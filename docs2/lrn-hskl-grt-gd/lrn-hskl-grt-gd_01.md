# 第一章 开始

如果你是不读前言的糟糕类型的人，你可能仍然想回去读最后一节——它解释了如何使用这本书，以及如何使用 GHC 加载函数。

首先，让我们启动 GHC 的交互模式并调用一些函数，这样我们就可以对 Haskell 有一个非常基本的了解。打开一个终端并输入 **`ghci`**。你会看到类似这样的内容：

```
GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
```

### 注意

GHCi 的默认提示符是 `Prelude>`，但我们将使用 `ghci>` 作为本书中示例的提示符。要使你的提示符与本书匹配，请在 GHCi 中输入 **`:set prompt "ghci> "`**。如果你不想每次运行 GHCi 都这样做，在你的主目录中创建一个名为 *.ghci* 的文件，并将其内容设置为 **`:set prompt "ghci> "`**。

恭喜你进入了 GHCi！现在让我们尝试一些简单的算术：

```
ghci> 2 + 15
17
ghci> 49 * 100
4900
ghci> 1892 - 1472
420
ghci> 5 / 2
2.5
```

![无标题图片](img/httpatomoreillycomsourcenostarchimages802506.png.jpg)

如果我们在一个表达式中使用多个运算符，Haskell 将按照考虑运算符优先级的顺序执行它们。例如，`*` 的优先级高于 `-`，所以 `50 * 100 - 4999` 被视为 `(50 * 100) - 4999`。

我们也可以使用括号来明确指定运算的顺序，如下所示：

```
ghci> (50 * 100) - 4999
1
ghci> 50 * 100 - 4999
1
ghci> 50 * (100 - 4999)
-244950
```

真的很酷，不是吗？（我知道现在还不是，但请耐心等待。）

要注意的一个陷阱是负数常量。始终最好在算术表达式中它们出现的地方用括号包围。例如，输入 `5 * -3` 会让 GHCi 大喊大叫，但输入 `5 * (-3)` 会正常工作。

布尔代数在 Haskell 中也很简单。像许多其他编程语言一样，Haskell 有布尔值 `True` 和 `False`，并使用 `&&` 运算符进行合取（布尔 *和*），使用 `||` 运算符进行析取（布尔 *或*），以及使用 `not` 运算符来否定 `True` 或 `False` 值：

```
ghci> True && False
False
ghci> True && True
True
ghci> False || True
True
ghci> not False
True
ghci> not (True && True)
False
```

我们可以使用 `==` 和 `/=` 运算符测试两个值的相等或不等，如下所示：

```
ghci> 5 == 5
True
ghci> 1 == 0
False
ghci> 5 /= 5
False
ghci> 5 /= 4
True
ghci> "hello" == "hello"
True
```

然而，在混合匹配值时要小心！如果我们输入类似 `5 + "llama"` 的内容，我们会得到以下错误信息：

```
No instance for (Num [Char])
arising from a use of `+' at <interactive>:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"
```

GHCi 告诉我们的是 `"llama"` 不是一个数字，所以它不知道如何将 5 加到它上面。`+` 运算符期望它的两个输入都是数字。

另一方面，`==` 运算符适用于任何可以比较的两个项目，有一个例外：它们都必须是相同类型的。例如，如果我们尝试输入 `True == 5`，GHCi 会抱怨。

### 注意

`5 + 4.0` 是一个有效的表达式，因为虽然 `4.0` 不是一个整数，但 `5` 很狡猾，可以像整数或浮点数一样行动。在这种情况下，`5` 适应以匹配浮点值 `4.0` 的类型。

我们稍后会更仔细地看看类型。

# 调用函数

![无标题图片](img/httpatomoreillycomsourcenostarchimages802508.png.jpg)

你可能没有意识到，但我们实际上一直在使用函数。例如，`*`是一个接受两个数字并将它们相乘的函数。正如你所看到的，我们通过将其夹在我们要相乘的两个数字之间来应用（或*调用*）它。这被称为中缀函数。

然而，大多数函数都是前缀函数。在 Haskell 中调用前缀函数时，函数名首先出现，然后是一个空格，然后是其参数（也用空格分隔）。例如，我们将尝试调用 Haskell 中最无聊的函数之一，`succ`：

```
ghci> succ 8
9
```

`succ`函数接受一个参数，可以是任何有明确定义的后继的值，并返回该值。整数值的后继只是下一个更大的数。

现在，让我们调用两个接受多个参数的前缀函数，`min`和`max`：

```
ghci> min 9 10
9
ghci> min 3.4 3.2
3.2
ghci> max 100 101
101
```

`min`和`max`函数各自接受两个参数，可以将它们按某种顺序排列（如数字！），并分别返回较小或较大的值。

函数应用在 Haskell 中具有所有操作的最高优先级。换句话说，这两个语句是等价的。

```
ghci> succ 9 + max 5 4 + 1
16
ghci> (succ 9) + (max 5 4) + 1
16
```

这意味着如果我们想得到`9 * 10`的后继，我们不能简单地写下

```
ghci> succ 9 * 10
```

由于运算符的优先级，这将评估为 9 的后继（即 10）乘以 10，得到 100。要得到我们想要的结果，我们需要输入

```
ghci> succ (9 * 10)
```

这返回了 91。

如果一个函数接受两个参数，我们也可以通过在其名称周围加上反引号（`` ` ``）将其作为中缀函数调用。例如，`div`函数接受两个整数并执行整数除法，如下所示：

```
ghci> div 92 10
9
```

然而，当我们这样称呼它时，可能会对哪个数字被哪个数字除产生一些混淆。通过使用反引号，我们可以将其称为中缀函数，突然间它似乎变得清晰多了：

```
ghci> 92 `div` 10
9
```

许多习惯于命令式语言的程序员倾向于坚持括号表示函数应用的观点，他们难以适应 Haskell 的方式。只需记住，如果你看到类似`bar (bar 3)`的东西，这意味着我们首先以`3`作为参数调用`bar`函数，然后将该结果传递给`bar`函数。在 C 语言中，等效的表达式可能是`bar(bar(3))`。

# 宝宝的第一函数

![无标题图片](img/httpatomoreillycomsourcenostarchimages802510.png.jpg)

函数定义的语法与函数调用类似：函数名后面跟着参数，参数之间用空格分隔。然后参数列表后面跟着`=`运算符，函数体由随后的代码组成。

例如，我们将编写一个简单的函数，该函数接受一个数字并将其乘以 2。打开你最喜欢的文本编辑器，输入以下内容：

```
doubleMe x = x + x
```

将此文件保存为 *baby.hs*。现在运行 `ghci`，确保 *baby.hs* 文件位于你的当前目录中。一旦进入 GHCi，输入 **`:l baby`** 来加载文件。现在我们可以玩我们的新函数：

```
ghci> :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci> doubleMe 9
18
ghci> doubleMe 8.3
16.6
```

因为 `+` 既可以作用于整数，也可以作用于浮点数（实际上，作用于任何可以被认为是数字的东西），所以我们的函数也可以与这些类型中的任何一种一起使用。

现在让我们编写一个函数，它接受两个数字，将每个数字乘以二，然后将它们相加。将以下代码添加到 *baby.hs* 文件中：

```
doubleUs x y = x * 2 + y * 2
```

### 注意

Haskell 中的函数不必按任何特定顺序定义，所以 *baby.hs* 文件中哪个函数先来并不重要。

现在保存文件，并在 GHCi 中输入 **`:l baby`** 来加载你的新函数。测试这个函数会产生可预测的结果：

```
ghci> doubleUs 4 9
26
ghci> doubleUs 2.3 34.2
73.0
ghci> doubleUs 28 88 + doubleMe 123
478
```

你定义的函数也可以相互调用。考虑到这一点，我们可以按以下方式重新定义 `doubleUs`：

```
doubleUs x y = doubleMe x + doubleMe y
```

这是在使用 Haskell 时你会看到的一个常见模式的简单示例：基本且显然正确的函数可以组合成更复杂的函数。这是一种避免代码重复的好方法。例如，如果有一天数学家发现 2 和 3 实际上是相同的，并且你必须更改你的程序，你只需将 `doubleMe` 重新定义为 `x + x + x`，由于 `doubleUs` 调用了 `doubleMe`，它现在也会在这个奇怪的、新的世界里自动正确地工作，在这个世界里 2 等于 3。

现在让我们编写一个函数，该函数将一个数字乘以 2，但仅当该数字小于或等于 100 时（因为大于 100 的数字已经足够大了！）。

```
doubleSmallNumber x = if x > 100
                        then x
                        else x*2
```

这个例子介绍了 Haskell 的 `if` 语句。你可能已经从其他语言中熟悉了 if 语句，但 Haskell 的独特之处在于 `else` 部分是强制性的。

命令式语言中的程序在程序运行时，计算机执行一系列步骤。当存在没有相应 `else` 的 `if` 语句且条件不满足时，那么属于 `if` 语句的步骤就不会被执行。因此，在命令式语言中，`if` 语句可以什么也不做。

另一方面，Haskell 程序是一系列函数的集合。函数用于将数据值转换为结果值，每个函数都应该返回某个值，这个值反过来又可以被另一个函数使用。由于每个函数都必须返回某些值，这意味着每个 `if` 都必须有一个相应的 `else`。否则，你可能会编写一个在满足某个条件时具有返回值但在不满足该条件时没有返回值的函数！简而言之：Haskell 的 `if` 是一个必须返回值的 *表达式*，而不是一个语句。

假设我们想要一个函数，该函数将 `doubleSmallNumber` 函数生成的每个数字加一。这个新函数的主体看起来像这样：

```
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
```

注意括号的放置。如果我们省略了它们，函数只会添加一个，如果 `x` 小于或等于 100。还要注意函数名末尾的单引号 (`'`)。单引号在 Haskell 的语法中没有特殊含义，这意味着它是一个有效的函数名字符。我们通常使用 `'` 来表示函数的*严格*版本（即不是懒加载的版本），或者是一个与类似名称的函数或变量的略微修改版本。

由于单引号 `'` 是函数名中的一个有效字符，我们可以编写一个看起来像这样的函数：

```
conanO'Brien = "It's a-me, Conan O'Brien!"
```

这里有两点需要注意。首先，我们没有在函数名中将 *Conan* 大写。在 Haskell 中，函数不能以大写字母开头。（我们稍后会看到原因。）其次，需要注意的是，这个函数没有接受任何参数。当一个函数不接受任何参数时，我们通常称其为*定义*或*名称*。因为我们一旦定义了名称（或函数），就不能更改它们的意思，所以函数 `conanO'Brien` 和字符串 `"It's a-me, Conan O'Brien!"` 可以互换使用。

# 列表简介

![无标题图片](img/httpatomoreillycomsourcenostarchimages802512.png.jpg)

Haskell 中的列表是*同构*数据结构，这意味着它们存储相同类型的多个元素。例如，我们可以有一个整数列表或字符列表，但不能有一个同时包含整数和字符的列表。

列表被方括号包围，列表值由逗号分隔：

```
ghci> let lostNumbers = [4,8,15,16,23,42]
ghci> lostNumbers
[4,8,15,16,23,42]
```

### 注意

使用 `let` 关键字在 GHCi 中定义名称。在 GHCi 中输入 `let a = 1` 等同于在脚本中写入 `a = 1`，然后使用 `:l` 加载它。

## 连接

当处理列表时，最常见的操作之一是连接。在 Haskell 中，这是使用 `++` 操作符完成的：

```
ghci> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci> "hello" ++ " " ++ "world"
"hello world"
ghci> ['w','o'] ++ ['o','t']
"woot"
```

### 注意

在 Haskell 中，字符串实际上只是字符列表。例如，字符串 `"hello"` 实际上与列表 `['h','e','l','l','o']` 相同。正因为如此，我们可以在字符串上使用列表函数，这非常方便。

当反复在长字符串上使用 `++` 操作符时要小心。当你组合两个列表时，Haskell 必须遍历整个第一个列表（`++` 左侧的列表）。当处理较小的列表时，这没问题，但将内容追加到包含五千万条记录的列表末尾将花费一些时间。

然而，将内容添加到列表的开头是一个几乎瞬时的操作。我们使用 `:` 操作符（也称为*cons*操作符）来完成这项操作：

```
ghci> 'A':" SMALL CAT"
"A SMALL CAT"
ghci> 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```

注意在第一个例子中，`:` 接受一个字符和一个字符列表（字符串）作为其参数。同样，在第二个例子中，`:` 接受一个数字和一个数字列表。`:` 操作符的第一个参数始终需要是列表中值的单个项目，并且与它被添加到的列表中的值类型相同。

另一方面，`++` 操作符始终接受两个列表作为参数。即使你只使用 `++` 向列表末尾添加单个元素，你也必须用方括号将其包围，这样 Haskell 才会将其视为列表：

```
ghci> [1,2,3,4] ++ [5]
[1,2,3,4,5]
```

将 `[1,2,3,4] ++ 5` 写作是错误的，因为 `++` 的两个参数都应该列表，而 `5` 不是一个列表；它是一个数字。

有趣的是，在 Haskell 中，`[1,2,3]` 只是 `1:2:3:[]` 的语法糖。`[]` 是一个空列表。如果我们向其中添加 `3`，它就变成了 `[3]`。然后如果我们向其中添加 `2`，它就变成了 `[2,3]`，依此类推。

### 注意

`[]`、`[[]]` 和 `[[],[],[]]` 都是不同的事物。第一个是一个空列表，第二个是一个包含一个空列表的列表，第三个是一个包含三个空列表的列表。

## 访问列表元素

如果你想通过索引获取列表中的元素，请使用 `!!` 操作符。与大多数编程语言一样，索引从 0 开始：

```
ghci> "Steve Buscemi" !! 6
'B'
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
```

然而，如果你尝试（比如说）从一个只有四个元素的列表中获取第六个元素，你会得到一个错误，所以请小心！

## 列表嵌套

列表可以包含列表作为元素，列表可以包含包含列表的列表，依此类推。 . . .

```
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci> [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci> b !! 2
[1,2,2,3,4]
```

列表中的列表可以有不同的长度，但它们不能有不同的类型。就像你不能有一个包含一些字符和一些数字作为元素的列表一样，你也不能有一个包含一些字符列表和一些数字列表的列表。

## 比较列表

如果列表中包含的项可以进行比较，则可以比较列表。当使用 `<`、`<=`、`>=` 和 `>` 来比较两个列表时，它们按字典顺序进行比较。这意味着首先比较两个列表的头部，如果它们相等，则比较第二个元素。如果第二个元素也相等，则比较第三个元素，依此类推，直到找到不同的元素。两个列表的顺序由第一对不同元素的顺序决定。

例如，当我们评估 `[3,4,2] < [3,4,3]` 时，Haskell 会看到 `3` 和 `3` 是相等的，所以它比较 `4` 和 `4`。这两个也是相等的，所以它比较 `2` 和 `3`。`2` 小于 `3`，所以它得出结论，第一个列表小于第二个列表。对于 `<=`、`>=` 和 `>` 也是如此。

```
ghci> [3,2,1] > [2,1,0]
True
ghci> [3,2,1] > [2,10,100]
True
ghci> [3,4,2] < [3,4,3]
True
ghci> [3,4,2] > [2,4]
True
ghci> [3,4,2] == [3,4,2]
True
```

此外，非空列表始终被认为大于空列表。这使得两个列表的排序在所有情况下都定义良好，包括当一个列表是另一个列表的正确初始段时。

## 更多列表操作

这里有一些更基本的列表函数，以及它们使用示例。

`head` 函数接受一个列表并返回其头部，或第一个元素：

```
ghci> head [5,4,3,2,1]
5
```

`tail` 函数接受一个列表并返回其尾部。换句话说，它切掉了列表的头部：

```
ghci> tail [5,4,3,2,1]
[4,3,2,1]
```

`last` 函数返回列表的最后一个元素：

```
ghci> last [5,4,3,2,1]
1
```

`init` 函数接受一个列表并返回除了其最后一个元素之外的所有内容：

```
ghci> init [5,4,3,2,1]
[5,4,3,2]
```

为了帮助我们可视化这些函数，我们可以将列表想象成一个怪物，如下所示：

![无标题图片](img/httpatomoreillycomsourcenostarchimages802514.png.jpg)

但如果我们尝试获取一个空列表的头部会发生什么呢？

```
ghci> head []
*** Exception: Prelude.head: empty list
```

哇——它在我们面前爆炸了！如果没有怪物，它就没有头部。当使用`head`、`tail`、`last`和`init`时，要小心不要在空列表上使用它们。这个错误在编译时无法捕获，因此总是好的做法是预防意外地让 Haskell 给你从空列表中获取元素。

`length`函数接受一个列表并返回其长度：

```
ghci> length [5,4,3,2,1]
5
```

`null`函数检查列表是否为空。如果是，它返回`True`，否则返回`False`。

```
ghci> null [1,2,3]
False
ghci> null []
True
```

`reverse`函数反转列表：

```
ghci> reverse [5,4,3,2,1]
[1,2,3,4,5]
```

`take`函数接受一个数字和一个列表。它从列表的开头提取指定数量的元素，如下所示：

```
ghci> take 3 [5,4,3,2,1]
[5,4,3]
ghci> take 1 [3,9,3]
[3]
ghci> take 5 [1,2]
[1,2]
ghci> take 0 [6,6,6]
[]
```

如果我们尝试获取比列表中元素更多的元素，Haskell 会返回整个列表。如果我们获取 0 个元素，我们会得到一个空列表。

`drop`函数的工作方式类似，但它只从列表的开头删除（最多）指定数量的元素：

```
ghci> drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci> drop 0 [1,2,3,4]
[1,2,3,4]
ghci> drop 100 [1,2,3,4]
[]
```

`maximum`函数接受可以按某种顺序排列的项目列表，并返回最大元素。`minimum`函数类似，但它返回最小项：

```
ghci> maximum [1,9,2,3,4]
9
ghci> minimum [8,4,2,1,5,6]
1
```

`sum`函数接受一个数字列表并返回它们的和。`product`函数接受一个数字列表并返回它们的乘积：

```
ghci> sum [5,2,1,6,3,2,5,7]
31
ghci> product [6,2,1,2]
24
ghci> product [1,2,5,6,7,9,2,0]
0
```

`elem`函数接受一个项目和项目列表，并告诉我们该项目是否是列表的元素。它通常被用作中缀函数，因为这样更容易阅读。

```
ghci> 4 `elem` [3,4,5,6]
True
ghci> 10 `elem` [3,4,5,6]
False
```

# 德克萨斯范围

![无标题图片](img/httpatomoreillycomsourcenostarchimages802516.png.jpg)

如果我们需要一个由 1 到 20 之间的数字组成的列表呢？当然，我们可以直接输入它们，但这不是对那些对他们的编程语言有卓越要求的绅士们的解决方案。相反，我们将使用*范围*。范围用于创建由可以*编号*或按顺序计数的元素组成的列表。

例如，数字可以进行编号：1, 2, 3, 4，等等。字符也可以进行编号：字母表是从 A 到 Z 的字符编号。然而，名字却不能进行编号。（“John”之后是什么？我不知道！）

要创建一个包含从 1 到 20 的所有自然数的列表，你只需输入`[1..20]`。在 Haskell 中，这与输入`[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`完全相同。这两者之间的唯一区别是手动编写长的编号序列是愚蠢的。

这里有一些更多的例子：

```
ghci> [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci> ['K'..'Z']
"KLMNOPQRSTUVWXYZ"
```

你也可以指定范围中元素之间的*步长*。如果我们想要一个包含 1 到 20 之间所有偶数的列表，或者 1 到 20 之间每隔一个数的列表呢？这只是一个用逗号分隔前两个元素并指定上限的问题：

```
ghci> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci> [3,6..20]
[3,6,9,12,15,18]
```

虽然它们非常方便，但带有步长的范围并不总是像人们期望的那样智能。例如，你不能输入 `[1,2,4,8,16..100]` 并期望得到所有不大于 100 的 2 的幂。首先，你只能指定一个步长大小。此外，一些不是算术的序列不能仅通过给出它们的前几个项来明确指定。

### 注意

要创建一个包含从 20 到 1 的所有数字的列表，你不能只输入 `[20..1]`，你必须输入 `[20,19..1]`。当你使用不带步长的范围（如 `[20..1]`）时，Haskell 将从空列表开始，然后不断将起始元素增加 1，直到它达到或超过范围的结束元素。因为 20 已经大于 1，所以结果将只是一个空列表。

你也可以通过不指定上限来使用范围创建无限列表。例如，让我们创建一个包含前 24 个 13 的倍数的列表。这是其中一种方法：

```
ghci> [13,26..24*13]
[13,26,39,52,65,78,91,104,117,130,143,156,169,
182,195,208,221,234,247,260,273,286,299,312]
```

但实际上有一个更好的方法——使用一个无限列表：

```
ghci> take 24 [13,26..]
[13,26,39,52,65,78,91,104,117,130,143,156,169,182,
195,208,221,234,247,260,273,286,299,312]
```

因为 Haskell 是*惰性*的，它不会立即尝试评估整个无限列表（这是好事，因为它永远不会完成）。相反，它将等待查看你需要从那个无限列表中获取哪些元素。在上面的例子中，它看到你只需要前 24 个元素，并且它很乐意满足你的要求。

这里有一些可以用来生成长列表或无限列表的函数：

+   `cycle`函数接受一个列表并无限复制其元素以形成一个无限列表。如果你尝试显示结果，它将永远继续，所以请确保在某个地方将其切片：

    ```
    ghci> take 10 (cycle [1,2,3])
    [1,2,3,1,2,3,1,2,3,1]
    ghci> take 12 (cycle "LOL ")
    "LOL LOL LOL "
    ```

+   `repeat`函数接受一个元素并生成一个只包含该元素的无限列表。这就像用一个只有一个元素的列表进行循环：

    ```
    ghci> take 10 (repeat 5)
    [5,5,5,5,5,5,5,5,5,5]
    ```

+   `replicate`是一个创建由单个元素组成的列表的更简单方法。它接受列表的长度和要复制的元素，如下所示：

    ```
    ghci> replicate 3 10
    [10,10,10]
    ```

关于范围的最后一点：在使用浮点数时要小心！因为浮点数，由于其本质，只有有限的精度，所以在范围内使用它们可能会得到一些相当奇怪的结果，就像你在这里看到的那样：

```
ghci> [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```

# 我是一个列表推导

![无标题图片](img/httpatomoreillycomsourcenostarchimages802518.png)

*列表推导*是一种过滤、转换和组合列表的方法。

它们与数学中的*集合推导*概念非常相似。集合推导通常用于从其他集合中构建集合。一个简单的集合推导示例是：{ 2 · *x*|*x* ∈ **N**, *x* ≤ 10}。这里使用的确切语法并不重要——重要的是这个语句说的是，“取所有小于或等于 10 的自然数，将每个数乘以 2，并使用这些结果创建一个新的集合。”

如果我们想在 Haskell 中写出相同的内容，我们可以使用列表操作：`take 10 [2,4..]`。然而，我们也可以使用列表推导来完成同样的事情，如下所示：

```
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```

让我们更仔细地看看这个例子中的列表推导式，以更好地理解列表推导式的语法。

在 `[x*2 | x <- [1..10]]` 中，我们说我们 *提取* 元素来自列表 `[1..10]`。`[x <- [1..10]]` 意味着 `x` 取每个从 `[1..10]` 中提取的元素的值。换句话说，我们将 `[1..10]` 中的每个元素 *绑定* 到 `x`。垂直管道（`|`）之前的部分是列表推导式的 *输出*。输出是我们指定我们希望提取的元素如何在结果列表中反映的部分。在这个例子中，我们说我们希望从列表 `[1..10]` 中提取的每个元素都加倍。

这可能看起来比第一个例子更长更复杂，但如果我们想要做的不仅仅是加倍这些数字，会怎么样呢？这正是列表推导式真正派上用场的地方。

例如，让我们在我们的理解中添加一个条件（也称为 *谓词*）。谓词位于列表推导式的末尾，并通过逗号与理解的其他部分分开。假设我们只想包含那些在加倍后大于或等于 12 的元素：

```
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```

如果我们想要所有 50 到 100 之间，除以 7 余数为 3 的数字，会怎样？很简单：

```
ghci> [ x | x <- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94]
```

### 注意

使用谓词去除列表的部分也称为 *过滤*。

现在来看另一个例子。假设我们想要一个理解，将大于 10 的奇数替换为 `"BANG!"`，将小于 10 的奇数替换为 `"BOOM!"`。如果一个数字不是奇数，我们就将其从列表中排除。为了方便，我们将这个理解放入一个函数中，这样我们就可以轻松地重用它：

```
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
```

### 注意

记住，如果你试图在 GHCi 中定义这个函数，你必须在函数名之前包含一个 `let`。然而，如果你在脚本中定义这个函数，然后将其加载到 GHCi 中，你就不需要与 `let` 糟糕地打交道。

当传递一个奇数给 `odd` 函数时，它返回 `True`，否则返回 `False`。只有当所有谓词评估为 `True` 时，元素才包含在列表中。

```
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"]
```

我们可以包含尽可能多的谓词，所有谓词都由逗号分隔。例如，如果我们想要所有 10 到 20 之间的数字，但不包括 13、15 或 19，我们会这样做：

```
ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]
```

不仅可以在列表推导式中包含多个谓词，还可以从几个列表中提取值。当从几个列表中提取值时，这些列表的所有元素组合都会反映在结果列表中：

```
ghci> [x+y | x <- [1,2,3], y <- [10,100,1000]]
[11,101,1001,12,102,1002,13,103,1003]
```

在这里，`x`是从`[1,2,3]`中抽取的，而`y`是从`[10,100,1000]`中抽取的。这两个列表以以下方式组合。首先，`x`变为`1`，当`x`为`1`时，`y`取`[10,100,1000]`中的每一个值。因为列表推导式的输出是`x+y`，所以值`11`、`101`和`1001`被添加到结果列表的开头（`1`被添加到`10`、`100`和`1000`）。之后，`x`变为`2`，同样的事情发生，导致元素`12`、`102`和`1002`被添加到结果列表中。当`x`抽取值`3`时，情况也是如此。

以这种方式，列表`[1,2,3]`中的每个元素`x`都会与列表`[10,100,1000]`中的每个元素`y`以所有可能的方式组合，使用`x+y`来生成这些组合的结果列表。

这里还有一个例子：如果我们有两个列表`[2,5,10]`和`[8,10,11]`，并且我们想要得到那些列表中所有可能数字组合的乘积，我们可以使用以下推导式：

```
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
```

如预期的那样，新列表的长度是 9。现在，如果我们想得到所有大于 50 的可能乘积呢？我们只需添加另一个谓词：

```
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110]
```

为了达到史诗般的幽默效果，让我们创建一个结合形容词列表和名词列表的列表推导式。

```
ghci> let nouns = ["hobo","frog","pope"]
ghci> let adjectives = ["lazy","grouchy","scheming"]
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"]
```

我们甚至可以使用列表推导式来编写我们自己的`length`函数版本！我们将它称为`length'`。这个函数将列表中的每个元素替换为`1`，然后使用`sum`将它们全部加起来，得到列表的长度。

```
length' xs = sum [1 | _ <- xs]
```

在这里，我们使用下划线（`_`）作为临时变量来存储我们从中提取的项目，因为我们实际上并不关心这些值。

记住，字符串也是列表，所以我们可以使用列表推导式来处理和生成字符串。以下是一个函数的示例，它接受一个字符串并从中删除所有小写字母：

```
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

这个谓词在这里做了所有的工作。它表示，只有当字符是列表`['A'..'Z']`的元素时，它才会被包含在新列表中。我们可以在 GHCi 中加载这个函数并测试它：

```
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS"
```

如果你在操作包含列表的列表，你也可以创建嵌套的列表推导式。例如，让我们取一个包含几个数字列表的列表，并移除所有奇数而不展开列表：

```
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```

这里外层列表推导式的输出是另一个列表推导式。列表推导式总是产生某种列表，所以我们可以知道这里的输出将是一个数字列表的列表。

### 注意

你可以将列表推导式拆分到多行以提高其可读性。如果你不在 GHCi 中，这可以是一个很大的帮助，尤其是在处理嵌套推导式时。

# 元组

![无标题图片](img/httpatomoreillycomsourcenostarchimages802520.png)

*元组*用于存储多个异构元素作为单个值。

在某些方面，元组与列表非常相似。然而，有一些基本区别。首先，如前所述，元组是异构的。这意味着单个元组可以存储几种不同类型的元素。其次，元组具有固定的大小——你需要提前知道你将存储多少个元素。

元组被圆括号包围，并且它们的组件由逗号分隔：

```
ghci> (1, 3)
(1,3)
ghci> (3, 'a', "hello")
(3,'a',"hello")
ghci> (50, 50.4, "hello", 'b')
(50,50.4,"hello",'b')
```

## 使用元组

作为元组何时有用的例子，让我们考虑在 Haskell 中如何表示二维向量。一种方法是将两个项目列表表示为 `[x,y]`。但是，假设我们想要创建一个向量列表，以表示坐标平面中二维形状的角。我们可以简单地创建一个列表的列表，如下所示：`[[1,2],[8,11],[4,5]]`。

然而，这种方法的问题是我们也可以创建一个列表，如 `[[1,2],[8,11,5],[4,5]]` 并尝试将其用作向量列表。尽管它作为向量列表没有意义，但 Haskell 没有问题地将此列表出现在之前列表可以出现的地方，因为它们都是同一类型（数字的列表的列表）。这可能会使编写操作向量和形状的函数变得更加复杂。

相反，大小为二的元组（也称为*对*）和大小为三的元组（也称为*三元组*）被视为两种不同的类型，这意味着列表不能由对和三元组组成。这使得元组在表示向量时非常有用。

我们可以通过用圆括号而不是方括号包围它们来将向量更改为元组，如下所示：`[(1,2),(8,11),(4,5)]`。现在，如果我们尝试混合成对和三元组，我们会得到一个错误，如下所示：

```
ghci> [(1,2),(8,11,5),(4,5)]
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```

Haskell 还认为具有相同长度但包含不同类型数据的元组是不同的元组类型。例如，你不能创建一个包含元组的列表，如 `[(1,2),("One",2)]`，因为第一个是数字的对，而第二个是包含字符串后跟数字的对。

元组可以用来轻松地表示各种数据。例如，如果我们想在 Haskell 中表示某人的姓名和年龄，我们可以使用一个三元组：`("Christopher", "Walken", 55)`。

记住，元组的大小是固定的——你应该只在事先知道你需要多少个元素时才使用它们。元组之所以如此严格，是因为，如前所述，元组的大小被视为其类型的一部分。不幸的是，这意味着你不能编写一个通用的函数来向元组追加元素——你需要为追加到对（以产生三元组）编写一个函数，为追加到三元组（以产生四元组）编写另一个函数，为追加到四元组编写另一个函数，依此类推。

与列表一样，如果它们的组件可以比较，元组可以相互比较。然而，与列表不同，你不能比较不同大小的两个元组。

虽然存在单元素列表，但没有单元素元组。当你这么想的时候，这是有道理的：单元素元组的属性将仅仅是它包含的值的属性，所以区分新的类型不会给我们带来任何好处。

## 使用对

在 Haskell 中，以对的形式存储数据非常常见，并且有一些有用的函数来操作它们。以下是对对进行操作的两种函数：

+   `fst`接受一个对并返回其第一个组件：

    ```
    ghci> fst (8, 11)
    8
    ghci> fst ("Wow", False)
    "Wow"
    ```

+   `snd`接受一个对并——惊喜！——返回其第二个组件：

    ```
    ghci> snd (8, 11)
    11
    ghci> snd ("Wow", False)
    False
    ```

### 注意

这些函数只对对进行操作。它们不会在三元组、四元组、五元组等上工作。我们稍后会介绍从元组中提取数据的不同方法。

`zip`函数是一种产生对列表的酷方法。它接受两个列表，然后将它们“压缩”成一个列表，通过将匹配的元素组合成对来实现。这是一个非常简单的函数，但它可以在你想要以特定方式组合两个列表或同时遍历两个列表时非常有用。以下是一个演示：

```
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1..5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```

注意，由于对可以包含不同类型的元素，`zip`可以接受包含不同类型元素的两个列表。但如果列表的长度不匹配会发生什么呢？

```
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
```

正如你在上面的例子中看到的，只有与所需的一样多的较长列表被使用——其余的只是被忽略。而且因为 Haskell 使用惰性求值，我们甚至可以将有限列表与无限列表`zip`：

```
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
```

## 寻找直角三角形

让我们用一个结合元组和列表解析的问题来结束。我们将使用 Haskell 找到一个符合所有这些条件的直角三角形：

+   三边的长度都是整数。

+   每条边的长度都小于或等于 10。

+   三角形的周长（边长的总和）等于 24。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802522.png.jpg)

如果一个三角形的一个角是直角（90 度角），那么这个三角形就是直角三角形。直角三角形有一个有用的性质：如果你平方形成直角的边的长度，然后将这些平方相加，那么这个和等于与直角相对的边的长度的平方。在图片中，与直角相邻的边被标记为`a`和`b`，与直角相对的边被标记为`c`。我们称那个边为*斜边*。

作为第一步，让我们生成所有可能的由小于或等于 10 的元素组成的三元组：

```
ghci> let triples = [ (a,b,c) | c <- [1..10], a <- [1..10], b <- [1..10] ]
```

我们在理解右侧的三个列表中抽取，输出表达式左侧将它们组合成一个三元组列表。如果你在 GHCi 中评估`triples`，你会得到一个包含 1,000 个条目的列表，所以我们在这里不会显示它。

接下来，我们将通过添加一个检查勾股定理（`a² + b² == c²`）是否成立的谓词来过滤掉不代表直角三角形的三角形。我们还将修改函数以确保边`a`不大于斜边`c`，并且边`b`不大于边`a`：

```
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a],
a² + b² == c²]
```

注意我们如何改变了从列表中抽取值的范围。这确保了我们不会检查不必要的三角形，例如边`b`大于斜边（在直角三角形中，斜边总是最长的边）的情况。我们还假设边`b`永远不会大于边`a`。这不会造成任何损害，因为对于每个被排除在外的、满足`a² + b² == c²`和`b` > `a`的三角形`(a,b,c)`，都会包含三角形`(b,a,c)`——只是边长顺序相反。（否则，我们的结果列表将包含实际上是相同三角形的成对三角形。）

### 注意

在 GHCi 中，你不能将定义和表达式拆分到多行。然而，在这本书中，我们偶尔需要将单行拆分，以便代码可以全部适合在页面上。（否则这本书会非常宽，无法放在任何正常的书架上——然后你就得买更大的书架了！）

我们几乎完成了。现在，我们只需要修改函数，使其只输出周长等于 24 的三角形：

```
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10],
 a <- [1..c], b <- [1..a], a² + b² == c², a+b+c == 24]
ghci> rightTriangles'
[(6,8,10)]
```

我们的答案就在这里！这是函数式编程中的一种常见模式：你从一个特定的候选解决方案集合开始，然后依次对这些解决方案应用转换和过滤，直到将可能性缩小到你想要的那个（或几个）解决方案。
