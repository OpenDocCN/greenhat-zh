# 第六章. 字符串工具

![字符串工具](img/00001.jpg)

使用 Ruby 操作文本非常简单；你可能已经见过 Ruby 的字符串方法，如`capitalize`、`upcase`、`downcase`和`swapcase`。在本章中，我们将扩展这些方法，为文本处理任务（如搜索、操作和创建文档）创建一个更强大的工具集。

# PDF 生成器

## PDF 生成器

### pdfGen.rb

PDF 文件提供了一种出色的数据展示方式。使用 PDF *(便携式文档格式)* 文件的一些优点包括平台独立性、查看一致性以及丰富的免费阅读软件选择。PDF 文件已成为互联网上信息交换的标准；我甚至将我的简历转换成了 PDF 格式，以便潜在雇主能够看到我希望他们看到的内容。此脚本将向您展示如何创建自己的 PDF 文件，而无需昂贵的软件。

## 代码

## 运行代码

要运行此脚本，请输入：

``**`ruby pdfGen.rb`**``

## 结果

执行脚本后，寻找一个名为 *book_review.pdf* 的 PDF 文件。该文件的格式将类似于 图 6-1 中所示的形式。

![book_review.pdf 的内容](img/00016.jpg)

图 6-1. book_review.pdf 的内容

## 工作原理

对于这个脚本，我们依赖于 PDF:Writer 库将普通文本转换为 PDF。这个库作为一个 gem 提供，因此你可以使用命令 `gem install pdf-writer` 轻松安装它。为了开始脚本，我们包含了 `pdf/writer`，以便稍后创建 PDF 文件，以及 `pdf/simpletable`，因为我们将在文档中添加一个表格！[](../Images/00002.jpg)。接下来，创建一个名为 `PDF` 的对象并将其保存到一个名为 `pdf` 的变量中！[](../Images/00003.jpg)。

我们正在创建一个表单，该表单将被用来收集关于这本书的宝贵客户反馈信息。PDF:Writer 库的默认文本字体是 Times New Roman，我明确地编写了字体代码作为提醒，即字体可以被更改。你可以将其更改为 `Courier`、`Helvetica` 或 `Times-Roman`。我们在 PDF 文档中添加了一个标题，并将其字体设置为 25 点，以便它可以从其他文本中区分出来。PDF 文件的下一段区域将是一个包含特定于书籍信息的表格。

我们创建一个 `SimpleTable` 对象，随后是一个代码块，该代码块将数据填充到表格中！[](../Images/00004.jpg)。虽然表格可以有任意多的列和行，但我们将使用两列，标题为 *问题* 和 *回答*。为了使表格更具美观性，并为顾客提供更多回答每个问题的空间，我将 `问题` 的宽度（即填充每个问题所需的最小字符宽度，以避免在问题列中浪费空间）设置为 `100`。表格的其余部分将用于顾客的回答。我们自定义了六个表格属性，并且得益于 Ruby 的易于理解的命名约定，自定义与方法名称匹配。这些属性将决定最终表格的外观。在表格属性之后的代码部分是初始化表格中的问题的地方！[](../Images/00005.jpg)。表格创建的最后一步是将它渲染出来。使用 `render_on` 方法将表格渲染到 `pdf` 变量中。

现在表格已经创建，脚本开始提出几个问题，这些问题都有不同的预期答案类型！[](../Images/00006.jpg)。问题部分的一个值得注意的方面是使用 `circle_at` 方法创建的圆圈！[](../Images/00007.jpg)。该方法需要三个参数。前两个参数是以 (*x*, *y*) 格式的起始坐标。第三个参数是圆的半径。当第一次调用 `circle_at` 时，绘图指针位于文档的末尾。为了使圆圈向上移动一行，y 坐标设置为 `pdf.y+5`。x 坐标增加以匹配相应的数字 *0* 到 *5*。为了保存 Ruby——我是指 Ruby——所做的大量工作，我们调用 `save_as` 方法，它确实做到了它所说的！[](../Images/00008.jpg)。文档被保存为 *book_review.pdf*。

# 单词频率

## 单词频率

### wordFreq.rb

此脚本将扫描文本文件并计算文档中每个单词出现的次数。从文档中提取单词计数或单词频率有几个原因。一个例子是用于对使用移位密码加密的密文进行密码分析。我发现单词频率在我的写作中也很有趣。运行此脚本可以显示我使用最频繁的单词，经过一些调整，可以显示那些不是我的日常词汇的单词。

## 代码

`![](img/00002.jpg) unless ARGV[0]      puts "\n 你需要包含一个文件进行测试。"      puts "用法：ruby wordFreq.rb file_to_test.txt"      exit  end  ![](img/00003.jpg) unless File.exist?(ARGV[0])      puts "\n 文件未找到，请检查路径。"      puts "用法：ruby wordFreq.rb file_to_test.txt"      exit  end   file = ARGV[0]  words = Hash.new(0) ![](img/00004.jpg) File.open(file, "r").each_line do |line| ![](img/00005.jpg)     line.scan(/\b\w+\b/) {|i| words[i] += 1}  end  ![](img/00006.jpg) sorted = words.sort_by {|a| a[1] }   temp = sorted.length  ![](img/00007.jpg) 10.times do      temp -= 1      puts "\"#{sorted[temp][0]}\" 出现了 #{sorted[temp][1]} 次"  end`

## 运行代码

通过键入以下命令执行此脚本：

```**`ruby wordFreq.rb`** **``*`/path/to/file/`*``**```

我运行了这个脚本，针对本书的第一章，看看会发生什么。我以为 *Ruby* 可能是前十大热门词汇之一，但除了常见的嫌疑人（例如，*the*，*to* 和 *is*）之外，单词 *script* 竟然悄悄地出现在了使用最频繁的 10 个单词列表中。谁能想到呢？

## 结果

结果输出到 $stdout，但也可以轻松地将它们输出到文本文件或 PDF 文件：

`"the" 出现了 513 次 "to" 出现了 156 次 "is" 出现了 128 次 "script" 出现了 126 次 "a" 出现了 118 次 "file" 出现了 107 次 "and" 出现了 94 次 "you" 出现了 87 次 "of" 出现了 81 次 "in" 出现了 70 次`

## 工作原理

脚本开始于一个检查，以确保用户已经输入了一个用于单词频率分析的文件名 ![图片](img/00002.jpg)。接下来，脚本会检查传入的文件名确实是一个文件，并且该文件是可访问的 ![图片](img/00003.jpg)。从第一个参数创建一个 `file` 对象并初始化一个名为 `words` 的哈希后，文件被打开，每一行都被读入一个块 ![图片](img/00004.jpg)。尽管块中只有一行，但那一行中正在进行许多不同的操作。关于这些多个操作的一个非常酷的部分是，它们被压缩成了一行，但仍然对人类来说很容易阅读 ![图片](img/00005.jpg)。对于文件中的每一行，内容都使用 `scan` 方法进行解析，或扫描。由于脚本正在跟踪每个单词的出现次数，这种方法允许脚本隔离单个单词。这个方法将匹配正则表达式的每个单词传递到另一个块（也位于同一行）。有趣的是，如果不需要块，可以直接将匹配项放入数组。但是，由于我们需要进行一些额外的操作，我们在行尾添加了一个块。

对于传递给块的每个单词，都会引用 `words` 哈希，如果单词存在，则键值增加一。如果单词之前没有遇到过，则初始化值并将键设置为计数一。在一行代码中根据文件中每个单词的出现次数填充哈希表是相当酷的。也许你在数学或统计学课程中遇到过 *直方图* 这个术语？这个脚本创建了一个简单的直方图，显示了给定文件中使用的单词比例。

到目前为止，`words` 哈希已经完全填充，剩下要做的就是输出重要信息。脚本使用名为 `sort_by` 的方法（它是 Enumerable 库的一部分）根据键对 `words` 中的值进行排序。`sort_by` 方法将排序相应的哈希，并返回一个多维数组，其中包含原始哈希中每个元素的键和值 ![图片](img/00006.jpg)。最后的块打印多维数组中的最后 10 个数组；这对应于文本文件中出现频率最高的 10 个单词 ![图片](img/00007.jpg)。

## 黑客脚本

最简单的黑客攻击方法是将脚本转换为分析文本文件中的字母。字母频率也用于密码分析。在谷歌上简单搜索一下，会发现英语中最常用的字母是 *e*。

一种稍微不同的方法可能是添加*停用词*。停用词是指在显示结果之前被移除的词。你可以移除像*the*、*to*、*is*、*of*、*as*等常见术语。此外，这个脚本可能是贝叶斯垃圾邮件过滤器的一个简单起点。贝叶斯垃圾邮件过滤器之所以强大，是因为它们可以识别垃圾邮件中出现的单词，并从这些单词中构建一个档案。我相信你可以想到一两个在垃圾邮件中常见的单词……比如与扩大这个或免费那个有关的内容。对垃圾邮件进行档案化是帮助用户获取合法电子邮件的一个工具。

# 逗号分隔值解析器

## 逗号分隔值解析器

### csv.rb

在我们的数字世界中，逗号分隔值（CSV）文件非常普遍。它们被用于各个地方，许多程序都有在 CSV 格式中输入或输出信息的函数。甚至微软的大多数产品都支持 CSV 格式！

这个脚本将向你展示如何在 CSV 文件中用逗号分隔数据后自定义数据输出。这将导致对数据的更有意义的解释。有两个库可以帮助你处理 CSV 文件：第一个是旧的 Ruby CSV 库标准，第二个是一个名为 FasterCSV 的库。我将向你展示如何使用 FasterCSV 并将其无缝集成到你的脚本中。只需注意，当你升级到 1.8 以上时，FasterCSV 将被纳入标准库。这两个库的使用方法非常相似；如果你需要升级或阅读旧的 Ruby CSV 代码，你根本不必担心。

我们可以使用`split`方法来修改我们自己的 CSV 库；但既然你已经看到了其他使用`split`的脚本，我们将介绍一些新且更高效的方法。为了使这个脚本更具体，假设你有一个由某些超先进金融分析软件（如 Excel 或 QuickBooks）输出的金融 CSV 文件。你必须弄清楚如何处理这些数据，所以你的第一个想法是咨询 Ruby！这就是*简单*的样子：

## 代码

`require 'faster_csv' ![图片](img/00002.jpg) unless ARGV[0] puts "用法：ruby csv.rb <文件名.ext>" puts "示例：ruby csv.rb comma.separated" exit unless File.exist?(ARGV[0]) puts "\n 文件未找到，请检查路径。" puts "用法：ruby csv.rb comma.separated" exit ![图片](img/00003.jpg) file = FasterCSV.open(ARGV[0], "r") print "文件是否包含标题信息（y/n）？ ![图片](img/00004.jpg)" h = $stdin.gets.chomp if h.downcase == 'y' ![图片](img/00005.jpg) header = file.shift print header.join("\t") ![图片](img/00006.jpg) file.each do |line| puts print line.join("\t") end else ![图片](img/00007.jpg) print "输入标题信息（以逗号分隔）：" header = $stdin.gets.strip header = header.split(",") ![图片](img/00008.jpg) header.each do |h| print h + "\t" end file.each do |line| puts line.each do |element| print element + "\t" end end end`

## 运行代码

通过输入以下命令运行脚本：

```**`ruby csv.rb`** **``*`comma_separated.file`*``** Does the file include header information (y/n)? **``*`y`*``**```

## 结果

为了测试这个脚本，我从一家财务报告网站上下载了一个包含关于谷歌信息的 CSV 文件。结果显示了 2004 年谷歌公开交易的前几天。自那时起，公司已经变得极其盈利，但这显示了谷歌刚开始时的价值。

`日期       开盘价      最高价      最低价      收盘价      成交量 2004-09-01 102.70     102.97     99.67      100.25     4573700 2004-08-31 102.30     103.71     102.16     102.37     2461400 2004-08-30 105.28     105.49     102.01     102.01     2601000 2004-08-27 108.10     108.62     105.69     106.15     3109000 2004-08-26 104.95     107.95     104.66     107.91     3551000 2004-08-25 104.96     108.00     103.88     106.00     4598900 2004-08-24 111.24     111.60     103.57     104.87     7631300 2004-08-23 110.75     113.48     109.05     109.40     9137200 2004-08-20 101.01     109.08     100.50     108.31     11428600 2004-08-19 100.00     104.06     95.96      100.34     22351900`

## 工作原理

脚本是为两种类型的 CSV 文件编写的：第一行有表头的文件和纯数据的文件。脚本将 CSV 文件作为唯一参数，首先检查文件是否存在以确保正确执行 ![图片 00002](img/00002.jpg)。接下来，脚本使用 faster_csv 库打开文件 ![图片 00003](img/00003.jpg)。文件打开后，脚本会询问用户关于表头信息，以便确定要遵循的代码部分 ![图片 00004](img/00004.jpg)。如果文件确实包含表头信息，则执行 `if` 语句的第一部分。假设 CSV 文件包含表头，第一项任务是删除表头，以便 faster_csv 可以施展其魔法。表头通过 `shift` 方法删除，并将值存储在变量 `header` 中 ![图片 00005](img/00005.jpg)。

解析表头后，脚本继续处理 CSV 文件的核心部分。如果您还记得之前的内容，我们初始化变量 `file` 为一个 FasterCSV 对象，该对象读取要解析的 CSV 文件。暂时回到基础，每一行包含可能或可能没有填充每个字段的数据。FasterCSV 库的语法很棒，因为代码与其他文件操作脚本非常相似。声明了一个代码块，为 CSV 文件中的每一行输出一个换行符。然后，对于每一行的每个元素，输出以制表符结束，以实现清晰的显示 ![图片 00006](img/00006.jpg)。并不复杂。FasterCSV 库使得处理 CSV 文件变得轻而易举，这也结束了第一个路径。

如果您有一个没有表头的原始 CSV 文件，可能您想添加自己的表头以方便使用或提高可读性。如果是这样，那么您会对询问表头的提问回答 **`no`**。然后脚本就知道要询问表头名称而不是尝试从 CSV 文件中读取它们 ![图片 00007](img/00007.jpg)。用户然后输入每个表头，用逗号分隔。表头创建后，脚本的其余部分运行，就像之前的路径 ![图片 00008](img/00008.jpg)。

## 修改脚本

由于这个脚本的简单性，没有太多技巧，但在 Ruby 编码中，有两件事可以作为很好的练习。第一是压缩脚本同时保持可读性。首先应该查看的地方是解析表头的地方。另一个同样有益的练习是对输出进行格式化以处理各种情况。目前，由于使用了制表符，如果某些元素字段太宽，信息可能会错位。此外，您还可以使用 CSV 文件将输出到另一个文件，用于许多其他用途。我让脚本直接输出数据，因为我的数据集不是很大，并且很容易在终端窗口中阅读。查看接下来的几节，它们基于解析 CSV 文件的基本思想。

# CSV 转换为 XML

## CSV 转换为 XML

### csvToXML.rb

如果你想要将信息填充到网络上，*可扩展标记语言 (XML)* 是一个很好的格式。XML 之所以如此酷，是因为该格式允许不同的系统使用开发者设计的通用格式来共享数据。此脚本将读取 CSV 文件中存储的信息，而不是仅仅将注释输出到用户的终端，而是生成一个 XML 文件。

## 代码

`![图片](img/00002.jpg)require 'faster_csv' ![图片](img/00003.jpg)print "CSV file to read: " infile = gets.strip ![图片](img/00004.jpg)print "What do you want to call each element: " record_name = gets.strip ![图片](img/00005.jpg)print "What do you want to title the XML document: " title = gets.strip ![图片](img/00006.jpg)print "What do you want to call the set of elements: " set = gets.strip ![图片](img/00007.jpg)file = FasterCSV.open(infile, "rb") ![图片](img/00008.jpg)header = file.shift ![图片](img/00009.jpg)File.open(File.basename(infile, ".*") + ".xml", 'wb') do |ofile| ![图片](img/00010.jpg)   ofile.puts '<?xml version="1.0"?>'   ofile.puts "<#{set}>"   ofile.puts "\t<name>#{title}</name>" ![图片](img/00011.jpg)   file.each do |record|       ofile.puts "\t<#{record_name}>"       for i in 0..(header.size - 1)           ofile.puts "\t\t<#{header[i]}>#{record[i]}</#{header[i]}>"       end       ofile.puts "\t</#{record_name}>"     end     ofile.puts "</#{set}>" end`

## 运行代码

要运行此脚本，请输入：

```**`ruby csvToXML.rb`** CSV file to read: **``*`employees.csv`*``** What do you want to call each element: **``*`names`*``** What do you want to title the XML document: **``*`Employees at Wicked Cool Ruby`*``** What do you want to call the set of elements: **``*`people`*``**```

## 结果

以下是你将在生成的 XML 文件中找到的内容：

`<?xml version="1.0"?> <people>    <name>Employees at Wicked Cool Ruby</name>    <names>        <first>Steve</first>        <last>Pugh</last>    </names>    <names>        <first>John</first>        <last>Doe</last>    </names> </people>`

## 工作原理

在这个脚本上稍微改变一下方向，我们不会从命令行传递任何信息到脚本中。像其他一些脚本一样，这个脚本将提示用户输入每个需要的数据，以完美地将 CSV 文件转换为 XML 文件。

再次，脚本将使用更快的 _csv 库 ![图片](img/00002.jpg)。 (如果你需要关于 faster_csv 操作的复习，请参阅 Comma-Separated Value Parser 中的“#38 Comma-Separated Value Parser”。) 在脚本接触 CSV 文件之前，需要指定一些信息。为了理解每个变量的原因，了解 XML 文档的结构很有帮助。我会指导你自行研究 XML 文档 ([`www.w3.org/XML/Core/#Publications/`](http://www.w3.org/XML/Core/#Publications/))。

第一个用户提示将获取 CSV 文件的名称并存储在`infile` ![图片](img/00003.jpg)。接下来，`record_name`将保存元素类型的值。XML 文件还需要一个标题，它存储在变量`title`中。最后，每个元素需要一个集合名称，它将存储在`set`中。

现在，脚本准备开始解析 CSV 文件并从头开始创建 XML 文档。第一个操作是打开 CSV 文件并将`faster_csv`对象存储在`file`中！![图片](img/00004.jpg)。脚本假设标题信息包含在 CSV 文件中，因此使用`shift`方法移除标题并存储在`header`中！![图片](img/00005.jpg)。接下来，通过使用 CSV 文件的基文件名并附加*.xml*扩展名来创建 XML 文件。使用典型的 XML 版本标签，脚本开始创建文档！![图片](img/00006.jpg)。

XML 文档中的每个元素都将有一个开标签和一个闭标签，因此脚本关闭它打开的每个标签是很重要的。`version`语句、设置名称和文档标题都将输出到名为`ofile`的 XML 文件中！![图片](img/00007.jpg)。接下来，每个记录将被创建！![图片](img/00008.jpg)。CSV 文件中的每一行都是一个记录，并且标题将决定每个记录包含多少个元素。在开始记录标签之后，每个元素都会用相应的标题名称进行标记！![图片](img/00009.jpg)。这个过程会重复应用于 CSV 文件中的每一行。一旦 CSV 文件被完全处理，脚本开始最终化关闭标签。当脚本退出时，XML 文件将完全形成，并准备好被整合到您所设想的内容中。

## 修改脚本

使用 XML 文件时，可能性是无限的。首先想到的是编辑脚本以处理不包含标题的文件。参见之前的 CSV 脚本以获得起点。另一个技巧是与网站集成，使用 XML 文件与层叠样式表（CSS）一起格式化输出。您可以设置一个网站，根据这个小脚本的输出动态更新。结果将是一个 XML 文件，当与 CSS 和 HTML 结合时，可以即时生成一个漂亮的网页。将此脚本与"#30 Flash Cards"结合使用，在 Flash Cards 上创建基于 XML 风格的网页式闪卡。

# Ruby Grep

## Ruby Grep

### rubyGrep.rb

想象一下这个场景：您在硬盘上的多个目录中存储了数百个文件——所有这些文件都很重要，并且包含与一个研究项目相关的信息。当您正在整合最终的报告时，您记得阅读了一篇论文中的一个图表，但您不确定它在哪篇论文中，更不用说它在哪个文件夹中了。怎么办？再次阅读文件？是的，没错！首先要做的是不要担心！第二件事是获取这个脚本的副本并运行它。这个脚本将允许您自动打开文件并读取内容，以闪电般的速度定位您所需的信息。

## 代码

` require 'English' ![](img/00002.jpg) unless ARGV[0]      puts "\nYou need to include a value to search for."      puts "Usage: ruby rubyGrep.rb \"value_to_search\" '**/*'"      exit  end   pattern = ARGV[0]  glob = ARGV[1]  ![](img/00003.jpg) Dir[glob].each do |file|      next unless File.file?(file)![](img/00004.jpg)         File.open(file, "rb") do |f| ![](img/00005.jpg)             f.each_line do |line| ![](img/00006.jpg)                  puts "#{File.expand_path(file)}: #{$INPUT_LINE_NUMBER}:  #{line}" if line.include?(pattern)          end      end  end`

## 运行代码

要运行此脚本，请输入：

``**`ruby rubyGrep.rb`** *`value_to_search where_to_search`* **`ruby rubyGrep.rb entropy '*'`**``

## 结果

为了本例的目的，我在 Ruby 脚本目录中搜索，以找出哪些脚本提到了单词*熵*，我在密码强度测试脚本中使用了这个单词。我只找到一个包含任何*熵*引用的脚本，搜索工作得非常完美。结果如下所示：

`C:/Steven.Pugh/Scripts/complete/password.rb: 22: entropy =  -1 * letters.keys.inject(0.to_f) do |sum, k| C:/Steven.Pugh/Scripts/complete/password.rb: 32: puts "\nThe entropy value is: #{entropy}"`

## 它是如何工作的

这个脚本的优雅之处在于其简洁性。它只使用了一个名为 English 的库，并且支持输出行号。即使没有这个库，脚本也可以运行，但不会包含行号。脚本首先检查是否已经指定了搜索字符串和搜索位置！[](../Images/00002.jpg)。当然，如果你什么也不搜索，你每次都会找到，所以请确保包含一个有意义的搜索模式。

要开始搜索目录，使用库 Dir 遍历在`ARGV[1]`中指定的目录内的每个文件，并将其保存在`glob`变量中！[](../Images/00003.jpg)。使用`'**/*'`表示法告诉`Dir`方法，我们想要递归地搜索当前目录及其所有子目录，并在搜索过程中扫描模式。如果你只想搜索当前目录而不搜索子目录，你可以向`Dir`方法提供`'*'`。`each`方法指的是我们在指定目录中找到的每个文件。当然，如果你只想搜索 HTML 文件，你可以在 glob 中添加一个扩展名，例如`'*.html'`。这个简单的语句允许脚本操作符合特定标准的每个单个文件。非常强大。

脚本的下一步是决定对每个文件执行什么操作。我们已经知道我们想要搜索特定的字符串，因此脚本需要打开每个文件。接下来的代码块将每个文件以只读方式打开，并将二进制内容传递给变量 `f` ![图片](img/00004.jpg)。然后使用 `each_line` 方法逐行搜索。变量 `line` 保存数据行 ![图片](img/00005.jpg)。然后一条长行会拉取所有相关数据以供用户显示 ![图片](img/00006.jpg)。我们将更仔细地分析这条线。为了读取该行，我们必须从优先级顺序开始，即该行的最后一个 `if` 语句 [`if line.include?(pattern)`]。一个重要的注意事项是，如果 `if` 语句评估为 `false`，意味着没有找到模式，则整行将被跳过。如果该行包含指定的模式，则评估该行的其余代码。为了做到这一点，我们需要回到行的开头，脚本会扩展文件路径并显示找到发生的位置的行号。

在运行此脚本时请记住，搜索可以是多么有创意，只要你想。如果你要搜索的文件恰好位于更高的目录或另一个分支的一部分，你需要在启动脚本时考虑到这一点。

## 漏洞脚本

我已经提到了几个你可以修改此脚本的地方，比如搜索其他文件类型和脚本的位置。此脚本也可以轻松地集成到其他脚本中，或者单独使用。

# 密码检查

## 密码检查

### password.rb

你认为你的密码安全吗？哈哈哈！！！我只是在开玩笑；我不知道你的密码是否安全，但这个脚本会给你一个相当不错的想法。它基于数学证明——数字不会说谎！试试这个脚本，确保在运行时没有人从你身后偷看，因为你的密码不会被隐藏。请注意，输出中没有包含基于字典的攻击；只考虑了熵和暴力破解。

## 代码

`![图片](img/00002.jpg) 除非 ARGV[0] puts "您需要包含一个密码进行测试。" puts "用法: ruby password.rb mySuperSecretPassword" exit  end ![图片](img/00003.jpg) password = ARGV[0] ![图片](img/00004.jpg) word = password.split(//) ![图片](img/00005.jpg) letters = Hash.new(0.0) ![图片](img/00006.jpg) set_size = 96 ![图片](img/00007.jpg) word.each do |i|     letters[i] += 1.0 end ![图片](img/00008.jpg) letters.keys.each do |j|     letters[j] /= word.length end ![图片](img/00009.jpg) entropy = -1 * letters.keys.inject(0.to_f) do |sum, k|     sum + (letters[k] * (Math.log(letters[k])/Math.log(2.to_f))) end ![图片](img/00011.jpg) combinations = 96 ** password.length   days = combinations.to_f / (10000000 * 86400)   years = days / 365   puts "\n 熵值是：#{entropy}" ![图片](img/00012.jpg)   puts "\n 并且需要大约 ~ #{days < 365 ? "#{days.to_i} 天" : "#{years.to_i} 年"} 来暴力破解密码"`

## 运行代码

要运行此脚本，请输入：

```**`ruby password.rb`** **``*`mySuperSecretPassword`*``**```

## 结果

我实际上运行了这个脚本，密码是 *RubyScr1pt5*，结果还不错：

`熵值是：3.4594316186373 并且需要大约 ~ 20238436 年来暴力破解密码`

## 它是如何工作的

这个密码脚本实际上是将两个概念结合在一起的一个非常酷的脚本。第一个是基于香农熵的熵计算。这个脚本将计算你密码的不确定性度量。如果你不喜欢希腊字母或自然对数，你会很高兴地知道我不会证明熵计算。如果你真的想看方程式，它下面有，但我们假设计算是可靠的。

脚本的第二部分基于计算机需要多长时间才能暴力破解或猜测你的密码。在计算中做了几个假设；为了确保脚本符合现实，你应该检查数学计算。我会指出你应该关注的地方。

首先，脚本以密码作为第一个参数运行。只要包含密码，脚本就会继续分析密码 ![图片](img/00002.jpg)。第一步是初始化一些稍后使用的变量。变量 `password` 将自然地包含用户的密码 ![图片](img/00003.jpg)。下一个变量 `word` 将包含构成用户密码的字符数组 ![图片](img/00004.jpg)。这是通过非常有用的方法 `split` 实现的。由于香农熵的计算涉及每个字母出现的概率，因此创建了一个哈希，其中将包含每个字母的一个实例作为键，以及下一个字母被选中的相应概率作为值。这个哈希称为 `letters` ![图片](img/00005.jpg)。请注意，这与单词频率中的“#37 单词频率”非常相似。

最后初始化的变量是`set_size` ![图片](img/00006.jpg)。集合的大小很重要，因为它决定了猜测用户密码所需的时间长度。我默认的集合大小是 96，这对应于一个包含混合大小写字母、数字以及美国键盘上所有常见符号的集合。你可以使用 62 的集合大小用于字母数字，26 用于仅包含小写或大写字母，10 用于数字。你的集合大小由你的密码策略预先确定。

要开始计算香农熵，通过计算每个特定字符的实例来填充哈希`letters` ![图片](img/00007.jpg)。接下来，将哈希中每个元素的值除以密码长度，以计算该字母出现的概率 ![图片](img/00008.jpg)。现在脚本已经有了计算密码混乱程度的所需所有信息。记住，混乱程度越高，猜测密码就越困难。还要注意，由相同符号重复组成的长度为*n*的密码将具有 0 的熵。用简单的话说，香农熵的计算是（负一）乘以（每个哈希元素的概率之和）乘以（哈希元素概率的自然对数之和）除以（2 的自然对数） ![图片](img/00009.jpg)。

将哈希元素的概率的自然对数除以 2 的自然对数的原因是为了考虑信息熵的自然单位。这种除法将从一个对数底数计算出`log2`。你还在吗？计算结果应该在两到四之间，存储在`entropy`中。

现在已经计算出了用户密码的香农熵，剩下要确定的是猜测这个密码需要多长时间。计算这个值的方法是知道你每秒将进行多少次猜测，然后计算在集合大小中的可能组合数。在这个脚本中，给定一个固定大小的密码，比如说八个字符，然后将这个数字提高到集合中字符数的幂。在这个例子中，你会将 96 提高到 8 的幂，结果将存储在`combinations`中 ![图片](img/00011.jpg)。接下来，你需要将计算机每秒将进行的猜测次数乘以一天中的秒数（一天有 86,400 秒）。

`combinations = 96 ** password.length  days = combinations.to_f / (10000000 * 86400)  years = days / 365`

我假设每秒 10,000,000 次尝试，这将使用高速双核处理器。如果你使用任何像[`www.picocomputing.com/`](http://www.picocomputing.com/)上找到的*现场可编程门阵列（FPGA）*，那么每秒的尝试次数将显著增加。

将组合数除以每天猜测的次数，将得到猜测用户密码所需的天数，该密码存储在变量 `days` 中。然后，你可以将天数除以一年中的天数（365），以得到猜测用户密码所需的时间（年数）；输出结果存储在 `years` 中。

最终输出将是熵的计算和猜测用户密码所需的时间长度。为了更有效的输出，并且因为一些密码可能在几天内就被猜出，我使用了三元表示法，即如果天数少于 365，则输出天数；否则输出年数 ![图片](img/00012.jpg)。这是一种优雅的条件显示时间的方法。

## 操纵脚本

你可以通过隐藏密码并将脚本纳入你的密码策略来破解此脚本。一个重要的补充是，密码破解不仅限于上述讨论的技术。另一种主要攻击是基于字典的攻击。虽然对于具有显著长度的强密码，数学运算对我们有利，但攻击者可以利用人类可预测性在破解密码时获得一些优势——选择 `password` 作为密码将非常容易受到字典攻击的破解。密码对于安全来说非常重要，因此了解如何衡量其强度有许多应用。
