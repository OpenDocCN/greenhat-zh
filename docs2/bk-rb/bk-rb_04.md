# 第四章 数组和哈希

![无标题图片](img/httpatomoreillycomsourcenostarchimages860138.png.jpg)

到目前为止，你通常一次只使用一个对象。在本章中，你将了解如何创建一个对象列表。你将从查看最常见的列表结构类型：数组开始。

# 数组

一个*数组*是一个按顺序排列的项目集合，其中每个项目都可以通过索引来访问。在 Ruby（与许多其他语言不同），一个数组可以包含混合数据类型的项目，例如字符串、整数和浮点数，甚至是一个返回某些值的函数调用。例如，这里显示的 `a1` 的最后一个元素调用了我的方法 `array_length`，它返回数组的长度 `a0`：

*array0.rb*

```
def array_length( anArray )
    return anArray.length
end

a0 = [1,2,3,4,5]
a1 = [1,'two', 3.0, array_length( a0 ) ]
p( a1 )        #=>[1, "two", 3.0, 5]
```

数组中的第一个项目具有索引 0，这意味着最后一个项目的索引等于数组中项目总数减 1。给定前面显示的数组 `a1`，这是获取第一个和最后一个项目值的方法：

```
a1[0]        # returns 1st item (at index 0)
a1[3]        # returns 4th item (at index 3)
```

你已经使用过数组几次——例如，在 *2adventure.rb* 中，你使用数组存储 Room 对象的映射：

```
mymap = Map.new([room1,room2,room3])
```

## 创建数组

与许多其他编程语言一样，Ruby 使用方括号来界定数组。你可以轻松地创建一个数组，用一些以逗号分隔的值填充它，并将其赋给一个变量：

```
arr = ['one','two','three','four']
```

就像 Ruby 中的大多数其他事物一样，数组是对象。它们由 Array 类定义，就像字符串一样，它们从 0 开始索引。你可以通过放置其索引在方括号中来引用数组中的项目。如果索引无效，则返回 `nil`：

*array1.rb*

```
arr = ['a', 'b', 'c']
puts(arr[0])      # shows 'a'
puts(arr[1])      # shows 'b'
puts(arr[2])      # shows 'c'
puts(arr[3])      # nil
```

显示 nil

当你尝试使用 `print` 或 `puts` 显示 `nil` 值时，Ruby 1.8 显示 `nil`，而 Ruby 1.9 显示一个空字符串。如果你想确保显示 `nil` 的字符串表示，请使用 `p` 或 `inspect` 方法而不是 `print`。你也可以显示它的类（`nil` 是 `NilClass` 的实例）或使用 `nil?` 方法来测试它是否为 `nil`：

```
puts(arr[3].inspect)     #=> nil
puts(arr[3].class)       #=> NilClass
p(arr[3])                #=> nil
puts(arr[3].nil?)        #=> true
```

*array1.rb*

一个数组可能包含产生值的表达式。假设你已经创建了以下方法：

*array2.rb*

```
def hello
  return "hello world"
end
```

你现在可以声明这个数组：

```
x = [1+2, hello, `dir`]
```

在这里，第一个元素是一个产生整数 3 的数学表达式，第二个是字符串 “hello world”（由 `hello` 方法返回）。如果你在 Windows 上运行它，第三个数组元素将是一个包含目录列表的字符串。这是因为 `` `dir` `` 是一个反引号字符串，它由操作系统执行（见 第三章）。因此，数组的最后一个“槽位”被 `dir` 命令返回的值填充，它恰好是一系列文件名。如果你在不同的操作系统上运行，你可能需要在此处替换一个适当的命令。（例如，如果你在类 Unix 操作系统上运行，你可以用 `` `ls` `` 替换以获取类似的一串文件名。）

创建文件名数组

Ruby 的一些类有返回值数组的函数。例如，`Dir`类，用于在磁盘目录上执行操作，有`entries`方法。将目录名传递给该方法，它将返回一个包含文件的数组：

```
Dir.entries( 'C:\\' )  # returns an array of files in C:\
```

*dir_array.rb*

如果你想要创建一个单引号字符串的数组，但又懒得输入所有的引号，可以使用在`%w`（或使用大写的`%W`来表示双引号字符串，如第三章中解释的）前带有括号的空格分隔的未引用文本的快捷方式。

*array2.rb*

```
y = %w( this is an array of strings )
```

以下代码将显示在变量`y`旁边的数组分配：

```
["this", "is", "an", "array", "of", "strings"]
```

你也可以使用通常的对象构造方法`new`来创建数组。可选地，你可以向`new`传递一个整数来创建一个特定大小的空数组（每个元素设置为`nil`），或者你可以传递两个参数：第一个用于设置数组的大小，第二个用于指定要放置在数组每个索引处的元素，如下所示：

```
a = Array.new                     # an empty array
a = Array.new(2)                  # [nil,nil]
a = Array.new(2,"hello world")    # ["hello world","hello world"]
```

## 多维数组

要创建一个多维数组，你可以创建一个数组，然后将其“槽位”中添加其他数组。例如，这创建了一个包含两个元素的数组，每个元素本身都是一个包含两个元素的数组：

```
a = Array.new(2)
a[0]= Array.new(2,'hello')
a[1]= Array.new(2,'world')
```

### 注意

你还可以通过将数组作为参数传递给`new`方法来创建一个数组对象。但请注意：如果你在`new`方法和开方括号之间没有留空格，Ruby 会将其视为语法错误。换句话说，这有效：`a = Array.new [1,2,3]`。然而，这不行：`a = Array.new[1,2,3]`。但是使用括号总是有效的，无论你放空格的位置在哪里：`a = Array.new([1,2,3])`。

你也可以使用方括号在数组内部嵌套数组。这创建了一个包含四个数组的数组，每个数组都包含四个整数：

```
a = [    [1,2,3,4],
    [5,6,7,8],
    [9,10,11,12],
    [13,14,15,16]  ]
```

在之前的代码中，我将四个“子数组”放在了不同的行上。这不是强制性的，但它确实有助于通过将每个子数组显示为类似电子表格中的行来澄清多维数组的结构。当谈论数组中的数组时，将每个嵌套数组称为“外部”数组的一行是很方便的。

为了查看使用多维数组的更多示例，请加载*multi_array.rb*程序。该程序首先创建一个包含两个其他数组的数组`multiarr`。这些数组中的第一个位于`multiarr`的索引 0 处，第二个位于索引 1 处：

*multi_array.rb*

```
multiarr = [['one','two','three','four'],[1,2,3,4]]
```

接下来，你需要找到一种方法来定位数组中的单个元素，这些数组本身又包含在其他数组中。你将在下一节中考虑这个问题。

## 遍历数组

您可以通过使用`for`循环遍历数组元素来访问数组元素。在许多编程语言中，`for`循环从起始数字（例如 0）开始计数，遍历固定数量的元素，直到结束数字（例如 10），并在每次循环迭代中递增计数器变量（例如`i`）。因此，在其他语言中，您可能习惯于编写类似这样的循环：`for i = 1 to 10`。

在 Ruby 中，正常的`for`循环遍历集合中的所有项目，可能被称为`for..in`循环。其计数器变量在每次循环迭代中逐个分配给集合中的每个对象。其语法可以总结为`for` *`anObject`* `in` *`aCollection`*，在每次循环迭代中，变量`anObject`从集合`aCollection`中分配一个新的项目，直到没有更多项目为止。下面显示的循环遍历两个元素，即索引 0 和 1 的两个子数组：

```
for i in multiarr
    puts(i.inspect)
end
```

这将显示以下内容：

```
["one", "two", "three", "four"]
[1, 2, 3, 4]
```

那么，您如何遍历两个子数组中的项目（字符串和整数）？如果有固定数量的项目，您可以为每个指定不同的迭代器变量，在这种情况下，每个变量将分配与匹配数组索引的值。

这里您有四个子数组槽位，因此您可以使用四个变量，如下所示：

```
for (a,b,c,d) in multiarr
    print("a=#{a}, b=#{b}, c=#{c}, d=#{d}\n" )
end
```

您还可以使用`for`循环逐个遍历每个子数组中的所有项目：

*multi_array2.rb*

```
for s in multiarr[0]
   puts(s)
end
for s in multiarr[1]
   puts(s)
end
```

这两种技术（多个迭代器变量和多个`for`循环）有两个要求：您知道网格数组中的“行”或“列”中有多少个项目，并且每个子数组包含的项目数量与其他子数组相同。

为了更灵活地遍历多维数组，您可以使用嵌套`for`循环。外层循环遍历每一行（子数组），内层循环遍历当前行中的每个项目。这种技术在子数组具有不同数量的项目时也有效：

```
for row  in multiarr
   for item in row
     puts(item)
   end
end
```

在下一章中，您将更深入地了解`for`循环和其他迭代器。

## 数组索引

与字符串（见第三章        #=> hello (or) ["h", "e", "l", "l", "o"]
print( arr[-5,5 ] )      #=> world (or) ["w", "o", "r", "l", "d"]
print( arr[0..4] )       #=> hello (or) ["h", "e", "l", "l", "o"]
print( arr[-5..-1] )     #=> world (or) ["w", "o", "r", "l", "d"]
```

注意，`print`或`puts`显示的输出可能因 Ruby 版本的不同而有所差异。当 Ruby 1.8 显示数组中的元素时，它们一个接一个地显示，看起来像单个字符串，例如`hello`。然而，Ruby 1.9 却以数组格式显示项目，例如`["h", "e", "l", "l", "o"]`。

如果您使用`p`而不是`print`来检查数组，Ruby 1.8 和 1.9 将显示相同的结果：

```
p( arr[0,5] )     #=> ["h", "e", "l", "l", "o"]
p( arr[0..4] )    #=> ["h", "e", "l", "l", "o"]
```

与字符串一样，当你提供两个整数以从数组中返回连续的项目数量时，第一个整数是起始索引，而第二个是项目的 *数量*（*不是* 索引）：

```
arr[0,5]    # returns 5 chars - ["h", "e", "l", "l", "o"]
```

你也可以通过索引数组来进行赋值。例如，我首先创建一个空数组，然后将项目放入索引 0、1 和 3。索引 2 的“空”槽位将被 `nil` 值填充：

*array_assign.rb*

```
arr = []

arr[0] = [0]
arr[1] = ["one"]
arr[3] = ["a", "b", "c"]

# arr now contains:
# [[0], ["one"], nil, ["a", "b", "c"]]
```

再次强调，你可以使用起始-结束索引、范围和负索引值：

```
arr2 = ['h','e','l','l','o',' ','w','o','r','l','d']

arr2[0] = 'H'
arr2[2,2] = 'L', 'L'
arr2[4..6] = 'O','-','W'
arr2[-4,4] = 'a','l','d','o'

# arr2 now contains:
# ["H", "e", "L", "L", "O", "-", "W", "a", "l", "d", "o"]
```

## 复制数组

注意，当你使用赋值运算符（`=`）将一个数组变量赋值给另一个变量时，你实际上是在赋值一个 *引用* 到数组；你并没有创建一个副本。例如，如果你将一个名为 `arr1` 的数组赋值给另一个名为 `arr2` 的数组，对任意一个变量的任何更改也会改变另一个变量的值，因为 *两个变量都引用了同一个数组*。如果你想使变量引用两个不同的数组，你可以使用 `clone` 方法来创建一个新的副本：

*array_copy.rb*

```
arr1=['h','e','l','l','o',' ','w','o','r','l','d']
arr2=arr1  # arr2 is now the same as arr1.
           # Change arr1 and arr2 changes too!
arr3=arr1.clone
           # arr3 is a copy of arr1.
           # Change arr3 and arr2 is unaffected
```

## 测试数组是否相等

数组的比较运算符是 `<=>`。这比较两个数组——我们可以称它们为 `arr1` 和 `arr2`。如果 `arr1` 小于 `arr2`，则返回 −1；如果 `arr1` 和 `arr2` 相等，则返回 0；如果 `arr2` 大于 `arr1`，则返回 1。但是 Ruby 如何确定一个数组是否“大于”或“小于”另一个数组呢？它会比较一个数组中的每个项目与另一个数组中相应项目的比较结果。当两个值不相等时，返回它们的比较结果。换句话说，如果进行如下比较：

```
[0,10,20] <=> [0,20,20]
```

会返回值 −1。这意味着第一个数组“小于”第二个数组，因为第一个数组索引 1 的整数（10）小于第二个数组索引 1 的整数（20）。

如果你想要根据数组的长度而不是其元素的值进行比较，你可以使用 `length` 方法：

```
#  Here [2,3,4].length is less than [1,2,3,4].length
p([1,2,3].length<=>[1,2,3,4].length)    #=> −1
p([2,3,4].length<=>[1,2,3,4].length)    #=> −1
```

如果你正在比较字符串数组，那么比较是基于构成这些字符串的字符的 ASCII 值进行的。如果一个数组比另一个数组长，并且两个数组中的元素都相等，那么较长的数组被认为是“大于”。然而，如果比较了这样的两个数组，并且较短的数组中的一个元素大于较长的数组中相应的元素，那么被认为是“大于”的是 *较短的* 数组。

*array_compare.rb*

```
p([1,2,3]<=>[2,3,4])            #=> −1     (array 1 < array 2)
p([2,3,4]<=>[1,2,3])            #=> 1      (array 1 > array 2)
p([1,2,3,4]<=>[1,2,3])          #=> 1      (array 1 > array 2)all
p([1,2,3,4]<=>[100,200,300])    #=> −1     (array 1 < array 2)
p([1,2,3]<=>["1","2","3"])      #=> nil    (invalid comparison)
```

## 数组排序

`sort`方法使用比较运算符`<=>`比较相邻的数组元素。这个运算符为许多 Ruby 类定义，包括 Array、String、Float、Date 和 Fixnum。然而，这个运算符并不是为所有类定义的（也就是说，它不是为所有其他类派生的 Object 类定义的）。这个不幸的后果之一是，它不能用于包含`nil`值的数组排序。然而，可以通过定义自己的排序例程来克服这种限制。这是通过向`sort`方法发送一个*块*来完成的。你将在第十章中详细了解块，但就现在而言，你需要知道的是，块是一段由花括号或`do`和`end`关键字分隔的代码块。以下块确定了`sort`方法使用的比较方式：

```
arr.sort{
  |a,b|
    a.to_s <=> b.to_s
}
```

在这里`arr`是一个数组对象，变量`a`和`b`代表两个连续的数组元素。我已经使用`to_s`方法将每个变量转换为字符串；这会将`nil`转换为空字符串，这将按“低”排序。请注意，尽管我的排序块定义了数组项的排序顺序，但它并没有改变数组项本身。因此，`nil`将保持为`nil`，整数将保持为整数。字符串转换仅用于实现比较，而不是改变数组项。

*array_sort.rb*

```
arr = ['h','e','l','l','o',' ',nil,'w','o','r','l','d',1,2,3,nil,4,5]

# sort ascending from nil upwards
sorted_arr = arr.sort{
    |a,b|
        a.to_s <=> b.to_s
    }

p(sorted_arr )
```

这是前一段代码创建并显示的数组：

```
[nil, nil, " ", 1, 2, 3, 4, 5, "d", "e", "h", "l", "l", "l", "o", "o", "r", "w"]
```

代码存档中提供的*array_sort.rb*程序还包含一个用于降序排序的方法。这是通过改变比较运算符两边的项目顺序来实现的：

```
reverse_sorted_arr = arr.sort{
    |a,b|
        b.to_s <=> a.to_s
    }
```

## 比较值

比较运算符“操作符”`<=>`（实际上是一个方法）定义在名为`Comparable`的 Ruby 模块中。目前，你可以将模块视为一种可重用的代码库。你将在第十二章中更详细地了解模块。

你可以在自己的类中包含`Comparable`模块。这让你可以重写`<=>`方法，以便你能够精确地定义特定对象类型之间的比较方式。例如，你可能想创建一个 Array 的子类，以便比较仅基于两个数组的长度，而不是基于数组中每个项的值（这是默认情况，如 See Testing Arrays for Equality 中所述）。以下是你可以这样做的示例：

*comparisons.rb*

```
class MyArray < Array
  include Comparable

  def <=> ( anotherArray )
    self.length <=> anotherArray.length
  end
end
```

现在，你可以这样初始化两个 MyArray 对象：

```
myarr1 = MyArray.new([0,1,2,3])
myarr2 = MyArray.new([1,2,3,4])
```

你可以使用 MyArray 中定义的`<=>`方法进行比较：

```
# Two MyArray objects
myarr1 <=> myarr2        #=> 0
```

这个比较返回 0，表示两个数组相等（因为我们的`<=>`方法仅根据长度来评估相等性）。另一方面，如果你用完全相同的整数值初始化两个标准数组，数组类的自身`<=>`方法将执行比较：

```
# Two Array objects
arr1 <=> arr2        #=> −1
```

这里比较返回 -1，这表示第一个数组评估为“小于”第二个数组，因为 Array 类的 `<=>` 方法比较 `arr1` 中每个项目的数值，这些数值小于 `arr2` 中相同索引处的项目值。

但如果你想要使用传统的编程符号进行“小于”、“等于”和“大于”的比较呢？

```
<                 # less than
==                # equal to
>                 # greater than
```

在 MyArray 类中，你可以进行此类比较而无需编写任何额外的代码。这是因为 `Comparable` 模块已被包含在 MyArray 类中，并自动提供这三个比较方法；每个方法都基于 `<=>` 方法的定义进行比较。由于我们的 `<=>` 方法基于数组中项目的数量进行评估，因此当第一个数组比第二个数组短时，`<` 方法评估为 true，当两个数组长度相等时，`==` 评估为 true，当第二个数组比第一个数组长时，`>` 评估为 true：

```
p( myarr1 < myarr2 )      #=> false
p( myarr1 == myarr2 )     #=> true
```

标准的 Array 类不包含 `Comparable` 模块。所以如果你尝试使用 `<`、`==` 或 `>` 比较两个普通数组，Ruby 将显示一个错误消息，告诉你该方法未定义。

然而，很容易将这些三个方法添加到 Array 的子类中。你只需要包含 Comparable，如下所示：

```
class Array2 < Array
  include Comparable
end
```

Array2 类现在将根据 Array 的 `<=>` 方法进行比较——也就是说，通过测试存储在数组中的项目的值，而不是仅仅测试数组的长度。假设 Array2 对象 `arr1` 和 `arr2` 使用与之前用于 `myarr1` 和 `myarr2` 相同的数组初始化，你现在会看到以下结果：

```
p( arr1 < arr2 )        #=> true
p( arr1 > arr2 )        #=> false
```

## 数组方法

一些标准数组方法会修改数组本身，而不是返回数组的修改副本。这些包括带有终止感叹号标记的方法，例如 `sort!`、`reverse!`、`flatten!` 和 `compact!`。这些还包括 `<<` 方法，它通过向其左侧的数组添加右侧的数组来修改左侧的数组；`clear`，它从给定的数组中移除所有元素；以及 `delete` 和 `delete_at`，它们移除选定的元素。表 4-1 展示了一些更常用的数组方法。

表 4-1. 常用数组方法

| Array | 任务 |
| --- | --- |
| `&` | 返回两个数组的公共元素，不包含重复项 |
| `+` | 返回连接两个数组的数组 |
| `-` | 返回从第一个数组中移除第二个数组中项目的数组 |
| `<<` | 通过从第二个数组中追加项目来修改第一个数组 |
| `clear` | 通过移除所有元素来修改数组 |
| `compact` | 返回移除 `nil` 项的数组 |
| `compact!` | 通过移除 `nil` 项来修改数组 |
| `delete( object )` | 通过删除对象来修改数组 |
| `delete_at( index )` | 通过删除索引处的项目来修改数组 |
| `flatten` | 解包嵌套数组元素并返回数组 |
| `flatten!` | 通过解包嵌套数组元素修改数组 |
| `length` | 返回数组中的元素数量 |
| `reverse` | 返回元素顺序相反的数组 |
| `reverse!` | 通过反转元素顺序修改数组 |
| `sort` | 使用 `<=>` 返回排序后的数组 |
| `sort!` | 通过 `<=>` 修改排序后的数组 |

你可以在 *array_methods.rb* 示例程序中尝试之前的方法。以下是一些示例：

*array_methods.rb*

```
arr1 = [1,1,2,2,3,3]
arr2 = [1,2,3,4,5,6,7,8,9]
arr3 = ['h','e','l','l','o',' ',nil,'w','o','r','l','d']

p(arr1&arr2 )       #=> [1, 2, 3]
p(arr1+arr2)        #=> [1, 1, 2, 2, 3, 3, 1, 2, 3, 4, 5, 6, 7, 8, 9]
p(arr1-arr2)        #=> []
p(arr2-arr1)        #=> [4, 5, 6, 7, 8, 9]
arr1<<arr2
p(arr1)             #=> [1, 1, 2, 2, 3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]]
arr1.clear
p(arr1)             #=>[]
```

虽然大多数数组方法的行为可以从其名称中推断出来，但 `flatten` 和 `compact` 方法需要一些解释。当数组不包含子数组时，我们说它被 *扁平化*。所以如果你有一个像 `[1,[2,3]]` 这样的数组，你可以调用 `[1,[2,3]].flatten` 来返回这个数组：`[1,2,3]`。

当数组不包含 `nil` 项时，我们说它被 *压缩*。所以如果你有一个像 `[1,2,nil,3]` 这样的数组，你可以调用 `[1,2,nil,3].compact` 来返回这个数组：`[1,2,3]`。可以通过将一个方法调用直接放在另一个方法调用之后来将 Array 的方法链接在一起：

*flatten_compact.rb*

```
p( [1,nil,[2,nil,3]].flatten.compact ) #=> [1,2,3]
```

# 哈希

尽管数组提供了按数字索引项目集合的好方法，但有时按其他方式索引它们会更方便。例如，如果你正在创建一个食谱集合，按名称索引每个食谱（例如，“丰富的巧克力蛋糕”和“红酒炖牛肉”）比按数字更有意义。

Ruby 有一个类允许你这样做，称为 *哈希*。这相当于其他语言中称为字典或关联数组的等效物。就像真正的字典一样，每个条目都通过一个唯一的 *键*（在现实生活中的字典中，这将是一个单词）来索引，该键与一个值（在字典中，这将是一个单词的定义）相关联。

## 创建哈希

就像数组一样，你可以通过创建 Hash 类的新实例来创建一个哈希：

*hash1.rb*

```
h1 = Hash.new
h2 = Hash.new("Some kind of ring")
```

之前的两个示例都创建了一个空的 Hash 对象。Hash 对象始终有一个默认值——也就是说，当在给定的索引处找不到特定值时返回的值。在这些示例中，`h2` 使用默认值 `"Some kind of ring"` 初始化；`h1` 没有初始化值，因此它的默认值将是 `nil`。

创建了 Hash 对象后，你可以使用类似数组的语法向其中添加项——也就是说，通过放置索引在方括号内并使用 `=` 来赋值。明显的区别是，在数组中，索引（或 *键*）必须是整数；在哈希中，它可以是任何唯一的数据项：

```
h2['treasure1'] = 'Silver ring'
h2['treasure2'] = 'Gold ring'
h2['treasure3'] = 'Ruby ring'
h2['treasure4'] = 'Sapphire ring'
```

通常，键可能是一个数字，或者在之前的代码中是一个字符串。然而，原则上，键可以是任何类型的对象。例如，给定某个类 X，以下赋值是完全合法的：

```
x1 = X.new('my Xobject')
h2[x1] = 'Diamond ring'
```

唯一键？

在将键分配给哈希时请小心。如果你在哈希中使用相同的键两次，你最终会覆盖原始值。这就像在数组中相同的索引处两次赋值一样。考虑以下示例：

```
h2['treasure1'] = 'Silver ring'
h2['treasure2'] = 'Gold ring'
h2['treasure3'] = 'Ruby ring'
h2['treasure1'] = 'Sapphire ring'
```

这里使用了两次键 `'treasure1'`。因此，原始值 `'Silver ring'` 被替换为 `'Sapphire ring'`，导致以下哈希：

```
{"treasure1"=>"Sapphire ring", "treasure2"=>"Gold ring", "treasure3"=>"Ruby ring"}
```

创建哈希并使用键值对初始化它们有一个简写方式。只需添加一个键后跟 `=>` 和其关联的值；每个键值对应该用逗号分隔，并将所有内容放在一对大括号内：

```
h1 = {    'room1'=>'The Treasure Room',
          'room2'=>'The Throne Room',
          'loc1'=>'A Forest Glade',
          'loc2'=>'A Mountain Stream' }
```

## 哈希索引

要访问一个值，请将其键放在方括号内：

```
puts(h1['room2'])            #=> 'The Throne Room'
```

如果你指定了一个不存在的键，将返回默认值。回想一下，你没有为 `h1` 指定默认值，但你已经为 `h2` 指定了：

```
p(h1['unknown_room'])        #=> nil
p(h2['unknown_treasure'])    #=> 'Some kind of ring'
```

使用 `default` 方法获取默认值，并使用 `default=` 方法设置它（有关 `get` 和 `set` 访问器方法的更多信息，请参阅第二章）：

```
p(h1.default)
h1.default = 'A mysterious place'
```

## 复制哈希

与数组一样，你可以将一个哈希变量赋给另一个，在这种情况下，两个变量都将引用同一个哈希，并且使用任一变量进行的更改将影响该哈希：

*hash2.rb*

```
h4 = h1
h4['room1']='A new Room'
puts(h1['room1'])        #=> 'A new Room'
```

如果你想让两个变量在不同的哈希对象中引用相同的项，请使用 `clone` 方法创建一个新的副本：

```
h5 = h1.clone
h5['room1'] = 'An even newer Room'
puts(h1['room1'])        #=> 'A new room' (i.e., its value is unchanged)
```

## 哈希顺序

哈希中元素的顺序根据你使用的 Ruby 版本而有所不同。在 Ruby 1.8 中，哈希通常按照其键定义的顺序存储，例如，键 1 小于键 2。当添加新项时，这些项将按键顺序插入。在 Ruby 1.9 中，哈希按照定义的顺序存储。当添加新项时，这些项将附加到哈希的末尾。

作为一般原则，最好不要对哈希中元素的顺序做出假设。大多数编程语言将哈希或字典视为无序集合。如果你假设哈希顺序是不可预测的，不仅会避免在运行不同 Ruby 实现的程序时可能出现的错误，而且还会避免当键的类型不同时可能出现的麻烦。记住，单个哈希可能包含整数、字符串和浮点键的混合，它们的相对顺序可能不明显。

*hash_order.rb*

```
h = {2=>"two", 1=>"one", 4=>"four" }
p( h )
h[3] = "three"
p( h )
h2 = {"one"=>1, 2=>"two", 4.5=>"four" }
p (h2)
```

当运行此代码时，Ruby 1.8 产生以下输出：

```
{1=>"one", 2=>"two", 4=>"four"}
{1=>"one", 2=>"two", 3=>"three", 4=>"four"}
{4.5=>"four", 2=>"two", "one"=>1}
```

但 Ruby 1.9 显示如下：

```
{2=>"two", 1=>"one", 4=>"four"}
{2=>"two", 1=>"one", 4=>"four", 3=>"three"}
{2=>"two", "one"=>1, 4.5=>"four"}
```

## 对哈希进行排序

如果你想确保哈希的元素按特定顺序排列，你可以对它们进行排序。与数组类一样，你可能会发现哈希的 `sort` 方法存在一些问题。它期望处理相同数据类型的键，因此，例如，如果你合并两个数组，其中一个使用整数键，另一个使用字符串键，你将无法对合并后的哈希进行排序。解决这个问题的方法，就像数组一样，是编写一些代码来执行自定义类型的比较，并将其传递给 `sort` 方法。你可能给它一个方法，如下所示：

*hash_sort.rb*

```
def sorted_hash( aHash )
  return aHash.sort{
    |a,b|
      a.to_s <=> b.to_s
  }
end
```

这是对哈希中每个键的字符串表示（`to_s`）进行排序。实际上，哈希的 `sort` 方法将哈希转换为嵌套数组，其中包含 `[key, value]` 数组，并使用数组 `sort` 方法进行排序。

## 哈希方法

哈希类有众多内置方法。例如，要使用其键从哈希中删除项，请使用 `delete` 方法：

```
aHash.delete( someKey )To test if a key or value exists, use the
 has_key? and has_value? methods:aHash.has_key?( someKey )
aHash.has_value?( someValue )
```

要合并两个哈希，请使用 `merge` 方法：`hash1.merge(hash2)`。

要使用原始哈希的值作为键和键作为值来创建新的哈希，请使用 `aHash.invert`。要返回包含哈希键或值的数组，请使用 `aHash.keys` 和 `aHash.values`。

这里有一个使用这些方法的一些示例：

*hash_methods.rb*

```
h1 = {
    'room1'=>'The Treasure Room',
    'room2'=>'The Throne Room',
    'loc1'=>'A Forest Glade',
    'loc2'=>'A Mountain Stream'
    }

h2 = {1=>'one', 2=>'two', 3=> 'three'}

h1['room1'] = 'You have wandered into a dark room'
h1.delete('loc2')
p(h1)
                         #=> {"room1"=>"You have wandered into a dark room",
                         #=> "room2"=>"The Throne Room",
                         #=> "loc1"=>"A Forest Glade"}
p(h1.has_key?('loc2'))   #=> false
p(h2.has_value?("two"))  #=>true
p(h2.invert)             #=> {"one"=>1, "two"=>2, "three"=>3}
p(h2.keys)               #=>[1, 2, 3]
p(h2.values)             #=>["one", "two", "three"]
```

如果你想要在哈希中查找项的位置，请使用 Ruby 1.8 中的 `index` 方法或 Ruby 1.9 中的 `key` 方法。`index` 方法在 Ruby 1.9 中仍然存在，但已弃用，因此可能在未来的版本中删除：

```
h2.index("two")    # use this with Ruby 1.8
h2.key("two")      # use this Ruby 1.9
```

深入挖掘

在本节中，你将学习更多操作数组和方法以及矩阵、向量和集合的基础知识。

将哈希视为数组

哈希的 `keys` 和 `values` 方法每个都返回一个数组，因此你可以使用各种数组方法来操作它们。以下是一些简单的示例（请记住，键和值的顺序可能会根据使用的 Ruby 版本而有所不同）：

*hash_ops.rb*

```
h1 = {'key1'=>'val1', 'key2'=>'val2', 'key3'=>'val3', 'key4'=>'val4'}
h2 = {'key1'=>'val1', 'KEY_TWO'=>'val2', 'key3'=>'VALUE_3', 'key4'=>'val4'}

p( h1.keys & h2.keys )                         # set intersection (keys)
#=> ["key1", "key3", "key4"]

p( h1.values & h2.values )                     # set intersection (values)
#=> ["val1", "val2", "val4"]

p( h1.keys+h2.keys )                           # concatenation
#=> [ "key1", "key2", "key3", "key4", "key1", "key3", "key4", "KEY_TWO"]

p( h1.values-h2.values )                       # difference
#=> ["val3"]

p( (h1.keys << h2.keys)  )                     # append
#=> ["key1", "key2", "key3", "key4", ["key1", "key3", "key4", "KEY_TWO"]]

p( (h1.keys << h2.keys).flatten.reverse  )     # 'un-nest' arrays and reverse
#=> ["KEY_TWO", "key4", "key3", "key1", "key4", "key3", "key2", "key1"]
```

追加与连接

请注意使用 `+` 来添加第二个数组的 *值* 到第一个数组中连接和使用 `<<` 来添加第二个 *数组* 本身作为第一个数组的最后一个元素的差异：

*append_concat.rb*

```
a =[1,2,3]
b =[4,5,6]
c = a + b            #=> c=[1, 2, 3, 4, 5, 6]   a=[1, 2, 3]
a << b               #=> a=[1, 2, 3, [4, 5, 6]]
```

此外，`<<` 修改第一个（即 *接收者*）数组，而 `+` 返回一个新数组，但不会更改接收者数组。

### 注意

在面向对象术语中，方法所属的对象称为 *接收者*。其思想是，与过程式语言中调用函数不同，向对象发送“消息”。例如，可以将消息 `+ 1` 发送到整数对象，而消息 `reverse` 可以发送到字符串对象。接收消息的对象会尝试找到一种方式（即一种 *方法*）来响应该消息。例如，字符串对象有一个 `reverse` 方法，因此能够响应 `reverse` 消息，而整数对象没有这样的方法，因此不能响应。

你可以使用 `flatten` 方法清理使用 `<<` 组合的两个数组，如下所示：

```
a=[1, 2, 3, [4, 5, 6]]
a.flatten            #=> [1, 2, 3, 4, 5, 6]
```

向量和矩阵

为了数学家的利益，Ruby 提供了 Vector 类和 Matrix 类。一个 *向量* 是一个有序元素集合，可以对它执行某些数学运算。一个 *矩阵* 是行和列的集合，每一行本身也是一个向量。矩阵允许你执行矩阵操作，这是本书范围之外的主题，并且可能只对数学程序员感兴趣。然而，你将在这里查看一些简单的示例。

首先，给定两个矩阵对象，`m1` 和 `m2`，你可以使用加号将矩阵中对应单元格的值相加，如下所示：`m3 = m1+m2`。为了使用它，你必须使用 `require` 指令导入 Matrix：

*matrix.rb*

```
require "Matrix"    # This is essential!

m1 = Matrix[ [1,2,3,4],
            [5,6,7,8],
            [9,10,11,12],
            [13,14,15,16]  ]

m2 = Matrix[ [10,20,30,40],
            [50,60,70,80],
            [90,100,110,120],
            [130,140,150,160]  ]

m3 = m1+m2
p(m3)
```

这将输出以下矩阵：

```
Matrix[[11, 22, 33, 44], [55, 66, 77, 88], [99, 110, 121, 132], [143, 154, 165, 176]]
```

以下示例从两个向量创建一个矩阵。通过将向量传递给 `Matrix.columns()` 方法，你构建一个矩阵，其行是数组的数组。这里矩阵有两个列，由向量 `v` 和 `v2` 创建，每行包含两个项目，一个来自每个列：

```
v = Vector[1,2,3,4,5]
v2 = Vector[6,7,8,9,10]
m4 = Matrix.columns([v,v2])
p( m4 )
```

这将输出以下内容：

```
Matrix[[1, 6], [2, 7], [3, 8], [4, 9], [5, 10]]
```

另一方面，如果你将相同的两个向量传递给 `Matrix.rows()` 方法，你将创建一个包含两行的矩阵，每行都是一个向量：

```
m5 = Matrix.rows([v,v2])
p( m5 )
```

这将输出以下内容：

```
Matrix[Vector[1, 2, 3, 4, 5], Vector[6, 7, 8, 9, 10]]
```

集合

Set 类实现了一个无序值集合，其中没有重复项。你可以使用值数组初始化一个 Set，在这种情况下，将忽略重复项：

*sets.rb*

```
s1 = Set.new( [1,2,3,4,5,2] )
s2 = Set.new( [1,1,2,3,4,4,5,1] )
s3 = Set.new( [1,2,100] )
weekdays = Set.new( %w( Monday, Tuesday, Wednesday, Thursday,
        Friday, Saturday, Sunday ) )
```

你可以使用 `add` 方法添加新值：

```
s1.add( 1000 )
```

`merge` 方法将一个集合的值与另一个集合的值合并：

```
s1.merge(s2)
```

你可以使用 `==` 来测试相等性。包含相同值（记住，当创建集合时将删除重复项）的两个集合被认为是相等的：

```
p( s1 == s2 )            #=> true
```

如果你显示集合的内容，顺序可能会根据所使用的 Ruby 版本而有所不同。如果顺序很重要，你可以使用 `to_a` 方法将集合转换为数组，并使用标准或自定义排序，如 排序数组 中所述：

```
p( weekdays.to_a.sort ) # sort alphabetically
#=> ["Friday,", "Monday,", "Saturday,", "Sunday", "Thursday,", "Tuesday,",
 "Wednesday,"]
```
