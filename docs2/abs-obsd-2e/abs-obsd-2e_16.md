## 第十六章 网络服务器

*幕后工作，*

*处理重要事务，*

*守护进程在这里。*

![](img/httpatomoreillycomsourcenostarchimages1616079.png) OpenBSD 基础系统包括几个服务器来支持网络。本章涵盖了以下网络服务器：

+   小服务器处理器 `inetd`

+   打印机守护进程 `lpd`

+   DHCP 守护进程 `dhcpd`

+   TFTP 守护进程 `tftpd`

+   SNMP 代理 `snmpd`

+   SSH 服务器 `sshd`

这本杂乱无章的小精灵支持了即将到来的章节中涵盖的功能。

## inetd 小服务器处理器

`inetd(8)` “超级服务器”处理不常使用的网络服务的传入网络请求。毕竟，许多系统没有稳定的 FTP 请求流，为什么还要一直运行 FTP 守护进程呢？相反，`inetd` 监听传入的网络请求，当 FTP 请求到达时，它启动 FTP 服务器并将请求传递给它。其他经常（但不总是）通过 `inetd` 运行的常见服务包括 ident、finger 和 TFTP。许多这些服务也可以独立运行，如果应用程序的使用需要的话。

`inetd` 还处理一些非常小且很少使用的功能，这些功能在 `inetd` 本身内实现比通过调用单独的程序实现更容易。这些功能包括 `discard`（将接收到的任何数据丢弃到 */dev/null* 的无底洞中），`chargen`（输出一串字符），和 `echo`（重复你发送给它的任何内容）。大多数这些服务在现代互联网上不是必需的，并且默认情况下被禁用，但如果你需要，你可以访问它们。

### 配置 inetd

你在 */etc/inetd.conf* 中配置 `inetd`。以下是 OpenBSD FTP 服务器的默认 `inetd` 配置：

```
#**1**ftp **2**stream **3**tcp **4**nowait **5**root **6**/usr/libexec/ftpd **7**ftpd -US
#ftp    stream   tcp6  nowait   root   /usr/libexec/ftpd   ftpd -US
```

你首先会注意到这些条目已被注释掉。OpenBSD 的默认 `inetd` 默认只提供身份服务器 `identd(8)` 和两个时间服务。

第一个字段是服务名称（在这种情况下为 `ftp`）**1**。此字段中的名称必须与 */etc/services* 中的名称匹配。`inetd` 程序使用 *services* 文件来执行服务查找，以确定它必须监听哪些端口。要更改 FTP 服务器运行的 TCP/IP 端口，请更改 */etc/services* 中 FTP 的端口。（你也可以更改第一个字段以使用通常在所需端口上运行的服务名称，但我发现用错误的名字开始我的 FTP 服务器条目只会让我头疼。）

第二个字段是套接字类型（在这种情况下为 `stream`）**2**。此字段决定了这种连接的类型。所有 TCP 连接都是 `stream` 类型，而 UDP 连接是 `dgram` 类型。`inetd` 程序也支持其他类型的连接，但它们很少使用。如果你正在考虑使用它们，要么你正在阅读需要此类连接的软件的文档，要么你错了（可能后者的可能性更大）。

第三字段是第 4 层网络协议，通常是`tcp` **3**，`udp`，`tcp6`或`udp6`。如果您想在 IPv4 和 IPv6 上提供服务，您需要为每个协议分别创建条目。这就是为什么 FTP 服务器有两个其他方面相同的配置。`inetd`程序还支持 RPC 服务，其类型为`rpc/udp`或`rpc/tcp`。

第四字段（在本例中为`nowait`）**4**表示`inetd`是否应该等待服务器程序关闭连接，或者只是启动程序然后离开。一般来说，基于 TCP 的守护进程使用`nowait`，而基于 UDP 的守护进程使用`wait`。（有少数例外。）

第五字段（在本例中为`root`）**5**指定了服务器守护进程运行的用户。许多使用`inetd`的程序必须以 root 身份运行，因为它们可以影响多个用户或接受更具体的登录，但一些较小的程序有专门的未授权用户。

第六字段是当连接请求到达时`inetd`运行的程序的全路径 **6**。在`inetd`中实现的服务路径为`internal`。FTP 服务器位于`/usr/libexec/ftpd`。

最后，最后一个字段给出了启动服务器程序的命令，包括您想要的任何命令行参数。此配置使用`-US`参数运行 FTP 服务器 **7**。

### 限制传入连接

小白用户偶尔会尝试通过发送比服务器能处理的更多的连接请求来将服务器从互联网上移除。`inetd`程序每个服务每分钟最多接受 256 个连接。如果一个服务接收过多的连接请求，`inetd`将记录问题并停止回答该服务的请求 10 分钟。

### 注意

IPv4 和 IPv6 版本分别限制，因此如果请求在协议族之间均匀分配，您每秒可以接受 512 个 FTP 连接。您可以在启动`inetd`时使用命令行标志全局覆盖此限制，或者您可以在每个服务的基础上进行配置。

`-R`标志控制`inetd`每分钟和每个服务接受的连接数。例如，要每分钟接受 1000 个请求，您需要在`/etc/rc.conf.local`中设置以下内容：

```
inetd_flags='-R 1000'
```

您可以通过编辑服务的`inetd.conf`条目中的`wait/nowait`字段来设置每个服务的限制。在`wait`或`nowait`条目后添加一个点，然后跟您希望服务每分钟被调用的次数。例如，如果您有一个只有几个朋友使用的 FTP 服务器，您可以将服务器限制为每分钟 10 个请求，如下所示：

```
ftp   stream  tcp    nowait.10  root    /usr/libexec/ftpd       ftpd -US
ftp   stream  tcp6   nowait.10  root    /usr/libexec/ftpd       ftpd -US
```

现在，如果一分钟内超过 10 个连接请求到达，`inetd`将停止服务 FTP 请求十分钟。攻击者仍然可以使用此方法使您的 FTP 服务离线，但不会使整个服务器离线。至少这样您可以选择您的故障模式以及何时达到它。

## lpd 打印守护进程

OpenBSD 包含了在 Unix-like 操作系统中常见的 `lpd(8)` 打印守护进程。`lpd` 守护进程有支持成千上万种不同打印机的选项，但找到支持任何特定打印机的正确选项组合可能是一个挑战。

在 OpenBSD 上使用打印机的最简单方法是通过 PostScript 服务器，这正是我将在这里介绍的方法。许多现代打印机，尤其是流行的多功能传真/扫描/打印机组合，都支持 PostScript，你会发现每个办公室的打印服务器也是如此。

系统中知道的每个打印机都需要在 */etc/printcap* 中有一个条目，即打印机功能数据库。这是一个另一种 `termcap(5)` 风格的配置文件。你不需要了解打印机的所有信息就可以在这里更改设置。此条目只需要打印服务器的主机名或 IP 地址以及你想要访问的打印机的打印服务器名称。然后使用以下模板：

```
lp|*printername*:\
  :sh=:\
  :rm=*printservername*:\
  :sd=/var/spool/output/*printername*:\
  :lf=/var/log/lpd-errs:\
  :rp=*printername*:
```

第一行给出打印机的名称。每个打印机可以有任意数量的名称，名称之间由管道（`|`）符号分隔。Unix-like 系统上的默认打印机名为 `lp`，因此请确保至少有一台打印机附有该名称。另一个名称应该是打印服务器用于该打印机的名称（例如 `Billing`）。（Microsoft 打印服务器通常在几个不同的名称下共享一台打印机，并且每个名称打印的内容不同，因此请确保使用代表 PostScript 功能的名称。）

其他行列出属性：

+   默认情况下，`lpd` 在每个打印作业前都会加上一个包含作业名称、编号、主机和其他识别信息的页面。当人们按页付费打印时，这曾经很重要，但除非你在一个只有一台大型打印机的环境中，否则这可能会浪费纸张。`:sh:=\` 条目会抑制此页面。

+   `:rm=` 属性给出了打印服务器的主机名或 IP 地址。你必须能够通过此名称 ping 通打印服务器。

+   如果每个打印机都有一个唯一的打印队列目录，给定 `:sd=` 属性，则打印效果最佳。打印机守护进程将正在前往打印服务器的文档存储在此目录中。此目录必须由用户 root 和组 daemon 拥有。

+   几台打印机可以共享一个公共日志文件，由 `:lf=` 属性表示。

+   最后，使用 `:rp=` 属性指定远程打印机名称。这是唯一一个不以反斜杠结尾的属性。

总是以换行符结束 */etc/printcap*。我通常使用一个完整的空白行，以确保无误。

现在你已经配置了打印机，你可以通过在 *rc.conf.local* 中添加以下条目在启动时启动 `lpd`：

```
lpd_flags=""
```

任何时间编辑 */etc/printcap* 后，都使用 `/etc/rc.d/lpd restart` 重新启动 `lpd`。

最后，使用 `lpq(1)` 查看打印队列，并观察 */var/log/lpd-errs* 文件以查找问题。

## DHCP 服务器 dhcpd

DHCP 是在 IP 网络上动态配置客户端的标准方法。你可能知道 DHCP 是一种为计算机提供基本 IP 信息的方法，但它也可以分发路由器和电话等嵌入式设备的配置文件，将无盘机器指向它们的内核和用户空间，等等。

OpenBSD 包含了一个经过大量修改的 ISC DHCP 服务器，`dhcpd(8)`。在这里，我们将介绍如何使用 `dhcpd` 在共享以太网系统中配置动态客户端的基础知识。在 第二十三章 中，我们将讨论使用 DHCP 配置无盘工作站细节。

### DHCP 的工作原理

寻求 DHCP 信息的客户端会在本地网络中广播一个请求，请求某人——任何人——给它一个网络配置。如果你的 DHCP 服务器位于该以太网段上，它会直接响应。如果它位于另一个网络段上，该网络段的路由器可以将 DHCP 请求转发到你的服务器，然后服务器将为客户端提供一个配置，并维护一个已分配哪些唯一配置值（如 IP 地址）给哪些客户端的列表。分配给客户端的配置称为 *租约*。像所有租约一样，DHCP 租约会过期，必须续订才能有效。

客户端可以请求某些 DHCP 功能以支持其操作。例如，Microsoft 客户端请求网络 Windows Internet Name Service (WINS) 服务器的 IP 地址，VoIP 桌面电话请求它们的配置文件，而无盘系统（在第二十三章定制 OpenBSD 中讨论）询问它们在哪里可以找到它们的内核和用户空间。DHCP 服务器可以提供这些信息，也可以不提供。

DHCP 服务器通过客户端连接到网络的网卡 MAC 地址唯一标识每个客户端。要找出客户端从 DHCP 服务器接收了什么信息，获取客户端的 MAC 地址并在 */var/db/dhcpd.lease* 文件中搜索它。

### 配置 dhcpd(8)

在 */etc/dhcpd.conf* 中配置 `dhcpd`。默认的 *dhcpd.conf* 文件包含一个适合小型办公环境的示例配置，以及一个无盘客户端的示例配置。

我将假设你在你的网络上运行一个 DHCP 服务器，并且这个服务器是 DHCP 服务的权威服务器。（OpenBSD 的 DHCP 服务器也支持集群以实现容错。） 

在配置 `dhcpd` 以动态配置客户端之前，你需要了解一些关于你网络的事实：

+   域名

+   DNS 服务器

+   IP 网络和子网掩码

+   网络中用于 DHCP 客户端的 IP 地址范围

+   默认路由器

一旦你有了这些信息，你就可以组装一个简短的 *dhcpd.conf* 文件。以下是一个示例：

```
**1** option domain-name "blackhelicopters.org";
**2** option domain-name-servers 192.0.2.5 192.0.2.10;
**3** subnet 198.51.100.0 netmask 255.255.255.0 {
**4**     option routers 198.51.100.1;
**5**     range 198.51.100.51 198.51.100.100;
  }
```

所有从这个主机获取配置的主机都被告知它们的域名是*blackhelicopters.org**1*，并且它们应该使用名称服务器 192.0.2.5 和 192.0.2.10**2**。客户端可以被配置为忽略或覆盖此 DHCP 配置，但你无法阻止本地系统管理员自挂东南枝。

每个子网都需要自己的配置。即使你只有一个子网，你也必须有一个定义该子网 IP 网络的`subnet`语句，以便`dhcpd`可以确定哪些客户端获得哪些配置。以下示例定义了网络在 198.51.100.0/24**3**上的客户端配置。以下方括号内的所有内容仅适用于此子网上的主机。

**4**处的`routers`选项标识了此网络的默认网关。因为`dhcpd`服务器不会让你为客户端定义额外的静态路由，所以你的本地网络路由器必须具有到达目的地的正确路由。如果你在本地网络上有多个网关，你的默认路由器应向 DHCP 客户端发送 ICMP 重定向以纠正其路由。（你不会单方面从防火墙中阻止 ICMP，对吧？）

`range`关键字给出了 DHCP 服务器可以分配给客户端的 IP 地址。在这个例子中，DHCP 服务器控制了从 198.51.100.51 到 198.51.100.100 的地址，包括**5**。如果有 52 个动态客户端同时连接，最后一个客户端将无法获得地址。

此配置应使你的客户端能够连接到网络。

### 静态 IP 地址分配

你可以通过在配置中指定客户端的以太网地址并使用`subnet`语句中的段落来告诉你的 DHCP 服务器为特定的主机分配特定的地址。以下是一个添加了静态条目的早期 DHCP 配置示例：

```
 subnet 198.51.100.0 netmask 255.255.255.0 {
    option routers 198.51.100.1;
    host lucas-desktop {
        hardware ethernet 00:cf:01:b1:9b:07;
        fixed-address 192.0.2.254;
    }
}
```

我已经找到了我的工作站的 MAC 地址，并使用它为该机器分配了一个静态 IP 地址。此客户端机器从子网定义继承了默认路由器以及任何默认 DHCP 信息。

### 启用 dhcpd

在`rc.conf.local`中启用`dhcpd`。

```
dhcpd_flags=""
```

如果你只有一个面向网络的接口，`dhcpd`将自动在该接口上监听 DHCP 请求。如果你有多个接口，请将接口名称作为参数。例如，以下是如何告诉`dhcpd`只在该接口`fxp1`上监听请求：

```
dhcpd_flags="fxp1"
```

接口名称必须是`rc.conf.local`中`dhcpd`参数的最后一个。如果`dhcpd`需要处理多个接口，接口列表必须跟在其他任何参数之后在`dhcpd_flags`中。

### dhcpd 和防火墙

OpenBSD 数据包过滤系统包括*表格*，这些是数据包过滤器应用规则到的一组 IP 地址。来自表格中 IP 地址的流量可以被阻止，带宽被限制或优先处理，或者被允许通过。每个表格都有一个唯一名称。

`dhcpd` 服务器可以将地址添加到包过滤表中，从而根据 IP 地址是否已租用动态更改防火墙规则。在这里，我们将探讨如何配置 `dhcpd` 以向包过滤表提供地址。第二十一章 讨论了如何配置包过滤规则以处理来自 `dhcpd` 的地址。

DHCP 将其地址池中的 IP 地址视为三种状态之一：已租用、已放弃或已更改。*已租用*的地址是指分配给连接到网络的宿主机的地址。使用 `-L` 选项向 `dhcpd` 提供已租用地址的包过滤表名称，然后配置包过滤规则以允许或拒绝这些地址访问网络的其他部分。

*已放弃*的地址是指已分配给宿主机但当前未使用的地址。在实践中，这意味着如果你关闭你的笔记本电脑，DHCP 服务器将认为分配给它的 IP 地址已放弃。问题是未经授权的用户可能会尝试从地址池中获取未使用的地址来接入网络，而不通过 DHCP 服务器。为了解决这个问题，向包过滤规则提供未使用地址的列表，并为非法网络主机提供他们自己的特殊包过滤规则。使用 `-A` 选项告诉 `dhcpd` 已放弃地址的包过滤表名称。

如果宿主机更改了地址，尽管 DHCP 服务器的配置说明，DHCP 服务器仍认为该地址已更改，`dhcpd` 可以将其新地址添加到更改地址表中。使用 `-C` 选项告诉 `dhcpd` 更改地址表的名称。（在第二十一章中，我们将对这些表进行一些有趣的配置。）

```
dhcpd_enable="-A table1 -L table2 -C table3 fxp1"
```

### 注意

静态 IP 地址分配不会进入表。如果你为宿主机分配了静态地址，你必须手动为该地址配置防火墙规则。

## TFTP 守护进程 tftpd

简单文件传输协议（TFTP）用于在网络上传输文件。与 FTP 不同，TFTP 不包含身份验证。任何可以访问 TFTP 服务器的人都可以从它上传或下载文件。

TFTP 是一种不灵活的协议。如果没有代理或翻译设备内的某种智能，它无法通过网络地址转换工作，并且没有像 FTP 和 SFTP 那样的交互会话。TFTP 最常用于复制嵌入式设备（如路由器）的配置文件和操作系统映像。

OpenBSD 使用 TFTP 来引导无盘系统，如第二十三章所述。

### 指定 tftpd 目录

OpenBSD 的 `tftpd(8)` 从目录中提供服务，就像一个 Web 服务器。传统上，这个目录是 */tftpboot*，但在此情况下不要遵循传统（您不希望 TFTP 用户填满您的服务器根分区！）。如果您在根分区上使用 */tftpboot*，请确保您的 TFTP 客户端无法写入该目录。（您可以创建一个 */tftpboot* 分区。）通常，我会创建 */var/tftpboot* 并告诉 `tftpd` 使用该目录作为其根目录。如果您的手指习惯于输入 `/tftpboot`，请创建一个符号链接。

要启用 `tftpd`，请在 `rc.conf.local` 中设置 `tftpd_flags` 为 TFTP 根目录。

```
tftpd_flags="/var/tftpboot"
```

`tftpd` 将 `chroot` 到您指定的目录，因此 `tftpd` 无法访问此目录之外的文件。

### tftpd 和文件

TFTP 使用文件权限作为访问控制方法。因为 TFTP 服务器上的所有文件都可以被任何可以访问服务器端口的用户读取，所以 TFTP 只允许客户端在其根目录中读取文件，前提是这些文件是全局可读的。要使它们全局可读，请执行以下操作：

```
# **chmod +r /var/tftpboot/*filename***
```

类似地，`tftpd` 不会允许任何人上传文件，除非该名称的文件已经存在并且是全局可写的。这意味着任何知道文件名的人都可以覆盖它，因此请将重要文件设置为只读。如果攻击者无法写入文件，他就无法填满您的硬盘。

要通过 TFTP 创建文件，以便您可以上传不存在的文件，请使用 `-c` 选项运行 `tftpd`。

`tftpd` 以 root 身份启动，以便绑定 UDP 端口 69，但它随后会降低权限并以无特权的用户 `_tftpd` 运行。`tftpd` 创建的任何文件都将属于其用户。作为一般规则，TFTP 根目录中的文件不应由 `_tftpd` 拥有，以确保服务器无法影响其提供的服务器文件。

### tftpd 日志记录

您应该记录您的 TFTP 传输。使用 `-v` 标志将事务日志发送到 `syslogd`。

```
tftpd_flags="-v /var/tftpboot"
```

`tftpd` 日志使用 FTP 功能将消息记录到 */var/log/daemon*。

### 测试 TFTP 服务器

使用 `tftp(1)` 测试您的 TFTP 服务器。

```
$ **tftp caddis**
tftp> **get testboot.iso**
Received 20879569 bytes in 10.4 seconds
```

在下载文件时，您不会看到任何友好的散列标记，并且您无法切换到另一个目录或列出 TFTP 服务器的内容。一旦测试完成，使用 `quit` 结束您的 TFTP 会话。

在您设置好 TFTP 客户端和服务器之后，您将准备好为无盘 OpenBSD 机器、路由器操作系统镜像或其他任何您需要的设备提供服务。

## SNMP 代理 snmpd

SNMP 是从网络设备收集信息的既定标准。许多不同厂商的不同设备都支持 SNMP 作为管理协议。

OpenBSD 包含一个 SNMP 代理 `snmpd(8)`，它支持所有常规的 SNMP 功能，并提供对 OpenBSD 特定功能（如数据包过滤）的可见性。

SNMP 根据标准的客户端/服务器模型工作。SNMP 客户端（通常是执行网络管理或监控的服务器）查询运行在网络设备上的 SNMP 服务器（或 *代理*）。SNMP 代理 `snmpd` 从本地系统收集信息并将其返回给客户端。

在传统的 SNMP 中，具有正确权限的 SNMP 客户端还可以请求 SNMP 代理修改其设备。大多数类 Unix 操作系统都设计为在命令行中进行配置，并且通常不接受 SNMP 的写请求。OpenBSD 跟随这一趋势，我们将特别关注只读 SNMP。

除了让 SNMP 代理响应 SNMP 客户端的请求外，代理还可以将 SNMP 陷阱发送到网络上的某个 *陷阱接收器*。SNMP 陷阱与 `syslogd(8)` 消息非常相似，但它们遵循 SNMP 所需的特定格式。

### 注意

OpenBSD 不包括 SNMP 陷阱接收器。如果您需要，请查看 `net-snmp` 包中的 `snmptrapd`。

### SNMP MIBs

SNMP 通过管理信息库（MIB）管理信息，MIB 是一个树状结构，包含以 ASN.1 格式的分层信息。每个 SNMP 代理都有一个从本地系统提取信息列表，这些信息按分层 SNMP MIB 安排，具有非常一般的主要类别，如网络、物理、程序等。

将 MIB 树想象成一个组织良好的文件柜，其中每个抽屉都保存着特定的信息，抽屉内的文件则保存着特定的事实。同样，最顶层的 MIB 包含了其下 MIB 的列表。

#### MIB 参考信息

MIBs 可以通过名称或编号进行引用。例如，这里是一个从 OpenBSD 测试机器中提取的 MIB：

```
interfaces.ifTable.ifEntry.ifDescr.1 = STRING: "em0"
```

这个 MIB 的第一个术语 `interfaces` 告诉我们，我们正在查看这台机器的网络接口。如果这台机器没有接口，这个类别甚至不会存在（尽管 OpenBSD 机器将始终至少有一个回环接口）。`ifTable` 是 *接口表*，它列出了系统上的所有网络接口。`ifEntry` 字段显示一个特定的条目，而 `ifDescr` 则意味着我们正在查看这个接口的描述。这个 MIB 可以表示为“这台机器上的接口编号 1 被称为 `em0`。”

MIBs 也可以用数字表示，大多数 SNMP 客户端在数字 MIB 中以原生方式工作。您的管理工具应该能够将数字和名称之间进行转换，但为了以防您感到非常惊讶，这里提供了之前示例的数字形式：

```
.1.3.6.1.2.1.2.2.1.2.1 = STRING: "em0"
```

用文字表达，这个 MIB 由五个部分组成，部分之间用点分隔。用数字表达，MIB 有 11 个部分。它们不应该是一样的吗？嗯，数字 MIB 更长，因为它包括了默认地址 .1.3.6.1.2.1，这对应于 *.iso.org.dod.internet.mgmt.mib-2*，这是在互联网上使用的 MIB 的标准子集。大多数 SNMP MIB 都以这个字符串开头，所以管理工具就不再打印出这个名称了。

#### MIB 定义

OpenBSD 支持两组 MIB：

+   标准的主机 MIB，这是每个网络管理系统都理解的。这些信息包括网络和磁盘空间利用率、系统上运行的软件等。

+   用于 OpenBSD 特定功能（如数据包过滤器、网络故障转移、桥接等）的 MIB。大多数网络管理系统不会默认理解 OpenBSD 特定的 MIB，所以你将想要让你的管理系统了解 OpenBSD 的 MIB。

MIB 是根据 MIB 文件中记录的非常严格的语法定义的。例如，`snmpd`在`/usr/share/snmp/mibs`中包含了 OpenBSD 特定功能的 MIB 文件。这些文件以纯文本形式编写，使用非常正式的 ASN.1 语法。虽然你可以仅用大脑阅读和解释它们，但我强烈建议将它们复制到你的网络管理工作站上，并使用 SNMP 客户端来检查它们。

MIB 浏览器解释 MIB 文件，并以完整的树状结构展示它们，包括树中每一部分的定义和每个 MIB 的描述，这些描述来自 MIB 文件。一般来说，你将 MIB 输入到 MIB 浏览器中，它会显示其数字和文字描述，并提供查询该 MIB 的 SNMP 代理的能力。

如果你已经在你的 OpenBSD 工作站上安装了 MIB 浏览器，请使用`mbrowse`包。如果你不想使用图形界面，请使用`net-snmp`包来获得一系列完整的命令行 SNMP 客户端工具，但要做好准备输入一些长的命令行。

### SNMP 安全

SNMP 最常见的替代缩写是“安全？不是我的问题！”这听起来不友好，但却是真的。你应该只在防火墙后面或信任的网络中使用 SNMP。如果你必须在裸露的互联网上使用 SNMP，请使用数据包过滤来阻止公众查询你的 SNMP 服务。SNMP 代理在 UDP 端口 161 上运行，因此只允许你的管理主机访问你的 SNMP 主机上的该端口。

SNMP 通过*团体*提供基本的安全保障。如果你阅读了 SNMP 文档，你会看到各种解释为什么团体不等于密码，但就系统管理员而言，团体就是密码。

大多数 SNMP 代理默认有两个团体：`public`（只读访问）和`private`（读写访问）。OpenBSD 的`snmpd`守护进程默认支持这两个团体。你的第一个任务之一将是将这些团体名称更改为全世界都不知道的名称。就像密码一样，团体名称应该难以被入侵者猜测，但对你来说容易记住。

如你所料，SNMP 已经有过各种版本。版本 1 是第一次尝试。版本 2c（SNMPv2c）是更常见的更新。版本 3（SNMPv3）使用加密来保护线上的数据，并且它包括强大的身份验证。在实践中，很少有供应商真正使用它，因为它非常复杂。`snmpd`守护进程对 SNMPv3 有部分支持。在这里，我们将专注于完全支持的 SNMPv2c。

### 配置`snmpd`

在`*/etc/snmpd.conf*`中配置`snmpd`。配置格式是一系列文本语句。定义新的共同体字符串会覆盖`public`和`private`的默认值。

我们首先定义新的只读和读写共同体字符串，如下所示：

```
read-only community hansteen
read-write community henning
```

通常，大多数`snmpd`配置语句看起来像这两样。`snmpd.conf(5)`手册页列出了所有有效的`*snmpd.conf*`配置语句。

每个 SNMP 系统都应列出联系人、描述和位置，如下例所示：

```
system contact "mwlucas@michaelwlucas.com"
system description "Web server"
system location "Rack Row 9, Cabinet 6, Under the Meal Replacement Bars"
```

许多网络管理系统会自动拉取这些信息以填充数据库。在这里，我为我的系统定义了这些值。为你的系统创建类似的条目。

默认的`*snmpd.conf*`只监听本地主机 IP 地址，127.0.0.1，因此外部主机无法联系 SNMP 守护进程。如果你想监听所有可用的地址，取消注释指定地址的行，如下所示。

```
listen_addr="127.0.0.1"
listen on $listen_addr
```

或者，你可以提供一个接口 IP 地址，使`snmpd`监听特定外部 IP 地址，对于具有多个地址的机器。

```
listen_addr="192.0.2.5"
```

使用此配置，`snmpd`可以提供有关你的系统的信息。在`*/etc/rc.conf.local*`中启用它。

```
snmpd_flags=""
```

这将使`snmpd`在启动时启动，或者你可以运行`*/etc/rc.d/snmpd*`。

### 调试`snmpd`

SNMP 调试可能是一个令人烦恼的协议。一方面，因为它使用 UDP，所以没有简单的方法来测试到代理的连接性。此外，它运行得相当安静，因为它不记录查询。

为了验证你的网络管理系统中的查询是否到达你的服务器，尝试以详细模式和调试模式运行`snmpd`。

```
# **snmpd -vd**
startup
snmpe_bind: binding to address 0.0.0.0:161
```

当一个 SNMP 查询到达你的服务器时，你应该看到服务器解析请求。同样地，`snmpd`在告诉你为什么它不能提供答案方面做得很好。

```
snmpe_parse: 192.0.2.197: wrong read community
```

来自对不存在 MIB 请求的错误，如以下所示，理解起来有点困难。

```
snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 1 request 1141724535
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.2041
snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 0 request 1141724536
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.2041
snmpe_parse: 192.0.2.197: invalid varbind element, error index 1
```

在这里，MIB 请求试图找到对象标识符（OID）`iso.org.dod.internet.private.enterprises.2041`，但 OpenBSD 的`snmpd`不支持它。（它支持`20`*`2`*`1`，这是 Net-SNMP MIB 的一部分。）SNMP 客户端请求了一个无效的 MIB。

这个例子展示了成功请求以及`snmpd`响应时发送的 MIB：

```
snmpe_parse: 192.0.2.197: SNMPv1 'henning' context 1 request 1531862688
snmpe_parse: 192.0.2.197: oid iso.org.dod.internet.private.enterprises.ucDavis
```

通过仔细阅读输出，你应该能够看到为什么`snmpd`没有按照预期回答请求。

### 获取`snmpd`信息

SNMP 最重要的特性是它允许您从操作系统和/或软件中读取统计数据。除了 SNMP 支持的常规功能，如资源利用率和进程外，`snmpd`还允许您获取 OpenBSD 特定的系统信息。您可以获得有关数据包过滤器、传感器数据、接口内存和命令地址冗余协议（CARP）的信息。所有这些信息都出现在.1.3.6.1.4.1.30155 MIB 下，这是 OpenBSD 的私有（企业）MIB 树。

#### PF SNMP MIB

OpenBSD 的数据包过滤功能保留了很多统计数据，而我所需要的一切都可以通过 PF MIB 获得。您将找到如下信息：

+   PF 是否开启，以及运行了多长时间（以百分之一秒为单位）

+   匹配过滤规则的数据包数量

+   分片和重组的数据包数量

+   由于内存问题、内部数据包过滤问题、状态表溢出等原因丢弃的数据包数量

+   从状态表中添加和删除的状态数量

+   各种协议的超时数量

+   每个接口上阻止的流量量

+   数据包过滤表的使用情况，每个表中的地址数量

还有更多。PF SNMP MIB 为您提供了更多关于数据包过滤的有用可见性。将您的 MIB 浏览器指向.1.3.6.1.4.1.30155.1 MIB，以查看所有内容。

#### 传感器

您可以通过`snmpd`查看与`sensorsd(8)`相同的内核值（见第十五章`预留了空间。检查*/usr/share/snmp/mibs*以获取额外的 MIB 文件，并使用您的 MIB 浏览器查看您的 OpenBSD 特定版本支持的内容。OpenBSD 团队根据需要和代码贡献添加 MIB。如果您需要 IPsec MIB，请随时编写并提交代码。

## SSH 服务器 sshd

安全外壳协议（SSH）是在主机之间建立加密隧道的一种协议。SSH 最常用于远程命令行访问系统，但你也可以将其用作其他协议的通用包装器，甚至用于构建虚拟专用网络。SSH 的一个常见用途是支持安全文件传输协议服务（SFTP），它不会提供 shell 提示符，但在文件通过网络传输时会加密文件和认证信息。

OpenBSD 项目支持 OpenSSH，这是一个免费许可的客户端和服务器。OpenSSH 是世界上部署最广泛的 SSH 服务器，市场份额约为 97%，通常被认为是标准的 SSH 服务器。关于 OpenSSH 已经写了很多本书，包括我的（《SSH Mastery》，Tilted Windmill Press，2012 年）。

OpenBSD 包括 OpenSSH 服务器`sshd(8)`，OpenSSH 命令行客户端`ssh(1)`，以及 SFTP 客户端`sftp(1)`。在这里我们将重点关注`sshd`，因为你可以使用任意数量的 SSH 客户端。我使用最频繁的是`ssh`（用于类 Unix 系统）和 PuTTY（用于 Windows）。对于 SFTP，我通常使用`sftp`（用于类 Unix 系统）和 WinSCP（用于 Windows）。

### 禁用 sshd

除非你在安装过程中指定了其他设置，否则 OpenBSD 默认会启动`sshd`。如果你不想`sshd`运行，请在*/etc/rc.conf.local*中禁用它。

```
sshd_flags=NO
```

### SSH 主机密钥

第一次启动`sshd`时，OpenBSD 会在*/etc/ssh*目录中创建*主机密钥*。这些是一组公钥和私钥，唯一地标识了一个 SSH 服务器。每个密钥文件的名字中都包含单词*key*。当你的客户端第一次连接到 SSH 服务器时，它会展示服务器主机密钥的指纹摘要。如果你告诉客户端接受这个密钥，客户端会缓存服务器的密钥。如果这个密钥发生了变化，客户端会警告用户服务器的唯一身份已改变，用户可能正在向不同的服务器提供他的登录凭证。（任何获得主机密钥副本的人都可以让另一个服务器伪装成你的服务器。）请确保备份你的主机密钥，并保护它们免遭盗窃。

### sshd 网络选项

你可以通过添加命令行标志来更改`sshd`的行为，但重新配置`sshd`最常见的方式是编辑*/etc/ssh*目录下的文件。

OpenSSH 有许多配置选项。其中最常更改的是网络设置。你可以通过编辑配置文件*/etc/ssh/sshd_config*来控制`sshd`监听的端口、IP 地址和 IP 版本。以下是一个示例：

```
Port 22
AddressFamily any
ListenAddress 0.0.0.0
ListenAddress ::
```

`Port`关键字指定了`sshd`附加到的 TCP/IP 端口。默认是 TCP 端口 22。

### 注意

有些人建议使用除 22 号端口以外的端口来避免密码猜测蠕虫。保护你的 SSH 服务器更好的方法仅允许公钥认证或使用数据包过滤器只允许来自选定主机或网络的登录。

`AddressFamily` 关键字指定 `sshd` 使用的 IP 版本。默认情况下，使用 IPv4 和 IPv6，但你可以使用 `inet`（IPv4）或 `inet6`（IPv6）关键字来限制特定协议。

最后，你可以使用 `ListenAddress` 选项将 `sshd` 绑定到特定的 IP 地址。

### chroot 用户

组织通常需要将用户限制在特定的目录或目录子集。例如，许多网站允许用户通过 SSH 命令行访问，以便他们可以更容易地编辑文件和调试问题，或者甚至只提供文件 SFTP 访问。这些用户应该有权访问自己的目录，但不能访问其他用户的文件或系统的任何其他部分。一种解决方案是在用户的家目录中 `chroot` 用户。如果你有多个需要访问共享目录的用户，你可以将他们全部 `chroot` 在该目录中。

将用户锁定在目录中涉及三个步骤：选择要锁定用户的目录、填充该目录以及配置 `sshd` 以 `chroot` 这些用户。为了演示，我们将通过一个示例来展示如何将用户 `lasnyder` 在他的家目录中 `chroot`，并给他命令行访问权限，这样他只能访问他的 `chroot` 中的程序。

#### 选择目录

首先，使用 `ChrootDirectory` 选项指定 `chroot` 目录。

```
ChrootDirectory /home/lasnyder
```

如果所有用户都需要锁定在同一个目录中，这效果很好，但如果你想让用户有自己的私有目录，或者你想要在文件系统中的其他位置指定一个目录，事情就会变得复杂。

OpenSSH 支持使用 `%%`、`%h` 和 `%u` 宏来表示家目录。如果你的 `chroot` 目录包含一个字面 `%`，请使用 `%%` 宏来表示它。本例中的服务器在家目录 */disk%3/home* 上，因此需要使用 `%%` 宏来转义百分号。

```
ChrootDirectory /disk%%3/home/lasnyder
```

`%u` 宏展开为用户的用户名。你可以使用这个宏来给用户一个除了家目录之外的 `chroot` 目录（尽管我不知道为什么你不想直接在期望的位置给他们一个家目录）。在这里，每个用户在 */var/www* 下都有一个目录：

```
ChrootDirectory /var/www/%u
```

最后，你可以使用 `%h` 宏将每个用户锁定在他的家目录中。

```
ChrootDirectory %h
```

无论你在哪里锁定用户，都必须给该目录提供用户执行所需的一切，因为用户将无法离开该目录去获取他可能需要的工具。

#### 填充 chroot

大多数程序，如 shell，至少需要几个设备节点，并且用户必须有一个 shell 程序才能运行。如果一个用户只有 SFTP 访问，你不需要对 `chroot` 进行任何特殊准备。OpenSSH 的 SFTP 服务器包含它所需的一切。但如果用户有 shell 访问，他们需要基本的设备节点和一个 shell 程序。

对于我们的示例，为了给`lasnyder`提供他所需要的，请进入`chroot`目录，创建一个*dev*目录，然后使用`/dev/MAKEDEV`创建标准的设备节点。你可以移除`console`、`klog`、`kmem`、`ksyms`、`mem`和`xf86`设备。

```
# **cd /home/lasnyder**
# **/dev/MAKEDEV std**
# **rm console klog kmem ksyms mem xf86**
```

现在我们需要为用户提供一个 shell。由于在 shell 内运行的程序无法访问`chroot`之外的任何文件，包括共享库，因此复制到`chroot`中的任何 shell 都必须是静态链接的。包含的系统 shell 是静态链接的，并且大多数 ports 树中的 shell 都可以构建为静态版本。

使用`file(1)`验证 shell 是否为静态链接，然后在`chroot`内创建一个*bin*目录并将 shell 复制到那里。

```
# **file /bin/ksh**
/bin/ksh: ELF 32-bit LSB executable, Intel 80386, version 1, for OpenBSD, statically linked, stripped
# **cd /home/lasnyder**
# **mkdir bin**
# **cd bin**
# **cp /bin/ksh .**
```

最后，尽管被`chroot`的用户不应该有对其自己的根目录的写访问权限，但他需要一个真正的家目录。用户在*/etc/passwd*中的家目录相对于`chroot`；换句话说，如果用户在*/etc/passwd*中的家目录是*/home/lasnyder*，并且用户被`chroot`到*/home/lasnyder*，那么他的个人文件和点文件实际上位于*/home/lasnyder/home/lasnyder*。

```
# **chown root:wheel /home/lasnyder**
# **mkdir -p /home/lasnyder/home/lasnyder**
# **chown lasnyder:lasnyder /home/lasnyder/home/lasnyder**
```

用户现在在系统上拥有一个友好的命令行监狱单元格。现在我们需要告诉`sshd`将用户锁在其中。

#### chroot 特定用户

将这种`chroot`策略应用于所有用户可能并不明智——至少，你的系统管理员需要无限制的系统访问来执行维护。

要告诉`sshd`对特定用户进行`chroot`，无论是按名称还是按组，请在*sshd_config*的末尾使用`Match`关键字。`Match`允许你根据用户和客户端 IP 地址等因素更改`sshd`的默认行为。（`Match`有许多其他功能；请参阅`sshd_config(5)`以获取示例。）

例如，如果你想仅对用户`lasnyder`进行`chroot`，你可以使用`Match`来指定他的用户名。在配置的早期，你会有一个`ChrootDirectory`语句，该语句关闭大多数用户的`chroot`。然后，在配置的末尾，你会根据匹配该用户名来更改设置。

```
…
ChrootDirectory none
…
Match User lasnyder
      ChrootDirectory %h
```

你也可以对组中的所有用户进行`chroot`。

```
…
ChrootDirectory none
…
Match Group webcustomers
      ChrootDirectory %h
```

如果你有多条`Match`条款，请用逗号分隔它们。

```
…
ChrootDirectory none
…
Match User lasnyder, jgballard, pkdick
      ChrootDirectory %h
```

或者，如果你的大多数用户都已被`chroot`，则反转默认设置，并特别为你的系统管理员去`chroot`。

```
…
ChrootDirectory %h
…
Match Group wheel
      ChrootDirectory none
```

通过仔细配置，你可以仅限制对所需用户的访问。

SSH 可以做很多事情，例如安全地从你的网络中消除密码。完全掌握这个协议是值得你花时间的。

OpenBSD 的内置服务可以帮助你维护你的网络，并提供各种有用的支持基础设施。现在你了解了如何配置一些这些内置程序，让我们看看如何将 OpenBSD 用作桌面。
