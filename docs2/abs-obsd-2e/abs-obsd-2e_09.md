## 第九章。更多文件系统

*加密你的硬盘吗？*

*软件 RAID 可以拯救你的日子，*

*或毁灭你的生活。*

![磁盘管理](img/httpatomoreillycomsourcenostarchimages1616079.png) 磁盘管理并不复杂，但内容足够多，以至于有两章。幸运的是！在本章中，我们将从如何自动将你的重要根分区备份到第二个磁盘开始。然后我们将探讨 OpenBSD 如何通过内存文件系统使用额外的内存作为磁盘空间，以及如何设置它。接下来，我们将访问格式化为其他操作系统的磁盘，如 NTFS、ext2 和 FAT。可移动媒体并不难处理，但有其自己的关注点。如果你不需要实际的媒体，但可以处理磁盘镜像，你可以访问那些。这两个主题都包含在本章中。我们还将讨论使用 NFS 作为服务器和客户端。我们的最后一个主题是 OpenBSD 的磁盘冗余和磁盘加密功能。

## 将备份保存到 /altroot 分区

你可能会失去大部分分区，但仍希望恢复其余的系统。然而，如果你失去了根文件系统，恢复就会变得困难得多。虽然你可以从 */etc* 中备份关键文件并使用它们来恢复系统，但 OpenBSD 提供了 */altroot* 分区作为自动在第二个磁盘上复制根分区的一种简单方法。

在第二个磁盘上的紧急根分区可以在磁盘故障的情况下为你提供更简单的恢复路径。从第二个磁盘启动让你可以在更换故障磁盘之前，从该磁盘上提取任何数据，甚至可能从第一个磁盘上未损坏的分区中提取数据。然而，没有必要将根分区备份到同一个磁盘，因为整个磁盘可能无法使用。

这个备份需要一个与根分区大小相同的空闲磁盘分区，位于不同的磁盘上。OpenBSD 安装程序的默认设置假设你只有一个磁盘。如果你在安装过程中有第二个磁盘，你需要使用自定义安装过程来创建 */altroot* 分区，就像我们在第三章中的多磁盘安装所做的那样。虽然配置分区在安装过程中最容易，但如果需要，你可以在以后添加更多磁盘，如第八章中讨论的那样。

你的 */altroot* 分区需要一个 */etc/fstab* 条目。如果你在安装过程中创建了分区，那么那个 */etc/fstab* 条目已经存在，但挂载类型不正确。如果你在安装后创建了此分区，你需要自己创建一个 */etc/fstab* 条目。/*altroot* 分区需要一个 `xx` 类型的挂载类型，如下所示：

```
a914f9a264fa64e6.a /altroot ffs xx 0 0
```

你不能从这个分区的 */etc/fstab* 条目中挂载它，因为 `xx` 不是一个有效的挂载类型。（如果你想手动挂载这个分区，可以运行，例如，`mount /dev/sd1a /altroot`。）日常系统维护任务 */etc/daily* 使用这个挂载选项来识别根备份分区。

要启用 */altroot* 备份，请将 `ROOTBACKUP=1` 添加到您的 */etc/daily.local* 文件中。

## 内存文件系统

除了在原始磁盘上创建分区外，OpenBSD 允许您在系统内存中创建分区。一个 *内存文件系统* (*MFS*)，或 *内存磁盘*，位于您的机器的 RAM 中，而不是物理磁盘上。在文件系统中读写文件比在旋转磁盘上访问相同的文件要快得多，这使得内存支持的文件系统对于某些应用程序来说是一个巨大的优化。

如果 MFSs 对于高性能环境来说听起来好得令人难以置信，那是因为它们确实如此。在您将它们应用到所有地方之前，先了解它们的限制。首先，RAM 在重启或关机后不会持续存在，因此重启或关机将会清除 MFS 的内容。虽然这看起来可能很明显，但我多次因为丢失了一个存储在忘记是 MFS 文件系统上的文件而惊讶。此外，如果您的系统崩溃，您将丢失存储在 MFS 上的任何数据。

您可以使用 MFS 分区作为临时空间，快速编译、压缩、解压缩或其他方式操作临时文件。我见过新闻服务器历史记录、数据库锁和其他存储在 MFS 上的特定应用程序文件。

即使系统经常交换，MFS 也能正常工作。内核保留内存中正在积极使用的任何信息，同时将未使用的信息传输到交换空间。这对于像 */tmp* 这样的小型分区来说非常出色，其中小型、频繁使用的文件可以快速访问。那些不太频繁访问的文件最终会存储在交换空间中，这提供了与访问物理磁盘相似的性能。

最后一句警告：如果您没有多余的 RAM，不要过度使用 MFS。如果您内存和交换空间不足，您的系统将表现非常糟糕。

### 创建 MFS 分区

使用 `mount_mfs(8)` 创建临时 MFS 分区。像其他 `mount_` 命令一样，`mount_mfs` 采取两个参数：物理设备和挂载点。与物理磁盘不同，内存没有设备节点，因此使用系统交换空间的设备节点。如果您有多个交换分区，请选择您喜欢的。

您可以通过将交换分区 */dev/sd0b* 和所需的挂载点 */mnt* 作为参数传递给 `mount_mfs` 来创建一个内存支持的文件系统：

```
# **mount_mfs /dev/sd0b /mnt**
```

这个分区的大小将仅限于您的交换分区的大小。

您可以创建较小的内存支持文件系统，这样当您填满内存磁盘时，您将会有内存和/或交换空间可用。使用 `-s` 标志和扇区数或使用尾随的 `b`（字节）、`m`（兆字节）或 `g`（千兆字节）来指定大小。以下是如何在 */mnt* 上创建一个 128MB MFS 的方法：

```
# **mount_mfs -s 128m /dev/sd0b /mnt**
```

如果您请求的 MFS 大于您的系统可以支持的，您将收到类似 `mmap: Cannot allocate memory` 的警告。再次尝试，这次使用一个更合理的尺寸。

### 在引导时挂载 MFS

你可以通过在*/etc/fstab*中添加条目来在启动时挂载 MFS。你只需要挂载点和分区大小。

```
**1**swap   **2**/mnt   **3**mfs   **4**rw,async,-s=128m   **5**0   **6**0
```

你不需要指定特定的交换设备；OpenBSD 足够智能，可以让你将内存磁盘通用地指定为交换后置**1**。就像任何其他分区一样，你还需要指定挂载点**2**和文件系统类型**3**。

当处理内存磁盘时，你可以使用与传统磁盘不同的选项**4**。由于系统崩溃会破坏 MFS 上的所有文件，因此你可以安全地使用`async`选项异步挂载 MFS 分区。你可能还希望在分区上使用`nodev`和`nosuid`挂载选项。你可以使用`-s`选项指定大小，但请确保在`-s`和大小之间放置一个等号（`=`）。因为*/etc/fstab*使用空白字符来分隔字段，如果你不使用等号，OpenBSD 会认为转储级别是 128m.^([21])

内存磁盘上的数据按定义是可丢弃的，所以不要备份它**5**。同样，在启动时永远不要使用`fsck(8)`对内存磁盘进行检查**6**。内存磁盘在每次启动时都会重新创建，因此它是自动内部一致的。

## 外部文件系统

任何使用非 FFS 文件系统的分区对 OpenBSD 来说是外部的。尽管 OpenBSD 可以访问许多外部文件系统，但不要期望它能够无缝访问。

对某些文件系统的支持是不完整的。例如，你只能以只读方式挂载 Microsoft NTFS 分区。其他文件系统不支持 OpenBSD 命令的全范围。因为 FAT 文件系统没有任何文件所有权或权限的概念，所以像`chmod`和`chown`这样的命令在磁盘上不会产生任何变化。

每个支持的文件系统都有自己的挂载程序来处理该文件系统的特性。为了简化你的生活，`mount`通常可以从磁盘格式中识别支持的文件系统，并在需要时调用正确的挂载程序。要挂载外部文件系统，你需要设备节点和一个挂载点。根据文件系统，你可能还需要知道你将要挂载的文件系统类型。

### Inodes vs. Vnodes

在我们讨论外部文件系统之前，让我们先谈谈让我困惑很长时间的事情：inode 和 vnode 之间的区别。

FFS 使用索引节点，或称为*inode*，来映射包含数据的磁盘块。当硬盘还是大而昂贵的物品，没有人会在计算机之间移动它们时，这工作得很好。然而，多年来，在机器之间交换磁盘变得越来越流行。

尽管类 Unix 系统在 inode 的概念下访问文件，但 FAT32 文件系统不使用 inode，ext2fs 的 inode 不会直接映射到 FFS 的 inode，CD 使用完全不同的布局。为了以一致的方式访问所有这些文件系统，BSD 需要另一层抽象。

虚拟节点，或*vnode*，是内核用来访问所有文件系统的抽象层。用户永远不会直接操作 vnode，但你会在 OpenBSD 的文档中看到对它们的引用。每个读取或写入磁盘的工具都通过 vnode 进行，将请求映射到文件系统。当你向 FFS 块或 inode 写入时，内核将数据地址到一个 vnode，该 vnode 反过来映射到一个 inode。当你向 FAT32 文件系统写入时，内核将数据地址到一个映射到 FAT32 文件系统中的点的 vnode。你只在处理 FFS 系统时使用 inode，但你的数据在访问任何文件系统时都会通过 vnode。

不要让非 FFS 系统上的 vnode 引用让你困惑。它们是 OpenBSD 的一部分，而不是文件系统的一部分。

### 常见的外国文件系统

常见的国外文件系统包括 MS-DOS、NTFS、ext2fs 和 CD。我们将探讨如何使用 OpenBSD 访问为这些操作系统格式化的磁盘。

#### MS-DOS

OpenBSD 支持 FAT、FAT16 和 FAT32 文件系统。这些格式常见于闪存媒体、旧版 Microsoft 操作系统和软盘。

要挂载具有 FAT 文件系统分区的文件系统，请使用`mount_msdos(8)`。

```
# **mount_msdos /dev/sd3i /mnt**
```

如果不确定磁盘上的哪个分区是 FAT 文件系统，请在驱动器上运行`disklabel(8)`并查看。FAT 文件系统通常位于*i*分区。即使你尝试插入 USB 驱动器并挂载其*i*分区，OpenBSD 也可能识别出它是一个 FAT 系统。

如果你经常使用 FAT 磁盘，可能会调查`/usr/ports/sysutils/mtools`，这是一个用于在不挂载的情况下处理 FAT 文件系统的软件集合。虽然`mount_msdos`相当可靠，但 mtools 提供了一个更优雅的界面。

#### NTFS

要挂载为现代 Microsoft 操作系统格式化的磁盘，请使用`mount_ntfs(8)`。

```
# **mount_ntfs /dev/sd3k /mnt**
```

当我写这篇文章时，OpenBSD 支持 NTFS4（来自 Windows NT）和 NTFS5（在 Windows 2000 和 XP 中）。Windows Vista 及更新的系统目前尚不支持，但当你阅读这篇文章时可能已经支持了。

如果你需要查看 NTFS 文件系统的特定文件属性，请查看`mount_ntfs`手册页以获取详细信息。

#### ext2fs

要挂载 ext2fs 和 ext3fs 文件系统，请使用`mount_ext2fs(8)`。（该程序可以挂载这两种类型的文件系统。）

```
# **mount_ext2fs /dev/sd3l /mnt**
```

由于它们共享 Unix 血统，Linux ext2fs 和 ext3fs 文件系统支持许多类似 FFS 的功能。与 NTFS 不同，你可以在 OpenBSD 中安全地读写 ext2fs 和 ext3fs 磁盘。然而，你不能使用 OpenBSD 读取 ext4fs 分区。

#### CD

用于数据使用的光盘格式使用 ISO-9660 文件系统。要挂载 CD，请使用`mount_cd9660(8)`。

```
# **mount_cd9660 /dev/cd0a /mnt**
```

使用设备的*a*或*c*分区挂载 CD。如果你想节省几个按键，`mount(8)`在自动检测 ISO-9660 文件系统方面非常出色。CD 的设备节点绑定到 CD 驱动器，而不是磁盘本身，因此节点不应该改变，除非你添加另一个驱动器。

如果你对烧录 CD 感兴趣，可以查看`mkhybrid(8)`和`cdio(1)`。

### 外来文件系统所有权

大多数外来的文件系统要么没有文件所有权的概念，要么有与类 Unix 操作系统不兼容的所有权方案。（在这些文件系统中，FAT 和 NTFS 是显著的。）挂载这些类型文件系统的程序会周到地允许你指定文件系统的文件所有权。`-u` 标志允许你指定文件所有者，而 `-g` 标志允许你指定组。

例如，我会这样挂载一个属于我账户的 FAT 文件系统：

```
# **mount_msdos -u mwlucas -g mwlucas /dev/sd3c /mnt**
```

一些其他文件系统使用与 OpenBSD 权限方案兼容的权限。例如，OpenBSD 需要的所有信息都包含在一个 ext2fs 文件系统中，以分配文件和目录的权限。但这并不意味着 ext2fs 文件系统在 OpenBSD 上会无缝运行。尽管 OpenBSD 会尊重 ext2fs 磁盘的权限，但用户 ID 数字可能在操作系统之间不匹配。

## 可移动介质

这些天，你可能会处理的可移动介质主要是外置硬盘、闪存驱动器和 CD。CD 是最简单的，因为你知道如何使用 `mount(8)` 和 `umount(8)`，你也知道它的设备节点和文件系统类型始终相同。但你是如何识别可移动硬盘的设备名称的呢？

当你将驱动器连接到你的机器时，OpenBSD 会自动为你分配一个设备节点到控制台，并在控制台上打印一条消息。你可以在连接驱动器时检查控制台，或者你可以在连接驱动器之前运行 `tail -f /var/log/messages` 来查看你的消息日志。

如果你经常使用某个特定的可移动磁盘，你可以通过为它创建一个 */etc/fstab* 条目来简化你的常规操作。以下是一个 CD 和 FAT 闪存驱动器的 */etc/fstab* 条目的示例。

```
/dev/cd0c /cdrom cd9660 ro,noauto
/dev/sd3i /mnt msdos rw,noauto
```

你不能为可移动介质使用 DUIDs，因为实际的介质可能会改变。

现在，你可以通过输入 `mount /cdrom` 在 */cdrom* 上挂载你的 CD，并通过输入 `mount /mnt` 在 */mnt* 上挂载你的 FAT 闪存驱动器。

注意，OpenBSD 默认不会创建 */cdrom* 目录；你需要自己创建它。你可以将这两个都指向 */mnt*，但我喜欢在我的系统上有一个专门的 CD 挂载点，并且让两个设备共享挂载点可能会隐藏其中一个文件系统。（记住，OpenBSD 有可堆叠的挂载，如第八章所述。第八章。）

## 挂载文件系统镜像

你可以挂载一个磁盘镜像，就像访问一个磁盘分区一样访问镜像。这在你想从 ISO 中提取一些文件但不想麻烦将镜像烧录到物理介质时非常有用。挂载磁盘镜像的技巧是将镜像附加到设备节点，这样你就可以使用正确的 `mount` 命令。

OpenBSD 使用`vnconfig(8)`程序将磁盘镜像连接到设备节点。（记住，vnode 是内核和文件系统之间的抽象层。）使用`vnconfig`在文件和设备节点之间“连接”vnode，然后通过 OpenBSD 的*/dev/svnd*设备访问它们。根据磁盘镜像类型，镜像可能包含 MBR 分区、disklabel 分区，或者只是一个文件系统。

默认内核有四个 vnode 设备。如果你需要同时挂载超过四个磁盘镜像，请使用`config(8)`的`-e`选项编辑你的内核二进制文件，如第十八章（Chapter 18）中所述。

### 将 Vnode 设备连接到磁盘镜像

`vnconfig(8)`命令接受两个参数：你想要使用的设备节点和你想要挂载的磁盘镜像。

```
# **vnconfig /dev/svnd*X*c /path/to/file**
```

注意，此示例使用设备的*c*分区。这允许你将磁盘镜像视为整个磁盘。

假设你有一个名为*install52.iso*的 ISO 镜像，你想将其挂载。首先，使用`vnconfig`将此镜像连接到 vnode 设备 0。

```
# **vnconfig /dev/vnd0c install52.iso**
```

然后，你可以使用`mount`将 vnode 连接到*/mnt*目录。

```
# **mount /dev/vnd0c /mnt/**
```

OpenBSD 的`mount(8)`足够智能，能够识别这是一个 CD 文件系统并将其以这种方式挂载。如果你要挂载使用不太易检测的文件系统的磁盘镜像，你需要使用该文件系统的特定`mount`命令。

### 从镜像中分离 Vnode 设备

连接到文件的 vnode 设备会一直保持连接状态，直到明确断开连接。你一次只能将一个 vnode 设备连接到一个文件。要断开 vnode 设备与文件的连接，请使用`vnconfig`的`-u`标志。例如，要断开位于*vnd0c*的 vnode 设备，请运行以下命令：

```
# **vnconfig -u vnd0c**
```

你现在可以将这个 vnode 设备连接到另一个文件。

在`vnconfig`中使用设备的完整路径是可选的。如果你知道设备名称，你可以使用它而不需要前面的*/dev*，就像前面的例子中那样。

## 基本 NFS 设置

NFS 允许一台机器访问另一台机器上的文件。NFS 起源于 UNIX，但今天它出现在大多数操作系统中，包括来自 Microsoft 和 Apple 的系统。OpenBSD 作为客户端和服务器支持 NFS 的 1 到 3 版本。

关于 NFS 可以写整本书——实际上也确实有人这么做了。我们不会深入探讨 NFS 的细节，而是专注于在 OpenBSD 上使基本的 NFS 共享工作。第一次配置 NFS 可能会让人感到害怕，但配置一个或两个文件共享后，你会发现它非常直接。

如果你有一个复杂的多版本多操作系统的 NFS 环境，或者你想要在数百个活跃客户端之间共享一个目录，你应该进行进一步的研究，但即使是一个基本的设置也会帮助你简化工作的一部分。

NFS 基于客户端/服务器模型。一台计算机（服务器）向其他计算机提供文件系统。服务器正在*导出*一个文件系统，提供的文件系统称为*导出*。NFS 客户端可以以几乎与挂载本地文件系统相同的方式挂载导出。

关于 NFS 的一个重要事项是它是无状态的，这意味着 NFS 不会跟踪连接的状态。你可以重启 NFS 服务器，客户端不会出现异常。当服务器关闭时，客户端无法访问服务器上的文件，但一旦服务器恢复，客户端会从上次停止的地方继续。其他网络文件系统并不总是如此有弹性。无状态性也会带来它自己的问题。例如，客户端无法知道他们当前正在读取的文件是否已被其他客户端修改。

如果你刚开始学习 NFS（或 OpenBSD 对 NFS 的实现），请检查*/var/log/messages*以查找与 NFS 相关的错误信息。如果你在学习过程中反复重新配置 NFS 服务器，但事情仍然无法正确工作，请重启 NFS 服务器和/或客户端。NFS 很复杂，有时从头开始清理堆栈可以解决很多问题。一旦你了解了所有部件如何组合在一起，重启以解决问题通常就不再必要了。

### 注意

NFS 协议在多年中不断发展，每个操作系统都实现了略有不同的 NFS 版本。其他 BSD、Illumos、Linux、Apple、Microsoft 以及大多数其他操作系统都可以与 OpenBSD 的 NFS 支持一起工作，但每个可能都需要针对特定环境进行偶尔的调整。如果你在尝试让 NFS 与 OpenBSD 和另一个操作系统一起工作时遇到问题，请阅读`mount_nfs(8)`并将详细信息输入到你喜欢的搜索引擎中。其他人之前可能已经遇到过这个问题，可能性很大。

## OpenBSD NFS 服务器

默认情况下，OpenBSD 包含了作为 NFS 服务器所需的所有程序，但你必须将其启用。NFS 服务器需要三个守护进程：

+   ****`portmap(8)`****. 将远程过程调用（RPC）服务的请求映射到 TCP/IP 端口号。

+   ****`mountd(8)`****. 监听传入的 NFS 挂载请求。

+   ****`nfsd(8)`****. 处理文件系统操作的请求。

`portmap(8)`守护进程有自己的*rc.conf*标志，因为它可以被许多其他 RPC 服务使用。`mountd(8)`和`nfsd(8)`守护进程由单个*rc.conf*标志控制。

将以下条目添加到*rc.conf.local*以在启动时启动所有三个进程：

```
portmap=YES
nfs_server=YES
```

你可以从*/etc/rc.d*中的脚本启动这三个守护进程。然而，如果你现在尝试启动这些守护进程，它们将不会运行。在 NFS 服务器守护进程启动之前，你必须至少配置一个导出。

### 导出文件系统

要导出文件系统，定义哪些客户端可以挂载哪些文件系统以及/或目录在`/etc/exports`中。此文件为服务器上的每个磁盘设备以及可以访问该磁盘设备的每个客户端或客户端组占用单独的一行。每一行最多有三个部分：

+   要导出的目录或分区

+   那个出口的选项

+   允许连接的客户端

在`/etc/exports`条目的三个组成部分中，只有目录是必需的。目录路径不能包含符号链接、双点或单点。

如果我想将我的家目录以读写方式导出到互联网上的每个主机，我可以使用只包含我的`/home`文件夹路径的*exports*行：

```
/home/mwlucas
```

这个完全有效（但非常愚蠢）的条目没有任何选项和主机限制。

要导出位于同一分区的多个目录，用单个空格将它们分开。

```
/home/mwlucas /home/lasnyder
```

你可以在一行中列出任意数量的目录，只要它们位于同一分区上。

NFS 客户端只能挂载在`/etc/exports`中指定的确切目录。如果你导出`/home/mwlucas`，客户端只能将`/home/mwlucas`附加到挂载点。他们不能挂载，比如，`/home/mwlucas/bin`。如果你想导出整个分区，你也可以这样做。如果你想允许客户端挂载挂载点下任何目录，指定挂载点和`-alldirs`选项。你不能在子目录中使用`-alldirs`；它必须是实际的挂载点。此条目允许任何人挂载`/home`中的任何目录：

```
/home -alldirs
```

要导出多个分区或来自多个分区的目录，请在单独的行中指定它们。

```
/home -alldirs
/var/log
```

每次你更改`/etc/exports`时，都必须通知`mountd`重新读取其配置。你可以通过将`reload`参数传递给`mountd`启动脚本来完成此操作：

```
# **/etc/rc.d/mountd reload**
```

虽然这些简单的挂载让你了解了 NFS 的工作方式，但它们非常不安全。要创建一个智能导出，你需要一些选项和访问列表。让我们看看 NFS 的一些常用选项。

### 只读挂载

你可能希望分享文件时无需担心下属是否会删除、修改或以其他方式撤销你的辛勤工作。你可以通过使用`-ro`选项将文件以只读方式共享。在这里，我将我的家目录提供给世界上所有的计算机，但作为一个只读共享：

```
/home/mwlucas -ro
```

这比向整个世界提供我的 NFS 导出读写权限稍微聪明一点，但只是稍微聪明一点。

### NFS 和用户

你已经知道文件所有权和权限与 UID 数字相关联。与许多其他文件共享协议不同，NFS 也使用 UID 来标识文件所有权。例如，在我的测试服务器上，我的账户`mwlucas`使用 UID 1000；在我的客户端，我的`mwlucas`账户也使用 UID 1000。这简化了我的生活，因为我无需过多担心文件所有权；服务器上`mwlucas`拥有的文件在客户端也是由`mwlucas`拥有的。

在只有少数用户和机器的小型网络中，^([22]) 你可能通过在所有系统上为同一用户分配相同的 UID 来无问题地保持 UID 号码同步。但在大型网络中，如果有多个用户，并且用户在自己的机器上有 root 权限，文件所有权可能会迅速成为一个严重问题。解决这个问题最好的办法是通过 LDAP 或 Kerberos 维护一个授权用户的中央存储库。

无论你如何管理你的用户，NFS 对 root 账户的处理方式都不同。NFS 服务器不能信任客户端机器上的 root 来以 root 身份在服务器上执行命令或写入文件；如果是这样，一个 NFS 客户端的漏洞就意味着 NFS 服务器的漏洞。默认情况下，来自客户端的 root 请求被映射到 UID 和 GID 32767（也称为`nobody`）。

如果你想要将 root 映射到特定的用户而不是通用的 UID `nobody`，请使用`-maproot`选项并指定一个用户名或 UID。在这里，我们将来自客户端的 root 请求映射到服务器上的`nfsroot`用户：

```
/home/mwlucas -maproot=nfsroot
```

你可以通过在用户名后指定它们，并用冒号分隔来给映射的 root 用户一个远程 root 账户可以访问的组列表。在这里，我们给客户端的 root 用户以`nfsroot`用户和`customers`、`webmasters`组的权限访问服务器：

```
/home/mwlucas -maproot=nfsroot:customers:webmasters
```

如果你想要明确地从所有组中移除映射的 root 用户，在用户名或 UID 后放置一个冒号，如下例所示：

```
/home/mwlucas -maproot=nfsroot:
```

假设你希望所有 NFS 客户端，无论客户端系统上的用户名如何，都使用 NFS 服务器上的单个用户 ID。`-mapall`选项允许你这样做。此选项使用与`-maproot`选项相同的格式。在这里，我们将所有 NFS 用户映射到服务器上的用户名`nfsuser`：

```
/home/mwlucas -mapall=nfsuser
```

正确控制用户访问将有助于保护你的 NFS 服务器。

### 允许的客户端

默认情况下，每个主机都可以访问你的 NFS 服务器。由于许多原因，这并不是一个好主意。你可以通过在导出条目末尾列出它们的 IP 地址来限制允许访问你的 NFS 服务器的客户端。

```
/home/mwlucas 192.0.2.1
```

你也可以通过主机名指定客户端，但如果服务器有 DNS 故障，它将不允许任何客户端访问。

```
/home/mwlucas treble.blackhelicopters.org
```

要允许访问整个网络，请使用`-network`和`-mask`选项。以下示例使用子网掩码允许访问地址 192.0.2.0 到 192.0.2.15。（如果你不熟悉子网掩码，请阅读第十一章。）

```
/home/mwlucas -network=192.0.2.0 -mask=255.255.255.240
```

当设置你的 NFS 服务器时，我建议你只授予需要访问的主机权限。

### 一个分区多个导出

对于每个分区和允许的客户端的组合，你只能有一行。如果*/home*是一个单独的分区，你不能有一个看起来像这样的导出文件：

```
/home/mwlucas -maproot=nfsroot: 192.0.2.1
/home/pkdick 192.0.2.1
```

如果两个目录位于同一分区上，NFS 不允许您使用不同的权限将它们导出到同一主机。然而，您可以像这里所示的那样，将一个分区的目录导出到不同的主机，使用不同的权限。

```
/home/mwlucas -maproot=nfsroot: 192.0.2.1
/home/pkdick 192.0.2.2
```

您可以将分区的目录导出到不同的主机，使用不同的权限。

```
/home/mwlucas -maproot=nfsroot: 192.0.2.1
/home/mwlucas -maproot=root 192.0.2.2
```

只有通过结合 IP 限制和控制用户权限，您才能有效地控制 NFS 服务器访问。

## NFS 客户端

OpenBSD 的 NFS 客户端不需要任何守护进程或配置。只需`mount`远程文件系统。在这里，我将我的服务器`treble`上的家目录挂载到`/mnt`：

```
# **mount treble:/home/mwlucas /mnt**
```

当通过 NFS 挂载远程文件系统时，输入主机名或 IP 地址，一个冒号，然后是目录。因为我客户端和服务器上的 UID 相同，所以我可以像处理本地文件系统上的文件一样访问、修改、删除和添加`/mnt`中的文件。

使用`df(1)`或`mount(8)`验证您的挂载。

```
$ **df -h**
Filesystem             Size    Used   Avail Capacity  Mounted on
/dev/sd0a             1005M    266M    689M    28%    /
…
treble:/home/mwlucas  26.9G   21.5M   25.5G     0%    /mnt
```

通过 NFS 挂载的目录显示得像任何其他挂载点一样。

要在启动时自动挂载 NFS 共享，或者只是为了方便将来使用，您可以使用`/etc/fstab`条目。如果您的系统在启动时可能没有 DNS 可用，请使用 NFS 服务器的 IP 地址。以下示例指定了两个`fstab`条目：一个使用主机名，一个使用 IP 地址：

```
treble:/home/mwlucas /mnt nfs,noauto rw 0 0
192.0.2.88:/usr/ports /usr/ports nfs,noauto ro 0 0
```

将所有 NFS 分区设置为`dump`和`fsck`的数字为`0`。不要在 NFS 挂载点上运行`fsck`或`dump`，因为这些程序需要原始磁盘访问，而 NFS 不提供这种访问。

使用您喜欢的任何其他挂载选项。OpenBSD 社区建议在适用时使用`noexec`、`nodev`和`nosuid`。我建议在不需要用于正常服务器操作的非 NFS 分区上使用`noauto`，这样不可用的 NFS 服务器就不会挂起您的机器的启动过程。

NFS 性能在很大程度上取决于您的硬件、本地网络、涉及的客户端和服务器、月亮的相位以及无数其他因素。如果您对 NFS 性能不满意，请阅读`mount_nfs(8)`并尝试使用 TCP 或 UDP、读写大小以及可能的时间超时进行实验。如果您需要一个复杂的 NFS 环境，您绝对应该花些时间学习更多关于 NFS 的知识。

## 软件 RAID

红外独立磁盘阵列（RAID）技术已成为在机器内镜像硬盘或组合多个硬盘以形成一个巨大分区的标准方式。在许多类型的 RAID 阵列中，如果一个硬盘故障，系统可以在您更换故障硬盘或第二个硬盘故障之前继续运行而不会丢失数据。

您可以从硬件中获得 RAID，或者让操作系统执行 RAID 操作。硬件 RAID 控制器看起来很棒，但实际上只是运行特殊软件的不错的磁盘控制器。使用`softraid(4)`驱动程序，OpenBSD 可以做到同样的事情，让您可以使用普通磁盘构建 RAID 数组。您可以使用与硬件 RAID 控制器一样多的磁盘和 OpenBSD 的 RAID 管理程序`bioctl(8)`以及`softraid(4)`软件 RAID 驱动程序来做几乎所有的事情。

### 注意

除了管理软件 RAID 之外，OpenBSD 的`bioctl(8)`还可以管理大多数类型的硬件 RAID 控制器。如果您计划使用硬件 RAID，阅读`bioctl`手册绝对值得您花时间。

### RAID 类型

OpenBSD 支持以下 RAID 配置：

> **RAID-0，或**条带化
> 
> 这种类型不是冗余的。它至少需要两个相同大小的磁盘，数据在磁盘之间共享以增加分区大小和提高吞吐量。您可以使用 RAID-0 将五个 4TB 磁盘组合成一个 20TB 的虚拟磁盘，但请注意：如果数组中的任何一个硬盘驱动器失败，您将丢失所有数据。RAID-0 在您需要非常大的文件系统时很有用，但它比单个磁盘更脆弱，因为它提供了多个故障点（或者正如我的一位半文学、半幽默的朋友曾经说过，“RAID-0 给‘一磁盘统治一切’这个短语赋予了全新的意义’）。RAID-0 数组的大小是所有硬盘驱动器大小的总和。
> 
> **RAID-1，或**镜像
> 
> 在这种类型中，一个磁盘的内容被复制到另一个磁盘上。镜像至少需要两个相同大小的磁盘，RAID-1 数组的大小等于数组中最小驱动器的大小。我使用镜像来保护所有重要数据，因为它甚至给廉价的桌面机箱服务器提供了一定程度的数据保护。OpenBSD 的软件 RAID 完全支持这一级别。
> 
> **RAID-4，或**跨磁盘条带化数据，并使用专用奇偶校验磁盘
> 
> 这种类型至少需要三个相同大小的磁盘。奇偶校验数据允许 RAID 阵列在丢失磁盘的情况下恢复数据，而 RAID-4 将奇偶校验数据存储在特定的磁盘上。这意味着您可以在不丢失数据的情况下丢失任何一个磁盘。当我写这段话的时候，`bioctl`的 RAID-4 支持是实验性的。希望这本书到达您手中之前，这种支持已经完善，但如果不是这样，您将需要使用硬件 RAID 卡来获得 RAID-4。
> 
> **RAID-5，或**跨所有驱动器共享奇偶校验的条带化
> 
> 这是当前行业标准的冗余。奇偶校验数据提供数据冗余——单个驱动器的丢失不会破坏任何数据。它需要至少三个相同大小的磁盘。与 RAID-4 不同，RAID-5 同时将奇偶校验数据共享到所有驱动器上。虽然吞吐量不如 RAID-0，但 RAID-5 阵列可以同时处理多个 I/O 请求。你的 RAID-5 阵列的大小是除了一个硬盘之外所有硬盘的总大小。如果你有五个 4TB 的硬盘，阵列将是 16TB（（5 - 1）× 4TB）。与 RAID-4 一样，`bioctl`中的 RAID-5 支持是不完整和实验性的。我希望在你阅读此内容之前它将完成，但如果不是，你将需要使用硬件 RAID 卡来使用 RAID-5。

根据 RAID 标准，这些级别中的每一个都需要相同大小的磁盘。但话虽如此，OpenBSD 的`softraid`使用分区而不是磁盘。你可以使用不同大小的磁盘，但你的 RAID 阵列将只使用每个磁盘上与最小驱动器相等的空间。如果你想镜像一个 1TB 的驱动器和 2TB 的驱动器，你的镜像将只提供 1TB 的空间。较大驱动器上的多余空间将被浪费.^([23])

除了标准的 RAID 方法之外，`softraid`还允许你加密 RAID 阵列中所有磁盘上的数据（如加密磁盘分区中所述）。它还允许你*连接*磁盘。连接的磁盘只是连续运行以创建一个大的虚拟磁盘。你可以连接两个 500GB 的磁盘和一个 1TB 的磁盘来创建一个 2TB 的分区。这些磁盘不需要相同的大小，但与 RAID-0 一样，它们是脆弱的。任何单个磁盘的损坏都将完全破坏虚拟磁盘并丢失所有数据。由于创建连接磁盘的过程与创建 RAID-0 磁盘的过程非常相似，我们将在创建 softraid 设备中介绍它。

### 为 softraid 准备磁盘

`softraid`软件 RAID 设备使用 disklabel 分区构建其虚拟磁盘。要在`softraid`阵列中使用磁盘，就像为常规文件系统中的磁盘准备一样准备它。

在 i386 和 amd64 上，`softraid`设备下的磁盘需要一个 MBR 分区。要使用单个 MBR 分区标记整个磁盘，请在磁盘上运行`fdisk -i`。

假设你有五个磁盘要用于 RAID 阵列：`sd2`、`sd3`、`sd4`、`sd5`和`sd6`。你需要按照以下方式准备每个磁盘：

```
# **fdisk -i sd2**
Do you wish to write new MBR and partition table? [n] **y**
Writing MBR at offset 0.
```

对阵列中的每个磁盘重复此操作。

一旦你为所有磁盘添加了 MBR，你需要在每个磁盘上放置一个 disklabel 分区。我倾向于使用分区字母*p*（最后一个可用的分区字母）为`softraid`设备设置分区。以下是设置`softraid`磁盘的方法：

```
  # **disklabel -E sd2**
  Label editor (enter '?' for help at any prompt)
**1** > **a**
**2** partition: [a] **p**
  offset: [64]
  size: [104856191]
**3** FS type: [4.2BSD] **RAID**
**4** > **q**
**5** Write new label?: [y] **y**
```

首先，我们使用 `a` **1** 添加一个分区，并分配分区字母 `p` **2**。我们不是使用我们常用的 4.2BSD 文件系统类型，而是分配一个 `RAID` **3** 文件系统类型。然后我们退出 **4** 并让 `disklabel` 将更改写入磁盘标签分区 **5**。

如果你有多块相同的磁盘，你可以使用 `disklabel` 来保存这块磁盘的配置，如下所示：

```
# **disklabel sd2 > disklabel.sd2.raid**
```

这将把磁盘 `sd2` 上的标签保存到文件 *disklabel.sd2.raid* 中。你可以使用 `disklabel(8)` 将这种分区复制到其他磁盘，`disklabel` 在复制时会为每个磁盘分配一个唯一的 DUID。这可以节省你为每个磁盘通过交互式编辑器的需要。让我们将这个 disklabel 应用到每个分区：

```
# **disklabel -R sd3 disklabel.sd2.raid**
# **disklabel -R sd4 disklabel.sd2.raid**
# **disklabel -R sd5 disklabel.sd2.raid**
# **disklabel -R sd6 disklabel.sd2.raid**
```

磁盘 `sd2` 到 `sd6` 现在已准备好被整合到 `softraid` 中。

### 创建 softraid 设备

使用 `bioctl(8)` 将磁盘拖入软件 RAID。你需要包含在 RAID 中的磁盘分区。OpenBSD 软件 RAID 数组以 `softraid` 开头，后面跟着一个数字。使用 `-c` 参数来指定 RAID 类型，使用 `-l` 来指定分区，并以你创建的 `softraid` 的名称结束。

```
# **bioctl -c *raidlevel* -l *partition1,partition2*… softraid*X***
```

我们有五个磁盘分区——`sd2p`、`sd3p`、`sd4p`、`sd5p` 和 `sd6p`——要添加到 `softraid` 设备中。要从这些分区构建一个 RAID-5 设备，请运行以下命令：

```
# **bioctl -c 5 -l sd2p,sd3p,sd4p,sd5p,sd6p softraid0**
softraid0: SR **1** RAID 5 volume attached as **2** sd7
```

响应表明我们已成功创建了一个 RAID-5 设备 **1**，并且它作为设备 `/dev/sd7` **2** 可用。在一个空白 RAID 磁盘上，你需要像其他任何新磁盘一样准备它，运行 `fdisk -i sd7` 和 `disklabel` 来创建 MBR 和 OpenBSD 分区，使用 `newfs` 在新分区上创建文件系统，然后你就可以开始了。（有关添加新磁盘的说明，请参阅第八章的详细说明。）

你可以通过选择不同的 `-c` 选项将这个设备做成 RAID-0、RAID-1 或 RAID-4 设备。复杂的是串联的 `softraid`。要将所有磁盘一起放入一个单一的串联虚拟分区中，请使用 `-c c`。

```
# **bioctl -c c -l sd2p,sd3p,sd4p,sd5p,sd6p softraid0**
softraid0: SR CONCAT volume attached as sd7
```

### softraid 状态

要检查 RAID 数组中每个设备的健康状态，给 `bioctl` 提供一个 `softraid` 设备的设备名。

```
# **bioctl softraid0**
Volume      Status               Size Device
softraid0 0 Online       214744170496 sd7     RAID5
          0 Online        53686099456 0:0.0   noencl <sd2p>
          1 Online        53686099456 0:1.0   noencl <sd3p>
          2 Online        53686099456 0:2.0   noencl <sd4p>
          3 Online        53686099456 0:3.0   noencl <sd5p>
          4 Online        53686099456 0:4.0   noencl <sd6p>
```

我们可以看到，五个驱动器正在使用中，全部组装成一个 RAID-5 虚拟驱动器。这里的一切看起来都很健康。任何看起来不太像这样的事物都表明存在问题。

### 识别失败的 softraid 卷

如果你有一个 RAID-1、RAID-4 或 RAID-5 `softraid` 卷，即使丢失一个驱动器也不会丢失你的数据。`bioctl` 会告诉你哪个驱动器失败了。这里，我的 `softraid` 卷中的一个驱动器已经失败了：

```
# **bioctl softraid0**
Volume      Status               Size Device
softraid0 0 Degraded     214744170496 sd7     RAID5
          0 Online        53686099456 0:0.0   noencl <sd2p>
          **1 Offline**                  **0 0:1.0**   **noencl <>**
          2 Online        53686099456 0:2.0   noencl <sd3p>
          3 Online        53686099456 0:3.0   noencl <sd4p>
          4 Online        53686099456 0:4.0   noencl <sd6p>
```

仔细观察，我可以看到驱动器 `sd2`、`sd3`、`sd4` 和 `sd6` 仍然可用并且在使用中。我的所有数据应该仍然完好无损，但在另一个磁盘失败之前，我需要更换 `sd5`。

### 重建失败的 softraid 卷

到我写这篇文章的时候为止，你无法重建失败的`softraid` RAID-4 或 RAID-5 设备。你必须备份你的数据，更换失败的驱动器，删除`softraid`设备，重新创建文件系统，并从备份中恢复。然而，你可以重建 RAID-1 设备。

让我们看看如何在 RAID-1 设备中更换磁盘。一个健康的三磁盘`softraid`镜像可能看起来是这样的：

```
# **bioctl softraid0**
Volume      Status               Size Device
softraid0 0 Online        53686099456 sd5**1**  RAID1
          0 Online        53686099456 0:0.0   noencl <sd2p>**2**
          1 Online        53686099456 0:1.0   noencl <sd3p>
          2 Online        53686099456 0:2.0   noencl <sd4p>
```

注意，这个 RAID 设备具有设备节点`sd5`[1]并且包括分区*sd2p*、*sd3p*和*sd4p*[2]。

我们更换了两个磁盘并重新启动这台机器。突然，*softraid*设备看起来非常不同。

```
# **bioctl softraid0**
Volume      Status               Size Device
softraid0 0 Degraded      53686099456 sd5     RAID1
          0 Offline                 0 0:0.0   noencl <>
          1 Offline                 0 0:1.0   noencl <>
          2 Online        53686099456 0:2.0   noencl <sd2p>
```

分区*sd3p*和*sd4p*丢失。这是因为底层磁盘已被更换。^[[24]) 准备替换磁盘以用于软件 RAID，如为 softraid 准备磁盘中所述。然后运行`bioctl`，使用`-R`标志指定`softraid`设备中要更换的磁盘。

```
# **bioctl -R /dev/sd3p sd5**
softraid0: rebuild of sd5 started on sd3p
```

如果你使用`bioctl`检查设备的状况，你会看到磁盘状态现在显示为“重建中。”

如果你有一个包含两个以上磁盘的镜像，你必须单独重建每个磁盘。先重建第一个磁盘，然后重建第二个磁盘。

### 删除 softraid 设备

要从你的系统中移除`softraid`设备，向`bioctl`传递`-d`标志和`softraid`设备的设备名。以下是如何移除我们刚刚创建的 RAID-5 设备的方法：

```
# **bioctl -d sd7**
```

### 警告

一旦你删除了 RAID 设备，除非你重新创建它并从备份中恢复数据，否则你无法恢复它。

### 重复使用 softraid 磁盘

`softraid`在其使用的磁盘开头写入元数据。在使用这些磁盘作为另一个`softraid`设备之前，你需要覆盖这些元数据。使用`dd(1)`覆盖磁盘的前一兆字节左右。

```
# **dd if=/dev/zero of=/dev/sd2c bs=1k count=1024**
1024+0 records in
1024+0 records out
1048576 bytes transferred in 0.594 secs (1765074 bytes/sec)
```

这将擦除 MBR 分区、任何初始磁盘标签以及磁盘上的任何文件系统信息。你现在可以像普通磁盘一样在`softraid`设备中重复使用这些磁盘。

### 从 softraid 设备启动

`softraid`功能仍在开发中。最终，你将能够使用安装程序构建一个软件 RAID 设备，在该设备上安装 OpenBSD，并直接运行完整的 RAID 配置。但在我写这篇文章的时候，你需要跳过一些步骤才能实现这一点。而不是记录一个会随着 OpenBSD 完成`softraid`开发而变化的特定过程，我将告诉你去互联网和*misc@OpenBSD.org*存档中搜索最新的说明。

## 加密磁盘分区

有时候我能看到未来。当有人说，“我已经加密了我的硬盘！”我会有一种通灵的感觉，他们会在说“我丢失了所有数据！”虽然在某些情况下加密硬盘分区是合理的，但大多数时候，这只是虚荣。在本节中，我将假设你理解何时真正需要磁盘加密，如果你在我丢失数据时不对我说抱怨，我将对你表示礼貌。

### 创建加密分区

OpenBSD 将磁盘加密作为`bioctl(8)`选项——具体来说，就像 RAID 纪律一样。在磁盘活动通常通过 RAID 纪律传递的地方，这里它们通过加密纪律传递。加密磁盘甚至显示为`softraid`设备。与对 RAID-5 的支持类似，对加密文件系统的支持是实验性的。尽管它*应该*工作，但如果某些功能尚未包含或如果它吃掉了你的整个磁盘，请不要感到惊讶。做好备份。重新阅读上一段。再次——*请*不要在我面前抱怨它不起作用。

在 OpenBSD 下，加密卷只能包含单个分区。使用 RAID 类型`C`来指定加密卷。以下是如何在`sd4p`分区上创建加密卷的步骤：

```
  # **bioctl -c C -l sd4p softraid0**
**1** New passphrase:
  Re-type passphrase:
  softraid0: SR CRYPTO volume attached as sd5
```

当提示**1**时，请输入密码短语两次。一个好的密码短语应该由多个单词组成，并包含字符、符号、数字、标点符号和空格的混合。密码短语是用于加密和解密数据的秘密代码，因此它越长、越多样化，就越好。记住这个密码短语；你必须再次输入它才能恢复你的数据。一旦你两次输入了你的密码短语，`bioctl`就会创建加密的磁盘设备。在这种情况下，它创建了一个加密磁盘`softraid0`作为`disk sd5`。

### 使用加密分区

不要立即挂载这个新磁盘！相反，使用`fdisk`来检查我们的新加密分区。

```
# **fdisk sd5**
Disk: sd5       geometry: 6526/255/63 [104855663 Sectors]
Offset: 0       Signature: 0x8BF9
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
 0: D9 230285  63  36 - 134263  55  58 [  3699532529:  2752373385 ] <Unknown ID>
 1: 8C  73068 221  44 - 176434  56  49 [  1173851386:  1660564401 ] <Unknown ID>
 2: C9 218148  78  47 - 141866 243  13 [  3504552580:  3069507328 ] <Unknown ID>
 3: AC 125252   6   1 - 245307  77  22 [  2012173758:  1928688070 ] <Unknown ID>
```

基础磁盘是空的，我们的`fdisk`输出看起来像垃圾，但这个磁盘现在是一个加密卷。

现在加密磁盘已经存在，创建 MBR 分区并添加 disklabel 分区，就像添加任何其他磁盘一样。然后你可以使用设备节点挂载你的加密设备分区——再次，就像任何其他磁盘一样。

要卸载解密分区，通过传递`bioctl`的`-d`参数来销毁`softraid`设备。

```
# **bioctl -d sd5**
```

对于没有密码短语的人来说，这个分区现在看起来像随机的垃圾。

### 自动解密

如果你有一个加密分区，你大概不希望 OpenBSD 在系统启动时自动解密和挂载它。（加密分区的全部意义在于只有拥有密码短语的人才能访问加密数据。）尽管如此，我不是那种告诉你不要自杀的人，所以如果你必须自动解密分区，你可以这样做。

首先，创建一个包含你的密码文件的文件。将此文件的拥有权赋予 root，并设置权限为`600`（所有者可读写；其他用户无访问权限），然后使用`-p`标志将此文件传递给`bioctl(8)`。在这个例子中，加密硬盘被创建为*/dev/sd5*，并且有一个分区在*/dev/sd5a*上。我已经将我的密码存储在文件*/etc/passphrase*中，所以我可以运行类似以下这样的命令：

```
# **bioctl -c C -l sd4p -p /etc/passphrase softraid0**
# **mount /dev/sd5a /home/mwlucas**
```

将此内容添加到*/etc/rc.securelevel*中将在启动时挂载这个加密分区。

你现在应该对如何管理 OpenBSD 硬盘和文件系统有了很好的了解。接下来，我们将探讨一些 OpenBSD 的特殊安全功能。

* * *

^([21]) 我不知道 128m 的转储级别意味着什么，除了“不是我所希望的。”

^([22]) “几个用户”我是指多少个？当你在所有系统间同步 UID 开始真正、真正地让你感到烦恼时，你就不再只有几个用户了。

^([23]) 你可以在较大驱动器上未使用的空间中添加一个非 RAID 分区，但这会对你的系统性能造成极大的破坏。只是买更多的硬盘，你这个吝啬鬼。

^([24]) 如果需要在硬盘上强制产生错误，从机器上移除硬盘肯定可以做到。

^([25]) 我帮不上什么忙——我所能做的就是说我“早就告诉你了。”顺便说一句：无论多么愉快的事情，如果你经常做，你都会感到厌倦。
