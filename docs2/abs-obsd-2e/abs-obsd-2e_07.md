## 第七章。根用户，以及如何避免它

*万恶之源*

*永远都不会离你太远。*

*sudo 可以救你的命。*

![图片](img/httpatomoreillycomsourcenostarchimages1616079.png) 大多数类 Unix 操作系统的安全性长期以来一直被认为是大粒度的。一个超级用户，root，可以做任何事情。其他用户则是低微的佃农，忍受着 root 强加在他们身上的枷锁。问题是 root 没有多少枷锁，而且它并不能很好地个性化它所拥有的枷锁。一些操作系统使用 POSIX 访问控制列表（ACLs）来提供更细粒度的访问控制，但这些配置起来很困难.^([15])

虽然类 Unix 操作系统的确没有详细的访问控制，但事实是大多数人并不麻烦去使用那些确实存在的控制。幸运的是，你可以结合组和权限来安全地处理几乎所有问题。

## 根用户密码

root 用户拥有系统，并对每一块硬件以及某些需要绝对控制的动作拥有绝对权力，例如操作内核和更改认证源。你需要 root 权限来执行这些任务。你可以以 root 身份登录，使用`su(1)`成为 root，或者使用`sudo(8)`（本章后面将讨论）来获取某些 root 级别的权限，而不必实际使用 root 账户。

要使用 root 密码，你可以要么在控制台登录提示符下以 root 身份登录，要么如果你属于`wheel`组，以自己的身份登录并使用切换用户命令`su(1)`。在这两种方法中，我推荐使用`su`；它会记录谁在使用它，并且当你从远程系统登录时也可以使用。要使用`su`，请运行以下命令：

```
$ **su**
Password:
#
```

当提示时，输入 root 密码。现在使用`id(1)`检查你的当前用户 ID。

```
# **id**
uid=0(root) gid=0(wheel) groups=0(wheel), 2(kmem), 3(sys), 4(tty), 5(operator), 20(staff), 31(guest)
```

如你所见，UID 是 0，这意味着你现在拥有系统，而且我确实是指*拥有*它。仔细考虑每一个按键。粗心大意可能会让你的硬盘回到原始的、未格式化的状态。

只有在`wheel`组中的用户才能使用 root 密码通过`su`成为 root。如果你将 root 密码给了没有物理控制台访问权限且在`wheel`组中的用户，他们可以多次输入`su`和 root 密码，但这不会起作用。（但任何人都可以在系统控制台使用 root 账户和密码，所以不要养成在办公室到处泄露 root 密码的习惯。）

要求加入组才能使用 root 密码引发了一个问题：“谁需要 root 访问权限？”root 是配置 OpenBSD 许多部分所必需的，但一旦系统正常运行，你可以大大减少或停止使用 root。对于任何绝对需要 root 的剩余任务，请使用`sudo`。

## 使用组

减少对 root 需求的最简单方法之一是使用组。类 Unix 操作系统将用户分类到组中，这些组由执行类似管理功能的用户账户组成。例如，你可以定义一个名为 `dnsadmins` 的组，并将编辑 DNS 区域文件的每个用户的账户添加到该组中。然后，通过适当地设置区域文件及其目录的权限，该组的成员可以编辑区域文件并重新加载名称服务器，而无需 root 密码。好消息是，你可以为几乎任何系统功能创建这样的组，从而避免给这些用户 root 访问权限。以这种方式使用组是一种强大且常被忽视的系统管理工具。我使用组来管理我自己的服务器——仅仅因为我 *可以* 使用 root，并不意味着我 *想要* 使用 root。用户可以通过使用 `id(1)` 来识别他们所属的组。

```
# **id**
uid=1000(mwlucas) gid=1000(mwlucas) groups=1000(mwlucas), 0(wheel), 2005(dnsadmin)
```

我的 UID 是 1000，我的用户名是 `mwlucas`。我的 GID，即主要组 ID，也是 1000，并且也命名为 `mwlucas`。我还在 `wheel` 和 `dnsadmin` 组中。

### /etc/group 文件

文件 */etc/group* 包含所有组信息。每一行包含四个由冒号分隔的字段：组名、密码、ID 号和成员列表。

```
wheel:*:0:root,mwlucas,pkdick
```

*组名* 是组的一个便于人类理解的名字。这个组被命名为 `wheel`。组名完全是任意的，如果你想，你可以将一个组命名为 `lickspittles`，但你应该选择一个能让人想到组目的的名字。虽然你可能记得 `lickspittles` 可以编辑公司网页，但这个组名对你的同事来说有意义吗？如果有，你可能需要更好的同事。

第二个字段是组密码，这是一个伟大的理论，一旦暴露在现实世界中就变成了令人震惊的实践。现代类 Unix 系统对组密码不做什么处理，但这个字段仍然保留，因为旧程序期望在这里找到一些内容。星号只是一个占位符，用来安抚这样的软件。（虽然 OpenBSD 可以消除这个字段，但一些企业会在操作系统之间共享 */etc/group*。）

第三个字段给出了组的唯一数字 GID。许多程序使用 GID 而不是名称来识别组。`wheel` 组的 GID 为 0。最大的 GID 是 232，即 4,294,967,296。

最后是一个用逗号分隔的该组所有用户的列表。正如你所见，用户 `root`、`mwlucas` 和 `pkdick` 都是 `wheel` 组的成员。要向组中添加用户，请将他们的用户名添加到这个列表中，但请记住，没有任何 */etc/group* 条目可以包含超过 200 个用户或超过 1024 个字符。

### 创建组

为了创建一个新组，你需要一个名称和 GID 号码。OpenBSD 通常将下一个可用的 GID 分配给 GID 小于 1000 的新创建的组，因为 GID 小于 1000 的是为 OpenBSD 保留的。需要专用 GID 的 OpenBSD 包含的程序使用小于 1000 的 GID。通过 OpenBSD 软件包系统或 ports（在第十三章中讨论）安装的软件在 500 到 1000 范围内分配专用 GID。用户账户的 GID 从 1000 开始并向上。如果你为特殊角色创建组，从高 GID 开始，这样这些管理组将明显不同于用户账户。

### 组、非特权用户和组权限

创建新组的最简单方法是用 `adduser` 命令为该角色创建一个非特权用户，并使用该用户的组来分配文件权限。与任何其他非特权用户一样，给这个账户分配 */var/empty* 作为家目录和 `nologin` 作为 shell。不要将此用户添加到任何其他组中（特别是不要添加到 `wheel` 组）。最后，让 `adduser` 禁用此账户。当然，shell 会阻止登录，但多一层防御也不会有害。

现在你已经有一个管理用户和一个组，你可以分配文件所有权。每个文件都有一个用户和一个组拥有。要查看现有文件的权限，包括隐藏文件，使用 `ls -la` 命令。（如果你忘记了文件所有权和权限是如何工作的，请阅读 `ls(1)` 和 `chmod(1)`。）许多系统管理员专注于文件所有权和所有者权限，在全局权限上花费的时间较少，并且像它们不存在一样忽略了组权限。仔细查看以下示例 DNS 文件。

```
# **ls -la**
total 22
drwxr-xr-x  2 mwlucas  wheel     512 Apr 16 22:02 .
drwxrwxrwt  8 root     wheel     512 Apr 16 22:00 ..
-rw-rw-r--  1 mwlucas  mwlucas 14595 Apr 16 22:02 michaelwlucas.com.db
-rw-r-----  1 mwlucas  wheel     198 Apr 16 22:02 rndc.key
```

此目录包含两个文件。文件 *rndc.key* 可以被用户 `mwlucas` 读写；`wheel` 组中的任何人都可读取 *rndc.key*；其他人甚至无法读取。文件 *michaelwlucas.com.db* 可以被用户 `mwlucas` 或 `wheel` 组中的任何人读写，但其他人只能读取。如果你在 `mwlucas` 组中，你可以编辑此文件。

假设我想让我的初级 DNS 管理员能够编辑区域文件，但不能编辑 `rndc(8)` 配置。文件权限是正确的，但我需要文件的所有权属于我的 DNS 管理用户 `dnsadmin`。我还想让我 DNS 管理员能够创建新的区域文件，因此他们需要在目录上拥有写权限。以下是我将如何做到这一点：

```
# **chown dnsadmin:dnsadmin michaelwlucas.com.db**
# **chgrp dnsadmin rndc.key**
# **chown dnsadmin:dnsadmin .**
# **chmod 775 .**
# **ls -la**
total 22
drwxrwxr-x  2 dnsadmin  dnsadmin    512 Apr 16 22:02 .
drwxrwxrwt  8 root      wheel       512 Apr 16 22:08 ..
-rw-rw-r--  1 dnsadmin  dnsadmin  14595 Apr 16 22:02 michaelwlucas.com
-rw-r--r--  1 root      dnsadmin    198 Apr 16 22:02 rndc.key
```

如你所见，这些文件现在归用户 `dnsadmin` 和组 `dnsadmin` 所有。组 `dnsadmin` 中的任何人都应该能够在不使用 root 密码的情况下编辑 *michaelwlucas.com.db* 文件。用户 `named`——DNS 服务器的非特权用户——应该能够读取这两个文件。将你的 DNS 管理员添加到 */etc/group* 中的 `dnsadmin` 组，他们就不需要 root 密码来完成他们的工作。

然而，这种模型也有局限性。虽然初级管理员无法意外编辑 *rndc.conf*，但他们可以删除和替换它。最好是将该文件放在一个他们可以读取但不能编辑的目录中。而且，尽管我们的 DNS 管理员可能认为他们需要 root 密码来重新启动名称服务器，但他们错了。使用 `rndc(8)` 来管理 DNS 服务器；其他任务可以通过 `cron(8)` 或通过 `sudo` 来管理。

## 使用 `sudo` 隐藏 root 访问

尽管正确使用组可以几乎消除编辑文件时需要 root 访问的需求，但这对于只能由 root 运行的命令没有帮助。您可以设置一个 cron 作业，每天午夜重新加载名称服务器，但每款软件偶尔都需要手动重启。因为 root 是全有或全无的事情，所以那些只有一项小任务要执行的人传统上需要 root 密码。

OpenBSD 包含 `sudo(8)` 及其相关工具，这些工具实现了仅对特定用户可运行的命令的细粒度访问控制。当配置正确时，`sudo` 允许普通用户以其他用户身份运行特定程序，包括 root。配置不当，`sudo` 允许完全的 root 访问。我将解释一个基本的 `sudo` 设置，它涵盖了几乎所有用途，但请记住，还有许多其他可能的组合。而且不要害怕阅读 `sudo(8)`、`sudoers(5)` 以及 `sudo` 主页上的文档（[`www.gratisoft.us/sudo/`](http://www.gratisoft.us/sudo/)*）。

### 为什么使用 `sudo`？

`sudo` 工具提供的功能远不止细粒度权限控制。通过 `sudo` 运行的每个命令都会被记录，这使得跟踪谁做了什么变得非常容易。高级系统管理员可以更改 root 密码，而无需将其提供给具有 root 级别访问权限的人。

`sudo` 配置文件旨在跨多个系统共享，因此一个 `sudo` 策略可以覆盖您的整个网络和每个操作系统。诚然，在具有独特目录布局的操作系统上使用单个 `sudo` 配置会遇到麻烦，例如 Mac OS X，但您可以在 OpenBSD、其他 BSD、Linux 以及甚至 OpenSolaris 或 AIX 之间轻松共享一个配置。

### `sudo` 的缺点

`sudo` 最常见的问题是让用户接受它。那些历史上可以访问 root 账户的人认为，通过 `sudo` 工作会“失去一些东西”。

克服这一问题的关键是只给用户授予他们完成任务所需的访问权限。一个抱怨权限不足的初级管理员要么超出了他的职责范围，要么需要更多的权限。发现人们实际做什么的一个可靠方法是实施一个最小的 `sudo` 权限方案，并等待投诉。如果没有人投诉，那么他们可能并没有非常努力地工作。

`sudo` 的配置语法可能会令人困惑，因为它的配置与任何其他配置文件都不太相似，而且一开始要完全正确可能很困难。然而，配置文件实际上非常适合其目的。一旦你理解了它，调整权限就会变得快速且容易。

### 注意

更严重的是，一个有缺陷的 `sudo` 设置可能会给人一种安全的感觉，同时留下用户成为 root 的漏洞。确保每次更改后都测试 `sudo`，并避免我在此处记录的常见配置错误。

一些用户会尽力扩大他们的访问权限，没有其他原因，只是想看看他们是否能智胜你。这些用户最好通过仔细的配置、管理政策和一根板球棒来管理。

### sudo 软件概述

`sudo` 程序是一个 `setuid` root 包装器，可以以任何其他用户身份运行命令。通过提供你想要运行的命令来使用 `sudo`。

```
$ **sudo /etc/rc.d/named restart**
```

`sudo` 软件将所需的命令（在这种情况下，`/etc/rc.d/named restart`）与其内部权限和特权列表进行比较。如果配置文件允许特定用户以 root 身份运行该命令，`sudo` 就会以 root 身份运行它。而且，因为 root 可以以任何用户身份运行任何命令，`sudo` 也可以以任何任意系统用户身份运行命令。你可以利用这个事实来授予任何用户以选择用户身份运行特定命令的能力；例如，某些数据库服务器的管理员必须经常以数据库用户身份运行命令。

`sudo` 软件是一个包含四个部分的套件。第一个部分是实际的 `sudo(8)` 命令，`setuid` root 包装器。第二个是配置文件 */etc/sudoers*，它描述了谁可以以什么用户身份运行哪些命令。（*/etc/sudoers* 在 `sudoers(5)` 中有完整文档。）第三个是 `visudo(8)` 命令，它在一个编辑器中打开 */etc/sudoers* 并在退出前检查配置文件语法。最后，`sudoedit(8)` 程序专门用于以其他用户身份编辑文件。

### visudo(8) 命令

如果 */etc/sudoers* 包含错误的语法，`sudo` 将无法运行。如果你依赖 `sudo` 来提供对系统的 root 级别访问，而你又破坏了 *sudoers* 文件，你将无法访问 root 账户，并失去纠正错误的能力。这是很糟糕的。

幸运的是，`visudo(8)` 程序通过锁定 */etc/sudoers* 以防止同时有人编辑配置文件来提供一些保护，这样只有一个人可以同时编辑配置文件。然后，它会在文本编辑器中打开 */etc/sudoers*（默认为 vi，但会尊重 `$EDITOR` 环境变量）。做出你的更改并保存你的工作。当你退出编辑器时，`visudo` 应该解析文件以检查语法正确性。

如果 `visudo` 检测到错误，它会打印出有问题的行号，并询问你想要做什么。

```
>>> /etc/sudoers: syntax error near line 34 <<<
What now?
```

在这里，我在第 34 行附近犯了一个错误。我可以重新编辑文件以修复错误，退出而不保存任何更改，或者强制 `visudo` 接受此文件。

按 E 键，`visudo` 应该返回到编辑器。转到有问题的行，修复你的错误，保存文件，然后再次退出编辑器。

输入 X 键，`visudo` 应该退出并恢复配置文件到其原始状态。你的更改将会丢失，但这可能是可以接受的。拥有一个旧的、可工作的配置比一个新出故障的配置要好。

按 Q 键会强制 `visudo` 接受文件，包括所有错误的语法。如果 `sudo` 无法解析 `/etc/sudoers`，它将立即退出。本质上，你是在告诉 `visudo` 在你以 root 身份登录并修复问题之前破坏 `sudo`。如果你认为你对 `/etc/sudoers` 的理解比 `visudo` 更好，你可能是错的。即使你是对的，你也是错的。

`visudo` 程序并不能保证配置会按照你的期望执行，它只能确保配置能够解析并且是有效的。一个正确格式的配置，声明“任何人不得通过 `sudo` 执行任何操作”，对于 `visudo` 来说是完全可以接受的。

### `/etc/sudoers` 文件

`/etc/sudoers` 文件决定了谁可以以哪个用户身份运行哪些命令。永远不要直接编辑 `/etc/sudoers`，即使你认为你确切知道要做的更改。始终使用 `visudo` 来更改 `/etc/sudoers`。

你会发现的各种 `sudoers` 样本配置通常非常复杂，因为它们展示了 `sudo` 可以做的一切巧妙的事情。然而，在这个阶段，你只想做简单、无聊的事情，比如给特定的用户授权运行特定的命令。而基本的语法非常简单。每个 `sudoers` 规则都遵循以下格式：

```
*Username    host*=*command*
```

+   `*`用户名*` 是可以执行命令的用户名，是用户名的别名，或者是一个系统组。

+   `*`主机*` 是此规则应用到的系统的主机名。你可以将 `/etc/sudoers` 在多个系统之间共享。此条目允许按主机设置规则。

+   `*`命令*` 空间列出了此规则应用的命令。你必须列出每个命令的完整路径，否则 `sudo` 将不会识别它。如果不是这个要求，某个不可信的人可能会调整他的 `$PATH` 来访问命令的重命名版本。

例如，假设我信任用户 `sbaxter` 可以以 root 身份在任意系统上运行任何命令。我使用关键字 `ALL` 来匹配主机和命令的所有可能选项：

```
sbaxter    ALL=ALL
```

作为首席系统管理员，我应该知道我分配给 `sbaxter` 的职责，以及他确切需要哪些命令。假设 `sbaxter` 是我的 DNS 从属。我通过组权限控制实际编辑区域文件，但有许多合法场合他需要停止、重启或以其他方式处理名称服务器程序。我希望他使用系统脚本 `/etc/rc.d/named` 来完成这项任务，而这个 `sudoers` 条目给了他在所有机器上使用该脚本的权限。

```
sbaxter    ALL=/etc/rc.d/named
```

如果我将这个文件在多台机器之间共享，那么很可能许多机器甚至没有运行名称服务器。为了限制我的从属机器只能访问 DNS 服务器，我会更改主机字段。

```
sbaxter    dns1=/etc/rc.d/named
```

然后，`sbaxter` 是电子邮件服务器 `mail1` 的管理员。这个服务器是他的责任，因此他需要运行任何命令。我可以在邮件服务器上为他设置完全不同的权限，同时在所有系统上使用相同的 *sudoers* 文件。

```
sbaxter    dns1=/etc/rc.d/named
sbaxter    mail1=ALL
```

是的，`sbaxter` 可以在 `mail1` 上使用 `visudo`，但他已经拥有该机器上的全部权限。我对此感到满意，因为他知道我会对他负责任何停机时间。

#### sudoers 字段中的多个条目

在单个字段中用逗号分隔多个条目。例如，过了一段时间，我厌倦了 `sbaxter` 让我在 DNS 服务器上挂载 NFS 共享，所以我将 `mount_nfs` 添加到他的权限中。

```
sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs
```

他现在可以挂载他自己的 NFS 共享，并且不再打扰我。

#### 以非 root 用户运行命令

在命令之前指定一个用户名，用括号括起来，表示该用户可以使用 `sudo` 以特定用户身份运行命令。例如，我的用户 `dwsmith` 是数据库管理员，需要在数据库服务器 `db1` 上以用户 `_postgresql` 的身份运行任何命令。

```
dwsmith    db1 = (_postgresql) ALL
```

`_postgresql` 用户无法成功运行像 `fdisk` 和 `newfs` 这样的关键系统程序，但它可以重启数据库、备份数据库并执行其他数据库管理任务。通过选择特定的用户、特定的机器和特定的命令，你可以定义任意复杂的 *sudoers* 策略。

#### 长行

如果一行中有多个命令、用户名或主机，那么这一行可能会变得不舒服地长。使用反斜杠 (`\`) 来表示规则继续在下一行。

```
sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs, \
        /sbin/reboot, /sbin/dump
```

使用尽可能多的行来使你的 *sudoers* 文件更容易管理。

### /etc/sudoers 别名

拥有不同角色的多台机器，添加多个具有不同权限级别的系统管理员，你的 */etc/sudoers* 文件会迅速变得复杂。当你有几个具有相同权限和希望他们访问的长命令列表的用户时，维护每个用户权限列表的一致性会变得繁琐。*别名* 简化了这些任务，并使 */etc/sudoers* 文件更容易理解，这使得你的生活更加轻松。

别名是一组用户、主机或命令。你可以在任何通常使用用户、主机或命令的地方使用别名。例如，你可以创建一个名为 `DATABASE_COMMANDS` 的别名，其中包含所有数据库管理员需要使用 `sudo` 运行的命令。

让我们以数据库管理员 `dwsmith` 为例，并使用别名来指定他的命令。

```
dwsmith    db1 = (_postgresql) DATABASE_COMMANDS
```

这个别名可能看起来没有为我们节省多少，但假设我们有几个数据库管理员。我们可以创建一个名为 `DBAs` 的别名，包括所有他们。

```
DBAs    db1 = (_postgresql) DATABASE_COMMANDS
```

突然，这一行代表了多条规则。所有数据库管理员都有相同的 `sudo` 权限，当你发现你需要给他们访问额外命令的权限时，只需将命令添加到别名中，它就会立即对每个数据库管理员可用。无需在用户之间繁琐且容易出错地复制条目。

在您可以使用之前，必须定义一个别名，因此别名通常位于文件顶部。每个别名由一个标识其类型的标签、一个名称和其项目列表组成。别名类型包括用户别名、运行时别名、主机别名和命令别名。

#### 用户别名

*用户别名* 是一组用户，并且用字符串 `User_Alias` 标记。在这个别名中只放置用户名。

```
User_Alias    DBAs = dwsmith, kkrusch
```

在这里，用户别名 `DBAs` 包含用户 `dwsmith` 和 `kkrusch`。通过在我的 *sudoers* 规则中使用别名而不是用户名，我确保这些用户获得完全相同的 `sudo` 权限。

您可以使用系统组在用户别名中，通过在前面加上百分号（`%`）来实现。我可能在 */etc/groups* 中创建一个名为 `databaseteam` 的组，并将 `dwsmith` 和 `kkrusch` 加入到这个团队中。

```
%databaseteam db1 = (_postgresql) DATABASE_COMMANDS
```

这种用法中最常见的是给 `wheel` 组无限的 `sudo` 访问权限。

```
%wheel ALL = ALL
```

此规则允许 `wheel` 组通过 `sudo` 以 root 身份运行任何命令。这不会改变组成员的权限，但通过 `sudo` 给他们访问权限。这对于运行单个命令来说很方便。

#### 运行时别名

*运行时别名* 是一组用户，其他用户可以以这些用户身份运行命令。例如，在特定的应用服务器上，数据库管理员需要以数据库所有者 `_postgresql` 和 Web 服务器所有者 `www` 的身份运行命令。然而，如果用户必须以多个用户身份运行命令，则需要为每个目标用户创建单独的 *sudoers* 条目。

*运行时别名* 允许您将这些账户分组：

```
Runas_Alias    APPOWNER = _postgresql, www
```

您现在可以编写一条规则，允许用户以 `_postgresql` 或 `www` 身份运行命令。

#### 主机别名

*主机别名* 是一组主机，定义为主机名、IP 地址或网络块。用字符串 `Host_Alias` 标记主机别名。以下是所有主机别名类型的示例：

```
Host_Alias    DB = db1, db2, db3
Host_Alias    DMZ = 192.0.2.0/24
Host_Alias    FIREWALL = 192.0.2.1, 192.0.2.2, 192.0.2.3
```

### 注意

我在这本书的其他地方警告过，基于主机名的安全规则容易受到 DNS 欺骗攻击的威胁。然而，入侵者不能欺骗机器的本地主机名，因此您可以在 *sudoers* 中安全地使用 */etc/myname* 中的主机名。

#### 命令别名

*命令别名* 是一组命令。例如，您可能有一个包含备份系统或从备份中恢复所需的所有命令的命令别名。它们用字符串 `Cmnd_Alias` 标记。

```
Cmnd_Alias    BACKUPS = /bin/mt, /sbin/restore, /sbin/dump
```

您可以使用通配符告诉命令别名包含特定目录中的所有内容。

```
Cmnd_Alias	APPCOMMANDS = /home/appuser/bin/*
```

您也可以列出部分命令名称。例如，大多数 PostgreSQL 的命令都以 `pg_` 前缀开始。要给用户访问这些命令的权限，可以使用如下通配符：

```
Cmnd_Alias    APPCOMMANDS = /home/appuser/bin/*,/usr/local/bin/pg_*
```

如果您发现自己正在编写包含路径如 */sbin/** 的命令别名，请停止并重新考虑，因为您实际上是在给用户无限的 root 权限。

#### 在 /etc/sudoers 中使用别名

正常情况下，使用别名就像列出用户、命令或主机名一样。在之前的示例中，我定义了用户别名 `DBAs`、运行别名 `APPOWNER`、主机别名 `DB` 和命令别名 `APPCOMMANDS`。以下是它们可能的使用方式：

```
DBAs    DB = ALL
```

在这里，用户组 `DBAs` 可以以任何用户身份在任何 `DB` 组的服务器上运行任何命令。该组的成员拥有服务器，如果他们搞砸了，这不是我的问题。

嗯，这种态度听起来不错，但事实是，当他们破坏服务器时，我必须介入。即使他们把数据库服务器推入沟里不是我的错，但这**是我的问题**。我必须锁定他们可以运行的命令，只允许他们运行 `APPCOMMANDS` 别名中的命令。因此，`DBAs` 组现在可以在 `DB` 服务器上运行 `APPCOMMANDS` 中的任何命令。

```
DBAs    DB = APPCOMMANDS
```

然后，我发现我的数据库管理员要么比我之前想的聪明，要么比我之前想的愚蠢。他们以 root 身份运行某些数据库命令，创建了 root 所拥有的日志文件。无特权的数据库用户 `_postgresql` 无法写入这些日志文件，因此应用程序服务器崩溃。解决这个问题需要更改这些日志文件的权限，但数据库管理员没有运行 `chown` 的权限。如果我把更改任意文件权限的能力给他们，那我就不如直接给他们 root 权限。

为了防止这种情况再次发生，我限制了他们的权限，使他们只能以应用程序无特权的用户身份运行他们的命令。

```
DBAs    DB = (APPOWNER) APPCOMMANDS
```

`DBAs` 组中的每个人都可以在 `APPCOMMANDS` 中运行任何命令，就像 `APPOWNER` 中的任何用户一样，在任何 `DB` 服务器上。我可以通过向各种别名中添加条目来更改他们的访问权限。

没有别名，这条规则会是什么样子？

```
dwsmith,kkrusch    db1,db2,db3 = (_postgresql,www) \
     /home/appowner/bin/*,/usr/local/bin/pg_*
```

这看起来很丑，但它确实做了完全相同的事情。

如果你给别名起名得当，你会发现规则更容易理解。虽然这些示例别名相当简短，但我已经使用了有最多 20 个成员的别名。没有别名的情况下，这些规则看起来令人震惊。

### 注意

在这种情况下，`sudo` 授予的一些权限是不必要的。例如，无特权的网络服务器用户不需要运行各种 PostgreSQL 工具，如果 `www` 尝试运行数据库，也不会发生什么。如果你不喜欢这样，可以制定两条不同的规则。无论如何，这比给数据库管理员提供 root 密码更安全。

#### 别名嵌套

你可以在别名中包含别名。在这里，我将两个用户别名合并为一个用于我的应用程序管理员的单一别名：

```
User_Alias    APPADMINS = DBAs, WEBMASTERS
```

#### 别名命名约定

传统的做法（但不是强制性的）是将别名命名为全大写字母，以帮助区分用户、主机等。尽管这是有效的语法，但最好避免将别名命名为用户或主机。以下是一个示例：

```
User_Alias    MWLUCAS    = mwlucas,pkdick,sbaxter,dwsmith
```

这会让我很快变得疯狂.^([16])

你也可以重复使用别名名称，如果它们是为不同类型的别名。例如，以下是完全合法的，但完全令人反感。

```
User_Alias    DB = dwsmith,kkrusch
Runas_Alias    DB = _postgresql,www
Host_Alias    DB = db1, db2, db3
Cmnd_Alias    DB = /usr/local/bin/pg_*, /home/appowner/bin/*
DB    DB = (DB) DB
```

如果这样做，任何必须调试您的`sudo`配置的人都会诅咒您的名字。即使您认为被诅咒是一种工作福利，这种命名方案也会在不方便的时候让您手机响个不停。

### 改变 sudo 的默认行为

您可以使用`默认`字段自定义`sudo`的行为，或某些用户、主机或别名的行为。例如，`sudo`的一个特性是如果您输入了错误的密码，它会侮辱您。

```
$ **sudo -l**
Password:
My pet rat can type better than you!
Password:
```

我输入了错误的密码。`sudo`侮辱了我，并给了我再次输入密码的机会。如果我连续三次输入错误的密码，`sudo`将退出。

在开源环境中侮辱用户是可以的，但如果您在公司，有人会向管理层投诉。您可以选择参加敏感性培训或通过在*sudoers*中添加以下行来主动禁用侮辱：

```
Defaults !insults
```

`默认`语句表示以下项目会影响一个或多个`sudo`默认值。`insults`选项控制侮辱用户。感叹号（`!`）是一个否定符号。通过在选项前放置感叹号，您将关闭该功能。当用户证明他们打字不如我的宠物老鼠时，系统将不再侮辱用户。

```
$ **sudo -l**
Password:
Sorry, try again.
Password:
```

您可以全局或按别名覆盖默认值。

#### 按主机覆盖默认值

要按主机覆盖默认值，请在`默认`后使用`@`符号，并给出主机或主机别名。在这里，我想侮辱那些在`caddis`或`APPSERVERS`别名中的机器上无法输入密码的用户，同时为所有其他服务器禁用侮辱：

```
Defaults !insults
Defaults@caddis insults
Defaults@APPSERVERS insults
```

这让我能够为任何服务器组合启用或禁用功能。

#### 按用户覆盖默认值

要按用户更改`sudo`的默认值，请使用`%`和用户或用户别名。

```
Defaults !insults
Defaults%lasnyder insults
Defaults%DBAs insults
```

无论`lasnyder`在哪里登录——我将侮辱他，以及`DBAs`别名中的用户。但是数据库管理员已经习惯了软件的恶劣待遇，如果不侮辱他们，可能会让他们感到困惑和失望。

#### 按命令覆盖默认值

您还可以通过在`默认`和命令列表之间放置感叹号来按命令逐个更改`sudo`的行为。

```
Defaults !insults
Defaults!/sbin/newfs,/sbin/fsck insults
Defaults%APPCOMMANDS insults
```

任何尝试使用`newfs(8)`或`fsck(8)`（在第八章第八章。磁盘和文件系统` 和 `sftp(1)` 将文件移动到其他服务器。阅读文档，创建一个批准的环境变量列表，并添加条目。

```
Defaults env_keep += "SSH_CLIENT SSH_CONNECTION SSH_TTY SSH_AUTH_SOCK"
```

### 注意

将文件复制到其他服务器的权限可能应该仅限于特定组的人员。系统管理员可能需要将文件复制到其他服务器，但许多其他用户不需要这种访问权限。

## 使用 sudo

现在你已经知道了如何设置 `sudo` 权限，让我们看看如何实际使用它。首先，让我们告诉 `sudo` 你的账户有权限运行任何命令。（你应该至少在测试机器上有 root 访问权限，所以这不会是一个安全问题。）

实现这一点的简单方法是取消注释 *sudoers* 中的条目，允许 `wheel` 成员访问所有命令。

```
%wheel ALL=(ALL) SETENV: ALL
```

作为 `wheel` 组的用户，检查你的 `sudo` 权限。

```
$ **sudo -l**
Password:
Matching Defaults entries for mwlucas on this host:
    env_keep+="DESTDIR DISTDIR EDITOR FETCH_CMD FLAVOR FTPMODE GROUP MAKE",
    env_keep+="MAKECONF MULTI_PACKAGES NOMAN OKAY_FILES OWNER PKG_CACHE",
    env_keep+="PKG_DBDIR PKG_DESTDIR PKG_PATH PKG_TMPDIR PORTSDIR",
    env_keep+="RELEASEDIR SHARED_ONLY SSH_AUTH_SOCK SUBPACKAGE VISUAL",
    env_keep+=WRKOBJDIR
User mwlucas may run the following commands on this host:
    (ALL) SETENV: ALL
```

当 `sudo` 要求输入密码时，输入你自己的密码，而不是 root 密码。

`-l` 标志告诉 `sudo` 显示你有哪些权限和设置。作为回应，`sudo` 解析 */etc/sudoers* 并输出适用于该系统上你账户的所有设置。任何特定主机的限制已经评估过，不会显示。

### sudo 密码缓存

当你正确输入密码时，`sudo` 记录时间，接下来五分钟内，它会记住你最近输入了密码，并且无需再次输入即可工作。五分钟后，你必须重新认证。这简化了输入一系列 `sudo` 命令的工作，但它的超时时间相对较短。

您可以通过运行 `sudo -k` 来让 `sudo` 忘记您的缓存密码。您可以使用 `sudoers` 中的 `timestamp_timeout` 选项来控制 `sudo` 再次请求密码之前的时间。在这里，我们告诉 `sudo` 不要在 10 分钟内超时密码：

```
Defaults timestamp_timeout 10
```

如果您将超时设置为 0，`sudo` 总是会要求输入密码。如果您将其设置为负值，`sudo` 将在整个登录会话中缓存密码。您必须运行 `sudo -k` 来让 `sudo` 忘记您输入了密码。

### 在 sudo 下运行命令

要通过 `sudo` 运行命令，只需在 `sudo` 命令后跟命令名称。例如，这是您如何通过 `sudo` 运行 `tcpdump` 的方法：

```
$ **sudo tcpdump**
```

`sudo` 命令应该提示您输入密码。正确输入后，`tcpdump` 应该以 root 身份运行。

您也可以在 `sudo` 下运行包含参数的命令。例如，我使用 `tail -f` 来查看日志文件的末尾，并显示新出现的条目。但某些日志文件只能由 root 访问，例如认证日志和包含详细 `sudo` 日志的日志。您可以使用 `sudo` 而不成为 root 来查看这些日志。

```
$ **sudo tail -f /var/log/authlog**
```

您可以配置 *sudoers* 以允许任何组合的命令和参数。

### 以其他用户身份运行命令

之前，您看到了如何授予一些用户以非 root 用户身份运行命令的权限。使用 `-u` 标志指定用户。

```
$ **sudo -u _postgresql pg_dump**
```

如果您没有权限以该用户身份运行该命令，您将收到错误。

## sudoedit

我的助手 `sbaxter` 需要编辑 *命名* 配置文件，`/etc/named.conf`。考虑以下 `sudo` 配置：

```
sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs,/usr/bin/vi /etc/named.conf
```

看起来不错，对吧？

哎，不行。

第一个问题是我要求 `sbaxter` 使用特定的编辑器。系统管理员需要具备 vi 的最低能力，但我不想强迫他使用特定的编辑器来完成日常工作。此外，许多编辑器提供 shell 转义功能。虽然大多数人知道在 vi 中转义到 shell，但 emacs 也有 shell 转义功能。如果我的助手在以 root 身份运行编辑器时能够转义到 shell，他将获得 root 权限。这正是我想避免的。

`sudoedit` 功能允许用户使用他们首选的编辑器或由系统管理员选择的默认编辑器编辑特定文件，而无需以 root 身份工作。

```
sbaxter    dns1=/etc/rc.d/named,/sbin/mount_nfs, \
        **sudoedit** /etc/named.conf, /etc/rndc.key
```

关键字 `sudoedit` 后跟一个文件列表，用户可以编辑这些文件，从而允许用户更改这些文件而无需 root 权限。

用户通过传递文件名给 `sudoedit` 来编辑文件。

```
$ **sudoedit /etc/named.conf**
```

技术上，用户并没有编辑实际的文件；相反，`sudoedit` 将文件复制到由用户拥有的临时文件中，当用户关闭编辑器时，它将临时文件复制到原始位置。用户永远不会以 root 身份运行编辑器。

`sudoedit` 关键字使用环境变量 `$SUDO_EDITOR`、`$VISUAL` 或 `$EDITOR` 中给出的编辑器。如果用户不喜欢系统提供的选项，他们可以在他们的 shell 中设置该变量。

## 最大的 `sudo` 错误：排除

现在你已经了解了 `sudo` 的基础知识，让我们考虑一个即使是经验丰富的系统管理员也会陷入困境的配置。有时你想要阻止用户执行特定的命令，但又要让他们能够访问其他所有命令。`sudoers` 文档说明你可以使用感叹号（`!`）作为否定字符来实现这一点，但这并不完全有效。然而，由于这是一个流行的方法，所以我将讨论它是如何工作的，然后演示如果你使用它，你的用户将如何自动获得 root 权限。

首先，定义包含禁止命令的命令别名。一个流行的排除项是 `su`。另一个常见的排除项是用户 shell，因为如果你以用户身份执行 shell，你将变成那个用户。

```
Cmnd_Alias    SHELLS = /bin/sh,/bin/csh,/usr/local/bin/tcsh
Cmnd_Alias    SU = /usr/bin/su
```

现在配置一个排除那些命令的命令别名。

```
pkdick	ALL = ALL, !SHELLS,!SU
```

看起来很有道理，不是吗？而且它似乎能正常工作。

```
$ **sudo sh**
Password:
Sorry, user pkdick is not allowed to execute '/usr/bin/su' as root.
```

但是这里有个问题：命令是通过完整路径定义的。你允许用户运行除了少数通过完整路径指定的命令之外的所有命令。这个用户需要做的只是将命令复制到另一个位置并运行它。

```
$ **cp /bin/sh /tmp/sh**
$ **sudo /tmp/sh**
#
```

欢迎来到 root！

否定命令可以被任何理解 `sudo` 基础知识的人绕过，正如你在 `sudo` 手册和其他文献中会发现的那样。人们 *仍然* 坚持使用它来保护生产系统。不要成为那些人之一。

## sudo 日志

每个使用 `sudo` 的命令都会被 `syslogd` 记录到 */var/log/secure*。每条日志消息都包含一个时间戳、一个用户名、一个终端、运行命令的目录、运行命令的用户以及所使用的命令。

```
Apr 30 14:16:50 treble sudo:  mwlucas : TTY=ttyp8 ; PWD=/home/mwlucas ; USER=root ; COMMAND=/usr/bin/su -m
```

通过检查文件 *secure*，你可以精确追踪谁做了什么以及何时做的。（将你的 *syslog* 消息发送到一个你的用户无法访问的日志服务器，以防止那些搞砸的人删除他们错误的日志。）

```
May 15 09:14:55 treble sudo:  lasnyder : TTY=ttyp4 ; PWD=/etc ; USER=root ; COMMAND=/bin/rm pf.conf
```

我确切地知道谁破坏了这个系统以及何时破坏的。日志条目将即将发生的事情从“谋杀”转变为“正当的杀人”。仅此一点就使得正确使用 `sudo` 值得。

本章为你提供了一些避免意外破坏系统的技巧。现在让我们看看如何通过操作磁盘和文件系统真正地破坏你的系统。

* * *

^([15]) 我可以简单地说“我从未见过配置正确的 POSIX ACLs”，但个人的轶事证据并不构成证明。即使我在这个行业中几十年收集到的数十个令人毛骨悚然的个人轶事也不构成证明。请随意证明我错了，但请，请在 *你的* 服务器上这么做。

^([16]) 哦，好吧——battier。高兴了吗？
