## 第八章。磁盘和文件系统

*哦，我的头好痛。*

*一串的 0 和 1，真痛苦！*

*文件系统隐藏了它们。*

![图片](img/httpatomoreillycomsourcenostarchimages1616079.png) 正确的数据管理可能是系统管理员最重要的职责。你可以更换几乎所有的计算机组件，但磁盘上的数据是无法替代的。也许这些数据并不重要或者已经备份，但丢失文件会毁了你的一天。作为系统管理员，你必须通过仔细管理你的磁盘和文件系统来保护重要数据。

我们在第二章中介绍了磁盘标签和 MBR 分区的基础知识，但 OpenBSD 允许你以任何数量的方式使用和滥用磁盘和文件系统。你将在本章中学习如何做到这一点。

## 设备节点

*设备节点*是一个文件，它为硬件提供了一个逻辑接口。通过从设备节点读取、向其发送数据或在其上使用命令，你是在告诉操作系统对硬件或在某些情况下对逻辑设备执行操作。

当数据发送到不同的设备时，它们的行为也会有所不同。例如，向控制台写入会在屏幕或终端上显示文本，而向磁盘设备写入会将数据放在该磁盘上。（OpenBSD 将设备节点放在*/dev*中，并禁止在其他文件系统上使用设备节点。）

许多磁盘管理程序期望被给定一个设备名称作为参数。不幸的是，设备节点名称通常是晦涩的，并且在不同的操作系统之间差异很大——即使在同一硬件上运行的密切相关操作系统之间也是如此。为了稍微简化你的生活，表 8-1 列出了常见 OpenBSD 磁盘设备的设备节点名称。

表 8-1. 表 8-1：常见的磁盘设备节点名称

| 设备节点 | 描述 |
| --- | --- |
| */dev/fd** | 软盘（块设备） |
| */dev/rfd** | 软盘（原始设备） |
| */dev/wd** | IDE 和一些 SATA 磁盘（块设备） |
| */dev/rwd** | IDE 和一些 SATA 磁盘（原始设备） |
| */dev/sd** | SCSI/SAS/SATA/USB/RAID 的非 IDE 磁盘（块设备） |
| */dev/rsd** | SCSI/SAS/SATA/USB/RAID 的非 IDE 磁盘（原始设备） |
| */dev/cd** | CD/DVD 驱动器（块设备） |

设备名称还有一个数字，告诉你它指的是该设备的哪个实例。编号从 0 开始。第一个 IDE 硬盘是*/dev/wd0*，*/dev/wd1*是第二个，而*/dev/cd1*是第二个 CD 驱动器。

每个分区都被分配了一个字母。例如，根分区是*a*，交换区是*b*，整个磁盘是*c*，依此类推。每个分区还有一个独立的设备节点，这是通过将分区字母附加到磁盘设备名称上得到的。例如，如果你在一个 IDE 驱动器上安装，你的根分区是*/dev/wd0a*。

### 原始和块设备

注意在表 8-1 中，设备以块或原始（字符）模式列出。这指的是设备是如何被访问的。

#### 块设备

硬盘通常使用块设备节点（有时称为*熟*设备节点）进行访问。当以块的形式访问设备时，传输到或从设备的数据会被*缓冲*，或者收集到足够的数据，使得访问设备变得值得麻烦。块设备通常被认为比原始设备更高效。

块设备的设备节点以设备驱动程序命名；例如，*/dev/wd3*。

#### 原始设备

原始设备有时被称为*字符*设备，因为它们一次访问一个字符。如果你需要精确控制数据在磁盘上的显示方式（例如，在创建文件系统时）使用原始设备。原始设备节点名称前有一个*r*，例如*/dev/rwd3*。

原始设备不进行缓冲。当你告诉系统向原始设备写入数据时，数据会立即传输。原始模式最适合提供自身缓冲或希望以特定方式排列数据的软件。

记住块和原始吞吐量之间的区别有一个简单的方法：假设你洒了一瓶阿司匹林。如果你一个个地捡起阿司匹林并将其直接放入瓶中，你正在进行无缓冲的或原始的传输。如果你用右手拿起阿司匹林，用左手收集它们，然后一次性将一堆阿司匹林（连同地板上的所有灰尘）倒入瓶中，你正在进行缓冲传输.^([17])

#### 选择您的模式

通过选择相应的设备节点，将磁盘（以及许多其他设备）作为原始或块访问。一些程序期望访问原始设备，而另一些程序期望访问块设备。如果一个程序打开*/dev/sd1a*，它是以块设备的形式访问磁盘*sd1*上的分区*a*。如果它打开*/dev/rsd1a*，它是以字符设备的形式访问相同的分区。

无论模式如何，底层硬件保持不变；唯一改变的是你与设备交换信息的方式。

### 设备附加与设备名称对比

不久以前，大多数磁盘都永久固定在系统的一个物理位置上。如果你的计算机有两个 IDE 总线，每个总线有两个硬盘驱动器，操作系统会确切知道它们的位置，通常在*/wd1*和*/wd2*。SCSI 磁盘有一个 SCSI ID 和一个逻辑单元号（LUN），更改它们需要重新启动计算机。传统上，你可以使用磁盘在系统中的位置来识别磁盘。例如，启动的 i386 计算机会通过查找连接到第一个 IDE 控制器第一个端口的硬盘来查找根分区，找到该磁盘上的*a*分区，并从该磁盘读取文件系统表。你可以进入 BIOS 告诉计算机在另一个磁盘上查找根分区，但计算机仍然通过它物理连接到计算机的位置来识别磁盘。

现在，磁盘可以在系统的多个位置出现和消失。例如，你可能需要根据需要连接和断开几个闪存驱动器，或者从总线到总线热插拔串行连接 SCSI (SAS) 或串行 ATA (SATA) 驱动器。物理位置不再是识别磁盘的安全方式。虽然 */dev/sd0* 是第一个 SCSI 磁盘的设备节点，但你不能假设当前连接到第一个 SCSI 端口的磁盘就是上次系统启动时插入的那个磁盘。OpenBSD 使用唯一 ID 对实际磁盘进行标记，如下一节所述。

## DUIDs 和/etc/fstab

所有 OpenBSD 平台都使用 disklabel 来识别分区和其他有关磁盘的信息。当你标记一个磁盘（如我们在第三章中所述，并在本章稍后手动进行），`disklabel`会将一个*disklabel 唯一标识符*，或 DUID，添加到磁盘标签中。DUID 是一个唯一的十六进制数字，允许 OpenBSD 识别特定的磁盘。

要查找磁盘的 DUID，将设备名传递给`disklabel`并查找`duid`条目：

```
# **disklabel sd0**
…
duid: 55128c3700af5491
…
```

当前连接为`sd0`的磁盘的 DUID 为`55128c3700af5491`。即使你物理移动磁盘，使其变为`sd9`或`sd18`，OpenBSD 也可以使用 DUID 来唯一识别此磁盘。

OpenBSD 使用文件系统表 */etc/fstab* 来将磁盘上的文件系统映射到挂载点，使用磁盘位置或 DUID。每个文件系统都在 */etc/fstab* 的单独一行上显示，如下所示：

```
**1** 55128c3700af5491.b **2**none **3**swap **4**sw
55128c3700af5491.a / ffs rw 1 1
55128c3700af5491.k /home ffs rw,nodev,nosuid 1 2
55128c3700af5491.d /tmp ffs rw,nodev,nosuid 1 2
…
```

我们将关注第一条目来探索这里发生的事情。第一个字段，`55128c3700af5491.b` **1**，是分区的位置。而较老的系统使用磁盘设备名和分区字母（例如*/dev/sd0a*），较新的系统可以使用 DUID、一个点号和分区字母（如`55128c3700af5491.a`）。通过在文件系统表中使用 DUID，OpenBSD 可以始终在相同的位置挂载相同的磁盘，无论其如何连接。

第二字段，`none` **2**，列出 *挂载点*，即文件系统附加到目录树中的目录。你可以写入文件的每个分区都附加到一个挂载点（例如 */usr*，*/var* 等），其中一个分区是根分区 (*/*)。交换空间使用 `none` 作为挂载点。

接下来，`swap` **3**，是文件系统类型。标准的 OpenBSD 分区使用类型 `ffs`，UNIX 快速文件系统。其他选项包括但不限于 `msdos`（Microsoft 风格的 FAT 分区）、`mfs`（内存文件系统）和 `cd9660`（CD）。

第四字段，`sw` **4**，显示了用于此文件系统的挂载选项。我将在 FFS 挂载选项中更详细地介绍挂载选项，但这里有一些在 */etc/fstab* 中经常出现的选项：

+   ****`ro`****. 文件系统以只读方式挂载。即使是 root 也不能写入它。

+   ****`rw`****. 文件系统以读写方式挂载。

+   ****`nodev`****. 设备节点不会被解释。

+   ****`nosuid`****. 禁止 `setuid` 文件。

+   ****`noauto`****. OpenBSD 不会在启动时或运行 `mount -a` 时自动挂载文件系统。此选项对于可能没有媒体的可移动媒体驱动器很有用，例如 CD 和 USB 闪存驱动器。

第五字段表示 `dump(8)` 是否应该备份此文件系统。如果此字段为 0（或不存在），则 `dump` 不会定期备份文件系统。否则，给出的数字是需要备份文件系统的最小备份级别。

最后一个字段是 *通过次数*。它告诉 `fsck` 在启动时何时检查文件系统。通过次数为 1 的文件系统首先检查，通过次数为 2 的文件系统其次检查，依此类推。通过次数为 0 告诉 `fsck` 在启动时不检查文件系统。如果一个文件系统没有通过次数，则相当于 0。

我强烈建议在 */etc/fstab* 和其他任何地方使用 DUIDs，而不是使用设备节点名称。虽然设备节点名称可能会改变，但 DUID 不会。

## MBR 分区和 fdisk(8)

一些硬件平台对磁盘分区有特定的想法，这与 OpenBSD 的期望不同。例如，i386 和 amd64 平台期望在硬盘上找到 MBR 分区，OpenBSD 通过在其自己的磁盘标签分区中放置自己的磁盘分区来适应这种怪癖。我们简要介绍了安装过程中的分区创建，但如果你在现有系统中添加硬盘，你需要手动使用 `fdisk(8)` 编辑 MBR 分区表。

我的特定测试系统有两个硬盘：*wd0* 和 *wd1*。我认为 *wd1* 完全为空，但在我能使用这个硬盘之前，我需要验证它是否为空，然后创建 MBR 分区。虽然 `fdisk` 有各种编辑磁盘的命令，但我发现最简单的方法是使用交互式磁盘编辑器。运行 `fdisk -e` 并给出新硬盘的设备节点。

```
# **fdisk -e wd1**
Enter 'help' for information
fdisk: 1>
```

编辑器很简单，但让你可以查看、添加、删除和编辑 MBR 分区。如果你在任何时候忘记了命令，输入`help`将打印出`fdisk`支持的 所有命令。

### 查看 MBR 分区

要查看当前磁盘上的 MBR 分区，输入**`print`**或**`p`**。以下是一个示例：

```
fdisk: 1> **print**
Disk: wd1       geometry: 2088/255/63 [33554304 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
 0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
```

第一行显示了磁盘几何形状（如第二章安装准备中所述）。这个磁盘的 MBR 表中的每个值都设置为 0，意味着它没有配置任何分区。

### 添加和删除分区

假设我们想在磁盘上创建一个 MBR 分区。我习惯使用分区 0，但 OpenBSD 安装程序通常使用分区 3。你选择的特定数字并不重要，除非你想要在磁盘上有多个 MBR 分区。

要编辑一个分区，输入**`edit`**或**`e`**后跟分区号。例如，要编辑分区 0，输入以下内容：

```
  fdisk: 1> **e 0**
            Starting         Ending         LBA Info:
   #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
   0: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
**1** Partition id ('0' to disable)  [0 - FF]: [0] (? for help) **a6**
   Do you wish to edit in CHS mode? [n]
**2** offset: [0]
**3** size: [0] *****
```

### 警告

便利的是，`fdisk`打印了当前这个 MBR 分区的信息。在弄乱它之前，确保它是你认为的那个分区。

首先，在**1**处设置分区 ID。这是一个标签，表示磁盘上会有什么类型的文件系统。OpenBSD 使用分区 ID `a6`，所以输入那个。

**2**处的偏移量是从磁盘开始到分区开始的扇区数。我们希望使用整个磁盘来安装 OpenBSD，所以将其设置为`0`。

最后，**3**处的尺寸是 MBR 分区填充的扇区数。在这里不需要复制磁盘中的扇区数；OpenBSD `fdisk`使用`*`表示“所有空闲空间”。

现在再次打印 MBR 表以检查你的工作。

```
fdisk:*1> **p**
Disk: wd1       geometry: 2088/255/63 [33554304 Sectors]
Offset: 0       Signature: 0x0
            Starting         Ending         LBA Info:
 #: id      C   H   S -      C   H   S [       start:        size ]
------------------------------------------------------------------------------
 0: A6      0   0   1 -   2088 167  63 [           0:    33554304 ] OpenBSD
 1: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 2: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
 3: 00      0   0   0 -      0   0   0 [           0:           0 ] unused
```

注意，分区 0 的条目类型为 A6，从磁道 0，头 0，扇区 1 开始，到磁道 2088，头 167，扇区 63 结束。它填充了 33,554,304 个扇区——与磁盘中的扇区数相同。这个 MBR 分区填充了整个磁盘。

如果你从另一个操作系统回收了这个磁盘，它可能已经有一个分区了。要删除一个分区，编辑分区并将其分区 ID 设置为 0。

### 使分区可引导

为了从硬盘启动，你需要将一个分区标记为活动分区。使用`flag`命令和一个分区号来完成此操作。

```
fdisk: 1> **flag 0**
Partition 0 marked active.
```

将这块硬盘包含到你的 BIOS 启动顺序中，计算机应该会尝试从它启动。仅仅将一个分区标记为活动分区并不意味着计算机*可以*从它启动；然而，你仍然需要一个内核、引导加载程序以及所有启动计算机所需的其他东西。

要将一个分区标记为不再活动，删除并重新创建它。（没有`unflag`命令。）

### 退出 fdisk

一旦你对你的工作满意，输入**`quit`**或**`q`**，`fdisk`应该将新的 MBR 表写入磁盘并退出。如果你改变了主意，不想做任何更改，输入**`abort`**或**`exit`**，`fdisk`应该退出而不保存对 MBR 分区表的更改。

## 标记磁盘

OpenBSD 使用 `disklabel` 在所有硬件平台上设置分区。我们在安装过程中使用了 `disklabel(8)`，但在你可以使用它们之前，你需要为新磁盘分区。（你也可以使用 `disklabel` 来备份、恢复和复制分区表。）

### 查看标签

要查看当前的磁盘标签，只需将磁盘名称作为参数传递。以下是如何查看上一节中空磁盘的磁盘标签：

```
  # **disklabel wd1**
**1** # /dev/rwd1c:
  …
**2** duid: 0000000000000000
  …
  16 partitions:
  #                size           offset  fstype [fsize bsize  cpg]
**3**  c:         33554304                0  unused
```

这看起来与我们在 第二章 中看到的磁盘标签非常相似，但有几个关键的区别。

首先，注意 **1** 处的设备。`disklabel` 命令访问原始设备，但你应该在命令行中使用块设备。

**2** 上的这个标签没有 DUID。这是一个默认的空磁盘标签。我们稍后会生成一个 DUID。

在 **3** 处，我们看到这个磁盘只有一个分区，*c*，它代表整个磁盘。你可以在分区 *c* 上创建和使用文件系统，但这不是标准做法。

### 创建磁盘标签分区

创建分区最简单的方法是使用我们用来安装 OpenBSD 的相同交互式磁盘标签编辑器。给磁盘标签编辑器传递 `-E` 标志和磁盘名称：

```
# **disklabel -E wd1**
Label editor (enter '?' for help at any prompt)
>
```

现在，你可以添加、删除和编辑分区，就像在 第三章 中一样。

在本书的其余部分，我们将根据需要编辑磁盘标签以更改分区和文件系统的特性。

### 备份和恢复磁盘标签

在对磁盘进行操作之前，备份其磁盘标签，以便在出错时可以回滚到旧标签。你可以使用以下命令备份磁盘标签：

```
# **disklabel wd1 > wd1.disklabel.saved**
```

要将保存的磁盘标签应用到磁盘上，给 `disklabel` 传递 `-R` 标志、磁盘设备和标签文件：

```
# **disklabel -R wd1 wd1.disklabel.saved**
```

这会将保存的标签写入磁盘。你可以使用保存的磁盘标签在相同磁盘之间复制分区。

现在你已经有了分区，让我们在这些分区上创建一个文件系统。

## 快速文件系统

OpenBSD 的文件系统，FFS，是 BSD 4.4 随附文件系统的改进版本。FFS 有时被称为 UFS（Unix 文件系统），许多系统实用程序仍然使用 UFS.^([18])

FFS 设计得既快又可靠，能够有效地处理最常见的场景，同时仍然支持奇怪的配置。默认情况下，OpenBSD 为通用用途调整了 FFS，但你可以根据需要优化它——无论是需要存储数十亿个微小的文件，还是存储六个 30GB 的文件。你不需要了解太多关于 FFS 内部结构的知识，但至少你应该理解块、碎片和 inode。

### FFS 版本

原始的 FFS 是在 1980 年代编写的，并包含了当时足够的硬编码限制。文件系统可以有高达 2³¹-1 个块，或者说接近一个太字节（TB）。在 1983 年，一个 1TB 的文件系统是无法想象的。在 2013 年，1TB 的硬盘很便宜。

对于较大的文件系统，我们有 FFS 版本 2。FFS2 可以支持高达 8 泽字节（按照 2013 年的标准是无法想象的）的文件系统。（请注意，FFS2 可能在达到文件系统大小限制之前就达到其他限制。）OpenBSD 支持 FFS 和 FFS2。

i386 和 amd64 引导软盘只支持 FFS，不支持 FFS2。然而，安装 CD 支持两者。大多数需要从软盘启动的机器不需要 FFS2，而且可能没有可以支持 2TB 驱动器的 BIOS。文件系统创建程序`newfs(1)`足够智能，可以在需要的情况下使用 FFS2，所以对于大多数安装，你不需要担心 FFS 和 FFS2 之间的区别。

### 注意

在极其不可能的情况下，如果你需要在必须通过软盘安装的机器上使用 FFS2，请确保将根（`/`）、`/var`和`/usr`等关键系统分区格式化为 FFS，而不是 FFS2。仅对非关键系统分区使用 FFS2。否则，你将无法使用安装盘进行升级或紧急修复。

### 区块、片段和 inode

FFS 和 FFS2 都通过区块、片段和 inode 进行管理。这种安排并不仅限于 FFS 和 FFS2；例如，NTFS 这样的文件系统也使用数据块和索引节点。然而，每个文件系统使用的索引系统在很大程度上是独特的。

#### 区块

*区块*是包含数据的磁盘部分。文件放置在一个或多个区块中。OpenBSD 的 FFS 使用默认的 16KB 区块大小，或八倍于片段大小，取较小者。并非所有文件都是 16KB 的倍数，所以剩余的位会放在*片段*中。一个片段是区块大小的八分之一，默认为 2KB。一个 20KB 的文件会填满一个区块和两个片段。

#### Inode

*inode*，或索引节点，包含关于文件的基本数据，例如文件的大小、权限以及包含文件的块列表。inode 中的数据统称为*元数据*，或关于数据的数据。

#### 超级块

你还会看到关于*超级块*的引用，这些块包含关于文件系统大小和规格的重要信息。超级块非常重要，因此 FFS 会为它们创建许多备份副本。如果你需要与超级块打交道，你可能做错了什么，或者你的文件系统出了问题。

### 创建 FFS 文件系统

使用`newfs(8)`创建 FFS 和 FFS2 文件系统，并确保磁盘有一个磁盘标签。`newfs`命令接受一个参数：分区设备节点。

```
# **newfs wd1a**
/dev/rwd1a: 16383.9MB in 33554304 sectors of 512 bytes
81 cylinder groups of 202.47MB, 12958 blocks, 25984 inodes each
super-block backups (for fsck -b #) at:
 32, 414688, 829344, 1244000, 1658656, 2073312, 2487968, 2902624, 3317280, 3731936,
 …
```

你将看到关于文件系统大小、包含多少区块等详细信息。随着`newfs`的进行，每个超级块备份的位置会被打印出来。（当计算机和磁盘速度较慢时，这会告诉操作员计算机实际上正在做事情，并没有卡住。）

分区大小决定了`newfs`使用的文件系统。小于 1TB 的分区使用 FFS 格式化；大于 1TB 的分区使用 FFS2。如果你想指定特定的文件系统格式（是的，如果你喜欢，甚至可以指定老式的 4.3BSD 格式），请使用`-O`标志。在大型分区上要求使用 FFS 文件系统是没有意义的，但你可能有小分区使用 FFS2 的原因。

```
# **newfs -O 2 wd1a**
```

如果你认为你需要指定在新的文件系统上使用哪种文件系统格式，你可能错了。

### FFS 挂载选项

OpenBSD 可以以几种特殊方式处理 FFS 分区，控制文件系统支持哪些类型的更改以及可能存在哪些类型的文件。这些被称为**挂载选项**。你可以在命令行上挂载分区时指定挂载选项，正如我们将在挂载和卸载分区中讨论的那样，或者在`/etc/fstab`中指定。

#### 挂载选项和`/etc/fstab`

在文件系统的`/etc/fstab`条目的第四字段中，以逗号分隔的列表形式指定文件系统的挂载选项。例如，以下是我`/etc/fstab`条目中包含我的`/home`目录的分区：

```
244f6d3acd6374ad.k /home ffs rw,nodev,nosuid,softdep 1 2
```

我已经指定了`rw`（读-写）、`nodev`（禁止设备节点）、`nosuid`（禁止`setuid`程序）和`softdep`（软更新）选项。我将介绍这些以及其他常见的挂载选项，并解释为什么你可能想要使用它们。

#### 只读挂载

如果你只想读取分区的内容，而永远不会写入它，你可以将分区挂载为**只读**。在大多数情况下，这是挂载磁盘最安全的方式，因为你不能更改磁盘上的数据或写入任何新数据。如果一个文件系统永远不会改变，将其挂载为只读可能是有意义的。

当特定的文件系统损坏时，只读挂载特别有价值。虽然 OpenBSD 不允许你在损坏或脏文件系统上执行标准的读-写挂载，但它通常可以以只读方式挂载这些文件系统。这给你提供了一个从分区中恢复一些数据的机会。（机会不大，但总是一个机会。）

要将文件系统挂载为只读，请使用选项`rdonly`或`ro`。

#### 读-写挂载

如果你既想从磁盘读取又想写入磁盘，你需要将分区挂载为**读-写**模式。默认情况下，OpenBSD 会将所有分区挂载为读-写模式。

使用选项`rw`来明确配置读-写挂载。

在现代硬件上，我建议结合使用软更新和读-写挂载。

#### 同步挂载

使用同步挂载是挂载文件系统的最安全方式。OpenBSD 可以从同步挂载的分区以硬件允许的速度读取数据。然而，每次你向磁盘写入数据时，内核都会向磁盘发送一块数据，等待接收磁盘已接受数据并将其写入磁盘的确认，然后告诉请求写入的程序数据现在已在磁盘上。

您应该知道，即使您使用的是同步挂载，大多数硬盘都会谎称它们实际上是否已将数据写入磁盘。这些硬盘执行 *写入缓存*，在驱动器实际写入数据之前，将写入缓存到磁盘本身的小型闪存或 RAM 缓冲区中。这提出了一个问题：同步挂载真的是同步的吗？硬盘供应商通常声称，在断电的情况下，这些磁盘保留足够的电力将缓存写入磁盘。

虽然它们在崩溃情况下提供最大的数据完整性，但同步挂载较慢。当数据完整性至关重要时，您可能会使用同步挂载，但在大多数情况下，这是过度杀鸡用牛刀，并且您几乎没有能力验证挂载是否真正同步。

使用 `sync` 关键字激活同步挂载。

#### 异步挂载

为了快速写入数据，但风险更高的数据丢失，异步挂载分区。当使用异步挂载时，内核在磁盘确认数据已写入之前，会通知软件所有磁盘写入均成功。这很快，但系统故障可能会在您的磁盘上留下不一致的数据。

在从备份恢复文件系统时，异步挂载很有用，因为如果在恢复过程中中途断电，您无论如何都需要重新开始。如果您关心数据或反对重新创建文件系统，请不要在生产环境中使用异步挂载。

使用 `async` 关键字激活异步挂载。

#### 软更新挂载

软更新挂载组织并安排磁盘写入，以确保文件系统元数据始终保持一致性。这提供了与异步挂载相似的性能，同时具有同步挂载的可靠性。虽然这并不意味着所有数据都会写入磁盘——在错误的时间断电会导致数据丢失——但使用软更新可以防止由丢失数据引起的大量文件系统完整性问题。这不是默认设置，因为一些较旧、较小的硬件没有足够的内存来支持它，但如果您使用现代 i386 和 amd64 硬件，我建议为所有 FFS 分区启用软更新。

要以软更新方式挂载文件系统，请使用 `softdep` 选项。

#### “不跟踪访问时间”挂载

FFS 记录文件最后被读取、执行或以其他方式查看的时间。更新这些访问时间会消耗一小部分但可测量的磁盘 I/O 和性能。您可以使用 `noatime` 挂载选项来告诉 OpenBSD 不要更新任何文件的访问时间。

在笔记本电脑上使用 `noatime` 有意义，因为最小化功耗至关重要。如果您想在自己的服务器上使用此选项以获得一点额外的性能，您应该购买更快的磁盘。一些软件，如 Mutt 邮件客户端，如果在挂载 `noatime` 的文件系统上运行，将会损坏。

#### 无设备节点允许挂载

通过使用 `nodev` 挂载选项，你可以告诉 OpenBSD 不要解释任何给定文件系统上的任何设备节点。入侵者可能会尝试创建“恶意”的设备节点并使用它们来写入文件或攻击网络，但如果内核不会识别这些设备节点，那么它就会切断这一类攻击。

如果你的计算机上有来自多个操作系统的硬盘，这种挂载类型也非常有用。例如，如果你的计算机上双启动了 OpenBSD 和 Linux，但你不想在使用 OpenBSD 时意外访问 Linux 设备节点，`nodev` 选项将阻止你这样做。（你可能认为你会注意到你输入了 */linux/dev/hda* 而不是 */dev/wd1*，但永远不要低估你出错的能力。）在大多数情况下，包含 */dev* 的分区应该是唯一包含设备节点的分区。

#### 执行禁止挂载

`noexec` 挂载选项阻止分区上的任何二进制文件被执行。使用 `noexec` 选项挂载 */home* 可以帮助防止用户安装和运行他们自己的程序，但要使其有效，你需要确保用户不能在任何共享区域（如 */tmp* 和 */var/tmp*）中安装二进制文件。

注意，禁止执行二进制文件不会阻止用户从该分区运行解释脚本。也许用户不能运行编译的 C 程序，但如果他们可以运行 `perl $HOME/rootkit.pl`，那么 `noexec` 不会对他们造成太大的影响。

#### setuid 禁止

`nosuid` 选项禁止在此文件系统上的程序执行 `setuid` 行为。许多分区不应该有 `setuid` 文件，设置这个选项是一个很好的方法来破坏它们。OpenBSD 默认在 */home* 和 */tmp* 等分区上设置此选项。你必须仔细地将此选项放置在所有用户可写文件系统上，以便它防止不希望的行为。

#### 不要自动挂载此文件系统

`noauto` 实际上不是一个挂载选项，而是一种告诉 OpenBSD 在引导时不挂载 */etc/fstab* 中列出的给定分区的办法。我经常为可移动媒体驱动器创建 */etc/fstab* 条目，但系统不应该在引导时尝试挂载这些分区。如果 */etc/fstab* 所需的分区不可用，引导将会挂起，我不想因为拔掉了闪存驱动器而导致我的计算机无法启动。

### 文件系统完整性

两种版本的 FFS 都非常努力地确保磁盘上的数据是正确且完整的。包含文件的块应该记录在 inode 中，inode 应该由目录条目引用，等等。当你删除一个文件时，应该删除对该文件的全部引用。

然而，系统故障后，数据可能不一致。元数据可能引用之前已擦除的块；文件可能位于 inode 记录指定的不同位置；文件系统可能包含各种指向已移动、更改或消失的项目的引用。这些不一致的，或*脏的*文件系统不可信，在您将其挂载为读写之前必须进行合理化，或*清理*。如果您以只读方式挂载脏文件系统，它可能会使您的系统恐慌，但如果您强制 OpenBSD 以读写方式挂载脏文件系统，您将使脏文件系统受到更多损害。

在启动时，OpenBSD 会对文件系统执行最小检查和清理，或*梳理*，并将自动纠正发现的任何小问题。如果梳理无法完全清理文件系统，则启动将挂起，直到您干预。

面对脏文件系统时，您有几个选择：使用文件系统检查工具 `fsck(8)`，使用 `fsdb(8)` 和 `clri(8)` 调试文件系统，或者丢弃文件系统并运行 `newfs(8)`。大多数时候，您会尝试使用 `fsck` 修复文件系统。成功使用 `fsdb` 需要更多关于 FFS 内部结构的知识，所以我只推荐给那些真正想要深入了解 FFS 并且有大量时间投入的人。使用 `newfs` 重建文件系统会破坏文件系统上的所有内容，但它对于只包含临时数据的分区来说是一个不错的选择，例如 */usr/obj*。

在尝试任何修复之前，您可以使用 `dump(8)` 来复制损坏的文件系统。这为您提供了在修复磁盘失败时回退到当前状态的选择。（如果您不得不这样做，那么您可能需要重新评估您的备份策略。）

#### 运行 fsck

如果您尝试在启动时或常规操作期间挂载脏文件系统，您将看到一条类似以下的消息：

```
/dev/rwd1a: UNEXPECTED INCONSISTENCY; RUN fsck_ffs MANUALLY
```

`fsck(8)` 程序是几个文件系统特定完整性检查程序的界面。当您运行它时，`fsck` 识别文件系统的类型，并为您调用正确的完整性检查器。通过提供您要检查的文件系统的设备名称来运行 `fsck`：

```
# **fsck /dev/wd1a**
```

您可以使用原始或烹饪设备名称；`fsck` 足够智能，即使您提供了烹饪设备名称，也会使用原始节点。

检查文件系统可能需要相当长的时间，所以请耐心等待。

当在脏文件系统上运行时，`fsck` 可能会发现许多问题：与 inode 失去关联的块、引用空块的 inode 等。它通常可以很好地猜测一切是如何组合在一起的。

当 `fsck` 发现它并不完全确定的问题时，它会建议一个修复方案并询问你是否想要进行更改。如果你回答 `y`，`fsck` 会进行更改。如果你回答 `n`，`fsck` 将保持文件系统不变。如果你告诉 `fsck` 不要执行它建议的更改，文件系统仍然会是脏的，你需要启动 `fsdb` 或 `clri` 并进行你认为更合适的更改。

有时，`fsck` 无法识别从损坏的文件系统中恢复的文件的名字或目录。这些文件会进入分区的 *lost+found* 目录（例如，*/usr/lost+found*）。你需要使用 `grep` 和 `strings` 等程序尝试通过其内容来识别这些文件。

#### 盲目信任 fsck

我们中那些缺乏调试文件系统技能的人发现自己处于一个困难的情况，我们只能接受 `fsck(8)` 知道最好的，或者只是从备份中恢复。如果你的文件系统在系统故障前进行了大量的磁盘 I/O，`fsck` 可能需要做出数十或数百次更改。你可能会花一个小时坐在控制台重复按 `y`。

如果你决定信任 `fsck` 并希望它是正确的，运行 `fsck -y`。这意味着“对每个问题回答 `y`”。你可能会在 *lost+found* 目录中找到文件系统的全部内容，或者你可能会丢失文件系统上的所有文件。但除非你非常熟悉 FFS 的内部结构，否则你仍然需要从备份中恢复。

如果你运行 `fsck` 并在途中意识到你希望回答 `y` 给所有后续的问题，请输入 `F`。这告诉 `fsck` 对所有剩余的问题回答 `y`。

在程序结束时，你已经恢复了系统或需要从备份中恢复。

## 当前已挂载的内容是什么？

在执行常规工作时，不可避免地你需要检查哪些磁盘当前已挂载，哪些未挂载。要查看所有挂载的文件系统和它们的挂载选项，请在没有任何选项的情况下运行 `mount(8)`：

```
$ **mount**
/dev/wd0a on / type ffs (local)
/dev/wd0k on /home type ffs (local, nodev, nosuid)
/dev/wd0d on /tmp type ffs (local, nodev, nosuid)
/dev/wd0f on /usr type ffs (local, nodev)
/dev/wd0g on /usr/X11R6 type ffs (local, nodev)
/dev/wd0h on /usr/local type ffs (local, nodev)
/dev/wd0j on /usr/obj type ffs (local, nodev, nosuid)
/dev/wd0i on /usr/src type ffs (local, nodev, nosuid)
/dev/wd0e on /var type ffs (local, nodev, nosuid)
```

FFS 和 FFS2 分区都显示为 `type ffs`。单词 `local` 表示分区位于连接到此机器的物理驱动器上。我们已经在本章前面介绍了各种挂载选项（如 `nodev`、`nosuid` 等）。

注意，`mount` 显示的是每个分区挂载的设备节点，而不是 DUID。如果你想查看磁盘的 DUID，请检查磁盘标签。

## 挂载和卸载分区

要将文件系统附加到你的目录树或 *mount* 它们，请使用 `mount(8)`。如果你以前从未手动挂载过文件系统，请将 OpenBSD 机器引导到单用户模式（参见 第五章) 并按照说明操作。

在单用户模式下，OpenBSD 只挂载一个分区：根分区，它将其挂载为只读。根分区包含足够的系统来执行基本设置、建立核心服务和找到其他文件系统。

因为除了根文件系统之外的其他文件系统没有被挂载，所以它们的内容是不可访问的。在单用户模式下查看系统中的 */usr*，你会发现它是空的。OpenBSD 并没有丢失这些文件；它只是还没有挂载包含这些文件的分区。

在单用户模式下完成任何实际工作，你可能需要挂载其他文件系统。

### 挂载标准文件系统

要手动挂载 */etc/fstab* 中列出的单个文件系统，给 `mount(8)` 提供你想要挂载的文件系统的名称。在这里，我们将挂载我们的 */usr* 分区：

```
# **mount /usr**
```

这将以 */etc/fstab* 中描述的精确方式挂载分区，其中包含所有指定的选项。

要挂载 */etc/fstab* 中列出的所有分区，给 `mount` 提供 `-a` 标志：

```
# **mount -a**
```

现在应该挂载所有你的文件系统（除了那些在 */etc/fstab* 中未列出的和那些带有 `noauto` 选项的文件系统）。

### 在非标准位置挂载

可能你必须在 */etc/fstab* 中未指定的位置挂载一个文件系统。我通常在向机器添加磁盘时这样做。要在 */etc/fstab* 中指定的位置之外挂载分区，或者要挂载没有 */etc/fstab* 条目的分区，给出分区设备名称和挂载点。

```
# **mount /dev/sd0d /mnt**
```

你必须使用设备节点的完整路径，而不仅仅是简短的设备节点名称。

你可以使用 DUID、一个点和分区字母代替设备节点的路径，但在命令行上，这比使用设备节点的路径更痛苦。

### 卸载分区

要从目录树中断开文件系统，在挂载点上使用 `umount(8)`。注意这个命令中只有一个 `n`。在这里，我们将使用 `umount` 来卸载我们的 */usr* 分区：

```
# **umount /usr**
```

你不能卸载被任何程序使用的文件系统。即使在挂载目录中的命令提示符也会阻止你卸载分区。

要卸载除了根分区之外的所有分区，给 `umount` 提供 `-a` 标志：

```
# **umount -a**
```

由于程序几乎肯定在每个分区上都有文件打开，这可能在单用户模式下才能工作。请注意，你不需要卸载所有分区就可以离开单用户模式。

### 使用选项挂载

假设你从一个退役的 OpenBSD 机器中取出一个磁盘，并且你需要从它那里检索一些文件。你想要以只读方式挂载磁盘，这样你就不改变磁盘上的任何文件。要手动挂载一个在 */etc/fstab* 中未指定选项的分区，使用 `-o` 标志。

例如，如果磁盘显示为 */dev/sd0* 并且你想挂载分区 *a*，运行以下命令：

```
# **mount -o ro /dev/sd0a /mnt**
```

为了防止旧软件在你的新系统上运行，使用我们之前提到的某些选项可能是个好主意，例如 `noexec`、`nodev` 和 `nosuid`。

## 分区有多少空间？

要了解你的分区中剩余多少可用空间，请使用`df(1)`。这个程序显示每个分区上的总文件系统块数，已使用的块数，以及空闲的块数。它还提供了使用百分比。

关于`df`的一个令人烦恼的事情是它默认以 512 字节块提供这些信息。当磁盘很小的时候，这没问题，但今天，这就像用码尺测量飞机航程的距离。有些人已经这样做了很长时间，以至于他们在潜意识里自动执行块转换。^([19]) 对于我们其他人来说，`-h`标志告诉`df`提供人类可读的输出，如兆字节或千兆字节，给我们这样的信息：

```
# **df -h**
Filesystem     Size    Used   Avail Capacity  Mounted on
/dev/sd0a     1005M   39.1M    916M     4%    /
/dev/sd0k     26.9G   27.0G   -104M    -1%    /home
/dev/sd0d      3.5G   12.0K    3.3G     0%    /tmp
…
```

你可能会想知道为什么这个例子中的*/home*分区有负的空闲空间。这是怎么可能的？默认情况下，FFS 为移动文件和减少碎片保留了每个分区的 5%。当你超过 100%的磁盘利用率时，你开始使用这部分保留空间。

当分区过满时，FFS 的性能会迅速下降。最好在磁盘上保留一些空闲空间，以便 FFS 可以自我碎片化。

你可以减少 FFS 保留的空间量，但这样做会影响性能。有关如何“自毁”的说明，请参阅`tunefs(8)`。

### 所有这些是什么东西？

当你看到分区已满时，一个明显的问题就是“是什么占满了我的磁盘？”我拥有的每一块硬盘都是逐渐满的，没有明显的原因。你可以使用`ls -l`来识别单个大文件，但递归检查文件系统中的每个目录既不实际又繁琐（更不用说令人烦恼了）。

要检查当前目录以下每个目录中使用的文件系统块数，请使用`du(1)`。

```
$ **du**
164     ./.ssh
2       ./old
6       ./.mozilla/firefox/bcpuv16e.default/chrome
80      ./.mozilla/firefox/bcpuv16e.default/Cache/0/B0
354     ./.mozilla/firefox/bcpuv16e.default/Cache/0/31
28      ./.mozilla/firefox/bcpuv16e.default/Cache/0/7A
…
```

当我在我的家目录中运行`du`时，我得到 700 个条目；其中 563 个与某些 Mozilla 工具有关。这样的列表会吓到新系统管理员，并让有经验的系统管理员工作过于辛苦。与其手动筛选这个列表，不如告诉`du`只显示当前目录中目录的总计，然后对输出进行排序，以便最大的目录首先出现。

```
$ **du -s * | sort -rnk 1**
25224805  Dark_Shadows_Complete_Series
141104    mibs
14948     tarballs
4668      work
1864      pix
…
```

我现在知道为什么我的*/home*分区满了。

你可以使用`-h`标志告诉`du`显示人类可读的值，但这样做会在千兆字节、兆字节和千字节之间混合显示值，使得`sort`变得不那么有用。

### 设置$BLOCKSIZE

许多磁盘工具包括但不限于`du(1)`和`df(1)`，都是以 512 字节块为单位显示信息的。如果你习惯于以块为单位工作，你可能不会介意看到它们。然而，如果你不习惯以块为单位工作，它们可能会让你想拔掉自己的头发。

环境变量 `BLOCKSIZE` 告诉这些程序使用不同大小的块来显示信息。如果您将 `BLOCKSIZE` 设置为 `K`，`df` 和 `du` 将以千字节显示总数。如果您将其设置为 `M`，这些工具将显示兆字节。检查您的 shell 手册页或您家目录中的 dotfiles 以获取设置环境变量的示例。

## 添加新硬盘

OpenBSD 安装程序会引导您格式化和分区初始硬盘。如果您需要向现有系统添加磁盘，则必须自行运行这些命令。好消息是，如果您能安装 OpenBSD，您就已经知道如何使用这些命令了，唯一困难的部分是学习要运行哪些命令。

我将以将 */home* 移动到新磁盘为例向您展示。如果您现有磁盘上有一些空闲空间，您可以在磁盘上创建一个新的分区，但那样就会消除这个示例的需要，所以我将假装我从未给你那个建议。（此外，将分区移动到单独的磁盘控制器通道可以提高性能。）

### 警告

在触摸任何涉及磁盘分区或文件系统的内容之前，请备份您的系统。在开始之前验证备份。您已经被警告了。

### 创建 MBR 分区

i386 和 amd64 平台要求磁盘既有 MBR 分区也有 OpenBSD 分区。一个标准的新磁盘需要一个覆盖整个磁盘的单一 OpenBSD MBR 分区。将 `-i` 参数传递给 `fdisk` 正好做到这一点。让我们在 `wd1`，我们的新磁盘上创建一个新的 MBR 分区：

```
# **fdisk -i wd1**
Do you wish to write new MBR and partition table? [n] **y**
Writing MBR at offset 0.
```

一旦您的磁盘上有了 MBR 分区，您就可以创建 disklabel 分区。

### 创建 Disklabel

所有 OpenBSD 平台都使用 disklabel 分区。要激活安装过程中使用的相同 disklabel 编辑器，给 `disklabel` 添加 `-E` 标志和磁盘名称：

```
# **disklabel -E wd1**
```

这应该与本章前面的内容相似。使用交互式 disklabel 编辑器创建您的新分区。对于单个 */home* 目录，我们将使用一个大的分区，*wd1a*。新的标签应该看起来像这样：

```
#                size           offset  fstype [fsize bsize  cpg]
  a:         33543648               64  4.2BSD   2048 16384    1
  c:         33554304                0  unused
```

当您完成编辑分区后，通过打印 disklabel 检查您的工作。这也应该给出新磁盘的 DUID。

当您对分区满意时，使用 `newfs` 在新分区上创建一个文件系统：

```
# **newfs wd1a**
```

您现在可以开始向您的计算机添加文件系统。

### 移动分区

将数据从一个磁盘移动到另一个磁盘比添加新的分区稍微复杂一些。您必须首先在临时位置挂载新驱动器，将文件复制到该位置，然后从旧位置删除它们，并将新驱动器挂载到其原来的位置。

我们新的 */home* 文件系统位于磁盘分区 *wd1a* 上。默认的“临时挂载”位置是 */mnt*，所以将其挂载在那里。这是严格临时的，因此没有必要通过 DUID 挂载它或为它创建一个 */etc/fstab* 条目。

```
# **mount wd1a /mnt**
```

然后，您可以使用 `tar(1)`、`cpio(1)` 或 `dump(8)` 和 `restore(8)` 将文件复制到临时位置。在这里，我们将 */home* 中的所有内容复制到 */mnt*。

```
# **(cd /home && tar cf - . ) | (cd /mnt && tar xpf - )**
```

您也可以使用 `cp(1)` 或 `mv(1)` 来做这件事，但这些命令不能保证文件权限和所有权会完整复制。OpenBSD 的这些程序版本在复制或移动文件时从未给我出错，但我从其他类 Unix 操作系统中了解到，在移动整个文件层次结构时，`tar` 和 `cpio` 都更可靠。如果您使用文件标志进行安全设置（见第十章），您必须使用 `dump(8)` 和 `restore(8)` 来保留这些标志。

使用 `tar` 或 `cpio` 不会从原始位置删除文件。这意味着，如果您在复制文件之后但在更改挂载点之前更改了用户的主目录中的文件，那么当您在移动磁盘时，他将丢失他的更改。^([20])

现在更新 */etc/fstab* 以反映您的新硬盘。

### 添加新的文件系统

查看新硬盘的磁盘标签并获取硬盘的 DUID。这个新硬盘的 DUID 是 `fea9194ee78362d8`。使用 DUID 和分区字母为您的新的分区创建一个 */etc/fstab* 条目。

```
fea9194ee78362d8.a /home ffs rw,nodev,nosuid,softdep 1 2
```

您可能希望在新位置保留旧分区，例如 */oldhome*。

如果您不确定为您的新的分区使用哪些挂载选项，`nodev`、`nosuid` 和 `softdep` 选项通常是安全的。您可能还想将分区设置为可读写（`rw`）。

现在卸载旧分区并挂载新分区。

```
# **umount /home**
# **mount /oldhome**
# **mount /home**
```

当您卸载一个分区时，`umount` 不会检查 */etc/fstab*。您告诉它卸载一个分区，然后它就卸载了那个分区。

### 可堆叠挂载

OpenBSD 文件系统是可堆叠的，这意味着您可以在另一个分区之上挂载一个分区。顶部的分区会隐藏下面文件系统中的任何文件。

以单用户模式查看您的系统。默认情况下，只有根分区被挂载。您可以查看 */home* 目录，它将是空的。没有理由您不能在 */home* 目录中放置文件，即使 */home* 没有挂载。假设您在单用户模式下将几个核心文件复制到 */home*，然后进入多用户模式。所有常规分区都已挂载。如果您此时查看 */home*，您将找不到您的核心文件。

发生了什么？那些文件去哪里了？

文件在 */home* 目录中，但在根分区上。*/home* 分区挂载在目录之上，因此 */home* 分区掩盖了根分区上 */home* 目录中的文件。要访问这些隐藏的文件，您必须卸载 */home* 分区。然而，这些隐藏文件仍然占用根分区的空间。

这种情况在分区分割时更为常见。例如，如果你发现你的 */var* 分区太小，你可能会将 */var/www* 移动到单独磁盘上的自己的分区中。为了在原始的 */var* 上释放空间，删除你复制到 */var/www* 的文件。

在掌握文件系统管理的基本知识后，你现在可以开始了解一些 OpenBSD 更有趣的文件系统技巧。

* * *

^([17]) 如果是缓释型阿司匹林，那么你正在进行缓释型缓释阿司匹林转移。但让我们不要深入那个话题。

^([18]) OpenBSD 并不是唯一仍然使用 BSD 4.4 文件系统或其衍生版本的操作系统。如果一个 Unix 供应商没有特别吹嘘其“改进和先进的”文件系统，那么它几乎肯定运行的是 FFS 的衍生版本。

^([19]) 嗨，Henning！

^([20]) 假设你在进行维护之前会警告你的用户。或者至少在维护期间。或者……也许是在之后。
