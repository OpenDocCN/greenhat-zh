## 第二十一章。数据包过滤

*名字是 Pond，詹姆斯·庞德。*

*我的 x86 已加载，*

*授权过滤。*

![](img/httpatomoreillycomsourcenostarchimages1616079.png) 数据包过滤和流量操作是网络安全中最基本的工具之一。OpenBSD 包含一个非常强大的内核级数据包过滤器 `pf(4)` 或 PF。这个工具不仅执行标准过滤，还可以以多种方式检查、重新组装、重定向以及其他方式滥用数据包；同时以多个不同方向转换地址；验证用户；并管理带宽。与 PF 一起，OpenBSD 包含允许您将系统转换为负载均衡器、透明代理或其他网络设备的程序。

PF 是 OpenBSD 的亮点之一，值得拥有一本自己的书。这本书是 Peter Hansteen（No Starch Press，2010）所著的 *《PF 权威指南》*，*第 2 版*，详细介绍了许多不同的 PF 应用场景。本章涵盖了 PF 的基础知识，以便您能够保护一个小型网络或单个服务器。如果您想保护一个 Web 农场，并且只将流量透明地转发到具有足够空闲容量来处理负载的活跃服务器，请获取 Peter 的书。

话虽如此，即使是 Peter 的书也没有涵盖 PF 的全部内容。OpenBSD 允许您对 TCP/IP 进行折叠、拉伸和扭曲，远远超出了任何合理的人在任何实际环境中可能期望支持的范畴。有关 PF 的完整详细信息，请阅读 `pf(4)`、`pfctl(8)`、`pf.conf(5)` 手册页，以及 OpenBSD PF FAQ 在 *[`www.OpenBSD.org/faq/pf/`](http://www.OpenBSD.org/faq/pf/)*。

### 注意

PF 仍在积极开发中。虽然配置语法不像以前那样频繁变化，但请检查 `pf.conf(5)` 以获取关于您版本 OpenBSD 的最新信息。

## 防火墙

在过去 20 年左右的时间里，*防火墙* 这个词已经被折磨得无法辨认，以至于它不再具有特定的含义。一般来说，防火墙位于私有网络和公共网络之间，并控制两者之间的流量。

您可以用不到 100 美元的价格购买一个用于电缆调制解调器的防火墙，也可以用 100 万美元购买一个企业级防火墙集群。区别在哪里？它们都是防火墙，就像老鼠、猫和象都是哺乳动物一样，但有些是受欢迎的，而大多数则不然.^([45]) 当然，您允许的当然是您个人的偏好。而且防火墙也大致如此。

一些防火墙过滤应用层流量。一些仅基于协议或端口进行过滤。一些防火墙检查协议标志并确保流量合理性。其他只是传递数据包。还有一些防火墙只是转换网络地址，并声称这提供了安全性。更糟糕的是，价格标签与功能集没有任何关系。

在最基本的情况下，所有防火墙都会过滤数据包并可以执行网络地址转换（NAT）。OpenBSD 可以像大多数商业防火墙一样，甚至更好地进行这些任务。但是，如果你想要应用程序代理，它们并不包含在核心 OpenBSD 系统中（除了 FTP 和 TFTP 代理，这些代理对于这些协议与 NAT 一起工作是必要的）。几个流行的应用程序代理在 OpenBSD 上运行得相当好，但它们不是 OpenBSD 的一部分。例如，我使用 Squid（*/usr/ports/www/squid*）和几个相关软件包在 OpenBSD 上构建了一个与大型公司提供的任何东西相媲美的 Web 代理和过滤器，以及一系列其他代理来管理几乎所有其他事情。如果你对防火墙感兴趣，我强烈建议你至少一次从可用的组件中组装一个功能强大的防火墙，以教育为目的，如果其他什么也不做的话。

防火墙是你自己定义的。你可以将所有流量通过简单的 OpenBSD 数据包过滤器发送，并诚实地宣称你有一个防火墙，或者你可以设置应用程序代理、身份验证等，仍然可以说你有一个防火墙。一个简单的数据包过滤器就像那些集成应用程序代理、价格昂贵的设备一样，是一个防火墙。下次有人说他有一个防火墙时，请记住这一点。

实际上，防火墙不是一个安全设备。它是一个政策执行点。46 防火墙不会保护任何东西；它阻止对某些服务的访问。但是阻止访问并不 inherently secure inherently insecure services—it just means you can’t access them. 如果你的防火墙允许访问某个服务，防火墙不会为该服务增加任何安全性。

为了构建一个有效的防火墙，你必须理解 TCP/IP。如果第十一章对你来说是一个启示，请获取一份*The TCP/IP Guide*（No Starch Press，2005）的副本。阅读它。标记它。突出显示它。然后再读一遍。

本章中的许多示例都假设你在构建防火墙。这意味着你的主机有两个或更多网络接口（包括 VLAN 接口），并且你想要保护一侧的网络不受另一侧网络的影响。虽然这是 OpenBSD 的一个流行应用，但这里涵盖的所有内容在单个主机上同样适用。我在孤立的 Web 服务器、桌面和任何裸露在互联网上的主机上过滤数据包。

## 启用和配置 PF

OpenBSD 在系统启动时默认启用 PF，使用以下*rc.conf*变量：

```
pf=YES
pf_rules=/etc/pf.conf
```

要在启动时禁用 PF，请在*rc.conf.local*中将`pf`设置为`NO`。

PF 的默认配置文件是*/etc/pf.conf*。这个文件并没有什么特殊之处——它只是一个标准位置。`pf(4)`内核接口不会直接读取该文件；PF 控制程序`pfctl(8)`读取文件并将配置发送到内核。

默认的 PF 配置（硬编码在*/etc/rc*中）阻止了除 ICMP 和 SSH 之外的所有网络流量。在引导过程中，PF 用*/etc/pf.conf*中的规则替换这些默认规则。如果*pf.conf*中的错误在系统引导时使文件不可解析，PF 无法加载这些规则；相反，它保留默认配置。您将能够连接到您的机器以纠正您的规则，但这就足够了。（而且，正如任何管理远程防火墙的人都可以告诉您的那样，这种能力可以为您节省大量的驾驶和电话费。）

默认运行 PF，即使有宽容的规则集，也会在内核的其他部分处理之前清理传入的流量。PF 在将数据包交给内核之前重新组装数据包，并且显然是虚假的流量，如太短而无法成为合法的数据包，将被丢弃。

如果您想在接口之间转发数据包（即，充当“防火墙”），请告诉内核使用`net.inet.ip.forwarding`和`net.inet6.ip6.forwarding` sysctls 转发数据包。（有关已注释示例，请参阅*/etc/sysctl.conf*。）

```
#net.inet.ip.forwarding=1
#net.inet6.ip6.forwarding=1
```

移除井号并重新启动，或者使用`sysctl(8)`在运行时启用和禁用数据包转发。

## 数据包过滤基础

数据包过滤是将数据包与规则列表进行比较，并根据这些规则接受、拒绝或修改它们。作为网络管理员，您有权决定哪些数据包是“坏”的，哪些是“好”的。当您为单个主机过滤数据包时，您可以合法地称该主机为“加固的”。（“加固”一词几乎与“防火墙”一词的意思完全相同：什么都没有。）当您将您的网络上的所有数据包通过一个过滤数据包的主机发送时，您就有一个基本的防火墙。

基本的数据包过滤器可能只允许您根据 TCP 或 UDP 协议号进行过滤。有些甚至不允许您根据 ICMP 类型进行过滤，或者无法处理 GUI 中未列出的协议。然而，PF 可以处理您向其投掷的几乎所有内容。如果您需要一台机器通过 IP 协议 184 与其他机器通信，PF 将支持您。许多商业防火墙不会允许您通过此类流量，或者声称可以，但如果你实际尝试，它们会大发雷霆。

### 数据包过滤概念

第十一章描述了 TCP 连接可以处于各种状态。一个刚开始的 TCP 连接会经历一个三次握手过程。客户端通过向服务器发送一个同步请求，或 SYN，数据包来请求连接。服务器通过向客户端发送 SYN 的确认以及它自己的 SYN 请求，或 SYN+ACK 数据包来响应。客户端随后发送自己的 ACK。

这个三次握手过程的每一部分都必须完成，才能在两台机器之间传输实际数据。您的数据包过滤规则必须允许三次握手和随后的数据传输的每一部分。PF 通过*状态检查*自动识别这些三次握手并跟踪它们。

#### 状态检测

PF 维护一个已完成的连接设置允许连接的列表，这被称为 *状态表*。当客户端发送一个 SYN 数据包时，PF 将该数据包记录在表中，并等待相应的 SYN+ACK 数据包。如果 PF 收到 SYN+ACK 数据包，但没有记录相应的 SYN 请求，则拒绝该 SYN+ACK 数据包。

PF 有一系列内置的超时时间，这些时间决定了空闲连接在状态表中保持多长时间，等待三次握手每个阶段的时长，等等。状态表是自我维护的，我从未需要调整这些超时时间。（偶尔，我需要增加状态表的最大大小。）

UDP 在技术上是无状态的，但某些应用程序期望一定量的状态。当你的系统传输一个 UDP 数据包时，应用程序可能会期望一个 UDP 数据包或 10 个响应，或者没有数据包，这取决于应用程序。

DNS 查询是 UDP 数据包往返流动的常见例子，虽然 UDP 没有状态，但 DNS 确实有。 (ICMP 的行为类似。)你可以根据你的协议，通过将这些流添加到状态表中来让 PF 期望或不需要这种往返。

### 注意

PF 也可以在不进行状态检测的情况下运行，允许根据单个数据包特征从主机和端口传输流量。*无状态过滤* 比状态检测慢，更难正确配置，通常被认为比状态检测不安全且不那么有用。

#### 数据包重组

数据包在传输过程中可能会被破坏，通常是通过 *分片*。数据包过滤器的部分工作就是合理地 *重组* 这些数据包。PF 可以以多种方式重组和合理化数据包。（旧版本的 PF 将此称为 *清洗*。）

#### 默认接受与默认拒绝

数据包过滤中的一个基本概念是默认接受与默认拒绝的问题：

+   *默认接受* 立场意味着你允许任何类型的连接，除了你明确拒绝的连接。默认的 PF 规则是默认接受立场的例子。

+   *默认拒绝* 立场意味着你只允许明确允许的连接。所有其他连接都被拒绝。

一旦你选择了默认设置，你可以调整你的规则，根据需要隐藏或显示网络服务。在当今世界，我建议在所有系统上使用默认拒绝，因为这种立场在将新服务添加到系统时保护了这些服务。在过去十年中，我看到的大多数使用默认接受立场的环境，是因为系统管理员没有理解他们所使用的网络协议。这在 VoIP 安装中尤其常见（是的，你可以对 VoIP 服务器进行数据包过滤！）

除了数据包过滤和重组之外，PF 还提供了一些其他重要功能，包括 NAT、连接重定向和带宽管理，仅举几例。我们将分别考虑。所有这些都在`*pf.conf*`中配置，并通过`pfctl(8)`进行管理。

### “我的网络不会出错”

许多构建防火墙的网络管理员会仔细过滤和限制入站流量，但只在出站流量上施加最小限制。虽然对入站流量的控制是网络管理中最直接的问题之一，但出站流量的控制也同样重要。

即使你信任你的用户，恶意软件也可以将一名熟练工程师的工作站变成垃圾邮件喷发虫。不要假设你的网络不会出错。它可以是有害的，而且总有一天会变成这样，但仔细的流量控制可以最小化你对邻居、客户、客户和声誉造成的损害。

你的员工桌面是否有理由连接到任何随机的远程邮件服务器？如果没有，就阻止它，即使工作站感染了垃圾邮件机器人，世界上的其他人也不会将你列入黑名单。用户是否有理由连接到远程 DNS 服务器，或者他们应该使用公司的 DNS 服务器？阻止出站 DNS，防止用户成为拒绝服务攻击的无意识放大器。我强烈建议对出站和入站流量都采取默认拒绝立场，并明确允许期望的流量。

当然，有些网络可能是个例外。如果你的网络上的每个系统都运行 OpenBSD，你将相当安全，免受常规恶意软件的侵害，但我们已经看到恶意软件针对电视、蓝光播放器、流媒体播放器和其他具有网络连接的设备。现在就保护自己。

无论何时你发现自己认为你的网络不会出错，请停下来提醒自己，你并不像世界上每个恶意软件作者的组合那样聪明。

### 数据包过滤无法做到的事情

数据包过滤根据 TCP/IP 协议和相关特性（如端口号）完全控制网络连接。如果你想阻止来自某些 IP 地址的所有流量，数据包过滤是你的朋友。如果你想只允许连接到特定的 TCP/IP 端口，数据包过滤将为你工作。如果你想只允许设置 ECN 标志的包进入，但没有其他标志，PF 将支持你（尽管这听起来相当愚蠢）。

你可以过滤在逻辑协议层运行的协议，如 IPsec、SKIP、VINES 等，但仅限于网络协议。如果是在不同的协议层，PF 就无能为力了。

### 注意

PF 甚至可以根据 MAC 地址进行过滤。通过在`bridge(4)`接口上添加的标签，对这种特定的媒体层协议提供了特殊支持，如`ifconfig(4)`文档所述。

类似地，PF 对应用程序或应用程序协议一无所知。如果您允许您的网络内服务器的 TCP/IP 连接到端口 25，您可能会认为您正在允许连接到该主机上的邮件服务器。实际上，您正在允许连接到该主机上运行在端口 25 上的任何守护进程！PF 不识别 SMTP 数据流；它只看到连接到端口 25。 (我有一个系统在许多通常分配给其他服务的端口上提供 SSH，这样我就可以轻松绕过任何我可能陷入的简单数据包过滤器。)

## PF 组件

在我们深入研究 PF 之前，让我们看看 OpenBSD 上数据包过滤的基本组件。除了 `pf(4)` 内核模块外，我们还将查看数据包过滤器控制程序和配置文件 */etc/pf.conf*。了解接口组也有帮助。

### 数据包过滤器控制和配置

使用数据包过滤器控制程序 `pfctl(8)` 来管理、配置和从 PF 中提取信息。您可以看到当前的包过滤规则和设置、正在处理连接、TCP/IP 事务的状态、调试信息以及各种其他细节。您还可以解析规则文件并将它们安装到实际的数据包过滤器中。

您将看到许多针对 `pfctl` 的不同选项，涵盖了数据包过滤管理的各个方面。其中许多选项相当长，但您只需输入足够多的单词参数来使命令独特。例如，您不必输入 `pfctl -s rules`，只需输入 `pfctl -sr` 就可以，因为没有其他 `pfctl -s` 的参数以 `r` 开头。话虽如此，我给出所有示例的完整形式，因为无法保证 OpenBSD 不会在未来添加以 `r` 开头的其他参数。

我专注于使用 `pfctl` 来查看 PF 输出，但 OpenBSD 还在 `systat(1)` 中包含了 PF 视图。对于 PF 活动的动态显示，类似于网络中的 `top(1)`，请查看 `systat`。通过提供视图名称作为参数来运行 `systat`，例如 `systat pf`。并且，一如既往，如果您想从 `pfctl` 获取更多详细信息，请添加一个或两个 `-v` 参数以启用详细模式。

您在 */etc/pf.conf* 中配置 PF。*pf.conf* 文件包含语句和规则，其格式根据它们配置的功能而变化。在我们完成之前，您将非常熟悉这个文件。

### 接口组

OpenBSD 允许您将接口放入命名组中，您可以在 PF 规则中引用这些组。这抽象了实际的物理接口，并允许您构建基于策略的规则集。看看这个接口：

```
# **ifconfig em0**
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
…
        groups: egress
…
```

此接口位于 `egress` 组中。如果一个默认路由通过该接口到达，则该接口将被分配到 `egress` 组。

要将此接口移动到新的组 `dmz`，请将其从 `egress` 组中删除并添加到 `dmz` 组中。当您将第一个接口分配给它时，将创建一个接口组，一个接口可以属于任意数量的组。

```
# **ifconfig em0 -group egress**
# **ifconfig em0 group dmz**
# **ifconfig em0**
em0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
…
        groups: dmz
…
```

你现在可以编写引用接口组而不是特定接口的规则。

### PF 配置

让我们拆解一个 OpenBSD 系统中的默认 *pf.conf* 文件，并识别一些部分。许多默认条目已被注释掉，但识别它们将有助于你理解组件是如何组合在一起的。

它从一个 *选项* 开始：

```
set skip on lo
```

选项可以打开或关闭功能，或设置其他功能的行为的一般规则。`skip` 选项根据接口禁用 PF。

接下来是 `anchor` 设置：

```
anchor "ftp-proxy/*",
```

一个 *锚点* 是一组用于数据包过滤的动态子规则。如果一个数据包在通过过滤规则处理时击中锚点，它将被丢弃到这个子规则集中进行进一步处理。`pfctl` 可以更改内核中运行的规则，而锚点是一种说“在这里添加新规则”的方式。

锚点通常用于允许外部软件向防火墙添加规则。例如，FTP 是一种复杂的协议，需要各种防火墙规则。OpenBSD 包含一个 FTP 代理，它可以动态地添加允许的 FTP 连接所需的所有规则。

然后是两个 *数据包过滤* 规则：

```
pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
pass
```

第一个是支持 FTP 流量的规则，与 FTP 锚点结合使用。我们将在下一章中更详细地探讨锚点和 FTP 处理。另一个是一个更简单的数据包过滤规则，允许所有流量。

接下来是两个 *表格*，它们是 IP 地址的列表：

```
table <spamd-white> persist
table <nospamd> persist file "/etc/mail/nospamd"
```

外部程序可以动态地更改表格，你可以在 *pf.conf* 或外部文件中直接向表格添加地址。这两个表格由反垃圾邮件软件 `spamd(8)` 使用。

表格之后是另一个数据包过滤规则：

```
pass in **on egress** proto tcp from any port smtp \
    rdr-to 127.0.0.1 port spamd
```

这条规则很有趣，因为它指的是一个接口组。只要流量到达 `egress` 组中的接口，就允许进入。

最后一条规则如下：

```
block in on ! lo0 proto tcp to port 6000:6010
```

这条数据包过滤规则阻止流量。如果一个数据包到达除了环回接口之外的任何接口，并且该数据包是 TCP 协议，目标端口为 6000 到 6010（包括 6010），则会被阻止。

这是在 *pf.conf* 中你会看到的东西。让我们深入了解过滤规则的具体细节。

## 过滤规则

过滤规则是 PF 的核心。你可以不进行任何花哨的重定向、地址转换、负载均衡或冗余操作来使用 PF，但数据包过滤是大多数这些功能的基础。然而，首先，基本的包过滤被定义为通过源、目的、协议和协议特性对网络数据包进行访问控制。

PF 按顺序处理过滤规则。最后匹配到数据包的规则将被执行。一个典型的数据包过滤规则看起来像这样：

```
**1**pass **2**in **3**on egress **4**proto tcp **5**from any **6**to 192.0.2.12 **7**port 80
```

过滤规则的第一词是一个关键字，描述了该规则的结果**1**。PF 将根据规则“通过”或“阻塞”匹配的数据包。 （还有“匹配”，我们将在下一章中探讨。）该行的其余部分是对匹配数据包的描述。如果数据包与描述匹配，则应用该规则。

第二个语句是数据包的方向。数据包要么进入要么出去。在这个规则中，数据包是进入的**2**——它正在进入系统。我们不仅定义了方向，还定义了一个接口组。数据包必须通过`egress`组中的接口进入此系统才能匹配此规则**3**。

然后我们有几个定义流量特征的语句。（这个规则几乎就像 TCP/IP 的正则表达式。）此规则适用于来自任何 IP 地址**5**的 TCP 连接**4**，如果连接是到 IP 地址 192.0.2.12**6**的端口 80**7**。

如果一个数据包与所有这些特征匹配，它就可以通过。如果这些特征中的任何一个不匹配，数据包就不符合这个规则，PF 会继续处理规则，寻找匹配项。

TCP 和 UDP 规则隐式检查连接状态。匹配此规则的数据包需要是一个 SYN 数据包，即标准 TCP/IP 连接的开始。PF 使用状态表来管理同一连接中的后续数据包（参见过滤规则和状态表）。

### 默认允许或默认拒绝

我之前提到了默认接受与默认拒绝的概念。在您的数据包过滤规则开始时设置这种立场，可以使用以下两个语句之一：

```
pass
block
```

默认的*pf.conf*具有默认通过立场，但它是为尚未配置防火墙的人准备的。我建议从单独的`block`语句开始您的过滤规则，然后添加规则以明确允许期望的流量。请记住，最后一个匹配的规则获胜。

### 数据包模式匹配

PF 最密集的部分之一是用于描述数据包的语法。大多数过滤规则通过协议、端口、方向和其他特征来描述数据包。PF 将每个到达的数据包与状态表进行比较，如果数据包不是状态表的一部分，它将数据包与过滤规则进行比较。如果规则与数据包描述匹配，则按需通过或阻塞数据包。

一旦您定义了您是在默认接受还是默认拒绝立场，过滤规则就描述了默认规则的例外。因此，如果您默认阻止数据包，您的大多数过滤规则将是描述特定期望连接的“通过”语句。

#### 方向

关键字`in`和`out`描述了数据包的传输方向。在许多商业防火墙中，`in`一词表示进入受保护网络的流量，而`out`指的是离开受保护网络的流量。OpenBSD 不会神奇地知道网络的哪一侧是受保护的，哪一侧不是。在 PF 看来，它正在管理两个接口之间的流量。关键字`in`表示从网络流入机器的流量，而`out`表示离开机器并进入网络的流量。

当你在 PF 规则中看到`in`或`out`时，不要将整个网络视为一个整体。相反，想象你自己非常小，坐在 CPU 上，在散热器上烤牛排，并观察数据包进入和离开计算机。你无法看到箱体之外的情况，只能看到来去的数据包。进入的数据包正在接近你，而出去的数据包正在远离你。

#### 接口匹配

`on`关键字描述了此规则适用的接口或接口组。您必须指定一个接口。

如果你想让规则匹配系统上的每个接口，请使用接口名称`all`。此示例阻止所有进入机器的接口`fxp0`上的流量，但允许所有通过接口组`egress`离开系统的流量：

```
block in on fxp0
pass out on egress
```

此规则集意味着接口`fxp0`由于某种原因而特殊，因此它不像`egress`组中的其他接口那样被处理。

#### 地址族

规则可以应用于特定的地址族，即`inet`用于 IPv4 或`inet6`用于 IPv6。以下是禁止 IPv4 但允许 IPv6 的方法：

```
block in on egress inet
pass in on egress inet6
```

假设您有更严格限制 IPv6 的后续规则。

#### 网络协议

PF 可以通过数字或名称识别几乎任何网络协议。`proto`关键字告诉 PF 匹配一个协议。网络协议可以通过名称从`/etc/protocols`、协议号或甚至列表（见使用列表）提供。

```
block in on egress proto tcp
pass in on egress proto udp
```

您可以使用此方法来通过除 IP 和 IPv6 之外的其他协议。以下是允许 IPsec 所需协议的方法：

```
pass in on egress proto esp
pass in on egress proto ah
```

此功能与`inet`和`inet6`语句有些重叠。如果您愿意，您可以明确允许 IP、ICMP、TCP、UDP 以及所有各种 IPv6 协议。

#### 源地址和目标地址

几乎每个过滤规则都指定了源地址和/或目标地址。

```
pass in on egress from 198.51.100.0/24 to 192.0.2.0/24
```

IP 地址可以以单个地址或带有子网掩码的地址（如前例所示）的形式出现。关键字`any`表示任何 IP 地址。关键字`all`是“从任何到任何”的简称。

您也可以使用主机名而不是 IP 地址。`pfctl`在加载规则时会检查主机的 IP 地址，并将实际 IP 地址插入到规则中。

```
pass in on egress from www.michaelwlucas.com
```

如果主机的 IP 地址发生变化，PF 不会注意到，直到你使用`pfctl`重新加载规则。如果找不到主机名，规则将无法解析，`pfctl`将无法加载它们。我建议不要在过滤规则中使用主机名，就像我建议在游泳时不要穿中世纪的板甲一样，但它是一个可用的选项。

要表示“除了这个地址之外的所有内容”，请使用感叹号作为否定字符。

```
block in from !192.0.2.0/24
```

这表示“除了地址 192.0.2.0/24 之外，所有内容都被阻止。”这与说“允许 192.0.2.0/24”不同，但它可以帮助简化你的规则。

你也可以使用列表、宏和表格作为 IP 地址。列表和宏将在本章后面讨论，表格将在下一章介绍。

#### 源和目标变体

你可以使用接口或接口组的名称而不是 IP 地址。

```
pass out on egress from egress
```

这允许流量通过出口接口组离开，从该组中任何接口的任何 IP 地址到任何 IP 地址。

如果你将接口名称或组放入括号中，PF 会在接口上的 IP 地址更改时更新其规则。这对于拨号连接或当你从接口添加和删除 IP 地址时非常有用。

```
pass out on egress from (egress)
```

你可以通过在名称后跟`:network`来指定直接连接到接口或接口组的网络。

```
pass in on egress from egress:network
```

假设出口组只有一个接口，并且该接口的 IP 地址为 192.0.2.88/25。这条规则将转换为以下内容：

```
pass in on egress from 192.0.2.0/25
```

这条规则意味着任何连接到出口接口的主机都可以在任何地方进行通信。当你向出口组添加另一个接口时，规则会自动更新以适应新接口的网络。

要过滤接口或组的广播流量，请使用`:broadcast`修饰符。

```
block in on egress from egress:broadcast
```

再次假设出口组只有一个接口，并且该接口的 IP 地址为 192.0.2.88/25。这条规则将转换为以下内容，在本地子网上阻止广播流量：

```
block in on egress from 192.0.2.127
```

使用`:peer`修饰符来指示点对点链路（如拨号连接）另一端的 IP 地址。

```
pass in on egress from egress:peer
```

在这里，我们完全信任我们的拨号服务提供商。

#### 接口主地址

要仅使用接口上的第一个 IP 地址，请使用接口或组名称添加`:0`修饰符。

```
pass out on egress from (egress:0)
```

出口接口组可能有 98 个 IP 地址分布在三个接口上，但每个接口上只有一个地址是第一个地址。此主机可以通过出口接口组进行通信，但只能从主 IP 地址进行通信。别名 IP 地址不能发起出站连接。

`:0` 修饰符的问题在于内核对接口上“第一个”地址的概念非常模糊。内核有一个与接口关联的地址列表。列表顶部的地址是当前“第一个”或“主要”地址，但这个地址可能会改变。如果这可能会引起问题，请在你的规则中指定 IP 地址，而不是依赖 `:0`。

你可以将 `:0` 附在任何其他接口修饰符上，即除了规则中的第一个地址之外的 IP 地址。OpenBSD 无法判断远程机器上的 IP 地址是别名还是实际 IP 地址，但你可以在本地机器上禁止对或来自别名的流量。

注意，接口上的第一个地址要么是 IPv4 地址 *要么* 是 IPv6 地址。如果你想允许每个协议的第一个地址，请在规则中指定地址族。

```
pass out on egress inet from egress:0
pass out on egress inet6 from egress:0
```

否则，PF 将仅使用它看到的第一个地址，无论地址族如何。

#### 源和目的端口

过滤规则可以描述 TCP 和 UDP 端口。

```
pass in on egress proto tcp from any to 192.0.2.12 port 80
```

此示例允许访问服务器 192.0.2.12 上的 TCP 端口 80。这可能是 Web 服务器。

你可以使用来自 */etc/services* 的服务名称而不是端口号，或者甚至使用列表（如本章后面所述）。你还可以使用范围，如表 21-1 所示。

表 21-1. 表 21-1：端口范围

| 符号 | 含义 |
| --- | --- |
| `!=` | 不等于 |
| `<` | 小于 |
| `>` | 大于 |
| `<=` | 小于等于 |
| `>=` | 大于等于 |
| `><` | 范围 |
| `<>` | 反向范围 |

例如，要指定所有大于 1024 的端口，你可以使用大于运算符（`>`）。

```
pass in on egress proto tcp from any to 192.0.2.12 port > 1024
```

要指定 1000 和 2000 之间的所有端口，不包括 1000 和 2000，请使用范围运算符（`><`）。

```
pass in on egress proto tcp from any to 192.0.2.12 port 1000 >< 2000
```

要将端口 1000 和 2000 包含在你的范围内，使用包含范围运算符（`:`）。(注意，冒号两侧不能有空格。)

```
pass in on egress proto tcp from any to 192.0.2.12 port 1000:2000
```

要传递所有小于 1000 且大于 2000 的端口的流量，请使用反向范围运算符（`<>`）。

```
pass in on egress proto tcp from any to 192.0.2.12 port 1000 <> 2000
```

范围允许你在非常少的规则中表达大量的端口。

### 完整规则集

以下是一个桌面机的完整规则集，使用了之前描述的许多功能。我们将在后面查看一些更复杂的规则集，但这个例子说明了 PF 规则的许多基本原理。

接口组 `egress` 连接到公共网络，而接口组 `inside` 连接到我的私有网络。

```
**1** set skip on lo
**2** block
**3** pass in on egress from egress:network
**4** pass in on inside from inside:network
**5** pass in on egress proto tcp from any to egress:0 port 22
**6** pass out all
```

第一条规则禁用了回环接口 **1** 的数据包过滤，第二条定义了一个默认拒绝立场 **2**。第二条和第三条规则允许来自直接连接到外部 **3** 和内部接口 **4** 的 IP 地址的所有连接。如果我在我的桌面上安装一个 Web 服务器，我希望能够从网络中任何我控制的机器上查看它。然后我允许来自世界任何地方的任何 `egress` 接口的 IP 地址的 SSH 连接进入。最后，我允许所有出站流量，这样我的桌面就可以自由访问外部世界 **6**。

我之前说过，PF 规则按顺序处理，这些规则说明了这一点。我设置了一个默认规则，阻止所有流量，然后使用单个规则来排除全局阻止的例外。

### 激活规则

为了使你的 PF 规则生效，你必须使用 `pfctl -f` 将它们加载到内核中。

```
# **pfctl -f /etc/pf.conf**
```

首先，`pfctl` 读取并解析规则文件。如果文件解析正确，`pfctl` 将扩展文件中的任何变量，执行任何必要的 DNS 查询以将主机名转换为 IP 地址，并将完整的规则馈送到内核。内核读取新的规则，然后在一次操作中在旧规则和新规则之间切换。在任何时候，数据包过滤规则都不会缺失、混乱或两个规则集的混合体。另外请注意，`pfctl -f` 不会在禁用的情况下启用 PF。

个人来说，我喜欢知道我的编辑过的数据包过滤配置在预定更改时间之前已经解析。当宣布给团队“新的防火墙配置将在中午生效”并花了一整天的时间追踪一个放错位置的逗号或括号，你应该放花括号时，这会让人感到尴尬。为了在不安装规则的情况下测试你的语法，请使用 `-n` 标志与 `-f` 一起使用。添加 `-v` 以启用详细模式，以查看 `pfctl` 如何扩展你的宏、组等。

```
# **pfctl -nvf /etc/pf.conf**
```

规则可能仍然有错误，但只是理解上的错误，而不是语法错误。

加载新规则不会删除任何现有的开放连接或状态条目。如果我的旧规则集允许出站 SSH 连接，而我从新安装的规则中移除了该权限，现有的 SSH 连接仍然保持开放。我可以使用 `pfctl -k` 特意终止这些连接，或者刷新状态表。

### 查看活动规则

要查看这些规则在 PF 内部的解释，请使用 `pfctl -s rules` 查看当前安装的规则集。以下是 一个完整的规则集 中配置生成的规则：

```
  # **pfctl -s rules**
**1** block drop all
**2** pass in on egress inet6 from 2001:db8:4::/64 flags S/SA
**3** pass in on egress inet from 192.0.2.0/28 flags S/SA
**4** pass in on inside inet from 192.168.1.0/24 flags S/SA
**5** pass in on egress inet proto tcp to 192.0.2.5 port = 22 flags S/SA
**6** pass out all flags S/SA
```

第一条规则建立了一个默认拒绝立场 **1**。然后我特别允许来自 `egress` 组中接口的本地网络的连接，无论是 IPv6 **2** 还是 IPv4 **3**。这个桌面还接受来自我的私有网络的连接 **4**。

私有网络只允许来自 IPv4 地址的连接，因为私有组中的接口只有一个 IPv4 地址。（我真的很应该添加一个 IPv6 地址，但它没有给我带来任何麻烦，所以我又可能再次忘记它。）然后有一个规则允许传入的 SSH 流量**5**，接着是一个最终规则允许所有传出流量**6**。

如果我在我的桌面电脑上更改任何 IP 地址，防火墙规则会自动更新以适应这些更改。这是接口组的一个非常实用的功能。如果我的桌面电脑经常移动，我会把接口组名称放在括号里，这样 PF 就会监视 IP 地址的更改。

### 注意

你可能会注意到，通过规则以`flags S/SA`结束。这意味着在 SYN 和 ACK 标志中，匹配的包只能设置 SYN 标志，表示这些是建立连接的请求。你可以根据 TCP 标志进行过滤，但这需要深入理解 TCP，大多数人应该永远不要这样做。要了解 SYN 和 SYN+ACK 包如何影响连接，你需要理解状态表。

要查看每个规则被触发多少次，请在`pfctl`命令中添加`-v`。

要查看规则如何影响不断更新的显示中的流量，请运行`systat rules`。

## 过滤规则和状态表

OpenBSD 在状态表中跟踪已批准的连接。属于已批准连接的包允许通过。考虑以下早期示例中的规则：

```
pass in on egress proto tcp from any to 192.0.2.12 port 80
```

如果一个包匹配此规则，并且它具有指示这是 TCP 连接开始的 TCP/IP 标志，PF 允许该连接。PF 还在状态表中创建一个条目。如果一个包与状态表匹配，PF 将直接传递该包，而无需查阅规则。

### TCP 状态

首先，我们将查看 TCP 连接的状态表条目。要查看状态表，请输入**`pfctl -s states`**。

```
# **pfctl -s states**
**1**all **2**tcp **3**192.0.2.12:80 <- **4**198.51.100.227:55635 **5**ESTABLISHED:ESTABLISHED
…
```

这个状态表条目代表一个包过滤器批准的特定连接。这个状态适用于所有接口**1**。如果一个状态只适用于一个接口，你将在这里看到接口名称。

这个 TCP 连接**2**目标是 192.0.2.12 端口 80**3**，来自主机 198.51.100.227 端口 55635**4**。当第一个来自 198.51.100.227 端口 55635 的 SYN 包到达时，PF 将此条目添加到状态表中。当 192.0.2.12 向 198.51.100.227 端口 55635 发送 SYN+ACK 包时，PF 查阅了状态表。这显然是一个与允许的 SYN 包匹配的匹配项，所以 PF 允许了该包，尽管在*pf.conf*中没有明确的规则允许该连接。这两个主机和这两个端口之间的数据交换继续进行。

PF 知道实际的 TCP/IP 数据交换看起来是什么样子。开始时有一个三次握手，当连接完成且 PF 跟踪连接状态时，有一个类似的舞蹈。这个特定的连接在双方**5**上建立，这意味着初始设置协商成功，数据可以自由地来回流动。

如果您的服务器足够繁忙，并且您不断刷新状态表视图，您将捕捉到其他状态下的连接。以下是数据交换结束并被拆除时的相同连接：

```
all tcp 192.0.2.12:80 <- 198.51.100.227:55635  FIN_WAIT_2:FIN_WAIT_2
```

### 注意

查看状态表可能存在的一个问题是`pfctl`显示的是快照。当您的眼睛滚动到屏幕底部时，表格已经改变。我个人认为这是唯一能够处理信息的方式。如果您需要在一个不断更新的显示中查看状态，在几乎实时的情况下，请运行`systat states`。

状态表非常具体。允许 198.51.100.227 端口 55635 到 192.0.2.12 端口 80 的状态表条目不允许其他主机和端口之间的流量。PF 知道流量应该如何流动，并且不会允许显然不属于现有 TCP/IP 交换的流量。如果一个来自 198.51.100.227 的数据包看起来像是这个数据交换的一部分，除了它来自端口 55634 而不是 55635 之外，状态表条目不会匹配。同样，如果 PF 知道连接处于`FIN_WAIT_2`状态，或者几乎完成，那么设置 ACK 标志的后续数据包不会匹配并将被丢弃。这是因为来自同一主机、同一端口的 SYN 请求不应该到达——客户端应该知道端口正在关闭之前的连接。新的连接应该来自客户端的不同端口并创建新的状态表条目。

没有状态检查，您需要编写的防火墙规则不仅允许传入流量，还允许响应。您的防火墙规则需要允许对数千个高编号端口的出站连接，而不仅仅是与所需连接相关联的单个端口。基于 TCP 标志的过滤几乎是不可能的。

### 注意

作为 20 世纪 90 年代的一名顾问，我拆除了几条被强行塞入无状态包过滤器的规则，因为这些规则在没有状态检查的情况下并不现实。此外，仔细跟踪数据交换不仅简化了规则，还防止了一系列基于 TCP/IP 的攻击。由于状态检查，您现在很少听到这些攻击。

### UDP 状态

UDP 连接的状态条目与 TCP 连接的状态条目相似。

```
all udp 192.0.2.12:53 <- 198.51.100.227:38469       SINGLE:MULTIPLE
```

这是一个 DNS 查询，目标为 192.0.2.12 端口 53，来自 198.51.100.227 端口 38469。客户端发送了一个数据包，目标以多个数据包回复。虽然状态检查不能通过标志识别此连接的状态，但它可以跟踪源地址和目标地址以及端口。你只需要写一条规则允许访问 192.0.2.12 端口 53，状态检查将允许匹配的回复数据包。

### ICMP 状态

ICMP 位于 TCP 和 UDP 之间。PF 了解 ICMP 类型，并知道对 ICMP 数据包的合法响应，通过使用状态检查，你可以自动获得所有这些好处。就像你可以编写允许特定 TCP 标志的规则一样，你也可以编写允许特定 ICMP 类型和代码的规则。我们大多数人无法做到这一点，而那些能够做到的人知道得更多。（指向现有 TCP 或 UDP 状态的 ICMP 错误将与该状态匹配，不需要单独允许。）

### 注意

OpenBSD 的状态检查实际上跟踪的细节比源地址、目标地址和端口更多。将`-v`添加到`pfctl`命令中，以查看更多信息，包括时间、由于状态而通过的数据包数量等。

## 使用列表和宏进行数据包过滤

PF 提供了许多方法，让一条规则引用多个相似的项目，或者用变量符号表示某物。基本的方法是列表和宏。

### 使用列表

*列表* 是在一条规则中表示多个相似项目的一种方式。如果你想要在特定的一组主机上打开特定的 TCP 端口组，并且你的规则条目是重复一条规则并做些小修改，那么你可能想使用列表。例如，打开 80 和 443 端口到一台主机需要两条规则：一条对应每个端口。如果你有 30 台 Web 服务器，你需要 60 条规则。这很麻烦，容易出错，但列表让你更容易表达这些常见的元素。

列表在规则中用花括号表示。为了使规则更易读，你可以在项目之间放置逗号。

```
pass in on egress proto tcp from any to 192.0.2.12 port {80, 443}
```

这一条`pf.conf`语句创建了两个规则，同时打开目标主机的 TCP 端口 80 和 443。

```
pass in on egress from any to 192.0.2.12 port = 80 flags S/SA
pass in on egress from any to 192.0.2.12 port = 443 flags S/SA
```

你也可以使用列表让这条规则覆盖多个 Web 服务器。

```
pass in on egress proto tcp from any to {192.0.2.12, 192.0.2.13} port {80, 443}
```

这将扩展为四条规则：每条规则对应服务器和端口的组合。

记住，列表中的每个条目都会创建自己的规则。列表条目不会组合成一条规则。

### 使用宏

宏是你创建并定义用于 PF 规则中的变量。宏使`pf.conf`更易读、可维护和管理。

宏名称必须以字母开头，但可以包含字母、数字和下划线。你不能给宏起一个在 PF 中其他地方使用的名字，比如`pass`、`block`或`proto`。宏的常见用途包括接口名称、网络地址和端口。

之前，我们看到了一个包括流行的 Web 端口 80 和 443 的列表。你可以将这些作为宏，如下所示：

```
web_ports="{80, 443}"
```

因此，我们的示例规则将变成这样：

```
pass in on egress proto tcp from any to 192.0.2.12 port $web_ports
```

当与花括号结合使用时，宏可以简化你的`pf.conf`文件。考虑以下`pf.conf`片段：

```
webservers="{192.0.2.12, 192.0.2.13, 192.0.2.14, 192.0.2.15}"
web_ports="{80, 443}"
pass in on egress proto tcp from any to $webservers port $web_ports
```

这会扩展为八条规则，但只需要三个易于理解的配置语句。当你添加一个新的 Web 服务器时，将它的 IP 地址添加到`webservers`宏中的列表中。更重要的是，你可能会在规则中的数十个地方使用`webservers`宏。更改 IP 地址列表一次比在每个规则中更改要容易得多，也更可能正确。

虽然你可能使用接口组来表示你机器本地的 IP 地址，但你可能还有其他需要表示的 IP 地址。宏在这方面也非常有用。

```
internal_ip="10.10.0.0/16"
```

或者，如果你有多个不同的块，你可以在宏内部使用列表。

```
internal_ip="{10.0.0.0/24, 10.0.5.0/24, 10.0.10.0/24}"
```

当使用`pfctl`查看正在运行的 PF 规则时，你不会看到宏或列表；相反，你看到的是它们扩展到的规则。

### 常见错误：列表排除和否定

列表可能难以理解，很容易编写出否定其他规则的列表。例如，这似乎应该工作：

```
clients = "{192.0.2.0/24, !192.0.2.128/29}"
pass in on egress from $clients
```

这里的想法是我们的客户端拥有 192.0.2.0/24 的 IP 地址。我们希望允许所有这些地址，除了中间的小块，即 192.0.2.128/29。这似乎是合理的，对吧？但就像排除`sudo(8)`中的命令一样，这也会出问题。记住，列表中的每个条目都会扩展为另一条规则。这会创建两条规则。

```
pass in on egress inet from 192.0.2.0/24 flags S/SA
pass in on egress inet from ! 192.0.2.128/29 flags S/SA
```

第一条规则适用于从 192.0.2.0/24 子网开始的全部内容。这正是我们想要的。然而，第二条规则却适用于不在 192.0.2.128/29 子网中的所有内容，也称为“世界上所有人”——这并不是我们希望实现的目标。

类似地，否定整个列表会扩展为否定列表中的每个单独项目。如果你需要执行这种排除操作，请使用下一章中描述的表格。

## 净化流量

互联网主机到达的各种奇怪流量。其中一些流量是损坏的垃圾。其他部分告诉你，其他人正在运行损坏的垃圾。

PF 试图在处理之前对流量进行净化和标准化。这些标准化包括丢弃非法数据包、数据包重组和数据包修改。

### 非法数据包

一些随机到达主机的数据是垃圾。如果一个数据包的长度短于 IP 头部，那么它就不能是一个真正的 IP 数据包；如果一个 TCP 数据包太短，无法包含完整的 TCP 头部，那么它也不能是一个真正的数据包。

如果数据包长度与头部中给出的长度不匹配，那么数据包就可能在某些方面损坏。PF 无法确定这些数据包的来源，或者它们是否被恶意损坏，或者只是在传输过程中损坏。由于内核无法对这些数据包进行处理，PF 会自动丢弃它们。

### 数据包重组

在包过滤器决定如何处理一个包之前，该包应该是没有歧义和随机奇怪性的。重新组装清理了这些歧义，默认的重新组装设置适用于大多数环境。当你启用 PF 时，你会得到重新组装。

### 包修改

有时候你需要修改包。如今，PF 为大多数环境处理一切。如果你需要修改包，例如清除分片 UDP 包上的“不要分段”位，请参阅`pf.conf(5)`中的`scrub`关键字。

### 阻止伪造的包

另一种经典的 IP 攻击是发送看起来来自私有网络到防火墙的包，试图绕过包过滤器。如今，大多数防火墙都阻止这种攻击，攻击者很少为此烦恼，但你仍然应该保护免受伪造攻击。仅仅因为其他人已经接种了麻疹疫苗并不意味着你应该不接种。

对于反伪造规则，使用`antispoof for`和一个接口名称。

```
antispoof for fxp0
```

当输入到包过滤器时，规则看起来可能像这样：

```
block drop in on ! fxp0 inet from 192.0.2.5/28
block drop in inet from 192.0.2.5 set ( prio 0 )
```

第一条规则丢弃了来自除`fxp0`以外的任何接口上`fxp0`本地地址的任何流量。来自`fxp0`本地地址的包应该始终通过`fxp0`到达你的系统。

第二条规则丢弃了来自`fxp0`接口地址的任何流量。具有该源地址的包永远不会从外部世界到达。如果系统需要与自身通信，它使用接口`lo0`。

你可以使用接口组而不是接口名称，但我不建议这样做。如果你有多个`egress`接口，在出口组上使用反伪造规则不会阻止到达错误出口接口的外部包。花时间在你的反伪造规则中列举你的接口。

你不仅可以列出单个接口，还可以使用列表或宏。

```
antispoof for {lo0, fxp0, em0}
```

反伪造规则可能会干扰通过环回接口传递的包。我建议跳过对`lo0`的过滤，尽管 PF 为 127.0.0.0/8 地址提供了特殊的内置保护。

现在你已经掌握了基本的包过滤，让我们来考虑一些 PF 的核心设置。

## PF 选项

选项是影响核心 PF 功能的基本设置。选项回答了像这样的问题：

+   我们是否将碎片重新组装成包？

+   状态表应该支持多少条记录？

+   是否开启了日志记录？

所有选项都以`set`关键字开头。因为选项会影响 PF 其他所有部分的操作，我建议将它们放在`pf.conf`的顶部。

在这里，我们将查看一些更常用的选项。

### 设置阻塞策略选项

你的防火墙会静默地丢弃禁止的包，还是会向客户端响应“对不起，不允许？”阻塞策略决定了它采取哪种方法。默认情况下，PF 会丢弃被阻塞的包，但你可以在单个过滤规则上覆盖全局阻塞策略。

严格来说，当 PF 丢弃数据包时，它应该向客户端返回一个错误，以便合法客户端可以立即意识到他们无法连接。使用`set block-policy return`告诉 PF 返回这些礼貌的错误：TCP 连接的 RST 和一个 ICMP 不可达消息用于其他类型的连接。

不幸的是，礼貌在现代社会互联网中被很大程度上忽视了。PF 的默认设置`set block-policy drop`告诉 PF 不要在阻塞的数据包上返回任何类型的错误。客户端应用程序，如网页浏览器、漏洞扫描器、蠕虫和其他恶意软件必须等待网络协议超时才能意识到他们无法连接。

我建议静默丢弃被阻塞的数据包.^([47])

### 设置限制选项

PF 包括限制用于跟踪片段、状态、地址表和其他内存消耗项的各种内部表的大小。我非常罕见地需要调整这些限制。现有的限制被选择是因为它们对于大多数环境中的大多数用户来说是足够的。

使用`pfctl`查看现有的限制。

```
# **pfctl -s memory**
states        hard limit    10000
src-nodes     hard limit    10000
frags         hard limit     1536
tables        hard limit     1000
table-entries hard limit   200000
```

让我们看看每个限制代表什么。

#### frags 限制

当 PF 收到一个分段数据包时，它会保留这个片段并等待该数据包的其他片段到达。一旦它收集到所有片段，它就会重新组装这个片段并处理它。`frags`限制控制了一次性等待重新组装的包片段的数量。（你不应该需要更改这个设置。）

要查看 PF 处理的总片段数以及每秒到达的片段数，使用`pfctl -s info`并查看计数器部分。

```
# **pfctl -s info**
…
  fragment                             368            0.0/s
…
```

这个主机已经在互联网数据中心裸露放置了三个月，只收到了 368 个片段。我不需要增加 PF 的片段内存，当然也不希望降低限制，以防突然收到大量片段。

如果你怀疑有片段流入，运行`systat pf`以持续更新 PF 统计计数器。

#### src-nodes 限制

PF 可以跟踪每个源地址的状态数量。你可能想限制每个客户端对特定服务器的连接数，比如 10 个连接。这个连接限制包括正在建立和仍在等待完成的连接。以下是一个此类规则的示例：

```
pass in proto tcp to $webserver port 80 keep state(max-src-states 10)
```

PF 的负载均衡器功能使用`src-nodes`通过`sticky-address`和`source-track`选项帮助跟踪哪些客户端连接到哪些服务器。

如果你使用这些功能，并且认为你可能会超出源节点，使用`pfctl -s Sources`来检查使用情况。

#### states 限制

`states`限制控制了状态检查列表中可以有多少条目。默认的 10,000 对于大多数环境来说是足够的。

你可以使用`pfctl -s info`查看当前的使用情况。

```
# **pfctl -s info**
Status: Enabled for 1 days 18:01:06              Debug: err
State Table                          Total             Rate
  current entries                       30
  searches                        54510751            6.3/s
  inserts                          2459724            0.3/s
  removals                         2459694            0.3/s
…
```

### 注意

我需要多次更改状态表。每次都是因为一个编写奇特的程序，要求客户端对单个 TCP/IP 端口进行数十次连接。我确信应用程序开发者有他们这样做的原因（可能的原因包括无知和恶意）。乘以数千个同时在线用户，这就变成了很多状态。由于我无法告诉开发者像普通人一样编写应用程序，我不得不调整状态表。

如果你怀疑状态表存在问题，请使用`systat pf`和/或`systat states`来实时查看状态活动。

#### 表和表条目限制

`tables`和`table-entries`限制控制 PF 可以创建多少个表，以及单个表中可以有多少条目。我从未需要调整这些，我建议如果你的过滤规则需要超过 1000 个表，你也许应该重新考虑你的设计。一个表可能需要存储超过 10 万个地址，但这种情况在当今非常少见。

#### 设置限制

要更改限制，请使用`set limit`，限制的名称和新的值。以下是如何将默认状态表大小加倍的方法：

```
set limit states 20000
```

再次强调，不要轻易更改这些默认设置。只有在现有限制导致特定问题时才增加它们。而且不要降低它们，否则你将无法为问题和高峰期做好准备。

### 设置优化选项

PF 包含各种超时设置，默认值适用于现代互联网。某些环境，如卫星上行链路，可能需要稍微不同的超时值。

你可以使用`set optimization`来调整 PF 的超时时间。（这个名字是 PF 早期时代的遗留物，但一直沿用至今。）这有四个值：

> **`normal`**
> 
> `normal`优化是默认设置。如果你没有指定优化，则使用标准超时时间。
> 
> **`conservative`**
> 
> `conservative`优化适用于你绝对不希望超时连接的环境。（状态表条目将保留更长时间。）此设置使用更多的内存和处理器时间——在繁忙的网络中可能更多。我使用它来安抚那些不太关心购买更多硬件，而更关心由于某些高管空闲连接超时而可能引起的会议的工业网络管理员。
> 
> **`high-latency`**
> 
> 如果你通过卫星上行链路或信鸽连接，请使用`high-latency`优化。
> 
> **`aggressive`**
> 
> 如果你有一个繁忙的防火墙，有很多连接进出，你可能尝试使用`aggressive`优化。这会更快地超时空闲连接，减少内存和处理器使用。许多人报告说，在他们的环境中`aggressive`超时工作得非常好，但如果低超时时间给你带来麻烦，请将其关闭。

通过使用`set optimization`和优化名称来配置这些设置。

```
set optimization conservative
```

### 设置跳过选项

你可以告诉 PF 不要管理一个接口。默认情况下，它会监视所有接口，但有些接口实际上并不需要过滤。你的回环接口`lo0`只从本地机器传递流量到自身。在`lo0`上进行数据包过滤是一个有趣的教育练习，但在生产环境中并不十分有用。

```
set skip on lo0
```

你也可以指定多个要跳过的接口。

```
set skip on {lo0 fxp0 fxp1}
```

在主干下的物理接口上跳过过滤，而选择在主干本身上进行过滤，这种情况相当常见。

这将帮助你开始学习数据包过滤。如果你有一个功能简单的单一服务器，你可以使用本章中介绍的技术相当好地保护它。但 PF 的功能远不止我们在这里讨论的，比如控制带宽和让应用程序动态更改规则。在下一章中，我们将触及 PF 的一些更高级功能。

* * *

^([45]) 对不起，猫和象，你们要找到自己的居住地。

^([46]) 明显地借鉴自 Henning Brauer。幸运的是，他现在对这个书已经厌倦了，不会注意到这一点。

^([47]) 请注意，如果 PF 在数据包被丢弃时提供了一个侮辱客户的功能，类似于 sudo，我可能需要改变我的推荐。但这不是 PF 的问题，而是底层网络协议的缺陷。
