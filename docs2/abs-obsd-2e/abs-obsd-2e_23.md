## 第二十三章. 定制 OpenBSD

*定制安装*

*使用文件和 DHCP，*

*然后无盘运行。*

![图片](http://atomoreilly.com/source/nostarch/images/1616079.png) 这章介绍了使用 OpenBSD 来自定义自己的不同方法，以及如何在非标准情况下安装 OpenBSD 和调试系统问题。我们将要解决的第一项任务是无盘安装。无盘系统通常用于在不连接任何安装媒体的情况下安装 OpenBSD，但它们也可以用于在没有硬盘的情况下运行系统。接下来，我们将创建一个 USB 闪存驱动器，用作 OpenBSD 安装媒体。最后，我们将介绍各种自定义 OpenBSD 安装和升级过程的方法。

所有这些任务都假设你已经有一个运行着你想要定制的版本的 OpenBSD 机器。只要虚拟机软件有必要的支持，你可以使用虚拟机来完成这些任务之一。由于虚拟化是一个常见的选项，让我们先来解决这个问题。

## 虚拟化 OpenBSD

OpenBSD 的开发者对虚拟化非常明确。OpenBSD 是为真实硬件编写的。虚拟硬件不是真实硬件。虽然它可以非常相似，但并不完全相同。

这种方法有几个影响，其中最成问题的是，并非所有虚拟化软件都能运行 OpenBSD。当我写这篇文章时，Oracle 的 VirtualBox 无法干净地运行 i386 或 amd64 版本的 OpenBSD。（有些人报告说能够启动某些版本的 VirtualBox 和/或 OpenBSD，但 OpenBSD 软件到处崩溃。）这不是 OpenBSD 的 bug。VirtualBox 没有充分模拟真实硬件。

话虽如此，OpenBSD 在某些虚拟机上运行得很好。VMware 运行得足够好，以至于 OpenBSD 包括针对 VMware 集成的特定驱动程序，包括内核中的 VMware Tools 驱动程序。KVM 虚拟化也工作，尽管 KVM 需要根据你使用的 KVM 和 OpenBSD 的确切组合进行一些调整。微软的虚拟化大部分工作，尽管 Virtual PC 有一些商业动机的限制。

虚拟化的主要问题是，虚拟化平台的妥协会自动给入侵者提供对所有虚拟机的硬件级访问权限，而 OpenBSD 不可能保护你免受这种攻击。实际上，没有任何操作系统可以做到。当任何脚本小子都能妥协底层的虚拟化服务器时，在 OpenBSD 上运行数据库对你没有任何好处。

根据我的经验，OpenBSD 虚拟机非常适合实验和参考。我使用它们来记录这本书的安装过程，并且在将它们部署到生产之前，我总是在虚拟机上测试软件配置。（虚拟化的真正好处可能就是不再有任何借口不测试更改。）但是，当我需要一个真正安全的服务器时，我会将 OpenBSD 安装在真实硬件上。

### 注意

如果你想在 OpenBSD 上运行虚拟机，你可以在软件包集合中找到 `qemu`、`bochs`、`dosbox` 和其他软件包。检查 */usr/ports/emulators* 以获取其他选项。

## 无盘安装

不使用本地媒体将空白系统引导到 OpenBSD 安装程序可以节省你的时间和精力。许多现代硬件都没有配备 CD 或软盘驱动器。当然，你可以临时添加一个 CD 驱动器，但如果你要安装大量的 OpenBSD 机器，那只是个麻烦。

你也可以使用网络引导在缺少已安装操作系统的硬件上引导 OpenBSD，或者在与你计划覆盖的不同操作系统上。这个过程被称为 *pxebooting*，或 *diskless* 操作。无盘系统可以有磁盘——只是它们不使用它们来引导操作系统。

如果你之前从未使用过无盘系统，你的第一次尝试可能会让你头疼。设置你的第一个无盘环境可能会很棘手，这会教你许多关于你的操作系统和硬件的未知知识。但沿途测试一切，仔细阅读错误信息，很快你就会 wonder why you thought this was hard.

### 注意

我将介绍在 amd64 和 i386 硬件上的无盘安装。其他平台可能有不同的要求，可能非常不同。阅读 `diskless(8)` 手册页以获取你特定架构的平台概述。

无盘系统之所以能够工作，是因为计算机不需要硬盘来运行。它需要一个操作系统。存储计算机操作系统的最简单方法是在本地硬盘上，但足够智能的网络卡可以使用 DHCP 提供的信息找到初始引导加载程序。

所有 amd64 和现代 i386 硬件都使用 Intel 的预引导执行环境 (PXE，发音为“pixie”）。DHCP 服务器告诉网卡文件的名称和可以找到该文件的 IP 地址，服务器通过 TFTP 获取该文件。这个文件通常被称为 *pxeboot*，但 *pxeboot* 文件在不同的操作系统之间可能会有很大的差异。OpenBSD 的 *pxeboot* 文件可能无法引导 FreeBSD 系统，更不用说微软的任何系统了。它是针对每个操作系统的。

一旦计算机加载了 *pxeboot*，它就会回到 TFTP 服务器去寻找适当的内核。一个 OpenBSD *pxeboot* 会寻找一个名为 *bsd* 的文件，假设它是一个内核，将内核加载到内存中，并启动它。要安装 OpenBSD，你需要加载安装内核文件 *bsd.rd*，这可以自动完成。

### 无盘硬件

在无盘系统上安装的 OpenBSD 系统必须足够聪明，能够在网络上找到其引导加载程序和操作系统，否则它们将无法启动。过去几年内制造的任何机器都使用 PXE。

你可能已经看到过一台计算机多次尝试从网络启动，对于大多数人来说，这些 BIOS 信息只是他们不断忘记禁用的烦恼。对于无盘安装，你需要确保该功能是开启的。

要启用 PXE，请启动硬件并进入 BIOS 设置。在 BIOS 中，你应该找到一个设置设备启动顺序的选项。如果机器支持 PXE，其中之一将是通过网络启动。启用该选项并查看是否可行。当你在 BIOS 中时，记下你的网络卡的 MAC 地址。你的 DHCP 服务器将需要它。如果你的 BIOS 默认使用统一可扩展固件接口 (UEFI)，请禁用它。

保存你的更改并退出。现在你的硬件应该已经准备好了。让我们准备服务器。

### DHCP 服务器设置

DHCP 不仅仅是分发 IP 地址和网络配置的方式。DHCP 服务器可以告诉网络感知的电话在哪里找到它们的配置，服务器硬件在哪里找到它的操作系统，打印机在哪里找到它们的打印服务器，等等。无盘安装使用 DHCP 向无盘服务器提供 *pxeboot* 文件的存储位置。

#### 每个主机或每个网络的配置

DHCP 期望通过网络或主机配置主机。当 DHCP 服务器收到 DHCP 请求时，它知道主机所在的网络地址和主机的 MAC 地址。根据这些信息，DHCP 服务器必须决定向主机提供哪种配置。这意味着你可以配置你的 DHCP 服务器，以便给定网络上的任何主机都被告知安装 OpenBSD，或者你可以给出你将要安装的机器的 MAC 地址，并告诉 DHCP 服务器只在该机器上启动安装。

由于我经常安装机器，我通常设置一个小型 VLAN，任何连接到网络的机器都会被告知安装 OpenBSD。这样，把他们的笔记本电脑插入我办公室随机以太网线的员工就可以免费升级操作系统。如果你只是偶尔安装机器，并且控制 DHCP 服务器，配置 DHCP 服务器告诉具有特定 MAC 地址的主机安装 OpenBSD 非常容易。

DHCP 服务器需要告诉客户端 PXE 启动文件的存储位置，这给客户端足够的智能来找到可引导的内核。这就像磁盘上的引导加载器一样，只不过 PXE 启动文件是与网络通信。OpenBSD 的 i386 和 amd64 平台包括文件 */usr/mdec/pxeboot*，就是为了这个目的。

使用 `filename` 选项给出 PXE 启动文件的名称，然后使用 `next-server` 选项指定客户端可以获取文件的 TFTP 服务器的 IP 地址。此示例告诉 DHCP 客户端从 IP 地址为 192.0.2.34 的服务器加载文件 *pxeboot*：

```
filename "pxeboot";
next-server 192.0.2.34;
```

根据你是否有一个安装网络或你的 DHCP 服务器设置为特定的 MAC 地址，放置这些语句。

#### 每个网络的配置

如果您想让网络上的所有主机都能接收到 OpenBSD 安装的 PXE 启动文件，请在`subnet`段落中放置`filename`和`next-server`选项，如下所示：

```
option  domain-name "michaelwlucas.com";
option  domain-name-servers 192.0.2.1;
subnet 192.0.2.0 netmask 255.255.255.0 {
        option routers 192.0.2.1;
        range 192.0.2.10 192.0.2.15;
        filename "pxeboot";
        next-server 192.0.2.34;
}
```

网络上任何在启动时发出 DHCP 请求的主机都会学习到获取 PXE 启动文件的位置。

#### 每台机器的配置

如果您已经在第十六章中讨论的 DHCP 配置中将机器的 MAC 地址硬编码，您可以向该主机提供 PXE 启动信息。

```
subnet 192.0.2.0 netmask 255.255.255.0 {
…
    host installationtarget {
        hardware ethernet 02:03:04:05:06:07;
        filename "pxeboot";
        next-server 192.0.2.34; }
    }
```

在此子网上启动时发出 PXE 请求的机器只有在它们具有 MAC 地址 02:03:04:05:06:07 时才能获得 PXE 启动文件的位置。

决定您希望您的 DHCP 服务器如何行为，并做出类似的配置更改。

现在让我们看看 TFTP 服务器。

### TFTP 服务器设置

下一个任务是使 OpenBSD 特定的启动文件在您的 TFTP 服务器上可用。至少，您需要*pxeboot*文件和一个内核，但添加一个*boot.conf*文件将简化您的工作。

OpenBSD 在`/usr/mdec/`中包含一个特定于架构的*pxeboot*文件。如果您正在安装 i386 机器，从现有的 i386 安装中获取此文件和`/bsd.rd`。如果您正在安装 amd64 硬件，从现有的 amd64 系统中获取*pxeboot*和`/bsd.rd`。将它们复制到 TFTP 服务器的根目录，并验证它们是否对所有用户可读。

*pxeboot*告诉机器查找标准内核*/bsd*，而不是安装内核*/bsd.rd*。当*pxeboot*加载完成后，它看起来就像标准的 OpenBSD 引导加载程序。您可以像在第五章中描述的那样中断引导，并选择不同的内核，但*pxeboot*也识别`/etc/boot.conf`。

要告诉*pxeboot*加载不同的内核，在您的 TFTP 服务器根目录中创建一个*etc*目录，然后在其中创建*boot.conf*文件。这个新的*boot.conf*文件与`/etc/boot.conf`具有完全相同的语法，因此您可以进行如下一行条目：

```
boot bsd.rd
```

您可以包括额外的启动选项，例如设置串行控制台。

### 完成无盘安装

一旦您有了 DHCP 和 TFTP，打开安装目标。您应该看到网卡发出 DHCP 请求，获取 IP 地址，并通过 TFTP 获取*pxeboot*。然后您应该看到 OpenBSD 引导加载程序加载安装的*bsd.rd*。最后，您应该获得 OpenBSD 安装脚本。

如果你没有获取到安装程序，请退一步。网卡是否从 DHCP 获取地址？如果不是，检查你的布线和 DHCP 服务器配置。如果你获取了 IP 地址，但不能获取*pxeboot*，请确保你在 DHCP 配置的正确部分放置了`filename`和`next-server`语句，并验证你没有包过滤器阻止对 TFTP 服务器的访问。尝试从不同的 TFTP 客户端获取这些文件，以确保 TFTP 服务器工作正常。如果安装目标部分启动了 OpenBSD，但没有激活安装程序，请确保你有指向*bsd.rd*而不是*bsd*的*etc/boot.conf*条目。

在这个阶段，你应该能够按照第二章和第三章中描述的方法正常安装 OpenBSD。但是，如果你想在没有硬盘的情况下运行完整的 OpenBSD 系统呢？这就是无盘操作的作用所在。

## 运行无盘系统

如果你管理许多计算机，你可能理解到移动部件会带来麻烦。特别是旋转硬盘，这只是一个非常糟糕的想法。

尝试这样做：如果你有一间满是相同机器的房间，尝试通过不使用硬盘来简化维护。这个组中的每台机器将使用通过 NFS 挂载的根目录和文件系统，而不是本地存储。你仍然需要数据存储，但可以使用一个中央高可用磁盘阵列、闪存驱动器或一些其他机制，其可靠性比最低标准的硬盘更好。

你可以将无盘安装过程扩展到在没有本地硬盘的情况下以全多用户模式运行 OpenBSD。你的服务器将需要三个额外的服务来支持完全无盘客户端：`rarpd(8)`、`bootparamd(8)`和 NFS。（只有无盘客户端需要`rarpd`和`bootparamd`。）

### 使用`rarpd(8)`进行反向 ARP

在标准的 ARP 请求中，客户端知道一个 IP 地址，并想要获取相应的 MAC 地址。对于反向 ARP，客户端知道一个 MAC 地址，并想要知道相应的 IP 地址。OpenBSD 需要在无盘启动过程中获取反向 ARP，它使用`rarpd(8)`为其他主机提供反向 ARP 服务。

`rarpd`使用`/etc/ethers`作为以太网地址和主机名的表格。每个无盘客户端需要一个类似于以下的`/etc/ethers`条目：

```
00:50:56:00:01:01       gill.blackhelicopters.org
```

这个条目意味着 MAC 地址为 00:50:56:00:01:01 的主机的主机名为*gill.blackhelicopters.org*。`rarpd`服务器必须能够将主机名解析为 IP 地址，无论是在 DNS 中还是在`/etc/hosts`中。

现在决定你想要在哪个网络接口上运行`rarpd`。如果你的服务器只有一个网络接口，那么就使用它。然而，如果你有多个网络接口，可能只监听一个接口是有意义的。

要使用特定的接口，请使用接口名称作为命令行参数；否则，使用 `-a` 以监听所有网络接口。例如，此 *rc.conf.local* 条目指示 `rarpd` 仅在接口 `em0` 上监听：

```
rarpd_flags="em0"
```

使用 */etc/rc.d/rarpd* 启动 `rarpd`，然后继续 `bootparamd`。

### 运行 bootparamd(8)

启动参数守护进程 `bootparamd` 告诉无盘 OpenBSD 机器其根文件系统的位置。当启动参数请求到达服务器时，`bootparamd` 会检查 */etc/bootparams* 文件以查找匹配的配置，并将其返回给客户端。

*/etc/bootparams* 中的条目给出一个主机名，后跟字符串 `root=`，一个 NFS 服务器，以及客户端根目录存储的目录。

```
gill.blackhelicopters.org root=192.0.2.34:/var/diskless/client1
```

在此示例中，主机 *gill.blackhelicopters.org* 将使用来自 IP 地址 192.0.2.34 的服务器的 NFS 根目录，在目录 */var/diskless/client1* 中。

对于几乎所有环境，您可以在没有任何命令行选项的情况下运行 `bootparamd`。像这样在 *rc.conf.local* 中启用它：

```
bootparamd_flags=""
```

启动 `bootparamd`。现在是你处理你的 NFS 服务器的时候了。

### 设置 NFS 根目录

多用户 OpenBSD 系统需要一个用户空间。没有本地磁盘，您需要创建一个 OpenBSD 用户空间。可以将 NFS 服务器的根目录导出以用作无盘客户端的根目录，但这不仅是不安全的，而且也是损坏 NFS 服务器的良好方式。为您的无盘机器创建一个单独的用户空间。

#### 导出根目录

您必须将用户空间的根目录导出到无盘机器。例如，以下是一个 */etc/exports* 行，它将目录 */var/diskless/client1* 共享到 IP 地址 192.0.2.37：

```
/var/diskless/client1 -maproot=root 192.0.2.37
```

注意这里的 `-maproot` 选项。无盘客户端期望能够以 root 用户身份写入和拥有文件。此 `-maproot` 条目将客户端的 UID 0（root）映射到 NFS 服务器的 root 账户。您还可以为无盘客户端的 root 账户设置一个单独的用户，将客户端的 root 账户映射到该新账户，并将无盘用户空间中所有文件的拥有权更改为该 root 账户。但是，由于这是您的第一个无盘主机，我们将从基本开始。

#### 填充无盘用户空间

安装最小用户空间的最简单方法是提取您选择的 OpenBSD 版本的 *etcXX.tgz* 和 *baseXX.tgz* 文件集到 NFS 根目录。在以下示例中，我已经将这些文件集复制到 */tmp*，并使用它们在 */var/diskless/client1* 中创建用户空间。

```
# **cd /var/diskless/client1**
# **tar -xzpf /tmp/etc53.tgz**
# **tar -xzpf /tmp/base53.tgz**
```

注意在 `tar` 命令中使用 `-p` 标志，以保留提取文件的原始权限。

无盘客户端还需要设备节点。进入新用户空间的 *dev* 目录并创建它们。

```
# **cd dev**
# **./MAKEDEV all**
```

虽然 `bootparamd` 告诉内核文件系统的根位置，但用户空间程序期望读取 */etc/fstab* 来获取该信息。创建一个 */etc/fstab* 文件，将根目录指向您的 NFS 共享。

```
192.0.2.34:/var/diskless/client1 / nfs rw 0 0
```

您还可以在此处添加任何其他所需的 NFS 挂载目录。

这应该就是您需要的一切。

### 开机！

一旦您有一个基本用户空间、设备节点和文件系统表，您就可以开启无盘节点，它应该会启动。如果它没有启动到登录提示符，请阅读控制台错误消息。通常，它们非常清晰。

由于您绕过了 OpenBSD 安装程序，目前还没有 root 密码或用户账户。立即以 root 身份登录并更改 root 密码，然后设置一个普通用户账户。

对于您的第一个无盘设置，一旦您有一个工作的用户空间，立即备份它。即使是一个包含整个用户空间的 tar 文件也将非常有用。在您试图将一切设置得尽可能完美时，您可能会多次弄乱无盘用户空间，能够将整个用户空间全部删除并从备份文件中恢复是非常宝贵的。

一旦您有一个基本系统运行，就可以扩展它。根据需要添加额外的文件集，设置更多用户，添加软件包，并为您的用户部署。

恭喜您，现在您已经成为 OpenBSD 用户的尖端用户。

## USB 安装介质

对于许多人来说，烧录 CD 来安装操作系统似乎是一种浪费。他们更喜欢将镜像写入 USB 闪存驱动器并从那里安装。OpenBSD 不提供这样的镜像，但如果您愿意做一些额外的工作，您可以创建一个可引导的 USB 设备，用于在目标硬件上安装。

官方建议是在 USB 设备上安装 OpenBSD，将*bsd.rd*文件和文件集复制到该设备，并使用它来安装新硬件。OpenBSD 安装程序允许您选择目标硬盘驱动器。在安装程序中选择 USB 设备，OpenBSD 将像对待任何其他数据存储设备一样安装到 USB 上。但您如何在最初不烧录 CD 的情况下在 USB 设备上安装 OpenBSD 呢？有几种方法可以解决这个问题，包括本章中已经介绍的一些方法。

### 使用虚拟机

您的第一个选择是在虚拟机中执行 USB 安装。许多桌面虚拟机软件包允许您将物理 USB 端口连接到虚拟机。 (OpenBSD 的虚拟化选项在虚拟化 OpenBSD 中讨论。)

如果您有运行 OpenBSD 并支持 USB 的虚拟化软件，请选择此选项。

### 运行无盘安装

您的第二个选择是运行无盘安装。大多数嵌入在廉价家用硬件中的 DHCP 服务器都会允许您向客户端发送一个文件名和一个 TFTP 服务器地址。如果您的服务器不支持，您可以为任何平台获取合适的 DHCP 服务器。您几乎可以在任何操作系统上找到免费提供的 TFTP 服务器。

使用 USB 驱动器启动安装目标，但加载 *bsd.rd* 内核。你现在在目标系统上运行了 OpenBSD 安装程序，并且有一个可以放在口袋里、几乎在任何地方都可以运行的 OpenBSD 系统。如果你已经在具有正确架构和 USB 插座的设备上运行了 OpenBSD，那就更容易了：从适当的 *bsd.rd* 启动系统，选择 `disk` 选项，并将安装程序指向本地目录中的集合。

### 转换 ISO 镜像

作为一种不那么正式的方法，你可以找到将 ISO 镜像转换为可启动 USB 镜像的软件。我在 Windows 上使用了 Rufus (*[`rufus.akeo.ie/`](http://rufus.akeo.ie/)*)，在其他类 Unix 系统上使用了 UNetbootin (*[`unetbootin.sourceforge.net/`](http://unetbootin.sourceforge.net/)*)。这种方法可能有效，但绝对不是 OpenBSD 推荐的。

## 自定义 OpenBSD 安装

我们中的许多人安装机器时都会遵循一系列步骤。所有刚刚安装的特定操作系统版本的宿主机都有一个共同的 SSH 服务器配置。我的机器都安装了 `tcsh` 并连接到中央认证系统。你可能有自己的列表。这些任务可以在安装后手动完成，但让 OpenBSD 在安装过程中为你完成这些任务会容易得多。

安装可以通过在安装过程中添加文件或在安装后运行命令来自定义。

### 自定义文件集

自定义文件集包括你想要复制到新安装中的文件。我使用自定义文件集来安装默认的 */etc/sudoers*、SSH 服务器配置、我公司的默认 *pf.conf* 以及类似文件。作为主要系统管理员，我还包括我的主目录中的 dotfiles 和其他个人化细节，以使我的生活更轻松。有些人包括多个主目录，包括 SSH 的 *authorized_keys* 文件。

将这些文件打包成一个 *siteXX.tgz* 文件，安装程序可以在新安装的根目录中提取它。（请确保将 *XX* 替换为你要安装的 OpenBSD 版本；例如，为 OpenBSD 5.4 命名一个 *site54.tgz* 文件。）

首先，安装一个与你想要定制的版本和平台完全相同的 OpenBSD 机器。进行更改并将你的文件添加到这个系统中，验证这个模板系统是否完全符合你的需求，然后将更改后的文件复制到 tar 文件中。

### 注意

你可以创建一个目录层次结构并将你想要的文件复制到其中，但我发现这样做更容易出错。一个小型虚拟机可以让你更可靠地构建 *siteXX.tgz* 文件。

以下示例创建了一个包含一个文件 */etc/ssh/sshd_config* 的 *site54.tar* 文件。请注意，我首先创建了一个普通的 tar 文件。由于我无法轻松地将文件添加到压缩的 tar 文件中，我需要在文件完成后对其进行压缩。

```
# **cd /**
# **tar -cf site54.tar etc/ssh/sshd_config**
```

现在我有了初始文件，我可以添加额外的文件。我已经对系统上的几个文件进行了定制，并添加了新的文件，所有这些都添加到 *site54.tar* 文件中。`-r` 标志告诉 `tar` 将文件添加到归档中。

```
# **tar -rf site54.tar etc/sudoers**
# **tar -rf site54.tar etc/pf/mgmt-hosts.conf**
# **tar -rf site54.tar etc/pf.conf**
```

下面是如何压缩 tar 文件的方法：

```
# **gzip site54.tar**
# **mv site54.tar.gz site54.tgz**
```

我已经构建了自己的 OpenBSD 定制版本，因此我有一个包含所有发布文件的本地 FTP 服务器。如果你使用的是官方 OpenBSD 发布版，但安装了足够多的 OpenBSD 机器，需要创建一个 *siteXX.tgz* 文件，你可以将官方发布版复制到本地 FTP 或 HTTP 镜像。将你的 *siteXX.tgz* 文件复制到这个目录，并更新 *index.txt* 文件。

```
# **ls -l > index.txt**
```

现在开始你的安装。告诉安装程序使用你的本地发布镜像而不是官方 OpenBSD 镜像。你应该能看到以下集合：

```
Select sets by entering a set name, a file name pattern or 'all'. De-select
sets by prepending a '-' to the set name, file name pattern or 'all'. Selected
sets are labelled '[X]'.
    [X] bsd           [X] etc54.tgz     [X] xbase54.tgz   [X] xserv54.tgz
    [X] bsd.rd        [X] comp54.tgz    [X] xetc54.tgz    [ ] site54.tgz
    [ ] bsd.mp        [X] man54.tgz     [X] xshare54.tgz
    [X] base54.tgz    [X] game54.tgz    [X] xfont54.tgz
Set name(s)? (or 'abort' or 'done') [done] **site52.tgz**
```

你的 *site54.tgz* 文件现在应该作为一个文件集可用。添加它，因为安装程序不会自动包含它。一旦安装完成，你应该能在新系统中找到你定制的和添加的文件。

### 安装后 Shell 脚本

一些任务可以通过复制文件来完成，但这很麻烦。例如，我想在我的所有 OpenBSD 服务器上安装 shell `tcsh`。我可以在 `tcsh` 软件包中放置所有文件，以及 */var/db/pkg/tcsh* 的内容，到 *siteXX.tgz* 中，但我知道我可能会以某种方式搞砸。在安装后运行 `pkg_add tcsh` 会容易得多，让 OpenBSD 做它应该做的事情。这就是 `install.site` 脚本的作用所在。

在完成安装但在给出最终命令提示之前，OpenBSD 会检查 */install.site* 文件。如果此文件存在，安装程序会运行它。脚本在 `chroot` 中运行到新安装的系统，所以你不需要担心更改任何路径。然而，脚本需要在最小内核上运行，所以最好在第一次真实启动之前等待低级内核调整。

这里是一个示例 `install.site` 脚本，它安装了两个软件包 `tcsh` 和 `python`：

```
#**/bin/sh**
export PKG_PATH=ftp://ftp13.usa.openbsd.org/pub/OpenBSD/snapshots/packages/i386/
pkg_add -v tcsh
pkg_add -v python-2.7.3p1
```

当处理 `install.site` 脚本时，如果软件包的名称可能不明确，请确保给出完整的软件包名称。只有一个 `tcsh` 软件包，但 Python 有几个版本。我指定了完整的软件包名称，而不是使用普通的 `python`。

还要注意，当你在一个包含完整用户空间的 `chroot` 中运行时，那个用户空间并没有完全初始化。当进入 `chroot` 时，OpenBSD 不会在该 `chroot` 中进行完整的多用户启动。环境大致相当于单用户模式。`install.site` 脚本不是你初始化数据库的地方。

当你有准备好的真实用户空间时，要自动在系统第一次真实启动时运行命令，请将命令追加到 */etc/rc.firsttime* 文件中。此文件在安装后的第一次系统启动时运行一次，然后删除自己。

## 定制升级

OpenBSD 允许你在二进制升级期间使用自定义文件集和 shell 脚本。如果你有很多机器需要升级，运行这些脚本来确保你的系统在升级后与升级前尽可能相同。我强烈建议在升级期间自动化已知的变化。

*siteXX.tgz* 文件在升级和安装时工作方式完全相同。将你想要在这个系统上使用的文件放入 *siteXX.tgz* 中，安装程序在安装升级文件时应该会复制这些文件到系统中。然而，与 `install.site` 不同，升级软件会查找脚本 `upgrade.site`。在升级过程中，任何 *install.site* 文件都会被忽略，因此你可以使用相同的 *siteXX.tgz* 进行升级和新的安装。

我发现 `upgrade.site` 脚本与该版本的 *OpenBSD Upgrade Guide* 结合使用特别有用。*升级指南* 包含在升级过程中必须执行的任务，其中许多非常适合脚本化。例如，删除新 OpenBSD 版本中删除的文件、程序和库的常见任务可以轻松添加到 `upgrade.site`。

关于 `upgrade.site` 的一个方便之处是，在运行升级之前，你可以将脚本复制到目标机器上。它不需要是 *siteXX.tgz* 的一部分。话虽如此，我不建议在 `upgrade.site` 中运行 `pkg_add -u`。虽然自动升级所有软件包的想法听起来不错，但请记住，你正在运行在一个有限的内核上，用户空间还没有完全初始化。让 `upgrade.site` 脚本添加任何需要在完全多用户系统上运行的命令到 */etc/rc.firsttime*，这样它们就会在系统第一次启动时运行。

通过本章中的提示，你可以根据需要自定义 OpenBSD。并且，通过本书中的信息，你应该知道 OpenBSD 在你的网络中是如何定位的。记住，他们确实是在针对你，你将实现实用的偏执。
