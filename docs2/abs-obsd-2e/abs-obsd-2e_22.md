## 第二十二章。高级 PF

*Office net 似乎很慢*

*感谢地下电影交换*。

*让我们立刻停止它！*

![图片](img/httpatomoreillycomsourcenostarchimages1616079.png) 上一章介绍了 OpenBSD 数据包过滤器 `pf(4)` 的基础知识。但是，正如我提到的，PF 可以以各种方式操作数据包，而不仅仅是允许或拒绝它们，包括以下内容：

+   您可以通过外部软件，如 `dhcpd(8)` 或 `spamd(8)`，动态更改要传递或阻止的地址列表。

+   您可以动态创建子规则集，这样您可以为麻烦的协议设置非常具体的规则，而不会允许不必要的更多访问。

+   PF 可以提供 NAT，让您在没有公共 IP 地址的情况下为整个网络提供互联网访问。

+   您可以任意重定向传入流量，并控制服务将使用的带宽量。

+   您可以使用 PF 记录。

本章涵盖了这些主题的每个方面。

## 使用表格进行数据包过滤

*表格* 是 IPv4 和/或 IPv6 地址的列表，就像列表一样。然而，表格比列表更快，并且使用的内存更少。如果您只有几个地址，使用列表是可以的，但一旦地址超过几个，请使用表格。

有趣的是，您可以在不重新加载过滤器规则的情况下编辑表格，并且有几个程序使用此功能来动态更改服务器的行为。有些人将恶意软件感染的计算机列表加载到表格中，以阻止这些主机，或者使用外部程序生成此类列表。（“你连续四次尝试发送无效的电子邮件？再见！”）表格可以永久保存在外部文件中，或者您可以将其视为临时文件。这是您的选择。

### 定义表格

您可以使用 `pfctl` 完全创建和操作表格，但这不如在 *pf.conf* 中定义表格常见。在尖括号内给出表格名称，并在花括号内用逗号分隔的初始成员提供。

```
table <management> {192.0.2.5, 192.0.2.8, 192.0.2.81}
```

在这种情况下，`management` 表格包含三个 IP 地址。

如果您想定义 `pfctl` 无法更改的表格，请使用 `const` 关键字。以下示例定义了一个用于私有（RFC 1918）地址空间的表格。这个地址空间已经定义了多年，所以没有人应该更改它。

```
table <private> const {10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16}
```

如果没有规则引用表格，PF 会将其丢弃。这对于静态规则来说是有意义的，但如果您正在使用锚点（本章后面将讨论），您可能希望保留表格以备规则再次出现。使用 `persist` 关键字使表格即使在规则未使用的情况下也能保留。

```
table <scumbags> persist
```

一些表格包含足够的地址，您可能不想在配置中列出它们。为了方便，您可以从文件中填充表格，如下所示：

```
table <fullbogons> persist file "/etc/fullbogons.txt"
```

我有一个每天更新 *fullbogons.txt* 文件的脚本。(*Bogons* 是不应该出现在全球互联网路由表中的地址。)

bogons 列表包括私有地址空间、为实验或文档保留的地址、未分配给任何网络的地址，以及分配给其他奇异用途的地址。几个组织生产和更新完整的 bogon 列表。我在我的边界处使用 bogons 列表来剔除明显的垃圾。文件看起来像这样：

```
# last updated 1352220481 (Tue Nov  6 16:48:01 2012 GMT)
0.0.0.0/8
10.0.0.0/8
14.1.96.0/19
…
```

你可以包括单个地址，但不能包括点分十进制子网掩码。你可以使用主机名，但在`pfctl`将规则馈送到内核之前，它会检查主机的 IP 地址或地址。这意味着如果主机在加载规则后更改其 IP 地址，PF 将不知道新的 IP 地址。

### 使用表格

在防火墙规则中使用表格的方式，就像使用地址或列表一样。

```
block in on egress from <fullbogons> to any
```

你可以在列表中放入多个表格。

```
block in on egress from {<fullbogons>, <scumbags>} to any
```

是的，列表比表格慢。但如果你以不同的方式维护两个不同的表格，你可能希望这些表格是分开的。而且如果两个项目的列表触发了防火墙耗尽，你真的需要更多的硬件。

### 查看表格

表格有自己的`pfctl`命令子集。要查看内核中有哪些表格，请使用`pfctl -s Tables`。（注意`Tables`以大写`T`开头。）

```
# **pfctl -s Tables**
fullbogons
scumbags
```

为什么你需要询问内核它有哪些表格？因为动态规则可以添加和删除表格，如锚点中讨论的那样。

如果你已经知道表格名称，并且想查看表格中的地址，请使用`-t`参数指定表格名称。`-T`参数有几个子命令，就像`-s`一样，但它是用于表格操作的。以下是如何检查`scumbags`表格的内容：

```
# **pfctl -t scumbags -T show**
   157.166.248.10
   157.166.248.11
   157.166.249.10
   157.166.249.11
```

对于许多表格操作（目前包括`add`、`delete`、`replace`和`test`），你可以在`-T`之前添加一个或两个`-v`选项来增加详细程度。如果你同时处理多个地址，增加详细程度会显示命令执行了什么。

### 搜索表格

你可以很容易地查看有四个条目的表格，但如果一个表格有数千个条目，你不会想一页一页地搜索地址。你可以使用`grep(1)`，但这可能会失败，因为一个地址可能是一个看起来完全不同的网络的组成部分。（我确信如果我输入 10.99.61.4，我可以写一个匹配 10.0.0.0/8 的`grep`表达式，但我不想尝试。）你可以测试一个地址，看看它是否在表格中。

```
# **pfctl -t fullbogons -T test 192.0.2.88**
1/1 addresses match.
```

这个地址出现在`fullbogons`表格中。

如果你在一个命令中测试多个地址，请在`-T`之前使用`-v`或`-vv`来查看哪些地址匹配，哪些不匹配。

```
# **pfctl -t scumbags -vvT test 192.0.2.88 198.51.100.90**
1/2 addresses match.
M  192.0.2.88    192.0.0.0/22
198.51.100.90    nomatch
```

使用单个`-v`只显示匹配的地址。

### 更改表格

表格的一个重要特性是你可以动态地更改它们而不需要重新加载防火墙规则。如果你必须向表格中添加一个地址，请使用`-T`的`add`命令。

```
# **pfctl -t scumbags -T add 192.0.2.88**
1/1 addresses added.
```

通过指定子网掩码和单个命令中的多个地址来添加网络。

```
# **pfctl -t scumbags -T add 198.51.100.0/24 2001:db8::/32**
2/2 addresses added.
```

如果你向一个不存在的表格中添加地址，PF 会自动创建该表格（所以现在你知道那个`scumbags`表格是从哪里来的）。

使用`-f`参数将文件中的所有地址添加到表中。

```
# **pfctl -t scumbags -T add -f scumbags.txt**
1/1 addresses added.
```

要删除地址，请使用`delete`命令。

```
# **pfctl -t scumbags -T delete  198.51.100.0/24**
1/1 addresses deleted.
```

要完全从表中删除所有条目，请使用`flush`。

```
# **pfctl -t scumbags -T flush**
6 addresses deleted.
```

如果清空表还不够，并且你想完全从规则中删除它，请使用`kill`。

```
# **pfctl -t scumbags -T kill**
1 table deleted.
```

### 表和自动化

OpenBSD 包括可以算法调整表的软件。在第十六章中，我提到了 DHCP 服务器将租用、废弃和更改的地址分配给表的能力。你可以使用 PF 为每个地址组分配不同的规则。

假设你使用`dhcpd(8)`将所有租用的 IP 地址添加到`leased`表，废弃的地址添加到`abandoned`表，更改的地址添加到`changed`表。拥有正确租用地址的主机可以访问网络，但拥有废弃和更改地址的主机不能。在这里，办公室组中的接口面向本地网络：

```
table <leased> persist
table <abandoned> persist
table <changed> persist
pass in on lan from <leased> to any
block in on lan from {<abandoned>, <changed>} to any
```

如果有人决定将 DHCP 服务器中的地址配置为计算机的静态地址，他们就会自动失去对网络其余部分的访问——问题解决。其他 OpenBSD 软件，如`spamd(8)`，也有类似的功能。

乍一看，这个功能似乎已经准备好与其他程序集成。编写一个解析日志、抓取 IP 地址并将这些地址输入到表中的脚本是相当简单的。几年前，我编写了一个脚本，从 Snort 入侵检测系统中获取警报并自动阻止网络中的攻击者。然而，如果没有仔细和熟练的注意，Snort 会产生许多误报。我的自动阻止脚本非常有效地对我的开发团队发起了拒绝服务攻击。

在自动向 PF 表输入以阻止流量时要小心。很容易损害所需的连接性。

## 使用 NAT

防火墙的一个关键功能是 NAT。使用 NAT 为多台机器提供 IPv4 网络访问，但只显示一个公共 IPv4 地址。一些公司通过 NAT 为成千上万台机器提供互联网访问。

NAT 就像用骨头熬汤——它拉伸了你所拥有的，使其覆盖更多。有些协议与 NAT 配合得不好。它确实会让人试图通过 IP 地址限制访问的人感到困惑。它还可能给网络取证和故障排除人员带来噩梦。但 NAT 是解决 IPv4 地址短缺的首选方案。

NAT**不是**作为安全机制设计的。它有一些小的安全优势，但不足以抵御今天的网络威胁。依赖 NAT 进行安全就像在酒吧喝完一杯黑咖啡后追赶 10 个锅炉工回家一样。你可能侥幸逃脱，但这完全靠运气。

IPv6 最初设计时没有 NAT，但几年后由于市场需求而被迫加入。 (IPv4 最初也是没有 NAT 设计的，所以 IPv6 只是遵循了传统。) 注意，一个 IPv6 地址——即使是全球唯一的 IPv6 地址——并不意味着或甚至暗示“可以从世界上任何地方访问。” 你可以在没有 NAT 的情况下实现稳固的网络隔离。避免使用 NAT 意味着使用你的数据包过滤器来保护你的机器，并在需要时使用额外的应用程序代理。

### 私有 NAT 地址

理论上，你可以使用 NAT 设备后面的任何地址。如果你使用一些随机的 IP 地址，那么你将无法与使用这些 IP 地址的现实中的人交换数据包。强烈建议使用为私有用途保留的一些 IP 地址，通常称为“RFC 1918 地址。” 这些包括以下 IP 地址：

+   10.0.0.0/8 (10.0.0.0-10.255.255.255)

+   172.16.0.0/12 (172.16.0.0-172.31.255.255)

+   192.168.0.0/16 (192.168.0.0-192.168.255.255)

你可以按任何你喜欢的方式子网化和重新排列这些地址，只要你不尝试在公共互联网上路由它们。

如果你有一个非常好的理由，你可以在 NAT 后面使用其他 IP 地址。例如，RFC 5737 定义了用于文档的 IPv4 地址。像 RFC 1918 地址一样，RFC 5737 地址永远不会出现在公共互联网上。因为我写文档，所以我在我家用网络和测试网络上使用这些地址。这让我在写书时节省了搜索和替换的时间.^([48]) 这些地址出现在其他网络上的可能性仍然为零。

### 配置 NAT

可能最常见的一种 NAT 用途是隐藏一个小型网络在单个 IP 地址后面。你会在许多家庭和小型企业中找到这种情况。非常少的家庭办公室有内部路由和多个子网。在这个例子中，我有两个接口组：面向互联网的`egress`组和连接到我的办公室的`lan`组。

```
pass out on egress from **1**lan:network to any **2**nat-to egress
```

这个规则的第一个部分看起来就像任何其他允许`lan`接口上的地址访问任何地方的防火墙规则，但最后两个词还额外配置了 NAT。`nat-to`关键字告诉 PF 转换地址**2**。随后的`egress`告诉 PF 隐藏内部地址在`egress`接口的地址后面**1**。你在这里可以使用接口名称或特定的 IP 地址，但如果你这样做，你必须在你更改服务器时更改你的过滤规则。

为了让 PF 识别从 DHCP 来的 IP 地址变化，请将接口组名称放在括号内。

```
pass out on egress from lan:network to any nat-to (egress)
```

现在加载你的防火墙规则，启用 IP 转发，突然之间，你的局域网主机将通过防火墙的公网地址访问互联网。

### NAT 的工作原理

理解地址转换工作原理的最简单方法是通过查看 PF 在来回传递转换后的数据包后状态表（在上一章中讨论过）。在办公室网络中，从机器 192.0.2.2 上，我运行了这个命令：

```
$ **ping www.michaelwlucas.com**
```

几次 ping 之后，我检查了状态表，并发现了如下条目：

```
# **pfctl -ss | grep 192.0.2.2**
all udp **1**203.0.113.5:55797 **2**(192.0.2.2:10853) -> **3**203.0.113.15:53    MULTIPLE:SINGLE
all icmp 203.0.113.5:8813 (192.0.2.2:41584) -> 198.22.63.8:8       0:0
```

第一种状态表示从防火墙的公共地址**1**到本地 DNS 服务器**3**的 UDP 连接。此状态条目包括客户端的私有 IP 地址**2**，以及客户端、防火墙和 DNS 服务器实际使用的端口号。

客户端通过从其 IP 地址上的 10853 端口向 DNS 服务器的 53 端口发送请求来启动此状态。当数据包通过 PF 时，OpenBSD 重写了数据包，使其看起来是从 203.0.113.5 地址的 55797 端口发出的，并将其发送到 DNS 服务器。DNS 服务器将其响应发送到防火墙的公共 IP 地址的 55797 端口。当回复到达时，防火墙检查状态表，发现 55797 端口的 UDP 数据包是客户端状态的一部分。PF 重写数据包的目标地址并将其转发到客户端。

第二种状态表示一个 ICMP 连接。状态表将用于 ping 请求的各种 ICMP 代码编码为端口号，并根据该信息将响应转发回客户端。否则，它与上面的 DNS 示例非常相似。

换句话说，NAT 通过撒谎来工作。PF 向客户端撒谎，告诉它它可以直接访问公共互联网。它向外部服务器撒谎，为客户端连接提供一个虚假的源地址和端口号。PF 使用状态表来跟踪它的谎言并保持一切一致。这些谎言对于 IPv4 地址的节约很有用，但它们正是地址转换使故障排除和入侵取证复杂化的原因。

现在您已经了解了 NAT 的基本原理，让我们向网络讲述更多复杂和有趣的故事。

### 多个或特定公共地址

您可以使用多个公共 IP 地址进行地址转换。如果您在 NAT 规则中使用接口组作为外部地址，该接口组中的任何地址都可以成为任何连接的公共地址。如果您想具体指定，请列出特定地址。

```
pass out on egress from lan:network to any **1**nat-to 203.0.113.5
```

当我的防火墙的外部接口有多个 IP 地址，并且我想将桌面客户端隐藏在单个地址后面时（尽管我可能还会定义并使用一个宏来定义和使用外部地址**1**），我会使用这个配置。

但您需要多少个公共地址？答案取决于您的客户端。

端口号范围从 0 到 65535。底部的 1024 个端口通常用于 localhost 上的服务。并非所有这些端口都会在 localhost 上使用，但数据包过滤器通常不会使用这些端口进行转换连接。我很懒，所以我会四舍五入到 64,000 个空闲端口。

即使是最繁忙的桌面客户端也很少能同时使用多达 100 个出站连接。大多数将使用更少的连接，但再次强调，我很懒，并且我想考虑最坏的情况，所以我会将其称为 100。

一个 IP 地址可以支持 64,000 / 100 = 640 台机器同时进行病理状态。实际上，每个客户端可能有 10 个同时的出站连接，因此一个公网地址可以支持 6,400 个同时客户端。有多少用户同时浏览互联网？答案可能不多。如果您有数千名用户，您可能从实现缓存代理中受益，这将大大减少连接数。

如果您担心一个地址的客户机数量过多，请关注您的状态表。直到您有一个公网 IP 地址有数万个状态，您不必担心。

在 NAT 规则中指定单个地址对于双向 NAT 最有用。

### 双向 NAT

如果您为特定的私有 IP 地址分配一个公网 IP 地址作为 NAT 地址，某些应用程序将运行得更好。例如，如果您有一个服务器在不同的端口上提供多种不同的服务，并且您想将其放在防火墙后面，您可能希望为它分配一个单独的地址。这被称为*双向*、*一对一*或*静态* NAT。OpenBSD 文档使用“双向”，但所有这些术语都意味着同一件事。

使用`binat-to`关键字配置双向 NAT。

```
pass on lan from 192.0.2.65 to any binat-to 203.0.113.6
```

PF 为私有 IP 地址 192.0.2.65 的 NAT 服务分配了公网 IP 地址 203.0.113.6。

如果您使用双向 NAT，请确保为您的通用 NAT 指定一个特定的 IP 地址，并考虑使用以下 NAT 规则：

```
pass out log on egress from lan:network to any nat-to egress
pass on lan from 192.0.2.2 to any binat-to 203.0.113.6
```

这个局域网的 IP 地址隐藏在`egress`接口的 IP 地址后面。如果 203.0.113.6 是`egress`接口上的一个地址，那么局域网的外出数据包可能会将其用作源地址。

当我需要双向 NAT 时，我通常会这样编写我的 NAT 规则：

```
mainnat="203.0.113.5"
servernat="203.0.113.6"
pass out log on egress from lan:network to any nat-to $mainnat
pass on lan from 192.0.2.2 to any binat-to $servernat
```

这样，离开我的网络的数据包会被明确地转换。只有特定的服务器使用 IP 地址 203.0.113.6；我本地网络上的所有其他主机使用 203.0.113.5。如果我更改 IP 地址，我必须重新配置*pf.conf*，但与解决网络模糊问题相比，这只是一个小的烦恼。

#### 双向 NAT 和安全

使用双向 NAT 并允许连接重定向，可以让您让网络外的人访问您防火墙后面的服务器，而每一个这样的空隙都是一个潜在的安全漏洞。如果您允许全世界访问您的 Web 服务器，并且入侵者破坏了您的其中一台服务器，那么您防火墙内部就有了一台受损害的机器。防火墙并没有真正保护 Web 服务器；它只是控制谁可以尝试入侵，并限制了可用的攻击向量。

#### 数据包过滤、双向 NAT 和规则顺序

当为双向 NAT 编写数据包过滤规则时，您列出规则的顺序很重要。考虑以下规则：

```
pass on lan from 192.0.2.2 to any binat-to 203.0.113.6
pass in on egress proto tcp from any to 192.0.2.2 port 80
```

第一条规则为局域网上的主机 192.0.2.2 建立了静态 NAT，隐藏在公共 IP 地址 203.0.113.6 后面。一切顺利。第二条规则允许连接到同一主机的 80 端口，或者不是吗？到达防火墙`出口`接口的针对此服务器的数据包不会地址到 192.0.2.2；它们会被地址到公共 NAT 地址，即 203.0.113.6。它们不会匹配此规则，因此会被丢弃。

为了允许来自世界各地的连接到这个防火墙后面的 Web 服务器，允许发送到公共地址上正确端口的包。

```
pass on lan from 192.0.2.2 to any binat-to 203.0.113.6
pass in on egress proto tcp from any to 203.0.113.6 port 80
```

这将 192.0.2.2 转换为公共地址 203.0.113.6，并允许目标为 203.0.113.6 端口 80 的数据包通过。你会在状态表中看到这一点，如下所示：

```
all tcp 203.0.113.6:80 <- 198.22.63.8:64791       ESTABLISHED:ESTABLISHED
```

主机 198.22.63.8 已连接到服务器的公共 IP 地址 80 端口。

为什么这个状态条目中没有隐藏的 IP 地址？因为这是一个双向 NAT。PF 可以通过未修改的端口号发送，所以它可以在状态表中跟踪较少的信息。

这里棘手的是规则顺序会影响你的过滤方式，你必须仔细阅读你的过滤规则，以了解地址转换如何与数据包过滤相互作用。我*总是*在过滤之前进行地址转换。我始终在过滤规则中使用公共 IP 地址，但有时这并不实用。PF 允许你编写任意复杂的规则，主要是因为现实世界是任意复杂的。如果你在 NAT 中遇到流量传输问题，请仔细阅读你的规则。

要查看双向 NAT，请查看加载的规则。

```
# **pfctl -sr**
…
pass out on lan inet from 192.0.2.2 to any flags S/SA nat-to 203.0.113.6 static-port
pass in on lan inet from any to 203.0.113.6 flags S/SA **rdr-to** 192.0.2.2
pass on egress inet proto tcp from any to 203.0.113.6 port = 80 flags S/SA
```

第一条规则允许私有 IP 地址访问公共互联网，并将其翻译为特定的 IP 地址。第三条规则将流量传递到翻译后的地址。

但关于第二条规则，那个`rdr-to`是什么？这是一个重定向，这是 PF 实现静态 NAT 的方式。

### 重定向

双向 NAT 实际上是地址转换和*重定向*的组合；换句话说，它将一个 IP 或端口连接的方向扭转到另一个。在双向 NAT 中，所有连接到指定公共 IP 地址的连接都会被重定向到不同的 IP 地址。有时你不想扭转一个 IP 地址的所有流量——只是几个端口。有时你希望一个端口单向重定向，但在其他地方使用不同的端口。可以通过重定向规则来实现这一点。

假设你有一个公共 IP 地址：203.0.113.5。你希望该 IP 地址上的 80 端口路由到你的 Web 服务器 192.0.2.2，端口 25 和 110 路由到你的邮件服务器 192.0.2.3，端口 443 路由到你的电子商务服务器 192.0.2.4。PF 允许你通过使用标准的包过滤规则并添加`rdr-to`重定向关键字来选择每个端口的发送位置。

```
pass in on egress proto tcp from any to egress port 80 rdr-to 192.0.2.2
pass in on egress proto tcp from any to egress port {25, 110} rdr-to 192.0.2.3
pass in on egress proto tcp from any to egress port 443 rdr-to 192.0.2.4
```

这些规则声明，任何连接到 `egress` 接口组（面向公共互联网的接口，默认路由通过它）都可以以三种不同的方式进行重定向。第一条规则将端口 80 请求导向一个内部服务器。第二条规则将端口 25 和 110 的请求导向第二个服务器。最后一条规则将端口 443 的请求重定向到第三个服务器。现在一个公共 IP 地址正在从三个不同的服务器向世界提供服务。

所有端口重定向规则都必须包含一个协议，因为指定 TCP/IP 端口仅在转发包含端口号的协议时才有效，例如 TCP 或 UDP。如果你想要转发 TCP 和 UDP 端口，你必须指定这两个协议。例如，DNS 在 TCP 和 UDP 上都使用端口 53。以下是一个将这两个协议的端口 53 重定向到内部服务器 192.0.2.5 的规则：

```
pass in on egress proto {tcp, udp} from any to egress port 53 rdr-to 192.0.2.5
```

选择一个端口，指定你希望它去往的地方，PF 将按照你的意愿进行重定向。

### 注意

你已经学习了双向 NAT 如何结合重定向和地址转换。内核中的 PF 引擎实际上对这种被称为“双向 NAT”的东西一无所知。`pfctl(8)` 将 `binat` 规则转换为两个独立的规则：一个用于转换，一个用于重定向。

### 多个地址和接口组

所有的前述讨论在你只有一个公共 IP 地址时是有意义的。但是，当你有多个地址时会发生什么呢？

记住，在 *pf.conf* 中使用接口组会告诉 `pfctl` 为接口组中的每个 IP 地址创建一个匹配规则。假设你的 `egress` 接口上有三个 IP 地址：203.0.113.5、203.0.113.6 和 203.0.113.7。你将编写以下 *pf.conf* 规则：

```
pass in on egress proto tcp from any to egress port 80 rdr-to 192.0.2.2
```

使用 `pfctl` 将此规则加载到内核中，你会得到什么？

```
# **pfctl -sr**
…
pass in on egress inet proto tcp from any to 203.0.113.5 port = 80 flags S/SA rdr-to 192.0.2.2
pass in on egress inet proto tcp from any to 203.0.113.6 port = 80 flags S/SA rdr-to 192.0.2.2
pass in on egress inet proto tcp from any to 203.0.113.7 port = 80 flags S/SA rdr-to 192.0.2.2
```

任何连接到这些 IP 地址上的端口 80 的连接都将被导向同一服务器的端口 80。这可能在某些环境中很有用，但这不是我们大多数人想要的。如果你有多个 IP 地址，并且只想在其中一个 IP 地址上重定向端口，你必须指定接口名称和公共 IP 地址。

```
pass in on em0 proto tcp from any to 203.0.113.5 port 80 rdr-to 192.0.2.2
```

这不会扩展；它没有任何接口组、地址列表、变量或宏。当 `pfctl` 解析时，它只将一个 PF 规则加载到内核中。

### 端口操作和范围

当你从一个机器重定向端口到另一个机器时，你可以更改端口。以下示例将防火墙上的 TCP 端口 2222 的请求重定向到防火墙内机器的端口 22。

```
pass in on egress proto tcp from any to egress port 2222 rdr-to 192.0.2.2 port 22
```

这是一种合理的方式，在只有一个 IP 地址的情况下向防火墙内的多台机器提供 SSH 服务，并为每台机器分配其自己的端口。

如果你有一些特定的源地址想要滥用，你可以通过源 IP 地址给予它们特殊的端口重定向。

```
pass in on egress proto tcp from 198.51.100.0/24 to egress port 80 rdr-to 192.0.2.2
pass in on egress proto tcp from ! 198.51.100.0/24 to egress port 80 rdr-to 192.0.2.3
```

来自 198.51.100.0/24 IP 地址的每个 HTTP 连接都将被重定向到一台服务器，而其他所有连接将被导向其他地方。（要为多个源地址重定向连接，请使用源地址表。）

PF 还可以使用与过滤端口相同的逻辑运算符重定向整个端口范围。一个明显的做法是将端口范围重定向到单个机器。NFS 是一个很好的例子，因为它需要 TCP 端口 111，以及从 1024 到 65535 的所有 TCP 和 UDP 端口。

```
pass in on egress proto {tcp, udp} from any to egress port {111, 1024:65535} rdr-to 192.0.2.15
```

回想一下第二十一章，端口号之间的冒号表示端口范围。此规则通过 1024 到 65535 的端口，包括端口号。诚然，某些 NFS 实现可以限制使用 TCP 或 UDP，这在你的包过滤器中是一个很大的漏洞。但 NFS 使用随机的高编号端口，这些端口来去非常快，无法在包级别上进行有效过滤或限制。

你也可以将整个端口范围引导到一台机器上的一个端口。

```
pass in on egress proto tcp from any to egress port {1024:65535} rdr-to 192.0.2.15 port 80
```

我曾用它将随机流量指向一个显示“走开。你不能使用此服务。”的网页。

### 透明拦截

流量拦截与重定向类似，PF 拦截指向一个端口的流量并将其引导到本地机器上的一个端口。流量拦截是实现透明代理的一种方式。使用`divert-to`关键字告诉 PF 将任何匹配的包引导到本地服务器。

```
pass in inet proto tcp from lan:network to any port 80 **divert-to** 127.0.0.1 port 3129
```

来自本地局域网到端口 80 的任何流量都将被重定向到防火墙上的端口 3129。端口 3129 通常由 Squid 缓存代理（*/usr/ports/www/squid*）使用。如果你选择实现像 Squid 这样的缓存代理，你可能希望将多个端口重定向到缓存。（我们将在 FTP 和 PF 中更详细地查看连接的重定向。）

## 锚点

在 PF 中，*锚点*是过滤器规则中特定点的子规则集，你可以更改它而无需重新加载规则。这是一个标记为“在此处插入规则”的位置，让你可以动态添加和删除过滤器规则、表以及其他 PF 配置。

锚点的最常见用户是软件程序。人类或系统管理员可能只需编辑*pf.conf*并重新加载规则。

OpenBSD 包括几个利用锚点的程序，包括 FTP 代理`ftp-proxy(8)`、认证防火墙访问系统`authpf(8)`和负载均衡器`relayd(8)`。你也可以使用锚点来触发规则的条件评估。

带有锚点的规则集可能看起来像以下示例，其中接口组`egress`面向互联网，而接口组`lan`面向具有地址 192.0.2.0/24 的小办公室。

```
block
pass in on egress from any to 192.0.2.45 port {25, 80}
anchor "antivirus/*"
pass in on lan from 192.0.2.0/27 to any
```

这些规则默认阻止所有流量。入站流量允许访问端口 25 和 80 的特定地址，因为那些是邮件和 Web 服务器。规则中间有一个锚点。我还不知道 `antivirus` 锚点中有什么，但其中的任何规则都会被处理。最后，允许一小部分地址的子网流出。

现在让我们向锚点添加一些规则。

### 向锚点添加规则

您可以从文件中、在 *pf.conf* 本身或通过 `pfctl` 将规则插入到锚点中。

#### 文件中的锚点规则

从文件向锚点添加规则是初始化数据包过滤器时锚点的好方法。您可以在其中设置基本规则，稍后可以扩展。在 *pf.conf* 中提供文件名。

```
anchor dhcp
load anchor dhcp from "/etc/pf/dhcp-anchor.conf"
```

我创建了一个 */etc/pf/* 目录，因为我不想在 */etc* 中散布大量的 PF 配置文件。毕竟，我很容易混淆。这个文件包含如下 PF 规则：

```
block from 192.0.2.192/26 to any
```

这是在启动 PF 时将基本规则加载到锚点的一种方法。

如果你注意到了，我的第一个例子锚点后面有一个 `/*`。这个例子没有。我会在嵌套锚点: /*中解释原因。

#### pf.conf 中的锚点规则

您可以直接在 *pf.conf* 中放置锚点规则。如果您不打算动态更改规则，甚至不需要命名锚点。只需使用花括号来定义锚点的开始和结束即可。

```
anchor "smtp" on egress {
    pass proto tcp from 192.0.2.12 to any port 25
    }
```

这只是比默认 *pf.conf* 中的锚点稍微复杂一点。

为什么你想这么做？请阅读条件过滤。

#### 通过 pfctl 的锚点规则

要使用 `pfctl` 动态更改锚点规则，您需要锚点的名称和您想要放入其位置的规则。例如，假设我想向第一个锚点示例中的 `antivirus` 锚点添加一个规则。

```
# **1****echo "block in from 203.0.113.8 to any"** **2****| pfctl** **3****-a antivirus** **4****-f -**
```

让我们稍微从后往前看这个命令。`pfctl` 的 `-a` 参数指定了一个锚点名称——在这个例子中是 `antivirus` 锚点 **3**。`-f` 参数通常提供一个包含新锚点规则的文件名，就像加载 PF 规则集时的 `-f` 一样，但与指向文件的路径不同，我使用一个单独的短横线来告诉 `pfctl` 从标准输入或命令行读取新规则 **4**。我通过回显要添加的规则 **1** 来开始一切，然后将它管道化到 `pfctl` **2**。

总体来说，这会将规则 `block in from 203.0.113.8 to any` 添加到 `antivirus` 锚点。

您也可以将新规则写入文件，并告诉 `pfctl` 从该文件加载规则到锚点中。

```
# **pfctl -a antivirus -f newrule.conf**
```

然而，如果您正在将规则写入文件以将其加载到锚点中，那么编辑 *pf.conf* 可能会更好。

### 注意

向锚点添加规则会擦除锚点中已有的任何规则。如果你有一个更新锚点规则的软件包，你的软件需要处理这种行为。如果你的期望行为可以通过 IP 地址列表实现，考虑使用表格而不是锚点。

### 查看和清除锚点

使用 `pfctl` 查看锚点（`-s`）、清除（`-F`）和加载（`-f`）命令，通过指定锚点名称使用 `-a`。

```
# **pfctl -a antivirus -s rules**
block drop in inet from 203.0.113.8 to any
```

要擦除锚点中的规则，请清除锚点中的规则。

```
# **pfctl -a antivirus -F rules**
rules cleared
```

你的锚点现在是空的。

锚点内的规则集完全相互独立，也独立于主规则集。清除特定锚点中的所有规则不会影响任何其他锚点中的规则，或主规则集中的规则。就这个而言，清除主规则集中的规则也不会影响锚点中的规则。要销毁一个锚点，你必须移除锚点中的所有内容，包括任何子锚点。

“子锚点？”我听到你喊道。“你现在在胡说些什么，伙计？”

### 条件过滤

考虑以下 *pf.conf* 片段：

```
…
anchor "office/*" in from lan to any {
    pass out proto tcp from any to {80, 443}
    }
…
```

`office/*` 锚点后面有一个过滤条件，只有符合过滤条件的流量才能通过该锚点。在这种情况下，只有来自 `lan` 接口组的包才能通过锚点内的规则。你锚点内的规则可能更容易编写，仅仅因为锚点内的一切已知都来自 `lan` 接口。

如果你的包过滤器负载非常重，你可能可以通过仔细的条件过滤来减少它处理数据包所花费的时间。

### 嵌套锚点: /*

锚点可以包含其他锚点。

```
anchor "office" in from lan to any{
    …
    anchor "ftp-proxy/*"
    pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
}
…
```

只有通过 `office` 锚点的流量才能通过 `ftp-proxy` 锚点。FTP 代理也可以有自己的子锚点。实际上，你可能需要多层锚点来支持复杂的协议，如 FTP。

这就是为什么某些锚点名称后面跟有 `/*` 的原因。没有这个的锚点名称会独立执行。通过添加 `/*`，你告诉 PF 按字母顺序评估此锚点内的所有子锚点。

锚点和子锚点故意模仿文件系统。你可以有一个文件 */office* 或一个包含更多文件的目录 */office/*。如果你列出目录中的文件，它们会按字母顺序显示。锚点的工作方式与此类似。

所有这些锚点内容都是非常理论性的。那么，有没有一个实际例子呢？继续阅读，看看 PF 如何使用锚点来处理最令人烦恼的网络协议：FTP。

## FTP 和 PF

大多数现代应用程序协议都运行在单个网络连接上。如果你发起一个网页请求，你的浏览器会打开到服务器的 80 号端口的连接，请求信息，并接收答案，所有这些都在同一个连接上完成。SSH 在 22 号端口打开一个单独的连接，并在此端口上交换所有信息，即使你在其中隧道了一百种其他协议。对旧协议的经验和实验教会了我们这种方法的好处。FTP 是一个较旧的协议，它提供了大量关于如何不做事的经验。

FTP 的原始版本（今天称为*主动 FTP*）要求客户端连接到服务器的 21 号端口。然后服务器会从 20 号端口打开一个连接回客户端，连接到客户端的某个随机高编号端口以发送信息。从服务器到客户端的连接被称为*数据连接*或*反向通道*。FTP 客户端和服务器就使用的端口以及第二个连接的用途达成一致。然而，在网络协议层面，客户端连接到 21 号端口和服务器从 20 号端口连接之间不存在连接，因此防火墙无法使用状态检测来区分这种连接是否被允许。更糟糕的是，如果客户端位于 NAT 设备后面，就无法确定防火墙应将传入的 FTP 数据请求路由到哪个私有 IP 地址。

*被动 FTP* 是 FTP 协议的一个更新版本，其中客户端初始化了两个 TCP 连接。所有现代客户端和服务器都支持被动 FTP。主动 FTP 和被动 FTP 之间的差异引发了用户教育的无尽循环和帮助台工作量的增加，尤其是在尝试通过网页浏览器使用 FTP 时。（如果有人要破坏我的帮助台工作人员，那肯定是我自己！）主动 FTP 简化了防火墙规则，因为防火墙不需要允许反向通道。不幸的是，被动 FTP 的创造者将修改后的协议称为 FTP。客户端不在乎主动还是被动，他们只想“这个 FTP 东西”能工作，不管它背后的实际协议是什么。

为了使事情更加复杂，一些 FTP 服务器和客户端在主动和被动 FTP 之间实现了某种折中方案。FTP 协议已经存在了几十年（它早于 TCP/IP），人们多年来一直在对其进行调整和“改进”。通过一个随机的 NAT 设备和数据包过滤器将一个随机的 FTP 服务器和客户端组合在一起可能会引起噩梦，或者至少需要打开广泛的 TCP 端口。

OpenBSD 和 PF 通过包含一个 FTP 应用程序代理`ftp-proxy(8)`来解决这个问题。当客户端发起 FTP 请求时，PF 拦截请求并将其重定向到应用程序代理。代理跟踪 FTP 协议事务，使用锚点将适当的规则插入防火墙，并在传输完成后删除规则。严格来说，`ftp-proxy`不是一个传统的代理。数据实际上并没有通过`ftp-proxy`；这个“代理”调整防火墙规则以便流量可以通过。代理需要两个部分：一个运行的`ftp-proxy`实例和重定向规则。

### 配置 ftp-proxy(8)

就像任何其他 OpenBSD 守护进程一样，`ftp-proxy`在`/etc/rc.conf.local`中启用。没有配置文件——只有命令行参数。默认情况下，`ftp-proxy`自动监听回环接口上的 8021 端口。我很少为常规使用添加任何`ftp-proxy`命令行参数。

```
ftpproxy_flags=""
```

然而，如果我在调试问题，我可能会在调试模式下前台运行`ftp-proxy`。这样做会显示所有发生的 FTP 事务。

```
# ftp-proxy -dD7
```

这显示了通过 FTP 代理的所有内容，包括返回客户端的数据通道使用的端口。按 CTRL-C 停止`ftp-proxy`。

我与`ftp-proxy`最常见的问题是调试终端中没有显示任何内容。这意味着防火墙没有将任何流量重定向到代理。检查你的`pf.conf`文件以验证你是否有了支持 FTP 代理的必要规则。

### PF 配置和 FTP 代理

PF 必须知道将 FTP 请求发送到`ftp-proxy`。默认的`pf.conf`文件中有一个很好的配置示例：

```
anchor "ftp-proxy/*"
pass in quick inet proto tcp to port ftp divert-to 127.0.0.1 port 8021
pass out inet proto tcp from (self) to any port ftp
```

这是我们使用锚点的地方。`ftp-proxy/*`锚点可以包含子规则集。`ftp-proxy`守护进程会动态修改这些锚点以配置必要的流量或数据连接。第二个规则声明 PF 会将任何指向 FTP 端口（21，根据`/etc/services`）的流量重定向到本地主机的 8021 端口。第三个规则表示防火墙主机可以将 TCP 端口 21 流量发送到任何其他主机。此规则包含一个新术语`(self)`，它是 PF 对“本地主机上的所有 IP 地址”的简称。

你如何确保这能工作？首先，找到一个支持主动 FTP 的 FTP 服务器。打开你的 FTP 客户端并登录到服务器，通过防火墙。一旦登录，在 FTP 提示符下使用`pasv`命令。此命令打开或关闭被动模式。如果服务器不识别`pasv`，则它只支持被动 FTP。为此测试找到另一个 FTP 服务器。一旦 FTP 服务器报告“被动模式已关闭”，列出目录内容。目录列表，就像数据文件一样，通过数据通道传输。

在一个活跃的 FTP 连接的数据传输过程中，你应该在`ftp-proxy/*`锚点中看到规则。

```
# **pfctl -a "ftp-proxy/*" -sr**
anchor "6837.2" all {
  pass in log (all) quick on rdomain 0 inet proto tcp from 129.128.5.191 to 139.171.202.34 port = 62323 flags S/SA keep state (max 1) rtable 0 rdr-to 192.0.2.2 port 64280
  pass out log (all) quick on rdomain 0 inet proto tcp from 129.128.5.191 to 192.0.2.2 port = 64280 flags S/SA keep state (max 1) nat-to 129.128.5.191
}
```

`ftp-proxy` 创建的规则非常具体。它们只允许一个连接，从一个特定的服务器到特定的客户端，并使用地址转换规则使每一方都认为它实际上在与正确的客户端或服务器通信。

### 注意

要了解如何限制你的客户端只使用匿名 FTP，或者如何使用`ftp-proxy`允许防火墙内的服务器进行入站 FTP 访问，请阅读`ftp-proxy(8)`手册页。

## 带宽管理

网络边界设备的一个常见任务是带宽管理。网络管理员必须控制用于特定任务的带宽量，还必须为关键功能预留带宽。如果你的一个下属在 Web 服务器上加载最新的热门漫画电影，你必须能够通过 SSH 连接到服务器，找出为什么你的服务器过载，并解决问题。PF 包括 ALTQ 带宽管理系统。

关于带宽管理，最重要的是记住你不能控制别人发送给你的流量量。你可以在流量进入你的网络时停止它。你可以发送带宽饱和的提示。你可以随意限制来自你的服务器的带宽。但无论你做什么，都无法阻止每秒 10,000 人点击链接到那个服务器。你无法阻止分布式拒绝服务攻击使你的入站带宽饱和。你能做的最好的事情就是控制你如何响应这些请求。

当我运行内容农场时，我通常在我的服务器前面放置专门的带宽控制机器。这种设置控制了多少流量实际上到达我的服务器网络，在流量突然激增时减轻服务器的负载，并防止一个过于繁忙的客户使同一服务器上的其他客户崩溃。

### 带宽管理队列

ALTQ 通过**队列**来管理带宽。队列是一系列等待处理的分组。

通过将你的带宽分成单独的队列，并按照你的配置处理这些队列，你可以管理服务器带宽。队列有点像杂货店的结账队列；一些队列是为 10 个或更少的分组设计的，可以让你快速结账，而其他队列是为每月购物一次并装满三个购物车的人设计的。你可以为队列定义几乎任何特性，就像你可以创建一个“仅肉类”或“白葡萄酒配鱼”的收银台一样。

工程师们定义了许多不同的队列算法，而对于特定情况最合适的队列方法是一个引发激烈讨论的话题。TCP/IP 服务质量队列处理是那些让孩子们哭泣的话题之一。默认情况下，所有基于 BSD 的系统都使用先进先出（FIFO）队列，其中分组按照接收的顺序进行处理。较新的分组会等待在队列中，直到较旧的分组移动。

OpenBSD 还支持优先级队列（PRIQ 或 prio），其中内核将某些类型的数据包视为“优先”并首先处理它们。这意味着如果您将网页数据包分配最高优先级，所有网页数据包都会跳到队列的头部。在优先级队列方案下，低优先级的数据包可能根本不会被处理。如今，几乎所有东西都支持优先级队列，尤其是交换机。优先级队列的目标是减少特定流量（如语音或视频）的延迟，通过增加不那么紧急流量的延迟来支付这种减少的延迟。

然而，在大多数需要调节带宽的操作环境中，基于类的队列（CBQ）是合适的。CBQ 允许网络管理员通过分层类为不同类型的流量分配一定量的带宽。每个类都有自己的队列，具有自己的带宽特性。您可以将不同类型的流量分配到不同的类中：将 SSH 分配到一个类，将 HTTP 和 HTTPS 分配到另一个类，等等。CBQ 的一个优点是其分层特性允许低级队列从高级队列借用可用带宽。

由于我发现 CBQ 适用于大多数环境，所以我在这里重点介绍它。一旦您掌握了 CBQ，如果您需要 PRIQ，您会发现它很容易理解。

### 父队列定义

队列配置从定义父队列开始。所有其他队列都是父队列的子队列。父队列连接到网络接口，通常是面向互联网的接口。将您的队列定义放在*pf.conf*文件中。我把队列放在文件顶部，在所有数据包过滤规则之前。

在接口上定义父队列的方法如下：

```
**1**altq on **2***interface* **3**cbq bandwidth **4***bw* qlimit **5***qlim* tbrsize **6***size* **7**queue { **8***queue1*, **9***queue2*}
```

所有 ALTQ 父队列定义都以`altq`关键字**1**开始，然后指定此队列所连接的接口**2**。（每个接口最多只能有一个父队列。）然后指定您正在使用的队列类型**3**。对于 CBQ 队列，队列类型始终是`cbq`。

现在定义父队列中的总带宽**4**。这不同于接口可以传输的带宽量，而是您合理预期的上游传输带宽量。如果您的 OpenBSD 机器有一个千兆网卡，但您只有 10 兆的互联网带宽，则使用`10Mb`作为您的带宽（或者调整带宽值，直到达到实际可用的分配）。您可以使用以下区分大小写的带宽缩写：

+   ****`b`****.每秒比特

+   ****`Kb`****.每秒千比特

+   ****`Mb`****.每秒兆比特

+   ****`Gb`****.每秒千兆比特

可选的`qlimit`参数指定队列可以持有的数据包数量**5**。默认值是`50`，对于几乎所有情况都足够了。我建议除非特定的调试显示您需要更大的队列大小，否则不要设置`qlimit`。

此示例包括令牌桶调节器大小配置，因为 `tbrsize` 允许你指定数据包可以传输的速度 **6**。ALTQ 默认以线缆允许的速度传输数据包。与 `qlimit` 一样，除非你遇到问题，否则我建议不要设置 `tbrsize`。

接下来，将其标识为父队列 **7**，并定义子队列 `queue1` **8** 和 `queue2` **9**。

这是如何配置一个具有 50 兆比特上行链路的父队列，并定义子队列 `ssh`、`web` 和 `mgmt`：

```
altq on em0 bandwidth 50Mb queue {ssh, web, mgmt}
```

`tbrsize` 和 `qlim` 关键字未设置，因此它们处于默认状态。

### 子队列定义

一旦你有一个父队列，你就可以定义子队列。使用以下语法定义 CBQ 队列：

```
queue **1***name* on **2***interface* bandwidth **3***bw* [priority **4**pri] [qlimit **5***qlim*] cbq **6**(options) **7**{child_queues}
```

每个队列都需要一个名称 **1**，在父队列定义中定义，长度不超过 15 个字符。名称不需要唯一——你可以在不同的接口上使用相同名称的队列——但我建议使用唯一的名称。

接口是应用此队列的特定接口 **2**。如果你没有定义接口，通过任何接口传输的流量都可以分配到这个队列。

`bandwidth` 术语使用与父队列相同的带宽标签，但分配给所有子队列的总带宽不能超过父队列上可用的总带宽 **3**。你也可以使用百分比值来表示带宽，表示此队列可以消耗父队列的百分比。带宽和队列是子队列描述中的唯一强制术语。

以下定义了 `ssh` 子队列并给它分配了 2 兆比特的带宽：

```
queue ssh bandwidth 2Mb
```

这里有一个名为 `web` 的子队列，它被允许使用父队列带宽的三分之四：

```
queue web bandwidth 75%
```

你可以为队列分配一个优先级 **4**。CBQ 优先级从 `0` 到 `7`，`7` 是最高的。默认优先级是 `1`。具有更高优先级的 CBQ 队列不会排除其他队列，但 PF 会比其他队列更快地处理它。

与父队列一样，你可以给子队列分配一个 `qlimit` **5**，但除非你有特定的问题需要用这个值来解决，否则不要这样做。

你可以为 CBQ 子队列分配选项 **6**。我们将在下一节中查看这些选项。

最后，子队列可以有它们自己的子队列。在队列 **7** 中定义一个队列的子队列。你将在 CBQ 规则集 中看到一个例子。

### 队列选项

通过为队列分配选项来修改子队列处理数据包的方式。选项让你决定队列应该如何响应各种网络条件和带宽可用性。

#### 默认

每个父队列必须有一个且仅有一个默认子队列。如果一个跨越队列接口的数据包没有被分配到其他队列，它将被分配到默认队列。

#### 随机早期检测

随机早期检测（RED）是一种处理队列开始填满时的数据包丢失的方法。随着队列的填满，越来越多的数据包被丢弃。RED 随机选择数据包进行丢弃。结果是，短传输，如 HTTP 请求和交互式 SSH 会话，响应更快，而大数据传输则变慢。

TCP 客户端和服务器通过减少吞吐量来对丢弃的数据包做出反应。UDP、ICMP 和其他协议没有内置的针对数据包丢失的反应。在预期携带 TCP 的队列上使用 RED 是合理的，但不是在其他协议的队列上。

#### 显式拥塞通知

显式拥塞通知（ECN）是对 RED 的一种修改，它是在数据包中设置标志而不是丢弃数据包。如果一个设备识别到 ECN 标志，它将降低传输速率。

然而，并非所有平台都理解 ECN，而且许多可以识别 ECN 的平台默认禁用它。微软的 Windows Vista 及更高版本、Apple OS X、FreeBSD 和 OpenBSD 可以支持 ECN，但默认禁用。较新的 Linux 版本如果其他主机请求，则支持 ECN。我在企业环境中成功使用了 ECN，在那里我可以让支持人员启用桌面上的 ECN。

除非你知道正在使用的操作系统并且可以控制它们的设置，否则请坚持使用标准的 RED。

#### borrow

`borrow`选项仅在 CBQ 中可用。如果父队列有可用带宽，设置了 borrow 的队列可以从父队列借用带宽。例如，你可能有一个为 VoIP 保留 20%带宽的队列。如果你在任何特定时刻没有那么多 VoIP 流量，父队列将有额外的带宽。其他队列可以从这个分配中借用带宽。然而，当你的 VoIP 流量激增时，PF 会撤销带宽贷款，VoIP 流量将获得为其预留的带宽。

在你想要允许借用带宽的队列上使用`borrow`选项，而不是在可能借用带宽的队列上。

### CBQ 规则集

在配置队列之前，确定你想要如何划分你的带宽。虽然你可以使用每秒比特数来管理带宽，但对于我们大多数人来说，百分比更容易处理。以下是一个公司 10 兆比特链路互联网带宽的划分方法。首先列出你想要的带宽预留列表，然后为每个类别分配一个名称，如下所示：

+   SSH（`ssh`）占 5%

+   我们电子商务服务器的入站流量为 50%，使用 RED（`web`）

+   高优先级的入站 VoIP 占 5%（`voip`）

+   其他流量，包括 DNS、SMTP 等占 40%

所有这些队列都可以从父队列借用带宽。

首先定义父队列。

```
altq on em0 cbq bandwidth 10Mb queue {ssh, web, voip, other}
```

这个父队列连接到接口`em0`，有 10 兆比特的带宽和四个子队列。保留所有其他选项不变。

现在定义第一个子队列。

```
queue ssh bandwidth 5% cbq (borrow)
```

从队列名称和您选择的带宽百分比开始。此百分比是从特定队列的父队列计算的，因此大约是 10 兆比特的 5%，即每秒 500 千比特。这应该足够用于远程登录和修复任何问题。添加`borrow`选项可以让您在可用的情况下使用更多带宽。

从这个示例开始，您可以定义其他子队列。

```
queue web bandwidth 50% cbq (borrow, red)
queue voip bandwidth 5% cbq (borrow)
queue other bandwidth 5% cbq (borrow, default)
```

另一个队列是您的默认队列。任何未分配到其自己队列的流量都将分配到这个队列。

### 将流量分配到队列

使用`queue`关键字在数据包过滤规则末尾将流量分配到队列。要允许所有 SSH（端口 22）流量进入网络并将其分配到名为`ssh`的队列，请使用如下规则：

```
pass in on egress proto tcp from any to lan:network port 22 queue ssh
```

### 使用`match`关键字

有时您必须对流量进行分类而不进行过滤。前面的示例允许您将传入的 SSH 流量分配到`ssh`队列，但您想同时捕获出站的 SSH 怎么办？考虑以下规则片段：

```
pass in on egress proto tcp from <customers> to <sshservers> port 22
pass out on egress from lan:network to any
```

这允许`customers`表中的主机通过端口 22 连接到`sshservers`表中的主机。第二条规则允许本地网络发送任何流量或任何协议。其中一些出站流量将是 SSH 流量。您是否需要为排队流量单独编写一条规则？

这就是`match`关键字发挥作用的地方。使用`match`，您可以更改 PF 如何分类流量，而无需更改其过滤方式。以下是如何将所有 TCP 端口 22 的流量发送到`ssh`队列，而无需更改任何过滤特性：

```
match proto tcp from any to any port 22 queue ssh
pass in on egress proto tcp from <customers> to <sshservers> port 22
pass out on egress from lan:network to any
```

第一条规则匹配所有 TCP 端口 22 的流量并将其分配到`ssh`队列。接下来的规则控制谁可以发送和接收 SSH 连接。

### 查看队列

要查看当前在数据包过滤器中的队列，请运行 `pfctl -s queues`。

```
# **pfctl -sq**
queue root_em0 on em0 bandwidth 10Mb priority 0 cbq( wrr root ) {ssh, web, voip, other}
queue  ssh on em0 bandwidth 500Kb cbq( borrow )
queue  web on em0 bandwidth 5Mb cbq( red borrow )
queue  voip on em0 bandwidth 500Kb priority 7 cbq( borrow )
queue  other on em0 bandwidth 500Kb cbq( borrow default )
```

使用`-v`选项可以为您提供每个队列状态的简要快照。要查看所有队列的持续更新视图，包括从每个队列借用多少流量、丢弃了什么等，请使用`-vvsq`或`systat queues`。

## PF 边缘

本节涵盖了几个 PF 配置的细节，它们不太适合其他地方：包含文件和`quick`关键字。

### 使用包含文件

有时将配置文件拆分成多个部分可以简化您的工作。在`pf.conf`中使用`include`语句来完成此操作。

```
include "/etc/pf/management-addresses"
```

当我需要管理具有独特配置但某些部分相同的多个 PF 机器时，我会这样做。`management-addresses`文件定义了一个表，列出了可以通过 SSH 连接、执行 SNMP 查询等操作的所有主机和网络。当这些地址中的任何一个发生变化时，我会将此文件复制到所有 PF 主机并重新加载数据包过滤规则。

### 使用快速跳过比赛

PF 按顺序处理数据包过滤规则，最后一个匹配的规则生效，这可能会使设计支持所需精确访问的规则集变得复杂。如果你发现自己陷入了困境，可以使用 `quick` 关键字来终止匹配数据包的其余规则的处理。以下是一个示例：

```
…
pass in **quick** proto tcp from any to $sshserver port 22
…
block in proto tcp from any to any port 22
…
```

第一条规则允许流量访问端口 22 上的宏 `$sshserver` 主机。第二条规则丢弃所有端口 22 的 TCP 流量。第一条规则中的 `quick` 关键字表示，“当一个数据包匹配此规则时，遵循此规则，并不要处理任何更多规则。”在这种情况下，SSH 连接将被允许。

`quick` 关键字在锚点中特别有用，因为自动化过程（如 `ftp-proxy(8)`）为特殊目的添加的规则可能会被后来为无关目的添加的规则覆盖。

我内心那个纯粹主义者想要坚持认为所有静态规则集都应该不使用 `quick` 来编写。虽然从严格意义上来说这是正确的，但有时避免使用 `quick` 可能会创建难以理解的规则集。一个容易理解的规则集比那些复杂但语法纯熟的规则集更安全。

## 记录 PF 日志

在规则中使用 `log` 关键字告诉 PF 记录数据包。

```
pass out **log** on egress from lan:network to any
```

然而，如果没有额外的设置，这些日志将直接发送到 PF 日志设备 `pflog0`。要成功记录 PF 消息，你必须运行数据包过滤器记录器 `pflogd(8)`。如果你在引导时启动 PF，`pflogd` 会自动启动。否则，你必须通过命令行启动它。

需要记住的一点是，如果你正在使用状态检测，只有触发规则的第一数据包会被记录。属于同一状态的其它数据包不会被记录。若要记录状态连接中的所有数据包，给 `log` 关键字添加 `all` 修饰符，但请注意，这可能会生成非常大的日志。

```
pass out log **(all)** on egress from lan:network to any
```

记录日志在解决连接问题时特别有用。如果你认为应该允许通过的数据包被阻止了，请在你的 `block` 语句中添加记录，以查看哪个规则阻止了流量。

我不推荐记录所有内容，尤其是因为日志可能会变得相当大。有选择性地记录。例如，你可能不关心本地用户访问了哪些网站，但确实想了解传入流量。并且确保排除防火墙日志流量从你的数据包过滤器日志中，否则你很快会发现 PF 正在记录日志传输的传输，这些是传输日志的日志，从你传输日志的那一刻起……等等等等。

### 阅读 PF 日志

PF 以 `tcpdump(8)` 二进制格式记录日志。使用 `tcpdump` 来检查数据。若要仅将日志中的所有内容输出，告诉 `tcpdump` 读取日志文件。

```
# **tcpdump -r /var/log/pflog**
```

这可能会生成大量输出。参见 过滤 tcpdump 获取一些提示。

### 实时日志访问

*/var/log/pflog* 中的条目不是实时添加的；`pflogd(8)` 会缓冲其记录，直到写入日志信息变得有意义。要实时查看 PF 日志，请使用 `-i` 标志将 `tcpdump` 连接到 `pflog0` 接口。

```
# **tcpdump -i pflog0**
```

根据你记录的流量大小，这可能会产生大量令人难以承受的信息。你必须过滤 `tcpdump` 以使其变得有用。或者，如果你假装错过了我之前关于日志大小的警告，你可以编写一个单行命令，使用 `logger` 将你的 PF 日志作为文本发送到 `syslog`。

### 过滤 tcpdump

每个系统管理员都应该知道如何使用 `tcpdump`。这是你这样做的原因。

当你遇到特定连接的问题时，你可能不关心通过过滤器的每个数据包。你关心的是特定主机的流量。使用 `ip` 或 `ip6` 表达式指定一个 IP 地址。

```
# **tcpdump -i pflog0 ip host 192.0.2.2**
```

这将仅显示与此特定主机之间的流量。

为了进一步缩小范围并仅查看两个主机之间的流量，请使用 `and` 关键字结合主机。

```
# **tcpdump -i pflog0 ip host 192.0.2.2 and ip host 203.0.113.88**
```

也许你只对特定地址上的特定端口感兴趣。使用 `tcp` 或 `udp` 关键字和端口号进行过滤。

```
# **tcpdump -i pflog0 ip host 139.171.199.254 and tcp port 80**
```

读取 `tcpdump(8)` 手册页，以获取无数其他过滤选项的详尽列表。

如果你不喜欢使用 `tcpdump`，可以考虑使用 `pflow(4)` NetFlow 导出器。网络流是一个复杂的话题，但书籍 *网络流分析*（No Starch Press，2010）可能对你有所帮助。

### 规则集跟踪

有时候，知道一个数据包是否通过或失败并不足够。你知道数据包被阻止了，但不知道原因。你想要观察数据包通过规则，并看到哪些规则影响了它。

假设内部主机 192.0.2.226 无法连接到外部主机 203.0.113.34。日志将显示数据包被阻止，但不会显示原因。你可以特别让 PF 记录匹配规则。在你的 *pf.conf* 文件顶部添加如下一行：

```
match log (matches) from 192.0.2.226 to 203.0.113.34
```

这是一个标准的包过滤规则。你可以使用单个 IP 地址、端口号或其他任何合法的包过滤术语。重新加载你的包过滤规则。

打开 `tcpdump`，并根据你的 `match` 语句中的一个 IP 地址进行过滤。如果你使用 NAT，请过滤不改变的 IP 地址。

```
# **tcpdump -n -e -ttt -i pflog0 ip host 203.0.113.34**
Dec 17 18:05:07.773703 **rule 0/(match) match out on fxp0**: 192.0.2.226.24916
> 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 <mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]> (DF)
Dec 17 18:05:07.773708 **rule 2/(match) block out on fxp0**: 192.0.2.226.24916
> 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 <mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]> (DF)
Dec 17 18:05:07.773712 **rule 5/(match) pass out on fxp0**: 192.0.2.226.24916
> 203.0.113.34.22: S 1730871963:1730871963(0) win 16384 <mss 1460,nop,nop,
sackOK,nop,wscale 3,nop,nop,timestamp 597858150[|tcp]> (DF)
```

虽然我不会详细介绍阅读 `tcpdump` 输出的所有烦人细节，但你可以看到 PF 会记录与这个数据连接匹配的规则编号，以及规则是允许还是阻止了连接。如果连接涉及 NAT，你将看到实际和转换后的 IP 地址。

到目前为止，你已经了解了足够多的 PF 知识来保护一个小型网络。如果你需要更多，请务必查看 *PF 书籍，第 2 版*（No Starch Press，2010）。

现在，让我们看看 OpenBSD 中一些更奇特的功能。

* * *

^([48]) 洛卡斯能在一天内配置一个高可用防火墙集群吗？是的。他能在不搞砸一切的情况下在文本文件中搜索和替换 IP 地址吗？不行。
