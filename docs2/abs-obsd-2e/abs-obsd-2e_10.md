## 第十章. 保护您的系统

*Hackers at the gates?*

*Puffy the Barbarian*

*defends against fiends.*

![](img/httpatomoreillycomsourcenostarchimages1616079.png) 保护您的系统意味着确保您的计算机资源仅由授权人员用于授权目的。即使系统没有重要数据，它仍然有宝贵的 CPU 时间、内存、存储和带宽。认为他们的系统太不重要而不值得任何人闯入的人可能会发现他们的设备正在托管色情内容或中继针对工业或军事网站的攻击。如果您像我一样，您宁愿不发现您的计算机通过执法人员的敲门使政府机构瘫痪。

控制大量远程计算机变得越来越容易。每年，都会出现越来越多的用于渗透服务器的点击式工具包。当一位聪明的攻击者发布一个漏洞利用程序时，任何人都可以使用它。闯入计算机是一笔大生意，如果您的计算机没有受到保护，*将会*被渗透。唯一的问题是方式。

通常来说，入侵者不会闯入操作系统；他们侵入在操作系统上运行的服务器程序。即使是最偏执、默认安全性的操作系统也无法保护编写不良的程序免受自身的影响。OpenBSD 的 W^X 和地址空间布局随机化等特性在很大程度上保护了操作系统免受有缺陷程序副作用的影响，但程序本身仍然会崩溃和燃烧。OpenBSD 经过广泛的审计和测试，以消除最常见的安全漏洞，但无法保证每个安全漏洞都已根除。新特性不断出现，可能会以意想不到的方式与旧功能（以及彼此）交互。有关 OpenBSD 特定特性的更多详细信息，请查看*[`www.OpenBSD.org/papers/`](http://www.OpenBSD.org/papers/)*的论文和演示文稿集合。

没有任何单一的工具可以保护您的服务器免受所有威胁，也没有任何单一的工具适用于所有环境。了解 OpenBSD 的安全特性有助于您不仅理解工具的功能，而且了解何时应该使用它们以及何时它们对您的特定情况无济于事。最好的开始方式是理解威胁。

## 敌人是谁？

专门研究安全的书籍将攻击者划分为更小、更具体的群体，并包括各种边缘情况，但这不是您在这里的原因。我把潜在的攻击者分为四组：脚本小子、僵尸网络、不满的用户和熟练的攻击者。这些类别易于理解，包括您可能遇到的 99%的攻击者。

### 脚本小子

最常见的攻击者类型，脚本小子，不是系统管理员。他们是业余爱好者，下载攻击脚本并寻找防御薄弱、易受攻击的系统。

脚本小子很容易防御：保持你的软件更新，并遵循良好的计算实践。就像蝗虫一样，脚本小子很容易被压扁，但这个小东西实在是太多了！

### 恶意软件网络

恶意软件网络由被蠕虫或病毒破坏的机器组成，并从中央点控制。恶意软件网络的控制者可能会使用受害机器来寻找更易受攻击的主机，发送垃圾邮件，或者入侵安全网站。大多数恶意软件网络由 Windows 或 Linux 机器组成，但没有任何理由说明这样的蠕虫不能针对 OpenBSD。病毒作者需要付出很多努力，但如果他找到一个合适的安全漏洞，这是可以想象的。

幸运的是，恶意软件防御与脚本小子防御类似。如果你保持软件更新，安全配置你的服务器软件，并遵循良好的计算实践，你不必担心太多。

### 愤世嫉俗的用户

安全专家通常声称，系统合法用户是大多数安全问题的原因。^([26)] 合法用户最有可能知道你的安全漏洞在哪里，觉得系统规则不适用于他们，并且有必要的访问权限和时间来尝试破解你的安全。如果你告诉一个员工公司政策禁止他访问计算机资源，而这个员工觉得他*应该*有权访问，他可能会寻找绕过限制的方法。你可以修补所有服务器并使用直接敌对的防火墙来保护它们，但如果有人有物理访问权限并且知道 root 密码，你的保护措施就毫无用处。

从两个层面解决这个问题。第一个是技术层面：保持你的服务器修补和更新。第二个是人为层面：不要留下半完成或半文档化的项目。那个为了紧急接入而安装的未加密调制解调器？把它扔掉，或者给它设置一个密码。同样，对于运行在非标准端口上的 telnet 服务器也是如此。

隐藏式安全最差。当有特权的用户离开公司时，立即禁用他的账户，更改所有管理密码，通知员工该人员的离职情况，并提醒他们不要与该人员共享机密信息。实施具有实际违规处罚的计算机安全政策。如果你有人力资源部门，让员工同意该政策并坚持他们执行它。

防止愤世嫉俗的用户最好的方法是什么？不要懒惰。

### 技能攻击者

作为最危险的一群人，熟练的攻击者包括合格的系统管理员、安全研究员、渗透专家以及想要访问特定资源的犯罪分子。如今控制计算机已经成为一项有利可图的生意。发送垃圾邮件或发起分布式拒绝服务攻击可以带来大量金钱。这些入侵者不在乎他们攻击谁，只要他们能确保获得所需的计算资源。

然而，如果你的公司有宝贵的机密信息，你可能会吸引到完全不同类型的入侵者：那些特别想要访问你网络的人。如果你的雇主从软件到前轮驱动车辆的铸铁郁金香都有所创造，那么你的产品很可能存在非法复制品的市场。有人会认为探测你暴露给互联网的每个 IP 地址上的每个端口是值得的。这可能需要很长时间，但没关系。你的数据有价格标签，而扫描是便宜的。这通常被称为高级持续性威胁，或 APT。

阻止其他类型入侵者的安全措施也会影响熟练攻击者所使用的技巧。如果你已经放弃了那个不安全的入站访问方法，入侵者就找不到它。如果你的服务器和程序都是最新版本并且配置正确，入侵者将需要找到之前未知的漏洞来入侵你的网络。如果一个熟练的入侵者真的想要获取*你的*公司的数据，他需要改变策略。他可能会尝试翻垃圾桶寻找旧粘性便签，或者甚至装扮成电信维修工试图安装数据嗅探器。如果一个入侵者对你的网络了如指掌，而他最容易的入侵方式*仍然*是来自冒险电影中的场景，那么你的安全状况相当不错。

### 注意

“黑客”这个词的含义因人而异。在技术界，黑客不仅对技术的内部运作感兴趣，而且能够创造新技术。媒体已经将这个词的含义转变为“入侵计算机的人”。我建议完全避免使用“黑客”这个词，而使用“入侵者”或“贪婪的吸脂猪狗”等术语。当然，何时使用每个术语取决于你。

## OpenBSD 安全公告

防御所有类型入侵者的最佳防线是保持你的计算机软件更新。这意味着你需要知道何时更新你的系统以及更新什么。OpenBSD 项目维护了一个低流量的邮件列表，*security-announce@OpenBSD.org*，专门用于向用户广播新的安全警报。请订阅此列表。

如果你不想再订阅另一个邮件列表，这些安全警报也发布在 OpenBSD 特定的网站上，例如 *[`www.undeadly.org`](http://www.undeadly.org)*。

注意，这不会为在 OpenBSD 上运行的第三方软件提供安全警报。你必须单独为这些程序获取更新。查看软件的网站以获取有关如何获取其安全公告的详细信息。如果你忽视更新而有人劫持了不安全的 Web 应用程序，那么你花费在保护操作系统上的所有时间都将浪费。

## OpenBSD 内存保护

最常见的入侵途径之一是攻击计算机内存中的内容。如果入侵者能够访问他们不应能够访问的内存，或者他们能够使程序访问不应访问的内存，他们就有无数种方法进入系统。

OpenBSD 包含了一系列系统内存的安全特性，系统管理员实际上从未真正看到过。你不需要开启不可执行的堆栈；它只是在那里。

其中一些特性仅在 OpenBSD 中出现。一些首先出现在 OpenBSD 中，然后传播到其他地方。一些来自研究论文。其他则是基于硬件特性。

OpenBSD 团队在安全特性方面比许多其他项目更加积极主动。以几年前 ProPolice 的部署为例。ProPolice 是一种编译器特性，可以防止某些类型的缓冲区溢出。在早期启用 ProPolice 时，许多软件无法构建。甚至更多软件可以构建，但在使用时崩溃。这些失败不是 ProPolice 的问题。ProPolice 只是暴露了软件中的编程错误。但许多用户和开发者说，“启用 ProPolice 会破坏所有东西，所以不要启用它。”

OpenBSD 团队在开发快照中默认启用了 ProPolice。发生了什么？很多问题——很多问题——都出现了。许多 OpenBSD 用户需要的第三方应用程序要么无法构建，要么无法运行。第三方应用程序的供应商开始收到来自 OpenBSD 用户的错误报告，他们能够确切地说明软件是如何出错的。软件供应商开始修复错误。

ProPolice 并没有导致这些崩溃；它只是暴露了错误。通过默认启用 ProPolice，OpenBSD 为免费软件世界提供了修复这些错误的动力。最终，随着 ProPolice 揭示的错误类型变得越来越不常见，其他操作系统也启用了 ProPolice。OpenBSD 愿意采取这一步骤，提高了整体计算机的安全性。

如果你密切关注 OpenBSD 的开发，预计会看到更多这样的行为。OpenBSD 团队做他们认为最正确的事情，而不是最方便或最容易的事情。

你应该了解的常见内存安全特性包括 W^X、.rodata 段、保护页、随机内存分配、ProPolice 以及保护`atexit`和`stdio`。我们将逐一介绍。

### W^X

W^X 代表写或执行。一旦程序被加载，该程序在内存中的页面要么是可写的，要么是可执行的，但不能同时两者都是。

一种常见的攻击技术是欺骗程序将信息写入内存，然后执行该内存片段。攻击者可能会说服程序将信息写入一块内存，但内核不会允许执行该内存。

一些硬件平台（如 amd64）具有 W^X 的硬件支持。如果存在这种支持，OpenBSD 会使用它。

### .rodata 段

传统上，包含程序代码的内存段通常有两个部分：实际代码和只读数据，或*.rodata 段*。在过去，一些操作系统允许程序修改只读内存。OpenBSD 通过利用硬件功能（如果可用）来防止这一点。

### 保护页

许多软件在访问它们分配的内存之外时都会出现问题。如果一个程序写入不属于它的内存，它就是在写入属于另一个程序的内存。入侵者利用这一点来利用程序。*保护页*是紧挨着程序分配的内存的单页内存。程序不能写入此内存。如果程序尝试写入保护页，它很可能会崩溃。通过强制执行此限制，OpenBSD 保护其他程序。

在所有地方使用保护页会消耗大量内存，因此 OpenBSD 只在仔细选择的位置启用保护页。

### 地址空间布局随机化

传统上，计算机连续分配内存。这可能会给入侵者带来某些优势。如果他们知道程序 A 通常在程序 B 之后加载，并且他们知道他们可以让程序 B 写入其分配之外的内存空间，他们可以猜测他们可以写入程序 A 的内存空间并使程序 A 以可预测的方式失败。这样做需要一定的技能，但一旦有人发现这种利用方法，无数的人都可以使用它。

OpenBSD 随机化内存分配的位置。连续启动的两个程序不会获得连续的内存块。这种随机化是智能的，以避免浪费内存。入侵者不能以这种方式利用一个程序攻击另一个程序。

### ProPolice

ProPolice 保护代码免受操纵内存栈的攻击。当代码编译时，ProPolice 会添加额外的代码以使程序保持在它自己的内存区域。如果 ProPolice 确定特定的内存区域（称为*金丝雀*）已被更改，它将立即终止程序。与其他内存保护技术防止写入可执行内存不同，当可写入的内存（*可以*写入，但具体*不应该*写入）被更改时，ProPolice 会终止进程。

### 以及更多！

OpenBSD 包含大量分散的小内存保护器。以下是一些小样本：

+   `malloc()`和`atexit()`系统调用在更新后标记内存为不可写。

+   文件描述符处理已经经过仔细审计。

+   当不涉及浮点数时，`snprintf`是异步信号安全的。

列表还在继续。

这些在现实世界中是否可能被利用？其中一些已经被利用，而另一些只是理论上的。但我会更愿意保护自己免受理论威胁，而不是假设没有人能破坏从未被破坏过的事物。

## 文件标志

所有类 Unix 操作系统都共享一个通用的权限方案，但 OpenBSD（以及大多数基于 BSD 的操作系统）通过*文件标志*扩展了权限方案。文件标志与权限一起工作，以改变文件安全性。标志可以使文件不可更改，使得现有数据无法被删除，用户只能向文件中添加内容，并产生其他几种效果。一些标志的功能与安全性无关，但我们将特别关注安全标志。文件标志在`chflags(1)`中列出并文档化。

### 文件标志类型

许多文件标志的效果取决于系统安全级别，我们将在下一节中介绍。理解安全级别的工作原理需要理解文件标志，而文件标志依赖于安全级别。在此期间，当我提到安全级别时，只需点头微笑。一切都会变得清晰，请相信我。

OpenBSD 的 UFS 和 UFS2 文件系统支持以下文件标志：

> **`sappnd`**
> 
> 带有系统级别只读标志的文件可以被添加，但不能被删除或以其他方式编辑。`sappnd`标志特别适用于日志文件。例如，常见的入侵者策略是删除*.history*或将它符号链接到*/dev/null*，这样管理员就无法看到发生了什么。如果账户被入侵，在用户的*.history*文件上设置`sappnd`标志可能很有趣。使用`sappnd`标志可以确保入侵者不能以这种方式掩盖他们的踪迹。只有 root 可以设置或删除`sappnd`标志，并且当系统在安全级别 1 或更高时，此标志不能被删除。
> 
> **`uappnd`**
> 
> 用户级别的只读标志只能由文件所有者或 root 设置。与`sappnd`类似，带有`uappnd`标志的文件可以被添加，但不能被其他方式编辑或删除。这对于个人日志和文件非常有用；它主要增加了一层额外的保护，以防止用户意外删除自己的文件。所有者或 root 可以设置或删除此标志。
> 
> **`schg`**
> 
> 带有系统级别不可变标志的文件不能以任何方式更改。它们不能被编辑、移动、替换或覆盖。基本上，文件系统本身阻止了所有尝试更改此文件的行为。只有 root 可以设置或删除此标志，并且当系统在安全级别 1 或更高时，此标志不能被删除。
> 
> **`uchg`**
> 
> 用户级别的不可变标志阻止任何人更改文件。这是一个用户级别的标志，因此 root 可以覆盖它。这个标志有助于防止文件被意外编辑或删除，但它不是确保系统安全的方法。所有者或 root 可以在任何安全级别设置或删除此标志。
> 
> **`nodump`**
> 
> 无备份标志告诉 `dump(8)` 不要备份文件。在不需要备份到磁带的文件上设置此标志。查看您的备份程序文档，以了解它是否尊重此标志。

### 设置、查看和移除文件标志

使用 `chflags(1)` 设置文件标志。例如，如果您非常担心有人更改您的内核文件，您可以使用系统级别的不可变标志标记 */bsd*。

```
# **chflags schg /bsd**
```

这将阻止任何人——包括您自己——更改内核、重新配置内核或升级系统。

您也可以使用 `-R` 标志递归地更改整个目录树上的文件标志。如果您想使 */bin* 下的所有内容都不可变，您将运行以下命令：

```
# **chflags -R schg /bin**
```

然后，您将无法再升级您的系统。

要查看文件上的标志，请使用 `ls -lo`。

```
$ **ls -lo vitallog**
-rw-r--r-- 1 root wheel - 20915343 Jul 17 16:56 vitallog
```

此文件上没有设置任何标志。让我们设置系统级别的只读标志。

```
$ **chflags sappnd vitallog**
chflags: vitallog: Operation not permitted
```

哦，对了——只有 root 用户可以设置系统级别的标志。让我们再试一次：

```
$ **sudo chflags sappnd vitallog**
Password:
$ **ls -lo vitallog**
-rw-r--r-- 1 mwlucas mwlucas sappnd 20915343 Jul 17 16:56 vitallog
```

此文件现在具有 `sappnd` 标志。系统可以添加到它，但不能对其进行其他编辑或删除。

OpenBSD 默认不标记任何文件，因此如果您想设置标志，您需要自己添加。然而，在您疯狂地添加标志之前，请注意，添加文件标志会增加系统维护的开销。如果升级系统很困难，系统管理员可能不想这样做。在 */bin* 中使所有程序不可变是否更安全，或者简化升级、更新和安全补丁的应用是否更安全？

要从文件中移除标志，请使用带有标志名称之前 `no` 的 `chflags`。例如，要取消 *vitallog* 文件上的 `sappnd` 标志，尝试以下操作：

```
$ **sudo chflags noschg vitallog**
Password:
chflags: vitallog: Operation not permitted
```

等一下！我正在使用 `sudo(8)` 运行，并且我有 root 级别的权限。发生了什么事？

默认情况下，OpenBSD 运行在 securelevel 1。在 securelevel 1 或更高级别运行时，您不能取消系统级别的文件标志，因此尝试取消设置将失败。您只能在 securelevel -1 或单用户模式下移除这些标志。继续阅读以了解 securelevel。

## Securelevel

`securelevel(7)` 是一个内核设置，用于限制系统可以执行的操作。随着 securelevel 的提高，内核的行为会有所不同。例如，在低 securelevel 下，上一节中讨论的文件标志可以被移除；文件可能被标记为不可变，但您可以移除标记、删除或编辑文件，并恢复标志。然而，当您提高 securelevel 时，您将无法再移除标志。系统其他部分的类似更改也会发生。整体来看，这些更改可能会挫败或阻止入侵者。

Securelevel 设置范围从 -1 到 2。尽管 OpenBSD 默认运行在 securelevel 1，但您可以根据您的环境更改此设置。

较高的 securelevel 会使得系统维护变得困难。在正常升级和管理过程中采取的许多操作也可能是入侵者用来掩盖行踪的行为。您可能需要在 securelevel 2 上运行一个高度安全、稳定的服务器，并在 -1 上运行您的实验性机器。另一方面，OpenBSD 的人不鼓励更改默认的 securelevel。在 -1 上运行您的系统可能会使您容易受到攻击，而在 2 上运行则会使得管理和维护变得复杂。您选择的 securelevel 取决于您的环境。

尽管名字如此，securelevel 并不是一个万能的安全调节器。随意提高 securelevel 除了让您和您的用户感到烦恼外，不会产生任何作用。虽然您可以在任何时候提高 securelevel，但您不能在不重启系统的情况下降低 securelevel，所以不要盲目实验。

### 设置系统 securelevel

在 */etc/rc.securelevel* 中设置引导时的 securelevel。在该文件中，您会找到如下类似的行：

```
securelevel=1
```

将 `1` 改为您想要的 securelevel。在您下一次重启时，系统进入多用户模式时会进入此 securelevel。如果您需要在引导过程提升 securelevel 之前运行一个进程，请将启动进程的命令放入此文件。

如果您想在不停机的情况下提升 securelevel，请调整 `kern.securelevel sysctl(3)` 到所需的值。

```
# **sysctl kern.securelevel=2**
kern.securelevel: 1 -> 2
```

记住，您不能降低正在运行系统的 securelevel。如果系统管理员可以降低 securelevel，那么入侵者也可以。

### Securelevel 定义

OpenBSD 有四个 securelevel：-1、0、1 和 2。我们将逐一介绍。

#### Securelevel -1

Securelevel -1 也被称为永久不安全模式。系统并不一定是不安全的——只是没有任何 securelevel 保护措施。我只使用 securelevel -1 来移除我一开始就不应该使用的文件标志。

#### Securelevel 0

Securelevel 0 仅在系统首次启动时使用。它不提供任何特殊功能。然而，当系统达到多用户模式时，securelevel 会自动提升到 1。在 */etc/rc.securelevel* 中设置 `securelevel=0` 在功能上等同于设置 `securelevel=1`。

#### Securelevel 1

在 OpenBSD 的默认 securelevel 1 下，事情变得有趣。

securelevel 影响某些内核配置设置，称为 sysctl（在第十八章中介绍）。在引导过程的早期，OpenBSD 使用 */etc/sysctl.conf* 中的设置来设置 sysctl。当我说某个特定的 sysctl 不能更改时，请将其理解为“不改变配置和重新启动”。

Securelevel 1 实现以下限制：

+   没有人可以写入 */dev/mem* 和 */dev/kmem* 设备。许多安全漏洞都是通过写入这些设备来实现的。

+   所有挂载的文件系统的原始磁盘设备都是只读的。（向挂载文件系统的原始设备写入会允许你更改文件而不考虑权限。）程序应该只通过文件系统访问挂载的文件系统，所以这不会改变日常操作。

+   系统级别的文件标志 `schg` 和 `sappnd` 不能被移除。

+   内核模块不能加载或卸载。OpenBSD 支持内核模块，但默认内核是单片的。在运行的生产系统上加载内核模块没有合法的理由。

+   sysctl `fs.posix.setuid` 不能更改。默认情况下，`chown(1)` 会根据 POSIX 标准清除文件上的 `setuid` 和 `setgid` 位，当更改文件权限时。你可以通过将 `fs.posix.setuid` 设置为 0 来覆盖此设置。

+   sysctl `hw.allowpowerdown` 不能更改。这控制着电源按钮与系统的交互。当设置为 1 时，短暂按下电源按钮会干净地关闭系统。当设置为 0 时，电源按钮不会关闭系统。（你仍然可以通过按住电源按钮几秒钟来关闭系统，但这不是干净关闭。）并非所有平台都支持这种关闭或电源管理。

+   sysctl `net.inet.ip.sourceroute` 不能更改。源路由是一种允许数据包发送者控制数据包在网络中采取的路径的技术。它已经引起了许多安全问题，并且其使用通常是不被鼓励的。OpenBSD 默认忽略源路由。将 `net.inet.ip.sourceroute` 设置为 1 会强制 OpenBSD 注意源路由。

+   sysctl `machdep.kbdreset` 不能更改。当设置为 1 时，`machdep.kbdreset` 允许系统通过 CTRL-ALT-DELETE 清洁重启。当此 sysctl 设置为 0 时，系统会忽略 CTRL-ALT-DELETE。

+   `ddb.console` 和 `ddb.panic` sysctl 可能不能提高。提高这些 sysctl 启用某些内核调试选项。未经授权的用户如果能够提高这些 sysctl，通过调试器可以获得无限系统访问。

+   sysctl `machdep.allowaperture` 不能提高。如果你想使用 X Window 系统（在第十七章中讨论），你必须通过在引导过程中早期启用此 sysctl 来允许 X 访问内核内存的特定部分。如果你没有运行 X，没有人有合法理由需要这种访问。

+   通用输入/输出（GPIO）控制器不能进一步配置。GPIO 控制器支持各种特殊用途的硬件。请参阅 `gpio(4)` 和 `gpioctl(8)` 以获取每个控制器的详细信息。

这些限制对日常操作的影响很小，但可能会干扰调试。如果你正在尝试找出为什么你的 GPIO 设备不工作，你可能想将你的 securelevel 设置为 -1。

#### Securelevel 2

Securelevel 2 是 OpenBSD 中的最高 securelevel，它禁用了在正常维护期间可能需要的各种功能。只有在稳定且不打算进行太多更改的机器上才应使用 securelevel 2。如果你需要更改 securelevel 2 限制的内容，你必须重新启动机器。

Securelevel 2 包含了 securelevel 1 的所有内容，以及以下内容：

+   原始磁盘设备始终是只读的。即使它们未被使用，你也不能格式化、fdisk 或 disklabel 磁盘。

+   系统时钟不能倒退，也不能接近溢出点。在进入多用户模式之前，请确保你的系统时间正确！

+   你不能更改数据包过滤规则（在第二十一章和第二十二章中介绍）。数据包过滤器、网络地址转换（NAT）、流量队列等都是不可变的。

+   内核调试器 sysctl 值（以 `ddb` 开头的）不能更改。

因此，例如，除非你了解数据包过滤规则只能通过重启来更改，否则你不想让你的防火墙在 securelevel 2 上运行。

### 你需要什么 Securelevel？

适合你环境的 securelevel 完全取决于你的情况，但绝大多数情况下，默认的 securelevel 1 是最合适的。

如果你正在调试和测试功能和工具，你可能会发现需要在开发机器上使用 securelevel -1。然而，一旦你解决了如何配置你的 GPIO 设备或系统的正确调试器设置，就使用 securelevel 1，以便在尽可能接近生产环境的情况下进行操作。

如果你有一个非常稳定的系统，你可以尝试使用 securelevel 2。然而，在我运行 OpenBSD 的这些年里，我只遇到过一次 securelevel 2 是正确的选择，还有几次 securelevel 2 带来的麻烦比它值得的要多。

### Securelevel 的弱点

Securelevel 能做什么？考虑一个场景，有人入侵了你的服务器上的一个网络应用程序，利用这个漏洞将自己提升到 shell 权限，然后使用 shell 提升到 root 权限。Securelevel 对此没有任何预防措施。

除非你大量使用了`schg`标志，入侵者可以用发送你的认证凭据到以虚假名字注册的免费电子邮件账户的系统二进制文件来替换。所以你决定四处奔波，将`schg`标志应用到像*/bin*和*/usr/lib*这样的关键目录的内容上。这样就能阻止那个家伙了！嗯，只要把每个文件都设置为不可变，包括*/etc*中的系统配置文件——你知道，你需要更改这些文件来完成你的工作——那么这就会有效。如果你留下一个文件没有保护，入侵者可以在系统启动的早期部分添加一个命令，比如`chflags -R noschg /`，那么下次你重启系统时，你所有的文件都会被解锁。你多久会彻底审计一次你的*/etc*文件？而且每次修补或升级系统时，你都需要撤销这个复杂的混乱！

这只是一个可能的方法。入侵者进入系统的途径有很多。依赖 securelevels 来保护你是不明智的。使用它们，并将它们视为你的工具箱中的一个工具，但不要认为它们是每个问题的万能药。

## 保持安全

本章讨论的工具并不是 OpenBSD 的唯一安全特性。OpenBSD 团队已经投入了大量工作来确保系统的每个部分都安全。但本章涵盖了使 OpenBSD 特殊的一些内容，并给你一个了解这些功能如何工作的想法。

通往安全的最佳路径是什么？保持你的系统更新，并安全地配置你的服务器守护进程。这很无聊，但有效。

* * *

^([26]) 我看到太多僵尸网络或脚本小子入侵几个月都没有被发现，因此我不太愿意将大多数安全问题归咎于合法用户。我同意“内部入侵”是最常见的入侵方式，但通常是因为有罪的用户无法闭嘴。
