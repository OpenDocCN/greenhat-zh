## 第五章. 引导过程

*单用户模式*

*夜间不按计划进行？*

*有什么东西“砰”的一声爆炸了！*

![引导加载程序](img/httpatomoreillycomsourcenostarchimages1616079.png) 为了正确管理任何计算平台，你必须了解引导过程。许多系统管理任务在系统运行时无法完成。OpenBSD 特别要求在引导过程完成之前完成某些任务。当然，在任何操作系统上，有时启动进程会阻止系统完成引导。解决这些问题的唯一方法是中断引导过程。

首先，我们将探讨 OpenBSD 引导过程的关键：引导加载程序。然后，我们将继续讨论单用户模式，最后是多用户启动。在这些阶段中，你可以执行一些有用的工作。

我建议在机器无法引导之前在测试机器上玩 OpenBSD 引导过程。这样，当凌晨时分出现问题，你可以花时间解决问题，而不是笨拙地使用不熟悉的命令。

## 开机与引导加载程序

通常，当 PC 风格的计算机首次引导时，它会启动 BIOS。BIOS 是一小块软件，用于确定哪些驱动器已连接以及它们连接到什么，安装了哪种 CPU，以及有多少可用内存。在获取这些信息后，BIOS 从某种存储设备加载一个最小引导加载程序。^[[11]

*引导加载程序* 是一个小程序，负责处理初始系统配置并引导内核。它找到并启动内核，内核随后检测硬件，附加设备驱动程序，并执行其他核心设置。最后，内核调用 `init(8)`，该程序启动进程并启用用户程序、网络接口、服务器软件等。

虽然大多数此过程无法管理——没有人实际配置 `init`！——但在系统完成引导并将你置于登录屏幕之前，你可以做很多事情。

OpenBSD 引导加载程序允许你在引导过程中中断，在引导之前配置系统，调整内核设置，甚至引导备用内核。

当硬件将引导过程控制权交给 OpenBSD 分区时，你会看到引导加载程序提示符，其外观可能如下所示：

```
>> OpenBSD/amd64 BOOT 3.18
boot>
```

引导加载程序的主要目的是找到内核，将其加载到内存中，并启动它。因为它在内核启动之前运行，所以引导加载程序可以向内核本身传递指令。

在引导完成之前，你可以执行以下操作：

> 使用内置帮助
> 
> 使用 `help` 函数打印引导加载程序支持的命令的简要列表。
> 
> ```
> boot> **help**
> commands: # boot echo env help ls machine reboot set stty time
> machine: boot diskinfo memory
> ```
> 
> 延迟引导过程
> 
> 默认情况下，加载程序等待五秒钟以获取指令，然后引导内核。要在提示符处暂停引导，请按空格键。
> 
> 设置引导超时
> 
> 要设置新的引导空闲超时，请使用 `set timeout` 命令指定秒数。
> 
> ```
> boot> **set timeout 10**
> ```
> 
> 在引导提示符空闲 10 秒后，系统应该启动。
> 
> 启动系统
> 
> 如果你暂停了引导过程，系统将不会启动，直到你告诉它。当你准备好启动时，使用`boot`命令：
> 
> ```
> > **boot**
> ```

我们将使用`boot`的各种排列组合来配置内核、启动单用户模式等。我将在适当的部分介绍其他引导命令。有关引导提示符上可以执行的所有操作的完整细节，请阅读`boot(8)`手册页。

## 以单用户模式启动

单用户模式是 OpenBSD 最早可以给你 Unix 风格 shell 提示的位置。在这个时候，内核已经探测了所有硬件，将驱动程序附加到它将要认可的所有硬件上，并启动了`init`。系统除了根分区外没有挂载任何文件系统，根分区是以只读模式挂载的。网络尚未启动，没有服务正在运行，安全性未实现，文件系统权限被忽略。

要以单用户模式启动 OpenBSD，请在引导提示符下输入**`boot -s`**。

```
boot> **boot -s**
```

为什么你想以单用户模式启动？如果你的计算机有问题阻止它启动，你应该能够访问单用户模式并修复问题。假设一个失败的磁盘阻止了系统在多用户引导期间启动，或者你更改了*/etc/ttys*中的终端设置，现在你无法登录到系统。或者你可能将一个愚蠢的设置放入*rc.conf.local*，引导过程挂起，因为它正在尝试做一些不可能的事情。在这些时候，单用户模式是你的最佳朋友。

此外，一些系统管理任务，如清除文件系统标志（见第八章），只能在单用户模式下完成。

### 以单用户模式挂载磁盘

通常，在单用户模式下进行任何操作之前，你应该有一个完全功能的文件系统。如果你的系统崩溃了，在挂载它们之前，务必检查文件系统的完整性：

```
# **fsck -p**
/dev/sd0a (e4bf0318329fe596.a): file system is clean; not checking
/dev/sd0h (e4bf0318329fe596.h): file system is clean; not checking
…
# **mount -a**
```

`fsck`和`mount`有许多更多选项。我们将在第八章（第八章。磁盘和文件系统）中更详细地介绍它们。

一旦挂载了所有文件系统，所有常规的命令行软件都应该可用。你应该能够编辑配置文件、启动和停止程序，并且通常可以对你喜欢的系统进行任何操作（包括破坏它）。

### 以单用户模式启动网络

使用 shell 脚本*/etc/netstart*在单用户模式下配置网络。（你可以手动运行所有适当的命令，但*/etc/netstart*将读取你的系统配置文件并为你完成繁琐的工作。）你必须通过`sh`显式运行此脚本：

```
# **sh /etc/netstart**
```

如果你因为网络问题而以单用户模式启动，这个脚本会方便地为你重现问题。

## 启动备用内核

正如我们在第十八章中将要详细介绍的，你可以配置 OpenBSD 内核，但在这样做之前，请确保你可以引导其他内核。如果你损坏了文件系统到连单用户模式都无法引导的程度，你需要能够引导不同的内核，并使用安装内核进行恢复。

### 引导不同的内核文件

OpenBSD 安装程序默认包含三个内核：单处理器内核 */bsd*，多处理器内核 */bsd.mp*，以及升级和安装内核 */bsd.rd*。（如果你的机器有多个处理器，安装程序会将 */bsd* 重命名为 */bsd.sp*，将 */bsd.mp* 重命名为 */bsd*。）

要引导非标准内核，首先重启并中断引导过程，在引导加载程序提示符下运行`boot`，并给出你想要引导的内核的完整路径：

```
boot> **boot /bsd.rd**
```

这将使用你选择的内核启动系统。你也可以使用其他引导选项，例如以单用户模式引导备用内核：

```
boot> **boot -s /bsd.sp**
```

这将让你能够从损坏的内核中恢复，尝试新的内核，或者介于两者之间的任何东西。

### 从备用硬盘引导

假设你真的把一切都搞砸了，你的根分区上没有可用的内核。幸运的是，如果你在另一个硬盘上有可用的内核，你可以从那个硬盘引导。通常，这个内核位于备用根分区，*/altroot*，如第八章中所述。）在本节中，我将把从那个备用内核引导的任务分解成几个步骤：找到包含分区的硬盘，找到包含文件的分区，并在该分区上引导正确的文件。

#### 寻找硬盘

一旦你熟悉了 OpenBSD，你可能会开始根据它们的设备名称来考虑系统中的硬盘，例如*/dev/sd0*，*/dev/wd1*等等。不幸的是，这些是内核对磁盘的命名；引导加载程序只识别 BIOS 的磁盘名称。

要询问引导加载程序关于磁盘的信息，请使用`machine diskinfo`命令：

```
boot> **machine diskinfo**
Disk    BIOS#   Type    Cyls    Heads   Secs    Flags   Checksum
fd0     0x0     *none*  80      2       18      0x4     0x0
hd0     0x80    label   1024    255     63      0x2     0x51db843d
hd1     0x81    label   1024    255     63      0x2     0x9329b723
hd2     0x82    label   1024    255     63      0x2     0xcfadb343
boot>
```

在这里，引导加载程序找到了四个磁盘设备。第一个，`fd0`，是一个软盘驱动器。这个驱动器可能没有磁盘，或者有磁盘，但无论它有什么，几乎可以肯定它不是你的备用内核。（它可能是一个安装盘，所以不要自动排除用于灾难恢复的可能性。）

其他三个设备—`hd0`，`hd1`和`hd2`—是硬盘。第一个，`hd0`，是默认的系统引导盘。如果你不能从这个磁盘引导，你需要找到包含你的内核的硬盘。

#### 寻找分区

从输出中模糊的记忆让我想到`hd2`可能是包含我的备份根分区的磁盘。为了尝试它，告诉加载程序磁盘分区`hd2a`是新的根分区：

```
boot> set device hd2a
```

在尝试从这个分区引导之前，看看它的内容：

```
boot> **ls**
stat(hd2a:/.): Invalid argument
boot>
```

显然，磁盘 `hd2` 没有分区 `a`。在服务恢复后，我会把这块磁盘放在车库后面，把它的问题打掉。现在，让我们尝试剩下的唯一磁盘，`hd1`。

```
boot> **set device hd1a**
boot> **ls**
drwxr-xr-x 0,0  512     .
drwxr-xr-x 0,0  512     ..
drwxr-xr-x 0,0  512     altroot
drwxr-xr-x 0,0  512     home
drwxr-xr-x 0,0  512     tmp
…
```

这看起来像是一个实际的根分区（`altroot` 提供了提示）。

#### 引导内核

在这一点上，我们可以引导不同的内核，但我们将只以单用户模式引导这个分区上的 */bsd* 内核，因为文件系统表将会有错误的根文件系统条目，这会搞砸各种东西。

```
boot> **boot -s**
booting hd1a:/bsd: 5669864+1601484+935608+0+617568 [89+499848+323884]=0xd351b8
…
```

或者，您也可以在引导提示符处给出设备名称：

```
boot> **boot -s hd1a:/bsd**
```

作为一般规则，您应该在 */mnt* 上挂载实际的根分区，进行必要的更改以进行正常操作，然后重新引导到正确的根分区。您还可以引导 */bsd.rd* 内核，这将使引导更加干净，但可用的工具会减少。

## 将引导加载程序设置永久化

要使引导加载程序选项永久化，请编辑 */etc/boot.conf*。引导加载程序在给您 `boot>` 提示符之前读取并运行此文件中的条目，这意味着您可以使用它来在每次计算机启动时自动运行引导加载程序命令。（尽管如果您宁愿每次重新启动时都坐在电脑前输入设置，请不要阻止我。）

您在引导加载程序提示符下可能给出的任何命令都是有效的 *boot.conf* 条目。例如，如果默认的引导速度太慢，您可以通过在 *boot.conf* 中添加此行来将引导超时设置为两秒：

```
set timeout 2
```

您还可以使用正确的 *boot.conf* 命令告诉系统引导不同的内核。

```
set image /bsd.mp
```

到目前为止，*boot.conf* 最常用于配置串行控制台。

## 串行控制台

所有这些巧妙的引导功能都让您在系统出现问题时能够做些有用的事情，但您如何在不坐在电脑前的情况下使用它们呢？如果您的电脑在国家的另一边的数据中心，或者坐在十年工资记录背后的地下室里，串行控制台会让您的生活更加愉快。

硬件串行控制台允许您在计算机和终端服务器（在另一台计算机上）之间运行串行电缆，以访问 BIOS 消息和操作系统引导和启动消息，从而简化远程系统的管理。在调试系统崩溃时，串行控制台也极其宝贵；错误消息通过串行端口发送，您可以轻松地捕获它们。^[[12]

真正的 UNIX 硬件具有串行控制台功能，大多数服务器级 i386 和 amd64 硬件也是如此。然而，大多数桌面级硬件则没有。但幸运的是，即使您没有硬件串行控制台，您也可以通过串行端口和软件串行控制台访问 OpenBSD 的所有启动消息。虽然 OpenBSD 的软件串行控制台不会让您访问硬件 BIOS，但它会允许您与引导加载程序接口，并在网络断开时远程访问系统控制台。

### 其他平台串行控制台

每个硬件平台都有自己的串行控制台标准。如果您运行的是不太常见的平台，请检查您的硬件文档。

如果您的硬件支持真实串行控制台，您通常应该在 BIOS 中进行配置。OpenBSD 支持硬件支持的任何功能，因此您的 Sparc64 硬件将像支持任何其他操作系统的串行控制台一样支持 OpenBSD 的串行控制台。

### 串行控制台物理设置

串行控制台需要一个 null modem 电缆，您应该可以从任何电脑店或在线供应商那里获得。虽然镀金电缆不值那么多钱，但也不要买最便宜的电缆。如果您有紧急情况，需要立即使用串行控制台，您可能不会愿意处理一根有缺陷的电缆。

将 null modem 电缆的一端插入您的 OpenBSD 机器的第一个串行端口。（串行控制台仅在第一个串行端口上受支持，或在 i386 和 amd64 硬件上的 `com0`。）将 null modem 电缆的另一端插入另一个系统的空闲串行端口。（为了简单起见，使用另一个 OpenBSD 或类 Unix 系统。）

如果您在远程位置有两台 OpenBSD 机器，并且想在两台机器上使用串行控制台，您可以让每台机器充当另一台的控制台客户端。将每台服务器的第一个串行端口连接到另一台服务器的第二个串行端口。如果您有三台机器，可以将它们串联成环。如果您有四台或更多机器，可以从您喜欢的拍卖网站上购买一台二手终端服务器。

您还可以使用两个 DB9-to-RJ45 转换器，一个标准和一个交叉，这将允许您通过标准 CAT5 电缆运行您的控制台连接。如果您有一个禁止人类进入（除非他们正在安装或拆除设备）的无人值守数据中心，您可以将串行控制台电缆延长约 12 米，这应该可以到达您的温暖房间。（大多数现代数据中心比串行电缆更适合处理 CAT5 电缆。）

### 串行控制台配置

现在您的控制台已经物理准备就绪，下一步是配置您的客户端以访问串行控制台。然后您可以设置串行控制台。

#### 配置串行控制台客户端

以下是一个 OpenBSD i386 或 amd64 系统的默认设置：

+   9600 波特

+   8 位

+   无奇偶校验

+   1 停止位

将这些值输入到客户端计算机上的任何终端仿真器中，串行控制台应该能够正常工作。您可以在 Microsoft 平台（我推荐 PuTTY）、OS X 和几乎所有其他操作系统上找到终端仿真器。

OpenBSD 包括终端模拟器`tip(1)`，它从`/etc/remote`读取其配置。`/etc/remote`中的`tty00`配置与 i386 和 amd64 系统的默认 OpenBSD 串行控制台配置相匹配（以及几个其他平台）。如果您将 null 调制解调器电缆连接到客户端的第一个串行端口，请使用以下命令连接：

```
# **tip tty00**
connected
```

如果没有显示`connected`，您的串行客户端配置不正确。在服务器上启用串行控制台之前，请修复您的客户端。您希望在配置控制台之前准备好串行客户端。

#### 设置串行控制台

OpenBSD 通常使用本地物理键盘、视频和鼠标作为控制台，但它也可以使用第一个串行端口作为串行控制台。

要设置控制台，请使用引导加载程序。您必须知道您首选控制台的加载程序设备名称：`com0`用于第一个串行端口或`pc0`用于物理连接的视频和键盘。

第一次尝试使用串行控制台时，请使用本地测试机器。事先设置您的客户端并启动您的终端模拟器，然后引导测试机器。在引导加载程序提示符下，输入以下命令：

```
boot> **set tty com0**
```

您服务器的显示器和键盘应该停止响应，如果您设置正确，您应该在终端模拟器中看到引导加载程序提示符。

要切换回物理控制台，告诉引导加载程序使用`pc0`设备：

```
boot> **set tty pc0**
```

嘭！服务器的键盘和显示器应该又能工作了。

要在每次引导时让您的机器使用串行控制台，请在`/etc/boot.conf`中添加此语句：

```
set tty com0
```

确保在机器安装到永久位置后测试您的串行控制台，并且始终将串行电缆拧紧在服务器上。松散的串行电缆只能提供一种安慰的错觉，但在最需要的时候会背叛您。

#### 测试串行配置

在配置您的串行控制台后，返回您的串行客户端并按回车键。您应该看到类似以下内容：

```
OpenBSD/amd64 (caddis.blackhelicopters.org) (tty00)
login:
```

### 修改串行控制台速度

较新的串行端口（意味着在过去 10 年内制造的任何端口）可以以远高于 9600 波特的速度运行。我有一些串行控制台运行速度仅为 115,200 波特的服务器。BIOS 信息以 115,200 波特显示，但 OpenBSD 控制台以 9600 波特运行。我的客户端显示为乱码。（许多 OpenBSD 用户认为不能以 9600 波特进行串行通信的任何东西都是损坏的，但您并不总是能控制您所使用的硬件。）

要使用这些端口，我可以在在切换 BIOS 信息和 OpenBSD 信息时更改我的串行控制台客户端的连接速度，或者更改 OpenBSD 控制台的速度以匹配硬件。

在引导加载程序中，告诉串行控制台以 115,200 波特运行：

```
boot> **stty com0 115200**
boot> **set tty com0**
```

如果这些设置有效，请将它们复制到`/etc/boot.conf`。

现在配置您的串行客户端。修改`tip`以使用更高的速度。首先，在`/etc/remote`中找到`tty00`条目：

```
tty00|For hp300,i386,mac68k,macppc,vax:\
        :dv=/dev/tty00:tc=direct:tc=unixhost:
```

但不要修改这个条目！我们将用它来说明 */etc/remote* 条目的风格。

### 注意

*/etc/remote* 的设计类似于一个 `termcap(5)` 数据库。如果你需要从头开始编写自己的 *`termcap`* 条目，那么你的生活方向就错了。但你可以识别内容并修改现有条目而不会感到太多痛苦。如果你真的想了解有关这些条目的所有内容，请阅读 *`remote(5)`* 手册页。

在这个条目中，反斜杠 (`\`) 表示“续到下一行”。冒号分隔字段。每一行在第一行之后都必须以冒号开头，并且每个字段都是一个键/值对。

现在，要创建一个以 115,200 波特率运行的控制台条目，请使用以下命令：

```
console:br#115200:tc=tty00:
```

*/etc/remote* 条目的第一个字段是名称，每个条目都必须有一个唯一的名称。我给这个条目命名为 `console`。第二个字段是 `br` 值。根据 `remote(5)`，`br` 代表比特率。我已经将比特率设置为 115,200 波特。第三个字段是 `tc`，代表“表继续”，等于 `tty00`。这意味着这个条目的描述将在 `tty00` 条目中继续。

整体来看，这个条目的意思是“复制 `tty00` 条目，并添加一个 115,200 的比特率。”

### 修改客户端串行端口

如果你有两个 OpenBSD 机器，每个机器都将其串行控制台发送到另一台机器的第一个串行端口，你必须告诉 `tip` 连接到第二个串行端口。命令 `tip tty00` 实际上并没有连接到名为 `tty00` 的串行端口——它连接到由 */etc/remote* 条目定义的端口，该条目名为 `tty00`。这意味着你不能运行，例如，`tip tty03` 并连接到串行端口 tty03，除非你有一个名为 `tty03` 的 */etc/remote* 条目。默认情况下，没有这样的条目，但你可以轻松地定义一个，如下所示：

```
tty03:dv=/dev/tty03:tc=tty00:
```

这个条目的名称是 `tty01`。`dv` 设置告诉 */etc/remote* 使用哪个物理设备。除了这个之外，所有设置都是从名为 `tty00` 的条目中复制的。

通过这些示例，你应该能够使用 OpenBSD 的 `tip` 连接到几乎任何串行控制台。

### 串行登录

串行控制台允许你与引导过程交互。然而，一旦你的机器完全进入多用户模式，默认的串行控制台将不会让你实际登录到 OpenBSD。在多用户模式下，OpenBSD 使用 `getty(8)` 初始化终端并处理登录，为了通过串行端口登录到你的机器，你需要告诉 `getty` 通过配置 */etc/ttys* 来接管串行线路。

我们将在 第十四章 中进一步讨论 */etc/ttys*，但到目前为止，以下是如何允许通过第一个串行端口进行登录的方法。找到名为 `tty00` 的条目，它应该看起来像这样：

```
tty00   "/usr/libexec/getty std.9600"   unknown off
```

删除最后两个单词，并将它们替换为以下内容：

```
tty00   "/usr/libexec/getty std.9600"   **vt220    on secure**
```

现在，运行 `kill -1 1`，你应该通过串行线路获得登录提示。

## 多用户启动

当内核完成核心设置并将控制权交给用户空间后，`init(8)` 运行 shell 脚本 */etc/rc*。此脚本处理所有系统设置，包括挂载文件系统、配置设备节点、识别共享库以及任何其他使系统可用的任务。一些任务委托给单独的脚本；例如，*/etc/netstart* 用于配置网络。

在本节中，我们将介绍 */etc/rc* 和其他启动脚本如何工作，以及启动过程的流程。有了这种理解，您应该能够轻松地配置您的 OpenBSD 机器启动您所需的确切内容——不多也不少。

### 启动系统脚本

启动系统包括脚本 */etc/rc*、*/etc/rc.conf*、*/etc/rc.conf.local*、*/etc/netstart*、*/etc/rc.securelevel*、*/etc/rc.local*、*/etc/rc.shutdown*、*/etc/rc.firsttime*、*/etc/fastboot* 以及 */etc/rc.d* 目录的内容。

#### /etc/rc 脚本

在 OpenBSD 上，从设置主机名到启动服务器守护进程，所有非内核内容都是通过 shell 命令配置的。主脚本是 */etc/rc*，它按正确顺序运行所有这些命令，确保每次引导时系统配置完全相同。作为最后一步，*/etc/rc* 运行 `getty(8)` 在所有适当的终端上显示登录提示。

除非您是一位经验非常丰富的系统管理员，并且有真正独特的需求，否则永远不要编辑 */etc/rc*。这是 */etc* 中可以技术上可编辑的几个文件之一，但普通人最好将其视为二进制文件。相反，每次您需要禁用功能时，请在 */etc/rc.conf.local* 中将其停用。要向启动过程添加新功能，请使用 shell 脚本 */etc/rc.securelevel* 和 */etc/rc.local*，或者为 */etc/rc.d* 编写 shell 脚本。

#### /etc/rc.conf 脚本

*/etc/rc.conf* 文件只包含所有其他启动脚本的默认值。阅读此文件以查看不同系统服务的配置选项。以下是您将在 *rc.conf* 中找到的片段之一：

```
…
bgpd_flags=NO           # for normal use: ""
rarpd_flags=NO          # for normal use: "-a"
bootparamd_flags=NO     # for normal use: ""
rbootd_flags=NO         # for normal use: ""
sshd_flags=""           # for normal use: ""
named_flags=NO          # for normal use: ""
…
```

如果变量设置为 `NO`，则默认禁用相关服务。

如您所见，OpenBSD 默认关闭几乎所有功能，只有一个例外：SSH 守护进程。将变量设置为成对的引号，如前一段代码片段中每个条目之后所示，就足以启用大多数守护进程，而且大多数守护进程在没有命令行标志的情况下运行得很好。然而，如果守护进程需要命令行参数才能运行，该参数将以 `-a` 附加到 `rarpd_flags` 中的原样显示。

### 注意

在冒着让我的服务器彻底崩溃的风险下，永远不要编辑 */etc/rc.conf*（将其视为二进制文件——记得吗？）在系统升级过程中，它将被全部替换。相反，将您的本地值放在 */etc/rc.conf.local* 中。

#### /etc/rc.conf.local 脚本

我之前已经提到过这一点，但我要反复强调：请将您的更改放置在 *rc.conf.local* 中。*rc.conf.local* 中的条目会覆盖 *rc.conf* 中的默认设置。

例如，假设在特定的机器上，您想以额外的调试方式运行 `sshd(8)`，并且您还想运行 `named(8)`。此外，您还想运行时间服务器 `ntpd(8)`，并在启动时使用 `-s` 标志来校正时间。在查阅了这些程序的文档后，您将以下行添加到 *rc.conf.local* 中：

```
sshd_flags="-D"
ntpd_flags="-s"
named_flags=""
```

OpenBSD 将启动此处指定的标志的程序。如果您指定了无效、不正确或不兼容的标志，守护进程将在控制台打印错误消息。

#### /etc/netstart 脚本

虽然其名称与其他脚本不同，但 */etc/netstart* 确实是一个系统启动脚本。它读取 */etc/mygate*、*/etc/myname* 以及所有 */etc/hostname.if* 文件，并使用其中的信息来配置所有网络接口、桥接、路由等。文件 */etc/rc* 在启动任何服务器守护进程、网络文件系统等之前运行此脚本。在单用户模式下，您需要手动运行此脚本以启动网络。

#### /etc/rc.securelevel 脚本

*/etc/rc.securelevel* 脚本在启动过程中较早运行，在 */etc/rc* 提高系统安全级别之前，但在启动网络之后。一旦提高安全级别，许多程序，尤其是那些接触内核或密切影响文件系统的程序，将无法运行。如果您运行这样的程序，可以将启动它的命令添加到此脚本中。如果您的本地程序不需要在系统安全级别提高之前运行，您最好从 *rc.local* 启动它或为其编写适当的 *rc.d* 脚本。

*rc.securelevel* 中的一个重要条目是系统安全级别的定义。我们将在 第十章 中讨论安全级别。现在，除非您已经熟悉基于 BSD 的系统并且确切知道您要采取哪种行动，否则不要触摸设置安全级别的行。

#### /etc/rc.local 脚本

在 */etc/rc* 完成几乎所有其他操作后，它会运行 */etc/rc.local*。您可以在 *rc.local* 中放置启动本地守护进程的命令，但最好编写一个 *rc.d* 脚本来启动本地守护进程，这样您可以轻松且一致地稍后重新启动它们。当然，如果您比较懒惰，可以使用 *rc.local*。

#### /etc/rc.shutdown 脚本

每次您使用 `reboot(8)` 或 `halt(8)` 时，OpenBSD 都会运行 */etc/rc.shutdown* 脚本，您可以依赖它来运行安全关闭服务器所需的额外命令。大多数服务器软件在没有特殊干预的情况下可以干净地关闭，但需要数据完整性的软件（如数据库）可能需要帮助才能安全关闭而不会丢失数据。再次提醒，如果可能的话，编写一个 *rc.d* 脚本来管理您的软件。

#### /etc/rc.firsttime 脚本

*/etc/rc* 一次运行 */etc/rc.firsttime* 脚本，将输出邮件发送给 root，并删除 *rc.firsttime*。安装程序使用 *rc.firsttime* 来执行诸如获取无法合法重新分发的固件等任务。虽然您通常不会使用 *rc.firsttime*，但您应该知道它存在，并且您可以使用它来在机器启动时执行一次性任务。

#### /etc/fastboot 脚本

如果 */etc/fastboot* 文件存在，OpenBSD 假定所有文件系统都是干净的（参见第八章），并且引导过程会跳过检查文件系统完整性。

#### /etc/rc.d 目录

如下一节所述，*/etc/rc.d* 目录包含用于管理软件的 shell 脚本。虽然系统附带了一些包含在 OpenBSD 中的软件的脚本，但附加包可以提供自己的脚本（参见第十三章）。

### 软件启动脚本

OpenBSD 使用 shell 脚本来启动、停止、重新启动、检查和重新配置服务器软件。这些脚本位于 */etc/rc.d* 目录中。OpenBSD 附带的所有服务器软件以及大多数需要脚本以正确启动和关闭的 ports 和 packages 都有这个目录中的脚本。使用这些脚本来管理集成软件，而无需重新启动服务器。

*rc.d* 脚本从 *rc.conf* 和 *rc.conf.local* 中读取其配置。大多数服务器运行 SSH 守护进程`sshd`，可以通过在 *rc.conf.local* 中添加行 `sshd_enable=""` 来启用它。查看 */etc/rc.d*，您会找到名为 *sshd* 的 shell 脚本。

如果您更改了您的`sshd`配置，您必须重新启动守护进程。使用 shell 脚本可以一致地完成此操作。

```
# **cd /etc/rc.d/**
# **./sshd restart**
sshd(ok)
sshd(ok)
```

当然，您也可以不使用 shell 脚本简单地通过识别当前运行的`sshd(8)`进程，阅读手册页以了解如何正确关闭它，然后使用相同的命令行标志重新启动它。对于`sshd`来说，这很简单：运行`pkill -1 sshd`会指示守护进程重新读取其配置文件。但是，重新启动需要各种标志的守护进程确实是一件大事。自动化这些系统管理任务确保您的守护进程始终运行。

要检查守护进程是否正在运行，请使用`check`命令检查您的 shell 的返回值。如果守护进程正在运行，脚本将返回`0`，如果没有运行，则返回`1`，如下所示：

```
# **./nfsd check**
# **echo $?**
1
```

如您通过`1`所见，`nfsd`并未运行。

`check`最常用的用途是在 shell 脚本中。您可以使用`start`参数启动守护进程，使用`stop`参数终止它。使用`restart`参数告诉守护进程重新加载其配置。

在 OpenBSD 中，*rc.d* 脚本在系统启动时运行，并在系统关闭时再次运行。（需要卸载所有这些硬盘驱动器，关闭守护进程，并清理。）在关闭时，*/etc/rc.d* 目录中的每个脚本都会使用`stop`参数调用。

### 第三方 rc.d 脚本

OpenBSD 的第三方软件包包括必要的 *rc.d* 脚本。例如，流行的数据库服务器 MySQL 的 `mysql-server` 软件包安装了脚本 */etc/rc.d/mysqld*。要使用该软件包，你必须将其在 *rc.conf.local* 中启用：

```
mysqld_flags=""
```

一旦启用该软件包，你就可以像管理任何其他 OpenBSD 守护进程一样管理你的 MySQL 服务器。然而，软件包化的软件在启动时仍然不会自动启动，所以你必须告诉 OpenBSD 在启动时运行这个特定的 *rc.d* 脚本，并在 *rc.conf.local* 中的 `pkg_scripts` 变量中关闭：

```
pkg_scripts="mysqld"
```

启动过程在启动时按给定顺序运行此变量中的脚本。对于某些守护进程，顺序很重要。例如，如果你有一个数据库驱动的网站，你应该在启动 web 服务器之前启动数据库。在关闭时，它以相反的顺序运行这些脚本。

### 强制启动软件

有时候你不想全局启用软件；你只想运行某个守护进程一段时间或解决特定情况。你可以使用 *rc.d* 脚本通过 `-f` 标志强制软件运行。

现在让我们来看一个现实生活中的例子。我之前在我的服务器上运行 PostgreSQL，但有人绑架了我的宠物老鼠，并威胁我使用 MySQL 以换取它们的平安归来。然而，我需要检查旧数据库中的某些数据，所以我强制启动了禁用的 PostgreSQL 服务器：

```
# **./postgresql -f start**
postgresql(ok)
```

如果你打包或安装自己的软件，我强烈建议编写你自己的 *rc.d* 脚本。花几分钟阅读现有的脚本将告诉你你需要知道的大部分内容。对于其余部分，请阅读 `rc.d(8)` 和 `rc.subr(8)` 手册页。

现在你已经可以启动 OpenBSD 了，让我们设置一些用户账户。

* * *

^([11]) 在 i386 和 amd64 系统上，这就是 MBR 出现的地方。

^([12]) 当然，一个远程键盘视频鼠标（KVM）系统可以给你所有这些功能，但非常少的 KVM 应用程序允许你从远程控制台复制和粘贴文本。这意味着你需要手动复制错误信息。
