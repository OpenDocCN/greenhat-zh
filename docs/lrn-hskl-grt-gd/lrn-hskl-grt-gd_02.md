# 第二章：相信类型

![无标题图片](img/httpatomoreillycomsourcenostarchimages802524.png.jpg)

Haskell 最强大的优点之一是其强大的类型系统。

在 Haskell 中，每个表达式的类型在编译时都是已知的，这导致代码更安全。如果你编写了一个尝试用数字除以布尔类型的程序，它将无法编译。这是好事，因为最好在编译时捕获这些错误，而不是让程序在以后崩溃。Haskell 中的每样东西都有类型，所以编译器可以在编译程序之前对程序进行大量的推理。

与 Java 或 Pascal 不同，Haskell 具有类型推断功能。例如，如果我们写一个数字，我们不需要告诉 Haskell 它是一个数字，因为它可以自己推断出来。

到目前为止，我们只对 Haskell 的类型进行了非常表面的了解，但理解类型系统是学习 Haskell 的一个非常重要的部分。

# 显式类型声明

我们可以使用 GHCi 来检查一些表达式的类型。我们将通过使用 `:t` 命令来实现，该命令后面跟任何有效表达式，会告诉我们它的类型。让我们试一试：

```
ghci> :t 'a'
'a' :: Char
ghci> :t True
True :: Bool
ghci> :t "HELLO!"
"HELLO!" :: [Char]
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci> :t 4 == 5
4 == 5 :: Bool
```

这里的 `::` 操作符读作“类型为”。显式类型总是用首字母大写来表示。`'a'` 的类型是 `Char`，代表*字符*。`True` 是 `Bool` 类型，或布尔类型。字符串 `"HELLO!"` 显示其类型为 `[Char]`。方括号表示列表，所以我们将其读作字符列表。与列表不同，每个元组的长度都有自己的类型。因此，元组 `(True, 'a')` 的类型是 `(Bool, Char)`，而 `('a','b','c')` 的类型是 `(Char, Char, Char)`。`4 == 5` 总是返回 `False`，所以它的类型是 `Bool`。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802526.png.jpg)

函数也有类型。当我们编写自己的函数时，我们可以选择给它们一个显式的类型声明。这通常被认为是一种良好的实践（除非编写非常简短的功能）。从现在开始，我们将对所有我们进行类型声明的函数进行类型声明。

记得我们在第一章“开始”中制作的列表推导？那个过滤掉字符串小写字母的？这是带有类型声明的样子：

```
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

`removeNonUppercase` 函数的类型是 `[Char] -> [Char]`，这意味着它接受一个字符串作为参数并返回另一个字符串。

但我们如何指定一个接受多个参数的函数的类型呢？这里有一个简单的函数，它接受三个整数并将它们相加：

```
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

参数和返回类型由 `->` 字符分隔，返回类型总是在声明中最后出现。（在第五章“高阶函数”中，你会看到为什么它们都用 `->` 分隔，而不是有更明确的区分。）

如果你想给你的函数一个类型声明，但又不确定应该是什么，你总是可以只写不带声明的函数，然后用 `:t` 来检查它。由于函数是表达式，`:t` 对它们的作用方式与你在本节开头看到的方式相同。

# 常见的 Haskell 类型

让我们看看一些常见的 Haskell 类型，它们用于表示基本事物，如数字、字符和布尔值。以下是一个概述：

+   `Int` 代表整数。它用于表示整数。`7` 可以是一个 `Int`，但 `7.2` 不能。`Int` 是 *有界* 的，这意味着它有一个最小值和一个最大值。

    ### 注意

    我们使用的是 GHC 编译器，其中 `Int` 的范围由你电脑上机器字的大小决定。所以如果你有一个 64 位 CPU，你的系统上最低的 `Int` 很可能是 -2⁶³，最高的是 2⁶³。

+   `Integer` 也用于存储整数，但它没有界限，因此可以用来表示非常大的数字。（我指的是 *真的* 很大！）然而，`Int` 更高效。例如，尝试将以下函数保存到文件中：

    ```
    factorial :: Integer -> Integer
    factorial n = product [1..n]
    ```

    然后，使用 `:l` 将其加载到 GHCi 中并测试它：

    ```
    ghci> factorial 50
    30414093201713378043612608166064768844377641568960512000000000000
    ```

+   `Float` 是一个单精度浮点数。将以下函数添加到你正在工作的文件中：

    ```
    circumference :: Float -> Float
    circumference r = 2 * pi * r
    ```

    然后，加载并测试它：

    ```
    ghci> circumference 4.0
    25.132742
    ```

+   `Double` 是一个双精度浮点数，精度是单精度的两倍。双精度数值类型使用两倍的位来表示数字。额外的位增加了它们的精度，但同时也占用更多的内存。这里还有一个可以添加到你的文件中的函数：

    ```
    circumference' :: Double -> Double
    circumference' r = 2 * pi * r
    ```

    现在加载并测试它。特别注意 `circumference` 和 `circumference'` 之间的精度差异。

    ```
    ghci> circumference' 4.0
    25.132741228718345
    ```

+   `Bool` 是一个布尔类型。它只能有两个值：`True` 和 `False`。

+   `Char` 表示一个 Unicode 字符。它用单引号表示。字符的列表是一个字符串。

+   元组是类型，但它们的定义也取决于它们的长度以及组件的类型。因此，从理论上讲，存在无限多的元组类型。（在实践中，元组最多可以有 62 个元素——远远超过你需要的。）注意，空元组 `()` 也是一个类型，它只能有一个值：`()`。

# 类型变量

对于某些函数能够在各种类型上操作是有意义的。例如，`head` 函数接受一个列表并返回该列表的头部元素。列表中包含的是数字、字符，甚至是更复杂的列表，这并不重要！该函数应该能够处理包含几乎所有内容的列表。

你认为 `head` 函数的类型是什么？让我们用 `:t` 函数来检查：

```
ghci> :t head
head :: [a] -> a
```

这 `a` 是什么？记住类型名称以大写字母开头，所以它不能是一个类型。这实际上是一个 *类型变量* 的例子，这意味着 `a` 可以是任何类型。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802528.png.jpg)

类型变量允许函数以类型安全的方式在多种类型的值上操作。这与其他编程语言中的*泛型*非常相似。然而，Haskell 的版本要强大得多，因为它允许我们轻松地编写非常通用的函数。

使用类型变量的函数被称为*多态函数*。`head` 的类型声明表明它接受任何类型的列表并返回该类型的一个元素。

### 注意

虽然类型变量可以有超过一个字符的名称，但我们通常给它们取名为 `a`、`b`、`c`、`d` 等等。

记得 `fst` 吗？它返回一个配对中的第一个元素。让我们检查它的类型：

```
ghci> :t fst
fst :: (a, b) -> a
```

你可以看到 `fst` 接受一个元组并返回一个与第一个元素相同类型的元素。这就是为什么我们可以在包含任何两种类型元素的配对上使用 `fst`。注意，尽管 `a` 和 `b` 是不同的类型变量，它们不一定是不同类型。这仅仅意味着第一个元素的类型和返回值的类型将是相同的。

# 类型类 101

*类型类*是一个定义某些行为的接口。如果一个类型是类型类的*实例*，那么它支持并实现了类型类所描述的行为。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802530.png.jpg)

更具体地说，类型类指定了一组函数，当我们决定将一个类型作为类型类的实例时，我们定义了这些函数对该类型的意义。

定义相等的类型类是一个很好的例子。许多类型的值可以通过使用 `==` 运算符进行比较。让我们检查这个运算符的类型签名：

```
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
```

注意，等号运算符（`==`）实际上是一个函数。同样，`+`、`*`、`-`、`/`以及几乎所有的其他运算符也都是函数。如果一个函数仅由特殊字符组成，它默认被视为中缀函数。如果我们想检查其类型、传递给另一个函数或将其作为前缀函数调用，我们需要将其括号包围，就像前面的例子一样。

这个例子展示了新内容：`=>` 符号。这个符号之前的一切被称为*类约束*。我们可以这样阅读这个类型声明：等式函数接受任何两个相同类型的值并返回一个 `Bool`。这两个值的类型必须是 `Eq` 类的实例。

`Eq` 类型类提供了一个用于测试相等的接口。如果对特定类型的两个项目进行比较相等是有意义的，那么该类型可以是 `Eq` 类型类的实例。所有标准的 Haskell 类型（除了输入/输出类型和函数）都是 `Eq` 的实例。

### 注意

重要的是要注意，类型类与面向对象编程语言中的类并不相同。

让我们看看一些最常见的 Haskell 类型类，它们使我们的类型可以轻松地进行相等性和顺序比较，作为字符串打印等。

## Eq 类型类

正如我们所讨论的，`Eq` 用于支持等性测试的类型。它的实例实现的函数是 `==` 和 `/=`。这意味着如果函数中对类型变量有 `Eq` 类约束，它会在定义的某个地方使用 `==` 或 `/=`。当一个类型实现一个函数时，这意味着它定义了当使用该特定类型时函数的行为。以下是一些在 `Eq` 的各种实例上执行这些操作的例子：

```
ghci> 5 == 5
True
ghci> 5 /= 5
False
ghci> 'a' == 'a'
True
ghci> "Ho Ho" == "Ho Ho"
True
ghci> 3.432 == 3.432
True
```

## `Ord` 类型类

`Ord` 是一个类型类，其值可以按某种顺序排列。例如，让我们看看大于 (`>`) 操作符的类型：

```
ghci> :t (>)
(>) :: (Ord a) => a -> a -> Bool
```

`>` 类型与 `==` 类型的用法相似。它接受两个参数并返回一个 `Bool`，告诉我们这两个事物之间是否存在某种关系。

我们到目前为止所讨论的所有类型（再次强调，除了函数）都是 `Ord` 类型的实例。`Ord` 包含了所有标准比较函数，如 `>`, `<`, `>=` 和 `<=`。

`compare` 函数接受两个类型为 `Ord` 实例的值，并返回一个 `Ordering`。`Ordering` 是一个类型，可以是 `GT`、`LT` 或 `EQ`，分别代表大于、小于或等于。

```
ghci> "Abrakadabra" < "Zebra"
True
ghci> "Abrakadabra" `compare` "Zebra"
LT
ghci> 5 >= 2
True
ghci> 5 `compare` 3
GT
ghci> 'b' > 'a'
True
```

## `Show` 类型类

类型为 `Show` 类型类实例的值可以表示为字符串。我们到目前为止所讨论的所有类型（除了函数）都是 `Show` 类型的实例。在这个类型类上操作的最常用的函数是 `show`，它将给定的值打印为字符串：

```
ghci> show 3
"3"
ghci> show 5.334
"5.334"
ghci> show True
"True"
```

## `Read` 类型类

`Read` 可以被认为是 `Show` 类型类的对立面。同样，我们到目前为止所讨论的所有类型都是 `Read` 类型的实例。`read` 函数接受一个字符串并返回一个类型为 `Read` 实例的值：

```
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
ghci> read "5" - 2
3
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```

到目前为止一切顺利。但如果我们尝试输入 `read "4"` 会发生什么呢？

```
ghci> read "4"
<interactive>:1:0:
    Ambiguous type variable 'a' in the constraint:
      'Read a' arising from a use of 'read' at <interactive>:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
```

GHCi 告诉我们它不知道我们想要什么返回值。注意，在之前的 `read` 使用中，我们之后对结果做了些处理，这使得 GHCi 能够推断出我们想要的返回类型。如果我们将其用作布尔值，例如，它知道它必须返回一个 `Bool`。但现在它知道我们想要的是 `Read` 类型的某个类型，但它不知道具体是哪一个。让我们看看 `read` 的类型签名：

```
ghci> :t read
read :: (Read a) => String -> a
```

### 注意

`String` 只是 `[Char]` 的另一个名称。`String` 和 `[Char]` 可以互换使用，但我们将主要坚持使用 `String`，因为它更容易编写且更易读。

我们可以看到 `read` 函数返回的值的类型是 `Read` 的实例，但如果以某种方式使用这个结果，它没有方法知道具体是哪种类型。为了解决这个问题，我们可以使用 *类型注解*。

类型注解是明确告诉 Haskell 表达式类型的一种方式。我们通过在表达式的末尾添加 `::` 并指定一个类型来实现这一点：

```
ghci> read "5" :: Int
5
ghci> read "5" :: Float
5.0
ghci> (read "5" :: Float) * 4
20.0
ghci> read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
```

编译器可以自己推断大多数表达式的类型。然而，有时编译器不知道对于像 `read "5"` 这样的表达式应该返回 `Int` 类型的值还是 `Float` 类型的值。为了查看类型，Haskell 需要实际评估 `read "5"`。但由于 Haskell 是静态类型语言，它需要在代码编译（或在 GHCi 的情况下评估）之前知道所有类型。因此，我们需要告诉 Haskell，“嘿，这个表达式应该有这种类型，以防你不知道！”

我们可以只给 Haskell 提供它需要的最少信息，以确定 `read` 应该返回哪种类型的值。例如，如果我们使用 `read` 并将其结果塞入列表中，Haskell 可以通过查看列表中的其他元素来确定我们想要的类型：

```
ghci> [read "True", False, True, False]
[True, False, True, False]
```

由于我们将 `read "True"` 作为 `Bool` 值列表中的一个元素使用，Haskell 看到这一点，`read "True"` 的类型也必须是 `Bool`。

## 枚举类型类

`Enum` 实例是顺序排列的类型——它们的值可以被枚举。`Enum` 类型类的主要优点是我们可以在列表范围内使用它的值。它们还有定义好的后继和前驱，我们可以通过 `succ` 和 `pred` 函数来获取。这个类中的类型示例包括 `()`、`Bool`、`Char`、`Ordering`、`Int`、`Integer`、`Float` 和 `Double`。

```
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]
[LT,EQ,GT]
ghci> [3 .. 5]
[3,4,5]
ghci> succ 'B'
'C'
```

## 有界类型类

`Bounded` 类型类的实例有一个上界和一个下界，可以通过使用 `minBound` 和 `maxBound` 函数来检查：

```
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
ghci> maxBound :: Bool
True
ghci> minBound :: Bool
False
```

`minBound` 和 `maxBound` 函数很有趣，因为它们有一个类型 `(Bounded a) => a`。在某种意义上，它们是多态常量。

注意，所有组件都是 `Bounded` 实例的元组也被认为是 `Bounded` 的实例：

```
ghci> maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```

## 数值类型类

`Num` 是一个数值类型类。它的实例可以像数字一样行动。让我们检查一个数字的类型：

```
ghci> :t 20
20 :: (Num t) => t
```

看起来整数也是多态常量。它们可以像 `Num` 类型类的任何实例（`Int`、`Integer`、`Float` 或 `Double`）一样行动：

```
ghci> 20 :: Int
20
ghci> 20 :: Integer
20
ghci> 20 :: Float
20.0
ghci> 20 :: Double
20.0
```

例如，我们可以检查 `*` 操作符的类型：

```
ghci> :t (*)
(*) :: (Num a) => a -> a -> a
```

这表明 `*` 接受两个数字并返回相同类型的数字。由于这种类型约束，`(5 :: Int) * (6 :: Integer)` 将导致类型错误，而 `5 * (6 :: Integer)` 将正常工作。`5` 可以像 `Integer` 或 `Int` 一样行动，但不能同时两者都是。

要成为 `Num` 的实例，一个类型必须已经存在于 `Show` 和 `Eq` 中。

## 浮点类型类

`Floating` 类型类包括 `Float` 和 `Double` 类型，它们用于存储浮点数。

需要使用浮点数来表示结果的 `Floating` 类型类的值实例的函数需要进行有意义的计算。一些例子是 `sin`、`cos` 和 `sqrt`。

## 整数类型类

`Integral` 是另一个数值类型类。虽然 `Num` 包括所有数字，包括实数整数，但 `Integral` 类只包括*仅*整数（整体数）。这个类型类包括 `Int` 和 `Integer` 类型。

处理数字的一个特别有用的函数是 `fromIntegral`。它有以下类型声明：

```
fromIntegral :: (Num b, Integral a) => a -> b
```

### 注意

注意到 `fromIntegral` 在其类型签名中有几个类约束。这是完全有效的——多个类约束在括号内由逗号分隔。

从其类型签名中，我们可以看到 `fromIntegral` 接收一个整数并将其转换为更通用的数字。当你想使整数和浮点数类型很好地协同工作时，这非常有用。例如，`length` 函数有如下类型声明：

```
length :: [a] -> Int
```

这意味着如果我们尝试获取列表的长度并将其加到 `3.2` 上，我们会得到一个错误（因为我们尝试将一个 `Int` 加到一个浮点数上）。为了解决这个问题，我们可以使用 `fromIntegral`，如下所示：

```
ghci> fromIntegral (length [1,2,3,4]) + 3.2
7.2
```

## 关于类型类的几点注意事项

因为类型类定义了一个抽象接口，一个类型可以成为多个类型类的实例，一个类型类也可以有多个类型作为其实例。例如，`Char` 类型是多个类型类的实例，其中两个是 `Eq` 和 `Ord`，因为我们可以检查两个字符是否相等，也可以按字母顺序比较它们。

有时，一个类型必须首先成为某个类型类的实例，才能允许它成为另一个类型类的实例。例如，要成为 `Ord` 的实例，一个类型必须首先成为 `Eq` 的实例。换句话说，成为 `Eq` 的实例是成为 `Ord` 实例的*先决条件*。如果你这样想，这是有道理的，因为如果你可以比较两个事物进行排序，你也应该能够判断这些事物是否相等。
