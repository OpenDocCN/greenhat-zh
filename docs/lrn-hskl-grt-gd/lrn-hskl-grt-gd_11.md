# 第十一章. 应用函子

Haskell 结合了纯度、高阶函数、参数化代数数据类型和类型类，这使得实现多态性比在其他语言中要容易得多。我们不需要考虑类型属于一个大层次。相反，我们考虑类型可以像什么样子，然后通过适当的类型类将它们连接起来。一个`Int`可以像很多东西一样——一个可比较的东西、一个有序的东西、一个可枚举的东西等等。

类型类是开放的，这意味着我们可以定义自己的数据类型，考虑它可能像什么样子，并将其与定义其行为的类型类连接起来。我们还可以引入一个新的类型类，然后使已经存在的类型成为它的实例。正因为如此，以及因为 Haskell 的类型系统允许我们仅通过函数的类型声明就了解很多关于函数的信息，我们可以定义定义非常通用和抽象行为的类型类。

我们之前讨论过定义操作以检查两个事物是否相等以及按某种顺序比较两个事物的类型类。这些行为非常抽象且优雅，尽管我们并不认为它们非常特别，因为我们大多数时候都在处理这些。在第七章（第七章. 创建自己的类型和类型类）中介绍了函子，它们是值可以被映射的类型。这是一个有用的例子，展示了类型类可以描述的既实用又相当抽象的性质。在本章中，我们将更深入地探讨函子，以及比函子更强、更有用的版本，称为*应用函子*。

# 函数式编程重述

正如你在第七章（第七章. 创建自己的类型和类型类）中学到的，函子是可以被映射的事物，例如列表、`Maybe`和树。在 Haskell 中，它们通过`Functor`类型类来描述，该类型类只有一个类型类方法：`fmap`。`fmap`的类型是`fmap :: (a -> b) -> f a -> f b`，这意味着“给我一个接受`a`并返回`b`的函数，以及一个包含`a`（或多个）的盒子，我会给你一个包含`b`（或多个）的盒子。”它将函数应用于盒子内的元素。

我们还可以将函子值视为具有附加*上下文*的值。例如，`Maybe`值有额外的上下文，即它们可能失败。对于列表，上下文是值实际上可以同时是多个值或没有值。`fmap`在保留其上下文的同时将函数应用于值。

如果我们想让一个类型构造器成为`Functor`的实例，它必须具有`* -> *`的类型，这意味着它恰好接受一个具体的类型作为类型参数。例如，`Maybe`可以成为一个实例，因为它接受一个类型参数来产生一个具体类型，如`Maybe Int`或`Maybe String`。如果一个类型构造器接受两个参数，如`Either`，我们需要部分应用类型构造器，直到它只接受一个类型参数。因此，我们不能写`instance Functor Either where`，但我们可以写`instance Functor (Either a) where`。然后如果我们想象`fmap`只为`Either a`，它将具有以下类型声明：

```
fmap :: (b -> c) -> Either a b -> Either a c
```

如你所见，`Either a`部分是固定的，因为`Either a`只接受一个类型参数。

## I/O 操作作为函子

你已经学会了如何让许多类型（好吧，类型构造器实际上）成为`Functor`的实例：`[]`，`Maybe`，`Either a`，以及我们在第七章中创建的`Tree`类型。你看到了如何通过它们映射函数以获得巨大的好处。现在，让我们来看看`IO`实例。

如果某个值具有如`IO String`这样的类型，这意味着它是一个将进入现实世界并为我们获取一些字符串的 I/O 操作，然后它将作为结果产生。我们可以在`do`语法中使用`<-`来将这个结果绑定到一个名字上。在第八章中，我们讨论了 I/O 操作如何像有脚的盒子一样走出去并为我们从外部世界获取一些值。我们可以检查它们获取了什么，但在检查之后，我们需要将值包装回`IO`中。考虑到这个有脚的盒子类比，你可以看到`IO`如何像一个函子。

让我们看看`IO`是如何成为`Functor`的实例的。当我们对 I/O 操作应用一个函数时，我们想要得到一个 I/O 操作，它执行相同的事情，但将我们的函数应用于其结果值。以下是代码：

```
instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
```

在 I/O 操作上映射某个东西的结果将是一个 I/O 操作，所以我们可以立即使用`do`语法来粘合两个操作并创建一个新的操作。在`fmap`的实现中，我们创建一个新的 I/O 操作，它首先执行原始的 I/O 操作，并调用其结果为`result`。然后我们做`return (f result)`。回想一下，`return`是一个函数，它创建一个不执行任何操作但只产生结果的 I/O 操作。

`do`块产生的操作将始终产生其最后一个操作的值。这就是为什么我们使用`return`来创建一个不执行任何操作但只产生`f result`作为新 I/O 操作结果的 I/O 操作。查看以下代码：

```
main = do line <- getLine
          let line' = reverse line
          putStrLn $ "You said " ++ line' ++ " backwards!"
          putStrLn $ "Yes, you said " ++ line' ++ " backwards!"
```

用户被提示输入一行，我们将其返回，但顺序相反。以下是使用`fmap`重写此操作的方法：

```
main = do line <- fmap reverse getLine
          putStrLn $ "You said " ++ line ++ " backwards!"
          putStrLn $ "Yes, you really said " ++ line ++ " backwards!"
```

![无标题图片](img/httpatomoreillycomsourcenostarchimages802644.png.jpg)

正如我们可以对 `Just "blah"` 应用 `fmap reverse` 来得到 `Just "halb"` 一样，我们也可以对 `getLine` 应用 `fmap reverse`。`getLine` 是一个类型为 `IO String` 的 I/O 操作，对它应用 `reverse` 会生成一个 I/O 操作，该操作将进入现实世界获取一行，然后对其结果应用 `reverse`。以同样的方式，我们可以将一个函数应用于 `Maybe` 框架内部的内容，我们也可以将一个函数应用于 `IO` 框架内部的内容，但它必须进入现实世界以获取某些内容。然后当我们使用 `<-` 绑定它到一个名称时，该名称将反映已经应用了 `reverse` 的结果。

I/O 操作 `fmap (++"!") getLine` 的行为就像 `getLine` 一样，除了其结果总是附加了 `"!"`。

如果 `fmap` 仅限于 `IO`，其类型将是 `fmap :: (a -> b) -> IO a -> IO b`。`fmap` 接收一个函数和一个 I/O 操作，并返回一个新的 I/O 操作，它类似于旧的操作，除了函数被应用于其包含的结果。

如果你发现自己将 I/O 操作的结果绑定到一个名称上，只是为了应用一个函数并称其为另一个名称，考虑使用 `fmap`。如果你想将多个函数应用于一个在函子内部的数据，你可以在顶层声明自己的函数，创建一个 lambda 函数，或者，理想情况下，使用函数组合：

```
import Data.Char
import Data.List

main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine
          putStrLn line
```

如果我们用输入 `hello there` 运行它，会发生以下情况：

```
$ ./fmapping_io
hello there
E-R-E-H-T- -O-L-L-E-H
```

`intersperse '-' . reverse . map toUpper` 函数接收一个字符串，将其映射到 `toUpper`，然后对结果应用 `reverse`，最后将 `intersperse '-'` 应用到结果上。这是一种更优雅的写法，如下所示：

```
(\xs -> intersperse '-' (reverse (map toUpper xs)))
```

## 函数作为函子

我们一直在处理的一个 `Functor` 的另一个实例是 `(->) r`。但是等等！`(->) r` 究竟是什么意思？函数类型 `r -> a` 可以重写为 `(->) r a`，就像我们可以将 `2 + 3` 写作 `(+) 2 3` 一样。当我们将其视为 `(->) r a` 时，我们可以以稍微不同的方式看待 `(->)`。它只是一个类型构造器，它接受两个类型参数，就像 `Either` 一样。

但请记住，类型构造器必须恰好接受一个类型参数，以便它可以成为 `Functor` 的实例。这就是为什么我们不能将 `(->)` 作为 `Functor` 的实例；然而，如果我们部分应用它到 `(->) r`，它不会引起任何问题。如果语法允许类型构造器通过部分应用（如我们可以通过 `(2+)` 部分应用 `+`，它等同于 `(+) 2`），我们可以将 `(->) r` 写作 `(r ->)`。

函数如何成为函子？让我们看看实现，它位于 `Control.Monad.Instances` 中：

```
instance Functor ((->) r) where
    fmap f g = (\x -> f (g x))
```

首先，让我们思考一下 `fmap` 的类型：

```
fmap :: (a -> b) -> f a -> f b
```

接下来，让我们在心中将每个 `f`，即我们的函子实例所扮演的角色，替换为 `(->) r`。这将使我们能够看到 `fmap` 应该如何在这个特定实例中表现。以下是结果：

```
fmap :: (a -> b) -> ((->) r a) -> ((->) r b)
```

现在，我们可以将 `(->) r a` 和 `(->) r b` 类型写成中缀 `r -> a` 和 `r -> b`，就像我们通常处理函数一样：

```
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```

好吧，在函数上映射函数必须产生一个函数，就像在 `Maybe` 上映射函数必须产生一个 `Maybe`，以及在列表上映射函数必须产生一个列表一样。前面的类型告诉我们什么？我们看到它接受一个从 `a` 到 `b` 的函数和一个从 `r` 到 `a` 的函数，并返回一个从 `r` 到 `b` 的函数。这让你想起了什么吗？是的，函数组合！我们将 `r -> a` 的输出管道输入到 `a -> b` 的输入中，以获得一个 `r -> b` 的函数，这正是函数组合的全部内容。这里有另一种编写此实例的方法：

```
instance Functor ((->) r) where
    fmap = (.)
```

这清楚地表明，在函数上使用 `fmap` 实际上就是函数组合。在脚本中，导入 `Control.Monad.Instances`，因为实例定义在那里，然后加载脚本并尝试在函数上应用映射：

```
ghci> :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) => a -> a
ghci> fmap (*3) (+100) 1
303
ghci> (*3) `fmap` (+100) $ 1
303
ghci> (*3) . (+100) $ 1
303
ghci> fmap (show . (*3)) (+100) 1
"303"
```

我们可以将 `fmap` 调用为一个中缀函数，以便清楚地看到它与 `.` 的相似之处。在第二行输入中，我们正在将 `(*3)` 映射到 `(+100)`，这将产生一个函数，它将接受一个输入，将 `(+100)` 应用到该输入上，然后将 `(*3)` 应用到该结果上。然后我们将该函数应用到 `1` 上。

正如所有函子一样，函数可以被看作是有上下文的价值。当我们有一个像 `(+3)` 这样的函数时，我们可以将值视为函数的最终结果，上下文是我们需要将函数应用到某物上才能得到结果。使用 `fmap (*3)` 在 `(+100)` 上将创建另一个像 `(+100)` 一样的函数，但在产生结果之前，`(*3)` 将被应用到该结果上。

当在函数上使用时，`fmap` 是函数组合的事实现在可能并不那么有用，但至少它非常有趣。它也让我们的大脑有点弯曲，并让我们看到那些更像计算而不是盒子的东西（`IO` 和 `(->) r`）可以成为函子。被映射到计算上的函数会产生相同类型的计算，但该计算的结果会通过该函数进行修改。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802646.png.jpg)

在我们继续到 `fmap` 应该遵循的规则之前，让我们再次思考一下 `fmap` 的类型：

```
fmap :: (Functor f) => (a -> b) -> f a -> f b
```

在 第五章 中引入柯里化函数时，首先声明所有 Haskell 函数实际上只接受一个参数。一个 `a -> b -> c` 函数只接受一个类型为 `a` 的参数，并返回一个 `b -> c` 的函数，该函数接受一个参数并返回 `c`。这就是为什么用太少的参数调用函数（部分应用它）会给我们返回一个接受我们省略的参数数量的函数（如果我们再次将函数视为接受多个参数）。因此，`a -> b -> c` 可以写成 `a -> (b -> c)`，以使柯里化更明显。

同样地，如果我们写`fmap :: (a -> b) -> (f a -> f b)`，我们可以把`fmap`不是看作是一个接受一个函数和一个函子值并返回一个函子值的函数，而是一个接受一个函数并返回一个新函数的函数，这个新函数与旧函数类似，除了它接受一个函子值作为参数并返回一个函子值作为结果。它接受一个`a -> b`函数并返回一个函数`f a -> f b`。这被称为*提升*一个函数。让我们使用 GHCi 的`:t`命令来玩这个想法：

```
ghci> :t fmap (*2)
fmap (*2) :: (Num a, Functor f) => f a -> f a
ghci> :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) => f a -> f [a]
```

表达式`fmap (*2)`是一个函数，它接受一个数字上的函子`f`并返回一个数字上的函子。这个函子可以是列表、`Maybe`、`Either String`或其他任何东西。表达式`fmap (replicate 3)`将接受任何类型的函子并返回一个该类型元素列表的函子。如果我们部分应用，比如`fmap (++"!")`并将其绑定到 GHCi 中的一个名称，这会更加明显。

你可以从两种方式来思考`fmap`：

+   作为一种函数，它接受一个函数和一个函子值，然后在该函子值上映射该函数

+   作为一种函数，它接受一个函数并将其提升，使其在函子值上操作

这两种观点都是正确的。

类型`fmap (replicate 3) :: (Functor f) => f a -> f [a]`意味着这个函数将在任何函子上工作。它将做什么取决于函子。如果我们对列表使用`fmap (replicate 3)`，将选择列表的`fmap`实现，这仅仅是`map`。如果我们对`Maybe a`使用它，它将对`Just`中的值应用`replicate 3`。如果是`Nothing`，它将保持`Nothing`。以下是一些示例：

```
ghci> fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci> fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci> fmap (replicate 3) (Right "blah")
Right ["blah","blah","blah"]
ghci> fmap (replicate 3) Nothing
Nothing
ghci> fmap (replicate 3) (Left "foo")
Left "foo"
```

# 函子定律

所有函子都应表现出某些类型的属性和行为。它们应该可靠地表现为可以被映射的对象。在函子上调用`fmap`应该只是将函数映射到函子——仅此而已。这种行为在*函子定律*中描述。所有`Functor`实例都应该遵守这两条定律。Haskell 不会自动执行这些定律，所以当你创建一个函子时，你需要自己测试它们。标准库中的所有`Functor`实例都遵守这些定律。

## 法则 1

第一条函子定律指出，如果我们将`id`函数映射到函子值上，我们得到的函子值应该与原始的函子值相同。更正式地说，这意味着`fmap id = id`。所以本质上，这表明如果我们对函子值执行`fmap id`，它应该与直接应用`id`到值上相同。记住`id`是恒等函数，它只是返回其参数未修改。它也可以写成`\x -> x`。如果我们把函子值看作是可以被映射的对象，`fmap id = id`定律似乎有点平凡或明显。

让我们看看这个定律对于几个函子的值是否成立。

```
ghci> fmap id (Just 3)
Just 3
ghci> id (Just 3)
Just 3
ghci> fmap id [1..5]
[1,2,3,4,5]
ghci> id [1..5]
[1,2,3,4,5]
ghci> fmap id []
[]
ghci> fmap id Nothing
Nothing
```

以`Maybe`的`fmap`实现为例，我们可以弄清楚为什么第一条函子定律成立：

```
instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
```

我们想象`id`在实现中扮演了`f`参数的角色。我们看到如果我们对`Just x`应用`fmap id`，结果将是`Just (id x)`，因为`id`只是返回其参数，我们可以推断出`Just (id x)`等于`Just x`。所以现在我们知道，如果我们对带有`Just`构造函数的`Maybe`值应用`id`，我们将得到相同的值。

看到对`Nothing`值应用`id`返回相同的值是显而易见的。所以从`fmap`实现的这两个方程中，我们发现定律`fmap id = id`成立。

## 法则 2

第二定律表明，先组合两个函数，然后将结果函数映射到 functor 上，应该与首先将一个函数映射到 functor 上，然后映射另一个函数相同。形式上写成，这意味着`fmap (f . g) = fmap f . fmap g`。或者用另一种方式写，对于任何 functor 值`x`，以下应该成立：`fmap (f . g) x = fmap f (fmap g x)`。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802648.png.jpg)

如果我们可以证明某个类型遵守了两个 functor 定律，我们就可以依赖它在映射时的基本行为与其他 functors 相同。我们可以知道，当我们对它使用`fmap`时，幕后不会有除了映射之外的其他操作，并且它将表现得像一个可以被映射的对象——即，一个 functor。

我们通过查看某个类型的`fmap`实现，然后使用我们用来检查`Maybe`是否遵守第一定律的方法，来找出某个类型的第二定律是如何成立的。所以，为了检查`Maybe`的第二 functor 定律是如何成立的，如果我们对`Nothing`应用`fmap (f . g)`，我们得到`Nothing`，因为对`Nothing`应用任何函数都会返回`Nothing`。如果我们调用`fmap f (fmap g Nothing)`，我们得到`Nothing`，原因相同。

如果`Maybe`是一个`Nothing`值，那么看到第二定律是如何成立的很容易。但是，如果它是一个`Just`值呢？嗯，如果我们对`(Just x)`应用`fmap (f . g)`，从实现中我们可以看到它被实现为`Just ((f . g) x)`，这是`Just (f (g x))`。如果我们对`(fmap g (Just x))`应用`fmap f`，从实现中我们可以看到`fmap g (Just x)`是`Just (g x)`。因此，`fmap f (fmap g (Just x))`等于`fmap f (Just (g x))`，从实现中我们可以看到这等于`Just (f (g x))`。

如果你对这个证明有点困惑，不要担心。确保你理解了函数组合是如何工作的。很多时候，你可以直观地看到这些定律是如何成立的，因为类型表现得像容器或函数。你也可以在类型的许多不同值上尝试它们，并能够有把握地说一个类型确实遵守了定律。

## 违反定律

让我们看看一个类型构造函数是`Functor`类型类的实例但实际上并不是 functor 的病理例子，因为它不满足定律。假设我们有以下类型：

```
data CMaybe a = CNothing | CJust Int a deriving (Show)
```

这里的 `C` 代表计数器。它是一种数据类型，看起来很像 `Maybe a`，但 `Just` 部分包含两个字段而不是一个。`CJust` 值构造函数中的第一个字段将始终具有 `Int` 类型，并且它将是一种计数器。第二个字段是类型 `a`，它来自类型参数，其类型将取决于我们为 `CMaybe a` 选择的具体类型。让我们来玩玩我们的新类型：

```
ghci> CNothing
CNothing
ghci> CJust 0 "haha"
CJust 0 "haha"
ghci> :t CNothing
CNothing :: CMaybe a
ghci> :t CJust 0 "haha"
CJust 0 "haha" :: CMaybe [Char]
ghci> CJust 100 [1,2,3]
CJust 100 [1,2,3]
```

如果我们使用 `CNothing` 构造函数，则没有字段。如果我们使用 `CJust` 构造函数，第一个字段是一个整数，第二个字段可以是任何类型。让我们将其作为 `Functor` 的实例，这样每次我们使用 `fmap` 时，函数都应用于第二个字段，而第一个字段增加 1。

```
instance Functor CMaybe where
    fmap f CNothing = CNothing
    fmap f (CJust counter x) = CJust (counter+1) (f x)
```

这有点像 `Maybe` 的实例实现，除了当我们对不表示空盒（`CJust` 值）的值执行 `fmap` 时，我们不仅将函数应用到内容上；我们还增加计数器 1。到目前为止，一切看起来都很酷。我们甚至可以玩玩这个：

```
ghci> fmap (++"ha") (CJust 0 "ho")
CJust 1 "hoha"
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))
CJust 2 "hohahe"
ghci> fmap (++"blah") CNothing
CNothing
```

这是否遵守函子定律？为了看到某物不遵守定律，只需找到一个反例就足够了：

```
ghci> fmap id (CJust 0 "haha")
CJust 1 "haha"
ghci> id (CJust 0 "haha")
CJust 0 "haha"
```

根据第一个函子定律，如果我们对函子值映射 `id`，它应该与直接用相同的函子值调用 `id` 相同。我们的例子表明，这并不适用于我们的 `CMaybe` 函子。尽管它是 `Functor` 类型类的一部分，但它不遵守这个函子定律，因此它不是一个函子。

由于 `CMaybe` 即使假装是函子也未能成为函子，因此将其用作函子可能会导致一些错误的代码。当我们使用函子时，我们不应该关心我们首先组合几个函数然后映射到函子值，还是我们依次将每个函数映射到函子值。但与 `CMaybe` 不同，这很重要，因为它跟踪它被映射了多少次。这很不酷！如果我们想让 `CMaybe` 遵守函子定律，我们需要确保在执行 `fmap` 时 `Int` 字段保持不变。

起初，函子定律可能看起来有些令人困惑且不必要。但如果我们知道一个类型遵守这两个定律，我们就可以对其行为做出某些假设。如果一个类型遵守函子定律，我们知道对那个类型的值调用 `fmap` 只会将函数映射到它上面——仅此而已。这导致代码更加抽象和可扩展，因为我们可以使用定律来推理任何函子都应该具有的行为，并编写在任何函子上都能可靠运行的函数。

下次你将一个类型作为 `Functor` 的实例时，花一分钟确保它遵守函子定律。你可以逐行检查实现，看看定律是否成立，或者尝试找到一个反例。一旦你处理了足够的函子，你将开始认识到它们共有的属性和行为，并开始直观地看到类型是否遵守函子定律。

# 使用应用函子

在本节中，我们将探讨应用函子，它们是增强版的函子。

到目前为止，我们一直专注于映射只接受一个参数的函数到函子。但是，当我们映射一个接受两个参数的函数到函子上时会发生什么？让我们看看这个的几个具体例子。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802650.png.jpg)

如果我们有`Just 3`并调用`fmap (*) (Just 3)`，我们会得到什么？从`Maybe`的`Functor`实例实现中，我们知道如果它是一个`Just`值，它将把函数应用于`Just`内部的值。因此，执行`fmap (*) (Just 3)`的结果是`Just ((*) 3)`，如果我们使用部分应用，也可以写成`Just (3 *)`。有趣的是！我们得到了一个被`Just`包裹的函数！

这里有一些函子值内部的更多函数：

```
ghci> :t fmap (++) (Just "hey")
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
ghci> :t fmap compare (Just 'a')
fmap compare (Just 'a') :: Maybe (Char -> Ordering)
ghci> :t fmap compare "A LIST OF CHARS"
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
```

如果我们将`compare`映射到一个字符列表上，它的类型是`(Ord a) => a -> a -> Ordering`，我们会得到一个类型为`Char -> Ordering`的函数列表，因为`compare`函数被部分应用于列表中的字符。它不是一个`(Ord a) => a -> Ordering`函数的列表，因为第一个`a`应用的是`Char`，因此第二个`a`必须决定其类型为`Char`。

我们看到通过将“多参数”函数映射到函子值上，我们得到了包含函数在内的函子值。那么现在我们能对它们做什么呢？首先，我们可以映射接受这些函数作为参数的函数，因为函子值内部的东西将被提供给我们要映射的函数作为参数：

```
ghci> let a = fmap (*) [1,2,3,4]
ghci> :t a
a :: [Integer -> Integer]
ghci> fmap (\f -> f 9) a
[9,18,27,36]
```

但如果我们有一个`Just (3 *)`的函子值和一个`Just 5`的函子值，而我们想要从`Just (3 *)`中提取函数并映射到`Just 5`上呢？使用普通的函子，我们就没有运气了，因为它们只支持在现有的函子上映射普通函数。即使当我们对包含函数的函子映射`\f -> f 9`时，我们只是在它上面映射了一个普通函数。但我们不能使用`fmap`提供的方法将一个函子值内部的函数映射到另一个函子值上。我们可以通过模式匹配`Just`构造函数来从中提取函数，然后映射到`Just 5`上，但我们正在寻找一个更通用和抽象的方法，它可以在函子之间工作。

## 问候应用函子

认识一下`Applicative`类型类，它在`Control.Applicative`模块中定义。它定义了两个函数：`pure`和`<*>`。它不提供这两个函数的默认实现，所以如果我们想让某个东西成为一个应用函子，我们需要定义它们两个。类定义如下：

```
class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
```

这简单的三行类定义告诉我们很多！第一行开始定义 `Applicative` 类，并且也引入了一个类约束。约束说，如果我们想使一个类型构造器成为 `Applicative` 类型类的一部分，它必须首先在 `Functor` 中。这就是为什么如果我们知道一个类型构造器是 `Applicative` 类型类的一部分，它也在 `Functor` 中，所以我们可以对它使用 `fmap`。

它定义的第一个方法被称为 `pure`。它的类型声明是 `pure :: a -> f a`。在这里，`f` 扮演了我们应用函子实例的角色。因为 Haskell 有一个非常好的类型系统，而且因为所有函数能做的只是接受一些参数并返回一些值，我们可以从类型声明中得知很多信息，这也不例外。

`pure` 应该接受任何类型的值，并返回一个包含该值的适用值的适用值。这里的“里面”再次指的是我们的盒子类比，尽管我们已经看到它并不总是经得起推敲。但 `a -> f a` 的类型声明仍然相当描述性。我们接受一个值，并将其包裹在一个适用值中，这个适用值的结果里面就是那个值。关于 `pure` 的更好思考方式可能是说它接受一个值并将其放入某种默认（或纯）上下文中——一个最小的上下文，仍然产生那个值。

`<*>` 函数非常有趣。它有这个类型声明：

```
f (a -> b) -> f a -> f b
```

这让你想起什么吗？它就像 `fmap :: (a -> b) -> f a -> f b`。你可以把 `<*>` 函数看作是某种增强版的 `fmap`。而 `fmap` 接受一个函数和一个函子值，并在函子值内部应用这个函数，`<*>` 接受一个包含函数的函子值和另一个函子，然后从第一个函子中提取那个函数，然后将其映射到第二个函子上。

## 可能的适用函子

让我们看看 `Maybe` 的 `Applicative` 实例实现：

```
instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
```

再次，从类定义中，我们看到扮演应用函子角色的 `f` 应该接受一个具体类型作为参数，所以我们写 `instance Applicative Maybe where` 而不是 `instance Applicative (Maybe a) where`。

接下来，我们有 `pure`。记住，它应该接受一些东西并将其包裹在应用值中。我们写 `pure = Just`，因为像 `Just` 这样的值构造器是普通函数。我们也可以写成 `pure x = Just x`。

最后，我们有 `<*>` 的定义。我们不能从一个 `Nothing` 中提取一个函数，因为它里面没有函数。所以如果我们尝试从一个 `Nothing` 中提取一个函数，结果是 `Nothing`。

在`Applicative`类的类定义中，有一个`Functor`类约束，这意味着我们可以假设`<*>`函数的两个参数都是函子值。如果第一个参数不是一个`Nothing`，而是一个包含某些函数的`Just`，那么我们就可以说我们想要将这个函数映射到第二个参数上。这也处理了第二个参数是`Nothing`的情况，因为对任何函数在`Nothing`上执行`fmap`操作都会返回一个`Nothing`。所以对于`Maybe`，`<*>`会从左边的值中提取函数（如果它是`Just`），并将其映射到右边的值上。如果任一参数是`Nothing`，结果就是`Nothing`。

现在我们来试一试：

```
ghci> Just (+3) <*> Just 9
Just 12

ghci> pure (+3) <*> Just 10
Just 13
ghci> pure (+3) <*> Just 9
Just 12
ghci> Just (++"hahah") <*> Nothing
Nothing
ghci> Nothing <*> Just "woot"
Nothing
```

你可以看到在这个情况下，执行`pure (+3)`和`Just (+3)`是相同的。如果你在应用式上下文中处理`Maybe`值（使用它们与`<*>`一起），请使用`pure`；否则，坚持使用`Just`。

前四行展示了函数是如何被提取然后映射的，但在这个情况下，它们可以通过仅仅将未包装的函数映射到函子上来实现。最后一行很有趣，因为我们尝试从一个`Nothing`中提取一个函数，然后将其映射到某个值上，结果是`Nothing`。

对于普通函子，当你将一个函数映射到一个函子上时，你无法以任何通用方式得到结果，即使结果是部分应用函数。另一方面，应用式函子允许你用一个函数操作多个函子。

## 应用式风格

使用`Applicative`类型类，我们可以链式使用`<*>`函数，这样我们就可以无缝地对多个应用值进行操作，而不仅仅是单个值。例如，看看这个：

```
ghci> pure (+) <*> Just 3 <*> Just 5
Just 8
ghci> pure (+) <*> Just 3 <*> Nothing
Nothing
ghci> pure (+) <*> Nothing <*> Just 5
Nothing
```

![无标题图片](img/httpatomoreillycomsourcenostarchimages802652.png.jpg)

我们将`+`函数包裹在一个应用值中，然后使用`<*>`用两个参数（都是应用值）调用它。

让我们一步一步地看看这是如何发生的。`<*>`是左结合的，这意味着这个：

```
pure (+) <*> Just 3 <*> Just 5
```

这与这个相同：

```
(pure (+) <*> Just 3) <*> Just 5
```

首先，`+`函数被放入一个应用值中——在这个例子中，是一个包含函数的`Maybe`值。所以我们有`pure (+)`，它是`Just (+)`。接下来，`Just (+) <*> Just 3`发生了。这个结果是因为部分应用。只将`+`函数应用到`3`上会得到一个接受一个参数并将 3 加到它上面的函数。最后，执行`Just (3+) <*> Just 5`，结果是`Just 8`。

这不是太棒了吗？应用式函子和`pure f <*> x <*> y <*> ...`的应用式风格允许我们使用一个期望参数不是应用值函数，并使用该函数对多个应用值进行操作。该函数可以接受我们想要的任意数量的参数，因为它总是在`<*>`出现之间逐步部分应用。

如果我们考虑这样一个事实，即 `pure f <*> x` 等于 `fmap f x`，这就会变得更加方便和明显。这是应用性定律之一。我们将在本章后面更详细地探讨应用性定律，但让我们先思考一下它在这里是如何应用的。`pure` 将一个值放入默认上下文中。如果我们只是将一个函数放入默认上下文中，然后从中提取并应用到另一个应用性函子中的值，那么这和只是映射该函数到该应用性函子上是一样的。我们不需要写 `pure f <*> x <*> y <*> ...`，我们可以写 `fmap f x <*> y <*> ...`。这就是为什么 `Control.Applicative` 导出了一个名为 `<$>` 的函数，它只是作为中缀操作符的 `fmap`。下面是如何定义它的：

```
(<$>) :: (Functor f) => (a -> b) -> f a -> f b
f <$> x = fmap f x
```

### 注意

记住，类型变量与参数名称或其他值名称无关。这里函数声明中的 `f` 是一个带有类约束的类型变量，表示任何替换 `f` 的类型构造函数都应该在 `Functor` 类型类中。函数体中的 `f` 表示一个映射到 `x` 的函数。我们使用 `f` 来表示这两者并不意味着它们表示相同的事物。

通过使用 `<$>`，应用性风格真正地闪耀，因为现在如果我们想在三个应用性值之间应用一个函数 `f`，我们可以写 `f <$> x <*> y <*> z`。如果参数是普通值而不是应用性函子，我们会写 `f x y z`。

让我们更仔细地看看它是如何工作的。假设我们想要将 `Just "johntra"` 和 `Just "volta"` 这两个值连接成一个 `String`，并在 `Maybe` 函子内部。我们可以这样做：

```
ghci> (++) <$> Just "johntra" <*> Just "volta"
Just "johntravolta"
```

在我们看到它是如何发生之前，比较前面的行与这一行：

```
ghci> (++) "johntra" "volta"
"johntravolta"
```

要在应用性函子上使用普通函数，只需在周围撒一些 `<$>` 和 `<*>`，函数就会在应用性上操作并返回一个应用性。这有多酷？

回到我们的 `(++) <$> Just "johntra" <*> Just "volta"`：首先 `(++)`，它有一个类型 `(++) :: [a] -> [a] -> [a]`，被映射到 `Just "johntra"` 上。这产生了一个与 `Just ("johntra"++)` 相同的值，其类型为 `Maybe ([Char] -> [Char])`。注意 `(++)` 的第一个参数是如何被消耗掉的，以及 `a` 如何变成了 `Char` 值。现在 `Just ("johntra"++) <*> Just "volta"` 发生了，它从 `Just` 中提取出函数并将其映射到 `Just "volta"` 上，结果得到 `Just "johntravolta"`。如果这两个值中的任何一个都是 `Nothing`，结果也会是 `Nothing`。

到目前为止，我们只在示例中使用了 `Maybe`，你可能认为应用性函子都是关于 `Maybe` 的。实际上，`Applicative` 有很多其他实例，所以让我们来认识它们！

## 列表

列表（实际上是列表类型构造函数 `[]`）是应用性函子。多么令人惊讶！下面是如何使 `[]` 成为 `Applicative` 的实例：

```
instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]
```

记住，`pure` 函数接受一个值并将其放入默认上下文中。换句话说，它将其放入一个最小的上下文中，但仍然可以产生该值。对于列表而言，最小的上下文将是空列表，但空列表代表没有值，因此它不能包含我们使用 `pure` 的值。这就是为什么 `pure` 函数接受一个值并将其放入单元素列表中的原因。同样，`Maybe` 应用函子（applicative functor）的最小上下文将是 `Nothing`，但它代表的是没有值而不是值，因此在 `Maybe` 的实例实现中 `pure` 被实现为 `Just`。

这是 `pure` 函数的实际应用：

```
ghci> pure "Hey" :: [String]
["Hey"]
ghci> pure "Hey" :: Maybe String
Just "Hey"
```

那么 `<*>` 呢？如果 `<*>` 函数的类型仅限于列表，我们将会得到 `(<*>) :: [a -> b] -> [a] -> [b]`。它是通过列表推导实现的。`<*>` 必须以某种方式从其左参数中提取函数，然后将其映射到右参数上。但左边的列表可以包含零个、一个或多个函数，右边的列表也可以包含多个值。这就是为什么我们使用列表推导从两个列表中抽取。我们将左列表中的每个可能的函数应用到右列表中的每个可能的值上。结果列表包含了将左列表中的函数应用到右列表中的每个值上的所有可能的组合。

我们可以这样使用 `<*>`：

```
ghci> [(*0),(+100),(²)] <*> [1,2,3]
[0,0,0,101,102,103,1,4,9]
```

左列表有三个函数，右列表有三个值，因此结果列表将有九个元素。左列表中的每个函数都会应用到右列表中的每个函数上。如果我们有一个接受两个参数的函数列表，我们可以在两个列表之间应用这些函数。

在以下示例中，我们在两个列表之间应用了两个函数：

```
ghci> [(+),(*)] <*> [1,2] <*> [3,4]
[4,5,5,6,3,4,6,8]
```

`<*>` 是左结合的，所以 `[(+),(*)] <*> [1,2]` 首先发生，结果是一个与 `[(1+),(2+),(1*),(2*)]` 相同的列表，因为左边的每个函数都会应用到右边的每个值上。然后 `[(1+),(2+),(1*),(2*)] <*> [3,4]` 发生，产生了最终结果。

使用列表的适用性风格很有趣！

```
ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
```

再次强调，我们只是通过插入适当的适用性运算符，在两个字符串列表之间使用了一个普通函数来连接两个字符串列表。

你可以将列表视为非确定性计算。例如，值 `100` 或 `"what"` 可以被视为只有一个结果的确定性计算，而列表 `[1,2,3]` 可以被视为无法决定想要哪个结果的计算，因此它向我们展示了所有可能的结果。所以当你写 `(+) <$> [1,2,3] <*> [4,5,6]` 这样的代码时，你可以将其视为使用 `+` 将两个非确定性计算相加，从而产生另一个结果更加不确定的非确定性计算。

在列表上使用应用式风格通常是一个很好的列表推导式的替代品。在第一章中，我们想看到`[2,5,10]`和`[8,10,11]`的所有可能乘积，所以我们做了以下操作：

```
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
```

我们只是从两个列表中抽取元素，并在每个元素组合之间应用一个函数。这也可以用应用式风格来完成：

```
ghci> (*) <$> [2,5,10] <*> [8,10,11]
[16,20,22,40,50,55,80,100,110]
```

这对我来说更清晰，因为更容易看出我们只是在两个非确定性计算之间调用`*`。如果我们想要所有大于 50 的两个列表的所有可能乘积，我们会使用以下代码：

```
ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
[55,80,100,110]
```

很容易看出`pure f <*> xs`与列表上的`fmap f xs`相等。`pure f`只是`[f]`，而`[f] <*> xs`将左列表中的每个函数应用到右列表中的每个值上，但由于左列表中只有一个函数，所以它就像映射。

## IO 也是一个应用式函子

我们已经遇到的另一个`Applicative`实例是`IO`。这是实例的实现方式：

```
instance Applicative IO where
    pure = return
    a <*> b = do
        f <- a
        x <- b
        return (f x)
```

![无标题图片](img/httpatomoreillycomsourcenostarchimages802654.png.jpg)

由于`pure`的核心理念是将值置于最小的上下文中，同时仍然保持其作为结果的价值，因此`pure`仅仅是`return`是有意义的。`return`执行一个不进行任何操作的 I/O 操作。它只是作为其结果产生一些值，而不执行任何像向终端打印或从文件读取这样的 I/O 操作。

如果`<*>`针对`IO`进行了特殊化，它将具有类型`(<*>) :: IO (a -> b) -> IO a -> IO b`。在`IO`的情况下，它接受一个产生函数的 I/O 操作`a`，执行该函数，并将该函数绑定到`f`。然后它执行`b`并将结果绑定到`x`。最后，它将函数`f`应用到`x`上，并产生这个结果。我们在这里使用了`do`语法来实现它。（记住，`do`语法是关于执行多个 I/O 操作并将它们粘合为一个。）

使用`Maybe`和`[]`，我们可以将`<*>`视为简单地从其左参数中提取一个函数，然后将其应用到右参数上。对于`IO`，提取仍然在游戏中，但现在我们还有一个关于*序列化*的概念，因为我们正在将两个 I/O 操作粘合为一个。我们需要从第一个 I/O 操作中提取函数，但要从 I/O 操作中提取结果，它必须被执行。考虑以下情况：

```
myAction :: IO String
myAction = do
    a <- getLine
    b <- getLine
    return $ a ++ b
```

这是一个会提示用户输入两行并作为其结果返回这两行连接的 I/O 操作。我们通过将两个`getLine` I/O 操作和一个`return`粘合在一起来实现它，因为我们希望我们的新粘合 I/O 操作保留`a ++ b`的结果。另一种写法是使用应用式风格：

```
myAction :: IO String
myAction = (++) <$> getLine <*> getLine
```

这和我们之前做的是一样的事情，当时我们在创建一个在两个其他 I/O 操作的结果之间应用函数的 I/O 操作。记住 `getLine` 是一个类型为 `getLine :: IO String` 的 I/O 操作。当我们使用 `<*>` 在两个应用值之间时，结果是另一个应用值，所以这一切都很有意义。

如果我们回到盒子类比，我们可以想象 `getLine` 是一个盒子，它会进入现实世界并为我们获取一个字符串。调用 `(++) <$> getLine <*> getLine` 会创建一个新的更大的盒子，它会将这两个盒子发送到终端去获取行，然后将其作为结果呈现这两个行的连接。

表达式 `(++) <$> getLine <*> getLine` 的类型是 `IO String`。这意味着该表达式是一个完全正常的 I/O 操作，就像其他任何操作一样，它也会产生一个结果值。这就是为什么我们可以做类似这样的事情：

```
main = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a
```

## 函数作为应用

`Applicative` 的另一个实例是 `(->) r`，或函数。我们并不经常将函数用作应用，但这个概念仍然非常有趣，所以让我们看看函数实例是如何实现的。

```
instance Applicative ((->) r) where
    pure x = (\_ -> x)
    f <*> g = \x -> f x (g x)
```

当我们用 `pure` 将一个值包裹成应用值时，它产生的结果必须是那个值。最小的默认上下文仍然会产生那个值作为结果。这就是为什么在函数实例实现中，`pure` 接收一个值并创建一个忽略其参数并始终返回该值的函数。`pure` 对于 `(->) r` 实例的类型是 `pure :: a -> (r -> a)`。

```
ghci> (pure 3) "blah"
3
```

由于柯里化，函数应用是左结合的，所以我们可以省略括号。

```
ghci> pure 3 "blah"
3
```

`<*>` 的实例实现有点难以理解，所以我们只需看看如何以应用风格使用函数作为应用函子：

```
ghci> :t (+) <$> (+3) <*> (*100)
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a
ghci> (+) <$> (+3) <*> (*100) $ 5
508
```

使用两个应用值调用 `<*>` 会得到一个应用值，所以如果我们用它来操作两个函数，我们就会得到一个函数。那么这里发生了什么？当我们执行 `(+) <$> (+3) <*> (*100)` 时，我们创建了一个函数，它会在 `(+3)` 和 `(*100)` 的结果上使用 `+` 并返回那个结果。在 `(+) <$> (+3) <*> (*100) $ 5` 中，`(+3)` 和 `(*100)` 首先应用于 `5`，得到 `8` 和 `500`。然后 `+` 被调用，使用 `8` 和 `500`，得到 `508`。

以下代码类似：

```
ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
[8.0,10.0,2.5]
```

我们创建了一个函数，它会调用函数 `\x y z -> [x,y,z]`，使用 `(+3)`、`(*2)` 和 `(/2)` 的最终结果。`5` 被喂给这三个函数中的每一个，然后使用这些结果调用 `\x y z -> [x, y, z]`。

![无标题图片](img/httpatomoreillycomsourcenostarchimages802656.png.jpg)

### 注意

你不必完全理解 `Applicative` 的 `(->) r` 实例是如何工作的，所以如果你现在不理解这一切，不要绝望。尝试玩转应用风格和函数，以获得一些关于如何将函数作为应用使用的见解。

## 压缩列表

实际上，列表作为 applicative 函子有更多的方式。我们已经介绍了一种方法：使用函数列表和值列表调用`<*>`，这会产生一个包含所有可能的将左列表中的函数应用于右列表中的值的组合的列表。

例如，如果我们编写`[(+3),(*2)] <*> [1,2]`，`(+3)`将被应用于`1`和`2`，而`(*2)`也将被应用于`1`和`2`，结果是一个包含四个元素的列表：`[4,5,2,4]`。然而，`[(+3),(*2)] <*> [1,2]`也可以以这种方式工作，即左列表中的第一个函数应用于右列表的第一个值，第二个函数应用于第二个值，依此类推。这将产生一个包含两个值的列表：`[4,4]`。你可以将其视为`[1 + 3, 2 * 2]`。

我们还没有遇到的一个`Applicative`实例是`ZipList`，它位于`Control.Applicative`中。

因为一个类型不能为同一个类型类有两个实例，所以引入了`ZipList a`类型，它有一个构造函数（`ZipList`）和一个字段（一个列表）。以下是实例：

```
instance Applicative ZipList where
        pure x = ZipList (repeat x)
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
```

`<*>`将第一个函数应用于第一个值，第二个函数应用于第二个值，依此类推。这是通过`zipWith (\f x -> f x) fs xs`完成的。由于`zipWith`的工作方式，结果列表的长度将等于两个列表中较短的那个。

`pure`在这里也很有趣。它接受一个值并将其放入一个只重复该值无限次的列表中。`pure "haha"`的结果是`ZipList (["haha", "haha","haha"...`。这可能会有些令人困惑，因为你已经了解到`pure`应该将值放入一个最小化但仍能产生该值的上下文中。你可能还在想，无限列表几乎不可能是最小化的。但是，在 zip 列表中，这是有意义的，因为它必须在每个位置上产生该值。这也满足了`pure f <*> xs`应该等于`fmap f xs`的法律。如果`pure 3`仅仅返回`ZipList [3]`，那么`pure (*2) <*> ZipList [1,5,10]`将导致`ZipList [2]`，因为两个 zip 列表组合后的列表长度等于两个列表中较短的那个。如果我们用一个有限列表和一个无限列表进行 zip，结果列表的长度将始终等于有限列表的长度。

那么，zip 列表在 applicative 风格中是如何工作的呢？嗯，`ZipList a`类型没有`Show`实例，因此我们需要使用`getZipList`函数从一个 zip 列表中提取一个原始列表：

```
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
[101,102,103]
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]
[101,102,103]
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]
[5,3,3,4]
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
[('d','c','r'),('o','a','a'),('g','t','t')]
```

### 注意

`(,,)`函数等同于`\x y z -> (x,y,z)`。同样，`(,)`函数等同于`\x y -> (x,y)`。

除了 `zipWith` 之外，标准库还有 `zipWith3`、`zipWith4` 等函数，一直可以到 `zipWith7`。`zipWith` 接受一个接受两个参数的函数，并用它来连接两个列表。`zipWith3` 接受一个接受三个参数的函数，并用它来连接三个列表，以此类推。通过使用以应用风格连接的列表，我们不需要为想要连接的每个列表数量都有一个单独的连接函数。我们只需使用应用风格将任意数量的列表与一个函数连接起来，这非常方便。

## 应用定律

正如正常的函子一样，应用函子附带一些定律。最重要的定律是 `pure f <*> x = fmap f x` 这个定律。作为一个练习，你可以为我们在本章中遇到的一些应用函子证明这个定律。以下是一些其他的应用定律：

+   `pure id <*> v = v`

+   `pure (.) <*> u <*> v <*> w = u <*> (v <*> w)`

+   `pure f <*> pure x = pure (f x)`

+   `u <*> pure y = pure ($ y) <*> u`

我们不会详细讨论它们，因为这会占用很多页面并且有点无聊。如果你感兴趣，你可以仔细看看它们，看看它们是否适用于某些实例。

# 应用函子的有用函数

`Control.Applicative` 定义了一个名为 `liftA2` 的函数，其类型如下：

```
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
```

它被定义为这样：

```
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
liftA2 f a b = f <$> a <*> b
```

它只是在一个应用值之间应用一个函数，隐藏了我们讨论过的应用风格。然而，它清楚地展示了为什么应用函子比普通函子更强大。

对于普通函子，我们可以在一个函子值上映射函数。对于应用函子，我们可以在几个函子值之间应用一个函数。观察这个函数的类型 `(a -> b -> c) -> (f a -> f b -> f c)` 也很有趣。当我们这样看待它时，我们可以说 `liftA2` 接受一个正常的二元函数并将其提升为一个在两个应用值上操作的函数。

这里有一个有趣的概念：我们可以取两个应用值并将它们组合成一个应用值，其中包含这两个应用值的结果列表。例如，我们有 `Just 3` 和 `Just 4`。让我们假设第二个包含一个单元素列表，因为这很容易实现：

```
ghci> fmap (\x -> [x]) (Just 4)
Just [4]
```

好吧，所以假设我们有 `Just 3` 和 `Just [4]`。我们如何得到 `Just [3,4]`？这很简单：

```
ghci> liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci> (:) <$> Just 3 <*> Just [4]
Just [3,4]
```

记住 `:` 是一个函数，它接受一个元素和一个列表，并返回一个新列表，其中包含该元素在开头。现在我们有了 `Just [3,4]`，我们能否将其与 `Just 2` 结合以产生 `Just [2,3,4]`？是的，我们可以。看起来我们可以将任意数量的应用值组合成一个包含那些应用值结果列表的应用值。

让我们尝试实现一个函数，它接受一个应用值列表并返回一个结果值为列表的应用值。我们将它称为 `sequenceA`。

```
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA [] = pure []
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs
```

哎，递归！首先，我们看看类型。它将一个 applicative 值的列表转换成一个包含列表的 applicative 值。从那以后，我们可以为基本情况打下一些基础。如果我们想将一个空列表转换成一个包含结果列表的 applicative 值，我们只需将一个空列表放入默认上下文中。现在轮到递归了。如果我们有一个包含头部和尾部的列表（记住`x`是一个 applicative 值，而`xs`是它们的列表），我们在尾部上调用`sequenceA`，这将产生一个包含列表的 applicative 值。然后我们只需将 applicative `x`中的值作为列表的前缀添加到那个 applicative 中，这样就完成了！

假设我们这样做：

```
sequenceA [Just 1, Just 2]}
```

根据定义，这等于以下内容：

```
(:) <$> Just 1 <*> sequenceA [Just 2]
```

进一步分解，我们得到以下内容：

```
(:) <$> Just 1 <*> ((:) <$> Just 2 <*> sequenceA [])
```

我们知道`sequenceA []`最终会变成`Just []`，所以这个表达式现在如下所示：

```
(:) <$> Just 1 <*> ((:) <$> Just 2 <*> Just [])
```

这就是：

```
(:) <$> Just 1 <*> Just [2]
```

这等于`Just [1,2]`！

实现`sequenceA`的另一种方式是使用折叠。记住，几乎任何通过遍历列表元素并沿途累积结果的函数都可以使用折叠来实现：

```
sequenceA :: (Applicative f) => [f a] -> f [a]
sequenceA = foldr (liftA2 (:)) (pure [])
```

我们从列表的右侧开始处理列表，并使用一个累加器值`pure []`作为起始值。我们在累加器和列表的最后一个元素之间放置`liftA2 (:)`，这会产生一个包含单例元素的 applicative。然后我们使用现在的最后一个元素和当前的累加器调用`liftA2 (:)`，以此类推，直到我们只剩下一个累加器，它包含所有 applicative 的结果列表。

让我们在一些 applicative 上试一下我们的函数：

```
ghci> sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci> sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci> sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]
```

当用于`Maybe`值时，`sequenceA`创建一个包含所有结果列表的`Maybe`值。如果一个值是`Nothing`，那么结果也是`Nothing`。当你有一系列`Maybe`值，并且你只对那些没有`Nothing`的值感兴趣时，这很酷。

当与函数一起使用时，`sequenceA`接受一个函数列表，并返回一个返回列表的函数。在我们的例子中，我们创建了一个函数，它接受一个数字作为参数，并将其应用于列表中的每个函数，然后返回一个结果列表。`sequenceA [(+3),(+2),(+1)] 3`将使用`3`调用`(+3)`，使用`3`调用`(+2)`，使用`3`调用`(+1)`，并将所有这些结果作为列表展示。

执行`(+) <$> (+3) <*> (*2)`将创建一个函数，该函数接受一个参数，将其传递给`(+3)`和`(*2)`，然后使用这两个结果调用`+`。同样地，`sequenceA [(+3),(*2)]`创建一个函数，该函数接受一个参数，并将其传递给列表中的所有函数。而不是使用函数的结果调用`+`，而是使用`:`和`pure []`的组合来收集这些结果到一个列表中，这就是该函数的结果。

当我们有一系列函数，并希望将相同的输入提供给所有这些函数，然后查看结果列表时，使用`sequenceA`是有用的。例如，假设我们有一个数字，我们想知道它是否满足列表中的所有谓词。这里有一种方法可以做到这一点：

```
ghci> map (\f -> f 7) [(>4),(<10),odd]
[True,True,True]
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]
True
```

记住，`and`接受一个布尔值列表，如果它们都是`True`，则返回`True`。另一种实现相同功能的方法是使用`sequenceA`：

```
ghci> sequenceA [(>4),(<10),odd] 7
[True,True,True]
ghci> and $ sequenceA [(>4),(<10),odd] 7
True
```

`sequenceA [(>4),(<10),odd]`创建一个函数，该函数将接受一个数字并将其提供给`[(>4),(<10),odd]`中的所有谓词，并返回一个布尔值列表。它将类型为`(Num a) => [a -> Bool]`的列表转换为类型为`(Num a) => a -> [Bool]`的函数。非常巧妙，不是吗？

由于列表是同质的，列表中的所有函数都必须是相同类型的函数。你不能有一个像`[ord, (+3)]`这样的列表，因为`ord`接受一个字符并返回一个数字，而`(+3)`接受一个数字并返回一个数字。

当与`[]`一起使用时，`sequenceA`接受一个列表的列表，并返回一个列表的列表。它实际上创建了包含所有可能元素组合的列表。为了说明，这里是用`sequenceA`和列表推导式完成的先前的例子：

```
ghci> sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci> sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> [[x,y] | x <- [1,2], y <- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci> sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
```

`(+) <$> [1,2] <*> [4,5,6]`的结果是一个非确定性计算`x + y`，其中`x`取自`[1,2]`中的每个值，`y`取自`[4,5,6]`中的每个值。我们将其表示为一个包含所有可能结果的列表。同样，当我们调用`sequenceA [[1,2],[3,4],[5,6]]`时，结果是`[x,y,z]`的非确定性计算，其中`x`取自`[1,2]`中的每个值，`y`取自`[3,4]`中的每个值，依此类推。为了表示这个非确定性计算的结果，我们使用一个列表，其中每个元素都是一个可能的列表。这就是为什么结果是列表的列表。

当与 I/O 操作一起使用时，`sequenceA`与`sequence`相同！它接受一个 I/O 操作的列表，并返回一个 I/O 操作，该操作将执行每个操作，并将结果作为执行这些 I/O 操作的结果的列表。这是因为要将`[IO a]`值转换为`IO [a]`值，以使 I/O 操作在执行时产生一个结果列表，所有这些 I/O 操作都必须按顺序排列，以便在求值时依次执行。你无法在不执行的情况下获得 I/O 操作的结果。

让我们按顺序排列三个`getLine` I/O 操作：

```
ghci> sequenceA [getLine, getLine, getLine]
heyh
ho
woo
["heyh","ho","woo"]
```

总结来说，应用函子不仅有趣，而且有用。它们允许我们通过应用风格结合不同的计算——例如 I/O 计算、非确定性计算、可能失败的计算等等。仅仅通过使用`<$>`和`<*>`，我们就可以使用普通函数对任意数量的应用函子进行统一操作，并利用每个函子的语义。
