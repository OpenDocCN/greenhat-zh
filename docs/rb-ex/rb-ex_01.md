# 第一章. 交互式 Ruby 和 Ruby 环境

![无标题图片](img/httpatomoreillycomsourcenostarchimages686190.png.jpg)

在 Ruby 中，就像在大多数编程语言中一样，我们通常会存储程序在外部文件中，并一次性执行它们作为一个单元。然而，Ruby 也允许您逐行输入程序的代码，并在进行过程中查看结果，使用交互式 Ruby（irb）；irb 是一个 shell，类似于 Unix 或类似 Unix 系统中的 bash 或 Windows 中的命令提示符。使用 irb 将让您了解 Ruby 如何处理信息，这也有助于您在编写程序之前就理解 Ruby 的基础知识。

谁应该阅读这一章？如果您已经使用过 Ruby，并且已经知道 *表达式、irb、流程控制、变量、函数、方法* 和 *常量* 这些术语的含义，您可能只需浏览这一章。（如果您以后遇到任何不熟悉的内容，您总是可以回来。）如果您以前从未编程过，您应该仔细阅读这一章。如果您已经使用过具有交互式环境的语言，如 Lisp 或 Python，您可能只需查看 irb 会话，以了解 Ruby 与您已知的语言有何不同——它可能在某些关键方面有所不同。

irb 程序是一个 *读取-评估-打印循环*（REPL）环境的例子。这个想法来自 Ruby 的祖先 Lisp。这意味着正如其名所说：它 *读取* 一行，*评估* 该行，*打印* 评估的结果，然后 *循环*，等待读取另一行。shell 会立即对您输入的每一行给出反馈，这是学习一种语言语法的理想方式。

# 启动 irb

启动 irb 非常简单。在 Unix 或类似 Unix 的机器上（例如 GNU/Linux 或 Mac OS X），你只需在 shell 提示符下输入 **`irb`**。这应该会给你以下结果：

```
$ irb
irb(main):001:0>
```

在 Windows 机器上，您可以选择 **开始 ▸ 运行**，输入 **`irb`**，然后点击 **确定**。您也可以直接从命令行运行 **`irb`** 命令。

# 使用 irb

现在您已经启动了它，irb 正在等待您输入第一行。*行* 由一个或多个表达式组成。

## 表达式

就 Ruby 而言，一个 *表达式* 只是一段有值的代码。按照精细的计算机编程传统，让我们看看 irb 对表达式 `“Hello, world!”` 的反应。

```
irb(main):001:0> "Hello, world!"
=> "Hello, world!"
```

### 注意

*此列表显示了您需要输入的行以及 irb 的响应。请注意，irb 还会在每行的开头显示行号。我偶尔会引用这些数字，以及*。

发生了什么？您输入了 `“Hello, world!”`，irb 高兴地将其直接返回给您。有趣的部分在于不明确的部分。您输入的表达式在 Ruby 中有一个值，因此也在 irb 中。`“Hello, world!”` 是一个 *字符串*，它是一系列字符，通常用单引号或双引号括起来。让我们来证明这一点。

## 一切都是对象

在 Ruby 中，就像它的祖先 Smalltalk 一样，一切都是一个*对象*，它只是一个类的实例。`“Hello, world!”`是字符串类的一个实例。

让我们在 irb 中验证一下：

```
irb(main):002:0> "Hello, world!".class
=> String
```

对象有*方法*（在对象上调用时为`some_object.some_method`），这些方法只是对象可以执行的操作。调用`class`方法只是简单地报告某个事物属于哪个类；换句话说，它是哪种类型的东西。由于`“Hello, world!”`是一个字符串，所以当在`“Hello, world!”`上调用`class`方法时，它报告的就是这个。当然，除了字符串之外，还有其他类型的对象。

### 注意

*本书假设你已经熟悉面向对象。如果你不熟悉，这里有一个简要的描述。对象是一个东西。它可以是任何类型的东西。每个对象都是类的实例；例如，对象*格拉斯哥、开罗*和*布法罗*都是类*`City`*的实例。这些对象彼此不同，但它们是同一类型的东西*。蒙提·派森*和*儿童在厅里*都是类*`Comedy Troupe`*的实例，等等。在 Ruby 中，你通常会使用全部小写字母命名实例，并在空格处使用下划线；你将使用驼峰命名法命名类。在实际的 Ruby 代码中，类*`ComedyTroupe`*将具有名为*`monty_python`*和*`kids_in_the_hall`*的实例（对象）**。

## 整数、Fixnums 和 Bignums

另一种类型的对象（或类）是*整数*，它是指可以被 1 整除的任何数字。这些应该对你来说很熟悉：0，1，-5，27 等等。让我们在 irb 中输入一个整数。

```
irb(main):003:0> 100
=> 100
```

### 注意

*如果你在整数上调用`class`方法，它将报告 Fixnum 或 Bignum，而不是 Integer。这源于 Ruby 内部存储数字的方式。计算机在不需要浪费空间的情况下可以更快地运行，所以它们必须担心数字占用多少空间。然而，计算机还需要能够处理非常大的数字。因此，它们做出了妥协，存储小的数字以节省空间，但同时也存储非常大的数字，这些数字不可避免地会占用更多的空间。像 Ruby 这样的高级语言会自动在这些不同类型的数字之间进行转换，所以你只需处理数字，无需担心这些具体的细节。这不是很方便吗？例如，*`100.class`*返回*`Fixnum`*，而*`(100 ** 100).class`*返回*`Bignum`*。这是因为 100 足够小，可以放入 Fixnum 中，但*`(100 ** 100)`*的值只能放入 Bignum 中——它太大，不能放入 Fixnum 中*。

我们可以看到，数字 100 在 irb 中的值是 100，正如你所期望的那样。但我们都想能够做更多的事情，而不仅仅是看到我们输入的内容，所以让我们用我们的数字 100 来做点什么。让我们把它加到 100 上。

```
irb(main):004:0> 100 + 100
=> 200
```

你可以看到 irb 已经正确地添加了这些数字，并显示了结果。在 Ruby 中，`100 + 100`是一个表达式，就像`“Hello, world!”`和单独的`100`一样也是表达式。`100 + 100`的值自然是 200。数字有一个名为`+`的方法，这是它们如何将自己添加到其他数字的方法。这正是我们在这里所做的事情。

## 加法、连接和异常

`+`符号不仅能加数字。让我们添加另外两个表达式：

```
irb(main):005:0> "Hello, " + "world!"
=> "Hello, world!"
```

通过将字符串`“Hello,”`添加到字符串`“world!”`中，我们创建了新的更长的字符串`“Hello, world!”`。字符串并不真正执行加法操作，它们使用`+`符号执行一个称为*连接*的操作，这仅仅是把一个东西附加到另一个东西的末尾。在 Ruby 中，`+`符号意味着*执行对这个类对象最有意义的类似加法操作*。这允许你只使用`+`符号并假设整数将以合理的“数字”方式相加，字符串将以合理的“字符串”方式相加，依此类推。

当我们尝试将两种不同类型的对象相加时会发生什么？让我们在 irb 中找出答案。

```
irb(main):006:0> "Hello, world!" + 100
TypeError: failed to convert Fixnum into String
        from (irb):6:in '+'
        from (irb):6
```

这个表达式没有像其他表达式那样顺利。`TypeError`是 Ruby（以及许多其他语言）称为*异常*的例子，这是编程语言发出的错误通知。我们的`TypeError`意味着 Ruby 对我们要求将字符串添加到数字中并不高兴.^([4]) 字符串知道如何将自己相加，数字也是如此——但它们不能跨越类型。在加法中，我们希望两个操作数都是同一类型。

## 类型转换

这个问题的解决方案是一个称为*类型转换*的操作，即将某物从一种类型转换为另一种类型。让我们在 irb 中看看类型转换的例子：

```
irb(main):007:0> "Hello, world!" + 100.to_s
=> "Hello, world!100"
```

在尝试将`100`添加到`“Hello, world!”`之前，我们调用`to_s`方法。这个方法代表将对象转换为*字符串*——正如你可能猜到的，它将调用它的对象转换为字符串。在我们需要将这两个操作数相加的时候，它们都是字符串，Ruby 忠实地将它们连接起来.^([5]) 让我们验证`100.to_s`是否是一个字符串：

```
irb(main):008:0> 100.to_s
=> "100"
```

所以是的。但当我们想要将某个东西转换为整数时会发生什么？是否有`to_i`方法可以调用字符串`“100”`？让我们找出答案。

### 注意

*在强类型语言中，如 Ruby，类型转换很常见。在弱类型语言中，虽然也可能出现，但不太常见。两种方法都有其支持者*。

```
irb(main):009:0> "100".to_i
=> 100
```

我们确实可以。所以我们现在知道如何通过`to_s`或`to_i`方法将字符串和整数相互转换。如果我们能查看一个给定对象可以调用的所有方法列表，那会很好。我们也可以通过一个恰如其名的`methods`方法来做这件事。让我们在整数 100 上调用它：

```
irb(main):010:0> 100.methods
=> ["<=", "to_f", "abs", "-", "upto", "succ", "|", "/", "type", "times", "%",
"-@", "&", "~", "<", "**", "zero?", "^", "<=>", "to_s", "step", "[]", ">",
"==", "modulo", "next", "id2name", "size", "<<", "*", "downto", ">>", ">=",
"divmod", "+", "floor", "to_int", "to_i", "chr", "truncate", "round", "ceil",
"integer?", "prec_f", "prec_i", "prec", "coerce", "nonzero?", "+@", "remainder",
"eql?", "===", "clone", "between?", "is_a?", "equal?", "singleton_methods",
"freeze", "instance_of?", "send", "methods", "tainted?", "id",
"instance_variables", "extend", "dup", "protected_methods", "=~", "frozen?",
"kind_of?", "respond_to?", "class", "nil?", "instance_eval", "public_methods",
"__send__", "untaint", "__id__", "inspect", "display", "taint", "method",
"private_methods", "hash", "to_a"]
```

你可以看到`+`和`to_s`都在方法名列表中.^([6])

## 数组

注意`methods`输出的括号是如何用方括号`[]`括起来的。这些括号表示括号内的项是数组的成员，数组是对象的列表。数组只是 Ruby 中的另一个类，就像 String 或 Integer 一样，而且（与某些其他语言不同）没有要求给定数组中的所有成员必须是同一类的实例。

将单个项目转换为数组的一种简单方法是将它用括号括起来，如下所示：

```
irb(main):011:0> [100].class
=> Array
```

数组也知道如何添加自己，如下所示：

```
irb(main):012:0> [100] + ["Hello, world!"]
=> [100, "Hello, world!"]
```

结果只是一个包含所有添加的数组元素的另一个数组。

## 布尔值

除了 String、Integer 和 Array 之外，Ruby 还有一个名为 Boolean 的类。字符串是字符序列，整数是任何可以被 1 整除的数，数组是成员的列表。*布尔值*只能是真或假。布尔值有很多用途，但它们最常用于确定是否执行一个动作或另一个动作的评估操作。这类操作被称为*流程控制*。

### 注意

*布尔值是以数学家乔治·布尔的名字命名的，他做了大量早期工作来形式化它们*。

## 流程控制

最常用的流程控制操作之一是`if`。它评估其后的表达式为真或假。让我们用`if`演示一些流程控制：

```
irb(main):013:0> 100 if true
=> 100
```

我们刚刚询问表达式`100 if true`是否为真。由于表达式`true`评估为真值，所以我们确实得到了值`100`。当`if`评估的表达式不为真时会发生什么？

```
irb(main):014:0> 100 if false
=> nil
```

这是一种新的情况。表达式`false`不是真的，所以我们没有得到表达式`100`。事实上，我们什么都没有得到——irb 告诉我们它没有值可以报告。Ruby 有一个特定的值表示值的缺失（或无意义的值），即`nil`。

值可能因多种原因而缺失。它可能是一个无法表达的概念，或者它可能指的是缺失的数据，这正是我们例子中的情况。当我们评估的表达式为假时，我们从未告诉 irb 要报告什么，因此值是缺失的。任何可能需要表示为*n/a*的值都是`nil`值的良好候选。当你与数据库交互时，这种情况经常发生。并非所有语言都有`nil`；一些语言有，但假设它必须是错误。Ruby 完全适应在适当的地方使用`nil`值。

`nil`值与所有其他值都不同。然而，当我们强制 Ruby 将`nil`评估为布尔值时，它评估为`false`，如下所示：

```
irb(main):015:0> "It's true!" if nil
=> nil
```

唯一评估为假布尔值的值是`nil`和`false`。在许多其他语言中，`0`或`“”`（一个零字符的字符串）也会评估为假，但在 Ruby 中并非如此。当强制转换为布尔值时，除了`nil`或`false`之外的所有内容都评估为真。

### 注意

*我们必须显式地将字符串和整数转换为彼此，使用`*to_s*`和`*to_i*`方法，但请注意，对于布尔值我们不需要这样做。当你使用`*if*`时，布尔转换是隐式的。如果你要显式地将布尔值转换为其他类型，你可能会期望有一个类似于`*to_s*`和`*to_i*`的方法，称为`*to_b*`。但在 Ruby 中目前还没有这样的方法，但我们在第三章中会自己编写一个*。

假设我们希望在评估表达式为真时得到某个特定值（就像我们之前用`if`做的那样），同时当评估表达式为假时也希望得到一些非`nil`值。我们该如何做呢？以下是一个在 irb 中的示例：

```
irb(main):016:0> if true
irb(main):017:1> 100
irb(main):018:1> else
irb(main):019:1* 50
irb(main):020:1> end
=> 100
```

这是我们第一次在 irb 中的多行表达式。它应该相当简单，返回`100`，因为`true`评估为真。让我们再次尝试，但有一些不同之处：

```
irb(main):021:0> if false
irb(main):022:1> 100
irb(main):023:1> else
irb(main):024:1* 50
irb(main):025:1> end
=> 50
```

这次，由于`false`评估为非真，多行表达式的值就是`else`中的值，即`50`。这种格式比之前只使用`if`的测试要复杂一些。我们还需要`end`关键字来告诉 irb 我们何时完成了从`if`开始的表达式。如果我们想经常进行这样的多行表达式测试，反复输入相同基本想法的微小变化可能会变得繁琐。这就是方法发挥作用的地方。

### 注意

*注意，irb 在其提示符中给你一些有用的信息。提示符通常以`*`符号结束，通常前面有一个数字。这个数字表示你处于多少层深度，即你需要多少个`end`语句才能回到顶层。你也会注意到，有时提示符不会以`*`符号结束，而是以星号(*)结束。这意味着 irb 只有一个不完整的语句，正在等待该语句被完成。非常有用*。

## 方法

我们之前提到了方法，但现在我们将更详细地讨论它们。一个*方法*只是附加到对象上的一小段代码；它接受一个或多个输入值并返回一个结果。^([7]) 我们称方法的输入为*参数*或*参数*，称结果值为*返回值*。我们在 Ruby 中使用`def`关键字定义方法：

```
irb(main):026:0> def first_if_true(first, second, to_be_tested)
irb(main):027:1> if to_be_tested
irb(main):028:2> first
irb(main):029:2> else
irb(main):030:2* second
irb(main):031:2> end
irb(main):032:1> end
=> nil
```

我们刚刚定义了一个名为`first_if_true`的方法，它接受三个参数（分别称为`first, second`和`to_be_tested`）并根据`to_be_tested`是否评估为真返回`first`或`second`的值。我们现在已经将之前的多行测试定义为可以重复使用不同值的抽象概念。让我们试试看。

### 注意

*`first_if_true` 的名字告诉你它将做什么。这是一个好习惯。方法名应该告诉你它们做什么。清晰直观的方法名是良好文档的重要部分。同样的建议也适用于稍后描述的变量。根据这个标准，*`result`*（如稍后所见）不是一个很好的名字。对于仅仅介绍将值赋给变量的概念的一个简单例子来说是可以的，但对于真正的生产代码来说，它太模糊了*。

记住 `first_if_true` 测试第三个值，然后返回第一个值或第二个值。

```
irb(main):033:0> first_if_true(1, 2, true)
=> 1
irb(main):034:0> first_if_true(1, 2, false)
=> 2
irb(main):035:0> first_if_true(1, 2, nil)
=> 2
irb(main):036:0> first_if_true(nil, "Hello, world!", true)
=> nil
irb(main):037:0> first_if_true(nil, "Hello, world!", false)
=> "Hello, world!"
```

随时可以在 irb 中尝试使用不同的参数来测试 `first_if_true` 方法，无论是现在还是以后。这应该能给你一个很好的想法，了解 Ruby 如何处理表达式。

### 注意

*当方法被使用时，它们会返回值，但定义一个方法的简单行为会返回 *`nil`*，正如你所看到的*。

## 变量

如果你想要将一个方法的输出作为另一个方法的输入，会发生什么？这样做最方便的方法之一是使用 *变量*。类似于代数或物理学，我们只是决定通过名字来引用某个值，比如用 *m* 表示某个特定的质量，用 *v* 表示某个特定的速度。我们用一个单独的 `=` 符号将值赋给变量，如下所示：

```
irb(main):038:0> result = first_if_true(nil, "Hello, world!", false)
=> "Hello, world!"
irb(main):039:0> result
=> "Hello, world!"
```

我们将 `first_if_true(nil, “Hello, world!”, false)`（恰好是 `"Hello, world!"`）的值赋给了一个名为 `result` 的变量。现在，我们已经在 `result` 这个名字下存储了 `"Hello, world!"` 这个值，它仍然按照你预期的那样评估，正如你在第 39 行所看到的。现在我们可以像使用任何其他值一样使用 `result`：

```
irb(main):040:0> first_if_true(result, 1, true)
=> "Hello, world!"
irb(main):041:0> first_if_true(result, 1, result)
=> "Hello, world!"
```

注意我们如何可以将 `result` 通过 `first_if_true` 传递，并评估它（作为 `to_be_tested`）的布尔值。我们也可以将它作为更大表达式的一部分：

```
irb(main):042:0> first_if_true(result, 1, (not result))
=> 1
```

在第 42 行的例子中，我们在将 `result` 传递给 `first_if_true` 之前，用关键字 `not` 反转了 `result` 的布尔值。我们在第 42 行没有对 `result` 进行任何修改。我们只是创建了一个新的表达式 `(not result)`，它恰好评估为 `result` 的布尔相反值。`result` 本身保持不变。

### 注意

*我添加了一些空格，只是为了更容易阅读哪些括号包含了方法的参数，哪些括号包含了 *`(not result)`* 表达式。Ruby 和 irb 对空白符并不很关心*。

## 常量

有时候我们想要通过名字来引用一个值，但不需要改变它。实际上，有时候我们打算不改变它。物理学中的好例子是光速或地球重力加速度——它们不会改变。在 Ruby 中，我们可以将这些值定义为 *常量*，这些常量必须以大写字母开头。（按照传统，它们通常是全部大写。）让我们定义一个常量然后使用它：

```
irb(main):043:0> HUNDRED = 100
=> 100
irb(main):044:0> first_if_true( HUNDRED.to_s + ' is true', false, HUNDRED )
=> "100 is true"
```

我们看到我们可以像给变量赋值一样给常量赋值。然后我们可以按名字使用那个常量，作为一个表达式或在一个更大的表达式中，根据需要。

* * *

^([4]) 在我们的例子中，特别是一个 Fixnum。

^([5]) 从技术上来说，我们并没有进行类型转换，而是创建了一个全新的对象，它恰好是数字 100 的字符串等价物。

^([6]) 顺便说一下，你可以将方法链接起来，例如`100.methods.sort`。如果你在 irb 中尝试这样做，你会得到与`100.methods`相同的函数列表，但按字母顺序排列。

^([7]) Ruby 是面向对象的，因此它使用*方法*这个术语。那些不太注重面向对象的语言可能会把方法称为*函数*。*方法*就是一个附加到对象上的函数。

# 使用 Ruby 解释器和环境

如果你来自 Unix 背景，你可能已经熟悉命令行选项和环境变量的概念。如果你不熟悉这些术语，它们只是计算机跟踪外部数据（通常是配置选项）的方式。Ruby 使用*命令行选项*和*环境变量*来跟踪诸如在安全方面应该多么谨慎或宽松，以及关于警告应该多么详细等问题。我们已经在从源代码下载安装 Ruby 的说明中看到了一个例子，当时我们执行了以下命令：

```
ruby --version
```

如你所料，这仅仅是要求 Ruby 报告其版本。你可以通过执行以下命令来找出 Ruby 理解的各种命令行选项：

```
ruby -h
```

环境变量可以存储这些命令行选项作为默认值；它们还可以存储 Ruby 可能仍认为执行某些任务所必需的其他信息。Unix-like 系统的用户将他们的文件存储在一个称为*HOME*目录中，这样可以避免其他用户的数据。Windows 中的“我的文档”文件夹与此类似。另一个重要的环境变量是`ARGV`，它是一个数组，用于跟踪传递给 Ruby 的所有参数。当你执行外部 Ruby 程序时（你通常会使用以下语法），程序的名字将会在`ARGV`中找到。

```
ruby some_external_program.rb
```

让我们继续探讨一些具体的示例程序。我们将更详细地处理本章中仅略提的一些主题，并针对每个示例进行适当的深入探讨。
