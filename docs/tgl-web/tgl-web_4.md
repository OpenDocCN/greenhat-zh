# 第三部分。未来的展望

经过近十年的停滞，浏览器世界再次成为了一场激烈的战场。这让人不禁联想到 20 世纪 90 年代末的第一场浏览器大战，厂商们通过每月推出新功能来竞争。主要的不同之处在于，现在安全性被视为一个明显的卖点。

当然，客观地衡量任何足够复杂的软件的健壮性是计算机科学中的一个未解问题，如果你的代码库恰好承载了近二十年的膨胀，那就更是如此。因此，大部分的竞争努力都投入到发明并迅速部署新的以安全为主题的新增功能中，往往很少考虑它们实际上解决他们应该解决的问题的能力。

同时，考虑到他们早期的失误，标准机构已经放弃了大部分学术上的严谨性，转而让一群专门的贡献者根据他们的看法调整规范。有传言称，将 HTML5 作为标准的最后一个编号版本，并过渡到一个每天都会变化——通常是根本性变化——的活文档。放宽要求有助于保持 W3C 和 WHATWG 周围的大部分工作持续进行，但也削弱了拥有一个中心组织的一些好处。许多最近的提案都倾向于快速、范围狭窄的修补，甚至不试图形成一个一致且高度集成的框架。当这种情况发生时，没有稳健的反馈机制来允许外部专家在实施工作开始之前合理地审查稳定规范并表达担忧。跟上变化的唯一方法就是沉浸在工作组的日常动态中。

很难说这种新的标准化方法是否是坏事。事实上，它的好处可能轻易地超过任何推测性的风险；首先，我们现在有机会得到一个与浏览器实际操作相当接近的标准。尽管如此，这个疯狂且很大程度上不受监督的过程的结果可能是不可预测的，这要求安全社区保持高度警惕。

在这种精神下，本书的最后一部分将探讨一些更合理和先进的建议，这些建议可能会塑造 Web 的未来……或者也可能在几年后最终被历史垃圾箱所淘汰。

# 第十六章。新和即将推出的安全功能

你很快就会意识到所有这些新浏览器功能之间的结合几乎没有规律和理由，但我们仍然需要以某种方式组织讨论。也许最好的方法就是看看它们的预期目的，并从专门为调整 Web 的安全模型以获得明确收益而创建的所有机制开始。

社区内强烈渴望发明一种全新的浏览器安全模型，但随之而来的是意识到这将需要重建整个网络。因此，大部分实际工作都集中在对现有方法的更谦逊扩展上，这不可避免地增加了浏览器代码库中安全关键部分复杂性。这种复杂性不受欢迎，但它的支持者总是认为这是合理的，无论是为了减轻一类漏洞，还是为了为一些其他难以解决的问题提供一个临时的解决方案，或者简单地为了在未来能够构建新的应用程序类型。所有这些好处通常都超过了模糊的风险。

# 安全模型扩展框架

在过去几年中，一些最成功的安全增强措施归结为向由同源策略及其相关策略强加的原始约束中增加灵活性。例如，一个曾经是实验性的提议现在已经进入主流，那就是用于跨源通信的 *postMessage(...)* API，这在第九章中有讨论。令人惊讶的是，在某些精心选择的场景中放松 SOP 检查的行为比锁定策略更为直观，也更不容易引起问题。因此，为了轻松开始，我们将首先关注这类框架。

## 跨域请求

在同源策略的原始约束下，与一个源关联的脚本没有干净且安全的方式与在任何其他源中执行的客户端脚本通信，也没有从愿意提供数据的第三方服务器中检索潜在有用数据的安全方式。

网络开发者长期以来一直抱怨这些约束，近年来，浏览器供应商开始倾听他们的需求。如您所忆，通过 *postMessage(...)* 解决了在脚本之间安排客户端通信的紧迫任务。客户端到服务器的场景被认为不那么紧急，但仍需一个标准化的解决方案，但已有一些进展可以报告。

创建从非同源服务器检索文档的方法最成功的尝试始于 2005 年。在 W3C 的赞助下，几位在开发用于构建交互式语音响应（IVR）系统的神秘文档格式 VoiceXML 的开发者，起草了一个关于 *跨源资源共享（CORS）* 的提议。240]。在 2007 年至 2009 年之间，他们笨拙的基于 XML 的设计逐渐演变成一个更简单、更广泛有用的方案，该方案依赖于 HTTP 头部级别的信号来通过 *XMLHttpRequest* API 的自然扩展来传达对跨源内容检索的同意。

### CORS 请求类型

如今天所指定，CORS 依赖于区分对 *XMLHttpRequest* API 的两种调用类型。当网站尝试通过 API 加载跨源文档时，浏览器首先需要区分 *简单请求*，其中生成的 HTTP 流量被认为足够接近通过其他现有导航方法生成的流量，以及 *非简单请求*，它包括所有其他内容。这两类请求的操作差异很大，正如我们将看到的。

当前规范表示，简单请求必须具有 GET、POST 或 HEAD 方法。此外，如果调用者指定了任何自定义标头，它们必须属于以下集合：

+   *Cache-Control*

+   *Content-Language*

+   *Content-Type*

+   *Expires*

+   *Last-Modified*

+   *Pragma*

今天，支持 CORS 的浏览器简单地不允许除 GET、POST 和 HEAD 之外的方法。同时，它们忽略了推荐的标头白名单，无条件地将任何具有自定义标头值的请求降级为非简单状态。WebKit 的实现还将任何携带有效载荷的请求视为非简单请求。（不清楚这是有意的设计决策还是错误。）

### 简单请求的安全检查

CORS 规范允许简单请求立即提交给目标服务器，而无需尝试确认目标是否愿意首先进行跨域通信。这个决定基于这样一个事实，攻击者可以通过其他手段（例如，通过自动提交表单）发起相当相似的基于 cookie 认证的流量，因此引入专门用于 CORS 的额外握手是没有意义的。（^[78]）

关键的安全检查仅在从服务器检索到响应后进行：只有当响应包含合适的、格式良好的 *Access-Control-Allow-Origin* 标头时，数据才会通过 *XMLHttpRequest* API 向调用者揭示。为了协助服务器，原始请求将包括一个强制性的 *Origin* 标头，指定与调用脚本关联的源。

为了说明这种行为，考虑以下从 [`www.bunnyoutlet.com/`](http://www.bunnyoutlet.com/) 发起的跨域 *XMLHttpRequest* 调用：

```
var x = XMLHttpRequest();
x.open('GET', 'http://fuzzybunnies.com/get_message.php?id=42', false);
x.send(null);
```

结果将是一个大致如下所示的 HTTP 请求：

```
GET /get_message.php?id=42 HTTP/1.0
Host: fuzzybunnies.com
Cookie: FUZZYBUNNIES_SESSION_ID=EA7E8167CE8B6AD93D43AC5AA869A920
`Origin: http://www.bunnyoutlet.com`
```

为了指示响应应在跨域中可读，服务器需要响应如下：

```
HTTP/1.0 200 OK
Access-Control-Allow-Origin: `http://www.bunnyoutlet.com`

The secret message is: "It's a cold day for pontooning."
```

### 注意

在 *Access-Control-Allow-Origin* 中使用通配符（“*”）是可能的，但请谨慎操作。在所有 HTTP 响应中无差别地设置 *Access-Control-Allow-Origin: ** 是不明智的，因为这步在很大程度上消除了 CORS 兼容浏览器中同源策略的任何保证。

### 非简单请求和预检

在 CORS 协议的早期草案中，几乎所有请求都旨在在没有首先检查服务器是否实际上愿意接受它们的情况下提交。不幸的是，这种设计破坏了某些网络应用利用的一个有趣特性，以防止跨站请求伪造：在 CORS 之前，攻击者无法将任意 HTTP 头部注入跨域请求中，因此自定义头部的存在通常作为请求来自与目标相同的源并且是通过 *XMLHttpRequest* 发出的证明。

后续的 CORS 修订通过要求一个更复杂的两步握手来纠正这个问题，该握手适用于不符合 CORS 请求类型 中概述的严格“简单请求”标准的请求，这些标准在 安全模型扩展框架 中。非简单请求的握手旨在确认目标服务器符合 CORS 规范，并且它希望接收来自特定调用者的非标准流量。握手是通过向目标 URL 发送一个包含底层 *XMLHttpRequest* 调用参数概述的纯 OPTIONS 请求（“预检”）来实现的。最重要的信息通过三个自解释的头部传递给服务器：*Origin*、*Access-Control-Request-Method* 和 *Access-Control-Request-Headers*。

这种握手只有在响应中通过使用 *Access-Control-Allow-Origin*、*Access-Control-Allow-Method* 和 *Access-Control-Allow-Headers* 正确认可这些参数时才被认为是成功的。在正确的握手之后，实际请求才会被发送。出于性能考虑，特定 URL 的预检检查结果可能会被客户端缓存一段时间。

### CORS 的当前状态

到目前为止，CORS 仅在 Firefox 和基于 WebKit 的浏览器中可用，并且在 Opera 或 Internet Explorer 中明显缺失。阻碍其采用的最重要因素可能仅仅是 API 并不像其客户端对应物 *postMessage(...)* 那样关键，因为它通常可以被服务器端的内容获取代理所替代。但是，该方案也面临着三个主要、尽管是轻微的批评，其中一些直接来自一家供应商。显然，这些批评并没有帮助解决问题。

第一项投诉主要是由微软的开发人员和一些学者提出的，他们认为该方案无谓地滥用环境权限。他们争辩说，在跨域共享数据的情况下，需要根据目标站点的凭证进行定制的情况非常少。批评者认为，意外泄露敏感信息的风险远远超过了任何好处，并且认为只允许进行非认证请求的方案更可取。在他们看来，任何需要某种形式认证的网站都应该依靠明确交换的认证令牌。^([79])

对 CORS 的另一种，更实际的批评是，该方案过于复杂：它扩展了一个已经问题重重且容易出错的 API，而没有清楚地解释一些调整的好处。特别是，预先请求增加的复杂性是否值得能够以非常规方法或随机头信息发出跨域请求的边缘利益并不清楚。

最后一点微弱的投诉基于这样一个事实，即 CORS 容易受到头信息注入的影响。与其他一些最近提出的浏览器功能不同，例如 WebSockets (第十七章)，CORS 不需要服务器回显一个不可预测的挑战字符串来完成握手。特别是与预检缓存结合使用时，这可能会加剧服务器端代码中某些头信息分割漏洞的影响。

## XDomainRequest

微软对 CORS 的反对似乎源于对使用环境权限的上述担忧，但也隐含着他们对与 W3C 互动的不满。2008 年，微软的程序经理 Sunava Dutta 提出了这个有些神秘的见解：^([241])

> 在[Internet Explorer 8] Beta 1 阶段，针对使用跨站 XMLHttpRequest 和访问控制框架进行跨域访问第三方数据提出了许多基于安全性的担忧。自 Beta 1 以来，我们有幸与其他浏览器和 W3C 面对面会议的与会者合作，以改善 W3C 访问控制框架的服务器端体验和安全性。

微软没有接受 CORS 对*XMLHttpRequest*的扩展，而是决定实施一个名为*XDomainRequest*的反提案。这个非常简单的新 API 与其他浏览器中可用的变体不同，其结果是请求始终是匿名的（即没有任何浏览器管理的凭证），并且它不允许使用任何自定义 HTTP 头或方法。

使用微软的 API 在其他方面与*XMLHttpRequest*非常相似：

```
var x = new XDomainRequest();
x.open("GET", "http://www.fuzzybunnies.com/get_data.php?id=1234");
x.send();
```

借鉴 W3C 的提案，生成的请求将包含一个*Origin*头，并且只有在响应中存在匹配的*Access-Control-Allow-Origin*头时，响应数据才会被调用者看到.^([80]) 预检请求和权限缓存不是设计的一部分。

就目的和用途而言，微软的解决方案比 CORS 更合理：它更简单、更安全，并且在所有可能的用途中可能同样有效。然而，它并不受欢迎。它仅在 Internet Explorer 8 及以上版本中受支持，由于 W3C 支持 CORS，其他人没有理由很快接受*XDomainRequest*。

同时，另一组研究人员在 W3C 的赞助下提出了第三个解决方案。他们的设计被称为统一消息策略（包括相应的*UniformRequest* API），^([243]) 采用的方法几乎与微软的方案相同。它不被任何现有浏览器支持，但有人谈论将其与 CORS 统一。

## Origin 头的其他用途

*Origin*头是 CORS、*XDomainRequest*和 UMP 的重要组成部分，但实际上它是独立于其他用途而演化的。在他们的 2008 年论文中，Adam Barth、Collin Jackson 和 John C. Mitchell^([244]) 倡导引入一个新的 HTTP 头，该头将提供一种比*Referer*更可靠和更注重隐私的替代方案。它还将通过向服务器提供所需的信息来识别请求的 SOP 级别源，而无需披露可能更敏感的路径或查询数据。

当然，是否在*Referer*及其建议的继任者之间存在的细微改进实际上会对那些基于隐私原因阻止第一个头的小部分但不可忽视的用户群体产生影响，这一点尚不清楚。因此，该提案最终陷入了一种虚拟的停滞状态，既没有被任何现有浏览器部署，也阻止了其他人追求其他解决方案，如 XSRF 或 XSSI.^([245])（公平地说，这个概念最近以*From-Origin*的新名字被重新启用，可能还没有完全消失。）^([246])

除了原始想法的命运之外，*Origin*头在 CORS 等特殊案例中的效用相当明显。大约在 2009 年，这导致了 Barth 提交了一份 IETF 草案，指定了头的语法，^([247]) 同时回避了关于何时发送头或它可能解决的具体安全问题的声明：

> 用户代理可以在任何 HTTP 请求中包含一个 Origin 头。
> 
> [...]
> 
> 当用户代理从“隐私敏感”的上下文中发起 HTTP 请求时，用户代理必须在 Origin 头中发送值“null”。
> 
> 注意：本文件未定义隐私敏感上下文的概念。生成 HTTP 请求的应用程序可以将上下文指定为隐私敏感，以对用户代理生成 Origin 标头的生成方式施加限制。

本规范的底线是，无论决策过程如何，一旦客户端选择提供该头，该值必须准确表示发起请求的 SOP 原因。例如，当特定操作从 [`www.bunnyoutlet.com:1234/bunny_reports.php`](http://www.bunnyoutlet.com:1234/bunny_reports.php) 发生时，传输的值应该是

```
Origin: http://www.bunnyoutlet.com:1234
```

对于无法有意义地映射到协议-主机-端口号元组的来源，浏览器必须发送 *null* 的值。

尽管有所有这些计划，但截至本文撰写时，只有一种浏览器在非 CORS 导航中包含 *Origin* 头：基于 WebKit 的实现会在提交 HTML 表单时发送它。Firefox 似乎正在考虑不同的方法，但似乎还没有实施任何具体措施。

* * *

^([77]) 恶意 URL 黑名单，这是该趋势的一个主要例子。黑名单是防病毒软件的一个轻量级、粗略的替代品，而防病毒软件本身又是不更新且设计不佳的软件的一个糟糕替代品。反恶意软件功能并不会使个别攻击更加困难；它们只是旨在阻止低级恶意软件的大规模传播，基于大多数用户不够有趣，不会成为特定目标或被巧妙攻击的假设。

^([78]) 该假设并不完全正确。例如，在引入此方案之前，攻击者无法发起一个与文件上传表单提交完全无法区分的跨域请求，但在 CORS 下，这种伪造是可能的。

^([79]) 同样的说法也可以用于任何其他设置中 HTTP cookies 的使用，看起来同样徒劳。确实，环境凭证比其他一些显式认证形式更频繁地引起问题，但它们的使用也更为方便，并且根本不会消失。

^([80]) 即使响应未经过认证，进行此检查的原因是为了防止将浏览器用作代理（例如，用于爬取内部网络或发送垃圾邮件）。

# 安全模型限制框架

扩展同源策略边界的方案相对简单易懂，并且通常安全失败。如果提议的更改没有在可能的代码路径之一中得到考虑，或者在某些特定浏览器中根本不支持，那么之前实施的、更严格的逻辑将启动。与这种方法相比，在现有的浏览器安全模型之上建立新的边界要危险得多。这是因为每个与安全相关的代码路径都必须调整以识别新的方案，并且每个浏览器都必须立即遵守，否则将出现意外问题。

在本节中，我们将快速查看一些更成功的尝试，这些尝试试图走这条危险但可能有益的道路——并探讨它们在哪里分道扬镳。

## 内容安全策略

*内容安全策略*（*CSP*）是一个不寻常的全面安全框架，最初由 Mozilla 的 Brandon Sterne 于 2008 年提出。^([[248]) 该框架最初设想为一种全面的方法来减轻常见网络漏洞的影响，从 XSRF 到 XSS，以及作为网站所有者执行各种非安全内容管理任务的工具。

在随后的几年里，CSP 迅速发展，在几次重大事件中，其范围发生了重大变化。（例如，作者迅速放弃了处理 XSRF 漏洞的计划，将这项工作委托给了尚未实现的*Origin*头部扩展。）事实上，截至本文撰写时，Mozilla 的规范正在被重写为 W3C 草案。^([[249]) 这导致了 Firefox 中发布的实现与 Adam Barth 在 WebKit 中实现的有限支持之间存在重大差异。（Internet Explorer 和 Opera 不支持 CSP，并且没有宣布任何具体计划来采用它。）

### 主要 CSP 指令

在其核心，Sterne 的设计允许网站所有者为每个文档指定策略，以限制受主体文档执行通常在相同源策略下允许的操作的能力。例如，CSP 可能阻止页面加载任何外部子资源，除了图像，并限制图像源仅限于一组受信任的来源，如下所示：

```
X-Content-Security-Policy: default-src 'none'; img-src http://*.example.com
```

如此例所示，策略可能被编码在 HTTP 头部中。根据 W3C 草案，也可以将它们嵌入到文档本身（使用*<meta>*标签）或者在外部 URL 上托管策略并通过*policy-uri*指向它。

对于每个内容源指令，策略的作者可以指定任意数量的完全限定起源或匹配多个主机、协议或端口的通配符表达式。三个特殊关键词（*none*、*self*和*data:*）分别对应一个空集、与携带策略的页面关联的起源或所有内联*data:* URL，顺序对应。

到目前为止，以下行为可以通过 CSP 指令进行控制：

+   **脚本执行** 可以使用 *script-src* 指令来指定允许的 *<script src=...>* URL 的协议、主机和端口。通常，CSP 会禁用在文档中内嵌脚本的能力（无论是通过独立的 *<script>* 块还是通过事件处理器），以及现有的脚本不小心将字符串传递给函数，如 *eval(...)*、*setTimeout(...)*、*setInterval(...)* 等等。正因为如此，*script-src* 指令对于限制 XSS 漏洞的影响是有用的：攻击者注入的任何标记都将限制在合法托管在批准来源之一的脚本加载。^([81])

+   **插件内容** 这通过 *object-src* 控制。由于 Java 或 Flash 等插件可能对嵌入页面有不受限制的访问权限，该指令应被视为与 *script-src* 大致相似，并且两个指令必须以类似的方式限制，以实现任何安全效益。

+   **样式表和字体** 这由 *style-src* 和 *font-src* 控制。与处理脚本的方式不同，CSP 最初并没有阻止内联 *<style>* 块或 *style=* 参数出现在页面上。因此，任何利用 XSS 漏洞的攻击者都可以大幅改变受影响页面的外观和功能（或者更糟），^([82]) 这两个指令仅服务于非安全目标，可能唯一的例外是限制混合内容漏洞。就在本书出版前的一刻，规范已经被修改，以包括对 CSS 的更稳健的方法。

+   **被动多媒体** 指令如 *img-src* 或 *media-src* 控制从特定来源嵌入多媒体内容的能力。与 CSS 控制的原设计一样，这不能被认为是一个安全特性。例如，在 XSS 漏洞的情况下，CSP 不会阻止攻击者利用样式表在受影响页面上绘制任意形状，甚至在一定程度上进行动画化。

+   **子框架** *frame-src* 指令指定了在页面上遇到的任何 *<iframe>* 标签的可接受目标；框架文档不会继承父页面的策略。为了保持其他 XSS 缓解措施的价值，必须采取措施不允许 *data:* URL 出现在这里（参见第十章）。

+   **默认策略** 在 W3C 草案中被称为 *default-src*，在 Mozilla 文档中有一个更神秘的名称（*allow*），该指令指定了任何未由更具体指令覆盖的内容的回退行为。即使在技术上不必要的情况下，该指令也是必需的。

### 备注

由于 CSP 指令被选用来非常紧密地映射到单个 HTML 标签，而不是按功能相似的行为分组，这可能是令人遗憾的。因此，很难理解 *script-src*、*frame-src* 和 *object-src* 等设置之间的复杂交互。此外，这种方法在未来的安全性方面也并不很高：已经有一些边缘类别的子资源（例如“favicons”）被完全排除在 CSP 之外，而这个列表可能会无意中增长。

与迄今为止概述的子资源驱动模型不同，CSP 还包含一个名为 *frame-ancestors* 的古怪指令。此参数旨在通过以类似于已建立的 *X-Frame-Options* 标头（在第十一章第十一章。同源规则之外的生活中概述）的方式指定当前文档的允许祖先来减轻点击劫持的影响。*frame-ancestors* 逻辑与 *default-src* 或 CSP 的其他任何部分完全独立；其默认值为 “*”。

在撰写本文时，正在讨论许多其他可能的策略扩展。这包括一个 *script-nonce* 指令，可以用于更安全地嵌入内联脚本（每个脚本块都必须以策略指定的、不可预测的令牌开始，这通常使得 XSS 利用更加困难），以及一个 *sandbox* 指令，它提供了一个到另一种安全机制的替代接口，这在 沙盒框架中进行了讨论。

### 策略违规

根据这些规则指定的策略限制了底层文档的行为。违规通常会导致子资源加载失败、内联脚本执行失败或页面渲染抑制（在特殊情况下为 *frame-ancestors*）。

由于 CSP 控制了广泛的内容行为，并且默认的失败模式相当残酷，作者认为有必要减轻网站管理员的不安。为了使 CSP 更易于使用，也许还出于一种天真的尝试提供利用检测，CSP 的一个可选功能允许浏览器立即将所有策略违规报告给网站的拥有者。此功能可以通过策略中的 *report-uri* 关键字启用。为了进一步简化部署，还可能以“软”模式推出任何策略或其部分，其中违规只会导致 HTTP 通知，而不会真正破坏页面。这是通过在名为 *X-Content-Security-Policy-Report-Only* 的头中指定策略来实现的。^([83])

### 对 CSP 的批评

与浏览器世界中大多数一次性安全功能相比，CSP 是一个非常合理和一致的设计。然而，从其诞生之日起，该提案就一直在设计实现方面的持续担忧中困扰。

关于 CSP 的最常见的抱怨可能不是安全问题：为了从框架提供的 XSS 防御中受益，网站管理员必须将页面上的所有内联脚本（通常是数百个单独的代码片段）移动到一个单独请求的文档中；在 CSP 的新草案中，所有样式表也需要这样做。将现有页面改造为与 CSP 兼容的复杂性以及额外 HTTP 请求的性能惩罚往往是不可行的。（可能可以通过最近草案中提出的*script-nonce*扩展来解决这个问题。）

对于 CSP（内容安全策略）的设计，一个更根本的担忧是，目前设想的规则集的原始粒度可能不足以提供足够的防御来抵御 XSS 攻击。考虑这样一个事实：任何复杂、现实生活中的领域都可能托管数十个相互独立的 Web 应用程序，每个应用程序可能包含数百个可能无关的静态脚本和 JavaScript API。攻击者利用 CSP 保护网站中的 XSS 漏洞，被阻止直接执行恶意脚本，但他们可能通过在错误上下文或错误顺序中加载现有脚本，将应用程序置于不一致且可能危险的状态。非 Web 软件中漏洞的历史表明，这种状态破坏条件比我们想象的更容易被利用。

更令人担忧的是，攻击者可以加载一个并非真正是脚本的子资源，但可能会被误认为是脚本。一个极端的例子是支持 E4X（见第六章}*——当通过*<script src=...>*加载时，可能会导致代码执行。认识到这个问题，开发者决定要求为在 CSP 下加载的任何脚本指定白名单*Content-Type*值，但即使这种方法也往往是不够的。

为了理解可能出错的地方，考虑一个极其常见的做法，即在公共 JSONP API 中托管，客户端可以指定回调函数的名称：

```
GET /store_locator_api.cgi?zip=90210&callback=`myResultParser` HTTP/1.0
...

HTTP/1.0 200 OK
Content-Type: application/x-javascript
...
`myResultParser`({ "store_name": "Spacely Space Sprockets",
                 "street": ... });
```

在 CSP 允许的源中的任何地方，这样的 API 都可能被攻击者用来调用客户端代码中的任意现有函数，可能还伴随着攻击者控制的参数。如果*回调*字符串没有被限制为字母数字（为什么应该限制呢？），指定*callback=alert(1);//*将直接导致代码注入。

除去粒度问题，CSP（内容安全策略）有时因令人困惑且有害的缺乏关注而应受到一些温和的批评。一方面，通过包含诸如 *frame-descendants* 或 *sandbox* 这样的指令，它似乎在试探性地构建一个单一、统一的浏览器安全框架——然而却意外地将 XSRF 漏洞排除在其范围之外，而没有提供除对 *Origin* 的模糊提及之外的任何可行的替代方案。另一方面，该提案往往只希望成为一项“内容策略”，并未特别关注提供足够强大和直观的安全特性。创建危险脚本策略的简便性，加上最初对样式表和图像监管的不力，都是这一趋势的明证。

## 沙盒框架

沙盒框架是正常 *<iframe>* 行为的一种扩展。它们允许顶层页面的所有者对嵌入的文档及其任何子框架施加某些额外的限制。目标是使网络应用程序在敏感网站上嵌入可能不受信任的广告、小工具或预格式化的 HTML 文档时更加安全。该设计精炼和 WebKit（目前唯一支持该功能的引擎）中此功能的初始实现是由 Adam Barth 推动的。

### 注意

奇怪的是，沙盒框架并不是一个全新的想法：微软几乎十年前就提出了一个类似的提案。自第 6 版以来，Internet Explorer 支持一个专有的 *security=restricted* 参数，该参数强制目标框架在受限区域渲染，从而有效地移除了其执行脚本、导航到其他位置等能力。然而，似乎没有人对使用此功能做任何事情感兴趣，除了绕过某些客户端 JavaScript 安全机制（最著名的是 anticlickjacking 检查）。我们很快就会知道 HTML5 的继任者是否表现得更好。

沙盒框架的设计相当简单：任何嵌入文档的框架都可以通过在适当的 *<iframe>* 标签上指定 *sandbox* 参数来受到限制。默认情况下，受到此限制的文档将无法执行脚本和执行某些类型的导航。可以通过一个或多个空格分隔的关键字来微调权限，这些关键字作为 *sandbox* 参数本身的值指定：

+   Allow-scripts 在没有此关键字的情况下，框架内显示的文档将无法执行 JavaScript 代码。此功能的主要功能是防止嵌入的文档执行 DoS 攻击、打开浏览器对话框或使用页面上的任何其他复杂自动化。

+   允许表单（Allow-forms）当这个关键字不存在时，在嵌入文档中遇到的任何 HTML 表单将无法工作。这种机制旨在防止框架内容利用其在受信任网站上的位置来钓鱼敏感信息。（注意：如果启用了 *allow-scripts*，则 *allow-forms* 几乎没有意义。脚本可以轻松构建类似表单的控件，并自动将收集到的信息发送到另一个网站，而无需功能性的 *<form>* 标签。）

+   允许顶级导航（Allow-top-navigation）这个关键字重新启用嵌入页面导航顶级窗口的能力。这种类型的导航通常作为同源策略（见第十一章来表示仅应在沙盒框架中显示的内容。他们的理由是，浏览器通常不会识别这种 MIME 类型，并且不会将其内联显示，并且可能在*<iframe>*处理代码中创建一个特殊情况。当然，正如从第十三章中可以清楚地看到的，这种防御是不充分的，因为一些浏览器和插件会内联渲染*text/html-sandboxed*响应或以其他令人不安的方式解释返回的数据（例如，作为*crossdomain.xml*）。

由于典型浏览器中源或域级别安全机制的碎片化，合成源的概念也存在严重问题。例如，与密码管理器的危险交互是可能的，这些交互必须被明确阻止，以防止在沙盒文档中自动完成登录表单。此外，还必须在安全提示中添加特殊逻辑，例如与地理位置 API 关联的提示。

经过一些尝试和错误，目前 WebKit 中可用的实现已经针对这些问题的每一个案例解决了许多问题。然而，未来的实现很可能会反复陷入这个陷阱，特别是 HTML5 规范认为这些特性的行为超出了范围，并且没有以任何方式指定所需的行为。

### 注意

移除合成源也会带来麻烦：如果用户在沙盒广告中点击了一个同站链接，并且该链接在新窗口中打开，那么浏览器可能应该阻止新窗口中的无限制脚本通过*打开者*对象执行其父级被禁止执行的操作。

## 严格传输安全

HTTPS 设计中最显著的弱点之一是用户经常通过在地址栏中输入无协议 URL（例如[bankofamerica.com](http://bankofamerica.com)而不是[`www.bankofamerica.com`](https://www.bankofamerica.com)）开始导航，在这种情况下，浏览器将假定使用 HTTP 并以明文发送初始请求。即使网站立即将流量重定向到 HTTPS，任何活跃的攻击者都可能在受害者的网络上拦截并修改该初始响应，从而阻止用户升级到安全协议。在这种情况下，浏览器 UI 中缺少小锁图标将很容易被忽略。

这个问题以及与混合内容和 cookie 作用域相关的几个外围问题促使 Jeff Hodges 和几位其他研究人员起草了一个关于 HTTP 严格传输安全（HSTS，或简称 STS）的提案。^([[251]) 他们的方法（目前被 WebKit 和 Firefox 支持）允许任何网站在互联网上指示浏览器，所有未来针对特定主机名或域名的请求都应该始终使用 HTTPS，并且任何 HTTP 流量都应该自动升级并仅通过 HTTPS 提交。

HSTS 设计背后的推理是，用户与特定域的第一次交互不太可能发生在被积极篡改的连接上——但随着时间的推移，当用户在开放的无线网络上漫游时，遇到攻击者的可能性会迅速增加。因此，HSTS 是一种不完美的防御，但在实践中通常足够好。

HSTS 的 opt-in 头可能在 HTTPS 响应中出现，看起来可能像这样：

```
Strict-Transport-Security: max-age=3000000; includeSubDomains
```

### 注意

为了让 HSTS 提供合理的保护，*max-age*（STS 记录可以存储在浏览器中的秒数）必须设置为一个远高于通常最坏情况下的网站访问时间间隔的值。由于没有简单的方法来禁用或覆盖 HSTS，当 HTTPS 网站出现问题时，网站所有者可能会选择一个足够小的值，以最小化当他们搞砸事情并需要回滚时的干扰。不清楚这种利益冲突是否会导致网络程序员做出最佳选择。

这种设计的安全后果相当不明显：DoS 攻击的风险略有增加，因为攻击者可以将此响应头注入尚未完全启用 HTTPS 的域。还有使用 HSTS 设置的唯一组合为几个诱饵主机名标记特定浏览器实例的可能性，这为基于 cookie 的用户跟踪提供了另一种选择。然而，这些担忧并不特别突出。

不幸的是，正如本书本节讨论的其他添加限制的框架一样，机制在原则上听起来很棒，但很难完全考虑到它可能与其他遗留代码的交互。特别是，除非使用*includeSubDomains*标志，否则 HSTS 对 HTTP cookie 的保护出人意料地少：未标记为*secure*的 cookie 仍然可能通过创建一个不存在的子域并拦截发送到该目的地的 HTTP 请求而被拦截。^([[84]) （即使是*secure*的 cookie 也可能以类似的方式被破坏，只是不能读取回。） 

在类似的情况下，对来自插件内容请求的 HSTS 强制执行可能不会很好地工作。

## 隐私浏览模式

私密浏览，俗称“色情模式”，是大多数最新浏览器中的一项非标准化功能。它的目的是创建一个非持久的浏览沙盒，与主浏览器会话隔离，一旦最后一个私密浏览窗口关闭，就会完全丢弃。从某种意义上说，这种机制可以被视为在现有浏览器安全范式之上添加的一种内容隔离形式，因此现在简要提及它是合适的。

除了 Chrome 之外，大多数浏览器厂商并没有准确解释与私密浏览相关的安全保证。不幸的是，对这一术语的直观理解与浏览器实际能提供的内容大相径庭。

不可否认，对该功能的直接解释是，私密浏览会话应该是完全匿名的，并且用户的任何活动数据都不会在系统中持久化。这两个假设已经部分被现代操作系统的网络堆栈和内存管理实践所破坏。但即使在浏览器内部，实现合理的匿名性几乎是不可能的。几乎每一种有状态的浏览器机制，从地理位置或弹出权限到严格传输安全到表单自动完成，再到基于插件的持久数据存储，都必须进行修改，以便正确处理两种浏览模式之间的区别，对于每个厂商来说，实现这一目标都是一场艰难的战斗。也许更令人沮丧的是，匿名性还受到脚本通过检查系统的特征（如已安装插件的集合、字体、屏幕分辨率、窗口大小、时钟漂移，甚至非加密安全的 PRNG 的行为）来唯一标识任何给定系统的能力的影响。252]

最后，尽管表面上看起来相反，私密浏览模式仅适用于防止向同一台机器上其他非技术用户泄露数据，而且有时甚至难以实现这一目标。

* * *

^([81]) 内容安全策略（CSP）在这里提供了几种可能导致自我伤害的方法。一方面，可以通过设置如*inline-script*（Mozilla 的命名，在 W3C 草案中改为*disable-xss-protection*）或*eval-script*来重新启用脚本执行。也许不那么明显的是，还可能犯下允许*data:*或***作为允许的源或允许 HTTPS 站点上的 HTTP 源的错误。

^([82]) 还记得 CSS3 中的高级选择器吗？通过巧妙地在注入样式中利用它们，可以方便地将页面中出现的字符串信息传递给第三方服务器，而无需使用 JavaScript。

^([83]) 作为旁注，这个特性不仅对短期实验有用，而且可以持续检测非关键问题。例如，网站所有者可以利用它通过为将被任何 HTTP 脚本违反的 HTTPS 页面创建仅报告策略来检测混合内容问题。

^([84]) 从第九章回顾，我们知道在某些浏览器中创建主机作用域的 cookie 相当棘手，而在 Internet Explorer 中则完全不可能拥有。

# 其他发展

本章之前讨论的安全功能旨在改变 Web 应用程序之间的边界，以及网站之间交互的方式。另一组提出的机制虽然不属于简单的分类，但仍然重要或足够成熟，值得在此简要提及。我们现在将回顾其中的一些。

## 浏览器内 HTML 清理器

XSS 漏洞是现代 Web 应用程序中遇到的最常见的安全问题。因此，如此少的提议安全框架旨在全面解决这个问题，这确实令人惊讶。诚然，CSP 是一个强有力的竞争者，但它要求对 Web 应用程序的编写方式进行根本性的改变，并且不能特别逐步或选择性地部署。另一方面，沙盒框架可能过于资源密集且使用不便，不适合显示数百个用户提供的短片段数据的最常见任务。

可能解决许多 XSS 问题的最佳方法之一是让 Web 框架提供解析的、无歧义的、二进制 DOM 树给浏览器。这样的解决方案将消除与模板转义和 HTML 清理相关的大多数问题。一个更实际的选择可能是为 Web 开发者提供一种强大的工具，以标记攻击者提供的字符串的边界，并限制嵌入有效负载的行为或外观，而无需对其进行转义或清理。可以想象这样的语法：

```
<sandbox token="random_value12345" settings="allow_static_html">
   ...any unsanitized text or HTML...
</sandbox token="random_value12345">
```

如果使用这样的工具，攻击者将无法逃出这样的沙盒，除非猜出随机生成的*令牌*边界的正确值，否则无法移除对脚本的限制。

可惜，这样的提议不太可能成为 HTML5 的一部分，也不会在任何浏览器中发布，因为这种序列化在本质上与 XML 不兼容，而修改 XML 本身以允许 HTML 中的隐蔽用例是一项难以实现的行动。令人沮丧的是，XML 已经提供了一种类似的方法，可以在*<![CDATA[...]]>*块内封装任意数据，但如果没有基于令牌的防护，这个沙盒在利用 XSS 时可以轻易逃逸。

相反，限制客户端脚本生成的任何 HTML 的权限要容易得多。从 Internet Explorer 8 开始，微软提供了一个简单但相对不灵活的 *toStaticHTML(...)* API，^([253]) 它承诺从传递给它的任何完全限定的 HTML 片段中移除 JavaScript。此方法输出的设计是为了安全地分配给现有 DOM 中的 *innerHTML* 属性.^([85])

微软的提议是可行的，但它回避了最常见且问题最多的任务，即安全地显示服务器提供的文档。而且它的 API 有一个微小但完全不必要的弱点：在调用 *toStaticHTML(...)* 后但在 *innerHTML* 赋值之前修剪或连接清理后的输出是出乎意料的危险，许多网络开发者可能会尝试这种做法。一个更合理的做法是在将内容清理仅限于赋值给 *innerHTML*。实际上，WebKit 工程师曾短暂讨论过这样一个 API 的提议（也称为 *innerStaticHTML* 或 *safeInnerHTML*），但这项努力似乎早已无疾而终。

## XSS 过滤

减少跨站漏洞的发生率是困难的，限制其影响也同样困难。正因为如此，一些研究人员得出结论，检测和阻止此类漏洞的利用可能是一个更好的选择。因此，大约在 2008 年，微软的 David Ross 宣布将在即将发布的 Internet Explorer 8 中包含 XSS 检测逻辑；^([254]) 几个月后，Adam Barth 在 WebKit 中实现了类似的功能。这些实现将当前 URL 的部分与检索到的页面上的任何字符串或传递给诸如 *document.write(...)* 和 *innerHTML* 等 API 的字符串进行比较。如果比较发现页面上可能存在的 JavaScript 部分可能源自未正确转义的 URL 参数，则页面的相关部分可能被替换为无害的字符串。

可惜，这个看似优雅的想法已知会导致严重问题。除了偶然的误报（Internet Explorer 8 的用户在访问*http://www.google.com/search?q=<script>*时可能会遇到意外麻烦）之外，过滤器还可能被恶意目的触发，通过在 URL 中附加页面的合法部分作为非功能参数。在一个极端且现已解决的案例中，这种行为被用来创建之前不存在的前端跨站脚本（XSS）攻击向量，仅仅是通过欺骗浏览器随意重新排列标记。^([255]) 但更基本的是，对于任何复杂的 Web 应用来说，选择性地禁用攻击者选择的脚本块都是风险很大的，即使页面的结构在其他方面是正确的，这样的调整也可能轻易地将客户端代码置于不一致或危险的状态。例如，考虑一个在线文档编辑器，它将以下每个功能都实现在一个单独的*<script>*块中：

1.  初始化编辑器的内部状态，并使用空起始文档创建用户界面。

1.  通过 URL 参数加载用户请求的文档当前版本，并进行错误检查以捕获任何潜在的网络问题。

1.  如果没有检测到错误，则进入交互式编辑模式，并自动将文档的当前状态每 30 秒保存一次，保存的 ID 基于 URL。

在这个并非完全不合理的设计中，移除第二步的能力可能会带来灾难性的后果，因为下一步可能会用空白副本覆盖现有的、服务器存储的文档。哎呀。

通过使用更简单的方案可以避免这个问题，即任何疑似 XSS 攻击都会导致浏览器简单地拒绝渲染文档。遗憾的是，相对较高的误报率阻止了作者采取这条路线。经过一番辩论后，微软决定提供基于选择的“严格”阻止模式，可以通过如下响应头切换：

```
XSS-Protection: 1; mode=block
```

### 注意

除了误报的风险之外，XSS 过滤器还容易产生误报，这种情况可能无法通过多少来改善。按照设计，这些过滤器永远无法检测到更危险的可存储 XSS 漏洞，即错误转义的数据来自除跟随链接之外的其他来源。但即便如此，众多（通常是隐式的）输入转义方案和*location.hash*或*pushState*（第十七章：相当安全，但容易误用。避免非简单请求，不允许任意头或方法。如果你控制服务器端应用程序框架，考虑自动从带有非白名单*Origin*值的传入 CORS 请求中删除*Cookie*头，以最大限度地减少意外共享用户特定数据的风险。为了最大限度地减少混合内容错误的发病率，考虑在通过纯 HTTP 接收到的任何请求上拒绝 HTTPS *Origin*值。

    谨慎对待*Access-Control-Allow-Origin: **，如果你需要使用它，请确保它只返回你打算共享的位置。

+   XDomainRequest：这可以安全使用。与*XMLHttpRequest*一样，限制从 HTTPS 源访问 HTTP API 可能是消除混合内容错误的好方法。

+   **内容安全策略（Content Security Policy）：** 这可以作为深度防御的一种安全措施使用。审查与*script-src*、*object-src*等之间的交互相关的注意事项，以及允许*data:*源的危险性。不要意外地允许混合内容：始终在规则集中指定协议，并确保它们与请求页面上提供的协议相匹配。

+   **沙盒框架（Sandboxed frames）：** 这可以作为从其他源嵌入小工具的安全方式使用，但在不合规的浏览器中，该机制将失败得很严重。你不应该对同源文档进行沙盒化。

+   **严格传输安全（Strict Transport Security）：** 这可以作为深度防御的一种安全措施使用。请确保将所有相关 cookie 标记为*secure*，并准备好应对通过伪造、非 STS 位置在您的域中注入 cookie 的可能性。在可行的情况下使用*includeSubDomains*来减轻这一风险。

+   toStaticHTML(...): 在可用的情况下可以安全使用，但在不合规的浏览器客户端替换它很困难。由于过滤器的设计，绕过漏洞在 API 中有较高的复发概率。

+   **私密浏览（Private browsing）：** 不要依赖此机制进行安全目的。

+   **跨站脚本过滤（XSS filtering）：** 不要依赖此机制进行安全目的。始终在 HTTP 响应中显式指定*XSS-Protection: 1; mode=block*或*XSS-Protection: 0*。默认设置相当不安全。

* * *

^([85]) 有趣的是，Internet Explorer 中的 HTML 解析器似乎非常愚钝，以至于甚至*toStaticHTML(...)*的作者也有些难以理解它。自从其引入以来，该 API 就遭受了相当多的绕过漏洞，其中大多数与处理 CSS 数据有关。

# 第十七章。其他值得注意的浏览器机制

为了总结本书的第三部分，我们简要列举了一些最近实施或计划实施的 API，尽管它们并非专为安全目的设计，但可能会在未来的几年内显著改变安全格局。例如，一些 API 改变了 Web 应用程序可以访问的数据类型，或者改变了浏览器与外部世界的通信方式。

以下列表必然是不完整的：每周都会起草新的、合理可信的设计，而旧的方法则可能在实际浏览器发货之前被废弃。尽管如此，本章应该可以作为对未来可能带来什么的有趣快照。

# URL 和协议级别的提案

这些功能旨在改变围绕链接行为、地址栏以及通过网络交换数据的过程。

**协议注册**

Web 应用程序通常假定处理之前为“真实”桌面软件保留的 URL 方案。一个典型的例子可能是*mailto:*协议，它最初旨在实例化一个独立的邮件应用程序，但如今通常更合理地被路由到网络邮件界面。为此，Mozilla 提出了，WebKit 接受了简单的*navigator.registerProtocolHandler(...)* API。²⁵⁶] 当调用此 API 时，用户会看到一个简单的安全提示，如果操作得到批准，则将基于 URL 的处理程序与特定的方案关联。截至今天，相关的提示容易受到第十四章中概述的竞争条件的影响，并且它们在其他方面似乎也缺乏，如图 17-1 所示。

![Firefox 中的一个严重令人困惑的提示。浏览器窗口上方的提示是由浏览器在调用 registerProtocolHandler(...) API 时生成的，协议名称设置为“做真正酷炫的事情”，应用程序名称设置为“Firefox (mozilla.org)”。这个特定的例子是无害的，但更危险的滥用手段就在眼前。](img/httpatomoreillycomsourcenostarchimages950045.png.jpg)

图 17-1. Firefox 中的一个严重令人困惑的提示。浏览器窗口上方的提示是由浏览器在调用*registerProtocolHandler(...)* API 时生成的，协议名称设置为“做真正酷炫的事情”，应用程序名称设置为“Firefox (mozilla.org)”。这个特定的例子是无害的，但更危险的滥用手段就在眼前。

**地址栏操作**

新引入的 HTML5 *history.pushState(...)* API，^([257]) 由 Firefox、WebKit 和 Opera 支持，允许当前显示的文档更改地址栏的内容为任何其他同源 URL，而不会实际触发通常与此步骤相关的页面转换。该 API 提供了比广泛滥用的 *location.hash* 存储应用程序状态的替代方案。有趣的是，尽管它很简单，但它已经导致了相当数量的有趣的安全漏洞。例如，一些实现不仅允许顶级文档更改地址栏中显示的顶级 URL，还允许任何可疑的第三方框架更改地址栏中的顶级 URL，并且它们允许诸如 *about:blank* 这样的源将大量不受约束的乱码放入 URL 字段。

**二进制 HTTP**

SPDY^([258]) （“快速”）是一个简单的加密 HTTP 替代品，它保留了协议的关键设计原则（包括大多数头部的布局和功能）。同时，它最小化了与处理并发请求或解析基于文本的请求和响应数据相关的开销。该协议目前仅在 Chrome 中得到支持，除了选定的 Google 服务外，在网络上并不常见。然而，它也可能很快就会出现在 Firefox 中。

**无 HTTP 网络**

WebSocket^([259]) 是一个仍在发展的 API，旨在协商大量不受约束的双向 TCP 流，用于 TCP 的事务性特性阻碍时（例如，在低延迟聊天应用的情况下）。该协议通过一个带密钥的挑战-响应握手来启动，看起来有点像 HTTP，并且（非常令人惊讶地）仅通过利用目标网站的头部分割漏洞是不可能伪造的。在握手成功后，可以在结果的长连接中双向交换原始数据，每条消息都封装在一个简单的协议帧中。该机制在 WebKit 中得到支持，并且可能很快就会出现在 Firefox 中。

**P2P 网络**

WebRTC^([260]) 是一组提议的 API 和网络协议，旨在无需集中式服务器基础设施即可促进与其他浏览器的发现和通信。此类协议的主要用例是在 Web 应用中实现 IP 电话和视频会议功能。目前还没有稳定的浏览器支持。

**离线应用**

缓存清单^([261]) 是一种相对简单的方法，允许 Web 服务器指示浏览器，某些文档的副本应无限期存储并重复使用，只要客户端似乎没有网络连接。结合客户端存储机制，如*localStorage* (第九章)，这允许某些自给自足的 JavaScript 应用程序在离线模式下使用。Firefox、WebKit 浏览器和 Opera 支持离线操作。与*localStorage*一样，这种机制的持久性可能会加剧访问不受信任网络的长远后果。

**更好的 cookies**

*Cake*^([262]) 是由 Adam Barth 起草的一个现已失效的提议，旨在创建一个比 HTTP cookies 更轻量级、更安全的替代品：为每个目标网站生成一个与源绑定、浏览器生成的 nonce。一个更现代但尚不完整的提议似乎在正常但基于源的 cookies 作为替代品之间摇摆。这两种方法目前在任何浏览器中都不可用。

# 内容级功能

本节概述的提议旨在使新的 Web 应用程序类别能够在 HTML 和 JavaScript 之上构建。

**客户端数据库**

几年来，已经提出了多个用于创建和操作本地存储数据库的 API，包括臭名昭著的*WebSQL* API，^([263])它本可以将著名的危险 SQL 语法带到客户端 JavaScript 中。WebSQL 提议被放弃，转而采用更合理的*IndexedDB*设计，^([264])它提供了一个干净的 API，没有序列化查询，并且具有与*localStorage*相当的安全模型——但这是在 WebSQL 支持在几个浏览器中发布之后。与此同时，新的 API 已经发布在 Chrome 中，并预计将在 Firefox 中出现。

**后台进程**

在 Firefox、WebKit 和 Opera 中可用的*Worker* API，^([265]) 允许创建后台 JavaScript 进程来执行计算密集型任务，而无需担心阻塞浏览器 UI。每个 worker 都在一个隔离的环境中运行，缺少通常的*window*或*document* DOM，并且可以通过*postMessage(...)* API 异步与其创建者通信。*专用 worker*只能由其创建者直接访问，而*共享 worker*可以在任何给定时间“附加”到几个不同的网站。(*持久 worker*，即独立于对其服务的持续需求运行的 worker，最初被提出，但后来被放弃。)Worker 线程的概念引发了一些外围的 DoS 担忧，但否则没有明显的安全风险。

**地理位置发现**

The *navigator.geolocation.getCurrentPosition(...)* API^([266]) 允许任何网站在用户（很大程度上可被劫持）同意的情况下请求有关客户端设备物理位置的信息。计算出的地理位置数据可能来自具有合适硬件模块的系统的 GPS 信息，或者根据附近的无线接入点、蜂窝基站等名称进行查询。该 API 在所有主要浏览器中都有支持，除了 Internet Explorer。

**设备方向**

一个非限制性的事件驱动 *DeviceOrientation* API^([267]) 允许网站根据加速度计数据读取设备的方向。这个 API 可能针对移动游戏，在配备了适当硬件的系统上的 Firefox、WebKit 和 Opera 中可用。加州大学戴维斯分校的两名研究人员最近演示了一个致命缺陷：在智能手机上，设备的微小移动可能被用来可靠地重建屏幕上的键盘输入，包括在无关网站上输入的密码^([268]）。

**页面预渲染**

Chrome 中的这个实验性功能允许在用户点击特定链接之前预先获取页面，并允许整个 HTML 文档在一个隐藏的标签页中预先渲染^([269])，一旦预测的导航操作发生，就暂时显示出来。如果预先渲染的页面被证明是恶意的话，这个机制会有一些有趣的浏览器安全后果。Chrome 的实现非常小心，直到标签页被揭示才推迟任何破坏性行为，但跨所有浏览器代码库犯错误将非常容易。

**导航时间**

几个互补的 API，目前仅在 Chrome 中可用，允许某些类型的导航，包括跨域页面加载，能够从客户端 JavaScript 进行非常精确的基准测试^([270])。该接口旨在允许网站所有者识别典型访客所经历的性能瓶颈。API 允许通过分析加载某些第三方内容所需的时间来收集一些与隐私相关的信息，但由于同样的攻击可以通过许多其他方式（例如，在子资源上的 *onload* 处理器）进行，这可能并不重要。

# I/O 接口

下面列出的功能为基于 Web 的脚本提供了新的输入和输出能力。

**用户界面通知**

*通知* 和 *window.notifications*^([271]) API 允许在屏幕角落创建仅文本或基于 HTML 的始终显示在顶部的弹出窗口，允许选定的 Web 应用程序温和地通知用户重要事件（如新邮件消息）。用户需要在每个网站上单独同意接收通知，这限制了滥用的风险。尽管如此，仍需注意正确传达微小通知窗口及其随后创建的任何对话框或提示的来源，这一方面花费了一些时间才得以完善。目前该 API 仅在 WebKit 中可用。

**全屏模式**

已有多个提案流传开来，允许 JavaScript 最大化当前浏览器窗口并隐藏所有浏览器界面。这一功能对于查看演示或观看电影等任务至关重要，但从安全角度来看显然非常危险：一旦控制了整个屏幕，任何恶意页面都可能绘制一个带有虚假地址栏的虚假浏览器窗口。到目前为止，似乎还没有具体的实现可供审查。关于鼠标光标锁定的一个早期提案也在讨论中。

**媒体捕获**

提出了一套名为 *navigator.device.capture* 的 API 套件^([272])，旨在让网站能够访问摄像头和麦克风数据。围绕这一机制，尤其是在处理与竞态条件攻击相关的安全提示的弹性方面，引发了明显的安全和隐私担忧。目前该 API 没有稳定的浏览器支持。
