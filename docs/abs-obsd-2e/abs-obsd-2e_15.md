## 第十五章 系统维护

*当硬件抱怨时，*

*OpenBSD 倾听。*

*你也应该倾听。*

![图片](http://atomoreilly.com/source/nostarch/images/1616079.png) 没有电脑会自己运行。如果它会，你就不需要这份工作了。即使是配置最好的服务器也会产生持续的维护需求。

OpenBSD 包括各种工具，使维护更容易，在需要维护时提醒你，并告诉你系统的状态。每天、每周和每月，OpenBSD 都会执行维护任务，并通知你结果。OpenBSD 会对关键系统功能和文件进行每日备份，并使用它们来监控系统完整性。它可以管理自己的日志文件，保持自己的时间，并在硬件出现故障时提醒你。

所有这些都始于定期维护。

## 计划任务

OpenBSD 包括每天、每周和每月运行的计划任务。这些任务以 root 身份运行，并将结果发送给 root。每日维护脚本是最复杂的；每月脚本是最简单的。

如果服务器运行良好，我可能几周甚至几个月都不会登录到它。事实上，我有一些服务器已经运行了一年多，没有人登录过。我阅读机器的每日报告，说“是的，没问题”，然后继续我的日常生活，自信监控系统会告诉我那些常规状态报告没有告诉我的事情。

定期维护任务会将结果发送到本地 root 用户，但如果没有人登录到机器，就没有人会看到这些结果。始终在*/etc/aliases*中为 root 设置一个电子邮件别名，这样这些消息就会发送给会实际阅读它们的人。

每天阅读每台机器的每封电子邮件都很烦人，但比发现用户告诉我服务有问题时更不烦人。这些消息通常在任何人（包括我）注意到之前就会提醒我系统问题。拥有数百台机器的站点通常会编写脚本来解析传入的电子邮件消息并标记有趣的细节。

你应该将维护电子邮件发送给最终负责系统的人——无论谁最感兴趣系统变化，最有可能意识到任何日常系统变化。如果你将阅读维护电子邮件的任务委托给对系统不太了解的下属，他可能会用关于你昨天做了什么的无尽问题来烦扰你，或者学会忽略状态邮件中的任何实际内容。

在这里，我们将看看每日、每周和每月例程是如何工作的。维护任务的完整文档出现在`daily(8)`中。

### 每日维护

每日维护任务首先从*/etc/daily.local*运行任何自定义维护任务（在本节末尾介绍），包括检查分区、运行提醒服务`calendar(1)`、运行`rdist(1)`、删除临时文件，以及其他一些无聊的事情。

OpenBSD 还可以在其日常维护中执行一些其他有趣的事情：

+   创建备份根文件系统，*/altroot*。

+   执行系统安全检查。

+   在 */var/backup* 中备份重要的系统文件。

+   检查重要系统文件的变化。

+   检查文件系统完整性。

+   运行 `rdist(1)`。

我在 第九章 中讨论了 */altroot*，因为它需要一个专用的文件系统分区。其他每个任务都可以稍后配置。

#### 安全检查

一些出错的情况并不一定意味着你的系统已经遭受了入侵，但仍然令人怀疑。日常安全检查会寻找一系列由恶意或疏忽引起的配置错误和问题。你可以在 `security(8)` 中阅读检查列表，但它们可以分为相当广泛的类别：

> 设备节点变更和权限
> 
> 新的设备节点、设备节点权限变更、新的软件包、以及新的或变更过的磁盘或分区可能表明恶意活动，也可能只是正常的系统管理。安全脚本会标记所有这些情况。如果你进行了这些变更，你会点头然后继续你的日常。如果你要求一个从属进程执行变更但变更没有出现，这时你应该问他们昨天整天都做了什么。如果你没有进行显示的变更，你希望了解这些情况。
> 
> 不安全的 NFS 导出
> 
> OpenBSD 包含了许多用于导出文件系统和远程运行命令的软件。这些服务，如打印和 NFS，不应允许来自任何主机的访问，而只应允许来自你批准的主机。安全任务会检查允许全局访问的配置。
> 
> 配置不当的账户
> 
> 另一个流行的攻击途径是密码数据库和相关文件。无密码的账户、重复条目、不当关闭的账户等问题都可能被用来危害系统。脚本会检查这些问题。
> 
> 权限
> 
> 权限设置不当可能导致权限提升。例如，系统上是否有新的 `setuid` 或 `setgid` 文件？如果有，安全脚本会通知你。如果你用这些权限安装了该文件，那么你没问题。如果这是意外的，你应该进行调查。
> 
> 用户环境
> 
> 如果你能够更改一个用户的环境，无论是 root 还是其他账户，你都可以诱使他们泄露他们的认证凭证或运行可疑命令。如果入侵者可以编辑用户的点文件，如 *.cshrc* 或 *.login*，他可以更改他运行的命令版本。也许他的 shell 被设置为运行一个要求用户输入密码并发送给入侵者匿名电子邮件账户的程序。通过正确设置家目录、点文件、邮件文件等的权限，你可以使这类攻击更困难。安全脚本会验证权限是否设置正确。

注意，安全检查**不是**一个入侵检测系统。它检查的更改类型是脚本小子和新手入侵者最有可能做出的，但熟悉 OpenBSD 的熟练入侵者可能会绕过它。他们甚至可以用一个 shell 脚本替换安全检查，该脚本每天发送一封看似无害的安全检查的电子邮件。

幸运的是，有能力的入侵者相对较少。只需记住，收到没有提及问题的安全检查是令人鼓舞的，但这并不是你的服务器安全的证据。

#### 重要文件备份和测试

每日安全检查会检查 */etc/changelist* 中列出的文件的变化，并轮换它们的备份，因为这些文件通常是关键系统文件，如 */etc/master.passwd*、*/etc/boot.conf* 和 */var/cron/tabs/root*。它还会检查磁盘分区和挂载文件系统的变化，以及设备节点的变化。

查看*/var/backups*，你会看到如下文件：

```
…
etc_fstab.backup
etc_fstab.current
etc_ftpchroot.current
etc_ftpusers.current
…
```

以*.current*结尾的文件是当每日维护任务上次运行时这些文件的副本。以*.backup*结尾的文件是这些文件的上一版本。

安全脚本第一次运行时，会将所有这些文件复制到 */var/backup*。在初始设置之后，安全脚本会检查原始文件与当前副本之间的变化。如果文件发生变化，则将文件的上一版本复制到*.backup*文件名，并将新版本复制到*.current*文件。

在前面的例子中，列表显示我在某个时间编辑了我的 */etc/fstab*，这促使安全脚本将其旧文件系统表的副本移动到*.backup*文件。我从未编辑过 */etc/ftpchroot* 或 */etc/ftpusers*，因此这些文件没有*.backup*版本，只有*.current*版本。

安全脚本不会复制它所监视的所有文件。例如，包含私钥或可能包含私钥的文件不会被复制，但安全脚本会计算校验和。（使用校验和监控的文件在 */etc/changelist* 中的名称前有一个加号。）手动编辑 */etc/ssh/ssh_host_ecdsa_key* 没有理由，如果文件发生变化，要么你知道原因，要么你需要从受信任的备份中恢复。

*/etc/changelist* 本身也被列在 */etc/changelist* 中。这看起来是递归的，但系统会备份你想要备份的文件列表，并在有人向 */etc/changelist* 中添加或删除文件时通知你。

#### 添加重要文件

你可以向更改列表中添加文件，甚至可以使用通配符来备份目录中的所有文件。但请注意，如果你在 */etc/changelist* 中使用了通配符，当文件被删除时，你不会收到通知。

考虑这个使用通配符的例子。在 第十三章 中，我将 `apache2` 端口添加到我的机器之一。我将配置文件放在 */etc/apache2* 中。我可以在更改列表中添加这样的行：

```
/etc/apache2/*
```

这将自动将 *apache2* 配置目录中的所有文件复制到 */var/backup* 并检查它们是否有变化。然而，当文件从这个目录中删除时，我不会收到通知。如果你使用的是一种配置机制，它说，“包含此类目录中的所有 *.conf* 文件”，这可能不是你想要的。更好的选择是逐个列出每个文件，并在添加关键文件时更新列表。

文件完整性检查最方便的一点是它会自动创建关键系统文件的本地备份。这意味着如果你决定学习如何使用 `vipw(8)` 并在这样做时彻底破坏用户数据库，你可以从 */var/backups* 中抓取昨天的副本，安装它，而且没有人会察觉。这同样适用于每个其他关键系统文件。

#### 文件系统完整性检查

当系统处于多用户模式时，你不能运行完整的 Unix 文件系统 (UFS) 检查，但你可以让 `fsck(8)` 执行文件系统完整性检查，以尝试在问题变得严重之前识别它们。这样做不会修复任何问题，但它会通知你它们的存在，这样你就可以安排停机时间进行维修。

要启用这些检查，请在 */etc/daily.local* 中将 `CHECKFILESYSTEMS` 设置为 `1`。

#### 使用 rdist 复制文件

`rdist(1)` 程序用于将文件复制到其他服务器，让你在许多服务器上维护关键文件的相同副本。如果你有兴趣使用它，请参阅 `rdistd(8)`。

#### 静音 /etc/daily

我们中的一些人拥有监控系统，可以跟踪服务器的磁盘、网络和其他基本信息。如果你不需要这种信息出现在你的日常状态邮件中，请在 */etc/daily.local* 中将 `VERBOSESTATUS` 设置为 `0`。这将关闭日常维护的这些部分，减少你需要阅读的内容。

如果剩余的每日维护没有生成任何输出，服务器当天不应发送状态电子邮件。在不信任监控系统的环境中，你可以使用每日状态消息来确保系统按预期运行。OpenBSD 给你选择。

### 周维护

每周脚本比每日脚本简单，只有三个常用功能：

+   首先，它运行自定义的每周脚本 */etc/weekly.local*。

+   其次，它更新了 `locate(1)` 数据库。

+   最后，它重建了 `whatis(1)` 手册页数据库。

### 月维护

OpenBSD 不需要任何通用的月维护，但为了保持一致性，*/etc/monthly* 脚本运行自定义脚本 */etc/monthly.local*。

### 自定义维护脚本

每个维护脚本在执行其他任务之前都会运行一个自定义脚本。你可以将任何需要的任务放在*/etc/daily.local*、*/etc/weekly.local*和*/etc/monthly.local*中。这些命令由 root 运行，因此不要将它们用于应由其他用户执行的任务。如果你的数据库需要备份，创建一个单独的脚本，并让运行数据库的非特权用户通过`cron(8)`运行该脚本。

一些网站使用计划中的维护任务来运行执行特定任务的复杂软件。例如，我知道有一家安全公司从数百台机器收集数据，并使用每日任务将数据发送到中央管理系统。实际上，你可以根据需要以任何方式使用本地脚本。

如果你有一个可以在其他用户账户下运行的维护任务，但你想将其附加到计划中的维护任务，你可以让本地脚本调用另一个脚本。通过使用`su(1)`切换用户并降低权限来启动该脚本。

自定义维护脚本可能最有用，可以改变标准维护脚本执行工作的方式。例如，假设你有一个包含临时文件的许多临时目录的系统。每周维护脚本更新 locate 数据库，但你不想这些临时文件包含在 locate 结果中。你可以在*/etc/weekly*创建新的 locate 数据库之前立即使用自定义维护脚本删除所有临时文件，并将此作为单独的任务进行安排。通过将其添加到*/etc/weekly.local*，你就会知道它将在*/etc/weekly*运行其他任务之前完成。

## 系统日志

Unix-like 操作系统使用的系统日志已成为日志记录的行业标准，但这并不一定是好事，因为日志机制可能会很麻烦。然而，一旦你正确配置了日志收集和轮换，OpenBSD 的日志系统大部分可以自行管理。

OpenBSD 使用 Unix-like（以及许多嵌入式）系统的标准日志系统`syslog(3)`。syslog 协议使用设施和优先级标记消息，并将这些消息交给守护进程。

任何程序都可以写入本地的`syslogd(8)`服务器，但在日志管理中关键是要决定如何对这些消息进行排序和存储。OpenBSD 的`syslogd`可以根据设施、优先级和源程序对消息进行排序。

### 设施

*设施*表示消息的来源。在大多数情况下，每个需要单独日志文件的程序都使用不同的设施。许多程序或协议，如 FTP，都有专门为它们设置的设施。syslog 协议也有各种通用的设施，你可以按需使用。

表 15-1 列出了标准设施并提供了一些关于它们使用的说明。

表 15-1. 表 15-1：标准 OpenBSD 设施

| 设施 | 用途 |
| --- | --- |
| `auth` | 关于身份验证的公共信息，例如某人登录或某人使用 `su` 时的情况。 |
| `authpriv` | 关于用户身份验证的私人信息，通常只有特权用户可以访问。 |
| `cron` | 来自系统调度程序 `cron(8)` 的消息。 |
| `daemon` | 对于既不需要也不需要专用设施的进程的捕获。 |
| `ftp` | 来自 FTP 和简单文件传输协议 (TFTP) 服务器的消息。 |
| `kern` | 内核生成的消息。 |
| `local0` 通过 `local7` | 这些设施是为系统管理员提供的。许多程序允许系统管理员配置它们的设施。对于此类程序，请使用这八个设施。 |
| `lpr` | 来自打印系统的消息。 |
| `mail` | 来自邮件服务器的消息。 |
| `mark` | 这个特殊设施每 20 分钟写入一条消息。 |
| `news` | 来自 Usenet 新闻服务器的消息。 |
| `syslog` | 来自 syslog 服务器的消息。 |
| `user` | 捕获所有消息的设施。如果用户空间程序没有指定日志设施，消息将最终在这里。 |
| `uucp` | 来自 Unix 到 Unix 复制协议 (UUCP) 服务器的消息。你可能会永远遇到这种互联网之前的电子邮件协议。 |

虽然大多数程序都有合理的默认设置，但作为系统管理员，你的工作是管理哪些程序将日志记录到哪些设施。如果可能，请为你的服务器特定守护进程使用本地设施。虽然完全有可能将设施用于原本的目的之外，但除非你真的没有其他选择，否则尽量不要将 `uucp` 设施重新分配给其他守护进程。

### 优先级

日志消息的优先级表示其重要性。程序通常将它们的日志数据发送到 `syslogd`，但 `syslogd` 决定保留什么和丢弃什么。你可以决定你日志中需要多少细节。使用以下九个 `syslog` 级别来决定记录什么和丢弃什么（从最重要到最不重要）：

+   ****`emerg`****. 系统紧急情况。此消息出现在每个活动终端上。计算机可能正在崩溃，或者可能有一些其他需要立即注意的错误。

+   ****`alert`****. 紧急情况。系统可以继续运行，但必须尽快处理此错误。

+   ****`critical`****. 严重问题。这表明严重的错误，例如硬盘故障。

+   ****`err`****. 错误。这些是关于需要关注但不会破坏你的系统的问题。

+   ****`warning`****. 各种警告。这些可能需要关注，但不会阻止生成它们的进程正常运行。

+   ****`notice`****. 重要信息，例如守护进程启动和关闭通知。

+   ****`info`****. 基本信息通常包括事务数据，例如邮件服务器中的单个消息或对 Web 服务器的单个查询。

+   ****`debug`****. 知识点。这个级别通常只对程序员感兴趣，但偶尔对试图弄清楚程序为何以某种方式运行的系统管理员有用。调试日志可以包含任何内容，包括违反用户隐私的信息，例如明文密码。

+   ****`none`****. 不要记录此设施中的任何内容。这最常用于排除日志文件中的信息，如稍后所述。

通过结合优先级，你可以将日志消息分类到单独的文件或其他目标中。

### 通过 syslogd(8)排序消息

`syslogd`将接收到的消息与*/etc/syslog.conf*中的条目进行比较。此文件有两列：第一列（*选择器*）描述了一种日志消息类型，第二列（*操作*）告诉`syslogd`当消息与描述匹配时该做什么。两列都不能有空格；空格只能出现在列之间。例如，以下是从默认的*syslog.conf*中的一行：

```
daemon.info            /var/log/daemon
```

任何具有守护进程设施和`info`或更高优先级的日志消息都将附加到文件*/var/log/daemon*。当然，如果所有日志都如此容易管理，这将是一个简短的章节。

`syslogd`将所有日志消息与所有*syslog.conf*条目进行比较。如果日志消息与多个选择器匹配，它将被发送到所有匹配的目的地。

#### 通配符

你可以在设施或优先级中使用通配符。例如，此行记录来自邮件设施的所有消息：

```
mail.*            /var/log/maillog
```

要从所有设施中捕获给定优先级或更高优先级的消息，请使用星号（`*`）。以下是如何将所有优先级`err`或更高消息发送到控制台的方法：

```
*.err    /dev/console
```

你还可以使用双通配符将所有日志消息发送到同一个地方。

```
*.*    /var/log/all.log
```

不要将所有内容记录到同一个位置，这既不实用也不明智。你不应该将`authpriv`调试信息发送到任何世界可读的文件。

#### 排除信息

使用`none`级别排除日志中的信息。例如，以下行排除了其他情况下包含的所有私人认证信息。

```
*.*;authpriv.none    /var/log/most.log
```

分号（`;`）允许你在单行上组合选择标准。

### 警告

如果你像这样使用分号组合条目，不要在分号后留空格。唯一的空格只能出现在选择器和目的地之间。

#### 组合设施

你可以使用逗号在单个条目中组合多个设施。以下是如何从多个设施中捕获所有`info`优先级或更高消息的方法：

```
auth,daemon,syslog,user.info    @loghost
```

来自`auth`、`daemon`、`syslog`和`user`设施，以及优先级`info`或更高的任何日志消息，都将通过网络发送到主机`loghost`。

#### 标记时间

虽然所有日志消息都有时间戳，但你可能想在日志文件中有一个标记来指示时间的流逝。特殊的`mark`设施每 20 分钟创建一条消息，让你可以向文件添加额外的时间戳。以下是如何每 20 分钟向邮件日志添加一个时间戳的方法：

```
mail.info;mark.info    /var/log/maillog
```

#### 本地设施

八个设施`local0`到`local7`可供你使用。许多程序可以配置为使用特定设施，因此你可以将它们指向特定的文件。我已经配置了一个守护进程使用设施`local7`。在这里，我将来自该设施的消息发送到文件：

```
local7.*    /var/log/postgres.log
```

一些程序对特定设施有硬编码的偏好。例如，flow-tools 软件包（见我的书《网络流量分析》，No Starch Press，2010 年）将设施`local6`硬编码到代码中。当你看到类似的情况时，不要感到惊讶。幸运的是，OpenBSD 的`syslogd`可以根据程序名称进行过滤，因此你可以轻松地过滤日志，尽管这种做法有些愚蠢。

#### 按程序名称选择

如果你没有设施，你可以使用生成 syslog 消息的程序名称作为选择器。使用程序名称需要两行：第一行包含带有前导感叹号的程序名称，第二行设置日志记录。OpenBSD 提供了以下`sudo(8)`日志记录的示例：

```
!sudo
*.*    /var/log/sudo
```

所有来自`sudo`的日志消息都发送到指定的日志文件。

你也可以通过程序名称进行选择，并在程序名称前使用两个感叹号（`!!`）来停止所有后续匹配消息的选择。以下示例将所有来自`sudo`的消息发送到*/var/log/sudo*，但防止`sudo`消息发送到任何其他日志。

```
!!sudo
   *.*    /var/log/sudo
!*
…
```

`sudo`条目末尾的`!*`是一种表示“所有程序”的方式——换句话说，不再按程序名称排序。只有在你使用双感叹号“在此处停止处理匹配消息”语法时才需要此语法。

### 记录日志操作

现在你已经知道如何将日志消息分类到不同的桶中，让我们看看如何对这些消息采取不同的操作。消息可以写入文件、通过管道发送到程序、发送到另一个主机或写入用户。

#### 将日志记录到文件

到目前为止的大多数示例都是将日志消息发送到文件，给出文件的完整路径作为操作。以下是将来自`local6`设施的所有消息发送到日志文件的步骤：

```
local6.*    /var/log/flowtools
```

你也可以通过给出设备节点的完整路径将消息发送到设备，但这只对非常少的设备有意义，例如控制台。这是因为将日志消息写入磁盘设备*/dev/wd0d*不会将消息存储在磁盘上。

#### 将日志记录到程序

要将选定的日志发送到程序，请使用管道（`|`）和程序的完整路径，如下所示：

```
*.*    |/usr/local/bin/logsurfer
```

日志系统应该启动目标程序，然后将日志消息喂入程序的标准输入。

#### 通知用户

你还可以通过列出逗号分隔的用户列表将日志消息直接发送到已登录用户。例如，要发送消息给所有用户，请使用星号。

```
*.emerg    *
*.info    lasnyder
```

此示例将通知所有已登录用户真正的紧急情况，但会深深惹恼`lasnyder`.^([41])

#### 将日志记录到远程主机

我通常有一个日志主机，它从各个地方收集日志消息——不仅从我的 OpenBSD 服务器，还包括所有其他类 Unix 系统、路由器、交换机以及其他任何支持 syslog 的设备。这减少了我的维护需求并节省了磁盘空间。而且，由于每个日志消息都包含一个主机名，我可以在稍后轻松地对它们进行分类。

要向另一个主机发送消息，请使用 `@` 符号。

```
*.info    @loghost.blackhelicopters.org
```

这会将优先级为 `info` 及以上的所有内容都转到我的日志主机。

你的日志主机必须接受来自网络的 syslog 消息。如果你的主机是 OpenBSD 机器，请使用 `-u` 标志运行 `syslogd`。并且务必使用数据包过滤器保护你的日志主机，这样随机主机就不能向它写入日志并填满你的磁盘。

### 自定义 syslogd

OpenBSD 默认运行 `syslogd`，你可以自定义 `syslogd` 的行为。常见的自定义包括添加更多的日志套接字和监听网络。

#### 添加额外的日志套接字

程序将日志消息写入 */dev/log* 套接字，但 `chroot` 内部的软件无法访问该设备。要使一个被锁定在 `chroot` 内的程序向 `syslogd` 发送消息，必须在 `chroot` 内的 */dev/log* 处放置一个额外的日志套接字。

例如，由于集成的 BIND DNS 服务器被 `chroot` 到 */var/named*，DNS 服务器期望在 */dev/log* 找到日志套接字，这意味着新的日志套接字应该位于 */var/named/dev/log*。要创建此日志套接字，请使用 `syslogd` 的 `-a` 选项，并在 *etc/rc.conf.local* 中给出日志套接字的完整路径。

```
syslogd_flags="-a /var/named/dev/log"
```

你可以使用大约 20 个额外的日志套接字。

#### 监听网络

如果你想让你的 OpenBSD 服务器充当日志主机，接受来自远程主机的日志，请使用 `-u` 标志。

```
syslogd_flags="-u"
```

由于 syslog 协议没有访问控制，任何可以访问日志主机上 514/UDP 端口的用户都可以写入你的日志文件。

### 注意

用垃圾填充主机的日志以填满硬盘是一种旧攻击。使用 OpenBSD 的数据包过滤系统（在第二十一章 Packet Filtering 和第二十二章 Advanced PF 中讨论）来保护你的日志主机。

### Syslog 和嵌入式系统

OpenBSD 支持将日志消息写入内存缓冲区，这允许在没有任何可写磁盘的系统上进行日志记录，例如无盘系统、嵌入式路由器和防火墙。`syslogd` 在内存缓冲区中保留这些日志，并且客户端可以通过报告套接字连接到 `syslogd` 并读取日志。正如你所期望的，当 `syslogd` 关闭时，内存中的日志会消失。

要使用 `syslogd` 进行报告，首先使用 `-s` 选项提供一个报告套接字，并给出报告套接字的完整路径。以下是一个在 */var/run/syslog* 中的报告套接字的 *rc.conf.local* 条目：

```
syslogd_flags="-s /var/run/syslog"
```

要将日志记录到缓冲区，在 *syslog.conf* 中创建一个动作。指定使用冒号 (`:`) 将日志记录到缓冲区，指定缓冲区的大小（以千字节为单位），然后是另一个冒号，以及内存缓冲区的名称。（最大缓冲区大小为 256KB。）

例如，这里我们捕获所有 `err` 级别或更高的日志消息，并将它们写入名为 `errors` 的 128KB 内存缓冲区：

```
*.err    :128:errors
```

使用 `syslogc(8)` 读取内存缓冲区，并使用 `-s` 选项告诉 `syslogc` 在哪里找到 `syslogd` 的报告套接字，并提供日志缓冲区的名称。以下是如何读取报告套接字 */var/run/syslog* 并读取 `errors` 缓冲区的方法：

```
$ **syslogc -s /var/run/syslog errors**
```

如果你忘记了要读取的缓冲区名称，请使用 `-q` 选项让 `syslogc` 查询可用的内存日志列表。务必提供报告套接字。

### 注意

即使你不是程序员，你仍然可以使用真实的 syslog 功能。通过 `logger(1)` 程序，shell 脚本可以将日志记录到 syslog。有关详细信息，请参阅 `logger` 的 man 页。

## 日志文件维护

你可以捕获日志。太棒了！现在只需让日志文件增长，直到它们填满你的硬盘，没有空间留给其他东西，对吧？或者你可以丢弃旧日志，让系统将日志保持在一个可管理的尺寸。这被称为 *日志轮转*。

查看系统消息日志 */var/log/messages*，你应该看到六个 *messages* 文件：*messages*，*messages.0.gz*，*messages.1.gz*，*messages.2.gz*，*messages.3.gz*，和 *messages.4.gz*。未压缩的 *messages* 文件是当前日志文件。其他文件是旧日志；*messages.0.gz* 是最新的，*messages.4.gz* 是最旧的。

当当前日志文件达到一定年龄或特定大小时，日志轮转会丢弃最旧的日志文件 (*messages.4.gz*)，并将次旧的文件 *messages.3.gz* 重命名为 *messages.4.gz*；*messages.2.gz* 重命名为 *messages.3.gz*；依此类推。现有的 *messages* 文件被重命名为 *messages.0* 并压缩，然后创建一个新的 *messages* 文件。

`newsyslog(8)` 程序轮转日志文件，重启守护进程，运行命令，将旧文件移动到其他目录，并处理所有常规任务。`root` 通过 `cron(8)` 每小时运行一次 `newsyslog`。当 `newsyslog` 启动时，它会读取 */etc/newsyslog.conf* 并检查列出的每个日志文件。如果满足轮转日志文件的条件，则轮转日志并执行其他配置的操作。

### newsyslog.conf 字段

*newsyslog.conf* 使用每行一个日志文件。每一行包含七个字段，如下所示：

```
/var/log/authlog        root:wheel      640  7     *    168   Z
```

从左到右，字段依次是日志文件、所有者、权限、保留文件数、大小、时间和标志。在标志字段之后，你可能还会看到一些可选参数。我们将按顺序查看每个字段。

#### 日志文件

每行的第一个条目是要处理的日志文件的完整路径（在这个例子中是 `/var/log/authlog`）。这必须与当前日志文件完全匹配。

#### 所有者

第二个字段（在我们的示例中为 `root:wheel`）列出了日志文件的所有者和组，由冒号分隔。此字段是可选的，并且在许多默认条目中不存在。

默认情况下，日志文件属于 root 用户和 `wheel` 组，但 `newsyslog` 可以更改日志文件的所有权。虽然更改所有权并不常见，但您可能希望明确声明特定文件的所有权。

您可以选择只更改所有者或只更改组。在这些情况下，只需在名称的一侧使用冒号，例如 `:wheel` 或 `root:`。如果您正在更改所有权，则必须始终包含冒号。

#### 权限

第三字段（在我们的示例中为 `640`）给出了旋转文件的权限，使用标准八进制表示法，如 `chmod(1)` 中所述。此字段是可选的，并且在许多默认条目中不存在。

#### 计数

第四字段指定 `newsyslog` 保留的归档日志文件的数量。在我们的示例中，*/var/log/messages* 有当前日志文件和五个归档，编号为 0 到 4。*newsyslog.conf* 为 */var/log/messages* 设置了 `5` 的计数。

#### 大小

第五字段是千字节大小的文件。当 `newsyslog` 运行时，它会检查日志文件的大小。如果日志文件的大小超过此处给出的值，`newsyslog` 将旋转日志。如果您不希望文件大小影响 `newsyslog` 何时旋转文件，请在此处放置一个星号。

#### 时间

要根据时间旋转日志，请使用第六个字段，它有四个可能的值：一个星号，一个数字，以及两种标准格式之一的时间。如果您根据大小而不是年龄旋转日志，请在此处放置一个星号。如果您在此处放置一个数字，则指定日志将在多少小时后旋转。我们的示例 */var/log/authlog* 每 168 小时旋转一次。

时间格式——ISO 8601 限制和 `newsyslog` 特定——要复杂一些。

> ISO 8601 限制
> 
> 以 `@` 符号开始的日期条目是 ISO 8601 限制时间格式。ISO 8601 限制时间格式在大多数类 Unix 系统上由 `newsyslog` 使用，因为它曾是麻省理工学院原始 `newsyslog` 使用的日期格式。ISO 8601 格式有点晦涩，但我所了解的每个类 Unix 操作系统都支持它。
> 
> 完整日期以 ISO 8601 格式表示为中间有 `T` 的 14 位数字。前四位是年份，接下来的两位是月份，接下来的两位是月份中的日期。（`T` 类似于小数点，将整个天数与一天的小数部分分开。）接下来的两位是小时，接下来的两位是分钟，最后两位是秒。例如，2013 年 9 月 13 日下午 3:18 和 58 秒的日期表示为 `20130913T151858`。（指定特定日期和时间来旋转日志不会非常有用，因为日志只会旋转一次。）
> 
> 您可以选择仅指定靠近 `T` 的字段，而将较远的字段留空。再次强调，如果您将 `T` 视为小数点，则不需要将 5.87 写成 005.8700；前导和尾随零是不相关的。
> 
> 在`newsyslog`的情况下，空字段是通配符。例如，`4T00`匹配每月第四天的午夜，而`T23`匹配每天的二十三点，即晚上 11 点。如果`newsyslog.conf`中列出时间为`@T2359`，则日志每天晚上 11:59 旋转。（当然，`newsyslog`每小时运行一次，因此日志不会正好在那个时间旋转。）
> 
> 与`cron(8)`一样，需要详细指定时间单位。例如，`@9T`，表示每月的第九天，每小时旋转一次日志，这意味着在这一天全天都会旋转日志。可能更好的做法是指定时间为`@9T01`，这样日志就会在每月的第九天凌晨 1 点旋转。由于`newsyslog`每小时运行一次，因此不需要比小时更精确地指定时间。
> 
> newsyslog 时间
> 
> 由于 ISO 8601 时间格式无法轻松指定每周的任务，并且无法指定每月的最后一天，OpenBSD 包含一个针对`newsyslog`特定的日期格式，允许您轻松指定这些常见时间。
> 
> 任何以美元符号（`$`）开头的条目都使用*月份 星期 天*格式。
> 
> 此特定格式使用三个标识符：*`M`*（月份中的某一天）、*`W`*（星期中的某一天）和*`H`*（一天中的某个小时）。每个标识符后面跟着一个数字，表示您正在使用的单位。小时范围从`0`到`23`，星期范围从`0`（星期日）到`6`（星期六）。月份中的天数从`1`开始到`31`结束，`L`或`l`代表月份的最后一天。例如，要在每月的第五天中午旋转日志，请使用`$M5H12`。要在每月最后一天的晚上 11 点开始月末会计，请使用`$MLH23`。
> 
> 如果您没有指定小时，则默认时间为所选日期的午夜。如果`newsyslog.conf`条目同时列出文件旋转的时间和大小，则`newsyslog`会在满足任一要求时旋转日志。

#### 标志

第七字段是可选的，它指导`newsyslog`对文件本身进行特殊处理。OpenBSD 使用四个标志：

+   ****`Z`****. 使用`gzip(1)`压缩文件。

+   ****`B`****. 对于二进制文件，不要向文件中添加“日志文件已切换”的消息。

+   ****`F`****. 跟踪符号链接。

+   ****`M`****. 用户正在监控此日志。

虽然`B`和`Z`标志在严格意义上不是互斥的，但大多数日志文件只需要其中一个，而且大多数二进制文件本身压缩效果不佳。（默认的`newsyslog.conf`压缩了包过滤日志文件，但这有点奇怪。）如果您看到带有`M`标志的`Z`标志，则在压缩日志之前，旧日志文件将被发送给用户。

### 监控日志

OpenBSD 的`newsyslog`可以在旋转日志之前将日志通过电子邮件发送给用户。如果您仔细控制日志的排序方式，此功能可能很有用。例如，`sudo(8)`日志记录成功的使用情况为`notice`优先级，但失败的用法为`alert`优先级。您可以在`syslog.conf`中将这些拆分为单独的日志文件，如下所示：

```
!sudo
*.*         /var/log/sudo
*.alert    /var/log/sudofail
```

`/var/log/sudofail`文件现在应只包含`sudo`失败，例如用户输入错误的密码或超出其权限。

现在你可以通过运行带有`-m`标志的`newsyslog`来告诉`newsyslog`检查受监控的日志。（`newsyslog`作为 root 的 cron 作业之一运行。）

要在日志轮换时每次都通过电子邮件将`sudo`失败日志发送给你，你可以将你的账户放入监控字段。

```
/var/log/sudofail    root:wheel    640    30    *    $H06    ZM    mwlucas
```

这假设这台机器上`mwlucas`账户收到的电子邮件会到达我这里。确保这一点的最简单方法是将电子邮件转发到`/etc/mail/aliases`。

### 注意

如果你认真对待观察这类故障，请在用户无法访问的日志主机上监控日志。一个成为本地机器 root 的用户可以在日志被电子邮件发送和轮换之前编辑日志。

### 添加 PID 文件

如果`newsyslog`试图轮换和压缩文件，但写入文件的进程仍在写入文件，文件可能会损坏。一些程序在释放其日志文件之前需要受到适当的打击。如何？只需在这里列出 PID 文件，然后`newsyslog`将向该进程 ID 发送`SIGHUP`（类似于`kill -1`）。

注意，PID 文件并不是识别特定进程的非常安全的方法，因为它们容易受到竞争条件和其它攻击。如果服务器有一个轮换日志的命令，那可能比向 PID 文件中指示的进程发送信号更明智的选择。

### 信号名称

要向具有 PID 文件的进程发送除`SIGHUP`之外的信号，请使用不同的*信号名称*。信号名称必须以`SIG`开头，并按名称指定。你可以在`signal(3)`中找到信号的全列表，但软件文档应该告诉你进程需要释放哪个信号才能重新启动其日志文件。此字段是可选的，但如果你使用它，你必须立即在它之前输入 PID 文件的完整路径。

### 要执行的命令

你可以通过在双引号中给出命令的完整路径，让`newsyslog`在轮换日志时运行一个命令，而不是向进程发送信号。虽然此字段是可选的，但它不能与 PID 文件结合使用。你可以使用 PID 文件或命令名称，但不能两者都使用。

## 系统时间

系统时间不正确没有借口。一旦你设置了时区，从任何数量可自由获取的网络时间服务器持续校正 OpenBSD 的时钟是很容易的。特别是虚拟机因时钟偏移而臭名昭著，但时间校正对它们也有效，所以，正如我说的，没有借口。

OpenBSD 包括其自己的 NTP 客户端，OpenNTPD，它被编写为安全且安全。然而，在`ntpd(8)`能够做任何事情之前，它需要一些配置。

### 配置`ntpd(8)`

OpenBSD 自带了一个完全可接受的通用`ntpd`配置，该配置使用公共时服务器。如果您的宿主机在公共互联网上，并且您只想设置系统时间，而不是为其他主机提供时间，请使用默认设置。否则，您必须通过选择时间源并决定`ntpd`是否将接受来自其他机器的时间请求来定制`/etc/ntpd.conf`。

#### 时间冗余

NTP 通过查询远程服务器来获取时间。如果您只有一个服务器，那么假定该时间是正确的。然而，如果您有多个时服务器，时间并不是简单地平均。如果一个时服务器与其他所有时服务器的时间相差甚远，那么该服务器的时间将被丢弃，并从剩余的时间中选择中位数。如果您只有两个时服务器，并且从它们那里获取的时间不同，`ntpd`无法确定哪个是正确的。为了帮助`ntpd`做出合理的决策，请始终列出至少三个时服务器。

#### 时间源

使用`server`、`servers`和`sensor`关键字选择您的时间源。

`server`选项告诉`ntpd`从一个单独的服务器获取时间，该服务器可能有多个 IP 地址。如果是这种情况，`ntpd`会尝试使用第一个 IP 地址。如果第一个地址不可用，它会尝试第二个，依此类推，直到得到响应。如果您有特定的时服务器要使用，请使用`server`选项，并确保列出至少三个时服务器。

```
server time1.blackhelicopters.org
server time2.blackhelicopters.org
server time3.blackhelicopters.org
```

`servers`选项告诉`ntpd`从共享相同主机名的多个主机获取时间。默认的`ntpd.conf`包括以下条目：

```
servers pool.ntp.org
```

主机`pool.ntp.org`有四个 IP 地址，`ntpd`将尝试从所有这些主机获取时间。

如果您有一个硬件时间传感器，您可以告诉`ntpd`从它那里读取时间。硬件时间传感器包括`nmea(4)`、`udcf(4)`和`mbg(4)`。`sensor`选项告诉`ntpd`使用硬件传感器。如果您投资了硬件时间传感器，您可能会对时间测量发射器和接收器之间的距离，并根据光速延迟调整时间感到足够关心。`correction`关键字允许您指定传感器落后于标准时间的微秒数。

当我写下这段文字时，一个 40 毫秒（ms）的延迟在科学界引起了轩然大波，因为研究人员认为他们可能看到了一个中微子以比光速更快的速度移动，所以我们将 40 毫秒的修正值放入我们的时间传感器中。

```
sensor nmea0 correction 40000
```

### 注意

警告：OpenBSD 不是一个实时操作系统。您无论如何都不应该用它来测量中微子速度！

#### 提供时间服务

我只在封闭网络上运行时间服务器，在这些网络上，很少的主机可以访问公共互联网。如果我有硬件时间传感器，我也会运行时间服务器，但大多数时候，我只是使用公共时服务器。

要让`ntpd`从其他主机回答时间查询，请使用`listen on`指令。您可以选择一个 IP 地址或使用星号表示“系统上的所有 IP 地址”。

```
listen on 192.0.2.87
listen on 2001:db8::aaaa
```

由于 `ntpd` 没有访问控制，任何可以连接到端口 123/UDP 的主机都可以从这个服务器获取时间。如果您担心这一点，可以使用数据包过滤（在第二十一章和第二十二章中讨论）来限制时间检查仅限于您网络上的主机。OpenNTP 的作者在他的整个公司以及公众中，使用一个带有 16MB（是的，是一个 *M*）RAM 的 MicroVAX 3100 上运行 NTP 进程，处理器使用率不超过 5%，因此 NTP 在现代系统上施加的负载是可以忽略不计的。

现在 `ntpd` 已经配置好了，让我们来使用它。

### 使用 ntpd(8)

您可以缓慢地纠正时间，或者一次性完成。我建议在启动时完全纠正时间，然后让 `ntpd` 在系统运行时缓慢调整系统时钟。这样可以在任何东西依赖它之前纠正时间，但又能持续保持同步。

在启动 `ntpd` 时纠正时间，请使用 `-s` 标志。

```
# **ntpd -s**
```

一旦 `ntpd` 从时间服务器收到响应并调整了时钟，您将获得一个命令提示符。在启动时，这会延迟其他软件的启动，以便它有正确的时间，并且当您检查时钟时，应该看到正确的时间。您可以在启动时使用 */etc/rc.conf.local* 中的 `ntpd_flags` 来配置此设置。

```
ntpd_flags='-s'
```

如果运行中的系统时钟不准确，并且您正在运行可能会因时钟倒退或时间跳跃（如许多数据库）而损坏的软件，您可能需要告诉 `ntpd` 更慢地纠正时钟。为此，请不带任何标志运行 `ntpd`，或者在 `rc.conf.local` 中设置它，以便在启动时以这种方式运行。

### 注意

您的起始时间可能偏差太大，以至于在任何合理的时间内都无法逐渐调整到正确的时间。为了修复时钟，在您能够关闭敏感软件时安排时钟更改，并确保在之后运行 NTP 以确保问题得到解决。最好是立即修复时钟并完成它。

## 硬件传感器

传感器是检查硬件健康和状态的物理探头。制造商在硬件中放置了越来越多的传感器，为操作系统提供低级硬件信息。OpenBSD 支持广泛的硬件传感器，并使用 `sensorsd` 守护进程查询它们并处理错误状态。

解决许多硬件错误需要关闭机器，但提前警告某个组件已停止工作，将硬件故障从意外的白天灾难转变为下班后的烦恼。一些硬件，如热插拔硬盘，一旦知道硬件已故障，就可以在不中断服务的情况下更换。

### 设备驱动程序

每个物理传感器都有一个设备驱动程序。设备驱动程序从硬件中提取信息，并在 sysctl（在第十八章中讨论）中发布。`sensorsd`读取 sysctl 值，并在它们更改或超过临界值时采取行动。例如，以下是我笔记本电脑的与传感器相关的 sysctl 值：

```
$ **sysctl hw.sensors**
hw.sensors.acpitz0.temp0=67.00 degC (zone temperature)
hw.sensors.acpiac0.indicator0=On (power supply)
hw.sensors.acpibat0.volt0=11.10 VDC (voltage)
hw.sensors.acpibat0.volt1=12.35 VDC (current voltage)
hw.sensors.acpibat0.power0=0.00 W (rate)
hw.sensors.acpibat0.watthour0=2.61 Wh (last full capacity)
hw.sensors.acpibat0.watthour1=0.30 Wh (warning capacity)
hw.sensors.acpibat0.watthour2=0.06 Wh (low capacity)
hw.sensors.acpibat0.watthour3=9.57 Wh (remaining capacity), OK
hw.sensors.acpibat0.raw0=2 (battery full), OK
hw.sensors.cpu0.temp0=81.00 degC
```

这款相对简单通用的硬件具有两个温度传感器和各种功率传感器。根据你的硬件，你可以获得数百行传感器输出。

许多 RAID 控制器有自己的传感器，并在阵列失败时报告。这里，我们看到由 AMI RAID 控制器提供的三个虚拟磁盘：

```
hw.sensors.ami0.drive0=online (sd0), OK
hw.sensors.ami0.drive1=degraded (sd1), WARNING
hw.sensors.ami0.drive2=failed (sd2), CRITICAL
```

如果没有传感器，你需要查看驱动器外壳上的闪烁灯光。或者你可以听那令人讨厌的“哔哔哔哔”声，这在 5,000 个服务器风扇、空调和某人其他硬件的哔哔声中是如此容易听到。

### 注意

一些传感器需要智能平台管理接口（IPMI）。这是一个默认在 OpenBSD 中禁用的内核功能，因为它会使某些机器表现得很糟糕。第十八章讨论了启用 IPMI。

设备驱动程序会自动连接到传感器，值会自动进入内核，但要以任何自动化的方式对这些结果进行处理，你需要`sensorsd(8)`，或者你需要配置一个基于 SNMP 的外部管理系统并使用`snmpd(8)`。我们将在这里查看使用`sensorsd(8)`。在第十六章中讨论了使用`snmpd(8)`。

### 传感器配置

传感器守护进程`sensorsd(8)`监视传感器监控数据。它记录更改，并在需要时执行命令。由于所有硬件都不同，所有环境都不同，默认情况下，`sensorsd`只注意传感器读数的变化。要采取行动，你必须配置`/etc/sensorsd.conf`中的`sensorsd`。

#### 传感器类型

OpenBSD 支持许多类型的传感器，如表 15-2 所示。

表 15-2. 表 15-2：支持的传感器类型

| 名称 | 功能 |
| --- | --- |
| 温度 | 温度（摄氏度） |
| 风扇 | 风扇速度（RPM） |
| 电压 | 直流电压 |
| 交流电压 | 交流电压 |
| 电阻 | 欧姆电阻 |
| 功率 | 瓦特 |
| 电流 | 安培 |
| 瓦特时 | 功率容量 |
| 安培时 | 功率容量 |
| 指示器 | 设备相关是/否 |
| 原始值 | 设备相关值 |
| 百分比 | 设备相关百分比 |
| 照度 | 照明 |
| 硬盘驱动器 | 硬盘 |
| 时间差 | 操作系统与硬件之间的时间差 |
| 湿度 | 百分比湿度 |
| 频率 | 微赫兹 |
| 角度 | 微度 |

你需要检查你的硬件手册，才能了解如何有效地使用这些传感器中的某些传感器。

一些传感器似乎有重叠。例如，为什么 OpenBSD 有那么多关于功率的单独值，当你可能通过一些数学运算得到一个共同的功率表时？原因是这些是实际传感器报告的值，开发者更愿意给你实际的测量值。OpenBSD 确实执行了一些数据合理化，但仅限于简单数据；例如，所有温度传感器都被归一化到摄氏度。

现在，让我们看看你可以用这些传感器做什么。

#### sensorsd.conf 中的设置

文件*sensorsd.conf*有示例条目，但由于环境差异很大，它们都被注释掉了。它使用`termcap`风格的配置语法，类似于*/etc/remote*（见第五章“引导过程”）或*/etc/login.access*（见第六章“用户管理”），其中用冒号分隔条目中的术语。每个条目以要测量的传感器开始，后跟属性名称和设置。

例如，这是默认*sensorsd.conf*中的一个温度传感器的条目：

```
hw.sensors.lm0.temp0:high=50C
```

对于传感器`lm0.temp0`，`high`属性设置为`50C`。

`sensorsd`支持四个属性：

+   ****`high`****. 上限

+   ****`low`****. 下限

+   ****`command`****. 当超过限制或状态改变时运行的命令

+   ****`istatus`****. 忽略此状态

报告的传感器类型值取决于什么是有意义的。对于温度和电压，当高限和低限有意义时，一些传感器会报告特定的值。前面显示的 RAID 控制器报告驱动器为降级、故障或健康。报告标量值的硬盘传感器没有用，因为你想知道 RAID 容器是否健康或驱动器是否已故障。没有中间地带。

对于单个传感器，你可以有高值和低值。例如，在大多数数据中心，温度可能没有低值，但电压肯定有。我在各种奇怪的地方工作，并不是所有这些地方都有干净的电源。

```
hw.sensors.acpibat0.volt0:low=11.0V:high=13.0V
```

有这样的行，如果我的笔记本电脑的电源低于 11 伏或高于 13 伏，我会知道。

一些系统可能具有数十种特定类型的传感器，这可能会使配置变得复杂。如果我的主板有 15 个温度传感器，我不想单独配置每个。幸运的是，你可以按类型批量配置传感器，而且由于我不关心哪个温度传感器会超过 80 摄氏度（如果任何一个超过，我想要一个警报），这很有效。

```
temp:high=80C
```

当应用此规则时，`sensorsd`首先寻找特定传感器的配置项。如果没有找到该特定规则，它会寻找通用规则。你可以为大多数温度传感器设置一个规则，然后为特定传感器覆盖它，如下所示：

```
hw.sensors.lm0.temp5:high=90C
temp=80C
```

这条规则说明，我的大多数温度传感器在 80 度时发出警报，但一个特定的传感器直到 90 度才会发出警报。

我关心温度，但我不在乎我的花哨键盘看到没有光，想要触发其背光。你可以使用 `istatus` 关键字忽略一个传感器或传感器类型。

```
illuminance:istatus
```

你应该根据你的环境和设备完全忽略某些类型的警报。自己做出决定。

#### 传感器触发动作

当硬盘故障时在 */var/log/daemon* 中有一个条目是好的，但如果系统会发送电子邮件、给你发短信或触发你的监控系统就更好了。它应该做些事情——*任何事*——不需要你登录并查看日志文件。幸运的是，`sensorsd` 可以在检测到问题或超过阈值时运行任意命令，使用 `command` 属性。

由于传感器种类繁多及其可能的错误状态和条件，`sensorsd` 没有细粒度的“对于错误运行此命令，但对于恢复运行那个其他命令。” 有太多可能的错误状态和条件，这使得这样做没有意义。相反，`sensorsd` 在超过任何阈值或任何状态变化时运行单个命令，包括启动时和单个传感器的状态从“未知”变为它开始时的状态。

考虑这个 *sensorsd.conf* 条目：

```
temp:high=80C:command=/sbin/reboot
```

初看，这看起来像是“如果温度高，重启机器。” 你认为这将毫无疑问地杀死任何占用你发热 CPU 的失控进程（完全不考虑除了 CPU 之外的其他硬件也会产生热量的事实），但 `sensorsd` 将在温度状态变化时运行该命令。状态在启动时变化，当第一次读取温度时，这意味着你的系统将启动，然后立即重启。你的脚本需要智能。

为了使脚本编写更容易，`sensorsd` 可以将一组变量传递给脚本：

+   ****`%1`****. 值是否在 *sensorsd.conf* 中设置的范围内？这可以是 `below`、`above`、`within`、`invalid` 或 `uninitialized` 之一。

+   ****`%n`****. 传感器编号。

+   ****`%s`****. 传感器状态。

+   ****`%x`****. 传感器所在设备。

+   ****`%t`****. 传感器类型。

+   ****`%2`****. 传感器的当前值。

+   ****`%3`****. 传感器的下限

+   ****`%4`****. 传感器的上限。

你可能运行一个温度命令如下：

```
temp:high=80C:command=/usr/local/script/temp %1 %2 %n
```

你的脚本 */usr/local/script/temp* 将接受三个参数：错误条件、温度和传感器名称。你的脚本将检查这些值，看看是否需要重启。

使用 `sensorsd`、正确的时间管理和日志文件管理，你的 OpenBSD 系统可以很大程度上自我管理。

在下一章中，我们将探讨 OpenBSD 如何照顾其他主机。

* * *

^([41]) 嘿，我快想不出怎么让 lasnyder 不高兴了——至少是合理的办法。
