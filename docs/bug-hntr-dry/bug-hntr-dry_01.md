# 第一章：漏洞挖掘

*漏洞挖掘* 是在软件或硬件中寻找错误的过程。然而，在这本书中，术语 *漏洞挖掘* 将专门用来描述寻找安全关键软件错误的过程。安全关键错误，也称为软件安全漏洞，允许攻击者远程损害系统、提升本地权限、跨越权限边界，或者以其他方式对系统造成破坏。

大约十年前，寻找软件安全漏洞主要是作为一种爱好或作为一种吸引媒体关注的方式。当人们意识到可以从漏洞中获利时，漏洞挖掘进入了主流。¹

软件安全漏洞，以及利用这些漏洞的程序（称为 *漏洞利用*），得到了很多媒体报道。此外，许多书籍和互联网资源描述了利用这些漏洞的过程，并且关于如何披露漏洞发现的问题一直在持续辩论。尽管如此，关于漏洞挖掘过程本身的出版物却出奇地少。尽管像 *软件漏洞* 或 *漏洞利用* 这样的术语被广泛使用，但许多人——甚至许多信息安全专业人士——并不知道漏洞挖掘者是如何在软件中找到安全漏洞的。

如果你问 10 个不同的漏洞挖掘者他们如何搜索软件中的安全相关错误，你很可能会得到 10 个不同的答案。这就是为什么至今还没有，可能永远也不会有一个“食谱”式的漏洞挖掘指南。与其试图编写一本通用的指令书而失败，我将描述我用来在现实生活中的软件中找到特定错误的方法和技术。希望这本书能帮助你发展自己的风格，以便你能够找到一些有趣的、安全关键的软件错误。

# 1.1 为了乐趣和利益

寻找漏洞的人有不同的目标和动机。一些独立的漏洞挖掘者希望提高软件安全性，而其他人则寻求通过名声、媒体关注、报酬或就业来获得个人收益。一家公司可能希望找到漏洞，以便将其用作营销活动的素材。当然，总有那些坏苹果，他们想找到新的方法来入侵系统或网络。另一方面，有些人只是出于乐趣——或者为了拯救世界。![更多内容](img/httpatomoreillycomsourcenostarchimages939227.png)

# 1.2 常见技术

虽然没有正式的文档描述标准的 bug 寻找过程，但确实存在一些常见的技巧。这些技巧可以分为两类：*静态*和*动态*。在静态分析中，也称为*静态代码分析*，检查软件的源代码或二进制的反汇编，但不执行。相反，动态分析涉及在软件执行时进行调试或模糊测试。这两种技术都有其优缺点，大多数 bug 猎人都会使用静态和动态技术的组合。

## 我偏爱的技巧

大多数时候，我更喜欢静态分析方法。我通常一行一行地阅读目标软件的源代码或反汇编，并试图理解它。然而，从头到尾阅读所有代码通常并不实用。当我寻找 bug 时，我通常首先尝试确定用户影响的输入数据是如何通过外部世界的接口进入软件的。这可能是网络数据、文件数据或执行环境中的数据，仅举几个例子。

接下来，我研究输入数据在软件中传递的不同方式，同时寻找对数据进行操作的任何可能可利用的代码。有时我能够仅通过阅读源代码（见第二章`和`strcat()`，以寻找可能的缓冲区溢出。或者，你也可以在反汇编中搜索`movsx`汇编指令，以找到符号扩展漏洞。如果你发现了一个可能存在漏洞的代码位置，你可以通过回溯代码来查看这些代码片段是否暴露了任何从应用程序入口点可访问的漏洞。我很少使用这种方法，但其他 bug 猎人对此深信不疑。

## 模糊测试

一种被称为 *模糊测试* 的完全不同的漏洞搜索方法。模糊测试是一种动态分析技术，它通过向应用程序提供格式错误或意外的输入来测试应用程序。虽然我不是模糊测试和模糊测试框架的专家——我知道一些漏洞搜索者开发了他们自己的模糊测试框架，并使用他们的模糊测试工具找到了大部分漏洞——但我有时会使用这种方法来确定用户影响的输入何时进入软件，有时也会用它来寻找漏洞（见第八章第八章。铃声大屠杀）。

你可能想知道如何使用模糊测试来识别用户影响的输入何时进入软件。想象一下，你有一个以二进制形式存在的复杂应用程序，你想检查其中的漏洞。识别这种复杂应用程序的入口点并不容易，但复杂的软件在处理格式错误的输入数据时往往会崩溃。这对于解析数据文件的软件（如办公产品、媒体播放器或网络浏览器）来说同样适用。大多数这些崩溃与安全无关（例如，浏览器中的除以零错误），但它们通常提供了一个我可以开始寻找用户影响的输入数据的入口点。

## 进一步阅读

这些只是可用于在软件中查找错误的技术和方法的少数几个。有关在源代码中查找安全漏洞的更多信息，我推荐 Mark Dowd、John McDonald 和 Justin Schuh 的 *软件安全评估艺术：识别和预防软件漏洞*（Addison-Wesley，2007）。如果你想了解更多关于模糊测试的信息，请参阅 Michael Sutton、Adam Greene 和 Pedram Amini 的 *模糊测试：暴力漏洞发现*（Addison-Wesley，2007）。

# 1.3 内存错误

本书描述的漏洞有一个共同点：它们都导致可利用的内存错误。这种内存错误发生在进程、线程或内核是

+   使用它不拥有的内存（例如，如第 A.2 节所述的空指针解引用）

+   使用比已分配的更多的内存（例如，如第 A.1 节所述的缓冲区溢出）

+   使用未初始化的内存（例如，未初始化的变量）^([2])

+   使用有缺陷的堆内存管理（例如，双重释放）^([3])

记忆错误通常发生在使用像显式内存管理或指针算术这样的强大 C/C++ 功能时使用不当。

一种被称为 *内存损坏* 的内存错误子类别发生在进程、线程或内核修改它不拥有的内存位置，或者当修改损坏了内存位置的状态时。

如果你对这些内存错误不熟悉，我建议你查看 A.1、A.2 和 A.3 节。这些章节描述了本书中讨论的编程错误和漏洞的基本知识。

除了可利用的内存错误之外，还存在数十种其他漏洞类别。这包括逻辑错误和特定于 Web 的漏洞，如跨站脚本、跨站请求伪造和 SQL 注入，仅举几例。然而，这些其他漏洞类别不是本书的主题。本书中讨论的所有漏洞都是可利用内存错误的结果。

# 1.4 行业工具

在寻找漏洞或构建用于测试它们的利用程序时，我需要一种方法来查看应用程序的工作原理。我通常使用调试器和反汇编器来获得这种内部视角。

## 调试器

调试器通常提供方法来附加到用户空间进程或内核，读写寄存器和内存中的值，并使用诸如断点或单步执行等特性来控制程序流程。每个操作系统通常都附带自己的调试器，但还有几个第三方调试器可供选择。表 1-1 列出了不同的操作系统平台和本书中使用的调试器。

表 1-1. 本书中使用的调试器

| 操作系统 | 调试器 | 内核调试 |
| --- | --- | --- |
| Microsoft | WinDbg (来自微软的官方调试器) | yes |
| Windows | OllyDbg and its variant Immunity Debugger | no |
| Linux | The GNU Debugger (gdb) | yes |
| Solaris | The Modular Debugger (mdb) | yes |
| Mac OS X | The GNU Debugger (gdb) | yes |
| Apple iOS | The GNU Debugger (gdb) | yes |

这些调试器将被用来识别、分析和利用我所发现的漏洞。有关一些调试器命令速查表，请参阅 B.1、B.2 和 B.4 节。

## 反汇编器

如果你想审计一个应用程序但没有访问源代码，你可以通过读取应用程序的汇编代码来分析程序的二进制文件。尽管调试器具有反汇编进程或内核代码的能力，但它们通常并不特别容易或直观地使用。填补这一空白的程序是交互式反汇编器专业版，也称为 IDA Pro.^([4]) IDA Pro 支持超过 50 种处理器系列，并提供完全交互性、可扩展性和代码图形化。如果你想审计程序二进制文件，IDA Pro 是必备的。有关 IDA Pro 及其所有功能的详尽介绍，请参阅 Chris Eagle 的*IDA Pro 书籍*，第 2 版（No Starch Press，2011 年）。

# 1.5 EIP = 41414141

### 注意

*指令指针/程序计数器：*

+   *EIP—32 位指令指针 (IA-32)*

+   *RIP—64 位指令指针 (Intel 64)*

+   *R15 或 PC—苹果 iPhone 上使用的 ARM 架构*

为了说明我所发现的漏洞的安全影响，我将讨论通过控制 CPU 的指令指针（IP）来获取受漏洞程序执行流程控制所需的步骤。指令指针或程序计数器（PC）寄存器包含下一个要执行的指令在当前代码段中的偏移量.^([5]) 如果你控制了这个寄存器，你就完全控制了受漏洞过程执行流程。为了演示指令指针控制，我将修改寄存器的值为`0x41414141`（ASCII 字符`AAAA`的十六进制表示），`0x41424344`（ASCII 字符`ABCD`的十六进制表示），或类似值。所以如果你在以下章节中看到`EIP = 41414141`，这意味着我已经控制了受漏洞程序。

一旦你掌握了指令指针的控制权，就有许多方法可以将它转变为一个完全工作、武器化的漏洞利用。有关漏洞开发过程的信息，你可以参考乔恩·埃里克森的《黑客：漏洞利用的艺术》，第 2 版（No Starch Press，2008 年），或者你可以在 Google 中输入“exploit writing”并浏览在线上可用的大量材料。

# 1.6 最后的注意事项

在本章中，我们覆盖了大量的内容，你可能会有很多疑问。不用担心——这是一个很好的位置。接下来的七个日记章节将更深入地探讨这里介绍的主题，并回答你许多问题。你还可以阅读附录，以获取本书中讨论的各种主题的背景信息。

### 注意

日记章节并非按时间顺序排列。它们是根据主题内容进行编排的，以便概念相互关联。

## 备注

^([1])

^([2])

^([3])

^([4])

^([5])

* * *

^([1]) 请参阅佩德拉姆·阿米尼的“Mostrame la guita! Adventures in Buying Vulnerabilities，”2009 年，[`docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr`](http://docs.google.com/present/view?id=dcc6wpsd_20ghbpjxcr)；查理·米勒的“The Legitimate Vulnerability Market: Inside the Secretive World of 0-day Exploit Sales，”2007 年，[`weis2007.econinfosec.org/papers/29.pdf`](http://weis2007.econinfosec.org/papers/29.pdf)；iDefense Labs Vulnerability Contribution Program，[`labs.idefense.com/vcpportal/login.html`](https://labs.idefense.com/vcpportal/login.html)；TippingPoint 的 Zero Day Initiative，[`www.zerodayinitiative.com/`](http://www.zerodayinitiative.com/).

^([2]) 请参阅丹尼尔·霍德森的“未初始化变量：查找、利用、自动化”（演示文稿，Ruxcon，2008），[`felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf`](http://felinemenace.org/~mercy/slides/RUXCON2008-UninitializedVariables.pdf).

^([3]) 请参阅通用弱点枚举，CWE 列表，CWE - 单个字典定义（2.0），CWE-415: Double Free，网址为 [`cwe.mitre.org/data/definitions/415.html`](http://cwe.mitre.org/data/definitions/415.html).

^([4]) 请参阅 [`www.hex-rays.com/idapro/`](http://www.hex-rays.com/idapro/).

^([5]) 请参阅 *Intel® 64 和 IA-32 架构软件开发者手册，第一卷：基本架构*，网址为 [`www.intel.com/products/processor/manuals/`](http://www.intel.com/products/processor/manuals/).
