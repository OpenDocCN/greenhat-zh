# 第三部分-9. 其他文件和消息传输应用

第八十五章

第八十六章

本书的前三部分已经探讨了几个最广泛使用的 TCP/IP 文件和消息传输协议：文件传输协议（FTP）、简单文件传输协议（TFTP）、电子邮件（email）和万维网。当然，今天互联网上使用的其他应用有成百上千，我们不可能在这里全部考察。然而，还有一些其他协议被认为是 TCP/IP 经典应用组的一部分，如 FTP、电子邮件和万维网，我认为它们值得讨论。

本部分包含两章，涵盖了这些其他文件和消息传输应用。第一章描述了 Usenet（网络新闻），这是互联网上最早的群组通信方法之一。第二章描述了 Gopher 协议，尽管今天不再广泛使用，但仍有简要讨论的价值，尤其是由于其作为万维网历史先导的角色。

# 第八十五章. USENET（网络新闻）和 TCP/IP 网络新闻传输协议（NNTP）

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

电子邮件（email）是现代互联网上消息传输的支柱之一，但它实际上仅设计用于相对较小的一组特定用户之间的通信。有许多情况下电子邮件并不理想，例如当需要在大批参与者之间共享信息时，其中并非所有参与者都必然相互认识。一个典型的例子是共享*新闻*。在这种情况下，提供新闻的人通常希望让任何感兴趣的人都能获得，而不是指定一组特定的收件人。

为了在互联网上分发新闻和其他类型的通用信息，创建了一个名为*Usenet*和*网络新闻*的消息系统。像电子邮件一样，这个应用允许大量用户编写和阅读消息。然而，它使用了一个与电子邮件非常不同的模型——一个专注于公共共享和反馈的模型。在 Usenet 中，任何人都可以编写可以被任何数量收件人阅读的消息，任何人都可以对其他人编写的消息做出回应。Usenet 是第一个广泛部署的基于互联网的群组通信应用之一，它已经发展成为世界上最大的在线社区之一，被数百万人们用于分享信息、提问和讨论数千个不同的话题。

在本章中，我详细介绍了 Usenet 和网络新闻，讨论了它们的使用方式和工作原理。我提供了 Usenet 的概述和历史，对其通信模型以及消息的创建和操作进行了高级概述，解释了 Usenet 新闻组，并描述了 Usenet 消息格式和标题。然后，我详细描述了网络新闻传输协议（NNTP）的操作，这是现代 Usenet 上传输消息的手段。通常从协议概述开始，然后解释 NNTP 的两种基本使用方式：在服务器之间传播新闻文章以及客户端文章的发布和访问。从那里，我继续介绍 NNTP 命令、命令扩展、响应和响应代码的技术细节。

### 小贴士

**背景信息** *Usenet 的工作方式在许多方面与电子邮件所使用的标准和技巧密切相关。如果你还没有阅读第三部分-7，该部分涵盖了电子邮件，我建议你至少回顾一下第七十四章中的电子邮件系统概览以及第七十六章中关于电子邮件消息格式的讨论，因为 Usenet 消息是基于 RFC 822 电子邮件消息标准的。*

# Usenet 概述、历史和操作

在电子邮件是现代手写信件或办公室备忘录的等价物时，*Usenet* 则是公司通讯、食堂公告板、咖啡休息时间聊天以及饮水机旁闲聊的更新版，所有这些都被整合在一起。通过互联网在全球范围内传播，Usenet 新闻组消息为具有共同兴趣的人们提供了一个形成在线社区的手段，以讨论事件、解决问题、相互提供支持，以及进行普通的社交和娱乐活动。

我们天生就是高度社交和富有创造力的动物，因此我们总是在寻找新的沟通方式。计算机首次连接起来后不久，人们就认识到这些互连提供了将人们联系起来的手段。使用计算机创建一个 *在线社区* 的愿望导致了 Usenet 在二十多年前被创造出来。

## Usenet 历史

与几乎所有与网络相关的事物一样，Usenet 的起点非常简陋。1979 年，Tom Truscott 是北卡罗来纳州杜克大学的学生，那个夏天他在贝尔实验室实习，UNIX 操作系统就是在这里诞生的。他非常喜欢这段经历，以至于当他秋天回到学校时，他怀念贝尔实验室密集的 UNIX 环境。他使用 *Unix-to-Unix Copy Protocol (UUCP)* 将信息从他的本地机器发送到其他机器，反之亦然，包括建立回贝尔实验室的电子连接。

建立在这样一个想法的基础上，Truscott 和他的杜克同学 Jim Ellis 与杜克大学和附近的北卡罗来纳大学教堂山分校（UNC）的 UNIX 热衷者合作，共同发展在线社区的想法。目标是创建一个系统，让学生可以使用 UNIX 编写和阅读消息，以便他们能够获得技术帮助并保持社交联系。他们根据一个类比于对所有连接系统用户开放的在线新闻简报来设计这个系统。为了共享信息，消息被发布到 *新闻组* 中，任何用户都可以访问这些消息来阅读和回复。

杜克大学和 UNC 的早期工作导致了最初的消息格式和该系统最早版本软件的开发，这些软件既被称为 *网络新闻（net news）*，也被称为 *Usenet*（*User's network* 的缩写）。最初，该系统只有两台计算机，共享一对不同新闻组中发布的消息。然而，系统的价值立即得到了认可，很快就有许多新的站点被添加到系统中。这些站点被组织成一个结构，以便使用直接的 UUCP 连接有效地传递消息。用于传递新闻文章的软件也继续发展，变得更加功能强大，阅读和编写文章的软件也是如此。

新闻组本身也随着时间的推移而发生了变化。许多新的新闻组被创建，并定义了一个分层结构来帮助以有意义的方式组织新闻组。随着更多站点和用户加入 Usenet，识别出了更多兴趣领域。如今，Usenet 新闻组数量惊人：超过 100,000 个。虽然其中许多组未被使用，但成千上万的活跃组讨论了几乎所有可以想象的主题——从太空探索到烹饪，从生物化学到 PC 故障排除，再到养马。还有一些针对特定地区的区域新闻组；例如，有一组新闻组用于讨论加拿大的事件，另一组用于讨论纽约地区的事件，等等。

## Usenet 运作和特点

Usenet 始于一个用户编写要分发的消息。在消息被“发布”到 TCP/IP 网络组之后，它被存储在该用户的本地新闻服务器上，并且特殊的软件会将它的副本发送到其他连接的新闻服务器。消息最终在世界范围内传播，任何选择阅读 TCP/IP 网络新闻组的任何人都可以看到这条消息。

Usenet 真正的力量在于，在阅读一条消息后，任何用户都可以在同一新闻组中对此做出回应。就像原始消息一样，回复会传播到每个连接的系统，包括原始消息作者的使用的系统。这使得 Usenet 在分享关于最近发生的事情的信息、进行社交讨论以及特别是在解决技术故障或寻求饮食计划帮助等问题上非常有用。

Usenet 特别有趣的地方在于，它根本不是一种形式化的系统，也不基于任何正式定义的标准。它是系统完全按即兴方式发展的一个经典例子：软件被创建，人们开始使用它，软件被改进，然后事情就从这个基础上发展起来。已经编写了一些标准来规范 Usenet 的工作方式——例如 RFC 1036，它描述了 Usenet 的消息格式——但这些更多地作为历史文件，而不是规范性标准。

同样，没有中央权威机构负责 Usenet 的运作，尽管新用户常常认为有一个。与拨号公告板系统或基于网络的论坛不同，Usenet 仅仅是通过站点之间的合作来运作的；没有负责人。因此，Usenet 有时被称为无政府状态，但这并不准确。并不是说没有规则。参与系统的管理者负责做出政策决定，例如支持哪些新闻组。系统也有一定的独裁性质，只有某些人（通常是系统管理员）可以决定是否创建某些类型的新闻组。系统还有社会主义元素，即机器所有者被期望相互分享消息。因此，简化的政治标签实际上并不适用于 Usenet。

每个社区都有一种*文化*，在线社区也是如此，包括 Usenet。有一个整体文化规定了在 Usenet 上可接受的行为，还有成千上万的新闻组特定文化，这些文化在多年的参与者写作中逐渐发展起来。甚至还有专门解释 Usenet 本身如何运作的新闻组，在那里你可以了解*新手*（新用户）、*网络礼仪*（发布消息的礼仪规则）和相关主题。

## Usenet 传输方法

正如我之前所说的，Usenet 消息最初是通过 UUCP 传输的，UUCP 是为了让 UNIX 系统直接通信而创建的，通常使用电话线。多年来，所有 Usenet 消息都是通过计算机化的电话从一台机器发送到另一台机器（就像电子邮件曾经一样）。每个加入网络的计算机都会连接到已加入 Usenet 的计算机，并定期接收来自它的消息流。该计算机的所有者必须同意向其他计算机提供消息。

20 世纪 80 年代开发 TCP/IP 以及互联网发展到一定规模和范围后，开始使用它来传递 Usenet 消息而不是 UUCP 是有意义的。*网络新闻传输协议（NNTP）*专门开发出来，用于描述在传输控制协议（TCP）上传递 Usenet 消息的机制。它于 1986 年正式定义在 RFC 977 中发布，NNTP 扩展在 2000 年 10 月发布的 RFC 2980 中描述。

多年来，Usenet 使用 NNTP 和 UUCP 两种方式传递信息，但现在 NNTP 是用于绝大多数 Usenet 流量的机制，因此也是我讨论 Usenet 时的主要焦点。NNTP 不仅用于将 Usenet 文章分发到各个服务器，还用于其他客户端操作，如发布和阅读消息。因此，它在 Usenet 消息通信的大部分步骤中都被使用。

### 注意

*许多人常常将整个 Usenet 系统等同于用于在互联网上传递 Usenet 消息的 NNTP 协议。然而，它们并不相同；Usenet 早于 NNTP，NNTP 仅仅是一个用于传递 Usenet 消息的协议。*

正是因为 NNTP 和互联网在当今 Usenet 中传递信息中的关键作用，这些概念常常被混淆。然而，记住这一点是至关重要的：Usenet 并不指代任何类型的物理网络或互连技术；相反，它是一个用户的逻辑网络。这个逻辑网络已经从 UUCP 数据传输演变为 NNTP 和 TCP/IP，但 Usenet 本身并没有改变。

现在，Usenet 面临着来自许多其他群组消息应用和协议的竞争，包括基于 Web 的公告板系统和聊天室。然而，经过 25 年的时间，Usenet 已经确立了自己，并且每天都有数百万人在使用它。虽然对一些人来说，主要基于文本的媒介看起来过时，但它仍然是全球群组通信的主要支柱，并且在未来许多年里可能会继续如此。

### 提示

**关键概念** 最早的在线电子社区之一是在 1979 年由希望保持联系并分享新闻和其他信息的大学学生建立的。今天，*Usenet（用户网络）*，也称为 *网络新闻*，已经发展成为一个覆盖全球的逻辑网络。通过在 Usenet 新闻组中发布消息，人们可以在各种感兴趣的主题上共享信息。Usenet 最初是以在参与主机之间建立直接连接的形式实现的。今天，互联网是消息传输的工具。

# Usenet 通信模型

当杜克大学的学生决定创建他们的在线社区时，电子邮件已经被广泛使用，并且有许多邮件列表在运行。在这些互联网之前的年代，电子邮件通常使用 UUCP 传输——这是 Usenet 设计要采用的方法。那么为什么不简单地使用电子邮件在站点之间进行通信呢？

主要原因是电子邮件并未设计用于促进创建一个可以轻松在群组中共享信息的在线社区。在这方面，电子邮件的主要问题是只有被指定为消息接收者的个人才能阅读它。没有一种设施可以让某人撰写消息并将其放置在公开的地方供任何人阅读，类似于在公共场所张贴通讯稿。

在大型群组中，电子邮件的另一个问题与效率相关。考虑一下，如果你将 1,000 人列入邮件列表，发送给该列表的每条消息都必须复制并交付 1,000 次。早期的网络在带宽和资源方面有限，因此使用电子邮件进行大规模的群组通信是可能的，但远非理想。

### 小贴士

**关键概念** 虽然电子邮件可以用于群组通信，但它有两个重要的限制。首先，必须将消息专门发送给每个接收者，这使得公共消息传递变得不可能。其次，每个接收者都需要接收消息的单独副本，因此向多个接收者发送消息需要使用大量的资源。

## Usenet 的公共分发导向

为了避免使用电子邮件进行群组消息传递的问题，Usenet 采用了一种与电子邮件截然不同的通信和消息处理模型。Usenet 通信模型与电子邮件模型之间的主要区别在于，Usenet 的消息处理是以 *公共分发* 的概念为中心，而不是向单个用户进行私人投递。这影响了 Usenet 通信的各个方面，如下所述：

**地址** 消息不是从发送者指向任何特定的接收者或接收者组，而是指向一个 *群组*，该群组与新闻组名称相对应。

**存储** 消息不是存储在个人邮箱中，而是在服务器上的一个中央位置，任何服务器用户都可以访问它们。

**交付** 消息并非从发送者的系统传递到接收者的系统，而是通过互联网传播到所有连接的系统，因此任何人都可以阅读它们。

## Usenet 通信过程

为了更详细地说明 Usenet 通信的工作原理，让我们看看撰写、传输和阅读典型 Usenet 消息（也称为 *文章*——这两个术语可以互换使用）所涉及的步骤。假设这个过程从用户 Ellen 在 newsgroup misc.rural 上发布一个关于生病的马匹求助请求开始。由于她是发布消息的人，因此她会被认为是消息的 *发布者*。简化地说，这个过程（如图 85-1 通信模型 此图说明了在现代 Usenet 上使用 NNTP 创建、传播和阅读消息的方法；在某些方面与第七十四章中的电子邮件模型图（图 74-1）相似。在这个例子中，消息由发布者 Ellen 创建，并由读者 Jane 阅读。这个过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，该消息从本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他 NNTP 服务器接收该消息，包括来自 Jane 本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并阅读该消息。Jane 可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及成千上万的其他读者，此处未显示）") 的步骤如下：

1.  **文章撰写** Ellen 首先创建一个 Usenet 文章，该文章的结构符合 Usenet 所需的特殊消息格式。这条消息与电子邮件消息类似，因为它有一个 *标题* 和一个 *正文*。正文包含要发送的实际消息，而标题包含描述消息并控制其传递方式的标题行。例如，一条重要的标题行指定了文章针对哪个新闻组。

1.  **文章发布和本地存储** 在完成她的文章后，Ellen 将文章提交到 Usenet，这个过程称为 *发布*。Ellen 电脑上的客户端软件程序将 Ellen 的消息传输到她的本地 Usenet 服务器。该消息存储在该服务器上适当文件存储区域。现在，所有决定阅读 misc.rural 的该服务器用户都可以立即访问它。

1.  **文章传播** 到目前为止，Ellen 的本地服务器是唯一拥有她消息副本的服务器。文章必须发送到其他网站，这个过程称为 *分发*，或者更常见的是，*传播*。Ellen 的消息从她的本地 Usenet 服务器传播到她直接连接的其他服务器。然后，这些服务器将其传播到它们连接的其他服务器，依此类推，直到所有想要该消息的 Usenet 服务器都有其副本。

1.  **文章访问和检索** 由于 Usenet 文章存储在中央服务器上，为了阅读它们，必须在服务器上访问。这通过使用 Usenet *新闻阅读器* 程序来完成。例如，名为 Jane 的其他 misc.rural 阅读者可能会访问该组并找到 Ellen 的消息。如果 Jane 能够帮助 Ellen，她可以通过发布自己的文章来回复 Ellen。这样，文章就会传播回 Ellen 的服务器，在那里她可以阅读并回复。所有其他 *misc.rural* 的读者也可以随时加入对话，这也是 Usenet 对群体沟通非常有用的原因。

![Usenet (网络新闻) 通信模型 此图说明了使用现代 Usenet 上的 NNTP 创建、传播和读取消息的方法；在某些方面与电子邮件模型图（见 ）相似。在这个例子中，消息是由发布者 Ellen 创建并由阅读者 Jane 读取的。这个过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，从该本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他 NNTP 服务器接收消息，包括 Jane 本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并读取消息。Jane 可以回复消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及也回到成千上万的其他读者，此处未显示）](http://atomoreilly.com/source/nostarch/images/288317.png.jpg)

图 85-1. Usenet（网络新闻）通信模型 此图说明了在现代 Usenet 上使用 NNTP 创建、传播和读取消息的方法；在某些方面与第七十四章中的电子邮件模型图（图 74-1 相似（第七十四章)。在这个例子中，消息是由发帖者 Ellen 创建并由读者 Jane 阅读的。这个过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，该本地服务器将其传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他 NNTP 服务器接收该消息，包括来自 Jane 本地服务器的上游服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并阅读该消息。Jane 可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及成千上万的其他读者，此处未显示）。

### 小贴士

**关键概念** Usenet 通信包括四个基本步骤。首先，消息被编写并发布到发件人的本地服务器。第三步是传播，其中消息从原始服务器传输到 Usenet 系统上的其他服务器。过程的最后一步是文章检索，其中新闻组的其他成员访问并阅读该文章。网络新闻传输协议（NNTP）是用于将 Usenet 文章从一个主机移动到下一个主机的技术。

## 消息传播与服务器组织

传播无疑是 Usenet 通信过程中最复杂的一部分。在过去，使用 UUCP 进行传播。每个 Usenet 服务器都会被编程为定期拨号连接到另一个服务器，并将自上次连接以来收到的所有新文章发送给它。文章会从一台服务器“泛滥”到另一台服务器。这既耗时又低效，而且之所以能工作，仅仅是因为文章的数量相对较少。

正如我在上一节中提到的，在现代 Usenet 中，NNTP 用于设备之间传输消息的所有阶段。文章是通过客户端机器和本地服务器之间的 NNTP 连接发布的，然后本地服务器使用相同的协议将文章传播到其他相邻的 NNTP 服务器。客户端新闻阅读软件也使用 NNTP 从服务器检索消息。

NNTP 服务器通常按照某种等级结构排列，最大的和最快的服务器为下游的较小服务器提供服务。根据连接的安排方式，一个 NNTP 服务器可能会立即与上游服务器建立连接，以便发送新发布的文章到其他 Usenet 服务器进行分发，或者服务器可能会被动等待上游服务器的连接来询问是否有新文章需要发送。在现代互联网的速度下，文章从一个服务器传播到另一个服务器通常只需要几分钟（或几秒钟），即使是在跨越大陆的情况下。

还可以限制 Usenet 消息的传播，这是一种常用于仅在特定地区或系统上相关的讨论的技术。讨论农村问题，如马匹，具有普遍兴趣，Ellen 可能在世界上任何地方都能找到帮助，因此她的消息的全球传播是有意义的。然而，如果 Ellen 住在波士顿地区，并且对了解一家好当地餐厅的位置感兴趣，那么只在本地区域发布查询到*ne.food*（新英格兰食品讨论）将更有意义。还有一些公司使用 Usenet 提供“内部”新闻组，这些新闻组根本不会从本地服务器传播出去。然而，由于现在许多新闻提供商都是全国性或国际性的，限制消息的传播在很大程度上已经不再流行。

## Usenet 寻址：新闻组

Usenet 通信中的一个关键概念是*新闻组*。新闻组是 Usenet 的寻址机制，将 Usenet 文章发送到新闻组相当于将电子邮件发送到电子邮件地址。新闻组类似于其他群组通信场所，如邮件列表、聊天室、互联网中继聊天（IRC）频道或公告板系统（BBS）论坛（尽管将新闻组称为*列表*、*房间*、*频道*或*BBS*可能会引起 Usenet 老用户的负面反应！）。

与任何寻址机制一样，新闻组必须是唯一可识别的。每个新闻组都有一个*新闻组名称*，它描述了新闻组的话题并将其与其他新闻组区分开来。由于有数以千计的不同新闻组，它们被组织成称为*等级结构*的集合。每个等级结构包含一个相关新闻组的树状结构。

### Usenet 新闻组等级结构

新 sggroup 层级的总体集合在许多方面类似于域名系统（DNS）中使用的域名树结构。每个 Usenet 层级就像 DNS 顶级域名内的所有域名的集合。就像域名 [www.pcguide.com](http://www.pcguide.com/) 是通过将顶级域名标签 *.com* 添加到二级域名 *pcguide* 和子域名 *www* 来形成的，新 sggroup 名称也是以同样的方式创建的。它们是从顶级新 sggroup 层级名称创建的，然后附加一组描述性标签，这些标签描述了新 sggroup 在层级中的位置。

DNS 和 Usenet 层级之间的一个区别是，虽然 DNS 名称是从右到左创建的，但 Usenet 新 sggroup 名称是以更自然的（对于英语使用者来说）从左到右的顺序创建的。例如，主要的 Usenet 层级之一是 *comp* 层级，致力于计算机主题。在 comp 中有一个关于数据通信的子层级称为 *dcom*，在其中有一个讨论数据布线的组。这个组被称为 comp.dcom.cabling。几乎所有的新 sggroup 都是按照这种方式组织的。

### “八大”新 sgroup 层级

Usenet 分散性质的一个问题是确保在某些我们希望每个人都处于同一页面的领域中的协调，其中之一就是新 sgroup 命名。如果我们让任何人都可以创建新 sgroup，我们可能会得到许多讨论相同主题的组。想象一下，如果有人对数据布线有疑问，但没有意识到 comp.dcom.cabling 存在，所以他创建了一个名为 comp.datacomm.cabling 的新组。这两个组可以共存，但这会导致对这个主题感兴趣的人群的混淆和碎片化。

为了避免新 sggroup 创建的问题，大型 Usenet 系统的管理员合作制定了一个系统，将许多常用的 Usenet 组组织成八个层级，并制定了一个在它们内部创建新新 sggroup 的特定程序。今天，这些被称为 *Big Eight* Usenet 层级，总结在 表 85-1 中。

表 85-1. Usenet 八大新 sgroup 层级

| Hierarchy | 描述 |
| --- | --- |
| comp.* | 讨论与计算机相关主题的新 sggroup，包括硬件、软件、操作系统和技术 |
| humanities.* | 讨论人文学科的新 sgroup，例如文学和艺术 |
| misc.* | 讨论不适合其他八大类别的杂项主题的新 sgroup |
| news.* | 讨论 Usenet 本身及其管理的新 sgroup |
| rec.* | 讨论休闲主题的新 sgroup，例如游戏、体育和活动 |
| sci.* | 科学新 sgroup，涵盖特定领域，如物理学和化学，研究主题等 |
| soc.* | 社会和社会讨论，包括特定文化的组 |
| talk.* | 主要围绕当前事件和事件讨论和辩论的新闻组 |

这八个层级包含了 Usenet 上今天使用最广泛的许多组。例如，职业棒球在 rec.sport.baseball 中讨论，英特尔电脑在 comp.sys.intel 中讨论，中东政治在 talk.politics.mideast 中讨论。

大八层级在结构和包含的新闻组方面控制得相当严格。创建一个新的大八新闻组的过程是民主和开放的。任何人都可以提议一个新的组，如果有足够的支持，它将由同意遵循大八系统的合作系统管理员创建。然而，这个过程相当复杂且耗时。有些人认为这是不可接受的，甚至反对整个限制性过程的观念。其他人认为这个系统有利，因为它通过减缓现有新闻组和新增组数量的变化速度，使大八层级相对有序。

### Alt 和其他新闻组层级

对于那些更喜欢更自由的环境，并且不想服从大八程序的人来说，有一个替代的 Usenet 层级，它以层级名称 *alt* 开头。这个层级包括成千上万的组。其中一些相当受欢迎，但许多根本未被使用；这是 alt 组创建相对容易的副作用。

除了这九个层级之外，还有数十个额外的、较小的层级。其中许多是地区性的，甚至是公司特定的。例如，*ne.* 层级包含了一组讨论与新英格兰相关问题的新闻组；*fr.* 覆盖法国，而 *de.* 则与德国相关。微软在其 *microsoft.** 层级下有自己的公共新闻组。图 85-2 展示了大八层级和一些其他存在的层级。

![Usenet 新闻组层次结构 Usenet 新闻组被组织成称为层次结构的树状结构。其中八个是集中式、广泛使用的通用层次结构，今天被称为“八大”。替代（alt）层次结构是一组非常松散的结构，包含数千个覆盖所有可想象话题的组。除此之外，还有许多地区性、私人性和特殊用途的层次结构。](img/httpatomoreillycomsourcenostarchimages288319.png.jpg)

图 85-2. Usenet 新闻组层次结构 Usenet 新闻组被组织成称为层次结构的树状结构。其中八个是集中式、广泛使用的通用层次结构，今天被称为“八大”。替代（alt）层次结构是一组非常松散的结构，包含数千个覆盖所有可想象话题的组。除此之外，还有许多地区性、私人性和特殊用途的层次结构。

### 小贴士

**关键概念** Usenet 消息不是针对单个用户的；相反，它们被发布到新闻组。每个新闻组代表一个主题。对组中主题感兴趣的人可以阅读其中的消息并回复它们。Usenet 新闻组被组织成类似 DNS 域结构的树状层次结构。许多最广泛使用的新闻组都位于一个名为“八大”的通用兴趣层次结构集合中。替代（alt）层次结构为“八大”提供了一个替代方案。还有许多地区性和特殊用途的层次结构。

### 未监管和监管新闻组

大多数新闻组对所有用户开放，被称为 *未监管*，因为发送给它们的消息会直接发送到整个 Usenet 服务器互联网。相比之下，只有一小部分新闻组是 *监管* 的，这意味着发送给组的所有消息都会被筛选，只有经过版主（或版主团队）批准的消息才会真正发布。

监管组的目的是确保特定组内的讨论保持主题相关。它们通常被创建来处理有争议的话题，以确保辩论保持建设性，避免破坏。例如，rec.guns 是监管的，以确保讨论集中在枪支的使用上，而不是无休止地围绕枪支控制等政治争论（这在 talk.politics.guns 中有位置）。监管组有时也用于仅用于公告的专业组，或内容受限的组。例如，rec.food.recipes 是监管的，这样它就只包含食谱和食谱请求，这有助于人们轻松找到食谱，而无需浏览大量讨论。最后，当一些破坏性元素选择在未监管的新闻组中发布大量内容，使得正常讨论变得困难时，有时会创建未监管组的监管版本。

### 在多个新闻组中交叉发布

一篇文章可以发布到多个新闻组。这个过程称为*跨发帖*，当一条消息涉及两个主题或允许发送者触及更广泛的受众时使用。例如，如果你住在西雅图地区，并且你的房子有问题，你可能会合法地跨发帖到*seattle.general*和*misc.consumers.house*。

跨发帖比独立向每个组发送相同消息更有效率，原因有两个：

+   每个 Usenet 服务器上只会存储消息的一个副本，而不是两个。

+   同时阅读这两个组的 Usenet 参与者不会看到消息两次。

然而，向大量新闻组进行跨发帖通常被认为是有破坏性的，并且违反了 Usenet 礼仪。

# Usenet 消息格式和特殊标题

Usenet 被设计成允许用户以消息的形式交换信息，这些消息是从一台计算机发送到另一台计算机的。与任何基于消息的网络应用程序一样，所有 Usenet 客户端软件和服务器软件都同意使用一个共同的*消息格式*。这确保了所有设备和程序都能以一致的方式解释所有 Usenet 文章。

虽然 Usenet 最初被创建为电子邮件的替代品，并且显然在处理消息的方式上存在差异，但也有许多相似之处。两者都是面向文本的消息系统，具有类似的内容和控件信息沟通需求。Usenet 的创建者意识到，基于电子邮件格式而不是从头开始创建新格式，将 Usenet 消息格式建立在电子邮件格式上会有许多优势。电子邮件消息格式已经被广泛使用，为 Usenet 采用它将节省实施时间和精力。它还将增强电子邮件和 Usenet 消息之间的兼容性，使得设计用于处理或显示电子邮件的软件也能与 Usenet 文章一起工作。因此，Usenet 消息格式是基于电子邮件消息的 RFC 822 标准定义的（在第七十六章中介绍）。

RFC 822 消息以一组*标题*开始，包含有关消息的控制和描述性信息，然后是一个空行，接着是消息的*主体*，其中包含实际内容。

RFC 822 标准的一个重要属性是能够定义自定义标题，这些标题补充了标准本身定义的常规标题集。Usenet 文章需要一些电子邮件不需要的信息，这些信息可以通过特别定义的标题包含在内，同时仍然遵循基本的 RFC 822 格式。同时，对于 Usenet 不需要的特定于电子邮件的标题可以省略。因此，Usenet 文章和电子邮件消息之间没有任何结构上的差异。它们之间的区别仅在于包含的标题类型和这些标题的值。例如，Usenet 消息将始终包含一个指定文章要发布的新闻组的标题，但不会像电子邮件消息那样带有“收件人：”行。

### 提示

**关键概念** Usenet 文章使用与电子邮件消息相同的 RFC 822 消息格式。Usenet 文章和电子邮件消息之间的唯一区别在于每个中使用的标题类型和值。

## Usenet 标题分类和常见标题

所有 Usenet 标题都是根据 RFC 822 标准中指定的标准标题格式定义的：<*标题名称*>: <*标题值*>。与电子邮件消息一样，标题可以扩展到多行，按照 RFC 822 标准中描述的缩进程序进行。

当前 Usenet 消息标准，RFC 1036，描述了 Usenet 消息的标题类型。标题分为两类：*强制性标题*（见表 85-2 中。

表 85-4. 常见的附加 Usenet 标题

| 标题名称 | 描述 |
| --- | --- |
| NNTP-Posting-Host: | 指定最初发布消息的主机的 IP 地址或 DNS 域名。这通常是作者用于发布消息的客户端地址或发送者的本地 NNTP 服务器。 |
| User-Agent: (或) X-Newsreader: | 用于发布消息的软件的名称和版本号。 |
| X-Trace: | 提供可用于跟踪消息的附加信息。 |
| X-Complaints-To: | 用于报告滥用信息的电子邮件地址。此标题现在由许多 ISP 自动包含。 |

## Usenet MIME 消息

由于 Usenet 遵循 RFC 822 标准，多用途互联网邮件扩展（MIME）可以用于格式化 Usenet 消息。当这样做时，您将在消息中看到通常的 MIME 标题（如 MIME-Version、Content-Type 等）。

注意，在 Usenet 消息中使用 MIME 存在一些争议。一些新闻阅读器不遵守 MIME 规范，在尝试显示这些消息时会变得混乱，许多 Usenet 老手反对在 Usenet 消息中使用除纯文本之外的内容。尽管如此，MIME 消息正在变得越来越普遍，无论是好是坏。

# NNTP 概述和一般操作

正如我在本章前面解释的那样，Usenet 最初是一个非正式的 UNIX 计算机网络，使用拨号 UUCP 连接在服务器之间传输消息。这种安排是出于必要性，并且工作相当不错，尽管它存在一些问题。20 世纪 80 年代，随着互联网的广泛使用，它为更有效地分发 Usenet 文章提供了理想的机会。NNTP 被开发为一种特殊的 TCP/IP 协议，用于发送这些消息。现在，NNTP 每天从一台计算机传输数十亿份 Usenet 消息到另一台计算机。

### 提示

**背景信息** *NNTP 在许多方面与简单邮件传输协议（SMTP）相似，包括其基本操作、命令集和回复格式。如果您熟悉 SMTP，可能会发现 NNTP 的信息更容易理解，SMTP 在第七十七章")中有介绍。*

Usenet 最初是一个*逻辑*的互连主机网络，它们直接相互联系。在早期的 Usenet 中，用户会将消息发布到她的本地服务器，消息将保留在那里，直到该服务器被另一个服务器联系或联系另一个服务器。然后，消息将被转移到新服务器，在那里它将保留，直到第二个服务器联系第三个服务器，依此类推。这种传输机制是有效的，但在许多方面存在严重缺陷。

服务器并不是持续连接在一起的；它们只能通过使用模拟调制解调器打电话来相互通信。因此，消息往往需要几个小时才能传播。那时的调制解调器按照今天的标准也非常慢——每秒 2400 比特或更少——所以从一个服务器复制消息到另一个服务器需要很长时间。最糟糕的是，除非两个站点在同一座城市，否则这些电话是长途电话，使得它们相当昂贵。

尽管存在所有这些问题，为什么还要使用这个系统？答案是简单，因为没有替代方案。在 20 世纪 70 年代末和 80 年代初，没有我们现在所知道的互联网，也没有其他物理基础设施存在来连接 Usenet 站点。要么通过电话线使用 UUCP，要么什么也不做。

随着新兴的 ARPAnet 成长为现代互联网，这一切都发生了变化。随着互联网的扩展，越来越多的站点连接到它，包括许多参与 Usenet 的站点。一旦交换中的两个站点都连接到互联网，使用互联网发送 Usenet 文章而不是依赖缓慢、昂贵的电话通话就变得很容易了。随着时间的推移，越来越多的 Usenet 站点加入了互联网，很明显，正如电子邮件从 UUCP 迁移到 TCP/IP 互联网一样，Usenet 的未来也在互联网上。

Usenet 从 UUCP 连接转移到 TCP/IP 互联网意味着需要重新思考如何将 Usenet 文章从服务器移动到服务器。在互联网上，Usenet 只是众多应用之一，消息的传输必须使用 TCP 或用户数据报协议（UDP）进行结构化。因此，就像其他应用一样，Usenet 需要一个应用层协议来描述如何在 TCP/IP 上传输 Usenet 流量。正如 Usenet 从电子邮件的 RFC 822 借用其消息格式一样，将其消息交付协议建模在电子邮件使用的协议（SMTP）上是有意义的。结果是 1986 年 2 月发布的 RFC 977 中 NNTP 的创建。

NNTP 的一般操作确实与 SMTP 非常相似。NNTP 使用 TCP，服务器在众所周知的 TCP 端口 119 上监听传入的连接，无论是来自客户端主机还是其他 NNTP 服务器。在 SMTP 中，当两个服务器使用 NNTP 进行通信时，发起连接的那个服务器在该交换中扮演客户端的角色。

连接建立后，通信以客户端发送给服务器的命令和从服务器返回给客户端设备的回复的形式进行。NNTP 命令以纯 ASCII 文本的形式发送，就像 SMTP、文件传输协议（FTP）、超文本传输协议（HTTP）和其他协议使用的文本一样。NNTP 响应以三位回复代码以及描述性文本的形式，同样就像 SMTP（它反过来又从 FTP 借用了这个概念）。

NNTP 被设计成一种用于传输 Usenet 消息的全面工具。它通常被视为一种将 Usenet 文章从一个服务器传输到另一个服务器的交付协议，但它也被用于客户端主机到 Usenet 服务器的连接，用于发布和阅读消息。因此，NNTP 命令集相当广泛，包括处理服务器之间以及客户端和服务器之间通信的命令。对于消息传播，一组命令允许服务器从一个服务器请求新文章或将新文章发送到另一个服务器。对于消息发布和访问，命令允许客户端请求新新闻组和消息的列表，并检索消息以供用户显示。

在 RFC 977 中定义的命令在十多年内是唯一的官方命令。然而，甚至在 20 世纪 80 年代末，NNTP 服务器和客户端软件的实现者就已经开始添加新的命令和功能，使 NNTP 更加高效，对用户更有用。这些*NNTP 扩展*最终在 2000 年发布的 RFC 2980 中被记录下来。我将在本章后面的“NNTP 命令和命令扩展”部分更详细地描述它们。

### 小贴士

**关键概念** 网络新闻传输协议（NNTP）是现代 Usenet 中实现消息通信的协议。它用于两个主要目的：在 NNTP 服务器之间传播消息，并允许 NNTP 客户端发布和阅读文章。它是一个独立的协议，但与电子邮件的简单邮件传输协议（SMTP）有许多相似之处。

NNTP 在现代 Usenet 通信过程中的所有传输步骤中都被使用。然而，NNTP 最常与 Usenet 文章的*传播*过程相关联。这可以说是 NNTP 最重要的功能：提供一种高效的方式，将大量 Usenet 文章从一个服务器传输到另一个服务器。因此，从协议的角度来看，这是一个合理的起点。

# NNTP 服务器间通信过程：新闻文章传播

要理解 NNTP 传播是如何工作的，我们必须首先看看现代 Usenet 网络本身的组织方式。现在，所有的 Usenet 站点都在互联网上，理论上，任何 NNTP 服务器都可以联系任何其他服务器来发送和接收 Usenet 文章。然而，如果要将一篇文章提交给特定的服务器，需要通过单独的 NNTP 连接发送到每个其他 NNTP 服务器，这将是荒谬的。因此，即使在互联网时代，Usenet 的逻辑网络仍然非常重要。

## Usenet 服务器结构

理论上，对 Usenet 结构的要求只是每个站点以某种形式至少连接到另一个站点。逻辑网络可以是无形的，甚至没有任何正式的结构，只要每个站点都能通过一系列中间服务器形成一条路径，相互连接。然而，现代 Usenet 非常庞大，每天都有成千上万的服务器和数以千计的文章被发布。这需要一种更组织化的结构来分发新闻。

因此，现代 Usenet 逻辑网络在结构上松散地分层。一些大型互联网服务提供商（ISP）和拥有高速互联网连接和大容量服务器的公司被认为是分层结构的顶层，有时被称为 Usenet 的*骨干网*。较小的组织连接到这些大型组织运行的服务器；这些组织被认为是骨干组的*下游*。反过来，更小的组织可能从连接到大型组织的那些组织进一步下游连接。

这种分层结构意味着大多数 Usenet 服务器只与其上游邻居以及它们提供服务的任何下游站点保持直接连接。服务器从其上游连接接收所谓的*新闻源*，因为那里是它将接收大部分新闻文章的地方。然后，它将其新闻源提供给其下游的所有服务器。我在图 85-1 通信模型 此图说明了在现代 Usenet 上使用 NNTP 创建、传播和读取消息的方法；在某些方面与第七十四章中的电子邮件模型图（图 74-1）相似。在这个例子中，消息由发件人 Ellen 创建并由读者 Jane 读取。过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，从该本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到互联网。其他 NNTP 服务器接收该消息，包括 Jane 的本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并读取该消息。Jane 可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及也回到成千上万的其他读者，此处未显示）")中展示了这种结构。

例如，假设公司 A 运行了一个名为 Largenews 的大型 Usenet 服务器，该服务器连接到主干网。从该服务器下游是 Mediumnews NNTP 服务器。该服务器为名为 Smallnews 的服务器提供服务。如果一个用户向 Mediumnews 发布文章，它将立即被放置在该服务器上。该服务器将文章向下发送到 Smallnews，以便该服务器的用户可以阅读。Mediumnews 还会在某个时候将文章发送到 Largenews。从 Largenews 出发，消息将被分发到其他主干站点，然后这些站点将消息传递到它们自己的下游站点。这样，所有站点最终都会收到消息的副本，尽管 Mediumnews 只需要直接连接到两个其他服务器。

用以描述使用 NNTP 传播新闻的术语是 *洪水传播*。这是因为消息从一个服务器开始，并从该服务器向外传播，最终到达主干站点，然后沿着所有下游的“河流”传播到 Usenet 上的每个站点。

尽管我把 Usenet 网络的逻辑结构描述为层次结构，但它并不是一个严格的层次结构。为了冗余，许多 NNTP 服务器维护与多个其他服务器的连接，以确保新闻能够快速传播。可以通过查看消息 ID 来控制文章的传输，以避免一个服务器从多个邻居那里同时接收到的消息重复。

## 基本 NNTP 传播方法

现在，让我们看看使用 NNTP 在服务器之间实际传播消息的方式。有两种技术可以实现这一点：

+   在 *推送模型* 中，一旦服务器收到新消息，它立即通知其上游和下游邻居关于该消息的信息，并询问他们是否想要一份副本。

+   在 *拉模型* 中，服务器不会向其邻居提供新文章。如果邻居服务器想要查看自上次连接建立以来到达了什么内容，它们必须请求新消息列表，然后请求将新消息发送给它们。

这两种技术都有优点和缺点，但推送是目前最常用的模型。

### 小贴士

**关键概念** NNTP 扮演的一个重要角色是在 Usenet 服务器之间传播文章，这使得整个系统成为可能。用于文章传播有两种模型：推送模型，其中接收新消息的服务器立即将其提供给连接的服务器，以及拉模型，其中接收新消息的服务器在收到其他服务器的请求之前保留它们。推送模型通常更受欢迎，因为它允许系统内更快地传递消息。

### 使用推送模型进行文章传播

使用推送模型，当 NNTP 服务器的管理员与上游 Usenet 服务提供商建立服务关系时，他们向提供商提供一份下游服务器希望携带的新组列表。每当该列表中的某个组上游服务器收到新文章时，它会自动发送到下游站点。这使下游服务器不必不断询问是否有新内容到达。

在 RFC 977 中定义的经典 NNTP 协议中，文章的交换基于推送模型，并使用 IHAVE 命令执行。回到上一节中的例子，假设有三条新消息到达 Largenews 服务器。它将建立一个到 Mediumnews 服务器的 NNTP 连接，并使用 IHAVE 命令逐个提供三条新消息的消息 ID。（NNTP 命令将在本章后面描述。）Mediumnews 服务器将对每一条消息做出回应，表明它是否已经拥有该消息。如果没有，Largenews 将发送该消息。使用推送模型传播文章的事务示例在图 85-3 中展示。

![使用推送模型传播 NNTP 文章 本例展示了 Usenet 文章是如何在服务器之间使用传统的推送模型进行移动的。在这里，作为 NNTP 客户端（实际上可能是 NNTP 服务器）的设备有两个消息可供服务器使用。它发送 IHAVE 命令指定第一条消息的消息 ID，但服务器已经有了这条消息，因此发送了一个 435（不要发送）回复。客户端随后发出一个带有第二条消息 ID 的 IHAVE 命令。服务器想要这条消息，因此发送了一个 335 回复。客户端发送 Usenet 消息，以单独一行上的单个句号结束。服务器表明它已收到消息，客户端完成其事务后，退出会话。](img/httpatomoreillycomsourcenostarchimages288321.png.jpg)

图 85-3. 使用推送模型进行 NNTP 文章传播 此示例展示了 Usenet 文章是如何在服务器之间使用传统的推送模型进行传播的。在这里，作为 NNTP 客户端的设备（实际上可能是 NNTP 服务器）有两个消息可供服务器使用。它发送 IHAVE 命令，指定第一条消息的消息 ID，但服务器已经有了这条消息，因此发送了一个 435（不要发送）回复。然后客户端发出一个带有第二条消息 ID 的 IHAVE 命令。服务器希望接收这条消息，因此发送了一个 335 回复。客户端发送 Usenet 消息，以单独一行上的单个句号结束。服务器表明它已收到消息，客户端完成交易后退出会话。

这种技术的优点是确保服务器不会收到它已经拥有的消息的重复副本。在现代 Usenet 中，它的缺点是速度慢，因为服务器必须在客户端发送消息或下一个命令之前响应 IHAVE 命令。

### 使用流模式提高传播效率

更重要的 NNTP 扩展之一是*流模式*，它改变了新闻推送的方式。（NNTP 命令扩展将在本章后面描述。）当此模式启用时，客户端机器使用 CHECK 命令而不是 IHAVE 来询问服务器是否希望接收特定的消息。服务器响应以表明是否希望接收消息；如果希望，客户端使用 TAKETHIS 命令发送消息。

CHECK/TAKETHIS 的好处是客户端在发送下一个命令之前不需要等待 CHECK 命令的回复。当客户端等待第一个 CHECK 命令的回复时，它可以做其他事情，比如发送下一个 CHECK 命令，允许命令以流的形式发送以提高效率。因此，客户端可以先发送一个 CHECK 命令用于第一条新消息，然后发送一个 CHECK 命令用于第二条，同时等待服务器对第一条消息的回复。可以发送多个 CHECK 命令流，然后为之前发送的每个 CHECK 命令发送 TAKETHIS 命令，以表明服务器希望接收该消息。

### 使用拉模型进行文章传播

拉模型是通过使用 NEWNEWS 和 ARTICLE 命令实现的。客户端连接到服务器并发送 NEWNEWS 命令，其中包含一个日期，指定客户端上次检查新消息的日期和时间。服务器响应，返回自该日期以来到达的新文章的消息 ID 集合。然后客户端使用 ARTICLE 命令请求每条新消息。

注意，推送和拉取模型可以在单个会话中结合使用。客户端可以连接到服务器，使用 NEWNEWS 检查该服务器上的新消息，然后通过 IHAVE 或 CHECK 通知服务器客户端想要发送的新消息。在实践中，一对服务器之间在特定交换中通常只使用这两种模型中的一种。

除了传播新消息外，NNTP 还用于允许服务器之间交流有关新创建的新闻组的信息。这是通过使用 NEWGROUPS 命令来完成的，该命令与 NEWNEWS 一样，指定了日期和时间。作为回应，服务器向客户端发送自指定日期和时间以来创建的新新闻组的列表。

# NNTP 客户端-服务器通信过程：新闻发布和访问

NNTP 与其前身 SMTP 的一个关键区别在于，NNTP 不仅用于服务器之间的通信。它还用于 Usenet 消息的初始发布以及阅读消息。实际上，NNTP 的大多数命令都涉及用户客户端机器与 NNTP 服务器之间的交互，而不是服务器之间的通信。

NNTP 客户端是指任何了解 NNTP 协议并设计为提供用户访问 Usenet 的软件程序。NNTP 客户端通常被称为*新闻阅读器*，它们为用户提供两个主要功能：*发布*和*阅读*Usenet 消息。Usenet 新闻阅读器几乎存在于所有硬件和软件平台上，它们在功能、用户界面和其他特性方面差异很大。如今，大多数人都在客户端计算机上使用 Usenet 新闻阅读器，这些计算机必须连接到单独的 NNTP 服务器来阅读和发布新闻。这些程序类似于电子邮件客户端，实际上，许多电子邮件客户端也充当 NNTP 客户端。

## 新闻发布、访问和阅读

发布 Usenet 消息是整个 Usenet 通信过程中的第一步（尽管许多 Usenet 文章实际上是其他文章的回复，所以这有点像鸡生蛋的问题）。使用 NNTP 发布文章非常直接。客户端建立与服务器的连接并发出 POST 命令。如果服务器愿意接受新文章，它会回复提示客户端发送文章。然后客户端将文章传输到服务器。一些新闻阅读器可能会批量处理新文章，以便在单个 NNTP 会话中发送，而不是逐个提交。

新闻阅读器也会建立一个 NNTP 连接到服务器来阅读 Usenet 文章。NNTP 提供大量命令来支持用户可能采取的各种不同的文章访问和检索操作。阅读的第一步有时是检查可用的新闻组列表。使用 LIST 命令，客户端从服务器请求可阅读和发布的新闻组列表。RFC 977 定义了基本的 LIST 命令，它将所有组列表返回给客户端。RFC 2980 定义了命令的多个扩展，允许客户端仅检索服务器上组的信息。由于今天 Usenet 新闻组的数量如此之大，通常情况下，除非用户明确请求，否则会跳过新闻组列表。

Usenet 消息访问的下一步通常是选择一个新闻组从可用的组列表中阅读。同样，由于今天有如此多的组，大多数新闻阅读器允许用户使用模式或部分名称字符串来搜索组名。然后，将带有所选组名的 GROUP 命令发送到服务器。服务器将组的第一和最后当前文章编号返回给客户端。

消息可以通过两种方式来识别：一种是绝对方式，另一种是站点特定方式。文章的消息 ID 是一个固定的标识符，可以在整个 Usenet 中唯一地表示它；这是在服务器间通信中用来确定每个站点是否有一个给定消息副本的方法。相比之下，*文章编号*是服务器特定的；它们代表那些文章到达服务器时分配的编号，并用作在新组中引用文章的简写。因此，同一消息在每个 NNTP 服务器上会有不同的文章编号。文章编号用于方便，因为它们比消息 ID 短得多。在会话期间，NNTP 服务器还维护一个当前文章指针，可以用来按顺序遍历新闻组。

## 新闻访问方法

新闻阅读器可以以多种不同的方式访问组中的消息，这取决于其编程方式和软件用户的需求。新闻访问方法包括以下内容：

**完整新闻组检索** 强制检索技术是客户端请求服务器发送该组中的所有消息。客户端发出 ARTICLE 命令以选择组中的第一条当前消息，使用 GROUP 命令返回的第一个文章编号。这会将服务器的内部会话指针设置为指向第一条文章，以便可以检索它。然后使用 NEXT 命令将指针前进到下一条消息，并使用 ARTICLE 命令检索它。这个过程一直持续到整个组都被读取。图 85-4（ch85s06.html#nntp_full_newsgroup_retrieval_process_th "图 85-4. NNTP 完整新闻组检索过程有许多方法可以让 NNTP 客户端访问和读取服务器上的 Usenet 消息。一种常见的方法是检索整个新闻组的全部内容。在这个例子中，客户端使用 GROUP 命令选择读取 comp.protocols.tcp-ip 新闻组；服务器响应 211（Group Selected）回复，其中包含有关该组的重要统计数据。客户端使用 ARTICLE 命令和组中第一条文章的编号 177，从服务器读取它。然后服务器逐行发送消息，以单行上的一个句号结束。客户端使用 NEXT 命令告诉服务器将其内部文章指针前进到下一条消息，这通常不会是刚刚读取的下一个连续编号；这里它是 179。然后客户端可以通过单独发送 ARTICLE 命令来读取那条消息。由于没有给出参数，服务器返回当前消息（179）。"）说明了这个过程。检索到的消息由新闻阅读器存储，并可供用户即时访问。这种方法最适合相对较小的新闻组以及/或拥有快速互联网连接的用户。

**新闻组标题检索** 由于下载整个新闻组耗时较长，许多新闻阅读器通过下载所有消息的标题而不是完整消息来妥协。这个过程与完整新闻组检索相同，但使用 HEAD 命令来检索仅包含文章标题。这比使用 ARTICLE 命令检索每条消息的全部内容要快。如果服务器支持，还可以使用 XHDR 命令扩展来更有效地检索消息标题的子集，例如主题行和作者。

**单篇文章检索** 还可以使用 ARTICLE 命令从新闻组中检索单个消息，并指定文章的消息标识符。

### 提示

**关键概念** 虽然 NNTP 最为人所知的是其在服务器间传播中的作用，但它也被 Usenet 客户端用于撰写和阅读文章。不同的命令提供了客户端设备阅读文章的灵活性。客户端可以检索整个新闻组，仅检索一组新闻组标题，或单个文章。其他命令也支持各种管理功能。

## 其他客户端/服务器功能

除了阅读和发布，NNTP 还包括支持用户可能希望执行的其他各种杂项任务的命令。客户端可以通过使用 HELP 命令来请求服务器的帮助信息，或者使用 NEWGROUPS 命令来获取新新闻组的列表。

大多数现代新闻阅读器包括的功能远远超出了之前描述的基本发布和阅读功能。大多数维护自己的配置文件集，允许用户维护一组喜欢的已订阅新闻组，而不是每次访问 Usenet 时都需要从主列表中选择一个组来阅读。新闻阅读器还会跟踪用户在每个已订阅新闻组中已阅读的文章，因此用户不需要浏览整个新闻组来查看已发布的新消息。

![NNTP 完整新闻组检索过程](http://atomoreilly.com/source/nostarch/images/288323.png.jpg) 有许多方法可以让 NNTP 客户端访问和读取服务器上的 Usenet 消息。一种常见的方法是检索整个新闻组的内容。在这个例子中，客户端使用 GROUP 命令选择用于阅读的新闻组 comp.protocols.tcp-ip；服务器响应 211（Group Selected）回复，其中包含有关该组的重要统计数据。客户端使用带有组中第一篇文章编号 177 的 ARTICLE 命令从服务器读取它。然后服务器逐行发送消息，以单行上的单个句号结束。客户端使用 NEXT 命令告诉服务器将其内部文章指针向前移动到下一篇文章，这通常不会是刚刚读取的下一个连续编号；这里它是 179。然后客户端可以通过单独发送 ARTICLE 命令来读取该消息。由于没有给出参数，服务器返回当前消息（179）。

图 85-4. NNTP 完整新闻组检索过程 有许多方式可以让 NNTP 客户端访问和读取服务器上的 Usenet 消息。一种常见的方法是检索整个新闻组的全部内容。在这个例子中，客户端使用 GROUP 命令选择用于阅读的新闻组 comp.protocols.tcp-ip；服务器响应以 211（Group Selected）回复，其中包含有关该组的重要统计数据。客户端使用带有组中第一篇文章编号的 ARTICLE 命令，即 177，从服务器读取它。然后服务器逐行发送消息，以一行上的单个句号结束。客户端使用 NEXT 命令告诉服务器将其内部文章指针向前移动到下一篇文章，这通常不会是刚刚读取的下一个连续编号；这里它是 179。然后客户端可以通过发送仅包含 ARTICLE 命令的命令来读取该消息。由于没有给出参数，服务器返回当前消息（179）。

## 文章线程

基本 Usenet 文章阅读的一个特别有用的增强功能是*线程化*。这个特性允许新闻阅读器以非严格的字母顺序或时间顺序显示文章，而是根据文章的引用头信息将文章分组到对话中。在繁忙的新闻组中，线程化特别有用，因为它允许用户一次性查看特定讨论中的所有文章，而不是同时尝试处理多个对话的消息。

线程化的问题之一是新闻阅读器需要花费很长时间来筛选所有这些引用行并构建文章线程。为了加快这一过程，许多服务器现在为新新闻组缓存额外的线程或概述信息，客户端可以在打开新闻组时检索这些信息以节省时间。这是通过使用 XTHREAD 或 XOVER NNTP 命令扩展来完成的。

# NNTP 命令和命令扩展

开放、协作的过程在开发互联网标准中的巨大优势之一是，通常新的协议是通过在旧协议的基础上进行设计。这节省了开发时间和精力，并促进了技术之间的兼容性。正如我在本章前面所解释的，NNTP 在许多方面基于 SMTP 的原则；SMTP 反过来又借鉴了早期协议（如 Telnet 和 FTP）的思想。这种传统可以在 NNTP 命令与这些早期协议的相似性中看到。

## 命令语法

与 SMTP 类似，所有 NNTP 命令都是 ASCII 文本，通过 NNTP TCP 连接发送到 NNTP 服务器，由充当客户端的设备（可能是新闻阅读器客户端或 NNTP 服务器本身）发送。这些是遵循 Telnet 网络虚拟终端 (NVT) 格式的标准文本字符串，以两个字符的回车/换行 (CRLF) 序列结束。与 SMTP 和 FTP 一样，您可以通过使用 Telnet 在端口 119 上连接到 NNTP 服务器来与 NNTP 服务器进行交互式会话。

NNTP 命令的基本语法是 <*command-code*> <*parameters*>。与 SMTP 不同，NNTP 命令不受四个字符长度的限制。命令后面的参数由一个或多个空格字符分隔，并用于提供必要的信息，以便服务器执行命令。NNTP 命令不区分大小写。

## 基础命令集

主要的 NNTP 规范，RFC 977，描述了 NNTP 客户端和服务器支持的命令基础集。它们没有被分成类别，而是按字母顺序列出，正如我在 表 85-5 中所做的那样。（关于这些命令中哪些用于新闻文章传播和新闻发布/访问的详细信息，在本章前面已提供。）

表 85-5. NNTP 基础命令

| 命令代码 | 命令 | 参数 | 描述 |
| --- | --- | --- | --- |
| ARTICLE | 获取文章 | 消息 ID 或服务器文章编号 | 告诉服务器向客户端发送特定的 Usenet 文章。要检索的文章可以使用其绝对、通用消息 ID 或其本地分配的文章编号来指定。当命令与文章编号一起发出时，这将导致服务器的内部消息指针设置为指定的文章。如果消息指针已经设置为特定的文章，则无需文章编号即可发出 ARTICLE 命令，并将检索当前消息。 |
| HEAD | 获取文章标题 | 消息 ID 或服务器文章编号 | 与 ARTICLE 命令相同，但只检索文章的标题。 |
| BODY | 获取文章正文 | 消息 ID 或服务器文章编号 | 与 ARTICLE 命令相同，但只返回文章的正文。 |
| STAT | 获取文章统计信息 | 服务器文章编号 | 概念上与 ARTICLE 命令相同，但不返回任何消息文本，只返回文章的消息 ID。此命令通常用于设置服务器的内部消息指针，因此 STAT 通常只与文章编号（而不是消息 ID）一起调用。 |
| GROUP | 选择新闻组 | 新闻组名称 | 告知服务器客户端想要访问的新闻组名称。假设指定的组存在，服务器将返回客户端该组中第一条和最后一条文章的编号，以及该组消息数量的估计。服务器的内部文章指针也将设置为组中的第一条消息。 |
| HELP | 获取帮助信息 | 无 | 请求服务器向客户端发送帮助信息，这通常以服务器支持的合法命令列表的形式出现。 |
| IHAVE | 向服务器提供文章 | 消息 ID | 客户端在 NNTP 会话中使用，告知服务器它有一个服务器可能感兴趣的新文章。服务器将检查提供的消息 ID，并响应客户端，指示是否希望客户端发送文章。 |
| LAST | 跳转到最后一条消息 | 无 | 告知服务器将其当前文章指针设置为新闻组中的最后一条消息。 |
| LIST | 列出新闻组 | 无 | 请求服务器发送它支持的新闻组列表，以及每个组中的第一条和最后一条文章编号。如 RFC 977 中描述的命令很简单，不支持参数，导致将新闻组的完整列表发送到客户端。NNTP 命令扩展显著扩展了此命令的语法，如本章下一节所述。 |
| NEWGROUPS | 列出新新闻组 | 日期和时间，以及可选的分布规范 | 请求服务器发送自指定日期和时间以来创建的新新闻组的列表。客户端还可以限制命令只返回特定区域分布内的新闻组。 |
| NEWNEWS | 列出新新闻文章 | 日期和时间，以及可选的分布规范 | 从服务器请求自特定日期和时间以来到达的所有新文章的列表。与 NEWGROUPS 命令类似，这可能受到分布的限制。服务器会响应新文章的消息 ID 列表。 |
| NEXT | 跳转到下一条消息 | 无 | 将服务器的当前文章指针移动到新闻组中的下一条消息。 |
| POST | 发布文章 | 无 | 告知服务器客户端想要发布新文章。服务器会响应一个肯定或否定的确认。假设发布是允许的，客户端随后将消息的全文发送到服务器，服务器将其存储并开始将其传播到其他服务器的过程。 |
| QUIT | 结束会话 | 无 | 终止 NNTP 会话。为了“礼貌”，客户端应在关闭 TCP 连接之前发出此命令。 |
| SLAVE | 设置从属状态 | 无 | 适用于特殊配置，其中一个 NNTP 服务器作为其他服务器的辅助。在实际应用中不常用。 |

### 提示

**关键概念** 主要 NNTP 标准定义了一系列基础 NNTP 命令，这些命令由发起 NNTP 连接的设备使用，以完成文章传播、发布和阅读功能。NNTP 命令由一个命令代码和可选的参数组成，这些参数指定了如何执行该命令。

## NNTP 命令扩展

RFC 977 中描述的基本命令集足以支持客户端-服务器和服务器间功能，但在许多方面，它相当基础且在效率和实用性方面有限。随着 Usenet 在 1980 年代末变得更大、更受欢迎，NNTP 需要改变以提高其可用性。1991 年，开始对 NNTP 标准进行正式修订的工作，但从未完成。尽管如此，该努力中的许多概念在随后的年份中非正式地被 NNTP 实现所采用。此外，一些 Usenet 软件作者创建了他们自己的非标准功能来改进协议，其中一些功能也通过广泛采用而成为事实标准。

因此，到 1990 年代末，大多数 Usenet 软件实际上实现了 NNTP 的变体，其功能远超标准文档中记录的内容。自然地，并非所有 NNTP 软件都支持相同的额外功能，这可能导致服务器和客户端之间潜在的兼容性问题。RFC 2980，“常见 NNTP 扩展”，于 2000 年 10 月发布，旨在正式化许多这些对基于 RFC 977 的基础 NNTP 标准的扩展。

NNTP 扩展主要包含新增的 NNTP 命令，这些命令被添加到基本的 NNTP 命令集中，以及一些对其他命令和 NNTP 功能的细微调整。这些扩展通常分为三类：

+   提高服务器间 NNTP 消息传输效率的扩展

+   使 NNTP 更有效地用于客户端消息访问的扩展

+   以下不属于前述任一组的杂项扩展

### NNTP 传输扩展

第一组被称为 NNTP *传输扩展*，它由一组相关的命令组成，旨在改善服务器之间的消息传播。其中大部分实现了 NNTP 的 *流模式*，这提供了一种更有效的方法，将大量文章从一个服务器移动到另一个服务器，正如本章前面关于服务器间通信的讨论中所述。表 85-6 描述了新的传输命令。

表 85-6. NNTP 传输扩展

| 命令代码 | 命令 | 参数 | 描述 |
| --- | --- | --- | --- |
| 模式 | 流模式 | 无 | 用于告知服务器客户端希望以流模式操作，使用 CHECK 和 TAKETHIS 命令。 |
| 检查 | 检查文章是否存在 | 消息 ID | 在流模式下，由作为客户端的服务器使用，以询问另一个服务器是否拥有特定文章的副本。服务器会回复表示是否希望收到该文章的副本。此命令类似于 IHAVE，但客户端在发送下一个命令之前不需要等待回复。 |
| TAKETHIS | 将文章发送到服务器 | 消息 ID | 当服务器对 CHECK 命令做出响应，表示希望获得特定消息的副本时，客户端使用此命令发送它。 |
| XREPLIC | 复制文章 | 新闻组和文章编号列表 | 为从一台服务器复制大量文章到另一台服务器的特殊目的而创建。它并不广泛使用。 |

### NNTP 新闻阅读器扩展

RFC 2980 定义的第二组扩展是 *新闻阅读器扩展*，这些扩展主要关注新闻阅读器客户端与 NNTP 服务器交互时使用的命令。这些扩展包括几个新命令，以及一个在 RFC 977 中功能非常有限的重要命令 LIST 的重大增强。

原始的 LIST 命令没有参数，只允许客户端检索服务器携带的所有新闻组的完整列表。当只有几百个 Usenet 新闻组时，这可能已经足够了，但现在有成千上万个。RFC 2980 定义了 LIST 命令的多种新变体，以允许客户端在服务器返回的信息类型上有更大的灵活性。表 85-7 显示了新的 LIST 命令变体。

表 85-7. NNTP LIST 命令扩展

| 命令代码 | 命令 | 参数 | 描述 |
| --- | --- | --- | --- |
| 列出活跃组 | 列出活跃新闻组 | 新闻组名称或模式 | 提供服务器上活跃新闻组的列表。这在语义上与原始的 LIST 命令相同，但客户端可以提供一个新闻组名称或模式来限制返回的新闻组数量。例如，客户端可以请求只包含“football”的新闻组列表。 |
| 列出活跃新闻组创建时间 | 列出活跃新闻组创建时间 | 无 | 促使服务器向客户端发送其 *active.times* 文件，该文件包含有关服务器携带的新闻组创建时间的信息。 |
| 列出分发 | 列出分发 | 无 | 使服务器向客户端发送 *distributions* 文件的内容，该文件显示了服务器识别的区域分发字符串（用于消息的分发标题）。 |
| 列出分发模式 | 列出分发模式 | 无 | 向服务器请求其 *distribution.pats* 文件，该文件类似于分发文件，但使用模式来总结不同新闻组的分发信息。 |
| LIST NEWSGROUPS | 列出新闻组 | 新闻组名称或模式 | 提供新闻组名称和描述的列表。与 LIST ACTIVE 不同，它只返回新闻组名称和描述，而不返回每个新闻组的文章编号。在功能上与 XGTITLE 相同（参见表 85-8），通常由用户用来定位要添加到其订阅列表中的新闻组。 |
| LIST OVERVIEW.FMT | 显示概要格式 | 无 | 促使服务器显示其 *概要* 文件的格式信息。有关更多信息，请参见表 85-8 中的 XOVER 命令描述。 |
| LIST SUBSCRIPTIONS | 获取默认订阅列表 | 无 | 请求服务器向客户端发送默认的新闻组订阅列表。这用于为新用户设置一个建议的新闻组列表。例如，如果一个组织有一个内部支持新闻组，它可以将这个组放在默认订阅列表中，这样所有新用户在第一次启动新闻阅读器时就能立即了解它。 |

除了对 LIST 命令的这些更改外，还定义了许多与新闻阅读器相关的命令扩展，这些扩展在表 85-8 中进行了描述。

表 85-8. NNTP 新闻阅读器扩展

| 命令代码 | 命令 | 参数 | 描述 |
| --- | --- | --- | --- |
| LISTGROUP | 列出新闻组中的文章编号 | 新闻组名称 | 使服务器返回当前新闻组中当前消息的本地文章编号列表。服务器当前的文章指针也设置为组中的第一条消息。 |
| MODE READER | 设置新闻阅读器模式 | 无 | 告知服务器，作为客户端的设备是一个客户端新闻阅读器，而不是另一个 NNTP 服务器。虽然技术上不是必需的——所有命令都可以由任何充当客户端的设备发送——一些服务器可能被优化以响应新闻阅读器相关的命令，如果给出此命令。 |
| XGTITLE | 获取新闻组描述 | 新闻组名称或模式 | 用于列出与特定文本模式匹配的新闻组或一组新闻组的描述。此命令在功能上与 LIST NEWSGROUP 命令扩展相同（参见表 85-7）。因此，建议不再使用 XGTITLE。 |
| XHDR | 获取文章标题 | 标题名称以及可选的消息 ID 或文章编号范围 | 允许客户端请求从一组消息中只获取特定的标题。如果只提供了标题名称，则返回当前组中所有消息的标题。否则，为所选消息提供标题。此扩展为新闻阅读器客户端提供了一种更高效的方式，用于检索和向用户显示新闻组中的重要标题。 |
| XINDEX | 获取索引信息 | 新闻组名称 | 获取索引文件，该文件由名为*TIN*的新闻阅读器使用，以提高浏览新闻组的效率。TIN 现在支持更常见的概览格式，因此 XOVER 命令比这个命令更受欢迎。 |
| XOVER | 获取概览信息 | 新闻组中的文章编号或文章编号范围 | 获取文章或一系列文章的概览。支持此功能的服务器维护一个特殊数据库，其中包含关于新闻组中当前文章的信息，该信息可以由各种新闻阅读器使用。检索概览信息允许像消息线程这样的功能比客户端必须检索每条消息的标题并手动分析它们更快地执行。 |
| XPAT | 获取匹配模式的文章标题 | 标题名称、模式以及消息 ID 或文章编号范围 | 与 XHDR 类似，它允许为消息集检索特定的标题。区别在于客户端可以指定一个必须匹配的图案，以便检索标题。这允许客户端让服务器搜索并返回某些消息，例如那些主题行表明特定类型讨论的消息，而不是要求客户端下载所有标题并搜索它们。 |
| XPATH | 获取文件名信息 | 消息 ID | 允许客户端请求在服务器上存储特定消息的实际文件名。 |
| XROVER | 获取概览引用信息 | 新闻组中的文章编号或文章编号范围 | 与 XOVER 命令类似，但专门检索指定文章的引用标题中的信息。这是包含创建线程对话所需数据的标题。 |
| XTHREAD | 获取线程信息 | 可选的 DBINIT 参数 | 与 XINDEX 类似，但检索由名为*TRN*的新闻阅读器使用的特殊线程信息文件。像 TIN 一样，TRN 现在支持常见的概览格式，因此 XOVER 比此命令更受欢迎。DBINIT 参数可用于检查线程数据库的存在。 |

### 其他 NNTP 扩展 |

最后一个扩展组包含与服务器间或客户端-服务器 NNTP 交互不严格相关的杂项扩展。该组中有两个命令：AUTHINFO 和 DATE。后者是一个简单的命令，会导致服务器告诉客户端其当前的日期和时间。AUTHINFO 则更有趣。它被客户端用来向服务器提供身份验证数据。

你可能已经注意到，在 RFC 977 协议中没有描述与安全相关的命令。这是因为原始 NNTP 根本没有任何安全功能。像许多在互联网时代之前编写的协议一样，在 20 世纪 80 年代初，安全性并没有被视为一个大问题。大多数新闻服务器仅由拥有该服务器的组织内部人员使用，并使用了简单的安全措施，例如通过 IP 地址或使用访问列表来限制对服务器的访问。

在 Usenet 规模扩大的早期，许多 NNTP 软件实现所做的更重要改变之一是要求进行身份验证。现代客户端通常会在建立与服务器连接时，将 AUTHINFO 作为它们的第一条命令之一发出，因为服务器在完成此操作之前将拒绝接受大多数其他命令。如果服务器因身份验证不正确而拒绝命令，还会添加一个特殊的回复代码到 NNTP 中。

AUTHINFO 命令可以通过几种不同的方式调用。命令的原始版本要求客户端发出一个带有用户名的 AUTHINFO USER 命令，然后是带有密码的 AUTHINFO PASS。这是一种简单的用户/密码登录身份验证。这种变体的 AUTHINFO SIMPLE 命令，客户端只需要发送一个密码。

客户端和服务器还可以通过使用 AUTHINFO GENERIC 命令来同意使用更复杂的身份验证方法。客户端向服务器提供它想要使用的身份验证方法的名称，以及身份验证所需的任何参数。然后，客户端和服务器根据他们使用的特定身份验证器交换消息和身份验证信息。

### 小贴士

**关键概念** 基本命令集的许多限制导致了 20 世纪 80 年代和 90 年代 NNTP 的非标准增强的激增。这些最终被记录在一系列 NNTP 命令扩展中，这些扩展正式补充了原始 RFC 977 命令。这些扩展在概念上分为三组：传输扩展，它细化了 NNTP 传播消息的方式；新闻阅读器扩展，它改善了客户端文章访问；以及杂项扩展。最重要的杂项扩展是 AUTHINFO，它为 NNTP 增加了安全性。

# NNTP 状态响应和响应代码

每次作为 NNTP 连接中客户端角色的设备发送命令时，服务器都会发送一个*响应*。响应用于确认收到命令，通知客户端命令处理的结果，并可能提示提供更多信息。由于 NNTP 命令的结构和格式与 SMTP 命令非常相似，我相信 NNTP 响应与 SMTP（在第七十七章中描述）非常相似，这不会让人感到惊讶。反过来，SMTP 响应基于 FTP 中设计的回复系统。

NNTP 响应的第一行包含一个三位数的数值*响应代码*，以及一行描述性文本，总结响应内容。这些响应代码的结构使得每个数字都有特定的意义，允许客户端快速确定回复所针对的命令的状态。在初始响应行之后，根据回复的不同，可能会跟随着多个附加的响应行。例如，成功的 LIST 命令会产生一个 215 响应代码，随后是新闻组的列表。

### 小贴士

**背景信息** *第七十二章")中关于 FTP 响应代码的讨论解释了为什么除了描述性文本外还使用数值响应代码*。

与 SMTP 和 FTP 一样，NNTP 响应代码可以认为是*xyz*的形式，其中*x*是第一位数字，*y*是第二位，*z*是第三位。第一个响应代码数字(*x*)表示命令在一般意义上的成功、失败或进度；一个成功的命令是否完成或未完成；以及一个未成功的命令未能工作的主要原因。这个数字的值与 SMTP 和 FTP 中定义的略有不同。在某些情况下，术语被简化了；例如，第二类是命令已确认，而不是更晦涩的 Positive Completion Reply。表 85-9 显示了该数字可能值的特定含义。

表 85-9. NNTP 响应代码格式：第一位数字解释

| 响应代码格式 | 含义 | 描述 |
| --- | --- | --- |
| 1yz | 信息性消息 | 通用信息；用于帮助信息和调试。 |
| 2yz | 命令已确认 | 命令已成功完成。 |
| 3yz | 命令已确认，请发送剩余部分 | 这是一个中间回复，用于提示客户端发送更多信息。通常用于对 IHAVE 或 POST 等命令的回复，服务器确认命令后，请求客户端传输文章。 |
| 4yz | 命令正确，但无法执行 | 命令有效但无法执行。此类错误通常由于参数错误、服务器暂时性问题、错误的命令序列或类似情况引起。 |
| 5yz | 命令未实现或错误，或严重程序错误 | 命令无效或严重的程序错误阻止了其执行。 |

第二个回复代码数字（*y*）用于将消息分类到功能组。这个数字与 SMTP 和 FTP 中的使用方式相同，但功能组不同，如表 85-10 中所述。

表 85-10. NNTP 回复代码格式：第二个数字解释

| 回复代码格式 | 含义 | 描述 |
| --- | --- | --- |
| x0z | 连接、设置和杂项 | 通用和杂项回复。 |
| x1z | 新闻组选择 | 与用于选择新闻组的命令相关的消息。 |
| x2z | 文章选择 | 与用于选择文章的命令相关的消息。 |
| x3z | 分布函数 | 与消息传输相关的消息。 |
| x4z | 发布 | 与发布消息相关的消息。 |
| x5z | 认证 | 与认证和 AUTHINFO 命令扩展相关的消息。（此类别在标准中未正式列出，但这些响应的中间数字为 5。） |
| x8z | 非标准扩展 | 保留用于私有、非标准实现使用。 |
| x9z | 调试 | 调试输出消息。 |

第三个回复代码数字（*z*）表示第二个数字描述的功能组中的特定消息类型。第三个数字允许每个功能组对于第一个代码数字给出的每个回复类型有十个不同的回复代码。

与 FTP 和 SMTP 一样，这些*x*、*y*和*z*数字的含义组合起来形成特定的回复代码。例如，如果客户端发出 IHAVE 命令但服务器不希望提供文章，服务器会发送回复代码 435。命令是正确的，但回复是负面的，因此以 4 开头，并且消息与消息分发相关，因此中间数字为 3。

表 85-11 包含了一些更常见的 NNTP 回复代码列表，按数字顺序排列，以及来自标准的典型回复文本和额外的描述信息。

表 85-11. NNTP 回复代码

| 回复代码 | 回复文本 | 描述 |
| --- | --- | --- |
| 100 | 接下来是帮助文本 | 在对 HELP 命令的响应之前发送。 |
| 111 | （日期和时间） | 对 DATE 命令扩展的响应。 |
| 199 | （调试输出） | 调试信息。 |
| 200 | 服务器就绪 - 允许发布 | 在会话初始化时由服务器发送，如果客户端被允许发布消息。 |
| 201 | 服务器就绪 - 不允许发布 | 在会话初始化时由服务器发送，如果客户端不允许发布消息。 |
| 202 | 已记录从属状态 | 对 SLAVE 命令的响应。 |
| 203 | 流式传输正常 | 对 MODE STREAM 命令的成功响应。 |
| 205 | 关闭连接 - 再见！ | 在收到 QUIT 消息后发送的再见信息。 |
| 211 | n f l s 已选择组 | 对 GROUP 命令的成功响应，指示组中估计的消息数量 (*n*)、第一和最后文章编号 (*f* 和 *l*) 以及组名 (*s*)。 |
| 215 | 随后跟有新闻组列表 (或) 随后跟有信息 | 对 LIST 命令的成功响应。第二种形式是针对作为 NNTP 命令扩展定义的 LIST 变体。 |
| 218 | 随后跟有 tin 风格索引 | 对 XINDEX 命令扩展的成功响应。 |
| 220 | n <a> 文章已检索 - 头部和正文随后 | 对 ARTICLE 命令的成功响应，指示文章编号和消息 ID。 |
| 221 | n <a> 文章已检索 - 头部信息随后 | 对 HEAD 命令的成功响应，指示文章编号和消息 ID。 |
| 222 | n <a> 文章已检索 - 正文信息随后 | 对 BODY 命令的成功响应，指示文章编号和消息 ID。 |
| 223 | n <a> 文章已检索 - 请求单独发送文本 | 对 STAT 命令的成功响应，指示文章编号和消息 ID。 |
| 224 | 随后跟有概要信息 | 对 XOVER 命令扩展的成功响应。 |
| 230 | 按消息 ID 列出新文章 | 对 NEWNEWS 命令的成功响应。 |
| 235 | 文章已成功传输 | 在文章发送后对 IHAVE 命令的成功响应。 |
| 239 | 文章已成功传输 | 对 TAKETHIS 命令的成功响应。 |
| 240 | 文章已成功发布 | 在文章发布后对 POST 命令的成功响应。 |
| 250 或 281 | 认证接受 | 使用 AUTHINFO 命令扩展成功认证。 |
| 282 | 随后跟有组和描述列表 | 对 XGTITLE 命令扩展的积极响应。 |
| 288 | 随后跟有二进制数据 | 对 XTHREAD 命令扩展的成功响应。 |
| 335 | 将文章发送以供传输 | 对 IHAVE 命令的初步响应。 |
| 340 | 将文章发送以供发布 | 对 POST 命令的初步响应。 |
| 381 | 需要更多认证信息 | 对 AUTHINFO 命令扩展的初步响应。 |
| 400 | 服务已中断 | 会话正在终止，可能是由于用户请求。 |
| 411 | 没有这样的新闻组 | 指定的新闻组名称无效。 |
| 412 | 没有选择新闻组 | 在使用 GROUP 命令选择新闻组之前尝试发出引用当前新闻组的命令。 |
| 420 | 没有当前文章被选中 | 在通过文章选择设置指针之前，尝试使用服务器的当前文章指针发布涉及当前文章的命令。 |
| 421 | 本组中没有下一篇文章 | 在新闻组的最后一篇文章时对 NEXT 命令的响应。 |
| 422 | 本组中没有上一篇文章 | 可能是 LAST 的响应（我不知道为什么“previous”这个词在那里）。 |
| 423 | 本组中没有这样的文章编号 | 无效文章编号的命令。 |
| 430 | 找不到这样的文章 | 文章未找到；它可能已被删除。 |
| 435 | 文章不受欢迎 - 不要发送 | 如果服务器不需要文章，则对 IHAVE 的负面响应。 |
| 436 | 转移失败 - 尝试稍后重试 | 文章传输暂时失败；重试。 |
| 437 | 文章被拒绝 - 不要再尝试 | 由于任何原因拒绝文章。 |
| 438 | 我已经有了，请不要发给我 | 与回复代码 435 相同，但针对 CHECK 命令扩展。 |
| 440 | 发布不允许 | 在不允许发布时发布 POST 命令。 |
| 441 | 发布失败 | POST 命令失败。 |
| 450 | 此命令需要授权 | 当服务器需要认证但客户端尚未认证时发送的响应。 |
| 452 | 授权被拒绝 | 认证失败。 |
| 480 | 转移权限被拒绝 | 如果不允许转移，则对 CHECK 的响应。 |
| 500 | 命令未识别 | 坏命令。 |
| 501 | 命令语法错误 | 命令中的语法错误。 |
| 502 | 访问限制或权限被拒绝 | 权限被拒绝；如果客户端没有正确认证但服务器需要它，则发送。 |
| 503 | 程序故障 - 命令未执行 | 通用致命错误消息。 |

### 小贴士

**关键概念** 每个作为 NNTP 连接中客户端的设备发送的命令都会导致服务器返回一个回复。NNTP 回复由三位数的回复代码和一系列描述性文本组成。这些代码是模仿 SMTP 的，进而模仿 FTP。

# 第八十六章。GOPHER 协议（GOPHER）

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

假设我告诉你我将要描述一个专为分布式文档搜索和检索而设计的 TCP/IP 应用层协议。此协议使用客户端/服务器模型进行操作，其中服务器提供指向相关资源的链接，例如文件或程序，用户通过显示用户选择选项的客户端软件访问这些资源。你可能认为我在谈论万维网，而且有很好的理由。然而，在这种情况下，我实际上在谈论网络的先驱之一：*Gopher 协议*。

在本章中，我简要描述了 Gopher 的历史、操作、与万维网的差异以及在现代互联网中的作用。

# Gopher 概述和一般操作

讨论此协议的一个好地方是从其名称开始，这个名字选择得很好，有多个原因。Gopher 协议是在明尼苏达大学开发的，该校的体育队伍被称为金戈菲尔（明尼苏达州被称为戈菲州）。这是名称的直接来源，但这也很合适，因为共享这个名字的啮齿动物以挖掘而闻名，就像协议被设计成“挖掘”通过互联网一样。当然，术语 *gopher* 也适用于执行差事的人，例如检索文档（他们“go fer”这个，“go fer”那个）。

Gopher 协议是在 20 世纪 80 年代末期开发的，旨在为大学的学生和教师提供一个组织文档的机制，以便他们可以轻松访问。指导系统开发的核心理念是 *简单性*。Gopher 是基于少数核心原则设计的，并且它使用一种非常直接的机制在客户端和服务器设备之间传递信息。它被描述在 1993 年 3 月发布的 RFC 1436 中。

## Gopher 服务器上的信息存储

Gopher 可访问的信息存储在 *Gopher 服务器* 上的文件中。它以类似于 Windows PC 或 UNIX 工作站文件系统树的方式组织。

正如文件系统由包含文件和子目录（子文件夹）的顶层目录（或文件夹）组成一样，Gopher 服务器将信息呈现为一个顶层目录，其中包含文件等资源以及/或包含更多资源的子目录。不同服务器上的资源可以通过在彼此的资源层次结构中提及它们来相互链接。还可以创建虚拟资源，它们的行为就像文件一样，例如允许 Gopher 服务器进行搜索的程序。

## Gopher 客户端/服务器操作

Gopher 的典型使用是从客户端用户在客户端机器上创建一个 TCP 连接到 Gopher 服务器开始，使用众所周知的 TCP 端口号 70。连接建立后，服务器等待客户端通过发送一个称为选择字符串的文本来请求特定的资源。通常，当用户首次访问服务器时，他们不知道要请求什么资源，因此会发送一个空（空）的选择字符串。这会导致服务器向客户端发送一个列表，列出服务器文件系统树顶层（根）目录中可用的资源。

服务器发送的目录列表由一系列行组成，每行描述该目录中的一个可用资源。每行包含以下元素，每个元素由制表符分隔：

**类型字符和资源名称** 行的第一个字符告诉客户端软件该行代表的是哪种资源。最常见的类型字符是 0（零）表示文件，1 表示子目录，7 表示搜索服务。直到第一个制表符字符之前的其余字符包含要向用户展示的资源名称。

**选择字符串** 发送到服务器以检索此资源的文本字符串。

**服务器名称** 资源所在的服务器名称。

**服务器端口号** 用于访问此资源服务器的端口号；通常是 70。

每行都以符合 Telnet 网络虚拟终端（NVT）规范的回车/换行（CRLF）字符序列结束。在发送目录列表（或任何其他响应）后，客户端和服务器之间的连接将关闭。

在收到此类目录列表后，Gopher 客户端软件将向用户显示一个菜单，其中包含服务器提供的所有资源名称。然后用户从菜单中选择他想要的项，客户端通过连接到适当的服务器和端口号，并发送该资源的选择字符串来检索它。如果这本身代表一个子目录，服务器将发送该子目录的新目录列表；如果它代表其他类型的资源，它将根据资源类型的要求进行访问。

例如，假设这一行是从服务器发送到客户端的：

```
0Gopher Introduction<Tab>intro<Tab>gopher.someserver.org<Tab>70
```

这将在包含其他选项的菜单中以名为 Gopher Introduction 的文件形式展示给用户。如果用户选择它，客户端将启动与 Gopher 服务器 gopher.someserver.org 在端口 70 的连接，并向该服务器发送选择字符串 intro 以检索文档。

# Gopher 和 Web 之间的重要差异

正如我在本讨论开始时暗示的那样，Gopher 和 Web 都旨在实现相同的基本目的：提供对信息库的访问，并在相关文档和资源之间建立链接。然而，它们在如何访问信息方面采取了非常不同的方法，特别是在两个关键领域：用户界面和资源链接。

Gopher 向用户展示的内容完全围绕其分层文件系统。因此，Gopher 本质上是基于菜单的，用户界面通常基于这些菜单的简单文本展示。相比之下，网络服务器上的信息可以以任何方式组织，并以服务器所有者希望的形式或风格展示给用户。网络更加自由形式，除非以某种方式有利，否则不需要使用目录结构。

在万维网中，链接是在文档之间直接进行的，通常使用超文本标记语言（HTML）标签。当某人撰写文档 A 时提到与文档 B 相关的内容，她会在文档 A 中直接放置指向文档 B 的链接。另一方面，Gopher 并没有设计成以这种方式使用链接。相反，链接的目的是使用我之前描述的目录树进行链接。

# Gopher 在现代互联网中的作用

有些人认为，在许多方面，Gopher 在技术上优于万维网。他们认为，让服务器进行链接比在文档中嵌入链接更干净。也可以提出这样的论点：Gopher 的文本导向效率更高，更能确保平台之间的兼容性，并且更适合像低带宽链接和视力障碍者访问这样的特殊需求情况。因此，一些 Gopher 爱好者认为，它比万维网是一个更纯粹的超文本系统。

然而，历史告诉我们，尽管 Gopher 比万维网出现得早，但万维网在短短几年内就超过了它的人气。如今，万维网是互联网上的 900 磅巨猩，而大多数人甚至从未听说过 Gopher。发生了什么？

我认为 Gopher 输给万维网的主要原因在于万维网具有更大的灵活性。Gopher 使用文本超链接和服务器目录结构可能很高效，但它是有限的。相比之下，万维网允许以多种方式展示信息。万维网的开放和非结构化特性使其成为信息提供者和应用开发者创造力的理想载体。在 20 世纪 90 年代中期，万维网也恰好处于支持从文本到图形计算过渡的最佳位置，而 Gopher 则没有。

简而言之，你可以用万维网做更多的事情，而大多数人更关心功能性和选项的广度，而不是直接的效率。一旦万维网开始获得动力，它很快就滚雪球般地发展起来。仅仅几年时间，万维网的使用就根深蒂固，而 Gopher 无法与之竞争。

对于其本身，明尼苏达大学可能因为其有争议的决定——向希望将 Gopher 用于商业目的的公司收取许可费——加速了 Gopher 的消亡。我不认为这有什么恶意。大学预算有限，希望能够负担得起的公司支付一小笔费用来支持 Gopher 软件的开发。然而，计算历史一次又一次地表明，没有比试图对协议或标准收取许可费或版税更快的方式来杀死它，无论理由是什么。

到 20 世纪 90 年代末，Gopher 已经走向了淘汰的道路。随着该协议的使用量减少，许多组织再也无法证明继续运行 Gopher 服务器是有必要的。甚至明尼苏达大学本身也因利用率低而最终关闭了自己的 Gopher 服务器。2002 年，一个与 Gopher 相关的安全漏洞在 Internet Explorer 中被发现，微软选择简单地从产品中移除 Gopher 支持，而不是修复这个问题。如今，Gopher 仍然存在，但它只是一种由相对较少的爱好者以及一些有使用 Gopher 历史的组织所使用的利基协议。

### 小贴士

**关键概念** Gopher 协议是一种分布式文档搜索和检索协议，它于 20 世纪 80 年代末在明尼苏达大学开发。资源存储在 Gopher 服务器上，这些服务器使用分层目录结构来组织信息。Gopher 客户端访问服务器以检索可用资源的目录列表，这些列表以菜单的形式呈现给用户，用户可以从菜单中选择一个项目进行检索。Gopher 的主要优势在于简单易用，但它缺乏在展示方面的灵活性以及有效展示图形和多媒体的能力。因此，尽管 Gopher 诞生早于万维网，但万维网几乎完全取代了它，现在 Gopher 只是一种利基协议。
