# 第三部分-第十章. 交互式和行政工具及协议

第八十七章

第八十八章

文件和消息传输应用包括文件传输协议（FTP）、电子邮件（email）和万维网，这使得文件和消息传输成为经典 TCP/IP 应用中最重要的一类。然而，这些应用并不代表 TCP/IP 互连网使用的唯一方式。虽然不像本节中我们之前检查的一些应用协议那样引人注目，但交互式和行政协议同样重要，值得理解。

本书最后一部分涵盖了 TCP/IP 应用的几个其他类别。第一章描述了交互式和远程应用协议，这些协议传统上用于允许一台计算机的用户访问另一台计算机，或者允许信息的实时交换。第二章讨论了 TCP/IP 管理和故障排除工具，这些工具可以被管理员和最终用户用来管理 TCP/IP 网络并诊断与之相关的问题。

# 第八十七章. TCP/IP 交互式和远程应用协议

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

当涉及到 TCP/IP 应用时，文件和消息传输应用受到最多的关注，因为它们是现代互连网中最常使用的应用。另一个不太为人所知的 TCP/IP 应用协议类别是允许用户通过互连网直接交互式访问和使用其他计算机的组，例如公共互联网。这些应用今天并不常被最终用户使用，但它们仍然很重要——从历史角度来看，以及在某些情况下，特别是对网络管理员来说，因为它们的实用性。

在本章中，我简要介绍了 TCP/IP 中使用的经典交互式和远程应用协议。我首先描述了 Telnet 协议，这是 TCP/IP 中最早且概念上最重要的应用协议之一。这次讨论包括对 Telnet 客户端/服务器通信、Telnet 网络虚拟终端（NVT）以及 Telnet 的协议命令和选项的描述。然后，我描述了伯克利远程访问家族，通常被称为*r 命令*或协议，因为它们的命令名以该字母开头。最后，我简要概述了互联网中继聊天（IRC）协议，这是互联网最初的交互式聊天应用，至今仍被广泛使用。

# Telnet 协议

在互联网的最初阶段，计算机科学家需要解决的最重要的问题之一是如何让操作一台计算机的用户能够访问并使用另一台计算机，就像那个远程用户是本地连接到它一样。为了满足这一需求而创建的协议被称为 *Telnet*，开发它的努力与整个互联网和 TCP/IP 紧密相连。尽管如今的大多数互联网用户从未直接调用 Telnet 协议，但他们一直在间接地使用其一些基本原理。每次你发送一封电子邮件，使用文件传输协议（FTP）传输文件，或加载一个网页时，你都在使用基于 Telnet 的技术。因此，Telnet 协议可以声称是 TCP/IP 历史上最重要的应用协议。

### 提示

**背景信息** 对传输控制协议（TCP）的基本理解，特别是其滑动窗口机制和流量控制功能，将有助于理解 Telnet。这些主题在第四十八章和第四十九章中有详细说明。

## Telnet 概述、历史和标准

Telnet 的历史实际上可以追溯到我们今天所知道的现代 TCP/IP 协议套件之前的十多年。正如我在 FTP 概述中提到的，TCP/IP 互联网技术早期开发者确定了网络需要满足的两个总体应用需求：允许对资源的 *直接访问* 和允许对资源的 *间接访问*。FTP 是为了间接访问而创建的，允许用户从远程主机检索资源，在本地使用它，如果需要的话，将其复制回源。Telnet 是为了直接访问而设计的，允许用户访问远程机器，就像他们本地连接到它一样。

### Telnet 历史

Telnet 最初是在 20 世纪 60 年代末开发的。这比我们现在许多人专用的个人电脑时代要早得多。那个时期的所有计算机都很大，通常由许多用户共享。要在计算机上工作，你必须访问连接到该机器的物理终端，这通常是根据主机的需求和要求特别定制的。由此产生了两个具体问题：

+   如果一个组织拥有几台不同的计算机，每个用户都需要一个单独的终端来访问他们使用的每一台计算机。这既昂贵又低效。我记得曾读过一本书中的引用，将这种情况比作一个房间里有许多电视，每个电视只能显示一个频道。

+   可能一个更显著的问题是，允许一个站点的一个用户访问并使用另一个站点的机器的困难。当时实现这一点的唯一方法是，从计算机的站点安装一条专用数据电路到用户的站点，将用户的终端连接到远程机器。同样，每个电路只能使一台机器可访问。每个用户和计算机的组合都需要安装和维护一个单独、昂贵的电路。

解决这两个问题的方案是创建一种更通用的方式，允许任何终端访问任何计算机。底层互联网提供了在计算机之间传递信息的机制。这成为了连接站点的物理网络，以及连接网络的 TCP/IP 协议套件。在此基础上运行的应用协议允许用户与任何网络计算机建立会话并使用它。这个应用协议就是 Telnet。

Telnet 是 1969 年在初生的 ARPAnet 上演示的第一个应用协议。第一个专门定义 Telnet 的 RFC 是 RFC 97，“对建议的 Telnet 协议的第一次尝试”，于 1971 年 2 月发布。Telnet 的开发在整个 1970 年代持续进行，有相当多的不同 RFC 致力于协议的修订和与其相关的问题讨论。花了多年时间来完善 Telnet 并解决与其开发相关联的所有困难。该协议的最终版本，“Telnet 协议规范”，于 1983 年 5 月作为 RFC 854 发布。多年来，还发布了其他 RFC 来阐明协议的使用并解决诸如身份验证等问题。此外，还有许多其他 RFC 定义了 Telnet 选项，如本章后面的“Telnet 选项和选项协商”部分所述。

### 基本 Telnet 概念

初看之下，Telnet 开发得如此之慢可能会令人惊讶，因为在理论上，它应该是一个非常简单的协议来定义。它只需要像其他任何协议一样在网络中发送按键和程序输出。如果每个终端和计算机都使用相同的通信方法，其定义将是简单的，但它们并不相同。Telnet 之所以变得复杂，是因为它需要允许一个制造商的终端能够与可能使用非常不同的数据表示的计算机进行通信。

Telnet 通过定义一种确保终端类型和计算机之间兼容性的方法来解决此问题，同时允许计算机和终端使用它们同意支持的特殊功能。该协议建立在三个主要概念的基础上。

**网络虚拟终端 (NVT)** Telnet 定义了一个标准化的、虚构的终端，称为 *网络虚拟终端 (NVT)*，它被所有设备用于通用通信。Telnet 客户端从用户那里获取输入，并将其从其原生形式转换为 NVT 格式，以便发送到在远程计算机上运行的 Telnet 服务器。服务器将 NVT 转换为被访问计算机所需的任何表示形式。当数据从远程计算机发送回用户时，这个过程是相反的。这个系统允许客户端和服务器即使使用完全不同的硬件和内部数据表示也能进行通信。在数据中穿插特殊的 Telnet 命令，以便客户端和服务器设备执行管理协议操作所需的各种功能。

**选项和选项协商** Telnet 客户端和服务器作为 NVT 行动，避免了设备之间的不兼容性，但这样做是通过去除所有终端特定功能来提供一个大家都能理解的通用基础表示。由于有许多情况下，更智能的终端和计算机可能希望使用更高级的通信功能和服务的场合，Telnet 定义了一个丰富的选项集和一种机制，通过这种机制，Telnet 客户端和服务器可以协商它们的使用。如果客户端和服务器就选项的使用达成一致，则可以启用该选项；如果不一致，它们始终可以回退到 NVT 以确保基本通信。

**对称操作** 虽然 Telnet 是一个客户端/服务器协议，但它专门设计为不对客户端和服务器软件的性质做出假设。一旦建立 Telnet 会话，计算机就可以作为平等的角色发送和接收数据。它们还可以各自启动选项协商。这使得该协议非常灵活，并导致它在各种地方得到应用，如下一节所述。

### Telnet 应用

Telnet 最常与远程登录相关联，这是它的常见传统用途。用户通常使用 Telnet 客户端程序打开到远程服务器的 Telnet 连接，然后服务器将 Telnet 客户端视为本地终端，允许用户登录并访问服务器的资源，就像他正在使用直接连接的终端一样。UNIX 用户仍然广泛使用这种方式，他们经常需要从本地机器登录到远程主机（我每天使用 Telnet 以这种方式访问数百英里外的机器）。然而，对于大多数在 Windows 或 Apple 计算机上工作的互联网用户来说，这种 Telnet 的使用并不常见，他们通过网络资源不是通过直接登录，而是通过其他方式访问。

虽然远程登录是 Telnet 的一个重要部分，但该协议并非最初就是为了那个特定功能而设计的。当使用 Telnet 访问远程设备时，该协议本身仅用于在客户端和服务器机器之间建立连接，根据 Telnet NVT 规则编码要传输的数据，并促进选项的协商和使用。客户端和服务器设备决定是否使用 Telnet 进行远程访问或其他目的。

这种灵活性，加上 Telnet 在 TCP/IP 套件中的历史，导致了它在各种其他协议中的应用。由于 Telnet 对客户端和服务器是什么没有假设，任何程序或应用都可以使用它。许多文件和消息传输应用，如 FTP、简单邮件传输协议 (SMTP)、网络新闻传输协议 (NNTP) 和超文本传输协议 (HTTP)，通过发送文本命令和消息进行通信，并使用 Telnet 的 NVT 规范确保设备之间通信的兼容性。它们实际上并没有建立 Telnet 会话或使用选项协商等特性；它们只是以与 Telnet 工作方式一致的方式发送数据。因此，尽管现代互联网用户可能从未有意调用 Telnet，但每次发送或接收电子邮件或浏览网页时，他们都在间接地使用它。管理员甚至可以使用 Telnet 客户端软件访问 FTP 和 HTTP 服务器等设备，并手动向这些设备发送命令。

### 小贴士

**关键概念** *Telnet* 是 TCP/IP 套件中最古老的协议之一，最早在 1960 年代开发，允许一个计算机系统上的用户直接访问和使用另一个系统。它最常用于远程登录，用户的机器上的 Telnet 客户端软件与远程主机上的 Telnet 服务器建立会话，使用户能够像直接连接一样与主机工作。为了确保使用不同硬件和软件的终端和主机之间的兼容性，Telnet 客户端和服务器软件之间的通信基于一个简化的、虚构的数据表示，称为 *网络虚拟终端 (NVT)*，可以通过协商选项来增强。

## Telnet 连接和客户端/服务器操作

Telnet 的整体功能是定义一种方式，允许一台机器上的用户或进程可以访问并使用另一台机器，就像它本地连接一样。这使得 Telnet 在操作上本质上是客户端/服务器模式，就像 TCP/IP 中许多其他应用协议一样。通常，Telnet 客户端是一段软件，作为用户界面的接口，处理按键和用户命令，并展示远程机器的输出。Telnet 服务器是在远程计算机上运行的程序，已配置为允许远程会话。

### TCP 会话和客户端/服务器通信

Telnet 用于在客户端和服务器之间进行长时间的数据和命令交互，因此它强烈依赖于*会话*的概念。因此，Telnet 通过面向连接的传输控制协议（TCP）运行。Telnet 服务器监听在著名的 TCP 端口号 23 上的连接。当客户端想要访问特定的服务器时，它会向相应的服务器发起一个 TCP 连接，服务器会响应并使用标准的 TCP 三次握手（在第四十七章中描述）来建立 TCP 连接。

TCP 连接在整个 Telnet 会话期间保持，Telnet 会话可以持续数小时、数天甚至数周。TCP 的服务质量特性保证数据可靠且有序地接收，并确保数据不会以过高的速率发送给客户端或服务器。提供 Telnet 服务的机器可以支持与不同用户的多个同时会话，通过使用客户端的 IP 地址和端口号来区分每个会话。

由于 TCP 是一种全双工协议，客户端和服务器都可以在 Telnet 会话中随意发送信息。默认情况下，两个设备开始时都使用标准的 NVT 方法来编码数据和控制命令（我们将在本章稍后全面探讨）。它们还可以协商使用 Telnet 选项来为会话提供更强大的功能。虽然选项协商可以在任何时候发生，但在 Telnet 会话首次建立时通常会有一个选项交换的爆发，之后则只有偶尔的选项命令交换。

在 TCP 连接建立且 Telnet 会话活跃时，客户端和服务器软件开始执行它们正常的任务，即使用户与远程主机进行交互。对于用户来说，Telnet 会话看起来基本上与坐在直接连接到远程主机的终端上是一样的。在大多数情况下，服务器将通过发送登录提示来开始用户的会话，要求输入用户名和密码。Telnet 客户端将从用户那里接受这些信息并将其发送到服务器。假设信息有效，用户将被登录并可以使用主机，方式取决于其账户的授权。

如 Telnet 概述中所述，尽管该协议通常用于远程登录，但它并不需要以这种方式使用。运行 Telnet 服务器的计算机管理员决定在该机器上如何使用它。举一个例子，一个 Telnet 服务器可以直接与提供服务的进程或程序接口。我记得几年前使用过一个提供公共天气信息的互联网服务器，它使用 Telnet。在通过该协议连接到该机器后，用户看到的不是登录提示，而是一个天气显示选项菜单。如今，Web 已经取代了大多数此类设施，因为它更适合此类信息检索。

### 小贴士

**关键概念** Telnet 是一种客户端/服务器协议，它使用 TCP 在用户终端和远程主机之间建立会话。Telnet 客户端软件从用户那里获取输入并将其发送到服务器，服务器将其传递给主机机器的操作系统。Telnet 服务器从主机获取输出并将其发送到客户端以显示给用户。虽然 Telnet 最常用于实现远程登录功能，但它并非专门为登录而设计。该协议足够通用，允许它用于各种功能。

### 使用 Telnet 访问其他服务器

Telnet NVT 表示被 SMTP 和 HTTP 等各种其他协议使用。这意味着，允许您访问 Telnet 服务器的相同 Telnet 客户端也可以用来直接访问其他应用程序服务器。您只需指定对应于服务的端口号即可。例如，以下命令将允许您直接与一个 Web 服务器接口：

```
telnet *`www.someserversomewhere.org`* 80
```

您将不会收到登录提示，而是服务器将等待您发送 HTTP 请求消息，就像您是一个网页浏览器一样。如果您输入一个有效的请求，服务器将发送一个 HTTP 响应消息。以这种方式使用，Telnet 可以作为一个非常有价值的诊断工具。

### 小贴士

**关键概念** Telnet 网络虚拟终端 (NVT) 数据表示已被众多其他 TCP/IP 协议采纳作为其消息系统的基础。因此，Telnet 客户端软件不仅可以用来连接到 Telnet 服务器，还可以用来连接到 SMTP 和 HTTP 等协议的服务器，这在诊断目的上非常有用。

## Telnet 通信模型和网络虚拟终端 (NVT)

Telnet 的核心实际上是一个相当简单的协议。一旦建立了 TCP 连接并开始 Telnet 会话，客户端和服务器软件的唯一真正任务是捕获输入和输出，并将其通过网络重定向。因此，当用户在其本地终端上按下一个键时，Telnet 客户端软件会捕获它并将其通过网络发送到远程机器。在那里，Telnet 服务器软件将按键发送到操作系统，操作系统将其视为在本地输入。当操作系统产生输出时，过程相反：Telnet 服务器软件捕获输出并将其通过网络发送到用户的客户端程序，该程序将其显示在打印机或监视器上。

用两个众所周知的陈词滥调来说，我可以说这看起来在纸上不错，但魔鬼在于细节。这个简化的实现只有在所有计算机和终端都使用完全相同的硬件、软件和数据表示时才会工作。当然，这今天远非如此，当 Telnet 正在开发时情况更糟。在“美好的旧时光”里，计算机非常专有，并且没有设计成可以互操作。它们在许多方面都不同——从终端使用的键盘类型和它可以发送的按键到终端每行和每屏的字符数，再到用于编码数据和控制功能的字符集。简而言之，计算机 A 被设计成只能接受来自其自己的终端的特定形式的输入，而不是来自计算机 B 的终端。

这实际上是在网络世界中相当常见的问题，我可以举一个现实世界的例子来帮助解释这个问题以及它可能如何被解决。假设一个重要的国际会议有来自不同国家的 30 位大使参加，每位大使都有一位助手。每个大使和助手对只说自己的语言，因此只能相互交流——就像是为相互接口而设计的计算机和终端一样。为了让一个国家的助手能与来自其他国家的大使交流，一个解决方案就是训练助手们说所有其他参加国家的语言。回到计算世界，这就像定义 Telnet 协议，使得每个 Telnet 客户端软件都能理解如何与现有的每台计算机通信。这可以工作，但会非常不切实际且难以实现。

另一种方法是定义一种单一的共同语言，并让所有的大使和助手都学习这种语言。虽然这需要一些工作，但远不如要求人们学习几十种语言那么多。每位大使和助手都会说一种母语和这种选定的共同语言。他们可以使用这种共同语言与所有人进行交流，而无需知道会议中可能使用的所有语言。更重要的是，如果一位大使和助手在会议上说一种新的、第 31 种语言，其他所有代表就不需要学习它。

Telnet 使用了一种非常类似的方法来处理其硬件和软件兼容性问题。而不是让终端和主机使用它们各自的原生语言进行通信，所有的 Telnet 客户端和服务器都同意发送符合虚构的、虚拟终端类型（NVT）的数据和命令。

### NVT

NVT 定义了信息格式化和发送的规则集，例如字符集、行终止符以及如何发送关于 Telnet 会话本身的信息。

在终端上运行的每个 Telnet 客户端都理解其原生语言和 NVT 语言。当用户在本地终端上输入信息时，它会被转换为 NVT 格式以便通过网络传输。当 Telnet 服务器接收到这些信息时，它会将其从 NVT 格式转换为远程主机期望接收的格式。从服务器到客户端的传输也执行相同的反向过程。这如图 图 87-1 Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。") 所示。

![Telnet 通信和网络虚拟终端 (NVT) Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。](img/httpatomoreillycomsourcenostarchimages288325.png.jpg)

图 87-1. Telnet 通信和网络虚拟终端 (NVT) Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。

### 小贴士

**关键概念** Telnet 的 *网络虚拟终端 (NVT)* 是一种统一的数据表示，确保了可能使用非常不同硬件、软件和数据格式的终端和主机之间通信的兼容性。Telnet 客户端将终端的原生格式输入转换为 NVT 格式以便传输到 Telnet 服务器，在那里它被转换为主机的内部格式。从主机到用户的输出过程是相反的。

NVT 被定义为包含一个逻辑键盘用于输入和一个逻辑打印机用于输出（协议的年龄在这些术语中得到了反映；几十年前没有显示器，所有输出都在纸上）。NVT 使用 7 位 *美国 ASCII (US-ASCII)* 字符集。每个字符使用一个 8 位字节进行编码。

然而，客户端和服务器可以使用 Telnet 选项协商其他数据表示，包括传输扩展 ASCII 或甚至完整的 8 位二进制数据。

### NVT ASCII 控制码

正规 ASCII 由 95 个常规的可打印字符（代码 32 至 126）和 33 个控制码（0 至 31 和 127）组成。Telnet 标准规定输出设备必须能够处理所有可打印字符，并强制规定如何解释其他一些常见的 ASCII 控制码。在这些码中，有三个（0、10 和 13）必须被所有 Telnet 软件接受；另外五个是可选的，但如果支持，则必须以与 Telnet 规范一致的方式进行解释。表 87-1 描述了标准 Telnet NVT ASCII 控制码。

表 87-1. 标准 Telnet NVT ASCII 控制码的解释

| ASCII 值（十进制） | ASCII 字符代码 | ASCII 字符 | 描述 | 支持可选/强制 |
| --- | --- | --- | --- | --- |
| 0 | NUL | 空字符 | 无操作（对输出无影响）。 | 强制 |
| 7 | BEL | 铃声 | 在输出上产生可听或可视的信号，而不移动打印头。此通知可用于吸引用户的注意，例如在错误的情况下。 | 可选 |
| 8 | BS | 退格 | 将打印位置向左移动一个字符。 | 可选 |
| 9 | HT | 水平制表符 | 将打印机移动到下一个水平制表位。标准没有指定设备如何就制表位位置达成一致；这可以通过 Telnet 选项进行协商。 | 可选 |
| 10 | LF | 换行 | 将打印机移动到下一行，保持打印位置不变。 | 强制 |
| 11 | VT | 垂直制表符 | 将打印行移动到下一个垂直制表位。与 HT 字符一样，设备必须使用选项来达成关于垂直制表位位置的协议。 | 可选 |
| 12 | FF | 进纸 | 将打印机移动到下一页的顶部（或在显示器上，清除屏幕并将光标定位在顶部）。 | 可选 |
| 13 | CR | 回车 | 将打印机移动到当前打印行的左边缘。 | 强制 |

Telnet NVT 方案定义了回车（CR）和换行（LF）字符的组合来表示 ASCII 文本行的结束。这两个字符的字面意思是回到左边界（CR）和进入下一行（LF）。然而，NVT 将 CRLF 序列视为不仅仅是两个独立的字符；它们被整体地用来定义一个*逻辑行结束字符*。这是必要的，因为并非所有终端类型都使用 CR 和 LF 来定义行结束。在本地格式和 NVT 格式之间转换行结束字符是 Telnet 客户端和服务器软件必须执行的功能之一，以确保终端和主机之间的兼容性。

### 小贴士

**关键概念** Telnet NVT 格式基于 7 位 US-ASCII，每个字节携带一个字符。标准规定设备必须处理所有标准可打印 ASCII 字符，以及三个强制性的控制字符。其中两个是回车（CR）和换行（LF）字符；当组合在一起时，它们定义了文本行的逻辑结束。Telnet 标准还描述了五种其他可选 ASCII 控制字符的解释。

### 半双工和全双工模式

Telnet 时代的另一个遗迹是，为了实现最大兼容性，NVT 规范是在假设半双工操作的情况下设计的：一次只能有一个设备传输。发送数据的设备应该用特殊的 Telnet 前进命令结束其传输，告诉另一个设备现在可以传输（下一部分将描述 Telnet 协议命令）。这类似于使用对讲机的人在每个传输结束时说“Over”，告诉他们的伙伴现在可以回应。

当然，现代网络以全双工模式运行，使用半双工通信将是无谓的低效。在大多数情况下，Telnet 客户端和服务器同意使用一个选项（抑制前进）来消除发送此命令的需要。然而，将其作为默认设置是 NVT 在 Telnet 中充当最小公倍数的一个好例子，以防任一设备需要更简单的操作模式。

## Telnet 协议命令

用户在终端输入的大部分输入都是以数据和命令的形式发送给他们正在使用的应用程序。然而，计算机系统也提供了一种方法，用户可以通过它来指示终端发送某些命令，以控制终端本身的操作以及它与连接的计算机的交互。最好的例子是中断进程的命令，通常是通过在用户终端上按下特殊键或键组合来发送的。

Telnet 需要有一个方式允许用户输入这样的命令。然而，在这里我们遇到了在终端和计算机之间通信数据时出现的问题：表示的不一致性。虽然所有终端和计算机都支持中断正在运行程序的能力，例如，它们可能使用不同的按键来调用它。例如，在大多数 UNIX 系统中，ctrl-C 组合键可以中断程序，但在 Windows 系统上输入这个键组合将不会（它通常代表复制数据功能！）。

由于问题与我们在表示数据流时遇到的问题相同，因此解决方案相同并不令人惊讶：使用一组标准命令的通用表示，这些命令在终端和主机计算机之间传递。所有表示这些命令的按键都转换为标准 Telnet 代码进行传输，然后转换为主机计算机的特定需求。因此，如果用户在将 ctrl-C 定义为中断功能的 UNIX 终端上按下，而不是发送那个确切的按键，Telnet 客户端会发送特殊的 Telnet 中断进程命令，该命令由 Telnet 服务器转换为适合连接的主机的适当命令代码。

Telnet 标准包括一系列这些特殊代码，允许用户控制远程计算机的操作。它还定义了一组特定于 Telnet 协议本身的命令；这些命令允许 Telnet 客户端和 Telnet 服务器软件进行通信。这些统称为 Telnet *协议命令*。

所有 Telnet 命令都发送在与常规数据相同的通信流中。它们使用从 240 到 254 范围内的特殊字节值来表示。为了区分这些值的字节数据和 Telnet 命令，每个命令前面都有一个特殊的 *转义字符*，被称为 *解释为命令 (IAC)*。IAC 的值为 255；当接收方看到这个字符时，它知道下一个字节是命令，而不是数据。因此，由于 Telnet 中断进程命令的值为 244，要发送此命令，Telnet 客户端会传输字节 255 然后是 244。如果需要发送实际数据字节值 255，它将以两个 255 字节的形式传输。一些 Telnet 命令还包括额外的数据字节，这些数据字节在命令代码本身之后发送。一个很好的例子是在“Telnet 选项和选项协商”部分后面，您将看到的 Telnet 选项协商中使用参数。 

### 提示

**关键概念** Telnet 协议定义了一组*协议命令*，用于两个目的：首先，表示需要在终端和主机之间发送的标准控制功能，例如中断进程的命令，其次，使 Telnet 客户端和服务器软件之间的协议通信成为可能。协议命令在 Telnet 会话的 TCP 连接的正常数据通信流中发送。每个命令由 240 到 254 之间的字节值表示，并且由 Interpret As Command (IAC)命令（字节值 255） precedes，它告诉接收者流中的下一个字节是命令。

你可能会在这个时候想知道为什么 IAC 字符真的有必要。毕竟，Telnet 使用 US-ASCII，它是 0 到 127 字节范围内的 7 位数据，而 Telnet 命令的值高于 127。使用 IAC 转义字符的一般理由是明确表示正在发送命令。一个更具体的原因是适应通过 Telnet 发送可选的 8 位二进制数据，客户端和服务器可以协商此功能。如果启用此模式且命令不以 IAC 字符开头，则需要以某种方式标记所有值从 240 到 255 的数据字节，以便它们被解释为数据而不是命令。由于命令发送的频率较低，包含额外的命令字节比数据字节更有效。通过转义命令，只有数据字节值 255 需要发送两个字节。

表 87-2 按数值字节值顺序列出 Telnet 协议命令，显示每个命令的代码和名称，并描述其含义和使用方法。

表 87-2. Telnet 协议命令

| 命令字节值（十进制） | 命令代码 | 命令 | 描述 |
| --- | --- | --- | --- |
| 240 | SE | 子协商结束 | 标记 Telnet 选项子协商的结束，与 SB 代码一起使用以指定更具体的选项参数。有关详细信息，请参阅本章后面的“Telnet 选项和选项协商”部分。 |
| 241 | NOP | 无操作 | 空命令；不执行任何操作。 |
| 242 | DM | 数据标记 | 用于标记接收者应扫描以查找紧急 Telnet 命令的数据序列的结束。有关详细信息，请参阅下一节中关于 Telnet 中断处理的讨论。 |
| 243 | BRK | 断开连接 | 表示在终端上按下“断开连接”或“注意”键。 |
| 244 | IP | 中断进程 | 告诉接收者中断、中止、挂起或终止当前正在使用的进程。 |
| 245 | AO | 终止输出 | 指示远程主机继续运行当前进程，但丢弃其所有剩余输出。如果程序开始向用户发送意外大量数据，则可能需要这样做。 |
| 246 | AYT | Are You There | 可能用于检查远程主机是否仍然“活跃”。当发送此字符时，远程主机会返回某种类型的输出以指示它仍在运行。 |
| 247 | EC | Erase Character | 指示接收方删除数据流中最后一个未删除的字符。用于撤销发送字符。 |
| 248 | EL | Erase Line | 告诉接收方删除从最后一个换行符（CRLF）序列（但不包括）回的数据流中的所有字符。 |
| 249 | GA | Go Ahead | 在 Telnet 半双工模式下使用，以向其他设备发出可以传输的信号。 |
| 250 | SB | Subnegotiation | 标记 Telnet 选项子协商的开始，当选项需要客户端和服务器交换参数时使用。有关完整描述，请参阅本章后面的“Telnet 选项和选项协商”部分。 |
| 251 | WILL | Will Perform | 在 Telnet 选项协商中，表示发送此代码的设备愿意执行或继续执行特定选项。 |
| 252 | WONT | Won't Perform | 在 Telnet 选项协商中，表示发送此代码的设备要么不愿意执行特定选项，要么现在拒绝继续执行它。 |
| 253 | DO | Do Perform | 在 Telnet 选项协商中，请求其他设备执行特定选项或确认对方执行该选项的期望。 |
| 254 | DONT | Don't Perform | 在 Telnet 选项协商中，指定对方不执行选项或确认设备对对方不执行选项的期望。 |
| 255 | IAC | Interpret As Command | 在前面描述中描述的命令值 240 到 254 前面。连续的两个 IAC 字节表示数据值 255。 |

也许具有讽刺意味的是，Telnet 命令不像在 Telnet 早期那样被广泛使用，因为许多我们之前讨论的兼容性问题现在不再存在。ASCII 已成为计算世界的标准字符集，因此许多如终止输出或中断进程的功能不再需要使用 Telnet 命令。然而，它们仍然被广泛用于内部 Telnet 操作，如选项协商。

## Telnet 中断处理

从 Telnet 客户端发送到服务器的所有数据字节都是按照发送的顺序接收的，反之亦然。这是我们期望应用程序运行的方式。实际上，确保数据不会乱序接收是我们对可靠传输协议 TCP（Telnet 在其上运行）所承担的一项工作。然而，由于 Telnet 以相同的方式在同一个连接上发送数据和命令，这可能会给 Telnet 带来问题。

这种问题最典型的例子是当用户需要中断一个进程时出现。假设你正在使用 Telnet 运行一个需要用户输入、处理输入并产生输出的交互式程序。当你愉快地输入时，你注意到已经有一段时间没有看到程序输出。这显然是由于编程错误或其他故障而挂起了。

如果你在一个直接连接的终端上使用该程序，你只需使用适合该终端的键或按键命令来中断或终止进程，然后重新启动它。相反，你正在使用 Telnet，所以你输入适当的按键，它被转换成特殊的 Telnet 中断进程命令代码（字节值为 244，前面是 Telnet 解释为命令代码，255）。

由于 Telnet 只使用单个流来传输命令和数据，因此该代码被放入 TCP 数据流中，以便发送到 Telnet 服务器。由于你输入了一段时间的数据，Telnet 中断进程代码将位于大量常规数据字节之后。现在远程进程已经停止读取这些数据，这意味着服务器的 TCP 接收缓冲区将开始填满。因此，中断进程命令将卡在缓冲区中，等待被读取。实际上，如果命令前面的数据字节足够多，服务器上的 TCP 缓冲区可能会完全填满，导致服务器关闭客户端的 TCP 发送窗口。这意味着中断进程命令将等待在客户端的出站 TCP 队列中，并且*永远不会*发送到远程主机！

我们需要的是一种方法，能够标记中断进程命令，以便无论其前面的数据字节数量如何，都可以发送到远程主机。如果你已经阅读了关于 TCP 的章节，你可能认为你已经阅读了关于该协议的一个特性，这个特性似乎非常适合这个问题，而且你是对的！TCP 紧急功能（在第四十八章 Chapter 48 中描述）允许重要数据被标记，以便它比常规数据具有优先级，这个过程有时被称为*带外信号*（因为信号在正常数据流之外）。Telnet 使用 TCP 的这个特性来定义它所说的*同步功能*。

当需要时，客户端通过发送特殊的 Telnet 数据标记（DM）协议命令来调用同步功能，同时指示其 TCP 层将该数据标记为紧急。携带此命令的 TCP 段中的 URG 位使其绕过 TCP 的正常流量控制机制，从而将其发送到远程主机。Telnet 服务器软件看到数据流中的同步，在其缓冲区中的所有数据中搜索，只寻找 Telnet 控制命令，如中断进程、中止输出和你在吗。然后立即执行这些命令。服务器继续搜索重要命令，直到看到数据标记命令为止。所有中间数据都被丢弃；它需要重新传输。在处理完数据标记后，服务器返回到正常操作。

服务器也可以在与其客户端设备上的用户通信时使用同步功能。例如，如果用户向服务器发送中止输出命令，她是在告诉服务器丢弃当前进程的所有剩余输出。服务器将停止发送该输出，并可以使用同步功能清除所有等待发送到客户端机器的未处理数据（因为它会导致数据被丢弃）。

### 小贴士

**关键概念** Telnet 协议命令与用户数据在同一数据流中发送，这意味着远程主机的问题可能会停止数据流，导致用户命令积压并且主机无法接收。由于这可能包括用户尝试解决主机问题的命令，这可能会成为一个严重的问题。为了缓解这种情况，Telnet 包含了 *同步功能*，它使用 TCP 的紧急数据传输功能强制接收关键命令，即使常规数据没有被处理。

## Telnet 选项和选项协商

基本的 Telnet NVT 规范通过定义每个 Telnet 客户端和服务器使用的通用数据表示和命令，解决了不同终端和计算机类型之间的兼容性问题。然而，这种通用表示的代价非常高：所有终端和主机的先进或特殊功能都被剥离。结果是，虽然每个人都能使用这种语言，但它并不能进行比基本对话更多的功能。

Telnet 的创造者认识到，虽然定义 NVT 作为确保跨设备兼容性的共同基础很重要，但同时也必须提供一种方式，让客户端和服务器能够同意使用更先进的通信方式。他们定义了一套 *Telnet 选项* 和一种机制，通过这种机制，Telnet 客户端和服务器可以 *协商* 他们想要使用的选项。

大多数 Telnet 选项用于提高设备之间数据传输的效率。例如，默认情况下，NVT 假设每个设备使用半双工操作，需要在每次传输后使用 Go Ahead 命令。然而，现在几乎所有硬件都支持全双工通信，因此设备通常会同意使用抑制 Go Ahead 选项来消除发送此字符的需要。同样，设备可以协商发送 8 位二进制数据而不是 Telnet NVT 的标准 7 位 ASCII 码。

Telnet 选项协商的过程在主 Telnet 标准文档 RFC 854 中以及配套文档 RFC 855，“Telnet 选项规范”中进行了描述。这些选项本身在单独的因特网标准集中进行了描述。其中一些与 RFC 854 和 RFC 855 同时发布；其他一些作为 Telnet 先前版本的组成部分在较早时定义；还有一些在多年后被添加。现在存在几十种不同的 Telnet 选项。互联网数字分配机构（IANA）维护了一个主列表，就像它维护其他 TCP/IP 参数一样。所有 Telnet 选项的最新列表可以在 IANA 网站上找到，网址为[`www.iana.org/assignments/telnet-options/`](http://www.iana.org/assignments/telnet-options/)。

### 常见 Telnet 选项

每个 Telnet 选项都使用一个十进制字节码来标识，其可能值为 0 到 254。值 255 保留用于扩展选项列表，以防需要超过 255 个选项。每个选项还与一个文本代码字符串相关联，这通常在协议讨论和诊断输出中用作代码号的符号。表 87-3 列出了一些更有趣的 Telnet 选项，并对每个选项提供了简要描述。

表 87-3. 常见 Telnet 选项

| 选项编号 | 选项代码 | 选项名称 | 描述 | 定义 RFC |
| --- | --- | --- | --- | --- |
| 0 | TRANSMIT-BINARY | 二进制传输 | 允许设备以 8 位二进制形式发送数据，而不是 7 位 ASCII 码。 | 856 |
| 1 | ECHO | 回显 | 允许设备协商各种不同的回显模式。（当你在一个终端上按下一个键时，你也期望看到你输入的字符作为输出出现在终端屏幕上；这被称为回显输入。） | 857 |
| 3 | SUPPRESS-GO-AHEAD | 抑制 Go Ahead | 允许不使用半双工模式的设备不再需要使用 Telnet Go Ahead 命令来结束传输。 | 858 |
| 5 | STATUS | 状态 | 允许设备请求 Telnet 选项的状态。 | 859 |
| 6 | TIMING-MARK | 定时标记 | 允许设备协商在数据流中插入一个特殊的定时标记，用于同步。 | 860 |
| 10 | NAOCRD | 输出回车符处理 | 允许设备协商如何处理回车符。 | 652 |
| 11 | NAOHTS | 输出水平制表符位置 | 允许设备确定用于输出显示的水平制表符位置。 | 653 |
| 12 | NAOHTD | 输出水平制表符处理 | 允许设备协商如何处理水平制表符，以及通过连接的哪一端处理。 | 654 |
| 13 | NAOFFD | 输出换页符处理 | 允许设备协商如何处理换页符字符。 | 655 |
| 14 | NAOVTS | 输出垂直制表符位置 | 用于确定用于输出显示的垂直制表符位置。 | 656 |
| 15 | NAOVTD | 输出垂直制表符处理 | 允许设备协商垂直制表符的位置处理。 | 657 |
| 16 | NAOLFD | 输出换行符处理 | 允许设备决定如何处理换行符字符。 | 658 |
| 17 | EXTEND-ASCII | 扩展 ASCII | 允许设备同意使用扩展 ASCII 进行传输，并协商其使用方式。 | 698 |
| 24 | TERMINAL-TYPE | 终端类型 | 允许客户端和服务器协商使用特定的终端类型。如果他们达成一致，这将允许服务器的输出根据用户使用的特定终端的需求进行理想化的定制。 | 1091 |
| 31 | NAWS | 协商窗口大小 | 允许通信终端窗口的大小。 | 1073 |
| 32 | TERMINAL-SPEED | 终端速度 | 允许设备报告当前的终端速度。 | 1079 |
| 33 | TOGGLE-FLOW-CONTROL | 远程流控制 | 允许在客户端和服务器之间启用和禁用流控制。 | 1372 |
| 34 | LINEMODE | 行模式 | 允许客户端一次发送一行数据而不是一个字符，通过将大量的小型 TCP 传输替换为少量的大型传输来提高性能。 | 1184 |
| 37 | AUTHENTICATION | 认证 | 允许客户端和服务器协商一种认证方法以安全连接。 | 1416 |

### 小贴士

**关键概念** Telnet NVT 规范确保所有使用 Telnet 的设备都能相互通信，但这是在最低级别上完成的通信。为了允许使用更复杂的格式和服务，Telnet 定义了一系列 *选项*。如果客户端和服务器都实现了特定的选项，它们可以通过 *协商* 过程来启用其使用。

### Telnet 选项协商

Telnet 选项协商的第一阶段是客户端和服务器决定是否启用特定的选项。Telnet 操作对称性的一个方面是，任何设备都可以选择启动一个选项的使用。启动设备可以指定它想要开始使用一个选项，或者它想要其他设备开始使用它。响应设备可以同意或不同意。只有当两个设备都同意使用该选项时，才能启用选项。

此协商是通过四个 Telnet 协议命令来执行的：WILL、WONT、DO 和 DONT。

要指定它想要开始使用一个选项，启动器将 WILL 命令发送到其他设备。响应设备可能有两种可能的回复：

**DO** 发送以表示同意启动器应使用该选项；然后它被认为是启用的。

**DONT** 发送以指定启动器不得使用该选项。

如果启动器希望其他设备开始使用一个选项，它将发送 DO 命令。该设备可能会以两种方式响应：

**WILL** 发送以指定响应设备将同意使用该选项；选项被启用。

**WONT** 发送以告知启动器，响应器将不会使用请求的选项。

Telnet 的对称性以及 DO 和 WILL 都可以用来启动协商或响应协商的事实，使得 Telnet 的选项协商可能变得复杂。由于任何设备都可以在任何时候启动选项的协商，如果两个设备同时尝试启用一个选项或各自持续响应对方的回复，这可能会导致确认循环。因此，Telnet 标准指定了 WHEN 使用 WILL 和 DO 命令的限制。一个是设备只能发送协商命令以请求更改选项的状态；它不能仅为了确认或加强当前选项的状态而发送 DO 或 WILL。另一个是，当设备收到请求开始使用它已经使用的选项时，它不应使用 DO 或 WILL 进行确认。

由于一个选项只能在两个设备都同意使用它的情况下被激活，因此任何设备都可以在任何时候通过发送这些命令之一来禁用选项的使用：

**WONT** 由设备发送，表示它将停止使用一个选项。其他设备必须以 DONT 作为确认进行响应。

**DONT** 由设备发送，表示它希望其他设备停止使用一个选项。其他设备必须以 WONT 响应。

### 小贴士

**关键概念** 任何设备都可以选择协商使用 Telnet 选项。发起者使用 WILL 命令来指定它想要开始使用特定选项；如果另一设备同意，它将响应 DO；否则，它发送 DONT。或者，发起者可以使用 DO 命令来指示它希望另一设备开始使用选项；如果该设备同意这样做，它将响应 WILL，如果不同意，则响应 WONT。任何设备都可以通过发送 WONT 或 DONT 命令在任何时候禁用选项的使用。

### 选项子协商

所述的 DO/DONT/WILL/WONT 协商仅用于启用或禁用选项。某些选项，如二进制传输选项（TRANSMIT-BINARY），要么是开启要么是关闭；在这种情况下，此选项协商就足够了。其他选项在启用后需要客户端和服务器交换参数以控制选项的工作方式。例如，TERMINAL-TYPE 选项需要客户端以某种方式向服务器发送终端名称。Telnet 允许客户端和服务器通过称为*选项子协商*的过程发送与选项相关的任意数量的数据。

设备通过发送一系列特殊的 Telnet 协议命令和数据开始子协商过程。首先，设备发送 SB（子协商）命令，然后是特定选项定义的选项号和参数，最后通过发送 SE（子协商结束）命令结束子协商数据。SB 和 SE 都必须在 Interpret As Command（IAC）命令字节之前。

让我们以终端类型协商为例。假设服务器支持此选项并希望客户端使用它。服务器通过发送 DO 命令开始选项协商：

```
IAC DO TERMINAL-TYPE
```

假设客户端同意，它将使用 WILL 命令响应：

```
IAC WILL TERMINAL-TYPE
```

现在终端类型选项已生效，但服务器仍然不知道客户端使用的是哪种终端。它可以通过发送此命令来提示客户端提供该信息：

```
IAC SB TERMINAL-TYPE SEND IAC SE
```

接收此选项子协商命令的客户端将使用以下方式响应：

```
IAC SB TERMINAL-TYPE IS <*`some_terminal_type`*> IAC SE
```

### 小贴士

**关键概念** WILL 和 DO 命令仅用于开启客户端和服务器同意使用的 Telnet 选项。在某些情况下，选项需要在客户端和服务器设备之间发送额外的信息才能正常工作。这是通过一个称为*选项子协商*的过程来实现的。任何设备都可以通过发送包含 SB（子协商）和 SE（子协商结束）Telnet 协议命令的数据集来向另一设备发送与选项相关的数据。

# 伯克利远程（r）命令

TCP/IP 之所以取得成功，在很大程度上是由于其通用性——它几乎在所有主要的计算平台上都得到了实现。虽然该套件因此并非针对任何特定的操作系统，但不可否认的是，它的历史与 UNIX 紧密相连。早期互联网上的大多数计算机都使用 UNIX，TCP/IP 的发展在许多方面与 UNIX 的发展并行。

在 UNIX 开发中起着重要作用的组织之一，因此间接地影响了 TCP/IP 的发展，是加利福尼亚大学伯克利分校（UCB）。USB 开发的知名*伯克利软件发行版（BSD）* UNIX 已经广泛使用超过 20 年。他们还为 BSD UNIX 开发了一套命令，以方便在 TCP/IP 互联网上进行各种远程操作功能。这些程序都以字母*r*（代表远程）开头，因此它们被称为*伯克利远程命令*（或实用程序）以及简单地称为*r 命令*。自从它们最初创建以来，它们已经被大多数 UNIX 变体和一些其他操作系统所采用。

### 小贴士

**背景信息** *这一部分对于那些对 UNIX 操作系统有一定了解的人来说可能更容易理解，而对于那些没有了解的人来说可能就不那么容易理解了*。

## 伯克利远程登录（rlogin）

伯克利远程协议家族的头部是远程登录命令，`rlogin`。正如其名明显暗示的那样，该程序的目的允许 UNIX 主机上的用户通过 TCP/IP 互联网登录到另一台主机。由于 Telnet 也经常用于远程登录，因此`rlogin`和 Telnet 有时被认为是 TCP/IP 远程登录的替代品。虽然它们可以以类似的方式使用，但在一些方面它们是相当不同的。

从概念上讲，Telnet 被设计成一种协议，以实现终端/主机通信。正如我在本章前面的 Telnet 概述中提到的，该协议并非专门为远程登录而设计。相比之下，`rlogin`旨在实现这一特定目的，这在它的操作中得到了体现。

该协议要求在将要允许远程访问的主机上运行`rlogin`服务器软件；它通常被称为`rlogind`（对于`rlogin` *守护进程*，后一词是标准 UNIX 术语，指后台服务器进程）。服务器监听 TCP 端口 513 上的传入连接请求。想要远程登录到服务器的用户在其本地主机上运行`rlogin`命令并指定服务器名称。客户端与服务器建立 TCP 连接，然后向服务器发送包含以下信息的字符串：

+   客户机上的用户登录名

+   用户希望在服务器上使用的登录名（这通常与客户端上的用户登录名相同，但并不总是如此）

+   控制信息，例如终端的类型和速度

服务器处理这些信息并开始登录过程。它通常会提示用户输入密码以登录到远程主机。假设密码正确，用户将登录到远程主机，并可以像本地连接的用户一样使用它。

从实际角度来看，`rlogin` 命令比 Telnet 简单得多；它不支持 Telnet 的完整命令结构，也不支持选项协商等能力。然而，它确实包括一组小命令。客户端能够向服务器发送一条关键信息：当前使用的终端窗口的大小。服务器能够通知客户端开启或关闭流量控制，请求客户端发送当前窗口大小，或者要求客户端清除服务器已发送的挂起输出，直到数据流中的某个特定点。

一些组织每天使用许多不同的 UNIX 主机，使用 `rlogin` 时需要不断输入密码可能有些繁琐。在这些系统中，管理员可以设置控制文件，指定主机名、用户名和密码的组合。如果设置正确，这允许授权用户使用 `rlogin` 自动远程访问主机，而无需输入登录名或密码。

如最初设计的那样，`rlogin` 是 TCP/IP 早期协议的一个经典例子，因为它强调的是简洁性和可用性而非安全性。这一点在前面描述的自动登录过程中尤为明显。`rlogin` 最初用于身份验证的方案被认为不足以满足现代 TCP/IP 互连网络，尤其是连接到互联网的网络。`rlogin` 的后续版本增加了更安全的授权方法。还有一个名为 `slogin`（代表 *secure login*）的新程序，它使用更强的身份验证和加密，旨在在新系统上取代 `rlogin`。

### 小贴士

**关键概念** 伯克利远程，或 *r* 命令，简化了 TCP/IP 互连网络中 UNIX 主机之间的远程操作。这个系列的基本命令是 *远程登录* 命令，`rlogin`，它允许一个主机上的设备访问并使用另一个主机，就像它本地连接到它一样。`rlogin` 常常被用作 Telnet 的替代品。在概念上和实际操作上，它都比 Telnet 简单。

## 伯克利远程壳（rsh）

当用户需要登录到服务器执行多项任务时，通常会使用 `rlogin`。然而，在某些情况下，用户只需要在远程主机上输入一条命令。使用 `rlogin`，用户需要登录到主机，执行命令，然后再次登出。这并不是一个巨大的不便，尤其是当正确配置了允许自动登录的配置文件时。然而，随着时间的推移，所有额外的登录和登出步骤都可能变得繁琐。为了方便起见，`rlogin` 的一个变体，称为 `rsh`（代表 *远程 shell*），允许用户访问远程主机并在其上执行单个命令，而无需进行登录和登出步骤。

### 注意

Shell 是 UNIX 中用来指代接受用户命令并在屏幕上显示输出的用户界面的标准术语。

`rsh` 命令基于 `rlogin` 并以类似的方式工作，但它围绕执行命令而不是建立持久的登录会话。远程主机上的服务器进程通常称为 `rshd`（代表 *远程 shell 守护进程*）并监听传入的 `rsh` 请求。当收到请求时，用户将通过与 `rlogin` 相同的机制登录。命令在远程主机上运行，然后用户会自动登出。

当使用自动登录时，`rsh` 最有用，这样程序就可以运行而无需用户输入登录名或密码。在这种情况下，程序可以使用 `rsh` 在远程主机上自动运行命令，而无需人工干预，这为 UNIX 用户打开了多种可能性。正常的 UNIX 用户界面概念，如 *标准输入（stdin）、标准输出（stdout）和标准错误（stderr）* 也适用于 `rsh`，因此您可以使用它来执行远程命令并将输出重定向到本地文件。例如，以下命令可以让用户获取主机服务器上其主目录的列表并将其存储在名为 remotelist 的本地文件中：

```
rsh <*`somehost`*> ls -l >remotelist
```

### 小贴士

**关键概念** `rsh`（远程 shell）命令类似于伯克利 `rlogin` 命令，但它不是在远程主机上打开登录会话，而是执行一个用户提供的单个命令。`rsh` 对于需要快速在远程主机上执行操作的用户非常有用，它还可以被其他程序用来自动化网络任务。

由于 `rsh` 基于 `rlogin`，所有适用于 `rlogin` 的担忧也与此相关，尤其是在安全方面。（我们真的不希望未经授权的用户在我们的服务器上运行命令！）与 `rlogin` 一样，`rsh` 的新版本支持比原始软件更先进的身份验证选项。同样，正如 `slogin` 是 `rlogin` 的一个更新、更安全的版本一样，有一个名为 `ssh`（代表 *安全 shell*）的程序在许多系统中取代了 `rsh`。

### 注意

*在某些系统上，如果* `rsh` *没有指定要执行的命令，则会建立交互式远程会话，就像输入了* `rlogin` *命令而不是* `rsh` *一样。

## 其他伯克利远程命令

`rlogin` 和 `rsh` 命令是伯克利 *r* 程序家族的通用成员，允许远程访问主机。为了补充这些，开发者还定义了一小部分特定的远程命令。这些命令本质上是一些常见 UNIX 功能的远程版本。然而，命令不是只应用于一个系统，而是在两个系统之间或整个 TCP/IP 网络上的所有系统之间使用。

所有这些命令都与 `rlogin` 一样基于 `rsh`。它们以相同的方式工作，但不是打开会话或将用户指定的命令传递给远程主机，而是执行特定功能。以下是最常见的这些远程命令：

**远程复制（**`rcp`**）** 这是 UNIX 复制 (`cp`) 命令的远程版本。它允许在本地主机和远程主机之间或两个远程主机之间复制文件。通常的语法基本上与常规 `cp` 命令相同，但源和/或目标被指定为位于远程主机上。`rcp` 命令可以像 FTP 一样使用，但更简单、功能更少。或者换句话说，`rcp` 相对于 FTP，就像 `rlogin` 相对于 Telnet。这不是一个完美的类比，但非常接近。

**远程运行时间（**`ruptime`**）** UNIX 命令 `uptime` 显示计算机自上次启动以来运行了多长时间，以及与其当前负载相关的信息。`ruptime` 是此命令的远程版本；它显示网络上每台机器的当前状态（运行或关闭），每台运行机器自上次启动以来运行了多长时间，以及其负载统计信息。

**远程谁（**`rwho`**）** 这是 `who` 命令的远程版本。`who` 命令显示运行其上的主机上所有登录的用户，而 `rwho` 命令显示网络上所有机器上登录的所有用户。

`ruptime` 和 `rwho` 命令都依赖于在联网机器上后台运行的 `rwhod`（远程谁守护进程）。这些进程会定期相互共享有关主机运行时间和每个系统登录用户的信息，因此当运行 `ruptime` 或 `rwho` 时可以快速显示。

在某些操作系统上，还可能实现其他远程命令。与 `rlogin` 和 `rsh` 一样，这些命令可能存在安全问题，而其他命令（如 `rwho`）可能存在效率问题。因此，在许多网络上，这些命令不再使用。

# 互联网中继聊天协议（IRC）

电子邮件（email）相对于传统邮件的主要优势是*速度*。不需要等待几天或几周才能将消息送达，它通常在几分钟甚至几秒钟内到达。这使得电子邮件对于大多数类型的信息传输来说比常规邮政服务更有用。然而，在某些情况下，送达速度不足以使电子邮件成为理想的通信机制。其中一种情况是，需要双方进行*对话*。

考虑到即使电子邮件可能非常快地送达，它也使用了解耦的通信模型。假设 Ellen 给 Jane 发送了一封电子邮件。消息可能在几秒钟内出现在 Jane 的收件箱中，但 Jane 可能不在那里阅读它。Jane 可能要过几个小时才能看到这条消息。然后 Jane 会向 Ellen 发送回复，而 Ellen 可能要过一段时间才能看到。如果他们讨论的主题需要几十次这样的迭代，那么完成交流可能需要很长时间。

在现实世界中，当然，我们大多数人永远不会用电子邮件进行这样的对话，而是更倾向于使用我们称之为电话的高科技通信设备。许多使用计算机的人意识到，如果两个人或更多人能够以类似电话对话的方式交互式地讨论问题，那将是有用的。在在线世界中，这通常被称为*聊天*，而第一个也是最重要的应用协议之一，旨在在 TCP/IP 中实现它，就是*互联网中继聊天（IRC）协议*。

在互联网广泛使用之前，拥有计算机的人通常会通过拨号进入公告板系统（*BBS*）或其他专有服务进行通信。IRC 最初是由一位名叫 Jarkko Oikarinen 的芬兰人创建的，基于他在 BBS 上的聊天应用经验。他在 1988 年编写了第一个客户端和服务器软件。该协议后来在 1993 年 5 月正式定义在 RFC 1459，“互联网中继聊天协议”中。2000 年 4 月，IRC 标准经过修订和增强，增加了几个新的扩展功能，并作为一套四份较小的文档发布：RFC 2810 至 RFC 2813。这些文档中的每一份都专注于 IRC 功能的一个特定领域。

### 注意

*RFC 1459 具有实验性 RFC 状态，而 RFC 2810 至 RFC 2813 组被指定为信息性。这使得 IRC 成为可选的；它不需要在 TCP/IP 设备上实现*。

## IRC 通信模型和客户端/服务器操作

IRC 是一个有趣的协议，因为它并不严格基于 TCP/IP 协议操作的客户端/服务器模型。*IRC 服务器* 是运行 IRC 服务器软件的 TCP/IP 机器。它们配置了允许它们相互建立 TCP 连接的信息。IRC 使用 TCP 是因为连接会维持很长时间，并且需要可靠的数据传输。服务器连接用于交换控制信息和用户数据，形成一个在应用层的逻辑 *IRC 网络*，这使得任何服务器都可以向任何其他服务器发送消息，使用中间服务器作为通道。服务器由 *IRC 运营商 (IRCops)* 管理，他们拥有特殊权限，可以确保网络上的一切运行顺利。

IRC 网络构成了 IRC 通信服务的骨干。用户可以通过在任何 TCP/IP 兼容设备上运行 *IRC 客户端* 软件来访问网络。用户输入网络上的一个服务器名称，并建立与该服务器的 TCP 连接。这会导致用户直接连接到一个服务器，从而间接连接到网络上的所有其他服务器。这使得用户可以向所有其他用户发送和接收消息，无论他们是否连接到用户的服务器或其他服务器。

## 消息和 IRC 频道

在 IRC 中最常见的通信类型是 *群组消息*，这是通过 *IRC 频道* 实现的。频道是一种虚拟的会议场所，有时也被称为 *聊天室*（尽管 IRC 纯粹主义者对使用该术语嗤之以鼻）。每个 IRC 网络都有数百甚至数千个不同的频道，每个频道都致力于特定类型的讨论，从严肃到滑稽不等。例如，一群对谈论气象学感兴趣的人可以建立一个名为 #weather 的频道，他们会在那里定期讨论气候学的各个方面和有趣的天气事件。

IRC 是一种本质上基于文本的协议（尽管也可以使用 IRC 客户端在用户之间传输任意文件，包括图像和可执行程序）。要在频道中通信，用户只需在 IRC 客户端程序中适当的位置输入文本，然后程序会自动将此文本发送给频道的每一位成员。IRC 网络实时处理这些消息的转发，从发送者连接的服务器到网络中的其他服务器，然后到那些服务器上的所有用户机器。当其他用户看到第一位用户的消息时，他们可以用自己的消息回复，这些消息反过来也会在网络中传播。每个 IRC 用户都会选择一个昵称（通常缩写为 *nick*），这就像是在连接到网络时用于通信的 *handle*。

IRC 还支持一对一的通信，这可以用于私人对话。要使用这种方法，用户只需要知道她想要与之交谈的另一个用户的昵称。她使用一个特殊的命令直接向该用户发送消息，该用户可以相应地回复。这不是一种安全的通信方式，因为消息没有被加密，并且它们会通过服务器传输，这些服务器可能会被监控。然而，在典型的 IRC 网络上流量如此之大，任何给定的消息不太可能被监控。

IRC 协议定义了一个丰富的命令集，允许用户执行基本功能，例如加入或离开频道、更改昵称、更改服务器、为频道设置操作模式等等。确切的命令集和可用功能既取决于用户使用的特定 IRC 客户端软件，也取决于 IRC 网络本身的功能。并非所有 IRC 网络都运行相同的协议版本。

## IRC 与现代互联网

由于它允许来自互联网任何地方的用户动态地相遇和共享信息，IRC 在 20 世纪 90 年代初变得非常流行。它就像一个基于文本的电话，但全球的用户不需要长途电话的费用。

IRC 最重要的一项特性是其开放性；它给每个人提供了自由，以他们认为最好的方式进行沟通。例如，每个 IRC 频道都有一个所有者，他拥有与频道使用相关的某些权利，包括决定谁应该被允许进入频道。这可能看起来是专制的，但 IRC 允许任何人立即启动一个新的频道并成为该频道的所有者，而无需事先注册或授权。这意味着如果你不喜欢某个频道的运行方式，你可以以最小的麻烦启动自己的频道。你不必遵守任何人的规则，除了服务器设定的规则（通常只是旨在防止滥用）。

同样的原则也适用于 IRC 网络。并不是只有一个单一的 IRC 网络；有几十个不同的网络。有些是大型、成熟的网络，可能有超过 100 个服务器和数千名用户；其他则是较小，专注于特定的兴趣领域或地理区域。任何人只要有硬件和软件，都可以设置自己的 IRC 网络，并且一些组织已经为自身使用设置了私有、专用的 IRC 服务器。

对于许多用户来说，IRC 被认为是被称为 *即时消息* 的相关交互式应用的最重要的祖先。这些服务由多个组织提供，包括美国在线（AOL）、雅虎和微软的 MSN。它们背后的理念与 IRC 非常相似。每个都允许一个用户发送的消息立即显示给另一个用户，尽管大多数服务主要关注用户之间的消息，而不是群组消息。即时消息在整体使用上已经超过了 IRC，这或许是由于像 AOL 这样的服务拥有庞大的用户群。然而，IRC 仍然被成千上万的爱好者每天广泛用于娱乐和商业目的。

# 第八十八章. TCP/IP 管理和故障排除工具及协议

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

本章关于应用协议的最后一部分与前面的章节略有不同。它不描述为最终用户设计的应用。相反，它讨论了一组 TCP/IP 故障排除工具和协议，这些通常是内部网络管理员的领域。尽管数百万人在每天使用 TCP/IP 时甚至不知道这些应用的存在——更不用说它们是如何工作的——但对于维护 TCP/IP 内部网络的人来说，它们至关重要。由于你们中的许多人学习 TCP/IP 是为了实施和管理这项技术，因此了解这些应用是如何工作的值得你们花时间。

在本章中，我概述了多种常用的软件工具，这些工具通常用于帮助设置、配置和维护 TCP/IP 内部网络。这些程序允许网络管理员执行诸如检查主机身份、验证两个主机之间的连接、检查设备之间的路由器路径、检查计算机配置以及查找域名系统（DNS）域名等功能。

本章的目标是解释故障排除工具的一般用途和功能，这样你们就会知道它们如何帮助你们管理 TCP/IP 网络。作为这些描述的一部分，我演示了在 UNIX 和 Windows 中调用每个工具的典型语法。由于软件实现的不同，你们需要查阅操作系统的文档，以了解每个程序在你们网络上的具体使用细节。在 Windows 系统上，尝试 `<`*`program`*`> /?` 来查看程序的语法；在 UNIX/Linux 上，尝试 `man <`*`program`*`>`。

### 小贴士

**背景信息** 许多在本节中描述的软件工具旨在管理其他 TCP/IP 协议的操作，例如互联网协议（IP）、域名系统（DNS）和动态主机配置协议（DHCP）。要充分理解这些实用程序的工作原理，你需要了解这些和其他关键 TCP/IP 协议的基础知识。特别是，这里讨论的一些实用程序使用互联网控制消息协议（ICMP）消息进行通信，因此我建议在继续之前熟悉 ICMP（在第二部分-6 中讨论）。

# TCP/IP 主机名称实用程序（hostname）

在诊断网络计算机问题时，最基本的一项任务是识别它。正如我们通常在见到某人时首先交换名字一样，管理员访问设备时采取的第一个行动之一是确定其名称，如果不知道的话。这是通过使用`hostname`实用程序来完成的。

你可能还记得我们在第三部分-1 中关于 TCP/IP 名称系统的讨论，其中提到主机命名有两种不同的方式。第一种方式是手动使用主机表或等效方式为设备分配平坦名称；这通常用于不会在公共互联网上访问的设备。第二种是在 DNS 中为设备分配域名。`hostname`实用程序可以用于这两种类型的命名主机，但它在每种类型中的功能略有不同。

在大多数系统上，包括 Windows 和许多 UNIX 实现，`hostname`实用程序非常简单。当你单独在带有无参数的行中输入该命令时，它会显示主机的完整名称。如果使用`-s`（短）参数并且主机名是一个完全限定的 DNS 域名，则仅显示节点的本地标签，而不是完整的域名；如果主机有一个平坦（非 DNS）名称，则`-s`参数没有效果。以下是一个简单的例子：

```
% hostname
fearn.pair.com
% hostname -s
fearn
```

`hostname`实用程序还旨在允许管理员设置主机的名称。这种语法的设置也很简单；你只需将主机名称作为参数提供，如下所示：

```
hostname <*`new-hostname`*>
```

然而，在大多数实现中，使用`hostname`命令设置设备名称的功能已被禁用或受限。在 Windows 系统中，控制面板中有一个特殊的小程序用于设置设备名称；尝试使用`hostname`设置它将导致错误消息。在 UNIX 中，系统超级用户可以使用`hostname`设置设备名称，但更常见的是通过其他方式完成，例如编辑配置文件`/etc/hosts`。如果为该主机分配的是简单的平坦名称，则管理员对其有完全控制权。然而，如果使用 DNS，则必须遵循注册名称的正确程序。

### 注意

*The* `hostname` *utility is not, strictly speaking, tied into the operation of DNS or other formal mechanisms for identifying a host. It simply displays what the administrator has set it to show. It makes sense for this to be set to the host's DNS name, but there may be exceptions, such as in small networks that might not use DNS*.

在大多数操作系统中，`-s` 参数是此命令支持的唯一参数。然而，并非所有 `hostname` 命令的实现都支持此参数。在某些实现中，如果您使用 `hostname -s`，系统可能会报告其主机名为 *–s*。在某些 Linux 系统中，`hostname` 工具包含一些额外的参数，允许以不同的方式显示主机名，以及一些其他功能，例如显示程序的版本号。

### 小贴士

**关键概念** 最简单、最基本的 TCP/IP 管理工具是 `hostname`，它返回运行它的主机名称。

# TCP/IP 通信验证工具（ping）

网络管理员被要求解决的最常见问题之一是两个主机无法通信。例如，企业网络中的用户可能无法从本地服务器检索他的文件，或者另一个用户可能难以加载她最喜欢的网站。在这些和类似情况下，诊断问题的第一步重要步骤是验证两台机器上的 TCP/IP 软件堆栈之间基本通信是否可行。这通常是通过使用 `ping` 工具或 IPv6 实现中的 `ping6` 来完成的。IPv6 版本的 `ping` 与 IPv4 ping 的工作方式非常相似，但 `ping6` 的选项和参数反映了 IPv6 中地址和路由的变化。

### 注意

*Some people say that* `ping` *is an acronym for Packet Internet Groper, while others insist that it is actually based on the use of the term to refer to a sonar pulse sent by a submarine to check for nearby objects. I really don't know which of these is true, but I prefer the second explanation. Consider that the utility works in a way similar to a sonar ping, and that it was originally written by a gentleman named Mike Muuss, who worked at the United States Army Ballistics Research Laboratory*.

`ping` 是最常用的诊断工具之一，几乎在每个 TCP/IP 实现中都有。它通常以命令行工具的形式实现和访问，尽管在某些操作系统中现在也有图形和基于菜单的程序版本。

## ping 工具的操作

ping 实用程序是使用互联网控制消息协议（ICMP）回声（请求）和回声回复消息实现的，这些消息专门为这种诊断用途而设计。当设备 A 向设备 B 发送 ICMP 回声消息时，设备 B 通过发送 ICMP 回声回复消息回传给设备 A。在 ICMPv6 中，即 ICMP 的 IPv6 版本，也存在相同的功能；ICMPv6 回声和回声回复消息在字段结构上仅与 IPv4 的略有不同。

这似乎表明 ping 将是一个非常简单的实用程序，它会发送一个回声消息并等待查看是否收到回声回复。如果是这样，这意味着两个设备能够通信；如果没有，这表明在两个设备之间的互联网上存在某个问题。然而，几乎所有 ping 实现都比这复杂得多。它们使用多组回声和回声回复消息，以及相当多的内部逻辑，允许管理员确定以下所有内容，以及更多：

+   两个设备是否能够通信

+   是否存在拥塞或其他问题，有时可能允许通信成功，但有时会导致失败，这被视为数据包丢失；如果是这样，丢失有多严重

+   在设备之间发送简单的 ICMP 消息需要多少时间，这可以指示主机之间的整体延迟，同时也表明是否存在某些类型的问题

## ping 的基本用法

ping 命令最基本的使用方法是仅输入命令本身，并带有主机的 IP 地址。几乎所有的实现也允许您使用主机名，它将被自动解析为 IP 地址。当您使用没有额外选项的实用程序时，它将使用默认值来设置参数，例如发送的消息大小、要发送的消息数量、等待回复的时间等。实用程序将向主机发送一系列回声消息，并报告是否收到每个消息的回复。如果看到回复，它还会指示接收响应所需的时间。当程序完成后，它将提供一个统计摘要，显示收到的回声消息中有多少百分比收到了回复，以及它们接收的平均时间。

### 注意

*虽然设备对 ping 命令无响应传统上被解释为通信问题，但这并不总是必然的情况。在当前提高安全意识的时代，一些网络被设置为不响应回声消息，以防止使用此类消息洪水的攻击。在这种情况下，ping 命令将失败，尽管主机可能非常可达*。

示例 88-1 展示了在 Windows XP 计算机上使用`ping`命令的例子（我的！），默认情况下，它发送四个 32 字节的回显消息，并在认为回显消息丢失之前允许四秒钟。我使用的是具有相当高延迟和偶尔丢包的卫星互联网连接。这对我不太理想，但有助于说明`ping`是如何工作的。

示例 88-1. 使用`ping`实用程序验证通信

```
D:\aa>ping www.pcguide.com
Pinging pcguide.com [209.68.14.80] with 32 bytes of data:

Reply from 209.68.14.80: bytes=32 time=582ms TTL=56
Reply from 209.68.14.80: bytes=32 time=601ms TTL=56
Request timed out.
Reply from 209.68.14.80: bytes=32 time=583ms TTL=56

Ping statistics for 209.68.14.80:
    Packets: Sent = 4, Received = 3, Lost = 1 (25% loss),
Approximate round trip times in milli-seconds:
    Minimum = 582ms, Maximum = 601ms, Average = 588ms
```

## 使用`ping`诊断连接问题的方法

大多数人发现使用默认设置的`ping`就足够满足他们的需求。实际上，这个实用程序可以以这种最简单的形式执行许多诊断检查。在许多情况下，你可以通过连续多次执行`ping`命令来诊断连接问题，通常从检查发送设备或接近发送设备的检查开始，然后向外扩展到观察到通信问题的其他设备。以下是一些如何使用`ping`的例子：

**内部设备 TCP/IP 堆栈操作** 通过对设备的自身地址执行`ping`操作，你可以验证其内部 TCP/IP 堆栈是否正常工作。这也可以使用标准的 IP 环回地址，127.0.0.1 来完成。

**本地网络连接** 如果内部测试成功，对本地网络上的另一台设备执行`ping`操作是个好主意，以验证本地通信是否可行。

**本地路由器操作** 如果本地网络没有问题，对设备使用的任何本地路由器执行`ping`操作是有意义的，以确保它正在运行且可访问。

**域名解析功能** 如果对一个 DNS 域名执行的`ping`操作失败，你应该尝试使用设备的 IP 地址来执行。如果那样可以工作，这表明可能存在域名配置或解析的问题。

**远程主机操作** 如果所有前面的检查都成功了，你可以尝试对一个远程主机执行`ping`操作，看看它是否响应。如果它没有响应，你可以尝试另一个远程主机。如果那个主机可以工作，那么问题可能实际上是在第一个远程设备本身，而不是你的本地设备。

### 小贴士

**关键概念** TCP/IP `ping`实用程序用于验证 TCP/IP 互联网上两个设备之间的通信能力。它通过一个设备向另一个设备发送 ICMP 回显（请求）消息，另一个设备以回显响应消息进行响应。这个程序在诊断许多连接问题方面非常有用，特别是如果用它来测试与不同位置的设备通信的能力。它还允许估计与另一个设备交换消息的平均往返延迟。

## `ping`选项和参数

除了前几节中描述的基本用法之外，所有`ping`实现都包含一些选项和参数，允许管理员微调其工作方式。它们允许 ping 用于更广泛的或更具体的测试类型。例如，`ping`可以设置为连续发送 Echo 消息的模式，以检查长时间内间歇性问题。您还可以增加发送消息的大小或它们的传输频率，以测试本地网络处理大量流量的能力。

与本章中描述的其他工具一样，`ping`程序的确切功能取决于实现。尽管 UNIX 和 Windows 系统通常包括许多相同的选项，但它们通常使用完全不同的选项代码。表 88-1 显示了在许多 UNIX 系统上为该工具定义的一些更重要选项，以及适当的选项参数。表 88-2 显示了典型 Windows 系统的`ping`选项。

表 88-1. 常见的 UNIX ping 实用工具选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-c <`*`count`*`>` | 指定应发送的 Echo 消息的数量。 |
| `-f` | 洪水模式；以高速发送 Echo 数据包以对网络进行压力测试。如果不小心使用，这可能会引起严重问题！ |
| `-i <`*`wait-interval`*`>` | 告诉工具在传输之间等待多长时间。 |
| `-m <`*`ttl-value`*`>` | 覆盖输出 Echo 消息的默认生存时间（TTL）值。 |
| `-n` | 仅输出数字；抑制 DNS 主机名的查找以节省时间。 |
| `-p <`*`pattern`*`>` | 允许指定一个字节模式，并将其包含在传输的 Echo 消息中。这可以用于诊断某些仅在特定类型传输中出现的奇怪问题。 |
| `-q` | 静默输出；仅在程序执行的开始和结束时显示摘要行，而抑制每个单独消息的行。 |
| `-R` | 告诉工具包含记录路由 IP 选项，以便可以显示 ICMP Echo 消息的路径。此选项并非所有实现都支持。使用下一节中描述的`traceroute`工具通常是一个更好的选择。 |
| `-s <`*`packet-size`*`>` | 指定要使用的输出消息的大小。 |
| `-S <`*`src-addr`*`>` | 在具有多个 IP 接口（地址）的设备上，允许从其中一个接口发送的`ping`命令使用其他接口中的一个地址。 |
| `-t <`*`timeout`*`>` | 指定超时时间，以秒为单位，在此之后`ping`工具将终止，无论已发送或接收了多少请求或回复。 |

表 88-2. 常见的 Windows ping 工具选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-a` | 如果目标设备指定为 IP 地址，则强制将地址解析为 DNS 主机名并显示。 |
| `-f` | 在出站数据报中设置不要分段位。 |
| `-i <`*`ttl-value`*`>` | 指定用于出站 Echo 消息的生存时间（TTL）值。 |
| `-j <`*`host-list`*`>` | 使用指定的松散源路由发送出站消息。 |
| `-k <`*`host-list`*`>` | 使用指示的严格源路由发送出站消息。 |
| `-l <`*`buffer-size`*`>` | 指定传输 Echo 消息中的数据字段的大小。 |
| `-n <`*`count`*`>` | 告诉工具发送多少个 Echo 消息。 |
| `-r <`*`count`*`>` | 指定使用记录路由 IP 选项和要记录的跳数。通常，使用`traceroute`工具（下一节将描述）更为可取。 |
| `-s <`*`count`*`>` | 指定使用 IP 时间戳选项来记录 Echo 和 Echo 回复消息的到达时间。 |
| `-t` | 连续发送 Echo 消息，直到程序被中断。 |
| `-w <`*`timeout`*`>` | 指定程序在放弃之前应等待每个 Echo 回复的时间长度，以毫秒为单位（默认为 4,000，即 4 秒）。 |

# TCP/IP 路由跟踪工具（traceroute）

`ping`工具对于检查两个设备是否能够相互通信非常有帮助。然而，它提供的关于两个设备之间发生情况的信息非常有限。如果`ping`显示完全无法通信或间歇性连接且传输数据丢失率很高，管理员需要了解 IP 数据报在跨越互联网传输时的具体情况。当两个设备相距很远时，这一点尤为重要，尤其是当你试图连接到公共互联网上的服务器时。

在我对 IP 数据报交付的概述中，我描述了当两个设备不在同一网络中时，它们之间发送的数据必须从一个网络传递到下一个网络，直到到达目的地。这意味着，每当从网络 A 的设备 A 向网络 B 的设备 B 发送数据时，它都会遵循一条路径，这条路径可能对每次传输都不相同。当出现通信问题时，能够检查两个设备之间数据的具体路径非常有用。为此，提供了一个特殊的路由跟踪工具，称为`traceroute`（在 Windows 系统中简称为`tracert`，这是 DOS 程序名旧八字符限制的遗留问题）。

这个程序的 IPv6 等价物被称为`traceroute6`，其工作方式与 IPv4 前辈非常相似。它显然使用 IPv6 数据报而不是 IPv4 数据报，并且被追踪设备的响应以 ICMPv6 超时和目标不可达消息的形式出现，而不是它们的 ICMPv4 对应消息。

## traceroute 工具的操作

与`ping`工具一样，`traceroute`使用 ICMP 消息实现。然而，与`ping`不同，`traceroute`最初并不是设计用来使用专门为路由跟踪而设计的特殊 ICMP 消息类型。相反，它巧妙地使用了旨在防止路由问题的 IP 和 ICMP 功能。

回想一下，IP 数据报格式包括一个生存时间（TTL）字段。该字段设置为数据报在必须丢弃之前可以转发的最大次数；它存在是为了防止数据报在互联网中无限循环。如果一个数据报必须因为 TTL 字段的过期而被丢弃，那么丢弃它的设备应该向发送丢弃数据报的设备发送 ICMP 超时消息。（这在第三十二章中有详细解释。）在正常情况下，这仅在存在问题时才会发生，例如路由器循环或其他配置问题。`traceroute`所做的是通过故意将测试数据报中的 TTL 值设置为太低，以至于无法到达其目的地，来强制路由中的每个路由器向它报告。

假设你拥有设备 A 和设备 B，它们通过路由器 R1 和 R2（总共三个跳数，即 A 到 R1，R1 到 R2，R2 到 B）相隔。如果你从设备 A 到设备 B 执行`traceroute`，以下是会发生的情况（参见图 88-1 值为 1，这将导致路由器 R1 丢弃它并向设备 A 发送 ICMP 时间超限消息。第二条消息的 TTL 值为 2，因此它将被丢弃并由路由器 R2 报告。第三条消息将穿过两个路由器并到达目标主机，设备 B，但由于消息是故意选择了一个无效的端口号，这将导致返回 ICMP 目标不可达消息。这些错误消息确定了设备 A 和 B 之间路由中设备的顺序。](httpatomoreillycomsourcenostarchimages288327.png.jpg)

图 88-1. `traceroute/tracert` 工具的操作 `traceroute` 工具通过强制设备报告带有故意设置为无效值的参数的路由数据报的失败来识别路由中的设备。在这里，设备 A 发送的第一条消息的生存时间 (TTL) 值为 1，这将导致路由器 R1 丢弃它并向设备 A 发送 ICMP 时间超限消息。第二条消息的 TTL 值为 2，因此它将被丢弃并由路由器 R2 报告。第三条消息将穿过两个路由器并到达目标主机，设备 B，但由于消息是故意选择了一个无效的端口号，这将导致返回 ICMP 目标不可达消息。这些错误消息确定了设备 A 和 B 之间路由中设备的顺序。

### 小贴士

**关键概念** `traceroute` 工具将 ping 的理念进一步发展，允许管理员不仅检查两个设备之间的通信，还可以看到这对设备之间所有中间设备的列表。它通过让发起主机发送一系列测试数据报，每个数据报的 TTL 值都设置为在路由上的每个设备上依次超时来实现。`traceroute` 程序还会显示从发送主机到目标设备之间与每个设备通信所需的时间。

## `traceroute` 工具的基本用法

示例 88-2 展示了在两个我经常使用的 UNIX 计算机之间发送的 `traceroute` 示例。我添加了 `-q2` 参数来将每跳的默认三个虚拟消息更改为两个，以便输出更适合页面。

示例 88-2. 使用 `traceroute` 工具进行路由跟踪

```
traceroute -q2 www.pcguide.com
traceroute to www.pcguide.com (209.68.14.80), 40 hops max, 40 byte packets
 1  cisco0fe0-0-1.bf.sover.net (209.198.87.10)  1.223 ms  1.143 ms
 2  cisco1fe0.bf.sover.net (209.198.87.12)  1.265 ms  1.117 ms
 3  cisco0a5-0-102.wnskvtao.sover.net (216.114.153.170)  8.004 ms  7.270 ms
 4  207.136.212.234 (207.136.212.234)  7.163 ms  7.601 ms
 5  sl-gw18-nyc-2-0.sprintlink.net (144.232.228.145)  15.948 ms  20.931 ms
 6  sl-bb21-nyc-12-1.sprintlink.net (144.232.13.162)  21.578 ms  16.324 ms
 7  sl-bb27-pen-12-0.sprintlink.net (144.232.20.97)  18.296 ms  *
 8  sl-bb24-pen-15-0.sprintlink.net (144.232.16.81)  18.041 ms  18.338 ms
 9  sl-bb26-rly-0-0.sprintlink.net (144.232.20.111)  20.259 ms  21.648 ms
10  sl-bb20-rly-12-0.sprintlink.net (144.232.7.249)  132.302 ms  37.825 ms
11  sl-gw9-rly-8-0.sprintlink.net (144.232.14.22)  23.085 ms  20.082 ms
12  sl-exped4-1-0.sprintlink.net (144.232.248.126)  43.374 ms  42.274 ms
13  * *
14  pcguide.com (209.68.14.80)  41.310 ms  49.455 ms
```

在这种情况下，服务器之间相隔 14 跳。注意，随着与发送设备距离的增加，经过的时间通常会增加，但由于任何两个设备之间延迟的随机元素，它并不一致（例如，第 10 跳的不一致的大值）。还要注意第七跳中的星号（*），这意味着在 TTL 值为 7 的第二次传输的超时期间没有收到任何响应。最后，第 13 跳没有任何报告。这台机器可能被配置为不发送超时消息。

在某些情况下可能会显示一些不寻常的结果。例如，`traceroute`程序可能会显示一个代码，如`!H`、`!N`或`!P`，分别表示收到针对主机、网络或协议的意外目的地不可达消息。根据实现，也可能存在其他错误消息。

## traceroute 选项和参数

与`ping`类似，`traceroute`可以使用 IP 地址或主机名。如果没有提供参数，将使用关键参数的默认值。在我使用的系统中，默认值是每个 TTL 值 3 个探测，最多测试 64 跳，数据包大小为 40 字节。然而，我的实现也支持许多选项和参数，以便我可以更好地控制工具的功能（例如，我在示例 88-2 中使用的`-q`参数）。UNIX 系统中可用的典型选项在表 88-3 中描述。Windows 中存在一组更小的选项，如表 88-4 所示。

表 88-3. Common UNIX traceroute Utility Options and Parameters

| 选项/参数 | 描述 |
| --- | --- |
| `-g <`*`host-list`*`>` | 指定用于跟踪的源路由。 |
| `-M <`*`initial-ttl-value`*`>` | 覆盖第一个发出的探测消息的初始 TTL 值的默认值 1。 |
| `-m <`*`max-ttl-value`*`>` | 设置要使用的最大 TTL 值。这限制了工具尝试跟踪的路由长度。 |
| `-n` | 仅使用数字地址显示路由，而不是同时显示 IP 地址和主机名。这通过节省工具在路由中的所有设备上执行反向 DNS 查找的需要来加快显示速度（ICMP 消息使用 IP 地址，而不是域名）。 |
| `-p <`*`port-number`*`>` | 指定用作探测消息目的地的端口号。 |
| `-q <`*`queries`*`>` | 告诉工具为路由中的每个设备发送多少个探测（默认为 3）。 |
| `-r` | 告诉程序绕过正常路由表，直接发送到连接网络上的主机。 |
| `-s <`*`源地址`*`>` | 在具有多个 IP 接口（地址）的设备上，允许设备在 `traceroute` 使用另一个接口时使用一个接口的地址。 |
| `-S` | 指示程序显示未收到回复的探测数量摘要。 |
| `-v` | 设置详细输出模式，告知用户在跟踪过程中接收到的所有 ICMP 消息。 |
| `-w <`*`等待时间`*`>` | 指定工具等待每个探测回复的时间长度，以秒为单位（典型默认值为 3 到 5 秒）。 |

表 88-4. 常见 Windows tracert 工具选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-d` | 仅使用数字地址显示路由，而不是同时显示 IP 地址和主机名，以便更快地显示。这在 UNIX 系统上的 `-n` 选项中相同。 |
| `-h <`*`最大跳数`*`>` | 指定用于跟踪的最大跳数（默认为 30）。 |
| `-j <`*`主机列表`*`>` | 使用指定的松散源路由发送出站探测。 |
| `-w <`*`等待时间`*`>` | 指定等待每个探测回复的时间长度，以毫秒为单位（默认为 4,000 毫秒，即 4 秒）。 |

# TCP/IP 地址解析协议工具 (arp)

在互联网中，所有设备都被视为在第三层虚拟连接，因为路由过程允许任何设备与任何其他设备通信。然而，远程网络上的设备无法直接通信。第三层的互联网通信实际上包括多个步骤，称为 *跳数*，这些跳数将数据从源传输到目的地。路由中的每个跳数都需要在成对的硬件设备之间发送数据，并且每次传输都必须使用第二层的硬件地址。由于 TCP/IP 使用第三层地址，这意味着每个跳数都需要将跳数的目标 IP 地址转换为硬件地址。这被称为 *地址解析*；为什么需要它以及用于它的方法在 第十三章") 中有详细解释。

在 TCP/IP 中，地址解析功能由恰如其分的名称地址解析协议（ARP）执行。当设备需要向具有特定 IP 地址的设备传输时，它可以使用 ARP 的请求/回复消息协议来找出与该 IP 地址对应的硬件设备。然而，每次这样的消息交换都需要时间和网络带宽，因此为了效率，每个设备都维护一个 ARP 缓存，这是一个包含 IP 地址和硬件地址之间映射的表。ARP 缓存表可以包含静态缓存条目的组合，这些条目是手动插入以供频繁访问的设备使用，以及动态条目，这些条目在请求/回复解析完成后自动插入。下次需要向 ARP 缓存表中的设备发送数据时，可以避免查找过程。

为了允许管理员管理此 ARP 缓存表，TCP/IP 设备包括一个 `arp` 实用程序。它具有以下三个基本功能，这些功能通过使用三个不同的命令版本（这一次，UNIX 和 Windows 中的命令版本是相同的）来调用：

**ARP 缓存表显示** 当使用 `-a` 选项与该实用程序一起使用时，它会显示 ARP 缓存表当前的内容。语法是 `arp -d <`*`主机名`*`>`。表中的每个条目都显示一个设备（接口）的 IP 地址和硬件地址对。通常，它还指示每个条目是静态的还是动态的。显示的确切格式因实现而异；一些程序显示 IP 地址，其他程序显示主机名，还有一些程序可能两者都显示。某些系统默认显示主机名，但允许使用 `-n` 选项来强制只显示 IP 地址（而不是名称）。

**ARP 缓存表条目添加** 此版本允许管理员创建一个新的手动 ARP 缓存表条目，将给定的主机名映射到指定的硬件地址。语法是 `arp -s <`*`主机名`*`>` <`*`硬件地址`*`>`。

**ARP 缓存表条目删除** 使用 `arp` 命令的 `-d` 选项可以从表中删除指定的缓存条目。某些实现允许添加另一个参数来指定应从缓存中删除所有条目。基本语法是 `arp -d <`*`主机名`*`>`。

### 小贴士

**关键概念** TCP/IP 的 arp 实用程序由管理员用于检查或修改主机的 ARP 缓存表，该表包含 TCP/IP 主机名和 IP 地址之间的映射。

某些软件版本也可能通过附加功能来补充这些基本命令。UNIX 系统上常见的附加选项是能够指定一个文件，从中可以读取缓存表条目，使用语法 `arp -f <`*`文件名`*`>`。与手动使用 `arp -s` 输入每个条目相比，这可以节省大量时间和精力。

注意，操作系统可能只允许授权用户访问可以更改 ARP 缓存表的选项。这一点在删除功能上尤为明显。

# TCP/IP DNS 名称解析和查找实用程序（nslookup、host 和 dig）

DNS 是 TCP/IP 互连网的一个关键重要部分，特别是现代互联网，因为它允许使用易于记忆的名称而不是令人困惑的数字地址来访问主机。DNS 操作涉及两种不同的主要设备类型：存储有关域的信息的 DNS 名称服务器和查询 DNS 服务器以将名称转换为地址以及执行其他必要功能的 DNS 解析器。

互联网用户持续使用 DNS 解析器将 DNS 名称转换为地址，但在正常情况下，它们总是间接调用的。每次用户在网页浏览器或文件传输协议（FTP）客户端等程序中输入 DNS 名称，或者在其他本章描述的实用程序（如`ping`或`traceroute`）中使用它时，解析器都会自动执行名称解析，而无需用户请求。因此，用户无需手动将 DNS 名称解析为地址。

然而，管理员经常需要手动执行 DNS 解析。例如，在解决问题时，管理员可能知道主机的名称但不知道其地址。在安全问题的案例中，地址可能出现在日志文件中，但主机名称可能未知。此外，尽管用户不需要知道定义 DNS 域的资源记录的详细信息，但管理员经常需要能够检查这些细节，以确保域设置正确。管理员还需要某种方式来诊断 DNS 服务器本身的问题。为了支持所有这些需求，现代 TCP/IP 实现配备了至少一个 DNS 名称解析和信息查找实用程序。在这里，我们将探讨三个这样的实用程序：`nslookup`、`host`和`dig`。

## `nslookup`实用程序

最常见的 DNS 诊断实用程序之一是`nslookup`（用于名称服务器查找），它已经存在很多年了。程序实现的细节取决于操作系统，尽管它们中的大多数在操作和设置上提供了相当相似版本。该实用程序通常可以在两种模式下使用：交互式或非交互式。

`nslookup`的非交互式版本是最简单的，当管理员只想快速将名称转换为地址或相反时，通常使用此版本。要运行此版本，使用以下简单的语法发出`nslookup`命令：

```
nslookup <*`host`* > [<*`server`*>]
```

在这里，`<`*`host`*`>` 可以是一个 DNS 域名，用于执行正常解析，或者它可能是一个 IP 地址，用于反向解析以返回相关的 DNS 域名。`<`*`server`*`>` 参数是可选的；如果省略，程序将使用发出命令的主机的默认名称服务器。示例 88-3 显示了 `nslookup` 的非交互式使用的一个简单示例。

示例 88-3. 使用 nslookup 工具进行 DNS 名称解析

```
D:\aa>nslookup www.pcguide.com
Server:  ns1-mar.starband.com
Address:  148.78.249.200

Non-authoritative answer:
Name:    pcguide.com
Address:  209.68.14.80
Aliases:  www.pcguide.com
```

这个示例是在我使用 Starband 卫星互联网服务的家用电脑上完成的，该服务配置为使用 Starband 的名称服务器 (`ns1-mar.starband.com`)。这里提供的答案被标记为 *非权威性*，因为它来自 Starband 名称服务器的 DNS 缓存，而不是 [www.pcguide.com](http://www.pcguide.com) 的 DNS 权威服务器之一。

### 注意

*也可以在非交互模式下指定一个或多个选项来修改查找行为。这些选项与表 88-5 中描述的由 `nslookup` set 命令控制的参数相同。它们通过在前面加一个破折号来指定。例如，`nslookup -timeout=10 www.pcguide.com` 将执行与示例 88-3 中相同的查找，但将超时时间设置为 10 秒*。

通过简单地不带参数发出命令名，可以选择 `nslookup` 的交互模式。这将导致程序显示当前默认名称服务器的 DNS 名称和地址，然后提供一个提示，管理员可以在其中输入命令。交互模式允许用户轻松地执行多个查找，而无需每次都输入 `nslookup`。更重要的是，它提供了更方便的控制方式，可以请求哪些类型的信息以及如何执行查找。

你通常可以通过在 `nslookup` 提示符下发出 `help` 或 `?` 命令来确定 `nslookup` 实现中可用的确切命令集。表 88-5 显示了大多数 `nslookup` 实现中通常可以找到的一些命令。

表 88-5. 典型的 nslookup 工具命令

| 命令和参数 | 描述 |
| --- | --- |
| `<`*`host`*`> [<`*`server`*`>]` | 查找指定的主机，可选地使用指定的 DNS 名称服务器。注意，这里实际上没有命令；你只需在命令提示符中直接输入名称即可。 |
| `server <`*`server`*`>` | 将默认服务器更改为 `<`*`server`*`>`，使用从当前默认服务器获得的信息。 |
| `lserver <`*`server`*`>` | 将默认服务器更改为 `<`*`server`*`>`，使用从初始名称服务器获得的信息；即，在启动 `nslookup` 命令时（在会话中当前名称服务器任何先前更改之前）系统默认的服务器。 |
| `root` | 将默认名称服务器更改为 DNS 根名称服务器之一。 |
| `ls [-t <`*`type`*`>] <`*`name`*`>` | 通过执行区域传输请求指定域名可用的信息列表。默认情况下，与域名关联的主机名和地址将被列出；可以使用 `-t` 选项将输出限制为特定记录类型。还可以定义其他选项。（大多数服务器将区域传输的使用限制为指定的从服务器，因此此命令可能对普通客户端不起作用。） |
| `help` | 显示帮助信息（通常是有效命令和选项的列表）。 |
| `?` | 与 `help` 相同（仅在某些系统上有效）。 |
| `set all` | 显示所有 `nslookup` 选项的当前值。 |
| `set <`*`option`*`>[=<`*`value`*`>]` | 设置一个选项以控制实用工具的行为。大多数实现包括相当多的选项，其中一些只需指定一个关键字即可控制，而其他选项则需要为选项指定一个值。例如，`set recurse` 告诉程序使用递归解析，而 `set norecurse` 关闭它。`set retry=3` 将重试次数设置为 3。 |
| `exit` | 退出程序。 |

`nslookup` 工具在 UNIX 和 Windows 系统上都得到了广泛部署，但该程序并非没有批评者。对其的投诉主要集中在它使用非标准的信息获取方法，而不是标准的解析例程。我也阅读过一些报告，称在某些情况下它可能会产生虚假的结果。命令的一个重大问题示例是，如果它无法执行其自身 IP 地址的反向查找，它将终止。这可能会造成混淆，因为用户会将该错误误认为是试图查找他们正在查找的名称时发生的错误。因此，出于这个和其他原因，UNIX 圈中的一些人认为 `nslookup` 是一种某种形式的黑客行为。在一些较新的 UNIX 系统中，`nslookup` 已被弃用（为了兼容性仍包含在操作系统中，但不推荐，未来可能会被移除）。取而代之的是，提供了一对较新的实用工具：`host` 和 `dig`。

## `host` 实用工具

`host` 工具最常用于简单的查询，例如通常使用 `nslookup` 的非交互模式执行的查询。它以与非交互式 `nslookup` 相同的方式调用：

```
host <*`host`*> [<*`server`*>]
```

输出与非交互式 `nslookup` 的输出类似，但更简洁。以下是一个示例：

```
%host www.pcguide.com
www.pcguide.com is an alias for pcguide.com.
pcguide.com has address 209.68.14.80
```

虽然 `host` 不支持交互式操作，但它包括一些选项，允许管理员获取使用 `nslookup` 交互模式所获得的信息。一些更常见的选项显示在 表 88-6 中。

表 88-6. 典型的 host 实用程序选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-d` | 打开调试模式。 |
| `-l` | 为域名提供完整的信息列表；这与交互式 `nslookup` 中的 `ls` 命令类似。这可以与 `-t` 选项一起使用，以仅选择域名中特定类型的资源记录。 |
| `-r` | 禁用请求中的递归。当指定此选项时，只有直接查询的服务器会返回任何信息；它不会查询其他服务器。 |
| `-t <`*`查询类型`*`>` | 指定对特定资源记录类型的查询，允许检索任何类型的 DNS 信息。 |
| `-v` | 使用详细模式输出（提供额外细节）。 |
| `-w` | 等待必要的响应时间（无超时）。 |

## `dig` 实用程序

`nslookup` 的第二种选择是 `dig`，代表域名信息探索者（可能是对 `ping` 命名来源的一种戏谑）。它与 `host` 命令不同，即使在最简单的方式下调用，它也提供了关于域的相当多的信息。它也相当复杂，具有大量选项和功能，例如用于获取多个域信息的批处理模式。

`dig` 命令的基本语法与 `nslookup` 和 `host` 不同。如果您指定了一个非默认的名字服务器，它将以一个符号 `@` 开头，并在要查询的主机之前。您还可以指定特定的资源记录类型，如下所示：

```
dig [@<*`server`* >] <*`host`* >  [<*`type`* >]
```

示例 88-4 展示了在同一个域名 ([www.pcguide.com](http://www.pcguide.com)) 上运行 `dig` 的输出，我将其用作 `nslookup` (示例 88-3) 和 `host` 的示例。您可以看到它提供了关于域的更多信息。

示例 88-4. 使用 nslookup 实用程序进行 DNS 名称解析

```
%dig www.pcguide.com
; <<>> DiG 9.2.1 <<>> www.pcguide.com
;; global options:  printcmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 15912
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0
;; QUESTION SECTION:
;www.pcguide.com.               IN      A

;; ANSWER SECTION:
www.pcguide.com.        3600    IN      CNAME   pcguide.com.
pcguide.com.            3600    IN      A       209.68.14.80

;; AUTHORITY SECTION:
pcguide.com.            3600    IN      NS      ns0.ns0.com.
pcguide.com.            3600    IN      NS      ns23.pair.com.

;; Query time: 1840 msec
;; SERVER: 209.68.1.87#53(209.68.1.87)
;; WHEN: Tue Nov 18 16:05:08 2003
;; MSG SIZE  rcvd: 109Server:  ns1-mar.starband.com
```

### 注意

*`dig` 实用程序非常有用，但仍然没有在一些系统上实现。幸运的是，有一个在线的 `dig` 实用程序，您可以通过在互联网上的浏览器访问。在 [`www.gont.com.ar/tools/dig`](http://www.gont.com.ar/tools/dig) 找到它。*

`dig`命令包括数十个选项和设置。由于本章已经非常长，而`dig`是这三个工具中功能最强大的，我将在这里停止。请查阅您系统的文档，以获取有关`dig`如何工作及其参数列表的完整说明。

### 小贴士

**关键概念** 大多数 TCP/IP 实现提供了一到多个管理员可以使用的工具，这些工具可以手动将 DNS 域名解析为 IP 地址或执行相关的 DNS 信息搜索。其中最常见的是 nslookup，它允许将主机名翻译为地址或反之亦然；它具有交互和非交互两种模式。在某些操作系统上，nslookup 已被 host 实用程序替换用于简单的 DNS 查找，以及 dig 程序用于更详细地检查 DNS 资源信息。

# TCP/IP DNS 注册数据库查找实用程序（whois/nicname）

类似于`nslookup`和`host`这样的实用程序允许管理员将 DNS 域名解析为地址，并查看有关域名资源记录的详细信息。然而，在某些情况下，管理员需要知道其 DNS 注册信息，而不是域名的技术信息。这包括诸如哪个组织拥有该域名、其注册何时到期以及谁是被指定的管理联系人等详细信息。

在 DNS 的早期，所有域名都由一个称为互联网网络信息中心（InterNIC 或简称 NIC）的单一机构集中注册。为了允许互联网用户查找有关域名和联系人的信息，InterNIC 建立了一个特殊的服务器。为了允许用户从该服务器检索信息，开发者创建了一个被称为`nicname`和`whois`的协议。它最初在 1982 年的 RFC 812 中描述，后来在 1985 年的 RFC 943 中进一步描述。随着时间的推移，`whois`这个名字已经成为了两个中的首选，并且它是今天用于允许管理员查找 DNS 注册数据的实用程序的名称。（它也可以用来查找有关 IP 地址的信息，但用于此目的的频率要低得多。）

随着互联网的增长和扩展，它逐渐摆脱了单一集中授权的状态。现代互联网有一个负责在不同 DNS 名称空间部分注册域名的权威机构的分层结构。近年来，由于允许为通用顶级域名（如.COM、.NET 和.ORG）设立多个注册机构的不规范过程，这变得更加复杂。所有这些都意味着查找域名注册信息需要更多的工作，因为这些信息分布在不同的服务器上的许多数据库中。

为了让管理员更容易在这个大型分布式数据库中找到有关域的信息，现代 TCP/IP 实现通常附带一个智能版的`whois`工具。它能够接受域名作为输入，并自动定位包含该域名信息的适当注册机构。该工具通常按以下方式使用：

```
whois [-h <*`whois-host`* >] <*`domain`*>
```

在这个语法中，`<domain>`表示请求注册信息的域名。管理员可以使用`-h`参数强制程序查询特定的 whois 服务器，但通常不需要这样做。一些实现还包括其他选项，可以用来将查询定向到特定的注册机构。

示例 88-5 展示了在 FreeBSD UNIX 机器上`whois`命令的示例输出（我已经删除了一些初步的一般信息和法律免责声明以缩短列表）。

示例 88-5. 使用 whois 程序进行 DNS 域名注册查询

```
%whois pcguide.com
Registrant:
  The PC Guide
  2080 Harwood Hill Road
  Bennington, VT 05201
  US

  ixl@fearn.pair.com
   +1.8025555555

Domain Name: PCGUIDE.COM

Administrative & Technical Contact:
  Charles Kozierok
  The PC Guide
  2080 Harwood Hill Road
  Bennington, VT 05201
  US

  ixl@fearn.pair.com
   +1.8025555555

Domain Name Servers:
  NS23.PAIR.COM
  NS0.NS0.COM

 Created:     August 25, 1997
Modified:     July  7, 2003
 Expires:     August 24, 2008

** Register Now at http://www.pairNIC.com/ **
```

在这种情况下，域名[pcguide.com](http://pcguide.com)的注册商是 pairNIC，这是 pair Networks 的 DNS 注册部门，我多年来（自 1997 年以来，如你所见）一直在使用的公司。这个输出是公开信息，让任何对 pcguide.com 感兴趣的人都能确定我拥有该域名，并了解如何联系我。（不，555-5555 不是我的真实电话号码。）它还告诉他们，pair Networks 运行包含我的域名信息的名称服务器。

许多操作系统，包括 Windows，都没有附带`whois`命令的实现，但有一些第三方程序将支持该功能。近年来，许多不同的组织也建立了实施`whois`功能的网站，对于那些更习惯于 Windows 等图形用户界面操作系统的用户来说，这要方便得多。许多这些网站都是由 DNS 注册商提供的免费服务，因此客户可以检查他们感兴趣的名称是否已被占用，如果是的话，由谁占用。

这些系统的一些缺点是，它们通常没有智能地检查存储域名记录的所有不同注册机构。在大多数情况下，注册商提供的`whois`服务只会搜索注册商运营的特定顶级域名中的名称。因此，如果注册商处理.COM、.ORG 和.NET，它可能只支持那些顶级域的`whois`查询。要检查更不为人知的域名（如一些不太常见的地理政治（国家代码）域名）的注册信息，可能需要进行相当多的搜索。

### 小贴士

**关键概念** TCP/IP 的 `whois` 实用程序允许显示 DNS 域的注册信息，例如其所有者、联系信息和注册到期日期。该程序最常见于 UNIX 操作系统，其中它被赋予了智能，允许它自动查询正确的服务器以找到大多数域的信息。较新的基于 Web 的 `whois` 实用程序也存在，但它们通常仅限于显示特定顶级域子集的域信息。

# TCP/IP 网络状态实用程序（netstat）

考虑到 TCP/IP 的复杂性，实际上，大多数时候，所有不同的协议、服务和程序都能高效且无声地完成它们的工作，这实际上是非常令人惊讶的。我们大多数人甚至都没有意识到后台正在进行多少工作，而这正是应该如此。另一方面，当 TCP/IP 网络出现问题时，负责修复问题的管理员需要尽可能多地了解套件背后所有这些片段和部分都在做什么。网络状态实用程序 `netstat` 就是为了这个目的。

`netstat` 程序在概念上非常简单，它被设计为只有一个目的：显示设备上 TCP/IP 运行的信息。然而，TCP/IP 的复杂性使得 `netstat` 本身相当复杂。该程序可以提供大量信息。通常，`netstat` 的选项和输出取决于特定的操作系统类型和版本。在 UNIX 和 Windows 机器上有所不同，因此我将分别描述每个平台的版本。

## UNIX netstat 实用程序

在大多数 UNIX 系统上，`netstat` 实用程序功能非常全面，典型的实现包括数十个选项，可以用来控制显示哪些信息。这些选项可能不会同时使用；相反，它们被组织成选项组，每个选项组展示一类信息。在每个组内，一个选项是强制性的，即标识该组的选项，因此也会显示一般类型的信息。每个组内还可能有其他选项，它们是可选的，并修改命令以提供对输出的更好控制。本质上，`netstat` 就像许多相关实用程序合并为一个。

表 88-7 提供了典型 UNIX `netstat` 实现的选项组简化总结，在此例中为 FreeBSD。

表 88-7. 典型的 UNIX netstat 选项组、选项和参数

| 选项组、选项和参数 | 描述 |
| --- | --- |
| `netstat [-AaLSW] [-f <`*`family`*`>] [-p <`*`protocol`*`>] [-n]` | 默认的 `netstat` 调用，没有强制选项。它提示实用程序显示主机机器上的活动套接字列表。显示的其他选项可以用来控制精确输出内容；例如，`-a` 也会显示服务器进程。 |
| `netstat -i [-abdt] [-f <`*`family`*`>] [-n] netstat -I <`*`interface`*`> [-abdt] [-f <`*`family`*`>] [-n]` | 告诉 `netstat` 提供所有网络接口（`-i`）或特定网络接口（`-I <`*`interface`*`>`）的信息。`-a` 选项还显示多播地址，`-b` 显示接口上进出数据的字节数，`-d` 显示丢弃的报文数量，`-t` 显示看门狗定时器的值。 |
| `netstat -w <`*`interval`*`> -d [-I <`*`interface`*`>]` | 每 `<`*`interval`*`>` 秒显示所有接口的报文流量信息，或者如果包含 `-I <`*`interface`*`>`，则仅显示指定接口的信息。如果包含 `-d`，则还指示丢弃的报文数量。 |
| `netstat -s [-s] [-z] [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | 显示系统上每个协议的全局统计信息（可能修改为仅显示特定地址族或协议的信息）。如果重复使用 `-s` 选项，则抑制值为零的计数器。使用 `-z` 选项在显示统计信息后重置统计信息。 |
| `netstat -i -s [-f <`*`family`*`>] [-p <`*`protocol`*`>] netstat -I <`*`interface`*`> -s [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | 显示与 `netstat -s` 相同的统计信息，但基于每个接口而不是整个系统的汇总。 |
| `netstat -m` | 输出内存管理例程统计信息。 |
| `netstat -r [-Aa] [-f <`*`family`*`>] [-n] [-W]` | 显示主机的路由表内容。`-A` 和 `-a` 选项提供有关路由的附加信息。 |
| `netstat -rs [-s]` | 显示路由统计信息。`-s` 选项抑制值为零的计数器。 |
| `netstat -g [-W] [-f <`*`family`*`>]` | 显示多播路由信息。 |
| `netstat -gs [-s] [-f <`*`family`*`>]` | 显示多播路由统计信息。`-s` 选项抑制值为零的计数器。 |

大多数在 表 88-7 中的选项特定于这些组；例如，在发出 `netstat -i` 命令时不能使用 `-s`。然而，也有一些通用选项可以与这些组中的多个组合使用，以一致的方式修改 `netstat` 变体的行为。这些选项在 表 88-8 中描述。

表 88-8. 典型 UNIX netstat 通用选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-f <`*`地址族`*`>` | 限制命令的输出只显示特定协议地址族的信息，对于运行多个协议套件的宿主。例如，常规 TCP/IP 的地址族是 `inet`；对于 IPv6，它是 `inet6`。其他也可能被支持。 |
| `-p <`*`协议`*`>` | 限制输出只显示与特定协议相关的数据，例如 IP、TCP、UDP 或 ICMP。 |
| `-n` | 以数字形式显示网络地址，而不是以符号名称显示。还以数字形式显示端口号，而不是将已知的 UDP 和 TCP 端口号转换为使用它们的协议名称（例如，23 而不是 telnet）。 |
| `-W` | 禁止自动截断地址（有时为了显示格式而这样做）。 |

`netstat` 命令可以产生大量的输出，尤其是如果你没有使用 表 88-8 中的某些选项进行限制。这对于单独使用 `netstat` 以及使用 `-s` 选项尤其如此。示例 88-6 展示了运行 "plain" `netstat` 的样本输出，但我已经截断了连接列表，使其不会太长（我还重新格式化了列表，以便更好地适应页面）。注意最后一列，它显示了 TCP 连接的当前状态（参见 第四十七章 中的 TCP 有限状态机描述）。

示例 88-6. 来自 UNIX netstat 工具的样本连接列表

```
%netstat
Active Internet connections
Prot  Rcv  Snd  Local Address     Foreign Address       (state)
tcp4  0    0    pcguide.com.http  c-24-118-141-124.3384  ESTABLISHED
tcp4  0    827  pcguide.com.http  webcacheB03a.cac.46075 ESTABLISHED
tcp4  0    0    qs36.smtp         MV1-24.171.17.64.1339  ESTABLISHED
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1338  ESTABLISHED
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1337  FIN_WAIT_1
tcp4  0    84   pcguide.com.http  dial81-131-97-70.2902  FIN_WAIT_1
tcp4  0    0    pcguide.com.http  216.76.14.221.9954     FIN_WAIT_2
tcp4  0    0    pcguide.com.http  216.76.14.221.9945     FIN_WAIT_2
tcp4  0    0    pcguide.com.http  1Cust234.tnt1.le.1326  TIME_WAIT
```

示例 88-7 展示了 `netstat -s.` 的输出示例。在这里，我通过使用 `-p ip` 限制了输出，告诉程序只显示与 IP 相关的统计信息。

示例 88-7. 来自 UNIX netstat 工具的样本 IP 统计信息

```
%netstat -s -p ip
ip:
        57156204 total packets received
        0 bad header checksums
        4 with size smaller than minimum
        0 with data size < data length
        0 with ip length > max ip packet size
        0 with header length < data size
        0 with data length < header length
        0 with bad options
        0 with incorrect version number
        138 fragments received
        6 fragments dropped (dup or out of space)
        128 fragments dropped after timeout
        2 packets reassembled ok
        57085912 packets for this host
        24736 packets for unknown/unsupported protocol
        0 packets forwarded (0 packets fast forwarded)
        44957 packets not forwardable
        4 packets received for unknown multicast group
        0 redirects sent
        66183465 packets sent from this host
        177 packets sent with fabricated ip header
        0 output packets dropped due to no bufs, etc.
        0 output packets discarded due to no route
        0 output datagrams fragmented
        0 fragments created
        0 datagrams that can't be fragmented
        0 tunneling packets that can't find gif
        22 datagrams with bad address in header
```

## Windows netstat 工具

Windows `netstat` 工具比 UNIX 版本简单得多，因为它有更少的选项。这对于学习该程序的人来说是个好消息，但对于那些希望在使用它时获得最大功能和灵活性的人来说，可能就不是那么好了。

与 UNIX `netstat` 版本一样，Windows 工具有一组选项组，用于指定显示的一般信息类型，以及一些可以与多个组一起使用的通用选项。选项组和通用选项分别显示在 表 88-9 和 表 88-10 中。

表 88-9. 常见的 Windows netstat 选项组、选项和参数

| 选项组、选项和参数 | 描述 |
| --- | --- |
| `netstat [-n] [-o] [<`*`间隔`*`>] netstat -a [-n] [-o]` | 当不带强制选项调用时，`netstat` 显示有关活动 TCP 连接的信息。 |
| `[-p <`*`协议`*`> [<`*`间隔`*`>]` | 显示所有活动的 TCP 连接，以及主机正在监听的所有 TCP 和 UDP 端口。 |
| `netstat -e [<`*`间隔`*`>]` | 显示以太网接口的统计信息。 |
| `netstat -r [<`*`间隔`*`>]` | 显示设备的当前路由表。 |
| `netstat -s [-p <`*`协议`*`>] [<`*`间隔`*`>]` | 通过协议显示系统的 TCP/IP 统计信息。 |

表 88-10. 常见的 Windows netstat 通用选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-n` | 以数字形式显示网络地址，而不是符号名称形式。还以数字形式显示端口，而不是显示与知名 UDP 或 TCP 端口号关联的标准进程名称。 |
| `-o` | 显示与每个连接关联的进程 ID。 |
| `-p <`*`协议`*`>` | 限制显示仅与指定协议关联的信息。 |
| `<`*`间隔`*`>` | 使 `netstat` 命令每隔 `<`*`间隔`*`>` 秒重复一次，而不仅仅是显示其信息一次。这可以与任何 `netstat` 选项组一起使用。例如，`netstat -s 5` 每 5 秒显示一次 TCP/IP 统计信息。 |

当提供相同或类似选项时，Windows `netstat` 程序的输出与 UNIX 工具的输出相当相似，但 UNIX 版本通常提供更多详细信息。示例 88-8 展示了一个示例，说明如何在我的家用 Windows XP 机器上使用 `-p icmp` 限制输出仅显示 ICMP 统计信息。

示例 88-8. Windows netstat 工具的样本 ICMP 统计信息

```
D:\aa>netstat -s -p icmp
ICMPv4 Statistics
                            Received    Sent
  Messages                  243         248
  Errors                    0           0
  Destination Unreachable   9           4
  Time Exceeded             7           0
  Parameter Problems        0           0
  Source Quenches           0           0
  Redirects                 0           0
  Echos                     224         20
  Echo Replies              3           224
  Timestamps                0           0
  Timestamp Replies         0           0
  Address Masks             0           0
  Address Mask Replies      0           0
```

示例 88-9 展示了 `netstat`（我稍作修改以适应页面）的路由表显示。您可以使用 UNIX 的 `netstat -s -p icmp` 或 `netstat -r` 命令获得类似的输出，但包含更多信息。

示例 88-9. Windows netstat 工具的样本路由表显示

```
D:\aa>netstat -r
Route Table
=================================================================
Interface List
0x1 ........................... MS TCP Loopback interface
0x2 ...00 04 76 4e 75 3f ...... 3Com 10/100 Mini PCI Ethernet
=================================================================
=================================================================
Active Routes:
  Network Dest     Netmask          Gateway        Interface      Met
  0.0.0.0          0.0.0.0          148.64.128.1   148.64.133.73   30
  127.0.0.0        255.0.0.0        127.0.0.1      127.0.0.1       1
  148.64.128.0     255.255.192.0    148.64.133.73  148.64.133.73   30
  148.64.133.73    255.255.255.255  127.0.0.1      127.0.0.1       30
  148.64.255.255   255.255.255.255  148.64.133.73  148.64.133.73   30
  224.0.0.0        240.0.0.0        148.64.133.73  148.64.133.73   30
  255.255.255.255  255.255.255.255  148.64.133.73  148.64.133.73   1
Default Gateway:      148.64.128.1
=================================================================
Persistent Routes:
  None
```

### 小贴士

**关键概念** TCP/IP 实现包括 `netstat` 工具，以便显示有关网络状态的信息。在 UNIX 系统上，`netstat` 是一个功能齐全的程序，具有许多选项，这些选项被组织成选项组，每个选项组都显示有关 TCP/IP 协议操作特定类型的信息。在 Windows 系统上，`netstat` 的功能相对有限，但它仍然可以显示大量信息。

# TCP/IP 配置工具（ifconfig、ipconfig 和 winipcfg）

网络管理员工作的一个重要部分是设置和维护使 TCP/IP 网络功能的各种设备，这个过程通常被称为 *配置*。网络主机由硬件和软件组成，它们协同工作以实现协议栈的所有层和功能。管理员使用硬件工具来配置物理设备，执行安装网络接口卡、连接电缆、操作开关和其他硬件设置等任务。同样，管理员需要工具来配置运行 TCP/IP 接口并控制网络主机上高层协议操作的软件。UNIX 管理员使用 `ifconfig` 工具。在 Windows NT、2000 和 XP 上，配置工具是 `ipconfig`。Windows 的早期版本有 `winipcfg` 工具。

## UNIX 的 ifconfig 工具

在 UNIX 系统中，管理员使用接口配置工具 `ifconfig` 来查看和修改控制主机上 TCP/IP 功能的软件设置。这是一个非常强大的程序，允许管理员设置和管理非常广泛的网络设置。`ifconfig` 在不同类型的 UNIX 中的实现差异很大；虽然它们在一般术语上相似，但它们可能有不同的选项和语法。

您可以使用 `ifconfig` 程序进行各种目的：创建或删除网络接口、更改其设置，或者简单地检查现有配置。因此，像 `netstat` 工具一样，`ifconfig` 将几个相关程序合并为一个，其工作方式取决于您调用它的语法。同样，像 `netstat` 一样，`ifconfig` 有许多通用选项可以应用于其许多不同用途。

表 88-11 提供了 `ifconfig` 可以执行的不同功能以及用于在典型 UNIX 实现（本例中为 NetBSD）中指定每个功能的语法的简化总结。您可以使用 `ifconfig` 通过设置几十个配置参数之一来修改接口的配置，使用表中最后一行所示的语法。表 88-12 描述了可用于许多不同模式的常见选项和参数。我在 表 88-13 中提供了一些样本参数的简要说明（有关完整列表，请参阅您的 `ifconfig` 文档）。

表 88-11. 典型 UNIX ifconfig 语法、选项和参数

| 语法、选项和参数 | 描述 |
| --- | --- |
| `ifconfig [-L] [-m] <`*`interface`*`>` | 当仅使用接口指定（除 `-L` 和 `-m` 之外）调用 `ifconfig` 时，它显示该网络接口的配置信息。请注意，仅输入 `ifconfig` 而不指定接口将仅显示参数的帮助信息。要查看所有接口，请使用 `-a` 参数。 |
| `ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [<`*`family`*`>]` | 显示主机上所有接口的信息。可以使用显示的通用参数或指定地址族来限制输出（参见表 88-12). |
| `ifconfig -l [-b] [-d] [-u] [-s]` | 列出系统上所有可用的接口。 |
| `ifconfig <`*`interface`*`> create` | 在主机上创建指定的逻辑网络接口，然后使用此表中最后一行所示的语法进行配置。请注意，某些 UNIX 变体允许在创建时设置某些参数。 |
| `ifconfig <`*`interface`*`> destroy` | 销毁指定的逻辑接口。 |
| `ifconfig <`*`interface`*`> [<`*`family`*`>] [<`*`address`*`> [<`*`dest-address`*`>]] [<`*`parameters`*`>]` | 配置主机上特定接口的参数。如果正在设置地址，则它是可选地址族之后的第一个参数。`<dest-address>` 用于指定点对点链路的目标地址。之后，可以指定几十个参数来配置接口，其中一些在表 88-13 中显示。 |

表 88-12. 典型的 UNIX ifconfig 通用选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| `-L` | 显示 IPv6 地址的地址生存时间。 |
| `-m` | 显示接口支持的所有媒体。 |
| `-b` | 将接口信息显示限制为广播接口。 |
| `-d` | 仅显示当前处于关闭状态（禁用）的接口。 |
| `-u` | 仅显示当前处于开启状态（操作中）的接口。 |
| `-s` | 仅显示可能连接的接口。 |
| `<`*`family`*`>` | 指定特定的地址族，用于限制输出或指示正在配置的地址类型。值 `inet` 用于 IPv4，`inet6` 用于 IPv6。 |

表 88-13. 典型的 UNIX ifconfig 接口配置参数

| 参数 | 描述 |
| --- | --- |
| `alias / -alias` | 建立或删除网络地址别名。 |
| `arp / -arp` | 启用或禁用在此接口上使用 ARP。 |
| `delete` | 删除指定的网络地址。 |
| `down` | 将接口标记为已关闭，禁用它。 |
| `media <`*`type`*`>` | 将接口的媒体类型设置为特定值。 |
| `mtu <`*`n`*`>` | 设置接口的最大传输单元（MTU）。 |
| `netmask <`*`掩码`*`>` | 为接口地址设置网络或子网掩码。 |
| `prefixlen <*`n`*`>` | 与`netmask`相同，但允许使用 CIDR 风格的前缀长度来指定掩码。 |
| `up` | 设置接口为启用状态。 |

### 注意

*由于创建、销毁或修改接口可能导致主机无法正常工作，因此在大多数系统中，通常需要管理员（超级用户）权限才能使用`ifconfig`进行除检查现有配置之外的操作*。

示例 88-10 显示了我在使用的一台 UNIX 机器上`ifconfig -a`命令的示例输出，显示了其接口的设置。

示例 88-10. UNIX ifconfig -a 命令的示例输出

```
%ifconfig -a
fxp0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
  address: 00:a0:c9:8c:f4:a1
  media: Ethernet autoselect (100baseTX full-duplex)
  status: active
  inet 166.84.1.3 netmask 0xffffffe0 broadcast 166.84.1.31
  inet alias 166.84.1.13 netmask 0xffffffff broadcast 166.84.1.13
lo0: flags=8009<UP,LOOPBACK,MULTICAST> mtu 33228
  inet 127.0.0.1 netmask 0xff000000
```

## Windows NT、2000 和 XP 的 ipconfig

Windows 在网络配置方面与 UNIX 采取的方法略有不同。如前所述，您可以使用 UNIX 的`ifconfig`程序查看和修改广泛的配置参数。然而，在 Windows 中，大多数设置和参数修改都是通过 Windows 控制面板完成的。Windows 确实包含一个与 UNIX 的`ifconfig`类似的小工具，但它的功能远不如`ifconfig`，主要用于检查现有配置，而不是更改配置。它还允许管理员轻松地在主机上执行一些简单功能。

在 Windows NT、2000 和 XP 上，`ifconfig`的等效命令行实用程序是`ipconfig`。与`ifconfig`一样，Windows 实用程序通过提供给程序选项来控制。然而，由于它比`ifconfig`简单得多，因此只有少数选项，如表 88-14 中总结的。

表 88-14. 典型的 Windows ipconfig 选项和参数

| 选项/参数 | 描述 |
| --- | --- |
| (none) | 当不带选项或参数调用时，`ipconfig`显示主机上每个接口的 IP 地址、子网掩码和默认网关。 |
| `/all` | 与不带选项调用`ipconfig`类似，但显示有关主机接口的更详细配置信息。 |
| `/release [<`*`适配器`*`>]` | 释放（终止）指定适配器（接口）或所有接口的 DHCP 租约，如果没有提供则释放所有接口。 |
| `/`renew [<*`适配器`*`>]` | 手动续订指定适配器（接口）或所有适配器的 DHCP 租约，如果没有指定则续订所有适配器。 |
| `/displaydns` | 显示主机的 DNS 解析器缓存内容。 |
| `/flushdns` | 清除主机的 DNS 解析器缓存。 |
| `/re`gisterdns | 刷新（续订）所有 DHCP 租约，并重新注册与主机关联的任何 DNS 名称。 |
| `/showclassid <`*`适配器`*`>` | 显示与此适配器关联的 DHCP 类 ID（这些用于将客户端分组，以便 DHCP 服务器对它们进行不同的处理）。即使只有一个适配器，也必须指定适配器。 |
| `/setclassid <`*`适配器`*`> [<`*`classid`*`>]` | 修改指定适配器的 DHCP 类 ID。 |

如前所述，`ipconfig` 最常用于仅检查现有配置。您可以从 表 88-14 中的选项列表中看到，`ipconfig` 的其他大多数用途都与控制 DNS 和动态主机配置协议 (DHCP) 等协议的操作有关，而不是配置主机。`ipconfig` 的一个常见用途是强制主机寻找新的 DHCP 租约，这可以通过先使用 `ipconfig /release` 然后使用 `ipconfig /renew` 来完成。

示例 88-11 展示了使用 `ipconfig` 命令不带任何选项时的输出示例。要获取接口的详细信息，可以使用 `/all` 选项，如 示例 88-12 中的示例所示（我已经稍作修改以便更容易阅读）。

示例 88-11. Windows ipconfig 工具的简化配置信息

```
D:\aa>ipconfig
Windows IP Configuration

Ethernet adapter Local Area Connection 2:

        Connection-specific DNS Suffix  . :
        IP Address. . . . . . . . . . . . : 148.64.133.73
        Subnet Mask . . . . . . . . . . . : 255.255.192.0
        Default Gateway . . . . . . . . . : 148.64.128.1
```

示例 88-12. Windows ipconfig 工具的详细配置信息

```
D:\aa>ipconfig /all
Windows IP Configuration

   Host Name . . . . . . . . . . . . : ixl
   Primary Dns Suffix  . . . . . . . :
   Node Type . . . . . . . . . . . . : Hybrid
   IP Routing Enabled. . . . . . . . : No
   WINS Proxy Enabled. . . . . . . . : No

Ethernet adapter Local Area Connection 2:

   Connection-specific DNS Suffix  . :
   Description . . . . . . . . . . . : 3Com PCI Ethernet Adapter
   Physical Address. . . . . . . . . : 00-04-76-4E-75-3F
   Dhcp Enabled. . . . . . . . . . . : Yes
   Autoconfiguration Enabled . . . . : Yes
   IP Address. . . . . . . . . . . . : 148.64.133.73
   Subnet Mask . . . . . . . . . . . : 255.255.192.0
   Default Gateway . . . . . . . . . : 148.64.128.1
   DHCP Server . . . . . . . . . . . : 148.64.128.1
   DNS Servers . . . . . . . . . . . : 148.78.249.200
                                       148.78.249.201
   Lease Obtained. . . . . . . . . . : April 19, 2003 11:51:37 AM
   Lease Expires . . . . . . . . . . : April 19, 2003 12:21:37 PM
```

## Windows 95、98 和 Me 的 winipcfg 工具

Windows 95、98 和 Me 有一个名为 `winipcfg` 的图形工具，而不是 `ipconfig` 命令行工具。此程序允许您以与 `ipconfig` 相似的方式检查配置参数，并且还可以释放和更新 DHCP 租约，但它不支持 `ipconfig` 的其他选项（例如显示主机的 DNS 缓存）。图 88-2 展示了 `winipcfg` 主屏幕的一个示例。

### 小贴士

**关键概念** 在 UNIX 系统中，`ifconfig` 工具可以用来显示或修改大量 TCP/IP 配置设置。Windows 系统提供命令行工具 `ipconfig` 或图形工具 winipcfg。两者都允许管理员查看主机的 TCP/IP 基本配置信息，并允许执行诸如更新 DHCP 租约等任务，但与 UNIX 的 `ifconfig` 程序相比，它们在其他方面相当有限。

![Windows 95/98/Me winipcfg 实用程序 winipcfg 实用程序可用于较旧的面向消费者的 Windows 版本，以检查主机的配置并释放/续订 DHCP 租约。](img/httpatomoreillycomsourcenostarchimages288329.png)

图 88-2. Windows 95/98/Me winipcfg 实用程序 winipcfg 实用程序可用于较旧的面向消费者的 Windows 版本，以检查主机的配置并释放/续订 DHCP 租约。

# 多种 TCP/IP 故障排除协议

一旦你设置了网络，它将很快出现你需要解决的问题。认识到 TCP/IP 互连网络的复杂性会使诊断某些问题变得困难，该套件的架构师定义了一系列有助于测试和故障排除网络的杂项实用程序协议。尽管这些协议已经存在超过 20 年，但它们相对不为人知，并且很少受到关注。然而，尽管它们在许多系统中不再实现，但我认为它们值得快速查看。

这些简单的协议被设计为在 TCP/IP 服务器上运行的服务。每个服务都在一个专用的已知端口号上监听请求，然后以特定类型的信息进行响应。这些协议可以与 TCP 和 UDP 一起使用，使得每种传输协议都可以进行测试。在 UDP 的情况下，服务器将其收到的每个 UDP 数据报计为一个请求，并向其发送响应。当与 TCP 一起使用时，客户端首先与服务器建立连接。在某些协议中，这个连接随后被用来在客户端和服务器之间连续发送数据；在其他协议中，建立连接被视为向服务器的一个隐含请求，服务器将立即发送响应并关闭连接。

表 88-15 提供了这些故障排除协议在 UDP 和 TCP 下的简要描述。我为每个协议展示了服务使用的端口号以及定义它的 RFC。

表 88-15. 多种 TCP/IP 故障排除协议

| 协议 | 已知端口号 | 定义 RFC | 描述 |
| --- | --- | --- | --- |
| 回声协议 | 7 | 862 | 将接收到的数据回显给其发送者。当在 UDP 上使用时，每条消息的有效负载被简单地封装成一个返回的 UDP 数据报并发送回去。对于 TCP，服务器将回显客户端发送的每个字节，直到连接关闭。 |
| 丢弃协议 | 9 | 863 | 丢弃发送给它的所有数据。 |
| 字符生成器协议 | 19 | 864 | 生成随机数据字符并发送给设备。当与 UDP 一起使用时，每个发送到服务器的 UDP 消息都会导致它发送一个包含随机数量（0 到 512 字节）数据的 UDP 消息。当与 TCP 一起使用时，服务器在客户端建立连接后立即开始发送字符，直到客户端终止连接。 |
| 每日名言协议 | 17 | 865 | 向客户端设备发送一条简短的消息（由服务器管理员选择）。对于 UDP，对于每个传入的 UDP 消息都会发送消息；对于 TCP，在建立连接后，服务器发送一次消息，然后关闭连接。 |
| 活跃用户 | 11 | 866 | 向设备发送活跃用户列表。对于 UDP，对于每个传入的 UDP 消息都会发送列表；如果列表长度超过 512 字节，它将在多个消息中发送。对于 TCP，在连接到服务器时自动发送列表，然后终止连接。 |
| 白天协议 | 13 | 867 | 在接收到 UDP 消息或传入的 TCP 连接后，以人类可读的形式返回服务器上的当前时间。 |
| 时间协议 | 37 | 868 | 以机器可读的形式返回当前时间——具体来说，是自 1900 年 1 月 1 日凌晨以来经过的秒数。服务器接收到每个 UDP 消息或建立 TCP 连接时都会发送时间。请注意，此协议不能用于服务器的时间同步，因为它不补偿消息在互联网中传输所需时间的变化。 |
