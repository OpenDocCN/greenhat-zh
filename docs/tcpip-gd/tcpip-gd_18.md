# 第三部分-7. TCP/IP 电子邮件系统：概念和协议

第七十四章

第七十五章

第七十六章

第七十七章")

第七十八章

人类创造与已知系统相似的系统是很常见的。我们都习惯于使用常规的邮件系统，从我们的位置发送信件和其他文件到邮政系统服务的任何地方的收件人。自然地，互联网的第一个应用之一就是创建一个电子版本的这种传统邮件系统，以便以类似的方式发送消息，但更快、更方便。在许多年里，TCP/IP 的 *电子邮件系统* 被创建和改进。现在，它是世界上使用最广泛的电子消息手段。

在本部分中，我详细描述了 TCP/IP 电子邮件（电子邮件），分为五章，讨论了电子邮件概念以及构成整体 TCP/IP 电子邮件系统的各种组件和协议。第一章提供了 TCP/IP 电子邮件的概述，并讨论了其使用方式以及构成系统的不同协议和方法。第二章讨论了电子邮件消息的寻址方式，第三章涵盖了电子邮件消息的标准和特殊格式。第四和第五章描述了实现电子邮件功能的 TCP/IP 协议。这些包括负责电子邮件投递的简单邮件传输协议 (SMTP)，以及用于邮箱访问和邮件检索的几个协议和方法，包括邮局协议第 3 版 (POP3) 和互联网消息访问协议 (IMAP)。

本讨论主要关注现代互联网中用于电子邮件编写、投递和访问的机制。在 第七十四章 的电子邮件概述中，我提到了过去用于 TCP/IP 电子邮件的一些技术，但只是为了历史完整性，并且为了对比这些方法与目前使用的方法。

# 第七十四章。TCP/IP 电子邮件系统概述和概念

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

在 TCP/IP 协议套件中，电子邮件（email）并不是仅仅作为一个单一协议或技术来实现的。相反，它是一个完整的系统，包含了许多相互协作的相关组件。这些包括定义地址和消息格式的标准，以及一系列在实现电子邮件消息中扮演不同功能的协议。在深入考察这些各个部分之前，先对整个系统进行一个概述是有意义的。

在本章中，我提供了一个关于 TCP/IP 电子邮件的简介，以帮助您理解该系统、其工作原理以及不同组件如何融入其中。我首先概述了电子邮件及其在 TCP/IP 中的实现的历史，然后提供了电子邮件通信过程中涉及步骤的一般概述，最后更具体地讨论了 TCP/IP 中使用的通信模型以及各种 TCP/IP 设备和协议在发送和接收电子邮件中所扮演的角色。

# TCP/IP 电子邮件系统概述和历史

人类对沟通的需求与人类自身一样古老。几千年前，沟通几乎完全是局部的。消息主要是口头的，即使在书写时，也很少被送到很远的距离。大多数人从未离家太远，也很少与那些远离他们的人沟通。但在古代，领导者使用信使将一些关键信息从一地传到另一地。这很慢且不可靠，但有些消息的重要性足以使得尽管困难重重，沟通的努力仍然必须付出。

交通运输的进步导致了通信能力的进步，最终导致了物理邮件系统的创建。如今，这些系统已经发展到任何发达世界的人都可以给几乎任何人发送信件或包裹的程度。尽管人们经常对邮政服务开玩笑，但可靠性已经大大提高。速度也比以前好得多，现在消息到达目的地只需要几天，而不是几周或几个月。

在我们现代世界的标准下，等待消息从一个地方传到另一个地方甚至需要几天时间，这相当慢。因此，网络最自然的应用之一就是将它们用作替代物理运输消息的手段。将邮件从物理过程转变为电子过程带来了巨大的好处，包括极大地提高了通信速度，能够瞬间将一条消息发送给多个收件人，以及能够在收到消息后几乎立即获得反馈。

## 电子邮件的早期阶段

电子邮件背后的想法不仅与计算机网络一样古老，实际上它还早于互联网互连。最早的电子邮件系统是在传统的主机计算机上实现的。这些是单台大型计算机，许多用户可以通过连接的终端同时访问。主机上的电子邮件系统由一套在主机上运行的软件组成，实现了整个电子邮件系统。每个用户都有一个位于这台机器上的邮箱，邮件通过将消息从一个邮箱移动到另一个邮箱来传递。用户通过用户界面程序发送和接收邮件。

这样的早期电子邮件系统对本地通信很有用，但不适用于向另一个组织的人发送消息。主机电子邮件在某种程度上类似于一个城镇的居民向另一个居民发送的本地邮件。如果没有建立用于投递的基础设施，就无法向远方城镇的人发送邮件。

互联网互连的力量真正使电子邮件成为通用的通信方式。互联网互连将系统连接在一起，就像邮政服务的飞机和车辆将邮局连接在一起一样。邮件通过互联网的基础技术从用户发送到用户。由于 TCP/IP 是最常用的互联网互连协议套件，而现代互联网使用 TCP/IP 将全球的系统连接在一起，因此它是发送电子邮件的载体。

## TCP/IP 电子邮件的历史

与一些其他文件和消息传输协议一样，基于 TCP/IP 的电子邮件实际上可以追溯到 TCP/IP 和互联网正式存在之前。最早的电子邮件协议是在 ARPAnet 时代开发的。在电子邮件创建之前，一些互联网 RFC，如 RFC 95（是的，95，两位数——我们在这里回溯得很远）和 RFC 155，描述了在 20 世纪 70 年代初用于分发文件的物理邮寄名单。正是这种发送文件的需求，可能让 TCP/IP 先驱们意识到他们自己正在创造的技术——电子消息系统的有用性。

描述电子邮件的第一个互联网文件可能是 1971 年发布的 RFC 196。它描述了*邮箱协议*，这是一种使用 TCP/IP 前身非常基础的邮件传输方法。该协议是为了发送远程打印文档的特定目的而设计的。在当时，人们像今天一样在交互式终端上使用计算机并不常见，但通过电子方式发送文档的想法是相同的。邮箱协议在 1971 年进行了多次修订。

在 20 世纪 70 年代中期，开发者开始致力于在新兴的互联网上实施电子邮件的更全面的方法。最初，这种方法使用了许多现有的应用层传输协议来描述，包括文件传输协议（FTP）。1980 年，在 RFC 772 中发布了“邮件传输协议（MTP）”。这是今天 TCP/IP 电子邮件的第一个前身，它使用了 Telnet 协议以及 FTP 的原则。

在 20 世纪 70 年代电子邮件协议开发期间，主机系统之间正在使用各种技术交换邮件。其中最常用的方法是*Unix-to-Unix Copy Protocol (UUCP)*，它被设计用来允许文件在 UNIX 系统之间传输，将文件从一个连接的系统移动到下一个系统。UUCP 也被用于通信 Usenet 新闻组文章和其他文件。

1981 年，随着*简单邮件传输协议（SMTP）*的定义，现代 TCP/IP 电子邮件时代开始形成。SMTP 详细描述了邮件如何直接或间接地从一台 TCP/IP 主机传输到另一台，而无需使用 FTP 或其他文件传输方法。（SMTP 的详细历史和讨论请见第七十七章。）大约在同一时间，还创建了其他互补规范，这些规范正式化或定义了系统的其他组件和元素。我们将在本章的其余部分探讨这些拼图碎片。

## TCP/IP 电子邮件系统概述

现代电子邮件系统中的一个最重要的通用概念是，在互联网上 SMTP 主机之间传递电子邮件的协议和允许用户访问其本地主机上收到的邮件的协议之间做出区分。继续使用邮政邮件的类比，不同的协议用于在邮局之间发送邮件和进行家庭投递。正如您将看到的，这是有意为之，以便即使在发送邮件时用户未连接到互联网，也能将邮件发送给用户。这种解耦至关重要，因为它使得延迟通信成为可能，邮件可以在发送者想要传输时发送，在收件人想要阅读时接收。

### 小贴士

**关键概念** TCP/IP 应用中最重要之一是现实世界邮政投递系统的互联网等价物，通常称为*电子邮件*或*电子邮件*。电子邮件的历史可以追溯到 TCP/IP 发展的最早阶段。如今，每天都有数百万人在全球范围内使用电子邮件发送简单和复杂的信息。TCP/IP 电子邮件不是一个单一的应用程序，而是一个包含多个协议、软件元素和组件的完整系统。

多年来，1980 年代初定义的基本组件没有发生实质性变化，但它们的使用方式已经演变和改进。早期的电子邮件投递涉及一个 SMTP 主机使用路由规范来指定邮件将通过中间系统投递的方式；如今，域名系统（DNS）使许多这样的做法变得过时，大多数情况下促进了邮件的几乎即时直接投递。早期的电子邮件只支持简单的文本，但现在我们可以在电子邮件中发送图形图像、程序和其他文件附件。现代高速互联网连接和更新的访问协议使得电子邮件成为实现几乎瞬间通信终极目标的实现，即使跨越大陆。

# TCP/IP 电子邮件通信概述

你刚刚看到，TCP/IP 电子邮件被实现为一个完整的系统，其中包含多个执行电子邮件通信完整工作不同部分的功能元素。这些元素包括标准消息格式、特定语法用于收件人地址，以及用于投递邮件和允许间歇性连接的 TCP/IP 客户端访问邮箱的协议。

为了帮助为检查这些组件奠定基础，在此，我提供了电子邮件通信完整端到端过程的概述，以便你可以看到一切是如何工作的。我将以简化的形式展示基本步骤，并继续与常规邮件系统进行类比以进行比较。

现代 TCP/IP 电子邮件通信过程由五个基本步骤组成：

1.  **邮件编写** 用户通过创建电子邮件消息开始电子邮件之旅。消息包含两部分：正文和标题。消息的正文是实际要传达的信息。标题包含描述消息和控制其投递和处理的元数据。消息必须按照电子邮件系统的标准消息格式创建，以便可以处理（参见第七十六章）来完成的。这类似于在邮局或邮递员从邮箱中取出信封并将其带到当地邮局以加入邮件投递流程。

1.  **邮件投递** 邮件消息被发送方的本地 SMTP 系统接收，并通过邮件系统发送到目标用户。如今，这通过执行目标收件人主机系统的 DNS 查找并建立到该系统的 SMTP 连接来完成。SMTP 还支持指定一系列 SMTP 服务器，消息必须通过这些服务器传递才能到达目的地。最终，邮件到达收件人的本地 SMTP 系统。这就像通过邮政系统内部的“内部互联网”中的卡车、飞机和其他设备将信封运输到目标收件人当地的邮局。

1.  **邮件接收和处理** 本地 SMTP 服务器接收电子邮件消息并处理它。它将邮件放入目标收件人的邮箱中，等待用户检索。在我们的物理类比中，这是收件人当地的邮局对从邮政投递系统进入的邮件进行分类并将邮件放入单独的邮局箱子或箱子中以便投递的步骤。

1.  **邮件访问和检索** 目标收件人会定期检查其本地 SMTP 服务器以确定是否有邮件到达。如果有，收件人会检索邮件，打开它并阅读其内容。这是通过特殊的邮件访问协议或方法（见第七十八章）来完成的。为了节省时间，访问协议和客户端电子邮件软件可能允许用户扫描收到的邮件的标题（如主题和发件人身份）以决定下载哪些邮件消息。这类似于在邮局或家中收到的邮件被物理取出的步骤。

### 提示

**关键概念** TCP/IP 电子邮件通信通常涉及五个步骤，每个步骤都与通过邮政系统寄送普通信件的旅程的一部分相对应。首先，电子邮件被*撰写*（书写）；其次，它被*提交*到电子邮件系统；第三，它被*投递*到收件人的服务器；第四，它被*接收和处理*；最后，它被收件人*访问和检索*。

在某些情况下，并不是所有这些步骤都会被执行。如果一个用户是从已经是一个 SMTP 服务器的设备发送电子邮件，那么步骤 2 可以省略。如果收件人登录到一个也是 SMTP 服务器的设备，那么步骤 5 将被跳过，因为用户可以直接在服务器上阅读邮件。因此，在最简单的情况下，发生的事情只是撰写、投递和接收；这发生在一位拨号 UNIX 主机用户向另一位用户发送邮件时。然而，在当今大多数情况下，所有五个步骤都会发生。

# TCP/IP 电子邮件消息通信模型

整个电子邮件系统的目的是实现 TCP/IP 互联网用户向一个或多个收件人传输消息。为了实现这一目标，需要一种特殊的通信方法，这使得电子邮件系统与大多数其他协议所使用的系统大不相同。为了理解我所说的意思，只需考虑发送信件和打电话之间的通信差异。

在这方面，大多数 TCP/IP 协议都类似于打电话：发送者和接收者必须同时都在网络上。如果你打电话给某人，而他不在那里接电话，你就无法与他交谈。（当然，我在这里忽略自动应答机和语音邮件！）大多数 TCP/IP 协议都是这样的。例如，要使用 FTP 发送文件，你必须从发送者的机器直接连接到接收者的机器。如果接收者的机器在发送者机器不在网络上的确切时间不在网络上，则无法进行通信。对于电子邮件来说，这种立即的通信是不可接受的。

就像现实世界的平信一样，乔希望能够在对他来说方便的时候将消息放入系统，而艾伦希望能够在对她来说合适的时候接收乔的邮件。为了实现这一点，电子邮件必须使用“发送后忘记”的模式，就像真正的邮件一样，乔将“信封”投入电子邮件系统，它最终会到达目的地。

这种*解耦*发送者和接收者的设计对电子邮件系统至关重要。这一点尤其正确，因为许多互联网电子邮件用户并不是一直都在互联网上。就像你不会希望邮件在你不在家的时候被拒绝一样，你也不希望在你不在互联网上的时候邮件无法送达。同样，你可能不希望在写消息的整个时间内都连接到互联网，尤其是如果你每天只有有限的时间可以访问互联网。

对整个电子邮件系统来说，另一个关键的想法是通信是在特定的*用户*之间进行的，而不是在特定的机器之间。这使得电子邮件在 TCP/IP 互联网上的许多其他通信类型中具有固有的不同。当我们查看第七十五章（第七十五章。TCP/IP 电子邮件地址和寻址）中的电子邮件地址时，你会看到为什么这一点很重要。

为了允许电子邮件所需的通信类型，整个系统被设计成便于将电子邮件消息从一位用户延迟发送到另一位用户。为了了解这是如何工作的，让我们再次看看我们之前讨论过的示例通信——但这次，考虑一下交换中不同设备的作用（如图图 74-1

图 74-1. 电子邮件通信模型 此图展示了两个用户之间典型电子邮件通信中涉及的四个设备。每个设备由多个不同元素组成，这些元素通过黑色箭头所示的方式进行通信。请注意固有的不对称性，因为用户发送电子邮件的方法与从服务器检索它的方法不同。大号阴影箭头显示了一个典型的交易：发送者编写邮件，并将其发送到她的本地电子邮件队列。它使用 SMTP 发送到发送者的本地 SMTP 服务器，然后发送到接收者的 SMTP 服务器，进入该用户的收件箱。然后通常使用 POP 或 IMAP 等协议检索。

# 电子邮件通信中的协议角色

你可能已经注意到，SMTP 被用于这个通信过程的大部分。实际上，如果接收者使用运行 SMTP 软件的机器，这对于使用拨号 UNIX 外壳互联网访问的人来说很常见，发送电子邮件的过程将完全使用 SMTP。然而，SMTP 服务器必须始终在互联网上可用，并准备好接收邮件。大多数人使用的是不总是在线或没有运行 SMTP 软件的设备。这就是为什么最后一步，电子邮件访问和检索，通常需要。

可能有可能定义电子邮件系统，使得这个通信的最后一步也使用 SMTP 进行，这意味着整个系统使用相同的协议。然而，SMTP 是为了特定的目的——传输和交付电子邮件而量身定制的，而不是为了远程邮箱访问。将邮箱访问的功能留给专门的、独立的协议更有意义。这不仅允许这些协议根据电子邮件接收者的需求进行定制，而且还通过为用户提供多种检索电子邮件的方式提供了灵活性。我在第七十八章中讨论了电子邮件访问协议和方法，重点介绍了两种最常用的协议：POP 和 IMAP。

在这里讨论的三个协议——SMTP、POP3 和 IMAP——在 TCP/IP 电子邮件阶段占据主导地位，但它们依赖于两个其他元素来扮演支持角色。第一个是电子邮件消息的地址分配方法，以确保它们到达目的地。第二个是用于编码消息和控制它们传递和使用的消息格式集合。这些元素通常不会得到应有的关注，但在这里，我将在接下来的两个章节中专门讨论它们。

### 小贴士

**关键概念** 邮件系统的一个关键要求是，在发送邮件时，发件人和收件人不必都在系统中。因此，TCP/IP 使用了一种具有多个设备的通信模型，允许发件人和收件人*解耦*。当发件人的客户端设备准备好传输时，它会将邮件排队并将邮件移动到发件人的本地 SMTP 服务器；然后使用 SMTP 将邮件传输到收件人的 SMTP 服务器。邮件可以在收件人的服务器上保留不定的时间。当收件人准备好阅读时，他可以使用一组邮件访问协议和方法之一或多个来检索邮件，其中最流行的是 POP 和 IMAP。

# 第七十五章。TCP/IP 电子邮件地址和地址分配

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

电子邮件（email）的整个概念基于一个类比：发送电子消息就像发送纸质消息一样。这个类比很有效，因为电子邮件确实被设计成类似于普通邮件，只是具有技术时代的优势：速度和灵活性。

邮件和普通邮件之间许多相似之处之一是需要*地址*。为了使信息能够送达，发件人必须指定收件人并提供足够的信息，以表明收件人如何以及在哪里可以找到。在 TCP/IP 邮件中，使用标准的*电子邮件地址*格式来完成这项工作，同时也支持在某些特殊情况下可能使用的替代地址方案。

在本章中，我描述了电子邮件消息的地址分配方式。我首先讨论了 TCP/IP 中的标准电子邮件地址以及如何使用这些地址来确定邮件应该发送到哪里。然后，我简要讨论了您可能会偶尔遇到的历 史性和特殊电子邮件地址。我还讨论了电子邮件地址簿（别名）的使用以及如何为多个收件人分配地址，并提供了一个关于电子邮寄列表的概述，这是电子群组通信最早实现的方式之一。

# TCP/IP 电子邮件地址分配和地址解析

在互联网上的所有通信都需要一种方式来指定通信的预期接收者的身份。大多数应用协议，如文件传输协议（FTP）和超文本传输协议（HTTP），使用传统的 TCP/IP 结构——IP 地址和端口号——来指定要发送的信息的目的地。IP 地址通常标识一台特定的主机计算机，而端口号则表示在该计算机上运行的软件进程或应用程序。

然而，电子邮件使用的通信模型与大多数应用不同。正如你在前一章讨论电子邮件模型时所见，电子邮件与其他许多系统区分开来的一个要素是通信是*以用户为导向的*。电子邮件不是从一个机器发送到另一个机器，就像使用 FTP 传输文件一样。相反，它是从一个用户发送到另一个用户。这对于整个系统的运行至关重要。一方面，它允许某人从任何数量的不同客户端计算机检索发送的电子邮件。这使得接收者即使在旅行时也能接收电子邮件。

由于电子邮件消息是基于用户的，因此地址方案也必须是基于用户的。我们不能使用传统的 IP 地址和端口，因此我们需要一个独特的系统来指定两个主要信息：用户是谁以及用户在哪里。这些当然类似于普通邮件信封上的姓名和地址。

用户名的概念相对简单明了，但确定用户的位置则不然。在普通邮件中，地址指的是一个物理地点。本来可以以同样的方式定义电子邮件地址；也就是说，让电子邮件地址指向用户的客户端机器。然而，请记住电子邮件投递的另一个重要特征：它是间接的，基于用户的本地简单邮件传输协议（SMTP）服务器在可以检索之前保存收到的邮件的概念。用户用来访问电子邮件的机器甚至可能没有常规地连接到互联网，因此可能难以识别。我们还希望用户能够从多台机器访问电子邮件。

由于所有这些原因，我们希望地址能够识别的不是用户在任何特定时间的具体位置，而是用户永久邮箱所在的地方——在用户的 SMTP 服务器上，该服务器永久连接到互联网。

## 标准基于 DNS 的电子邮件地址

在 TCP/IP 中，用于识别服务器（和其他机器）的系统是 *域名系统 (DNS)*。DNS 是一个庞大的系统，本书的 第三部分-1 中有描述，如果您想了解更多，应该阅读这部分内容。现在，重要的是要意识到，在 DNS 中，互联网上的所有设备都被组织成一个设备命名层次结构，任何设备都可以使用由点号分隔的一系列文本标签组成的 *域名* 来识别。

完整的 TCP/IP 地址由两个部分组成：用户名指定和域名指定。这两个部分通过 at 符号 (@) 连接在一起，形成了我们今天熟悉的 TCP/IP 电子邮件地址语法：*<username>*@*<domainname>*。

*<domainname>* 的格式遵循 DNS（域名系统）的语法规则（见 第五十三章。如果特殊字符和空格被引号包围（或通过转义字符等方式标记为名称的一部分），则 *<username>* 中也可以包含其他特殊字符和空格。域名不区分大小写；用户名可能区分大小写，这取决于系统。

一个有效的电子邮件地址示例是 cmk@athena.mit.edu（这是我多年前在学校时使用的地址）。在这里，*cmk* 是我的用户名（我的首字母缩写）；*athena.mit.edu* 是我接收邮件的主机名称；而 *athena* 是麻省理工学院 *(mit)* 中的一个特定系统，这是一个使用 *.edu* 顶级域的教育机构。

还可以使用互联网标准的统一资源定位符 (URL) 来指定电子邮件地址。这允许在超文本（Web）文档中嵌入链接；当点击时，它会调用电子邮件客户端向用户发送邮件。电子邮件 URL 通过在地址前加上特殊的 URL 方案字符串 *mailto:* 来创建，如下所示：mailto:cmk@athena.mit.edu。

## 电子邮件地址的特殊要求

拥有一个电子邮件地址指向用户的本地 SMTP 服务器，与地址中提到特定客户端计算机相比，提供了很大的灵活性。但这不足以处理以下情况：

+   组织可能希望使用通用的地址，这些地址不指定处理电子邮件的 SMTP 服务器的名称，以便发送者或客户端更容易记住电子邮件地址。例如，如果某人知道我的真实姓名并且我知道我在麻省理工学院，那么他更容易记住我的电子邮件地址为 cmk@mit.edu，而不是记住 cmk@athena.mit.edu。

+   管理员可能会在一段时间内更改处理邮件的机器。这意味着所有用户的电子邮件地址也必须更改——而且我们都知道这是多么痛苦的事情。例如，如果我从 athena 机器移动到 jabberwocky 机器，我的旧地址需要更改为 cmk@jabberwocky.mit.edu。但如果是 cmk@mit.edu 这样的地址，服务器更改就不会影响地址。

+   在较大的组织中，可能希望有多个服务器分担处理传入电子邮件的负载。

为了满足所有这些要求，DNS 系统包括一个专门设计来支持电子邮件地址的功能。可以设置一个特殊的 *邮件交换 (MX)* 记录，指定特定域名到达时应使用哪个 SMTP 服务器。如果配置得当，这将为处理上述情况以及更多情况提供相当大的灵活性。有关更多详细信息，请参阅第五十六章 MX 记录和 DNS 电子邮件支持 的描述。

### 小贴士

**关键概念** 所有网络通信都需要某种形式的地址；由于电子邮件是 *面向用户* 的，因此电子邮件地址也是基于用户的。在现代 TCP/IP 电子邮件中，标准地址由一个 *用户名* 组成，它指定了收件人，以及一个 *域名*，它指定了用户所在的 DNS 域。为接受电子邮件的每个域名都设置了一个特殊的 DNS *邮件交换 (MX)* 记录，因此发送 SMTP 服务器可以确定它应该使用哪个 SMTP 服务器来发送邮件给特定的收件人。

假设，例如，我是 pcguide.com 域名的所有者。邮件可以发送到 pcguide.com，但实际上并不存储在任何以该名称命名的服务器上。相反，它被重定向到我的收件箱实际所在的真实服务器。这使得我可以处理所有发送到 pcguide.com 的邮件，无论我的邮箱实际位于何处。

DNS 也很重要，因为它的 MX 资源记录消除了将电子邮件从一台 SMTP 服务器中继到下一台以投递的需要。在现代 TCP/IP 中，可以直接从发送者的 SMTP 服务器发送电子邮件到收件人的服务器，这使得通信更快、更高效。这一点也在第五十六章 DNS 解析概念和解析器操作 中进行了讨论。

# TCP/IP 历史和特殊电子邮件地址

TCP/IP 电子邮件非常成功，可以说是全球电子消息传递最重要的标准。电子邮件的广泛应用与 TCP/IP 和互联网的整体应用紧密相连。由于大多数组织都希望成为互联网的一部分，他们连接到它并使用其技术，包括 DNS，这是 TCP/IP 电子邮件地址的基础。反过来，使用简单的 DNS 风格的电子邮件地址（*用户*@*域名*）鼓励了电子邮件的进一步使用，因为人们发现从概念上决定如何发送消息是容易的。

然而，TCP/IP 并不是唯一的电子邮件系统。多年来，已经发展了几个其他网络的电子邮件系统。由于互联网是世界上最大的互联网，TCP/IP 电子邮件经常被用作某种类型的清算所，以将这些不同的电子邮件机制连接起来。这被称为*网关*，它允许使用非 SMTP 电子邮件系统的人与使用 TCP/IP 的人进行交互，反之亦然。网关是复杂的，部分原因是因为电子邮件系统使用不同的方式来寻址邮件。让我们看看这些系统之一以及它们如何与 TCP/IP 交互。

## FidoNet 寻址

最早的独立电子邮件系统之一是*FidoNet*，它已经存在很长时间，并且至今仍在使用。FidoNet 是一个使用调制解调器和专有协议连接的全球网络；从本质上讲，它是全球 TCP/IP 互联网的“竞争对手”。我把*竞争对手*这个词放在引号里，因为 FidoNet 和 TCP/IP 互联网在用户数量和它们支持的应用类型方面并不真正可比，但它们在总体目标上相似：全球电子通信。

FidoNet 用户使用四个数字来识别，这些数字指定了 FidoNet 的*区域、网络、节点*和*点（连接点）*。这些寻址元素用于在该系统中发送邮件，这再次与 TCP/IP 完全不同。然而，为了允许 TCP/IP 和 FidoNet 之间的通信，FidoNet 管理员已经建立了一个网关系统，允许使用 TCP/IP 风格的域名发送邮件。这种映射方式也被其他具有专有邮件地址格式的系统所采用，以允许它们与互联网接口。

例如，如果一个用户在机器 4，节点 205，网络 141，区域 1（北美），FidoNet 地址将是 1:141/205:4。等效的域名将是 p4.f205.n141.z1.fidonet.org，并且可以用于 TCP/IP 风格的*用户*@*域名*寻址。

## UUCP 风格的寻址

与电子邮件相关联的一种较老的地址风格是 UUCP 风格的地址。*Unix-to-Unix Copy Protocol (UUCP)* 在 SMTP 广泛部署之前被广泛使用来路由邮件（再次强调，它仍然在使用，但不像以前那么普遍）。在这个系统中，地址被指定为由感叹号（!）分隔的主机路径。路径决定了邮件到达特定用户的路由，通过一系列运行 UUCP 的中间机器。例如，如果发送到 joesplace 主机上的 joe 的邮件必须通过三个主机——host1、host2 和 host3，那么地址将是 host1!host2!host3!joesplace!joe。由于感叹号的俚语是 *bang*，因此这种表示法被称为 *bang path* 表示法。

当 DNS 开始使用时，UUCP 风格的表示法有时会与 TCP/IP 风格的域名地址表示法混合使用。因此，你可能会看到类似 host1!user@domain 的地址。在如何确切解释此类地址方面存在一些混淆：这是否意味着首先发送邮件到 host1，然后到 user@domain？或者这是否意味着首先发送到域名，然后到达 host1 的用户？对此没有统一的答案。这个问题主要是由 UUCP 的使用减少以及 UUCP 系统转向 TCP/IP 风格的域名地址表示法来解决的。

## 网关地址方式

你可能会遇到看起来像使用不寻常的标点符号嵌套了多个 TCP/IP 地址的电子邮件地址。例如，你可能会看到这样的地址：user%domain1.com@subdomain.domain2.edu。这是一种在电子邮件网关使用时有时会看到的地址方式；它会导致邮件被发送到 subdomain.domain2.edu 的 user%domain1.com。然后，该地址被解释为 user@domain1.com。然而，再次强调，并非所有系统都能保证以相同的方式解释这一点。

电子邮件网关通常不是一件简单的事情，正如你所看到的，其中一个原因是使用了不同的电子邮件地址风格，以及复杂混合地址解释的一致性问题。然而，随着互联网的扩展和 TCP/IP 的更广泛使用，这些较老的特殊地址格式变得越来越少见。它们越来越多地成为历史趣闻（除非你恰好使用其中之一）。

# TCP/IP 电子邮件别名和地址簿

邮件类似于普通邮件，但由于数字和电子通信的两个主要优势，它优于普通邮件。一个优势是*速度*，这就是为什么现代互联网用户发明了俚语“蜗牛邮件”来指代普通邮政服务。但另一个优势，*灵活性*，同样至关重要。电子邮件允许你以普通邮件难以实现的方式轻松发送消息。这种灵活性在地址方面表现得尤为明显。

邮件地址的灵活性首先体现在大多数电子邮件客户端支持高级功能，允许用户以方便的方式指定收件人的身份。虽然 TCP/IP 地址比较直接，但记住你所认识的人的地址是困难的。在现实生活中，我们使用地址簿来帮助我们记住地址。通过电子邮件，我们可以通过允许电子邮件软件将一个名字与一个电子邮件地址关联来实现同样的功能。

这通常有两种方式。在老式的基于文本的电子邮件中，如许多 UNIX 系统上使用的，使用*别名*来执行名字和地址的关联。这些是电子邮件地址的简写形式，可以节省输入。例如，我经常给我妻子 Robyn 发邮件，但我懒得每次都输入她的完整地址。所以我在我的电子邮件程序中为她定义了一个别名，简单地叫*r*。我输入邮件命令并指定别名*r*作为预期的收件人，它会为我展开她的电子邮件地址。

在现代图形电子邮件系统中，不使用别名。相反，通常实现一个*电子地址簿*，这相当于纸质地址簿。区别在于没有手动复制；你只需用鼠标从列表中选择名字即可。

# 多个收件人地址指定

邮件地址的另一个优点是它允许轻松指定多个收件人。使用纸质邮件，给十个人发送信息意味着你需要十份信息、十个信封和十个邮票。通过电子邮件，你只需在收件人列表中以逗号分隔列出收件人地址：<user1@domain1>，<user2@domain2>，<user3@domain3>。每个收件人都会收到一个单独的副本。当然，也可以使用别名和/或地址簿来指定每个收件人，使这个过程更加简单。

由于电子邮件使得一个人向一组人发送信息变得非常容易，所以被称为*一对多*的消息传递，这也是电子群组通信最早实现的方式之一。在电子邮件出现之前，在小组环境中共享信息需要面对面会议或电话会议。在这两种情况下，所有参与者必须同时在场，并且涉及成本，尤其是当参与者地理位置相距遥远时。

通过电子邮件，一组人可以共享信息，而无需见面或同时在线。假设一个小组由四个人组成：Ellen、Joe、Jane 和 Tom。Ellen 有一个她想要讨论的提案。她把它发送给 Joe、Jane 和 Tom。每个收件人都会在方便的时候阅读它。然后每个人都可以向小组回复。例如，Tom 可能对提案有评论，所以他只需把它发送给 Ellen、Joe 和 Jane。大多数电子邮件客户端都包括一个*群组回复*功能来达到这个目的。

# 邮件列表

在较大的群体中，通过键入每个收件人的地址来进行沟通变得繁琐。相反，使用**邮件列表**。列表是由一个被称为**列表所有者**的个人创建的，包含该群体所有成员的电子邮件地址。创建了一个特殊的**列表地址**，它就像一个普通的电子邮件地址一样工作。然而，当任何人向这个特殊地址发送邮件时，它并不是简单地存入邮箱。相反，它会被特殊的软件拦截，该软件处理消息并将其自动发送给列表上的所有收件人。任何收件人都可以回复列表地址，所有成员都会收到回复。

现在有许多其他方式可以供群体用来分享信息，例如使用万维网公告板、Usenet 新闻组、互联网中继聊天（IRC）等等。其中一些拥有许多功能，使得邮件列表看起来显得不够复杂。尽管如此，电子邮件列表仍然非常受欢迎，这主要是因为电子邮件是最通用的互联网通信方式，也是使用起来最简单的方法之一。

互联网上正在使用成千上万的邮件列表，涵盖每一个可以想象的主题。每个列表在许多方面都有所不同，包括以下五个方面：

**实施** 通常，一些特殊的软件被用来允许列表所有者管理列表、添加和删除用户，并设置控制列表运作的参数。这些程序通常被称为**机器人**或**listservs（列表服务器）**。其中较为常见的列表服务器之一名为**Majordomo**。一些邮件列表实际上是通过网络实现的和管理。（互联网应用之间的界限正变得越来越模糊。）

**订阅规则和技术** 一些邮件列表对任何希望加入的人开放；而另一些则仅限邀请加入。大多数允许新订阅者使用软件自动加入；而另一些则要求列表所有者添加新成员。

**管理方法和风格** 列表所有者决定在列表上讨论的内容是否可接受。有些列表是**受管理的**，这意味着所有提交给列表的内容都必须在发送给列表成员之前得到列表所有者的批准。有些列表允许非成员向列表发送邮件，而有些则不允许。

**文化** 与所有群体一样，邮件列表中的群体也有自己的文化、有趣的个性和其他独特的特质。新加入列表的成员通常会被鼓励先阅读列表内容，而不是立即发送邮件，直到他们适应了列表的运作方式。这个过程与 Usenet 新手的适应过程类似（Usenet 的内容在第八十五章 和 TCP/IP 网络新闻传输协议 (NNTP)")中有介绍）。

**特殊功能** 一些列表支持特殊功能，例如以**摘要模式**（将消息收集到大型摘要中以减少发送的单独消息数量）订阅的能力，或者通过网页访问消息。

### 小贴士

**关键概念** 电子邮件的许多好处之一是，通过指定多个收件人地址，可以轻松地向许多人同时发送消息。这使得**群组通信**变得简单且直接，因为每个收件人都可以发送群组回复来回应收到原始消息的每个人。电子**邮件列表**为群体交换思想和信息提供了一种更正式化的方式；在互联网上使用了数以千计的此类列表。

# 第七十六章：TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME

![无标题图片](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)

使用计算机进行通信的优点是显而易见的，但计算机技术的使用也带来了一些限制。当我将电子邮件与普通邮件进行比较时，我总是指出电子邮件在交付方式上要快得多，也更加灵活，这是真的。一封电子邮件可以在几秒钟内到达目的地，而一封传统信件可能需要几天。

然而，使用计算机进行通信的一个显著缺点是，它们在理解消息方面不太灵活。考虑一下，任何人都可以将任何类型的信件、备忘录或其他通信放入信封并发送给您，并且假设您知道它所写的语言，您就可以打开信封并可能理解它。您可以弄清楚如何处理信件中不寻常位置出现的日期，或者您的名字出现在顶部而不是底部，或者消息正文以不同的方式结构化。您可以阅读用钢笔、铅笔或蜡笔打字或手写的笔记——只要字母可辨认，您就可以理解正在说的话。

计算机不擅长解读这样的细微差别。正因为如此，电子邮件系统必须依赖于标准消息格式来确保所有消息都具有相同的形式和结构。这使得电子邮件系统中的所有设备都能够读取和理解彼此的消息，从而使 TCP/IP 电子邮件能够在许多不同类型的计算机上工作。

在本章中，我描述了用于 TCP/IP 电子邮件消息的两种格式：主要的 TCP/IP 电子邮件标准，该标准被称为 RFC 822 格式，这是定义该标准的标准名称，以及多用途互联网邮件扩展（MIME）标准，该标准通过定义将各种媒体和非英语文本编码到标准 RFC 822 格式的方法，极大地扩展了电子邮件支持不同类型信息通信的能力。

# TCP/IP 电子邮件 RFC 822 标准消息格式概述

我阅读过的关于互联网应用的最精辟的观察之一是，它们的有用性与使用它们的人数成正比。TCP/IP 电子邮件就是一个很好的例子。它是一种强大的通信方法，在很大程度上是因为今天几乎每个拥有电脑的人都参与了该系统。使用电子邮件的人数越多，它就越强大。

TCP/IP 电子邮件的创造者意识到，使用该系统的人会使用许多不同类型的硬件和软件。为了确保每个人都能理解所有电子邮件消息，无论谁发送它们，他们都指定了一个通用的电子邮件消息格式。这个格式没有官方的华丽名称；它只是以定义它的标准名称而闻名：RFC 822 消息格式。

### 小贴士

**相关信息** *本讨论将参考对简单邮件传输协议（SMTP；见第七十七章"))的讨论，但设计得如此，以便您在学习 SMTP 之前阅读它而不会感到困惑*。

传递电子邮件的主要协议是简单邮件传输协议（SMTP）。因此，TCP/IP 电子邮件所使用的消息格式可以被认为是 SMTP 的协议消息格式，这与讨论其他协议（如互联网协议（IP）和传输控制协议（TCP））时提到的特殊消息格式类似。然而，TCP/IP 电子邮件消息格式不仅被 SMTP 使用，还被所有处理电子邮件的协议和应用使用。这包括邮件访问协议邮局协议（POP3）和互联网消息访问协议（IMAP），以及其他一些协议。它也被设计成可能适用于其他非 TCP/IP 邮件投递协议。也许正因为如此，TCP/IP 电子邮件格式并没有作为 SMTP 本身的一部分，即 RFC 821，来指定，而是在一个配套文件 RFC 822 中进行了指定。两者都是在 1982 年发布的。

## RFC 822 消息格式标准的开发

TCP/IP 所使用的消息格式的历史可以追溯到 1982 年之前。它最初在 20 世纪 70 年代初被定义为在互联网的前身 ARPAnet 上传递文本消息的格式。该格式经过多次改进，最终在 1977 年发布了重要的电子邮件标准 RFC 733，“ARPA 网络文本消息格式标准”。RFC 822 随后简化了 RFC 733 的内容，移除了一些在早期标准中描述但未能获得认可的功能，并简化了规范。

在 2001 年，SMTP 和 RFC 822 消息格式都进行了修订；SMTP 现在由 RFC 2821 描述，消息格式由 RFC 2822 描述。这个更新的标准对 RFC 822 消息格式进行了相对较小的修改，以反映 TCP/IP 电子邮件的现代使用。尽管 RFC 2822 是当前标准，但原始名称仍然是最常用的名称。在这个讨论中，我将尊重这个惯例，基于 RFC 2822 描述消息格式，同时仍然称之为 RFC 822 消息格式。

RFC 822 格式描述了 TCP/IP 电子邮件消息的格式、结构和内容。正如我所说的，它与 TCP/IP 中其他协议使用的消息格式类似。像那些其他格式一样，RFC 822 格式可以逻辑上分为两个主要部分：*消息头*，其中包含重要的控制和描述信息，以及*消息体*或*有效载荷*，它携带数据。

## RFC 822 消息概述

RFC 822 与其他协议的字段格式在表达上有所不同。大多数 TCP/IP 协议将头信息编码成一组紧凑的字节，这些字节根据它们在消息中的位置和分配给它们的语义意义进行读取和理解。以 IP 为例。每个 IP 数据报的第九个字节是生存时间 (TTL) 字段，它编码为从 0 到 255 的值。读取 IP 数据报的设备只需知道第 9 个字节包含 TTL 值。如果它在那里看到二进制值 00010011，它就知道这个数据报的 TTL 值是十进制的 19。

与此相反，RFC 822 消息不使用二进制格式。它们完全由常规 ASCII 文本行组成（在美国使用，标准中称为 *US-ASCII*），即使是标题。每一行都以 ASCII *回车 (CR)* 字符结束，后面跟着一个 *换行 (LF)* 字符；这个组合统称为 *CRLF*。每行文本应包含 78 个或更少的字符（不包括终止的 CRLF），并且不能超过 998 个字符（同样，不包括 CRLF）。此外，CR 和 LF 字符不得单独出现在文本中。

RFC 822 消息以一组文本行开始，这些行共同构成了消息头。每个*头字段*都以以下形式在文本中表示：*<头名称>: <头值>*。例如，如果 RFC 822 消息中有一个 *TTL* 字段（实际上没有，因为这个概念并不特指电子邮件），并且需要表示值为 19，则头字段将如下所示：*生存时间: 19*。

将所有字段都表示为简单文本意味着每个头在每个消息中占用更多空间；字符串 *生存时间: 19* 包括终止的 CRLF 共占用 18 个字节，而 IP 头中二进制编码的 TTL 字段只占用一个字节。我们从这一点获得的是两个重要的好处：

+   任何用户都可以轻松检查头部，并立即了解哪些头部存在以及它们的值是什么，这使得 RFC 822 消息非常易于阅读。

+   由于每个头部都有明确的标签，RFC 822 消息在包含的头部数量以及它们出现的顺序上可以有所不同，这使得它们具有灵活性。

## 通用 RFC 822 消息结构

RFC 822 消息始终以一组头部字段开始（如下一节所述）。在所有头部之后，必须出现一个空行。这仅由 CRLF 字符组成，紧随最后一个头部字段行末的 CRLF 之后。看到连续的两个 CRLF 字符对，设备读取消息时会知道头部已经结束。所有剩余的行都被认为是消息的正文。像头部行一样，正文行由 ASCII 文本组成，长度不得超过 998 个字符，建议长度为 78 个字符或更少（以便在标准 80 字符终端显示器上更容易阅读）。

### 小贴士

**关键概念** 为了确保 TCP/IP 互联网上的每个设备都能读取由每个其他设备发送的电子邮件，所有消息都必须遵循特定的结构。首先指定现代 TCP/IP 电子邮件消息形式的规范是 RFC 822，因此现在被称为*RFC 822 消息格式*。一个 RFC 822 消息由一组*消息头部*和一个*消息正文*组成，它们由一个空行分隔。RFC 822 消息必须只包含纯 ASCII 文本字符。每行长度不得超过 1,000 个字符，最后两个字符必须是 ASCII CR 和 LF 字符，以标记行尾。

由于电子邮件消息的头部和正文都是简单的 ASCII 文本，整个消息就是一个文本文件，因此这些消息非常易于阅读，也易于创建。您可以使用简单的文本编辑器创建完整的电子邮件消息，包括头部，并且可以使用简单的文本显示工具阅读。这有助于电子邮件的普及。

缺点是，决定使消息完全为 ASCII 意味着 RFC 822 消息中没有任何原生支持用于需要更复杂结构或无法使用有限的 ASCII 字符表达的内容。因此，您不能直接使用 ASCII 表达图片、二进制文件、电子表格、声音剪辑和类似类型的文件。此外，ASCII 的使用使得 RFC 822 非常适合表达英语消息，但不适合许多 ASCII 无法表示字符的其他语言。所有这些限制最终促使了增强的 MIME 消息格式的创建，我们将在本章后面详细探讨。

# TCP/IP 电子邮件 RFC 822 标准消息格式头部字段和组

RFC 822 消息格式描述了 TCP/IP 电子邮件消息的结构和内容。结构有意设计得简单，易于创建和理解。每条消息以一组描述消息及其内容的头信息开始。一个空行标志着头信息的结束，然后是消息体。

消息体包含发送者与收件人沟通的实际文本，而消息头包含各种目的的信息。头信息通过指定收件人、描述消息内容以及提供有关在消息交付过程中发生处理的信息来帮助控制消息的处理方式。

## 头字段结构

如前所述，*<header name>*字段是头信息的名称，*<header value>*是与该头信息相关联的值，这取决于头信息类型。像所有 RFC 822 行一样，头信息长度不得超过 998 个字符，建议长度不超过 78 个字符，以便更容易阅读。RFC 822 和 2822 标准支持一种特殊语法，允许在头信息非常长时将其折叠到多行。这是通过将头信息值继续到新行来完成的，该新行必须以至少一个空白字符开始，例如空格或制表符，如下所示：

| *<header name>: <header value part 1>* |
| --- |
| *<white space> <header value part 2>* |
| *<white space> <header value part 3>* |

制表符通常用于此目的。例如，如果我们想指定大量收件人，可以这样做：

| To:*<tab>person1@domain1.org, person2@domain2.com*, |
| --- |
| *<tab>person3@domain3.net, person4@domain4.edu* |

## 头字段组

RFC 822 消息格式指定了许多可以包含在电子邮件中的头信息类型。少数头信息是强制性的，意味着它们必须包含在所有消息中。一些不是强制性的，但通常存在，因为它们对于描述消息是基本的。其他可选头信息仅在需要时包含。

为了帮助组织许多头信息，RFC 2822 标准将它们分类为头字段组（RFC 822 也这样做，尽管在旧标准中组略有不同）：

**起源日期字段**指定消息准备交付的日期和时间；有关详细信息，请参阅下一节。（这个字段单独成组的原因对我来说不太清楚；可能只是因为它非常重要。）

**发件人字段**包含有关消息发送者的信息。

**目标地址字段**指定消息的收件人，可能属于以下三个不同的收件人类别之一：主要收件人（"To"）、抄送收件人（"Cc"）和暗送收件人（"Bcc"）。

**标识字段**包含帮助识别消息的信息。

**信息字段** 包含可选信息，以帮助接收者了解消息的内容。

**重发字段** 在重发消息时保留原始发起者、目的地和其他字段。

**跟踪字段** 显示邮件在传输过程中所经过的路径。

此外，格式允许指定其他用户定义字段，只要它们对应于标准的 *<头部名称>: <头部值>* 语法。这可以用来提供各种类型的信息。例如，有时电子邮件客户端软件会包含一个头部行，指示用于编写和发送消息的软件的名称和版本。正如您将在本章后面看到的那样，MIME 使用新的头部行来编码有关 MIME 消息的信息。

### 小贴士

**关键概念** 每个 RFC 822 消息都以一组 *头部* 开头，这些头部包含有关消息的基本信息。这些头部用于管理消息的处理和解释方式，并且它们还描述了消息主体的内容。每个头部由一个 *头部名称* 和一个 *头部值* 组成。有十几种不同的标准 RFC 822 头部可供使用，并组织成组。还可以定义自定义用户头部。

## 常见头部字段分组与头部字段

表 76-1 描述了 TCP/IP 电子邮件消息中的头部字段及其使用方式。

表 76-1. RFC 822 电子邮件头部字段分组与字段

| 字段组 | 字段名称 | 出现形式 | 每条消息的出现次数 | 描述 |
| --- | --- | --- | --- | --- |
| 发起日期 | Date: | 必需 | 1 | 指示邮件传输系统可供投递的日期和时间。这通常是用户告诉其电子邮件客户端发送消息的日期/时间。 |
| 发起者字段 | From: | 必需 | 1 | 发送消息的用户的电子邮件地址，应该是消息的来源者。 |
|   | 发件人: | 可选 | 1 | 发送电子邮件的人的电子邮件地址，如果与消息发起者不同。例如，如果 B 人发送包含 A 人消息的电子邮件，A 人的地址将放在 From: 头部，B 人的地址将放在 Sender: 头部。如果发起者和发送者是同一人（通常是这种情况），则此字段不存在。 |
|   | 回复到: | 可选 | 1 | 告知消息接收者，发起者希望接收者用于回复的地址。如果不存在，回复通常发送回 From: 地址。 |
| 目标地址字段 | To: | 通常存在 | 1 | 消息的主要接收者列表。 |
|   | 抄送： | 可选 | 1 | 包含接收消息副本的收件人列表（*抄送* 代表碳副本，如旧式打字机中使用）。在将消息发送到抄送：标题中列出的某人以及标题中的某人之间没有技术上的区别。区别仅在于收件人如何解释消息。通常，抄送：列表中的人是消息的主要收件人，而抄送：列表中的人是为了信息目的而被抄送消息的人。 |
|   | 密送： | 可选 | 1 | 包含接收“盲”副本的收件人列表，其他收件人不知道他们已经收到了副本。例如，如果 X 在 *收件人* 行中指定，Y 在 *抄送* 行中，Z 在 *密送* 行中，那么三个人都会收到消息的副本，但 X 和 Y 不会知道 Z 已经收到了副本。这是通过在消息交付前删除 *密送* 行或更改其内容来实现的。 |
| 识别字段 | Message-ID： | 应该存在 | 1 | 为识别消息提供唯一代码；通常在发送消息时生成。 |
|   | In-Reply-To： | 可选，通常用于回复 | 1 | 当回复另一条消息时，在此字段中指定原始消息的 Message-ID：字段，以告知收件人回复的消息与哪条原始消息相关。 |
|   | 参考文献： | 可选 | 1 | 识别与该消息相关的其他文档，例如其他电子邮件消息。 |
| 信息字段 | 主题： | 通常存在 | 1 | 描述消息的主题或内容。 |
|   | 评论： | 可选 | 无限制 | 包含关于消息的总结性评论。 |
|   | 关键词： | 可选 | 无限制 | 包含可能对收件人有用的逗号分隔的关键词列表。在搜索特定主题的消息时可以可选使用。 |
| 重新发送字段 | 重新发送-日期：重新发送-发件人：重新发送-发件人：重新发送-收件人：重新发送-抄送：重新发送-密送：重新发送-消息-ID： | 每次重新发送消息时都需要一个重新发送块 | 对于每个重新发送块，重新发送-日期：和重新发送-发件人：是必需的；其他的是可选的 | 仅在原始收件人将消息转发给其他人时使用，称为转发。例如，X 可能将消息发送给 Y，Y 再将其转发给 Z。在这种情况下，原始的日期：、发件人：和其他头信息保持不变，就像 X 发送消息时一样。重新发送-日期：、重新发送-发件人：和其他重新发送头信息用于指示重新发送消息的日期、发起者、收件人和其他特征。 |
| 跟踪字段 | 已接收：返回路径： | 由电子邮件系统插入 | 无限制 | 在处理消息并将其从发起者传输到收件人的过程中由计算机插入。可用于追踪消息在电子邮件系统中的路径。 |

# TCP/IP 电子邮件 RFC 822 标准消息格式处理和解释

定义 SMTP 的标准将协议描述为负责传输*邮件对象*。邮件对象被描述为由两个组件组成：一条*消息*和一个*信封*。消息是电子邮件消息中的所有内容，包括消息头和正文；信封包含完成消息传输所需的所有信息。

这些对象之间的区别在技术上很重要。正如邮政服务在决定如何处理一封信时只看信封而不是信件内容一样，SMTP 在决定如何发送消息时也只看信封。它不依赖于实际消息中的信息来进行基本传输。

因此，信封并不等同于消息头信息。然而，正如您通过查看电子邮件头信息列表可以看出的，每条消息都包括收件人和其他用于邮件传输所需的信息。因此，通常电子邮件消息会指定足够多的头信息来完成其自身的投递。电子邮件软件可以处理和解释消息，以构建 SMTP 传输消息到目标邮箱所需的信封。关于电子邮件消息与其信封之间的区别，在描述 SMTP 邮件传输的章节中进行了更详细的讨论，请参阅第七十七章").

由于 RFC 822 消息格式简单，处理 RFC 822 消息相对直接。完整的电子邮件消息的创建始于用户创建消息时创建消息体和某些头信息。每当一条消息被软件程序“处理”时，都会检查头信息，以便程序可以确定如何处理它。根据需要，还会添加和更改额外的头信息。

以下是在消息头信息生命周期中发生的事件序列。

**创作** 消息的人类创作者编写消息正文，并告知电子邮件客户端程序某些重要头字段应使用的值。这些包括目标收件人、消息主题、其他信息字段以及某些可选头信息，如回复到字段。

**发送客户端处理** 邮件客户端处理消息，将人类提供的信息放入适当的头信息格式中，并创建初始的电子邮件消息。此时，它会在消息中插入某些头信息，例如起始日期。客户端还会解析目标收件人列表，以使用 SMTP 传输消息创建信封。

**SMTP 服务器处理** 在转发消息时，SMTP 服务器不会关注消息中的大多数字段。然而，它们会在传输消息时添加某些标题，特别是跟踪标题，如 Received 和 Return-Path。这些通常被添加到消息的开头，以确保现有的标题不会被重新排列或修改。请注意，然而，当在电子邮件系统之间进行网关操作（如第七十五章所述）时，某些标题实际上必须更改，以确保消息与非 TCP/IP 电子邮件软件兼容。

**收件人客户端处理** 当消息到达目的地时，收件人的 SMTP 服务器可能会添加标题来指示消息接收的日期和时间。

**收件人访问** 当消息的收件人使用客户端软件时，可以通过如 POP3 或 IMAP 等电子邮件访问协议，软件会分析邮箱中的每条消息。这使得软件能够以对人类用户有意义的方式显示消息，并可能允许选择特定的消息进行检索。例如，我们大多数人喜欢看到新收邮件的摘要列表，显示发件人、消息主题、接收消息的日期和时间，这样我们可以决定先阅读哪些邮件，哪些邮件推迟到以后阅读，以及哪些邮件不阅读直接删除（如垃圾邮件）。

# MIME 概述

RFC 822 电子邮件消息格式是 TCP/IP 互联网中交换电子邮件的标准。它使用简单的 ASCII 文本，使得创建、处理和阅读电子邮件消息变得容易，这也为电子邮件作为全球通信方法的成功做出了贡献。

不幸的是，尽管 ASCII 文本非常适合撰写简单的备忘录和其他简短消息，但它没有提供灵活性来支持其他类型的通信。为了允许电子邮件携带多媒体信息、任意文件以及使用除 ASCII 字符集以外的字符集的语言消息，MIME 标准被创建。

### 注意

*虽然 MIME 是专门为电子邮件开发的，但其编码和数据表示方法已被证明非常有用，以至于它也被其他应用协议所采用。其中最著名的是超文本传输协议（HTTP），它使用 MIME 标题来指示正在传输的数据的特征。MIME 的一些元素实际上并不是为电子邮件开发的，而是为 HTTP 或其他协议使用的，我在适当的地方指出了这一点。请注意，HTTP 只使用 MIME 的一些元素；HTTP 消息不是 MIME 兼容的*。

大多数协议之所以成功，特别是因为它们基于广泛接受的开放标准。RFC 822 电子邮件消息格式标准是一个很好的例子；每天都有数百万人使用它来发送和接收 TCP/IP 电子邮件。

然而，标准的成功是有代价的：对那些标准的依赖。一旦一个标准被广泛使用，就很难对其进行修改，即使时代变迁，该标准也不再满足现代计算的需求。不幸的是，RFC 822 电子邮件消息格式就是一个很好的例子。

## MIME 的动机

### MIME 的动机

TCP/IP 电子邮件是在 20 世纪 60 年代和 70 年代开发的。与今天计算机和网络世界相比，当时几乎一切都是“小”的。网络规模小；用户数量少；网络主机的计算能力小；网络连接的容量小；网络应用程序数量少。（当时唯一不“小”的是计算机本身的尺寸！）

由于这个原因，对电子邮件信息的要求也相对较小。当时的计算机输入和输出大多是文本基础的，因此 SMTP 和 RFC 822 标准的创造者将电子邮件视为严格意义上的文本媒介是很自然的。因此，他们指定 RFC 822 来传输文本消息。

初出茅庐的互联网也是在美利坚合众国开发的，最初，整个互联网都位于美国境内。大多数美国人讲英语，正如你可能知道的，英语使用相对较少的字符，这些字符可以用 ASCII 字符集很好地表示。当时定义电子邮件消息格式以支持美国 ASCII（US-ASCII）也是有意义的。

然而，随着计算机的发展，它们从严格的文本模型转向了图形操作系统。可以预见的是，用户对发送的内容产生了兴趣，不仅仅是文本。他们希望能够传输图表、非 ASCII 文本文档（如 Microsoft Word 文件）、二进制程序文件，以及最终的多媒体信息：数字照片、MP3 音频剪辑、幻灯片演示文稿、电影文件等等。此外，随着互联网的增长和全球化，其他国家也开始“上网”，其中一些国家使用的语言根本无法用 US-ASCII 字符集表达。

不幸的是，到了这个时候，事情已经定型。RFC 822 已经广泛使用，改变它也意味着 SMTP、POP 和 IMAP 等协议的工作方式也要改变，这些协议运行在数百万台机器上。然而，到了 20 世纪 80 年代末，很明显，纯 ASCII 电子邮件的限制是一个必须解决的问题。需要一种解决方案，而它以多用途互联网邮件扩展（MIME）的形式出现。

### 注意

*从现在开始，MIME 通常用单数形式来指代，尽管它是一个复数术语的缩写*。

## MIME 功能

MIME 背后的想法既巧妙又优雅：RFC 822 将电子邮件消息限制为 ASCII 文本，但这并不意味着我们不能为 ASCII 文本的创建定义一个更具体的结构。我们不仅可以让用户输入 ASCII 文本消息，还可以使用 ASCII 文本字符来编码非文本数据包（通常称为*附件*）。使用这种技术，MIME 允许常规的 RFC 822 电子邮件消息携带以下内容：

**非文本信息** 包括图形文件、多媒体剪辑以及之前列出的所有其他非文本数据示例。

**任意二进制文件** 包括可执行程序和存储在专有格式中的文件（例如，AutoCAD 文件、Adobe Acrobat PDF 文件等）。

**使用除 ASCII 以外的字符集的文本消息** 包括在 RFC 822 电子邮件消息的标题中使用非 ASCII 字符的能力。

MIME 甚至更进一步，通过实际定义一个结构，允许多个文件被编码成一个单独的电子邮件消息，包括不同类型的文件。例如，一个从事预算分析的人可以发送一个包含文本消息、PowerPoint 演示文稿和包含预算数字的电子表格的电子邮件消息。这种能力大大扩展了电子邮件在 TCP/IP 中的用途。

所有这些操作都是通过特殊的编码规则来完成的，这些规则将非 ASCII 文件和信息转换成 ASCII 形式。信息编码的方式会在消息中添加标题来指示。编码后的消息可以像其他任何消息一样通过系统发送。SMTP 和其他处理邮件的协议对消息体不感兴趣，因此它们甚至不知道 MIME 已被使用。

需要修改的电子邮件软件的唯一变化是向电子邮件客户端程序添加对 MIME 的支持。发送者和接收者都必须支持 MIME 来编码和解码消息。MIME 最初开发时，对 MIME 的支持并不广泛，但这项技术的价值非常显著，以至于今天几乎所有电子邮件客户端软件都包含它。此外，大多数客户端今天也可以使用 MIME 标题中的信息，不仅解码非文本信息，而且将其传递给适当的应用程序以供用户展示。

### 小贴士

**关键概念** 使用 RFC 822 消息格式确保所有设备都能读取彼此的电子邮件消息，但它有一个关键的限制：它只支持纯 ASCII 文本。这对于现代互连网络的需求来说是不够的，而且依赖于 RFC 822 标准会使替换它变得困难。*MIME*指定了几个方法，允许电子邮件消息包含多媒体内容、二进制文件和文本文件，同时仍然遵循 RFC 822 消息格式。MIME 还通过允许在单个消息中发送多个文件或内容片段来进一步扩展电子邮件的灵活性。

## MIME 标准

MIME 首次在 1992 年 6 月发布的两套标准中进行了描述，分别是 RFC 1341 和 RFC 1342。这些标准在 1993 年 9 月通过 RFC 1521 和 RFC 1522 进行了更新。1994 年 3 月，又发布了一个补充标准，RFC 1590，该标准规定了定义新的 MIME 媒体类型的过程。

MIME 的工作在 1990 年代中期继续进行，并于 1996 年 11 月再次修订了标准。这次，文档被完全重构，以改善信息的可读性，并作为一套五个单独的标准发布。这些标准在 表 76-2 中展示。

自从这五个主要的 MIME 标准发布以来，已经发布了大量的附加 RFC，这些 RFC 定义了 MIME 本身的各种扩展，包括额外的 MIME 报头类型和新媒体类型。值得注意的例子是 RFC 2183 和 2557，分别定义了 MIME Content-Disposition 和 Content-Location 报头。一些其他 MIME 功能实际上被定义为使用 MIME 的其他技术的部分；例如，第一个 HTTP 标准，RFC 1945 定义了 Content-Length 报头。其他 RFC 定义了新的媒体类型和子类型（此处无法一一列出）。|

表 76-2. MIME 标准

| RFC 编号 | RFC 名称 | 描述 |
| --- | --- | --- |
| 2045 | 多用途互联网邮件扩展 (MIME) 第一部分：互联网消息体的格式 | 描述了 MIME 背后的基本概念和 MIME 消息的结构。 |
| 2046 | 多用途互联网邮件扩展 (MIME) 第二部分：媒体类型 | 解释了 MIME 媒体类型和子类型的概念，并描述了 MIME 标准中定义编码的一些媒体类型。 |
| 2047 | MIME (多用途互联网邮件扩展) 第三部分：非 ASCII 文本的消息报头扩展 | 描述了如何修改 RFC 822 报头以携带非 ASCII 文本。 |
| 2048 | 多用途互联网邮件扩展 (MIME) 第四部分：注册程序 | 讨论了组织如何为与 MIME 一起使用注册额外的媒体类型。 |
| 2049 | 多用途互联网邮件扩展 (MIME) 第五部分：一致性准则和示例 | 提供了额外的实现信息和 MIME 可以如何使用的示例。 |

# MIME 基本结构和报头

MIME 标准的创建者面临着一个艰巨的挑战：如何在 RFC 822 规定消息只能包含 ASCII 文本的情况下，为电子邮件消息中的数据类型带来灵活性。为了实现这一点，MIME 创建者必须利用已经放入现有 RFC 822 中的灵活性区域。

有两种这样的机会：第一种是 RFC 822 消息体允许包含任何类型的 ASCII 文本，只要行不超过 998 个文本字符，并且每行以 CRLF 控制代码组合结束。尽管 RFC 822 的创建者自然假设这种 ASCII 文本将是可读的，但没有任何阻止它成为机器可读代码的东西。第二种机会是内置在 RFC 822（以及使用它的协议，如 SMTP）中的功能，允许向任何电子邮件消息添加自定义用户定义的头部字段。

RFC 822 消息体的非特定性质是 MIME 本身如何工作的基础。支持 MIME 标准的电子邮件客户端使用特殊的编码算法将非 ASCII 信息转换为 ASCII 形式。然后，它将这组编码的 ASCII 字符放入消息体中，就像用户使用两种特殊结构之一输入一样。

向 RFC 822 添加新头部的功能被用来从发送者向接收者传达有关 MIME 使用的信息。传输 MIME 消息的设备并不关心是否使用了 MIME，因为它们不关注消息主体的内容。然而，当消息到达目的地时，接收者的电子邮件客户端程序必须有一种方式知道使用了 MIME，并且必须被告知消息中的信息是如何编码的。否则，它可能只是将编码的非 ASCII 数据以 ASCII 文本的形式呈现给用户（这看起来像是一堆随机乱码）。

## 基本结构

数据在消息体中编码的方法以及 MIME 头部中包含的方法取决于 MIME 消息的整体结构。根据消息携带的媒体类型，描述了两种基本结构类型：

**简单结构（离散媒体）** 携带单个离散媒体类型（如文本消息或图形图像）的 MIME 消息使用简单结构。消息体中只存在一种信息编码。

**复杂结构（复合媒体）** 一些 MIME 消息携带复合媒体类型，这允许在单个消息中包含多种不同的媒体，例如文本消息和图形图像，或者允许电子邮件完全封装另一个电子邮件消息。许多这些消息使用更复杂的结构，其中消息体包含多个 MIME 主体部分。

## MIME 实体

总体而言，整个 MIME 消息和单个体部分统称为*MIME 实体*。每套 MIME 头提供了关于这两种 MIME 实体类型的信息：整个 MIME 消息或复合消息中的体部分。当一个 MIME 消息被接收时，接收者首先检查整个消息的头（RFC 822 头）以确定整体消息类型。这随后指示消息是否使用简单或复杂结构。如果使用后者，则解析消息体，并对每个单独的体部分进行单独解释，包括其个性化的头。本章后面的“MIME 复合媒体类型”部分提供了关于这些体部分如何格式化的更多详细信息。

## 主要 MIME 头

五个主要 MIME 标准中的第一个，RFC 2045，描述了一组五个主要 MIME 头，这些头传递了关于每个 MIME 实体（消息或体部分）内容的基本信息。

**MIME 版本** 每个 MIME 消息都必须有一个 MIME-Version 头，它有两个作用。首先，它标识电子邮件消息是 MIME 编码的。其次，尽管到目前为止只定义了一个版本的 MIME，但拥有一个版本号头提供了未来证明，以防将来创建的新版本可能与当前版本不兼容。目前，所有 MIME 消息都使用版本 1.0。这是唯一适用于整个消息的 MIME 头；它不用于标记单个 MIME 体部分。这很容易记住，因为它是唯一一个名称不以 Content-开头的头。

**Content-Type** 描述了 MIME 实体中编码的数据的性质。此头指定了一个内容类型和一个内容子类型，它们由一个斜杠字符分隔。它还可以可选地包含某些参数，这些参数传达有关类型和子类型的额外信息。在消息体中，此头告诉电子邮件消息的接收者它包含什么类型的媒体以及体是否使用简单或复杂结构。在体部分中，它描述了体部分包含的媒体类型。例如，包含 HTML 文档的消息可能有一个`Content-Type`头为`text/html`，而包含 JPEG 图形文件的消息可能指定为`image/jpeg`。对于复合 MIME 类型，整个消息的`Content-Type`头将包含类似`multipart/mixed`或`multipart/alternative`的内容，并且每个体部分将包含单独的`Content-Type`头，如`text/html`或`image/jpeg`。这些内容将在下一节中详细讨论。此头是可选的。当不存在时，假定默认值为常规 US-ASCII 文本消息（常规 RFC 822 消息的媒体类型）。

**内容传输编码（Content-Transfer-Encoding**）对于使用简单结构的消息，指定用于在消息正文中编码数据的编码方法；对于复合消息，标识每个 MIME 正文部分的编码方法。对于已经是 ASCII 形式的数据，不需要特殊编码，但其他类型的数据必须转换为 ASCII 才能传输。此标题告诉收件人如何将数据解码回其正常表示形式。（MIME 编码方法将在本章后面描述。）此标题是可选的；如果不存在，默认值是 7 位编码，这又是常规 ASCII 的编码。

**内容标识符（Content-ID**）允许 MIME 内容被分配一个特定的标识代码。此标题类似于 RFC 822 消息标识符标题字段，但它是针对 MIME 内容本身的。它是可选的，通常用于多部分 MIME 消息的正文部分。

**内容描述（Content-Description**）此可选标题允许将任意附加文本描述与 MIME 实体关联。在多部分消息中，每个正文部分可能会被赋予一个描述标题，以便让收件人清楚地了解各部分代表的内容。

### 小贴士

**关键概念** MIME 通过将非 ASCII 数据编码为 ASCII 形式，并添加描述这些数据及其解释方式的特殊标题，为电子邮件消息中可以携带的信息提供了灵活性。最重要的 MIME 标题是 *内容类型（Content-Type**），它描述了消息中包含的数据类型，以及 *内容传输编码（Content-Transfer-Encoding**），它指定了数据的编码方式。MIME 支持两种基本整体格式：*简单结构*，其中在消息中编码单一类型的 *离散媒体*，以及 *复杂结构*，它编码了一种 *复合媒体* 类型，可以携带多种类型的信息。

## 其他 MIME 标题

除了五个基本标题外，MIME 标准还允许定义额外的标题。唯一的限制是它们都必须以单词 *Content*- 开头，这清楚地表明它们是描述 MIME 实体（消息或正文部分）的内容。发送方和收件方都必须支持自定义标题，才能使其有用。

实际上已经创建了几个新的 MIME 标题，并在各种互联网 RFC 中进行了文档记录。其中一些实际上是为特定用于电子邮件消息之外设计的，而是用于利用 MIME 技术的其他协议，例如 HTTP。以下三个值得关注：

**内容处置（Content-Disposition**）在多部分 MIME 消息中，此标题可以用于 MIME 正文部分，以控制信息如何呈现给用户。两个最常见值是 *内联（inline**），表示内容旨在与其他正文部分一起自动显示，以及 *附件（attachment**），表示内容与主文档分开。此标题在 RFC 2183 中定义。

**内容位置** 允许使用统一资源定位符（URL）标识 MIME 主体部分的位置。这在将 HTML 和其他多媒体启用文档格式编码成 MIME 多部分消息用于电子邮件时有时会用到。它在 RFC 2557 中定义。

**内容长度** 指定 MIME 实体的字节数。这个报头在 MIME 的电子邮件应用中不常用，但在 HTTP 中是一个重要的报头。它在 HTTP 标准中描述，首次出现在 RFC 1945 中。

# MIME 内容类型报头和离散媒体

MIME 使用特殊的技巧将各种类型的信息编码成 ASCII 文本形式，如图形图像、声音文件、视频剪辑、应用程序程序、压缩数据文件等。我们通常将这些称为不同类型的 *媒体*，MIME 使用相同的术语来描述它们。

由于 MIME 支持如此多种类的媒体，每个消息都包含描述其内容的必要信息，以便准确解码消息内容。这就是重要的 MIME 内容类型报头的功能。

## 内容类型报头语法

内容类型报头的语法如下：

| *Content-Type: <type>/<subtype> [; parameter1 ; parameter2 .. ; parameterN ]* |
| --- |

这些不同元素的目的在于以从一般到具体的方式描述 MIME 实体中的媒体。第一个元素，*<type>*，被称为 *最高层媒体类型*，描述了数据的整体形式。例如，它表示 MIME 实体是否包含文本、图像、音频等。第二个元素，*<subtype>*，提供了关于数据形式或格式的具体信息。例如，JPEG 图像和 GIF 图像都是图像，但它们有不同的格式。在内容类型报头中，*<type>* 和 *<subtype>* 都是必需的。

在这些元素之后可能出现一个或多个 *参数*，这些参数通常是可选的，但对于某些媒体类型可能是必需的。这些参数提供了关于数据性质的更多细节，当需要时提供。每个参数前面都有一个分号，并以属性/值对的形式表达，由等号（=）分隔，如下所示：*; attribute=value*。

参数可能被用做的一个例子是在指定文本消息中的字符集。常规的 RFC 822 ASCII 文本的表示如下：

```
Content-type: text/plain; charset="us-ascii"
```

最高层媒体类型是 `text`，子类型是 `plain`，这表明这是一个纯文本消息。参数 `charset` 指定消息使用 US-ASCII 字符集。参数的另一个常见用途是指定附件文件的名称，如下所示：

```
Content-type: image/jpeg; name="ryanpicture.jpg"
```

## 离散媒体类型和子类型

如我之前所述，MIME 支持两种基本结构：简单和复杂。一个简单的消息只携带一种媒体类型，例如一段文本、一张图片或一个可执行文件。这些在 MIME 中被称为 *离散媒体类型*。一个复杂的消息携带一个 *复合媒体类型*，它可以包含多个正文部分。每个正文部分又携带与其中一个离散媒体类型相对应的数据。顶级媒体类型指示整个消息是否携带离散媒体类型或复合类型。

### 小贴士

**关键概念** MIME 的 *Content-Type* 头部指定了 MIME 消息中编码的数据类型。该头部通过 *顶级媒体类型* 指示消息内容的通用形式，并通过指定 *子类型* 来指示数据的更具体性质。它还可以包含可选的 *参数*，提供有关内容的更多信息。

RFC 2046 标准（描述 MIME 的五个标准集中的第二个标准）定义了五个离散顶级媒体类型：`text`、`image`、`audio`、`video` 和 `application`。它们各自代表在 TCP/IP 上常见传输的数据的主要类别之一。每个类型都有一个或多个子类型，其中一些还包含用于提供更多信息的参数。

MIME 的创建者认识到，该标准无法描述每种媒体类型，并且未来将创建新的媒体类型。RFC 2048（MIME 集的第四部分）描述了如何通过该过程描述和将新的媒体类型、子类型和参数注册到互联网数字分配机构（IANA）。

到目前为止，只创建了一个新的顶级媒体类型；这是 `model` 顶级类型，用于 CAD 建模文件和类似用途，如 RFC 2077 所述。然而，多年来已经创建了数十个新的子类型，其中一些在 RFC 中指定，而另一些则直接在 IANA 进行注册。这包括许多供应商特定的子类型，通常通过子类型名称中的前缀 *x-* 或 *vnd* 来识别。

现在存在数百种类型/子类型组合，我不会列出所有。您可以在 IANA 的网站上找到按顶级媒体类型组织的 MIME 媒体类型的完整列表：[`www.iana.org/assignments/media-types/index.html`](http://www.iana.org/assignments/media-types/index.html)。

在这里，我将简要描述六个 MIME 离散顶级媒体类型。对于每个类型，我都提供了一个表格，展示了一些更常见的 MIME 子类型，以给您一个大致的了解。

### 文本媒体类型 (text)

`text` 媒体类型用于发送主要以文本形式的数据。表 76-3 描述了这些子类型。

表 76-3. MIME 文本媒体类型子类型

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `text/plain` | 纯文本，用于常规消息，如对应初始 RFC 822 标准的消息 | RFC 2046 |
| `text/enriched` | 包含格式信息或其他增强信息，使其不再是纯文本的文本 | RFC 1896 |
| `text/html` | 使用 HTML 表达的文档，通常用于万维网 | RFC 2854 |
| `text/css` | 万维网的层叠样式表信息 | RFC 2318 |

### 图像媒体类型 (image)

`image` 媒体类型表示图形图像文件，如图片。子类型通常表示特定的格式，以便接收者能够正确解码和展示文件。一些更常见的子类型在 表 76-4 中展示。

表 76-4. MIME 图像媒体类型子类型

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `image/jpeg` | JPEG 格式的图像 | RFC 2046 |
| `image/gif` | 图形交换格式 (GIF) 图像 | IANA 表示 RFC 2046，但实际上并不在那里。 |
| `image/tiff` | 标记图像文件格式 (TIFF) 图像 | RFC 2302 |

|

```
image/vnd.dwg,
image/vnd.dxf,
image/vnd.svf
```

| 在 AutoCAD 中使用的矢量图像 | IANA 注册 |
| --- | --- |

### 音频媒体类型 (audio)

`audio` 媒体类型用于发送音频信息。子类型通常表示特定的格式。表 76-5 展示了一些常见的值。

表 76-5. MIME 音频媒体类型子类型

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `audio/basic` | 在主要 MIME 标准中定义的基本音频类型，描述使用 8 位 ISDN mu-law 脉冲编码调制在 8,000 Hz 下编码的单通道音频 | RFC 2046 |
| `audio/mpeg` | MPEG 标准音频（包括流行的 MP3 文件格式） | RFC 3003 |

### 视频媒体类型 (video)

`video` 媒体类型用于发送视频信息。同样，子类型通常表示特定的格式，如 表 76-6 所示。

表 76-6. MIME 视频媒体类型子类型

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `video/mpeg` | 视频编码为 MPEG 数字视频标准 | RFC 2046 |
| `video/dv` | 与多种视频设备使用的 SD-VCR、HD-VCR 和 DVB 等多个流行标准相对应的数字视频 | RFC 3189 |
| `video/quicktime` | 苹果的 QuickTime 电影格式 | IANA 注册 |

### 模型媒体类型 (model)

`model` 媒体类型描述了一个模型表示，例如二维或三维物理模型。其子类型在 表 76-7 中描述。

表 76-7. MIME 模型媒体类型子类型

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `model/mesh` | 用于建模的网格 | RFC 2077 |
| `model/vrml` | 虚拟现实建模语言（VRML）模型 | RFC 2077 |
| `model/iges` | 与初始图形交换规范（IGES）相对应的模型文件 | 在 IANA 进行注册 |

### 应用媒体类型（application）

`application` 媒体类型是任何不适合前面类别或本质上是应用程序特定的数据的通用类型。子类型通过指明使用它的应用程序类型来描述数据。这可以用来指导收件人的电子邮件程序选择一个适当的应用程序程序来显示它，就像 Windows 中的文件扩展名告诉操作系统如何打开不同类型的文件一样。

例如，如果你在电脑上安装了 Microsoft Excel，点击以 .XLS 结尾的文件名将自动启动 Excel。同样，Excel 电子表格通常使用 MIME 以 `application/vnd.ms-excel` 的媒体类型发送。这告诉收件人的电子邮件程序启动 Excel 来读取此文件。

`由于存在许多应用程序，这个顶级类型中存在超过 100 个不同的子类型。表 76-8 包含了一些代表性的样本。`

`表 76-8. MIME 应用媒体类型子类型`

| 类型/子类型 | 描述 | 定义来源 |
| --- | --- | --- |
| `application/octet-stream` | 一组任意的二进制数据八位字节（有关更多详细信息，请参阅此表之后的讨论） | RFC 2046 |
| `application/postscript` | 用于打印和生成 Adobe Acrobat (PDF) 文件的 PostScript 文件 | RFC 2046 |
| `application/applefile` | 表示 Apple Macintosh 文件的资源文件信息 | 在 IANA 进行注册 |
| `application/msword` | Microsoft Word 文档（注意，这与大多数其他 Microsoft 文件类型不同，没有 vnd 前缀） | 在 IANA 进行注册 |
| `application/pdf` | Adobe Acrobat 创建的便携式文档格式（PDF）文件 | 在 IANA 进行注册 |
| `application/vnd.framemaker` | Adobe FrameMaker 文件 | 在 IANA 进行注册 |
| `application/vnd.lotus-1-2-3` | Lotus 1-2-3 文件 | 在 IANA 进行注册 |
| `application/vnd.lotus-notes` | Lotus Notes 文件 | 在 IANA 进行注册 |
| `application/vnd.ms-excel` | Microsoft Excel 工作表文件 | 在 IANA 进行注册 |
| `application/vnd.ms-powerpoint` | Microsoft PowerPoint 演示文稿文件 | 在 IANA 进行注册 |
| `application/vnd.ms-project` | Microsoft Project 文件 | 在 IANA 进行注册 |
| `application/zip` | 包含一个或多个其他文件的压缩存档文件，使用 ZIP/PKZIP 压缩格式 | 在 IANA 进行注册 |

``在这些应用程序子类型中，有一种特别值得进一步提及：`application/octet-stream` 子类型。这是在应用程序类型中的万用类型，仅仅意味着文件是一系列任意二进制数据。通常在发送者不确定数据的形式或无法将其识别为属于特定应用程序时使用。当使用此类型时，接收者通常会提示将数据保存到文件。然后他必须弄清楚使用什么应用程序来读取它。``

```application/octet-stream` MIME 类型/子类型甚至可以用于未知格式的图像、音频或视频。如果你尝试发送发送程序不理解的多媒体文档，它通常将其编码为 `application/octet-stream` 以进行传输。这是你的电子邮件程序向接收者表示“我正在以这种方式发送此文件；你自己决定如何处理它。”的一种方式。``

``这种 `application/octet-stream` 类型也常用于在 Windows 系统上传输可执行文件（程序）。不幸的是，虽然方便，但这可能是一个严重的安全隐患。近年来，互联网一直受到病毒和蠕虫的持续侵袭，它们通过将自身作为电子邮件附件发送给其他用户来传播。这使得打开和运行任何未知的 `application/octet-stream` 附件可能具有潜在的危险。``

````# MIME Composite Media Types: Multipart and Encapsulated Message Structures    MIME discrete media types allow MIME to represent hundreds of different kinds of data in email messages. This alone would make MIME an incredibly useful technology, but the MIME standard goes one step further by defining *composite* media types. These allow MIME to perform even more spectacular feats, such as sending many types of data at once or encapsulating other messages or information into email.    The use of a MIME composite media type is indicated via the Content-Type header of an RFC 822 message. Instead of one of the six discrete media types (`text`, `image`, `audio`, `video`, `model`, or `application`), one of these two composite media types is used: `multipart`, which allows one or more sets of data to be sent in a single MIME message, and `message`, which allows a message to encapsulate another message.    ### Tip    **KEY CONCEPT** Two MIME composite media types exist: `message`, which allows one message to encapsulate another, and `multipart`, which allows multiple individual media types to be encoded into a single email message.    ## MIME Multipart Message Type    The `multipart` media type is the more common of the two types, and for good reason: It is an *incredibly* powerful mechanism. It allows one message to contain many different kinds of information that can be used in different ways. Each piece of data is encoded separately as a MIME body part, and the parts are combined into a single email message. How these parts are used depends on the semantics of the message, indicated by the MIME subtype. RFC 2046 describes several of these, and a few new ones have also been defined by the IANA registration scheme described earlier.    ### MIME Multipart Message Subtypes    Table 78-9 shows the most common multipart media subtypes and how they are used. The first four are defined in RFC 2046.    Table 76-9. Common MIME multipart Media Type Subtypes     | Type/Subtype | Description | Defining Source | | --- | --- | --- | | `multipart/mixed` | Indicates that the body parts are not really related, but they have been bundled for transport in a single message for convenience. For example, this might be used by someone to send an office memo along with a vacation snapshot just for fun. This subtype is also sometimes used when the parts are related but the relationship is communicated to the recipient in some other way (such as via a description in a distinct body part). | RFC 2046 | | `multipart/alternative` | Specifies that the body parts are alternative representations of the same information. The recipient decodes the parts and chooses the one that is best suited to her needs. A common use of this is in sending Hypertext Markup Language (HTML)-encoded email. Some email clients can't display HTML, so it is courteous to send a *multipart/alternative* message containing the message in both HTML and plain text forms. The alternatives should be placed in the message in increasing order of preference, meaning that the preferred format goes last. In the case of a document that includes plain text and rich text alternatives—such as the preceding example with plain text and HTML versions of a document—the plainest format should go first and the fanciest last. | RFC 2046 | | `multipart/parallel` | Tells the recipient that the body parts should all be displayed at the same time (in parallel). For example, someone sends an audio clip along with explanatory text to be displayed alongside it as it plays. | RFC 2046 | | `multipart/digest` | Allows a message to carry a digest, such as a collection of other email messages. | RFC 2046 | | `multipart/related` | Indicates specifically that the body parts are related to each other. Special parameters are used to provide more information on how they are to be interpreted. | RFC 2387 | | `multipart/encrypted` | Used for encrypted data. The first body part contains information on how the data is to be decrypted, and the second contains the data itself. | RFC 1847 |    ## Multipart Message Encoding    You can see just from the different subtypes shown in Table 78-9 how much flexibility the multipart type provides to MIME, and there are other subtypes. In all cases, the same syntax is used to encode the constituent body parts into a single message. The basic process is as follows:    1.  Each individual piece of data is processed as if it were to be transmitted as the body of a discrete media type MIME message. This includes the specification of appropriate headers, such as Content-Type, Content-ID, and Content-Transfer-Encoding, as needed.           2.  A special *boundary delimiter* is chosen to separate the body parts. It must be selected so that it will not appear in any of the body parts; a random string is sometimes used. It is prepended with two dashes (—) when placed in the message to reduce the chance of it being mistaken for data.           3.  The multipart message is assembled. It consists of a *preamble* text area, then a boundary line, followed by the first body part. Each subsequent body part is separated from the previous one with another boundary line. After the last body part, another boundary line appears, followed by an *epilogue* text area.           4.  The special parameter *boundary* is included in the Content-Type header of the message as a whole, to tell the recipient what pattern separates the body parts.              ### Tip    **KEY CONCEPT** MIME multipart messages are formed by first processing each individual data component to create a MIME *body part*. Each can have a distinct encoding method and set of headers, as if it were a separate MIME message. These body parts are then combined into a single multipart message and separated with a *boundary delimiter*. The identity of the delimiter is inserted into the *boundary* parameter of the *Content-Type* header, so the recipient can easily separate the individual body parts upon receipt of the message.    These rules may seem rather complicated, but once you've seen a couple of multipart messages, the structure will make sense. To help clarify multipart message encoding, Figure 76-1 shows graphically the overall structure of a multipart MIME message.    Example 76-1 contains a specific example of a multipart message (with portions abbreviated to keep the length down), so you can see what one looks like in text form. (If you want to see more, you probably have several in your own email inbox right now!)    Example 76-1. Example of a MIME multipart message    ``` From: Joe Sender <joe@someplace.org> To: Jane Receiver <jane@somewhereelse.com> Date: Sun, 1 Jun 2003 13:28:19 —0800 Subject: Photo and discussion MIME-Version: 1.0 Content-Type: multipart/mixed; boundary="exampledelimtext123"  This is a multipart message in MIME format  -exampledelimtext123 Content-Type: text/plain  Jane, here is the photo you wanted from me for the new client. Here are some notes on how it was processed. (Blah blah blah...) Talk to you soon, Joe.  -exampledelimtext123  Content-Type: image/jpeg; name="clientphoto.jpg" Content-Transfer-Encoding: base64  SDc9Pjv/2wBDAQoLCw4NDhwQEBw7KCIoOzs7Ozs7Ozs ... zv/wAARCADIARoDASIAAhEBAxEB/8QAHAAAAQUBA  -exampledelimtext123  (Epilogue) ```  ![MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called "Delimiter." This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.](img/httpatomoreillycomsourcenostarchimages288289.png)  Figure 76-1. MIME multipart message structure A MIME multipart message consists of a set of main headers and a main body portion, like all messages. Within the main body are one or more body parts, each of which has its own body-part-specific headers followed by the body part itself; each body part is shown in a black box. The Content-Type header of the message as a whole indicates that the message type is multipart, and the boundary parameter specifies the name of the delimiter, in this case just called "Delimiter." This delimiter is used to separate the body parts from each other and from the preamble and epilogue that begin and end the message body, respectively.    In this example, Joe is sending Jane a multipart message containing a JPEG photograph and some explanatory text. The main header of the message specifies the `multipart/mixed` type and a boundary string of `exampledelimtext123`. The message begins with the preamble, which is ignored by the recipient email client but can be seen by the human reader. It is common to put a string here such as the one given in this example. That way, if a person using a client that does not support MIME receives the message, the recipient will know what it is.    The first delimiter string is then placed in the message, followed by the first body part, the text Joe is sending Jane. This is preceded by whatever headers are needed by the body part, in this case `Content-Type: text/plain`. (Note, however, that this is the default in MIME, so it could be omitted here.) After the text message is another delimiter, and then the encoded JPEG photo in the second body part, with its own headers. Finally, there is one more delimiter, and then a space for the epilogue. This is ignored if present and is often not used at all.    It is possible to send a multipart message that has only a single body part. This is sometimes done to take advantage of the preamble area to provide information about how to decode a nontext media type. Of course, this can also be done by including such text decoding instructions as a body part.    ## MIME Encapsulated Message Type    The other composite media type is the `message` type, which is devoted to the special purpose of encapsulating existing email messages within the body of a new message, or encapsulating other types of messages. This may be another email message previously sent or a message of some other kind. This media type also provides flexibility for sending partial messages and other special types of communication. Table 76-10 shows the three subtypes defined in RFC 2046.    Table 76-10. Common MIME message Media Type Subtypes     | Type/Subtype | Description | Defining Source | | --- | --- | --- | | `message/rfc822` | Indicates that the body contains an encapsulated email, itself formatted according to the RFC 822 standard. Note that this doesn't necessarily mean it is a plain text email message; it could be a MIME message (though encapsulating MIME within MIME must be done carefully). | RFC 2046 | | `message/partial` | Allows the fragmentation of larger messages into pieces that can later be reassembled. | RFC 2046 | | `message/external-body` | Indicates that the body of the message is not actually contained in the message itself; instead, a reference is provided to where the body is located. Sufficient information to locate the real message body must be provided. | RFC 2046 |    ## MIME Content-Transfer-Encoding Header and Encoding Methods    One of the main reasons why MIME was created was the significant restrictions that the RFC 822 standard places on how data in email messages must be formatted. To follow the rules, messages must be encoded in US-ASCII, a 7-bit data representation. This means that even though each byte can theoretically have any of 256 values, in ASCII only 128 values are valid. Furthermore, lines can be no longer than 1,000 characters including the carriage return and line feed (CRLF) characters at the end, and those two characters cannot appear elsewhere.    For some types of data, such as text files, this is no big deal; but for others it is a serious problem. This is especially the case with binary data. If you look at the data in a video clip, MP3 file, or executable program, it will appear to be random gibberish. In fact, such data is not random; it is represented using specific rules, but the data is expressed in raw binary form, where any 8-bit byte can contain any value from 0 to 255, which is why it looks like junk to humans. More important, this means that this data does not follow the rules for RFC 822 files and cannot be sent directly in this form.    To send non-ASCII data in MIME, it must be encoded. The Content-Transfer-Encoding header is used to specify how a MIME message or body part has been encoded, so that it can be decoded by its recipient. Four types of encoding are defined: `7bit, 8bit`/`binary, quoted-printable`, and `base64`. The quoted-printable and base64 encodings are the most interesting ones, because they are what allow non-RFC-822 data to be sent using RFC 822.    ### Tip    **KEY CONCEPT** MIME supports four encoding methods: `7bit`, `8bit` (`binary`), `quoted-printable`, and `base64`. `7bit` encoding is standard ASCII and is used for text. `quoted-printable` encoding is for output that is mostly text but has some special characters that must be encoded. `base64` is used for arbitrary binary files. The 8-bit encoding method is defined in MIME but not used for RFC 822 messages.    ## 7-Bit and 8-Bit Encoding    `7bit` encoding indicates that the message is already in ASCII form compatible with RFC 822\. It is the default and is what is assumed if no Content-Transfer-Encoding header is present.    The `8bit` and `binary` values are synonymous. They mean the message has been encoded directly in 8-bit binary form. Yes, I did just say that this would violate the rules of RFC 822\. These options appear to have been included to support future mechanisms for transporting binary data directly. RFC 1652 describes an SMTP extension that discusses this in part: "SMTP Service Extension for 8bit-MIMEtransport" (there is no space between *MIME* and *transport*). However, the standard clearly states that this still does not allow the transfer of raw binary data using SMTP and RFC 822.    ## Quoted-Printable Encoding    Quotable-printable encoding is a special type that is used when most of the data is ASCII text, but it contains certain violations of the rules of RFC 822\. These illegal sections are converted using special encoding rules so the data as a whole is consistent with RFC 822; only the problem bytes are encoded. The result is that RFC 822 compatibility is achieved while maintaining most of the data as regular text so it can still be easily understood by a human.    An example would be letters with tildes or accents, such as those used in French or Spanish. Another would be a text message formed using an editor that inserts carriage return characters in the middle of a line. Most of the message is still text. The `quoted-printable` encoding can be used here, with the carriage return characters represented as =0D (the hexadecimal value of the character prepended by an equal sign). RFC 2046 contains more details on how this is done.    ## Base64 Encoding    In contrast, `base64` encoding is more often used for raw binary data that is not in human-readable form anyway, such as graphical image, audio, video, and application files. This encoding is used to allow arbitrary binary data to be represented in ASCII form. The data is then sent as ASCII and decoded back into binary form by the recipient. The idea behind this type of encoding is simple: The data that needs to be sent can have any value for each 8-bit byte, which is not allowed. So why not rearrange the bits so the data fits into the 7-bit ASCII limits of RFC 822?    This is done by processing the data to be sent three bytes at a time. There are 24 bits in each three-byte block, which are carved into four sets of 6 bits each. Each 6-bit group has a value from 0 to 63 and is represented by a single ASCII character, as presented in Table 76-11.    Table 76-11. MIME base64 Encoding Groups     | 6-Bit Value | Encoding | 6-Bit Value | Encoding | 6-Bit Value | Encoding | 6-Bit Value | Encoding | | --- | --- | --- | --- | --- | --- | --- | --- | | 0 | A | 16 | Q | 32 | g | 48 | w | | 1 | B | 17 | R | 33 | h | 49 | x | | 2 | C | 18 | S | 34 | i | 50 | y | | 3 | D | 19 | T | 35 | j | 51 | z | | 4 | E | 20 | U | 36 | k | 52 | 0 | | 5 | F | 21 | V | 37 | l | 53 | 1 | | 6 | G | 22 | W | 38 | m | 54 | 2 | | 7 | H | 23 | X | 39 | n | 55 | 3 | | 8 | I | 24 | Y | 40 | o | 56 | 4 | | 9 | J | 25 | Z | 41 | p | 57 | 5 | | 10 | K | 26 | a | 42 | q | 58 | 6 | | 11 | L | 27 | b | 43 | r | 59 | 7 | | 12 | M | 28 | c | 44 | s | 60 | 8 | | 13 | N | 29 | d | 45 | t | 61 | 9 | | 14 | O | 30 | e | 46 | u | 62 | + | | 15 | P | 31 | f | 47 | v | 63 | / |    For example, suppose the first three bytes of the data to be sent were the decimal values 212, 39, and 247\. These cannot all be expressed in 7-bit ASCII. In binary form, they are expressed like so:     | 11010100 00100111 11110111 |    We can divide these into four 6-bit groups:     | 110101 - 00 0010 - 0111 11 - 110111 |    Which yields the four values 53, 2, 31, and 55\. Thus, the values 214, 39, and 247 would be encoded as the three ASCII characters 1Cf3\. The conceptual steps of this process are shown in Figure 76-2.    ### Note    *The sequence of steps for the encoding are intended to help you understand the process. Computers inherently deal directly with bits and would not bother with converting to decimal before encoding the 6-bit groups into ASCII characters*.  ![MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.](img/httpatomoreillycomsourcenostarchimages288291.png.jpg)  Figure 76-2. MIME base64 encoding In this simplified example, three binary data bytes are encoded as four ASCII characters using MIME base64 encoding. Instead of transmitting those three bytes, two of which would not be valid in RFC 822, the four ASCII characters 1Cf3 are sent.    This 3-to-4 encoding is done for all the data. The converted ASCII characters are then placed into the body of the entity instead of the raw binary data, 76 characters to a line. I showed how this is done in the second body part in the example in Example 76-1 (except I didn't use 76 characters per line, to keep the line lengths short). One final character is involved in this scheme, the equal sign (=), which is used as a padding character when needed.    Since base64 characters are regular ASCII, they appear to SMTP like a regular text message. Of course, the data looks like gibberish to us, but that's not a problem since it will be converted back to its regular form and displayed to the recipient as an image, movie, audio, or whatever.    ### Tip    **KEY CONCEPT** MIME uses *base64* encoding to transform arbitrary 8-bit files into a form that is acceptable for communication in email. Each set of three 8-bit bytes is divided into four 6-bit groups, and each 6-bit group is represented by an ASCII character. Since the data is ASCII, it conforms to the RFC 822 message format standard, even if it is not human-readable. The receiving device reverses the encoding, changing each four-character block back into three 8-bit bytes.    The main drawback of the base64 method is that it is about 33 percent less efficient than sending binary data directly, using a protocol like the File Transfer Protocol (FTP). The reason is that three 8-bit bytes of binary data are sent as four ASCII characters, but of course, each ASCII character is represented using 8 bits itself. So there is one-third more overhead when using base64\. In most cases, this is not a big deal, but it can be significant if downloading very large email files over a slow Internet connection.    Note that RFC 2046 also defines two other encodings: `ietf-token` and `x-token`. These are included to allow new encoding types to be defined in the future.    # MIME Extension for non-ASCII Mail Message Headers    All of the MIME mechanisms discussed up to this point deal with ways of encoding different kinds of ASCII and non-ASCII data into the *body* of an RFC 822 message. In addition to these capabilities, MIME also includes a way in which non-ASCII data can be encoded into *headers* of an RFC 822 message.    At this point, you might be wondering why anyone would want to do this. Sure, it makes sense to be able to use MIME to encode binary data such as an image into an email, but why do it in a header? Well, if you can't see the need for this, chances are that you are a native English speaker. ASCII does a great job of representing English, but isn't so good with many other languages. With RFC 822, speakers of languages that use non-ASCII characters were unable to use descriptive headers fully, such as the Subject and Comments headers. Some could not even properly express their own names!    The solution to this problem is the subject of RFC 2047, the third of the five main MIME standards. It describes how to encode non-ASCII text into ASCII RFC 822 message headers. The idea is straightforward: As with message bodies, the non-ASCII text is replaced with ASCII, and information is provided to describe how this was done.    With this technique, the value of a regular header is replaced by a MIME *encoded-word* that has the following syntax:     | =?*<charset>*?*<encoding>*?*<encoded-text>*?= |    The strings `=?` and `?=` are used to *bracket* the non-ASCII header, which flags it as a MIME encoded header to the recipient's email client. The other elements, separated by `?`, indicate how the non-ASCII text is encoded, as follows:    **<charset>** The character set used, such as `iso-8859-1`.    **<encoding>** Two different encoding types are defined, each represented by a single letter for brevity: `B` indicates base64 encoding, and `Q` indicates quoted-printable encoding (these encoding types are discussed in the previous section.    **<encoded-text>** The non-ASCII text that has been encoded as ASCII using the encoding type indicated.    As you can see, this method is analogous to how a non-ASCII message body or body part would be encoded, but the information about the encoding has been condensed so everything can fit in a single header line. The *<charset>* parameter is somewhat analogous to the Content-Type header for a message body, but since headers can contain only text, it specifies what kind of text it is. The *<encoding>* parameter is clearly equivalent to the Content-Transfer-Encoding header.    ### Tip    **KEY CONCEPT** In addition to its many functions for encoding a variety of data in email message bodies, MIME provides a feature that allows non-ASCII information to be placed into email headers. This is done by encoding the data using either *quoted-printable or base64* encoding, and then using a special format for the header value that specifies its encoding and character set. This technique is especially useful for email sent in languages that cannot be represented easily in standard ASCII, such as many Asian languages.    Here's an example of a non-ASCII header, using the GB2312 character set (for Chinese characters) and base64 encoding:    ``` Subject: =?GB2312?B?u7bTrbLOvNPDwLn61bm74Q==?= ```    I hope that doesn't say anything inappropriate; I took it from a piece of spam email I received once!    # Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)  ![image with no caption](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)  I emphasized in my overall description of TCP/IP email that communication using email requires the interaction of various protocols and elements. One mistake that some people make is to equate the method used for delivering email with the entire system. This is, however, an understandable mistake—just as the postal service is only a part of the whole system of mailing a letter, it is nonetheless a very big part. Likewise, the delivery of email from sender to recipient is arguably the most important part of email as a whole. In modern TCP/IP, this task is the responsibility of the *Simple Mail Transfer Protocol (SMTP)*.    In this chapter, I describe in detail the operation of SMTP. I begin with an overview and history of the protocol and a discussion of the standards that define it. I then examine the way that SMTP client/server communication and message transport work. I explain the way that SMTP servers establish connections and transaction sessions, and then the process by which mail is transferred from one server to another. I describe some of the special features implemented in SMTP and discuss SMTP security issues. I conclude with a reference summary of SMTP commands and replies.    ### Tip    **BACKGROUND INFORMATION** *My discussion of SMTP assumes that you already have a basic understanding of the general concepts of TCP/IP email, as well as familiarity with TCP/IP email addressing and message formatting. These topics are discussed in Chapters Chapter 74, Chapter 75, and Chapter 76, respectively*.    # SMTP Overview, History, and Standards    The overview and history of the TCP/IP email system in Chapter 74 describes how TCP/IP evolved from its early beginnings to its current form. Since the mechanism used to deliver email is such a big part of the system as a whole, any overview of the system must of necessity discuss how delivery mechanisms have changed as well. In the case of TCP/IP, the delivery of mail evolved through many forms during the 1970s, as developers sought to find effective ways of communicating email messages between systems. Most of these efforts involved attempts to transmit mail using existing protocols; this makes sense, since it is easier to adapt a technology than design one from scratch.    ## SMTP Standards    One important achievement in the development of a mail system was the publishing of the *Mail Transfer Protocol (MTP)*, which was first defined in RFC 772 in September 1980, and then updated in RFC 780 in May 1981\. MTP describes a set of commands and procedures by which two devices can connect using TCP to exchange email messages. Its operation is described largely using elements borrowed from two early TCP/IP application protocols that were already in use at that time: Telnet and the File Transfer Protocol (FTP). The commands of MTP are actually based directly on those of FTP.    Although there was nothing inherently wrong with basing email delivery on FTP, defining it this way made MTP somewhat of a hack. It was also restricted to the capabilities defined by FTP, a general file transfer protocol, so it was not possible to include features in MTP that were specific to sending and receiving mail. Due to the importance of email, a specific protocol designed for the purpose of delivering email was warranted. SMTP was first defined in RFC 788 and published in November 1981.    The name suggests that SMTP is simpler than the protocol that it replaced. Whether or not this is true is somewhat a matter of opinion; I do note that RFC 788 is 61 pages long, while the earlier RFC 780 was only 43 pages. What SMTP definitely has over MTP is *elegance*; the protocol is designed specifically for the transport of email. While it retains certain similarities to FTP, it is an independent protocol running over the Transmission Control Protocol (TCP). So, from a conceptual standpoint, it can be considered simpler than MTP. In terms of mechanics, the process SMTP uses to transfer an email message is indeed rather simple, especially compared to some other protocols.    RFC 788 described the operation of SMTP carrying email messages corresponding to the ARPAnet text message standard as described in RFC 733\. Development of both email messages and SMTP continued, and in August 1982, a milestone in TCP/IP email was achieved when RFCs 821 and 822 were published. RFC 821 revised SMTP and became the defining standard for the protocol for the next two decades. RFC 822, its companion standard, became the standard for TCP/IP email messages carried by SMTP.    ### Tip    **KEY CONCEPT** The most important component of the TCP/IP email system is the *Simple Mail Transfer Protocol (SMTP)*. SMTP was derived from the earlier Mail Transfer Protocol (MTP) and is the mechanism used for the delivery of mail between TCP/IP systems and users. The only part of the email system for which SMTP is not used is the final retrieval step by an email recipient.    As the 1980s progressed, and TCP/IP and the Internet both grew in popularity, SMTP gradually overtook other methods to become the dominant method of email message delivery. For a number of years, the protocol was used mostly as is, with no new RFCs published to define new versions or formally change its behavior. This changed in February 1993, when RFC 1425, "SMTP Service Extensions," was published. As the name suggests, this standard describes a process for adding new capabilities to extend how SMTP works, while maintaining backward compatibility with existing systems. SMTP with these extensions is sometimes called *Extended SMTP* or *ESMTP* (though use of this term seems not to be entirely universal).    As development of SMTP continued, RFC 1425 was revised in RFC 1651 in July 1994, and then in RFC 1869 in November 1995\. Along with these revisions, a number of other RFCs defining particular SMTP extensions, such as pipelining and message size declaration, were defined.    In April 2001, another major milestone in TCP/IP email was reached when revisions of RFC 821 and RFC 822 were published, as RFCs 2821 and 2822, respectively. Both documents are consolidations of updates and changes that had been made to RFCs 821 and 822 between 1982 and 2001\. And, no, I don't think it is a coincidence that the old and new RFC numbers are exactly 2,000 apart. RFCs 2820 and 2823 were both published in May 2000, so it looks like 2821 and 2822 were reserved for the email standards. I think this naming was a great idea, as it makes it clear that the new RFCs are revisions of the old ones.    RFC 2821 is the current base standard for SMTP. It incorporates the base protocol description from RFC 821 and the latest SMTP extensions as defined in RFC 1869\. It updates the description of the email communication model to reflect the realities of modern TCP/IP networks, especially the email features built into the Domain Name System (DNS). We'll examine this in more detail in the next section.    ## SMTP Communication and Message Transport Methods    The TCP/IP email communication model describes the way email messages are conveyed from the sender to the recipient. In most cases, this involves the sender's client machine sending the email to its local SMTP server, which sends it to the recipient's local SMTP server, which then sends it to the recipient's local host. SMTP handles the transport between SMTP servers. In fact, the overall email communication model is largely described by the RFC 821 and 2821 SMTP standards.    The initial communication takes place between the sender's client machine and a local SMTP server that the sender is allowed to access. After submission of the email message, that SMTP server becomes responsible for delivering the message to the SMTP server responsible for the recipient's mailbox.    ### Early Email Communication Using Relaying    In the early days of email, when RFC 821 and its predecessors were first defined, the Internet was very different from what it is today. There was no DNS, and this made email delivery complex, because there was no way to map a mailbox address to the IP address of the SMTP server that managed that mailbox. Also, many proprietary networks were connected to the Internet, which meant that it was not always possible for any particular system to communicate with any other.    Given this, how could email be delivered? The most common way in the early days of SMTP was through a process called *relaying*. SMTP routing information was included along with the email address, to specify a sequence of SMTP servers that the mail should be relayed through to get to its destination. For example, if a sender using SMTP Server A wanted to send email to someone whose mailbox was on SMTP Server Z, the sender might have needed to specify that the mail be sent through intermediate SMTP Servers D, P, and U to get there. An SMTP connection would be established from Server A to Server D to send the message on one leg of its journey; then it would go from Server D to P, Server P to U, and then Server U to Z. The process is analogous to how Internet Protocol (IP) routing works, but at the application layer (actually using IP routing at a lower level).    You can probably see the problems with this quite easily: It's cumbersome, requires many devices to handle the mail, results in delays in communication, and requires the communication of source routes between SMTP servers. It was certainly functional, but it was far from ideal.    ### Modern Email Communication Using DNS and Direct Delivery    The creation of DNS radically changed how email delivery worked. DNS includes support for a special *mail exchange (MX)* record that allows easy mapping from the domain name in an email address to the IP address of the SMTP server that handles mail for that domain. I explain this in the description of the regular email address format in Chapter 76, as well as the section about DNS email support in Chapter 56.    In the new system, SMTP communication is much simpler and more direct. The sending SMTP server uses DNS to find the MX record of the domain to which the email is addressed. This gives the sender the DNS name of the recipient's SMTP server. This is resolved to an IP address, and a connection can be made directly from the sender's SMTP server to the recipient's server to deliver the email. While SMTP still supports relaying, direct email delivery using MX records is faster and more efficient, and RFC 2821 makes clear that this is now the preferred method.    In this new system, SMTP is generally used only for two transfers: first, from the sender's client machine to the sender's local SMTP server, and then from that server to the recipient's local SMTP server, as shown in Figure 74-1 in Chapter 74. (A distinct mail access protocol or method is used by the recipient for the last leg of the journey.) Each transfer of an email message between SMTP servers involves the establishment of a TCP connection, and then the transfer of the email headers and body using the SMTP mail transfer process. The following sections describe in detail how this occurs.    ### Tip    **KEY CONCEPT** In the early days of SMTP, mail was delivered using the relatively inefficient process of relaying from server to server across the internetwork. Today, when an SMTP server has mail to deliver to a user, it determines the server that handles the user's mail using the Domain Name System (DNS) and sends the mail directly to that server.    ## Terminology: Client/Server and Sender/Receiver    The original RFC 821 standard referred to the device that initiates an SMTP email transfer as the *sender* and the device that responds to it as the *receiver*. These terms were changed to *client* and *server* in RFC 2821 to "reflect current industry terminology." Strictly speaking, this is correct, but in some ways, the more current terminology is significantly *less* clear.    As I explained in the general discussion of TCP/IP client/server operation in Chapter 8, the terms *client* and *server* are used in many different senses in networking, which often leads to confusion. In common parlance, the computers that handle email on the Internet are usually all called *SMTP servers*. This is because they run SMTP server software to provide SMTP services to client machines, such as end-user PCs. In addition, these devices are usually dedicated hardware servers running in network centers, typically managed by Internet service providers (ISPs).    However, the terms *client* and *server* are now used to refer to the roles in a particular SMTP communication as well. Since all SMTP servers both send and receive email, they all act as both clients and servers at different times. An SMTP server that is relaying an email will act as both server and client for that message, receiving it as a server, and then sending it to the next server as a client. Adding to this potential confusion is the fact that the initial stage in sending an email is from the sender's client machine to the sender's local SMTP server. Thus, the client role in an SMTP transaction may not be an actual SMTP server, but the server role will always be a server.    For all of these reasons, the old terms *sender* and *receiver* are still used in places in RFC 2821, where needed for clarity. I consider them much more straightforward and use them in the rest of this chapter.    ### Tip    **KEY CONCEPT** SMTP servers both send and receive email. The device sending mail acts as a client for that transaction, and the one receiving it acts as a server. To avoid confusion, it is easier to refer to the device sending email as the *SMTP sender* and the one receiving as the *SMTP receiver*; these terms were used when SMTP was originally created.    # SMTP Connection and Session Establishment and Termination    The delivery of email using SMTP involves the regular exchange of email messages among SMTP servers. SMTP servers are responsible for sending email that users of the server submit for delivery. They also receive email intended for local recipients, or for forwarding or relaying to other servers.    ## Overview of Connection Establishment and Termination    All SMTP communication is done using TCP. This allows SMTP servers to make use of TCP's many features that ensure efficient and reliable communication. SMTP servers generally must be kept running and connected to the Internet 24 hours a day, seven days a week, to ensure that mail can be delivered at any time. (This is a big reason why most end users employ access protocols such as the Post Office Protocol to access their received email rather than running their own SMTP servers.) The server listens continuously on the SMTP server port, well-known port number 25, for any TCP connection requests from other SMTP servers.    An SMTP server that wishes to send email normally begins with a DNS lookup of the MX record corresponding to the domain name of the intended recipient's email address to get the name of the appropriate SMTP server. This name is then resolved to an IP address; for efficiency, this IP address is often included as an *additional* record in the response to the MX request to save the sending server from needing to perform two explicit DNS resolutions.    The SMTP sender then establishes an SMTP session with the SMTP receiver. Once the session is established, mail transactions can be performed to allow mail to be sent between the devices. When the SMTP sender is finished sending mail, it terminates the connection. All of these processes involve specific exchanges of commands and replies, which are illustrated in Figure 77-1.    Let's take a look at these processes in more detail, starting with SMTP session establishment.    ## Connection Establishment and Greeting Exchange    The SMTP sender begins by initiating a TCP connection to the SMTP receiver. The sending SMTP server uses an ephemeral port number, since it is playing the role of the client in the transaction. Assuming that the server is willing to accept a connection, it will indicate that it is ready to receive instructions from the client by sending reply code 220\. This is called the *greeting* or *service ready* response. It commonly includes the full domain name of the server machine, the version of the SMTP server software it is running, and possibly other information.    Now, it would be rude for the server acting as a client to start sending commands to the responding server without saying hello first, wouldn't it? So that's exactly what comes next: the client says, "Hello." In the original SMTP protocol, this is done by issuing a HELO command, which includes the domain name of the sending (client) SMTP server as a courtesy. The receiving device then responds back with a return hello message using an SMTP reply code 250.    For example, if the SMTP server smtp.sendersite.org was making a connection to the SMTP server [mail.receiversplace.com](http://mail.receiversplace.com), it would say:    ``` HELO smtp.sendersite.org. ```    After receiving this greeting, [mail.receiversplace.com](http://mail.receiversplace.com) would respond back with a `hello` message of its own, something like this:    ``` 250 mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you. ```  ![SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.](img/httpatomoreillycomsourcenostarchimages288293.png.jpg)  Figure 77-1. SMTP transaction session establishment and termination An SMTP session begins with the SMTP sender establishing a TCP connection to the SMTP receiver. The receiver sends a ready message; the sender sends a HELO or EHLO command, to which the receiver responds. Assuming no difficulties are encountered, the session is established and mail transactions take place. When the sender is finished, it sends a QUIT command; the receiver responds with a 221 reply and closes the session.    (The chatty text is of course purely optional; most of the time, SMTP communication is between software programs, so the pleasantries are usually written by programmers who have a sense of humor.)    ## Connection Establishment Using SMTP Extensions    The SMTP extensions first defined in RFC 1425, and then in subsequent standards up to RFC 2821, define an alternative hello message for the client to use: EHLO (extended hello). An SMTP sender supporting SMTP extensions (and most do) uses EHLO instead of HELO in response to the 220 greeting. This serves both to say hello to the SMTP receiver and to tell it that the sender supports SMTP extensions.    If the SMTP receiver supports the extensions, it replies with the usual 250 reply, as well as a series of extra 250 responses. Each of these lists an EHLO *keyword* that indicates a particular SMTP extension the receiver supports. If the receiving server doesn't support the extensions, it will reject the EHLO command with a 500 reply code ("syntax error, command not recognized"). This tells the SMTP sender that it cannot use extensions. It will then issue a conventional HELO command, or it will QUIT the connection if it requires the SMTP extension to be present. (In practice, it is rare for a server to *require* the use of SMTP extensions.)    Here's the same example used earlier, but using EHLO. The sender says:    ``` EHLO smtp.sendersite.org. ```    Assuming [mail.receiversplace.com](http://mail.receiversplace.com) supports the SMTP extensions, a typical reply might look like this:    ``` 250-mail.receiversplace.com Hello smtp.sendersite.org, nice to meet you. 250-SIZE 250-DSN 250 PIPELINING ```    Each of these additional replies identifies a particular SMTP extension supported by [mail.receiversplace.com](http://mail.receiversplace.com); in this case, message size declaration (SIZE), delivery status notification (DSN), and command pipelining. (The dashes after the 250 indicate a multiple-line response to a command; this is discussed in the "SMTP Multiple-Line Text Replies" section later in the chapter.)    Once the HELO or EHLO command has been sent and the receiving device has responded, the session is initiated. Further commands can be sent by the sending SMTP server to the responding server. These usually take the form of email message transfer transactions using the process described in the upcoming "SMTP Mail Transaction Process" section, and other command/reply exchanges as needed.    ## Connection Termination    When the sending device is finished sending all the email it has to transfer to the receiving device, and it has completed all its other activities, it terminates the session by issuing the QUIT command. This normally results in a 221 "goodbye" message from the SMTP receiver, which says something like "closing transmission channel." The TCP connection is then terminated.    ### Tip    **KEY CONCEPT** An SMTP session consists of three basic phases. The session is first *established* through the creation of a TCP connection and the exchange of identity information between the SMTP sender and receiver using the HELO command. Once established, *mail transactions* can be performed. When the SMTP sender is finished with the session, it *terminates* it using the QUIT command. If *SMTP extensions* are supported, the SMTP sender uses the *EHLO (extended hello)* command instead of *HELO*, and the SMTP receiver replies with a list of extensions it will allow the SMTP sender to use.    A server may also terminate prematurely in special cases. If it is given a local command to shut down (for example, due to imminent rebooting of the hardware server on which it is running), it may respond to any routine command with a 421 response ("Service not available, closing transmission channel"). A server is not supposed to terminate a session simply due to receipt of an invalid command, however; this should happen only in special cases where session termination cannot be avoided.    # SMTP Mail Transaction Process    As described in the previous section, the delivery of an email message begins with the establishment of an SMTP session between the devices sending and receiving the message. The SMTP sender initiates a TCP connection to the SMTP receiver and then sends a HELO or an EHLO command, to which the receiver responds. Assuming no problems ensue, the session is then established and ready for actual email message transactions.    ## Overview of SMTP Mail Transaction    The SMTP mail transaction process itself consists of three steps:    *   **Transaction Initiation and Sender Identification** The SMTP sender tells the SMTP receiver that it wants to start sending a message and gives the receiver the email address of the message's originator.           *   **Recipient Identification** The sender tells the receiver the email address(es) of the intended recipients of the message.           *   **Mail Transfer** The sender transfers the email message to the receiver. This is a complete email message meeting the RFC 822 specification (which may be in MIME format as well).              That's it! So you can see that the word *Simple* in *Simple Mail Transfer Protocol* definitely has at least *some* merit. In fact, one question that sometimes comes up when examining SMTP is "Why couldn't this process be even simpler?" The first two steps identify the sender of the email and the intended recipient(s). But all of this information is already contained in headers in the message itself. Why doesn't SMTP just read that information from the message, which would make the mail transaction a *one-step* process?    The explanation isn't specifically addressed in the SMTP standards, but I believe there are several reasons for this:    *   Specifying the sender and recipients separately is more efficient, as it gives the SMTP receiver the information it needs up front before the message itself is transmitted. In fact, the SMTP receiver can decide whether or not to accept the message based on the source and destination email addresses.           *   Having this information specified separately gives greater control on how email is distributed. For example, an email message may be addressed to two recipients, but they may be on totally different systems; the SMTP sender might wish to deliver the mail using two separate SMTP sessions to two different SMTP receivers.           *   In a similar vein, there is the matter of delivering blind carbon copies. Someone who is BCC'ed a message must receive it without being mentioned in the message itself.           *   Having this information separate makes implementing security on SMTP much easier.              For these reasons, SMTP draws a distinction between the message itself, which it calls the *content*, and the sender and recipient identification, which it calls the *envelope*. This is consistent with our running analogy between regular mail and email. Just as the postal service delivers a piece of mail using only the information written on the envelope, SMTP delivers email using the envelope information, not the content of the message. It's not quite the case that the SMTP server doesn't look at the message itself, just that this is not the information it uses to manage delivery.    ### Note    *It is possible for the sender of a message to generate envelope information based on the contents of the message, but this is somewhat external to SMTP itself. It is described in the standard, but caution is urged in exactly how this is implemented*.    ## SMTP Mail Transaction Details    Let's take a more detailed look at the SMTP mail transaction process, using as aids the process diagram in Figure 77-2 and the sample transaction of Example 77-1 (which has commands highlighted in bold and replies in italics).    Example 77-1. Example of an SMTP mail transaction    ``` `MAIL FROM:<joe@someplace.org>` *`250 <joe@someplace.org> . . . Sender ok`* `RCPT TO:<jane@somewhereelse.com>` *`250 <jane@somewhereelse.com> . . . Recipient ok`* `DATA` *`354 Enter mail, end with "." on a line by itself`* `From: Joe Sender <joe@someplace.org>` `To: Jane Receiver <jane@somewhereelse.com>` `Date: Sun, 1 Jun 2003 14:17:31 --0800` `Subject: Lunch tomorrow`  `Hey Jane,`  `It's my turn for lunch tomorrow. I was thinking we could` `[rest of message]` `Hope you are free. Send me a reply back when you get a chance.` `Joe.` `.` *`250 OK`* ```  ![SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.](img/httpatomoreillycomsourcenostarchimages288295.png.jpg)  Figure 77-2. SMTP mail transaction process Once an SMTP session is established between a sender and receiver, each mail transaction consists of a set of three command/reply sequences. The sender is first identified using the MAIL command and the recipients are specified using one or more RCPT commands. The actual mail message is then transferred using the DATA command, which involves a preliminary reply before the actual message is sent and a completion reply when it has been fully received.    The first two steps in the mail transaction are responsible for providing the receiving SMTP server with the envelope information just discussed. The transaction begins by the SMTP sender issuing a MAIL command. This serves to inform the receiver that a new transaction is commencing and also to tell it the *from* information on the envelope. Here's an example:    ``` MAIL FROM:<joe@someplace.org> ```    The email address of the originator is always enclosed in angle brackets (< and >). The SMTP receiver acknowledges the command with a 250 ("OK") reply message, sometimes sending back the address as a confirmation. Here's an example:    ``` 250 <joe@someplace.org> . . . Sender ok ```    Next, the SMTP sender uses RCPT commands to specify the intended recipients of the email that is being sent. Each RCPT line can contain only one recipient, so if multiple recipients are indicated, two or more RCPT commands must be issued. Each one normally specifies an email address, but if relaying is being used, the command may contain routing information as well. (As described earlier in the "SMTP Communication and Message Transport Methods" section, this is not as commonly done as it was in the past.) Here's an example:    ``` RCPT TO:<jane@somewhereelse.com> ```    Assuming the server accepts the email, it will give a 250 "OK" reply again, like so:    ``` 250 <jane@somewhereelse.com> . . . Recipient ok ```    The SMTP sender then issues the DATA command, which tells the SMTP receiver that the message is coming:    ``` DATA ```    The SMTP receiver responds with a 354 "intermediate" reply message, such as this:    ``` 354 Enter mail, end with "." on a line by itself ```    The SMTP sender then sends the email message, one line at a time, with a single dot (.) on a line to terminate it. The server confirms the receipt of the message with another 250 "OK" reply, and the transaction is finished.    ### Tip    **KEY CONCEPT** After an SMTP session is established, email messages are sent using the SMTP *mail transaction process*. The SMTP sender starts the transaction by identifying the sender of the email and then specifying one or more recipients. The email message itself is then transmitted to the SMTP receiver. Each email to be sent is a separate transaction.    While this indeed is quite simple, notice that I have shown an email transfer from a sender to one recipient, one in which there were no problems or complications in the transaction. Due either to command syntax or server issues, it is possible for various types of errors to occur at different stages of the process, which may result in the transaction failing. As you'll see shortly, security concerns may come also into play, leading to restrictions in what transactions a server may allow.    # SMTP Special Features, Capabilities, and Extensions    The primary job of the SMTP is to implement the TCP/IP email delivery system. Whenever the user of an SMTP server gives it an email message addressed to a remote mailbox, the server will attempt to transfer it to the appropriate destination server, using the SMTP mail transaction process. Many billions of such transfers are performed every day on the Internet, allowing email to reach its destination quickly anywhere around the world.    ## SMTP Special Features and Capabilities    In addition to this basic transfer mechanism, SMTP includes a number of other features and capabilities. These allow SMTP to support special requirements and auxiliary needs of the mail system, as described in detail in RFC 2821\. It would take many pages to describe them all in detail, so I will provide a quick summary of the more important ones here so you know a bit about them.    The following are some of SMTP's special features:    **Mail Relaying** As discussed in the "SMTP Communication and Message Transport Methods" section earlier in this chapter, the protocol was once widely used in a relaying mode, where email was routed from one SMTP server to another to reach its destination. Today, the more efficient, normal method of email transfer on the Internet is directly from the sender's SMTP server to the recipient's server, using DNS MX records to determine the recipient SMTP server address. SMTP still includes the ability to relay mail from one server to another, provided certain conditions are met. Note that many servers won't relay mail because this feature has been abused for spamming and malicious hacking.    **Mail Forwarding** Under certain conditions, an SMTP server may agree to accept email for a remote mailbox and forward it to the appropriate destination. This sounds similar to relaying but is used in a different way. A common example is when users change their email address. For example, if you have worked at XYZ Industries for years and then retire, the company may no longer wish to let you receive email at the company's SMTP server. As a courtesy, however, they may forward email sent to you there, so that you receive it at your new company.    **Mail Gatewaying** Certain SMTP servers may be configured as email gateways. These devices translate TCP/IP email into a form suitable for another email system, and vice versa. Gatewaying is a complex topic because email systems can be so different. One of the more important problems is the inconsistency of addressing methods of different email systems.    **Address Debugging** SMTP includes a VRFY (verify) command that can be used to check the validity of an email address without actually sending mail to it.    **Mailing List Expansion** The SMTP command EXPN (expand) can be used to determine the individual email addresses associated with a mailing list. (Note, however, that this has nothing directly to do with mailing list software like *Majordomo*.)    **Turning** The original SMTP included a command that allows the SMTP sender and SMTP receiver to change roles. This could be used to allow SMTP Server A to send email to Server B, and then have Server B send email it has queued for Server A in the same session. In practice, this capability was not widely used for a variety of reasons, including security considerations. It is now officially not recommended but may still be implemented in some SMTP software.    These are just a few of the features that are mentioned in the SMTP standards. In addition, developers of a particular type of SMTP server software may give it other features as well. The HELP command is one way of determining what commands are supported by a particular SMTP server.    SMTP servers also must perform a great deal of background processing that doesn't get a great deal of attention. This includes managing connections, checking for errors in commands and email messages, and reacting accordingly. They must also be on the lookout for problem conditions, such as looping that may result in an email message being passed back and forth between two SMTP servers, each thinking the other is the intended recipient. In the event of an initial failure to deliver mail, an SMTP server is also required to retry communication periodically with the destination device and return a failure message to the sender if it cannot deliver the message after a certain period of time. RFC 2821 contains more details.    ## SMTP Extensions    As discussed earlier in this chapter, during the 1990s, many extensions to the basic operation of SMTP were defined. These are enabled when two SMTP servers supporting the extension set up a session using the EHLO command and appropriate extension response codes. Table 77-1 summarizes some of the more interesting SMTP extensions that have been defined and gives the RFC number where each is described. You can find the full current set of SMTP extensions at [`www.iana.org/assignments/mail-parameters`](http://www.iana.org/assignments/mail-parameters).    Table 77-1. SMTP Extensions     | Extension Keyword | Extension | Defining Document | Description | | --- | --- | --- | --- | | 8BITMIME | 8-bit MIME support | RFC 1652 | Theoretically defines support for the 8-bit content transfer encoding type in MIME, but complications associated with this. See the discussion of content encoding in Chapter 76 for details. | | AUTH | Authorization | RFC 2554 | Used to implement an authorization mechanism for servers requiring enhanced security. | | DSN | Delivery status notification | RFC 1891 | Allows an SMTP sender to request that the SMTP receiver notify it if a problem occurs in delivering a message. | | ENHANCEDSTATUSCODES | Enhanced status codes | RFC 2034, RFC 1893 | Extends the traditional three-digit SMTP reply code format with extra codes that provide more information. See the "SMTP Replies and Reply Codes" section later in this chapter for more information. | | PIPELINING | Command pipelining | RFC 2920 | Allows multiple commands to be transmitted in batches from the SMTP sender to the receiver, rather than sending one command at a time and waiting for a response code. | | SIZE | Message size declaration | RFC 1870 | Allows information about the size of a message to be declared by an SMTP sender prior to transmitting it, so the SMTP receiver can decide if it wants the message or not. |    ### Note    *Certain commands in the basic SMTP description that are considered optional are also sometimes considered extensions, such as the EXPN and HELP commands; I have not listed these here, since they are not true SMTP extensions*.    # SMTP Security Issues    When it comes to security and SMTP, the theme is a common one in TCP/IP: A lack of security in how the protocol is implemented, because it was developed when the Internet was just a small group of machines controlled by individuals who mostly knew and trusted each other or who were able to use physical security. Developers never imagined TCP/IP being used by millions of anonymous average Joes around the world, which necessitates far more attention to security than a small research internetwork like the ARPAnet.    With SMTP, security matters are, if anything, *worse* than they are with some of the other protocols. Not only does SMTP not have any real security mechanism, the original relaying model of SMTP communication is entirely designed around the idea of cooperation and trust among servers. Since most SMTP servers would be asked to handle a certain number of intermediate transfers, each server was required to accept mail from any originator to be delivered to any destination.    The basic assumption in this model is that users of SMTP servers would all be well behaved and not abuse the system by flooding intermediate servers with a lot of mail to be delivered or sending bogus messages to cause problems. This all changed as the Internet exploded in popularity in the 1990s. Con artists, malicious hackers, and disreputable salespeople discovered that email could be used for free delivery of messages simply by submitting them to an SMTP server for delivery. The result was overloaded servers, primarily due to the sending of large quantities of unwanted email, which Internet users commonly call *spam*.    ### Note    *The term spam, in this context, has nothing directly to do with the Hormel processed meat product. Its use in reference to massive amounts of email comes from a Monty Python comedy sketch in which that word is repeated in phrases over and over again*.    It is actually very easy to impersonate an SMTP server. You can use the Telnet Protocol to connect directly to an SMTP server on port 25\. SMTP commands are all sent as text, and so are SMTP replies, so you can have a conversation with a server, and even manually perform a mail transaction. This is useful for debugging, but it also makes abuse of a wide-open SMTP server trivially easy. Since spammers often don't want to be identified, they employ spoofing techniques to make it more difficult to identify them, so resolving these problems is even more difficult.    Despite this obvious dilemma, efforts to implement a general security mechanism in SMTP have been resisted for two main reasons. First, there is no foolproof way to retrofit a new security mechanism onto something as widely used as SMTP without creating incompatibilities between newer and older systems. Second, many administrators were reluctant to do away completely with the general notion of cooperation among sites that has helped make the Internet so successful.    Still, something had to be done. The compromise was for system administrators to tighten up their SMTP servers through the imposition of both technical and policy changes. Naturally, these vary from one organization to another. Some of the more common SMTP security provisions include the following:    *   Checking the IP address of a device attempting connection and refusing even to start an SMTP session unless it is in a list of authorized client devices.           *   Restricting certain commands or features, such as email relaying, to authorized users or client servers. This is sometimes done by requiring authentication via the SMTP extension AUTH before the command will be accepted.           *   Limiting the use of commands such as EXPN to prevent unauthorized users from determining the email addresses of users on mailing lists.           *   Checking the validity of envelope information before accepting a message for delivery. Some servers will first verify that the originator's email address is valid before agreeing to accept the MAIL command. Many will check the recipient's address and refuse the message if delivery is not to a local mailbox. Others use even more advanced techniques.           *   Limiting the size of email messages that may be sent or the number that may be sent in a given period of time.           *   Logging all access to the server to keep records of server use and check for abuse.              Because of all the abuse in recent years, you will find that most SMTP servers implement these or other features, even though most of those features are not formally defined by the SMTP standards. Rather, they are enhancements built into individual SMTP server software packages.    SMTP was designed during an era in which Internet security was not much of an issue; as a result, the base protocol includes no security mechanism at all. Since email is so often abused today, most modern SMTP servers incorporate one or more security features to avoid problems.    Some of these measures can actually be quite sophisticated. For example, the SMTP server run by pair Networks, the great web-hosting company I have used for years, uses *POP-before-SMTP authentication*. This means that before the server will accept outgoing mail from the user via SMTP, the user must first log in to check incoming mail using the Post Office Protocol (POP). Since POP includes authentication, a successful POP login tells the server the user is authorized. This "flips a switch" in the server that allows the user to access the SMTP service after that login for a limited period of time. If this seems convoluted, then you're starting to get an idea of the hassle that spammers and malicious hackers have created for ISPs today.    It's also worth noting that SMTP does not include any mechanism for encryption to ensure the privacy of email transmissions. Users requiring security to control who sees their messages must use a separate encryption scheme to encode the body of the message prior to submission.    # SMTP Commands    Early TCP/IP email mechanisms were developed by borrowing techniques and elements from existing application protocols, especially Telnet and FTP. SMTP is an independent protocol, but its heritage can still be seen clearly in a few areas. One of the more obvious of these is in the method by which commands are issued by an SMTP sender and replies returned by an SMTP receiver.    Like FTP, all SMTP commands are sent as plain ASCII text over the TCP connection established between the client and server in an SMTP connection. These commands must end with the two-character CRLF sequence that normally terminates ASCII text as required for the Telnet Network Virtual Terminal (NVT; see Chapter 87). In fact, you can check the function of an SMTP server and even issue commands to it yourself simply by using Telnet to connect to it on port 25.    All SMTP commands are specified using a four-letter command code. Some commands also either allow or require parameters to be specified. The basic syntax of a command is    ``` <command-code> <parameters> ```    When parameters are used, they follow the command code and are separated from it by one or more space characters. For example, the HELO and EHLO commands are specified with the command code, a space character, and then the domain name of the SMTP sender, as you saw earlier in the discussion of SMTP connection establishment.    Table 77-2 lists the commands currently used in modern SMTP in the order they are described in RFC 2821, with a brief description of each.    Table 77-2. SMTP Commands     | Command Code | Command | Parameters | Description | | --- | --- | --- | --- | | HELO | Hello | The domain name of the sender | The conventional instruction sent by an SMTP sender to an SMTP receiver to initiate the SMTP session. | | EHLO | Extended Hello | The domain name of the sender | Sent by an SMTP sender that supports SMTP extensions to greet an SMTP receiver and ask it to return a list of SMTP extensions the receiver supports. The domain name of the sender is supplied as a parameter. | | MAIL | Initiate Mail Transaction | Must include a FROM: parameter specifying the originator of the message, and may contain other parameters as well | Begins a mail transaction from the sender to the receiver. | | RCPT | Recipient | Must include a TO: parameter specifying the recipient mailbox, and may also incorporate other optional parameters | Specifies one recipient of the email message being conveyed in the current transaction. | | DATA | Mail Message Data | None | Tells the SMTP receiver that the SMTP sender is ready to transmit the email message. The receiver normally replies with an intermediate "go ahead" message, and the sender then transmits the message one line at a time, indicating the end of the message by a single period on a line by itself. | | RSET | Reset | None | Aborts a mail transaction in progress. This may be used if an error is received upon issuing a MAIL or RCPT command, if the SMTP sender cannot continue the transfer as a result. | | VRFY | Verify | Email address of mailbox to be verified | Asks the SMTP receiver to verify the validity of a mailbox. | | EXPN | Expand | Email address of mailing list | Requests that the SMTP server confirm that the address specifies a mailing list, and return a list of the addresses on the list. | | HELP | Help | Optional command name | Requests general help information if no parameter is supplied; otherwise, information specific to the command code supplied. | | NOOP | No Operation | None | Does nothing except for verifying communication with the SMTP receiver. | | QUIT | Quit | None | Terminates the SMTP session. |    Like FTP commands, SMTP commands are not case-sensitive.    ### Tip    **KEY CONCEPT** The SMTP sender performs operations using a set of *SMTP commands*. Each command is identifies using a four-letter code. Since SMTP supports only a limited number of functions, it has a small command set.    The commands in Table 77-2 are those most commonly used in SMTP today. Certain other commands were also originally defined in RFC 821 but have since become obsolete. These include the following:    **SEND, SAML (Send and Mail), and SOML (Send or Mail)** RFC 821 defined a distinct mechanism for delivering mail directly to a user's terminal as opposed to a mailbox, optionally in combination with conventional email delivery. These were rarely implemented and obsoleted in RFC 2821.    **TURN** Reverses the role of the SMTP sender and receiver as described earlier in the SMTP special features discussion. This had a number of implementation and security issues and was removed from the standard in RFC 2821.    Finally, note that certain SMTP extensions make changes to the basic SMTP command set. For example, the *AUTH* extension specifies a new command (also called AUTH) that specifies an authentication method the SMTP client wants to use. Other extensions define new parameters for existing commands. For example, the SIZE extension defines a *SIZE* parameter that can be added to a *MAIL* command to tell the SMTP receiver the size of the message to be transferred.    # SMTP Replies and Reply Codes    All SMTP protocol operations consist of the plain ASCII text SMTP commands you saw in Table 77-2, issued by the sender to the receiver. The receiver analyzes each command, carries out the instruction requested by the sender if possible, and then sends a reply to the sender. The reply serves several functions: confirming command receipt, indicating whether or not the command was accepted, and communicating the result of processing the command.    Just as SMTP commands are sent in a manner reminiscent of how FTP internal commands work, SMTP replies are formatted and interpreted in a way almost identical to that of FTP replies. As with FTP, the reply consists of not just a string of reply text, but a combination of reply text and a numerical *reply code*. And as with FTP, these reply codes use three digits to encode various information about the reply, with each digit having a particular significance. The reply code is really the key part of the reply, with the reply text being merely descriptive.    ### Note    *The discussion of FTP reply codes in Chapter 72") contains a thorough explanation of the benefits of using these structured numeric reply codes*.    ## Reply Code Structure and Digit Interpretation    SMTP reply codes can be considered to be of the form *xyz*, where *x* is the first digit, *y* is the second, and *z* is the third.    The first reply code digit (*x*) indicates the success or failure of the command in general terms, whether a successful command is complete or incomplete, and whether an unsuccessful command should be tried again or not. This particular digit is interpreted in exactly the same way as it is in FTP, as shown in Table 77-3.    Table 77-3. SMTP Reply Code Format: First Digit Interpretation     | Reply Code Format | Meaning | Description | | --- | --- | --- | | 1yz | Positive Preliminary Reply | An initial response indicating that the command has been accepted and processing of it is still in progress. The SMTP sender should expect another reply before a new command may be sent. Note that while this first digit type is formally defined in the SMTP specification for completeness, it is not currently used by any of the SMTP commands; that is, no reply codes between 100 and 199 exist in SMTP. | | 2yz | Positive Completion Reply | The command has been successfully processed and completed. | | 3yz | Positive Intermediate Reply | The command was accepted but processing it has been delayed, pending receipt of additional information. For example, this type of reply is often made after receipt of a DATA command to prompt the SMTP sender to send the actual email message to be transferred. | | 4yz | Transient Negative Completion Reply | The command was not accepted and no action was taken, but the error is temporary and the command may be tried again. This is used for errors that may be a result of temporary glitches or conditions that may change, such as a resource on the SMTP server being temporarily busy. | | 5yz | Permanent Negative Completion Reply | The command was not accepted and no action was taken. Trying the same command again is likely to result in another error. An example would be sending an invalid command. |    The second reply code digit (*y*) is used to categorize messages into functional groups. This digit is used in the same general way as in FTP, but some of the functional groups are different in SMTP, as you can see in Table 77-4.    Table 77-4. SMTP Reply Code Format: Second Digit Interpretation     | Reply Code Format | Meaning | Description | | --- | --- | --- | | x0z | Syntax | Syntax errors or miscellaneous messages. | | x1z | Information | Replies to requests for information, such as status requests. | | x2z | Connections | Replies related to the connection between the SMTP sender and SMTP receiver. | | x3z | Unspecified | Not defined. | | x4z | Unspecified | Not defined. | | x5z | Mail System | Replies related to the SMTP mail service itself. |    The third reply code digit (*z*) indicates a specific type of message within each of the functional groups described by the second digit. The third digit allows each functional group to have ten different reply codes for each reply type given by the first code digit (preliminary success, transient failure, and so on).    Again, as in FTP, these *x*, *y*, and *z* digit meanings are combined to make specific reply codes. For example, the reply code 250 is a positive reply indicating command completion, related to the mail system. It is usually used to indicate that a requested mail command was completed successfully.    Table 77-5 contains a list of some of the more common SMTP reply codes taken from RFC 2821, in numerical order. For each, I have shown the typical reply text specified in the standard and provided additional descriptive information when needed.    As mentioned earlier, the actual text string for each reply code is implementation-specific. While the standard specifies dry response text such as "Requested action completed" for a 250 message, some servers will customize this code or even give different replies to different 250 messages, depending on the context.    Table 77-5. SMTP Reply Codes     | Reply Code | Reply Text | Description | | --- | --- | --- | | 211 | System status or system help reply. |  | | 214 | *<Help message…>* | Used for text sent in reply to the HELP command. | | 220 | *<servername>* Service ready. | Greeting message sent when TCP connection is first established to an SMTP server. | | 221 | *<servername>* closing transmission channel. | Goodbye message sent in response to a QUIT message. | | 250 | Requested mail action ok, completed | Indicates successful execution of a variety of commands. | | 251 | User not local; will forward to *<forward-path>* | Used when the SMTP receiver agrees to forward a message to a remote user. | | 252 | Cannot VRFY user, but will accept message and attempt delivery | Indicates that a server tried to verify an email address, but was not able to do so completely. Usually means the address appears to be valid but it was not possible to ascertain this to be positively true. | | 354 | Start mail input; end with <CRLF>.<CRLF> | Intermediate reply to a DATA command. | | 421 | *<servername>* Service not available, closing transmission channel | Sent in response to any command when the SMTP receiver prematurely terminates the connection. A common reason for this is receipt of a local shutdown command, due to a hardware reboot, for example. | | 450 | Requested mail action not taken: mailbox unavailable | Sent when a mailbox is busy due to another process accessing it. | | 451 | Requested action aborted: local error in processing | Local processing problem on the server. | | 452 | Requested action not taken: insufficient system storage. | Time to clean out the server's hard disk! | | 500 | Syntax error, command unrecognized | Response to a bad command or one that was too long. | | 501 | Syntax error in parameters or arguments |  | | 502 | Command not implemented | Command is valid for SMTP in general but not supported by this particular server. | | 503 | Bad sequence of commands | Commands were not sent in the correct order, such as sending the DATA command before the MAIL command. | | 504 | Command parameter not implemented. |  | | 550 | Requested action not taken: mailbox unavailable | Generic response given due to a problem with a specified mailbox. This includes trying to send mail to an invalid address, refusal to relay to a remote mailbox, and so forth. | | 551 | User not local; please try *<forward-path>* | Tells the SMTP sender to try a different path; may be used to support mailbox forwarding. | | 552 | Requested mail action aborted: exceeded storage allocation | User's mailbox is full. | | 553 | Requested action not taken: mailbox name not allowed | Specification of an invalid mailbox address. | | 554 | Transaction failed. | General failure of a transaction. |    ## SMTP Multiple-Line Text Replies    As in FTP, it is possible for an SMTP reply to contain more than one line of text. In this case, each line starts with the reply code, and all lines but the last have a hyphen between the reply code and the reply text to indicate that the reply continues. The last line has a space between the reply code and reply text, just like a single-line reply. See the "Connection Establishment Using SMTP Extensions" section earlier in this chapter for an example of a multiple-line response to an EHLO command.    ## Enhanced Status Code Replies    When the ENHANCEDSTATUSCODES SMTP extension is enabled, this causes supplemental reply codes to be issued by the SMTP receiver in response to each command. These codes are similar in some respects to the standard reply codes; they also use three digits, but the digits are separated by periods. These enhanced codes provide more information about the results of operations, especially errors.    For example, if you try to issue a RCPT command specifying a remote mailbox on a server that does not support this feature, it will send back a 550 reply, which is a generic error meaning "requested action not taken: mailbox unavailable." When enhanced status codes are active, the response will be 550 5.7.1, which is the more specific message "delivery not authorized, request refused." A full description of these enhanced codes can be found in RFC 1893.    ### Tip    **KEY CONCEPT** Each time the SMTP sender issues a command, it receives a *reply* from the SMTP receiver. SMTP replies are similar to FTP replies, using both a three-digit reply code and a descriptive text line. A special *enhanced status codes* SMTP extension is also defined; when enabled, this causes the SMTP receiver to return more detailed result information after processing a command.    # Chapter 78. TCP/IP ELECTRONIC MAIL ACCESS AND RETRIEVAL PROTOCOLS AND METHODS  ![image with no caption](img/httpatomoreillycomsourcenostarchimages287681.png.jpg)  The Simple Mail Transfer Protocol (SMTP) is responsible for most of the process of sending an electronic mail (email) message from the originator to the recipient. SMTP's job ends when the message has been successfully deposited into the recipient's mailbox on his local SMTP server.    In some cases, this mailbox is the end of the message's travels through cyberspace. More often, however, it is only a "rest stop"—the last step of the journey is for the message to be accessed and read by the user to whom it was sent. This may require that it be retrieved from the mailbox and transferred to another client machine. For a variety of reasons, SMTP is not used for the process of accessing a mailbox; instead, a special set of protocols and methods is designed specifically for email access and retrieval.    In this chapter, I describe some of the more common techniques used for TCP/IP email access and retrieval. I begin with an overview of the subject that describes in general the different paradigms used for email access and gives an overview of the protocols.    I then describe the operation of the very popular Post Office Protocol (POP), focusing on version 3 (POP3). I look at the protocol in general terms, discussing its history, the various versions of the protocol, and the standards that define them. I describe POP3's general operation and the communication between a client and server, concentrating on the three main states through which the session transitions. I then describe each of these states in sequence: the *Authorization* state, *Transaction* state, and *Update* state.    Following this, I discuss the other common mail access protocol: the Internet Message Access Protocol (IMAP). This includes a description of its benefits compared to the simpler POP3, a discussion of its operation, and a look at how client and server devices communicate, showing how the IMAP session moves through a series of four states.    Finally, I conclude with a discussion of two alternative methods of email access and retrieval. The first I call *direct server access*, which describes several ways that mailboxes are accessed without the use of special remote-access protocols such as POP and IMAP. The second is email access using a web browser. This is the newest email access method and is growing in popularity every year.    # TCP/IP Email Mailbox Access Model, Method, and Protocol Overview    In an ideal world, every device on the Internet would run SMTP server software, and that one protocol would be sufficient to implement the entire TCP/IP email system. You would compose email on your machine, your SMTP software would send it to a recipient's machine, and she would read it.    Here in the real world, however, this is not possible in general terms. An SMTP server must be connected to the Internet and available around the clock to receive email sent at any time by any of the millions of other computers in the world. Most of us either cannot or do not want to run machines continuously connected to the Internet, nor do we want to configure and maintain potentially complex SMTP software. For these reasons, a complete email exchange normally involves not two devices but four: A message is composed on the sender's client machine, and then transferred to the sender's SMTP server, then to the recipient's SMTP server, and finally to the recipient's machine.    The communication between SMTP servers is done with SMTP; so is the initial step of sending the email from the sender's machine to the sender's SMTP server. However, SMTP is not used for the last part of the process, which is accessing the recipient's mailbox. Instead, specific mailbox access and retrieval protocols and methods were devised.    Why not simply have mail wait on the recipient's SMTP server, and then have the mail sent to the recipient client device when it comes online, using SMTP? This isn't possible for two main reasons. First, SMTP was designed for the specific purpose of transporting only email. Having it responsible for client mailbox access would require adding more functionality, making it difficult to keep SMTP *simple*. In the same vein, SMTP works on a *push* model, with transactions being initiated by the sender. It would need changes to allow it to respond to requests from a client device that is only online intermittently.    The second reason is probably more important, because the current protocol configuration allows *flexibility* in how email is accessed. If we used SMTP, all we would be able to do is transfer email to the recipient's client machine. This would be functional, but it would greatly limit the capabilities of how email is used, especially, for example, for users who wish to access mail directly on the server and manipulate it there. Also consider the problem of people with special requirements, such as those who travel and may need to access email from a number of different client devices. There is thus an advantage to providing more than one way to access a mailbox.    ## Email Access and Retrieval Models    RFC 1733, "Distributed Electronic Mail Models in IMAP4," describes three different paradigms, or models, for mail access and retrieval:    **Online Access Model** We would all be using this mode of access in my ideal world scenario, where every machine was always connected to the Internet running an SMTP server. We would have constant, direct online access to our mailboxes. In the real world, this model is still used by some Internet users, especially those who have UNIX accounts or run their own SMTP servers. I call this *direct server access*.    **Offline Access Model** In this paradigm, a user establishes a connection to a server where his mailbox is located. The user downloads received messages to the client device and then deletes them from the server mailbox. All reading and other activity performed on the mail can be done offline once the mail has been retrieved.    **Disconnected Access Model** This is a hybrid of online and offline access. The user downloads messages from the server, so she can read or otherwise manipulate them without requiring a continuous connection to the server. However, the mail is not deleted from the server, as in the offline model. At some time in the future, the user connects back with the server and synchronizes any changes made on the local device with the mailbox on the server. What sort of changes can be made? Examples include marking whether or not a message has been read to keep track of read and unread mail, and marking messages to which the user has already replied. These are important tools to help those with busy mailboxes keep track of what they need to do.    None of the three models is entirely better than the others. Each has advantages and disadvantages, which is why it is good that we have these options rather than the single SMTP protocol for mail access.    Direct server access has the main benefits of instant speed and universal access from any location. As for disadvantages, you must be online to read mail, and it usually requires that you use UNIX email clients, which with most people are not familiar. However, IMAP can also be used for online access.    Offline access has the main advantages of simplicity and short connection time requirements; you can easily connect to the mailbox, download messages, and then read them locally. But that makes this method somewhat inflexible and poorly suited to access from different machines. Still, it is currently the most popular access method because simplicity is important; it is best typified by POP.    Disconnected access attempts to combine the advantages of offline and online access without combining their disadvantages, and it does a pretty good job. The advantages are significant: the ability to access mail quickly and use it offline, while retaining and updating the mailbox on the server to allow access from different client machines. IMAP is popularly used for disconnected access. In the IMAP overview later in this chapter, I explore its advantages over offline access as well as its main disadvantages, which are complexity and far less universal support than POP (though acceptance of IMAP is slowly increasing).    Finally, in recent years, a somewhat new mailbox access method has become popular: email access using the World Wide Web. This technique allows a user to access his mailbox from any computer with an Internet connection and a web browser. It is a good example of line blurring, not only between the access models discussed here, but between TCP/IP applications—in this case, the Web and email.    ### Tip    **KEY CONCEPT** For flexibility, TCP/IP uses a variety of mailbox access and retrieval protocols and methods to allow users to read email. Three different models describe how these different methods work: the *online model*, in which email is accessed and read on the server; the *offline model*, in which mail is transferred to the client device and used there; and the *disconnected model*, in which mail is retrieved and read offline but remains on the server with changes synchronized for consistency.    # TCP/IP Post Office Protocol (POP/POP3)    The overall communication model used for TCP/IP email provides many options to an email user for accessing her electronic mailbox. The most popular access method today is the simple offline access model, in which a client device accesses a server, retrieves mail, and deletes it from the server. POP was designed for quick, simple, and efficient mail access; it is used by millions of people to access billions of email messages every day.    ## POP Overview, History, Versions, and Standards    Of the three mailbox access paradigms—online, offline, and disconnected—the offline model is probably the least capable in terms of features. And it is also the most popular. This may seem counterintuitive, but it is in fact a pattern that repeats itself over and over in the worlds of computing and networking. The reason is that *simplicity* and *ease of implementation* are keys to the success of any technology, and the offline mail access model beats the other two in these areas.    The history of offline email access goes back farther than one might expect—to the early 1980s. Two decades ago, not everyone and his brother were accessing the Internet to check email the way we do today. In fact, only a relatively small number of machines were connected using TCP/IP, and most users of these machines could access their email on a server, using the online access model.    However, even back then, developers recognized the advantages of being able to retrieve email from a server directly to a client computer, rather than accessing the mailbox on the server using Telnet or Network File System (NFS). In 1984, RFC 918 was published, defining POP. This protocol provided a simple way for a client computer to retrieve email from a mailbox on an SMTP server so it could be used locally.    The emphasis was on *simple*. The RFC for this first version of POP is only five pages long, and the standard it defined is extremely rudimentary. It describes a simple sequence of operations in which a user provides a name and password for authentication and then downloads the entire contents of a mailbox. Simple is good, but simple has limits.    RFC 937, "Post Office Protocol - Version 2" was published in February 1985\. POP2 expanded the capabilities of POP by defining a much richer set of commands and replies. This included the ability to read only certain messages, rather than dumping a whole mailbox. Of course, this came at the cost of a slight increase in protocol complexity, but POP2 was still quite simple as protocols go.    These two early versions of POP were used in the mid-1980s, but not very widely. Again, this is simply because the need for an offline email access protocol was limited at that time; most people were not using the Internet before the 1990s.    In 1988, RFC 1081 was published, describing POP3\. By this time, the personal computer (PC) was transitioning from a curiosity to a place of importance in the worlds of computing and networking. POP3 was based closely on POP2, but the new version was refined and enhanced with the idea of providing a simple and efficient way for PCs and other clients not normally connected to the Internet to access and retrieve email.    Development on POP3 continued through the 1990s, with several new RFCs published every couple of years. RFC 1081 was made obsolete by, in turn, RFCs 1225, 1460, 1725, and 1939\. Despite the large number of revisions, the protocol itself has not changed a great deal since 1988; these RFCs contain only relatively minor tweaks to the original description of the protocol. RFC 1939 was published in 1996, and POP3 has not been revised since that time, though a few subsequent RFCs define optional extensions and additions to the basic protocol, such as alternative authentication mechanisms.    While POP3 has been enhanced and refined, its developers have remained true to the basic idea of a very simple protocol for quick and efficient email transfer. POP3 is a straightforward state-based protocol, with a client and server proceeding through three stages during a session. A very small number of commands is defined to perform simple tasks, and even after all its changes and revisions, the protocol has a minimum of fluff.    For reasons that are unclear to me, almost everyone refers to POP with its version number—that is, they say *POP3* instead of *POP*. This is true despite most people not using version numbers with many other protocols, and almost no one using any other version of POP. But it is the convention, and I will follow it in the rest of this discussion.    ### Tip    **KEY CONCEPT** POP is currently the most popular TCP/IP email access and retrieval protocol. It implements the offline access model, allowing users to retrieve mail from their SMTP server and use it on their local client computers. It is specifically designed to be a simple protocol and has only a small number of commands. The current revision of POP is version 3, and the protocol is usually abbreviated *POP3*.    ### Note    *Some implementations of POP attempt to implement the disconnected access model, with limited success. More often, however, IMAP is used for this purpose, since it is better suited to that access model. See the overview of IMAP later in this chapter for more details*.    ## POP3 General Operation    POP3 is a regular TCP/IP client/server protocol. In order to provide access to mailboxes, POP3 server software must be installed and continuously running on the server on which the mailboxes are located. This does not necessarily have to be the same physical hardware device that runs the SMTP server software that receives mail for those boxes—a mechanism such as NFS may be used to allow both the POP3 and SMTP servers to "see" mailboxes locally. POP3 clients are regular end-user email programs that make connections to POP3 servers to get mail; examples include Microsoft Outlook and Eudora Email.    POP3 uses TCP for communication, to ensure the reliable transfer of commands, responses, and message data. POP3 servers listen on well-known port number 110 for incoming connection requests from POP3 clients. After a TCP connection is established, the POP3 session is activated. The client sends commands to the server, which replies with responses and/or email message contents.    POP3 commands are three or four letters long and are case-insensitive. They are all sent in plain ASCII text and terminated with a CRLF sequence, just as with FTP and SMTP commands. POP3 replies are also textual, but the protocol does not use the complex three-digit reply code mechanism of FTP (and SMTP). In fact, it defines only two basic responses:    **+OK** A positive response, sent when a command or action is successful    **-ERR** A negative response, sent to indicate that an error has occurred    These messages may be accompanied by explanatory text, especially in the case of an ERR response, to provide more information about the nature of the error.    ## POP3 Session States    POP3 is described in terms of a *finite state machine (FSM)*, with a session transitioning through three states during the course of its lifetime, as shown in Figure 78-1 to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated."). (I describe the concepts behind using FSM as a descriptive tool in Chapter 47.) Fortunately, unlike the FSMs of protocols like TCP, this one really is simple, because it is *linear*. The session goes through each state once and only once, in the following sequence:    1.  **Authorization State** The server provides a greeting to the client to indicate that it is ready for commands. The client then provides authentication information to allow access to the user's mailbox.           2.  **Transaction State** The client is allowed to perform various operations on the mailbox. These include listing and retrieving messages and marking retrieved messages for deletion.           3.  **Update State** When the client is finished with all of its tasks and issues the QUIT command, the session enters this state automatically, where the server actually deletes the messages marked for deletion in the Transaction state. The session is then concluded, and the TCP connection between the two is terminated.            ![POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.](img/httpatomoreillycomsourcenostarchimages288297.png.jpg)  Figure 78-1. POP3 finite state machine POP uses a finite state machine (FSM) to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.    POP3 is designed so that only certain commands may be sent in each of these states. Here, I will describe the activities that take place in these three states, including the commands that are issued by the client in each.    ### Tip    **KEY CONCEPT** POP3 is a client/server protocol that is described using a simple linear sequence of states. A POP3 session begins with a POP3 client making a TCP connection to a POP3 server, at which point the session is in the *Authorization* state. After successful authentication, the session moves to the *Transaction* state, where the client can perform mail access transactions. When it is finished, the client ends the session and the *Update* state is entered automatically, where cleanup functions are performed and the POP3 session ended.    ### POP3 Authorization State: User Authentication Process and Commands    A session between a POP3 client and a POP3 server begins when the client sends a TCP connection request to the server. The connection is established using the standard TCP three-way handshake, and the POP3 session commences. The first of the three states of a POP3 session, the Authorization state, is responsible for authenticating the POP3 client with the server.    When the session first enters this state, the server sends a greeting message to the client. This tells the client that the connection is alive and ready for the client to send the first command. An example of such a greeting follows:    ``` +OK POP3 server ready ```    The client is now required to authenticate the user who is trying to access a mailbox. This proves that the user has the right to access the server and identifies the user so the server knows which mailbox is being requested.    The normal method of authorization in POP3 is a standard user name/password login. This is pretty much identical to how a login is performed in FTP; even the commands are the same. First the client issues a USER command along with the user's mailbox name (his user name or email address). The server responds with an intermediate acknowledgment. The client then uses the PASS command to send the user's password. Assuming the login is valid, the server responds to the client with an acknowledgment that indicates successful authentication. The response will also typically specify the number of messages waiting for the user in the mailbox. This process is illustrated in Figure 78-2.  ![POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.](img/httpatomoreillycomsourcenostarchimages288299.png.jpg)  Figure 78-2. POP3 user authentication process Once the TCP connection is established from the client to the server, the server responds with a greeting message, and the simple POP3 authentication process begins. The client sends a user name and password to the server using the USER and PASS commands, and the server evaluates the information to determine whether or not it will allow the client access.    Example 78-1 shows an example POP3 authorization, with the client's commands in boldface and the server's responses in italics.    ### Note    *Some servers may require only the name of the user* (jane), *while others require the full email address, as shown in Example 78-1*.    Example 78-1. Example of POP3 authorization    ``` *`+OK POP3 server ready`* `USER jane@somewhereelse.com` *`+OK`* `PASS *******` *`+OK jane@somewhereelse.com has 3 messages`* ```    If authorization is successful, the POP3 session transitions to the Transaction state, where mail-access commands can be performed. If the user name or password is incorrect, an error response is given, and the session cannot proceed. The authorization may also fail due to technical problems, such as an inability by the server to lock the mailbox (perhaps due to new mail arriving via SMTP).    Since user name/password authorization is considered by many people to be insufficient for the security needs of modern internetworks, the POP3 standard also defines an alternative authentication method using the APOP command. This is a more sophisticated technique based on the Message Digest 5 (MD5) encryption algorithm. If the server supports this technique, in its opening greeting it provides a string indicating a *timestamp* that is unique for each POP3 session. The client then performs an MD5 calculation using this timestamp value and a shared secret known by the server and client. The result of this calculation is included in the client's APOP command. If it matches the server's calculation, authentication is successful; otherwise, the session remains in the Authorization state.    POP was also designed to be extendable through the addition of other authentication mechanisms. This process is based on the use of the optional AUTH command, as described in RFC 1734.    ### Tip    **KEY CONCEPT** A POP3 session begins in the Authorization state, where the client device is expected to authenticate with the server. By default, POP3 uses only a simple user name/password authentication method. Optional authentication methods are also defined for applications requiring more security.    ### POP3 Transaction State: Mail and Information Exchange Process and Commands    Once the POP3 client has successfully authenticated the user who is performing mailbox access, the session transitions from the Authorization state to the Transaction state. There's no real mystery as to what this phase of the connection is all about: The POP3 client issues the commands that perform mailbox access and message retrieval transactions.    Most of the commands defined in POP3 are valid only in the Transaction state. Table 78-1 lists each of them, in the order in which they appear in RFC 1939.    Table 78-1. POP3 Transaction Commands     | Command Code | Command | Parameters | Description | | --- | --- | --- | --- | | STAT | Status | None | Requests status information for the mailbox. The server will normally respond, telling the client the number of messages in the mailbox and the number of bytes of data it contains. Optionally, more information may also be returned. | | LIST | List Messages | Optional message number | Lists information for the messages in a mailbox; generally this means showing the message number and its size. If a message number is given, only that message's information is provided; otherwise, the full contents of the mailbox are described, one line at a time, with a line containing just a single period at the end. | | RETR | Retrieve | Message number | Retrieves a particular message from the mailbox. The server responds with a standard +OK message and then immediately sends the message in RFC 822 format, one line at a time. A line with a single period is sent after the last line. | | DELE | Delete | Message number | Marks a message as deleted. Once deleted, any further attempt to access a message (using LIST or RETR, for example) results in an error. | | NOOP | No Operation | None | Does nothing; the server just returns an +OK reply. | | RSET | Reset | None | Resets the session to the state it was in upon entry to the Transaction state. This includes undeleting any messages already marked for deletion. | | TOP | Retrieve Message Top | Message number and number of lines | Allows a client to retrieve only the beginning of a message. The server returns the headers of the message and only the first *N* lines, where *N* is the number of lines specified. This command is optional and may not be supported by all servers. | | UIDL | Unique ID Listing | Optional message number | If a message number was specified, returns a unique identification code for that message; otherwise, returns an identification code for each message in the mailbox. This command is optional and may not be supported by all servers. |    The Transaction state is relatively unstructured in that commands do not need to be issued in any particular order to meet the requirements of the standard. However, there is a natural progression to how a mailbox is retrieved, and that means the commands are usually used in the following order:    1.  The client issues a STAT command to see the number of messages in the mailbox.           2.  The client issues a LIST command, and the server tells it the number of each message to be retrieved.           3.  The client issues a RETR command to get the first message and, if successful, marks it for deletion with DELE. The client uses RETR/DELE for each successive message.              Example 78-2 and Figure 78-3") show a sample access sequence for a mailbox containing two messages that total 574 bytes; the client's commands are in boldface and the server's responses are in italics.    Example 78-2. Example of the POP3 mail exchange process    ``` `STAT` *`+OK 2 574`* `LIST` *`+OK`* *`1 414`* *`2 160`* *`.`* `RETR 1` *`+OK`* *`(Message 1 is sent)`* *`.`* `DELE 1` *`+OK message 1 deleted`* `RETR 2` *`+OK`* *`(Message 2 is sent)`* *`.`* `DELE 2` *`+OK message 2 deleted`* `QUIT` ```    The exact message sent in reply to each command is server-dependent; some say +OK, while others provide more descriptive text, as I have done here for the responses to the DELE command.    ### Tip    **KEY CONCEPT** After successful authorization, the POP3 session transitions to the Transaction state, where the client actually accesses email messages on the server. The client normally begins by first retrieving statistics about the mailbox from the server and obtaining a list of the messages in the mailbox. The client then retrieves each message one at a time, marking each retrieved message for deletion on the server.    In some cases, a POP3 client may be configured to *not* delete messages after retrieving them. This is useful, for example, when Web-based access is being combined with a conventional email client program.    ### POP3 Update State: Mailbox Update and Session Termination Process and Commands    Once the POP3 client has completed all the email message access and retrieval transactions that it needs to perform, it isn't quite finished yet. The POP3 standard defines a final session state, the Update state, to perform various housekeeping functions, after which both the POP3 session and the underlying TCP connection are terminated.    The transition from the Transaction state to the Update state occurs when the POP3 client issues the QUIT command. This command has no parameters and serves to tell the POP3 server that the client is finished and wishes to end the session. The POP3 standard lists this command as part of its description of the Update state, though it is actually issued from the Transaction state.  ![POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)](img/httpatomoreillycomsourcenostarchimages288301.png.jpg)  Figure 78-3. POP3 mail exchange process This diagram shows the typical exchange of commands and replies employed by a POP3 client to retrieve email from a POP3 server. The STAT command is used to get mailbox statistics, followed by the LIST command to obtain a list of message numbers. Each message in turn is then retrieved using RETR and marked for deletion by DELE. (Messages are not actually deleted until the Update state is entered.)    After the POP3 server receives the QUIT command, it deletes any messages that were previously marked for deletion by the DELE command in the Transaction state. It's interesting to note that POP chose to implement this two-stage deletion process. The standard doesn't describe specifically why this was done, but it seems likely that it is a precaution to insure against accidental deletion and loss of mail.    By delaying actual deletion until the Update state, the server can verify that it has received and processed all commands prior to the move to the Update state. This also allows the deletion of messages to be undone if necessary, using the RSET command, if the user changes her mind about the deletion prior to exiting the Transaction state. Finally, if any problem occurs with communication between the client and server that causes the TCP connection to be interrupted prematurely before the QUIT command is issued, no messages will be removed from the mailbox, giving the client a second chance to retrieve them in case they were not received properly.    Once the deleted messages have been removed, the server returns an acknowledgment to the client: +OK if the update was successful, or -ERR if there was a problem removing one or more of the deleted messages. Assuming no problems occurred, the +OK response will also contain a goodbye message of some sort, indicating that the session is about to be closed. The TCP connection between the client and server is then torn down and the session is done.    ### Tip    **KEY CONCEPT** When the POP3 client is done with its email transactions, it issues the QUIT command. This causes the Update state to be entered automatically, where the server performs necessary cleanup operations, including deleting any messages marked for deletion in the Transaction state.    A POP3 mail-retrieval session normally lasts a few seconds or minutes, but it can take many minutes if the mailbox is large and the connection between the client and server is slow. There is no limit on how long the client and server can be connected, as long as commands continue to be sent by the client. A POP3 server will normally implement an inactivity timer, however, which is customizable but must have a duration of no less than ten minutes. If the connection is idle for the full duration of the inactivity timer, the server assumes that the client has experienced some sort of a problem and shuts down the connection. If this occurs, the server does not delete any messages marked for deletion—again, this is to give the client another chance to retrieve those messages if a problem occurred getting them the first time.    # TCP/IP Internet Message Access Protocol (IMAP/IMAP4)    The offline mailbox access model provides the basic mail access functions that most users need. Using the popular POP3, a user can access her mailbox and retrieve messages so she can read them on her local machine. This model has the advantage of simplicity, but it does not provide many features that are increasingly in demand today, such as keeping track of the status of messages and allowing access from many client devices simultaneously. To provide better control over how mail is accessed and managed, we must use either the online or disconnected access models. IMAP was created to allow these access models to be used; it provides rich functionality and flexibility for the TCP/IP email user.    ### Tip    **RELATED INFORMATION** *The main price that IMAP pays for having a much richer set of functionality than POP is much more complexity. In this section, I have described IMAP in approximately the same level of detail that I did earlier for POP. Please see the appropriate RFC documents for the full description of the protocol and more discussion of some of its nuances, particularly the syntax of the many commands and parameters, which would take dozens of pages to cover fully here*.    ## IMAP Overview, History, Versions, and Standards    POP3 has become the most popular protocol for accessing TCP/IP mailboxes, not because of its rich functionality, but in spite of its lack of functionality. POP implements the offline mail access model, where mail is retrieved and then deleted from the server where the mailbox resides, so it can be used on a local machine. Millions of people use POP3 every day to access incoming mail. Unfortunately, due to the way the offline access model works, POP3 cannot be used for much else.    The online model is the one we would use in an ideal world, in which we all would be always connected to the Internet all the time. Offline access is a necessity, however, because most user client machines are connected to the Internet only periodically. The transfer of mail from the server to a client machine removes the requirement that we be online to perform mail functions, but it costs us the benefits of central mail storage on the server.    This may seem counterintuitive: how can it be better to have mail stored on some remote server rather than on our local computer? The main reason for this is flexibility of access. One of the biggest problems with offline access using POP3 is that mail is transferred permanently from a central server to one client machine. This is fine as long as an individual uses only that one machine, but what if the person has separate work and home computers or travels a great deal? And what about a mailbox shared by many users? These concerns have become more and more important in recent years.    Another issue is data security and safety. Mail servers run by Internet service providers (ISPs) are usually located in professionally managed data centers. They are carefully controlled and monitored, and backups occur on a routine basis. Most people do not take this sort of care with their own PCs and Macs, nor do they back up their data routinely. So, it's less likely that people will lose mail that on the server.    Of course, we still have the problem of not wanting to force users to be online all the time to access their mail. The solution is the disconnected mailbox access model, which marries the benefits of online and offline access. Mail is retrieved for local use as in the offline model, so the user does not need to be connected to the server continuously. However, changes made to the mailbox are synchronized between the client and the server. The mail remains on the server, where it can be accessed from a different client in the future, and the server acts as a permanent home base for the user's mail.    Recognizing these benefits, developers made some attempts to implement POP using the disconnected access model. Typically, this was done by using POP commands to retrieve mail but still leave it on the server, which is an option in many client programs. This works, but only to a limited extent; for example, keeping track of which messages are new or old becomes an issue when they are both retrieved and left on the server. POP simply lacks the features required for proper disconnected access because it was not designed for it.    In the mid-1980s, development began at Stanford University on a new protocol that would provide a more capable way of accessing user mailboxes. The result was the Interactive Mail Access Protocol, later renamed the Internet Message Access Protocol (IMAP).    ### IMAP Features    IMAP was designed for the specific purpose of providing flexibility in how users access email messages. It, in fact, can operate in all three of the access modes: online, offline, and disconnected access. Of these, the online and disconnected access modes are of interest to most users of the protocol; offline access is similar to how POP works.    IMAP allows a user to do all of the following:    *   Access and retrieve mail from a remote server so it can be used locally while retaining it on the server.           *   Set message flags so that the user can keep track of which messages he has already seen, already answered, and so on.           *   Manage multiple mailboxes and transfer messages from one mailbox to another. You can organize mail into categories, which is useful for those working on multiple projects or those who are on various mailing lists.           *   Determine information about a message prior to downloading it, to decide whether or not to retrieve it.           *   Download only portions of a message, such as one body part from a MIME multipart message. This can be quite helpful in cases where large multimedia files are combined with short text elements in a single message.           *   Manage documents other than email. For example, IMAP can be used to access Usenet messages.              Of course, there are some disadvantages to IMAP, but not many. One disadvantage is that it is more complex, but it's really not that complex, and the protocol has been around for enough years that this is not a big issue. The most important sticking point with IMAP is simply that it is used less commonly than POP, so providers that support it are not as easy to find as those that support POP. This is changing, however, as more people discover IMAP's benefits.    ### Tip    **KEY CONCEPT** POP is popular because of its simplicity and long history, but it has few features and normally supports only the rather limited offline mail access method. To provide more flexibility for users in how they access, retrieve, and work with email messages, IMAP was developed. IMAP is used primarily in the online and disconnected access models. It allows users to access mail from many different devices, manage multiple mailboxes, select only certain messages for downloading, and much more. Due to its many capabilities, it is growing in popularity.    ### IMAP History and Standards    IMAP has had a rather interesting history—interesting in the sense that the normal orderly development process that is used for most TCP/IP protocols broke down. The result wasn't quite as bad as the chaos that occurred in the development of SNMP version 2 (see Chapter 65), but it was still unusual.    The first version of IMAP formally documented as an Internet standard was IMAP version 2 (IMAP2) in RFC 1064, published in July 1988\. This was updated in RFC 1176, August 1990, retaining the same version number. However, it seems that some of the people involved with IMAP were not pleased with RFC 1176, so they created a new document defining version 3 of IMAP (IMAP3): RFC 1203, published in February 1991\. This is described by its authors as a "counter proposal."    For whatever reason, however, IMAP3 was never accepted by the marketplace. Instead, people kept using IMAP2 for a while. An extension to the protocol was later created, called IMAP2bis, which added support for Multipurpose Internet Mail Extensions (MIME) to IMAP. This was an important development due to the usefulness of MIME, and many implementations of IMAP2bis were created. Despite this, for some reason IMAP2bis was never published as an RFC. This may have been due to the problems associated with the publishing of IMAP3.    ### Note    *bis is a Latin word meaning again. It is sometimes used to differentiate changed technical documents from their previous versions when no official new version number is allocated*.    In December 1994, IMAP version 4 (IMAP4) was published in two RFCs: RFC 1730 describing the main protocol, and RFC 1731 describing authentication mechanisms for IMAP4\. IMAP4 is the current version of IMAP that is widely used today. It continues to be refined; the latest specific version is actually called version 4rev1 (IMAP4rev1), defined in RFC 2060, and then most recently by RFC 3501\. Most people still just call this *IMAP4*, and that's what I will do in the rest of this section.    ## IMAP General Operation    IMAP4 is a standard client/server protocol like POP3 and most other TCP/IP application protocols. For the protocol to function, an IMAP4 server must be operating on the server where user mailboxes are located. Again, as with POP3, this does not necessarily need to be the same physical server that provides SMTP service. The mailbox must in some way be made accessible to both SMTP for incoming mail, and to IMAP4 for message retrieval and modification. A mechanism for ensuring exclusive access to avoid interference between the various protocols is also needed.    IMAP4 uses the Transmission Control Protocol (TCP) for communication. This ensures that all commands and data are sent reliably and received in the correct order. IMAP4 servers listen on well-known port number 143 for incoming connection requests from IMAP4 clients. After a TCP connection is established, the IMAP4 session begins.    ## IMAP Session States    The session between an IMAP4 client and server is described in the IMAP standards using an FSM. Again, this is similar to how POP3 operates, except that IMAP4 is a bit more complex. Its FSM defines four states instead of three, and where a POP3 session is linear (going through each state only once) in IMAP4 the session is not. However, the state flow is still fairly straightforward, mostly following a logical sequence from one state to the next. The IMAP FSM is illustrated in Figure 78-4 but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.").  ![IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in ) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.](img/httpatomoreillycomsourcenostarchimages288303.png.jpg)  Figure 78-4. IMAP FSM The IMAP FSM is slightly more complex than that of POP (shown in Figure 78-1 to describe its operation, but it is very simple because it is linear. Once a TCP connection is established between a POP3 client and POP3 server, the session proceeds through three states in sequence, after which the connection is terminated.")) but it's still rather straightforward. Once the TCP connection is made between client and server, the Not Authenticated state is entered; after successful authorization, the session moves to the Authenticated state. The session may move between Authenticated and Selected several times, as different mailboxes are selected for use and then closed when no longer needed. From any state the session may be terminated, entering the Logout state.    The following are the IMAP states, in the usual sequence in which they occur for a session:    1.  **Not Authenticated State** The session normally begins in this state after a TCP connection is established, unless the special IMAP *preauthentication* feature has been used (we'll get to this feature shortly). At this point, the client cannot really do much aside from providing authentication information so it can move to the next state.           2.  **Authenticated State** The client has completed authentication, either through an authentication process in the prior state or through preauthentication. The client is now allowed to perform operations on whole mailboxes. The client must select a mailbox before individual message operations are permitted.           3.  **Selected State** After a mailbox has been chosen, the client is allowed to access and manipulate individual messages within the mailbox. When the client is finished with the current mailbox, it can close it and return to the Authenticated state to select a new one to work with, or it can log out to end the session.           4.  **Logout State** The client may issue a Logout command from any of the other states to request that the IMAP session be ended. The session may also enter this state if the session inactivity timer expires. The server sends a response, and the connection is terminated.              ### Tip    **KEY CONCEPT** IMAP is a client/server application, and an IMAP session begins with the client making a TCP connection to the server. The session then normally starts in the Not Authenticated state and remains there until successful authentication. In the Authenticated state, the client may perform operations on whole mailboxes, but a mailbox must be selected to transition to the Selected state, where individual messages can be manipulated. The client can work with many mailboxes by selecting each one in turn; it then logs out from the server.    Of the four IMAP states, only the first three are *interactive*, meaning states in which commands are actively issued by the client and responses provided by the server. Some IMAP commands can be used while the session is in any state; others are state-specific.    ### Session Establishment and Greeting    The server determines in which state the IMAP session begins and sends a *greeting* message to tell the client the session is established and indicate which state it is in. Normally, the server will begin the session in the Not Authenticated state. This is conveyed to the client with the normal OK greeting message, such as this:    ``` * OK <*`server-name`*> server ready ```    ### Preauthentication    In certain circumstances, a server may already know the identity of the client, perhaps as a result of some external authentication mechanism not part of the IMAP protocol. In this case, a special greeting is used:    ``` * PREAUTH <*`server-name`*> server ready, logged in as <*`user-name`*> ```    This tells the client that it is already in the Authenticated state.    If the server decides for whatever reason not to accept a new session from the client, it can respond with a BYE response, instead of OK or PREAUTH, and close the TCP connection.    ## IMAP Commands, Results, and Responses    Once an IMAP session is established, all communication between the client and server takes place in the form of *commands* sent by the client and *responses* returned by the server. Like POP3, commands and responses are sent as strings of ASCII text and terminated with a CRLF sequence, making them compatible with the way data is sent using the Telnet Protocol. However, IMAP has a few differences from POP and many other TCP/IP application protocols.    The first interesting thing about IMAP commands is that most are not abbreviated into codes of three or four letters—they are spelled out in full. So where POP3 has a STAT command, the command in IMAP is called STATUS. Commands are normally shown in uppercase, as I do in this book, but they are case-insensitive.    IMAP also uses an interesting system of *command tagging* to match client commands explicitly with certain server responses. Each time a client sends a command, it prefixes it with a tag that is unique for the particular session. The tags are usually short strings with a monotonically increasing number in them; the examples in the IMAP standards have the first command tagged a0001, the second a0002, and so on. That said, as long as each command is uniquely labeled, it doesn't matter what tagging scheme is used. When the server needs to send a response that is specific to a command, it tags the reply with the appropriate command tag. Not all replies are tagged, however.    The standard doesn't state explicitly why this tagging scheme is needed, but I believe it is probably related to IMAP's multiple command feature. IMAP clients are allowed to send a sequence of commands to the server to be processed, rather than sending commands only one at a time. This can improve performance when certain commands would take a long time to complete. The only restriction is that the commands must be independent enough that the result of executing them all would be the same, regardless of the order in which they were processed. For example, sending a command to read a particular entity in combination with a command to store a value into the same entity is not allowed.    ### Tip    **KEY CONCEPT** IMAP tags its commands with a unique identifier. These tags can then be used in replies by the server to match replies with the commands to which they correspond. This enables multiple commands to be sent to an IMAP server in succession.    ### Command Groups    IMAP commands are organized into groups based on which session states the IMAP session may be in when they are used:    **"Any State" Commands** A small number of commands that can be used at any time during an IMAP session.    **Not Authenticated State Commands** Commands that can be used only in the Not Authenticated state. They are usually used for authentication, of course.    **Authenticated State Commands** Commands used to perform various actions on mailboxes. (Note that despite the name, these commands can also be used in the Selected state.)    **Selected State** A set of commands for accessing and manipulating individual messages that can be used only in the Selected state.    The reason for having the distinct Authenticated and Selected states and command groups is that IMAP is designed specifically to enable the manipulation of multiple mailboxes. After the session starts and the client is authenticated, the client is allowed to issue commands that work with entire mailboxes. However, it may not issue commands that manipulate individual messages until it tells the server which mailbox it wants to work with, which puts it in the Selected state. The client can also issue mailbox commands from the Selected state.    ### Note    *In addition to these four state groups, the standard also defines an extension mechanism that allows new commands to be defined. These must begin with the letter X*.    ### "Any State" Commands    Table 78-2 describes the IMAP "any state" commands, which can be used whenever needed.    Table 78-2. IMAP "Any State" Commands     | Command | Parameters | Description | | --- | --- | --- | | CAPABILITY | None | Asks the server to tell the client what capabilities and features it supports. | | NOOP (No Operation) | None | Does nothing. May be used to reset the inactivity timer or to prompt the server periodically to send notification if new messages arrive. | | LOGOUT | None | Tells the server that the client is done and ready to end the session, which transitions to the Logout state for termination. |    ### Results and Responses    Each command sent by the IMAP client elicits some sort of reaction from the IMAP server. The server takes action based on what the client requested and then returns one or more text strings to indicate what occurred. The server can send two types of replies after a command is received:    **Result** A reply usually indicating the status or disposition of a command. It may be tagged with the command tag of the command whose result it is communicating, or it may be a general message that is not tagged.    **Response** Any type of information that is being sent by the server to the client. It is usually not tagged with a command tag and is not specifically intended to indicate server status.    ### Note    *The IMAP standards sometimes use the terms result, response, and reply in a manner that I find to be inconsistent. Watch out for this if you examine the IMAP RFCs*.    ### Tip    **KEY CONCEPT** IMAP servers issue two basic types of replies to client commands: *results* are replies that indicate the success, failure, or status of a command; *responses* are general replies containing many different types of information that the server needs to send to the client.    ### Result Codes    Three main result codes are sent in reply to a command, and two special ones are used in certain circumstances:    **OK** A positive result to a command, usually sent with the tag of the command that was successful. May be sent untagged in the server's initial greeting when a session starts.    **NO** A negative result to a command. When tagged, indicates the command failed; when untagged, serves as a general warning message about some situation on the server.    **BAD** Indicates an error message. It is tagged when the error is directly related to a command that has been sent and otherwise is untagged.    **PREAUTH** An untagged message sent at the start of a session to indicate that no authentication is required; the session goes directly to the Authenticated state.    **BYE** Sent when the server is about to close the connection. It is always untagged and is sent in reply to a Logout command or when the connection is to be closed for any other reason.    ### Response Codes    In contrast to results, responses are used to communicate a wide variety of information to the client device. Responses normally include descriptive text that provides details about what is being communicated. They may be sent either directly in reply to a command or incidentally to one. An example of the latter case would be if a new message arrives in a mailbox during a session. In this case, the server will convey this information unilaterally at its first opportunity, regardless of what command was recently sent.    The following are the response codes defined by the IMAP standard:    **ALERT** An alert message to be sent to the human user of the IMAP client to inform him of something important.    **BADCHARSET** Sent when a search fails due to use of an unsupported character set.    **CAPABILITY** A list of server capabilities may be sent as part of the initial server greeting so the CAPABILITY command does not need to be used.    **PARSE** Sent when an error occurs parsing the headers or MIME content of an email message.    **PERMANENTFLAGS** Communicates a list of message status flags that the client is allowed to manipulate.    **READ-ONLY** Tells the client that the mailbox is accessible only in a read-only mode.    **READ-WRITE** Tells the client that the mailbox is accessible in read-write mode.    **TRYCREATE** Sent when an APPEND or COPY command fails due to the target mailbox not existing, to suggest to the client that it try creating the mailbox first.    **UIDNEXT** Sent with a decimal number that specifies the next unique identifier value to use in an operation. These identifiers allow each message to be uniquely identified.    **UIDVALIDITY** Sent with a decimal number that specifies the unique identifier validity value, used to confirm unique message identification.    **UNSEEN** Sent with a decimal number that tells the client the message that is flagged as not yet seen (a new message).    ## IMAP Not Authenticated State: User Authentication Process and Commands    An IMAP4 session begins with an IMAP4 client establishing a TCP connection with an IMAP4 server. Under normal circumstances, the IMAP4 server has no idea who the client is, and therefore starts the session in the Not Authenticated state. For security reasons, the client is not allowed to do anything until it is authenticated. Thus, the only purpose of this state is to allow the client to present valid credentials so the session can move on to the Authenticated state.    ### IMAP Authentication Methods    The IMAP4 standard defines three different mechanisms by which a client may authenticate itself. These are implemented using one or more of the three different commands allowed only in the Not Authenticated state, which are shown in Table 78-3.    Table 78-3. IMAP Not Authenticated State Commands     | Command | Parameters | Description | | --- | --- | --- | | LOGIN | User name and password | Specifies a user name and password to use for authentication. | | AUTHENTICATE | Authentication mechanism name | Tells the server that the client wants to use a particular authentication mechanism and prompts the client and server to exchange authentication information appropriate for that mechanism. | | STARTTLS | None | Tells the IMAP4 server to use the Transport Layer Security (TLS) protocol for authentication, and prompts TLS negotiation to begin. |    In response to a LOGIN or AUTHENTICATE command, the server will send an OK message if the authentication was successful, and then transition to the Authenticated state. It will send a NO response if authentication failed due to incorrect information. The client can then try another method of authenticating or terminate the session with the LOGOUT command.    The three authentication methods are as follows:    **Plain Login** This is the typical user name/password technique, using the LOGIN command by itself. This is similar to the simple scheme used in POP3, except that in IMAP4 one command is used to send both the user name and password. Since the command and parameters are sent in plain text, this is by far the least secure method of authentication and is not recommended by the standard unless some other means is used in conjunction.    **TLS Login** This is a secure login where the Transport Layer Security (TLS) protocol is first enabled with the STARTTLS command, and then the LOGIN command can be used securely. Note that STARTTLS only causes the TLS negotiation to begin and does not itself cause the IMAP client to be authenticated. Either LOGIN or AUTHENTICATE must still be used.    **Negotiated Authentication Method** The AUTHENTICATE command allows the client and server to use any authentication scheme that they both support. The server may indicate which schemes it supports in response to a CAPABILITY command. After specifying the authentication mechanism to be used, the server and client exchange authentication information as required by the mechanism specified. This may require one or more additional lines of data to be sent.    ### Tip    **KEY CONCEPT** IMAP supports three basic types of authentication: a plain user name/password login, authentication using the Transport Layer Security (TLS) protocol, or the negotiation of some other authentication method between the client and server. In some cases, the IMAP server may choose to preauthenticate clients that it is able to identify reliably; in which case, the Not Authenticated state is skipped entirely.    ## IMAP Authenticated State: Mailbox Manipulation/Selection Process and Commands    In the normal progression of an IMAP session, the Authenticated state is the first state in which the IMAP client is able to perform useful work on behalf of its user. This state will normally be reached from the Not Authenticated state after successful authentication using the LOGIN or AUTHENTICATE command. Alternately, a server may preauthenticate a client and begin the session in this state directly.    Once in the Authenticated state, the client is considered authorized to issue commands to the server. However, it may issue only commands that deal with *whole mailboxes*. As mentioned in the general operation overview, IMAP was created to allow access to, and manipulation of, multiple mailboxes. For this reason, the client must specify dynamically which mailbox it wants to use before commands dealing with individual messages may be given. This is done in this state using the SELECT or EXAMINE command, which both cause a transition to the Selected state.    It is also possible that the Authenticated state can be reentered during the course of a session. If the CLOSE command is used from the Selected state to close a particular mailbox, the server will consider that mailbox deselected, and the session will transition back to the Authenticated state until a new selection is made. The same can occur if a new SELECT or EXAMINE command is given from the Selected state but fails.    ### Authenticated State Commands    Table 78-4 provides a brief description of the mailbox-manipulation commands that can be used in the Authenticated state.    Table 78-4. IMAP Authenticated State Commands     | Command | Parameters | Description | | --- | --- | --- | | SELECT | Mailbox name | Selects a particular mailbox so that messages within it can be accessed. If the command is successful, the session transitions to the Selected state. The server will also normally respond with information for the client about the selected mailbox, as described after this table. | | EXAMINE | Mailbox name | The same as the SELECT command, except that the mailbox is opened read-only; no changes are allowed. | | CREATE | Mailbox name | Creates a mailbox with the given name. | | DELETE | Mailbox name | Deletes the specified mailbox. | | RENAME | Current and new mailbox names | Renames a mailbox. | | SUBSCRIBE | Mailbox name | Adds the mailbox to the server's set of active mailboxes. This is sometimes used when IMAP4 is employed for Usenet message access. | | UNSUBSCRIBE | Mailbox name | Removes the mailbox from the active list. | | LIST | Mailbox name or reference string | Requests a partial list of available mailbox names, based on the parameter provided. | | LSUB | Mailbox name or reference string | The same as LIST but returns only names from the active list. | | STATUS | Mailbox name | Requests the status of the specified mailbox. The server responds providing information such as the number of messages in the box and the number of recently arrived and unseen messages. | | APPEND | Mailbox name, message, optional flags, and date/time | Adds a message to a mailbox. |    ### Note    *All of the commands in Table 78-4 may also be used in the Selected state; they should really be called Authenticated+Selected state commands*.    When either the SELECT or EXAMINE command is successfully issued, the server will return to the client a set of useful information about the mailbox, which can be used to guide commands issued from the Selected state. This information includes the following three mandatory responses:    **<*n*> EXISTS** Tells the client the number of messages in the mailbox.    **<*n*> RECENT** Tells the client the number of recently arrived (new) messages.    **FLAGS (<*flag-list*>)** Tells the client which flags are supported in the mailbox. These include the following: `\Seen`, `\Answered`, `\Flagged` (marked for special attention), `\Deleted`, `\Draft`, and `\Recent`. (The backslashes are part of the flag names.)    The reply from the server may also contain these optional replies:    **UNSEEN <*n*>** The message number of the first unseen message.    **PERMANENTFLAGS (<*flag-list*>)** A list of flags (as for the FLAGS response above) that the client is allowed to change.    **UIDNEXT <*n*>** The next unique identifier value. This is used to check for changes made to the mailbox since the client last accessed it.    **UIDVALIDITY <*n*>** The unique identifier validity value, used to confirm valid UID values.    ### Tip    **KEY CONCEPT** In the Authenticated state, the IMAP client can perform operations on whole mailboxes, such as creating, renaming, or deleting mailboxes, or listing mailbox contents. The SELECT and EXAMINE commands are used to tell the IMAP server which mailbox the client wants to open for message-specific access. Successful execution of either command causes the server to provide the client with several pieces of important information about the mailbox, after which the session transitions to the Selected state.    ## IMAP Selected State: Message Manipulation Process and Commands    Once the IMAP client has been authorized to access the server, it enters the Authenticated state, where it is allowed to execute tasks on whole mailboxes. Since IMAP allows multiple mailboxes to be manipulated, message-specific commands cannot be used until the client tells the server which mailbox in wants to work with. Only one mailbox can be accessed at a time in a given session.    After the SELECT or EXAMINE command is successfully issued, the session enters the Selected state. In this state, the full palette of message and mailbox commands is available to the client. This includes the message-specific commands in Table 78-5 as the mailbox commands defined for the Authenticated state. Most of IMAP's message-specific commands do not include a mailbox name as a parameters, since the server knows automatically that the commands apply to whatever mailbox was selected in the Authenticated state.    The session remains in the Selected state for as long as the client continues to have work to do with the particular selected (or examined) mailbox. Three different actions can cause a transition out of the Selected state:    *   If the client has nothing more to do when it is done with the current mailbox, it can use the LOGOUT command to end the session.           *   The client can use the CLOSE command to tell the server it is finished with the current mailbox but keep the session active. The server will close the mailbox, and the session will go back to the Authenticated state.           *   The client can issue a new SELECT or EXAMINE command, which will implicitly close the current mailbox and then open the new one. The transition in this case is from the Selected state back to the Selected state, but with a new current mailbox.              ### Selected State Commands    Table 78-5 lists the message-specific commands that can be used only in the Selected state.    Table 78-5. IMAP Selected State Commands     | Command | Parameters | Description | | --- | --- | --- | | CHECK | None | Sets a checkpoint for the current mailbox. This is used to mark when a certain sequence of operations has been completed. | | CLOSE | None | Explicitly closes the current mailbox and returns the session to the Authenticated state. When this command is issued, the server will also implicitly perform an EXPUNGE operation on the mailbox. | | EXPUNGE | None | Permanently removes any messages that were flagged for deletion by the client. This is done automatically when a mailbox is closed. | | SEARCH | Search criteria and an optional character set specification | Searches the current mailbox for messages matching the specified search criteria. The server response lists the message numbers meeting the criteria. | | FETCH | Sequence of message numbers and a list of message data items (or a macro) | Retrieves information about a message or set of messages from the current mailbox. | | STORE | Sequence of message numbers, message data item name, and value | Stores a value for a particular message data item for a set of messages. | | COPY | Sequence of message numbers and a mailbox name | Copies the set of messages specified to the end of the specified mailbox. | | UID | Command name and arguments | Used to allow one of the other commands above to be performed using unique identifier numbers for specifying the messages to be operated on, rather than the usual message sequence numbers. |    The list in Table 78-5 might seem surprisingly short. You might wonder, for example, where the specific commands are to read a message header or body, delete a message, mark a message as read, and so forth. The answer is that these (and much more) are all implemented as part of the powerful and flexible FETCH and STORE commands.    The FETCH command can be used to read a number of specific elements from either one message or a sequence of messages. The list of message data items specifies what information is to be read. The data items that can be read include the headers of the message, the message body, flags that are set for the message, the date of the message, and much more. The FETCH command can even be used to retrieve part of a message, such as one body part of a MIME multipart message, making it very useful indeed. Special macros are also defined for convenience. For example, the client can specify the message data item FULL to get all the data associated with a message.    The complement to FETCH, the STORE command, is used to make changes to a message. However, this command does not modify the basic message information such as the content of headers and the message body. Rather, it exists for changing the message's status flags. For example, after replying to a particular message, the client may set the `\Answered` flag for that message using the STORE command.    Message deletion in IMAP is done in two stages for safety, as in POP and many other protocols. The client sets the `\Deleted` flag for whichever messages are to be removed, using the STORE command. The messages are deleted only when the mailbox is expunged, typically when it is closed.    The search facility in IMAP4 is also surprisingly quite sophisticated, allowing the client to look for messages based on multiple criteria simultaneously. For example, with the appropriate syntax, you could search for "all posts that are flagged as having been answered that were sent by Jane Jones before April 1, 2004." Users of IMAP clients can thus easily locate specific messages even in very large mailboxes without needing to download and hunt through hundreds of messages.    ### Tip    **KEY CONCEPT** After the client opens a specific mailbox, the IMAP session enters the Selected state, where operations such as reading and copying individual email messages may be performed. The two most important commands used in this state are FETCH, which can be used to retrieve a whole message, part of a message, or only certain message headers or flags; and STORE, which sets a message's status information. IMAP also includes a powerful search facility, providing users with great flexibility in finding messages in a mailbox. When the client is finished working with a particular mailbox, it may choose a different one and reenter the Selected state, close the mailbox and return to the Authenticated state, or log out, automatically entering the Logout state.    # TCP/IP Direct Server Email Access    This final portion of the journey of a TCP/IP email message is usually the job of an email access and retrieval protocol like POP3 or IMAP4\. These are *customized* protocols, by which I mean that they were created specifically for the last step of the email communication process. However, there are also several *generic* methods by which an email client can gain access to a mailbox, without the use of a special protocol.    These methods are all variations of the online email access model. They generally work by establishing *direct access* to the server where the mailbox is located. The mailbox itself is just a file on a server somewhere, so if that file can be made available, it can be viewed and manipulated like any other file using an email client program that reads and writes the mailbox file. The following are some of the ways in which this can be done:    **Using the SMTP Server Directly** The simplest method for gaining access to the mailbox is to log on to the server itself. This is not an option for most people, and even in years gone by, it was not often done, for security and other reasons. However, some people do run their own SMTP servers, giving them considerable control over access to their email.    **File Sharing Access** Using a protocol such as NFS, it is possible to have a mailbox mounted on a user's client machine where it can be accessed as if it were a local file. The mail is still on the server and not the client machine, but the communication between the client and the server occurs transparently to both the user and the email client software.    **Dial-Up Remote Server Access** A user on a client machine dials up a server where her mailbox is located and logs in to it. The user then can issue commands to access mail on that server as if she were logged in to it directly.    **Telnet Remote Server Access** Instead of dialing in to the server, a user can connect to it for remote access using the Telnet Protocol.    These techniques are much more commonly associated with timesharing systems, which commonly use the UNIX family of operating systems more than others. They are also often combined; for example, remote access is often provided for UNIX users, but most companies don't want users logging in directly to the SMTP server. Instead, an ISP might run an SMTP server on one machine called *mail.companyname.com* and also operate a different server that is designed for client access called *users.companyname.com*. A user could access email by dialing into the users machine, which would employ NFS to access user mailboxes on the mail machine.    Direct server access is a method that has been around for decades. At one time, this was how the majority of people accessed email, for two main reasons. First, if you go back far enough, protocols like POP or IMAP had not yet been developed; the TCP/IP email system as a whole predates them by many years, and direct access was the only option back then. Second, the general way that email and networks were used years ago was different from what it is today. Most individuals did not have PCs at home, and no Internet as we know it existed. Remotely accessing a UNIX server using a modem or Telnet for email and other services was just the way it was done.    I got started using direct server access for email more than ten years ago, and I still use it today. I Telnet in to a client machine and use a UNIX email program called `elm` to access and manipulate my mailbox. To me, this provides numerous advantages:    *   Most important, I can access my email using Telnet from any machine on the Internet, anywhere around the world.           *   Since I am logged in directly, I get immediate notification when new mail arrives, without needing to check routinely for new mail.           *   My mailbox is always accessible, and all my mail is always on a secure server in a professionally managed data center.           *   I have complete control over my mailbox and can edit it, split it into folders, write custom spam filters, or do anything else I need to do.              This probably sounds good, but most people today do not use direct server access because of the disadvantages of this method. One big issue is that you must be logged in to the Internet to access your email. Another one, perhaps even larger, is the need to be familiar with UNIX and a UNIX email program. UNIX is simply not as user-friendly as a graphical operating systems such as Windows or the Mac. For example, my UNIX email program doesn't support color and cannot show me attached graphic images. I must extract images and other files from MIME messages and transfer them to my own PC for viewing.    Most ordinary computer users today don't know UNIX and don't want to know it. They are much happier using a fancy graphical email program based on POP3 or IMAP4\. However, a number of us old UNIX dinosaurs are still around and believe the benefits of direct access outweigh the drawbacks. (Oh, one other benefit that I forgot to mention is that it's very hard to get a computer virus in email when you use UNIX!)    ### Tip    **KEY CONCEPT** Instead of using a dedicated protocol like POP3 or IMAP4 to retrieve mail, on some systems it is possible for a user to have direct server access to email. This is most commonly done on UNIX systems, where protocols like Telnet or NFS can give a user shared access to mailboxes on a server. This is the oldest method of email access. It provides the user with the most control over his mailbox and is well suited to those who must access mail from many locations. The main drawback is that it means the user must be on the Internet to read email, and it also usually requires familiarity with the UNIX operating system, which few people use today.    # TCP/IP World Wide Web Email Access    Most email users like the advantages of online access, especially the ability to read mail from a variety of different machines. What they don't care for is direct server access using protocols like Telnet, UNIX, and nonintuitive, character-based email programs. They want online access, but they want it to be simple and easy to use.    In the 1990s, the World Wide Web was developed and grew in popularity very rapidly, due in large part to its ease of use. Millions of people became accustomed to firing up a web browser to perform a variety of tasks, to the point at which using the Web has become almost second nature. It didn't take very long before someone figured out that using the Web would be a natural way of providing easy access to email on a server.    This technique is straightforward. It exploits the flexibility of the Hypertext Transfer Protocol (HTTP) to tunnel email from a mailbox server to the client. A web browser (client) is opened and given a URL for a special web server document that accesses the user's mailbox. The web server reads information from the mailbox and sends it to the web browser, where it is displayed to the user.    This method uses the online access model like direct server access, because requests must be sent to the web server, and this requires the user to be online. The mail also remains on the server, as when NFS or Telnet are used. The big difference between Web-based mail and the UNIX methods is that the former is much easier for nonexperts to use.    Since the idea was first developed, many companies have jumped on the Web-mail bandwagon, and the number of people using this technique has exploded into the millions in just a few years. Many free services even popped up in the late 1990s as part of the dot-com bubble, allowing any Internet user to send and receive email using the Web at no charge (except perhaps for tolerating advertising). Many ISPs now offer Web access as an option in additional to conventional POP/IMAP access, which is useful for those who travel.    There are drawbacks to the technique, however, which as you might imagine are directly related to its advantages. Web-based mail is easy to use, but inflexible; the user does not have direct access to her mailbox and can use only whatever features the provider's website implements. For example, suppose the user wants to search for a particular string in her mailbox; this requires that the Web interface provide this function. If it doesn't, the user is out of luck.    Web-based mail also has a disadvantage that is an issue for some people: performance. Using conventional UNIX direct access, it is quick and easy to read through a mailbox; the same is true of access using POP3, once the mail is downloaded. In contrast, Web-based mail services mean each request requires another HTTP request/response cycle. The fact that many Web-based services are free often means server overload that exacerbates the speed issue.    Note that when Web-based mail is combined with other methods such as POP3, care must be taken to avoid strange results. If the Web interface doesn't provide all the features of the conventional email client, certain changes made by the client may not show up when Web-based access is used. Also, mail retrieval using POP3 by default removes the mail from the server. If you use POP3 to read your mailbox and then later try to use the Web to access those messages from elsewhere, you will find that the mail is gone—it's on the client machine where you used the POP3 client. Many email client programs now allow you to specify that you want the mail left on the server after retrieving it using POP3.    ### Tip    **KEY CONCEPT** In the past few years, a new method has been developed to allow email access using the World Wide Web. This technique is rapidly growing in popularity, because it provides many of the benefits of direct server access, such as the ability to receive email anywhere around the world, while being much simpler and easier than the older methods of direct access such as making a Telnet connection to a server. In some cases, Web-based email can be used in combination with other methods or protocols, such as POP3, giving users great flexibility in how they read their mail.````
