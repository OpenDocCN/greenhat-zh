# 第八章. 像程序员一样思考

![无标题图片](img/httpatomoreillycomsourcenostarchimages1273151.png.jpg)

是时候将前几章中我们所经历的一切整合起来，完成从新手程序员到问题解决程序员的转变之旅。

在前几章中，我们在各个领域解决了问题。我相信这些领域对正在发展的程序员来说最有益，但当然还有更多东西要学习，而且许多问题将需要本书未涵盖的技能。因此，在本章中，我们将回到一般问题解决概念，结合我们在旅程中获得的知识，制定一个攻击任何编程问题的**宏伟蓝图**。虽然我们可能称之为一个一般计划，但在某种程度上，它实际上是一个非常具体的计划：它将是**您的**计划，而不是别人的。我们还将探讨您作为程序员可以增加知识和技能的许多方式。

# 制定您的个人宏伟蓝图

充分发挥您的优势和劣势

在多年的教学过程中，我见过各种能力水平的学生。我说的不仅仅是有些程序员的能力比其他人强，虽然这当然是真的。即使在能力水平相同的情况下，程序员之间也存在很大的差异。我记不清有多少次被一个曾经努力的学生迅速掌握一项特定技能或一个有才华的学生在新领域表现出弱点而感到惊讶。正如没有两个人的指纹是完全相同的，也没有两个人的大脑是完全相同的，对某个人来说容易的课程对另一个人来说可能就很难。

假设您是一名足球教练，正在为下一场比赛制定进攻策略。由于受伤，您不确定哪位四分卫能够首发。这两位四分卫都是能力出众的专业球员，但就像任何领域的个人一样，他们都有自己的优势和劣势。为一位四分卫制定的比赛策略可能对另一位来说却是个糟糕的选择。

在制定您的宏伟蓝图时，您是教练，您的技能组合就是您的四分卫。为了最大限度地提高成功的机会，您需要一个既能认识到您的优势也能认识到您的劣势的计划。

## 在第一章中，我们了解到解决问题的第一规则是您应该始终有一个计划。一个更精确的表述可能是说您应该始终遵循**您的**计划。您应该构建一个能够最大限度地发挥您的优势并最小化您的劣势的宏伟蓝图，然后将这个宏伟蓝图应用于您必须解决的每个问题。

因此，制定自己的主计划的关键步骤是识别你的优势和弱点。这并不困难，但需要努力和相当程度的诚实自我评估。为了从你的错误中受益，你不仅必须在出现错误的程序中纠正它们，而且你必须在心理上或最好是在文档中记录它们。这样，你可以识别出你否则可能会错过的行为模式。

我将描述两种不同类别的弱点：编码和设计。*编码弱点*是在你实际编写代码时容易重复犯错的领域。例如，许多程序员经常编写迭代次数过多或过少的循环。这被称为*栅栏桩错误*，源自一个古老的难题，即需要多少根栅栏桩才能用 10 英尺长的横梁建造一个 50 英尺的栅栏。大多数人的直接反应是五根，但如果你仔细思考，答案是六根，如图图 8-1 所示。

大多数编码弱点是程序员在编码过快或准备不足时创建的语义错误的情况。相比之下，*设计弱点*是在问题解决或设计阶段常见的问题。例如，你可能会发现你很难开始或者很难将之前编写的子程序集成到完整的解决方案中。

![栅栏桩难题](img/httpatomoreillycomsourcenostarchimages1273271.png)

图 8-1. 栅栏桩难题

虽然这两个类别之间有一些重叠，但两种类型的弱点往往会引起不同类型的问题，并且必须以不同的方式来防御。

### 针对编码弱点的规划

在编程中，最令人沮丧的活动之一可能是花费数小时追踪一个语义错误，一旦确定，其实很容易修复。因为没有人是完美的，所以无法完全消除这些情况，但一个好的程序员会尽其所能避免一次又一次地犯同样的错误。

我认识一个程序员，他已经厌倦了犯可能是 C++编程中最常见的语义错误：将赋值运算符（`=`）替换为相等运算符（`==`）。因为 C++中的条件表达式是整数，而不是严格的布尔值，所以以下这样的语句在语法上是合法的：

```
if (number = 1) flag = true;
```

在这种情况下，整数值 1 被分配给`number`，然后值 1 被用作条件语句的结果，C++将其评估为`true`。当然，程序员本意是想做的是：

```
if (number == 1) flag = true;
```

对于反复犯这种错误感到沮丧，程序员自学了总是以另一种方式编写相等测试，即左侧使用数值字面量，例如：

```
if (1 == number) flag = true;
```

通过这样做，如果程序员不小心使用了相等运算符，表达式`1 = number`就不再是合法的 C++语法，并且会在编译时产生语法错误。原始错误是合法的语法，所以它只是一个语义错误，可能会在编译时被捕获，也可能根本不会被捕获。由于我自己也犯过这样的错误（并且试图追踪这个错误让自己疯狂），我采用了这种方法，将数值字面量放在相等运算符的左边。在这个过程中，我发现了一些有趣的事情。因为这与我的常规风格相反，将字面量放在左边迫使我写条件语句时暂时停下来。我会想，“我需要记住把字面量放在左边，这样我就能在用到赋值运算符时提醒自己。”正如你所预期的，通过让这个想法在我的脑海中运行，我实际上从未使用过赋值运算符，而总是正确地使用了相等运算符。现在，我不再把字面量放在相等运算符的左边，但我仍然会停下来，让这些想法在我的脑海中运行，这使我避免了使用错误的运算符。

这里的教训是，意识到自己的编码弱点通常就足以避免它们。这是好消息。坏消息是，你仍然需要付出努力来首先意识到自己的编码弱点。关键技巧是问自己为什么犯了一个特定的错误，而不仅仅是修复错误然后继续前进。这将帮助你识别你未能遵循的一般原则。例如，假设你编写了以下函数来计算整数数组中正数的平均值：

```
double averagePositive(int array[ARRAYSIZE]) {
   int total = 0;
   int positiveCount = 0;
   for (int i = 0; i < ARRAYSIZE; i++) {
      if (array[i] > 0) {
         total += array[i];
         positiveCount++;
      }
   }
 return total / (double) positiveCount;
}
```

乍一看，这个函数看起来没问题，但仔细检查后会发现一个问题。如果数组中没有正数，那么循环结束时`positiveCount`的值将为零，这将在函数结束时导致除以零的错误 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)。因为这是浮点数除法，程序可能实际上不会崩溃，而是产生奇怪的行为，这取决于这个函数在整个程序中的使用方式。

如果你急于让代码运行，并发现了这个问题，你可能会添加一些代码来处理`positiveCount`为零的情况，然后继续。但如果你想作为一个程序员成长，你应该问问自己你犯了什么错误。具体问题当然是，你没有考虑到除以零的可能性。但如果分析就到这里，那么在将来它对你帮助不大。当然，你可能会遇到另一个除数可能为零的情况，但这并不常见。相反，我们应该问一下违反了哪个一般原则。答案是：我们应该总是寻找可能使我们的代码崩溃的特殊情况。

通过考虑这个一般原则，我们更有可能看到我们错误中的模式，因此更有可能在将来捕捉到这些错误。问自己“这里有可能除以零吗？”并不像问自己“这个数据有哪些特殊情况？”那么有用。通过问更广泛的问题，我们会提醒自己不仅要检查除以零，还要检查空数据集、超出预期范围的数据等等。

### 针对设计弱点的规划

设计上的弱点需要不同的方法来规避。但第一步是相同的：你识别出弱点。很多人在这个步骤上遇到困难，因为他们不喜欢对自己如此苛刻。我们习惯于隐藏个人的失败。就像当面试官问你最大的弱点是什么时，你被期望给出一些关于你过于关心工作质量的废话，而不是提供一个**实际**的弱点。但就像超人有他的氪石一样，即使是最好的程序员也有真正的弱点。

这里有一份（当然不是详尽的）程序员弱点的样本列表。看看你是否在这些描述中找到了自己。

**设计复杂**

具有这种弱点的程序员创建的程序部分太多或步骤太多。虽然程序可以工作，但它们不会让人有信心——就像看起来一扯就会破的破旧衣服——而且它们显然效率低下。

**无法开始**

这个程序员有很大的惰性。无论是由于对解决问题的信心不足还是简单的拖延，这个程序员在问题上的初始进展总是花费太长时间。

**未能测试**

这个程序员不喜欢正式测试代码。通常代码对一般情况有效，但对特殊情况无效。在其他情况下，代码可能运行良好，但不会“扩展”到程序员未测试的更大的问题集。

**过度自信**

信心是一件好事——这本书的目的是增加读者的信心——但过度的自信有时可能和缺乏自信一样成问题。过度自信会以各种方式表现出来。过度自信的程序员可能会尝试比必要的更复杂的解决方案，或者给项目留的时间太少，结果导致一个匆忙、充满错误的程序。

**薄弱环节**

这个类别有点像是一个大杂烩。一些程序员在遇到某些概念之前工作得很顺利。考虑一下本书前面章节中讨论的主题。大多数程序员，即使完成了练习，也会在某些我们覆盖的领域比其他领域更有信心。例如，程序员可能在指针程序中迷失方向，或者递归让程序员的头脑变得混乱。也许程序员在设计复杂的类时遇到困难。并不是程序员不能勉强解决问题，但这是一项艰难的工作，就像在泥地里开车一样。

有不同的方法可以面对你的大规模薄弱环节，但一旦你认识到它们，规划起来就容易多了。例如，如果你是那种经常跳过测试的程序员，那么请将测试明确纳入你编写每个模块的计划中，并且不要在检查那个框之前进入下一个模块。或者考虑一种称为*测试驱动开发*的设计范式，在这种范式中，测试代码首先编写，然后编写代码来填充那些测试。如果你有困难开始，使用分解或简化问题的原则，并尽快开始编写代码，理解你可能需要稍后重写那段代码。如果你的设计通常过于复杂，在你的总体规划中添加一个明确的重构步骤。重点是，无论你作为程序员有什么弱点，如果你认识到它们，你就可以规划绕过它们。那么，你的弱点就不再是弱点——只是你在通往成功项目完成道路上的障碍，你可以绕过它们。

### 规划您的优势

规划您的薄弱环节主要是为了避免错误。然而，良好的规划并不仅仅是避免错误。它是在你当前的能力和可能面临的任何限制下，朝着最佳可能结果努力。这意味着你必须在你的总体规划中融入你的优势。

你可能认为这一部分不是为你准备的，或者至少还不是。毕竟，如果你在读这本书，那么你还在成为程序员的路上。你可能想知道在目前的发展阶段你是否真的有任何优势。我在这里告诉你，你确实有，即使你还没有意识到。以下是一份常见的程序员优势列表，绝非详尽无遗，每个优势都有描述以及帮助你识别这些优势是否适用于你的提示：

**注重细节**

这种类型的程序员可以预见特殊情况，在问题出现之前就能看到潜在的性能问题，并且永远不会让大局模糊了必须处理的重要细节，这对于程序成为一个完整且正确的解决方案至关重要。具有这种优势的程序员倾向于在编码前在纸上测试他们的计划，缓慢编码，并频繁测试。

**快速学习者**

快速学习者能够迅速掌握新技能，无论是学习已知语言中的新技术还是使用新的应用程序框架。这种类型的程序员喜欢学习新事物的挑战，并可能根据这种偏好选择项目。

**快速编码者**

快速编码者不需要花很多时间在参考书上就能敲出一个函数。一旦开始输入，代码就会从快速编码者的指尖流淌出来，几乎不需要努力，且语法错误很少。

**永不放弃**

对于一些程序员来说，一个讨厌的 bug 就像是对他们个人的侮辱，不能被忽视。这就像程序用皮手套打在程序员的嘴上，程序员必须做出回应。这种类型的程序员似乎总是保持冷静，坚定但从不非常沮丧，并确信只要付出足够的努力，胜利就一定属于自己。

**超级问题解决者**

很可能你在购买这本书时并不是一个超级问题解决者，但现在你已经得到了一些指导，也许一切开始变得容易起来。具有这种特性的程序员在阅读问题时已经开始构想可能的解决方案。

**动手实践者**

对于这种程序员来说，一个能工作的程序就像一个美妙的玩具箱。动手实践者从未失去让计算机按照自己的意愿工作的兴奋感，喜欢不断为计算机找到新的任务。也许这种动手实践意味着给一个能工作的程序添加越来越多的功能——这是一种被称为*渐进式特性主义*的症状。也许程序可以被重构以提高性能。也许程序只是为了程序员或用户而变得更漂亮。

很少有程序员会展现出超过两种这些优势——实际上，其中一些优势可能会相互抵消。但每个程序员都有自己的优势。如果你在上述任何一项中找不到自己的影子，那只是意味着你还没有足够了解自己，或者你的优势不属于我的任何一个类别。

一旦你确定了你的优势，你需要将它们纳入你的总体规划中。假设你是一个编程速度快的人。显然这有助于让任何项目顺利完成，但你如何以系统化的方式利用这个优势呢？在正式的软件工程中，有一种称为“快速原型设计”的方法，其中程序最初在没有广泛规划的情况下编写，然后通过连续迭代进行改进，直到结果满足问题要求。如果你是一个编程速度快的人，你可能尝试采用这种方法，一旦有基本想法就立即编码，让你的粗糙原型指导最终程序代码的设计和开发。

如果你是一个快速学习者，也许你应该从寻找新的资源或技术来解决当前问题开始每一个项目。如果你不是一个快速学习者，但你是那种不容易沮丧的程序员，也许你应该从你认为最困难的领域开始项目，给自己更多的时间去解决它们。

所以无论你有什么优势，确保你在编程中充分利用它们。设计你的总体规划，以便尽可能多地做你最擅长的事情。这样不仅会产生最好的结果，而且你也会玩得最开心。

## 制定总体规划

让我们看看构建一个示例总体规划。配料包括我们开发的所有解决问题的技巧，以及我们对优势和劣势的分析。在这个例子中，我将使用我自己的优势和劣势。

在解决问题的技巧方面，我使用这本书中分享的所有技巧，但我特别偏爱“简化问题”的技巧，因为使用这个技巧让我感觉我总是在朝着目标取得具体进展。如果我现在无法想出一种编写满足完整规范代码的方法，我就会先抛出一部分规范，直到我获得动力。

我最大的编程弱点是过于急切。我喜欢编程，因为我喜欢看到计算机按照我的指令运行。有时这会让我想，“让我们试试看这个，看看会发生什么，”而此时我应该还在分析我刚刚写下的代码的正确性。这里的危险不在于程序会失败——而在于程序可能会看似成功但未涵盖所有特殊情况，或者成功但不是我能写出的最佳解决方案。

我喜欢优雅的程序设计，这种设计易于扩展和重用。通常当我编写较大的项目时，我会花费大量时间开发替代设计方案。总体来说，这是一个好的特性，但有时这会导致我在设计阶段花费过多时间，没有留出足够的时间来实际实施所选的设计。此外，有时这可能会导致过度设计的解决方案。也就是说，有时解决方案比实际需要的更加优雅、可扩展和健壮。因为每个项目在时间和金钱上都是有限的，所以最佳解决方案必须在追求高软件质量与节约资源的需求之间取得平衡。

我认为我最好的编程优势是，我能够很好地掌握新概念，并且我喜欢学习。当一些程序员喜欢反复使用相同的技能时，我喜欢那些可以让我学到新东西的项目，而且我总是被这样的挑战所激励。

考虑到所有这些，以下是我对新项目的总体规划。

为了克服我的主要设计弱点，我将严格限制我在设计阶段花费的时间，或者，在继续前进之前，限制我要考虑的不同设计的数量。这可能会让一些读者觉得这是一个危险的想法。我们不应该在设计阶段投入尽可能多的时间，然后再开始编码吗？大多数项目不都是因为前端投入的时间不足而导致后端出现一系列妥协吗？这些担忧是合理的，但请记住，我并不是在编写一个软件开发的一般指南。我正在创建我自己的个人总体规划，以应对编程问题。我的弱点是过度设计，而不是设计不足，因此限制设计时间对我来说是有意义的。对于另一位程序员来说，这样的规则可能是灾难性的，有些程序员可能需要一个规则来迫使他们花更多的时间在设计上。

在完成初步分析之后，我将考虑项目是否提供了学习新技术、库等的机会。如果确实如此，我将在尝试将其纳入我的开发解决方案之前，编写一个小型测试程序来尝试这些新技能。

为了对抗过度的急切心情，我可以在完成每个模块的编码后加入一个微型的代码审查步骤。然而，这需要我自己的意志力——当我完成每个模块时，我肯定会想要尝试它。仅仅希望每次都能说服自己放弃，就像在饥饿的人旁边放一袋薯片，然后惊讶地看着袋子被清空。更好的办法是制定一个计划，让程序员不必与其本能作斗争。那么，如果我创建两个版本的项目：一个粗糙的、无拘无束的版本和一个经过打磨的交付版本呢？如果我允许自己随意玩弄第一个版本，但直到它被彻底审查后才允许将其代码合并到打磨版本中，我更有可能克服我的弱点。

# 解决任何问题

一旦我们有了总计划，我们就准备好应对任何情况。这正是这本书的最终目的：从一个问题开始，任何问题，找到一条通往解决方案的道路。在前面的所有章节中，问题描述推动我们朝着特定的初始方向前进，但在现实世界中，大多数问题并不要求使用数组或递归，或者将程序功能的一部分封装到类中。相反，程序员在解决问题的过程中做出这些决定。

起初，更少的约束可能看起来会使问题更容易解决。毕竟，设计要求是一种约束，而约束不是会使问题更难吗？虽然这是真的，但所有问题都有约束——只是有些情况下，它们比其他情况下更明确地表述出来。例如，没有被告知特定问题是否需要动态分配的结构并不意味着这个决定没有影响。如果我们的设计选择错误，问题的广泛约束——无论是性能、可修改性、开发速度还是其他什么——可能更难满足，或者可能根本无法满足。

想象一下，一群朋友请你为他们挑选一部电影观看。如果其中一个朋友肯定想看喜剧，另一个不喜欢老电影，还有一个列出她刚刚看过的五部电影，不想再看，这些限制会使选择变得困难。然而，如果没有人有任何建议，只是“随便挑个好的”，你的工作会更难，你很可能挑选出至少一个成员根本不喜欢的电影。

因此，更大、定义较宽泛、约束较弱的难题是最难解决的。然而，它们同样容易受到我们在本书中使用的相同问题解决技术的攻击；只是需要更多的时间来解决。有了这些技术的知识和手中的总计划，你将能够解决任何问题。

为了说明我所说的内容，我将带你了解一个玩猜字谜程序的初步步骤，这是一个经典的儿童游戏，但有一个转折点。

在我们到达问题描述之前，让我们回顾一下游戏的基本规则。第一个玩家选择一个单词，并告诉第二个玩家单词中有多少个字母。然后第二个玩家猜测一个字母。如果这个字母在单词中，第一个玩家会显示这个字母在单词中的位置；如果这个字母出现多次，所有出现的位置都会被指出。如果这个字母不在单词中，第一个玩家会在一个被绞死的人的 stick-figure 画上添加一个部件。如果第二个玩家猜对了单词中的所有字母，第二个玩家获胜，但如果第一个玩家完成了画，第一个玩家获胜。关于组成被绞死的人的部件数量有不同的规则，所以更普遍地说，玩家们事先同意第一个玩家获胜需要多少“失误”。

现在我们已经了解了基本规则，让我们来看一个具体的问题，包括具有挑战性的转折点。

问题：猜字谜作弊

编写一个程序，该程序将是猜字谜（hangman）文本版本的玩家 1（也就是说，你实际上不需要画一个被绞死的人——只需记录错误的猜测次数即可）。玩家 2 将通过指定猜测单词的长度以及导致游戏失败的错误猜测次数来设置游戏的难度。

转折点是程序将作弊。而不是在游戏开始时实际选择一个单词，只要玩家 2 失败，程序就可以显示一个与玩家 2 给出的所有信息匹配的单词。正确猜测的字母必须出现在正确的位置，而且任何错误的猜测字母都不能出现在单词中。当游戏结束时，玩家 1（程序）将告诉玩家 2 所选择的单词。因此，玩家 2 永远无法证明游戏在作弊；这只是玩家 2 获胜的可能性很小。

这不是一个按照现实世界标准的大问题，但它足够大，可以展示我们在处理指定结果但没有指定方法论的编程问题时面临的问题。根据问题描述，你可以在开发环境中启动并开始编写代码，可以在数十个不同的地方开始。当然，这将是错误的，因为我们总是希望有计划地编程，所以我需要将我的总体规划应用于这个具体的情况。

我的大计划的第一部分是限制我在设计阶段花费的时间。为了使这成为现实，我需要在编写生产代码之前仔细思考设计。然而，我相信在这种情况下进行一些实验对于我找到问题的解决方案是必要的。我的大计划还允许我创建两个项目，一个粗糙的原型和最终的、完善的解决方案。因此，我将允许自己在任何实际设计工作之前开始为原型编码，但在我相信设计已经确定之前，不允许对最终解决方案进行任何编码。这不能保证我对第二个项目的整个设计完全满意，但它提供了最好的机会。

现在是时候开始分析这个问题了。在之前的章节中，我们有时会列出完成问题所需的子任务，所以我想要列出这些子任务。然而，目前这很困难，因为我不知道程序实际上会如何实现作弊。我需要进一步调查这个领域。

## 找到作弊的方法

在猜字谜游戏中作弊是足够具体的，我不期望在组件的正常来源中找到任何帮助；没有*邪恶策略*模式。在这个阶段，我对如何作弊有一个模糊的想法。我想我会选择一个初始谜题单词，只要玩家 2 选择的字母实际上不在那个单词中，我就保留那个单词。然而，一旦玩家 2 猜中了一个实际上在单词中的字母，如果可能找到一个不包含迄今为止所选字母的单词，我就会切换到另一个单词。换句话说，我会尽可能长时间地拒绝玩家 2 匹配。这是我的想法，但我需要的不仅仅是想法——我需要我能实现的东西。

为了使我的想法更加明确，我将在纸上通过一个例子来工作，扮演玩家 1 的角色，从一个单词列表开始。为了简化问题，我将假设玩家 2 请求了一个三字母单词，并且我知道的所有三字母单词的完整列表显示在表 8-1 的第一列。我将假设我的第一个选择的“谜题单词”是列表上的第一个单词，*bat*。如果玩家 2 猜的字母不是*b*、*a*或*t*，我会说“不”，然后我们就会更接近完成绞刑架。如果玩家 2 猜中了一个单词中的字母，那么我会选择另一个单词，一个不包含那个字母的单词。

然而，当我查看我的列表时，我不太确定这种策略是否是最好的。在某些情况下，这可能是有意义的。假设玩家 2 猜测*b*。列表中没有任何其他单词包含*b*，所以我可以将谜题单词切换到其中任何一个。这也意味着我已经最小化了损害；我只从我的列表中消除了一个可能的单词。但是，如果玩家 2 猜测*a*会发生什么？如果我只是说“没有”，我将消除包含*a*的所有单词，这只会留下表 8-1 第二列中的三个单词供我选择。如果相反，我决定承认谜题单词中存在字母*a*，我将剩下五个单词可供选择，如第三列所示。但请注意，这种扩展的选择仅因为所有五个单词的*a*都在相同的位置。一旦我宣布一个猜测是正确的，我就必须准确地显示字母在单词中的位置。如果我在游戏中剩余的时间里还有更多的单词选择来应对未来的猜测，我会感到更加安心。

表 8-1. 样本单词列表

| All Words | Words Without *a* | Words with *a* |
| --- | --- | --- |
| bat | dot | bat |
| car | pit | car |
| dot | top | eat |
| eat | saw |
| pit |   | tap |
| saw |   |   |
| tap |   |   |
| top |   |   |

此外，即使我设法在游戏早期避免了揭示字母，我也必须预计玩家 2 最终会做出正确的猜测。例如，玩家 2 可能一开始就猜测所有元音字母。因此，在某个时候，我必须决定在字母被揭示时该做什么，并且根据我对样本列表的实验，看起来我必须找到字母出现最频繁的位置（或位置）。从这个观察中，我意识到我一直在错误地思考作弊。我实际上永远不应该选择一个谜题单词，即使只是暂时，而只是跟踪如果我必须选择时所有可能的单词。

带着这个想法，我现在可以以不同的方式定义作弊：尽可能多地保留候选谜题单词列表中的单词。对于玩家 2 的每一次猜测，程序都需要做出一个决定。我们声称这个猜测是未命中还是匹配？如果是匹配，猜测的字母出现在哪些位置？我的程序将保持一个不断减少的候选谜题单词列表，并在每次猜测后做出决定，以保留列表中尽可能多的单词。

# 悖我猜单词游戏所需的操作

现在我已经足够了解这个问题，可以创建我的子任务列表。在这样一个规模的问题中，在早期阶段制作的列表可能会遗漏一些操作。这是可以接受的，因为我的主要计划预计我不会第一次就创建一个完美的设计。

**存储并维护一个单词列表**。

这个程序必须有一个有效的英语单词列表。因此，程序将不得不从文件中读取单词列表，并以某种格式将它们存储在内部。在游戏过程中，随着程序的作弊，这个列表将被缩减或提取。

**创建给定长度的单词子列表**。

由于我的意图是维护候选谜底单词列表，我必须以玩家 2 指定的长度单词列表开始游戏。

**跟踪所选字母**。

程序需要记住哪些字母已被猜出，其中有多少是不正确的，以及对于被认为正确的字母，它们在谜底单词中的位置。

**计算不包含字母的单词数量**。

为了便于作弊，我需要知道列表中有多少单词不包含最近猜出的字母。请记住，程序将决定最近猜出的字母是否出现在谜底单词中，目的是在候选单词列表中留下尽可能多的单词。

**根据字母和位置确定单词数量最多的情况**。

这看起来是最棘手的操作。假设玩家 2 刚刚猜出字母*d*，当前游戏谜底单词长度为三个。也许当前的候选单词列表总共包含 10 个包含*d*的单词，但这并不重要，因为程序必须声明字母在谜底单词中的位置。让我们称单词中字母的位置为模式。所以*d??*是一个三字母模式，指定第一个字母是*d*，而其他两个字母可以是任何不是*d*的字母。考虑表 8-2。假设第一列中的列表包含程序所知的每个包含*d*的三字母单词。其他列根据模式分解这个列表。最频繁出现的模式是*??d*，有 17 个单词。这个数字，17，将与候选列表中不包含*d*的单词数量进行比较，以确定猜测是匹配还是失误。

**创建匹配特定模式的单词子列表**。

当程序宣布玩家 2 的猜测是匹配时，它将创建一个新的候选单词列表，其中只包含与所选字母模式匹配的单词。在先前的例子中，如果我们宣布*d*为匹配，表 8-2 的第三列将变成新的候选单词列表。

**继续玩游戏直到游戏结束**。

在所有其他操作就绪之后，我需要编写将一切粘合在一起并实际玩游戏的代码。程序应该反复请求玩家 2（用户）猜测，确定通过接受或拒绝该猜测来决定候选单词列表是否会变长，相应地减少单词列表，并显示结果谜题单词，包括任何正确猜测的字母，以及所有先前猜测的字母的回顾。这个过程将继续，直到游戏结束，由一方玩家获胜——我还需要弄清楚这些条件。

表 8-2. 三字母单词

| 所有单词 | ?dd | ??d | d?? | d?d |
| --- | --- | --- | --- | --- |
| add | add | aid | day | did |
| aid | odd | and | die |   |
| and |   | bad | doe |   |
| bad |   | bed | dog |   |
| bed |   | bid | dry |   |
| bid |   | end | due |   |
| day |   | fed |   |   |
| did |   | had |   |   |
| die |   | hid |   |   |
| doe |   | kid |   |   |
| dog |   | led |   |   |
| dry |   | mad |   |   |
| due |   | mod |   |   |
| end |   | old |   |   |
| fed |   | red |   |   |
| had |   | rid |   |   |
| hid |   | sad |   |   |
| kid |   |   |   |   |
| led |   |   |   |   |
| mad |   |   |   |   |
| mod |   |   |   |   |
| odd |   |   |   |   |
| old |   |   |   |   |
| red |   |   |   |   |
| rid |   |   |   |   |
| sad |   |   |   |   |

## 初始设计

尽管看起来之前的操作列表只是列出了一些原始事实，但设计决策正在被做出。考虑操作“创建一个匹配模式的单词子列表。”这个操作将出现在我的解决方案中，至少是这个初始版本，但严格来说，这根本不是一个*必需*的操作。同样，“创建给定长度的单词子列表”也不是。与其维护一个不断缩小的候选谜题单词列表，我可以在整个游戏中保持原始的单词主列表。但这将使大多数其他操作变得复杂。对于“计算不包含指定字母的单词数量”的操作，不能仅仅遍历候选谜题单词列表并计算所有不包含指定字母的单词。因为它将搜索主列表，所以它还必须检查每个单词的长度以及单词是否与谜题单词中到目前为止揭示的字母匹配。我认为我选择的路径总体上更容易，但我必须意识到，即使是这些早期的选择也在影响着最终的设计。

虽然在将问题分解为子任务之后，我还有其他决定要做。

**如何存储单词列表**

程序的关键数据结构将是单词列表，程序将在整个游戏中减少这个列表。在选择结构时，我观察到以下几点。首先，我相信我不需要随机访问列表中的单词，而是一直从前往后整体处理列表。第二，我不知道我需要的初始列表的大小。第三，我将会频繁地减少列表。第四，也是最后一点，标准`string`类的方法在这个程序中可能会很有用。将这些观察结果综合起来，我决定我的初始选择将是标准的模板`list`类，项目类型为`string`。

**如何跟踪猜测的字母**

被选中的字母在概念上是一个集合——也就是说，一个字母要么被选中，要么没有被选中，一个字母不能被选中超过一次。因此，这实际上是一个特定字母是否是“选中”集合的成员的问题。因此，我将选中的字母表示为一个大小为 26 的`bool`数组。如果数组命名为`guessedLetters`，那么`guessedLetters[0]`在游戏到目前为止被猜中时为 true，否则为 false；`guessedLetters[1]`用于*b*，以此类推。我将使用我们在整本书中一直在使用的范围转换技术，在大小写字母及其在数组中的对应位置之间进行转换。如果`letter`是一个表示小写字母的 char，那么`guessedLetters[letter - 'a']`就是相应的位置。

**如何存储模式**

我将要编写的操作之一，“创建匹配模式的单词子列表”，将使用单词中字母的位置模式。这个模式将由另一个操作产生，“根据字母和位置确定最大单词数”。那么我将使用什么格式来存储这些数据？模式是一系列代表特定字母出现位置的数字。我有许多方法可以存储这些数字，但我将保持简单，使用另一个`list`，这个`list`的项目类型为`int`。

**我是在写一个类吗？**

因为我在用 C++编写这个程序，我可以根据我的意愿使用面向对象编程，也可以不使用。我的第一个想法是，我列表中的许多操作可以自然地合并成一个类，比如叫做`wordList`，它有根据指定标准（即长度和模式）删除单词的方法。然而，因为我正在尝试避免做出我现在会后悔的设计决策，所以我将我的第一个、粗略而实用的程序完全做成过程式的。一旦我解决了程序的所有棘手方面，并且实际上为列表中的所有操作编写了代码，我将处于一个很好的位置来决定面向对象编程对于最终版本的可适用性。

## 初始编码

现在有趣的部分开始了。我启动了我的开发环境并开始工作。这个程序将使用标准库中的许多类，为了清晰起见，让我先设置好所有这些类：

```
#include <iostream>
using std::cin;
using std::cout;
using std::ios;
#include <fstream>
using std::ifstream;
#include <string>
using std::string;
#include <list>
using std::list;
using std::iterator;
#include <cstring>
```

现在我已经准备好开始编写我列表中的操作代码了。在某种程度上，我可以按任何顺序编写这些操作，但我打算从一个函数开始，该函数将读取一个包含单词的纯文本文件到我所选择的`list<string>`结构中。在这个时候，我意识到我需要找到一个现有的单词主文件——我不想自己输入。幸运的是，搜索“单词列表”揭示了许多网站，它们提供了以纯文本格式排列的英语单词列表，每个单词占文件的一行。我已经熟悉了在 C++中读取文本文件，但如果我不熟悉，我会编写一个小型测试程序，先练习这项技能，然后再将其集成到作弊的猜字游戏程序中，这种练习我在本章后面会讨论。

拿到文件后，我可以编写这个函数：

```
list<string> readWordFile(char * filename) {
   list<string> wordList;
 ifstream wordFile(filename, ios::in);
 if (wordFile == NULL) {
      cout << "File open failed. \n";
      return wordList;
   }
   char currentWord[30];
 while (wordFile >> currentWord) {
    if (strchr(currentWord, '\'') == 0) {
         string temp(currentWord);
         wordList.push_back(temp);
      }
   }
   return wordList;
}
```

这个函数很简单，所以我只会做几个简要的注释。如果你以前从未见过，一个`ifstream`对象 ![ifstream](http://atomoreilly.com/source/no_starch_images/1273182.png) 是一个输入流，它的工作方式就像`cin`一样，只不过它从文件而不是标准输入读取。如果构造函数无法打开文件（通常这意味着文件未找到），对象将是`NULL`，我会明确检查这一点 ![ifstream](http://atomoreilly.com/source/no_starch_images/1273191.png)。如果文件存在，它将在循环 ![ifstream](http://atomoreilly.com/source/no_starch_images/1273193.png) 中被处理，循环读取文件的每一行到一个字符数组中，将数组转换为`string`对象，并将其添加到`list`中。我最终使用的英语单词文件包含了带有撇号的单词，这些单词在我们的游戏中是不合法的，所以我明确排除了它们 ![ifstream](http://atomoreilly.com/source/no_starch_images/1273195.png)。

接下来，我编写了一个函数来显示我`list<string>`中的所有单词。这不在我的必需操作列表中，我也不会在游戏中使用它（毕竟，这只会帮助玩家 2，而我正试图欺骗他），但这是一个测试我的`readWordFile`函数是否正确工作的好方法：

```
void displayList(const list<string> & wordList) {
 list<string>::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      cout << iter->c_str() << "\n";
      iter++;
   }
}
```

这实际上是上一章中介绍的基本列表遍历代码。请注意，我已经将参数声明为`const`引用 ![图片](img/httpatomoreillycomsourcenostarchimages1273182.png)。因为列表在开始时可能相当大，所以将引用参数声明为`const`可以减少函数调用的开销，而值参数将不得不复制整个列表。将这个引用参数声明为`const`表示函数不会更改列表，这有助于代码的可读性。一个`const`列表需要一个`const`迭代器 ![图片](img/httpatomoreillycomsourcenostarchimages1273191.png)。`cout`流不能输出字符串对象，所以这个方法使用`c_str()`生成等效的空终止`char`数组 ![图片](img/httpatomoreillycomsourcenostarchimages1273193.png)。

我使用这个相同的基本结构来编写一个函数，该函数计算列表中不包含指定字母的单词数量：

```
int countWordsWithoutLetter(const list<string> & wordList, char letter) {
   list<string>::const_iterator iter;
   int count = 0;
   iter = wordList.begin();
   while (iter != wordList.end()) {
    if (iter->find(letter) == string::npos) {
         count++;
      }
      iter++;
   }
   return count;
}
```

如您所见，这是一个相同的基本遍历循环。在内部，我调用了`string`类的`find`方法 ![图片](img/httpatomoreillycomsourcenostarchimages1273182.png)，它返回其`char`参数在`string`对象中的位置，当字符未找到时返回特殊值`npos`。

我使用这个相同的基本结构来编写一个函数，该函数会移除我的单词列表中所有与指定长度不匹配的单词：

```
void removeWordsOfWrongLength(list<string> & wordList,
                              int acceptableLength)
{
   list<string>::iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter->length() != acceptableLength) {
       iter = wordList.erase(iter);
      } else {
       iter++;
      }
   }
}
```

这个函数是每个你编写的程序都是加深你对程序工作方式理解的机会的一个很好的例子。这个函数对我来说写起来很简单，因为我已经从之前编写的程序中理解了“幕后”发生了什么。这个函数使用了之前函数的基本遍历代码，但代码在循环内部变得有趣。`erase()`方法从一个`list`对象中移除由`iterator`指定的项。但根据我们在第七章中实现链表迭代器模式的经验，我知道`iterator`几乎肯定是一个指针。根据我们在第四章中的指针经验，我知道当它是一个指向已删除对象的悬挂引用时，指针是无用的，并且通常是危险的。因此，我知道我需要在这次操作后给`iter`赋一个有效值。幸运的是，`erase()`的设计者已经预料到这个问题，并有一个方法返回一个指向我们刚刚删除的项之后的项的新`iterator`，所以我可以将这个值赋回`iter` ![图片](img/httpatomoreillycomsourcenostarchimages1273182.png)。此外，请注意，我只在未从列表中删除当前字符串时显式前进`iter` ![图片](img/httpatomoreillycomsourcenostarchimages1273191.png)，因为`erase()`返回值的赋值实际上会前进`iterator`，我不想跳过任何项。

现在是困难的部分：在剩余的单词列表中找到指定字母的最常见模式。这是使用分解问题技术的一个机会。我知道这个操作的子任务之一是确定一个特定的单词是否与特定的模式匹配。记住，一个模式是一个`list<int>`，其中每个`int`代表字母在单词中出现的位置，并且为了使单词与模式匹配，不仅字母必须出现在单词中指定的位置，而且字母**不能**出现在单词的任何其他位置。有了这个想法，我将通过遍历字符串来测试字符串是否匹配；对于字符串中的每个位置，如果指定的字母出现，我将确保该位置在模式中，如果出现其他字母，我将确保该位置不在模式中。

为了使事情更加简单，我首先将编写一个单独的函数来检查特定的位置数字是否出现在模式中：

```
bool numberInPattern(const list<int> & pattern, int number) {
   list<int>::const_iterator iter;
   iter = pattern.begin();
   while (iter != pattern.end()) {
      if (*iter == number) {
         return true;
      }
      iter++;
   }
   return false;
}
```

基于之前的函数，这段代码相当简单编写。我只是遍历`list`，寻找`number`。要么我找到它并返回`true`，要么我到达列表的末尾并返回`false`。现在我可以实现通用的模式匹配测试：

```
bool matchesPattern(string word, char letter, list<int> pattern) {
   for (int i = 0; i < word.length(); i++) {
      if (word[i] == letter) {
         if (!numberInPattern(pattern, i)) {
            return false;
         }
      } else {
         if (numberInPattern(pattern, i)) {
            return false;
         }
      }
   }
   return true;
}
```

如您所见，这个函数遵循了之前概述的计划。对于字符串中的每个字符，如果它与`letter`匹配，代码将检查当前位置是否在模式中。如果字符不匹配`letter`，代码将检查该位置是否不在模式中。如果单个位置不匹配模式，则单词将被拒绝；否则，单词的末尾将被达到，单词将被接受。

在这个阶段，我突然想到，如果列表中的每个单词都包含指定的字母，那么找到最频繁出现的模式将会更容易。因此，我快速编写了一个函数来删除不包含该字母的单词：

```
void removeWordsWithoutLetter(list<string> & wordList,
                               char requiredLetter) {
   list<string>::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter->find(requiredLetter) == string::npos) {
         iter = wordList.erase(iter);
      } else {
         iter++;
      }
   }
}
```

这段代码只是之前函数中用到的想法的组合。现在我想起来，我还需要一个相反的函数，一个可以删除所有包含指定字母的单词的函数。当程序在调用最新的猜测失败时，我将使用这个函数来减少候选单词列表。

```
void removeWordsWithLetter(list<string> & wordList, char forbiddenLetter) {
   list<string>::const_iterator iter;
   iter = wordList.begin();
   while (iter != wordList.end()) {
      if (iter->find(forbiddenLetter) != string::npos) {
         iter = wordList.erase(iter);
      } else {
         iter++;
      }
   }
}
```

现在，我准备找到给定字母在单词列表中最频繁出现的模式。我考虑了多种方法，并选择了我认为最容易实现的方法。首先，我将调用上面的函数来删除所有不包含指定字母的单词。然后，我将取列表中的第一个单词，确定其模式，并计算列表中有多少其他单词具有相同的模式。在计数时，所有这些单词都将从列表中删除。然后，这个过程将再次使用现在列表头部的单词重复进行，等等，直到列表为空。结果看起来像这样：

```
void mostFreqPatternByLetter(list<string> wordList, char letter,
                             list<int> & maxPattern,
                             int & maxPatternCount) {
 removeWordsWithoutLetter(wordList, letter);
   list<string>::iterator iter;
   maxPatternCount = 0;
 while (wordList.size() > 0) {
      iter = wordList.begin();
      list<int> currentPattern;
    for (int i = 0; i < iter->length(); i++) {
         if ((*iter)[i] == letter) {
            currentPattern.push_back(i);
         }
      }
      int currentPatternCount = 1;
      iter = wordList.erase(iter);
    while (iter != wordList.end()) {
         if (matchesPattern(*iter, letter, currentPattern)) {
            currentPatternCount++;
            iter = wordList.erase(iter);
         } else {
            iter++;
         }
      }
    if (currentPatternCount > maxPatternCount) {
         maxPatternCount = currentPatternCount;
         maxPattern = currentPattern;
      }
      currentPattern.clear();
   }
}
```

`list`作为值参数传入![图片链接](http://atomoreilly.com/source/no_starch_images/1273182.png)，因为这个函数在处理过程中会将列表缩减为空，我不想影响调用代码传递的参数。注意，`maxPattern`![图片链接](http://atomoreilly.com/source/no_starch_images/1273191.png)和`maxPatternCount`![图片链接](http://atomoreilly.com/source/no_starch_images/1273193.png)仅作为输出参数；这些将被用来将最常出现的模式和它的出现次数发送回调用代码。我移除了所有没有`letter`![图片链接](http://atomoreilly.com/source/no_starch_images/1273195.png)的单词。然后我进入函数的主循环，只要列表不为空![图片链接](http://atomoreilly.com/source/no_starch_images/1273197.png)，循环就会继续。循环内的代码有三个主要部分。首先，一个`for`循环构建列表中第一个单词的模式![图片链接](http://atomoreilly.com/source/no_starch_images/1273203.png)。然后，一个`while`循环计算列表中有多少单词与该模式匹配![图片链接](http://atomoreilly.com/source/no_starch_images/1273203.png)。最后，我们看到这个计数是否大于迄今为止看到的最高的计数，采用“山丘之王”策略，这是在第三章![图片链接](http://atomoreilly.com/source/no_starch_images/1273223.png)中首次出现的。

我还需要最后一个实用函数来显示迄今为止猜测的所有字母。记住，我将它们存储为一个包含 26 个`bool`值的数组：

```
void displayGuessedLetters(bool letters[26]) {
   cout << "Letters guessed: ";
   for (int i = 0; i < 26; i++) {
      if (letters[i]) cout << (char)('a' + i) << " ";
   }
   cout << "\n";
}
```

注意，我在一个范围的基值（在这种情况下是字符`a`）和一个来自另一个范围的值![图片链接](http://atomoreilly.com/source/no_starch_images/1273182.png)上添加了基值，这是一种我们在第二章中首次使用的技巧。

现在我已经完成了所有的关键子任务，我准备尝试解决整个问题，但我这里有很多函数还没有经过完全测试，我希望它们能尽快得到测试。所以，与其一步解决剩余的问题，我打算简化这个问题。我会通过将一些变量，比如拼图单词的大小，变成常量来实现这一点。

因为我会丢弃这个版本，所以我愿意把整个游戏逻辑放入`main`函数中。尽管如此，由于结果很长，我打算分阶段展示代码。

```
int main () {
 list<string> wordList = readWordFile("wordlist.txt");
   const int wordLength = 8;
   const int maxMisses = 9;
 int misses = 0;
 int discoveredLetterCount = 0;
 removeWordsOfWrongLength(wordList, wordLength);
 char revealedWord[wordLength + 1] = "********";
 bool guessedLetters[26];
   for (int i = 0; i < 26; i++) guessedLetters[i] = false;
 char nextLetter;
   cout << "Word so far: " << revealedWord << "\n";
```

这段代码的第一部分设置了我们玩游戏所需的常量和变量。大部分代码都是自解释的。单词列表是从文件 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png) 中创建的，然后根据指定的单词长度进行了缩减，在这个例子中是常量值 8 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。变量`misses` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png) 存储玩家 2 的错误猜测次数，而`discoveredLetterCount` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png) 跟踪单词中已揭示的位置数（如果*d*出现两次，猜测*d*会使此值增加两）。`revealedWord`变量存储玩家 2 目前所知的谜题单词，未猜测的字母用星号表示 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273197.png)。`guessedLetters`数组中的`bool` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273199.png) 跟踪到目前为止猜测的特定字母；一个循环将所有值设置为`false`。最后，`nextLetter` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273203.png) 存储玩家 2 的当前猜测。我输出了初始的`revealedWord`，然后我就准备好进入主游戏循环了。

```
 while (discoveredLetterCount < wordLength && misses < maxMisses) {
     cout << "Letter to guess: ";
     cin >> nextLetter;
   guessedLetters[nextLetter - 'a'] = true;
   int missingCount = countWordsWithoutLetter(wordList, nextLetter);
     list<int> nextPattern;
     int nextPatternCount;

mostFreqPatternByLetter(wordList, nextLetter, nextPattern, nextPatternCount);
     if (missingCount > nextPatternCount) {
      removeWordsWithLetter(wordList, nextLetter);
        misses++;
     } else {
      list<int>::iterator iter = nextPattern.begin();
        while (iter != nextPattern.end()) {
           discoveredLetterCount++;
           revealedWord[*iter] = nextLetter;
           iter++;
        }
        wordList = reduceByPattern(wordList, nextLetter, nextPattern);
     }
     cout << "Word so far: " << revealedWord << "\n";
     displayGuessedLetters(guessedLetters);
  }
```

游戏结束有两种条件。要么玩家 2 发现了单词中的所有字符，使得`discoveredLetterCount`达到`wordLength`，要么玩家 2 的错误猜测完成了吊死人的游戏，在这种情况下`misses`将等于`maxMisses`。因此，只要这两个条件中的任何一个没有发生，循环就会继续 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)。在循环内部，在从用户那里读取下一个猜测之后，`guessedLetters`中的相应位置会被更新 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png)。然后就开始作弊了。程序会确定如果猜测被宣布为失误，单词列表中会剩下多少候选词，使用`countWordsWithoutLetter` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png)，并且确定如果猜测被宣布为命中，最多会剩下多少，使用`mostFreqPatternByLetter` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。如果前者更大，就会淘汰包含猜测字母的单词，并将`misses`增加 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273197.png)。如果后者更大，我们会采用`mostFreqPatternByLetter`给出的模式，并更新`revealedWord`，同时从列表中移除所有不匹配该模式的单词 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273199.png)。

```
if (misses == maxMisses) {
      cout << "Sorry. You lost. The word I was thinking of was '";
      cout << (wordList.cbegin())->c_str() << "'.\n";
   } else {
      cout << "Great job. You win. Word was '" << revealedWord << "'.\n";
   }
   return 0;
}
```

代码的其余部分是我所说的“循环后事分析”，其中循环后的动作由“杀死”循环的条件决定。在这里，要么我们的程序成功地欺骗了胜利，要么玩家 2 在所有不利的情况下迫使程序揭示整个单词。请注意，当程序获胜时，列表中至少必须保留一个单词，所以我只显示第一个单词 ![更多](http://atomoreilly.com/source/no_starch_images/1273182.png) 并声称这是我一直在想的。一个更狡猾的程序可能会随机选择剩余单词中的一个，以减少对手发现作弊的机会。

## 初始结果分析

我已经把这些代码组合起来并测试了，它确实工作，但显然还有很多改进的空间。除了任何设计考虑之外，程序缺少很多功能。它不允许用户指定谜题单词的大小或允许的错误猜测次数。它不检查猜测的字母是否已经被猜测过。就这一点而言，它甚至不检查输入字符是否是小写字母。它缺少很多界面上的礼貌，比如告诉用户还有多少次未命中。我认为如果程序能提供再次玩的机会，而不是让用户重新运行程序，那也会很好。

关于设计，当我开始思考程序的最终版本时，我会认真考虑面向对象的设计。现在看起来`wordlist`类似乎是一个自然的选择。在我看来，主函数看起来太大。我喜欢模块化、易于维护的设计，这应该会导致一个短小且仅指导子程序之间交通的主函数。因此，我的主函数需要分解成几个函数。我的一些初始设计选择可能需要重新思考。例如，事后看来，将模式存储为`list<int>`看起来很繁琐。也许我可以尝试一个`bool`数组，类似于`guessedLetters`？

或者，也许我应该寻找另一种完全不同的结构。现在也是我退后一步看看是否有机会学习解决这个问题的新的技术的时候了。我在想是否有我尚未考虑的专门的数据结构可能是有帮助的。即使我最终坚持我的原始选择，我也可以从调查中学习很多。

尽管所有这些决定仍然悬而未决，但我感觉我在这个项目上已经取得了很大的进展。拥有一个满足问题基本要求的可工作程序是一个很好的起点。我可以轻松地在这个粗糙版本中尝试不同的设计想法，因为我已经知道我有一个解决方案，我只是在寻找更好的解决方案。

创建一个恢复点

微软 Windows 操作系统在安装或修改系统组件之前会创建它所说的*恢复点*。恢复点包含关键文件的备份副本，例如注册表。如果安装或更新导致严重问题，可以通过从恢复点复制文件来有效地“回滚”或撤销。

我强烈建议你对自己的源代码采取同样的方法。当你有一个你预期以后要修改的工作程序时，复制整个项目，只修改副本。这样做很快，如果你的修改出了问题，可以节省你大量的时间。程序员很容易陷入这样的陷阱，认为：“我完成过这个；因此，我可以再次完成它。”这通常是正确的，但知道你可以再次做某事和能够立即引用旧源代码之间有很大的区别。

你也可以使用*版本控制软件*，它自动复制和存储项目文件。版本控制软件的功能不仅限于“恢复点”功能；它还可能允许多个程序员独立地在同一文件上工作，例如。虽然这些工具超出了本书的范围，但作为程序员的发展过程中，你应该调查这些工具。

## 问题解决的艺术

你是否认识到了我在迄今为止的解决方案中使用的所有问题解决技巧？我有一个解决问题的计划。一如既往，这是所有问题解决技巧中最关键的。我决定从我的解决方案的第一版开始，使用我非常熟悉的一些数据结构，即数组和`list`类。我将功能简化，以便更容易编写我的草稿版本，并允许我比其他情况下更早地测试我的代码。我将问题分解为操作，并将每个操作变成一个不同的函数，这样我可以单独处理程序的各个部分。当我不确定如何作弊时，我会进行实验，这样我可以将“作弊”重新定义为“最大化候选单词列表的大小”，这对我来说是一个具体的编码概念。在具体编码操作时，我使用了本书中使用的类似技术。

我也成功地避免了感到沮丧，尽管我想你可能得相信我的话。

在我们继续之前，让我明确一点，我已经展示了我在解决这个问题的过程中所采取的步骤**我**达到这个阶段。这些步骤不一定是你解决这个问题的步骤。上面显示的代码并不是解决问题的最佳方案，也不一定比你想到的方案更好。我希望它展示的是，任何问题，无论大小，都可以使用本书中贯穿始终的基本技术的变体来解决。如果你面临的是一个比这个大两倍或十倍的问题，这可能会考验你的耐心，但你仍然可以解决它。

# 学习新的编程技能

还有另一个话题需要讨论。在掌握本书的问题解决技巧的过程中，你正在走上程序员生涯的关键一步。然而，与大多数职业一样，这是一条没有终点的路，因为你必须始终努力成为一个更好的程序员。与编程中的其他一切一样，你应该有一个计划，说明你将如何学习新的技能和技术，而不仅仅是相信你会在路上点点滴滴地学到新东西。

在本节中，我们将讨论你可能想要掌握的新技能的一些领域，以及每个领域的系统方法。贯穿所有这些领域的共同线索是，你必须将你想要学习的内容付诸实践。这就是为什么本书的每一章都以练习结束——你一直在做这些练习，对吧？阅读有关编程的新思想是真正学习它们的必要第一步，但仅仅是一步。为了达到能够自信地在一个现实世界问题的解决方案中应用新技术的水平，你应该首先在一个较小的、合成的练习中尝试这个技术。记住，我们基本的问题解决技术之一是将复杂问题分解，通过分割问题或暂时减少问题，使得我们处理的每个状态只有一个非平凡元素。你不想在学习将是你解决方案核心的技能的同时尝试解决一个非平凡问题，因为那样你的注意力将分散在两个困难的问题上。

## 新的语言

我认为 C++是一种非常适合生产代码的编程语言，我在第一章中解释了为什么我认为它也是一种非常适合学习的语言。话虽如此，没有一种编程语言在所有情况下都是优越的；因此，优秀的程序员必须学习几种。

### 投资时间学习

在可能的情况下，你应该在尝试用一种新语言编写生产代码之前给自己留出时间来学习这种新语言。如果你尝试解决一个你从未使用过的语言中的非平凡问题，你很快就会违反一个重要的解决问题的规则：避免挫败感。给自己设定一个学习一种语言的任务，并在你给自己分配任何“真实”程序之前完成这个任务。

当然，在现实世界中，有时我们并不完全控制我们被分配项目的时间。在任何时候，都可能有人要求我们用特定的语言编写程序，并且这个请求可能伴随着一个截止日期，这将阻止我们在解决实际问题之前悠闲地学习这种语言。最好的防御措施是在你绝对需要知道它们之前就开始学习其他编程语言。调查那些引起你兴趣的语言或那些你预期在职业生涯中编程的领域的语言。这是另一种情况，在短期内看似浪费时间的行为，在长期内会带来巨大的回报。即使最终你不需要你近期学习过的语言，学习另一种语言也可以提高你对其他已知语言的技能，因为它迫使你以新的和不同的方式思考，帮助你摆脱旧习惯，并从新的角度看待你的技能和技术。把它看作是编程的交叉训练。

### 从你所知开始

当你开始学习一种新的编程语言时，按照定义，你对它一无所知。如果你不是第一次学习编程语言，那么你对编程的了解就很多了。因此，学习新语言的一个好步骤是理解你已经在另一种语言中知道如何编写的代码如何在新的语言中编写。

如前所述，你想要通过实践来学习，而不仅仅是通过阅读。将你在其他语言中编写的程序重写在新语言中。系统地调查单个语言元素，例如控制语句、类、其他数据结构等。目标是尽可能地将你之前的知识转移到新语言中。

### 调查不同之处

下一步是研究新语言的不同之处。虽然两种高级编程语言可能有很多相似之处，但新语言中**肯定**有一些不同之处，否则就没有理由选择这种语言而不是其他语言。再次强调，通过实践来学习。例如，仅仅阅读一个语言的多个选择语句允许范围（而不是 C++ `switch`语句的单独值）并不如实际编写代码来有意义地使用这种能力对你有所帮助。

这一步对于明显不同的语言来说显然很重要，但对于有共同祖先的语言来说同样重要，例如 C++、C#和 Java，它们都是 C 的面向对象的后代。语法相似性可能会让你误以为你对新语言了解得比你实际了解的要多。考虑以下代码：

```
integerListClass numberList;
numberList.addInteger(15);
```

如果这些行被展示给你作为 C++代码，你会理解第一行创建了一个名为`numberList`的对象，属于`integerListClass`类，而第二行在对象上调用了一个`addInteger`方法。如果这个类实际上存在并且有一个同名的方法接受`int`参数，那么这段代码是完美的。现在假设我告诉你这段代码是用 Java 而不是 C++编写的。从语法上讲，这两行没有非法之处。然而，在 Java 中，仅仅声明一个类对象并不实际构造对象，因为对象变量实际上是引用——也就是说，它们的行为类似于指针。要在 Java 中执行等效步骤，正确的代码将是：

```
integerListClass numberList = new integerListClass;
numberList.addInteger(15);
```

你可能会很快注意到 Java 和 C++之间的这个特定差异，但许多其他差异可能相当微妙。如果你不花时间去发现它们，它们会在新语言中使调试变得非常困难。当你扫描代码时，你的内部编程语言解释器会给你提供关于你所阅读内容的错误信息。

### 研究编写良好的代码

我在这本书中一直强调，你不应该通过修改别人的代码来学习编程。然而，有时候研究别人的代码是至关重要的。虽然你可以通过编写一系列原创程序来提高你在新语言中的技能，但要达到精通的水平，你将需要寻找由精通该语言的程序员编写的代码。

你不是在寻找“抄袭”这段代码；你不是要借用这段代码来解决特定问题。相反，你是在查看现有代码，以发现该语言的“最佳实践”。看看专家程序员的代码，并问问自己，程序员不仅在做**什么**，而且在做**为什么**。如果代码附有程序员的解释，那就更好了。区分风格选择和性能优势。通过完成这一步，你将避免一个常见的陷阱。程序员往往只学会足够的新语言知识来生存，结果是代码薄弱，没有使用语言的所有功能。例如，如果你是一个需要用 Java 编写代码的 C++程序员，你不想满足于用 pidgin C++编写代码；相反，你想要学会像 Java 程序员一样编写实际的 Java 代码。

就像其他所有事情一样，将你学到的知识付诸实践。将原始代码修改成做些新的事情。将代码放在一边，尝试重新生成它。目标是让你对代码足够熟悉，以至于你可以回答其他程序员关于它的问题。

需要强调的是，这一步骤是在其他步骤之后进行的。在我们达到在新的语言中研究他人代码的阶段之前，我们已经在新的语言中学习了语法和语法，并将我们在另一种语言中学到的解决问题的技能应用到新的语言中。如果我们试图通过从研究长程序样本和修改这些样本开始学习新的语言来缩短这个过程，那么我们真的有风险只能做到这一点。

## 已知语言的新技能

只因为你达到了可以说你“知道”一门语言的程度，并不意味着你了解这门语言的所有内容。即使你已经掌握了这门语言的语法，也总会有新的方法来组合现有的语言特性以解决问题。这些新方法中的大多数都将属于前一章中提到的“组件”标题下的某个类别，我们在其中讨论了如何构建组件知识。重要的因素是努力。一旦你擅长以某种方式解决问题，就很容易依赖你已经知道的知识，停止作为程序员的成长。到了那个阶段，你就像一个只会投掷强力快球的棒球投手，却不知道如何投掷其他类型的球。有些投手只凭借一个球就能在职业生涯中取得成功，但那些想要从替补投手转变为首发投手的投手则需要更多。

要成为最好的程序员，你需要寻求新的知识和新的技术，并将它们付诸实践。寻找挑战并克服它们。研究你选择的语言的专家程序员的成果。

记住，需求是发明之母。寻找那些无法用你当前技能集满意解决的问题。有时你可以修改你已经解决的问题，以提供新的挑战。例如，你可能已经编写了一个当数据集较小时运行良好的程序，但当你允许数据增长到巨无霸规模时会发生什么？或者如果你已经编写了一个将数据存储在本地硬盘上的程序，但你希望数据被远程存储呢？或者当你需要程序的多重执行，这些执行可以同时访问和更新远程数据时会发生什么？通过从工作程序开始并添加新功能，你可以专注于编程的新方面。

## 新的库

现代编程语言与它们的内核库密不可分。当你学习 C++时，你不可避免地会了解一些关于标准模板库的知识，例如，当你学习 Java 时，你会了解标准 Java 类。然而，除了语言捆绑的库之外，你还需要学习第三方库。有时这些是通用应用程序框架，如微软的.NET 框架，它可以与几种不同的高级语言一起使用。在其他情况下，库是特定于某个特定领域的，如 OpenGL 用于图形，或者它是第三方专有软件包的一部分。

就像学习一门新语言一样，你不应该在需要该库的重大项目中学习一个新的库。相反，在将它们用于实际项目之前，你应该在一个零重要性的测试项目中单独学习库的主要组件。为自己设定一个越来越困难的解决问题的进度。记住，目标不一定是要完成任何这些问题，而是要从过程中学习，因此你不需要完善解决方案，甚至在你成功将库的这部分应用于你的程序后，也不需要完成它们。这些程序可以作为以后工作的参考。当你发现自己因为无法记住如何，比如说，在 OpenGL 中将 2D 显示叠加到 3D 场景中而陷入困境时，没有什么比打开一个专门为了演示那种技术而创建的旧程序更好了，因为这个程序是用你自己的风格编写的，因为它是由你编写的。

此外，就像学习一门新语言一样，一旦你熟悉了一个库的基本用法，你应该回顾一下那些在该库使用方面有经验的专家所编写的代码。大多数大型库都有一些官方文档没有暴露的特性和注意事项，这些只有在长期经验中才能从其他程序员那里发现。实际上，要深入理解某些库，可能需要使用其他程序员提供的框架。重要的是不要过度依赖他人的代码，而应尽快达到重新创建最初展示给你的代码的阶段。你可能会惊讶于从重新创建他人现有代码的过程中学到了多少东西。你可能会在原始代码中看到对库函数的调用，并理解这个调用中传递的参数产生了某种结果。然而，当你把这段代码放一边，并试图在自己的程序中重现那种效果时，你将不得不调查该函数的文档、所有可能的参数值以及为什么它们必须是这样的才能得到期望的效果。

## 上课

作为一名长期的教育工作者，我觉得我必须通过谈论课程来结束这一部分——不是在面向对象编程的意义上，而是在学校课程的意义上。无论你想学习编程的哪个领域，你都会找到有人愿意教你，无论是在传统的教室里还是在某种在线环境中。然而，课程是学习的催化剂，而不是学习本身，尤其是在编程这样的领域。无论编程讲师多么博学或热情，当你真正学习新的编程技能时，这将在你坐在电脑前发生，而不是你坐在讲堂里。正如我在整本书中反复强调的那样，你必须将编程思想付诸实践，你必须使它们成为你自己的，才能真正学会它们。

这并不是说课程没有价值——因为它们通常具有巨大的价值。编程中的一些概念本质上是难以理解或令人困惑的，如果你有机会接触到擅长解释复杂概念的讲师，这可能为你节省大量时间和挫折。此外，课程提供了对你学习的评估。如果你有幸遇到一位优秀的讲师，你可能可以从对你的代码的评估中学到很多东西，这将简化学习过程。最后，课程的顺利完成为当前或未来的雇主提供了一些证据，表明你理解所教授的主题（如果你不幸遇到一位糟糕的讲师，你至少可以从中得到安慰）。

只需记住，你的编程教育是你的责任，即使你参加了一门课程。课程会提供一个框架，让你在学期结束时获得成绩和学分，但这个框架并不限制你的学习。把你在课堂上的时间看作是一个极好的机会，尽可能多地了解这门学科，而不仅仅是课程大纲中列出的任何目标。

# 结论

我深情地回忆起我的第一次编程经历。我编写了一个简短的基于文本的弹球机模拟，不，这对我来说也没有什么意义，但当时肯定有。那时我并没有电脑——1976 年谁有呢？——但在我的父亲的办公室里有一台电传打字机终端，本质上是一个巨大的点阵打印机，带有咔哒咔哒的键盘，通过声学调制解调器与当地大学的计算机主机通信。（你用手拨打电话，当你听到电子尖叫时，你就把听筒放入连接到终端的特殊托架上。）尽管我的弹球机模拟既原始又无意义，但当程序运行起来，计算机按照我的指令行动时，我就上瘾了。

那天我有的感觉——一台计算机就像一个无限的乐高积木堆、Erector Sets 和林肯积木，所有这些都可以用来构建我能想象到的一切——这就是推动我对编程热爱的原因。当我的开发环境宣布构建成功，我的手指触摸到按键开始执行我的程序时，我总是既兴奋又焦虑，期待着成功或失败的结果，渴望看到我的努力成果，无论是编写一个简单的测试项目，还是在大型解决方案上完成最后的润色，或者我是在创建美丽的图形，还是在构建数据库应用程序的前端。

我希望你在编程时也有类似的感受。即使你还在这本书涵盖的一些领域挣扎，我也希望你现在明白，只要编程让你如此兴奋，你总是想坚持下去，就没有你解决不了的问题。所需要的只是愿意付出努力，并且以正确的方式处理这个过程。时间会解决剩下的问题。

你是否已经像程序员一样思考了？如果你已经解决了这些章节末尾的练习题，那么你应该像程序员一样思考，并且对自己的问题解决能力有信心。如果你没有解决很多练习题，那么我有一个建议给你，我敢打赌你能猜到是什么：解决更多的练习题。如果你在之前的章节中跳过了一些练习，不要从这一章的练习开始——回到你停止的地方，从那里继续前进。如果你不想做更多的练习，因为你不喜欢编程，那么我帮不上忙。

一旦你开始像程序员一样思考，就为你的技能感到自豪。如果有人称你为码农而不是程序员，可以说一个受过良好训练的鸟儿可以被训练出来敲代码——你不仅仅是写代码，你使用代码来解决问题。当你坐在面试桌对面，面对未来的雇主或客户时，你会知道无论工作需要什么，你都能找到解决办法。

# 练习

你肯定知道会有最后一组练习。当然，这些练习比之前章节中的任何练习都更具挑战性和开放性。

1.  为作弊猜字游戏问题编写一个比我的更好的完整实现。

1.  扩展你的猜字游戏程序，让用户可以选择成为玩家 1。用户仍然可以选择单词中的字母数量和未猜中的猜测次数，但程序负责猜测。

1.  将你的猜字游戏程序用另一种你目前几乎一无所知或知之甚少的语言重写。

1.  使你的“猜字谜”游戏具有图形化，实际上显示绞刑架和正在被建造的绞刑犯。你试图像程序员一样思考，而不是像艺术家一样，所以不要担心艺术的质量。你必须制作一个真正的图形程序。不要用 ASCII 文本绘制绞刑犯——那太简单了。你可能想调查 C++的 2D 图形库，或者选择一个一开始就更具图形导向的平台，比如 Flash。拥有一个图形化的“猜字谜”可能需要限制错误猜测的数量，但可能有一种方法可以至少提供这个数字的选择范围。

1.  设计你自己的练习：运用你在“猜字谜”问题中学到的技能来解决一些完全不同的问题，这些问题涉及到操作单词列表，例如另一个使用单词的游戏——比如拼字游戏、拼写检查器，或者你想得到的任何其他东西。

1.  设计你自己的练习：寻找一个 C++编程问题，其规模或难度如此之大，以至于你确信你曾经认为凭借你的技能解决它是不可行的，然后解决它。

1.  设计你自己的练习：寻找一个你感兴趣但尚未在程序中使用过的库或 API。然后调查那个库或 API，并在一个有用的程序中使用它。如果你对通用编程感兴趣，可以考虑 Microsoft .NET 库或开源数据库库。如果你喜欢底层图形，可以考虑 OpenGL 或 DirectX。如果你想尝试制作游戏，可以考虑像 Ogre 这样的开源游戏引擎。考虑你想编写的程序类型，找到一个合适的库，然后着手去做。

1.  设计你自己的练习：为一个新的平台（对你来说是新的）编写一个有用的程序——例如，移动或网页编程。
