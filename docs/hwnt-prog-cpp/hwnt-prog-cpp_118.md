# 第二部分：提示

**提示 1**：在铁路的早期，他们在铁轨交叉的地方遇到了火车相撞的问题。因此，他们通过了一项法律：

+   当两列火车在铁轨交叉的地方相遇时，双方都应停车，并保持停车状态，直到另一列火车通过。

+   (答案 24。)

**提示 2**：UNIX 使用 <换行符> 来结束行。Microsoft Windows 使用 <回车符><换行符>。(答案 5。)

**提示 3**：该语句：

```
        if (n2 =! 0)

```

除非它的任务是让你困惑，否则它没有在履行其职责，在这种情况下，它做得非常出色。(下一条提示 82。答案 25。)

**提示 4**：构造函数正确地初始化了魔法数字。或者如果它被调用的话。但众所周知，没有调用构造函数就无法创建变量。嗯，几乎每个人都知道。(下一条提示 300。答案 98。)

**提示 5**：简单宏和参数化宏之间有什么区别？(答案 113。)

**提示 6**：操作系统调用很昂贵。(答案 96。)

**提示 7**：无符号字符权限

(下一条提示 313。答案 11。)

**提示 8**：树木外科医生定律：不要砍掉你站着的树枝。(下一条提示 317。答案 75。)

**提示 9**：该程序在复杂指令集机器（如 80x86 CPU）上不会失败，但在 RISC 机器（如 Sparcs）上会失败。它还在 Celerity 1000 ^([1]), 我就是在那里找到问题的。(下一条提示 143。答案 52。)

**提示 10**：这个程序一次读取一个字符的数据。它本应一次写入一个字符的数据。(下一条提示 102。答案 99。)

**提示 11**：当程序员尝试设置调试变量时，他会收到错误信息：

```
        debugging -- no such variable or class

```

(下一条提示 105。答案 84。)

**提示 12**：检查预处理器输出。(答案 82。)

**提示 13**：g++ 编译器发出警告：

```
        var.cpp: In function 'int main()':
        var.cpp:14: warning: unused variable 'bool remove'
        var.cpp:16: warning: the address of 'int remove(const char*)', will always be
           'true'

```

(答案 35。)

**提示 14**：优化器可以随意对你的代码进行游戏。(下一条提示 114。)

**提示 15**：结果是系统相关的。(下一条提示 278。答案 63。)

**提示 16**：M_PI 是正确的，但打印的结果是错误的。(下一条提示 170。答案 10。)

**提示 17**：逗号操作符返回第二个表达式的结果。所以表达式 5,9 的值是 9。(下一条提示 348。答案 86。)

**提示 18**：你不能。(下一条提示 344。答案 80。)

**提示 19**：printf 函数迷失了方向，开始编造东西。(下一条提示 31。答案 85。)

**提示 20:** 循环体执行的次数可能比你想象的要少。（下一提示 36。答案 89。）

**提示 21:** 如果你使用 MS-DOS，结果取决于内存模型。（下一提示 130。答案 21。）

**提示 22:** 失败是系统依赖的。（下一提示 9。答案 52。）

**提示 23:** 当何时调用 true_name 的析构函数？何时使用字符串？（答案 30。）

**提示 24:** 在调用 tmp_name 和使用结果之间调用更多函数，你得到坏结果的可能性就越大。（下一提示 85。答案 18。）

**提示 25:** C++ 只部分是类型安全的。（下一提示 63。答案 7。）

**提示 26:** 静态数据是危险的。（答案 100。）

**提示 27:** 需要的资源：资源 1，资源 2 - 或者是资源 2，资源 1？（下一提示 1。答案 24。）

**提示 28:** 通过预处理器运行程序。（下一提示 327。答案 29。）

**提示 29:** 循环执行了多少次？（下一提示 20。答案 89。）

**提示 30:** Borland 编译器允许你在编译时定义字符变量的默认值是 signed 还是 unsigned。（下一提示 60。答案 8。）

**提示 31:** C 不对 printf 调用进行参数检查。（下一提示 277。答案 85。）

**提示 32:** 答案取决于谁编写了你的堆管理库。 (答案 77。)

**提示 33:** 通过预处理器运行程序并查看结果。（下一提示 179。答案 105。）

**提示 34:** 结果是：

```
        11072   12627   16262
        3157    3664    5034
        13605   16307   22366

```

（下一提示 158。答案 53。）

**提示 35:** 预处理器语法不是 C++ 语法。（下一提示 284。答案 82。）

**提示 36:** 计算完结果后我们怎么办？（下一提示 152。答案 89。）

**提示 37:** 任何编写 i++++ 的人都应该被枪毙。（下一提示 272。答案 87。）

**提示 38:** 语句：

```
            counter = = 10;

```

是一个有效的 C++ 语句。它不做任何事情，但它有效。 （下一提示 205。答案 112。）

**提示 39:** 你能精确地将 1/3 表示为小数吗？计算机能否精确地将 0.1 表示为浮点数？（两者的答案相同。） (答案 107。)

**提示 40:** 问题出在更早的行，而不是第 16 行。（下一提示 346。答案 79。）

**提示 41:** 高度从未被分配为 2。（下一提示 78。答案 62。）

**提示 42:** 字典文件是按字母顺序排列的。（下一提示 311。答案 74。）

**提示 43**：_an_array.operator = (an_array)_ 做什么？(答案 75.)

**提示 44**：缩进不正确。(下一个 提示 156. 答案 31.)

**提示 45**：g++ 编译器输出警告：

```
        semi.cpp: In function 'int main()':
        semi.cpp:15: warning: statement with no effect

```

(下一个 提示 35. 答案 82.)

**提示 46**：所见即所得——字面意思。 (下一个 提示 307. 答案 69.)

**提示 47**：输出是：

```
        One million 1

```

(下一个 提示 59. 答案 44.)

**提示 48**：函数调用结束时缓冲区会发生什么？(答案 83.)

**提示 49**：编译器可以决定一些多部分语句的执行顺序。(答案 26.)

**提示 50**：此程序不会生成编译器警告。(下一个 提示 318. 答案 20.)

**提示 51**：两个问题与结构体数据中放置的内容有关。(我知道这使总数达到四个，但有一个同时属于这两个类别。) (答案 71.)

**提示 52**：你知道这个提示应该是什么，不是吗？(下一个 提示 207. 答案 42.)

**提示 53**：我们有两个函数在无限递归中相互调用结果。因为只有三个成员函数，所以应该不难找出哪些函数导致了问题。(下一个 提示 125. 答案 12.)

**提示 54**：运算符优先级。(答案 49.)

**提示 55**：我不知道你可以在 C++ 数字中放置逗号。(下一个 提示 335. 答案 44.)

**提示 56**：delete 在哪里被调用？(答案 32.)

**提示 57**：双精度是 64 位。C 标准是将所有浮点运算都在双精度下进行。

所有这些都与问题无关。(顺便说一句，从 64 位浮点格式中获取 64 位分数是一个巧妙的方法。) (下一个 提示 94. 答案 73.)

**提示 58**：0d 是回车符的 ASCII 码。(下一个 提示 234. 答案 5.)

**提示 59**：g++ 编译器发出警告：

```
        comma.cpp: In function 'int main()':
        comma.cpp:12: warning: left-hand operand of comma expression has no effect

```

(下一个 提示 126. 答案 44.)

**提示 60**：g++ 编译器发出警告：

```
        chff.cpp: In function `int main()':
        chff.cpp:13: warning: comparison is always 0 due to limited range of data type

```

(答案 8.)

**提示 61**：未捕获的异常是 class problem 类。真的！(下一个 提示 339. 答案 55.)

**提示 62**：字符 "A" 的整数值为 65。字符 "A" + 1 的整数值为 66。这与输出有关：

```
        A6667

```

(答案 45.)

**提示 63**：在 C++ 中，外部变量不是类型安全的。(答案 7.)

**提示 64**：fork 系统调用创建了一个具有重复内存的重复进程。 (下一个 提示 252. 答案 50.)

**提示 65**：程序崩溃。 (下一个 提示 282. 答案 115.)

**提示 66**：缩进不正确。(答案 97.)

**提示 67**：不要指望缩进是正确的。 (答案 13。)

**提示 68**：该程序返回给操作系统的退出代码是什么？ (答案 6。)

**提示 69**：结果是系统相关的。 (下一提示 279。答案 94。)

**提示 70**：一些示例运行：

```
        Enter two integers: 100 3
        Result is: 100

        Enter two integers: 37 0
        Result is: 37

```

(下一提示 3。答案 25。)

**提示 71**：换行符出现在不希望出现的地方。 (答案 33。)

**提示 72**：C++字符串为我们处理一切。但它们在我们背后做的一件事会引发麻烦。 (下一提示 162。答案 36。)

**提示 73**：程序运行时崩溃。 (下一提示 182。答案 95。)

**提示 74**：在大多数系统中，使用以下命令：

```
        $ program

```

将会工作，并使用以下命令：

```
        $ program >output.txt

```

将会失败。 (下一提示 197。答案 83。)

**提示 75**：out_file 是什么类型的参数？ (下一提示 159。答案 40。)

**提示 76**：在二进制中，3 是 0011。在二进制中，12 是 1100。 (下一提示 218。答案 17。)

**提示 77**：当打开失败时发生错误。 (下一提示 288。答案 60。)

**提示 78**：该语句

```
          11   height = 2;

```

不是一个可执行语句；它看起来像是一个。 (下一提示 287。答案 62。)

**提示 79**：何时初始化 a_var 和调用构造函数？ (下一提示 137。答案 111。)

**提示 80**：计算机不知道基本的数学。 (下一提示 268。答案 1。)

**提示 81**：没有原型——没有参数检查。 (下一提示 174。答案 41。)

**提示 82**：g++ 编译器生成以下警告：

```
        not_z.cpp: In function `int main()':
        not_z.cpp:13: warning: suggest parentheses around assignment used as truth
           value

```

(下一提示 262。答案 25。)

**提示 83**：有两个声明，但只声明了一个变量。 (下一提示 148。答案 57。)

**提示 84**：0x8000 >> 1 是什么？ (答案 19。)

**提示 85**：指向的是什么？谁拥有它？拥有多久？ (答案 18。)

**提示 86**：每个指针指向的数据由谁拥有。 (下一提示 26。答案 100。)

**提示 87**：结果是系统相关的。 (下一提示 21。答案 21。)

**提示 88**：该语句的数据放在哪里：

```
           printf("That's all\n");

```

(下一提示 48。答案 83。)

**提示 89**：这是正确的，合法的标准 C++，即使有些人可能看起来不这么认为。 (下一提示 211。答案 86。)

**提示 90**：将输出通过预处理器运行。 (下一提示 273。答案 88。)

**提示 91**：g++ 编译器给出以下警告：

```
        hbit.cpp: In function 'void bit_out(short int)':
        hbit.cpp:19: warning: overflow in implicit constant conversion

```

(答案 2。)

**提示 92**：很明显，问题必须在第 28 行之前，因为我们没有看到“Starting....”信息。（下一提示 111。答案 68。）

**提示 93**：输出如下：

```
        i is 3
        i is 2

```

（答案 87。）

**提示 94**：这取决于实现。在一些较旧的系统上，你会得到正确的位数精度。在一般模拟浮点数的系统中，会报告准确的结果，而在具有浮点协处理器的系统中，会报告夸张的结果。（答案 73。）

**提示 95**：结果是编译时开关相关的。（下一提示 331。答案 39。）

**提示 96**：gcc 警告如下：

```
        sum.c: In function 'sum':
        sum.c:13: warning: declaration of 'i1' shadows a parameter
        sum.c:14: warning: declaration of 'i2' shadows a parameter
        sum.c:15: warning: declaration of 'i3' shadows a parameter

```

（答案 94。）

**提示 97**：竞争条件。平局会导致死机。（下一提示 27。答案 24。）

**提示 98**：remove 是一个标志.remove 不是一个标志。（下一提示 221。答案 35。）

**提示 99**：人类将波士顿的邮编打印为 02126。C++看待事物的方式不同。（下一提示 308。答案 15。）

**提示 100**：示例输出：

```
        Area of sample is 0

```

（下一提示 326。答案 93。）

**提示 101**：这是一个老 C 程序员将旧的 C 程序移植到 C++的例子。（下一提示 120。答案 98。）

**提示 102**：输出看起来像这样：

```
        47421068117101321161113211511110910132981149710511
        01009710997103101100321121141111031149710932114101
        11311710511410110910111011611544101161041013210211
        ...

```

（下一提示 160。答案 99。）

**提示 103**：结果是系统相关的。（下一提示 314。答案 90。）

**提示 104**：在 MS-DOS 系统上，克利夫兰的邮编是一个负数。（下一提示 223。答案 104。）

**提示 105**：优化器可以在这段代码上做很多工作。（答案 84。）

**提示 106**：g++ 编译器发出警告：

```
        comment.cpp:19:35: warning: "/*" within comment

```

（答案 91。）

**提示 107**：结果是编译时开关相关的。（下一提示 29。答案 89。）

**提示 108**：什么是缓冲区？（下一提示 263。答案 68。）

**提示 109**：setjmp 和 longjmp*不*做什么？（答案 66。）

**提示 110**：异常没有被捕获。乍一看，这似乎是不可能的，因为我们只捕获了一个异常类，即 problem。即使我们没有捕获它，catch(...)也应该捕获其他所有内容。（下一提示 173。答案 55。）

**提示 111**：在编程中，没有什么明显的事情。（答案 68。）

**提示 112**：这是一个错误。（下一提示 227。答案 38。）

**提示 113**：用十进制写 1/3。（下一提示 302。答案 54。）

**提示 114**：每次都是同一个数字。（下一提示 66。答案 97。）

**提示 115**：两个 if，一个 else。那么 else 属于哪个 if？（答案 31。）

**提示 116**：结果是系统相关的。你可能幸运地得到正确答案，或者你可能得到随机数。（答案 51。）

**提示 117**：short int 的范围是多少？（答案 1。）

**提示 118**：有趣的宏定义。（下一提示 190。答案 113。）

**提示 119**：炸弹操作取决于编译器。在便宜的编译器上你会得到一个核心转储。更好的编译器会打印出一个错误信息，告诉你调用了一个纯虚函数。（下一提示 237。答案 101。）

**提示 120**：无法更改类中的常量。然而，如果我们通过调试器运行它，我们会发现魔法数字是 0 而不是预期的值。（下一提示 4。答案 98。）

**提示 121**：这个问题取决于编译器标志。（下一提示 14。答案 114。）

**提示 122**：输出是：

```
        11 squared is 121

```

不是程序员期望的 1 到 10 的平方。（答案 34。）

**提示 123**：打印的项不是一个整数。（下一提示 149。答案 86。）

**提示 124**：变量 ch 是一个字符。ch+1 是什么？（下一提示 283。答案 45。）

**提示 125**：计算复制构造函数被调用的次数。（下一提示 235。答案 12。）

**提示 126**："000" 是一个合法的 C++ 语句。完全无用，但合法。（答案 44。）

**提示 127**：是的，缓冲 I/O 对这样的程序很有用。但这里的方式不是使用缓冲 I/O 库 *iostream*。（答案 65。）

**提示 128**：乘法操作进行了多少次？(答案 39。)

**提示 129**：结果可能取决于编译时使用的编译器标志。（下一提示 310。答案 9。）

**提示 130**：英特尔机器有一个非常损坏的段指针架构。（下一提示 231。答案 21。）

**提示 131**：结果是编译器相关的。（下一提示 141。答案 8。）

**提示 132**：进程切换可以在任何时候发生。（下一提示 276。答案 92。）

**提示 133**：预处理器不是 C++。（下一提示 360。答案 46。）

**提示 134**：这里有一种方法：

```
        if (i = = 2)
            i=1;

        else
            i = 2;

```

但有一个更快的方法。（下一提示 140。答案 48。）

**提示 135**：答案取决于系统。（下一提示 264。答案 70。）

**提示 136**：八进制。（答案 15。）

**提示 137**：std::cout 何时初始化？（答案 111。）

**提示 138**：g++ 警告：

```
comment.cpp:11: warning: '/*' within comment

```

(答案 62。)

**提示 139**：我期望程序打印：

```
        First 1
        First 1
        First 1
        Second 1
        Second 2
        Second 3

```

这并不是打印出来的内容。（下一提示 297。答案 102。）

**提示 140:** 这是另一种方法：

```
        i = (i == 2) ? 1 : 2;

```

但有一个更快的方法。（下一提示 216。答案 48。）

**提示 141:** 结果可以通过某些编译器的编译时开关进行更改。（下一提示 30。答案 8。）

**提示 142:** 派生类的构造函数按“基类，派生类”的顺序调用。析构函数按“派生类，基类”的顺序调用。（答案 101。）

**提示 143:** 语句：

```
        flags |= CD_SIGNAL;

```

应该设置标志中的一个位。大多数时候它确实是这样做的。（答案 52。）

**提示 144:** 输出是：

```
        ----------------

```

（下一提示 91。答案 2。）

**提示 145:** 正在传递的变量的类型是什么？就函数而言，参数类型是什么？（下一提示 315。答案 72。）

**提示 146:** C++ 的 std::string 类分配内存。但它也会销毁它，并且被精心设计以避免内存泄漏。（下一提示 359。答案 66。）

**提示 147:** 一些编译器，包括用于此程序的编译器，允许您进行优化和调试。（下一提示 11。答案 84。）

**提示 148:** g++ 会发出警告：

```
        /tmp/cckuUagE.o: In function 'std::string::_M_data() const':
        /home/sdo/local/include/g++-v3/i586-pc-linux-gnu/bits/gthr-
        single.h(.data+0x0): multiple definition of 'value'
        /tmp/ccenmAbd.o(.data+0x0):/home/sdo/local/include/g++-v3/i586-pc-linux-gnu/
        bits/gthr-single.h: first defined here
        collect2: ld returned 1 exit status

```

(答案 57。)

**提示 149:** 打印的项是一个指针。（下一提示 347。答案 86。）

**提示 150:** 首次初始化字符串 first_name 是什么时候？full_name 是什么时候？谁强制执行这个顺序？（答案 3。）

**提示 151:** '\n' 是换行符。(答案 37。)

**提示 152:** 如果我们对结果不采取任何行动，那么为什么还要计算它？(答案 89。)

**提示 153:** 声明

```
        struct info *new_info(void)

```

包含一个线索。（下一提示 101。答案 98。）

**提示 154:** 有多少个指针？它们指向多少个东西？（下一提示 209。答案 64。）

**提示 155:** g++ 编译器输出警告：

```
        equal.cpp: In function 'int main()':
        equal.cpp:15: warning: suggest parentheses around assignment used as truth value

```

（下一提示 208。答案 47。）

**提示 156:** 输出是：

```
        Customer must pay -10

```

（下一提示 115。答案 31。）

**提示 157:** 您的结果可能会有所不同。（下一提示 79。答案 111。）

**提示 158:** SAIL 和 C 几乎没有相同的语法。这两种语言完全不同。然而，同一个单字符错误导致两个程序都出错。（下一提示 220。答案 53。）

**提示 159:** 通常 C++ 使用“按值传递”来传递参数。这意味着值被复制到子程序中。（下一提示 233。答案 40。）

**提示 160:** 输出包含一堆整数。（答案 99。）

**提示 161:** 我数了 3 个。（下一提示 293。答案 71。）

**提示 162:** 这看起来很像程序 58。（下一提示 178。答案 36。）

**提示 163:** `++i` 返回什么？`i++` 返回什么？（下一提示 93。答案 87。）

**提示 164:** 您的结果可能会有所不同。（下一提示 19。答案 85。）

**提示 165:** 每个人都知道 (x*4)/4 = x。这是基本的数学。（下一提示 80。答案 1。）

**提示 166:** 如果你认为编译时开关与优化有关，那你就错了。（下一提示 358。答案 63。）

**提示 167:** 什么样的数字可以用一个 3 位有符号数表示？（下一提示 169。答案 42。）

**提示 168:** 输出是：

```
        Division 5

```

（下一提示 202。答案 91。）

**提示 169:** 什么样的数字可以用一个 2 位有符号数表示？（下一提示 52。答案 42。）

**提示 170:** 打印的内容是：

```
        pi is 1413754136

```

结果取决于机器。（下一提示 203。答案 10。）

**提示 171:** 并非所有位数组的大小都相同。（下一提示 353。答案 56。）

**提示 172:** 看到的就是得到的。（下一提示 46。答案 69。）

**提示 173:** 那么未捕获的异常是从哪里来的？（下一提示 61。答案 55。）

**提示 174:** gcc 生成了以下警告：

```
        strcat.c: In function `full_name':
        strcat.c:19: warning: implicit declaration of function `strcpy'
        strcat.c:20: warning: implicit declaration of function `strcat'
        strcat.c:20: warning: passing arg 2 of `strcat' makes pointer from integer witho
        ut a cast
        strcat.c: In function `main':
        strcat.c:28: warning: implicit declaration of function `printf'

```

(答案 41。)

**提示 175:** 如果程序正常运行，这个语句绝对是毫无用处的。（下一提示 232。答案 80。）

**提示 176:** 您的结果可能会有所不同。（下一提示 24。答案 18。）

**提示 177:** 结果取决于系统和编译器。（下一提示 49。答案 26。）

**提示 178:** 这是程序 58 中的错误的一个 C++ 版本。（答案 36。）

**提示 179:** ABORT 语句看起来像是一个语句。它不是。（答案 105。）

**提示 180:** 输出是：

```
        -xxxxxxxxxxxxxxx

```

（下一提示 303。答案 19。）

**提示 181:** `scanf` 停止读取时文件会留在哪里？（答案 28。）

**提示 182:** 程序在执行 `sscanf` 时会崩溃。（下一提示 254。答案 95。）

**提示 183:** 在这种情况下，缓冲 I/O 有用吗？（下一提示 213。答案 65。）

**提示 184:** 问题涉及到过度使用 `delete`。（下一提示 188。答案 115。）

**提示 185:** 我们并不总是在打开文件后关闭它。结果是文件描述符耗尽。我们需要添加一些 `close(fd)` 语句。（这是 3 个问题中的 2 个。）(答案 60。)

**提示 186:** 程序使用内联函数，这些函数由某人指向。这可能是问题的一部分吗？（下一提示 219。答案 77。）

**提示 187:** 在以下内容的末尾看起来有一个无用的分号：

```
        result=result/*divisor;  /* Do divide */;

```

它不是没有用的。（下一提示 245。答案 91。）

**提示 188**：在拷贝构造函数中使用 delete 运算符。正在删除什么？（答案 115。）

**提示 189**：an_array 变量有多少个实例？（下一提示 329。答案 59。）

**提示 190**：通过预处理器运行它。（下一提示 5。答案 113。）

**提示 191**：返回了什么？（下一提示 23。答案 30。）

**提示 192**：输出是系统相关的。（下一提示 90。答案 88。）

**提示 193**：缩进不正确。（下一提示 122。答案 34。）

**提示 194**：结果是系统相关的。（下一提示 324。答案 112。）

**提示 195**：prev_ch 被创建了很多次。（答案 106。）

**提示 196**：volatile 修改了什么？（答案 61。）

**提示 197**：setbuf 导致数据被放在哪里？（下一提示 88。答案 83。）

**提示 198**：M_PI 在 *math.h* 中定义为

```
        #define M_PI 3.14159265358979323846 /* pi */

```

（下一提示 16。答案 10。）

**提示 199**：这个函数：

```
        trouble operator = (const trouble &i_trouble)

```

return?（下一提示 333。答案 109。）

**提示 200**：它没有打印出预期的内容。（下一提示 192。答案 88。）

**提示 201**：输出：

```
        The area is 367

```

（下一提示 259。答案 29。）

**提示 202**：那么为什么除法没有发生呢？（下一提示 187。答案 91。）

**提示 203**：g++ 编译器报告的警告：

```
        pi.c: In function 'main':
        pi.c:12: warning: int format, double arg (arg 2)

```

(答案 10。)

**提示 204**：输出是：

```
        Y=8

```

（下一提示 54。答案 49。）

**提示 205**：MAX 不是 10。（答案 112。）

**提示 206**：从 C++ 的角度来看，打印是正确的。（下一提示 99。答案 15。）

**提示 207**：g++ 编译器发出警告：

```
        bit.cpp: In function 'int main()':
        bit.cpp:33: warning: comparison is always 0 due to width of bitfield

```

(答案 42。)

**提示 208**：典型运行：

```
        $ equal
        Enter current balance: 10
        You owe 0
        $ equal
        Enter current balance: 0
        You owe 0
        $ equal
        Enter current balance: -10
        You owe 0

```

（下一提示 267。答案 47。）

**提示 209**：只有一个名称变量和两个指针。（答案 64。）

**提示 210**：常量成员的初始化顺序是什么？（下一提示 100。答案 93。）

**提示 211**：结果是系统相关的。（下一提示 123。答案 86。）

**提示 212**：结果是系统相关的。（下一提示 225。答案 110。）

**提示 213**：在这个情况下使用了缓冲 I/O 吗？（下一提示 127。答案 65。）

**提示 214**：显然，它只打印一次 Hello 和两个新行。但同样明显，如果它做了同样的事情，它就不会出现在这本书里。（下一提示 64。答案 50。）

**提示 215**：看起来第 10 行和第 11 行有注释。这并不完全正确。第 10 行和第 11 行都有注释。(下一条提示 138。答案 62。)

**提示 216**：最快的方法不使用比较，只使用一次减法。( 答案 48。)

**提示 217**：程序输出：

```
        Error: Could not open
        oot
        ewable

```

(下一条提示 243。答案 37。)

**提示 218**："按位与" 不等于 "逻辑与"。(答案 17。)

**提示 219**：程序使用了内联函数，有人指向这些函数。这可能是问题的一部分吗？不。这与它无关。C++ 处理这种情况非常好。(下一条提示 271。答案 77。)

**提示 220**：如果这是一个密码，数字的频率分析可能会提供线索。实际上，这不是一个密码，但数字的频率分析可能会很有趣。(下一条提示 341。答案 53。)

**提示 221**：remove 是两件事。(下一条提示 13。答案 35。)

**提示 222**：竞争条件。(下一条提示 132。答案 92。)

**提示 223**：大多数 UNIX 编译器使用 32 位整数。在 MS-DOS（我的意思是 MS-DOS，而不是 Microsoft Windows），整数通常是 16 位。(下一条提示 258。答案 104。)

**提示 224**：典型运行：

```
        % calc
        Enter operator and value:+ 5
        Total: 5
        Enter operator and value:+ 10
        Bad operator entered
        Total: 5
        Enter operator and value:Bad operator entered
        Total: 5
        Enter operator and value :q
        Bad operator entered
        Total: 5
        Enter operator and value:q

```

(下一条提示 257。答案 28。)

**提示 225**：你认为初始化 log_file 需要什么？(答案 110。)

**提示 226**：这个程序中至少有三个错误，它们的性质相似。(下一条提示 77。答案 60。)

**提示 227**：如果余额为 0 会发生什么？(答案 38。)

**提示 228**：这个程序可以在所有已知的 C++ 编译器上编译并运行。然而它是错误的！这是怎么发生的？(下一条提示 321。答案 66。)

**提示 229**：09 后的字节是错误的。(下一条提示 58。答案 5。)

**提示 230**：对齐和填充。(下一条提示 249。答案 103。)

**提示 231**：在英特尔机器上，在某些内存模型中，编译器生成的代码仅用于操作指针的地址部分，而将段保留不变。( 答案 21。)

**提示 232**：只有在你以交互式调试器运行程序时，这个声明才有用。(下一条提示 309。答案 81。)

**提示 233**：复制 ostream 变量意味着什么？(答案 40。)

**提示 234**：0a 是换行符的 ASCII 码。(下一条提示 2。答案 5。)

**提示 235**：复制构造函数在两个地方被调用。( 答案 12。)

**提示 236**：var_array::~var_array 被调用了多少次？(下一条提示 286。答案 59。)

**提示 237:** 编译器会非常努力地防止你调用纯虚函数。你不能声明抽象类的实例，并且任何基类都必须有一个派生版本，该版本定义了所有纯虚函数。这意味着任何纯虚函数在基类中都将有一个实际的定义。

那么，如果我们知道在派生类中必须有一个虚函数的实现，我们是如何调用一个的呢？（下一 提示 142。答案 101。）

**提示 238:** 常识告诉你，如果你将数组声明为

```
        int array[5]

```

然后元素是：

```
        array[l], array[2], array[3], array[4], array[5]

```

常识与编程无关。（答案 90。）

**提示 239:** 以下是 MS-DOS 输出的十六进制转储：

```
        000000 00 01 02 03 04 05 06 07 08 09 0d 0a 0b 0c 0d 0e
        000010 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e
        000020 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e
        000030 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e
        000040 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e
        000050 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e
        000060 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e
        000070 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e
        000080 7f

```

（下一 提示 229。答案 5。）

**提示 240:** 逗号是 C++ 操作符。（下一 提示 47。答案 44。）

**提示 241:** 线程切换可以发生在任何两行之间，如下两行：

```
        ++count;  // We've got a new character
        *in_ptr = ch;// Store the character

```

(答案 92。)

**提示 242:** g++ 编译器报告了警告：

```
        def.cpp: In function 'int main()':
        def.cpp:19: warning: label 'defualt' defined but not used

```

(答案 67。)

**提示 243:** 在 UNIX 上，名称长度为 15 个字符。在 MS-DOS 上，它只有 12 个字符长。（下一 提示 151。答案 37。）

**提示 244:** 在编译程序时使用 g++。

```
        g++ -g -Wall -o last last.cpp first.cpp

```

它可以工作。但当编译为：

```
        g++ -g -Wall -o last first.cpp last.cpp

```

它失败了。

（下一 提示 150。答案 3。）

**提示 245:** 如果你编辑器中有语法高亮，看看当你将此代码放入其中时会发生什么。（下一 提示 338。答案 91。）

**提示 246:** 显然答案是 3。（i++ 是 2，再加一个 ++ 就是 3。）但在编程中没有什么显然的。（下一 提示 37。答案 87。）

**提示 247:** 空格。（下一 提示 325。答案 23。）

**提示 248:** 这个程序中有两个变量声明。（下一 提示 83。答案 57。）

**提示 249:** 6 不能被 4 整除。（答案 103。）

**提示 250:** 重新定义的新函数应该可以工作，因为显然所有位数组都是相同的大小。（下一 提示 171。答案 56。）

**提示 251:** 注意你的结尾。（答案 43。）

**提示 252:** fork 系统调用创建了一个具有重复内存的重复进程，这包括已缓存的 printf 数据。（答案 50。）

**提示 253:** 普通人通过说“1, 2, 3, 4, 5”来数五个东西。C++ 程序员说，“0, 1, 2, 3, 4”。（下一 提示 238。答案 90。）

**提示 254:** gcc 警告：

```
        calc2.c: In function 'main':
        calc2.c:24: warning: format argument is not a pointer (arg 3)
        calc2.c:24: warning: format argument is not a pointer (arg 4)

```

(答案 95。)

**提示 255:** 预处理器不理解 C++ 语法。（下一 提示 295。答案 78。）

**提示 256:** 如果你尝试调试程序，问题通常就会消失。（下一 提示 121。答案 114。）

**提示 257:** 你的结果可能会有所不同。(提示 181。 答案 28。)

**提示 258:** 16 位整数可以从 32767 到 -32768。(答案 104。)

**提示 259:** 结果是 367 (330 + 37)。(答案 29。)

**提示 260:** strcmp 不返回 true/false。(答案 76。)

**提示 261:** char prev_ch = '\0'; 在 prev_ch 被创建时执行。(提示 195。 答案 106。)

**提示 262:** 语句

```
        if (n2 =! 0)

```

改变 n2。(答案 25。)

**提示 263:** UNIX 设计师在他们无限的智慧中发布了以下信息：

```
           Floating exception (core dumped)

```

对于整数除以零。(提示 92。 答案 68。)

**提示 264:** 一些系统允许你取消对 NULL 的引用；而另一些系统则不允许。(答案 70。)

**提示 265:** 不在本书中！(提示 72。 答案 36。)

**提示 266:** 表达式 x << 2 实际上是 4。然而，我们在这个程序中不使用这个表达式。(提示 204。 答案 49。)

**提示 267:** 语句：

```
        if (amount = 0)

```

不比较 0 和 amount。(答案 47。)

**提示 268:** 这个程序的输出如下：

```
           The number of sheep is: 100
           The number of sheep is: 1000
           The number of sheep is: -6384

```

(提示 117。 答案 1。)

**提示 269:** char * != char[] (提示 25。 答案 7。)

**提示 270:** 输出如下：

```
        Size is 25

```

not

```
        Size is 20

```

如程序员所期望的那样。(答案 4。)

**提示 271:** 答案取决于系统。(提示 32。 答案 77。)

**提示 272:** 如果射击他或她不可行，应该让他或她明白什么是好的编程风格。(提示 163。 答案 87。)

**提示 273:** 在一个系统上的输出看起来像：

```
        3 squared is 9
        5 squared is 25
        7 squared is 49
        9 squared is 81
        11 squared is 121

```

(答案 88。)

**提示 274:** switch 语句没有默认情况；它看起来是这样的。(提示 242。 答案 67。)

**提示 275:** 第 16 行没有问题。我们问它是为了愚弄你。(提示 40。 答案 79。)

**提示 276:** 读者执行这两行：

```
        ++count; // We've got a new character
        *in_ptr = ch;// Store the character

```

(提示 241。 答案 92。)

**提示 277:** gcc 警告：

```
        two.c: In function 'main':
        two.c:11: warning: too few arguments for format
        two.c:9: warning: unused variable `answer'

```

(答案 85。)

**提示 278:** 一些编译器有一个可以改变程序行为的开关。这个开关不会解决问题，但程序的行为会不同。(提示 166。 答案 63。)

**提示 279:** 有多个 i1。(提示 96。 答案 94。)

**提示 280:** 了解 "and" 和 "and and" 之间的区别。(提示 76。 答案 17。)

**提示 281:** 程序打印：

```
        Result is 0

```

(答案 27。)

**提示 282:** 如果你检查代码，我总是确保在覆盖它之前删除变量 data。(提示 184。 答案 115。)

**提示 283**：输出是：

```
        A6667

```

（下一提示 62。答案 45。）

**提示 284**：这个语句：

```
        -1.0;

```

是一个合法的 C++ 语句。尽管完全无用，但这个语句是合法的。（下一提示 12。答案 82。）

**提示 285**：因为没有标题，所以我们没有标准函数的原型；它们是隐式声明的。（下一提示 81。答案 41。）

**提示 286**：`var_array::~var_array`被调用两次。（答案 59。）

**提示 287**：如果你有一个带有语法高亮的编辑器，它将以一种颜色显示基数，以另一种颜色显示高度。（下一提示 215。答案 62。）

**提示 288**：即使文件存在且权限允许读取文件，打开也会失败。（下一提示 306。答案 60。）

**提示 289**：这个语句

```
        int &i = 3+4;

```

是非法的。但不用担心；我们不会使用它——至少不是以这种形式。（答案 22。）

**提示 290**：输出是：

```
        Width is too small
        area(10, 10) = 100

```

程序员期望的是：

```
        Width is too small
        area(10, 50) = 500

```

（下一提示 67。答案 13。）

**提示 291**：复制构造函数被调用的次数比你想象的要多。（下一提示 316。答案 109。）

**提示 292**：记住“1”和“1.0”是不同的。（下一提示 281。答案 27。）

**提示 293**：两个问题涉及到结构体数据中的字节数。（下一提示 51。答案 71。）

**提示 294**：`strcmp`可能会让新手困惑。（下一提示 260。答案 76。）

**提示 295**：将输出通过预处理器运行。（答案 78。）

**提示 296**：示例输出：

```
        Stack 0 has 1 elements
        Stack 1 has 100 elements
        Stack 2 has 134516168 elements
        Stack 3 has 134525376 elements
        Stack 4 has 4 elements

```

（下一提示 145。答案 72。）

**提示 297**：`i++`的值是多少？`++i`的值是多少？（答案 102。）

**提示 298**：它们是不同的。（下一提示 255。答案 78。）

**提示 299**：数字看起来是八进制的。（答案 53。）

**提示 300**：在类内部更改常量是不可能的，但这个程序却做到了。不调用构造函数就创建类是不可能的，但这个程序却做到了。（答案 98。）

**提示 301**：这个程序打印：

```
        parity
        -break
        xon
        -rts

```

（答案 108。）

**提示 302**：将 1/3 以十进制形式三次列在一列中。现在将它们加起来。（答案 54。）

**提示 303**：0x8000（1000 0000 0000(b)）是 (1<<15)。这是正确的值，也是程序员期望的。（下一提示 84。答案 19。）

**提示 304**：缩进不正确。（下一提示 270。答案 4。）

**提示 305**：自己创建新的函数可以大大加快速度——如果你做对了的话。（下一提示 250。答案 56。）

**提示 306:** 打开失败，出现 EMFILE 错误。（进程已经打开了最大数量的文件。）(下一 提示 185。答案 60。)

**提示 307:** 字符串：

```
        "Hello World!/n"

```

包含 14 个字符。(答案 69。)

**提示 308:** 程序打印

```
        San Diego 92126
        Boston    01110

```

(下一 提示 136。答案 15。)

**提示 309:** 程序员认为当读取数据项 #500 时会发生一些奇怪的事情。（答案 81。)

**提示 310:** *in_port_ptr* 被读取了多少次？（下一 提示 356。答案 9。）

**提示 311:** 使用的数据结构是一个不平衡的二叉树。（下一 提示 323。答案 74。）

**提示 312:** 我不知道你可以进行像 a<b<c 这样的三元比较。（下一 提示 18。答案 80。）

**提示 313:** 一个字符有 8 位。它们的编号是什么？(答案 11。)

**提示 314:** 有时当你运行程序时，你会得到错误的答案，有时你会因为段错误而崩溃（Windows 用户会得到一个 UAE - Unexpected Application Error），有时一切都会正常工作。（下一 提示 253。答案 90。）

**提示 315:** 数组的元素大小是多少？(答案 72。)

```
        sizeof(stack) != sizeof(safe_stack)

```

**提示 316:** 样本输出：

```
        Copy Constructor called
        = operator called
        Copy Constructor called
        = operator called
        Copy Constructor called
        = operator called
        ...

```

（下一 提示 199。答案 109。）

**提示 317:** 这个程序试图在删除数据后立即复制数据。（下一 提示 43。答案 75。）

**提示 318:** memset 的参数有哪些？（下一 提示 337。答案 20。）

**提示 319:** 结果是系统相关的。（下一 提示 191。答案 30。）

**提示 320:** 我们没有在这个程序中包含任何头文件是有原因的。（下一 提示 285。答案 41。）

**提示 321:** 程序是非标准的。（下一 提示 68。答案 6。）

**提示 322:** 嘿，这不是我们在程序 58 中做的那个程序吗？不，实际上这是你应用了修正后的程序。注意第 22 行的优雅静态声明。（但仍然存在问题。）（下一 提示 154。答案 64。）

**提示 323:** 使用的数数据结构是一个 *非常* 不平衡的二叉树。（答案 74。）

**提示 324:** 检查预处理器输出。（下一 提示 38。答案 112。）

**提示 325:** 这个程序需要 "blank"，"blank"，和 "blank"。(答案 23。)

**提示 326:** g++ 编译器报告了警告：

```
        rect.cpp: In constructor `rectangle::rectangle(int, int)':
        rect.cpp:20: warning: member initializers for 'const int rectangle::height'
        rect.cpp:18: warning:   and 'const int rectangle::area'
        rect.cpp:31: warning:   will be re-ordered to match declaration order

```

(答案 93。)

**提示 327:** 预处理器遵循自己的规则。（下一 提示 201。答案 29。）

**提示 328:** out_file 是什么？（下一 提示 75。答案 40。）

**提示 329:** 当 store_it 执行时，有两个 var_array 类的实例。 (下一 提示 355。 答案 59。)

**提示 330:** 当派生类中没有定义函数时，C++ 会去基类中寻找它。

所以什么阻止 C++ 调用 base::print_it(int)？ (答案 58。)

**提示 331:** 我们确实将乘法的结果存储到结果中 1863 次。所以循环正在执行。 (下一 提示 128。 答案 39。)

**提示 332:** 16 位字的最左边的位是多少？ (下一 提示 144。 答案 2。)

**提示 333:** 操作符 = 如何返回其结果？ (答案 109。)

**提示 334:** 赋值运算符有问题。 (下一 提示 357。 答案 14。)

**提示 335:** 你不能。 (下一 提示 240。 答案 44。)

**提示 336:** 有事物和指向事物的指针。 (下一 提示 196。 答案 61。)

**提示 337:** sizeof(array) 不是一个字符，'\0' 不是一个整数。C++ 并不足够聪明来注意到这一点。 (答案 20。)

**提示 338:** 注释以 /* 开始并以 */ 结束。 (下一 提示 106。 答案 91。)

**提示 339:** 这是第二次我们抛出有问题的异常。 (下一 提示 345。 答案 55。)

**提示 340:** 一个名字比你想象的要复杂。 (下一 提示 71。 答案 33。)

**提示 341:** 如果你进行了频率分析，你会发现在输出中缺少数字 8 和 9。 (下一 提示 299。 答案 53。)

**提示 342:** 12 * 34 = 408。它总是 408。每个人都知道这一点，包括编译器。 (答案 16。)

**提示 343:** 对齐。 (下一 提示 230。 答案 103。)

**提示 344:** 为什么计算机执行测试 1>c？ (答案 80。)

**提示 345:** 第二个异常是从堆栈析构函数抛出的。 (答案 55。)

**提示 346:** 问题出在第 5 行。 (答案 79。)

**提示 347:** g++ 编译器发出警告：

```
        array2.cpp: In function 'int main()':
        array2.cpp:17: warning: left-hand operand of comma expression has no effect

```

(下一 提示 17。 答案 86。)

**提示 348:** 矩阵 [2] 是一个指针。 (答案 86。)

**提示 349:** MS-DOS 版本插入一个字符。 (下一 提示 239。 答案 5。)

**提示 350:** 问题取决于编译器。 (下一 提示 256。 答案 114。)

**提示 351:** 程序打印：

```
        At least one number is zero.

```

(下一 提示 280。 答案 17。)

**提示 352:** 程序报告 64 位精度。 (下一 提示 57。 答案 73。)

**提示 353:** 重新定义的新函数为什么将大小作为参数传递。 (答案 56。)

**提示 354**：程序打印：

```
        2 is prime
        3 is prime
        5 is prime
        7 is prime

```

我们原本期待收到一些消息告诉我们 4、6、8 和 9 不是质数。但不知何故，那些消息消失了。

（下一提示 274。答案 67。）

**提示 355**：拷贝构造函数是如何实现的？（下一提示 236。答案 59。）

**提示 356**：代码要读取多少次*in_port_ptr 才能正常工作？（至少在表面层面上。）答案 9。]

**提示 357**：下面被赋予的是什么

```
        save_queue = a_queue

```

(答案 14。)

**提示 358**：编译时开关与如何处理 char 到 int 的转换有关。（答案 63。）

**提示 359**：setjmp 和 longjmp 的作用是什么？（下一提示 109。答案 66。）

**提示 360**：通过预处理器运行它。（答案 46。）

**提示 361**：嘿，Steve，你不能让这个程序正确运行吗？（下一提示 265。答案 36。）

^([1])Celerity 1000 是首批 RISC 小型计算机之一。不幸的是，创建它的公司已经不再营业。
