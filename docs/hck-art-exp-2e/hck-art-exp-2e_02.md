# 第 0x200 章。 编程

*黑客*这个词既指编写代码的人，也指利用它的人。尽管这两个黑客群体有不同的最终目标，但两组都使用类似的问题解决技术。由于理解编程有助于那些利用它的人，而理解利用有助于那些编程的人，许多黑客都两者兼顾。在编写优雅代码的技术和利用程序的技术中，都发现了有趣的黑客技巧。黑客实际上只是找到对问题的一种巧妙且反直觉的解决方案的行为。

在程序漏洞中发现的黑客攻击通常使用计算机的规则以从未打算过的方式绕过安全措施。编程黑客在这一点上相似，它们也以新的和创造性的方式使用计算机的规则，但最终目标是效率或更小的源代码，而不一定是安全妥协。实际上，有无限多的程序可以编写来完成任何给定的任务，但其中大多数解决方案都是不必要的大、复杂和杂乱。剩下的少数解决方案则是小、高效和整洁的。具有这些品质的程序被称为*优雅*，而倾向于导致这种效率的巧妙和创造性的解决方案被称为*黑客*。编程两边的黑客都欣赏优雅代码的美丽和巧妙黑客的独创性。

在商业界，人们更重视快速生成功能代码，而不是实现巧妙黑客和优雅。由于计算能力和内存的指数级增长，在处理具有千兆赫兹处理周期和千兆字节内存的现代计算机时，额外花费五个小时来创建稍微快一些和更高效的代码在商业上是没有意义的。尽管时间和内存优化对除了最复杂的用户之外的所有用户来说都是不言而喻的，但新功能是可销售的。当底线是金钱时，在优化上花费时间进行巧妙黑客攻击是没有意义的。

真正欣赏编程优雅之处的是黑客们：这些是电脑爱好者，他们的最终目标不是盈利，而是从他们的老式 Commodore 64 中榨取每一丝可能的功能，需要编写微小而惊人的代码以穿过狭窄的安全缝隙的漏洞制造者，以及任何其他欣赏追求和挑战找到最佳解决方案的人。这些人会对编程感到兴奋，并真正欣赏优雅代码的美丽或巧妙黑客的独创性。由于理解编程是理解程序如何被利用的先决条件，因此编程是一个自然的起点。

# 什么是编程？

编程是一个非常自然和直观的概念。程序不过是一系列用特定语言编写的语句。程序无处不在，甚至世界上的技术恐惧者每天都在使用程序。驾驶指示、烹饪食谱、足球战术和 DNA 都是程序的类型。一个典型的驾驶指示程序可能看起来像这样：

```
Start out down Main Street headed east. Continue on Main Street until you see
a church on your right. If the street is blocked because of construction, turn
right there at 15th Street, turn left on Pine Street, and then turn right on
16th Street. Otherwise, you can just continue and make a right on 16th Street.
Continue on 16th Street, and turn left onto Destination Road. Drive straight
down Destination Road for 5 miles, and then you'll see the house on the right.
The address is 743 Destination Road.
```

任何懂英语的人都能理解并遵循这些驾驶指示，因为它们是用英语写的。诚然，它们并不优雅，但每个指令都很清晰，易于理解，至少对于阅读英语的人来说是这样的。

但计算机本身并不理解英语；它只理解机器语言。要指示计算机做某事，指令必须用它的语言编写。然而，*机器语言*是晦涩难懂的，难以操作——它由原始的比特和字节组成，并且因架构而异。要为 Intel *x*86 处理器编写机器语言的程序，你必须找出每个指令的值，每个指令如何交互，以及无数的底层细节。这样的编程既费力又繁琐，当然不是直观的。

要克服编写机器语言的复杂性，需要一个翻译器。*汇编器*是机器语言翻译器的一种形式——它是一个将汇编语言翻译成机器可读代码的程序。*汇编语言*比机器语言更易于理解，因为它使用不同的指令和变量名，而不是仅仅使用数字。然而，汇编语言仍然离直观性很远。指令名非常晦涩，且语言是针对特定架构的。正如 Intel *x*86 处理器的机器语言与 Sparc 处理器的机器语言不同一样，*x*86 汇编语言与 Sparc 汇编语言也不同。使用某一处理器架构编写的汇编语言程序在另一处理器架构上无法运行。如果程序是用*x*86 汇编语言编写的，它必须重写以在 Sparc 架构上运行。此外，为了有效地编写汇编语言程序，你仍然需要了解你正在编写的处理器架构的许多底层细节。

这些问题可以通过另一种称为编译器的翻译器来解决。*编译器*将高级语言转换为机器语言。高级语言比汇编语言更直观，并且可以转换为针对不同处理器架构的许多不同类型的机器语言。这意味着如果程序是用高级语言编写的，那么程序只需要编写一次；相同的程序代码可以被编译成适用于各种特定架构的机器语言。C、C++和 Fortran 都是高级语言的例子。用高级语言编写的程序比汇编语言或机器语言更易于阅读，更像英语，但它仍然必须遵循非常严格的关于指令措辞的规则，否则编译器将无法理解它。

# Pseudo-code

程序员还有一种编程语言的形态，称为伪代码。*伪代码*只是用类似于高级语言的通用结构排列的英语。它不被编译器、汇编器或任何计算机理解，但它是一种程序员安排指令的有用方式。伪代码没有明确的定义；事实上，大多数人写的伪代码略有不同。它有点像是英语和像 C 这样的高级编程语言之间的模糊的缺失环节。伪代码是介绍通用编程概念的绝佳方式。

# 控制结构

没有控制结构，程序就只是一系列按顺序执行的指令。这对于非常简单的程序来说是可以的，但大多数程序，如驾驶指南示例，并不那么简单。驾驶指南中包含了诸如“*继续沿 Main Street 行驶，直到你看到右手边的教堂*”和“*如果街道因施工而堵塞*”之类的语句……这些语句被称为*控制结构*，它们改变了程序执行流程，从简单的顺序执行转变为更复杂、更有用的流程。

## If-Then-Else

在我们的驾驶指南中，Main Street 可能会在施工中。如果是这样，就需要一套特殊的指令来处理这种情况。否则，应遵循原始的指令集。这些特殊的情况可以通过程序中的最自然的控制结构之一来处理：*if-then-else 结构*。一般来说，它看起来像这样：

```
If *`(condition) then {   Set of instructions to execute if the condition is met;`*
}
Else
{
  *`Set of instruction to execute if the condition is not met; }`*
```

对于这本书，我们将使用类似 C 语言的伪代码，因此每条指令都将以分号结束，指令集将通过花括号和缩进来分组。前面提到的驾驶指南的 if-then-else 伪代码结构可能看起来像这样：

```
Drive down Main Street;
If (street is blocked)
{
  Turn right on 15th Street;
  Turn left on Pine Street;
  Turn right on 16th Street;
}
Else
{
  Turn right on 16th Street;
}
```

每条指令都在单独的一行上，各种条件指令集被大括号包围并缩进以提高可读性。在 C 语言和许多其他编程语言中，`then`关键字是隐含的，因此省略了，所以在前面的伪代码中也没有包含。

当然，其他语言在它们的语法中需要`then`关键字——例如 BASIC、Fortran 和 Pascal。这些编程语言中的语法差异只是表面现象；底层结构仍然是相同的。一旦程序员理解了这些语言试图传达的概念，学习各种语法变体就相对简单。由于本书后面的部分将使用 C 语言，所以本书中使用的伪代码将遵循 C 语言类似的语法，但请记住，伪代码可以有多种形式。

C 语言类似语法中另一个常见的规则是，当由大括号包围的指令集只包含一个指令时，大括号是可选的。为了提高可读性，仍然建议缩进这些指令，但这在语法上不是必需的。根据这个规则，之前的驾驶指南可以被重写为等价的伪代码：

```
Drive down Main Street;
If (street is blocked)
{
  Turn right on 15th Street;
  Turn left on Pine Street;
  Turn right on 16th Street;
}
Else
  Turn right on 16th Street;
```

这条关于指令集的规则适用于本书中提到的所有控制结构，并且该规则本身可以用伪代码来描述。

```
If (there is only one instruction in a set of instructions)
  The use of curly braces to group the instructions is optional;
Else
{
  The use of curly braces is necessary;
  Since there must be a logical way to group these instructions;
}
```

语法本身的描述也可以被视为一个简单的程序。if-then-else 有各种变体，例如 select/case 语句，但逻辑基本上是相同的：如果发生这种情况就做这些事情，否则做其他事情（这可能包括更多的 if-then 语句）。

## While/Until Loops

另一个基本的编程概念是 while 控制结构，它是一种循环。程序员经常希望多次执行一组指令。程序可以通过循环来完成这个任务，但这需要一组条件来告诉它何时停止循环，否则它将无限期地继续。一个*while 循环*告诉在条件为真时循环执行以下指令集。一个简单的饥饿鼠标程序可能看起来像这样：

```
While (you are hungry)
{
  Find some food;
  Eat the food;
}
```

在 while 语句之后的两个指令集将会在鼠标仍然饥饿的情况下重复执行。鼠标每次找到的食物量可能从一小块面包屑到一整条面包不等。同样，while 语句中的指令集执行次数取决于鼠标找到的食物量。

while 循环的另一种变体是 until 循环，这种语法在编程语言 Perl 中可用（C 语言不使用这种语法）。一个*until 循环*实际上是一个条件语句反转的 while 循环。使用 until 循环的相同鼠标程序可能是这样的：

```
Until (you are not hungry)
{
  Find some food;
  Eat the food;
}
```

从逻辑上讲，任何类似 until 的语句都可以转换成 while 循环。之前的驾驶指示中包含有*Continue on Main Street until you see a church on your right*（继续在主街上行驶，直到你看到右边的教堂）这样的语句。通过简单地反转条件，可以轻松地将其转换为标准的 while 循环。

```
While (there is not a church on the right)
   Drive down Main Street;
```

## For 循环

另一种循环控制结构是*for 循环*。这通常用于程序员想要循环一定次数的情况。例如，*Drive straight down Destination Road for 5 miles*（直行下目的地道路 5 英里）可以转换为一个类似以下的 for 循环：

```
For (5 iterations)
  Drive straight for 1 mile;
```

实际上，for 循环只是一个带有计数器的 while 循环。同样的语句可以写成如下形式：

```
Set the counter to 0;
While (the counter is less than 5)
{
  Drive straight for 1 mile;
  Add 1 to the counter;
}
```

C 样式的伪代码语法使得 for 循环的这种特性更加明显：

```
For (i=0; i<5; i++)
  Drive straight for 1 mile;
```

在这种情况下，计数器被称为`i`，for 语句被分成三个部分，由分号分隔。第一部分声明计数器并将其设置为初始值，在这种情况下是 0。第二部分类似于使用计数器的 while 语句：*While*计数器满足这个条件，继续循环。第三部分和最后一部分描述了在每次迭代期间应该对计数器执行什么操作。在这种情况下，`i++`是一个简写方式，表示*将计数器 i 的值加 1*。

使用所有的控制结构，什么是编程？中的驾驶指示可以转换成类似以下的 C 样式的伪代码：

```
Begin going East on Main Street;
While (there is not a church on the right)
  Drive down Main Street;
If (street is blocked)
{
  Turn right on 15th Street;
  Turn left on Pine Street;
  Turn right on 16th Street;
}
Else
  Turn right on 16th Street;
Turn left on Destination Road;
For (i=0; i<5; i++)
  Drive straight for 1 mile;
Stop at 743 Destination Road;
```

# 更基本的编程概念

在接下来的章节中，将介绍更多通用的编程概念。这些概念在许多编程语言中使用，只有一些语法上的差异。在介绍这些概念时，我将使用 C 样式的语法将它们整合到伪代码示例中。最终，伪代码应该看起来非常类似于 C 代码。

## 变量

在 for 循环中使用的计数器实际上是一种变量类型。*变量*可以简单地理解为持有可变数据的对象——因此得名。也存在一些不改变的变量，这些变量被称为*常量*。回到驾驶的例子，汽车的速度就是一个变量，而汽车的颜色则是一个常量。在伪代码中，变量是简单的抽象概念，但在 C（以及许多其他语言）中，变量在使用之前必须声明并指定其类型。这是因为 C 程序最终会被编译成可执行程序。就像烹饪食谱在给出指令之前列出所有必需的原料一样，变量声明允许你在进入程序的核心部分之前做好准备。最终，所有变量都存储在某个地方的内存中，它们的声明允许编译器更有效地组织这些内存。尽管如此，尽管有所有变量类型的声明，但本质上一切都是内存。

在 C 语言中，每个变量都被赋予一个类型，该类型描述了要存储在该变量中的信息。最常见的类型包括 `int`（整数值）、`float`（十进制浮点值）和 `char`（单个字符值）。变量可以通过在列出变量之前使用这些关键字来声明，如下所示。

```
int a, b;
float k;
char z;
```

变量 `a` 和 `b` 现在定义为整数，`k` 可以接受浮点值（如 3.14），而 `z` 预期将包含字符值，如 *A* 或 *w*。变量可以在声明时或之后任何时间使用等号运算符赋值。

```
int a = 13, b;
float k;
char z = 'A';

k = 3.14;
z = 'w';
b = a + 5;
```

执行以下指令后，变量 `a` 将包含 13 的值，`k` 将包含数字 3.14，`z` 将包含字符 *w*，而 `b` 将包含值 18，因为 13 加 5 等于 18。变量只是记住值的一种方式；然而，在 C 语言中，你必须首先声明每个变量的类型。

## | 算术运算符 |

语句 `b = a + 7` 是一个非常简单的算术运算符的例子。在 C 语言中，以下符号用于各种算术运算。

前四个操作应该看起来很熟悉。模数减少可能是一个新概念，但实际上它只是除法后的余数。如果 `a` 是 13，那么 13 除以 5 等于 2，余数为 3，这意味着 `a % 5 = 3`。另外，由于变量 `a` 和 `b` 是整数，所以 `b = a / 5` 的语句将导致 2 的整数值存储在 `b` 中，因为那是它的整数部分。为了保留更准确的答案 2.6，必须使用浮点变量。

| 操作 | 符号 | 示例 |
| --- | --- | --- |
| 加法 | + | `b = a + 5` |
| 减法 | - | `b = a - 5` |
| 乘法 | * | `b = a * 5` |
| 除法 | / | `b = a / 5` |
| 模数减少 | % | `b = a % 5` |

要使程序使用这些概念，你必须使用它的语言。C 语言还提供了这些算术运算的几种简写形式。其中之一在前面提到过，并且在 for 循环中常用。

| 完整表达式 | 简写 | 说明 |
| --- | --- | --- |
| `i = i + 1` | `i++ 或 ++i` | 将 1 加到变量上。 |
| `i = i - 1` | `i-- 或 --i` | 从变量中减去 1。 |

这些简写表达式可以与其他算术运算结合，产生更复杂的表达式。这就是 `i++` 和 `++i` 之间的区别变得明显的地方。第一个表达式意味着在 *评估算术运算后* 将 `i` 的值增加 1，而第二个表达式意味着在 *评估算术运算前* 将 `i` 的值增加 1。以下示例将有助于澄清。

```
int a, b;
a = 5;
b = a++ * 6;
```

在这一组指令执行完毕后，变量 `b` 将包含 30，而 `a` 将包含 6，因为 `b = a++ * 6;` 的简写相当于以下语句：

```
b = a * 6;
a = a + 1;
```

然而，如果使用指令 `b = ++a * 6;`，则对 `a` 的加法顺序会改变，从而导致以下等效指令：

```
a = a + 1;
b = a * 6;
```

由于顺序已改变，在这种情况下 `b` 将包含 36，而 `a` 仍然包含 6。

在程序中，变量经常需要就地修改。例如，你可能需要向一个变量添加一个任意的值，比如 12，并将结果直接存储在那个变量中（例如，`i = i + 12`）。这种情况经常发生，因此也存在简写形式。

| 完整表达式 | 简写 | 说明 |
| --- | --- | --- |
| `i = i + 12` | `i+=12` | 向变量添加一些值。 |
| `i = i - 12` | `i-=12` | 从变量中减去一些值。 |
| `i = i * 12` | `i*=12` | 将一些值乘以变量。 |
| `i = i / 12` | `i/=12` | 从变量中除以一些值。 |

## 比较运算符

变量经常用于之前解释的控制结构的条件语句中。这些条件语句基于某种比较。在 C 语言中，这些比较运算符使用一种在许多编程语言中相当常见的简写语法。

| 条件 | 符号 | 示例 |
| --- | --- | --- |
| 小于 | < | `(a < b)` |
| 大于 | > | `(a > b)` |
| 小于或等于 | <= | `(a <= b)` |
| 大于或等于 | >= | `(a >= b)` |
| 等于 | == | `(a == b)` |
| 不等于 | != | `(a != b)` |

大多数这些运算符都是不言自明的；然而，请注意，*等于* 的简写使用双等号。这是一个重要的区别，因为双等号用于测试等价性，而单等号用于将值赋给变量。语句 `a = 7` 的意思是 *将值 7 放入变量 `a` 中*，而 `a == 7` 的意思是 *检查变量 `a` 是否等于 7*。（一些编程语言如 Pascal 实际上使用 := 来进行变量赋值以消除视觉上的混淆。）此外，请注意，感叹号通常表示 *非*。这个符号可以单独使用来反转任何表达式。

```
!(a < b)    is equivalent to    (a >= b)
```

这些比较运算符也可以通过 OR 和 AND 的简写形式连接在一起。

| 逻辑 | 符号 | 示例 |
| --- | --- | --- |
| OR | &#124;&#124; | `((a < b) &#124;&#124; (a < c))` |
| AND | && | `((a < b) && !(a < c))` |

由两个较小的条件通过 OR 逻辑连接的示例语句将在 `a` 小于 `b` 或 `a` 小于 `c` 时触发为真。同样，由两个较小的比较通过 AND 逻辑连接的示例语句将在 `a` 小于 `b` 且 `a` 不小于 `c` 时触发为真。这些语句应该用括号分组，并且可以包含许多不同的变体。

许多事情都可以归结为变量、比较运算符和控制结构。回到鼠标寻找食物的例子，饥饿可以翻译成一个布尔值 true/false 变量。自然地，1 表示 true，0 表示 false。

```
While (hungry == 1)
{
  Find some food;
  Eat the food;
}
```

这是由程序员和黑客经常使用的一种简写。C 语言实际上没有布尔运算符，所以任何非零值都被认为是真的，如果语句包含 0，则该语句被认为是假的。实际上，比较运算符会在比较为真时返回 1，在比较为假时返回 0。检查变量 `hungry` 是否等于 1，如果 `hungry` 等于 1，则返回 1，如果 `hungry` 等于 0，则返回 0。由于程序只使用这两种情况，比较运算符可以完全省略。

```
While (hungry)
{
  Find some food;
  Eat the food;
}
```

一个更智能的鼠标程序，具有更多输入，展示了比较运算符如何与变量结合使用。

```
While ((hungry) && !(cat_present))
{
  Find some food;
  If(!(food_is_on_a_mousetrap))
    Eat the food;
}
```

这个例子假设还有描述猫的存在和食物位置的变量，值为 1 表示真，值为 0 表示假。只需记住，任何非零值都被认为是真的，而 0 的值被认为是假的。

## 函数

有时候程序员会知道他需要多次使用一组指令。这些指令可以被组合成一个更小的子程序，称为**函数**。在其他语言中，函数被称为子程序或过程。例如，转向汽车的动作实际上由许多更小的指令组成：打开适当的转向灯，减速，检查来车，转动方向盘到适当的方向，等等。本章开头的驾驶指示需要很多转弯；然而，列出每个转弯的每一个小指令将会很繁琐（并且可读性较差）。你可以将变量作为参数传递给函数，以修改函数的操作方式。在这种情况下，函数接收转弯的方向作为参数。

```
Function Turn(variable_direction)
{
  Activate the variable_direction blinker;
  Slow down;
  Check for oncoming traffic;
  while(there is oncoming traffic)
  {
    Stop;
    Watch for oncoming traffic;
  }
  Turn the steering wheel to the variable_direction;
  while(turn is not complete)
  {
    if(speed < 5 mph)
      Accelerate;
  }
  Turn the steering wheel back to the original position;
  Turn off the variable_direction blinker;
}
```

这个函数描述了完成转弯所需的所有指令。当一个了解这个函数的程序需要转弯时，它只需调用这个函数。当函数被调用时，其中的指令会根据传递给它的参数执行；之后，执行会返回到函数调用后的程序位置。可以向这个函数传递左转或右转，这将导致函数向该方向转弯。

在 C 语言中，默认情况下，函数可以向调用者返回一个值。对于那些熟悉数学函数的人来说，这完全合理。想象一个计算一个数字阶乘的函数——自然地，它返回结果。

在 C 语言中，函数不是用“函数”关键字标记的；相反，它们通过返回变量的数据类型来声明。这种格式看起来非常类似于变量声明。如果一个函数旨在返回一个整数（可能是一个计算某个数字 *x* 的阶乘的函数），该函数可能看起来像这样：

```
int factorial(int x)
{
  int i;
  for(i=1; i < x; i++)
    x *= i;
  return x;
}
```

此函数被声明为整数类型，因为它将 1 到 *x* 的每个值相乘并返回结果，这是一个整数。函数末尾的返回语句将变量 *x* 的内容传递回并结束函数。然后，这个阶乘函数可以像整数变量一样在任何了解它的程序的主要部分中使用。

```
int a=5, b;
b = factorial(a);
```

在这个简短程序结束时，变量 `b` 将包含 120，因为阶乘函数将使用 5 作为参数并返回 120。

在 C 中，编译器在可以使用函数之前必须“知道”它们。这可以通过在程序后面使用之前简单地编写整个函数来实现，或者通过使用函数原型。*函数原型*只是告诉编译器预期一个具有此名称、此返回数据类型以及这些数据类型作为其功能参数的函数。实际函数可以位于程序末尾附近，但可以在任何其他地方使用，因为编译器已经知道它了。`factorial()` 函数的函数原型示例可能看起来像这样：

```
int factorial(int);
```

通常，函数原型位于程序的开头附近。在原型中实际上不需要定义任何变量名称，因为这是在实际函数中完成的。编译器所关心的是函数的名称、其返回数据类型以及其功能参数的数据类型。

如果一个函数没有要返回的值，它应该被声明为 `void`，就像我之前用作示例的 `turn()` 函数一样。然而，`turn()` 函数还没有捕获我们所需的全部转向功能。方向指示中的每个转向都有方向和街道名称。这意味着转向函数应该有两个变量：转向的方向和要转向的街道。这使转向功能变得复杂，因为必须在转向之前找到正确的街道。下面列出了一个使用正确 C 语法伪代码的更完整的转向函数。

```
void turn(variable_direction, target_street_name)
{
  Look for a street sign;
  current_intersection_name = read street sign name;
  while(current_intersection_name != target_street_name)
  {
    Look for another street sign;
    current_intersection_name = read street sign name;
  }

  Activate the variable_direction blinker;
  Slow down;
  Check for oncoming traffic;
  while(there is oncoming traffic)
  {
    Stop;
    Watch for oncoming traffic;
  }
  Turn the steering wheel to the variable_direction;
  while(turn is not complete)
  {
    if(speed < 5 mph)
      Accelerate;
  }
  Turn the steering wheel right back to the original position;
  Turn off the variable_direction blinker;
}
```

此函数包括一个部分，通过寻找路标、读取每个路标上的名称并将该名称存储在名为 `current_intersection_name` 的变量中来寻找合适的交叉点。它将继续寻找和读取路标，直到找到目标街道；在那个时刻，剩余的转向指令将被执行。现在可以将伪代码的转向指令更改为使用此转向函数。

```
Begin going East on Main Street;
while (there is not a church on the right)
   Drive down Main Street;
if (street is blocked)
{
  Turn(right, 15th Street);
  Turn(left, Pine Street);
  Turn(right, 16th Street);
}
else
  Turn(right, 16th Street);
Turn(left, Destination Road);
for (i=0; i<5; i++)
  Drive straight for 1 mile;
Stop at 743 Destination Road;
```

在伪代码中通常不常用函数，因为伪代码主要是程序员在编写可编译代码之前勾勒程序概念的一种方式。由于伪代码实际上不需要真正工作，所以不需要写出完整的函数——只需简单地写下“在这里做一些复杂的事情”就足够了。但在像 C 这样的编程语言中，函数被大量使用。C 的大部分实用性来自于被称为*库*的现有函数集合。

# 摸索实践

现在 C 的语法感觉更加熟悉，一些基本编程概念也已经解释清楚，实际上用 C 编程并不是一大步。C 编译器几乎适用于所有操作系统和处理器架构，但在这本书中，我们将专门使用 Linux 和基于*x*86 的处理器。Linux 是一个免费的操作系统，每个人都可以访问，基于*x*86 的处理器是地球上最受欢迎的消费级处理器。由于黑客精神实际上就是实验，所以如果你有一个 C 编译器来跟随，那可能最好不过了。

如果你的电脑有*x*86 处理器，这本书中包含了一个 Live CD，你可以用它来跟随。只需将 CD 放入驱动器，重新启动你的电脑。它将启动到一个 Linux 环境中，而不会修改你的现有操作系统。从这个 Linux 环境中，你可以跟随这本书，并自己进行实验。

让我们直接进入正题。第一个`firstprog.c`程序是一段简单的 C 代码，它将打印“Hello, world!” 10 次。

## 摸索实践

### firstprog.c

```
#include <stdio.h>

int main()
{
  int i;
  for(i=0; i < 10; i++)       // Loop 10 times.
  {
    puts("Hello, world!\n");  // put the string to the output.
  }
  return 0;                   // Tell OS the program exited without errors.
}
```

C 程序的主要执行开始于名为`main()`的函数。任何跟在两个正斜杠（//）后面的文本都是注释，编译器会忽略它。

第一行可能有些令人困惑，但这只是 C 语法，告诉编译器包含一个名为`stdio`的标准输入/输出（I/O）库的头文件。当程序编译时，这个头文件会被添加到程序中。它位于/usr/include/stdio.h，它定义了标准 I/O 库中相应函数的几个常量和函数原型。由于`main()`函数使用了标准 I/O 库中的`printf()`函数，所以在使用之前需要一个`printf()`函数原型。这个函数原型（以及许多其他原型）包含在 stdio.h 头文件中。C 的很多力量来自于其可扩展性和库。其余的代码应该很容易理解，看起来也和之前的伪代码很相似。你可能甚至注意到有一组可以省略的大括号。这个程序将做什么应该很明显，但让我们使用 GCC 编译它并运行它，以确保一切正常。

*GNU 编译器集合（GCC）*是一个免费的 C 语言编译器，可以将 C 语言翻译成处理器可以理解的机器语言。输出的翻译是一个可执行二进制文件，默认情况下称为`a.out`。编译后的程序是否做了你想象中的事情？

```
reader@hacking:~/booksrc $ gcc firstprog.c
reader@hacking:~/booksrc $ ls -l a.out
-rwxr-xr-x 1 reader reader 6621 2007-09-06 22:16 a.out
reader@hacking:~/booksrc $ ./a.out
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
Hello, world!
reader@hacking:~/booksrc $
```

## 整体图景

好的，这些都是你在基础编程课程中会学到的东西——基础但重要。大多数入门级编程课程只是教授如何阅读和编写 C 语言。请别误会，精通 C 语言非常有用，足以让你成为一个合格的程序员，但它只是整体图景中的一小部分。大多数程序员从上到下学习语言，从未看到整体图景。黑客通过了解所有这些部分在这个整体图景中的相互作用来获得优势。在编程领域看到整体图景，只需意识到 C 代码是为了编译而设计的。代码在编译成可执行二进制文件之前实际上什么也不能做。将 C 源代码视为程序是一种常见的误解，黑客每天都在利用这种误解。`a.out`的二进制指令是用机器语言编写的，这是一种 CPU 可以理解的基本语言。编译器被设计成将 C 代码翻译成适用于各种处理器架构的机器语言。在这种情况下，处理器属于使用*x*86 架构的家族。还有 Sparc 处理器架构（用于 Sun 工作站）和 PowerPC 处理器架构（用于预 Intel Mac）。每种架构都有不同的机器语言，因此编译器充当中间人——将 C 代码翻译成目标架构的机器语言。

只要编译后的程序能正常工作，普通程序员只关心源代码。但黑客意识到，编译后的程序才是实际在现实世界中执行的内容。通过对 CPU 运行方式的更好理解，黑客可以操纵运行在其上的程序。我们已经看到了第一个程序的源代码，并将其编译成了*x*86 架构的可执行二进制文件。但这个可执行二进制文件看起来是什么样子呢？GNU 开发工具包中包含一个名为`objdump`的程序，它可以用来检查编译后的二进制文件。让我们先看看`main()`函数被转换成的机器代码。

```
reader@hacking:~/booksrc $ objdump -D a.out | grep -A20 main.:
08048374 <main>:
 8048374:       55                      push   %ebp
 8048375:       89 e5                   mov    %esp,%ebp
 8048377:       83 ec 08                sub    $0x8,%esp
 804837a:       83 e4 f0                and    $0xfffffff0,%esp
 804837d:       b8 00 00 00 00          mov    $0x0,%eax
 8048382:       29 c4                   sub    %eax,%esp
 8048384:       c7 45 fc 00 00 00 00    movl   $0x0,0xfffffffc(%ebp)
 804838b:       83 7d fc 09             cmpl   $0x9,0xfffffffc(%ebp)
 804838f:       7e 02                   jle    8048393 <main+0x1f>
 8048391:       eb 13                   jmp    80483a6 <main+0x32>
 8048393:       c7 04 24 84 84 04 08    movl   $0x8048484,(%esp)
 804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>
 804839f:       8d 45 fc                lea    0xfffffffc(%ebp),%eax
 80483a2:       ff 00                   incl   (%eax)
 80483a4:       eb e5                   jmp    804838b <main+0x17>
 80483a6:       c9                      leave
 80483a7:       c3                      ret
 80483a8:       90                      nop
 80483a9:       90                      nop
 80483aa:       90                      nop
reader@hacking:~/booksrc $
```

`objdump`程序会输出过多的行，以至于无法合理地检查，因此输出被管道传输到`grep`，使用命令行选项仅显示正则表达式`main.:`之后的 20 行。每个字节都以*十六进制表示法*表示，这是一种基数为 16 的计数系统。你最熟悉的计数系统使用的是基数为 10 的系统，因为到了 10 就需要添加一个额外的符号。十六进制使用 0 到 9 来表示 0 到 9，但它也使用 A 到 F 来表示 10 到 15 的值。这种表示法很方便，因为一个字节包含 8 位，每一位可以是真或假。这意味着一个字节有 256（2⁸）种可能的值，所以每个字节可以用 2 个十六进制数字来描述。

最左侧开始的十六进制数字是内存地址。机器语言指令的位必须放在某个地方，这个地方就叫做*内存*。内存只是由带有地址的临时存储空间字节组成的集合。

就像当地街道上一排房子，每栋房子都有自己的地址一样，内存可以看作是一排字节，每个字节都有自己的内存地址。每个内存字节都可以通过其地址来访问，在这种情况下，CPU 通过访问这部分内存来检索构成编译程序的机器语言指令。较老的 Intel *x*86 处理器使用 32 位寻址方案，而较新的处理器使用 64 位寻址方案。32 位处理器有 2³²（或 4,294,967,296）个可能的地址，而 64 位处理器有 2⁶⁴（1.84467441 x 10¹⁹）个可能的地址。64 位处理器可以在 32 位兼容模式下运行，这允许它们快速运行 32 位代码。

上列中间的十六进制字节是*x*86 处理器的机器语言指令。当然，这些十六进制值只是 CPU 能够理解的二进制 1s 和 0s 字节的表现形式。但由于*0101010110001001111001011000001111101100111100001*…对除了处理器之外的东西没有太大用处，因此机器代码以十六进制字节的形式显示，并且每条指令都单独放在一行上，就像将一个段落拆分成句子一样。

想想看，十六进制字节本身其实也不是非常有用——这就是汇编语言的作用所在。最右侧的指令是汇编语言。汇编语言实际上只是对应机器语言指令的助记符集合。指令`ret`比`0xc3`或`11000011`更容易记住和理解。与 C 和其他编译语言不同，汇编语言指令与其对应的机器语言指令有一个直接的、一对一的关系。这意味着由于每个处理器架构都有不同的机器语言指令，因此每个架构也有不同的汇编语言形式。汇编语言只是程序员用来表示处理器所接受的机器语言指令的一种方式。这些机器语言指令的确切表示只是惯例和偏好的问题。虽然理论上你可以创建自己的*x*86 汇编语言语法，但大多数人还是坚持使用两种主要类型之一：AT&T 语法和 Intel 语法。在更大的图景的输出中显示的汇编语言是 AT&T 语法，因为几乎所有的 Linux 反汇编工具默认都使用这种语法。通过%和$符号的嘈杂前缀很容易识别 AT&T 语法（再次查看更大的图景上的示例）。可以通过向`objdump`提供额外的命令行选项`-M intel`来以 Intel 语法显示相同的代码，如下面的输出所示。

```
reader@hacking:~/booksrc $ objdump -M intel -D a.out | grep -A20 main.:
08048374 <main>:
 8048374:       55                      push   ebp
 8048375:       89 e5                   mov    ebp,esp
 8048377:       83 ec 08                sub    esp,0x8
 804837a:       83 e4 f0                and    esp,0xfffffff0
 804837d:       b8 00 00 00 00          mov    eax,0x0
 8048382:       29 c4                   sub    esp,eax
 8048384:       c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-4],0x0
 804838b:       83 7d fc 09             cmp    DWORD PTR [ebp-4],0x9
 804838f:       7e 02                   jle    8048393 <main+0x1f>
 8048391:       eb 13                   jmp    80483a6 <main+0x32>
 8048393:       c7 04 24 84 84 04 08    mov    DWORD PTR [esp],0x8048484
 804839a:       e8 01 ff ff ff          call   80482a0 <printf@plt>
 804839f:       8d 45 fc                lea    eax,[ebp-4]
 80483a2:       ff 00                   inc    DWORD PTR [eax]
 80483a4:       eb e5                   jmp    804838b <main+0x17>
 80483a6:       c9                      leave
 80483a7:       c3                      ret
 80483a8:       90                      nop
 80483a9:       90                      nop
 80483aa:       90                      nop
reader@hacking:~/booksrc $
```

个人而言，我认为 Intel 语法更易于阅读和理解，因此为了本书的目的，我将尽量坚持这种语法。无论汇编语言表示如何，处理器能理解的命令都非常简单。这些指令由一个操作和一些有时描述操作目的和/或源的额外参数组成。这些操作移动内存，执行某种基本数学运算，或者中断处理器以使其执行其他操作。最终，计算机处理器真正能做的就是这些。但就像使用相对较小的字母表写出了数百万本书一样，使用相对较小的机器指令集合可以创建无限多的可能程序。

处理器也有它们自己的一组特殊变量，称为**寄存器**。大多数指令使用这些寄存器来读取或写入数据，因此理解处理器的寄存器对于理解指令是至关重要的。整体图景一直在不断扩大…。

## x86 处理器

8086 CPU 是第一个 *x*86 处理器。它由英特尔开发和制造，后来在该系列中开发了更先进的处理器：80186、80286、80386 和 80486。如果你记得在 80 年代和 90 年代人们谈论 386 和 486 处理器，他们所指的就是这些。

*x*86 处理器有几个寄存器，它们就像是处理器的内部变量。我现在可以抽象地谈论这些寄存器，但我认为亲自看到这些事物总是更好的。GNU 开发工具还包括一个名为 GDB 的调试器。*调试器*被程序员用来逐步执行编译后的程序，检查程序内存，并查看处理器寄存器。一个从未使用调试器查看程序内部工作原理的程序员就像是一个从未使用显微镜的十七世纪医生。与显微镜类似，调试器允许黑客观察机器代码的微观世界——但调试器的功能远比这个比喻所允许的强大。与显微镜不同，调试器可以从所有角度查看执行过程，暂停它，并在过程中更改任何内容。

下面，使用 GDB 显示程序开始前的处理器寄存器状态。

```
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) break main
Breakpoint 1 at 0x804837a
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, 0x0804837a in main ()
(gdb) info registers
eax            0xbffff894       -1073743724
ecx            0x48e0fe81       1222704769
edx            0x1      1
ebx            0xb7fd6ff4       -1208127500
esp            0xbffff800       0xbffff800
ebp            0xbffff808       0xbffff808
esi            0xb8000ce0       -1207956256
edi            0x0      0
eip            0x804837a        0x804837a <main+6>
eflags         0x286    [ PF SF IF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) quit
The program is running.  Exit anyway? (y or n) y
reader@hacking:~/booksrc $
```

在 `main()` 函数上设置了断点，以便在执行我们的代码之前停止执行。然后 GDB 运行程序，在断点处停止，并被告知显示所有处理器寄存器和它们当前的状态。

前四个寄存器（*EAX, ECX, EDX* 和 *EBX*）被称为通用寄存器。它们分别被称为*累加器、计数器、数据*和*基址*寄存器。它们用于各种目的，但主要在 CPU 执行机器指令时作为临时变量。

第二组四个寄存器（*ESP, EBP, ESI* 和 *EDI*）也是通用寄存器，但有时它们也被称为指针和索引。它们分别代表*堆栈指针、基指针、源索引*和*目标索引*。前两个寄存器被称为指针，因为它们存储 32 位地址，本质上指向内存中的那个位置。这些寄存器对程序执行和内存管理非常重要；我们稍后会更详细地讨论它们。最后两个寄存器在技术上也是指针，通常用于在需要从或向内存读取或写入数据时指向源和目标。有一些加载和存储指令使用这些寄存器，但大部分情况下，这些寄存器可以被视为简单的通用寄存器。

*EIP* 寄存器是 *指令指针* 寄存器，它指向处理器正在读取的当前指令。就像一个孩子在他阅读时用手指指着每个单词一样，处理器使用 EIP 寄存器作为其手指来读取每个指令。自然地，这个寄存器非常重要，在调试时将被大量使用。目前，它指向 `0x804838a` 的内存地址。

剩余的 *EFLAGS* 寄存器实际上由几个用于比较和内存分段的位标志组成。实际内存被分成几个不同的段，这将在后面讨论，这些寄存器跟踪这些信息。在大多数情况下，可以忽略这些寄存器，因为它们很少需要直接访问。

## 汇编语言

由于我们在这本书中使用 Intel 语法的汇编语言，我们的工具必须配置为使用此语法。在 GDB 中，可以通过简单地输入 `set disassembly intel` 或简写为 `set dis intel` 来设置反汇编语法为 Intel。您可以通过将命令放入家目录中的 `.gdbinit` 文件来配置此设置，以便每次 GDB 启动时都运行。

```
reader@hacking:~/booksrc $ gdb -q
(gdb) set dis intel
(gdb) quit
reader@hacking:~/booksrc $ echo "set dis intel" > ~/.gdbinit
reader@hacking:~/booksrc $ cat ~/.gdbinit
set dis intel
reader@hacking:~/booksrc $
```

现在 GDB 已配置为使用 Intel 语法，让我们开始理解它。Intel 语法的汇编指令通常遵循以下风格：

```
operation <destination>, <source>
```

目标和源值将是一个寄存器、一个内存地址或一个值。操作通常是直观的助记符：`mov` 操作将从源移动值到目标，`sub` 将执行减法，`inc` 将执行增量，等等。例如，下面的指令将把值从 ESP 移动到 EBP，然后从 ESP 中减去 8（将结果存储在 ESP 中）。

```
8048375:        89 e5                 mov    ebp,esp
8048377:        83 ec 08              sub    esp,0x8
```

也有一些操作用于控制执行流程。`cmp` 操作用于比较值，基本上任何以 `j` 开头的操作都用于跳转到代码的另一个部分（取决于比较的结果）。下面的示例首先比较位于 EBP 减 4 的 4 字节值与数字 9。接下来的指令是 `jump if less than or equal to` 的简写，指的是上一个比较的结果。如果该值小于或等于 9，执行将跳转到 `0x8048393` 处的指令。否则，执行将流向下一个指令，进行无条件跳转。如果该值不小于或等于 9，执行将跳转到 `0x80483a6`。

```
804838b:        83 7d fc 09           cmp    DWORD PTR [ebp-4],0x9
804838f:        7e 02                 jle    8048393 <main+0x1f>
8048391:        eb 13                 jmp    80483a6 <main+0x32>
```

这些示例来自我们之前的反汇编，并且我们的调试器已配置为使用 Intel 语法，所以让我们使用调试器在汇编指令级别逐步执行第一个程序。

`-g` 标志可以被 GCC 编译器用来包含额外的调试信息，这将使 GDB 能够访问源代码。

```
reader@hacking:~/booksrc $ gcc -g firstprog.c 
reader@hacking:~/booksrc $ ls -l a.out
-rwxr-xr-x 1 matrix users 11977 Jul 4 17:29 a.out
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/libthread_db.so.1".
(gdb) list
1       #include <stdio.h>
2
3       int main()
4       {
5               int i;
6               for(i=0; i < 10; i++)
7               {
 8                       printf("Hello, world!\n");
9               }
10      }
(gdb) disassemble main
Dump of assembler code for function main():
0x08048384 <main+0>:    push   ebp
*`0x08048385 <main+1>:    mov    ebp,esp 0x08048387 <main+3>:    sub    esp,0x8 0x0804838a <main+6>:    and    esp,0xfffffff0 0x0804838d <main+9>:    mov    eax,0x0 0x08048392 <main+14>:   sub    esp,eax`*
`0x08048394 <main+16>:   mov    DWORD PTR [ebp-4],0x0`
0x0804839b <main+23>:   cmp    DWORD PTR [ebp-4],0x9
0x0804839f <main+27>:   jle    0x80483a3 <main+31>
0x080483a1 <main+29>:   jmp    0x80483b6 <main+50>
0x080483a3 <main+31>:   mov    DWORD PTR [esp],0x80484d4
0x080483aa <main+38>:   call   0x80482a8 <_init+56>
0x080483af <main+43>:   lea    eax,[ebp-4]
0x080483b2 <main+46>:   inc    DWORD PTR [eax]
0x080483b4 <main+48>:   jmp    0x804839b <main+23>
0x080483b6 <main+50>:   leave
0x080483b7 <main+51>:   ret
End of assembler dump.
(gdb) break main
Breakpoint 1 at 0x8048394: file firstprog.c, line 6.
(gdb) run
Starting program: /hacking/a.out

Breakpoint 1, main() at firstprog.c:6
6               for(i=0; i < 10; i++)
(gdb) info register eip
eip            0x8048394        0x8048394
(gdb)
```

首先，列出源代码并显示`main()`函数的反汇编代码。然后，在`main()`函数的开始处设置一个断点，并运行程序。这个断点简单地告诉调试器在到达该点时暂停程序的执行。由于断点是在`main()`函数的开始处设置的，程序在执行`main()`函数中的任何指令之前就会遇到断点并暂停。然后，会显示 EIP（指令指针）的值。

注意，EIP 包含一个指向`main()`函数反汇编（以粗体显示）中的指令的内存地址。在此之前的指令（以斜体显示）统称为*函数序言*，由编译器生成，用于为`main()`函数的其余局部变量设置内存。变量需要声明在 C 中的部分原因是为了帮助构建这部分代码。调试器知道这部分代码是自动生成的，并且足够智能，可以跳过它。我们稍后会更多地讨论函数序言，但现在我们可以从 GDB 那里得到启示，跳过它。

GDB 调试器提供了一个直接检查内存的方法，使用命令`x`，它是`examine`的缩写。检查内存是任何黑客的关键技能。大多数黑客攻击都类似于魔术表演——除非你知道手法和误导，否则它们看起来神奇而神秘。在魔术和黑客攻击中，如果你只看对的地方，技巧就会很明显。这也是为什么一个好的魔术师永远不会重复同一个魔术。但是，使用像 GDB 这样的调试器，可以确定地检查、暂停、单步执行和重复程序的每个执行方面，直到需要为止。由于运行中的程序主要是处理器和内存段，检查内存是查看真正发生事情的第一种方法。

GDB 中的检查命令可以以多种方式查看内存中的特定地址。当使用此命令时，它期望两个参数：要检查的内存位置以及如何显示该内存。

显示格式也使用单字母缩写，这些缩写可以有一个可选的计数，表示要检查的项目数量。以下是一些常见的格式字母：

| **`o`** 以八进制显示。 |
| --- |
| **`x`** 以十六进制显示。 |
| **`u`** 以无符号、标准的十进制显示。 |
| **`t`** 以二进制显示。 |

这些命令可以与`examine`命令一起使用来检查特定的内存地址。在下面的示例中，使用了 EIP 寄存器的当前地址。在 GDB 中，通常使用简写命令，甚至`info register eip`也可以简写为`i r eip`。

```
gdb) i r eip
eip            0x8048384        0x8048384 <main+16>
(gdb) x/o 0x8048384
0x8048384 <main+16>:    077042707
(gdb) x/x $eip
0x8048384 <main+16>:    0x00fc45c7
(gdb) x/u $eip
0x8048384 <main+16>:    16532935
(gdb) x/t $eip
0x8048384 <main+16>:    00000000111111000100010111000111
(gdb)
```

可以通过使用 EIP 中存储的地址来检查 EIP 指向的内存。调试器允许你直接引用寄存器，因此 `$eip` 等同于那一刻 EIP 包含的值。八进制值 `077042707` 等同于十六进制的 `0x00fc45c7`，也等同于十进制的 `16532935`，进而等同于二进制的 `00000000111111000100010111000111`。也可以将数字添加到检查命令的格式中，以检查目标地址的多个单元。

```
(gdb) x/2x $eip
0x8048384 <main+16>:    0x00fc45c7     0x83000000
(gdb) x/12x $eip
0x8048384 <main+16>:    0x00fc45c7     0x83000000     0x7e09fc7d     0xc713eb02
0x8048394 <main+32>:    0x84842404     0x01e80804     0x8dffffff     0x00fffc45
0x80483a4 <main+48>:    0xc3c9e5eb     0x90909090     0x90909090     0x5de58955
(gdb)
```

单个单元的默认大小是四个字节的单元，称为 *字*。可以通过在格式字母的末尾添加大小字母来更改检查命令的显示单元大小。有效的大小字母如下：

| **`b`** 一个单字节 |
| --- |
| **`h`** 一个半字，大小为两个字节 |
| **`w`** 一个字，大小为四个字节 |
| **`g`** 一个巨大的，大小为八字节 |

这有点令人困惑，因为有时术语 *字* 也指 2 字节值。在这种情况下，*双字* 或 *DWORD* 指的是 4 字节值。在这本书中，字和 DWORD 都指 4 字节值。如果我在谈论一个 2 字节值，我会称它为 *短* 或半字。以下 GDB 输出显示了以各种大小显示的内存。

```
(gdb) x/8xb $eip
0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00    0x83
(gdb) x/8xh $eip
0x8048384 <main+16>:    0x45c7  0x00fc  0x0000  0x8300  0xfc7d  0x7e09  0xeb02  0xc713
(gdb) x/8xw $eip
0x8048384 <main+16>:    0x00fc45c7      0x83000000      0x7e09fc7d      0xc713eb02
0x8048394 <main+32>:    0x84842404      0x01e80804      0x8dffffff      0x00fffc45 
(gdb)
```

如果仔细观察，你可能会注意到数据中有些奇怪的地方。第一个 `x`amine 命令显示了前八个字节，自然地，使用更大单元的 `x`amine 命令会显示更多的数据。然而，第一个 `x`amine 显示的前两个字节是 `0xc7` 和 `0x45`，但当在确切的相同内存地址检查半字时，显示的值是 `0x45c7`，字节顺序相反。当以 `0x00fc45c7` 显示完整的四个字节时，也可以看到相同的字节反转效果，但当逐字节显示前四个字节时，它们的顺序是 `0xc7, 0x45, 0xfc` 和 `0x00`。

这是因为在 *x*86 处理器上，值以 *小端字节序* 存储的，这意味着最低有效字节首先存储。例如，如果要将四个字节解释为单个值，则必须以相反的顺序使用字节。GDB 调试器足够智能，知道值是如何存储的，因此当检查字或半字时，必须反转字节以在十六进制中显示正确的值。重新查看以十六进制和无符号十进制显示的这些值可能有助于消除任何混淆。

```
(gdb) x/4xb $eip
0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00
(gdb) x/4ub $eip
0x8048384 <main+16>:    199     69      252     0
(gdb) x/1xw $eip
0x8048384 <main+16>:    0x00fc45c7
(gdb) x/1uw $eip
0x8048384 <main+16>:    16532935
(gdb) quit
The program is running.  Exit anyway? (y or n) y
reader@hacking:~/booksrc $ bc -ql
199*(256³) + 69*(256²) + 252*(256¹) + 0*(256⁰)
3343252480
0*(256³) + 252*(256²) + 69*(256¹) + 199*(256⁰)
16532935
quit
reader@hacking:~/booksrc $
```

前四个字节同时以十六进制和标准无符号十进制表示。使用名为 `bc` 的命令行计算器程序来显示，如果字节以错误的顺序解释，结果将是可怕的错误值 `3343252480`。给定架构的字节序是一个需要了解的重要细节。虽然大多数调试工具和编译器会自动处理字节序的细节，但最终你将直接自己操作内存。

除了转换字节顺序外，GDB 还可以使用 `examine` 命令进行其他转换。我们已经看到 GDB 可以将机器语言指令反汇编成人类可读的汇编指令。`examine` 命令也接受格式字母 `i`，代表 *instruction*，以显示内存为反汇编的汇编语言指令。

```
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) break main
Breakpoint 1 at 0x8048384: file firstprog.c, line 6.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at firstprog.c:6
6         for(i=0; i < 10; i++)
(gdb) i r $eip
eip            0x8048384        0x8048384 <main+16>
(gdb) x/i $eip
0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0
(gdb) x/3i $eip
0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0
0x804838b <main+23>:    cmp    DWORD PTR [ebp-4],0x9
0x804838f <main+27>:    jle    0x8048393 <main+31>
(gdb) x/7xb $eip
0x8048384 <main+16>:    0xc7    0x45    0xfc    0x00    0x00    0x00    0x00
(gdb) x/i $eip
0x8048384 <main+16>:    mov    DWORD PTR [ebp-4],0x0
(gdb)
```

在上面的输出中，`a.out` 程序在 GDB 中运行，并在 `main()` 处设置了断点。由于 EIP 寄存器指向实际包含机器语言指令的内存，它们反汇编得相当好。

之前的 `objdump` 汇编确认，EIP 所指向的七个字节实际上是对应汇编指令的机器语言。

```
	8048384:      c7 45 fc 00 00 00 00   mov   DWORD PTR [ebp-4],0x0
```

这个汇编指令会将值 0 移入存储在 EBP 寄存器地址减 4 的内存中。这是 C 变量 `i` 在内存中的存储位置；`i` 被声明为一个占用 4 个字节的整数，在 *x86* 处理器上。基本上，这个命令会将循环中的变量 `i` 清零。如果现在检查这个内存，它将只包含随机垃圾。这个位置的内存可以通过几种不同的方式进行检查。

```
(gdb) i r ebp
ebp            0xbffff808       0xbffff808
(gdb) x/4xb $ebp - 4
0xbffff804:     0xc0    0x83    0x04    0x08
(gdb) x/4xb 0xbffff804
0xbffff804:     0xc0    0x83    0x04    0x08
(gdb) print $ebp - 4
$1 = (void *) 0xbffff804
(gdb) x/4xb $1
0xbffff804:     0xc0    0x83    0x04    0x08
(gdb) x/xw $1
0xbffff804:     0x080483c0
(gdb
```

EBP 寄存器显示包含地址 `0xbffff808`，汇编指令将写入比这低 4 个偏移量的值，即 `0xbffff804`。可以使用 `examine` 命令直接检查这个内存地址，或者通过即时计算。`print` 命令也可以用来进行简单的数学运算，但结果存储在调试器的临时变量中。这个名为 `$1` 的变量可以在以后快速重新访问内存中的特定位置。上述任何一种方法都可以完成相同的任务：显示在当前指令执行时将被清零的内存中的 4 个垃圾字节。

让我们使用 `nexti` 命令执行当前指令，它代表 *next instruction*。处理器将读取 EIP 中的指令，执行它，并将 EIP 前进到下一个指令。

```
(gdb) nexti
0x0804838b      6        for(i=0; i < 10; i++)
(gdb) x/4xb $1
0xbffff804:     0x00   0x00    0x00    0x00
(gdb) x/dw $1
0xbffff804:     0
(gdb) i r eip
eip            0x804838b       0x804838b <main+23>
(gdb) x/i $eip
0x804838b <main+23>:    cmp   DWORD PTR [ebp-4],0x9
(gdb)
```

如预测的那样，之前的命令将 EBP 减 4 找到的 4 个字节清零，这是为 C 变量 `i` 预留的内存。然后 EIP 前进到下一个指令。接下来的几个指令实际上更值得作为一个组来讨论。

```
(gdb) x/10i $eip
0x804838b <ma in+23>:   cmp   DWORD PTR [ebp-4],0x9
0x804838f <main+27>:   jle   0x8048393 <main+31>
0x8048391 <main+29>:   jmp   0x80483a6 <main+50>
`0x8048393 <main+31>:   mov   DWORD PTR [esp],0x8048484`
0x804839a <main+38>:   call  0x80482a0 <printf@plt>
0x804839f <main+43>:   lea   eax,[ebp-4]
0x80483a2 <main+46>:   inc   DWORD PTR [eax]
0x80483a4 <main+48>:   jmp   0x804838b <main+23>
0x80483a6 *`<main+50>:   leave`*
0x80483a7 <main+51>:   ret
(gdb)
```

第一条指令，`cmp`，是一个比较指令，它将 C 变量 `i` 所使用的内存与值 9 进行比较。下一条指令，`jle`，代表 *跳转如果小于或等于*。它使用前一次比较的结果（实际上存储在 EFLAGS 寄存器中）来决定是否将 EIP 跳转到代码的不同部分。如果前一次比较操作的目标小于或等于源，则执行跳转。在这种情况下，指令表示如果 C 变量 `i` 存储在内存中的值小于或等于 9，则跳转到地址 `0x8048393`。如果不是这种情况，EIP 将继续执行下一条指令，这是一条无条件跳转指令。这将导致 EIP 跳转到地址 `0x80483a6`。这三条指令组合起来创建了一个 if-then-else 控制结构：*如果 i 小于或等于 9，则跳转到地址 0x8048393 的指令；否则，跳转到地址 0x80483a6*。`0x8048393` 的第一个地址（加粗显示）是固定跳转指令之后的指令，而 `0x80483a6` 的第二个地址（斜体显示）位于函数的末尾。

由于我们知道值 0 存储在正在与值 9 进行比较的内存位置中，并且我们知道 0 小于或等于 9，因此在执行下两条指令后，EIP 应该位于 `0x8048393`。

```
(gdb) nexti
0x0804838f      6          for(i=0; i < 10; i++)
(gdb) x/i $eip
0x804838f <main+27>:     jle    0x8048393 <main+31>
(gdb) nexti
8            printf("Hello, world!\n");
(gdb) i r eip
eip            0x8048393        0x8048393 <main+31>
(gdb) x/2i $eip
0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484
0x804839a <main+38>:    call   0x80482a0 <printf@plt>
(gdb)
```

如预期的那样，前两条指令让程序执行流程下转到 `0x8048393`，这带我们来到了下两条指令。第一条指令是另一个 `mov` 指令，它将地址 `0x8048484` 写入 ESP 寄存器所包含的内存地址。但 ESP 指向的是什么？

```
	(gdb) i r esp
	esp           0xbffff800       0xbffff800
	(gdb)
```

目前，ESP 指向内存地址 `0xbffff800`，因此当执行 `mov` 指令时，地址 `0x8048484` 被写入那里。但为什么？内存地址 `0x8048484` 有什么特别之处？有一种方法可以找出答案。

```
	(gdb) x/2xw 0x8048484
	0x8048484:      0x6c6c6548      0x6f57206f
	(gdb) x/6xb 0x8048484
	0x8048484:      0x48    0x65    0x6c   0x6c   0x6f   0x20
	(gdb) x/6ub 0x8048484
	0x8048484:      72      101     108    108    111 32
	(gdb)
```

有经验的眼睛可能会注意到这里内存的一些情况，特别是字节的范围。经过足够长时间的内存检查，这些类型的视觉模式会变得更加明显。这些字节位于可打印的 ASCII 范围内。*ASCII* 是一个协议，将键盘上的所有字符（以及一些不是的字符）映射到固定的数字。字节 `0x48, 0x65, 0x6c` 和 `0x6f` 都对应于下面显示的 ASCII 表中的字母。这个表可以在 ASCII 的 man 页面上找到，大多数 Unix 系统中可以通过输入 `man ascii` 来访问。

### ASCII 表

```
	Oct   Dec   Hex   Char           Oct   Dec   Hex   Char
	------------------------------------------------------------
	000   0     00    NUL '\0'       100   64    40    @
	001   1     01    SOH            101   65    41    A
	002   2     02    STX            102   66    42    B
	003   3     03    ETX            103   67    43    C
	004   4     04    EOT            104   68    44    D
	005   5     05    ENQ            105   69    45    E
	006   6     06    ACK            106   70    46    F
	007   7     07    BEL '\a'       107   71    47    G
	010   8     08    BS  '\b'       `110   72    48    H`
	011   9     09    HT  '\t'       111   73    49    I
	012   10    0A    LF  '\n'       112   74    4A    J
	013   11    0B    VT  '\v'       113   75    4B    K
	014   12    0C    FF  '\f'       114   76    4C    L
	015   13    0D    CR  '\r'       115   77    4D    M
	016   14    0E    SO             116   78    4E    N
	017   15    0F    SI             117   79    4F    O
	020   16    10    DLE            120   80    50    P
	021   17    11    DC1            121   81    51    Q
	022   18    12    DC2            122   82    52    R
	023   19    13    DC3            123   83    53    S
	024   20    14    DC4            124   84    54    T
	025   21    15    NAK            125   85    55    U
	026   22    16    SYN            126   86    56    V
	027   23    17    ETB            127   87    57    W
	030   24    18    CAN            130   88    58    X
	031   25    19    EM             131   89    59    Y
	032   26    1A    SUB            132   90    5A    Z
	033   27    1B    ESC            133   91    5B    [
	034   28    1C    FS             134   92    5C    \   '\\'
	035   29    1D    GS             135   93    5D    ]
	036   30    1E    RS             136   94    5E    ^
	037   31    1F    US             137   95    5F    _
	040   32    20    SPACE          140   96    60    `
	041   33    21    !              141   97    61    a
	042   34    22    "              142   98    62    b
	043   35    23    #              143   99    63    c
	044   36    24    $              144   100   64    d
	045   37    25    %              `145   101   65    e`
	046   38    26    &              146   102   66    f
	047   39    27    '              147   103   67    g
	050   40    28    (              150   104   68    h
	051   41    29    )              151   105   69    i
	052   42    2A    *              152   106   6A    j
	053   43    2B    +              153   107   6B    k
	054   44    2C    ,              `154  108   6C     l`
	055   45    2D    -              155   109   6D    m
	056   46    2E    .              156   110   6E    n
	057   47    2F    /              `157  111   6F    o`
	060   48    30    0              160   112   70    p
	061   49    31    1              161   113   71    q
	062   50    32    2              162   114   72    r
	063   51    33    3              163   115   73    s
	064   52    34    4              164   116   74    t
	065   53    35    5              165   117   75    u
	066   54    36    6              166   118   76    v
	067   55    37    7              167   119   77    w
	070   56    38    8              170   120   78    x
	071   57    39    9              171   121   79    y
	072   58    3A    :              172   122   7A    z
	073   59    3B    ;              173   123   7B    {
	074   60    3C    <              174   124   7C    |
	075   61    3D    =              175   125   7D    }
	076   62    3E    >              176   126   7E    ~
	077   63    3F    ?              177   127   7F    DEL
```

幸运的是，GDB 的 examine 命令也包含查看此类内存的条款。可以使用 `c` 格式字母自动查找 ASCII 表上的字节，而 `s` 格式字母将显示整个字符串字符数据。

```
(gdb) x/6cb 0x8048484
0x8048484:      72 'H'  101 'e' 108 'l' 108 'l' 111 'o' 32 ' '
(gdb) x/s 0x8048484
0x8048484:       "Hello, world!\n"
(gdb)
```

这些命令显示数据字符串 `"Hello, world!\n"` 存储在内存地址 `0x8048484`。这个字符串是 `printf()` 函数的参数，这表明将这个字符串的地址移动到 ESP (`0x8048484`) 中与这个函数有关。下面的输出显示了数据字符串的地址被移动到 ESP 指向的地址。

```
(gdb) x/2i $eip
0x8048393 <main+31>:    mov    DWORD PTR [esp],0x8048484
0x804839a <main+38>:    call   0x80482a0 <printf@plt>
(gdb) x/xw $esp
0xbffff800:     0xb8000ce0
(gdb) nexti
0x0804839a      8           printf("Hello, world!\n");
(gdb) x/xw $esp
0xbffff800:     0x08048484 
(gdb)
```

下一条指令实际上是 `printf()` 函数；它打印数据字符串。前面的指令是为函数调用做准备，函数调用的结果可以在下面的输出中用粗体看到。

```
(gdb) x/i $eip
0x804839a <main+38>:    call   0x80482a0 <printf@plt>
(gdb) nexti
`Hello, world!`
6         for(i=0; i < 10; i++)
(gdb)
```

继续使用 GDB 进行调试，让我们检查下两条指令。再次，它们作为一个组来看更有意义。

```
(gdb) x/2i $eip
0x804839f <main+43>:    lea    eax,[ebp-4]
0x80483a2 <main+46>:    inc    DWORD PTR [eax]
(gdb)
```

这两个指令基本上只是将变量 `i` 递增 1。`lea` 指令是 *Load Effective Address* 的缩写，它将 EBP 减 4 的熟悉地址加载到 EAX 寄存器中。此指令的执行情况如下所示。

```
(gdb) x/i $eip
0x804839f <main+43>:    lea    eax,[ebp-4]
(gdb) print $ebp - 4
$2 = (void *) 0xbffff804
(gdb) x/x $2
0xbffff804:     0x00000000
(gdb) i r eax
eax            0xd      13
(gdb) nexti
0x080483a2      6         for(i=0; i < 10; i++)
(gdb) i r eax
eax            0xbffff804       -1073743868
(gdb) x/xw $eax
0xbffff804:     0x00000000
(gdb) x/dw $eax
0xbffff804:     0
(gdb)
```

下一个 `inc` 指令将此地址（现在存储在 EAX 寄存器中）的值加 1。此指令的执行情况也如下所示。

```
gdb) x/i $eip
0x80483a2 <main+46>:    inc    DWORD PTR [eax]
(gdb) x/dw $eax
0xbffff804:     0
(gdb) nexti
0x080483a4      6         for(i=0; i < 10; i++)
(gdb) x/dw $eax
0xbffff804:     1
(gdb)
```

最终结果是存储在内存地址 EBP 减 4 (`0xbffff804`) 处的值，加 1。这种行为对应于一段 C 代码，其中变量 `i` 在 for 循环中被递增。

下一条指令是一个无条件跳转指令。

```
(gdb) x/i $eip
0x80483a4 <main+48>:    jmp    0x804838b <main+23> 
(gdb)
```

当执行此指令时，它将程序送回到地址 `0x804838b` 的指令。它是通过简单地设置 EIP 为该值来做到这一点的。

再次查看完整的反汇编代码，你应该能够判断出哪些 C 代码被编译成了哪些机器指令。

```
(gdb) disass main
Dump of assembler code for function main:
0x08048374 <main+0>:    push   ebp
0x08048375 <main+1>:    mov    ebp,esp
0x08048377 <main+3>:    sub    esp,0x8
0x0804837a <main+6>:    and    esp,0xfffffff0
0x0804837d <main+9>:    mov    eax,0x0
0x08048382 <main+14>:   sub    esp,eax
`0x08048384 <main+16>:   mov    DWORD PTR [ebp-4],0x0 0x0804838b <main+23>:   cmp    DWORD PTR [ebp-4],0x9 0x0804838f <main+27>:   jle    0x8048393 <main+31> 0x08048391 <main+29>:   jmp    0x80483a6 <main+50>`
*`0x08048393 <main+31>:   mov    DWORD PTR [esp],0x8048484 0x0804839a <main+38>:   call   0x80482a0 <printf@plt>`*
`0x0804839f <main+43>:   lea    eax,[ebp-4] 0x080483a2 <main+46>:   inc    DWORD PTR [eax] 0x080483a4 <main+48>:   jmp    0x804838b <main+23>`
0x080483a6 <main+50>:   leave
0x080483a7 <main+51>:   ret
End of assembler dump.
(gdb) list
1       #include <stdio.h>
2
3       int main()
4       {
5         int i;
`6         for(i=0; i < 10; i++) 7         {`
8           *`printf("Hello, world!\n");`*
`9         }`
10      } 
(gdb)
```

粗体显示的指令构成了 for 循环，斜体显示的是循环内的 `printf()` 调用。程序执行将跳回比较指令，继续执行 `printf()` 调用，并递增计数器变量，直到它最终等于 10。此时，条件 `jle` 指令不会执行；相反，指令指针将继续到无条件跳转指令，退出循环并结束程序。

# 回归基础

现在，编程的概念不那么抽象了，还有一些关于 C 语言的重要概念需要了解。汇编语言和计算机处理器在高级编程语言之前就存在了，许多现代编程概念都是随着时间的推移而演化的。就像对拉丁语的一点点了解可以极大地提高一个人对英语语言的理解一样，对底层编程概念的了解可以帮助理解高级概念。在继续下一节时，请记住，C 代码必须编译成机器指令后才能执行任何操作。

## 字符串

在前面的程序中传递给`printf()`函数的值`"Hello, world!\n"`是一个字符串——技术上讲，是一个字符数组。在 C 语言中，*数组*简单地是一系列特定数据类型的*n*个元素。一个 20 个字符的数组仅仅是内存中 20 个相邻的字符。数组也被称为*缓冲区*。char_array.c 程序是一个字符数组的例子。

### char_array.c

```
#include <stdio.h>
int main()
{
  char str_a[20];
  str_a[0]  = 'H';
  str_a[1]  = 'e';
  str_a[2]  = 'l';
  str_a[3]  = 'l';
  str_a[4]  = 'o';
  str_a[5]  = ',';
  str_a[6]  = ' ';
  str_a[7]  = 'w';
  str_a[8]  = 'o';
  str_a[9]  = 'r';
  str_a[10] = 'l';
  str_a[11] = 'd';
  str_a[12] = '!';
  str_a[13] = '\n';
  str_a[14] = 0;
  printf(str_a);
}
```

GCC 编译器也可以使用`-o`开关来定义编译输出的文件。此开关在下面用于将程序编译成名为`char_array`的可执行二进制文件。

```
reader@hacking:~/booksrc $ gcc -o char_array char_array.c
reader@hacking:~/booksrc $ ./char_array
Hello, world!
reader@hacking:~/booksrc $
```

在前面的程序中，定义了一个 20 个元素的字符数组`str_a`，并且逐个将数组元素写入。请注意，数字从 0 开始，而不是从 1 开始。同时请注意，最后一个字符是 0。（这通常也被称为*空字节*。）由于字符数组被定义，因此为它分配了 20 个字节，但实际上只使用了 12 个字节。末尾的空字节用作分隔符，以告诉任何处理字符串的函数在此处停止操作。剩余的额外字节只是垃圾，将被忽略。如果在字符数组的第五个元素中插入一个空字节，`printf()`函数只会打印出`Hello`。

由于逐个设置字符数组中的每个字符非常繁琐，而字符串的使用相当频繁，因此创建了一套标准函数用于字符串操作。例如，`strcpy()`函数将从源字符串复制到目标字符串，遍历源字符串并将每个字节复制到目标位置（并在复制空终止字节后停止）。函数参数的顺序类似于 Intel 汇编语法：目标在前，然后是源。char_array.c 程序可以使用`strcpy()`重写，以使用字符串库完成相同的功能。下面所示的 char_array 程序的下一个版本包括 string.h，因为它使用了字符串函数。

### char_array2.c

```
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20];

   strcpy(str_a, "Hello, world!\n");
   printf(str_a); 
}
```

让我们用 GDB 来看看这个程序。在下面的输出中，编译后的程序用 GDB 打开，并在加粗显示的`strcpy()`调用之前、期间和之后设置了断点。调试器将在每个断点暂停程序，给我们机会检查寄存器和内存。`strcpy()`函数的代码来自共享库，因此在此函数中设置断点实际上只能在程序执行后进行。

```
reader@hacking:~/booksrc $ gcc -g -o char_array2 char_array2.c
reader@hacking:~/booksrc $ gdb -q ./char_array2
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main() {
5          char str_a[20];
`6 7          strcpy(str_a, "Hello, world!\n"); 8          printf(str_a);`
9       }
(gdb) break 6

Breakpoint 1 at 0x80483c4: file char_array2.c, line 6.
(gdb) break strcpy
Function "strcpy" not defined.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 2 (strcpy) pending.
(gdb) break 8
Breakpoint 3 at 0x80483d7: file char_array2.c, line 8\. 
(gdb)
```

当程序运行时，`strcpy()`断点被解决。在每个断点处，我们将查看 EIP 及其指向的指令。请注意，中间断点的 EIP 内存位置不同。

```
(gdb) run
Starting program: /home/reader/booksrc/char_array2 
Breakpoint 4 at 0xb7f076f4
Pending breakpoint "strcpy" resolved

Breakpoint 1, main () at char_array2.c:7
7          strcpy(str_a, "Hello, world!\n");
(gdb) i r eip
eip            0x80483c4        0x80483c4 <main+16>
(gdb) x/5i $eip
0x80483c4 <main+16>:    mov    DWORD PTR [esp+4],0x80484c4
0x80483cc <main+24>:    lea    eax,[ebp-40]
0x80483cf <main+27>:    mov    DWORD PTR [esp],eax
0x80483d2 <main+30>:    call   0x80482c4 <strcpy@plt>
0x80483d7 <main+35>:    lea    eax,[ebp-40]
(gdb) continue
Continuing.

Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
(gdb) i r eip
`eip            0xb7f076f4       0xb7f076f4 <strcpy+4>`
(gdb) x/5i $eip
0xb7f076f4 <strcpy+4>:  mov    esi,DWORD PTR [ebp+8]
0xb7f076f7 <strcpy+7>:  mov    eax,DWORD PTR [ebp+12]
0xb7f076fa <strcpy+10>: mov    ecx,esi
0xb7f076fc <strcpy+12>: sub    ecx,eax
0xb7f076fe <strcpy+14>: mov    edx,eax
(gdb) continue
Continuing.

Breakpoint 3, main () at char_array2.c:8
8          printf(str_a);
(gdb) i r eip
eip            0x80483d7        0x80483d7 <main+35>
(gdb) x/5i $eip
0x80483d7 <main+35>:    lea    eax,[ebp-40]
0x80483da <main+38>:    mov    DWORD PTR [esp],eax
0x80483dd <main+41>:    call   0x80482d4 <printf@plt>
0x80483e2 <main+46>:    leave
0x80483e3 <main+47>:    ret
(gdb)
```

中间断点处的 EIP 地址不同，因为`strcpy()`函数的代码来自一个已加载的库。实际上，调试器显示中间断点处的`strcpy()`函数的 EIP，而其他两个断点处的 EIP 在`main()`函数中。我想指出，EIP 能够从主代码跳转到`strcpy()`代码，然后再返回。每次函数被调用时，都会在称为堆栈的数据结构上保留一个记录。堆栈允许 EIP 通过一系列函数调用返回。在 GDB 中，可以使用`bt`命令来回溯堆栈。在下面的输出中，堆栈回溯显示在每个断点处。

```
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/char_array2 
Error in re-setting breakpoint 4:
Function "strcpy" not defined.

Breakpoint 1, main () at char_array2.c:7
7          strcpy(str_a, "Hello, world!\n");
(gdb) bt
#0  main () at char_array2.c:7
(gdb) cont
Continuing.

Breakpoint 4, 0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
(gdb) bt
#0  0xb7f076f4 in strcpy () from /lib/tls/i686/cmov/libc.so.6
#1  0x080483d7 in main () at char_array2.c:7
(gdb) cont
Continuing.

Breakpoint 3, main () at char_array2.c:8
8          printf(str_a);
(gdb) bt
#0  main () at char_array2.c:8
(gdb)
```

在中间断点处，堆栈的回溯显示了`strcpy()`函数的调用记录。同时，你可能注意到在第二次运行时`strcpy()`函数的地址略有不同。这是由于自 Linux 内核 2.6.11 以来默认启用的一个利用保护方法。我们将在稍后详细讨论这个保护机制。

## 签名，未签名，长整型和短整型

默认情况下，C 语言中的数值是有符号的，这意味着它们可以是负数也可以是正数。相比之下，无符号值不允许负数。由于最终都是内存，所有数值都必须以二进制形式存储，无符号值在二进制中更有意义。一个 32 位无符号整数可以包含从 0（所有二进制 0）到 4,294,967,295（所有二进制 1）的值。一个 32 位有符号整数仍然是 32 位，这意味着它只能处于 2³²种可能的位组合之一。这允许 32 位有符号整数从-2,147,483,648 到 2,147,483,647 的范围。本质上，其中一位是一个标记值正或负的标志。正的有符号值看起来和无符号值一样，但负数使用称为二进制补码的方法存储。二进制补码以适合二进制加法器的方式表示负数——当二进制补码中的负值与相同大小的正值相加时，结果将是 0。这是通过首先以二进制形式写出正数，然后反转所有位，最后加 1 来完成的。这听起来很奇怪，但它确实有效，并允许使用简单的二进制加法器将负数与正数相加。

这可以通过使用`pcalc`（一个简单的程序员计算器，以十进制、十六进制和二进制格式显示结果）在较小的规模上快速探索。为了简化，本例中使用 8 位数字。

```
reader@hacking:~/booksrc $ pcalc 0y01001001
        73              0x49            0y1001001
reader@hacking:~/booksrc $ pcalc 0y10110110 + 1
        183             0xb7            0y10110111
reader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111
        256             0x100           0y100000000
reader@hacking:~/booksrc $
```

首先，二进制值 01001001 被显示为正 73。然后所有位都被反转，并加 1 得到负 73 的二进制补码表示 10110111。当这两个值相加时，原始 8 位的结果为 0。程序`pcalc`显示值为 256，因为它不知道我们只处理 8 位值。在二进制加法器中，那个进位位会被丢弃，因为变量的内存末尾已经到达。这个例子可能有助于阐明二进制补码是如何发挥其魔力的。

在 C 语言中，可以通过在声明前简单添加关键字`unsigned`来声明变量为无符号。无符号整数可以用`unsigned int`声明。此外，可以通过添加关键字`long`或`short`来扩展或缩短数值变量的大小。实际的大小将取决于代码编译的架构。C 语言提供了一种名为`sizeof()`的宏，可以确定某些数据类型的大小。这就像一个函数，它接受一个数据类型作为输入，并返回目标架构上用该数据类型声明的变量的大小。`datatype_sizes.c`程序通过使用`sizeof()`函数探索各种数据类型的大小。

### datatype_sizes.c

```
#include <stdio.h>

int main() {
   printf("The 'int' data type is\t\t %d bytes\n", sizeof(int));
   printf("The 'unsigned int' data type is\t %d bytes\n", sizeof(unsigned int));
   printf("The 'short int' data type is\t %d bytes\n", sizeof(short int));
   printf("The 'long int' data type is\t %d bytes\n", sizeof(long int));
   printf("The 'long long int' data type is %d bytes\n", sizeof(long long int));
   printf("The 'float' data type is\t %d bytes\n", sizeof(float));
   printf("The 'char' data type is\t\t %d bytes\n", sizeof(char));
}
```

这段代码以稍微不同的方式使用了`printf()`函数。它使用了一种称为格式说明符的东西来显示`sizeof()`函数调用返回的值。格式说明符将在稍后深入解释，所以现在让我们只关注程序输出。

```
reader@hacking:~/booksrc $ gcc datatype_sizes.c
reader@hacking:~/booksrc $ ./a.out
The 'int' data type is           4 bytes
The 'unsigned int' data type is  4 bytes
The 'short int' data type is     2 bytes
The 'long int' data type is      4 bytes
The 'long long int' data type is 8 bytes
The 'float' data type is         4 bytes
The 'char' data type is          1 bytes
reader@hacking:~/booksrc $
```

如前所述，在*x*86 架构上，有符号和无符号整数的大小都是四字节。浮点数也是四字节，而字符只需要一个字节。`long`和`short`关键字也可以与浮点变量一起使用，以扩展和缩短它们的大小。

## 指针

EIP 寄存器是一个指针，在程序执行过程中通过包含其内存地址来“指向”当前指令。指针的概念在 C 语言中也被使用。由于物理内存实际上不能移动，其中的信息必须被复制。复制大量内存以供不同函数或不同地方使用可能会非常耗费计算资源。从内存的角度来看，这也是昂贵的，因为必须在复制源之前保存或分配新目标复制所需的空间。指针是解决这个问题的方法。而不是复制一大块内存，传递那块内存块的起始地址要简单得多。

C 语言中的指针可以像任何其他变量类型一样定义和使用。由于*x*86 架构上的内存使用 32 位寻址，指针的大小也是 32 位（4 字节）。指针通过在变量名前加上一个星号(*)来定义。不是定义一个该类型的变量，而是定义一个指向该类型数据的指针。`pointer.c`程序是一个使用`char`数据类型的指针的例子，`char`数据类型的大小仅为 1 字节。

### pointer.c

```
#include <stdio.h>
#include <string.h>

int main() {
   char str_a[20]; // A 20-element character array
   char *pointer;  // A pointer, meant for a character array
   char *pointer2; // And yet another one

   strcpy(str_a, "Hello, world!\n");
   pointer = str_a; // Set the first pointer to the start of the array.
   printf(pointer);

   pointer2 = pointer + 2; // Set the second one 2 bytes further in.
   printf(pointer2);       // Print it.
   strcpy(pointer2, "y you guys!\n"); // Copy into that spot.
   printf(pointer);        // Print again.
}
```

如代码中的注释所示，第一个指针被设置在字符数组的起始位置。当以这种方式引用字符数组时，它实际上就是一个指针。这就是这个缓冲区之前是如何作为一个指针传递给`printf()`和`strcpy()`函数的。第二个指针被设置为第一个指针的地址加 2，然后打印了一些内容（如下面的输出所示）。

```
reader@hacking:~/booksrc $ gcc -o pointer pointer.c
reader@hacking:~/booksrc $ ./pointer
Hello, world!
llo, world!
Hey you guys!
reader@hacking:~/booksrc $
```

让我们用 GDB 来看看这个例子。程序被重新编译，并在源代码的第 10 行设置了断点。这将使得程序在将`"Hello, world!\n"`字符串复制到`str_a`缓冲区并且指针变量被设置为它的起始地址后停止。

```
reader@hacking:~/booksrc $ gcc -g -o pointer pointer.c
reader@hacking:~/booksrc $ gdb -q ./pointer
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main()  {
5           char str_a[20]; // A 20-element character array
6           char *pointer;  // A pointer, meant for a character array
7           char *pointer2; // And yet another one
8
9           strcpy(str_a, "Hello, world!\n");
10          pointer = str_a; // Set the first pointer to the start of the array.
(gdb)
11          printf(pointer);
12
13          pointer2 = pointer + 2; // Set the second one 2 bytes further in.
14          printf(pointer2); // Print it.
15          strcpy(pointer2, "y you guys!\n"); // Copy into that spot.
16          printf(pointer); // Print again.
17      }
(gdb) break 11
Breakpoint 1 at 0x80483dd: file pointer.c, line 11.
(gdb) run
Starting program: /home/reader/booksrc/pointer

Breakpoint 1, main () at pointer.c:11
11         printf(pointer);
(gdb) x/xw pointer
0xbffff7e0:     0x6c6c6548
(gdb) x/s pointer
0xbffff7e0:      "Hello, world!\n"
(gdb)
```

当指针被作为一个字符串检查时，很明显给定的字符串就在那里，并且位于内存地址`0xbffff7e0`。记住，字符串本身并没有存储在指针变量中——只有内存地址`0xbffff7e0`被存储在那里。

为了看到指针变量中实际存储的数据，你必须使用地址运算符。地址运算符是一个*一元运算符*，这意味着它只对一个参数进行操作。这个运算符只是变量名前加上一个&符号。当它被使用时，返回的是变量的地址，而不是变量本身。这个运算符在 GDB 和 C 编程语言中都存在。

```
(gdb) x/xw &pointer
0xbffff7dc:     0xbffff7e0
(gdb) print &pointer
$1 = (char **) 0xbffff7dc
(gdb) print pointer
$2 = 0xbffff7e0 "Hello, world!\n"
(gdb)
```

当使用地址运算符时，指针变量显示其在内存中的地址为`0xbffff7dc`，并且它包含地址`0xbffff7e0`。

地址运算符通常与指针一起使用，因为指针包含内存地址。`addressof.c`程序演示了地址运算符被用来将一个整型变量的地址放入指针中。下面这行内容被加粗显示。

### addressof.c

```
#include <stdio.h>

int main() {
   int int_var = 5;
   int *int_ptr;

`int_ptr = &int_var; // put the address of int_var into int_ptr`
}
```

程序本身实际上并没有输出任何内容，但你可能猜得出会发生什么，甚至在用 GDB 调试之前。

```
reader@hacking:~/booksrc $ gcc -g addressof.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list
1       #include <stdio.h>
2
3       int main() {
4               int int_var = 5;
5               int *int_ptr;
6
7               int_ptr = &int_var; // Put the address of int_var into int_ptr.
8       }
(gdb) break 8
Breakpoint 1 at 0x8048361: file addressof.c, line 8.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at addressof.c:8
8       }
(gdb) print int_var
$1 = 5
(gdb) print &int_var
$2 = (int *) 0xbffff804
(gdb) print int_ptr
$3 = (int *) 0xbffff804
(gdb) print &int_ptr
$4 = (int **) 0xbffff800
(gdb)
```

如往常一样，设置了断点并在调试器中执行程序。此时，程序的大部分已经执行完毕。第一个`print`命令显示了`int_var`的值，第二个显示了它的地址，使用了地址运算符。接下来的两个打印命令显示了`int_ptr`包含`int_var`的地址，并且还显示了`int_ptr`的地址作为额外信息。

存在着一个额外的单目运算符，称为解引用运算符，用于与指针一起使用。这个运算符将返回指针指向的地址中的数据，而不是地址本身。它以变量名前的星号(*)形式出现，类似于指针的声明。再次强调，解引用运算符在 GDB 和 C 中都存在。在 GDB 中使用时，它可以检索 `int_ptr` 指向的整数值。

```
(gdb) print *int_ptr
$5 = 5
```

在 addressof.c 代码（在 addressof2.c 中显示）中添加一些内容（将演示所有这些概念。添加的 `printf()` 函数使用格式参数，我将在下一节中解释。现在，只需关注程序输出即可。

### addressof2.c

```
#include <stdio.h>

int main() {
   int int_var = 5;
   int *int_ptr;

   int_ptr = &int_var; // Put the address of int_var into int_ptr.

   printf("int_ptr = 0x%08x\n", int_ptr);
   printf("&int_ptr = 0x%08x\n", &int_ptr);
   printf("*int_ptr = 0x%08x\n\n", *int_ptr);

   printf("int_var is located at 0x%08x and contains %d\n", &int_var, int_var);
   printf("int_ptr is located at 0x%08x, contains 0x%08x, and points to %d\n\n",
      &int_ptr, int_ptr, *int_ptr);
}
```

编译并执行 addressof2.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc addressof2.c
reader@hacking:~/booksrc $ ./a.out
int_ptr = 0xbffff834
&int_ptr = 0xbffff830
*int_ptr = 0x00000005

int_var is located at 0xbffff834 and contains 5
int_ptr is located at 0xbffff830, contains 0xbffff834, and points to 5

reader@hacking:~/booksrc $
```

当单目运算符与指针一起使用时，地址运算符可以被认为是向相反方向移动，而解引用运算符则沿着指针指向的方向前进。

## 格式字符串

`printf()` 函数不仅可以打印固定字符串，还可以使用格式字符串以多种不同的格式打印变量。*格式字符串* 只是一个包含特殊转义序列的字符字符串，这些转义序列告诉函数在转义序列的位置插入以特定格式打印的变量。在前面程序中使用 `printf()` 函数的方式中，`"Hello, world!\n"` 字符串在技术上是一个格式字符串；然而，它没有特殊的转义序列。这些 *转义序列* 也被称为 *格式参数*，并且对于格式字符串中找到的每个格式参数，函数都期望有一个额外的参数。每个格式参数以百分号(%)开头，并使用与 GDB 的 examine 命令中使用的格式字符非常相似的单一字符缩写。

| 参数 | 输出类型 |
| --- | --- |
| `%d` | 十进制 |
| `%u` | 无符号十进制 |
| `%x` | 十六进制 |

所有的前述格式参数都接收它们的值，而不是值的指针。还有一些格式参数期望指针，如下所示。

| 参数 | 输出类型 |
| --- | --- |
| `%s` | 字符串 |
| `%n` | 已写入的字节数 |

`%s` 格式参数期望得到一个内存地址；它将打印该内存地址处的数据，直到遇到空字节。`%n` 格式参数是独一无二的，因为它实际上会写入数据。它也期望得到一个内存地址，并将迄今为止写入该内存地址的字节数写入进去。

现在，我们的重点将只是用于显示数据的格式参数。fmt_strings.c 程序展示了不同格式参数的一些示例。

### fmt_strings.c

```
#include <stdio.h>

int main() {
   char string[10];
   int A = -73;
   unsigned int B = 31337;

   strcpy(string, "sample");
   // Example of printing with different format string
   printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
   printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
   printf("[field width on B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
   printf("[string] %s Address %08x\n", string, string);

   // Example of unary address operator (dereferencing) and a %x format string
   printf("variable A is at address: %08x\n", &A);
}
```

在前面的代码中，为格式字符串中的每个格式参数的每个 `printf()` 调用传递了额外的变量参数。最后的 `printf()` 调用使用参数 `A`，这将提供变量 `A` 的地址。程序的编译和执行如下。

```
reader@hacking:~/booksrc $ gcc -o fmt_strings fmt_strings.c
reader@hacking:~/booksrc $ ./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[field width on B] 3: '31337', 10: '     31337', '00031337'
[string] sample Address  bffff870
variable A is at address: bffff86c
reader@hacking:~/booksrc $
```

`printf()` 的前两次调用演示了使用不同的格式参数打印变量 `A` 和 `B`。由于每行有三个格式参数，变量 `A` 和 `B` 需要分别提供三次。`%d` 格式参数允许负值，而 `%u` 不允许，因为它期望无符号值。

当变量 `A` 使用 `%u` 格式参数打印时，它显示为一个非常高的值。这是因为 `A` 是一个以二进制补码形式存储的负数，而格式参数正试图将其作为无符号值打印。由于二进制补码翻转所有位并加一，之前为零的高位现在变为一位。

示例中的第三行，标记为 `[field width on B]`，展示了在格式参数中使用字段宽度选项。这只是一个指定该格式参数的最小字段宽度的整数。然而，这并不是最大字段宽度——如果要输出的值大于字段宽度，则字段宽度将被超出。当使用 3 时就会发生这种情况，因为输出数据需要 5 个字节。当使用 10 作为字段宽度时，在输出数据之前输出 5 个空格字节。此外，如果字段宽度值以 0 开头，这意味着字段应该用零填充。例如，当使用 08 时，输出为 00031337。

标记为 `[string]` 的第四行简单地展示了 `%s` 格式参数的使用。记住，变量字符串实际上是一个包含字符串地址的指针，这工作得非常好，因为 `%s` 格式参数期望通过引用传递数据。

最后的行仅显示了变量 `A` 的地址，使用一元地址运算符取消引用变量。此值以八个十六进制数字显示，并用零填充。

如这些示例所示，你应该使用 `%d` 打印十进制值，使用 `%u` 打印无符号值，使用 `%x` 打印十六进制值。可以通过在百分号后直接放置一个数字来设置最小字段宽度，如果字段宽度以 0 开头，它将被零填充。`%s` 参数可以用来打印字符串，并且应该传递字符串的地址。到目前为止，一切顺利。

格式字符串被一系列标准 I/O 函数使用，包括`scanf()`，它基本上像`printf()`一样工作，但用于输入而不是输出。一个关键的区别是，`scanf()`函数期望其所有参数都是指针，因此参数必须是变量地址——而不是变量本身。这可以通过使用指针变量或使用一元地址运算符来检索普通变量的地址来实现。`input.c`程序和执行结果应该有助于解释。

### `input.c`

```
#include <stdio.h>
#include <string.h>

int main() {
   char message[10];
   int count, i;

   strcpy(message, "Hello, world!");

   printf("Repeat how many times? ");
   scanf("%d", &count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, message);
}
```

在`input.c`文件中，使用`scanf()`函数来设置`count`变量。下面的输出展示了其用法。

```
reader@hacking:~/booksrc $ gcc -o input input.c
reader@hacking:~/booksrc $ ./input
Repeat how many times? 3
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!
reader@hacking:~/booksrc $ ./input
Repeat how many times? 12
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!
  3 - Hello, world!
  4 - Hello, world!
  5 - Hello, world!
  6 - Hello, world!
  7 - Hello, world!
  8 - Hello, world!
  9 - Hello, world!
 10 - Hello, world!
 11 - Hello, world!
reader@hacking:~/booksrc $
```

格式字符串被非常频繁地使用，因此熟悉它们是有价值的。此外，能够输出变量的值允许在程序中进行调试，而不需要使用调试器。对于黑客的学习过程来说，某种形式的即时反馈是相当关键的，而像打印变量值这样简单的事情就可以允许进行大量的利用。

## 类型转换

*类型转换*只是临时改变变量数据类型的一种方法，尽管它最初是如何定义的。当一个变量被转换为不同类型时，编译器基本上被指示将那个变量视为新数据类型，但仅限于该操作。类型转换的语法如下：

```
(typecast_data_type) variable
```

这可以在处理整数和浮点变量时使用，正如`typecasting.c`文件所展示的。

### `typecasting.c`

```
#include <stdio.h>

int main() {
   int a, b;
   float c, d;

   a = 13;
   b = 5;

   c = a / b;                 // Divide using integers.
   d = (float) a / (float) b; // Divide integers typecast as floats.

   printf("[integers]\t a = %d\t b = %d\n", a, b);
   printf("[floats]\t c = %f\t d = %f\n", c, d);
}
```

编译和执行`typecasting.c`的结果如下。

```
reader@hacking:~/booksrc $ gcc typecasting.c
reader@hacking:~/booksrc $ ./a.out
[integers]       a = 13 b = 5
[floats]         c = 2.000000    d = 2.600000
reader@hacking:~/booksrc $
```

如前所述，将整数 13 除以 5 将向下取整到错误答案 2，即使这个值被存储到浮点变量中。然而，如果这些整数变量被转换为浮点数，它们将被视为这样。这允许正确计算 2.6。

这个例子是说明性的，但类型转换真正发挥作用的地方是当它与指针变量一起使用时。尽管指针只是一个内存地址，但 C 编译器仍然要求每个指针都有一个数据类型。这样做的一个原因是为了尽量减少编程错误。整数指针应该只指向整数数据，而字符指针应该只指向字符数据。另一个原因是用于指针算术。整数的大小是四个字节，而字符只占用一个字节。`pointer_types.c`程序将进一步演示和解释这些概念。此代码使用格式参数`%p`来输出内存地址。这是一个用于显示指针的简写，基本上等同于`0x%08x`。

### `pointer_types.c`

```
#include <stdio.h>

int main() {
   int i;

   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
   int int_array[5] = {1, 2, 3, 4, 5};

   char *char_pointer;
   int *int_pointer;

   char_pointer = char_array;
   int_pointer = int_array;

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[integer pointer] points to %p, which contains the integer %d\n",
            int_pointer, *int_pointer);
      int_pointer = int_pointer + 1;
   }

   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.
      printf("[char pointer] points to %p, which contains the char '%c'\n",
            char_pointer, *char_pointer);
      char_pointer = char_pointer + 1;
   }
}
```

在此代码中，内存中定义了两个数组——一个包含整数数据，另一个包含字符数据。还定义了两个指针，一个具有整数数据类型，一个具有字符数据类型，并将它们设置为指向对应数据数组的起始位置。两个独立的 for 循环通过指针算术迭代数组，以调整指针指向下一个值。在循环中，当使用`%d`和`%c`格式参数实际打印整数和字符值时，请注意相应的`printf()`参数必须取消引用指针变量。这是通过使用一元`*`运算符完成的，并在上面用粗体标出。

```
reader@hacking:~/booksrc $ gcc pointer_types.c
reader@hacking:~/booksrc $ ./a.out
[integer pointer] points to 0xbffff7f0, which contains the integer 1
[integer pointer] points to 0xbffff7f4, which contains the integer 2
[integer pointer] points to 0xbffff7f8, which contains the integer 3
[integer pointer] points to 0xbffff7fc, which contains the integer 4
[integer pointer] points to 0xbffff800, which contains the integer 5
[char pointer] points to 0xbffff810, which contains the char 'a'
[char pointer] points to 0xbffff811, which contains the char 'b'
[char pointer] points to 0xbffff812, which contains the char 'c'
[char pointer] points to 0xbffff813, which contains the char 'd'
[char pointer] points to 0xbffff814, which contains the char 'e'
reader@hacking:~/booksrc $
```

即使在各自的循环中向`int_pointer`和`char_pointer`添加相同的值 1，编译器也会以不同的数量增加指针的地址。由于 char 只有 1 个字节，指向下一个 char 的指针自然会多 1 个字节。但既然整数是 4 个字节，指向下一个整数的指针就必须多 4 个字节。

在 pointer_types2.c 中，指针被并置，使得`int_pointer`指向字符数据，反之亦然。代码的主要更改用粗体标出。

### pointer_types2.c

```
#include <stdio.h>

int main() {
   int i;

   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
   int int_array[5] = {1, 2, 3, 4, 5};

   char *char_pointer;
   int *int_pointer;

   `char_pointer = int_array; // The char_pointer and int_pointer now    int_pointer = char_array; // point to incompatible data types.`

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[integer pointer] points to %p, which contains the char '%c'\n",
            int_pointer, *int_pointer);
      int_pointer = int_pointer + 1;
   }

   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.
      printf("[char pointer] points to %p, which contains the integer %d\n",
            char_pointer, *char_pointer);
      char_pointer = char_pointer + 1;
   }
}
```

下面的输出显示了编译器输出的警告。

```
reader@hacking:~/booksrc $ gcc pointer_types2.c
pointer_types2.c: In function `main':
pointer_types2.c:12: warning: assignment from incompatible pointer type
pointer_types2.c:13: warning: assignment from incompatible pointer type
reader@hacking:~/booksrc $
```

为了防止编程错误，编译器会对指向不兼容数据类型的指针给出警告。但编译器和可能还有程序员是唯一关心指针类型的人。在编译后的代码中，指针不过是一个内存地址，所以如果指针指向不兼容的数据类型，编译器仍然会编译代码——它只是警告程序员要预料到意外的结果。

```
reader@hacking:~/booksrc $ ./a.out
[integer pointer] points to 0xbffff810, which contains the char 'a'
[integer pointer] points to 0xbffff814, which contains the char 'e'
[integer pointer] points to 0xbffff818, which contains the char '8'
[integer pointer] points to 0xbffff81c, which contains the char '
[integer pointer] points to 0xbffff820, which contains the char '?'
[char pointer] points to 0xbffff7f0, which contains the integer 1
[char pointer] points to 0xbffff7f1, which contains the integer 0
[char pointer] points to 0xbffff7f2, which contains the integer 0
[char pointer] points to 0xbffff7f3, which contains the integer 0
[char pointer] points to 0xbffff7f4, which contains the integer 2
reader@hacking:~/booksrc $
```

即使`int_pointer`指向的字符数据只包含 5 个字节的数据，它仍然被类型化为整数。这意味着每次向指针添加 1 时，地址会增加 4。同样，`char_pointer`的地址每次只增加 1，逐字节遍历 20 个字节的整数数据（五个 4 字节的整数）。再次强调，当逐字节检查 4 字节的整数时，整数数据的 littleendian 字节序是明显的。`0x00000001`的 4 字节值实际上在内存中存储为`0x01, 0x00, 0x00, 0x00`。

将会出现这种情况，即你使用了一个指向具有冲突类型的数据的指针。由于指针类型决定了它指向的数据的大小，因此确保类型正确非常重要。正如你在下面的 pointer_types3.c 中可以看到，类型转换只是动态更改变量类型的一种方式。

### pointer_types3.c

```
#include <stdio.h>

int main() {
   int i;

   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
   int int_array[5] = {1, 2, 3, 4, 5};

   char *char_pointer;
   int *int_pointer;

   char_pointer = (char *) int_array; // Typecast into the
   int_pointer = (int *) char_array;  // pointer's data type.

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[integer pointer] points to %p, which contains the char '%c'\n",
            int_pointer, *int_pointer);
      `int_pointer = (int *) ((char *) int_pointer + 1);`
   }

   for(i=0; i < 5; i++) { // Iterate through the char array with the char_pointer.
      printf("[char pointer] points to %p, which contains the integer %d\n",
            char_pointer, *char_pointer);
      `char_pointer = (char *) ((int *) char_pointer + 1);`
   }
}
```

在此代码中，当指针最初设置时，数据会被转换成指针的数据类型。这将防止 C 编译器对冲突的数据类型发出抱怨；然而，任何指针运算仍然是不正确的。为了修复这个问题，当向指针加 1 时，它们必须首先被转换成正确的数据类型，以便地址能以正确的量增加。然后这个指针需要再次被转换回指针的数据类型。这看起来不太美观，但它是有效的。

```
reader@hacking:~/booksrc $ gcc pointer_types3.c
reader@hacking:~/booksrc $ ./a.out
[integer pointer] points to 0xbffff810, which contains the char 'a'
[integer pointer] points to 0xbffff811, which contains the char 'b'
[integer pointer] points to 0xbffff812, which contains the char 'c'
[integer pointer] points to 0xbffff813, which contains the char 'd'
[integer pointer] points to 0xbffff814, which contains the char 'e'
[char pointer] points to 0xbffff7f0, which contains the integer 1
[char pointer] points to 0xbffff7f4, which contains the integer 2
[char pointer] points to 0xbffff7f8, which contains the integer 3
[char pointer] points to 0xbffff7fc, which contains the integer 4
[char pointer] points to 0xbffff800, which contains the integer 5
reader@hacking:~/booksrc $
```

自然地，一开始就为指针使用正确的数据类型要容易得多；然而，有时需要一个通用的、无类型的指针。在 C 语言中，空指针是一个无类型的指针，由`void`关键字定义。对空指针的实验很快就会揭示关于无类型指针的一些事情。首先，指针不能被取消引用除非它们有一个类型。为了检索指针内存地址中存储的值，编译器必须首先知道它是什么类型的数据。其次，在进行指针运算之前，空指针也必须进行类型转换。这些限制相当直观，这意味着空指针的主要目的是简单地持有内存地址。

可以通过每次使用时将其类型转换成正确的类型来修改 pointer_types3.c 程序，以使用单个空指针。编译器知道空指针是无类型的，所以任何类型的指针都可以存储在空指针中而不需要类型转换。这也意味着在取消引用时，空指针必须始终进行类型转换。这些差异可以在使用空指针的 pointer_types4.c 中看到。

### pointer_types4.c

```
#include <stdio.h>

int main() {
   int i;

   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
   int int_array[5] = {1, 2, 3, 4, 5};

   void *void_pointer;

   void_pointer = (void *) char_array;

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[char pointer] points to %p, which contains the char '%c'\n",
            void_pointer, *((char *) void_pointer));
      void_pointer = (void *) ((char *) void_pointer + 1);
   }

   void_pointer = (void *) int_array;

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[integer pointer] points to %p, which contains the integer %d\n",
            void_pointer, *((int *) void_pointer));
      void_pointer = (void *) ((int *) void_pointer + 1);
   }
}
```

编译和执行 pointer_types4.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc pointer_types4.c
reader@hacking:~/booksrc $ ./a.out
[char pointer] points to 0xbffff810, which contains the char 'a'
[char pointer] points to 0xbffff811, which contains the char 'b'
[char pointer] points to 0xbffff812, which contains the char 'c'
[char pointer] points to 0xbffff813, which contains the char 'd'
[char pointer] points to 0xbffff814, which contains the char 'e'
[integer pointer] points to 0xbffff7f0, which contains the integer 1
[integer pointer] points to 0xbffff7f4, which contains the integer 2
[integer pointer] points to 0xbffff7f8, which contains the integer 3
[integer pointer] points to 0xbffff7fc, which contains the integer 4
[integer pointer] points to 0xbffff800, which contains the integer 5
reader@hacking:~/booksrc $
```

pointer_types4.c 的编译和输出基本上与 pointer_types3.c 相同。空指针实际上只是持有内存地址，而硬编码的类型转换则告诉编译器在指针使用时使用正确的类型。

由于类型由类型转换处理，空指针实际上不过是一个内存地址。通过类型转换定义的数据类型，任何足够大以容纳四个字节值的对象都可以像空指针一样工作。在 pointer_types5.c 中，使用无符号整数来存储这个地址。

### pointer_types5.c

```
#include <stdio.h>

int main() {
   int i;

   char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
   int int_array[5] = {1, 2, 3, 4, 5};

   unsigned int hacky_nonpointer;

   hacky_nonpointer = (unsigned int) char_array;

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[hacky_nonpointer] points to %p, which contains the char '%c'\n",
            hacky_nonpointer, *((char *) hacky_nonpointer));
      `hacky_nonpointer = hacky_nonpointer + sizeof(char);`
   }

   hacky_nonpointer = (unsigned int) int_array;

   for(i=0; i < 5; i++) { // Iterate through the int array with the int_pointer.
      printf("[hacky_nonpointer] points to %p, which contains the integer %d\n",
            hacky_nonpointer, *((int *) hacky_nonpointer));
      `hacky_nonpointer = hacky_nonpointer + sizeof(int);`
   }
}
```

这相当是种权宜之计，但因为这个整数值在赋值和取消引用时被转换成了正确的指针类型，最终结果是一样的。注意，不是通过多次类型转换对无符号整数（它甚至不是一个指针）进行指针运算，而是使用`sizeof()`函数通过常规算术达到相同的结果。

```
reader@hacking:~/booksrc $ gcc pointer_types5.c
reader@hacking:~/booksrc $ ./a.out
[hacky_nonpointer] points to 0xbffff810, which contains the char 'a'
[hacky_nonpointer] points to 0xbffff811, which contains the char 'b'
[hacky_nonpointer] points to 0xbffff812, which contains the char 'c'
[hacky_nonpointer] points to 0xbffff813, which contains the char 'd'
[hacky_nonpointer] points to 0xbffff814, which contains the char 'e'
[hacky_nonpointer] points to 0xbffff7f0, which contains the integer 1
[hacky_nonpointer] points to 0xbffff7f4, which contains the integer 2
[hacky_nonpointer] points to 0xbffff7f8, which contains the integer 3
[hacky_nonpointer] points to 0xbffff7fc, which contains the integer 4
[hacky_nonpointer] points to 0xbffff800, which contains the integer 5
reader@hacking:~/booksrc $
```

关于 C 语言中的变量，需要记住的重要一点是编译器是唯一关心变量类型的。最终，在程序编译完成后，变量不过是一些内存地址。这意味着可以通过告诉编译器将它们类型转换为所需的类型，轻松地将一种类型的变量强制转换为另一种类型的行为。

## 命令行参数

许多非图形程序以命令行参数的形式接收输入。与使用`scanf()`输入不同，命令行参数在程序开始执行后不需要用户交互。这通常更高效，并且是一种有用的输入方法。

在 C 语言中，可以通过向函数添加两个额外的参数来在`main()`函数中访问命令行参数：一个整数和一个指向字符串数组的指针。整数将包含参数的数量，字符串数组将包含每个参数。commandline.c 程序及其执行应该能解释清楚。

### commandline.c

```
#include <stdio.h>

int main(int arg_count, char *arg_list[]) {
   int i;
   printf("There were %d arguments provided:\n", arg_count);
   for(i=0; i < arg_count; i++)
      printf("argument #%d\t-\t%s\n", i, arg_list[i]);
}
reader@hacking:~/booksrc $ gcc -o commandline commandline.c
reader@hacking:~/booksrc $ ./commandline
There were 1 arguments provided:
argument #0     -       ./commandline
reader@hacking:~/booksrc $ ./commandline this is a test
There were 5 arguments provided:
argument #0     -       ./commandline
argument #1     -       this
argument #2     -       is
argument #3     -       a
argument #4     -       test
reader@hacking:~/booksrc $
```

零级参数始终是执行二进制的名称，其余的参数数组（通常称为*参数向量*）包含剩余的参数作为字符串。

有时程序可能希望将命令行参数用作整数而不是字符串。不管怎样，参数都是以字符串的形式传递的；然而，存在标准转换函数。与简单的类型转换不同，这些函数实际上可以将包含数字的字符数组转换为实际的整数。这些函数中最常见的是`atoi()`，它是*ASCII to integer*的缩写。这个函数接受一个指向字符串的指针作为其参数，并返回它所表示的整数值。观察它在 convert.c 中的使用。

### convert.c

```
#include <stdio.h>

void usage(char *program_name) {
   printf("Usage: %s <message> <# of times to repeat>\n", program_name);
   exit(1);
}

int main(int argc, char *argv[]) {
   int i, count;

   if(argc < 3)      // If fewer than 3 arguments are used,
      usage(argv[0]); // display usage message and exit.

   count = atoi(argv[2]); // Convert the 2nd arg into an integer.
   printf("Repeating %d times..\n", count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, argv[1]); // Print the 1st arg.
}
```

编译并执行 convert.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc convert.c
reader@hacking:~/booksrc $ ./a.out
Usage: ./a.out <message> <# of times to repeat>
reader@hacking:~/booksrc $ ./a.out 'Hello, world!' 3
Repeating 3 times..
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!
reader@hacking:~/booksrc $
```

在前面的代码中，一个`if`语句确保在访问这些字符串之前使用了三个参数。如果程序尝试访问不存在或程序没有权限读取的内存，程序将会崩溃。在 C 语言中，检查这些类型的条件并在程序逻辑中处理它们非常重要。如果注释掉了错误检查的`if`语句，就可以探索这种内存违规。convert2.c 程序应该使这一点更加明确。

### convert2.c

```
#include <stdio.h>

void usage(char *program_name) {
   printf("Usage: %s <message> <# of times to repeat>\n", program_name);
   exit(1);
}

int main(int argc, char *argv[]) {
   int i, count;

//  if(argc < 3)      // If fewer than 3 arguments are used,
//    usage(argv[0]); // display usage message and exit.

   count = atoi(argv[2]); // Convert the 2nd arg into an integer.
   printf("Repeating %d times..\n", count);

   for(i=0; i < count; i++)
      printf("%3d - %s\n", i, argv[1]); // Print the 1st arg.
}
```

编译并执行 convert2.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc convert2.c
reader@hacking:~/booksrc $ ./a.out test
Segmentation fault (core dumped)
reader@hacking:~/booksrc $
```

当程序没有足够的命令行参数时，它仍然试图访问参数数组中的元素，即使它们不存在。这导致程序由于段错误而崩溃。

内存被分割成段（稍后将会讨论），并且一些内存地址不在程序被赋予访问权限的内存段边界内。当程序尝试访问超出范围的地址时，它将崩溃并称为*段错误*。这种效果可以通过 GDB 进一步探索。

```
reader@hacking:~/booksrc $ gcc -g convert2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) run test
Starting program: /home/reader/booksrc/a.out test

Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
(gdb) where
#0  0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
#1  0xb800183c in ?? ()
#2  0x00000000 in ?? ()
(gdb) break main
Breakpoint 1 at 0x8048419: file convert2.c, line 14.
(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/a.out test

Breakpoint 1, main (argc=2, argv=`0xbffff894`) at convert2.c:14
14         count = atoi(argv[2]); // convert the 2nd arg into an integer
(gdb) cont
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
(gdb) x/3xw 0xbffff894
0xbffff894:     0xbffff9b3      0xbffff9ce      0x00000000
(gdb) x/s 0xbffff9b3
0xbffff9b3:      "/home/reader/booksrc/a.out"
(gdb) x/s 0xbffff9ce
0xbffff9ce:      "test"
(gdb) x/s 0x00000000
0x0:     <Address 0x0 out of bounds>
(gdb) quit
The program is running.  Exit anyway? (y or n) y
reader@hacking:~/booksrc $
```

在 GDB 中使用单个命令行参数`test`执行程序，这会导致程序崩溃。`where`命令有时会显示有用的堆栈回溯；然而，在这种情况下，堆栈在崩溃时被严重破坏。在`main`函数上设置断点并重新执行程序以获取参数向量（以粗体显示）的值。由于参数向量是指向字符串列表的指针，因此它实际上是指向指针列表的指针。使用`x/3xw`命令检查参数向量地址存储的前三个内存地址，显示它们自身是指向字符串的指针。第一个是指零参数，第二个是`test`参数，第三个是零，超出了范围。当程序尝试访问这个内存地址时，它会因段错误而崩溃。

## 变量作用域

关于 C 语言中内存的另一个有趣的概念是变量作用域或上下文——特别是函数内变量的上下文。每个函数都有自己的局部变量集合，它们与其他一切无关。实际上，对同一函数的多次调用都有自己的上下文。你可以使用带有格式字符串的`printf()`函数快速探索这一点；在 scope.c 中查看它。

### scope.c

```
#include <stdio.h>

void func3() {
   int i = 11;
   printf("\t\t\t[in func3] i = %d\n", i);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i = %d\n", i);
   func3();
   printf("\t\t[back in func2] i = %d\n", i);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i = %d\n", i);
   func2();
   printf("\t[back in func1] i = %d\n", i);
}

int main() {
   int i = 3;
   printf("[in main] i = %d\n", i);
   func1();
   printf("[back in main] i = %d\n", i);
}
```

这个简单程序的输出展示了嵌套函数调用。

```
reader@hacking:~/booksrc $ gcc scope.c
reader@hacking:~/booksrc $ ./a.out
[in main] i = 3
        [in func1] i = 5
                [in func2] i = 7
                        [in func3] i = 11
                [back in func2] i = 7
        [back in func1] i = 5
[back in main] i = 3
reader@hacking:~/booksrc $
```

在每个函数中，变量`i`被设置为不同的值并打印出来。注意，在`main()`函数中，变量`i`是 3，即使在调用`func1()`之后，变量`i`是 5。同样，在`func1()`中，变量`i`保持为 5，即使在调用`func2()`之后，`i`是 7，依此类推。最好的理解方式是，每个函数调用都有自己的变量`i`版本。

变量也可以具有全局作用域，这意味着它们将在所有函数中持续存在。如果变量在代码的开始处定义，且不在任何函数内部，则变量是全局的。在下面的 scope2.c 示例代码中，变量`j`被全局声明并设置为 42。这个变量可以被任何函数读取和写入，并且对其的更改将在函数之间持续存在。

### scope2.c

```
#include <stdio.h>

int j = 42; // j is a global variable.

void func3() {
   int i = 11, j = 999; // Here, j is a local variable of func3().
   printf("\t\t\t[in func3] i = %d, j = %d\n", i, j);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i = %d, j = %d\n", i, j);
   printf("\t\t[in func2] setting j = 1337\n");
   j = 1337; // Writing to j
   func3();
   printf("\t\t[back in func2] i = %d, j = %d\n", i, j);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i = %d, j = %d\n", i, j);
   func2();
   printf("\t[back in func1] i = %d, j = %d\n", i, j);
}

int main() {
   int i = 3;
   printf("[in main] i = %d, j = %d\n", i, j);
   func1();
   printf("[back in main] i = %d, j = %d\n", i, j);
}
```

编译和执行 scope2.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc scope2.c
reader@hacking:~/booksrc $ ./a.out
[in main] i = 3, j = 42
        [in func1] i = 5, j = 42
                [in func2] i = 7, j = 42
                [in func2] setting j = 1337
                        [in func3] i = 11, j = 999
                [back in func2] i = 7, j = 1337
        [back in func1] i = 5, j = 1337
[back in main] i = 3, j = 1337 
reader@hacking:~/booksrc $
```

在输出中，全局变量`j`在`func2()`中被写入，并且这种变化在除了`func3()`之外的所有函数中都持续存在，因为`func3()`有自己的局部变量名为`j`。在这种情况下，编译器更倾向于使用局部变量。由于所有这些变量都使用相同的名称，可能会有些混乱，但请记住，最终，这都只是内存。全局变量`j`只是存储在内存中，每个函数都能访问那个内存。每个函数的局部变量都存储在内存中的特定位置，无论名称是否相同。打印这些变量的内存地址将给出更清晰的画面。在下面的 scope3.c 示例代码中，变量地址是通过使用一元地址运算符来打印的。

### scope3.c

```
#include <stdio.h>

int j = 42; // j is a global variable.

void func3() {
   int i = 11, j = 999; // Here, j is a local variable of func3().
   printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j);
}

void func2() {
   int i = 7;
   printf("\t\t[in func2] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t[in func2] j @ 0x%08x = %d\n", &j, j);
   printf("\t\t[in func2] setting j = 1337\n");
   j = 1337; // Writing to j
   func3();
   printf("\t\t[back in func2] i @ 0x%08x = %d\n", &i, i);
   printf("\t\t[back in func2] j @ 0x%08x = %d\n", &j, j);
}

void func1() {
   int i = 5;
   printf("\t[in func1] i @ 0x%08x = %d\n", &i, i);
   printf("\t[in func1] j @ 0x%08x = %d\n", &j, j);
   func2();
   printf("\t[back in func1] i @ 0x%08x = %d\n", &i, i);
   printf("\t[back in func1] j @ 0x%08x = %d\n", &j, j);
}

int main() {
   int i = 3;
   printf("[in main] i @ 0x%08x = %d\n", &i, i);
   printf("[in main] j @ 0x%08x = %d\n", &j, j);
   func1();
   printf("[back in main] i @ 0x%08x = %d\n", &i, i);
   printf("[back in main] j @ 0x%08x = %d\n", &j, j);
}
```

编译和执行 scope3.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc scope3.c 
reader@hacking:~/booksrc $ ./a.out
[in main] i @ 0xbffff834 = 3
[in main] j @ 0x08049988 = 42
        [in func1] i @ 0xbffff814 = 5
        [in func1] j @ 0x08049988 = 42
                [in func2] i @ 0xbffff7f4 = 7
                [in func2] j @ 0x08049988 = 42
                [in func2] setting j = 1337
                        [in func3] i @ 0xbffff7d4 = 11
                        [in func3] j @ 0xbffff7d0 = 999
                [back in func2] i @ 0xbffff7f4 = 7
                [back in func2] j @ 0x08049988 = 1337
        [back in func1] i @ 0xbffff814 = 5
        [back in func1] j @ 0x08049988 = 1337
[back in main] i @ 0xbffff834 = 3
[back in main] j @ 0x08049988 = 1337
reader@hacking:~/booksrc $
```

在这个输出中，很明显`func3()`使用的变量`j`与其他函数使用的`j`不同。`func3()`使用的`j`位于`0xbffff7d0`，而其他函数使用的`j`位于`0x08049988`。此外，请注意变量`i`对每个函数来说实际上是一个不同的内存地址。

在以下输出中，GDB 用于在`func3()`的断点处停止执行。然后回溯命令显示了堆栈上每个函数调用的记录。

```
reader@hacking:~/booksrc $ gcc -g scope3.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1       #include <stdio.h>
2
3       int j = 42; // j is a global variable.
4
5       void func3() {
6          int i = 11, j = 999; // Here, j is a local variable of func3().
7          printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
8          printf("\t\t\t[in func3] j @ 0x%08x = %d\n", &j, j);
9       }
10
(gdb) break 7
Breakpoint 1 at 0x8048388: file scope3.c, line 7.
(gdb) run
Starting program: /home/reader/booksrc/a.out
[in main] i @ 0xbffff804 = 3
[in main] j @ 0x08049988 = 42
        [in func1] i @ 0xbffff7e4 = 5
        [in func1] j @ 0x08049988 = 42
                [in func2] i @ 0xbffff7c4 = 7
                [in func2] j @ 0x08049988 = 42
                [in func2] setting j = 1337

Breakpoint 1, func3 () at scope3.c:7
7          printf("\t\t\t[in func3] i @ 0x%08x = %d\n", &i, i);
(gdb) bt
#0  func3 () at scope3.c:7
#1  0x0804841d in func2 () at scope3.c:17
#2  0x0804849f in func1 () at scope3.c:26
#3  0x0804852b in main () at scope3.c:35
(gdb)
```

回溯还通过查看堆栈上保留的记录来显示嵌套函数调用。每次函数被调用时，都会在堆栈上放置一个称为*堆栈帧*的记录。回溯中的每一行对应一个堆栈帧。每个堆栈帧还包含该上下文中的局部变量。可以通过在回溯命令中添加单词*full*来在 GDB 中显示每个堆栈帧包含的局部变量。

```
(gdb) bt full
#0  func3 () at scope3.c:7
        i = 11
        j = 999
#1  0x0804841d in func2 () at scope3.c:17
        i = 7
#2  0x0804849f in func1 () at scope3.c:26
        i = 5
#3  0x0804852b in main () at scope3.c:35
        i = 3
(gdb)
```

完整的回溯清楚地显示局部变量`j`仅在`func3()`的上下文中存在。全局版本的变量`j`在其他函数的上下文中使用。

除了全局变量之外，变量也可以通过在变量定义前添加关键字`static`来定义为静态变量。与全局变量类似，*静态变量*在函数调用之间保持不变；然而，静态变量也类似于局部变量，因为它们在特定的函数上下文中保持局部。静态变量的一个不同且独特的特性是它们只初始化一次。static.c 中的代码将有助于解释这些概念。

### static.c

```
#include <stdio.h>

void function() { // An example function, with its own context
   int var = 5;
   static int static_var = 5; // Static variable initialization

   printf("\t[in function] var = %d\n", var);
   printf("\t[in function] static_var = %d\n", static_var);
   var++;          // Add one to var.
   static_var++;   // Add one to static_var.
}

int main() { // The main function, with its own context
   int i;
   static int static_var = 1337; // Another static, in a different context

   for(i=0; i < 5; i++) { // Loop 5 times.
      printf("[in main] static_var = %d\n", static_var);
      function(); // Call the function.
   }
}
```

正确命名的`static_var`在两个地方被定义为静态变量：在`main()`的上下文中和在`function()`的上下文中。由于静态变量在特定的功能上下文中是局部的，这些变量可以具有相同的名称，但它们实际上代表内存中的两个不同位置。该函数只是在其上下文中打印两个变量的值，然后将它们各自加 1。编译和执行此代码将显示静态变量和非静态变量之间的差异。

```
reader@hacking:~/booksrc $ gcc static.c
reader@hacking:~/booksrc $ ./a.out
[in main] static_var = 1337
        [in function] var = 5
        [in function] static_var = 5
[in main] static_var = 1337
        [in function] var = 5
        [in function] static_var = 6
[in main] static_var = 1337
        [in function] var = 5
        [in function] static_var = 7
[in main] static_var = 1337
        [in function] var = 5
        [in function] static_var = 8
[in main] static_var = 1337
        [in function] var = 5
        [in function] static_var = 9
reader@hacking:~/booksrc $
```

注意，`static_var`在后续调用`function()`之间保留其值。这是因为静态变量保留其值，也因为它们只初始化一次。此外，由于静态变量是特定功能上下文内的局部变量，`main()`上下文中的`static_var`在整个过程中都保留了其值为 1337。

再次，通过使用一元地址运算符解引用这些变量的地址来打印它们，将提供对实际发生情况的更深入了解。请查看 static2.c 以获取示例。

### static2.c

```
#include <stdio.h>

void function() { // An example function, with its own context
   int var = 5;
   static int static_var = 5; // Static variable initialization

   printf("\t[in function] var  @ %p = %d\n", &var, var);
   printf("\t[in function] static_var @ %p = %d\n", &static_var, static_var);
   var++;          // Add 1 to var.
   static_var++;   // Add 1 to static_var.
}

int main() { // The main function, with its own context
   int i;
   static int static_var = 1337; // Another static, in a different context

   for(i=0; i < 5; i++) { // loop 5 times
      printf("[in main] static_var @ %p = %d\n", &static_var, static_var);
      function(); // Call the function.
   } 
}
```

编译和执行 static2.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc static2.c
reader@hacking:~/booksrc $ ./a.out
[in main] static_var @ 0x804968c = 1337
        [in function] var  @ 0xbffff814 = 5
        [in function] static_var @ 0x8049688 = 5
[in main] static_var @ 0x804968c = 1337
        [in function] var  @ 0xbffff814 = 5
        [in function] static_var @ 0x8049688 = 6
[in main] static_var @ 0x804968c = 1337
        [in function] var  @ 0xbffff814 = 5
        [in function] static_var @ 0x8049688 = 7
[in main] static_var @ 0x804968c = 1337
        [in function] var  @ 0xbffff814 = 5
        [in function] static_var @ 0x8049688 = 8
[in main] static_var @ 0x804968c = 1337
        [in function] var  @ 0xbffff814 = 5
        [in function] static_var @ 0x8049688 = 9
reader@hacking:~/booksrc $
```

显示变量地址后，很明显，`main()`中的`static_var`与`function()`中找到的`static_var`不同，因为它们位于不同的内存地址（分别为`0x804968c`和`0x8049688`）。你可能已经注意到，局部变量的地址都非常高，如`0xbffff814`，而全局和静态变量的内存地址都非常低，如`0x0804968c`和`0x8049688`。你非常敏锐——注意到这样的细节并询问为什么是黑客技术的基石之一。继续阅读以获取你的答案。

# 内存分段

编译程序的内存被分为五个部分：文本段、数据段、bss 段、堆和栈。每个部分代表内存中为特定目的预留的特殊部分。

*文本段*有时也被称为*代码段*。这是程序汇编的机器语言指令所在的位置。由于上述高级控制结构和函数将编译成汇编语言中的分支、跳转和调用指令，该段中的指令执行是非线性的。当程序执行时，EIP 被设置为文本段中的第一条指令。然后处理器遵循一个执行循环，执行以下操作：

1.  读取 EIP 指向的指令

1.  将指令的字节长度添加到 EIP

1.  执行步骤 1 中读取的指令

1.  返回步骤 1

有时指令将是一个跳转或调用指令，这会将 EIP 更改为内存中的不同地址。处理器并不关心这种变化，因为它本来就在期待执行是非线性的。如果 EIP 在步骤 3 中发生变化，处理器将直接回到步骤 1，并读取 EIP 更改到的地址处的指令。

文本段中的写权限被禁用，因为它不用于存储变量，只用于存储代码。这防止了人们实际修改程序代码；任何尝试写入此内存段的尝试都将导致程序通知用户发生了错误，并且程序将被终止。这个段的只读性还有另一个优点，即它可以被程序的不同副本共享，允许程序同时执行而不会出现任何问题。还应该注意的是，这个内存段的大小是固定的，因为其中没有任何东西会发生变化。

数据段和 bss 段用于存储全局和静态程序变量。*数据段*填充了初始化的全局和静态变量，而*bss 段*填充了它们的未初始化对应物。尽管这些段是可写的，但它们也有一个固定的大小。记住，全局变量是持久的，尽管它们的功能上下文（如前例中的变量`j`）。全局和静态变量能够持久存在，因为它们存储在自己的内存段中。

*堆段*是程序员可以直接控制的内存段。该段中的内存块可以被分配并用于程序员可能需要的任何用途。关于堆段的一个显著点是它的大小不是固定的，因此它可以根据需要增长或缩小。堆中的所有内存都由分配器和释放器算法管理，分别保留堆中的内存区域以供使用，并取消保留以允许该部分内存被重新用于后续的保留。堆的大小将根据保留的内存量而增长和缩小。这意味着使用堆分配函数的程序员可以在运行时保留和释放内存。堆的增长是向更高内存地址方向下降的。

*栈段*也具有可变大小，并在函数调用期间用作临时暂存区，用于存储局部函数变量和上下文。这就是 GDB 的 backtrace 命令查看的内容。当程序调用一个函数时，该函数将有自己的传递变量集，并且函数的代码将在文本（或代码）段的不同内存位置。由于上下文和 EIP 在函数调用时必须改变，因此栈用于记住所有传递的变量、函数完成后 EIP 应返回的位置以及该函数使用的所有局部变量。所有这些信息都存储在栈上，统称为*栈帧*。栈包含许多栈帧。

在计算机科学的一般术语中，*栈*是一种常用的抽象数据结构。它具有*先进后出（FILO）*的顺序，这意味着首先放入栈中的项目是最后从栈中出来的。想象一下，在一条一端有结的线绳上串珠子——你无法取下第一个珠子，直到你移除了所有的其他珠子。当一个项目放入栈中时，这被称为*压入*，而当一个项目从栈中移除时，这被称为*弹出*。

如其名所示，内存的栈段实际上是一个栈数据结构，其中包含栈帧。ESP 寄存器用于跟踪栈末端的地址，该地址随着项目的推入和弹出而不断变化。由于这是一种非常动态的行为，因此栈不是固定大小的也很有道理。与堆的动态增长相反，当栈改变大小时，它在内存的可视列表中向上增长，朝向较低的内存地址。

栈的 FILO 特性可能看起来有些奇怪，但鉴于栈用于存储上下文，它非常有用。当一个函数被调用时，一些东西会一起推入栈中，形成一个*栈帧*。EBP 寄存器——有时被称为*帧指针（FP）*或*局部基（LB）指针*——用于引用当前栈帧中的局部函数变量。每个栈帧都包含函数的参数、其局部变量以及两个必要的指针，用于将事物恢复原状：保存的帧指针（SFP）和返回地址。*SFP*用于将 EBP 恢复到其先前的值，而*返回地址*用于将 EIP 恢复到函数调用后找到的下一条指令。这恢复了先前栈帧的功能上下文。

以下 stack_example.c 代码有两个函数：`main()`和`test_function()`。

## 内存分段

### stack_example.c

```
void test_function(int a, int b, int c, int d) {
   int flag;
   char buffer[10];

   flag = 31337;
   buffer[0] = 'A';
}

int main() {
   test_function(1, 2, 3, 4);
}
```

此程序首先声明了一个具有四个参数的测试函数，这些参数都被声明为整数：`a`、`b`、`c`和`d`。函数的局部变量包括一个名为`flag`的单个字符和一个名为`buffer`的 10 字符缓冲区。这些变量的内存位于栈段中，而函数代码的机器指令存储在文本段中。编译程序后，可以使用 GDB 检查其内部工作原理。下面的输出显示了`main()`和`test_function()`的反汇编机器指令。`main()`函数从`0x08048357`开始，`test_function()`从`0x08048344`开始。每个函数的前几条指令（以下用粗体显示）设置栈帧。这些指令统称为*过程序言*或*函数序言*。它们在栈上保存帧指针，并为局部函数变量保存栈内存。有时函数序言还会处理一些栈对齐。确切的序言指令将根据编译器和编译器选项有很大差异，但通常这些指令构建栈帧。

```
reader@hacking:~/booksrc $ gcc -g stack_example.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main():
`0x08048357 <main+0>:    push   ebp 0x08048358 <main+1>:    mov    ebp,esp 0x0804835a <main+3>:    sub    esp,0x18 0x0804835d <main+6>:    and    esp,0xfffffff0 0x08048360 <main+9>:    mov    eax,0x0 0x08048365 <main+14>:   sub    esp,eax`
0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4
0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3
0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2
0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1
0x08048386 <main+47>:   call   0x8048344 <test_function>
0x0804838b <main+52>:   leave
0x0804838c <main+53>:   ret
End of assembler dump
(gdb) disass test_function()
Dump of assembler code for function test_function:
`0x08048344 <test_function+0>:   push   ebp 0x08048345 <test_function+1>:   mov    ebp,esp 0x08048347 <test_function+3>:   sub    esp,0x28`
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave
0x08048356 <test_function+18>:  ret
End of assembler dump
(gdb)
```

当程序运行时，调用`main()`函数，该函数简单地调用`test_function()`。

当从`main()`函数调用`test_function()`函数时，各种值被推送到栈中以创建栈帧的起始部分，如下所示。当调用`test_function()`时，函数参数以相反的顺序（因为它是 FILO）推送到栈上。函数的参数是 1、2、3 和 4，因此后续的推指令将 4、3、2 和最后 1 推送到栈上。这些值对应于函数中的变量`d`、`c`、`b`和`a`。将这些值推送到栈上的指令在下面的`main()`函数反汇编中用粗体显示。

```
(gdb) disass main
Dump of assembler code for function main:
0x08048357 <main+0>:    push   ebp
0x08048358 <main+1>:    mov    ebp,esp
0x0804835a <main+3>:    sub    esp,0x18
0x0804835d <main+6>:    and    esp,0xfffffff0
0x08048360 <main+9>:    mov    eax,0x0
0x08048365 <main+14>:   sub    esp,eax
`0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4 0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3 0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2 0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1`
0x08048386 <main+47>:   call   0x8048344 <test_function>
0x0804838b <main+52>:   leave
0x0804838c <main+53>:   ret
End of assembler dump
(gdb)
```

接下来，当执行汇编调用指令时，返回地址被推送到栈上，执行流程跳转到`test_function()`的起始地址`0x08048344`。返回地址的值将是当前 EIP 之后的指令位置——具体来说，是之前提到的执行循环的第 3 步中存储的值。在这种情况下，返回地址将指向`main()`中的 leave 指令，地址为`0x0804838b`。

调用指令既将返回地址存储在堆栈上，又将 EIP 跳转到 `test_function()` 的开始处，因此 `test_function()` 的过程序言指令完成了堆栈帧的构建。在这一步中，当前 EBP 的值被推送到堆栈上。这个值被称为保存的帧指针（SFP），稍后用于将 EBP 恢复到其原始状态。然后，当前 ESP 的值被复制到 EBP 中以设置新的帧指针。这个帧指针用于引用函数的局部变量（`flag` 和 `buffer`）。通过从 ESP 中减去来为这些变量保存内存。最后，堆栈帧看起来可能如下所示：

![](img/httpatomoreillycomsourcenostarchimages254229.png.jpg)

图 0x200-1。

我们可以使用 GDB 在堆栈上观察堆栈帧的构建过程。在下面的输出中，在调用 `test_function()` 之前以及在 `test_function()` 开始处设置了断点。GDB 将第一个断点放在函数参数推送到堆栈之前，第二个断点放在 `test_function()` 的过程序言之后。当程序运行时，执行会在断点处停止，此时会检查寄存器的 ESP（堆栈指针）、EBP（帧指针）和 EIP（执行指针）。

```
(gdb) list main
4
5          flag = 31337;
6          buffer[0] = 'A';
7       }
8
9       int main() {
10         test_function(1, 2, 3, 4);
11      }
(gdb) break 10
Breakpoint 1 at 0x8048367: file stack_example.c, line 10.
(gdb) break test_function
Breakpoint 2 at 0x804834a: file stack_example.c, line 5.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at stack_example.c:10
10         test_function(1, 2, 3, 4);
(gdb) i r esp ebp eip
esp            0xbffff7f0       0xbffff7f0
ebp            0xbffff808       0xbffff808
eip            0x8048367        0x8048367 <main+16>
(gdb) x/5i $eip
0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4
0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3
0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2
0x804837f <main+40>:    mov    DWORD PTR [esp],0x1
0x8048386 <main+47>:    call   0x8048344 <test_function>
(gdb)
```

这个断点正好在创建 `test_function()` 调用的堆栈帧之前。这意味着这个新堆栈帧的底部位于当前 ESP 的值，`0xbffff7f0`。下一个断点正好在 `test_function()` 的过程序言之后，所以继续执行将构建堆栈帧。下面的输出显示了第二个断点处的类似信息。局部变量（`flag` 和 `buffer`）相对于帧指针（EBP）进行引用。

```
(gdb) cont
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5
5          flag = 31337;
(gdb) i r esp ebp eip
esp            0xbffff7c0       0xbffff7c0
ebp            0xbffff7e8       0xbffff7e8
eip            0x804834a        0x804834a <test_function+6>
(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave
0x08048356 <test_function+18>:  ret
End of assembler dump.
(gdb) print $ebp-12
$1 = (void *) 0xbffff7dc
(gdb) print $ebp-40
$2 = (void *) 0xbffff7c0
(gdb) x/16xw $esp
0xbffff7c0:   0x00000000      0x08049548      0xbffff7d8      0x08048249
0xbffff7d0:     0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9
0xbffff7e0:     0xb7fd6ff4      0xbffff89c      0xbffff808      0x0804838b
0xbffff7f0:      `0x00000001      0x00000002      0x00000003      0x00000004`
(gdb)
```

堆栈帧在堆栈的末尾显示。函数的四个参数可以在堆栈帧的底部看到（![](img/httpatomoreillycomsourcenostarchimages254261.png)），返回地址直接位于其上方（![](img/httpatomoreillycomsourcenostarchimages254461.png)）。之上是 `0xbffff808` 的保存帧指针（![](img/httpatomoreillycomsourcenostarchimages254537.png)），这是前一个堆栈帧中 EBP 的值。其余的内存为局部堆栈变量 `flag` 和 `buffer` 保存。计算它们相对于 EBP 的相对地址以显示它们在堆栈帧中的确切位置。`flag` 变量的内存显示在 ![](img/httpatomoreillycomsourcenostarchimages254530.png) 和缓冲区变量的内存显示在 ![](img/httpatomoreillycomsourcenostarchimages254488.png)。堆栈帧中的额外空间只是填充。

执行完成后，整个栈帧将从栈中弹出，EIP 被设置为返回地址，以便程序可以继续执行。如果在函数内部调用了另一个函数，另一个栈帧将被推入栈中，依此类推。随着每个函数的结束，其栈帧将从栈中弹出，以便执行可以返回到上一个函数。这种行为是为什么这个内存段以 FILO（先进后出）数据结构组织的原因。

内存的不同段按照它们被呈现的顺序排列，从较低的内存地址到较高的内存地址。由于大多数人熟悉向下计数的编号列表，较小的内存地址显示在顶部。有些文本将这个顺序颠倒，这可能会非常令人困惑；因此，在这本书中，较小的内存地址总是显示在顶部。大多数调试器也以这种方式显示内存，较小的内存地址在顶部，较高的在底部。

由于堆和栈都是动态的，它们都向对方的方向增长。这最小化了浪费的空间，使得当堆较小时，栈可以更大，反之亦然。

![](img/httpatomoreillycomsourcenostarchimages254381.png.jpg)

图 0x200-2。

## C 语言中的内存段

在 C 语言中，与其他编译型语言一样，编译后的代码存放在文本段，而变量则位于剩余的段中。变量将被存储在哪个内存段中，取决于变量的定义方式。在函数外部定义的变量被认为是全局变量。也可以在任意变量声明前加上`static`关键字，使变量成为静态变量。如果静态或全局变量被初始化为数据，它们将被存储在数据内存段中；否则，这些变量将被放置在 bss 内存段中。堆内存段的内存必须首先使用名为`malloc()`的内存分配函数进行分配。通常，指针用于引用堆上的内存。最后，剩余的函数变量被存储在堆栈内存段中。由于堆栈可以包含许多不同的栈帧，因此栈变量可以在不同的功能上下文中保持唯一性。`memory_segments.c`程序将帮助解释 C 语言中的这些概念。

### memory_segments.c

```
#include <stdio.h>

int global_var;

int global_initialized_var = 5;

void function() {  // This is just a demo function.
   int stack_var; // Notice this variable has the same name as the one in main().

   printf("the function's stack_var is at address 0x%08x\n", &stack_var);
}

int main() {
   int stack_var; // Same name as the variable in function()
   static int static_initialized_var = 5;
   static int static_var;
   int *heap_var_ptr;

   heap_var_ptr = (int *) malloc(4);

   // These variables are in the data segment.
   printf("global_initialized_var is at address 0x%08x\n", &global_initialized_var);
   printf("static_initialized_var is at address 0x%08x\n\n", &static_initialized_var);

   // These variables are in the bss segment.
   printf("static_var is at address 0x%08x\n", &static_var);
   printf("global_var is at address 0x%08x\n\n", &global_var);

   // This variable is in the heap segment.
   printf("heap_var is at address 0x%08x\n\n", heap_var_ptr);

   // These variables are in the stack segment.
   printf("stack_var is at address 0x%08x\n", &stack_var);
   function(); 
}
```

由于变量命名具有描述性，大部分代码相当直观。全局和静态变量声明方式如前所述，并且也声明了初始化后的对应变量。栈变量在`main()`和`function()`中都被声明，以展示函数上下文的影响。堆变量实际上被声明为一个整数指针，它将指向堆内存段上分配的内存。调用`malloc()`函数在堆上分配四个字节。由于新分配的内存可以是任何数据类型，`malloc()`函数返回一个空指针，需要将其转换为整数指针。

```
reader@hacking:~/booksrc $ gcc memory_segments.c
reader@hacking:~/booksrc $ ./a.out 
global_initialized_var is at address 0x080497ec
static_initialized_var is at address 0x080497f0

static_var is at address 0x080497f8
global_var is at address 0x080497fc

heap_var is at address 0x0804a008

stack_var is at address 0xbffff834
the function's stack_var is at address 0xbffff814
reader@hack ing:~/booksrc $
```

前两个初始化变量具有最低的内存地址，因为它们位于数据内存段。接下来的两个变量，`static_var`和`global_var`，存储在 bss 内存段，因为它们未初始化。这些内存地址略大于前一个变量的地址，因为 bss 段位于数据段下方。由于这两个内存段在编译后都具有固定的大小，因此几乎没有浪费的空间，地址之间也不是很远。

堆变量存储在堆段上分配的空间中，该段位于 bss 段下方。请记住，这个段的内存不是固定的，以后还可以动态分配更多空间。最后，最后两个`stack_var`具有非常大的内存地址，因为它们位于栈段。栈中的内存也不是固定的；然而，这个内存从底部开始，向后增长到堆段。这允许两个内存段都是动态的，而不会在内存中浪费空间。`main()`函数上下文中的第一个`stack_var`存储在栈段内的栈帧中。`function()`中的第二个`stack_var`有自己的独特上下文，因此该变量存储在栈段中的不同栈帧中。当在程序接近结束时调用`function()`，会创建一个新的栈帧来存储（其他事物中包括）`function()`上下文的`stack_var`。由于栈随着每个新的栈帧向上增长到堆段，因此第二个`stack_var`（`0xbffff814`）的内存地址小于在`main()`上下文中找到的第一个`stack_var`（`0xbffff834`）的地址。

## 使用堆

使用其他内存段仅仅是变量声明方式的问题。然而，使用堆则需要更多的努力。正如之前所演示的，在堆上分配内存是通过使用`malloc()`函数来完成的。这个函数接受一个大小作为其唯一的参数，并在堆段中保留相应大小的空间，以空指针的形式返回该内存的起始地址。如果由于某种原因`malloc()`函数无法分配内存，它将简单地返回一个值为 0 的 NULL 指针。相应的释放函数是`free()`。这个函数接受一个指针作为其唯一的参数，并释放堆上的内存空间，以便以后再次使用。这些相对简单的函数在 heap_example.c 中得到了演示。

### heap_example.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
   char *char_ptr;  // A char pointer
   int *int_ptr;    // An integer pointer
   int mem_size;

   if (argc < 2)     // If there aren't command-line arguments,
      mem_size = 50; // use 50 as the default value.
   else
      mem_size = atoi(argv[1]);

   printf("\t[+] allocating %d bytes of memory on the heap for char_ptr\n", mem_size);
   char_ptr = (char *) malloc(mem_size); // Allocating heap memory

   if(char_ptr == NULL) {  // Error checking, in case malloc() fails
      fprintf(stderr, "Error: could not allocate heap memory.\n");
      exit(-1);
   }

   strcpy(char_ptr, "This is memory is located on the heap.");
   printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

   printf("\t[+] allocating 12 bytes of memory on the heap for int_ptr\n");
   int_ptr = (int *) malloc(12); // Allocated heap memory again

   if(int_ptr == NULL) {  // Error checking, in case malloc() fails
      fprintf(stderr, "Error: could not allocate heap memory.\n");
      exit(-1);
   }

   *int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.
   printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);

   printf("\t[-] freeing char_ptr's heap memory...\n");
   free(char_ptr); // Freeing heap memory

   printf("\t[+] allocating another 15 bytes for char_ptr\n");
   char_ptr = (char *) malloc(15); // Allocating more heap memory

   if(char_ptr == NULL) {  // Error checking, in case malloc() fails
      fprintf(stderr, "Error: could not allocate heap memory.\n");
      exit(-1);
   }

   strcpy(char_ptr, "new memory");
   printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

   printf("\t[-] freeing int_ptr's heap memory...\n");
   free(int_ptr); // Freeing heap memory
   printf("\t[-] freeing char_ptr's heap memory...\n");
   free(char_ptr); // Freeing the other block of heap memory 
}
```

这个程序接受一个命令行参数作为第一次内存分配的大小，默认值为 50。然后它使用`malloc()`和`free()`函数在堆上分配和释放内存。程序中有大量的`printf()`语句来调试程序执行时实际发生的事情。由于`malloc()`不知道它正在分配哪种类型的内存，它返回一个指向新分配堆内存的空指针，这必须转换为适当类型。在每次`malloc()`调用之后，都有一个错误检查块来检查分配是否失败。如果分配失败且指针为 NULL，则使用`fprintf()`将错误消息打印到标准错误，并退出程序。`fprintf()`函数与`printf()`非常相似；然而，它的第一个参数是`stderr`，这是一个用于显示错误的标准文件流。这个函数将在稍后进行更多解释，但现在，它只是用作正确显示错误的一种方式。程序的其余部分相当直接。

```
reader@hacking:~/booksrc $ gcc -o heap_example heap_example.c
reader@hacking:~/booksrc $ ./heap_example
        [+] allocating 50 bytes of memory on the heap for char_ptr
char_ptr (0x804a008) --> 'This is memory is located on the heap.'
        [+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x804a040) --> 31337
        [-] freeing char_ptr's heap memory...
        [+] allocating another 15 bytes for char_ptr
char_ptr (0x804a050) --> 'new memory'
        [-] freeing int_ptr's heap memory...
        [-] freeing char_ptr's heap memory... 
reader@hacking:~/booksrc $
```

在前面的输出中，注意每个内存块在堆中都有一个递增更高的内存地址。尽管前 50 字节已被释放，但当请求额外的 15 字节时，它们被放置在为`int_ptr`分配的 12 字节之后。堆分配函数控制这种行为，可以通过改变初始内存分配的大小来探索。 

```
reader@hacking:~/booksrc $ ./heap_example 100
        [+] allocating 100 bytes of memory on the heap for char_ptr
char_ptr (0x804a008) --> 'This is memory is located on the heap.'
        [+] allocating 12 bytes of memory on the heap for int_ptr
int_ptr (0x804a070) --> 31337
        [-] freeing char_ptr's heap memory...
        [+] allocating another 15 bytes for char_ptr
char_ptr (0x804a008) --> 'new memory'
        [-] freeing int_ptr's heap memory...
        [-] freeing char_ptr's heap memory...
reader@hacking:~/booksrc $
```

如果分配了一个较大的内存块然后释放，最终的 15 字节分配将发生在释放的内存空间中。通过实验不同的值，你可以找出分配函数何时选择回收释放的空间以供新的分配使用。通常，简单的信息性`printf()`语句和一些实验可以揭示许多关于底层系统的东西。

## 带错误检查的 malloc()

在 `heap_example.c` 中，对 `malloc()` 调用进行了多次错误检查。尽管 `malloc()` 调用从未失败，但在 C 语言编程中处理所有潜在情况是很重要的。但是，由于有多个 `malloc()` 调用，错误检查代码需要出现在多个地方。这通常会使代码看起来杂乱无章，如果需要修改错误检查代码或需要新的 `malloc()` 调用，这会很不方便。由于每个 `malloc()` 调用的错误检查代码基本上都是相同的，这是一个使用函数而不是在多个地方重复相同指令的完美场所。请查看 `errorchecked_heap.c` 以获取示例。

### errorchecked_heap.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *errorchecked_malloc(unsigned int); // Function prototype for errorchecked_malloc()

int main(int argc, char *argv[]) {
   char *char_ptr;  // A char pointer
   int *int_ptr;    // An integer pointer
   int mem_size;

   if (argc < 2)     // If there aren't command-line arguments,
      mem_size = 50; // use 50 as the default value.
   else
      mem_size = atoi(argv[1]);

   printf("\t[+] allocating %d bytes of memory on the heap for char_ptr\n", mem_size);
   char_ptr = (char *) errorchecked_malloc(mem_size); // Allocating heap memory

   strcpy(char_ptr, "This is memory is located on the heap.");
   printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);
   printf("\t[+] allocating 12 bytes of memory on the heap for int_ptr\n");
   int_ptr = (int *) errorchecked_malloc(12); // Allocated heap memory again

   *int_ptr = 31337; // Put the value of 31337 where int_ptr is pointing.
   printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);

   printf("\t[-] freeing char_ptr's heap memory...\n");
   free(char_ptr); // Freeing heap memory

   printf("\t[+] allocating another 15 bytes for char_ptr\n");
   char_ptr = (char *) errorchecked_malloc(15); // Allocating more heap memory

   strcpy(char_ptr, "new memory");
   printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);

   printf("\t[-] freeing int_ptr's heap memory...\n");
   free(int_ptr); // Freeing heap memory
   printf("\t[-] freeing char_ptr's heap memory...\n");
   free(char_ptr); // Freeing the other block of heap memory
}

void *errorchecked_malloc(unsigned int size) { // An error-checked malloc() function
   void *ptr;
   ptr = malloc(size);
   if(ptr == NULL) {
      fprintf(stderr, "Error: could not allocate heap memory.\n");
      exit(-1);
   }
   return ptr; 
}
```

`errorchecked_heap.c` 程序基本上等同于之前的 `heap_example.c` 代码，除了将堆内存分配和错误检查合并到一个函数中。代码的第一行 `void *errorchecked_malloc(unsigned int);` 是函数原型。这使编译器知道将有一个名为 `errorchecked_malloc()` 的函数，它期望一个无符号整数参数，并返回一个 `void` 指针。实际的函数可以放在任何地方；在这种情况下，它位于 `main()` 函数之后。该函数本身相当简单；它只是接受要分配的字节数，并尝试使用 `malloc()` 分配这么多内存。如果分配失败，错误检查代码将显示错误并退出程序；否则，它将返回指向新分配堆内存的指针。这样，自定义的 `errorchecked_malloc()` 函数就可以用来替代正常的 `malloc()`，从而消除后续重复错误检查的需要。这种方式开始凸显使用函数编程的实用性。

# 建立在基础之上

一旦你理解了 C 编程的基本概念，其余的部分就相对简单了。C 语言的强大之处主要来自于使用其他函数。实际上，如果从任何先前的程序中移除这些函数，剩下的将只是非常基础的语句。

## 文件访问

在 C 语言中访问文件主要有两种方式：文件描述符和文件流。*文件描述符*使用一组低级 I/O 函数，而*文件流*是基于低级函数构建的更高层次的缓冲 I/O 形式。有些人认为文件流函数更容易编程；然而，文件描述符更为直接。在这本书中，我们将重点关注使用文件描述符的低级 I/O 函数。

这本书背面的条形码代表一个数字。因为这个数字在书店中的其他书籍中是唯一的，收银员可以在结账时扫描这个数字，并使用它来参考商店数据库中关于这本书的信息。同样，文件描述符是一个用于引用打开文件的数字。使用文件描述符的四个常见函数是 `open()`、`close()`、`read()` 和 `write()`。所有这些函数在出现错误时都会返回 -1。`open()` 函数用于打开一个文件以供读取和/或写入，并返回一个文件描述符。返回的文件描述符只是一个整数值，但在打开的文件中是唯一的。文件描述符作为参数传递给其他函数，就像指向打开文件的指针一样。对于 `close()` 函数，文件描述符是唯一的参数。`read()` 和 `write()` 函数的参数是文件描述符、指向要读取或写入的数据的指针以及从该位置读取或写入的字节数。`open()` 函数的参数是要打开的文件名的指针以及一系列预定义的标志，这些标志指定了访问模式。这些标志及其用法将在稍后进行深入解释，但现在让我们看看一个使用文件描述符的简单记事程序——simplenote.c。这个程序接受一个命令行参数作为笔记，并将其添加到 `/tmp/notes` 文件的末尾。这个程序使用了几个函数，包括一个看起来熟悉的错误检查堆内存分配函数。其他函数用于显示用法消息和处理致命错误。`usage()` 函数在 `main()` 之前简单地定义，因此不需要函数原型。

### simplenote.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

void usage(char *prog_name, char *filename) {
   printf("Usage: %s <data to add to %s>\n", prog_name, filename);
   exit(0);
}

void fatal(char *);            // A function for fatal errors
void *ec_malloc(unsigned int); // An error-checked malloc() wrapper

int main(int argc, char *argv[]) {
   int fd; // file descriptor
   char *buffer, *datafile;

   buffer = (char *) ec_malloc(100);
   datafile = (char *) ec_malloc(20);
   strcpy(datafile, "/tmp/notes");

   if(argc < 2)                 // If there aren't command-line arguments,
      usage(argv[0], datafile); // display usage message and exit.
   strcpy(buffer, argv[1]);     // Copy into buffer.

   printf("[DEBUG] buffer   @ %p: \'%s\'\n", buffer, buffer);
   printf("[DEBUG] data file @ %p: \'%s\'\n", datafile, datafile);

   strncat(buffer, "\n", 1); // Add a newline on the end.

// Opening file
   fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
   if(fd == -1)
      fatal("in main() while opening file");
   printf("[DEBUG] file descriptor is %d\n", fd);
// Writing data
   if(write(fd, buffer, strlen(buffer)) == -1)
      fatal("in main() while writing buffer to file");
// Closing file
   if(close(fd) == -1)
      fatal("in main() while closing file");

   printf("Note has been saved.\n");
   free(buffer);
   free(datafile);
}

// A function to display an error message and then exit
void fatal(char *message) {
   char error_message[100];

   strcpy(error_message, "[!!] Fatal Error ");
   strncat(error_message, message, 83);
   perror(error_message);
   exit(-1);
}

// An error-checked malloc() wrapper function
void *ec_malloc(unsigned int size) {
   void *ptr;
   ptr = malloc(size);
   if(ptr == NULL)
      fatal("in ec_malloc() on memory allocation");
   return ptr; 
}
```

除了在 `open()` 函数中使用的看起来奇怪的标志外，大部分代码应该是可读的。还有一些我们之前没有使用过的标准函数。`strlen()` 函数接受一个字符串并返回其长度。它与 `write()` 函数一起使用，因为它需要知道要写入多少字节。`perror()` 函数是 *print error* 的缩写，并在 `fatal()` 中用于在退出前打印一个额外的错误消息（如果有的话）。

```
reader@hacking:~/booksrc $ gcc -o simplenote simplenote.c 
reader@hacking:~/booksrc $ ./simplenote 
Usage: ./simplenote <data to add to /tmp/notes>
reader@hacking:~/booksrc $ ./simplenote "this is a test note"
[DEBUG] buffer   @ 0x804a008: 'this is a test note'
[DEBUG] data file @ 0x804a070: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ cat /tmp/notes 
this is a test note
reader@hacking:~/booksrc $ ./simplenote "great, it works"
[DEBUG] buffer   @ 0x804a008: 'great, it works'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ cat /tmp/notes 
this is a test note
great, it works
reader@hacking:~/booksrc $
```

程序执行的输出相当直观，但关于源代码还有一些需要进一步解释的地方。由于 fcntl.h 和 sys/stat.h 文件定义了与 `open()` 函数一起使用的标志，因此必须包含这些文件。第一组标志位于 fcntl.h 中，用于设置访问模式。访问模式必须使用以下三个标志之一：

| **`O_RDONLY`** 以只读方式打开文件。 |
| --- |
| **`O_WRONLY`** 以只写方式打开文件。 |
| **`O_RDWR`** 以读写方式打开文件。 |

这些标志可以使用位或运算符与几个其他可选标志组合。以下是一些更常见且有用的标志：

| **`O_APPEND`** 在文件末尾写入数据。 |
| --- |
| **`O_TRUNC`** 如果文件已存在，则将文件截断到 0 长度。 |
| **`O_CREAT`** 如果文件不存在，则创建文件。 |

位操作使用标准逻辑门，如或和与，来组合位。当两个位进入一个或门时，如果第一个位或第二个位中的任何一个为 1，则结果为 1。如果两个位进入一个与门，只有当第一个位和第二个位都为 1 时，结果才为 1。32 位全值可以使用这些位操作符对每个对应的位执行逻辑操作。bitwise.c 的源代码和程序输出演示了这些位操作。 

### bitwise.c

```
#include <stdio.h>

int main() {
   int i, bit_a, bit_b;
   printf("bitwise OR operator  |\n");
   for(i=0; i < 4; i++) {
      bit_a = (i & 2) / 2; // Get the second bit.
      bit_b = (i & 1);     // Get the first bit.
      printf("%d | %d = %d\n", bit_a, bit_b, bit_a | bit_b);
   }
   printf("\nbitwise AND operator  &\n");
   for(i=0; i < 4; i++) {
      bit_a = (i & 2) / 2; // Get the second bit.
      bit_b = (i & 1);     // Get the first bit.
      printf("%d & %d = %d\n", bit_a, bit_b, bit_a & bit_b);
   } 
}
```

编译和执行 bitwise.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc bitwise.c
reader@hacking:~/booksrc $ ./a.out
bitwise OR operator  |
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

bitwise AND operator  &
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1 
reader@hacking:~/booksrc $
```

用于 `open()` 函数的标志具有与单个位对应的值。这样，标志可以通过或逻辑组合，而不会破坏任何信息。fcntl_flags.c 程序及其输出探讨了 fcntl.h 中定义的一些标志值以及它们是如何相互组合的。

### fcntl_flags.c

```
#include <stdio.h>
#include <fcntl.h>

void display_flags(char *, unsigned int);
void binary_print(unsigned int);

int main(int argc, char *argv[]) {
   display_flags("O_RDONLY\t\t", O_RDONLY);
   display_flags("O_WRONLY\t\t", O_WRONLY);
   display_flags("O_RDWR\t\t\t", O_RDWR);
   printf("\n");
   display_flags("O_APPEND\t\t", O_APPEND);
   display_flags("O_TRUNC\t\t\t", O_TRUNC);
   display_flags("O_CREAT\t\t\t", O_CREAT);
   printf("\n");
   display_flags("O_WRONLY|O_APPEND|O_CREAT", O_WRONLY|O_APPEND|O_CREAT);
}

void display_flags(char *label, unsigned int value) {
   printf("%s\t: %d\t:", label, value);
   binary_print(value);
   printf("\n");
}

void binary_print(unsigned int value) {
   unsigned int mask = 0xff000000; // Start with a mask for the highest byte.
   unsigned int shift = 256*256*256; // Start with a shift for the highest byte.
   unsigned int byte, byte_iterator, bit_iterator;

   for(byte_iterator=0; byte_iterator < 4; byte_iterator++) {
      byte = (value & mask) / shift; // Isolate each byte.
      printf(" ");
      for(bit_iterator=0; bit_iterator < 8; bit_iterator++) { // Print the byte's bits.
         if(byte & 0x80) // If the highest bit in the byte isn't 0,
            printf("1");       // print a 1.
         else
            printf("0");       // Otherwise, print a 0.
         byte *= 2;         // Move all the bits to the left by 1.
      }
      mask /= 256;       // Move the bits in mask right by 8.
      shift /= 256;      // Move the bits in shift right by 8.
   } 
}
```

编译和执行 fcntl_flags.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc fcntl_flags.c 
reader@hacking:~/booksrc $ ./a.out
O_RDONLY                        : 0     : 00000000 00000000 00000000 00000000
O_WRONLY                        : 1     : 00000000 00000000 00000000 00000001
O_RDWR                          : 2     : 00000000 00000000 00000000 00000010

O_APPEND                        : 1024  : 00000000 00000000 00000100 00000000
O_TRUNC                         : 512   : 00000000 00000000 00000010 00000000
O_CREAT                         : 64    : 00000000 00000000 00000000 01000000

O_WRONLY|O_APPEND|O_CREAT       : 1089  : 00000000 00000000 00000100 01000001 
$
```

使用位标志与位逻辑结合是一种高效且常用的技术。只要每个标志都是一个只有唯一位被打开的数字，对这些值进行位或操作的效果就等同于它们的和。在 fcntl_flags.c 中，1 + 1024 + 64 = 1089。尽管如此，这种方法只有在所有位都是唯一的时候才有效。

## 文件权限

如果在 `open()` 函数的访问模式中使用 `O_CREAT` 标志，则需要额外的参数来定义新创建文件的文件权限。此参数使用在 sys/stat.h 中定义的位标志，可以通过位或逻辑组合在一起。

| **`S_IRUSR`** 给文件用户（所有者）读权限。 |
| --- |
| **`S_IWUSR`** 给文件用户（所有者）写权限。 |
| **`S_IXUSR`** 给文件用户（所有者）执行权限。 |
| **`S_IRGRP`** 给文件组读权限。 |
| **`S_IWGRP`** 给文件组写权限。 |
| **`S_IXGRP`** 给文件组执行权限。 |
| **`S_IROTH`** 给文件其他（任何人）读权限。 |
| **`S_IWOTH`** 给文件其他（任何人）写权限。 |
| **`S_IXOTH`** 给文件其他（任何人）执行权限。 |

如果你已经熟悉 Unix 文件权限，那么这些标志应该对你来说非常合理。如果它们不合理，这里有一个 Unix 文件权限的快速入门课程。

每个文件都有一个所有者和一个组。这些值可以使用 `ls -l` 显示，以下输出中显示了这些值。

```
reader@hacking:~/booksrc $ ls -l /etc/passwd simplenote*
-rw-r--r-- 1 root   root   1424 2007-09-06 09:45 /etc/passwd
-rwxr-xr-x 1 reader reader 8457 2007-09-07 02:51 simplenote
-rw------- 1 reader reader 1872 2007-09-07 02:51 simplenote.c 
reader@hacking:~/booksrc $
```

对于 /etc/passwd 文件，所有者是 root，组也是 root。对于其他两个 simplenote 文件，所有者是 reader，组是 users。

读、写、执行权限可以针对三个不同的字段：用户、组和其他进行开启和关闭。用户权限描述文件所有者可以做什么（读、写和/或执行），组权限描述该组中的用户可以做什么，其他权限描述其他所有人可以做什么。这些字段也在`ls -l`输出的前面显示。首先显示用户读/写/执行权限，使用`r`表示读，`w`表示写，`x`表示执行，-表示关闭。接下来的三个字符显示组权限，最后三个字符是其他权限。在上面的输出中，simplenote 程序的所有三个用户权限都已开启（以粗体显示）。每个权限对应一个位标志；读是 4（二进制中的 100），写是 2（二进制中的 010），执行是 1（二进制中的 001）。由于每个值只包含唯一的位，位或操作可以达到与将这些数字相加相同的结果。这些值可以相加，以使用`chmod`命令定义用户、组和其他用户的权限。

```
reader@hacking:~/booksrc $ chmod 731 simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c
reader@hacking:~/booksrc $ chmod ugo-wx simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c
reader@hacking:~/booksrc $ chmod u+w simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c
reader@hacking:~/booksrc $
```

第一个命令（`chmod 721`）为用户赋予读、写和执行权限，因为第一个数字是 7（4 + 2 + 1），为组赋予写和执行权限，因为第二个数字是 3（2 + 1），为其他用户只赋予执行权限，因为第三个数字是 1。权限也可以通过`chmod`命令添加或移除。在下一个`chmod`命令中，参数`ugo-wx`意味着*从用户、组和其他用户中移除读写执行权限*。最后的`chmod u+w`命令为用户赋予写权限。

在 simplenote 程序中，`open()`函数使用`S_IRUSR|S_IWUSR`作为其附加权限参数，这意味着在创建时/tmp/notes 文件应该只有用户读和写权限。

```
reader@hacking:~/booksrc $ ls -l /tmp/notes 
-rw------- 1 reader reader 36 2007-09-07 02:52 /tmp/notes 
reader@hacking:~/booksrc $
```

## 用户 ID

Unix 系统上的每个用户都有一个唯一的用户 ID 号。这个用户 ID 可以使用`id`命令显示。

```
reader@hacking:~/booksrc $ id reader
`uid=999(reader)` gid=999(reader)
groups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4
4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a
dmin)
reader@hacking:~/booksrc $ id matrix
uid=500(matrix) gid=500(matrix) groups=500(matrix)
reader@hacking:~/booksrc $ id root
uid=0(root) gid=0(root) groups=0(root)
reader@hacking:~/booksrc $
```

根用户（用户 ID 为 0）类似于管理员账户，它对系统拥有完全访问权限。可以使用`su`命令切换到不同的用户，如果这个命令以 root 身份运行，则无需密码即可完成。`sudo`命令允许单个命令以 root 用户身份运行。在 LiveCD 上，为了简化操作，`sudo`已被配置为无需密码即可执行。这些命令提供了一种简单的方法来快速在用户之间切换。

```
reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ id
uid=501(jose) gid=501(jose) groups=501(jose)
jose@hacking:/home/reader/booksrc $
```

作为 jose 用户，如果执行 simplenote 程序，它将以 jose 的身份运行，但无法访问/tmp/notes 文件。这个文件属于 reader 用户，并且只允许所有者读写权限。

```
jose@hacking:/home/reader/booksrc $ ls -l /tmp/notes
-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes
jose@hacking:/home/reader/booksrc $ ./simplenote "a note for jose"
[DEBUG] buffer   @ 0x804a008: 'a note for jose'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[!!] Fatal Error in main() while opening file: Permission denied
jose@hacking:/home/reader/booksrc $ cat /tmp/notes
cat: /tmp/notes: Permission denied
jose@hacking:/home/reader/booksrc $ exit
exit
reader@hacking:~/booksrc $
```

如果读者是 simplenote 程序的唯一用户，这没问题；然而，很多时候，多个用户需要能够访问同一文件的某些部分。例如，/etc/passwd 文件包含系统上每个用户的账户信息，包括每个用户的默认登录 shell。`chsh` 命令允许任何用户更改自己的登录 shell。此程序需要能够更改 `/etc/passwd` 文件，但仅限于与当前用户账户相关的行。Unix 中解决此问题的方法是设置 `set user ID (setuid)` 权限。这是一个可以使用 `chmod` 设置的附加文件权限位。当带有此标志的程序执行时，它将以文件所有者的用户 ID 运行。

```
reader@hacking:~/booksrc $ which chsh
/usr/bin/chsh
reader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd
-rw-r--r-- 1 root root  1424 2007-09-06 21:05 /etc/passwd
-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh
reader@hacking:~/booksrc $
```

`chsh` 程序设置了 `setuid` 标志，这在上面 `ls` 输出的 `s` 中有所指示。由于此文件属于 root 用户并且设置了 `setuid` 权限，因此当任何用户运行此程序时，程序将以 root 用户身份运行。`chsh` 写入的 `/etc/passwd` 文件也属于 root 用户，并且只允许所有者写入。`chsh` 中的程序逻辑设计为只允许写入与运行程序的用户对应的 `/etc/passwd` 中的行，尽管程序实际上是以 root 身份运行的。这意味着正在运行程序具有真实用户 ID 和有效用户 ID。这些 ID 可以分别使用 `getuid()` 和 `geteuid()` 函数检索，如 uid_demo.c 中所示。

### uid_demo.c

```
#include <stdio.h>

int main() {
   printf("real uid: %d\n", getuid());
   printf("effective uid: %d\n", geteuid()); 
}
```

编译和执行 uid_demo.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 999
reader@hacking:~/booksrc $ sudo chown root:root ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo 
real uid: 999
effective uid: 999 
reader@hacking:~/booksrc $
```

在 uid_demo.c 的输出中，当执行 `uid_demo` 时，两个用户 ID 都显示为 999，因为 999 是读者的用户 ID。接下来，使用 `sudo` 命令与 `chown` 命令一起使用，将 `uid_demo` 的所有者和组更改为 root。由于程序对其他用户有执行权限，因此程序仍然可以执行，并且它显示两个用户 ID 仍然为 999，因为那仍然是用户的 ID。

```
reader@hacking:~/booksrc $ chmod u+s ./uid_demo
chmod: changing permissions of `./uid_demo': Operation not permitted
reader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo
reader@hacking:~/booksrc $ ./uid_demo 
real uid: 999
effective uid: 0 
reader@hacking:~/booksrc $
```

由于程序现在属于 root 用户，因此必须使用 `sudo` 来更改其文件权限。`chmod u+s` 命令开启了 `setuid` 权限，这在下面的 `ls -l` 输出中可以看到。现在当用户 reader 执行 `uid_demo` 时，有效用户 ID 为 0（root），这意味着程序可以以 root 身份访问文件。这就是 `chsh` 程序能够允许任何用户更改其存储在 `/etc/passwd` 中的登录 shell 的原因。

这种相同的技术可以用于多用户笔记程序中。下一个程序将是 simplenote 程序的修改版；它还将记录每个笔记原始作者的用户 ID。此外，将引入新的 `#include` 语法。

`ec_malloc()` 和 `fatal()` 函数在我们的许多程序中都很有用。与其将这些函数复制粘贴到每个程序中，不如将它们放入一个单独的包含文件中。

### hacking.h

```
// A function to display an error message and then exit
void fatal(char *message) {
   char error_message[100];

   strcpy(error_message, "[!!] Fatal Error ");
   strncat(error_message, message, 83);
   perror(error_message);
   exit(-1);
}

// An error-checked malloc() wrapper function
void *ec_malloc(unsigned int size) {
   void *ptr;
   ptr = malloc(size);
   if(ptr == NULL)
      fatal("in ec_malloc() on memory allocation");
   return ptr;
}
```

在这个新程序 hacking.h 中，函数可以直接包含。在 C 语言中，当 `#include` 的文件名被 `<` 和 `>` 包围时，编译器会在标准包含路径中查找此文件，例如 /usr/include/。如果文件名被引号包围，编译器会在当前目录中查找。因此，如果 hacking.h 与程序在同一个目录中，可以通过输入 `#include "hacking.h"` 来与该程序一起包含。

新的 notetaker 程序（notetaker.c）中更改的行以粗体显示。

### notetaker.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
`#include "hacking.h"`

void usage(char *prog_name, char *filename) {
   printf("Usage: %s <data to add to %s>\n", prog_name, filename);
   exit(0);
}

void fatal(char *);            // A function for fatal errors
void *ec_malloc(unsigned int); // An error-checked malloc() wrapper

int main(int argc, char *argv[]) {
   `int userid, fd; // File descriptor`
   char *buffer, *datafile;

   buffer = (char *) ec_malloc(100);
   datafile = (char *) ec_malloc(20);
   `strcpy(datafile, "/var/notes");`

   if(argc < 2)                // If there aren't command-line arguments,
      usage(argv[0], datafile); // display usage message and exit.

   strcpy(buffer, argv[1]);  // Copy into buffer.

   printf("[DEBUG] buffer   @ %p: \'%s\'\n", buffer, buffer);
   printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

 // Opening the file
   fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
   if(fd == -1)
      fatal("in main() while opening file");
   printf("[DEBUG] file descriptor is %d\n", fd);

   `userid = getuid(); // Get the real user ID.`

// Writing data
   `if(write(fd, &userid, 4) == -1) // Write user ID before note data.       fatal("in main() while writing userid to file");    write(fd, "\n", 1); // Terminate line.     if(write(fd, buffer, strlen(buffer)) == -1) // Write note.       fatal("in main() while writing buffer to file");    write(fd, "\n", 1); // Terminate line.`

// Closing file
   if(close(fd) == -1)
      fatal("in main() while closing file");

   printf("Note has been saved.\n");
   free(buffer);
   free(datafile); 
}
```

输出文件已从 /tmp/notes 更改为 /var/notes，因此数据现在存储在一个更永久的位置。使用 `getuid()` 函数获取真实用户 ID，该 ID 写在笔记行之前的数据文件中。由于 `write()` 函数期望一个源指针，因此对整数值 `userid` 使用 `&` 运算符以提供其地址。

```
reader@hacking:~/booksrc $ gcc -o notetaker notetaker.c
reader@hacking:~/booksrc $ sudo chown root:root ./notetaker
reader@hacking:~/booksrc $ sudo chmod u+s ./notetaker
reader@hacking:~/booksrc $ ls -l ./notetaker
-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker
reader@hacking:~/booksrc $ ./notetaker "this is a test of multiuser notes"
[DEBUG] buffer   @ 0x804a008: 'this is a test of multiuser notes'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ ls -l /var/notes
-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes
reader@hacking:~/booksrc $
```

在前面的输出中，notetaker 程序被编译并更改为主属为 root，并设置了 `setuid` 权限。现在当程序执行时，程序以 root 用户身份运行，因此当创建文件 /var/notes 时，它也由 root 拥有。

```
reader@hacking:~/booksrc $ cat /var/notes
cat: /var/notes: Permission denied
reader@hacking:~/booksrc $ sudo cat /var/notes
?
this is a test of multiuser notes
reader@hacking:~/booksrc $ sudo hexdump -C /var/notes
00000000  `e7 03 00 00` 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|
00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 75 73 65 72  |est of multiuser|
00000020  20 6e 6f 74 65 73 0a                              | notes.|
00000027
reader@hacking:~/booksrc $ pcalc 0x03e7
        999             0x3e7           0y1111100111
reader@hacking:~/booksrc $
```

/var/notes 文件包含读者的用户 ID（999）和笔记。由于小端架构，整数 999 的 4 个字节在十六进制中显示为反转（如上粗体所示）。

为了使普通用户能够读取笔记数据，需要一个相应的 `setuid` root 程序。notesearch.c 程序将读取笔记数据，并且只显示由该用户 ID 编写的笔记。此外，还可以提供一个可选的命令行参数作为搜索字符串。当使用此参数时，只有与搜索字符串匹配的笔记将被显示。

### notesearch.c

```
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"
#define FILENAME "/var/notes"

int print_notes(int, int, char *);   // Note printing function.
int find_user_note(int, int);        // Seek in file for a note for user.
int search_note(char *, char *);     // Search for keyword function.
void fatal(char *);                  // Fatal error handler

int main(int argc, char *argv[]) {
   int userid, printing=1, fd; // File descriptor
   char searchstring[100];

   if(argc > 1)                        // If there is an arg,
      strcpy(searchstring, argv[1]);   //   that is the search string;
   else                                // otherwise,
      searchstring[0] = 0;             //   search string is empty.

   userid = getuid();
   fd = open(FILENAME, O_RDONLY);   // Open the file for read-only access.
   if(fd == -1)
      fatal("in main() while opening file for reading");

   while(printing)
      printing = print_notes(fd, userid, searchstring);
   printf("-------[ end of note data ]-------\n");
   close(fd);
}

// A function to print the notes for a given uid that match
// an optional search string;
// returns 0 at end of file, 1 if there are still more notes.
int print_notes(int fd, int uid, char *searchstring) {
   int note_length;
   char byte=0, note_buffer[100];

   note_length = find_user_note(fd, uid);
   if(note_length == -1)  // If end of file reached,
      return 0;           //   return 0.

   read(fd, note_buffer, note_length); // Read note data.
   note_buffer[note_length] = 0;       // Terminate the string.

   if(search_note(note_buffer, searchstring)) // If searchstring found,
      printf(note_buffer);                    //   print the note.
   return 1;
}

// A function to find the next note for a given userID;
// returns -1 if the end of the file is reached;
// otherwise, it returns the length of the found note.
int find_user_note(int fd, int user_uid) {
   int note_uid=-1;
   unsigned char byte;
   int length;

   while(note_uid != user_uid) {  // Loop until a note for user_uid is found.

      if(read(fd, &note_uid, 4) != 4) // Read the uid data.
         return -1; // If 4 bytes aren't read, return end of file code.
      if(read(fd, &byte, 1) != 1) // Read the newline separator.
         return -1;

      byte = length = 0;
      while(byte != '\n') {  // Figure out how many bytes to the end of line.
         if(read(fd, &byte, 1) != 1) // Read a single byte.
            return -1;     // If byte isn't read, return end of file code.
         length++;
      }
   }
   lseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes.

   printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
   return length;
}

// A function to search a note for a given keyword;
// returns 1 if a match is found, 0 if there is no match.
int search_note(char *note, char *keyword) {
   int i, keyword_length, match=0;

   keyword_length = strlen(keyword);
   if(keyword_length == 0)  // If there is no search string,
      return 1;              // always "match".

   for(i=0; i < strlen(note); i++) { // Iterate over bytes in note.
      if(note[i] == keyword[match])  // If byte matches keyword,
         match++;   // get ready to check the next byte;
      else {        //   otherwise,
         if(note[i] == keyword[0]) // if that byte matches first keyword byte,
            match = 1;  // start the match count at 1.
         else
            match = 0;  // Otherwise it is zero.
      }
      if(match == keyword_length) // If there is a full match,
         return 1;   // return matched.
   }
   return 0;  // Return not matched.
}
```

大部分代码应该是有意义的，但有一些新概念。文件名在顶部定义，而不是使用堆内存。此外，使用 `lseek()` 函数来重置文件中的读取位置。函数调用 `lseek(fd, length * -1, SEEK_CUR);` 告诉程序将读取位置向前移动 `length * -1` 个字节。由于这会变成一个负数，因此位置会向后移动 `length` 个字节。

```
reader@hacking:~/booksrc $ gcc -o notesearch notesearch.c
reader@hacking:~/booksrc $ sudo chown root:root ./notesearch
reader@hacking:~/booksrc $ sudo chmod u+s ./notesearch
reader@hacking:~/booksrc $ ./notesearch
[DEBUG] found a 34 byte note for user id 999
this is a test of multiuser notes
-------[ end of note data ]------- 
reader@hacking:~/booksrc $
```

当编译并设置 `setuid` 为 root 时，notesearch 程序按预期工作。但这只是一个单一用户；如果不同的用户使用 notetaker 和 notesearch 程序会发生什么？

```
reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ ./notetaker "This is a note for jose"
[DEBUG] buffer   @ 0x804a008: 'This is a note for jose'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
jose@hacking:/home/reader/booksrc $ ./notesearch 
[DEBUG] found a 24 byte note for user id 501
This is a note for jose
-------[ end of note data ]------- 
jose@hacking:/home/reader/booksrc $
```

当用户 jose 使用这些程序时，真实用户 ID 是 501。这意味着该值将添加到所有使用 notetaker 编写的笔记中，并且只有具有匹配用户 ID 的笔记将由 notesearch 程序显示。

```
reader@hacking:~/booksrc $ ./notetaker "This is another note for the reader user"
[DEBUG] buffer   @ 0x804a008: 'This is another note for the reader user'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.
reader@hacking:~/booksrc $ ./notesearch 
[DEBUG] found a 34 byte note for user id 999
this is a test of multiuser notes
[DEBUG] found a 41 byte note for user id 999
This is another note for the reader user
-------[ end of note data ]------- 
reader@hacking:~/booksrc $
```

类似地，所有面向用户读者的笔记都附有用户 ID 999。尽管笔记记录程序和笔记搜索程序都是`suid`root，并且对`/var/notes`数据文件具有完全的读写权限，但笔记搜索程序中的程序逻辑阻止当前用户查看其他用户的笔记。这非常类似于`/etc/passwd`文件存储所有用户的信息，而像`chsh`和`passwd`这样的程序允许任何用户更改自己的 shell 或密码。

## 结构体

有时候，应该将多个变量分组在一起并作为一个整体处理。在 C 语言中，*结构体*是包含许多其他变量的变量。结构体经常被各种系统函数和库使用，因此理解如何使用结构体是使用这些函数的先决条件。

现在用一个简单的例子就足够了。在处理许多时间函数时，这些函数使用一个名为`tm`的时间结构体，该结构体在`/usr/include/time.h`中定义。结构体的定义如下。

```
	struct tm {
	     int     tm_sec;        /* seconds */
	     int     tm_min;        /* minutes */
	     int     tm_hour;       /* hours */
	     int     tm_mday;       /* day of the month */
	     int     tm_mon;        /* month */
	     int     tm_year;       /* year */
	     int     tm_wday;       /* day of the week */
	     int     tm_yday;       /* day in the year */
	     int     tm_isdst;      /* daylight saving time */ 
	};
```

在定义了这个结构体之后，`struct tm`成为一个可用的变量类型，可以用来声明具有`tm`结构体数据类型的变量和指针。time_example.c 程序演示了这一点。当包含`time.h`头文件时，`tm`结构体被定义，之后用于声明`current_time`和`time_ptr`变量。

### time_example.c

```
#include <stdio.h>
#include <time.h>

int main() {
   long int seconds_since_epoch;
   struct tm current_time, *time_ptr;
   int hour, minute, second, day, month, year;

   seconds_since_epoch = time(0); // Pass time a null pointer as argument.
   printf("time() - seconds since epoch: %ld\n", seconds_since_epoch);

   time_ptr = &current_time;  // Set time_ptr to the address of
                              // the current_time struct.
   localtime_r(&seconds_since_epoch, time_ptr);

   // Three different ways to access struct elements:
   hour = current_time.tm_hour;  // Direct access
   minute = time_ptr->tm_min;    // Access via pointer
   second = *((int *) time_ptr); // Hacky pointer access

   printf("Current time is: %02d:%02d:%02d\n", hour, minute, second); 
}
```

`time()` 函数将返回自 1970 年 1 月 1 日以来的秒数。Unix 系统中的时间相对于这个相当任意的时刻来保持，这也被称为*纪元*。`localtime_r()` 函数期望两个指针作为参数：一个是指自纪元以来的秒数，另一个是指向 `tm` 结构体的指针。指针 `time_ptr` 已经被设置为 `current_time` 的地址，一个空的 `tm` 结构体。使用地址运算符提供 `seconds_since_epoch` 的指针作为 `localtime_r()` 的另一个参数，它填充了 `tm` 结构体的元素。结构体的元素可以通过三种不同的方式访问；前两种是访问结构体元素的正确方式，第三种是一个修改过的解决方案。如果使用结构体变量，可以通过将元素名称添加到变量名称的末尾并使用点号来访问其元素。因此，`current_time.tm_hour` 将访问名为 `current_time` 的 `tm` 结构体中的 `tm_hour` 元素。结构体指针通常被使用，因为传递一个四字节的指针比传递整个数据结构要高效得多。结构体指针如此常见，以至于 C 语言内置了一种方法，可以从结构体指针访问结构体元素，而无需解引用指针。当使用结构体指针如 `time_ptr` 时，可以通过结构体元素名称以类似的方式访问结构体元素，但使用一系列看起来像指向右方的箭头的字符。因此，`time_ptr->tm_min` 将访问 `time_ptr` 所指向的 `tm` 结构体中的 `tm_min` 元素。秒数可以通过这些正确的方法之一访问，使用 `tm_sec` 元素或 `tm` 结构体，但使用了第三种方法。你能弄清楚这种第三种方法是如何工作的吗？

```
reader@hacking:~/booksrc $ gcc time_example.c
reader@hacking:~/booksrc $ ./a.out
time() - seconds since epoch: 1189311588
Current time is: 04:19:48
reader@hacking:~/booksrc $ ./a.out
time() - seconds since epoch: 1189311600
Current time is: 04:20:00
reader@hacking:~/booksrc $
```

程序按预期工作，但在 `tm` 结构体中是如何访问秒数的呢？记住，最终，这都只是内存。由于 `tm_sec` 在 `tm` 结构体的开头定义，这个整数值也在开头。在 `second = *((int *) time_ptr)` 这一行中，变量 `time_ptr` 被从 `tm` 结构体指针转换为整数指针。然后这个转换后的指针被解引用，返回指针地址处的数据。由于 `tm` 结构体的地址也指向这个结构体的第一个元素，这将检索结构体中 `tm_sec` 的整数值。time_example.c 代码（time_example2.c）的以下添加部分也输出了 `current_time` 的字节。这表明 `tm` 结构体的元素在内存中紧挨着。结构体中更低的元素也可以通过简单地增加指针的地址来直接通过指针访问。

### time_example2.c

```
#include <stdio.h>
#include <time.h>

void dump_time_struct_bytes(struct tm *time_ptr, int size) {
   int i;
   unsigned char *raw_ptr;
   printf("bytes of struct located at 0x%08x\n", time_ptr);
   raw_ptr = (unsigned char *) time_ptr;
   for(i=0; i < size; i++)
   {
      printf("%02x ", raw_ptr[i]);
      if(i%16 == 15) // Print a newline every 16 bytes.
         printf("\n");
   }
   printf("\n");
}

int main() {
   long int seconds_since_epoch;
   struct tm current_time, *time_ptr;
   int hour, minute, second, i, *int_ptr;

   seconds_since_epoch = time(0); // Pass time a null pointer as argument.
   printf("time() - seconds since epoch: %ld\n", seconds_since_epoch);

   time_ptr = &current_time;  // Set time_ptr to the address of
                              // the current_time struct.
   localtime_r(&seconds_since_epoch, time_ptr);

   // Three different ways to access struct elements:
   hour = current_time.tm_hour;  // Direct access
   minute = time_ptr->tm_min;    // Access via pointer
   second = *((int *) time_ptr); // Hacky pointer access

   printf("Current time is: %02d:%02d:%02d\n", hour, minute, second);

   dump_time_struct_bytes(time_ptr, sizeof(struct tm));

   minute = hour = 0;  // Clear out minute and hour.
   int_ptr = (int *) time_ptr;

   for(i=0; i < 3; i++) {
      printf("int_ptr @ 0x%08x : %d\n", int_ptr, *int_ptr);
      int_ptr++; // Adding 1 to int_ptr adds 4 to the address,
   }             // since an int is 4 bytes in size. 
}
```

编译并执行 time_example2.c 的结果如下。

```
reader@hacking:~/booksrc $ gcc -g time_example2.c
reader@hacking:~/booksrc $ ./a.out
time() - seconds since epoch: 1189311744
Current time is: 04:22:24
bytes of struct located at 0xbffff7f0
18 00 00 00 16 00 00 00 04 00 00 00 09 00 00 00
08 00 00 00 6b 00 00 00 00 00 00 00 fb 00 00 00
00 00 00 00 00 00 00 00 28 a0 04 08
int_ptr @ 0xbffff7f0 : 24
int_ptr @ 0xbffff7f4 : 22
int_ptr @ 0xbffff7f8 : 4
reader@hacking:~/booksrc $
```

虽然可以通过这种方式访问结构体的内存，但会假设结构体中变量的类型以及变量之间没有填充。由于结构体元素的类型数据也存储在结构体中，因此使用适当的方法访问结构体元素要容易得多。

## 函数指针

指针简单地包含一个内存地址，并赋予一个描述它指向位置的数据类型。通常，指针用于变量；然而，它们也可以用于函数。`funcptr_example.c`程序演示了函数指针的使用。

### funcptr_example.c

```
#include <stdio.h>

int func_one() {
   printf("This is function one\n");
   return 1;
}

int func_two() {
   printf("This is function two\n");
   return 2;
}

int main() {
   int value;
   int (*function_ptr) ();

   function_ptr = func_one;
   printf("function_ptr is 0x%08x\n", function_ptr);
   value = function_ptr();
   printf("value returned was %d\n", value);

   function_ptr = func_two;
   printf("function_ptr is 0x%08x\n", function_ptr);
   value = function_ptr();
   printf("value returned was %d\n", value); 
}
```

在这个程序中，在`main()`函数中声明了一个名为`function_ptr`的函数指针。然后这个指针被设置为指向函数`func_one()`，并调用它；之后它又被设置并用于调用`func_two()`。下面的输出显示了此源代码的编译和执行过程。

```
reader@hacking:~/booksrc $ gcc funcptr_example.c
reader@hacking:~/booksrc $ ./a.out
function_ptr is 0x08048374
This is function one
value returned was 1
function_ptr is 0x0804838d
This is function two
value returned was 2 
reader@hacking:~/booksrc $
```

## 伪随机数

由于计算机是确定性机器，它们无法产生真正的随机数。但许多应用程序需要某种形式的随机性。伪随机数生成函数通过生成一个伪随机数流来满足这一需求。这些函数可以从一个种子数开始生成一个看似随机的数列；然而，使用相同的种子可以再次生成相同的序列。确定性机器无法产生真正的随机性，但如果伪随机生成函数的种子值未知，序列将看起来是随机的。生成器必须使用`srand()`函数用值初始化，从那时起，`rand()`函数将返回一个从 0 到`RAND_MAX`的伪随机数。这些函数和`RAND_MAX`在`stdlib.h`中定义。虽然`rand()`返回的数字看起来是随机的，但它们依赖于提供给`srand()`的种子值。为了在后续程序执行之间保持伪随机性，随机化器每次都必须用不同的值初始化。一种常见的做法是使用自纪元以来的秒数（由`time()`函数返回）作为种子。`rand_example.c`程序演示了这种技术。

### rand_example.c

```
#include <stdio.h>
#include <stdlib.h>

int main() {
   int i;
   printf("RAND_MAX is %u\n", RAND_MAX);
   srand(time(0));

   printf("random values from 0 to RAND_MAX\n");
   for(i=0; i < 8; i++)
      printf("%d\n", rand());
   printf("random values from 1 to 20\n");
   for(i=0; i < 8; i++)
      printf("%d\n", (rand()%20)+1); 
}
```

注意模运算符是如何用来从 1 到 20 获取随机值的。

```
reader@hacking:~/booksrc $ gcc rand_example.c
reader@hacking:~/booksrc $ ./a.out
RAND_MAX is 2147483647
random values from 0 to RAND_MAX
815015288
1315541117
2080969327
450538726
710528035
907694519
1525415338
1843056422
random values from 1 to 20
2
3
8
5
9
1
4
20
reader@hacking:~/booksrc $ ./a.out
RAND_MAX is 2147483647
random values from 0 to RAND_MAX
678789658
577505284
1472754734
2134715072
1227404380
1746681907
341911720
93522744
random values from 1 to 20
6
16
12
19
8
19
2
1
reader@hacking:~/booksrc $
```

程序的输出仅显示随机数。伪随机性也可以用于更复杂的程序，正如本节最后脚本中将看到的那样。

## 一个机会游戏

本节最后的程序是一系列使用我们讨论过的许多概念的随机游戏。程序使用伪随机数生成器函数来提供随机元素。它有三个不同的游戏函数，这些函数通过一个全局函数指针调用，并且它使用结构体来保存玩家的数据，这些数据保存在一个文件中。多用户文件权限和用户 ID 允许多个用户玩游戏并维护他们自己的账户数据。game_of_chance.c 程序代码有大量的文档，你应该能够在这个阶段理解它。

### game_of_chance.c

```
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <time.h>
#include <stdlib.h>
#include "hacking.h"

#define DATAFILE "/var/chance.data" // File to store user data

// Custom user struct to store information about users
struct user {
   int uid;
   int credits;
   int highscore;
   char name[100];
   int (*current_game) ();
};

// Function prototypes
int get_player_data();
void register_new_player();
void update_player_data();
void show_highscore();
void jackpot();
void input_name();
void print_cards(char *, char *, int);
int take_wager(int, int);
void play_the_game();
int pick_a_number();
int dealer_no_match();
int find_the_ace();
void fatal(char *);

// Global variables
struct user player;      // Player struct

int main() {
   int choice, last_game;

   srand(time(0)); // Seed the randomizer with the current time.

   if(get_player_data() == -1)  // Try to read player data from file.
      register_new_player();    // If there is no data, register a new player.

   while(choice != 7) {
      printf("-=[ Game of Chance Menu ]=-\n");
      printf("1 - Play the Pick a Number game\n");
      printf("2 - Play the No Match Dealer game\n");
      printf("3 - Play the Find the Ace game\n");
      printf("4 - View current high score\n");
      printf("5 - Change your user name\n");
      printf("6 - Reset your account at 100 credits\n");
      printf("7 - Quit\n");
      printf("[Name: %s]\n", player.name);
      printf("[You have %u credits] ->  ", player.credits);
      scanf("%d", &choice);

      if((choice < 1) || (choice > 7))
         printf("\n[!!] The number %d is an invalid selection.\n\n", choice);
      else if (choice < 4) {          // Otherwise, choice was a game of some sort.
            if(choice != last_game) { // If the function ptr isn't set
               if(choice == 1)        // then point it at the selected game
                  player.current_game = pick_a_number;
               else if(choice == 2)
                  player.current_game = dealer_no_match;
               else
                  player.current_game = find_the_ace;
               last_game = choice;    // and set last_game.
            }
            play_the_game();          // Play the game.
         }
      else if (choice == 4)
         show_highscore();
      else if (choice == 5) {
         printf("\nChange user name\n");
         printf("Enter your new name: ");
         input_name();
         printf("Your name has been changed.\n\n");
      }
      else if (choice == 6) {
         printf("\nYour account has been reset with 100 credits.\n\n");
         player.credits = 100;
      }
   }
   update_player_data();
   printf("\nThanks for playing! Bye.\n");
}

// This function reads the player data for the current uid
// from the file. It returns -1 if it is unable to find player
// data for the current uid.
int get_player_data() { 
   int fd, uid, read_bytes;
   struct user entry;

   uid = getuid();

   fd = open(DATAFILE, O_RDONLY);
   if(fd == -1) // Can't open the file, maybe it doesn't exist
      return -1;
   read_bytes = read(fd, &entry, sizeof(struct user));    // Read the first chunk.
   while(entry.uid != uid && read_bytes > 0) { // Loop until proper uid is found.
      read_bytes = read(fd, &entry, sizeof(struct user)); // Keep reading.
   }
   close(fd); // Close the file.
   if(read_bytes  < sizeof(struct user)) // This means that the end of file was reached.
      return -1;
   else
      player = entry; // Copy the read entry into the player struct.
   return 1;          // Return a success.
}

// This is the new user registration function.
// It will create a new player account and append it to the file.
void register_new_player()  { 
   int fd;

   printf("-=-={ New Player Registration }=-=-\n");
   printf("Enter your name: ");
   input_name();

   player.uid = getuid();
   player.highscore = player.credits = 100;

   fd = open(DATAFILE, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
   if(fd == -1)
      fatal("in register_new_player() while opening file");
   write(fd, &player, sizeof(struct user));
   close(fd);

   printf("\nWelcome to the Game of Chance %s.\n", player.name);
   printf("You have been given %u credits.\n", player.credits);
}

// This function writes the current player data to the file.
// It is used primarily for updating the credits after games.
void update_player_data() {
   int fd, i, read_uid;
   char burned_byte;

   fd = open(DATAFILE, O_RDWR);
   if(fd == -1) // If open fails here, something is really wrong.
      fatal("in update_player_data() while opening file");
   read(fd, &read_uid, 4);          // Read the uid from the first struct.
   while(read_uid != player.uid) {  // Loop until correct uid is found.
      for(i=0; i < sizeof(struct user) - 4; i++) // Read through the
         read(fd, &burned_byte, 1);             // rest of that struct.
      read(fd, &read_uid, 4);      // Read the uid from the next struct. 
   }
   write(fd, &(player.credits), 4);   // Update credits.
   write(fd, &(player.highscore), 4); // Update highscore.
   write(fd, &(player.name), 100);    // Update name.
   close(fd);
}

// This function will display the current high score and
// the name of the person who set that high score.
void show_highscore() {
   unsigned int top_score = 0;
   char top_name[100];
   struct user entry;
   int fd;

   printf("\n====================| HIGH SCORE |====================\n");
   fd = open(DATAFILE, O_RDONLY);
   if(fd == -1)
      fatal("in show_highscore() while opening file");
   while(read(fd, &entry, sizeof(struct user)) > 0) { // Loop until end of file.
      if(entry.highscore > top_score) {   // If there is a higher score,
            top_score = entry.highscore;  // set top_score to that score
            strcpy(top_name, entry.name); // and top_name to that username.
         }
   }
   close(fd);
   if(top_score > player.highscore)
      printf("%s has the high score of %u\n", top_name, top_score);
   else
      printf("You currently have the high score of %u credits!\n", player.highscore);
   printf("======================================================\n\n");
}

// This function simply awards the jackpot for the Pick a Number game.
void jackpot() {
   printf("*+*+*+*+*+* JACKPOT *+*+*+*+*+*\n");
   printf("You have won the jackpot of 100 credits!\n");
   player.credits += 100;
}

// This function is used to input the player name, since 
// scanf("%s", &whatever) will stop input at the first space.
void input_name() {
   char *name_ptr, input_char='\n';
   while(input_char == '\n')    // Flush any leftover 
      scanf("%c", &input_char); // newline chars.

   name_ptr = (char *) &(player.name); // name_ptr = player name's address
   while(input_char != '\n') {  // Loop until newline.
      *name_ptr = input_char;   // Put the input char into name field.
      scanf("%c", &input_char); // Get the next char.
      name_ptr++;               // Increment the name pointer.
   }
   *name_ptr = 0;  // Terminate the string.
}

// This function prints the 3 cards for the Find the Ace game.
// It expects a message to display, a pointer to the cards array,
// and the card the user has picked as input. If the user_pick is
// -1, then the selection numbers are displayed.
void print_cards(char *message, char *cards, int user_pick) {
   int i;

   printf("\n\t*** %s ***\n", message);
   printf("      \t._.\t._.\t._.\n");
   printf("Cards:\t|%c|\t|%c|\t|%c|\n\t", cards[0], cards[1], cards[2]);
   if(user_pick == -1)
      printf(" 1 \t 2 \t 3\n");
   else {
      for(i=0; i < user_pick; i++)
         printf("\t");
      printf(" ^-- your pick\n");
   }
}

// This function inputs wagers for both the No Match Dealer and
// Find the Ace games. It expects the available credits and the
// previous wager as arguments. The previous_wager is only important
// for the second wager in the Find the Ace game. The function
// returns -1 if the wager is too big or too little, and it returns
// the wager amount otherwise.
int take_wager(int available_credits, int previous_wager) {
   int wager, total_wager;

   printf("How many of your %d credits would you like to wager?  ", available_credits);
   scanf("%d", &wager);
   if(wager < 1) {   // Make sure the wager is greater than 0.
      printf("Nice try, but you must wager a positive number!\n");
      return -1;
   }
   total_wager = previous_wager + wager;
   if(total_wager > available_credits) {  // Confirm available credits
      printf("Your total wager of %d is more than you have!\n", total_wager);
      printf("You only have %d available credits, try again.\n", available_credits);
      return -1;
   }
   return wager;
}

// This function contains a loop to allow the current game to be
// played again. It also writes the new credit totals to file
// after each game is played.
void play_the_game() { 
   int play_again = 1;
   int (*game) ();
   char selection;

   while(play_again) {
      printf("\n[DEBUG] current_game pointer @ 0x%08x\n", player.current_game);
      if(player.current_game() != -1) {         // If the game plays without error and
         if(player.credits > player.highscore)  // a new high score is set,
            player.highscore = player.credits;  // update the highscore.
         printf("\nYou now have %u credits\n", player.credits);
         update_player_data();                  // Write the new credit total to file.
         printf("Would you like to play again? (y/n)  ");
         selection = '\n';
         while(selection == '\n')               // Flush any extra newlines.
            scanf("%c", &selection);
         if(selection == 'n')
            play_again = 0;
      }
      else               // This means the game returned an error,
         play_again = 0; // so return to main menu.
   }
}

// This function is the Pick a Number game.
// It returns -1 if the player doesn't have enough credits.
int pick_a_number() { 
   int pick, winning_number;

   printf("\n####### Pick a Number ######\n");
   printf("This game costs 10 credits to play. Simply pick a number\n");
   printf("between 1 and 20, and if you pick the winning number, you\n");
   printf("will win the jackpot of 100 credits!\n\n");
   winning_number = (rand() % 20) + 1; // Pick a number between 1 and 20.
   if(player.credits < 10) {
      printf("You only have %d credits. That's not enough to play!\n\n", player.credits);
      return -1;  // Not enough credits to play 
   }
   player.credits -= 10; // Deduct 10 credits.
   printf("10 credits have been deducted from your account.\n");
   printf("Pick a number between 1 and 20: ");
   scanf("%d", &pick);

   printf("The winning number is %d\n", winning_number);
   if(pick == winning_number)
      jackpot();
   else
      printf("Sorry, you didn't win.\n");
   return 0;
}

// This is the No Match Dealer game.
// It returns -1 if the player has 0 credits.
int dealer_no_match() { 
   int i, j, numbers[16], wager = -1, match = -1;

   printf("\n::::::: No Match Dealer :::::::\n");
   printf("In this game, you can wager up to all of your credits.\n");
   printf("The dealer will deal out 16 random numbers between 0 and 99.\n");
   printf("If there are no matches among them, you double your money!\n\n");

   if(player.credits == 0) {
      printf("You don't have any credits to wager!\n\n");
      return -1;
   }
   while(wager == -1)
      wager = take_wager(player.credits, 0);

   printf("\t\t::: Dealing out 16 random numbers :::\n");
   for(i=0; i < 16; i++) {
      numbers[i] = rand() % 100; // Pick a number between 0 and 99.
      printf("%2d\t", numbers[i]);
      if(i%8 == 7)               // Print a line break every 8 numbers.
         printf("\n");
   }
   for(i=0; i < 15; i++) {       // Loop looking for matches.
      j = i + 1;
      while(j < 16) {
         if(numbers[i] == numbers[j])
            match = numbers[i];
         j++;
      }
   }
   if(match != -1) {
      printf("The dealer matched the number %d!\n", match);
      printf("You lose %d credits.\n", wager);
      player.credits -= wager;
   } else {
      printf("There were no matches! You win %d credits!\n", wager);
      player.credits += wager;
   }
   return 0;
}

// This is the Find the Ace game.
// It returns -1 if the player has 0 credits.
int find_the_ace() {
   int i, ace, total_wager;
   int invalid_choice, pick = -1, wager_one = -1, wager_two = -1;
   char choice_two, cards[3] = {'X', 'X', 'X'};

   ace = rand()%3; // Place the ace randomly.

   printf("******* Find the Ace *******\n");
   printf("In this game, you can wager up to all of your credits.\n");
   printf("Three cards will be dealt out, two queens and one ace.\n");
   printf("If you find the ace, you will win your wager.\n");
   printf("After choosing a card, one of the queens will be revealed.\n");
   printf("At this point, you may either select a different card or\n");
   printf("increase your wager.\n\n");

   if(player.credits == 0) {
      printf("You don't have any credits to wager!\n\n");
      return -1;
   }

   while(wager_one == -1) // Loop until valid wager is made.
      wager_one = take_wager(player.credits, 0);

   print_cards("Dealing cards", cards, -1);
   pick = -1;
   while((pick < 1) || (pick > 3)) { // Loop until valid pick is made.
      printf("Select a card: 1, 2, or 3  ");
      scanf("%d", &pick);
   }
   pick--; // Adjust the pick since card numbering starts at 0.
   i=0;
   while(i == ace || i == pick) // Keep looping until
      i++;                      // we find a valid queen to reveal.
   cards[i] = 'Q';
   print_cards("Revealing a queen", cards, pick);
   invalid_choice = 1;
   while(invalid_choice) {       // Loop until valid choice is made.
      printf("Would you like to:\n[c]hange your pick\tor\t[i]ncrease your wager?\n");
      printf("Select c or i:  ");
      choice_two = '\n';
      while(choice_two == '\n')  // Flush extra newlines.
         scanf("%c", &choice_two);
      if(choice_two == 'i') {    // Increase wager.
            invalid_choice=0;    // This is a valid choice.
            while(wager_two == -1)   // Loop until valid second wager is made.
               wager_two = take_wager(player.credits, wager_one);
         }
      if(choice_two == 'c') {    // Change pick.
         i = invalid_choice = 0; // Valid choice
         while(i == pick || cards[i] == 'Q') // Loop until the other card
            i++;                             // is found,
         pick = i;                           // and then swap pick.
         printf("Your card pick has been changed to card %d\n", pick+1);
      }
   }

   for(i=0; i < 3; i++) {  // Reveal all of the cards.
      if(ace == i)
         cards[i] = 'A';
      else
         cards[i] = 'Q';
   }
   print_cards("End result", cards, pick);

   if(pick == ace) {  // Handle win.
      printf("You have won %d credits from your first wager\n", wager_one);
      player.credits += wager_one;
      if(wager_two != -1) {
         printf("and an additional %d credits from your second wager!\n", wager_two);
         player.credits += wager_two;
      }
   } else { // Handle loss.
      printf("You have lost %d credits from your first wager\n", wager_one);
      player.credits -= wager_one;
      if(wager_two != -1) {
         printf("and an additional %d credits from your second wager!\n", wager_two);
         player.credits -= wager_two;
      }
   }
   return 0; 
}
```

由于这是一个多用户程序，它会在 /var 目录下写入文件，因此它必须是 suid root。

```
reader@hacking:~/booksrc $ gcc -o game_of_chance game_of_chance.c 
reader@hacking:~/booksrc $ sudo chown root:root ./game_of_chance
reader@hacking:~/booksrc $ sudo chmod u+s ./game_of_chance
reader@hacking:~/booksrc $ ./game_of_chance
-=-={ New Player Registration }=-=-
Enter your name: Jon Erickson

Welcome to the Game of Chance, Jon Erickson.
You have been given 100 credits.
-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jon Erickson]
[You have 100 credits] ->  1

[DEBUG] current_game pointer @ 0x08048e6e

####### Pick a Number ######
This game costs 10 credits to play. Simply pick a number
between 1 and 20, and if you pick the winning number, you
will win the jackpot of 100 credits!

10 credits have been deducted from your account.
Pick a number between 1 and 20: 7
The winning number is 14.
Sorry, you didn't win.

You now have 90 credits.
Would you like to play again? (y/n)  n
-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jon Erickson]
[You have 90 credits] ->  2

[DEBUG] current_game pointer @ 0x08048f61

::::::: No Match Dealer :::::::
In this game you can wager up to all of your credits.
The dealer will deal out 16 random numbers between 0 and 99.
If there are no matches among them, you double your money!

How many of your 90 credits would you like to wager?  30
                ::: Dealing out 16 random numbers :::
88      68      82      51      21      73      80      50
11      64      78      85      39      42      40      95
There were no matches! You win 30 credits!

You now have 120 credits
Would you like to play again? (y/n)  n
-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jon Erickson]
[You have 120 credits] ->  3

[DEBUG] current_game pointer @ 0x0804914c
******* Find the Ace *******
In this game you can wager up to all of your credits.
Three cards will be dealt: two queens and one ace.
If you find the ace, you will win your wager.
After choosing a card, one of the queens will be revealed.
At this point you may either select a different card or
increase your wager.

How many of your 120 credits would you like to wager?  50

        *** Dealing cards ***
        ._.     ._.     ._.
Cards:  |X|     |X|     |X|
         1       2       3
Select a card: 1, 2, or 3:  2

        *** Revealing a queen ***
        ._.     ._.     ._.
Cards:  |X|     |X|     |Q|
                 ^-- your pick
Would you like to
[c]hange your pick      or      [i]ncrease your wager?
Select c or i:  c
Your card pick has been changed to card 1.

        *** End result ***

        ._.     ._.     ._.
Cards:  |A|     |Q|     |Q|
         ^-- your pick
You have won 50 credits from your first wager.

You now have 170 credits.
Would you like to play again? (y/n)  n
-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jon Erickson]
[You have 170 credits] ->  4

====================| HIGH SCORE |====================
You currently have the high score of 170 credits!
======================================================

-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jon Erickson]
[You have 170 credits] ->  7

Thanks for playing! Bye.
reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ ./game_of_chance
-=-={ New Player Registration }=-=-
Enter your name: Jose Ronnick

Welcome to the Game of Chance Jose Ronnick.
You have been given 100 credits.
-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score 5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jose Ronnick]
[You have 100 credits] ->  4
====================| HIGH SCORE |====================
Jon Erickson has the high score of 170.
======================================================

-=[ Game of Chance Menu ]=-
1 - Play the Pick a Number game
2 - Play the No Match Dealer game
3 - Play the Find the Ace game
4 - View current high score
5 - Change your username
6 - Reset your account at 100 credits
7 - Quit
[Name: Jose Ronnick]
[You have 100 credits] ->  7

Thanks for playing! Bye.
jose@hacking:~/booksrc $ exit
exit 
reader@hacking:~/booksrc $
```

试着玩一下这个程序。找到 A 约游戏是一个条件概率原理的演示；尽管它不符合直觉，但改变你的选择将增加你找到 A 约的概率从 33% 提高到 50%。许多人难以理解这个真理——这就是为什么它不符合直觉。黑客的秘密在于理解这样的小众真理，并利用它们产生看似神奇的结果。
