# 第三章 LI(U)NIX 系统管理

![LI(U)NIX 系统管理](img/00001.jpg)

没有计算系统是直接从盒子里运行得最优的。无论你需要调整安全设置、添加用户、定义权限还是安装应用程序——总有事情要做。一旦系统配置得完全符合你的要求，接下来的任务就是维护系统，直到需要升级。然后这个周期又从头开始。这个周期被称为系统管理。精通 Linux 或 Unix 系统管理的管理员了解简单的脚本可以为极客的工具箱增添多少力量和灵活性。忘记那些日常任务吧：让脚本来处理它们。

# 修复错误的文件名

## 修复错误的文件名

### fixFilename.rb

当涉及到文件命名时，存在无限的可能性。可以是简短的缩写文件名，也可以是长描述性文件名，甚至是不合逻辑的随机文件名。某些系统中的文件名可能过长，而其他系统中的文件名可能包含特殊或保留字符。

在*图形用户界面*（GUI）环境中工作可能会导致在命名约定方面养成坏习惯。GUI 环境可以处理文件名中使用的几乎所有字符，但当这些文件名在命令行中访问时，它们会带来很多麻烦。这个脚本的目的是为了记住那些仍然使用命令行的人……包括我自己。对于所有关于文件命名的不可确定性，一个简单的脚本可以帮助清理和组织它们。这个脚本将根据一组特定的规则重命名文件。

当我想起奇怪的文件名时，图片和音乐文件总是浮现在脑海中。如果你正在分享那次特别的度假照片或展示你乐队最新的即兴演奏会，命名方案会因人而异，并且可能与接收者的操作系统冲突。我将向您展示的脚本将根据您的指定格式化每个文件名。这个脚本非常可定制且效率极高，所以找到一些文件名可疑的文件并将它们通过这个脚本处理。当脚本完成后，你会感到非常惊喜。

## 代码

`` #!/usr/bin/ruby   unless ARGV[0]      puts "用法：ruby fixFilename.rb <filename.ext>"      puts "示例：ruby fixFilename.rb '如何（制作）在$500 上赚取 20%的更多利润.pdf'"      exit  end  ![](img/00002.jpg) old_filename = ARGV[0]   unless File.exist?(old_filename)'      puts "#{old_filename}不存在。请重试。" ![](img/00003.jpg)      exit  end  ![](img/00004.jpg) name = File.basename(old_filename, ".*")  ext = File.extname(old_filename)  ![](img/00005.jpg) replacements = {  /;/ => "-",                  /\s/ => "_",                  /\'\`/ => "=",                  /\&/ => "_and_",                  /\$/ => "dollar_",                  /%/ => "_percent",                  /[\(\)\[\]<>]/ => ""                }    replacements.each do |orig, fix|       name.gsub!(orig,fix)  end  ![](img/00006.jpg) File.rename(old_filename, name + ext)  ![](img/00007.jpg) puts "#{old_filename} ---> #{name + ext}"``

## 运行代码

该脚本通过一个命令行参数运行，即要扫描和可能修复的文件名：

```**``./fixFilename.rb *`"How to (make) 20% more on $500.pdf"`*``**```

## 结果

生成的输出将显示旧文件名以及它被转换成了什么。对于这个例子，我创建了一个包含一些讨厌字符的虚假文件。

``*`如何（制作）在$500 上赚取 20%的更多利润.pdf ---> How_to_make_20_percent_more_on_dollar_500.pdf`*``

## 工作原理

如“运行代码”部分所述，此脚本依赖于用户将文件名作为参数传递给脚本 ![](img/00002.jpg)。脚本反过来会连接到文件并确保它确实存在。如果用户输入了文件名中的某些错误，脚本不会崩溃，而是会通知用户输入有误并干净地退出 ![](img/00003.jpg)。

接下来，创建了一个名为`name`的新变量，这样您就可以在不破坏原始文件名的情况下调整它。文件名被从其扩展名中剥离 ![](img/00004.jpg)。我单独隔离了扩展名，以防万一某个过滤器被设置为意外更改扩展名，这样文件仍然可以正常工作。在脚本当前配置中，它只会更改文件名。

该脚本使用名为 `replacements` 的哈希数据结构来存储所有无效字符及其对应的可接受值。将使用包含 `gsub` 方法的代码块来进行所有替换。最终结果是 `name` 将返回，其中所有指定的模式都将被替换。哈希的每一行都专注于特定的“坏字符”！[](../Images/00005.jpg)。首先是分号，它是 Linux 中的保留字符，必须进行转义。而不是处理分号，脚本将其替换为破折号。文件名中的所有空白都被转换为下划线，它们看起来与空白相似。反引号（在美国键盘上，此键位于数字 1 的左上角，与波浪号共享）和撇号被转换为等号。符号如 &、% 和 $ 被转换为单词。最后，检查名称中是否有任何括号、花括号和尖括号。任何找到的都将被移除。

脚本的最后一步是重命名文件。使用 `rename` 方法，脚本将文件重命名为我们全新的操作系统友好名称！[](../Images/00006.jpg)。为了对用户表示友好，脚本显示了旧文件名以及它将被转换成什么！[](../Images/00007.jpg)。

## 漏洞脚本

由于每个规则都是这样创建的，因此对这个脚本的进一步扩展非常容易。如果您有更好的表示百分号的方法，那么您可以轻松地编辑相应的代码行。此外，始终有可能为每个文件添加前缀或后缀。脚本很灵活，所以尝试一些变体，看看您是否喜欢。

# 添加用户

## 添加用户

### addUser.rb

自从图形用户界面（GUIs）的出现以来，向 Unix 和 Linux 系统添加用户变得容易得多。您填写框格，点击添加，就完成了。在 GUIs 之前，以及今天仍然很常见的情况下，系统管理员必须手动在系统上创建每个用户账户。

虽然手动为小型组织创建用户账户的任务可能微不足道，但对于拥有数千用户的庞大企业来说，情况就不同了。手动输入 1,000 个用户的账户信息到计算机系统中是耗时、乏味且最重要的是，浪费人力生产力的。此脚本自动化了向系统添加用户账户的过程。

* * *

### 警告

*此脚本依赖于平台，因此请确保您的系统与命令兼容，以避免损坏您的用户文件*。

* * *

## 代码

` #!/usr/bin/env ruby   #使用带有各种参数的'useradd'命令   print "Enter new username: " ![](img/00002.jpg)    user_name = gets.chomp   #添加用户组 ![](img/00003.jpg)    print "\nEnter primary group: "  gname = gets.chomp  add_user = "-g #{gname} "   while gname      print "\nEnter next group (return blank line when finished): "      gname = gets.chomp      break if gname.empty?      add_user << "-G #{gname} "  end  ![](img/00004.jpg) #定义用户登录时启动的程序   puts "\n\n\n[1] Bourne Again Shell (bash)"  puts "[2] Korn Shell (ksh)"  puts "[3] Z Shell (zsh)"  puts "[4] C Shell (csh)"  print "Which shell do you prefer (default bash)? "   sh_num = gets.chomp.to_i  shell = case sh_num      when 1 then '/bin/bash'      when 2 then '/bin/ksh'      when 3 then '/bin/zsh'      when 4 then '/bin/csh'      else '/bin/bash'  end   add_user << "-s #{shell} "   #定义家目录   add_user << "-d /home/#{user_name} "   #定义起始文件夹   add_user << "-m #{user_name}"   #将用户添加到系统并查看返回值 ![](img/00005.jpg) if(system("useradd #{add_user}"))      puts "\n\nSuccessfully added: #{user_name}"  else      puts "\n\nUnable to add: #{user_name}"  end`

## 运行代码

你可以通过遵循脚本给出的提示将用户添加到你的 Unix 类型系统中。通过输入以下命令来运行它：

```**`./addUser.rb`** Enter new username: **``*`steve`*``** How many groups will you add? **``*`2`*``** Enter primary group: **``*`admin`*``** Enter next group: **``*`printer`*``**  [1] Bourne Again Shell (bash) [2] Korn Shell (ksh) [3] Z Shell (zsh) [4] C Shell (csh) Which shell do you prefer (default bash)? **``*`1`*``**  Successfully added: *`steve`*```

## 结果

这个脚本将导致一个用户被添加到你的系统中，其配置由你指定。如果脚本成功，你会看到以下行：

``Successfully added: *`steve`*``

如果你能够更改新账户的密码，那么你就知道脚本实际上已经工作了。我在 Gentoo Linux 计算机上运行了这个脚本，并且如果没有指定密码，所有账户在创建时都被禁用了。只需输入：

```**``passwd *`steve`*``**```

并输入你选择的密码两次。接下来，你可以切换用户，使用你的新凭据登录，然后休息一下。如果脚本在创建账户时失败，你将收到一个错误消息。

## 工作原理

你将不再需要记住每个标志或阅读`man`页面来简单地添加用户。`useradd`命令是一种干净的方式来向系统中添加用户，但标志和选项可能有点晦涩难懂。此外，添加超过几个账户可能会变得繁琐。这个脚本完全交互式，将允许任何具有基本系统知识的人轻松添加用户。

在上面的例子中，脚本实际上创建以下字符串，并使用`system()`命令来执行它：

``useradd -g *`admin`* -G *`printer`* -s /bin/*`bash`* -d /home/*`steve`* -m *`steve`*``

脚本通过请求新账户的用户名来开始构建字符串 ![](img/00002.jpg)。用户名有两个重要原因：它指定了登录凭证的第一部分，并完成了主目录。接下来是组 ![](img/00003.jpg)。在 Unix 风格的系统中，组很重要，因为它们将权限关联到特定的用户名。在这个例子中，我使用了管理员和打印机组——这些完全取决于你的系统中的组。

在授予用户权限后，脚本会请求 shell 预设 ![](img/00004.jpg)。我提供的 shell 列表（bash、ksh、zsh 和 csh）可能并不都在你的系统上安装，所以你需要相应地进行编辑。Bash 是最常用的 shell，所以我将其定义为默认条目，并在我的示例中使用它。

我们命令字符串的最后一个添加项是主目录和用户名。脚本一开始就要求输入用户名，所以使用那个值。主目录最终是 */home/steve*，用户名显然是 *steve*。

最后，使用 `system()` 命令执行字符串 ![](img/00005.jpg)，该命令会启动一个子进程并等待子进程终止。如果子进程成功退出，则返回值 `true`；否则，返回 `false`。

## 破解脚本

希望你能意识到，并非所有标志都是创建用户所必需的，但它们确实在初始账户创建过程中简化了生活。通过添加一些额外的代码，这个脚本可以与 CSV 文件集成，以实现自动化用户创建。

不要被我所描述的数据量所压倒，通过修改这些脚本进行破解。如果你认真想要编写自己的脚本，一个好的起点是调整其他脚本，逐步过渡到从头编写脚本……尤其是当它们涉及许多复杂部分时。

# 修改用户

## 修改用户

### modUser.rb

如果你曾经管理过拥有多个用户的计算机系统，那么你很可能不得不修改现有的账户。根据我的经验，用户账户可以被修改以更新到期日期、更改主目录、调整用户名，或者更常见的是，向其中添加新的组。下面你将找到一个通用的脚本，用于指导用户完成修改过程。请注意，此脚本需要以提升的权限运行。

* * *

### 警告

*此脚本依赖于平台，因此请确保你的系统与命令兼容，以避免损坏你的用户文件*。

* * *

## 代码

` #!/usr/bin/env ruby   #使用带有各种参数的命令'useradd'   print "请输入要修改的用户名: "  user_name = gets.chomp   #确定账户将属于多少个组 ![](img/00002.jpg) print "您想将此账户添加到任何组中吗 [y/n]? "  gresult = gets.chomp ![](img/00003.jpg)     if (gresults == 'y' || gresults == 'Y')      #将组添加到用户中      print "\n 请输入主要组: "      gname = gets.chomp      mod_user = "-g #{gname} "       while gname          print "\n 请输入下一个组: "          gname = gets.chomp          break if gname.empty?          mod_user << "-G #{gname} "      end  end    #定义用户登录时启动的程序  print "您想更改启动的 shell 吗 [y/n]?  sresult = gets.chomp  if (sresults == 'y' || sresults == 'Y')      puts "\n\n\n[1] Bourne Again Shell (bash)"      puts "[2] Korn Shell (ksh)"      puts "[3] Z Shell (zsh)"      puts "[4] C Shell (csh)"      print "您想选择哪个 shell? "       sh_num = gets.chomp.to_i      shell = case sh_num          when 1 then '/bin/bash'          when 2 then '/bin/ksh'          when 3 then '/bin/zsh'          when 4 then '/bin/csh'          else '/bin/bash'      end      mod_user << "-s ${shell} "  end   #定义主目录  print "您想更改主目录吗 [y/n]?  dresult = gets.chomp  if (dresults == 'y' || dresults == 'Y')      print "请输入新目录: "      dir = gets.chomp      mod_user << "-d #{dir} "  end   #定义新的登录名  print "您想更改登录名吗 [y/n]?  lresult = gets.chomp  if (lresults == 'y' || lresults == 'Y')      print "请输入新的登录名: "      name = gets.chomp      mod_user << "-l #{name}"  end   #修改用户并查看返回值  if('usermod #{mod_user}')      puts "\n\n 成功修改：#{user_name}\n"  else      puts "\n\n 无法修改：#{user_name}\n"`

## 运行代码

您至少会被提示五次信息。第一次提示将要求您输入您想要修改的账户的用户名。接下来的四次提示将询问您需要修改账户的哪个部分。

在上面的示例中，我只更改了启动的 shell。下面的脚本交互如下：

```**`./modUser.rb`** Enter the username to modify: **``*`steve`*``** Would you like to add this account to any groups [y/n]? **``*`n`*``** Would you like to change the starting shell [y/n]? **``*`y`*``**     [1] Bourne Again Shell (bash)     [2] Korn Shell (ksh)     [3] Z Shell (zsh)     [4] C Shell (csh) Which shell would you like? **``*`3`*``** Would you like to change the home directory [y/n]? **``*`n`*``** Would you like to change the login name [y/n]? **``*`n`*``**  Successfully modified: *`steve`*```

## 结果

结果将是两条消息之一。要么

``成功修改：*`steve`*``

或

``无法修改：*`steve`*``

如果您无法修改用户，您将需要戴上您的故障排除帽，找出原因。

在示例中，每次我重新登录到 steve 账户时，我现在将启动 Z Shell 而不是 Bash。看看有多简单？这个脚本可以给 Unix 新手，并且可以从终端运行而不用担心。

## 工作原理

脚本的主要组件与 Hacking the Script 中的"#18 添加用户"脚本类似，因为无论你是创建、修改还是删除用户账户，账户的属性都是相同的。虽然我选择了四个我认为最常修改的属性，但它们总是可以被移除以缩短运行时间，或者你可以添加其他属性以满足你的需求。需要修改的属性包括`groups`、`starting shell`、`home directory`和`login name`。

从用户名开始，脚本开始提示系统管理员确定每个属性是否需要修改 ![图片](img/00002.jpg)。每次都使用一个简单的条件语句，并查找字母 *y*。如果用户启用了大写锁定键，脚本也会接受大写字母 *Y*。任何其他输入，无论是 *n*、*N* 还是其他字符，都将被解释为拒绝修改 ![图片](img/00003.jpg)。我本可以将这个选项添加到条件语句中，但我很容易地应用 `.downcase` 到 `gets` 语句，以确保输入始终为小写。

由于脚本的大部分内容都是自我解释的，并且在 Hacking the Script 中的"#18 添加用户"部分有详细说明，因此我不会过多地阐述细节。一个值得注意的有趣点是：如果你希望修改账户的用户名，那么该账户不能被登录。如果你尝试使用`su`切换到管理员账户，然后修改你刚刚离开的账户，你肯定会看到一个友好的消息声明你无法修改特定的用户。

## Hacking the Script

添加用户和修改用户是非常相似的操作，这使得为所有用户操作创建一个一键脚本变得可行。你可以轻松地将 Hacking the Script 中的"#18 添加用户"脚本与此脚本结合，并从中提取一些方法以创建另一个干净的脚本。

# 终止卡住进程

## 终止卡住进程

### killProcess.rb

应用程序是操作系统的美妙补充。但有时它们会卡住，并开始对你的系统进行自我造成的拒绝服务攻击。一些进程非常顽固，需要额外的努力才能完全终止。这个邪恶的小脚本会直观地识别卡住的进程，并自动终止它们。这难道不是避免额外手动工作的好方法吗？

## 代码

```

## 运行代码

脚本几乎完全自主，只需在结束进程前进行确认。要运行它，请输入：

```

## 结果

你将得到一系列关于被识别为违规进程的问题。这些问题将看起来像这样：

```Would you like to kill: /usr/games/blackjack (y/n)? **``*`y`*``** Killing /usr/bin/blackjack (7274) . . . Would you like to kill: /usr/bin/ruby (y/n)? **``*`n`*``**```

## 它是如何工作的

这段代码的美丽之处在于脚本提取 CPU 时间的方式。如果一个进程已经消耗了超过合理时间的 CPU 周期，那么就是时候结束这个进程了。很可能是这个进程卡住了，阻止了其他应用程序，并浪费了宝贵的系统资源。你可以更改时间限制以适应你的需求，但任何时间段都能通过让 CPU 专注于有意义的数据来提高处理器的效率。

在这个脚本中允许的最大时间是按秒设置的。在脚本中，我任意选择了 5 分钟，即 300 秒 ![图片](img/00002.jpg)。这个脚本中使用的数据是通过 Ruby 的强大反引号 ![图片](img/00003.jpg) 从系统中检索的。`ps`命令通过几个参数执行，这将使脚本能够针对滥用进程。`h`标志从`ps`输出中移除标题。由于我们指定了使用的字段，因此不需要标记字段。接下来，`-e`用于显示系统上的所有进程；也可以用`-A`代替`-e`。该标志的第二部分是`o`，该标志允许我们指定输出。命令的其余部分显示了我们要检索的字段：`cputime`、`pcpu`、`pid`、`user`和`command`。

现在数据已经以字符串形式捕获到变量`ps_list`中，必须将其分解成可管理的信息块。这里就派上了高效`.split`命令的用场，它被用来通过每一行来分割字符串 ![图片](img/00004.jpg)。如果你还记得`ps`的输出，每个进程都有自己的行。在将进程分解为其元素之后，我们可以开始检查这些元素。

如果你还没有意识到`.each`的强大功能，你很快就会明白。变量`list`包含每个进程及其详细信息的数组。`.each`指令将遍历每个进程，无论有多少或有多少个![图片](img/00005.jpg)。

尽管我们已经将每个进程与其他进程分开，但我们还需要进一步深入具体进程信息，以隔离字段![图片](img/00006.jpg)。`.split`的默认分隔符是空白。在`.split`之前的进程字符串可能看起来像：

``*`"00:03:04    0.0    1    steve    /usr/bin/ruby"`*``

分割后，它将是一个包含五个元素的数组：

``*`["00:06:04", "0.0", "1", "steve", "/usr/bin/ruby"]`*``

这有多酷？

希望你能看到，每个进程的第一个字段将决定进程的命运。在这个例子中，进程已经运行了六分钟零四秒。为了将数据转换成可用的形式，我们需要将时间转换成秒。我使用了正则表达式和基于时间格式的分组。`=~`操作符是另一个巧妙的功能；它允许你绕过正则表达式`match`方法。我经常使用正则表达式进行输入验证——如果你不知道它们，那么花时间去学习它们是非常值得的！

在正则表达式评估数据后，评估将返回每个分组，由括号表示，表示为`$1-$`*`n`*，其中*`n`*是组的数量![图片](img/00007.jpg)。下一步是将每个值分解成秒。我们知道每小时有 3600 秒，每分钟有 60 秒。因此，我们将每个分组乘以其对应的秒数并将它们相加![图片](img/00008.jpg)。

评估是通过三个`if`语句完成的。另一种选择是使用一个非常长的`if`语句，但我决定反对它，为了保持代码的可读性。一个进程要成为目标，必须满足三个条件。如果这些条件中的任何一个没有得到满足，那么我们就忽略这个进程。这三个条件是：时间超过`$max_time`秒，所有者不是受保护的用户，以及进程不是系统关键进程![图片](img/00009.jpg)。在脚本中，我加入了一些例子，比如`root`和`kdeinit`。在这个区域玩玩，以定制你的需求。

如果你信任脚本只做它所说的，不做更多，你可以移除确认语句。我不完全信任，所以我更喜欢知道我即将终止一个进程。如果用户回答的不是大写或小写的 y，则进程不会被终止——再次强调，我正在使用正则表达式。如果脚本被指示终止进程，它将尝试使用 `TERM` ![图片](img/00011.jpg)。如果你感到特别烦躁，可以自由地将其更改为 `SIGTERM`，因为它是一种更强烈的终止方式。偶尔，一个进程不会死亡，脚本会通知你。你可以继续重试 ![图片](img/00012.jpg)，或者通过回答确认行中的“否”来跳过它。一旦脚本处理完每个进程，它将退出。

# 验证符号链接

## 验证符号链接

### symlinkCheck.rb

*符号链接，或称为符号链接*，由于许多原因而非常出色：它们简化了令人讨厌的长路径名；你可以把它们放在任何你喜欢的地方；你可以称它们为任何你想要的名字；并且它们通常对用户是透明的。虽然符号链接可以做神奇的事情，但它们成为孤儿（即不再指向有效的目标）时真的很糟糕。因此，为了维护符号链接的声誉，我编写了这个脚本来清理自己的……以及他人的。这是一个家务脚本。

## 代码

` #!/usr/bin/ruby  ![图片](img/00002.jpg) unless File.directory?(ARGV[0])   

## 运行代码

脚本仅运行单个目录输入。如果你有一个存放符号链接的目录，这个脚本可以在几秒钟内清理列表。只需输入以下内容：

```**``./symlinkCheck.rb *`/directory/of/symlinks`*``**```

## 结果

脚本将立即输出每个被识别为孤立符号链接的路径——其他所有符号链接将被跳过。输出将类似于以下内容：

``坏链接：*`/home/steve/Desktop/symlink.txt`*``

## 它是如何工作的

用户输入驱动脚本的流程，因此第一步是收集用户输入（我们正在搜索符号链接的目录）。如果提供了无效的参数，用户将收到通知，并且脚本将退出 ![图片](img/00002.jpg)。目录使用 `Dir.open()` 命令打开 ![图片](img/00003.jpg)。在目录成功打开后，过程将被迭代，并对每个文件进行分析。

一个文件要被视为孤儿符号链接，必须满足两个条件。第一个条件通过`next unless`语句进行检查 ![图片 1](img/00004.jpg)。这个语句检查文件是否是符号链接。如果文件不是符号链接，那么脚本就不需要浪费更多时间分析它；调用`next`并继续分析其他文件。如果你幸运的话，文件是符号链接，那么脚本将验证这个符号链接实际上是否链接到了某个东西。这个第二个检查基于符号链接指向的目标：方法`File.file?`将询问目标是否是一个文件 ![图片 2](img/00005.jpg)。如果目标不存在，链接就是孤儿的，必须报告给用户以便进一步操作 ![图片 3](img/00006.jpg)。脚本完成后，输出将显示坏符号链接的完整路径，以便于识别。剩下的工作就是用户找到每个坏链接的目标或者删除符号链接。

## 修改脚本

虽然这个脚本只检查文件的符号链接，但目录也可以有符号链接。你可以修改这个脚本以查找无效的目录以及无效的文件链接。试一试，看看你的机器上存在多少意外无效的链接！
