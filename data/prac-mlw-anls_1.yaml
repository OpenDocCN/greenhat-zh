- en: isolation.tools.setVersion.disable = "TRUE"
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: isolation.tools.setVersion.disable = "TRUE"
- en: isolation.tools.getVersion.disable = "TRUE"
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: isolation.tools.getVersion.disable = "TRUE"
- en: monitor_control.disable_directexec = "TRUE"
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_directexec = "TRUE"
- en: monitor_control.disable_chksimd = "TRUE"
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_chksimd = "TRUE"
- en: monitor_control.disable_ntreloc = "TRUE"
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_ntreloc = "TRUE"
- en: monitor_control.disable_selfmod = "TRUE"
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_selfmod = "TRUE"
- en: monitor_control.disable_reloc = "TRUE"
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_reloc = "TRUE"
- en: monitor_control.disable_btinout = "TRUE"
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_btinout = "TRUE"
- en: monitor_control.disable_btmemspace = "TRUE"
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_btmemspace = "TRUE"
- en: monitor_control.disable_btpriv = "TRUE"
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_btpriv = "TRUE"
- en: monitor_control.disable_btseg = "TRUE"
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: monitor_control.disable_btseg = "TRUE"
- en: '*Listing 17-5: VMware’s* .vmx *file undocumented options used to thwart anti-VM
    techniques* The directexec parameter causes user-mode code to be emulated, instead
    of being run directly on the CPU, thus thwarting certain anti-VM techniques.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表17-5：VMware的* .vmx *文件未记录的选项，用于阻止反VM技术* 直接exec参数导致用户模式代码被模拟，而不是直接在CPU上运行，从而阻止某些反VM技术。'
- en: The first four settings are used by VMware backdoor commands so that VMware
    Tools running in the guest cannot get information about the host.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个设置被VMware后门命令使用，以便在虚拟机中运行的VMware Tools无法获取有关宿主机的信息。
- en: These changes will protect against all of ScoopyNG’s checks, other than the
    sixth, when running on a multiprocessor machine. However, we do not recommend
    using these settings in VMware, because they disable the usefulness of VMware
    Tools and they may have serious negative effects on the performance of your virtual
    machines. Add these options only after you’ve Anti-Virtual Machine Techniques
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将防止在多处理器机器上运行时ScoopyNG的所有检查，除了第六项。然而，我们不推荐在VMware中使用这些设置，因为它们禁用了VMware Tools的有用性，并且可能对虚拟机的性能产生严重影响。只有在您已经尝试了反虚拟机技术之后，才添加这些选项。
- en: '**379**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**379**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: exhausted all other techniques. These techniques have been mentioned for completeness,
    but modifying a *.vmx* file to try to catch ten of the potentially hundreds of
    ways that VMware might be detected can be a bit of a wild-goose chase.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试了所有其他技术。这些技术被提及是为了完整性，但修改*.vmx*文件以尝试捕捉VMware可能被检测到的数百种潜在方式中的十种可能是一种徒劳的追求。
- en: '**Escaping the Virtual Machine**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**逃离虚拟机**'
- en: VMware has its vulnerabilities, which can be exploited to crash the host operating
    system or even run code in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: VMware有其漏洞，可以利用这些漏洞来崩溃宿主操作系统，甚至在其中运行代码。
- en: Many publicized vulnerabilities are found in VMware’s shared folders feature
    or in tools that exploit the drag-and-drop functionality of VMware Tools.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公开的漏洞都发现存在于VMware的共享文件夹功能或利用VMware Tools拖放功能的工具中。
- en: One well-publicized vulnerability uses shared folders to allow a guest to write
    to any file on the host operating system in order to modify or compromise the
    host operating system. Although this particular technique doesn’t work with the
    current version of VMware, several different flaws have been discovered in the
    shared folders feature. Disable shared folders in the virtual machine settings
    to prevent this type of attack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一种广为人知的漏洞利用共享文件夹允许来宾向宿主操作系统的任何文件写入，以修改或损害宿主操作系统。尽管这种特定技术不适用于当前版本的VMware，但已在共享文件夹功能中发现了几个不同的漏洞。在虚拟机设置中禁用共享文件夹以防止此类攻击。
- en: Another well-publicized vulnerability was found in the virtual machine display
    function in VMware. An exploit for this vulnerability is known as Cloudburst,
    and it is publicly available as part of the Canvas penetration-testing tool (this
    vulnerability has also been patched by VMware).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在VMware的虚拟机显示功能中也发现了一个广为人知的漏洞。这个漏洞的利用程序被称为Cloudburst，它是Canvas渗透测试工具的一部分公开可用（VMware也已经修复了这个漏洞）。
- en: Certain publicly available tools assist in exploiting VMware once the host has
    been infected, including VMchat, VMcat, VMftp, VMdrag-n-hack, and VMdrag-n-sploit.
    These tools are of little use until you have escaped the virtual machine, and
    you shouldn’t need to worry about them if malware is being run in the virtual
    machine.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦宿主机被感染，某些公开可用的工具可以帮助利用VMware，包括VMchat、VMcat、VMftp、VMdrag-n-hack和VMdrag-n-sploit。这些工具在你从虚拟机中逃脱之前几乎没有用处，如果你在虚拟机中运行恶意软件，你也不必担心它们。
- en: '**Conclusion**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter introduced the most popular anti-VMware techniques. Because malware
    authors use these techniques to slow down analysis, it’s important to be able
    to recognize them. We have explained these techniques in detail so that you can
    find them in disassembly or debugging, and we’ve explored ways to overcome them
    without needing to modify malware at the disassembly level.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了最流行的反 VMware 技术。由于恶意软件作者使用这些技术来减缓分析，因此能够识别它们非常重要。我们已经详细解释了这些技术，以便您可以在反汇编或调试中找到它们，并且我们已经探讨了在不修改反汇编级别的恶意软件的情况下克服它们的方法。
- en: When performing basic dynamic analysis, you should always use a virtual machine.
    However, if your subject malware doesn’t seem to run, consider trying another
    virtual machine with VMware Tools uninstalled before debugging or disassembling
    the malware in search of virtual machine detection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行基本动态分析时，您应该始终使用虚拟机。但是，如果您的目标恶意软件似乎无法运行，在调试或反汇编恶意软件以寻找虚拟机检测之前，请考虑尝试使用未安装 VMware
    Tools 的另一个虚拟机。
- en: You might also run your subject malware in a different virtual environment (like
    VirtualBox or Parallels) or even on a physical machine.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在不同的虚拟环境中（如 VirtualBox 或 Parallels）或甚至在物理机上运行您的目标恶意软件。
- en: As with anti-debugging techniques, anti-VM techniques can be spotted using common
    sense while slowly debugging a process. For example, if you see code terminating
    prematurely at a conditional jump, it may be doing so as a result of an anti-VM
    technique. As always, be aware of these types of issues and look ahead in the
    code to determine what action to take.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与反调试技术一样，在缓慢调试进程时，可以使用常识来发现反 VMware 技术。例如，如果你看到代码在条件跳转处提前终止，那么它可能是由于反 VMware
    技术导致的。始终要意识到这些问题，并在代码中向前查看以确定采取什么行动。
- en: '**380**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**380**'
- en: Chapter 17
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第 17 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: '**Lab 17-1**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 17-1**'
- en: Analyze the malware found in *Lab17-01.exe* inside VMware. This is the same
    malware as *Lab07-01.exe*, with added anti-VMware techniques.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 分析在 VMware 中 *Lab17-01.exe* 中发现的恶意软件。这与 *Lab07-01.exe* 中的恶意软件相同，增加了反 VMware
    技术。
- en: '**NOTE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The anti-VM techniques found in this lab may not work in your environment.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*本实验中发现的反 VMware 技术可能在您的环境中不起作用。*'
- en: '***Questions***'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What anti-VM techniques does this malware use?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种恶意软件使用了哪些反 VMware 技术？
- en: 2\.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: If you have the commercial version of IDA Pro, run the IDA Python script from
    Listing 17-4 in Chapter 17 (provided here as *findAntiVM.py*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拥有 IDA Pro 的商业版本，请运行第 17 章中提供的 *findAntiVM.py*（见列表 17-4）的 IDA Python 脚本。
- en: What does it find?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它发现了什么？
- en: 3\.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: What happens when each anti-VM technique succeeds?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每种反 VMware 技术成功时会发生什么？
- en: 4\.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: Which of these anti-VM techniques work against your virtual machine?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些反 VMware 技术对您的虚拟机有效？
- en: 5\.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: Why does each anti-VM technique work or fail?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么每个反 VMware 技术有效或失败？
- en: 6\.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: How could you disable these anti-VM techniques and get the malware to run?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如何禁用这些反 VMware 技术，并使恶意软件运行？
- en: '**Lab 17-2**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 17-2**'
- en: 'Analyze the malware found in the file *Lab17-02.dll* inside VMware. After answering
    the first question in this lab, try to run the installation exports using *rundll32.exe*
    and monitor them with a tool like procmon. The following is an example command
    line for executing the DLL:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 分析在 VMware 中文件 *Lab17-02.dll* 中发现的恶意软件。在回答本实验的第一个问题后，尝试使用 *rundll32.exe* 运行安装导出，并使用类似
    procmon 的工具进行监控。以下是一个执行 DLL 的示例命令行：
- en: rundll32.exe Lab17-02.dll,InstallRT (or InstallSA/InstallSB)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: rundll32.exe Lab17-02.dll,InstallRT (或 InstallSA/InstallSB)
- en: '***Questions***'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What are the exports for this DLL?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 DLL 的导出是什么？
- en: 2\.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: What happens after the attempted installation using *rundll32.exe*?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *rundll32.exe* 尝试安装后会发生什么？
- en: 3\.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: Which files are created and what do they contain?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些文件被创建，它们包含什么内容？
- en: 4\.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: What method of anti-VM is in use?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正在使用哪种反 VMware 技术？
- en: 5\.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: How could you force the malware to install during runtime?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在运行时强制恶意软件安装？
- en: 6\.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: How could you permanently disable the anti-VM technique?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如何永久禁用反 VMware 技术？
- en: 7\.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 7\.
- en: How does each installation export function work?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安装导出函数是如何工作的？
- en: Anti-Virtual Machine Techniques
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 反虚拟机技术
- en: '**381**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**381**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Lab 17-3**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 17-3**'
- en: Analyze the malware *Lab17-03.exe* inside VMware. This lab is similar to *Lab12-02.exe*,
    with added anti-VMware techniques.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 VMware 中的恶意软件 *Lab17-03.exe*。这个实验与 *Lab12-02.exe* 类似，增加了反 VMware 技术。
- en: '***Questions***'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What happens when you run this malware in a virtual machine?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在虚拟机中运行这个恶意软件时会发生什么？
- en: 2\.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: How could you get this malware to run and drop its keylogger?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何让这个恶意软件运行并放下其键盘记录器？
- en: 3\.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Which anti-VM techniques does this malware use?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件使用哪些反虚拟机技术？
- en: 4\.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What system changes could you make to permanently avoid the anti-VM
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做出哪些系统更改以永久避免反虚拟机
- en: techniques used by this malware?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件使用的技巧？
- en: 5\.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: How could you patch the binary in OllyDbg to force the anti-VM techniques to
    permanently fail?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在OllyDbg中修补二进制文件，以强制反虚拟机技术永久失效？
- en: '**382**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**382**'
- en: Chapter 17
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第17章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**P A C K E R S A N D U N P A C K I N G**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包器和解包**'
- en: Packing programs, known as *packers*, have become
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*打包器*的打包程序已经变得
- en: extremely popular with malware writers because they
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 极受恶意软件编写者欢迎，因为他们
- en: help malware hide from antivirus software, complicate
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助恶意软件躲避防病毒软件，使问题复杂化
- en: malware analysis, and shrink the size of a malicious
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析，并缩小恶意软件的大小
- en: executable. Most packers are easy to use and are freely available. Basic static
    analysis isn’t useful on a packed program; packed malware must be unpacked before
    it can be analyzed statically, which makes analysis more complicated and challenging.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件。大多数打包器易于使用且免费提供。对打包程序进行基本静态分析没有用；打包的恶意软件在进行分析之前必须先解包，这使得分析更加复杂和具有挑战性。
- en: 'Packers are used on executables for two main reasons: to shrink programs or
    to thwart detection or analysis. Even though there are a wide variety of packers,
    they all follow a similar pattern: They transform an executable to create a new
    executable that stores the transformed executable as data and contains an unpacking
    stub that is called by the OS.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器用于可执行文件的两个主要原因：缩小程序或阻止检测或分析。尽管有各种各样的打包器，但它们都遵循一个类似的模式：它们将可执行文件转换成一个新的可执行文件，该文件将转换后的可执行文件作为数据存储，并包含一个由操作系统调用的解包占位符。
- en: We begin this chapter with some background information about how packers work
    and how to recognize them. Then we will discuss unpacking strategies, starting
    with simple ones and then moving on to strategies that are progressively more
    complicated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始介绍打包器的工作原理和如何识别它们的一些背景信息。然后我们将讨论解包策略，从简单的策略开始，然后逐步过渡到更复杂的策略。
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Packer Anatomy**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包器解剖**'
- en: When malware has been packed, an analyst typically has access to only the packed
    file, and cannot examine the original unpacked program or the program that packed
    the malware. In order to unpack an executable, we must undo the work performed
    by the packer, which requires that we understand how a packer operates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件被打包后，分析师通常只能访问打包文件，无法检查原始未打包的程序或打包恶意软件的程序。为了解包可执行文件，我们必须撤销打包器执行的工作，这要求我们了解打包器的工作原理。
- en: All packers take an executable file as input and produce an executable file
    as output. The packed executable is compressed, encrypted, or otherwise transformed,
    making it harder to recognize and reverse-engineer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所有打包器都将可执行文件作为输入，并生成一个可执行文件作为输出。打包的可执行文件被压缩、加密或进行其他转换，使其更难识别和逆向工程。
- en: Most packers use a compression algorithm to compress the original executable.
    A packer designed to make the file difficult to analyze may encrypt the original
    executable and employ anti-reverse-engineering techniques, such as anti-disassembly,
    anti-debugging, or anti-VM. Packers can pack the entire executable, including
    all data and the resource section, or pack only the code and data sections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数打包器使用压缩算法来压缩原始可执行文件。设计用于使文件难以分析的打包器可能会加密原始可执行文件并采用反逆向工程技术，如反汇编、反调试或反虚拟机。打包器可以打包整个可执行文件，包括所有数据和资源部分，或者只打包代码和数据部分。
- en: To maintain the functionality of the original program, a packing program needs
    to store the program’s import information. The information can be stored in any
    format, and there are several common strategies, which are covered in depth later
    in this chapter. When unpacking a program, reconstructing the import section can
    sometimes be challenging and time-consuming, but it’s necessary for analyzing
    the program’s functionality.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持原始程序的功能，打包程序需要存储程序的导入信息。信息可以存储在任何格式中，本章后面将详细介绍几种常见的策略。在解包程序时，重建导入部分有时可能具有挑战性和耗时，但对于分析程序的功能是必要的。
- en: '***The Unpacking Stub***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***解包占位符***'
- en: Nonpacked executables are loaded by the OS. With packed programs, the unpacking
    stub is loaded by the OS, and then the unpacking stub loads the original program.
    The code entry point for the executable points to the unpacking stub rather than
    the original code. The original program is generally stored in one or more extra
    sections of the file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 未打包的可执行文件由操作系统加载。对于打包程序，解包占位符由操作系统加载，然后解包占位符加载原始程序。可执行文件的代码入口点指向解包占位符而不是原始代码。原始程序通常存储在文件的一个或多个额外部分中。
- en: 'The unpacking stub can be viewed by a malware analyst, and understanding the
    different parts of the stub is fundamental to unpacking the executable. The unpacking
    stub is often small, since it does not contribute to the main functionality of
    the program, and its function is typically simple: unpack the original executable.
    If you attempt to perform static analysis on the packed program, you will be analyzing
    the stub, not the original program.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解包占位符可以被恶意软件分析师查看，理解占位符的不同部分对于解包可执行文件是基本的。解包占位符通常很小，因为它不贡献于程序的主要功能，其功能通常是简单的：解包原始的可执行文件。如果你尝试对打包程序进行静态分析，你将分析的是占位符，而不是原始程序。
- en: 'The unpacking stub performs three steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解包占位符执行三个步骤：
- en: 
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Unpacks the original executable into memory
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将原始可执行文件解包到内存中
- en: 
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Resolves all of the imports of the original executable
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 解析原始可执行文件的所有导入
- en: 
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Transfers execution to the original entry point (OEP)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行权转移到原始入口点（OEP）
- en: '***Loading the Executable***'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '***加载可执行文件***'
- en: When regular executables load, a loader reads the PE header on the disk, and
    allocates memory for each of the executable’s sections based on that header. The
    loader then copies the sections into the allocated spaces in memory.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当常规可执行文件加载时，加载器读取磁盘上的PE头，并根据该头为可执行文件的每个部分分配内存。然后加载器将部分复制到内存中分配的空间。
- en: '**384**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**384**'
- en: Chapter 18
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Packed executables also format the PE header so that the loader will allocate
    space for the sections, which can come from the original program, or the unpacking
    stub can create the sections. The unpacking stub unpacks the code for each section
    and copies it into the space that was allocated. The exact unpacking method used
    depends on the goals of the packer, and it is generally contained within the stub.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的可执行文件也会格式化PE头，以便加载器为部分分配空间，这些空间可以来自原始程序，或者解包占位符可以创建部分。解包占位符解包每个部分的代码，并将其复制到分配的空间中。确切的解包方法取决于打包器的目标，并且通常包含在占位符中。
- en: '***Resolving Imports***'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***解析导入***'
- en: As discussed in Chapter 1, nonpacked PE files include a section that tells the
    loader which functions to import, and another section that stores the addresses
    of the names of all the imported functions. The Windows loader reads the import
    information, determines which functions are needed, and then fills in the addresses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如第1章所述，未打包的PE文件包含一个部分，告诉加载器需要导入哪些函数，以及另一个部分存储所有导入函数名称的地址。Windows加载器读取导入信息，确定需要哪些函数，然后填写地址。
- en: The Windows loader cannot read import information that is packed. For a packed
    executable, the unpacking stub will resolve the imports. The specific approach
    depends on the packer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Windows加载器无法读取打包的导入信息。对于打包的可执行文件，解包占位符将解析导入。具体方法取决于打包器。
- en: The most common approach is to have the unpacking stub import only the LoadLibrary
    and GetProcAddress functions. After the unpacking stub unpacks the original executable,
    it reads the original import information. It will call LoadLibrary for each library,
    in order to load the DLL into memory, and will then use GetProcAddress to get
    the address for each function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法是让解包占位符只导入LoadLibrary和GetProcAddress函数。在解包占位符解包原始可执行文件后，它将读取原始的导入信息。它将为每个库调用LoadLibrary，以便将DLL加载到内存中，然后使用GetProcAddress获取每个函数的地址。
- en: Another approach is to keep the original import table intact, so that the Windows
    loader can load the DLLs and the imported functions. This is the simplest approach,
    since the unpacking stub does not need to resolve the imports. However, static
    analysis of the packed program will reveal all the original imports, so this approach
    lacks stealth. Additionally, since the imported functions are stored in plaintext
    in the executable, the compression possible with this approach is not optimal.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是保持原始导入表完整，以便Windows加载器可以加载DLL和导入函数。这是最简单的方法，因为解包占位符不需要解析导入。然而，对打包程序的静态分析将揭示所有原始导入，因此这种方法缺乏隐蔽性。此外，由于导入函数以明文形式存储在可执行文件中，因此使用这种方法可能无法实现最佳压缩。
- en: A third approach is to keep one import function from each DLL contained in the
    original import table. This approach will reveal only one function per imported
    library during analysis, so it’s stealthier than the previous approach, but analysis
    will still reveal all the libraries that are imported. This approach is simpler
    for the packer to implement than the first approach, since the libraries do not
    need to be loaded by the unpacking stub, but the unpacking stub must still resolve
    the majority of the functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是保留原始导入表中每个DLL的一个导入函数。这种方法在分析过程中将只揭示每个导入库的一个函数，因此比前一种方法更隐蔽，但分析仍然会揭示所有导入的库。这种方法对于打包器来说比第一种方法更容易实现，因为库不需要由解包占位符加载，但解包占位符仍然需要解析大多数函数。
- en: The final approach is the removal of all imports (including LoadLibrary and
    GetProcAddress). The packer must find all the functions needed from other libraries
    without using functions, or it must find LoadLibrary and GetProcAddress, and use
    them to locate all the other libraries. This process is discussed in Chapter 19,
    because it is similar to what shellcode must do.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是删除所有导入（包括LoadLibrary和GetProcAddress）。打包器必须找到从其他库中需要的所有函数，而不使用函数，或者它必须找到LoadLibrary和GetProcAddress，并使用它们来定位所有其他库。这个过程在第19章中讨论，因为它与shellcode必须执行的操作类似。
- en: The benefit of this approach is that the packed program includes no imports
    at all, which makes it stealthy. However, in order to use this approach, the unpacking
    stub must be complex.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是打包的程序根本不包含任何导入，这使得它具有隐蔽性。然而，为了使用这种方法，解包的占位符必须复杂。
- en: Packers and Unpacking
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器和解包器
- en: '**385**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**385**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***The Tail Jump***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***尾部跳转***'
- en: Once the unpacking stub is complete, it must transfer execution to the OEP.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解包占位符完成，它必须将执行权转移到OEP。
- en: The instruction that transfers execution to the OEP is commonly referred to
    as the *tail jump*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将执行权转移到OEP的指令通常被称为*尾部跳转*。
- en: A jump instruction is the simplest and most popular way to transfer execution.
    Since it’s so common, many malicious packers will attempt to obscure this function
    by using a ret or call instruction. Sometimes the tail jump is obscured with OS
    functions that transfer control, such as NtContinue or ZwContinue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令是最简单且最受欢迎的执行转移方式。由于它非常常见，许多恶意打包器会尝试通过使用ret或call指令来隐藏这个功能。有时尾部跳转会通过操作系统函数来隐藏，例如NtContinue或ZwContinue。
- en: '***Unpacking Illustrated***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***解包图解***'
- en: 'Figures 18-1 through 18-4 illustrate the packing and unpacking process, as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-1至图18-4说明了打包和解包过程，如下所示：
- en: 
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Figure 18-1 shows the original executable. The header and sections are visible,
    and the starting point is set to the OEP.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-1显示了原始的可执行文件。头部和段是可见的，起始点设置为OEP。
- en: 
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Figure 18-2 shows the packed executable as it exists on disk. All that is visible
    is the new header, the unpacking stub, and packed original code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-2显示了磁盘上存在的打包可执行文件。可见的只有新的头部、解包占位符和打包的原始代码。
- en: Header
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 头部
- en: Imports
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 导入
- en: Exports
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 导出
- en: Entry Point
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点
- en: .text Section
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .text段
- en: Entry Point
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点
- en: Header
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 头部
- en: .data Section
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: .data段
- en: Unpacking Stub
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解包占位符
- en: Packed
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打包
- en: .rsrc Section
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: .rsrc段
- en: Original Code
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码
- en: '*Figure 18-1: The original executable,*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-1：原始的可执行文件，*'
- en: '*Figure 18-2: The packed executable,*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-2：打包的可执行文件，*'
- en: '*prior to packing*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*在打包之前*'
- en: '*after the original code is packed and*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*在原始代码打包之后* '
- en: '*the unpacking stub is added*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*解包占位符被添加*'
- en: 
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Figure 18-3 shows the packed executable as it exists when it’s loaded into memory.
    The unpacking stub has unpacked the original code, and valid
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-3显示了当它被加载到内存中时的打包可执行文件。解包占位符已经解包了原始代码，并且是有效的
- en: .text and .data sections are visible. The starting point for the executable
    still points to the unpacking stub, and the import table is usually not valid
    at this stage.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: .text和.data节是可见的。可执行文件的起始点仍然指向解包占位符，并且在此阶段导入表通常无效。
- en: 
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Figure 18-4 shows the fully unpacked executable. The import table has been reconstructed,
    and the starting point has been edited to point to the OEP.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-4显示了完全解包的可执行文件。导入表已被重建，起始点已被编辑以指向OEP。
- en: Note that the final unpacked program is different than the original program.
    The unpacked program still has the unpacking stub and any other code that the
    packing program added. The unpacking program has a PE
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最终解包的程序与原始程序不同。解包程序仍然具有解包占位符和打包程序添加的任何其他代码。解包程序有一个PE
- en: header that has been reconstructed by the unpacker and will not be exactly the
    same as the original program.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由解包器重建的标题，并且不会与原始程序完全相同。
- en: '**386**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**386**'
- en: Chapter 18
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Header
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 标题
- en: Header
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 标题
- en: Exports
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 导出
- en: Entry Point
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点
- en: Exports
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 导出
- en: .text Section
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: .text节
- en: .text Section
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: .text节
- en: .data Section
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: .data节
- en: .data Section
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: .data节
- en: .rsrc Section
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: .rsrc节
- en: .rsrc Section
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: .rsrc节
- en: Entry Point
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点
- en: Unpacking Stub
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 解包占位符
- en: Unpacking Stub
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解包占位符
- en: Imports
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 导入
- en: '*Figure 18-3: The program after being*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-3：程序被解包后的*'
- en: '*Figure 18-4: The fully unpacked*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-4：完全解包的*'
- en: '*unpacked and loaded into memory. The*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*解包并加载到内存中。程序*'
- en: '*program. The import table is*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序。导入表是*'
- en: '*unpacking stub unpacks everything neces-*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*解包占位符解包所有必要的*'
- en: '*reconstructed, and the starting*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*重建，并且起始*'
- en: '*sary for the code to run. The program’s*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*必要的代码运行。程序的*'
- en: '*point is back to the original entry*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*点回到原始入口*'
- en: '*starting point still points to the unpacking*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*起始点仍然指向解包*'
- en: '*point (OEP).*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*点（OEP）。*'
- en: '*stub, and there are no imports.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*占位符，并且没有导入。*'
- en: '**Identifying Packed Programs**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别打包程序**'
- en: An early step when analyzing malware is to recognize that it is packed. We have
    covered techniques for detecting if malware is packed in earlier chapters. Here,
    we’ll provide a review and also introduce a new technique.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 分析恶意软件的早期步骤是识别它被打包。我们在前面的章节中介绍了检测恶意软件是否被打包的技术。在这里，我们将进行回顾并介绍一种新技术。
- en: '***Indicators of a Packed Program***'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '***打包程序的指标***'
- en: The following list summarizes signs to look for when determining whether malware
    is packed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表总结了在确定恶意软件是否被打包时需要寻找的迹象。
- en: 
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The program has few imports, and particularly if the only imports are LoadLibrary
    and GetProcAddress.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 程序导入较少，尤其是如果唯一的导入是LoadLibrary和GetProcAddress。
- en: 
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: When the program is opened in IDA Pro, only a small amount of code is recognized
    by the automatic analysis.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在IDA Pro中打开时，自动分析只识别了一小部分代码。
- en: 
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: When the program is opened in OllyDbg, there is a warning that the program may
    be packed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在OllyDbg中打开时，会有一个警告，表明程序可能被打包。
- en: 
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The program shows section names that indicate a particular packer (such as UPX0).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示的节名称表明了特定的打包器（如UPX0）。
- en: 
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The program has abnormal section sizes, such as a .text section with a Size
    of Raw Data of 0 and Virtual Size of nonzero.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 程序有异常的节大小，例如.text节具有原始数据大小为0和虚拟大小非零。
- en: Packer-detection tools such as PEiD can also be used to determine if an executable
    is packed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用PEiD等打包检测工具来确定可执行文件是否被打包。
- en: '***Entropy Calculation***'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***熵计算***'
- en: Packed executables can also be detected via a technique known as *entropy* *calculation*.
    Entropy is a measure of the disorder in a system or program, and while there is
    not a well-defined standard mathematical formula for calculating entropy, there
    are many well-formed measures of entropy for digital data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的可执行文件也可以通过称为*熵* *计算*的技术来检测。熵是系统或程序中无序的度量，虽然没有定义良好的标准数学公式来计算熵，但有许多针对数字数据的熵度量方法。
- en: Packers and Unpacking
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包
- en: '**387**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**387**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Compressed or encrypted data more closely resembles random data, and therefore
    has high entropy; executables that are not encrypted or compressed have lower
    entropy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩或加密的数据更接近随机数据，因此具有高熵；未加密或未压缩的可执行文件具有较低的熵。
- en: Automated tools for detecting packed programs often use heuristics like entropy.
    One such free automated tool is Mandiant Red Curtain, which calculates a threat
    score for any executable using measures such as entropy. Red Curtain can scan
    a filesystem for suspected packed binaries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检测打包程序的自动工具通常使用诸如熵之类的启发式方法。其中一个免费自动工具是Mandiant Red Curtain，它使用诸如熵之类的度量来为任何可执行文件计算威胁分数。Red
    Curtain可以扫描文件系统以查找可疑的打包二进制文件。
- en: '**Unpacking Options**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**解包选项**'
- en: 'There are three options for unpacking a packed executable: automated static
    unpacking, automated dynamic unpacking, and manual dynamic unpacking. The automated
    unpacking techniques are faster and easier than manual dynamic unpacking, but
    automated techniques don’t always work. If you have identified the kind of packer
    used, you should determine if an automated unpacker is available. If not, you
    may be able to find information about how to unpack the packer manually.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解包打包的可执行文件有三种选项：自动静态解包、自动动态解包和手动动态解包。自动解包技术比手动动态解包更快、更简单，但自动技术并不总是有效。如果你已经确定了使用的打包器类型，你应该确定是否有可用的自动解包器。如果没有，你可能能够找到有关如何手动解包打包器的信息。
- en: When dealing with packed malware, remember that your goal is to analyze the
    behavior of the malware, which does not always require you to re-create the original
    malware. Most of the time, when you unpack malware, you create a new binary that
    is not identical to the original, but does all the same things as the original.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理打包的恶意软件时，请记住你的目标是分析恶意软件的行为，这并不总是需要你重新创建原始恶意软件。大多数时候，当你解包恶意软件时，你会创建一个新的二进制文件，它不与原始文件完全相同，但执行所有相同的事情。
- en: '**Automated Unpacking**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动解包**'
- en: Automated static unpacking programs decompress and/or decrypt the executable.
    This is the fastest method, and when it works, it is the best method, since it
    does not run the executable, and it restores the executable to its original state.
    Automatic static unpacking programs are specific to a single packer, and they
    will not work on packers that are designed to thwart analysis.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 自动静态解包程序解压缩和/或解密可执行文件。这是最快的方法，当它有效时，是最佳方法，因为它不运行可执行文件，并将可执行文件恢复到其原始状态。自动静态解包程序针对单个打包器特定，它们不会在旨在阻止分析的工具上工作。
- en: PE Explorer, a free program for working with EXE and DLL files, comes with several
    static unpacking plug-ins as part of the default setup. The default plug-ins support
    NSPack, UPack, and UPX. Unpacking files with PE Explorer is completely seamless.
    If PE Explorer detects that a file you’ve chosen to open is packed, it will automatically
    unpack the executable. Note that if you want to examine the unpacked executable
    outside PE Explorer, you’ll need to save it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PE Explorer，一个用于处理EXE和DLL文件的免费程序，作为默认设置的一部分包含几个静态解包插件。默认插件支持NSPack、UPack和UPX。使用PE
    Explorer解包文件是完全无缝的。如果PE Explorer检测到你选择的要打开的文件是打包的，它将自动解包可执行文件。请注意，如果你想在PE Explorer之外检查解包的可执行文件，你需要将其保存。
- en: Automated dynamic unpackers run the executable and allow the unpacking stub
    to unpack the original executable code. Once the original executable is unpacked,
    the program is written to disk, and the unpacker reconstructs the original import
    table.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 自动动态解包器运行可执行文件，并允许解包占位符解包原始可执行代码。一旦原始可执行文件被解包，程序将被写入磁盘，解包器重建原始导入表。
- en: The automated unpacking program must determine where the unpacking stub ends
    and the original executable begins, which is difficult. When the packer fails
    to identify the end of the unpacking stub correctly, unpacking fails.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 自动解包程序必须确定解包占位符的结束位置和原始可执行文件的开始位置，这是困难的。当打包器未能正确识别解包占位符的结束位置时，解包将失败。
- en: '**388**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**388**'
- en: Chapter 18
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Unfortunately, currently there are no good publicly available automated dynamic
    unpackers. Many publicly available tools will do an adequate job on some packers,
    but none is quite ready for serious usage.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前还没有好的公开可用的自动动态解包器。许多公开可用的工具在处理某些打包器时可以完成足够的工作，但没有一个是完全准备好用于严重使用的。
- en: 'Both automated unpacking techniques work quickly and are easy to use, but they
    have limited success. A malware analyst must know the difference between automated
    static and dynamic unpackers: Automated dynamic unpacking programs run the malicious
    executable, and automated static unpacking programs do not. Any time that the
    malicious program will run, it is necessary to make sure that happens in a safe
    environment, as discussed in Chapter 2\.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 两种自动解包技术都运行得很快，使用起来也很方便，但它们的成功率有限。恶意软件分析师必须知道自动静态解包器和动态解包器之间的区别：自动动态解包程序运行恶意可执行文件，而自动静态解包程序则不运行。每当恶意程序运行时，都必须确保它在安全环境中运行，正如第2章所讨论的那样。
- en: '**Manual Unpacking**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动解包**'
- en: Sometimes, packed malware can be unpacked automatically by an existing program,
    but more often it must be unpacked manually. Manual unpacking can sometimes be
    done quickly, with minimal effort; other times it can be a long, arduous process.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，打包的恶意软件可以通过现有的程序自动解包，但更常见的是必须手动解包。手动解包有时可以快速完成，付出最小的努力；有时它可能是一个漫长而艰巨的过程。
- en: 'There are two common approaches to manually unpacking a program:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解包程序有两种常见的方法：
- en: 
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Discover the packing algorithm and write a program to run it in reverse.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 发现打包算法，并编写一个程序来逆向运行它。
- en: By running the algorithm in reverse, the program undoes each of the steps of
    the packing program. There are automated tools that do this, but this approach
    is still inefficient, since the program written to unpack the malware will be
    specific to the individual packing program used. So, even with automation, this
    process takes a significant amount of time to complete.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逆向运行算法，程序取消打包程序中的每个步骤。有一些自动化工具可以做到这一点，但这种方法仍然效率低下，因为用于解包恶意软件的程序将针对特定的打包程序。因此，即使有自动化，这个过程也需要相当长的时间才能完成。
- en: 
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Run the packed program so that the unpacking stub does the work for you, and
    then dump the process out of memory, and manually fix up the PE header so that
    the program is complete. This is the more efficient approach.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行打包程序，让解包占位符为您完成工作，然后将进程从内存中转储出来，并手动修复PE头，以便程序完整。这是更有效的方法。
- en: Let’s walk through a simple manual unpacking process. For the purposes of this
    example, we’ll unpack an executable that was packed with UPX. Although UPX can
    easily be unpacked automatically with the UPX
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的手动解包过程来了解一下。为了这个示例，我们将解包一个使用UPX打包的可执行文件。尽管UPX可以使用UPX自动解包，但我们将手动进行解包。
- en: program, it is simple and makes a good example. You’ll work through this process
    yourself in the first lab for this chapter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 程序，它简单且是一个很好的例子。您将在本章的第一个实验中亲自完成这个过程。
- en: Begin by loading the packed executable into OllyDbg. The first step is to find
    the OEP, which was the first instruction of the program before it was packed.
    Finding the OEP for a function can be one of the more difficult tasks in the manual
    unpacking process, and will be covered in detail later in the chapter. For this
    example, we will use an automated tool that is a part of the OllyDump plug-in
    for OllyDbg.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将打包的可执行文件加载到OllyDbg中。第一步是找到OEP，这是程序在打包之前的第一个指令。在手动解包过程中，找到函数的OEP可能是更困难的任务之一，将在本章后面详细讨论。在这个例子中，我们将使用OllyDbg的OllyDump插件的一部分自动化工具。
- en: '**NOTE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OllyDump, a plug-in for OllyDbg, has two good features for unpacking: It can*
    *dump the memory of the current process, and it can search for the OEP for a packed*
    *executable.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*OllyDump是OllyDbg的一个插件，具有两个用于解包的良好功能：它可以* *转储当前进程的内存，并且可以搜索打包* *可执行文件的OEP*
    *。*'
- en: Packers and Unpacking
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包
- en: '**389**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**389**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: In OllyDbg, select **Plugins****OllyDump****Find OEP by Section Hop**. The
    program will hit a breakpoint just before the OEP executes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在OllyDbg中，选择**插件****OllyDump****通过段跳转查找OEP**。程序将在OEP执行前遇到断点。
- en: When that breakpoint is hit, all of the code is unpacked into memory, and the
    original program is ready to be run, so the code is visible and available for
    analysis. The only remaining step is to modify the PE header for this code so
    that our analysis tools can interpret the code properly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到这个断点时，所有代码将被解包到内存中，原始程序准备运行，因此代码是可见的，并且可用于分析。唯一剩下的步骤是修改此代码的PE头，以便我们的分析工具可以正确解释代码。
- en: The debugger will be broken on the instruction that is the OEP. Write down the
    value of the OEP, and do not close OllyDbg.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器将在OEP的指令上中断。写下OEP的值，不要关闭OllyDbg。
- en: Now we’ll use the OllyDump plug-in to dump the executable. Select **Plugins****OllyDump****Dump
    Debugged Process**. This will dump everything from process memory onto disk. There
    are a few options on the screen for dumping the file to disk.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用 OllyDump 插件来导出可执行文件。选择 **插件****OllyDump****导出调试进程**。这将把进程内存中的所有内容导出到磁盘上。屏幕上有一些选项用于将文件导出到磁盘。
- en: 'If OllyDbg just dumped the program without making any changes, then the dumped
    program will include the PE header of the packed program, which is not the same
    as the PE header of the unpacked program. We would need to change two things to
    correct the header:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 OllyDbg 只是导出了程序而没有进行任何更改，那么导出的程序将包括打包程序的 PE 头，这不同于解包程序的 PE 头。我们需要更改两件事来纠正头文件：
- en: 
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The import table must be reconstructed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 导入表必须重建。
- en: 
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: The entry point in the PE header must point to the OEP.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: PE 头中的入口点必须指向 OEP。
- en: Fortunately, if you don’t change any of the options on the dump screen, OllyDump
    will perform these steps automatically. The entry point of the executable will
    be set to the current instruction pointer, which in this case was the OEP, and
    the import table will be rebuilt. Click the **Dump** button, and you are finished
    unpacking this executable. We were able to unpack this program in just a few simple
    steps because OEP was located and the import table was reconstructed automatically
    by OllyDump. With complex unpackers it will not be so simple and the rest of the
    chapter covers how to unpack when OllyDump fails.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果你没有在导出屏幕上更改任何选项，OllyDump 将会自动执行这些步骤。可执行文件的入口点将被设置为当前指令指针，在这个例子中是 OEP，并且导入表将被重建。点击
    **导出** 按钮，你就可以完成这个可执行文件的解包。我们之所以能够通过几个简单的步骤解包这个程序，是因为 OEP 被定位，并且导入表是由 OllyDump
    自动重建的。对于复杂的解包器来说，这不会那么简单，本章的其余部分将涵盖 OllyDump 失败时如何解包。
- en: '***Rebuilding the Import Table with Import Reconstructor***'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用导入重建器重建导入表***'
- en: Rebuilding the import table is complicated, and it doesn’t always work in OllyDump.
    The unpacking stub must resolve the imports to allow the application to run, but
    it does not need to rebuild the original import table. When OllyDbg fails, it’s
    useful to try to use Import Reconstructor (ImpRec) to perform these steps.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重建导入表很复杂，并且并不总是在 OllyDump 中有效。解包占位符必须解析导入以允许应用程序运行，但它不需要重建原始的导入表。当 OllyDbg 失败时，尝试使用导入重建器（ImpRec）执行这些步骤是有用的。
- en: ImpRec can be used to repair the import table for packed programs.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ImpRec 可以用来修复打包程序的导入表。
- en: Run ImpRec, and open the drop-down menu at the top of the screen. You should
    see the running processes. Select the packed executable. Next, enter the RVA value
    of the OEP (not the entire address) in the OEP field on the right. For example,
    if the image base is 0x400000 and the OEP is 0x403904, enter **0x3904**. Next,
    click the **IAT autosearch** button. You should see a window with a message stating
    that ImpRec found the original import address table (IAT). Now click **GetImports**.
    A listing of all the files with imported functions should appear on the left side
    of the main window. If the operation was successful, all the imports should say
    valid:YES. If the GetImports function was not successful, then the import table
    cannot be fixed automatically using ImpRec.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 ImpRec，打开屏幕顶部的下拉菜单。你应该能看到正在运行的过程。选择打包的可执行文件。接下来，在右侧的 OEP 字段中输入 OEP 的 RVA
    值（不是整个地址）。例如，如果图像基址是 0x400000，OEP 是 0x403904，则输入 **0x3904**。接下来，点击 **IAT 自动搜索**
    按钮。你应该会看到一个窗口，显示消息表明 ImpRec 找到了原始的导入地址表（IAT）。现在点击 **获取导入**。所有带有导入函数的文件列表应该出现在主窗口的左侧。如果操作成功，所有导入都应该显示为有效：是。如果获取导入函数失败，则无法使用
    ImpRec 自动修复导入表。
- en: '**390**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**390**'
- en: Chapter 18
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Strategies for manually fixing the table are discussed later in this chapter.
    For now, we’ll assume that the import table was discovered successfully.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面将讨论手动修复表的策略。现在，我们假设导入表已成功发现。
- en: Click the **Fix Dump** button. You’ll be asked for the path to the file that
    you dumped earlier with OllyDump, and ImpRec will write out a new file with an
    underscore appended to the filename.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **修复导出** 按钮。你将被要求输入之前使用 OllyDump 导出的文件的路径，ImpRec 将会创建一个新文件，并在文件名后添加下划线。
- en: You can execute the file to make sure that everything has worked, if you’re
    not sure whether you’ve done it correctly. This basic unpacking process will work
    for most packed executables, and should be tried first.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否正确执行了操作，可以执行文件以确保一切正常。这个基本的解包过程将适用于大多数加密的可执行文件，并且应该首先尝试。
- en: As mentioned earlier, the biggest challenge of manually unpacking malware is
    finding the OEP, as we’ll discuss next.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，手动解包恶意软件的最大挑战是找到OEP，我们将在下一节讨论。
- en: '***Finding the OEP***'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '***查找OEP***'
- en: There are many strategies for locating the OEP, and no single strategy will
    work against all packers. Analysts generally develop personal preferences, and
    they will try their favorite strategies first. But to be successful, analysts
    must be familiar with many techniques in case their favorite method does not work.
    Choosing the wrong technique can be frustrating and time-consuming.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定位OEP有许多策略，没有一种策略对所有加密器都有效。分析师通常会有个人偏好，并且会首先尝试他们最喜欢的策略。但为了成功，分析师必须熟悉许多技术，以防他们最喜欢的方
    法不起作用。选择错误的技术可能会令人沮丧且耗时。
- en: Finding the OEP is a skill that must be developed with practice. This section
    contains a variety of strategies to help you develop your skills, but the only
    way to really learn is to practice.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 查找OEP是一项必须通过实践来培养的技能。本节包含各种策略，以帮助您培养技能，但真正学习的方法只有实践。
- en: 'In order to find the OEP, you need to run the malicious program in a debugger
    and use single-stepping and breakpoints. Recall the different types of breakpoints
    described in Chapter 8\. OllyDbg offers four types of breakpoints, which are triggered
    by different conditions: the standard INT 3 breakpoints, the memory breakpoint
    provided by OllyDbg, hardware breakpoints, and run tracing with break conditions.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到OEP，您需要在调试器中运行恶意程序并使用单步执行和断点。回想一下第8章中描述的不同类型的断点。OllyDbg提供四种类型的断点，它们由不同的条件触发：标准的INT
    3断点、OllyDbg提供的内存断点、硬件断点和带有断点条件的运行跟踪。
- en: Packed code and the unpacking stub are often unlike the code that debuggers
    ordinarily deal with. Packed code is often self-modifying, containing call instructions
    that do not return, code that is not marked as code, and other oddities. These
    features can confuse the debuggers and cause breakpoints to fail.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 加密代码和解密stub通常与调试器通常处理的代码不同。加密代码通常是自修改的，包含不返回的调用指令、未标记为代码的代码以及其他奇怪之处。这些特性可能会使调试器困惑并导致断点失败。
- en: Using an automated tool to find the OEP is the easiest strategy, but much like
    the automated unpacking approach, these tools do not always work. You may need
    to find the OEP manually.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动化工具查找OEP是最简单的策略，但就像自动化解包方法一样，这些工具并不总是有效。您可能需要手动找到OEP。
- en: '**Using Automated Tools to Find the OEP**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用自动化工具查找OEP**'
- en: In the previous example, we used an automated tool to find the OEP. The most
    commonly used automatic tool for finding the OEP is the OllyDump plug-in within
    OllyDbg, called Find OEP by Section Hop. Normally, the unpacking stub is in one
    section and the executable is packed into another section. OllyDbg detects when
    there is a transfer from one section to another and breaks there, using either
    the step-over or step-into method. The step-over method will step-over any call
    instructions. Calls are often used to execute code in another section, and this
    method is designed to prevent OllyDbg from incorrectly labeling those calls the
    OEP. However, if a call function does not return, then OllyDbg will not locate
    the OEP.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了一个自动化工具来查找OEP。用于查找OEP最常用的自动化工具是OllyDbg中的OllyDump插件，称为通过段跳转查找OEP。通常，解包stub位于一个部分，而可执行文件被压缩到另一个部分。OllyDbg检测到从一个部分到另一个部分的转移时，会在这里中断，使用单步执行或单步进入方法。单步执行方法会跳过任何调用指令。调用通常用于在另一个部分执行代码，这种方法旨在防止OllyDbg错误地将这些调用标记为OEP。然而，如果一个调用函数没有返回，那么OllyDbg将无法定位OEP。
- en: Packers and Unpacking
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 加密器和解密器
- en: '**391**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**391**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Malicious packers often include call functions that do not return in an effort
    to confuse the analyst and the debugger. The step-into option steps into each
    call function, so it’s more likely to find the OEP, but also more likely to produce
    false positives. In practice you should try both the step-over and the step-into
    methods.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意打包器经常包含不返回的调用函数，以混淆分析师和调试器。单步执行选项会进入每个调用函数，因此更有可能找到OEP，但也更有可能产生假阳性。在实践中，您应该尝试单步执行和单步进入方法。
- en: '**Finding the OEP Manually**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动查找OEP**'
- en: When automated methods for finding the OEP fail, you will need to find it manually.
    The simplest manual strategy is to look for the tail jump. As mentioned earlier,
    this instruction jumps from the unpacking stub to the OEP.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动查找OEP的方法失败时，您需要手动查找。最简单的手动策略是寻找尾部跳转。如前所述，这个指令从解包占位符跳转到OEP。
- en: Normally, it’s a jmp instruction, but some malware authors make it a ret instruction
    in order to evade detection.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它是一个跳转指令，但一些恶意软件作者将其改为返回指令以逃避检测。
- en: Often, the tail jump is the last valid instruction before a bunch of bytes that
    are invalid instructions. These bytes are padding to ensure that the section is
    properly byte-aligned. Generally, IDA Pro is used to search through the packed
    executable for the tail jump. Listing 18-1 shows a simple tail jump example.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尾部跳转是在一系列无效指令之前的最后一个有效指令。这些字节是填充，以确保该部分正确字节对齐。通常，使用IDA Pro在打包的可执行文件中搜索尾部跳转。列表18-1显示了简单的尾部跳转示例。
- en: 00416C31 PUSH EDI
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C31 PUSH EDI
- en: 00416C32 CALL EBP
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C32 CALL EBP
- en: 00416C34 POP EAX
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C34 POP EAX
- en: 00416C35 POPAD
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C35 POPAD
- en: 00416C36 LEA EAX,DWORD PTR SS:[ESP-80]
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C36 LEA EAX,DWORD PTR SS:[ESP-80]
- en: 00416C3A PUSH 0
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C3A PUSH 0
- en: 00416C3C CMP ESP,EAX
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C3C CMP ESP,EAX
- en: 00416C3E JNZ SHORT Sample84.00416C3A
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C3E JNZ SHORT Sample84.00416C3A
- en: 00416C40 SUB ESP,-80
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C40 SUB ESP,-80
- en: 00416C43 JMP Sample84.00401000
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C43 JMP Sample84.00401000
- en: 00416C48 DB 00
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C48 DB 00
- en: 00416C49 DB 00
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C49 DB 00
- en: 00416C4A DB 00
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C4A DB 00
- en: 00416C4B DB 00
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C4B DB 00
- en: 00416C4C DB 00
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C4C DB 00
- en: 00416C4D DB 00
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C4D DB 00
- en: 00416C4E DB 00
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 00416C4E DB 00
- en: '*Listing 18-1: A simple tail jump*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-1：简单的尾部跳转*'
- en: 'This example shows the tail jump for UPX at , which is located at address
    0x00416C43\. Two features indicate clearly that this is the tail jump: It’s located
    at the end of the code, and it links to an address that is very far away. If we
    were examining this jump in a debugger, we would see that there are hundreds of
    0x00 bytes after the jump, which is uncommon; a return generally follows a jump,
    but this one isn’t followed by any meaningful code.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了UPX在地址0x00416C43处的尾部跳转，它位于代码的末尾。两个特征清楚地表明这是尾部跳转：它位于代码的末尾，并且链接到一个非常远的地址。如果我们在一个调试器中检查这个跳转，我们会看到跳转之后有数百个0x00字节，这是不常见的；返回通常跟随跳转，但这个跳转后面没有任何有意义的代码。
- en: The other feature that makes this jump stick out is its size. Normally, jumps
    are used for conditional statements and loops, and go to addresses that are within
    a few hundred bytes, but this jump goes to an address that’s 0x15C43 bytes away.
    That is not consistent with a reasonable jmp statement.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个跳转突出的另一个特征是其大小。通常，跳转用于条件语句和循环，并跳转到距离几百字节内的地址，但这个跳转跳转到距离0x15C43字节远的地址。这与合理的jmp语句不一致。
- en: The graph view in IDA Pro often makes the tail jump very easy to spot, as shown
    in Figure 18-5\. IDA Pro colors a jump red when it can’t determine **392**
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro的图形视图通常使尾部跳转非常容易发现，如图18-5所示。当IDA Pro无法确定**392**时，它会将跳转颜色设置为红色。
- en: Chapter 18
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 89](index-426_1.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Image 89](index-426_1.png)'
- en: where the jump goes. Normally, jumps are within the same function, and IDA Pro
    will draw an arrow to the target of a jmp instruction. In the case of a tail jump,
    IDA Pro encounters an error and colors the jump red.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转的目的地。通常，跳转是在同一个函数内，IDA Pro会在jmp指令的目标处画一个箭头。在尾部跳转的情况下，IDA Pro遇到错误并将跳转颜色设置为红色。
- en: '*Figure 18-5: A tail jump is highlighted in red in the IDA Pro graph view.*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-5：在IDA Pro图形视图中以红色突出显示尾部跳转。*'
- en: The tail jump transfers execution to the original program, which is packed on
    disk. Therefore, the tail jump goes to an address that does not contain valid
    instructions when the unpacking stub starts, but does contain valid instructions
    when the program is running. Listing 18-2 shows the disassembly at the address
    of the jump target when the program is loaded in OllyDbg. The instruction ADD
    BYTE PTR DS:[EAX],AL corresponds to two 0x00
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部跳转将执行权转移到磁盘上打包的原始程序。因此，当解包占位符开始时，尾部跳转会跳转到不包含有效指令的地址，但在程序运行时包含有效指令。列表 18-2
    显示了在 OllyDbg 中加载程序时跳转目标的地址处的反汇编代码。指令 ADD BYTE PTR DS:[EAX],AL 对应于两个 0x00
- en: bytes, which is not a valid instruction, but OllyDbg is attempting to disassemble
    this instruction anyway.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 字节，这不是一个有效的指令，但 OllyDbg 仍然尝试反汇编这个指令。
- en: 00401000 ADD BYTE PTR DS:[EAX],AL
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000 ADD BYTE PTR DS:[EAX],AL
- en: 00401002 ADD BYTE PTR DS:[EAX],AL
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 00401002 ADD BYTE PTR DS:[EAX],AL
- en: 00401004 ADD BYTE PTR DS:[EAX],AL
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 00401004 ADD BYTE PTR DS:[EAX],AL
- en: 00401006 ADD BYTE PTR DS:[EAX],AL
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 00401006 ADD BYTE PTR DS:[EAX],AL
- en: 00401008 ADD BYTE PTR DS:[EAX],AL
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 00401008 ADD BYTE PTR DS:[EAX],AL
- en: 0040100A ADD BYTE PTR DS:[EAX],AL
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100A ADD BYTE PTR DS:[EAX],AL
- en: 0040100C ADD BYTE PTR DS:[EAX],AL
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100C ADD BYTE PTR DS:[EAX],AL
- en: 0040100E ADD BYTE PTR DS:[EAX],AL
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100E ADD BYTE PTR DS:[EAX],AL
- en: '*Listing 18-2: Instruction bytes stored at OEP before the original program
    is unpacked* Packers and Unpacking'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-2：在原始程序解包之前存储在 OEP 的指令字节* 打包和解包'
- en: '**393**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**393**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Listing 18-3 contains the disassembly found at the same address when the tail
    jump is executed. The original executable has been unpacked, and there are now
    valid instructions at that location. This change is another hall-mark of a tail
    jump.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18-3 包含了在执行尾部跳转时在相同地址找到的反汇编代码。原始可执行文件已被解包，现在该位置有有效的指令。这种变化是尾部跳转的另一个标志。
- en: 00401000 CALL Sample84.004010DC
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000 CALL Sample84.004010DC
- en: 00401005 TEST EAX,EAX
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 00401005 TEST EAX,EAX
- en: 00401007 JNZ SHORT Sample84.0040100E
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 00401007 JNZ SHORT Sample84.0040100E
- en: 00401009 CALL Sample84.00401018
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 00401009 CALL Sample84.00401018
- en: 0040100E PUSH EAX
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100E PUSH EAX
- en: 0040100F CALL DWORD PTR DS:[414304] ; kernel32.ExitProcess 00401015 RETN
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F CALL DWORD PTR DS:[414304] ; kernel32.ExitProcess 00401015 RETN
- en: '*Listing 18-3: Instruction bytes stored at OEP after the original program is
    unpacked* Another way to find the tail jump is to set a read breakpoint on the
    stack.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18-3：在原始程序解包后存储在 OEP 的指令字节* 另一种找到尾部跳转的方法是在堆栈上设置一个读取断点。'
- en: Remember for read breakpoints, you must use either a hardware breakpoint or
    an OllyDbg memory breakpoint. Most functions in disassembly, including the unpacking
    stub, begin with a push instruction of some sort, which you can use to your advantage.
    First, make a note of the memory address on the stack where the first value is
    pushed, and then set a breakpoint on read for that stack location.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 记住对于读取断点，你必须使用硬件断点或 OllyDbg 内存断点。大多数反汇编中的函数，包括解包占位符，都以某种类型的压栈指令开始，你可以利用这一点。首先，注意堆栈上第一个值被推入的内存地址，然后在该堆栈位置设置一个读取断点。
- en: After that initial push, everything else on the stack will be higher on the
    stack (at a lower memory address). Only when the unpacking stub is complete will
    that stack address from the original push be accessed. Therefore, that address
    will be accessed via a pop instruction, which will hit the breakpoint and break
    execution. The tail jump is generally just after the pop instruction. It’s often
    necessary to try several different types of breakpoints on that address. A hardware
    breakpoint on read is a good type to try first.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个初始压栈之后，堆栈上的其他所有内容都将位于更高的堆栈上（在较低的内存地址）。只有当解包占位符完成时，才会访问原始压栈的堆栈地址。因此，该地址将通过一个弹出指令来访问，这将触发断点并中断执行。尾部跳转通常就在弹出指令之后。通常需要在该地址尝试几种不同的断点类型。读取硬件断点是一个值得首先尝试的类型。
- en: Note that the OllyDbg interface does not allow you to set a breakpoint in the
    stack window. You must view the stack address in the memory dump window and set
    a breakpoint on it there.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 OllyDbg 界面不允许你在堆栈窗口中设置断点。你必须查看内存转储窗口中的堆栈地址，并在那里设置断点。
- en: Another strategy for manually finding OEP is to set breakpoints after every
    loop in the code. This allows you to monitor each instruction being executed without
    consuming a huge amount of time going through the same code in a loop over and
    over again. Normally, the code will have several loops, including loops within
    loops. Identify the loops by scanning through the code and setting a breakpoint
    after each loop. This method is manually intensive and generally takes longer
    than other methods, but it is easy to comprehend. The biggest pitfall with this
    method is setting a breakpoint in the wrong place, which will cause the executable
    to run to completion without hitting the breakpoint. If this happens, don’t be
    discouraged. Go back to where you left off and keeping setting breakpoints further
    along in the process until you find the OEP.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 手动找到OEP的另一种策略是在代码中的每个循环后设置断点。这允许你监控每条正在执行的指令，而无需花费大量时间重复遍历相同的代码。通常，代码将包含多个循环，包括嵌套循环。通过扫描代码并在每个循环后设置断点来识别循环。这种方法需要手动操作，通常比其他方法耗时更长，但易于理解。这种方法的最大陷阱是在错误的位置设置断点，这会导致可执行文件运行到完成而不触发断点。如果发生这种情况，不要气馁。回到你离开的地方，并在过程中继续设置断点，直到找到OEP。
- en: Another common pitfall is stepping over a function call that never returns.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的陷阱是跳过一个永远不会返回的函数调用。
- en: When you step-over the function call, the program will continue to run, and
    the breakpoint will never be hit. The only way to address this is to start over,
    return to the same function call, and step-into the function instead of stepping
    **394**
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当你跳过函数调用时，程序将继续运行，并且断点永远不会被触发。解决这个问题的唯一方法是重新开始，回到相同的函数调用，并进入函数而不是跳过**394**。
- en: Chapter 18
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: over it. Stepping into every function can be time consuming, so it’s advisable
    to use trial and error to determine when to step-over versus step-into.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 跳入每个函数可能会很耗时，因此建议使用试错法来确定何时跳过，何时进入。
- en: Another strategy for finding the tail jump is to set a breakpoint on GetProcAddress.
    Most unpackers will use GetProcAddress to resolve the imports for the original
    function. A breakpoint that hits on GetProcAddress is far into the unpacking stub,
    but there is still a lot of code before the tail jump. Setting a breakpoint at
    GetProcAddress allows you to bypass the beginning of the unpacking stub, which
    often contains the most complicated code.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 找到尾部跳转的另一种策略是在GetProcAddress上设置断点。大多数解包器都会使用GetProcAddress来解决原始函数的导入。在GetProcAddress上触发的断点位于解包器占位符的深处，但在尾部跳转之前还有很多代码。在GetProcAddress上设置断点允许你绕过解包器占位符的开始部分，这部分通常包含最复杂的代码。
- en: Another approach is to set a breakpoint on a function that you know will be
    called by the original program and work backward. For example, in most Windows
    programs, the OEP can be found at the beginning of a standard wrapper of code
    that is outside the main method. Because the wrapper is always the same, you can
    find it by setting a breakpoint on one of the functions it calls.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是设置一个断点在你知道原始程序将会调用的函数上，然后反向工作。例如，在大多数Windows程序中，OEP可以在主方法之外的标准包装代码的开始处找到。因为包装器总是相同的，你可以通过在它调用的函数之一上设置断点来找到它。
- en: For command-line programs, this wrapper calls the GetVersion and GetCommandLineA
    functions very early in the process, so you can try to break when those functions
    are called. The program isn’t loaded yet, so you can’t set a breakpoint on the
    call to GetVersion, but you can set one on the first instruction of GetVersion,
    which works just as well.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令行程序，这个包装器在过程开始时非常早地调用了GetVersion和GetCommandLineA函数，因此你可以在这些函数被调用时尝试中断。程序尚未加载，因此你无法在GetVersion的调用上设置断点，但你可以在GetVersion的第一条指令上设置断点，这同样有效。
- en: In GUI programs, GetModuleHandleA is usually the first function to be called.
    After the program breaks, examine the previous stack frame to see where the call
    originated. There’s a good chance that the beginning of the function that called
    GetModuleHandleA or GetVersion is the OEP. Beginning at the call instruction,
    scroll up and search for the start of the function. Most functions start with
    push ebp, followed by mov ebp, esp. Try to dump the program with the beginning
    of that function as the OEP. If you’re right, and that function is the OEP, then
    you are finished. If you’re wrong, then the program will still be dumped, because
    the unpacking stub has already finished.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GUI 程序中，GetModuleHandleA 通常是被调用的第一个函数。程序崩溃后，检查之前的堆栈帧以确定调用来源。有很大可能性，调用 GetModuleHandleA
    或 GetVersion 的函数的开始就是 OEP。从调用指令开始，向上滚动并搜索函数的开始。大多数函数以 push ebp 开头，然后是 mov ebp,
    esp。尝试以该函数的开始作为 OEP 来导出程序。如果你是对的，并且该函数是 OEP，那么你就完成了。如果你错了，那么程序仍然会被导出，因为解包占位符已经完成了。
- en: You will be able to view and navigate the program in IDA Pro, but you won’t
    necessarily know where the program starts. You might get lucky and IDA Pro might
    automatically identify WinMain or DllMain.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够在 IDA Pro 中查看和导航程序，但你并不一定知道程序从哪里开始。你可能很幸运，IDA Pro 可能会自动识别 WinMain 或 DllMain。
- en: The last tactic for locating the OEP is to use the Run Trace option in OllyDbg.
    Run Trace gives you a number of additional breakpoint options, and allows you
    to set a breakpoint on a large range of addresses. For example, many packers leave
    the .text section for the original file. Generally, there is nothing in the .text
    section on disk, but the section is left in the PE header so that the loader will
    create space for it in memory. The OEP is always within the original .text section,
    and it is often the first instruction called within that section. The Run Trace
    option allows you to set a breakpoint to trigger whenever any instruction is executed
    within the .text section. When the breakpoint is triggered, the OEP can usually
    be found.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 定位 OEP 的最后一种策略是使用 OllyDbg 中的 Run Trace 选项。Run Trace 提供了多个额外的断点选项，并允许你在大量地址上设置断点。例如，许多打包器保留了原始文件中的
    .text 部分。通常，磁盘上的 .text 部分中没有内容，但该部分保留在 PE 头部，以便加载器在内存中为它创建空间。OEP 总是在原始 .text 部分内，并且通常是该部分中第一个被调用的指令。Run
    Trace 选项允许你设置一个断点，以便在 .text 部分中的任何指令执行时触发。当断点被触发时，OEP 通常可以找到。
- en: '***Repairing the Import Table Manually***'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***手动修复导入表***'
- en: OllyDump and ImpRec are usually able to rebuild the import table by searching
    through the program in memory for what looks like a list of imported functions.
    But sometimes this fails, and you need to learn a little more about how the import
    table works in order to analyze the malware.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDump 和 ImpRec 通常能够通过在内存中的程序中搜索看起来像导入函数列表的内容来重建导入表。但有时这会失败，你需要对导入表的工作原理有更多的了解才能分析恶意软件。
- en: Packers and Unpacking
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 打包器和解包
- en: '**395**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**395**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The import table is actually two tables in memory. The first table is the list
    of names or ordinals used by the loader or unpacking stub to determine which functions
    are needed. The second table is the list of the addresses of all the functions
    that are imported. When the code is running, only the second table is needed,
    so a packer can remove the list of names to thwart analysis. If the list of names
    is removed, then you may need to manually rebuild the table.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 导入表实际上在内存中是两个表。第一个表是加载器或解包占位符使用的名称或序号列表，用于确定需要哪些函数。第二个表是所有导入函数的地址列表。当代码运行时，只需要第二个表，因此打包器可以移除名称列表以阻止分析。如果移除了名称列表，那么可能需要手动重建该表。
- en: Analyzing malware without import information is extremely difficult, so it’s
    best to repair the import information whenever possible. The simplest strategy
    is to repair the imports one at a time as you encounter them in the disassembly.
    To do this, open the file in IDA Pro without any import information. When you
    see a call to an imported function, label that imported function in the disassembly.
    Calls to imported functions are an indirect call to an address that is outside
    the loaded program, as shown in Listing 18-4\.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 没有导入信息分析恶意软件极其困难，因此最好尽可能修复导入信息。最简单的策略是在反汇编中遇到导入时逐个修复它们。为此，在IDA Pro中打开文件，不包含任何导入信息。当你看到对导入函数的调用时，在反汇编中标记该导入函数。对导入函数的调用是对加载程序外地址的间接调用，如列表18-4所示。
- en: push eax
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: push eax
- en: call dword_401244
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: call dword_401244
- en: '...'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'dword_401244: 0x7c4586c8'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'dword_401244: 0x7c4586c8'
- en: '*Listing 18-4: Call to an imported function when the import table is not properly
    reconstructed* The listing shows a call instruction with a target based on a DWORD
    pointer.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-4：当导入表未正确重建时对导入函数的调用* 列表显示了一条基于DWORD指针的目标调用指令。'
- en: In IDA Pro, we navigate to the DWORD and see that it has a value of 0x7c4586c8,
    which is outside our loaded program. Next, we open OllyDbg and navigate to the
    address 0x7c4586c8 to see what is there. OllyDbg has labeled that address WriteFile,
    and we can now label that import address as imp_WriteFile, so that we know what
    the function does. You’ll need to go through these steps for each import you encounter.
    The cross-referencing feature of IDA Pro will then label all calls to the imported
    functions. Once you’ve labeled enough functions, you can effectively analyze the
    malware.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA Pro中，我们导航到DWORD，看到它的值为0x7c4586c8，这个值超出了我们加载的程序。接下来，我们打开OllyDbg并导航到地址0x7c4586c8，看看那里有什么。OllyDbg将该地址标记为WriteFile，现在我们可以将该导入地址标记为imp_WriteFile，这样我们就知道该函数的功能了。你需要为遇到的每个导入执行这些步骤。IDA
    Pro的交叉引用功能将标记所有对导入函数的调用。一旦标记了足够多的函数，你就可以有效地分析恶意软件。
- en: The main drawbacks to this method are that you may need to label a lot of functions,
    and you cannot search for calls to an import until you have labeled it. The other
    drawback to this approach is that you can’t actually run your unpacked program.
    This isn’t a showstopper, because you can use the unpacked program for static
    analysis, and you can still use the packed program for dynamic analysis.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是你可能需要标记很多函数，并且在你标记之前，你不能搜索对导入的调用。这种方法的另一个缺点是你实际上不能运行你的解包程序。这并不是一个致命的问题，因为你可以使用解包程序进行静态分析，你仍然可以使用打包程序进行动态分析。
- en: Another strategy, which does allow you to run the unpacked program, is to manually
    rebuild the import table. If you can find the table of imported functions, then
    you can rebuild the original import table by hand. The PE
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略，这确实允许你运行解包的程序，就是手动重建导入表。如果你能找到导入函数表，那么你可以手动重建原始的导入表。PE
- en: file format is an open standard, and you can enter the imported functions one
    at time, or you could write a script to enter the information for you.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式是一个开放标准，你可以逐个输入导入函数，或者你可以编写一个脚本来为你输入信息。
- en: The biggest drawback is that this approach can be very tedious and time-consuming.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最大缺点是它可能非常繁琐和耗时。
- en: '**396**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**396**'
- en: Chapter 18
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes malware authors use more than one packer. This doubles the work
    for the* *analyst, but with persistence, it’s usually possible to unpack even
    double-packed malware. The strategy is simple: Undo the first layer of packing
    using any of the techniques* *we’ve just described, and then repeat to undo the
    second layer of packing. The strategies* *are the same, regardless of the number
    of packers used.*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时恶意软件作者会使用多个打包器。这会加倍分析员的工作量，但只要有毅力，通常可以解包双层打包的恶意软件。策略很简单：使用我们刚刚描述的任何技术来撤销第一层打包，然后重复操作以撤销第二层打包。策略是相同的，无论使用了多少打包器。*'
- en: '**Tips and Tricks for Common Packers**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见打包器的技巧和窍门**'
- en: This section covers just a sampling of popular packers that you are likely to
    encounter when analyzing malware. For each packer covered, we’ve included a description
    and a strategy for unpacking manually. Automated unpackers are also listed for
    some of these, but they do not always work. For each packer, strategies for finding
    the OEP and potential complications are also included.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅涵盖了您在分析恶意软件时可能遇到的一些流行打包器的样本。对于每个打包器，我们都包括了一个描述和手动解包的策略。对于其中一些打包器，还列出了自动解包器，但它们并不总是有效。对于每个打包器，还包括了查找
    OEP 和潜在问题的策略。
- en: '***UPX***'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '***UPX***'
- en: The most common packer used for malware is the Ultimate Packer for eXecutables
    (UPX). UPX is open source, free, and easy to use, and it supports a wide variety
    of platforms. UPX compresses the executable, and is designed for performance rather
    than security. UPX is popular because of its high decompression speed, and the
    small size and low memory requirements of its decompression routine.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 用于恶意软件的最常见的打包器是 Ultimate Packer for eXecutables (UPX)。UPX 是开源的、免费的，并且易于使用，它支持广泛的平台。UPX
    压缩可执行文件，其设计重点是性能而非安全性。UPX 因其高解压缩速度、小尺寸和低内存要求而受到欢迎。
- en: UPX was not designed to be difficult to reverse-engineer, and it does not pose
    much of a challenge for a malware analyst. Most programs packed with UPX can be
    unpacked with UPX as well, and the command line has a -d option that you can use
    to decompress a UPX-packed executable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: UPX 并未设计成难以逆向工程，它对恶意软件分析师来说并不构成太大挑战。大多数用 UPX 打包的程序也可以用 UPX 解包，并且命令行有一个 -d 选项，您可以使用它来解压缩
    UPX 打包的可执行文件。
- en: Because it’s fairly easy to overcome, UPX is a good packer for learning how
    to manually unpack malware. However, many stealthy malicious programs are designed
    to appear to be packed with UPX, when they are really packed with another packer
    or a modified version of UPX. When this is the case, the UPX program will not
    be able to unpack the executable.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它相对容易克服，UPX 是学习如何手动解包恶意软件的好打包器。然而，许多隐秘的恶意程序被设计成看起来是用 UPX 打包的，而实际上它们是用另一个打包器或
    UPX 的修改版本打包的。在这种情况下，UPX 程序将无法解包可执行文件。
- en: You can find the OEP for UPX by using many of the strategies outlined earlier
    in this chapter. You can also use the Find OEP by Section Hop feature in OllyDump,
    or simply page down through the unpacking stub until you see the tail jump. Dumping
    the file and reconstructing the import table with OllyDump will be successful.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用本章前面概述的许多策略来找到 UPX 的 OEP。您还可以在 OllyDump 中使用“通过段跳转查找 OEP”功能，或者简单地向下翻页通过解包
    stub，直到您看到尾部跳转。使用 OllyDump 导出文件并重建导入表将会有所成功。
- en: '***PECompact***'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '***PECompact***'
- en: PECompact is a commercial packer designed for speed and performance.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: PECompact 是一个为速度和性能设计的商业打包器。
- en: A discontinued free student version is still often used by malware authors.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 已停用的免费学生版本仍然经常被恶意软件作者使用。
- en: Programs packed with this packer can be difficult to unpack, because it includes
    anti-debugging exceptions and obfuscated code. PECompact has a plug-in framework
    that allows third-party tools to be incorporated, and malware authors often include
    third-party tools that make unpacking even more difficult.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此打包器打包的程序可能难以解包，因为它包括反调试异常和混淆代码。PECompact 有一个插件框架，允许集成第三方工具，恶意软件作者经常包括使解包更加困难的第三方工具。
- en: Packers and Unpacking
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包
- en: '**397**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**397**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Unpacking PECompact manually is largely the same as unpacking UPX. The program
    generates some exceptions, so you will need to have OllyDbg set to pass exceptions
    to the program. This was discussed in detail in Chapter 16\.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解包 PECompact 与解包 UPX 大致相同。该程序生成一些异常，因此您需要将 OllyDbg 设置为将异常传递给程序。这在第 16 章中已有详细讨论。
- en: You can find the OEP by looking for the tail jump. Step over a few functions,
    and you will see a tail jump consisting of a jmp eax followed by many 0x00 bytes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过寻找尾部跳转来找到 OEP。跳过几个函数，您将看到一个由 jmp eax 后跟许多 0x00 字节组成的尾部跳转。
- en: '***ASPack***'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '***ASPack***'
- en: ASPack is focused on security, and it employs techniques to make it difficult
    to unpack programs. ASPack uses self-modifying code, which makes it difficult
    to set breakpoints and to analyze in general.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ASPack 专注于安全性，并采用了一些使程序难以解包的技术。ASPack 使用自修改代码，这使得设置断点和一般分析变得困难。
- en: Setting a breakpoint can cause programs packed with ASPack to terminate prematurely,
    but these programs can still be manually unpacked using hardware breakpoints set
    on the stack address. Additionally, ASPack is so popular that there are many automated
    unpackers available. Their effectiveness varies, but automated unpacking is always
    worth trying as a first option.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点可能会导致使用 ASPack 打包的程序提前终止，但仍然可以通过在堆栈地址上设置的硬件断点手动解包。此外，ASPack 非常受欢迎，因此有许多自动化解包器可用。它们的有效性各不相同，但自动化解包始终值得作为首选选项尝试。
- en: Although you may successfully unpack an ASPack packed file using automated techniques,
    most likely you’ll need to unpack files manually. Begin by opening the code for
    the unpacking stub. Early in the code, you will see a PUSHAD instruction. Determine
    which stack addresses are used to store the registers, and set a hardware breakpoint
    on one of those addresses. Ensure that it is set to break on a read instruction.
    When the corresponding POPAD
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能使用自动化技术成功解包 ASPack 打包的文件，但很可能会需要手动解包文件。首先，打开解包占位符的代码。在代码的早期部分，你会看到一个 PUSHAD
    指令。确定哪些堆栈地址用于存储寄存器，并在其中一个地址上设置硬件断点。确保它设置为在读取指令时中断。当相应的 POPAD 指令被调用时，断点将被触发，你将距离指向
    OEP 的尾部跳转指令只有几条指令的距离。
- en: instruction is called, the breakpoint will be triggered and you will be just
    a few instructions away from the tail jump that leads to the OEP.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用该指令时，断点将被触发，你将距离指向 OEP 的尾部跳转指令只有几条指令的距离。
- en: '***Petite***'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '***Petite***'
- en: Petite is similar to ASPack in a number of ways. Petite also uses anti-debugging
    mechanisms to make it difficult to determine the OEP, and the Petite code uses
    single-step exceptions in order to break into the debugger. This can be resolved
    by passing single-step exceptions to the program, as described in Chapter 16\.
    The best strategy is to use a hardware breakpoint on the stack to find the OEP,
    as with ASPack. Petite uses a complicated code structure that makes it easy to
    spot the OEP once you have gotten close because the original code looks normal
    unlike the Petite wrapper code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Petite 在许多方面与 ASPack 相似。Petite 也使用反调试机制来使确定 OEP 非常困难，Petite 代码使用单步异常来中断调试器。这可以通过在第
    16 章中描述的方式将单步异常传递给程序来解决。最佳策略是使用堆栈上的硬件断点来找到 OEP，就像 ASPack 一样。Petite 使用复杂的代码结构，一旦接近
    OEP，就很容易发现，因为原始代码看起来很正常，与 Petite 包装代码不同。
- en: Petite also keeps at least one import from each library in the original import
    table. Although this does not affect how difficult it is to unpack, you can easily
    determine which DLLs the malware uses without unpacking it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'Petite 也保留原始导入表中的每个库至少一个导入。尽管这不会影响解包的难度，但你可以在不解包的情况下轻松确定恶意软件使用的 DLL。 '
- en: '***WinUpack***'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '***WinUpack***'
- en: WinUpack is a packer with a GUI front end, designed for optimal compression,
    and not for security. There is a command-line version of this packer called UPack,
    and there are automated unpackers specific to UPack and WinUpack.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: WinUpack 是一个具有图形用户界面的打包器，旨在实现最佳压缩，而不是为了安全。这个打包器的命令行版本称为 UPack，还有针对 UPack 和 WinUpack
    的特定自动化解包器。
- en: '**398**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**398**'
- en: Chapter 18
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第 18 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Although security isn’t its focus, WinUpack does include security measures that
    make it difficult to find the OEP, and render techniques such as searching for
    the tail jump or using OllyDump useless. Listing 18-5 shows the tail jump for
    this executable.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安全不是其重点，但 WinUpack 仍然包括一些安全措施，这使得找到 OEP 非常困难，并且使搜索尾部跳转或使用 OllyDump 等技术变得无用。列表
    18-5 显示了这个可执行文件的尾部跳转。
- en: 010103A6 POP ECX
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 010103A6 POP ECX
- en: 010103A7 OR ECX,ECX
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 010103A7 OR ECX,ECX
- en: 010103A9 MOV DWORD PTR SS:[EBP+3A8],EAX
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 010103A9 MOV DWORD PTR SS:[EBP+3A8],EAX
- en: 010103AF POPAD
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 010103AF POPAD
- en: 010103B0 JNZ SHORT Sample_upac.010103BA
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 010103B0 JNZ SHORT Sample_upac.010103BA
- en: 010103B2 MOV EAX,1
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 010103B2 MOV EAX,1
- en: 010103B7 RETN 0C
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 010103B7 RETN 0C
- en: 010103BA PUSH Sample_upac.01005F85
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 010103BA PUSH Sample_upac.01005F85
- en: 010103BF RETN
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 010103BF RETN
- en: 010103C0 MOV EAX,DWORD PTR SS:[EBP+426]
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 010103C0 MOV EAX,DWORD PTR SS:[EBP+426]
- en: 010103C6 LEA ECX,DWORD PTR SS:[EBP+43B]
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 010103C6 LEA ECX,DWORD PTR SS:[EBP+43B]
- en: 010103CC PUSH ECX
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 010103CC PUSH ECX
- en: 010103CD PUSH EAX
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 010103CD PUSH EAX
- en: 010103CE CALL DWORD PTR SS:[EBP+F49]
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 010103CE CALL DWORD PTR SS:[EBP+F49]
- en: 010103D4 MOV DWORD PTR SS:[EBP+555],EAX
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 010103D4 MOV DWORD PTR SS:[EBP+555],EAX
- en: 010103DA LEA EAX,DWORD PTR SS:[EBP+447]
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 010103DA LEA EAX,DWORD PTR SS:[EBP+447]
- en: 010103E0 PUSH EAX
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 010103E0 PUSH EAX
- en: 010103E1 CALL DWORD PTR SS:[EBP+F51]
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 010103E1 CALL DWORD PTR SS:[EBP+F51]
- en: 010103E7 MOV DWORD PTR SS:[EBP+42A],EAX
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 010103E7 MOV DWORD PTR SS:[EBP+42A],EAX
- en: '*Listing 18-5: Tail jump for a program packed with UPack* In this listing,
    the tail jump at  is in the middle of the unpacking stub, so it is difficult
    to spot. A push instruction at  followed by a return instruction is extremely
    common for a tail jump. The code jumps all around before arriving at the tail
    jump in order to make it harder to spot. To further obscure the tail jump, the
    push that precedes the retn instruction is modified by the packer shortly before
    it is called. The jump is also not very far, so you can’t identify it by searching
    for long jumps. Because the OEP is in the same section as the unpacking stub,
    OllyDump cannot automatically identify the tail jump via its section-hopping method.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表18-5：使用UPack打包程序的尾部跳转* 在这个列表中，尾部跳转在解包占位符的中间，因此很难发现。在处的一个push指令后面跟着一个return指令对于尾部跳转来说非常常见。代码在到达尾部跳转之前跳来跳去，以使其更难发现。为了进一步隐藏尾部跳转，在调用之前，打包器修改了在retn指令之前的前一个push指令。跳转也不是很远，所以你不能通过搜索长跳转来识别它。因为OEP和解包占位符在同一个节中，所以OllyDump不能通过其节跳转方法自动识别尾部跳转。'
- en: The best strategy for finding the OEP for a program packed with UPack is to
    set a breakpoint on GetProcAddress, and then single-step carefully over instructions
    looking for the loops that set the import resolution. If you set the breakpoints
    at every jmp or call instruction, you will be single-stepping forever, but if
    you set the breakpoints too sparsely, the program will probably miss your breakpoints
    and run until completion.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用UPack打包的程序，找到OEP的最佳策略是在GetProcAddress上设置断点，然后仔细单步执行指令，寻找设置导入解析的循环。如果你在每一个jmp或call指令上设置断点，你将永远单步执行，但如果你设置得太稀疏，程序可能会错过你的断点并运行到完成。
- en: Do not be discouraged if the program runs to completion without hitting your
    breakpoints. Simply restart the application in the debugger and try again. Making
    mistakes is a part of the process. Eventually, you will single-step onto a ret
    instruction that is the tail jump.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序运行到完成而没有触发你的断点，不要气馁。只需在调试器中重新启动应用程序并再次尝试。犯错误是这个过程的一部分。最终，你将单步执行到一个ret指令，它就是尾部跳转。
- en: Sometimes, recognizing the tail jump can be tricky. In this case, it jumps about
    0x4000 bytes away. Most unpacking stubs are much smaller than 0x4000, and a jump
    of that size usually is a jump to the OEP. A good way to double-check is to examine
    the code around the OEP, which should look more like Packers and Unpacking
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，识别尾部跳转可能很棘手。在这种情况下，它跳转大约0x4000字节。大多数解包占位符都比0x4000小得多，而那么大的跳转通常是指向OEP的跳转。一个好的双重检查方法是检查OEP周围的代码，它应该看起来更像是打包和拆包。
- en: '**399**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**399**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: ordinary code compared to the unpacking stub. The unpacking stub often has many
    conditional jumps and returns in the middle of a function, but the code around
    the OEP should not have these unusual elements.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 普通代码与解包占位符相比。解包占位符通常在函数中间有很多条件跳转和返回，但OEP周围的代码不应该有这些不寻常的元素。
- en: Another strategy that works on UPack is to set a breakpoint on GetModuleHandleA
    for GUI programs or GetCommandLineA for command-line programs. In Windows, these
    functions are called shortly after the OEP.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 对于UPack，另一种有效的策略是在GUI程序上对GetModuleHandleA或命令行程序上的GetCommandLineA设置断点。在Windows中，这些函数在OEP之后不久就被调用。
- en: Once the breakpoint is triggered, search backward through the code to find the
    OEP.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发断点，通过代码向后搜索以找到OEP。
- en: Sometimes WinUpack crashes OllyDbg by using a PE header that OllyDbg parses
    incorrectly. In Chapter 16, we showed that OllyDbg isn’t perfect and has issues
    parsing binaries that run just fine on Windows outside the debugger. If you encounter
    this problem, always try to use WinDbg before attempting to decipher PE header
    errors.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，WinUpack会通过使用OllyDbg解析错误的PE头文件来崩溃OllyDbg。在第16章中，我们展示了OllyDbg并不完美，并且存在解析在调试器外Windows上运行良好的二进制文件的问题。如果你遇到这个问题，在尝试解析PE头文件错误之前，总是尝试使用WinDbg。
- en: '***Themida***'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '***Themida***'
- en: Themida is a very complicated packer with many features. Most of the features
    are anti-debugging and anti-analysis, which make it a very secure packer that’s
    difficult to unpack and analyze.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Themida是一个非常复杂的打包器，具有许多功能。大多数功能都是反调试和反分析，这使得它成为一个非常安全的打包器，难以解包和分析。
- en: Themida contains features that prevent analysis with VMware, debuggers, and
    Process Monitor (procmon). Themida also has a kernel component, which makes it
    much more difficult to analyze. Code running in the kernel has very few restrictions,
    and analysis code generally runs in user space, and is therefore subject to more
    restrictions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Themida包含防止使用VMware、调试器和进程监视器（procmon）进行分析的功能。Themida还有一个内核组件，这使得分析变得更加困难。在内核中运行的代码受到的限制非常少，而分析代码通常在用户空间运行，因此受到更多的限制。
- en: Because Themida includes so many features, the packed executable is unusually
    bulky. In addition, unlike most packers, Themida’s code continues to run the entire
    time that the original program is running.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Themida包含了许多功能，因此打包的可执行文件异常庞大。此外，与大多数打包程序不同，Themida的代码在整个原始程序运行期间都会继续运行。
- en: Some automated tools are designed to unpack Themida files, but their success
    varies based on the version of Themida and the settings used when the program
    was packed. Themida has so many features and settings that it is impossible to
    find a single unpacking strategy that will always work.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一些自动化工具被设计用来解包Themida文件，但它们的成功率取决于Themida的版本以及程序打包时使用的设置。Themida有如此多的功能和设置，以至于不可能找到一个始终有效的单一解包策略。
- en: If automated tools don’t work, another great strategy is to use ProcDump to
    dump the process from memory without debugging. ProcDump is a tool from Microsoft
    for dumping the contents of a Windows process. It’s designed to work with a debugger,
    but is not itself a debugger. The biggest advantage of ProcDump is that you can
    dump process memory without stopping or debugging the process, which is extremely
    useful for packers that have advanced anti-debugging measures. Even when you cannot
    debug an executable, you can use ProcDump to dump the unpacked contents while
    the executable is running. This process doesn’t completely restore the original
    executable, but it does allow you to run strings and do some analysis on the code.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动化工具不起作用，另一个很好的策略是使用ProcDump从内存中转储进程而不进行调试。ProcDump是微软的一个工具，用于转储Windows进程的内容。它设计用于与调试器一起工作，但它本身不是一个调试器。ProcDump的最大优点是你可以转储进程内存而不停止或调试进程，这对于具有高级反调试措施的打包程序来说非常有用。即使你无法调试可执行文件，你仍然可以在可执行文件运行时使用ProcDump转储解包的内容。这个过程并不完全恢复原始的可执行文件，但它确实允许你运行strings并在代码上进行一些分析。
- en: '**Analyzing Without Fully Unpacking**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需完全解包的分析**'
- en: Some programs, including those packed with Themida, can be very difficult to
    unpack. At times, you might spend all day trying to unpack a program and have
    no success. Perhaps the packer is using a new technique that you simply **400**
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序，包括使用Themida打包的程序，可能非常难以解包。有时，你可能会花整天时间尝试解包一个程序，但毫无成功。也许打包程序正在使用一种全新的技术，你根本不知道**400**
- en: Chapter 18
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 第18章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: cannot solve. If that happens, you may be in luck—you don’t always need to create
    a fully unpacked working executable in order to analyze a piece of malware.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 无法解决。如果发生这种情况，你可能很幸运——分析恶意软件时，你并不总是需要创建一个完全解包的工作可执行文件。
- en: The simplest case occurs when a program that is unpacked fails to execute because
    you can’t completely repair the import table and PE header. In that case, you
    can still use IDA Pro to analyze the program, even though it is not fully executable.
    Once you have the dumped program on disk, you can have IDA Pro analyze specific
    sections of code by navigating to the memory address and marking that section
    as code. You can also run Strings on the program (as discussed in Chapter 1),
    which might reveal the imported functions and other useful information.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是，一个解包的程序无法执行，因为你无法完全修复导入表和PE头。在这种情况下，你仍然可以使用IDA Pro来分析程序，即使它不是完全可执行的。一旦你在磁盘上有程序的转储，你可以通过导航到内存地址并标记该部分为代码，让IDA
    Pro分析代码的特定部分。你还可以在程序上运行Strings（如第1章所述），这可能揭示导入的函数和其他有用的信息。
- en: The analysis that’s possible without fully unpacking is very limited, but depending
    on your goal, it may be sufficient.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在无需完全解包的情况下进行的分析非常有限，但根据你的目标，它可能足够了。
- en: Some unpackers do not actually unpack the entire original program before the
    program begins running. Instead, they unpack a portion of the original program,
    and run that portion. When it is time to run the next portion of code, that portion
    is unpacked into memory and run. This creates considerable overhead for the executable,
    but makes it very difficult for an analyst to unpack.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 一些解压缩器实际上在程序开始运行之前不会解压缩整个原始程序。相反，它们会解压缩原始程序的一部分，并运行这部分。当需要运行代码的下一部分时，这部分会被解压缩到内存中并运行。这给可执行文件带来了相当大的开销，但使得分析师解压缩变得非常困难。
- en: Reverse-engineering the technique that unpacks individual chunks of code can
    enable you to write a script to unpack all of the code, or at least large portions
    of it. Another option is to focus more on dynamic analysis.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编解压缩单个代码块的技术可以使你编写一个脚本来解压缩所有代码，或者至少是大部分代码。另一种选择是更多地关注动态分析。
- en: '**Packed DLLs**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包 DLL**'
- en: There are additional complications associated with packing DLLs, so this capability
    is not supported by all packers. Handling the exports of the DLL is one complication.
    The export table in the DLL points to the address of the exported functions, and
    if the DLL is packed, then the exported functions are also packed. The packer
    must account for this to ensure that the DLL
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 与打包 DLL 相关还有一些额外的复杂性，因此并非所有打包器都支持此功能。处理 DLL 的导出是一个复杂性。DLL 中的导出表指向导出函数的地址，如果
    DLL 被打包，那么导出函数也会被打包。打包器必须考虑到这一点，以确保 DLL
- en: operates properly.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 运行正常。
- en: Unpacking a DLL is not much different from unpacking an EXE. The key thing to
    remember is that DLLs have an OEP, just like executables. All DLLs have a function
    called DllMain, which is called when the DLL is loaded.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩 DLL 与解压缩 EXE 并没有太大区别。要记住的关键点是 DLL 有一个 OEP，就像可执行文件一样。所有 DLL 都有一个名为 DllMain
    的函数，当 DLL 被加载时会被调用。
- en: The OEP in a DLL is the original start of DllMain. The start address listed
    in the packed DLL is the address of the unpacking stub, which is placed into DllMain
    rather than into the main method. OllyDbg can load DLLs, and OllyDbg has a tool
    called *loadDll.exe*, which allows you to load and debug DLLs.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: DLL 中的 OEP 是 DllMain 的原始起始地址。打包 DLL 中列出的起始地址是解压缩占位符的地址，它被放置在 DllMain 中而不是主方法中。OllyDbg
    可以加载 DLL，OllyDbg 有一个名为 *loadDll.exe* 的工具，允许你加载和调试 DLL。
- en: The problem is that the DllMain method will be called prior to breaking in OllyDbg.
    By the time the break occurs, the unpacking stub will have already executed, and
    it will be very difficult to find the OEP.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 DllMain 方法将在 OllyDbg 中断之前被调用。到断点发生时，解压缩占位符已经执行，这将非常难以找到 OEP。
- en: To get around this, open the PE file and locate the Characteristics field in
    the IMAGE_FILE_HEADER section. The bit in the 0x2000 place in the IMAGE_FILE_HEADER
    is set to 1 for DLLs. If this field is changed to a 0, then the file will be interpreted
    as an executable. OllyDbg will open the program as an EXE, and you will be able
    to apply all of the unpacking strategies discussed in this chapter. After you’ve
    found the OEP, change the bit back so that the program will be treated as a DLL
    again.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，请打开 PE 文件，并在 IMAGE_FILE_HEADER 部分找到 Characteristics 字段。IMAGE_FILE_HEADER
    中的 0x2000 位置的位被设置为 1 用于 DLL。如果这个字段被更改为 0，那么文件将被解释为可执行文件。OllyDbg 将程序作为 EXE 打开，你将能够应用本章讨论的所有解压缩策略。在你找到
    OEP 之后，将位改回，这样程序将再次被当作 DLL 处理。
- en: Packers and Unpacking
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解压缩
- en: '**401**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**401**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Conclusion**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter covered a large number of strategies for dealing with packed software.
    We started with the basics of how packers work and how to unpack software, and
    then discussed some automated unpacking tools and strategies.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了大量处理打包软件的策略。我们从打包器的工作原理和如何解压缩软件的基本知识开始，然后讨论了一些自动解压缩工具和策略。
- en: Next, we covered techniques that can be used to manually unpack malicious software.
    No single strategy or tool will work in all cases, so you need to be familiar
    with several techniques.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了可以用来手动解压缩恶意软件的技术。没有单一的策略或工具在所有情况下都有效，所以你需要熟悉几种技术。
- en: In the next chapter, we will cover shellcode and strategies for recognizing
    and analyzing malicious shellcode.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍识别和分析恶意壳代码的策略。
- en: '**402**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**402**'
- en: Chapter 18
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第 18 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: Your goal for the labs in this chapter is simply to unpack the code for further
    analysis. For each lab, you should try to unpack the code so that other static
    analysis techniques can be used. While you may be able to find an automated unpacker
    that will work with some of these labs, automated unpackers won’t help you learn
    the skills you need when you encounter custom packers. Also, once you master unpacking,
    you may be able to manually unpack a file in less time than it takes to find,
    download, and use an automated unpacker.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 本章实验室的目标仅仅是解包代码以进行进一步分析。对于每个实验室，你应该尝试解包代码，以便可以使用其他静态分析技术。虽然你可能能够找到一些可以与这些实验室一起工作的自动化解包器，但自动化解包器不会帮助你学习当你遇到自定义打包器时所需的技能。此外，一旦你掌握了解包，你可能能够在比找到、下载和使用自动化解包器更短的时间内手动解包文件。
- en: Each lab is a packed version of a lab from a previous chapter. Your task in
    each case is to unpack the lab and identify the chapter in which it appeared.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实验室都是前一章实验室的打包版本。在这种情况下，你的任务是解包实验室并确定它出现在哪一章。
- en: The files are *Lab18-01.exe* through *Lab18-05.exe*.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 文件为*Lab18-01.exe*至*Lab18-05.exe*。
- en: Packers and Unpacking
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和反打包
- en: '**403**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**403**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**PART 6**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**第六部分**'
- en: '**S P E C I A L T O P I C S**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**S P E C I A L T O P I C S**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**S H E L L C O D E A N A L Y S I S**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**S H E L L C O D E A N A L Y S I S**'
- en: '*Shellcode* refers to a payload of raw executable code.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shellcode*指的是原始可执行代码的有效负载。'
- en: The name *shellcode* comes from the fact that attackers would usually use this
    code to obtain interactive shell
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 名称*shellcode*来源于攻击者通常会使用此代码来获取交互式shell的事实
- en: access on the compromised system. However, over
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在受损害系统上的访问。然而，超过
- en: time, the term has become commonly used to describe
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 时间，这个术语已经变得普遍用来描述
- en: any piece of self-contained executable code.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 任何自包含的可执行代码片段。
- en: Shellcode is often used alongside an exploit to subvert a running program, or
    by malware performing process injection. Exploitation and process injection are
    similar in that the shellcode is added to a running program and executed after
    the process has started.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode通常与漏洞利用一起使用，以颠覆正在运行的程序，或者由恶意软件执行进程注入。漏洞利用和进程注入在shellcode被添加到正在运行的程序并在进程启动后执行方面是相似的。
- en: 'Shellcode requires its authors to manually perform several actions that software
    developers usually never worry about. For example, the shellcode package cannot
    rely on actions the Windows loader performs during normal program startup, including
    the following:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode要求其作者手动执行软件开发者通常从不关心的几个动作。例如，shellcode包不能依赖于Windows加载器在正常程序启动期间执行的操作，包括以下操作：
- en: 
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Placing the program at its preferred memory location
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序放置在其首选内存位置
- en: 
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Applying address relocations if it cannot be loaded at its preferred memory
    location
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法在首选内存位置加载，则应用地址重定位
- en: 
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Loading required libraries and resolving external dependencies
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 加载所需的库和解决外部依赖
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This chapter will introduce you to these shellcode techniques, demonstrated
    by full, working real-world examples.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍这些shellcode技术，并通过完整的、实际应用的示例进行演示。
- en: '**Loading Shellcode for Analysis**'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '**加载Shellcode进行分析**'
- en: Loading and running shellcode in a debugger is problematic because shellcode
    is usually just a binary chunk of data that cannot run in the same way as a normal
    executable. To make things easier, we’ll use *shellcode_launcher.exe* (included
    with the labs available at *http://www.practicalmalwareanalysis.com/*) to load
    and jump to pieces of shellcode.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试器中加载和运行shellcode存在问题，因为shellcode通常只是一个无法像正常可执行文件那样运行的二进制数据块。为了使事情变得简单，我们将使用*shellcode_launcher.exe*（包含在*http://www.practicalmalwareanalysis.com/*提供的实验室中）来加载和跳转到shellcode的各个部分。
- en: 'As discussed in Chapter 5, loading shellcode into IDA Pro for static analysis
    is relatively simple, but the user must provide input during the load process,
    since there is no executable file format that describes the contents of shellcode.
    First, you must ensure the correct processor type is selected in the load process
    dialog. For samples in this chapter, you can use the **Intel 80x86 processors:
    metapc** processor type and select **32-bit disassembly** when prompted. IDA Pro
    loads the binary but performs no automatic analysis (analysis must be done manually).'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5章所述，将shellcode加载到IDA Pro进行静态分析相对简单，但用户必须在加载过程中提供输入，因为没有可执行文件格式可以描述shellcode的内容。首先，你必须确保在加载过程对话框中选择了正确的处理器类型。对于本章的示例，你可以使用**Intel
    80x86处理器：metapc**处理器类型，并在提示时选择**32位反汇编**。IDA Pro将加载二进制文件，但不会进行自动分析（分析必须手动完成）。
- en: '**Position-Independent Code**'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置无关代码**'
- en: '*Position-independent code (PIC)* is code that uses no hard-coded addresses
    for either code or data. Shellcode is PIC. It cannot assume that it will be located
    at a particular memory location when it executes, because at runtime, different
    versions of a vulnerable program may load the shellcode into different memory
    locations. The shellcode must ensure that all memory access for both code and
    data uses PIC techniques.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*位置无关代码（PIC）* 是不使用硬编码地址的代码或数据。Shellcode是PIC。它在执行时不能假设它将位于特定的内存位置，因为在运行时，不同版本的易受攻击程序可能将shellcode加载到不同的内存位置。Shellcode必须确保所有代码和数据访问都使用PIC技术。'
- en: Table 19-1 shows several common types of x86 code and data access, and whether
    they are PIC.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 表19-1显示了多种常见的x86代码和数据访问类型，以及它们是否是PIC。
- en: '**Table 19-1:** Different Types of x86 Code and Data Access **Instruction mnemonics**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-1:** 不同类型的x86代码和数据访问 **指令助记符**'
- en: '**Instruction bytes**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令字节**'
- en: '**Position-independent?**'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置无关？**'
- en: call sub_401000
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 调用子程序 sub_401000
- en: E8 C1 FF FF FF 
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: E8 C1 FF FF FF 
- en: 'Yes'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: jnz short loc_401044
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: jnz short loc_401044
- en: 75 0E 
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 75 0E 
- en: 'Yes'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: mov edx, dword_407030 
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, dword_407030 
- en: 8B 15 30 70 40 00
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 8B 15 30 70 40 00
- en: 'No'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: mov eax, [ebp-4] 
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp-4] 
- en: 8B 45 FC
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 8B 45 FC
- en: 'Yes'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: In the table, the call instruction contains a 32-bit signed relative displacement
    that is added to the address immediately following the call instruction in order
    to calculate the target location. Because the call instruction shown in the table
    is located at 0x0040103A, adding the offset value 0xFFFFFFC1 
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在表中，call指令包含一个32位的带符号相对位移量，该位移量加到call指令后的地址上，以计算目标位置。因为表中的call指令位于0x0040103A，所以加上偏移值0xFFFFFFC1
    
- en: to the location of the instruction, plus the size of the call instruction (5
    bytes), results in the call target 0x00401000\.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 到指令位置的地址，加上调用指令的大小（5字节），得到调用目标0x00401000。
- en: The jnz instruction is very similar to call, except that it uses only an 8-bit
    signed relative displacement. The jnz instruction is located at 0x00401034\.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: jnz指令与call指令非常相似，不同之处在于它只使用一个8位的带符号相对位移。jnz指令位于0x00401034。
- en: '**408**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**408**'
- en: Chapter 19
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 第19章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Adding together this location, the offset stored in the instruction (0xe) ,
    and the size of the instruction (2 bytes) results in the jump target 0x00401044\.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 将此位置、指令中存储的偏移量（0xe）和指令的大小（2字节）相加，得到跳转目标0x00401044。
- en: As you can see, control-flow instructions such as call and jump are already
    position-independent. They calculate target addresses by adding a relative offset
    stored in the instruction to the current location specified by the EIP
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，控制流指令如call和jump已经是位置无关的。它们通过将指令中存储的相对偏移量加到由EIP指定的当前位置来计算目标地址。
- en: register. (Certain forms of call and jump allow programmers to use absolute,
    or nonrelative, addressing that is not position-independent, but they are easily
    avoided.)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器。 (某些形式的call和jump允许程序员使用绝对或非相对的地址，这些地址不是位置无关的，但它们很容易避免。)
- en: The mov instruction at  shows an instruction accessing the global data variable
    dword_407030\. The last 4 bytes in this instruction show the memory location 0x00407030\.
    This particular instruction is not position-independent and must be avoided by
    shellcode authors.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的mov指令显示了访问全局数据变量dword_407030的指令。此指令中的最后4个字节显示了内存位置0x00407030。这个特定的指令不是位置无关的，shellcode作者必须避免它。
- en: 'Compare the mov instruction at  to the mov instruction at , which accesses
    a DWORD from the stack. This instruction uses the EBP register as a base, and
    contains a signed relative offset: 0xFC (-4). This type of data access is position-independent
    and is the model that shellcode authors must use for all data access: Calculate
    a runtime address and refer to data only by using offsets from this location.
    (The following section discusses finding an appropriate runtime address.)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 将指令 `mov` 在位置  与指令 `mov` 在位置  进行比较，后者从堆栈中访问一个 DWORD。此指令使用 EBP 寄存器作为基址，并包含一个有符号的相对偏移量：0xFC
    (-4)。这种数据访问是位置无关的，并且是壳代码作者必须用于所有数据访问的模型：计算运行时地址，并通过使用此位置的偏移量来引用数据。（以下章节讨论如何找到合适的运行时地址。）
- en: '**Identifying Execution Location**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别执行位置**'
- en: Shellcode needs to dereference a base pointer when accessing data in a position-independent
    manner. Adding or subtracting values to this base value will allow it to safely
    access data that is included with the shellcode.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码需要在位置无关的方式访问数据时对基指针进行解引用。向此基值添加或减去值将允许它安全地访问包含在壳代码中的数据。
- en: Because the x86 instruction set does not provide EIP-relative data access, as
    it does for control-flow instructions, a general-purpose register must first be
    loaded with the current instruction pointer, to be used as the base pointer.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86 指令集不提供与控制流指令相同的 EIP 相对数据访问，因此必须首先将当前指令指针加载到通用寄存器中，用作基指针。
- en: 'Obtaining the current instruction pointer may not be immediately obvious, because
    the instruction pointer on x86 systems cannot be directly accessed by software.
    In fact, there is no way to assemble the instruction mov eax, eip to directly
    load a general-purpose register with the current instruction pointer. However,
    shellcode uses two popular techniques to address this issue: call/pop and fnstenv
    instructions.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前指令指针可能并不立即明显，因为 x86 系统上的指令指针不能被软件直接访问。实际上，没有方法可以汇编指令 `mov eax, eip` 来直接将当前指令指针加载到通用寄存器中。然而，壳代码使用两种流行的技术来解决此问题：call/pop
    和 fnstenv 指令。
- en: '***Using call/pop***'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 call/pop***'
- en: When a call instruction is executed, the processor pushes the address of the
    instruction following the call onto the stack, and then branches to the requested
    location. This function executes, and when it completes, it executes a ret instruction
    to pop the return address off the top of the stack and load it into the instruction
    pointer. As a result, execution returns to the instruction just after the call.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 call 指令时，处理器将调用后指令的地址推入堆栈，然后转到请求的位置。此函数执行，当它完成时，它执行 ret 指令以从堆栈顶部弹出返回地址并将其加载到指令指针中。因此，执行返回到调用后的指令。
- en: Shellcode can abuse this convention by immediately executing a pop instruction
    after a call, which will load the address immediately following the call into
    the specified register. Listing 19-1 shows a simple Hello World example that uses
    this technique.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码可以通过在调用指令后立即执行 pop 指令来滥用此约定，这将立即将调用后的地址加载到指定的寄存器中。清单 19-1 展示了一个简单的 Hello
    World 示例，它使用了这种技术。
- en: Shellcode Analysis
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码分析
- en: '**409**'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '**409**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Bytes Disassembly
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 字节反汇编
- en: 83 EC 20 sub esp, 20h
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 83 EC 20 sub esp, 20h
- en: 31 D2 xor edx, edx
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 31 D2 xor edx, edx
- en: E8 0D 00 00 00 call sub_17 
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: E8 0D 00 00 00 call sub_17 
- en: 48 65 6C 6C 6F db 'Hello World!',0 
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 48 65 6C 6C 6F db 'Hello World!',0 
- en: 20 57 6F 72 6C
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 20 57 6F 72 6C
- en: 64 21 00
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 64 21 00
- en: 'sub_17:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'sub_17:'
- en: '5F pop edi  ; edi gets string pointer 52 push edx ; uType: MB_OK'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '5F pop edi  ; edi 获取字符串指针 52 push edx ; uType: MB_OK'
- en: 57 push edi ; lpCaption
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 57 push edi ; lpCaption
- en: 57 push edi ; lpText
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 57 push edi ; lpText
- en: '52 push edx ; hWnd: NULL'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '52 push edx ; hWnd: NULL'
- en: B8 EA 07 45 7E mov eax, 7E4507EAh ; MessageBoxA FF D0 call eax 
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: B8 EA 07 45 7E mov eax, 7E4507EAh ; MessageBoxA FF D0 call eax 
- en: 52 push edx ; uExitCode
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 52 push edx ; uExitCode
- en: B8 FA CA 81 7C mov eax, 7C81CAFAh ; ExitProcess FF D0 call eax 
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: B8 FA CA 81 7C mov eax, 7C81CAFAh ; ExitProcess FF D0 call eax 
- en: '*Listing 19-1: call/pop Hello World example*'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-1：call/pop Hello World 示例*'
- en: The call at  transfers control to sub_17 at . This is PIC because the call
    instruction uses an EIP relative value (0x0000000D) to calculate the call target.
    The pop instruction at  loads the address stored on top of the stack into EDI.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在  处的调用将控制权转移到  处的 sub_17。这是 PIC，因为调用指令使用 EIP 相对值（0x0000000D）来计算调用目标。在  处的
    pop 指令将存储在堆栈顶部的地址加载到 EDI 中。
- en: Remember that the EIP value saved by the call instruction points to the location
    immediately following the call, so after the pop instruction, EDI will contain
    a pointer to the db declaration at . This db declaration is assembly language
    syntax to create a sequence of bytes to spell out the string Hello World!. After
    the pop at , EDI will point to this Hello World! string.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，call 指令保存的 EIP 值指向 call 后立即的位置，所以 pop 指令之后，EDI 将包含指向 db 声明（）的指针。这个 db 声明是汇编语言语法，用于创建一个字节序列来拼写字符串
    Hello World！在  处的 pop 之后，EDI 将指向这个 Hello World！字符串。
- en: This method of intermingling code and data is normal for shellcode, but it can
    easily confuse disassemblers who try to interpret the data following the call
    instruction as code, resulting in either nonsensical disassembly or completely
    halting the disassembly process if invalid opcode combinations are encountered.
    As seen in Chapter 15, using call/pop pairs to obtain pointers to data may be
    incorporated into larger programs as an additional anti-reverse-engineering technique.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将代码和数据混合的方法对于 shellcode 来说是正常的，但它很容易使尝试将调用指令后的数据解释为代码的反汇编器感到困惑，这可能导致反汇编无意义或遇到无效操作码组合时完全停止反汇编过程。如第
    15 章所示，使用 call/pop 对对来获取数据指针可能被纳入更大的程序中作为额外的反逆向工程技术。
- en: The remaining code calls MessageBoxA  to show the “Hello World!” message, and
    then ExitProcess  to cleanly exit. This sample uses hard-coded locations for
    both function calls because imported functions in shellcode are not automatically
    resolved by the loader, but hard-coded locations make this code fragile. (These
    addresses come from a Windows XP SP3 box, and may differ from yours.)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的代码调用 MessageBoxA  来显示“Hello World！”消息，然后调用 ExitProcess  来干净地退出。此示例使用硬编码的位置来调用这两个函数，因为在
    shellcode 中的导入函数不会被加载器自动解析，而硬编码的位置使得此代码脆弱。（这些地址来自 Windows XP SP3 系统，可能与您的不同。）
- en: To find these function addresses with OllyDbg, open any process and press CTRL-G
    to bring up the Enter Expression to Follow dialog. Enter **MessageBoxA** in the
    dialog and press ENTER. The debugger should show the location of the function,
    as long as the library with this export ( *user32.dll* ) is loaded by the process
    being debugged.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 OllyDbg 查找这些函数地址，打开任何进程并按 CTRL-G 弹出“跟随表达式”对话框。在对话框中输入 **MessageBoxA** 并按回车。只要被调试的进程已加载包含此导出（*user32.dll*）的库，调试器应显示函数的位置。
- en: '**410**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**410**'
- en: Chapter 19
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'To load and step through this example with *shellcode_launcher.exe*, enter
    the following at the command line:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 *shellcode_launcher.exe* 加载并单步执行此示例，请在命令行中输入以下内容：
- en: '**shellcode_launcher.exe -i helloworld.bin -bp -L user32**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**shellcode_launcher.exe -i helloworld.bin -bp -L user32**'
- en: The -L user32 option is required because the shellcode does not call LoadLibraryA,
    so *shellcode_launcher.exe* must make sure this library is loaded.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: -L user32 选项是必需的，因为 shellcode 没有调用 LoadLibraryA，所以 *shellcode_launcher.exe*
    必须确保加载此库。
- en: The -bp option inserts a breakpoint instruction just prior to jumping to the
    shellcode binary specified with the -i option. Recall that debuggers can be registered
    for just-in-time debugging and can be launched automatically (or when prompted)
    when a program encounters a breakpoint. If a debugger such as OllyDbg has been
    registered as a just-in-time debugger, it will open and attach to the process
    that encountered a breakpoint. This allows you to skip over the contents of the
    *shellcode_launcher.exe* program and begin at the start of the shellcode binary.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: -bp 选项在跳转到由 -i 选项指定的 shellcode 二进制文件之前插入一个断点指令。回想一下，调试器可以注册为即时调试器，并在程序遇到断点时自动启动（或提示时启动）。如果
    OllyDbg 等调试器已注册为即时调试器，它将打开并附加到遇到断点的进程。这允许您跳过 *shellcode_launcher.exe* 程序的内容，并从
    shellcode 二进制文件的开头开始。
- en: You can set OllyDbg as your just-in-time debugger by selecting **Options**
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 OllyDbg 设置为即时调试器，通过选择**选项**
- en: '**Just-in-time Debugging****Make OllyDbg Just-in-time Debugger**.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**即时调试****将 OllyDbg 设置为即时调试器**。'
- en: '**NOTE**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Readers who wish to execute this example may need to modify the hard-coded
    function* *locations for MessageBoxA and ExitProcess. These addresses can be found
    as described* *in the text. Once the addresses have been found, you can patch*
    helloworld.bin *within* *OllyDbg by placing the cursor on the instruction that
    loads the hard-coded function* *location into register EAX and then pressing the
    spacebar. This brings up OllyDbg’s* *Assemble At dialog, which allows you to enter
    your own assembly code. This will be* *assembled by OllyDbg and overwrite the
    current instruction. Simply replace the* *7E4507EAh value with the correct value
    from your machine, and OllyDbg will patch* *the program in memory, allowing the
    shellcode to execute correctly.*'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '*希望执行此示例的读者可能需要修改MessageBoxA和ExitProcess的硬编码函数位置。这些地址可以在文本中找到的描述中找到* *。一旦找到地址，您可以在OllyDbg中通过将光标放在将硬编码函数位置加载到寄存器EAX的指令上并按空格键来修补helloworld.bin。这将打开OllyDbg的*
    *汇编对话框，允许您输入自己的汇编代码。这将由OllyDbg汇编并覆盖当前指令。只需将* *7E4507EAh值替换为您机器上的正确值，OllyDbg将修补*
    *内存中的程序，使shellcode能够正确执行。*'
- en: '***Using fnstenv***'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用fnstenv***'
- en: The x87 floating-point unit (FPU) provides a separate execution environment
    within the normal x86 architecture. It contains a separate set of special-purpose
    registers that need to be saved by the OS on a context switch when a process is
    performing floating-point arithmetic with the FPU. Listing 19-2
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: x87浮点单元（FPU）在正常的x86架构内提供了一个独立的执行环境。它包含一组需要由操作系统在进程执行浮点运算时进行上下文切换保存的特殊目的寄存器。清单19-2
- en: shows the 28-byte structure used by the fstenv and fnstenv instructions to store
    the state of the FPU to memory when executing in 32-bit protected mode.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了在32位保护模式下执行时，fstenv和fnstenv指令用于将FPU状态存储到内存中使用的28字节结构。
- en: struct FpuSaveState {
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: struct FpuSaveState {
- en: uint32_t control_word;
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t control_word;
- en: uint32_t status_word;
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t status_word;
- en: uint32_t tag_word;
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t tag_word;
- en: uint32_t fpu_instruction_pointer;
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t fpu_instruction_pointer;
- en: uint16_t fpu_instruction_selector;
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: uint16_t fpu_instruction_selector;
- en: uint16_t fpu_opcode;
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: uint16_t fpu_opcode;
- en: uint32_t fpu_operand_pointer;
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: uint32_t fpu_operand_pointer;
- en: uint16_t fpu_operand_selector;
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: uint16_t fpu_operand_selector;
- en: uint16_t reserved;
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: uint16_t reserved;
- en: '};'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '*Listing 19-2: FpuSaveState structure definition*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单19-2：FpuSaveState结构定义*'
- en: Shellcode Analysis
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode分析
- en: '**411**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**411**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The only field that matters for use here is fpu_instruction_pointer at byte
    offset 12\. This will contain the address of the last CPU instruction that used
    the FPU, providing context information for exception handlers to identify which
    FPU instructions may have caused a fault. This field is required because the FPU
    is running in parallel with the CPU. If the FPU
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用的唯一字段是字节偏移量为12的fpu_instruction_pointer。这将包含最后使用FPU的CPU指令的地址，为异常处理器提供上下文信息，以识别可能引起故障的FPU指令。这个字段是必需的，因为FPU与CPU并行运行。如果FPU
- en: generates an exception, the exception handler cannot simply look at the interrupt
    return address to identify the instruction that caused the fault.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 生成异常时，异常处理器不能简单地查看中断返回地址来识别导致故障的指令。
- en: Listing 19-3 shows the disassembly of another Hello World program that uses
    fnstenv to obtain the EIP value.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 清单19-3显示了另一个使用fnstenv获取EIP值的Hello World程序的汇编代码。
- en: Bytes Disassembly
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 字节 汇编
- en: 83 EC 20 sub esp, 20h
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 83 EC 20 sub esp, 20h
- en: 31 D2 xor edx, edx
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 31 D2 xor edx, edx
- en: EB 15 jmp short loc_1C
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: EB 15 jmp short loc_1C
- en: EA 07 45 7E dd 7E4507EAh ; MessageBoxA FA CA 81 7C dd 7C81CAFAh ; ExitProcess
    48 65 6C 6C 6F db 'Hello World!',0
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: EA 07 45 7E dd 7E4507EAh ; MessageBoxA FA CA 81 7C dd 7C81CAFAh ; ExitProcess
    48 65 6C 6C 6F db 'Hello World!',0
- en: 20 57 6F 72 6C
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 20 57 6F 72 6C
- en: 64 21 00
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 64 21 00
- en: 'loc_1C:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'loc_1C:'
- en: D9 EE fldz 
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: D9 EE fldz 
- en: D9 74 24 F4 fnstenv byte ptr [esp-0Ch] 
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: D9 74 24 F4 fnstenv byte ptr [esp-0Ch] 
- en: 5B pop ebx 
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 5B pop ebx 
- en: ; ebx points to fldz
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ; ebx 指向 fldz
- en: '8D 7B F3 lea edi, [ebx-0Dh]  ; load HelloWorld pointer 52 push edx ; uType:
    MB_OK'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '8D 7B F3 lea edi, [ebx-0Dh]  ; 加载 HelloWorld 指针 52 push edx ; uType: MB_OK'
- en: 57 push edi ; lpCaption
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 57 push edi ; lpCaption
- en: 57 push edi ; lpText
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 57 push edi ; lpText
- en: '52 push edx ; hWnd: NULL'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '52 push edx ; hWnd: NULL'
- en: 8B 43 EB mov eax, [ebx-15h]  ;
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 8B 43 EB mov eax, [ebx-15h]  ;
- en: load
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 加载
- en: MessageBoxA
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: MessageBoxA
- en: FF D0 call eax ; call MessageBoxA 52 push edx ; uExitCode
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: FF D0 call eax ; 调用 MessageBoxA 52 push edx ; uExitCode
- en: '8B 43 EF mov eax, [ebx-11h]  ; load ExitProcess FF D0 call eax ; call ExitProcess
    *Listing 19-3: fnstenv Hello World example*'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 8B 43 EF mov eax, [ebx-11h]  ; 加载 ExitProcess FF D0 call eax ; 调用 ExitProcess
    *清单19-3：fnstenv Hello World示例*
- en: The fldz instruction at  pushes the floating-point number 0.0 onto the FPU
    stack. The fpu_instruction_pointer value is updated within the FPU to point to
    the fldz instruction.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在处的fldz指令将浮点数0.0推送到FPU堆栈。fpu_instruction_pointer值在FPU内部更新，以指向fldz指令。
- en: Performing the fnstenv at  stores the FpuSaveState structure onto the stack
    at [esp-0ch], which allows the shellcode to do a pop at  that loads EBX with
    the fpu_instruction_pointer value. Once the pop executes, EBX will contain a value
    that points to the location of the fldz instruction in memory. The shellcode then
    starts using EBX as a base register to access the data embedded in the code.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在处执行fnstenv将FpuSaveState结构存储到[esp-0ch]的堆栈上，这允许shellcode在处执行pop，将EBX加载为fpu_instruction_pointer值。一旦pop执行，EBX将包含一个指向内存中fldz指令位置的值。然后shellcode开始使用EBX作为基址寄存器来访问代码中嵌入的数据。
- en: As in the previous Hello World example, which used the call/pop technique, this
    code calls MessageBoxA and ExitProcess using hard-coded locations, but here the
    function locations are stored as data along with the ASCII string to print. The
    lea instruction at  loads the address of the Hello **412**
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前使用call/pop技术的Hello World示例一样，此代码使用硬编码的位置调用MessageBoxA和ExitProcess，但在这里，函数位置与要打印的ASCII字符串一起作为数据存储。在处的lea指令加载Hello
    **412**的地址
- en: Chapter 19
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 第19章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: World! string by subtracting 0x0d from the address of the fldz instruction stored
    in EBX. The mov instruction at  loads the first function location for MessageBoxA,
    and the mov instruction at  loads the second function location for ExitProcess.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: World! 通过从EBX中存储的fldz指令的地址中减去0x0d来获取字符串。在处的mov指令加载MessageBoxA的第一个函数位置，而在处的mov指令加载ExitProcess的第二个函数位置。
- en: '**NOTE**'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Listing 19-3 is a contrived example, but it is common for shellcode to store
    or create* *function pointer arrays. We used the fldz instruction in this example,
    but any non-control FPU instruction can be used.*'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表19-3是一个虚构的例子，但shellcode存储或创建* *函数指针数组是常见的。我们在这个例子中使用了fldz指令，但任何非控制FPU指令都可以使用。*'
- en: 'This example can be executed using *shellcode_launcher.exe* with the following
    command:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以使用*shellcode_launcher.exe*通过以下命令执行：
- en: '**shellcode_launcher.exe -i hellofstenv.bin -bp -L user32**'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '**shellcode_launcher.exe -i hellofstenv.bin -bp -L user32**'
- en: '**Manual Symbol Resolution**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**手动符号解析**'
- en: Shellcode exists as a binary blob that gains execution. It must do something
    useful once it gains execution, which usually means interacting with the system
    through APIs.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode作为一个二进制blob存在，并获取执行权。一旦它获得执行权，它必须做一些有用的事情，这通常意味着通过API与系统交互。
- en: Remember that shellcode cannot use the Windows loader to ensure that all required
    libraries are loaded and available, and to make sure that all external symbols
    are resolved. Instead, it must find the symbols itself. The shellcode in the previous
    examples used hard-coded addresses to find the symbols, but this very fragile
    method will work only on a specific version of an OS and service pack. Shellcode
    must dynamically locate the functions in order to work reliably in different environments,
    and for that task, it typically uses LoadLibraryA and GetProcAddress.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，shellcode不能使用Windows加载器来确保所有必需的库都已加载并可用，并且要确保所有外部符号都已解析。相反，它必须自己找到符号。之前示例中的shellcode使用了硬编码的地址来查找符号，但这种方法非常脆弱，只能在特定版本的操作系统和服务包上工作。Shellcode必须动态定位函数，以便在不同的环境中可靠地工作，为此，它通常使用LoadLibraryA和GetProcAddress。
- en: LoadLibraryA loads the specified library and returns a handle. The GetProcAddress
    function searches the library’s exports for the given symbol name or ordinal number.
    If shellcode has access to these two functions, it can load any library on the
    system and find exported symbols, at which point it has full access to the API.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: LoadLibraryA加载指定的库并返回一个句柄。GetProcAddress函数在库的导出中搜索给定的符号名称或序号。如果shellcode可以访问这两个函数，它可以加载系统上的任何库并找到导出符号，此时它就可以完全访问API。
- en: 'Both functions are exported from *kernel32.dll*, so the shellcode must do the
    following:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都从*kernel32.dll*导出，因此shellcode必须执行以下操作：
- en: 
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Find *kernel32.dll* in memory.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存中查找*kernel32.dll*。
- en: 
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Parse *kernel32.dll*’s PE file and search the exported functions for LoadLibraryA
    and GetProcAddress.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 解析*kernel32.dll*的PE文件，并在导出函数中搜索LoadLibraryA和GetProcAddress。
- en: '***Finding kernel32.dll in Memory***'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '***在内存中查找kernel32.dll***'
- en: In order to locate *kernel32.dll*, we’ll follow a series of undocumented Windows
    structures. One of these structures contains the load address of *kernel32.dll*.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定位 *kernel32.dll*，我们将遵循一系列未记录的Windows结构。其中之一包含 *kernel32.dll* 的加载地址。
- en: Shellcode Analysis
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 分析
- en: '**413**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**413**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**NOTE**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Most of the Windows structures are listed on the Microsoft Developer Network
    (MSDN)* *site, but they are not fully documented. Many contain byte arrays named
    Reserved,* *with the warning “This structure may be altered in future versions
    of Windows.” For* *full listings of these structures, see* http://undocumented.ntinternals.net/
    *.*'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '*大多数Windows结构都在微软开发者网络（MSDN）* *网站上列出，但它们并未完全文档化。许多包含名为Reserved的* *字节数组，并带有警告“此结构可能在Windows的将来版本中更改。”关于这些结构的完整列表，请参阅*
    http://undocumented.ntinternals.net/ *.*'
- en: Figure 19-1 shows the data structures that are typically followed in order to
    find the base address for *kernel32.dll* (only relevant fields and offsets within
    each structure are shown).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-1显示了通常遵循以找到 *kernel32.dll* 基地址的数据结构（仅显示每个结构中的相关字段和偏移）。
- en: '**TEB**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**TEB**'
- en: '...'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0x30: PPEB peb;'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '0x30: PPEB peb;'
- en: '**PEB**'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEB**'
- en: '...'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0x0c: PPEB_LDR_data ldr;'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '0x0c: PPEB_LDR_data ldr;'
- en: '...'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**PEB_LDR_Data**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEB_LDR_Data**'
- en: '...'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0x0c: LIST_ENTRY InLoadOrderLinks;'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '0x0c: LIST_ENTRY InLoadOrderLinks;'
- en: '0x14: LIST_ENTRY InMemoryOrderLinks;'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '0x14: LIST_ENTRY InMemoryOrderLinks;'
- en: '0x1c: LIST_ENTRY InInitializationOrderLinks;'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '0x1c: LIST_ENTRY InInitializationOrderLinks;'
- en: '...'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '***ntdll.dll*** **LDR_DATA_TABLE_ENTRY**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '***ntdll.dll*** **LDR_DATA_TABLE_ENTRY**'
- en: '***kernel32.dll*** **LDR_DATA_TABLE_ENTRY**'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '***kernel32.dll*** **LDR_DATA_TABLE_ENTRY**'
- en: '0x00: LIST_ENTRY InLoadOrderLinks;'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '0x00: LIST_ENTRY InLoadOrderLinks;'
- en: '0x00: LIST_ENTRY InLoadOrderLinks;'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '0x00: LIST_ENTRY InLoadOrderLinks;'
- en: '0x08: LIST_ENTRY InMemoryOrderLinks;'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '0x08: LIST_ENTRY InMemoryOrderLinks;'
- en: '0x08: LIST_ENTRY InMemoryOrderLinks;'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '0x08: LIST_ENTRY InMemoryOrderLinks;'
- en: '0x10: LIST_ENTRY InInitializationOrderLinks;'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '0x10: LIST_ENTRY InInitializationOrderLinks;'
- en: '0x10: LIST_ENTRY InInitializationOrderLinks;'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '0x10: LIST_ENTRY InInitializationOrderLinks;'
- en: '...'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0x18: PVOID DllBase;'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '0x18: PVOID DllBase;'
- en: '...'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0x24: UNICODE_STRING FullDllName;'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '0x24: UNICODE_STRING FullDllName;'
- en: '*Figure 19-1: Structure traversal to find* kernel32.dll *DllBase* The process
    begins with the TEB, accessible from the FS segment register. Offset 0x30 within
    the TEB is the pointer to the PEB. Offset 0xc within the PEB is the pointer to
    the PEB_LDR_DATA structure, which contains three doubly linked lists of LDR_DATA_TABLE
    structures—one for each loaded module.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：结构遍历来查找* kernel32.dll *DllBase* 过程从可从FS段寄存器访问的TEB开始。TEB中的偏移0x30是PEB的指针。PEB中的偏移0xc是PEB_LDR_DATA结构的指针，它包含三个双向链接列表的
    LDR_DATA_TABLE 结构——每个加载的模块一个。'
- en: The DllBase field in the *kernel32.dll* entry is the value we’re seeking.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '*kernel32.dll* 条目中的 DllBase 字段是我们正在寻找的值。'
- en: Three LIST_ENTRY structures link the LDR_DATA_TABLE entries together in different
    orders, by name. The InInitializationOrderLinks entry is typically followed by
    shellcode. From Windows 2000 through Vista, *kernel32.dll* is the second DLL initialized,
    just after *ntdll.dll*, which means that the second entry in the InInitializationOrderLinks
    list of structures should belong to *kernel32.dll*. However, beginning with Windows
    7, *kernel32.dll* is no longer the second module to be initialized, so this simple
    algorithm no longer works. Portable shellcode will instead need to examine the
    UNICODE_STRING
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 LIST_ENTRY 结构通过名称以不同的顺序链接 LDR_DATA_TABLE 条目。InInitializationOrderLinks 条目通常后面跟着shellcode。从Windows
    2000到Vista，*kernel32.dll* 是第二个初始化的DLL，紧随 *ntdll.dll* 之后，这意味着结构列表中的第二个条目应属于 *kernel32.dll*。然而，从Windows
    7开始，*kernel32.dll* 已不再是第二个初始化的模块，因此这个简单的算法不再有效。可移植的shellcode将需要检查 UNICODE_STRING
- en: FullDllName field to confirm it is *kernel32.dll*.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: FullDllName 字段以确认它是 *kernel32.dll*。
- en: When traversing the LIST_ENTRY structures, it is important to realize that the
    Flink and Blink pointers point to the equivalent LIST_ENTRY in the next and previous
    LDR_DATA_TABLE structures. This means that when following the InInitializationOrderLinks
    to get to *kernel32.dll*’s LDR_DATA_TABLE_ENTRY, you need to add only eight to
    the pointer to get the DllBase, instead of adding 0x18, which you would have to
    do if the pointer pointed to the start of the structure.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历 LIST_ENTRY 结构时，重要的是要意识到 Flink 和 Blink 指针指向下一个和前一个 LDR_DATA_TABLE 结构中的等效
    LIST_ENTRY。这意味着在跟随 InInitializationOrderLinks 以到达 *kernel32.dll* 的 LDR_DATA_TABLE_ENTRY
    时，只需将指针增加八位即可获得 DllBase，而不是像指针指向结构开始时那样增加 0x18。
- en: '**414**'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**414**'
- en: Chapter 19
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 第19章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Listing 19-4 contains sample assembly code that finds the base address of *kernel32.dll.*
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19-4包含用于查找*kernel32.dll*基本地址的示例汇编代码。
- en: ; __stdcall DWORD findKernel32Base(void);
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ; __stdcall DWORD findKernel32Base(void);
- en: 'findKernel32Base:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 'findKernel32Base:'
- en: push esi
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: push esi
- en: xor eax, eax
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: mov eax, [fs:eax+0x30]  ; eax gets pointer to PEB
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [fs:eax+0x30]  ; eax获取PEB指针
- en: test eax, eax
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: test eax, eax
- en: '; if high bit set: Win9x'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: ;如果高位设置：Win9x
- en: js .kernel32_9x 
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: js .kernel32_9x 
- en: mov eax, [eax + 0x0c] 
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [eax + 0x0c] 
- en: ; eax gets pointer to PEB_LDR_DATA
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: ; eax获取PEB_LDR_DATA
- en: ;esi gets pointer to 1st
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: ;esi获取第一个
- en: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
- en: mov esi, [eax + 0x1c]
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: mov esi, [eax + 0x1c]
- en: ;eax gets pointer to 2nd
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: ;eax获取第二个
- en: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: ;LDR_DATA_TABLE_ENTRY.InInitializationOrderLinks.Flink
- en: lodsd 
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: lodsd 
- en: mov eax, [eax + 8]
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [eax + 8]
- en: ; eax gets LDR_DATA_TABLE_ENTRY.DllBase
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: ; eax获取LDR_DATA_TABLE_ENTRY.DllBase
- en: jmp near .finished
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: jmp near .finished
- en: '.kernel32_9x:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '.kernel32_9x:'
- en: jmp near .kernel32_9x 
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: jmp near .kernel32_9x 
- en: '; Win9x not supported: infinite loop'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: ; 不支持Win9x：无限循环
- en: '.finished:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '.finished:'
- en: pop esi
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: pop esi
- en: ret
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ret
- en: '*Listing 19-4: findKernel32Base implementation*'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表19-4：findKernel32Base实现*'
- en: The listing accesses the TEB using the FS segment register at  to get the pointer
    to the PEB. The js ( jump if signed) instruction at  is used to test whether
    the most significant bit of the PEB pointer is set, in order to differentiate
    between Win9x and WinNT systems. In WinNT (including Windows 2000, XP, and Vista),
    the most significant bit of the PEB pointer is typically never set, because high
    memory addresses are reserved for the OS.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 列表使用FS段寄存器在处访问TEB，以获取PEB的指针。在处的js（如果符号位设置则跳转）指令用于测试PEB指针的最高位是否设置，以区分Win9x和WinNT系统。在WinNT（包括Windows
    2000、XP和Vista）中，PEB指针的最高位通常永远不会设置，因为高内存地址是为操作系统保留的。
- en: Using the sign bit to identify the OS family fails on systems that use the /3GB
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号位来识别操作系统家族在使用/3GB
- en: boot option, which causes the user-level/kernel-level memory split to occur
    at 0xC0000000 instead of 0x8000000, but this is ignored for this simple example.
    This shellcode chose not to support Win9x, so it enters an infinite loop at 
    if Win9x is detected.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 引导选项，这会导致用户级/内核级内存分割在0xC0000000而不是0x8000000处发生，但在这个简单的示例中忽略这一点。此shellcode选择不支持Win9x，因此如果检测到Win9x，它将在处进入无限循环。
- en: The shellcode proceeds to PEB_LDR_DATA at . It assumes that it is running under
    Windows Vista or earlier, so it can simply retrieve the second LDR_DATA_TABLE_ENTRY
    in the InInitializationOrderLinks linked list at  and return its DllBase field.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode继续到PEB_LDR_DATA在处。它假设它在Windows Vista或更早的版本下运行，因此它可以简单地检索处的InInitializationOrderLinks链接列表中的第二个LDR_DATA_TABLE_ENTRY并返回其DllBase字段。
- en: '***Parsing PE Export Data***'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '***解析PE导出数据***'
- en: Once you find the base address for *kernel32.dll*, you must parse it to find
    exported symbols. As with finding the location of *kernel32.dll*, this process
    involves following several structures in memory.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 找到*kernel32.dll*的基本地址后，必须解析它以查找导出符号。与查找*kernel32.dll*的位置一样，此过程涉及在内存中跟随几个结构。
- en: Shellcode Analysis
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode分析
- en: '**415**'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '**415**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: PE files use relative virtual addresses (RVAs) when defining locations within
    a file. These addresses can be thought of as offsets within the PE
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: PE文件在定义文件内的位置时使用相对虚拟地址（RVAs）。这些地址可以被视为PE
- en: image in memory, so the PE image base address must be added to each RVA to turn
    it into a valid pointer.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 图像在内存中的偏移量，因此必须将PE图像基本地址添加到每个RVA中，才能将其转换为有效的指针。
- en: The export data is stored in IMAGE_EXPORT_DIRECTORY. An RVA to this is stored
    in the array of IMAGE_DATA_DIRECTORY structures at the end of the IMAGE_OPTIONAL_HEADER.
    The location of the IMAGE_DATA_DIRECTORY array depends on whether the PE file
    is for a 32-bit application or a 64-bit application.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 导出数据存储在IMAGE_EXPORT_DIRECTORY中。该RVA存储在IMAGE_OPTIONAL_HEADER末尾的IMAGE_DATA_DIRECTORY结构数组中。IMAGE_DATA_DIRECTORY数组的位置取决于PE文件是为32位应用程序还是64位应用程序。
- en: 'Typical shellcode assumes it is running on a 32-bit platform, so it knows at
    compile time that the correct offset from the PE signature to the directory array
    is as follows:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的shellcode假设它在32位平台上运行，因此在编译时知道从PE签名到目录数组的正确偏移量如下：
- en: sizeof(PE_Signature) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER)
    = 120 bytes The relevant fields in the IMAGE_EXPORT_DIRECTORY structure are shown
    in Figure 19-2\. AddressOfFunctions is an array of RVAs that points to the actual
    export functions. It is indexed by an export ordinal (an alternative way of finding
    an exported symbol).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: sizeof(PE_Signature) + sizeof(IMAGE_FILE_HEADER) + sizeof(IMAGE_OPTIONAL_HEADER)
    = 120 bytes 相关字段在 IMAGE_EXPORT_DIRECTORY 结构中如图 19-2 所示。AddressOfFunctions 是一个指向实际导出函数的
    RVA 数组。它通过导出序号（查找导出符号的另一种方式）进行索引。
- en: The shellcode needs to map the export name to the ordinal in order to use this
    array, and it does so using the AddressOfNames and AddressOfNameOrdinals arrays.
    These two arrays exist in parallel. They have the same number of entries, and
    equivalent indices into these arrays are directly related.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 需要将导出名称映射到序号才能使用此数组，它使用 AddressOfNames 和 AddressOfNameOrdinals 数组来完成此操作。这两个数组并行存在。它们具有相同数量的条目，并且这些数组中的等效索引直接相关。
- en: AddressOfNames is an array of 32-bit RVAs that point to the strings of symbol
    names. AddressOfNameOrdinals is an array of 16-bit ordinals. For a given index
    idx into these arrays, the symbol at AddressOfNames[idx] has the export ordinal
    value at AddressOfNameOrdinals[idx]. The AddressOfNames array is sorted alpha-betically
    so that a binary search can quickly find a specific string, though most shellcode
    simply performs a linear search starting at the beginning of the array.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: AddressOfNames 是一个指向符号名称字符串的 32 位 RVA 数组。AddressOfNameOrdinals 是一个 16 位序号数组。对于这些数组中的给定索引
    idx，AddressOfNames[idx] 中的符号在 AddressOfNameOrdinals[idx] 中具有导出序号值。AddressOfNames
    数组按字母顺序排序，以便快速通过二分搜索找到特定字符串，尽管大多数 shellcode 只是在数组开头进行线性搜索。
- en: 'To find the export address of a symbol, follow these steps: 1\.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到符号的导出地址，请按照以下步骤操作：1.
- en: Iterate over the AddressOfNames array looking at each char* entry, and perform
    a string comparison against the desired symbol until a match is found. Call this
    index into AddressOfNames iName.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 AddressOfNames 数组，查看每个 char* 条目，并与所需的符号进行字符串比较，直到找到匹配项。将此索引称为 AddressOfNames
    中的 iName。
- en: 2\.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Index into the AddressOfNameOrdinals array using iName. The value retrieved
    is the value iOrdinal.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 iName 索引 AddressOfNameOrdinals 数组。检索到的值是 iOrdinal。
- en: 3\.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Use iOrdinal to index into the AddressOfFunctions array. The value retrieved
    is the RVA of the exported symbol. Return this value to the requester.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 iOrdinal 来索引 AddressOfFunctions 数组。检索到的值是导出符号的 RVA。将此值返回给请求者。
- en: A sample implementation of this algorithm is shown later in the chapter as part
    of a full Hello World example.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将展示该算法的一个示例实现，作为完整 Hello World 示例的一部分。
- en: '**416**'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**416**'
- en: Chapter 19
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: ;BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie) mov edi,
    edi
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: ;BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie) mov edi,
    edi
- en: push ebp
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: '...'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ;ATOM __stdcall AddAtomA(LPCSTR lpString)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: ;ATOM __stdcall AddAtomA(LPCSTR lpString)
- en: mov edi, edi
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: mov edi, edi
- en: push ebp
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: '...'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ;ATOM __stdcall AddAtomW(LPCWSTR lpString)
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: ;ATOM __stdcall AddAtomW(LPCWSTR lpString)
- en: mov edi, edi
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: mov edi, edi
- en: push ebp
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: '...'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**IMAGE_EXPORT_DIRECTORY**'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**IMAGE_EXPORT_DIRECTORY**'
- en: '"ActivateActCtx"'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '"ActivateActCtx"'
- en: '"lstrln"'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '"lstrln"'
- en: '"AddAtomA"'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '"AddAtomA"'
- en: '"lstrlnA"'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '"lstrlnA"'
- en: '...'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '"AddAtomW"'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '"AddAtomW"'
- en: '"lstrlnW"'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '"lstrlnW"'
- en: '0x18: NumberOfNames'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '0x18: NumberOfNames'
- en: '0x1c: AddressOfFunctions'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '0x1c: AddressOfFunctions'
- en: '0x20: AddressOfNames'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '0x20: AddressOfNames'
- en: '0x24: AddressOfNameOrdinals'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '0x24: AddressOfNameOrdinals'
- en: '...'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '0'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '...'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 3b6
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 3b6
- en: 3b7
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 3b7
- en: 3b8
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 3b8
- en: '*Figure 19-2:* kernel32.dll *IMAGE_EXPORT_DIRECTORY*'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 19-2:* kernel32.dll *IMAGE_EXPORT_DIRECTORY*'
- en: Once the shellcode finds LoadLibraryA, it can load arbitrary libraries. The
    return value of LoadLibraryA is treated as a HANDLE in the Win32 API. Examining
    the HANDLE values shows that it is actually a 32-bit pointer to the dllBase of
    the library that was loaded, which means that the shellcode can skip using GetProcAddress
    and continue using its own PE parsing code with the dllBase pointers returned
    from LoadLibraryA (which is also beneficial when hashed names are used, as explained
    in the next section).
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 shellcode 找到 LoadLibraryA，它就可以加载任意库。LoadLibraryA 的返回值在 Win32 API 中被视为 HANDLE。检查
    HANDLE 值显示，它实际上是指向已加载库的 dllBase 的 32 位指针，这意味着 shellcode 可以跳过使用 GetProcAddress，并继续使用从
    LoadLibraryA 返回的 dllBase 指针（这在下一节中解释的哈希名称使用时也有益）。
- en: '***Using Hashed Exported Names***'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用哈希导出名称***'
- en: 'The algorithm just discussed has a weakness: It performs a strcmp against each
    export name until it finds the correct one. This requires that the full name of
    each API function the shellcode uses be included as an ASCII string.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 上面讨论的算法有一个弱点：它会对每个导出名称执行 strcmp 操作，直到找到正确的名称。这要求将 shellcode 所使用的每个 API 函数的完整名称作为
    ASCII 字符串包含在内。
- en: When the size of the shellcode is constrained, these strings could push the
    size of the shellcode over the limit.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 当 shellcode 的大小受到限制时，这些字符串可能会使 shellcode 的大小超过限制。
- en: Shellcode Analysis
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 分析
- en: '**417**'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '**417**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: A common way to address this problem is to calculate a hash of each symbol string
    and compare the result with a precomputed value stored in the shellcode. The hash
    function does not need to be sophisticated; it only needs to guarantee that within
    each DLL used by the shellcode, the hashes that the shellcode uses are unique.
    Hash collisions between symbols in different DLLs and between symbols the shellcode
    does not use are fine.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是对每个符号字符串计算一个哈希值，并将结果与存储在 shellcode 中的预计算值进行比较。哈希函数不需要很复杂；它只需要保证在
    shellcode 所使用的每个 DLL 中，shellcode 使用的哈希值是唯一的。不同 DLL 中的符号之间的哈希冲突以及 shellcode 未使用的符号之间的哈希冲突是可以接受的。
- en: The most common hash function is the 32-bit rotate-right-additive hash, as shown
    in Listing 19-5\.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的哈希函数是 32 位右旋加法哈希，如列表 19-5 所示。
- en: ; __stdcall DWORD hashString(char* symbol);
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: ; __stdcall DWORD hashString(char* symbol);
- en: 'hashString:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 'hashString:'
- en: push esi
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: push esi
- en: push edi
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: push edi
- en: mov esi, dword [esp+0x0c] ; load function argument in esi
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: mov esi, dword [esp+0x0c] ; 将函数参数加载到 esi
- en: '.calc_hash:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '.calc_hash:'
- en: xor edi, edi 
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: xor edi, edi 
- en: cld
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: cld
- en: '.hash_iter:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '.hash_iter:'
- en: xor eax, eax
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: lodsb 
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: lodsb 
- en: ; load next byte of input string
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: ; 加载输入字符串的下一个字节
- en: cmp al, ah
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: cmp al, ah
- en: je .hash_done ; check if at end of symbol ror edi, 0x0d 
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: je .hash_done ; 检查是否到达符号末尾 ror edi, 0x0d 
- en: ; rotate right 13 (0x0d)
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: ; 右旋 13 位 (0x0d)
- en: add edi, eax
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: add edi, eax
- en: jmp near .hash_iter
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: jmp near .hash_iter
- en: '.hash_done:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '.hash_done:'
- en: mov eax, edi
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, edi
- en: pop edi
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: pop edi
- en: pop esi
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: pop esi
- en: retn 4
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: retn 4
- en: '*Listing 19-5: hashString implementation*'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-5：hashString 实现*'
- en: This function calculates a 32-bit DWORD hash value of the string pointer argument.
    The EDI register is treated as the current hash value, and is initialized to zero
    at . Each byte of the input string is loaded via the lodsb instruction at .
    If the byte is not NULL, the current hash is rotated right by 13 (0x0d) at ,
    and the current byte is added into the hash. This hash is returned in EAX so that
    its caller can compare the result with the value compiled into the code.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算字符串指针参数的 32 位 DWORD 哈希值。EDI 寄存器被视为当前哈希值，并在  处初始化为零。通过 lodsb 指令在每个输入字符串的每个字节上加载。如果字节不是
    NULL，则当前哈希值通过  右旋 13 位 (0x0d)，并将当前字节添加到哈希中。此哈希值返回到 EAX，以便其调用者可以将结果与编译到代码中的值进行比较。
- en: '**NOTE**'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The particular algorithm in Listing 19-5 has become commonly used due to its
    inclusion in Metasploit, but variations that use different rotation amounts and
    hash sizes* *are sometimes seen.*'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-5 中的特定算法由于包含在 Metasploit 中而变得普遍使用，但有时也会看到使用不同旋转量和哈希大小的变体。*'
- en: '**A Full Hello World Example**'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个完整的 Hello World 示例**'
- en: Listing 19-6 shows a full implementation of the findSymbolByHash function that
    can be used to find exported symbols in loaded DLLs.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-6 显示了 findSymbolByHash 函数的完整实现，该函数可用于在加载的 DLL 中查找导出符号。
- en: '**418**'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '**418**'
- en: Chapter 19
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '; __stdcall DWORD findSymbolByHash(DWORD dllBase, DWORD symHash); findSymbolByHash:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '; __stdcall DWORD findSymbolByHash(DWORD dllBase, DWORD symHash); findSymbolByHash:'
- en: pushad
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: pushad
- en: 'mov ebp, [esp + 0x24] ; load 1st arg: dllBase'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, [esp + 0x24] ; 加载第一个参数：dllBase
- en: mov eax, [ebp + 0x3c] 
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: mov eax, [ebp + 0x3c] 
- en: ; get offset to PE signature
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: ; 获取 PE 签名偏移量
- en: '; load edx w/ DataDirectories array: assumes PE32'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: ; 加载包含 DataDirectories 数组的 edx：假设为 PE32 格式
- en: mov edx, [ebp + eax + 4+20+96] 
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: mov edx, [ebp + eax + 4+20+96] 
- en: add edx, ebp ; edx:= addr IMAGE_EXPORT_DIRECTORY
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: add edx, ebp ; edx:= addr IMAGE_EXPORT_DIRECTORY
- en: mov ecx, [edx + 0x18]  ; ecx:= NumberOfNames
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: mov ecx, [edx + 0x18]  ; ecx:= NumberOfNames
- en: mov ebx, [edx + 0x20] ; ebx:= RVA of AddressOfNames add ebx, ebp ; rva->va
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebx, [edx + 0x20] ; ebx:= RVA of AddressOfNames add ebx, ebp ; rva->va
- en: '.search_loop:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '.search_loop:'
- en: jecxz .error_done ; if at end of array, jmp to done dec ecx ; dec loop counter
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: jecxz .error_done ; 如果到达数组末尾，跳转到 done dec ecx ; 减少循环计数器
- en: ; esi:= next name, uses ecx*4 because each pointer is 4 bytes mov esi, [ebx+ecx*4]
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: ; esi:= 下一个名称，使用 ecx*4 因为每个指针是 4 个字节 mov esi, [ebx+ecx*4]
- en: add esi, ebp ; rva->va
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: add esi, ebp ; 将 rva 转换为 va
- en: push esi
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: push esi
- en: call hashString 
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: call hashString 
- en: ; hash the current string
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: ; 对当前字符串进行哈希处理
- en: '; check hash result against arg #2 on stack: symHash'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '; check hash result against arg #2 on stack: symHash'
- en: cmp eax, [esp + 0x28] 
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: cmp eax, [esp + 0x28] 
- en: jnz .search_loop
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: jnz .search_loop
- en: ; at this point we found the string in AddressOfNames
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: ; at this point we found the string in AddressOfNames
- en: mov ebx, [edx+0x24] ; ebx:= ordinal table rva add ebx, ebp ; rva->va
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebx, [edx+0x24] ; ebx:= ordinal table rva add ebx, ebp ; rva->va
- en: ; turn cx into ordinal from name index.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: ; turn cx into ordinal from name index.
- en: '; use ecx*2: each value is 2 bytes'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '; use ecx*2: each value is 2 bytes'
- en: mov cx, [ebx+ecx*2] 
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: mov cx, [ebx+ecx*2] 
- en: mov ebx, [edx+0x1c] ; ebx:= RVA of AddressOfFunctions add ebx, ebp ; rva->va
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebx, [edx+0x1c] ; ebx:= RVA of AddressOfFunctions add ebx, ebp ; rva->va
- en: '; eax:= Export function rva. Use ecx*4: each value is 4 bytes mov eax, [ebx+ecx*4]
    '
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '; eax:= Export function rva. Use ecx*4: each value is 4 bytes mov eax, [ebx+ecx*4]
    '
- en: add eax, ebp ; rva->va
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: add eax, ebp ; rva->va
- en: jmp near .done
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: jmp near .done
- en: '.error_done:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '.error_done:'
- en: xor eax, eax ; clear eax on error
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax ; clear eax on error
- en: '.done:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '.done:'
- en: mov [esp + 0x1c], eax 
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: mov [esp + 0x1c], eax 
- en: ; overwrite eax saved on stack
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: ; overwrite eax saved on stack
- en: popad
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: popad
- en: retn 8
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: retn 8
- en: '*Listing 19-6: findSymbolByHash implementation*'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-6: findSymbolByHash implementation*'
- en: The function takes as arguments a pointer to the base of the DLL and a 32-bit
    hash value that corresponds to the symbol to find. It returns the pointer to the
    requested function in register EAX. Remember that all addresses in a PE file are
    stored as RVAs, so code needs to continuously add the dllBase value (kept in register
    EBP in this example) to the RVAs retrieved from PE
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受 DLL 基地址的指针和一个与要查找的符号对应的 32 位哈希值作为参数。它将请求的函数的指针返回到寄存器 EAX。记住，PE 文件中的所有地址都存储为
    RVAs，因此代码需要持续地将 dllBase 值（在此示例中保存在寄存器 EBP 中）添加到从 PE 获取的 RVAs
- en: structures to create pointers it can actually use.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: structures to create pointers it can actually use.
- en: The code begins parsing the PE file at  to get the pointer to the PE
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: The code begins parsing the PE file at  to get the pointer to the PE
- en: signature. A pointer to IMAGE_EXPORT_DIRECTORY is created at  by adding the
    correct offset, assuming this is a 32-bit PE file. The code begins parsing the
    Shellcode Analysis
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: signature. A pointer to IMAGE_EXPORT_DIRECTORY is created at  by adding the
    correct offset, assuming this is a 32-bit PE file. The code begins parsing the
    Shellcode Analysis
- en: '**419**'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '**419**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: IMAGE_EXPORT_DIRECTORY structure at , loading the NumberOfNames value and the
    AddressOfNames pointer. Each string pointer in AddressOfNames is passed to the
    hashString function at , and the result of this calculation is compared against
    the value passed as the function argument at .
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: IMAGE_EXPORT_DIRECTORY structure at , loading the NumberOfNames value and the
    AddressOfNames pointer. Each string pointer in AddressOfNames is passed to the
    hashString function at , and the result of this calculation is compared against
    the value passed as the function argument at .
- en: Once the correct index into AddressOfNames is found, it is used as an index
    into the AddressOfNameOrdinals array at location  to obtain the corresponding
    ordinal value, which is used as an index into the AddressOfFunctions array at
    . This is the value the user wants, so it is written to the stack at , overwriting
    the EAX value saved by the pushad instruction so that this value is preserved
    by the following popad instruction.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到 AddressOfNames 中的正确索引，它就被用作 AddressOfNameOrdinals 数组在位置  的索引，以获取相应的序数值，该值被用作
    AddressOfFunctions 数组在  的索引。这是用户想要的价值，因此它被写入到  的堆栈中，覆盖了由 pushad 指令保存的 EAX 值，以便通过后续的
    popad 指令保留此值。
- en: Listing 19-7 shows a complete Hello World shellcode example that uses the previously
    defined findKernel32Base and findSymbolByHash functions, instead of relying on
    hard-coded API locations.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-7 展示了一个完整的 Hello World shellcode 示例，它使用先前定义的 findKernel32Base 和 findSymbolByHash
    函数，而不是依赖于硬编码的 API 位置。
- en: mov ebp, esp
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: sub esp, 24h
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: sub esp, 24h
- en: call sub_A0  ; call to real start of code db 'user32',0 
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: call sub_A0  ; call to real start of code db 'user32',0 
- en: db 'Hello World!!!!',0
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: db 'Hello World!!!!',0
- en: 'sub_A0:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 'sub_A0:'
- en: pop ebx ; ebx gets pointer to data
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: pop ebx ; ebx gets pointer to data
- en: call findKernel32Base 
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: call findKernel32Base 
- en: mov [ebp-4], eax ; store kernel32 base address push 0EC0E4E8Eh ; LoadLibraryA
    hash
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp-4], eax ; store kernel32 base address push 0EC0E4E8Eh ; LoadLibraryA
    hash
- en: push dword ptr [ebp-4]
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: push dword ptr [ebp-4]
- en: call findSymbolByHash 
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: call findSymbolByHash 
- en: mov [ebp-14h], eax ; store LoadLibraryA location lea eax, [ebx]  ; eax points
    to "user32"
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp-14h], eax ; store LoadLibraryA location lea eax, [ebx]  ; eax points
    to "user32"
- en: push eax
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: push eax
- en: call dword ptr [ebp-14h] ; LoadLibraryA
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: call dword ptr [ebp-14h] ; LoadLibraryA
- en: mov [ebp-8], eax ; store user32 base address
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp-8], eax ; store user32 base address
- en: push 0BC4DA2A8h  ; MessageBoxA hash
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: push 0BC4DA2A8h  ; MessageBoxA hash
- en: push dword ptr [ebp-8] ; user32 dll location
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: push dword ptr [ebp-8] ; user32 dll location
- en: call findSymbolByHash
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: call findSymbolByHash
- en: mov [ebp-0Ch], eax ; store MessageBoxA location push 73E2D87Eh ; ExitProcess
    hash
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp-0Ch], eax ; store MessageBoxA location push 73E2D87Eh ; ExitProcess
    hash
- en: push dword ptr [ebp-4] ; kernel32 dll location
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: push dword ptr [ebp-4] ; kernel32 dll 位置
- en: call findSymbolByHash
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: call findSymbolByHash
- en: mov [ebp-10h], eax ; store ExitProcess location xor eax, eax
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp-10h], eax ; 存储 ExitProcess 位置 xor eax, eax
- en: 'lea edi, [ebx+7] ; edi:= "Hello World!!!!" pointer push eax ; uType: MB_OK'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 'lea edi, [ebx+7] ; edi:= "Hello World!!!!" 指针 push eax ; uType: MB_OK'
- en: push edi ; lpCaption
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: push edi ; lpCaption
- en: push edi ; lpText
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: push edi ; lpText
- en: 'push eax ; hWnd: NULL'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 'push eax ; hWnd: NULL'
- en: call dword ptr [ebp-0Ch] ; call MessageBoxA
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: call dword ptr [ebp-0Ch] ; 调用 MessageBoxA
- en: xor eax, eax
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: xor eax, eax
- en: push eax ; uExitCode
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: push eax ; uExitCode
- en: call dword ptr [ebp-10h] ; call ExitProcess
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: call dword ptr [ebp-10h] ; 调用 ExitProcess
- en: '*Listing 19-7: Position-independent Hello World*'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-7：位置无关的 Hello World*'
- en: '**420**'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**420**'
- en: Chapter 19
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The code begins by using a call/pop at  to obtain a pointer to the data starting
    at . It then calls findKernel32Base at  to find *kernel32.dll* and calls findSymbolByHash
    at  to find the export in *kernel32.dll* with the hash 0xEC0E4E8E. This is the
    ror-13-additive hash of the string LoadLibraryA.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过一个 call/pop 在  处获取从  开始的数据的指针。然后它调用 findKernel32Base 在  处找到 *kernel32.dll*，并调用
    findSymbolByHash 在  处找到 *kernel32.dll* 中具有哈希值 0xEC0E4E8E 的导出。这是字符串 LoadLibraryA
    的 ror-13-加性哈希。
- en: When this function returns EAX, it will point to the actual memory location
    for LoadLibraryA.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个函数返回 EAX 时，它将指向 LoadLibraryA 的实际内存位置。
- en: The code loads a pointer to the "user32" string at  and calls the LoadLibraryA
    function. It then finds the exported function MessageBoxA at 
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 代码加载指向 "user32" 字符串的指针在 ，并调用 LoadLibraryA 函数。然后它找到导出函数 MessageBoxA 在 
- en: and calls it to display the “Hello World!!!!” message. Finally, it calls ExitProcess
    to cleanly exit.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 并调用它来显示“Hello World!!!!”消息。最后，它调用 ExitProcess 来干净地退出。
- en: '**NOTE**'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Using the shellcode’s PE parsing ability instead of GetProcAddress has the
    additional* *benefit of making reverse-engineering of the shellcode more difficult.
    The hash values* *hide the API calls used from casual inspection.*'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用 Shellcode 的 PE 解析能力而不是 GetProcAddress 有额外的优势，即使 Shellcode 的逆向工程更加困难。哈希值隐藏了从普通检查中使用的
    API 调用。*'
- en: '**Shellcode Encodings**'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shellcode 编码**'
- en: In order to execute, the shellcode binary must be located somewhere in the program’s
    address space when it is triggered. When paired with an exploit, this means that
    the shellcode must be present before the exploit occurs or be passed along with
    the exploit. For example, if the program is performing some basic filtering on
    input data, the shellcode must pass this filter, or it will not be in the vulnerable
    process’s memory space. This means that shellcode often must look like legitimate
    data in order to be accepted by a vulnerable program.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行，当触发时，Shellcode 二进制文件必须位于程序地址空间中的某个位置。当与漏洞利用结合使用时，这意味着 Shellcode 必须在漏洞利用发生之前存在，或者与漏洞利用一起传递。例如，如果程序正在对输入数据进行一些基本的过滤，Shellcode
    必须通过这个过滤器，否则它将不会在易受攻击进程的内存空间中。这意味着 Shellcode 通常必须看起来像合法数据，才能被易受攻击的程序接受。
- en: One example is a program that uses the unsafe string functions strcpy and strcat,
    both of which do not set a maximum length on the data they write. If a program
    reads or copies malicious data into a fixed-length buffer using either of these
    functions, the data can easily exceed the size of the buffer and lead to a buffer-overflow
    attack. These functions treat strings as an array of characters terminated by
    a NULL (0x00) byte. Shellcode that an attacker wants copied into this buffer must
    look like valid data, which means that it must not have any NULL bytes in the
    middle that would prematurely end the string-copy operation.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是使用不安全的字符串函数 strcpy 和 strcat 的程序，这两个函数都没有设置它们写入数据的最大长度。如果程序使用这些函数中的任何一个将恶意数据读取或复制到固定长度的缓冲区中，数据可以轻易超过缓冲区的大小，从而导致缓冲区溢出攻击。这些函数将字符串视为以
    NULL (0x00) 字节终止的字符数组。攻击者想要复制到这个缓冲区的 Shellcode 必须看起来像有效数据，这意味着它中间不能有任何 NULL 字节，否则会提前结束字符串复制操作。
- en: Listing 19-8 shows a small piece of disassembly of code used to access the registry,
    with seven NULL bytes in this selection alone. This code could typically not be
    used as-is in a shellcode payload.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19-8 显示了用于访问注册表的代码的少量反汇编代码，在这个选择中就有七个 NULL 字节。这段代码通常不能直接用作 Shellcode 有效负载。
- en: 57 push edi
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 57 push edi
- en: 50 push eax ; phkResult
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 50 push eax ; phkResult
- en: 6A 01 push 1 ; samDesired 8D 8B D0 13 **00 00** lea ecx, [ebx+13D0h]
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 6A 01 push 1 ; samDesired 8D 8B D0 13 **00 00** lea ecx, [ebx+13D0h]
- en: 6A **00** push 0 ; ulOptions 51 push ecx ; lpSubKey
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 6A **00** push 0 ; ulOptions 51 push ecx ; lpSubKey
- en: '68 02 **00 00** 80 push 80000002h ; hKey: HKEY_LOCAL_MACHINE'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '68 02 **00 00** 80 push 80000002h ; hKey: HKEY_LOCAL_MACHINE'
- en: 'FF 15 20 **00** 42 **00** call ds:RegOpenKeyExA *Listing 19-8: Typical code
    with highlighted NULL bytes* Shellcode Analysis'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: FF 15 20 **00** 42 **00** call ds:RegOpenKeyExA *清单19-8：带有突出显示的空字节典型代码* Shellcode分析
- en: '**421**'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**421**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'Programs may perform additional sanity checks on data that the shellcode must
    pass in order to succeed, such as the following:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可能对shellcode必须通过的数据执行额外的合理性检查，以便成功，例如以下内容：
- en: 
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: All bytes are printable (less than 0x80) ASCII bytes.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字节都是可打印的ASCII字节（小于0x80）。
- en: 
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: All bytes are alphanumeric ( *A* through *Z*, *a* through *z*, or 0 through
    9).
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字节都是字母数字的（*A*到*Z*，*a*到*z*，或0到9）。
- en: To overcome filtering limitations by the vulnerable program, nearly all shellcode
    encodes the main payload to pass the vulnerable program’s filter and inserts a
    decoder that turns the encoded payload into executable bytes.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服易受攻击程序过滤限制，几乎所有shellcode都将主要有效载荷进行编码以通过易受攻击程序的过滤器，并插入一个解码器，将编码的有效载荷转换为可执行的字节。
- en: Only the small decoder section must be written carefully so that its instruction
    bytes will pass the strict filter requirements; the rest of the payload can be
    encoded at compile time to also pass the filter. If the shellcode writes the decoded
    bytes back on top of the encoded bytes (as usual), the shellcode is self-modifying.
    When the decoding is complete, the decoder transfers control to the main payload
    to execute.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 只需小心编写小的解码器部分，以确保其指令字节可以通过严格的过滤器要求；其余的有效载荷可以在编译时进行编码，以通过过滤器。如果shellcode将解码的字节写回到编码的字节之上（如通常情况），则shellcode是自我修改的。解码完成后，解码器将控制权传递给主要有效载荷以执行。
- en: 'The following are common encoding techniques:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的编码技术：
- en: 
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: XOR all payload bytes with constant byte mask. Remember that for all values
    of the same size *a*, *b* that ( *a* XOR *b*) XOR *b* == *a*.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有有效载荷字节与常数字节掩码进行XOR运算。记住，对于相同大小的所有值*a*，*b*，(*a* XOR *b*) XOR *b* == *a*。
- en: 
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: Use an alphabetic transform where a single byte of payload is split into two
    4-bit nibbles and added to a printable ASCII character (such as *A* or *a*).
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字母变换，将有效载荷的单字节分成两个4位的半字节，并将其添加到可打印的ASCII字符（如*A*或*a*）中。
- en: Shellcode encodings have additional benefits for the attackers, in that they
    make analysis more difficult by hiding human-readable strings such as URLs or
    IP addresses. Also, they may help evade network IDSs.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode编码对攻击者有额外的优势，因为它们通过隐藏可读字符串（如URL或IP地址）使分析更加困难。此外，它们可能有助于绕过网络入侵检测系统。
- en: '**NOP Sleds**'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOP雪橇**'
- en: A *NOP sled* (also known as a *NOP slide*) is a long sequence of instructions
    preceding shellcode, as shown in Figure 19-3\. NOP sleds are not required to be
    present with shellcode, but they are often included as part of an exploit to increase
    the likelihood of the exploit succeeding. Shellcode authors can do this by creating
    a large NOP sled immediately preceding the shellcode. As long as execution is
    directed somewhere within the NOP sled, the shellcode will eventually run.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*NOP雪橇*（也称为*NOP滑块*）是位于shellcode之前的一长串指令，如图19-3所示。NOP雪橇不是shellcode必须存在的，但它们通常作为攻击的一部分被包含，以提高攻击成功的可能性。Shellcode作者可以通过在shellcode之前创建一个大的NOP雪橇来实现这一点。只要执行被引导到NOP雪橇的某个地方，shellcode最终会运行。
- en: Jump Location
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转位置
- en: NOP Sled
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: NOP雪橇
- en: Decoder
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器
- en: Encoded Payload
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 编码有效载荷
- en: '*Figure 19-3: NOP sled and shellcode layout*'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-3：NOP雪橇和shellcode布局*'
- en: Traditional NOP sleds are made up of long sequences of the NOP (0x90) instruction,
    but exploit authors can be creative in order to avoid detection.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的NOP雪橇由一长串的NOP（0x90）指令组成，但攻击者可以富有创意以避免检测。
- en: Other popular opcodes are in the 0x40 to 0x4f range. These opcodes are single-byte
    instructions that increment or decrement the general-purpose registers.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 其他流行的操作码位于0x40到0x4f范围内。这些操作码是单字节指令，用于增加或减少通用寄存器。
- en: '**422**'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '**422**'
- en: Chapter 19
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 第19章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: This opcode byte range also consists of only printable ASCII characters. This
    is often useful because the NOP sled executes before the decoder runs, so it must
    pass the same filtering requirements as the rest of the shellcode.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作码字节范围也只包含可打印的ASCII字符。这通常很有用，因为NOP雪橇在解码器运行之前执行，因此它必须通过与其他shellcode相同的过滤要求。
- en: '**Finding Shellcode**'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找Shellcode**'
- en: Shellcode can be found in a variety of sources, including network traffic, web
    pages, media files, and malware. Because it is not always possible to create an
    environment with the correct version of the vulnerable program that the exploit
    targets, the malware analyst must try to reverse-engineer shellcode using only
    static analysis.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode可以在各种来源中找到，包括网络流量、网页、媒体文件和恶意软件。由于不一定总是能够创建一个具有目标漏洞程序正确版本的测试环境，恶意软件分析师必须尝试仅使用静态分析来逆向工程shellcode。
- en: Malicious web pages typically use JavaScript to profile a user’s system and
    check for vulnerable versions of the browser and installed plug-ins.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意网页通常使用JavaScript来分析用户的系统，并检查浏览器和已安装插件的易受攻击版本。
- en: The JavaScript unescape is typically used to convert the encoded shellcode text
    into a binary package suitable for execution. Shellcode is often stored as an
    encoded text string included with the script that triggers the exploit.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的unescape通常用于将编码的shellcode文本转换为适合执行的二进制包。Shellcode通常以编码的文本字符串的形式存储在触发漏洞的脚本中。
- en: 'The encoding understood by unescape treats the text %u *XXYY* as an encoded
    big-endian Unicode character, where *XX* and *YY* are hex values. On little-endian
    machines (such as x86), the byte sequence *YY* *XX* will be the result after decoding.
    For example, consider this text string:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 未转义编码理解的文本将%u *XXYY*视为一个编码的大端Unicode字符，其中*XX*和*YY*是十六进制值。在小端机器（如x86）上，解码后的字节序列将是*YY*
    *XX*。例如，考虑以下文本字符串：
- en: '%u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '%u1122%u3344%u5566%u7788%u99aa%ubbcc%uddee'
- en: 'It will be decoded to the following binary byte sequence: 22 11 44 33 66 55
    88 77 aa 99 cc bb ee dd'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被解码为以下二进制字节序列：22 11 44 33 66 55 88 77 aa 99 cc bb ee dd
- en: A % symbol that is not immediately followed by the letter u is treated as a
    single encoded hex byte. For example, the text string %41%42%43%44 will be decoded
    to the binary byte sequence 41 42 43 44\.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 如果%符号后面不是紧跟字母u，则被视为一个单独的编码十六进制字节。例如，文本字符串%41%42%43%44将被解码为二进制字节序列41 42 43 44。
- en: '**NOTE**'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Both single- and double-byte encoded characters can be used within the same
    text string.*'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '*同一文本字符串中可以使用单字节和双字节编码的字符。*'
- en: '*This is a popular technique wherever JavaScript is used, including in PDF
    documents.*'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是一个在JavaScript使用的地方都很流行的技术，包括PDF文档中。*'
- en: Shellcode used within a malicious executable is usually easy to identify because
    the entire program will be written using shellcode techniques as obfuscation,
    or a shellcode payload will be stored within the malware and will be injected
    into another process.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 在恶意可执行文件中使用的shellcode通常很容易识别，因为整个程序将使用shellcode技术作为混淆，或者shellcode有效载荷将存储在恶意软件中，并将其注入到另一个进程中。
- en: 'The shellcode payload is usually found by looking for the typical process-injection
    API calls discussed in Chapter 12: VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.
    The buffer written into the other process probably contains shellcode if the malware
    launches a remote thread without applying relocation fix-ups or resolving external
    dependencies. This may be convenient for the malware writer, since shellcode can
    bootstrap itself and execute without help from the originating malware.'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过查找第12章中讨论的典型进程注入API调用来找到shellcode有效载荷：VirtualAllocEx、WriteProcessMemory和CreateRemoteThread。如果恶意软件在未应用重定位修复或解决外部依赖的情况下启动远程线程，写入另一个进程的缓冲区可能包含shellcode。这可能对恶意软件编写者来说很方便，因为shellcode可以自我引导并执行，而无需来自原始恶意软件的帮助。
- en: Sometimes shellcode is stored unencoded within a media file. Disassemblers such
    as IDA Pro can load arbitrary binary files, including those suspected of containing
    shellcode. However, even if IDA Pro loads the file, it may not analyze the shellcode,
    because it does not know which bytes are valid code.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，shellcode会以未编码的形式存储在媒体文件中。像IDA Pro这样的反汇编器可以加载任意二进制文件，包括那些疑似包含shellcode的文件。然而，即使IDA
    Pro加载了文件，它也可能不会分析shellcode，因为它不知道哪些字节是有效的代码。
- en: Shellcode Analysis
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode分析
- en: '**423**'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**423**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: Finding shellcode usually means searching for the initial decoder that is likely
    present at the start of the shellcode. Useful opcodes to search for are listed
    in Table 19-2\.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找shellcode通常意味着搜索可能存在于shellcode开头处的初始解码器。表19-2中列出了要搜索的有用操作码。
- en: '**Table 19-2:** Some Opcode Bytes to Search For'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '**表19-2：要搜索的一些操作码字节**'
- en: '**Instruction type**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令类型**'
- en: '**Common opcodes**'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见操作码**'
- en: Call
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 调用
- en: '0xe8'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '0xe8'
- en: Unconditional jumps
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件跳转
- en: 0xeb, 0xe9
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 0xeb, 0xe9
- en: Loops
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 循环
- en: 0xe0, 0xe1, 0xe2
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 0xe0, 0xe1, 0xe2
- en: Short conditional jumps
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 短条件跳转
- en: 0x70 through 0x7f
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 0x70通过0x7f
- en: Attempt to disassemble each instance of the opcodes listed in Table 19-2
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试反汇编表19-2中列出的每个操作码实例
- en: in the loaded file. Any valid code should be immediately obvious. Just remember
    that the payload is likely encoded, so only the decoder will be visible at first.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载的文件中。任何有效的代码都应该立即显而易见。只需记住，有效载荷很可能是编码的，所以最初只能看到解码器。
- en: If none of those searches work, there may still be embedded shellcode, because
    some file formats allow for encoded embedded data. For example, exploits targeting
    the CVE-2010-0188 critical vulnerability in Adobe Reader use malformed TIFF images,
    embedded within PDFs, stored as a Base64-encoded string, which may be zlib-compressed.
    When working with particular file formats, you will need to be familiar with that
    format and the kind of data it can contain in order to search for malicious content.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些搜索都不起作用，可能仍然存在嵌入的shellcode，因为某些文件格式允许嵌入编码的数据。例如，针对Adobe Reader中CVE-2010-0188关键漏洞的漏洞利用使用格式错误的TIFF图像，嵌入在PDF中，存储为Base64编码的字符串，可能被zlib压缩。在处理特定文件格式时，你需要熟悉该格式及其可以包含的数据类型，以便搜索恶意内容。
- en: '**Conclusion**'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: Shellcode authors must employ techniques to work around inherent limitations
    of the odd runtime environment in which shellcode executes. This includes identifying
    where in memory the shellcode is executing and manually resolving all of the shellcode’s
    external dependencies so that it can interact with the system. To save on space,
    these dependencies are usually obfuscated by using hash values instead of ASCII
    function names. It is also common for nearly the entire shellcode to be encoded
    so that it bypasses any data filtering by the targeted process. All of these techniques
    can easily frustrate beginning analysts, but the material in this chapter should
    help you recognize these common activities, so you can instead focus on understanding
    the main functionality of the shellcode.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode作者必须采用技术来克服shellcode在执行时固有的运行时环境的限制。这包括确定shellcode在内存中的执行位置，并手动解决shellcode的所有外部依赖，以便它可以与系统交互。为了节省空间，这些依赖通常通过使用哈希值而不是ASCII函数名来混淆。整个shellcode几乎全部编码也是常见的，以便绕过目标进程的数据过滤。所有这些技术都可能轻易地让初学者感到沮丧，但本章中的材料应该有助于你识别这些常见活动，这样你就可以专注于理解shellcode的主要功能。
- en: '**424**'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '**424**'
- en: Chapter 19
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 第19章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: In these labs, we’ll use what we’ve covered in Chapter 19 to analyze samples
    inspired by real shellcode. Because a debugger cannot easily load and run shellcode
    directly, we’ll use a utility called *shellcode_launcher.exe* to dynamically analyze
    shellcode binaries. You’ll find instructions on how to use this utility in Chapter
    19 and in the detailed analyses in Appendix C.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些实验室中，我们将使用第19章中介绍的内容来分析受真实shellcode启发的样本。由于调试器无法轻松加载和运行shellcode，我们将使用名为
    *shellcode_launcher.exe* 的实用程序来动态分析shellcode二进制文件。你可以在第19章和附录C中的详细分析中找到如何使用此实用程序的方法。
- en: '**Lab 19-1**'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 19-1**'
- en: Analyze the file *Lab19-01.bin* using *shellcode_launcher.exe*.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *shellcode_launcher.exe* 分析文件 *Lab19-01.bin*。
- en: '***Questions***'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: How is the shellcode encoded?
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode是如何编码的？
- en: 2\.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Which functions does the shellcode manually import?
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode手动导入了哪些函数？
- en: 3\.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: What network host does the shellcode communicate with?
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode与哪个网络主机通信？
- en: 4\.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: What filesystem residue does the shellcode leave?
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode留下了哪些文件系统残留？
- en: 5\.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: What does the shellcode do?
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode执行什么操作？
- en: '**Lab 19-2**'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 19-2**'
- en: The file *Lab19-02.exe* contains a piece of shellcode that will be injected
    into another process and run. Analyze this file.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *Lab19-02.exe* 包含一段将被注入另一个进程并运行的shellcode。分析此文件。
- en: '***Questions***'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 1\.
- en: What process is injected with the shellcode?
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个进程被注入了shellcode？
- en: 2\.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 2\.
- en: Where is the shellcode located?
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode位于何处？
- en: 3\.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 3\.
- en: How is the shellcode encoded?
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode是如何编码的？
- en: 4\.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 4\.
- en: Which functions does the shellcode manually import?
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode手动导入了哪些函数？
- en: 5\.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 5\.
- en: What network hosts does the shellcode communicate with?
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode与哪些网络主机通信？
- en: 6\.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 6\.
- en: What does the shellcode do?
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: shellcode执行什么操作？
- en: '**Lab 19-3**'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 19-3**'
- en: Analyze the file *Lab19-03.pdf*. If you get stuck and can’t find the shellcode,
    just skip that part of the lab and analyze file *Lab19-03_sc.bin* using
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 分析文件 *Lab19-03.pdf*。如果你遇到困难，找不到shellcode，就跳过实验室的这一部分，并使用以下方法分析文件 *Lab19-03_sc.bin*：
- en: '*shellcode_launcher.exe*.'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: '*shellcode_launcher.exe*。'
- en: Shellcode Analysis
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode分析
- en: '**425**'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '**425**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Questions***'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What exploit is used in this PDF?
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 PDF 中使用了哪种漏洞？
- en: 2\.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: How is the shellcode encoded?
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码是如何编码的？
- en: 3\.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: Which functions does the shellcode manually import?
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码手动导入了哪些函数？
- en: 4\.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What filesystem residue does the shellcode leave?
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码留下了哪些文件系统残留？
- en: 5\.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: What does the shellcode do?
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 壳代码执行了什么操作？
- en: '**426**'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: '**426**'
- en: Chapter 19
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 第 19 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**C + + A N A L Y S I S**'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '**C + + 分析**'
- en: Malware analysis is conducted without access to source
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析在没有访问源代码的情况下进行
- en: code, but the specific source language has a significant impact on the assembly.
    For example, C++ has several
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码的情况下，但具体的源语言对汇编有重大影响。例如，C++ 有几个
- en: features and constructs that do not exist in C, and
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言中不存在的特性和构造，以及
- en: these can complicate analysis of the resulting assembly.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能会使结果的汇编分析复杂化。
- en: Malicious programs written in C++ create challenges for the malware analyst
    that make it harder to determine the purpose of assembly code.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 用 C++ 编写的恶意程序给恶意软件分析师带来了挑战，使得确定汇编代码的目的变得更加困难。
- en: Understanding basic C++ features and how they appear in assembly language is
    critical to analyzing malware written in C++.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基本的 C++ 特性和它们在汇编语言中的表现对于分析用 C++ 编写的恶意软件至关重要。
- en: '**Object-Oriented Programming**'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**'
- en: Unlike C, C++ is an object-oriented programming language, following a programming
    model that uses objects that contain data as well as functions to manipulate the
    data. The functions in object-oriented programming are like functions in C programs,
    except that they are associated with a particular object or class of objects.
    Functions within a C++ class are often called *methods*
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 不同，C++ 是一种面向对象的编程语言，遵循使用包含数据和函数的对象的编程模型来操作数据。面向对象编程中的函数类似于 C 程序中的函数，只不过它们与特定的对象或对象类相关联。C++
    类中的函数通常被称为 *方法*
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: to draw a distinction. Although many features of object-oriented programming
    are irrelevant to malware analysis because they do not impact the assembly, a
    few can complicate analysis.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 来区分。尽管面向对象编程的许多特性与恶意软件分析无关，因为它们不会影响汇编，但其中一些可能会使分析复杂化。
- en: '**NOTE**'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn more about C++, consider reading* Thinking in C++ *by Bruce Eckel,
    available as a free download from* http://www.mindviewinc.com/ *.*'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多关于 C++ 的信息，请考虑阅读 Bruce Eckel 的 *Thinking in C++*，可在 *http://www.mindviewinc.com/*
    免费下载。*'
- en: In object-orientation, code is arranged in user-defined data types called *classes*.
    Classes are like structs, except that they store function information in addition
    to data. Classes are like a blueprint for creating an object—one that specifies
    the functions and data layout for an object in memory.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象中，代码按用户定义的数据类型（称为 *类*）排列。类类似于结构体，除了它们存储函数信息以及数据。类是创建对象的蓝图——它指定了对象在内存中的函数和数据布局。
- en: When executing object-oriented C++ code, you use the class to create an object
    of the class. This object is referred to as an *instance* of the class. You can
    have multiple instances of the same class. Each instance of a class has its own
    data, but all objects of the same type share the same functions. To access data
    or call a function, you must reference an object of that type.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行面向对象的 C++ 代码时，您使用类来创建类的对象。这个对象被称为类的 *实例*。您可以拥有同一类的多个实例。每个类的实例都有自己的数据，但同一类型的所有对象共享相同的函数。要访问数据或调用函数，您必须引用该类型的对象。
- en: Listing 20-1 shows a simple C++ program with a class and a single object.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-1 显示了一个包含类和单个对象的简单 C++ 程序。
- en: class SimpleClass {
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: class SimpleClass {
- en: 'public:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: int x;
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: void HelloWorld() {
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: void HelloWorld() {
- en: printf("Hello World\n");
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: printf("Hello World\n");
- en: '}'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: int _tmain(int argc, _TCHAR* argv[])
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: int _tmain(int argc, _TCHAR* argv[])
- en: '{'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: SimpleClass myObject;
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleClass myObject;
- en: myObject.HelloWorld();
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: myObject.HelloWorld();
- en: '}'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 20-1: A simple C++ class*'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-1：一个简单的 C++ 类*'
- en: In this example, the class is called SimpleClass. It has one data element, x,
    and a single function, HelloWorld. We create an instance of SimpleClass named
    myObject and call the HelloWorld function for that object. (The public keyword
    is a compiler-enforced abstraction mechanism with no impact on the assembly code.)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类被称为 SimpleClass。它有一个数据元素 x 和一个单独的函数 HelloWorld。我们创建了一个名为 myObject 的
    SimpleClass 实例，并调用了该对象的 HelloWorld 函数。（公共关键字是一个编译器强制执行的抽象机制，对汇编代码没有影响。）
- en: '***The this Pointer***'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '***this指针***'
- en: As we have established, data and functions are associated with objects. In order
    to access a piece of data, you use the form *ObjectName.variableName*.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经建立的，数据和函数与对象相关联。为了访问一块数据，你使用*对象名.变量名*的形式。
- en: Functions are called similarly with *ObjectName.functionName*. For example,
    in Listing 20-1, if we wanted to access the x variable, we would use myObject.x.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用方式与*对象名.函数名*类似。例如，在列表20-1中，如果我们想访问x变量，我们会使用myObject.x。
- en: '**428**'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '**428**'
- en: Chapter 20
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 第20章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: In addition to accessing variables using the object name and the variable name,
    you can also access variables for the current object using only the variable name.
    Listing 20-2 shows an example.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用对象名和变量名来访问变量外，你还可以仅使用变量名来访问当前对象的变量。列表20-2展示了示例。
- en: class SimpleClass {
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: class SimpleClass {
- en: 'public:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: int x;
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: int x;
- en: void HelloWorld() {
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: void HelloWorld() {
- en: if (x == 10) printf("X is 10.\n");
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: if (x == 10) printf("X is 10.\n");
- en: '}'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '};'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: int _tmain(int argc, _TCHAR* argv[])
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: int _tmain(int argc, _TCHAR* argv[])
- en: '{'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: SimpleClass myObject;
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleClass myObject;
- en: myObject.x = 9;
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: myObject.x = 9;
- en: myObject.HelloWorld();
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: myObject.HelloWorld();
- en: SimpleClass myOtherObject;
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleClass myOtherObject;
- en: myOtherOject.x = 10;
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: myOtherOject.x = 10;
- en: myOtherObject.HelloWorld();
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: myOtherObject.HelloWorld();
- en: '}'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 20-2: A C++ example with the this pointer*'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表20-2：带有this指针的C++示例*'
- en: In the HelloWorld function, the variable x is accessed as just x at , and not
    *ObjectName*.x. That same variable, which refers to the same address in memory,
    is accessed in the main method at  using myObject.x.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在HelloWorld函数中，变量x作为处的x直接访问，而不是*对象名*.x。相同的变量，它指向相同的内存地址，在主方法中通过myObject.x在处访问。
- en: Within the HelloWorld method, the variable can be accessed just as x because
    it is assumed to refer to the object that was used to call the function, which
    in the first case is myObject . Depending on which object is used to call the
    HelloWorld function, a different memory address storing the x variable will be
    accessed. For example, if the function were called with myOtherObject.HelloWorld,
    then an x reference at  would access a different memory location than when that
    is called with myObject.HelloWorld. The this pointer is used to keep track of
    which memory address to access when accessing the x variable.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 在HelloWorld方法中，变量可以像x一样访问，因为它假定它指的是调用函数所使用的对象，在第一种情况下是myObject 。根据哪个对象被用来调用HelloWorld函数，将访问不同的存储x变量的内存地址。例如，如果函数是用myOtherObject.HelloWorld调用的，那么在处的x引用将访问与用myObject.HelloWorld调用时不同的内存位置。this指针用于跟踪访问x变量时要访问的内存地址。
- en: The this pointer is implied in every variable access within a function that
    doesn’t specify an object; it is an implied parameter to every object function
    call. Within Microsoft-generated assembly code, the this parameter is usually
    passed in the ECX register, although sometimes ESI is used instead.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，每当没有指定对象时，this指针都是隐含的；它是每个对象函数调用的隐含参数。在Microsoft生成的汇编代码中，this参数通常在ECX寄存器中传递，尽管有时也使用ESI。
- en: In Chapter 6, we covered the stdcall, cdecl, and fastcall calling conventions.
    The C++ calling convention for the this pointer is often called *thiscall*.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章，我们介绍了stdcall、cdecl和fastcall调用约定。C++中this指针的调用约定通常称为*thiscall*。
- en: Identifying the thiscall convention can be one easy way to identify object-oriented
    code when looking at disassembly.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 通过识别thiscall约定，可以是一个识别反汇编时面向对象代码的简单方法。
- en: C++ Analysis
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: C++分析
- en: '**429**'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '**429**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The assembly in Listing 20-3, generated from Listing 20-2, demonstrates the
    usage of the this pointer.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 列表20-3中的汇编代码，由列表20-2生成，展示了this指针的使用。
- en: ;Main Function
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: ;主函数
- en: 00401100 push ebp
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 00401100 push ebp
- en: 00401101 mov ebp, esp
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 00401101 mov ebp, esp
- en: 00401103 sub esp, 1F0h
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 00401103 sub esp, 1F0h
- en: 00401109
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 00401109
- en: mov [ebp+var_10], offset off_404768
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp+var_10], offset off_404768
- en: '00401110'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '00401110'
- en: mov [ebp+var_C], 9
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: mov [ebp+var_C], 9
- en: '00401117'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '00401117'
- en: lea ecx, [ebp+var_10]
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: lea ecx, [ebp+var_10]
- en: 0040111A call sub_4115D0
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111A call sub_4115D0
- en: 0040111F mov [ebp+var_34], offset off_404768
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 0040111F mov [ebp+var_34], offset off_404768
- en: 00401126 mov [ebp+var_30], 0Ah
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 00401126 mov [ebp+var_30], 0Ah
- en: 0040112D
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 0040112D
- en: lea ecx, [ebp+var_34]
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: lea ecx, [ebp+var_34]
- en: 00401130 call sub_4115D0
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 00401130 call sub_4115D0
- en: ;HelloWorld Function
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: ;HelloWorld函数
- en: 004115D0 push ebp
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 004115D0 push ebp
- en: 004115D1 mov ebp, esp
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 004115D1 mov ebp, esp
- en: 004115D3 sub esp, 9Ch
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 004115D3 sub esp, 9Ch
- en: 004115D9 push ebx
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 004115D9 push ebx
- en: 004115DA push esi
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 004115DA push esi
- en: 004115DB push edi
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 004115DB push edi
- en: 004115DC mov [ebp+var_4], ecx
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 004115DC mov [ebp+var_4], ecx
- en: 004115DF mov eax, [ebp+var_4]
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 004115DF mov eax, [ebp+var_4]
- en: 004115E2 cmp dword ptr [eax+4], 0Ah
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 004115E2 cmp dword ptr [eax+4], 0Ah
- en: 004115E6 jnz short loc_4115F6
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 004115E6 jnz short loc_4115F6
- en: 004115E8 push offset aXIs10_ ; "X is 10.\n"
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 004115E8 push offset aXIs10_ ; "X is 10.\n"
- en: 004115ED call ds:__imp__printf
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 004115ED call ds:__imp__printf
- en: '*Listing 20-3: The this pointer shown in disassembly*'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 20-3：反汇编中显示的 this 指针*'
- en: The main method first allocates space on the stack. The beginning of the object
    is stored at var_10 on the stack at . The first data value stored in that object
    is the variable x, which is set at an offset of 4 from the beginning of the object.
    The value x is accessed at  and is labeled var_C by IDA Pro.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法首先在堆栈上分配空间。对象的开始存储在堆栈上的 var_10。在该对象中存储的第一个数据值是变量 x，它设置在对象开始的偏移量为 4。值 x 在
     处访问，并被 IDA Pro 标记为 var_C。
- en: IDA Pro can’t determine whether the values are both part of the same object,
    and it labels x as a separate value. The pointer to the object is then placed
    into ECX for the function call . Within the HelloWorld function, the value of
    ECX is retrieved and used as the this pointer . Then at an offset of 4, the code
    accesses the value for x . When the main function calls HelloWorld for the second
    time, it loads a different pointer into ECX.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: IDA Pro 无法确定这些值是否都是同一对象的组成部分，并将 x 标记为单独的值。然后，将对象指针放入 ECX 以进行函数调用 。在 HelloWorld
    函数中，检索 ECX 的值并将其用作 this 指针 。然后在偏移量为 4 的位置，代码访问 x 的值 。当主函数第二次调用 HelloWorld 时，它将不同的指针加载到
    ECX 中。
- en: '***Overloading and Mangling***'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '***重载和混淆***'
- en: C++ supports a coding construct known as *method overloading*, which is the
    ability to have multiple functions with the same name, but that accept different
    parameters. When the function is called, the compiler determines which version
    of the function to use based on the number and types of parameters used in the
    call, as shown in Listing 20-4\.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 支持一种称为 *方法重载* 的编码结构，即具有相同名称但接受不同参数的多个函数的能力。当调用函数时，编译器根据调用中使用的参数的数量和类型确定要使用的函数版本，如图
    20-4 所示。
- en: '**430**'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '**430**'
- en: Chapter 20
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: Chapter 20
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 90](index-464_1.png)'
  id: totrans-1100
  prefs: []
  type: TYPE_IMG
  zh: '![Image 90](index-464_1.png)'
- en: LoadFile (String filename) {
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: LoadFile (String filename) {
- en: '...'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: LoadFile (String filename, int Options) {
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: LoadFile (String filename, int Options) {
- en: '...'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Main () {
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: Main () {
- en: LoadFile ("c:\myfile.txt"); //Calls the first LoadFile function LoadFile ("c:\myfile.txt",
    GENERIC_READ); //Calls the second LoadFile
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: LoadFile ("c:\\myfile.txt"); // 调用第一个 LoadFile 函数 LoadFile ("c:\\myfile.txt",
    GENERIC_READ); // 调用第二个 LoadFile
- en: '}'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '*Listing 20-4: Function overloading example*'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 20-4：函数重载示例*'
- en: 'As you can see in the listing, there are two LoadFile functions: one that takes
    only a string and another that takes a string and an integer. When the LoadFile
    function is called within the main method, the compiler selects the function to
    call based on the number of parameters supplied.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表所示，存在两个 LoadFile 函数：一个只接受字符串，另一个接受字符串和整数。当在主方法中调用 LoadFile 函数时，编译器根据提供的参数数量选择要调用的函数。
- en: C++ uses a technique called *name mangling* to support method overloading. In
    the PE file format, each function is labeled with only its name, and the function
    parameters are not specified in the compiled binary format.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 使用一种称为 *名称混淆* 的技术来支持方法重载。在 PE 文件格式中，每个函数只标记其名称，函数参数不在编译的二进制格式中指定。
- en: To support overloading, the names in the file format are modified so that the
    name information includes the parameter information. For example, if a function
    called TestFunction is part of the SimpleClass class and accepts two integers
    as parameters, the mangled name of that function would be
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持重载，文件格式中的名称被修改，以便名称信息包括参数信息。例如，如果名为 TestFunction 的函数是 SimpleClass 类的一部分，并接受两个整数作为参数，则该函数的混淆名称将是
- en: ?TestFunction@SimpleClass@@QAEXHH@Z.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: ?TestFunction@SimpleClass@@QAEXHH@Z.
- en: The algorithm for mangling the names is compiler-specific, but IDA Pro can demangle
    the names for most compilers. For example, Figure 20-1 shows the function TestFunction.
    IDA Pro demangles the function and shows the original name and parameters.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆名称的算法是编译器特定的，但 IDA Pro 可以对大多数编译器进行去混淆。例如，图 20-1 显示了 TestFunction 函数。IDA Pro
    对函数进行去混淆并显示原始名称和参数。
- en: '*Figure 20-1: IDA Pro listing of a demangled function name* The internal function
    names are visible only if there are symbols in the code you are analyzing. Malware
    usually has the internal symbols removed; however, some imported or exported C++
    functions with mangled names may be visible in IDA Pro.'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-1：IDA Pro 中去混淆的函数名称列表* 内部函数名称仅在分析代码中有符号时可见。恶意软件通常移除了内部符号；然而，一些具有混淆名称的导入或导出
    C++ 函数可能在 IDA Pro 中可见。'
- en: C++ Analysis
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析
- en: '**431**'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**431**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Inheritance and Function Overriding***'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '***继承与函数覆盖***'
- en: '*Inheritance* is an object-oriented programming concept in which parent-child
    relationships are established between classes. Child classes inherit functions
    and data from parent classes. A child class automatically has all the functions
    and data of the parent class, and usually defines additional functions and data.
    For example, Listing 20-5 shows a class called Socket.'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承* 是一种面向对象编程概念，其中在类之间建立父-子关系。子类从父类继承函数和数据。子类自动拥有父类的所有函数和数据，并且通常定义额外的函数和数据。例如，列表
    20-5 显示了一个名为 Socket 的类。'
- en: class Socket {
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: class Socket {
- en: '...'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'public:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void setDestinationAddr (INetAddr * addr) {
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: void setDestinationAddr (INetAddr * addr) {
- en: '...'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '};'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'class UDPSocket : publicSocket {'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 'class UDPSocket : public Socket {'
- en: 'public:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void sendData (char * buf, INetAddr * addr) {
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: void sendData (char * buf, INetAddr * addr) {
- en:  setDestinationAddr(addr)
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh:  setDestinationAddr(addr)
- en: '...'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '...'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '};'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '*Listing 20-5: Inheritance example*'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-5：继承示例*'
- en: The Socket class has a function to set the destination address, but it has no
    function to sendData because it’s not a specific type of socket. A child class
    called UDPSocket can send data and implements the sendData function at , and
    it can also call the setDestinationAddr function defined in the Socket class.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: Socket 类有一个设置目标地址的函数，但没有 sendData 函数，因为它不是特定类型的套接字。一个名为 UDPSocket 的子类可以发送数据并实现了处的
    sendData 函数，它也可以调用在 Socket 类中定义的 setDestinationAddr 函数。
- en: In Listing 20-5, the sendData function at  can call the setDestinationAddr
    function at  even though that function is not defined in the UDPSocket class,
    because the functionality of the parent class is automatically included in the
    child class.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 20-5 中，sendData 函数在处可以调用 setDestinationAddr 函数在处，即使该函数在 UDPSocket 类中没有定义，因为父类的功能会自动包含在子类中。
- en: Inheritance helps programmers more efficiently reuse code, but it’s a feature
    that does not require any runtime data structures and generally isn’t visible
    in assembly code.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 继承帮助程序员更有效地重用代码，但它是一个不需要任何运行时数据结构的特性，并且在汇编代码中通常不可见。
- en: '**Virtual vs. Nonvirtual Functions**'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚函数与非虚函数**'
- en: A *virtual function* is one that can be overridden by a subclass and whose execution
    is determined at *runtime*. If a function is defined within a parent class and
    a function with the same name is defined in a child class, the child class’s function
    overrides the parent’s function.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚函数* 是可以被子类覆盖的函数，其执行是在 *运行时* 决定的。如果一个函数在父类中定义，而在子类中定义了具有相同名称的函数，则子类的函数将覆盖父类的函数。'
- en: Several popular programming models use this functionality in order to greatly
    simplify complex programming tasks. To illustrate why this is useful, return to
    the socket example in Listing 20-5\. There, we have code that is going to sendData
    over the network, and we want it to be able to send data via TCP and UDP. One
    easy way to accomplish this is to create a parent class **432**
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 几种流行的编程模型使用此功能来极大地简化复杂的编程任务。为了说明这为什么有用，回到列表 20-5 中的套接字示例。在那里，我们有将要通过网络发送 sendData
    的代码，我们希望它能够通过 TCP 和 UDP 发送数据。实现这一目标的一种简单方法是通过创建一个父类 **432**
- en: Chapter 20
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 第 20 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: called Socket with a virtual function called sendData. Then we have two chil-dren
    classes called UDPSocket and TCPSocket, which override the sendData function to
    send the data over the appropriate protocol.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用了具有 sendData 虚函数的 Socket。然后我们有两个子类，分别是 UDPSocket 和 TCPSocket，它们覆盖了 sendData
    函数以通过适当的协议发送数据。
- en: In the code that uses the socket, we create an object of type Socket, and create
    whichever socket we are using in this instance. Each time we call the sendData
    function, the sendData function will be called from the proper subclass of Socket,
    whether UDPSocket or TCPSocket, based on which type of Socket object was originally
    created.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用套接字的代码中，我们创建一个Socket类型的对象，并创建在这个实例中使用的套接字。每次调用sendData函数时，sendData函数将根据最初创建的Socket对象类型从Socket的适当子类中调用，无论是UDPSocket还是TCPSocket。
- en: The biggest advantage here is that if a new protocol—QDP, for example—
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的优势是，如果发明了一种新的协议——例如QDP——
- en: is invented, you simply create a new QDPSocket class, and then change the line
    of code where the object is created. Then all calls to sendData will call the
    new QDPSocket version of sendData without the need to change all the calls individually.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: is invented, you simply create a new QDPSocket class, and then change the line
    of code where the object is created. Then all calls to sendData will call the
    new QDPSocket version of sendData without the need to change all the calls individually.
- en: In the case of nonvirtual functions, the function to be executed is determined
    at compile time. If the object is an instance of the parent class, the parent
    class’s function will be called, even if the object at runtime belongs to the
    child class. When a virtual function is called on an object of the child class,
    the child class’s version of the function may be called, if the object is typed
    as an instance of the parent class.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 在非虚函数的情况下，要执行哪个函数是在编译时确定的。如果对象是父类的实例，即使运行时对象属于子类，也会调用父类的函数。当对子类的对象调用虚函数时，如果对象被类型化为父类的实例，可能会调用子类的函数版本。
- en: Table 20-1 shows a code snippet that will execute differently if the function
    is virtual or nonvirtual.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 表20-1显示了如果函数是虚函数或非虚函数，代码将执行不同的代码片段。
- en: '**Table 20-1:** Source Code Example for Virtual Functions **Non-virtual function**'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '**表20-1：虚函数源代码示例** **非虚函数**'
- en: '**Virtual function**'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚函数**'
- en: class A {
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: class A {
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: 'public:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: 'public:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void foo() {
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: void foo() {
- en: **virtual** void foo() {
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: **virtual** void foo() {
- en: printf("Class A\n");
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: printf("类A\n");
- en: printf("Class A\n");
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: printf("类A\n");
- en: '}'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '};'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'class B : public A {'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 'class B : public A {'
- en: 'class B : public A {'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 'class B : public A {'
- en: 'public:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: 'public:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'public:'
- en: void foo() {
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: void foo() {
- en: **virtual** void foo() {
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: **virtual** void foo() {
- en: printf("Class B\n");
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: printf("类B\n");
- en: printf("Class B\n");
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: printf("类B\n");
- en: '}'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '};'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: void g(A& arg) {
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: void g(A& arg) {
- en: void g(A& arg) {
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: void g(A& arg) {
- en: arg.foo();
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: arg.foo();
- en: arg.foo();
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: arg.foo();
- en: '}'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: int _tmain(int argc, _TCHAR* argv[])
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: int _tmain(int argc, _TCHAR* argv[])
- en: int _tmain(int argc, _TCHAR* argv[])
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: int _tmain(int argc, _TCHAR* argv[])
- en: '{'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '{'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: B b;
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: B b;
- en: B b;
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: B b;
- en: A a;
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: A a;
- en: A a;
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: A a;
- en: g(b);
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: g(b);
- en: g(b);
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: g(b);
- en: return 0;
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: return 0;
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: '}'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: C++ Analysis
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: C++分析
- en: '**433**'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '**433**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: 'The code contains two classes: class A and class B. The class B class overrides
    the foo method from class A. The code also contains a function to call the foo
    method from outside either class. If the function is not declared as virtual,
    it will print “Class A.” If it is declared as virtual, it will print “Class B.”
    The code on either side is identical except for the virtual keywords at  and
    .'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码包含两个类：类A和类B。类B重写了类A的foo方法。代码还包含一个从外部调用foo方法的函数。如果该函数未声明为虚函数，它将打印“类A。”如果它声明为虚函数，它将打印“类B。”两边的代码除了虚函数关键字在和处不同之外，其余都是相同的。
- en: In the case of nonvirtual functions, the determination of which function to
    call is made at compile time. In the two code samples in Listing 20-6, when this
    code is compiled, the object at  is of class A. While the object at 
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在非虚函数的情况下，确定调用哪个函数是在编译时进行的。在列表20-6中的两个代码示例中，当编译此代码时，处的对象是类A的。而
- en: could be a subclass of class A, at compile time, we know that it is an object
    of class A, and the foo function for class A is called. This is why the code on
    the left will print “Class A.”
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是类A的子类，在编译时，我们知道它是一个类A的对象，并调用类A的foo函数。这就是为什么左边的代码会打印“类A。”
- en: In the case of virtual functions, the determination of which function to call
    is made at runtime. If a class A object is called at runtime, then the class A
    version of the function is called. If the object is of class B, then the class
    B
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚函数的情况下，确定调用哪个函数是在运行时进行的。如果运行时调用的是类A的对象，则调用类A的函数版本。如果对象是类B的，那么类B
- en: function is called. This is why the code on the right will print “Class B.”
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: function is called. This is why the code on the right will print “Class B.”
- en: This functionality is often referred to as *polymorphism*. The biggest advantage
    to polymorphism is that it allows objects that perform different functionality
    to share a common interface.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能通常被称为*多态性*。多态性的最大优点是它允许执行不同功能的对象共享一个公共接口。
- en: '***Use of Vtables***'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '***vtable的使用***'
- en: The C++ compiler will add special data structures when it compiles code to support
    virtual functions. These data structures are called *virtual function* *tables*,
    or *vtables*. These tables are simply arrays of function pointers. Each class
    using virtual functions has its own vtable, and each virtual function in a class
    has an entry in the vtable.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 当C++编译器编译代码以支持虚函数时，会添加特殊的数据结构。这些数据结构被称为*虚函数表*，或*vtables*。这些表仅仅是函数指针的数组。每个使用虚函数的类都有自己的vtable，并且类中的每个虚函数在vtable中都有一个条目。
- en: Table 20-2 shows a disassembly of g function from the two code snippets in Table
    20-1\. On the left is the nonvirtual function call to foo, and on the right is
    the virtual call.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 表20-2显示了表20-1中两个代码片段的g函数的反汇编。左侧是非虚函数调用foo，右侧是虚调用。
- en: '**Table 20-2:** Assembly Code of the Example from Table 20-1'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '**表20-2：表20-1示例的汇编代码**'
- en: '**Non-virtual function call**'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: '**非虚函数调用**'
- en: '**Virtual function call**'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚函数调用**'
- en: 00401000 push ebp
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000 push ebp
- en: 00401000 push ebp
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 00401000 push ebp
- en: 00401001 mov ebp, esp
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 00401001 mov ebp, esp
- en: 00401001 mov ebp, esp
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 00401001 mov ebp, esp
- en: 00401003 mov ecx, [ebp+arg_0]
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 00401003 mov ecx, [ebp+arg_0]
- en: 00401003 mov
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 00401003 mov
- en: eax, [ebp+arg_0]
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: eax, [ebp+arg_0]
- en: 00401006 call sub_401030
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 00401006 call sub_401030
- en: 00401006 mov
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 00401006 mov
- en: edx, [eax]
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: edx, [eax]
- en: 0040100B pop ebp
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100B pop ebp
- en: 00401008 mov ecx, [ebp+arg_0]
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 00401008 mov ecx, [ebp+arg_0]
- en: 0040100C retn
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100C retn
- en: 0040100B mov eax, [edx]
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100B mov eax, [edx]
- en: 0040100D call eax
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100D call eax
- en: 0040100F pop ebp
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 0040100F pop ebp
- en: 00401010 retn
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 00401010 retn
- en: The source code change is small, but the assembly looks completely different.
    The function call on the left looks the same as the C functions that we have seen
    before. The virtual function call on the right looks different. The biggest difference
    is that we can’t see the destination for the call instruction, which can pose
    a big problem when analyzing disassembled C++, because we need to track down the
    target of the call instruction.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码更改很小，但汇编代码看起来完全不同。左侧的函数调用看起来与我们之前看到的C函数相同。右侧的虚函数调用看起来不同。最大的不同是我们看不到调用指令的目标，这在分析反汇编的C++时可能是一个大问题，因为我们需要追踪调用指令的目标。
- en: '**434**'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: '**434**'
- en: Chapter 20
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 第20章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: The argument for the g function is a reference, which can be used as a pointer,
    to an object of class A (or any subclass of class A). The assembly code accesses
    the pointer to the beginning of the object . The code then accesses the first
    4 bytes of the object .
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: g函数的参数是一个引用，它可以作为一个指向类A（或A的任何子类）对象的指针。汇编代码访问对象开始的指针。然后代码访问对象的第一个4字节。
- en: Figure 20-2 shows how the virtual function is used in Table 20-2 to determine
    which code to call. The first 4 bytes of the object are a pointer to the vtable.
    The first 4-byte entry of the vtable is a pointer to the code for the first virtual
    function.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 图20-2显示了在表20-2中如何使用虚函数来确定要调用的代码。对象的第一个4字节是一个指向vtable的指针。vtable的第一个4字节条目是指向第一个虚函数代码的指针。
- en: Object
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 对象
- en: Vtable
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: vtable
- en: Code
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 代码
- en: vtable
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: vtable
- en: Function 1
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 函数1
- en: push ebp
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: push ebp
- en: mov ebp, esp
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: mov ebp, esp
- en: object data1
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数据1
- en: Function 2
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 函数2
- en: '...'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: object data2
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 对象数据2
- en: '...'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '...'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '*Figure 20-2: C++ object with a virtual function table (vtable)* To figure
    out which function is being called, you find where the vtable is being accessed,
    and you see which offset is being called. In Table 20-2, we see the first vtable
    entry being accessed. To find the code that is called, we must find the vtable
    in memory and then go to the first function in the list.'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图20-2：具有虚函数表(vtable)的C++对象* 要确定正在调用哪个函数，你需要找到vtable被访问的地方，并查看哪个偏移量被调用。在表20-2中，我们看到第一个vtable条目被访问。要找到被调用的代码，我们必须在内存中找到vtable，然后转到列表中的第一个函数。'
- en: Nonvirtual functions do not appear in a vtable because there is no need for
    them. The target for nonvirtual function calls is fixed at compile time.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 非虚函数不会出现在vtable中，因为它们在编译时不需要。非虚函数调用的目标在编译时是固定的。
- en: '***Recognizing a Vtable***'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: '***识别vtable***'
- en: In order to identify the call destination, we need to determine the type of
    object and locate the vtable. If you can spot the new operator for the constructor
    (a concept described in the next section), you can typically discover the address
    of the vtable being accessed nearby.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定调用目标，我们需要确定对象的类型并定位虚表。如果您能找到构造函数的新操作符（一个在下一节中描述的概念），通常可以找到附近被访问的虚表的地址。
- en: The vtable looks like an array of function pointers. For example, Listing 20-6
    shows the vtable for a class with three virtual functions. When you see a vtable,
    only the first value in the table should have a cross-reference.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 虚表看起来像是一个函数指针数组。例如，列表 20-6 显示了一个具有三个虚函数的类的虚表。当您看到虚表时，表中只有第一个值应该有一个交叉引用。
- en: The other elements of the table are accessed by their offset from the beginning
    of the table, and there are no accesses directly to items within the table.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的其他元素通过从表格开始的偏移量进行访问，并且没有直接访问表格内项的访问。
- en: '**NOTE**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this example, the line labeled off_4020F0 is the beginning of the vtable,
    but don’t* *confuse this with switch offset tables, covered in Chapter 6\. A switch
    offset table* *would have offsets to locations that are not subroutines, labeled
    loc_###### instead* *of sub_######.*'
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个例子中，标记为 off_4020F0 的行是虚表的开始，但不要* *将此与第 6 章中介绍的 switch 偏移表混淆。switch 偏移表*
    *将包含指向不是子例程的位置的偏移量，标记为 loc_###### 而不是 sub_######。*'
- en: 004020F0 **off_4020F0** dd offset sub_4010A0
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F0 **off_4020F0** dd offset sub_4010A0
- en: 004020F4 dd offset sub_4010C0
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F4 dd offset sub_4010C0
- en: 004020F8 dd offset sub_4010E0
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F8 dd offset sub_4010E0
- en: '*Listing 20-6: A vtable in IDA Pro*'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-6：IDA Pro 中的虚表*'
- en: C++ Analysis
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析
- en: '**435**'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '**435**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '![Image 91](index-469_1.jpg)'
  id: totrans-1265
  prefs: []
  type: TYPE_IMG
  zh: '![图像 91](index-469_1.jpg)'
- en: You can recognize virtual functions by their cross-references. Virtual functions
    are not directly called by other parts of the code, and when you check cross-references
    for a virtual function, you should not see any calls to that function. For example,
    Figure 20-3 shows the cross-references for a virtual function. Both cross-references
    are offsets to the function, and neither is a call instruction. Virtual functions
    almost always appear this way, whereas nonvirtual functions are typically referenced
    via a call instruction.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过交叉引用来识别虚函数。虚函数不是由代码的其他部分直接调用的，并且当您检查虚函数的交叉引用时，您不应该看到对该函数的任何调用。例如，图 20-3
    显示了虚函数的交叉引用。这两个交叉引用都是对函数的偏移量，都不是调用指令。虚函数几乎总是以这种方式出现，而非虚函数通常通过调用指令进行引用。
- en: '*Figure 20-3: Cross-references for a virtual function* Once you have found
    a vtable and virtual functions, you can use that information to analyze them.
    When you identify a vtable, you instantly know that all functions within that
    table belong to the same class, and that functions within the same class are somehow
    related. You can also use vtables to determine if class relationships exist.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 20-3：虚函数的交叉引用* 一旦找到虚表和虚函数，您就可以使用这些信息来分析它们。当您识别到虚表时，您立即知道该表中的所有函数都属于同一个类，并且同一类中的函数以某种方式相关。您还可以使用虚表来确定是否存在类关系。'
- en: Listing 20-7, an expansion of Listing 20-6, includes vtables for two classes.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 20-7，是列表 20-6 的扩展，包括两个类的虚表。
- en: 004020DC off_4020DC dd offset sub_401100
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 004020DC off_4020DC dd offset sub_401100
- en: 004020E0 dd offset sub_4010C0
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 004020E0 dd offset sub_4010C0
- en: 004020E4
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 004020E4
- en: dd offset sub_4010E0
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: dd offset sub_4010E0
- en: 004020E8 dd offset sub_401120
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 004020E8 dd offset sub_401120
- en: 004020EC dd offset unk_402198
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 004020EC dd offset unk_402198
- en: 004020F0 off_4020F0 dd offset sub_4010A0
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F0 off_4020F0 dd offset sub_4010A0
- en: 004020F4 dd offset sub_4010C0
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F4 dd offset sub_4010C0
- en: 004020F8
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 004020F8
- en: dd offset sub_4010E0
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: dd offset sub_4010E0
- en: '*Listing 20-7: Vtables for two different classes*'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 20-7：两个不同类的虚表*'
- en: Notice that the functions at  and  are the same, and that there are two cross-references
    for this function, as shown in Figure 20-3\. The two cross-references are from
    the two vtables that point to this function, which suggests an inheritance relationship.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到和处的函数是相同的，并且如图 20-3 所示，该函数有两个交叉引用。这两个交叉引用来自指向此函数的两个虚表，这表明存在继承关系。
- en: Remember that child classes automatically include all functions from a parent
    class, unless they override it. In Listing 20-7, sub_4010E0 at  and  is a function
    from the parent class that is also in the vtable for the child class, because
    it can also be called for the child class.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，子类会自动包含父类中的所有函数，除非它们重写了这些函数。在列表20-7中，sub_4010E0在和处是父类中的一个函数，它也在子类的vtable中，因为它也可以为子类调用。
- en: You can’t always differentiate a child class from a parent class, but if one
    vtable is larger than the other, it is the subclass. In this example, the vtable
    at offset 4020F0 is the parent class, and the vtable at offset 4020DC is the child
    class because its vtable is larger. (Remember that child classes always have the
    same functions as the parent class and may have additional functions.) **436**
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定能区分子类和父类，但如果一个vtable比另一个大，那么它是子类。在这个例子中，偏移量为4020F0的vtable是父类，而偏移量为4020DC的vtable是子类，因为它的vtable更大。（记住，子类总是有与父类相同的函数，并且可能有额外的函数。）**436**
- en: Chapter 20
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 第20章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Creating and Destroying Objects**'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建和销毁对象**'
- en: Two special functions for C++ classes are the *constructor* and *destructor*.
    When an object is created, the constructor is called. When an object is destroyed,
    the destructor is called.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: C++类有两个特殊函数：*构造函数*和*析构函数*。当创建对象时，会调用构造函数。当对象被销毁时，会调用析构函数。
- en: The constructor performs any initialization needed by the object.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数执行对象需要的任何初始化。
- en: Objects can be created on the stack or stored on the heap. For objects created
    on the stack, there is no need to allocate specific memory for the object; the
    object will simply be stored on the stack along with other local variables.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以创建在栈上或存储在堆上。对于在栈上创建的对象，不需要为对象分配特定的内存；对象将简单地与其他局部变量一起存储在栈上。
- en: The destructor for objects is automatically called when the objects go out of
    scope. Sometimes this tends to complicate disassembly, because the compiler may
    need to add exception handling code in order to guarantee that object destructors
    are called.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象超出作用域时，会自动调用对象的析构函数。有时这会使反汇编变得复杂，因为编译器可能需要添加异常处理代码，以确保调用对象析构函数。
- en: For objects that are not stored on the stack, the memory is allocated with the
    new operator, which is a C++ keyword that creates heap space for a new object
    and calls the constructor. In disassembly, the new operator is usually an imported
    function that can be spotted easily. For example, Listing 20-8 shows the IDA Pro
    disassembly using the new operator implemented as an imported function. Since
    this is the new operator and not a regular function, it has an unusual function
    name. IDA Pro identifies the function properly as the new operator and labels
    it as such. Similarly, a delete operator is called when heap-allocated objects
    are to be freed.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不在栈上存储的对象，内存是通过new运算符分配的，它是C++中的一个关键字，用于为新的对象创建堆空间并调用构造函数。在反汇编中，new运算符通常是一个导入函数，可以很容易地找到。例如，列表20-8显示了使用导入函数实现的new运算符的IDA
    Pro反汇编。由于这是new运算符而不是常规函数，它有一个不寻常的函数名。IDA Pro正确地将该函数识别为new运算符，并将其标记为这样的。同样，当需要释放堆分配的对象时，会调用delete运算符。
- en: '**NOTE**'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Object creation and deletion are key elements of the execution flow for a
    C++ program.*'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象创建和销毁是C++程序执行流程中的关键元素。*'
- en: '*Reverse-engineering these routines can usually provide key insight into the
    object layout* *and aid analysis in other member functions.*'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: '*对这些例程进行逆向工程通常可以提供关于对象布局的关键见解，并有助于分析其他成员函数。*'
- en: 00401070 push ebp
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 00401070 push ebp
- en: 00401071 mov ebp, esp
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 00401071 mov ebp, esp
- en: 00401073 sub esp, 1Ch
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 00401073 sub esp, 1Ch
- en: 00401076 mov [ebp+var_10],  offset off_4020F0
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 00401076 mov [ebp+var_10],  offset off_4020F0
- en: 0040107D mov [ebp+var_10],  offset off_4020DC
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 0040107D mov [ebp+var_10],  offset off_4020DC
- en: 00401084 mov [ebp+var_4], offset off_4020F0
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 00401084 mov [ebp+var_4], offset off_4020F0
- en: 0040108B push 4
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108B push 4
- en: 0040108D call ??2@YAPAXI@Z ; operator new(uint)
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 0040108D call ??2@YAPAXI@Z ; operator new(uint)
- en: '*Listing 20-8: The new operator in disassembly*'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表20-8：反汇编中的new运算符*'
- en: In Listing 20-8, we’re looking at an object stored on the stack. The offset
    moved into location var_10 is the vtable. The compiler here shows some strange
    behavior by putting different offsets into the same location twice in a row. The
    instruction at  is useless, because the second offset at  will overwrite what
    is stored at .
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 20-8 中，我们正在查看堆栈上存储的对象。移动到位置 var_10 的偏移量是虚表。编译器在这里表现出一些奇怪的行为，连续两次将不同的偏移量放入同一位置。指令
     是无用的，因为偏移量  将覆盖存储在  中的内容。
- en: If we were to look at the offsets for this code, we would see that they are
    the vtables for the two classes. The first offset is the vtable for the parent
    class, and the second offset is the vtable for the class of the object being created.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这段代码的偏移量，我们会看到它们是两个类的虚表。第一个偏移量是父类的虚表，第二个偏移量是正在创建的对象的类的虚表。
- en: C++ Analysis
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析
- en: '**437**'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '**437**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Conclusion**'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '**结论**'
- en: In order to analyze malicious programs written in C++, you need to understand
    C++ features and how they affect the assembly code. By understanding inheritance,
    vtables, the this pointer, and name mangling, you won’t be slowed down by C++
    code, and you’ll be able to take advantage of any clues provided by the additional
    structure created by C++ classes.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析用 C++ 编写的恶意软件，你需要了解 C++ 特性和它们如何影响汇编代码。通过理解继承、虚表、this 指针和名称修饰，你不会因为 C++ 代码而减慢速度，并且能够利用
    C++ 类创建的任何结构提供的线索。
- en: '**438**'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '**438**'
- en: Chapter 20
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 第 20 章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**L A B S**'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '**L A B S**'
- en: '**Lab 20-1**'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 20-1**'
- en: The purpose of this first lab is to demonstrate the usage of the this pointer.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 本次第一个实验的目的是演示 this 指针的使用。
- en: Analyze the malware in *Lab20-01.exe*.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 *Lab20-01.exe* 中的恶意软件。
- en: '***Questions***'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: Does the function at 0x401040 take any parameters?
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401040 处的函数是否接受任何参数？
- en: 2\.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: Which URL is used in the call to URLDownloadToFile?
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 URLDownloadToFile 时使用了哪个 URL？
- en: 3\.
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What does this program do?
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序做了什么？
- en: '**Lab 20-2**'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 20-2**'
- en: The purpose of this second lab is to demonstrate virtual functions. Analyze
    the malware in *Lab20-02.exe*.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 本次实验的目的是演示虚函数。分析 *Lab20-02.exe* 中的恶意软件。
- en: '**NOTE**'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This program is not dangerous to your computer, but it will try to upload
    possibly sensitive files from your machine.*'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个程序对您的计算机没有危险，但它会尝试从您的机器上传可能敏感的文件。*'
- en: '***Questions***'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What can you learn from the interesting strings in this program?
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个程序中的有趣字符串中学到什么？
- en: 2\.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What do the imports tell you about this program?
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 导入项能告诉你关于这个程序什么信息？
- en: 3\.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: What is the purpose of the object created at 0x4011D9? Does it have any virtual
    functions?
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0x4011D9 处创建的对象的目的是什么？它有任何虚函数吗？
- en: 4\.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: Which functions could possibly be called by the call [edx] instruction at 0x401349?
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 0x401349 处的 [edx] 指令可能调用哪些函数？
- en: 5\.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: How could you easily set up the server that this malware expects in order to
    fully analyze the malware without connecting it to the Internet?
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何轻松设置恶意软件期望的服务器，以便在不连接到互联网的情况下完全分析恶意软件？
- en: 6\.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '6.'
- en: What is the purpose of this program?
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的目的是什么？
- en: 7\.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '7.'
- en: What is the purpose of implementing a virtual function call in this program?
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中实现虚函数调用的目的是什么？
- en: '**Lab 20-3**'
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lab 20-3**'
- en: This third lab is a longer and more realistic piece of malware. This lab comes
    with a configuration file named *config.dat* that must be in the same directory
    as the lab in order to execute properly. Analyze the malware in *Lab20-03.exe*.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 本次第三个实验是一个更长、更真实的恶意软件样本。本实验附带一个名为 *config.dat* 的配置文件，必须与实验文件位于同一目录下才能正确执行。分析
    *Lab20-03.exe* 中的恶意软件。
- en: C++ Analysis
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 分析
- en: '**439**'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '**439**'
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '***Questions***'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '***问题***'
- en: 1\.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '1.'
- en: What can you learn from the interesting strings in this program?
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个程序中的有趣字符串中学到什么？
- en: 2\.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '2.'
- en: What do the imports tell you about this program?
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 导入项能告诉你关于这个程序什么信息？
- en: 3\.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '3.'
- en: At 0x4036F0, there is a function call that takes the string Config error, followed
    a few instructions later by a call to CxxThrowException. Does the function take
    any parameters other than the string? Does the function return anything? What
    can you tell about this function from the context in which it’s used?
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0x4036F0 处有一个函数调用，它调用字符串 Config error，随后几条指令后调用 CxxThrowException。这个函数除了字符串外还接受任何参数吗？这个函数返回任何东西吗？你能从它被使用的上下文中了解到这个函数的什么信息？
- en: 4\.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: '4.'
- en: What do the six entries in the switch table at 0x4025C8 do?
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 0x4025C8处的切换表中的六个条目分别做什么？
- en: 5\.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '5.'
- en: What is the purpose of this program?
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的目的是什么？
- en: '**440**'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '**440**'
- en: Chapter 20
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 第20章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**6 4 - B I T M A L W A R E**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '**6 4 - B I T M A L W A R E**'
- en: Almost all current malware is 32-bit, but some is writ-
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有当前的恶意软件都是32位的，但也有一些是...
- en: ten for the 64-bit architecture in order to interact
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与64位架构交互
- en: with 64-bit OSs. As 64-bit OSs become more popular,
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 与64位操作系统相关。随着64位操作系统的普及，
- en: so will 64-bit malware.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 所以64位恶意软件也是如此。
- en: Several 64-bit architectures have been introduced. The first to be supported
    by Windows, Itanium, was designed for performance computing and was not compatible
    with x86\. AMD later introduced a 64-bit architecture called AMD64, which was
    compatible with x86 code. Intel adopted AMD64
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 已介绍了几种64位架构。Windows首先支持的Itanium是为高性能计算设计的，与x86不兼容。AMD后来引入了一种称为AMD64的64位架构，它与x86代码兼容。英特尔采用了AMD64
- en: and called its implementation EM64T. This architecture is now known as x64,
    or x86-64, and it is the most popular implementation of 64-bit code on Windows.
    All current Windows versions are available in 64-bit versions, which support both
    64-bit and 32-bit applications.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其实现称为EM64T。这种架构现在被称为x64，或x86-64，它是Windows上64位代码最流行的实现。所有当前的Windows版本都提供64位版本，支持64位和32位应用程序。
- en: The x64 architecture was designed as an upgrade to x86, and the instruction
    sets are not drastically different. Because most instructions are unchanged from
    x86 to x64, when you open a 64-bit executable in IDA Pro, you should be familiar
    with most of the instructions. One of the biggest complications
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: x64架构被设计为x86的升级，指令集没有太大差异。因为大多数指令从x86到x64没有变化，所以当你用IDA Pro打开64位可执行文件时，你应该熟悉大多数指令。最大的复杂性之一
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: associated with 64-bit malware analysis is that not all tools support x64 assembly.
    For example, as of this writing, OllyDbg does not support 64-bit applications,
    although WinDbg does. IDA Pro supports x64 assembly, but it requires the IDA Pro
    Advanced version.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 与64位恶意软件分析相关的是，并非所有工具都支持x64汇编。例如，截至本文撰写时，OllyDbg不支持64位应用程序，尽管WinDbg支持。IDA Pro支持x64汇编，但它需要IDA
    Pro高级版本。
- en: This chapter addresses the differences between 32-bit and 64-bit systems, and
    provides a few hints to help analyze 64-bit code.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了32位和64位系统之间的差异，并提供了一些提示，以帮助分析64位代码。
- en: '**Why 64-Bit Malware?**'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么是64位恶意软件？**'
- en: Knowing that 32-bit malware can target both 32-bit and 64-bit machines, why
    would anyone bother to write 64-bit malware?
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 既然32位恶意软件可以针对32位和64位机器，为什么还有人要编写64位恶意软件？
- en: While you can run both 32-bit and 64-bit applications on the same system, you
    cannot run 32-bit code within 64-bit applications. When a processor is running
    32-bit code, it is running in 32-bit mode, and you cannot run 64-bit code. Therefore,
    anytime malware needs to run inside the process space of a 64-bit process, it
    must be 64-bit.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在同一系统上运行32位和64位应用程序，但你不能在64位应用程序中运行32位代码。当处理器运行32位代码时，它处于32位模式，你不能运行64位代码。因此，每当恶意软件需要在64位进程的进程空间中运行时，它必须是64位的。
- en: 'Here are a few examples of why malware might need to be compiled for the x64
    architecture:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例说明为什么恶意软件可能需要为x64架构编译：
- en: '**Kernel code**'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核代码**'
- en: All kernel code for an OS is within a single memory space, and all kernel code
    running in a 64-bit OS must be 64-bit. Because rootkits often run within the kernel,
    rootkits that target 64-bit OSs must be compiled into 64-bit machine code. Also,
    because antivirus and host-based security code often contain kernel elements,
    malware designed to interfere with these applications must be 64-bit, or at least
    have 64-bit components.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的所有内核代码都在单个内存空间内，且在64位操作系统上运行的内核代码必须是64位的。因为rootkits通常在内核中运行，所以针对64位操作系统的rootkits必须编译成64位机器代码。此外，由于防病毒和基于主机的安全代码通常包含内核元素，旨在干扰这些应用程序的恶意软件必须是64位的，或者至少包含64位组件。
- en: Microsoft has made changes to the 64-bit versions of Windows that make it difficult
    to run malicious kernel code by detecting unauthorized modifications to the kernel
    and restricting the Windows ability to load drivers that aren’t digitally signed.
    (These changes are covered in detail at the end of Chapter 10.)
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对Windows 64位版本进行了修改，使得通过检测内核的未授权修改并限制Windows加载未数字签名的驱动程序的能力，难以运行恶意内核代码。（这些修改在第10章的末尾有详细说明。）
- en: '**Plug-ins and injected code**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件和注入代码**'
- en: These must be 64-bit in order to run properly in a 64-bit process. For example,
    a malicious Internet Explorer plug-in or ActiveX control must be 64-bit if the
    computer is running the 64-bit version of Internet Explorer. Code injected using
    the techniques covered in Chapter 12 also runs within another process. If the
    target process is 64-bit, the injected code must also be 64-bit.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些必须是64位的，以便在64位进程中正常运行。例如，如果计算机运行的是64位版本的Internet Explorer，那么恶意Internet Explorer插件或ActiveX控件必须是64位的。在第12章中介绍的技术注入的代码也在另一个进程中运行。如果目标进程是64位的，注入的代码也必须是64位的。
- en: '**Shellcode**'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shellcode**'
- en: Shellcode is usually run as part of an exploit within the process that it is
    exploiting. In order to exploit a vulnerability in the 64-bit version of Internet
    Explorer, for example, a malware author would need to write 64-bit shellcode.
    As more users run a mix of 64-bit and 32-bit applications, malware writers will
    need to write a separate version of shellcode for 32-bit and 64-bit victims.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode通常作为被利用进程的一部分运行。例如，为了利用64位版本Internet Explorer中的漏洞，恶意软件作者需要编写64位shellcode。随着越来越多的用户运行64位和32位应用程序的混合，恶意软件编写者将为32位和64位受害者编写单独的shellcode版本。
- en: '**442**'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**442**'
- en: Chapter 21
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 第21章
- en: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.it-ebooks.info](http://www.it-ebooks.info/)'
- en: '**Differences in x64 Architecture**'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '**x64架构的差异**'
- en: 'The following are the most important differences between Windows 64-bit and
    32-bit architecture:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Windows 64位和32位架构之间最重要的差异：
- en: 
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: All addresses and pointers are 64 bits.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 所有地址和指针都是64位的。
- en: 
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 
- en: All general-purpose registers—including RAX, RBX, RCX, and so on—
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通用寄存器——包括RAX、RBX、RCX等——
- en: have increased in size, although the 32-bit versions can still be accessed.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸已增加，尽管32位版本仍然可以访问。
