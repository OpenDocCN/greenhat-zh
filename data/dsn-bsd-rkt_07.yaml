- en: Chapter 7. DETECTION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。检测
- en: 'We''ll now turn to the challenging world of rootkit detection. In general,
    you can detect a rootkit in one of two ways: either by signature or by behavior.
    *Detecting by signature* involves scanning the operating system for a particular
    rootkit trait (e.g., inline function hooks). *Detecting by behavior* involves
    catching the operating system in a "lie" (e.g., `sockstat(1)` lists two open ports,
    but a port scan reveals three).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向具有挑战性的rootkit检测领域。一般来说，你可以通过两种方式检测rootkit：要么通过签名，要么通过行为。*通过签名检测*涉及在操作系统中扫描特定的rootkit特征（例如，内联函数钩子）。*通过行为检测*涉及捕捉操作系统在“说谎”（例如，`sockstat(1)`列出两个打开的端口，但端口扫描显示三个）。
- en: In this chapter, you'll learn how to detect the different rootkit techniques
    described throughout this book. Keep in mind, however, that rootkits and rootkit
    detectors are in a perpetual arms race. When one side develops a new technique,
    the other side develops a countermeasure. In other words, what works today may
    not work tomorrow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何检测本书中描述的不同rootkit技术。然而，请记住，rootkits和rootkit检测器处于永无止境的军备竞赛中。当一方开发了一种新技术时，另一方就会开发一种对策。换句话说，今天有效的方法明天可能就不灵了。
- en: Detecting Call Hooks
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测调用钩子
- en: As stated in [Chapter 2](ch02.html "Chapter 2. HOOKING"), call hooking is really
    all about redirecting function pointers. Therefore, to detect a call hook, you
    simply need to determine whether or not a function pointer still points to its
    original function. For example, you can determine if the `mkdir` system call has
    been hooked by checking its `sysent` structure's `sy_call` member. If it points
    to any function other than `mkdir`, you've got yourself a call hook.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.html "第2章。挂钩")中所述，调用钩子实际上完全是关于重定向函数指针。因此，要检测调用钩子，你只需确定函数指针是否仍然指向其原始函数。例如，你可以通过检查`sysent`结构的`sy_call`成员来确定`mkdir`系统调用是否被钩子。如果它指向除`mkdir`之外的任何函数，你就找到了一个调用钩子。
- en: Finding System Call Hooks
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找系统调用钩子
- en: 'Listing 7-1 is a simple program designed to find (and uninstall) system call
    hooks. This program is invoked with two parameters: the name of the system call
    to check and its corresponding system call number. It also has an optional third
    parameter, the string "fix," which restores the original system call function
    if a hook is found.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-1是一个简单的程序，用于查找（并卸载）系统调用钩子。此程序使用两个参数调用：要检查的系统调用名称及其对应的系统调用号。它还有一个可选的第三个参数，字符串"fix"，如果找到钩子，则恢复原始的系统调用函数。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following program is actually Stephanie Wehner's checkcall.c; I have made
    some minor changes so that it compiles cleanly under FreeBSD 6\. I also made some
    cosmetic changes so that it looks better in print.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序实际上是Stephanie Wehner的checkcall.c；我对它做了一些小的修改，以便在FreeBSD 6下干净地编译。我还做了一些外观上的修改，以便在打印时看起来更好。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: checkcall.c*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-1：checkcall.c*'
- en: Listing 7-1 first ❶ retrieves the in-memory address of `sysent[]` and the system
    call to be checked (`argv[1]`). Next, ❷ a local copy of `argv[1]`'s `sysent` structure
    is created. This structure's `sy_call` member is then ❸ checked to make sure that
    it still points to its original function; if it does, the program returns. Otherwise,
    it means there is a system call hook, and the program continues. If the optional
    third parameter is present, `sy_call` is ❹ adjusted to point to its original function,
    effectively uninstalling the system call hook.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-1首先❶检索`sysent[]`的内存地址和要检查的系统调用(`argv[1]`)。然后❷创建`argv[1]`的`sysent`结构的一个本地副本。然后检查该结构的`sy_call`成员，以确保它仍然指向其原始函数；如果是这样，程序返回。否则，这意味着存在系统调用钩子，程序继续。如果存在可选的第三个参数，则将`sy_call`调整以指向其原始函数，从而有效地卸载系统调用钩子。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The checkcall program only uninstalls the system call hook; it doesn't remove
    it from memory. Also, if you pass an incorrect system call function and number
    pair, checkcall can actually damage your system. However, the point of this example
    is that it details (in code) the theory behind detecting any call hook.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: checkcall程序仅卸载系统调用钩子；它不会将其从内存中移除。此外，如果你传递了一个错误的系统调用函数和数字对，checkcall实际上可能会损坏你的系统。然而，本例的重点是详细（在代码中）说明检测任何调用钩子的理论。
- en: In the following output, checkcall is run against `mkdir_hook` (the `mkdir`
    system call hook developed in [Chapter 2](ch02.html "Chapter 2. HOOKING")) to
    demonstrate its functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下输出中，checkcall程序针对`mkdir_hook`（在[第2章](ch02.html "第2章。挂钩")中开发的`mkdir`系统调用钩子）运行以演示其功能。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the hook is caught and uninstalled.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，钩子被捕获并卸载了。
- en: Because checkcall works by referencing the kernel's in-memory symbol table,
    patching this table would defeat checkcall. Of course, you could get around this
    by referencing a symbol table on the filesystem, but then you would be susceptible
    to a file redirection attack. See what I meant earlier by a perpetual arms race?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为checkcall通过引用内核的内存符号表来工作，修补这个表将使checkcall失效。当然，你可以通过引用文件系统上的符号表来绕过这个问题，但这样你将容易受到文件重定向攻击。我之前提到的永无止境的军备竞赛是什么意思？
- en: Detecting DKOM
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测DKOM
- en: As stated in [Chapter 3](ch03.html "Chapter 3. DIRECT KERNEL OBJECT MANIPULATION"),
    DKOM is one of the most difficult-to-detect rootkit techniques. This is because
    you can unload a DKOM-based rootkit from memory after patching, which leaves almost
    no signature. Therefore, in order to detect a DKOM-based attack, your best bet
    is to catch the operating system in a "lie." To do this, you should have a good
    understanding of what is considered normal behavior for your system(s).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](ch03.html "第3章。直接内核对象操作")所述，DKOM是难以检测的rootkit技术之一。这是因为你可以在修补后从内存中卸载基于DKOM的rootkit，这几乎不留下任何痕迹。因此，为了检测基于DKOM的攻击，你最好的办法是捕捉操作系统在“说谎”。为此，你应该对你的系统（们）的正常行为有一个很好的理解。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One caveat to this approach is that you can't trust the APIs on the system you
    are checking.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，你不能信任你检查的系统上的API。
- en: Finding Hidden Processes
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找隐藏进程
- en: Recall from [Chapter 3](ch03.html "Chapter 3. DIRECT KERNEL OBJECT MANIPULATION")
    that in order to hide a running process with DKOM, you need to patch the `allproc`
    list, `pidhashtbl`, the parent process's child list, the parent process's process-group
    list, and the `nprocs` variable. If any of these objects is left unpatched, it
    can be used as the litmus test to determine whether or not a process is hidden.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第3章](ch03.html "第3章。直接内核对象操作")回忆起，为了使用DKOM隐藏一个运行中的进程，你需要修补`allproc`列表、`pidhashtbl`、父进程的子进程列表、父进程的进程组列表以及`nprocs`变量。如果这些对象中的任何一个未被修补，它可以用作试金石来确定一个进程是否被隐藏。
- en: However, if all of these objects are patched, you can still find a hidden process
    by checking `curthread` before (or after) each context switch, since every running
    process stores its context in `curthread` when it executes. You can check `curthread`
    by installing an inline function hook at the beginning of `mi_switch`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使所有这些对象都进行了修补，你仍然可以通过在每次上下文切换之前（或之后）检查`curthread`来找到一个隐藏的过程，因为每个正在运行的过程在执行时都会将其上下文存储在`curthread`中。你可以在`mi_switch`的开始处安装一个内联函数钩子来检查`curthread`。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Because the code to do this is rather lengthy, I'll simply explain how it's
    done and leave the actual code to you.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为执行此操作的代码相当长，我将简单地解释如何执行，并将实际的代码留给你。
- en: The `mi_switch` function implements the machine-independent prelude to a thread
    context switch. In other words, it handles all the administrative tasks required
    to perform a context switch, but not the context switch itself. (Either `cpu_switch`
    or `cpu_throw` performs the actual context switch.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`mi_switch`函数实现了线程上下文切换的机器无关的前奏。换句话说，它处理执行上下文切换所需的所有管理任务，但不执行上下文切换本身。（`cpu_switch`或`cpu_throw`执行实际的上下文切换。）'
- en: 'Here is the disassembly of `mi_switch`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`mi_switch`的汇编代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assuming that your `mi_switch` hook is going to be installed on a wide range
    of systems, you can use the fact that `mi_switch` always accesses ❶ the `%fs`
    segment register (which is, of course, `curthread`) as your placeholder instruction.
    That is, you can use 0×64 in a manner similar to how we used 0xe8 in [Chapter 5](ch05.html
    "Chapter 5. RUN-TIME KERNEL MEMORY PATCHING")'s `mkdir` inline function hook.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的`mi_switch`钩子将被安装在广泛的各种系统上，你可以利用`mi_switch`总是访问❶ `%fs`段寄存器（当然，就是`curthread`）的事实作为你的占位指令。也就是说，你可以用0×64的方式，类似于我们在[第5章](ch05.html
    "第5章。运行时内核内存修补")的`mkdir`内联函数钩子中使用0xe8。
- en: With regard to the hook itself, you can either write something very simple,
    such as a hook that prints out the process name and PID of the currently running
    thread (which, given enough time, would give you the "true" list of running processes
    on your system) or write something very complex, such as a hook that checks whether
    the current thread's process structure is still linked in `allproc`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于钩子本身，你可以写一个非常简单的钩子，比如打印出当前运行线程的进程名和PID（如果时间足够长，这将给出你系统上运行进程的“真实”列表），或者写一个非常复杂的钩子，比如检查当前线程的进程结构是否仍然链接在`allproc`中。
- en: Regardless, this hook will add a substantial amount of overhead to your system's
    thread-scheduling algorithm, which means that while it's in place, your system
    will become more or less unusable. Therefore, you should also write an uninstall
    routine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，这个钩子将给你的系统线程调度算法增加大量的开销，这意味着当它被放置时，你的系统将变得几乎无法使用。因此，你也应该编写一个卸载例程。
- en: Also, because this is a rootkit detection program and not a rootkit, I would
    suggest that you allocate kernel memory for your hook the "proper" way—with a
    kernel module. Remember, the algorithm to allocate kernel memory via run-time
    patching has an inherent race condition, and you don't want to crash your system
    while checking for hidden processes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为这是一个rootkit检测程序而不是rootkit，我建议你以“正确”的方式为你的钩子分配内核内存——使用内核模块。记住，通过运行时修补分配内核内存的算法存在固有的竞争条件，你不想在检查隐藏进程时导致系统崩溃。
- en: That's it. As you can see, this program is really just a simple inline function
    hook, no more complex than the example from [Chapter 5](ch05.html "Chapter 5. RUN-TIME
    KERNEL MEMORY PATCHING").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。正如你所见，这个程序实际上只是一个简单的内联函数钩子，其复杂度并不比[第5章](ch05.html "第5章。运行时内核内存修补")中的例子更复杂。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Based on the process-hiding routine from [Chapter 3](ch03.html "Chapter 3. DIRECT
    KERNEL OBJECT MANIPULATION"), you can also detect a hidden process by checking
    the UMA zone for processes. First, select an unused flag bit from *p_flag*. Next,
    iterate through all of the slabs/buckets in the UMA zone and find all of the allocated
    processes; lock each process and clear the flag. Then, iterate through *allproc*
    and set the flag on each process. Finally, iterate through the processes in the
    UMA zone again, and look for any processes that don't have the flag set. Note
    that you'll need to hold *allproc_lock* the entire time you are doing this to
    prevent races that would result in false positives; you can use a shared lock,
    though, to avoid starving the system too much. ^([[1](#ftn.CHP-7-FN-1)])
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[第3章](ch03.html "第3章。直接内核对象操作")中的进程隐藏例程，你也可以通过检查进程的UMA区域来检测一个隐藏的进程。首先，从*p_flag*中选择一个未使用的标志位。接下来，遍历UMA区域中的所有slabs/buckets，找到所有已分配的进程；锁定每个进程并清除标志。然后，遍历*allproc*并设置每个进程的标志。最后，再次遍历UMA区域中的进程，寻找任何未设置标志的进程。请注意，在整个操作过程中，你需要持有*allproc_lock*以防止产生导致假阳性的竞争条件；尽管如此，你可以使用共享锁来避免过度消耗系统资源。^([[1](#ftn.CHP-7-FN-1)])
- en: Finding Hidden Ports
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找隐藏端口
- en: Recall from [Chapter 3](ch03.html "Chapter 3. DIRECT KERNEL OBJECT MANIPULATION")
    that we hid an open TCP-based port by removing its `inpcb` structure from `tcbinfo.listhead`.
    Compare that with hiding a running process, which involves removing its `proc`
    structure from three lists and a hash table, as well as adjusting a variable.
    Seems a little imbalanced, doesn't it? The fact is, if you want to completely
    hide an open TCP-based port, you need to adjust one list (`tcbinfo.listhead`),
    two hash tables (`tcbinfo.hashbase` and `tcbinfo.porthashbase`), and one variable
    (`tcbinfo.ipi_count`). But there is one problem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第3章](ch03.html "第3章。直接内核对象操作")中提到的，我们通过从`tcbinfo.listhead`中移除其`inpcb`结构来隐藏一个基于TCP的开放端口。将其与隐藏一个运行中的进程进行比较，这涉及到从三个列表和一个哈希表中移除其`proc`结构，以及调整一个变量。看起来有点不平衡，不是吗？事实上，如果你想完全隐藏一个基于TCP的开放端口，你需要调整一个列表（`tcbinfo.listhead`）、两个哈希表（`tcbinfo.hashbase`和`tcbinfo.porthashbase`）以及一个变量（`tcbinfo.ipi_count`）。但有一个问题。
- en: When data arrives for an open TCP-based port, its associated `inpcb` structure
    is retrieved through `tcbinfo.hashbase`, not `tcbinfo.listhead`. In other words,
    if you remove an `inpcb` structure from `tcbinfo.hashbase`, the associated port
    is rendered useless (i.e., no one can connect to or exchange data with it). Consequently,
    if you want to find every open TCP-based port on your system, you just need to
    iterate through `tcbinfo.hashbase`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据到达一个基于TCP的开放端口时，其相关的`inpcb`结构是通过`tcbinfo.hashbase`而不是`tcbinfo.listhead`检索的。换句话说，如果你从`tcbinfo.hashbase`中移除一个`inpcb`结构，相关的端口将变得无用了（即，没有人可以连接到或与之交换数据）。因此，如果你想找到系统上的每个基于TCP的开放端口，你只需要遍历`tcbinfo.hashbase`。
- en: '* * *'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-7-FN-1)]) ¹ Of course, all of this just means that my process-hiding
    routine needs to patch the UMA zone for processes and threads. Thanks, John.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-7-FN-1)]) ¹ 当然，所有这些都意味着我的进程隐藏例程需要修补进程和线程的UMA区域。谢谢，John。
- en: Detecting Run-Time Kernel Memory Patching
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测运行时内核内存修补
- en: 'There are essentially two types of run-time kernel memory patching attacks:
    those that employ inline function hooks and those that don''t. I''ll discuss detecting
    each in turn.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有两种运行时内核内存修补攻击类型：那些使用内联函数钩子的和那些不使用的。我将依次讨论检测每种类型。
- en: Finding Inline Function Hooks
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找内联函数钩子
- en: Finding an inline function hook is rather tedious, which also makes it somewhat
    difficult. You can install an inline function hook just about anywhere, as long
    as there is enough room within the body of your target function, and you can use
    a variety of instructions to get the instruction pointer to point to a region
    of memory under your control. In other words, you don't have to use the exact
    jump code presented in [Example](ch05s06.html#example-id8 "Example").
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 找到内联函数钩子相当繁琐，这也使得它有些困难。你几乎可以在目标函数体内任何地方安装内联函数钩子，只要你的目标函数体内有足够的空余空间，并且你可以使用各种指令来使指令指针指向你控制的内存区域。换句话说，你不必使用[示例](ch05s06.html#example-id8
    "示例")中展示的精确跳转代码。
- en: What this means is that in order to detect an inline function hook you need
    to scan, more or less, the entire range of executable kernel memory and look through
    each unconditional jump instruction.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着为了检测内联函数钩子，你需要扫描，或多或少，整个可执行内核内存范围，并查看每个无条件跳转指令。
- en: In general, there are two ways to do this. You could look through each function,
    one at a time, to see if any jump instructions pass control to a region of memory
    outside the function's start and end addresses. Alternately, you could create
    an HIDS that works with executable kernel memory instead of files; that is, you
    first scan your memory to establish a baseline and then periodically scan it again,
    looking for differences.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种方法可以做到这一点。你可以逐个查看每个函数，看看是否有跳转指令将控制权传递到函数起始地址和结束地址之外的内存区域。或者，你可以创建一个与可执行内核内存一起工作的
    HIDS，而不是文件；也就是说，你首先扫描你的内存以建立基线，然后定期再次扫描，寻找差异。
- en: Finding Code Byte Patches
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找代码字节修补
- en: Finding a function that has had its code patched is like looking for a needle
    in a haystack, except that you don't know what the needle looks like. Your best
    bet is to create (or use) an HIDS that works with executable kernel memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查找已经修补代码的函数就像在 haystack 中找针，只不过你不知道针是什么样子。你最好的选择是创建（或使用）一个与可执行内核内存一起工作的 HIDS。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In general, it's much less tedious to detect run-time kernel memory patching
    through behavioral analysis.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，通过行为分析来检测运行时内核内存修补要少枯燥得多。
- en: Concluding Remarks
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: As you can probably tell by the lack of example code in this chapter, rootkit
    detection isn't easy. More specifically, developing and writing a generalized
    rootkit detector isn't easy, for two reasons. First, kernel-mode rootkits are
    on a level playing field with detection software (i.e., if something is guarded,
    it can be bypassed, but the reverse is also true—if something is hooked, it can
    be unhooked). ^([[2](#ftn.CHP-7-FN-2)]) Second, the kernel is a very big place,
    and if you don't know specifically where to look, you have to look everywhere.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经从本章中缺少示例代码中看出，rootkit检测并不容易。更具体地说，开发和编写一个通用rootkit检测器并不容易，有两个原因。首先，内核模式rootkit与检测软件处于同一水平（即，如果某物被保护，它可以被绕过，反之亦然——如果某物被钩住，它可以被取消钩住）。^([[2](#ftn.CHP-7-FN-2)])
    第二，内核是一个非常庞大的地方，如果你不知道具体在哪里寻找，你就必须到处寻找。
- en: 'This is probably why most rootkit detectors are designed as follows: First,
    someone writes a rootkit that hooks or patches function A, and then someone else
    writes a rootkit detector that guards function A. In other words, most rootkit
    detectors are of the one-shot fix variety. Therefore, it''s an arms race, with
    the rootkit authors dictating the pace and the anti-rootkit authors constantly
    playing catch-up.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能就是为什么大多数rootkit检测器都是这样设计的：首先，有人编写了一个rootkit，它钩住或修补了函数A，然后另一个人编写了一个rootkit检测器来保护函数A。换句话说，大多数rootkit检测器都是一次性修复的类型。因此，这是一个军备竞赛，rootkit作者设定了节奏，而反rootkit作者则不断追赶。
- en: In short, while rootkit detection is necessary, prevention is the best course.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，虽然rootkit检测是必要的，但预防是最好的方法。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I purposely left prevention out of this book because there are pages upon pages
    dedicated to the subject (i.e., all the books and articles about hardening your
    system), and I don't have anything to add.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意没有在这本书中讨论预防措施，因为关于这个主题的书籍和文章已经有很多页了（即，所有关于加固系统的书籍和文章），而且我也没有什么可以补充的。
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-7-FN-2)]) ² There is an exception to this rule, however, that favors
    detection. You can detect a rootkit through a service, which it provides, that
    can't be cut off; the `inpcb` example in [Finding Hidden Ports](ch07s02.html#finding_hidden_ports
    "Finding Hidden Ports") is an example. Of course, this is not always easy or even
    possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-7-FN-2)]) ² 然而，有一个例外，这个例外有利于检测。你可以通过一个无法切断的服务来检测rootkit，例如在[寻找隐藏端口](ch07s02.html#finding_hidden_ports
    "寻找隐藏端口")中提到的`inpcb`示例。当然，这并不总是容易的，甚至可能不可能。
