- en: Chapter 9. More Filesystems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第九章。更多文件系统
- en: '*Encrypt your hard drive?*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密你的硬盘吗？*'
- en: '*Software RAID can save your day,*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件RAID可以拯救你的日子，*'
- en: '*or ruin your life.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*或毁灭你的生活。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Disk management isn’t
    complicated, but there’s enough material that it gets two chapters. Lucky you!
    In this chapter, we’ll start with how to automatically back up your vital root
    partition to a second disk. Then we’ll explore how OpenBSD can use additional
    memory as disk space via a memory filesystem and how to set that up. Next, we’ll
    access disks formatted for other operating systems, such as NTFS, ext2, and FAT.
    Removable media isn’t difficult to work with, but has its own concerns. If you
    don’t need the actual media, but can work with disk images, you can access those.
    Both topics are covered in this chapter. We’ll also discuss using NFS, as both
    a server and a client. Our final topic is OpenBSD’s disk redundancy and disk encryption
    features.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![磁盘管理](httpatomoreillycomsourcenostarchimages1616079.png) 磁盘管理并不复杂，但内容足够多，以至于有两章。幸运的是！在本章中，我们将从如何自动将你的重要根分区备份到第二个磁盘开始。然后我们将探讨OpenBSD如何通过内存文件系统使用额外的内存作为磁盘空间，以及如何设置它。接下来，我们将访问格式化为其他操作系统的磁盘，如NTFS、ext2和FAT。可移动媒体并不难处理，但有其自己的关注点。如果你不需要实际的媒体，但可以处理磁盘镜像，你可以访问那些。这两个主题都包含在本章中。我们还将讨论使用NFS作为服务器和客户端。我们的最后一个主题是OpenBSD的磁盘冗余和磁盘加密功能。'
- en: Backing Up to the /altroot Partition
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将备份保存到 /altroot 分区
- en: You can lose most of your partitions and still hope to recover the rest of the
    system. If you lose your root filesystem, however, recovery becomes a much more
    difficult task. While you could back up critical files from */etc* and use them
    to restore your system, OpenBSD provides the */altroot* partition as an easy way
    to automatically duplicate the root partition on a second disk.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会失去大部分分区，但仍希望恢复其余的系统。然而，如果你失去了根文件系统，恢复就会变得困难得多。虽然你可以从 */etc* 中备份关键文件并使用它们来恢复系统，但OpenBSD提供了
    */altroot* 分区作为自动在第二个磁盘上复制根分区的一种简单方法。
- en: An emergency root partition on a second disk gives you an easier path to recovery
    in the event of a disk failure. Booting to the second disk lets you pull any data
    off that disk, and possibly even from undamaged partitions on the first disk,
    before replacing the failed disk. There’s no reason to back up your root partition
    to the same disk, however, as the whole disk will probably be unusable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个磁盘上的紧急根分区可以在磁盘故障的情况下为你提供更简单的恢复路径。从第二个磁盘启动让你可以在更换故障磁盘之前，从该磁盘上提取任何数据，甚至可能从第一个磁盘上未损坏的分区中提取数据。然而，没有必要将根分区备份到同一个磁盘，因为整个磁盘可能无法使用。
- en: This backup requires a free disk partition the same size as your root partition,
    located on a different disk. The OpenBSD installer defaults assume that you have
    only one disk. If you have a second disk during installation, you need to use
    a custom install process to create the */altroot* partition, as we did in the
    multiple disk installation in [Chapter 3](ch03.html "Chapter 3. Installation Walk-Through").
    While configuring partitions is easiest during the installation, you can add more
    disks later if needed, as discussed in [Chapter 8](ch08.html "Chapter 8. Disks
    and Filesystems").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个备份需要一个与根分区大小相同的空闲磁盘分区，位于不同的磁盘上。OpenBSD安装程序的默认设置假设你只有一个磁盘。如果你在安装过程中有第二个磁盘，你需要使用自定义安装过程来创建
    */altroot* 分区，就像我们在[第三章](ch03.html "第三章。安装指南")中的多磁盘安装所做的那样。虽然配置分区在安装过程中最容易，但如果需要，你可以在以后添加更多磁盘，如[第八章](ch08.html
    "第八章。磁盘和文件系统")中讨论的那样。
- en: 'Your */altroot* partition needs an */etc/fstab* entry. If you created the partition
    during the install process, that */etc/fstab* entry already exists but has the
    wrong mount type. If you created this partition after installation, you’ll need
    to create an */etc/fstab* entry yourself. The /*altroot* partition needs a mount
    type of `xx`, as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 */altroot* 分区需要一个 */etc/fstab* 条目。如果你在安装过程中创建了分区，那么那个 */etc/fstab* 条目已经存在，但挂载类型不正确。如果你在安装后创建了此分区，你需要自己创建一个
    */etc/fstab* 条目。/*altroot* 分区需要一个 `xx` 类型的挂载类型，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You cannot mount this partition from its */etc/fstab* entry, as `xx` is not
    a valid mount type. (You could run, say, `mount /dev/sd1a /altroot` if you want
    to manually mount this partition.) The daily system maintenance job */etc/daily*
    uses this mount option to identify the root backup partition.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能从这个分区的 */etc/fstab* 条目中挂载它，因为 `xx` 不是一个有效的挂载类型。（如果你想手动挂载这个分区，可以运行，例如，`mount
    /dev/sd1a /altroot`。）日常系统维护任务 */etc/daily* 使用这个挂载选项来识别根备份分区。
- en: To enable the */altroot* backup, add `ROOTBACKUP=1` to your */etc/daily.local*
    file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 */altroot* 备份，请将 `ROOTBACKUP=1` 添加到您的 */etc/daily.local* 文件中。
- en: Memory Filesystems
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存文件系统
- en: In addition to creating partitions on raw disk, OpenBSD lets you create partitions
    in system memory. A *memory filesystem* (*MFS*), or *memory disk*, lives in your
    machine’s RAM, rather than on a physical disk. Reading and writing files to and
    from such a filesystem is much faster than accessing those same files on a spinning
    disk, which makes a memory-backed filesystem a huge optimization for certain applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在原始磁盘上创建分区外，OpenBSD 允许您在系统内存中创建分区。一个 *内存文件系统* (*MFS*)，或 *内存磁盘*，位于您的机器的 RAM
    中，而不是物理磁盘上。在文件系统中读写文件比在旋转磁盘上访问相同的文件要快得多，这使得内存支持的文件系统对于某些应用程序来说是一个巨大的优化。
- en: If MFSs sound too good to be true for high-performance environments, that’s
    because they are. Understand their limits before you implement them everywhere.
    First, RAM does not persist across reboots or shutdowns, so either will erase
    the contents of an MFS. While this might seem obvious, I’ve surprised myself more
    than once by losing a file stored on a filesystem I had forgotten was an MFS.
    Furthermore, if your system crashes, you’ll lose any data stored on an MFS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MFSs 对于高性能环境来说听起来好得令人难以置信，那是因为它们确实如此。在您将它们应用到所有地方之前，先了解它们的限制。首先，RAM 在重启或关机后不会持续存在，因此重启或关机将会清除
    MFS 的内容。虽然这看起来可能很明显，但我多次因为丢失了一个存储在忘记是 MFS 文件系统上的文件而惊讶。此外，如果您的系统崩溃，您将丢失存储在 MFS
    上的任何数据。
- en: You can use an MFS partition as scratch space to rapidly compile, compress,
    decompress, or otherwise manipulate temporary files. I’ve seen news server histories,
    database locks, and other application-specific files stored on MFSs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 MFS 分区作为临时空间，快速编译、压缩、解压缩或其他方式操作临时文件。我见过新闻服务器历史记录、数据库锁和其他存储在 MFS 上的特定应用程序文件。
- en: An MFS works even in situations where the system regularly swaps. The kernel
    retains any information being actively used in memory, while transferring unused
    information to swap space. This is excellent for small partitions like */tmp*,
    in which small, frequently used files can be quickly accessed. Files that are
    less frequently accessed end up in swap space, which gives performance similar
    to accessing a physical disk.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 即使系统经常交换，MFS 也能正常工作。内核保留内存中正在积极使用的任何信息，同时将未使用的信息传输到交换空间。这对于像 */tmp* 这样的小型分区来说非常出色，其中小型、频繁使用的文件可以快速访问。那些不太频繁访问的文件最终会存储在交换空间中，这提供了与访问物理磁盘相似的性能。
- en: 'One last word of caution: Don’t make heavy use of MFSs if you don’t have RAM
    to spare. If you run short on combined memory and swap space, your system will
    perform very poorly.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一句警告：如果您没有多余的 RAM，不要过度使用 MFS。如果您内存和交换空间不足，您的系统将表现非常糟糕。
- en: Creating MFS Partitions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 MFS 分区
- en: 'Create temporary MFS partitions with `mount_mfs(8)`. Like other `mount_` commands,
    `mount_mfs` takes two arguments: the physical device and a mount point. Unlike
    physical disks, memory doesn’t have a device node, so use the device node of the
    system swap space. If you have multiple swap partitions, pick whichever you like.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mount_mfs(8)` 创建临时 MFS 分区。像其他 `mount_` 命令一样，`mount_mfs` 采取两个参数：物理设备和挂载点。与物理磁盘不同，内存没有设备节点，因此使用系统交换空间的设备节点。如果您有多个交换分区，请选择您喜欢的。
- en: 'Here is how you can create a memory-backed filesystem by passing a swap partition,
    */dev/sd0b*, and a desired mount point, */mnt*, as arguments to `mount_mfs`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将交换分区 */dev/sd0b* 和所需的挂载点 */mnt* 作为参数传递给 `mount_mfs` 来创建一个内存支持的文件系统：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The size of this partition will be limited only by the size of your swap partition.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分区的大小将仅限于您的交换分区的大小。
- en: 'You can create smaller memory-backed filesystems, so that you will have memory
    and/or swap space available if you fill the memory disk. Specify the size with
    the `-s` flag and a number of sectors, or with a trailing `b` (bytes), `m` (megabytes),
    or `g` (gigabytes). Here’s how to create a 128MB MFS on */mnt*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建较小的内存支持文件系统，这样当您填满内存磁盘时，您将会有内存和/或交换空间可用。使用 `-s` 标志和扇区数或使用尾随的 `b`（字节）、`m`（兆字节）或
    `g`（千兆字节）来指定大小。以下是如何在 */mnt* 上创建一个 128MB MFS 的方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you request an MFS larger than your system can support, you’ll get a warning
    like `mmap: Cannot allocate memory`. Try again, this time with a more reasonable
    size.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您请求的 MFS 大于您的系统可以支持的，您将收到类似 `mmap: Cannot allocate memory` 的警告。再次尝试，这次使用一个更合理的尺寸。'
- en: Mounting an MFS at Boot
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在引导时挂载 MFS
- en: You can mount an MFS at boot by adding an */etc/fstab* entry. You only need
    a mount point and the partition size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在*/etc/fstab*中添加条目来在启动时挂载MFS。你只需要挂载点和分区大小。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You don’t need to specify a specific swap device; OpenBSD is smart enough to
    let you say the memory disk is generically swap-backed **1**. Just as with any
    other partition, you also need to specify the mount point **2** and the filesystem
    type **3**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要指定特定的交换设备；OpenBSD足够智能，可以让你将内存磁盘通用地指定为交换后置**1**。就像任何其他分区一样，你还需要指定挂载点**2**和文件系统类型**3**。
- en: When dealing with a memory disk, you can use different options than you would
    for a traditional disk **4**. Since a system crash would destroy all files on
    the MFS anyway, you can safely mount an MFS partition as asynchronous using the
    `async` option. You might also want to use `nodev` and `nosuid` mount options
    on this partition. You can specify the size with the `-s` option, but make sure
    that you put an equal sign (`=`) between the `-s` and the size. Because */etc/fstab*
    uses whitespace to separate fields, OpenBSD will think the dump level is 128m
    if you don’t use an equal sign.^([[21](#ftn.id344921)])
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理内存磁盘时，你可以使用与传统磁盘不同的选项**4**。由于系统崩溃会破坏MFS上的所有文件，因此你可以安全地使用`async`选项异步挂载MFS分区。你可能还希望在分区上使用`nodev`和`nosuid`挂载选项。你可以使用`-s`选项指定大小，但请确保在`-s`和大小之间放置一个等号（`=`）。因为*/etc/fstab*使用空白字符来分隔字段，如果你不使用等号，OpenBSD会认为转储级别是128m.^([[21](#ftn.id344921)])
- en: Data on a memory disk is by definition disposable, so don’t back it up **5**.
    Similarly, never use `fsck(8)` with a memory disk at boot **6**. The memory disk
    is created anew at each boot, so it is automatically internally consistent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内存磁盘上的数据按定义是可丢弃的，所以不要备份它**5**。同样，在启动时永远不要使用`fsck(8)`对内存磁盘进行检查**6**。内存磁盘在每次启动时都会重新创建，因此它是自动内部一致的。
- en: Foreign Filesystems
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部文件系统
- en: Any partition that uses a non-FFS filesystem is foreign to OpenBSD. Although
    OpenBSD can access many foreign filesystems, don’t expect it to be seamless.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用非FFS文件系统的分区对OpenBSD来说是外部的。尽管OpenBSD可以访问许多外部文件系统，但不要期望它能够无缝访问。
- en: Support for some filesystems is incomplete. For example, you can mount Microsoft
    NTFS partitions only as read-only. Other filesystems don’t support the full range
    of OpenBSD commands. Because FAT filesystems don’t have any concept of file ownership
    or permissions, commands like `chmod` and `chown` won’t change anything on the
    disk.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对某些文件系统的支持是不完整的。例如，你只能以只读方式挂载Microsoft NTFS分区。其他文件系统不支持OpenBSD命令的全范围。因为FAT文件系统没有任何文件所有权或权限的概念，所以像`chmod`和`chown`这样的命令在磁盘上不会产生任何变化。
- en: Each supported filesystem has its own mount program to handle the vagaries of
    that filesystem. To simplify your life, `mount` can usually recognize supported
    filesystems from the on-disk format and call the correct mount program as needed.
    To mount a foreign filesystem, you need the device node and a mount point. Depending
    on the filesystem, you may also need to know the type of filesystem you’ll be
    mounting.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个支持的文件系统都有自己的挂载程序来处理该文件系统的特性。为了简化你的生活，`mount`通常可以从磁盘格式中识别支持的文件系统，并在需要时调用正确的挂载程序。要挂载外部文件系统，你需要设备节点和一个挂载点。根据文件系统，你可能还需要知道你将要挂载的文件系统类型。
- en: Inodes vs. Vnodes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Inodes vs. Vnodes
- en: 'Before we talk about foreign filesystems, let’s touch on something that confused
    me for a long time: the difference between inodes and vnodes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论外部文件系统之前，让我们先谈谈让我困惑很长时间的事情：inode和vnode之间的区别。
- en: The FFS uses index nodes, or *inodes*, to map blocks of disk that contain data.
    This worked just dandy when hard drives were big, expensive things that no one
    moved between computers. Over the years, however, swapping disks between machines
    has become more popular.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: FFS使用索引节点，或称为*inode*，来映射包含数据的磁盘块。当硬盘还是大而昂贵的物品，没有人会在计算机之间移动它们时，这工作得很好。然而，多年来，在机器之间交换磁盘变得越来越流行。
- en: Although Unix-like systems think in terms of accessing files via inodes, the
    FAT32 filesystem doesn’t use inodes, ext2fs’s inodes don’t map directly onto FFS
    inodes, and CDs use a completely different layout. To access all of these filesystems
    in a consistent way, BSD needed another layer of abstraction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管类Unix系统在inode的概念下访问文件，但FAT32文件系统不使用inode，ext2fs的inode不会直接映射到FFS的inode，CD使用完全不同的布局。为了以一致的方式访问所有这些文件系统，BSD需要另一层抽象。
- en: The virtual node, or *vnode*, is an abstraction layer the kernel uses to access
    all filesystems. Users never manipulate vnodes directly, but you’ll see references
    to them throughout OpenBSD’s documentation. Every tool that reads or writes to
    disks does so through vnodes, which map the requests to the filesystem. When you
    write to an FFS block or inode, the kernel addresses data to a vnode, which in
    turn maps to an inode. When you write to a FAT32 filesystem, the kernel addresses
    data to a vnode mapped to a point in the FAT32 filesystem. You use inodes only
    when dealing with FFS systems, but your data will pass through a vnode when accessing
    any filesystem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟节点，或*vnode*，是内核用来访问所有文件系统的抽象层。用户永远不会直接操作vnode，但你会在OpenBSD的文档中看到对它们的引用。每个读取或写入磁盘的工具都通过vnode进行，将请求映射到文件系统。当你向FFS块或inode写入时，内核将数据地址到一个vnode，该vnode反过来映射到一个inode。当你向FAT32文件系统写入时，内核将数据地址到一个映射到FAT32文件系统中的点的vnode。你只在处理FFS系统时使用inode，但你的数据在访问任何文件系统时都会通过vnode。
- en: Don’t let references to vnodes on non-FFS systems confuse you. They’re part
    of OpenBSD, not the filesystem.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让非FFS系统上的vnode引用让你困惑。它们是OpenBSD的一部分，而不是文件系统的一部分。
- en: Common Foreign Filesystems
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的外国文件系统
- en: Common foreign filesystems include MS-DOS, NTFS, ext2fs, and CD. We’ll look
    at how to access disks formatted for those operating systems with OpenBSD.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的国外文件系统包括MS-DOS、NTFS、ext2fs和CD。我们将探讨如何使用OpenBSD访问为这些操作系统格式化的磁盘。
- en: MS-DOS
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MS-DOS
- en: OpenBSD supports the FAT, FAT16, and FAT32 filesystems. These formats are commonly
    found on flash media, old Microsoft operating systems, and floppy disks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD支持FAT、FAT16和FAT32文件系统。这些格式常见于闪存媒体、旧版Microsoft操作系统和软盘。
- en: To mount a filesystem with a FAT filesystem partition, use `mount_msdos(8)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载具有FAT文件系统分区的文件系统，请使用`mount_msdos(8)`。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Not sure which partition on the disk is the FAT filesystem? Run `disklabel(8)`
    on the drive and see. FAT filesystems are often located on the *i* partition.
    And even if you try inserting your USB drive and mounting its *i* partition, OpenBSD
    will probably figure out that it’s a FAT system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定磁盘上的哪个分区是FAT文件系统，请在驱动器上运行`disklabel(8)`并查看。FAT文件系统通常位于*i*分区。即使你尝试插入USB驱动器并挂载其*i*分区，OpenBSD也可能识别出它是一个FAT系统。
- en: If you work with FAT disks often, you might investigate */usr/ports/sysutils/mtools*,
    a collection of software for working with FAT filesystems without mounting them.
    While `mount_msdos` is quite reliable, mtools offers a more elegant interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用FAT磁盘，可能会调查`/usr/ports/sysutils/mtools`，这是一个用于在不挂载的情况下处理FAT文件系统的软件集合。虽然`mount_msdos`相当可靠，但mtools提供了一个更优雅的界面。
- en: NTFS
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: NTFS
- en: To mount disks formatted for modern Microsoft operating systems, use `mount_ntfs(8)`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载为现代Microsoft操作系统格式化的磁盘，请使用`mount_ntfs(8)`。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As I write this, OpenBSD supports NTFS4 (from Windows NT) and NTFS5 (in Windows
    2000 and XP). Windows Vista and newer systems are not yet supported, but they
    might be by the time you read this.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写这篇文章时，OpenBSD支持NTFS4（来自Windows NT）和NTFS5（在Windows 2000和XP中）。Windows Vista及更新的系统目前尚不支持，但当你阅读这篇文章时可能已经支持了。
- en: If you need to view file attributes specific to the NTFS filesystem, check the
    `mount_ntfs` man page for details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要查看NTFS文件系统的特定文件属性，请查看`mount_ntfs`手册页以获取详细信息。
- en: ext2fs
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ext2fs
- en: To mount ext2fs and ext3fs filesystems, use `mount_ext2fs(8)`. (The one program
    mounts both types of filesystem.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载ext2fs和ext3fs文件系统，请使用`mount_ext2fs(8)`。（该程序可以挂载这两种类型的文件系统。）
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Owing to their shared Unix heritage, the Linux ext2fs and ext3fs filesystems
    support many FFS-like features. Unlike with NTFS, you can safely read and write
    ext2fs and ext3fs disks in OpenBSD. You cannot, however, read ext4fs partitions
    using OpenBSD.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们共享Unix血统，Linux ext2fs和ext3fs文件系统支持许多类似FFS的功能。与NTFS不同，你可以在OpenBSD中安全地读写ext2fs和ext3fs磁盘。然而，你不能使用OpenBSD读取ext4fs分区。
- en: CD
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CD
- en: Compact discs formatted for data use the ISO-9660 filesystem. To mount a CD,
    use `mount_cd9660(8)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数据使用的光盘格式使用ISO-9660文件系统。要挂载CD，请使用`mount_cd9660(8)`。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Mount CDs using either the *a* or *c* partition on the device. If you would
    like to save yourself a few keystrokes, `mount(8)` is very good at automatically
    detecting ISO-9660 filesystems. The device node for a CD is tied to the CD drive,
    not the disk itself, so the node shouldn’t change unless you add another drive.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备的*a*或*c*分区挂载CD。如果你想节省几个按键，`mount(8)`在自动检测ISO-9660文件系统方面非常出色。CD的设备节点绑定到CD驱动器，而不是磁盘本身，因此节点不应该改变，除非你添加另一个驱动器。
- en: If you’re interested in burning a CD, look at `mkhybrid(8)` and `cdio(1)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对烧录CD感兴趣，可以查看`mkhybrid(8)`和`cdio(1)`。
- en: Foreign Filesystem Ownership
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外来文件系统所有权
- en: Most foreign filesystems either have no concept of file ownership or have an
    ownership scheme incompatible with that of Unix-like operating systems. (Notable
    among these filesystems are FAT and NTFS.) The programs that mount these kinds
    of filesystems thoughtfully allow you to specify the ownership of files on the
    filesystem. The `-u` flag lets you specify a file owner, and the `-g` flag lets
    you specify the group.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数外来的文件系统要么没有文件所有权的概念，要么有与类 Unix 操作系统不兼容的所有权方案。（在这些文件系统中，FAT 和 NTFS 是显著的。）挂载这些类型文件系统的程序会周到地允许你指定文件系统的文件所有权。`-u`
    标志允许你指定文件所有者，而 `-g` 标志允许你指定组。
- en: 'For example, here’s how I would mount a FAT filesystem as owned by my account:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我会这样挂载一个属于我账户的 FAT 文件系统：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Some other filesystems use permissions schemes compatible with OpenBSD’s permissions.
    For example, all of the information OpenBSD needs to assign permissions to files
    and directories is contained within an ext2fs filesystem. That doesn’t mean that
    an ext2fs filesystem will perform seamlessly on OpenBSD, however. Though OpenBSD
    will respect the ext2fs disk’s permissions, the user ID numbers probably won’t
    match up between the operating systems.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他文件系统使用与 OpenBSD 权限方案兼容的权限。例如，OpenBSD 需要的所有信息都包含在一个 ext2fs 文件系统中，以分配文件和目录的权限。但这并不意味着
    ext2fs 文件系统在 OpenBSD 上会无缝运行。尽管 OpenBSD 会尊重 ext2fs 磁盘的权限，但用户 ID 数字可能在操作系统之间不匹配。
- en: Removable Media
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移动介质
- en: These days, the removable media you’ll most likely deal with are external hard
    drives, flash drives, and CDs. The CD is the simplest, because you know how to
    use `mount(8)` and `umount(8)`, and you know its device node and filesystem type
    will always be the same. But how do you identify the device name of a removable
    hard drive?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，你可能会处理的可移动介质主要是外置硬盘、闪存驱动器和 CD。CD 是最简单的，因为你知道如何使用 `mount(8)` 和 `umount(8)`，你也知道它的设备节点和文件系统类型始终相同。但你是如何识别可移动硬盘的设备名称的呢？
- en: When you attach a drive to your machine, OpenBSD automatically assigns your
    drive a device node to your console and prints a message to the console. You can
    check the console as you attach the drive, or you can watch your messages log
    by running `tail -f /var/log/messages` before attaching the drive.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将驱动器连接到你的机器时，OpenBSD 会自动为你分配一个设备节点到控制台，并在控制台上打印一条消息。你可以在连接驱动器时检查控制台，或者你可以在连接驱动器之前运行
    `tail -f /var/log/messages` 来查看你的消息日志。
- en: If you frequently use a particular removable disk, you can simplify your routine
    by making an */etc/fstab* entry for it. Here are some sample */etc/fstab* entries
    for a CD and a FAT flash drive.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常使用某个特定的可移动磁盘，你可以通过为它创建一个 */etc/fstab* 条目来简化你的常规操作。以下是一个 CD 和 FAT 闪存驱动器的
    */etc/fstab* 条目的示例。
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can’t use DUIDs for removable media, because the actual media might change.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为可移动介质使用 DUIDs，因为实际的介质可能会改变。
- en: Now you can mount your CD on */cdrom* by entering `mount /cdrom`, and your FAT
    flash drive on */mnt* by entering mount `/mnt`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过输入 `mount /cdrom` 在 */cdrom* 上挂载你的 CD，并通过输入 `mount /mnt` 在 */mnt* 上挂载你的
    FAT 闪存驱动器。
- en: Note that OpenBSD does not create a */cdrom* directory by default; you’ll need
    to create it yourself. You could point both of these at */mnt*, but I like having
    a dedicated CD mount point on my systems, and having two devices share a mount
    point risks concealing one of the filesystems. (Remember that OpenBSD has stackable
    mounts, as discussed in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems").)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，OpenBSD 默认不会创建 */cdrom* 目录；你需要自己创建它。你可以将这两个都指向 */mnt*，但我喜欢在我的系统上有一个专门的 CD
    挂载点，并且让两个设备共享挂载点可能会隐藏其中一个文件系统。（记住，OpenBSD 有可堆叠的挂载，如第 8 章所述。[第 8 章](ch08.html "第
    8 章。磁盘和文件系统")。）
- en: Mounting Filesystem Images
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载文件系统镜像
- en: You can mount a disk image and access the image just as you would a disk partition.
    This is very useful for those times you want to extract a few files from an ISO
    but don’t want to bother burning the image to physical media. The trick to mounting
    a disk image is attaching the image to a device node so that you can use the proper
    `mount` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以挂载一个磁盘镜像，就像访问一个磁盘分区一样访问镜像。这在你想从 ISO 中提取一些文件但不想麻烦将镜像烧录到物理介质时非常有用。挂载磁盘镜像的技巧是将镜像附加到设备节点，这样你就可以使用正确的
    `mount` 命令。
- en: OpenBSD uses the `vnconfig(8)` program to attach disk images to device nodes.
    (Remember that a vnode is an abstraction layer between the kernel and a filesystem.)
    Use `vnconfig` to “wire” vnodes between a file and a device node, and then access
    them through OpenBSD’s */dev/svnd* devices. Depending on the disk image type,
    the image might have MBR partitions, disklabel partitions, or just a filesystem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD使用`vnconfig(8)`程序将磁盘镜像连接到设备节点。（记住，vnode是内核和文件系统之间的抽象层。）使用`vnconfig`在文件和设备节点之间“连接”vnode，然后通过OpenBSD的*/dev/svnd*设备访问它们。根据磁盘镜像类型，镜像可能包含MBR分区、disklabel分区，或者只是一个文件系统。
- en: The default kernel has four vnode devices. If you need to mount more than four
    disk images simultaneously, edit your kernel binary using `config(8)`’s `-e` option,
    as discussed in [Chapter 18](ch18.html "Chapter 18. Kernel Configuration").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认内核有四个vnode设备。如果你需要同时挂载超过四个磁盘镜像，请使用`config(8)`的`-e`选项编辑你的内核二进制文件，如第18章（[Chapter
    18](ch18.html "Chapter 18. Kernel Configuration")）中所述。
- en: Attaching Vnode Devices to Disk Images
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Vnode设备连接到磁盘镜像
- en: 'The `vnconfig(8)` command takes two arguments: the device node you want to
    use and the disk image you want to mount.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`vnconfig(8)`命令接受两个参数：你想要使用的设备节点和你想要挂载的磁盘镜像。'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that this example uses the *c* partition of the device. This allows you
    to treat the disk image as a whole disk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此示例使用设备的*c*分区。这允许你将磁盘镜像视为整个磁盘。
- en: Suppose you have an ISO image named *install52.iso* that you would like to mount.
    First, use `vnconfig` to attach this image to vnode device 0.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为*install52.iso*的ISO镜像，你想将其挂载。首先，使用`vnconfig`将此镜像连接到vnode设备0。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can then use `mount` to attach the vnode to an */mnt* directory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用`mount`将vnode连接到*/mnt*目录。
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: OpenBSD’s `mount(8)` is smart enough to recognize this as a CD filesystem and
    mount it as such. If you’re mounting a disk image that uses a less detectable
    filesystem, you need to use the specific `mount` command for that filesystem.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD的`mount(8)`足够智能，能够识别这是一个CD文件系统并将其以这种方式挂载。如果你要挂载使用不太易检测的文件系统的磁盘镜像，你需要使用该文件系统的特定`mount`命令。
- en: Detaching Vnode Devices from Images
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从镜像中分离Vnode设备
- en: 'Vnode devices attached to a file remain attached until specifically disconnected,
    and you can attach a vnode device to only one file at a time. To disconnect the
    vnode device from the file, use the `-u` flag with `vnconfig`. For example, to
    disconnect the vnode device located at *vnd0c*, run this command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到文件的vnode设备会一直保持连接状态，直到明确断开连接。你一次只能将一个vnode设备连接到一个文件。要断开vnode设备与文件的连接，请使用`vnconfig`的`-u`标志。例如，要断开位于*vnd0c*的vnode设备，请运行以下命令：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can now attach this vnode device to another file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将这个vnode设备连接到另一个文件。
- en: Using the full path to the device is optional in `vnconfig`. If you know the
    device name, you can use it without the leading */dev*, as in the preceding example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vnconfig`中使用设备的完整路径是可选的。如果你知道设备名称，你可以使用它而不需要前面的*/dev*，就像前面的例子中那样。
- en: Basic NFS Setup
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本NFS设置
- en: NFS allows one machine to access files on another machine. NFS has its origins
    in UNIX, but today appears in most operating systems, including those from Microsoft
    and Apple. OpenBSD supports NFS versions 1 through 3 as both a client and a server.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: NFS允许一台机器访问另一台机器上的文件。NFS起源于UNIX，但今天它出现在大多数操作系统中，包括来自Microsoft和Apple的系统。OpenBSD作为客户端和服务器支持NFS的1到3版本。
- en: Entire books can be—and have been—written about NFS. We won’t go into the intimate
    details of NFS, but rather focus on getting a basic NFS share working on OpenBSD.
    Configuring NFS the first time can be intimidating, but after setting up a file
    share or two, you’ll find it straightforward.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NFS可以写整本书——实际上也确实有人这么做了。我们不会深入探讨NFS的细节，而是专注于在OpenBSD上使基本的NFS共享工作。第一次配置NFS可能会让人感到害怕，但配置一个或两个文件共享后，你会发现它非常直接。
- en: If you have a complicated NFS environment—involving multiple versions of multiple
    operating systems—or if you want to share a directory among hundreds of active
    clients, you should do further research, but even a basic setup will help to simplify
    parts of your job.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个复杂的多版本多操作系统的NFS环境，或者你想要在数百个活跃客户端之间共享一个目录，你应该进行进一步的研究，但即使是一个基本的设置也会帮助你简化工作的一部分。
- en: NFS works on the client/server model. One computer, the server, offers filesystems
    to other computers. The server is *exporting* a filesystem, and the filesystems
    on offer are called *exports*. NFS clients can mount exports in a manner almost
    identical to that used to mount local filesystems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NFS基于客户端/服务器模型。一台计算机（服务器）向其他计算机提供文件系统。服务器正在*导出*一个文件系统，提供的文件系统称为*导出*。NFS客户端可以以几乎与挂载本地文件系统相同的方式挂载导出。
- en: One important thing to remember about NFS is that it is *stateless*, which means
    that NFS does not track the condition of a connection. You can reboot an NFS server,
    and the client won’t throw a fit. The client cannot access files on the server
    while the server is down, but once the server returns, the client will pick up
    right where things left off. Other network filesystems are not always so resilient.
    Statelessness causes its own problems as well. For example, clients cannot know
    when a file they are currently reading has been modified by another client.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NFS的一个重要事项是它是无状态的，这意味着NFS不会跟踪连接的状态。你可以重启NFS服务器，客户端不会出现异常。当服务器关闭时，客户端无法访问服务器上的文件，但一旦服务器恢复，客户端会从上次停止的地方继续。其他网络文件系统并不总是如此有弹性。无状态性也会带来它自己的问题。例如，客户端无法知道他们当前正在读取的文件是否已被其他客户端修改。
- en: If you’re just learning NFS (or OpenBSD’s implementation of NFS), check */var/log/messages*
    for NFS-related error messages. If you’ve repeatedly reconfigured your NFS server
    as part of learning, and things just don’t work correctly, reboot your NFS server
    and/or client. NFS is complicated, and sometimes starting with a clean stack clears
    up a lot of problems. Once you understand how all the pieces fit together, a reboot
    to resolve problems should never be necessary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始学习NFS（或OpenBSD对NFS的实现），请检查*/var/log/messages*以查找与NFS相关的错误信息。如果你在学习过程中反复重新配置NFS服务器，但事情仍然无法正确工作，请重启NFS服务器和/或客户端。NFS很复杂，有时从头开始清理堆栈可以解决很多问题。一旦你了解了所有部件如何组合在一起，重启以解决问题通常就不再必要了。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The NFS protocol has evolved over the years, and every operating system has
    implemented a slightly different version of NFS. Other BSDs, Illumos, Linux, Apple,
    Microsoft, and most other operating systems can work with OpenBSD’s NFS support,
    but each may require an occasional tweak for specific environments. If you’re
    having trouble getting NFS to work with OpenBSD and another operating system,
    read `mount_nfs(8)` and feed the details to your favorite search engine. The odds
    that someone else has experienced this problem before are good.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NFS协议在多年中不断发展，每个操作系统都实现了略有不同的NFS版本。其他BSD、Illumos、Linux、Apple、Microsoft以及大多数其他操作系统都可以与OpenBSD的NFS支持一起工作，但每个可能都需要针对特定环境进行偶尔的调整。如果你在尝试让NFS与OpenBSD和另一个操作系统一起工作时遇到问题，请阅读`mount_nfs(8)`并将详细信息输入到你喜欢的搜索引擎中。其他人之前可能已经遇到过这个问题，可能性很大。
- en: The OpenBSD NFS Server
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenBSD NFS服务器
- en: 'By default, OpenBSD includes all the programs necessary to act as an NFS server,
    but you must turn it on. The NFS server requires three daemons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenBSD包含了作为NFS服务器所需的所有程序，但你必须将其启用。NFS服务器需要三个守护进程：
- en: '****`portmap(8)`****. Maps requests for remote procedure call (RPC) services
    to TCP/IP port numbers.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`portmap(8)`****. 将远程过程调用（RPC）服务的请求映射到TCP/IP端口号。'
- en: '****`mountd(8)`****. Listens for incoming NFS mount requests.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`mountd(8)`****. 监听传入的NFS挂载请求。'
- en: '****`nfsd(8)`****. Processes requests for filesystem actions.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`nfsd(8)`****. 处理文件系统操作的请求。'
- en: The `portmap(8)` daemon has its own *rc.conf* flag, as it can be used by many
    other RPC services. The `mountd(8)` and `nfsd(8)` daemons are controlled by a
    single *rc.conf* flag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`portmap(8)`守护进程有自己的*rc.conf*标志，因为它可以被许多其他RPC服务使用。`mountd(8)`和`nfsd(8)`守护进程由单个*rc.conf*标志控制。'
- en: 'Add the following entries to *rc.conf.local* to start all three processes at
    boot time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下条目添加到*rc.conf.local*以在启动时启动所有三个进程：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can start these three daemons from scripts in */etc/rc.d*. If you try to
    start these daemons now, however, they won’t run. You must configure at least
    one export before the NFS server daemons will start.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*/etc/rc.d*中的脚本启动这三个守护进程。然而，如果你现在尝试启动这些守护进程，它们将不会运行。在NFS服务器守护进程启动之前，你必须至少配置一个导出。
- en: Exporting Filesystems
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出文件系统
- en: 'To export filesystems, define which clients may mount which filesystems and/or
    directories in */etc/exports*. This file takes a separate line for each disk device
    on the server and each client or group of clients that can access that disk device.
    Each line has up to three parts:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出文件系统，定义哪些客户端可以挂载哪些文件系统以及/或目录在`/etc/exports`中。此文件为服务器上的每个磁盘设备以及可以访问该磁盘设备的每个客户端或客户端组占用单独的一行。每一行最多有三个部分：
- en: Directories or partitions to be exported
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要导出的目录或分区
- en: Options on that export
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那个出口的选项
- en: Clients permitted to connect
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许连接的客户端
- en: Of the three components of an */etc/exports* entry, only the directory is mandatory.
    The directory path cannot contain symlinks, double dots, or single dots.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/exports`条目的三个组成部分中，只有目录是必需的。目录路径不能包含符号链接、双点或单点。
- en: 'If I wanted to export my home directory as read-write to every host on the
    Internet, I could use an *exports* line containing only the path to my */home*
    folder:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想将我的家目录以读写方式导出到互联网上的每个主机，我可以使用只包含我的`/home`文件夹路径的*exports*行：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This perfectly valid (but perfectly foolish) entry contains no options and no
    host restrictions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完全有效（但非常愚蠢）的条目没有任何选项和主机限制。
- en: To export multiple directories that reside on the same partition, separate them
    with a single space.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出位于同一分区的多个目录，用单个空格将它们分开。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can list any number of directories on one line, as long as they exist on
    the same partition.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一行中列出任意数量的目录，只要它们位于同一分区上。
- en: 'NFS clients can mount only exactly the directory specified in */etc/exports*.
    If you export */home/mwlucas*, clients can attach only */home/mwlucas* to a mount
    point. They cannot mount, say, */home/mwlucas/bin* instead. If you would like
    to export an entire partition, you can do that, too. If you want to let clients
    mount any directories beneath that mount point, specify the mount point and the
    `-alldirs` option. You cannot use `-alldirs` with a subdirectory; it must be the
    actual mount point. This next entry lets anyone mount any directory in */home*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NFS客户端只能挂载在`/etc/exports`中指定的确切目录。如果你导出`/home/mwlucas`，客户端只能将`/home/mwlucas`附加到挂载点。他们不能挂载，比如，`/home/mwlucas/bin`。如果你想导出整个分区，你也可以这样做。如果你想允许客户端挂载挂载点下任何目录，指定挂载点和`-alldirs`选项。你不能在子目录中使用`-alldirs`；它必须是实际的挂载点。此条目允许任何人挂载`/home`中的任何目录：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To export multiple partitions, or directories from multiple partitions, specify
    them on separate lines.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出多个分区或来自多个分区的目录，请在单独的行中指定它们。
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Any time you change */etc/exports*, you must signal `mountd` to reread its
    configuration. You can do this by passing the `reload` argument to the `mountd`
    startup script:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你更改`/etc/exports`时，都必须通知`mountd`重新读取其配置。你可以通过将`reload`参数传递给`mountd`启动脚本来完成此操作：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While these simple mounts give you an idea of how NFS works, they’re very insecure.
    To make an intelligent export, you need a few options and an access list. Let’s
    take a look at some of NFS’s more commonly used options.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些简单的挂载让你了解了NFS的工作方式，但它们非常不安全。要创建一个智能导出，你需要一些选项和访问列表。让我们看看NFS的一些常用选项。
- en: Read-Only Mounts
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只读挂载
- en: 'You might want to share files without worrying about whether your underlings
    will delete, modify, or otherwise undo your hard work. You can share files as
    read-only by using the `-ro` option. Here, I offer my home directory to all the
    computers in the world, but as a read-only share:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望分享文件时无需担心下属是否会删除、修改或以其他方式撤销你的辛勤工作。你可以通过使用`-ro`选项将文件以只读方式共享。在这里，我将我的家目录提供给世界上所有的计算机，但作为一个只读共享：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is slightly more intelligent than offering my NFS exports to the entire
    world read-write, but only slightly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这比向整个世界提供我的NFS导出读写权限稍微聪明一点，但只是稍微聪明一点。
- en: NFS and Users
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NFS和用户
- en: You already know that file ownership and permissions are tied to UID numbers.
    Unlike many other file-sharing protocols, NFS also uses UIDs to identify file
    ownership. For example, on my test server, my account `mwlucas` uses the UID 1000;
    on my client, my `mwlucas` account also uses the UID 1000\. This simplifies my
    life, as I don’t need to worry too much about file ownership; files owned by `mwlucas`
    on the server are owned by `mwlucas` on the client.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道文件所有权和权限与UID数字相关联。与许多其他文件共享协议不同，NFS也使用UID来标识文件所有权。例如，在我的测试服务器上，我的账户`mwlucas`使用UID
    1000；在我的客户端，我的`mwlucas`账户也使用UID 1000。这简化了我的生活，因为我无需过多担心文件所有权；服务器上`mwlucas`拥有的文件在客户端也是由`mwlucas`拥有的。
- en: On a small network with only a few users and machines,^([[22](#ftn.id330714)])
    you can probably keep UID numbers synchronized without a problem by assigning
    the same UID to the same user on all of your systems. But on a large network,
    with more than one user and where users have root on their own machines, file
    ownership can quickly become a serious problem. The best way around this is to
    maintain a central repository of authorized users via LDAP or Kerberos.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有少数用户和机器的小型网络中，^([[22](#ftn.id330714)]) 你可能通过在所有系统上为同一用户分配相同的UID来无问题地保持UID号码同步。但在大型网络中，如果有多个用户，并且用户在自己的机器上有root权限，文件所有权可能会迅速成为一个严重问题。解决这个问题最好的办法是通过LDAP或Kerberos维护一个授权用户的中央存储库。
- en: Regardless of how you manage your users, NFS handles the root account differently.
    An NFS server cannot trust root on client machines to execute commands or write
    files as root on the server; if that were the case, a breach on one NFS client
    would mean a breach on the NFS server. By default, requests from root on the client
    are mapped to UID and GID 32767 (also known as `nobody`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何管理你的用户，NFS对root账户的处理方式都不同。NFS服务器不能信任客户端机器上的root来以root身份在服务器上执行命令或写入文件；如果是这样，一个NFS客户端的漏洞就意味着NFS服务器的漏洞。默认情况下，来自客户端的root请求被映射到UID和GID
    32767（也称为`nobody`）。
- en: 'If you want to map root to a specific user rather than the generic UID `nobody`,
    use the `-maproot` option and specify either a username or UID. Here, we map incoming
    requests from root on the client to the user `nfsroot` on the server:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将root映射到特定的用户而不是通用的UID `nobody`，请使用`-maproot`选项并指定一个用户名或UID。在这里，我们将来自客户端的root请求映射到服务器上的`nfsroot`用户：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can give the mapped root user a list of groups that the remote root account
    can access by specifying them after the username, separated by colons. Here, we
    give the client’s root user access to the server as the user `nfsroot` and the
    groups `customers` and `webmasters`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在用户名后指定它们，并用冒号分隔来给映射的root用户一个远程root账户可以访问的组列表。在这里，我们给客户端的root用户以`nfsroot`用户和`customers`、`webmasters`组的权限访问服务器：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to explicitly remove the mapped root user from all groups, put
    a colon after the username or UID, as in this example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要明确地从所有组中移除映射的root用户，在用户名或UID后放置一个冒号，如下例所示：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Suppose you want all the NFS clients, regardless of username on the client
    system, to use a single user ID on the NFS server. The `-mapall` option allows
    you to do this. This option uses the same format as the `-maproot` option. Here,
    we map all NFS users to the username `nfsuser` on the server:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你希望所有NFS客户端，无论客户端系统上的用户名如何，都使用NFS服务器上的单个用户ID。`-mapall`选项允许你这样做。此选项使用与`-maproot`选项相同的格式。在这里，我们将所有NFS用户映射到服务器上的用户名`nfsuser`：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Correct control of user access will help protect your NFS server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正确控制用户访问将有助于保护你的NFS服务器。
- en: Permitted Clients
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许的客户端
- en: By default, every host can access your NFS server. For many reasons, that’s
    not a great idea. You can restrict the clients permitted to access your NFS server
    by listing their IP addresses at the end of the export entry.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个主机都可以访问你的NFS服务器。由于许多原因，这并不是一个好主意。你可以通过在导出条目末尾列出它们的IP地址来限制允许访问你的NFS服务器的客户端。
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can also specify clients by their hostname, but if the server has a DNS
    failure, it won’t allow any clients access.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过主机名指定客户端，但如果服务器有DNS故障，它将不允许任何客户端访问。
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To permit access to an entire network, use the `-network` and `-mask` options.
    The next example permits access to the addresses 192.0.2.0 through 192.0.2.15,
    using a subnet mask. (If you’re not familiar with subnet masks, read [Chapter 11](ch11.html
    "Chapter 11. Overview of TCP/IP").)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许访问整个网络，请使用`-network`和`-mask`选项。以下示例使用子网掩码允许访问地址192.0.2.0到192.0.2.15。（如果你不熟悉子网掩码，请阅读[第11章](ch11.html
    "第11章。TCP/IP概述")。）
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When setting up your NFS server, I recommend you grant access to only the hosts
    who need it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置你的NFS服务器时，我建议你只授予需要访问的主机权限。
- en: Multiple Exports for One Partition
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个分区多个导出
- en: 'You can have only one line for each combination of partition and permitted
    clients. If */home* is a single partition, you can’t have an exports file that
    looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个分区和允许的客户端的组合，你只能有一行。如果*/home*是一个单独的分区，你不能有一个看起来像这样的导出文件：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If two directories are located on the same partition, NFS will not allow you
    to export them to the same host using different permissions. You can, however,
    export directories on one partition to different hosts with different permissions,
    as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个目录位于同一分区上，NFS不允许您使用不同的权限将它们导出到同一主机。然而，您可以像这里所示的那样，将一个分区的目录导出到不同的主机，使用不同的权限。
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can export directories on a partition to different hosts with different
    permissions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将分区的目录导出到不同的主机，使用不同的权限。
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Only by combining IP restrictions and controlling user permissions can you can
    effectively control NFS server access.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过结合IP限制和控制用户权限，您才能有效地控制NFS服务器访问。
- en: NFS Clients
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS客户端
- en: 'OpenBSD’s NFS client doesn’t need any daemons or configuration. Just `mount`
    the remote filesystem. Here, I mount my home directory from my server `treble`
    on */mnt*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD的NFS客户端不需要任何守护进程或配置。只需`mount`远程文件系统。在这里，我将我的服务器`treble`上的家目录挂载到`/mnt`：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When mounting remote filesystems over NFS, enter the hostname or IP address,
    a colon, and the directory. Because I have the same UID on both the client and
    server, I can access, alter, remove, and add files in */mnt* exactly as if I were
    dealing with files on a local filesystem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过NFS挂载远程文件系统时，输入主机名或IP地址，一个冒号，然后是目录。因为我客户端和服务器上的UID相同，所以我可以像处理本地文件系统上的文件一样访问、修改、删除和添加`/mnt`中的文件。
- en: Verify your mount with `df(1)` or `mount(8)`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`df(1)`或`mount(8)`验证您的挂载。
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The NFS-mounted directory shows up like any other mount point.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过NFS挂载的目录显示得像任何其他挂载点一样。
- en: 'To mount an NFS share automatically at boot, or just record it for future convenience,
    you may use an */etc/fstab* entry. If your system might not have DNS available
    to it at boot time, use an IP address for the NFS server. The following example
    specifies two *fstab* entries: one using a hostname and one using an IP address:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在启动时自动挂载NFS共享，或者只是为了方便将来使用，您可以使用`/etc/fstab`条目。如果您的系统在启动时可能没有DNS可用，请使用NFS服务器的IP地址。以下示例指定了两个`fstab`条目：一个使用主机名，一个使用IP地址：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Give all NFS partitions dump and `fsck` numbers of `0`. Do not run `fsck` or
    `dump` on an NFS mount, as those programs require raw disk access that NFS doesn’t
    provide.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有NFS分区设置为`dump`和`fsck`的数字为`0`。不要在NFS挂载点上运行`fsck`或`dump`，因为这些程序需要原始磁盘访问，而NFS不提供这种访问。
- en: Use any other mount options you like. The OpenBSD folks recommend using `noexec`,
    `nodev`, and `nosuid` “when applicable.” I recommend `noauto` on NFS partitions
    that aren’t required for normal server operation, so that an unavailable NFS server
    does not hang your machine’s boot process.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的任何其他挂载选项。OpenBSD社区建议在适用时使用`noexec`、`nodev`和`nosuid`。我建议在不需要用于正常服务器操作的非NFS分区上使用`noauto`，这样不可用的NFS服务器就不会挂起您的机器的启动过程。
- en: NFS performance depends a great deal on your hardware, your local network, the
    clients and servers involved, the phase of the moon, and any number of other factors.
    If you’re not happy with your NFS performance, read `mount_nfs(8)` and experiment
    with using TCP or UDP, the read and write sizes, and perhaps the timeout. If you
    need a complicated NFS environment, you should definitely invest some time in
    learning more about NFS.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: NFS性能在很大程度上取决于您的硬件、本地网络、涉及的客户端和服务器、月亮的相位以及无数其他因素。如果您对NFS性能不满意，请阅读`mount_nfs(8)`并尝试使用TCP或UDP、读写大小以及可能的时间超时进行实验。如果您需要一个复杂的NFS环境，您绝对应该花些时间学习更多关于NFS的知识。
- en: Software RAID
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件RAID
- en: The Redundant Array of Independent Disks (RAID) technology has become the standard
    way of mirroring hard drives within a machine or combining multiple hard drives
    to form one giant partition. In many types of RAID arrays, if one disk fails,
    the system can continue to run without data loss until you replace the failed
    disk or a second disk fails.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 红外独立磁盘阵列（RAID）技术已成为在机器内镜像硬盘或组合多个硬盘以形成一个巨大分区的标准方式。在许多类型的RAID阵列中，如果一个硬盘故障，系统可以在您更换故障硬盘或第二个硬盘故障之前继续运行而不会丢失数据。
- en: You can get RAID from the hardware or have the operating system perform the
    RAID operations. Hardware RAID controllers seem nice, but are in reality just
    decent disk controllers that run special software. Using the `softraid(4)` driver,
    OpenBSD can do the same thing, letting you build RAID arrays out of plain disks.
    You can do just about everything you can with a hardware RAID controller with
    a bunch of disks and OpenBSD’s RAID management program `bioctl(8)` and the `softraid(4)`
    software RAID driver.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从硬件中获得RAID，或者让操作系统执行RAID操作。硬件RAID控制器看起来很棒，但实际上只是运行特殊软件的不错的磁盘控制器。使用`softraid(4)`驱动程序，OpenBSD可以做到同样的事情，让您可以使用普通磁盘构建RAID数组。您可以使用与硬件RAID控制器一样多的磁盘和OpenBSD的RAID管理程序`bioctl(8)`以及`softraid(4)`软件RAID驱动程序来做几乎所有的事情。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to managing software RAID, OpenBSD’s `bioctl(8)` can manage most
    sorts of hardware RAID controllers. If you’re planning to use hardware RAID, reading
    the `bioctl` manual is definitely worth your time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了管理软件RAID之外，OpenBSD的`bioctl(8)`还可以管理大多数类型的硬件RAID控制器。如果您计划使用硬件RAID，阅读`bioctl`手册绝对值得您花时间。
- en: RAID Types
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RAID类型
- en: 'OpenBSD supports the following RAID configurations:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD支持以下RAID配置：
- en: '**RAID-0, or** striping'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**RAID-0，或**条带化'
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This type is not redundant. It requires at least two disks of the same size,
    and data is shared between the disks to increase partition size and throughput.
    You can use RAID-0 to combine five 4TB disks into a 20TB virtual disk, but be
    warned: If one hard drive in the array fails, you’ll lose all your data. RAID-0
    is useful when you need a really big filesystem, but it’s more vulnerable than
    a single disk because it provides multiple points of failure (or as one of my
    quasi-literary, quasi-humorous friends once said, “RAID-0 gives a whole new meaning
    to the phrase one disk to rule them all”). The size of a RAID-0 array is the size
    of all the hard drives combined.'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种类型不是冗余的。它至少需要两个相同大小的磁盘，数据在磁盘之间共享以增加分区大小和提高吞吐量。您可以使用RAID-0将五个4TB磁盘组合成一个20TB的虚拟磁盘，但请注意：如果数组中的任何一个硬盘驱动器失败，您将丢失所有数据。RAID-0在您需要非常大的文件系统时很有用，但它比单个磁盘更脆弱，因为它提供了多个故障点（或者正如我的一位半文学、半幽默的朋友曾经说过，“RAID-0给‘一磁盘统治一切’这个短语赋予了全新的意义’）。RAID-0数组的大小是所有硬盘驱动器大小的总和。
- en: '**RAID-1, or** mirroring'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**RAID-1，或**镜像'
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With this type, the contents of one disk are duplicated on another. Mirroring
    requires at least two disks of the same size, and the size of a RAID-1 array is
    equal to the size of the smallest drive in the array. I use mirroring to protect
    all vital data, as it gives even a cheap desktop-chassis server some measure of
    data protection. OpenBSD’s software RAID fully supports this level.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种类型中，一个磁盘的内容被复制到另一个磁盘上。镜像至少需要两个相同大小的磁盘，RAID-1数组的大小等于数组中最小驱动器的大小。我使用镜像来保护所有重要数据，因为它甚至给廉价的桌面机箱服务器提供了一定程度的数据保护。OpenBSD的软件RAID完全支持这一级别。
- en: '**RAID-4, or** striping data across disks, with a dedicated parity disk'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**RAID-4，或**跨磁盘条带化数据，并使用专用奇偶校验磁盘'
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This type requires at least three disks of the same size. Parity data lets a
    RAID array recover data on missing disks, and RAID-4 stores that parity data on
    a specific disk. This means that you can lose any one of the disks without losing
    data. As I write this, `bioctl`’s RAID-4 support is experimental. Hopefully this
    support will be complete before the book reaches you, but if not, you’ll need
    to use a hardware RAID card to get RAID-4.
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种类型至少需要三个相同大小的磁盘。奇偶校验数据允许RAID阵列在丢失磁盘的情况下恢复数据，而RAID-4将奇偶校验数据存储在特定的磁盘上。这意味着您可以在不丢失数据的情况下丢失任何一个磁盘。当我写这段话的时候，`bioctl`的RAID-4支持是实验性的。希望这本书到达您手中之前，这种支持已经完善，但如果不是这样，您将需要使用硬件RAID卡来获得RAID-4。
- en: '**RAID-5, or** striping with parity shared across all drives'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**RAID-5，或**跨所有驱动器共享奇偶校验的条带化'
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the current industry standard for redundancy. Parity data provides data
    redundancy—the loss of a single drive doesn’t destroy any data. It requires at
    least three disks of the same size. Unlike RAID-4, RAID-5 shares the parity data
    across all the drives simultaneously. While throughput isn’t as good as that of
    RAID-0, a RAID-5 array can simultaneously serve multiple I/O requests. The size
    of your RAID-5 array is the combined size of all but one of your hard drives.
    If you have five 4TB drives, the array will be 16TB ((5 – 1) × 4TB). Like RAID-4,
    RAID-5 support in `bioctl` is incomplete and experimental. I hope it will be complete
    before you read this, but if not, you’ll need to use a hardware RAID card for
    RAID-5.
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是当前行业标准的冗余。奇偶校验数据提供数据冗余——单个驱动器的丢失不会破坏任何数据。它需要至少三个相同大小的磁盘。与RAID-4不同，RAID-5同时将奇偶校验数据共享到所有驱动器上。虽然吞吐量不如RAID-0，但RAID-5阵列可以同时处理多个I/O请求。你的RAID-5阵列的大小是除了一个硬盘之外所有硬盘的总大小。如果你有五个4TB的硬盘，阵列将是16TB（（5
    - 1）× 4TB）。与RAID-4一样，`bioctl`中的RAID-5支持是不完整和实验性的。我希望在你阅读此内容之前它将完成，但如果不是，你将需要使用硬件RAID卡来使用RAID-5。
- en: According to the RAID standards, each of these levels requires disks of the
    same size. That said, OpenBSD’s `softraid` uses partitions rather than disks.
    You can use disks of different sizes, but your RAID array will use only an amount
    of space on each disk equal to the smallest drive. If you want to mirror a 1TB
    drive and a 2TB drive, your mirror will offer only 1TB of space. The excess space
    on the larger drive is wasted.^([[23](#ftn.id367975)])
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RAID标准，这些级别中的每一个都需要相同大小的磁盘。但话虽如此，OpenBSD的`softraid`使用分区而不是磁盘。你可以使用不同大小的磁盘，但你的RAID阵列将只使用每个磁盘上与最小驱动器相等的空间。如果你想镜像一个1TB的驱动器和2TB的驱动器，你的镜像将只提供1TB的空间。较大驱动器上的多余空间将被浪费.^([[23](#ftn.id367975)])
- en: In addition to the standard RAID methods, `softraid` also allows you to encrypt
    your data across all disks in a RAID array (as described in [Encrypted Disk Partitions](ch09.html#encrypted_disk_partitions
    "Encrypted Disk Partitions")). It also lets you *concatenate* disks. Concatenated
    disks are just run together to create one large virtual disk. You could concatenate
    two 500GB disks and a 1TB disk to create a single 2TB partition. These disks don’t
    need to be the same size, but as with RAID-0, they are vulnerable. Damage to any
    one disk will completely wreck the virtual disk and lose all data. As the process
    for creating a concatenated disk closely resembles that of creating a RAID-0 disk,
    we’ll cover it in [Creating softraid Devices](ch09.html#creating_softraid_devices
    "Creating softraid Devices").
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的RAID方法之外，`softraid`还允许你加密RAID阵列中所有磁盘上的数据（如[加密磁盘分区](ch09.html#encrypted_disk_partitions
    "加密磁盘分区")中所述）。它还允许你*连接*磁盘。连接的磁盘只是连续运行以创建一个大的虚拟磁盘。你可以连接两个500GB的磁盘和一个1TB的磁盘来创建一个2TB的分区。这些磁盘不需要相同的大小，但与RAID-0一样，它们是脆弱的。任何单个磁盘的损坏都将完全破坏虚拟磁盘并丢失所有数据。由于创建连接磁盘的过程与创建RAID-0磁盘的过程非常相似，我们将在[创建softraid设备](ch09.html#creating_softraid_devices
    "创建softraid设备")中介绍它。
- en: Preparing Disks for softraid
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为softraid准备磁盘
- en: The `softraid` software RAID device builds its virtual disks out of disklabel
    partitions. To use a disk in a `softraid` array, prepare it just as you would
    a disk for a regular filesystem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`softraid`软件RAID设备使用disklabel分区构建其虚拟磁盘。要在`softraid`阵列中使用磁盘，就像为常规文件系统中的磁盘准备一样准备它。'
- en: On i386 and amd64, disks underlying a `softraid` device need an MBR partition.
    To mark a whole disk with a single MBR partition, run `fdisk -i` on the disk.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在i386和amd64上，`softraid`设备下的磁盘需要一个MBR分区。要使用单个MBR分区标记整个磁盘，请在磁盘上运行`fdisk -i`。
- en: 'Suppose you have five disks to use in a RAID array: `sd2`, `sd3`, `sd4`, `sd5`,
    and `sd6`. You’ll need to prepare each of them as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有五个磁盘要用于RAID阵列：`sd2`、`sd3`、`sd4`、`sd5`和`sd6`。你需要按照以下方式准备每个磁盘：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Repeat this for every disk in your array.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对阵列中的每个磁盘重复此操作。
- en: 'Once you’ve added an MBR to all your disks, you’ll need to put a disklabel
    partition on each disk. I tend to use partition letter *p* (the last available
    partition letter) for `softraid` devices. Here’s how to set up a disk for `softraid`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为所有磁盘添加了MBR，你需要在每个磁盘上放置一个disklabel分区。我倾向于使用分区字母*p*（最后一个可用的分区字母）为`softraid`设备设置分区。以下是设置`softraid`磁盘的方法：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we add a partition with `a` **1** and assign it partition letter `p`
    **2**. Instead of our usual filesystem type of 4.2BSD, we assign a filesystem
    type of `RAID` **3**. Then we quit **4** and let `disklabel` write the changes
    to the disklabel partition **5**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `a` **1** 添加一个分区，并分配分区字母 `p` **2**。我们不是使用我们常用的 4.2BSD 文件系统类型，而是分配一个
    `RAID` **3** 文件系统类型。然后我们退出 **4** 并让 `disklabel` 将更改写入磁盘标签分区 **5**。
- en: 'If you have multiple identical disks, you can use `disklabel` to save this
    disk’s configuration, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多块相同的磁盘，你可以使用 `disklabel` 来保存这块磁盘的配置，如下所示：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This saves the label on disk `sd2` to the file *disklabel.sd2.raid*. You can
    make `disklabel(8)` copy this partitioning to other disks, and `disklabel` will
    assign each disk a unique DUID as it copies. This saves you from needing to walk
    through the interactive editor for each disk. Let’s apply this disklabel to each
    partition:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把磁盘 `sd2` 上的标签保存到文件 *disklabel.sd2.raid* 中。你可以使用 `disklabel(8)` 将这种分区复制到其他磁盘，`disklabel`
    在复制时会为每个磁盘分配一个唯一的 DUID。这可以节省你为每个磁盘通过交互式编辑器的需要。让我们将这个 disklabel 应用到每个分区：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Disks `sd2` through `sd6` are now ready for assimilation into `softraid`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘 `sd2` 到 `sd6` 现在已准备好被整合到 `softraid` 中。
- en: Creating softraid Devices
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 softraid 设备
- en: Use `bioctl(8)` to drag disks into a software RAID. You’ll need the disk partitions
    you want to include in the RAID. OpenBSD software RAID arrays are named `softraid`,
    followed by a number. Use the `-c` argument to give a RAID type, and `-l` to give
    the partitions, and end with the name of the `softraid` you’re creating.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bioctl(8)` 将磁盘拖入软件 RAID。你需要包含在 RAID 中的磁盘分区。OpenBSD 软件RAID 数组以 `softraid`
    开头，后面跟着一个数字。使用 `-c` 参数来指定 RAID 类型，使用 `-l` 来指定分区，并以你创建的 `softraid` 的名称结束。
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have five disk partitions—`sd2p`, `sd3p`, `sd4p`, `sd5p`, and `sd6p`—to
    add to a `softraid` device. To build a RAID-5 device out of these partitions,
    run this command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五个磁盘分区——`sd2p`、`sd3p`、`sd4p`、`sd5p` 和 `sd6p`——要添加到 `softraid` 设备中。要从这些分区构建一个
    RAID-5 设备，请运行以下命令：
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The response indicates that we’ve successfully created a RAID-5 device **1**,
    and it’s available as device `/dev/sd7` **2**. On a blank RAID disk, which you
    need to prepare just as you would any other new disk, run `fdisk -i sd7` and `disklabel`
    to create MBR and OpenBSD partitions, use `newfs` to create a filesystem on the
    new partitions, and you’re ready to go. (See the instructions for adding a new
    disk in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems") for details.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 响应表明我们已成功创建了一个 RAID-5 设备 **1**，并且它作为设备 `/dev/sd7` **2** 可用。在一个空白 RAID 磁盘上，你需要像其他任何新磁盘一样准备它，运行
    `fdisk -i sd7` 和 `disklabel` 来创建 MBR 和 OpenBSD 分区，使用 `newfs` 在新分区上创建文件系统，然后你就可以开始了。（有关添加新磁盘的说明，请参阅[第
    8 章](ch08.html "第 8 章。磁盘和文件系统")的详细说明。）
- en: You could have made this a RAID-0, RAID-1, or RAID-4 device by choosing a different
    `-c` option. The tricky one is a concatenated `softraid`. To dump all the disks
    together into a single concatenated virtual partition, use `-c c`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选择不同的 `-c` 选项将这个设备做成 RAID-0、RAID-1 或 RAID-4 设备。复杂的是串联的 `softraid`。要将所有磁盘一起放入一个单一的串联虚拟分区中，请使用
    `-c c`。
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: softraid Status
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: softraid 状态
- en: To check the health of each device in a RAID array, give `bioctl` the device
    name of the `softraid` device.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 RAID 数组中每个设备的健康状态，给 `bioctl` 提供一个 `softraid` 设备的设备名。
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We see that the five drives are in use, all assembled into a RAID-5 virtual
    drive. Everything here is healthy. Anything that doesn’t look roughly like this
    indicates a problem.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，五个驱动器正在使用中，全部组装成一个 RAID-5 虚拟驱动器。这里的一切看起来都很健康。任何看起来不太像这样的事物都表明存在问题。
- en: Identifying Failed softraid Volumes
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别失败的 softraid 卷
- en: 'If you have a RAID-1, RAID-4, or RAID-5 `softraid` volume, you can lose a drive
    and not lose your data. `bioctl` tells you if a drive fails. Here, one of the
    drives in my `softraid` volume has failed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 RAID-1、RAID-4 或 RAID-5 `softraid` 卷，即使丢失一个驱动器也不会丢失你的数据。`bioctl` 会告诉你哪个驱动器失败了。这里，我的
    `softraid` 卷中的一个驱动器已经失败了：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Looking closely at this, I can see that drives `sd2`, `sd3`, `sd4`, and `sd6`
    are still available and in use. All my data should still be intact, but I need
    to replace `sd5` before another disk fails.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我可以看到驱动器 `sd2`、`sd3`、`sd4` 和 `sd6` 仍然可用并且在使用中。我的所有数据应该仍然完好无损，但在另一个磁盘失败之前，我需要更换
    `sd5`。
- en: Rebuilding Failed softraid Volumes
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重建失败的 softraid 卷
- en: As of this writing, you cannot rebuild a failed `softraid` RAID-4 or RAID-5
    device. You must back up your data, replace the failed drive, delete the `softraid`
    device, re-create the filesystem, and restore from backup. You can, however, rebuild
    a RAID-1 device.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到我写这篇文章的时候为止，你无法重建失败的`softraid` RAID-4或RAID-5设备。你必须备份你的数据，更换失败的驱动器，删除`softraid`设备，重新创建文件系统，并从备份中恢复。然而，你可以重建RAID-1设备。
- en: 'Let’s look at replacing a disk in a RAID-1 device. Here’s what a healthy, three-disk
    `softraid` mirror might look like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在RAID-1设备中更换磁盘。一个健康的三磁盘`softraid`镜像可能看起来是这样的：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that this RAID device has device node `sd5` **1** and includes the partitions
    *sd2p*, *sd3p*, and *sd4p* **2**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个RAID设备具有设备节点`sd5`[1]并且包括分区*sd2p*、*sd3p*和*sd4p*[2]。
- en: We replace two disks and reboot this machine. Suddenly, the *softraid* device
    looks very different.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更换了两个磁盘并重新启动这台机器。突然，*softraid*设备看起来非常不同。
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Partitions *sd3p* and *sd4p* are missing. That’s because the underlying disks
    have been replaced.^([[24](#ftn.id433352)]) Prepare the replacement disks for
    software RAID, as discussed in [Preparing Disks for softraid](ch09.html#preparing_disks_for_softraid
    "Preparing Disks for softraid"). Then run `bioctl`, using the `-R` flag to specify
    the disk to replace in the `softraid` device.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 分区*sd3p*和*sd4p*丢失。这是因为底层磁盘已被更换。[^[[24](#ftn.id433352)]) 准备替换磁盘以用于软件RAID，如[为softraid准备磁盘](ch09.html#preparing_disks_for_softraid
    "为softraid准备磁盘")中所述。然后运行`bioctl`，使用`-R`标志指定`softraid`设备中要更换的磁盘。
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you check the status of the device using `bioctl`, you’ll see the disk status
    now says “Rebuilding.”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`bioctl`检查设备的状况，你会看到磁盘状态现在显示为“重建中。”
- en: If you have a mirror with more than two disks, you must rebuild each disk separately.
    Rebuild the first disk, and then rebuild the second disk.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含两个以上磁盘的镜像，你必须单独重建每个磁盘。先重建第一个磁盘，然后重建第二个磁盘。
- en: Deleting softraid Devices
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除softraid设备
- en: 'To remove a `softraid` device from your system, pass `bioctl` the `-d` flag
    and the device name for the `softraid` device. Here’s how to remove the RAID-5
    device we just created:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的系统中移除`softraid`设备，向`bioctl`传递`-d`标志和`softraid`设备的设备名。以下是如何移除我们刚刚创建的RAID-5设备的方法：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Warning
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Once you delete the RAID device, you can’t get it back unless you re-create
    it and restore your data from backup.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你删除了RAID设备，除非你重新创建它并从备份中恢复数据，否则你无法恢复它。
- en: Reusing softraid Disks
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复使用softraid磁盘
- en: '`softraid` writes metadata at the beginning of the disks it uses. You need
    to overwrite this metadata before you can use the disks in another `softraid`
    device. Overwrite the first megabyte or so of the disk with `dd(1)`.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`softraid`在其使用的磁盘开头写入元数据。在使用这些磁盘作为另一个`softraid`设备之前，你需要覆盖这些元数据。使用`dd(1)`覆盖磁盘的前一兆字节左右。'
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This erases the MBR partitions, any initial disklabels, and any filesystem information
    on the disk. You can now reuse these disks in `softraid` devices as normal disks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将擦除MBR分区、任何初始磁盘标签以及磁盘上的任何文件系统信息。你现在可以像普通磁盘一样在`softraid`设备中重复使用这些磁盘。
- en: Booting from a softraid Device
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从softraid设备启动
- en: The `softraid` feature is still in development. Eventually, you’ll be able to
    use the installer to build a software RAID device, install OpenBSD on that device,
    and run a full RAID configuration out of the box. But as I write this, you’ll
    need to jump through some hoops to make that happen. Rather than document a specific
    procedure that will change as OpenBSD completes `softraid` development, I’m going
    to tell you to search the Internet and the *misc@OpenBSD.org* archives for the
    most recent instructions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`softraid`功能仍在开发中。最终，你将能够使用安装程序构建一个软件RAID设备，在该设备上安装OpenBSD，并直接运行完整的RAID配置。但在我写这篇文章的时候，你需要跳过一些步骤才能实现这一点。而不是记录一个会随着OpenBSD完成`softraid`开发而变化的特定过程，我将告诉你去互联网和*misc@OpenBSD.org*存档中搜索最新的说明。'
- en: Encrypted Disk Partitions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密磁盘分区
- en: Sometimes I can see the future. When someone says, “I’ve encrypted my hard drive!”
    I have a psychic vision of them saying “I’ve lost all my data!” While encrypting
    a hard drive partition is warranted in some cases, most of the time, it’s just
    pretentious. In this section, I will do you the courtesy of assuming that you
    understand when you truly need disk encryption if you will do me the courtesy
    of not complaining to me when you lose your data.^([[25](#ftn.id458279)])
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我能看到未来。当有人说，“我已经加密了我的硬盘！”我会有一种通灵的感觉，他们会在说“我丢失了所有数据！”虽然在某些情况下加密硬盘分区是合理的，但大多数时候，这只是虚荣。在本节中，我将假设你理解何时真正需要磁盘加密，如果你在我丢失数据时不对我说抱怨，我将对你表示礼貌。
- en: Creating Encrypted Partitions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建加密分区
- en: OpenBSD includes disk encryption as a `bioctl(8)` option—specifically, like
    a RAID discipline. Where disk activity would normally be passed through a RAID
    discipline, here they pass through an encryption discipline. The encrypted disk
    even shows up as a `softraid` device. Much like the support for RAID-5, support
    for encrypted filesystems is experimental. Although it *should* work, don’t be
    shocked if some features are not yet included or if it eats your entire disk.
    Keep good backups. Reread the previous paragraph. And again—*please* don’t complain
    to me when it doesn’t work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD将磁盘加密作为`bioctl(8)`选项——具体来说，就像RAID纪律一样。在磁盘活动通常通过RAID纪律传递的地方，这里它们通过加密纪律传递。加密磁盘甚至显示为`softraid`设备。与对RAID-5的支持类似，对加密文件系统的支持是实验性的。尽管它*应该*工作，但如果某些功能尚未包含或如果它吃掉了你的整个磁盘，请不要感到惊讶。做好备份。重新阅读上一段。再次——*请*不要在我面前抱怨它不起作用。
- en: 'Under OpenBSD, an encrypted volume can include only a single partition. Use
    the RAID type `C` to specify an encrypted volume. Here’s, how to create an encrypted
    volume on the *sd4p* partition:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD下，加密卷只能包含单个分区。使用RAID类型`C`来指定加密卷。以下是如何在`sd4p`分区上创建加密卷的步骤：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When prompted **1**, enter a passphrase twice. A good passphrase is several
    words long, and includes a mix of characters, symbols, numbers, punctuation, and
    whitespace. The passphrase is the secret code used to encrypt and decrypt data,
    so the longer and more varied it is, the better. Remember this passphrase; you
    must enter it again to recover your data. Once you’ve entered your passphrase
    twice, `bioctl` creates the encrypted disk device. In this case, it has created
    encrypted disk `softraid0` as `disk sd5`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示**1**时，请输入密码短语两次。一个好的密码短语应该由多个单词组成，并包含字符、符号、数字、标点符号和空格的混合。密码短语是用于加密和解密数据的秘密代码，因此它越长、越多样化，就越好。记住这个密码短语；你必须再次输入它才能恢复你的数据。一旦你两次输入了你的密码短语，`bioctl`就会创建加密的磁盘设备。在这种情况下，它创建了一个加密磁盘`softraid0`作为`disk
    sd5`。
- en: Using Encrypted Partitions
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用加密分区
- en: Do not mount this new disk yet! Instead, use `fdisk` to check our new, encrypted
    partition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 不要立即挂载这个新磁盘！相反，使用`fdisk`来检查我们的新加密分区。
- en: '[PRE49]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The underlying disk is blank, and our `fdisk` output looks like garbage, but
    this disk is now an encrypted volume.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 基础磁盘是空的，我们的`fdisk`输出看起来像垃圾，但这个磁盘现在是一个加密卷。
- en: Now that the encrypted disk exists, create an MBR partition and add disklabel
    partitions, just as when you add any other disk. Then you can mount your encrypted
    device partition using the device node—again, just as with any other disk.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加密磁盘已经存在，创建MBR分区并添加disklabel分区，就像添加任何其他磁盘一样。然后你可以使用设备节点挂载你的加密设备分区——再次，就像任何其他磁盘一样。
- en: To unmount the decrypted partition, destroy the `softraid` device by passing
    `bioctl` the `-d` argument.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载解密分区，通过传递`bioctl`的`-d`参数来销毁`softraid`设备。
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To anyone who doesn’t have the passphrase, this partition now looks like random
    garbage.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有密码短语的人来说，这个分区现在看起来像随机的垃圾。
- en: Automatic Decryption
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动解密
- en: If you have an encrypted partition, presumably you don’t want OpenBSD to automatically
    decrypt and mount it when the system boots. (The whole point of an encrypted partition
    is that only a person who has the passphrase can access the encrypted data.) Still,
    I’m not one to tell you not to shoot yourself in the foot, so if you must automatically
    decrypt the partition, you can do so.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个加密分区，你大概不希望OpenBSD在系统启动时自动解密和挂载它。（加密分区的全部意义在于只有拥有密码短语的人才能访问加密数据。）尽管如此，我不是那种告诉你不要自杀的人，所以如果你必须自动解密分区，你可以这样做。
- en: 'First, create a file containing your passphrase. Give ownership of this file
    to root and set the permissions to `600` (read-write by owner; no access by other
    users), and then give this file to `bioctl(8)` with the `-p` flag. In this example,
    the encrypted disk is created as */dev/sd5* and there is a partition on */dev/sd5a*.
    I’ve stored my passphrase in the file */etc/passphrase*, so I could run something
    like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含你的密码文件的文件。将此文件的拥有权赋予root，并设置权限为`600`（所有者可读写；其他用户无访问权限），然后使用`-p`标志将此文件传递给`bioctl(8)`。在这个例子中，加密硬盘被创建为*/dev/sd5*，并且有一个分区在*/dev/sd5a*上。我已经将我的密码存储在文件*/etc/passphrase*中，所以我可以运行类似以下这样的命令：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Adding this to */etc/rc.securelevel* will mount this encrypted partition at
    boot.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将此内容添加到*/etc/rc.securelevel*中将在启动时挂载这个加密分区。
- en: You should now have a good idea of how to manage OpenBSD disks and filesystems.
    Next, we’ll look at some of OpenBSD’s special security features.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对如何管理 OpenBSD 硬盘和文件系统有了很好的了解。接下来，我们将探讨一些 OpenBSD 的特殊安全功能。
- en: '* * *'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[21](#id344921)]) I don’t know what a dump level of 128m means, other than
    “not what I want.”
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#id344921)]) 我不知道128m的转储级别意味着什么，除了“不是我所希望的。”
- en: ^([[22](#id330714)]) How many users do I mean by “a few?” When synchronizing
    UIDs across all of your systems begins to really, *really* annoy you, you no longer
    have a few users.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#id330714)]) “几个用户”我是指多少个？当你在所有系统间同步UID开始真正、真正地让你感到烦恼时，你就不再只有几个用户了。
- en: ^([[23](#id367975)]) You could add a non-RAID partition in the unused space
    on the larger drive, but that would do terrible things to your system’s performance.
    Just buy more hard drives, you cheapskate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#id367975)]) 你可以在较大驱动器上未使用的空间中添加一个非RAID分区，但这会对你的系统性能造成极大的破坏。只是买更多的硬盘，你这个吝啬鬼。
- en: ^([[24](#id433352)]) If you need to force an error on a hard disk, removing
    the disk from the machine will certainly do it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#id433352)]) 如果需要在硬盘上强制产生错误，从机器上移除硬盘肯定可以做到。
- en: '^([[25](#id458279)]) Not that I can help you—all I can do is say “I told you
    so.” On a related note: You can get tired of anything, no matter how pleasant,
    if you have to do it often enough.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#id458279)]) 我帮不上什么忙——我所能做的就是说我“早就告诉你了。”顺便说一句：无论多么愉快的事情，如果你经常做，你都会感到厌倦。
