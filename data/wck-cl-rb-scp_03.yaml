- en: Chapter 3. LI(U)NIX SYSTEM ADMINISTRATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 LI(U)NIX系统管理
- en: '![LI(U)NIX SYSTEM ADMINISTRATION](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![LI(U)NIX系统管理](../Images/00001.jpg)'
- en: 'No computing system runs optimally straight out of the box. Whether you need
    to adjust security settings, add users, define permissions, or install applications—there
    is always something left to do. Once the system is configured exactly how you
    want it, the next task is maintaining the system until an upgrade is needed. Then
    the cycle starts all over again. This cycle is known as system administration.
    Administrators well versed in Linux or Unix system administration understand the
    power and flexibility that simple scripts can add to the geek''s toolbox. Forget
    about the mundane tasks: Let the scripts deal with them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有计算系统是直接从盒子里运行得最优的。无论你需要调整安全设置、添加用户、定义权限还是安装应用程序——总有事情要做。一旦系统配置得完全符合你的要求，接下来的任务就是维护系统，直到需要升级。然后这个周期又从头开始。这个周期被称为系统管理。精通Linux或Unix系统管理的管理员了解简单的脚本可以为极客的工具箱增添多少力量和灵活性。忘记那些日常任务吧：让脚本来处理它们。
- en: Fixing Bad Filenames
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复错误的文件名
- en: Fixing Bad Filenames
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复错误的文件名
- en: fixFilename.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fixFilename.rb
- en: When it comes to naming files, endless possibilities exist. There can be short
    abbreviated filenames, long descriptive filenames, or even random filenames that
    don't make sense. Filenames can be too long for some systems or contain special,
    reserved characters for other systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文件命名时，存在无限的可能性。可以是简短的缩写文件名，也可以是长描述性文件名，甚至是不合逻辑的随机文件名。某些系统中的文件名可能过长，而其他系统中的文件名可能包含特殊或保留字符。
- en: Working in *a graphical user interface*, or *GUI*, environment can lead to bad
    habits, as far as naming conventions go. The GUI environment can deal with almost
    any character used in a filename, but when these filenames are accessed at the
    command line, they create a lot of headaches. The idea behind this script is to
    remember the poor souls who still use the command line … myself included. For
    all of the uncertainty of naming files, a simple script can help clean up and
    organize them. This script will rename files according to a specific set of rules.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图形用户界面*（GUI）环境中工作可能会导致在命名约定方面养成坏习惯。GUI环境可以处理文件名中使用的几乎所有字符，但当这些文件名在命令行中访问时，它们会带来很多麻烦。这个脚本的目的是为了记住那些仍然使用命令行的人……包括我自己。对于所有关于文件命名的不可确定性，一个简单的脚本可以帮助清理和组织它们。这个脚本将根据一组特定的规则重命名文件。
- en: When I think of weird filenames, picture and music files always come to mind.
    If you're sharing photographs from that special vacation or showing off your band's
    latest jam session, the naming scheme will be different from person to person,
    and it may clash with the recipient's operating system. The script I'm about to
    show you will take each filename and format it based on your specifications. This
    script is highly customizable and super efficient, so find some files with questionable
    filenames and send them through. You'll be pleasantly surprised when the script
    is done.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想起奇怪的文件名时，图片和音乐文件总是浮现在脑海中。如果你正在分享那次特别的度假照片或展示你乐队最新的即兴演奏会，命名方案会因人而异，并且可能与接收者的操作系统冲突。我将向您展示的脚本将根据您的指定格式化每个文件名。这个脚本非常可定制且效率极高，所以找到一些文件名可疑的文件并将它们通过这个脚本处理。当脚本完成后，你会感到非常惊喜。
- en: The Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`` #!/usr/bin/ruby   unless ARGV[0]      puts "Usage: ruby fixFilename.rb <filename.ext>"
         puts "Example: ruby fixFilename.rb \''How to (make) 20% more on $500.pdf\''"
         exit  end  ![](../Images/00002.jpg) old_filename = ARGV[0]   unless File.exist?(old_filename)''
         puts "#{old_filename} does not exist.  Please try again." ![](../Images/00003.jpg)  
       exit  end  ![](../Images/00004.jpg) name = File.basename(old_filename, ".*")
     ext = File.extname(old_filename)  ![](../Images/00005.jpg) replacements = {  /;/
    => "-",                  /\s/ => "_",                  /\''\`/ => "=",       
              /\&/ => "_and_",                  /\$/ => "dollar_",               
      /%/ => "_percent",                  /[\(\)\[\]<>]/ => ""                }    replacements.each
    do |orig, fix|       name.gsub!(orig,fix)  end  ![](../Images/00006.jpg) File.rename(old_filename,
    name + ext)  ![](../Images/00007.jpg) puts "#{old_filename} ---> #{name + ext}"``'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`` #!/usr/bin/ruby   unless ARGV[0]      puts "用法：ruby fixFilename.rb <filename.ext>"
         puts "示例：ruby fixFilename.rb ''如何（制作）在$500上赚取20%的更多利润.pdf''"      exit  end  ![](../Images/00002.jpg) old_filename
    = ARGV[0]   unless File.exist?(old_filename)''      puts "#{old_filename}不存在。请重试。"
    ![](../Images/00003.jpg)      exit  end  ![](../Images/00004.jpg) name = File.basename(old_filename,
    ".*")  ext = File.extname(old_filename)  ![](../Images/00005.jpg) replacements
    = {  /;/ => "-",                  /\s/ => "_",                  /\''\`/ => "=",
                     /\&/ => "_and_",                  /\$/ => "dollar_",         
            /%/ => "_percent",                  /[\(\)\[\]<>]/ => ""             
      }    replacements.each do |orig, fix|       name.gsub!(orig,fix)  end  ![](../Images/00006.jpg) File.rename(old_filename,
    name + ext)  ![](../Images/00007.jpg) puts "#{old_filename} ---> #{name + ext}"``'
- en: Running the Code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script runs with one command-line argument, the filename to scan and potentially
    fix:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本通过一个命令行参数运行，即要扫描和可能修复的文件名：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Results
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The resulting output will show the old filename and what it was converted to.
    For this example, I made a bogus file with some nasty characters in it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出将显示旧文件名以及它被转换成了什么。对于这个例子，我创建了一个包含一些讨厌字符的虚假文件。
- en: '``*`How to (make) 20% more on $500.pdf ---> How_to_make_20_percent_more_on_dollar_500.pdf`*``'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`如何（制作）在$500上赚取20%的更多利润.pdf ---> How_to_make_20_percent_more_on_dollar_500.pdf`*``'
- en: How It Works
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: As mentioned in "Running the Code," this script relies on the user passing a
    filename as an argument to the script ![](../Images/00002.jpg). The script, in
    turn, attaches to the file and ensures that it actually exists. If a user mistyped
    some of the filename, instead of crashing, the script will inform the user that
    something is amiss with the input and exit cleanly ![](../Images/00003.jpg).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如“运行代码”部分所述，此脚本依赖于用户将文件名作为参数传递给脚本 ![](../Images/00002.jpg)。脚本反过来会连接到文件并确保它确实存在。如果用户输入了文件名中的某些错误，脚本不会崩溃，而是会通知用户输入有误并干净地退出
    ![](../Images/00003.jpg)。
- en: Next, a new variable called `name` is created so that you can tweak the original
    filename without disrupting it. The filename is stripped from its extension ![](../Images/00004.jpg).
    I isolated the extension so the file will still function properly in the off chance
    that one of the filters was set up in a way that could accidentally alter an extension.
    In the script's current configuration, it will only alter the filename.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建了一个名为`name`的新变量，这样您就可以在不破坏原始文件名的情况下调整它。文件名被从其扩展名中剥离 ![](../Images/00004.jpg)。我单独隔离了扩展名，以防万一某个过滤器被设置为意外更改扩展名，这样文件仍然可以正常工作。在脚本当前配置中，它只会更改文件名。
- en: The script uses a hash data structure named `replacements` to hold all of the
    invalid characters and their corresponding acceptable values. A code block containing
    the `gsub` method will be used to make all of the substitutions. The end result
    is that `name` will be returned with all occurrences of the specified pattern
    substituted by a replacement. Each line of the hash focuses on a specific "bad
    character" ![](../Images/00005.jpg). First is the semicolon, which is a reserved
    character in Linux and must be escaped. Instead of dealing with the semi-colon,
    the script substitutes it with a dash. All whitespace in the filename is turned
    into underscores, which look similar to whitespace. Backticks (on American keyboards
    this key is on the upper-left side, immediately to the left of the number 1, shared
    with the tilde) and apostrophes are turned into equal signs. Symbols such as &,
    %, and $ are converted to words. Finally, the name is checked for any parentheses,
    curly brackets, and angle brackets. Any found are removed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本使用名为 `replacements` 的哈希数据结构来存储所有无效字符及其对应的可接受值。将使用包含 `gsub` 方法的代码块来进行所有替换。最终结果是
    `name` 将返回，其中所有指定的模式都将被替换。哈希的每一行都专注于特定的“坏字符”！[](../Images/00005.jpg)。首先是分号，它是
    Linux 中的保留字符，必须进行转义。而不是处理分号，脚本将其替换为破折号。文件名中的所有空白都被转换为下划线，它们看起来与空白相似。反引号（在美国键盘上，此键位于数字
    1 的左上角，与波浪号共享）和撇号被转换为等号。符号如 &、% 和 $ 被转换为单词。最后，检查名称中是否有任何括号、花括号和尖括号。任何找到的都将被移除。
- en: The last step in the script renames the file. Using the `rename` method, the
    script gives the file our brand new operating-system friendly name ![](../Images/00006.jpg).
    As a courtesy to the user, the old filename is shown, as well as what it is being
    transformed into ![](../Images/00007.jpg).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一步是重命名文件。使用 `rename` 方法，脚本将文件重命名为我们全新的操作系统友好名称！[](../Images/00006.jpg)。为了对用户表示友好，脚本显示了旧文件名以及它将被转换成什么！[](../Images/00007.jpg)。
- en: Hacking the Script
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: Further expansion on this script is really easy because of the way each rule
    is created. If you have a better way of representing the percentage sign, then
    you can easily edit the corresponding line of code. Additionally, there is always
    the possibility of adding prefixes or suffixes to each file. The script is flexible,
    so try some variations to see how you like them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个规则都是这样创建的，因此对这个脚本的进一步扩展非常容易。如果您有更好的表示百分号的方法，那么您可以轻松地编辑相应的代码行。此外，始终有可能为每个文件添加前缀或后缀。脚本很灵活，所以尝试一些变体，看看您是否喜欢。
- en: Adding a User
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户
- en: Adding a User
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户
- en: addUser.rb
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addUser.rb
- en: Since the advent of GUIs, adding users to Unix and Linux systems has become
    much easier. You fill out the boxes, click Add, and you're done. Before GUIs,
    and still too often today, system administrators had to manually create each user
    account on a system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自从图形用户界面（GUIs）的出现以来，向 Unix 和 Linux 系统添加用户变得容易得多。您填写框格，点击添加，就完成了。在 GUIs 之前，以及今天仍然很常见的情况下，系统管理员必须手动在系统上创建每个用户账户。
- en: While the task of manually creating user accounts for small organizations can
    be trivial, big businesses with thousands of users are a different story. Manually
    inputting account information into a computer system for 1,000 users is time consuming,
    tedious, and, most importantly, a waste of human productivity. This script automates
    the addition of user accounts to a system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动为小型组织创建用户账户的任务可能微不足道，但对于拥有数千用户的庞大企业来说，情况就不同了。手动输入 1,000 个用户的账户信息到计算机系统中是耗时、乏味且最重要的是，浪费人力生产力的。此脚本自动化了向系统添加用户账户的过程。
- en: '* * *'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Warning
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*This script is platform dependent, so ensure that your systems are compatible
    with the commands to avoid corrupting your user files*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*此脚本依赖于平台，因此请确保您的系统与命令兼容，以避免损坏您的用户文件*。'
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The Code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` #!/usr/bin/env ruby   #Using the command ''useradd'' with various arguments   print
    "Enter new username: " ![](../Images/00002.jpg)    user_name = gets.chomp   #Add
    the groups to the user ![](../Images/00003.jpg)    print "\nEnter primary group:
    "  gname = gets.chomp  add_user = "-g #{gname} "   while gname      print "\nEnter
    next group (return blank line when finished): "      gname = gets.chomp      break
    if gname.empty?      add_user << "-G #{gname} "  end  ![](../Images/00004.jpg) #Define
    which program will start when the user logs in  puts "\n\n\n[1] Bourne Again Shell
    (bash)"  puts "[2] Korn Shell (ksh)"  puts "[3] Z Shell (zsh)"  puts "[4] C Shell
    (csh)"  print "Which shell do you prefer (default bash)? "   sh_num = gets.chomp.to_i
     shell = case sh_num      when 1 then ''/bin/bash''      when 2 then ''/bin/ksh''
         when 3 then ''/bin/zsh''      when 4 then ''/bin/csh''      else ''/bin/bash''
     end   add_user << "-s #{shell} "   #Define home directory  add_user << "-d /home/#{user_name}
    "   #Define starting folder  add_user << "-m #{user_name}"   #Add user to the
    system and look at return value ![](../Images/00005.jpg) if(system("useradd #{add_user}"))
         puts "\n\nSuccessfully added: #{user_name}"  else      puts "\n\nUnable to
    add: #{user_name}"  end`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '` #!/usr/bin/env ruby   #使用带有各种参数的''useradd''命令   print "Enter new username:
    " ![](../Images/00002.jpg)    user_name = gets.chomp   #添加用户组 ![](../Images/00003.jpg)  
     print "\nEnter primary group: "  gname = gets.chomp  add_user = "-g #{gname}
    "   while gname      print "\nEnter next group (return blank line when finished):
    "      gname = gets.chomp      break if gname.empty?      add_user << "-G #{gname}
    "  end  ![](../Images/00004.jpg) #定义用户登录时启动的程序   puts "\n\n\n[1] Bourne Again
    Shell (bash)"  puts "[2] Korn Shell (ksh)"  puts "[3] Z Shell (zsh)"  puts "[4]
    C Shell (csh)"  print "Which shell do you prefer (default bash)? "   sh_num =
    gets.chomp.to_i  shell = case sh_num      when 1 then ''/bin/bash''      when
    2 then ''/bin/ksh''      when 3 then ''/bin/zsh''      when 4 then ''/bin/csh''
         else ''/bin/bash''  end   add_user << "-s #{shell} "   #定义家目录   add_user
    << "-d /home/#{user_name} "   #定义起始文件夹   add_user << "-m #{user_name}"   #将用户添加到系统并查看返回值
    ![](../Images/00005.jpg) if(system("useradd #{add_user}"))      puts "\n\nSuccessfully
    added: #{user_name}"  else      puts "\n\nUnable to add: #{user_name}"  end`'
- en: Running the Code
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'You can add users to your Unix-type system by following the prompts given by
    the script. Run it by typing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过遵循脚本给出的提示将用户添加到你的Unix类型系统中。通过输入以下命令来运行它：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'This script will result in a user being added to your system with the configuration
    specified by you. You will see the following lines if the script was successful:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将导致一个用户被添加到你的系统中，其配置由你指定。如果脚本成功，你会看到以下行：
- en: '``Successfully added: *`steve`*``'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '``Successfully added: *`steve`*``'
- en: 'If you are able to change the password of the new account, you''ll know the
    script actually worked. I ran this script on a Gentoo Linux computer and all of
    my accounts were disabled upon creation if no password was specified. Simply type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够更改新账户的密码，那么你就知道脚本实际上已经工作了。我在Gentoo Linux计算机上运行了这个脚本，并且如果没有指定密码，所有账户在创建时都被禁用了。只需输入：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and enter your chosen password twice. Next, you can switch users, log in with
    your new credentials, and take a break. If the script was unsuccessful in creating
    the account, you will receive an error message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 并输入你选择的密码两次。接下来，你可以切换用户，使用你的新凭据登录，然后休息一下。如果脚本在创建账户时失败，你将收到一个错误消息。
- en: How It Works
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: You will no longer need to remember each flag or read through the `man` pages
    to simply add a user. The `useradd` command is a clean way to add users to a system,
    but the flags and options can be a bit cryptic. Also, adding more than a handful
    of accounts can become tedious. This script is fully interactive and will allow
    anyone with basic system knowledge to easily add users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不再需要记住每个标志或阅读`man`页面来简单地添加用户。`useradd`命令是一种干净的方式来向系统中添加用户，但标志和选项可能有点晦涩难懂。此外，添加超过几个账户可能会变得繁琐。这个脚本完全交互式，将允许任何具有基本系统知识的人轻松添加用户。
- en: 'In the example above, the script essentially creates the following string and
    uses the `system()` command to execute it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，脚本实际上创建以下字符串，并使用`system()`命令来执行它：
- en: '``useradd -g *`admin`* -G *`printer`* -s /bin/*`bash`* -d /home/*`steve`* -m
    *`steve`*``'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '``useradd -g *`admin`* -G *`printer`* -s /bin/*`bash`* -d /home/*`steve`* -m
    *`steve`*``'
- en: 'The script begins building the string by requesting the username for the new
    account ![](../Images/00002.jpg). The username is important for two reasons: It
    specifies the first piece of the logon credential, and it completes the home directory.
    Next are the groups ![](../Images/00003.jpg). Groups matter in Unix-style systems
    because they associate permissions to a specific username. In this example, I
    used the administrator and printer groups—these are entirely dependent upon the
    groups in your system.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过请求新账户的用户名来开始构建字符串 ![](../Images/00002.jpg)。用户名有两个重要原因：它指定了登录凭证的第一部分，并完成了主目录。接下来是组
    ![](../Images/00003.jpg)。在 Unix 风格的系统中，组很重要，因为它们将权限关联到特定的用户名。在这个例子中，我使用了管理员和打印机组——这些完全取决于你的系统中的组。
- en: After the permissions are given to the user, the shell preference is requested
    ![](../Images/00004.jpg). The list of shells I provided (bash, ksh, zsh, and csh)
    may not all be installed on your system, so you'll need to edit accordingly. Bash
    is the most common shell to use, so I have defined that as the default entry and
    also used it in my example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在授予用户权限后，脚本会请求 shell 预设 ![](../Images/00004.jpg)。我提供的 shell 列表（bash、ksh、zsh
    和 csh）可能并不都在你的系统上安装，所以你需要相应地进行编辑。Bash 是最常用的 shell，所以我将其定义为默认条目，并在我的示例中使用它。
- en: The last addition to our command string is the home directory and username.
    The script asked for the username in the beginning, so that value is used. The
    home directory ends up being */home/steve*, and the username is, obviously, *steve*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们命令字符串的最后一个添加项是主目录和用户名。脚本一开始就要求输入用户名，所以使用那个值。主目录最终是 */home/steve*，用户名显然是 *steve*。
- en: Finally, the string is executed using the `system()` command ![](../Images/00005.jpg),
    which spawns a subprocess and waits for the subprocess to terminate. The value
    `true` is returned if the subprocess exits successfully; otherwise, `false` is
    returned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `system()` 命令执行字符串 ![](../Images/00005.jpg)，该命令会启动一个子进程并等待子进程终止。如果子进程成功退出，则返回值
    `true`；否则，返回 `false`。
- en: Hacking the Script
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解脚本
- en: Hopefully, you realize that not all of the flags are required to create a user,
    but they do make life simpler during the initial account creation process. With
    some additional code, this script could be integrated with a CSV file for automated
    user creation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能意识到，并非所有标志都是创建用户所必需的，但它们确实在初始账户创建过程中简化了生活。通过添加一些额外的代码，这个脚本可以与 CSV 文件集成，以实现自动化用户创建。
- en: Try not to be overwhelmed by the amount of data I'm describing by hacking these
    scripts. If you are serious about writing your own scripts, a good starting point
    is to tweak other scripts and build up to writing scripts from scratch … especially
    when they involve many complex sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被我所描述的数据量所压倒，通过修改这些脚本进行破解。如果你认真想要编写自己的脚本，一个好的起点是调整其他脚本，逐步过渡到从头编写脚本……尤其是当它们涉及许多复杂部分时。
- en: Modifying a User
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改用户
- en: Modifying a User
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改用户
- en: modUser.rb
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: modUser.rb
- en: If you have ever administered a computer system that had multiple users, chances
    are you have had to modify existing accounts. In my experience, user accounts
    can be modified to update an expiration date, change a home directory, tweak a
    username, or, more commonly, to add a new group to the mix. Below you will find
    a generic script for guiding the user through the modification process. Keep in
    mind that this script needs to be run with elevated permissions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经管理过拥有多个用户的计算机系统，那么你很可能不得不修改现有的账户。根据我的经验，用户账户可以被修改以更新到期日期、更改主目录、调整用户名，或者更常见的是，向其中添加新的组。下面你将找到一个通用的脚本，用于指导用户完成修改过程。请注意，此脚本需要以提升的权限运行。
- en: '* * *'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Warning
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*This script is platform dependent, so ensure that your systems are compatible
    with the commands to avoid corrupting your user files*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*此脚本依赖于平台，因此请确保你的系统与命令兼容，以避免损坏你的用户文件*。'
- en: '* * *'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The Code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` #!/usr/bin/env ruby   #Using the command ''useradd'' with various arguments   print
    "Enter the username to modify: "  user_name = gets.chomp   #Determine how many
    groups the account will belong to ![](../Images/00002.jpg) print "Would you like
    to add this account to any groups [y/n]? "  gresult = gets.chomp ![](../Images/00003.jpg)  
      if (gresults == ''y'' || gresults == ''Y'')      #Add the groups to the user
         print "\nEnter primary group: "      gname = gets.chomp      mod_user = "-g
    #{gname} "       while gname          print "\nEnter next group: "          gname
    = gets.chomp          break if gname.empty?          add_user << "-G #{gname}
    "      end  end    #Define which program will start when the user logs in  print
    "Would you like to change the starting shell [y/n]?  sresult = gets.chomp  if
    (sresults == ''y'' || sresults == ''Y'')      puts "\n\n\n[1] Bourne Again Shell
    (bash)"      puts "[2] Korn Shell (ksh)"      puts "[3] Z Shell (zsh)"      puts
    "[4] C Shell (csh)"      print "Which shell would you like? "       sh_num = gets.chomp.to_i
         shell = case sh_num          when 1 then ''/bin/bash''          when 2 then
    ''/bin/ksh''          when 3 then ''/bin/zsh''          when 4 then ''/bin/csh''
             else ''/bin/bash''      end      mod_user << "-s ${shell} "  end   #Define
    home directory  print "Would you like to change the home directory [y/n]?  dresult
    = gets.chomp  if (dresults == ''y'' || dresults == ''Y'')      print "Enter new
    directory: "      dir = gets.chomp      mod_user << "-d #{dir} "  end   #Define
    new Login  print "Would you like to change the login name [y/n]?  lresult = gets.chomp
     if (lresults == ''y'' || lresults == ''Y'')      print "Enter new login: "   
      name = gets.chomp      mod_user << "-l #{name}"  end   #Modify user and look
    at return value  if(''usermod #{mod_user}'')      puts "\n\nSuccessfully modified:
    #{user_name}\n"  else      puts "\n\nUnable to modify: #{user_name}\n"`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '` #!/usr/bin/env ruby   #使用带有各种参数的命令''useradd''   print "请输入要修改的用户名: "  user_name
    = gets.chomp   #确定账户将属于多少个组 ![](../Images/00002.jpg) print "您想将此账户添加到任何组中吗 [y/n]?
    "  gresult = gets.chomp ![](../Images/00003.jpg)     if (gresults == ''y'' ||
    gresults == ''Y'')      #将组添加到用户中      print "\n请输入主要组: "      gname = gets.chomp
         mod_user = "-g #{gname} "       while gname          print "\n请输入下一个组: "
             gname = gets.chomp          break if gname.empty?          mod_user <<
    "-G #{gname} "      end  end    #定义用户登录时启动的程序  print "您想更改启动的shell吗 [y/n]?  sresult
    = gets.chomp  if (sresults == ''y'' || sresults == ''Y'')      puts "\n\n\n[1]
    Bourne Again Shell (bash)"      puts "[2] Korn Shell (ksh)"      puts "[3] Z Shell
    (zsh)"      puts "[4] C Shell (csh)"      print "您想选择哪个shell? "       sh_num =
    gets.chomp.to_i      shell = case sh_num          when 1 then ''/bin/bash''   
          when 2 then ''/bin/ksh''          when 3 then ''/bin/zsh''          when
    4 then ''/bin/csh''          else ''/bin/bash''      end      mod_user << "-s
    ${shell} "  end   #定义主目录  print "您想更改主目录吗 [y/n]?  dresult = gets.chomp  if (dresults
    == ''y'' || dresults == ''Y'')      print "请输入新目录: "      dir = gets.chomp   
      mod_user << "-d #{dir} "  end   #定义新的登录名  print "您想更改登录名吗 [y/n]?  lresult =
    gets.chomp  if (lresults == ''y'' || lresults == ''Y'')      print "请输入新的登录名:
    "      name = gets.chomp      mod_user << "-l #{name}"  end   #修改用户并查看返回值  if(''usermod
    #{mod_user}'')      puts "\n\n成功修改：#{user_name}\n"  else      puts "\n\n无法修改：#{user_name}\n"`'
- en: Running the Code
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: You will be prompted for information a minimum of five times. The first prompt
    will ask for the username of the account you want to modify. The remaining four
    prompts will ask questions about which part of the account needs modification.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少会被提示五次信息。第一次提示将要求您输入您想要修改的账户的用户名。接下来的四次提示将询问您需要修改账户的哪个部分。
- en: 'In the example above, I only changed the starting shell. The script interaction
    is shown below:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我只更改了启动的shell。下面的脚本交互如下：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Results
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The results will be one of two messages. Either
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是两条消息之一。要么
- en: '``Successfully modified: *`steve`*``'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '``成功修改：*`steve`*``'
- en: or
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '``Unable to modify: *`steve`*``'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '``无法修改：*`steve`*``'
- en: If you are unable to modify the user, you will need to break out your troubleshooting
    hat to find the reason.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法修改用户，您将需要戴上您的故障排除帽，找出原因。
- en: In the example, whenever I log back into the account steve, I will now start
    off with the Z Shell instead of Bash. See how easy it is? This script could be
    given to a Unix novice and run from a terminal without any worries.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，每次我重新登录到steve账户时，我现在将启动Z Shell而不是Bash。看看有多简单？这个脚本可以给Unix新手，并且可以从终端运行而不用担心。
- en: How It Works
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script's main components are similar to the script in "#18 Adding a User"
    on [Hacking the Script](../Text/dummy_split_128.html#filepos283804), because the
    attributes for a user account are the same whether you are creating, modifying,
    or deleting it. While I chose four attributes that I felt would be modified most
    frequently, they can always be removed to shorten runtime, or you can add others
    to suit your needs. The attributes to modify are `groups`, `starting shell`, `home
    directory`, and `login name`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的主要组件与[Hacking the Script](../Text/dummy_split_128.html#filepos283804)中的"#18
    添加用户"脚本类似，因为无论你是创建、修改还是删除用户账户，账户的属性都是相同的。虽然我选择了四个我认为最常修改的属性，但它们总是可以被移除以缩短运行时间，或者你可以添加其他属性以满足你的需求。需要修改的属性包括`groups`、`starting
    shell`、`home directory`和`login name`。
- en: Starting with the username, the script begins to prompt the system administrator
    for each attribute to determine whether any modifications are needed ![](../Images/00002.jpg).
    A simple conditional statement is used each time and looks for the letter *y*.
    In case the user left her CAPS LOCK enabled, the script will also accept an uppercase
    letter *Y*. Any other input, whether it's *n*, *N*, or some other character, will
    be interpreted as a dismissal of the modification ![](../Images/00003.jpg). Instead
    of adding this option to the conditional statement, I could have easily applied
    `.downcase` to the `gets` statement to ensure the input is always lowercase.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户名开始，脚本开始提示系统管理员确定每个属性是否需要修改 ![图片](../Images/00002.jpg)。每次都使用一个简单的条件语句，并查找字母
    *y*。如果用户启用了大写锁定键，脚本也会接受大写字母 *Y*。任何其他输入，无论是 *n*、*N* 还是其他字符，都将被解释为拒绝修改 ![图片](../Images/00003.jpg)。我本可以将这个选项添加到条件语句中，但我很容易地应用
    `.downcase` 到 `gets` 语句，以确保输入始终为小写。
- en: 'Because most of the script is self-explanatory and thoroughly covered in "#18
    Adding a User" on [Hacking the Script](../Text/dummy_split_128.html#filepos283804),
    I won''t belabor the details. An interesting point to note: If you wish to modify
    the username of an account, that account cannot be logged into. If you try to
    `su` to an admin account, then modify the account you just came from, or you will
    surely see a friendly message declaring that you cannot modify the specific user.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本的大部分内容都是自我解释的，并且在[Hacking the Script](../Text/dummy_split_128.html#filepos283804)中的"#18
    添加用户"部分有详细说明，因此我不会过多地阐述细节。一个值得注意的有趣点是：如果你希望修改账户的用户名，那么该账户不能被登录。如果你尝试使用`su`切换到管理员账户，然后修改你刚刚离开的账户，你肯定会看到一个友好的消息声明你无法修改特定的用户。
- en: Hacking the Script
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hacking the Script
- en: Adding a user and modifying a user are very similar operations, lending themselves
    to the creation of a turnkey script for all user manipulations. You could easily
    combine the script in "#18 Adding a User" on [Hacking the Script](../Text/dummy_split_128.html#filepos283804)
    with this script and extract some of the methods for another clean script.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 添加用户和修改用户是非常相似的操作，这使得为所有用户操作创建一个一键脚本变得可行。你可以轻松地将[Hacking the Script](../Text/dummy_split_128.html#filepos283804)中的"#18
    添加用户"脚本与此脚本结合，并从中提取一些方法以创建另一个干净的脚本。
- en: Killing a Stuck Process
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止卡住进程
- en: Killing a Stuck Process
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止卡住进程
- en: killProcess.rb
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: killProcess.rb
- en: Applications are wonderful additions to operating systems. But occasionally
    they get stuck and begin to cause a self-inflicted Denial of Service attack on
    your system. Some processes are very stubborn and take extra effort to completely
    kill. This wicked little script will intuitively identify the stuck processes
    and automatically terminate them. How's that for avoiding additional manual work?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是操作系统的美妙补充。但有时它们会卡住，并开始对你的系统进行自我造成的拒绝服务攻击。一些进程非常顽固，需要额外的努力才能完全终止。这个邪恶的小脚本会直观地识别卡住的进程，并自动终止它们。这难道不是避免额外手动工作的好方法吗？
- en: The Code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`` #!/usr/bin/ruby ![](../Images/00002.jpg) max_time = 300 ![](../Images/00003.jpg) ps_list
    = `ps h -eo cputime, pcpu, pid, user, cmd`  ![](../Images/00004.jpg) list = ps_list.split(/\n/)  ![](../Images/00005.jpg) list.each
    do |p| ![](../Images/00006.jpg)     process = p.split ![](../Images/00007.jpg)  
      process[0] =~ /(\d+):(\d+):(\d+)/ ![](../Images/00008.jpg)     cpu_time = $1*3600
    + $2*60 + $3 ![](../Images/00009.jpg)     next if cpu_time < $max_time      next
    if process[3] == "root" or process[3] == "postfix"      next if process[4] ==
    "kdeinit"       begin          print "Would you like to kill: #{process[4]} (y/n)?
    "          if gets.downcase == "y" ![](../Images/00011.jpg)               Process.kill
    :TERM,process[2]          end      rescue          puts "Couldn''t kill the process...check
    permission." ![](../Images/00012.jpg)            retry      end  end``'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Running the Code
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script is almost completely autonomous and only requires confirmation before
    killing a process. To run it, type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本几乎完全自主，只需在结束进程前进行确认。要运行它，请输入：
- en: '``**`./killProcess.rb`**``'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The Results
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'You will get a series of questions asking about the process identified as being
    an offender. The questions will look like these:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一系列关于被识别为违规进程的问题。这些问题将看起来像这样：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How It Works
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The beauty of this code lies in the way the script extracts CPU time. If a process
    has been expending CPU cycles for more than a reasonable amount of time, then
    it's time to kill the process. Chances are the process is hung, blocking other
    applications, and wasting precious system resources. You can change the time constraint
    to match the needs of your situation, but any time period will gain efficiency
    out of the processor by allowing the CPU to focus on meaningful data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的美丽之处在于脚本提取CPU时间的方式。如果一个进程已经消耗了超过合理时间的CPU周期，那么就是时候结束这个进程了。很可能是这个进程卡住了，阻止了其他应用程序，并浪费了宝贵的系统资源。你可以更改时间限制以适应你的需求，但任何时间段都能通过让CPU专注于有意义的数据来提高处理器的效率。
- en: 'The maximum time allowed in this script is set in seconds. In the script, I
    arbitrarily choose 5 minutes, or 300 seconds ![](../Images/00002.jpg). The data
    used in this script is retrieved from the system using Ruby''s awesome backticks
    ![](../Images/00003.jpg). The `ps` command is executed with several arguments
    that will enable the script to target abusive processes. The `h` flag removes
    the header from the `ps` output. Since we are dictating the fields used, we don''t
    need to label the fields. Next, `-e` is used to show all processes on the system;
    `-A` could have also been used instead of `-e`. The second part of that flag is
    `o`, and that flag allows us to specify the output. The rest of the command shows
    which fields we are interested in retrieving: `cputime`, `pcpu`, `pid`, `user`,
    and `command`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中允许的最大时间是按秒设置的。在脚本中，我任意选择了5分钟，即300秒 ![图片](../Images/00002.jpg)。这个脚本中使用的数据是通过Ruby的强大反引号
    ![图片](../Images/00003.jpg) 从系统中检索的。`ps`命令通过几个参数执行，这将使脚本能够针对滥用进程。`h`标志从`ps`输出中移除标题。由于我们指定了使用的字段，因此不需要标记字段。接下来，`-e`用于显示系统上的所有进程；也可以用`-A`代替`-e`。该标志的第二部分是`o`，该标志允许我们指定输出。命令的其余部分显示了我们要检索的字段：`cputime`、`pcpu`、`pid`、`user`和`command`。
- en: Now that the data is captured into the variable `ps_list` as a string, it must
    be broken down into manageable pieces of information. The highly effective `.split`
    command comes into play here, directed to split up the string by every new line
    ![](../Images/00004.jpg). If you recall the `ps` output, each process has its
    own line. After the processes are broken down into their elements, we can begin
    examining these.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经以字符串形式捕获到变量`ps_list`中，必须将其分解成可管理的信息块。这里就派上了高效`.split`命令的用场，它被用来通过每一行来分割字符串
    ![图片](../Images/00004.jpg)。如果你还记得`ps`的输出，每个进程都有自己的行。在将进程分解为其元素之后，我们可以开始检查这些元素。
- en: If you don't yet realize the power of `.each`, you will soon. The variable `list`
    contains an array of each process and its details. The `.each` instruction will
    go through each process no matter how many or how few there are ![](../Images/00005.jpg).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到`.each`的强大功能，你很快就会明白。变量`list`包含每个进程及其详细信息的数组。`.each`指令将遍历每个进程，无论有多少或有多少个![图片](../Images/00005.jpg)。
- en: 'Even though we have split each process from the others, we need to drill down
    the specific process information further to isolate the fields ![](../Images/00006.jpg).
    The default delimiter for `.split` is whitespace. A process string before the
    `.split` might look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将每个进程与其他进程分开，但我们还需要进一步深入具体进程信息，以隔离字段![图片](../Images/00006.jpg)。`.split`的默认分隔符是空白。在`.split`之前的进程字符串可能看起来像：
- en: '``*`"00:03:04    0.0    1    steve    /usr/bin/ruby"`*``'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`"00:03:04    0.0    1    steve    /usr/bin/ruby"`*``'
- en: 'After the split it will be an array with five items:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 分割后，它将是一个包含五个元素的数组：
- en: '``*`["00:06:04", "0.0", "1", "steve", "/usr/bin/ruby"]`*``'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`["00:06:04", "0.0", "1", "steve", "/usr/bin/ruby"]`*``'
- en: How cool is that?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这有多酷？
- en: Hopefully, you see that the first field of each process will be what decides
    the process's fate. In this example, the process has been running for six minutes
    and four seconds. To get the data into a usable form, we need to convert the time
    into seconds. I've used a regular expression and groupings based on the time format.
    The `=~` operator is another slick feature; it allows you to take a shortcut around
    the regular expression `match` method. I use regular expressions a lot for input
    validation—if you don't know them, they are well worth the time it takes to learn!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到，每个进程的第一个字段将决定进程的命运。在这个例子中，进程已经运行了六分钟零四秒。为了将数据转换成可用的形式，我们需要将时间转换成秒。我使用了正则表达式和基于时间格式的分组。`=~`操作符是另一个巧妙的功能；它允许你绕过正则表达式`match`方法。我经常使用正则表达式进行输入验证——如果你不知道它们，那么花时间去学习它们是非常值得的！
- en: After the regular expression has evaluated the data, the evaluation will return
    each grouping, signified by parentheses, into `$1-$`*`n`* with *`n`* being the
    number of groups ![](../Images/00007.jpg). The next step is to break each value
    down into seconds. We know there are 3,600 seconds in every hour and 60 seconds
    in every minute. So we multiply each grouping by its corresponding seconds and
    add them together ![](../Images/00008.jpg).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式评估数据后，评估将返回每个分组，由括号表示，表示为`$1-$`*`n`*，其中*`n`*是组的数量![图片](../Images/00007.jpg)。下一步是将每个值分解成秒。我们知道每小时有3600秒，每分钟有60秒。因此，我们将每个分组乘以其对应的秒数并将它们相加![图片](../Images/00008.jpg)。
- en: 'The evaluation is done using three `if` statements. An alternative would be
    to use a really long `if` statement, but I decided against it for the sake of
    keeping the code readable. For a process to be a target, it must meet three conditions.
    If any of those conditions are not satisfied, then we disregard the process. The
    three conditions are: the time being more than `$max_time` in seconds, the owner
    not being a protected user, and the process not being a system-critical one ![](../Images/00009.jpg).
    In the script, I threw in some examples like `root` and `kdeinit`. Play around
    in this area to customize for your purposes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 评估是通过三个`if`语句完成的。另一种选择是使用一个非常长的`if`语句，但我决定反对它，为了保持代码的可读性。一个进程要成为目标，必须满足三个条件。如果这些条件中的任何一个没有得到满足，那么我们就忽略这个进程。这三个条件是：时间超过`$max_time`秒，所有者不是受保护的用户，以及进程不是系统关键进程![图片](../Images/00009.jpg)。在脚本中，我加入了一些例子，比如`root`和`kdeinit`。在这个区域玩玩，以定制你的需求。
- en: If you trust the script to do everything it said and no more, you can remove
    the confirmation statement. I'm not entirely trusting, so I prefer to know when
    I'm about to kill a process. If the user answers anything but a capitalized or
    lowercase y, the process will not be killed—again, I am using a regular expression.
    If the script is directed to kill the process, it will attempt to use `TERM` ![](../Images/00011.jpg).
    Feel free to change to `SIGTERM` if you're feeling especially grumpy since it
    is a more forceful kill. Every once in a while a process won't die, and the script
    will let you know. You can continue retrying ![](../Images/00012.jpg), or skip
    it by answering no to the confirmation line. Once the script has gone through
    each process, it exits.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你信任脚本只做它所说的，不做更多，你可以移除确认语句。我不完全信任，所以我更喜欢知道我即将终止一个进程。如果用户回答的不是大写或小写的 y，则进程不会被终止——再次强调，我正在使用正则表达式。如果脚本被指示终止进程，它将尝试使用
    `TERM` ![图片](../Images/00011.jpg)。如果你感到特别烦躁，可以自由地将其更改为 `SIGTERM`，因为它是一种更强烈的终止方式。偶尔，一个进程不会死亡，脚本会通知你。你可以继续重试
    ![图片](../Images/00012.jpg)，或者通过回答确认行中的“否”来跳过它。一旦脚本处理完每个进程，它将退出。
- en: Validating Symlinks
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证符号链接
- en: Validating Symlinks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证符号链接
- en: symlinkCheck.rb
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: symlinkCheck.rb
- en: '*Symlinks, or symbolic links*, are awesome for a lot of reasons: They simplify
    obnoxiously long path names; you can put them anywhere you like; you can call
    them whatever you want; and they are generally transparent to the user. While
    symlinks can do magical things, they really suck when they become orphans (that
    is, no longer point to a valid target). So, in an effort to uphold the symlink
    reputation, I wrote this script to clean up after myself … and others. It''s a
    housekeeping script.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号链接，或称为符号链接*，由于许多原因而非常出色：它们简化了令人讨厌的长路径名；你可以把它们放在任何你喜欢的地方；你可以称它们为任何你想要的名字；并且它们通常对用户是透明的。虽然符号链接可以做神奇的事情，但它们成为孤儿（即不再指向有效的目标）时真的很糟糕。因此，为了维护符号链接的声誉，我编写了这个脚本来清理自己的……以及他人的。这是一个家务脚本。'
- en: The Code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` #!/usr/bin/ruby  ![](../Images/00002.jpg) unless File.directory?(ARGV[0])
         puts "Not a valid directory...\nCheck path and try again.\n\n"      exit
     end  ![](../Images/00003.jpg) Dir.open(ARGV[0]) do |adir|      adir.each do |afile|
    ![](../Images/00004.jpg)            next unless FileTest.symlink?(afile) ![](../Images/00005.jpg)  
             next if File.file?(afile) ![](../Images/00006.jpg)            puts "Bad
    Link: #{File.expand_path(afile)}"      end  end`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '` #!/usr/bin/ruby  ![图片](../Images/00002.jpg) unless File.directory?(ARGV[0])   '
- en: Running the Code
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script runs off a single directory input. If you have a directory where
    you keep symlinks, this script will scrub the list in a matter of seconds. Just
    type the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本仅运行单个目录输入。如果你有一个存放符号链接的目录，这个脚本可以在几秒钟内清理列表。只需输入以下内容：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Results
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The script will immediately output the path of each symlink identified as being
    orphaned—all other symlinks are skipped. The output will be similar to this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将立即输出每个被识别为孤立符号链接的路径——其他所有符号链接将被跳过。输出将类似于以下内容：
- en: '``Bad Link: *`/home/steve/Desktop/symlink.txt`*``'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '``坏链接：*`/home/steve/Desktop/symlink.txt`*``'
- en: How It Works
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: User input drives the script's direction, so the first step is to collect the
    user input (the directory in which we are symlink hunting). If an invalid argument
    is supplied, the user is notified and the script exits ![](../Images/00002.jpg).
    The directory is opened using the `Dir.open()` command ![](../Images/00003.jpg).
    After the directory has been successfully opened, the process is iterated and
    each file analyzed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入驱动脚本的流程，因此第一步是收集用户输入（我们正在搜索符号链接的目录）。如果提供了无效的参数，用户将收到通知，并且脚本将退出 ![图片](../Images/00002.jpg)。目录使用
    `Dir.open()` 命令打开 ![图片](../Images/00003.jpg)。在目录成功打开后，过程将被迭代，并对每个文件进行分析。
- en: 'Two conditions must be met for a file to be considered an orphaned symlink.
    The first condition is checked by the `next unless` statement ![](../Images/00004.jpg).
    This statement checks to see if the file is a symlink. If the file is not a symbolic
    link, then the script doesn''t need to waste any more time analyzing it; `next`
    is called and the rest of the files are analyzed. If you''re lucky and the file
    is a symlink, then the script will verify that the symlink actually links to something.
    This second check is based on the symlink pointing to a target: the method `File.file?`
    will be asking if the target is a file ![](../Images/00005.jpg). If the target
    does not exist, the link is orphaned and must be reported to the user for further
    action ![](../Images/00006.jpg). The output shows the entire path of the bad symlink
    for easy identification once the script has finished. All that is left is for
    the user to find the target for each bad link or delete the symlink.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件要被视为孤儿符号链接，必须满足两个条件。第一个条件通过`next unless`语句进行检查 ![图片1](../Images/00004.jpg)。这个语句检查文件是否是符号链接。如果文件不是符号链接，那么脚本就不需要浪费更多时间分析它；调用`next`并继续分析其他文件。如果你幸运的话，文件是符号链接，那么脚本将验证这个符号链接实际上是否链接到了某个东西。这个第二个检查基于符号链接指向的目标：方法`File.file?`将询问目标是否是一个文件
    ![图片2](../Images/00005.jpg)。如果目标不存在，链接就是孤儿的，必须报告给用户以便进一步操作 ![图片3](../Images/00006.jpg)。脚本完成后，输出将显示坏符号链接的完整路径，以便于识别。剩下的工作就是用户找到每个坏链接的目标或者删除符号链接。
- en: Hacking the Script
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: While this script only looks at symbolic links of files, directories can also
    have symbolic links. You can change this script to look for invalid directories
    along with invalid file links. Give it a try and see how many unexpectedly invalid
    links exist on your machine!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个脚本只检查文件的符号链接，但目录也可以有符号链接。你可以修改这个脚本以查找无效的目录以及无效的文件链接。试一试，看看你的机器上存在多少意外无效的链接！
