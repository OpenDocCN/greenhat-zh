- en: Chapter 0x600. COUNTERMEASURES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第0x600章。对策
- en: The golden poison dart frog secretes an extremely toxic poison—one frog can
    emit enough to kill 10 adult humans. The only reason these frogs have such an
    amazingly powerful defense is that a certain species of snake kept eating them
    and developing a resistance. In response, the frogs kept evolving stronger and
    stronger poisons as a defense. One result of this co-evolution is that the frogs
    are safe against all other predators. This type of co-evolution also happens with
    hackers. Their exploit techniques have been around for years, so it's only natural
    that defensive countermeasures would develop. In response, hackers find ways to
    bypass and subvert these defenses, and then new defense techniques are created.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 金色毒箭蛙分泌出极其有毒的毒液——一只青蛙就能分泌出足以杀死10名成年人的毒液。这些青蛙之所以拥有如此惊人的防御能力，唯一的原因是某种蛇类一直捕食它们并产生抗性。作为回应，青蛙不断进化出更强有力的毒液作为防御。这种协同进化的一个结果是青蛙对所有其他捕食者都安全。这种类型的协同进化也发生在黑客之间。他们的攻击技术已经存在多年，因此防御对策的发展是自然而然的事情。作为回应，黑客找到了绕过和颠覆这些防御的方法，然后又创造了新的防御技术。
- en: 'This cycle of innovation is actually quite beneficial. Even though viruses
    and worms can cause quite a bit of trouble and costly interruptions for businesses,
    they force a response, which fixes the problem. Worms replicate by exploiting
    existing vulnerabilities in flawed software. Often these flaws are undiscovered
    for years, but relatively benign worms such as CodeRed or Sasser force these problems
    to be fixed. As with chickenpox, it''s better to suffer a minor outbreak early
    instead of years later when it can cause real damage. If it weren''t for Internet
    worms making a public spectacle of these security flaws, they might remain unpatched,
    leaving us vulnerable to an attack from someone with more malicious goals than
    just replication. In this way, worms and viruses can actually strengthen security
    in the long run. However, there are more proactive ways to strengthen security.
    Defensive countermeasures exist which try to nullify the effect of an attack,
    or prevent the attack from happening. A countermeasure is a fairly abstract concept;
    this could be a security product, a set of policies, a program, or simply just
    an attentive system administrator. These defensive countermeasures can be separated
    into two groups: those that try to detect the attack and those that try to protect
    the vulnerability.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种创新循环实际上是非常有益的。尽管病毒和蠕虫会给企业带来相当大的麻烦和昂贵的中断，但它们迫使人们做出反应，从而解决问题。蠕虫通过利用有缺陷软件中现有的漏洞进行复制。通常这些缺陷多年都未被发现，但相对温和的蠕虫如CodeRed或Sasser迫使这些问题得到修复。就像水痘一样，最好是早期就出现轻微的爆发，而不是多年后造成真正的损害。如果不是互联网蠕虫将这些安全漏洞公之于众，它们可能仍然未被修补，使我们容易受到那些除了复制之外还有更恶意目标的人的攻击。这样，蠕虫和病毒实际上可以在长期内加强安全性。然而，还有更多积极主动的方式来加强安全性。防御对策存在，试图消除攻击的影响，或者防止攻击发生。对策是一个相当抽象的概念；这可能是一个安全产品、一系列政策、一个程序，或者只是一个警觉的系统管理员。这些防御对策可以分为两组：那些试图检测攻击的，和那些试图保护漏洞的。
- en: Countermeasures That Detect
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测对策
- en: The first group of countermeasures tries to detect the intrusion and respond
    in some way. The detection process could be anything from an administrator reading
    logs to a program sniffing the network. The response might include killing the
    connection or process automatically, or just the administrator scrutinizing everything
    from the machine's console.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组对策试图检测入侵并做出某种响应。检测过程可能包括管理员阅读日志，或者程序嗅探网络。响应可能包括自动终止连接或进程，或者只是管理员仔细检查机器控制台上的所有内容。
- en: As a system administrator, the exploits you know about aren't nearly as dangerous
    as the ones you don't. The sooner an intrusion is detected, the sooner it can
    be dealt with and the more likely it can be contained. Intrusions that aren't
    discovered for months can be cause for concern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，你所知道的漏洞并不像你所不知道的那么危险。入侵检测得越早，处理得越早，就越有可能被控制。几个月都没有被发现入侵的情况可能会引起担忧。
- en: The way to detect an intrusion is to anticipate what the attacking hacker is
    going to do. If you know that, then you know what to look for. Countermeasures
    that detect can look for these attack patterns in log files, network packets,
    or even program memory. After an intrusion is detected, the hacker can be expunged
    from the system, any filesystem damage can be undone by restoring from backup,
    and the exploited vulnerability can be identified and patched. Detecting countermeasures
    are quite powerful in an electronic world with backup and restore capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 检测入侵的方法是预测攻击者将要做什么。如果你知道了，那么你就知道该寻找什么。检测对策可以在日志文件、网络数据包或程序内存中寻找这些攻击模式。一旦检测到入侵，黑客就可以从系统中清除，任何文件系统损坏都可以通过恢复备份来撤销，并且可以识别并修补被利用的漏洞。在具有备份和恢复功能的电子世界中，检测对策非常强大。
- en: For the attacker, this means detection can counteract everything he does. Since
    the detection might not always be immediate, there are a few "smash and grab"
    scenarios where it doesn't matter; however, even then it's better not to leave
    tracks. Stealth is one of the hacker's most valuable assets. Exploiting a vulnerable
    program to get a root shell means you can do whatever you want on that system,
    but avoiding detection additionally means no one knows you're there. The combination
    of "God mode" and invisibility makes for a dangerous hacker. From a concealed
    position, passwords and data can be quietly sniffed from the network, programs
    can be backdoored, and further attacks can be launched on other hosts. To stay
    hidden, you simply need to anticipate the detection methods that might be used.
    If you know what they are looking for, you can avoid certain exploit patterns
    or mimic valid ones. The co-evolutionary cycle between hiding and detecting is
    fueled by thinking of the things the other side hasn't thought of.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于攻击者来说，这意味着检测可以抵消他所做的一切。由于检测可能不会总是立即发生，有一些“打砸抢”场景并不重要；然而，即使在这种情况下，最好不要留下痕迹。隐蔽性是黑客最宝贵的资产之一。利用一个有漏洞的程序来获取
    root shell 意味着你可以在该系统上做任何你想做的事情，但避免检测还意味着没有人知道你在那里。这种“上帝模式”和隐形性的结合使得黑客变得危险。从隐蔽的位置，可以从网络中悄悄地嗅探密码和数据，可以对程序进行后门攻击，并可以对其他主机发起进一步的攻击。为了保持隐蔽，你需要简单地预测可能会使用的检测方法。如果你知道他们在寻找什么，你可以避免某些利用模式或模仿有效的模式。隐藏和检测之间的协同进化周期是由思考对方没有考虑过的事情推动的。
- en: System Daemons
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统守护进程
- en: To have a realistic discussion of exploit countermeasures and bypass methods,
    we first need a realistic exploitation target. A remote target will be a server
    program that accepts incoming connections. In Unix, these programs are usually
    system daemons. A daemon is a program that runs in the background and detaches
    from the controlling terminal in a certain way. The term *daemon* was first coined
    by MIT hackers in the 1960s. It refers to a molecule-sorting demon from an 1867
    thought experiment by a physicist named James Maxwell. In the thought experiment,
    Maxwell's demon is a being with the supernatural ability to effortlessly perform
    difficult tasks, apparently violating the second law of thermodynamics. Similarly,
    in Linux, system daemons tirelessly perform tasks such as providing SSH service
    and keeping system logs. Daemon programs typically end with a *d* to signify they
    are daemons, such as *sshd* or *syslogd*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行关于利用对策和绕过方法的现实讨论，我们首先需要一个现实的利用目标。一个远程目标将是一个接受传入连接的服务器程序。在 Unix 中，这些程序通常是系统守护进程。守护进程是一种在后台运行的程序，并以某种方式从控制终端分离。术语
    *daemon* 首次由 20 世纪 60 年代的麻省理工学院黑客提出。它指的是一位名叫詹姆斯·麦克斯韦的物理学家在 1867 年的一个思想实验中提到的分子排序恶魔。在这个思想实验中，麦克斯韦的恶魔是一个具有超自然能力，能够轻松完成困难任务的生物，似乎违反了热力学第二定律。同样，在
    Linux 中，系统守护进程不知疲倦地执行提供 SSH 服务和记录系统日志等任务。守护程序通常以 *d* 结尾，以表示它们是守护进程，例如 *sshd* 或
    *syslogd*。
- en: With a few additions, the tinyweb.c code on [A Tinyweb Server](ch04s02.html#a_tinyweb_server
    "A Tinyweb Server") can be made into a more realistic system daemon. This new
    code uses a call to the `daemon()` function, which will spawn a new background
    process. This function is used by many system daemon processes in Linux, and its
    man page is shown below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一些内容，[《A Tinyweb Server》](ch04s02.html#a_tinyweb_server "A Tinyweb Server")
    中的 tinyweb.c 代码可以被改造成一个更真实的系统守护进程。这个新的代码使用了对 `daemon()` 函数的调用，这将启动一个新的后台进程。这个函数在
    Linux 中被许多系统守护进程使用，其 man 页面如下所示。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: System daemons run detached from a controlling terminal, so the new tinyweb
    daemon code writes to a log file. Without a controlling terminal, system daemons
    are typically controlled with signals. The new tinyweb daemon program will need
    to catch the terminate signal so it can exit cleanly when killed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统守护进程在控制终端之外运行，因此新的 tinyweb 守护进程代码会写入日志文件。没有控制终端，系统守护进程通常通过信号来控制。新的 tinyweb
    守护进程程序需要捕获终止信号，以便在它被杀死时干净地退出。
- en: Crash Course in Signals
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号速成课程
- en: Signals provide a method of interprocess communication in Unix. When a process
    receives a signal, its flow of execution is interrupted by the operating system
    to call a signal handler. Signals are identified by a number, and each one has
    a default signal handler. For example, when CTRL-C is typed in a program's controlling
    terminal, an interrupt signal is sent, which has a default signal handler that
    exits the program. This allows the program to be interrupted, even if it is stuck
    in an infinite loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 信号为 Unix 系统中进程间通信提供了一种方法。当一个进程收到一个信号时，其执行流程会被操作系统中断以调用信号处理程序。信号通过一个数字来识别，每个信号都有一个默认的信号处理程序。例如，当在程序的控制终端中输入
    CTRL-C 时，会发送一个中断信号，它有一个默认的信号处理程序，用于退出程序。这允许程序在陷入无限循环时也能被中断。
- en: Custom signal handlers can be registered using the `signal()` function. In the
    example code below, several signal handlers are registered for certain signals,
    whereas the main code contains an infinite loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `signal()` 函数可以注册自定义信号处理程序。在下面的示例代码中，为某些信号注册了几个信号处理程序，而主代码包含一个无限循环。
- en: signal_example.c
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: signal_example.c
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When this program is compiled and executed, signal handlers are registered,
    and the program enters an infinite loop. Even though the program is stuck looping,
    incoming signals will interrupt execution and call the registered signal handlers.
    In the output below, signals that can be triggered from the controlling terminal
    are used. The `signal_handler()` function, when finished, returns execution back
    into the interrupted loop, whereas the `sigint_handler()` function exits the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序编译并执行时，会注册信号处理程序，程序进入一个无限循环。尽管程序陷入了循环，但传入的信号会中断执行并调用已注册的信号处理程序。在下面的输出中，使用了可以从控制终端触发的信号。`signal_handler()`
    函数完成后，将执行权返回到中断的循环中，而 `sigint_handler()` 函数则退出程序。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Specific signals can be sent to a process using the `kill` command. By default,
    the `kill` command sends the terminate signal (`SIGTERM`) to a process. With the
    `-l` command-line switch, `kill` lists all the possible signals. In the output
    below, the `SIGUSR1` and `SIGUSR2` signals are sent to the signal_example program
    being executed in another terminal.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `kill` 命令向一个进程发送特定的信号。默认情况下，`kill` 命令向进程发送终止信号（`SIGTERM`）。使用 `-l` 命令行选项，`kill`
    会列出所有可能的信号。在下面的输出中，`SIGUSR1` 和 `SIGUSR2` 信号被发送到另一个终端中正在执行的 signal_example 程序。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, the `SIGKILL` signal is sent using `kill -9`. This signal's handler
    cannot be changed, so `kill -9` can always be used to kill processes. In the other
    terminal, the running signal_example shows the signals as they are caught and
    the process is killed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `kill -9` 发送 `SIGKILL` 信号。这个信号的处理器不能被更改，因此 `kill -9` 总是可以用来杀死进程。在另一个终端中，运行的
    signal_example 显示了捕获到的信号，并且进程被杀死。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Signals themselves are pretty simple; however, interprocess communication can
    quickly become a complex web of dependencies. Fortunately, in the new tinyweb
    daemon, signals are only used for clean termination, so the implementation is
    simple.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信号本身相当简单；然而，进程间通信可以迅速变成一个复杂的依赖网络。幸运的是，在新的 tinyweb 守护进程中，信号仅用于干净的终止，因此实现简单。
- en: Tinyweb Daemon
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tinyweb 守护进程
- en: This newer version of the tinyweb program is a system daemon that runs in the
    background without a controlling terminal. It writes its output to a log file
    with timestamps, and it listens for the terminate (`SIGTERM`) signal so it can
    shut down cleanly when it's killed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 tinyweb 程序的新版本是一个在后台运行的系统守护进程，没有控制终端。它将输出写入带有时间戳的日志文件，并监听终止信号（`SIGTERM`），以便在它被杀死时干净地关闭。
- en: These additions are fairly minor, but they provide a much more realistic exploit
    target. The new portions of the code are shown in bold in the listing below.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新增内容相当微小，但它们提供了一个更加现实的攻击目标。下面的代码列表中，新代码部分以粗体显示。
- en: tinywebd.c
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tinywebd.c
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This daemon program forks into the background, writes to a log file with timestamps,
    and cleanly exits when it is killed. The log file descriptor and connection-receiving
    socket are declared as globals so they can be closed cleanly by the `handle_shutdown()`
    function. This function is set up as the callback handler for the terminate and
    interrupt signals, which allows the program to exit gracefully when it's killed
    with the `kill` command.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此守护进程程序在后台进行分支，写入带有时间戳的日志文件，并在被杀死时干净地退出。日志文件描述符和连接接收套接字被声明为全局变量，以便可以通过`handle_shutdown()`函数干净地关闭。此函数被设置为终止和中断信号的回调处理程序，这使得程序在用`kill`命令杀死时可以优雅地退出。
- en: The output below shows the program compiled, executed, and killed. Notice that
    the log file contains timestamps as well as the shutdown message when the program
    catches the terminate signal and calls `handle_shutdown()`to exit gracefully.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了程序编译、执行和杀死的过程。请注意，日志文件包含时间戳，以及当程序捕获终止信号并调用`handle_shutdown()`以优雅退出时的关闭消息。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This tinywebd program serves HTTP content just like the original tinyweb program,
    but it behaves as a system daemon, detaching from the controlling terminal and
    writing to a log file. Both programs are vulnerable to the same overflow exploit;
    however, the exploitation is only the beginning. Using the new tinyweb daemon
    as a more realistic exploit target, you will learn how to avoid detection after
    the intrusion.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个tinywebd程序就像原始的tinyweb程序一样提供HTTP内容，但它作为一个系统守护进程运行，从控制终端分离出来，并写入日志文件。这两个程序都容易受到相同的溢出漏洞攻击；然而，利用只是开始。使用新的tinyweb守护进程作为更现实的漏洞目标，你将学习如何在入侵后避免检测。
- en: Tools of the Trade
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行业工具
- en: With a realistic target in place, let's jump back over to the attacker's side
    of the fence. For this kind of attack, exploit scripts are an essential tool of
    the trade. Like a set of lock picks in the hands of a professional, exploits open
    many doors for a hacker. Through careful manipulation of the internal mechanisms,
    the security can be entirely sidestepped.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了一个现实的目标后，让我们回到攻击者的那一侧。对于这种攻击，漏洞脚本是行业中的必备工具。就像专业人士手中的锁匠工具一样，漏洞为黑客打开了多扇门。通过仔细操作内部机制，可以完全绕过安全措施。
- en: In previous chapters, we've written exploit code in C and manually exploited
    vulnerabilities from the command line. The fine line between an exploit program
    and an exploit tool is a matter of finalization and reconfigurability. Exploit
    programs are more like guns than tools. Like a gun, an exploit program has a singular
    utility and the user interface is as simple as pulling a trigger. Both guns and
    exploit programs are finalized products that can be used by unskilled people with
    dangerous results. In contrast, exploit tools usually aren't finished products,
    nor are they meant for others to use. With an understanding of programming, it's
    only natural that a hacker would begin to write his own scripts and tools to aid
    exploitation. These personalized tools automate tedious tasks and facilitate experimentation.
    Like conventional tools, they can be used for many purposes, extending the skill
    of the user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们用C语言编写了漏洞利用代码，并从命令行手动利用漏洞。漏洞程序和漏洞工具之间的细微差别在于最终化和可重新配置性。漏洞程序更像是枪支而不是工具。就像枪支一样，漏洞程序具有单一的功能，用户界面简单到只需拉动扳机。枪支和漏洞程序都是最终产品，可以被不熟练的人使用，并产生危险的结果。相比之下，漏洞工具通常不是最终产品，也不打算供他人使用。有了编程的理解，黑客开始编写自己的脚本和工具来辅助漏洞利用是顺理成章的。这些个性化的工具自动化繁琐的任务，并促进实验。像传统工具一样，它们可以用于许多目的，扩展用户的能力。
- en: tinywebd Exploit Tool
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tinywebd 漏洞利用工具
- en: For the tinyweb daemon, we want an exploit tool that allows us to experiment
    with the vulnerabilities. As in the development of our previous exploits, GDB
    is used first to figure out the details of the vulnerability, such as offsets.
    The offset to the return address will be the same as in the original tinyweb.c
    program, but a daemon program presents added challenges. The daemon call forks
    the process, running the rest of the program in the child process, while the parent
    process exits. In the output below, a breakpoint is set after the `daemon()` call,
    but the debugger never hits it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 tinyweb 守护进程，我们希望有一个漏洞利用工具，允许我们实验漏洞。就像我们之前漏洞的开发一样，首先使用 GDB 来确定漏洞的细节，例如偏移量。返回地址的偏移量将与原始
    tinyweb.c 程序中的相同，但守护进程程序带来了额外的挑战。守护进程调用会派生子进程，在子进程中运行程序的其余部分，而父进程退出。在下面的输出中，在
    `daemon()` 调用后设置了断点，但调试器从未命中它。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the program is run, it just exits. In order to debug this program, GDB
    needs to be told to follow the child process, as opposed to following the parent.
    This is done by setting `follow-fork-mode` to `child`. After this change, the
    debugger will follow execution into the child process, where the breakpoint can
    be hit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它只是退出。为了调试这个程序，需要告诉 GDB 跟踪子进程，而不是跟踪父进程。这是通过将 `follow-fork-mode` 设置为 `child`
    来实现的。在此更改之后，调试器将跟踪执行到子进程，在那里可以命中断点。
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's good to know how to debug child processes, but since we need specific stack
    values, it's much cleaner and easier to attach to a running process. After killing
    any stray a.out processes, the tinyweb daemon is started back up and then attached
    to with GDB.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何调试子进程是很好的，但由于我们需要特定的堆栈值，连接到正在运行的过程会更干净、更容易。在杀死任何散乱的 a.out 进程后，重新启动 tinyweb
    守护进程，然后使用 GDB 连接到它。
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The execution pauses while the tinyweb daemon waits for a connection. Once again,
    a connection is made to the webserver using a browser to advance the code execution
    to the breakpoint.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当 tinyweb 守护进程等待连接时，执行会暂停。再次使用浏览器连接到 web 服务器，以推进代码执行到断点。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The debugger shows that the request buffer starts at `0xbffff5c0` and the stored
    return address is at `0xbffff7dc`, which means the offset is 540 bytes. The safest
    place for the shellcode is near the middle of the 500-byte request buffer. In
    the output below, an exploit buffer is created that sandwiches the shellcode between
    a NOP sled and the return address repeated 32 times. The 128 bytes of repeated
    return address keep the shellcode out of unsafe stack memory, which might be overwritten.
    There are also unsafe bytes near the beginning of the exploit buffer, which will
    be overwritten during null termination. To keep the shellcode out of this range,
    a 100-byte NOP sled is put in front of it. This leaves a safe landing zone for
    the execution pointer, with the shellcode at `0xbffff624`. The following output
    exploits the vulnerability using the loopback shellcode.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器显示请求缓冲区从 `0xbffff5c0` 开始，存储的返回地址在 `0xbffff7dc`，这意味着偏移量是 540 字节。在 500 字节请求缓冲区的中间附近是放置
    shellcode 的最安全位置。在下面的输出中，创建了一个漏洞利用缓冲区，将 shellcode 放在 NOP 滑梯和重复 32 次的返回地址之间。重复的
    128 字节返回地址使 shellcode 避免了可能被覆盖的不安全堆栈内存。在漏洞利用缓冲区的开头也有不安全的字节，这些字节将在空终止符期间被覆盖。为了使
    shellcode 避免这个范围，在其前面放置了一个 100 字节的 NOP 滑梯。这为执行指针留下了一个安全着陆区，shellcode 位于 `0xbffff624`。下面的输出使用回环
    shellcode 利用漏洞。
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the offset to the return address is 540 bytes, 544 bytes are needed to
    overwrite the address. With the loopback shellcode at 83 bytes and the overwritten
    return address repeated 32 times, simple arithmetic shows that the NOP sled needs
    to be 333 bytes to align everything in the exploit buffer properly. netcat is
    run in listen mode with an ampersand (&) appended to the end, which sends the
    process to the background. This listens for the connection back from the shellcode
    and can be resumed later with the command `fg` (foreground). On the LiveCD, the
    at (@) symbol in the command prompt will change color if there are background
    jobs, which can also be listed with the `jobs` command. When the exploit buffer
    is piped into netcat, the `-w` option is used to tell it to time out after one
    second. Afterward, the backgrounded netcat process that received the connectback
    shell can be resumed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回地址的偏移量是540字节，因此需要544字节来覆盖地址。带有83字节循环回shellcode和重复32次的覆盖返回地址，简单的算术表明NOP雪橇需要333字节来正确地对齐攻击缓冲区中的所有内容。netcat以监听模式运行，并在末尾附加一个&符号，将进程发送到后台。这监听来自shellcode的连接回传，可以用`fg`（前台）命令稍后恢复。在LiveCD上，命令提示符中的@符号如果有后台作业，会改变颜色，也可以用`jobs`命令列出。当攻击缓冲区被管道传输到netcat时，使用`-w`选项告诉它在1秒后超时。之后，接收了连接回传shell的已后台化的netcat进程可以被恢复。
- en: All this works fine, but if a shellcode of different size is used, the NOP sled
    size must be recalculated. All these repetitive steps can be put into a single
    shell script.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都很好，但如果使用了不同大小的shellcode，必须重新计算NOP雪橇的大小。所有这些重复的步骤都可以放入一个单独的shell脚本中。
- en: The BASH shell allows for simple control structures. The `if` statement at the
    beginning of this script is just for error checking and displaying the usage message.
    Shell variables are used for the offset and overwrite return address, so they
    can be easily changed for a different target. The shellcode used for the exploit
    is passed as a command-line argument, which makes this a useful tool for trying
    out a variety of shellcodes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: BASH shell允许简单的控制结构。这个脚本开头的`if`语句只是为了错误检查和显示使用信息。shell变量用于偏移量和覆盖返回地址，因此可以很容易地更改以针对不同的目标。用于攻击的shellcode作为命令行参数传递，这使得它成为一个尝试各种shellcode的有用工具。
- en: xtool_tinywebd.sh
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xtool_tinywebd.sh
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that this script repeats the return address an additional thirty-third
    time, but it uses 128 bytes (32 `x` 4) for calculating the sled size. This puts
    an extra copy of the return address past where the offset dictates. Sometimes
    different compiler options will move the return address around a little bit, so
    this makes the exploit more reliable. The output below shows this tool being used
    to exploit the tinyweb daemon once again, but with the port-binding shellcode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个脚本额外重复了返回地址三十三次，但它是用128字节（32 `x` 4）来计算雪橇大小的。这使得返回地址的副本超出了偏移量指定的位置。有时不同的编译器选项会稍微移动返回地址，这使得攻击更加可靠。下面的输出显示了该工具再次被用来攻击tinyweb守护进程，但这次使用了端口绑定shellcode。
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that the attacking side is armed with an exploit script, consider what happens
    when it's used. If you were the administrator of the server running the tinyweb
    daemon, what would be the first signs that you were hacked?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击方已经装备了攻击脚本，考虑一下使用它时会发生什么。如果你是运行tinyweb守护进程的服务器管理员，你首先会看到什么迹象表明你被黑了？
- en: Log Files
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志文件
- en: One of the two most obvious signs of intrusion is the log file. The log file
    keptby the tinyweb daemon is one of the first places to look into when troubleshooting
    a problem. Even though the attacker's exploits were successful, the log file keeps
    a painfully obvious record that something is up.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最明显的入侵迹象之一是日志文件。tinyweb守护进程保留的日志文件是当解决问题时首先要查看的地方之一。尽管攻击者的攻击是成功的，但日志文件仍然保留了一个痛苦明显的记录，表明出了问题。
- en: Log Files
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志文件
- en: tinywebd Log File
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tinywebd日志文件
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course in this case, after the attacker gains a root shell, he can just edit
    the log file since it's on the same system. On secure networks, however, copies
    of logs are often sent to another secure server. In extreme cases, logs are sent
    to a printer for hard copy, so there is a physical record. These types of countermeasures
    prevent tampering with the logs after successful exploitation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，攻击者获得root shell后，他可以直接编辑日志文件，因为它们在同一个系统上。然而，在安全的网络上，日志的副本通常会发送到另一个安全服务器。在极端情况下，日志会被发送到打印机以生成硬拷贝，因此有一个物理记录。这些类型的对策可以防止在成功利用后篡改日志。
- en: Blend In with the Crowd
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与众不同
- en: 'Even though the log files themselves cannot be changed, occasionally what gets
    logged can be. Log files usually contain many valid entries, whereas exploit attempts
    stick out like a sore thumb. The tinyweb daemon program can be tricked into logging
    a valid-looking entry for an exploit attempt. Look at the source code and see
    if you can figure out how to do this before continuing on. The idea is to make
    the log entry look like a valid web request, like the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日志文件本身不能更改，但偶尔记录的内容可以更改。日志文件通常包含许多有效条目，而漏洞尝试则像 sore thumb 一样突出。可以欺骗 tinyweb
    守护程序程序记录一个看似有效的漏洞尝试条目。查看源代码，看看在继续之前你是否能找出如何做到这一点。想法是使日志条目看起来像有效的网络请求，如下所示：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This type of camouflage is very effective at large enterprises with extensive
    log files, since there are so many valid requests to hide among: It''s easier
    to blend in at a crowded mall than an empty street. But how exactly do you hide
    a big, ugly exploit buffer in the proverbial sheep''s clothing?'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种伪装在拥有大量日志文件的大型企业中非常有效，因为有许多有效请求需要隐藏：在拥挤的商场中融入比在空旷的街道上更容易。但如何将一个庞大、丑陋的漏洞缓冲区隐藏在寓言中的羊皮中呢？
- en: There's a simple mistake in the tinyweb daemon's source code that allows the
    request buffer to be truncated early when it's used for the log file output, but
    not when copying into memory. The `recv_line()` function uses `\r\n` as the delimiter;
    however, all the other standard string functions use a null byte for the delimiter.
    These string functions are used to write to the log file, so by strategically
    using both delimiters, the data written to the log can be partially controlled.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 tinyweb 守护程序的源代码中有一个简单的错误，允许在用于日志文件输出时提前截断请求缓冲区，但在复制到内存中时不会。`recv_line()`函数使用`\r\n`作为分隔符；然而，所有其他标准字符串函数都使用空字节作为分隔符。这些字符串函数用于写入日志文件，因此通过战略性地使用这两个分隔符，可以部分控制写入日志的数据。
- en: The following exploit script puts a valid-looking request in front of the rest
    of the exploit buffer. The NOP sled is shrunk to accommodate the new data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下漏洞利用脚本将一个看似有效的请求放在漏洞利用缓冲区的其余部分之前。将NOP sled缩小以适应新数据。
- en: xtool_tinywebd_stealth.sh
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xtool_tinywebd_stealth.sh
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This new exploit buffer uses the null byte delimiter to terminate the fake request
    camouflage. A null byte won't stop the `recv_line()` function, so the rest of
    the exploit buffer is copied to the stack. Since the string functions used to
    write to the log use a null byte for termination, the fake request is logged and
    the rest of the exploit is hidden. The following output shows this exploit script
    in use.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的漏洞利用缓冲区使用空字节分隔符来终止伪装的伪造请求。空字节不会停止`recv_line()`函数，因此漏洞利用缓冲区的其余部分被复制到堆栈上。由于用于写入日志的字符串函数使用空字节作为终止符，因此伪造请求被记录，其余的漏洞利用被隐藏。以下输出显示了此漏洞利用脚本的使用情况。
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The connection used by this exploit creates the following log file entries on
    the server machine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此漏洞利用所使用的连接会在服务器机器上创建以下日志文件条目。
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Even though the logged IP address cannot be changed using this method, the request
    itself appears valid, so it won't attract too much attention.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无法使用此方法更改记录的IP地址，但请求本身看起来是有效的，因此不会引起太多注意。
- en: Overlooking the Obvious
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽视明显之处
- en: In a real-world scenario, the other obvious sign of intrusion is even more apparent
    than log files. However, when testing, this is something that is easily overlooked.
    If log files seem like the most obvious sign of intrusion to you, then you are
    forgetting about the loss of service. When the tinyweb daemon is exploited, the
    process is tricked into providing a remote root shell, but it no longer processes
    web requests. In a real-world scenario, this exploit would be detected almost
    immediately when someone tries to access the website.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，入侵的其他明显迹象甚至比日志文件更明显。然而，在测试时，这是很容易被忽视的东西。如果你认为日志文件是入侵的最明显迹象，那么你忘记了服务中断。当
    tinyweb 守护程序被利用时，进程被欺骗以提供远程root shell，但它不再处理网络请求。在现实场景中，当有人尝试访问网站时，这种漏洞几乎会立即被发现。
- en: A skilled hacker can not only crack open a program to exploit it, he can also
    put the program back together again and keep it running. The program continues
    to process requests and it seems like nothing happened.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一位熟练的黑客不仅可以破解程序以利用它，还可以将其重新组装并保持运行。程序继续处理请求，似乎什么都没发生。
- en: One Step at a Time
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一步一个脚印
- en: Complex exploits are difficult because so many different things can go wrong,
    with no indication of the root cause. Since it can take hours just to track down
    where the error occurred, it's usually better to break a complex exploit down
    into smaller parts. The end goal is a piece of shellcode that will spawn a shell
    yet keep the tinyweb server running. The shell is interactive, which causes some
    complications, so let's deal with that later. For now, the first step should be
    figuring out how to put the tinyweb daemon back together after exploiting it.
    Let's begin by writing a piece of shellcode that does something to prove it ran
    and then puts the tinyweb daemon back together so it can process further web requests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的攻击行为很难，因为可能发生很多不同的问题，而且没有根因的指示。由于追踪错误发生的位置可能需要数小时，通常最好将复杂的攻击行为分解成更小的部分。最终目标是生成一段shellcode，它将启动shell同时保持tinyweb服务器运行。shell是交互式的，这引起了一些复杂性，所以我们稍后再处理。现在，第一步应该是确定如何在利用它之后将tinyweb守护进程重新组装起来。让我们先编写一段shellcode，使其执行一些操作以证明它已运行，然后将tinyweb守护进程重新组装起来以便处理进一步的Web请求。
- en: Since the tinyweb daemon redirects standard out to /dev/null, writing to standard
    out isn't a reliable marker for shellcode. One simple way to prove the shellcode
    ran is to create a file. This can be done by making a call to `open()`, and then
    `close()`. Of course, the `open()` call will need the appropriate flags to create
    a file. We could look through the include files to figure out what `O_CREAT` and
    all the other necessary defines actually are and do all the bitwise math for the
    arguments, but that's sort of a pain in the ass. If you recall, we've done something
    like this already—the notetaker program makes a call to `open()`which will create
    a file if it didn't exist. The strace program can be used on any program to show
    every system call it makes. In the output below, this is used to verify that the
    arguments to `open()` in C match up with the raw system calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于tinyweb守护进程将标准输出重定向到/dev/null，因此向标准输出写入不是一个可靠的shellcode运行证明方法。证明shellcode已运行的一个简单方法就是创建一个文件。这可以通过调用`open()`然后`close()`来实现。当然，`open()`调用需要适当的标志来创建文件。我们可以查看包含文件以了解`O_CREAT`和其他所有必要的定义实际上是什么，并对参数进行所有位运算，但这有点麻烦。如果你还记得，我们之前已经做过类似的事情——记事本程序会调用`open()`，如果文件不存在，则会创建文件。strace程序可以用于任何程序，以显示它所做的每个系统调用。在下面的输出中，这是用来验证C中的`open()`参数与原始系统调用相匹配的。
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When run through strace, the notetaker binary's suid-bit isn't used, so it doesn't
    have permission to open the data file. That doesn't matter, though; we just want
    to make sure the arguments to the `open()` system call match the arguments to
    the `open()` call in C. Since they match, we can safely use the values passed
    to the `open()` function in the notetaker binary as the arguments for the `open()`
    system call in our shellcode. The compiler has already done all the work of looking
    up the defines and mashing them together with a bitwise OR operation; we just
    need to find the call arguments in the disassembly of the notetaker binary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过strace运行时，记事本二进制文件的suid位没有被使用，因此它没有权限打开数据文件。但这没关系；我们只是想确保`open()`系统调用的参数与C中的`open()`调用参数相匹配。由于它们匹配，我们可以安全地使用记事本二进制文件中传递给`open()`函数的值作为我们shellcode中`open()`系统调用的参数。编译器已经完成了查找定义并将它们与位或操作组合在一起的所有工作；我们只需要在记事本二进制文件的汇编中找到调用参数。
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Remember that the arguments to a function call will be pushed to the stack in
    reverse. In this case, the compiler decided to use `mov DWORD PTR[esp+`*`offset`*],*`value_to_push_to_stack`*
    instead of `push` instructions, but the structure built on the stack is equivalent.
    The first argument is a pointer tothe name of the file in EAX, the second argument
    (`put at [esp+4]`) is `0x441`, and the third argument (`put at [esp+8]`) is `0x180`.
    This means that `O_WRONLY|O_CREAT|O_APPEND` turns out to be `0x441` and `S_IRUSR|S_IWUSR`
    is 0x180\. The following shellcode uses these values to create a file called Hacked
    in the root filesystem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，函数调用的参数将被推送到栈中，顺序是相反的。在这种情况下，编译器决定使用`mov DWORD PTR[esp+offset], value_to_push_to_stack`而不是`push`指令，但栈上构建的结构是等效的。第一个参数是文件名的指针，位于EAX中，第二个参数（放置在[esp+4]）是`0x441`，第三个参数（放置在[esp+8]）是`0x180`。这意味着`O_WRONLY|O_CREAT|O_APPEND`的结果是`0x441`，而`S_IRUSR|S_IWUSR`是`0x180`。以下shellcode使用这些值在根文件系统中创建一个名为Hacked的文件。
- en: mark.s
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mark.s
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The shellcode opens a file to create it and then immediately closes the file.
    Finally, it calls exit to avoid an infinite loop. The output below shows this
    new shellcode being used with the exploit tool.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 打开一个文件以创建它，然后立即关闭文件。最后，它调用 exit 以避免无限循环。下面的输出显示了使用漏洞工具使用的新 Shellcode。
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Putting Things Back Together Again
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将事物重新组合在一起
- en: To put things back together again, we just need to repair any collateral damage
    caused by the overwrite and/or shellcode, and then jump execution back into the
    connection accepting loop in `main()`. The disassembly of `main()` in the output
    below shows that we can safely return to the addresses `0x08048f64`,`0x08048f65`,
    or `0x08048fb7` to get back into the connection accept loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事物重新组合在一起，我们只需要修复由覆盖和/或 Shellcode 造成的任何附带损害，然后跳转到 `main()` 中的连接接受循环。下面的输出中
    `main()` 的反汇编显示我们可以安全地返回到地址 `0x08048f64`、`0x08048f65` 或 `0x08048fb7` 以返回到连接接受循环。
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: All three of these addresses basically go to the same place. Let's use `0x08048fb7`
    since this is the original return address used for the call to `handle_connection()`.
    However, there are other things we need to fix first. Look at the function prologue
    and epilogue for `handle_connection()`. These are the instructions that set up
    and remove the stack frame structures on the stack.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个地址基本上都指向同一个地方。让我们使用 `0x08048fb7`，因为这是用于调用 `handle_connection()` 的原始返回地址。然而，我们还需要先修复其他一些问题。查看
    `handle_connection()` 的函数前缀和后缀。这些是设置和移除堆栈帧结构的指令。
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At the beginning of the function, the function prologue saves the current values
    of the EBP and EBX registers by pushing them to the stack, and sets EBP to the
    current value of ESP so it can be used as a point of reference for accessing stack
    variables. Finally, `0x644` bytes are saved on the stack for these stack variables
    by subtracting from ESP. The function epilogue at the end restores ESP by adding
    `0x644` back to it and restores the saved values of EBX and EBP by popping them
    from the stack back into the registers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数开始时，函数前缀通过将它们压入堆栈来保存 EBP 和 EBX 寄存器的当前值，并将 EBP 设置为 ESP 的当前值，以便它可以作为访问堆栈变量的参考点。最后，通过从
    ESP 减去 `0x644` 字节来在堆栈上保存这些堆栈变量。函数后缀在末尾通过将 `0x644` 加回到 ESP 中来恢复 ESP，并通过从堆栈中弹出保存的
    EBX 和 EBP 的值来恢复寄存器中的保存值。
- en: The overwrite instructions are actually found in the `recv_line()` function;
    however, they write to data in the `handle_connection()` stack frame, so the overwrite
    itself happens in `handle_connection()`. The return address that we overwrite
    is pushed to the stack when `handle_connection()` is called, so the saved values
    for EBP and EBX pushed to the stack in the function prologue will be between the
    return address and the corruptible buffer. This means that EBP and EBX will get
    mangled when the function epilogue executes. Since we don't gain control of the
    program's execution until the return instruction, all the instructions between
    the overwrite and the return instruction must be executed. First, we need to assess
    how much collateral damage is done by these extra instructions after the overwrite.
    The assembly instruction `int3` creates the byte `0xcc`, which is literally a
    debugging breakpoint. The shellcode below uses an `int3` instruction instead of
    exiting. This breakpoint will be caught by GDB, allowing us to examine the exact
    state of the program after the shellcode executes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖指令实际上位于 `recv_line()` 函数中；然而，它们写入 `handle_connection()` 堆栈帧中的数据，因此覆盖本身发生在
    `handle_connection()` 中。当我们调用 `handle_connection()` 时，我们覆盖的返回地址被压入堆栈，因此函数前缀中压入堆栈的
    EBP 和 EBX 的保存值将位于返回地址和可破坏缓冲区之间。这意味着当函数后缀执行时，EBP 和 EBX 将被破坏。由于我们直到返回指令才获得程序的执行控制权，因此必须在覆盖和返回指令之间的所有指令都必须执行。首先，我们需要评估这些额外的指令在覆盖之后造成的附带损害有多大。汇编指令
    `int3` 创建了字节 `0xcc`，这实际上是调试断点。下面的 Shellcode 使用 `int3` 指令而不是退出。这个断点将被 GDB 捕获，允许我们检查
    Shellcode 执行后的程序的确切状态。
- en: mark_break.s
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mark_break.s
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To use this shellcode, first get GDB set up to debug the tinyweb daemon. In
    the output below, a breakpoint is set right before `handle_connection()` is called.
    The goal is to restore the mangled registers to their original state found at
    this breakpoint.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 Shellcode，首先设置 GDB 以调试 tinyweb 守护进程。下面的输出中，在调用 `handle_connection()` 之前设置了一个断点。目标是恢复在断点处找到的原始状态破坏的寄存器。
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the output above, a breakpoint is set right before `handle_connection()`
    is called (shown in bold). Then, in another terminal window, the exploit tool
    is used to throw the new shellcode at it. This will advance execution to the breakpoint
    in the other terminal.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，在调用`handle_connection()`之前设置了一个断点（用粗体显示）。然后，在另一个终端窗口中，使用攻击工具将新的shellcode投掷给它。这将使执行推进到另一个终端中的断点。
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Back in the debugging terminal, the first breakpoint is encountered. Some important
    stack registers are displayed, which show the stack setup before (and after) the
    `handle_connection()` call. Then, execution continues to the `int3` instruction
    in the shellcode, which acts like a breakpoint. Then these stack registers are
    checked again to view their state at the moment the shellcode begins to execute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到调试终端，遇到了第一个断点。一些重要的栈寄存器被显示出来，它们显示了在调用`handle_connection()`之前（和之后）的栈设置。然后，执行继续到shellcode中的`int3`指令，它就像一个断点。然后再次检查这些栈寄存器，以查看shellcode开始执行时的状态。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This output shows that EBX and EBP are changed at the point the shellcode begins
    execution. However, an inspection of the instructions in `main()`'s disassembly
    shows that EBX isn't actually used. The compiler probably saved this register
    to the stack due to some rule about calling convention, even though it isn't really
    used. EBP, however, is used heavily, since it's the point of reference for all
    local stack variables. Because the original saved value of EBP was overwritten
    by our exploit, the original value must be recreated. When EBP is restored to
    its original value, the shellcode should be able to do its dirty work and then
    return back into `main()` as usual. Since computers are deterministic, the assembly
    instructions will clearly explain how to do all this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，在shellcode开始执行时，EBX和EBP发生了变化。然而，检查`main()`反汇编中的指令显示，实际上并没有使用EBX。编译器可能由于某些关于调用约定的规则而将此寄存器保存到栈上，尽管实际上并没有使用。然而，EBP被大量使用，因为它是所有局部栈变量的参考点。由于原始的EBP保存值被我们的攻击覆盖，必须重新创建原始值。当EBP恢复到原始值时，shellcode应该能够完成其肮脏的工作，然后像往常一样返回到`main()`。由于计算机是确定性的，汇编指令将清楚地解释如何完成所有这些。
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A quick glance at the function prologue for `main()` shows that EBP should be
    `0x68` bytes larger than ESP. Since ESP wasn't damaged by our exploit, we can
    restore the value for EBP by adding `0x68` to ESP at the end of our shellcode.
    With EBP restored to the proper value, the program execution can be safely returned
    into the connection-accepting loop. The proper return address for the `handle_connection()`
    call is the instruction found after the call at `0x08048fb7`. The following shellcode
    uses this technique.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看`main()`函数的前置部分，可以看到EBP应该比ESP大`0x68`字节。由于ESP没有被我们的攻击损坏，我们可以在shellcode的末尾将`0x68`加到ESP上，以恢复EBP的值。EBP恢复到正确的值后，程序执行可以安全地返回到连接接受循环。`handle_connection()`调用的正确返回地址是在`0x08048fb7`之后的指令。下面的shellcode使用了这种技术。
- en: mark_restore.s
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mark_restore.s
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When assembled and used in an exploit, this shellcode will restore the tinyweb
    daemon's execution after marking the filesystem. The tinyweb daemon doesn't even
    know that something happened.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇编并用于攻击时，这个shellcode将在标记文件系统后恢复tinyweb守护进程的执行。tinyweb守护进程甚至不知道发生了什么。
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Child Laborers
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 儿童劳工
- en: Now that the difficult part is figured out, we can use this technique to silently
    spawn a root shell. Since the shell is interactive, but we still want the process
    to handle web requests, we need to fork to a child process. The `fork()` call
    creates a child process that is an exact copy of the parent, except that it returns
    `0` in the child process and the new process ID in the parent process. We want
    our shellcode to fork and the child process to serve up the root shell, while
    the parent process restores tinywebd's execution. In the shellcode below, several
    instructions are added to the start of loopback_shell.s. First, the fork syscall
    is made, and the return value is put in the EAX register. The next few instructions
    test to see if EAX is zero. If EAX is zero, we jump to `child_process` to spawn
    the shell. Otherwise, we're in the parent process, so the shellcode restores execution
    into tinywebd.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在难题已经解决，我们可以使用这个技术来静默地启动一个root shell。由于shell是交互式的，但我们仍然希望进程处理web请求，因此我们需要进行进程的fork。`fork()`调用创建了一个子进程，它是父进程的精确副本，除了在子进程中返回`0`，而在父进程中返回新的进程ID。我们希望我们的shellcode能够fork，并且子进程提供root
    shell，而父进程恢复tinywebd的执行。在下面的shellcode中，loopback_shell.s的开头添加了几条指令。首先，执行fork系统调用，并将返回值存入EAX寄存器。接下来的几条指令检查EAX是否为零。如果EAX为零，我们跳转到`child_process`以启动shell。否则，我们处于父进程中，因此shellcode将执行恢复到tinywebd。
- en: loopback_shell_restore.s
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: loopback_shell_restore.s
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The following listing shows this shellcode in use. Multiple jobs are used instead
    of multiple terminals, so the netcat listener is sent to the background by ending
    the command with an ampersand (&). After the shell connects back, the `fg` command
    brings the listener back to the foreground. The process is then suspended by hitting
    CTRL-Z, which returns to the BASH shell. It might be easier for you to use multiple
    terminals as you are following along, but job control is useful to know for those
    times when you don't have the luxury of multiple terminals.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了此shellcode的使用情况。使用多个作业而不是多个终端，因此将netcat监听器通过在命令末尾添加一个&符号发送到后台。在shell连接回来后，`fg`命令将监听器带回前台。然后通过按CTRL-Z挂起进程，返回到BASH
    shell。您可能更容易使用多个终端来跟随，但了解作业控制对于您没有多个终端的奢侈情况是有用的。
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this shellcode, the connect-back root shell is maintained by a separate
    child process, while the parent process continues to serve web content.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此shellcode，连接回的root shell由一个单独的子进程维护，而父进程继续提供web内容。
- en: Advanced Camouflage
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级伪装
- en: Our current stealth exploit only camouflages the web request; however, the IP
    address and timestamp are still written to the log file. This type of camouflage
    will make the attacks harder to find, but they are not invisible. Having your
    IP address written to logs that could be kept for years might lead to trouble
    in the future. Since we're mucking around with the insides of the tinyweb daemon
    now, we should be able to hide our presence even better.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的隐蔽漏洞仅伪装了web请求；然而，IP地址和时间戳仍然被写入日志文件。这种伪装会使攻击更难被发现，但它们并不是无形的。如果您的IP地址被写入可能保存多年的日志，可能会在未来引起麻烦。由于我们现在正在处理tinyweb守护进程的内部，我们应该能够更好地隐藏我们的存在。
- en: Spoofing the Logged IP Address
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪造记录的IP地址
- en: The IP address written to the log file comes from the `client_addr_ptr`, which
    is passed to `handle_connection()`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 写入日志文件的IP地址来自`client_addr_ptr`，它被传递给`handle_connection()`。
- en: Code Segment from tinywebd.c
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tinywebd.c的代码段
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To spoof the IP address, we just need to inject our own `sockaddr_in` structure
    and overwrite the `client_addr_ptr` with the address of the injected structure.
    The best way to generate a `sockaddr_in` structure for injection is to write a
    little C program that creates and dumps the structure. The following source code
    builds the struct using command-line arguments and then writes the struct data
    directly to file descriptor 1, which is standard output.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要伪造IP地址，我们只需要注入我们自己的`sockaddr_in`结构，并用注入结构的地址覆盖`client_addr_ptr`。生成用于注入的`sockaddr_in`结构的最佳方式是编写一个小型的C程序来创建和转储该结构。以下源代码使用命令行参数构建结构，然后将结构数据直接写入文件描述符1，即标准输出。
- en: addr_struct.c
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addr_struct.c
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This program can be used to inject a `sockaddr_in` structure. The output below
    shows the program being compiled and executed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序可以用来注入一个`sockaddr_in`结构。下面的输出显示了程序被编译和执行的情况。
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To integrate this into our exploit, the address structure is injected after
    the fake request but before the NOP sled. Since the fake request is 15 bytes long
    and we know the buffer starts at `0xbffff5c0`, the fake address will be injected
    at `0xbfffff5cf`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此集成到我们的利用中，在伪造请求之后但在NOP sled之前注入地址结构。由于伪造请求长度为15字节，而我们知道缓冲区从`0xbffff5c0`开始，因此伪造的地址将在`0xbfffff5cf`处注入。
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since the `client_addr_ptr` is passed as a second function argument, it will
    be on the stack two dwords after the return address. The following exploit script
    injects a fake address structure and overwrites `client_addr_ptr`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`client_addr_ptr`作为第二个函数参数传递，它将在返回地址后的堆栈上两个dwords处。下面的利用脚本注入一个伪造的地址结构并覆盖`client_addr_ptr`。
- en: xtool_tinywebd_spoof.sh
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xtool_tinywebd_spoof.sh
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The best way to explain exactly what this exploit script does is to watch tinywebd
    from within GDB. In the output below, GDB is used to attach to the running tinywebd
    process, breakpoints are set before the overflow, and the IP portion of the log
    buffer is generated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这个利用脚本确切做什么的最好方法是使用GDB从内部观察tinywebd。在下面的输出中，GDB用于附加到正在运行的tinywebd进程，在溢出之前设置断点，并生成日志缓冲区的IP部分。
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Then, from another terminal, the new spoofing exploit is used to advance execution
    in the debugger.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中，使用新的欺骗利用来在调试器中推进执行。
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Back in the debugging terminal, the first breakpoint is hit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试终端中，第一个断点被触发。
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At the first breakpoint, `client_addr_ptr` is shown to be at `0xbffff7e4` and
    pointing to `0xbffff810`. This is found in memory on the stack two dwords after
    the return address. The second breakpoint is after the overwrite, so the `client_addr_ptr`
    at `0xbffff7e4` is shown to be overwritten with the address of the injected `sockaddr_in`
    structure at `0xbffff5cf`. From here, we can peek at the `log_buffer` before it's
    written out to the log to verify the address injection worked.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个断点处，`client_addr_ptr`显示为位于`0xbffff7e4`并指向`0xbffff810`。这在返回地址后的堆栈上的内存中找到，距离返回地址两个dwords。第二个断点是在覆盖之后，因此`client_addr_ptr`在`0xbffff7e4`处被显示为被覆盖为注入的`sockaddr_in`结构地址`0xbffff5cf`。从这里，我们可以在写入日志之前查看`log_buffer`以验证地址注入是否成功。
- en: Logless Exploitation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无日志利用
- en: Ideally, we want to leave no trace at all. In the setup on the LiveCD, technically
    you can just delete the log files after you get a root shell. However, let's assume
    this program is part of a secure infrastructure where the log files are mirrored
    to a secure logging server that has minimal access or maybe even a line printer.
    In these cases, deleting the log files after the fact is not an option. The `timestamp()`
    function in the tinyweb daemon tries to be secure by writing directly to an open
    file descriptor. We can't stop this function from being called, and we can't undo
    the write it does to the log file. This would be a fairly effective countermeasure;
    however, it was implemented poorly. In fact, in the previous exploit, we stumbled
    upon this problem.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望完全不留下任何痕迹。在LiveCD的设置中，技术上你可以在获得root shell后直接删除日志文件。然而，让我们假设这个程序是安全基础设施的一部分，其中日志文件被镜像到一个具有最小访问权限或甚至可能是一个行式打印机的安全日志服务器。在这些情况下，在事后删除日志文件不是一种选择。tinyweb守护进程中的`timestamp()`函数试图通过直接写入一个打开的文件描述符来提高安全性。我们无法阻止调用此函数，也无法撤销它对日志文件所做的写入。这将是一个相当有效的对策；然而，它的实现并不好。实际上，在前一个利用中，我们偶然发现了这个问题。
- en: Even though `logfd` is a global variable, it is also passed to `handle_connection()`as
    a function argument. From the discussion of functional context, you should remember
    that this creates another stack variable with the same name, `logfd`.Since this
    argument is found right after the `client_addr_ptr` on the stack, it gets partially
    overwritten by the null terminator and the extra `0x0a` byte found at the end
    of the exploit buffer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`logfd`是一个全局变量，但它也被作为函数参数传递给`handle_connection()`。从功能上下文的讨论中，你应该记得这会创建另一个具有相同名称的堆栈变量，`logfd`。由于这个参数在堆栈上紧接在`client_addr_ptr`之后，它被null终止符和在利用缓冲区末尾发现的额外的`0x0a`字节部分覆盖。
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As long as the log file descriptor doesn't happen to be 2560 (`0x0a00` in hexadecimal),
    every time `handle_connection()` tries to write to the log it will fail. This
    effect can be quickly explored using strace. In the output below, strace is used
    with the `-p` command-line argument to attach to a running process. The `-e trace=write`
    argument tells strace to only look at write calls. Once again, the spoofing exploit
    tool is used in another terminal to connect and advance execution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 strace 快速探索这个效果。在下面的输出中，strace 使用 `-p` 命令行参数附加到一个正在运行的过程。`-e trace=write`
    参数告诉 strace 只查看写入调用。再次使用另一个终端中的伪造漏洞利用工具来连接并推进执行。
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This output clearly shows the attempts to write to the log file failing. Normally,
    we wouldn't be able to overwrite the `logfd` variable, since the `client_addr_ptr`
    is in the way. Carelessly mangling this pointer will usually lead to a crash.
    But since we've made sure this variable points to valid memory (our injected spoofed
    address structure), we're free to overwrite the variables that lie beyond it.
    Since the tinyweb daemon redirects standard out to /dev/null, the next exploit
    script will overwrite the passed `logfd` variable with `1`, for standard output.
    This will still prevent entries from being written to the log file but in a much
    nicer way—without errors.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出清楚地显示了尝试写入日志文件失败的情况。通常情况下，我们无法覆盖 `logfd` 变量，因为 `client_addr_ptr` 在路上。粗心大意地篡改这个指针通常会导致崩溃。但既然我们已经确保这个变量指向有效的内存（我们注入的伪造地址结构），我们就自由地覆盖它之后的变量。由于
    tinyweb 守护进程将标准输出重定向到 /dev/null，下一个漏洞利用脚本将覆盖传递的 `logfd` 变量，使其为 `1`，用于标准输出。这仍然会阻止条目写入日志文件，但方式更加优雅——没有错误。
- en: xtool_tinywebd_silent.sh
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xtool_tinywebd_silent.sh
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When this script is used, the exploit is totally silent and nothing is written
    to the log file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此脚本时，漏洞利用是完全静默的，并且不会将任何内容写入日志文件。
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice the log file's size and access time remain the same. Using this technique,
    we can exploit tinywebd without leaving any trace in the log files. In addition,
    the write calls execute cleanly, as everything is written to /dev/null. This is
    shown by strace in the output below, when the silent exploit tool is run in another
    terminal.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意日志文件的大小和访问时间保持不变。使用这种技术，我们可以利用 tinywebd 而不会在日志文件中留下任何痕迹。此外，写入调用执行得干净利落，因为所有内容都写入到
    /dev/null。这通过下面的输出中的 strace 显示出来，当在另一个终端中运行静默漏洞利用工具时。
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The Whole Infrastructure
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整个基础设施
- en: As always, details can be hidden in the bigger picture. A single host usually
    exists within some sort of infrastructure. Countermeasures such as intrusion detection
    systems (IDS) and intrusion prevention systems (IPS) can detect abnormal network
    traffic. Even simple log files on routers and firewalls can reveal abnormal connections
    that are indicative of an intrusion. In particular, the connection to port 31337
    used in our connect-back shellcode is a big red flag. We could change the port
    to something that looks less suspicious; however, simply having a webserver open
    outbound connections could be a red flag by itself. A highly secure infrastructure
    might even have the firewall setup with egress filters to prevent outbound connections.
    In these situations, opening a new connection is either impossible or will be
    detected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，细节可能隐藏在更大的画面中。单个主机通常存在于某种基础设施中。如入侵检测系统（IDS）和入侵预防系统（IPS）之类的对策可以检测异常网络流量。即使是路由器和防火墙上的简单日志文件也可能揭示出异常连接，这些连接表明了入侵。特别是，我们用于连接回
    shellcode 的端口 31337 是一个明显的红旗。我们可以将其更改为看起来不那么可疑的端口；然而，仅仅有一个 web 服务器打开出站连接本身就可能是红旗。一个高度安全的设施甚至可能配置了防火墙出口过滤器来防止出站连接。在这些情况下，打开新的连接要么是不可能的，要么会被检测到。
- en: Socket Reuse
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket 重用
- en: In our case, there's really no need to open a new connection, since we already
    have an open socket from the web request. Since we're mucking around inside the
    tinyweb daemon, with a little debugging we can reuse the existing socket for the
    root shell. This prevents additional TCP connections from being logged and allows
    exploitation in cases where the target host cannot open outbound connections.
    Take a look at the source code from tinywebd.c shown below.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，实际上没有必要打开一个新的连接，因为我们已经从网络请求中获得了打开的套接字。由于我们在 tinyweb 守护进程内部捣鼓，通过一点调试，我们可以重用现有的套接字来获取
    root shell。这防止了额外的 TCP 连接被记录，并允许在目标主机无法打开出站连接的情况下进行利用。请查看下面的 tinywebd.c 源代码。
- en: Excerpt from tinywebd.c
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tinywebd.c 的摘录
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unfortunately, the `sockfd` passed to `handle_connection()` will inevitably
    be overwritten so we can overwrite `logfd`. This overwrite happens before we gain
    control of the program in the shellcode, so there's no way to recover the previous
    value of `sockfd`. Luckily, `main()` keeps another copy of the socket's file descriptor
    in `new_sockfd`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，传递给 `handle_connection()` 的 `sockfd` 将不可避免地被覆盖，因此我们可以覆盖 `logfd`。这种覆盖发生在我们通过
    shellcode 控制程序之前，所以无法恢复 `sockfd` 的原始值。幸运的是，`main()` 函数在 `new_sockfd` 中保留了套接字的文件描述符的另一个副本。
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After the breakpoint is set and the program continues, the silent exploit tool
    is used from another terminal to connect and advance execution.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置断点并继续程序之后，另一个终端中的静默利用工具被用来连接并推进执行。
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This debugging output shows that `new_sockfd` is stored at `0xbffff83c` within
    main's stack frame. Using this, we can create shellcode that uses the socket file
    descriptor stored here instead of creating a new connection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调试输出显示 `new_sockfd` 存储在 main 函数的栈帧中的 `0xbffff83c`。利用这个信息，我们可以创建使用此处存储的套接字文件描述符的
    shellcode，而不是创建新的连接。
- en: While we could just use this address directly, there are many little things
    that can shift stack memory around. If this happens and the shellcode is using
    a hard-coded stack address, the exploit will fail. To make the shellcode more
    reliable, take a cue from how the compiler handles stack variables. If we use
    an address relative to ESP, then even if the stack shifts around a bit, the address
    of `new_sockfd` will still be correct since the offset from ESP will be the same.
    As you may remember from debugging with the `mark_break` shellcode, ESP was `0xbffff7e0`.
    Using this value for ESP, the offset is shown to be `0x5c` bytes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以直接使用这个地址，但有许多小事情可能会改变栈内存的位置。如果发生这种情况，并且 shellcode 使用硬编码的栈地址，则利用将失败。为了使
    shellcode 更可靠，可以借鉴编译器处理栈变量的方式。如果我们使用相对于 ESP 的地址，那么即使栈移动了一点点，`new_sockfd` 的地址仍然会正确，因为从
    ESP 的偏移量将是相同的。如您从使用 `mark_break` shellcode 进行调试中记得的那样，ESP 是 `0xbffff7e0`。使用这个值作为
    ESP，偏移量显示为 `0x5c` 字节。
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The following shellcode reuses the existing socket for the root shell.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shellcode 重新使用现有的套接字以用于 root shell。
- en: socket_reuse_restore.s
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: socket_reuse_restore.s
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To effectively use this shellcode, we need another exploitation tool that lets
    us send the exploit buffer but keeps the socket out for further I/O. This second
    exploit script adds an additional `cat -` command to the end of the exploit buffer.
    The dash argument means standard input. Running cat on standard input is somewhat
    useless in itself, but when the command is piped into netcat, this effectively
    ties standard input and output to netcat's network socket. The script below connects
    to the target, sends the exploit buffer, and then keeps the socket open and gets
    further input from the terminal. This is done with just a few modifications (shown
    in bold) to the silent exploit tool.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用这个 shellcode，我们需要另一个利用工具，它允许我们发送利用缓冲区，但保持套接字用于进一步的 I/O。这个第二个利用脚本在利用缓冲区的末尾添加了一个额外的
    `cat -` 命令。破折号参数表示标准输入。在标准输入上运行 cat 本身可能有些无意义，但当命令被管道传输到 netcat 时，这实际上将标准输入和输出绑定到
    netcat 的网络套接字。下面的脚本连接到目标，发送利用缓冲区，然后保持套接字打开并从终端获取进一步的输入。这是通过对静默利用工具进行少量修改（以粗体显示）来实现的。
- en: xtool_tinywebd_reuse.sh
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: xtool_tinywebd_reuse.sh
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When this tool is used with the socket_reuse_restore shellcode, the root shell
    will be served up using the same socket used for the web request. The following
    output demonstrates this.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个工具与 socket_reuse_restore shellcode 一起使用时，将使用用于 web 请求的相同套接字提供 root shell。下面的输出演示了这一点。
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By reusing the existing socket, this exploit is even quieter since it doesn't
    create any additional connections. Fewer connections mean fewer abnormalities
    for any countermeasures to detect.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新使用现有的套接字，这个利用甚至更安静，因为它不会创建任何额外的连接。更少的连接意味着更少的异常，这有助于检测任何对策。
- en: Payload Smuggling
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 货物走私
- en: The aforementioned network IDS or IPS systems can do more than just track connections—they
    can also inspect the packets themselves. Usually, these systems are looking for
    patterns that would signify an attack. For example, a simple rule looking for
    packets that contain the string `/bin/sh` would catch a lot of packets containing
    shellcode. Our `/bin/sh` string is already slightly obfuscated since it's pushed
    to the stack in four-byte chunks, but a network IDS could also look for packets
    that contain the strings `/bin` and `//sh`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的网络IDS或IPS系统不仅可以跟踪连接，还可以检查数据包本身。通常，这些系统正在寻找表示攻击的图案。例如，一个简单的规则，寻找包含字符串`/bin/sh`的数据包，会捕获很多包含shellcode的数据包。我们的`/bin/sh`字符串已经稍微被混淆了，因为它以四个字节的块推送到堆栈，但网络IDS也可以寻找包含字符串`/bin`和`//sh`的数据包。
- en: These types of network IDS signatures can be fairly effective at catching script
    kiddies who are using exploits they downloaded from the Internet. However, they
    are easily bypassed with custom shellcode that hides any telltale strings.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这类网络IDS签名可以相当有效地捕捉到使用从互联网下载的漏洞的脚本小子。然而，它们很容易被自定义的shellcode绕过，这些shellcode隐藏了任何明显的字符串。
- en: String Encoding
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串编码
- en: To hide the string, we will simply add 5 to each byte in the string. Then, after
    the string has been pushed to the stack, the shellcode will subtract 5 from each
    string byte on the stack. This will build the desired string on the stack so it
    can be used in the shellcode, while keeping it hidden during transit. The output
    below shows the calculation of the encoded bytes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏字符串，我们将简单地给字符串中的每个字节加5。然后，在字符串被推送到堆栈后，shellcode将从堆栈上的每个字符串字节减去5。这样就可以在堆栈上构建所需的字符串，以便在shellcode中使用，同时在传输过程中保持其隐藏。下面的输出显示了编码字节的计算。
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The following shellcode pushes these encoded bytes to the stack and then decodes
    them in a loop. Also, two `int3` instructions are used to put breakpoints in the
    shellcode before and after the decoding. This is an easy way to see what's going
    on with GDB.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shellcode将这些编码的字节推送到堆栈，并在循环中解码它们。此外，还使用了两个`int3`指令在解码前后在shellcode中设置断点。这是使用GDB查看正在发生的事情的一种简单方法。
- en: encoded_sockreuserestore_dbg.s
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: encoded_sockreuserestore_dbg.s
- en: '[PRE55]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The decoding loop uses the EDX register as a counter. It begins at 8 and counts
    down to 0, since 8 bytes need to be decoded. Exact stack addresses don't matter
    in this case since the important parts are all relatively addressed, so the output
    below doesn't bother attaching to an existing tinywebd process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 解码循环使用EDX寄存器作为计数器。它从8开始计数到0，因为需要解码8个字节。在这种情况下，确切的堆栈地址并不重要，因为重要的部分都是相对地址的，所以下面的输出没有麻烦地附加到现有的tinywebd进程。
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Since the breakpoints are actually part of the shellcode, there is no need to
    set one from GDB. From another terminal, the shellcode is assembled and used with
    the socket-reusing exploit tool.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断点实际上是shellcode的一部分，因此不需要从GDB设置一个。从另一个终端，shellcode被汇编并使用socket重用漏洞工具。
- en: From Another Terminal
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从另一个终端
- en: '[PRE57]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Back in the GDB window, the first `int3` instruction in the shellcode is hit.
    From here, we can verify that the string decodes properly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回到GDB窗口，shellcode中的第一个`int3`指令被触发。从这里，我们可以验证字符串是否正确解码。
- en: '[PRE58]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that the decoding has been verified, the `int3` instructions can be removed
    from the shellcode. The following output shows the final shellcode being used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解码已经验证，可以从shellcode中移除`int3`指令。以下输出显示了最终使用的shellcode。
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How to Hide a Sled
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何隐藏雪橇
- en: The NOP sled is another signature easy to detect by network IDSes and IPSes.
    Large blocks of `0x90` aren't that common, so if a network security mechanism
    sees something like this, it's probably an exploit. To avoid this signature, we
    can use different single-byte instructions instead of NOP. There are several one-byte
    instructions—the increment and decrement instructions for various registers—that
    are also printable ASCII characters.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: NOP sled是另一种网络IDS和IPS容易检测到的签名。大块的`0x90`并不常见，所以如果网络安全机制看到这样的东西，它很可能是漏洞。为了避免这种签名，我们可以使用不同的单字节指令而不是NOP。有几个单字节指令——为各种寄存器提供增量或减量指令——也是可打印的ASCII字符。
- en: '| Instruction | Hex | ASCII |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 十六进制 | ASCII |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| inc eax | `0x40` | @ |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| inc eax | `0x40` | @ |'
- en: '| inc ebx | `0x43` | C |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| inc ebx | `0x43` | C |'
- en: '| inc ecx | `0x41` | A |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| inc ecx | `0x41` | A |'
- en: '| inc ecx | `0x42` | B |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| inc ecx | `0x42` | B |'
- en: '| dec eax | `0x48` | H |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| dec eax | `0x48` | H |'
- en: '| dec ebx | `0x4B` | K |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| dec ebx | `0x4B` | K |'
- en: '| dec ecx | `0x49` | I |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| dec ecx | `0x49` | I |'
- en: '| dec edx | `0x4A` | J |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| dec edx | `0x4A` | J |'
- en: Since we zero out these registers before we use them, we can safely use a random
    combination of these bytes for the NOP sled. Creating a new exploit tool that
    uses random combinations of the bytes `@, C, A, B, H, K, I`, and `J` instead of
    a regular NOP sled will be left as an exercise for the reader. The easiest way
    to do this would be by writing a sled-generation program in C, which is used with
    a BASH script. This modification will hide the exploit buffer from IDSes that
    look for a NOP sled.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在使用这些寄存器之前将它们清零，我们可以安全地使用这些字节的随机组合来作为NOP sled。创建一个新的利用工具，该工具使用字节的随机组合`@,
    C, A, B, H, K, I`和`J`而不是常规的NOP sled，将留给读者作为练习。最简单的方法是编写一个C语言编写的sled生成程序，该程序与BASH脚本一起使用。这种修改将隐藏利用缓冲区，防止IDS寻找NOP
    sled。
- en: Buffer Restrictions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区限制
- en: Sometimes a program will place certain restrictions on buffers. This type of
    data sanity-checking can prevent many vulnerabilities. Consider the following
    example program, which is used to update product descriptions in a fictitious
    database. The first argument is the product code, and the second is the updated
    description. This program doesn't actually update a database, but it does have
    an obvious vulnerability in it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时程序会对缓冲区施加某些限制。这种数据完整性检查可以防止许多漏洞。考虑以下示例程序，它用于更新虚构数据库中的产品描述。第一个参数是产品代码，第二个参数是更新后的描述。这个程序实际上并没有更新数据库，但它确实存在一个明显的漏洞。
- en: Buffer Restrictions
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区限制
- en: update_info.c
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: update_info.c
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Despite the vulnerability, the code does make an attempt at security. The length
    of the product ID argument is restricted, and the contents of the description
    argument are limited to printable characters. In addition, the unused environment
    variables and program arguments are cleared out for security reasons. The first
    argument (`id`) is too small for shellcode, and since the rest of the stack memory
    is cleared out, there's only one place left.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在漏洞，代码确实尝试进行安全检查。产品ID参数的长度受到限制，描述参数的内容仅限于可打印字符。此外，出于安全原因，未使用的环境变量和程序参数被清除。第一个参数（`id`）对于Shellcode来说太小了，而且由于栈内存的其他部分被清除，只剩下了一个地方。
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This output shows a sample usage and then tries to exploit the vulnerable `strcpy()`
    call. Although the return address can be overwritten using the first argument
    (`id`), the only place we can put shellcode is in the second argument (`desc`).
    However, this buffer is checked for nonprintable bytes. The debugging output below
    confirms that this program could be exploited, if there was a way to put shellcode
    in the description argument.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了示例用法，然后尝试利用有漏洞的`strcpy()`调用。尽管可以通过第一个参数（`id`）覆盖返回地址，但我们唯一可以放置Shellcode的地方是在第二个参数（`desc`）中。然而，这个缓冲区会检查非可打印字节。下面的调试输出确认，如果有一种方法可以将Shellcode放入描述参数中，则此程序可以被利用。
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The printable input validation is the only thing stopping exploitation. Like
    airport security, this input validation loop inspects everything coming in. And
    while it's not possible to avoid this check, there are ways to smuggle illicit
    data past the guards.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可打印输入验证是阻止利用的唯一因素。就像机场安检一样，这个输入验证循环检查所有进入的内容。虽然无法避免这个检查，但有一些方法可以绕过守卫将非法数据偷偷运过。
- en: Polymorphic Printable ASCII Shellcode
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态可打印ASCII Shellcode
- en: Polymorphic shellcode refers to any shellcode that changes itself. The encoding
    shellcode from the previous section is technically polymorphic, since it modifies
    the string it uses while it's running. The new NOP sled uses instructions that
    assemble into printable ASCII bytes. There are other instructions that fall into
    this printable range (from `0x33` to `0x7e`); however, the total set is actually
    rather small.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 多态Shellcode指的是任何会改变自身的Shellcode。上一节中的编码Shellcode在技术上属于多态，因为它在运行时修改了所使用的字符串。新的NOP
    sled使用可以组装成可打印ASCII字节的指令。还有其他指令也属于这个可打印范围（从`0x33`到`0x7e`）；然而，实际上这个集合相当小。
- en: The goal is to write shellcode that will get past the printable character check.
    Trying to write complex shellcode with such a limited instruction set would simply
    be masochistic, so instead, the printable shellcode will use simple methods to
    build more complex shellcode on the stack. In this way, the printable shellcode
    will actually be instructions to make the real shellcode.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是编写能够绕过可打印字符检查的Shellcode。尝试用如此有限的指令集编写复杂的Shellcode将是自虐的，因此，可打印Shellcode将使用简单的方法在栈上构建更复杂的Shellcode。这样，可打印Shellcode实际上将成为生成真实Shellcode的指令。
- en: The first step is figuring out a way to zero out registers. Unfortunately, the
    XOR instruction on the various registers doesn't assemble into the printable ASCII
    character range. One option is to use the AND bitwise operation, which assembles
    into the percent character (%) when using the EAX register. The assembly instruction
    of `and eax, 0x41414141` will assemble to the printable machine code of `%AAAA`,
    since `0x41` in hexadecimal is the printable character *A*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是找出一种方法来清零寄存器。不幸的是，各种寄存器上的XOR指令无法组装成可打印的ASCII字符范围。一个选项是使用AND位操作，当使用EAX寄存器时，它会组装成百分号字符（%）。`and
    eax, 0x41414141`的汇编指令将组装成可打印的机器代码`%AAAA`，因为十六进制的`0x41`是可打印字符*A*。
- en: 'An AND operation transforms bits as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: AND操作按以下方式转换位：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since the only case where the result is 1 is when both bits are 1, if two inverse
    values are ANDed onto EAX, EAX will become zero.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于结果为1的唯一情况是两个位都是1，如果将两个相反的值AND到EAX上，EAX将变为零。
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Thus, by using two printable 32-bit values that are bitwise inverses of each
    other, the EAX register can be zeroed without using any null bytes, and the resulting
    assembled machine code will be printable text.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用两个彼此位逆的32位可打印值，可以在不使用任何空字节的情况下清零EAX寄存器，并且生成的汇编机器代码将是可打印的文本。
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So `%JONE%501:` in machine code will zero out the EAX register. Interesting.
    Some other instructions that assemble into printable ASCII characters are shown
    in the box below.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，机器代码中的`%JONE%501:`将清零EAX寄存器。有趣。下面框中显示了其他一些可以组装成可打印ASCII字符的指令。
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Amazingly, these instructions, combined with the `AND eax` instruction, are
    sufficient to build loader code that will inject the shellcode onto the stack
    and then execute it. The general technique is, first, to set ESP back behind the
    executing loader code (in higher memory addresses), and then to build the shellcode
    from end to start by pushing values onto the stack, as shown here.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这些说明与`AND eax`指令结合，足以构建将shellcode注入堆栈并执行它的加载器代码。一般技术是，首先将ESP设置在执行中的加载器代码之后（在较高的内存地址），然后从后向前构建shellcode，通过将值推入堆栈来实现，如下所示。
- en: Since the stack grows up (from higher memory addresses to lower memory addresses),
    the ESP will move backward as values are pushed to the stack, and the EIP will
    move forward as the loader code executes. Eventually, EIP and ESP will meet up,
    and the EIP will continue executing into the freshly built shellcode.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈向上增长（从较高内存地址到较低内存地址），当值推入堆栈时，ESP会向后移动，而EIP会在加载器代码执行时向前移动。最终，EIP和ESP会相遇，EIP将继续执行新构建的shellcode。
- en: '![](httpatomoreillycomsourcenostarchimages254398.png.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254398.png.jpg)'
- en: Figure 0x600-1.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图0x600-1。
- en: First, ESP must be set behind the printable loader shellcode. A little debugging
    with GDB shows that after gaining control of program execution, ESP is 555 bytes
    before the start of the overflow buffer (which will contain the loader code).
    The ESP register must be moved so it's after the loader code, while still leaving
    room for the new shellcode and for the loader shellcode itself. About 300 bytes
    should be enough room for this, so let's add 860 bytes to ESP to put it 305 bytes
    past the start of the loader code. This value doesn't need to be exact, since
    provisions will be made later to allow for some slop. Since the only usable instruction
    is subtraction, addition can be simulated by subtracting so much from the register
    that it wraps around. The register only has 32 bits of space, so adding 860 to
    a register is the same as subtracting 860 from 2^(32), or 4,294,966,436\. However,
    this subtraction must only use printable values, so we split it up across three
    instructions that all use printable operands.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，ESP必须设置在可打印的加载器shellcode之后。使用GDB进行一点调试显示，在获得程序执行控制权后，ESP在溢出缓冲区开始之前555字节（该缓冲区将包含加载器代码）。ESP寄存器必须移动，使其在加载器代码之后，同时还要留出为新shellcode和加载器shellcode本身留出空间。大约300字节应该足够了，所以让我们给ESP加上860字节，使其在加载器代码开始之后305字节。这个值不需要非常精确，因为稍后会做出一些调整。由于唯一可用的指令是减法，可以通过从寄存器中减去足够的值来模拟加法，这样寄存器就会回绕。寄存器只有32位空间，所以给寄存器加860相当于从2^(32)，即4,294,966,436中减去860。然而，这个减法必须只使用可打印的值，所以我们将其分成三个指令，所有这些指令都使用可打印的操作数。
- en: '[PRE67]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As the GDB output confirms, subtracting these three values from a 32-bit number
    is the same as adding 860 to it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如GDB输出所确认的，从32位数字中减去这三个值等同于向其添加860。
- en: '[PRE68]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The goal is to subtract these values from ESP, not EAX, but the instruction
    `sub esp` doesn't assemble into a printable ASCII character. So the current value
    of ESP must be moved into EAX for the subtraction, and then the new value of EAX
    must be moved back into ESP.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是从ESP而不是EAX中减去这些值，但`sub esp`指令无法汇编成可打印的ASCII字符。因此，必须将ESP的当前值移动到EAX进行减法，然后将新的EAX值移动回ESP。
- en: However, since neither `mov esp, eax` nor `mov eax, esp` assemble into printable
    ASCII characters, this exchange must be done using the stack. By pushing the value
    from the source register to the stack and then popping it off into the destination
    register, the equivalent of a `mov` *`dest, source`* instruction can be accomplished
    with `push` *`source`* and `pop` *`dest`*. Fortunately, the `pop` and `push` instructions
    for both EAX and ESP registers assemble into printable ASCII characters, so this
    can all be done using printable ASCII.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于`mov esp, eax`和`mov eax, esp`这两条指令都无法汇编成可打印的ASCII字符，因此这个交换必须使用堆栈来完成。通过将源寄存器的值推送到堆栈，然后再从目标寄存器中弹出，可以使用`push
    source`和`pop dest`指令完成相当于`mov dest, source`的指令。幸运的是，EAX和ESP寄存器的`pop`和`push`指令可以汇编成可打印的ASCII字符，因此所有这些都可以使用可打印的ASCII来完成。
- en: Here is the final set of instructions to add 860 to ESP.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加860到ESP的最终指令集。
- en: '[PRE69]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This means that `TX-3399-Purr-!TTT-P\` will add 860 to ESP in machine code.
    So far, so good. Now the shellcode must be built.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`TX-3399-Purr-!TTT-P\`将在机器码中将ESP增加860。到目前为止，一切顺利。现在必须构建shellcode。
- en: First, EAX must be zeroed out; this is easy now that a method has been discovered.
    Then, by using more `sub` instructions, the EAX register must be set to the last
    four bytes of the shellcode, in reverse order. Since the stack normally grows
    upward (toward lower memory addresses) and builds with a FILO ordering, the first
    value pushed to the stack must be the last four bytes of the shellcode. These
    bytes must be in reverse order, due to the little-endian byte ordering. The following
    output shows a hexadecimal dump of the standard shellcode used in the previous
    chapters, which will be built by the printable loader code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须将EAX清零；现在发现了一种方法。然后，通过使用更多的`sub`指令，必须将EAX寄存器设置为shellcode的最后四个字节，顺序相反。由于堆栈通常向上增长（向较低的内存地址），并且按照FILO顺序构建，因此推送到堆栈的第一个值必须是shellcode的最后四个字节。这些字节必须顺序相反，因为是小端字节序。以下输出显示了在前面章节中使用的标准shellcode的十六进制转储，这将由可打印加载器代码构建。
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this case, the last four bytes are shown in bold; the proper value for the
    EAX register is `0x80cde189`. This is easy to do by using `sub` instructions to
    wrap the value around. Then, EAX can be pushed to the stack. This moves ESP up
    (toward lower memory addresses) to the end of the newly pushed value, ready for
    the next four bytes of shellcode (shown in italic in the preceding shellcode).
    More `sub` instructions are used to wrap EAX around to `0x53e28951,` and this
    value is then pushed to the stack. As this process is repeated for each four-byte
    chunk, the shellcode is built from end to start, toward the executing loader code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最后四个字节用粗体表示；EAX寄存器的正确值是`0x80cde189`。通过使用`sub`指令来环绕值，这很容易做到。然后，可以将EAX推送到堆栈。这会使ESP向上移动（向较低的内存地址），到达新推入值的末尾，为shellcode的下一个四个字节做好准备（在前面shellcode中用斜体表示）。使用更多的`sub`指令将EAX环绕到`0x53e28951`，然后将这个值推送到堆栈。随着这个过程对每个四个字节的块重复进行，shellcode从后向前构建，向执行加载器代码。
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Eventually, the beginning of the shellcode is reached, but there are only three
    bytes (shown in italic in the preceding shellcode) left after pushing `0x99c931db`
    to the stack. This situation is alleviated by inserting one singlebyte NOP instruction
    at the beginning of the code, resulting in the value `0x31c03190` being pushed
    to the stack—`0x90` is machine code for NOP.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，到达了shellcode的开始部分，但在将`0x99c931db`推送到堆栈后，只剩下三个字节（在前面shellcode中用斜体表示）。通过在代码的开始插入一个单字节NOP指令，可以缓解这种情况，结果将`0x31c03190`值推送到堆栈——`0x90`是NOP指令的机器码。
- en: Each of these four-byte chunks of the original shellcode is generated with the
    printable subtraction method used earlier. The following source code is a program
    to help calculate the necessary printable values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 原始shellcode的每个四个字节的块都是使用之前提到的可打印减法方法生成的。以下源代码是一个帮助计算必要可打印值的程序。
- en: printable_helper.c
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: printable_helper.c
- en: '[PRE72]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When this program is run, it expects two arguments—the start and the end values
    for EAX. For the printable loader shellcode, EAX is zeroed out to start with,
    and the end value should be `0x80cde189`. This value corresponds to the last four
    bytes from shellcode.bin.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序运行时，它期望两个参数——EAX的起始值和结束值。对于可打印的加载器shellcode，EAX以零开始，结束值应该是`0x80cde189`。这个值对应于shellcode.bin的最后四个字节。
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The output above shows the printable values needed to wrap the zeroed EAX register
    around to `0x80cde189` (shown in bold). Next, EAX should be wrapped around again
    to `0x53e28951` for the next four bytes of the shellcode (building backwards).
    This process is repeated until all the shellcode is built. The code for the entire
    process is shown below.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出显示了所需的可打印值，以将清零的EAX寄存器绕回`0x80cde189`（以粗体显示）。接下来，EAX应该再次绕回`0x53e28951`，以构建shellcode的下一个四个字节（反向构建）。这个过程重复进行，直到构建完所有的shellcode。整个过程的代码如下所示。
- en: printable.s
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: printable.s
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: At the end, the shellcode has been built somewhere after the loader code, most
    likely leaving a gap between the newly built shellcode and the executing loader
    code. This gap can be bridged by building a NOP sled between the loader code and
    the shellcode.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，shellcode在加载器代码之后某处构建，很可能是留下一个新构建的shellcode和正在执行的加载器代码之间的间隙。这个间隙可以通过在加载器代码和shellcode之间构建一个NOP
    sled来架起。
- en: Once again, `sub` instructions are used to set EAX to `0x90909090`, and EAX
    is repeatedly pushed to the stack. With each `push` instruction, four NOP instructions
    are tacked onto the beginning of the shellcode. Eventually, these NOP instructions
    will build right over the executing `push` instructions of the loader code, allowing
    the EIP and program execution to flow over the sled into the shellcode.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`sub`指令将EAX设置为`0x90909090`，并且EAX被反复压入栈中。每次`push`指令，都会在shellcode的开始处附加四个NOP指令。最终，这些NOP指令将直接覆盖加载器代码的执行`push`指令，允许EIP和程序执行流过sled进入shellcode。
- en: This assembles into a printable ASCII string, which doubles as executable machine
    code.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将汇编成一个可打印的ASCII字符串，它同时充当可执行机器代码。
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This printable ASCII shellcode can now be used to smuggle the actual shellcode
    past the input-validation routine of the update_info program.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可打印的ASCII shellcode现在可以用来绕过update_info程序的输入验证例程，将实际的shellcode偷偷带过去。
- en: '[PRE76]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Neat. In case you weren't able to follow everything that just happened there,
    the output below watches the execution of the printable shellcode in GDB. The
    stack addresses will be slightly different, changing the return addresses, but
    this won't affect the printable shellcode—it calculates its location based on
    ESP, giving it this versatility.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 真是 neat。如果你没有跟上刚才发生的一切，下面的输出显示了在GDB中观察可打印shellcode的执行情况。栈地址将略有不同，改变返回地址，但这不会影响可打印shellcode——它根据ESP计算其位置，从而赋予它这种灵活性。
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The first nine instructions add 860 to ESP and zero out the EAX register The
    next eight instructions push the last eight bytes of the shellcode to the stack
    in four-byte chunks. This process is repeated in the next 32 instructions to build
    the entire shellcode on the stack.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 前九条指令将860加到ESP上，并将EAX寄存器清零。接下来的八条指令将shellcode的最后八个字节以四个字节为单位压入栈中。这个过程在接下来的32条指令中重复，以在栈上构建整个shellcode。
- en: '[PRE78]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now with the shellcode completely constructed on the stack, EAX is set to `0x90909090`.
    This is pushed to the stack repeatedly to build a NOP sled to bridge the gap between
    the end of the loader code and the newly constructed shellcode.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在shellcode已经完全构建在栈上，EAX被设置为`0x90909090`。这个值被反复压入栈中以构建一个NOP sled，以在加载器代码的末尾和新建的shellcode之间架起桥梁。
- en: '[PRE79]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now the execution pointer (EIP) can flow over the NOP bridge into the constructed
    shellcode.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行指针（EIP）可以流过NOP桥进入构建的shellcode。
- en: Printable shellcode is a technique that can open some doors. It and all the
    other techniques we discussed are just building blocks that can be used in a myriad
    of different combinations. Their application requires some ingenuity on your part.
    Be clever and beat them at their own game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可打印shellcode是一种可以打开一些大门的技术。它以及我们讨论的所有其他技术只是构建块，可以以无数种不同的组合方式使用。它们的应用需要你的一些独创性。要聪明，打败他们自己的游戏。
- en: Hardening Countermeasures
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强型防护措施
- en: 'The exploit techniques demonstrated in this chapter have been around for ages.
    It was only a matter of time for programmers to come up with some clever protection
    methods. An exploit can be generalized as a three-step process: First, some sort
    of memory corruption; then, a change in control flow; and finally, execution of
    the shellcode.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的利用技术已经存在很长时间了。程序员想出一些聪明的保护方法只是时间问题。一个利用可以概括为三个步骤：首先，某种形式的内存损坏；然后，控制流的改变；最后，执行shellcode。
- en: Nonexecutable Stack
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可执行堆栈
- en: Most applications never need to execute anything on the stack, so an obvious
    defense against buffer overflow exploits is to make the stack nonexecutable. When
    this is done, shellcode inserted anywhere on the stack is basically useless. This
    type of defense will stop the majority of exploits out there, and it is becoming
    more popular. The latest version of OpenBSD has a nonexecutable stack by default,
    and a nonexecutable stack is available in Linux through PaX, a kernel patch.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序不需要在堆栈上执行任何操作，因此针对缓冲区溢出攻击的一种明显防御措施是使堆栈不可执行。当这样做时，堆栈上插入的任何shellcode基本上都是无用的。这种防御措施将阻止大多数现有的攻击，并且越来越受欢迎。OpenBSD的最新版本默认具有不可执行的堆栈，而Linux通过PaX内核补丁也提供了不可执行的堆栈。
- en: ret2libc
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ret2libc
- en: Of course, there exists a technique used to bypass this protective countermeasure.
    This technique is known as *returning into libc*. libc is a standard C library
    that contains various basic functions, such as `printf()` and `exit()`. These
    functions are shared, so any program that uses the `printf()` function directs
    execution into the appropriate location in libc. An exploit can do the exact same
    thing and direct a program's execution into a certain function in libc. The functionality
    of such an exploit is limited by the functions in libc, which is a significant
    restriction when compared to arbitrary shellcode. However, nothing is ever executed
    on the stack.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，存在一种绕过这种保护措施的技术。这种技术被称为“返回到libc”。libc是一个标准的C库，包含各种基本函数，如`printf()`和`exit()`。这些函数是共享的，所以任何使用`printf()`函数的程序都会将执行引导到libc中的适当位置。一个利用可以做到完全相同的事情，并将程序的执行引导到libc中的某个函数。这种利用的功能受限于libc中的函数，与任意shellcode相比，这是一个重大的限制。然而，堆栈上从未执行过任何操作。
- en: Returning into system()
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回到system()
- en: One of the simplest libc functions to return into is `system()`. As you recall,
    this function takes a single argument and executes that argument with /bin/sh.
    This function only needs a single argument, which makes it a useful target. For
    this example, a simple vulnerable program will be used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`system()`函数是返回到libc中最简单的函数之一。如您所记得，这个函数接受一个参数，并使用`/bin/sh`执行该参数。这个函数只需要一个参数，这使得它成为一个有用的目标。在这个例子中，将使用一个简单的脆弱程序。
- en: vuln.c
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: vuln.c
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Of course, this program must be compiled and setuid root before it's truly vulnerable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个程序在真正变得脆弱之前必须编译并设置setuid root权限。
- en: '[PRE81]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The general idea is to force the vulnerable program to spawn a shell, without
    executing anything on the stack, by returning into the libc function `system()`.
    If this function is supplied with the argument of `/bin/sh`, this should spawn
    a shell.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通用思路是通过返回到libc函数`system()`，强制脆弱程序产生一个shell，而不在堆栈上执行任何操作。如果这个函数提供了`/bin/sh`作为参数，这将产生一个shell。
- en: 'First, the location of the `system()` function in libc must be determined.
    This will be different for every system, but once the location is known, it will
    remain the same until libc is recompiled. One of the easiest ways to find the
    location of a libc function is to create a simple dummy program and debug it,
    like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，必须确定libc中`system()`函数的位置。这会因系统而异，但一旦知道了位置，它将保持不变，直到libc重新编译。找到libc函数位置的最简单方法之一是创建一个简单的虚拟程序并对其进行调试，如下所示：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, a dummy program is created that uses the `system()` function. After it's
    compiled, the binary is opened in a debugger and a breakpoint is set at the beginning.
    The program is executed, and then the location of the `system()` function is displayed.
    In this case, the `system()` function is located at `0xb7ed0d80`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个使用`system()`函数的虚拟程序。编译后，在调试器中打开二进制文件并设置一个断点在开始处。执行程序，然后显示`system()`函数的位置。在这种情况下，`system()`函数位于`0xb7ed0d80`。
- en: 'Armed with that knowledge, we can direct program execution into the `system()`
    function of libc. However, the goal here is to cause the vulnerable program to
    execute `system("/bin/sh")` to provide a shell, so an argument must be supplied.
    When returning into libc, the return address and function arguments are read off
    the stack in what should be a familiar format: the return address followed by
    the arguments. On the stack, the return-into-libc call should look something like
    this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，我们可以将程序执行引导到 libc 的 `system()` 函数。然而，这里的目的是使易受攻击的程序执行 `system("/bin/sh")`
    以提供 shell，因此必须提供一个参数。当返回到 libc 时，返回地址和函数参数将从堆栈中读取，其格式应该是熟悉的：返回地址后跟参数。在堆栈上，返回到
    libc 的调用应该看起来像这样：
- en: '![](httpatomoreillycomsourcenostarchimages254392.png.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254392.png.jpg)'
- en: Figure 0x600-2.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x600-2。
- en: Directly after the address of the desired libc function is the address to which
    execution should return after the libc call. After that, all of the function arguments
    come in sequence.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在期望的 libc 函数地址之后，是执行完 libc 调用后应返回的地址。之后，所有函数参数按顺序排列。
- en: In this case, it doesn't really matter where the execution returns to after
    the libc call, since it will be opening an interactive shell. Therefore, these
    four bytes can just be a placeholder value of `FAKE`. There is only one argument,
    which should be a pointer to the string `/bin/sh`. This string can be stored anywhere
    in memory; an environment variable is an excellent candidate. In the output below,
    the string is prefixed with several spaces. This will act similarly to a NOP sled,
    providing us with some wiggle room, since `system(" /bin/sh")` is the same as
    `system(" /bin/sh")`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在 libc 调用之后执行流程返回的位置并不重要，因为它将打开一个交互式 shell。因此，这四个字节可以是 `FAKE` 的占位符值。只有一个参数，它应该是指向字符串
    `/bin/sh` 的指针。此字符串可以存储在内存中的任何位置；环境变量是一个很好的候选者。在下面的输出中，字符串前面加了几空格。这将类似于 NOP 滑梯，为我们提供一些操作空间，因为
    `system(" /bin/sh")` 与 `system(" /bin/sh")` 相同。
- en: '[PRE83]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: So the `system()` address is `0xb7ed0d80`, and the address for the `/bin/sh`
    string will be `0xbffffe5b` when the program is executed. That means the return
    address on the stack should be overwritten with a series of addresses, beginning
    with `0xb7ecfd80`, followed by `FAKE` (since it doesn't matter where execution
    goes after the `system()` call), and concluding with `0xbffffe5b`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`system()` 地址是 `0xb7ed0d80`，当程序执行时，`/bin/sh` 字符串的地址将是 `0xbffffe5b`。这意味着堆栈上的返回地址应该被一系列地址覆盖，首先是
    `0xb7ecfd80`，然后是 `FAKE`（因为 `system()` 调用之后执行流程的走向并不重要），最后是 `0xbffffe5b`。
- en: A quick binary search shows that the return address is probably overwritten
    by the eighth word of the program input, so seven words of dummy data are used
    for spacing in the exploit.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 快速二分搜索显示，返回地址很可能被程序输入的第八个单词覆盖，因此在漏洞利用中使用了七个字节的哑数据来填充空间。
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The exploit can be expanded upon by making chained libc calls, if needed. The
    return address of `FAKE` used in the example can be changed to direct program
    execution. Additional libc calls can be made, or execution can be directed into
    some other useful section in the program's existing instructions.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以通过创建链式 libc 调用来扩展漏洞利用。示例中使用的 `FAKE` 的返回地址可以更改，以引导程序执行。可以执行额外的 libc 调用，或者将执行流程引导到程序现有指令中的其他有用部分。
- en: Randomized Stack Space
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机化堆栈空间
- en: Another protective countermeasure tries a slightly different approach. Instead
    of preventing execution on the stack, this countermeasure randomizes the stack
    memory layout. When the memory layout is randomized, the attacker won't be able
    to return execution into waiting shellcode, since he won't know where it is.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种防护对策尝试了一种稍微不同的方法。它不是防止在堆栈上执行，而是随机化堆栈内存布局。当内存布局被随机化时，攻击者将无法将执行流程返回到等待的 shellcode，因为他不知道它的位置。
- en: This countermeasure has been enabled by default in the Linux kernel since 2.6.12,
    but this book's LiveCD has been configured with it turned off. To turn this protection
    on again, echo `1` to the /proc filesystem as shown below.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Linux 内核 2.6.12 版本以来，此对策默认启用，但本书的 LiveCD 已配置为关闭。要再次启用此保护，请按照以下所示将 `1` 输出到
    /proc 文件系统。
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With this countermeasure turned on, the notesearch exploit no longer works,
    since the layout of the stack is randomized. Every time a program starts, the
    stack begins at a random location. The following example demonstrates this.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此对策后，notesearch 漏洞利用不再有效，因为堆栈布局已被随机化。每次程序启动时，堆栈从随机位置开始。以下示例演示了这一点。
- en: Randomized Stack Space
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机化栈空间
- en: aslr_demo.c
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aslr_demo.c
- en: '[PRE86]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This program has an obvious buffer overflow vulnerability in it. However with
    ASLR turned on, exploitation isn't that easy.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中有一个明显的缓冲区溢出漏洞。然而，当开启ASLR时，利用并不那么容易。
- en: '[PRE87]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Notice how the location of the buffer on the stack changes with every run. We
    can still inject the shellcode and corrupt memory to overwrite the return address,
    but we don't know where the shellcode is in memory. The randomization changes
    the location of everything on the stack, including environment variables.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缓冲区在栈上的位置在每次运行时都会改变。我们仍然可以注入shellcode并损坏内存以覆盖返回地址，但我们不知道shellcode在内存中的位置。随机化改变了栈上所有内容的地址，包括环境变量。
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: This type of protection can be very effective in stopping exploits by the average
    attacker, but it isn't always enough to stop a determined hacker. Can you think
    of a way to successfully exploit this program under these conditions?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保护措施可以非常有效地阻止普通攻击者的攻击，但并不总是足以阻止一个有决心的黑客。你能想到一种方法在这些条件下成功利用这个程序吗？
- en: Investigations with BASH and GDB
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BASH和GDB进行调查
- en: Since ASLR doesn't stop the memory corruption, we can still use a bruteforcing
    BASH script to figure out the offset to the return address from the beginning
    of the buffer. When a program exits, the value returned from the main function
    is the exit status. This status is stored in the BASH variable $?, which can be
    used to detect whether the program crashed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ASLR并不能阻止内存损坏，我们仍然可以使用一个暴力破解的BASH脚本来找出从缓冲区开始到返回地址的偏移量。当程序退出时，主函数返回的值是退出状态。这个状态存储在BASH变量$?中，可以用来检测程序是否崩溃。
- en: '[PRE89]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Using BASH's `if` statement logic, we can stop our brute-forcing script when
    it crashes the target. The `if` statement block is contained between the keywords
    `then` and `fi`; the white space in the `if` statement is required. The `break`
    statement tells the script to break out of the `for` loop.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BASH的`if`语句逻辑，当脚本崩溃时，我们可以停止我们的暴力破解脚本。`if`语句块包含在关键字`then`和`fi`之间；`if`语句中的空白是必需的。`break`语句告诉脚本跳出`for`循环。
- en: '[PRE90]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Knowing the proper offset will let us overwrite the return address. However,
    we still cannot execute shellcode since its location is randomized. Using GDB,
    let's look at the program just as it's about to return from the main function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 知道正确的偏移量将使我们能够覆盖返回地址。然而，我们仍然不能执行shellcode，因为它的位置是随机的。使用GDB，让我们看看程序在即将从主函数返回时的状态。
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The breakpoint is set at the last instruction of `main`. This instruction returns
    EIP to the return address stored on the stack. When an exploit overwrites the
    return address, this is the last instruction where the original program has control.
    Let's take a look at the registers at this point in the code for a couple of different
    trial runs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 断点设置在`main`函数的最后一条指令。这条指令将EIP返回到栈上存储的返回地址。当利用覆盖返回地址时，这是原始程序最后控制的指令。让我们看看在代码的这个点，几个不同试验运行时的寄存器。
- en: '[PRE92]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Despite the randomization between runs, notice how similar the address in ESP
    is to the address of the buffer (shown in bold). This makes sense, since the stack
    pointer points to the stack and the buffer is on the stack. ESP's value and the
    buffer's address are changed by the same random value, because they are relative
    to each other.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在运行之间有随机化，但请注意ESP中的地址与缓冲区地址（以粗体显示）的相似性。这是有道理的，因为栈指针指向栈，而缓冲区在栈上。ESP的值和缓冲区的地址由相同的随机值改变，因为它们是相对的。
- en: GDB's `stepi` command steps the program forward in execution by a single instruction.
    Using this, we can check ESP's value after the `ret` instruction has executed.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: GDB的`stepi`命令通过单条指令向前执行程序。使用这个命令，我们可以检查`ret`指令执行后的ESP值。
- en: '[PRE93]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Single stepping shows that the `ret` instruction increases the value of ESP
    by 4\. Subtracting the value of ESP from the address of the buffer, we find that
    ESP is pointing 80 bytes (or 20 words) from the start of the buffer. Since the
    return address's offset was 19 words, this means that after `main`'s final `ret`
    instruction, ESP points to stack memory found directly after the return address.
    This would be useful if there was a way to control EIP to go where ESP is pointing
    instead.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 单步执行显示`ret`指令将ESP的值增加4。从ESP的值减去缓冲区的地址，我们发现ESP指向从缓冲区开始80字节（或20个单词）的栈内存。由于返回地址的偏移量是19个单词，这意味着在`main`的最终`ret`指令之后，ESP指向返回地址之后直接找到的栈内存。如果有一种方法可以控制EIP指向ESP所指向的位置，这将是有用的。
- en: Bouncing Off linux-gate
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用linux-gate反弹
- en: The technique described below doesn't work with Linux kernels starting from
    2.6.18\. This technique gained some popularity and, of course, the developers
    patched the problem. The kernel used in the included LiveCD is 2.6.20, so the
    output below is from the machine loki, which is running a 2.6.17 Linux kernel.
    Even though this particular technique doesn't work on the LiveCD, the concepts
    behind it can be applied in other useful ways.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下面描述的技术从2.6.18开始的Linux内核版本不再适用。这项技术获得了一些流行度，当然，开发者们修补了这个问题。包含在LiveCD中的内核版本是2.6.20，因此下面的输出来自名为loki的机器，该机器运行的是2.6.17版本的Linux内核。尽管这个特定的技术不适用于LiveCD，但其背后的概念可以以其他有用的方式应用。
- en: '*Bouncing off linux-gate* refers to a shared object, exposed by the kernel,
    which looks like a shared library. The program ldd shows a program''s shared library
    dependencies. Do you notice anything interesting about the linux-gate library
    in the output below?'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*从linux-gate跳转*指的是由内核暴露的共享对象，它看起来像是一个共享库。程序ldd显示了程序的共享库依赖关系。你注意到下面输出中的linux-gate库有什么有趣的地方吗？'
- en: '[PRE94]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Even in different programs and with ASLR enabled, linux-gate.so.1 is always
    present at the same address. This is a virtual dynamically shared object used
    by the kernel to speed up system calls, which means it's needed in every process.
    It is loaded straight from the kernel and doesn't exist anywhere on disk.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在不同的程序和启用ASLR的情况下，linux-gate.so.1总是出现在相同的地址。这是一个由内核使用的虚拟动态共享对象，用于加速系统调用，这意味着它在每个进程中都是必需的。它直接从内核加载，并且不存在于磁盘上的任何地方。
- en: The important thing is that every process has a block of memory containing linux-gate's
    instructions, which are always at the same location, even with ASLR. We are going
    to search this memory space for a certain assembly instruction, `jmp esp`. This
    instruction will jump EIP to where ESP is pointing.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，每个进程都有一个包含linux-gate指令的内存块，这些指令的位置总是相同的，即使在ASLR的情况下。我们将在这个内存空间中搜索特定的汇编指令，`jmp
    esp`。这个指令将使EIP跳转到ESP指向的位置。
- en: First, we assemble the instruction to see what it looks like in machine code.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们组装指令，看看它在机器代码中的样子。
- en: '[PRE95]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Using this information, a simple program can be written to find this pattern
    in the program's own memory.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，可以编写一个简单的程序来在程序的自身内存中找到这个模式。
- en: find_jmpesp.c
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: find_jmpesp.c
- en: '[PRE96]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When the program is compiled and run, it shows that this instruction exists
    at `0xffffe777`. This can be further verified using GDB:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序编译并运行时，它显示这个指令存在于`0xffffe777`。这可以通过GDB进一步验证：
- en: '[PRE97]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Putting it all together, if we overwrite the return address with the address
    `0xffffe777`, then execution will jump into linux-gate when the main function
    returns. Since this is a `jmp esp` instruction, execution will immediately jump
    back out of linux-gate to wherever ESP happens to be pointing. From our previous
    debugging, we know that at the end of the main function, ESP is pointing to memory
    directly after the return address. So if shellcode is put here, EIP should bounce
    right into it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，如果我们用地址`0xffffe777`覆盖返回地址，那么当主函数返回时，执行将跳转到linux-gate。由于这是一个`jmp esp`指令，执行将立即从linux-gate跳回到ESP指向的地方。根据我们之前的调试，我们知道在主函数的末尾，ESP指向返回地址之后的内存。所以如果在这里放置shellcode，EIP应该会直接跳入其中。
- en: '[PRE98]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This technique can also be used to exploit the notesearch program, as shown
    here.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术也可以用来利用notesearch程序，如下所示。
- en: '[PRE99]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The initial estimate of 35 words was off, since the program still crashed with
    the slightly smaller exploit buffer. But it is in the right ballpark, so a manual
    tweak (or a more accurate way to calculate the offset) is all that is needed.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的35个单词的估计不准确，因为程序仍然在稍微小一点的利用缓冲区中崩溃。但它在正确的范围内，所以只需要手动调整（或更精确地计算偏移量）即可。
- en: Sure, bouncing off linux-gate is a slick trick, but it only works with older
    Linux kernels. Back on the LiveCD, running Linux 2.6.20, the useful instruction
    is no longer found in the usual address space.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，从linux-gate跳转是一个巧妙的技巧，但它只适用于较旧的Linux内核。回到LiveCD上，运行Linux 2.6.20，有用的指令不再在通常的地址空间中找到。
- en: '[PRE100]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Without the `jmp esp` instruction at a predictable address, there is no easy
    way to bounce off of linux-gate. Can you think of a way to bypass ASLR to exploit
    aslr_demo on the LiveCD?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 没有在可预测地址的`jmp esp`指令，就没有简单的方法从linux-gate跳转。你能想到绕过ASLR来在LiveCD上的aslr_demo进行利用的方法吗？
- en: Applied Knowledge
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用知识
- en: Situations like this are what makes hacking an art. The state of computer security
    is a constantly changing landscape, and specific vulnerabilities are discovered
    and patched every day. However, if you understand the concepts of the core hacking
    techniques explained in this book, you can apply them in new and inventive ways
    to solve the problem du jour. Like LEGO bricks, these techniques can be used in
    millions of different combinations and configurations. As with any art, the more
    you practice these techniques, the better you'll understand them. With this understanding
    comes the wisdom to guesstimate offsets and recognize memory segments by their
    address ranges.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况正是使黑客技术成为一门艺术的原因。计算机安全的状态是一个不断变化的景观，每天都会发现和修补特定的漏洞。然而，如果你理解了本书中解释的核心黑客技术概念，你就可以以新的和创造性的方式应用它们来解决当天的难题。就像乐高积木一样，这些技术可以用数百万种不同的组合和配置来使用。就像任何艺术一样，你练习这些技术的次数越多，你对它们的理解就会越好。这种理解带来了猜测偏移量和通过地址范围识别内存段的知识。
- en: In this case, the problem is still ASLR. Hopefully, you have a few bypass ideas
    you might want to try out now. Don't be afraid to use the debugger to examine
    what is actually happening. There are probably several ways to bypass ASLR, and
    you may invent a new technique. If you don't find a solution, don't worry—I'll
    explain a method in the next section. But it's worthwhile to think about this
    problem a little on your own before reading ahead.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，问题仍然是ASLR。希望你现在有几个绕过的想法可以尝试。不要害怕使用调试器来检查实际发生的情况。可能存在几种绕过ASLR的方法，你可能会发明一种新技术。如果你找不到解决方案，不要担心——我将在下一节中解释一种方法。但在继续阅读之前，花点时间自己思考一下这个问题是值得的。
- en: A First Attempt
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次尝试
- en: In fact, I had written this chapter before linux-gate was fixed in the Linux
    kernel, so I had to hack together an ASLR bypass. My first thought was to leverage
    the `execl()` family of functions. We've been using the `execve()`function in
    our shellcode to spawn a shell, and if you pay close attention (or just read the
    man page), you'll notice the `execve()` function replaces the currently running
    process with the new process image.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我在Linux内核中的linux-gate修复之前就写了这一章，所以我不得不拼凑一个ASLR绕过方案。我的第一个想法是利用`execl()`函数族。我们一直在使用`execve()`函数在我们的shellcode中启动shell，如果你仔细观察（或者只是阅读手册页面），你会注意到`execve()`函数会替换当前运行的进程为新进程映像。
- en: '[PRE101]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: It seems like there could be a weakness here if the memory layout is randomized
    only when the process is started. Let's test this hypothesis with a piece of code
    that prints the address of a stack variable and then executes aslr_demo using
    an `execl()` function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存布局仅在进程启动时随机化，这里可能存在一个弱点。让我们通过一段打印栈变量地址并使用`execl()`函数执行aslr_demo的代码来测试这个假设。
- en: aslr_execl.c
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aslr_execl.c
- en: '[PRE102]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: When this program is compiled and executed, it will `execl()` aslr_demo, which
    also prints the address of a stack variable (buffer). This lets us compare the
    memory layouts.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个程序编译并执行时，它将使用`execl()`执行aslr_demo，它也会打印栈变量（缓冲区）的地址。这让我们可以比较内存布局。
- en: '[PRE103]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The first result looks very promising, but further attempts show that there
    is some degree of randomization happening when the new process is executed with
    `execl()`. I'm sure this wasn't always the case, but the progress of open source
    is rather constant. This isn't much of a problem though, since we have ways to
    deal with that partial uncertainty.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果看起来非常有希望，但进一步的尝试表明，当使用`execl()`执行新进程时，确实存在一定程度的不确定性。我确信这并不总是这样，但开源的进步是相当稳定的。这并不是什么大问题，因为我们有处理这种部分不确定性的方法。
- en: Playing the Odds
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩概率游戏
- en: Using `execl()` at least limits the randomness and gives us a ballpark address
    range. The remaining uncertainty can be handled with a NOP sled. A quick examination
    of aslr_demo shows that the overflow buffer needs to be 80 bytes to overwrite
    the stored return address on the stack.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 至少使用`execl()`可以限制随机性，并给我们一个大致的地址范围。剩余的不确定性可以用NOP滑梯来处理。快速检查aslr_demo显示，溢出缓冲区需要80字节来覆盖栈上存储的返回地址。
- en: '[PRE104]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Since we will probably want a rather large NOP sled, in the following exploit
    the NOP sled and the shellcode will be put after the return address overwrite.
    This allows us to inject as much of a NOP sled as needed. In this case, a thousand
    bytes or so should be sufficient.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能需要一个相当大的NOP滑梯，在下面的攻击中，NOP滑梯和shellcode将被放在返回地址覆盖之后。这允许我们注入所需的尽可能多的NOP滑梯。在这种情况下，大约一千字节应该足够了。
- en: aslr_execl_exploit.c
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aslr_execl_exploit.c
- en: '[PRE105]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This code should make sense to you. The value `200` is added to the return address
    to skip over the first 90 bytes used for the overwrite, so execution lands somewhere
    in the NOP sled.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该对你来说是有意义的。值`200`被加到返回地址上，以跳过用于覆盖的前90个字节，因此执行会落在NOP滑梯的某个地方。
- en: '[PRE106]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, occasionally the randomization causes the exploit to fail, but
    it only needs to succeed once. This leverages the fact that we can try the exploit
    as many times as we want. The same technique will work with the notesearch exploit
    while ASLR is running. Try writing an exploit to do this.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，偶尔随机化会导致利用失败，但只需成功一次即可。这利用了我们可以尝试利用任意多次的事实。当地址空间布局随机化（ASLR）正在运行时，相同的技巧也会在notesearch利用中起作用。尝试编写一个能够做到这一点的利用程序。
- en: Once the basic concepts of exploiting programs are understood, countless variations
    are possible with a little bit of creativity. Since the rules of a program are
    defined by its creators, exploiting a supposedly secure program is simply a matter
    of beating them at their own game. New clever methods, such as stack guards and
    IDSs, try to compensate for these problems, but these solutions aren't perfect
    either. A hacker's ingenuity tends to find holes in these systems. Just think
    of the things they didn't think of.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了利用程序的基本概念，凭借一点创意，就可以产生无数的变化。由于程序规则是由其创造者定义的，因此利用一个看似安全的程序仅仅是战胜他们自己的游戏。新的巧妙方法，如堆栈保护器和入侵检测系统（IDSs），试图弥补这些问题，但这些解决方案也不是完美的。黑客的独创性往往能发现这些系统中的漏洞。只需想想他们没有考虑到的事情。
