- en: Part II. Browser Security Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分. 浏览器安全特性
- en: Having reviewed the basic building blocks of the Web, we can now comfortably
    examine all the security features that keep rogue web applications at bay. [Part II](pt02.html
    "Part II. Browser Security Features") of this book takes a look at everything
    from the well-known but often misunderstood same-origin policy to the obscure
    and proprietary zone settings of Internet Explorer. It explains what these mechanisms
    can do for you—and when they tend to fall apart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了Web的基本构建块之后，我们现在可以舒适地检查所有保持恶意Web应用远离的安全特性。[本书的第二部分](pt02.html "第二部分. 浏览器安全特性")探讨了从众所周知但常常被误解的同源策略到IE的神秘且专有的区域设置等所有内容。它解释了这些机制可以为您做什么——以及它们何时容易崩溃。
- en: Chapter 9. Content Isolation Logic
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 内容隔离逻辑
- en: 'Most of the security assurances provided by web browsers are meant to isolate
    documents based on their origin. The premise is simple: Two pages from different
    sources should not be allowed to interfere with each other. Actual practice can
    be more complicated, however, as no universal agreement exists about where a single
    document begins and ends or what constitutes a single origin. The result is a
    sometimes unpredictable patchwork of contradictory policies that don’t quite work
    well together but that can’t be tweaked without profoundly affecting all current
    legitimate uses of the Web.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器提供的绝大多数安全保证都是为了根据其来源隔离文档。前提很简单：来自不同来源的两个页面不应该被允许相互干扰。然而，实际的实践可能更为复杂，因为关于单个文档的开始和结束在哪里，或者什么构成一个单一来源，并没有达成普遍的共识。结果是，有时不可预测的、相互矛盾的政策拼凑，它们并不完全协同工作，但如果不进行大幅调整，就会严重影响当前所有合法的Web使用。
- en: These problems aside, there is also little clarity about what actions should
    be subject to security checks in the first place. It seems clear that some interactions,
    such as following a link, should be permitted without special restrictions as
    they are essential to the health of the entire ecosystem, and that others, such
    as modifying the contents of a page loaded in a separate window, should require
    a security check. But a large gray area exists between these extremes, and that
    middle ground often feels as if it’s governed more by a roll of the dice than
    by any unified plan. In these murky waters, vulnerabilities such as cross-site
    request forgery (see [Chapter 4](ch04.html "Chapter 4. Hypertext Markup Language"))
    abound.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题之外，关于最初应该对哪些操作进行安全检查也缺乏清晰的了解。显然，一些交互，如跟随链接，应该在没有特殊限制的情况下允许，因为它们对于整个生态系统的健康至关重要，而其他一些操作，如修改在单独窗口中加载的页面内容，则应该需要进行安全检查。但在这些极端之间存在着一个很大的灰色区域，而这个中间地带往往感觉更像是由掷骰子决定的，而不是任何统一的计划。在这些浑浊的水域中，跨站请求伪造（见[第4章](ch04.html
    "第4章. 超文本标记语言"））等漏洞比比皆是。
- en: It’s time to start exploring. Let’s roll a die of our own and kick off the journey
    with JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始探索了。让我们掷出自己的骰子，并用JavaScript开启这段旅程。
- en: Same-Origin Policy for the Document Object Model
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档对象模型（DOM）的同源策略
- en: 'The *same-origin policy* (*SOP*) is a concept introduced by Netscape in 1995
    alongside JavaScript and the Document Object Model (DOM), just one year after
    the creation of HTTP cookies. The basic rule behind this policy is straightforward:
    Given any two separate JavaScript execution contexts, one should be able to access
    the DOM of the other only if the protocols, DNS names,^([[43](#ftn.CHP-9-FN-1)])
    and port numbers associated with their host documents match exactly. All other
    cross-document JavaScript DOM access should fail.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*同源策略* (*SOP*) 是Netscape在1995年与JavaScript和文档对象模型（DOM）一起引入的概念，就在HTTP cookies创建后的第二年。这一策略背后的基本规则很简单：对于任何两个独立的JavaScript执行上下文，一个应该能够访问另一个的DOM，前提是与其宿主文档相关联的协议、DNS名称和端口号完全匹配。所有其他跨文档的JavaScript
    DOM访问都应该失败。'
- en: 'The protocol-host-port tuple introduced by this algorithm is commonly referred
    to as *origin*. As a basis for a security policy, this is pretty robust: SOP is
    implemented across all modern browsers with a good degree of consistency and with
    only occasional bugs.^([[44](#ftn.CHP-9-FN-2)]) In fact, only Internet Explorer
    stands out, as it ignores the port number for the purpose of origin checks. This
    practice is somewhat less secure, particularly given the risk of having non-HTTP
    services running on a remote host for HTTP/0.9 web servers (see [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol")). But usually it makes no appreciable
    difference.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法引入的协议-主机-端口号三元组通常被称为*源*。作为安全策略的基础，这相当稳健：SOP在所有现代浏览器中得到了良好的实施，并且一致性很高，只有偶尔会出现错误.^([[44](#ftn.CHP-9-FN-2)])
    实际上，只有Internet Explorer与众不同，因为它在源检查中忽略了端口号。这种做法的安全性略低，尤其是在远程主机上运行HTTP/0.9网络服务器时，存在非HTTP服务的风险（参见[第3章](ch03.html
    "第3章。超文本传输协议")). 但通常这不会造成明显的差异。
- en: '[Table 9-1](ch09.html#outcomes_of_sop_checks "Table 9-1. Outcomes of SOP Checks")
    illustrates the outcome of SOP checks in a variety of situations.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-1](ch09.html#outcomes_of_sop_checks "表9-1。SOP检查结果")展示了在多种情况下SOP检查的结果。'
- en: Table 9-1. Outcomes of SOP Checks
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1. SOP检查结果
- en: '| Originating document | Accessed document | Non-IE browser | Internet Explorer
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 原始文档 | 访问文档 | 非IE浏览器 | Internet Explorer |'
- en: '| --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| [http://example.com/a/](http://example.com/a/) | [http://example.com/b/](http://example.com/b/)
    | Access okay | Access okay |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| [http://example.com/a/](http://example.com/a/) | [http://example.com/b/](http://example.com/b/)
    | 访问正常 | 访问正常 |'
- en: '| [http://example.com/](http://example.com/) | [http://www.example.com/](http://www.example.com/)
    | Host mismatch | Host mismatch |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| [http://example.com/](http://example.com/) | [http://www.example.com/](http://www.example.com/)
    | 主机不匹配 | 主机不匹配 |'
- en: '| [http://example.com/](http://example.com/) | [https://example.com/](https://example.com/)
    | Protocol mismatch | Protocol mismatch |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| [http://example.com/](http://example.com/) | [https://example.com/](https://example.com/)
    | 协议不匹配 | 协议不匹配 |'
- en: '| [http://example.com:81/](http://example.com:81/) | [http://example.com/](http://example.com/)
    | Port mismatch | Access okay |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| [http://example.com:81/](http://example.com:81/) | [http://example.com/](http://example.com/)
    | 端口不匹配 | 访问正常 |'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This same-origin policy was originally meant to govern access only to the DOM
    ; that is, the methods and properties related to the contents of the actual displayed
    document. The policy has been gradually extended to protect other obviously sensitive
    areas of the root JavaScript object, but it is not all-inclusive. For example,
    non-same-origin scripts can usually still call *location.assign()* or *location.replace(...)*
    on an arbitrary window or a frame. The extent and the consequences of these exemptions
    are the subject of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin
    Rules").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个同源策略最初是为了仅控制对DOM的访问；也就是说，与实际显示文档内容相关的特性和方法。该策略已经逐渐扩展到保护根JavaScript对象的其他显然敏感区域，但并非涵盖所有。例如，非同源脚本通常仍然可以在任意窗口或框架上调用
    *location.assign()* 或 *location.replace(...)*。这些特权的范围和后果是[第11章](ch11.html "第11章。同源规则之外的生活")的主题。
- en: 'The simplicity of SOP is both a blessing and a curse. The mechanism is fairly
    easy to understand and not too hard to implement correctly, but its inflexibility
    can be a burden to web developers. In some contexts, the policy is too broad,
    making it impossible to, say, isolate home pages belonging to separate users (short
    of giving each a separate domain). In other cases, the opposite is true: The policy
    makes it difficult for legitimately cooperating sites (say, *login.example.com*
    and *payments.example.com*) to seamlessly exchange data.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SOP的简单性既是祝福也是诅咒。该机制相对容易理解，并且正确实施并不太难，但它的僵化可能会给网络开发者带来负担。在某些情况下，该策略过于宽泛，使得无法（例如）隔离属于不同用户的首页（除非为每个用户分配一个单独的域名）。在其他情况下，情况正好相反：该策略使得合法合作的网站（例如，*login.example.com*
    和 *payments.example.com*）难以无缝交换数据。
- en: Attempts to fix the first problem—to narrow down the concept of an origin—are
    usually bound to fail because of interactions with other explicit and hidden security
    controls in the browser. Attempts to broaden origins or facilitate cross-domain
    interactions are more common. The two broadly supported ways of achieving these
    goals are *document.domain* and *postMessage(...)*, as discussed below.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解决第一个问题——缩小源的概念——通常会因为与浏览器中其他显式和隐式安全控制的交互而注定失败。尝试扩展源或促进跨域交互更为常见。实现这些目标广泛支持的两个方法如下：*document.domain*
    和 *postMessage(...)*，如下所述。
- en: document.domain
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: document.domain
- en: 'This JavaScript property permits any two cooperating websites that share a
    common top-level domain (such as *example.com*, or even just *.com*) to agree
    that for the purpose of future same-origin checks, they want to be considered
    equivalent. For example, both *login.example.com* and *payments.example.com* may
    perform the following assignment:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript属性允许任何两个共享公共顶级域名（例如 *example.com*，甚至仅仅是 *.com*）的协作网站同意，为了未来源策略检查的目的，它们希望被视为等效。例如，*login.example.com*
    和 *payments.example.com* 可能执行以下赋值：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting this property overrides the usual hostname matching logic during same-origin
    policy checks. The protocols and port numbers still have to match, though; if
    they don’t, tweaking *document.domain* will not have the desired effect.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此属性将覆盖在源策略检查期间通常的域名匹配逻辑。尽管如此，协议和端口号仍然必须匹配；如果不匹配，调整 *document.domain* 也不会产生预期的效果。
- en: Both parties must explicitly opt in for this feature. Simply because *login.example.com*
    has set its *document.domain* to *example.com* does not mean that it will be allowed
    to access content originating from the website hosted at [http://example.com/](http://example.com/).
    That website needs to perform such an assignment, too, even if common sense would
    indicate that it is a no-op. This effect is symmetrical. Just as a page that sets
    *document.domain* will not be able to access pages that did not, the action of
    setting the property also renders the caller mostly (but not fully!)^([[45](#ftn.CHP-9-FN-3)])
    out of reach of normal documents that previously would have been considered same-origin
    with it. [Table 9-2](ch09.html#outcomes_of_document.domain_checks "Table 9-2. Outcomes
    of document.domain Checks") shows the effects of various values of *document.domain*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 双方必须明确选择此功能。仅仅因为 *login.example.com* 将其 *document.domain* 设置为 *example.com*
    并不意味着它将被允许访问来自[http://example.com/](http://example.com/)网站的原始内容。该网站也需要执行这样的赋值，即使常识可能表明这是一个无操作。这种效果是对称的。正如设置
    *document.domain* 的页面将无法访问未设置该属性的页面一样，设置属性的行为也将调用者大部分（但不是全部！）^([[45](#ftn.CHP-9-FN-3)])
    排除在之前被认为是同源的普通文档之外。[表9-2](ch09.html#outcomes_of_document.domain_checks "表9-2.
    *document.domain* 检查的结果")显示了 *document.domain* 的各种值的效应。
- en: Despite displaying a degree of complexity that hints at some special sort of
    cleverness, *document.domain* is not particularly safe. Its most significant weakness
    is that it invites unwelcome guests. After two parties mutually set this property
    to *example.com*, it is not simply the case that *login.example.com* and *payments.example.com*
    will be able to communicate; *funny-cat-videos.example.com* will be able to jump
    on the bandwagon as well. And because of the degree of access permitted between
    the pages, the integrity of any of the participating JavaScript contexts simply
    cannot be guaranteed to any realistic extent. In other words, touching *document.domain*
    inevitably entails tying the security of your page to the security of the weakest
    link in the entire domain. An extreme case of setting the value to **.com* is
    essentially equivalent to assisted suicide.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *document.domain* 显示出一定程度的复杂性，暗示着某种特殊类型的巧妙，但它并不特别安全。它最显著的弱点是它邀请不受欢迎的访客。当双方相互将此属性设置为
    *example.com* 后，不仅仅是 *login.example.com* 和 *payments.example.com* 将能够通信；*funny-cat-videos.example.com*
    也能加入这个行列。而且由于页面之间允许的访问程度，任何参与JavaScript上下文的完整性都无法保证到任何实际的程度上。换句话说，触摸 *document.domain*
    必然意味着将你页面的安全性绑定到整个域中最薄弱环节的安全性。将值设置为 **.com** 的极端情况本质上等同于协助自杀。
- en: Table 9-2. Outcomes of *document.domain* Checks
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-2. *document.domain* 检查的结果
- en: '| Originating document | Accessed document | Outcome |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 原始文档 | 访问文档 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| URL | document.domain | URL | document.domain |   |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| URL | document.domain | URL | document.domain |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [http://payments.example.com/](http://payments.example.com/)
    | *example.com* | Access okay |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [http://payments.example.com/](http://payments.example.com/)
    | *example.com* | 访问允许 |'
- en: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [https://payments.example.com/](https://payments.example.com/)
    | *example.com* | Protocol mismatch |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.example.com/](http://www.example.com/) | *example.com* | [https://payments.example.com/](https://payments.example.com/)
    | *example.com* | 协议不匹配 |'
- en: '| [http://payments.example.com/](http://payments.example.com/) | *example.com*
    | [http://example.com/](http://example.com/) | **(not set)** | Access denied |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| [http://payments.example.com/](http://payments.example.com/) | *example.com*
    | [http://example.com/](http://example.com/) | **(未设置)** | 访问被拒绝 |'
- en: '| [http://www.example.com/](http://www.example.com/) | **(not set)** | [http://www.example.com/](http://www.example.com/)
    | *example.com* | Access denied |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.example.com/](http://www.example.com/) | **(未设置)** | [http://www.example.com/](http://www.example.com/)
    | *example.com* | 访问被拒绝 |'
- en: postMessage(...)
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: postMessage(...)
- en: The *postMessage(...)* API is an HTML5 extension that permits slightly less
    convenient but remarkably more secure communications between non-same-origin sites
    without automatically giving up the integrity of any of the parties involved.
    Today it is supported in all up-to-date browsers, although because it is fairly
    new, it is not found in Internet Explorer 6 or 7.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*postMessage(...)* API 是一个HTML5扩展，允许在非同源站点之间进行稍微不那么方便但非常安全的通信，而不会自动放弃任何一方的完整性。今天，它被所有最新的浏览器支持，尽管由于它相对较新，它不在Internet
    Explorer 6或7中。'
- en: The mechanism permits a text message of any length to be sent to any window
    for which the sender holds a valid JavaScript handle (see [Chapter 6](ch06.html
    "Chapter 6. Browser-Side Scripts")). Although the same-origin policy has a number
    of gaps that permit similar functionality to be implemented by other means,^([[46](#ftn.CHP-9-FN-4)])
    this one is actually safe to use. It allows the sender to specify what origins
    are permitted to receive the message in the first place (in case the URL of the
    target window has changed), and it provides the recipient with the identity of
    the sender so that the integrity of the channel can be ascertained easily. In
    contrast, legacy methods that rely on SOP loopholes usually don’t come with such
    assurances; if a particular action is permitted without robust security checks,
    it can usually also be triggered by a rogue third party and not just by the intended
    participants.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制允许发送任何长度的文本消息到任何发送者持有有效JavaScript句柄的窗口（参见[第6章](ch06.html "第6章。浏览器端脚本")）。尽管同源策略存在一些漏洞，允许通过其他方式实现类似功能，^([[46](#ftn.CHP-9-FN-4)])
    但实际上这种方法是安全的。它允许发送者指定哪些源被允许首先接收消息（如果目标窗口的URL已更改），并且它向接收者提供了发送者的身份，以便可以轻松地确定通道的完整性。相比之下，依赖于SOP漏洞的旧方法通常不提供此类保证；如果某个特定操作在没有稳健的安全检查的情况下被允许，那么它通常也可以被恶意第三方触发，而不仅仅是预期参与者。
- en: 'To illustrate the proper use of *postMessage(...)*, consider a case in which
    a top-level document located at *payments.example.com* needs to obtain user login
    information for display purposes. To accomplish this, it loads a frame pointing
    to *login.example.com*. This frame can simply issue the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明 *postMessage(...)* 的正确使用方法，考虑一个位于 *payments.example.com* 的顶级文档需要获取用户登录信息以供显示的情况。为此，它加载了一个指向
    *login.example.com* 的框架。这个框架可以简单地发出以下命令：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The browser will deliver the message only if the embedding site indeed matches
    the specified, trusted origin. In order to securely process this response, the
    top-level document needs to use the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器只有在嵌入的网站确实匹配指定的、受信任的源时才会传递消息。为了安全地处理此响应，顶级文档需要使用以下代码：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*PostMessage(...)* is a very robust mechanism that offers significant benefits
    over *document.domain* and over virtually all other guerrilla approaches that
    predate it; therefore, it should be used as often as possible. That said, it can
    still be misused. Consider the following check that looks for a substring in the
    domain name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*PostMessage(...)* 是一个非常健壮的机制，与 *document.domain* 以及几乎所有早于它的游击战方法相比，提供了显著的好处；因此，它应该尽可能多地使用。尽管如此，它仍然可能被滥用。考虑以下检查，它在域名中查找子字符串：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As should be evident, this comparison will not only match sites within *example.com*
    but will also happily accept messages from [www.example.com.bunnyoutlet.com](http://www.example.com.bunnyoutlet.com).
    In all likelihood, you will stumble upon code like this more than once in your
    journeys. Such is life!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如应明显，这个比较不仅会匹配*example.com*内的网站，而且也会愉快地接受来自[www.example.com.bunnyoutlet.com](http://www.example.com.bunnyoutlet.com)的消息。在所有可能的情况下，你可能会不止一次地在你旅途中遇到这样的代码。这就是生活！
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Recent tweaks to HTML5 extended the *postMessage(...)* API to incorporate somewhat
    overengineered “ports” and “channels,” which are meant to facilitate stream-oriented
    communications between websites. Browser support for these features is currently
    very limited and their practical utility is unclear, but from the security standpoint,
    they do not appear to be of any special concern.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最近对HTML5的调整扩展了*postMessage(...)* API，以包含某些过度设计的“端口”和“通道”，这些端口和通道旨在促进网站之间的流式通信。浏览器对这些特性的支持目前非常有限，它们的实际效用尚不清楚，但从安全角度来看，它们似乎并不引起任何特殊关注。
- en: Interactions with Browser Credentials
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与浏览器凭证的交互
- en: As we are wrapping up the overview of the DOM-based same-origin policy, it is
    important to note that it is in no way synchronized with ambient credentials,
    SSL state, network context, or many other potentially security-relevant parameters
    tracked by the browser. Any two windows or frames opened in a browser will remain
    same-origin with each other even if the user logs out from one account and logs
    into another, if the page switches from using a good HTTPS certificate to a bad
    one, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束基于DOM的同源策略概述时，重要的是要注意，它与环境凭证、SSL状态、网络上下文或许多其他浏览器跟踪的潜在安全相关参数没有任何同步。在浏览器中打开的两个窗口或框架将保持同源关系，即使用户从一个账户注销并登录到另一个账户，如果页面从使用好的HTTPS证书切换到坏的证书，等等。
- en: This lack of synchronization can contribute to the exploitability of other security
    bugs. For example, several sites do not protect their login forms against cross-site
    request forgery, permitting any third-party site to simply submit a username and
    a password and log the user into an attacker-controlled account. This may seem
    harmless at first, but when the content loaded in the browser before and after
    this operation is considered same-origin, the impact of normally ignored “self-inflicted”
    cross-site scripting vulnerabilities (i.e., ones where the owner of a particular
    account can target only himself) is suddenly much greater than it would previously
    appear. In the most basic scenario, the attacker may first open and keep a frame
    pointing to a sensitive page on the targeted site (e.g., [http://www.fuzzybunnies.com/address_book.php](http://www.fuzzybunnies.com/address_book.php))
    and then log the victim into the attacker-controlled account to execute self-XSS
    in an unrelated component of [fuzzybunnies.com](http://fuzzybunnies.com). Despite
    the change of HTTP credentials, the code injected in that latter step will have
    unconstrained access to the previously loaded frame, permitting data theft.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不同步可能导致其他安全漏洞的可利用性。例如，一些网站没有保护他们的登录表单免受跨站请求伪造攻击，允许任何第三方网站简单地提交用户名和密码，并将用户登录到攻击者控制的账户。起初这看起来可能无害，但考虑到在此操作前后加载到浏览器中的内容被认为是同源的，通常被忽视的“自造成的”跨站脚本漏洞（即，特定账户的所有者只能针对自己）的影响突然比之前看起来要大得多。在最基本的情况下，攻击者可能首先打开并保持一个指向目标网站上敏感页面的框架（例如，[http://www.fuzzybunnies.com/address_book.php](http://www.fuzzybunnies.com/address_book.php)）并然后登录受害者到攻击者控制的账户以在[fuzzybunnies.com](http://fuzzybunnies.com)的一个无关组件中执行自-XSS。尽管HTTP凭证发生了变化，但在那最后一步中注入的代码将不受限制地访问之前加载的框架，允许数据窃取。
- en: '* * *'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[43](#CHP-9-FN-1)]) This and most other browser security mechanisms are
    based on DNS labels, not on examining the underlying IP addresses. This has a
    curious consequence: If the IP of a particular host changes, the attacker may
    be able to talk to the new destination through the user’s browser, possibly engaging
    in abusive behaviors while hiding the true origin of the attack (unfortunate,
    not very interesting) or interacting with the victim''s internal network, which
    normally would not be accessible due to the presence of a firewall (a much more
    problematic case). Intentional change of an IP for this purpose is known as *DNS
    rebinding*. Browsers try to mitigate DNS rebinding to some extent by, for example,
    caching DNS lookup results for a certain time (*DNS pinning*), but these defenses
    are imperfect.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[43](#CHP-9-FN-1)]) 这以及大多数其他浏览器安全机制都是基于DNS标签，而不是基于检查底层IP地址。这有一个奇特的结果：如果某个主机的IP地址发生变化，攻击者可能能够通过用户的浏览器与新的目的地进行通信，可能在进行滥用行为的同时隐藏攻击的真实来源（不幸，但并不很有趣）或者与受害者的内部网络进行交互，这在通常情况下由于防火墙的存在而无法访问（一个更成问题的情况）。出于此目的有意更改IP地址的行为被称为*DNS重绑定*。浏览器试图通过例如缓存DNS查找结果一段时间（*DNS固定*）等方式在一定程度上减轻DNS重绑定的风险，但这些防御措施并不完美。
- en: ^([[44](#CHP-9-FN-2)]) One significant source of same-origin policy bugs is
    having several separate URL-parsing routines in the browser code. If the parsing
    approach used in the HTTP stack differs from that used for determining JavaScript
    origins, problems may arise. Safari, in particular, combated a significant number
    of SOP bypass flaws caused by pathological URLs, including many of the inputs
    discussed in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[44](#CHP-9-FN-2)]) 同源策略漏洞的一个显著来源是浏览器代码中有多个独立的URL解析程序。如果在HTTP堆栈中使用的解析方法与用于确定JavaScript来源的方法不同，可能会出现问题。特别是Safari，它对抗了由病态URL引起的许多SOP绕过漏洞，包括在[第2章](ch02.html
    "第2章。一切从URL开始")中讨论的许多输入。
- en: ^([[45](#CHP-9-FN-3)]) For example, in Internet Explorer, it will still be possible
    for one page to navigate any other documents that were nominally same-origin but
    that became “isolated” after setting *document.domain*, to *javascript:* URLs.
    Doing so permits any JavaScript to execute in the context of such as a pseudo-isolated
    domain. On top of this, obviously nothing stops the originating page from simply
    setting its own *document.domain* to a value identical with that of the target
    in order to eliminate the boundary. In other words, the ability to make a document
    non-same-origin with other pages through *document.domain* should not be relied
    upon for anything even remotely serious or security relevant.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[45](#CHP-9-FN-3)]) 例如，在Internet Explorer中，仍然有可能让一个页面导航到任何名义上是同源的但后来在设置*document.domain*后变为“隔离”的文档，到*javascript:*
    URL。这样做允许任何JavaScript在伪隔离域的上下文中执行。在此基础上，显然没有任何阻止原始页面简单地将其自己的*document.domain*设置为与目标相同的值以消除边界的。换句话说，不应依赖于通过*document.domain*将文档与其他页面非同源的能力来进行任何甚至稍微重要或与安全相关的操作。
- en: ^([[46](#CHP-9-FN-4)]) More about this in [Chapter 11](ch11.html "Chapter 11. Life
    Outside Same-Origin Rules"), but the most notable example is that of encoding
    data in URL fragment identifiers. This is possible because navigating frames to
    a new URL is not subject to security restrictions in most cases, and navigation
    to a URL where only the fragment identifier changes does not actually trigger
    a page reload. Framed JavaScipt can simply poll *location.hash* and detect incoming
    messages this way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[46](#CHP-9-FN-4)]) 更多关于这方面的内容请参阅[第11章](ch11.html "第11章。同源规则之外的生活")，但最显著的例子是将数据编码在URL片段标识符中。这是可能的，因为大多数情况下，在框架中导航到新的URL不受安全限制，并且仅更改片段标识符的URL导航实际上不会触发页面刷新。框架化的JavaScript可以简单地轮询*location.hash*并以此方式检测传入的消息。
- en: Same-Origin Policy for XMLHttpRequest
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMLHttpRequest的同源策略
- en: The *XMLHttpRequest* API, mentioned in this book on several prior occasions,
    gives JavaScript programs the ability to issue almost unconstrained HTTP requests
    to the server from which the host document originated, and read back response
    headers and the document body. The ability to do so would not be particularly
    significant were it not for the fact that the mechanism leverages the existing
    browser HTTP stack and its amenities, including ambient credentials, caching mechanisms,
    keep-alive sessions, and so on.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本书在前面多次提到的 *XMLHttpRequest* API，赋予了 JavaScript 程序向主机文档来源的服务器发出几乎不受约束的 HTTP 请求的能力，并读取响应头部和文档主体。如果这种机制没有利用现有的浏览器
    HTTP 栈及其便利性，包括环境凭据、缓存机制、保持连接会话等，那么这种能力就不会特别重要。
- en: 'A simple and fairly self-explanatory use of a synchronous *XMLHttpRequest*
    could be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同步 *XMLHttpRequest* 的一个简单且相当直观的使用方法可以是以下这样：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Asynchronous requests are very similar but are executed without blocking the
    JavaScript engine or the browser. The request is issued in the background, and
    an event handler is called upon completion instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 异步请求与同步请求非常相似，但它们不会阻塞 JavaScript 引擎或浏览器。请求在后台发出，并在完成后调用事件处理器。
- en: As originally envisioned, the ability to issue HTTP requests via this API and
    to read back the data is governed by a near-verbatim copy of the same-origin policy
    with two minor and seemingly random tweaks. First, the *document.domain* setting
    has no effect on this mechanism, and the destination URL specified for *XMLHttpRequest.open(...)*
    must always match the true origin of the document. Second, in this context, port
    number is taken into account in Internet Explorer versions prior to 9, even though
    this browser ignores it elsewhere.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如最初设想的那样，通过此 API 发出 HTTP 请求并读取数据的能力，受几乎完全相同的同源策略的约束，只有两个微小的、看似随机的调整。首先，*document.domain*
    设置对此机制没有影响，并且为 *XMLHttpRequest.open(...)* 指定的目标 URL 必须始终与文档的真实来源相匹配。其次，在此上下文中，在
    Internet Explorer 9 之前的版本中考虑了端口号，尽管此浏览器在其他地方忽略了它。
- en: 'The fact that *XMLHttpRequest* gives the user an unprecedented level of control
    over the HTTP headers in a request can actually be advantageous to security. For
    example, inserting a custom HTTP header, such as *X-Coming-From: same-origin*,
    is a very simple way to verify that a particular request is not coming from a
    third-party domain, because no other site should be able to insert a custom header
    into a browser-issued request. This assurance is not very strong, because no specification
    says that the implicit restriction on cross-domain headers can’t change;^([[47](#ftn.CHP-9-FN-5)])
    nevertheless, when it comes to web security, such assumptions are often just something
    you have to learn to live with.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，*XMLHttpRequest* 允许用户对请求中的 HTTP 头部进行前所未有的控制，这实际上可能对安全性有益。例如，插入一个自定义的 HTTP
    头部，如 *X-Coming-From: same-origin*，是一个非常简单的方式来验证特定的请求不是来自第三方域名，因为没有任何其他网站应该能够向浏览器发出的请求中插入自定义头部。这种保证并不非常强，因为没有规范说明对跨域头部的隐式限制不能改变；^([[47](#ftn.CHP-9-FN-5)])
    然而，当涉及到网络安全时，这种假设通常是你必须学会接受的。'
- en: Control over the structure of an HTTP request can also be a burden, though,
    because inserting certain types of headers may change the meaning of a request
    to the destination server, or to the proxies, without the browser realizing it.
    For example, specifying an incorrect *Content-Length* value may allow an attacker
    to smuggle a second request into a keep-alive HTTP session maintained by the browser,
    as shown here.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HTTP 请求结构的控制也可能成为一种负担，因为插入某些类型的头部可能会改变对目标服务器或代理的意义，而浏览器并没有意识到这一点。例如，指定一个错误的
    *Content-Length* 值可能允许攻击者将第二个请求偷偷地放入浏览器维护的保持连接的 HTTP 会话中，如下所示。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If this happens, the response to that second, injected request may be misinterpreted
    by the browser later, possibly poisoning the cache or injecting content into another
    website. This problem is especially pronounced if an HTTP proxy is in use and
    all HTTP requests are sent through a shared channel.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，浏览器可能会错误地解释第二个注入请求的响应，可能污染缓存或将内容注入到另一个网站。如果使用 HTTP 代理并且所有 HTTP 请求都通过共享通道发送，这个问题尤其明显。
- en: 'Because of this risk, and following a lot of trial and error, modern browsers
    blacklist a selection of HTTP headers and request methods. This is done with relatively
    little consistency: While *Referer*, *Content-Length*, and *Host* are universally
    banned, the handling of headers such as *User-Agent*, *Cookie*, *Origin*, or *If-Modified-Since*
    varies from one browser to another. Similarly, the TRACE method is blocked everywhere,
    because of the unanticipated risk it posed to *httponly* cookies—but the CONNECT
    method is permitted in Firefox, despite carrying a vague risk of messing with
    HTTP proxies.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种风险，经过大量的尝试和错误，现代浏览器黑名单了一些 HTTP 头部和请求方法。这做得相对不太一致：虽然 *Referer*、*Content-Length*
    和 *Host* 被普遍禁止，但诸如 *User-Agent*、*Cookie*、*Origin* 或 *If-Modified-Since* 的头部处理因浏览器而异。同样，由于对
    *httponly* cookie 的未预料风险，TRACE 方法在所有地方都被阻止——但 CONNECT 方法在 Firefox 中被允许，尽管它带有可能破坏
    HTTP 代理的模糊风险。
- en: Naturally, implementing these blacklists has proven to be an entertaining exercise
    on its own. Strictly for your amusement, consider the following cases that worked
    in some browsers as little as three years ago:^([[176](pr03.html#ftn.CHP-9-FT-1)])
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，实现这些黑名单本身就是一个有趣的练习。仅为了娱乐，考虑以下在三年前一些浏览器中有效的情况：^([[176](pr03.html#ftn.CHP-9-FT-1)])
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: or simply
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或简单地
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Cross-Origin Resource Sharing*^([[177](pr03.html#ftn.CHP-9-FT-2)]) *(CORS)*
    is a proposed extension to *XMLHttpRequest* that permits HTTP requests to be issued
    across domains and then read back if a particular response header appears in the
    returned data. The mechanism changes the semantics of the API discussed in this
    session by allowing certain “vanilla” cross-domain requests, meant to be no different
    from regular navigation, to be issued via *XMLHttpRequest.open(...)* with no additional
    checks; more elaborate requests require an OPTIONS-based preflight request first.
    CORS is already available in some browsers, but it is opposed by Microsoft engineers,
    who pursued a competing *XDomainRequest* approach in Internet Explorer 8 and 9\.
    Because the outcome of this conflict is unclear, a detailed discussion of CORS
    is reserved for [Chapter 16](ch16.html "Chapter 16. New and Upcoming Security
    Features"), which provides a more systematic overview of upcoming and experimental
    mechanisms.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨源资源共享*^([[177](pr03.html#ftn.CHP-9-FT-2)]) *(CORS)* 是对 *XMLHttpRequest* 的一个提议性扩展，允许跨域发起
    HTTP 请求，并在返回的数据中出现特定响应头时读取。该机制通过允许某些“纯”跨域请求（旨在与常规导航无差异）通过 *XMLHttpRequest.open(...)*
    发起，而不需要额外的检查；更复杂的请求需要先进行基于 OPTIONS 的预检请求。CORS 已在一些浏览器中可用，但遭到了微软工程师的反对，他们在 Internet
    Explorer 8 和 9 中追求了竞争性的 *XDomainRequest* 方法。由于这一冲突的结果尚不明确，对 CORS 的详细讨论留给了 [第 16
    章](ch16.html "第 16 章。新和即将推出的安全功能")，该章提供了一个更系统的对即将推出和实验性机制的概述。'
- en: '* * *'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[47](#CHP-9-FN-5)]) In fact, many plug-ins had problems in this area in the
    past. Most notably, Adobe Flash permitted arbitrary cross-domain HTTP headers
    until 2008, at which point its security model underwent a substantial overhaul.
    Until 2011, the same plug-in suffered from a long-lived implementation bug that
    caused it to resend any custom headers to an unrelated server following an attacker-supplied
    HTTP 307 redirect code. Both of these problems are fixed now, but discovery-to-patch
    time proved troubling.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[47](#CHP-9-FN-5)]) 事实上，许多插件在过去在这个领域存在问题。最值得注意的是，Adobe Flash 允许任意跨域 HTTP
    头部信息，直到 2008 年，那时它的安全模型经历了重大改革。直到 2011 年，该插件还遭受了一个长期存在的实现错误，导致它在攻击者提供的 HTTP 307
    重定向代码之后向一个无关的服务器重新发送任何自定义头部。这两个问题现在都已修复，但发现到修复的时间证明是麻烦的。
- en: Same-Origin Policy for Web Storage
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Storage 的同源策略
- en: Web storage is a simple database solution first implemented by Mozilla engineers
    in Firefox 1.5 and eventually embraced by the HTML5 specification.^([[178](pr03.html#ftn.CHP-9-FT-3)])
    It is available in all current browsers but not in Internet Explorer 6 or 7.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Web storage 是一个简单的数据库解决方案，最初由 Mozilla 工程师在 Firefox 1.5 中实现，最终被 HTML5 规范所采纳。它在所有当前浏览器中可用，但在
    Internet Explorer 6 或 7 中不可用。
- en: 'Following several dubious iterations, the current design relies on two simple
    JavaScript objects: *localStorage* and *sessionStorage*. Both objects offer an
    identical, simple API for creating, retrieving, and deleting name-value pairs
    in a browser-managed database. For example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次可疑的迭代后，当前的设计依赖于两个简单的 JavaScript 对象：*localStorage* 和 *sessionStorage*。这两个对象提供了一个相同且简单的
    API，用于在浏览器管理的数据库中创建、检索和删除键值对。例如：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *localStorage* object implements a persistent, origin-specific storage that
    survives browser shutdowns, while *sessionStorage* is expected to be bound to
    the current browser window and provide a temporary caching mechanism that is destroyed
    at the end of a browsing session. While the specification says that both *localStorage*
    and *sessionStorage* should be associated with an SOP-like origin (the protocol-host-port
    tuple), implementations in some browsers do not follow this advice, introducing
    potential security bugs. Most notably, in Internet Explorer 8, the protocol is
    not taken into account when computing the origin, putting HTTP and HTTPS pages
    within a shared context. This design makes it very unsafe for HTTPS sites to store
    or read back sensitive data through this API. (This problem is corrected in Internet
    Explorer 9, but there appears to be no plan to backport the fix.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*localStorage* 对象实现了一种持久、特定源存储，它能在浏览器关闭后继续存在，而 *sessionStorage* 则预期与当前浏览器窗口绑定，提供一个在浏览会话结束时被销毁的临时缓存机制。虽然规范说明
    *localStorage* 和 *sessionStorage* 都应与类似SOP的源（协议-主机-端口号三元组）相关联，但某些浏览器的实现并未遵循这一建议，引入了潜在的安全漏洞。最值得注意的是，在Internet
    Explorer 8中，计算源时不考虑协议，导致HTTP和HTTPS页面处于同一个上下文中。这种设计使得HTTPS站点通过此API存储或读取敏感数据非常不安全。（此问题在Internet
    Explorer 9中得到修正，但似乎没有计划回滚此修复。）'
- en: 'In Firefox, on the other hand, the *localStorage* behaves correctly, but the
    *sessionStorage* interface does not. HTTP and HTTPS use a shared storage context,
    and although a check is implemented to prevent HTTP content from reading keys
    created by HTTPS scripts, there is a serious loophole: Any key first created over
    HTTP, and then updated over HTTPS, will remain visible to nonencrypted pages.
    This bug, originally reported in 2009,^([[179](pr03.html#ftn.CHP-9-FT-4)]) will
    eventually be resolved, but when is not clear.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在Firefox中，*localStorage* 的行为是正确的，但 *sessionStorage* 接口则不正确。HTTP和HTTPS使用共享存储上下文，尽管实现了检查以防止HTTP内容读取由HTTPS脚本创建的键，但存在一个严重的漏洞：任何首先通过HTTP创建，然后通过HTTPS更新的键，将始终对非加密页面可见。这个最初在2009年报告的漏洞^([[179](pr03.html#ftn.CHP-9-FT-4)])最终将被解决，但具体时间尚不清楚。
- en: Security Policy for Cookies
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩子安全策略
- en: 'We discussed the semantics of HTTP cookies in [Chapter 3](ch03.html "Chapter 3. Hypertext
    Transfer Protocol"), but that discussion left out one important detail: the security
    rules that must be implemented to protect cookies belonging to one site from being
    tampered with by unrelated pages. This topic is particularly interesting because
    the approach taken here predates the same-origin policy and interacts with it
    in a number of unexpected ways.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。超文本传输协议")中讨论了HTTP cookies的语义，但那次讨论遗漏了一个重要细节：必须实施的安全规则，以保护一个站点的cookies不被无关页面篡改。这个话题特别有趣，因为这里采取的方法早于同源策略，并以多种意想不到的方式与之交互。
- en: Cookies are meant to be scoped to domains, and they can’t be limited easily
    to just a single hostname value. The *domain* parameter provided with a cookie
    may simply match the current hostname (such as *foo.example.com*), but this will
    not prevent the cookie from being sent to any eventual subdomains, such as *bar.foo.example.com*.
    A qualified right-hand fragment of the hostname, such as *example.com*, can be
    specified to request a broader scope, however.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies旨在限定于域，并且不能轻易限制为仅单个主机名值。与cookie一起提供的 *domain* 参数可能仅匹配当前主机名（例如 *foo.example.com*），但这不会阻止cookie被发送到任何子域，例如
    *bar.foo.example.com*。可以通过指定主机名的合格右端片段（例如 *example.com*）来请求更广泛的范围。
- en: Amusingly, the original RFCs imply that Netscape engineers wanted to allow exact
    host-scoped cookies, but they did not follow their own advice. The syntax devised
    for this purpose was not recognized by the descendants of Netscape Navigator (or
    by any other implementation for that matter). To a limited extent, setting host-scoped
    cookies is possible in some browsers by completely omitting the *domain* parameter,
    but this method will have no effect in Internet Explorer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，原始的RFCs暗示Netscape工程师想要允许精确的主机域cookies，但他们没有遵循自己的建议。为此目的设计的语法没有被Netscape
    Navigator的后代（或任何其他实现）所认可。在一定程度上，通过完全省略 *domain* 参数，在某些浏览器中可以设置主机域cookies，但在Internet
    Explorer中这种方法将没有任何效果。
- en: '[Table 9-3](ch09s04.html#a_sample_of_cookie-setting_behaviors "Table 9-3. A
    Sample of Cookie-Setting Behaviors") illustrates cookie-setting behavior in some
    distinctive cases.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-3](ch09s04.html#a_sample_of_cookie-setting_behaviors "表9-3. Cookie设置行为的示例")展示了在某些特定情况下cookie设置行为。'
- en: Table 9-3. A Sample of Cookie-Setting Behaviors
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-3. Cookie设置行为的示例
- en: '| Cookie set at *foo.example.com*, *domain* parameter is: | Scope of the resulting
    cookie |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 在*foo.example.com*设置的cookie，*domain*参数是： | 结果cookie的作用域 |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Non-IE browsers | Internet Explorer |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 非IE浏览器 | Internet Explorer |'
- en: '| --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (value omitted) | *foo.example.com* (exact) | **.foo.example.com* |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| (value omitted) | *foo.example.com* (exact) | **.foo.example.com* |'
- en: '| *bar.foo.example.com* | Cookie not set: domain more specific than origin
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| *bar.foo.example.com* | Cookie not set: domain more specific than origin
    |'
- en: '| *foo.example.com* | **.foo.example.com* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| *foo.example.com* | **.foo.example.com* |'
- en: '| *baz.example.com* | Cookie not set: domain mismatch |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| *baz.example.com* | Cookie not set: domain mismatch |'
- en: '| *example.com* | **.example.com* |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| *example.com* | **.example.com* |'
- en: '| *ample.com* | Cookie not set: domain mismatch |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *ample.com* | Cookie not set: domain mismatch |'
- en: '| *.com* | Cookie not set: domain too broad, security risk |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| *.com* | Cookie not set: domain too broad, security risk |'
- en: 'The only other true cookie-scoping parameter is the path prefix: Any cookie
    can be set with a specified *path* value. This instructs the browser to send the
    cookie back only on requests to matching directories; a cookie scoped to *domain*
    of *example.com* and *path* of */some/path/* will be included on a request to'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的另一个真正的cookie作用域参数是路径前缀：任何cookie都可以设置一个指定的*path*值。这指示浏览器仅在请求匹配的目录时发送cookie；一个作用域为*example.com*的*domain*和*path*为*/some/path/*的cookie将包含在请求到
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This mechanism can be deceptive. URL paths are not taken into account during
    same-origin policy checks and, therefore, do not form a useful security boundary.
    Regardless of how cookies work, JavaScript code can simply hop between any URLs
    on a single host at will and inject malicious payloads into such targets, abusing
    any functionality protected with path-bound cookies. (Several security books and
    white papers recommend path scoping as a security measure to this day. In most
    cases, this advice is dead wrong.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制可能会产生误导。在检查同源策略时，URL 路径不被考虑，因此不能形成一个有用的安全边界。无论cookie如何工作，JavaScript代码都可以随意跳转到单个主机上的任何URL，并将恶意负载注入到这些目标中，滥用任何受路径边界cookie保护的功能。（至今仍有几本安全书籍和白皮书推荐将路径作用域作为安全措施。在大多数情况下，这种建议是错误的。）
- en: 'Other than the true scoping features (which, along with cookie name, constitute
    a tuple that uniquely identifies every cookie), web servers can also output cookies
    with two special, independently operated flags: *httponly* and *secure*. The first,
    *httponly*, prevents access to the cookie via the *document.cookie* API in the
    hope of making it more difficult to simply copy a user’s credentials after successfully
    injecting a malicious script on a page. The second, *secure*, stops the cookie
    from being submitted on requests over unencrypted protocols, which makes it possible
    to build HTTPS services that are resistant to active attacks.^([[48](#ftn.CHP-9-FN-6)])'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了真正的作用域功能（这些功能与cookie名称一起构成一个元组，唯一地标识了每个cookie）之外，Web服务器还可以输出带有两个特殊、独立操作的标志的cookie：*httponly*和*secure*。第一个，*httponly*，通过防止通过*document.cookie*
    API访问cookie，希望使其更难在成功注入恶意脚本后简单地复制用户的凭据。第二个，*secure*，阻止cookie在未加密的协议上的请求中提交，这使得构建能够抵御主动攻击的HTTPS服务成为可能。[^([[48](#ftn.CHP-9-FN-6)])
- en: The pitfall of these mechanisms is that they protect data only against reading
    and not against overwriting. For example, it is still possible for JavaScript
    code delivered over HTTP to simply overflow the per-domain cookie jar and then
    set a new cookie without the *secure* flag.^([[49](#ftn.CHP-9-FN-7)]) Because
    the *Cookie* header sent by the browser provides no metadata about the origin
    of a particular cookie or its scope, such a trick is very difficult to detect.
    A prominent consequence of this behavior is that the common “stateless” way of
    preventing cross-site request forgery vulnerabilities by simultaneously storing
    a secret token in a client-side cookie and in a hidden form field, and then comparing
    the two, is not particularly safe for HTTPS websites. See if you can figure out
    why!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制的陷阱在于它们只保护数据免受读取，而不保护免受覆盖。例如，通过 HTTP 传输的 JavaScript 代码仍然可以简单地溢出每个域的 cookie
    容器，然后设置一个新的 cookie 而不使用 *secure* 标志。[^49](#ftn.CHP-9-FN-7) 由于浏览器发送的 *Cookie* 标头没有提供有关特定
    cookie 的来源或其作用域的元数据，这种技巧很难检测。这种行为的一个显著后果是，常见的“无状态”方式防止跨站请求伪造漏洞，即同时在一个客户端 cookie
    和一个隐藏表单字段中存储一个秘密令牌，然后比较这两个令牌，对于 HTTPS 网站来说并不特别安全。看看你是否能弄清楚为什么！
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Speaking of destructive interference, until 2010, *httponly* cookies also clashed
    with *XMLHttpRequest*. The authors of that API simply have not given any special
    thought to whether the *XMLHttpRequest.getResponseHeader(...)* function should
    be able to inspect server-supplied *Set-Cookie* values flagged as *httponly*—with
    predictable results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 说到破坏性干扰，直到 2010 年，*httponly* cookies 也与 *XMLHttpRequest* 发生冲突。该 API 的作者根本没有考虑过
    *XMLHttpRequest.getResponseHeader(...)* 函数是否应该能够检查标记为 *httponly* 的服务器提供的 *Set-Cookie*
    值——结果是可预见的。
- en: Impact of Cookies on the Same-Origin Policy
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookies 对同源策略的影响
- en: The same-origin policy has some undesirable impact on the security of cookies
    (specifically, on the path-scoping mechanism), but the opposite interaction is
    more common and more problematic. The difficulty is that HTTP cookies often function
    as credentials, and in such cases, the ability to obtain them is roughly equivalent
    to finding a way to bypass SOP. Quite simply, with the right set of cookies, an
    attacker could use her own browser to interact with the target site on behalf
    of the victim; same-origin policy is taken out of the picture, and all bets are
    off.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略对 cookies 的安全性（特别是路径范围机制）有一些不良影响，但相反的交互更为常见且更成问题。困难在于 HTTP cookies 经常充当凭证，在这种情况下，获取它们的能力大致等同于找到绕过
    SOP 的方法。简单地说，有了正确的一组 cookies，攻击者可以使用自己的浏览器代表受害者与目标网站交互；同源策略就被排除在外，所有的赌注都取消了。
- en: Because of this property, any discrepancies between the two security mechanisms
    can lead to trouble for the more restrictive one. For example, the relatively
    promiscuous domain-scoping rules used by HTTP cookies mean that it is not possible
    to isolate fully the sensitive content hosted on *webmail.example.com* from the
    less trusted HTML present on *blog.example.com*. Even if the owners of the webmail
    application scope their cookies tightly (usually at the expense of complicating
    the sign-on process), any attacker who finds a script injection vulnerability
    on the blogging site can simply overflow the per-domain cookie jar, drop the current
    credentials, and set his own **.example.com* cookies. These injected cookies will
    be sent to *webmail.example.com* on all subsequent requests and will be largely
    indistinguishable from the real ones.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，两种安全机制之间的任何差异都可能导致对限制更严格的那一方造成麻烦。例如，HTTP cookies使用的相对宽松的域范围规则意味着无法完全隔离托管在
    *webmail.example.com* 上的敏感内容与托管在 *blog.example.com* 上的不太可信的 HTML。即使 webmail 应用的所有者将
    cookies 的范围限制得很紧（通常是以复杂化登录过程为代价），任何在博客网站上发现脚本注入漏洞的攻击者都可以简单地溢出每个域的 cookie 容器，丢弃当前的凭证，并设置自己的
    **.example.com** cookies。这些注入的 cookies 将在所有后续请求中发送到 *webmail.example.com*，并且与真实的
    cookies 几乎无法区分。
- en: 'This trick may seem harmless until you realize that such an action may effectively
    log the victim into a bogus account and that, as a result, certain actions (such
    as sending email) may be unintentionally recorded within that account and leaked
    to the attacker before any foul play is noticed. If webmail sounds too exotic,
    consider doing the same on Amazon or Netflix: Your casual product searches may
    be revealed to the attacker before you notice anything unusual about the site.
    (On top of this, many websites are simply not prepared to handle malicious payloads
    in injected cookies, and unexpected inputs may lead to XSS or similar bugs.)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧看起来可能无害，直到你意识到这样的行为可能会有效地将受害者登录到一个虚假账户，并且因此，某些操作（如发送电子邮件）可能会在该账户中无意中记录下来，并在任何恶行被发现之前泄露给攻击者。如果你觉得webmail太陌生，考虑在Amazon或Netflix上做同样的事情：你的产品搜索可能会在你注意到网站有任何异常之前被攻击者发现。（此外，许多网站根本未准备好处理注入cookie中的恶意负载，意外的输入可能导致XSS或类似的漏洞。）
- en: The antics of HTTP cookies also make it very difficult to secure encrypted traffic
    against network-level attackers. A *secure* cookie set by [https://webmail.example.com/](https://webmail.example.com/)
    can still be clobbered and replaced by a made-up value set by a spoofed page at
    [http://webmail.example.com/](http://webmail.example.com/), even if there is no
    actual web service listening on port 80 on the target host.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP cookie的恶作剧也使得在网络级别攻击者面前保护加密流量变得非常困难。由[https://webmail.example.com/](https://webmail.example.com/)设置的*安全*cookie仍然可能被篡改并被[http://webmail.example.com/](http://webmail.example.com/)上的伪造页面设置的虚构值所替代，即使目标主机上没有实际监听80端口的网络服务。
- en: Problems with Domain Restrictions
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域限制问题
- en: The misguided notion of allowing domain-level cookies also poses problems for
    browser vendors and is a continuing source of misery. The key question is how
    to reliably prevent *example.com* from setting a cookie for **.com* and avoid
    having this cookie unexpectedly sent to every other destination on the Internet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 允许域级cookie的错误观念也给浏览器供应商带来了问题，并且是持续痛苦的来源。关键问题是如何可靠地防止*example.com*为**.com**设置cookie，并避免这个cookie意外地发送到互联网上的每个其他目的地。
- en: 'Several simple solutions come to mind, but they fall apart when you have to
    account for country-level TLDs: *example.com.pl* must be prevented from setting
    a **.com.pl* cookie, too. Realizing this, the original Netscape cookie specification
    provided the following advice:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几个简单的解决方案，但当你必须考虑国家级TLD时，它们就会失效：*example.com.pl*也必须防止设置**.com.pl**的cookie。意识到这一点，原始的Netscape
    cookie规范提供了以下建议：
- en: 'Only hosts within the specified domain can set a cookie for a domain and domains
    must have at least two (2) or three (3) periods in them to prevent domains of
    the form: “.com”, “.edu”, and “va.us”.'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有指定域内的主机才能为该域设置cookie，并且域必须至少包含两个（2）或三个（3）点，以防止形式为“ .com”，“ .edu”，“ va.us”的域。
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Any domain that fails within one of the seven special top level domains listed
    below only requires two periods. Any other domain requires at least three. The
    seven special top level domains are: “COM”, “EDU”, “NET”, “ORG”, “GOV”, “MIL”,
    and “INT”.'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下七个特殊顶级域之一中失败的任何域只需要两个点。其他域至少需要三个点。这七个特殊顶级域是：“COM”，“EDU”，“NET”，“ORG”，“GOV”，“MIL”，“INT”。
- en: Alas, the three-period rule makes sense only for country-level registrars that
    mirror the top-level hierarchy (*example.co.uk*) but not for the just as populous
    group of countries that accept direct registrations (*example.fr*). In fact, there
    are places where both approaches are allowed; for example, both *example.jp* and
    *example.co.jp* are perfectly fine.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，三段式规则只适用于像*example.co.uk*这样的顶级域镜像的国家级注册商，而不适用于同样人口众多的直接注册接受国家群体（如*example.fr*）。实际上，有些地方两种方法都是允许的；例如，*example.jp*和*example.co.jp*都是完全可行的。
- en: Because of the out-of-touch nature of this advice, most browsers disregarded
    it and instead implemented a patchwork of conditional expressions that only led
    to more trouble. (In one case, for over a decade, you could actually set cookies
    for **.com.pl*.) Comprehensive fixes to country-code top-level domain handling
    have shipped in all modern browsers in the past four years, but as of this writing
    they have not been backported to Internet Explorer 6 and 7, and they probably
    never will be.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些建议与实际脱节，大多数浏览器都忽视了它们，并实施了一系列条件表达式，这反而导致了更多的问题。（在一种情况下，超过十年，你实际上可以为**.com.pl**设置cookie。）在过去四年中，所有现代浏览器都发布了针对国家代码顶级域处理的综合修复方案，但截至本文撰写时，它们还没有被回滚到Internet
    Explorer 6和7，而且可能永远不会。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To add insult to injury, the Internet Assigned Numbers Authority added a fair
    number of top-level domains in recent years (for example, *.int* and *.biz*),
    and it is contemplating a proposal to allow arbitrary generic top-level domain
    registrations. If it comes to this, cookies will probably have to be redesigned
    from scratch.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人愤慨的是，互联网数字分配机构近年来添加了相当数量的顶级域名（例如，*.int*和*.biz*），并且正在考虑一个允许任意通用顶级域名注册的提案。如果真的发展到这一步，cookie可能不得不从头开始重新设计。
- en: The Unusual Danger of “localhost”
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “localhost”的异常危险
- en: One immediately evident consequence of the existence of domain-level scoping
    of cookies is that it is fairly unsafe to delegate any hostnames within a sensitive
    domain to any untrusted (or simply vulnerable) party; doing so may affect the
    confidentiality, and invariably the integrity, of any cookie-stored credentials—and,
    consequently, of any other information handled by the targeted application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 域级作用域的cookie存在的一个明显后果是，将敏感域内的任何主机名委托给任何不可信（或简单来说易受攻击）的第三方都是相当不安全的；这样做可能会影响任何存储在cookie中的凭证的机密性，并且不可避免地会影响其完整性——进而影响目标应用程序处理的其他任何信息。
- en: 'So much is obvious, but in 2008, Tavis Ormandy spotted something far less intuitive
    and far more hilarious:^([[180](pr03.html#ftn.CHP-9-FT-5)]) that because of the
    port-agnostic behavior of HTTP cookies, an additional danger lies in the fairly
    popular and convenient administrative practice of adding a “localhost” entry to
    a domain and having it point to 127.0.0.1.^([[50](#ftn.CHP-9-FN-8)]) When Ormandy
    first published his advisory, he asserted that this practice is widespread—not
    a controversial claim to make—and included the following resolver tool output
    to illustrate his point:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，但在2008年，Tavis Ormandy发现了一些远不如直观且更加滑稽的事情：[180](pr03.html#ftn.CHP-9-FT-5)]
    由于HTTP cookie的无端口感知行为，一个额外的危险在于相当流行且方便的行政实践，即在域中添加一个“localhost”条目，并将其指向127.0.0.1。[50](#ftn.CHP-9-FN-8)]
    当Ormandy首次发布他的警告时，他断言这种做法很普遍——这不是一个有争议的声明——并包括以下解析器工具输出以说明他的观点：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Why would this be a security risk? Quite simply, it puts the HTTP services
    on the user’s own machine within the same domain as the remainder of the site,
    and more importantly, it puts all the services that only *look* like HTTP in the
    very same bucket. These services are typically not exposed to the Internet, so
    there is no perceived need to design them carefully or keep them up-to-date. Tavis’s
    case in point is a printer-management service provided by CUPS (Common UNIX Printing
    System), which would execute attacker-supplied JavaScript in the context of *example.com*
    if invoked in the following way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这会是一个安全风险？简单地说，它将用户机器上的HTTP服务与网站的其他部分放在同一个域中，更重要的是，它将所有看似HTTP的服务放在同一个桶中。这些服务通常不会暴露在互联网上，因此没有感知到需要精心设计它们或保持它们更新的需求。Tavis的案例是一个由CUPS（通用UNIX打印系统）提供的打印机管理服务，如果以以下方式调用，它将在*example.com*的上下文中执行攻击者提供的JavaScript：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The vulnerability in CUPS can be fixed, but there are likely many other dodgy
    local services on all operating systems—everything from disk management tools
    to antivirus status dashboards. Introducing entries pointing back to 127.0.0.1,
    or any other destinations you have no control over, ties the security of cookies
    within your domain to the security of random third-party software. That is a good
    thing to avoid.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: CUPS中的漏洞可以修复，但所有操作系统上可能还有许多其他可疑的本地服务——从磁盘管理工具到防病毒状态仪表板应有尽有。引入指向127.0.0.1或其他你无法控制的任何目的地的条目，将你域内cookie的安全性绑定到随机第三方软件的安全性。这是应该避免的好事。
- en: Cookies and “Legitimate” DNS Hijacking
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookie和“合法”DNS劫持
- en: The perils of the domain-scoping policy for cookies don’t end with *localhost*.
    Another unintended interaction is related to the common, widely criticized practice
    of some ISPs and other DNS service providers of hijacking domain lookups for nonexistent
    (typically mistyped) hosts. In this scheme, instead of returning the standard-mandated
    NXDOMAIN response from an upstream name server (which would subsequently trigger
    an error message in the browser or other networked application), the provider
    will falsify a record to imply that this name resolves to its site. Its site,
    in turn, will examine the *Host* header supplied by the browser and provide the
    user with unsolicited, paid contextual advertising that appears to be vaguely
    related to her browsing interests. The usual justification offered for this practice
    is that of offering a more user-friendly browsing experience; the real incentive,
    of course, is to make more money.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于cookie的域作用域策略的危险并不局限于 *localhost*。另一个意想不到的交互与一些ISP和其他DNS服务提供商的常见、广泛批评的做法有关，即劫持对不存在（通常是拼写错误）的主机的域名查找。在这个方案中，提供商不是从上游名称服务器返回标准要求的NXDOMAIN响应（这会随后在浏览器或其他网络应用程序中触发错误消息），而是伪造一个记录来暗示该名称解析到其网站。其网站反过来会检查浏览器提供的
    *Host* 头部，并向用户提供看似与她浏览兴趣相关的不请自来的、付费的上下文广告。这种做法通常提供的正当理由是提供更用户友好的浏览体验；当然，真正的动机是赚取更多利润。
- en: Internet service providers that have relied on this practice include Cablevision,
    Charter, Earthlink, Time Warner, Verizon, and many more. Unfortunately, their
    approach is not only morally questionable, but it also creates a substantial security
    risk. If the advertising site contains any script-injection vulnerabilities, the
    attacker can exploit them in the context of any other domain simply by accessing
    the vulnerable functionality through an address such as *nonexistent.example.com*.
    When coupled with the design of HTTP cookies, this practice undermines the security
    of any arbitrarily targeted services on the Internet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖这种做法的互联网服务提供商包括Cablevision、Charter、Earthlink、Time Warner、Verizon以及许多更多。不幸的是，他们的方法不仅道德上有疑问，而且也创造了重大的安全风险。如果广告网站包含任何脚本注入漏洞，攻击者可以通过访问诸如
    *nonexistent.example.com* 这样的地址来利用这些漏洞，在任意其他域的上下文中。当与HTTP cookie的设计相结合时，这种做法破坏了互联网上任何任意目标服务的安全性。
- en: Predictably, script-injection vulnerabilities can be found in such hastily designed
    advertising traps without much effort. For example, in 2008, Dan Kaminsky spotted
    and publicized a cross-site scripting vulnerability on the pages operated by Earthlink.^([[181](pr03.html#ftn.CHP-9-FT-6)])
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 预计之下，这种匆忙设计的广告陷阱中可以轻易地发现脚本注入漏洞。例如，在2008年，丹·卡明斯基发现了并公开了一个由Earthlink运营的页面上的跨站脚本漏洞.^([[181](pr03.html#ftn.CHP-9-FT-6)])
- en: 'All right, all right: It’s time to stop obsessing over cookies and move on.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好吧：是时候停止对cookie的痴迷，继续前进。
- en: '* * *'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[48](#CHP-9-FN-6)]) It does not matter that *https://webmail.example.com/*
    is offered only over HTTPS. If it uses a cookie that is not locked to encrypted
    protocols, the attacker may simply wait until the victim navigates to [http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/),
    silently inject a frame pointing to [http://webmail.example.com/](http://webmail.example.com/)
    on that page, and then intercept the resulting TCP handshake. The browser will
    then send all the *webmail.example.com* cookies over an unencrypted channel, and
    at this point the game is essentially over.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[48](#CHP-9-FN-6)]) 即使提供的网址 *https://webmail.example.com/* 只能通过HTTPS访问，如果它使用了一个未锁定到加密协议的cookie，攻击者只需等待受害者导航到
    [http://www.fuzzybunnies.com/](http://www.fuzzybunnies.com/)，就可以在页面上静默地注入一个指向
    [http://webmail.example.com/](http://webmail.example.com/) 的框架，然后拦截产生的TCP握手。此时，浏览器将发送所有
    *webmail.example.com* 的cookie通过未加密的通道，游戏基本上就结束了。
- en: ^([[49](#CHP-9-FN-7)]) Even if this possibility is prevented by separating the
    jars for *httponly* and normal cookies, multiple identically named but differently
    scoped cookies must be allowed to coexist, and they will be sent together on any
    matching requests. They will be not accompanied by any useful metadata, and their
    ordering will be undefined and browser specific.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#CHP-9-FN-7)]) 即使通过将 *httponly* 和普通cookie的jar分开来防止这种可能性，也必须允许存在多个同名但作用域不同的cookie，它们将在任何匹配的请求中一起发送。它们不会伴随任何有用的元数据，并且它们的顺序将是未定义的，并且是浏览器特定的。
- en: ^([[50](#CHP-9-FN-8)]) This IP address is reserved for loopback interfaces;
    any attempt to connect to it will route you back to the services running on your
    own machine.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#CHP-9-FN-8)]) 这个IP地址是为回环接口保留的；任何尝试连接到它的尝试都会将您路由回您自己机器上运行的服务。
- en: Plug-in Security Rules
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件安全规则
- en: Browsers do not provide plug-in developers with a uniform and extensible API
    for enforcing security policies; instead, each plug-in decides what rules should
    be applied to executed content and how to put them into action. Consequently,
    even though plug-in security models are to some extent inspired by the same-origin
    policy, they diverge from it in a number of ways.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器并没有为插件开发者提供一个统一和可扩展的API来强制执行安全策略；相反，每个插件都决定应该应用于执行内容哪些规则以及如何实施它们。因此，尽管插件安全模型在某种程度上受到同源策略的启发，但在许多方面都与它不同。
- en: This disconnect can be dangerous. In [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts"), we discussed the tendency for plug-ins to rely on inspecting the JavaScript
    *location* object to determine the origin of their hosting page. This misguided
    practice forced browser developers to restrict the ability of JavaScript programs
    to tamper with some portions of their runtime environment to save the day. Another
    related, common source of incompatibilities is the interpretation of URLs. For
    example, in the middle of 2010, one researcher discovered that Adobe Flash had
    trouble with the following URL:^([[182](pr03.html#ftn.CHP-9-FT-7)])
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种脱节可能很危险。在[第6章](ch06.html "第6章。浏览器端脚本")中，我们讨论了插件倾向于检查JavaScript *location*对象以确定其宿主页面的来源的趋势。这种错误的做法迫使浏览器开发者限制JavaScript程序对其运行时环境的某些部分的篡改能力，以挽救局面。另一个相关的、常见的兼容性问题来源是对URL的解释。例如，在2010年中旬，一位研究人员发现Adobe
    Flash在以下URL上存在问题:^([[182](pr03.html#ftn.CHP-9-FT-7)])
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The plug-in decided that the origin of any code retrieved through this URL should
    be set to *example.com*, but the browser, when presented with such a URL, would
    naturally retrieve the data from [bunnyoutlet.com](http://bunnyoutlet.com) instead
    and then hand it over to the confused plug-in for execution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 插件决定通过此URL检索的任何代码的来源应设置为*example.com*，但浏览器在遇到此类URL时，自然会从[bunnyoutlet.com](http://bunnyoutlet.com)检索数据，然后将它交给困惑的插件执行。
- en: While this particular bug is now fixed, other vulnerabilities of this type can
    probably be expected in the future. Replicating some of the URL-parsing quirks
    discussed in [Chapter 2](ch02.html "Chapter 2. It Starts with a URL") and [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol") can be a fool’s errand and, ideally,
    should not be attempted at all.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个特定的漏洞现在已经修复，但未来可能还会出现这种类型的其他漏洞。复制[第2章](ch02.html "第2章。一切从URL开始")和[第3章](ch03.html
    "第3章。超文本传输协议")中讨论的一些URL解析怪癖可能是一项徒劳的任务，理想情况下，根本不应该尝试。
- en: It would not be polite to end this chapter on such a gloomy note! Systemic problems
    aside, let’s see how some of the most popular plug-ins approach the job of security
    policy enforcement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的悲观基调下结束这一章是不礼貌的！除了系统性问题之外，让我们看看一些最受欢迎的插件是如何处理安全策略强制执行的。
- en: Adobe Flash
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Adobe Flash
- en: The Flash security model underwent a major overhaul in 2008,^([[183](pr03.html#ftn.CHP-9-FT-8)])
    and since then, it has been reasonably robust. Every loaded Flash applet is now
    assigned an SOP-like origin derived from its originating URL^([[51](#ftn.CHP-9-FN-9)])
    and is granted nominal origin-related permissions roughly comparable to those
    of JavaScript. In particular, each applet can load cookie-authenticated content
    from its originating site, load some constrained datatypes from other origins,
    and make same-origin *XMLHttpRequest*-like HTTP calls through the *URLRequest*
    API. The set of permissible methods and request headers for this last API is managed
    fairly reasonably and, as of this writing, is more restrictive than most of the
    browser-level blacklists for *XMLHttpRequest* itself.^([[184](pr03.html#ftn.CHP-9-FT-9)])
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Flash安全模型在2008年经历了重大改革^([[183](pr03.html#ftn.CHP-9-FT-8)])，自那以后，它已经相当稳健。现在每个加载的Flash小程序都被分配了一个类似于SOP的来源，该来源来自其原始URL^([[51](#ftn.CHP-9-FN-9)])，并且被授予与JavaScript相当的名义来源相关权限。特别是，每个小程序都可以从其原始站点加载经过cookie认证的内容，从其他来源加载一些受限制的数据类型，并且可以通过*URLRequest*
    API进行类似*XMLHttpRequest*的HTTP调用。这个最后API允许的方法和请求头集合被相当合理地管理，并且截至本文撰写时，比大多数浏览器级别的*XMLHttpRequest*黑名单更为严格.^([[184](pr03.html#ftn.CHP-9-FT-9)])
- en: On top of this sensible baseline, three flexible but easily misused mechanisms
    permit this behavior to be modified to some extent, as discussed next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个合理的基线之上，三种灵活但容易被误用的机制允许在一定程度上修改这种行为，如以下所述。
- en: Markup-Level Security Controls
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记级别安全控制
- en: 'The embedding page can specify three special parameters provided through *<embed>*
    or *<object>* tags to control how an applet will interact with its host page and
    the browser itself:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入页面可以通过*<embed>*或*<object>*标签提供的三个特殊参数来指定，以控制小程序如何与其宿主页面和浏览器本身交互：
- en: AllowScriptAccess **parameter** This setting controls an applet’s ability to
    use the JavaScript *ExternalInterface.call(...)* bridge (see [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins")) to execute JavaScript statements
    in the context of the embedding site. Possible values are *always*, *never*, and
    *sameorigin*; the last setting gives access to the page only if the page is same-origin
    with the applet itself. (Prior to the 2008 security overhaul, the plug-in defaulted
    to *always*; the current default is the much safer *sameorigin*.)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许脚本访问**参数**此设置控制小程序使用JavaScript *ExternalInterface.call(...)*桥接（见[第8章](ch08.html
    "第8章. 使用浏览器插件进行内容渲染"））在嵌入站点上下文中执行JavaScript语句的能力。可能的值是*总是*、*从不*和*sameorigin*；最后一个设置仅在页面与小程序本身同源时才提供对页面的访问。（在2008年安全升级之前，插件默认为*总是*；当前的默认值是更安全的*sameorigin*。）
- en: AllowNetworking **parameter** This poorly named setting restricts an applet’s
    permission to open or navigate browser windows and to make HTTP requests to its
    originating server. When set to *all* (the default), the applet can interfere
    with the browser; when set to *internal*, it can perform only nondisruptive, internal
    communications through the Flash plug-in. Setting this parameter to *none* disables
    most network-related APIs altogether.^([[52](#ftn.CHP-9-FN-10)]) (Prior to recent
    security improvements, *allowNetworking=all* opened up several ways to bypass
    *allowScriptAccess=none*, for example, by calling *getURL(...)* on a *javascript:*
    URL. As of this writing, however, all scripting URLs should be blacklisted in
    this scenario.)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许网络**参数**这个命名不佳的设置限制了小程序打开或导航浏览器窗口以及对其原始服务器进行HTTP请求的权限。当设置为*all*（默认值）时，小程序可以干扰浏览器；当设置为*internal*时，它只能通过Flash插件执行非破坏性的内部通信。将此参数设置为*none*将完全禁用大多数与网络相关的API。（在最近的安全改进之前，*allowNetworking=all*打开了绕过*allowScriptAccess=none*的几种方法，例如，在*javascript:*
    URL上调用*getURL(...)*。然而，截至本文写作时，所有脚本URL都应该在此场景中被列入黑名单。）
- en: AllowFullScreen **parameter** This parameter controls whether an applet should
    be permitted to go into full-screen rendering mode. The possible values are *true*
    and *false*, with *false* being the default. As noted in [Chapter 8](ch08.html
    "Chapter 8. Content Rendering with Browser Plug-ins"), the decision to give this
    capability to Flash applets is problematic due to UI spoofing risks; it should
    be not enabled unless genuinely necessary.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许全屏**参数**此参数控制小程序是否应被允许进入全屏渲染模式。可能的值是*true*和*false*，其中*false*是默认值。如[第8章](ch08.html
    "第8章. 使用浏览器插件进行内容渲染"）所述，由于UI欺骗风险，赋予Flash小程序此功能是有问题的；除非确实有必要，否则不应启用。
- en: Security.allowDomain(...)
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Security.allowDomain(...)
- en: 'The *Security.allowDomain(...)* method^([[185](pr03.html#ftn.CHP-9-FT-10)])
    allows Flash applets to grant access to their variables and functions to any JavaScript
    code or to other applets coming from a different origin. Buyer beware: Once such
    access is granted, there is no reliable way to maintain the integrity of the original
    Flash execution context. The decision to grant such permissions should not be
    taken lightly, and the practice of calling *allowDomain("*")* should usually be
    punished severely.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Security.allowDomain(...)*方法允许Flash小程序将其变量和函数授予来自不同源的所有JavaScript代码或其他小程序。购买者请注意：一旦授予此类访问权限，就再也没有可靠的方法来维护原始Flash执行上下文的完整性。授予此类权限的决定不应轻率行事，并且通常应严厉惩罚调用*allowDomain("*")*的做法。'
- en: Note that a weirdly named *allowInsecureDomain(...)* method is also available.
    The existence of this method does not indicate that *allowDomain(...)* is particularly
    secure; rather, the “insecure” variant is provided for compatibility with ancient,
    pre-2003 semantics that completely ignored the HTTP/HTTPS divide.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有一个名为*allowInsecureDomain(...)*的奇怪方法也是可用的。这个方法的存在并不表明*allowDomain(...)*特别安全；相反，提供“不安全”变体是为了与古老的、2003年之前的语义兼容，这些语义完全忽略了HTTP/HTTPS的划分。
- en: Cross-Domain Policy Files
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨域策略文件
- en: 'Through the use of *loadPolicyFile(...)*, any Flash applet can instruct its
    runtime environment to retrieve a security policy file from an almost arbitrary
    URL. This XML-based document, usually named *crossdomain.xml*, will be interpreted
    as an expression of consent to cross-domain, server-level access to the origin
    determined by examining the policy URL.^([[186](pr03.html#ftn.CHP-9-FT-11)]) The
    syntax of a policy file is fairly self-explanatory and may look like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 *loadPolicyFile(...)*，任何Flash小程序都可以指示其运行时环境从几乎任意的URL检索安全策略文件。这个基于XML的文档，通常命名为
    *crossdomain.xml*，将被解释为对跨域、服务器级访问由检查策略URL确定的源的表达同意。[^([[186](pr03.html#ftn.CHP-9-FT-11)])]
    策略文件的语法相当直观，可能看起来像这样：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The policy may permit actions such as loading cross-origin resources or issuing
    arbitrary *URLRequest* calls with whitelisted headers, through the browser HTTP
    stack. Flash developers do attempt to enforce a degree of path separation: A policy
    loaded from a particular subdirectory can in principle permit access only to files
    within that path. In practice, however, the interactions with SOP and with various
    path-mapping semantics of modern browsers and web application frameworks make
    it unwise to depend on this boundary.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 政策可能允许通过浏览器HTTP堆栈执行诸如加载跨源资源或使用白名单头发出任意 *URLRequest* 调用等操作。Flash开发者确实尝试执行一定程度上的路径分离：从特定子目录加载的策略原则上只允许访问该路径内的文件。然而，在实践中，与SOP（安全策略）以及现代浏览器和Web应用程序框架的各种路径映射语义的交互使得依赖这种边界是不明智的。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Making raw TCP connections via *XMLSocket* is also possible and controlled by
    an XML policy, but following Flash’s 2008 overhaul, *XMLSocket* requires that
    a separate policy file be delivered on TCP port 843 of the destination server.
    This is fairly safe, because no other common services run on this port and, on
    many operating systems, only privileged users can launch services on any port
    below 1024\. Because of the interactions with certain firewall-level mechanisms,
    such as FTP protocol helpers, this design may still cause some network-level interference,^([[187](pr03.html#ftn.CHP-9-FT-12)])
    but this topic is firmly beyond the scope of this book
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *XMLSocket* 建立原始TCP连接也是可能的，并且由XML策略控制。但是，在Flash于2008年进行重大改版之后，*XMLSocket*
    要求在目标服务器的TCP端口843上交付一个单独的策略文件。这是相当安全的，因为在这个端口上没有运行其他常见服务，并且在许多操作系统上，只有特权用户可以在任何低于1024的端口上启动服务。由于与某些防火墙级机制（如FTP协议助手）的交互，这种设计可能仍然会导致一些网络级干扰，[^([[187](pr03.html#ftn.CHP-9-FT-12)])]
    但这个主题远远超出了本书的范围。
- en: As expected, poorly configured *crossdomain.xml* policies are an appreciable
    security risk. In particular, it is a very bad idea to specify *allow-access-from*
    rules that point to any domain you do not have full confidence in. Further, specifying
    “`*`” as a value for this parameter is roughly equivalent to executing *document.domain
    = “com”*. That is, it’s a death wish.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，配置不当的 *crossdomain.xml* 策略是一个明显的安全风险。特别是，指定指向任何你对其没有完全信心的域的 *allow-access-from*
    规则是一个非常糟糕的想法。此外，将“`*`”指定为该参数的值大致等同于执行 *document.domain = “com”*。也就是说，这是自寻死路。
- en: Policy File Spoofing Risks
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略文件欺骗风险
- en: Other than the possibility of configuration mistakes, another security risk
    with Adobe’s policy-based security model is that random user-controlled documents
    may be interpreted as cross-domain policies, contrary to the site owner’s intent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置错误的可能性之外，Adobe基于策略的安全模型中另一个安全风险是，随机用户控制的文档可能被解释为跨域策略，这与网站所有者的意图相反。
- en: Prior to 2008, Flash used a notoriously lax policy parser, which when processing
    *loadPolicyFile(...)* files would skip arbitrary leading garbage in search of
    the opening *<cross-domain-policy>* tag. It would simply ignore the MIME type
    returned by the server when downloading the resource, too. As a result, merely
    hosting a valid, user-supplied JPEG image could become a grave security risk.
    The plug-in also skipped over any HTTP redirects, making it dangerous to do something
    as simple as issuing an HTTP redirect to a location you did not control (an otherwise
    harmless act).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在2008年之前，Flash使用了一个臭名昭著的宽松策略解析器，在处理 *loadPolicyFile(...)* 文件时会跳过任意前导垃圾以寻找开头的
    *<cross-domain-policy>* 标签。它还会简单地忽略服务器在下载资源时返回的MIME类型。因此，仅仅托管一个有效的、用户提供的JPEG图像就可能成为一个严重的安全风险。插件还会跳过任何HTTP重定向，因此向一个你无法控制的地点（一个在其他方面无害的行为）发出HTTP重定向是危险的。
- en: Following the much-needed revamp of the *loadPolicyFile* behavior, many of the
    gross mistakes have been corrected, but the defaults are still not perfect. On
    the one hand, redirects now work intuitively, and the file must be a well-formed
    XML document. On the other, permissible MIME types include *text/**, *application/xml*,
    and *application/xhtml+xml*, which feels a bit too broad. *text/plain* or *text/csv*
    may be misinterpreted as a policy file, and that should not be the case.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在对*loadPolicyFile*行为进行必要的改进之后，许多重大错误已经得到纠正，但默认设置仍然不完美。一方面，重定向现在工作得直观，文件必须是一个格式良好的XML文档。另一方面，允许的MIME类型包括*text/**,
    *application/xml*, 和 *application/xhtml+xml*，这感觉有点太宽泛。*text/plain*或*text/csv*可能会被误解释为策略文件，而这不应该发生。
- en: Thankfully, to mitigate the problem, Adobe engineers decided to roll out *meta-policies*,
    policies that are hosted at a predefined, top-level location (*/crossdomain.xml*)
    that the attacker can’t override. A meta-policy can specify sitewide restrictions
    for all the remaining policies loaded from attacker-supplied URLs. The most important
    of these restrictions is *<site-control permitted-cross-domain-policies="...">*.
    This parameter, when set to *master-only*, simply instructs the plug-in to disregard
    subpolicies altogether. Another, less radical value, *by-content-type*, permits
    additional policies to be loaded but requires them to have a nonambiguous *Content-Type*
    header set to *text/x-cross-domain-policy*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为了减轻这个问题，Adobe工程师决定推出*meta-policies*，这些策略托管在预定义的顶级位置（*/crossdomain.xml*），攻击者无法覆盖。元策略可以指定从攻击者提供的URL加载的所有剩余策略的网站范围限制。其中最重要的限制是*<site-control
    permitted-cross-domain-policies="...">*。当此参数设置为*master-only*时，简单地向插件指示完全忽略子策略。另一个不那么激进的值，*by-content-type*，允许加载额外的策略，但要求它们必须有一个非歧义的*Content-Type*头，设置为*text/x-cross-domain-policy*。
- en: Needless to say, it’s highly advisable to use a meta-policy that specifies one
    of these two directives.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，强烈建议使用指定这两个指令之一的元策略。
- en: Microsoft Silverlight
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微软Silverlight
- en: If the transition from Flash to Silverlight seems abrupt, it’s because the two
    are easy to confuse. The Silverlight plug-in borrows from Flash with remarkable
    zeal; in fact, it is safe to say that most of the differences between their security
    models are due solely to nomenclature. Microsoft’s platform uses the same-origin-determination
    approach, substitutes *allowScriptAccess* with *enableHtmlAccess*, replaces *crossdomain.xml*
    with the slightly different *clientaccesspolicy.xml* syntax, provides a *System.Net.Sockets*
    API instead of *XMLSocket*, uses *HttpWebRequest* in place of *URLRequest*, rearranges
    the flowers, and changes the curtains in the living room.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从Flash过渡到Silverlight看起来很突然，那是因为两者很容易混淆。Silverlight插件以惊人的热情借鉴了Flash；事实上，可以说它们之间的安全模型差异大部分仅仅是因为命名。微软的平台使用相同的源确定方法，用*enableHtmlAccess*替换了*allowScriptAccess*，用稍微不同的*clientaccesspolicy.xml*语法替换了*crossdomain.xml*，提供了*System.Net.Sockets*
    API而不是*XMLSocket*，用*HttpWebRequest*代替了*URLRequest*，重新排列了花，还更换了客厅的窗帘。
- en: 'The similarities are striking, down to the list of blocked request headers
    for the *HttpWebRequest* API, which even includes *X-Flash-Version* from the Adobe
    spec.^([[188](pr03.html#ftn.CHP-9-FT-13)]) Such consistency is not a problem,
    though: In fact, it is preferable to having a brand-new security model to take
    into account. Plus, to its credit, Microsoft did make a couple of welcome improvements,
    including ditching the insecure *allowDomain* logic in favor of *RegisterScriptableObject*,
    an approach that allows only explicitly specified callbacks to be exposed to third-party
    domains.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的相似之处非常明显，甚至包括*HttpWebRequest* API阻止的请求头列表，甚至包括Adobe规范中的*X-Flash-Version*。[188](pr03.html#ftn.CHP-9-FT-13)]
    这种一致性并不是问题：事实上，与完全新的安全模型相比，这是更可取的。此外，值得称赞的是，微软确实做了一些受欢迎的改进，包括放弃不安全的*allowDomain*逻辑，转而采用*RegisterScriptableObject*方法，这种方法只允许显式指定的回调暴露给第三方域。
- en: Java
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java
- en: Sun’s Java (now officially belonging to Oracle) is a very curious case. Java
    is a plug-in that has fallen into disuse, and its security architecture has not
    received much scrutiny in the past decade or so. Yet, because of its large installed
    base, it is difficult to simply ignore it and move on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Sun的Java（现在正式属于Oracle）是一个非常有趣的情况。Java是一个已经不再使用的插件，其安全架构在过去十年左右的时间里并没有得到太多的审查。然而，由于其庞大的安装基础，很难简单地忽略它并继续前进。
- en: Unfortunately, the closer you look, the more evident it is that the ideas embraced
    by Java tend to be incompatible with the modern Web. For example, a class called
    *java.net.HttpURLConnection*^([[189](pr03.html#ftn.CHP-9-FT-14)]) permits credential-bearing
    HTTP requests to be made to an applet’s originating website, but the “originating
    website” is understood as *any* website hosted at a particular IP address, as
    sanctioned by the *java.net.URL.equals(...)* check. This model essentially undoes
    any isolation between HTTP/1.1 virtual hosts—an isolation strongly enforced by
    the same-origin policy, HTTP cookies, and virtually all other browser security
    mechanisms in use today.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，越深入地观察，越明显的是，Java 所采纳的理念往往与现代网络不兼容。例如，一个名为 *java.net.HttpURLConnection*^([[189](pr03.html#ftn.CHP-9-FT-14)])
    的类允许对小程序的源网站发起带有凭证的 HTTP 请求，但“源网站”被理解为在特定 IP 地址上托管的所有网站，这是由 *java.net.URL.equals(...)*
    检查所认可的。这种模型本质上取消了 HTTP/1.1 虚拟主机之间的任何隔离——这种隔离是由同源策略、HTTP 饼干和今天几乎所有其他浏览器安全机制严格实施的。
- en: Further along these lines, the *java.net.URLConnection* class^([[190](pr03.html#ftn.CHP-9-FT-15)])
    allows arbitrary request headers, including *Host*, to be set by the applet, and
    another class, *Socket*,^([[191](pr03.html#ftn.CHP-9-FT-16)]) permits unconstrained
    TCP connections to arbitrary ports on the originating server. All of these behaviors
    are frowned upon in the browser and in any other contemporary plug-in.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这些思路进一步，*java.net.URLConnection* 类^([[190](pr03.html#ftn.CHP-9-FT-15)]) 允许小程序设置任意请求头，包括
    *Host*，并且另一个类，*Socket*^([[191](pr03.html#ftn.CHP-9-FT-16)]) 允许在源服务器上的任意端口建立不受限制的
    TCP 连接。所有这些行为在浏览器和任何其他当代插件中都是不被推荐的。
- en: 'Origin-agnostic access from the applet to the embedding page is provided through
    the *JSObject* mechanism and is expected to be controlled by the embedding party
    through the *mayscript* attribute specified in the *<applet>*, *<embed>*, or *<object>*
    tags.^([[192](pr03.html#ftn.CHP-9-FT-17)]) The documentation suggests that this
    is a security feature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 小程序通过 *JSObject* 机制提供对嵌入页面的无原点访问，并期望通过在 *<applet>*, *<embed>*, 或 *<object>*
    标签中指定的 *mayscript* 属性来由嵌入方控制.^([[192](pr03.html#ftn.CHP-9-FT-17)]) 文档建议这是一个安全特性：
- en: Due to security reasons, JSObject support is not enabled in Java Plug-in by
    default. To enable JSObject support in Java Plug-in, a new attribute called MAYSCRIPT
    needs to be present in the EMBED/OBJECT tag.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于安全原因，Java 插件默认不启用 JSObject 支持。要启用 Java 插件中的 JSObject 支持，需要在 EMBED/OBJECT 标签中存在一个名为
    MAYSCRIPT 的新属性。
- en: Unfortunately, the documentation neglects to mention that another closely related
    mechanism, *DOMService*,^([[193](pr03.html#ftn.CHP-9-FT-18)]) ignores this setting
    and gives applets largely unconstrained access to the embedding page. While *DOMService*
    is not supported in Firefox and Opera, it is available in other browsers, which
    makes any attempt to load third-party Java content equivalent to granting full
    access to the embedding site.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，文档没有提到另一个与之密切相关的机制，*DOMService*^([[193](pr03.html#ftn.CHP-9-FT-18)]) 忽略了这个设置，并给予小程序对嵌入页面的几乎不受限制的访问。虽然
    *DOMService* 在 Firefox 和 Opera 中不受支持，但它在其他浏览器中可用，这使得加载第三方 Java 内容的任何尝试都等同于授予嵌入站点的完全访问权限。
- en: Whoops.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Interesting fact: Recent versions of Java attempt to copy the *crossdomain.xml*
    support available in Flash.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：Java 的最新版本试图复制 Flash 中的 *crossdomain.xml* 支持。
- en: '* * *'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[51](#CHP-9-FN-9)]) In some contexts, Flash may implicitly permit access
    from HTTPS origins to HTTP ones but not the other way round. This is usually harmless,
    and as such, it is not given special attention throughout the remainder of this
    section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[51](#CHP-9-FN-9)]) 在某些情况下，Flash 可能隐式允许从 HTTPS 原始地访问 HTTP，但不是反过来。这通常是无害的，因此在本节的其余部分没有给予特殊关注。
- en: ^([[52](#CHP-9-FN-10)]) It should not be assumed that this setting prevents
    any sensitive data available to a rogue applet from being relayed to third parties.
    There are many side channels that any Flash applet could leverage to leak information
    to a cooperating party without directly issuing network requests. In the simplest
    and most universal case, CPU loads can be manipulated to send out individual bits
    of information to any simultaneously loaded applet that continuously samples the
    responsiveness of its runtime environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[52](#CHP-9-FN-10)]) 不应假设这种设置可以阻止任何恶意小程序可用的敏感数据被转发给第三方。任何Flash小程序都可以利用许多旁路通道，在不直接发出网络请求的情况下，将信息泄露给合作方。在最简单和最普遍的情况下，可以通过操纵CPU负载来向任何同时加载的小程序发送单个信息位，这些小程序会持续采样其运行时环境的响应性。
- en: Coping with Ambiguous or Unexpected Origins
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应对模糊或意外的来源
- en: This concludes our overview of the basic security policies and consent isolation
    mechanisms. If there is one observation to be made, it’s that most of these mechanisms
    depend on the availability of a well-formed, canonical hostname from which to
    derive the context for all the subsequent operations. But what if this information
    is not available or is not presented in the expected form?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对基本安全策略和同意隔离机制的概述。如果要说一个观察结果，那就是这些机制中的大多数都依赖于一个良好形成的、规范的主机名，以便从中推导出所有后续操作的环境上下文。但假如这个信息不可用或者不是以预期的形式呈现呢？
- en: Well, that’s when things get funny. Let’s have a look at some of the common
    corner cases, even if just for fleeting amusement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，事情变得有趣了。让我们看看一些常见的边缘情况，即使只是为了短暂的娱乐。
- en: IP Addresses
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址
- en: Due to the failure to account for IP addresses when designing HTTP cookies and
    the same-origin policy, almost all browsers have historically permitted documents
    loaded from, say, *http://1.2.3.4/* to set cookies for a “domain” named **.3.4*.
    Adjusting *document.domain* in a similar manner would work as well. In fact, some
    of these behaviors are still present in older versions of Internet Explorer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在设计HTTP cookie和同源策略时未能考虑到IP地址，几乎所有浏览器都历史性地允许从，比如说，*http://1.2.3.4/*加载的文档为名为**.3.4**的“域名”设置cookie。以类似的方式调整*document.domain*也会有效。事实上，这些行为中的一些仍然存在于较老版本的Internet
    Explorer中。
- en: This behavior is unlikely to have an impact on mainstream web applications,
    because such applications are not meant to be accessed through an IP-based URL
    and will often simply fail to function properly. But a handful of systems, used
    primarily by technical staff, are meant to be accessed by their IP addresses;
    these systems may simply not have DNS records configured at all. In these cases,
    the ability for *http://1.2.3.4/* to inject cookies for *http://123.234.3.4/*
    may be an issue. The IP-reachable administrative interfaces of home routers are
    of some interest, too.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为不太可能对主流Web应用产生影响，因为这些应用并不是通过基于IP的URL访问的，并且通常会简单地无法正常工作。但有一些系统，主要用于技术人员，是通过它们的IP地址访问的；这些系统可能根本就没有配置DNS记录。在这些情况下，*http://1.2.3.4/*向*http://123.234.3.4/*注入cookie的能力可能成为一个问题。家庭路由器的IP可达管理接口也引起了一些兴趣。
- en: Hostnames with Extra Periods
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有额外句点的主机名
- en: At their core, cookie-setting algorithms still depend on counting the number
    of periods in a URL to determine whether a particular *domain* parameter is acceptable.
    In order to make the call, the count is typically correlated with a list of several
    hundred entries on the vendor-maintained Public Suffix List ([http://publicsuffix.org/](http://publicsuffix.org/)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，设置cookie的算法仍然依赖于计算URL中句点的数量，以确定特定的*域名*参数是否可接受。为了做出这个判断，通常会将这个计数与供应商维护的数百个条目的公共后缀列表（[http://publicsuffix.org/](http://publicsuffix.org/)）相关联。
- en: Unfortunately for this algorithm, it is often possible to put extra periods
    in a hostname and still have it resolve correctly. Noncanonical hostname representations
    with excess periods are usually honored by OS-level resolvers and, if honored,
    will confuse the browser. Although said browser would not automatically consider
    a domain such as [www.example.com.pl](http://www.example.com.pl). (with an extra
    trailing period) to be the same as the real [www.example.com.pl](http://www.example.com.pl),
    the subtle and seemingly harmless difference in the URL could escape even the
    most attentive users.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于这个算法来说，通常可以在主机名中添加额外的点，同时仍然正确解析。带有额外点的非规范主机名表示通常被操作系统级别的解析器所尊重，如果被尊重，将会使浏览器困惑。尽管如此，浏览器不会自动将带有额外尾点的域名[www.example.com.pl](http://www.example.com.pl)视为与真实的[www.example.com.pl](http://www.example.com.pl)相同。（带有额外的尾点）URL中的微妙且看似无害的差异可能会逃过甚至最警觉的用户。
- en: In such a case, interacting with the URL with trailing period can be unsafe,
    as other documents sharing the **.com.pl*. domain may be able to inject cross-domain
    cookies with relative ease.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，与带有尾点的URL交互可能是不安全的，因为共享**.com.pl**域的其他文档可能能够相对容易地注入跨域cookies。
- en: This period-counting problem was first noticed around 1998.^([[194](pr03.html#ftn.CHP-9-FT-19)])
    About a decade later, many browser vendors decided to roll out basic mitigations
    by adding a yet another special case to the relevant code; as of this writing,
    Opera is still susceptible to this trick.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种点计数问题首次在1998年左右被发现.^([[194](pr03.html#ftn.CHP-9-FT-19)]) 十年后，许多浏览器供应商决定通过在相关代码中添加另一个特殊情况来实施基本缓解措施；截至本文撰写时，Opera仍然容易受到这种技巧的影响。
- en: Non-Fully Qualified Hostnames
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非完全合格的主机名
- en: Many users browse the Web with their DNS resolvers configured to append local
    suffixes to all found hostnames, often without knowing. Such settings are usually
    sanctioned by ISPs or employers through automatic network configuration data (Dynamic
    Host Configuration Protocol, DHCP).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用户在不知道的情况下，使用配置了将本地后缀附加到所有找到的主机名的DNS解析器浏览网络。这种设置通常由ISP或雇主通过自动网络配置数据（动态主机配置协议，DHCP）授权。
- en: For any user browsing with such a setting, the resolution of DNS labels is ambiguous.
    For example, if the DNS search path includes *coredump.cx*, then [www.example.com](http://www.example.com)
    may resolve to the real [www.example.com](http://www.example.com) website or to
    [www.example.com.coredump.cx](http://www.example.com.coredump.cx) if such a record
    exists. The outcomes are partly controlled by configuration settings and, to some
    extent, can be influenced by an attacker.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用这种设置的任何用户，DNS标签的解析是模糊的。例如，如果DNS搜索路径包括*coredump.cx*，那么[www.example.com](http://www.example.com)可能解析到真实的[www.example.com](http://www.example.com)网站，或者如果存在这样的记录，解析到[www.example.com.coredump.cx](http://www.example.com.coredump.cx)。结果部分受配置设置控制，并在一定程度上可能受到攻击者的影响。
- en: 'To the browser, both locations appear to be the same, which may have some interesting
    side effects. Consider one particularly perverse case: Should *http://com*, which
    actually resolves to [http://com.coredump.cx/](http://com.coredump.cx/), be able
    to set **.com* cookies by simply omitting the *domain* parameter?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浏览器来说，这两个位置看起来是相同的，这可能会产生一些有趣的副作用。考虑一个特别扭曲的情况：*http://com*，实际上解析到[http://com.coredump.cx/](http://com.coredump.cx/)，是否能够通过简单地省略*domain*参数来设置**.com**
    cookies？
- en: Local Files
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地文件
- en: Because local resources loaded through the *file:* protocol do not have an explicit
    hostname associated with them, it’s impossible for the browser to compute a normal
    origin. For a very long time, the vendors simply decided that the best course
    of action in such a case would be to simply ditch the same-origin policy. Thus,
    any HTML document saved to disk would automatically be granted access to any other
    local files via *XMLHttpRequest* or DOM and, even more inexplicably, would be
    able to access any Internet-originating content in the same way.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过*file:*协议加载的本地资源没有与它们关联的显式主机名，浏览器无法计算正常的源。在很长一段时间里，供应商简单地决定在这种情况下最好的做法就是简单地放弃同源策略。因此，任何保存到磁盘的HTML文档都会自动获得通过*XMLHttpRequest*或DOM访问任何其他本地文件的权限，甚至更令人费解的是，能够以相同的方式访问任何来自互联网的内容。
- en: This proved to be a horrible design decision. No one expected that the mere
    act of downloading an HTML document would put all of the user’s local files, and
    his online credentials, in jeopardy. After all, accessing that same document over
    the Web would be perfectly safe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明是一个糟糕的设计决策。没有人预料到仅仅下载一个 HTML 文档的行为就会将用户的本地文件和在线凭证置于危险之中。毕竟，通过网络访问相同的文档是完全安全的。
- en: 'Many browsers have tried to close this loophole in recent years, with varying
    degrees of success:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 许多浏览器近年来试图以不同程度的成功关闭这一漏洞：
- en: '**Chrome (and, by extension, other WebKit browsers)**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chrome（以及由此扩展的其他 WebKit 浏览器）**'
- en: The Chrome browser completely disallows any cross-document DOM or *XMLHttpRequest*
    access from *file:* origins, and it ignores *document.cookie* calls or *<meta
    http-equiv="Set-Cookie" ...>* directives in this setting. Access to a *localStorage*
    container shared by all *file:* documents is permitted, but this may change soon.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 浏览器完全禁止从 *file:* 原始来源进行任何跨文档 DOM 或 *XMLHttpRequest* 访问，并且在此设置中忽略 *document.cookie*
    调用或 *<meta http-equiv="Set-Cookie" ...>* 指令。允许访问所有 *file:* 文档共享的 *localStorage*
    容器，但这种情况可能很快会改变。
- en: '**Firefox**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firefox**'
- en: Mozilla’s browser permits access only to files within the directory of the original
    document, as well as nearby subdirectories. This policy is pretty good, but it
    still poses some risk to documents stored or previously downloaded to that location.
    Access to cookies via *document.cookie* or *<meta http-equiv="Set-Cookie" ...>*
    is possible, and all *file:* cookies are visible to any other local JavaScript
    code.^([[53](#ftn.CHP-9-FN-11)]) The same holds true for access to storage mechanisms.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 的浏览器只允许访问原始文档目录内的文件以及附近的子目录。这项政策相当不错，但仍然对存储或以前下载到该位置的文档存在一定风险。通过 *document.cookie*
    或 *<meta http-equiv="Set-Cookie" ...>* 访问 cookie 是可能的，并且所有 *file:* cookie 都对任何其他本地
    JavaScript 代码可见.^([[53](#ftn.CHP-9-FN-11)]) 对于访问存储机制也是如此。
- en: '**Internet Explorer 7 and above**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Internet Explorer 7 及以上版本**'
- en: Unconstrained access to local and Internet content from *file:* origins is permitted,
    but it requires the user to click through a nonspecific warning to execute JavaScript
    first. The consequences of this action are not explained clearly (the help subsystem
    cryptically states that *“Internet Explorer restricts this content because occasionally
    these programs can malfunction or give you content you don’t want”*), and many
    users may well be tricked into clicking through the prompt.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 允许从 *file:* 原始来源无限制地访问本地和互联网内容，但需要用户点击一个非特定的警告来首先执行 JavaScript。这一行动的后果没有明确说明（帮助系统神秘地表示，“Internet
    Explorer 限制此内容，因为这些程序偶尔可能会出错或给你不想要的内容”），许多用户可能会被误导而点击提示。
- en: Internet Explorer’s cookie semantics are similar to those of Firefox. Web storage
    is not supported in this origin, however.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer 的 cookie 语义与 Firefox 类似。在此原始来源中不支持 Web 存储。
- en: '**Opera** and **Internet Explorer 6**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Opera** 和 **Internet Explorer 6**'
- en: Both of these browsers permit unconstrained DOM or *XMLHttpRequest* access without
    further checks. Noncompartmentalized *file:* cookies are permitted, too.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种浏览器都允许无限制的 DOM 或 *XMLHttpRequest* 访问，而不进行进一步检查。也允许非分区的 *file:* cookie。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Plug-ins live by their own rules in *file:* land: Flash uses a *local-with-filesystem*
    sandbox model,^([[195](pr03.html#ftn.CHP-9-FT-20)]) which gives largely unconstrained
    access to the local filesystem, regardless of the policy enforced by the browser
    itself, while executing Java or Windows Presentation Framework applets from the
    local filesystem may in some cases be roughly equivalent to running an untrusted
    binary.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在 *file:* 领域按照自己的规则运行：Flash 使用 *local-with-filesystem* 沙盒模型，^([[195](pr03.html#ftn.CHP-9-FT-20)])
    这为本地文件系统提供了大量不受限制的访问权限，无论浏览器本身执行的政策如何，而从本地文件系统执行 Java 或 Windows Presentation Framework
    小程序在某些情况下可能大致等同于运行不可信的二进制文件。
- en: Pseudo-URLs
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪 URL
- en: The behavior of pseudo-URLs such as *about:*, *data:*, or *javascript:* originally
    constituted a significant loophole in the implementations of the same-origin policy.
    All such URLs would be considered same-origin and would permit unconstrained cross-domain
    access from any other resource loaded over the same scheme. The current behavior,
    which is very different, will be the topic of the next chapter of this book; in
    a nutshell, the status quo reflects several rounds of hastily implemented improvements
    and is a complex mix of browser-specific special cases and origin-inheritance
    rules.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 *about:*、*data:* 或 *javascript:* 这样的伪 URL 的行为最初构成了同源策略实现中的一个重大漏洞。所有这样的 URL
    都会被视为同源，并允许不受限制的跨域访问来自加载了相同方案的任何其他资源。当前的行为与之前大相径庭，将是本书下一章的主题；简而言之，现状反映了多次匆忙实施的改进，是浏览器特定特殊情况与源继承规则复杂混合的结果。
- en: Browser Extensions and UI
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器扩展和 UI
- en: Several browsers permit JavaScript-based UI elements or certain user-installed
    browser extensions to run with elevated privileges. These privileges may entail
    circumventing specific SOP checks or calling normally unavailable APIs in order
    to write files, modify configuration settings, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 几种浏览器允许基于 JavaScript 的 UI 元素或某些用户安装的浏览器扩展以提升权限运行。这些权限可能包括绕过特定的 SOP 检查或调用通常不可用的
    API 来写入文件、修改配置设置等。
- en: Privileged JavaScript is a prominent feature of Firefox, where it is used with
    XUL to build large portions of the browser user interface. Chrome also relies
    on privileged JavaScript to a smaller but still notable degree.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 特权 JavaScript 是 Firefox 的一个显著特性，在那里它与 XUL 一起用于构建浏览器用户界面的大部分。Chrome 也依赖于特权 JavaScript，程度较小但仍很显著。
- en: 'The same-origin policy does not support privileged contexts in any specific
    way. The actual mechanism by which extra privileges are granted may involve loading
    the document over a special and normally unreachable URL scheme, such as *chrome:*
    or *res:*, and then adding special cases for that scheme in other portions of
    the browser code. Another option is simply to toggle a binary flag for a JavaScript
    context, regardless of its actual origin, and examine that flag later. In all
    cases, the behavior of standard APIs such as *localStorage*, *document.domain*,
    or *document.cookie* may be difficult to predict and should not be relied upon:
    Some browsers attempt to maintain isolation between the contexts belonging to
    different extensions, but most don’t.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略并没有以任何特定方式支持特权上下文。实际授予额外权限的机制可能涉及通过特殊且通常无法到达的 URL 方案（如 *chrome:* 或 *res:*）加载文档，然后在浏览器代码的其他部分为该方案添加特殊案例。另一种选择是简单地为一个
    JavaScript 上下文切换一个二进制标志，无论其实际源是什么，然后在之后检查该标志。在所有情况下，标准 API（如 *localStorage*、*document.domain*
    或 *document.cookie*）的行为可能难以预测，不应依赖：一些浏览器试图在不同扩展的上下文之间保持隔离，但大多数并不这样做。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever writing browser extensions, any interaction with nonprivileged contexts
    must be performed with extreme caution. Examining untrusted contexts can be difficult,
    and the use of mechanisms such as *eval(...)* or *innerHMTL* may open up privilege-escalation
    paths.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写浏览器扩展时，与非特权上下文的任何交互都必须极端谨慎地进行。检查不受信任的上下文可能很困难，使用诸如 *eval(...)* 或 *innerHTML*
    这样的机制可能会打开权限提升路径。
- en: '* * *'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[53](#CHP-9-FN-11)]) Because there is no compartmentalization between *file:*
    cookies, it is unsafe to rely on them for legitimate purposes. Some locally installed
    HTML applications ignore this advice, and consequently, their cookies can be easily
    tampered with by any downloaded, possibly malicious, HTML document viewed by the
    user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[53](#CHP-9-FN-11)]) 由于 *file:* 钩子之间没有隔离，因此依赖它们进行合法目的是不安全的。一些本地安装的 HTML 应用程序忽略了这一建议，因此它们的
    cookie 可以很容易地被用户查看的任何下载的、可能恶意的内容篡改。
- en: Other Uses of Origins
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源的其他用途
- en: Well, that’s all to be said about browser-level content isolation logic for
    now. It is perhaps worth noting that the concept of origins and host- or domain-based
    security mechanisms is not limited to that particular task and makes many other
    appearances in the browser world. Other quasi-origin-based privacy or security
    features include preferences and cached information related to per-site cookie
    handling, pop-up blocking, geolocation sharing, password management, camera and
    microphone access (in Flash), and much, much more. These features tend to interact
    with the security features described in this chapter at least to some extent;
    we explore this topic in more detail soon.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于浏览器级别的内容隔离逻辑就说到这里。也许值得指出的是，原点和基于主机或域的安全机制的概念并不仅限于那个特定任务，并在浏览器世界中出现了许多其他情况。其他基于准原点的隐私或安全特性包括与每个站点相关的首选项和缓存信息、弹出窗口阻止、地理位置共享、密码管理、摄像头和麦克风访问（在
    Flash 中），以及更多。这些特性至少在一定程度上与本章中描述的安全特性相互作用；我们将在不久的将来更详细地探讨这个主题。
- en: Security Engineering Cheat Sheet
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程备忘单
- en: Good Security Policy Hygiene for All Websites
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网站的优秀安全策略
- en: To protect your users, include a top-level *crossdomain.xml* file with the *permitted-cross-domain-policies*
    parameter set to *master-only* or *by-content-type*, even if you do not use Flash
    anywhere on your site. Doing so will prevent unrelated attacker-controlled content
    from being misinterpreted as a secondary *crossdomain.xml* file, effectively undermining
    the assurances of the same-origin policy in Flash-enabled browsers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护您的用户，包括一个顶层 *crossdomain.xml* 文件，并将 *permitted-cross-domain-policies* 参数设置为
    *master-only* 或 *by-content-type*，即使您在网站上任何地方都不使用 Flash。这样做将防止无关的攻击者控制的内容被错误地解释为次要的
    *crossdomain.xml* 文件，从而有效地破坏了 Flash 启用浏览器中同源策略的保证。
- en: When Relying on HTTP Cookies for Authentication
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖 HTTP Cookies 进行身份验证时
- en: Use the *httponly* flag; design the application so that there is no need for
    JavaScript to access authentication cookies directly. Sensitive cookies should
    be scoped as tightly as possible, preferably by not specifying *domain* at all.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *httponly* 标志；设计应用程序，使其不需要 JavaScript 直接访问身份验证 cookie。敏感 cookie 应尽可能紧密地限定作用域，最好根本不指定
    *domain*。
- en: If the application is meant to be HTTPS only, cookies must be marked as *secure*,
    and you must be prepared to handle cookie injection gracefully. (HTTP contexts
    may overwrite *secure* cookies, even though they can’t read them.) Cryptographic
    cookie signing may help protect against unconstrained modification, but it does
    not defend against replacing a victim’s cookies with another set of legitimately
    obtained credentials.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序仅打算使用 HTTPS，则必须将 cookie 标记为 *secure*，并且你必须准备好优雅地处理 cookie 注入。（HTTP 上下文可能会覆盖
    *secure* cookie，尽管它们无法读取它们。）加密 cookie 签名可能有助于防止不受限制的修改，但它不能防御用另一组合法获得的凭据替换受害者的
    cookie。
- en: When Arranging Cross-Domain Communications in JavaScript
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 JavaScript 中安排跨域通信时
- en: 'Do not use *document.domain*. Rely on *postMessage(...)* where possible and
    be sure to specify the destination origin correctly; then verify the sender’s
    origin when receiving the data on the other end. Beware of naïve substring matches
    for domain names: *msg.origin.indexOf(".example.com")* is very insecure.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 *document.domain*。尽可能依赖 *postMessage(...)*，并确保正确指定目标源；然后在另一端接收数据时验证发送者的源。警惕对域名进行天真子串匹配：*msg.origin.indexOf(".example.com")*
    非常不安全。
- en: Note that various pre-*postMessage* SOP bypass tricks, such as relying on *window.name*,
    are not tamper-proof and should not be used for exchanging sensitive data.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，各种预-*postMessage* SOP 绕过技巧，如依赖 *window.name*，不是防篡改的，不应用于交换敏感数据。
- en: When Embedding Plug-in-Handled Active Content from Third Parties
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌入第三方处理的插件式活动内容时
- en: Consult the cheat sheet in [Chapter 8](ch08.html "Chapter 8. Content Rendering
    with Browser Plug-ins") first for general advice.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查阅[第 8 章](ch08.html "第 8 章。使用浏览器插件进行内容渲染")中的备忘单以获取一般建议。
- en: '**Flash:** Do not specify *allowScriptAccess=always* unless you fully trust
    the owner of the originating domain and the security of its site. Do not use this
    setting when embedding HTTP applets on HTTPS pages. Also, consider restricting
    *allowFullScreen* and *allowNetworking* as appropriate.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flash:** 除非你完全信任原始域的所有者和其网站的安全性，否则不要指定 *allowScriptAccess=always*。在将 HTTP
    小程序嵌入 HTTPS 页面时不要使用此设置。此外，根据需要考虑限制 *allowFullScreen* 和 *allowNetworking*。'
- en: '**Silverlight:** Do not specify *enableHtmlAccess=true* unless you trust the
    originating domain, as above.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Silverlight:** 除非你信任原始域名，如上所述，否则不要指定 *enableHtmlAccess=true*。'
- en: '**Java:** Java applets can’t be safely embedded from untrusted sources. Omitting
    *mayscript* does not fully prevent access to the embedding page, so do not attempt
    to do so.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java:** 来自不受信任来源的Java小程序不能安全嵌入。省略 *mayscript* 并不能完全防止访问嵌入页面，因此不要尝试这样做。'
- en: When Hosting Your Own Plug-in-Executed Content
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当托管你自己的插件执行内容时
- en: Note that many cross-domain communication mechanisms provided by browser plug-ins
    may have unintended consequences. In particular, avoid *crossdomain.xml*, *clientaccesspolicy.xml*,
    or *allowDomain(...)* rules that point to domains you do not fully trust.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，浏览器插件提供的许多跨域通信机制可能具有意想不到的后果。特别是，避免使用 *crossdomain.xml*、*clientaccesspolicy.xml*
    或指向你不完全信任的域的 *allowDomain(...)* 规则。
- en: When Writing Browser Extensions
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写浏览器扩展时
- en: Avoid relying on *innerHTML*, *document.write(...)*, *eval(...)*, and other
    error-prone coding patterns, which can cause code injection on third-party pages
    or in a privileged JavaScript context.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免依赖 *innerHTML*、*document.write(...)*、*eval(...)* 和其他容易出错的编码模式，这些模式可能导致第三方页面或特权JavaScript上下文中的代码注入。
- en: Do not make security-critical decisions by inspecting untrusted JavaScript security
    contexts, as their behavior can be deceptive.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要通过检查不受信任的JavaScript安全上下文来做出安全关键的决定，因为它们的行为可能是欺骗性的。
- en: Chapter 10. Origin Inheritance
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 源继承
- en: Some web applications rely on pseudo-URLs such as *about:*, *javascript:*, or
    *data:* to create HTML documents that do not contain any server-supplied content
    and that are instead populated with the data constructed entirely on the client
    side. This approach eliminates the delay associated with the usual HTTP requests
    to the server and results in far more responsive user interfaces.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web应用程序依赖于伪URL，如 *about:*、*javascript:* 或 *data:*，来创建不包含任何服务器提供内容的HTML文档，而是用完全在客户端构建的数据填充。这种方法消除了与服务器通常的HTTP请求相关的延迟，并导致用户界面响应更快。
- en: Unfortunately, the original vision of the same-origin policy did not account
    for such a use case. Specifically, a literal application of the protocol-, host-,
    and port-matching rules discussed in [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic") would cause every *about:blank* document created on the client
    side to have a different origin from its parent page, preventing it from being
    meaningfully manipulated. Further, all *about:blank* windows created by completely
    unrelated websites would belong to the same origin and, under the right circumstances,
    would be able to interfere with each other with no supervision at all.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，同源策略的原始愿景没有考虑到这种使用案例。具体来说，对第9章中讨论的协议、主机和端口匹配规则的直接应用会导致客户端创建的每个 *about:blank*
    文档与它的父页面有不同的源，从而阻止它被有意义地操作。此外，由完全不相关的网站创建的所有 *about:blank* 窗口将属于同一个源，在适当的条件下，它们将能够完全不受监督地相互干扰。
- en: To address this incompatibility of client-side documents with the same-origin
    policy, browsers gradually developed incompatible and sometimes counterintuitive
    approaches to computing a synthetic origin and access permissions for pseudo-URLs.
    An understanding of these rules is important on its own merit, and it will lay
    the groundwork for the discussion of certain other SOP exceptions in [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules").
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决客户端文档与同源策略的不兼容性，浏览器逐渐发展出了一些不兼容且有时令人费解的方法来计算伪URL的合成源和访问权限。理解这些规则本身就很重要，并且它将为讨论第11章中某些其他SOP异常打下基础。
- en: Origin Inheritance for about:blank
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: about:blank 的源继承
- en: 'The *about:* scheme is used in modern browsers for a variety of purposes, most
    of which are not directly visible to normal web pages. The *about:blank* document
    is an interesting special case, however: This URL can be used to create a minimal
    DOM hierarchy (essentially a valid but empty document) to which the parent document
    may write arbitrary data later on.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*about:* 方案在现代浏览器中用于多种目的，其中大多数对普通网页来说并不直接可见。然而，*about:blank* 文档是一个有趣的特殊情况：这个URL可以用来创建一个最小的DOM层次结构（本质上是一个有效但空的文档），之后父文档可以写入任意数据。'
- en: 'Here is an example of a typical use of this scheme:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个方案典型使用的一个例子：
- en: '[PRE15]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the HTML markup provided in this example, and when creating new windows or
    frames in general, *about:blank* can be omitted. The value is defaulted to when
    no other URL is specified by the creator of the parent document.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中提供的HTML标记中，以及创建新窗口或框架时，通常可以省略 *about:blank*。如果没有指定其他URL，则默认为此值。
- en: In every browser, most types of navigation to *about:blank* result in the creation
    of a new document that inherits its SOP origin from the page that initiated the
    navigation. The inherited origin is reflected in the *document.domain* property
    of the new JavaScript execution context, and DOM access to or from any other origins
    is not permitted.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个浏览器中，大多数导航到 *about:blank* 的操作都会创建一个新的文档，该文档从发起导航的页面继承其SOP源。继承的源反映在新JavaScript执行上下文的
    *document.domain* 属性中，并且不允许从任何其他源访问DOM。
- en: This simple formula holds true for navigation actions such as clicking a link,
    submitting a form, creating a new frame or a window from a script, or programmatically
    navigating an existing document. That said, there are exceptions, the most notable
    of which are several special, user-controlled navigation methods. These include
    manually entering *about:blank* in the address bar, following a bookmark, or performing
    a gesture reserved for opening a link in a new window or a tab.^([[54](#ftn.CHP-10-FN-1)])
    These actions will result in a document that occupies a unique synthetic origin
    and that can’t be accessed by any other page.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的公式适用于导航操作，例如点击链接、提交表单、从脚本中创建新框架或窗口，或以编程方式导航现有文档。尽管如此，存在例外情况，其中最值得注意的是几个特殊、由用户控制的导航方法。这些包括在地址栏手动输入
    *about:blank*、跟随书签，或执行用于在新窗口或标签页中打开链接的手势.^([[54](#ftn.CHP-10-FN-1)]) 这些操作将导致一个占据独特合成源且无法被任何其他页面访问的文档。
- en: 'Another special case is the loading of a normal server-supplied document that
    subsequently redirects to *about:blank* using *Location* or *Refresh*. In Firefox
    and WebKit-based browsers, such redirection results in a unique, nonaccessible
    origin, similar to the scenario outlined in the previous paragraph. In Internet
    Explorer, on the other hand, the resulting document will be accessible by the
    parent page if the redirection occurs inside an *<iframe>* but not if it took
    place in a separate window. Opera’s behavior is the most difficult to understand:
    *Refresh* results in a document that can be accessed by the parent page, but the
    *Location* redirect will give the resulting page the origin of the site that performed
    the redirect.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊情况是加载一个正常的由服务器提供的文档，随后使用 *Location* 或 *Refresh* 重定向到 *about:blank*。在Firefox和基于WebKit的浏览器中，这种重定向会导致一个独特且不可访问的源，类似于前一段中概述的情况。另一方面，在Internet
    Explorer中，如果重定向发生在 *<iframe>* 内，则生成的文档可以被父页面访问，但如果它发生在单独的窗口中，则不可访问。Opera的行为最难理解：*Refresh*
    导致一个可以被父页面访问的文档，但 *Location* 重定向将给生成的页面赋予执行重定向的网站的源。
- en: Further, it is possible for a parent document to navigate an existing document
    frame to an *about:blank* URL, even if the existing document shown in that container
    has a different origin than the caller.^([[55](#ftn.CHP-10-FN-2)]) The newly created
    blank document will inherit the origin from the caller in all browsers other than
    Internet Explorer. In the case of Internet Explorer, such navigation will succeed
    but will result in an inaccessible document. (This behavior is most likely not
    intentional.)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，父文档可以将现有文档框架导航到 *about:blank* URL，即使在该容器中显示的现有文档与调用者具有不同的源.^([[55](#ftn.CHP-10-FN-2)])
    在所有浏览器中，除了Internet Explorer之外，新创建的空白文档将从调用者那里继承源。在Internet Explorer的情况下，这种导航将成功，但将导致一个不可访问的文档。（这种行为可能不是故意的。）
- en: If this description makes your head spin, the handling of *about:blank* documents
    is summarized in [Table 10-1](ch10.html#origin_inheritance_for_about_colon "Table 10-1. Origin
    Inheritance for about:blank URLs").
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个描述让你感到困惑，*about:blank* 文档的处理方法总结在 [表10-1](ch10.html#origin_inheritance_for_about_colon
    "表10-1. Origin Inheritance for about:blank URLs") 中。
- en: Table 10-1. Origin Inheritance for *about:blank* URLs
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-1. *about:blank* URLs的源继承
- en: '|   | Type of navigation |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|   | 导航类型 |'
- en: '| --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| New page | Existing non-same-origin page | *Location* redirect | *Refresh*
    redirect | URL entry or gesture |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 新页面 | 已存在的非同源页面 | *Location* 重定向 | *Refresh* 重定向 | URL输入或手势 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Internet Explorer** | Inherited from caller | Unique origin | (Denied)
    | **Frame**: Inherited from parent | Unique origin |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer** | 从调用者继承 | 唯一来源 | (拒绝) | **框架**：从父级继承 | 唯一来源 |'
- en: '| **Window**: Unique origin |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **窗口**：唯一来源 |'
- en: '| **Firefox** | Inherited from caller | Unique origin |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **Firefox** | 从调用者继承 | 唯一来源 |'
- en: '| **All WebKit** | Inherited from caller | (Denied) | Unique origin |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **所有WebKit** | 从调用者继承 | (拒绝) | 唯一来源 |'
- en: '| **Opera** | Inherited from caller | Inherited from redirecting party | Inherited
    from parent |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **Opera** | 从调用者继承 | 从重定向方继承 | 从父级继承 |'
- en: '* * *'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[54](#CHP-10-FN-1)]) This is usually accomplished by holding ctrl or shift
    while clicking on a link, or by right-clicking the mouse to access a contextual
    menu, and then selecting the appropriate option.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[54](#CHP-10-FN-1)]) 这通常是通过在点击链接时按住ctrl或shift键，或者通过右键单击鼠标以访问上下文菜单，然后选择适当的选项来实现的。
- en: ^([[55](#CHP-10-FN-2)]) The exact circumstances that make this possible will
    be the focus of [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules").
    For now, suffice it to say that this can be accomplished in many settings in a
    browser-specific way. For example, in Firefox, you call *window.open(..., 'target')*,
    while in Internet Explorer, calling *target.location.assign(...)* is the way to
    go.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[55](#CHP-10-FN-2)]) 使这成为可能的确切情况将是 [第11章](ch11.html "第11章。跳出同源规则") 的重点。现在，只需说，这可以在许多浏览器特定的设置中实现。例如，在Firefox中，你调用
    *window.open(..., 'target')*，而在Internet Explorer中，调用 *target.location.assign(...)*
    是正确的方法。
- en: 'Inheritance for data: URLs'
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'data: URL的继承'
- en: 'The *data:* scheme,^([[196](pr03.html#ftn.CHP-10-FT-1)]) first outlined in
    [Chapter 2](ch02.html "Chapter 2. It Starts with a URL"), was designed to permit
    small documents, such as icons, to be conveniently encoded and then directly inlined
    in an HTML document, saving time on HTTP round-trips. For example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*data:* 方案，^([[196](pr03.html#ftn.CHP-10-FT-1)]) 首次在 [第2章](ch02.html "第2章。一切从URL开始")
    中概述，旨在允许小文档，如图标，方便地编码并在HTML文档中直接内联，从而节省HTTP往返时间。例如：'
- en: '[PRE16]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the *data:* scheme is used in conjunction with type-specific subresources,
    the only unusual security consideration is that it poses a challenge for plug-ins
    that wish to derive permissions for an applet from its originating URL. The origin
    can’t be computed by looking at the URL alone, and the behavior is somewhat unpredictable
    and highly plug-in specific (for example, Adobe Flash currently rejects any attempts
    to use *data:* documents).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当*data:* 方案与类型特定子资源一起使用时，唯一不寻常的安全考虑是它对插件构成了挑战，这些插件希望从其原始URL中获取小程序的权限。来源不能仅通过查看URL来计算，并且行为有些不可预测且高度依赖于插件（例如，Adobe
    Flash目前拒绝使用*data:* 文档的任何尝试）。
- en: 'More important than the case of type-specific content is the use of *data:*
    as a destination for windows and frames. In all browsers but Internet Explorer,
    the scheme can be used as an improved variant of *about:blank*, as in this example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 比类型特定内容的情况更重要的是，*data:* 作为窗口和框架的目标使用。在所有浏览器中除了Internet Explorer外，该方案可以用作*about:blank*的改进版本，如下例所示：
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this scenario, there is no compelling reason for a *data:* URL to behave
    differently than *about:blank*. In reality, however, it will behave differently
    in some browsers and therefore must be used with care.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有充分的理由让*data:* URL的行为与*about:blank*不同。然而，实际上，在某些浏览器中，它的行为会有所不同，因此必须谨慎使用。
- en: '**WebKit browsers** In Chrome and Safari, all *data:* documents are given a
    unique, nonaccessible origin and do not inherit from the parent at all.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebKit浏览器** 在Chrome和Safari中，所有*data:* 文档都被赋予一个唯一且不可访问的来源，并且完全不继承自父级。'
- en: '**Firefox** In Firefox, the origin for *data:* documents is inherited from
    the navigating context, similar to *about:blank*. However, unlike with *about:blank*,
    manually entering *data:* URLs or opening bookmarked ones results in the new document
    inheriting origin from the page on which the navigation occurred.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firefox** 在Firefox中，*data:* 文档的来源是从导航上下文继承的，类似于*about:blank*。然而，与*about:blank*不同，手动输入*data:*
    URL或打开书签会导致新文档从发生导航的页面继承来源。'
- en: '**Opera** As of this writing, a shared “empty” origin is used for all *data:*
    URLs, which is accessible by the parent document. This approach is unsafe, as
    it may allow cross-domain access to frames created by unrelated pages, as shown
    in [Figure 10-1](ch10s02.html#access_between_data_colon_urls_in_opera "Figure 10-1. Access
    between data: URLs in Opera"). (I reported this behavior to Opera, and it likely
    will be amended soon.)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opera** 到目前为止，所有 *data:* URL 都使用共享的“空”来源，该来源可以通过父文档访问。这种方法是不安全的，因为它可能允许跨域访问由无关页面创建的框架，如图
    10-1 所示。[图 10-1](ch10s02.html#access_between_data_colon_urls_in_opera "图 10-1.
    Opera 中 *data:* URL 之间的访问")。 (我已经向 Opera 报告了这种行为，它可能很快就会得到修正。)'
- en: '**Internet Explorer** *data:* URLs are not supported in Internet Explorer versions
    prior to 8\. The scheme is supported only for select types of subresources in
    Internet Explorer 8 and 9 and can’t be used for navigation.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internet Explorer** 中的 *data:* URL 在 8.0 之前的版本中不受支持。该方案仅在 Internet Explorer
    8 和 9 中支持某些类型的子资源，并且不能用于导航。'
- en: '[Table 10-2](ch10s02.html#origin_inheritance_for_data_colon_urls "Table 10-2. Origin
    Inheritance for data: URLs") summarizes the current behavior of *data:* URLs.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-2](ch10s02.html#origin_inheritance_for_data_colon_urls "表 10-2. *data:*
    URL 的来源继承") 总结了 *data:* URL 的当前行为。'
- en: Table 10-2. Origin Inheritance for *data:* URLs
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2. *data:* URL 的来源继承
- en: '|   | Type of navigation |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|   | 导航类型 |'
- en: '| --- | --- |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| New page | Existing non-same-origin page | *Location* redirect | *Refresh*
    redirect | URL entry or gesture |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 新页面 | 已存在的非同源页面 | *Location* 重定向 | *Refresh* 重定向 | URL 输入或手势 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Internet Explorer 6/7** | (Not supported) |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer 6/7** | (不支持) |'
- en: '| **Internet Explorer 8/9** | (Not supported for navigation) |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer 8/9** | (不支持导航) |'
- en: '| **Firefox** | Inherited from caller | Unique origin | Inherited from previous
    page |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| **Firefox** | 从调用者继承 | 唯一来源 | 从前一页继承 |'
- en: '| **All WebKit** | Unique origin | (Denied) | Unique origin | Unique origin
    |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| **所有 WebKit** | 唯一来源 | (拒绝) | 唯一来源 | 唯一来源 |'
- en: '| **Opera** | Shared origin (This is a bug!) | (Denied) | Inherited from parent
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **Opera** | 共享来源（这是一个错误！）| (拒绝) | 从父级继承 |'
- en: '![Access between data: URLs in Opera](httpatomoreillycomsourcenostarchimages950021.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Opera 中 *data:* URL 之间的访问](httpatomoreillycomsourcenostarchimages950021.png.jpg)'
- en: Figure 10-1. Access between *data:* URLs in Opera
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1. Opera 中 *data:* URL 之间的访问
- en: 'Inheritance for javascript: and vbscript: URLs'
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 和 VBScript 的继承：URL
- en: Scripting-related pseudo-URLs, such as *javscript:*, are a very curious mechanism.
    Using them to load some types of subresources will lead to code execution in the
    context of the document that attempts to load such an operation (subject to some
    inconsistent restrictions, as discussed in [Chapter 4](ch04.html "Chapter 4. Hypertext
    Markup Language")). An example of this may be
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与脚本相关的伪 URL，例如 *javscript:*，是一个非常奇特的机制。使用它们来加载某些类型的子资源将导致在尝试加载此类操作的文档上下文中执行代码（受一些不一致的限制，如第
    4 章所述[第 4 章](ch04.html "第 4 章。超文本标记语言")）。这种情况的一个例子可能是
- en: '[PRE18]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: More interestingly (and far less obviously) than the creation of new subresources,
    navigating existing windows or frames to *javascript:* URLs will cause the inlined
    JavaScript code to execute in the context of the navigated page (and not the navigating
    document!)—even if the URL is entered manually or loaded from a bookmark.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建新的子资源相比，更有趣（并且远不那么明显）的是，将现有窗口或框架导航到 *javascript:* URL 将导致内联 JavaScript 代码在导航页面的上下文中执行（而不是导航文档！）——即使
    URL 是手动输入或从书签加载的。
- en: 'Given this behavior, it is obviously very unsafe to allow one document to navigate
    any other non-same-origin context to a *javascript:* URL, as it would enable the
    circumvention of all other content-isolation mechanisms: Just load [fuzzybunnies.com](http://fuzzybunnies.com)
    in a frame, and then navigate that frame to *javascript:do_evil_stuff()* and call
    it a day. Consequently, such navigation is prohibited in all browsers except for
    Firefox. Firefox appears to permit it for some reason, but it changes the semantics
    in a sneaky way. When the origin of the caller and the navigation target do not
    match, it executes the *javascript:* payload in a special null origin, which lacks
    its own DOM or any of the browser-supplied I/O functions registered (thus permitting
    only purely algorithmic operations to occur).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种行为，显然允许一个文档将任何非同源上下文导航到 *javascript:* URL 是非常不安全的，因为它将能够绕过所有其他内容隔离机制：只需在框架中加载
    [fuzzybunnies.com](http://fuzzybunnies.com)，然后导航该框架到 *javascript:do_evil_stuff()*
    并结束。因此，除了 Firefox 之外的所有浏览器都禁止此类导航。Firefox 似乎出于某种原因允许这样做，但它以巧妙的方式改变了语义。当调用者和导航目标的来源不匹配时，它会在一个特殊的空来源中执行
    *javascript:* 有效负载，该来源没有自己的 DOM 或任何浏览器提供的已注册的 I/O 函数（因此只允许执行纯算法操作）。
- en: 'The cross-origin case is dangerous, but its same-origin equivalent is not:
    Within a single origin, any content is free to navigate itself or its peers to
    *javascript:* URLs on its own volition. In this case, the *javascript:* scheme
    is honored when following links, submitting forms, calling *location.assign(...)*,
    and so on. In WebKit and Opera, *Refresh* redirection to *javascript:* will work
    as well; other browsers reject such navigation due to vague and probably misplaced
    script-injection concerns.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 跨源情况是危险的，但它的同源等效物并不危险：在单个来源内，任何内容都可以自由地导航自身或其同辈到其自身的 *javascript:* URL。在这种情况下，当跟随链接、提交表单、调用
    *location.assign(...)* 等时，会尊重 *javascript:* 方案。在 WebKit 和 Opera 中，*Refresh* 重定向到
    *javascript:* 也会正常工作；其他浏览器由于模糊且可能位置不当的脚本注入担忧而拒绝此类导航。
- en: The handling of scripting URLs is outlined in [Table 10-3](ch10s03.html#origin_inheritance_for_data_colon
    "Table 10-3. Origin Inheritance for Scripting URLs").
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本 URL 的处理在 [表 10-3](ch10s03.html#origin_inheritance_for_data_colon "表 10-3.
    脚本 URL 的来源继承") 中概述。
- en: Table 10-3. Origin Inheritance for Scripting URLs
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-3. 脚本 URL 的来源继承
- en: '|   | Type of navigation |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|   | 导航类型 |'
- en: '| --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | |'
- en: '| New page | Existing same-origin page | Existing non-same-origin page | *Location*
    redirect | *Refresh* redirect | URL entry or gesture |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 新页面 | 存在的同源页面 | 存在的非同源页面 | *Location* 重定向 | *Refresh* 重定向 | URL 输入或手势 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Internet Explorer** | Inherited from caller | Inherited from navigated
    page | (Denied) | (Denied) | (Denied) | Inherited from navigated page |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **Internet Explorer** | 从调用者继承 | 从导航页面继承 | (拒绝) | (拒绝) | (拒绝) | 从导航页面继承 |'
- en: '| **Firefox** | Null context | (Denied) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **Firefox** | 无上下文 | (拒绝) |'
- en: '| **All WebKit** | (Denied) | Inherited from navigated page |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **所有 WebKit** | (拒绝) | 从导航页面继承 |'
- en: '| **Opera** | (Denied) | Inherited from navigated page |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **歌剧** | (拒绝) | 从导航页面继承 |'
- en: 'On top of these fascinating semantics, there is a yet another twist unique
    to the *javascript:* scheme: In some cases, the handling of such script-containing
    URLs involves a second step. Specifically, if the supplied code evaluates properly,
    and the value of the last statement is nonvoid and can be converted to a string,
    this string will be interpreted as an HTML document and will replace the navigated
    page (inheriting origin from the caller). The logic governing this curious behavior
    is very similar to that influencing the behavior of *data:* URLs. An example of
    such a document-replacing expression is this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些迷人的语义之上，还有另一个独特的转折，这是 *javascript:* 方案的独有特点：在某些情况下，处理包含脚本的 URL 涉及一个额外的步骤。具体来说，如果提供的代码正确评估，并且最后一个语句的值非空且可以转换为字符串，则该字符串将被解释为
    HTML 文档，并将替换导航的页面（从调用者继承来源）。支配这种奇特行为的逻辑与影响 *data:* URL 行为的逻辑非常相似。这样一个文档替换表达式的例子如下：
- en: '[PRE19]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A Note on Restricted Pseudo-URLs
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于受限伪 URL 的说明
- en: The somewhat quirky behavior of the three aforementioned classes of URLs—*about:blank*,
    *javascript:*, and *data:*—are all that most websites need to be concerned with.
    Nevertheless, browsers use a range of other documents with no inherent, clearly
    defined origin (e.g., *about:config* in Firefox, a privileged JavaScript page
    that can be used to tweak the browser’s various under-the-hood settings, or *chrome://downloads*
    in Chrome, which lists the recently downloaded documents with links to open any
    of them). These documents are a continued source of security problems, even if
    they are not reachable directly from the Internet.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上述三种URL类别的有些古怪的行为——*about:blank*、*javascript:* 和 *data:*——是大多数网站需要关注的。尽管如此，浏览器使用了一系列其他文档，这些文档没有固有的、明确定义的源（例如，Firefox中的
    *about:config*，这是一个特权JavaScript页面，可以用来调整浏览器的各种底层设置，或者Chrome中的 *chrome://downloads*，它列出了最近下载的文档，并提供链接以打开其中任何一个）。这些文档是持续的安全问题来源，即使它们不能直接从互联网访问。
- en: Because of the incompatibility of these URLs with the boundaries controlled
    by the same-origin policy, special care must be taken to make sure that these
    URLs are sufficiently isolated from other content whenever they are loaded in
    the browser as a result of user action or some other indirect browser-level process.
    An interesting case illustrating the risk is a 2010 bug in the way Firefox handled
    *about:neterror*.^([[197](pr03.html#ftn.CHP-10-FT-2)]) Whenever Firefox can’t
    correctly retrieve a document from a remote server (a condition that is usually
    easy to trigger with a carefully crafted link), it puts the destination URL in
    the address bar but loads *about:neterror* in place of the document body. Unfortunately,
    due to a minor oversight, this special error page would be same-origin with any
    *about:blank* document opened by any Internet-originating content, thereby permitting
    the attacker to inject arbitrary content into the *about:neterror* window while
    preserving the displayed destination URL.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些URL与同源策略控制的边界不兼容，因此必须特别小心，确保在浏览器中由于用户操作或其他间接浏览器级过程加载这些URL时，它们与其他内容足够隔离。一个说明风险的有趣案例是2010年Firefox处理*about:neterror*的方式中的错误。^([[197](pr03.html#ftn.CHP-10-FT-2)])
    当Firefox无法从远程服务器正确检索文档（这种情况通常可以通过精心制作的链接轻松触发）时，它会将目标URL放入地址栏，但用*about:neterror*代替文档主体。不幸的是，由于一个小的疏忽，这个特殊的错误页面会与任何由互联网源打开的*about:blank*文档具有相同的源，从而允许攻击者向*about:neterror*窗口注入任意内容，同时保留显示的目标URL。
- en: The moral of this story? Avoid the urge to gamble with the same-origin policy;
    instead, play along with it. Note that making *about:neterror* a hierarchical
    URL, instead of trying to keep track of synthetic origins, would have prevented
    the bug.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的意义是什么？避免使用同源策略进行赌博的冲动；相反，与之合作。请注意，将 *about:neterror* 设置为分层URL，而不是试图跟踪合成源，本可以防止这个错误。
- en: Security Engineering Cheat Sheet
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: Because of their incompatibility with the same-origin policy, *data:*, *javascript:*,
    and implicit or explicit *about:blank* URLs should be used with care. When performance
    is not critical, it is preferable to seed new frames and windows by pointing them
    to a server-supplied blank document with a definite origin first.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们与同源策略的不兼容性，*data:*、*javascript:* 和隐式或显式的*about:blank* URL应谨慎使用。当性能不是关键时，最好通过将新框架和窗口指向由服务器提供的具有明确源的空白文档来初始化它们。
- en: Keep in mind that *data:* and *javascript:* URLs are not a drop-in replacement
    for *about:blank*, and they should be used only when absolutely necessary. In
    particular, it is currently unsafe to assume that *data:* windows can’t be accessed
    across domains.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，*data:* 和 *javascript:* URL不是*about:blank*的直接替代品，并且只有在绝对必要时才应使用它们。特别是，目前假设*data:*窗口不能跨域访问是不安全的。
- en: Chapter 11. Life Outside Same-Origin Rules
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。同源规则之外的生活
- en: The same-origin policy is the most important mechanism we have to keep hostile
    web applications at bay, but it’s also an imperfect one. Although it is meant
    to offer a robust degree of separation between any two different and clearly identifiable
    content sources, it often fails at this task.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略是我们用来阻止敌对Web应用程序的最重要机制，但它并不完美。尽管它的目的是在任意两个不同且可明确识别的内容源之间提供强大的隔离度，但它往往在这个任务上失败。
- en: To understand this disconnect, recall that contrary to what common sense may
    imply, the same-origin policy was never meant to be all-inclusive. Its initial
    focus, the DOM hierarchy (that is, just the *document* object exposed to JavaScript
    code) left many of the peripheral JavaScript features completely exposed to cross-domain
    manipulation, necessitating ad hoc fixes. For example, a few years after the inception
    of SOP, vendors realized that allowing third-party documents to tweak the *location.host*
    property of an unrelated window is a bad idea and that such an operation could
    send potentially sensitive data present in other URL segments to an attacker-specified
    site. The policy has subsequently been extended to at least partly protect this
    and a couple of other sensitive objects, but in some less clear-cut cases, awkward
    loopholes remain.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种脱节，请记住，与常识可能暗示的相反，同源策略从未旨在包罗万象。它的初始重点是DOM层次结构（即仅暴露给JavaScript代码的*document*对象），这使许多外围JavaScript功能完全暴露于跨域操作，需要临时解决方案。例如，在SOP（Same-Origin
    Policy）实施几年后，供应商意识到允许第三方文档调整与无关窗口的*location.host*属性是一个糟糕的想法，并且这种操作可能会将其他URL段中可能敏感的数据发送到攻击者指定的网站。该策略随后被扩展到至少部分保护这一点和其他几个敏感对象，但在一些不太明确的情况下，仍然存在尴尬的漏洞。
- en: The other problem is that many cross-domain interactions happen completely outside
    of JavaScript and its object hierarchy. Actions such as loading third-party images
    or stylesheets are deeply rooted in the design of HTML and do not depend on scripting
    in any meaningful way. (In principle, it would be possible to retrofit them with
    origin-based security controls, but doing so would interfere with existing websites.
    Plus, some think that such a decision would go against the design principles that
    made the Web what it is; they believe that the ability to freely cross-reference
    content should not be infringed upon.)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题在于，许多跨域交互完全发生在JavaScript及其对象层次结构之外。例如加载第三方图像或样式表这样的操作深深植根于HTML的设计中，并且不依赖于任何有意义的脚本。原则上，可以通过基于源的安全控制来改造它们，但这样做会干扰现有的网站。此外，有些人认为这样的决定会违反使Web成为今天的Web的设计原则；他们认为自由交叉引用内容的能力不应受到侵犯。）
- en: In light of this, it seems prudent to explore the boundaries of the same-origin
    policy and learn about the rich life that web applications can lead outside its
    confines. We begin with document navigation—a mechanism that at first seems strikingly
    simple but that is really anything but.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，探索同源策略的边界并了解网络应用在其范围之外可以拥有的丰富生活似乎是谨慎的。我们从文档导航开始——这个机制一开始看起来非常简单，但实际上却远非如此。
- en: Window and Frame Interactions
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口和框架交互
- en: On the Web, the ability to steer the browser from one website to another is
    taken for granted. Some of the common methods of achieving such navigation are
    discussed throughout [Part I](pt01.html "Part I. Anatomy of the Web") of this
    book; the most notable of these are HTML links, forms, and frames; HTTP redirects;
    and JavaScript *window.open(...)* and *location.** calls.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上，从一个网站导航到另一个网站的能力被视为理所当然。本书第一部分[Part I](pt01.html "Part I. Anatomy of the
    Web")中讨论了实现这种导航的一些常见方法；其中最显著的是HTML链接、表单和框架；HTTP重定向；以及JavaScript的*window.open(...)*和*location.*调用。
- en: Actions such as pointing a newly opened window to an off-domain URL or specifying
    the *src* parameter of a frame are intuitive and require no further review. But
    when we look at the ability of one page to navigate another, existing document—well,
    the reign of intuition comes to a sudden end.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 指向新打开的窗口的域外URL或指定框架的*src*参数这样的操作直观且无需进一步审查。但当我们看到一页导航到另一页、现有文档的能力时——嗯，直觉的统治突然结束。
- en: Changing the Location of Existing Documents
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变现有文档的位置
- en: 'In the simple days before the advent of HTML frames, only one document could
    occupy a given browser window, and only that single window would be under the
    document’s control. Frames changed this paradigm, however, permitting several
    different and completely separate documents to be spliced into a single logical
    view, coexisting within a common region of the screen. The introduction of the
    mechanism also necessitated another step: To sanely implement certain frame-based
    websites, any of the component documents displayed in a window needed the ability
    to navigate its neighboring frames or perhaps the top-level document itself. (For
    example, imagine a two-frame page with a table of contents on the left and the
    actual chapter on the right. Clicking a chapter name in the left pane should navigate
    the chapter in the right pane, and nothing else.)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML框架出现之前的简单日子里，只有一个文档可以占据一个特定的浏览器窗口，并且只有那个单一的窗口处于文档的控制之下。然而，框架改变了这种模式，允许几个不同且完全独立的文档被拼接成一个单一的逻辑视图，共存于屏幕的公共区域。引入这种机制也
    necessitated另一个步骤：为了合理地实现某些基于框架的网站，窗口中显示的任何组件文档都需要能够导航其相邻的框架或甚至顶级文档本身。（例如，想象一个有两个框架的页面，左侧是目录，右侧是实际的章节。在左侧面板中点击章节名称应该导航右侧面板中的章节，而不会导航其他任何内容。）
- en: 'The mechanism devised for this last purpose is fairly simple: One can specify
    the *target* parameter on *<a href=...>* links or forms, or provide the name of
    a window to the JavaScript method known as *window.open(...)*, in order to navigate
    any other, previously named document view. In the mid-1990s, when this functionality
    first debuted, there seemed to be no need to incorporate any particular security
    checks into this logic; any page could navigate any other named window or a frame
    displayed by the browser to a new location at will.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为此目的设计的机制相当简单：可以在*<a href=...>*链接或表单上指定*target*参数，或者将窗口的名称提供给名为*window.open(...)*的JavaScript方法，以导航任何其他先前命名的文档视图。在20世纪90年代中期，当这种功能首次推出时，似乎没有必要将任何特定的安全检查纳入这种逻辑；任何页面都可以随意将任何其他命名的窗口或浏览器显示的框架导航到新位置。
- en: 'To understand the consequences of this design, it is important to pause for
    a moment and examine the circumstances under which a particular document may obtain
    a name to begin with. For frames, the story is simple: In order to reference a
    frame easily on the embedding page, virtually all frames have a *name* attribute
    (and some browsers, such as Chrome, also look at *id*). Browser windows, on the
    other hand, are typically anonymous (that is, their *window.name* property is
    an empty string), unless created programmatically; in the latter case, the name
    is specified by whoever creates the view. Anonymous windows do not necessarily
    stay anonymous, however. If a rogue application is displayed in such a window
    even briefly, it may set the *window.name* property to any value, and this effect
    will persist.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种设计的后果，重要的是暂停一下，并检查特定文档最初可能获得名字的情况。对于框架来说，故事很简单：为了在嵌入页面上轻松引用框架，几乎所有框架都有一个*name*属性（并且一些浏览器，如Chrome，还会查看*id*）。另一方面，浏览器窗口通常是匿名的（即，它们的*window.name*属性是一个空字符串），除非是程序创建的；在后一种情况下，名字由创建视图的人指定。然而，匿名窗口并不一定保持匿名。如果恶意应用程序在这样一个窗口中甚至只是短暂地显示，它也可能将*window.name*属性设置为任何值，并且这种效果将持续存在。
- en: The aforementioned ability to target windows and frames by name is not the only
    way to navigate them; JavaScript programs that hold window handles pointing to
    other documents may directly invoke certain DOM methods without knowing the name
    of their target at all. Attacker-supplied code will not normally hold handles
    to completely unrelated windows, but it can traverse properties such as *opener*,
    *top*, *parent*, or *frames[]* in order to locate even distant relatives within
    the same navigation flow. An example of such a far-reaching lookup (and subsequently,
    navigation) is
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称定位窗口和框架的能力并不是导航它们的唯一方式；持有指向其他文档的窗口句柄的JavaScript程序可以直接调用某些DOM方法，而无需知道它们目标的名字。攻击者提供的代码通常不会持有与完全无关的窗口的句柄，但它可以遍历诸如*opener*、*top*、*parent*或*frames[]*等属性，以便在相同的导航流程中定位到远亲。这种远距离查找（以及随后的导航）的一个例子是
- en: '[PRE20]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These two lookup techniques are not mutually exclusive: JavaScript programs
    can first obtain the handle of an unrelated but named window through *window.open(...)*
    and then traverse the *opener* or *frames[]* properties of that context in order
    to reach its interesting relatives nearby.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种查找技术并不相互排斥：JavaScript程序可以通过*window.open(...)*首先获取一个无关但命名的窗口的句柄，然后通过该上下文的*opener*或*frames[]*属性遍历，以便到达其附近的有趣相关元素。
- en: Once a suitable handle is looked up in any fashion, the originating context
    can leverage one of several DOM methods and properties in order to change the
    address of the document displayed in that view. In every contemporary browser,
    calling the *<handle>.location.replace(...)* method, or assigning a value to *<handle>.location*
    or *<handle>.location.href* properties, should do the trick. Amusingly, due to
    random implementation quirks, other theoretically equivalent approaches (such
    as invoking *<handle>.location.assign(...)* or *<handle>.window.open(..., "_self")*)
    may be hit-and-miss.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦以任何方式查找到合适的句柄，原始上下文就可以利用几个DOM方法和属性来更改在该视图中显示的文档地址。在每一个现代浏览器中，调用*<handle>.location.replace(...)*方法，或者将值赋给*<handle>.location*或*<handle>.location.href*属性，应该可以达到目的。有趣的是，由于随机实现的怪癖，其他理论上等效的方法（例如调用*<handle>.location.assign(...)*或*<handle>.window.open(...,
    "_self")*)可能会时灵时不灵。
- en: Okay, so it may be possible to navigate unrelated documents to new locations—but
    let’s see what could possibly go wrong.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以可能可以将无关的文档导航到新的位置——但让我们看看可能会出什么问题。
- en: Frame Hijacking Risks
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架劫持风险
- en: The ability for one domain to navigate windows created by other sites, or ones
    that are simply no longer same-origin with their creator, is usually not a grave
    concern. This laid-back design may be an annoyance and may pose some minor, speculative
    phishing risk,^([[56](#ftn.CHP-11-FN-1)]) but in the grand scheme of things, it
    is neither a very pronounced issue nor a particularly distinctive one. This is,
    perhaps, the reason why the original authors of the relevant APIs have not given
    the entire mechanism too much thought.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个域能够导航由其他网站创建的窗口，或者那些不再与创建者同源的窗口，通常并不是一个严重的问题。这种轻松的设计可能令人烦恼，并可能带来一些轻微的、推测性的钓鱼风险^([[56](#ftn.CHP-11-FN-1)]),但在大局中，这既不是一个非常突出的问题，也不是一个特别独特的问题。这可能是相关API的原始作者没有过多考虑整个机制的原因。
- en: 'Alas, the concept of HTML frames alters the picture profoundly: Any application
    that relies on frames to build a trusted user interface is at an obvious risk
    if an unrelated site is permitted to hijack such UI elements without leaving any
    trace of the attack in the address bar! [Figure 11-1](ch11.html#a_historically_permitted_comma_dangerous
    "Figure 11-1. A historically permitted, dangerous frame navigation scenario: The
    window on the right is opened at the same time as a banking website and is actively
    subverting it.") shows one such plausible attack scenario.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，HTML框架的概念极大地改变了这一局面：任何依赖于框架来构建可信用户界面的应用程序，如果允许无关的网站劫持这样的UI元素而不在地址栏留下任何攻击痕迹，那么它就处于明显的风险之中！[图11-1](ch11.html#a_historically_permitted_comma_dangerous
    "图11-1. 历史上允许的、危险的框架导航场景：右侧窗口与银行网站同时打开，并积极篡改它。")展示了这样一个可能的攻击场景。
- en: '![A historically permitted, dangerous frame navigation scenario: The window
    on the right is opened at the same time as a banking website and is actively subverting
    it.](httpatomoreillycomsourcenostarchimages950023.png.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![历史上允许的、危险的框架导航场景：右侧窗口与银行网站同时打开，并积极篡改它。](httpatomoreillycomsourcenostarchimages950023.png.jpg)'
- en: 'Figure 11-1. A historically permitted, dangerous frame navigation scenario:
    The window on the right is opened at the same time as a banking website and is
    actively subverting it.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1. 历史上允许的、危险的框架导航场景：右侧窗口与银行网站同时打开，并积极篡改它。
- en: Georgi Guninski, one of the pioneering browser security researchers, realized
    as early as 1999 that by permitting unconstrained frame navigation, we were headed
    for some serious trouble. Following his reports, vendors attempted to roll out
    frame navigation restrictions mid-2000.^([[198](pr03.html#ftn.CHP-11-FT-1)]) Their
    implementation constrained all cross-frame navigation to the scope of a single
    window, preventing malicious web pages from interfering with any other simultaneously
    opened browser sessions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治·古尼斯基（Georgi Guninski），一位先驱浏览器安全研究人员，早在1999年就意识到，通过允许无限制的框架导航，我们正走向一些严重的麻烦。在他的报告之后，供应商试图在2000年中期推出框架导航限制。[198](pr03.html#ftn.CHP-11-FT-1)]他们的实现将所有跨框架导航限制在单个窗口的范围内，防止恶意网页干扰任何其他同时打开的浏览器会话。
- en: Surprisingly, even this simple policy proved difficult to implement correctly.
    It was only in 2008 that Firefox eliminated this class of problems,^([[199](pr03.html#ftn.CHP-11-FT-2)])
    while Microsoft essentially ignored the problem until 2006\. Still, these setbacks
    aside, we should be fine—right?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，即使这项简单的政策也难以正确实施。直到2008年，Firefox才消除了这类问题，[199](pr03.html#ftn.CHP-11-FT-2)]而微软直到2006年才基本忽略这个问题。尽管如此，抛开这些挫折，我们应该没问题——对吧？
- en: Frame Descendant Policy and Cross-Domain Communications
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架后代策略和跨域通信
- en: The simple security restriction discussed in the previous session was not, in
    fact, enough. The reason was a new class of web applications, sometimes known
    as *mashups*, that combined data from various sources to enable users to personalize
    their working environment and process data in innovative ways. Unfortunately for
    browser vendors, such web applications frequently relied on third-party gadgets
    loaded through *<iframe>* tags, and their developers could not reasonably expect
    that loading a single frame from a rogue source would put all other frames on
    the page at risk. Yet, the simple and elegant window-level navigation policy amounted
    to permitting exactly that.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中讨论的简单安全限制实际上并不足够。原因是出现了一类新的Web应用程序，有时被称为*mashups*，它们结合了来自各种来源的数据，使用户能够个性化他们的工作环境并以创新的方式处理数据。不幸的是，对于浏览器供应商来说，这类Web应用程序通常依赖于通过*<iframe>*标签加载的第三方小工具，而它们的开发者无法合理地期望从恶意源加载单个框架会危及页面上所有其他框架。然而，简单而优雅的窗口级导航策略恰恰允许这样做。
- en: Around 2006, Microsoft agreed that the current approach was not sustainable
    and developed a more secure *descendant policy* for frame navigation in Internet
    Explorer 7\. Under this policy, navigation of non-same-origin frames is permitted
    only if the party requesting the navigation shares the origin with one of the
    ancestors of the targeted view. [Figure 11-2](ch11.html#a_complex_but_permissible_navigation_bet
    "Figure 11-2. A complex but permissible navigation between non-same-origin frames.
    This attempt succeeds only because the originating frame has the same origin as
    one of the ancestors of the targeted document—here, it’s the top-level page itself.")
    shows the navigation scenario permitted by this new policy.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2006年，微软同意当前的方法不可持续，并在Internet Explorer 7中开发了一种更安全的*后代策略*用于框架导航。根据这项政策，只有在请求导航的方与目标视图的祖先之一共享源时，才允许非同源框架的导航。[图11-2](ch11.html#a_complex_but_permissible_navigation_bet
    "图11-2. 在非同源框架之间进行复杂但允许的导航。这次尝试之所以成功，仅仅是因为发起框架与目标文档的一个祖先具有相同的源——在这里，就是顶级页面本身。")展示了这项新政策允许的导航场景。
- en: '![A complex but permissible navigation between non-same-origin frames. This
    attempt succeeds only because the originating frame has the same origin as one
    of the ancestors of the targeted document—here, it’s the top-level page itself.](httpatomoreillycomsourcenostarchimages950025.png.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![在非同源框架之间进行复杂但允许的导航。这次尝试之所以成功，仅仅是因为发起框架与目标文档的一个祖先具有相同的源——在这里，就是顶级页面本身。](httpatomoreillycomsourcenostarchimages950025.png.jpg)'
- en: Figure 11-2. [A complex but permissible navigation between non-same-origin frames.
    This attempt succeeds only because the originating frame has the same origin as
    one of the ancestors of the targeted document—here, it’s the top-level page itself.](http://www.robotroom.com/DebouncedCounter/Figure713.gif)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2. [在非同源框架之间进行复杂但允许的导航。这次尝试之所以成功，仅仅是因为发起框架与目标文档的一个祖先具有相同的源——在这里，就是顶级页面本身。](http://www.robotroom.com/DebouncedCounter/Figure713.gif)
- en: '[](http://www.fuzzybunnies.com/)[As with many other security improvements,
    Microsoft never backported this policy to the still popular Internet Explorer
    6, and it never convincingly pressured users to abandon the older and increasingly
    insecure (but still superficially supported) version of its browser. On a more
    positive note, by 2009, three security researchers (Adam Barth, Collin Jackson,
    and John C. Mitchell) convinced Mozilla, Opera, and WebKit to roll out a similar
    policy in their browsers,^[](http://www.bunnyoutlet.com/)[200](pr03.html#ftn.CHP-11-FT-3)]
    finally closing the mashup loophole for a good majority of the users of the Internet.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[](http://www.fuzzybunnies.com/)[与其他许多安全改进一样，微软从未将此策略回滚到仍然流行的Internet Explorer
    6，也从未有说服力地敦促用户放弃其浏览器中越来越不安全（但表面上仍得到支持）的旧版本。更积极的一面是，到2009年，三位安全研究人员（Adam Barth、Collin
    Jackson和John C. Mitchell）说服Mozilla、Opera和WebKit在其浏览器中实施类似的政策，^[](http://www.bunnyoutlet.com/)[200](pr03.html#ftn.CHP-11-FT-3)]最终为大多数互联网用户关闭了mashup漏洞。'
- en: 'Well, *almost* closing it. Even the new, robust policy has a subtle flaw. Notice
    in [Figure 11-2](ch11.html#a_complex_but_permissible_navigation_bet "Figure 11-2. A
    complex but permissible navigation between non-same-origin frames. This attempt
    succeeds only because the originating frame has the same origin as one of the
    ancestors of the targeted document—here, it’s the top-level page itself.") that
    a rogue site, [http://bunnyoutlet.com/](http://bunnyoutlet.com/), can interfere
    with a private frame that [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    has created for its own use. At first glance, there is no harm here: The attacker’s
    domain is shown in the address bar, so the victim, in theory, should not be fooled
    into interacting with the subverted UI of [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    in any meaningful way. Sadly, there is a catch: Some web applications have learned
    to use frames not to create user interfaces but to relay programmatic messages
    between origins. For applications that need to support Internet Explorer 6 and
    7, where *postMessage(...)* is not available, the tricks similar to the approach
    shown in [Figure 11-3](ch11.html#a_potential_cross-domain_communication_s "Figure 11-3. A
    potential cross-domain communication scheme, where the top-level page encodes
    messages addressed to the embedded gadget in the fragment identifier of the gadget
    frame and the gadget responds by navigating a subframe that is same-origin with
    the top-level document. If this application is framed on a rogue site, the top-level
    document controlled by the attacker will be able to inject messages between the
    two parties by freely navigating send_to_parent and send_to_child.") are commonplace.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，*几乎*关闭了。即使是新的、稳健的政策也有一个细微的缺陷。注意在[图11-2](ch11.html#a_complex_but_permissible_navigation_bet
    "图11-2. 在非同源框架之间的一种复杂但允许的导航。这种尝试之所以成功，仅仅是因为发起框架与目标文档的一个祖先具有相同的源——这里，是顶级页面本身。")中，恶意网站[http://bunnyoutlet.com/](http://bunnyoutlet.com/)可以干扰[http://fuzzybunnies.com/](http://fuzzybunnies.com/)为其自身使用而创建的私有框架。乍一看，这里没有伤害：攻击者的域名显示在地址栏中，所以理论上受害者不应该被欺骗与[http://fuzzybunnies.com/](http://fuzzybunnies.com/)的篡改UI进行任何有意义的交互。遗憾的是，有一个陷阱：一些Web应用已经学会了使用框架不是为了创建用户界面，而是为了在源之间传递程序性消息。对于需要支持Internet
    Explorer 6和7的应用程序，其中*postMessage(...)*不可用，类似[图11-3](ch11.html#a_potential_cross-domain_communication_s
    "图11-3. 一种潜在的跨域通信方案，其中顶级页面在设备框架的片段标识符中编码发送给嵌入式小工具的消息，而小工具通过导航与顶级文档同源的子框架来响应。如果这个应用在恶意网站上被框架化，攻击者控制的顶级文档将能够通过自由导航send_to_parent和send_to_child在双方之间注入消息。")中展示的方法是常见的。
- en: '![A potential cross-domain communication scheme, where the top-level page encodes
    messages addressed to the embedded gadget in the fragment identifier of the gadget
    frame and the gadget responds by navigating a subframe that is same-origin with
    the top-level document. If this application is framed on a rogue site, the top-level
    document controlled by the attacker will be able to inject messages between the
    two parties by freely navigating send_to_parent and send_to_child.](httpatomoreillycomsourcenostarchimages950027.png.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![一个潜在的跨域通信方案，其中顶级页面在设备框架的片段标识符中编码发送给嵌入式小工具的消息，而小工具通过导航与顶级文档同源的子框架来响应。如果这个应用在恶意网站上被框架化，攻击者控制的顶级文档将能够通过自由导航send_to_parent和send_to_child在双方之间注入消息。](httpatomoreillycomsourcenostarchimages950027.png.jpg)'
- en: Figure 11-3. A potential cross-domain communication scheme, where the top-level
    page encodes messages addressed to the embedded gadget in the fragment identifier
    of the gadget frame and the gadget responds by navigating a subframe that is same-origin
    with the top-level document. If this application is framed on a rogue site, the
    top-level document controlled by the attacker will be able to inject messages
    between the two parties by freely navigating *send_to_parent* and *send_to_child*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-3. 一种潜在的跨域通信方案，其中顶级页面在嵌入的设备帧的片段标识符中编码发送给嵌入设备的消息，设备通过导航与顶级文档同源的子帧进行响应。如果此应用程序在恶意网站上被嵌入，攻击者控制的顶级文档将能够通过自由导航
    *send_to_parent* 和 *send_to_child* 在双方之间注入消息。
- en: 'If an application that relies on a similar hack is embedded by a rogue site,
    the integrity of the communication frames may be compromised, and the attacker
    will be able to inject messages into the stream. Even the uses of *postMessage(...)*
    may be at risk: If the party sending the message does not specify a destination
    origin or if the recipient does not examine the originating location, hijacking
    a frame will benefit the attacker in exactly the same way.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个依赖于类似黑客手段的应用程序被恶意网站嵌入，通信帧的完整性可能会受到损害，攻击者将能够向流中注入消息。甚至使用 *postMessage(...)*
    也可能存在风险：如果发送消息的一方没有指定目标源或接收方没有检查原始位置，劫持一个帧将以相同的方式使攻击者受益。
- en: Unsolicited Framing
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未经请求的帧嵌入
- en: 'The previous discussion of cross-frame navigation highlights one of the more
    interesting weaknesses in the browser security model, as well as the disconnect
    between the design goals of HTML and the aim of the same-origin policy. But that’s
    not all: The concept of cross-domain framing is, by itself, fairly risky. Why?
    Well, any malicious page may embed a third-party application without a user’s
    knowledge, let alone consent. Further, it may obfuscate this fact by overlaying
    other visual elements on top of the frame, leaving visible just a small chunk
    of the original site, such as a button that performs a state-changing action.
    In such a setting, any user logged into the targeted application with ambient
    credentials may be easily tricked into interacting with the disguised UI control
    and performing an undesirable and unintended action, such as changing sharing
    settings for a social network profile or deleting data.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 之前关于跨帧导航的讨论突出了浏览器安全模型中一个更有趣的弱点，以及 HTML 设计目标与同源策略目标之间的脱节。但不仅如此：跨域帧的概念本身就有相当大的风险。为什么？好吧，任何恶意页面都可能在不让用户知情甚至未经同意的情况下嵌入第三方应用程序。此外，它还可能通过在帧上叠加其他视觉元素来掩盖这一事实，只露出原始网站的一小部分，例如执行状态更改操作的按钮。在这种设置下，任何使用环境凭证登录目标应用程序的用户都可能很容易被诱骗与伪装的
    UI 控件交互，并执行不希望或不打算执行的操作，例如更改社交网络配置文件的分享设置或删除数据。
- en: 'This attack can be improved by the rogue site leveraging a CSS2 property called
    *opacity* to make the targeted frame completely invisible without affecting its
    actual behavior. Any click in the area occupied by such a see-through frame will
    be delivered to the UI controls contained therein (see [Figure 11-4](ch11.html#a_simplified_example_of_a_ui-splicing_at
    "Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity
    to hide the document the user will actually interact with")). Too, by combining
    CSS opacity with JavaScript code to make the frame follow the mouse pointer, it
    is possible to carry out the attack fairly reliably in almost any setting: Convincing
    the user to click anywhere in the document window is not particularly hard.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通过恶意网站利用 CSS2 中的 *opacity* 属性，可以使目标帧完全不可见，而不会影响其实际行为，从而改进这种攻击。在这种透明的帧占据的区域中的任何点击都将传递到其中包含的
    UI 控件（见 [图 11-4](ch11.html#a_simplified_example_of_a_ui-splicing_at "图 11-4. 使用
    CSS 透明度隐藏用户实际交互的文档的 UI 拼接攻击简化示例"））。同样，通过将 CSS 透明度与 JavaScript 代码结合，使帧跟随鼠标指针，几乎在任何设置中都可以相当可靠地执行攻击：说服用户在文档窗口的任何地方点击并不特别困难。
- en: '![A simplified example of a UI-splicing attack that uses CSS opacity to hide
    the document the user will actually interact with](httpatomoreillycomsourcenostarchimages950029.png.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CSS 透明度隐藏用户实际交互的文档的 UI 拼接攻击简化示例](httpatomoreillycomsourcenostarchimages950029.png.jpg)'
- en: Figure 11-4. A simplified example of a UI-splicing attack that uses CSS opacity
    to hide the document the user will actually interact with
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-4. 使用 CSS 透明度隐藏用户实际交互的文档的 UI 拼接攻击简化示例
- en: Researchers have recognized the possibility of such trickery to some extent
    since the early 2000s, but a sufficiently convincing attack wasn’t demonstrated
    until 2008, when Robert Hansen and Jeremiah Grossman publicized the issue broadly.^([[201](pr03.html#ftn.CHP-11-FT-4)])
    Thus, the term *clickjacking* was born.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 研究人员自2000年代初以来在一定程度上认识到了这种欺骗的可能性，但直到2008年，罗伯特·汉森和杰里米·格罗斯曼才广泛公开了这个问题，这才证明了有足够说服力的攻击。[^[[201](pr03.html#ftn.CHP-11-FT-4)])
    因此，“点击劫持”这个术语应运而生。
- en: 'The high profile of Hansen and Grossman’s report, and their interesting proof-of-concept
    example, piqued vendors’ interest. This interest proved to be short-lived, however,
    and there appears to be no easy way to solve this problem without taking some
    serious risks. The only even remotely plausible way to mitigate the impact would
    be to add renderer-level heuristics to disallow event delivery to cross-domain
    frames that are partly obstructed or that have not been displayed long enough.
    But this solution is complicated and hairy enough to be unpopular.^([[202](pr03.html#ftn.CHP-11-FT-5)])
    Instead, the problem has been slapped with a Band-Aid. A new HTTP header, *X-Frame-Options*,
    permits concerned sites to opt out of being framed altogether (*X-Frame-Options:
    deny*) or consent only to framing within a single origin (*X-Frame-Options: same-origin*).^([[203](pr03.html#ftn.CHP-11-FT-6)])
    This header is supported in all modern browsers (in Internet Explorer, beginning
    with version 8),^([[57](#ftn.CHP-11-FN-2)]) but it actually does little to address
    the vulnerability.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '汉森和格罗斯曼的报告备受关注，以及他们有趣的证明概念示例激起了供应商的兴趣。然而，这种兴趣很快就被证明是短暂的，而且似乎没有简单的方法可以解决这个问题而不承担重大风险。唯一可能稍微减轻影响的方法是添加渲染器级别的启发式规则，禁止将事件传递给部分遮挡或未显示足够长时间的跨域框架。但这个解决方案复杂且棘手，可能不受欢迎。[^[[202](pr03.html#ftn.CHP-11-FT-5)])
    相反，这个问题只是被贴上了临时补丁。一个新的HTTP头信息，*X-Frame-Options*，允许相关网站选择完全退出被框架嵌入（*X-Frame-Options:
    deny*）或仅同意在单个源中框架嵌入（*X-Frame-Options: same-origin*）。[^[[203](pr03.html#ftn.CHP-11-FT-6)])
    这个头信息在所有现代浏览器中都有支持（在Internet Explorer中，从版本8开始），[^[[57](#ftn.CHP-11-FN-2)]) 但实际上对解决漏洞帮助甚微。'
- en: Firstly, the opt-in nature of the defense means that most websites will not
    adopt it or will not adopt it soon enough; in fact, a 2011 survey of the top 10,000
    destinations on the Internet found that barely 0.5 percent used this feature.^([[204](pr03.html#ftn.CHP-11-FT-7)])
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，防御措施的自愿性质意味着大多数网站不会采用它，或者不会很快采用它；事实上，2011年对互联网上排名前10,000个目的地的调查发现，仅有不到0.5%使用了这个功能。[^[[204](pr03.html#ftn.CHP-11-FT-7)])
- en: To add insult to injury, the proposed mechanism is useless for applications
    that want to be embedded on third-party sites but that wish to preserve the integrity
    of their UIs. Various mashups and gadgets, those syndicated “like” buttons provided
    by social networking sites, and managed online discussion interfaces are all at
    risk.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人遗憾的是，所提出的机制对于希望嵌入第三方网站但希望保留其UI完整性的应用程序来说毫无用处。各种混合应用和设备，那些由社交网站提供的“喜欢”按钮，以及管理的在线讨论界面都面临着风险。
- en: Beyond the Threat of a Single Click
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不仅仅是单次点击的威胁
- en: As the name implies, the clickjacking attack outlined by Grossman and Hansen
    targets simple, single-click UI actions. In reality, however, the problem with
    deceptive framing is more complicated than the early reporting would imply. One
    example of a more complex interaction is the act of selecting, dragging, and dropping
    a snippet of text. In 2010, Paul Stone proposed a number of ways in which such
    an action could be disguised as a plausible interaction with an attacker’s site,^([[205](pr03.html#ftn.CHP-11-FT-8)])
    the most notable of which is the similarity between drag-and-drop and the use
    of a humble document-level scrollbar. The same click-drag-release action may be
    used to interact with a legitimate UI control or to unwittingly drag a portion
    of preselected text out of a sensitive document and drop it into an attacker-controlled
    frame. (Cross-domain drag-and-drop is no longer permitted in WebKit, but as of
    this writing other browser vendors are still debating the right way to address
    this risk.)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，Grossman和Hansen概述的点击劫持攻击针对的是简单的单次点击用户界面操作。然而，实际上，欺骗性框架的问题比早期报道的要复杂得多。一个更复杂的交互示例是选择、拖动和放置一段文本的行为。2010年，Paul
    Stone提出了一些方法，可以将此类行为伪装成与攻击者网站的合理交互，其中最值得注意的是拖放与谦逊的文档级滚动条的使用相似性。相同的点击-拖动-释放动作可以用来与合法的用户界面控件交互，或者无意中将预选文本的一部分从敏感文档中拖出并放入攻击者控制的框架中。（在WebKit中不再允许跨域拖放，但截至本文撰写时，其他浏览器供应商仍在争论如何正确应对这一风险。）
- en: An even more challenging problem is keystroke redirection. Sometime in 2010,
    I noticed that it was possible to selectively redirect keystrokes across domains
    by examining the code of a pressed key using the *onkeydown* event in JavaScript.
    If the pressed key matched what a rogue site wanted to enter into a targeted application,
    HTML element focus could be changed momentarily to a hidden *<iframe>*, thereby
    ensuring the delivery of the actual keystrokes to the targeted web application
    rather than the harmless text field the user seems to be interacting with.^([[206](pr03.html#ftn.CHP-11-FT-9)])
    Using this method, an attacker can synthesize arbitrarily complex text in another
    domain on the user’s behalf—for example, inviting the attacker as an administrator
    of the victim’s blog.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更具挑战性的问题是按键重定向。大约在2010年，我注意到可以通过使用JavaScript中的*onkeydown*事件检查按下的键的代码，有选择地在域之间重定向按键。如果按下的键与恶意网站想要输入的目标应用中的内容匹配，HTML元素焦点可以暂时切换到一个隐藏的*<iframe>*，从而确保实际按键被发送到目标Web应用，而不是用户似乎正在与之交互的无害文本字段。使用这种方法，攻击者可以代表用户在另一个域中合成任意复杂的文本——例如，邀请攻击者作为受害者博客的管理员。
- en: Browser vendors addressed the selective keystroke redirection issue by disallowing
    element focus changes in the middle of a keypress, but doing so did not close
    the loophole completely. After all, in some cases, an attacker can predict what
    key will be pressed next and roughly at what time, thereby permitting a preemptive,
    blindly executed focus switch. The two most obvious cases are a web-based action
    game or a typing-speed test, since both typically involve rapid pressing of attacker-influenced
    keys.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器供应商通过禁止在按键过程中更改元素焦点来解决选择性的按键重定向问题，但这样做并没有完全关闭漏洞。毕竟，在某些情况下，攻击者可以预测下一个将被按下的键以及大致的时间，从而允许进行先发制人的、盲目执行的重点切换。最明显的两个案例是基于网络的动作游戏或打字速度测试，因为两者通常都涉及攻击者影响的键的快速按下。
- en: 'In fact, it gets better: Even if a malicious application only relies on free-form
    text entry—for example, by offering the user a comment-submission form—it’s often
    possible to guess which character will be pressed next based on the previous few
    keystrokes alone. English text (and text in most other human languages) is highly
    redundant, and in many cases, a considerable amount of input can be predicted
    ahead of time: You can bet that *a-a-r-d-v* will be followed by *a-r-k*, and almost
    always you will be right.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，情况甚至更糟：即使一个恶意应用仅依赖于自由形式的文本输入——例如，通过向用户提供一个评论提交表单——通常也可以仅根据前几个按键来猜测下一个将被按下的字符。英语文本（以及大多数其他人类语言的文本）高度冗余，在许多情况下，可以提前预测相当数量的输入：你可以打赌*a-a-r-d-v*后面将跟随*a-r-k*，而且几乎总是正确的。
- en: '* * *'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[56](#CHP-11-FN-1)]) One potential attack is this: Open a legitimate website
    (say, [http://trusted-bank.com/](http://trusted-bank.com/)) in a new window, wait
    for the user to inspect the address bar, and then quickly change the location
    to an attacker-controlled but similarly named site (e.g., [http://trustea-bank.com/](http://trustea-bank.com/)).
    The likelihood of successfully phishing the victim may be higher than when the
    user is navigating to the bad URL right away.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[56](#CHP-11-FN-1)]) 一种潜在的攻击方式是：在一个新窗口中打开一个合法网站（比如，[http://trusted-bank.com/](http://trusted-bank.com/))，等待用户检查地址栏，然后迅速将位置更改为一个攻击者控制的但名称相似的网站（例如，[http://trustea-bank.com/](http://trustea-bank.com/))。成功钓鱼受害者的可能性可能高于用户直接导航到恶意
    URL 的情况。
- en: ^([[57](#CHP-11-FN-2)]) In older versions of Internet Explorer, web application
    developers sometimes resort to JavaScript in an attempt to determine whether the
    *window* object is the same as *parent*, a condition that should be satisfied
    if no higher-level frame is present. Unfortunately, due to the flexibility of
    JavaScript DOM, such checks, as well as many types of possible corrective actions,
    are notoriously unreliable.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[57](#CHP-11-FN-2)]) 在 Internet Explorer 的早期版本中，Web 应用程序开发人员有时会求助于 JavaScript，试图确定
    *window* 对象是否与 *parent* 相同，如果不存在更高层的框架，则应满足这一条件。遗憾的是，由于 JavaScript DOM 的灵活性，此类检查以及许多可能的纠正措施都臭名昭著地不可靠。
- en: Cross-Domain Content Inclusion
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域内容包含
- en: 'Framing and navigation are a distinct source of trouble, but these mechanisms
    aside, HTML supports a number of other ways to interact with non-same-origin data.
    The usual design pattern for these features is simple and seemingly safe: A constrained
    data format that will affect the appearance of the document is retrieved and parsed
    without being directly shown to the origin that referenced it. Examples of mechanisms
    that follow this rule include markup such as *<script src=...>*, *<link rel=stylesheet
    href=...>*, *<img src=...>*, and several related cases discussed throughout [Part I](pt01.html
    "Part I. Anatomy of the Web") of this book.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 框架和导航是一个独特的麻烦来源，但抛开这些机制，HTML 支持许多其他与不同源数据交互的方式。这些功能的常规设计模式简单且看似安全：检索并解析影响文档外观的约束数据格式，而无需直接展示给引用它的源。遵循此规则的机制示例包括如
    *<script src=...>*、*<link rel=stylesheet href=...>*、*<img src=...>* 以及本书 [第一部分](pt01.html
    "第一部分。网络解剖") 中讨论的几个相关案例。
- en: 'Regrettably, the devil is in the details. When these mechanisms were first
    proposed, nobody asked several extremely pressing questions:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，魔鬼藏在细节中。当这些机制最初被提出时，没有人提出几个极其紧迫的问题：
- en: Should these subresources be requested with ambient credentials associated with
    their origin? If so, there is a danger that the response may contain sensitive
    data not intended for the requesting party. It would probably be better to require
    some explicit form of authentication or to notify the server about the origin
    of the requesting page.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些子资源是否应该使用与它们的源相关联的环境凭据进行请求？如果是这样，那么响应中可能包含请求方不希望看到的敏感数据。可能更好的做法是要求某种明确的认证形式，或者通知服务器请求页面的来源。
- en: Should the relevant parsers be designed to minimize the risk of mistaking one
    document type for another? And should the servers have control over how their
    responses are interpreted (for example through the *Content-Type* header)? If
    not, what are the consequences of, say, interpreting a user’s private JPEG image
    as a script?
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关解析器是否应该设计成最小化误将一种文档类型误认为另一种文档类型的风险？服务器是否应该控制其响应的解析方式（例如通过 *Content-Type* 标头）？如果不是，将用户的私人
    JPEG 图像解释为脚本会有什么后果？
- en: Should the requesting page have no way to infer anything about the contents
    of the retrieved payloads? If yes, then this goal needs to be taken into account
    with utmost care when designing all the associated APIs. (If such separation is
    not a goal, the importance of the previous questions is even more pronounced.)
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求页面是否应该没有推断检索到的有效负载内容的方式？如果是的话，那么在设计所有相关 API 时，需要极其小心地考虑这一目标。（如果这种分离不是目标，那么前述问题的意义就更加明显。）
- en: 'The developers acted with conflicting assumptions about these topics, or perhaps
    had not given them any thought at all, leading to a number of profound security
    risks. For example, in most browsers, it used to be possible to read arbitrary,
    cookie-authenticated text by registering an *onerror* handler on cross-domain
    *<script>* loads: The verbose “syntax error” message generated by the browser
    would include a snippet of the retrieved file. Still, no problem in this category
    is more interesting than a glitch discovered by Chris Evans in 2009.^([[207](pr03.html#ftn.CHP-11-FT-10)])
    He noticed that the hallmark fault tolerance of CSS parsers (which, as you may
    recall, recover from syntax errors by attempting to resynchronize at the nearest
    curly bracket) is also a fatal security flaw.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在这些主题上存在相互冲突的假设，或者可能根本没有考虑过这些问题，导致了一系列深刻的网络安全风险。例如，在大多数浏览器中，过去可以通过在跨域 *<script>*
    加载上注册 *onerror* 处理器来读取任意、通过 Cookie 认证的文本：浏览器生成的冗长的“语法错误”消息将包括检索到的文件的一部分。然而，在这个类别中，没有比克里斯·埃文斯在
    2009 年发现的故障更有趣的了.^([[207](pr03.html#ftn.CHP-11-FT-10)]) 他注意到 CSS 解析器的标志性容错能力（如您所知，通过尝试在最近的括号处重新同步来从语法错误中恢复）也是一个致命的安全漏洞。
- en: 'In order to understand the issue, consider the following simple HTML document.
    This document contains two occurrences of an attacker-controlled string, and—sandwiched
    in between—a sensitive, user-specific value (in this case, a user’s name):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个问题，考虑以下简单的 HTML 文档。该文档包含两个攻击者控制的字符串，并且——在两者之间——是一个敏感的、特定于用户的值（在这种情况下，是用户的名字）：
- en: '[PRE21]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s assume that the attacker lured the victim to his own page and, on this
    page, used *<link rel=stylesheet>* to load the aforementioned cross-domain HTML
    document in place of a stylesheet. The victim’s browser will happily comply: It
    will request the document using the victim’s cookies, will ignore *Content-Type*
    on the subsequent response, and will hand the retrieved content over to the CSS
    parser. The parser will cheerfully ignore all syntax errors leading up to what
    appears to be a CSS rule named *gotcha*. It will then process the *url(''...*
    pseudo-function, consuming all subsequent HTML (including the secret user name!),
    until it reaches a matching quote and a closing parenthesis. When this faux stylesheet
    is later applied to a *class=gotcha* element on the attacker’s website, the browser
    will attempt to load the resulting URL and will leak the secret value to the attacker’s
    server in the process.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者诱骗受害者访问其自己的页面，并在该页面上使用 *<link rel=stylesheet>* 来加载上述跨域 HTML 文档，而不是样式表。受害者的浏览器会欣然同意：它会使用受害者的
    Cookie 请求该文档，会忽略后续响应中的 *Content-Type*，并将检索到的内容交给 CSS 解析器。解析器会愉快地忽略所有导致看似名为 *gotcha*
    的 CSS 规则之前的语法错误。然后，它将处理 *url('...* 伪函数，消耗所有后续的 HTML（包括秘密的用户名！），直到遇到匹配的引号和闭合括号。当这个假样式表后来应用于攻击者网站上的
    *class=gotcha* 元素时，浏览器将尝试加载生成的 URL，并在过程中向攻击者的服务器泄露秘密值。
- en: 'Astute readers may note that the CSS standard does not support multiline string
    literals, and as such, this trick would not work as specified. That’s partly true:
    In most browsers, the attempt will succeed only if the critical segment of the
    page contains no stray newlines. Some web applications are optimized to avoid
    unnecessary whitespaces and therefore will be vulnerable, but most web developers
    use newlines liberally, thwarting the attack. Alas, as noted in [Chapter 5](ch05.html
    "Chapter 5. Cascading Style Sheets"), one browser behaves differently: Internet
    Explorer accepts multiline strings in stylesheets and many other egregious syntax
    violations, accidentally amplifying the impact of this flaw.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能会注意到 CSS 标准不支持多行字符串字面量，因此这个技巧不会按指定的方式工作。这部分是正确的：在大多数浏览器中，只有当页面的关键部分不包含多余的换行符时，尝试才会成功。一些
    Web 应用程序被优化以避免不必要的空白，因此它们会受到影响，但大多数 Web 开发者会自由地使用换行符，从而挫败攻击。遗憾的是，正如在第 5 章[第 5
    章。层叠样式表](ch05.html "第 5 章。层叠样式表")中所述，有一个浏览器表现不同：Internet Explorer 接受样式表中的多行字符串和许多其他严重的语法违规，意外地放大了这个漏洞的影响。
- en: Note
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since identifying this problem, Chris Evans has pushed for fixes in all mainstream
    browsers, and as of this writing, most implementations reject cross-domain stylesheets
    that don’t begin right away with a valid CSS rule or that are served with an incompatible
    *Content-Type* header (same-origin stylesheets are treated less restrictively).
    The only vendor to resist was Microsoft, which changed its mind only after a demonstration
    of a successful proof-of-concept attack against Twitter.^([[208](pr03.html#ftn.CHP-11-FT-11)])
    Following this revelation, Microsoft agreed not only to address the problem in
    Internet Explorer 8 but also—uncharacteristically—to backport this particular
    fix to Internet Explorer 6 and 7 as well.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 自从发现这个问题以来，Chris Evans一直在主流浏览器中推动修复，截至本文撰写时，大多数实现都拒绝接受那些不以有效CSS规则开始或带有不兼容的*Content-Type*头部的跨域样式表（同源样式表受到较少的限制）。唯一抵制这一做法的是微软，它在演示了对Twitter成功的概念验证攻击之后才改变主意。[^([[208](pr03.html#ftn.CHP-11-FT-11)])
    随着这一揭示，微软不仅同意在Internet Explorer 8中解决这个问题，而且——不寻常的是——还将这个特定的修复回滚到Internet Explorer
    6和7中。
- en: 'Thanks to Chris’s efforts, stylesheets are a solved problem, but similar problems
    are bound to recur for other types of cross-domain subresources. In such cases,
    not all transgressions can be blamed on the sins of the old. For example, when
    browser vendors rolled out *<canvas>*, a simple HTML5 mechanism that enables JavaScript
    to create vector and bitmap graphics,^([[209](pr03.html#ftn.CHP-11-FT-12)]) many
    implementations put no restrictions on loading cross-domain images onto the canvas
    and then reading them back pixel by pixel. As of this writing, this issue, too,
    has been resolved: A canvas once touched by a cross-domain image becomes “tainted”
    and can only be written to, not read. But when we need to fix each such case individually,
    something is very wrong.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Chris的努力，样式表问题已经得到解决，但类似的问题在其他类型的跨域子资源中很可能会再次出现。在这种情况下，不能将所有违规行为都归咎于过去的错误。例如，当浏览器厂商推出*<canvas>*,一个简单的HTML5机制，允许JavaScript创建矢量图形和位图图形时[^([[209](pr03.html#ftn.CHP-11-FT-12)])]，许多实现并没有对将跨域图像加载到画布上并逐像素读取施加任何限制。截至本文撰写时，这个问题也得到了解决：一旦被跨域图像接触过的画布就会变成“污染的”，只能写入而不能读取。但当我们需要单独修复每个这样的案例时，问题就非常严重了。
- en: A Note on Cross-Origin Subresources
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于跨域子资源的注意事项
- en: So far, we have focused on the risks of malicious websites navigating or including
    content that belongs to trusted parties. That said, the ability to load certain
    types of subresources from other origins has significant consequences, even if
    not actively subverted by a third-party site.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注恶意网站导航或包含属于受信任方的内容的危险。话虽如此，从其他来源加载某些类型的子资源的能力具有重大影响，即使没有第三方网站积极篡改。
- en: In [Part I](pt01.html "Part I. Anatomy of the Web") of the book, we hinted that
    loading a script or a stylesheet from another origin effectively equates the security
    of the document that performs the load to the security of the origin of the loaded
    subresource; in particular, loading an HTTP script on an HTTPS page undoes most
    of the benefits of encryption. Similarly, loading a script from a provider whose
    infrastructure is vulnerable to attack can be nearly as problematic as not properly
    maintaining your own servers.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第一部分](pt01.html "第一部分。网络解剖学")中，我们暗示从另一个来源加载脚本或样式表实际上等同于将执行加载的文档的安全性等同于加载的子资源来源的安全性；特别是，在HTTPS页面上加载HTTP脚本会取消加密的大部分好处。同样，从基础设施容易受到攻击的提供商那里加载脚本可能几乎与没有正确维护自己的服务器一样有问题。
- en: In addition to scripts and stylesheets, other content types that may lead to
    serious trouble include remote fonts (a recent addition to CSS) and plug-ins with
    access to the embedding page (such as *allowScriptAccess=always* for Flash). It
    is also somewhat dangerous to load images, icons, cursors, or HTML frames from
    untrusted sources, although the impact of doing so is contained to some extent
    and will be use specific.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 除了脚本和样式表之外，其他可能导致严重问题的内容类型包括远程字体（CSS中的最新添加）和可以访问嵌入页面的插件（例如，*allowScriptAccess=always*用于Flash）。从不受信任的来源加载图像、图标、光标或HTML框架也是相当危险的，尽管这样做的影响在一定程度上得到了限制，并且将具体使用。
- en: 'Contemporary browsers attempt to detect cases where HTTPS documents load HTTP
    resources—a condition known as *mixed content*. They do so fairly inconsistently,
    however: Internet Explorer is the only browser that blocks most types of mixed
    content by default (and Chrome is expected to follow suit), but neither Internet
    Explorer nor Firefox nor Opera consistently detects mixed content on *<embed>*,
    *<object>*, or *<applet>* tags. In browsers other than Internet Explorer, the
    default action is a subtle warning (for example, an exclamation mark next to the
    lock icon) or a cryptic dialog, which does very little to protect the user but
    which may alert a sufficiently attentive web developer.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当代浏览器试图检测HTTPS文档加载HTTP资源的情况——这种情况被称为 *混合内容*。然而，它们这样做并不一致：只有Internet Explorer默认情况下阻止大多数类型的混合内容（预计Chrome也将效仿），但Internet
    Explorer、Firefox和Opera并不始终在 *<embed>*, *<object>*, 或 *<applet>* 标签上检测混合内容。在其他浏览器中，默认操作是一个微妙的警告（例如，在锁形图标旁边的感叹号）或一个神秘的对话框，这对保护用户所起的作用非常有限，但可能会提醒一个足够警觉的Web开发者。
- en: As to the other flavor of mixed content—loading subresources across domains
    that offer different levels of trust—browsers have no way to detect this. The
    decision to include content from dubious sources is often made too lightly and
    such mistakes can be difficult to spot until too late.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 至于混合内容的另一种形式——在不同信任级别上跨域加载子资源——浏览器没有方法来检测这种情况。从可疑来源包含内容的决定通常过于草率，并且这种错误可能直到太晚才被发现。
- en: Note
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Another interesting problem with cross-domain subresources is that they may
    request certain additional permissions or credentials from the browser. The associated
    browser security prompts are usually not designed with such scenarios with mind,
    and they do not always make sufficiently clear which origin is requesting the
    permission and based on what sort of relationship with the top-level site. We
    discussed one such problem in [Chapter 3](ch03.html "Chapter 3. Hypertext Transfer
    Protocol"): the authentication prompt shown in response to HTTP code 401\. Several
    other, related cases will appear in [Chapter 15](ch15.html "Chapter 15. Extrinsic
    Site Privileges").'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 跨域子资源的一个有趣问题是它们可能从浏览器请求某些额外的权限或凭证。相关的浏览器安全提示通常没有考虑到这样的场景，并且它们并不总是足够清楚地说明哪个源正在请求权限以及基于与顶级站点的何种关系。我们在[第3章](ch03.html
    "第3章。超文本传输协议")中讨论了这样一个问题：对HTTP代码401响应显示的认证提示。其他几个相关案例将在[第15章](ch15.html "第15章。外部站点权限")中出现。
- en: Privacy-Related Side Channels
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐私相关副作用通道
- en: 'Another unfortunate and noteworthy consequence of the gaps in the same-origin
    policy is the ability to collect information about a user’s interaction with unrelated
    sites. Some of the most rudimentary examples, most of them known for well over
    a decade,^([[210](pr03.html#ftn.CHP-11-FT-13)]) include the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略中的漏洞的另一个不幸且值得注意的后果是能够收集有关用户与无关网站交互的信息。其中一些最基本示例，大多数已为人所知超过十年，^([[210](pr03.html#ftn.CHP-11-FT-13)])
    包括以下内容：
- en: Using *onload* handlers to measure the time it takes to load certain documents,
    an indication of whether they have been previously visited and cached by the browser
    or not.^([[211](pr03.html#ftn.CHP-11-FT-14)])
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *onload* 处理器来测量加载某些文档所需的时间，这是浏览器是否已之前访问并缓存它们的指示.^([[211](pr03.html#ftn.CHP-11-FT-14)])
- en: 'Using *onload* and *onerror* on *<img>* tags to see if an authentication-requiring
    image on a third-party site can be loaded, thus disclosing whether the user is
    logged into that site or not. (Bonus: Sometimes, the error message disclosed to
    the *onerror* handler will include snippets of the targeted page, too.)'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *<img>* 标签上的 *onload* 和 *onerror* 来查看第三方站点上的认证要求图像是否可以加载，从而披露用户是否已登录该站点。（加分项：有时，提供给
    *onerror* 处理器的错误消息还会包括目标页面的片段。）
- en: Loading an unrelated web application in a hidden frame and examining properties
    such as the number and names of subframes created on that page (available through
    the *<handle>.frames[]* array) or the set of global variables (sometimes leaked
    through the semantics of the *delete* operator) in order to detect the same. Naturally,
    the set of sites the user visits or is logged into can be fairly sensitive.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在隐藏框架中加载一个无关的Web应用程序，并检查该页面上创建的子框架的数量和名称（通过 *<handle>.frames[]* 数组获取）或全局变量集（有时通过
    *delete* 操作符的语义泄露）以检测相同情况。自然地，用户访问或登录的网站集合可能相当敏感。
- en: In addition to these tricks, a particularly frightening class of privacy problems
    is associated with two APIs created several years ago to help websites understand
    the style applied to any document element (the sum of browser-specific defaults,
    CSS rules, and any runtime tweaks made automatically by the browser or performed
    via JavaScript). The two APIs in question are *getComputedStyle*, mandated by
    CSS Level 2,^([[212](pr03.html#ftn.CHP-11-FT-15)]) and *currentStyle*, proprietary
    to Internet Explorer.^([[213](pr03.html#ftn.CHP-11-FT-16)]) Their functionality,
    together with the ability to assign distinctive styling to visited links (using
    the *:visited* pseudo-class), means that any rogue JavaScript can rapidly display
    and examine thousands of URLs to see which ones are shaded differently (due to
    being present in a user’s browsing history), thereby building a reliable, extensive,
    and possibly incriminating overview of a user’s online habits with unprecedented
    efficiency and reliability.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些技巧之外，一类特别令人恐惧的隐私问题与几年前创建的两个API有关，这两个API旨在帮助网站理解任何文档元素应用的样式（浏览器特定默认值、CSS规则以及浏览器自动或通过JavaScript执行的任何运行时调整的总和）。这两个API分别是CSS
    Level 2规定的*getComputedStyle*^([[212](pr03.html#ftn.CHP-11-FT-15)])和仅属于Internet
    Explorer的*currentStyle*^([[213](pr03.html#ftn.CHP-11-FT-16)])。它们的函数性与为已访问链接分配独特样式的能力（使用`:visited`伪类）相结合，意味着任何恶意JavaScript都可以快速显示和检查数千个URL，以查看哪些URL被不同地着色（由于存在于用户的浏览历史中），从而以前所未有的效率和可靠性构建一个可靠、广泛且可能具有指控性的用户在线习惯概览。
- en: This problem has been known since at least since 2002, when Andrew Clover posted
    a brief note about it to the popular BUGTRAQ mailing list.^([[214](pr03.html#ftn.CHP-11-FT-17)])
    The issue received little scrutiny in the following years, until a series of layperson-targeted
    demonstrations and a subsequent public outcry around 2006\. A few years later,
    Firefox and WebKit browsers rolled out security improvements to limit the extent
    of styling possible in *:visited* selectors and to limit the ability to inspect
    the resulting composite CSS data.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题至少从2002年开始就已经为人所知，当时Andrew Clover在流行的BUGTRAQ邮件列表上发布了一篇关于它的简短笔记.^([[214](pr03.html#ftn.CHP-11-FT-17)])
    在接下来的几年里，这个问题并没有受到太多的关注，直到2006年左右，一系列针对普通用户的演示和随后的公众舆论爆发。几年后，Firefox和WebKit浏览器推出了安全改进，以限制`:visited`选择器中可能的样式范围，并限制检查结果组合CSS数据的能力。
- en: 'That said, such fixes will never be perfect. Even though they make automated
    data collection impossible, smaller quantities of data can be obtained with a
    user’s help. Case in point: Collin Jackson and several other researchers proposed
    a simple scheme that involved presenting a faux CAPTCHA^([[58](#ftn.CHP-11-FN-3)])
    consisting of seven-segment, LCD-like digits.^([[215](pr03.html#ftn.CHP-11-FT-18)])
    Rather than being an actual, working challenge, the number the user would see
    depended on the *:visited*-based styling applied to superimposed links (see [Figure 11-5](ch11s03.html#a_fake_seven-segment_display_can_be_used
    "Figure 11-5. A fake seven-segment display can be used to read back link styling
    when the displayed number is entered into the browser in an attempt to solve a
    CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history."));
    by typing that number back onto the page, the user would unwittingly tell the
    author of the site what exact styling had been applied and, therefore, what sites
    appeared in the victim’s browsing history.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这样的修复永远不会完美。尽管它们使得自动数据收集变得不可能，但在用户的帮助下，仍然可以获取到少量数据。以Collin Jackson和几位其他研究人员提出的一个简单方案为例：该方案涉及展示一个由七段、类似LCD的数字组成的假CAPTCHA^([[58](#ftn.CHP-11-FN-3)])。这个假CAPTCHA并不是一个实际的工作挑战，用户看到的数字取决于应用于叠加链接的基于`:visited`的样式（参见[图11-5](ch11s03.html#a_fake_seven-segment_display_can_be_used
    "图11-5. 使用假七段显示器可以读取链接样式，当用户在浏览器中输入显示的数字以尝试解决CAPTCHA时。用户将看到5、6、9或8，具体取决于之前的浏览历史。"））；用户将那个数字重新输入到页面上，就会无意中告诉网站作者实际应用了哪些样式，因此可以知道哪些网站出现在受害者的浏览历史中。
- en: '![A fake seven-segment display can be used to read back link styling when the
    displayed number is entered into the browser in an attempt to solve a CAPTCHA.
    The user will see 5, 6, 9, or 8, depending on prior browsing history.](httpatomoreillycomsourcenostarchimages950031.png.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![使用假七段显示器可以读取链接样式，当用户在浏览器中输入显示的数字以尝试解决CAPTCHA时。用户将看到5、6、9或8，具体取决于之前的浏览历史。](httpatomoreillycomsourcenostarchimages950031.png.jpg)'
- en: Figure 11-5. A fake seven-segment display can be used to read back link styling
    when the displayed number is entered into the browser in an attempt to solve a
    CAPTCHA. The user will see 5, 6, 9, or 8, depending on prior browsing history.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5. 当尝试解决CAPTCHA时，将显示的数字输入浏览器中，可以使用一个假的七段显示器来读取回链样式。用户将看到5、6、9或8，这取决于之前的浏览历史。
- en: '* * *'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[58](#CHP-11-FN-3)]) CAPTCHA (sometimes expanded as Completely Automated
    Public Turing test to tell Computers and Humans Apart) is a term for a security
    challenge that is believed to be difficult to solve using computer algorithms
    but that should be easy for a human being. It is usually implemented by showing
    an image of several randomly selected, heavily distorted characters and asking
    the user to type them back. CAPTCHA may be used to discourage the automation of
    certain tasks, such as opening new accounts or sending significant volumes of
    email. (Needless to say, due to advances in computer image processing, robust
    CAPTCHAs are increasingly difficult for humans to solve, too.)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[58](#CHP-11-FN-3)]) CAPTCHA（有时扩展为完全自动化的公众图灵测试，用于区分计算机和人类）是一个指代安全挑战的术语，这种挑战被认为使用计算机算法难以解决，但对于人类来说应该很容易。它通常通过显示几个随机选择的、严重扭曲的字符的图像，并要求用户将其重新输入来实现。CAPTCHA可以用来阻止某些任务的自动化，例如开设新账户或发送大量电子邮件。（不用说，由于计算机图像处理技术的进步，健壮的CAPTCHA也越来越难以被人类解决。）
- en: Other SOP Loopholes and Their Uses
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他SOP漏洞及其用途
- en: Although this chapter has focused on areas where the limitations of the same-origin
    policy have a clear, negative impact on the security or privacy of online browsing,
    there are several accidental gaps in the scheme that in most cases seem to be
    of no special consequence. For example, in many versions of Internet Explorer,
    it was possible to manipulate the value of *window.opener* or *window.name* of
    an unrelated window. Meanwhile in Firefox, there are currently no constraints
    on setting *location.hash* across domains, even though all other partial location
    properties are restricted.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章重点介绍了同一源策略限制对在线浏览安全或隐私产生明确负面影响的领域，但在该方案中存在几个意外漏洞，在大多数情况下似乎没有特殊影响。例如，在许多版本的Internet
    Explorer中，可以操纵无关窗口的 *window.opener* 或 *window.name* 的值。与此同时，在Firefox中，目前对设置跨域的
    *location.hash* 没有任何限制，尽管所有其他部分位置属性都受到限制。
- en: 'The primary significance of these mechanisms is that they are often repurposed
    to build cross-domain communication channels in browsers that do not support the
    *postMessage(...)* API. Such mechanisms are often built on shaky ground: The lack
    of SOP enforcement is typically uniform and means that any website, not just the
    “authorized” parties, will be able to interfere with the data. The ability for
    rogue parties to navigate nested frames, as discussed in [Frame Hijacking Risks](ch11.html#frame_hijacking_risks
    "Frame Hijacking Risks") in [Frame Hijacking Risks](ch11.html#frame_hijacking_risks
    "Frame Hijacking Risks"), further complicates the picture.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制的主要意义在于，它们通常被重新用于在不支持 *postMessage(...)* API的浏览器中建立跨域通信通道。这些机制通常建立在不稳定的基础上：SOP执行力的缺乏通常是统一的，这意味着任何网站，而不仅仅是“授权”方，都将能够干扰数据。正如在[框架劫持风险](ch11.html#frame_hijacking_risks
    "框架劫持风险")中讨论的那样，恶意方导航嵌套框架的能力进一步复杂了这一情况。
- en: Security Engineering Cheat Sheet
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: Good Security Hygiene for All Websites
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网站的优秀安全卫生
- en: 'Serve all content for your site with *X-Frame-Options: sameorigin*. Make case-by-case
    exceptions only for specific, well-understood locations that require cross-domain
    embedding. Try not to depend on JavaScript “framebusting” code to prevent framing
    because it’s very tricky to get that code right.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 *X-Frame-Options: sameorigin* 为您网站上的所有内容提供服务。仅对特定、明确理解的、需要跨域嵌入的位置进行逐案例外。尽量不依赖JavaScript“framebusting”代码来防止框架，因为这非常难以正确实现。'
- en: Return user-specific, sensitive data that is not meant to be loaded across domains
    using well-constrained formats that are unlikely to be misinterpreted as standalone
    scripts, stylesheets, and so on. Always use the right *Content-Type*.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回用户特定的敏感数据，这些数据不应跨域加载，应使用严格约束的格式，这些格式不太可能被误解释为独立的脚本、样式表等。始终使用正确的 *内容类型*。
- en: When Including Cross-Domain Resources
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含跨域资源时
- en: In many scenarios (especially when dealing with scripts, stylesheets, fonts,
    and certain types of plug-in-handled content), you are linking the security of
    your site to the originating domain of the subresource. When in doubt, make a
    local copy of the data instead. On HTTPS sites, require all subresources to be
    served over HTTPS.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多场景中（尤其是在处理脚本、样式表、字体和某些类型的插件处理内容时），你正在将你站点的安全性链接到子资源的源域。如果有疑问，请本地复制数据。在HTTPS站点上，要求所有子资源都通过HTTPS提供服务。
- en: When Arranging Cross-Domain Communications in JavaScript
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当在JavaScript中安排跨域通信时
- en: Consult the cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic"). Do not use cross-frame communication schemes based on *location.hash*,
    *window.name*, *frameElements*, and similar ephemeral hacks, unless you are prepared
    to deal with injected content.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第9章](ch09.html "第9章。内容隔离逻辑")中的速查表。除非你准备好处理注入的内容，否则不要使用基于 *location.hash*、*window.name*、*frameElements*
    和类似临时黑客技巧的跨框架通信方案。
- en: Do not expect subframes on your page to sit still, especially if you are not
    using *X-Frame-Options* to limit the ability of other sites to frame your application.
    In certain cases, an attacker may be able to navigate such frames to a different
    location without your knowledge or consent.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要期望你的页面上的子框架会静止不动，尤其是如果你没有使用 *X-Frame-Options* 来限制其他网站框架你的应用程序的能力。在某些情况下，攻击者可能能够在不知情或未经你同意的情况下将此类框架导航到不同的位置。
- en: Chapter 12. Other Security Boundaries
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。其他安全边界
- en: 'All previously described origin-level content-isolation policies, and the accompanying
    context inheritance and document navigation logic, work hand in hand to form the
    bulk of the browser security model. Impenetrable and fragile, that model is also
    incomplete: A handful of interesting corner cases completely escape any origin-based
    frameworks.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前描述的基于源的内容隔离策略，以及伴随的上下文继承和文档导航逻辑，共同构成了浏览器安全模型的大部分。这个模型既难以渗透又脆弱，但它也是不完整的：一些有趣的边缘情况完全逃出了任何基于源的框架。
- en: The security risks associated with these corner cases can’t be addressed simply
    by fine-tuning the mechanisms discussed earlier in this book. Instead, additional,
    sometimes hopelessly imperfect security boundaries need to be created from scratch.
    These new boundaries may, for example, further restrict the ability of rogue web
    pages to navigate to certain URLs.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边缘情况相关的安全风险不能仅仅通过调整本书前面讨论的机制来解决。相反，需要从头开始创建额外的、有时几乎是无法弥补的安全边界。例如，这些新边界可能会进一步限制恶意网页导航到某些URL的能力。
- en: This chapter offers a quick look at some of the most significant examples of
    the loopholes in the origin-based model and the ways that vendors have dealt with
    them.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了基于源模型的一些最显著的漏洞示例以及供应商如何处理这些问题。
- en: Navigation to Sensitive Schemes
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航到敏感方案
- en: In the past, browser vendors reasoned that there was no harm in allowing any
    page on the Internet to navigate to a document stored on a user’s hard drive using
    the *file:* protocol or to open a new window pointing to a privileged resource,
    such as the *about:config* page in Firefox. After all, they thought, the originating
    document and the destination would not be same-origin, and, therefore, any direct
    access to the sensitive data would be prevented.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，浏览器供应商认为，允许任何互联网页面使用 *file:* 协议导航到用户硬盘上存储的文档或打开指向特权资源的新的窗口（例如Firefox中的 *about:config*
    页面）并没有什么危害。毕竟，他们认为，源文档和目标不会是同源的，因此任何对敏感数据的直接访问都将被阻止。
- en: For many years, based on this rationale, browsers permitted such navigation
    to take place. Alas, this decision proved to be not only extremely confusing^([[59](#ftn.CHP-12-FN-1)])
    but also dangerous. The danger comes from the fact that many programs, browsers
    included, tend to store various types of Internet-originating content in the filesystem;
    temporary files and cached documents are a common example. In many cases, an attacker
    could have some control over the creation and contents of such files, and, if
    the resources are created at a predictable location, subsequent navigation to
    the right *file:* URL could allow the attacker to execute his own payload in this
    coveted origin, with access to any other file on the disk and, perhaps, any other
    website on the Internet.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，基于这一理由，浏览器允许这种导航发生。遗憾的是，这一决定不仅极其令人困惑^([[59](#ftn.CHP-12-FN-1)])，而且危险。危险在于许多程序，包括浏览器，倾向于在文件系统中存储各种类型的互联网来源内容；临时文件和缓存文档是常见例子。在许多情况下，攻击者可能对这类文件的创建和内容有所控制，如果资源在可预测的位置创建，随后导航到正确的
    *file:* URL 可能允许攻击者在备受青睐的源中执行自己的有效载荷，并访问磁盘上的任何其他文件，也许还能访问互联网上的任何其他网站。
- en: Comparably disastrous consequences have been observed with a variety of privileged,
    internally handled URLs. The ability to navigate directly to locations such as
    *about:config* (Firefox) not only made it possible to exploit potential vulnerabilities
    in the privileged scripts (a transgression to which browser vendors are not immune)
    but also led to system compromise if, through a literal application of the same-origin
    policy, the browser naïvely deemed *about:config* and *about:blank* to come from
    the same origin.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 与各种特权、内部处理的 URL 相比，已经观察到具有灾难性的后果。直接导航到诸如 *about:config*（Firefox）之类的位置的权限不仅使得利用特权脚本中的潜在漏洞（浏览器供应商对此类违规行为并不免疫）成为可能，而且如果通过直接应用同源策略，浏览器天真地认为
    *about:config* 和 *about:blank* 来自同一源，这可能导致系统被破坏。
- en: 'Having learned from a history of painful mishaps, modern browsers typically
    police navigation based on three tiers of URL schemes:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上一系列痛苦的事故中吸取教训，现代浏览器通常根据三个级别的 URL 方案来监控导航：
- en: '**Unrestricted** This category includes virtually all true network protocols,
    such as HTTP, HTTPS, FTP; most encapsulating pseudo-protocols such as *mhtml:*
    or *jar:*; and all schemes registered to plug-ins and external applications. Navigation
    to these URLs is not constrained in any specific way.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不受限制** 这一类别包括几乎所有真正的网络协议，如 HTTP、HTTPS、FTP；大多数封装的伪协议，如 *mhtml:* 或 *jar:*；以及注册到插件和外部应用程序的所有方案。对这些
    URL 的导航不受任何特定方式的约束。'
- en: '**Partly restricted** This category includes several security-sensitive schemes
    such as *file:* and special pseudo-URLs such as *javascript:* or *vbscript:*.
    Navigation to them is not completely denied, but it is subject to additional,
    scheme-specific security checks. For example, access to *file:* is usually permitted
    only from other *file:* documents, requiring the first one to be opened manually.
    (The rules for navigation to *javascript:* URLs were discussed in [Chapter 10](ch10.html
    "Chapter 10. Origin Inheritance").)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分受限** 这一类别包括几个安全敏感的方案，如 *file:* 和特殊的伪 URL，如 *javascript:* 或 *vbscript:*。对这些方案的导航并未完全禁止，但需要额外的、针对特定方案的
    安全检查。例如，对 *file:* 的访问通常仅限于其他 *file:* 文档，要求第一个文档手动打开。（关于导航到 *javascript:* URL 的规则已在
    [第 10 章](ch10.html "第 10 章。源继承") 中讨论。）'
- en: '**Fully restricted** This category includes privileged pages in *about:*, *res:*,
    *chrome:*, and similar browser-specific namespaces. Normal, unprivileged HTML
    documents are not permitted to navigate to them under any circumstance.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全受限** 这一类别包括 *about:*、*res:*、*chrome:* 和类似浏览器特定命名空间中的特权页面。在任何情况下，都不允许正常的、非特权的
    HTML 文档导航到这些页面。'
- en: '* * *'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[59](#CHP-12-FN-1)]) For example, on Windows systems, a common prank was
    to use a seamlessly embedded *<iframe>* pointing to *file:///c:/* in order to
    display the contents of a victim’s hard drive, leading some users to believe that
    the page doing so has somehow gained access to their files.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[59](#CHP-12-FN-1)]) 例如，在 Windows 系统上，一个常见的恶作剧是使用无缝嵌入的 *<iframe>* 指向 *file:///c:/*
    来显示受害者的硬盘内容，导致一些用户认为执行此操作的页面以某种方式获得了访问他们文件的权限。
- en: Access to Internal Networks
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部网络访问
- en: The trouble with accessing sensitive protocols is merely a prelude to a far
    more serious issue that somehow escaped the creators of the same-origin policy.
    The problem is that DNS-derived origins may have nothing to do with actual network-level
    boundaries—or with how these boundaries change over time. A malicious script may
    be granted same-origin access to intranet sites on the victim’s local network,
    even if a firewall prevents the attacker from interacting with these destinations
    directly.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 访问敏感协议的问题仅仅是同源策略创造者可能没有预料到的更严重问题的序曲。问题是 DNS 衍生的源可能与实际的网络级别边界无关——或者与这些边界随时间变化的方式无关。恶意脚本可能被授予对受害者本地网络上内部网站的同源访问权限，即使防火墙阻止攻击者直接与这些目标交互。
- en: There are at least three distinctive venues for such attacks.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击至少有三种不同的方式。
- en: '**Origin Infiltration**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**源渗透**'
- en: When a user visits a rogue network—such as an open wireless network at an airport
    or in a café—an attacker on that network may trick the victim’s browser into opening
    a URL such as [http://us-payroll/](http://us-payroll/). When this happens, the
    attacker may provide his own, spoofed content for that site. Frighteningly, if
    the user then brings the same browser to a corporate network, the previously injected
    content will have same-origin access to the real version of [http://us-payroll/](http://us-payroll/),
    complete with the user’s ambient credentials.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问一个恶意网络——例如机场或咖啡馆中的开放无线网络——该网络上的攻击者可能诱骗受害者的浏览器打开一个如 [http://us-payroll/](http://us-payroll/)
    的 URL。当这种情况发生时，攻击者可能为该网站提供自己的、伪造的内容。令人恐惧的是，如果用户随后带着同一个浏览器进入企业网络，之前注入的内容将具有对 [http://us-payroll/](http://us-payroll/)
    的真实版本的同源访问权限，包括用户的环境凭据。
- en: 'The persistence of injected content may be achieved in a couple of ways. The
    most basic method is for an attacker simply to inject a hidden [http://us-payroll/](http://us-payroll/)frame
    onto every visited page in the hope that the user will suspend a portable computer
    with the browser still running and then take it to another network. Another technique
    is *cache poisoning*: creating long-lived, cached objects that the browser will
    use instead of retrieving a fresh copy from the destination site. Several other,
    more obscure approaches also exist.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 注入内容的持久性可以通过几种方式实现。最基本的方法是攻击者简单地在一个隐藏的 [http://us-payroll/](http://us-payroll/)
    框架中注入到每个访问的页面，希望用户在浏览器仍然运行的情况下暂停携带的计算机，并将其带到另一个网络。另一种技术是 *缓存中毒*：创建长期存在的、缓存的对象，浏览器将使用这些对象而不是从目标网站检索新鲜副本。还存在几种其他更不为人知的方案。
- en: '**DNS Rebinding**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**DNS 重绑定**'
- en: This arguably less serious but more easily exploitable problem was mentioned
    in footnote 1 in [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic").
    In short, since the same-origin policy looks just at the DNS name of a host, not
    at the IP address, an attacker who owns [bunnyoutlet.com](http://bunnyoutlet.com)
    is free to respond initially to a DNS lookup from a user with a public IP such
    as *213.134.128.25* and then switch to an address reserved for private networks,
    such as *10.0.0.1*. Documents loaded from both sources will be considered same-origin,
    giving the attacker the ability to interact with the victim’s internal network.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可能不那么严重但更容易利用的问题在 [第 9 章](ch09.html "第 9 章。内容隔离逻辑") 的脚注 1 中被提及。简而言之，由于同源策略只关注主机的
    DNS 名称，而不是 IP 地址，因此拥有 [bunnyoutlet.com](http://bunnyoutlet.com) 的攻击者可以自由地最初对具有公共
    IP 地址（如 *213.134.128.25*）的用户进行 DNS 查询，然后切换到为私有网络保留的地址，如 *10.0.0.1*。从这两个来源加载的文档将被视为同源，这给了攻击者与受害者内部网络交互的能力。
- en: 'The mitigating factor is that this interaction will not involve proper ambient
    credentials that the victim normally has for the targeted site: As far as the
    browser is concerned, it is still talking to [bunnyoutlet.com](http://bunnyoutlet.com)
    and not to, say, the aforementioned *us-payroll* site. Still, the prospect of
    the attacker examining the internal network and perhaps trying to brute-force
    the appropriate credentials or identify vulnerabilities is disconcerting.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解因素是这种交互不会涉及受害者通常为针对的网站拥有的适当环境凭据：就浏览器而言，它仍在与 [bunnyoutlet.com](http://bunnyoutlet.com)
    而不是上述 *us-payroll* 网站进行通信。尽管如此，攻击者检查内部网络并可能尝试暴力破解适当的凭据或识别漏洞的前景仍然令人不安。
- en: '**Simple Exploitation of XSS or XSRF Flaws**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单利用 XSS 或 XSRF 漏洞**'
- en: Even outside the realm of the same-origin policy, the mere possibility of navigating
    to intranet URLs means that the attacker may attempt to (blindly) target known
    or suspected vulnerabilities in locally running software. Because internal applications
    are thought to be protected from malicious users, they are often not engineered
    or maintained to the same standards as externally facing code.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在相同源策略之外，导航到内网URL的可能性意味着攻击者可能会尝试（盲目地）针对本地运行的软件中已知或疑似存在的漏洞。由于内部应用程序被认为受到恶意用户的保护，它们通常不会被设计或维护到与面向外部的代码相同的标准。
- en: One striking example of this problem is the dozens of vulnerabilities discovered
    over the years in internal-only web management interfaces of home network routers
    manufactured by companies such as Linksys (Cisco), Netgear, D-Link, Motorola,
    and Siemens. Cross-site request forgery vulnerabilities in these applications
    can, in extreme cases, permit attackers to access the device and intercept or
    modify all network traffic going to or through it.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个引人注目的例子是，在Linksys（Cisco）、Netgear、D-Link、Motorola和Siemens等公司制造的家用网络路由器的内部仅限Web管理界面中发现的数十个漏洞。这些应用程序中的跨站请求伪造漏洞在极端情况下可能允许攻击者访问设备并拦截或修改所有进入或通过该设备的网络流量。
- en: So far, the disconnect between browser security mechanisms and network segmentation
    remains an unsolved problem in browser engineering. Several browsers try to limit
    the impact of DNS rebinding by caching DNS responses for a predefined time—a practice
    known as *DNS pinning*—but the defense is imperfect, and the remaining attack
    vectors still remain.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，浏览器安全机制和网络分段之间的脱节仍然是浏览器工程中的一个未解决的问题。几个浏览器试图通过缓存DNS响应一段时间来限制DNS重绑定的影响——这种做法被称为*DNS固定*——但防御并不完美，剩余的攻击向量仍然存在。
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unusually, Internet Explorer takes the lead on this front, offering an optional
    way to mitigate the risk. Microsoft’s users are protected to some extent if they
    flip a cryptic zone setting named “websites in less privileged web content zone
    can navigate into this zone” to “disable” in the configuration options for local
    intranet. Unfortunately, the zone model in Internet Explorer comes with some unexpected
    pitfalls, as we’ll discuss in [Chapter 15](ch15.html "Chapter 15. Extrinsic Site
    Privileges").
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不寻常的是，Internet Explorer在这方面领先，提供了一个可选的方式来减轻风险。如果Microsoft的用户在本地内网配置选项中将一个神秘的区域设置“在受限制的Web内容区域中的网站可以导航到该区域”切换到“禁用”，他们将在一定程度上受到保护。不幸的是，Internet
    Explorer中的区域模型带来了一些意外的陷阱，我们将在[第15章](ch15.html "第15章。外部站点权限")中讨论。
- en: Prohibited Ports
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁止端口
- en: 'Security researchers have cautioned that the ability of browsers to submit
    largely unconstrained cross-origin request bodies, for example with <*form method="POST"
    enctype="text/plain">*, may interfere with certain other fault-tolerant but non-HTTP
    network services. For example, consider SMTP, the dominant mail transfer protocol:
    When interacting with an unsuspecting browser, most servers that speak SMTP will
    patiently ignore the first few incomprehensible lines associated with HTTP headers
    and then honor any SMTP commands that appear in the request body. In effect, the
    browser could be used as a proxy for relaying spam.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 安全研究人员警告说，浏览器提交大量不受约束的跨源请求体的能力，例如使用`<form method="POST" enctype="text/plain">`，可能会干扰某些其他容错但非HTTP的网络服务。例如，考虑SMTP，占主导地位的邮件传输协议：当与一个毫无戒心的浏览器交互时，大多数使用SMTP的服务器会耐心地忽略与HTTP头关联的几行难以理解的内容，然后尊重请求体中出现的任何SMTP命令。实际上，浏览器可以被用作中继垃圾邮件的代理。
- en: A related but less well-explored concern, discussed in [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol"), is the risk of an attacker talking
    to non-HTTP services running in the same domain as the targeted web application
    and tricking the browser into misinterpreting the returned, possibly partly attacker-controlled
    data as HTML delivered over HTTP/0.9\. This behavior could expose cookies or other
    credentials associated with the targeted site.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。超文本传输协议")中讨论的一个相关但不太被深入探讨的担忧是，攻击者与运行在目标Web应用同一域中的非HTTP服务进行交流，并诱使浏览器错误地解释返回的、可能部分受攻击者控制的数据，将其视为通过HTTP/0.9发送的HTML。这种行为可能会暴露与目标站点关联的cookie或其他凭证。
- en: 'The design of HTTP makes it impossible to solve these problems in a particularly
    robust way. Instead, browser vendors have responded in a rather unconvincing manner:
    by shipping a list of prohibited TCP ports to which requests cannot be sent. For
    Internet Explorer versions 6 and 7, the list consists of the following port numbers:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的设计使得无法以特别稳健的方式解决这些问题。相反，浏览器厂商以一种相当令人怀疑的方式做出了回应：通过提供一份禁止发送请求的TCP端口号列表。对于Internet
    Explorer 6和7版本，该列表包括以下端口号：
- en: '| 19 | chargen |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 19 | chargen |'
- en: '| 21 | ftp |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 21 | ftp |'
- en: '| 25 | smtp |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 25 | smtp |'
- en: '| 110 | pop3 |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 110 | pop3 |'
- en: '| 119 | nntp |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 119 | nntp |'
- en: '| 143 | imap2 |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 143 | imap2 |'
- en: Versions 8 and 9 of Internet Explorer further prohibit ports 220 (imap3) and
    993 (ssl imap3).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer的8和9版本进一步禁止了220（imap3）和993（ssl imap3）端口。
- en: 'All other browsers discussed in this book use a different, common list:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 本书讨论的所有其他浏览器使用不同的、共同的列表：
- en: '| 1 | tcpmux | 115 | sftp |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 1 | tcpmux | 115 | sftp |'
- en: '| 7 | echo | 117 | uccp-path |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 7 | echo | 117 | uccp-path |'
- en: '| 9 | discard | 119 | nntp |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 9 | discard | 119 | nntp |'
- en: '| 11 | systat | 123 | ntp |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 11 | systat | 123 | ntp |'
- en: '| 13 | daytime | 135 | loc-srv |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 13 | daytime | 135 | loc-srv |'
- en: '| 15 | netstat | 139 | netbios |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 15 | netstat | 139 | netbios |'
- en: '| 17 | qotd | 143 | imap2 |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 17 | qotd | 143 | imap2 |'
- en: '| 19 | chargen | 179 | bgp |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 19 | chargen | 179 | bgp |'
- en: '| 20 | ftp-data | 389 | ldap |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| 20 | ftp-data | 389 | ldap |'
- en: '| 21 | ftp | 465 | ssl smtp |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 21 | ftp | 465 | ssl smtp |'
- en: '| 22 | ssh | 512 | exec |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 22 | ssh | 512 | exec |'
- en: '| 23 | telnet | 513 | login |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 23 | telnet | 513 | login |'
- en: '| 25 | smtp | 514 | shell |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 25 | smtp | 514 | shell |'
- en: '| 37 | time | 515 | printer |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 37 | time | 515 | printer |'
- en: '| 42 | name | 526 | tempo |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 42 | name | 526 | tempo |'
- en: '| 43 | nicname | 530 | courier |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 43 | nicname | 530 | courier |'
- en: '| 53 | domain | 531 | chat |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 53 | domain | 531 | chat |'
- en: '| 77 | priv-rjs | 532 | netnews |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 77 | priv-rjs | 532 | netnews |'
- en: '| 79 | finger | 540 | uucp |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 79 | finger | 540 | uucp |'
- en: '| 87 | ttylink | 556 | remotefs |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 87 | ttylink | 556 | remotefs |'
- en: '| 95 | supdup | 563 | ssl nntp |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 95 | supdup | 563 | ssl nntp |'
- en: '| 101 | hostriame | 587 | smtp submission |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 101 | hostriame | 587 | smtp submission |'
- en: '| 102 | iso-tsap | 601 | syslog |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 102 | iso-tsap | 601 | syslog |'
- en: '| 103 | gppitnp | 636 | ssl ldap |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 103 | gppitnp | 636 | ssl ldap |'
- en: '| 104 | acr-nema | 993 | ssl imap |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 104 | acr-nema | 993 | ssl imap |'
- en: '| 109 | pop2 | 995 | ssl pop3 |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 109 | pop2 | 995 | ssl pop3 |'
- en: '| 110 | pop3 | 2049 | nfs |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 110 | pop3 | 2049 | nfs |'
- en: '| 111 | sunrpc | 4045 | lockd |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 111 | sunrpc | 4045 | lockd |'
- en: '| 113 | auth | 6000 | X11 |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 113 | auth | 6000 | X11 |'
- en: There are, of course, various protocol-specific exceptions to these rules. For
    example, *ftp:* URLs are obviously permitted to access port 21, normally associated
    with that protocol.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些规则存在各种特定协议的例外。例如，*ftp:* URL显然允许访问与该协议通常关联的21号端口。
- en: The current solution is flawed in several ways, the most important of which
    may be that both lists have numerous glaring omissions and, given the number of
    network protocols devised to date, simply have no chance of ever being exhaustive.
    For example, no rule would prevent the browser from talking to Internet Relay
    Chat (IRC) servers, which use a fault-tolerant, text-based protocol not entirely
    unlike SMTP.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的解决方案存在几个缺陷，其中最重要的可能是两个列表都有许多明显的遗漏，并且考虑到迄今为止设计的网络协议数量，它们根本不可能完全详尽。例如，没有任何规则可以阻止浏览器与使用容错、基于文本协议的Internet中继聊天（IRC）服务器通信，这种协议与SMTP并不完全不同。
- en: 'The lists are also not regularly updated to reflect the demise of nearly extinct
    network protocols or the introduction of new ones. Lastly, they can unfairly and
    unexpectedly penalize system administrators for picking nonstandard ports for
    certain services they want to hide from public view: Doing so means opting out
    of this browser-level protection mechanism.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表也没有定期更新以反映几乎灭绝的网络协议的消亡或新协议的引入。最后，它们可能会不公平和意外地惩罚系统管理员，因为他们选择了某些他们希望隐藏在公众视野之外的服务的不标准端口：这样做意味着选择退出这种浏览器级别的保护机制。
- en: Limitations on Third-Party Cookies
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方Cookie的限制
- en: Since their inception, HTTP cookies have been misunderstood as the tool that
    enabled online advertisers to violate users’ privacy to an unprecedented and previously
    unattainable extent. This sentiment has been echoed by the mainstream press in
    the years since. For example, in 2001, the *New York Times* published a lengthy
    exposé on the allegedly unique risks of HTTP cookies and even quoted Lawrence
    Lessig, a noted legal expert and a political activist:^([[216](pr03.html#ftn.CHP-12-FT-1)])
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它们的诞生以来，HTTP cookies一直被误解为允许在线广告商以前所未有和以前无法达到的程度侵犯用户隐私的工具。这种观点在随后的几年里得到了主流媒体的呼应。例如，2001年，《纽约时报》发表了一篇关于HTTP
    cookies据称独特风险的详细调查报告，并引用了著名法律专家和政治活动家劳伦斯·莱斯格的话：^([[216](pr03.html#ftn.CHP-12-FT-1)])
- en: Before cookies, the Web was essentially private. After cookies, the Web becomes
    a space capable of extraordinary monitoring.
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在cookie出现之前，网络本质上是一个私密的领域。而在cookie出现之后，网络变成了一个可以进行非凡监控的空间。
- en: The high-profile assault on a single HTTP header continued over the course of
    a decade, gradually shifting its focus toward third-party cookies in particular.
    Third-party cookies are the cookies set by domains other than the domain of the
    top-level document, and they are usually associated with the process of loading
    images, frames, or applets from third-party sites. The reason they have attracted
    attention is that operators of advertising networks have embraced such cookies
    as a convenient way to tag a user who sees their ad embedded on [fuzzybunnies.com](http://fuzzybunnies.com)
    and then recognize that user through a similar embedded ad served on [playboy.com](http://playboy.com).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 对单个HTTP头部的公开攻击持续了十年之久，逐渐将重点转向第三方cookie。第三方cookie是由顶级文档域之外的域设置的cookie，它们通常与从第三方网站加载图像、框架或小程序的过程相关联。它们之所以引起关注，是因为广告网络的运营商将此类cookie视为标记在[fuzzybunnies.com](http://fuzzybunnies.com)上看到其广告的用户的一种便捷方式，然后通过在[playboy.com](http://playboy.com)上提供的类似嵌入式广告来识别该用户。
- en: Because the clearly undesirable possibility of performing this type of cross-domain
    tracking has been erroneously conflated with the existence of third-party cookies,
    the pressure on browser vendors has continued to mount. In one instance, the *Wall
    Street Journal* flat out accused Microsoft of being in bed with advertisers for
    not eliminating third-party cookies in the company’s product.^([[217](pr03.html#ftn.CHP-12-FT-2)])
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行此类跨域跟踪的明显不希望发生的可能性被错误地与第三方cookie的存在混为一谈，浏览器供应商所承受的压力持续增加。在其中一个例子中，《华尔街日报》直言不讳地指责微软公司因为在其产品中未消除第三方cookie而与广告商有染。[^[[217](pr03.html#ftn.CHP-12-FT-2])]
- en: Naturally, the readers of this book will recognize that the fixation on HTTP
    cookies is deeply misguided. There is no doubt that some parties use the mechanism
    for vaguely sinister purposes, but nothing makes it uniquely suited for this task;
    there are many other equivalent ways to store unique identifiers on visitors’
    computers (such as cache-based tags, previously discussed in [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol")). Besides, it is simply impossible to
    prevent cooperating sites from using existing unique fingerprints of every browser
    (exposed through the JavaScript object model or plug-ins such as Flash) to correlate
    and mine cross-domain browsing patterns at will. The sites that embed advertisements
    for profit are quite willing to cooperate with the parties who pay their bills.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这本书的读者会认识到，对HTTP cookie的过度关注是极其错误的。毫无疑问，某些方面使用该机制是为了模糊的恶意目的，但没有任何东西使其特别适合这项任务；还有许多其他等效的方法可以在访客的计算机上存储唯一的标识符（例如，在第3章中讨论过的基于缓存的标签）。此外，简单地阻止合作网站使用每个浏览器现有的唯一指纹（通过JavaScript对象模型或如Flash之类的插件暴露）随意关联和挖掘跨域浏览模式是不可能的。那些为了盈利而嵌入广告的网站非常愿意与支付他们账单的各方合作。
- en: 'In fact, the common reliance on HTTP cookies offers a distinctive advantage
    to users: Unlike many of the easily embraced alternatives, this mechanism is purpose
    built and coupled with reasonably well-designed and fine-grained privacy controls.
    Breaking cookies will not hinder tracking but will remove any pretense of transparency
    from the end user. Another noted privacy and security activist, Ed Felten, once
    said: “If you’re going to track me, please use cookies.”^([[218](pr03.html#ftn.CHP-12-FT-3)])'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，对HTTP cookie的普遍依赖为用户提供了一种独特的优势：与许多容易接受的替代方案不同，这种机制是专门设计的，并且与合理设计且粒度细的隐私控制相结合。破坏cookie不会妨碍跟踪，但会从最终用户那里消除任何透明度的假象。另一位知名的隐私和安全活动家Ed
    Felten曾说过：“如果你要跟踪我，请使用cookie。”[^[[218](pr03.html#ftn.CHP-12-FT-3])]
- en: Unscrupulous online tracking is a significant social issue, and new technical
    mechanisms may be needed so that users can communicate their privacy preferences
    to well-behaved sites (such as the recently added *DNT* request header^([[219](pr03.html#ftn.CHP-12-FT-4)])
    rolled out in Firefox 4). In order to deal with the ill-behaved ones, a regulatory
    framework may be required, too. In the absence of such a framework, in Internet
    Explorer 9, Microsoft is experimenting with a managed blacklist of known bad sources
    of tracking cookies—but the odds that this would discourage sleazy business practices
    are slim.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 无良的在线跟踪是一个重大的社会问题，可能需要新的技术机制，以便用户可以向行为良好的网站（如Firefox 4最近添加的*DNT*请求头部^([[219](pr03.html#ftn.CHP-12-FT-4)]))传达他们的隐私偏好。为了处理行为不良的网站，可能还需要一个监管框架。在没有这样的框架的情况下，在Internet
    Explorer 9中，微软正在尝试使用已知跟踪cookie不良来源的管理黑名单进行实验——但这种情况可能不足以阻止卑鄙的商业行为。
- en: In any case, despite having little or no merit, the continued public outcry
    against third-party cookies eventually resulted in several browser vendors shipping
    half-baked and easily circumvented solutions that let them claim they had done
    *something*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，尽管这些第三方cookie的争议微乎其微或根本不存在，但持续的公众反对最终导致了几家浏览器厂商推出了半成品且容易被规避的解决方案，使他们能够声称已经“做了些什么”。
- en: In Internet Explorer, setting and reading third-party cookies is blocked by
    default, except for session cookies accompanied by a satisfactory P3P header.
    *P3P* (*Platform for Privacy Preferences*)^([[220](pr03.html#ftn.CHP-12-FT-5)])
    is a method to construct machine-readable, legally binding summaries of a site’s
    privacy policy, be it as an XML file or as a *compact policy* in an HTTP header.
    For example, the keyword TEL in an HTTP header means that the site uses the collected
    information for telemarketing purposes. (No technical measure will prevent a site
    from lying in a P3P header, but the potential legal consequences are meant to
    discourage that.)
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Internet Explorer中，默认阻止设置和读取第三方cookie，除非是与令人满意的P3P头部一起的会话cookie。*P3P* (*平台隐私偏好*)^([[220](pr03.html#ftn.CHP-12-FT-5)])
    是一种构建机器可读、具有法律约束力的网站隐私政策的摘要的方法，无论是作为XML文件还是作为HTTP头部中的*紧凑策略*。例如，HTTP头部中的关键词TEL表示该网站使用收集到的信息进行电话营销。（没有任何技术措施可以阻止网站在P3P头部中撒谎，但潜在的合法后果旨在阻止这种行为。）
- en: Note
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The incredibly ambitious, 111-page P3P specification caused the solution to
    crumble under its own weight. Large businesses are usually very hesitant to embrace
    P3P as a solution to technical problems because of the legal footprint of the
    spec, while small businesses and individual site owners copy over P3P header recipes
    with little or no understanding of what they are supposed to convey.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非凡雄心勃勃的、111页的P3P规范导致解决方案在其自身重量下崩溃。大型企业通常非常犹豫是否将P3P作为解决技术问题的方案，因为规范的法律影响，而小型企业和个人网站所有者则很少或没有理解就复制了P3P头部配方。
- en: 'In Safari, the task of setting third-party cookies is blocked by default, but
    previously issued cookies can be read freely. However, this behavior can be overridden
    if the user interacts with the cookie-setting document first. Such an interaction
    could be intentional but may very well not be: The clickjacking-related tricks
    outlined in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin Rules")
    apply to this scenario as well.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Safari中，默认阻止设置第三方cookie的任务，但可以自由读取之前发行的cookie。然而，如果用户首先与设置cookie的文档交互，则可以覆盖这种行为。这种交互可能是故意的，但也可能不是：第11章（第11章。同源规则之外的生活）中概述的与clickjacking相关的技巧也适用于这种情况。
- en: In other browsers, third-party cookies are permitted by default, but a configuration
    option is provided to change the behavior. Enabling this option limits the ability
    to set third-party cookies, but reading existing ones is not limited in any way.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他浏览器中，第三方cookie默认允许，但提供了一个配置选项来更改行为。启用此选项会限制设置第三方cookie的能力，但读取现有的cookie没有任何限制。
- en: For the purpose of these checks, a cookie is considered to be coming from a
    third party if it’s loaded from a completely unrelated domain. For example, a
    frame pointing to [bunnyoutlet.com](http://bunnyoutlet.com) loaded on [fuzzybunnies.com](http://fuzzybunnies.com)
    meets this criterion, but [www1.fuzzybunnies.com](http://www1.fuzzybunnies.com)
    and [www2.fuzzybunnies.com](http://www2.fuzzybunnies.com) are considered to be
    in a first-party relationship. The logic used to make this determination is fragile,
    and it suffers from the same problems that cookie *domain* scoping would. In Internet
    Explorer 6 and 7, for example, the comparisons in certain country-level domains
    are performed incorrectly.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行这些检查，如果一个Cookies是从一个完全无关的域加载的，那么它被认为是来自第三方。例如，在[fuzzybunnies.com](http://fuzzybunnies.com)上加载的指向[bunnyoutlet.com](http://bunnyoutlet.com)的框架符合这一标准，但[www1.fuzzybunnies.com](http://www1.fuzzybunnies.com)和[www2.fuzzybunnies.com](http://www2.fuzzybunnies.com)被认为是第一方关系。用于做出这种决定的逻辑是脆弱的，并且它遭受了与Cookies
    *域*作用域相同的问题。例如，在Internet Explorer 6和7中，某些国家级域的比较执行不正确。
- en: Note
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The crusade against third-party cookies could be seen as a harmless exercise,
    but it has had negative consequences, too. Browsers that reject third-party cookies
    make it very difficult to build cookie-based authentication for embeddable gadgets
    and other types of mashups, and they make it difficult to use “sandbox” domains
    to isolate untrusted but private content from the main application to limit the
    impact of script-injection flaws.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 对第三方Cookies的十字军东征可能被视为无害的练习，但它也有负面影响。拒绝第三方Cookies的浏览器使得构建基于Cookies的认证对于可嵌入的小工具和其他类型的混合应用变得非常困难，并且它们使得使用“沙箱”域来隔离不受信任但私有的内容以限制脚本注入漏洞的影响变得困难。
- en: Security Engineering Cheat Sheet
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Building Web Applications on Internal Networks
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部网络上构建Web应用程序时
- en: Assume that determined attackers will be able to interact with those applications
    through a victim’s browser, regardless of any network-level security controls.
    Ensure that proper engineering standards are met and require HTTPS with *secure*
    cookies for all sensitive applications in order to minimize the risk of origin
    infiltration attacks.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设决心攻击者将能够通过受害者的浏览器与那些应用程序交互，无论任何网络级别的安全控制。确保满足适当的工程标准，并要求所有敏感应用程序使用HTTPS和*安全*的Cookies，以最大限度地降低来源渗透攻击的风险。
- en: When Launching Non-HTTP Services, Particularly on Nonstandard Ports
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动非HTTP服务，尤其是在非标准端口上时
- en: Evaluate the impact of browsers unintentionally issuing HTTP requests to the
    service and the impact of having the response interpreted as HTTP/0.9\. For vulnerable
    protocols, consider dropping the connection immediately if the received data begins
    with “GET” or “POST” as one possible precaution.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估浏览器无意中向服务发出HTTP请求的影响，以及将响应解释为HTTP/0.9的影响。对于易受攻击的协议，如果接收到的数据以“GET”或“POST”开头，立即断开连接可能是一个可能的预防措施。
- en: When Using Third-Party Cookies for Gadgets or Sandboxed Content
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用第三方Cookies用于小工具或沙箱内容时
- en: If you need to support Internet Explorer, be prepared to use P3P policies (and
    evaluate their legal significance). If you need to support Safari, you may have
    to resort to an alternative credential storage mechanism (such as HTML5 *localStorage*).
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要支持Internet Explorer，请准备使用P3P策略（并评估其法律意义）。如果需要支持Safari，可能不得不求助于替代的凭证存储机制（例如HTML5
    *localStorage*）。
- en: Chapter 13. Content Recognition Mechanisms
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章. 内容识别机制
- en: 'So far, we have looked at a fair number of well-intentioned browser features
    that, as the technology matured, proved to be short-sighted and outright dangerous.
    But now, brace for something special: In the history of the Web, nothing has proven
    to be as misguided as *content sniffing*.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一些有良好意图的浏览器功能，随着技术的成熟，这些功能证明是短视的，甚至是危险的。但现在，准备好迎接一些特别的东西：在Web的历史上，没有什么比*内容嗅探*更被误导的了。
- en: 'The original premise behind content sniffing was simple: Browser vendors assumed
    that in some cases, it would be appropriate—even desirable—to ignore the normally
    authoritative metadata received from the server, such as the *Content-Type* header.
    Instead of honoring the developer’s declared intent, implementations that support
    content sniffing may attempt to second-guess the appropriate course of action
    by applying proprietary heuristics to the returned payload in order to compensate
    for possible mistakes. (Recall from [Chapter 1](ch01.html "Chapter 1. Security
    in the World of Web Applications") that during the First Browser Wars, vendors
    turned fault-tolerance compatibility into an ill-conceived competitive advantage.)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探背后的原始前提很简单：浏览器供应商假设在某些情况下，忽略从服务器接收的正常权威元数据，例如*Content-Type*头，可能是适当的——甚至是希望的。而不是尊重开发者的声明意图，支持内容嗅探的实现可能会尝试通过应用专有启发式方法来猜测适当的行动方案，以弥补可能的错误。（回想一下[第1章](ch01.html
    "第1章。Web应用程序世界中的安全")，在第一次浏览器大战期间，供应商将容错兼容性变成了一个不切实际的竞争优势。）
- en: It didn’t take long for content-sniffing features to emerge as a substantial
    and detrimental aspect of the overall browser security landscape. To their horror
    and disbelief, web developers soon noticed that they couldn’t safely host certain
    nominally harmless document types like *text/plain* or *text/csv* on behalf of
    their users; any attempt to do so would inevitably create a risk that such content
    could be misinterpreted as HTML.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探功能很快成为浏览器整体安全景观中的一个重大且有害的方面。令他们惊恐和难以置信的是，Web开发人员很快发现，他们无法安全地为用户托管某些表面上无害的文档类型，如*text/plain*或*text/csv*；任何尝试这样做都会不可避免地产生风险，即这种内容可能会被误解释为HTML。
- en: 'Perhaps partly in response to these concerns, in 1999 the practice of unsolicited
    content sniffing was explicitly forbidden in HTTP/1.1:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 或许部分是为了回应这些担忧，1999年，在HTTP/1.1中明确禁止了未经请求的内容嗅探实践：
- en: If and only if the media type is not given by a *Content-Type* field, the recipient
    may attempt to guess the media type via inspection of its content and/or the name
    extension(s) of the URI used to identify the resource.
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有当媒体类型不是由*Content-Type*字段提供时，接收者才可以通过检查其内容以及/或用于标识资源的URI的名称扩展来尝试猜测媒体类型。
- en: Alas, this uncharacteristically clear requirement arrived a bit too late. Most
    browsers were already violating this rule to some extent, and absent a convenient
    way to gauge the potential consequences, their authors hesitated to simply ditch
    the offending code. Although several of the most egregious mistakes were cautiously
    reverted in the past decade, two companies—Microsoft and Apple—largely resisted
    the effort. They decided that interoperability with broken web applications should
    trump the obvious security problems. To pacify any detractors, they implemented
    a couple of imperfect, secondary security mechanisms intended to mitigate the
    risk.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这个不同寻常的明确要求来得有点太晚了。大多数浏览器已经在某种程度上违反了这项规则，而且由于没有方便的方法来衡量潜在后果，它们的作者犹豫不决，不愿简单地丢弃有问题的代码。尽管在过去十年中，一些最严重的错误被谨慎地回滚，但微软和苹果两家公司主要抵制了这一努力。他们决定，与损坏的Web应用程序的互操作性应该优先于明显的安全问题。为了安抚任何批评者，他们实施了几种不完美、次要的安全机制，旨在减轻风险。
- en: Today, the patchwork of content-handling policies and the subsequently deployed
    restrictions cast a long shadow on the online world, making it nearly impossible
    to build certain types of web services without resorting to contrived and sometimes
    expensive tricks. To understand these limitations, let’s begin by outlining several
    scenarios where a nominally passive document may be misidentified as HTML or something
    like it.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，内容处理政策和随后部署的限制在在线世界中投下了长长的阴影，使得在没有求助于人为和有时昂贵的技巧的情况下几乎不可能构建某些类型的Web服务。为了理解这些限制，让我们首先概述几个场景，在这些场景中，一个表面上被动的文档可能会被误识别为HTML或类似的东西。
- en: Document Type Detection Logic
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档类型检测逻辑
- en: The simplest and the least controversial type of document detection heuristics,
    and the one implemented by all modern browsers, is the logic implemented to handle
    the absence of the *Content-Type* header. This situation, which is encountered
    very rarely, may be caused by the developer accidentally omitting or mistyping
    the header name or the document being loaded over a non-HTTP transport mechanism
    such as *ftp:* or *file:*.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且最具争议性的文档检测启发式方法是处理 *Content-Type* 标头缺失的逻辑，这是所有现代浏览器所实现的。这种情况非常罕见，可能是由于开发者不小心省略或误输了标头名称，或者文档是通过非
    HTTP 传输机制（如 *ftp:* 或 *file:*）加载的。
- en: For HTTP specifically, the original RFCs explicitly permit the browser to examine
    the payload for clues when the *Content-Type* value is not available. For other
    protocols, the same approach is usually followed, often as a natural consequence
    of the design of the underlying code.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTTP 而言，原始的 RFC 明确允许浏览器在 *Content-Type* 值不可用时检查有效负载以获取线索。对于其他协议，通常遵循相同的方法，这通常是底层代码设计的一个自然结果。
- en: The heuristics employed to determine the type of a document typically amount
    to checking for static signatures associated with several dozen known file formats
    (such as images and common plug-in-handled files). The response will also be scanned
    for known substrings in order to detect signatureless formats such as HTML (in
    which case, the browser will look for familiar tags—*<body>*, *<font>*, etc).
    In many browsers, noncontent signals, such as trailing *.html* or *.swf* strings
    in the path segment of the URL, are taken into account as well.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 用于确定文档类型的启发式方法通常涉及检查与几十种已知文件格式（如图像和常见的插件处理的文件）相关的静态签名。响应也会被扫描以检测无签名的格式，如 HTML（在这种情况下，浏览器将寻找熟悉的标签——*<body>*,
    *<font>*, 等）。在许多浏览器中，还会考虑非内容信号，例如 URL 路径段中尾随的 *.html* 或 *.swf* 字符串。
- en: 'The specifics of content-sniffing logic vary wildly from one browser to another
    and are not well documented or standardized. To illustrate, consider the handling
    of Adobe Flash (SWF) files served without *Content-Type*: In Opera, they are recognized
    unconditionally based on a content signature check; in Firefox and Safari, an
    explicit *.swf* suffix in the URL is required; and Internet Explorer and Chrome
    will not autorecognize SWF at all.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探逻辑的具体细节在不同浏览器之间差异很大，且没有很好地记录或标准化。为了说明这一点，考虑一下没有 *Content-Type* 的 Adobe Flash
    (SWF) 文件的处理：在 Opera 中，它们基于内容签名检查无条件地被识别；在 Firefox 和 Safari 中，URL 中需要显式的 *.swf*
    后缀；而 Internet Explorer 和 Chrome 完全不会自动识别 SWF。
- en: Rest assured, the SWF file format is not an exceptional case. For example, when
    dealing with HTML files, Chrome and Firefox will autodetect the document only
    if one of several predefined HTML tags appears at the very beginning of the file;
    while Firefox will be eager to “detect” HTML based solely on the presence of an
    *.html* extension in the URL, even if no recognizable markup is seen. Internet
    Explorer, on the other hand, will simply always default to HTML in the absence
    of *Content-Type*, and Opera will scan for known HTML tags within the first 1000
    bytes of the returned payload.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心，SWF 文件格式并不是一个特例。例如，当处理 HTML 文件时，Chrome 和 Firefox 只有在文件开头出现几个预定义的 HTML 标签之一时，才会自动检测文档；而
    Firefox 会根据 URL 中存在 *.html* 扩展名来“检测” HTML，即使没有看到可识别的标记。另一方面，Internet Explorer
    在没有 *Content-Type* 的情况下，将始终默认为 HTML，而 Opera 将在返回的有效负载的前 1000 个字节内扫描已知的 HTML 标签。
- en: The assumption behind all this madness is that the absence of *Content-Type*
    is an expression of an intentional wish by the publisher of the page—but that
    assumption is not always accurate and has caused a fair number of security bugs.
    That said, most web servers actively enforce the presence of a *Content-Type*
    header and will insert a default value if one is not explicitly generated by the
    server-side scripts that handle user requests. So perhaps there is no need to
    worry? Well, unfortunately, this is not where the story of content sniffing ends.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些混乱背后的假设是，*Content-Type* 的缺失是页面发布者有意表达的一种愿望——但这种假设并不总是准确的，并导致了相当数量的安全漏洞。话虽如此，大多数
    Web 服务器都会积极强制执行 *Content-Type* 标头的存在，并在服务器端脚本未明确生成时插入一个默认值。所以也许没有必要担心？不幸的是，内容嗅探的故事并没有在这里结束。
- en: Malformed MIME Types
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式错误的 MIME 类型
- en: The HTTP RFC permits content sniffing only in the absence of *Content-Type*
    data; the browser is openly prohibited from second-guessing the intent of the
    webmaster if the header is present in any shape or form. In practice, however,
    this advice is not taken seriously. The next small step taken off the cliff was
    the decision to engage heuristics if the server-returned MIME type was deemed
    invalid in any way.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP RFC 允许在没有 *Content-Type* 数据的情况下进行内容嗅探；如果头部以任何形式存在，浏览器被明确禁止猜测网站管理员的意图。然而，在实践中，这一建议并未被认真对待。从悬崖上迈出的下一步是决定，如果服务器返回的
    MIME 类型被认为以任何方式无效，则采用启发式方法。
- en: According to the RFC, the *Content-Type* header should consist of two slash-delimited
    alphanumeric tokens (*type/subtype*), potentially followed by other semicolon-delimited
    parameters. These tokens may contain any non-whitespace, seven-bit ASCII characters
    other than a couple of special “separators” (a generic set that includes characters
    such as “@”, “?”, and the slash itself). Most browsers attempt to enforce this
    syntax but do so inconsistently; the absence of a slash is seen almost universally
    as an invitation to content sniffing, and so is the inclusion of whitespaces and
    certain (but not all) control characters in the first portion of the identifier
    (the *type* token). On the other hand, the technically illegal use of high-bit
    characters or separators affects the validity of this field only in Opera.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 RFC，*Content-Type* 头部应由两个由斜杠分隔的字母数字标记 (*type/subtype*) 组成，可能后跟其他由分号分隔的参数。这些标记可以包含任何非空白、七位
    ASCII 字符，除了少数几个特殊的“分隔符”（一个包括诸如“@”、“?”和斜杠本身的通用集合）。大多数浏览器试图强制执行这种语法，但执行并不一致；几乎普遍认为，缺少斜杠是一种邀请进行内容嗅探的信号，同样，在标识符的第一部分（*type*
    标记）中包含空白和某些（但不是所有）控制字符也是如此。另一方面，技术上非法使用高位字符或分隔符只会影响 Opera 中该字段的合法性。
- en: The reasons for this design are difficult to understand, but to be fair, the
    security impact is still fairly limited. As far as web application developers
    are concerned, care must be exercised not to make typos in *Content-Type* values
    and not to allow users to specify arbitrary, user-controlled MIME types (merely
    validated against a blacklist of known bad options). These requirements may be
    unexpected, but usually they do not matter a lot. So, what are we ultimately getting
    at?
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的理由难以理解，但公平地说，其安全影响仍然相当有限。对于网络应用开发者来说，必须小心不要在 *Content-Type* 值中犯拼写错误，并且不允许用户指定任意、受用户控制的
    MIME 类型（仅通过已知不良选项的黑名单进行验证）。这些要求可能令人意外，但通常它们并不很重要。那么，我们最终想要达到的目的是什么呢？
- en: Special Content-Type Values
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊的 Content-Type 值
- en: The first clear signal that content sniffing was becoming truly dangerous was
    the handling of a seemingly unremarkable MIME type known as *application/octet-stream*.
    This specific value is not mentioned at all in the HTTP specification but is given
    a special (if vague) role deep in the bowels of RFC 2046:^([[221](pr03.html#ftn.CHP-13-FT-1)])
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 内容嗅探变得真正危险的第一明确信号是对一个看似不起眼的 MIME 类型 *application/octet-stream* 的处理。这个特定的值在 HTTP
    规范中根本未提及，但在 RFC 2046 的深处被赋予了特殊（尽管模糊）的角色：^([[221](pr03.html#ftn.CHP-13-FT-1)])
- en: The recommended action for an implementation that receives an *application/octet-stream*
    entity is to simply offer to put the data in a file, with any *Content-Transfer-Encoding*
    undone, or perhaps to use it as input to a user-specified process.
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于接收 *application/octet-stream* 实体的实现，建议简单地提供将数据放入文件的服务，取消任何 *Content-Transfer-Encoding*，或者可能将其用作用户指定的过程的输入。
- en: The original intent of this MIME type may not be crystal clear from the quoted
    passage alone, but it is commonly interpreted as a way for web servers to indicate
    that the returned file has no special meaning to the server and that it should
    not have one to the client. Consequently, most web servers default to *application/octet-stream*
    on all types of opaque, nonweb files, such as downloadable executables or archives,
    if no better *Content-Type* match can be found. However, in rare cases of administrator
    errors (for example, due to deletion of the essential *AddType* directives in
    Apache configuration files), web servers may also fall back to this MIME type
    on documents meant for in-browser consumption. This configuration error is, of
    course, very easy to detect and fix, but Microsoft, Opera, and Apple nevertheless
    chose to compensate for it. The browsers from these vendors eagerly engage in
    content sniffing whenever *application/octet-stream* is seen.^([[60](#ftn.CHP-13-FN-1)])
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 MIME 类型的原始意图仅从引用的段落中可能并不十分清晰，但它通常被解释为一种让 Web 服务器表明返回的文件对服务器没有特殊意义，并且对客户端也不应有特殊意义的方式。因此，大多数
    Web 服务器在没有找到更好的 *Content-Type* 匹配的情况下，默认将所有类型的非 Web 文件（如可下载的可执行文件或存档）设置为 *application/octet-stream*。然而，在管理员错误（例如，由于删除
    Apache 配置文件中的基本 *AddType* 指令）的罕见情况下，Web 服务器也可能回退到这种 MIME 类型来处理旨在浏览器内消费的文档。当然，这种配置错误很容易检测和修复，但微软、Opera
    和苹果公司仍然选择对此进行补偿。当看到 *application/octet-stream* 时，这些供应商的浏览器会积极地进行内容嗅探。[^([60](#ftn.CHP-13-FN-1))]
- en: This particular design decision has suddenly made it more difficult for web
    applications to host binary files on behalf of the user. For example, any code-hosting
    platform must exercise caution when returning executables or source archives as
    *application/octet-stream*, because there is a risk they may be misinterpreted
    as HTML and displayed inline. That’s a major issue for any software hosting or
    webmail system and for many other types of web apps. (It’s slightly safer for
    them to use any other generic-sounding MIME type, such as *application/binary*,
    because there is no special case for it in the browser code.)
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的设计决策突然使得 Web 应用程序代表用户托管二进制文件变得更加困难。例如，任何代码托管平台在返回可执行文件或源存档为 *application/octet-stream*
    时都必须谨慎，因为这些文件可能会被错误地解释为 HTML 并内联显示。这对任何软件托管或网络邮件系统以及许多其他类型的 Web 应用程序都是一个重大问题。（它们使用任何其他听起来通用的
    MIME 类型（如 *application/binary*）稍微安全一些，因为在浏览器代码中没有为其设置特殊案例。）
- en: 'In addition to the special treatment given to *application/octet-stream*, a
    second, far more damaging exception exists for *text/plain*. This decision, unique
    to Internet Explorer and Safari, traces back to RFC 2046\. In that document, *text/plain*
    is given a dual function: first, to transmit plaintext documents (ones that *“do
    not provide for or allow formatting commands, font attribute specifications, processing
    instructions, interpretation directives, or content markup”*) and, second, to
    provide a fallback value for any text-based documents not otherwise recognized
    by the sender.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对 *application/octet-stream* 的特殊处理外，还存在一个针对 *text/plain* 的第二个、破坏性更大的例外。这个决定是独一无二的，仅限于
    Internet Explorer 和 Safari。它追溯到 RFC 2046。在该文件中，*text/plain* 被赋予了双重功能：首先，用于传输纯文本文档（即那些“不提供或允许格式化命令、字体属性规范、处理指令、解释指令或内容标记”的文档）；其次，为任何发送者未识别的基于文本的文档提供回退值。
- en: The distinction between *application/octet-stream* and *text/plain* fallback
    made perfect sense for email messages, a topic that this RFC originally dealt
    with, but proved to be much less relevant to the Web. Nevertheless, some web servers
    adopted *text/plain* as the fallback value for certain types of responses (most
    notably, the output of CGI scripts).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*application/octet-stream* 和 *text/plain* 回退之间的区别对于电子邮件消息来说是有意义的，这是该 RFC 最初处理的主题，但对于
    Web 来说则显得不那么相关。尽管如此，一些 Web 服务器还是采用了 *text/plain* 作为某些类型响应的回退值（最显著的是 CGI 脚本的输出）。'
- en: 'The *text/plain* logic subsequently implemented in Internet Explorer and Safari
    in order to detect HTML in such a case is really bad news: It robs web developers
    of the ability to safely use this MIME type to generate user-specific plaintext
    documents and offers no alternatives. This has resulted in a substantial number
    of web application vulnerabilities, but to this day, Internet Explorer developers
    seem to have no regrets and have not changed the default behavior of their code.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 随后在Internet Explorer和Safari中实施的*text/plain*逻辑，以检测此类情况中的HTML，实际上是个坏消息：它剥夺了Web开发者使用此MIME类型生成特定用户纯文本文档的能力，并且没有提供替代方案。这导致了大量Web应用程序漏洞，但时至今日，Internet
    Explorer的开发者似乎没有遗憾，并且没有改变他们代码的默认行为。
- en: Safari developers, on the other hand, recognized and tried to mitigate the risk
    while keeping the functionality in place—but they failed to appreciate the complexity
    of the Web. The solution implemented in their browser is to rely on a secondary
    signal in addition to the presence of a plausible-looking HTML markup in the document
    body. The presence of an extension such as *.html* or *.xml* at the end of the
    URL path is interpreted by their implementation as a sign that content sniffing
    can be performed safely. After all, the owner of the site wouldn’t name the file
    this way otherwise, right?
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Safari的开发者认识到了风险，并试图在保持功能的同时减轻风险——但他们没有充分理解Web的复杂性。他们在浏览器中实施的解决方案是依赖除文档主体中看似合理的HTML标记之外的次要信号。URL路径末尾存在扩展名，如*.html*或*.xml*，被他们的实现解释为内容嗅探可以安全进行的信号。毕竟，网站的拥有者不会以这种方式命名文件，对吧？
- en: Alas, the signal they embraced is next to worthless. As it turns out, almost
    all web frameworks support at least one of several methods for encoding parameters
    in the path segment of the URL instead of in the more traditionally used query
    part. For example, in Apache, one such mechanism is known as PATH_INFO, and it
    happens to be enabled by default. By leveraging such a parameter-passing scheme,
    the attacker can usually append nonfunctional garbage to the path, thereby confusing
    the browser without affecting how the server will respond to the submitted request
    itself.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，他们所采用的信号几乎毫无价值。事实证明，几乎所有的Web框架都至少支持几种方法来在URL路径段中编码参数，而不是在更传统上使用的查询部分。例如，在Apache中，这种机制被称为PATH_INFO，并且默认情况下是启用的。通过利用这种参数传递方案，攻击者通常可以向路径中添加非功能性的垃圾数据，从而混淆浏览器，但不会影响服务器对提交请求本身的响应。
- en: 'To illustrate, the following two URLs will likely have the same effect for
    websites running on Apache or IIS:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下两个URL对于运行在Apache或IIS上的网站可能产生相同的效果：
- en: '[PRE22]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: and
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE23]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In some less-common web frameworks, the following approach may also work:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些不太常见的Web框架中，以下方法也可能有效：
- en: '[PRE24]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unrecognized Content Type
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别不到的内容类型
- en: Despite the evident trouble with *text/plain*, the engineers working on Internet
    Explorer decided to take their browser’s heuristics even further. Internet Explorer
    applies both content sniffing and extension matching^([[61](#ftn.CHP-13-FN-2)])
    not only to a handful of generic MIME types but also to any document type not
    immediately recognized by the browser. This broad category may include everything
    from JSON (*application/json*) to multimedia formats such as Ogg Vorbis (*audio/ogg*).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对*text/plain*存在明显的麻烦，但正在开发Internet Explorer的工程师们决定将他们的浏览器启发式方法进一步扩展。Internet
    Explorer不仅对少量通用MIME类型，而且对任何浏览器无法立即识别的文档类型都应用内容嗅探和扩展匹配^([[61](#ftn.CHP-13-FN-2)])。这个广泛的类别可能包括从JSON
    (*application/json*) 到多媒体格式，如Ogg Vorbis (*audio/ogg*)。
- en: Such a design is, naturally, problematic and causes serious problems when hosting
    any user-controlled document formats other than a small list of universally supported
    MIME types registered internally in the browser or when routed to a handful of
    commonly installed external applications.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的设计自然是存在问题的，当在浏览器内部注册的少量通用MIME类型之外，或者当路由到少量常见安装的外部应用程序时，托管任何用户控制的文档格式都会引起严重问题。
- en: 'Nor do the content-sniffing habits of Internet Explorer finally end there:
    The browser will also resort to payload inspection when dealing with internally
    recognized document formats that, for any reason, can’t be parsed cleanly. In
    Internet Explorer versions prior to 8, serving a user-supplied but nonvalidated
    file claiming to be an JPEG image can lead to the response being treated as HTML.
    And it gets even more hilarious: Even a subtle mistake, such as serving a valid
    GIF file with *Content-Type: image/jpeg*, triggers the same code path. Heck, several
    years ago, Internet Explorer even detected HTML on any valid, properly served
    PNG file. Thankfully, this logic has since been disabled—but the remaining quirks
    are still a minefield.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '而Internet Explorer的内容嗅探习惯并没有就此结束：当处理浏览器内部识别的文档格式时，如果由于任何原因无法干净地解析，浏览器也会求助于负载检查。在8.0之前的Internet
    Explorer版本中，提供用户提供的未经验证的文件，声称是JPEG图像，可能会导致响应被当作HTML处理。更有趣的是：即使是微小的错误，比如用*Content-Type:
    image/jpeg*提供有效的GIF文件，也会触发相同的代码路径。天哪，几年前，Internet Explorer甚至能在任何有效、正确提供的PNG文件上检测到HTML。幸运的是，这个逻辑已经被禁用——但剩下的怪癖仍然是一个雷区。'
- en: Note
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to fully appreciate the risk of content sniffing on valid images, note
    that it is not particularly difficult to construct images that validate correctly
    but that carry attacker-selected ASCII strings—such as HTML markup—in the raw
    image data. In fact, it is relatively easy to construct images that, when scrubbed,
    rescaled, and recompressed using a known, deterministic algorithm, will have a
    nearly arbitrary string appear out of the blue in the resulting binary stream.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分理解在有效图像上进行内容嗅探的风险，请注意，构建验证正确但携带攻击者选择的ASCII字符串（如HTML标记）的图像并不特别困难。实际上，相对容易构建这样的图像，当使用已知、确定性的算法进行清洗、重新缩放和重新压缩时，几乎任意的字符串会突然出现在生成的二进制流中。
- en: To its credit, in Internet Explorer 8 and beyond, Microsoft decided to disallow
    most types of gratuitous content sniffing on known MIME types in the *image/**
    category. It also disallowed HTML detection (but not XML detection) on image formats
    not recognized by the browser, such as *image/jp2* (JPEG2000).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 值得称赞的是，在Internet Explorer 8及更高版本中，微软决定禁止在已知的MIME类型中大多数类型的免费内容嗅探，特别是在*image/**类别中。它还禁止在浏览器不识别的图像格式上检测HTML（但不检测XML），例如*image/jp2*（JPEG2000）。
- en: This single tweak aside, Microsoft has proven rather unwilling to make meaningful
    changes to its content-sniffing logic, and its engineers have publicly defended
    the need to maintain compatibility with broken websites.^([[222](pr03.html#ftn.CHP-13-FT-2)])
    Microsoft probably wants to avoid the wrath of large institutional customers,
    many of whom rely on ancient and poorly designed intranet apps and depend on the
    quirks of the Internet Explorer-based monoculture on the client end.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个单一调整之外，微软证明并不愿意对其内容嗅探逻辑进行有意义的更改，其工程师公开捍卫了维护与损坏网站兼容性的必要性.^([[222](pr03.html#ftn.CHP-13-FT-2)])
    微软可能想要避免大型机构客户的愤怒，许多客户依赖古老且设计不佳的内部应用程序，并依赖于客户端基于Internet Explorer的单文化怪癖。
- en: 'In any case, due to the backlash that Internet Explorer faced over its *text/plain*
    handling logic, newer versions offer a partial workaround: an optional HTTP header,
    *X-Content-Type-Options: nosniff*, which allows website owners to opt out of most
    of the controversial content heuristics. The use of this header is highly recommended;
    unfortunately, the support for it has not been backported to versions 6 and 7
    of the browser and has only a limited support in other browsers. In other words,
    it cannot be depended on as a sole defense against content sniffing.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '无论如何，由于Internet Explorer在处理*text/plain*逻辑上遭遇的反弹，新版本提供了一种部分解决方案：一个可选的HTTP头，*X-Content-Type-Options:
    nosniff*，允许网站所有者选择退出大多数有争议的内容启发式方法。使用此头文件强烈推荐；不幸的是，它尚未回滚到浏览器的6.0和7.0版本，在其他浏览器中支持也有限。换句话说，不能将其作为对抗内容嗅探的唯一防御手段。'
- en: Note
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Food for thought: According to the data collected in a 2011 survey by SHODAN
    and Chris John Riley,^([[223](pr03.html#ftn.CHP-13-FT-3)]) only about 0.6 percent
    of the 10,000 most popular websites on the Internet used this header on a site-wide
    level.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 思考食物：根据SHODAN和Chris John Riley在2011年进行的一项调查收集的数据，^([[223](pr03.html#ftn.CHP-13-FT-3)])
    在互联网上最受欢迎的10,000个网站中，只有大约0.6%在网站范围内使用了这个标题。
- en: Defensive Uses of Content-Disposition
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容处置的防御性用途
- en: 'The *Content-Disposition* header, mentioned several times in [Part I](pt01.html
    "Part I. Anatomy of the Web") of this book, may be considered a defense against
    content sniffing in some use cases. The function of this header is not explained
    satisfactorily in the HTTP/1.1 specification. Instead, it is documented only in
    RFC 2183,^([[224](pr03.html#ftn.CHP-13-FT-4)]) where its role is explained only
    as it relates to mail applications:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第一部分](pt01.html "第一部分。网络解剖学")中多次提到的 *Content-Disposition* 头部，在某些用例中可能被视为防止内容嗅探的一种防御手段。HTTP/1.1
    规范中对这个头部功能的解释并不令人满意。相反，它仅在 RFC 2183 中进行了文档记录，^([[224](pr03.html#ftn.CHP-13-FT-4)])
    其中仅将其角色解释为与邮件应用相关：
- en: Bodyparts can be designated “attachment” to indicate that they are separate
    from the main body of the mail message, and that their display should not be automatic,
    but contingent upon some further action of the user. The MUA^([[62](#ftn.CHP-13-FN-3)])
    might instead present the user of a bitmap terminal with an iconic representation
    of the attachments, or, on character terminals, with a list of attachments from
    which the user could select for viewing or storage.
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以将 Bodyparts 标记为“附件”，以表明它们与邮件主体的主要部分是分开的，并且它们的显示不应是自动的，而应取决于用户的进一步操作。MUA^([[62](#ftn.CHP-13-FN-3)])
    可能会向位图终端用户展示附件的图标表示，或者在字符终端上，展示一个用户可以选择查看或存储的附件列表。
- en: 'The HTTP RFC acknowledges the use of *Content-Disposition: attachment* in the
    web domain but does not elaborate on its intended function. In practice, upon
    seeing this header during a normal document load, most browsers will display a
    file download dialog, usually with three buttons: “open,” “save,” and “cancel.”
    The browser will not attempt to interpret the document any further unless the
    “open” option is selected or the document is saved to disk and then opened manually.
    For the “save” option, an optional *filename* parameter included in the header
    is used to suggest the name of the download, too. If this field is absent, the
    filename will be derived from the notoriously unreliable URL path data.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP RFC 承认在 Web 域中使用 *Content-Disposition: attachment*，但没有详细说明其预期功能。在实践中，在正常文档加载期间看到这个头部时，大多数浏览器会显示一个文件下载对话框，通常有三个按钮：“打开”、“保存”和“取消”。除非选择“打开”选项或将文档保存到磁盘并手动打开，否则浏览器不会尝试进一步解释文档。对于“保存”选项，头部中包含的可选
    *filename* 参数用于建议下载的文件名。如果此字段不存在，则文件名将来自众所周知的不可靠的 URL 路径数据。'
- en: Because the header prevents most browsers from immediately interpreting and
    displaying the returned payload, it is particularly well suited for safely hosting
    opaque, downloadable files such as the aforementioned case of archives or executables.
    Furthermore, because it is ignored on type-specific subresource loads (such as
    *<img>* or *<script>*), it may also be employed to protect user-controlled JSON
    responses, images, and so on against content sniffing risks. (The reason why all
    implementations ignore *Content-Disposition* for these types of navigation is
    not particularly clear, but given the benefits, it’s best not to question the
    logic now.)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该头部阻止了大多数浏览器立即解释和显示返回的有效载荷，因此它特别适合安全托管不透明的、可下载的文件，例如上述存档或可执行文件的案例。此外，因为它在特定类型子资源加载（如
    *<img>* 或 *<script>*）中被忽略，因此它还可以用于保护用户控制的 JSON 响应、图像等免受内容嗅探风险。 (为什么所有实现都忽略这些类型导航的
    *Content-Disposition* 并不是特别清楚，但考虑到其好处，现在最好不质疑这种逻辑。)
- en: One example of a reasonably robust use of *Content-Disposition* and other HTTP
    headers to discourage content sniffing on a JSON response may be
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理稳健地使用 *Content-Disposition* 和其他 HTTP 头部来阻止 JSON 响应内容嗅探的例子可能
- en: '[PRE25]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The defensive use of *Content-Disposition* is highly recommended where possible,
    but it is important to recognize that the mechanism is neither mandated for all
    user agents nor well documented. In less popular browsers, such as Safari Mobile,
    the header may have no effect; in mainstream browsers, such as Internet Explorer
    6, Opera, and Safari, a series of *Content-Disposition* bugs have at one point
    or another rendered the header ineffective in attacker-controlled cases.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，强烈推荐使用 *Content-Disposition* 的防御性用途，但重要的是要认识到，该机制并非对所有用户代理都有强制要求，也没有得到很好的文档记录。在不太受欢迎的浏览器中，如
    Safari Mobile，该头部可能没有任何效果；在主流浏览器中，如 Internet Explorer 6、Opera 和 Safari，一系列 *Content-Disposition*
    缺陷在某个时刻或另一个时刻使头部在攻击者控制的案例中失效。
- en: 'Another problem with the reliance on *Content-Disposition* is that the user
    may still be inclined to click “open.” Casual users can’t be expected to be wary
    of viewing Flash applets or HTML documents just because a download prompt gets
    in the way. In most browsers, selecting “open” puts the document in a *file:*
    origin, which may be problematic on its own (the recent improvements in Chrome
    certainly help), and in Opera, the document will be displayed in the context of
    the originating domain. Arguably, Internet Explorer makes the best choice: HTML
    documents are placed in a special sandbox using a *mark-of-the-web* mechanism
    (outlined in more detail in [Chapter 15](ch15.html "Chapter 15. Extrinsic Site
    Privileges")), but even in that browser, Java or Flash applets will not benefit
    from this feature.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖 *Content-Disposition* 的另一个问题是，用户仍然可能倾向于点击“打开”。不能期望普通用户因为下载提示而警惕查看Flash小程序或HTML文档。在大多数浏览器中，选择“打开”会将文档置于
    *file:* 原因，这本身可能就存在问题（Chrome最近的改进确实有所帮助），而在Opera中，文档将在原始域的上下文中显示。可以说，Internet
    Explorer做出了最佳选择：HTML文档使用 *mark-of-the-web* 机制（在第15章中更详细地概述）放置在特殊沙盒中，但即使在那个浏览器中，Java或Flash小程序也不会从这一特性中受益。
- en: Content Directives on Subresources
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源的内容指令
- en: Most content-related HTTP headers, such as *Content-Type*, *Content-Disposition*,
    and *X-Content-Type-Options*, have largely no effect on type-specific subresource
    loads, such as *<img>*, *<script>*, or *<embed>*. In these cases, the embedding
    party has nearly complete control over how the response will be interpreted by
    the browser.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与内容相关的HTTP头，如 *Content-Type*、*Content-Disposition* 和 *X-Content-Type-Options*，对特定类型的子资源加载（如
    *<img>*, *<script>*, 或 *<embed>*)几乎没有影响。在这些情况下，嵌入方几乎完全控制浏览器如何解释响应。
- en: '*Content-Type* and *Content-Disposition* may also not be given much attention
    when handling requests initiated from within plug-in-executed code. For example,
    recall from [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic") that any
    *text/plain* or *text/csv* documents may be interpreted by Adobe Flash as security-sensitive
    *crossdomain.xml* policies unless an appropriate site-wide metapolicy is present
    in the root directory on the destination server. Whether you wish to call it “content
    sniffing” or just “content-type blindness,” the problem is still very real.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理从插件执行代码中发起的请求时，*Content-Type* 和 *Content-Disposition* 也可能不会引起太多关注。例如，回想一下[第9章](ch09.html
    "第9章。内容隔离逻辑")，任何 *text/plain* 或 *text/csv* 文档都可能被Adobe Flash解释为安全敏感的 *crossdomain.xml*
    策略，除非目标服务器根目录中存在适当的全局元策略。无论你是否称之为“内容嗅探”还是仅仅“内容类型盲”，这个问题仍然非常真实。
- en: Consequently, even when all previously discussed HTTP headers are used religiously,
    it is important to always consider the possibility that a third-party page may
    trick the browser into interpreting that page as one of several problematic document
    types; applets and applet-related content, PDFs, stylesheets, and scripts are
    usually of particular concern. To minimize the risk of mishaps, you should carefully
    constrain the structure and character set of any served payloads or use “sandbox”
    domains to isolate any document types that can’t be constrained particularly well.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使严格遵守之前讨论的所有HTTP头，始终考虑第三方页面可能欺骗浏览器将其解释为几种问题文档类型之一的可能性也很重要；小程序和小程序相关的内容、PDF、样式表和脚本通常是特别关注的对象。为了最大限度地减少意外事件的风险，您应该仔细限制任何提供的数据负载的结构和字符集，或者使用“沙盒”域来隔离那些无法很好地限制的文档类型。
- en: Downloaded Files and Other Non-HTTP Content
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载的文件和其他非HTTP内容
- en: The behavior of HTTP headers such as *Content-Type*, *Content-Disposition*,
    and *X-Content-Type-Options* may be convoluted and exception ridden, but at the
    very least, they add up to a reasonably consistent whole. Still, it is easy to
    forget that in many real-world cases, the metadata contained in these headers
    is simply not available—and in that case, all bets are off. For example, the handling
    of documents retrieved over *ftp:*, or saved to disk and opened over the *file:*
    protocol, is highly browser- and protocol-specific and often surprises even the
    most seasoned security experts.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头如 *Content-Type*、*Content-Disposition* 和 *X-Content-Type-Options* 的行为可能很复杂，并且充满例外，但至少它们加起来是一个相当一致的总体。然而，很容易忘记在许多实际情况下，这些头中包含的元数据根本不可用——在这种情况下，所有的赌注都取消了。例如，通过
    *ftp:* 获取的文档的处理，或者保存到磁盘并通过 *file:* 协议打开的文档，高度依赖于浏览器和协议，并且经常让经验最丰富的安全专家都感到惊讶。
- en: When opening local files, browsers usually give precedence to file extension
    data, and if the extension is one of the hardcoded values known to the browser,
    such as *.txt* or *.html*, most browsers will take this information at face value.
    Chrome is the exception; it will attempt to autodetect certain “passive” document
    types, such as JPEG, even inside *.txt* documents. (HTML, however, is strictly
    off-limits.)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开本地文件时，浏览器通常会优先考虑文件扩展名数据，如果扩展名是浏览器已知的一些硬编码值之一，例如 *.txt* 或 *.html*，大多数浏览器都会直接接受这些信息。Chrome
    是一个例外；它会尝试自动检测某些“被动”文档类型，例如 JPEG，即使在 *.txt* 文档内部也是如此。（然而，HTML 是严格禁止的。）
- en: When it comes to other extensions registered to external programs, the behavior
    is a bit less predictable. Internet Explorer will usually invoke the external
    application, but most other browsers will resort to content sniffing, behaving
    as though they loaded the document over HTTP with no *Content-Type* set. All browsers
    will also fall back to content sniffing if the extension is not known (say, *.foo*).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到注册到外部程序的其他扩展名时，行为会稍微难以预测。Internet Explorer 通常会调用外部应用程序，但大多数其他浏览器会求助于内容嗅探，表现得好像他们通过
    HTTP 加载了没有 *Content-Type* 设置的文档。所有浏览器在扩展名未知（例如，*.foo*）的情况下也会回退到内容嗅探。
- en: 'The heavy reliance on file extension data and content sniffing for *file:*
    documents creates an interesting contrast with the normal handling of Internet-originating
    resources. On the Web, *Content-Type* is by and large the authoritative descriptor
    of document type. File extension information is ignored most of the time, and
    it is perfectly legal to host a functional JPEG file at a location such as [http://fuzzybunnies.com/gotcha.txt](http://fuzzybunnies.com/gotcha.txt).
    But what happens when this document is downloaded to disk? Well, in such case,
    the effective meaning of the resource will unexpectedly change: When accessing
    it over the *file:* protocol, the browser may insist on rendering it as a text
    file, based strictly on the extension data.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件扩展名数据和内容嗅探的过度依赖与对来自互联网的资源正常处理形成了有趣的对比。在网络上，*Content-Type* 通常是文档类型的权威描述符。大多数时候，文件扩展名信息会被忽略，在诸如
    [http://fuzzybunnies.com/gotcha.txt](http://fuzzybunnies.com/gotcha.txt) 这样的位置托管一个功能性的
    JPEG 文件是完全合法的。但是，当这个文档下载到磁盘上时会发生什么呢？嗯，在这种情况下，资源的有效含义会意外地改变：当通过 *file:* 协议访问它时，浏览器可能会坚持将其渲染为文本文件，严格基于扩展名数据。
- en: 'The example above is fairly harmless, but other content promotion vectors,
    such as an image becoming an executable, may be more troubling. To that effect,
    Opera and Internet Explorer will attempt to modify the extension to match the
    MIME type for a handful of known *Content-Type* values. Other browsers do not
    offer this degree of protection, however, and may even be thoroughly confused
    by the situation they find themselves in. [Figure 13-1](ch13.html#prompt_displayed_by_firefox_when_saving
    "Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg
    document served with Content-Disposition: attachment. The “hello.exe” filename
    is derived by the browser from a nonfunctional PATH_INFO suffix appended by the
    attacker at the end of the URL. The prompt incorrectly claims that the .exe file
    is a “JPEG Image.” In fact, when saved to disk, it will be an executable.") captures
    Firefox in one such embarrassing moment.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '上述示例相对无害，但其他内容推广向量，如一个图像变成可执行文件，可能会更加令人担忧。为此，Opera 和 Internet Explorer 将尝试修改扩展名以匹配一些已知的
    *Content-Type* 值。然而，其他浏览器并不提供这种程度的保护，甚至可能会被他们所处的情境彻底搞混。[图 13-1](ch13.html#prompt_displayed_by_firefox_when_saving
    "图 13-1. Firefox 在保存带有 Content-Disposition: attachment 的 Content-Type: image/jpeg
    文档时显示的提示。浏览器从攻击者附加在 URL 末尾的非功能 PATH_INFO 后缀中推导出“hello.exe”文件名。提示错误地声称.exe 文件是“JPEG
    图像”。实际上，当保存到磁盘时，它将是一个可执行文件。") 捕获了 Firefox 在这样一个尴尬的时刻。'
- en: '![Prompt displayed by Firefox when saving a Content-Type: image/jpeg document
    served with Content-Disposition: attachment. The “hello.exe” filename is derived
    by the browser from a nonfunctional PATH_INFO suffix appended by the attacker
    at the end of the URL. The prompt incorrectly claims that the .exe file is a “JPEG
    Image.” In fact, when saved to disk, it will be an executable.](httpatomoreillycomsourcenostarchimages950033.png.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox 在保存带有 Content-Disposition: attachment 的 Content-Type: image/jpeg
    文档时显示的提示。浏览器从攻击者附加在 URL 末尾的非功能 PATH_INFO 后缀中推导出“hello.exe”文件名。提示错误地声称.exe 文件是“JPEG
    图像”。实际上，当保存到磁盘时，它将是一个可执行文件。](httpatomoreillycomsourcenostarchimages950033.png.jpg)'
- en: 'Figure 13-1. Prompt displayed by Firefox when saving a Content-Type: image/jpeg
    document served with Content-Disposition: attachment. The “hello.exe” filename
    is derived by the browser from a nonfunctional PATH_INFO suffix appended by the
    attacker at the end of the URL. The prompt incorrectly claims that the .exe file
    is a “JPEG Image.” In fact, when saved to disk, it will be an executable.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '图 13-1. Firefox 在保存带有 Content-Disposition: attachment 的 Content-Type: image/jpeg
    文档时显示的提示。浏览器从攻击者附加在 URL 末尾的非功能 PATH_INFO 后缀中提取“hello.exe”文件名。提示错误地声称 .exe 文件是“JPEG
    图像”。实际上，当保存到磁盘时，它将是一个可执行文件。'
- en: This problem underscores the importance of returning an explicit, harmless *filename*
    value whenever using a *Content-Disposition* attachment, to prevent the victim
    from being tricked into downloading a document format that the site owner never
    intended to host.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题强调了在使用 *Content-Disposition* 附件时返回一个明确的、无害的 *filename* 值的重要性，以防止受害者被诱骗下载网站所有者从未打算托管文档格式的文件。
- en: 'Given the complex logic used for *file:* URLs, the simplicity of *ftp:* handling
    may come as a shock. When accessing documents over FTP, most browsers pay no special
    attention to file extensions and will simply indulge in rampant content sniffing.
    One exception is Opera, where extension data still takes precedence. From the
    engineering point of view, the prevalent approach to FTP may seem logical: The
    protocol can be considered roughly equivalent to HTTP/0.9\. Nevertheless, the
    design also violates the principle of least astonishment. Server owners would
    not expect that by allowing users to upload *.txt* documents to an FTP site, they
    are automatically consenting to host active HTML content within their domain.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用于 *file:* URL 的复杂逻辑，*ftp:* 处理的简单性可能会让人感到惊讶。当通过 FTP 访问文档时，大多数浏览器不会对文件扩展名给予特殊关注，而会简单地纵容内容嗅探的泛滥。一个例外是
    Opera，在那里扩展数据仍然占据优先地位。从工程角度来看，FTP 的主流方法似乎是有逻辑的：该协议可以大致等同于 HTTP/0.9。然而，这种设计也违反了最小惊讶原则。服务器所有者不会期望通过允许用户将
    *.txt* 文档上传到 FTP 站点，他们就会自动同意在其域名内托管活动 HTML 内容。
- en: '* * *'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[60](#CHP-13-FN-1)]) In Internet Explorer, this implemented logic differs
    subtly from a scenario where no *Content-Type* is present. Instead of always assuming
    HTML, the browser will scan the first 256 bytes for popular HTML tags and other
    predefined content signatures. From the security standpoint, however, it’s not
    a very significant difference.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[60](#CHP-13-FN-1)]) 在 Internet Explorer 中，这种实现的逻辑与没有 *Content-Type* 的情况略有不同。浏览器不会总是假设
    HTML，而是会扫描前 256 字节以查找流行的 HTML 标签和其他预定义的内容签名。然而，从安全角度来看，这并不是一个很大的差异。
- en: ^([[61](#CHP-13-FN-2)]) Naturally, path-based extension matching is essentially
    worthless for the reasons discussed in the previous section; but in the case of
    Internet Explorer 6, it gets even worse. In this browser, the extension can appear
    in the query portion of the URL. Nothing stops the attacker from simply appending
    *?foo=bar.html* to the requested URL, effectively ensuring that this check is
    always satisfied.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[61](#CHP-13-FN-2)]) 自然地，基于路径的扩展名匹配对于前述原因来说基本上是毫无价值的；但在 Internet Explorer
    6 的情况下，问题变得更糟。在这个浏览器中，扩展名可以出现在 URL 的查询部分。攻击者可以简单地向请求的 URL 中附加 *?foo=bar.html*，从而有效地确保这个检查总是满足条件。
- en: ^([[62](#CHP-13-FN-3)]) MUA stands for “mail user agent,” that is, a client
    application used to retrieve, display, and compose mail messages.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[62](#CHP-13-FN-3)]) MUA 代表“邮件用户代理”，即用于检索、显示和编写邮件消息的客户端应用程序。
- en: Character Set Handling
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符集处理
- en: 'Document type detection is one of the more important pieces of the content-processing
    puzzle, but it is certainly not the only one. For all types of text-based files
    rendered in the browser, one more determination needs to be made: The appropriate
    character set transformation must be identified and applied to the input stream.
    The output encoding sought by the browser is typically UTF-8 or UTF-16; the input,
    on the other hand, is up to the author of the page.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 文档类型检测是内容处理谜题中更为重要的部分之一，但绝对不是唯一的部分。对于所有在浏览器中渲染的基于文本的文件，还需要做出一个额外的判断：必须确定并应用到输入流中的适当字符集转换。浏览器所寻求的输出编码通常是
    UTF-8 或 UTF-16；而输入，另一方面，取决于页面的作者。
- en: In the simplest scenario, the appropriate encoding method will be provided by
    the server in a *charset* parameter of the *Content-Type* header. In the case
    of HTML documents, the same information may also be conveyed to some extent through
    the *<meta>* directive. (The browser will attempt to speculatively extract and
    interpret this directive before actually parsing the document.)
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的场景中，适当的编码方法将由服务器在*Content-Type*头部的*charset*参数中提供。在HTML文档的情况下，相同的信息也可能在一定程度上通过*<meta>*指令传达。（浏览器将尝试在实际上解析文档之前推测性地提取和解释此指令。）
- en: 'Unfortunately, the dangerous qualities of certain character encodings, as well
    as the actions taken by the browser when the *charset* parameter is not present
    or is not recognized, once again make life a lot more interesting than the aforementioned
    simple rule would imply. To understand what can go wrong, we first need to recognize
    three special classes of character sets that may alter the semantics of HTML or
    XML documents:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，某些字符编码的危险特性，以及当*charset*参数不存在或未被识别时浏览器采取的行动，再次使得生活比上述简单规则所暗示的有趣得多。为了了解可能出错的情况，我们首先需要识别三种可能改变HTML或XML文档语义的特殊字符集类别：
- en: '**Character sets that permit noncanonical representations of standard 7-bit
    ASCII codes**. Such noncanonical sequences could be used to cleverly encode HTML
    syntax elements, such as angle brackets or quotes, in a manner that survives a
    simple server-side check. For example, the famously problematic UTF-7 encoding
    permits the “<” character to be encoded as a five-character sequence of “+ADw-”,
    a string that most server-side filters will happily permit as is. In a similar
    vein, UTF-8 specification formally prohibits, but technically permits, “<” to
    be represented by unnecessarily verbose 2- to 5-byte sequences, from 0xC0 0xBC
    to 0xFC 0x80 0x80 0x80 0x80 0xBC.^([[63](#ftn.CHP-13-FN-4)])'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**允许标准7位ASCII码的非规范表示的字符集**。这样的非规范序列可以巧妙地编码HTML语法元素，如尖括号或引号，以在简单的服务器端检查中存活。例如，臭名昭著的UTF-7编码允许“<”字符被编码为“+ADw-”这个五字符序列，大多数服务器端过滤器都会乐意允许它原样通过。在类似的情况下，UTF-8规范正式禁止，但技术上允许“<”通过不必要的冗长2到5字节序列来表示，从0xC0
    0xBC到0xFC 0x80 0x80 0x80 0x80 0xBC.^([[63](#ftn.CHP-13-FN-4)])'
- en: '**Variable length encodings that give special meaning to one or more bytes
    that follow a special prefix**. Such logic may result in legitimate HTML syntax
    elements being “consumed” as part of an unintentional multibyte literal. For example,
    the Shift JIS prefix code 0xE0 can cause the subsequent angle bracket or a quote
    to be consumed in Internet Explorer, Firefox, and Opera (but not in Chrome), possibly
    severely altering the meaning of the inline markup.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有特殊前缀并赋予其后一个或多个字节特殊意义的可变长度编码**。这种逻辑可能导致合法的HTML语法元素被“消耗”作为无意中多字节字面量的一部分。例如，Shift
    JIS前缀码0xE0可能导致后续的尖括号或引号在Internet Explorer、Firefox和Opera中被消耗（但在Chrome中不会），这可能会严重改变内联标记的含义。'
- en: 'The opposite problem may also occur: The server may be convinced that it is
    outputting a multibyte literal, but this literal may be rejected by the browser
    and interpreted as several individual characters. In EUC-KR, the 0x8E prefix is
    honored only if the subsequent character has an ASCII code of 0x41 or higher.
    Any less and it will not have the expected effect, but not all server-side implementations
    may notice.'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反过来也可能出现问题：服务器可能确信它正在输出多字节字面量，但这个字面量可能被浏览器拒绝，并解释为几个单独的字符。在EUC-KR中，0x8E前缀只有在后续字符的ASCII码为0x41或更高时才会得到尊重。如果更低，它将不会产生预期的效果，但并非所有的服务器端实现都会注意到。
- en: '**Encodings that are completely incompatible with 8-bit ASCII**. These cases
    will simply lead to a very different view of document structure between the client
    and the server. Common examples include UTF-16 or UTF-32.'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与8位ASCII完全不兼容的编码**。这些情况将导致客户端和服务器之间对文档结构的看法非常不同。常见例子包括UTF-16或UTF-32。'
- en: 'The bottom line is that unless the server has a perfect command of the character
    set it is generating and unless it is certain that the client will not apply an
    unexpected transformation to the payload, serious complications may arise. For
    example, consider a web application that removes angle brackets from the highlighted
    user-controlled string in the following piece of HTML:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，除非服务器对其生成的字符集有完美的控制，并且除非它确信客户端不会对有效载荷应用意外的转换，否则可能会出现严重的复杂性。例如，考虑一个Web应用程序，它会从以下HTML片段中删除高亮显示的用户可控字符串中的尖括号：
- en: '[PRE26]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If that document is interpreted as UTF-7 by the receiving party, the actual
    parsed markup will look as follows:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收方将该文档解释为 UTF-7，实际解析的标记将如下所示：
- en: '[PRE27]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A similar problem, this time related to byte consumption in Shift JIS encoding,
    is illustrated below. A multibyte prefix is permitted to consume a closing quote,
    and as a result, the associated HTML tag is not terminated as expected, enabling
    the attacker to inject an extra *onerror* handler into the markup:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似的问题，这次与 Shift JIS 编码的字节消耗有关，如下所示。允许多字节前缀消耗一个闭合引号，因此相关的 HTML 标签没有按预期终止，这使得攻击者能够向标记中注入额外的
    *onerror* 处理程序：
- en: '[PRE28]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is simply imperative to prevent character set autodetection for all text-based
    documents that contain any type of user-controlled data. Most browsers will engage
    in character set detection if the *charset* parameter is not found in the *Content-Type*
    header or in the *<meta>* tag. Some marked differences exist between the implementations
    (for example, only Internet Explorer is keen to detect UTF-7), but you should
    never assume that the outcome of character set sniffing will be safe.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含任何类型用户可控数据的所有基于文本的文档，防止字符集自动检测是至关重要的。大多数浏览器如果未在 *Content-Type* 报头或 *<meta>*
    标签中找到 *charset* 参数，将会进行字符集检测。实现之间存在一些明显的差异（例如，只有 Internet Explorer 倾向于检测 UTF-7），但您永远不应假设字符集嗅探的结果是安全的。
- en: Character set autodetection will also be attempted if the character set is not
    recognized or is mistyped; this problem is compounded by the fact that charset
    naming can be ambiguous and that web browsers are inconsistent in how much tolerance
    they have for common name variations. As a single data point, consider the fact
    that Internet Explorer recognizes both ISO-8859-2 and ISO8859-2 (with no dash
    after the ISO part) as valid character set identifiers in the *Content-Type* header
    but fails to recognize UTF8 as an alias for UTF-8\. The wrong choice can cause
    some serious pain.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符集未被识别或输入错误，也会尝试进行字符集自动检测；由于字符集命名可能具有歧义，以及网络浏览器在处理常见名称变化时的不一致性，这个问题变得更加复杂。作为一个数据点，考虑以下事实：Internet
    Explorer 识别 ISO-8859-2 和 ISO8859-2（ISO 部分后没有连字符）作为 *Content-Type* 报头中的有效字符集标识符，但无法识别
    UTF8 作为 UTF-8 的别名。错误的选择可能会造成一些严重的问题。
- en: Note
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Fun fact: The *X-Content-Type-Options* header has no effect on character-sniffing
    logic.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：*X-Content-Type-Options* 报头对字符嗅探逻辑没有影响。
- en: Byte Order Marks
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节顺序标记
- en: 'We are not done with character set detection just yet! Internet Explorer needs
    to be singled out for yet another dramatically misguided content-handling practice:
    the tendency to give precedence to the so-called *byte order mark (BOM)*, a sequence
    of bytes that can be placed at the beginning of a file to identify its encoding,
    over the explicitly provided *charset* data. When such a marker is detected in
    the input file, the declared character set is ignored.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成字符集检测！需要特别指出的是，Internet Explorer 还有一个明显错误的处理内容实践：倾向于优先考虑所谓的 *字节顺序标记 (BOM)*，这是一个可以放在文件开头的字节序列，用于标识其编码，而不是显式提供的
    *charset* 数据。当在输入文件中检测到这样的标记时，声明的字符集将被忽略。
- en: '[Table 13-1](ch13s02.html#common_byte_order_markers_open_parenthes "Table 13-1. Common
    Byte Order Markers (BOMs)") shows several common markers. Of these, the printable
    UTF-7 BOM is particularly sneaky.'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-1](ch13s02.html#common_byte_order_markers_open_parenthes "表 13-1. 常见字节顺序标记
    (BOMs)") 展示了几个常见的标记。在这些标记中，可打印的 UTF-7 BOM 特别狡猾。'
- en: Table 13-1. Common Byte Order Markers (BOMs)
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13-1. 常见字节顺序标记 (BOMs)
- en: '| Encoding name | Byte order mark sequence |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| 编码名称 | 字节顺序标记序列 |'
- en: '| --- | --- |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| UTF-7 | “+/v” followed by “8”, “9”, “+”, or “/” |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| UTF-7 | “+/v” 后跟 “8”，“9”，“+”，或 “/” |'
- en: '| UTF-8 | 0xEF 0xBB 0xBF |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| UTF-8 | 0xEF 0xBB 0xBF |'
- en: '| UTF-16 little endian | 0xFF 0xFE |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16 小端序 | 0xFF 0xFE |'
- en: '| UTF-16 big endian | 0xFE 0xFF |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| UTF-16 大端序 | 0xFE 0xFF |'
- en: '| UTF-32 little endian | 0xFF 0xFE 0x00 0x00 |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32 小端序 | 0xFF 0xFE 0x00 0x00 |'
- en: '| UTF-32 big endian | 0x00 0x00 0xFE 0xFF |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| UTF-32 大端序 | 0x00 0x00 0xFE 0xFF |'
- en: '| GB −18030 | 0x84 0x31 0x95 0x33 |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| GB −18030 | 0x84 0x31 0x95 0x33 |'
- en: Note
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Microsoft engineers acknowledge the problem with this design and, as of this
    writing, say that the logic may be revised, depending on the outcome of compatibility
    tests. If the problem is resolved by the time this book hits the shelves, kudos
    to them. Until then, allowing the attacker to control the first few bytes of an
    HTTP response that is not otherwise protected by *Content-Disposition* may be
    a bad idea—and other than padding the response, there is no way to work around
    this glitch.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 微软工程师承认这种设计的问题，并且截至本文撰写时，表示逻辑可能会根据兼容性测试的结果进行修订。如果问题在本书上架时得到解决，那么他们值得赞扬。在此之前，允许攻击者控制一个未由
    *Content-Disposition* 保护的 HTTP 响应的前几个字节可能是一个坏主意——除了填充响应之外，没有其他方法可以解决这个问题。
- en: Character Set Inheritance and Override
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集继承和覆盖
- en: Two additional, little-known mechanisms should be taken into account when evaluating
    the potential impact on character set handling strategies in contemporary web
    browsers. Both of these features may permit an attacker to force undesirable character
    encoding upon another page, without relying on character sniffing.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估当代网络浏览器中字符集处理策略的潜在影响时，应考虑两个额外的、鲜为人知的机制。这两个特性都可能允许攻击者强制对另一个页面使用不希望的字符编码，而无需依赖字符嗅探。
- en: The first apparatus in question, supported by all but Internet Explorer, is
    known as *character set inheritance*. Under this policy, any encoding defined
    for the top-level frame may be automatically applied to any framed documents that
    do not have their own, valid *charset* value set. Initially, such inheritance
    is extended to all framing scenarios, even across completely unrelated websites.
    However, when Stefan Esser, Abhishek Arya, and several other researchers demonstrated
    a number of plausible attacks that leveraged this feature to force UTF-7 parsing
    on unsuspecting targets, Firefox and WebKit developers decided to limit the behavior
    to same-origin frames. (Opera still permits cross-domain inheritance. Although
    it does not support UTF-7, other problematic encodings, such as Shift JIS, are
    fair game.)
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 有关的问题的第一个设备，除了 Internet Explorer 之外都得到支持，被称为 *字符集继承*。根据这项政策，为顶层框架定义的任何编码可以自动应用于任何没有设置自己的、有效的
    *charset* 值的框架文档。最初，这种继承扩展到所有框架场景，甚至跨越完全无关的网站。然而，当 Stefan Esser、Abhishek Arya
    和其他一些研究人员展示了一些利用此功能对不知情的目标强制 UTF-7 解析的合理攻击时，Firefox 和 WebKit 开发人员决定将这种行为限制在相同源框架。Opera
    仍然允许跨域继承。尽管它不支持 UTF-7，但其他有问题的编码，如 Shift JIS，也是公平的游戏。
- en: The other mechanism that deserves mention is the ability to manually override
    the currently used character set. This feature is available through the *View
    > Encoding* menu or similar in most browsers. Using this menu to change the character
    set causes the page and all its subframes (including cross-domain ones!) to be
    reparsed using the selected encoding, regardless of any *charset* directives encountered
    earlier for that content.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的另一个机制是手动覆盖当前使用的字符集。这个功能在大多数浏览器中的 *查看 > 编码* 菜单或类似菜单中可用。使用此菜单更改字符集会导致页面及其所有子框架（包括跨域的）使用所选编码重新解析，而不管之前遇到的内容的任何
    *charset* 指令。
- en: 'Because users may be easily duped into selecting an alternative encoding for
    an attacker-controlled page (simply in order to view it correctly), this design
    should make you somewhat uncomfortable. Casual users can’t be expected to realize
    that their election will also apply to hidden *<iframe>* tags and that such a
    seemingly innocuous action may enable cross-site scripting attacks against unrelated
    web properties. In fact, let’s be real: Most of them will not know—and should
    not have to know—what an *<iframe>* is.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户可能很容易被欺骗选择一个攻击者控制的页面的替代编码（只是为了正确查看），这种设计可能会让你感到有些不舒服。普通用户无法期望他们意识到他们的选择也将适用于隐藏的
    *<iframe>* 标签，并且这种看似无害的行为可能会使针对无关网站的网络脚本攻击成为可能。事实上，让我们现实一点：他们中的大多数甚至不知道——也不应该知道——*<iframe>*
    是什么。
- en: Markup-Controlled Charset on Subresources
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源上的标记控制字符集
- en: We are nearing the end of the epic journey through the web of content-handling
    quirks, but we are not quite done yet. Astute readers may recall that in [Type-Specific
    Content Inclusion](ch04s05.html#type-specific_content_inclusion "Type-Specific
    Content Inclusion") in [Frames](ch04s05.html#frames "Frames"), I mentioned that
    on certain types of subresources (namely, stylesheets and scripts), the embedding
    page can specify its own *charset* value in order to apply a specific transformation
    to the retrieved document, for example,
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束这段穿越内容处理怪癖网络的史诗之旅，但我们还没有完全结束。敏锐的读者可能会记得，在 [特定类型内容包含](ch04s05.html#type-specific_content_inclusion
    "特定类型内容包含") 中，我在 [框架](ch04s05.html#frames "框架") 一章中提到，对于某些类型的子资源（即样式表和脚本），嵌入页面可以指定自己的
    *charset* 值，以便对检索到的文档应用特定的转换，例如，
- en: '[PRE29]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This parameter is honored by all browsers except for Opera. Where it is supported,
    it typically does not take precedence over *charset* in *Content-Type*, unless
    that second parameter is missing or unrecognized. But to every rule, there is
    an exception, and all too often, the name of this exception is Internet Explorer
    6\. In that still-popular browser, the encoding specified by the markup overrides
    HTTP data.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Opera 外，所有浏览器都支持此参数。在它被支持的地方，它通常不会在 *Content-Type* 中的 *charset* 之前优先，除非第二个参数缺失或无法识别。但每条规则都有例外，而这个例外的名字往往是
    Internet Explorer 6。在这个仍然流行的浏览器中，标记指定的编码会覆盖 HTTP 数据。
- en: 'Does this behavior matter in practice? To fully grasp the consequences, let’s
    also quickly return to [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"),
    where we debated the topic of securing server-generated, user-specific, JSON-like
    code against cross-domain inclusion. One example of an application that needs
    such a defense is a searchable address book in a webmail application: The search
    term is provided in the URL, and a JavaScript serialization of the matching contacts
    is returned to the browser but must be shielded from inclusion on unrelated sites.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在实践中是否重要？为了完全理解后果，让我们也快速回到 [第 6 章](ch06.html "第 6 章。浏览器端脚本")，在那里我们讨论了如何保护服务器生成的、针对特定用户的、类似
    JSON 的代码免受跨域包含。需要这种防御的应用程序的一个例子是网络邮件应用程序中的可搜索地址簿：搜索词包含在 URL 中，匹配的联系人的 JavaScript
    序列化返回到浏览器，但必须防止其在无关网站上被包含。
- en: 'Now, let’s assume that the developer came up with a simple trick to prevent
    third-party web pages from loading this data through *<script src=...>*: A single
    “//” prefix is used to turn the entire response into a comment. Same-origin callers
    that use the *XMLHttpRequest* API can simply examine the response, strip the prefix,
    and pass the data to *eval(...)*—but remote callers, trying to abuse the *<script
    src=...>* syntax, will be out of luck.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设开发者想出了一个简单的技巧来防止第三方网页通过 *<script src=...>* 加载这些数据：使用单个“//”前缀将整个响应转换为注释。使用
    *XMLHttpRequest* API 的同源调用者可以简单地检查响应，去除前缀，然后将数据传递给 *eval(...)*——但尝试利用 *<script
    src=...>* 语法的外部调用者将不会成功。
- en: 'In this design, a request to */contact_search.php?q=smith* may yield the following
    response:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，对 */contact_search.php?q=smith* 的请求可能会产生以下响应：
- en: '[PRE30]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As long as the search term is properly escaped or filtered, this scheme appears
    safe. But when we realize that the attacker may force the response to be interpreted
    as UTF-7, the picture changes dramatically. A seemingly benign search term that,
    as far as the server is concerned, contains no illegal characters could still
    unexpectedly decode to
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 只要搜索词被正确转义或过滤，这个方案看起来是安全的。但当我们意识到攻击者可能迫使响应被解释为 UTF-7 时，情况发生了戏剧性的变化。一个看似无害的搜索词，从服务器的角度来看，不包含任何非法字符，仍然可能意外地解码为
- en: '[PRE31]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This response, when loaded via *<script src=... charset=utf-7>* inside the victim’s
    browser, gives the attacker access to a portion of the user’s address book.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过受害者的浏览器中的 *<script src=... charset=utf-7>* 加载此响应时，攻击者可以访问用户地址簿的一部分。
- en: 'This is not just a thought exercise: The “//” approach is fairly common on
    the Web, and Masato Kinugawa, a noted researcher, found several popular web applications
    affected by this bug. And a more contrived variant of the same attack is also
    possible against other execution-preventing prefixes, such as *while (1);*. In
    the end, the problems with cross-domain *charset* override on *<script>* tags
    is one of the reasons why in [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts"),
    we strongly recommend using a robust parser-stopping prefix to prevent the interpreter
    from ever looking at any attacker-controlled bits. Oh—and if you factor in the
    support for E4X, the picture becomes even more interesting,^([[225](pr03.html#ftn.CHP-13-FT-5)])
    but let’s leave it at that.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一个思维练习：“//” 方法在互联网上相当常见，知名研究员Masato Kinugawa发现几个流行的Web应用程序受到了这个漏洞的影响。同样，针对其他阻止执行的词法前缀（如
    *while (1);*）的攻击变种也是可能的。最终，跨域 *charset* 在 *<script>* 标签上的问题是我们强烈推荐在 [第6章](ch06.html
    "第6章。浏览器端脚本") 中使用强大的解析器停止前缀以防止解释器查看任何攻击者控制的位的原因之一。哦——如果考虑到对E4X的支持，情况变得更加有趣，^([[225](pr03.html#ftn.CHP-13-FT-5)])
    但让我们就到这里为止。
- en: Detection for Non-HTTP Files
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非HTTP文件的检测
- en: 'To wrap up this chapter, let’s look at the last missing detail: character set
    encoding detection for documents delivered over non-HTTP protocols. As can be
    expected, documents saved to disk and subsequently opened over the *file:* protocol,
    or loaded by other means where the usual *Content-Type* metadata is absent, will
    usually be subjected to character set detection logic. However, unlike with document
    determination heuristics, there is no substantial difference among all the possible
    delivery methods: In all cases, the sniffing behavior is roughly the same.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章内容，让我们看看最后一个缺失的细节：对于通过非HTTP协议传输的文档，进行字符集编码检测。正如预期的那样，保存到磁盘并随后通过 *file:*
    协议打开的文档，或者通过其他方式加载且通常的 *内容类型* 元数据缺失的文档，通常会受到字符集检测逻辑的影响。然而，与文档确定启发式方法不同，所有可能的传输方法之间没有实质性的差异：在所有情况下，嗅探行为大致相同。
- en: 'There is no clean and portable way to address this problem for all text-based
    documents, but for HTML specifically, the impact of character set sniffing can
    be mitigated by embedding a *<meta>* directive inside the document body:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有基于文本的文档，没有干净且可移植的方式来解决这个问题，但对于HTML来说，可以通过在文档体中嵌入 *<meta>* 指令来减轻字符集嗅探的影响：
- en: '[PRE32]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You should not ditch *Content-Type* in favor of this indicator. Unlike *<meta>*,
    the header works for non-HTML content, and it is easier to enforce and audit on
    a site-wide level. That said, documents that are likely to be saved to disk and
    that contain attacker-controlled tidbits will benefit from a redundant *<meta>*
    tag. (Just make sure that this value actually matches *Content-Type*.)
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该为了这个指标而放弃 *内容类型*。与 *<meta>* 不同，该标头适用于非HTML内容，并且在网站范围内更容易执行和审计。话虽如此，那些可能被保存到磁盘且包含攻击者控制信息的文档将受益于一个冗余的
    *<meta>* 标签。（只是确保这个值实际上与 *内容类型* 匹配。）
- en: Security Engineering Cheat Sheet
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: Good Security Practices for All Websites
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网站的优秀安全实践
- en: 'Instruct the web server to append the *X-Content-Options: nosniff* header to
    all HTTP responses.'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '指示Web服务器将 *X-Content-Options: nosniff* 标头添加到所有HTTP响应中。'
- en: Consult the cheat sheet in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic") to set up an appropriate */crossdomain.xml* meta-policy.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 咨询 [第9章](ch09.html "第9章。内容隔离逻辑") 中的速查表来设置适当的 */crossdomain.xml* 元策略。
- en: Configure the server to append default *charset* and *Content-Type* values on
    all responses that would otherwise not have one.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务器在所有其他响应中附加默认的 *字符集* 和 *内容类型* 值，否则这些响应将没有这些值。
- en: If you are not using path-based parameter passing (such as PATH_INFO), consider
    disabling this feature.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有使用基于路径的参数传递（例如 PATH_INFO），考虑禁用此功能。
- en: When Generating Documents with Partly Attacker-Controlled Contents
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成包含部分攻击者控制内容的文档时
- en: Always return an explicit, valid, well-known *Content-Type* value. Do not use
    *text/plain* or *application/octet-stream*.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是返回一个明确、有效、众所周知的 *内容类型* 值。不要使用 *text/plain* 或 *application/octet-stream*。
- en: For any text-based documents, return a explicit, valid, well-known *charset*
    value in the *Content-Type* header; UTF-8 is preferable to any other variable-width
    encodings. Do not assume that *application/xml+svg*, *text/csv*, and other non-HTML
    documents do not need a specified character set. For HTML, consider a redundant
    *<meta>* directive if it’s conceivable that the file may be downloaded by the
    user. Beware of typos—UTF8 is not a valid alias for UTF-8.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于任何基于文本的文档，在*Content-Type*头中返回一个明确、有效、众所周知的*charset*值；UTF-8比任何其他可变宽度编码更可取。不要假设*application/xml+svg*、*text/csv*和其他非HTML文档不需要指定字符集。对于HTML，如果文件可能被用户下载，考虑使用冗余的*<meta>*指令。注意拼写错误——UTF8不是UTF-8的有效别名。
- en: 'Use *Content-Disposition: attachment* and an appropriate, explicit *filename*
    value for responses that do not need to be viewed directly—including JSON data.'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '对于不需要直接查看的响应，包括JSON数据，使用*Content-Disposition: attachment*和适当的、明确的*filename*值。'
- en: Do not allow the user to control the first few bytes of the file. Constrain
    the response as much as possible. Do not pass through NULs, control characters,
    or high-bit values unless absolutely necessary.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要允许用户控制文件的前几个字节。尽可能约束响应。除非绝对必要，否则不要传递NULs、控制字符或高位值。
- en: When performing server-side encoding conversions, be sure that your converters
    reject all unexpected or invalid inputs (e.g., overlong UTF-8).
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行服务器端编码转换时，确保你的转换器拒绝所有意外或无效的输入（例如，过长的UTF-8）。
- en: When Hosting User-Generated Files
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 当托管用户生成文件时
- en: 'Consider using a sandbox domain if possible. If you intend to host unconstrained
    or unknown file formats, a sandbox domain is a necessity. Otherwise, at the very
    minimum, do the following:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，考虑使用沙盒域名。如果你打算托管不受限制或未知文件格式，沙盒域名是必需的。否则，至少要执行以下操作：
- en: 'Use *Content-Disposition: attachment* and an appropriate, explicit *filename*
    value that matches the *Content-Type* parameter.'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用*Content-Disposition: attachment*和与*Content-Type*参数匹配的适当、明确的*filename*值。'
- en: Carefully validate the input data and always use the appropriate, commonly recognized
    MIME type. Serving JPEG as *image/gif* may lead to trouble. Refrain from hosting
    MIME types that are unlikely to be supported by popular browsers.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细验证输入数据，并始终使用适当、公认的MIME类型。将JPEG作为*image/gif*提供可能会导致麻烦。避免托管不太可能被流行浏览器支持的MIME类型。
- en: 'Refrain from using *Content-Type: application/octet-stream* and use *application/binary*
    instead, especially for unknown document types. Refrain from returning *Content-Type:
    text/plain*. Do not permit user-specified *Content-Type* headers.'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '避免使用*Content-Type: application/octet-stream*，而应使用*application/binary*，特别是对于未知文档类型。避免返回*Content-Type:
    text/plain*。不允许用户指定的*Content-Type*头。'
- en: '* * *'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[63](#CHP-13-FN-4)]) Today, this problem is mitigated by most browsers:
    Their parsers now have additional checks to reject overlong UTF-8 encodings as
    a matter of principle. The same cannot be said of all possible server-side UTF-8
    libraries, however.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[63](#CHP-13-FN-4)]) 现在，这个问题被大多数浏览器缓解了：它们的解析器现在有额外的检查，以原则性地拒绝过长的UTF-8编码。然而，并非所有可能的UTF-8服务器端库都如此。
- en: Chapter 14. Dealing with Rogue Scripts
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。处理恶意脚本
- en: 'In the previous five chapters, we examined a fairly broad range of browser
    security mechanisms—and looking back at them, it is fair to say that almost all
    share a common goal: to stop rogue content from improperly interfering with any
    other, legitimate web pages displayed in a browser. This is an important pursuit
    but also a fairly narrow one; subverting the boundaries between unrelated websites
    is a large part of every attacker’s repertoire but certainly not the only trick
    in the book.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五章中，我们考察了相当广泛的浏览器安全机制——回顾这些内容，可以说它们几乎都有一个共同的目标：阻止恶意内容不当地干扰浏览器中显示的任何其他合法网页。这是一个重要的追求，但也是一个相当狭窄的追求；颠覆无关网站之间的边界是每个攻击者工具箱的一部分，但绝不是书中唯一的技巧。
- en: The other significant design-level security challenge that all browsers have
    to face is that attackers may abuse well-intentioned scripting capabilities in
    order to disrupt or impersonate third-party sites without actually interacting
    with the targeted content. For example, if JavaScript code controlled by an attacker
    is permitted to create arbitrary undecorated windows on a screen, the attacker
    may find that, rather than look for a way to inject a malicious payload into the
    content served at [fuzzybunnies.com](http://fuzzybunnies.com), it may be easier
    to just open a window with a believable replica of the address bar, thus convincing
    the user that the content displayed is from a trusted site.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 所有浏览器都必须面对的其他重大设计级安全挑战是，攻击者可能会滥用良好的脚本功能，以干扰或冒充第三方网站，而无需与目标内容实际交互。例如，如果允许攻击者控制的JavaScript代码在屏幕上创建任意未装饰的窗口，攻击者可能会发现，与其寻找将恶意有效载荷注入[fuzzybunnies.com](http://fuzzybunnies.com)上提供的内容的方法，不如直接打开一个带有可信地址栏复制品的窗口，从而让用户相信显示的内容来自受信任的网站。
- en: 'Unfortunately for victims, in the early days of the Web, no real attention
    was given to the susceptibility of JavaScript APIs to attacks meant to disrupt
    or confuse users, and, unlike cross-domain content isolation issues, this class
    of problems is still not taken very seriously. The situation is unlikely to change
    anytime soon: Vendor resources are stretched thin between addressing comparatively
    more serious implementation-level flaws in the notoriously buggy browser codebases
    and rolling out new, shiny security features that appease web application developers,
    users, and the mainstream press alike.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受害者来说，不幸的是，在互联网的早期，并没有真正关注到JavaScript API对旨在干扰或迷惑用户的攻击的易受攻击性，而且与跨域内容隔离问题不同，这类问题至今仍未受到足够的重视。这种情况不太可能在短期内改变：供应商资源在解决臭名昭著的浏览器代码库中相对更严重的实现级别缺陷和推出新的、光鲜的安全特性之间捉襟见肘，这些特性旨在安抚Web应用开发者、用户和主流媒体。
- en: Denial-of-Service Attacks
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务拒绝攻击
- en: The possibility of an attacker crashing a browser or otherwise rendering it
    inoperable is one of the most common, obvious, and least appreciated issues affecting
    the modern Web. In the era of gadgets and mashups, it can have unexpectedly unpleasant
    consequences, too.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者使浏览器崩溃或使其无法操作的可能性是影响现代Web最常见、最明显且最不受重视的问题之一。在设备和小拼贴的时代，它也可能产生意想不到的不愉快后果。
- en: 'The most prominent reason why most browsers are susceptible to *denial-of-service
    (DoS)* attacks is due simply to a lack of planning: Neither the underlying document
    formats nor the capabilities exposed through scripting languages were designed
    to have a sensible, constrained worst-case CPU or memory footprint. In other words,
    any sufficiently complex HTML file or an endless JavaScript loop could bring the
    underlying operating system to its knees. Worse, the attempts to mandate resource
    limits or to give users a way to resume control of a runaway browser following
    a visit to a rogue page meet with resistance. For example, the authors of many
    of the recently proposed HTML5 APIs provide no advice on preventing resource exhaustion
    attacks, nor do they even acknowledge this need, because they think that any limits
    imposed today will likely hinder the growth of the Web 5 or 10 years from now.
    Browser developers, in turn, refuse to take any action absent any standards-level
    guidance.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浏览器容易受到*服务拒绝（DoS）*攻击最突出的原因是缺乏规划：底层文档格式以及通过脚本语言暴露的能力都没有设计成具有合理的、受限制的最坏情况CPU或内存占用。换句话说，任何足够复杂的HTML文件或无休止的JavaScript循环都可能使底层操作系统瘫痪。更糟糕的是，试图强制实施资源限制或为用户提供在访问恶意页面后恢复对失控浏览器控制的方法的努力遭到了抵制。例如，许多最近提出的HTML5
    API的作者没有提供防止资源耗尽攻击的建议，甚至没有承认这种需求，因为他们认为今天实施的任何限制都可能阻碍5年或10年后的Web 5增长。浏览器开发者反过来拒绝采取任何行动，除非有标准级别的指导。
- en: 'A common utilitarian argument against any proposed DoS defenses is that they
    are pointless—that the browser is hopelessly easy to crash in a multitude of ways,
    so why take special measures to address a specific vector today? It’s hard to
    argue with this view, but it’s also important to note that it acts as a self-fulfilling
    prophecy: The steady increase in the number of DoS vectors is making it more and
    more unlikely that the situation will be comprehensively addressed any time soon.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何提议的拒绝服务（DoS）防御措施，常见的功利主义论点是它们毫无意义——浏览器以多种方式轻易崩溃，那么为什么还要采取特殊措施来应对今天的特定向量呢？虽然很难反驳这种观点，但也很重要的是要注意，它起到了自我实现的预言的作用：拒绝服务向量的数量持续增加，使得在不久的将来全面解决这种情况的可能性越来越小。
- en: Note
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be fair, the computational complexity of certain operations is not the only
    reason why browsers are easy to crash. Vendors are also constrained by the need
    to maintain a significant degree of synchronicity during page-rendering and script-execution
    steps (see [Chapter 6](ch06.html "Chapter 6. Browser-Side Scripts")). This design
    eliminates the need for website developers to write reentrant and thread-safe
    code and has substantial code complexity and security benefits. Unfortunately,
    it also makes it much easier for one document to lock up the entire browser, or
    at least a good portion thereof.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，某些操作的计算复杂性并不是浏览器容易崩溃的唯一原因。供应商还受到在页面渲染和脚本执行步骤中保持显著同步需求的限制（参见[第6章](ch06.html
    "第6章。浏览器端脚本")）。这种设计消除了网站开发者编写可重入和线程安全代码的需求，并具有大量的代码复杂性和安全优势。不幸的是，这也使得一个文档锁定整个浏览器，或者至少是其中很大一部分变得容易得多。
- en: Regardless of all these considerations, and even if browser vendors refuse to
    acknowledge DoS risks as a specific flaw, the impact of such attacks is difficult
    to ignore. For one, whenever a browser is brought down, there is a substantial
    risk of data loss (in the browser itself or in any applications indirectly affected
    by the attack). Also, on some social-networking sites, an attacker may be able
    to lock out the victim from the site simply by sharing a rogue gadget, or perhaps
    even a well-selected image, with the victim, preventing that person from ever
    using that service again.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 无论考虑上述所有因素，即使浏览器供应商拒绝承认DoS风险作为一个特定的缺陷，此类攻击的影响是难以忽视的。首先，每当浏览器崩溃时，都会存在数据丢失的重大风险（在浏览器本身或任何间接受到攻击影响的应用程序中）。此外，在某些社交网站上，攻击者可能只需与受害者分享一个恶意的小工具，或者甚至是一个精心挑选的图像，就可以使受害者无法再使用该服务。
- en: 'Some of the common tricks used to take a browser out of service include loading
    complex XHTML or SVG documents, opening a very large number of windows, running
    an endless JavaScript loop that allocates memory, queuing a significant number
    of *postMessage(...)* calls, and so on. While these examples are implementation-specific,
    every browser offers a fair number of ways to achieve this goal. Even in Chrome,
    which uses separate renderer processes to isolate unrelated pages, it’s not difficult
    to bring down the entire browser: The top-level process mediates a variety of
    script-accessible and sometimes memory- or CPU-intensive tasks.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的使浏览器失效的技巧包括加载复杂的XHTML或SVG文档，打开非常多的窗口，运行一个无休止的分配内存的JavaScript循环，排队大量*postMessage(...)*调用，等等。虽然这些例子是特定实现的，但每个浏览器都提供了相当多的方法来实现这一目标。即使在Chrome浏览器中，它使用单独的渲染进程来隔离无关的页面，也不是很难使整个浏览器崩溃：顶级进程协调各种脚本可访问的以及有时是内存或CPU密集型任务。
- en: Given the above, it’s no surprise that despite generally dismissive attitudes,
    the major browsers nevertheless implement several DoS countermeasures. They do
    not add up to a coherent strategy, and have they have been rolled out only in
    response to the widespread abuse of specific APIs or to mitigate nonmalicious
    but common programming errors. Nevertheless, let’s look at them briefly.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述情况，尽管普遍持怀疑态度，但主要浏览器仍然实施了几个DoS防御措施。它们并不构成一个连贯的策略，并且它们只针对特定API的广泛滥用或减轻非恶意但常见的编程错误而推出。尽管如此，我们还是简要地看看它们。
- en: Execution Time and Memory Use Restrictions
  id: totrans-677
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行时间和内存使用限制
- en: 'Because of the aforementioned need to enforce a degree of synchronicity for
    many types of JavaScript operations, most browser vendors err on the side of caution
    and execute scripts synchronously with most of the remaining browser code. This
    design has an obvious downside: A good portion of the browser may become completely
    unresponsive as the JavaScript engine is, say, trying to evaluate a bogus *while
    (1)* loop. In Opera and Chrome, the top-level user interface will still be largely
    responsive, if sluggish, but in most other browsers, it won’t even be possible
    to close the browser window using the normal UI.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要强制执行许多类型 JavaScript 操作的同步性，大多数浏览器厂商都偏向于谨慎，并将脚本与大多数剩余的浏览器代码同步执行。这种设计有一个明显的缺点：当
    JavaScript 引擎尝试评估一个无效的 *while (1)* 循环时，浏览器的大部分功能可能会完全无法响应。在 Opera 和 Chrome 中，顶级用户界面仍然可以保持大部分响应性，尽管可能有些缓慢，但在大多数其他浏览器中，甚至无法使用正常
    UI 关闭浏览器窗口。
- en: Because endless loops are fairly easy to create by accident, in order to aid
    developers, Internet Explorer, Firefox, Chrome, and Safari enforce a modest time
    limit on any continuously or nearly continuously executing scripts. If the script
    is making the browser unresponsive for longer than a couple of seconds, the user
    will be shown a dialog and given the option to abort execution. Picking this option
    will have a result similar to encountering an unhandled exception, that is, of
    abandoning the current execution flow.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无限循环很容易意外创建，为了帮助开发者，Internet Explorer、Firefox、Chrome 和 Safari 对任何持续或几乎持续执行的脚本实施了一个适度的时间限制。如果脚本使浏览器在几秒钟内无法响应，用户将看到一个对话框，并可以选择终止执行。选择此选项的结果类似于遇到未处理的异常，即放弃当前的执行流程。
- en: 'Regrettably, such a limit is not a particularly robust defense against malicious
    scripts. For example, regardless of the user’s choice, it is still possible to
    resume execution through timers or event handlers, and it’s easy to avoid triggering
    the prompt in the first place by periodically returning the CPU briefly to an
    idle state in order to reset the counter. Too, as noted previously, there are
    ways to hog CPU resources without resorting to busy loops: Rendering complex XHTML,
    SVG, or XSLT documents can be just as disruptive and is not subject to any checks.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这样的限制并不是针对恶意脚本的特别有效的防御措施。例如，无论用户的选择如何，仍然可以通过计时器或事件处理程序恢复执行，并且通过定期将 CPU 短暂返回空闲状态以重置计数器，很容易避免触发提示。此外，正如之前所述，有方法可以占用
    CPU 资源而不必使用忙循环：渲染复杂的 XHTML、SVG 或 XSLT 文档可能会同样破坏性，并且不受任何检查。
- en: Execution time aside, there have been attempts to control the memory footprint
    of executed scripts. The size of the call stack is limited to a browser-specific
    value between 500 and 65535, and attempting a deeper recursion will result in
    an unconditional stop. Script heap size, on the other hand, is typically not restricted
    in a meaningful way; pages can allocate and use up gigabytes of memory. In fact,
    most of the previously implemented restrictions (such as the 16MB cap in Internet
    Explorer 6) have been removed in more recent releases.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行时间之外，还尝试控制执行脚本的内存占用。调用栈的大小限制在 500 到 65535 之间的浏览器特定值，尝试更深的递归将导致无条件停止。另一方面，脚本堆的大小通常没有以有意义的方式进行限制；页面可以分配和使用数
    GB 的内存。实际上，之前实施的大多数限制（如 Internet Explorer 6 中的 16MB 限制）在最近的版本中已被移除。
- en: Connection Limits
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接限制
- en: In many web applications, each web page consists not only of the proper HTML
    document retrieved from the URL visible in the address bar but also as many as
    several dozen other, separately loaded subresources, such as images, stylesheets,
    and scripts. Because requesting all of these elements through individually established
    HTTP connections can be slow, the reader may recall from [Chapter 3](ch03.html
    "Chapter 3. Hypertext Transfer Protocol") that the protocol has been extended
    to offer keep-alive sessions and request pipelining. But even with these improvements,
    one stubborn problem remains. The inherent limitation of the protocol is that
    the server must always send responses in the same order that it received the requests,
    so if any of the subresources (no matter how inconsequential) takes a bit longer
    to generate, the loading of all subsequent ones will be delayed.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多网络应用中，每个网页不仅包括从地址栏中可见的URL检索到的正确HTML文档，还包括多达几十个其他单独加载的子资源，例如图片、样式表和脚本。由于通过单独建立的HTTP连接请求所有这些元素可能会很慢，读者可能还记得从[第3章](ch03.html
    "第3章. 超文本传输协议")中了解到，该协议已被扩展以提供持久连接和请求管道化。但即使有了这些改进，仍然存在一个顽固的问题。协议的固有局限性在于服务器必须始终以接收请求的相同顺序发送响应，因此如果任何子资源（无论多么微不足道）生成时间稍长，所有后续资源的加载都将被延迟。
- en: To work around this problem, and to optimize performance when keep-alive requests
    or pipelining can’t be used, all browsers permit the opening of several simultaneous
    HTTP connections to the destination server. This way, the browser can issue multiple
    requests in parallel.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，并在无法使用持久连接请求或管道化时优化性能，所有浏览器都允许同时打开到目标服务器的几个HTTP连接。这样，浏览器可以并行发出多个请求。
- en: Unfortunately, the parallel connection design can be expensive for the destination
    website, especially if the server relies on the traditional *fork()*-based connection-handling
    architecture.^([[64](#ftn.CHP-14-FN-1)]) Therefore, in order to limit the risk
    of accidentally or intentionally launching a distributed DoS attack, the number
    of parallel connections needs to be limited to a modest per-host value, typically
    between 4 and 16\. Furthermore, to prevent attackers from overloading the browser
    itself (or affecting the performance of the nearby networking equipment), the
    total number of simultaneous connections to all destinations is also constrained
    to a low multiple of the per-host cap.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并行连接设计对目标网站来说可能代价高昂，特别是如果服务器依赖于传统的基于*fork()*的连接处理架构。[^([64](#ftn.CHP-14-FN-1))].
    因此，为了限制意外或故意发起分布式DoS攻击的风险，需要将并行连接的数量限制为每个主机的适度值，通常在4到16之间。此外，为了防止攻击者过载浏览器本身（或影响附近网络设备的性能），到所有目标的总并发连接数也受到限制，通常为每个主机上限的低倍数。
- en: Note
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In many implementations, the per-host connection limit is enforced by looking
    at DNS labels, not at IP addresses. Therefore, an attacker may still be able to
    point several bogus DNS entries in his own domains to any unrelated target IP
    and circumvent the first restriction. The global connection limit will be still
    in effect, though.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实现中，每个主机的连接限制是通过查看DNS标签而不是IP地址来强制执行的。因此，攻击者仍然可以将他自己的域中的几个虚假DNS条目指向任何无关的目标IP，从而绕过第一个限制。尽管如此，全局连接限制仍然有效。
- en: Although the number of concurrent HTTP sessions is limited, there are no practical
    restrictions on how long an active session may be kept alive (that is, as long
    as no kernel-level TCP/IP timeouts are encountered). This design may make it possible
    for attackers to simply exhaust the global connection limit by talking to a couple
    of intentionally slow destinations, preventing the user from doing anything useful
    in the meantime.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管并发HTTP会话的数量有限，但没有任何实际限制可以保持一个活跃会话的持续时间（也就是说，只要没有遇到内核级别的TCP/IP超时）。这种设计可能使得攻击者可以通过与几个故意缓慢的目标进行通信来简单地耗尽全局连接限制，从而阻止用户在此期间进行任何有用的操作。
- en: Pop-Up Filtering
  id: totrans-689
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹出窗口过滤
- en: 'The *window.open(...)* and *window.showModalDialog(...)*^([[65](#ftn.CHP-14-FN-2)])
    APIs permit web pages to create new browser windows, pointing them to any otherwise
    permitted URLs. In both cases, the browser may be instructed not to show certain
    window decorations for the newly loaded document or to position the window on
    the screen in a specific way. A simple use of *window.open(...)* might look like
    this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '*window.open(...)*和*window.showModalDialog(...)*API允许网页创建新的浏览器窗口，并将它们指向任何其他允许的URL。在这两种情况下，浏览器可以指示不要显示新加载文档的某些窗口装饰，或将窗口在屏幕上以特定方式定位。*window.open(...)*的简单使用可能看起来像这样：'
- en: '[PRE33]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In addition to these two JavaScript methods, new windows may also be opened
    indirectly by programatically interacting with certain HTML elements. For example,
    it is possible to call the *click()* method on an HTML link or to invoke the *submit()*
    method on a form. If the relevant markup includes a *target* parameter, the resulting
    navigation will take place in a new window of a specified name.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两种JavaScript方法之外，新窗口也可能通过程序性地与某些HTML元素交互而间接打开。例如，可以在HTML链接上调用*click()*方法，或者在表单上调用*submit()*方法。如果相关的标记包括*target*参数，则结果导航将在指定名称的新窗口中进行。
- en: As could be expected, the ability for random web pages to open new browser windows
    soon proved to be problematic. In the late 1990s, many players in the then-young
    online advertising industry decided they needed to attract attention to their
    ads at any cost, even at the expense of profoundly annoying and alienating their
    audiences. Automatically spawning windows solely to show a flashy advertisement
    seemed like a great way to do business and make new friends.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，随机网页打开新浏览器窗口的能力很快证明是问题。在20世纪90年代末，当时年轻的在线广告行业的许多参与者决定他们需要不惜一切代价吸引人们对他们广告的注意，甚至以深深烦恼和疏远他们的受众为代价。仅为了展示一个闪亮的广告而自动打开窗口似乎是一种很好的商业方式，也是结交新朋友的好方法。
- en: 'Pop-up and pop-under^([[66](#ftn.CHP-14-FN-3)]) advertisements have quickly
    emerged as one of the best-known and most reviled aspects of the Web. For good
    reason, too: Especially with pop-unders, it would not be unusual to amass a dozen
    of them after two to three hours of casual browsing.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 弹窗和弹出下文广告迅速成为互联网上最知名和最遭人厌恶的方面之一。原因也很充分：特别是对于弹出下文广告，在两到三小时的随意浏览后，积累一打这样的广告并不罕见。
- en: 'Due to widespread complaints, browser vendors stepped in and implemented a
    simple restriction: Spurious attempts by non-whitelisted pages to create new windows
    would be silently ignored.^([[67](#ftn.CHP-14-FN-4)]) Exceptions were made for
    attempts made immediately after a mouse click or a similar user action. For example,
    in the case of JavaScript, the ability to call *window.open(...)* would be granted
    to code executed in response to an *onclick* event and revoked shortly thereafter.
    (In Internet Explorer and WebKit, this permission expires the moment the event
    handler is exited. Other browsers may recognize a short grace period of one second
    or so.)'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 由于普遍的投诉，浏览器厂商介入并实施了一个简单的限制：非白名单页面创建新窗口的虚假尝试将被默默地忽略。对于在鼠标点击或类似用户操作后立即进行的尝试，则做出了例外。例如，在JavaScript的情况下，对响应*onclick*事件的代码调用*window.open(...)*的能力将被授予，并在之后不久撤销。在Internet
    Explorer和WebKit中，这种权限在事件处理程序退出时立即过期。其他浏览器可能认识到大约一秒钟的短暂宽限期。）
- en: 'The pop-up blocking feature initially curtailed pop-up advertising but, ultimately,
    proved to be fairly ineffective: Many websites would simply wait for the user
    to click anywhere on the page (in order to follow a link or even scroll the document)
    and spawn new windows in response. Others simply moved on to even more disruptive
    practices such as interstitials—full-page advertisements you need to click through
    to get to the content you actually want to read.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 弹窗阻止功能最初限制了弹窗广告，但最终证明效果相当有限：许多网站会简单地等待用户在页面上点击任何位置（为了跟随链接或甚至滚动文档）并相应地打开新窗口。其他网站则转向了更具破坏性的做法，例如插页式广告——你需要点击才能进入你真正想要阅读的内容的整页广告。
- en: 'The advertising arms race aside, the war on *window.open(...)* is also interesting
    from the DoS perspective. Creating hundreds of thousands of windows, thereby exhausting
    OS-enforced limits on the number of UI handles, is a sure way to crash the browser
    and to disrupt other applications as well. Any mechanism that limits this capability
    would be, at least in theory, a valuable defense. No such luck: Unbelievably,
    only Internet Explorer and Chrome sensibly limit the actual number of times *window.open(...)*
    can be called in response to a single click. In other browsers, once the temporary
    permission to open windows is granted, the attacker can go completely nuts and
    open as many windows as she desires.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 除了广告军备竞赛之外，对*window.open(...)*的战争从拒绝服务（DoS）的角度来看也很有趣。创建数十万个窗口，从而耗尽操作系统对UI句柄数量的限制，是导致浏览器崩溃和干扰其他应用程序的可靠方法。任何限制这种能力的机制，至少在理论上，都是一种有价值的防御。不幸的是，没有这样的运气：令人难以置信的是，只有Internet
    Explorer和Chrome合理地限制了响应单个点击时*window.open(...)*可以调用的实际次数。在其他浏览器中，一旦授予打开窗口的临时权限，攻击者就可以完全失控，打开她想要的任意数量的窗口。
- en: Dialog Use Restrictions
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对话框使用限制
- en: Window-related woes aside, all web-originating scripts can open certain browser-
    or OS-handled dialogs. The usefulness of these dialogs to modern web applications
    is minimal, but they still constitute another interesting part of the browser
    security landscape. Dialog-initiating APIs include *window.alert(...)*, used to
    display simple text messages; *window.prompt(...)* and *window.confirm(...)*,
    used to request basic user input; and *window.print(...)*, which brings up the
    OS-level printing dialog. A couple of obscure vendor extensions, such as Mozilla’s
    *window.sidebar.addPanel(...)* and *window.sidebar.addSearchEngine(...)* (to create
    bookmarks and register new search providers, respectively), are also on this list.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与窗口相关的问题之外，所有源自网页的脚本都可以打开某些由浏览器或操作系统处理的对话框。这些对话框对现代网络应用的有用性很小，但它们仍然是浏览器安全景观中另一个有趣的部分。启动对话框的API包括*window.alert(...)*，用于显示简单的文本消息；*window.prompt(...)*和*window.confirm(...)*，用于请求基本的用户输入；以及*window.print(...)*，它将弹出操作系统级别的打印对话框。一些鲜为人知的供应商扩展，例如Mozilla的*window.sidebar.addPanel(...)*和*window.sidebar.addSearchEngine(...)*（分别用于创建书签和注册新的搜索提供商），也列在这个列表中。
- en: The aforementioned JavaScript methods aside, several types of dialogs can be
    spawned indirectly. For example, it is possible to invoke the *click()* method
    on a file upload button or to navigate to a downloadable file, which usually brings
    up the OS-supplied file selection dialog. Navigating to a URL that requires HTTP
    authentication will also typically bring up a browser-level prompt.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述JavaScript方法之外，还可以间接生成几种类型的对话框。例如，可以在文件上传按钮上调用*click()*方法或导航到可下载的文件，这通常会导致操作系统提供的文件选择对话框。导航到需要HTTP身份验证的URL通常也会弹出浏览器级别的提示。
- en: 'So, what makes dialogs so interesting? The challenge with these prompts is
    quite different from that of programmatically created windows. Unlike the largely
    asynchronous *window.open(...)* API, dialogs pause the execution of JavaScript
    and defer many other actions (such as navigation or event delivery), effectively
    preventing dialogs from being created in large numbers to exhaust resources and
    crash the application. But their modal behavior is also their curse: They prevent
    any interaction with some portion of the browser until the user dismisses the
    dialog itself.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么使得对话框如此有趣呢？与这些提示相关的挑战与程序化创建的窗口的挑战相当不同。与主要异步的*window.open(...)* API不同，对话框会暂停JavaScript的执行并推迟许多其他操作（如导航或事件传递），有效地防止大量创建对话框以耗尽资源并导致应用程序崩溃。但它们的模态行为也是它们的诅咒：它们阻止用户与浏览器的一部分进行任何交互，直到用户关闭对话框本身。
- en: 'This creates an interesting loophole. If a new dialog is opened immediately
    after the old one is closed, the victim may be locked out of a vital portion of
    the browser UI, often even losing the ability to close the window or navigate
    away from the offending page. Malware authors sometimes abuse that quirk to force
    casual, panicked users to perform a dangerous action (such as downloading and
    executing an untrusted executable) just to be permitted to continue their work:
    Making any other choice in the script-initiated security prompt will only make
    the same dialog reappear over and over again.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这创造了一个有趣的漏洞。如果在关闭旧对话框后立即打开新对话框，受害者可能会被锁在浏览器UI的关键部分之外，甚至可能失去关闭窗口或从受影响的页面导航的能力。恶意软件作者有时会利用这个特性，强迫普通、恐慌的用户执行危险的操作（例如下载并执行不可信的可执行文件），以便允许他们继续工作：在脚本启动的安全提示中做出任何其他选择，只会让相同的对话框反复出现。
- en: Probably because of this malware-related tangent, browser vendors have begun
    experimenting with less disruptive prompting methods. In Chrome, for example,
    some of the most common modal dialogs have a checkbox that allows the user to
    suppress future attempts by the page to use the offending API (until the next
    reload, that is). In Opera, it is possible to stop the execution of scripts on
    the page. And in both Opera and recent versions of Firefox, many common dialogs
    are modal only in relation to the document-controlled area of the window, still
    allowing the tab to be closed or a different URL to be entered in the address
    bar. Nevertheless, the coverage of such improvements is limited.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 可能正是因为这个与恶意软件相关的旁路，浏览器厂商已经开始尝试使用不那么干扰的提示方法。例如，在Chrome浏览器中，一些最常见的模态对话框都有一个复选框，允许用户抑制页面未来尝试使用有问题的API（直到下一次重新加载为止）。在Opera浏览器中，可以停止页面上脚本的执行。在Opera和Firefox的最新版本中，许多常见的对话框仅在文档控制的窗口区域是模态的，仍然允许关闭标签页或在地址栏中输入不同的URL。然而，这些改进的覆盖范围有限。
- en: '![Firefox generated a profoundly confusing and vague prompt following the execution
    of an onbeforeunload handler on a web page. The handler gives page authors a chance
    to explain the consequences of navigating away from their page (such as losing
    any unsaved data) and requests a final decision from the user.For usability reasons,
    random pages on the Internet are no longer permitted to abort pending navigation
    by means other than this specific onbeforeunload dialog. (Surprisingly, the by-design
    ability to trap the user on a rogue page forever and cancel any navigation attempts
    wasn’t received well.) In this screenshot, the first and the last line come from
    the browser itself; the middle two lines are an “explanation” supplied by an (unnamed!)
    rogue website instead. The security impact of this particular dialog is minimal,
    but it is a remarkable example of poor UI design. Sadly, a nearly identical dialog
    is also used by Internet Explorer, and most other browser dialogs are not much
    better.](httpatomoreillycomsourcenostarchimages950035.png.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox在网页上执行onbeforeunload处理程序后生成了一个令人困惑且模糊的提示。处理程序给页面作者一个机会来解释离开页面（例如丢失任何未保存的数据）的后果，并请求用户做出最终决定。出于可用性的原因，不再允许互联网上的随机页面通过除这个特定的onbeforeunload对话框之外的其他方式中止挂起的导航。（令人惊讶的是，设计上能够永远将用户困在恶意页面上并取消任何导航尝试的能力并没有得到好评。）在这个屏幕截图中，第一行和最后一行来自浏览器本身；中间两行是（未命名的！）恶意网站提供的“解释”。这个特定对话框的安全影响最小，但它是一个糟糕的UI设计的显著例子。遗憾的是，几乎相同的对话框也被Internet
    Explorer使用，而且大多数其他浏览器的对话框也好不到哪里去。](http://atomoreilly.com/source/nostarch/images/950035.png.jpg)'
- en: Figure 14-1. Firefox generated a profoundly confusing and vague prompt following
    the execution of an onbeforeunload handler on a web page. The handler gives page
    authors a chance to explain the consequences of navigating away from their page
    (such as losing any unsaved data) and requests a final decision from the user.^([[68](#ftn.CHP-14-FN-5)])
    In this screenshot, the first and the last line come from the browser itself;
    the middle two lines are an “explanation” supplied by an (unnamed!) rogue website
    instead. The security impact of this particular dialog is minimal, but it is a
    remarkable example of poor UI design. Sadly, a nearly identical dialog is also
    used by Internet Explorer, and most other browser dialogs are not much better.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1. Firefox在网页上执行onbeforeunload处理程序后生成了一个令人困惑且模糊的提示。处理程序给页面作者一个机会来解释离开页面（例如丢失任何未保存的数据）的后果，并从用户那里请求最终决定.^([[68](#ftn.CHP-14-FN-5)])
    在这个屏幕截图中，第一行和最后一行来自浏览器本身；中间两行是由一个（未命名的！）恶意网站提供的“解释”。这个特定对话框的安全影响最小，但它是一个糟糕UI设计的显著例子。遗憾的是，一个几乎相同的对话框也被Internet
    Explorer使用，而且大多数其他浏览器对话框也好不到哪里去。
- en: Note
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many browser-level dialogs do a poor job of explaining where the prompt originated
    and its intended purpose. In some cases, such as the Firefox dialog shown in [Figure 14-1](ch14.html#firefox_generated_a_profoundly_confusing
    "Figure 14-1. Firefox generated a profoundly confusing and vague prompt following
    the execution of an onbeforeunload handler on a web page. The handler gives page
    authors a chance to explain the consequences of navigating away from their page
    (such as losing any unsaved data) and requests a final decision from the user.
    In this screenshot, the first and the last line come from the browser itself;
    the middle two lines are an “explanation” supplied by an (unnamed!) rogue website
    instead. The security impact of this particular dialog is minimal, but it is a
    remarkable example of poor UI design. Sadly, a nearly identical dialog is also
    used by Internet Explorer, and most other browser dialogs are not much better."),
    the result can be comical—and there is a more sinister side to such goofiness,
    too. Spawning authoritative-sounding dialogs that claim to be coming from the
    operating system itself is a common trick used by malware authors to confuse less
    experienced users. It’s not hard to imagine why that works.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 许多浏览器级别的对话框在解释提示的来源和其预期目的方面做得不好。在某些情况下，例如[图14-1](ch14.html#firefox_generated_a_profoundly_confusing
    "图14-1. Firefox在网页上执行onbeforeunload处理程序后生成了一个令人困惑且模糊的提示。处理程序给页面作者一个机会来解释离开页面（例如丢失任何未保存的数据）的后果，并从用户那里请求最终决定。在这个屏幕截图中，第一行和最后一行来自浏览器本身；中间两行是由一个（未命名的！）恶意网站提供的“解释”。这个特定对话框的安全影响最小，但它是一个糟糕UI设计的显著例子。遗憾的是，一个几乎相同的对话框也被Internet
    Explorer使用，而且大多数其他浏览器对话框也好不到哪里去。")中显示的Firefox对话框，结果可能是滑稽的——而且这种愚蠢也有更险恶的一面。生成听起来权威的对话框，声称它们来自操作系统本身，是恶意软件作者用来混淆经验不足用户的一种常见技巧。不难想象为什么这会有效。
- en: '* * *'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[64](#CHP-14-FN-1)]) The traditional design of most Unix services is to have
    a master “listener” process, and then create a new process for handling every
    accepted connection. For the developer, this model is remarkable in its simplicity;
    but it comes with many significant hidden costs for the operating system, which
    sometimes finds handling more than several hundred simultaneous connections at
    once challenging.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[64](#CHP-14-FN-1)]) 大多数Unix服务的传统设计是有一个主“监听”进程，然后为每个接受的连接创建一个新的进程。对于开发者来说，这种模型以其简单性而著称；但这也给操作系统带来了许多显著的隐藏成本，有时操作系统发现同时处理超过几百个并发连接具有挑战性。
- en: ^([[65](#CHP-14-FN-2)]) The little-known *showModalDialog(...)* method is a
    bit of a misnomer. It is essentially equivalent to *window.open(...)*, but it
    is supposed to vaguely emulate the behavior of a modal dialog by blocking the
    scripts in the calling context until such a “dialog” window is dismissed. The
    exact behavior of this API varies randomly from one browser to another. For example,
    it is sometimes possible for other pages to navigate the underlying window or
    execute new scripts while the original JS code that called *showModalDialog(...)*
    is in progress.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[65](#CHP-14-FN-2)]) 少为人知的 `showModalDialog(...)` 方法有点名不副实。它本质上等同于 `window.open(...)`，但它的目的是通过阻塞调用上下文中的脚本，直到这样的“对话框”窗口被关闭，来模糊地模拟模态对话框的行为。这个API的确切行为在不同浏览器之间随机变化。例如，当调用
    `showModalDialog(...)` 的原始JS代码正在执行时，有时其他页面可以导航到基础窗口或执行新的脚本。
- en: ^([[66](#CHP-14-FN-3)]) A “pop-under” is a pop-up window that, immediately after
    its creation, is moved to the back of the window stack with the help of *opener.window.focus()*
    or *window.blur()*. Pop-unders are arguably slightly less distracting than pop-ups,
    because the user does not have to take immediate action to go back to the original
    document. They are no less despised, however.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[66](#CHP-14-FN-3)]) “弹出下推”是一种弹出窗口，在创建后立即通过`opener.window.focus()`或`window.blur()`的帮助将其移动到窗口堆栈的后面。与弹出窗口相比，弹出下推可能稍微不那么分散注意力，因为用户不需要立即采取行动来返回原始文档。然而，它们并不少人讨厌。
- en: ^([[67](#CHP-14-FN-4)]) For example, a call to *window.open(...)* would not
    generate an exception. The return value in such a case is not standardized, however,
    making it difficult to detect a blocked pop-up reliably. In Internet Explorer
    and Firefox, the function will return *null*; in Safari, it will return another
    special value, *undefined*; in Opera, a dummy window handle will be supplied;
    and in Chrome, the returned window handle will even have a quasi-functional DOM.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[67](#CHP-14-FN-4)]) 例如，调用`window.open(...)`不会生成异常。然而，在这种情况下，返回值并不标准化，这使得可靠地检测被阻止的弹出窗口变得困难。在Internet
    Explorer和Firefox中，该函数将返回`null`；在Safari中，它将返回另一个特殊值`undefined`；在Opera中，将提供一个虚拟窗口句柄；而在Chrome中，返回的窗口句柄甚至具有准功能DOM。
- en: ^([[68](#CHP-14-FN-5)]) For usability reasons, random pages on the Internet
    are no longer permitted to abort pending navigation by means other than this specific
    *onbeforeunload* dialog. (Surprisingly, the by-design ability to trap the user
    on a rogue page forever and cancel any navigation attempts wasn’t received well.)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[68](#CHP-14-FN-5)]) 由于可用性原因，不再允许互联网上的随机页面通过除这种特定的*onbeforeunload*对话框之外的其他方式中止挂起的导航。（令人惊讶的是，设计上能够将用户永远困在恶意页面上并取消任何导航尝试的能力并没有得到好评。）
- en: Window-Positioning and Appearance Problems
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口定位和外观问题
- en: All right, all right—let’s move beyond the arguably uninspiring and unpopular
    topic of DoS flaws. There is a lot more to the various UI-related APIs—and *window.open(...)*
    is a particularly curious case. Recall from the discussion earlier in this chapter
    that this humble function permits web applications not only to create new windows
    but also to position them in a specific spot on the screen. Several other methods,
    such as *window.moveTo(...)*, *window.resizeTo(...)*, *window.focus()*, or *window.blur()*,
    further permit such a window to be moved around the screen, scaled, or stacked
    in a particular way. Finally, *window.close()* allows it to be discreetly disposed
    of when the script no longer needs it.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，好吧——让我们超越可能令人提不起兴趣且不受欢迎的DoS漏洞话题。与UI相关的各种API还有很多内容——`window.open(...)`就是一个特别有趣的情况。回想一下本章前面讨论的内容，这个不起眼的功能不仅允许Web应用程序创建新窗口，还可以在屏幕上的特定位置定位它们。其他几种方法，如`window.moveTo(...)`、`window.resizeTo(...)`、`window.focus()`或`window.blur()`，进一步允许这样的窗口在屏幕上移动、缩放或以特定方式堆叠。最后，`window.close()`允许在脚本不再需要它时悄悄地将其处理掉。
- en: As with most other UI-manipulation features, these APIs soon proved to be a
    source of pain. Following a series of amusing hacks that involved creating “hidden”
    windows by placing them partly or completely off-screen or by making them really
    tiny, these functions now require newly created windows to have certain minimal
    dimensions and to stay entirely within the visible desktop area. (It is still
    possible to create a window that constantly hops around the screen and evades
    all mouse-driven attempts to close it, but given what you’ve read so far, this
    deserves nothing but a heavy sigh.)
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他UI操作功能一样，这些API很快就被证明是痛苦的来源。在一系列有趣的黑客攻击之后，这些攻击通过将窗口部分或完全放置在屏幕之外或使其变得非常小来创建“隐藏”窗口，现在这些功能要求新创建的窗口必须具有某些最小尺寸，并且完全保持在可见桌面区域内。（尽管如此，仍然可以创建一个不断在屏幕上跳跃并逃避所有鼠标尝试关闭它的窗口，但鉴于你到目前为止所读到的内容，这只能引起深深的叹息。）
- en: 'The restrictions on window size do not mean that the entire contents of the
    address bar have to be visible to the user, however. An undersized window could
    be leveraged to mislead the user as to the origin of a document simply by carefully
    truncating the hostname, as shown in [Figure 14-2](ch14s02.html#a_window_carefully_sized_by_a_script_so
    "Figure 14-2. A window carefully sized by a script so that the real origin of
    the displayed content is elided in a confusing way. The actual URL of this cat-themed
    page is , not ."). Browser vendors have been aware of this problem since at least
    my report in 2010,^([[226](pr03.html#ftn.CHP-14-FT-1)]) but as of this writing,
    only Internet Explorer uses a somewhat convincing if subtle mitigation: It appends
    “...” at the end of any elided hostnames in the address bar.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对窗口大小的限制并不意味着地址栏的整个内容都必须对用户可见。一个尺寸过小的窗口可以通过精心截断主机名来误导用户关于文档来源，如图[图14-2](ch14s02.html#a_window_carefully_sized_by_a_script_so
    "图14-2. 脚本精心调整的窗口大小，使得显示内容的真实来源以一种令人困惑的方式被省略。这个以猫为主题的页面的实际URL是，而不是。")所示。浏览器厂商至少从2010年我的报告以来就已经意识到这个问题，^([[226](pr03.html#ftn.CHP-14-FT-1)])但截至本文写作时，只有Internet
    Explorer使用了一种多少有些令人信服但微妙的缓解措施：它在地址栏中省略的主机名末尾附加“...”。
- en: Another interesting issue with script-controlled window positioning is the prospect
    of creating several cleverly aligned, overlapping windows to form what appears
    to be a single document window with an address bar that doesn’t correspond to
    portions of the document displayed. This attack, which I like to call *window
    splicing*, is perhaps best illustrated in [Figure 14-3](ch14s02.html#a_window-splicing_attack_in_chrome._what
    "Figure 14-3. A window-splicing attack in Chrome. What may appear as a single
    document is actually a composite of two overlapping, aligned windows. The user
    is led to believe that the file upload button comes from the domain shown in the
    address bar of the top window, but it does not. Certain visual cues indicate foul
    play (for example, part of the window border has a slightly different hue), but
    they are too subtle to be easily noticed by the user.").
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 使用脚本控制的窗口定位的另一个有趣问题是，创建几个巧妙对齐、重叠的窗口，以形成一个看似单个文档窗口，其地址栏并不对应显示的文档部分。这种攻击，我将其称为*窗口拼接*，在[图14-3](ch14s02.html#a_window-splicing_attack_in_chrome._what
    "图14-3. Chrome中的窗口拼接攻击。看似单个文档实际上是由两个重叠、对齐的窗口组合而成。用户会被误导认为文件上传按钮来自顶部窗口的地址栏所显示的域，但实际上并非如此。某些视觉线索表明有欺诈行为（例如，窗口边框的一部分颜色略有不同），但这些线索过于微妙，不易被用户轻易察觉。")中或许得到了最好的说明。
- en: '![A window carefully sized by a script so that the real origin of the displayed
    content is elided in a confusing way. The actual URL of this cat-themed page is
    , not .](httpatomoreillycomsourcenostarchimages950037.png.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![脚本精心调整的窗口大小，使得显示内容的真实来源以一种令人困惑的方式被省略。这个以猫为主题的页面的实际URL是，而不是。](httpatomoreillycomsourcenostarchimages950037.png.jpg)'
- en: Figure 14-2. A window carefully sized by a script so that the real origin of
    the displayed content is elided in a confusing way. The actual URL of this cat-themed
    page is [http://www.example.com.coredump.cx/](http://www.example.com.coredump.cx/),
    not [http://www.example.com/](http://www.example.com/).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-2. 脚本精心调整的窗口大小，使得显示内容的真实来源以一种令人困惑的方式被省略。这个以猫为主题的页面的实际URL是[http://www.example.com.coredump.cx/](http://www.example.com.coredump.cx/)，而不是[http://www.example.com/](http://www.example.com/)。
- en: Window positioning offers some interesting if far-fetched attack scenarios,
    but manipulating the contents of a programmatically created window is also of
    some relevance to browser security. We have already mentioned that one of the
    features of the *window.open(...)* API is its ability to hide certain elements
    of the browser chrome (scrollbars, menus, and so on) in the newly opened window.
    An example of such a UI-restricting call is
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口定位提供了一些有趣但有些牵强的攻击场景，但操纵通过编程创建的窗口的内容对浏览器安全也具有一定的相关性。我们已经提到，*window.open(...)*
    API的一个特性是它能够在新打开的窗口中隐藏浏览器界面的某些元素（滚动条、菜单等）。这样的UI限制调用示例是
- en: '[PRE34]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![A window-splicing attack in Chrome. What may appear as a single document
    is actually a composite of two overlapping, aligned windows. The user is led to
    believe that the file upload button comes from the domain shown in the address
    bar of the top window, but it does not. Certain visual cues indicate foul play
    (for example, part of the window border has a slightly different hue), but they
    are too subtle to be easily noticed by the user.](httpatomoreillycomsourcenostarchimages950039.png.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome中的窗口拼接攻击。可能看起来是一个单独的文档，实际上是由两个重叠、对齐的窗口组合而成。用户会被引导相信文件上传按钮来自顶部窗口地址栏中显示的域名，但实际上并非如此。某些视觉线索表明有欺诈行为（例如，窗口边框的一部分颜色略有不同），但这些线索太微妙，不容易被用户察觉。](httpatomoreillycomsourcenostarchimages950039.png.jpg)'
- en: Figure 14-3. A window-splicing attack in Chrome. What may appear as a single
    document is actually a composite of two overlapping, aligned windows. The user
    is led to believe that the file upload button comes from the domain shown in the
    address bar of the top window, but it does not. Certain visual cues indicate foul
    play (for example, part of the window border has a slightly different hue), but
    they are too subtle to be easily noticed by the user.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3. Chrome中的窗口拼接攻击。可能看起来是一个单独的文档，实际上是由两个重叠、对齐的窗口组合而成。用户会被引导相信文件上传按钮来自顶部窗口地址栏中显示的域名，但实际上并非如此。某些视觉线索表明有欺诈行为（例如，窗口边框的一部分颜色略有不同），但这些线索太微妙，不容易被用户察觉。
- en: 'One of these settings, `location=no`, was meant to hide the address bar. This
    is, of course, a horrible idea: It enables the attacker not only to hide the actual
    address bar but also to load a page that simply provides a pixel-perfect image
    of the address bar showing a completely unrelated URL. Heck, with some minimal
    effort, that fake address bar may even be fully interactive.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个设置，`location=no`，原本是为了隐藏地址栏。这当然是一个糟糕的想法：它不仅允许攻击者隐藏实际的地址栏，还可以加载一个仅提供地址栏像素完美图像的页面，显示一个完全不相关的URL。更糟糕的是，通过一些最小限度的努力，这个假地址栏甚至可能完全交互式。
- en: 'Realizing the dangers of this design, most browsers eventually began displaying
    a minimalistic, read-only address bar in any windows opened with `location=no`;
    Apple, however, sees no harm in allowing this setting to work as originally envisioned
    in the 1990s. Too bad: [Figure 14-4](ch14s02.html#allowing_websites_to_hide_the_address_ba
    "Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea.
    The displayed document is not retrieved from . Instead, the page simply displays
    a screenshot of a real address bar in a window created by window.open("...", "location=no").")
    shows a simple attack on its UI. (I contacted Apple about this attack sometime
    in 2010 but have yet to hear back.)'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到这种设计的危险，大多数浏览器最终开始在任何使用 `location=no` 打开的窗口中显示一个简约的、只读的地址栏；然而，苹果公司认为允许这种设置按照20世纪90年代最初设想的方式工作并无害处。遗憾的是：[图14-4](ch14s02.html#allowing_websites_to_hide_the_address_ba
    "图14-4. 允许网站在Safari中隐藏地址栏是一个糟糕的想法。显示的文档并非来自 . 而是页面简单地显示了一个由 window.open("...",
    "location=no") 创建的窗口中的真实地址栏的截图。") 展示了对其用户界面的简单攻击。（我在2010年左右联系了苹果公司关于这种攻击，但至今未收到回复。）
- en: '![Allowing websites to hide the address bar in Safari is a bad idea. The displayed
    document is not retrieved from . Instead, the page simply displays a screenshot
    of a real address bar in a window created by window.open("...", "location=no").](httpatomoreillycomsourcenostarchimages950041.png.jpg)'
  id: totrans-727
  prefs: []
  type: TYPE_IMG
  zh: '![允许网站在Safari中隐藏地址栏是一个糟糕的想法。显示的文档并非来自 . 而是页面简单地显示了一个由 window.open("...", "location=no")
    创建的窗口中的真实地址栏的截图。](httpatomoreillycomsourcenostarchimages950041.png.jpg)'
- en: Figure 14-4. Allowing websites to hide the address bar in Safari is a bad idea.
    The displayed document is not retrieved from [http://www.example.com/](http://www.example.com/).
    Instead, the page simply displays a screenshot of a real address bar in a window
    created by *window.open("*[http://coredump.cx/](http://coredump.cx/)*...", "location=no")*.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4. 允许网站在Safari中隐藏地址栏是一个糟糕的想法。显示的文档并非来自 [http://www.example.com/](http://www.example.com/)。而是页面简单地显示了一个由
    *window.open("*[http://coredump.cx/](http://coredump.cx/)*...", "location=no")*
    创建的窗口中的真实地址栏的截图。
- en: 'Microsoft has not fared much better: Although they patched up *window.open(...)*,
    they forgot about *window.createPopup(...)*, an ancient and obscure API still
    not subject to the necessary checks.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的表现也好不到哪里去：尽管他们修补了 *window.open(...)*，但他们忘记了 *window.createPopup(...)*，这是一个古老且不为人知的API，至今仍未受到必要的检查。
- en: Timing Attacks on User Interfaces
  id: totrans-730
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面的时间攻击
- en: 'The problems we’ve discussed so far in this chapter may be hard to fix, but
    at least in principle, the solutions are not out of reach. Still, here’s a preposterous
    question: Could the current model of web scripting be fundamentally incompatible
    with the way human beings work? By that, I do not mean merely the dangers of web-delivered
    social engineering that targets the inattentive and the easily confused; rather,
    I’m asking if it’s possible for scripts to consistently outsmart alert and knowledgeable
    victims simply due to the inherent limitations of human cognition?'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们讨论的问题可能难以解决，但至少在原则上，解决方案并非遥不可及。然而，这里有一个荒谬的问题：当前的网页脚本模型是否可能与人类的工作方式在本质上不兼容？通过这个问题，我并不是仅仅指针对粗心大意和容易混淆的人进行的网络社会工程学的危险；而是在问，是否有可能让脚本持续地智胜警觉和知识渊博的受害者，仅仅是因为人类认知的固有局限性？
- en: The question is outlandish enough not to be asked often, yet the answer may
    be yes. Consider that in a typical, attentive human subject, the usual latency
    between a visual stimulus and a voluntary motor response is between 100 and 300
    milliseconds.^([[227](pr03.html#ftn.CHP-14-FT-2)]) Humans do not pause for that
    long to assess the situation after every minute muscle movement; instead, we subconsciously
    schedule a series of learned motor actions well in advance and process any sensory
    feedback as it arrives later on. For a split second, we cannot abort a premeditated
    action, even if something goes horribly wrong.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题足够荒谬，以至于很少被问起，但答案可能是肯定的。考虑一下，在典型的、警觉的人类受试者中，视觉刺激和自愿运动反应之间的通常延迟在100到300毫秒之间.^([[227](pr03.html#ftn.CHP-14-FT-2)])人类不会在每次肌肉运动后都停下来评估情况那么长时间；相反，我们潜意识地提前安排了一系列学习到的运动动作，并在稍后处理任何到达的感官反馈。在一瞬间，我们无法取消预先计划好的动作，即使出了可怕的问题。
- en: Alas, on today’s personal computers, a lot can happen in as little as one-tenth
    of that interval. In particular, scripts can open new windows, move them around,
    or close any existing ones; they can also initiate or abort system-level prompts.
    In such a setting, designing security-sensitive UIs is not nearly as simple as
    it seems, and some types of attacks may be simply impossible to defend against
    without a major paradigm shift in how we design software.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，在今天的个人电脑上，在这么短的时间内可能发生很多事情。特别是，脚本可以打开新的窗口，移动它们，或者关闭任何现有的窗口；它们还可以启动或终止系统级提示。在这种设置下，设计对安全敏感的用户界面远不如看起来那么简单，而且某些类型的攻击可能在没有进行软件设计范式重大转变的情况下根本无法防御。
- en: 'To illustrate the issue, consider a page that attempts to start an unsolicited
    download of a dangerous file type. The download will typically initiate a browser-level
    dialog with three options: “open,” “save,” and “cancel.” Sane users will make
    that last choice—but not if the attacker robs them of a chance to do so.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，考虑一个尝试启动危险文件类型的不请自来的下载的页面。下载通常会在浏览器级别启动一个带有三个选项的对话框：“打开”、“保存”和“取消”。理智的用户会选择最后一个选项——但如果攻击者剥夺了他们这样做的机会，情况就不同了。
- en: Let’s assume that just milliseconds after the dialog is opened, and perhaps
    before the user even registers its presence, a new window is created on top that
    hides it from view. In that window, the attacker plants a carefully positioned
    button or link that the user is likely to click, for example, a button to dismiss
    an annoying interstitial advertisement. As the user attempts to perform this perfectly
    reasonable action, the rogue page may use *onmousemove* events to monitor the
    position and velocity of the mouse pointer and fairly accurately predict the timing
    of an upcoming click. Closing the overlay window several milliseconds before that
    click, only to reveal the “open” button in the same position, will lead the user
    inevitably to make that choice in the security prompt. There is simply nothing
    the user can do. (I demonstrated a practical attack on Firefox along these lines
    in 2007.)^([[228](pr03.html#ftn.CHP-14-FT-3)])
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在对话框打开后的几毫秒内，甚至在用户甚至没有意识到它的存在之前，就创建了一个新的窗口，将其隐藏起来。在这个窗口中，攻击者放置了一个精心定位的按钮或链接，用户很可能会点击，例如，关闭一个令人讨厌的插页广告的按钮。当用户试图执行这个完全合理的动作时，恶意页面可能会使用`onmousemove`事件来监控鼠标指针的位置和速度，并相当准确地预测即将点击的时间。在点击之前几毫秒关闭覆盖窗口，然后在该位置显示“打开”按钮，将不可避免地引导用户在安全提示中选择该选项。用户实际上什么也做不了。（我在2007年演示了基于这些原理的Firefox的实际攻击。）^([[228](pr03.html#ftn.CHP-14-FT-3)])
- en: 'In response to the attacks on security dialogs, a variety of security delays
    have been implemented in the past few years, requiring anywhere from 500 milliseconds
    to 5 seconds between the dialog coming into focus and any dangerous buttons being
    enabled for user input. But such delays do not sit well with browser UI designers:
    They hate them, feeling that the product should be as responsive as possible and
    that annoying the user with nonclickable buttons or countdowns is a significant
    usability issue. Some have even pushed to remove existing timeouts from legacy
    UIs.^([[69](#ftn.CHP-14-FN-6)]) HTML5 geolocation-sharing prompts are impacted
    by this view. Many browsers are not protected against the attack on this UI in
    any significant way.^([[229](pr03.html#ftn.CHP-14-FT-4)])'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对安全对话框攻击的回应，在过去的几年中已经实施了各种安全延迟，要求在对话框聚焦和任何危险按钮启用用户输入之间有500毫秒到5秒的时间。但这样的延迟并不符合浏览器UI设计师的口味：他们讨厌它，觉得产品应该尽可能有响应性，而用不可点击的按钮或倒计时来烦扰用户是一个重大的可用性问题。有些人甚至推动从遗留UI中移除现有的超时设置.^([[69](#ftn.CHP-14-FN-6)])
    HTML5地理位置共享提示也受到了这种观点的影响。许多浏览器在以任何重要方式保护这种UI免受攻击方面做得不足.^([[229](pr03.html#ftn.CHP-14-FT-4)])
- en: To further complicate the picture, browser-level user interfaces are not the
    only concern for UI-timing attacks. The security- or privacy-sensitive functionality
    of many trusted websites can also be attacked, and fixing that problem is a lot
    harder than adding delay timers on a handful of known dangerous system-level UIs.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步复杂化情况，浏览器级别的用户界面并不是UI时间攻击的唯一关注点。许多受信任网站的安全或隐私敏感功能也可能受到攻击，解决这个问题比在几个已知的危险系统级UI上添加延迟计时器要困难得多。
- en: Note
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Millisecond-level click or keypress hijacking aside, it has been repeatedly
    demonstrated that with minimal and seemingly innocuous conditioning, healthy and
    focused test subjects can be reliably tricked into ignoring even very prominent
    and unusual visual stimuli. The infamous Invisible Gorilla experiment,^([[230](pr03.html#ftn.CHP-14-FT-5)])
    shown in [Figure 14-5](ch14s03.html#a_single_frame_from_the_invisible_gorill "Figure 14-5. A
    single frame from the Invisible Gorilla experiment, courtesy of Daniel Simons
    (). When asked to view this video and count the number of times the players pass
    the basketball, most viewers fail to notice a person in a gorilla suit casually
    strolling across the room halfway through the clip. Really! Go to and try it on
    a friend."), is a particularly well-known example of this. Almost all viewers
    watching a clip prepared by the researchers fail to notice a plainly visible gorilla
    in a crowd. The corollary is that even savvy users can be conditioned to ignore
    cues such as changes to the address bar or to SSL indicators in the browser—a
    very disconcerting thought. The only reason why we are not trying to solve this
    problem today is that few exploit writers are behavioral scientists. But if you
    are a high-profile target, this seems like a risky bet.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 除了毫秒级的点击或按键劫持之外，已经反复证明，通过最小化和看似无害的条件反射，健康的专注测试对象可以被可靠地欺骗，忽略甚至非常突出和异常的视觉刺激。臭名昭著的“不可见的大猩猩”实验，^([[230](pr03.html#ftn.CHP-14-FT-5)])
    如[图14-5](ch14s03.html#a_single_frame_from_the_invisible_gorill "图14-5. 来自‘不可见的大猩猩’实验的单帧画面，由丹尼尔·西蒙斯提供()。当被要求观看这个视频并数出球员传递篮球的次数时，大多数观众未能注意到一个穿着大猩猩服装的人在中途悠闲地穿过房间。真的！去试试看，并让你的朋友也试试。"),
    是这一点的特别著名例子。几乎所有观看研究人员制作的剪辑的观众都未能注意到人群中一个明显可见的大猩猩。由此得出的推论是，即使是老练的用户也可能被训练去忽略诸如地址栏变化或浏览器中SSL指示器的变化等提示——这是一个非常令人不安的想法。我们今天没有试图解决这个问题，唯一的原因是很少有利用者作者是行为科学家。但如果你是一个高调的目标，这似乎是一个风险很大的赌注。
- en: '![A single frame from the Invisible Gorilla experiment, courtesy of Daniel
    Simons (). When asked to view this video and count the number of times the players
    pass the basketball, most viewers fail to notice a person in a gorilla suit casually
    strolling across the room halfway through the clip. Really! Go to and try it on
    a friend.](httpatomoreillycomsourcenostarchimages950043.png.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![来自“不可见的大猩猩”实验的单帧画面，由丹尼尔·西蒙斯提供()。当被要求观看这个视频并数出球员传递篮球的次数时，大多数观众未能注意到一个穿着大猩猩服装的人在中途悠闲地穿过房间。真的！去试试看，并让你的朋友也试试。](httpatomoreillycomsourcenostarchimages950043.png.jpg)'
- en: Figure 14-5. A single frame from the Invisible Gorilla experiment, courtesy
    of Daniel Simons^([[231](pr03.html#ftn.CHP-14-FT-6)]) ([http://dansimons.com/](http://dansimons.com/)).
    When asked to view this video and count the number of times the players pass the
    basketball, most viewers fail to notice a person in a gorilla suit casually strolling
    across the room halfway through the clip. Really! Go to [http://theinvisiblegorilla.com/videos.html](http://theinvisiblegorilla.com/videos.html)
    and try it on a friend.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5. 无形大猩猩实验的单帧，由Daniel Simons提供^([[231](pr03.html#ftn.CHP-14-FT-6)]) ([http://dansimons.com/](http://dansimons.com/)).
    当被要求观看这个视频并数出球员传递篮球的次数时，大多数观众未能注意到一个穿着大猩猩服装的人在中途悠闲地穿过房间。真的！去[http://theinvisiblegorilla.com/videos.html](http://theinvisiblegorilla.com/videos.html)并让朋友试试。
- en: Security Engineering Cheat Sheet
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Permitting User-Created <iframe> Gadgets on Your Site
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 当允许在你的网站上使用用户创建的<iframe>小工具时
- en: Don’t do so unless you are prepared to live with the consequences. You can’t
    reliably prevent a malicious gadget from launching DoS attacks on your users.
    Any such gadget will also be able to bring up various obscure dialogs that, as
    a rule, will not distinguish between your top-level page and the domain the gadget
    is hosted in.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你准备好接受后果，否则不要这样做。你无法可靠地防止恶意设备对你的用户发起DoS攻击。任何这样的设备也将能够弹出各种晦涩的对话框，通常情况下，这些对话框不会区分你的顶级页面和设备所在的主域。
- en: When Building Security-Sensitive UIs
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建安全敏感的UI时
- en: Because of the risk of UI race conditions, avoid situations where a vital setting
    can be changed with a single keypress or a single click. Require at least two
    operations (such as selecting a checkbox and then clicking Save). If single-click
    actions are unavoidable, consider examining other signals. For example, was the
    mouse pointer in the current window 500 milliseconds ago?
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于存在UI竞态条件风险，避免出现单次按键或单次点击即可更改关键设置的情况。至少需要两个操作（例如选择复选框然后点击保存）。如果单次点击操作不可避免，考虑检查其他信号。例如，鼠标指针在当前窗口500毫秒前是否在？
- en: '* * *'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[69](#CHP-14-FN-6)]) See, for example, Mozilla bug 561177, where one of the
    Firefox UI engineers proposed the removal of a security delay from the plug-in
    installation prompt.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[69](#CHP-14-FN-6)]) 例如，参见Mozilla错误报告561177，其中一位Firefox UI工程师提出了从插件安装提示中移除安全延迟的建议。
- en: Chapter 15. Extrinsic Site Privileges
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。外部网站权限
- en: To wrap up the discussion of all the noteworthy browser security features, we’ll
    look at a handful of mechanisms that grant special privileges to sites hand-picked
    by the user or hardcoded by the authors of the browser itself. The approach taken
    in these cases is in stark contrast to the schemes we have discussed previously,
    all of which rely on a fairly sensible examination of intrinsic properties of
    the displayed content. Normally, the implementation would have us look at the
    source of the document, the context it is displayed in, or the nature of the operation
    that the document is attempting to perform, but barring the outcome of these checks,
    the browser would never give preferential treatment to a single otherwise unremarkable
    origin.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结所有值得注意的浏览器安全功能的讨论，我们将探讨一些机制，这些机制赋予用户或浏览器作者硬编码的特定网站特殊权限。在这些情况下采取的方法与我们之前讨论的方案截然不同，所有这些方案都依赖于对显示内容内在属性的相当合理的检查。通常，实现方式会要求我们查看文档的源代码、其显示的上下文或文档试图执行的操作的性质，但在排除这些检查的结果之外，浏览器永远不会给予一个原本无足轻重的来源优先权。
- en: Per-site privileges violate this principle of impartiality in a fairly brutal
    way, for reasons ranging from questionable to—more commonly—just utilitarian.
    There are compelling usability reasons to bring certain inherently dangerous features
    to the browser world, but there is no good way to programmatically decide which
    web applications are trustworthy enough to be given access to them. Delegating
    this task to a human being may be the best thing we can do.^([[70](#ftn.CHP-15-FN-1)])
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 每站权限以一种相当残酷的方式违反了这一公平原则，原因从可疑到——更常见的是——实用主义。有充分的可用性理由将某些固有的危险功能引入浏览器世界，但没有好的方法可以程序化地决定哪些Web应用程序足够值得信赖，可以赋予它们访问这些功能的权限。将这项任务委托给人类可能是我们能做的最好的事情.^([[70](#ftn.CHP-15-FN-1)])
- en: Naturally, the creation of a caste of privileged applications can be very problematic
    because the boundaries between any two web applications are not particularly well
    defined to begin with, making it difficult to contain the permissions precisely.
    And because the already imperfect boundaries apply only to certain cross-site
    interactions, vulnerabilities such as XSS or XSRF may further contribute to the
    misery. In the end, a significant disconnect may develop between the intent of
    a per-site permission and the actual consequences of such a grant.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，创建一个特权应用程序阶层可能会非常成问题，因为任何两个Web应用程序之间的边界一开始就不太明确，这使得精确控制权限变得困难。而且，由于这些已经不完美的边界仅适用于某些跨站交互，XSS或XSRF等漏洞可能会进一步加剧问题。最终，网站权限的意图与实际后果之间可能会出现重大脱节。
- en: Browser- and Plug-in-Managed Site Permissions
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器和插件管理的网站权限
- en: When balancing security, privacy, and usability, browser vendors sometimes find
    themselves between a rock and a hard place. Some proposed features seem essential
    to the continued growth of the Web but are simply too dangerous to be made available
    to every website on the Internet. Examples of such problematic mechanisms include
    giving access to video camera or microphone feeds,^([[71](#ftn.CHP-15-FN-2)])
    allowing websites to query for user geolocation data,^([[72](#ftn.CHP-15-FN-3)])
    installing browser extensions or themes, or opening desktop notifications.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在平衡安全、隐私和可用性时，浏览器供应商有时会发现自己处于两难境地。一些提议的功能似乎对网络的持续增长至关重要，但过于危险，不能提供给互联网上的每个网站。这类问题机制包括访问视频摄像头或麦克风数据，^([[71](#ftn.CHP-15-FN-2)])
    允许网站查询用户地理位置数据，^([[72](#ftn.CHP-15-FN-3)]) 安装浏览器扩展或主题，或开启桌面通知。
- en: 'As a work-around for this problem, vendors require the user to approve the
    application’s request in order for it to be allowed to access a privileged API.
    On the first attempt to use restricted functionality, the user is typically provided
    with a visual cue (ranging from an icon to a modal prompt) and given three choices:
    ignore the request, permit it once, or permanently authorize the requesting site
    to access the API. Of these choices, the last one is the most interesting: If
    selected, all future access from a matching host will be automatically approved,
    sometimes without any further visual indication.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个问题的解决方案，供应商要求用户批准应用程序的请求，以便允许它访问特权API。在第一次尝试使用受限功能时，用户通常会收到一个视觉提示（从图标到模态提示），并给出三个选择：忽略请求、允许一次或永久授权请求网站访问API。在这些选择中，最后一个是最有趣的：如果选择，所有来自匹配主机的未来访问都将自动批准，有时甚至没有任何进一步的视觉指示。
- en: Note
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Most whitelists look only at the hostname, and not at the protocol or port.
    Any entry on these lists will therefore match more than one SOP origin. In particular,
    authorizing [https://fuzzybunnies.com/](https://fuzzybunnies.com/) to access your
    camera may also authorize the nonencrypted site at [http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    to do the same.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数白名单只查看主机名，而不是协议或端口。因此，这些列表上的任何条目都将匹配多个SOP源。特别是，授权[https://fuzzybunnies.com/](https://fuzzybunnies.com/)访问您的摄像头也可能授权非加密网站[http://fuzzybunnies.com/](http://fuzzybunnies.com/)执行相同的操作。
- en: Granting websites access to privacy- or security-sensitive features should be
    done with care, because, as noted earlier, the implications of doing so extend
    beyond merely trusting the authors of the whitelisted application. Permission
    is granted to any content executed in the matching origin, regardless of how the
    payload got there, greatly amplifying the impact of simple (and, in the long run,
    inevitable) implementation bugs. A script injection vulnerability in a privileged
    origin no longer merely exposes the data stored within the application but may
    also leak client-originating sensitive data feeds.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎地授予网站访问隐私或安全敏感功能的权限，因为，如前所述，这样做的影响不仅限于信任白名单应用程序的作者。权限授予给在匹配源中执行的所有内容，无论其负载如何到达，这极大地放大了简单（并且在长远来看是不可避免的）实现错误的影响。在特权源中的脚本注入漏洞不再仅仅暴露应用程序中存储的数据，还可能泄露来自客户端的敏感数据流。
- en: Hardcoded Domains
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定域名
- en: In addition to the list of user-authorized privileged domains, some browsers
    or browser plug-ins come with a list of vendor-selected sites or SOP origins that
    are given substantial privileges to reconfigure or update portions of the browser
    or the operating system. Some of the most prominent examples of this trend include
    [update.microsoft.com](http://update.microsoft.com), which is recognized by ActiveX
    controls that ship with Microsoft Windows and is allowed to install software updates;
    [addons.mozilla.org](http://addons.mozilla.org) and [chrome.google.com](http://chrome.google.com),
    recognized by their corresponding browsers and given special privileges to install
    extensions or themes; or [www.macromedia.com](http://www.macromedia.com), which
    is allowed to reconfigure Adobe Flash.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户授权的特权域名列表之外，一些浏览器或浏览器插件附带了一个由供应商选择的网站列表或SOP来源，这些网站被赋予了重新配置或更新浏览器或操作系统的部分内容的重大特权。这一趋势的最突出例子包括
    [update.microsoft.com](http://update.microsoft.com)，它被随Microsoft Windows一起发布的ActiveX控件所识别，并允许安装软件更新；[addons.mozilla.org](http://addons.mozilla.org)
    和 [chrome.google.com](http://chrome.google.com)，分别被它们对应的浏览器所识别，并赋予了安装扩展或主题的特殊权限；或者
    [www.macromedia.com](http://www.macromedia.com)，它被允许重新配置Adobe Flash。
- en: 'The designs of these mechanisms vary and, as a rule, are not documented in
    a satisfactory way. Some features require second-level verification, such as a
    cryptographic signature or user consent, but others do not. Broadly speaking,
    the proliferation of such privileged domains is troubling, because it is clear
    that they will not be immune to the usual security problems that plague the rest
    of the modern Web. Case in point: [http://xssed.com/](http://xssed.com/) lists
    six publicly reported XSS vulnerabilities in [addons.mozilla.org](http://addons.mozilla.org).^([[232](pr03.html#ftn.CHP-15-FT-1)])'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机制的设计各不相同，通常情况下，它们并没有得到令人满意的文档记录。一些功能需要二级验证，例如加密签名或用户同意，但其他则不需要。从广义上讲，这种特权域的泛滥令人担忧，因为很明显，它们不会免受困扰现代网络的其他常见安全问题。例如：[http://xssed.com/](http://xssed.com/)
    列出了 [addons.mozilla.org](http://addons.mozilla.org) 中的六个公开报告的跨站脚本（XSS）漏洞.^([[232](pr03.html#ftn.CHP-15-FT-1)])
- en: '* * *'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[70](#CHP-15-FN-1)]) It is fair to complain that browsers do not do much
    to equip users with affirmative signals about the trustworthiness of a visited
    site, even though many robust indicators may plausibly be arrived at in an automated
    way. Blacklist-driven attempts to block known malicious sites exist, but given
    the negligible cost of registering a new domain (or compromising a random existing
    one), these approaches are arguably of less value.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[70](#CHP-15-FN-1)]) 有理由抱怨浏览器并没有做很多来为用户提供有关访问网站可信度的积极信号，尽管许多强大的指标可能以自动化的方式得到。基于黑名单的尝试来阻止已知的恶意网站存在，但考虑到注册新域名（或破坏一个随机现有的域名）的微不足道的成本，这些方法的价值可能较小。
- en: ^([[71](#CHP-15-FN-2)]) This functionality is currently supported only by plug-ins,
    such as Adobe Flash, but on track to become a part of HTML5.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[71](#CHP-15-FN-2)]) 目前这项功能仅由插件支持，例如Adobe Flash，但预计将成为HTML5的一部分。
- en: ^([[72](#CHP-15-FN-3)]) This API derives user location from parameters such
    as the current IP address, the list of nearby wireless networks or cell towers,
    or the data supplied by a hardware GPS receiver. With the exception of GPS data,
    it may be necessary to consult an external service provider to map these inputs
    to physical coordinates.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[72](#CHP-15-FN-3)]) 此API从当前IP地址、附近无线网络或蜂窝基站列表，或由硬件GPS接收器提供的数据等参数中获取用户位置。除了GPS数据外，可能需要咨询外部服务提供商将这些输入映射到物理坐标。
- en: Form-Based Password Managers
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于表单的密码管理器
- en: Surprised? Don’t be. Mentioning password managers may seem out of place, but
    it is very useful to consider this technology as an indirect form of a site-bound
    privilege. Before we explain, let’s briefly review why password management is
    implemented in modern browsers to begin with and how it actually operates.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 感到惊讶吗？不要。提到密码管理器可能看起来有些不合适，但将这项技术视为一种间接的站点特权形式非常有用。在我们解释之前，让我们简要回顾一下为什么密码管理最初在现代浏览器中得到实现，以及它是如何实际运作的。
- en: 'The answer to the first question is fairly simple: Today, almost every major
    website requires, or at least strongly encourages, all visitors to open an account.
    Logging in is typically necessary in order to customize the appearance of the
    site and is a prerequisite for interacting with other registered users. Unfortunately,
    these site-specific authentication systems are not synchronized (save for several
    limited-scale “federated login” experiments, such as OpenID),^([[233](pr03.html#ftn.CHP-15-FT-2)])
    and they effectively force the general population to create and memorize several
    dozen robust passwords, one for every destination frequented. This approach is
    difficult to sustain and leads to rampant and dangerous password reuse; that’s
    where browser vendors decided to step in.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的答案相当简单：今天，几乎每个主要网站都要求，或者至少强烈建议所有访客注册一个账户。登录通常是自定义网站外观所必需的，并且是与其他注册用户互动的先决条件。不幸的是，这些特定站点的身份验证系统并没有同步（除了几个有限的“联合登录”实验，如OpenID），^([[233](pr03.html#ftn.CHP-15-FT-2)])
    并且实际上迫使普通大众为每个常去的网站创建和记住几十个强大的密码。这种方法难以维持，并导致密码重用泛滥且危险；这就是浏览器厂商决定介入的原因。
- en: Form-based password managers are an inelegant but pragmatic solution to the
    problem of coping with the proliferation of per-site credentials. They apply simple
    heuristics to detect the submission of normal-looking login forms (the browser
    looks for an *<input type=password>* field and then perhaps examines the names
    of form fields for strings such as *user* and *pass*). When a suitable form is
    detected, the browser will offer to save the associated login information in a
    persistent store on the hard drive,^([[73](#ftn.CHP-15-FN-4)]) and if the user
    consents, it will then automatically retrieve and paste this data into matching
    forms encountered later on. In Firefox, Chrome, and Safari, the process of retrieving
    a stored password is automatic; in Internet Explorer and Opera, an additional
    user gesture may be required to confirm the intent.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表单的密码管理器是对处理站点凭证激增问题的一种不优雅但实用的解决方案。它们通过简单的启发式方法来检测看似正常的登录表单的提交（浏览器会寻找一个 *<input
    type=password>* 字段，然后可能检查表单字段的名称，寻找诸如 *user* 和 *pass* 这样的字符串）。当检测到合适的表单时，浏览器会提供将相关的登录信息保存到硬盘上的持久存储中的选项，^([[73](#ftn.CHP-15-FN-4)])
    如果用户同意，它将随后自动检索并将这些数据粘贴到后来遇到的匹配表单中。在Firefox、Chrome和Safari中，检索存储的密码的过程是自动的；在Internet
    Explorer和Opera中，可能需要额外的用户操作来确认意图。
- en: 'The design of password managers is fragile but has one clear benefit: It works
    right away even without official support (or, for that matter, informed consent)
    from any websites. Web applications that are unhappy about this feature may opt
    out by appending a poorly named *autocomplete=off* parameter to the offending
    password field,^([[74](#ftn.CHP-15-FN-5)]) but beyond that, the process is almost
    completely seamless.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 密码管理器的设计脆弱，但有一个明显的优点：即使在没有任何网站官方支持（或，更确切地说，知情同意）的情况下，它也能立即工作。不希望有此功能的Web应用程序可以通过将一个命名不佳的
    *autocomplete=off* 参数附加到受影响的密码字段上选择退出，^([[74](#ftn.CHP-15-FN-5)]) 但除此之外，整个过程几乎是完全无缝的。
- en: The primary way that every in-browser password manager protects stored data
    is by tying the credentials to the SOP origin where they were originally entered—paying
    close attention to the hostname, protocol, and port. Some browsers also consider
    secondary indicators, such as the ordering or naming of form fields, the URL path
    to the form, or the address to which the credentials are sent. (As we know from
    [Chapter 9](ch09.html "Chapter 9. Content Isolation Logic"), such scoping measures
    are not particularly useful from the security standpoint due to the operation
    of the same-origin policy.)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器内置密码管理器保护存储数据的主要方式是将凭证与其最初输入的SOP（Same-Origin Policy，同源策略）源绑定——密切注意主机名、协议和端口。一些浏览器还会考虑次要指标，例如表单字段的排序或命名、表单的URL路径或凭证发送到的地址。（正如我们在[第9章](ch09.html
    "第9章。内容隔离逻辑")中了解到的，由于同源策略的操作，这些范围措施从安全角度来看并不特别有用。）
- en: 'In browsers that autocomplete login forms without the need for human interaction,
    it is sensible to look at the mechanism as a form of a privileged API: Any content
    executing in the appropriate origin will be able to request browser-stored credentials
    by constructing a believable-looking form and then waiting for it to be automatically
    populated with login data. In order to read back this information, the script
    merely needs to examine the *value* property of the DOM element associated with
    the password field.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在无需人工交互即可自动完成登录表单的浏览器中，将这种机制视为一种特权API的形式是合理的：在适当的源中执行的内容将能够通过构建看起来可信的表单并等待自动填充登录数据来请求浏览器存储的凭据。为了读取这些信息，脚本只需检查与密码字段关联的DOM元素的*value*属性。
- en: Note
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Removing the ability to inspect values of password fields may seem like a simple
    way to improve the scheme, but it is not a very good one. The data could still
    be stolen by, say, waiting for password autocompletion, changing the data submission
    method from POST to GET, and then calling *submit()* on the login form. These
    steps would result in navigation to a page that has the password plainly visible
    in the *location.search* string. (Plus, many web applications have legitimate
    uses for reading back these fields on the client side, for example, to advise
    on password strength.)
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 移除检查密码字段值的能力可能看起来是改进方案的一种简单方法，但这并不是一个好方法。数据仍然可能被窃取，例如，通过等待密码自动完成，将数据提交方法从POST更改为GET，然后在登录表单上调用*submit()*。这些步骤会导致导航到一个页面，该页面在*location.search*字符串中清楚地显示了密码。（此外，许多Web应用程序在客户端读取这些字段具有合法用途，例如，提供密码强度建议。）
- en: As should be clear, the most serious risk associated with password managers
    is the amplification of XSS bugs. In web applications that use *httponly* cookies,
    a successful exploitation of an XSS flaw may give the attacker only transient
    access to a user’s account, but if the same vulnerability can be leveraged to
    steal a user’s password, the consequences are more dire and longer-lived.^([[75](#ftn.CHP-15-FN-6)])
    More obscure side effects are possible, too. For example, any application that
    allows users to construct custom form-based surveys must carefully restrict the
    layout of the generated forms or risk doubling as a password-harvesting tool.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，与密码管理器相关的最大风险是XSS漏洞的放大。在使用*httponly* cookie的Web应用程序中，成功利用XSS漏洞可能只会让攻击者暂时访问用户的账户，但如果同样的漏洞可以用来窃取用户的密码，后果将更加严重且持久.^([[75](#ftn.CHP-15-FN-6)])
    还可能出现更不明显的影响。例如，任何允许用户构建基于表单的自定义调查的应用程序都必须仔细限制生成的表单布局，否则可能会成为密码收集工具的双重角色。
- en: '* * *'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[73](#CHP-15-FN-4)]) This data may be stored on disk as a plaintext representation,
    a naïvely obfuscated string, or a properly encrypted value protected with a “master”
    password that needs to be entered beforehand. All three methods are comparably
    vulnerable to determined attackers with access to the local system, but the plaintext
    approach is sometimes frowned upon, as it is more exposed to nosy but nontechnical
    users.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[73](#CHP-15-FN-4)]) 这些数据可能以纯文本表示、天真地混淆的字符串或使用“主”密码保护的加密值的形式存储在磁盘上，该密码需要事先输入。这三种方法都相对容易受到有权访问本地系统的有决心攻击者的攻击，但纯文本方法有时会受到批评，因为它更容易暴露给好奇但非技术性的用户。
- en: ^([[74](#CHP-15-FN-5)]) Despite the name, this stops the browser from recording
    the password and not just from autocompleting it.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[74](#CHP-15-FN-5)]) 尽管名称如此，但这阻止了浏览器记录密码，而不仅仅是自动完成它。
- en: '^([[75](#CHP-15-FN-6)]) Such consequences may extend beyond the affected application:
    Even with password managers in place, password reuse is a common, unfortunate
    trend.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[75](#CHP-15-FN-6)]) 这样的后果可能超出了受影响的应用程序：即使有密码管理器的存在，密码重用仍然是一个普遍且不幸的趋势。
- en: Internet Explorer’s Zone Model
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Internet Explorer的Zone模型
- en: 'Internet Explorer’s zone model^([[234](pr03.html#ftn.CHP-15-FT-3)]) is a proprietary
    attempt to reconcile the different security requirements that users (or system
    administrators) may have for different types of web applications, for example,
    a banking page and an online game. Microsoft’s approach is to establish several
    predefined classes of websites—known as *zones*—each with its own set of configurable
    security permissions. The five supported zones are these:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer的zone模型^([[234](pr03.html#ftn.CHP-15-FT-3)]) 是一种专有尝试，旨在解决用户（或系统管理员）对不同类型Web应用程序可能具有的不同安全需求，例如，银行页面和在线游戏。微软的方法是建立几个预定义的网站类别——称为*zones*——每个类别都有自己的可配置安全权限集。支持的五个区域如下：
- en: '**My computer (aka local machine)** This hidden zone is used for all local
    *file:* resources (with one exception—more about it soon). The user cannot add
    or remove any elements from this set and cannot change its security settings through
    the normal user interface. Administrators and developers can modify the registry
    or use *urlmon.dll* hooks to override settings, however.'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我的电脑（即本地计算机）** 这个隐藏区域用于所有本地 *file:* 资源（有一个例外——稍后将有更多介绍）。用户不能从这个集合中添加或删除任何元素，也不能通过正常用户界面更改其安全设置。管理员和开发者可以通过修改注册表或使用
    *urlmon.dll* 钩子来覆盖设置。'
- en: '**Local intranet** This zone is meant to include trusted applications on a
    user’s local network. By default, *local intranet* enjoys many problematic privileges,
    such as unrestricted access to the system clipboard, the ability to open windows
    without an address bar, or the ability to bypass the usual frame navigation security
    checks (the descendant policy, outlined in [Chapter 11](ch11.html "Chapter 11. Life
    Outside Same-Origin Rules")). Members of this set are detected automatically using
    several configurable heuristics, and they may include destinations with non-fully
    qualified hostnames, addresses on the HTTP proxy exemption list,^([[76](#ftn.CHP-15-FN-7)])
    or remote *file:* URLs accessed over SMB. Manual inclusion of sites in this zone
    is also possible (in addition to or instead of the built-in heuristics).'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地内部网络** 这个区域旨在包括用户本地网络上的受信任应用程序。默认情况下，*本地内部网络* 拥有许多有问题的特权，例如无限制访问系统剪贴板、能够打开没有地址栏的窗口，或者能够绕过通常的框架导航安全检查（第11章中概述的后代策略）。该集合的成员会自动通过几个可配置的启发式方法检测到，它们可能包括具有非完全限定主机名的目的地、HTTP代理豁免列表上的地址，或通过SMB访问的远程
    *file:* URL。也可以手动将站点包含在这个区域中（除了或代替内置的启发式方法）。'
- en: Note
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The *local intranet* zone makes an implicit connection between a local network
    and a trusted environment. This connection is often dubious in the modern-day
    environment, especially given the prevalence of public Internet access over unencrypted
    Wi-Fi: Other uses of the network are not any more trustworthy than a random website
    hosted across the globe.'
  id: totrans-785
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*本地内部网络* 区域在本地网络和受信任环境之间建立了一个隐含的连接。在现代环境中，这种连接往往值得怀疑，尤其是在公共互联网访问普遍通过未加密的Wi-Fi的情况下：网络的其他用途并不比全球范围内的随机网站更值得信赖。'
- en: '**Trusted sites** These are nominally empty zones roughly equivalent to *local
    intranet* in terms of their security settings but managed solely by the user.
    Autodetection heuristics are unavailable, and all entries have to be created by
    hand.'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受信任的站点** 这些区域在安全设置上相当于本地内部网络，但完全由用户管理。自动检测启发式方法不可用，所有条目都必须手动创建。'
- en: '**Restricted sites** In these nominally empty zones, the user may add “untrusted”
    destinations. The default settings for these zones remove many rudimentary and
    generally harmless capabilities from the loaded content (for example, *Refresh*
    headers will not work) while offering limited security benefits.'
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受限站点** 在这些名义上为空区域中，用户可以添加“不受信任”的目的地。这些区域的默认设置从加载的内容中移除了许多基本且通常无害的功能（例如，*刷新*头将无法工作），同时提供有限的安全优势。'
- en: The practicality of this zone seems unclear. Because of the need to whitelist
    every untrusted site, the zone obviously can’t be relied upon as an alternative
    to browsing the Internet with sensible default settings for previously unseen
    destinations.
  id: totrans-788
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个区域的实际用途似乎并不明确。由于需要将每个不受信任的站点列入白名单，该区域显然不能作为对具有合理默认设置的先前未见目的地的互联网浏览的替代方案。
- en: '**Internet** This is a default zone for sites not included in any of the remaining
    categories. Its default settings match the general browser security model baseline
    discussed previously in this book.'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网** 这是未包含在任何其他类别中的站点的默认区域。其默认设置与本书之前讨论的通用浏览器安全模型基准相匹配。'
- en: The concept of zones, coupled with some of their security controls, seems to
    be a step in the right direction. For example, it allows system administrators
    to fine-tune the permissions for *file:* documents without affecting the security
    or convenience of normal browsing—or to prohibit Internet sites from navigating
    to local, corporate systems (using the setting named “Websites in less privileged
    web content zone can navigate into this zone”). Unfortunately, the actual implementation
    of the zone model is muddied by a lack of focus, and in practice, it is misused
    more often than it is genuinely benefited from.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 区域的概念，加上它们的一些安全控制，似乎是一个正确的方向。例如，它允许系统管理员在不影响正常浏览的安全或便利性的情况下，对*文件:*文档的权限进行微调——或者禁止互联网站点导航到本地、企业系统（使用名为“受限制的网站内容区域中的网站可以导航到该区域”的设置）。不幸的是，区域模型的实际实现由于缺乏重点而变得混乱，在实践中，它被误用的频率比真正从中受益的频率要高。
- en: 'The first problem evident to anyone trying to master the zone mechanism is
    its obtuse terminology and the almost-comical complexity of many of the settings.
    Every zone comes with over 100 checkboxes; some of these will alter the browser
    security model profoundly, while others have no security consequences whatsoever.
    (The aforementioned *Refresh* setting is one example of a security no-op; the
    ability to disable form submission is another.) These two classes of settings
    are not distinguished in any clear way, and many are nearly impossible to comprehend
    at a glance. For example, the option “Binary and script behaviors” can be set
    to “enable” or “disable,” but the help subsystem offers no information about what
    either setting will actually do. The only explanation is provided in the official
    developer documentation posted on Microsoft’s site—but even this document can
    confuse.^([[235](pr03.html#ftn.CHP-15-FT-4)]) See for yourself:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何试图掌握区域机制的人来说，第一个明显的问题是其晦涩的术语以及许多设置几乎令人捧腹的复杂性。每个区域都带有超过100个复选框；其中一些会深刻地改变浏览器安全模型，而其他则完全没有安全后果。（上述的*刷新*设置就是一个安全无操作示例；禁用表单提交的能力是另一个。）这两类设置在没有任何明显的方式中区分，许多设置几乎一眼看去就难以理解。例如，选项“二进制和脚本行为”可以设置为“启用”或“禁用”，但帮助子系统没有提供关于这两个设置实际会做什么的信息。唯一的解释是在微软网站上发布的官方开发者文档中提供的——但即使是这份文档也可能让人困惑.^([[235](pr03.html#ftn.CHP-15-FT-4)])
    请自己看看：
- en: 'Internet Explorer contains dynamic binary behaviors: components that encapsulate
    specific functionality for HTML elements to which they were attached. These binary
    behaviors are not controlled by any Internet Explorer security setting, allowing
    them to work on Web pages in the Restricted Sites zone. In Windows Server 2003
    Service Pack 1, there is a new Internet Explorer security setting for binary behaviors.
    This new setting disables binary behaviors in the Restricted Sites zone by default.
    In combination with the Local Machine Lockdown security feature, it also requires
    administrative approval for binary behaviors to run in the Local Machine zone
    by default. This new binary behaviors security setting provides a general mitigation
    to vulnerabilities in Internet Explorer binary behaviors.'
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Internet Explorer 包含动态二进制行为：封装了特定功能的组件，用于附加到HTML元素上。这些二进制行为不受任何 Internet Explorer
    安全设置的约束，允许它们在受限制站点区域中的网页上工作。在 Windows Server 2003 Service Pack 1 中，有一个新的 Internet
    Explorer 安全设置用于二进制行为。这个新设置默认禁用受限制站点区域中的二进制行为。结合本地计算机锁定安全功能，它还要求默认情况下在本地计算机区域中运行二进制行为需要管理员批准。这个新的二进制行为安全设置提供了对
    Internet Explorer 二进制行为漏洞的一般缓解措施。
- en: 'There are many similar cases of settings that require a substantial effort
    to understand. For example, it is unlikely that even the most seasoned administrators
    will understand the implications of tweaking settings named “Access data sources
    across domains” or “Navigate windows and frames across different domains”. All
    this confusion has an interesting consequence: Trusted parties unintentionally
    dispense dubious advice. For example, Charles Schwab, a prominent investment bank,
    tells customers to disable the frame navigation descendant model,^([[236](pr03.html#ftn.CHP-15-FT-5)])
    essentially making HTML frames unsafe to use not only for Charles Schwab but also
    for any other website. One of the sites maintained by the Internal Revenue Service
    provides the same, extremely inconsiderate tip.^([[237](pr03.html#ftn.CHP-15-FT-6)])'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多类似的设置，需要付出大量努力才能理解。例如，即使是经验最丰富的管理员也不太可能理解名为“跨域访问数据源”或“在不同域之间导航窗口和框架”的设置的含义。所有这些混乱都有一个有趣的后果：受信任的各方无意中提供了可疑的建议。例如，著名的投资银行查尔斯·施瓦布（Charles
    Schwab）建议客户禁用框架导航后裔模型，^([[236](pr03.html#ftn.CHP-15-FT-5)]) 这实际上使得HTML框架不仅对查尔斯·施瓦布，而且对任何其他网站都不安全。美国国税局维护的一个网站提供了同样的、极其不体贴的建议.^([[237](pr03.html#ftn.CHP-15-FT-6)])
- en: The complexity and poor documentation of Internet Explorer’s zone settings aside,
    the other problem with the zone model is the clustering of unrelated permissions.
    The settings for *local intranet* and *trusted sites* containers enable a random
    collection of features that may be required by some trusted sites—but none of
    the trusted sites could possibly require *all* of the permissions the zone entails.
    Because of this design, adding sites to privileged zones can once more have unexpectedly
    far-ranging consequences in the case of, say, a trivial XSS flaw.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是Internet Explorer区域设置的复杂性还是文档的糟糕，区域模型的其他问题是不相关的权限的聚集。*本地 intranet* 和 *受信任站点*
    容器的设置允许随机收集一些受信任站点可能需要的特性，但没有任何受信任站点可能需要区域所包含的所有权限。正因为这种设计，将站点添加到特权区域可能会在诸如简单的XSS漏洞的情况下产生意想不到的广泛影响。
- en: Mark of the Web and Zone.Identifier
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网页标记和区域标识符
- en: 'To maintain the integrity of the zone model on downloaded files, Internet Explorer
    further utilizes two overlapping mechanisms to track the original zone information
    for any externally retrieved document:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持下载文件上区域模型的完整性，Internet Explorer 进一步利用两个重叠机制来跟踪任何外部检索文档的原始区域信息：
- en: '**Mark of the Web (MotW)** This simple pseudo-HTML tag is inserted at the beginning
    of HTML documents downloaded via Internet Explorer to indicate their initial source.^([[238](pr03.html#ftn.CHP-15-FT-7)])
    One example of a MotW tag may be *<!-- saved from url=(0024)*[http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    *-->*. The URL recorded in this tag is mapped to an appropriate zone; the document
    is then opened in a unique origin in that zone. The most important consesequence
    is that the downloaded content is isolated from other *file:* URLs.'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网页标记（MotW）** 这是一个简单的伪HTML标签，被插入到通过Internet Explorer下载的HTML文档的开头，以指示它们的初始来源.^([[238](pr03.html#ftn.CHP-15-FT-7)])
    MotW标签的一个例子可能是 *<!-- saved from url=(0024)*[http://fuzzybunnies.com/](http://fuzzybunnies.com/)
    *-->*. 此标签中记录的URL映射到相应的区域；文档随后在该区域的唯一源中打开。最重要的后果是，下载的内容与其他 *file:* URL隔离开。'
- en: Note
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The inline nature of MotW is one of its flaws. Faux tags can be pre-inserted
    by rogue parties into HTML documents downloaded through non-Internet Explorer
    browsers, saved from email clients, or downloaded by Internet Explorer with a
    non-HTML extension (and then subjected to content sniffing). Though, to be fair,
    the privileges of *file:* documents saved without any MotW tags are significant
    enough to keep attackers relatively uninterested in hopping from the *My Computer*
    zone to, say, *Local Intranet*.
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MotW的内联性质是其缺陷之一。恶意方可以通过非Internet Explorer浏览器下载的HTML文档、从电子邮件客户端保存的文档或使用非HTML扩展名下载的Internet
    Explorer（然后进行内容嗅探）预先插入假标签。尽管如此，没有MotW标签保存的 *file:* 文档的权限已经足够大，以至于攻击者相对不感兴趣从 *我的电脑*
    区域跳转到，比如说，*本地 intranet* 区域。
- en: '**Alternate Data Stream (ADS) Zone Identifier** This is a piece of NTFS metadata
    attached by Internet Explorer (and Chrome) to every downloaded file, indicating
    the numerical code of the zone the file was retrieved from.^([[239](pr03.html#ftn.CHP-15-FT-8)])
    The *Zone.Identifier* mechanism is less portable than MotW, and the information
    is lost when files are saved to non-NTFS filesystems. However, it is also more
    versatile, as it can be applied to non-HTML documents.'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交替数据流（ADS）区域标识符** 这是一段由Internet Explorer（以及Chrome）附加到每个下载文件的NTFS元数据，指示文件检索来源的区域数值代码.^([[239](pr03.html#ftn.CHP-15-FT-8)])
    与MotW相比，*Zone.Identifier*机制的可移植性较差，当文件保存到非NTFS文件系统时，信息会丢失。然而，它也更加灵活，因为它可以应用于非HTML文档。'
- en: '*Zone.Identifier* metadata is recognized by Internet Explorer itself, by the
    Windows GUI shell, and by some other Microsoft products, but third-party software
    almost universally ignores it. Where it is supported, it may result in a more
    restrictive security policy being applied to the document; more commonly, it just
    pops up a security warning about the unspecified risks of opening Internet-originating
    data.'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*Zone.Identifier*元数据被Internet Explorer自身、Windows GUI外壳和某些其他Microsoft产品所识别，但第三方软件几乎普遍忽略它。在它被支持的地方，它可能会导致对文档应用更严格的安全策略；更常见的是，它只会弹出一个关于打开源自互联网数据的未指定风险的安全警告。'
- en: Security Engineering Cheat Sheet
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: When Requesting Elevated Permissions from Within a Web Application
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Web应用程序内请求提升权限时
- en: Keep in mind that requesting access to geolocation data, video or microphone
    feeds, and other privileged APIs comes with responsibility. If your site is prone
    to XSS vulnerabilities, you are gambling not only with the data stored in the
    application but with the privacy of your users. Plan accordingly and compartmentalize
    the privileged functionality well. Never ask your users to lower their Internet
    Explorer security settings to accommodate your application, and do not blindly
    follow this advice when given by others—no matter who they are.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，请求访问地理位置数据、视频或麦克风流以及其他特权API伴随着责任。如果你的网站容易受到XSS漏洞的影响，你不仅是在冒险应用程序中存储的数据，还在冒险用户的隐私。相应地规划，并妥善隔离特权功能。永远不要要求你的用户降低他们的Internet
    Explorer安全设置以适应你的应用程序，并且当别人给出这样的建议时，不要盲目跟随——无论他们是谁。
- en: When Writing Plug-ins or Extensions That Recognize Privileged Origins
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写识别特权来源的插件或扩展时
- en: You are putting your users at elevated risk due to inevitable web application
    security bugs. Design APIs robustly and try to use secondary security measures,
    such as cryptography, to further secure communications with your server. Do not
    whitelist nonencrypted origins, as they are prone to spoofing on open wireless
    networks.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在让你的用户面临由于不可避免的Web应用程序安全漏洞而提高的风险。设计健壮的API，并尝试使用二级安全措施，如加密，以进一步保护与服务器通信。不要将未加密的来源列入白名单，因为它们容易在开放的无线网络上被欺骗。
- en: '* * *'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[76](#CHP-15-FN-7)]) In configurations where a proxy is required to access
    protected internal systems but not required to access the Internet, these may
    have the unintended and scary effect of classifying the entire Web as a local
    network.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[76](#CHP-15-FN-7)]) 在需要代理才能访问受保护内部系统但不需要访问互联网的配置中，这些配置可能会产生意想不到且令人恐惧的效果，将整个网络分类为本地网络。
