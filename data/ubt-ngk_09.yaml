- en: Chapter 9. SIMPLE KITTEN WAYS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 简单的小猫方式
- en: Getting to Know the Linux Terminal and Command Line . . . and the Cool Things
    It Can Do
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解Linux终端和命令行……以及它能做的酷事
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages656092.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages656092.png.jpg)'
- en: Many people shy away from Linux because they envision it as a system for compu-geeks,
    an environment in which you do everything the hard way—by command line. In this
    era of graphical interfaces, the idea of typing commands to get things done seems
    like a dreadful throwback to the days of DOS, and that puts many people off, especially
    those who remember what it was like in the "old days."
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人避开Linux，因为他们将其视为一个为电脑极客设计的系统，一个你必须通过命令行以艰难方式做所有事情的的环境。在这个图形界面时代，通过输入命令来完成事情的想法似乎是对DOS时代的可怕回归，这让很多人望而却步，尤其是那些记得“旧时光”的人。
- en: This reaction is fair enough, but it is not really an accurate reflection of
    the reality of the Linux world. After all, most Linux users today utilize some
    sort of graphical interface. They can, and often do, achieve all that they hope
    to achieve through drop-down menus and mouse clicks alone. Many are able to survive
    quite happily without ever once opening their Terminal. The same could be true
    of you.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反应是合理的，但它并不真正准确地反映了Linux世界的现实。毕竟，今天的大多数Linux用户都在使用某种图形界面。他们可以，并且经常只通过下拉菜单和鼠标点击就能实现他们希望实现的一切。许多人能够非常快乐地生活，甚至从未打开过他们的终端。对你来说也可能如此。
- en: Be that as it may, there is still much to be said for the power and convenience
    of the command line. The fact that the command line can now be utilized within
    a graphical environment also makes it much less forbidding. The Terminal is just
    a tiny text-based island in a sea of graphical bodies (see [Figure 9-1](ch09.html#putting_the_terminal_in_perspective
    "Figure 9-1. Putting the Terminal in perspective")). Using the command line can
    be as pain-free as anything else you do on your system, and it can actually provide
    you with a little fun if you are willing to give it a try.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，命令行的强大和便利性仍然有很多可说的。命令行现在可以在图形环境中使用，这也使得它不那么令人畏惧。终端只是图形世界中的一小块基于文本的岛屿（参见[图9-1](ch09.html#putting_the_terminal_in_perspective
    "图9-1. 将终端置于视角中")). 使用命令行可以像你在系统上做的任何其他事情一样不痛苦，而且如果你愿意尝试，它实际上可以给你带来一些乐趣。
- en: '![Putting the Terminal in perspective](httpatomoreillycomsourcenostarchimages656363.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![将终端置于视角中](httpatomoreillycomsourcenostarchimages656363.png.jpg)'
- en: Figure 9-1. Putting the Terminal in perspective
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-1. 将终端置于视角中
- en: Unfortunately, many guides to using the command line are written by hard-core
    command-line junkies, whose enthusiasm for what they see as a really good thing
    inadvertently makes what they write seem even more off-putting to the recent Linux
    immigrant or wanna-be.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，许多关于使用命令行的指南都是由那些对命令行作为真正的好东西充满热情的硬核命令行爱好者所写，他们的热情无意中使得他们对新来的Linux移民或想要成为Linux用户的人所写的内容看起来更加令人反感。
- en: For your sake, I will try to curb my own enthusiasm so as not to scare you right
    back to [Chapter 6](ch06.html "Chapter 6. ROUNDING OUT THE BIRD") and the more
    comfortable world of the Ubuntu Software Center. I will also try to help you keep
    things in perspective by teaching you, whenever possible, to use the command line
    as a complement to the various graphical tools that you have at your disposal,
    rather than presenting it as the sole way of going about things. Of course, I
    am not going to cover every possible angle in this regard—just enough to give
    you some exposure and experience and, ideally, make you feel at least a little
    more at ease with the command line. Who knows; could you actually come to think
    of using the command line as . . . fun? Well, I won't get too carried away.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了你的利益，我会尽量抑制自己的热情，以免让你再次被吓回到[第6章](ch06.html "第6章. 完善鸟")和Ubuntu软件中心这个更舒适的世界。我还会尽量通过教你，在可能的情况下，将命令行作为你拥有的各种图形工具的补充来使用，而不是将其作为唯一的方法来处理事情。当然，我并不会涵盖这个方面的每一个可能的角度——只是足够让你有一些接触和经验，并且理想情况下，让你对命令行至少感到稍微自在一些。谁知道呢；你实际上会不会开始认为使用命令行是……有趣的？好吧，我不会太过分。
- en: Meet the Terminal
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识终端
- en: You can run the Linux command-line Terminal application in your Ubuntu system
    by selecting **Applications** ▸ **Accessories** ▸ **Terminal**. When the Terminal
    opens, it will, in all its simplicity, look much like [Figure 9-2](ch09.html#the_terminal_application
    "Figure 9-2. The Terminal application").
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Ubuntu系统中选择**应用程序** ▸ **附件** ▸ **终端**来运行Linux命令行终端应用程序。当终端打开时，它将以其所有的简单性，看起来与[图9-2](ch09.html#the_terminal_application
    "图9-2. 终端应用程序")非常相似。
- en: '![The Terminal application](httpatomoreillycomsourcenostarchimages656365.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![终端应用程序](httpatomoreillycomsourcenostarchimages656365.png.jpg)'
- en: Figure 9-2. The Terminal application
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-2. 终端应用程序
- en: 'As you can see, all it says is `rg@rg-desktop:˜$`. In this case, `rg` is my
    username, `rg-desktop` is the name I gave my computer during installation, and
    the tilde (`˜`) signifies that I am in my home folder. If it were to say `˜/Music`,
    for example, it would mean that I am currently in the *Music* folder within my
    home folder. Of course, all this will be different in your case, because your
    username and computer name will be different. If your username is *frog* and your
    computer''s name is *wetrock*, for example, the command line will say `frog@wetrock:˜$`.
    If all this is sounding rather obtuse to you, just think of it this way: *`user-name`*`@`*`computer_name`*`:˜$`
    in the Terminal is the equivalent of your home folder in Nautilus.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它只显示`rg@rg-desktop:˜$`。在这种情况下，`rg`是我的用户名，`rg-desktop`是我安装时给电脑取的名字，波浪号（`˜`）表示我正在我的主目录中。如果它显示`˜/Music`，例如，那就意味着我目前在我的主目录中的*Music*文件夹内。当然，所有这些在你那里都会有所不同，因为你的用户名和电脑名会不同。例如，如果你的用户名是*frog*，电脑名是*wetrock*，那么命令行将显示`frog@wetrock:˜$`。如果这一切听起来相当晦涩难懂，就想想这样：在终端中，`*user-name*``@``*computer_name*``:˜$`相当于在Nautilus中的你的主目录。
- en: 'Typing in the Terminal is straightforward enough; you just type as you usually
    do. You can also delete and insert letters or phrases by using the **delete**
    and **backspace** keys and the arrow keys. For practice, try the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入非常简单；你只需像平时一样输入即可。你也可以通过使用**删除**和**退格**键以及箭头键来删除和插入字母或短语。为了练习，尝试以下操作：
- en: Type **`I like strawberries so very much`**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`我喜欢草莓非常非常地喜欢`**。
- en: Change `strawberries` to `cherries` (because cherries are, in fact, so much
    better). Just use your left arrow key to move the cursor in front of the first
    *s* in `strawberries`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`strawberries`改为`cherries`（因为实际上樱桃要好得多）。只需使用你的左箭头键将光标移动到`strawberries`中的第一个*s*之前。
- en: Tap your **delete** key as many times as necessary to erase the word `strawberries`
    (uh, that would be 12 times, methinks).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**删除**键，直到将单词`strawberries`删除（我想是12次）。
- en: Type **`cherries`**, and then use your right arrow key to move the cursor back
    to the end of this meaningful sentence.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cherries`**，然后使用你的右箭头键将光标移回这个有意义的句子的末尾。
- en: 'Now that you''ve completed this fascinating bit of typing practice, press the
    **enter** key. As you will almost immediately see, the Terminal''s response to
    your efforts thus far is merely a dismissive `I: command not found`. Although
    you''ve typed a string of text that has meaning to you, it means absolutely nothing
    to your system. In fact, the system was so shortsighted that it could see nothing
    other than the first word you typed in the Terminal (`I`); and because `I` is
    not a valid command, the system had no idea what do to with it.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经完成了这个有趣的打字练习，按**回车**键。你几乎会立即看到，终端对你迄今为止所做努力的回应只是一个轻蔑的`I: 命令未找到`。尽管你输入了一串对你有意义的文本，但对你的系统来说，这毫无意义。事实上，系统如此短视，除了你在终端中输入的第一个词（`I`）之外，什么也看不到；因为`I`不是一个有效的命令，系统不知道该如何处理它。'
- en: Some Goofy Yet Useful Fun with the Command Terminal
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与命令终端的一些古怪但有用的乐趣
- en: A rather cool thing about typing in the command Terminal is that it has what
    you might call *short-term memory*. Try it by typing the word **`cherry`** and
    then pressing **enter**. Ignoring the command-not-found message, go on and type
    **`vanilla`**, and press **enter**. Now type **`gelato`**, and press **enter**.
    So far, so dumb, right? Well, not really. Let's type everything we've typed thus
    far again, but this time let's do it with only one key.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令终端中打字的一个相当酷的事情是它有所谓的*短期记忆*。通过输入单词**`cherry`**并按**回车**来尝试。忽略命令未找到的消息，继续输入**`vanilla`**并按**回车**。现在输入**`gelato`**并按**回车**。到目前为止，这似乎很愚蠢，对吧？但实际上并非如此。让我们再次输入我们迄今为止输入的所有内容，但这次只使用一个键。
- en: Huh?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 哎？
- en: Yes, just press the up arrow key once, and what do you see? That's right—the
    last command you typed appears, which in this case would be `gelato`. Press the
    up arrow key again, and the command that you typed before that will appear—`vanilla`.
    One more time? Yes, `cherry`. And one more time for the grand finale . . . `I
    like cherries so very much`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，只需按一次上箭头键，你看到了什么？没错——你最后输入的命令出现了，在这个例子中就是`gelato`。再按一次上箭头键，你之前输入的命令就会出现——`vanilla`。再来一次？是的，`cherry`。再来一次，作为高潮……`I
    like cherries so very much`。
- en: 'Considering what we have thus far, this may all seem a bit silly, but imagine
    that you''re not typing goofy little words and instead have to deal with considerably
    longer strings, such as a simple copy command (which you''ll learn about later
    in this chapter) like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们到目前为止所学的，这一切可能看起来有点愚蠢，但想象一下，你不是在输入愚蠢的小词，而是必须处理相当长的字符串，比如一个简单的复制命令（你将在本章后面学到）：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By typing that string, you are copying an image called *onthebeach1_27.jpg*
    from the *coastal* folder to another folder called *stpierre*. If you wanted to
    copy another photo in the *coastal* folder, *onthebeach1_16.jpg*, for instance,
    you could simply press the up arrow key once, use the left arrow key and **delete**
    key to move over to and delete the `27`, and replace it with **`16`**. All in
    all, it would be much simpler and much faster. It would also help you avoid mistakes
    in typing. Not so dumb anymore, eh?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入那个字符串，你正在将名为*onthebeach1_27.jpg*的图片从*coastal*文件夹复制到另一个名为*stpierre*的文件夹中。如果你想从*coastal*文件夹复制另一张照片，比如*onthebeach1_16.jpg*，你可以简单地按一次上箭头键，使用左箭头键和**delete**键移动到并删除`27`，然后替换成**`16`**。总的来说，这将更加简单和快速。它还可以帮助你避免输入错误。不再那么愚蠢，对吧？
- en: Nontoxic Commands
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无毒命令
- en: As you now know, all of this typing is easy enough, but to actually do something
    useful with your Terminal, you need to type commands—and there are more of them
    than you could ever hope or need to know. To get you started, we will begin with
    some commands that are easy to understand, nontoxic, and completely kitten-friendly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，所有这些输入都是足够简单的，但要在你的终端中实际做些有用的事情，你需要输入命令——而且命令的种类比你希望或需要的要多。为了让你开始，我们将从一些容易理解、无毒且完全适合猫咪友好的命令开始。
- en: $ whoami
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ whoami
- en: There is no command as easy, safe, or even as seemingly useless as `whoami`.
    Rather than help those with multiple-personality disorders discover who they are
    at any given moment, the `whoami` command simply tells you which user is currently
    logged in. Try it by typing **`whoami`** after the `$` and then pressing the **enter**
    key. Remember that commands are case sensitive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 没有命令像`whoami`这样简单、安全，甚至看似无用。`whoami`命令并不是帮助那些有多重人格障碍的人在任何时刻发现他们是谁，它只是告诉你当前登录的是哪个用户。试着在`$`后面输入**`whoami`**然后按**enter**键。记住，命令是区分大小写的。
- en: The Terminal will now tell you the username of the person currently logged in.
    If you are logged in as *frog*, you should get `frog` as the answer to your command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 终端现在会告诉你当前登录的人的用户名。如果你以*frog*登录，你应该得到命令的答案是`frog`。
- en: $ finger
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ finger
- en: If you enjoyed discovering who you are with the `whoami` command, then you might
    enjoy finding out even more about yourself using the `finger` command. You can
    use the `finger` command in a number of ways, but a very simple one is finding
    out about a particular user. Try this on yourself by typing **`finger`** and then
    your username. In my case, that would be **`finger rg`**. Once you've typed the
    command, press **enter**, and see what you get. You can see my results in [Figure 9-3](ch09s03.html#output_from_the_finger_command
    "Figure 9-3. Output from the finger command").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用`whoami`命令来发现你是谁，那么你可能也会喜欢使用`finger`命令来了解更多关于自己的信息。你可以以多种方式使用`finger`命令，但一个非常简单的方式是了解某个特定的用户。试着对自己做这个实验，输入**`finger`**然后输入你的用户名。以我的情况为例，就是**`finger
    rg`**。一旦你输入了命令，按下**enter**键，看看你得到了什么。你可以在[图9-3](ch09s03.html#output_from_the_finger_command
    "图9-3. `finger`命令的输出")中看到我的结果。
- en: '![Output from the finger command](httpatomoreillycomsourcenostarchimages656367.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![`finger`命令的输出](httpatomoreillycomsourcenostarchimages656367.png.jpg)'
- en: Figure 9-3. Output from the `finger` command
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-3. `finger`命令的输出
- en: As you can see, my login name is *rg*, my real name is Rickford Grant, my home
    directory is */home/rg*, and I am using the Bash shell for typing my commands.
    I have been logged on since Wednesday, April 14, at 19:59 Eastern daylight time
    (EDT), and I've had my Terminal session open since Thursday, April 15, at 19:26\.
    I have no mail or plan. It doesn't tell you my Social Security number or my mother's
    maiden name, but it is pretty cool, don't you think?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我的登录名是*rg*，我的真实姓名是Rickford Grant，我的主目录是*/home/rg*，我正在使用Bash shell来输入我的命令。我从4月14日星期三的19:59东部标准时间（EDT）开始登录，我的终端会话从4月15日星期四的19:26开始。我没有邮件或计划。它不会告诉你我的社会保险号码或我母亲的婚前名字，但确实很酷，不是吗？
- en: What Is a Shell?
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是shell？
- en: As you noticed, I mentioned that the results of the `finger` command showed
    I was using the Bash shell, so you may be understandably wondering just what Bash
    is. Well, Bash (Bourne Again Shell) is one of the many shells that are used in
    Linux systems, and it's the one that happens to come with your Ubuntu distro (and
    most others, for that matter). A *shell* is a program that interprets the commands
    you type into the Terminal and delivers them, so to speak, to your system so that
    it can act upon them. I like to think of it as a command-handling subsystem, for
    which the Terminal acts as a graphical frontend.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所注意到的，我提到`finger`命令的结果显示我正在使用Bash shell，因此你可能很自然地想知道Bash究竟是什么。好吧，Bash（Bourne
    Again Shell）是Linux系统中使用的许多shell之一，它恰好包含在你的Ubuntu发行版（以及大多数其他发行版）中。*shell*是一个程序，它解释你在终端中输入的命令，并将它们“传递”给你的系统，以便它可以对其执行。我倾向于将其视为一个命令处理子系统，其中终端充当图形前端。
- en: What Is a Plan?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是计划？
- en: I also mentioned that the results said I had no plan, so you may also be wondering
    what that is all about. A *.plan* file is a small file kept in your home folder
    that other users see when they use the `finger` command on you. Traditionally,
    a *.plan* file contained information about where you were going to be or what
    you were working on. These days, however, most people use them to leave odd little
    messages, quotations, or whatever, much as they do in email signatures. Take a
    look at [Figure 9-4](ch09s03.html#output_from_the_finger_command_with_a_pl "Figure 9-4. Output
    from the finger command with a plan") to see what happens after I add a *.plan*
    file to my home folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我还提到结果显示我没有计划，因此你可能也在想这究竟是怎么回事。*.plan*文件是一个保存在你主目录中的小文件，当其他用户使用`finger`命令查看你时可以看到它。传统上，*.plan*文件包含有关你将去哪里或你在做什么的信息。然而，如今，大多数人使用它们来留下奇怪的小信息、引言或
    whatever，就像他们在电子邮件签名中做的那样。看看[图9-4](ch09s03.html#output_from_the_finger_command_with_a_pl
    "图9-4. 使用计划后的finger命令输出")，看看我在主目录中添加*.plan*文件后会发生什么。
- en: '![Output from the finger command with a plan](httpatomoreillycomsourcenostarchimages656369.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用计划后的finger命令输出](httpatomoreillycomsourcenostarchimages656369.png.jpg)'
- en: Figure 9-4. Output from the `finger` command with a plan
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-4. 使用计划后的`finger`命令输出
- en: You can now see my plan, which is a quotation from Kurt Vonnegut's *The Sirens
    of Titan* (or Al Stewart's song by the same name, for that matter), though you
    can put anything you want in your own. You will get the chance to create your
    own plan file in Project 9A, so if this all seems fun to you, just hang in there.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到我的计划，这是一句来自库尔特·冯内古特《泰坦的号角》（或同名歌曲Al Stewart）的引言，尽管你可以放入你想要的任何内容。在项目9A中，你将有机会创建自己的计划文件，所以如果这一切看起来很有趣，就坚持下去吧。
- en: Before moving on, I should mention that you can also use the `finger` command
    to do a little domestic espionage of sorts. Let's say your child, Chris, has a
    user account on your machine. Chris, who wants your permission to go to the movies,
    claims to have been hard at work on the computer all day writing a report for
    school. Having your doubts, you could type **`finger chris`** to see what the
    facts actually are. It may be a bit underhanded and rotten, but it works. It also
    works both ways; others can check up on you as well. You can try it by seeing
    when the last time you logged in to your graphika account was (assuming you created
    such an account in [Chapter 8](ch08.html "Chapter 8. DRESSING UP THE BIRD")).
    Just type **`finger graphika`**, and then press **enter**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我应该提到，你也可以使用`finger`命令进行某种程度的家庭间谍活动。假设你的孩子Chris在你的机器上有一个用户账户。Chris想要你的允许去看电影，声称他整天都在电脑上写学校的报告。如果你对此表示怀疑，你可以键入**`finger
    chris`**来查看实际情况。这可能有点不光彩和卑鄙，但它有效。这也同样适用于双方；其他人也可以检查你。你可以通过查看你上次登录到你的graphika账户的时间来尝试（假设你在[第8章](ch08.html
    "第8章. 美化鸟儿"))中创建了这样一个账户）。只需键入**`finger graphika`**，然后按**回车键**。
- en: You can even use the `finger` command to find out facts about people on other
    systems, providing their network's finger service is active and you know their
    email address. Typing something like **`finger`** *`username@hostname.com`* would
    do the trick. It's kind of cool but also kind of spooky, I suppose.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用`finger`命令来了解其他系统上的人的信息，前提是他们的网络上的finger服务是活跃的，并且你知道他们的电子邮件地址。键入类似**`finger`**
    *`username@hostname.com`*的内容就可以做到这一点。这有点酷，但也有一点令人毛骨悚然，我想。
- en: $ pwd
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ pwd`'
- en: If you know who you are but aren't exactly sure where you are, `pwd` (print
    working directory) should come in handy. The `pwd` command tells you exactly where
    the Terminal is in your directory tree.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道自己是谁，但不确定自己在哪里，`pwd`（打印工作目录）应该会很有用。`pwd`命令会告诉你终端在你的目录树中的确切位置。
- en: Let's say, for example, that my Terminal is in my personal home directory (which
    is actually called *rg*) in the system's home directory (which is actually called
    *home* and which is where all the user account directories are located) when I
    use the `pwd` command; I would, after pressing the **enter** key, get `/home/rg`
    printed to my Terminal. You should get similar results if you try it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，当我使用`pwd`命令时，我的终端位于系统主目录下的个人主目录（实际上称为*rg*）中（实际上称为*home*，这里是所有用户账户目录的位置）；按下**回车键**后，`/home/rg`会显示在我的终端上。如果你尝试这样做，应该会得到类似的结果。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The word *print*, in this case, has nothing to do with your printer; it merely
    means that the response will be printed to, or displayed in, the Terminal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，单词*print*与你的打印机无关；它仅仅意味着响应将被打印到，或在终端中显示。
- en: $ df
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`$ df`'
- en: Another safe and easy, but much more useful, command is `df` (disk filesystem).
    The `df` command tells you how much disk space you have used, as well as how much
    space you still have available, on each of the partitions on your various mounted
    disks. Try it by typing **`df`** and then pressing **enter**. Your output should
    look something like that shown in [Figure 9-5](ch09s03.html#output_from_the_df_command
    "Figure 9-5. Output from the df command") (depending, of course, on the size of
    your mounted disks and how they are set up).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个既安全又简单，但非常有用的命令是`df`（磁盘文件系统）。`df`命令会告诉你你在各个挂载的磁盘的每个分区上使用了多少磁盘空间，以及你还剩下多少可用空间。通过键入**`df`**然后按**回车键**来尝试。你的输出应该看起来像[图9-5](ch09s03.html#output_from_the_df_command
    "图9-5. df命令的输出")中所示的那样（当然，这取决于你挂载的磁盘的大小和它们的设置）。
- en: '![Output from the df command](httpatomoreillycomsourcenostarchimages656371.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![df命令的输出](httpatomoreillycomsourcenostarchimages656371.png.jpg)'
- en: Figure 9-5. Output from the `df` command
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-5. `df`命令的输出
- en: As you will notice, the sizes are given in kilobytes (KB) rather than the gigabytes
    (GB) and megabytes (MB) you are probably more used to, but there is a way around
    this. Many commands accept a *flag*, or *option*, to further fine-tune how the
    command performs. These flags are written directly after the main command and
    are preceded by a space and a hyphen.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，大小是以千字节（KB）而不是你更熟悉的千兆字节（GB）和兆字节（MB）给出的，但有一种方法可以解决这个问题。许多命令接受一个*标志*或*选项*来进一步微调命令的执行方式。这些标志直接写在主命令之后，并且前面有一个空格和一个连字符。
- en: In this case, you can try using the `-h` (human readable) flag to have your
    figures come out in the way you are most familiar with. Try this by typing **`df
    -h`** on the command line and pressing **enter**. The output should now appear
    in a more familiar format (see [Figure 9-6](ch09s03.html#output_from_the_df_command_with_the_-h_f
    "Figure 9-6. Output from the df command with the -h flag")).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以尝试使用`-h`（人类可读）标志，让你的数字以你最熟悉的方式显示。通过在命令行中输入**`df -h`**并按**enter**键来尝试这个。输出现在应该以更熟悉的形式出现（见[图9-6](ch09s03.html#output_from_the_df_command_with_the_-h_f
    "图9-6. df命令带有-h标志的输出")）。
- en: '![Output from the df command with the -h flag](httpatomoreillycomsourcenostarchimages656373.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![df命令带有-h标志的输出截图](httpatomoreillycomsourcenostarchimages656373.png.jpg)'
- en: Figure 9-6. Output from the `df` command with the `-h` flag
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6. df命令带有-h标志的输出
- en: $ ls
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ ls
- en: Another harmless but handy command is `ls` (list directory contents). The `ls`
    command shows you what is in your current directory. This is the nongraphical
    equivalent of double-clicking a folder in Nautilus to see what is inside. Try
    it by typing **`ls`** and then pressing the **enter** key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个无害但实用的命令是`ls`（列出目录内容）。`ls`命令显示你当前目录中的内容。这是在Nautilus中双击文件夹以查看里面的内容的非图形等效操作。通过输入**`ls`**然后按**enter**键来尝试它。
- en: If you've been following *my* commands so far, your results should list all
    of the folders in your home directory. You can also use the `-R` flag to show
    not only the list of files in the folder but also what is within the subfolders.
    Of course, you should have no subfolders in any of the folders you created in
    [Chapter 7](ch07.html "Chapter 7. A TIDY NEST") and [Chapter 8](ch08.html "Chapter 8. DRESSING
    UP THE BIRD"), so you can hold off experimenting with this for a while. Instead,
    try typing **`ls -a`** to see your invisible, or *hidden*, files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直按照*我的*命令来做，你的结果应该会列出你主目录中的所有文件夹。你也可以使用`-R`标志来显示文件夹中的文件列表以及子文件夹中的内容。当然，你应该在你的[第7章](ch07.html
    "第7章。整洁的巢穴")和[第8章](ch08.html "第8章。打扮鸟儿")中创建的任何文件夹中都没有子文件夹，所以你可以暂时不进行实验。相反，尝试输入**`ls
    -a`**来查看你的不可见或*隐藏*的文件。
- en: $ calendar
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ calendar
- en: I'll let you experiment with this one on your own. Just type **`calendar`**,
    and press **enter** to see the somewhat interesting results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我会让你自己尝试这个。只需输入**`calendar`**，然后按**enter**键，看看那些有点意思的结果。
- en: $ exit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ exit
- en: The `exit` command is a simple one that allows you to exit the Terminal. Just
    type **`exit`**, and press **enter**. The Terminal window will close.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`命令是一个简单的命令，允许你退出终端。只需输入**`exit`**，然后按**enter**键。终端窗口将会关闭。'
- en: Commands with Some Teeth
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有牙齿的命令
- en: The simple commands you have tried so far are all of the safe-and-sane, fire
    marshal–approved variety; they merely print information to your Terminal. Now
    you are going to try to get some real tangible results from the commands you use.
    These commands are also essentially safe and sane if you follow my instructions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止尝试的简单命令都是安全且理智的，消防队长批准的品种；它们只是将信息打印到你的终端。现在你将尝试从你使用的命令中获得一些真正的可触摸的结果。如果你遵循我的指示，这些命令基本上也是安全且理智的。
- en: $ mkdir
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ mkdir
- en: You have already learned how to create folders by means of menus and your mouse,
    but you can also do this using the command line. The command is `mkdir` (make
    directory), and it is easy as pie to use (though I've never been quite sure how
    pie is easy).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会了如何通过菜单和鼠标创建文件夹，但你也可以使用命令行来完成。命令是`mkdir`（创建目录），使用起来就像吃派一样简单（尽管我从未完全确定派是怎么简单的）。
- en: To see how this command works and to work with the commands that follow, use
    the `mkdir` command now to create a folder called *command_exp* (for command experiments).
    All you have to do is type **`mkdir command_exp`** in a new Terminal window and
    press **enter**. The new folder should appear in your home folder, so go ahead
    and check to see whether it is there by clicking the home icon on your desktop.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个命令的工作原理以及使用接下来的命令，现在使用`mkdir`命令创建一个名为*command_exp*（用于命令实验）的文件夹。你只需要在新的终端窗口中输入**`mkdir
    command_exp`**并按**enter**键。新文件夹应该出现在你的主目录中，所以你可以点击桌面上的主图标来检查它是否在那里。
- en: OK, good, *bra*, *bueno*! Now let's create another new folder within that new
    folder—a *subfolder*, if you will. We'll call this one *sub*. So, just type **`mkdir
    command_exp/sub`**, and press **enter**. You can now take a peek and see whether
    the *sub* folder appears within the *command_exp* folder, if you like.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，*bra*，*bueno*！现在让我们在那个新文件夹内创建另一个新的文件夹——一个 *subfolder*，如果你愿意。我们将称这个为 *sub*。所以，只需输入
    **`mkdir command_exp/sub`**，然后按 **enter**。现在你可以查看 *sub* 文件夹是否出现在 *command_exp*
    文件夹内，如果你喜欢的话。
- en: $ mv
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ mv
- en: The next command is the `mv` (move) command, but before you experiment with
    it, you need to create a dummy file—you need something to move, after all. You
    can do this by using another command—`touch`. To make the file—let's call it *expfile.txt—*go
    to the Terminal, type **`touch expfile.txt`**, and press **enter**. The new file
    will now appear in your home folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令是 `mv`（移动）命令，但在你尝试它之前，你需要创建一个虚拟文件——毕竟你需要一些东西来移动。你可以通过使用另一个命令——`touch` 来做到这一点。为了创建文件——让我们称它为
    *expfile.txt*——前往终端，输入 **`touch expfile.txt`**，然后按 **enter**。新文件现在将出现在你的主文件夹中。
- en: To move the file that you've just created, you will use the `mv` command, of
    course. Just type **`mv expfile.txt command_exp/sub`** (this tells the system
    which file to move and where to move it to), and press **enter**. The file will
    now be in your *sub* folder.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动你刚刚创建的文件，你当然会使用 `mv` 命令。只需输入 **`mv expfile.txt command_exp/sub`**（这告诉系统哪个文件要移动以及移动到哪里），然后按
    **enter**。现在文件将位于你的 *sub* 文件夹中。
- en: $ cd
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ cd
- en: Until now, you have been using the command line from your home folder. With
    the `cd` command, you can change your Terminal's location to another folder. This
    is a very handy command that you will be using quite a lot when doing the projects
    in this book. To take it out for a spin, let's get inside the *command_exp* folder
    by typing **`cd command_exp`** and pressing **enter**. If you've done this correctly,
    the prompt in your Terminal should now read *`username`*`@`*`computer_name`*`:˜/command_exp$`.
    If so, you can pat yourself on the back.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用从你的主文件夹开始的命令行。使用 `cd` 命令，你可以将终端的位置更改为另一个文件夹。这是一个非常实用的命令，你将在本书的项目中经常使用它。为了试一试，让我们通过输入
    **`cd command_exp`** 并按 **enter** 来进入 *command_exp* 文件夹。如果你做得正确，你的终端提示符现在应该显示为
    *`username`*`@`*`computer_name`*`:˜/command_exp$`。如果是这样，你可以给自己鼓掌。
- en: While you are there, you might as well try the `ls` command with the `R` (recursive)
    flag to see how that works. Just type **`ls -R`**, and press **enter**. Your Terminal
    should now show that you have a subfolder there called *sub* and a file inside
    that subfolder called *expfile.txt*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你身处其中时，不妨尝试使用带有 `R`（递归）标志的 `ls` 命令来看看它是如何工作的。只需输入 **`ls -R`**，然后按 **enter**。现在你的终端应该会显示你有一个名为
    *sub* 的子文件夹，以及该子文件夹内有一个名为 *expfile.txt* 的文件。
- en: That is all you really want to do in there for now, so to get back to your home
    directory, just type **`cd`** and press **enter**, which will take you back home,
    so to speak.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你真正想要做的就这么多，所以为了回到你的主目录，只需输入 **`cd`** 并按 **enter**，这样你就可以“回家”了。
- en: For future reference, it is worth noting a couple of other `cd` command shortcuts.
    If you are within a subfolder of a subfolder and want to move back a step (from
    */home/rg/peas/pudding* to */home/rg/peas*, for example), you can do so by typing
    **`cd ..`** (with a space between `cd` and `..`) and pressing **enter**. You can
    also type **`cd -`** (with a space between `cd` and `-`) in order to get back
    to a directory where you were previously (from */home/rg* to */home/rg/peas/pudding*,
    for example).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将来参考，值得注意的是几个其他的 `cd` 命令快捷键。如果你在一个子文件夹的子文件夹内，并且想要退回一步（例如从 */home/rg/peas/pudding*
    退回到 */home/rg/peas*），你可以通过输入 **`cd ..`**（在 `cd` 和 `..` 之间有一个空格）并按 **enter** 来做到这一点。你也可以输入
    **`cd -`**（在 `cd` 和 `-` 之间有一个空格）以便回到你之前所在的目录（例如从 */home/rg* 回到 */home/rg/peas/pudding*）。
- en: $ cp
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ cp
- en: Being fickle, as humans are by nature, you might decide that not only do you
    want your *expfile.txt* file in the subfolder but that you also want a copy in
    your home directory, where it was in the first place. To copy *expfile.txt*, you
    can use the `cp` (copy) command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人类天生多变，你可能会决定不仅想在子文件夹中保留 *expfile.txt* 文件，还希望在家目录中有一个副本，那里是它最初所在的地方。要复制 *expfile.txt*，你可以使用
    `cp`（复制）命令。
- en: 'To do this, the command needs to know where the file you want to copy is, what
    it is called, and where you want to copy it, which in this case is to your home
    folder. Normally you would type `cp command_exp/sub/expfile.txt /home/`*`username`*
    to do this, but if you recall my mention of it near the beginning of this chapter,
    you can abbreviate the `/home/`*`username`* portion of the command string to `˜/`,
    which means the same thing and is an important tip to remember, because the tilde
    is frequently used in online instructions. Because reducing wear and tear on the
    fingers is always a desirable goal, type the following command, and then press
    **enter**:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，命令需要知道你想要复制的文件的位置、它的名称以及你想要复制到的位置，在这种情况下是复制到你的主文件夹。通常你会输入 `cp command_exp/sub/expfile.txt
    /home/`*`username`* 来完成这个操作，但如果你记得我在本章开头提到的，你可以将命令字符串中的 `/home/`*`username`* 部分缩写为
    `˜/`，它意味着相同的意思，这是一个重要的提示要记住，因为波浪号在在线说明中经常被使用。因为减少手指磨损总是个可取的目标，输入以下命令，然后按 **enter**
    键：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Be sure to put a space between the file you are copying and its destination
    (in this case, between `expfile.txt` and `˜/`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在你要复制的文件和它的目的地之间留一个空格（在这种情况下，在 `expfile.txt` 和 `˜/` 之间）。
- en: Once you've done this, you should have two copies of *expfile.txt*, one in your
    home folder and one in your *sub* folder. Go take a look to see the fruit of your
    endeavors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你应该有两个 *expfile.txt* 的副本，一个在你的主文件夹中，一个在你的 *sub* 文件夹中。去看看你努力的成果吧。
- en: $ rm
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ rm
- en: When you were a kid, you may well have experienced the joy of building a castle
    out of LEGO bricks and then the even greater joy of tearing the whole thing down
    (preferably by hurling D cell batteries at it). You will now embark on a similar
    move. The first tool in this nostalgic endeavor is the `rm` (remove) command,
    with which you can trash files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还是一个孩子的时候，你可能已经体验过用乐高积木建造城堡的乐趣，然后是拆毁整个建筑的更大乐趣（最好是朝它扔去D型电池）。现在，你将开始类似的行动。在这个怀旧的努力中，第一个工具是
    `rm`（删除）命令，你可以用它来删除文件。
- en: The `rm` command, albeit very useful and easy to use, should be used with caution.
    Once you remove a file with this command, there is no going back—the file will
    not be placed in the Trash; it is gone for good.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `rm` 命令非常实用且易于使用，但应该谨慎使用。一旦你用这个命令删除了一个文件，就无法回头——文件不会被放入回收站；它将永远消失。
- en: To play it safe, let's try the `rm` command by getting rid of that new copy
    of *expfile.txt* that we just created in the home folder. The basic `rm` command
    structure consists of the command itself, `rm`, followed by the name of the file
    you want to remove. In this case, you want to remove the file called *expfile.txt*
    located in your home folder. Assuming your Terminal shows you to be home, remove
    the file by typing **`rm expfile.txt`** followed by a tap on the ol' **enter**
    key. The file will then be gone, and gone for good.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，让我们尝试使用 `rm` 命令来删除我们刚刚在主文件夹中创建的新副本 *expfile.txt*。基本的 `rm` 命令结构由命令本身 `rm`
    组成，后面跟着你想要删除的文件名。在这种情况下，你想要删除的是位于你主文件夹中的名为 *expfile.txt* 的文件。假设你的终端显示你处于主目录，通过输入
    **`rm expfile.txt`** 并按一下那个老式的 **enter** 键来删除文件。文件将会消失，并且永远消失。
- en: Now, double your pleasure by getting rid of the version of *expfile.txt* that
    is located in the subfolder *sub*. In this case, you need to specify where the
    file is because it isn't in the folder that the Terminal is in. Just type **`rm
    command_exp/sub/expfile.txt`**, and then press **enter**. Oooh, very cool. Brings
    ya back, doesn't it?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过删除位于子文件夹 *sub* 中的 *expfile.txt* 的版本，来加倍你的乐趣。在这种情况下，你需要指定文件的位置，因为它不在终端所在的文件夹中。只需输入
    **`rm command_exp/sub/expfile.txt`**，然后按 **enter** 键。哇，非常酷。这让你想起了什么吗？
- en: $ rmdir
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ rmdir
- en: You will now continue the fun with the `rmdir` (remove directory) command, which
    is a bigger and more powerful version of the `rm` command.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将继续使用 `rmdir`（删除目录）命令的乐趣，这是 `rm` 命令的一个更大、更强大的版本。
- en: You should use the `rmdir` command, like the `rm` command, with caution. There
    are no do-overs with `rmdir`. Once you remove a directory or folder with this
    command, it is gone for good.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该谨慎使用 `rmdir` 命令，就像使用 `rm` 命令一样。使用 `rmdir` 没有撤销的机会。一旦你用这个命令删除了一个目录或文件夹，它就永远消失了。
- en: To try this command, you can get rid of that *sub* folder you created. Type
    **`rmdir command_exp/sub`**, and press **enter**. The *sub* folder should now
    be gone. Finally, to round out the fun, use the `rmdir` command once more to get
    rid of the *command_exp* folder you created earlier. You've probably got it down
    by now, but just in case you don't, type **`rmdir command_exp`**, and then press
    **enter**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个命令，你可以删除你创建的那个 *sub* 文件夹。输入 **`rmdir command_exp/sub`**，然后按 **enter**。现在
    *sub* 文件夹应该已经消失了。最后，为了增加一些乐趣，再次使用 `rmdir` 命令来删除你之前创建的 *command_exp* 文件夹。你现在可能已经掌握了这个，但以防万一你还没有，输入
    **`rmdir command_exp`**，然后按 **enter**。
- en: $ chmod
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ chmod
- en: In [Chapter 7](ch07.html "Chapter 7. A TIDY NEST"), you learned how to change
    file permissions via the Nautilus interface. This is without a doubt the easiest
    way to go about such things, but you might find times when it is easier to use
    the command-line approach.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第7章](ch07.html "第7章. 一个整洁的巢穴") 中，你学习了如何通过 Nautilus 界面更改文件权限。毫无疑问，这是处理此类事情的最简单方法，但你可能会发现有时使用命令行方法更容易。
- en: 'The command for changing file permissions is `chmod` (change mode). To use
    it, just type the command followed by the permissions you want to extend to a
    file and then the location of the file itself. For example, let''s say you copied
    a JPEG file, *mybirthday.jpg*, from a CD to the *personal* subfolder within the
    *Photos* folder on your hard disk, and the file is write protected. To change
    the file so that you have write permissions (meaning that you can alter the file),
    you would type the following and then press **enter**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件权限的命令是 `chmod`（更改模式）。要使用它，只需输入命令，然后是想要扩展到文件的权限，然后是文件本身的路径。例如，假设你从一个 CD 上复制了一个
    JPEG 文件，*mybirthday.jpg*，到你的硬盘上 *Photos* 文件夹内的 *personal* 子文件夹中，并且文件是写保护的。要更改文件以便你有写入权限（这意味着你可以更改文件），你将输入以下内容并按
    **enter**：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To change the permissions of all the files and subfolders (and all the files
    within those subfolders) in one fell swoop, you can add the `-R` (recursive) flag
    to the `chmod` command. The command would thus be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性更改所有文件和子文件夹（以及那些子文件夹中的所有文件）的权限，你可以在 `chmod` 命令中添加 `-R`（递归）标志。因此，命令如下：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The number `744`, by the way, extends read, write, and execute (run) permissions
    to you, the owner, but gives read-only rights to everyone else—a pretty safe choice
    when in doubt. If you want to figure out permission numbers for yourself, it is
    pretty easy. You are basically dealing with three number positions, each of which
    has eight numerical possibilities (`0`–`7`). The left slot represents permissions
    for the owner, the center slot represents permissions for the group, and the third
    slot represents permissions for others.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，数字 `744` 将读取、写入和执行（运行）权限扩展到所有者你，但给其他人只提供只读权限——当不确定时这是一个相当安全的选择。如果你想自己找出权限数字，这相当简单。你基本上在处理三个数字位置，每个位置都有八个数字可能性（`0`–`7`）。最左边的槽位代表所有者的权限，中间的槽位代表组的权限，第三个槽位代表其他人的权限。
- en: 'The meanings of the numbers themselves are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数字本身的含义如下：
- en: '| `7` | Read, write, and execute permissions |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `7` | 读取、写入和执行权限 |'
- en: '| `6` | Read and write permissions |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `6` | 读取和写入权限 |'
- en: '| `5` | Read and execute permissions |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 读取和执行权限 |'
- en: '| `4` | Read-only permissions |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 只读权限 |'
- en: '| `3` | Write and execute permissions |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 写入和执行权限 |'
- en: '| `2` | Write-only permissions |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 只写入权限 |'
- en: '| `1` | Execute-only permissions |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 只执行权限 |'
- en: '| `0` | No permissions |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `0` | 没有权限 |'
- en: '[Figure 9-7](ch09s04.html#the_meaning_of_permission_numbers "Figure 9-7. The
    meaning of permission numbers") points out the meaning of each of these numbers
    and what each number slot represents. In fact, if you don''t mind a bit of simple
    addition, things are even easier to understand. To start with, remember that 1
    = execute, 2 = write, and 4 = read. Add any of those numbers together, and you
    get the other permission combos. For example, 1 (execute) + 4 (read) = 5 (read
    and execute). As you can see, permissions aren''t all that complicated.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-7](ch09s04.html#the_meaning_of_permission_numbers "图9-7. 权限数字的含义") 指出了每个数字的含义以及每个数字槽位代表的内容。实际上，如果你不介意一点简单的加法，事情甚至更容易理解。首先，记住
    1 = 执行，2 = 写入，4 = 读取。将这些数字相加，你就可以得到其他的权限组合。例如，1（执行）+ 4（读取）= 5（读取和执行）。正如你所看到的，权限并不那么复杂。'
- en: '![The meaning of permission numbers](httpatomoreillycomsourcenostarchimages656375.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![权限数字的含义](httpatomoreillycomsourcenostarchimages656375.png.jpg)'
- en: Figure 9-7. The meaning of permission numbers
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7. 权限数字的含义
- en: Now if you're more of a letters than numbers sort of person, you'll be happy
    to know that there is another way to change permissions that is probably even
    easier. In this approach, you have to deal only with two groups of letters and
    the symbols `+` and `-`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更倾向于字母而不是数字，你可能会很高兴地知道还有另一种更改权限的方法，可能甚至更简单。在这种方法中，你只需处理两组字母和符号`+`和`-`。
- en: 'The first group consists of the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组包括以下内容：
- en: '| `u` | User (owner of the file) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 用户（文件的所有者） |'
- en: '| `g` | Group (specified group of users) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 组（指定的用户组） |'
- en: '| `o` | Others (anyone who is not the user or a member of the group) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 其他（任何不是用户或组成员的人） |'
- en: '| `a` | All (all of the above) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 所有（上述所有） |'
- en: 'The second group consists of the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组包括以下内容：
- en: '| `r` | Read |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 读取 |'
- en: '| `w` | Write |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 写入 |'
- en: '| `x` | Execute |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 执行 |'
- en: You might already be able to figure out how this is all going to work, but I'll
    spell it out just in case your intuition is worn out for the day. Let's say you
    want to change the permissions of a file (*butterhaters.txt*, for example) so
    that all users on your machine can read and write to it. After opening a Terminal
    window, you can make the change by typing **`chmod a+rw butterhaters.txt`** and
    pressing **enter**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经能够猜出这一切是如何工作的，但我会详细说明，以防你的直觉今天用完了。假设你想更改一个文件（例如*butterhaters.txt*）的权限，以便你的机器上的所有用户都可以读取和写入它。在打开一个终端窗口后，你可以通过输入**`chmod
    a+rw butterhaters.txt`**并按**enter**键来做出更改。
- en: Oops! Just remembered that you don't want anyone changing the content of the
    file, eh? Well, to take back the write permissions for that file, you just need
    to type **`chmod a-w butterhaters.txt`** and then press **enter**. As you can
    see, the `+` gives permissions, while the `-` taketh away.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！刚刚想起你不想让任何人更改文件的内容，对吧？好吧，要撤销该文件的写权限，你只需输入**`chmod a-w butterhaters.txt`**然后按**enter**键。正如你所见，`+`表示赋予权限，而`-`表示撤销。
- en: That's much simpler, you've got to admit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这要简单得多，你不得不承认。
- en: $ sudo
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ sudo
- en: When you ran the Ubuntu Software Center in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), you were first asked to input your password before you could run
    the program. The reason for this, as I mentioned then, is that the Ubuntu Software
    Center installs the files it downloads in various folders throughout your system,
    almost all of which are write protected. By supplying your password, you are telling
    your system that you, as holder of the password, have the right to allow the Ubuntu
    Software Center to do that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第6章](ch06.html "第6章。完善鸟")中运行Ubuntu软件中心时，你首先被要求输入密码，然后才能运行程序。正如我那时提到的，这样做的原因是Ubuntu软件中心会将下载的文件安装到系统中的各个文件夹中，几乎所有的文件夹都是只读保护的。通过提供你的密码，你是在告诉你的系统，作为密码的持有者，你有权允许Ubuntu软件中心这样做。
- en: The command version of that same password-giving process is the `sudo` command.
    To perform an operation in a folder that is write protected, you would first type
    **`sudo`** and then the command you want to perform. For example, if you wanted
    to copy an icon image, let's call it *myicon.png*, to the globally located and
    write-protected *pixmaps* folder (*/usr/share/pixmaps*), you would type **`sudo
    cp myicon.png /usr/share/pixmaps`**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那个相同的密码提供过程的命令版本是`sudo`命令。要在一个只读保护的文件夹中执行操作，你首先输入**`sudo`**然后输入你想要执行的命令。例如，如果你想复制一个图标图像，我们可以称之为*myicon.png*，到全局位置和只读保护的*pixmaps*文件夹（*/usr/share/pixmaps*），你将输入**`sudo
    cp myicon.png /usr/share/pixmaps`**。
- en: After typing a command preceded by the `sudo` command and pressing **enter**,
    you will be prompted for your password. Once you type your password and press
    **enter** again, the command will be executed. I should mention that once you
    input your password, it will stay in memory for about five minutes. This means
    that you will not be prompted for your password when using the `sudo` command
    again within that time frame.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入以`sudo`命令开头的命令并按**enter**键后，你将被提示输入密码。一旦你输入密码并再次按**enter**键，命令将被执行。我应该提到的是，一旦你输入了密码，它将在内存中保留大约五分钟。这意味着在此期间，当你再次使用`sudo`命令时，你将不会被提示输入密码。
- en: $ locate
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ locate
- en: 'Now that you are familiar with the `sudo` command, let''s take it out for a
    spin by working with the `locate` command. The `locate` command is essentially
    a command-line alternative to the graphical Search tool found in the Places menu.
    Using the command is quite easy: Simply type the command followed by a space and
    the name of the file you want to find.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 `sudo` 命令，让我们通过使用 `locate` 命令来实际操作一下。`locate` 命令本质上是在“位置”菜单中找到的图形搜索工具的命令行替代品。使用这个命令相当简单：只需输入命令，然后跟一个空格和你要查找的文件名。
- en: Before you can use this command, though, you will need to create a database
    of filenames for `locate` to use. This is where using the `sudo` command, along
    with yet another command, `updatedb`, comes into play. Just type **`sudo updatedb`**,
    and press **enter**. After you type your password when asked to do so, it will
    seem that nothing is happening for a while, but don't worry. As long as the cursor
    in your Terminal is blinking, progress is being made, and when your user prompt
    returns, you will have successfully created the database file. After that, you
    can use the `locate` command.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用此命令之前，你需要为 `locate` 命令创建一个文件名数据库。这就是使用 `sudo` 命令以及另一个命令 `updatedb` 发挥作用的地方。只需输入
    **`sudo updatedb`**，然后按 **enter** 键。当你被要求输入密码时，一段时间内似乎没有任何反应，但请放心。只要你的终端光标在闪烁，进度就在进行中，当你的用户提示符返回时，你就已成功创建了数据库文件。之后，你可以使用
    `locate` 命令。
- en: Oh, and in the future if you think that the process seems to be taking longer
    and longer, don't worry—it is. The more files and applications you add to your
    system, the longer it will take your system to catalog them all.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，还有，将来如果你觉得这个过程似乎越来越慢，请不要担心——它确实是这样。你添加到系统中的文件和应用程序越多，你的系统整理这些文件所需的时间就越长。
- en: 'To take this new command for a test drive, let''s look for the *openofficeorg3-writer.png*
    file that you worked with in [Chapter 3](ch03.html "Chapter 3. A NEW PLACE TO
    CALL HOME"). Just type the following, and press **enter**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个新命令，让我们查找你在[第3章](ch03.html "第3章。一个新的家")中使用的 *openofficeorg3-writer.png*
    文件。只需输入以下内容，然后按 **enter** 键：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your results should look like those in [Figure 9-8](ch09s04.html#the_results_of_a_locate_search
    "Figure 9-8. The results of a locate search").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果应该看起来像[图9-8](ch09s04.html#the_results_of_a_locate_search "图9-8。locate搜索的结果")中的那样。
- en: '![The results of a locate search](httpatomoreillycomsourcenostarchimages656377.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![locate搜索的结果](httpatomoreillycomsourcenostarchimages656377.png.jpg)'
- en: Figure 9-8. The results of a `locate` search
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8。`locate`搜索的结果
- en: $ apt-get
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ apt-get
- en: 'Let''s move on to a command that might seem a bit familiar to you: `apt-get`.
    Yes, this command is indeed a means of controlling the powerful package download
    and installation tool, APT, which I covered in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"). Although it might not be as pleasing to use APT via the command
    line as it is via the Ubuntu Software Center, doing so can come in handy. I''ll
    cover the basics for you here.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到一个可能对你来说有点熟悉的命令：`apt-get`。是的，这个命令确实是控制强大的包下载和安装工具APT（我在[第6章](ch06.html
    "第6章。完善鸟儿")中介绍过）的一种方式。虽然通过命令行使用APT可能不如通过Ubuntu软件中心那样令人愉悦，但这样做有时会很有用。这里我会为你介绍一些基础知识。
- en: Just for fun and to get a bit of nontoxic practice with `apt-get`, open a Terminal
    window, type **`apt-get moo`**, and press **enter**. The result of this endeavor,
    as you will see, is an example of another Easter egg lurking within your system
    ([Figure 9-9](ch09s04.html#discovering_an_easter_egg_via_apt-get "Figure 9-9. Discovering
    an Easter egg via apt-get")). Useless, yes, but a safe first step in working with
    `apt-get`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，并且为了练习一下 `apt-get` 的非毒性操作，打开一个终端窗口，输入 **`apt-get moo`**，然后按 **enter** 键。正如你将看到的，这次尝试的结果是系统中隐藏的另一个彩蛋的例子（[图9-9](ch09s04.html#discovering_an_easter_egg_via_apt-get
    "图9-9。通过apt-get发现彩蛋")）。虽然无实际用途，但这是使用 `apt-get` 的一个安全第一步。
- en: '![Discovering an Easter egg via apt-get](httpatomoreillycomsourcenostarchimages656379.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![通过apt-get发现彩蛋](httpatomoreillycomsourcenostarchimages656379.png.jpg)'
- en: Figure 9-9. Discovering an Easter egg via `apt-get`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9。通过apt-get发现彩蛋
- en: To actually put the `apt-get` command to use, start by making sure to close
    any APT frontends you might have open, such as the Ubuntu Software Center. As
    I mentioned, you can run only one APT tool at a time. Once the coast is clear,
    you should always start out any operations involving `apt-get` with an update
    of the APT database so that you will be downloading the newest stuff. To do this,
    just type the command **`sudo apt-get update`**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用`apt-get`命令，首先确保关闭你可能打开的任何APT前端，例如Ubuntu软件中心。正如我提到的，你一次只能运行一个APT工具。一旦情况允许，你应该始终在涉及`apt-get`的操作开始时更新APT数据库，以便下载最新内容。为此，只需输入命令**`sudo
    apt-get update`**。
- en: If you want to install a single package without heading over to the Ubuntu Software
    Center, you can do so by typing **`sudo apt-get install`** *`package-name`*. For
    example, if you want to download and install the Shufflepuck game clone, Tuxpuck,
    you would type **`sudo apt-get install tuxpuck`**. If you eventually get annoyed
    with Tuxpuck after having lost one too many times, you can uninstall it by typing
    **`sudo apt-get remove tuxpuck`**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要安装单个软件包而不去Ubuntu软件中心，你可以通过输入**`sudo apt-get install`** *`软件包名称`*来实现。例如，如果你想下载并安装Shufflepuck游戏克隆版Tuxpuck，你将输入**`sudo
    apt-get install tuxpuck`**。如果你在玩Tuxpuck时输得太多，最终感到厌烦，你可以通过输入**`sudo apt-get remove
    tuxpuck`**来卸载它。
- en: Finally, bearing in mind all the warnings offered in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), if you want to upgrade your entire system via the command line,
    you can do so by typing **`sudo apt-get dist-upgrade`** (but only after doing
    a **`sudo apt-get update`** first).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑到[第6章](ch06.html "第6章。完善鸟")中提供的所有警告，如果你想通过命令行升级整个系统，你可以通过输入**`sudo apt-get
    dist-upgrade`**（但在此之前，请先执行**`sudo apt-get update`**）来实现。
- en: $ aptitude
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ aptitude
- en: To wrap up this section, let's finish with an increasingly popular alternative
    to `apt-get`, called `aptitude`. One of the differences responsible for `aptitude`'s
    popularity is that it is considered to have superior dependency handling to `apt-get`;
    in addition, it is arguably easier to use, because of its semigraphical interface
    ([Figure 9-10](ch09s04.html#the_semigraphical_interface_of_aptitude "Figure 9-10. The
    semigraphical interface of aptitude")). Because of this hybrid graphical interface,
    a lengthy discussion of how to use `aptitude` would take us from the main purpose
    of this chapter, which is learning to work with commands. That being the case,
    I will only briefly touch upon its use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，让我们以越来越受欢迎的`apt-get`替代品`aptitude`为例。导致`aptitude`受欢迎的一个差异是它被认为在依赖处理方面优于`apt-get`；此外，由于它的半图形界面，它可能更容易使用（[图9-10](ch09s04.html#the_semigraphical_interface_of_aptitude
    "图9-10. aptitude的半图形界面")）。正因为这种混合图形界面，关于如何使用`aptitude`的详细讨论将使我们偏离本章的主要目的，即学习如何使用命令。因此，我只会简要地提及它的使用。
- en: Start `aptitude` by typing **`sudo aptitude`** in a Terminal window and pressing
    **enter**. To install a package, you would click **Search** in the blue menu ribbon
    at the top of the window, select **Find** in the drop-down menu that appears,
    type the name of the package you are looking for in the search box, and then click
    **Ok** ([Figure 9-11](ch09s04.html#performing_a_package_search_in_aptitude "Figure 9-11. Performing
    a package search in aptitude")).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中输入**`sudo aptitude`**并按**回车键**来启动`aptitude`。要安装一个软件包，你会在窗口顶部的蓝色菜单带上点击**搜索**，在出现的下拉菜单中选择**查找**，在搜索框中输入你想要查找的软件包名称，然后点击**确定**（[图9-11](ch09s04.html#performing_a_package_search_in_aptitude
    "图9-11. 在aptitude中执行软件包搜索")）。
- en: '![The semigraphical interface of aptitude](httpatomoreillycomsourcenostarchimages656381.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![aptitude的半图形界面](httpatomoreillycomsourcenostarchimages656381.png.jpg)'
- en: Figure 9-10. The semigraphical interface of `aptitude`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10. `aptitude`的半图形界面
- en: '![Performing a package search in aptitude](httpatomoreillycomsourcenostarchimages656383.png.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![在aptitude中执行软件包搜索](httpatomoreillycomsourcenostarchimages656383.png.jpg)'
- en: Figure 9-11. Performing a package search in `aptitude`
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11. 在`aptitude`中执行软件包搜索
- en: Back in the main `aptitude` screen, you would select the package you want, click
    **Package** in the blue menu strip at the top of the page, and then select **Install**.
    If you prefer, you can just press the + key after selecting the target package
    to accomplish the same thing. Your package should now appear in green text. You
    may select other packages to install at the same time in the same way. Once done,
    press G on your keyboard, and the download and installation process will begin.
    If you are first presented with a screen telling you that certain packages will
    also be installed or removed, read through that screen, and then press G again
    to move on to the actual installation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `aptitude` 界面中，您会选择您想要的软件包，点击页面顶部蓝色菜单条上的 **Package**，然后选择 **Install**。如果您愿意，在选择目标软件包后，只需按下
    + 键即可完成相同操作。您的软件包现在应该以绿色文本显示。您可以用同样的方式选择其他要安装的软件包。完成后，按键盘上的 G 键，下载和安装过程将开始。如果您首先看到一个屏幕告诉您某些软件包也将被安装或删除，请阅读该屏幕，然后再次按
    G 键继续实际安装。
- en: It is also possible to use `aptitude` strictly in command mode in almost the
    same manner as `apt-get`, using pretty much the same arguments. To make sure the
    package lists that `aptitude` uses are up-to-date, you would start with the command
    **`sudo aptitude update`**. To install a package, such as the puzzle game Tangrams
    (aka gtans), you would type **`sudo aptitude install gtans`**. You would uninstall
    the package by typing **`sudo aptitude remove gtans`**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以几乎以与 `apt-get` 相同的方式，使用几乎相同的参数，在命令模式下严格使用 `aptitude`。为了确保 `aptitude` 使用的软件包列表是最新的，您需要从命令
    **`sudo aptitude update`** 开始。要安装一个软件包，例如拼图游戏 Tangrams（又名 gtans），您需要输入 **`sudo
    aptitude install gtans`**。您可以通过输入 **`sudo aptitude remove gtans`** 来卸载该软件包。
- en: A Couple of Other Biters You'll Be Using Soon
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您很快就会用到的其他几个命令
- en: 'This is as good a place as any to introduce two more commands that you will
    be called upon to use in this chapter and elsewhere in the book: `ln` and `tar`.
    You needn''t practice with these yet, because you will be using them very soon,
    but you might as well know what they are all about.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个介绍您在本章以及本书其他部分将要使用的两个命令的好地方：`ln` 和 `tar`。您目前不需要练习这些命令，因为您很快就会用到它们，但您最好了解一下它们是什么。
- en: $ ln
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ ln
- en: You use the `ln` (link) command to create a link file that launches or activates
    another file located in a separate folder. This is very useful when trying to
    activate a file that is buried deep in the subfolder of a subfolder of a subfolder
    somewhere on your hard disk. The command is very often used with the `-s` (symbolic)
    flag, which provides essentially the same thing as the shortcut you've come to
    know in Windows or the alias on the Mac.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 `ln`（链接）命令创建一个链接文件，该文件可以启动或激活位于另一个文件夹中的另一个文件。当您试图激活位于硬盘某个子文件夹的子文件夹的子文件夹中的文件时，这非常有用。该命令通常与
    `-s`（符号）标志一起使用，它基本上与您在 Windows 中所熟知的快捷方式或 Mac 上的别名相同。
- en: The easiest way to use the `ln` command is to first use the `cd` command to
    change the Terminal's location to the folder where you want to place the link.
    Then you can type the **`ln`** command on the command line, followed by the path
    of the file to which you want to link. For example, let's say you want to put
    a link in your home folder for an OpenOffice.org Writer file of your autobiography
    called *myLife.odt*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ln` 命令的最简单方法是首先使用 `cd` 命令将终端的位置更改为您想要放置链接的文件夹。然后您可以在命令行上输入 **`ln`** 命令，后面跟您想要链接的文件的路径。例如，假设您想在您的家目录中为名为
    *myLife.odt* 的 OpenOffice.org Writer 自传文件创建一个链接。
- en: 'The file is pretty well buried in a nest of subfolders deep within your home
    folder: */home/*username*/Documents/personal/self/autobiography/myLife.odt*. To
    create the link, you would open a new Terminal window, type the following command
    string, and then press **enter**:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件深深埋藏在家目录中的一个子文件夹的巢穴中：*/home/*username*/Documents/personal/self/autobiography/myLife.odt*。要创建链接，您需要打开一个新的终端窗口，输入以下命令字符串，然后按
    **enter**：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once you are finished, the link will appear in your home folder as an icon matching
    the original file in appearance, albeit sporting an arrow to signify that it is
    a link.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，链接将以与原始文件外观相匹配的图标出现在您的家目录中，尽管它有一个箭头表示这是一个链接。
- en: $ tar
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: $ tar
- en: In [Chapter 7](ch07.html "Chapter 7. A TIDY NEST") you learned to create and
    extract archives, or *tarballs*, but did you know that you can also create and
    extract tarballs using the command line? The `tar` command is your key to doing
    this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。一个整洁的巢穴") 中，你学习了如何创建和提取存档，或者说是 *tarball*，但你是否知道你还可以使用命令行来创建和提取
    tarball？`tar` 命令是你完成这项任务的关键。
- en: 'To create an archive, you would simply type **`tar -cvf`**, followed by the
    name the final tarball will be, and then the name of the folder or file you are
    trying to archive. For example, let''s say you want to create an archive of your
    photos folder, and you want to call it *pics4pals*. In this case, you would type
    the following command and then press **enter**:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个存档，你只需输入 **`tar -cvf`**，然后是最终 tarball 的名称，接着是你想要存档的文件夹或文件的名称。例如，假设你想要创建一个包含你的照片文件夹的存档，并且你想将其命名为
    *pics4pals*。在这种情况下，你会输入以下命令，然后按 **enter** 键：
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you no doubt noticed, there are some flags after the `tar` command in that
    string. The `c` tells the tar program to *create* a new archive. The `v` tells
    the program to be *verbose*, or, in other words, to tell you what it is doing
    in the Terminal as it is doing it. Finally, the `f` tells the program that what
    follows is the *file information*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，在那个字符串中 `tar` 命令之后有一些标志。`c` 告诉 `tar` 程序去 *创建* 一个新的存档。`v` 告诉程序要 *详细*，换句话说，就是在它执行时在终端告诉你它在做什么。最后，`f`
    告诉程序接下来的是 *文件信息*。
- en: If, after creating the archive, you suddenly remember that there is one more
    file you want to add to the mix, you can use the `-r` flag to append the archive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建存档之后，如果你突然想起还有另一个文件想要添加到其中，你可以使用 `-r` 标志来追加存档。
- en: 'For example, to add a file called *cranky.png* to the archive, you would type
    the following and then press **enter**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将名为 *cranky.png* 的文件添加到存档中，你只需输入以下内容并按 **enter** 键：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, chances are that you will be doing more tarball extracting than
    creating, so you no doubt want to know how to do that. Fortunately, the process
    is pretty similar to what you use when creating the tarball. The main difference
    is in the first flag. Rather than using the `tar` command with the `-c` flag,
    you would instead use it with the `-x` flag, which tells the tar program to *extract*
    the specified archive. So if you want to extract a tarball called *spicyfood.tar*,
    type the following command, and press **enter**:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会做更多的 tarball 提取而不是创建，所以你无疑想知道如何进行。幸运的是，这个过程与创建 tarball 时使用的非常相似。主要区别在于第一个标志。你不会使用带有
    `-c` 标志的 `tar` 命令，而是使用带有 `-x` 标志的 `tar` 命令，这告诉 `tar` 程序 *提取* 指定的存档。所以如果你想提取一个名为
    *spicyfood.tar* 的 tarball，请输入以下命令，然后按 **enter** 键：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What you have been doing thus far is creating and extracting archives, which
    are basically just collections of files. They are not, however, compressed. In
    fact, most tarballs you find will be compressed, and you can tell by the ending
    *tar.gz*. That *gz* means that the archive was compressed using the gzip program.
    Extracting a compressed tarball is just as easy as extracting a straight tar archive;
    all you have to do is add the `-z` flag, which tells your system to use the gzip
    program to decompress the archive. For example, if you want to extract a compressed
    tarball called *goosedown.tar.gz*, type the following command, and press **enter**:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你所做的是创建和提取存档，这些存档基本上只是文件的集合。然而，它们并不是压缩的。事实上，你找到的大多数 tarball 都会被压缩，你可以通过它们的扩展名
    *tar.gz* 来判断。那个 *gz* 表示存档是用 gzip 程序压缩的。提取一个压缩的 tarball 和提取一个普通的 tar 存档一样简单；你只需要添加
    `-z` 标志，告诉你的系统使用 gzip 程序解压缩存档。例如，如果你想提取一个名为 *goosedown.tar.gz* 的压缩 tarball，请输入以下命令，然后按
    **enter** 键：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Well, now that you know how to decompress and extract a gzipped tarball, you
    probably want to know how to create one. This is, again, little different than
    creating the tar archive itself; you would just add the `-z` tag to tell the program
    to use gzip to compress the folder. For example, to create a compressed version
    of your *Documentia* folder, which we''ll call *tightdocs.tar.gz*, you would type
    the following and press **enter**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在你已经知道了如何解压缩和提取一个 gzipped tarball，你可能想知道如何创建一个。这和创建 tar 存档本身几乎没什么区别；你只需添加
    `-z` 标签来告诉程序使用 gzip 压缩文件夹。例如，要创建你的 *Documentia* 文件夹的压缩版本，我们将其称为 *tightdocs.tar.gz*，你将输入以下内容并按
    **enter** 键：
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's worth mentioning at this point that you may also come across some files
    compressed with the bzip program. Such files are recognizable by some variation
    on the *.bz* or .*bz2* file extension. Dealing with these files should pose no
    problem, because the commands are almost identical to those for gzip. Just substitute
    `-j` for `-z` in the command string.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可能会遇到一些使用 bzip 程序压缩的文件。这些文件可以通过 *.bz* 或 .*bz2* 文件扩展名的变体来识别。处理这些文件应该不会遇到问题，因为命令几乎与
    gzip 的命令相同。只需在命令字符串中将 `-j` 替换为 `-z` 即可。
- en: Compressing and Extracting Compressed Single Files
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩和解压缩单个压缩文件
- en: If you want to compress or decompress a single file, you don't really need to
    use the tar program at all, since its purpose is to create archives consisting
    of several files. You can instead use the `gzip` and `gunzip` commands directly.
    For example, to compress a file called *matilda.png*, you would type **`gzip matilda.png`**
    and press **enter**. The *matilda.png* file would then become *matilda.jpg.gz*.
    To decompress the file, you would type **`gunzip matilda.jpg.gz`** and press **enter**,
    after which the *matilda.jpg* file would be back to normal.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想压缩或解压缩单个文件，实际上你根本不需要使用 tar 程序，因为它的目的是创建包含多个文件的存档。你可以直接使用 `gzip` 和 `gunzip`
    命令。例如，要压缩名为 *matilda.png* 的文件，你将输入 **`gzip matilda.png`** 并按 **enter**。*matilda.png*
    文件将变成 *matilda.jpg.gz*。要解压缩文件，你将输入 **`gunzip matilda.jpg.gz`** 并按 **enter**，之后
    *matilda.jpg* 文件将恢复正常。
- en: So, can you compress an archive you've already created with the `tar` command?
    Sure. For example, to compress the *spicyfood.tar* archive mentioned earlier,
    you would type **`gzip spicyfood.tar`**, and *voila*—you've got yourslf a compressed
    *spicyfood.tar.gz* archive. Pretty cool, don't you think?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你能使用 `tar` 命令压缩你已创建的存档吗？当然可以。例如，要压缩前面提到的 *spicyfood.tar* 存档，你将输入 **`gzip
    spicyfood.tar`**，然后——恭喜你——你得到了一个压缩的 *spicyfood.tar.gz* 存档。非常酷，不是吗？
- en: 'Project 9A: Creating a Plan'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 9A：创建计划
- en: Now that you have a bit of command experience, it's time to get some practice
    and put all those commands to good use. In this project, you'll start off easy
    by creating a *.plan* file, like the one mentioned earlier in the chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一些命令经验了，是时候进行一些练习，并充分利用所有这些命令了。在这个项目中，你将从创建一个 *.plan* 文件开始，就像本章前面提到的那样。
- en: The actual *.plan* file is a hidden file (as you can see by the dot before its
    name), which contains the plan or message that you add to that file. That message
    will appear in the output of someone's Terminal when they use the `finger` command
    to find out more about you. You may not need such a *.plan* file, but it is an
    easy enough way to get started working a bit more with commands and the Terminal
    itself, so let's give it a try.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 *.plan* 文件是一个隐藏文件（正如你可以在其名称前的点号看到的那样），它包含你添加到该文件的计划或信息。这条信息将出现在某人使用 `finger`
    命令了解更多关于你的信息时的终端输出中。你可能不需要这样的 *.plan* 文件，但它是一个简单易行的方式来开始使用命令和终端本身进行更多的工作，所以让我们试试看。
- en: To start out, you'll open the Terminal-based Pico editor to create the *.plan*
    file. To do this, open a Terminal window, type **`pico .plan`** (being sure to
    put a space between `pico` and `.plan`), and press **enter**. Your Terminal should
    now look a bit different, as you can see in [Figure 9-12](ch09s06.html#the_pico_editor
    "Figure 9-12. The Pico editor").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你将打开基于终端的 Pico 编辑器来创建 *.plan* 文件。为此，打开一个终端窗口，输入 **`pico .plan`**（确保在 `pico`
    和 `.plan` 之间有一个空格），然后按 **enter**。现在你的终端看起来可能会有点不同，就像你在[图 9-12](ch09s06.html#the_pico_editor
    "图 9-12. The Pico editor") 中看到的那样。
- en: You will now be looking at your new, and totally empty, *.plan* file within
    the Pico editor. All you have to do now is type your plan or message. Once you've
    done that, press **ctrl**-X to exit the Pico editor, and it will ask you whether
    you want to save your work. You do, so type **`Y`**, after which you will be presented
    with a set of save options. You have already named the file *.plan*, as you can
    see near the bottom of the screen, so all you have to do is press **enter**. You
    will be back at your now-familiar user prompt in the Terminal window.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在 Pico 编辑器中查看你的新文件，一个完全空的 *.plan* 文件。你现在需要做的就是输入你的计划或信息。一旦完成，按 **ctrl**-X
    退出 Pico 编辑器，它会询问你是否想要保存你的工作。你确实需要保存，所以输入 **`Y`**，之后你会看到一系列的保存选项。正如你在屏幕底部看到的，你已经将文件命名为
    *.plan*，所以你只需要按 **enter**。你将回到终端窗口中现在熟悉的用户提示符。
- en: '![The Pico editor](httpatomoreillycomsourcenostarchimages656385.png.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![The Pico editor](httpatomoreillycomsourcenostarchimages656385.png.jpg)'
- en: Figure 9-12. The Pico editor
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-12. The Pico editor
- en: To wrap things up, you want to change the permission of the new *.plan* file
    by typing **`chmod 644 .plan`** in the Terminal window and then pressing **enter**.
    The *.plan* file should now be in your home folder and readable (see Note below)
    by all, so go on and test your work by typing **`finger`** *`username`* and pressing
    **enter**. The message you entered in your *.plan* file should now appear in the
    results in place of the `no Plan` you found there earlier. If you want to change
    the contents of your *.plan* file later, just follow the same steps, and change
    the text when the *.plan* appears in the Pico editor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，你需要在终端窗口中输入 **`chmod 644 .plan`** 来更改新 *.plan* 文件的权限，然后按 **enter**。现在 *.plan*
    文件应该在你的家目录中，并且对所有用户都是可读的（见下文说明）。接下来，通过输入 **`finger`** *`username`* 并按 **enter**
    来测试你的工作。你之前在 *.plan* 文件中输入的消息现在应该出现在结果中，而不是你之前找到的 `no Plan`。如果你想以后更改 *.plan* 文件的内容，只需遵循相同的步骤，并在
    Pico 编辑器中 *.plan* 出现时更改文本。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: The name of the *.plan* file is preceded by a period, which means that it is
    a hidden file. Thus, if you take a look in your home folder, you will not be able
    to see the file unless you have checked the *Show hidden and backup files* box
    in the Nautilus Preferences window.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*.plan* 文件名前有一个点，这意味着它是一个隐藏文件。因此，如果你查看你的家目录，除非你在 Nautilus 预设窗口中勾选了 *显示隐藏和备份文件*
    复选框，否则你将看不到该文件。'
- en: 'Project 9B: More Command Practice with pyWings'
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 9B：使用 pyWings 进行更多命令练习
- en: Now let's get some more experience with the Terminal by installing a simple,
    and admittedly kind of silly, oracle program called pyWings (see [Figure 9-13](ch09s07.html#seeking_wisdom_from_pywings
    "Figure 9-13. Seeking wisdom from pyWings")). pyWings will give you cryptic guidance
    in response to whatever questions you may ask it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过安装一个简单且有点愚蠢的占卜程序 pyWings 来获得更多关于终端的经验（见图 9-13）。pyWings 将根据你提出的任何问题提供神秘的指导。
- en: To use pyWings, type whatever your confusion is in the input box, click one
    of the concern icons on the left (self, another, world), click one of the realm
    icons on the right (love, work, truth), and hit the big button that looks like
    half an eye. The oracle will then tell you what it has to say. As an example,
    I asked the oracle why I feel so down when the skies are so sunny, and I picked
    *self* as my concern and *truth* as the realm. [Figure 9-14](ch09s07.html#pywings_bestows_its_wisdom
    "Figure 9-14. pyWings bestows its wisdom.") shows the wisdom that was bestowed
    upon me.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 pyWings，在输入框中输入你的困惑，点击左侧的一个关注图标（自我、他人、世界），点击右侧的一个领域图标（爱情、工作、真理），然后点击那个看起来像半个眼睛的大按钮。占卜师随后会告诉你他有什么要说的。例如，我向占卜师询问为什么天空如此晴朗时我感到如此沮丧，我选择了
    *自我* 作为我的关注点，*真理* 作为领域。[图 9-14](ch09s07.html#pywings_bestows_its_wisdom "图 9-14.
    pyWings 传授其智慧。") 显示了我得到的智慧。
- en: '![Seeking wisdom from pyWings](httpatomoreillycomsourcenostarchimages656387.png.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![从 pyWings 寻求智慧](httpatomoreillycomsourcenostarchimages656387.png.jpg)'
- en: Figure 9-13. Seeking wisdom from pyWings
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-13. 从 pyWings 寻求智慧
- en: '![pyWings bestows its wisdom.](httpatomoreillycomsourcenostarchimages656389.png.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![pyWings 传授其智慧。](httpatomoreillycomsourcenostarchimages656389.png.jpg)'
- en: Figure 9-14. pyWings bestows its wisdom.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-14. pyWings 传授其智慧。
- en: As you can see, the oracle told me, "What we bring closer, grows to us," which
    I will interpret as . . . well, I'm not sure what to interpret it as.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，占卜师告诉我，“我们拉近的，就会长到我们身上，”我将它解释为……好吧，我不确定该如何解释。
- en: Hmmm.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯嗯。
- en: pyWings was written in a programming language called Python, which actually
    creates scripts rather than true conventional programs. You will learn a little
    more about this distinction in later in the chapter, but one of the differences
    I can mention right off the bat is that you don't actually have to install pyWings;
    you are simply going to put it on your hard drive in your home folder and run
    it from there, more or less as is.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: pyWings 是用一种叫做 Python 的编程语言编写的，它实际上创建的是脚本而不是真正的传统程序。你将在本章后面学到更多关于这种区别的知识，但我可以立即提到的不同之处在于，你实际上不需要安装
    pyWings；你只需将其放在你的家目录的硬盘上，然后从那里运行它，基本上就是这样。
- en: '9B-1: Getting Ready for pyWings (Installing Tkinter)'
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9B-1: 准备使用 pyWings（安装 Tkinter）'
- en: As I mentioned, one difference between pyWings and most of the other applications
    you know is that pyWings is a Python script. To create a graphical interface for
    itself, pyWings uses a toolbox known as *Tkinter*, which is the de facto standard
    (though not the only) GUI toolbox for Python. Tkinter, however, no longer comes
    bundled with Ubuntu, so you will need to download and install it yourself. Fortunately,
    this is quite easily done.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，pyWings 与你了解的大多数其他应用程序之间的一个区别是 pyWings 是一个 Python 脚本。为了为自己创建图形界面，pyWings
    使用一个名为 *Tkinter* 的工具箱，它是 Python 的既定标准（尽管不是唯一）GUI 工具箱。然而，Tkinter 已经不再随 Ubuntu 一起打包，所以你需要自己下载并安装它。幸运的是，这很容易做到。
- en: Although it is possible to whip open the Ubuntu Software Center and install
    Tkinter by the simple means learned in [Chapter 6](ch06.html "Chapter 6. ROUNDING
    OUT THE BIRD"), it seems more appropriate in this command line–oriented chapter
    to . . . yeah, you got it, use the command line. That said, open a Terminal window,
    type **`sudo apt-get install python-tk`**, and then press **enter**. When asked
    for your password, type it, and then press **enter**. APT will search the online
    repositories and find your file, along with anything else it requires to function
    properly. Once it is ready, it will ask you whether you want to continue. You
    do, so type **`y`**, and then press **enter**. When your username prompt reappears,
    you'll know the job is done, and you can go on to the next step.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以打开 Ubuntu 软件中心，通过在 [第 6 章](ch06.html "第 6 章。完善鸟儿") 中学到的简单方法安装 Tkinter，但在这个以命令行为导向的章节中，似乎更合适的是……是的，你猜对了，使用命令行。话虽如此，打开一个终端窗口，输入
    **`sudo apt-get install python-tk`**，然后按 **enter** 键。当被要求输入密码时，输入它，然后按 **enter**
    键。APT 将搜索在线仓库，找到你的文件，以及它正常运行所需的所有其他文件。一旦准备就绪，它将询问你是否想继续。你会，所以输入 **`y`**，然后按 **enter**
    键。当你的用户名提示符再次出现时，你就知道任务完成了，你可以进行下一步。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you prefer, you can perform this installation using `aptitude` instead, using
    the techniques we discussed earlier in the chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以使用我们在本章前面讨论的技术，用 `aptitude` 来执行此安装。
- en: '9B-2: Getting pyWings'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9B-2：获取 pyWings
- en: You are just about ready to begin "installing" pyWings, but before you do, you
    need to get it from [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/).
    Once there, click the **View all files** button, and then download the file *pywings-1.1.tar.gz*.
    Then place the file in your home folder so that you can follow along easily with
    the rest of this project.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你差不多准备好开始“安装”pyWings了，但在你这样做之前，你需要从 [http://sourceforge.net/projects/pywings/](http://sourceforge.net/projects/pywings/)
    获取它。一旦到达那里，点击 **查看所有文件** 按钮，然后下载文件 *pywings-1.1.tar.gz*。然后将文件放在你的主文件夹中，这样你就可以轻松地跟随这个项目的其余部分。
- en: '9B-3: Creating a LocalApps Folder for pyWings'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9B-3：为 pyWings 创建 LocalApps 文件夹
- en: As I mentioned earlier, you will be installing the pyWings program locally in
    your home folder. Installing a program *locally* means that you are installing
    the program and all its support and data files in your home folder. This makes
    things a bit easier, but it also means that the program will not be available
    to other users. It also means that if you're not careful, you might inadvertently
    delete it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，你将在主文件夹中本地安装 pyWings 程序。本地安装一个程序意味着你将程序及其所有支持和数据文件安装在你的主文件夹中。这使得事情变得容易一些，但也意味着程序将不会对其他用户可用。这也意味着如果你不小心，你可能会意外地删除它。
- en: To make things a bit easier and safer for you, you are going to create a folder
    in your home folder in which to place pyWings and all other applications that
    you install locally on your machine in the future. You will, logically enough,
    call the folder *LocalApps*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更容易、更安全地操作，你将在主文件夹中创建一个文件夹，用于放置 pyWings 以及你将来在机器上本地安装的所有其他应用程序。你将逻辑地将其命名为
    *LocalApps*。
- en: 'Let''s make the folder using a command in order to get some more practice.
    Go to the Terminal, make sure you are in your home folder, type the following
    command, and then press **enter**:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用命令来创建文件夹，以便获得更多的实践机会。转到终端，确保你处于你的主文件夹中，输入以下命令，然后按 **enter** 键：
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '9B-4: Extracting the pyWings Tarball'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9B-4：提取 pyWings 的 Tarball
- en: Now it is time to extract the tarball. You could do this by the double-click
    method you learned in [Chapter 7](ch07.html "Chapter 7. A TIDY NEST"), but since
    you're working with the command line here, let's use that instead.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提取 tarball 文件了。你可以通过在 [第 7 章](ch07.html "第 7 章。一个整洁的巢") 中学到的双击方法来做这件事，但由于你在这里使用命令行，所以我们还是使用命令行吧。
- en: 'To start, you''re going to place the tarball in the same folder into which
    you extract its files. Usually this isn''t necessary because the contents of most
    tarballs are already packaged in a folder of their own. By double-clicking the
    tarball to open it in File Roller, you can see whether things are packed in a
    folder or simply as a group of files. In the case of pyWings, it is the latter,
    so follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要将 tarball 放置在与您提取文件相同的文件夹中。通常这并不是必要的，因为大多数 tarball 的内容已经打包在自己的文件夹中。通过双击
    tarball 在 File Roller 中打开它，您可以查看内容是打包在文件夹中还是简单地作为一组文件。在 pyWings 的情况下，它是后者，所以按照以下步骤操作：
- en: Create a *pywings* folder by typing **`mkdir pywings`** and pressing **enter**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`mkdir pywings`** 并按 **enter** 创建一个 *pywings* 文件夹。
- en: Move the pyWings tarball into that folder by typing **`mv pywings*.gz pywings`**
    and pressing **enter**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`mv pywings*.gz pywings`** 并按 **enter** 将 pyWings tarball 移动到该文件夹。
- en: You can see that in this step you used an asterisk (**`*`**) to save some wear
    and tear on your fingers. The asterisk is a wildcard character that in this case
    told your system to move any file beginning in *`pywings`* and ending in *`.gz`*.
    Fortunately you had only one item matching those criteria.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以看到，在这个步骤中，您使用了一个星号（**`*`**）来节省一些手指的磨损。星号是一个通配符，在这种情况下，它告诉您的系统移动任何以 *`pywings`*
    开头并以 *`.gz`* 结尾的文件。幸运的是，您只有一个项目符合这些标准。
- en: Move to the new *pywings* folder by typing **`cd pywings`** and pressing **enter**.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入 **`cd pywings`** 并按 **enter** 移动到新的 *pywings* 文件夹。
- en: Now you get down to the process of extracting the tarball itself using the `tar`
    command. To do this, type **`tar –xzvf pywings*.gz`**, and press **enter**.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您开始使用 `tar` 命令提取 tarball 本身的过程。为此，输入 **`tar –xzvf pywings*.gz`** 并按 **enter**。
- en: Again, notice that you used the asterisk to save youself some keystrokes, though
    you could just as well have typed **`-1.1.tar`** in its stead.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次注意，您使用了星号来节省一些按键，尽管您也可以用 **`-1.1.tar`** 代替。
- en: Finally, type **`cd`**, and press **enter** to bring the Terminal back to your
    home folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，输入 **`cd`** 并按 **enter** 将终端返回到您的家文件夹。
- en: '9B-5: Moving the pyWings Folder to Your LocalApps Folder'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9B-5: 将 pyWings 文件夹移动到您的 LocalApps 文件夹'
- en: 'The extraction process is now complete. Before going on to running pyWings,
    however, let''s move it to the new *LocalApps* folder you created in Project 9B-3\.
    To do this, type the following command, and then press **enter**:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解压过程现在已完成。在继续运行 pyWings 之前，让我们将其移动到您在项目 9B-3 中创建的新 *LocalApps* 文件夹。为此，输入以下命令，然后按
    **enter**：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '9B-6: Running pyWings'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9B-6: 运行 pyWings'
- en: Now that you have pyWings in place and ready for action, let's start up the
    great oracle right now so that you can get a better perspective on how to deal
    with the aspects of life that trouble you.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经将 pyWings 安装好并准备使用，让我们立即启动这个伟大的先知，以便您能更好地了解如何处理困扰您的生活方面。
- en: 'In the Terminal, make sure you are in your home directory, type the following
    command string, and then press **enter**:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，确保您处于您的家目录，输入以下命令字符串，然后按 **enter**：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since *pywings.py* is a Python script, rather than an application, you are calling
    Python's attention to that fact so that Python will know it needs to deal with
    that script. If all went according to plan, pyWings should be up and running and
    will soon be making you a wiser person.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *pywings.py* 是一个 Python 脚本，而不是一个应用程序，您是在提醒 Python 注意这一点，以便 Python 知道它需要处理该脚本。如果一切按计划进行，pyWings
    应该已经启动并运行，并很快会使您成为一个更聪明的人。
- en: '9B-7: Creating a Launchable Link for pyWings'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9B-7: 为 pyWings 创建可启动链接'
- en: The method of running pyWings that you've just used works well enough, but it
    is a pain to open your Terminal and type that somewhat lengthy string every time
    you want to find out what fate has in store for you. Let's find a way to make
    things easier in the future.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚才使用的运行 pyWings 的方法效果足够好，但每次想要找出命运为你准备的安排时，打开终端并输入那个相对较长的字符串确实很麻烦。让我们找到一种方法，让未来事情变得更容易。
- en: To run an application from the Terminal, you generally type the name of that
    application, or, to put it more precisely, the name of that program's executable
    file; the application's name thus acts as a sort of command. For your system to
    recognize that command, however, the command (the executable file or a link to
    it) must be in a location where the system can find it. Whenever you run a command
    of any sort, your system checks a series of locations (most of which are *bin
    folders*, where executable files are located) to find that command.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要从终端运行应用程序，您通常输入该应用程序的名称，或者更准确地说，该程序的可执行文件名称；因此，应用程序的名称充当了一种命令。然而，为了让您的系统识别该命令，该命令（可执行文件或指向它的链接）必须位于系统可以找到的位置。每次您运行任何类型的命令时，您的系统都会检查一系列位置（其中大多数是*bin文件夹*，可执行文件位于其中）以找到该命令。
- en: 'You can easily find out where these locations are by typing **`echo $PATH`**
    in a new Terminal window and then pressing **enter**. As you will see, on your
    Ubuntu system, these locations are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在新的终端窗口中输入**`echo $PATH`**并按**enter**键来轻松地找出这些位置。正如您将看到的，在您的Ubuntu系统中，这些位置如下所示：
- en: '| */usr/local/bin* | */bin* |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| */usr/local/bin* | */bin* |'
- en: '| */usr/local/sbin* | */usr/bin* |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| */usr/local/sbin* | */usr/bin* |'
- en: '| */sbin* | */usr/games* |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| */sbin* | */usr/games* |'
- en: '| */usr/sbin* |   |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| */usr/sbin* |   |'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The results of the `echo $PATH` command will not appear as they do in the easier-to-read
    chart shown here but, rather, in a single line divided by colons. The actual output
    shown in the Terminal is *`/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo $PATH`命令的结果不会像这里所示的那样容易阅读的图表中显示，而是一个由冒号分隔的单行。实际在终端中显示的输出是*`/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games`*。'
- en: If the command you typed is in one of those locations, the program, or script,
    will run. As you no doubt know, however, pyWings is not in any of those locations.
    It is in */home/*username*/LocalApps/pyWings* and is thus, in a sense, out of
    your system's sight.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入的命令位于这些位置之一，程序或脚本将运行。然而，如您所知，pyWings不在这些位置中的任何一个。它位于*/home/*username*/LocalApps/pyWings*，因此在某种程度上，它超出了您系统的视线。
- en: To remedy this situation, you could add the path of your pyWings script to the
    list of paths that the system checks for run commands, so as to make the system
    aware of your new application's existence. However, let's try another method that
    I think is easier. What you will do is create a link to pyWings, a sort of launchable
    alias, in one of the locations your system does check for commands.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以将pyWings脚本的路径添加到系统检查运行命令的路径列表中，以便让系统知道您的新应用程序的存在。但是，让我们尝试另一种我认为更简单的方法。您将要做的是在系统检查命令的其中一个位置创建一个指向pyWings的链接，一种可启动的别名。
- en: 'To create this link, you will be using three commands: `cd` (to change directories),
    `sudo` (to give yourself write access to the destination folder), and `ln -s`
    (to create the link).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此链接，您将使用三个命令：`cd`（更改目录），`sudo`（给自己提供对目标文件夹的写访问权限），以及`ln -s`（创建链接）。
- en: In the Terminal, type **`cd /usr/games`**, and press **enter**. This puts you
    in one of the folders your system searches when you enter commands.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入**`cd /usr/games`**，然后按**enter**键。这会将您置于系统在您输入命令时搜索的文件夹之一。
- en: Type **`sudo ln -s /home/`***`username`***`/LocalApps/pywings/pywings.py pywings`**,
    and press **enter**. (Note that there is a space between the words `pywings.py`
    and `pywings` at the end of that command string.)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`sudo ln -s /home/`***`username`***`/LocalApps/pywings/pywings.py pywings`**，然后按**enter**键。（注意，在该命令字符串的末尾，`pywings.py`和`pywings`之间有一个空格。）
- en: The `pywings` at the end of that command string is the name that you are giving
    the link; the name of the link thus becomes the command you will use to run the
    application. If you type nothing, the link will be called *pywings.py*, which
    would mean three more keystrokes for you every time you wanted to start the program.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令字符串末尾的`pywings`是您赋予链接的名称；因此，链接的名称就变成了您运行应用程序时使用的命令。如果您不输入任何内容，链接将被命名为`pywings.py`，这意味着每次您想要启动程序时，都需要多按三个键。
- en: Type your password when prompted to do so, and then press **enter**.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示输入密码时，请输入您的密码，然后按**enter**键。
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cd`**，然后按**enter**键将终端返回到您的家目录。
- en: '9B-8: Running pyWings Again'
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9B-8：再次运行pyWings
- en: Now that you have created the link, you should be able to run the pyWings program
    much more easily. To try it, quit pyWings (if it is still running), type **`pywings`**
    in the Terminal window, and press **enter**. Your personal pyWings oracle should
    appear again.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了链接，应该能够更容易地运行pyWings程序。要尝试它，退出pyWings（如果它仍在运行），在终端窗口中输入**`pywings`**，然后按**回车**。您的个人pyWings占卜师应该再次出现。
- en: You've managed to cut down on the number of keystrokes required to run pyWings
    from the Terminal. However, if you are really into this pyWings thing and want
    to use it often, it will probably be handiest to add a launcher to your panel,
    a drawer, or the Applications menu.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '您已经成功减少了在终端中运行pyWings所需的按键数。然而，如果您真的对pyWings情有独钟并想经常使用它，将启动器添加到您的面板、抽屉或应用程序菜单中可能最方便。 '
- en: To add a pyWings panel launcher, for example, right-click any open space in
    the panel, and select **Add to Panel**. When the Add to Panel window appears,
    click the **Custom Application Launcher** item, and click **Add**. In the Create
    Launcher window that appears, type **`pyWings`** in the Name section, anything
    you want in the Comment section (**`Your Obtuse Guru`**, for example), and, assuming
    you created a launchable link in Project 9B-7, type **`pywings`** in the Command
    section. For an icon, click the **No Icon** button, and then look around until
    you find an icon that suits your fancy. I like *gnome-eog.png* myself. Once you've
    made your selection, click **Add** in the Browse icons window, and then click
    **OK** in the Create Launcher window.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要添加pyWings面板启动器，请右键单击面板上的任何空白区域，并选择**添加到面板**。当出现添加到面板窗口时，单击**自定义应用程序启动器**项，然后单击**添加**。在出现的创建启动器窗口中，在名称部分输入**`pyWings`**，在注释部分输入您想要的任何内容（例如**`您的愚钝导师`**），并且假设您在项目9B-7中创建了一个可启动的链接，在命令部分输入**`pywings`**。对于图标，单击**无图标**按钮，然后四处寻找一个适合您口味的图标。我自己喜欢*gnome-eog.png*。一旦您做出了选择，在浏览图标窗口中单击**添加**，然后在创建启动器窗口中单击**确定**。
- en: '9B-9: Adding Emblems to Your LocalApps Folder'
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9B-9: 将徽章添加到您的LocalApps文件夹'
- en: Now that pyWings is successfully installed and working, it is probably a good
    idea to add an emblem to your new *LocalApps* folder so that you don't inadvertently
    dump it in the Trash someday. You already learned how to do this in [Chapter 8](ch08.html
    "Chapter 8. DRESSING UP THE BIRD"), so I won't give you the step-by-step instructions.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在pyWings已成功安装并运行，给您的新的*LocalApps*文件夹添加一个徽标可能是个好主意，这样您就不会不小心把它扔进垃圾桶。您已经在[第8章](ch08.html
    "第8章. DRESSING UP THE BIRD")中学到了如何这样做，所以我就不会给出逐步说明。
- en: 'Project 9C: Command Practice Review with Briscola'
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目9C：使用Briscola进行命令练习复习
- en: If you want to reinforce the skills you've put to use in the previous project,
    why not go a bit Continental and try Briscola—a simple, yet very traditional,
    Italian card game (see [Figure 9-15](ch09s08.html#briscola "Figure 9-15. Briscola"))?
    Unlike pyWings, which is a Python script, Briscola is a script of a different
    flavor, written in a scripting language called Tcl, which uses something called
    Tk to create its graphical interface.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想加强在前一个项目中使用的技能，为什么不尝试一下大陆风格的Briscola——一种简单但非常传统的意大利纸牌游戏（见[图9-15](ch09s08.html#briscola
    "图9-15. Briscola"))？与Python脚本pyWings不同，Briscola是一个不同口味的脚本，用一种称为Tcl的脚本语言编写，它使用某种称为Tk的东西来创建其图形界面。
- en: '![Briscola](httpatomoreillycomsourcenostarchimages656391.png.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![Briscola](httpatomoreillycomsourcenostarchimages656391.png.jpg)'
- en: Figure 9-15. Briscola
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-15. Briscola
- en: '9C-1: Getting Briscola'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9C-1: 获取Briscola'
- en: 'You are just about ready to begin "installing" Briscola, but before you do,
    you must get it. You can get Briscola by going to the project''s home page at
    [http://www.rigacci.org/comp/software/](http://www.rigacci.org/comp/software/)
    and downloading it in the traditional manner, but since we''re working with commands,
    let''s instead get Briscola by using a new command: `wget`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您差不多准备好开始“安装”Briscola了，但在您这样做之前，您必须先获取它。您可以通过访问项目的首页[http://www.rigacci.org/comp/software/](http://www.rigacci.org/comp/software/)并以传统方式下载Briscola来获取它，但由于我们正在使用命令，让我们使用一个新的命令：`wget`来获取Briscola。
- en: 'To do this, just open a Terminal window, type the following command string,
    and then press **enter**:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需打开一个终端窗口，输入以下命令字符串，然后按**回车**：
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you have any trouble downloading Briscola in this way, you can also download
    it from the site for this book: [http://www.edgy-penguins.org/UFNG/](http://www.edgy-penguins.org/UFNG/).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以这种方式下载Briscola遇到任何问题，您也可以从本书的网站下载：[http://www.edgy-penguins.org/UFNG/](http://www.edgy-penguins.org/UFNG/)。
- en: In your Terminal window, you will see `wget` in action as it connects to the
    site where Briscola is stored and then downloads the file. When it's done, you
    will find the Briscola tarball in your home folder.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端窗口中，你会看到 `wget` 正在连接到存放 Briscola 的网站并下载文件的动作。完成后，你将在你的家目录中找到 Briscola 的
    tarball。
- en: '9C-2: Extracting the Briscola Tarball and Renaming the Briscola Folder'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9C-2：解压 Briscola Tarball 并重命名 Briscola 文件夹
- en: Extracting the Briscola tarball is essentially the same process as that for
    pyWings; however, Briscola is already packaged within its own folder, so you won't
    have to create a special folder for it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 Briscola tarball 的过程基本上与 pyWings 的过程相同；然而，Briscola 已经打包在其自己的文件夹中，因此你不需要为它创建一个特殊的文件夹。
- en: 'Although I am sure you now know the drill, I''ll tell you again. Just open
    a Terminal window, type the following command, and press **enter**:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我相信你现在已经知道了步骤，但我还是要再告诉你一次。只需打开一个终端窗口，输入以下命令，然后按 **enter** 键：
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A new folder, *Briscola-4.1*, will now appear in your home folder with all the
    Briscola files in it. To make things easier to deal with in the future, let's
    shorten the name of the folder to simply *briscola*. You already know how to do
    this via the right-click method, but this time around let's to do it via the command
    line. To do this, you use, perhaps surprisingly, the `mv` command followed by
    the name of the file whose name you are going to change, followed by the new name
    of the file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的家目录中会出现一个新的文件夹 *Briscola-4.1*，其中包含所有的 Briscola 文件。为了使未来的处理更加方便，让我们将文件夹的名称缩短为简单的
    *briscola*。你已经知道如何通过右键点击方法来完成这个操作，但这次我们通过命令行来完成。为此，你使用，可能令人惊讶的是，`mv` 命令，后面跟着你要更改名称的文件名，然后是文件的新名称。
- en: 'Give it a go by typing the following command and pressing **enter**:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令并按 **enter** 键来尝试：
- en: '[PRE16]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '9C-3: Preparing the Briscola Script'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9C-3：准备 Briscola 脚本
- en: Most applications that come in tarball form include a README file, which includes
    information on what you need to do to install and use the application. If you
    double-click the **README** file in the *briscola* folder in Nautilus, you will
    see that the "HOW TO START" section tells you to adjust the first line of the
    *briscola.tk* script to point it to your Tk shell, and to adjust the second line
    of the script to point to the directory where the various Briscola files are located.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数以 tarball 形式提供的应用程序都包含一个 README 文件，其中包含了关于如何安装和使用该应用程序所需的信息。如果你在 Nautilus
    中的 *briscola* 文件夹中双击 **README** 文件，你会看到“如何开始”部分告诉你需要调整 *briscola.tk* 脚本的第一行，使其指向你的
    Tk shell，并调整脚本的第二行，使其指向存放各种 Briscola 文件所在的目录。
- en: 'To perform the adjustments as instructed in the README file, just follow these
    steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照 README 文件中的说明进行调整，只需按照以下步骤操作：
- en: Find the Tk shell, called Wish, by typing **`locate wish`** in the Terminal
    window and pressing **enter**, and then note the location given on a piece of
    paper. You may get a number of locations in your search results, but the one you
    want is `/usr/bin/wish`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端窗口中输入 **`locate wish`** 并按 **enter** 键，找到名为 Wish 的 Tk shell，并记下给出的位置。你可能会在搜索结果中得到多个位置，但你需要的是
    `/usr/bin/wish`。
- en: Direct the Terminal to the *briscola* folder by typing **`cd briscola`** and
    pressing **enter**.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中输入 **`cd briscola`** 并按 **enter** 键，将终端指向 *briscola* 文件夹。
- en: Use the Pico editor, which we used in Project 9A, to edit the *briscola.tk*
    file by typing **`pico briscola.tk`** and pressing **enter**. The *briscola.tk*
    file will appear in the Pico editor in your Terminal window.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在项目 9A 中使用的 Pico 编辑器，通过输入 **`pico briscola.tk`** 并按 **enter** 键来编辑 *briscola.tk*
    文件。*briscola.tk* 文件将出现在你的终端窗口中的 Pico 编辑器中。
- en: Change the very first line of the *briscola.tk* file from `#!/usr/local/bin/wish`
    to **`#!/usr/bin/wish`**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *briscola.tk* 文件的第一行从 `#!/usr/local/bin/wish` 更改为 **`#!/usr/bin/wish`**。
- en: In the second line, change `/usr/local/games/briscola` to **`/usr/share/games/briscola`**,
    which is where you will place Briscola in just a bit. Your editor window should
    now look like [Figure 9-16](ch09s08.html#configuring_briscola_with_the_pico_edito
    "Figure 9-16. Configuring Briscola with the Pico editor").
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，将 `/usr/local/games/briscola` 更改为 **`/usr/share/games/briscola`**，这是你稍后将要放置
    Briscola 的位置。你的编辑器窗口现在应该看起来像 [图 9-16](ch09s08.html#configuring_briscola_with_the_pico_edito
    "图 9-16. 使用 Pico 编辑器配置 Briscola")。
- en: '![Configuring Briscola with the Pico editor](httpatomoreillycomsourcenostarchimages656393.png.jpg)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 Pico 编辑器配置 Briscola](httpatomoreillycomsourcenostarchimages656393.png.jpg)'
- en: Figure 9-16. Configuring Briscola with the Pico editor
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 9-16. 使用 Pico 编辑器配置 Briscola
- en: Press **ctrl**-X on your keyboard.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在键盘上按 **ctrl**-X。
- en: Type **`y`**, and press **enter** to save your changes.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`y`**，然后按**enter**键保存你的更改。
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cd`**，然后按**enter**键将终端返回到你的主文件夹。
- en: '9C-4: Moving the Briscola Folder to a Global Location'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9C-4：将Briscola文件夹移动到全局位置
- en: You could move the *briscola* folder to the *LocalApps* folder and play it from
    there, as you did with pyWings, but this time around, let's do things a bit differently
    by moving the whole thing to global territory. This not only keeps it safe from
    any obsessive housekeeping tendencies but also allows all users on the same computer
    to play the game. You will need to use the `sudo` command to do this so that you
    can have write access in those protected folders.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将*briscola*文件夹移动到*LocalApps*文件夹中，并从那里玩游戏，就像你对pyWings所做的那样，但这次，让我们通过将整个文件夹移动到全局区域来做一些不同的事情。这不仅使它免受任何强迫性的家务整理倾向的影响，而且允许同一台电脑上的所有用户玩游戏。你需要使用`sudo`命令来做这件事，这样你就可以在受保护的文件夹中拥有写入权限。
- en: 'To do this, just type the following command in the Terminal window, and press
    **enter**:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需在终端窗口中输入以下命令，然后按**enter**键：
- en: '[PRE17]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When you are prompted for your password, type it, and press **enter**.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示输入密码时，输入它，然后按**enter**键。
- en: '9C-5: Creating a Launchable Link for Briscola'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9C-5：为Briscola创建可启动链接
- en: 'Even though you''ve moved Briscola to a global location, you still can''t run
    it with a simple one-word command because the *briscola.tk* file is not in the
    system''s command search path. Just as you did for pyWings, you will now create
    a launchable link for Briscola to solve that problem. Here are the steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经将Briscola移动到了全局位置，你仍然不能通过简单的单字命令来运行它，因为*briscola.tk*文件不在系统的命令搜索路径中。就像你为pyWings所做的那样，你现在将为Briscola创建一个可启动的链接来解决这个问题。以下是步骤：
- en: In the Terminal, type **`cd /usr/games`**, and press **enter**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，输入**`cd /usr/games`**，然后按**enter**键。
- en: Now create the link by typing **`sudo ln -s /usr/share/games/briscola/briscola.tk
    briscola`**, and press **enter**.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过输入**`sudo ln -s /usr/share/games/briscola/briscola.tk briscola`**并按**enter**键创建链接。
- en: Type **`cd`**, and press **enter** to return the Terminal to your home folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**`cd`**，然后按**enter**键将终端返回到你的主文件夹。
- en: You can now easily run Briscola by typing **`briscola`** in the Terminal and
    pressing **enter**.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过在终端中输入**`briscola`**并按**enter**键轻松运行Briscola。
- en: Can You Do the Same Thing with pyWings?
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能用pyWings做同样的事情吗？
- en: 'Sure. If you want to move pyWings to a global location, just follow the same
    procedure for moving the *pywings* folder and creating the link as you did for
    Briscola, making the necessary substitutions, of course. You will have to remove
    the previously created pyWings link, though, by typing the following command and
    pressing **enter**:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当然。如果你想将pyWings移动到全局位置，只需按照移动*pywings*文件夹和创建链接的相同程序进行，当然需要做必要的替换。不过，你将需要通过输入以下命令并按**enter**键来删除之前创建的pyWings链接：
- en: '[PRE18]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After that, move the *pywings* folder to global territory by typing **`sudo
    mv ˜/LocalApps/pywings /usr/share/games/pywings`** and pressing **enter**. When
    prompted for your password, type it, and press **enter**. You can then create
    the launchable link by typing **`cd /usr/games`**, pressing **enter**, typing
    **`sudo ln -s /usr/share/games/pywings/pywings.py pywings`**, and pressing **enter**
    once more.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过输入**`sudo mv ˜/LocalApps/pywings /usr/share/games/pywings`**并按**enter**键将*pywings*文件夹移动到全局区域。当提示输入密码时，输入它，然后按**enter**键。然后你可以通过输入**`cd
    /usr/games`**，按**enter**键，输入**`sudo ln -s /usr/share/games/pywings/pywings.py
    pywings`**并再次按**enter**键来创建可启动的链接。
- en: Playing Briscola
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩Briscola
- en: As I already mentioned, Briscola is easy—about as easy a card game as there
    is. It is a trick-taking game, which means that you put out a card and then your
    opponent puts out a card, and the one who puts out the higher point-value card
    wins the hand, or *trick*. Points are awarded on the basis of the cards involved
    in that trick. The winner of the trick then goes on to *lead* the next trick,
    meaning that the winner puts out his or her card first the next time around. When
    all the cards are played, the points for each player are then tallied, and the
    player with the higher points wins. It's much simpler to do than it is to describe.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，Briscola很简单——几乎是最简单的纸牌游戏之一。它是一种技巧游戏，这意味着你先出一张牌，然后你的对手出一张牌，出点数更高的牌的人赢得这一轮，或者称为*技巧*。根据参与该技巧的牌来计算分数。赢得技巧的人接着*领先*下一轮，这意味着赢家将首先出牌。当所有牌都出完时，然后计算每位玩家的分数，分数更高的玩家获胜。这比描述的要简单得多。
- en: Want to Know More?
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 想了解更多吗？
- en: If you would like a more detailed set of rules for playing Briscola (and just
    about any other card game in the world), check out [http://www.pagat.com/](http://www.pagat.com/).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解玩布里斯科（以及世界上几乎所有其他纸牌游戏）的更详细规则，请查看[http://www.pagat.com/](http://www.pagat.com/)。
- en: 'Project 9D: Compiling and Installing Programs from Source: Xmahjongg'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 9D：从源代码编译和安装程序：Xmahjongg
- en: Though it was far more common in the earlier days, *compiling programs from
    source* seems to be a phrase you still hear more in the Linux world than in any
    other. For the beginner, just the mention of compiling a program from source seems
    off-putting enough. The words *compile* and *source* seem to instill a sense of
    foreboding in the heart of the new user. That certainly was the case for me, anyway.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在早期更为常见，但**从源代码编译程序**似乎是一个在Linux世界中比在其他任何地方都更常听到的短语。对于初学者来说，仅仅提到从源代码编译程序似乎就足以让人望而却步。**编译**和**源**这两个词似乎在新用户心中灌输了一种不祥之感。至少对我来说是这样的。
- en: You can live long and prosper without ever bothering to compile anything on
    your system. You can move along quite happily with your system as is, or you can
    just install programs by means of the much more convenient Ubuntu Software Center.
    Still, once in the Linux world, you are likely to come across this installation
    method and may well become curious, especially if you move into the geekier side
    of the community.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不费心在你的系统上编译任何东西的情况下长寿并繁荣。你可以带着你的系统继续快乐地前进，或者你可以通过更方便的Ubuntu软件中心安装程序。尽管如此，一旦进入Linux世界，你很可能会遇到这种安装方法，并且可能会很好奇，尤其是如果你转向社区的更技术的一面。
- en: So, What Is Source?
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，什么是源代码？
- en: To get started, it is probably a good idea to understand what *source* is so
    as to help you to understand a bit about how a program actually gets from its
    primitive state on the programmer's computer to an up-and-running application
    on your machine. First the programmer writes a program in a programming language.
    You have probably heard of programming languages such as BASIC or C, and there
    are many others. What the programmer actually writes with such a language is a
    set of instructions called the *source code*, or *source*. Your computer, however,
    cannot actually understand any of that source on its own. It is as if the computer
    speaks ancient Greek, and the source code is all written in French. The computer
    therefore needs some sort of interpreter to help it out.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，了解**源代码**是什么可能是个好主意，这样可以帮助你理解程序是如何从程序员电脑上的原始状态变成你机器上运行的应用程序的。首先，程序员用一种编程语言编写程序。你可能听说过像BASIC或C这样的编程语言，还有很多其他的。程序员实际上用这种语言编写的是一组称为**源代码**或**源**的指令。然而，你的电脑实际上无法理解任何这些源代码。这就像电脑说古希腊语，而源代码都是用法语写的。因此，电脑需要某种解释器来帮助它。
- en: The various languages that programmers use are called *high-level languages*—they
    are relatively easy for programmers to read. The computer, on the other hand,
    only understands *low-level languages*, which are quite difficult for most mere
    mortal programmers to deal with. To convert the high-level language instructions
    to a low-level language, the computer needs some other program to translate.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员使用的各种语言被称为**高级语言**——它们相对容易阅读。然而，计算机只理解**低级语言**，这对大多数普通程序员来说相当难以处理。为了将高级语言指令转换为低级语言，计算机需要其他程序来翻译。
- en: If this translation process actually takes place while a program is running,
    the translator program is called an *interpreter*. Applications that run using
    an interpreter are usually called *scripts*. The pyWings and Briscola applications
    earlier in this chapter are examples of such script applications.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个翻译过程在程序运行时实际发生，那么这个翻译程序被称为**解释器**。使用解释器运行的应用程序通常被称为**脚本**。本章前面提到的pyWings和布里斯科应用程序就是这样的脚本应用程序的例子。
- en: The problem with such scripts is that they can be slower than most of the applications
    you're familiar with—the computer must run an interpreter, interpret the source
    code, and run the actual application all at the same time. This is like having
    a French book translated into Greek by a live interpreter; it's very slow indeed.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这种脚本的问题在于，它们的速度可能比你所熟悉的多数应用程序都要慢——计算机必须运行解释器，解释源代码，并运行实际的应用程序，这一切都要同时进行。这就像有一本法语书籍由现场翻译成希腊语；确实非常慢。
- en: As an alternative, most programs use a compiler instead of an interpreter. A
    *compiler* translates the high-level source code into low-level *machine code*,
    or *object code*, that the computer can understand before the application is actually
    run. Once this translation is done, the computer never has to bother with the
    high-level instructions again; it can merely read the translated version each
    time it runs the program. This is like having a translated version of a foreign
    book that you can read any time you want. Because computers can run compiled programs
    without simultaneously using an interpreter, compiled programs run faster than
    scripts. Most applications for all operating systems are, therefore, compiled.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，大多数程序使用编译器而不是解释器。**编译器**将高级源代码翻译成低级的**机器代码**或**目标代码**，在应用程序实际运行之前，计算机可以理解。一旦完成这种翻译，计算机就再也不必担心高级指令了；它只需每次运行程序时读取翻译后的版本即可。这就像拥有一本可以随时阅读的翻译版外国书籍一样。因为计算机可以在不同时使用解释器的情况下运行编译程序，所以编译程序比脚本运行得更快。因此，所有操作系统的应用程序大多数都是编译的。
- en: The Basics
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'The actual process of compiling an application from source and then installing
    it is quite simple—a truly "one, two, three" bit of presto change-o. Basically,
    after extracting the source code from an archived file (usually in the form of
    a tarball), you would use the following commands to accomplish the task:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码编译应用程序然后安装的实际过程相当简单——真正的一“二”三“魔术”。基本上，在从归档文件（通常是tar包的形式）中提取源代码后，您可以使用以下命令来完成此任务：
- en: '**`./configure`**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**`./configure`**'
- en: To configure a *makefile*, which provides instructions for the `make` command
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置一个**makefile**，它为`make`命令提供指令
- en: '**`make`**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**`make`**'
- en: To translate the source code into object code that the computer can understand
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码翻译成计算机能理解的**目标代码**
- en: '**`sudo make install`**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sudo make install`**'
- en: To give yourself write privileges in protected folders and then install the
    application
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在受保护的文件夹中获得写权限然后安装应用程序
- en: '**`make clean`**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**`make clean`**'
- en: To tidy up the leftovers once the process is complete (to clean up the mess)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程完成后整理残留物（清理混乱）
- en: I know that sounds like a lot of commands, but as I always say, it is easier
    to actually do than it looks like on the page, so fear not.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来像很多命令，但正如我经常说的，实际上做起来比看起来容易，所以不要害怕。
- en: '9D-1: Installing the Tools You Need'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9D-1：安装您需要的工具
- en: 'Before doing anything else, you have to get your system ready to do what you''re
    about to ask of it. Because Ubuntu is designed with the average computer user
    in mind, it does not come with the various applications and libraries you need
    to compile applications from source. Fortunately, however, everything you need
    to get the job done is available via the Ubuntu Software Center. To get ready
    for the work at hand in this chapter (and many other jobs you are likely to do
    on your own in the future), perform searches for and install the following packages:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，您必须使您的系统准备好执行您即将要求它做的事情。因为Ubuntu是为普通计算机用户设计的，所以它没有包含您从源代码编译应用程序所需的各个应用程序和库。幸运的是，然而，您完成这项工作所需的一切都可以通过Ubuntu软件中心获得。为了准备本章（以及您未来可能自己做的许多其他工作）的工作，请搜索并安装以下包：
- en: build-essential
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: build-essential
- en: libgtk2.0-dev
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libgtk2.0-dev
- en: '9D-2: Downloading and Extracting the Xmahjongg File'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9D-2：下载和提取Xmahjongg文件
- en: To get some hands-on experience with compiling a program from source, you will
    be working with a game called *Xmahjongg*, which you can see in [Figure 9-17](ch09s09.html#the_xmahjongg_game
    "Figure 9-17. The Xmahjongg game"). If you've tried the version of Mahjongg that
    comes with your Ubuntu distribution, you will notice that this one is much easier
    on your eyes and is a bit more colorful (check out the project site at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    to catch a glimpse of it in its full-color glory).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得从源代码编译程序的实际经验，您将使用一个名为**Xmahjongg**的游戏，您可以在[图9-17](ch09s09.html#the_xmahjongg_game
    "图9-17. Xmahjongg游戏")中看到它。如果您尝试过您Ubuntu发行版中包含的Mahjongg版本，您会注意到这个版本对您的眼睛更友好，颜色也更丰富（查看项目网站[http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)，一睹其全彩风采）。
- en: '![The Xmahjongg game](httpatomoreillycomsourcenostarchimages656395.png.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![Xmahjongg游戏](httpatomoreillycomsourcenostarchimages656395.png.jpg)'
- en: Figure 9-17. The Xmahjongg game
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-17. Xmahjongg游戏
- en: Xmahjongg is available via the Ubuntu Software Center, so it is not absolutely
    necessary to install it in the way you are about to, but doing so provides a perfect
    opportunity to learn how to compile a program from source. The amount of source
    code isn't all that great, so it won't take too much time to do, and it requires
    no tinkering.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Xmahjongg 通过 Ubuntu 软件中心提供，所以按照你即将要做的方式安装它并不是绝对必要的，但这样做提供了一个学习如何从源代码编译程序的理想机会。源代码的数量并不多，所以不会花费太多时间，而且不需要任何调整。
- en: To get started, you will first have to download the Xmahjongg source code. You
    can get this from the Xmahjongg project page at [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/).
    Download the tarball *xmahjongg-3.7.tar.gz*, or a newer version if there is one.
    Do not download any of the other file types available on that page.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你首先需要下载 Xmahjongg 的源代码。你可以从 Xmahjongg 项目页面 [http://www.lcdf.org/xmahjongg/](http://www.lcdf.org/xmahjongg/)
    获取。下载 *xmahjongg-3.7.tar.gz* 的 tarball，或者如果有新版本的话，也请下载。不要下载该页面上提供的其他文件类型。
- en: 'If you prefer, you can instead download the Xmahjongg tarball by using the
    `wget` command that you learned in Project 9C-1\. Just open a Terminal window,
    type the following command, and then press **enter**:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用你在项目 9C-1 中学到的 `wget` 命令来下载 Xmahjongg 的 tarball。只需打开一个终端窗口，输入以下命令，然后按
    **enter** 键：
- en: '[PRE19]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you have the file on your hard disk, untar the *xmahjongg-3.7.tar.gz* file.
    You can do this either by using the command line, as you learned to do earlier
    in the chapter, or by double-clicking the file and dragging its contents into
    the appropriate folder. To make it easier for you to follow along with the directions
    I'll be giving you, be sure to place the untarred Xmahjongg folder in your home
    folder. Then you will be ready to roll.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在硬盘上有了该文件，就可以解压 *xmahjongg-3.7.tar.gz* 文件。你可以通过命令行来完成，就像你在本章早些时候学到的，或者通过双击文件并将内容拖放到适当的文件夹中。为了让你更容易跟随我将给出的指示，请确保将解压后的
    Xmahjongg 文件夹放在你的家目录中。然后你就可以开始了。
- en: Normally at this point, you would look through the folder to find some instructions
    for dealing with the package, just as you did earlier in the chapter for Briscola.
    In most source code packages, this information is included in an INSTALL file,
    like the one in the *xmahjongg-3.7* folder ([Figure 9-18](ch09s09.html#identifying_a_package_apostrophy_s_insta
    "Figure 9-18. Identifying a package's INSTALL file")). To read the INSTALL file,
    just double-click it, and it will open in Gedit.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在这个时候，你会浏览文件夹以找到处理该包的一些说明，就像你在本章早些时候为 Briscola 做的那样。在大多数源代码包中，这些信息包含在一个名为
    INSTALL 的文件中，就像 *xmahjongg-3.7* 文件夹中的那样 ([图 9-18](ch09s09.html#identifying_a_package_apostrophy_s_insta
    "图 9-18. 识别包的 INSTALL 文件")). 要读取 INSTALL 文件，只需双击它，它将在 Gedit 中打开。
- en: In this case, you can simply close the INSTALL file, because it prescribes the
    same steps I've listed next. However, in the future, when you install other programs
    from source, you will need to follow the instructions in the INSTALL files that
    come with the source files. However, with most INSTALL files, the instructions
    will match the process I am about to describe.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以简单地关闭 INSTALL 文件，因为它规定的步骤与我接下来要列出的步骤相同。然而，在将来，当你从源代码安装其他程序时，你需要遵循源代码文件中包含的
    INSTALL 文件中的说明。然而，对于大多数 INSTALL 文件，说明将与我要描述的过程相匹配。
- en: Of course, it may well happen that you take a look at the contents of the INSTALL
    file and start wondering what alien tongue it is written in. In cases when you
    have no idea what the INSTALL file is going on about, just look for a *configure*
    file in the package folder. If you find one, you should be able to follow the
    instructions in this project.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会查看 INSTALL 文件的内容，并开始怀疑它使用的是哪种外星语言。当你对 INSTALL 文件的内容一无所知时，只需在包文件夹中寻找一个
    *configure* 文件。如果你找到了，你应该能够遵循本项目的说明。
- en: '![Identifying a package''s INSTALL file](httpatomoreillycomsourcenostarchimages656397.png.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![识别包的 INSTALL 文件](httpatomoreillycomsourcenostarchimages656397.png.jpg)'
- en: Figure 9-18. Identifying a package's INSTALL file
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-18. 识别包的 INSTALL 文件
- en: '9D-3: Running configure and make for Xmahjongg'
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9D-3: 为 Xmahjongg 运行 configure 和 make'
- en: 'Now that you have downloaded and untarred the Xmahjongg tarball, installation
    is pretty standard. Here''s what you need to do:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经下载并解压了 Xmahjongg 的 tarball，安装过程相当标准。你需要做的是：
- en: Open a Terminal window, and then move into the new folder by typing **`cd xmahjongg*`**
    and pressing **enter**.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，然后通过输入 **`cd xmahjongg`** 并按 **enter** 键进入新文件夹。
- en: The next step is sort of a setup phase that runs the configure script in the
    *xmahjongg-3.7* folder. The configure script checks what files, compilers, and
    other things it needs, and then it searches your computer to see whether those
    things are there and, if so, where. Based on this information, it writes a file
    called a *makefile*, which is a set of instructions that will tell the `make`
    command in the subsequent step how to set things up specifically for your system
    configuration.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个步骤类似于一个设置阶段，它会在*xmahjongg-3.7*文件夹中运行configure脚本。configure脚本检查它需要哪些文件、编译器和其他东西，然后它搜索你的电脑以查看这些东西是否存在，如果存在，它们在哪里。基于这些信息，它编写一个名为*makefile*的文件，这是一个指令集，将告诉后续步骤中的`make`命令如何针对你的系统配置进行具体设置。
- en: Configure the program by typing **`./configure`** and pressing **enter**.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入**`./configure`**并按**回车**来配置程序。
- en: While you are running `configure`, you will see lots of odd and mysterious things
    flowing through your Terminal window; this is essentially a running account of
    what is going on, each step of the way. This can take a bit of time, but don't
    worry. As long as the mysterious text keeps flowing and you don't get an error
    message at the very end of the whole process, all will be well.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在运行`configure`时，你会在终端窗口中看到很多奇怪和神秘的事物流动；这实际上是对每一步正在发生的事情的运行记录。这可能会花费一些时间，但不要担心。只要神秘的文本继续流动，并且在整个过程的最后你没有收到错误信息，一切都会顺利。
- en: When `configure` has done its thing, you will see your prompt again, and you
    can go on to the next step, which is the translation, or *compilation*, step.
    The `make` command reads the makefile created by `configure` to see how things
    need to be set up on your machine. Then it proceeds to call on the compiler to
    translate the high-level source code into low-level, machine-readable files that
    can be installed in the subsequent step.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`configure`完成其任务后，你将再次看到你的提示符，然后你可以继续到下一步，即翻译或*编译*步骤。`make`命令读取`configure`创建的makefile，以查看在你的机器上需要如何设置。然后它调用编译器将高级源代码翻译成低级、机器可读的文件，这些文件可以在后续步骤中安装。
- en: To perform this translation, type **`make`**, and press **enter**.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行这个翻译，请输入**`make`**，然后按**回车**。
- en: Again, you will be treated to even more mysterious text flowing through the
    window and a short wait, usually a tad longer than for the configure process.
    Once `make` has done its job and you see your prompt again, you are ready to install
    the program.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，你将看到更多的神秘文本在窗口中流动，以及一段短暂的等待，通常比configure过程稍长一些。一旦`make`完成其工作，你再次看到提示符，你就准备好安装程序了。
- en: Up to this point, you have not changed your system in any way. All the changes
    thus far have taken place in the *xmahjongg-3.7* folder only—your system is still
    as pure as the day you started. Of course, all that is going to end right now
    when you perform the final installation step.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有以任何方式改变你的系统。到目前为止的所有更改都只发生在*xmahjongg-3.7*文件夹中——你的系统仍然像你开始时一样纯净。当然，所有这些都将随着你执行最终的安装步骤而结束。
- en: '9D-4: Installing and Running Xmahjongg'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9D-4：安装和运行Xmahjongg
- en: Now you've come to the last step in this part of the process, `make install`.
    Here you are telling your system to install what you have created, or *compiled*,
    in the `make` step. Note that because installation takes place in permissions-protected
    parts of your system, you will need to add `sudo` to the command string to give
    yourself administrative privileges.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经来到了这个流程部分的最后一步，`make install`。在这里，你正在告诉你的系统安装你在`make`步骤中创建的，或者说是*编译*的内容。请注意，由于安装发生在系统权限保护的部分，你需要将`sudo`添加到命令字符串中，以赋予自己管理权限。
- en: To perform the installation, type **`sudo make install`**, and press **enter**.
    You will then be prompted for your password. After typing it and pressing **enter**,
    the installation process will take place. Once your Terminal brings you back to
    your user prompt, Xmahjongg will be installed and ready to run. As a general rule,
    programs compiled from source do not automatically install a launcher in your
    Applications menu; you must instead run them by command. Although you can run
    a program for the first time by typing a command in the Run Application panel
    applet, it is better to run the program for the first time by typing the command
    in your Terminal window. If anything has gone amiss during installation, the Terminal
    will tell you what the problem is, whereas the Run Application method would just
    leave you wondering what's going on.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行安装，输入 **`sudo make install`**，然后按 **回车键**。你将需要输入密码。输入密码并按 **回车键**后，安装过程将开始。一旦你的终端带你回到用户提示符，Xmahjongg
    将被安装并准备好运行。一般来说，从源代码编译的程序不会自动在你的应用程序菜单中安装启动器；你必须通过命令来运行它们。虽然你可以通过在运行应用程序面板小程序中输入命令来首次运行程序，但最好是在终端窗口中输入命令来首次运行程序。如果在安装过程中有任何问题，终端会告诉你问题是什么，而运行应用程序方法只会让你感到困惑。
- en: To run Xmahjongg, just type **`xmahjongg`** in a Terminal window, and then press
    **enter**. If everything goes as it should, you can then create a program launcher
    for Xmahjongg in your Applications menu, on the GNOME Panel, or in a panel drawer.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Xmahjongg，只需在终端窗口中输入 **`xmahjongg`**，然后按 **回车键**。如果一切正常，你可以在你的应用程序菜单、GNOME
    面板或面板抽屉中创建一个 Xmahjongg 的程序启动器。
- en: '9D-5: Cleaning Up and/or Uninstalling Xmahjongg'
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9D-5：清理和/或卸载 Xmahjongg
- en: Once you are done and everything seems to be working as it should, you would
    normally tidy things up in the Xmahjongg folder by getting rid of any unnecessary
    files. You can do this via the Terminal by using the `cd` command to go back into
    the Xmahjongg folder, typing **`make clean`**, and then pressing **enter**.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成工作，并且一切似乎都在按预期工作，你通常会清理 Xmahjongg 文件夹，删除任何不必要的文件。你可以通过终端使用 `cd` 命令回到 Xmahjongg
    文件夹，输入 **`make clean`**，然后按 **回车键**来完成此操作。
- en: If you want to uninstall Xmahjongg, open a Terminal window, go back to the Xmahjongg
    folder by using the `cd` command, type **`sudo make uninstall`**, and finally
    press **enter**. The routine is essentially the same for any applications installed
    in this way, though as you might imagine, uninstallation isn't always as smooth
    a process as what I've just described (and it's definitely not as easy as it is
    via the Ubuntu Software Center).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要卸载 Xmahjongg，请打开一个终端窗口，使用 `cd` 命令回到 Xmahjongg 文件夹，输入 **`sudo make uninstall`**，然后按
    **回车键**。对于以这种方式安装的任何应用程序，这个过程基本上是相同的，尽管你可能想象得到，卸载过程并不总是像我所描述的那样顺利（而且肯定没有通过 Ubuntu
    软件中心卸载那么简单）。
- en: The main reason for the uninstallation process being less than cooperative is
    that the `make uninstall` routine requires you to keep the original project folder,
    which means you have to keep a bit of clutter you normally wouldn't need to bother
    with. On top of this, some projects do not provide a `make uninstall` routine
    at all. This means that you have to keep track of where everything has been installed
    in your system and then remove each item using a series of `sudo rm` commands.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程不合作的主要原因在于，`make uninstall` 程序要求你保留原始项目文件夹，这意味着你必须保留一些你通常不需要麻烦的杂乱东西。除此之外，一些项目甚至根本不提供
    `make uninstall` 程序。这意味着你必须跟踪系统中所有内容的安装位置，然后使用一系列 `sudo rm` 命令逐个删除每个项目。
- en: All that negativity aside, go ahead, have some fun, and put your command-line
    skills to the test. You'll have something to tell your grandkids about in the
    future.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 不谈这些负面的事情，继续前进，享受乐趣，并测试你的命令行技能。将来你会有一些可以告诉你的孙子辈的故事。
- en: Customizing the Terminal
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制终端
- en: The Terminal is a very simple application in terms of looks, though you can
    spice things up a bit if you're so inclined. Not only can you change the background
    and text colors in the Terminal, but you can even display one of your favorite
    photos as a background (as shown in [Figure 9-19](ch09s10.html#a_terminal_window_with_customized_backgr
    "Figure 9-19. A Terminal window with customized background and font colors"))
    or make the background transparent.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，终端是一个非常简单的应用程序，尽管如果您愿意，可以稍微装饰一下。您不仅可以在终端中更改背景和文本颜色，甚至还可以显示您最喜欢的照片作为背景（如图9-19所示）或使背景透明。
- en: To change the Terminal background, go to the Terminal, and select **Edit** ▸
    **Profiles**. When the Profiles window appears, select the profile you want to
    edit, which the first time out would be Default, and then click the **Edit** button.
    In the Editing Profile window that appears, click the **Background** tab, select
    **Background image** ([Figure 9-20](ch09s10.html#customizing_the_terminal_window
    "Figure 9-20. Customizing the Terminal window")), and then navigate to the photo
    you want to use as your background by clicking the **Menu** button next to the
    words *Image file* and then finding the file in the Select Background Image window.
    When you've found the photo of your choice, click **Open**. Depending on the image
    you use for your background, you may find it rather difficult to see the text
    once your image appears in the Terminal. If so, try moving the slider under the
    words *Shade transparent or image background* in the Editing Profile window. If
    that still doesn't do the trick, click the **Colors** tab, deselect **Use colors
    from system theme**, and then try some of the preset Foreground and Background
    combinations from the menu button next to the words *Built-in schemes*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改终端背景，请转到终端，并选择**编辑** ▸ **配置文件**。当配置文件窗口出现时，选择您想要编辑的配置文件，第一次通常是默认配置文件，然后点击**编辑**按钮。在出现的编辑配置文件窗口中，点击**背景**选项卡，选择**背景图片**
    ([图9-20](ch09s10.html#customizing_the_terminal_window "图9-20. 定制终端窗口")), 然后通过点击“*图像文件*”旁边的**菜单**按钮并找到您想要用作背景的图片，在“选择背景图片”窗口中进行导航。当您找到您选择的图片后，点击**打开**。根据您用作背景的图片，您可能会发现一旦图片出现在终端中，您可能很难看到文本。如果是这样，请尝试在编辑配置文件窗口中移动“*阴影透明或图像背景*”下面的滑块。如果这仍然不起作用，请点击**颜色**选项卡，取消选择**使用系统主题颜色**，然后尝试从“*内置方案*”旁边的菜单按钮中选择预设的前景和背景组合。
- en: '![A Terminal window with customized background and font colors](httpatomoreillycomsourcenostarchimages656399.png.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![定制背景和字体颜色的终端窗口](httpatomoreillycomsourcenostarchimages656399.png.jpg)'
- en: Figure 9-19. A Terminal window with customized background and font colors
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-19. 定制背景和字体颜色的终端窗口
- en: '![Customizing the Terminal window](httpatomoreillycomsourcenostarchimages656401.png.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![定制终端窗口](httpatomoreillycomsourcenostarchimages656401.png.jpg)'
- en: Figure 9-20. Customizing the Terminal window
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-20. 定制终端窗口
- en: If you just want to make the background transparent, go back to the **Background**
    tab, select **Transparent background**, and drag the slider to the right. You
    can also use the slider to adjust the shading of your background image if you
    choose to go that route.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想使背景透明，请返回**背景**选项卡，选择**透明背景**，并将滑块拖到右侧。如果您选择这种方式，您也可以使用滑块调整背景图片的阴影。
- en: Depending on the colors present in your background image or in your desktop
    wallpaper (if you've gone the transparent route), you may also want to change
    the font color for your Terminal to make things easier to see. To do this, click
    the **Colors** tab, deselect **Use colors from system theme**, and then make the
    appropriate font color selection.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的背景图片或桌面壁纸（如果您选择了透明方式）中的颜色，您可能还希望更改终端的字体颜色，以便更容易看到。为此，请点击**颜色**选项卡，取消选择**使用系统主题颜色**，然后进行适当的字体颜色选择。
- en: Tabbed Shell Sessions in the Terminal
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端中的分页Shell会话
- en: 'To wrap things up in this chapter, I thought I might mention one particularly
    convenient feature of the GNOME Terminal: tabs. Just as you can view multiple
    web pages in one Firefox web browser window through the use of tabs, tabs in the
    Terminal application allow you to have more than one shell session running at
    the same time without having more Terminal windows open (see [Figure 9-21](ch09s11.html#running_multiple_shell_sessions_in_tabs
    "Figure 9-21. Running multiple shell sessions in tabs within the GNOME Terminal")).
    This reduces the amount of desktop clutter and generally makes things easier to
    deal with. You can open a new tab within the Terminal by going to the Terminal
    and selecting **File** ▸ **Open Tab**.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章内容，我想提及GNOME终端的一个特别方便的功能：标签。正如您可以通过使用标签在单个Firefox浏览器窗口中查看多个网页一样，终端应用程序中的标签允许您同时运行多个shell会话，而无需打开更多的终端窗口（参见[图9-21](ch09s11.html#running_multiple_shell_sessions_in_tabs
    "图9-21. 在GNOME终端中通过标签运行多个shell会话")). 这减少了桌面上的杂乱，通常也使得处理事情变得更加容易。您可以通过在终端中选择**文件**
    ▸ **打开标签**来在终端中打开一个新的标签。
- en: '![Running multiple shell sessions in tabs within the GNOME Terminal](httpatomoreillycomsourcenostarchimages656403.png.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![在GNOME终端中通过标签运行多个shell会话](httpatomoreillycomsourcenostarchimages656403.png.jpg)'
- en: Figure 9-21. Running multiple shell sessions in tabs within the GNOME Terminal
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-21. 在GNOME终端中通过标签运行多个shell会话
