- en: Chapter 3. GEOCODING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。地理编码
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: I've demonstrated some fun map examples in the first two chapters of this book,
    but there's been an elephant in the room. Those latitude and longitude points
    I explained in [Describe a Point on the Earth](ch01s02.html "Describe a Point
    on the Earth") in [Describe a Point on the Earth](ch01s02.html "Describe a Point
    on the Earth") are obviously useful to a computer, but not to humans. How often
    have you been invited to a party at a location designated by only geographic coordinates?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书的前两章中演示了一些有趣的地图示例，但房间里有一头大象。我在[描述地球上的一个点](ch01s02.html "描述地球上的一个点")中解释的[描述地球上的一个点](ch01s02.html
    "描述地球上的一个点")中的经纬度点显然对计算机很有用，但对人类来说并不如此。你有多少次被邀请到一个仅用地理坐标指定的地点参加派对？
- en: In this chapter, I'll show how you can take something that makes sense to you—addresses,
    city names, and even postal codes—and turn them into the latitude and longitude
    points that Mapstraction needs. The conversion is called *geocoding*, and we'll
    look at several methods you can put to use in your own mapping projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将展示如何将对你有意义的事物——地址、城市名称，甚至邮政编码——转换成Mapstraction所需的纬度和经度点。这种转换称为*地理编码*，我们将探讨你可以在自己的地图项目中使用的几种方法。
- en: How Do Geocoders Work?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理编码器是如何工作的？
- en: At first glance, a geocoder looks like an oracle. You pass it an address, it
    looks into its crystal ball, and then it replies with a pair of numbers. Like
    magic, the coordinates, when plotted on a map, are exactly where the address is
    located. Let's take a look behind the curtain and see how a geocoder works.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，地理编码器就像一个先知。你给它一个地址，它看看它的水晶球，然后给出一个回复。就像魔法一样，当这些坐标在地图上标出时，它们正好位于地址所在的位置。让我们揭开幕布，看看地理编码器是如何工作的。
- en: As with most magic, you may be disappointed to find out that most geocoding
    is really just estimation. Geocoding isn't elegant—it's sort of brute force.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数魔法一样，你可能会失望地发现，大多数地理编码实际上只是估计。地理编码并不优雅——它有点像蛮力。
- en: 'First, the geocoder breaks the address into pieces. For example, consider Graceland''s
    address:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，地理编码器会将地址分解成各个部分。例如，考虑格莱美庄园的地址：
- en: 3734 Elvis Presley Blvd, Memphis, TN
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3734 Elvis Presley Blvd, Memphis, TN
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Street number, Street name, Suffix, City, State
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 街道号码，街道名称，后缀，城市，州
- en: The city is important because, believe it or not, other cities have an Elvis
    Presley Blvd. When you think of even more common names (say, Main Street), you
    can see how this step becomes important. In fact, within cities a road's suffix
    can be an issue, with a single street name being an Avenue, Street, Circle, and
    more. If you think those variations are confusing while navigating, think about
    how they confuse a geocoder.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 城市很重要，因为信不信由你，其他城市也有Elvis Presley Blvd。当你想到更常见的名称（比如，Main Street）时，你可以看到这一步是如何变得重要的。事实上，在城市内部，道路的后缀可能是一个问题，同一条街道可能被称为Avenue、Street、Circle等等。如果你认为这些变化在导航时很令人困惑，那么想想它们如何让地理编码器困惑。
- en: A street name match might be the toughest part of fixing a location. Dealing
    with misspellings and other ways of formatting a name can be difficult. Like many
    other major cities, my hometown of Portland, Oregon, has a street named after
    Martin Luther King, Jr. The street, both in Portland and in other cities, is commonly
    referred to as *MLK*. Whether a geocoder should recognize this abbreviation is
    debatable, but that gives you an idea of the sort of things you have to consider.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 街道名称匹配可能是修复位置中最困难的部分。处理拼写错误和其他名称格式化方式可能很困难。像许多其他大城市一样，我家乡俄勒冈州的波特兰市有一条以马丁·路德·金爵士命名的街道。这条街道在波特兰和其他城市都通常被称为*MLK*。是否应该让地理编码器识别这个缩写是有争议的，但这让你了解你必须考虑的一些问题。
- en: Now that you've zeroed in on the correct street and know its city, you need
    to find the actual address on the street. Storing every last address in the world
    isn't necessary and would be difficult since new ones are created all the time.
    Instead, most geocoders use street segments, as shown in [Figure 3-1](ch03.html#geocoders_use_street_segments_to_estimat
    "Figure 3-1. Geocoders use street segments to estimate location.").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确定了正确的街道并知道它的城市，你需要找到街道上的实际地址。存储世界上所有的地址是不必要的，而且由于新地址不断产生，这会很困难。相反，大多数地理编码器使用街道段，如图[图3-1](ch03.html#geocoders_use_street_segments_to_estimat
    "图3-1. 地理编码器使用街道段来估计位置")所示。
- en: '![Geocoders use street segments to estimate location.](httpatomoreillycomsourcenostarchimages671983.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![地理编码器使用街道段来估计位置。](httpatomoreillycomsourcenostarchimages671983.png.jpg)'
- en: Figure 3-1. Geocoders use street segments to estimate location.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1. 地理编码器使用街道段来估计位置。
- en: Using our Graceland example, we might know that a segment of Elvis Presley Blvd
    begins at 3700 and ends at 3799\. We also know the latitude and longitude points
    at each end of the segment. Using those pieces of information, we can estimate
    that Graceland, at 3734, is about a third of the way between 3700 and 3799\. Using
    the two points, the geocoder can then calculate an approximate location.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的格拉辛德（Graceland）为例，我们可能知道伊丽莎白·泰勒大道（Elvis Presley Blvd）的一段从3700号开始，到3799号结束。我们还知道该段两端的地纬度和经度点。使用这些信息，我们可以估计格拉辛德（3734号）大约位于3700号和3799号之间三分之一的位置。使用这两个点，地理编码器可以计算出大致的位置。
- en: JavaScript vs. HTTP Geocoding
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 与 HTTP 地理编码
- en: 'In this chapter, I will cover two major methods of retrieving latitude and
    longitude results from an address: via a JavaScript geocoding API or via a geocoding
    web service over HTTP. On the surface, these methods are very similar because
    the data that comes back is the same. The difference is in what you can do with
    the results.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍两种从地址中检索纬度和经度结果的主要方法：通过 JavaScript 地理编码 API 或通过 HTTP 上的地理编码网络服务。表面上，这些方法非常相似，因为返回的数据是相同的。区别在于你可以用结果做什么。
- en: '*JavaScript geocoders* call an external server with client-side code, meaning
    the code runs in the browser. This method is the same one used by Mapstraction
    and every mapping API. In this sense, JavaScript geocoders are extremely convenient
    for the web-mapping developer.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 地理编码器*使用客户端代码调用外部服务器，这意味着代码在浏览器中运行。这种方法与Mapstraction和每个映射API所使用的方法相同。从这个意义上说，JavaScript
    地理编码器对于网络地图开发者来说非常方便。'
- en: '*HTTP geocoders* also call an external server, but do so from your server,
    so the code runs outside the browser. This method is similar to the one used by
    PHP, the web programming language I''ve employed to show examples in [Chapter 9](ch09.html
    "Chapter 9. GO SERVER-SIDE"). In fact, you might use PHP to interpret the results
    from an HTTP geocoder.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*HTTP 地理编码器*也调用外部服务器，但这是从你的服务器进行的，所以代码在浏览器外运行。这种方法与我在第9章（ch09.html "第9章。服务器端编程"）中使用的网页编程语言PHP所使用的方法类似。事实上，你可能会使用PHP来解释HTTP地理编码器的结果。'
- en: Why would you use one type of geocoder over another? The quality of the data
    is similar, assuming the geocoders come from the same provider (i.e., Google).
    A JavaScript geocoder is usually just a wrapper for a server-side geocoder. In
    other words, both types end up calling upon the same dataset.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会选择使用一种类型的地理编码器而不是另一种？假设地理编码器来自同一提供商（例如，谷歌），数据质量是相似的。JavaScript 地理编码器通常只是服务器端地理编码器的一个包装器。换句话说，两种类型最终都会调用相同的数据集。
- en: The decision about which geocoder to use comes down to how much freedom you
    want with input and output. You can use a JavaScript geocoder in only a narrow
    band of ways. The input likely comes from the user via a form. The output almost
    certainly goes to a web page or to a map on the web page.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用哪种地理编码器的决定取决于你对输入和输出的自由度有多少。你只能以非常有限的方式使用 JavaScript 地理编码器。输入很可能来自用户通过表单。输出几乎肯定是要发送到网页或网页上的地图。
- en: Most of your location data will end up on a map, of course. You may want to
    do many things before that happens, however. Gaining control of the output is
    the biggest reason why you would use an HTTP geocoder. When the result is retrieved
    server-side, you have the option to store it to a database, cache the data, share
    the data over SMS or email, or send it off to a third-party service. Some of these
    options may be possible with a JavaScript geocoder, but they aren't easy to implement
    because they are outside the JavaScript geocoder's normal use—inside the browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你大部分的位置数据最终都会出现在地图上。然而，在发生这种情况之前，你可能想做很多事情。获取输出控制是你会使用 HTTP 地理编码器的主要原因之一。当结果在服务器端检索时，你有选项将其存储到数据库中，缓存数据，通过短信或电子邮件共享数据，或者将其发送到第三方服务。其中一些选项可能使用
    JavaScript 地理编码器是可能的，但它们不容易实现，因为它们超出了 JavaScript 地理编码器的正常用途——在浏览器内部。
- en: By using an HTTP geocoder, you control where you get your input. For example,
    you might retrieve it from a database, a third-party service, or a list of addresses.
    With a JavaScript geocoder, the input likely comes directly from data the user
    enters in an input box on a website. For many uses, that's all you'll need, but
    other times you'll want more freedom.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 HTTP 地理编码器，您控制着输入的来源。例如，您可能从数据库、第三方服务或地址列表中检索它。使用 JavaScript 地理编码器时，输入很可能直接来自用户在网站上的输入框中输入的数据。对于许多用途，这已经足够了，但有时您可能需要更多的自由度。
- en: If you spend enough time producing web maps, you'll probably combine JavaScript
    and HTTP geocoding. The rest of this chapter will focus on the different services
    you can use as you convert human-readable addresses to geographic coordinates
    (and vice versa).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您花足够的时间制作网络地图，您可能会结合使用 JavaScript 和 HTTP 地理编码。本章的其余部分将重点介绍您在将可读地址转换为地理坐标（反之亦然）时可以使用的不同服务。
- en: '#12: Geocode with JavaScript'
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#12: 使用 JavaScript 进行地理编码'
- en: When you want geocoding that stays within the web browser, you use JavaScript,
    the same programming language used by Mapstraction and every mapping provider
    it supports. You can retrieve a city name or address from a user and send it off
    to be geocoded. The response goes to a JavaScript callback function that you declare.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要在网页浏览器内进行地理编码时，您会使用 JavaScript，这是 Mapstraction 和它所支持的每个地图服务提供商所使用的相同编程语言。您可以从用户那里获取城市名称或地址，并将其发送进行地理编码。响应将发送到您声明的
    JavaScript 回调函数。
- en: 'As with mapping APIs, you can choose your own JavaScript geocoder. Predictably,
    I''ll show Mapstraction''s geocoder, which will use whichever provider you specify
    and give you the same flexibility that you get from using Mapstraction for creating
    maps: Write the code once and easily switch between providers.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与地图 API 一样，您可以选择自己的 JavaScript 地理编码器。不出所料，我将展示 Mapstraction 的地理编码器，它将使用您指定的任何提供商，并为您提供使用
    Mapstraction 创建地图时相同的灵活性：编写一次代码，轻松切换提供商。
- en: Because not every map requires geocoding, the geocoder is kept separate from
    the main Mapstraction code. Also, not every provider has a geocoder, so each is
    stored individually. In this example, we'll be using Google. You can download
    `mxn.google.geocoder.js` from [http://mapstraction.com/](http://mapstraction.com/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非每个地图都需要地理编码，因此地理编码器被保留在主 Mapstraction 代码之外。此外，并非每个提供商都有地理编码器，因此每个都单独存储。在这个例子中，我们将使用
    Google。您可以从 [http://mapstraction.com/](http://mapstraction.com/) 下载 `mxn.google.geocoder.js`。
- en: 'You include the Mapstraction geocoder in your code much like you include your
    mapping provider and Mapstraction proper. Add this line (assuming the file is
    in the current directory) within the `<head>` section of your basic map:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码中像包含您的地图提供商和 Mapstraction 本身一样包含 Mapstraction 地理编码器。假设文件位于当前目录中，在基本地图的
    `<head>` 部分添加此行：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the script included, use this code to initialize the map, geocode an address,
    and mark the result on the map:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 包含脚本后，使用以下代码初始化地图、将地址进行地理编码并在地图上标记结果：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with most map examples in this book, I use the `create_map` function to initialize
    the map. You can name this function whatever you want, as long as the function
    is called when the page loads.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的大多数地图示例一样，我使用 `create_map` 函数来初始化地图。您可以给这个函数取任何名字，只要在页面加载时调用这个函数即可。
- en: To create the Mapstraction geocoder object, we need to provide a callback function
    ❶ and tell Mapstraction which provider ❷ we want to use (the provider's JavaScript
    still needs to be included). The callback function receives the geocoded results.
    First, we need to give an address or city name to the geocoder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Mapstraction 地理编码器对象，我们需要提供一个回调函数 ❶ 并告诉 Mapstraction 我们想使用哪个提供商 ❷（提供商的 JavaScript
    仍然需要包含）。回调函数接收地理编码的结果。首先，我们需要给地理编码器提供一个地址或城市名称。
- en: We create a generic JavaScript object ❸ to hold the textual location information.
    Then, we add attributes for the parts of the address. The names may be slightly
    odd because Mapstraction is attempting to work not just in your country but around
    the world.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个通用的 JavaScript 对象 ❸ 来存储文本位置信息。然后，我们为地址的各个部分添加属性。名称可能有些奇怪，因为 Mapstraction
    正在尝试在全球范围内工作，而不仅仅是您的国家。
- en: Once the address's parts are filled in, you can send it to the geocoder ❹. Then,
    your callback function will be passed the results as a location object, which
    itself has some attributes of interest. Most important is the `LatLonPoint` of
    the address ❺. In this example, I've used the point to create a new marker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦地址的部分被填写完整，你可以将其发送到地理编码器 ❹。然后，你的回调函数将作为位置对象传递结果，该对象本身也有一些有趣的属性。最重要的是地址的`LatLonPoint`
    ❺。在这个例子中，我使用了这个点来创建一个新的标记。
- en: The marker needs a description, which I'll put inside a message box. I'm using
    the full address ❻, which the geocoder has cleaned up. As you can see in [Figure 3-2](ch03s03.html#geocoded_results_of_no_starch_press_offi
    "Figure 3-2. Geocoded results of No Starch Press offices"), the geocoder has added
    the ZIP Code, converted "Street" to "St" and refers to the country as "USA" instead
    of "US."
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 标记需要一个描述，我会把它放在一个消息框里。我使用的是完整的地址 ❻，这是地理编码器清理过的。正如你在[图3-2](ch03s03.html#geocoded_results_of_no_starch_press_offi
    "图3-2. No Starch Press办公室的地理编码结果")中看到的，地理编码器添加了邮政编码，将“Street”转换为“St”，并将国家称为“USA”而不是“US”。
- en: '![Geocoded results of No Starch Press offices](httpatomoreillycomsourcenostarchimages671985.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![No Starch Press办公室的地理编码结果](httpatomoreillycomsourcenostarchimages671985.png.jpg)'
- en: Figure 3-2. Geocoded results of No Starch Press offices
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-2. No Starch Press办公室的地理编码结果
- en: Of course, this example is only so useful. The address is hard-coded. You will
    likely be taking input from a user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子只具有这样的用途。地址是硬编码的。你很可能会从用户那里获取输入。
- en: Geocode User Input
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理编码用户输入
- en: JavaScript geocoders most commonly require user input to be helpful. Let's tweak
    the code from the previous section to take a textual location from an input box
    and geocode it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript地理编码器通常需要用户输入才能发挥作用。让我们调整上一节中的代码，从输入框中获取文本位置并进行地理编码。
- en: 'To start, you''ll need a place for the user to enter data. Let''s add a form
    to our HTML, either above or below the map `div`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个地方让用户输入数据。让我们在我们的HTML中添加一个表单，要么在地图`div`上方，要么在下方：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we need to do something when the user types in an address or city name.
    Here''s a new version of the `create_map` function with a few changes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在用户输入地址或城市名称时做些事情。下面是`create_map`函数的新版本，其中做了一些修改：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can't geocode until we get input, which won't happen until the user submits
    the form. So we wait for submission ❶ and then jump into action with an anonymous
    function. We could have used a named function, but with only a few lines writing
    the code inline is easiest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在得到输入之前不能进行地理编码，而输入只有在用户提交表单时才会发生。所以我们等待提交 ❶，然后使用匿名函数采取行动。我们也可以使用命名函数，但只有几行代码，直接在代码中编写是最容易的。
- en: In the previous section, I separated each piece of the address. In the case
    of input from a user, that is not always possible. Instead, I've provided the
    entire value of the input box to the geocoder ❷.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我分别处理了地址的每一部分。在用户输入的情况下，这并不总是可能的。相反，我已经将输入框的整个值提供给地理编码器 ❷。
- en: The callback function, `add_point`, can remain the same. Enter an address and
    it adds a marker to the geocoded point. Do it again and now you have two markers.
    This geocoding could get addicting.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数`add_point`可以保持不变。输入一个地址，它会在地理编码的点处添加一个标记。再次操作，现在你有了两个标记。这种地理编码可能会上瘾。
- en: '#13: Geocode with an HTTP Web Service'
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#13: 使用HTTP网络服务进行地理编码'
- en: JavaScript is convenient when you want to geocode in the browser. You gain more
    control of your geocoding by using a web service, however. The addresses can come
    from anywhere, including a list of places. The results can be stored anywhere,
    including a database, so you can access them anytime and plot them on a map.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在浏览器中进行地理编码时，JavaScript非常方便。然而，通过使用网络服务，你可以获得更多对地理编码的控制。地址可以来自任何地方，包括地点列表。结果可以存储在任何地方，包括数据库，这样你就可以随时访问并在地图上绘制它们。
- en: Several geocoders are available to choose from, including one each from Google
    and Yahoo!. The input for each is slightly different, as are the results. In the
    next sections, I outline how to use these two geocoders and point you to a few
    others.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个地理编码器可供选择，包括来自Google和Yahoo!的各一个。每个的输入略有不同，结果也是如此。在接下来的几节中，我将概述如何使用这两个地理编码器，并指向一些其他的地理编码器。
- en: Use Google's Geocoding Web Service
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Google的地理编码网络服务
- en: Google is the king of the web-mapping world, so of course, Google has a geocoding
    web service. You can use it to convert an address or city into latitude and longitude
    points and grab the result in one of several data formats. As an added benefit,
    Google pretties up the address for you and provides multiple options when the
    query is ambiguous.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Google是网络地图世界的王者，因此当然，Google有一个地理编码网络服务。您可以使用它将地址或城市转换为经纬度点，并以几种数据格式之一获取结果。作为额外的好处，Google为您美化了地址，并在查询模糊时提供了多个选项。
- en: 'One of the additional freedoms of using a web service to geocode is that you
    can look at results in a web browser, without writing any actual code. Check out
    the following URL in your browser:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络服务进行地理编码的额外自由之一是您可以在网页浏览器中查看结果，而无需编写任何实际代码。请在您的浏览器中查看以下URL：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters you can send to Google are shown in bold, along with all possible
    parameters that are shown in [Table 3-1](ch03s04.html#google_geocoder_parameters
    "Table 3-1. Google Geocoder Parameters"). The entire address is passed as the
    `q` query argument. You could also simply include a city name or postal code here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向Google发送的参数以粗体显示，以及所有在[表3-1](ch03s04.html#google_geocoder_parameters "表3-1.
    Google地理编码器参数")中显示的可能参数。整个地址作为`q`查询参数传递。您也可以简单地在这里包含一个城市名称或邮政编码。
- en: Table 3-1. Google Geocoder Parameters
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1. Google地理编码器参数
- en: '| Parameter | Description |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `q` | *Required*. Query to search, such as address or city name |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `q` | *必需*。查询，例如地址或城市名称 |'
- en: '| `sensor` | *Required*. Whether from a mobile device: `true` or `false` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `sensor` | *必需*。是否来自移动设备：`true`或`false` |'
- en: '| `output` | Format of results: `json` (default), `xml`, `kml`, or `csv` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `output` | 结果格式：`json`（默认），`xml`，`kml`或`csv` |'
- en: '| `gl` | Country code as a top-level domain. E.g., `us`, `ca`, `uk` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `gl` | 国家代码作为顶级域名。例如，`us`，`ca`，`uk` |'
- en: The `output` we want is XML, which can be read by most any programming language.
    And unless you are using this geocoder from a mobile device, set `sensor` to false.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的`output`是XML格式，大多数编程语言都可以读取。除非您是从移动设备使用此地理编码器，否则将`sensor`设置为false。
- en: 'Now let''s look at the XML results from the above call to Google''s HTTP geocoder:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看从Google的HTTP地理编码器调用中得到的XML结果：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The results are actually in *Keyhole Markup Language* (KML), a flavor of XML
    (see [#55: Use KML](ch08s04.html "#55: Use KML") in [#55: Use KML](ch08s04.html
    "#55: Use KML")). The coordinates and other information about the geocoded place
    are stored as Placemarks. In our example, we only have one Placemark ❶, because
    only one result is possible for a complete address. In ambiguous cases (say we
    searched for simply "Springfield"—many places have that name), the best result
    will be listed as the first Placemark, with others receiving incremented ids (i.e.,
    p2, p3, etc.).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '结果实际上是在*Keyhole标记语言*（KML）中，这是一种XML的变体（参见[#55: 使用KML](ch08s04.html "#55: 使用KML")）。地理编码地点的坐标和其他信息存储为Placemark。在我们的例子中，我们只有一个Placemark❶，因为对于完整的地址只有一个可能的结果。在模糊的情况下（比如说我们搜索了简单的“Springfield”——许多地方都有这个名称），最佳结果将作为第一个Placemark列出，其他结果将获得递增的id（即，p2，p3等）。'
- en: In fact, if you want your application to show possible results, as [http://maps.google.com/](http://maps.google.com/)
    does, use the full formatted address ❷ of each Placemark. You can see here that
    Google cleaned up even my specific address, converting the "Street" to "St" and
    adding the postal code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果您想让您的应用程序显示可能的结果，就像[http://maps.google.com/](http://maps.google.com/)所做的那样，请使用每个Placemark的完整格式化地址❷。您可以看到，谷歌甚至清理了我的具体地址，将“Street”转换为“St”并添加了邮政编码。
- en: The pieces of the address can also be accessed individually, yet the tag names
    might seem strange to you. That's because Google has made them generic, so the
    tags aren't confusing to people not in the United States. The state abbreviation
    ❸ is called an *Administrative Area Name*, for example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 地址的各个部分也可以单独访问，但标签名称可能对您来说很奇怪。这是因为Google使它们通用，所以标签不会使不在美国的人感到困惑。例如，州缩写❸被称为*行政区域名称*。
- en: Accessing the values individually makes showing just the city ❹ or only the
    address ❺ easier. Also, accessing them individually is a quick way to determine
    a place's postal code ❻ (called a ZIP Code in the US).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单独访问值可以更轻松地显示城市❹或仅地址❺。此外，单独访问它们是快速确定一个地方的邮政编码❻（在美国称为ZIP Code）的方法。
- en: Finally, the most important part of geocoding is the latitude and longitude
    points. These points are stored together within a single tag ❼. You can use a
    split function (one using PHP is shown in the next section) to retrieve the coordinates'
    individual pieces.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，地理编码最重要的部分是纬度和经度点。这些点存储在一个单独的标签 ❼ 中。你可以使用分割函数（下一节将展示 PHP 中的一个）来检索坐标的各个部分。
- en: Did you notice that Google provides three numbers instead of just two? The third
    represents altitude and is a property of the KML format. The geocoder does not
    send this value, so it will always be zero.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到谷歌提供了三个数字而不是两个吗？第三个数字代表海拔，是 KML 格式的一个属性。地理编码器不会发送这个值，所以它总是为零。
- en: If you need help bringing these geocoder results into your applications, [Chapter 9](ch09.html
    "Chapter 9. GO SERVER-SIDE") can show you how to do so in PHP. Or, if you only
    need the coordinates, read on to see Google's approach to really simple geocoding.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助将这些地理编码结果引入你的应用程序，[第 9 章](ch09.html "第 9 章. 服务器端 GO")可以展示如何在 PHP 中这样做。或者，如果你只需要坐标，请继续阅读，了解谷歌对真正简单地理编码的方法。
- en: Alternate Data Formats
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他数据格式
- en: I love XML, but it's not always the preferred data format. Google's web service
    geocoder gives you a choice of several formats, including JavaScript Object Notation
    (JSON) and comma-separated values (CSV). The latter is great when you want "just
    the facts."
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢 XML，但它并不总是首选的数据格式。谷歌的地理编码网络服务提供了多种格式选择，包括 JavaScript 对象表示法 (JSON) 和逗号分隔值
    (CSV)。后者在你只想“只看事实”时非常棒。
- en: 'Plop an `output` argument in the URL and set its value to be the desired format,
    for example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中放入一个 `output` 参数，并将其值设置为所需的格式，例如：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we ask for CSV. Unlike other result formats, we don''t get a rewritten
    address, a postal code, or any other niceties. We do, however, get the four most
    important values separated by commas:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求 CSV。与其他结果格式不同，我们不会得到重写的地址、邮编或其他任何好处。然而，我们确实得到了四个最重要的值，由逗号分隔：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first part is the code from the server. A `200` means we have a good result.
    Anything else, and we likely have an error.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是来自服务器的代码。`200` 表示我们有一个好的结果。其他任何东西，我们可能有一个错误。
- en: The second part is a number that represents the granularity of our result. Is
    it street-level (an address), postal-level, or city-level? The possible results
    are roughly equivalent to zoom levels, as shown in [Table 3-2](ch03s04.html#levels_codes_for_geocoding_accuracy
    "Table 3-2. Levels Codes for Geocoding Accuracy").
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是一个数字，代表我们结果的粒度。它是街道级别（一个地址）、邮政级别还是城市级别？可能的结果大致相当于缩放级别，如[表 3-2](ch03s04.html#levels_codes_for_geocoding_accuracy
    "表 3-2. 地理编码精度级别代码")所示。
- en: Table 3-2. Levels Codes for Geocoding Accuracy
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2. 地理编码精度级别代码
- en: '| Code | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Unknown |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 未知 |'
- en: '| 1 | Country |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 国家 |'
- en: '| 2 | State (or similar region) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 州（或类似区域）|'
- en: '| 3 | County (or other subregion) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 县（或其他子区域）|'
- en: '| 4 | City |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 城市 |'
- en: '| 5 | Postal code |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 邮编 |'
- en: '| 6 | Street |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 街道 |'
- en: '| 7 | Intersection |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 交叉点 |'
- en: '| 8 | Address |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 地址 |'
- en: '| 9 | Building (such as landmarks) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 建筑物（如地标）|'
- en: The last two numbers of the CSV results might look familiar. They are the latitude
    and longitude points (in that order). These results are probably the most important
    because geocoding is all about turning a city name or address into plotable coordinates.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 结果的最后两个数字可能看起来很熟悉。它们是纬度和经度点（按此顺序）。这些结果可能是最重要的，因为地理编码的全部内容就是将城市名称或地址转换为可绘制的坐标。
- en: 'Here''s some simple PHP code that calls out to the Google geocoder web service,
    parses the CSV results, and saves the coordinates to variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些简单的 PHP 代码，它调用谷歌地理编码网络服务，解析 CSV 结果，并将坐标保存到变量中：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is just a snippet to give you an idea of how to separate simple CSV
    results like those in this example. If you run this code, nothing will happen
    because all I have shown here is storing the results in variables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只是一个片段，以给你一个如何分离简单 CSV 结果（如本例中所示）的思路。如果你运行这段代码，什么也不会发生，因为我所展示的只是将结果存储在变量中。
- en: To begin, we create a variable to hold the URL we'll use to call Google. Because
    the variable is long and this book's pages are only so wide, I split it into two
    lines ❶, but to PHP, the variable is all one text string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个变量来保存我们将用于调用谷歌的 URL。因为变量很长，而这本书的页面只有那么宽，所以我将其拆分为两行❶，但对于 PHP 来说，这个变量是一个完整的文本字符串。
- en: 'The URL is then passed to the `get_url` function ❷, one I will show you how
    to write in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve a Web Page")
    in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve a Web Page"). You''ll
    need to include a file with that code or paste a copy of the function near the
    bottom of your PHP file.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '然后将 URL 传递给 `get_url` 函数❷，这是一个我将在 [#61: 获取网页](ch09s03.html "#61: 获取网页") 中向你展示如何编写的函数。[#61:
    获取网页](ch09s03.html "#61: 获取网页")。你需要包含一个包含该代码的文件或在你 PHP 文件的底部附近粘贴该函数的副本。'
- en: Once we have a result from Google, we explode the text ❸ into several pieces,
    all stored in a single array variable. Because a comma is used to separate the
    data, that's the delimiter we'll use to split the text.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从谷歌得到结果，我们就将文本 ❸ 分解成几个部分，所有这些部分都存储在一个单独的数组变量中。因为数据是用逗号分隔的，所以我们将使用逗号作为分隔符来分割文本。
- en: With the pieces stored as elements of an array, we're almost ready to get our
    latitude and longitude. We need to make sure the array variable has four results
    ❹, as expected. Also, the first number in the results needs to be `200` ❺, the
    code for a good result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将部分存储为数组的元素后，我们几乎准备好获取我们的纬度和经度了。我们需要确保数组变量有四个结果 ❹，正如预期的那样。此外，结果中的第一个数字必须是 `200`
    ❺，这是良好结果的代码。
- en: Because arrays in PHP start counting at the zeroth spot, our latitude and longitude
    are stored as the second and third indexes of the explode result variable. With
    very little PHP code and even less text, you've now successfully turned an address
    into geographic coordinates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PHP 中的数组从零开始计数，所以我们的纬度和经度被存储在 explode 结果变量的第二个和第三个索引中。用很少的 PHP 代码和更少的文本，你现在已经成功地将一个地址转换成了地理坐标。
- en: Use Yahoo!'s Geocoding Web Service
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Yahoo! 地理编码网络服务
- en: Though Google may get the lion's share of the press, Yahoo's geo-developer tools
    are exceptional. Such is the case with its easy-to-use, full-featured geocoding
    web service. You pass a city name or full address and Yahoo! spits out simple
    XML with coordinates and other geographic data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然谷歌可能获得了大部分的媒体报道，但 Yahoo 的地理开发者工具非常出色。这种情况适用于其易于使用、功能齐全的地理编码网络服务。你传递一个城市名称或完整的地址，Yahoo!
    就会输出带有坐标和其他地理数据的简单 XML。
- en: 'Because the result is just plain XML, you can check it out in your web browser
    to get a feel for how the service works. Visit this URL:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为结果只是普通的 XML，你可以在你的网络浏览器中查看它，以了解该服务的工作方式。访问这个 URL：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The arguments are shown in bold. You'll need your API key as the `appid`. This
    ID is the same as for the Yahoo! Maps API. I showed you how to sign up for an
    ID in [Create a Yahoo! Map](ch01s03.html#create_a_yahoo_exclamation_map "Create
    a Yahoo! Map") in [Create a Yahoo! Map](ch01s03.html#create_a_yahoo_exclamation_map
    "Create a Yahoo! Map").
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 参数以粗体显示。你需要将你的 API 密钥作为 `appid`。这个 ID 与 Yahoo! 地图 API 中的 ID 相同。我在 [创建 Yahoo!
    地图](ch01s03.html#create_a_yahoo_exclamation_map "创建 Yahoo! 地图") 中向你展示了如何注册 ID。[创建
    Yahoo! 地图](ch01s03.html#create_a_yahoo_exclamation_map "创建 Yahoo! 地图")。
- en: 'In this example, the pieces of the address are segmented into `street`, `city`,
    and `state`. You can also use a single argument for an address, similar to Google''s
    geocoder:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，地址的部分被分割成 `street`、`city` 和 `state`。你也可以用一个参数表示地址，类似于 Google 的地理编码器：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `location` argument contains all the pieces in the previous example but
    puts them in one place. If you are receiving an address as input from a user,
    you will prefer this option unless you have a way to separate the address into
    pieces (such as multiple form fields).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`location` 参数包含上一个示例中的所有部分，但将它们放在一个地方。如果你从用户那里接收地址作为输入，你将更喜欢这个选项，除非你有方法将地址分解成各个部分（例如多个表单字段）。'
- en: 'No matter which way you call the API, the results will be formatted the same
    way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你以何种方式调用 API，结果将以相同的方式格式化：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compared to Google's XML results, these results are very simple. The latitude
    and longitude are shown separately, as are the pieces of the address (even if
    you send the location as one string of text, Yahoo! separates things out for you).
    Each field makes sense as long as you are geocoding addresses or cities in the
    United States. In Canada, for example, you have to know that provinces are stored
    in the `<state>` tag.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Google 的 XML 结果相比，这些结果非常简单。纬度和经度分别显示，地址的各个部分也是如此（即使你发送的是一个文本字符串，Yahoo! 也会为你分开）。只要你在美国对地址或城市进行地理编码，每个字段都有意义。例如，在加拿大，你必须知道省份存储在
    `<state>` 标签中。
- en: If your search has ambiguous results, such as a non-unique city name, Yahoo!
    will put the best result first. Other results will follow inside their own `<Result>`
    tag.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的搜索结果模糊，例如城市名称不唯一，Yahoo! 将将最佳结果放在首位。其他结果将跟随在其自己的 `<Result>` 标签内。
- en: 'Because you''re working with simple XML here, you can parse them as you would
    any other XML. [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use
    XML") in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52: Use XML")
    shows this process in PHP and JavaScript. If you want other formats, Yahoo! does
    provide results as JSON or Serialized PHP. The first is covered in [#53: Use JSON](ch08s02.html
    "#53: Use JSON") in [#53: Use JSON](ch08s02.html "#53: Use JSON"), whereas the
    second is explained at [http://developer.yahoo.com/common/phpserial.html/](http://developer.yahoo.com/common/phpserial.html/).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '由于你在这里使用的是简单的 XML，你可以像解析任何其他 XML 一样解析它们。[#52: 使用 XML](ch08.html#number_symble_52_colon_use_xml
    "#52: 使用 XML") 在 [#52: 使用 XML](ch08.html#number_symble_52_colon_use_xml "#52:
    使用 XML") 中展示了这个过程在 PHP 和 JavaScript 中的实现。如果你需要其他格式，Yahoo! 提供了 JSON 或序列化 PHP 格式的结果。第一种格式在
    [#53: 使用 JSON](ch08s02.html "#53: 使用 JSON") 中介绍，而第二种格式在 [http://developer.yahoo.com/common/phpserial.html/](http://developer.yahoo.com/common/phpserial.html/)
    中解释。'
- en: Other Geocoding Web Services
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他地理编码网络服务
- en: The previous examples show the two most likely choices for geocoders, but you
    have other options, especially if you are willing to pay for the service. Why
    shell out dough when Google and Yahoo! give away geocoding? Your choice really
    comes down to the terms of service and rate limits, which can restrict your use
    of a geocoder for high traffic, commercial purposes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了地理编码器的两种最可能的选择，但你还有其他选择，尤其是如果你愿意为服务付费的话。为什么要在 Google 和 Yahoo! 免费提供地理编码的情况下花钱呢？你的选择实际上取决于服务条款和速率限制，这些限制可能会限制你在高流量、商业用途中对地理编码器的使用。
- en: You won't necessarily need to crush that piggy bank to use a for-pay geocoder.
    For example, *geocoder.us* only charges a quarter of a US cent to geocode an address.
    For an up-to-date list of geocoder services, see [http://mapscripting.com/geocoders/](http://mapscripting.com/geocoders/).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你不一定需要打破那个储蓄罐来使用付费地理编码器。例如，*geocoder.us* 只需收取四分之一美分来对地址进行地理编码。有关地理编码服务器的最新列表，请参阅
    [http://mapscripting.com/geocoders/](http://mapscripting.com/geocoders/)。
- en: '#14: Reverse Geocoding: Get an Address from a Point'
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#14: 反向地理编码：从点获取地址'
- en: So far we have used human-readable information—a city name or address—to retrieve
    latitude and longitude points, which are easier for a computer to understand.
    From time to time, you may want to go the other way. If all you have is a set
    of coordinates, you can use them to reverse geocode to get the address and other
    geographic information that will make sense to a human.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是人类可读的信息——城市名称或地址——来检索经纬度坐标点，这对于计算机来说更容易理解。有时，你可能想反过来操作。如果你只有一组坐标，你可以使用它们进行反向地理编码，以获取对人类有意义的地址和其他地理信息。
- en: Regular geocoding is complicated and imprecise, but reverse geocoding is more
    so. First, the geocoder finds the street that is closest to the coordinates; then,
    it determines which address belongs to that point. Truthfully, the result is more
    often a range of addresses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正常地理编码既复杂又不精确，但反向地理编码更是如此。首先，地理编码器找到离坐标最近的街道；然后，它确定哪个地址属于该点。说实话，结果往往是地址范围。
- en: 'Reverse geocoding may seem a little silly given that it is imperfect. But as
    location becomes more prevalent on the Web, reverse geocoding will become more
    common. For example, consider [#48: Get Location Using JavaScript](ch07s02.html
    "#48: Get Location Using JavaScript") in [#48: Get Location Using JavaScript](ch07s02.html
    "#48: Get Location Using JavaScript"). In many cases, the GPS or other device
    reporting someone''s whereabouts will only provide the latitude and longitude
    points. That information is enough to plot it on a map, but not enough to make
    much sense to humans viewing the information.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到它并不完美，反向地理编码可能看起来有点荒谬。但随着位置信息在互联网上的普及，反向地理编码将会变得更加常见。例如，考虑 [#48: 使用 JavaScript
    获取位置](ch07s02.html "#48: 使用 JavaScript 获取位置") 在 [#48: 使用 JavaScript 获取位置](ch07s02.html
    "#48: 使用 JavaScript 获取位置")。在许多情况下，GPS 或其他报告某人位置的设备只会提供经纬度坐标点。这些信息足以在地图上标出，但对于查看信息的人类来说，信息并不充分。'
- en: In the following sections, I'll show two services, both from Google, that will
    provide reverse geocoding, helping you create geographic information from computer-readable
    data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我将展示两个服务，这两个服务都来自 Google，它们将提供反向地理编码，帮助你从可读数据中创建地理信息。
- en: Reverse Geocode with JavaScript
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 进行反向地理编码
- en: If you use Google as your mapping provider, reverse geocoding can happen within
    your JavaScript code without even loading Mapstraction's geocoder (which only
    supports *forward* geocoding). In this example, we'll still use Mapstraction because
    the reverse geocoding is only a small part of a map's code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Google 作为你的地图服务提供商，反向地理编码可以在你的 JavaScript 代码中发生，甚至不需要加载 Mapstraction 的地理编码器（它只支持
    *正向* 地理编码）。在这个例子中，我们仍然使用 Mapstraction，因为反向地理编码只是地图代码的一个小部分。
- en: Let's create a basic Mapstraction map, with Google as the provider. We'll convert
    the center of the map to a Google point and send it off to be reverse geocoded.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的 Mapstraction 地图，使用 Google 作为提供者。我们将地图的中心转换为 Google 点，并发送它进行反向地理编码。
- en: 'Assuming you have your HTML set up as in [Create a Mapstraction Map](ch01s03.html#create_a_mapstraction_map
    "Create a Mapstraction Map") in [Create a Mapstraction Map](ch01s03.html#create_a_mapstraction_map
    "Create a Mapstraction Map"), here is the JavaScript to create the map and call
    the Google geocoder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 HTML 设置如 [创建 Mapstraction 地图](ch01s03.html#create_a_mapstraction_map "创建
    Mapstraction 地图") 中所述，以下是创建地图并调用 Google 地理编码器的 JavaScript 代码：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As promised, much of this code is comprised of Mapstraction functions. The Google-specific
    calls are separated out. For example, we create a geocoder object ❶ and then make
    the call to get the location. Even this contains some Mapstraction, as we use
    it to get the center of the map ❷ and convert that point to one Google understands.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺的那样，大部分代码都是由 Mapstraction 函数组成的。特定于 Google 的调用被分离出来。例如，我们创建一个地理编码器对象 ❶，然后调用以获取位置。甚至这个调用也包含一些
    Mapstraction，因为我们使用它来获取地图的中心 ❷，并将该点转换为 Google 可以理解的点。
- en: With the call to the geocoder, we need to provide a callback function ❸. This
    function is used when the result comes back from Google. Because we created a
    named function, we also need to create the function with that name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用地理编码器时，我们需要提供一个回调函数 ❸。这个函数在结果从 Google 返回时使用。因为我们创建了一个命名函数，所以我们还需要用那个名字创建该函数。
- en: The `found_address` function takes one argument, which is the results object
    that Google's geocoder sends to us. Once we've determined we have a good response
    ❹ (a status code of `200`), we can grab the point ❺, which contains our coordinates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`found_address` 函数接受一个参数，即 Google 地理编码器发送给我们的结果对象。一旦我们确定我们有一个良好的响应 ❹（状态码为 `200`），我们就可以获取点
    ❺，它包含我们的坐标。'
- en: You might wonder why the point is even necessary, seeing as this is the piece
    of data that you started with. In many cases, Google isn't able to find an address
    at your *exact* point (imagine the center of a large park, for example), so it
    chooses one nearby. In that case, you'll want to know the point it used, so you
    can plot accordingly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么这个点甚至有必要，因为这是你开始的地方的数据。在许多情况下，Google 无法在您的 *确切* 点找到地址（例如，想象一下一个大公园的中心），因此它会选择一个附近的地址。在这种情况下，您将想要知道它使用的点，以便相应地绘制。
- en: Google might actually send multiple results, which would be stored in the `response.Placemark`
    array. The first is its best guess and probably the one to use, though in some
    situations you could allow the user to select the most accurate result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Google 实际上可能会发送多个结果，这些结果将存储在 `response.Placemark` 数组中。第一个是它的最佳猜测，并且可能是应该使用的那个，尽管在某些情况下，您可能允许用户选择最准确的结果。
- en: Most of the remaining code in `found_address` will look familiar, as it's standard
    Mapstraction functions from [Chapter 2](ch02.html "Chapter 2. PLOTTING MARKERS
    AND MESSAGE BOXES"). We put a marker at the location Google returned. Then, we
    use the most important piece of information, the address ❻, as the message inside
    the marker's box.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`found_address` 中剩余的大部分代码看起来很熟悉，因为它来自 [第 2 章](ch02.html "第 2 章。绘制标记和信息框") 的标准
    Mapstraction 函数。我们在 Google 返回的位置放置一个标记。然后，我们使用最重要的信息，即地址 ❻，作为标记框内的信息。'
- en: To get a good feel for reverse geocoding, try changing the coordinates you pass
    to Google by altering the center of the map. Or, read on to make a map that reverse
    geocodes wherever you click.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解反向地理编码，尝试通过改变地图的中心来更改传递给 Google 的坐标。或者，继续阅读以创建一个点击任何地方都会进行反向地理编码的地图。
- en: Reverse Geocode in a Click
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点击进行反向地理编码
- en: Want to play around with reverse geocoding? Attempting to click exactly on your
    own address to see how close you can come to your exact location can be fun. Also,
    giving yourself quick access to reverse geocoding can be a good developer tool
    to get a better idea of how the process works.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 想要尝试反向地理编码吗？尝试精确点击你的地址，看看你能多接近你的确切位置，这可以很有趣。此外，快速访问反向地理编码也可以是一个好的开发者工具，帮助你更好地了解这个过程。
- en: 'You can use most of the previous example. In fact, `found_address` can stay
    exactly the same. Replace the `create_map` function with this slightly altered
    version:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用大多数之前的示例。实际上，`found_address`可以保持完全相同。将`create_map`函数替换为这个略微修改的版本：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I added some zoom controls ❶ to the map, so you can find specific places to
    click (in San Francisco, unless you change the map's center or scroll the map
    to another location). Then I wrote some code that waits for a click event ❷ on
    the map. When the click occurs, it calls an anonymous, inline function. This function
    could be named, but with only a few simple lines, writing it inline is easier.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我在地图上添加了一些缩放控件❶，这样你可以找到特定的点击位置（除非你更改地图的中心或滚动地图到另一个位置，否则是在旧金山）。然后我编写了一些代码，等待地图上的点击事件❷。当点击发生时，它调用一个匿名内联函数。这个函数可以被命名，但只有几行简单的代码，内联编写更容易。
- en: Within the anonymous function, we make a call to the Google geocoder very similar
    to the one we used before. In this instance, we pass the point where the user
    clicked ❸ instead of the center of the map. Note that we need to convert the point
    to the proprietary Google coordinate type because Mapstraction captures the clickpoint
    but then needs to pass it off to a Google geocoder. Mapstraction speaks Google,
    but Google does not speak Mapstraction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名函数中，我们调用谷歌地理编码器，与之前使用的非常相似。在这个例子中，我们传递用户点击的点❸而不是地图的中心。请注意，我们需要将点转换为专有的谷歌坐标类型，因为Mapstraction捕获点击点，然后需要将其传递给谷歌地理编码器。Mapstraction说谷歌话，但谷歌不说Mapstraction话。
- en: Because the other code is the same, clicking the map adds a marker with the
    address in an opened message box. Click a few more times and additional markers
    will appear on the map, containing the geographic information provided by the
    reverse geocoder.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其他代码相同，点击地图会在打开的消息框中添加带有地址的标记。点击几次更多，地图上会出现额外的标记，包含反向地理编码器提供的地理信息。
- en: Are you beginning to see the usefulness of a reverse geocoder? In the next section,
    you'll be able to access that data outside of JavaScript, with Google's HTTP geocoder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始看到反向地理编码器的有用性了吗？在下一节中，你将能够使用谷歌的HTTP地理编码器在JavaScript之外访问这些数据。
- en: Reverse Geocode with Google's Web Service
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用谷歌网络服务进行反向地理编码
- en: As I've mentioned elsewhere in this chapter, power and flexibility come from
    being able to control the input and output of a geocoder. You can have the same
    freedom using the reverse geocoding provided by Google's web service.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章的其他地方提到的，力量和灵活性来自于能够控制地理编码器的输入和输出。你可以使用谷歌提供的反向地理编码服务获得相同的自由。
- en: 'With a tiny tweak to the URL, Google''s geocoder becomes a reverse geocoder:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对URL进行微调，谷歌的地理编码器变成了反向地理编码器：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''re still using the `q` query argument, as we did in the Google portion
    of [#13: Geocode with an HTTP Web Service](ch03s04.html "#13: Geocode with an
    HTTP Web Service") in [#13: Geocode with an HTTP Web Service](ch03s04.html "#13:
    Geocode with an HTTP Web Service"). Instead of passing an address, we send the
    latitude and longitude, in that order and separated by a comma (bolded in the
    above URL).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '我们仍然使用`q`查询参数，就像在[第13节：使用HTTP网络服务进行地理编码](ch03s04.html "#13: Geocode with an
    HTTP Web Service")中谷歌部分所做的那样。我们发送的是纬度和经度，按照这个顺序，用逗号分隔（在上面的URL中用粗体标出）。'
- en: 'The results are virtually the same as with the forward geocoder:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果几乎与使用正向地理编码器相同：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The biggest difference is that you are bound to have multiple Placemarks, because
    reverse geocoding is much less precise than standard geocoding. Otherwise, the
    content you receive within each Placemark is the same, right down to the postal
    code—as, of course, is the address (or range), which is the entire point of the
    process in the first place.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的不同之处在于你可能会拥有多个地标，因为反向地理编码比标准地理编码要粗糙得多。否则，每个地标内接收到的内容都是相同的，包括邮政编码——当然，地址（或范围）也是，这是这个过程最初的目的。
- en: No longer will you have to leave users attempting to decipher strange numbers
    that are made for a computer to understand. Whether you choose JavaScript or a
    server-side web service, you can go from coordinates to text with a quick call
    to a reverse geocoder.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你再也不必让用户尝试解读为计算机理解而设计的奇怪数字了。无论你选择JavaScript还是服务器端网络服务，你都可以通过快速调用反向地理编码器从坐标转换为文本。
- en: '#15: Get Postal Code Coordinates'
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#15: 获取邮政编码坐标'
- en: Have you ever been to a website that asked you to enter your ZIP Code to find
    a store's nearest location? Probably yes, I'd guess. This section will help you
    take the first step toward creating something like that yourself. You need a way
    to turn a postal code into geographic coordinates.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经访问过要求你输入ZIP代码以查找商店最近位置的网站？可能吧，我猜。本节将帮助你迈出创建类似功能的第一步。你需要一种将邮政编码转换为地理坐标的方法。
- en: You may be thinking that a large area cannot be turned into a single geographic
    point. You're right, though the same could be said about any address where the
    geocode result tends to be a point near the street. What about your backyard?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为大面积不能转换成一个地理点。你是对的，尽管对于任何地理编码结果倾向于街道附近点的地址来说，也可以这么说。那么你的后院呢？
- en: Remember, geocoding is not a precise science. For an address, a point is chosen
    that makes sense. For a postal code, the most logical point is somewhere near
    the center. Even the center is difficult to determine for the amorphous boundaries
    of some places, however. Hence, the latitude and longitude represent a spot *near*
    the center.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，地理编码不是一门精确的科学。对于一个地址，选择一个有意义的点。对于邮政编码，最合理的点通常位于中心附近。然而，对于一些边界模糊的地方，确定中心点仍然很困难。因此，纬度和经度代表的是中心附近的一个点。
- en: 'The easiest method for getting coordinates of a postal code is to search using
    a geocoding service. For example, if you wanted to look up the most famous ZIP
    Code in Beverly Hills using a Yahoo! geocoder, you''d use this URL:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 获取邮政编码坐标的最简单方法是通过地理编码服务进行搜索。例如，如果你想使用Yahoo!地理编码器查找比弗利山最著名的ZIP代码，你会使用这个URL：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And your results would look something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你的结果可能看起来像这样：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the precision is ZIP-level and the address tag is empty. Otherwise,
    the results are similar to what gets returned when you search for a complete address.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，精度是ZIP级别的，地址标签为空。否则，结果与搜索完整地址时返回的结果相似。
- en: Install a Postal Code Database
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装邮政编码数据库
- en: If you need to perform a lot of lookups, or want faster access to the results,
    having a database table to geocode postal codes without the use of another service
    makes sense. The United States has fewer than 50,000 ZIP Codes, a reasonably small
    number of records to store and access. Other countries have more unique postal
    codes (Canada, for example, has nearly a million, which is still small enough
    to be worth it).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要执行大量的查找，或者想要更快地访问结果，拥有一个无需使用其他服务的数据库表来地理编码邮政编码是有意义的。美国有不到50,000个ZIP代码，这是一个相当小的记录数量，便于存储和访问。其他国家有更多独特的邮政编码（例如，加拿大有近一百万，这仍然足够小，值得这样做）。
- en: You will need a database to keep your postal codes and their corresponding coordinates.
    In [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE"), I describe how to install
    MySQL and import data from a CSV file. The book's website contains links where
    you can download postal code databases for free. See [http://mapscripting.com/postal-code-database](http://mapscripting.com/postal-code-database).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个数据库来存储你的邮政编码及其对应的坐标。在[第9章](ch09.html "第9章。服务器端")中，我描述了如何安装MySQL并从CSV文件导入数据。本书的网站包含可以免费下载邮政编码数据库的链接。请参阅[http://mapscripting.com/postal-code-database](http://mapscripting.com/postal-code-database)。
- en: 'The fields contained in the databases will vary, but here''s an example structure
    of a US ZIP Code database:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中包含的字段可能会有所不同，但这里是一个美国ZIP代码数据库的示例结构：
- en: '| **ZIP Code** The postal code |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **ZIP代码** 邮政编码 |'
- en: '| **name** A textual description of this ZIP Code, such as neighborhood or
    city name |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **名称** 该ZIP代码的文本描述，例如街区或城市名称 |'
- en: '| **latitude** The north/south portion of the coordinates |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **纬度** 坐标的南/北部分 |'
- en: '| **longitude** The east/west portion of the coordinates |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| **经度** 坐标的东/西部分 |'
- en: A very basic database may not even contain a name field, as the most important
    part of a postal code database is converting from the code to a point.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常基础的数据库甚至可能不包含名称字段，因为邮政代码数据库最重要的部分是将代码转换为点。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll want to pay attention to whether the ZIP Code field is stored as text
    or a number. Some prefer text because text can better represent ZIP Codes that
    begin with a zero. Databases are able to search for numbers more efficiently,
    however, so you'll need to make sure to strip off any zeros at the beginning of
    user input.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意ZIP代码字段是存储为文本还是数字。有些人更喜欢文本，因为文本可以更好地表示以零开头的ZIP代码。然而，数据库能够更有效地搜索数字，所以你需要确保从用户输入中去除任何开头的零。
- en: 'With a full database of postal codes loaded into the `zipcoord` table (a name
    I made up), the SQL to find the coordinates for Beverly Hills, 90210, would look
    something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将完整的邮政编码数据库加载到`zipcoord`表（这是我取的名字）中时，查找比弗利山90210的坐标的SQL语句可能看起来像这样：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should only get one set of coordinates from that database call because
    only one 90210 postal code exists. To learn more about accessing the SQL results
    with PHP, see [#65: Use MySQL from PHP](ch09s07.html "#65: Use MySQL from PHP")
    in [#65: Use MySQL from PHP](ch09s07.html "#65: Use MySQL from PHP").'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '你应该只从数据库调用中获取一组坐标，因为只有一个90210的邮政编码。要了解更多关于使用PHP访问SQL结果的信息，请参阅[第65节：从PHP中使用MySQL](ch09s07.html
    "#65: Use MySQL from PHP")。'
- en: 'Now that you can get postal code coordinates, you''re ready to do something
    with them. At the beginning of this project, I mentioned websites that have a
    search box to find locations near your ZIP Code. Combine your postal code result
    with [#46: Get Nearest Locations from Your Own Database](ch06s11.html "#46: Get
    Nearest Locations from Your Own Database") in [#46: Get Nearest Locations from
    Your Own Database](ch06s11.html "#46: Get Nearest Locations from Your Own Database"),
    and you''ll have built a store locator, just like you''ve seen on those sites.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经可以获取邮政编码坐标了，你可以开始使用它们了。在这个项目的开始阶段，我提到了那些有搜索框以查找你ZIP代码附近位置的网站。将你的邮政编码结果与[第46节：从你的数据库中获取最近的位置](ch06s11.html
    "#46: Get Nearest Locations from Your Own Database")结合，你将构建了一个商店定位器，就像你在那些网站上看到的那样。'
