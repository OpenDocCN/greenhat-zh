- en: Part IV. Lisp is Science
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：Lisp 是科学
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781390.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781390.png.jpg)'
- en: Chapter 14. Ramping Lisp Up a Notch with Functional Programming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章：使用函数式编程提升 Lisp 的水平
- en: As you’ve seen in the preceding chapters, Lisp makes it pretty easy to throw
    together some quick code and build some simple games in no time. However, Lisp’s
    main claim to fame is as an academic tool, appropriate for tackling the most complicated
    scientific problems. The fact that it’s also great for hacking is arguably just
    a side benefit.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中看到的，Lisp 使得快速编写代码和构建简单的游戏变得非常容易。然而，Lisp 的主要声誉在于作为一种学术工具，适合解决最复杂的科学问题。它也适合黑客攻击，这可以说是附带的好处。
- en: In the rest of this book, we’re going to focus on the scientific side of the
    language, exploring some advanced techniques to build a more sophisticated game
    that I hope will really blow your mind. It will do things you may never have thought
    would be possible in a computer program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将专注于语言的科学方面，探索一些高级技术来构建一个更复杂的游戏，我希望这真的会让你大开眼界。它将做些你可能从未想过在计算机程序中做到的事情。
- en: In this chapter, you’re going to learn about the first advanced Lisp concept,
    called the *functional programming technique*. In the next chapter, we’ll use
    this technique to build a simple dice wars game, as well as a crude artificially
    intelligent opponent to play against!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习第一个高级 Lisp 概念，称为 *函数式编程技术*。在下一章中，我们将使用这项技术来构建一个简单的掷骰子战争游戏，以及一个粗略的人工智能对手来与之对战！
- en: What Is Functional Programming?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: We’ve already discussed the concept of functional programming a bit in earlier
    chapters. The glib answer is that functional programming is “a style of programming
    where we write all of our code using functions.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面章节中讨论了函数式编程的概念。简单地说，函数式编程是“一种编程风格，我们使用函数编写所有的代码。”
- en: However, we mean something very specific when using the term *function* in this
    context—exactly the same thing that mathematicians mean when they use the word
    *function*. So, what do mathematicians mean when they use this word?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们在这个上下文中使用术语 *函数* 时，我们指的是非常具体的东西——与数学家使用这个词时所指的完全相同。那么，当数学家使用这个词时，他们是什么意思呢？
- en: 'You probably already know the answer. Try to remember way, way back when you
    took pre-algebra. If you didn’t fall asleep during that particular lesson, you
    might remember your teacher drawing something like this on the chalkboard:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道了答案。试着回忆一下你上代数前的时候。如果你在那个特别的课程中没有睡着，你可能会记得你的老师在大黑板上画了类似这样的东西：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782772.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782772.png.jpg)'
- en: This picture shows that a function has arguments that may go into it, called
    the *domain* of the function. The function then takes these arguments and returns
    a value. This value is said to fall within the *range* of the function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片显示了一个函数有可以输入的参数，称为函数的 *定义域*。然后函数将这些参数取走并返回一个值。这个值被称为位于函数的 *值域* 内。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some advanced Lispers will cringe when someone says that a function “returns
    a value.” This is because Lisp derives from a something called the *lambda calculus*,
    which is a fundamental programming-like algebra developed back in the 1930s by
    Alonzo Church. In the lambda calculus, you “run” a program by performing substitution
    rules on the starting program to determine the result of a function. Hence, the
    result of a set of functions just sort of magically appears by performing substitutions;
    never does a function consciously “decide” to return a value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级 Lisp 程序员可能会对有人说函数“返回值”感到不适。这是因为 Lisp 源自一种称为 *λ-演算* 的东西，这是一种在 1930 年代由 Alonzo
    Church 开发的基本的编程类似代数。在 λ-演算中，你通过在起始程序上执行替换规则来“运行”一个程序，以确定函数的结果。因此，一组函数的结果通过执行替换规则神奇地出现；函数永远不会“有意识地”决定返回一个值。
- en: Because of this, Lisp purists prefer to say that a function “evaluates to a
    result.” However, almost everyone else in the programming world likes to say that
    functions return a value. It’s up to you to decide which way of thinking about
    functions feels the most natural.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Lisp 纯粹主义者更喜欢说一个函数“评估为结果”。然而，在编程世界的几乎每个人喜欢说函数返回一个值。这取决于你决定哪种关于函数的思考方式感觉最自然。
- en: 'Here are some important properties of mathematical functions that we’ll want
    our Lisp functions to obey as well:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些数学函数的重要属性，我们希望我们的Lisp函数也遵守：
- en: The function always returns the same result, as long as the same arguments are
    passed into it. (This is often referred to as *referential transparency*.)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要传入相同的参数，函数总是返回相同的结果。（这通常被称为*引用透明性*。）
- en: The function never references variables that are defined outside the function,
    unless we are certain that these variables will remain constant.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数永远不会引用函数外部定义的变量，除非我们确定这些变量将保持不变。
- en: No variables are modified (or *mutated*, as functional programmers like to say)
    by the function.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不会修改（或如函数式程序员喜欢说的*变异*）任何变量。
- en: The purpose of the function is to do nothing other than to return a result.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的目的是除了返回结果之外不做任何事情。
- en: The function doesn’t do anything that is visible to the outside world, such
    as pop up a dialog box on the screen or make your computer go “Bing!”
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不会做任何外界可见的事情，例如在屏幕上弹出对话框或让计算机发出“Bing！”的声音。
- en: The function doesn’t take information from an outside source, such as the keyboard
    or the hard drive.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不会从外部来源获取信息，例如键盘或硬盘。
- en: If we obey these rules whenever possible, we can say that our code is written
    in the *functional style*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尽可能遵守这些规则，我们可以说我们的代码是以*函数式风格*编写的。
- en: 'A great example of a true mathematical function is the sine function. Similarly,
    the `sin` function in Lisp (which calculates the mathematical sine) is a great
    example of a Lisp function that obeys the rules of the functional style:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的数学函数的一个很好的例子是正弦函数。同样，Lisp中的`sin`函数（计算数学正弦）是Lisp函数遵守函数式风格的绝佳例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `sin` function always returns the same result, as long as you always pass
    the same argument (in this case, `0.5`) into it. It doesn’t do anything to interact
    with the outside world. Its entire purpose in life is to return the sine as a
    value. It obeys all the rules in the preceding list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`sin`函数只要传入相同的参数（在这种情况下，`0.5`）就会始终返回相同的结果。它不会做任何与外界交互的事情。它存在的全部目的就是返回正弦值。它遵守前面列出的所有规则。'
- en: Clearly, it would be impossible to write *all* the code in a computer program
    in the functional style. For instance, one of the rules stipulates that the computer
    isn’t allowed to go “Bing!”—who would want to use a computer if it didn’t go “Bing!”
    once in a while?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在计算机程序中用函数式风格编写*所有*代码是不可能的。例如，其中一条规则规定计算机不允许发出“Bing！”的声音——如果计算机偶尔不发出“Bing！”的声音，谁会想使用它呢？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781022.png.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781022.png.jpg)'
- en: Whenever a piece of code does something that is visible to the outside world,
    such as go “Bing!” or display a dialog box on the screen, we say that the code
    *causes a side effect*. Functional programmers think of such side effects as making
    your code “dirty.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一段代码做了一些外界可见的事情，例如发出“Bing！”的声音或在屏幕上显示对话框时，我们就说这段代码*引起了副作用*。函数式程序员认为这样的副作用会使你的代码“不洁”。
- en: The technical term for such dirty code that contains side effects is *imperative
    code*. The term *imperative* implies that the code is written in a “cookbook”
    style, where you basically say things like “first do this, and then do that.”
    Like a cookbook, most lines in imperative code perform side effects, such as writing
    to the screen or modifying a global variable. Imperative code is the opposite
    of functional code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包含副作用的不洁代码的术语是*命令式代码*。术语*命令式*意味着代码是以“食谱”风格编写的，你基本上会说“首先做这个，然后做那个。”就像食谱一样，命令式代码中的大多数行都会执行副作用，例如写入屏幕或修改全局变量。命令式代码与函数式代码相反。
- en: 'This leads us to the central philosophy of functional programming. It states
    that you should break your program into two parts:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们到函数式编程的核心哲学。它指出你应该将你的程序分成两部分：
- en: The first, and biggest part, should be completely functional and free of side
    effects. This is the clean part of your program.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分，也是最大的一部分，应该是完全函数式且无副作用的。这是你程序中的干净部分。
- en: The second, smaller part of your program is the part that has all the side effects,
    interacting with the user and the rest of the outside world. This code is dirty
    and should be kept as small as possible.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的第二部分，较小的一部分，是包含所有副作用的部分，与用户和外界交互。这段代码是不洁的，应该尽可能保持最小。
- en: If a piece of code pops up a dialog box, for example, we deem it dirty and banish
    it to the imperative section of our code. Things like dialog boxes are not really
    math, and we shouldn’t let them play with our math functions and other clean,
    functional code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一段代码弹出一个对话框，例如，我们认为它是脏的，并将其放入我们代码的命令式部分。像对话框这样的东西并不真的是数学，我们不应该让它们与我们的数学函数和其他干净、功能性的代码互动。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781918.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/781918.png.jpg)'
- en: Anatomy of a Program Written in the Functional Style
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式风格编写的程序结构
- en: Now that we’ve discussed how functional programming is done, let’s write a simple
    program that follows this style. Since we want this program to be a typical example
    of most software, we should figure out what most software in the world actually
    does. So what do most programs in the world actually do? They keep track of widgets!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何进行函数式编程，让我们写一个简单的程序，遵循这种风格。由于我们希望这个程序成为大多数软件的典型例子，我们应该弄清楚世界上大多数软件实际上做什么。那么，世界上大多数程序实际上做什么呢？它们跟踪小部件！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781308.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/781308.png.jpg)'
- en: 'Here’s our entire example program, written in the functional style:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的整个示例程序，用函数式风格编写的：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As promised, it is split into two parts: the *clean part* and the *dirty part*.
    I did say that the clean part of the program should be much bigger than the dirty
    part. However, since this example is so short, the dirty part ended up a bit bigger.
    Usually, you can expect the clean part to be around 80 percent of the actual code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，它分为两部分：*干净部分*和*脏部分*。我确实说过程序的干净部分应该比脏部分大得多。然而，由于这个例子非常简短，脏部分最终变得稍微大一些。通常，你可以预期干净部分大约占实际代码的
    80%。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some programming languages are even more focused on functional programming than
    Lisp is. Haskell, for instance, has powerful features that let you write 99.9
    percent of your code in a functional style. In the end, however, your program
    will still need to have some kind of side effect; otherwise, your code couldn’t
    accomplish anything useful.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言甚至比 Lisp 更专注于函数式编程。例如，Haskell 有强大的功能，让你可以用函数式风格编写 99.9% 的代码。然而，最终，你的程序仍然需要某种形式的副作用；否则，你的代码无法完成任何有用的任务。
- en: 'So what does our example program do? Well, it basically does what most computer
    programs in the world are designed to do: It keeps track of widgets in a database!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的示例程序做什么呢？嗯，它基本上做了世界上大多数计算机程序设计要做的：它在数据库中跟踪小部件！
- en: The database in this example is very primitive. It’s just a Lisp list, stored
    in the global variable `*database*`. Since the database is going to start off
    empty, we initialize this variable and set it to be empty ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的数据库非常原始。它只是一个存储在全局变量 `*database*` 中的 Lisp 列表。由于数据库一开始是空的，我们初始化这个变量并将其设置为空
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。
- en: We can call the function `main-loop` to start tracking some widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
    This function just starts an infinite loop, asking the user for a widget name
    ![](httpatomoreillycomsourcenostarchimages783510.png). Then, after it reads in
    the widget, it calls the `add-widget` function to add the new widget to the database
    ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用函数 `main-loop` 来开始跟踪一些小部件 ![http://atomoreilly.com/source/nostarch/images/783554.png]。这个函数只是启动一个无限循环，询问用户小部件的名称
    ![http://atomoreilly.com/source/nostarch/images/783510.png]。然后，在读取小部件信息后，它调用 `add-widget`
    函数将新小部件添加到数据库中 ![http://atomoreilly.com/source/nostarch/images/783544.png]。
- en: However, the `add-widget` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    is in the clean part of the code. That means it’s functional and isn’t allowed
    to modify the `*database*` variable directly. Like all functional code, the `add-widget`
    function is allowed to do nothing more than return a new value. This means that
    the only way it can “add” a widget to a database is to return a brand-new database!
    It does this by simply taking the database passed to it and then consing the widget
    to the database to create a new database ![](httpatomoreillycomsourcenostarchimages783562.png).
    The new database is identical to the previous one, except that it now contains
    a new widget at the front of the list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`add-widget` 函数 ![image](httpatomoreillycomsourcenostarchimages783564.png)
    位于代码的干净部分。这意味着它是功能性的，不允许直接修改 `*database*` 变量。像所有功能性代码一样，`add-widget` 函数只能返回一个新值，不能做更多的事情。这意味着它唯一能够“添加”小部件到数据库的方式是返回一个全新的数据库！它是通过简单地接受传递给它的数据库，然后将小部件连接到数据库来创建一个新的数据库
    ![image](httpatomoreillycomsourcenostarchimages783562.png)。新的数据库与之前的数据库完全相同，只是现在列表的最前面增加了一个新的小部件。
- en: 'Think of how crazy this sounds on the face of it. Imagine that we’re running
    an Oracle database server, containing millions of widgets:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这听起来有多疯狂。想象一下，我们正在运行一个包含数百万个小部件的Oracle数据库服务器：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782052.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782052.png.jpg)'
- en: 'Then, when we add a new widget, the database server accomplishes this by creating
    a brand-new replica of the previous database, which differs only in that a single
    new item has been added:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们添加一个新的小部件时，数据库服务器通过创建一个全新的数据库副本来完成这个任务，这个副本与之前的数据库唯一的不同之处在于增加了一个新的项目：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781440.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781440.png)'
- en: This would be horribly inefficient. However, in our widgets example, things
    are not as bad as they may first appear. It is true that the `add-widgets` function
    creates a new list of widgets every time it is called, and that repeated calls
    to this function would make the list longer and longer. However, since every new
    widget is simply added to the front of the list, it turns out that the tail end
    of the widget list is identical to the previous version of the list. Hence, the
    `add-widget` function can “cheat” whenever it creates a new list, by simply consing
    a single new widget to the front of the list, and then repurposing the old list
    as a tail to hold the rest of the items ![](httpatomoreillycomsourcenostarchimages783562.png).
    This allows the new list to be created in a way that is fast and also requires
    very little new memory to be allocated. In fact, the only new memory allocated
    by `add-widget` is a single new cons cell to link the new widget to the previous
    list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将非常低效。然而，在我们的小部件示例中，事情并没有看起来那么糟糕。确实，每次调用 `add-widgets` 函数时，都会创建一个新的小部件列表，并且重复调用此函数会使列表越来越长。然而，由于每个新的小部件只是简单地添加到列表的前面，结果发现小部件列表的尾部与列表的上一版本完全相同。因此，`add-widget`
    函数在创建新列表时可以通过简单地连接一个新小部件到列表的前面，并将旧列表作为尾部来保存其余项目来“欺骗” ![image](httpatomoreillycomsourcenostarchimages783562.png)。这允许以快速的方式创建新列表，并且只需要分配非常少的内存。实际上，`add-widget`
    分配的唯一新内存是一个新的连接单元，用于将新小部件连接到之前的列表。
- en: This type of cheating when creating new data structures is a key technique that
    makes efficient functional programming possible. Furthermore, sharing of structures
    can be done safely, since one of the tenets of functional programming is to never
    modify old pieces of data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新数据结构时这种欺骗行为是使高效功能性编程成为可能的关键技术。此外，由于功能性编程的一个基本原则是永远不要修改旧数据，因此结构共享可以安全地进行。
- en: 'So our `add-widget` function creates a new database for us with the additional
    item added to it. The `main-loop` function, in the dirty part of the code, sets
    the global `*database*` variable equal to this new database. In this way, we have
    indirectly modified the database in two steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `add-widget` 函数为我们创建了一个包含额外项目的数据库。在代码的脏部分，`main-loop` 函数将全局的 `*database*`
    变量设置为这个新数据库。这样，我们就间接地在两步中修改了数据库。
- en: The `add-widget` function, which is basically the brains of this program, generated
    an updated database for us.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`add-widget` 函数，这个程序的大脑，为我们生成了一个更新的数据库。'
- en: The `main-loop` function, which was in charge of the dirty work, modified the
    global `*database*` variable to complete the operation.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负责脏活累活的 `main-loop` 函数修改了全局的 `*database*` 变量以完成操作。
- en: 'This example program illustrates the basic layout of a Lisp program written
    in the functional style. Let’s try out our new program to see it in action:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序展示了用函数式风格编写的Lisp程序的基本布局。让我们尝试运行我们的新程序，看看它是如何工作的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Remember that you can hit ctrl-C to exit the infinite loop in this example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以按ctrl-C来退出这个例子中的无限循环。
- en: Higher-Order Programming
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶编程
- en: One common stumbling block for programmers learning to write programs in the
    functional style is that they find it hard to combine different chunks of code
    to perform a single action. This is called *code composition*. A programming language
    should make code composition easy. In other words, it should make it easy for
    you to take different pieces of code and use them together to solve a task. The
    most powerful tool for code composition when writing functional code is *higher-order
    programming*, which lets you use functions that accept other functions as parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于学习用函数式风格编写程序的程序员来说，一个常见的难题是他们发现很难将不同的代码块组合起来执行单个操作。这被称为*代码组合*。编程语言应该使代码组合变得容易。换句话说，它应该使你能够将不同的代码片段组合起来，共同解决问题。在编写函数式代码时，*高阶编程*是代码组合的最强大工具，它允许你使用接受其他函数作为参数的函数。
- en: 'Let’s look at an example to understand why code composition can be a challenge
    to a beginning functional programmer. Suppose we want to add two to every number
    in the following list:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解为什么代码组合可能对初学的函数式程序员来说是一个挑战。假设我们想要将以下列表中的每个数字加二：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To do this, we will need to write code to traverse the list, as well as write
    code to add two to a number. These are the two tasks we need to compose.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要编写代码来遍历列表，以及编写代码来将一个数字加二。这是我们需要的两个组合任务。
- en: Code Composition with Imperative Code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令式代码进行代码组合
- en: 'One possible naïve (and imperative) way to perform this task is to use a `loop`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个任务的一个可能的天真（且命令式）的方法是使用一个`loop`：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we’re creating a variable `n` that counts through all the items in the
    list in a `loop` ![](httpatomoreillycomsourcenostarchimages783564.png). We then
    use `setf` to add two to the number at the location `n` in the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is similar to the sort of code you might write if you were a C programmer.
    Although it’s pretty ugly, there are positive things that can be said about it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个变量`n`，它通过`loop`遍历列表中的所有项 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。然后我们使用`setf`将列表中位置`n`的数字加二
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)。这类似于如果你是C程序员可能会编写的代码。尽管它看起来很丑陋，但关于它也有一些积极的东西可以说：
- en: Code structured like this is potentially very efficient. It’s space-efficient,
    since we don’t need to allocate any memory for storing a new list (we’re just
    munging the old list to increase all the numbers in it by two). And it could also
    be very time-efficient, if we rewrote this loop to work on an array instead of
    a list. (Remember that finding the *n*th item in a list is slow.)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种结构的代码可能非常高效。它节省空间，因为我们不需要为存储新列表分配任何内存（我们只是在修改旧列表，使其中的所有数字都加二）。而且它也可能非常节省时间，如果我们把这个循环改写为在数组上工作而不是在列表上。记住，在列表中找到第*n*项是慢的。
- en: 'Code written like this clearly composes the task of looping ![](httpatomoreillycomsourcenostarchimages783564.png)
    and the task of adding two to a number ![](httpatomoreillycomsourcenostarchimages783562.png).
    By putting our code for the addition inside the loop, we are composing these two
    activities to complete a more complicated goal: adding two to an entire list of
    numbers.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样编写的代码明显组合了循环 ![图片](httpatomoreillycomsourcenostarchimages783564.png) 和将一个数字加二
    ![图片](httpatomoreillycomsourcenostarchimages783562.png) 的任务。通过将我们的加法代码放在循环内部，我们将这两个活动组合起来，以完成一个更复杂的任务：将整个数字列表中的数字加二。
- en: 'However, there are obvious downsides to the imperative approach:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，命令式方法存在明显的缺点：
- en: It destroys the original list. This is a problem if we use the `*my-list*` variable
    later, and miss the fact that this code has messed up the original values in this
    list. A Lisper would say that allowing the `*my-list*` variable to be modified
    willy-nilly makes this variable a piece of *hidden state* in the program. Bugs
    related to hidden state are common in programming languages that encourage imperative-style
    programming.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会破坏原始列表。如果我们稍后使用`*my-list*`变量，并且没有意识到这段代码已经破坏了列表中的原始值，这就会成为一个问题。Lisper会说，允许`*my-list*`变量随意修改，使得这个变量成为程序中的*隐藏状态*。与隐藏状态相关的错误在鼓励命令式编程风格的编程语言中很常见。
- en: We needed to create a variable `n` ![](httpatomoreillycomsourcenostarchimages783564.png)
    to keep track of our position in the list. This makes the code more bulky and
    also adds more places where bugs could lurk. There’s always a risk that we give
    `n` a wrong value or use it incorrectly to access items from the list.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建一个变量 `n` ![http://atomoreilly.com/source/nostarch/images/783564.png] 来跟踪我们在列表中的位置。这使得代码更加臃肿，也增加了更多可能出现错误的地方。我们总是有风险给
    `n` 赋予错误的值或错误地使用它来访问列表中的项。
- en: Using the Functional Style
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数式风格
- en: 'Now let’s see what happens if we rewrite this code in a functional style. Let’s
    first write it as a beginning functional programmer might, without using higher-order
    programming:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如果我们以函数式风格重写这段代码会发生什么。让我们首先像初学者一样写它，不使用高阶编程：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we’re creating a function `add-two` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds two to the number at the front of the list and then calls itself recursively
    to build the tail of the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为 `add-two` 的函数 ![http://atomoreilly.com/source/nostarch/images/783564.png]，它将2加到列表前面的数字上，然后递归地调用自身来构建列表的尾部。
- en: 'This code avoids many of the downsides from the imperative solution. It does
    not destroy the original list, and it does not require us to use a numeric index.
    Unfortunately, it also lacks one of the critical benefits of the imperative version:
    There is no longer a clear delineation between the code that adds two to items
    in the list and the code that traverses the list. These two activities are now
    deeply intertwined, which is the reason we needed to create a special function,
    `add-two`, to make this solution work. We have lost our ability to compose these
    two tasks in a clean way.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码避免了命令式解决方案的许多缺点。它不会破坏原始列表，也不需要我们使用数字索引。不幸的是，它也失去了命令式版本的一个关键好处：不再有明确的界限来区分添加2到列表项的代码和遍历列表的代码。这两个活动现在深深地交织在一起，这也是我们需要创建一个特殊的函数
    `add-two` 来使这个解决方案工作的原因。我们失去了以干净的方式组合这两个任务的能力。
- en: Higher-Order Programming to the Rescue
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶编程来拯救
- en: 'If we want to write code for this task in a functional style, but still allow
    our code to be composable, we’ll need to make use of higher-order functions. Here
    is how an experienced Lisper would add two to every number in a list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以函数式风格编写这个任务的代码，但仍然允许我们的代码可组合，我们需要使用高阶函数。以下是一个经验丰富的Lisper如何将2加到列表中每个数字上的方法：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we finally have a version of the code that is functional *and* allows us
    to compose the traversal code and the addition code. Here, the traversal is performed
    by the `mapcar` function, which is a higher-order function since it applies a
    supplied function to every member in a list. The addition is performed by a lambda
    function, which is responsible only for adding two to a number, and is oblivious
    to the fact that the numbers are in a list. This example shows that higher-order
    programming can let us write clearly delineated chunks of code and then compose
    them, without needing to break from the functional style.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于有一个版本的代码是函数式的，并且允许我们组合遍历代码和添加代码。在这里，遍历是通过 `mapcar` 函数完成的，它是一个高阶函数，因为它将提供的函数应用于列表中的每个成员。添加是通过一个lambda函数完成的，它只负责将2加到数字上，并且对数字在列表中的事实视而不见。这个例子表明，高阶编程可以让我们编写清晰界定的代码块，然后组合它们，而无需打破函数式风格。
- en: Why Functional Programming Is Crazy
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么函数式编程很疯狂
- en: 'We already know one reason why functional programming is crazy: Functional
    programs can’t really do anything, since they can’t have *side effects*. As Simon
    Peyton Jones, a well-known functional programmer, likes to say, “All you can do
    without side effects is push a button and watch the box get hot for a while.”
    (Which isn’t technically true, since even the box getting hot is a side effect.)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道为什么函数式编程很疯狂的一个原因：函数式程序实际上不能做任何事情，因为它们不能有 *副作用*。正如著名的函数式程序员Simon Peyton
    Jones喜欢说的，“没有副作用你能做的只是按下一个按钮，然后看着盒子热一段时间。”（这从技术上讲是不正确的，因为盒子变热本身就是一个副作用。）
- en: 'We’ve seen that we can work around this limitation of functional programming
    by adding a dirty section to our programs, which is kept separate from the rest
    of the code and contains all our code that is imperative and not in the functional
    style. However, recall the problem with the functional style: It can cause code
    to be extremely inefficient.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过在我们的程序中添加一个“脏”部分来绕过函数式编程的限制，这部分代码与代码的其他部分保持分离，并包含所有我们的命令式代码，这些代码不是函数式风格的。然而，回想一下函数式风格的问题：它可能导致代码效率极低。
- en: Performance has always been a huge concern with functional programs. Having
    to write code that isn’t allowed to mutate the value of existing variables, but
    only create new variables, can lead to a huge amount of memory copying and memory
    allocation, which can slow programs down to a crawl. One way to mitigate this
    copying and allocation is by using shared structures between different pieces
    of data in our programs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 性能一直是函数式程序的一个巨大关注点。必须编写不允许修改现有变量值，而只能创建新变量的代码，这可能导致大量的内存复制和内存分配，这可能会使程序速度慢到几乎停止。减轻这种复制和分配的一种方法是在我们程序的不同数据部分之间使用共享结构。
- en: Nonetheless, code written in the functional style has other properties that
    affect performance. For instance, functional code uses a lot of recursion, instead
    of looping. Using recursion causes the Lisp compiler/interpreter to put a lot
    of items on the program stack, which can be very slow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，以函数式风格编写的代码具有影响性能的其他属性。例如，函数式代码大量使用递归，而不是循环。使用递归会导致Lisp编译器/解释器在程序栈上放置大量项目，这可能会非常慢。
- en: Fortunately, functional programmers have developed optimization techniques that
    can solve the vast majority of performance problems. These include memoization,
    tail call optimization, lazy evaluation, and higher-order programming, which we’ll
    cover in the next few chapters. Using these techniques and others, an experienced
    functional programmer can write code that is usually comparable in performance
    to code written in any other style.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，函数式程序员已经开发出可以解决绝大多数性能问题的优化技术。这些包括记忆化、尾调用优化、惰性评估和高级编程，这些内容我们将在下一章中介绍。使用这些技术和其他技术，经验丰富的函数式程序员可以编写通常与其他风格编写的代码具有可比性能的代码。
- en: However, some types of programs just can’t be written in a purely functional
    way. For instance, you probably wouldn’t write something like a full-on Oracle-style
    relational database system in a functional style. Yet, smaller, memory-resident
    database systems may be able to use purely functional techniques (an example is
    the HAppS-IxSet available to Haskell programmers at [http://happs.org/](http://happs.org/)).
    So there is really no hard limit as to when functional programming can be used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些类型的程序根本不能以纯函数式的方式编写。例如，你可能不会用函数式风格来编写一个全功能的Oracle式关系数据库系统。然而，较小的、内存驻留的数据库系统可能能够使用纯函数式技术（例如，Haskell程序员可以在[http://happs.org/](http://happs.org/)上获得的HAppS-IxSet）。因此，实际上并没有一个严格的界限来决定何时可以使用函数式编程。
- en: Why Functional Programming Is Fantastic
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么函数式编程很棒
- en: Now that I’ve told you about all the headaches a functional programmer must
    endure, you may be wondering, “Why would anyone bother to program this way?” The
    answer is that functional programming has many enticing benefits that make up
    for these headaches.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经告诉你函数式程序员必须忍受的所有头痛问题，你可能想知道，“为什么有人会费心以这种方式编程？”答案是，函数式编程有许多吸引人的好处，这些好处可以弥补这些头痛。
- en: Functional Programming Reduces Bugs
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程减少错误
- en: 'Bugs in computer programs usually happen because, under certain circumstances,
    the code behaves in ways the programmer didn’t expect when the code was written.
    In functional programming, the behavior of your functions depends on one and only
    one thing: the arguments explicitly passed into the function. This makes it much
    easier for a programmer to appreciate all the circumstances a program could possibly
    encounter, including circumstances that could lead to errors.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序中的错误通常发生是因为，在特定情况下，代码的行为与程序员在编写代码时预期的行为不符。在函数式编程中，函数的行为取决于一个且仅有一个因素：传递给函数的显式参数。这使得程序员更容易理解程序可能遇到的所有情况，包括可能导致错误的情况。
- en: Writing functions that depend on only their arguments for their behavior also
    makes bugs easy to duplicate. If you call a function with the same data passed
    in through its arguments, it should do the same exact thing every time. This is
    the property we called *referential transparency*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编写仅依赖于其参数行为的函数也使得错误易于复制。如果你用通过其参数传入的相同数据调用一个函数，它应该每次都做完全相同的事情。这就是我们所说的*引用透明性*。
- en: Functional Programs Are More Compact
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性程序更加紧凑
- en: It turns out a lot of the work in run-of-the-mill computer programs involves
    creating, initializing, and updating variables. Functional programs don’t do any
    of this. As we discussed earlier, functional programs make use of higher-order
    functions, which don’t require us to create tons of temporary variables in our
    code, and that makes our code more compact.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，许多常规计算机程序的工作涉及创建、初始化和更新变量。功能性程序不做任何这些。正如我们之前讨论的，功能性程序利用了高阶函数，这不需要我们在代码中创建大量的临时变量，这使得我们的代码更加紧凑。
- en: Functional Code Is More Elegant
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性代码更加优雅
- en: The biggest advantage of functional programming is that it brings all of computer
    programming back to the domain of mathematics. It wouldn’t make sense for a math
    equation to pop up a dialog box or write to the hard drive. It can be argued that
    if we get our computer code back to this same level of purity, it will be far
    more elegant. Additionally, if our code is closer to the world of mathematics,
    we may be able to use tools in mathematics to write better computer code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性编程的最大优势是它将所有计算机编程带回到了数学领域。数学方程式弹出对话框或写入硬盘是没有意义的。可以认为，如果我们让我们的计算机代码回到这种相同的纯净水平，它将更加优雅。此外，如果我们的代码更接近数学世界，我们可能能够使用数学工具来编写更好的计算机代码。
- en: In fact, a lot of research continues to be done in using mathematical proofs
    to check for the correctness of functional computer programs. Although this research
    still isn’t to the point where a practical programmer would use such techniques,
    they may be more common in the future. And, almost certainly, a functional programming
    style will be essential in making correctness proofs on your code possible.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，许多研究仍在继续进行，使用数学证明来检查功能性计算机程序的正确性。尽管这项研究还没有达到实用程序员会使用这些技术的程度，但它们在未来可能会更加普遍。而且，几乎可以肯定，功能性编程风格将对于在代码上进行正确性证明变得至关重要。
- en: What You've Learned
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we discussed functional programming. Along the way, you learned
    the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了功能性编程。在这个过程中，你学习了以下内容：
- en: Programs written in the *functional style* always give the same result when
    they are given the same values in their arguments.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以功能性风格编写的程序在给定的参数值相同时总是给出相同的结果。
- en: Functional programs do not contain *side effects*. Their whole purpose in life
    is to just calculate a value to return.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性程序不包含*副作用*。它们存在的全部目的就是计算一个值并返回。
- en: Programs that are not functional usually read like a cookbook, with statements
    like, “First do this, and then do that.” This style of programming is called *imperative
    programming*.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能性程序通常读起来像菜谱，包含诸如“首先做这个，然后做那个”之类的语句。这种编程风格被称为*命令式编程*。
- en: A good strategy for writing Lisp programs is to break them into a clean, functional
    part and a dirty, imperative part.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Lisp程序的一个好策略是将它们分解成一个干净的功能性部分和一个脏的命令式部分。
- en: Functional programs can be written quickly, are more compact, and tend to have
    fewer bugs, particularly in the hands of an experienced functional programmer.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性程序可以快速编写，更加紧凑，并且往往具有更少的错误，尤其是在经验丰富的功能性程序员手中。
- en: Chapter 15. Dice of Doom, a Game Written in the Functional Style
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。使用功能性风格编写的“末日骰子”游戏
- en: Now we’re finally ready to create a more sophisticated (and fun) computer program
    in the functional style. As we expand this program throughout the rest of this
    book, you’ll learn about techniques for writing elegant functional code, while
    at the same time maintaining strong performance in your programs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好在功能性风格中创建一个更复杂（并且有趣）的计算机程序了。随着我们在本书的其余部分扩展这个程序，你将了解编写优雅功能性代码的技术，同时保持程序中的强大性能。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782714.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782714.png.jpg)'
- en: The Rules of Dice of Doom
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “末日骰子”的规则
- en: Dice of Doom is a game in the same family as Risk, Dice Wars ([http://www.gamedesign.jp/flash/dice/dice.html](http://www.gamedesign.jp/flash/dice/dice.html)),
    and KDice ([http://kdice.com/](http://kdice.com/)). In the beginning, we’re going
    to keep the rules of Dice of Doom mind-numbingly simple. In later chapters, we’ll
    expand the rules, until eventually we’ll have a game very similar to Dice Wars.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “末日骰子”是一款与“风险”、“骰子战争”（[http://www.gamedesign.jp/flash/dice/dice.html](http://www.gamedesign.jp/flash/dice/dice.html)）和“KDice”（[http://kdice.com/](http://kdice.com/)）同属一类的游戏。一开始，我们将保持“末日骰子”的规则极其简单。在后面的章节中，我们将扩展规则，直到最终我们会有一个与“骰子战争”非常相似的游戏。
- en: 'Here are the simplified rules we’ll start with:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将开始使用的简化规则：
- en: Two players (named A and B) occupy spaces on a hexagonal grid. Each hexagon
    in the grid will have some six-sided dice on it, owned by the occupant.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个玩家（命名为A和B）在一个六边形网格上占据空间。网格中的每个六边形上都会有一些六面骰子，属于占领者。
- en: During a turn, a player can perform any number of moves, but must perform at
    least one move. If the player cannot move, the game ends.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个回合中，玩家可以进行任意数量的移动，但必须至少进行一次移动。如果玩家无法移动，游戏结束。
- en: A move consists of attacking a neighboring hexagon owned by the opponent. The
    player must have more dice in her hexagon than the neighboring hexagon in order
    to attack. For now, all attacks will automatically lead to a win. In future variants,
    we’ll actually roll the dice for a battle. But for now, the player with more dice
    just wins automatically.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动包括攻击对手拥有的相邻六边形。玩家必须在她自己的六边形中拥有比相邻六边形更多的骰子才能进行攻击。目前，所有攻击都将自动导致胜利。在未来变体中，我们将实际掷骰子进行战斗。但到目前为止，拥有更多骰子的玩家将自动获胜。
- en: After winning a battle, the losing player’s dice are removed from the board,
    and all but one of the winning player’s dice are moved onto the newly won hexagon.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赢得一场战斗后，输掉战斗的玩家的骰子将从棋盘上移除，并且除了一个之外的所有赢家的骰子都将移动到新占领的六边形上。
- en: After a player is finished making her moves, reinforcements are added to that
    player’s dice armies. Reinforcements to the player’s occupied hexagons are added
    one die at a time, starting from the upper-left corner, moving across and down.
    The maximum number of dice added as reinforcements is one less than the player
    took from the opponent in her completed turn.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩家完成她的移动后，将增援部队添加到该玩家的骰子军队中。增援到玩家占领的六边形的增援是逐个骰子添加的，从左上角开始，横向和纵向移动。作为增援添加的骰子最大数量比玩家在其完成的回合中从对手那里拿走的骰子少一个。
- en: When a player can no longer take her turn, the game has ended. The player who
    occupies the most hexagons at this point is the winner. (A tie is also possible.)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一名玩家不能再进行她的回合时，游戏结束。此时占据最多六边形区域的玩家是赢家。（也可能出现平局。）
- en: A Sample Game of Dice of Doom
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “末日骰子”的一个示例游戏
- en: Since our implementation of Dice of Doom will include an AI player, we’re going
    to start with an extremely humble size for our game board. As you probably know,
    AI code can be very computationally intensive. In our early, very naive version
    of this game, any board larger than a 2-by-2 grid of hexagons would bring CLISP
    to its knees!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的“末日骰子”实现将包括一个AI玩家，我们将从极小的游戏板尺寸开始。正如你可能知道的，AI代码可能非常计算密集。在我们这个游戏的早期、非常天真的版本中，任何大于2x2六边形网格的棋盘都会让CLISP崩溃！
- en: 'Here is a complete game, played on a puny 2-by-2 board:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个在微小的2x2棋盘上进行的完整游戏示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783538.png.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783538.png.jpg)'
- en: At the beginning of the game, player A (indicated with black hexagons) possesses
    the top two hexagons, with three dice on each. Player B occupies the bottom row
    (indicated by the white hexagons), with three dice and one die, respectively.
    Player A attacks the lone die with one of his piles. After the attack, one of
    player A’s dice remains behind, while the others move to the conquered spot. Then
    player A passes the turn.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开始时，玩家A（用黑色六边形表示）拥有顶部两个六边形，每个六边形上有三个骰子。玩家B占据底部行（用白色六边形表示），分别有三个骰子和一个骰子。玩家A用他的一堆骰子中的一枚攻击孤立的骰子。攻击后，玩家A的一枚骰子留在了原地，而其他骰子移动到被征服的位置。然后玩家A结束回合。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782970.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782970.png.jpg)'
- en: Player B now attacks player A’s two dice with a pile of three. Player B then
    passes. At this point, player B receives a single reinforcement die on her left
    hexagon. This is because she killed two of player A’s dice. The reinforcements,
    as per the rules, consist of the number of dice killed, minus one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家B用三堆骰子攻击玩家A的两个骰子。然后玩家B传递。在这个时候，玩家B在她的左侧六边形上获得一个强化骰子。这是因为她杀死了玩家A的两个骰子。根据规则，强化骰子的数量是杀死的骰子数量减去一。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782752.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782752.png.jpg)'
- en: Player A now attacks with three of his dice and passes. Also, he gets a reinforcement
    die.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家A现在用他的三个骰子进行攻击并传递。此外，他还获得一个强化骰子。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782186.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782186.png.jpg)'
- en: Player B now has only one legal move, attacking two against one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家B现在只有一个合法的移动，即攻击两个对抗一个。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781602.png.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781602.png.jpg)'
- en: Player A now has the upper hand, killing all of player B’s remaining dice. As
    you can see, player A is permitted to perform multiple attacks on his turn before
    passing. The game has ended with player A as the winner.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家A处于优势，杀死了玩家B剩余的所有骰子。正如你所见，玩家A在传递之前被允许进行多次攻击。游戏以玩家A获胜结束。
- en: Implementing Dice of Doom, Version 1
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现“末日骰子”版本1
- en: Let’s start coding this game in Lisp. As we discussed in the previous chapter,
    this game will contain both clean, functional code and dirty, imperative code.
    You’ll be able to tell in which category a block of code fits by the “clean/functional”
    or “dirty/imperative” icon next to it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始用Lisp编写这个游戏。正如我们在上一章中讨论的，这个游戏将包含干净的、函数式的代码和脏的、命令式的代码。你将能够通过它旁边的“干净/函数式”或“脏/命令式”图标来判断代码块属于哪个类别。
- en: Defining Some Global Variables
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一些全局变量
- en: 'First, we’ll create some global variables that define the basic parameters
    for our game:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些全局变量来定义我们游戏的基本参数：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’re stating that there will be two players ![](httpatomoreillycomsourcenostarchimages783564.png),
    that the maximum number of dice on a square is three ![](httpatomoreillycomsourcenostarchimages783562.png),
    and that the board will be 2-by-2 ![](httpatomoreillycomsourcenostarchimages783560.png).
    In later versions of Dice of Doom, we’ll increase all of these parameters, to
    allow for a more challenging game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明将有两位玩家 ![图片](httpatomoreillycomsourcenostarchimages783564.png)，每个方格上的骰子最大数量为三个
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)，并且游戏板将是2x2 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。在Dice
    of Doom的后续版本中，我们将增加所有这些参数，以允许更具有挑战性的游戏。
- en: Since it’s useful to know the total number or hexagons there are at the current
    board size, we also define `*board-hexnum*` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Note that even though the grid is made of hexagons, it is still basically a square
    grid, since the number of hexagons just equals the square of the side of the grid.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于了解当前游戏板大小下六边形的总数是有用的，我们也定义了`*board-hexnum*` ![图片](httpatomoreillycomsourcenostarchimages783554.png)。请注意，尽管网格由六边形组成，但它基本上仍然是一个方形网格，因为六边形的数量正好等于网格边长的平方。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, every code sample has an associated icon to indicate whether
    it is made of dirty, imperative or clean, functional code. By the end of this
    chapter, you should be able to easily tell the difference and have some appreciation
    for the benefits of each style.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，每个代码示例都有一个相关的图标，表示它是脏的、命令式的还是干净的、函数式的代码。到本章结束时，你应该能够轻松地区分它们，并对每种风格的优点有所了解。
- en: Representing the Game Board
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示游戏板
- en: 'We’re going to represent the game board using a simple list. The hexagons will
    be stored in this list, starting at the top left, and then moving across and down.
    For each hexagon, we’ll store a list of two items: a number indicating the current
    occupant of the hexagon and another number indicating the number of dice at that
    location.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的列表来表示游戏板。六边形将存储在这个列表中，从左上角开始，然后横向和纵向移动。对于每个六边形，我们将存储一个包含两项的列表：一个表示当前占据六边形的数字，另一个表示该位置的骰子数量。
- en: 'For instance, here is an example of a game board and the list that encodes
    it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个游戏板及其编码列表的示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779855.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779855.png.jpg)'
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that most Lisp programmers like to count starting at zero. Therefore, players
    A and B are represented with the numbers 0 and 1\. This list indicates that player
    A has three dice on the first hexagon and three on the second. Player B has three
    dice on the third hexagon and one on the fourth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数 Lisp 程序员喜欢从零开始计数。因此，玩家 A 和 B 分别用数字 0 和 1 表示。这个列表表明玩家 A 在第一个六边形上有三个骰子，在第二个六边形上也有三个。玩家
    B 在第三个六边形上有三个骰子，在第四个六边形上有一个。
- en: When we create our AI player, it will need to be able to look at many hexagons
    on the board very quickly. Because of this, we’re going to create a second representation
    of our board in the form of an array. Remember that checking a numeric location
    (for instance, hexagon 2) in a list requires the `nth` function, which is potentially
    slow. Arrays, on the other hand, will allow for very fast lookup at a specific
    location, even with very large board sizes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的 AI 玩家时，它需要能够非常快速地查看棋盘上的许多六边形。因此，我们将以数组的形式创建我们棋盘的第二个表示。记住，在列表中检查数字位置（例如，六边形
    2）需要 `nth` 函数，这可能是缓慢的。另一方面，数组将允许在特定位置进行非常快速的查找，即使是在非常大的棋盘尺寸下。
- en: 'The `board-array` function converts a board represented with a list to an array
    for us:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`board-array` 函数将用列表表示的棋盘转换为数组：'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the game begins, we’ll start with a randomized board. Here’s the function
    that creates a random board:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，我们将从一个随机化的棋盘开始。这是创建随机棋盘的函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function is not in the functional style (as the icon indicates), since
    it will create a different, random result every time it is called. It generates
    the board as a list, but then converts the list to our speedier array format when
    it’s done, using `board-array` ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不是函数式风格（如图标所示），因为它每次调用都会产生不同的、随机的结果。它将棋盘生成为一个列表，但完成后会使用 `board-array` 将列表转换为我们的更快的数组格式
    ![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png)。
- en: It generates random values using the Lisp function `random`. This function produces
    a different random integer every time, greater than or equal to zero, but smaller
    than the number passed to it. We use our `*num-players*` and `*max-dice*` global
    variables to generate random values for each hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 Lisp 函数 `random` 生成随机值。这个函数每次都会产生一个不同的随机整数，大于或等于零，但小于传递给它的数字。我们使用我们的全局变量
    `*num-players*` 和 `*max-dice*` 为每个六边形生成随机值 ![httpatomoreillycomsourcenostarchimages783562.png](httpatomoreillycomsourcenostarchimages783562.png)。
- en: 'Let’s try out the `gen-board` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下 `gen-board` 函数：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember that the hash mark (#) indicates that we’ve created an array, not a
    list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，井号（#）表示我们创建了一个数组，而不是一个列表。
- en: 'We’ll name our players using letters (just A and B, until we start introducing
    more players). Here’s a function that converts a player number into a letter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字母来命名玩家（仅限于 A 和 B，直到我们开始介绍更多玩家）。这是一个将玩家编号转换为字母的函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `code-char` function converts an ASCII code into the appropriate character.
    Let’s call it for player 1 to see the result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`code-char` 函数将 ASCII 码转换为相应的字符。让我们为玩家 1 调用它来看看结果：'
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, let’s create a function that will take an encoded board and draw it
    in a pretty way on the screen. It will tilt the board in the same way as our drawings,
    so it’s obvious which six hexagons neighbor any given hexagon.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个函数，它将接受一个编码的棋盘，并以美观的方式在屏幕上绘制它。它将以与我们的绘图相同的方式倾斜棋盘，因此可以清楚地看到任何给定的六边形周围相邻的六个六边形。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the whole purpose of this `draw-board` function is to write stuff to the
    console, it’s definitely not functional. Let’s look at this function more closely.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于整个 `draw-board` 函数的目的是将内容写入控制台，它肯定不是函数式的。让我们更仔细地看看这个函数。
- en: The outer `loop` runs through all the rows of the board, stored in the variable
    `y` ![](httpatomoreillycomsourcenostarchimages783564.png). There are two inner
    `loop`s. The first inner `loop` adds the indentation to the left side to give
    the board that tilted look ![](httpatomoreillycomsourcenostarchimages783562.png).
    The second inner `loop` loops through the columns, stored in the variable `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png). It then uses `x` and `y`
    to calculate the appropriate hex number, and retrieves that hex from the board
    array using `aref` ![](httpatomoreillycomsourcenostarchimages783554.png). Finally,
    it prints the data in the hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 外层`循环`遍历存储在变量`y`中的棋盘所有行 ![httpatomoreillycomsourcenostarchimages783564.png]。存在两个内层`循环`。第一个内层`循环`在左侧添加缩进，使棋盘看起来倾斜
    ![httpatomoreillycomsourcenostarchimages783562.png]。第二个内层`循环`遍历存储在变量`x`中的列 ![httpatomoreillycomsourcenostarchimages783560.png]。然后使用`x`和`y`计算适当的十六进制数，并使用`aref`从棋盘数组中检索该十六进制数
    ![httpatomoreillycomsourcenostarchimages783554.png]。最后，它打印出十六进制中的数据 ![httpatomoreillycomsourcenostarchimages783510.png]。
- en: 'Here’s the output of the `draw-board` function, as well as a drawing to compare
    it with:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`draw-board`函数的输出，以及与之比较的绘图：
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781087.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781087.png.jpg)'
- en: Decoupling Dice of Doom's Rules from the Rest of the Game
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将“末日骰子”的规则与游戏的其他部分解耦
- en: 'Now we’re ready to write the code that takes care of the guts of our first
    Dice of Doom implementation. In writing this code, we’re going to employ a powerful
    functional programming technique: a *function pipeline*. This means that our game
    is going to consist of a succession of functions that operate, one after another,
    on a big chunk of data, which will hold a representation of our game board, making
    modifications to the structure along the way. A function pipeline will allow us
    to build a game rule engine that’s *100% decoupled from the rest of the game code*.
    To understand why this is so cool, let’s first consider some of what’s involved
    in writing a board game with a smart AI player.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写处理我们第一个“末日骰子”实现核心部分的代码。在编写此代码时，我们将采用一种强大的函数式编程技术：函数管道。这意味着我们的游戏将由一系列函数组成，这些函数依次对一个大数据块进行操作，该数据块将包含我们游戏棋盘的表示，并在过程中对其进行修改。函数管道将使我们能够构建一个与游戏代码其他部分完全解耦的游戏规则引擎。为了理解为什么这如此酷，让我们首先考虑编写具有智能人工智能玩家的棋盘游戏所涉及的一些内容。
- en: For one thing, any computer implementation of a board game will need code that
    handles the human player’s moves. This part of the code will need to know the
    rules of the board game and make sure the human player’s move is legal before
    letting it happen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任何棋盘游戏的计算机实现都需要处理人类玩家走棋的代码。这部分代码需要了解棋盘游戏的规则，并在允许发生之前确保人类玩家的走棋是合法的。
- en: We’ll also need to write the AI code. And in order for the AI player to pick
    a move, it needs to know all the rules of the board game.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写人工智能代码。为了让人工智能玩家选择走棋，它需要了解棋盘游戏的全部规则。
- en: 'Notice something? Both of these separate parts of our game engine need to understand
    the rules of the game! Clearly, what we want to do is break our game code into
    three big pieces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到了什么？我们游戏引擎的这两个独立部分都需要理解游戏规则！显然，我们想要做的是将我们的游戏代码分成三个主要部分：
- en: The handling of the human’s moves
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理人类的走棋
- en: The AI player
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能玩家
- en: The rule engine
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则引擎
- en: One piece handles the player’s moves. Another is the code for the AI player.
    Both of these then talk to some code that understand the rules, sort of a “rule
    engine.” Is this kind of design possible?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一部分处理玩家的走棋。另一部分是人工智能玩家的代码。这两部分然后与一些理解规则的代码进行通信，有点像“规则引擎”。这种设计可能吗？
- en: In a traditional, imperative programming style, it would be very difficult to
    write a program like this. Most imperative game engines duplicate the code that
    “understands the rules,” because of the complexity of writing fully decoupled
    components in an imperative language. The reason for this is that a board game
    requires a lot of context—every move is dependent on what moves preceded it. This
    means that every time the AI module or player-handling module needs to check the
    rules, it must tell the “rule code” the current context in detail. Both would
    need to tell the rule code that “It’s player so-and-so’s turn and the game board
    looks like such-and-such.” Without this information, the rule code can’t tell
    whether or not a move is legal.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的命令式编程风格中，编写这样的程序会非常困难。大多数命令式游戏引擎会复制“理解规则”的代码，因为在一个命令式语言中编写完全解耦的组件非常复杂。这是因为棋盘游戏需要大量的上下文——每一个动作都依赖于之前发生的动作。这意味着每次AI模块或玩家处理模块需要检查规则时，它必须详细地告诉“规则代码”当前的上下文。两者都需要告诉规则代码：“现在是某某玩家的回合，游戏板看起来是这样的。”没有这些信息，规则代码就无法判断一个动作是否合法。
- en: Passing around this context requires tons of tedious bookkeeping code everywhere,
    is error-prone, and is inefficient. It’s inefficient because, with a naive design,
    the player-handling code may check the legality of moves the AI code had already
    explored and found legal.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 传递这个上下文需要大量的繁琐的记账代码，容易出错，且效率低下。效率低下是因为，在简单的设计中，玩家处理代码可能会检查AI代码已经探索并认为合法的动作的合法性。
- en: Using functional programming, however, we can decouple these three concerns
    entirely in our program. We will be able to do this without bookkeeping code and
    in a way that avoids duplication any legality calculations. We will accomplish
    this by encoding our rule code in a lazy game tree!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用函数式编程，我们可以在程序中完全解耦这三个关注点。我们将能够做到这一点，而不需要记账代码，并且以避免任何合法性计算重复的方式。我们将通过将我们的规则代码编码在懒游戏树中来实现这一点！
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The basic approach we’re using—programming a game in the functional style using
    a lazy game tree and a function pipeline—is described in the classic paper “Why
    Functional Programming Matters” by John Hughes ([http://www.scribd.com/doc/26902/whyfp/](http://www.scribd.com/doc/26902/whyfp/)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的基本方法——使用懒游戏树和函数管道以函数式风格编写游戏——在John Hughes的经典论文“为什么函数式编程很重要”中有描述([http://www.scribd.com/doc/26902/whyfp/](http://www.scribd.com/doc/26902/whyfp/))。
- en: In this chapter, we’ll be creating a game tree that is not yet lazy. You’ll
    need to wait until [Chapter 18](ch20.html "Chapter 18. Lazy Programming") to understand
    lazy programming and what a lazy game tree will look like. That’s also when you’ll
    be able to fully appreciate how cool this architectural design really is.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个还不是懒的棋盘树。您需要等到[第18章](ch20.html "第18章。懒编程")才能理解懒编程以及懒游戏树的样子。那时您也将能够完全欣赏这种架构设计有多么酷。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781119.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781119.png.jpg)'
- en: Generating a Game Tree
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成游戏树
- en: 'The entire rule set for our game is encoded in the following master function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏的整个规则集都编码在以下主函数中：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `game-tree` function builds a tree of all possible moves, given a certain
    starting configuration. This function will be called only a single time at the
    beginning of the game. It will then recursively build a tree of all possible moves
    for the game, down to the final winning positions. The other parts of our game
    will then elegantly traverse this tree in order to conform to the rules of the
    game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-tree`函数根据一定的起始配置构建所有可能动作的树。这个函数将在游戏开始时只被调用一次。然后，它将递归地构建游戏的所有可能动作的树，直到最终的胜利位置。我们的游戏的其他部分将优雅地遍历这棵树，以符合游戏的规则。'
- en: 'In order to calculate the legal possible moves of the game tree from a given
    context, the function needs four pieces of data passed to it as arguments ![](httpatomoreillycomsourcenostarchimages783564.png):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '为了从给定的上下文中计算游戏树的合法可能动作，该函数需要通过参数传递四份数据 ![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png):'
- en: What the board looks like
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋盘的样子
- en: The current player
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前玩家
- en: How many dice have been captured by the player in the player’s current turn,
    which is needed to calculate any future reinforcements, as per our rules
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前回合中，玩家捕获了多少个骰子，这是根据我们的规则计算未来增援所需的
- en: Whether the current move is the first move for the current player, because a
    player can’t pass a turn without first making at least one move
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前移动是否是当前玩家的第一次移动，因为玩家在至少进行一次移动之前不能传递回合
- en: 'As the `game-tree` function creates the tree, it will put information about
    the current board and current player at every branch ![](httpatomoreillycomsourcenostarchimages783562.png).
    The subbranches will then hold all the legal follow-up moves from the current
    branch:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当`game-tree`函数创建树时，它将在每个分支上放置有关当前棋盘和当前玩家的信息 ![放置当前棋盘和玩家信息](httpatomoreillycomsourcenostarchimages783562.png)。子分支将包含从当前分支的所有合法后续移动：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783184.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783184.png)'
- en: 'There are two types of legal moves possible for players: attack a hexagon or
    pass their turn to the next player (assuming they’ve already attacked at least
    once already). The passing move is added to the list of legal moves through the
    `add-passing-move` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    The attacking moves are added to the list through the `attacking-moves` function
    ![](httpatomoreillycomsourcenostarchimages783554.png). Let’s look at these functions
    next.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可能有两种合法的移动类型：攻击一个六边形或将其回合传递给下一个玩家（假设他们已经至少攻击过一次）。通过`add-passing-move`函数将传递移动添加到合法移动列表中
    ![添加传递移动](httpatomoreillycomsourcenostarchimages783560.png)。攻击移动通过`attacking-moves`函数添加到列表中
    ![添加攻击移动](httpatomoreillycomsourcenostarchimages783554.png)。接下来，让我们看看这些函数。
- en: Calculating Passing Moves
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算传递移动
- en: 'Here is the function that adds the passing moves to the game tree:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向游戏树添加传递移动的函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE17]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The job of this function is to add a passing move to the tally of moves, if
    passing is permitted. The current list of moves is passed in to this function
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then the function will
    return the expanded list of moves. If the move is the first move in a player’s
    turn ![](httpatomoreillycomsourcenostarchimages783562.png), no passing is allowed,
    and we just return the unaltered list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we add a new move to the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的任务是在允许传递的情况下，将传递移动添加到移动总数中。当前移动列表被传递到这个函数 ![传递当前移动列表](httpatomoreillycomsourcenostarchimages783564.png)，然后该函数将返回扩展后的移动列表。如果移动是玩家回合中的第一次移动
    ![玩家回合中的第一次移动](httpatomoreillycomsourcenostarchimages783562.png)，则不允许传递，我们只返回未更改的列表
    ![不允许传递](httpatomoreillycomsourcenostarchimages783560.png)。否则，我们向列表中添加一个新的移动。
- en: 'Every move in our game tree consists of two parts:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏树中的每个移动都由两部分组成：
- en: The first part is a description of the move. Since we’re just passing in this
    move, we’ll set the description to `nil` ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分是对移动的描述。由于我们只是传递这个移动，我们将描述设置为`nil` ![设置描述为nil](httpatomoreillycomsourcenostarchimages783554.png)。
- en: The second part of the move is an entirely new game tree, which holds the entire
    universe of moves that exists after this move has been performed. We create this
    by recursively calling `game-tree` again ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since this is the end of the player’s turn, the player may receive dice as reinforcements.
    So, we update the board sent to this new `game-tree` call with the `add-new-dice`
    function ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动的第二部分是一个全新的游戏树，它包含了在此移动执行后存在的所有可能的移动。我们通过递归调用`game-tree`来创建这个游戏树 ![递归调用game-tree](httpatomoreillycomsourcenostarchimages783510.png)。由于这是玩家的回合结束，玩家可能会收到骰子作为增援。因此，我们使用`add-new-dice`函数更新发送给这个新`game-tree`调用的棋盘
    ![添加新骰子](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Of course, we also will need to change the current player, since a new person’s
    turn is now starting. We do this by adding one to the current player number and
    taking the modulus of the result, with the total number of players as the denominator
    ![](httpatomoreillycomsourcenostarchimages783544.png). Changing a player in this
    fancy way will allow the code to work, even when we increase the number of players
    in the game in future versions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要更改当前玩家，因为现在是一个新人的回合开始了。我们通过将当前玩家编号加一，并用玩家总数作为除数取模来实现这一点 ![更改玩家编号](httpatomoreillycomsourcenostarchimages783544.png)。以这种方式更改玩家将允许代码在未来版本中即使增加游戏中的玩家数量也能正常工作。
- en: Calculating Attacking Moves
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算攻击移动
- en: 'Here is the function that adds the possible attacking moves to the game tree:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向游戏树添加可能攻击移动的函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](http://atomoreilly.com/source/nostarch/images/783226.png)'
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `attacking-moves` function is a bit more complicated than the `add-passing-move`
    function. It’s responsible for scanning the current game board and figuring out
    what moves the current player is legally allowed to perform.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`attacking-moves`函数比`add-passing-move`函数复杂一些。它负责扫描当前游戏棋盘，并确定当前玩家合法允许执行哪些移动。'
- en: Since it must spend a lot of time figuring out who the player is on a given
    hexagon, we first write a convenience function called `player` that returns the
    player for a given board position ![](httpatomoreillycomsourcenostarchimages783564.png).
    We write a similar function to get the number of dice on a given hexagon ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须花费大量时间来确定给定六边形上的玩家是谁，我们首先编写了一个方便的函数`player`，该函数返回给定棋盘位置的玩家 ![http://atomoreilly.com/source/nostarch/images/783564.png]。我们编写了一个类似函数来获取给定六边形上的骰子数量
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。
- en: Next, we need to scan the board top to bottom and find out which squares the
    current player occupies. For each occupied square, there may be one or more legal
    attacks starting at that position. Since the number of attacks from any hexagon
    may vary, we use `mapcan` to scan the board ![](httpatomoreillycomsourcenostarchimages783560.png).
    Remember that `mapcan` lets each hexagon we scan return its results as a list.
    Then `mapcan` concatenates these lists together. This way, any scanned hexagon
    can contribute zero to *n* moves to the list.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从上到下扫描棋盘，找出当前玩家占据的方格。对于每个占据的方格，可能有一个或多个从该位置开始的合法攻击。由于任何六边形的攻击数量可能不同，我们使用`mapcan`来扫描棋盘
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。记住，`mapcan`允许我们扫描的每个六边形将其结果作为列表返回。然后`mapcan`将这些列表连接起来。这样，任何扫描的六边形都可以向列表贡献从0到*n*个移动。
- en: Within the `lambda` function used by the `mapcan`, which gets called for every
    hexagon, we first want to check whether the current player occupies this hexagon
    ![](httpatomoreillycomsourcenostarchimages783554.png). Then we want to check all
    of its neighbors to see if any of them present a viable attack. We do this with
    another `mapcan` ![](httpatomoreillycomsourcenostarchimages783510.png). We’ll
    figure out the neighbors to this hexagon by using the `neighbors` function, which
    we’ll write shortly ![](httpatomoreillycomsourcenostarchimages783498.png).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mapcan`函数中使用的`lambda`函数，该函数为每个六边形调用一次，我们首先想要检查当前玩家是否占据了该六边形 ![http://atomoreilly.com/source/nostarch/images/783554.png]。然后我们想要检查所有相邻的六边形，看看是否有任何一个六边形构成了有效的攻击。我们使用另一个`mapcan`
    ![http://atomoreilly.com/source/nostarch/images/783510.png] 来完成这个操作。我们将通过使用`neighbors`函数来确定这个六边形的相邻六边形，这个函数我们将很快编写
    ![http://atomoreilly.com/source/nostarch/images/783498.png]。
- en: How do we decide if a hexagon can be an attack destination? Well, it must be
    a hexagon we don’t already own, plus (as per the rules) the source hexagon needs
    to have more dice than the destination hexagon ![](httpatomoreillycomsourcenostarchimages783544.png).
    If we have found a legal attack move, we then describe the move ![](httpatomoreillycomsourcenostarchimages783556.png).
    The description is simply a list of the source position and the destination position.
    We then (as with passing moves) recursively generate another game tree that describes
    what happens if the move is executed ![](httpatomoreillycomsourcenostarchimages783566.png).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何决定一个六边形是否可以成为攻击目标？嗯，它必须是一个我们尚未拥有的六边形，并且（根据规则）源六边形需要比目标六边形有更多的骰子 ![http://atomoreilly.com/source/nostarch/images/783544.png]。如果我们找到了一个合法的攻击移动，我们随后描述这个移动
    ![http://atomoreilly.com/source/nostarch/images/783556.png]。描述只是一个源位置和目标位置的列表。然后（就像传递移动一样）递归地生成另一个游戏树，描述如果执行这个移动会发生什么
    ![http://atomoreilly.com/source/nostarch/images/783566.png]。
- en: Finding the Neighbors
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找相邻六边形
- en: 'Next, let’s create the function that calculates the neighboring hexagons to
    a given hexagon:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个函数来计算给定六边形的相邻六边形：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](http://atomoreilly.com/source/nostarch/images/783226.png)'
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every hexagon on the board may have up to six neighbors, or fewer, if the hexagon
    is on an edge of the board. We build up a list of possible neighbors in a `loop`
    ![](httpatomoreillycomsourcenostarchimages783564.png), and then collect the ones
    with position numbers that aren’t off the edge of the board ![](httpatomoreillycomsourcenostarchimages783554.png).
    Also, since our position numbers wrap from row to row, we need to make sure we
    don’t look to the left if we’re on the left edge of the board ![](httpatomoreillycomsourcenostarchimages783562.png)
    or look to the right if we’re on the right edge of the board ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏板上的每个六边形可能有最多六个邻居，如果六边形在板的边缘，则可能更少。我们通过一个`loop`构建可能的邻居列表 ![loop](httpatomoreillycomsourcenostarchimages783564.png)，然后收集那些位置编号不在板边缘的六边形
    ![不在边缘](httpatomoreillycomsourcenostarchimages783554.png)。此外，由于我们的位置编号从行到行是循环的，我们需要确保如果我们位于板的左侧边缘
    ![左侧边缘](httpatomoreillycomsourcenostarchimages783562.png) 或右侧边缘 ![右侧边缘](httpatomoreillycomsourcenostarchimages783560.png)，不要向左看或向右看。
- en: This function is marked clean (it is in the functional style), but nonetheless
    contains a loop. Usually, looping goes against the tenets of functional programming.
    However, many Lispers consider it kosher to use a `loop` in functional code if
    all it does is collect some values, since it really isn’t mutating any values
    or producing any other side effects. So, we will allow ourselves to use such loops
    in the functional-style part of this game.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被标记为清洁（它处于函数式风格），但尽管如此，它仍然包含一个`loop`。通常，循环违反函数式编程的原则。然而，许多Lisper认为，如果`loop`只是收集一些值，那么在函数式代码中使用它是可以接受的，因为它实际上并没有改变任何值或产生任何其他副作用。因此，我们将允许自己在游戏的函数式风格部分使用这样的循环。
- en: 'Let’s try out our `neighbors` function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的`neighbors`函数：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781241.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781241.png)'
- en: As you can see, it correctly tells us that hexagon 2 neighbors hexagons 0 and
    3.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它正确地告诉我们六边形2的邻居是六边形0和3。
- en: Attacking
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击
- en: 'Now let’s write our `board-attack` function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写我们的`board-attack`函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a function that figures out what happens if the hexagon `src` attacks
    the hexagon `dst`. It works by `loop`ing across the board, keeping track of the
    current position ![](httpatomoreillycomsourcenostarchimages783564.png) and the
    contents in the hexagon at that position ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the current hexagon is the source hexagon, we just place a single die in that
    place; as per our rules, a single die is left behind after an attack ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the current hexagon is the destination position, we place the remaining dice
    there, subtracting the one left behind ![](httpatomoreillycomsourcenostarchimages783554.png).
    In other cases, we just collect the very same hex ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个确定如果六边形`src`攻击六边形`dst`会发生什么的函数。它通过在板上`loop`，跟踪当前位置 ![当前位置](httpatomoreillycomsourcenostarchimages783564.png)
    和该位置六边形的内含物 ![六边形内容](httpatomoreillycomsourcenostarchimages783562.png) 来工作。如果当前六边形是源六边形，我们只需在那个地方放置一个骰子；根据我们的规则，攻击后留下一个骰子
    ![留下骰子](httpatomoreillycomsourcenostarchimages783560.png)。如果当前六边形是目标位置，我们将剩余的骰子放在那里，减去留下的一个
    ![减去骰子](httpatomoreillycomsourcenostarchimages783554.png)。在其他情况下，我们只是收集相同的六边形
    ![相同的六边形](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'Let’s try out our `board-attack` function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的`board-attack`函数：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782736.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782736.png)'
- en: As you can see, attacking from hexagon 1 to 3 causes `board-attack` to properly
    update the game board, so that one die remains on the old square and two are on
    the new, conquered square.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从六边形1攻击到3会导致`board-attack`正确更新游戏板，使得一个骰子留在原来的方格上，两个在新的、征服的方格上。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many of the functions in this chapter have inefficiencies to keep things simple.
    We’ll fix many of these in future versions of the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多函数都有低效之处，以保持简单。我们将在游戏的未来版本中修复这些问题。
- en: Reinforcements
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增援
- en: To add the reinforcements to the board, we need to scan across the game board,
    find occupied spots that can accommodate another die, and add the die there. Of
    course, the number of reinforcements is limited based on how many opponent dice
    the player captured in the last turn. Because of this, we’ll need to keep a running
    tally of how many reinforcement dice remain.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要在棋盘上添加强化，我们需要扫描整个游戏棋盘，找到可以容纳另一个骰子的占据点，并将骰子放在那里。当然，强化骰子的数量受限于玩家在上一个回合中捕获的对手骰子的数量。因此，我们需要持续计算剩余的强化骰子数量。
- en: The most obvious way to track the remaining dice would be to have a `remaining-dice`
    variable, and decrement this every time a die is placed. However, having a die
    that is decremented (mutated) would not be in line with the functional style.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪剩余骰子的最明显方法是有 `remaining-dice` 变量，并在放置骰子时递减。然而，拥有递减（变异）的骰子与函数式风格不符。
- en: Therefore, instead, we’re going to write our `add-new-dice` function using a
    local recursive function, which will also maintain this running count of dice.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用局部递归函数来编写我们的 `add-new-dice` 函数，该函数也将维护骰子的运行计数。
- en: 'Here is this `add-new-dice` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个 `add-new-dice` 函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing `add-new-dice` does is define a local function named `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This function will be our list-eater that goes through the hexagons of the board
    and spits out a new list that includes the reinforcements. Since our board is
    actually stored in an array for efficiency reasons, we convert our array into
    a list with the `coerce` function before calling `f` ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`add-new-dice` 首先定义了一个名为 `f` 的局部函数 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。这个函数将遍历棋盘上的六边形，并输出一个包含强化骰子的新列表。由于我们的棋盘实际上为了效率原因存储在一个数组中，我们在调用
    `f` 之前使用 `coerce` 函数将数组转换为列表 ![图片](httpatomoreillycomsourcenostarchimages783556.png)。'
- en: 'Inside the function `f`, we must consider three situations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数 `f` 内部，我们必须考虑三种情况：
- en: That we’re at the end of the board. In this case, the reinforced board will
    also be completed, so we just return `nil` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经到达棋盘的末尾。在这种情况下，强化后的棋盘也将完成，所以我们只需返回 `nil` ![图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: That we’re out of `spare-dice` to add to add as reinforcements. In this case,
    the rest of the board will just be the same as before, so we can just return the
    remainder of the list as the new board ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经没有 `spare-dice` 可以添加作为强化。在这种情况下，剩余的棋盘将保持不变，因此我们可以直接返回列表的剩余部分作为新的棋盘 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。
- en: Neither of the preceding situations. In all other cases, we need to analyze
    the current hexagon and decide whether a reinforcement should be added in it.
    We check whether the current player occupies that hexagon and whether we have
    less than the maximum number of dice on that square ![](httpatomoreillycomsourcenostarchimages783554.png).
    If this is the case, we add a new die on the hexagon and call `f` against the
    rest of the board, recursively ![](httpatomoreillycomsourcenostarchimages783510.png).
    Otherwise, we leave the current hexagon unchanged and proceed by recursively calling
    `f` against the rest of the board ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述两种情况都不适用。在其他所有情况下，我们需要分析当前六边形并决定是否需要在其中添加强化。我们检查当前玩家是否占据该六边形，以及在该方块上我们是否拥有少于最大数量的骰子
    ![图片](httpatomoreillycomsourcenostarchimages783554.png)。如果是这种情况，我们在六边形上添加一个新的骰子，并对剩余的棋盘递归地调用
    `f` ![图片](httpatomoreillycomsourcenostarchimages783510.png)。否则，我们保持当前六边形不变，并通过递归地调用
    `f` 对剩余的棋盘进行操作 ![图片](httpatomoreillycomsourcenostarchimages783544.png)。
- en: 'Let try adding reinforcements to a board:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在棋盘上添加强化：
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `add-new-dice` properly placed two reinforcement dice for player
    A (player 0).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`add-new-dice` 正确地为玩家 A（玩家 0）放置了两个强化骰子。
- en: Trying Out Our New game-tree Function
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试我们的新游戏树函数
- en: We have now written all the code needed to create a comprehensive game tree
    of our simplified version of Dice of Doom. But be careful! A game tree of most
    board games is excruciatingly large. Even on a 2-by-2 board, our game may consist
    of hundreds of possible moves. You’ll want to call the `game-tree` function only
    on a game board that is near the end of play, or you’ll be watching helplessly
    as the CLISP REPL prints out a humongous tree showing all the possible ways in
    which a game may progress.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了创建简化版“末日骰子”的完整游戏树的所需所有代码。但要注意！大多数棋类游戏的游戏树都非常庞大。即使在2x2的棋盘上，我们的游戏也可能包含数百种可能的动作。你只想在接近游戏结束的棋盘上调用`game-tree`函数，否则你将无助地看着CLISP
    REPL打印出一个巨大的树，显示游戏可能进展的所有可能方式。
- en: 'Here is a safe board position for you to try out:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个安全的棋盘位置供你尝试：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783122.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/783122.png)'
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The game tree first lists the current player number ![](httpatomoreillycomsourcenostarchimages783564.png),
    the layout of the board ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then the legal moves for that context. For the initial board position, at
    the beginning of player A’s turn, there is only one possible move: The player
    can move from hexagon 2 to hexagon 3, capturing player B’s die in that spot ![](httpatomoreillycomsourcenostarchimages783560.png).
    After that, the player can pass. Player B now has no move available. Since this
    player’s game tree has no available moves listed ![](httpatomoreillycomsourcenostarchimages783554.png),
    the game has ended, with a win for player A.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏树首先列出当前玩家编号 ![http://atomoreilly.com/source/nostarch/images/783564.png](http://atomoreilly.com/source/nostarch/images/783564.png)，棋盘布局
    ![http://atomoreilly.com/source/nostarch/images/783562.png]，然后是该上下文的有效动作。对于初始棋盘位置，在玩家A的回合开始时，只有一个可能的动作：玩家可以从六边形2移动到六边形3，捕获该位置的玩家B的骰子
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。之后，玩家可以选择过。玩家B现在没有可用的动作。由于这个玩家的游戏树没有列出可用的动作
    ![http://atomoreilly.com/source/nostarch/images/783554.png]，游戏结束，玩家A获胜。
- en: Playing Dice of Doom Against Another Human
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与另一名人类玩“末日骰子”
- en: Now that we’ve completely captured the universe of Dice of Doom in our comprehensive
    `game-tree` function, it’s simple to create a human versus human version of this
    game. All we need to do is create some functions that travel down the game tree
    as players choose their moves.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完全捕获了“末日骰子”游戏的全局“游戏树”函数，创建一个人类对人类版本的游戏变得简单。我们只需要创建一些函数，让它们随着玩家选择动作而沿着游戏树向下移动。
- en: The Main Loop
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主循环
- en: 'Here is the function that travels down the game tree, allowing two humans to
    play Dice of Doom:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是沿着游戏树向下移动的函数，允许两名人类玩“末日骰子”：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/781994.png)'
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function, `play-vs-human`, is the main loop of our game. It accepts a tree
    describing the starting position of the board.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数`play-vs-human`是游戏的主循环。它接受一个描述棋盘起始位置的树。
- en: First, it calls a function named `print-info`, which will draw the board on
    the screen, along with other helpful information about the current state of the
    game ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we need to check
    if any follow-up moves exist. These follow-up moves would be listed starting at
    the `caddr` position of the game tree ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它调用一个名为`print-info`的函数，该函数将在屏幕上绘制棋盘，以及有关游戏当前状态的其他有用信息 ![http://atomoreilly.com/source/nostarch/images/783564.png](http://atomoreilly.com/source/nostarch/images/783564.png)。接下来，我们需要检查是否存在后续动作。这些后续动作将从游戏树的`caddr`位置开始
    ![http://atomoreilly.com/source/nostarch/images/783562.png](http://atomoreilly.com/source/nostarch/images/783562.png)。
- en: If follow-up moves are available, we call the function `handle-human`, which
    will interact with the current player to help him pick his new move. This `handle-human`
    function will then return the subbranch of the tree that represents the player’s
    choice. We can then recursively pass this subbranch into `play-vs-human` to proceed
    with the game ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有后续动作可用，我们调用`handle-human`函数，该函数将与当前玩家交互，帮助他选择新的动作。然后`handle-human`函数将返回表示玩家选择的子树的分支。然后我们可以递归地将这个子分支传递给`play-vs-human`以继续游戏
    ![http://atomoreilly.com/source/nostarch/images/783560.png](http://atomoreilly.com/source/nostarch/images/783560.png)。
- en: If no follow-up moves are available, the game has officially ended. We then
    call the `announce-winner` function, which, appropriately, will announce the winner
    ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有后续动作可用，游戏就正式结束了。然后我们调用`announce-winner`函数，它恰当地会宣布获胜者 ![http://atomoreilly.com/source/nostarch/images/783554.png](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: Giving Information About the State of the Game
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏状态信息提供
- en: 'Here is the print-info function, which describes the status of the current
    node in the game tree:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`print-info`函数，它描述了游戏树中当前节点的状态：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This function displays two important pieces of information on the REPL. First,
    it shows who the current player is ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it prints out a pretty version of the game board with the `draw-board` function
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在REPL上显示两个重要的信息。首先，它显示了当前玩家是谁 ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。然后，它使用`draw-board`函数打印出游戏板的漂亮版本
    ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Handling Input from Human Players
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理来自人类玩家的输入
- en: Next is the function that lets humans choose their next move. It displays a
    very helpful, numbered menu of all currently available moves for the player to
    choose from.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是允许人类选择下一步行动的函数。它显示了一个非常有用的、编号的菜单，列出了所有当前可用的移动供玩家选择。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To display the list of available moves, we use a `loop` that traverses all the
    available moves and prints a description about each one ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `loop` is not functional, since it prints stuff on the screen for the player
    to read. We print a counting number in front of each move ![](httpatomoreillycomsourcenostarchimages783560.png)
    using the variable n, which counts from 1 inside our `loop` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示可用的移动列表，我们使用一个`loop`遍历所有可用的移动，并打印每个移动的描述 ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。这个`loop`不是函数式的，因为它在屏幕上打印内容供玩家阅读。我们使用变量n在每次移动前打印一个计数数字
    ![无标题图片](httpatomoreillycomsourcenostarchimages783560.png)，其中n在`loop`内部从1开始计数
    ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Each move has an action value associated with it. If the action is non-nil ![](httpatomoreillycomsourcenostarchimages783554.png),
    then the action is an attack, where the action value describes the source and
    destination hexagons of the attack. We print such attacking action using the `format`
    command ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个移动都与一个动作值相关联。如果动作非nil ![无标题图片](httpatomoreillycomsourcenostarchimages783554.png)，则该动作是攻击，动作值描述了攻击的源和目标六边形。我们使用`format`命令打印这种攻击动作
    ![无标题图片](httpatomoreillycomsourcenostarchimages783510.png)。
- en: We use an empty action value to represent the passing move. In that case, we
    just `princ` “end turn” to describe this move ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个空的动作值来表示传递动作。在这种情况下，我们只需`princ`“结束回合”来描述这个动作 ![无标题图片](httpatomoreillycomsourcenostarchimages783544.png)。
- en: After the available moves have been displayed, we use `read` to read in the
    player’s choice. With the `nth` function, we can then select that branch of the
    game tree and return it from our `handle-human` function ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示可用的移动后，我们使用`read`读取玩家的选择。然后，使用`nth`函数，我们可以选择游戏树的那部分并从我们的`handle-human`函数返回它
    ![无标题图片](httpatomoreillycomsourcenostarchimages783556.png)。
- en: Determining the Winner
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定胜者
- en: The task of announcing the winner can be nicely broken into a *clean/functional*
    and a *dirty/imperative* part.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 宣布胜者的任务可以很好地分为一个*干净/功能*部分和一个*脏/强制*部分。
- en: The clean part concerns the task of calculating the winning player. We want
    to calculate this in a way that can handle more than just two players, since our
    game will allow for more in the future. Also, the function must be cognizant of
    possible ties.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的部分涉及计算胜者的任务。我们希望以能够处理不仅仅是两个玩家的方式计算这一点，因为我们的游戏未来将允许更多。此外，该函数必须意识到可能的平局。
- en: 'To accomplish this, we’ll write a function called `winners` that returns a
    list of one or more players who captured the maximum number of hexagons at the
    end of the game. If there is a tie, it will simply return all the players who
    share first place, in terms of the total count of occupied spaces for all players.
    With this design, the function will work for *any number of players* and will
    elegantly handle ties. This is what the `winners` function looks like:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将编写一个名为`winners`的函数，该函数返回一个或多个在游戏结束时捕获了最多六边形的玩家列表。如果有平局，它将简单地返回所有共享第一名的玩家，即所有玩家占据的总空间数。按照这种设计，该函数将适用于*任何数量的玩家*，并且优雅地处理平局。这是`winners`函数的样子：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE29]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We calculate the winner for a given ending board position in four steps.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过四个步骤计算给定结束棋盘位置的赢家。
- en: First, we build up a tally of who occupies each hexagon on the board ![](httpatomoreillycomsourcenostarchimages783564.png).
    With the `across loop` construct, we can traverse the array of the ending board
    directly and collect the occupier of each hexagon.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们统计出占据棋盘上每个六边形的玩家！[](httpatomoreillycomsourcenostarchimages783564.png)。使用`across
    loop`结构，我们可以直接遍历结束棋盘的数组并收集每个六边形的占据者。
- en: Second, we need to count the total number of squares each player has captured,
    using this tally. The totals variable will be an alist of player->spaces pairs.
    We build this alist by finding all players who have at least one entry in the
    tally with `remove-duplicates` ![](httpatomoreillycomsourcenostarchimages783560.png).
    We can map across this and then create a count for each occupier ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，我们需要使用这个统计来计算每个玩家占领的总方块数。`totals`变量将是一个player->spaces对的alist。我们通过使用`remove-duplicates`找到至少在统计中有一次条目的所有玩家来构建这个alist！[](httpatomoreillycomsourcenostarchimages783560.png)。然后我们可以映射到这个列表，并为每个占据者创建一个计数！[](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Third, we want to find what the maximum number of occupied hexagons for a single
    player is. We do this by stripping the counts from our alist by mapping `cdr`
    across the list ![](httpatomoreillycomsourcenostarchimages783554.png). We then
    apply `max` to this list to find the largest number of occupied spaces for a single
    player.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们想要找出单个玩家占据的六边形数量的最大值。我们通过映射`cdr`到我们的alist上来从计数中去除！[](httpatomoreillycomsourcenostarchimages783554.png)。然后，我们应用`max`到这个列表中，以找到单个玩家占据的最大空间数量。
- en: Finally, we need create a list of all the “best” players. We do this by stripping
    out all but the best from our totals using the `remove-if` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    We then just pull out the player numbers for the best players by mapping `car`
    across the list of bests ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个包含所有“最佳”玩家的列表。我们通过使用`remove-if`函数从总数中去除所有非最佳玩家来实现这一点！[](httpatomoreillycomsourcenostarchimages783544.png)。然后，我们通过映射`car`到最佳玩家的列表中，提取出最佳玩家的玩家编号！[](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'Next, let’s write the dirty `announce-winner` function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写“宣布赢家”的函数：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is rather simple. First, we calculate the winners by calling our
    earlier function ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    check if there is more than one winner ![](httpatomoreillycomsourcenostarchimages783562.png)
    (a tie). For ties, we print a special message ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we just announce a single winner ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数相当简单。首先，我们通过调用我们之前的功能来计算赢家！[](httpatomoreillycomsourcenostarchimages783564.png)。然后我们检查是否有多个赢家！[](httpatomoreillycomsourcenostarchimages783562.png)（平局）。对于平局，我们打印一条特殊信息！[](httpatomoreillycomsourcenostarchimages783560.png)。否则，我们只宣布一个赢家！[](httpatomoreillycomsourcenostarchimages783554.png)。
- en: Trying Out the Human vs. Human Version of Dice of Doom
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试玩“末日骰子”的人与人版本
- en: 'We now have a completely playable game of dice of doom. Here is an example
    game from start to finish:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全可玩的游戏“末日骰子”。以下是一个从开始到结束的示例游戏：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating an Intelligent Computer Opponent
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个智能电脑对手
- en: As we discussed when we were designing the game tree code for Dice of Doom,
    having a separate game tree generator makes it easy to add an AI player to a game
    engine. In fact, we’re now going to add a computer player that can play an absolutely
    perfect game with only 23 additional lines of code!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在为“末日骰子”设计游戏树代码时讨论的那样，有一个独立的游戏树生成器使得将AI玩家添加到游戏引擎中变得容易。实际上，我们现在要添加一个电脑玩家，它只需23行额外的代码就能玩出绝对完美的游戏！
- en: 'So how does an AI player decide to make a move? We’ll use the following strategy:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个AI玩家是如何决定走哪一步的呢？我们将使用以下策略：
- en: Look at each available move.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个可用的走法。
- en: Give a point rating to the board position resulting from each move.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出每个走法导致的棋盘位置的评分。
- en: Pick the move with the maximum point rating.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择具有最大评分的走法。
- en: 'This sounds like a simple plan, but there is one step in this algorithm that’s
    pretty tricky: calculating the best point rating for a given board position.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计划听起来很简单，但这个算法中有一个步骤相当棘手：计算给定棋盘位置的最佳评分。
- en: If a move leads immediately to a win, it’s easy to give a point rating to that
    move—any winning move clearly deserves a very high point rating. However, most
    moves in a game cannot lead to an immediate win. In those cases, in order to determine
    if the result of a set of moves deserves a good point rating, we need to figure
    out what the opponent player will do in response.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个动作直接导致胜利，很容易为该动作给出评分——任何胜利的动作显然都应得到非常高的评分。然而，大多数游戏中的动作都不能导致立即胜利。在这些情况下，为了确定一系列动作的结果是否值得一个好的评分，我们需要弄清楚对手玩家将如何回应。
- en: But how will we know what the opponent player will decide to do? If we’re not
    careful, we’ll end up in an ugly impasse where we say, “He thinks that I think
    that he thinks that I think . . .” in order to calculate a meaningful point value
    for a given board position. How do we account for the opponent’s behavior without
    giving ourselves a headache?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道对手玩家将决定做什么？如果我们不小心，我们可能会陷入一个丑陋的僵局，我们说，“他认为我认为他认为我认为……”，以便为给定的棋盘位置计算一个有意义的评分。我们如何考虑对手的行为而不让自己头疼？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781316.png.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781316.png.jpg)'
- en: The Minimax Algorithm
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小-最大算法
- en: 'It turns out that for a two-player board game, a simple method exists to model
    what an opponent will do. We simply accept the truism “What is good for my opponent
    is bad for me.” This means we can use the following approach to model a move for
    the opponent:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，对于两人棋盘游戏，存在一种简单的方法来模拟对手将如何行动。我们简单地接受这样一个真理：“对我对手有利的就是对我有害的。”这意味着我们可以使用以下方法来模拟对手的动作：
- en: Look at each available move.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看每个可用的动作。
- en: Give a point rating to the board position resulting from each move.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个动作导致的棋盘位置给出评分。
- en: Pick the move with the minimum point rating.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择评分最低的动作。
- en: This algorithm for estimating what an opponent will do is identical to the one
    used for the primary player, except that in step 3, we pick the move with the
    *minimum* instead of *maximum* rating. The benefit of this approach, called the
    *minimax algorithm*, is that we use the same point ratings when working out the
    opponent’s moves that we use for the primary AI player, but then just tweak the
    third step a little to adjust.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用于估计对手将如何行动的算法与用于主要玩家的算法相同，只是在第3步中，我们选择评分最低的动作而不是评分最高的动作。这种方法的优点，称为最小-最大算法，是我们使用与主要AI玩家相同的评分来计算对手的动作，然后只是稍微调整第3步。
- en: 'This is crucial: It turns out that if we can avoid calculating separate ratings
    for ourselves as for our opponent in the game, then searching down the game tree
    for good moves becomes dramatically easier and faster.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要：结果证明，如果我们能够避免在游戏中为对手和自己计算不同的评分，那么在游戏树中搜索好的动作就会变得大大简化并加快速度。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The basic minimax algorithm works only in two-player games. When three or more
    players are involved in a game, we can’t really say that “What is good for my
    opponent is bad for me” is completely true any more. This is because an additional
    truism becomes important: “The enemy of my enemy is my friend.” This means that
    some of my opponents may, at times, act as a friend by making moves that harm
    a common enemy, while not affecting me directly. We’ll discuss this issue more
    in [Chapter 20](ch22.html "Chapter 20. Making Dice of Doom More Fun").'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的最小-最大算法仅在两人游戏中有效。当有三名或更多玩家参与游戏时，我们不能再断言“对我对手有利的就是对我有害的”这一说法完全正确。这是因为一个额外的真理变得很重要：“敌人的敌人是我的朋友。”这意味着我的某些对手可能会在某个时刻通过采取损害共同敌人的动作来充当朋友，而不会直接影响我。我们将在[第20章](ch22.html
    "第20章。让毁灭骰子游戏更有趣")中更详细地讨论这个问题。
- en: Turning Minimax into Actual Code
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将最小-最大转化为实际代码
- en: 'Now we’re ready to put the minimax idea into practice, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将最小-最大思想付诸实践，如下所示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE32]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `rate-position` function generates a numeric point rating for a given branch
    of the game tree. In order to do this, we first need to figure out if there are
    any moves available from the given position ![](httpatomoreillycomsourcenostarchimages783564.png)
    (that is, the current move is not an ending move in the game).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`rate-position`函数为游戏树的一个给定分支生成一个数值评分。为了做到这一点，我们首先需要确定从给定位置（即当前动作不是游戏中的结束动作）是否有任何可用的动作![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png)。'
- en: If moves are available, we’ll need to look at all the subsequent moves to decide
    how to rate the current position. We accomplish this by calling `get-ratings`
    ![](httpatomoreillycomsourcenostarchimages783554.png), a function that will return
    the point rating of each follow-up move. As per minimax, we will then pick either
    the best (`max`) ![](httpatomoreillycomsourcenostarchimages783562.png) or worst
    (`min`) ![](httpatomoreillycomsourcenostarchimages783560.png) rating of all the
    follow-up moves, depending on whether the move being rated is for the AI player
    or its opponent.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可用动作，我们需要查看所有后续动作以决定如何评级当前位置。我们通过调用`get-ratings` ![评级](httpatomoreillycomsourcenostarchimages783554.png)，一个将返回每个后续动作的点评级的函数来实现这一点。按照最小-最大原则，然后我们将选择所有后续动作中的最佳(`max`)
    ![评级](httpatomoreillycomsourcenostarchimages783562.png)或最差(`min`) ![评级](httpatomoreillycomsourcenostarchimages783560.png)评级，具体取决于正在评级的动作是为AI玩家还是其对手。
- en: If, on the other hand, there are no follow-up moves, we’ll need to check who
    the winner is for the current board position ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the player isn’t among the winners of this position, we can give the position
    the minimum rating of `0` ![](httpatomoreillycomsourcenostarchimages783556.png).
    Otherwise, we’ll divide one by the number of winners to determine our rating ![](httpatomoreillycomsourcenostarchimages783544.png).
    By doing this, we also give a meaningful rating for ties. If the player is the
    sole winner, the rating, using this formula, will be the maximum value of `1`.
    For a two-player tie, the rating will be a sensible `0.5`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有后续动作，我们需要检查当前棋盘位置的胜者 ![胜者](httpatomoreillycomsourcenostarchimages783510.png)。如果玩家不是这个位置胜者之一，我们可以给这个位置分配最低评级`0`
    ![评级](httpatomoreillycomsourcenostarchimages783556.png)。否则，我们将胜者数量除以1来确定我们的评级
    ![评级](httpatomoreillycomsourcenostarchimages783544.png)。通过这样做，我们也为平局给出了有意义的评级。如果玩家是唯一的胜者，根据这个公式，评级将是最大值`1`。对于两名玩家的平局，评级将是合理的`0.5`。
- en: 'Here is what the `get-ratings` function looks like:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`get-ratings`函数的样子：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783226.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783226.png)'
- en: '[PRE33]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function simply maps `rate-position` across each available follow-up move
    for the given branch of the tree.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数简单地映射给定树分支的每个可用后续动作的`rate-position`。
- en: Creating a Game Loop with an AI Player
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用人工智能玩家创建游戏循环
- en: 'Earlier, we wrote a function called `handle-human` that interacted with a human
    to decide on a move in the game. Here is an analogous function, `handle-computer`,
    that interacts with our AI player to choose a move:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们编写了一个名为`handle-human`的函数，该函数与人类交互以决定游戏中的移动。这里有一个类似的功能，`handle-computer`，它与我们的AI玩家交互以选择移动：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE34]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This `handle-computer` function is quite straightforward. First, we get the
    ratings of each available move ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we pick the move that is rated the highest ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`handle-computer`函数相当直接。首先，我们获取每个可用动作的评级 ![评级](httpatomoreillycomsourcenostarchimages783564.png)。然后我们选择评级最高的动作
    ![评级](httpatomoreillycomsourcenostarchimages783562.png)。
- en: 'Finally, let’s create a function that handles the main loop for playing against
    the computer. This one is analogous to our earlier `play-vs-human` function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个处理与计算机对弈的主循环的函数。这个函数与之前的`play-vs-human`函数类似：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781994.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781994.png)'
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As with the `play-vs-human` function, `play-vs-computer` first prints out information
    about the current state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
    If no more moves are available, it then calls the `announce-winner` function ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与`play-vs-human`函数一样，`play-vs-computer`首先打印出有关当前游戏状态的详细信息 ![详细信息](httpatomoreillycomsourcenostarchimages783564.png)。如果没有更多动作可用，它随后调用`announce-winner`函数
    ![详细信息](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Next, we need to check who the current player is. By convention, we’ll have
    the human be player A (player 0). If the player number is 0, we call our old `handle-human`
    function to let the human decide on her move ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, we treat the player as an AI player and use the `handle-computer` function
    to decide on a move ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检查当前玩家是谁。按照惯例，我们将人类玩家称为玩家A（玩家0）。如果玩家编号是0，我们将调用我们的旧`handle-human`函数，让人类玩家决定她的走法
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)。否则，我们将玩家视为AI玩家，并使用`handle-computer`函数来决定走法
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: We have now written a fully functional AI engine for Dice of Doom!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为《末日骰子》编写了一个完全功能化的AI引擎！
- en: Playing Our First Human vs. Computer Game
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩我们的第一次人机对战游戏
- en: The following is an example game playing against the computer AI. The computer
    plays an optimal game and wins.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对抗计算机AI的示例游戏。计算机玩了一局最优游戏并获胜。
- en: '[PRE36]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Making Dice of Doom Faster
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让《末日骰子》更快
- en: The functional programming style can lead to slow code, at least in the hands
    of a novice programmer. We used the functional style to develop the core of Dice
    of Doom. Hence, this first version of our game is excruciatingly inefficient.
    We had to limit our game to a 2-by-2 board to make it playable. But now we can
    increase our board size to 3-by-3, as we optimize our game engine.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程风格可能会导致代码运行缓慢，至少对于新手程序员来说是这样。我们使用了函数式风格来开发《末日骰子》的核心。因此，我们这款游戏的第一版效率极低。为了使其可玩，我们不得不将游戏限制在2x2的棋盘上。但现在，随着我们优化游戏引擎，我们可以将棋盘大小增加到3x3。
- en: Let’s increase the parameters controlling the board size to make this happen.
    You may not want to play a game at this new size until you’ve implemented all
    the optimizations throughout the rest of this chapter, unless you are an extremely
    patient person and don’t mind having the computer take minutes building the initial
    game tree and deciding on moves.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加控制棋盘大小的参数，以实现这一目标。除非你是一个极其有耐心的人，不介意电脑花费数分钟构建初始游戏树并决定走法，否则你可能不想在这个新大小上玩游戏，除非你已经实现了本章其余部分的全部优化。
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There, we’ve upgraded the board size to 3 by 3.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，我们已经将棋盘大小升级到3x3。
- en: The rest of this chapter covers some important techniques for optimizing functional
    code. These techniques apply to all programs written in the functional style,
    which includes Dice of Doom. In later chapters, we’ll add other optimizations.
    Eventually, we’ll be able to play against an AI player on much more spacious boards,
    while still having elegant code written in the functional style.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将介绍一些优化函数式代码的重要技术。这些技术适用于所有以函数式风格编写的程序，包括《末日骰子》。在后面的章节中，我们将添加其他优化。最终，我们将在更大的棋盘上与AI玩家对战，同时仍然保持使用函数式风格编写的优雅代码。
- en: Closures
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Before we start optimizing Dice of Doom, there is an important Lisp programming
    concept we need to discuss: *closures*. Closures are extra bits of data from the
    outside world that are captured whenever a lambda function is created. To understand
    the hows and whys of capturing variables in a closure, consider the following
    example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始优化《末日骰子》之前，有一个重要的Lisp编程概念我们需要讨论：*闭包*。闭包是每当创建lambda函数时从外部世界捕获的一些额外数据。为了理解在闭包中捕获变量的如何和为什么，请考虑以下示例：
- en: '[PRE38]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, we’re creating a new, unnamed function ![](httpatomoreillycomsourcenostarchimages783564.png),
    and then setting `*foo*` equal to this function. Next, we call this function using
    the `funcall` command ![](httpatomoreillycomsourcenostarchimages783562.png). As
    you would expect, the value returned from this function is `5`. All the lambda
    function does is return this number.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个新的、未命名的函数 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)，然后将`*foo*`设置为这个函数。接下来，我们使用`funcall`命令调用这个函数
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)。正如你所期望的，这个函数返回的值是`5`。lambda函数所做的只是返回这个数字。
- en: 'Next, consider this more interesting example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑这个更有趣的例子：
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This version of `foo` is exactly the same as the previous version of `*foo*`,
    except that we first declare a local variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is set to `5`. Then, in the body of the `lambda`, we return `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    So, what do you think will happen if we call this new version of `*foo*`?
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`foo`与之前的`*foo*`版本完全相同，除了我们首先声明了一个局部变量`x` ![http://atomoreilly.com/source/nostarch/images/783564.png]，它被设置为`5`。然后，在`lambda`体的内部，我们返回`x`
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。所以，你认为如果我们调用这个新的`*foo*`版本会发生什么？
- en: The reason this is a tough question is that `x` is declared as a “local” variable.
    However, `x` (apparently) no longer exists once we call `*foo*`, since we’re already
    long past the point where we’re evaluating the body of the `let` expression.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题之所以困难，是因为`x`被声明为一个“局部”变量。然而，一旦我们调用`*foo*`，`x`（显然）就不再存在了，因为我们已经远远超过了评估`let`表达式体的点。
- en: 'Let’s try it out and see what happens:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试看看会发生什么：
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Holy cow! Somehow the lambda expression we created remembered what `x` was at
    the time it was created. The variable `x`, which we previously thought of as a
    local variable, has somehow managed to live on past the block in which it was
    created!
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪！不知怎么的，我们创建的lambda表达式记住了创建时`x`的值。我们之前认为的局部变量`x`不知怎么的设法在其创建的块之外存活了下来！
- en: 'When we first covered `let` expressions in [Chapter 2](ch02.html "Chapter 2. Creating
    Your First Lisp Program"), you learned that advanced Lispers prefer to call variables
    created with a `let` expression *lexical variables*. Now you can see why: A variable
    created in this way does not need to be local, if it is captured in a closure,
    by using the variable in a lambda expression.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第2章](ch02.html "第2章。创建你的第一个Lisp程序")中首次介绍`let`表达式时，你了解到高级Lisper更喜欢将使用`let`表达式创建的变量称为*词法变量*。现在你可以看到为什么了：以这种方式创建的变量不需要是局部的，如果它在闭包中被捕获，通过在lambda表达式中使用该变量。
- en: To understand how closures work, remember that Lisp uses garbage collection.
    In fact, it was the first language to have this feature. Garbage collection means
    that you never have to “free” variables (as you do in C programming). The Lisp
    compiler/interpreter is smart enough to know when variables are no longer in use
    and destroys them automatically.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解闭包是如何工作的，请记住Lisp使用垃圾回收。实际上，它是第一个具有此功能的语言。垃圾回收意味着你永远不需要“释放”变量（就像你在C编程中做的那样）。Lisp编译器/解释器足够智能，能够知道何时变量不再被使用，并自动销毁它们。
- en: Garbage collection will happen at some arbitrary future time after you’ve exited
    a `let` expression. Periodically, Lisp will search its memory for items that are
    no longer referenced anywhere and can therefore be safely destroyed. If Lisp notices
    that a variable defined in a `let` is no longer used by anything, it will destroy
    that variable.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在你退出一个`let`表达式之后，垃圾回收将在某个任意未来的时间发生。定期地，Lisp会搜索其内存以查找那些在任何地方都不再被引用的项目，因此可以安全地销毁它们。如果Lisp注意到在`let`中定义的变量不再被任何东西使用，它将销毁那个变量。
- en: However, if you create a lambda expression within the `let` expression (as we
    did in the previously), it’s possible for those variables to live on, being referenced
    from within the lambda expression. In that case, the garbage collector will leave
    those variables alone. Basically, you’ve created variables that are permanent—at
    least as long as the lambda expression doesn’t fall out of use and get garbage
    collected.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在`let`表达式中创建一个lambda表达式（就像我们之前做的那样），这些变量可能会继续存在，因为它们在lambda表达式中被引用。在这种情况下，垃圾回收器会留下这些变量。基本上，你已经创建了永久的变量——至少在lambda表达式不再被使用并且没有被垃圾回收之前是这样的。
- en: 'You can do a lot of cool things using closures. They’re often used for caching
    small pieces of information between uses of a function. For instance, here a function
    that remembers what line number is currently being printed:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用闭包做很多酷的事情。它们通常用于在函数使用之间缓存小块信息。例如，这里有一个记住当前正在打印的行号的函数：
- en: '[PRE41]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In order to keep track of the line number, we first create a lexical variable
    named `line-number` ![](httpatomoreillycomsourcenostarchimages783564.png). Next,
    we declare our `my-print` function using `defun` ![](httpatomoreillycomsourcenostarchimages783562.png),
    in the body of the `let`. This command will create a lambda function behind the
    scenes, therefore letting us also generate a closure.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪行号，我们首先创建一个名为 `line-number` 的词法变量 ![image](http://atomoreilly.com/source/nostarch/images/783564.png)。接下来，我们使用
    `defun` ![image](http://atomoreilly.com/source/nostarch/images/783562.png) 在 `let`
    的主体中声明我们的 `my-print` 函数。这个命令将在幕后创建一个 lambda 函数，因此也允许我们生成闭包。
- en: Within the body of the `my-print` function, we can then print the `line-number`
    ![](httpatomoreillycomsourcenostarchimages783560.png), and even mutate it using
    `incf` ![](httpatomoreillycomsourcenostarchimages783554.png). (`incf` just adds
    one to a variable.) Because the `line-number` variable is captured in the closure,
    it can “live on” between calls to `my-print`, allowing us to count line numbers.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `my-print` 函数的主体中，我们可以打印 `line-number` ![image](http://atomoreilly.com/source/nostarch/images/783560.png)，甚至使用
    `incf` ![image](http://atomoreilly.com/source/nostarch/images/783554.png) 来修改它。（`incf`
    只是将一个变量加一。）因为 `line-number` 变量被捕获在闭包中，它可以在 `my-print` 的调用之间“存活”，这样我们就可以计数行号。
- en: Memoization
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆化
- en: The first optimization we’re going to perform is called *memoization*. This
    technique makes use of closures. Memoization works only for functions written
    in the functional style. As you know, the behavior of a function in the functional
    style depends only on the arguments passed into it. Also, the only action of a
    function in the functional style is to calculate a value to return to the caller.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的第一项优化称为 *记忆化*。这项技术利用闭包。记忆化只适用于以函数式风格编写的函数。正如你所知，函数式风格的函数行为仅取决于传递给它的参数。此外，函数式风格的函数唯一的行为是计算一个值并将其返回给调用者。
- en: 'This suggests an obvious optimization: What if we remember the arguments and
    result of each call of this function? Then, if the function ever gets called again
    with the same arguments, we won’t need to recalculate the result. Instead, we
    can simply return the precalculated result.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明了一个明显的优化：如果我们记住这个函数每次调用的参数和结果会怎样？那么，如果这个函数再次以相同的参数被调用，我们就不需要重新计算结果。相反，我们可以简单地返回预先计算的结果。
- en: Several functions in Dice of Doom can benefit from memoization.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Dice of Doom 中的几个函数可以从记忆化中受益。
- en: Memoizing the neighbors Function
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化邻居函数
- en: 'Let’s start with the `neighbors` function, which lets us know which hexagons
    on the board can be attacked from a given location:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `neighbors` 函数开始，它让我们知道从给定位置可以攻击棋盘上的哪些六边形：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What `neighbors` is telling us is that if we want to attack other hexagons on
    the board from hexagon 0, we can reach only hexagon 3, 1, or 4 (based on our new
    3-by-3 board size).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighbors` 函数告诉我们，如果我们想从六边形 0 攻击棋盘上的其他六边形，我们只能到达 3、1 或 4 号六边形（基于我们新的 3x3 棋盘大小）。'
- en: 'As you may remember, the `neighbors` function needed to do all kinds of ugly
    checking for the edges of the board, since hexagons along the edges are limited
    in the hexagons they can attack. However, since the shape of the board never changes
    mid-game, these numbers never change for a given board position. This makes `neighbors`
    a perfect candidate for memoization! Here is the code that accomplishes this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，`neighbors` 函数需要做各种关于棋盘边缘的丑陋检查，因为边缘的六边形在它们可以攻击的六边形方面是有限的。然而，由于棋盘的形状在游戏中永远不会改变，这些数字对于给定的棋盘位置永远不会改变。这使得
    `neighbors` 成为记忆化的完美候选！以下是实现这一点的代码：
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s dissect this code to make sense of what’s happening. First, we save the
    old version of the `neighbors` function in a local variable named `old-neighbors`
    ![](httpatomoreillycomsourcenostarchimages783564.png). The `symbol-function` command
    simply retrieves the function bound to a symbol. Using `symbol-function` here
    allows us to retain access to the old value of `neighbors`, even if we define
    a new function with the same name, as we’ll do shortly.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析这段代码，以理解正在发生的事情。首先，我们将 `neighbors` 函数的旧版本保存在一个名为 `old-neighbors` 的局部变量中
    ![image](http://atomoreilly.com/source/nostarch/images/783564.png)。`symbol-function`
    命令简单地检索绑定到符号的函数。在这里使用 `symbol-function` 允许我们保留对 `neighbors` 旧值的访问，即使我们定义了一个具有相同名称的新函数，就像我们很快要做的那样。
- en: Next, we define a local variable `previous` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which will hold all previous arguments and results the function has ever seen.
    This can be represented as a hash table, where the arguments are the hash key
    and the results are the values.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个局部变量`previous` ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)，它将保存函数曾经见过的所有参数和结果。这可以表示为一个哈希表，其中参数是哈希键，结果是值。
- en: Now we define a new `neighbors` function that will override the old definition
    of `neighbors` ![](httpatomoreillycomsourcenostarchimages783560.png). This new
    definition will add memoization to the old version of the function. Then we look
    up the argument `pos` in the hash table and return it, if available ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we call the old definition of the function (that’s why we needed to
    create the `old-neighbors` lexical variable) and add this new argument/result
    pair to the hash table ![](httpatomoreillycomsourcenostarchimages783510.png).
    Since `setf` returns the value being set, this command will also cause this newly
    calculated result to be returned to the caller of `neighbors`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个新的`neighbors`函数，它将覆盖旧的`neighbors`定义 ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)。这个新定义将为旧版本的函数添加记忆化。然后我们在哈希表中查找参数`pos`，如果有的话就返回它
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。否则，我们调用函数的旧定义（这就是为什么我们需要创建`old-neighbors`词法变量），并将这个新的参数/结果对添加到哈希表中
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783510.png)。由于`setf`返回被设置的值，这个命令也会导致这个新计算的结果返回给`neighbors`的调用者。
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful not to declare the memoized version of the `neighbors` function more
    than once, without also redeclaring the original version of the function. Otherwise,
    the `neighbors` function will be wrapped in multiple unsightly layers of memoization,
    since there are no checks if the memoization has already been done.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不要多次声明`neighbors`函数的记忆化版本，而不重新声明函数的原始版本。否则，`neighbors`函数将被包裹在多层不美观的记忆化层中，因为没有检查记忆化是否已经完成。
- en: Memoizing the Game Tree
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化游戏树
- en: The biggest payoff by far for memoization in our program will be in the `game-tree`
    function. This makes sense, if you think about how a board game works. Very often,
    you can get the same board positions in a board game by performing the same moves
    in a slightly different order. In our naive version of the `game-tree` function,
    every different move sequence leads to a completely different branch in the game
    tree that we need to build in a totally repetitive and inefficient way.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，记忆化带来的最大收益将是`game-tree`函数。如果你考虑一下棋盘游戏的工作方式，这是有道理的。在棋盘游戏中，通过以稍微不同的顺序执行相同的移动，你经常可以得到相同的棋盘位置。在我们原始的`game-tree`函数版本中，每一个不同的移动序列都会导致游戏树中完全不同的分支，我们需要以完全重复和低效的方式构建这些分支。
- en: 'In the memoized version of the `game-tree` code, the function can say to itself,
    “Hey, I’ve seen that board position before!” and can then share branches of the
    game tree. Here is a memoized version of `game-tree` that does this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game-tree`代码的记忆化版本中，函数可以对自己说，“嘿，我以前见过这个棋盘位置！”然后可以共享游戏树的分支。下面是一个执行此操作的`game-tree`的记忆化版本：
- en: '[PRE44]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this memoization is virtually identical to the one we used for
    the `neighbors` function. The only difference is that we’re setting the hash table
    to use `equalp` instead of `eql` (the default) for the test on the key ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种记忆化几乎与`neighbors`函数中使用的记忆化完全相同。唯一的区别是我们将哈希表设置为使用`equalp`而不是默认的`eql`来进行键的测试
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)。
- en: This is because the key (that is, the arguments to `game-tree`) contains the
    game board, in the form of an array. If we change the test function to be `equalp`,
    then Lisp will check every hexagon on the board and make sure it matches before
    using a previous calculation.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为键（即`game-tree`的参数）包含游戏板，以数组的形式。如果我们把测试函数改为`equalp`，那么Lisp将检查游戏板上的每一个六边形，确保它们匹配后才会使用之前的计算。
- en: Memoizing the rate-position Function
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化`rate-position`函数
- en: 'Another function that will benefit greatly from memoization is the `rate-position`
    function. Here it is, memoized:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个将从记忆化中受益极大的函数是`rate-position`函数。这里就是它，已经记忆化了：
- en: '[PRE45]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to do something a bit special for the memoization on this function to
    work correctly, because of the `tree` argument passed into rate-position. The
    game tree is potentially huge, so we need to make sure we never compare a game
    tree object with `equal` (or a similar comparison function that is slow with large
    lists). Instead, we want to compare it with `eql`. Because of this, we handle
    the memoization of each of the two parameters to `rate-position` (`tree` and `player`)
    separately. We accomplish this by having nested hash tables.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于传递给`rate-position`的`tree`参数，我们需要对这个函数的记忆化做一些特殊处理，以确保其正确工作。游戏树可能非常大，因此我们需要确保我们永远不会使用`equal`（或类似的大型列表慢速比较函数）来比较游戏树对象。相反，我们希望使用`eql`来比较。因此，我们分别处理`rate-position`的两个参数的记忆化（`tree`和`player`）。我们通过嵌套哈希表来实现这一点。
- en: First, we create an outer hash table with the default `eql` test ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then, we define a `tab` variable that looks up one of our variables (`player`)
    in the outer hash table ![](httpatomoreillycomsourcenostarchimages783562.png),
    to retrieve an inner hash table. If `tab` is not found in the outer hash table
    ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll create a new, empty
    inner hash table, storing it in the outer hash table with the same key ![](httpatomoreillycomsourcenostarchimages783554.png).
    The rest of the function is similar to our previous examples, except that we’re
    now using our inner hash table, with the `tree` argument as a key ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个外部的哈希表，使用默认的`eql`测试![图片链接](httpatomoreillycomsourcenostarchimages783564.png)。然后，我们定义一个`tab`变量，在外部哈希表中查找我们的一个变量（`player`），以检索一个内部哈希表![图片链接](httpatomoreillycomsourcenostarchimages783562.png)。如果`tab`在外部哈希表中未找到![图片链接](httpatomoreillycomsourcenostarchimages783560.png)，我们将创建一个新的、空的内部哈希表，使用相同的键存储在外部哈希表中![图片链接](httpatomoreillycomsourcenostarchimages783554.png)。函数的其余部分与我们的前例类似，只是我们现在使用内部哈希表，以`tree`参数作为键![图片链接](httpatomoreillycomsourcenostarchimages783510.png)。
- en: This memoization will bring us a step closer to having larger, and more fun,
    boards for Dice of Doom.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种记忆化将使我们更接近拥有更大、更有趣的“末日骰子”棋盘。
- en: Note
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You use memoization for optimizing the performance of code written in the functional
    style. However, memoization code is not, in itself, written in the functional
    style. It cannot be, since it requires you to maintain and update a table of previous
    calls to the target function.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用记忆化来优化以函数式风格编写的代码的性能。然而，记忆化代码本身并不是以函数式风格编写的。它不能是，因为它要求您维护和更新目标函数先前调用的表。
- en: Tail Call Optimization
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: 'The next technique we’re going to use to optimize our functional program is
    called *tail call optimization*. To understand this concept, let’s study a simple
    function that calculates the length of a list:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的下一个优化函数式程序的技术被称为*尾调用优化*。为了理解这个概念，让我们研究一个简单的函数，该函数用于计算列表的长度：
- en: '[PRE46]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `my-length` function should be pretty easy for you to understand at this
    point. First, it checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783564.png).
    If not, it recursively calls itself against the tail of the list and adds one
    to the total, using the `1+` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    If the list is empty, the function just returns `0` ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`my-length`函数应该很容易理解。首先，它检查列表是否为空![图片链接](httpatomoreillycomsourcenostarchimages783564.png)。如果不为空，它将递归地对其列表的尾部调用自身，并使用`1+`函数将总数加一![图片链接](httpatomoreillycomsourcenostarchimages783562.png)。如果列表为空，函数仅返回`0`![图片链接](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'It turns out that this function is actually quite inefficient. We can easily
    see this by trying to use it against a really big list:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这个函数实际上相当低效。我们可以通过尝试使用它来处理一个非常大的列表来轻松地看出这一点：
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Calling this function in CLISP actually causes the program to crash! (Other
    Common Lisp compilers/interpreters may do better, depending on whether the compiler
    writers use any special tricks to anticipate this common pitfall in Lisp code.)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLISP中调用此函数实际上会导致程序崩溃！（其他Common Lisp编译器/解释器可能表现更好，这取决于编译器编写者是否使用了任何特殊技巧来预测Lisp代码中的这种常见陷阱。）
- en: This happens because of the `1+` function. It tells Lisp, “*First*, figure out
    the length of the shorter list, *then* call `1+` on the result.”
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`1+`函数。它告诉Lisp，“*首先*，找出较短列表的长度，*然后*在结果上调用`1+`。”
- en: The problem is that each time we call `my-length` recursively, Lisp must remember
    that we need to add one to the result later on, once the length of the tail of
    the list has been figured out. Since the list is 100,000 items long, it must remember
    this 99,999 times before it can perform a single addition! The CLISP interpreter
    places a reminder for all of these additions on the program stack, which eventually
    overflows, crashing the program.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于每次我们递归调用 `my-length` 时，Lisp 必须记住稍后需要将结果加一，一旦计算出列表尾部的长度。由于列表有 100,000 个项目长，它必须在执行单个加法之前记住
    99,999 次！CLISP 解释器将这些加法的提醒放在程序栈上，最终导致栈溢出，程序崩溃。
- en: 'So how do we avoid this problem? We do it by rewriting our `my-length` function
    like so:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何避免这个问题呢？我们通过如下重写我们的 `my-length` 函数来实现：
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we define a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png)
    that will act as our list-eater. This function takes an extra parameter, often
    called an `accumulator`, here shortened to `acc` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This `acc` argument keeps a running count of how many items in the list we have
    previously encountered. When we initially call the function `f`, we set `acc`
    to `0` ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个局部函数 `f` ![http://atomoreilly.com/source/nostarch/images/783564.png]，它将充当我们的列表消耗者。这个函数接受一个额外的参数，通常称为
    `accumulator`，这里简称为 `acc` ![http://atomoreilly.com/source/nostarch/images/783564.png]。这个
    `acc` 参数保持着我们之前遇到的列表中项目数量的累计计数。当我们最初调用函数 `f` 时，我们将 `acc` 设置为 `0` ![http://atomoreilly.com/source/nostarch/images/783510.png](http://atomoreilly.com/source/nostarch/images/783510.png)。
- en: By making this accumulator available, it means that when `f` calls itself recursively
    ![](httpatomoreillycomsourcenostarchimages783560.png), it now longer needs to
    add one to the result. Instead, it just adds one to the accumulator. Once we reach
    the end of the list (`lst` is `nil` ![](httpatomoreillycomsourcenostarchimages783562.png)),
    then `acc` will equal the total number of items in the list, so we can just return
    it ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使这个累加器可用，这意味着当 `f` 递归调用自身时 ![http://atomoreilly.com/source/nostarch/images/783560.png](http://atomoreilly.com/source/nostarch/images/783560.png)，它现在不再需要将一加到结果上。相反，它只需将一加到累加器上。一旦我们到达列表的末尾（`lst`
    是 `nil` ![http://atomoreilly.com/source/nostarch/images/783562.png](http://atomoreilly.com/source/nostarch/images/783562.png)），那么
    `acc` 将等于列表中的项目总数，因此我们可以直接返回它 ![http://atomoreilly.com/source/nostarch/images/783554.png](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: What is important here is that *the very last thing* the function `f` does,
    in the case where more items are on the list, is call itself recursively ![](httpatomoreillycomsourcenostarchimages783560.png).
    (The additional line in the `if` statement ![](httpatomoreillycomsourcenostarchimages783554.png)
    doesn’t count, since that part won’t be called if the expression evaluates to
    true.) When a function in Lisp calls itself (or another function) as its very
    last action, we call this action a *tail call*. A smart Lisp compiler, when seeing
    a tail call, can then say to itself, “Hey, since I don’t need to do anything more
    after calling `f` again, I can just go straight to `f`, without needing to put
    the current program context on the stack.”
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，在函数 `f` 的最后一件事情中，如果列表中还有更多项目，它将递归地调用自身 ![http://atomoreilly.com/source/nostarch/images/783560.png](http://atomoreilly.com/source/nostarch/images/783560.png)。（`if`
    语句中的附加行 ![http://atomoreilly.com/source/nostarch/images/783554.png](http://atomoreilly.com/source/nostarch/images/783554.png)
    不计入，因为如果表达式评估为真，这部分将不会被调用。）当一个函数在 Lisp 中将其自身（或另一个函数）作为其最后的行为调用时，我们称这个行为为 *尾部调用*。一个聪明的
    Lisp 编译器，在看到尾部调用时，可以对自己说，“嘿，既然我在再次调用 `f` 之后不需要做任何事情，我就可以直接跳到 `f`，而不需要将当前的程序上下文放在栈上。”
- en: This is actually similar to performing a `GOTO` in BASIC or a `longjmp` in C++.
    In all of these cases, we just “forget” where we came from, which is very fast
    and doesn’t thrash the stack. However, in the case of a tail call in Lisp, it
    is also perfectly safe. Anyone who has used `GOTO` or `longjmp` knows they’re
    anything but safe!
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上类似于在 BASIC 中执行 `GOTO` 或者在 C++ 中执行 `longjmp`。在这些所有情况下，我们只是“忘记”了我们来自哪里，这非常快，而且不会使栈碎片化。然而，在
    Lisp 中的尾部调用情况下，这也是完全安全的。任何使用过 `GOTO` 或 `longjmp` 的人都知道它们绝对不安全！
- en: Notice that there are two different definitions for `lst` that exist in the
    preceding example code. One is an argument to the `my-length` function, and the
    other is an argument to the function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The values of these two lst arguments will deviate as the program runs and `f`
    is called recursively. However, within the function `f`, the version in its own
    argument list will take precedence. This process of hiding one variable with another
    through precedence is called *variable shadowing*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面示例代码中存在两个不同的 `lst` 定义。一个是 `my-length` 函数的参数，另一个是函数 `f` 的参数 ![更多](httpatomoreillycomsourcenostarchimages783564.png)。随着程序运行和
    `f` 的递归调用，这两个 `lst` 参数的值将会不同。然而，在函数 `f` 内部，其参数列表中的版本将具有优先权。通过优先级隐藏一个变量以另一个变量称为
    *变量遮蔽*。
- en: Note
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I used variable shadowing in the `my-length` function so it would be impossible
    for me to accidentally use the “wrong list” when writing the code inside of function
    `f`. Other programmers dislike this technique, since having similarly named variables
    with different values can lead to confusion. You’ll need to decide which of these
    arguments is most convincing to you and whether you’ll use variable shadowing
    in your own code.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `my-length` 函数中使用了变量遮蔽，这样在编写函数 `f` 内部的代码时，我就不可能意外地使用“错误的列表”。其他程序员不喜欢这种技术，因为具有相似名称但值不同的变量可能会导致混淆。你需要决定哪种论点对你最有说服力，以及你将在自己的代码中使用变量遮蔽。
- en: Support for Tail Calls in Common Lisp
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Common Lisp 中的尾调用支持
- en: Unfortunately, you can’t be 100 percent sure in Common Lisp that a compiler/interpreter
    will perform tail call optimizations. It is not required by the ANSI Common Lisp
    standard. (The situation is actually different in the Scheme dialect, since Scheme
    has a strict requirement for tail call optimization.)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在 Common Lisp 中，你不能百分之百确信编译器/解释器会执行尾调用优化。ANSI Common Lisp 标准没有要求这一点。（在
    Scheme 的情况下，情况实际上不同，因为 Scheme 对尾调用优化有严格的要求。）
- en: However, most Common Lisp compilers support this feature, although CLISP requires
    some extra cajoling to make tail call optimization work for some functions, including
    our example function. The reason for this is that tail calls can actually lead
    to performance problems themselves, in some esoteric cases. Also, when we debug
    a program, it’s nice to be able to look at the full call stack; tail call optimizations
    will prevent this, since, by their nature, they will minimize the information
    available on the stack.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数 Common Lisp 编译器支持此功能，尽管 CLISP 需要一些额外的说服才能使某些函数（包括我们的示例函数）的尾调用优化工作。原因在于尾调用本身在某些神秘的情况下可能会导致性能问题。此外，当我们调试程序时，能够查看完整的调用堆栈会很好；尾调用优化将阻止这一点，因为，根据其本质，它们将最小化堆栈上的信息。
- en: 'Here’s the extra step we need to take to get CLISP to tail call optimize the
    `my-length` function:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要采取的额外步骤，以便让 CLISP 对 `my-length` 函数进行尾调用优化：
- en: '[PRE49]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Calling this function will tell CLISP to run the `my-length` function through
    its full compiler, which includes a tail code optimization step. Now we can run
    `my-length` against our jumbo-sized list!
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将告诉 CLISP 通过其完整的编译器运行 `my-length` 函数，包括尾代码优化步骤。现在我们可以用 `my-length` 对我们的巨型列表进行测试了！
- en: '[PRE50]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Tail Call Optimization in Dice of Doom
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶魔骰子的尾调用优化
- en: 'One function in our game that could definitely benefit from tail call optimization
    is the `add-new-dice` function. Here’s the fully optimized version:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中一个肯定可以从尾调用优化中受益的函数是 `add-new-dice` 函数。以下是完全优化的版本：
- en: '[PRE51]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As before, we’re performing the list-eating in a function called `f` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which also has an accumulator. However, this time the `acc` variable will contain
    a *list* of newly updated hexagons with extra dice. We can now call `f` in tail
    call positions in two places ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png),
    where we `cons` new hexagons to the `acc` variable.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在名为 `f` 的函数中进行列表消耗 ![更多](httpatomoreillycomsourcenostarchimages783564.png)，该函数也有一个累加器。然而，这次
    `acc` 变量将包含一个包含额外骰子的新六边形列表。我们现在可以在两个地方调用 `f` 以尾调用位置 ![更多](httpatomoreillycomsourcenostarchimages783560.png)
    ![更多](httpatomoreillycomsourcenostarchimages783554.png)，我们将新的六边形 `cons` 到 `acc`
    变量中。
- en: Once we’ve processed the whole list of hexagons on the board, we can just return
    `acc`. However, since we’ve consed stuff to `acc` as we went along the list, `acc`
    will actually be reversed. Therefore, we need to perform an extra call to `reverse`
    at the very end ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完棋盘上所有六边形的列表，我们就可以直接返回`acc`。然而，由于我们在遍历列表的过程中向`acc`中添加了东西，`acc`实际上会被反转。因此，我们需要在最后额外调用一次`reverse`！![更多内容](http://atomoreilly.com/source/nostarch/images/783562.png)。
- en: We have now explored some basic techniques for optimizing computer programs
    written in the functional style.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探索了一些优化函数式风格编写的计算机程序的基本技术。
- en: A Sample Game on the 3-by-3 Board
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3x3棋盘上的一个示例游戏
- en: Now let’s enjoy the fruits of our labor. The following is a full game against
    the AI player on a 3-by-3 board. As you can see, on an evenly matched starting
    board, the computer is now practically unbeatable.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们享受我们劳动的果实。以下是在3x3棋盘上与AI玩家进行的一场完整游戏。正如你所看到的，在一个势均力敌的起始棋盘上，计算机现在几乎是无敌的。
- en: '[PRE52]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What You've Learned
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你已经学到了什么
- en: 'In this chapter, we used our knowledge of functional programming to develop
    a board game with AI. Along the way you learned the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用函数式编程的知识开发了一个带有AI的棋盘游戏。在这个过程中，你学习了以下内容：
- en: Functional programming techniques allow you to write a game program with a “rule
    engine” that is separate from the rest of the code. You accomplish this by using
    *function pipelining* and building a *game tree* that is independently traversed
    by other parts of your game code as the game progresses.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程技术允许你使用一个独立的“规则引擎”来编写游戏程序，这个引擎与代码的其他部分是分开的。你通过使用*函数管道*和构建一个*游戏树*来实现这一点，该游戏树在游戏进行过程中由游戏代码的其他部分独立遍历。
- en: You can create an AI player for a two-player game using the *minimax algorithm*.
    This algorithm is based on the truism “What is good for my enemy is bad for me.”
    It allows you to efficiently rate positions in a two-player board game.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用*最小-最大算法*为两人游戏创建一个AI玩家。这个算法基于这样一个真理：“对我敌人有利的就是对我有害的。”它允许你高效地评估两人棋盘游戏中的位置。
- en: Lexical variables (which we’ve been calling *local* variables) can live on past
    the form in which they were created if they are referenced by a lambda expression.
    Capturing variables in this way is called *creating a closure*.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词汇变量（我们一直称之为*局部*变量）如果被lambda表达式引用，它们可以超出其创建的形式而存在。以这种方式捕获变量被称为*创建闭包*。
- en: Functional programs can be optimized using *memoization*, which requires you
    to cache previous results calculated by a function.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序可以使用*记忆化*进行优化，这需要你缓存函数计算出的先前结果。
- en: You can also improve functional programs by using *tail call optimizations*,
    which allow you to make sure the call stack isn’t abused. You do this by controlling
    which function appears in the tail call (final) position of your list-eater functions.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以通过使用*尾调用优化*来改进函数式程序，这可以确保调用栈不被滥用。你通过控制哪个函数出现在你的列表吞噬函数的尾调用（最终）位置来实现这一点。
- en: Chapter 16. The Magic of Lisp Macros
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。Lisp宏的魔力
- en: '*Macro programming* allows you to mess around inside your Lisp compiler/interpreter
    to turn Lisp into your own custom programming language. When faced with a difficult
    programming challenge, many experienced Lispers will first ask themselves, “What
    programming language could I use to make this problem easy to solve?” Then they’ll
    use macros to convert Lisp into *that* language!'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*宏编程*允许你在你的Lisp编译器/解释器内部捣鼓，将Lisp转换成你自己的定制编程语言。当面对一个困难的编程挑战时，许多经验丰富的Lisper会首先问自己：“我能用哪种编程语言来使这个问题容易解决？”然后他们会使用宏将Lisp转换成*那种*语言！'
- en: 'No other programming language possesses such a simple and comprehensive macro
    system. One can even argue that it would be impossible to add this feature to
    other programming languages, for a simple reason: The Lisp languages are the only
    ones in which computer code and program data are made out of the same “stuff.”
    As discussed many times in this book, the fundamental structures for storing data
    in Lisp are symbols, numbers, and lists, which are made of cons cells. Similarly,
    the code of a Lisp program is made out of these same basic building blocks. As
    you’ll see in this chapter, this symmetry between code and data in Lisp is the
    magic that makes the Lisp macro system possible.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何其他编程语言拥有如此简单而全面的宏系统。甚至可以争论说，由于一个简单的原因，将这个特性添加到其他编程语言中是不可能的：Lisp 语言是唯一一种将计算机代码和程序数据由相同的“材料”构成的。正如本书多次讨论的那样，Lisp
    中存储数据的基本结构是符号、数字和列表，它们由 cons 单元组成。同样，Lisp 程序的代码也是由这些相同的基本构建块构成的。正如您在本章中将会看到的，Lisp
    中代码与数据之间的这种对称性是使 Lisp 宏系统成为可能的关键。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781590.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781590.png)'
- en: Note
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have heard that other programming languages, such as C++, also have
    a feature called macros. For instance, in the C++ language, you would create these
    using the #define directive. However, these are not the same thing! Lisp macros
    work in an entirely different and far more sophisticated way.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能听说过其他编程语言，如 C++，也具有名为宏的功能。例如，在 C++ 语言中，您会使用 #define 指令来创建这些宏。然而，这些并不是一回事！Lisp
    宏以完全不同且更为复杂的方式工作。'
- en: A Simple Lisp Macro
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的 Lisp 宏
- en: Sometimes when you’re writing a computer program, you get a feeling of *déjà
    vu*. I’m sure you know this feeling. You’re typing away at your computer, and
    you suddenly realize, “Hey, this is the third time this week I’ve written this
    same fragment of code!”
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当您编写计算机程序时，您会感到一种 *似曾相识* 的感觉。我相信您知道这种感觉。您正在电脑上打字，突然意识到，“嘿，这已经是本周第三次写这段相同的代码了！”
- en: 'Suppose, for example, that your program needs a special `add` function:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，您的程序需要一个特殊的 `add` 函数：
- en: '[PRE53]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This function adds together two numbers and prints out the sum on the REPL
    as a side effect. You might find this function useful in a program during debugging:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将两个数字相加，并以副作用在 REPL 上打印出总和。您可能会在程序调试期间发现这个函数很有用：
- en: '[PRE54]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This `add` function seems straightforward, but its code has an annoyance: Why
    do you need so many parentheses to declare your variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png)?
    The `let` command requires so many parentheses that when you need only a single
    variable, the code ends up looking especially ludicrous.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `add` 函数看起来很简单，但它的代码有一个烦恼：为什么您需要这么多括号来声明变量 `x` ![image with no caption](httpatomoreillycomsourcenostarchimages783564.png)？`let`
    命令需要这么多括号，以至于当您只需要一个变量时，代码看起来特别荒谬。
- en: The parentheses required by `let` are an example of the kind of *visual noise*
    a programmer must deal with almost every day. However, you can’t just write a
    regular function to hide those parentheses, because the `let` command can do things
    a regular Lisp function can’t support. The `let` command is a *special form*.
    It’s a core part of the language and has special powers beyond those of a standard
    Lisp function.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 所需的括号是程序员几乎每天都必须处理的 *视觉噪音* 的一个例子。然而，您不能仅仅写一个常规函数来隐藏那些括号，因为 `let` 命令可以做一些常规
    Lisp 函数不支持的事情。`let` 命令是一个 *特殊形式*。它是语言的核心部分，并具有超出标准 Lisp 函数的特殊能力。'
- en: 'Macros let us get rid of the superfluous parentheses. Let’s create a new macro
    named `let1`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 宏让我们摆脱了多余的括号。让我们创建一个新的宏名为 `let1`：
- en: '[PRE55]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, the definition of a macro looks similar to the definition of
    a function. However, instead of using `defun`, we use `defmacro` to define it.
    Like a function, it has a name (in this case, `let1`) and arguments passed to
    it ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，宏的定义看起来与函数的定义相似。然而，我们不是使用 `defun` 来定义它，而是使用 `defmacro`。像函数一样，它有一个名称（在这种情况下，`let1`）和传递给它的参数
    ![image with no caption](httpatomoreillycomsourcenostarchimages781590.png)。
- en: 'Once we’ve defined the macro `let1`, it can be used just like `let`, except
    that it works with fewer parentheses:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了宏 `let1`，它就可以像 `let` 一样使用，只是它使用更少的括号：
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Macro Expansion
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏展开
- en: Although a macro definition looks very similar to a function definition, a macro
    is actually very different from a function. To understand why, imagine your Lisp
    is actually a cute little blob, merrily running your Lisp programs.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然宏定义看起来与函数定义非常相似，但实际上宏与函数非常不同。为了理解原因，想象一下你的Lisp实际上是一个可爱的小球，快乐地运行你的Lisp程序。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782790.png)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages782790.png)'
- en: This blob understands only standard Lisp code. If it were to see our `let1`
    command, it would have no idea what to do.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小球只理解标准的Lisp代码。如果它看到我们的`let1`命令，它将不知道该怎么办。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782218.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages782218.png)'
- en: Now imagine that we have a magic wand that transforms the appearance of our
    code *just before* Lisp gets a peek at it. In our example, it will transform `let1`
    into a regular `let`, so Lisp will stay happy.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一根魔杖，在Lisp查看代码之前，就改变了代码的外观。在我们的例子中，它将`let1`转换成常规的`let`，这样Lisp就会保持快乐。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781008.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781008.png)'
- en: This magic wand is called *macro expansion*. This is a special transformation
    that your code is put through before the core of the Lisp interpreter/compiler
    gets to see it. The job of the macro expander is to find any macros in your code
    (such as our let1 macro) and to convert them into regular Lisp code.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这根魔杖被称为*宏展开*。这是一种特殊的转换，在Lisp解释器/编译器的核心看到它之前，你的代码会经历这种转换。宏展开器的任务是找到你的代码中的任何宏（如我们的let1宏）并将它们转换成常规的Lisp代码。
- en: This means a macro is run at *a different time* than a function is run. A regular
    Lisp function runs when you execute a program that contains the function. This
    is called *runtime*. A macro, on the other hand, runs before the program does,
    when the program is read and compiled by your Lisp environment. This is called
    *macro expansion time*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着宏的运行时间与函数的运行时间不同。常规的Lisp函数在你执行包含函数的程序时运行。这被称为*运行时*。另一方面，宏在程序运行之前运行，当你的Lisp环境读取和编译程序时。这被称为*宏展开时间*。
- en: Now that we’ve discussed the basic thinking behind Lisp macros, let’s take a
    closer look at how `let1` was defined.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了Lisp宏背后的基本思想，让我们更仔细地看看`let1`是如何定义的。
- en: How Macros Are Transformed
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏是如何转换的
- en: When we define a new macro with the `defmacro` command, we’re basically teaching
    the Lisp macro expansion system a new transformation that it can use to translate
    code before running a program. The macro receives raw source code in its arguments,
    in the form of Lisp expressions. Its job is to help the macro expander transform
    this raw code into standard Lisp code that keeps the Lisp blob happy.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`defmacro`命令定义一个新的宏时，我们基本上是在教Lisp宏展开系统一个新的转换，它可以在运行程序之前使用这个转换来翻译代码。宏接收其参数中的原始源代码，形式为Lisp表达式。它的任务是帮助宏展开器将这个原始代码转换成标准的Lisp代码，这样Lisp小球就会保持快乐。
- en: 'Let’s take a closer look at how our `let1` macro gets transformed. Here is
    its definition once again:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`let1`宏是如何转换的。这是它的定义再次：
- en: '[PRE57]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first line of this `defmacro` call ![](httpatomoreillycomsourcenostarchimages783564.png)
    tells the macro expander, “Hey, if you see a form in code that begins with let1,
    here’s what you need to do to transform it into standard Lisp.” A macro defined
    with `defmacro` may also have arguments passed into it, which will contain the
    raw source code found inside the macro when the macro is used. The `let1` macro
    has three such arguments passed into it: `var`, `val`, and `body` ![](httpatomoreillycomsourcenostarchimages783564.png).
    So what do these three arguments represent?'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`defmacro`调用的第一行 ![](httpatomoreillycomsourcenostarchimages783564.png) 告诉宏展开器，“嘿，如果你在代码中看到一个以let1开头的形式，这就是你需要做的，将其转换成标准的Lisp。”使用`defmacro`定义的宏也可以传入参数，这些参数将包含在宏中使用时在宏内部找到的原始源代码。`let1`宏有三个这样的参数传入：`var`、`val`和`body`
    ![](httpatomoreillycomsourcenostarchimages783564.png)。那么这三个参数代表什么呢？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779867.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages779867.png)'
- en: 'As you can see, when we use `let1`, we’ll end up having three different expressions
    inside it, which are the arguments to the `let1` macro:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们使用`let1`时，我们最终会在其中得到三个不同的表达式，它们是`let1`宏的参数：
- en: '**`var`**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**`var`**'
- en: The first argument is the name of the variable we’re defining. This name will
    be available within our macro using the argument named `var`. In this example,
    it will equal the symbol `foo`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们定义的变量的名称。这个名称将在我们的宏中使用名为 `var` 的参数中可用。在这个例子中，它将等于符号 `foo`。
- en: '**`val`**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**`val`**'
- en: The second expression holds the code that determines the value of the variable.
    In our macro, this is the second argument, `val`. It will equal the list `(+ 2
    3)`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表达式包含确定变量值的代码。在我们的宏中，这是第二个参数 `val`。它将等于列表 `(+ 2 3)`。
- en: '**`body`**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**`body`**'
- en: The third expression inside a `let1` call is the body code, which makes use
    of the new variable that’s created (in this case, `foo`). It will be available
    in the macro through the argument named `body`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`let1` 调用中的第三个表达式是体代码，它使用了新创建的变量（在这种情况下，`foo`）。它将通过名为 `body` 的参数在宏中可用。'
- en: Since the `let` command is allowed to have multiple statements in its body,
    we will want to mirror this behavior in the `let1` macro. This is why, in the
    `defmacro` command defining let1, the final `body` argument has the special keyword
    `&body` in front of it. This tells the macro expander “Give me all remaining expressions
    in the macro in a list.” Because of this, the body argument in our `let1` example
    is actually `((* foo foo))`—a nested list. In this example, we put only a single
    statement inside `let1`.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `let` 命令允许其体中有多个语句，我们希望在 `let1` 宏中反映这种行为。这就是为什么在定义 `let1` 的 `defmacro` 命令中，最后的
    `body` 参数前面有一个特殊的键词 `&body`。这告诉宏展开器“给我宏中所有剩余的表达式列表。”正因为如此，我们的 `let1` 示例中的 `body`
    参数实际上是 `((* foo foo))`——一个嵌套列表。在这个例子中，我们只在 `let1` 中放置了一个单条语句。
- en: 'Now that you’ve seen what the values to the arguments of our `let1` macro are,
    let’s see how the macro uses this information to transform the `let1` into a standard
    `let` that the Lisp compiler can understand. The easiest way to transform source
    code in Lisp is to use backquote syntax. (If you don’t remember how to use backquotes,
    please see [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works") in [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works "How Quasiquoting
    Works").) With backquotes, we can build the code for a proper `let` command using
    code passed to `let1`. Here’s our `let1` macro again for reference:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了我们 `let1` 宏的参数值，让我们看看宏是如何使用这些信息将 `let1` 转换为 Lisp 编译器可以理解的标准的 `let` 命令的。在
    Lisp 中转换源代码的最简单方法是使用带引号语法。（如果您不记得如何使用带引号，请参阅 [How Quasiquoting Works](ch05s04.html#how_quasiquoting_works
    "How Quasiquoting Works")。) 使用带引号，我们可以使用传递给 `let1` 的代码构建正确的 `let` 命令。以下是我们的 `let1`
    宏再次供参考：
- en: '[PRE58]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the `let1` macro returns a backquoted list starting with the
    symbol `let` ![](httpatomoreillycomsourcenostarchimages783564.png), followed by
    the variable name and value, placed in a proper nested list, which Lisp’s `let`
    command requires. The commas cause the actual variable name and value to be plopped
    in at these locations. Finally, we place the `body` code from the `let1` in the
    analogous place in the `let` command ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`let1` 宏返回一个以符号 `let` 开头的带引号的列表 ![httpatomoreillycomsourcenostarchimages783564.png]，后面跟着变量名称和值，放置在一个适当的嵌套列表中，这是
    Lisp 的 `let` 命令所要求的。逗号导致实际的变量名称和值被放置在这些位置。最后，我们将 `let1` 中的 `body` 代码放置在 `let`
    命令中的类似位置 ![httpatomoreillycomsourcenostarchimages783562.png]。
- en: 'The `body` argument is inserted into the transformed code using the splicing
    comma `(,@)`. To understand why the `body` needs to be handled in this special
    way, consider the following use of our `let1` macro:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片逗号 `(,@)` 将 `body` 参数插入到转换后的代码中。要理解为什么需要以这种方式处理 `body`，请考虑以下我们 `let1` 宏的使用：
- en: '[PRE59]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this case, we’ve put more than one thing inside the body of our `let`. Remember
    that the `let` command includes an implicit `progn` command, and it can have multiple
    Lisp instructions inside. Our new `let`1 macro allows for this as well by placing
    the special `&body` marker in front of the `body` argument, causing all remaining
    syntax expressions to be passed into `let1` as a list. So, in the preceding example,
    the `body` argument contains the code `((princ "Lisp is awesome!") (* foo foo))`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 `let` 的体中放置了多个东西。记住，`let` 命令包含一个隐式的 `progn` 命令，并且可以在其中包含多个 Lisp 指令。我们新的
    `let1` 宏通过在 `body` 参数前面放置特殊的 `&body` 标记来实现这一点，导致所有剩余的语法表达式作为列表传递给 `let1`。因此，在前面的例子中，`body`
    参数包含代码 `((princ "Lisp is awesome!") (* foo foo))`。
- en: Using the Simple Macro
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简单宏
- en: 'Now that we’ve written our `let1` macro, let’s rewrite our custom `add` function
    in a cleaner way:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了 `let1` 宏，让我们以更简洁的方式重写我们的自定义 `add` 函数：
- en: '[PRE60]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Isn’t this much easier on the eyes?
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是对眼睛更友好吗？
- en: 'We can use the `macroexpand` command to see code generated by a macro. Simply
    pass the macro’s code to `macroexpand`, like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `macroexpand` 命令来查看宏生成的代码。只需将宏的代码传递给 `macroexpand`，就像这样：
- en: '[PRE61]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can now see the raw code generated by `let1` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `T` at the end ![](httpatomoreillycomsourcenostarchimages783562.png) just
    means `macroexpand` was handed a valid macro that it was able to expand.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以看到 `let1` 生成的原始代码 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。结尾的
    `T` ![图片](httpatomoreillycomsourcenostarchimages783562.png) 只意味着 `macroexpand`
    被传递了一个有效的宏，它能够展开。
- en: As your macros become more complex, you’ll find that `macroexpand` is a valuable
    tool in testing and debugging their structure.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的宏变得更加复杂时，你会发现 `macroexpand` 是测试和调试它们结构的一个非常有价值的工具。
- en: More Complex Macros
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的宏
- en: 'Let’s suppose you need a custom `my-length` command. This is a classic list-eating
    function that will count the length of a list. We’ll write it in the proper “tail
    call optimized” style (discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming")), where the recursive function call
    is in the tail position. Here’s the code:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个自定义的 `my-length` 命令。这是一个经典的列表消费者函数，它将计算列表的长度。我们将以适当的“尾调用优化”风格（在第 14 章讨论）编写它，其中递归函数调用位于尾位置。以下是代码：
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see, this function has tons of repetitive stuff, once again giving
    us that dreaded feeling of *déjà vu*. There are two repetitive patterns in this
    function:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数有很多重复的内容，又一次给我们带来了那种令人讨厌的 *déjà vu* 感觉。在这个函数中有两个重复的模式：
- en: As in other list-eater functions, we have the annoying check to see if the list
    is empty ![](httpatomoreillycomsourcenostarchimages783562.png) and the associated
    use of `cdr` ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像其他列表消费者函数一样，我们有一个讨厌的检查来查看列表是否为空 ![图片](httpatomoreillycomsourcenostarchimages783562.png)
    和相关的 `cdr` 使用 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。
- en: We did all this verbose work to create a local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们做了所有这些冗长的操作来创建一个局部函数 `f` ![图片](httpatomoreillycomsourcenostarchimages783564.png)。
- en: Let’s write some macros that make this function (and other functions with the
    same repetition) more pithy.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些使这个函数（以及具有相同重复的其他函数）更加简洁的宏。
- en: A Macro for Splitting Lists
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割列表的宏
- en: First, let’s create a `split` macro. It will let us write cleaner list-eater
    functions, such as our `my-length` function.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个 `split` 宏。它将使我们能够编写更简洁的列表消费者函数，例如我们的 `my-length` 函数。
- en: 'List-eaters always check if the list is empty. If it isn’t, they take apart
    the list using `car` and/or `cdr`, and then perform operations on the head and/or
    tail of the list. The `split` macro does this for us. Here’s what it looks like
    when we use the finished `split` macro:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 列表消费者总是检查列表是否为空。如果不是，它们会使用 `car` 和/或 `cdr` 将列表拆分开，然后对列表的头部和/或尾部执行操作。`split`
    宏为我们做了这件事。以下是使用完成的 `split` 宏时的样子：
- en: '[PRE63]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first argument of the `split` macro is a list you want to split into a head
    and a tail ![](httpatomoreillycomsourcenostarchimages783564.png). If this is possible,
    the next expression in the `split` macro will be called ![](httpatomoreillycomsourcenostarchimages783562.png).
    As a bonus, our `split` macro automatically creates two variables for us, named
    `head` and `tail`. This way, we don’t always need to call `car` and `cdr` inside
    list-eating functions. If the list is empty ![](httpatomoreillycomsourcenostarchimages783560.png),
    we call the expression at the end ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 宏的第一个参数是要拆分为头部和尾部的列表 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。如果这是可能的，`split`
    宏中的下一个表达式将被调用 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。作为额外的好处，我们的
    `split` 宏自动为我们创建了两个变量，分别命名为 `head` 和 `tail`。这样，我们就不必总是在列表消费者函数内部调用 `car` 和 `cdr`。如果列表为空
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)，我们调用最后的表达式 ![图片](httpatomoreillycomsourcenostarchimages783554.png)。'
- en: 'Let’s look at the code for the `split` macro. Note that this initial version
    of the macro contains some bugs we’ll discuss shortly:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `split` 宏的代码。注意，这个宏的初始版本包含一些我们很快就会讨论的 bug：
- en: '[PRE64]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our `split` macro requires three (and only three) expressions as arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    This means when we use this macro, we’ll always need exactly three items.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `split` 宏需要三个（而且只有三个）表达式作为参数 ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)。这意味着当我们使用这个宏时，我们总是需要恰好三个项目。
- en: The code that needs to be generated by `split` is pretty straightforward. First,
    we have an `if` that checks if the list is empty ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is, we break apart the list and stick it into our two local variables, `head`
    ![](httpatomoreillycomsourcenostarchimages783560.png) and `tail` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Then we put in the code that handles the “yes, we can split the list” case ![](httpatomoreillycomsourcenostarchimages783510.png).
    If we can’t split the list, we call the no case ![](httpatomoreillycomsourcenostarchimages783544.png).
    Note that in the no case, we don’t have access to the `head/tail` variables, since
    they aren’t created if the list can’t be split.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`split` 需要生成的代码相当简单。首先，我们有一个 `if` 语句检查列表是否为空 ![图片链接](httpatomoreillycomsourcenostarchimages783562.png)。如果是，我们将分解列表并将其放入我们的两个局部变量
    `head` ![图片链接](httpatomoreillycomsourcenostarchimages783560.png) 和 `tail` ![图片链接](httpatomoreillycomsourcenostarchimages783554.png)。然后我们放入处理“是的，我们可以分解列表”情况的代码
    ![图片链接](httpatomoreillycomsourcenostarchimages783510.png)。如果我们不能分解列表，我们调用无情况 ![图片链接](httpatomoreillycomsourcenostarchimages783544.png)。请注意，在无情况下，我们没有访问
    `head/tail` 变量，因为如果列表不能分解，它们就不会被创建。'
- en: 'With this new `split` macro, we can clean up our `my-length` macro a bit:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的 `split` 宏，我们可以稍微清理一下我们的 `my-length` 宏：
- en: '[PRE65]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice how we now make use of the `tail` variable created by `split`, simplifying
    our code ![](httpatomoreillycomsourcenostarchimages783564.png). Macros that automatically
    generate variables like this are called *anaphoric macros*.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在如何使用 `split` 创建的 `tail` 变量，简化了我们的代码 ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)。自动生成此类变量的宏被称为
    *反身宏*。
- en: However, we are not yet finished with our `split` macro. Although it basically
    works, it contains some subtle bugs that we need to address.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的 `split` 宏还没有完成。尽管它基本上是可行的，但它包含一些微妙的错误，我们需要解决。
- en: Avoiding Repeated Execution in Macros
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免宏中的重复执行
- en: 'One common bug that can happen in a macro is incorrect repeated execution of
    code. In fact, our current version of the `split` macro contains this flaw. Here
    is an example that clearly shows the problem:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 宏中可能发生的一个常见错误是不正确地重复执行代码。事实上，我们当前的 `split` 宏包含这个缺陷。以下是一个清楚地显示问题的示例：
- en: '[PRE66]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this use of `split`, the statement “Lisp rocks!” was printed three times,
    even though it appears only once in the original code. How is this possible?
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `split` 的使用中，“Lisp rocks!” 被打印了三次，尽管它在原始代码中只出现了一次。这是怎么做到的？
- en: Remember that the arguments passed into a macro consist of raw source code.
    This means the `val` argument passed into `split` contains the raw code of the
    `progn` statement ![](httpatomoreillycomsourcenostarchimages783564.png), including
    the raw code for the `princ` statement within it. Since we reference `val` three
    times inside the `split` macro, it causes the `princ` statement to be executed
    three times.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，传递给宏的参数是原始源代码。这意味着传递给 `split` 的 `val` 参数包含 `progn` 语句的原始代码 ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)，包括其中
    `princ` 语句的原始代码。由于我们在 `split` 宏内部引用 `val` 三次，这导致 `princ` 语句执行了三次。
- en: 'We can verify this by running this example through `macroexpand`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行这个示例通过 `macroexpand` 来验证这一点：
- en: '[PRE67]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, the `princ` statement appears three times ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    This causes unexpected behavior and is inefficient, since we’re repeatedly running
    the same code unnecessarily.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`princ` 语句出现了三次 ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)
    ![图片链接](httpatomoreillycomsourcenostarchimages783562.png) ![图片链接](httpatomoreillycomsourcenostarchimages783560.png)。这导致意外的行为，并且效率低下，因为我们不必要地重复运行相同的代码。
- en: 'If you give this problem some thought, the solution isn’t too hard to figure
    out. We simply need to create a local variable inside the `split` macro, like
    this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细思考这个问题，解决方案并不难找出。我们只需要在 `split` 宏内部创建一个局部变量，如下所示：
- en: '[PRE68]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that we made use of `let1` in this new version of `split`. As this shows,
    it is perfectly okay to use macros inside *other* macros.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `split` 的新版本中使用了 `let1`。正如这所示，在 *其他* 宏中使用宏是完全可行的。
- en: 'Now if we rerun our previous example, we can see that `split` behaves correctly,
    `princ`ing the statement only once:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新运行之前的示例，我们可以看到 `split` 的行为是正确的，`princ` 只打印了一次语句：
- en: '[PRE69]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Unfortunately, this new version of the `split` macro introduces *yet another*
    bug. Let’s tackle this new bug next.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个新的 `split` 宏版本引入了 *另一个* 错误。让我们接下来解决这个新错误。
- en: Avoiding Variable Capture
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免变量捕获
- en: 'To see the bug in our newest version of `split`, try running the following:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到我们 `split` 的新版本中的错误，尝试运行以下代码：
- en: '[PRE70]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Can you tell what happened? We just created a variable `x` inside the new version
    of our `split` macro! Here’s what the call to `split` looks like if we `macroexpand`
    it:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 您能告诉我发生了什么吗？我们刚刚在 `split` 宏的新版本中创建了一个变量 `x`！以下是如果我们对 `split` 进行 `macroexpand`
    时它的样子：
- en: '[PRE71]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how the expanded version of `split` contains a definition of `x` ![](httpatomoreillycomsourcenostarchimages783562.png).
    This blocks the competing definition in our troublesome example ![](httpatomoreillycomsourcenostarchimages783564.png).
    In this scenario, the `split` macro accidentally *captured* the variable `x` and
    overwrote it in an unexpected way. How can we avoid this problem?
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `split` 的展开版本包含了一个 `x` 的定义 ![http://atomoreilly.com/source/nostarch/images/783562.png]。这阻止了我们在麻烦示例中的竞争定义
    ![http://atomoreilly.com/source/nostarch/images/783564.png]。在这种情况下，`split` 宏意外地
    *捕获* 了变量 `x` 并以意想不到的方式覆盖了它。我们如何避免这个问题？
- en: 'One simple solution would be to not create a variable `x` in the macro, but
    to instead use a variable with some insane long name like `xqweopfjsadlkjgh`.
    Then we could feel pretty confident the variable used inside the macro will never
    clash with a variable inside the code that uses it. If fact, there is a Common
    Lisp function called `gensym` whose job it is to generate crazy variable names
    exactly for this purpose:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是在宏中不创建变量 `x`，而是使用一些疯狂的长名称，比如 `xqweopfjsadlkjgh`。然后我们可以相当有信心，宏内部使用的变量永远不会与使用它的代码中的变量冲突。实际上，有一个名为
    `gensym` 的 Common Lisp 函数，其任务就是生成疯狂的长变量名，正好用于这个目的：
- en: '[PRE72]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `gensym` function will create a unique variable name for you that is guaranteed
    never to clash with any other variable name in your code. You may notice that
    it also has a special prefix (`#`:) that differentiates it from other names. Common
    Lisp handles these `gensym-based` names as a special case and will stop you from
    using the name of a `gensym` variable directly.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`gensym` 函数会为您创建一个唯一的变量名，保证在您的代码中不会与其他任何变量名冲突。您可能会注意到它还有一个特殊的前缀（`#`）来区分其他名称。Common
    Lisp 将基于 `gensym` 的名称视为特殊情况，并阻止您直接使用 `gensym` 变量的名称。'
- en: 'Now let’s use the `gensym` function inside our `split` macro to protect the
    macro from causing variable capture:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `split` 宏内部使用 `gensym` 函数来保护宏，防止它导致变量捕获：
- en: '[PRE73]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the first line of our revised macro, we define a variable `g` that contains
    the `gensym` name ![](httpatomoreillycomsourcenostarchimages783564.png). It’s
    very important to notice that there is *not* a backquote at the front of this
    line. This means that this line of code is run at *macro expand time*, not *runtime*,
    and it is perfectly fine to define the variable `g` at this point. The `let1`
    on the next line, however, has a backquote in front of it ![](httpatomoreillycomsourcenostarchimages783562.png).
    This line will be run at runtime, so we don’t want to use a hardcoded variable
    in this spot. In this new version, we instead use the unique `gensym` name stored
    in `g`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修订的宏的第一行中，我们定义了一个变量 `g`，它包含 `gensym` 名称 ![http://atomoreilly.com/source/nostarch/images/783564.png]。非常重要的一点是，注意这一行前面没有反引号。这意味着这一行代码是在
    *宏展开时间* 运行的，而不是 *运行时*，在这个点上定义变量 `g` 是完全正常的。然而，下一行的 `let1` 前面有一个反引号 ![http://atomoreilly.com/source/nostarch/images/783562.png]。这一行将在运行时运行，所以我们不希望在这一点上使用硬编码的变量。在这个新版本中，我们改用存储在
    `g` 中的唯一 `gensym` 名称。
- en: 'Now every time the `split` macro is used, a unique name is generated to hold
    the internal value. We can test this by running some examples through `macroexpand`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次使用 `split` 宏时，都会生成一个唯一的名称来保存内部值。我们可以通过运行一些示例并通过 `macroexpand` 来测试这一点：
- en: '[PRE74]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Notice how a differently named local variable was created in both instances
    ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png).
    This guarantees that the variable name will not only be unique within your code,
    but will also be unique if the `split` macro is ever used multiple times in a
    nested fashion. We have now created a fully debugged version of our `split` macro.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这两种情况下都创建了一个不同名称的局部变量 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)！这保证了变量名不仅在你自己的代码中是唯一的，而且在
    `split` 宏被多次嵌套使用时也是唯一的。我们现在已经创建了一个完全调试好的 `split` 宏版本。
- en: Just because it is now bug-free does not mean that it is free of variable capture.
    Note that the macro still defines the variables `head` and `tail`. If you used
    this function in other code in which head or tail had an alternate meaning, your
    code would fail! However, in the case of `head` and `tail`, the capture is on
    purpose. In this situation, the variable capture is a *feature*, not a bug—it
    is an anaphoric macro. As we’ve discussed, this means that it makes named variables
    or functions available that we can use in the body of the macro.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然现在它没有错误，但这并不意味着它没有变量捕获的问题。请注意，宏仍然定义了变量 `head` 和 `tail`。如果你在其他代码中使用这个函数，其中
    `head` 或 `tail` 有不同的含义，你的代码就会失败！然而，在 `head` 和 `tail` 的情况下，捕获是有意的。在这种情况下，变量捕获是一个
    *特性*，而不是错误——它是一个反身宏。正如我们讨论过的，这意味着它使得我们可以在宏的主体中使用命名变量或函数。 '
- en: A Recursion Macro
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归宏
- en: 'Let’s take another look at our improved `my-length` macro:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们改进的 `my-length` 宏：
- en: '[PRE75]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As we discussed, there is an additional repetitive pattern in this code: The
    creation of a local function `f`. Let’s write another macro that gets rid of this
    additional visual noise: `recurse`. Here’s an example of the `recurse` macro in
    use:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，在这段代码中还有一个额外的重复模式：局部函数 `f` 的创建。让我们写另一个宏来消除这种额外的视觉噪音：`recurse`。下面是 `recurse`
    宏的使用示例：
- en: '[PRE76]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The first parameter into the `recurse` macro is a list of variables and their
    starting values ![](httpatomoreillycomsourcenostarchimages783564.png). In this
    case, we’re declaring only one variable (`n`) and setting its starting value to
    9\. The rest of the lines in the macro make up the body of the recursive function.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse` 宏的第一个参数是一个变量列表及其起始值 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)。在这种情况下，我们只声明了一个变量（`n`）并将其起始值设置为9。宏中的其余行构成了递归函数的主体。'
- en: The first thing we do in the body is start a fresh line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we check if `n` has reached zero yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it has, we print “lift-off!” ![](httpatomoreillycomsourcenostarchimages783554.png).
    Otherwise, we print the current number ![](httpatomoreillycomsourcenostarchimages783510.png)
    and call the function again, recursively. Like our `split` macro, the `recurse`
    macro is anaphoric. In the case of `recurse`, it makes a function named `self`
    available, which we call when we’re ready to perform a recursion ![](httpatomoreillycomsourcenostarchimages783544.png).
    We also subtract one from `n` at this point to lower the countdown number.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在主体中，我们首先开始一个新行 ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)。然后我们检查
    `n` 是否已经达到零 ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)。如果是，我们打印
    “起飞！” ![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。否则，我们打印当前的数字
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783510.png) 并再次递归地调用该函数。像我们的
    `split` 宏一样，`recurse` 宏也是反身的。在 `recurse` 的情况下，它使得一个名为 `self` 的函数可用，我们在准备执行递归时调用它
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783544.png)。此时，我们还将 `n`
    减去1，以降低倒计时数字。
- en: 'Now that we’ve seen how `recurse` should work, let’s write this `recurse` macro.
    In order to process the list of arguments and starting values, it’s useful for
    us to have a function that can group items into a list of pairs. Here is a function,
    `pairs`, that accomplishes this:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 `recurse` 应该如何工作，让我们编写这个 `recurse` 宏。为了处理参数列表和起始值，对我们来说有一个可以将项目分组为对列表的函数是有用的。下面是一个完成这个任务的函数，`pairs`：
- en: '[PRE77]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `pairs` function is a tail-call-optimized list-eater, which, ironically,
    has its own local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Shortly, we won’t need to declare such a function anymore.) It uses `split` to
    break an item off the list ![](httpatomoreillycomsourcenostarchimages783562.png).
    However, since it needs to process two items (a pair) from the list at once, we
    need to run an additional check to see if the tail is empty ![](httpatomoreillycomsourcenostarchimages783560.png).
    If there are no items in the list ![](httpatomoreillycomsourcenostarchimages783544.png)
    (or only one item left ![](httpatomoreillycomsourcenostarchimages783510.png)),
    we return our accumulated values. Otherwise, we recursively process the rest of
    the list, with a new pair of items placed into the accumulator ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs`函数是一个尾调用优化的列表消耗者，它讽刺地有自己的局部函数`f` ![http://atomoreilly.com/source/no_starch_images/783564.png]。（很快我们就不再需要声明这样的函数了。）它使用`split`从列表中分离出一个项
    ![http://atomoreilly.com/source/no_starch_images/783562.png]。然而，由于它需要一次性处理列表中的两个项（一个对），我们需要运行一个额外的检查来查看尾部是否为空
    ![http://atomoreilly.com/source/no_starch_images/783560.png]。如果没有项在列表中 ![http://atomoreilly.com/source/no_starch_images/783544.png]（或者只剩下一个项
    ![http://atomoreilly.com/source/no_starch_images/783510.png]），我们返回累积的值。否则，我们递归地处理列表的其余部分，将一对新项放入累加器
    ![http://atomoreilly.com/source/no_starch_images/783554.png]。'
- en: 'Now we’re finally ready to write the `recurse` macro:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好编写`recurse`宏了：
- en: '[PRE78]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As you can see, it simply transforms the recursion into a traditional local
    function. First, it uses our new `pairs` function to take apart the variable names
    and starting values, and puts the result into `p` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it defines a local function simply named `self`. The variable names for `self`
    are the odd-numbered items from `p` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we want `self` to be accessible, anaphorically, from inside the macro, we
    use a plain name instead of a `gensym` name for this function. At the bottom of
    the macro, we then simply call `self`, passing in all the starting values ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只是将递归转换成了传统的局部函数。首先，它使用我们新的`pairs`函数来分解变量名和起始值，并将结果放入`p` ![http://atomoreilly.com/source/no_starch_images/783564.png]。然后它定义了一个简单地命名为`self`的局部函数。`self`的变量名是`p`中的奇数项
    ![http://atomoreilly.com/source/no_starch_images/783562.png]。由于我们希望`self`在宏内部可以通过词法引用访问，我们使用一个普通的名字而不是`gensym`名字来为这个函数命名。在宏的底部，我们简单地调用`self`，传入所有起始值
    ![http://atomoreilly.com/source/no_starch_images/783560.png]。
- en: 'Now that we’ve created the `recurse` macro, let’s once again clean up our `my-length`
    function using this new language construct:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`recurse`宏，让我们再次使用这个新的语言结构来清理我们的`my-length`函数：
- en: '[PRE79]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, there is very little repetition or visual noise in this version
    of our `my-length` function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个版本的`my-length`函数中，几乎没有重复或视觉上的杂音。
- en: Now you can appreciate how helpful macros can be when trying to write clean,
    succinct code. However, a liberal use of macros will also require you to bear
    some costs that you need to be aware of. We’ll look at the potential downsides
    to macros next.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以体会到宏在尝试编写干净、简洁的代码时是多么有帮助。然而，宏的广泛使用也将要求您承担一些成本，您需要意识到这些成本。接下来，我们将探讨宏的潜在缺点。
- en: 'Macros: Dangers and Alternatives'
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏：危险与替代方案
- en: 'Macros allow us to write code that generates other code, making the Lisp languages
    a wonderful tool for metaprogramming and prototyping new language ideas. But,
    at some level, macros are just a sleight of hand: They let you trick the Lisp
    compiler/interpreter into accepting your own customized language constructs and
    treating them like standard Lisp. They are indeed a powerful tool in a programmer’s
    tool chest, but they are not as elegant as some of the other programming tools
    you’ve encountered in this book.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 宏允许我们编写生成其他代码的代码，这使得Lisp语言成为元编程和新语言想法原型设计的绝佳工具。但是，在某种程度上，宏只是一个小把戏：它们让你欺骗Lisp编译器/解释器接受你自己的定制语言结构，并将它们视为标准Lisp。它们确实是程序员工具箱中的强大工具，但它们并不像你在本书中遇到的其他一些编程工具那样优雅。
- en: The main drawback of macros is that they can make it hard for other programmers
    to understand your code. After all, if you’re creating your own language dialect,
    other programmers won’t be familiar with it. Even your future self—say, in a year
    or two—may have a hard time understanding the structure of your code if you’ve
    made heavy use of macros. Because of this, experienced Lispers will do their best
    to use alternate techniques to macro programming whenever possible. Often, a beginning
    Lisper will write a macro in situations that could be addressed in other, cleaner
    ways.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的主要缺点是它们可能会让其他程序员难以理解你的代码。毕竟，如果你正在创建自己的语言方言，其他程序员可能不熟悉它。甚至你未来的自己——比如说，一两年后——如果过度使用了宏，也可能难以理解你代码的结构。正因为如此，经验丰富的
    Lisp 程序员会尽最大努力在可能的情况下使用其他技术来代替宏编程。通常，一个初学者 Lisp 程序员会在可以用其他更干净的方式解决的问题中编写宏。
- en: 'For instance, it’s fun to see how we were able to clean up our `my-length`
    function by adding a couple of macros named `split` and `recurse`. However, in
    the previous two chapters, you learned about another tool, functional programming,
    which can also be used to clean up list-eater functions. One powerful function
    often used by functional programmers is `reduce`. It is a higher-order function
    that accepts a function and a list, and will call the function once for every
    value in the list. Here is the `my-length` function rewritten to use the powerful
    `reduce` function, rather than macros:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看到我们如何通过添加名为 `split` 和 `recurse` 的几个宏来清理我们的 `my-length` 函数，这很有趣。然而，在前两章中，你学习了另一个工具，函数式编程，它也可以用来清理列表吞噬函数。函数程序员经常使用的一个强大函数是
    `reduce`。它是一个高阶函数，接受一个函数和一个列表，并将为列表中的每个值调用该函数。以下是使用强大的 `reduce` 函数而不是宏重写的 `my-length`
    函数：
- en: '[PRE80]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see, this new version of `my-length` easily blows away our previous
    version. It is shorter, and it doesn’t rely on any of the nonstandard macros that
    we created.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个 `my-length` 的新版本轻易地超越了我们的旧版本。它更短，并且不依赖于我们创建的任何非标准宏。
- en: The first argument to `reduce` holds our *reduction function* ![](httpatomoreillycomsourcenostarchimages783564.png).
    Its job is to keep track of, and update, an accumulated value, here named `x`.
    This variable `x` will hold the current accumulated value, which in this case
    will be the length of the list so far. This means we can simply add one to `x`
    to update it to its new value ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since the reduction function will be called once for every item in the list, it
    will, in the end, generate the length of the list. (The reduction function also
    receives, as an argument, the current item in the list, here given as the variable
    `i`. However, we do not need it for calculating the list’s length.) The next item
    passed to `reduce` is the list we want to reduce ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, since the accumulated length we’re calculating should have an initial
    value of zero, we indicate this by setting the `:initial-value` keyword argument
    to zero ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 的第一个参数是我们的**归约函数** ![归约函数](httpatomoreillycomsourcenostarchimages783564.png)。它的任务是跟踪并更新一个累积值，这里命名为
    `x`。这个变量 `x` 将持有当前的累积值，在这种情况下，将是到目前为止的列表长度。这意味着我们可以简单地给 `x` 加一，将其更新到新的值 ![更新值](httpatomoreillycomsourcenostarchimages783562.png)。由于归约函数将为列表中的每个项目调用一次，它最终将生成列表的长度。（归约函数还接收一个参数，即列表中的当前项目，这里给出的是变量
    `i`。然而，我们不需要它来计算列表的长度。）传递给 `reduce` 的下一个项目是我们想要归约的列表 ![列表](httpatomoreillycomsourcenostarchimages783560.png)。最后，由于我们正在计算的累积长度应该有一个初始值为零，我们通过将
    `:initial-value` 关键字参数设置为零来表示这一点 ![初始值](httpatomoreillycomsourcenostarchimages783554.png)。'
- en: Clearly, there are other scenarios where the list-eater macros we’ve created
    in this chapter are still useful. There are many cases where the `reduce` function
    could not be so easily used. So in the end, there are still many situations where
    creating your own Lisp dialect is exactly the right solution to a problem, as
    you’ll see in the next chapter.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有其他场景，我们在这章中创建的列表吞噬宏仍然很有用。有许多情况，`reduce` 函数不能那么容易地使用。所以最终，仍然有许多情况，创建自己的
    Lisp 方言正是解决问题的正确方法，正如你将在下一章中看到的。
- en: What You've Learned
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'This chapter covered macro programming. You’ve learned the following:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了宏编程。你学到了以下内容：
- en: Macros let you write code that writes code. With macros, you can create your
    own programming language and convert it to standard Lisp just before the compiler
    can get a peek at it.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏让你可以编写编写代码的代码。有了宏，你可以在编译器能够查看它之前，创建自己的编程语言并将其转换为标准 Lisp。
- en: Macros allow you to get rid of that feeling of *déjà vu* when writing your code,
    in situations when nothing else can do so.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏可以让你在编写代码时摆脱那种*似曾相识*的感觉，在没有任何其他方法可以做到的情况下。
- en: You must be careful when writing macros so that they don’t lead to unintentional,
    repeated execution of code.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写宏时，你必须小心，以免导致代码意外地重复执行。
- en: You need to be careful to avoid unintended *variable capture* in macros. You
    can avoid this by using `gensym` names.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要小心避免在宏中发生意外的*变量捕获*。你可以通过使用 `gensym` 命名来避免这种情况。
- en: If variables created by a macro are exposed on purpose, as a feature of the
    macro, the macro is called an *anaphoric macro*.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果宏创建的变量有意暴露，作为宏的一个特性，那么这个宏被称为*反身宏*。
- en: Macro programming is a very powerful technique. However, try to use functional
    programming instead to solve a problem whenever possible. Macros should always
    be a last resort.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏编程是一个非常强大的技术。然而，尽可能尝试使用函数式编程来解决问题。宏应该始终是最后的手段。
- en: Chapter 17. Domain-Specific Languages
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章。领域特定语言
- en: One of the best reasons for using macros is to perform *domain-specific language*
    (*DSL*) programming. DSL programming is an advanced macro programming technique
    that allows us to solve difficult programming problems by drastically changing
    the structure and appearance of Lisp code to optimize it for a specialized purpose.
    Although macros are not strictly necessary for doing DSL programming, by writing
    a set of macros, you can easily create a DSL in Lisp.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宏的最好理由之一是进行*领域特定语言（DSL）*编程。DSL 编程是一种高级宏编程技术，它允许我们通过大幅改变 Lisp 代码的结构和外观来优化它以适应特定目的，从而解决困难的编程问题。尽管宏对于进行
    DSL 编程不是严格必要的，但通过编写一组宏，你可以在 Lisp 中轻松创建一个 DSL。
- en: What Is a Domain?
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是领域？
- en: According to the 2000 US Census, the average family in the United States had
    1.86 children. Since no individual family has exactly 1.86 children, it is obvious
    that no particular family is truly perfectly average. In the same way, there is
    no such thing as an average computer program. Every program is designed to solve
    a specific problem, and every area of human inquiry, or *domain*, has its own
    idiosyncratic requirements that influence programs that solve problems in the
    given area. With DSLs, we enhance the core of our programming language to take
    these domain-specific requirements into account, potentially making our resulting
    code easier to write and understand.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 2000 年的美国人口普查，美国平均家庭有 1.86 个孩子。由于没有哪个家庭的孩子数量正好是 1.86 个，因此很明显，没有哪个家庭真正完美地平均。同样，也没有所谓的平均计算机程序。每个程序都是为了解决特定的问题而设计的，每个人类探究领域，或*领域*，都有其独特的需求，这些需求会影响解决该领域问题的程序。通过
    DSL，我们增强了编程语言的核心，以考虑这些特定领域的需求，从而可能使我们的代码更容易编写和理解。
- en: 'Let’s take a look at some specific domains and create some DSLs that let us
    easily work within these domains using Lisp. In this chapter, we’ll create two
    different DSLs. First, we’ll create a DSL for writing *scalable vector graphics
    (SVG)* files. Then we’ll write a DSL for creating commands in a text adventure—we’re
    finally going to upgrade our Wizard’s Adventure Game from [Chapter 5](ch05.html
    "Chapter 5. Building a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting
    with the World: Reading and Printing in Lisp") to make it fully playable!'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些特定的领域，并创建一些领域特定语言（DSL），这样我们就可以使用 Lisp 在这些领域内轻松工作。在本章中，我们将创建两个不同的 DSL。首先，我们将创建一个用于编写*可伸缩矢量图形（SVG）*文件的
    DSL。然后我们将编写一个用于创建文本冒险游戏命令的 DSL——我们最终将把我们的巫师冒险游戏从[第 5 章](ch05.html "第 5 章。构建文本游戏引擎")和[第
    6 章](ch06.html "第 6 章。与世界交互：在 Lisp 中读取和打印")升级到完全可玩的状态！
- en: Writing SVG Files
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 SVG 文件
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780406.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780406.png)'
- en: The SVG format is a file format for drawing graphics. In this format, you specify
    objects like circles and polygons, and then pass them to a compatible computer
    program to view. Because the SVG format specifies a drawing using pure math functions
    instead of raw pixels, it is easy for a program to render an SVG image at any
    size, making images in this format easily scalable.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 格式是一种用于绘制图形的文件格式。在这个格式中，你指定像圆圈和多边形这样的对象，然后将它们传递给一个兼容的计算机程序来查看。由于 SVG 格式使用纯数学函数而不是原始像素来指定绘图，因此程序可以轻松地将
    SVG 图像渲染成任何大小，使得这种格式的图像易于缩放。
- en: The SVG format is currently receiving a lot of attention from web developers.
    All modern browsers (excluding Microsoft Internet Explorer) support SVG natively.
    Recently, Google released a set of libraries called SVG Web that adds decent support
    for SVG, even in Internet Explorer. This allows SVG to work in more than 90 percent
    of current web browsers. Finally, SVG has become a practical and efficient option
    for drawing graphics on websites.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 格式目前正受到许多网络开发者的关注。所有现代浏览器（不包括 Microsoft Internet Explorer）都原生支持 SVG。最近，Google
    发布了一套名为 SVG Web 的库，为 SVG 提供了良好的支持，甚至在 Internet Explorer 中也是如此。这使得 SVG 在超过 90%
    的当前网络浏览器中工作。最终，SVG 已经成为在网站上绘制图形的实用和高效选项。
- en: 'The SVG format is built on top of the XML format. Here is an example of what
    a complete SVG file looks like:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 格式建立在 XML 格式之上。以下是一个完整的 SVG 文件示例：
- en: '[PRE81]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Simply copy this text and place it in a file named *example.svg* (or download
    this file from [http://landoflisp.com/](http://landoflisp.com/)). Then you can
    open the file from the Firefox web browser (the Safari, Chrome, and Opera web
    browsers should also work).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地复制这段文本并将其放置在名为 *example.svg* 的文件中（或从 [http://landoflisp.com/](http://landoflisp.com/)
    下载此文件）。然后你可以从 Firefox 网络浏览器（Safari、Chrome 和 Opera 网络浏览器也应该可以）打开该文件。
- en: 'Here is what you should see, with a red and blue circle:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你应该看到的内容，有一个红色和蓝色的圆圈：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782270.png.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782270.png.jpg)'
- en: Now, let’s write some macros and functions to let us create a picture like this
    directly in Common Lisp!
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些宏和函数，让我们能够直接在 Common Lisp 中创建这样的图片！
- en: Creating XML and HTML with the tag Macro
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签宏创建 XML 和 HTML
- en: 'The XML data format (just like the HTML data format) consists primarily of
    nested tags:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: XML 数据格式（就像 HTML 数据格式一样）主要由嵌套标签组成：
- en: '[PRE82]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Every tag ![](httpatomoreillycomsourcenostarchimages783564.png) also has a
    matching closing tag ![](httpatomoreillycomsourcenostarchimages783562.png). The
    closing tag has the same name, but with a slash preceding it. Additionally, tags
    may contain attributes:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签 ![](httpatomoreillycomsourcenostarchimages783564.png) 都有一个对应的闭合标签 ![](httpatomoreillycomsourcenostarchimages783562.png)。闭合标签具有相同的名称，但前面有一个斜杠。此外，标签可能包含属性：
- en: '[PRE83]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this example, we create a tag named `mytag` that has the attribute of being
    blue and has a height of 9.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `mytag` 的标签，它具有蓝色属性和高度为 9。
- en: Writing a Macro Helper Function
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写宏辅助函数
- en: Often, when writing a macro to perform a task, you’ll find a lot of what your
    macro needs to do can be handled by a function instead. Because of this, it is
    often prudent to first write a helper function that does most of what the macro
    needs to do. Then you write the macro, keeping it as simple as possible by leveraging
    the helper function. This is what we’re going to do as we write a macro to create
    XML-style tags in Lisp.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你编写一个宏来执行一个任务时，你会发现你的宏需要做的很多工作可以通过一个函数来处理。正因为如此，通常明智的做法是首先编写一个辅助函数，它完成宏需要做的绝大部分工作。然后你编写宏，通过利用辅助函数使其尽可能简单。这就是我们在编写一个用于在
    Lisp 中创建 XML 风格标签的宏时将要做的。
- en: 'Here is our helper function, called `print-tag`, which prints a single opening
    (or closing) tag:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的辅助函数，名为 `print-tag`，它打印一个单个的开头（或闭合）标签：
- en: '[PRE84]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'First, the `print-tag` function prints an opening angle bracket ![](httpatomoreillycomsourcenostarchimages783564.png).
    Since this is only a character, we use the literal character syntax by prefixing
    the bracket with #\. Then we check the predicate `closingp` ![](httpatomoreillycomsourcenostarchimages783562.png).
    If it is true, the tag needs to have a slash in front of it to make it a closing
    tag. Then we print the name of the tag, converted to lowercase with the `string-downcase`
    function ![](httpatomoreillycomsourcenostarchimages783560.png). Next, we iterate
    through all the attributes in the `alst` of attributes ![](httpatomoreillycomsourcenostarchimages783554.png)
    and print out each attribute/value pair ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, we end by putting in a closing angle bracket ![](httpatomoreillycomsourcenostarchimages783544.png).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`print-tag`函数打印一个开方括号![图片](httpatomoreillycomsourcenostarchimages783564.png)。由于这只是一个字符，我们使用字面字符语法，通过在括号前加上#\.
    然后我们检查谓词`closingp`![图片](httpatomoreillycomsourcenostarchimages783562.png)。如果它是真的，标签前面需要有一个斜杠，使其成为一个闭合标签。然后我们打印标签的名称，使用`string-downcase`函数转换为小写![图片](httpatomoreillycomsourcenostarchimages783560.png)。接下来，我们遍历属性列表`alst`中的所有属性![图片](httpatomoreillycomsourcenostarchimages783554.png)并打印出每个属性/值对![图片](httpatomoreillycomsourcenostarchimages783510.png)。最后，我们通过添加一个闭合方括号![图片](httpatomoreillycomsourcenostarchimages783544.png)来结束。
- en: The following is an example use of the `print-tag` function. Since it is a plain
    function and not a macro, it’s easy to debug in the REPL. This is another reason
    why helper functions are a good idea when creating macros.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`print-tag`函数的示例用法。由于它是一个普通函数而不是宏，所以在REPL中调试起来很容易。这也是为什么在创建宏时使用辅助函数是一个好主意。
- en: '[PRE85]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you can see, this function does a fine job of printing an XML tag. However,
    it would be a real chore if all tags had to be created in this way. That’s why
    we’re going to write the `tag` macro next.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数很好地打印了一个XML标签。然而，如果所有标签都必须以这种方式创建，那将是一件非常繁琐的事情。这就是为什么我们将编写`tag`宏的下一个原因。
- en: Creating the tag Macro
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建标签宏Macro
- en: 'The `tag` macro we’ll create has been adopted from the macro of the same name
    in Paul Graham’s Arc Lisp dialect. It improves on the `print-tag` function in
    several crucial ways, all of which could not be remedied without having a macro:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的`tag`宏是从保罗·格雷厄姆的Arc Lisp方言中同名宏中采纳的。它在几个关键方面改进了`print-tag`函数，所有这些都无法在没有宏的情况下修复：
- en: Tags always come in pairs. However, if we want to nest tags, a function would
    not be able to print tags that surround the tags printed inside it. This is because
    it requires us to execute code before and after nested tags are evaluated. This
    is possible in a macro, but not a function.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签总是成对出现。然而，如果我们想要嵌套标签，函数将无法打印出包围其内部打印的标签的标签。这是因为它要求我们在嵌套标签评估前后执行代码。这在宏中是可能的，但在函数中则不行。
- en: Tag names and attribute names usually do not need to change in a dynamic way.
    Because of this, it’s redundant to need to prefix tag names with a single quote.
    In other words, tag names should by default be treated as if they were in data
    mode.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签名称和属性名称通常不需要以动态方式更改。正因为如此，在标签名称前加上单引号是多余的。换句话说，标签名称应该默认被视为数据模式中的内容。
- en: Unlike tag names, it’s very desirable for the values of attributes to be dynamically
    generated. Our macro will have a syntax that places the attribute values into
    code mode so we can execute Lisp code to populate these values.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与标签名称不同，属性值的动态生成是非常希望的。我们的宏将有一个语法，将属性值放入代码模式，这样我们就可以执行Lisp代码来填充这些值。
- en: 'Ideally, this is how we would like the tag macro to work, when we use it in
    the REPL:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这就是我们希望在REPL中使用标签宏的方式：
- en: '[PRE86]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Notice that the tag name and attribute list no longer need quotes in front of
    them. Additionally, it is now easy to calculate an attribute dynamically with
    Lisp code. In this case, we’re calculating that the height is 4 plus 5.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签名称和属性列表不再需要前面的引号。此外，现在使用Lisp代码动态计算属性变得容易。在这种情况下，我们计算高度是4加5。
- en: 'Here’s the macro that accomplishes this task:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成这个任务的宏：
- en: '[PRE87]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As you would expect, the macro first calls `print-tag` to generate the opening
    tag ![](httpatomoreillycomsourcenostarchimages783564.png). This is a bit tricky
    when we generate the alist of attributes for `print-tag`, since we want the values
    for the attributes to be in code mode. We accomplish this by wrapping the attributes
    using `list` ![](httpatomoreillycomsourcenostarchimages783562.png). Then we `mapcar`
    through the attributes, which we’ve paired with the `pairs` function ![](httpatomoreillycomsourcenostarchimages783554.png).
    (Remember that we created the `pairs` function toward the end of the previous
    chapter.) For each attribute pair, we generate a code fragment in the list that
    consists of cons, without a quotation mark in front of the value of the attribute,
    so that we can dynamically calculate it ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，宏首先调用`print-tag`来生成开标签 ![http://atomoreilly.com/source/nostarch/images/783564.png]。当我们为`print-tag`生成属性列表时，这有点棘手，因为我们希望属性的值处于代码模式。我们通过使用`list`来包装属性来实现这一点
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。然后我们使用`mapcar`遍历属性，这些属性与`pairs`函数配对
    ![http://atomoreilly.com/source/nostarch/images/783554.png]。（记住，我们在上一章的末尾创建了`pairs`函数。）对于每个属性对，我们在列表中生成一个代码片段，该片段由cons组成，属性值的面前没有引号，这样我们就可以动态地计算它
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。
- en: Next, we put all the code nested inside our `tag` macro, so that it is called
    after the opening tag ![](httpatomoreillycomsourcenostarchimages783510.png). Finally
    we create a closing tag ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所有嵌套在`tag`宏内部的代码放入其中，以便在开标签之后调用它 ![http://atomoreilly.com/source/nostarch/images/783510.png]。最后，我们创建一个闭标签
    ![http://atomoreilly.com/source/nostarch/images/783544.png]。
- en: 'To make more sense of how this macro handles the attribute list, let’s pass
    the output from our example to `macroexpand`:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个宏如何处理属性列表，让我们将我们的示例输出传递给`macroexpand`：
- en: '[PRE88]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Looking at the macro expansion, it should be clear how the `tag` macro builds
    the attribute list to pass to `print-tag` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and how it allows us to dynamically generate attribute values, such as the height
    attribute ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看宏展开，应该很清楚`tag`宏如何构建传递给`print-tag`的属性列表 ![http://atomoreilly.com/source/nostarch/images/783564.png]以及它如何允许我们动态生成属性值，例如高度属性
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。
- en: 'Here is another example of this macro in use, now with two inner tags:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用此宏的另一个示例，现在包含两个内部标签：
- en: '[PRE89]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice how it correctly surrounds the inner, nested tags with proper XML opening
    and closing tags. Note also that I have added line breaks and indentation to the
    output ![](httpatomoreillycomsourcenostarchimages783564.png) for clarity. The
    actual output of the `tag` function always prints on a single line, without line
    breaks or indentation.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它如何正确地使用适当的XML开闭标签包围内部嵌套标签。同时，我还添加了换行和缩进来使输出更清晰 ![http://atomoreilly.com/source/nostarch/images/783564.png]。`tag`函数的实际输出始终打印在单行上，没有换行或缩进。
- en: Using the tag Macro to Generate HTML
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`tag`宏生成HTML
- en: 'The `tag` macro can be used for generating XML *or* HTML. For instance, we
    could do the following to generate a “Hello World” HTML document:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`宏可以用于生成XML或HTML。例如，我们可以这样做来生成一个“Hello World”HTML文档：'
- en: '[PRE90]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Since HTML uses predefined tags (unlike XML, where the tags can have any name),
    we could write simple macros for specific HTML tags that make them even easier
    to write HTML in Lisp. For instance, here are some simple `html` and `body` macros:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML使用预定义的标签（与XML不同，XML的标签可以有任意名称），我们可以为特定的HTML标签编写简单的宏，使它们在Lisp中编写HTML变得更加容易。例如，这里有一些简单的`html`和`body`宏：
- en: '[PRE91]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we could write our “Hello World” HTML example even more elegantly:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更优雅地编写我们的“Hello World”HTML示例：
- en: '[PRE92]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: However, we want to use the `tag` macro to create SVG drawings instead. So let’s
    expand our DSL for the SVG domain.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望使用`tag`宏来创建SVG绘图。因此，让我们扩展我们的SVG领域DSL。
- en: Creating SVG-Specific Macros and Functions
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SVG特定宏和函数
- en: 'First, let’s write the `svg` macro, which embodies an entire SVG image. Here
    it is:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写`svg`宏，它包含整个SVG图像。如下所示：
- en: '[PRE93]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `svg` macro is built on top of the `tag` macro. SVG images, for our purposes,
    require two special attributes to be created:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`svg`宏建立在`tag`宏之上。对于我们的目的，SVG图像需要创建两个特殊属性：'
- en: The `xmlns` attribute tells the SVG viewer (in our case, the Firefox web browser)
    where it can find the proper documentation for the SVG format ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xmlns` 属性告诉 SVG 查看器（在我们的例子中，是 Firefox 网络浏览器）在哪里可以找到 SVG 格式的正确文档 ![更多](http://atomoreilly.com/source/no_starch_images/783564.png)。'
- en: The second attribute enables hyperlinks inside the picture ![](httpatomoreillycomsourcenostarchimages783562.png).
    We’ll be using this hyperlinking feature in more advanced examples, starting in
    the next chapter.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个属性允许在图片内启用超链接 ![更多](http://atomoreilly.com/source/no_starch_images/783562.png)。我们将在下一章的更高级示例中使用这个超链接功能。
- en: To draw pictures, we’ll need to manipulate colors. To keep things simple, we’re
    just going to represent colors as RGB triples stored in a list. For instance,
    the color `(255 0 0)` is bright red.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制图像，我们需要操作颜色。为了简化问题，我们将只将颜色表示为存储在列表中的 RGB 三元组。例如，颜色 `(255 0 0)` 是亮红色。
- en: 'Often, it is useful to generate lighter or darker variants of a particular
    color. The following `brightness` function does this for us:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成特定颜色的亮或暗变体很有用。下面的 `brightness` 函数为我们做到了这一点：
- en: '[PRE94]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If you pass bright red into this function and set the brightness to negative
    100, you can see that it will generate a darker red:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将亮红色传递给这个函数并将亮度设置为 -100，你可以看到它会生成一个较深的红色：
- en: '[PRE95]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, let’s create a function that sets the style of an SVG picture element:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个函数来设置 SVG 图像元素的样式：
- en: '[PRE96]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `svg-style` function accepts a color, and then sets the fill and stroke
    (outline) of a picture element ![](httpatomoreillycomsourcenostarchimages783564.png).
    By using our brightness function, we can make the outline a darker variant of
    the fill ![](httpatomoreillycomsourcenostarchimages783562.png). This way, we need
    to specify only a single color for every element in our pictures, while maintaining
    a pleasing appearance.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`svg-style` 函数接受一个颜色，然后设置图片元素的填充和描边（轮廓）![更多](http://atomoreilly.com/source/no_starch_images/783564.png)。通过使用我们的亮度函数，我们可以使轮廓成为填充的较暗变体
    ![更多](http://atomoreilly.com/source/no_starch_images/783562.png)。这样，我们只需要为图片中的每个元素指定一个颜色，同时保持令人愉悦的外观。'
- en: Now, let’s create a function to draw a circle. Since we won’t need to nest other
    SVG tags inside a circle, there is no need to write a macro for drawing circles—a
    function suffices.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数来绘制圆。由于我们不需要在圆内嵌套其他 SVG 标签，因此不需要编写绘制圆的宏——一个函数就足够了。
- en: '[PRE97]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We’ll want to set the center, radius, and color of each circle. The center needs
    to be assigned to the `cx` ![](httpatomoreillycomsourcenostarchimages783564.png)
    and `cy` ![](httpatomoreillycomsourcenostarchimages783562.png) SVG attributes
    of the circle. The radius is put in the `r` attribute ![](httpatomoreillycomsourcenostarchimages783560.png).
    We set the style of our circle with our `svg-style` function ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要设置每个圆的中心、半径和颜色。中心需要分配给圆的 `cx` ![更多](http://atomoreilly.com/source/no_starch_images/783564.png)
    和 `cy` ![更多](http://atomoreilly.com/source/no_starch_images/783562.png) SVG 属性。半径放在
    `r` 属性 ![更多](http://atomoreilly.com/source/no_starch_images/783560.png) 中。我们使用我们的
    `svg-style` 函数 ![更多](http://atomoreilly.com/source/no_starch_images/783554.png)
    设置圆的样式。
- en: 'We are now ready to draw the simple SVG picture of two circles shown earlier,
    using our new DSL! Here’s how we do it:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用我们新的 DSL 来绘制之前展示的简单 SVG 图像，这里是我们的操作方法：
- en: '[PRE98]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We now have a functional SVG DSL. Let’s add some more functionality to our DSL
    so we can appreciate the power a DSL can give to our programs.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能性的 SVG DSL。让我们给我们的 DSL 添加更多功能，以便我们能够欣赏 DSL 可以给我们的程序带来的力量。
- en: Building a More Complicated SVG Example
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建更复杂的 SVG 示例
- en: 'Let’s add a new function to our SVG DSL that makes it easy to draw an arbitrary
    polygon:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 SVG DSL 中添加一个新功能，使其能够轻松绘制任意多边形：
- en: '[PRE99]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: An SVG polygon stores all the points of the polygon in the `points` attribute
    ![](httpatomoreillycomsourcenostarchimages783564.png). We construct the list of
    points by using a `format` statement, which contains the `˜{ ˜}` control strings
    ![](httpatomoreillycomsourcenostarchimages783562.png). Remember from [Chapter 11](ch12.html
    "Chapter 11. Printing Text with the format Function") that these control strings
    let us iterate through a list inside the `format` function. In this case, we’re
    iterating through the list of points. We then flatten the list of point pairs
    using `mapcan` ![](httpatomoreillycomsourcenostarchimages783560.png), which you
    may remember is the same as using a `mapcar` followed by an `append`.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: SVG 多边形将多边形的所有点存储在 `points` 属性中 ![](httpatomoreillycomsourcenostarchimages783564.png)。我们通过使用包含
    `˜{ ˜}` 控制字符串的 `format` 语句来构建点的列表 ![](httpatomoreillycomsourcenostarchimages783562.png)。记得从第
    11 章（[Chapter 11](ch12.html "Chapter 11. Printing Text with the format Function")）中，这些控制字符串允许我们在
    `format` 函数内部迭代列表。在这种情况下，我们正在迭代点的列表。然后我们使用 `mapcan` ![](httpatomoreillycomsourcenostarchimages783560.png)，你可能记得这与使用
    `mapcar` 后跟 `append` 相同，来展平点对的列表。
- en: 'In this example, we’re going to draw some random walks. A *random walk* is
    a graph of what you would get if you decide, at each moment in time, to flip a
    coin and then move either up or down a step. Random walks are very similar in
    behavior to stocks in the stock market. They are often used as a starting point
    for financial modeling. Here is a function that generates a random walk:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将绘制一些随机游走。随机游走是一种图表，如果你在每个时间点决定抛硬币，然后向上或向下移动一步，你将得到的结果。随机游走的行为与股市中的股票非常相似。它们通常被用作金融建模的起点。以下是一个生成随机游走的函数：
- en: '[PRE100]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function builds a list of numbers, starting with the `value` parameter.
    Then it increases or decreases this value randomly. We choose which direction
    to move using the `random` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    (Note that, in order to keep it simple, this function isn’t tail call optimized,
    since the `cons` happens after the recursive call.)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从 `value` 参数开始构建一个数字列表。然后它随机增加或减少此值。我们使用 `random` 函数 ![](httpatomoreillycomsourcenostarchimages783564.png)
    来选择移动的方向。（注意，为了保持简单，此函数没有进行尾调用优化，因为 `cons` 发生在递归调用之后。）
- en: 'Here’s an example of how we can use the `random-walk` function:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用 `random-walk` 函数的一个示例：
- en: '[PRE101]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now let’s use our SVG DSL to draw a slew of random walks in a picture:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用我们的 SVG DSL 来绘制一系列随机游走图片：
- en: '[PRE102]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Since the amount of data created in this example is quite huge, we’re dumping
    the data straight to a file (named *random_walk.svg*), instead of printing it
    to the REPL. We do this by redirecting the `*standard-output*` dynamic variable
    ![](httpatomoreillycomsourcenostarchimages783564.png), a technique introduced
    in [Chapter 12](ch13.html "Chapter 12. Working with Streams"). Notice how we can
    mix Lisp code freely with our DSL commands. For instance, we can loop right inside
    the SVG macro to generate 10 polygons at once ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本例中创建的数据量相当巨大，我们将数据直接输出到文件（命名为 *random_walk.svg*），而不是打印到 REPL。我们通过重定向 `*standard-output*`
    动态变量 ![](httpatomoreillycomsourcenostarchimages783564.png)，这是一种在第 12 章（[Chapter 12](ch13.html
    "Chapter 12. Working with Streams")）中介绍的技术。注意我们如何可以自由地混合 Lisp 代码和我们的 DSL 命令。例如，我们可以在
    SVG 宏内部直接循环以一次性生成 10 个多边形 ![](httpatomoreillycomsourcenostarchimages783562.png)。
- en: 'To make the graph pretty, we’re going to fill in the area under each graph
    line with a color. To do this, we’ll represent each line using a polygon, with
    the base line along the bottom of the graph (with a y-coordinate of 200) included
    as points to close the shape:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图表更美观，我们将用颜色填充每条图表线下的区域。为此，我们将每条线表示为一个多边形，底边沿着图表的底部（y 坐标为 200）包括作为点来闭合形状：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781225.png)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781225.png)'
- en: This is why we add points for the bottom-left ![](httpatomoreillycomsourcenostarchimages783560.png)
    and bottom-right ![](httpatomoreillycomsourcenostarchimages783554.png) corner
    as we create each polygon. For even more fun, we also randomize the color of each
    graph line ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们在创建每个多边形时，会添加左下角 ![](httpatomoreillycomsourcenostarchimages783560.png)
    和右下角 ![](httpatomoreillycomsourcenostarchimages783554.png) 的点。为了增加更多乐趣，我们还随机化了每条图表线的颜色
    ![](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'Here is an example of some random graphs generated by this very simple DSL
    code:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用这个非常简单的 DSL 代码生成的随机图表的示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779828.png.jpg)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779828.png.jpg)'
- en: 'Now that you’ve seen how easily you can write XML, HTML, and SVG DSLs in Lisp,
    let’s create an entirely different kind of DSL—one that will let us build custom
    game commands for our Wizard’s Adventure Game from [Chapter 5](ch05.html "Chapter 5. Building
    a Text Game Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the
    World: Reading and Printing in Lisp")!'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经看到在Lisp中编写XML、HTML和SVG DSL是多么容易，让我们创建一种完全不同的DSL——一种将允许我们为第5章（[第5章. 构建文本游戏引擎](ch05.html
    "Chapter 5. Building a Text Game Engine")）和第6章（[第6章. 与世界交互：在Lisp中读取和打印](ch06.html
    "Chapter 6. Interacting with the World: Reading and Printing in Lisp")）中的巫师冒险游戏构建自定义游戏命令的DSL！'
- en: Creating Custom Game Commands for Wizard's Adventure Game
  id: totrans-673
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为巫师冒险游戏创建自定义游戏命令
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783098.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783098.png)'
- en: 'If you remember, when we last encountered the game starring our wizard and
    apprentice in [Chapter 5](ch05.html "Chapter 5. Building a Text Game Engine")
    and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and
    Printing in Lisp"), we could walk around the world and pick up objects. However,
    we couldn’t really perform any other interesting or fun actions. To make a game
    fun, it should include special actions that can be performed with certain objects
    and/or at certain locations in the game. We need frogs that can be kissed, dragons
    that can be fought, and perhaps even maidens that can be rescued!'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你记得，当我们上次在[第5章](ch05.html "Chapter 5. Building a Text Game Engine")和[第6章](ch06.html
    "Chapter 6. Interacting with the World: Reading and Printing in Lisp")中遇到以我们的巫师和学徒为主角的游戏时，我们可以在世界中四处走动并捡起物品。然而，我们实际上无法执行任何其他有趣或有趣味的动作。为了让游戏变得有趣，它应该包括可以在游戏中的特定对象和/或位置执行的特殊动作。我们需要可以亲吻的青蛙、可以战斗的龙，甚至可能还有可以救出的少女！'
- en: Creating these kinds of interesting activities in the game poses a unique challenge.
    On the one hand, there are clearly many similarities between such different game
    actions. For instance, most of them will require us to have an object in our possession.
    On the other hand, they all need to have *unique and idiosyncratic properties*
    (enabled through command-specific Lisp code) or the game becomes boring. As you’ll
    see, a DSL can help you add many such unique commands to your game.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中创建这些有趣的活动提出了独特的挑战。一方面，这类不同的游戏动作之间显然有许多相似之处。例如，大多数动作将需要我们拥有一个对象。另一方面，它们都需要具有*独特和个性化的属性*（通过特定命令的Lisp代码实现）或者游戏会变得无聊。正如你将看到的，一个DSL可以帮助你向你的游戏添加许多这样的独特命令。
- en: 'To run the code from here until the end of this chapter, we’re going to use
    all the game code from [Chapter 5](ch05.html "Chapter 5. Building a Text Game
    Engine") and [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading
    and Printing in Lisp"). Just put the code from those chapters into a file named
    *wizards_game.lisp* (or download *wizards_game.lisp* from [http://landoflisp.com/](http://landoflisp.com/)).
    As soon as the game is loaded, you can type game commands like look directly in
    the CLISP REPL. Alternatively, you can use the `game-repl` command we created
    in [Chapter 6](ch06.html "Chapter 6. Interacting with the World: Reading and Printing
    in Lisp") to get a more polished game experience. Remember that the `quit` command
    will take you out of the game REPL.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '要从这里运行代码到本章结束，我们将使用[第5章](ch05.html "Chapter 5. Building a Text Game Engine")和[第6章](ch06.html
    "Chapter 6. Interacting with the World: Reading and Printing in Lisp")中的所有游戏代码。只需将这些章节中的代码放入名为*wizards_game.lisp*的文件中（或从[http://landoflisp.com/](http://landoflisp.com/)下载*wizards_game.lisp*）。游戏加载后，你可以在CLISP
    REPL中直接输入游戏命令，如look。或者，你可以使用我们在[第6章](ch06.html "Chapter 6. Interacting with the
    World: Reading and Printing in Lisp")中创建的`game-repl`命令来获得更精致的游戏体验。记住，`quit`命令将带你退出游戏REPL。'
- en: 'Here’s what you do to load the game code from the REPL and start running game
    commands:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何从REPL加载游戏代码并开始运行游戏命令的步骤：
- en: '[PRE103]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Creating New Game Commands by Hand
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建新的游戏命令
- en: So what should our game DSL look like? The only way to really know is to first
    create some commands by hand. Then we can see if there are any common patterns
    between different commands that we can use as the basis of our DSL.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的游戏领域特定语言（DSL）应该是什么样子呢？真正了解的唯一方法就是首先手动创建一些命令。然后我们可以看看不同命令之间是否存在任何共同模式，这些模式可以作为我们DSL的基础。
- en: A Command for Welding
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 焊接命令
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781998.png.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781998.png.jpg)'
- en: 'In the attic of the wizard’s house is a welding machine. Let’s allow the players
    to weld the chain to the bucket if they bring those items to that location. Here’s
    the code to make this happen:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在巫师房子的阁楼里有一台焊接机。让我们允许玩家如果带着这些物品到那个地点，就可以将链条焊接在桶上。以下是实现这一功能的代码：
- en: '[PRE104]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: First, we need an easy way of checking whether the player is currently carrying
    an object, using the `have` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    Remember that we created a command for checking what the player is carrying, named
    `inventory`. If an object is a member of the inventory, it means the player must
    “have” that object.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种简单的方法来检查玩家是否正在携带一个物品，使用 `have` 函数 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。记住，我们创建了一个名为
    `inventory` 的命令来检查玩家携带的物品。如果一个物品是存货列表的成员，这意味着玩家必须“拥有”那个物品。
- en: Next, our program needs some way of keeping track of whether or not the chain
    and bucket are welded together, since there will be actions later in the game
    that are possible only once this welding has happened. For this purpose, we create
    a global, dynamic variable named `*chain-welded*` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的程序需要一种方法来跟踪链条和桶是否已经焊接在一起，因为游戏后期会有一些只有在焊接发生后才能执行的动作。为此，我们创建了一个名为 `*chain-welded*`
    的全局动态变量 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: 'Finally, we need to create the welding command itself ![](httpatomoreillycomsourcenostarchimages783560.png).
    Welding is possible only if a slew of conditions are met ![](httpatomoreillycomsourcenostarchimages783554.png):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建焊接命令本身 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。只有在满足一系列条件的情况下才能进行焊接
    ![图片](httpatomoreillycomsourcenostarchimages783554.png)：
- en: You must be in the attic.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须身处阁楼。
- en: You must have `chain` and `bucket` as the subject and object of the welding
    command.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须将 `chain` 和 `bucket` 作为焊接命令的主题和宾语。
- en: You must be carrying the chain and bucket with you.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须随身携带链条和桶。
- en: The chain and bucket can’t already be welded together.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链条和桶不能已经焊接在一起。
- en: If these conditions are met, we set our `*chain-welded*` variable to `true`
    ![](httpatomoreillycomsourcenostarchimages783510.png) and print a message indicating
    this success. If any of the conditions fail, we indicate that the welding was
    unsuccessful ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件得到满足，我们将我们的 `*chain-welded*` 变量设置为 `true` ![图片](httpatomoreillycomsourcenostarchimages783510.png)
    并打印一条表示成功的消息。如果任何条件失败，我们将表明焊接未成功 ![图片](httpatomoreillycomsourcenostarchimages783544.png)。
- en: 'Let’s try the command in the CLISP REPL:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 CLISP REPL 中尝试这个命令：
- en: '[PRE105]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Well, that’s exactly the right response. After all, we’re not in the attic,
    and we aren’t carrying the right objects. So far, so good.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这正是正确的回答。毕竟，我们不在阁楼里，也没有携带正确的物品。到目前为止，一切顺利。
- en: 'Next, let’s try our new command in our fancy `game-repl`:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的花哨的 `game-repl` 中尝试我们的新命令：
- en: '[PRE106]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'What? Why doesn’t it “know” that command? The answer is simple: Our `game-re`pl
    has some basic protections against running unauthorized commands. To remedy this,
    we need to add `weld` to our list of permitted commands:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？为什么它“不知道”那个命令？答案是简单的：我们的 `game-repl` 有一些基本的保护措施来防止运行未经授权的命令。为了解决这个问题，我们需要将
    `weld` 添加到我们允许的命令列表中：
- en: '[PRE107]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: By using the `pushnew` command, the `weld` function is added only to the allowed
    commands if it wasn’t already present in that list. Problem solved!
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `pushnew` 命令，只有在 `weld` 函数尚未出现在该列表中时，才会将其添加到允许的命令中。问题解决！
- en: A Command for Dunking
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个浸没命令
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780712.png.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780712.png.jpg)'
- en: 'In the wizard’s garden, there is a well. Let’s create a command that lets the
    player dunk the bucket in the well to fill it with water:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在巫师的花园里有一口井。让我们创建一个命令，让玩家可以将桶浸入井中，以装满水：
- en: '[PRE108]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: As with our `weld` command, we first need a variable to keep track of whether
    the bucket has been filled yet ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we need a `dunk` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Notice how, with dunking, we once again have a long list of conditions that need
    to be met before we can successfully complete the action ![](httpatomoreillycomsourcenostarchimages783560.png).
    Some of these are similar to those we needed for our welding command. For instance,
    dunking also requires the player to be in a specific location with the correct
    object. Other conditions are dunking-specific, such as the fact that the player
    needs to have a welded chain before being able to dunk. Finally, we need to push
    the `dunk` function onto our list of allowed actions ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 `weld` 命令一样，我们首先需要一个变量来跟踪水桶是否已经被填满 ![httpatomoreillycomsourcenostarchimages783564.png]。接下来，我们需要一个
    `dunk` 函数 ![httpatomoreillycomsourcenostarchimages783562.png]。注意，在浸没过程中，我们再次需要满足一系列条件才能成功完成动作
    ![httpatomoreillycomsourcenostarchimages783560.png]。其中一些与我们的焊接命令所需的条件相似。例如，浸没也需要玩家在特定位置拥有正确的对象。其他条件是浸没特有的，例如，玩家在能够浸没之前需要有一个焊接好的链条。最后，我们需要将
    `dunk` 函数推送到允许的动作列表中 ![httpatomoreillycomsourcenostarchimages783554.png]。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780228.png)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages780228.png)'
- en: The game-action Macro
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏动作宏
- en: Now that we’ve created two custom game actions for our game, it’s obvious that
    the `weld` and `dunk` commands are very similar in some ways. However, as in our
    SVG library, each game command needs to contain a certain amount of dynamic logic
    in it, to customize the behavior of the command. Let’s write a `game-action` macro
    that addresses these issues. It will make it much easier to create new game commands.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的游戏创建了两个自定义游戏动作，很明显，`weld` 和 `dunk` 命令在某些方面非常相似。然而，正如我们的 SVG 库一样，每个游戏命令都需要包含一定量的动态逻辑，以自定义命令的行为。让我们编写一个
    `game-action` 宏来处理这些问题。这将使创建新的游戏命令变得容易得多。
- en: '[PRE109]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This `game-action` macro embodies the common pattern between our `dunk` and
    `weld` commands. The parameters to `game-action` are the name of the command,
    the two objects involved in the action, the place it needs to occur, and some
    arbitrary additional code in the `body` parameter that lets us add custom logic
    to the command ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `game-action` 宏体现了我们的 `dunk` 和 `weld` 命令之间的共同模式。`game-action` 的参数是命令的名称、参与动作的两个对象、需要发生的地方，以及
    `body` 参数中的任意附加代码，这允许我们向命令添加自定义逻辑 ![httpatomoreillycomsourcenostarchimages783564.png]。
- en: The main job of the `game-action` macro is to define a new function for a command
    ![](httpatomoreillycomsourcenostarchimages783562.png). It may be surprising to
    you that a macro can do something as powerful as define a new function on its
    own, but there is nothing to stop it from doing this. I hope this example shows
    you just how flexible and mind-bending the Common Lisp macro system can be.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-action` 宏的主要任务是定义一个新函数来处理命令 ![httpatomoreillycomsourcenostarchimages783562.png]。你可能觉得宏能够独立定义一个新函数是非常强大的，但没有任何东西可以阻止它这样做。我希望这个例子能让你看到
    Common Lisp 宏系统是多么灵活和令人费解。'
- en: Since all game actions for this game require the location, subject, and object,
    we can take care of some of the conditions directly within this macro ![](httpatomoreillycomsourcenostarchimages783560.png).
    However, we’re going to leave other conditions open for each specific command.
    Notice, for example, that the subject of the game sentence needs to be owned by
    the player ![](httpatomoreillycomsourcenostarchimages783554.png), but the object
    does not. This makes sense, since there are many actions that can be performed,
    such as “throw rock dragon,” where the object of the sentence (dragon) does *not*
    need to be in the player’s inventory.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个游戏的所有游戏动作都需要位置、主题和对象，我们可以在宏内部直接处理一些条件 ![httpatomoreillycomsourcenostarchimages783560.png]。然而，我们将为每个特定命令留出其他条件。注意，例如，游戏句子的主题需要由玩家拥有
    ![httpatomoreillycomsourcenostarchimages783554.png]，但对象则不需要。这很有道理，因为有许多可以执行的动作，例如“扔石头龙”，其中句子的对象（龙）不需要在玩家的库存中。
- en: Once the basic macro-level conditions have been met, we will defer the rest
    of the logic to the level of the individual command ![](httpatomoreillycomsourcenostarchimages783510.png).
    If the conditions were *not* met, we print an error message, customized with the
    name of the current command ![](httpatomoreillycomsourcenostarchimages783544.png).
    Finally, we `pushnew` the command into the list of allowed commands for our fancy
    `game-repl` ![](httpatomoreillycomsourcenostarchimages783566.png).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦满足了基本的宏级条件，我们将把其余的逻辑推迟到单个命令的级别！![图片](httpatomoreillycomsourcenostarchimages783510.png)。如果条件没有满足，我们将打印一个错误消息，该消息根据当前命令进行了定制！![图片](httpatomoreillycomsourcenostarchimages783544.png)。最后，我们将命令
    `pushnew` 到允许的命令列表中，用于我们的花哨的 `game-repl`！![图片](httpatomoreillycomsourcenostarchimages783566.png)。
- en: One thing we do *not* do in this macro is define or set any global variables.
    If a game command needs to define a `*chain-welded*` or `*bucket-filled*` global
    variable, it must do this itself. This makes sense, since there is clearly no
    guarantee that there will be a one-to-one relationship between state variables
    for our game and particular commands. For instance, some commands may be permitted
    multiple times, making the state unnecessary. Or an action may depend on multiple
    state variables. Having this kind of variation in the commands is what makes them
    unique and fun.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个宏中，我们不做的一件事是定义或设置任何全局变量。如果游戏命令需要定义 `*chain-welded*` 或 `*bucket-filled*` 全局变量，它必须自己完成。这很有道理，因为很明显，我们的游戏的状态变量和特定命令之间不可能存在一对一的关系。例如，某些命令可能被允许多次执行，使得状态变得不必要。或者一个动作可能依赖于多个状态变量。这种命令的多样性使得它们独特且有趣。
- en: 'With this macro, we now have a simple DSL for creating new game actions! Essentially,
    this command gives us our own programming language, specialized for the domain
    of creating game commands. Let’s rewrite our previous `weld` and `dunk` commands
    using our new game command programming language:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个宏，我们现在有一个简单的领域特定语言（DSL）来创建新的游戏动作！本质上，这个命令给我们提供了一个自己的编程语言，专门用于创建游戏命令的领域。让我们用我们新的游戏命令编程语言重写之前的
    `weld` 和 `dunk` 命令：
- en: '[PRE110]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you can see, these commands have become much easier on the eyes. Notice how
    `weld` checks for ownership of the bucket, whereas `dunk` does not need to check
    for ownership of the well.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些命令现在看起来更容易阅读。注意 `weld` 命令是如何检查桶的所有权的，而 `dunk` 命令则不需要检查井的所有权。
- en: 'To further illustrate the value of using macros to implement our game command
    DSL, let’s implement a more complicated game command, `splash`:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明使用宏来实现我们的游戏命令 DSL 的价值，让我们实现一个更复杂的游戏命令，`splash`：
- en: '[PRE111]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'For this command, there are three distinct scenarios that might happen:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个命令，可能有三种不同的场景会发生：
- en: The bucket is empty.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶是空的。
- en: Your bucket is full, but you stole the frog. In that case, you lose.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的桶满了，但你偷了青蛙。在这种情况下，你输了。
- en: Your bucket is full and you didn’t steal the frog. You win!
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的桶满了，但你没有偷青蛙。你赢了！
- en: With our `game-action` macro, we can support many action commands, each with
    special idiosyncratic behavior. Still, we are able to avoid unnecessary repetition.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `game-action` 宏，我们可以支持许多动作命令，每个命令都有特殊的行为。尽管如此，我们仍然能够避免不必要的重复。
- en: Note
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `game-action` command exposes the `subject` and `object` variables within
    the body of the macro. This allows game commands to access this information, but
    it might also cause a name collision if the code that creates the `game-action`
    commands also has variables named `subject` and `object`. As an exercise, try
    modifying the `game-action` macro so that the `subject` and `object` variables
    are replaced by `gensym` names, as discussed in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-action` 命令在宏的体内部暴露了 `subject` 和 `object` 变量。这允许游戏命令访问这些信息，但如果有创建 `game-action`
    命令的代码也使用了名为 `subject` 和 `object` 的变量，则可能会引起名称冲突。作为一个练习，尝试修改 `game-action` 宏，使
    `subject` 和 `object` 变量被 `gensym` 名称替换，如第 [16 章](ch18.html "第 16 章。Lisp 宏的魔力")
    中所述。'
- en: Let's Try the Completed Wizard's Adventure Game!
  id: totrans-728
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们尝试完成巫师冒险游戏！
- en: Here is a sample run through of the Wizard’s Adventure Game that shows off some
    of the rich functionality we’ve put into this game. Play the game yourself and
    see if you can win the magic donut!
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是巫师冒险游戏的一个示例运行，展示了我们在这个游戏中加入的一些丰富功能。自己玩一玩，看看你是否能赢得魔法甜甜圈！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780868.png.jpg)'
  id: totrans-730
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780868.png.jpg)'
- en: '[PRE112]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: What You've Learned
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'This chapter demonstrated how to create DSLs in Lisp. You learned the following:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何在Lisp中创建DSLs。你学习了以下内容：
- en: When you need to do some weird programming for a very specific domain, Macros
    are a great solution. With them, you can create your own DSL.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要为非常具体的领域进行一些奇怪的编程时，宏是一个很好的解决方案。有了它们，你可以创建自己的DSL。
- en: Often, it makes sense to first write a helper function for a macro (like `print-tag`),
    and then write a macro (like `tag`) to add improvements that only a macro can
    provide. These improvements usually involve being able to access the code with
    a clearer, and often safer, syntax.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，为宏（如`print-tag`）编写一个辅助函数是有意义的，然后编写一个宏（如`tag`）来添加只有宏才能提供的改进。这些改进通常涉及能够以更清晰、通常更安全的语法访问代码。
- en: You can mix DSLs with regular Lisp code, which gives you a lot of power.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将领域特定语言（DSLs）与常规Lisp代码混合，这给了你很多力量。
- en: DSLs are useful when you need to write very specific code—whether it’s code
    for a web page, code that draws a picture, or code that builds special game commands.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要编写非常具体的代码时，DSLs非常有用——无论是网页代码、绘图代码还是构建特殊游戏命令的代码。
- en: Chapter 18. Lazy Programming
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。懒编程
- en: In [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional
    Programming"), you learned that your programs can be simpler and cleaner when
    built with clean, math-like functions. These functions always return the same
    result, which depends solely on the arguments passed into them. When you rely
    only on these types of functions, you are using the *functional programming style*.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch16.html "第14章。使用函数式编程提升Lisp的层次")中，你了解到当使用干净、类似数学的函数构建程序时，你的程序可以更简单、更干净。这些函数总是返回相同的结果，这完全取决于传入它们的参数。当你只依赖这些类型的函数时，你就是在使用*函数式编程风格*。
- en: 'However, when we used the functional programming style to create the Dice of
    Doom game in [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written
    in the Functional Style"), a problem became evident: If your functions rely entirely
    on the arguments passed into them, the stuff that you need to pass into them often
    becomes *huge*.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们使用函数式编程风格在[第15章](ch17.html "第15章。使用函数式风格编写的Dice of Doom游戏")创建Dice of Doom游戏时，一个问题变得明显：如果你的函数完全依赖于传入它们的参数，你需要传入的东西通常会变得*非常大*。
- en: In the Dice of Doom game, we pass around the `game-tree` variable, which holds
    all the possible future states of the game board. This is a truly massive structure,
    even on a measly 3-by-3 board! So while the game’s current design makes our code
    very simple and elegant, it doesn’t appear to scale well to larger game boards,
    which would have exponentially larger game trees. The only way we could conceivably
    maintain our elegant code while allowing more complex games on larger boards is
    to make our program smart enough not to look at every conceivable move right from
    the start of the game. Is this possible? Yes, it is possible, using a feature
    called *lazy evaluation*. In this chapter, we’ll employ lazy evaluation to create
    an improved version of Dice of Doom.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dice of Doom游戏中，我们传递`game-tree`变量，它包含游戏棋盘所有可能未来的状态。这是一个真正的巨大结构，即使在可怜的3x3棋盘上也是如此！因此，虽然游戏当前的设计使我们的代码非常简单和优雅，但它似乎不太适合更大的游戏棋盘，这会导致指数级更大的游戏树。我们唯一可能保持优雅代码的同时，允许在更大的棋盘上进行更复杂的游戏的方法是，使我们的程序足够智能，从游戏开始时就不查看每一个可能的走法。这是可能的吗？是的，是可能的，使用一个叫做*懒加载评估*的功能。在本章中，我们将使用懒加载评估来创建Dice
    of Doom的改进版本。
- en: Adding Lazy Evaluation to Lisp
  id: totrans-742
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将懒加载评估添加到Lisp
- en: 'With lazy evaluation, we can still create our entire game tree in a single
    place in our code—at the beginning of our game. However, we use some clever tricks
    so that some branches of our game tree are hidden in clouds:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 使用懒加载评估，我们仍然可以在代码的一个地方创建整个游戏树——在游戏开始时。然而，我们使用一些巧妙的技巧，使得游戏树的一些分支隐藏在云中：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782958.png.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782958.png.jpg)'
- en: The branches of the game tree are still declared right from the start. However,
    we don’t bother doing all the actual calculations for the branches in clouds,
    as we would do when we create a “real” branch. This is the *lazy* part of lazy
    evaluation.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏树分支从一开始就被声明了。然而，我们并不麻烦去计算云分支的实际值，就像我们创建一个“真实”分支时那样。这是懒加载评估的*懒*部分。
- en: 'Instead, we wait to see if anyone “looks” at a cloudy branch. The moment this
    happens, POOF!, we create a real branch of our game tree at that spot:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们等待看是否有人“查看”一个云分支。一旦发生这种情况，POOF！，我们在游戏树的那个位置创建一个真实的分支：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781540.png)'
  id: totrans-747
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781540.png)'
- en: This means that these branches in the game tree are created only if some part
    of the code happens to look at them. If the player never chooses a particular
    move in the game, and the AI never decides to contemplate it, our program will
    lazily avoid the calculations needed to figure out what the given branch actually
    looks like.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只有当代码的某个部分偶然查看这些分支时，这些游戏树中的分支才会被创建。如果玩家从未选择过特定的移动，并且AI从未决定考虑它，我们的程序将懒地避免进行计算，以确定给定分支的实际样子。
- en: Some languages, such as Haskell and Clojure Lisp, contain support for lazy evaluation
    as part of the core of the language. In fact, Clojure encourages its use and clearly
    demonstrates how useful it is for functional programming. However, the ANSI Common
    Lisp standard does not contain any similar feature for such lazy evaluation. Fortunately,
    with Common Lisp’s powerful macro system, we can easily add this feature to the
    language ourselves!
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如Haskell和Clojure Lisp，在语言的核心中包含对懒计算的支撑。实际上，Clojure鼓励使用它，并清楚地展示了它对函数式编程的实用性。然而，ANSI
    Common Lisp标准并没有包含任何类似的功能来实现这种懒计算。幸运的是，凭借Common Lisp强大的宏系统，我们可以轻松地将这个功能添加到语言中！
- en: Creating the lazy and force Commands
  id: totrans-750
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建懒和强制命令
- en: 'The most basic commands for lazy evaluation we’re going to create are `lazy`
    and `force`. The `lazy` command will be a wrapper you can put around a piece of
    code, telling Lisp that you would like the code to be evaluated in a lazy way,
    like this:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的最基本的懒计算命令是`lazy`和`force`。`lazy`命令将是一个包装器，你可以将其放在一段代码周围，告诉Lisp你希望这段代码以懒方式评估，如下所示：
- en: '[PRE113]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'As you can see, the computer *does not* try to calculate the value of 1 plus
    2\. Instead, it simply returns a function. To get the actual result of the calculation,
    we must call our other basic lazy evaluation command on a lazy value:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，计算机*不会*尝试计算1加2的值。相反，它只是返回一个函数。要获取计算的真正结果，我们必须在我们的另一个基本懒计算命令上调用懒值：
- en: '[PRE114]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The important thing is that the calculation was performed, but not when the
    lazy value was created—only when it was forced. To see that this is the case,
    let’s look at a more complex example:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，计算确实被执行了，但不是在懒值创建时，而是在它被强制时。为了证明这一点，让我们看一个更复杂的例子：
- en: '[PRE115]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here, we’ve created our own `add` function, which, as a side effect, prints
    a message to the console showing when the addition is happening ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we lazily add two numbers with our function and store the result in the
    variable `*foo*` ![](httpatomoreillycomsourcenostarchimages783562.png). So far,
    we know the addition hasn’t actually happened, since the message “I am adding
    now” has not yet appeared.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了自己的`add`函数，它作为副作用，会在控制台打印出加法操作发生的时间 ![image with no caption](httpatomoreillycomsourcenostarchimages783564.png)。接下来，我们使用我们的函数懒加两个数字，并将结果存储在变量`*foo*`中
    ![image with no caption](httpatomoreillycomsourcenostarchimages783562.png)。到目前为止，我们知道加法实际上还没有发生，因为消息“我现在正在加”还没有出现。
- en: Then we `force` our variable ![](httpatomoreillycomsourcenostarchimages783560.png).
    By forcing the value, the calculation is actually performed, and the result of
    `3` is returned. You can see that the addition took place when we forced the lazy
    value, since our message was also printed in the console ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们`force`我们的变量 ![image with no caption](httpatomoreillycomsourcenostarchimages783560.png)。通过强制赋值，计算实际上被执行，并返回`3`的结果。你可以看到，当我们强制赋值懒值时，加法操作发生了，因为我们的消息也打印到了控制台
    ![image with no caption](httpatomoreillycomsourcenostarchimages783554.png)。
- en: 'Here is the code for a simple implementation of `lazy`:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`lazy`简单实现的代码：
- en: '[PRE116]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We implement `lazy` by declaring a macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    This macro will require two variables in the code it generates. We need to declare
    these as `gensym` names ![](httpatomoreillycomsourcenostarchimages783562.png),
    as discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros").
    Next, we begin generating the code that the macro will output ![](httpatomoreillycomsourcenostarchimages783560.png)
    (note the backquote at the beginning of this line).
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过声明一个宏来实现`lazy`，这个宏的代码如下 ![image with no caption](httpatomoreillycomsourcenostarchimages783564.png)。这个宏在生成的代码中需要两个变量。我们需要将这些变量声明为`gensym`名称
    ![image with no caption](httpatomoreillycomsourcenostarchimages783562.png)，正如在[第16章](ch18.html
    "第16章。Lisp宏的魔力")中讨论的那样。接下来，我们开始生成宏将要输出的代码 ![image with no caption](httpatomoreillycomsourcenostarchimages783560.png)（注意这一行开头的反引号）。
- en: At the top of the code generated by the macro is a declaration for two local
    variables, using the `gensym` names we created ![](httpatomoreillycomsourcenostarchimages783560.png).
    The first variable tells us whether this lazy value has been forced yet ![](httpatomoreillycomsourcenostarchimages783560.png).
    If it is `nil`, the value can hide in a cloud. If the variable is true, the value
    is no longer hidden in a cloud, because it has been forced.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在宏生成的代码顶部，有两个局部变量的声明，使用我们创建的`gensym`名称 ![](httpatomoreillycomsourcenostarchimages783560.png)。第一个变量告诉我们这个懒值是否已经被强制
    ![](httpatomoreillycomsourcenostarchimages783560.png)。如果是`nil`，值可以隐藏在云彩中。如果变量为真，值就不再隐藏在云彩中，因为它已经被强制。
- en: Once the value has been calculated through a call to `force`, we store the resulting
    value in another variable, though initially this value isn’t used and is set to
    `nil` ![](httpatomoreillycomsourcenostarchimages783554.png). When our `lazy` macro
    is called, we want it to return a function, which can be called at a later time
    to force our lazy value to return a result. Therefore, we declare a lambda function
    next ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦通过调用`force`计算了值，我们将结果值存储在另一个变量中，尽管最初这个值没有被使用，并设置为`nil` ![](httpatomoreillycomsourcenostarchimages783554.png)。当我们的`lazy`宏被调用时，我们希望它返回一个函数，这个函数可以在稍后调用以强制我们的懒值返回一个结果。因此，我们接下来声明一个lambda函数
    ![](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Remember that any local variables declared outside this lambda function will
    be captured by the function as a closure. This means that the local variables
    above ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png)
    will persist between subsequent calls of the lambda function. Why does this matter?
    Well, once the cloud goes POOF!, we have completed all the work to calculate a
    value, and we don’t want to do it again when the lazy value is forced and checked
    again multiple times in the future. We can avoid this by remembering the value
    after the first `force` here ![](httpatomoreillycomsourcenostarchimages783554.png)
    between calls.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，任何在这个lambda函数外部声明的局部变量都将被函数作为闭包捕获。这意味着上面的局部变量 ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png)
    将在lambda函数的后续调用之间持续存在。这为什么很重要呢？好吧，一旦云彩消失POOF!，我们就完成了计算值的全部工作，我们不想在未来在懒值被强制和再次检查多次时再次做这件事。我们可以通过在调用之间记住第一次`force`这里的值来避免这种情况
    ![](httpatomoreillycomsourcenostarchimages783554.png)。
- en: When our lazy value is forced (by calling the lambda function we created), the
    first question we must ask ourselves is whether it has been forced already or
    is still hidden behind the cloud ![](httpatomoreillycomsourcenostarchimages783544.png).
    For a value that has not yet been forced, we go POOF! and perform the lazy calculation
    ![](httpatomoreillycomsourcenostarchimages783556.png), and save it as our `value`.
    We also mark it as having been `forced` ![](httpatomoreillycomsourcenostarchimages783566.png).
    Now the cloud has been destroyed.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的懒值被强制（通过调用我们创建的lambda函数）时，我们必须问自己的第一个问题是它是否已经被强制，或者仍然隐藏在云彩后面 ![](httpatomoreillycomsourcenostarchimages783544.png)。对于尚未被强制的一个值，我们就会POOF!执行懒计算
    ![](httpatomoreillycomsourcenostarchimages783556.png)，并将其保存为我们的`value`。我们还标记它为`forced`
    ![](httpatomoreillycomsourcenostarchimages783566.png)。现在云彩已经消失了。
- en: Once the cloud is gone, we can simply return our calculated value ![](httpatomoreillycomsourcenostarchimages783498.png).
    This may have been just calculated, or it may already exist from a previous call
    to `force`.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 云彩消失后，我们只需简单地返回我们的计算值 ![](httpatomoreillycomsourcenostarchimages783498.png)。这可能刚刚被计算，或者它可能已经存在于之前的`force`调用中。
- en: 'Unlike the (admittedly mind-bending) code for the `lazy` macro, the `force`
    function is super-simple. All it does is call the lambda function created by `lazy`:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 与（诚然令人费解的）`lazy`宏的代码不同，`force`函数非常简单。它所做的只是调用由`lazy`创建的lambda函数：
- en: '[PRE117]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We now have a fully functional set of primitive lazy evaluation commands. Many
    different types of sophisticated tools could be built on top of these simple `lazy`
    and `force` commands.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一套完整的原始懒评估命令。许多不同类型的复杂工具可以建立在这些简单的`lazy`和`force`命令之上。
- en: Creating a Lazy Lists Library
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建懒列表库
- en: We will now employ our new commands to build a library for *lazy lists*, based
    loosely on their implementation in Clojure. (In Clojure, lazy lists are referred
    to as *lazy sequences*.)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用我们的新命令构建一个基于Clojure实现的懒列表库的库。 (在Clojure中，懒列表被称为懒序列。)
- en: 'Since the fundamental command for working with Lisp lists is the `cons` command,
    you shouldn’t be surprised that the first command we create for working with lazy
    lists is the `lazy-cons` command:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理Lisp列表的基本命令是`cons`命令，您可能不会对第一个用于处理惰性列表的命令是`lazy-cons`命令感到惊讶：
- en: '[PRE118]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This macro emulates the behavior of `cons`, except that the result is wrapped
    in the `lazy` macro. To accompany `lazy-cons`, we’ll also create `lazy-car` and
    `lazy-cdr` commands:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏模拟了`cons`的行为，只不过结果是包裹在`lazy`宏中。为了配合`lazy-cons`，我们还将创建`lazy-car`和`lazy-cdr`命令：
- en: '[PRE119]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'All these functions do is force the lazy value and then call `car` and `cdr`,
    respectively. Let’s try using these new commands:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数所做的只是强制惰性值，然后分别调用`car`和`cdr`。让我们尝试使用这些新命令：
- en: '[PRE120]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As you can see, we can use `lazy-cons` exactly as we would use `cons` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we can take apart a lazy cons in the same way we would take apart a cons
    ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以像使用`cons`一样使用`lazy-cons` ![链接](http://atomoreilly.com/source/nostarch/images/783564.png)。然后我们可以像分解`cons`一样分解惰性`cons`
    ![链接](http://atomoreilly.com/source/nostarch/images/783562.png)![链接](http://atomoreilly.com/source/nostarch/images/783560.png)。
- en: 'So far, it looks like our lazy list functions aren’t any different from the
    standard `cons`, `car`, and `cdr` functions. However, we can actually use them
    to perform some pretty amazing feats. Consider, for instance, the following definition:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，看起来我们的惰性列表函数与标准的`cons`、`car`和`cdr`函数没有太大区别。然而，我们实际上可以使用它们来完成一些相当惊人的壮举。例如，考虑以下定义：
- en: '[PRE121]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Here, we’ve used the `lazy-cons` command to declare something impossible: a
    variable that holds a list of all positive integers! We do this by creating a
    local function `f` ![](httpatomoreillycomsourcenostarchimages783564.png), which
    we then call recursively to build an infinite chain of `lazy-cons`es, using an
    ever-increasing number `n` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Once we’ve declared this seemingly impossible `*integers*` variable, we can use
    it just as you might expect:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`lazy-cons`命令来声明一件看似不可能的事情：一个包含所有正整数的列表的变量！我们通过创建一个局部函数`f` ![链接](http://atomoreilly.com/source/nostarch/images/783564.png)，然后递归地调用它来构建一个无限的`lazy-cons`链，使用一个不断增长的数字`n`
    ![链接](http://atomoreilly.com/source/nostarch/images/783562.png)。一旦我们声明了这个看似不可能的`*integers*`变量，我们就可以像预期的那样使用它：
- en: '[PRE122]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: As long as we stick to using only our `lazy-` commands, we can pull whatever
    we want out of our infinite list of integers, forcing more and more numbers from
    `*integers*` on an as-needed basis.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们坚持只使用我们的`lazy-`命令，我们就可以从我们的无限整数列表中取出我们想要的任何东西，根据需要强制从`*integers*`中获取更多和更多的数字。
- en: Since not all lists are infinite (as is the list of positive integers), we’ll
    also need to have a concept of a `lazy-nil` to terminate a list. Similarly, we
    need a `lazy-null` function that we can use to check if we’ve reached the end
    of a list, just as the `null` function can be used to check for the end of a regular
    list.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有列表都是无限的（例如正整数的列表），我们还需要有一个`lazy-nil`的概念来终止列表。同样，我们需要一个`lazy-null`函数，我们可以用它来检查是否到达了列表的末尾，就像`null`函数可以用来检查常规列表的末尾一样。
- en: '[PRE123]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Now that we have all the basic building blocks for working with lazy lists,
    let’s create some useful functions for our library.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了处理惰性列表的基本构建块，让我们为我们的库创建一些有用的函数。
- en: Converting Between Regular Lists and Lazy Lists
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在常规列表和惰性列表之间的转换
- en: 'One obvious thing we would want to be able to do is convert a regular list
    into a lazy list. The `make-lazy` function allows us to do this:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要能够做的一件明显的事情是将常规列表转换为惰性列表。`make-lazy`函数允许我们这样做：
- en: '[PRE124]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: As the `make-lazy` function clearly shows, writing lazy list library functions
    is sort of like writing zen koans. The only way to understand them is to stare
    at them for a long time. The English language doesn’t have appropriate words for
    clearly explaining functions like `make-lazy`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`make-lazy`函数清楚地显示的那样，编写惰性列表库函数有点像写禅宗公案。理解它们的唯一方法就是长时间地盯着它们看。英语没有合适的词汇来清楚地解释像`make-lazy`这样的函数。
- en: In broad terms, `make-lazy` uses recursion to travel across the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and then wraps each cons in a call to the `lazy` macro ![](httpatomoreillycomsourcenostarchimages783564.png).
    However, to get the full meaning of this function (and the other remaining functions
    in our lazy library), you’ll just have to try to think carefully about what `lazy`
    and `force` really mean, and meditate a bit over each function. Luckily, once
    our little lazy list library is complete, it will hide most of the strangeness
    of lazy evaluation.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，`make-lazy` 使用递归遍历列表 ![http://atomoreilly.com/source/nostarch/images/783562.png]，然后将每个
    cons 元素包裹在 `lazy` 宏的调用中 ![http://atomoreilly.com/source/nostarch/images/783564.png]。然而，要完全理解这个函数（以及我们懒加载库中剩余的其他函数），你只需仔细思考
    `lazy` 和 `force` 的真正含义，并对每个函数进行一些冥想。幸运的是，一旦我们的小懒列表库完成，它将隐藏大多数懒加载的奇怪之处。
- en: Just as we wrote the `make-lazy` function to convert regular lists to lazy lists,
    we can create some functions to do the reverse—convert lazy lists into regular
    ones. The `take` and `take-all` functions allow us to do this.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们编写 `make-lazy` 函数将常规列表转换为懒加载列表一样，我们可以创建一些函数来做相反的操作——将懒加载列表转换为常规列表。`take`
    和 `take-all` 函数允许我们这样做。
- en: '[PRE125]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The reason we want two different commands for going from lazy to regular lists
    is that, unlike regular lists, lazy lists can be infinite. Therefore, it is useful
    to have an additional command that lets us take just a specified number of items
    from the list. The `take` function accepts an extra argument `n` that indicates
    just how many values we want to take ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we just want all values, we can call the `take-all` function ![](httpatomoreillycomsourcenostarchimages783562.png).
    Of course, this function cannot be used on infinite lists—taking all items from
    an infinite list would lead to an infinite loop.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要两个不同的命令来从懒加载列表转换为常规列表的原因是，与常规列表不同，懒加载列表可以是无限的。因此，有一个额外的命令让我们能够从列表中取出指定数量的项是有用的。`take`
    函数接受一个额外的参数 `n`，它表示我们想要取出的值的数量 ![http://atomoreilly.com/source/nostarch/images/783564.png]。如果我们只想获取所有值，我们可以调用
    `take-all` 函数 ![http://atomoreilly.com/source/nostarch/images/783562.png]。当然，这个函数不能用于无限列表——从无限列表中取出所有项会导致无限循环。
- en: 'Let’s try out our new lazy list conversion functions:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们新的懒加载列表转换函数：
- en: '[PRE126]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: As you would expect, if we take the first 10 integers off the list of all positive
    integers, we just get the numbers 1 through 10 as a result ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `take` function can also be used on a finite list we’ve created by calling
    `make-lazy` ![](httpatomoreillycomsourcenostarchimages783562.png). However, if
    a list is finite, we can use the simpler `take-all` function and just get a regular
    list of all items in the lazy list ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，如果我们从所有正整数的列表中取出前 10 个整数，我们只会得到从 1 到 10 的数字作为结果 ![http://atomoreilly.com/source/nostarch/images/783564.png]。`take`
    函数也可以用于通过调用 `make-lazy` 创建的有限列表 ![http://atomoreilly.com/source/nostarch/images/783562.png]。然而，如果列表是有限的，我们可以使用更简单的
    `take-all` 函数，并直接得到懒加载列表中所有项的常规列表 ![http://atomoreilly.com/source/nostarch/images/783560.png]。
- en: Mapping and Searching Across Lazy Lists
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在懒加载列表中进行映射和搜索
- en: 'We also want to be able to map and search across lazy lists. Here are some
    functions to allow that:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够在懒加载列表上进行映射和搜索。以下是一些允许这样做的函数：
- en: '[PRE127]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: These functions are analogous to the functions `mapcar`, `mapcan`, `find-if`,
    and `nth`. The only difference is that they accept and return lazy lists. This
    means that instead of using `null`, `car`, and `cdr`, they use the lazy versions
    of these functions (`lazy-null`, `lazy-car`, and `lazy-cdr`) that we just created.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数与 `mapcar`、`mapcan`、`find-if` 和 `nth` 函数类似。唯一的区别是它们接受和返回懒加载列表。这意味着它们不是使用
    `null`、`car` 和 `cdr`，而是使用我们刚刚创建的这些函数的懒加载版本（`lazy-null`、`lazy-car` 和 `lazy-cdr`）。
- en: 'Using these functions is pretty straightforward:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数相当简单：
- en: '[PRE128]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Calling `lazy-mapcar` to map the square root function across the positive integers
    gives us a lazy list of the square roots of the positive integers. The first 10
    are shown ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we call
    `lazy-mapcan` ![](httpatomoreillycomsourcenostarchimages783562.png) and check
    if each positive integer is even. If it is, we return a lazy list of the numbers
    ![](httpatomoreillycomsourcenostarchimages783560.png). If it isn’t, we return
    the lazy empty list ![](httpatomoreillycomsourcenostarchimages783554.png). The
    result is that we’ve filtered out all the even numbers from our lazy list of integers.
    We can use `lazy-find-if` to find the first odd number in a lazy list ![](httpatomoreillycomsourcenostarchimages783510.png).
    In this case, the number was 7\. Finally, we can use `lazy-nth` to pick a number
    out of a specific location in a lazy list ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lazy-mapcar`调用平方根函数映射正整数，我们得到了正整数的平方根的懒列表。前10个如下所示 ![httpatomoreillycomsourcenostarchimages783564.png]。接下来，我们调用`lazy-mapcan`
    ![httpatomoreillycomsourcenostarchimages783562.png]并检查每个正整数是否为偶数。如果是，我们返回一个包含数字的懒列表
    ![httpatomoreillycomsourcenostarchimages783560.png]。如果不是，我们返回一个懒空列表 ![httpatomoreillycomsourcenostarchimages783554.png]。结果是，我们从整数懒列表中过滤掉了所有偶数。我们可以使用`lazy-find-if`在懒列表中找到第一个奇数
    ![httpatomoreillycomsourcenostarchimages783510.png]。在这种情况下，数字是7。最后，我们可以使用`lazy-nth`从懒列表的特定位置选择一个数字
    ![httpatomoreillycomsourcenostarchimages783544.png]。
- en: We have now written an entire, if rather simple, lazy list library. Place all
    the functions we’ve written so far in this chapter in a file named *lazy.lisp*
    (or simply download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了一个完整的，尽管相当简单的懒列表库。将本章中我们编写的所有函数放入名为*lazy.lisp*的文件中（或者直接从[http://landoflisp.com/](http://landoflisp.com/)下载该文件）。
- en: Now, you’re going to see that lazy lists allow us to greatly boost the power
    of our Dice of Doom game engine!
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你们将看到懒列表如何极大地提升我们“末日骰子”游戏引擎的效能！
- en: Dice of Doom, Version 2
  id: totrans-807
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 末日骰子，版本2
- en: In [Chapter 15](ch17.html "Chapter 15. Dice of Doom, a Game Written in the Functional
    Style"), we created the first version of our Dice of Doom game. We are now going
    to modify some of the functions from that version. To proceed, place the code
    from that chapter into a file named *dice_of_doom_v1.lisp* so that we can reference
    it in this new version (or just download that file from [http://landoflisp.com/](http://landoflisp.com/)).
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch17.html "第15章。末日骰子，一个用函数式风格编写的游戏")中，我们创建了“末日骰子”游戏的第一个版本。现在，我们将修改该版本中的一些函数。为了继续，将那一章的代码放入名为*dice_of_doom_v1.lisp*的文件中，以便我们可以在新版本中引用它（或者直接从[http://landoflisp.com/](http://landoflisp.com/)下载该文件）。
- en: 'To use our previous Dice of Doom and our new lazy list library, run the following
    in the REPL:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们之前的“末日骰子”和新的懒列表库，请在REPL中运行以下命令：
- en: '[PRE129]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Next, we’re going to increase the size of our board to a more roomy 4-by-4:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将棋盘的大小增加到更宽敞的4x4：
- en: '[PRE130]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: To allow the game to run at a reasonable speed at this larger size, we’ll make
    the list of moves at each branch of our game tree a lazy list, instead of just
    a regular list. By simply converting this one structure in our game from a regular
    list to a lazy list, the entire game tree will become lazy as a result. To accomplish
    this, we now need to redefine some of the functions from the first version of
    our game to use our new lazy list functions.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏以合理的速度运行在这个更大的规模上，我们将游戏树每个分支的移动列表改为懒列表，而不是普通的列表。通过简单地将我们游戏中的一种结构从普通列表转换为懒列表，整个游戏树将因此变为懒列表。为了实现这一点，我们现在需要重新定义我们游戏第一版中的一些函数，以便使用我们新的懒列表函数。
- en: 'First, let’s make some small modifications to the functions that calculate
    the attacking and passing moves possible from a given board position:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对计算从给定棋盘位置可能的攻击和传球移动的函数做一些小的修改：
- en: '[PRE131]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As you can see, the `add-passing-move` function needs only one small change.
    Since the list of moves is now a lazy list, we use `lazy-cons` to add a passing
    move to the top of the list of possible moves ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 如你们所见，`add-passing-move`函数只需要做一个小改动。由于移动列表现在是懒列表，我们使用`lazy-cons`将一个传球移动添加到可能的移动列表的顶部
    ![httpatomoreillycomsourcenostarchimages783564.png]。
- en: The `attacking-moves` function requires a few more changes. First, since it
    now needs to return a lazy list, we use `lazy-mapcan` in lieu of `mapcan` in two
    places as the moves are calculated ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    The `lazy-mapcan` function also requires the lists created inside it to be lazy,
    which we accomplish with the `make-lazy` function ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783544.png).
    Also, any place we returned `nil` we now instead return a `lazy-nil` ![](httpatomoreillycomsourcenostarchimages783510.png)![](httpatomoreillycomsourcenostarchimages783556.png).
    Finally, we also make the list of calculated board positions lazy ![](httpatomoreillycomsourcenostarchimages783566.png),
    since it is fed into the outer `lazy-mapcan`.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '`attacking-moves` 函数需要一些额外的更改。首先，由于它现在需要返回一个惰性列表，我们在两个地方使用 `lazy-mapcan` 代替
    `mapcan` 来计算移动 ![图片](httpatomoreillycomsourcenostarchimages783562.png)![图片](httpatomoreillycomsourcenostarchimages783560.png)。`lazy-mapcan`
    函数还要求其内部创建的列表是惰性的，我们通过 `make-lazy` 函数来实现 ![图片](httpatomoreillycomsourcenostarchimages783554.png)![图片](httpatomoreillycomsourcenostarchimages783544.png)。此外，我们还将返回
    `nil` 的任何地方现在改为返回 `lazy-nil` ![图片](httpatomoreillycomsourcenostarchimages783510.png)![图片](httpatomoreillycomsourcenostarchimages783556.png)。最后，我们还使计算出的棋盘位置列表变为惰性
    ![图片](httpatomoreillycomsourcenostarchimages783566.png)，因为它被输入到外部的 `lazy-mapcan`。'
- en: 'Next, let’s make similar changes to two of the functions that deal with human
    players:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们对处理人类玩家的两个函数进行类似的更改：
- en: '[PRE132]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the `handle-human` function, we have a local function `print-moves`, which
    is a list-eater function across the list of moves. We modify it to use our lazy
    commands when checking for the end of the list ![](httpatomoreillycomsourcenostarchimages783564.png),
    taking a move off the front of the list ![](httpatomoreillycomsourcenostarchimages783562.png),
    and recursing across the tail of the list ![](httpatomoreillycomsourcenostarchimages783560.png).
    Finally, we modify `handle-human` to use `lazy-nth` to pick a move after the human
    chooses it from the list of options ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle-human` 函数中，我们有一个局部函数 `print-moves`，它是一个遍历移动列表的列表消耗函数。我们修改它以在检查列表的末尾时使用我们的惰性命令
    ![图片](httpatomoreillycomsourcenostarchimages783564.png)，从列表的前端移除一个移动 ![图片](httpatomoreillycomsourcenostarchimages783562.png)，并在列表的尾部递归
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)。最后，我们修改 `handle-human`
    以使用 `lazy-nth` 在人类从选项列表中选择移动后选择一个移动 ![图片](httpatomoreillycomsourcenostarchimages783554.png)。
- en: In the `play-vs-human` function, we make just a single pinpoint change. In order
    to determine whether we’ve reached the end of a game, we need to check whether
    the list of subsequent possible moves is empty, and then announce the winner.
    We simply use `lazy-null` to check if the lazy list of moves is empty ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `play-vs-human` 函数中，我们只做了一处精确的更改。为了确定我们是否到达了游戏的末尾，我们需要检查后续可能的移动列表是否为空，然后宣布获胜者。我们简单地使用
    `lazy-null` 来检查惰性移动列表是否为空 ![图片](httpatomoreillycomsourcenostarchimages783510.png)。
- en: 'With these simple changes in place, you can play Dice of Doom against another
    human on much larger board sizes, since no move in the tree is realized unless
    one of the players decides to make it. On our larger, 4-by-4 board, enter the
    following to start a game (just as for version 1 of our game):'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简单的更改到位后，你可以在更大的棋盘尺寸上与另一名人类玩家玩“末日骰子”，因为除非一名玩家决定做出移动，否则树中的任何移动都不会实现。在我们的更大，4x4的棋盘上，输入以下内容以开始游戏（就像我们游戏的第1版一样）：
- en: '[PRE133]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Version 1 would screech to a halt the moment this command was executed. This
    is because it would need to generate the entirety of the game tree, *for every
    possible move of the whole game*, before the game would even start playing.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 第1版会在执行此命令的瞬间停止。这是因为它需要在游戏开始播放之前，为整个游戏中所有可能的移动生成整个游戏树。
- en: With our lazy version of Dice of Doom, the game starts instantly!
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的惰性版本“末日骰子”，游戏可以立即开始！
- en: Making Our AI Work on Larger Game Boards
  id: totrans-826
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的AI在更大的游戏棋盘上工作
- en: Next, we’re going to adjust our game AI functions to use the new lazy list library
    when processing moves. Along the way, we will make some additional improvements
    to the AI code.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整我们的游戏AI函数以在处理移动时使用新的惰性列表库。在这个过程中，我们将对AI代码进行一些额外的改进。
- en: Trimming the Game Tree
  id: totrans-828
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪切游戏树
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779954.png.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779954.png.jpg)'
- en: In version 1 of Dice of Doom, our AI code was, in certain ways, extremely powerful.
    This is because, at every decision point, the AI player would look at *every possible
    future board position* to choose the absolute best next move. In this way, it
    could play a perfect game of Dice of Doom, winning every game that was winnable.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在《末日骰子》版本1中，我们的AI代码在某些方面非常强大。这是因为，在每一个决策点，AI玩家会查看**每一个可能的未来棋盘位置**来选择绝对最佳的下一步走法。通过这种方式，它可以玩出完美的《末日骰子》，赢得每一场可以赢得的比赛。
- en: However, such a design does not scale to larger boards. This is because it becomes
    impossible to contemplate every single possible future move once there are too
    many. In fact, the whole point of our new lazy game tree is to avoid contemplating
    every possible move. Therefore, we need a way to tell the computer, “Consider
    only this many moves, and no more.” In other words, we want to be able tell it
    to look only two, three, or four moves ahead, and then stop looking any further.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计无法扩展到更大的棋盘。这是因为一旦棋盘变得太大，就几乎不可能考虑每一个可能的未来走法。事实上，我们新提出的懒惰游戏树的核心目的就是避免考虑每一个可能的走法。因此，我们需要一种方法告诉计算机，“只考虑这么多走法，不再考虑更多。”换句话说，我们希望能够告诉它只看两步、三步或四步，然后停止进一步查看。
- en: The functional programming style of Dice of Doom allows us to do this in a very
    elegant but nonobvious way.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 《末日骰子》的函数式编程风格允许我们以一种非常优雅但并不明显的方式做到这一点。
- en: The *obvious* solution to the problem would be to modify the `get-ratings` and
    `rate-position` from version 1 to have a new argument called `search-depth`. Then
    we could ask ourselves at every call of those functions, “Have we reached the
    maximum search depth we want?”
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的**明显**方案是对版本1中的`get-ratings`和`rate-position`进行修改，添加一个名为`search-depth`的新参数。然后，在每次调用这些函数时，我们可以问自己，“我们已经达到想要的最大搜索深度了吗？”
- en: The problem with this approach is that it gunks up those functions with extra,
    confusing code. In fact, the way we evaluate board positions is theoretically
    a separate issue from how deep we wish to search. As programmers like to say,
    these issues are *orthogonal*, and it would be best if we could write separate
    functions to deal with each of these issues independently.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是它会使那些函数变得复杂，代码难以理解。实际上，我们评估棋盘位置的方式在理论上与希望搜索的深度是两个独立的问题。程序员喜欢说，这些问题是**正交的**，如果我们可以分别编写函数来独立处理这些问题，那就最好不过了。
- en: In fact, with our new lazy game tree, it is possible to write a separate function
    that is solely responsible for “trimming” the search tree and is completely independent
    from the main AI code that contemplates and rates possible moves.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有了我们新的懒惰游戏树，我们可以编写一个单独的函数，专门负责“修剪”搜索树，并且完全独立于主要AI代码，后者负责考虑和评估可能的走法。
- en: 'Here is the function that trims our tree:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个修剪树的函数：
- en: '[PRE134]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This is a pretty simple function that takes just two arguments: a lazy tree
    and the depth to which we wish to trim it ![](httpatomoreillycomsourcenostarchimages783564.png).
    As a result, it just outputs a new game tree, calling itself recursively, decrementing
    the depth for each level it travels into the tree ![](httpatomoreillycomsourcenostarchimages783554.png).
    Once this depth reaches zero ![](httpatomoreillycomsourcenostarchimages783562.png),
    we know we’re at the level that we want to trim, and we set the lazy list of moves
    to the empty list ![](httpatomoreillycomsourcenostarchimages783560.png).'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的函数，它只接受两个参数：一个懒惰树和希望修剪到的深度！[](httpatomoreillycomsourcenostarchimages783564.png)。因此，它只是输出一个新的游戏树，递归地调用自身，每深入树的一层就减少深度！[](httpatomoreillycomsourcenostarchimages783554.png)。一旦这个深度达到零！[](httpatomoreillycomsourcenostarchimages783562.png)，我们就知道我们已经到达了想要修剪的水平，并将懒惰走法列表设置为空列表！[](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Now all we need to do is call our new `limit-tree-depth` function before doing
    our AI rating calculations. We do this by tweaking our `handle-computer` function
    a bit:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的只是在我们进行AI评级计算之前调用我们的新`limit-tree-depth`函数。我们通过稍微调整我们的`handle-computer`函数来实现这一点：
- en: '[PRE135]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Before calling `get-ratings` to get a rating for every next available move,
    we transform our game tree into our trimmed game tree ![](httpatomoreillycomsourcenostarchimages783564.png).
    All of our AI code can now run on the trimmed tree, completely oblivious to the
    fact that a larger game tree exists or that there are deeper moves it isn’t including
    in its calculations. With this technique, we have managed to decouple the code
    that limits the AI search depth from the algorithm that actually evaluates board
    positions. One other small modification is to use `lazy-nth` when picking a move
    out of the lazy list of moves ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`get-ratings`以获取每个下一个可用移动的评分之前，我们将我们的游戏树转换为修剪后的游戏树 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)。现在，我们所有的AI代码都可以在修剪后的树上运行，完全不知道存在一个更大的游戏树，或者它没有包括在计算中的更深层次的移动。通过这种技术，我们已经成功地将限制AI搜索深度的代码与实际评估棋盘位置的算法解耦。另一个小的修改是在从懒加载移动列表中选择移动时使用`lazy-nth`
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)。
- en: Note
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `limit-tree-depth` function uses a pretty crude method for trimming our
    tree: It simply trims all tree branches beyond a certain depth. For most board
    games, doing this is an optimal way of trimming the game tree. However, Dice of
    Doom has the uncommon property that multiple moves in a row are allowed for each
    player. It would probably be more optimal if `limit-tree-depth` took into account
    how many times we’ve switched players as a criterion for trimming a branch. But
    our simpler version works well enough.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit-tree-depth`函数使用了一种相当粗糙的方法来修剪我们的树：它只是简单地修剪所有超过一定深度的树分支。对于大多数棋盘游戏来说，这样做是修剪游戏树的最佳方式。然而，《末日骰子》有一个不寻常的特性，即每个玩家都允许连续进行多次移动。如果`limit-tree-depth`在修剪分支时考虑到我们切换玩家的次数，可能更优。但我们的简单版本已经足够好了。'
- en: 'At this point, we should also make a pinpoint change to `play-vs-computer`:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们也应该对`play-vs-computer`进行精确的修改：
- en: '[PRE136]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here, we just added a `lazy-null` to check for the end of the lazy list of moves
    in a single spot ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是添加了一个`lazy-null`来检查单个位置上懒加载移动列表的末尾 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)。
- en: Now let’s look at another trick that will improve the power of our AI code.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个将提高我们AI代码能力的技巧。
- en: Applying Heuristics
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用启发式
- en: By trimming our game tree, we’ve fundamentally changed our AI player. Without
    trimming, the AI player was able to play a perfect game at all times. By trimming
    the tree, however, it is possible for the AI to “miss something,” since it is
    no longer contemplating every possible future move. In version 2 of Dice of Doom,
    the computer player will no longer be able to play a perfect game—just a “pretty
    good” game is possible.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修剪我们的游戏树，我们从根本上改变了我们的AI玩家。如果没有修剪，AI玩家能够始终玩出完美的游戏。然而，通过修剪树，AI就有可能“错过”一些东西，因为它不再考虑每一个可能未来的移动。在《末日骰子》版本2中，电脑玩家将无法再玩出完美的游戏——只能玩出“相当不错”的游戏。
- en: Basically, we’ve exchanged the AI’s ability to play a perfect game for much
    better performance. In the process, we’ve turned the AI code from something precise
    that can be analyzed by mathematics into something that is “squishier” and far
    less precise. As computer scientists would say, we have now entered into the realm
    of *heuristics*.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们用AI玩完美游戏的能力换取了更好的性能。在这个过程中，我们将AI代码从可以被数学分析出的精确事物转变为“更柔软”且远不那么精确的事物。正如计算机科学家所说，我们现在已经进入了*启发式*领域。
- en: In computer science, heuristics are programming techniques that are imperfect,
    but allow us to get good results very quickly. Broadly speaking, any technique
    that is fast but not guaranteed to work 100 percent of the time is a heuristic.
    When we write code that uses heuristics (as our Dice of Doom AI engine now does),
    it is often worthwhile to use some creative thinking and to “play around” with
    the code in different ways.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，启发式是一种不完美的编程技术，但允许我们快速获得良好的结果。广义上讲，任何快速但不是每次都能保证成功的技巧都是启发式。当我们编写使用启发式（如我们的《末日骰子》AI引擎现在所做的那样）的代码时，通常值得进行一些创造性思考，并以不同的方式“玩弄”代码。
- en: Basically, since we’re already given up on our goal of a perfect solution and
    are now using imprecise techniques, it’s possible that tweaking the knobs on the
    heuristic code in different ways could dramatically improve our results. And indeed,
    it turns out that there is a simple change we can make to our Dice of Doom AI
    heuristics that will significantly improve the AI player’s game.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，既然我们已经放弃了寻找完美解决方案的目标，现在正在使用不精确的技术，那么以不同的方式调整启发式代码中的旋钮可能会显著提高我们的结果。事实上，我们发现我们可以对Dice
    of Doom AI的启发式算法进行一个简单的修改，这将显著提高AI玩家的游戏表现。
- en: Winning by a Lot vs. Winning by a Little
  id: totrans-853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大胜与小胜
- en: In version 1 of our Dice of Doom code, the AI player had no reason to ever worry
    about its margin of victory. All it cared about was that when the game ended,
    it had ownership of at least one more territory of the board than its opponent,
    which meant it had won.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dice of Doom代码的版本1中，AI玩家没有理由担心其胜利的幅度。它唯一关心的是当游戏结束时，它至少比对手多拥有一个棋盘领土，这意味着它已经获胜。
- en: However, now that we’re using imprecise heuristics in our AI code, it matters
    *a lot* how large the lead is at any point in the game. A heuristic rule for this
    situation is “If I am totally whomping my opponent in the game, it is pretty unlikely
    he/she will be able to recover, even if I look only a few moves ahead.”
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们在AI代码中使用不精确的启发式算法，游戏中的领先幅度在任何时刻都非常重要。这种情况下的启发式规则是：“如果我在游戏中彻底打败了我的对手，那么即使我只看几步棋，他/她恢复的可能性也很小。”
- en: Remember that a minimax algorithm (as we’re using in our AI) assigns a point
    score to every final leaf branch in the tree. In version 1 of our game, this score
    was either 0 or 1, or sometimes 1/2 when the game ended in a tie. In version 2,
    these are not truly “final leaves” in the tree, but simply leaves in our much
    smaller trimmed tree. In this situation, it would be much better if our leaf point
    scores had a larger range of values, so that we can tell which moves lead to a
    game we’re winning by “a lot” and which moves lead to a game we’re winning by
    only “a little.”
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，最小-最大算法（正如我们在AI中使用的那样）会给树中的每个最终叶子分支分配一个得分。在我们的游戏版本1中，这个得分要么是0或1，或者当游戏以平局结束时，有时是1/2。在版本2中，这些并不是树中的真正“最终叶子”，而只是我们更小的修剪树中的叶子。在这种情况下，如果我们的叶子得分有更大的值范围，那么我们就可以判断哪些走法会导致我们赢得“很多”的游戏，哪些走法会导致我们只赢得“一点”。
- en: 'Let’s write a `score-board` function that uses some more complex heuristics
    to score the board position at a leaf:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`score-board`函数，该函数使用一些更复杂的启发式算法来评估叶子节点的棋盘位置：
- en: '[PRE137]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The `score-board` function loops ![](httpatomoreillycomsourcenostarchimages783564.png)
    across all of the hexes of the board and builds a running total of points for
    each hex using the `sum` directive of the loop macro. If the player we’re scoring
    owns the current hex ![](httpatomoreillycomsourcenostarchimages783562.png), we
    want to add positive points to the total ![](httpatomoreillycomsourcenostarchimages783554.png)![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`score-board`函数遍历棋盘上的所有六边形，并使用循环宏的`sum`指令为每个六边形累积得分。如果我们要评估的玩家拥有当前的六边形，我们希望将正分加到总分上！[图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)！[图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)！[图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)！[图片链接](http://atomoreilly.com/source/nostarch/images/783510.png)。'
- en: 'To decide exactly how many points to add to the total for an occupied hex,
    we make another heuristic observation: Hexes that neighbor a stronger opponent
    aren’t quite as valuable as hexes without strong neighbors. We’ll call a hex that
    neighbors an enemy hex that has more dice on it a *threatened hex*. For hexes
    that are threatened ![](httpatomoreillycomsourcenostarchimages783560.png), we’ll
    add only 1 point to the point total ![](httpatomoreillycomsourcenostarchimages783554.png).
    For hexes that are unthreatened, we’ll add 2 points ![](httpatomoreillycomsourcenostarchimages783510.png).
    Finally, for each hex owned by an opposing player, we’ll subtract 1 point from
    the total ![](httpatomoreillycomsourcenostarchimages783544.png).'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定为占据的六边形添加多少分，我们做出另一个启发式观察：与更强的对手相邻的六边形并不像没有强邻居的六边形那样有价值。我们将一个与拥有更多骰子的敌人相邻的六边形称为*受威胁的六边形*。对于受威胁的六边形！[图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)，我们将只添加1分到总分！[图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。对于不受威胁的六边形，我们将添加2分！[图片链接](http://atomoreilly.com/source/nostarch/images/783510.png)。最后，对于每个由对手拥有的六边形，我们将从总分中减去1分！[图片链接](http://atomoreilly.com/source/nostarch/images/783544.png)。
- en: Again, the important thing to realize is that `score-board` is a heuristic function,
    and there is no truly right or wrong way to generate such a score. Instead of
    adding 2 points for unthreatened hexes, we could just as easily have added 1.5
    points. In developing this example, I ran some simulations playing various opponents
    using different versions of the `score-board` function, and this version ended
    up working reasonably well. Developing heuristics is not an exact science.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，重要的是要认识到 `score-board` 是一个启发式函数，没有真正正确或错误的方式来生成这样的分数。我们不仅可以为不受威胁的六边形加 2
    分，同样也可以加 1.5 分。在开发这个示例时，我使用不同版本的 `score-board` 函数与各种对手进行了模拟，这个版本最终表现相当不错。开发启发式方法不是一门精确的科学。
- en: 'Here is the function that determines whether a given hex is threatened:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是确定给定六边形是否受到威胁的函数：
- en: '[PRE138]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: First, we get the hex in question and figure out who the occupying player is,
    and how many dice that player has ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we loop through all the neighboring squares for the current position ![](httpatomoreillycomsourcenostarchimages783562.png).
    After that, we find out the player and dice count for each of the neighbors ![](httpatomoreillycomsourcenostarchimages783560.png).
    As soon as we find a neighboring hex owned by an opponent with a larger dice count
    (a threatening neighbor) ![](httpatomoreillycomsourcenostarchimages783554.png),
    we can return true ![](httpatomoreillycomsourcenostarchimages783510.png). Calling
    `return` in this way causes the loop to stop early with true as a result.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取相关的六边形，并确定占据该六边形的玩家以及该玩家有多少个骰子 ![相关骰子](httpatomoreillycomsourcenostarchimages783564.png)。然后，我们遍历当前位置的所有相邻方格
    ![当前位置的相邻方格](httpatomoreillycomsourcenostarchimages783562.png)。之后，我们找出每个相邻方格的玩家和骰子数量
    ![每个相邻方格的玩家和骰子数量](httpatomoreillycomsourcenostarchimages783560.png)。一旦我们找到一个由对手拥有的、骰子数量更多的相邻六边形（一个威胁性的邻居）
    ![威胁性的邻居](httpatomoreillycomsourcenostarchimages783554.png)，我们就可以返回 true ![返回
    true](httpatomoreillycomsourcenostarchimages783510.png)。以这种方式调用 `return` 会导致循环提前停止，并以
    true 作为结果。
- en: 'Now that we have completed our `score-board` and `threatened` functions, we’re
    ready to write our improved `get-ratings` and `rate-position` functions:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的 `score-board` 和 `threatened` 函数，我们准备编写我们的改进的 `get-ratings` 和 `rate-position`
    函数：
- en: '[PRE139]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: As you can see, we’ve updated a couple lines of code ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)
    to be compatible with our new lazy game tree. Notice that any game positions that
    lack follow-up moves (that is, leaves) now cause our new score-board function
    to be called ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们更新了几行代码 ![更新代码](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)，以与我们的新懒散游戏树兼容。请注意，任何缺乏后续移动（即，叶子）的游戏位置现在都会调用我们的新
    `score-board` 函数 ![新 `score-board` 函数](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Now that we have a fully working heuristic AI player that can play on larger
    game boards, let’s try it out. As usual, all moves for player B in the following
    example are being automatically calculated by the AI algorithm:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全工作的启发式 AI 玩家，可以在更大的游戏棋盘上玩游戏，让我们试试。像往常一样，以下示例中玩家 B 的所有移动都由 AI 算法自动计算：
- en: '[PRE140]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: With these changes in place, the AI player will win around 65 to 70 percent
    of all games (depending on the board size and AI level) when pitted against a
    player that chooses only random moves. This is actually a very good result. Our
    simple `gen-board` function often creates very lopsided starting positions, so
    many of the remaining 30 percent of the games are simply unwinnable for the computer.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，当与只选择随机移动的玩家对抗时，AI 玩家将赢得大约 65 到 70% 的所有游戏（取决于棋盘大小和 AI 级别）。这实际上是一个非常不错的结果。我们的简单
    `gen-board` 函数经常创建非常不平衡的起始位置，所以剩下的 30% 的游戏对于计算机来说很多都是无法赢得的。
- en: Alpha Beta Pruning
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alpha Beta Pruning
- en: Let’s add one final improvement to version 2 of our Dice of Doom AI.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Dice of Doom AI 的第 2 版中添加一个最后的改进。
- en: '*Alpha-beta pruning* is a well-known optimization of the minimax algorithm
    that improves performance by skipping over some branches (*pruning* those branches)
    if it is certain that they will not impact the final minimax evaluation.'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alpha-beta pruning* 是一个著名的最小-最大算法优化，通过跳过一些分支（*剪枝*这些分支）来提高性能，如果确定这些分支不会影响最终的最小-最大评估。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780064.png.jpg)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780064.png.jpg)'
- en: 'When would a branch in the game tree be unable to impact the final result?
    In order to understand how alpha-beta pruning works, look at the following picture,
    showing the game tree for a simple 2-by-2 board:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏树中的哪个分支无法影响最终结果？为了理解 alpha-beta 剪枝是如何工作的，请看以下图片，展示了简单 2x2 节点的游戏树：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783278.png.jpg)'
  id: totrans-876
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783278.png.jpg)'
- en: At the top of this picture is the starting position of the game. The arrows
    point to possible moves. Above each board it states which player (A or B) currently
    is making a move.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 图的上方是游戏的起始位置。箭头指向可能的移动。在每个棋盘上方都标明当前是哪个玩家（A 或 B）进行移动。
- en: The picture also shows the results of a minimax analysis of the game tree. On
    the bottom right of each board, you can see a number showing how our latest `get-ratings`
    function (with the new `score-board` logic) would rate that position. For leaf
    nodes (the boards along the very bottom), this number is calculated through `score-board`.
    For branch nodes, the number is calculated based on the minimax algorithm.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 图片还显示了游戏树的最小-最大分析结果。在每个棋盘的右下角，你可以看到一个数字，显示我们的最新 `get-ratings` 函数（带有新的 `score-board`
    逻辑）将如何评估该位置。对于叶节点（最底部的棋盘），这个数字是通过 `score-board` 计算得出的。对于分支节点，这个数字是基于最小-最大算法计算得出的。
- en: Every position in the game tree that allows a choice of moves is marked either
    as a MAX node or MIN node. Since the analysis in the picture is based on finding
    the best move for player A, all places allowing choices for player A are marked
    as MAX. All positions allowing choices for player B are marked as MIN. As you
    can see from the picture, this game is pretty unexciting, and there is only one
    position where player B actually has a choice of moves. In other words, only one
    MIN node exists in the game tree.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏树中每个允许选择移动的位置都被标记为 MAX 节点或 MIN 节点。由于图中分析是基于寻找玩家 A 的最佳移动，因此允许玩家 A 进行选择的所有位置都被标记为
    MAX。允许玩家 B 进行选择的所有位置都被标记为 MIN。从图中可以看出，这个游戏相当无趣，玩家 B 实际上只有一个移动选择的位置。换句话说，游戏树中只有一个
    MIN 节点。
- en: Working left to right, the minimax algorithm travels, depth first, exploring
    all the way down to the leaves. This is called a *depth-first search*. (We’re
    assuming no trimming is occurring, with `*ai-level*` set very high.) Then it chooses
    either the maximum or minimum scores for any nodes that have more than one branch.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右工作，最小-最大算法深度优先遍历，一直探索到叶节点。这被称为 *深度优先搜索*。（我们假设没有进行修剪，`*ai-level*` 设置得非常高。）然后它为具有多个分支的任何节点选择最大或最小分数。
- en: When it does this, the first (left) branch of the MIN node in the picture ends
    up with a score of 8\. If the AI engine now dips into the right branch, it really
    only cares what it finds there as long as the score remains below 8\. After all,
    the minimum of 8 and any larger number larger than 8 will still be 8, making such
    large numbers irrelevant to the eventual outcome of the calculation.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 当它这样做时，图中 MIN 节点的第一个（左侧）分支最终得分为 8。如果 AI 引擎现在进入右侧分支，它只关心在那里找到的内容，只要得分低于 8。毕竟，8
    和任何大于 8 的最小值仍然是 8，使得这些大数字对计算的最终结果无关紧要。
- en: As soon as the AI finds a node in the right branch that has a score of 8 (marked
    with a star in the picture), it knows the rest of the right branch is irrelevant
    and can be pruned away from our calculations. This means the minimax algorithm
    has no need to look at the branch in the tree marked with the dotted line in the
    picture.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 AI 在右侧分支找到一个得分为 8 的节点（图中用星号标记），它就知道右侧分支的其余部分是无关紧要的，可以从我们的计算中剪除。这意味着最小-最大算法不需要查看图中标记的虚线分支。
- en: This is a simple example, showing alpha-beta pruning in action. In the game
    tree shown in the picture, this pruning leads to only modest savings, since just
    a small number of the total nodes can be pruned. However, with larger game trees,
    the savings from alpha-beta pruning are typically immense, constituting a majority
    of the nodes in the game tree.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，展示了 alpha-beta 剪枝的实际应用。在图中显示的游戏树中，这种剪枝仅导致微小的节省，因为总共可以剪枝的节点数量很少。然而，对于更大的游戏树，alpha-beta
    剪枝的节省通常是巨大的，构成了游戏树中大多数节点。
- en: We’re going to take some liberties in how we implement alpha-beta pruning in
    our game to keep things simple. First, an alpha-beta pruning algorithm usually
    will pass around two variables called, naturally, `alpha` and `beta`.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的游戏中对alpha-beta剪枝的实现采取一些简化措施。首先，alpha-beta剪枝算法通常会传递两个变量，自然地称为 `alpha`
    和 `beta`。
- en: This is because it’s possible to write code that handles both the MAX nodes
    and MIN nodes at once by switching `alpha` and `beta` between the high and low
    limits. In our example, we’re going to use the variables `upper-limit` and `lower-limit`
    instead, indicating the highest and lowest values we care about as we traverse
    the game tree. As a cost, there will be some repetitive-looking code for handling
    the MAX and MIN cases. However, thinking of alpha-beta pruning in terms of `upper-limit`
    and `lower-limit` makes the code a bit easier to understand.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们可以编写一次处理MAX节点和MIN节点的代码，通过在高低限制之间切换 `alpha` 和 `beta`。在我们的例子中，我们将使用变量 `upper-limit`
    和 `lower-limit`，表示我们在遍历游戏树时关心的最高和最低值。作为代价，将会有一些看起来重复的代码来处理MAX和MIN情况。然而，将alpha-beta剪枝视为
    `upper-limit` 和 `lower-limit` 使得代码更容易理解。
- en: Another compromise we’re making is that we’re not decoupling the pruning code
    from the minimax code. Remember that with the trimming code, we wrote an independent
    function named `limit-tree-depth`, which separated the act of trimming from the
    rest of the AI code. We could use a similar approach for separating the alpha-beta
    pruning code as well, creating a function that can transform the game tree into
    a pruned version on its own. However, doing this is a bit more involved, because
    the alpha-beta pruning code must have access to intermediate minimax calculations.
    For a more advanced AI engine, this would be a good idea. For our simple engine,
    we will just add our alpha-beta pruning check directly inside our minimax functions.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出的另一个妥协是，我们没有将剪枝代码与最小-最大代码解耦。记住，在使用剪枝代码时，我们编写了一个独立的函数名为 `limit-tree-depth`，它将剪枝操作与AI代码的其他部分分离。我们同样可以采用类似的方法来分离alpha-beta剪枝代码，创建一个能够将游戏树转换为剪枝版本的函数。然而，这样做稍微复杂一些，因为alpha-beta剪枝代码必须能够访问中间的最小-最大计算。对于更高级的AI引擎，这是一个好主意。对于我们的简单引擎，我们将在最小-最大函数内部直接添加我们的alpha-beta剪枝检查。
- en: 'So let’s get started. First, we’ll rewrite our `get-ratings` function as two
    new functions: `ab-get-ratings-max` and `ab-get-ratings-min`.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。首先，我们将重写我们的 `get-ratings` 函数为两个新函数：`ab-get-ratings-max` 和 `ab-get-ratings-min`。
- en: Remember that the `get-ratings` function was responsible for calculating the
    best score out of multiple available moves from a single-board arrangement. Now,
    however, we want it to stop early in its evaluation of moves once it decides it
    has found a move that’s “as good as is possible.” Determining whether it has reached
    this point is subtly different depending on whether the node in question is a
    MAX move (a move of the current player) or a MIN move (a move for the opponent).
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`get-ratings` 函数负责计算从单板布局中多个可用走法中的最佳得分。然而，现在我们希望它在决定找到了“尽可能好”的走法后，能够提前停止对走法的评估。确定是否达到这一点取决于所讨论的节点是MAX走法（当前玩家的走法）还是MIN走法（对手的走法）。
- en: 'Let’s look at the version responsible for MAX nodes first:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看负责MAX节点的版本：
- en: '[PRE141]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We’re now passing in an extra `upper-limit` and `lower-limit` argument into
    `ab-get-ratings-max` ![](httpatomoreillycomsourcenostarchimages783564.png). This
    function won’t actually ever check the `lower-limit` argument directly, since
    it is concerned only with finding the maximum rating possible from the given location
    in the tree. However, it will pass this value on to child branches, which may
    contain MIN nodes that *do* care about the lower limit.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将额外的 `upper-limit` 和 `lower-limit` 参数传递给 `ab-get-ratings-max`！![图片](http://atomoreilly.com/source/no_starch_images/783564.png)。这个函数实际上永远不会直接检查
    `lower-limit` 参数，因为它只关心从树中的给定位置找到可能的最大评分。然而，它将这个值传递给子分支，这些分支可能包含关心下限的MIN节点。
- en: When we rate the next branch of the tree ![](httpatomoreillycomsourcenostarchimages783562.png)
    (by calling `ab-rate-position`, which we’ll write shortly), we save the result
    as `x`. If `x` is greater than or equal to our `upper-limit` ![](httpatomoreillycomsourcenostarchimages783560.png),
    we know we got a result as good as we can hope for, and can just return the latest
    rating as a final value in our list ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估树的下一个分支 ![树分支](http://atomoreilly.com/source/nostarch/images/783562.png)（通过调用
    `ab-rate-position`，我们很快就会编写这个函数），我们将结果保存为 `x`。如果 `x` 大于或等于我们的 `upper-limit` ![upper-limit](http://atomoreilly.com/source/nostarch/images/783560.png)，我们知道我们已经得到了我们所能期望的最好的结果，并且可以只将最新的评估值作为列表中的最终值返回
    ![列表中的最终值](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: If `x` isn’t large enough, we need to keep looking at the remaining branches
    ![](httpatomoreillycomsourcenostarchimages783510.png). Note that `x` will become
    the new `lower-limit` if it’s larger than the previous `lower-limit`.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `x` 不够大，我们需要继续查看剩余的分支 ![剩余的分支](http://atomoreilly.com/source/nostarch/images/783510.png)。注意，如果
    `x` 大于之前的 `lower-limit`，它将成为新的 `lower-limit`。
- en: 'Next, let’s look at the `ab-get-ratings-min` function:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `ab-get-ratings-min` 函数：
- en: '[PRE142]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `ab-get-ratings-min` function is basically identical to the `ab-get-ratings-max`
    function, except the roles of the upper and lower limits are flipped. Based on
    the repetitiveness of these two functions, you could probably imagine how the
    `ab-get-ratings-max` and `ab-get-ratings-min` functions could be combined into
    a single function. As mentioned earlier, with that approach, rather than `upper-limit`
    and `lower-limit`, you would use the more generic terms `alpha` and `beta`, as
    these will differ based on whether the node is a MAX node or a MIN node.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '`ab-get-ratings-min` 函数基本上与 `ab-get-ratings-max` 函数相同，除了上下限的角色互换了。基于这两个函数的重复性，你可以想象
    `ab-get-ratings-max` 和 `ab-get-ratings-min` 函数如何合并成一个函数。如前所述，采用这种方法，而不是 `upper-limit`
    和 `lower-limit`，你会使用更通用的术语 `alpha` 和 `beta`，因为这些将根据节点是 MAX 节点还是 MIN 节点而有所不同。'
- en: 'Next, we need to tweak `rate-position`, the function that rates a single-board
    arrangement:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调整 `rate-position` 函数，这是评估单板排列的函数：
- en: '[PRE143]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In our new `ab-rate-position`, we check if this node in the game tree is a move
    for us or a move for an opponent ![](httpatomoreillycomsourcenostarchimages783564.png).
    If it’s a move for us, then it’s a MAX node, and we want to dispatch to `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783562.png). If it’s the opponent’s
    turn, we instead dispatch to `ab-get-ratings-min` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Otherwise, `ab-rate-positon` is the same as our previous `rate-position` function.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新 `ab-rate-position` 中，我们检查游戏树中的这个节点是我们的一步棋还是对手的一步棋 ![对手的一步棋](http://atomoreilly.com/source/nostarch/images/783564.png)。如果是我们的棋，那么它是一个
    MAX 节点，我们希望调度到 `ab-get-ratings-max` ![ab-get-ratings-max](http://atomoreilly.com/source/nostarch/images/783562.png)。如果是对手的回合，我们则调度到
    `ab-get-ratings-min` ![ab-get-ratings-min](http://atomoreilly.com/source/nostarch/images/783560.png)。否则，`ab-rate-position`
    与我们之前的 `rate-position` 函数相同。
- en: 'To complete our support for alpha-beta pruning, we need to modify one more
    function: the `handle-computer` function that kicks off our minimax calculations:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们对 alpha-beta 剪枝的支持，我们需要修改另一个函数：启动我们的最小-最大计算的 `handle-computer` 函数：
- en: '[PRE144]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This function starts off the minimax calculation by calling `ab-get-ratings-max`
    ![](httpatomoreillycomsourcenostarchimages783564.png), since the first move most
    definitely belongs to the target player and therefore is a MAX node.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过调用 `ab-get-ratings-max` ![ab-get-ratings-max](http://atomoreilly.com/source/nostarch/images/783564.png)
    开始最小-最大计算，因为第一步肯定属于目标玩家，因此是一个 MAX 节点。
- en: When we call this function, we’ll need to pass in our starting `upper-limit`
    and `lower-limit`. Since we’re at the very beginning of our minimax searching,
    we’ll want to set these to be as large and as small as possible. Ideally, we would
    want them to be *positive infinity* and *negative infinity*. Although many Lisp
    environments contain support for such concepts, they are not part of the ANSI
    Common Lisp standard. However, the standard does define `most-positive-fixnum`
    and `most-negative-fixnum`, which are very large positive and negative numbers,
    making them perfectly suited for our purposes. Hence, we pass these into `ab-get-ratings-max`
    to start off our limits ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们需要传入我们的起始`upper-limit`和`lower-limit`。由于我们处于minimax搜索的非常开始阶段，我们希望将这些设置得尽可能大和尽可能小。理想情况下，我们希望它们是*正无穷大*和*负无穷大*。尽管许多Lisp环境包含对这些概念的支持，但它们不是ANSI
    Common Lisp标准的一部分。然而，标准确实定义了`most-positive-fixnum`和`most-negative-fixnum`，它们是非常大的正数和负数，非常适合我们的目的。因此，我们将这些传递给`ab-get-ratings-max`以开始我们的限制！[](http://atomoreilly.com/source/nostarch/images/783562.png)！[](http://atomoreilly.com/source/nostarch/images/783560.png)。
- en: If we wanted to squeeze out a tad more efficiency from our AI engine, we could,
    instead, set the `upper-limit` and `lower-limit` to be the maximum and minimum
    values from our `score-board` function. That would slightly improve the amount
    of pruning that is possible. However, the `score-board` function may return a
    different range of scores based on the size of the board. and it might have other
    dependencies if we decide to optimize board scoring even more in the future. Therefore,
    it is best for the time being if we set our limits to nigh infinity for the start
    of our minimax calculations so we don’t need to worry about this.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从我们的AI引擎中挤出更多效率，我们可以，相反，将`upper-limit`和`lower-limit`设置为`score-board`函数的最大值和最小值。这将略微提高可能进行的剪枝量。然而，`score-board`函数可能会根据棋盘的大小返回不同的分数范围，并且如果我们决定在未来进一步优化棋盘评分，它可能还有其他依赖项。因此，目前最好的做法是在我们的minimax计算开始时将我们的限制设置为接近无限大，这样我们就不必担心这个问题。
- en: 'As a final reward for once again improving the performance of our AI, let’s
    increase the size of the board to use a 5-by-5 game field. With our new lazy,
    trimmed, and pruned AI algorithms, we should be able to handle this larger board
    without a sweat:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 作为再次提高我们AI性能的最终奖励，让我们将棋盘的大小增加到5x5游戏区域。使用我们新的懒、修剪和剪枝AI算法，我们应该能够轻松地处理这个更大的棋盘：
- en: '[PRE145]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that we used memoization for some of our earlier functions. If you
    have already played some games in this chapter on a 4-by-4 board, one function
    in particular, the `neighbors` function, may return results based on this old
    board size. This is only an issue if you’ve already played a game on the 4-by-4
    board without restarting your Lisp in the interim. To fix this, simply rerun the
    definition of the `neighbors` function in `dice_of_doom_v1.lisp` from the REPL
    (including the memoized revision at the bottom of the file) to clear any cached
    results.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们为一些早期的函数使用了记忆化。如果你已经在4x4棋盘上玩了一些游戏，特别是`neighbors`函数，可能会根据这个旧的棋盘大小返回结果。这仅在你已经在这个4x4棋盘上玩过游戏并且在此期间没有重新启动Lisp的情况下才是问题。为了解决这个问题，只需在REPL中重新运行`dice_of_doom_v1.lisp`中`neighbors`函数的定义（包括文件底部的记忆化修订版）以清除任何缓存的计算结果。
- en: 'Here’s what our game looks like now:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看我们的游戏是什么样子：
- en: '[PRE146]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: At this point, our REPL game interface is becoming really impractical for such
    a large game field. We’ll be addressing that next.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的REPL游戏界面对于如此大的游戏区域来说变得非常不实用。我们将在下一节解决这个问题。
- en: What You've Learned
  id: totrans-912
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到的内容
- en: 'In this chapter, we made the computer player for our Dice of Doom game much
    more sophisticated. We implementing the game tree using lazy lists, and applied
    several optimization techniques to limit the number of board positions that are
    searched by the AI engine. Along the way, you learned the following:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使我们的“末日骰子”游戏计算机玩家变得更加复杂。我们使用懒列表实现游戏树，并应用了多种优化技术来限制AI引擎搜索的棋盘位置数量。在这个过程中，你学习了以下内容：
- en: '*Lazy programming* allows you to work with very large (and even infinite) data
    structures and do so efficiently.'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*懒编程*允许你以高效的方式处理非常大的（甚至无限的）数据结构。'
- en: Once you have a `lazy` macro and a `force` function, you can use them to build
    more sophisticated lazy operations, including building a lazy list library.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你有了`lazy`宏和`force`函数，你可以使用它们来构建更复杂的懒操作，包括构建懒列表库。
- en: Heuristics are imperfect algorithms that can be used to improve the performance
    of your code, with some creative thinking. In our example, we made some heuristic
    changes to how we score leaf nodes.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启发式算法是不完美的算法，可以通过一些创造性思维来提高代码的性能。在我们的例子中，我们对评分叶节点的启发式方法进行了一些更改。
- en: Once we converted Dice of Doom to use a lazy tree, we were able to elegantly
    trim the game tree in order to limit how deep the AI thinks when contemplating
    its moves.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们将“末日骰子”转换为使用懒树，我们就能优雅地修剪游戏树，以限制 AI 在考虑其移动时的思考深度。
- en: Alpha-beta pruning lets us improve performance even more, by pruning branches
    that have no way of impacting the final scores on the moves being considered by
    the AI.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpha-beta 剪枝让我们能够进一步改进性能，通过剪枝那些无法影响 AI 考虑的移动最终得分的分支。
- en: Chapter 19. Creating a Graphical, Web-Based Version of Dice of Doom
  id: totrans-919
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 19 章：创建基于网页的“末日骰子”图形版本
- en: In the previous chapter, we created a second version of Dice of Doom to play
    on larger game boards. It has become quite difficult to understand the board and
    make moves using our crude console interface. Certainly, Dice of Doom would be
    infinitely better if we had a pretty graphical game board that allowed us to simply
    click where we wanted to make our moves. Well, I have good news for you . . .
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们创建了“末日骰子”的第二个版本，用于在更大的游戏板上进行游戏。使用我们粗糙的控制台界面来理解和移动变得相当困难。当然，如果有一个漂亮的图形游戏板，我们可以简单地点击想要移动的位置，那么“末日骰子”将变得无限好。好消息是……
- en: In this chapter, we’ll put together a lot of code from earlier chapters to transform
    Dice of Doom into a full-featured, graphical game you can play right inside a
    web browser!
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从早期章节中收集大量代码，将“末日骰子”转换成一个可以在网页浏览器中直接玩的全功能图形游戏！
- en: Drawing the Game Board Using the SVG Format
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SVG 格式绘制游戏板
- en: We’ve already written a primitive web server in [Chapter 13](ch14.html "Chapter 13. Let's
    Create a Web Server!"). Also, we’ve covered how to draw SVG graphics with a DSL
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages"). Lucky for
    us, the new HTML5 standard includes features that make it possible to embed SVG
    pictures directly inside a standard HTML document. In this way, we’ll be able
    to use our simple little web server to serve up some fully interactive vector
    graphics. You’ll be amazed at how easy it is to do this.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [第 13 章](ch14.html "第 13 章。让我们创建一个网络服务器！") 中编写了一个原始的网络服务器。此外，我们在 [第 17
    章](ch19.html "第 17 章。领域特定语言") 中介绍了如何使用 DSL 绘制 SVG 图形。幸运的是，新的 HTML5 标准包括一些功能，使得直接在标准
    HTML 文档中嵌入 SVG 图片成为可能。这样，我们将能够使用我们简单的网络服务器来提供一些完全交互式的矢量图形。您将惊讶于做这件事有多容易。
- en: Note
  id: totrans-924
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time this book was written, the only web browser to support inline SVG
    within HTML was Firefox 3.7 Alpha. Use this, or a more recent release of Firefox
    with our new version of Dice of Doom. If you’re having problems, try navigating
    to the about:config page in the Firefox address bar, and set the html5.enable
    configuration setting to true. This will allow Firefox to use the latest HTML5
    settings.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书编写时，唯一支持在 HTML 中内联 SVG 的网络浏览器是 Firefox 3.7 Alpha。请使用这个版本，或者使用 Firefox 的较新版本与我们的新版本“末日骰子”。如果您遇到问题，请尝试在
    Firefox 地址栏中导航到 about:config 页面，并将 html5.enable 配置设置设置为 true。这将允许 Firefox 使用最新的
    HTML5 设置。
- en: Also, remember that our web server library is not pure ANSI Common Lisp, and
    makes use of some CLISP-specific extensions. This means it requires CLISP to function.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，我们的网络服务器库不是纯 ANSI Common Lisp，而是使用了某些 CLISP 特定扩展。这意味着它需要 CLISP 才能运行。
- en: First, we’ll need to pull in code from various other chapters to get ready.
    In the previous chapter, we created version 2 of our Dice of Doom engine. Place
    all the code from that chapter in a file named *dice_of_doom_v2.lisp*. You should
    also already have created a file named *webserver.lisp* from [Chapter 13](ch14.html
    "Chapter 13. Let's Create a Web Server!"). (These files are all freely available
    from [http://landoflisp.com/](http://landoflisp.com/).)
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从其他章节中提取代码，为准备工作做好准备。在前一章中，我们创建了“末日骰子”引擎的第二个版本。将那一章的所有代码放入名为 *dice_of_doom_v2.lisp*
    的文件中。您也应该已经从 [第 13 章](ch14.html "第 13 章。让我们创建一个网络服务器！") 中创建了一个名为 *webserver.lisp*
    的文件。（这些文件都可以从 [http://landoflisp.com/](http://landoflisp.com/) 免费获取。）
- en: 'Let’s load in these files:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载这些文件：
- en: '[PRE147]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For our SVG support, we’ll also need the SVG-rendering code from [Chapter 16](ch18.html
    "Chapter 16. The Magic of Lisp Macros") and [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages"). Place those functions in *svg.lisp*. (This file is also available
    from [http://landoflisp.com/](http://landoflisp.com/).) For reference, the functions
    we’ll need are `let1`, `split`, `pairs`, `print-tag`, `tag`, `svg`, `brightness`,
    `svg-style`, and `polygon`. Load this file next:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 SVG 支持，我们还需要第 16 章 ![ch18.html "第 16 章。Lisp 宏的魔力"] 和第 17 章 ![ch19.html
    "第 17 章。领域特定语言"] 中的 SVG 渲染代码。将这些函数放在 `svg.lisp` 中。（此文件也可从 [http://landoflisp.com/](http://landoflisp.com/)
    获取。）作为参考，我们需要的功能有 `let1`、`split`、`pairs`、`print-tag`、`tag`、`svg`、`brightness`、`svg-style`
    和 `polygon`。接下来加载此文件：
- en: '[PRE148]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Now let’s write some code that can draw a pretty version of our game board
    using SVG. First, we’ll want to define some constants that control the various
    dimensions needed to draw the board:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一些代码，使用 SVG 绘制我们游戏板的漂亮版本。首先，我们需要定义一些常量来控制绘制板所需的各种尺寸：
- en: '[PRE149]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The board width and height will be 900-by-500 pixels, which is a good size for
    playing a game in a browser on most people’s computer screens. The board scale
    ![](httpatomoreillycomsourcenostarchimages783564.png) represents half the width
    of a single hex on the screen in pixels. The `*top-offset*` variable ![](httpatomoreillycomsourcenostarchimages783562.png)
    tells us we want three extra hex heights of free space above the base of the board.
    We’ll need this because a hex with lot of dice on it will have its dice sticking
    out, upward, and we need room for these dice to be visible on the screen. The
    `*dice-scale*` variable ![](httpatomoreillycomsourcenostarchimages783560.png)
    tells us that a single die will be about 40 pixels tall and wide on the screen.
    Finally, we set `*dot-size*` to `0.05`, which tells us that each dot will be about
    0.05 times the size of a die ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 板的宽度和高度将是 900x500 像素，这对于在大多数人的电脑屏幕上玩游戏来说是一个很好的尺寸。板的比例 ![http://atomoreilly.com/source/no_starch_images/783564.png]
    表示屏幕上单个六边形的宽度的一半（以像素为单位）。`*top-offset*` 变量 ![http://atomoreilly.com/source/no_starch_images/783562.png]
    告诉我们我们希望在板的底部上方有额外的三个六边形高度的空间。我们需要这个空间，因为一个上面有很多骰子的六边形，其骰子会向上突出，我们需要空间让这些骰子在屏幕上可见。`*dice-scale*`
    变量 ![http://atomoreilly.com/source/no_starch_images/783560.png] 告诉我们单个骰子在屏幕上大约高宽
    40 像素。最后，我们将 `*dot-size*` 设置为 `0.05`，这意味着每个点将是骰子大小的 0.05 倍 ![http://atomoreilly.com/source/no_starch_images/783554.png]。
- en: Drawing a Die
  id: totrans-935
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制骰子
- en: 'Now we’re ready to write a function that can draw a die. Note that we won’t
    use bitmaps or anything like that to draw. Instead, we’re drawing a die “the hard
    way,” by rendering it directly out of raw SVG polygons. Here’s the code:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写一个可以绘制骰子的函数。请注意，我们不会使用位图或类似的东西来绘制。相反，我们将通过直接从原始 SVG 多边形渲染骰子“硬”方法来绘制骰子。以下是代码：
- en: '[PRE150]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: To draw a die, we need to pass in three arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    The first two are the x and y position at which the die should appear in the SVG
    picture. The third is the color we want the die to be. This function will take
    some liberties with that color and modify it as needed to give the die a little
    shading.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个骰子，我们需要传递三个参数 ![http://atomoreilly.com/source/no_starch_images/783564.png]。前两个是骰子在
    SVG 图片中应出现的位置的 x 和 y 坐标。第三个是我们想要骰子的颜色。这个函数将对那个颜色做一些自由处理，并根据需要修改它，以给骰子一点阴影。
- en: Anything we draw in this function will need to be rendered in a scaled fashion,
    based on the `*dice-scale*` constant we defined. Therefore, we first define a
    local function `calc-pt` that scales a point for us ![](httpatomoreillycomsourcenostarchimages783562.png).
    Since we’ll need to draw several scaled polygons, let’s also create a convenience
    function, `f`, that runs `calc-pt` against all points in a polygon and then draws
    it by calling the `polygon` function ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中我们绘制的任何内容都需要根据我们定义的 `*dice-scale*` 常量进行缩放渲染。因此，我们首先定义一个局部函数 `calc-pt`，它为我们缩放一个点
    ![http://atomoreilly.com/source/no_starch_images/783562.png]。由于我们需要绘制几个缩放的多边形，让我们也创建一个便利函数
    `f`，它对多边形中的所有点运行 `calc-pt`，然后通过调用 `polygon` 函数 ![http://atomoreilly.com/source/no_starch_images/783560.png]
    来绘制它。
- en: 'A die in our picture will have three visible faces: the top face, the front
    face, and the right face. We draw these by calling our function `f` three times
    starting here ![](httpatomoreillycomsourcenostarchimages783554.png) and using
    some hard-coded coordinates for the three faces.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 我们图片中的骰子将有三个可见的面：顶面、前面和右面。我们通过三次调用我们的函数 `f` 来绘制这些面，从这里开始 ![http://atomoreilly.com/source/no_starch_images/783554.png]，并使用一些硬编码的坐标来绘制三个面。
- en: The last thing we need to do is draw the little dots on the faces of the die.
    We do this by `mapcing` ![](httpatomoreillycomsourcenostarchimages783510.png)
    the coordinates for the dots ![](httpatomoreillycomsourcenostarchimages783544.png)
    against a lambda function that can render a dot. This lambda function uses the
    `*dot-size*` variable to scale down a square-shaped polygon that represents each
    dot on the die face. We could write more sophisticated code to draw circular and/or
    elliptical dots, but the dots are so small that squares look just fine.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是在骰子的面上绘制小圆点。我们通过 `mapcing` ![httpatomoreillycomsourcenostarchimages783510.png](httpatomoreillycomsourcenostarchimages783510.png)
    小圆点的坐标与一个可以渲染点的lambda函数进行映射 ![httpatomoreillycomsourcenostarchimages783544.png](httpatomoreillycomsourcenostarchimages783544.png)。这个lambda函数使用
    `*dot-size*` 变量来缩小代表骰子面上每个点的正方形多边形。我们可以编写更复杂的代码来绘制圆形和/或椭圆形的点，但点非常小，正方形看起来就很好。
- en: 'Let’s try drawing a die at x=50 and y=50 with an RGB red `(255 0 0)` color:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在x=50和y=50的位置用RGB红色 `(255 0 0)` 绘制一个骰子：
- en: '[PRE151]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If you want to see what the final die looks like, just save this gobbledygook
    to a file named *die.svg*. Then load the result in Firefox, where you should see
    the following picture (shown at a blown-up size):'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看看最终的骰子是什么样子，只需将这个乱七八糟的东西保存到一个名为 *die.svg* 的文件中。然后在Firefox中加载这个结果，你应该会看到以下图片（放大显示）：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782140.png.jpg)'
  id: totrans-945
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages782140.png.jpg)'
- en: Drawing a Tile
  id: totrans-946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制格子
- en: 'Next, let’s write the function to draw an entire hex tile, including the base
    and the dice on the tile:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写一个函数来绘制整个六边形格子，包括基础和格子上的骰子：
- en: '[PRE152]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: This function takes in a lot of parameters, because a lot of information is
    encoded in a single tile of the board. You’ll learn the precise meaning of each
    of these parameters when we draw the board in the next section.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收很多参数，因为很多信息都编码在棋盘的单个格子中。当我们下一节绘制棋盘时，你会了解到这些参数的精确含义。
- en: First, our `draw-tile-svg` function draws the base. To give the base a mild
    3D look, we’ll draw it twice, with one level stacked on top of the other. Here
    ![](httpatomoreillycomsourcenostarchimages783564.png) is the loop that draws the
    two bases. Within that loop, we need to draw a hexagonal polygon ![](httpatomoreillycomsourcenostarchimages783562.png).
    We map a scaling function across the coordinates so that they are scaled to our
    `*board-scale*` variable. Here ![](httpatomoreillycomsourcenostarchimages783560.png)
    you can see the six points of a hexagon in perspective encoded using decimal notation.
    The color of the base will be brightened slightly if it has been chosen by the
    player to perform a move. We do this by increasing the brightness of the tile
    when creating our polygons ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的 `draw-tile-svg` 函数绘制基础。为了给基础一个轻微的3D效果，我们将绘制两次，一层堆叠在另一层之上。这里 ![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png)
    是绘制两个基础的循环。在这个循环内部，我们需要绘制一个六边形多边形 ![httpatomoreillycomsourcenostarchimages783562.png](httpatomoreillycomsourcenostarchimages783562.png)。我们将缩放函数映射到坐标上，以便它们缩放到我们的
    `*board-scale*` 变量。这里 ![httpatomoreillycomsourcenostarchimages783560.png](httpatomoreillycomsourcenostarchimages783560.png)
    你可以看到使用十进制表示法编码的六边形的六个点。如果玩家选择该基础进行移动，基础的颜色会稍微变亮。我们通过在创建多边形时增加格子的亮度来实现这一点 ![httpatomoreillycomsourcenostarchimages783554.png](httpatomoreillycomsourcenostarchimages783554.png)。
- en: After we’ve finished drawing the tile base, we need to draw the dice that reside
    on the tile. We do this by looping across the number of dice ![](httpatomoreillycomsourcenostarchimages783510.png)
    and then calling our `draw-die-svg` function ![](httpatomoreillycomsourcenostarchimages783544.png).
    When calculating the x and y positions of the dice, we need to perform a bit of
    scaling math. The most interesting piece of this math is that we shift the dice
    a bit to the left or right, depending on whether the sum of the x-, y-, and z-coordinates
    for a given die is odd or even ![](httpatomoreillycomsourcenostarchimages783556.png).
    This makes the stacks look a little imperfect and will give the stacked dice for
    the complete board a pleasing, natural appearance.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成绘制格子基础之后，我们需要绘制位于格子上的骰子。我们通过遍历骰子的数量 ![httpatomoreillycomsourcenostarchimages783510.png](httpatomoreillycomsourcenostarchimages783510.png)
    并调用我们的 `draw-die-svg` 函数 ![httpatomoreillycomsourcenostarchimages783544.png](httpatomoreillycomsourcenostarchimages783544.png)
    来完成这个任务。在计算骰子的x和y位置时，我们需要进行一些缩放数学运算。这个数学运算中最有趣的部分是我们根据给定骰子的x、y和z坐标之和是奇数还是偶数，稍微向左或向右移动骰子
    ![httpatomoreillycomsourcenostarchimages783556.png](httpatomoreillycomsourcenostarchimages783556.png)。这使得堆叠看起来有点不完美，并且会给整个棋盘的堆叠骰子带来令人愉悦、自然的外观。
- en: Now let’s call our function to draw a finished tile and see how it looks. Again,
    just copy the output from this command to a file named something like *tile.svg*.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用我们的函数来绘制一个完成的瓷砖，看看它的样子。同样，只需将此命令的输出复制到一个名为 *tile.svg* 的文件中。
- en: '[PRE153]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Here’s what you should see when looking at the file in Firefox:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Firefox 中查看文件时，你应该看到以下内容：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782446.png.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782446.png.jpg)'
- en: Drawing the Board
  id: totrans-956
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制游戏板
- en: Now we’re ready to write a function that draws an entire game board as an SVG.
    It will be very similar to our `draw-board` function, which we’ve been using to
    draw the board to the console. It fulfills the same role, but simply outputs the
    result as SVG data.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写一个函数，将整个游戏板作为 SVG 绘制出来。它将非常类似于我们用来将游戏板绘制到控制台的 `draw-board` 函数。它扮演着相同的角色，但只是将结果输出为
    SVG 数据。
- en: '[PRE154]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `draw-board-svg` function takes the board as an argument, but also requires
    two other arguments that will be important for using the picture as the front
    end of the user interface for our game ![](httpatomoreillycomsourcenostarchimages783564.png).
    One argument is `chosen-tile`, which indicates a tile that the player has clicked
    with the mouse. We’re going to color that tile a bit lighter, so the player can
    tell that the computer has recognized the selection. Another argument is `legal-tiles`,
    which indicates which tiles the player can legally click next.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw-board-svg` 函数接受游戏板作为参数，但还需要两个其他参数，这对于将图片用作我们游戏用户界面的前端非常重要！其中一个参数是 `chosen-tile`，它指示玩家用鼠标点击的瓷砖。我们将使该瓷砖的颜色稍微亮一些，这样玩家就可以知道计算机已经识别了选择。另一个参数是
    `legal-tiles`，它指示玩家可以合法点击的瓷砖。'
- en: It so happens that SVG pictures have a feature for web links, which works just
    like the `<a href="...">` hyperlinks in regular HTML. If a tile is a legal tile
    for the player’s next move, we’ll wrap the SVG for that tile in such a link, making
    it clickable. Having the `legal-tiles` parameter lets us know which tiles we want
    to be clickable.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 偶然的是，SVG 图片有一个用于网页链接的功能，它的工作方式与常规 HTML 中的 `<a href="...">` 超链接类似。如果一个瓷砖是玩家下一步合法的瓷砖，我们将用这样的链接包裹该瓷砖的
    SVG，使其可点击。拥有 `legal-tiles` 参数让我们知道我们想要哪些瓷砖是可点击的。
- en: The `draw-board-svg` function consists of a couple of nested loops that loop
    through the `y` ![](httpatomoreillycomsourcenostarchimages783562.png) and `x`
    ![](httpatomoreillycomsourcenostarchimages783560.png) coordinates of the tile
    board. For each tile, we then define a ton of local variables (using the facility
    for local variables in the `loop` macro introduced in [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")). First, we declare `pos` ![](httpatomoreillycomsourcenostarchimages783554.png),
    which indicates the position of current tile in the hex array. Then we fetch that
    hex. Next, we calculate the pixel coordinates for the tiles, in the variables
    `xx` and `yy`. As you can see, the math for these coordinates gets a bit tricky,
    since the board is drawn in perspective on the screen.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw-board-svg` 函数由几个嵌套循环组成，这些循环遍历瓷砖板的 `y` 和 `x` 坐标。对于每个瓷砖，我们定义大量局部变量（使用在第
    10 章中引入的 `loop` 宏提供的局部变量功能）。首先，我们声明 `pos`，它指示当前瓷砖在六边形数组中的位置。然后我们获取那个六边形。接下来，我们计算瓷砖的像素坐标，存储在变量
    `xx` 和 `yy` 中。如您所见，这些坐标的数学计算有点复杂，因为游戏板在屏幕上是按透视绘制的。'
- en: The final local variable we define is `col`, which will hold the color of the
    tile and dice in the current spot. We do this by using a list of die colors, which
    currently holds the colors red (for player A) and blue (for player B). We also
    darken the color a bit based on the y-coordinate using the `brightness` function
    (discussed in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages")).
    This darkens the rows in the back a bit, adding to the 3D appearance of our SVG
    game board.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的最后一个局部变量是 `col`，它将保存当前位置瓷砖和骰子的颜色。我们通过使用一个包含骰子颜色的列表来完成此操作，目前该列表包含红色（代表玩家
    A）和蓝色（代表玩家 B）。我们还根据 y 坐标使用 `brightness` 函数（在第 17 章中讨论）稍微加深颜色，这会使背景行变暗，增加我们 SVG
    游戏板的 3D 效果。
- en: If the current tile is a member of the legal tiles ![](httpatomoreillycomsourcenostarchimages783510.png),
    we’re going to wrap it in a web link, as mentioned previously. In SVG, this is
    done with a tag in the form `<a xlink:href="...">`, which we create here ![](httpatomoreillycomsourcenostarchimages783544.png).
    Notice that we also wrap each tile in a `<g>` tag, which tells the SVG renderer
    to treat the polygons in this tile as a group. To figure out the actual URL we
    want to link to, we call the `make-game-link` function. This function builds an
    appropriate URL. You’ll understand the format of the URL better once we start
    writing the code that handles the web server for our game.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前瓷砖是合法瓷砖的成员 ![image](httpatomoreillycomsourcenostarchimages783510.png)，我们将像之前提到的那样将其包装在一个网络链接中。在SVG中，这是通过创建一个形式为`<a
    xlink:href="...">`的标签来完成的，我们在这里创建它 ![image](httpatomoreillycomsourcenostarchimages783544.png)。请注意，我们还把每个瓷砖包装在一个`<g>`标签中，这告诉SVG渲染器将这个瓷砖中的多边形视为一个组。为了确定我们想要链接的实际URL，我们调用`make-game-link`函数。这个函数构建一个合适的URL。一旦我们开始编写处理我们游戏网络服务器的代码，你将更好地理解URL的格式。
- en: 'Finally, we’re ready to call our `draw-tile` function ![](httpatomoreillycomsourcenostarchimages783556.png).
    There are two different versions of the call in our code: one for the hyperlinked
    version and one for the nonlinked version.'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备调用我们的`draw-tile`函数 ![image](httpatomoreillycomsourcenostarchimages783556.png)。在我们的代码中，有两个不同的调用版本：一个用于超链接版本，另一个用于非链接版本。
- en: 'Phew! Now we can finally draw a full game board dynamically, using the SVG
    format:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸！现在我们终于可以使用SVG格式动态地绘制一个完整的游戏板了：
- en: '[PRE155]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'If you save the output to *board.svg* and load it in Firefox, here is what
    you should see:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将输出保存为`board.svg`并在Firefox中加载它，你应该看到以下内容：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781682.png.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781682.png.jpg)'
- en: Building the Web Server Interface
  id: totrans-969
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建网络服务器界面
- en: Now that we’ve completed the graphical side of Dice of Doom version 3, we’re
    ready to write the side that interfaces with the web server.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了Dice of Doom版本3的图形部分，我们准备编写与网络服务器交互的部分。
- en: Writing Our Web Request Handler
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们的网络请求处理器
- en: 'The central function for our web server handling is called `dod-request-handler`.
    It is the function that we can pass to the `serve` command in our web server library,
    and it is responsible for handling all the web requests coming from the web browser.
    Here is the code for `dod-request-handler`:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网络服务器处理的核心函数名为`dod-request-handler`。它是我们可以传递给网络服务器库中的`serve`命令的函数，并且负责处理来自网络浏览器的所有网络请求。以下是`dod-request-handler`的代码：
- en: '[PRE156]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: First, this function checks whether the current page being fetched from the
    web server is `game.html` ![](httpatomoreillycomsourcenostarchimages783564.png).
    This is the page where our game will reside on the web server. At the top of the
    page, we specify the `doctype` ![](httpatomoreillycomsourcenostarchimages783562.png).
    When done in this way, it tells the web browser to expect an HTML5-encoded web
    page. Then we put in some simple HTML to center the page and print a welcome message
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数检查从网络服务器获取的当前页面是否是`game.html` ![image](httpatomoreillycomsourcenostarchimages783564.png)。这是我们游戏将在网络服务器上驻留的页面。在页面的顶部，我们指定`doctype`
    ![image](httpatomoreillycomsourcenostarchimages783562.png)。以这种方式完成时，它告诉网络浏览器预期一个HTML5编码的网页。然后我们添加一些简单的HTML来居中页面并打印一个欢迎信息
    ![image](httpatomoreillycomsourcenostarchimages783560.png)。
- en: The `params` passed from the web server library may contain an important value
    named `chosen`, which we fetch using this line ![](httpatomoreillycomsourcenostarchimages783554.png).
    If there is no chosen tile, or if the game tree is currently empty ![](httpatomoreillycomsourcenostarchimages783510.png),
    it means the player must be starting a brand-new game. If that’s the case, we
    will call a function named `web-initialize` ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络服务器库传递的`params`可能包含一个名为`chosen`的重要值，我们可以使用此行来获取它 ![image](httpatomoreillycomsourcenostarchimages783554.png)。如果没有选中的瓷砖，或者如果游戏树当前为空
    ![image](httpatomoreillycomsourcenostarchimages783510.png)，这意味着玩家必须是在开始一个全新的游戏。如果是这种情况，我们将调用名为`web-initialize`的函数
    ![image](httpatomoreillycomsourcenostarchimages783544.png)。
- en: Next, we need to find out whether the game has ended. We can tell this by checking
    if the list of moves is empty (which, as you might remember, is stored in the
    `caddr` location of the tree). In that case, we’ll announce a winner ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出游戏是否已经结束。我们可以通过检查移动列表是否为空（你可能记得，这是存储在树的`caddr`位置）来判断这一点。在这种情况下，我们将宣布一个获胜者
    ![image](httpatomoreillycomsourcenostarchimages783556.png)。
- en: Following that, we need to see if the current player is player zero, which means
    the player is the human player. In that case, we’ll call the function `web-handle-human`
    ![](httpatomoreillycomsourcenostarchimages783566.png) to build the rest of the
    HTML data in the body of the page. We also use the `read-from-string` function
    to pull the number of the chosen tile from the `chosen` parameter, if it exists.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们需要检查当前玩家是否是玩家零，这意味着玩家是人类玩家。在这种情况下，我们将调用函数 `web-handle-human` ![更多关于奥莱利](http://atomoreilly.com/source/no_starch_images/783566.png)
    来构建页面主体中的剩余 HTML 数据。我们同样使用 `read-from-string` 函数从 `chosen` 参数中提取所选瓷砖的编号，如果它存在的话。
- en: In all other cases, we know we’re dealing with a computer player and hand over
    control to `web-handle-computer` ![](httpatomoreillycomsourcenostarchimages783498.png)
    to build the rest of the HTML.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，我们知道我们正在处理一个电脑玩家，并将控制权交给 `web-handle-computer` ![更多关于奥莱利](http://atomoreilly.com/source/no_starch_images/783498.png)
    来构建剩余的 HTML。
- en: Lastly, the `dod-request-handler` function needs to call the `draw-dod-page`
    function to draw the game board, which we do here ![](httpatomoreillycomsourcenostarchimages783062.png).
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`dod-request-handler` 函数需要调用 `draw-dod-page` 函数来绘制游戏板，我们在这里完成 ![更多关于奥莱利](http://atomoreilly.com/source/no_starch_images/783062.png)。
- en: Limitations of Our Game Web Server
  id: totrans-980
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们游戏服务器的局限性
- en: The limitations of our game web server are quite significant. First of all,
    for simplicity’s sake, the `dod-request-handler` function makes absolutely no
    effort to try to determine from whom the web request is coming. It behaves as
    if all game interactions were coming from a single player, and therefore isn’t
    a true multiplayer server for Dice of Doom. If multiple players were to try to
    play different games at the same time, the `dod-request-handler` would get confused
    and *bad things* would happen.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏服务器的局限性相当显著。首先，为了简化起见，`dod-request-handler` 函数根本不尝试确定网络请求来自何方。它表现得好像所有游戏交互都来自单个玩家，因此对于《末日骰子》来说，它不是一个真正的多人服务器。如果多个玩家同时尝试玩不同的游戏，`dod-request-handler`
    会感到困惑，并且会发生*不好的事情*。
- en: It would not be too difficult to expand `dod-request-handler` into a true web
    server for multiple, parallel games. To do this, we would need to pull session
    information out of the header data it receives as an argument from the web server,
    and then all variables it references (such as `*cur-game-tree*`, for instance)
    would need to live in a hash table, using the session information as a key. This
    way, each player would have her own game tree, and our engine could then serve
    multiple games in parallel. The implementation of such a multigame version of
    the `dod-request-handler` is “an exercise for the reader.”
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dod-request-handler` 扩展成一个真正的支持多个、并行游戏的网络服务器并不困难。为此，我们需要从它从网络服务器接收的作为参数的头部数据中提取会话信息，然后所有引用的变量（例如
    `*cur-game-tree*` 等）都需要存储在散列表中，使用会话信息作为键。这样，每位玩家都会有自己的游戏树，然后我们的引擎就可以并行服务多个游戏。这种多游戏版本的
    `dod-request-handler` 的实现是“留给读者的练习。”
- en: Another limitation of `dod-request-handler` is that it reads information from
    the URL using the `read-from-string` function. As you’ve learned in earlier chapters,
    this function can be compromised to run arbitrary code in the hands of an experienced
    (and evil) Lisper.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '`dod-request-handler` 的另一个局限性是它使用 `read-from-string` 函数从 URL 中读取信息。正如你在前面的章节中学到的，这个函数可以被破坏，在经验丰富（且邪恶）的
    Lisp 程序员手中运行任意代码。'
- en: Initializing a New Game
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化新游戏
- en: 'Here is the `web-initialize` function, which initializes our game engine to
    start a brand-new game of Dice of Doom:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `web-initialize` 函数，它初始化我们的游戏引擎以开始一场全新的《末日骰子》游戏：
- en: '[PRE157]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: As you can see, it generates a random game board, builds a tree from it, and
    then stores the result in the global `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，它生成一个随机的游戏板，从中构建一棵树，然后将结果存储在全局变量 `*cur-game-tree*` 中 ![更多关于奥莱利](http://atomoreilly.com/source/no_starch_images/783564.png)。
- en: Announcing a Winner
  id: totrans-988
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宣布获奖者
- en: 'Here is the function that announces the winner within the web browser:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是宣布获胜者的函数，它是在网页浏览器内执行的：
- en: '[PRE158]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: It is exactly the same as our previous `announce-winner` function, except that
    it now includes some extra code at the end to build a web link ![](httpatomoreillycomsourcenostarchimages783564.png),
    which will allow us to conveniently start a brand-new game, since the current
    game has ended.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 它与我们之前的 `announce-winner` 函数完全相同，只是现在在末尾添加了一些额外的代码来构建一个网页链接 ![更多关于奥莱利](http://atomoreilly.com/source/no_starch_images/783564.png)，这将允许我们方便地开始一场全新的游戏，因为当前的游戏已经结束。
- en: Handling the Human Player
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理人类玩家
- en: The `web-handle-human` function is responsible for creating the HTML and doing
    the bookkeeping when the player taking the current turn is the human player.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-handle-human`函数负责在当前回合的玩家是人类玩家时创建HTML并进行账目管理。'
- en: '[PRE159]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The recent choices the human has made dictate what this function will do. The
    `web-handle-human` function knows the human’s choices by referencing the most
    recently chosen position, which derives from a variable passed as a parameter
    through the web request. It also can reference the `*from-tile*` global variable,
    which tells it which tile the player initially chose to use as a starting location
    for a move. It needs both of these values, since a move has both a source location
    and a destination location.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 人类玩家最近的选择决定了这个函数将执行什么操作。`web-handle-human`函数通过引用最近选择的位置来了解人类玩家的选择，这个位置来源于通过网络请求传递的参数变量。它还可以引用`*from-tile*`全局变量，这告诉它玩家最初选择哪个地砖作为移动的起始位置。它需要这两个值，因为移动既有源位置也有目标位置。
- en: If the player has not yet chosen a location, we want to print a message requesting
    that the player choose a hex ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player chose to pass, we want to print a message saying that player’s reinforcements
    have been placed ![](httpatomoreillycomsourcenostarchimages783562.png). (Remember
    that reinforcements are placed right after someone passes.)
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家尚未选择位置，我们想要打印一条消息要求玩家选择一个六边形![图片](httpatomoreillycomsourcenostarchimages783564.png)。如果玩家选择通过，我们想要打印一条消息说玩家的增援已经部署![图片](httpatomoreillycomsourcenostarchimages783562.png)。（记住，增援是在有人通过之后立即部署的。）
- en: Next, we check if the `*from-tile*` variable is nil. If this is the case, it
    means the player has not yet chosen a starting location for a dice attack. If
    it’s `nil`, we can set `*from-tile*` equal to the location that was just selected
    ![](httpatomoreillycomsourcenostarchimages783560.png), as well as ask the player
    to select a destination.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查`*from-tile*`变量是否为nil。如果是这种情况，这意味着玩家尚未为掷骰攻击选择起始位置。如果它是`nil`，我们可以将`*from-tile*`设置为刚刚选择的地点![图片](httpatomoreillycomsourcenostarchimages783560.png)，并要求玩家选择目的地。
- en: If the currently selected location is the same as the `*from-tile*` variable,
    it means a tile was selected twice. This must mean the player has changed his
    mind and wants to undo his selection. Therefore, we will set `*from-tile*` to
    `nil` and print a cancellation message ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前选定的位置与`*from-tile*`变量相同，这意味着选了两次地砖。这一定意味着玩家改变了主意，想要撤销选择。因此，我们将`*from-tile*`设置为`nil`并打印一条取消消息![图片](httpatomoreillycomsourcenostarchimages783554.png)。
- en: In all other cases, it means the player has selected two valid locations for
    the start and end of an attack. We can now advance the `*cur-game-tree*` to point
    to the appropriate next tree inside the lazy list of available moves ![](httpatomoreillycomsourcenostarchimages783510.png).
    We want to print a message, allowing the player to pass ![](httpatomoreillycomsourcenostarchimages783544.png)
    or make yet another attack.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他情况下，这意味着玩家已经为攻击的起始和结束位置选择了两个有效位置。现在我们可以将`*cur-game-tree*`向前推进，指向可用移动懒列表中的适当下一个树![图片](httpatomoreillycomsourcenostarchimages783510.png)。我们想要打印一条消息，允许玩家通过![图片](httpatomoreillycomsourcenostarchimages783544.png)或再次发起攻击。
- en: We have now completed the code our game server will use to interact with the
    human player. Next, let’s write a function to handle the computer player.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了游戏服务器将用于与人类玩家交互的代码。接下来，让我们编写一个处理计算机玩家的函数。
- en: Handling the Computer Player
  id: totrans-1001
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理计算机玩家
- en: 'Handling the web interface for our computer player is pretty simple. After
    all, computer players don’t need any fancy user interface stuff to know what’s
    going on in the game. All the web stuff that happens when the computer is making
    moves is there solely for the benefit of the human player. Here is the `web-handle-computer`
    code that renders the HTML in the web interface as the AI player makes a move:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 处理我们计算机玩家的网络界面相当简单。毕竟，计算机玩家不需要任何花哨的用户界面东西来了解游戏中的情况。当计算机移动时发生的所有网络操作都是为了人类玩家的利益。以下是`web-handle-computer`代码，当AI玩家移动时，它在网络界面中渲染HTML：
- en: '[PRE160]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: All this function does is call our previous `handle-computer` function, which
    will return the next branch that the computer has selected in the game tree. We
    use this to update our `*cur-game-tree*` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, we print a message to state that the player has moved ![](httpatomoreillycomsourcenostarchimages783562.png).
    The last part of the function is a clever little gimmick to spice up our web interface
    a bit. It puts a smidgen of JavaScript in the HTML of the web page ![](httpatomoreillycomsourcenostarchimages783560.png),
    which forces the web browser to automatically load a new web page in five seconds.
    This means that as the computer AI player makes its moves, we get to see everything
    happen in a crude animation!
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数所做的只是调用我们之前的`handle-computer`函数，该函数将返回游戏树中计算机选择的下一个分支。我们使用这个来更新我们的`*cur-game-tree*`变量
    ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。接下来，我们打印一条消息来声明玩家已经移动
    ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)。函数的最后部分是一个巧妙的小技巧，用来让我们的网页界面更加生动。它在网页的HTML中放入了一点点JavaScript
    ![无标题图片](httpatomoreillycomsourcenostarchimages783560.png)，这会强制网络浏览器在五秒后自动加载一个新的网页。这意味着当计算机AI玩家移动时，我们能看到所有动作在一个粗略的动画中发生！
- en: Drawing the SVG Game Board from Within the HTML
  id: totrans-1005
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在HTML中绘制SVG游戏棋盘
- en: 'We have only one more function to write to complete version 3 of Dice of Doom:
    the `draw-dod-page` function. This function interfaces our page game server code
    with the SVG code that draws our board.'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编写一个函数来完成Dice of Doom的版本3：`draw-dod-page`函数。这个函数将我们的页面游戏服务器代码与绘制我们棋盘的SVG代码接口。
- en: '[PRE161]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The most complicated part of this function is the code that determines which
    tiles on the board are legal tiles for the player to click ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the player has already selected a tile, we want to find all moves ![](httpatomoreillycomsourcenostarchimages783562.png)
    where the starting position for the move matches the selected tile ![](httpatomoreillycomsourcenostarchimages783560.png)
    and return the destination position for the given move ![](httpatomoreillycomsourcenostarchimages783554.png).
    If the player hasn’t selected a tile yet, we just want to return all the legal
    starting positions ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数最复杂的部分是确定棋盘上哪些方块是玩家可以点击的有效方块的代码 ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。如果玩家已经选择了一个方块，我们希望找到所有移动
    ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)，其中移动的起始位置与所选方块 ![无标题图片](httpatomoreillycomsourcenostarchimages783560.png)
    匹配，并返回给定移动的终点位置 ![无标题图片](httpatomoreillycomsourcenostarchimages783554.png)。如果玩家还没有选择方块，我们只想返回所有合法的起始位置
    ![无标题图片](httpatomoreillycomsourcenostarchimages783510.png)。
- en: We have now completed our fully graphical version of Dice of Doom. Let’s play!
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了Dice of Doom的完全图形版本。让我们开始玩吧！
- en: Playing Version 3 of Dice of Doom
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩Dice of Doom的版本3
- en: 'First, we need to start up our web server. Simply serve up our `dod-request-handler`,
    and we’re ready to go:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要启动我们的网络服务器。只需提供我们的`dod-request-handler`，我们就可以开始了：
- en: '[PRE162]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Now move over to Firefox and go to [http://localhost:8080/game.html](http://localhost:8080/game.html).
    You should see our game in your browser:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换到Firefox并访问[http://localhost:8080/game.html](http://localhost:8080/game.html)。你应该能在浏览器中看到我们的游戏：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783058.png.jpg)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783058.png.jpg)'
- en: 'When you click a tile, it is highlighted:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击一个方块时，它会高亮显示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782450.png.jpg)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782450.png.jpg)'
- en: 'Now you can select a tile to attack. In this example, we’ll choose the stack
    of two dice to the right of the selected stack:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以选择一个方块进行攻击。在这个例子中，我们将选择所选堆叠右侧的两个骰子的堆叠：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781872.png.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781872.png.jpg)'
- en: 'Next, let’s pass our turn by clicking the **`pass`** web link. This will cause
    the reinforcement dice to be placed (in this case, only a single additional die
    in the upper-left corner):'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过点击**`pass`**网页链接来跳过我们的回合。这将导致强化骰子被放置（在这种情况下，只在左上角放置一个额外的骰子）：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781252.png.jpg)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781252.png.jpg)'
- en: If you now hit **`continue`**, you will see the game cycle automatically through
    the moves for the computer player, in a similar fashion. It will keep going on
    like this until there is a winner for the game. You can always start a new game
    by just going back to the original *game.html* URL.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击 **`继续`**，你将看到游戏自动通过计算机玩家的移动，以类似的方式。它将继续这样进行，直到有游戏获胜者。你可以通过简单地回到原始的 *game.html*
    URL来开始新游戏。
- en: This is much nicer than the crude console interface we’ve been using so far!
    But there are still a few, final improvements we’re going to make to pep up Dice
    of Doom. We’ll be covering those in the next (and final chapter) of this book.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们迄今为止使用的原始控制台界面要好得多！但还有一些最终改进我们将对“末日骰子”进行，以使其更加生动。我们将在本书的下一章（也是最后一章）中介绍这些改进。
- en: What You've Learned
  id: totrans-1023
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你所学的
- en: 'In this chapter, we discussed how you can generate interactive graphics in
    a web browser from a Lisp program. Along the way, you learned the following:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何从Lisp程序生成Web浏览器中的交互式图形。在这个过程中，你学习了以下内容：
- en: You can create a graphical version of Dice Of Doom by rendering the board using
    the SVG format.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用SVG格式渲染棋盘来创建“末日骰子”的图形版本。
- en: The HTML5 standard supports inline SVG images. You can use this to create an
    interactive, web-based version of your game.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5标准支持内联SVG图像。您可以使用此功能创建一个基于Web的交互式游戏版本。
- en: The simple web server used for our example has several limitations. For example,
    our game cannot be played by multiple players. However, the request handler could
    be expanded to allow for multiple, parallel games.
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用于示例的简单Web服务器有几个限制。例如，我们的游戏不能由多个玩家进行。然而，请求处理器可以被扩展以允许进行多个并行游戏。
- en: Chapter 20. Making Dice of Doom More Fun
  id: totrans-1028
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章. 使“末日骰子”游戏更加有趣
- en: It’s now time to create a final version of Dice of Doom. Version 4 of our game
    will be much more fun to play than our earlier versions.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建“末日骰子”的最终版本了。我们游戏的第4版将比之前的版本更有趣。
- en: Although you probably were not aware of it, we made some major compromises in
    the rules for our game to make it easier to program. In this chapter, we will
    allow more players, add rolling of the dice, and implement a few more changes
    to make Dice of Doom a much more interesting game.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能没有意识到，我们在游戏规则上做出了一些重大妥协，以使其更容易编程。在本章中，我们将允许更多玩家参与，增加掷骰子，并对“末日骰子”进行一些更多更改，使其成为一个更加有趣的游戏。
- en: Increasing the Number of Players
  id: totrans-1031
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加玩家数量
- en: 'To begin, put all the code from the previous chapter in a file named *dice_of_doom_v3.lisp*
    (also available from the companion website), and then execute the following command:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将上一章的所有代码放入名为 *dice_of_doom_v3.lisp* 的文件中（也可从配套网站获取），然后执行以下命令：
- en: '[PRE163]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The first change we’re going to make is to increase the number of players from
    two to four. Three of these will be AI opponents, played by the computer. Because
    of how we’ve written our code so far, this requires very little extra code:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一个改变是将玩家数量从两个增加到四个。其中三个将是人工智能对手，由计算机进行游戏。由于我们迄今为止的代码编写方式，这只需要很少的额外代码：
- en: '[PRE164]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: First, we simply change our `*num-players*` variable to `4`. Then we need to
    indicate additional die colors for our new players. The colors for the four players
    will be red, blue, green, and purple.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只需将我们的 `*num-players*` 变量更改为 `4`。然后我们需要为我们的新玩家指定额外的骰子颜色。四位玩家的颜色将是红色、蓝色、绿色和紫色。
- en: It turns out that the AI we’ve created so far already works just fine in a four-player
    game.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们迄今为止创建的人工智能在四人游戏中运行得很好。
- en: Our AI game engine will use what is called a “paranoid strategy.” This means
    that the AI players will always assume that every other player (including the
    human) has no other goal but to—how should I put this?—screw them over personally.
    This isn’t a bad strategy to use; however, a game with more than two players opens
    up new possibilities. For instance, losing players could gang up on a winning
    player to improve their odds. Our game AI isn’t smart enough to form such packs
    of cooperation, but it’s good enough.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的AI游戏引擎将使用所谓的“偏执策略”。这意味着AI玩家将始终假设每个其他玩家（包括人类）的唯一目标就是——如何表达？——个人地欺骗他们。这不是一个坏策略；然而，超过两个玩家的游戏打开了新的可能性。例如，输掉游戏的玩家可能会联合起来对付获胜的玩家，以提高他们的胜算。我们的游戏AI不够聪明，无法形成这样的合作团伙，但已经足够好了。
- en: 'Now that we’ve already tweaked some constants to increase the number of players,
    let’s tweak a couple more:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经调整了一些常数以增加玩家数量，让我们再调整几个：
- en: '[PRE165]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we’re increasing the maximum number of dice on a hex tile from three to
    five, and decreasing the level of our AI from four to two. With the new rules
    described in this chapter, we’ll need to dumb down our AI a bit to make sure it
    stays zippy. Since there are now four competing players, the AI actually doesn’t
    need to be so smart to challenge the human opponent.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将六边形瓷砖上的最大骰子数量从三个增加到五个，并将我们的AI级别从四降低到二。根据本章中描述的新规则，我们需要使我们的AI稍微简单一些，以确保它保持敏捷。由于现在有四个竞争玩家，AI实际上不需要非常聪明就能挑战人类对手。
- en: Rolling the Dice
  id: totrans-1042
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掷骰子
- en: 'I’m sure you’ve probably noticed one obvious flaw in our game so far: Despite
    the fact that it is called Dice of Doom, it actually is completely devoid of any
    randomness! The dice are never rolled, and the larger stack will always automatically
    win, which makes for a pretty lame dice game. Now we’re finally going to rectify
    this flaw.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你肯定注意到了我们游戏中的一个明显的缺陷：尽管它被称为“末日骰子”，但实际上它完全没有随机性！骰子从未被掷出，较大的堆叠总是自动获胜，这使得游戏变得相当无聊。现在我们终于要纠正这个缺陷了。
- en: In this version of the game, during an attack, both piles of dice are rolled,
    and whoever rolls the highest number wins the battle. Ties are a victory for the
    defender. If the attacker loses, that player must surrender all dice from the
    attacking hex except one.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏版本中，在攻击期间，两个骰子堆都会被掷出，掷出最高数字的一方赢得战斗。平局对防守方有利。如果攻击者失败，该玩家必须放弃攻击六边形中除一个以外的所有骰子。
- en: In the lingo of AI programming, this means we will add *chance nodes* to our
    game tree. The way we’re going to implement this is pretty simple.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能编程的术语中，这意味着我们将向我们的游戏树添加 *机会节点*。我们将以非常简单的方式实现这一点。
- en: Building Chance Nodes
  id: totrans-1046
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建机会节点
- en: 'Every move in our lazy list of moves up to now has always had exactly two items
    in it: a description of the move (a list of the source and destination of the
    attack, or `nil` for a passing move) and the new node of the game tree for when
    the move has been taken. Now we’re simply going to add a third item to a move,
    which contains the game tree for an unsuccessful attack. This means that each
    move in our move list will double as a chance node, with two possible follow-up
    nodes for the next game tree, depending on whether an attack is successful.'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们懒散的移动列表中的每个移动都恰好有两个项目：移动的描述（攻击的源和目的地列表，或者对于通过移动为 `nil`）以及当移动被采取时的游戏树的新节点。现在我们只是简单地为移动添加第三个项目，它包含一个不成功攻击的游戏树。这意味着我们的移动列表中的每个移动都将作为机会节点，根据攻击是否成功，为下一个游戏树提供两个可能的后续节点。
- en: Let’s update our `attacking-moves` function to add this extra item to the move
    so that each move acts as a chance node.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `attacking-moves` 函数，以便为移动添加这个额外项目，使每个移动都充当一个机会节点。
- en: '[PRE166]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The only thing new in this updated version of `attacking-moves` is right here
    ![](httpatomoreillycomsourcenostarchimages783564.png), where we add a third item
    as we create a new move in the game tree. The board in this alternate branch of
    our chance node is constructed by calling the function `board-attack-fail`, which
    we will write next.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `attacking-moves` 的更新版本中，唯一的新增内容就在这里 ![更新版本](httpatomoreillycomsourcenostarchimages783564.png)，我们在创建游戏树中的新移动时添加了第三个项目。在这个机会节点的替代分支中，棋盘是通过调用
    `board-attack-fail` 函数构建的，我们将在下一节中编写这个函数。
- en: 'The `board-attack-fail` function does exactly what you would expect: It takes
    a board and returns a board that has all dice but one removed from the hex from
    which a failed attack originated.'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '`board-attack-fail` 函数正是你所期望的那样工作：它接受一个棋盘，并返回一个棋盘，其中从攻击失败的六边形中移除了所有骰子（除了一个）。'
- en: '[PRE167]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Here, we simply loop over the board and return each hex unmodified ![](httpatomoreillycomsourcenostarchimages783562.png),
    unless it happens to be the source hex for the attack. In that case, we remove
    all dice from that hex but one ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是遍历棋盘，并返回每个未修改的六边形 ![遍历棋盘](httpatomoreillycomsourcenostarchimages783562.png)，除非它恰好是攻击的源六边形。在这种情况下，我们将从该六边形中移除所有骰子（除了一个）
    ![移除骰子](httpatomoreillycomsourcenostarchimages783564.png)。
- en: Doing the Actual Dice Rolling
  id: totrans-1054
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行实际的骰子掷出
- en: 'Next, we need to write some functions to actually roll the dice. Here is a
    function that rolls a pile of dice:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一些函数来实际掷骰子。以下是一个掷骰子堆的函数：
- en: '[PRE168]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: First, it calculates a total count of a pile of rolled dice by looping once
    for each die. For each die, it generates a random number from 1 to 6\. Then it
    stores the total sum in the `total` variable ![](httpatomoreillycomsourcenostarchimages783564.png).
    Next, the `roll-dice` function prints a descriptive message about the roll ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it returns the total ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它通过为每个骰子循环一次来计算掷出的骰子堆的总数。对于每个骰子，它生成一个1到6之间的随机数。然后，它将总和存储在`total`变量中！[](httpatomoreillycomsourcenostarchimages783564.png)。接下来，`roll-dice`函数打印关于掷骰子的描述性消息！[](httpatomoreillycomsourcenostarchimages783562.png)。最后，它返回总和！[](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Since we’re never going to roll a pile of dice in isolation, let’s create another
    function that pits two piles of dice against each other:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们永远不会单独掷骰子堆，让我们创建另一个函数，将两堆骰子相互对抗：
- en: '[PRE169]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: This simply calls `roll-dice` twice and compares the total of the two rolls.
    We’ll want to use this function as we travel along our game tree to pick either
    the winning or losing move as a turn is chosen by either the human or the computer.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是两次调用`roll-dice`并比较两次滚动的总和。当我们沿着游戏树前进，选择人类或计算机选择的获胜或失败移动时，我们将想要使用这个函数。
- en: Calling the Dice Rolling Code from Our Game Engine
  id: totrans-1061
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从我们的游戏引擎调用掷骰子代码
- en: 'In the context of our game engine, rolling dice simply means picking either
    the winning or losing branch of the chance node after the human or computer has
    chosen a move. This action is performed by the `pick-chance-branch` function:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏引擎的上下文中，掷骰子简单地意味着在人类或计算机选择移动后，选择机遇节点的获胜或失败分支。这个动作由`pick-chance-branch`函数执行：
- en: '[PRE170]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This function takes the current board and also the move that contains the chance
    node that needs to be resolved ![](httpatomoreillycomsourcenostarchimages783564.png).
    When the path inside the move is not `null`, we call `roll-against` with a count
    of dice in the source and destination hexes along the path of attack ![](httpatomoreillycomsourcenostarchimages783562.png).
    We check for a `null` path because that means the move was a “pass,” which doesn’t
    require any dice rolling.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受当前棋盘以及包含需要解决的机遇节点的移动！[](httpatomoreillycomsourcenostarchimages783564.png)。当移动内部的路径不是`null`时，我们使用源和目标六边形路径上的骰子数量调用`roll-against`！[](httpatomoreillycomsourcenostarchimages783562.png)。我们检查`null`路径，因为这表示移动是“跳过”，不需要掷骰子。
- en: If the dice roll for the attack is successful, we remove the first child tree
    from the chance node within the move ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the attack is unsuccessful, we return the second child of the chance node ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击的骰子滚动成功，我们从移动中的机遇节点中移除第一个子树！[](httpatomoreillycomsourcenostarchimages783560.png)。如果攻击失败，我们返回机遇节点的第二个子节点！[](httpatomoreillycomsourcenostarchimages783554.png)。
- en: 'Now we need to make sure that the `pick-chance-branch` function is called when
    the human or computer chooses a move. First, let’s take care of the human:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保在人类或计算机选择移动时调用`pick-chance-branch`函数。首先，让我们处理人类的情况：
- en: '[PRE171]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: All we’ve done here is to add a call to `pick-chance-branch` at the end of our
    previous `handle-human` function, at the point we need to return the child branch
    of the game tree that holds the next state of the game ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在我们之前的`handle-human`函数末尾添加了对`pick-chance-branch`的调用，在需要返回包含游戏下一个状态的子树分支的点！[](httpatomoreillycomsourcenostarchimages783564.png)。
- en: 'We update the `handle-computer` function in the same way:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相同的方式更新`handle-computer`函数：
- en: '[PRE172]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Again, we’ve simply added a call to `pick-chance-branch` at the end of the function
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只是在函数末尾简单地添加了对`pick-chance-branch`的调用！[](httpatomoreillycomsourcenostarchimages783564.png)。
- en: It is now possible to play our updated Dice of Doom game. However, at this point,
    the computer player will play a very poor game, because the AI does not yet understand
    that the chance nodes exist. It will simply assume that every attack will always
    be successful, making it much too foolhardy to play a decent game. We need to
    improve our AI so that it takes into account the rolling of the dice as it makes
    its decisions.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以玩我们更新的“末日骰子”游戏了。然而，在这个阶段，计算机玩家将玩得非常糟糕，因为AI还没有理解机遇节点存在。它将简单地假设每次攻击都会成功，这使得它过于鲁莽，无法玩得体面。我们需要改进我们的AI，使其在做出决策时考虑到掷骰子。
- en: Updating the AI
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新AI
- en: 'For the AI to be able to deal with the dice rolls that are now important to
    our game, it must know a little something about the statistics of dice rolls.
    The following table gives it the needed statistical information:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让AI能够处理对我们游戏现在重要的骰子滚动，它必须对骰子滚动的统计信息有所了解。以下表格提供了它所需的统计信息：
- en: '[PRE173]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This table contains the odds of winning for each possible pairing of dice in
    our game. The columns represent the attacking dice, starting with one die. The
    rows represent the destination dice, starting with two dice (the minimum dice
    needed for an attack).
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 此表格包含了我游戏中每个可能的骰子配对获胜的概率。列代表攻击骰子，从一枚骰子开始。行代表目标骰子，从两枚骰子开始（攻击所需的最低骰子数量）。
- en: This table tells us, for instance, that a roll of two attacking dice against
    one defending die has an 84 percent chance of winning. Four attacking dice against
    three defending dice have a 74 percent chance of winning.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 此表格告诉我们，例如，两枚攻击骰子对抗一枚防御骰子的投掷有84%的获胜概率。四枚攻击骰子对抗三枚防御骰子有74%的获胜概率。
- en: 'If you remember, the core function in our AI code is the `get-ratings` function,
    which gives a point score to the list of possible follow-up moves. We need to
    modify how it calculates the score of each possible move to take the odds of success
    of the dice roll into account. We are now going to make use of our `*dice-odds*`
    table, as well as the point scores of the successful or failed outcomes of each
    attack, to interpolate a combined score for each available move:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们AI代码中的核心函数是`get-ratings`函数，它为可能的后续走法列表提供得分。我们需要修改它计算每个可能走法得分的算法，以考虑骰子滚动的成功概率。我们现在将利用我们的`*dice-odds*`表格以及每个攻击成功或失败的结果的点分数，为每个可用的走法插值一个综合得分：
- en: '[PRE174]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: In our updated `get-ratings` function, we look up the odds of each attack succeeding
    from our table ![](httpatomoreillycomsourcenostarchimages783564.png). Then we
    multiply the odds with the rating for the winning child tree ![](httpatomoreillycomsourcenostarchimages783562.png).
    Additionally, we add in the odds of losing the attack (one minus the odds of winning)
    multiplied by the rating for the losing board position ![](httpatomoreillycomsourcenostarchimages783560.png).
    We now have an updated `get-ratings` function that understands chance nodes and
    accounts for them appropriately when generating the score for a move.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新的`get-ratings`函数中，我们从表格中查找每个攻击成功的概率![图片](httpatomoreillycomsourcenostarchimages783564.png)。然后我们将概率与获胜子树的评级![图片](httpatomoreillycomsourcenostarchimages783562.png)相乘。此外，我们还将攻击失败的几率（胜率减一）乘以失败棋盘位置的评级![图片](httpatomoreillycomsourcenostarchimages783560.png)。现在我们有一个更新的`get-ratings`函数，它理解随机节点，并在生成走法得分时适当考虑它们。
- en: 'For our game AI to be fully compatible with chance nodes, we need to make one
    additional small change. Our tree-trimming function needs to know about the two
    branches of the chance node within each move, so it can properly trim both the
    winning and losing alternatives for each move:'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的游戏AI完全兼容随机节点，我们需要进行一个小小的额外修改。我们的剪枝函数需要了解每个走法中随机节点的两个分支，这样它就可以正确地修剪每个走法的获胜和失败选项：
- en: '[PRE175]'
  id: totrans-1082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: We `mapcar` ![](httpatomoreillycomsourcenostarchimages783564.png) across the
    tail of each move, so trimming is performed on both branches of any chance nodes.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个走法的尾部使用`mapcar`![图片](httpatomoreillycomsourcenostarchimages783564.png)，因此对任何随机节点的两个分支都进行修剪。
- en: Note
  id: totrans-1084
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Version 4 of Dice of Doom will not have alpha-beta pruning. Performing proper
    alpha-beta pruning in the presence of chance nodes is very complex.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: “末日骰子”版本4将不会有alpha-beta剪枝。在有随机节点的情况下执行正确的alpha-beta剪枝非常复杂。
- en: Improving the Dice of Doom Reinforcement Rules
  id: totrans-1086
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进“末日骰子”增援规则
- en: Until now, the number of reinforcements at the end of a player’s turn always
    equals the number of captured opponent dice, minus one. This reinforcement rule
    guaranteed that the total number of dice in a game always decreases, so that the
    game was certain to eventually terminate, and the game tree was always finite
    in size.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，玩家回合结束时增加的增援数量总是等于捕获的对手骰子数量减一。这个增援规则保证了游戏中骰子的总数总是减少，因此游戏最终一定会结束，游戏树的大小总是有限的。
- en: However, since version 2, our game tree has been a lazy tree, so it is perfectly
    fine if the tree is infinite. Remember that one of the main benefits of lazy evaluation
    is that you can have data structures that are infinite in size.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自从版本2以来，我们的游戏树一直是一个懒树，所以如果树是无限的，那完全没问题。记住，懒加载的主要好处之一是可以拥有无限大小的数据结构。
- en: Therefore, we are now going to adjust our reinforcement rules to make our game
    strategically more interesting.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将调整我们的强化规则，使我们的游戏在战略上更有趣。
- en: According to our new rules, the number of reinforcement dice will equal the
    number of tiles in the player’s largest contiguous territory. This adds a lot
    of strategic depth, because the players must constantly decide whether to risk
    connecting their territories, or perhaps even to sacrifice smaller, nonviable
    territories by sending them on suicide missions.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的新规则，强化骰子的数量将等于玩家最大连续领土中的瓷砖数量。这增加了许多战略深度，因为玩家必须不断决定是否冒险连接他们的领土，或者甚至通过派遣自杀任务来牺牲较小的、不可行的领土。
- en: 'In order to implement this new reinforcement rule, let’s first define the function
    `get-connected`, which returns a list of tiles that are owned by the current player
    and are connected as a cluster of neighbors to the target tile:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个新的强化规则，我们首先定义一个名为`get-connected`的函数，该函数返回当前玩家拥有的、与目标瓷砖作为邻居集群连接的瓷砖列表：
- en: '[PRE176]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: This function uses the same algorithm for finding connected tiles as we used
    for calculating connectedness in our Grand Theft Wumpus game in [Chapter 8](ch09.html
    "Chapter 8. This Ain't Your Daddy's Wumpus"). We traverse through the hexes and
    their neighbors recursively, while maintaining a `visited` list.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用与我们在[第8章](ch09.html "第8章。这不是你爸爸的Wumpus")中用于计算连通性的Grand Theft Wumpus游戏相同的算法来查找连通的瓷砖。我们通过递归遍历六边形及其邻居，同时维护一个`visited`列表。
- en: The `get-connected` function accomplishes this by defining two recursive local
    functions. The `check-pos` function ![](httpatomoreillycomsourcenostarchimages783564.png)
    checks a single position and appends any new neighbors accessible from that location
    to the visited list. The `check-neighbors` function ![](httpatomoreillycomsourcenostarchimages783562.png)
    checks an entire list of neighbors, similarly appending new neighbors to the visited
    list. These two functions call each other recursively until all neighbors in a
    cluster are found. To start off this recursive calculation, we call the `check-pos`
    function with the target position and an initially empty `visited` list ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: '`get-connected`函数通过定义两个递归局部函数来实现这一点。`check-pos`函数 ![http://atomoreilly.com/source/nostarch/images/783564.png]
    检查单个位置，并将从该位置可访问的新邻居添加到访问列表中。`check-neighbors`函数 ![http://atomoreilly.com/source/nostarch/images/783562.png]
    检查整个邻居列表，同样将新邻居添加到访问列表中。这两个函数相互递归调用，直到找到集群中的所有邻居。为了开始这个递归计算，我们使用目标位置和一个最初为空的`visited`列表调用`check-pos`函数
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。'
- en: 'We can now find clusters. However, to find the *largest* cluster, we need the
    `largest-cluster-size` function:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到集群了。但是，为了找到*最大的*集群，我们需要`largest-cluster-size`函数：
- en: '[PRE177]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: This function defines a local function `f`, which we’ll use to check every position
    on the board, while maintaining both a list of previously visited nodes and the
    size of the largest, best cluster found so far ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数定义了一个局部函数`f`，我们将使用它来检查棋盘上的每个位置，同时维护先前访问过的节点列表以及迄今为止找到的最大、最佳集群的大小 ![http://atomoreilly.com/source/nostarch/images/783564.png]。
- en: As long as the current position number is less than the total number of spots
    on the board ![](httpatomoreillycomsourcenostarchimages783562.png), we continue
    to check tiles. If the current tile to be checked belongs to the player and also
    has not yet been visited ![](httpatomoreillycomsourcenostarchimages783560.png),
    we’ll call `get-connected` to retrieve the cluster of hexes reachable from this
    spot ![](httpatomoreillycomsourcenostarchimages783554.png). Then, if the size
    of the cluster is larger than the best found so far ![](httpatomoreillycomsourcenostarchimages783510.png),
    we make this the new best size in our recursive call ![](httpatomoreillycomsourcenostarchimages783544.png).
    Otherwise, we proceed by calling `f` while keeping the previous best size ![](httpatomoreillycomsourcenostarchimages783556.png).
    (The best variable at this point will hold the best value found so far from previous
    iterations.) No matter what happens, however, the `pos` variable is incremented
    with every recursive call to `f`, so that we eventually cover the whole board.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 只要当前位置编号小于板上的总点数 ![点数说明](http://atomoreilly.com/source/nostarch/images/783562.png)，我们就继续检查瓷砖。如果当前要检查的瓷砖属于玩家，并且尚未访问
    ![访问说明](http://atomoreilly.com/source/nostarch/images/783560.png)，我们将调用 `get-connected`
    来检索从这个位置可达的六边形集群 ![集群说明](http://atomoreilly.com/source/nostarch/images/783554.png)。然后，如果集群的大小大于迄今为止找到的最佳大小
    ![最佳大小说明](http://atomoreilly.com/source/nostarch/images/783510.png)，我们将在这个递归调用中将它作为新的最佳大小。否则，我们通过调用
    `f` 并保持先前的最佳大小继续进行 ![保持最佳大小说明](http://atomoreilly.com/source/nostarch/images/783556.png)。（此时最佳变量将保留迄今为止从先前迭代中找到的最佳值。）无论如何，`pos`
    变量都会在每次递归调用 `f` 时增加，这样我们最终就能覆盖整个板。
- en: 'Finally, we need to update `add-new-dice` to make use of our new rule for choosing
    the number of reinforcements:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新 `add-new-dice` 以利用我们选择增援数量的新规则：
- en: '[PRE178]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: As you can see, the `add-new-dice` function still receives `spare-dice` as an
    argument for compatibility with our old code ![](httpatomoreillycomsourcenostarchimages783564.png),
    but now this argument is simply ignored. Instead, the number of reinforcements
    added to the board depends on the size of the largest cluster ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, the `add-new-dice` is identical to our previous version.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`add-new-dice` 函数仍然接收 `spare-dice` 作为参数以保持与旧代码的兼容性 ![兼容性说明](http://atomoreilly.com/source/nostarch/images/783564.png)，但现在这个参数被简单地忽略。相反，添加到板上的增援数量取决于最大集群的大小
    ![集群大小说明](http://atomoreilly.com/source/nostarch/images/783562.png)。否则，`add-new-dice`
    与我们之前的版本相同。
- en: This is all the code we need to enable the new reinforcement rules. Note that,
    due to the design of our code, the AI player has full access to the game tree.
    Since the game tree now contains all of this new reinforcement data, the AI will
    automatically adapt its playing strategy to take into account the new reinforcement
    rules!
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有代码，以启用新的增援规则。请注意，由于我们代码的设计，AI 玩家可以完全访问游戏树。由于游戏树现在包含所有这些新的增援数据，AI 将自动调整其游戏策略，以考虑新的增援规则！
- en: Conclusion
  id: totrans-1103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: We’ve gone through quite a long trip as we’ve created the Dice of Doom game,
    employing an immense number of different programming techniques along the way.
    We’ve taken even more trips with all the other games in this book. Thanks for
    taking this journey with me through the world of Lisp programming!
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建“末日骰子”游戏的过程中走了一段相当长的旅程，沿途使用了大量的不同编程技术。在这本书中的其他所有游戏中，我们也进行了更多的旅行。感谢您与我一起踏上
    Lisp 编程世界的旅程！
- en: 'I suggest that you take a moment to enjoy the fruits of your labor and play
    a few games of the fourth and final version of Dice of Doom. Again, all you need
    to do is serve up the Dice of Doom request handler through our web server:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您花点时间享受您辛勤劳动的成果，并玩几局“末日骰子”的第四版和最终版本。再次提醒，您只需要通过我们的网络服务器提供“末日骰子”请求处理器：
- en: '[PRE179]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Now you can play Dice of Doom in Firefox (again, at the address *localhost:8080/game.html*)
    as it is meant to be played, with four players and all the new rules we’ve added
    in this chapter.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在 Firefox 中玩“末日骰子”（再次，地址为 *localhost:8080/game.html*），按照预期的方式玩，有四名玩家和我们在本章中添加的所有新规则。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781284.png.jpg)'
  id: totrans-1108
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/781284.png.jpg)'
- en: Good luck with all your Dice of Doom battles and all your future Lisp programming!
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 祝您在所有“末日骰子”战斗和未来的 Lisp 编程中一切顺利！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780634.png.jpg)'
  id: totrans-1110
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/780634.png.jpg)'
- en: Appendix A. Epilogue
  id: totrans-1111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 结语
- en: 'Now that you’ve worked your way through this book, here is one final reward:
    A story about the technologies behind the entire Lisp family of programming languages,
    set in the not-too-distant future . . .'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经通读了这本书，这里有一个最后的奖励：一个关于整个Lisp编程语言家族背后的技术的故事，设定在不太遥远的未来……
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781408.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780716.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780760.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780566.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780604.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages780012.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783188.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783236.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782622.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782670.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782072.png.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781408.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780716.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780760.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780566.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780604.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages780012.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages783188.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages783236.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782622.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782670.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782072.png.jpg)'
- en: Functional Guild Cruiser
  id: totrans-1114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能型巡洋舰
- en: '**Lisp Dialect**'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'Functional programming is a mathematical approach to programming that was pioneered
    by the creators of Lisp. Functional programming places certain restrictions on
    the programmer, but it can lead to very elegant code. When using functional programming,
    every variable that is used by a given function must be one of the following:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种数学化的编程方法，由Lisp的创造者开创。函数式编程对程序员施加某些限制，但它可以导致非常优雅的代码。在使用函数式编程时，给定函数使用的每个变量必须是以下之一：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782902.png)'
  id: totrans-1119
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782902.png)'
- en: A parameter passed into that function
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给该函数的参数
- en: A local variable created within that function
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该函数内部创建的局部变量
- en: A constant
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个常量
- en: Also, functional programming doesn’t allow a function to have *side effects*.
    This means a function can’t write to the disk, print messages on the screen, or
    do anything other than return a result. The goal is to write most of a program
    using “functional code,” while retaining a teensy bit of code that does any dirty,
    nonfunctional stuff that is still needed.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，函数式编程不允许函数有*副作用*。这意味着函数不能写入磁盘，不能在屏幕上打印消息，或者做任何除了返回结果之外的事情。目标是使用“函数式代码”编写程序的大部分内容，同时保留一小部分代码，用于执行任何仍然需要的脏乱的非函数式操作。
- en: How It Kills Bugs
  id: totrans-1124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何杀死错误
- en: Writing code in a functional style guarantees that a function does only one
    thing (returns a value) and is dependent on one only thing (the parameters passed
    to it). This makes it very easy to debug. No matter how many times you run a function,
    as long as you’re passing it the same data, you will always get the same result.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 以函数式风格编写代码可以保证函数只做一件事（返回一个值）并且只依赖于一个东西（传递给它的参数）。这使得调试变得非常容易。无论你运行函数多少次，只要传递给它相同的数据，你总是会得到相同的结果。
- en: Example A-1. Example
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-1. 示例
- en: '[PRE180]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Explanation
  id: totrans-1128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: If you enter this code into the Lisp REPL and execute `(ask-and-respond)`, you
    will be asked for your name, and then greeted by your name but with all duplicate
    letters removed. All the hard work in this function is handled by `unique-letters`,
    which is written in a functional style ![](httpatomoreillycomsourcenostarchimages783564.png).
    The dirty work of interacting with the user, which can’t be written in a purely
    functional way, is handled by `ask-and-respond` ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此代码输入到Lisp REPL中并执行`(ask-and-respond)`，你将被要求输入你的名字，然后会以你的名字问候你，但所有重复的字母都被移除了。这个函数中的所有艰苦工作都是由`unique-letters`处理的，它是以函数式风格编写的
    ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)。与用户交互的脏活，不能以纯函数式方式编写，由`ask-and-respond`处理
    ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Weakness
  id: totrans-1130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: The main weakness of functional programming is that some side effects are almost
    always necessary for a program to actually *do* something. This means you can’t
    write a useful program that has the entirety of its code written in the functional
    style. At least a small amount of code will be nonfunctional.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的主要弱点是，程序实际上要“做”一些事情，几乎总是需要一些副作用。这意味着你不能编写一个全部用函数式风格编写的有用程序。至少会有一些代码是非函数式的。
- en: Functional programming is discussed in [Chapter 14](ch16.html "Chapter 14. Ramping
    Lisp Up a Notch with Functional Programming").
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在[第14章](ch16.html "第14章。用函数式编程提升Lisp的层次")中讨论。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782372.png.jpg)'
  id: totrans-1133
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782372.png.jpg)'
- en: Macro Guild Melee Fighters
  id: totrans-1134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏团近战战士
- en: '**Lisp Dialect**'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*True macros* are one of Lisp’s most unique and amazing features. In fact,
    the reason Lispers put up with all those annoying parentheses in their code is
    that those parentheses enable the awesome Lisp macro system.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的宏*是Lisp最独特和最惊人的特性之一。事实上，Lisper忍受他们代码中所有那些令人烦恼的括号的原因是，那些括号使得Lisp的宏系统变得神奇。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780362.png)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780362.png)'
- en: True macros allow you to add new functionality to Lisp in a very fundamental
    way. Experienced Lispers can use macros to make their Lisp compiler/interpreter
    do their bidding cleanly and elegantly.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的宏允许你以非常基本的方式向Lisp添加新功能。经验丰富的Lisper可以使用宏来干净优雅地让他们的Lisp编译器/解释器执行他们的命令。
- en: How It Kills Bugs
  id: totrans-1141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何杀死错误
- en: By using macros, an experienced Lisper can minimize code duplication, and better
    tailor the underlying language to the problem at hand. This leads to cleaner code
    and fewer bugs.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用宏，经验丰富的Lisper可以最小化代码重复，并更好地将底层语言定制到当前问题。这导致代码更干净，错误更少。
- en: Example A-2. Example
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 例A-2. 示例
- en: '[PRE181]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Explanation
  id: totrans-1145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释
- en: 'Lisp macros are so powerful that you can actually write your own if-then command!
    The code shown here creates a macro called `three-way-if` that has three branches:
    one for a `nil` value ![](httpatomoreillycomsourcenostarchimages783564.png), one
    for a numerical zero value ![](httpatomoreillycomsourcenostarchimages783562.png),
    and one for everything else ![](httpatomoreillycomsourcenostarchimages783560.png).
    For most purposes, a function like this might seem stupid, but if you ever want
    to write a program that constantly needs to distinguish zeros from `nil`s (or
    needs to handle some other domain-specific headache), you’ll make your life much
    easier by writing a macro.'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp宏如此强大，以至于你可以实际编写自己的if-then命令！这里显示的代码创建了一个名为`three-way-if`的宏，它有三个分支：一个用于`nil`值
    ![无标题图片](httpatomoreillycomsourcenostarchimages783564.png)，一个用于数值零 ![无标题图片](httpatomoreillycomsourcenostarchimages783562.png)，以及一个用于其他所有情况
    ![无标题图片](httpatomoreillycomsourcenostarchimages783560.png)。对于大多数用途，这样的函数可能看起来很愚蠢，但如果你需要编写一个经常需要区分零和`nil`（或需要处理其他特定领域的头痛问题）的程序，编写一个宏将使你的生活更容易。
- en: Weakness
  id: totrans-1147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Since Lisp macros are so powerful, there is always the danger of programmers
    abusing them. Overuse of macros can make it hard for other programmers to understand
    your code.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lisp宏非常强大，程序员滥用它们的风险总是存在的。过度使用宏可能会让其他程序员难以理解你的代码。
- en: Macros are discussed in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp
    Macros").
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 宏在[第16章](ch18.html "第16章。Lisp宏的魔力")中讨论。
- en: Restart Guild Armored Fighter
  id: totrans-1150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重启团装甲战士
- en: '**Lisp Dialect**'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Proper exception handling is extremely difficult. There are really only two
    good approaches: Don’t handle exceptions at all and just let your program die
    when one occurs, or handle every single exception in the most direct and specific
    way possible. But is it truly possible to handle every potential exception in
    your code? If your write Common Lisp code, it’s possible to get extremely close
    to this ideal goal.'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的异常处理极其困难。实际上只有两种好的方法：根本不处理异常，当异常发生时让程序直接崩溃，或者以最直接和具体的方式处理每一个异常。但是，在代码中真正处理每一个潜在的异常是否真的可能？如果你编写Common
    Lisp代码，你可以非常接近这个理想目标。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782448.png)'
  id: totrans-1155
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782448.png)'
- en: For example, suppose you write a function that raises the prices on a list of
    widgets. But then, while the function is processing one of the widgets in the
    list, there’s a memory allocation error. You can’t prepare for this type of error
    ahead of time, since it could happen anywhere in a program. This makes it impossible
    to address using traditional exception handling methods.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你编写了一个函数来提高小部件列表中的价格。但在函数处理列表中的某个小部件时，出现了内存分配错误。你无法提前准备这种类型的错误，因为它可能发生在程序的任何地方。这使得使用传统的异常处理方法无法解决这个问题。
- en: 'Even if a function lower in the call stack catches and resolves the source
    of the exception, the program still faces an unsolvable problem: Some of the widget
    prices have been raised, while others have not. Common Lisp, however, has a mechanism
    for addressing this problem, called *restarts*.'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 即使调用栈中较低层的函数捕获并解决了异常的根源，程序仍然面临一个无法解决的问题：一些小部件的价格已经上涨，而另一些则没有。然而，Common Lisp
    有一个机制来解决这个问题，称为 *重启*。
- en: In a language that supports restarts, the function that raises the widget prices
    can make the proclamation, “Hey everybody! If something bad happens while I’m
    working on my widgets, just use my restart (called `try-again`) when it’s safe
    for me to finish my work!” Another function, lower in the call tree, can now handle
    the error, and then call `try-again` to ensure that the widget prices won’t become
    corrupt. This allows the function to finish raising widget prices at the exact
    point of failure.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持重启的语言中，提高小部件价格的函数可以宣布，“嘿，大家！如果在我处理小部件时发生什么坏事，当对我来说安全完成我的工作时，请使用我的重启（称为 `try-again`）！”
    另一个位于调用树较低层的函数现在可以处理错误，然后调用 `try-again` 来确保小部件价格不会变得损坏。这允许函数在失败的确切点完成提高小部件价格的操作。
- en: In fact, if you have a program that can’t afford to shut down (a web server,
    for example), you can still handle a surprising number of extreme exceptions in
    Common Lisp without ending the program. Even if the program encounters a truly
    exceptional exception, it can simply divert control back to the REPL. The programmer
    can then fix the cause of the exception, access a list of available restarts,
    and continue running the program on the spot.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你有一个无法承受关闭的程序（例如，一个网络服务器），你仍然可以在不结束程序的情况下处理大量极端的异常。即使程序遇到真正异常的异常，它也可以简单地将控制权转回到交互式解释器。然后程序员可以修复异常的原因，访问可用的重启列表，并立即继续运行程序。
- en: How It Kills Bugs
  id: totrans-1160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何杀死错误
- en: By using restarts and the Lisp REPL, a bug can be fixed in a running program,
    allowing you to “hot script” long-running applications with only a negligible
    interruption.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用重启和 Lisp REPL，可以在运行中的程序中修复错误，允许你以几乎可以忽略不计的中断来“热脚本”长时间运行的应用程序。
- en: Example A-3. Example
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-3. 示例
- en: '[PRE182]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Explanation
  id: totrans-1164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This is an implementation of a function that raises prices on a list of widgets.
    The actual work of raising the price of a single widget is done by the `raise-price`
    function ![](httpatomoreillycomsourcenostarchimages783564.png). The call to this
    function is protected by wrapping it in a `loop` and the `restart-case` command,
    which declares a restart called `try-again` ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the price can be raised without problems, the `raise-price` function will complete
    normally, the loop is interrupted with a `return` ![](httpatomoreillycomsourcenostarchimages783562.png),
    and the next item in the list of widgets is processed. On the other hand, if an
    error occurs while raising the price on a widget, another function (or the programmer)
    can attempt to fix the problem and call the `try-again` restart to retry the widget
    at the point of failure ![](httpatomoreillycomsourcenostarchimages783560.png),
    which leads to another cycle through the `loop` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The function can then continue down the rest of the list, raising the prices on
    the remaining widgets ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现函数的示例，该函数会提高一系列小工具的价格。单个小工具价格提高的实际工作由`raise-price`函数完成 ![httpatomoreillycomsourcenostarchimages783564.png]。对该函数的调用被包裹在一个`loop`和一个`restart-case`命令中，该命令声明了一个名为`try-again`的重启
    ![httpatomoreillycomsourcenostarchimages783560.png]。如果价格可以无问题地提高，`raise-price`函数将正常完成，循环通过`return`中断
    ![httpatomoreillycomsourcenostarchimages783562.png]，然后处理小工具列表中的下一个项目。另一方面，如果在提高小工具价格时发生错误，另一个函数（或程序员）可以尝试修复问题并调用`try-again`重启来重试失败点的小工具
    ![httpatomoreillycomsourcenostarchimages783560.png]，这导致循环的另一个循环 ![httpatomoreillycomsourcenostarchimages783564.png]。然后函数可以继续处理列表的其余部分，提高剩余小工具的价格
    ![httpatomoreillycomsourcenostarchimages783554.png]。
- en: By using restarts, your code can offer multiple alternative follow-up options
    for coping with an exception, so that even the most exceptional exceptions can
    be handled appropriately.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用重启，你的代码可以为处理异常提供多种替代后续选项，即使是最异常的异常也能得到适当的处理。
- en: Weakness
  id: totrans-1167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Even though Common Lisp has one of the most advanced exception handling systems
    in existence, it is still difficult to handle every exception appropriately in
    your code. However, restarts give you the unique ability to fix a running program
    and allow it to continue operating, which is usually not possible in other languages.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Common Lisp拥有现存最先进的异常处理系统之一，但在代码中仍然难以适当地处理每一个异常。然而，重启功能赋予你独特的修复正在运行程序并允许其继续运行的能力，这在其他语言中通常是不可能的。
- en: Restarts are discussed in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up
    a Notch with Functional Programming").
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 重启在[第14章](ch16.html "第14章。用函数式编程提升Lisp的层次")中讨论。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782184.png.jpg)'
  id: totrans-1170
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782184.png.jpg)'
- en: Generic Setter Guild Supply Ship
  id: totrans-1171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用设置器供应船
- en: '**Lisp Dialect**'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'To modify the value of a variable in Common Lisp, you use `setf`. However,
    this command also has an amazing special power: Instead of a variable name, you
    can pass it a complex Lisp expression that retrieves a value. It can then turn
    that expression “inside out” and use it to modify that value, rather than simply
    retrieve it. These types of expressions are called *generic setters*.'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改Common Lisp中变量的值，你使用`setf`。然而，此命令还具有惊人的特殊功能：你可以传递一个复杂的Lisp表达式作为参数，该表达式检索一个值。然后它可以反转该表达式并使用它来修改该值，而不仅仅是检索它。这类表达式被称为*通用设置器*。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779817.png)'
  id: totrans-1176
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779817.png)'
- en: Many commands besides `setf` also support generic setters. Using this feature,
    most types of data structures can get by without any specific “setting” functions
    of their own.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`setf`之外，许多命令还支持通用设置器。使用此功能，大多数数据结构类型都可以无需任何特定的“设置”函数。
- en: How It Kills Bugs
  id: totrans-1178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何杀死虫子
- en: When you have a complicated, nested data structure, it’s often easier to understand
    code that retrieves data from a specific location than it is to understand code
    that sets a value at the same location. If you want to set a value at a specific
    location in a complicated structure, you usually need to work backward through
    the structure to figure out how to change it. But with generic setters, you can
    let Lisp handle the hard code for you. Having simpler code is a great way to fight
    bugs.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个复杂、嵌套的数据结构时，理解从特定位置检索数据的代码通常比理解在相同位置设置值的代码更容易。如果你想在复杂结构中的特定位置设置值，你通常需要从结构中向后工作以找出如何更改它。但是，使用通用设置器，你可以让Lisp为你处理复杂的代码。拥有更简单的代码是防止错误的好方法。
- en: Example A-4. Example
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-4. 示例
- en: '[PRE183]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Explanation
  id: totrans-1182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: The example creates a variable named `foo`, which holds a list of three items
    ![](httpatomoreillycomsourcenostarchimages783564.png). The second item in the
    list is an empty hash table. Then it adds a key named `my-key` with a value of
    `77` to the table inside `foo` all at once, by putting a complex expression into
    `setf` that “gets at” this location ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 示例创建了一个名为`foo`的变量，它包含三个项目列表 ![image](httpatomoreillycomsourcenostarchimages783564.png)。列表中的第二个项目是一个空的哈希表。然后它一次性将名为`my-key`的键和值为`77`添加到`foo`内部的表中，通过将一个复杂的表达式放入`setf`中，以“获取”这个位置
    ![image](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Weakness
  id: totrans-1184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: By mutating an existing data structure, generic setters cause a side effect,
    which violates one of the tenets of functional programming. This means they can’t
    be used when programming in a purely functional style.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改现有数据结构，通用设置器产生副作用，这违反了函数式编程的一个原则。这意味着在纯函数式编程风格中不能使用它们。
- en: Generic setters are discussed in [Chapter 9](ch10.html "Chapter 9. Advanced
    Datatypes and Generic Programming").
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 通用设置器在[第9章](ch10.html "第9章。高级数据类型和泛型编程")中讨论。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783056.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages783102.png.jpg)'
  id: totrans-1187
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783056.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages783102.png.jpg)'
- en: DSL Guild Hot Rods
  id: totrans-1188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DSL Guild Hot Rods
- en: '**Lisp Dialect**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Because Lisp has such a simple syntax (everything is delimited with parentheses),
    it is easy to use it to build your own custom programming language, designed for
    a specific domain. Such *domain-specific languages* (*DSLs*) tend to make heavy
    use of the Lisp macro system. They represent an extreme form of macro programming,
    transforming Lisp into a completely new programming language.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lisp有如此简单的语法（所有内容都用括号分隔），因此很容易用它来构建自己的定制编程语言，专为特定领域设计。这种*领域特定语言*（*DSLs*）往往大量使用Lisp宏系统。它们代表了宏编程的极端形式，将Lisp转换成一种全新的编程语言。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781109.png.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781109.png.jpg)'
- en: Explanation
  id: totrans-1194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This is an example of code that uses a DSL to build an HTML page. In this case,
    the page displays “Hello **World**” in a browser, with the second word rendered
    in bold. The `html` and `body` commands (macros created for the HTML library in
    [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros")) generate opening
    and closing tags that will contain the body of the page ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then it calls the regular Lisp function `princ` to generate the text. The second
    word is wrapped in another custom DSL command, `bold` ![](httpatomoreillycomsourcenostarchimages783562.png),
    which generates opening and closing bold tags around the specified text.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用DSL构建HTML页面的代码示例。在这种情况下，页面在浏览器中显示“Hello **World**”，第二个单词以粗体显示。`html`和`body`命令（在第16章[Chapter
    16. The Magic of Lisp Macros](ch18.html "Chapter 16. The Magic of Lisp Macros")中为HTML库创建的宏）生成包含页面主体的开闭标签
    ![image](httpatomoreillycomsourcenostarchimages783564.png)。然后它调用常规的Lisp函数`princ`来生成文本。第二个单词被另一个自定义DSL命令`bold`
    ![image](httpatomoreillycomsourcenostarchimages783562.png)包裹，该命令在指定文本周围生成开闭粗体标签。
- en: Example A-5. Example
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-5. 示例
- en: '[PRE184]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Weakness
  id: totrans-1198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Since DSLs are programming languages you create all by yourself, you can definitely
    shoot yourself in the foot if you aren’t careful. It’s easy to create code in
    a language that is impossible for others (and perhaps even you) to understand.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DSLs是你自己创建的编程语言，如果你不小心，你肯定可以自己给自己挖坑。很容易创建别人（甚至可能是你自己）都无法理解的语言。
- en: '[Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages") discusses DSLs,
    including the DSL that allows you to write HTML directly inside your Lisp code,
    as shown in this example.'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](ch19.html "第17章。领域特定语言") 讨论了DSL，包括允许你直接在Lisp代码中编写HTML的DSL，如本例所示。'
- en: CLOS Guild Battleship
  id: totrans-1201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLOS Guild Battleship
- en: '**Lisp Dialect**'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Common Lisp
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp
- en: Synopsis
  id: totrans-1204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Common Lisp has the most sophisticated object-oriented programming framework
    of any major programming language, called the *Common Lisp Object System* (*CLOS*).
    It is customizable at a fundamental level using the *Metaobject Protocol* (*MOP*).
    There’s really nothing like it anywhere else in programming. It lets you create
    incredibly complex software without losing control over the code.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp拥有任何主要编程语言中最复杂的面向对象编程框架，称为**Common Lisp对象系统**（*CLOS*）。它可以使用**元对象协议**（*MOP*）在基本级别进行自定义。在编程的任何其他地方都找不到类似的东西。它让你能够创建极其复杂的软件，同时又不失去对代码的控制。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782004.png.jpg)'
  id: totrans-1206
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782004.png.jpg)'
- en: How It Kills Bugs
  id: totrans-1207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何杀死虫子
- en: '*Object-oriented programing* (*OOP*) is a commonly used technique for keeping
    bugs under control. By writing code in an object-oriented style, you can *decouple*
    different parts of your code. When you decouple code, you break your code into
    logical components, which can be tested independently.'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向对象编程*（*OOP*）是保持虫子（错误）在控制之下的一种常用技术。通过以面向对象的方式编写代码，你可以*解耦*代码的不同部分。当你解耦代码时，你会将代码分解成逻辑组件，这些组件可以独立进行测试。'
- en: 'Example A-6. Example 1: Wrapping Code Around Methods'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-6. 示例1：将代码包裹在方法周围
- en: '[PRE185]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The basic concepts behind object-oriented programming in Common Lisp are discussed
    in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic Programming").
    For detailed information on the design of CLOS, I recommend reading the CLOS papers
    compiled at [http://www.dreamsongs.com/CLOS.html](http://www.dreamsongs.com/CLOS.html).
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp中面向对象编程的基本概念在第[9章](ch10.html "第9章。高级数据类型和泛型编程")中讨论。有关CLOS设计的详细信息，我建议阅读编译在[http://www.dreamsongs.com/CLOS.html](http://www.dreamsongs.com/CLOS.html)的CLOS论文。
- en: Explanation
  id: totrans-1212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: For this example, imagine we run a company that sells widgets, and we need some
    object-oriented Lisp code to help keep track of them. First, we need to create
    a new CLOS class (called `widget`) with `defclass` ![](httpatomoreillycomsourcenostarchimages783564.png).
    It has one property (or *slot*, in Lisp lingo) describing the widget’s color.
    Next, we declare a `describe-widget`, which prints out a description of the widget
    ![](httpatomoreillycomsourcenostarchimages783562.png). By convention, a function
    designed to operate on a specific type of object is called a *method*. In this
    case, the `describe-widget` is considered a method of the `widget` object.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，假设我们经营一家销售小部件的公司，我们需要一些面向对象的Lisp代码来帮助跟踪它们。首先，我们需要使用`defclass`创建一个新的CLOS类（称为`widget`）
    ![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png)。它有一个属性（或Lisp术语中的*槽*）描述小部件的颜色。接下来，我们声明一个`describe-widget`，它会打印出小部件的描述
    ![httpatomoreillycomsourcenostarchimages783562.png](httpatomoreillycomsourcenostarchimages783562.png)。按照惯例，设计用于操作特定类型对象的函数被称为*方法*。在这种情况下，`describe-widget`被认为是`widget`对象的方法。
- en: Now suppose we want to write an entry to a log file every time a user checks
    on a widget. Using the CLOS, we can declare one or more *before methods* that
    will automatically be called before the main `describe-widget` method is executed
    ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想在用户检查小部件时，每次都向日志文件写入一条条目。使用CLOS，我们可以声明一个或多个**前置方法**，这些方法将在主`describe-widget`方法执行之前自动被调用
    ![httpatomoreillycomsourcenostarchimages783560.png](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'If we didn’t have before methods available, we would need to dirty up our main
    widget code to add logging, like so:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有可用的前置方法，我们需要弄脏我们的主小部件代码以添加日志，如下所示：
- en: '[PRE186]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Here, we’ve added the command for logging ![](httpatomoreillycomsourcenostarchimages783562.png)
    right in the middle of the `describe-widget` method ![](httpatomoreillycomsourcenostarchimages783564.png).
    This code is a lot uglier, because writing to logs has nothing intrinsically to
    do with describing a widget. The logging in this version is also tightly coupled
    to the main code, which means we can no longer test the widget code independently
    from the debugging code. Using the before method leads to cleaner, more decoupled
    code.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `describe-widget` 方法的中间添加了日志记录命令 ![日志记录命令](httpatomoreillycomsourcenostarchimages783562.png)。这段代码看起来很丑，因为将日志写入与描述小部件本质上没有关系。在这个版本中，日志记录也与主代码紧密耦合，这意味着我们不能再独立于调试代码测试小部件代码。使用
    before 方法会导致更干净、更解耦的代码。
- en: Explanation
  id: totrans-1218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This example demontrates *multiple dispatch*, a powerful technique for writing
    methods that are chosen based on the types of their parameters.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了*多重分派*，这是一种强大的技术，可以根据参数的类型选择方法。
- en: 'Example A-7. Example 2: Multiple Dispatch'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-7. 示例 2：多重分派
- en: '[PRE187]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The example begins by creating a `color` class ![](httpatomoreillycomsourcenostarchimages783564.png)
    and also defines three derived classes: `red`, `green`, and `blue` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we declare a `mix` method, which will tell us what happens if we mix any
    two colors. By default, when we mix two colors, it just says, “I don’t know what
    color that makes” ![](httpatomoreillycomsourcenostarchimages783560.png). However,
    using multiple dispatch, *we can define more versions* of the `mix` method. For
    instance, we can declare a version that mixes blue and yellow ![](httpatomoreillycomsourcenostarchimages783554.png),
    and another version for yellow and red ![](httpatomoreillycomsourcenostarchimages783510.png).
    Here’s what happens when we call these methods with different colors:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例首先创建一个 `color` 类 ![创建 color 类](httpatomoreillycomsourcenostarchimages783564.png)
    并定义了三个派生类：`red`、`green` 和 `blue` ![定义派生类](httpatomoreillycomsourcenostarchimages783562.png)。然后我们声明一个
    `mix` 方法，它将告诉我们混合任何两种颜色会发生什么。默认情况下，当我们混合两种颜色时，它只是说，“我不知道那是什么颜色” ![混合颜色](httpatomoreillycomsourcenostarchimages783560.png)。然而，使用多重分派，我们可以定义更多版本的
    `mix` 方法。例如，我们可以声明一个混合蓝色和黄色的版本 ![混合蓝色和黄色](httpatomoreillycomsourcenostarchimages783554.png)，以及一个混合黄色和红色的版本
    ![混合黄色和红色](httpatomoreillycomsourcenostarchimages783510.png)。以下是使用不同颜色调用这些方法时发生的情况：
- en: '[PRE188]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The important thing to note about the example is that in order to figure out
    which mix method to call in a given situation, the CLOS needs to take into account
    both of the objects passed into the method. It is *dispatching* to a specific
    implementation of the method based on the types of *multiple* objects. This is
    a feature that is not available in traditional object-oriented languages, such
    as Java or C++.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个示例的重要事项是，为了确定在给定情况下调用哪个混合方法，CLOS 需要考虑传递给方法的所有对象。它是基于*多个*对象类型的*分派*到特定方法实现的。这是传统面向对象语言（如
    Java 或 C++）中不可用的功能。
- en: Weakness
  id: totrans-1225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Opinions vary widely in the Lisp community as to how large a role object-oriented
    techniques should play in programming. The critics of this style complain that
    object-oriented techniques force data to be hidden away in lot of disparate places
    by requiring them to live inside many different objects. Having data located in
    disparate places can make programs difficult to understand, especially if that
    data changes over time. Therefore, many Lispers prefer to use functional techniques
    over object-oriented techniques, though the two can often be used together with
    some care. Nonetheless, there are still many domains in which object-oriented
    techniques are invaluable, such as in user interface programming or simulation
    programming.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 社区中关于面向对象技术在编程中应扮演多大角色的观点差异很大。这种风格的批评者抱怨说，面向对象技术通过要求它们存在于许多不同的对象中，迫使数据隐藏在许多不同的地方。数据位于不同的地方可能会使程序难以理解，尤其是如果这些数据随时间变化。因此，许多
    Lisp 程序员更喜欢使用函数式技术而不是面向对象技术，尽管这两种技术通常可以谨慎地一起使用。尽管如此，仍然有许多领域在面向对象技术中非常有价值，例如用户界面编程或模拟编程。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780010.png.jpg)'
  id: totrans-1227
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780010.png.jpg)'
- en: The Continuation Guild Rocket Pods
  id: totrans-1228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Continuation Guild 火箭舱
- en: '**Lisp Dialect**'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp 方言**'
- en: Scheme (limited support in Common Lisp with *continuation-passing style*, or
    through the use of special libraries)
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 方案（在 Common Lisp 中有限制地支持，例如通过使用*延续传递风格*或通过使用特殊库）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783034.png)'
  id: totrans-1231
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](http://atomoreilly.com/source/nostarch/images/783034.png)'
- en: Synopsis
  id: totrans-1232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: In the 1970s, a special dialect of Lisp was created that featured a particularly
    powerful programming feature called *continuations*. Basically, continuations
    let you put “time travel” into your code. This allows you to do things like run
    programs backward, sideways, or in other crazy ways. For instance, it’s great
    for implementing advanced programming techniques, such as *nondeterministic programming*.
    In nondeterministic programming, you write code that offers the computer multiple
    choices for what to do next. If one choice isn’t satisfactory, the computer can
    “roll back time” with continuations to try a different path.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 20 世纪 70 年代，创建了一种特殊的 Lisp 方言，它具有一个特别强大的编程特性，称为 *延续*。基本上，延续让你可以将“时间旅行”放入你的代码中。这允许你做一些事情，比如运行程序的逆向、横向或其他疯狂的方式。例如，这对于实现高级编程技术，如
    *非确定性编程* 非常有用。在非确定性编程中，你编写代码，让计算机有多个选择来决定下一步做什么。如果某个选择不满意，计算机可以使用延续“回滚时间”来尝试不同的路径。
- en: Example A-8. Example
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 A-8. 示例
- en: '[PRE189]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Note
  id: totrans-1236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is in the Scheme Lisp dialect and won’t run in Common Lisp.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是 Scheme Lisp 语言的，不会在 Common Lisp 中运行。
- en: How It Kills Bugs
  id: totrans-1238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何杀死错误
- en: There are many situations where having time travel in your code can make the
    code easier to understand. The classic example is in a web server. Often, a person
    must visit several pages on a web page in order to perform a single action. With
    a continuation-aware web server, you can write code that pretends these pages
    were visited all at the same time, making your code a lot less buggy. Later on,
    the web server uses continuations to break your code into several parts (by using
    the time-travel abilities of continuations), taking care of all the ugly details
    of handling a multipage web action.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况，在代码中拥有时间旅行可以使代码更容易理解。经典的例子是在一个网络服务器中。通常，一个人必须访问网页上的几个页面才能执行一个单一的操作。使用了解延续的网络服务器，你可以编写代码，让这些页面看起来是同时访问的，这使得你的代码的bug少得多。稍后，网络服务器使用延续将你的代码分成几个部分（通过使用延续的时间旅行能力），处理处理多页面网络操作的所有丑陋细节。
- en: Explanation
  id: totrans-1240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: In the example, we create a simple function called `foo` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which adds one to a number, and then doubles it. For instance, running `(foo 7)`
    will return `16`. However, inside the function, there is a call to `call-with-current-continuation`
    ![](httpatomoreillycomsourcenostarchimages783562.png), which captures the state
    of the function before the doubling step. It saves this “moment in time” in the
    variable `continuation` ![](httpatomoreillycomsourcenostarchimages783560.png).
    The current state of the running program is captured at this line ![](httpatomoreillycomsourcenostarchimages783562.png).
    Everything that happens *after* the continuation was captured will then be executed
    if we call the captured continuation. The only part of the `foo` command that
    happens after the continuation was captured is the multiplication by two ![](httpatomoreillycomsourcenostarchimages783554.png).
    Consequently, the variable `continuation` is now a time machine that we can use
    to jump into this past moment to switch out the number we want to double with
    another one. So, if we were to now call `(continuation 100)`, it would return
    200 (which is 100 doubled). We have traveled backward in time!
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们创建了一个简单的函数，名为 `foo` ![http://atomoreilly.com/source/nostarch/images/783564.png]，它将一个数字加一，然后将其翻倍。例如，运行
    `(foo 7)` 将返回 `16`。然而，在函数内部，有一个对 `call-with-current-continuation` 的调用 ![http://atomoreilly.com/source/nostarch/images/783562.png]，它捕获了翻倍步骤之前的函数状态。它将这个“时间点”保存在变量
    `continuation` ![http://atomoreilly.com/source/nostarch/images/783560.png] 中。当前程序的运行状态在此行被捕获
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。如果调用捕获的延续，那么在延续被捕获之后发生的所有事情都将被执行。在延续被捕获之后发生的
    `foo` 命令的唯一部分是乘以二 ![http://atomoreilly.com/source/nostarch/images/783554.png]。因此，变量
    `continuation` 现在是一个时间机器，我们可以用它跳回到这个过去时刻，用另一个数字替换我们想要翻倍的数字。所以，如果我们现在调用 `(continuation
    100)`，它将返回 200（这是 100 翻倍的结果）。我们已经回到了过去！
- en: Weakness
  id: totrans-1242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Continuations are such an awesome feature that they don’t really have a downside.
    The only real problem they present is for creators of programming languages. True
    continuations are technically difficult to put into a programming language, so
    few languages support them. Scheme happens to be one of them. To learn more about
    continuation-based web servers, see “Implementation and Use of the PLT Scheme
    Web Server”by Shriram Krishnamurthi, et al.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 续续是如此出色的特性，以至于它几乎没有缺点。它唯一真正的问题是对于编程语言的创造者。真正的续续在技术上很难放入编程语言中，所以很少有语言支持它们。Scheme碰巧是其中之一。想了解更多关于基于续续的Web服务器，请参阅Shriram
    Krishnamurthi等人撰写的“PLT Scheme Web服务器的实现和使用”。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782118.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages782166.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781552.png.jpg)![image
    with no caption](httpatomoreillycomsourcenostarchimages781592.png.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782118.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages782166.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781552.png.jpg)![无标题图片](httpatomoreillycomsourcenostarchimages781592.png.jpg)'
- en: Brevity Guild Micro Fighter
  id: totrans-1245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简洁派微战斗机
- en: '**Lisp Dialect**'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Arc Lisp (indirectly available in Common Lisp using custom macros)
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: Arc Lisp（在Common Lisp中使用自定义宏间接可用）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779769.png.jpg)'
  id: totrans-1248
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779769.png.jpg)'
- en: Synopsis
  id: totrans-1249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Lisp allows you to write code that is incredibly concise but doesn’t look like
    your cat walked over your keyboard. (I’m looking at you, Perl!) This is possible
    because of the various features we’ve already mentioned, such as macros, functional
    programming, and Lisp’s dynamic typing system.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp允许你编写非常简洁的代码，但看起来并不像是你的猫在键盘上走过。（我正在看着你，Perl！）这是由于我们已经提到的各种特性，例如宏、函数式编程和Lisp的动态类型系统。
- en: 'There is one Lisp dialect, however, that takes this idea to the extreme: Arc.
    In fact, code brevity is the primary design goal for this language. Paul Graham,
    the designer of Arc, analyzed large amounts of computer code in an attempt to
    figure out which primitive commands are needed to write code that is as concise
    as possible, while keeping the code readable.'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种Lisp方言将这一理念推向了极致：Arc。事实上，代码简洁性是这种语言的主要设计目标。Arc的设计者保罗·格雷厄姆分析了大量计算机代码，试图找出编写尽可能简洁的代码所需的原始命令，同时保持代码的可读性。
- en: How It Kills Bugs
  id: totrans-1252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它如何杀死虫子
- en: With Arc, the goal is to write programs that are short. It is designed to let
    you say what you want to say in the most concise way possible, leaving no place
    for bugs to hide.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Arc，目标是编写简短的程序。它旨在让你以最简洁的方式表达你的想法，不留任何让错误隐藏的地方。
- en: Example A-9. Example
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-9. 示例
- en: '[PRE190]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is in the Arc Lisp dialect and won’t run in Common Lisp.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是在Arc Lisp方言中，不会在Common Lisp中运行。
- en: Explanation
  id: totrans-1258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This example creates a list of all prime numbers between 1 and 1000, using the
    naïve method of checking for smaller numbers that divide evenly into the current
    loop value.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用检查当前循环值是否有较小数可以整除的朴素方法，创建了一个包含1到1000之间所有素数的列表。
- en: The `accum` function creates a local function named `a`, which is used to collect
    any primes that are found ![](httpatomoreillycomsourcenostarchimages783564.png).
    We iterate through the integers with a `for` loop ![](httpatomoreillycomsourcenostarchimages783562.png),
    checking for smaller numbers that divide evenly into the current value of `i`
    ![](httpatomoreillycomsourcenostarchimages783560.png). If none are are found,
    `i` is added to the list of primes ![](httpatomoreillycomsourcenostarchimages783554.png),
    by calling the function `a` with this new number. The brackets, `[ ]`, are a shortcut
    for creating a lambda function with one parameter, which is accessed with the
    underscore character.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '`accum`函数创建了一个名为`a`的局部函数，用于收集找到的任何素数！[](httpatomoreillycomsourcenostarchimages783564.png)。我们使用`for`循环！[](httpatomoreillycomsourcenostarchimages783562.png)遍历整数，检查是否有比当前`i`的值小的数可以整除`i`！[](httpatomoreillycomsourcenostarchimages783560.png)。如果没有找到，`i`将通过调用带有这个新数字的函数`a`添加到素数列表！[](httpatomoreillycomsourcenostarchimages783554.png)。方括号`[
    ]`是创建具有一个参数的lambda函数的快捷方式，该参数通过下划线字符访问。'
- en: Weakness
  id: totrans-1261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Finding an optimally concise set of commands is difficult. With too many commands
    available, your code can become hard to understand, since it’s difficult to remember
    what each function does. With too few commands, programs can get too bulky. Arc
    Lisp tries to find a happy medium, although there’s still room for alternative
    language designs optimized for code brevity.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个最优的简洁命令集是困难的。当可用的命令太多时，你的代码可能难以理解，因为难以记住每个函数的作用。当命令太少时，程序可能会变得过于庞大。Arc Lisp试图找到一个折中的方案，尽管仍有空间为代码简洁性优化的替代语言设计。
- en: '[Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros") demonstrates
    how to use macros to make your code concise, and many other examples of Lisp’s
    powers of brevity are shown in the chapters following that discussion.'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](ch18.html "第16章。Lisp宏的魔力")展示了如何使用宏来使代码简洁，以及在该讨论之后章节中展示了Lisp简洁性的许多其他示例。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781032.png.jpg)'
  id: totrans-1264
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781032.png.jpg)'
- en: Multicore Guild Formation Fighters
  id: totrans-1265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多核公会战斗者
- en: '**Lisp Dialect**'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp方言**'
- en: Clojure Lisp (available in Common Lisp with the CL-STM extension)
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure Lisp（在Common Lisp中通过CL-STM扩展提供）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783054.png)'
  id: totrans-1268
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783054.png)'
- en: Synopsis
  id: totrans-1269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Now that most computers have multiple cores, there is a lot of interest in finding
    elegant ways to write multicore/multithreaded code. One popular approach is to
    use functional data structures along with a *software transactional memory* system.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数计算机都有多个核心，因此寻找编写多核/多线程代码的优雅方法引起了广泛关注。一种流行的方法是使用功能数据结构以及一个*软件事务内存*系统。
- en: Using software transactional memory, you can share complex data structures between
    several threads, with a guarantee that no thread will see inconsistent information
    in the data, even if it tries to read shared data while another thread is attempting
    to write to it.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软件事务内存，你可以在几个线程之间共享复杂的数据结构，并保证没有任何线程会在数据中看到不一致的信息，即使它在另一个线程尝试写入共享数据时尝试读取它。
- en: How It Fights Bugs
  id: totrans-1272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何战斗错误
- en: Multithreaded code tends to be very buggy. By using software transactional memory,
    you can greatly increase your odds of writing bug-free multithreaded software.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程代码往往非常容易出错。通过使用软件事务内存，你可以大大提高编写无bug多线程软件的机会。
- en: Explanation
  id: totrans-1274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: In this example, we define two bank accounts called `checking` and `savings`
    ![](httpatomoreillycomsourcenostarchimages783564.png), with a total amount of
    $300 between them. We then define a `transfer-to-savings` function, which can
    be called to move money from the `checking` account to the `savings` account ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了两个账户，分别称为`checking`和`savings`![](httpatomoreillycomsourcenostarchimages783564.png)，它们之间的总金额为$300。然后我们定义了一个`transfer-to-savings`函数，可以通过调用它将钱从`checking`账户转移到`savings`账户![](httpatomoreillycomsourcenostarchimages783562.png)。
- en: Example A-10. Example
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-10. 示例
- en: '[PRE191]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Note
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用Clojure Lisp方言，无法在Common Lisp中运行。
- en: Because this function contains a `dosync` block, Clojure will make sure these
    two `alter` operations ![](httpatomoreillycomsourcenostarchimages783560.png) happen
    at the same moment in time. Of course, both values aren’t really altered at the
    exact same point in time, but the language makes sure it will appear to happen
    simultaneously. If another thread were to read these two accounts at the same
    time, also within a `dosync` block, it would see exactly $300 in the combined
    accounts, no matter how many times either thread checks these values.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个函数包含一个`dosync`块，Clojure会确保这两个`alter`操作![](httpatomoreillycomsourcenostarchimages783560.png)在相同的时间点发生。当然，这两个值并不是在完全相同的时间点被修改，但语言确保它们看起来是同时发生的。如果另一个线程在`dosync`块内同时读取这两个账户，它将看到总金额正好是$300，无论哪个线程检查这些值多少次。
- en: Weakness
  id: totrans-1281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Software transactional memory carries a performance penalty that cancels out
    some of the performance gains that come with using multiple CPU cores. However,
    as the number of CPU cores increases, this penalty is less of an issue.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 软件事务内存会带来性能损失，这抵消了使用多个CPU核心带来的部分性能提升。然而，随着CPU核心数量的增加，这种损失变得越来越小。
- en: The Lazy Guild Frigate
  id: totrans-1283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰公会战舰
- en: Lisp Dialect
  id: totrans-1284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lisp方言
- en: Clojure (available in Common Lisp with the Series library, CLAZY library, or
    custom macros)
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure（在Common Lisp中通过Series库、CLAZY库或自定义宏提供）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783350.png.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783350.png.jpg)'
- en: Synopsis
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: A lazy programming language will perform a calculation *only* if the compiler
    determines it is absolutely necessary to produce a visible result. Clojure is
    the most popular Lisp dialect to include lazy programming as a primary feature.
    However, limited forms of lazy programming are common in all Lisp dialects.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 懒编程语言仅在编译器确定它绝对必要以产生可见结果时才会执行计算。Clojure是最受欢迎的包含懒编程作为主要特性的Lisp方言。然而，所有Lisp方言中都有懒编程的有限形式。
- en: How It Kills Bugs
  id: totrans-1289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何杀死错误
- en: Lazy languages let you create infinitely big data structures (as long as you
    don’t try to use *all* of the data), which allows more of your code to be formulated
    as transformations of large data structures. In general, it is easier to debug
    data structures than it is to debug algorithms. Algorithms involve steps that
    unfold over time, and to understand them, you usually need to watch them as they
    execute. Data, on the other hand, exists independently of time, which means you
    can find bugs in a data structure just by looking at it.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰的语言允许你创建无限大的数据结构（只要你不尝试使用*所有*的数据），这使得更多的代码可以表述为大型数据结构的转换。一般来说，调试数据结构比调试算法更容易。算法涉及随时间展开的步骤，要理解它们，你通常需要观察它们执行的过程。另一方面，数据独立于时间存在，这意味着你只需查看数据结构就能找到其中的错误。
- en: Example A-11. Example
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例A-11. 示例
- en: '[PRE192]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Note
  id: totrans-1293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is in the Clojure Lisp dialect and won’t run in Common Lisp.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用Clojure Lisp方言，无法在Common Lisp中运行。
- en: Explanation
  id: totrans-1295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明
- en: This code returns the first 20 even positive integers. To do this, it first
    creates an infinite list of all positive integers ![](httpatomoreillycomsourcenostarchimages783560.png),
    using the `iterate` function to create a list of integers starting at zero. Then
    it filters out the even numbers ![](httpatomoreillycomsourcenostarchimages783562.png).
    Finally, it takes the first 20 numbers from that result ![](httpatomoreillycomsourcenostarchimages783564.png).
    Until the final `take` command, the data structures being operated on are theoretically
    infinite. However, since Clojure is a lazy language, it instantiates these data
    structures only on an as-needed basis. This means that only the first 20 such
    numbers are ever generated. (And even then, they are generated only if we actually
    use the final value somehow, such as printing it to the screen.)
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码返回前20个正偶数。为此，它首先使用`iterate`函数创建一个从零开始的整数列表，形成一个无限大的正整数列表 ![](httpatomoreillycomsourcenostarchimages783560.png)。然后它过滤出偶数
    ![](httpatomoreillycomsourcenostarchimages783562.png)。最后，它从该结果中取出前20个数字 ![](httpatomoreillycomsourcenostarchimages783564.png)。直到最后的`take`命令，正在操作的数据结构在理论上是无尽的。然而，由于Clojure是一种懒语言，它仅在需要时实例化这些数据结构。这意味着只有前20个这样的数字会被生成。（即使如此，只有在实际使用最终值的情况下，例如将其打印到屏幕上，它们才会被生成。）
- en: Weakness
  id: totrans-1297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱点
- en: Since a lazy programming language chooses the order in which your code is run,
    it can lead to debugging headaches if you try to trace your code as it is running.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于懒编程语言选择代码运行的顺序，如果你尝试跟踪代码的执行过程，可能会导致调试困难。
- en: '[Chapter 18](ch20.html "Chapter 18. Lazy Programming") discusses lazy programming.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch20.html "第18章。懒编程") 讨论了懒编程。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782876.png.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782876.png.jpg)'
