- en: 'Chapter 16. Network Drivers, Part 1: Data Structures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章。网络驱动程序，第 1 部分：数据结构
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: '*Network devices*, or *interfaces*, transmit and receive data packets that
    are driven by the network subsystem (Corbet et al., 2005). In this chapter, we’ll
    examine the data structures used to manage these devices: `ifnet`, `ifmedia`,
    and `mbuf`. You’ll then learn about Message Signaled Interrupts, which are an
    alternative to traditional interrupts and are commonly used by network devices.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络设备* 或 *接口* 通过网络子系统（Corbet 等人，2005）发送和接收由网络子系统驱动的数据包。在本章中，我们将检查用于管理这些设备的数据结构：`ifnet`、`ifmedia`
    和 `mbuf`。然后，您将了解消息信号中断，它们是传统中断的替代品，通常由网络设备使用。'
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To keep things simple, we’ll examine only Ethernet drivers. Also, I won’t provide
    a discussion on general networking concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们只检查以太网驱动程序。此外，我不会提供关于通用网络概念的讨论。
- en: Network Interface Structures
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口结构
- en: 'An `ifnet` structure is the kernel’s representation of an individual network
    interface. It is defined in the `<net/if_var.h>` header as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifnet` 结构是内核对单个网络接口的表示。它在 `<net/if_var.h>` 头文件中定义如下：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ll demonstrate how `struct ifnet` is used in [Hello, world!](ch16s05.html
    "Hello, world!") in [Hello, world!](ch16s05.html "Hello, world!"). For now, let’s
    look at its method fields.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 [Hello, world!](ch16s05.html "Hello, world!") 中演示如何使用 `struct ifnet`，在 [Hello,
    world!](ch16s05.html "Hello, world!") 中。现在，让我们看看它的方法字段。
- en: The ![](httpatomoreillycomsourcenostarchimages1137507.png) `if_init` field identifies
    the interface’s init routine. *Init routines* are called to initialize their interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137507.png) `if_init` 字段标识了接口的初始化例程。*初始化例程*
    被调用以初始化其接口。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137505.png) `if_ioctl` field
    identifies the interface’s ioctl routine. Characteristically, ioctl routines are
    used to configure their interface (for example, for setting the maximum transmission
    unit).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137505.png) `if_ioctl` 字段标识了接口的
    ioctl 例程。典型地，ioctl 例程用于配置其接口（例如，设置最大传输单元）。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137501.png) `if_input` field
    identifies the interface’s input routine. An interface sends an interrupt whenever
    it receives a packet. Its driver-defined interrupt handler then calls its *input
    routine* to process the packet. Note that this is a departure from the norm. Input
    routines are called by a driver, while the other routines are called by the network
    stack. The `if_input` field generally points to a link layer routine (for example,
    `ether_input`) rather than a driver-defined routine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137501.png) `if_input` 字段标识了接口的输入例程。每当接口接收到数据包时，它都会发送一个中断。其驱动程序定义的中断处理程序随后调用其
    *输入例程* 来处理数据包。请注意，这与常规做法不同。输入例程是由驱动程序调用的，而其他例程是由网络栈调用的。`if_input` 字段通常指向链路层例程（例如，`ether_input`），而不是由驱动程序定义的例程。'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, link layer routines are kernel defined. Method fields that expect
    a link layer routine should be defined by an `*ifattach` function (such as `ether_ifattach`),
    not directly by a driver. `*ifattach` functions are described in [Network Interface
    Structure Management Routines](ch16s02.html "Network Interface Structure Management
    Routines") in [Network Interface Structure Management Routines](ch16s02.html "Network
    Interface Structure Management Routines").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，链路层例程是由内核定义的。期望链路层例程的方法字段应由 `*ifattach` 函数（例如 `ether_ifattach`）定义，而不是直接由驱动程序定义。`*ifattach`
    函数在 [网络接口结构管理例程](ch16s02.html "网络接口结构管理例程") 中描述。
- en: The ![](httpatomoreillycomsourcenostarchimages1137499.png) `if_output` field
    identifies the interface’s output routine. *Output routines* are called by the
    network stack to prepare an upper-layer packet for transmission. Every output
    routine ends by calling its interface’s ![](httpatomoreillycomsourcenostarchimages1137513.png)
    transmit routine. If an interface lacks a transmit routine, its ![](httpatomoreillycomsourcenostarchimages1137503.png)
    start routine is called instead. Typically, when a network driver defines a transmit
    routine, its start routine is undefined, and vice versa. The `if_output` field
    generally points to a link layer routine (for example, `ether_output`) rather
    than a driver-defined routine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137499.png) `if_output` 字段标识了接口的输出例程。*输出例程*由网络栈调用，以准备上层数据包进行传输。每个输出例程都以调用其接口的
    ![](httpatomoreillycomsourcenostarchimages1137513.png) 传输例程结束。如果一个接口缺少传输例程，则调用其
    ![](httpatomoreillycomsourcenostarchimages1137503.png) 启动例程。通常，当网络驱动程序定义传输例程时，其启动例程是未定义的，反之亦然。`if_output`
    字段通常指向链路层例程（例如，`ether_output`），而不是由驱动程序定义的例程。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137503.png) `if_start` field
    identifies the interface’s start routine. Before I describe start routines, it’s
    important to discuss ![](httpatomoreillycomsourcenostarchimages1137517.png) send
    queues. Send queues are filled by output routines. *Start routines* remove one
    packet from their send queue and deposit it in their interface’s transmit ring.
    They repeat this process until the send queue is empty or the transmit ring is
    full. Transmit rings are simply ring buffers used for transmission. Network interfaces
    use ring buffers for transmission and reception.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137503.png) `if_start` 字段标识了接口的启动例程。在描述启动例程之前，讨论
    ![](httpatomoreillycomsourcenostarchimages1137517.png) 发送队列是很重要的。发送队列由输出例程填充。*启动例程*从它们的发送队列中移除一个数据包并将其存入接口的传输环。它们重复此过程，直到发送队列为空或传输环已满。传输环是用于传输的简单环形缓冲区。网络接口使用环形缓冲区进行传输和接收。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137513.png) `if_transmit` field
    identifies the interface’s transmit routine. Transmit *routines* are an alternative
    to start routines. Transmit routines maintain their own send queues. That is,
    they forego the ![](httpatomoreillycomsourcenostarchimages1137517.png) predefined
    send queue, and output routines push packets directly to them. Transmit routines
    can maintain multiple send queues, which makes them ideal for interfaces with
    multiple transmit rings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137513.png) `if_transmit` 字段标识了接口的传输例程。传输
    *例程* 是启动例程的替代方案。传输例程维护自己的发送队列。也就是说，它们放弃了 ![](httpatomoreillycomsourcenostarchimages1137517.png)
    预定义的发送队列，并且输出例程直接将数据包推送到它们。传输例程可以维护多个发送队列，这使得它们非常适合具有多个传输环的接口。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137511.png) `if_qflush` field
    identifies the interface’s qflush routine. *Qflush routines* are called to flush
    the send queues of transmit routines. Every transmit routine must have a corresponding
    qflush routine.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137511.png) `if_qflush` 字段标识了接口的
    qflush 例程。*Qflush 例程*被调用以清除传输例程的发送队列。每个传输例程都必须有一个相应的 qflush 例程。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137509.png) `if_resolvemulti`
    field identifies the interface’s resolvemulti routine. *Resolvemulti routines*
    are called to resolve a network layer address into a link layer address when registering
    a multicast address with their interface. The `if_resolvemulti` field generally
    points to a link layer routine (for example, `ether_resolvemulti`) rather than
    a driver-defined routine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137509.png) `if_resolvemulti` 字段标识了接口的
    resolvemulti 例程。*Resolvemulti 例程*被调用以在将多播地址注册到其接口时将网络层地址解析为链路层地址。`if_resolvemulti`
    字段通常指向链路层例程（例如，`ether_resolvemulti`），而不是由驱动程序定义的例程。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137515.png) `if_reassign` field
    identifies the interface’s reassign routine. Reassign *routines* are called before
    their interface is moved to another virtual network stack (vnet). They perform
    any tasks necessary before the move. The `if_reassign` field generally points
    to a link layer routine (for example, `ether_reassign`) rather than a driver-defined
    routine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1137515.png) `if_reassign` 字段标识了接口的重新分配例程。在接口移动到另一个虚拟网络栈（vnet）之前，会调用重新分配
    *例程*。它们执行移动之前所需的任何任务。`if_reassign` 字段通常指向链路层例程（例如，`ether_reassign`），而不是由驱动程序定义的例程。'
- en: The `if_watchdog` field is deprecated and must *not* be defined. In FreeBSD
    version 9, `if_watchdog` will be removed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`if_watchdog` 字段已被弃用，并且必须**不**定义。在 FreeBSD 版本 9 中，`if_watchdog` 将被移除。'
- en: Network Interface Structure Management Routines
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口结构管理例程
- en: 'The FreeBSD kernel provides the following functions for working with `ifnet`
    structures:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了以下函数来处理 `ifnet` 结构：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An `ifnet` structure is a dynamically allocated structure that’s owned by the
    kernel. That is, you cannot allocate a `struct ifnet` on your own. Instead, you
    must call `if_alloc`. The ![](httpatomoreillycomsourcenostarchimages1137499.png)
    type argument is the interface type (for example, Ethernet devices are `IFT_ETHER`).
    Symbolic constants for every interface type can be found in the `<net/if_types.h>`
    header.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifnet` 结构是一个由内核拥有的动态分配的结构。也就是说，你不能自己分配一个 `struct ifnet`。相反，你必须调用 `if_alloc`。类型参数是接口类型（例如，以太网设备是
    `IFT_ETHER`）。每个接口类型的符号常量可以在 `<net/if_types.h>` 头文件中找到。'
- en: Allocating an `ifnet` structure does not make the interface available to the
    system. To do that, you must initialize the structure (by defining the necessary
    fields) and then call `if_attach`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个 `ifnet` 结构并不会使接口对系统可用。为了做到这一点，你必须初始化该结构（通过定义必要的字段），然后调用 `if_attach`。
- en: The `if_initname` function is a convenient function for setting an ![](httpatomoreillycomsourcenostarchimages1137501.png)
    interface’s ![](httpatomoreillycomsourcenostarchimages1137503.png) name and ![](httpatomoreillycomsourcenostarchimages1137505.png)
    unit number. (Needless to say, this function is used before `if_attach`.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`if_initname` 函数是一个方便的函数，用于设置接口的名称和单元号。 （不用说，这个函数是在 `if_attach` 之前使用的。）'
- en: When an `ifnet` structure is no longer needed, it should be deactivated with
    `if_detach`, after which it can be freed with `if_free`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `ifnet` 结构不再需要时，应该使用 `if_detach` 来使其失效，之后可以使用 `if_free` 来释放它。
- en: ether_ifattach Function
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ether_ifattach` 函数'
- en: The `ether_ifattach` function is a variant of `if_attach` that’s used for Ethernet
    devices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ether_ifattach` 函数是 `if_attach` 的一个变体，用于以太网设备。'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function is defined in the */sys/net/if_ethersubr.c* source file as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在 */sys/net/if_ethersubr.c* 源文件中定义如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function takes an ifnet structure, ![](httpatomoreillycomsourcenostarchimages1137499.png)
    ifp, and a link layer address, ![](httpatomoreillycomsourcenostarchimages1137501.png)
    lla, and sets up `ifp` for an Ethernet device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个 `ifnet` 结构，`ifp`，和一个链路层地址，`lla`，并为以太网设备设置 `ifp`。
- en: As you can see, it assigns certain values to `ifp`, including assigning the
    appropriate link layer routine to ![](httpatomoreillycomsourcenostarchimages1137503.png)
    `if_output`, ![](httpatomoreillycomsourcenostarchimages1137505.png) `if_input`,
    ![](httpatomoreillycomsourcenostarchimages1137507.png) `if_resolvemulti`, and
    ![](httpatomoreillycomsourcenostarchimages1137509.png) `if_reassign`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它为 `ifp` 分配了某些值，包括将适当的链路层例程分配给 `if_output`、`if_input`、`if_resolvemulti`
    和 `if_reassign`。
- en: ether_ifdetach Function
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ether_ifdetach` 函数'
- en: The `ether_ifdetach` function is a variant of `if_detach` that’s used for Ethernet
    devices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ether_ifdetach` 函数是 `if_detach` 的一个变体，用于以太网设备。'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function is used to deactivate an `ifnet` structure set up by `ether_ifattach`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于使由 `ether_ifattach` 设置的 `ifnet` 结构失效。
- en: Network Interface Media Structures
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口媒体结构
- en: 'An `ifmedia` structure catalogs every media type that is supported by a network
    interface (for example, 100BASE-TX, 1000BASE-SX, and so on). It is defined in
    the `<net/if_media.h>` header as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifmedia` 结构列出了网络接口支持的每种媒体类型（例如，100BASE-TX、1000BASE-SX 等）。它在 `<net/if_media.h>`
    头文件中定义如下：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Network Interface Media Structure Management Routines
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口媒体结构管理例程
- en: 'The FreeBSD kernel provides the following functions for working with ifmedia
    structures:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 内核提供了以下函数来处理 `ifmedia` 结构：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An `ifmedia` structure is a statically allocated structure that’s owned by a
    network driver. To initialize an `ifmedia` structure, you must call `ifmedia_init`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifmedia` 结构是一个由网络驱动程序拥有的静态分配的结构。要初始化一个 `ifmedia` 结构，你必须调用 `ifmedia_init`。'
- en: The ![](httpatomoreillycomsourcenostarchimages1137499.png) `dontcare_mask` argument
    marks the bits in ![](httpatomoreillycomsourcenostarchimages1137507.png) ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `mword` that can be ignored. Usually, `dontcare_mask` is set to `0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`dontcare_mask` 参数标记 `mword` 中的位，这些位可以忽略。通常，`dontcare_mask` 设置为 `0`。'
- en: 'The ![](httpatomoreillycomsourcenostarchimages1137501.png) `change_callback`
    argument denotes a callback function. This function is executed to change the
    media type or media options. Here is its function prototype:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`change_callback` 参数表示一个回调函数。此函数执行以更改媒体类型或媒体选项。以下是其函数原型：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Users can change an interface’s media type or media options with `ifconfig(8)`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用 `ifconfig(8)` 命令更改接口的媒体类型或媒体选项。
- en: 'The ![](httpatomoreillycomsourcenostarchimages1137503.png) `status_callback`
    argument denotes a callback function. This function is executed to return the
    media status. Here is its function prototype:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`status_callback` 参数表示一个回调函数。此函数执行以返回媒体状态。以下是其函数原型：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Users can query an interface’s media status with `ifconfig(8)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用 `ifconfig(8)` 命令查询接口的媒体状态。
- en: The `ifmedia_add` function adds a media type to ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `ifm`. The ![](httpatomoreillycomsourcenostarchimages1137507.png) `mword` argument
    is a 32-bit “word” that identifies the media type. Valid values for `mword` are
    defined in `<net/if_media.h>`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifmedia_add` 函数向 `ifm` 添加媒体类型。`mword` 参数是一个 32 位“字”，用于标识媒体类型。`mword` 的有效值在
    `<net/if_media.h>` 中定义。'
- en: 'Here are the `mword` values for Ethernet devices:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是以太网设备的 `mword` 值：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As an example, the `mword` value for 100BASE-TX is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，100BASE-TX 的 `mword` 值如下：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Table 16-1](ch16s04.html#bit-by-bit_breakdown_of_mword "Table 16-1. Bit-by-Bit
    Breakdown of mword") describes how each bit in `mword` is used. It also displays
    the bitmasks that can be passed to `dontcare_mask` to ignore those bits.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](ch16s04.html#bit-by-bit_breakdown_of_mword "表 16-1. `mword` 的位分解")
    描述了 `mword` 中每个位的用途。它还显示了可以传递给 `dontcare_mask` 以忽略这些位的位掩码。'
- en: Table 16-1. Bit-by-Bit Breakdown of `mword`
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-1. `mword` 的位分解
- en: '| Bits | Purpose of Bits | Mask to Ignore Bits |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 比特 | 比特用途 | 忽略比特的掩码 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 00–04 | Denotes the media type variant (for example, 100BASE-TX) | `IFM_TMASK`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 00–04 | 表示媒体类型变体（例如，100BASE-TX） | `IFM_TMASK` |'
- en: '| 05–07 | Denotes the media type (for example, Ethernet) | `IFM_NMASK` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 05–07 | 表示媒体类型（例如，以太网） | `IFM_NMASK` |'
- en: '| 08–15 | Denotes the media type specific options | `IFM_OMASK` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 08–15 | 表示媒体类型特定选项 | `IFM_OMASK` |'
- en: '| 16–18 | Denotes the media type mode (for multimode media only) | `IFM_MMASK`
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 16–18 | 表示媒体类型模式（仅适用于多模态媒体） | `IFM_MMASK` |'
- en: '| 19 | Reserved for future use | n/a |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 保留供将来使用 | n/a |'
- en: '| 20–27 | Denotes the shared options (for example, force full-duplex) | `IFM_GMASK`
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 20–27 | 表示共享选项（例如，强制全双工） | `IFM_GMASK` |'
- en: '| 28–31 | Denotes the `mword` instance | `IFM_IMASK` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 28–31 | 表示 `mword` 实例 | `IFM_IMASK` |'
- en: The ![](httpatomoreillycomsourcenostarchimages1137509.png) `data` and ![](httpatomoreillycomsourcenostarchimages1137511.png)
    `aux` arguments allow drivers to provide metadata about `mword`. Because drivers
    typically have no metadata to provide, `data` and `aux` are frequently set to
    `0` and `NULL`, respectively.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 和 `aux` 参数允许驱动程序提供有关 `mword` 的元数据。因为驱动程序通常没有元数据提供，所以 `data` 和 `aux`
    通常设置为 `0` 和 `NULL`。'
- en: The `ifmedia_set` function sets the default ![](httpatomoreillycomsourcenostarchimages1137515.png)
    media type for ![](httpatomoreillycomsourcenostarchimages1137513.png) `ifm`. This
    function is used only during device initialization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifmedia_set` 函数设置 `ifm` 的默认媒体类型。此函数仅在设备初始化期间使用。'
- en: The `ifmedia_removeall` function takes an ![](httpatomoreillycomsourcenostarchimages1137515.png)
    `ifmedia` structure and removes every media type from it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifmedia_removeall` 函数接受一个 `ifmedia` 结构，并从其中删除每个媒体类型。'
- en: Hello, world!
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello, world!
- en: Now that you’re familiar with the if* structures and their management routines,
    let’s go through an example. The following function, named `em_setup_interface`
    and defined in */sys/dev/e1000/if_em.c*, sets up `em(4)`’s `ifnet` and `ifmedia`
    structures. (The `em(4)` driver is for Intel’s PCI Gigabit Ethernet adapters.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 if* 结构及其管理例程，让我们通过一个例子来了解。以下名为 `em_setup_interface` 的函数，在 */sys/dev/e1000/if_em.c*
    中定义，用于设置 `em(4)` 的 `ifnet` 和 `ifmedia` 结构。（`em(4)` 驱动程序是用于英特尔 PCI 千兆以太网适配器的。）
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function can be split into three parts. The first ![](httpatomoreillycomsourcenostarchimages1137501.png)
    allocates an ![](httpatomoreillycomsourcenostarchimages1137503.png) Ethernet-specific
    `ifnet` structure and stores it in ![](httpatomoreillycomsourcenostarchimages1137499.png)
    `adapter->ifp`. Then `adapter->ifp` is defined and ![](httpatomoreillycomsourcenostarchimages1137505.png)
    activated. (Here, adapter is the name for em(4)’s softc structure.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以分为三个部分。第一部分 ![分配](http://atomoreilly.com/source/nostarch/images/1137501.png)
    分配一个 ![特定于以太网的](http://atomoreilly.com/source/nostarch/images/1137503.png) `ifnet`
    结构并将其存储在 ![适配器](http://atomoreilly.com/source/nostarch/images/1137499.png) `adapter->ifp`
    中。然后 `adapter->ifp` 被定义并 ![激活](http://atomoreilly.com/source/nostarch/images/1137505.png)
    。（在这里，适配器是 em(4) 的 softc 结构的名称。）
- en: The second part ![](httpatomoreillycomsourcenostarchimages1137507.png) outlines
    and ![](httpatomoreillycomsourcenostarchimages1137509.png) enables the interface’s
    features, such as ![](httpatomoreillycomsourcenostarchimages1137511.png) Wake-on-LAN
    (WOL). (*WOL* is an Ethernet standard that allows a computer to be turned on,
    or woken up, by a network message.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分 ![概述](http://atomoreilly.com/source/nostarch/images/1137507.png) 和 ![启用](http://atomoreilly.com/source/nostarch/images/1137509.png)
    接口的特性，例如 ![唤醒网络](http://atomoreilly.com/source/nostarch/images/1137511.png) （WOL）。（*WOL*
    是一种以太网标准，允许计算机通过网络消息开机或唤醒。）
- en: The third part ![](httpatomoreillycomsourcenostarchimages1137513.png) initializes
    an `ifmedia` structure, ![](httpatomoreillycomsourcenostarchimages1137515.png)
    adds the interface’s supported media to it, and ![](httpatomoreillycomsourcenostarchimages1137517.png)
    defines the default media type as *automatically select the best media*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分 ![初始化](http://atomoreilly.com/source/nostarch/images/1137513.png) 初始化一个
    `ifmedia` 结构，![添加](http://atomoreilly.com/source/nostarch/images/1137515.png)
    将接口支持的媒体添加到其中，并且 ![定义](http://atomoreilly.com/source/nostarch/images/1137517.png)
    将默认媒体类型设置为 *自动选择最佳媒体*。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, `em_setup_interface` is called during `em(4)`’s `device_attach` routine.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`em_setup_interface` 在 `em(4)` 的 `device_attach` 例程中被调用。
- en: mbuf Structures
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mbuf 结构
- en: An `mbuf` structure is a memory buffer for network data. Commonly, this data
    spans multiple `mbuf` structures, which are arranged into a linked list known
    as an *mbuf chain*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`mbuf` 结构是网络数据的内存缓冲区。通常，这些数据跨越多个 `mbuf` 结构，这些结构被组织成一个称为 *mbuf 链* 的链表。'
- en: '`struct mbuf` is defined in the `<sys/mbuf.h>` header as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct mbuf` 在 `<sys/mbuf.h>` 头文件中定义如下：'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Every `mbuf` structure contains a ![](httpatomoreillycomsourcenostarchimages1137501.png)
    buffer for data and a ![](httpatomoreillycomsourcenostarchimages1137499.png) header,
    which looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `mbuf` 结构包含一个 ![数据](http://atomoreilly.com/source/nostarch/images/1137501.png)
    缓冲区和 ![头部](http://atomoreilly.com/source/nostarch/images/1137499.png) ，其外观如下：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll walk through an example that uses mbufs in [Chapter 17](ch17.html "Chapter 17. Network
    Drivers, Part 2: Packet Reception and Transmission"). For more on mbufs, see the
    `mbuf(9)` manual page.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 17 章](ch17.html "第 17 章。网络驱动程序，第二部分：数据包接收和传输") 中通过一个使用 mbuf 的例子来讲解。有关
    mbuf 的更多信息，请参阅 `mbuf(9)` 手册页。
- en: Message Signaled Interrupts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息信号中断
- en: Message Signaled Interrupts (MSI) and Extended Message Signaled Interrupts (MSI-X)
    are alternative ways to send interrupts. Traditionally, devices include an interrupt
    pin that they assert in order to generate an interrupt, but MSI- and MSI-X-enabled
    devices send some data, known as an *MSI message* or *MSI-X message*, to a particular
    memory address in order to generate an interrupt. MSI- and MSI-X-enabled devices
    can define multiple unique messages. Subsequently, drivers can define multiple
    unique interrupt handlers. In other words, MSI- and MSI-X-enabled devices can
    issue different interrupts, with each interrupt specifying a different condition
    or task. MSI- and MSI-X-enabled devices can define up to 32 and 2,048 unique messages,
    respectively. (MSI and MSI-X are not exclusive to network devices. They are, however,
    exclusive to PCI and PCIe devices.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 消息信号中断（MSI）和扩展消息信号中断（MSI-X）是发送中断的替代方法。传统上，设备包含一个中断引脚，它们通过断言该引脚来生成中断，但MSI和MSI-X启用设备会将一些数据（称为*MSI消息*或*MSI-X消息*）发送到特定的内存地址以生成中断。MSI和MSI-X启用设备可以定义多个唯一消息。随后，驱动程序可以定义多个唯一的中断处理程序。换句话说，MSI和MSI-X启用设备可以发出不同的中断，每个中断指定不同的条件或任务。MSI和MSI-X启用设备可以分别定义多达32和2,048个唯一消息。（MSI和MSI-X不仅限于网络设备。然而，它们仅限于PCI和PCIe设备。）
- en: Implementing MSI
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现MSI
- en: Unlike with previous topics, I’m going to take a holistic approach here. Namely,
    I’m going to show an example first, and then I’ll describe the MSI family of functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的话题不同，这里我将采取一种整体的方法。具体来说，我将首先展示一个示例，然后描述MSI函数族。
- en: The following function, named `ciss_setup_msix` and defined in */sys/dev/ciss/ciss.c*,
    sets up MSI for the `ciss(4)` driver.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数名为`ciss_setup_msix`，定义在`/sys/dev/ciss/ciss.c`中，用于为`ciss(4)`驱动程序设置MSI。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This function was chosen solely because it’s simple. The fact that it’s from
    `ciss(4)` is irrelevant.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数之所以被选择，仅仅是因为它很简单。它来自`ciss(4)`的事实并不重要。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is composed of four parts. The first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    ensures that the device actually supports MSI.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数由四个部分组成。第一部分![httpatomoreillycomsourcenostarchimages1137499.png](httpatomoreillycomsourcenostarchimages1137499.png)确保设备实际上支持MSI。
- en: The second part determines the number of unique ![](httpatomoreillycomsourcenostarchimages1137501.png)
    MSI-X or ![](httpatomoreillycomsourcenostarchimages1137503.png) MSI messages the
    device maintains, and stores the answer in `count`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分确定设备维护的唯一MSI-X或MSI消息的数量，并将答案存储在`count`中。
- en: The third part allocates `count` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    *MSI-X* or ![](httpatomoreillycomsourcenostarchimages1137507.png) *MSI vectors*,
    which connect each message to a `SYS_RES_IRQ` resource with a rid of 1 through
    count. Thus, in order to assign an interrupt handler to the eighth message, you’d
    call `bus_alloc_resource_any` (to allocate a `SYS_RES_IRQ` resource) and pass
    8 as the `rid` argument. Then you’d call `bus_setup_intr` as usual.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分分配`count`![httpatomoreillycomsourcenostarchimages1137505.png](httpatomoreillycomsourcenostarchimages1137505.png)
    *MSI-X* 或 ![httpatomoreillycomsourcenostarchimages1137507.png](httpatomoreillycomsourcenostarchimages1137507.png)
    *MSI向量*，这些向量将每个消息连接到一个具有1到`count`的`rid`的`SYS_RES_IRQ`资源。因此，为了将中断处理程序分配给第八个消息，你需要调用`bus_alloc_resource_any`（以分配一个`SYS_RES_IRQ`资源）并将8作为`rid`参数传递。然后你通常会调用`bus_setup_intr`。
- en: Lastly, the fourth part ![](httpatomoreillycomsourcenostarchimages1137509.png)
    saves the `rid` of each MSI-X or MSI message in the `ciss_irq_rid` array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第四部分![httpatomoreillycomsourcenostarchimages1137509.png](httpatomoreillycomsourcenostarchimages1137509.png)将每个MSI-X或MSI消息的`rid`存储在`ciss_irq_rid`数组中。
- en: 'Naturally, this function is called during `ciss(4)`’s `device_attach` routine,
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个函数在`ciss(4)`的`device_attach`例程中被调用，如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how MSI is ![](httpatomoreillycomsourcenostarchimages1137499.png) ![](httpatomoreillycomsourcenostarchimages1137501.png)
    set up before ![](httpatomoreillycomsourcenostarchimages1137503.png) acquiring
    an IRQ. Additionally, notice how the ![](httpatomoreillycomsourcenostarchimages1137505.png)
    `rid` argument is `ciss_irq_rid`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意MSI是在![httpatomoreillycomsourcenostarchimages1137499.png](httpatomoreillycomsourcenostarchimages1137499.png)![httpatomoreillycomsourcenostarchimages1137501.png](httpatomoreillycomsourcenostarchimages1137501.png)获取中断之前![httpatomoreillycomsourcenostarchimages1137503.png](httpatomoreillycomsourcenostarchimages1137503.png)设置的。此外，注意`rid`参数是`ciss_irq_rid`。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of this writing, `ciss(4)` supports only the first MSI-X or MSI message.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`ciss(4)`只支持第一个MSI-X或MSI消息。
- en: MSI Management Routines
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MSI管理例程
- en: 'The FreeBSD kernel provides the following functions for working with MSI:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD内核提供了以下函数用于处理MSI：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `pci_msix_count` and `pci_msi_count` functions return the number of unique
    MSI-X or MSI messages maintained by the device `dev`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_msix_count` 和 `pci_msi_count` 函数返回设备 `dev` 维护的唯一 MSI-X 或 MSI 消息的数量。'
- en: The `pci_alloc_msix` and `pci_alloc_msi` functions allocate `count` MSI-X or
    MSI vectors based on `dev`. If there are not enough free vectors, fewer than `count`
    vectors will be allocated. Upon a successful return, count will contain the number
    of vectors allocated. (MSI-X and MSI vectors were described in [Implementing MSI](ch16s08.html
    "Implementing MSI") in [Message Signaled Interrupts](ch16s07.html "Message Signaled
    Interrupts").)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_alloc_msix` 和 `pci_alloc_msi` 函数根据 `dev` 分配 `count` 个 MSI-X 或 MSI 向量。如果可用向量不足，则分配的向量数将少于
    `count`。成功返回后，`count` 将包含分配的向量数。（MSI-X 和 MSI 向量在 [实现 MSI](ch16s08.html "实现 MSI")
    中进行了描述，见 [消息信号中断](ch16s07.html "消息信号中断")。）'
- en: The `pci_release_msi` function releases the MSI-X or MSI vectors that were allocated
    by `pci_alloc_msix` or `pci_alloc_msi`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_release_msi` 函数释放由 `pci_alloc_msix` 或 `pci_alloc_msi` 分配的 MSI-X 或 MSI
    向量。'
- en: Conclusion
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter examined `ifnet`, `ifmedia`, and `mbuf` structures, as well as
    MSI and MSI-X. In [Chapter 17](ch17.html "Chapter 17. Network Drivers, Part 2:
    Packet Reception and Transmission"), you’ll use this information to analyze a
    network driver.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 `ifnet`、`ifmedia` 和 `mbuf` 结构，以及 MSI 和 MSI-X。在 [第 17 章](ch17.html "第 17
    章。网络驱动程序，第二部分：数据包接收和传输") 中，你将使用这些信息来分析一个网络驱动程序。
