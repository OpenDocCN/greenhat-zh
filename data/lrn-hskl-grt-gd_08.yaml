- en: Chapter 8. Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。输入和输出
- en: In this chapter, you’re going to learn how to receive input from the keyboard
    and print stuff to the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何从键盘接收输入并将内容打印到屏幕上。
- en: 'But first, we’ll cover the basics of input and output (I/O):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们将介绍输入和输出（I/O）的基础知识：
- en: What are I/O actions?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是I/O操作？
- en: How do I/O actions enable us to do I/O?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O操作是如何使我们能够进行I/O的？
- en: When are I/O actions actually performed?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O操作实际上何时执行？
- en: Dealing with I/O brings up the issue of constraints on how Haskell functions
    can work, so we’ll look at how we get around that first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 处理I/O引发了对Haskell函数工作方式的约束问题，所以我们将看看我们如何绕过这个问题。
- en: Separating the Pure from the Impure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将纯与杂分离
- en: By now, you’re used to the fact that Haskell is a purely functional language.
    Instead of giving the computer a series of steps to execute, you give it definitions
    of what certain things are. In addition, a function isn’t allowed to have *side
    effects*. A function can give us back only some result based on the parameters
    we supplied to it. If a function is called two times with the same parameters,
    it must return the same result.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经习惯了Haskell是一种纯函数式语言的事实。你不会给计算机一系列要执行的步骤，而是给它某些事物是什么的定义。此外，函数不允许有*副作用*。函数只能根据我们提供给它的参数返回一些结果。如果一个函数用相同的参数调用两次，它必须返回相同的结果。
- en: While this may seem a bit limiting at first, it’s actually really cool. In an
    imperative language, you have no guarantee that a simple function that should
    just crunch some numbers won’t burn down your house or kidnap your dog while crunching
    those numbers. For instance, when we were making a binary search tree in the previous
    chapter, we didn’t insert an element into a tree by modifying the tree itself;
    instead, our function actually returned a *new* tree with the new element inserted
    into that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始这可能看起来有点限制，但实际上真的很酷。在命令式语言中，你无法保证一个简单的函数在处理数字时不会烧毁你的房子或绑架你的狗。例如，在前一章我们制作二叉搜索树时，我们并没有通过修改树本身来插入一个元素；相反，我们的函数实际上返回了一个*新*的树，新元素被插入其中。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802614.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802614.png.jpg)'
- en: 'The fact that functions cannot change state—like updating global variables,
    for example—is good, because it helps us reason about our programs. However, there’s
    one problem with this: If a function can’t change anything in the world, how is
    it supposed to tell us what it calculated? To do that, it must change the state
    of an output device (usually the state of the screen), which then emits photons
    that travel to our brain, which changes the state of our mind, man.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数无法改变状态——例如更新全局变量——的事实是好的，因为它有助于我们推理程序。然而，这里有一个问题：如果一个函数不能改变世界中的任何东西，它如何告诉我们它计算了什么？为了做到这一点，它必须改变输出设备（通常是屏幕）的状态，然后发射光子到我们的大脑，这改变了我们的心态，伙计。
- en: But don’t despair, all is not lost. Haskell has a really clever system for dealing
    with functions that have side effects. It neatly separates the part of our program
    that is pure and the part of our program that is impure, which does all the dirty
    work like talking to the keyboard and the screen. With those two parts separated,
    we can still reason about our pure program and take advantage of all the things
    that purity offers—like laziness, robustness, and composability—while easily communicating
    with the outside world. You’ll see this at work in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但别灰心，并非一切都已失去。Haskell有一个非常巧妙的系统来处理具有副作用的功能。它巧妙地将我们程序的纯部分和杂部分分开，后者执行所有脏活，比如与键盘和屏幕交互。通过将这两部分分开，我们仍然可以推理我们的纯程序，并利用纯性提供的一切——比如惰性、健壮性和可组合性——同时轻松地与外界沟通。你将在本章中看到这一点是如何发挥作用的。
- en: Hello, World!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello, World!
- en: Until now, we’ve always loaded our functions into GHCi to test them. We’ve also
    explored the standard library functions in that way. Now we’re finally going to
    write our first real Haskell program! Yay! And sure enough, we’re going to do
    the good old Hello, world! schtick.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是将函数加载到GHCi中以测试它们。我们也以这种方式探索了标准库函数。现在我们终于要编写我们的第一个真正的Haskell程序了！太好了！而且确实如此，我们将做那个古老的Hello,
    world!游戏。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802616.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802616.png.jpg)'
- en: 'For starters, punch the following into your favorite text editor:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容输入你喜欢的文本编辑器：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We just defined `main`, and in it we call a function called `putStrLn` with
    the parameter `"hello, world"`. Save that file as *helloworld.hs*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了`main`，并在其中调用了一个名为`putStrLn`的函数，参数为`"hello, world"`。将文件保存为`*helloworld.hs*`。
- en: 'We’re going to do something we’ve never done before: compile our program, so
    that we get an executable file that we can run! Open your terminal, navigate to
    the directory where *helloworld.hs* is located, and enter the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做一些以前从未做过的事情：编译我们的程序，这样我们就可以得到一个可执行的文件，我们可以运行它！打开你的终端，导航到`*helloworld.hs*`所在的目录，并输入以下内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This invokes the GHC compiler and tells it to compile our program. It should
    report something like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用GHC编译器并告诉它编译我们的程序。它应该报告如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now you can run your program by entering the following at the terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在终端输入以下内容来运行你的程序：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using Windows, instead of doing `./helloworld`, just type in **`helloworld.exe`**
    to run your program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，运行程序时不需要输入`./helloworld`，只需输入**`helloworld.exe`**即可。
- en: 'Our program prints out the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序打印出以下内容：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And there you go—our first compiled program that prints something to the terminal.
    How extraordinarily boring!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是这样——我们的第一个编译程序，它在终端上打印了一些内容。多么无聊啊！
- en: 'Let’s examine what we wrote. First, let’s look at the type of the function
    `putStrLn`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们写了什么。首先，让我们看看函数`putStrLn`的类型：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can read the type of `putStrLn` like this: `putStrLn` takes a string and
    returns an *I/O action* that has a result type of `()` (that is, the empty tuple,
    also known as *unit*).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样读取`putStrLn`的类型：`putStrLn`接受一个字符串并返回一个*I/O操作*，其结果类型为`()`（即空元组，也称为*单元*）。
- en: An I/O action is something that, when performed, will carry out an action with
    a side effect (such as reading input or printing stuff to the screen or a file)
    and will also present some result. We say that an I/O action *yields* this result.
    Printing a string to the terminal doesn’t really have any kind of meaningful return
    value, so a dummy value of `()` is used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个I/O操作是指执行时会产生副作用（如读取输入或打印屏幕或文件中的内容）的操作，并且还会呈现一些结果。我们说I/O操作*产生*这个结果。将字符串打印到终端实际上并没有任何有意义的返回值，所以使用了一个虚拟值`()`。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The empty tuple is the value (), and it also has a type of ().
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 空元组是值()`，它也有一个类型()。
- en: So when will an I/O action be performed? Well, this is where `main` comes in.
    An I/O action will be performed when we give it a name of `main` and then run
    our program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么I/O操作何时会被执行呢？嗯，这就是`main`发挥作用的地方。当我们将名称指定为`main`并运行我们的程序时，I/O操作将被执行。
- en: Gluing I/O Actions Together
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将I/O操作粘合在一起
- en: 'Having your whole program be just one I/O action seems kind of limiting. That’s
    why we can use `do` syntax to glue together several I/O actions into one. Take
    a look at the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序只包含一个I/O操作似乎有点限制。这就是为什么我们可以使用`do`语法将多个I/O操作粘合在一起。看看下面的例子：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ah, interesting—new syntax! And this reads pretty much like an imperative program.
    If you compile and run it, it will behave just as you expect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，有趣——新的语法！这几乎就像一个命令式程序。如果你编译并运行它，它将表现得正如你所期望的那样。
- en: 'Notice that we said `do` and then we laid out a series of steps, as we would
    in an imperative program. Each of these steps is an I/O action. By putting them
    together with `do` syntax, we glued them into one I/O action. The action that
    we got has a type of `IO ()`, as that’s the type of the last I/O action inside.
    Because of that, `main` always has a type signature of `main :: IO` *`something`*,
    where *`something`* is some concrete type. We don’t usually specify a type declaration
    for `main`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们说了`do`，然后我们列出了一系列步骤，就像在一个命令式程序中做的那样。这些步骤中的每一个都是一个I/O操作。通过使用`do`语法将它们组合在一起，我们将它们粘合成了一个I/O操作。我们得到的行为类型为`IO
    ()`，因为这是内部最后一个I/O操作的类型。正因为如此，`main`总是有一个类型签名`main :: IO something`，其中*`something`*是某个具体的类型。我们通常不会为`main`指定类型声明。'
- en: How about that third line, which states `name <- getLine`? It looks like it
    reads a line from the input and stores it into a variable called `name`. Does
    it really? Well, let’s examine the type of `getLine`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 那第三行，声明`name <- getLine`，看起来它从输入读取一行并将其存储到名为`name`的变量中。它真的这样做吗？好吧，让我们检查`getLine`的类型。
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802618.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802618.png.jpg)'
- en: We see that `getLine` is an I/O action that yields a `String`. That makes sense,
    because it will wait for the user to input something at the terminal, and then
    that something will be represented as a string.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`getLine`是一个I/O操作，它产生一个`String`。这很有道理，因为它会等待用户在终端输入某些内容，然后这些内容将以字符串的形式表示。
- en: 'So what’s up with `name <- getLine` then? You can read that piece of code like
    this: perform the I/O action `getLine`, and then bind its result value to `name`.
    `getLine` has a type of `IO String`, so `name` will have a type of `String`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`name <- getLine`是怎么回事呢？你可以这样阅读这段代码：执行不纯操作`getLine`，然后将它的结果值绑定到`name`上。`getLine`的类型是`IO
    String`，所以`name`的类型将是`String`。
- en: You can think of an I/O action as a box with little feet that will go out into
    the real world and do something there (like write some graffiti on a wall) and
    maybe bring back some data. Once it has fetched that data for you, the only way
    to open the box and get the data inside it is to use the `<-` construct. And if
    we’re taking data out of an I/O action, we can take it out only when we’re inside
    another I/O action. This is how Haskell manages to neatly separate the pure and
    impure parts of our code. `getLine` is impure, because its result value is not
    guaranteed to be the same when performed twice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把不纯操作想象成一个有脚的盒子，它会走出现实世界并做些事情（比如在墙上涂鸦）并可能带回一些数据。一旦它为你获取了这些数据，唯一打开盒子并获取其中数据的方法就是使用`<-`构造。如果我们从不纯操作中取出数据，我们只能在另一个不纯操作中进行。这就是Haskell如何整洁地分离我们代码的纯和不纯部分。`getLine`是不纯的，因为它的结果值在两次执行时可能不会相同。
- en: 'When we do `name <- getLine`, `name` is just a normal string, because it represents
    what’s inside the box. For example, we can have a really complicated function
    that takes your name (a normal string) as a parameter and tells you your fortune
    based on your name, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们做`name <- getLine`时，`name`只是一个普通字符串，因为它代表盒子里的内容。例如，我们可以有一个非常复杂的函数，它以你的名字（一个普通字符串）作为参数，并根据你的名字告诉你你的命运，就像这样：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `tellFortune` function (or any of the functions it passes `name` to) does
    not need to know anything about I/O—it’s just a normal `String -> String` function!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`tellFortune`函数（或者它传递`name`给的其他任何函数）不需要了解任何关于I/O的事情——它只是一个普通的`String -> String`函数！'
- en: To see how normal values differ from I/O actions, consider the following line.
    Is it valid?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解正常值和不纯操作的不同，考虑以下行。这是否有效？
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you said no, go eat a cookie. If you said yes, drink a bowl of molten lava.
    (Just kidding—don’t!) This doesn’t work because `++` requires both its parameters
    to be lists over the same type. The left parameter has a type of `String` (or
    `[Char]`, if you will), while `getLine` has a type of `IO String`. Remember that
    you can’t concatenate a string and an I/O action. First, you need to get the result
    out of the I/O action to get a value of type `String`, and the only way to do
    that is to do something like `name <- getLine` inside some other I/O action.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说了不，就去吃一块饼干。如果你说了是，就喝一碗熔岩。 (只是开玩笑——别这么做！) 这行不通，因为`++`需要它的两个参数都是同一类型的列表。左边的参数类型是`String`（或者如果你愿意，是`[Char]`），而`getLine`的类型是`IO
    String`。记住，你不能将字符串和不纯操作连接起来。首先，你需要从不纯操作中获取结果以获得`String`类型的值，而唯一的方法是在另一个不纯操作中做类似`name
    <- getLine`的事情。
- en: If we want to deal with impure data, we must do it in an impure environment.
    The taint of impurity spreads around much like the undead scourge, and it’s in
    our best interest to keep the I/O parts of our code as small as possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理不纯数据，我们必须在不纯的环境中处理。不纯的污点就像不死生物的瘟疫一样四处蔓延，因此我们最好将代码中的I/O部分保持尽可能小。
- en: 'Every I/O action that is performed yields a result. That’s why our previous
    example could also have been written like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个执行的不纯操作都会产生一个结果。这就是为什么我们之前的例子也可以写成这样：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However, `foo` would just have a value of `()`, so doing that would be kind
    of moot. Notice that we didn’t bind the last `putStrLn` to anything. That’s because
    in a `do` block, the last action cannot be bound to a name as the first two were.
    You’ll see exactly why that is so when we venture off into the world of monads,
    starting in [Chapter 13](ch13.html "Chapter 13. A Fistful of Monads"). For now,
    the important point is that the `do` block automatically extracts the value from
    the last action and yields that as its own result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`foo`将只有一个`()`值，所以这样做可能有点多余。注意我们没有将最后的`putStrLn`绑定到任何东西上。这是因为在一个`do`块中，最后一个操作不能像前两个那样绑定到名字上。当我们进入第13章（[Chapter 13](ch13.html
    "Chapter 13. A Fistful of Monads")）的monads世界时，你会看到为什么是这样的。现在，重要的是`do`块会自动从最后一个操作中提取值，并将其作为自己的结果。
- en: Except for the last line, every line in a `do` block that doesn’t bind can also
    be written with a bind. So `putStrLn "BLAH"` can be written as `_ <- putStrLn
    "BLAH"`. But that’s useless, so we leave out the `<-` for I/O actions that don’t
    yield an important result, like `putStrLn`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后一行外，`do`块中不绑定的每一行也可以用绑定来写。所以`putStrLn "BLAH"`可以写成`_ <- putStrLn "BLAH"`。但这没有用，所以我们省略了`<-`，对于像`putStrLn`这样的不产生重要结果的I/O操作。
- en: What do you think will happen when we do something like the following?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为当我们做类似以下操作时会发生什么？
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Do you think it will read from the input and then bind the value of that to
    `name`? Well, it won’t. All this does is give the `getLine` I/O action a different
    name called `myLine`. Remember that to get the value out of an I/O action, you
    must perform it inside another I/O action by binding it to a name with `<-`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为它会从输入中读取，并将那个值绑定到`name`上吗？不，它不会。这仅仅是将`getLine` I/O操作赋予了一个不同的名字，叫做`myLine`。记住，要从I/O操作中获取值，你必须通过使用`<-`将其绑定到名字来在另一个I/O操作中执行它。
- en: I/O actions will be performed when they are given a name of `main` or when they’re
    inside a bigger I/O action that we composed with a `do` block. We can also use
    a `do` block to glue together a few I/O actions, and then we can use that I/O
    action in another `do` block, and so on. They will be performed if they eventually
    fall into `main`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当I/O操作被赋予`main`这个名字，或者当它们在一个更大的I/O操作内部，这个I/O操作是通过`do`块组合的，I/O操作将会执行。我们也可以使用`do`块将几个I/O操作粘合在一起，然后我们可以将这个I/O操作用在另一个`do`块中，依此类推。如果它们最终落入`main`中，它们将会执行。
- en: 'There’s also one more case when I/O actions will be performed: when we type
    out an I/O action in GHCi and press enter.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在GHCi中输入一个I/O操作并按回车键时，也会执行I/O操作：当我们将I/O操作在GHCi中输入并按回车键时，也会执行I/O操作。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even when we just punch in a number or call a function in GHCi and press enter,
    GHCi will apply `show` to the resulting value, and then it will print it to the
    terminal by using `putStrLn`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在GHCi中输入一个数字或调用一个函数并按回车键，GHCi也会将`show`应用到结果值上，然后它会使用`putStrLn`将其打印到终端。
- en: Using let Inside I/O Actions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在I/O操作中使用`let`
- en: When using `do` syntax to glue together I/O actions, we can use `let` syntax
    to bind pure values to names. Whereas `<-` is used to perform I/O actions and
    bind their results to names, `let` is used when we just want to give names to
    normal values inside I/O actions. It’s similar to the `let` syntax in list comprehensions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`do`语法将I/O操作粘合在一起时，我们可以使用`let`语法将纯值绑定到名字上。与`<-`用于执行I/O操作并将结果绑定到名字不同，`let`用于我们只想在I/O操作内部给正常值命名时。它与列表推导式中的`let`语法类似。
- en: Let’s take a look at an I/O action that uses both `<-` and `let` to bind names.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用`<-`和`let`绑定名字的I/O操作的例子。
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See how the I/O actions in the `do` block are lined up? Also notice how the
    `let` is lined up with the I/O actions, and the names of the `let` are lined up
    with each other? That’s good practice, because indentation is important in Haskell.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`do`块中的I/O操作是如何对齐的？也请注意`let`是如何与I/O操作对齐的，以及`let`的名字是如何彼此对齐的？这是良好的实践，因为在Haskell中缩进很重要。
- en: We wrote `map toUpper firstName`, which turns something like `"John"` into a
    much cooler string like `"JOHN"`. We bound that uppercased string to a name and
    then used it in a string that we printed to the terminal.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了`map toUpper firstName`，它将像`"John"`这样的字符串转换成更酷的字符串`"JOHN"`。我们将这个大写后的字符串绑定到一个名字上，然后将其用于打印到终端的字符串中。
- en: You may be wondering when to use `<-` and when to use `let` bindings. `<-` is
    for performing I/O actions and binding their results to names. `map toUpper firstName`,
    however, isn’t an I/O action—it’s a pure expression in Haskell. So you can use
    `<-` when you want to bind the results of I/O actions to names, and you can use
    `let` bindings to bind pure expressions to names. Had we done something like `let
    firstName = getLine`, we would have just called the `getLine` I/O action a different
    name, and we would still need to run it through a `<-` to perform it and bind
    its result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道何时使用`<-'和何时使用`let`绑定。`<-'用于执行I/O操作并将它们的结果绑定到名称。然而，`map toUpper firstName`不是一个I/O操作——它是一个Haskell中的纯表达式。所以当你想要将I/O操作的结果绑定到名称时，你可以使用`<-'，而你可以使用`let`绑定将纯表达式绑定到名称。如果我们做了像`let
    firstName = getLine`这样的操作，我们只是将`getLine` I/O操作命名为不同的名称，我们仍然需要通过`<-'来执行它并绑定其结果。
- en: Putting It in Reverse
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向操作
- en: 'To get a better feel for doing I/O in Haskell, let’s make a simple program
    that continuously reads a line and prints out the same line with the words reversed.
    The program’s execution will stop when we input a blank line. This is the program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解在Haskell中进行I/O，让我们编写一个简单的程序，该程序持续读取一行并打印出相同行中单词的逆序。当输入一个空行时，程序将停止执行。这是该程序：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To get a feel for what it does, save it as *reverse.hs*, and then compile and
    run it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它做什么，将其保存为`reverse.hs`，然后编译并运行它：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `reverseWords` function is just a normal function. It takes a string like
    `"hey there man"` and applies `words` to it to produce a list of words like `["hey","there","man"]`.
    We map `reverse` over the list, getting `["yeh","ereht","nam"]`, and then we put
    that back into one string by using `unwords`. The final result is `"yeh ereht
    nam"`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`reverseWords`函数只是一个普通函数。它接受一个如`"hey there man"`这样的字符串，并对其应用`words`以产生一个如`["hey","there","man"]`的单词列表。我们在这个列表上映射`reverse`，得到`["yeh","ereht","nam"]`，然后我们使用`unwords`将其放回一个字符串中。最终结果是`"yeh
    ereht nam"`。
- en: What about `main`? First, we get a line from the terminal by performing `getLine`
    and call that line `line`. Next we have a conditional expression. Remember that
    in Haskell, every `if` must have a corresponding `else`, because every expression
    must have some sort of value. Our `if` says that when a condition is true (in
    our case, the line that we entered is blank), we perform one I/O action; when
    it isn’t true, the I/O action under the `else` is performed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`main`呢？首先，我们通过执行`getLine`从终端获取一行，并将其称为`line`。接下来，我们有一个条件表达式。记住，在Haskell中，每个`if`都必须有一个对应的`else`，因为每个表达式都必须有某种类型的值。我们的`if`表示当条件为真（在我们的情况下，我们输入的行是空的）时，我们执行一个I/O操作；当它不为真时，执行`else`下的I/O操作。
- en: 'Because we need to have exactly one I/O action after the `else`, we use a `do`
    block to glue together two I/O actions into one. We could also write that part
    as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要在`else`之后恰好有一个I/O操作，所以我们使用`do`块将两个I/O操作粘合在一起成为一个。我们也可以将这部分写成如下形式：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes it clearer that the `do` block can be viewed as one I/O action, but
    it’s uglier.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`do`块可以被视为一个I/O操作，但看起来更丑陋。
- en: Inside the `do` block, we apply `reverseWords` to the line that we got from
    `getLine` and then print that to the terminal. After that, we just perform `main`.
    It’s performed recursively, and that’s okay, because `main` is itself an I/O action.
    So in a sense, we go back to the start of the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`do`块内部，我们将`reverseWords`应用于从`getLine`获取的行，然后将其打印到终端。之后，我们只是执行`main`。它是递归执行的，这是可以的，因为`main`本身就是一个I/O操作。所以从某种意义上说，我们又回到了程序的开始。
- en: 'If `null line` is `True`, the code after the `then` is executed: `return ()`.
    You might have used a `return` keyword in other languages to return from a subroutine
    or function. But `return` in Haskell is nothing like the `return` in most other
    languages.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`null line`是`True`，则执行`then`之后的代码：`return ()`。你可能在其他语言中使用`return`关键字从子程序或函数返回。但在Haskell中，`return`与大多数其他语言中的`return`完全不同。
- en: In Haskell (and in I/O actions specifically), `return` makes an I/O action out
    of a pure value. Returning to the box analogy for I/O actions, `return` takes
    a value and wraps it up in a box. The resulting I/O action doesn’t actually do
    anything; it just yields that value as its result. So in an I/O context, `return
    "haha"` will have a type of `IO String`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell（特别是在I/O操作中），`return`将一个纯值转换为一个I/O操作。回到I/O操作的盒子类比，`return`取一个值并将其包裹在一个盒子中。结果I/O操作实际上并不做任何事情；它只是作为其结果提供那个值。所以在一个I/O上下文中，`return
    "haha"`的类型将是`IO String`。
- en: What’s the point of just transforming a pure value into an I/O action that doesn’t
    do anything? Well, we needed some I/O action to carry out in the case of an empty
    input line. That’s why we made a bogus I/O action that doesn’t do anything by
    writing `return ()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将纯值转换成不执行任何操作的 I/O 操作有什么意义呢？嗯，在空输入行的情况下，我们需要执行一些 I/O 操作。这就是为什么我们通过编写 `return
    ()` 创建了一个不执行任何操作的虚假 I/O 操作。
- en: 'Unlike in other languages, using `return` doesn’t cause the I/O `do` block
    to end in execution. For instance, this program will quite happily continue all
    the way to the last line:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，使用 `return` 不会导致 I/O `do` 块在执行中结束。例如，这个程序会一直运行到最后一行：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, all these uses of `return` do is make I/O actions that yield a result,
    which is then thrown away because it isn’t bound to a name.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有这些 `return` 的用途只是创建产生结果的 I/O 操作，然后因为它们没有被绑定到名字上而被丢弃。
- en: 'We can use `return` in combination with `<-` to bind stuff to names:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `return` 与 `<-` 结合来将东西绑定到名字上：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So you see, `return` is sort of the opposite of `<-`. While `return` takes
    a value and wraps it up in a box, `<-` takes a box (and performs it) and takes
    the value out of it, binding it to a name. But doing this is kind of redundant,
    especially since you can use `let` in `do` blocks to bind to names, like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你看，`return` 有点像是 `<-` 的对立面。虽然 `return` 取一个值并将其包裹在一个盒子里，但 `<-` 取一个盒子（并执行它）然后从中取出值，并将其绑定到一个名字上。但这样做有点多余，特别是既然你可以在
    `do` 块中使用 `let` 来绑定到名字，就像这样：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When dealing with I/O `do` blocks, we mostly use `return` either because we
    need to create an I/O action that doesn’t do anything or because we don’t want
    the I/O action that’s made up from a `do` block to have the result value of its
    last action. When we want it to have a different result value, we use `return`
    to make an I/O action that always yields our desired result, and we put it at
    the end.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 I/O `do` 块时，我们通常使用 `return` 要么是因为我们需要创建一个不执行任何操作的 I/O 操作，要么是因为我们不希望由 `do`
    块组成的 I/O 操作具有其最后操作的返回值。当我们希望它具有不同的返回值时，我们使用 `return` 来创建一个总是产生我们期望的结果的 I/O 操作，并将其放在末尾。
- en: Some Useful I/O Functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的 I/O 函数
- en: Haskell comes with a bunch of useful functions and I/O actions. Let’s take a
    look at some of them to see how they’re used.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 提供了许多有用的函数和 I/O 操作。让我们看看其中的一些，看看它们是如何使用的。
- en: putStr
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: putStr
- en: '`putStr` is much like `putStrLn`, in that it takes a string as a parameter
    and returns an I/O action that will print that string to the terminal. However,
    `putStr` doesn’t jump into a new line after printing out the string, whereas `putStrLn`
    does. For example, look at this code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`putStr` 与 `putStrLn` 很相似，因为它接受一个字符串作为参数，并返回一个将字符串打印到终端的 I/O 操作。然而，`putStr`
    在打印字符串后不会跳到新的一行，而 `putStrLn` 会。例如，看看这段代码：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we compile and run this, we get the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行这个程序，我们会得到以下输出：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: putChar
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: putChar
- en: 'The `putChar` function takes a character and returns an I/O action that will
    print it to the terminal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`putChar` 函数接受一个字符，并返回一个将字符打印到终端的 I/O 操作：'
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`putStr` can be defined recursively with the help of `putChar`. The base case
    of `putStr` is the empty string, so if we’re printing an empty string, we just
    return an I/O action that does nothing by using `return ()`. If it’s not empty,
    then we print the first character of the string by doing `putChar` and then print
    the rest of them recursively:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`putStr` 可以通过 `putChar` 的帮助递归定义。`putStr` 的基本情况是空字符串，所以如果我们正在打印一个空字符串，我们只需使用
    `return ()` 返回一个不执行任何操作的 I/O 操作。如果不是空的，那么我们通过 `putChar` 打印字符串的第一个字符，然后递归地打印其余部分：'
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how we can use recursion in I/O, just as we can use it in pure code.
    We define the base case and then think what the result actually is. In this case,
    it’s an action that first outputs the first character and then outputs the rest
    of the string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在 I/O 中使用递归，就像我们可以在纯代码中使用它一样。我们定义基本情况，然后思考实际的结果是什么。在这种情况下，它是一个首先输出第一个字符然后输出字符串其余部分的操作。
- en: print
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: print
- en: '`print` takes a value of any type that’s an instance of `Show` (meaning that
    we know how to represent it as a string), applies `show` to that value to “stringify”
    it, and then outputs that string to the terminal. Basically, it’s just `putStrLn
    . show`. It first runs `show` on a value, and then feeds that to `putStrLn`, which
    returns an I/O action that will print out our value.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 接受任何类型的值，只要它是 `Show` 的实例（这意味着我们知道如何将其表示为字符串），将 `show` 应用到该值以“字符串化”它，然后将该字符串输出到终端。基本上，它只是
    `putStrLn . show`。它首先对值运行 `show`，然后将结果传递给 `putStrLn`，它返回一个将我们的值打印到终端的 I/O 操作。'
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compiling this and running it, we get the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此代码，我们得到以下输出：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, it’s a very handy function. Remember how we talked about how
    I/O actions are performed only when they fall into `main` or when we try to evaluate
    them at the GHCi prompt? When we type out a value (like `3` or `[1,2,3]`) and
    press enter, GHCi actually uses `print` on that value to display it on the terminal!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常实用的函数。记得我们之前讨论过 I/O 操作只有在它们落入 `main` 或我们在 GHCi 提示符中尝试评估它们时才会执行吗？当我们输入一个值（如
    `3` 或 `[1,2,3]`）并按回车键时，GHCi 实际上会对该值使用 `print` 来在终端上显示它！
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When we want to print out strings, we usually use `putStrLn` because we don’t
    want the quotes around them. However, for printing out values of other types to
    the terminal, `print` is used the most often.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要打印字符串时，我们通常使用 `putStrLn`，因为我们不希望它们周围有引号。然而，对于将其他类型的数据打印到终端，`print` 是最常用的。
- en: when
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: when
- en: The `when` function is found in `Control.Monad` (to access it, use `import Control.Monad`).
    It’s interesting because in a `do` block, it looks like a flow-control statement,
    but it’s actually a normal function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 函数位于 `Control.Monad` 中（要访问它，请使用 `import Control.Monad`）。它很有趣，因为在 `do`
    块中，它看起来像是一个流程控制语句，但实际上它是一个普通函数。'
- en: '`when` takes a `Bool` and an I/O action, and if that `Bool` value is `True`,
    it returns the same I/O action that we supplied to it. However, if it’s `False`,
    it returns the `return ()` action, which doesn’t do anything.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 函数接受一个 `Bool` 和一个 I/O 操作，如果那个 `Bool` 值是 `True`，它返回我们提供给它的相同 I/O 操作。然而，如果它是
    `False`，它返回 `return ()` 操作，这个操作不会做任何事情。'
- en: 'Here’s a small program that asks for some input and prints it back to the terminal,
    but only if that input is `SWORDFISH`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小程序，它会要求输入一些内容，并将其打印回终端，但只有当输入是 `SWORDFISH` 时：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Without `when`, we would need to write the program like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `when`，我们需要像这样编写程序：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `when` function is useful when we want to perform some I/O
    actions when a condition is met, but do nothing otherwise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`when` 函数在我们想要在满足条件时执行一些 I/O 操作，但在其他情况下不执行时非常有用。
- en: sequence
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sequence
- en: 'The `sequence` function takes a list of I/O actions and returns an I/O action
    that will perform those actions one after the other. The result that this I/O
    action yields will be a list of the results of all the I/O actions that were performed.
    For instance, we could do this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`sequence` 函数接受一个 I/O 操作的列表，并返回一个 I/O 操作，该操作将依次执行这些操作。这个 I/O 操作产生的结果将是执行的所有
    I/O 操作的结果列表。例如，我们可以这样做：'
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or we could do this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样做：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The results of both these versions are exactly the same. `sequence [getLine,
    getLine, getLine]` makes an I/O action that will perform `getLine` three times.
    If we bind that action to a name, the result is a list of all the results. So
    in this case, the result would be a list of three things that the user entered
    at the prompt.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的输出结果完全相同。`sequence [getLine, getLine, getLine]` 创建了一个 I/O 操作，该操作将执行 `getLine`
    三次。如果我们将这个操作绑定到一个名称上，结果将是一个包含所有结果的列表。所以在这种情况下，结果将是一个包含用户在提示符中输入的三个东西的列表。
- en: 'A common pattern with `sequence` is when we map functions like `print` or `putStrLn`
    over lists. Executing `map print [1,2,3,4]` won’t create an I/O action, but instead
    will create a list of I/O actions. Effectively, this is the same as writing this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sequence` 的一个常见模式是当我们将 `print` 或 `putStrLn` 等函数映射到列表上。执行 `map print [1,2,3,4]`
    不会创建一个 I/O 操作，而是会创建一个 I/O 操作的列表。实际上，这和写下面这样的代码是相同的：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we want to transform that list of I/O actions into an I/O action, we must
    sequence it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将这个 I/O 操作的列表转换成一个 I/O 操作，我们必须对其进行序列化：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: But what’s with the `[(),(),(),(),()]` at the end of the output? Well, when
    we evaluate an I/O action in GHCi, that action is performed, and then its result
    is printed out, unless that result is `()`. That’s why evaluating `putStrLn "hehe"`
    in GHCi just prints out `hehe`—`putStrLn "hehe"` yields `()`. But when we enter
    `getLine` in GHCi, the result of that I/O action is printed out, because `getLine`
    has a type of `IO String`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但输出末尾的 `[(),(),(),(),()]` 是什么意思呢？好吧，当我们评估 GHCi 中的 I/O 操作时，该操作会被执行，然后打印出其结果，除非该结果是
    `()`。这就是为什么在 GHCi 中评估 `putStrLn "hehe"` 只会打印出 `hehe`——`putStrLn "hehe"` 产生 `()`。但是当我们输入
    `getLine` 到 GHCi 中时，那个 I/O 操作的结果会被打印出来，因为 `getLine` 的类型是 `IO String`。
- en: mapM
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mapM
- en: 'Because mapping a function that returns an I/O action over a list and then
    sequencing it is so common, the utility functions `mapM` and `mapM_` were introduced.
    `mapM` takes a function and a list, maps the function over the list, and then
    sequences it. `mapM_` does the same thing, but it throws away the result later.
    We usually use `mapM_` when we don’t care what result our sequenced I/O actions
    have. Here’s an example of `mapM`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在列表上映射返回 I/O 操作的函数，然后对其进行序列化是非常常见的，所以引入了实用函数 `mapM` 和 `mapM_`。`mapM` 接受一个函数和一个列表，将函数映射到列表上，然后对其进行序列化。`mapM_`
    做同样的事情，但随后会丢弃结果。我们通常在不在乎我们序列化的 I/O 操作的结果时使用 `mapM_`。以下是一个 `mapM` 的例子：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But we don’t care about the list of three units at the end, so it’s better
    to use this form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们并不关心最后的三个单元列表，所以使用这个形式更好：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: forever
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: forever
- en: 'The `forever` function takes an I/O action and returns an I/O action that just
    repeats the I/O action it got forever. It’s located in `Control.Monad`. The following
    little program will indefinitely ask the user for some input and spit it back
    in all uppercase characters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`forever` 函数接受一个 I/O 操作，并返回一个无限重复该 I/O 操作的 I/O 操作。它位于 `Control.Monad` 中。以下这个小程序将无限期地要求用户输入一些内容，并以全部大写字母的形式将其返回：'
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: forM
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: forM
- en: '`forM` (located in `Control.Monad`) is like `mapM`, but its parameters are
    switched around. The first parameter is the list, and the second is the function
    to map over that list, which is then sequenced. Why is that useful? Well, with
    some creative use of lambdas and `do` notation, we can do stuff like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`forM`（位于 `Control.Monad` 中）类似于 `mapM`，但其参数顺序相反。第一个参数是列表，第二个是要映射到该列表上的函数，然后对其进行序列化。这有什么用呢？嗯，通过一些创造性的
    lambda 和 `do` 表达式使用，我们可以做这样的事情：'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here’s what we get when we try this out:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试这样做时，我们得到以下结果：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `(\a -> do ... )` lambda is a function that takes a number and returns an
    I/O action. Notice that we call `return color` in the inside `do` block. We do
    that so that the I/O action that the `do` block defines yields the string that
    represents our color of choice. We actually did not have to do that though, since
    `getLine` already yields our chosen color, and it’s the last line in the `do`
    block. Doing `color <- getLine` and then `return color` is just unpacking the
    result from `getLine` and then repacking it—it’s the same as just calling `getLine`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`(\a -> do ... )` lambda 是一个接受一个数字并返回一个 I/O 操作的函数。注意我们在内部 `do` 块中调用了 `return
    color`。我们这样做是为了让 `do` 块定义的 I/O 操作产生代表我们选择的颜色的字符串。实际上我们不必这样做，因为 `getLine` 已经产生了我们选择的颜色，并且它是
    `do` 块中的最后一行。执行 `color <- getLine` 然后执行 `return color` 只是从 `getLine` 中解包结果然后再打包它——这和只调用
    `getLine` 是一样的。'
- en: The `forM` function (called with its two parameters) produces an I/O action,
    whose result we bind to `colors`. `colors` is just a normal list that holds strings.
    At the end, we print out all those colors by calling `mapM putStrLn colors`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`forM` 函数（使用其两个参数调用）产生一个 I/O 操作，我们将结果绑定到 `colors`。`colors` 只是一个普通的字符串列表。最后，我们通过调用
    `mapM putStrLn colors` 打印出所有这些颜色。'
- en: You can think of `forM` as saying, “Make an I/O action for every element in
    this list. What each I/O action will do can depend on the element that was used
    to make the action. Finally, perform those actions and bind their results to something.”
    (Although we don’t need to bind it; we could also just throw it away.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `forM` 理解为，“为这个列表中的每个元素创建一个 I/O 操作。每个 I/O 操作将做什么可以依赖于用于创建该操作的元素。最后，执行这些操作并将它们的结果绑定到某个地方。”（尽管我们不需要绑定它；我们也可以简单地丢弃它。）
- en: We could have actually achieve the same result without `forM`, but using `forM`
    makes the code more readable. Normally, we use `forM` when we want to map and
    sequence some actions that we define on the spot using `do` notation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以不使用 `forM` 就达到相同的结果，但使用 `forM` 使得代码更易读。通常，当我们想要映射和序列化一些在 `do` 表达式上即时定义的操作时，我们会使用
    `forM`。
- en: I/O Action Review
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O 操作回顾
- en: Let’s run through a quick review of the I/O basics. I/O actions are values much
    like any other value in Haskell. We can pass them as parameters to functions,
    and functions can return I/O actions as results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下 I/O 基础知识。I/O 操作就像 Haskell 中的任何其他值一样，是值。我们可以将它们作为参数传递给函数，函数也可以将 I/O
    操作作为结果返回。
- en: What’s special about I/O actions is that if they fall into the `main` function
    (or are the result in a GHCi line), they are performed. And that’s when they get
    to write stuff on your screen or play “Yakety Sax” through your speakers. Each
    I/O action can also yield a result to tell you what it got from the real world.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: I/O操作的特殊之处在于，如果它们发生在`main`函数中（或者是在GHCi命令行中的结果），它们就会被执行。这时，它们会在你的屏幕上写东西，或者通过你的扬声器播放“Yakety
    Sax”。每个I/O操作还可以产生一个结果，告诉你它从现实世界获得了什么。
