- en: Part VI. VIEW FROM THE TOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第VI部分。从高处看
- en: The air's getting thinner, but the view's getting better. Several hundred pages
    ago we started our journey at the lowest level, grubbing around the seedy underbelly
    of source code construction. In this last section we complete our journey by climbing
    to the very top of the software development mountain and surveying the territory
    below. I hope you're not afraid of heights.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 空气越来越稀薄，但视野却越来越开阔。在几百页之前，我们从源代码构建的阴暗角落开始我们的旅程。在这个最后一部分，我们通过攀登软件开发之巅，审视下面的领域来完成我们的旅程。我希望你不会害怕高度。
- en: Here we'll look at how the final parts of the jigsaw fit together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探讨拼图最后部分的组合方式。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章。程序配方")'
- en: 'The code cookbook: how we actually write software in our development teams.
    This chapter describes both software development methodologies and software development
    processes. It shows how we manage to produce programs in a predictable, timely
    manner (or, at least, attempt to).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 代码食谱：我们如何在开发团队中实际编写软件。本章描述了软件开发方法和软件开发流程。它展示了我们如何以可预测、及时的方式（或者至少尝试这样做）产生程序。
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第23章](ch23.html "第23章。极限之外")'
- en: 'A look at the different code-writing disciplines out there: applications programming,
    games programming, distributed programming, and more. Each of these branches of
    programming has its own special problems and important skills. Understanding these
    will equip you to write the most suitable code for each occasion.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 查看不同的代码编写学科：应用程序编程、游戏编程、分布式编程等等。每个编程分支都有其独特的问题和重要的技能。理解这些将使你能够为每种场合编写最合适的代码。
- en: '[Chapter 24](ch24.html "Chapter 24. WHERE NEXT?")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第24章](ch24.html "第24章。下一步去哪里？")'
- en: The end is in sight. . . . This is the final, tearful farewell. We look at where
    to go next in your continuing study of code craft. This book is just the beginning.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 结局就在眼前……这是最后的、泪眼盈盈的告别。我们来看看在继续学习代码工艺的过程中下一步该去哪里。这本书只是个开始。
- en: Chapter 22. RECIPE FOR A PROGRAM
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第22章。程序配方
- en: '*Code Development Methodologies and Processes*'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*代码开发方法和流程*'
- en: They always say time changes things, but you actually have to change them yourself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他们总是说时间会改变一切，但实际上你必须自己去改变它们。
- en: --Andy Warhol
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: -- 安迪·沃霍尔
- en: '**Ingredients**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**配料**'
- en: 1 bunch programmers (preferably fresh)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一群程序员（最好是新手）
- en: 1-2 tsp language
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 1-2茶匙语言
- en: 1 target platform
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 1个目标平台
- en: 1 project manager
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1名项目经理
- en: 1 pinch luck
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 1撮运气
- en: 1 sachet dehydrated training
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 1包脱水训练
- en: Various industry buzzwords
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 各种行业术语
- en: '**Instructions**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**说明**'
- en: Marinade programmers in training. Add language, target platform, and season
    with project manager. Stir briskly until well mixed. Add buzzwords to taste. Sprinkle
    evenly with luck and leave to cook in a hot software oven until deadline. Remove,
    tip onto wire rack, and allow to cool before handing on to customer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在培训中的程序员。加入语言、目标平台，用项目经理调味。快速搅拌至混合均匀。根据口味添加术语。均匀撒上运气，放入热软件烤箱中烹饪至截止日期。取出，倒扣在铁架上，冷却后再交给客户。
- en: 'I know at least four recipes for sponge cake. They vary depending on whether
    you want a fat-free or an egg-free cake and also on the method you want to prepare
    with. Writing software is like that. There is no one recipe or magic formula;
    the same system could be built in many different ways, with no one necessarily
    better than any other. There are different ingredients that you may choose to
    feed the development process and different methods to follow. Likely as not, they
    will each produce a slightly different cake; different in terms of features, structure,
    stability, extensibility, maintainability, and more. These recipes describe the
    *software life cycle*: the phases of development ranging from the very beginning
    (conceptualizing the software) to its very end (decommissioning it).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我至少知道四种海绵蛋糕的配方。它们根据你想要无脂或无蛋的蛋糕以及你想要准备的方法而有所不同。编写软件就像这样。没有一种配方或魔法公式；同一个系统可以用许多不同的方式构建，没有一种方式必然比其他方式更好。你可以选择不同的配料来滋养开发过程，以及不同的方法来遵循。很可能会产生略微不同的蛋糕；在功能、结构、稳定性、可扩展性、可维护性等方面有所不同。这些配方描述了*软件生命周期*：从软件的最初概念化到其最终退役的各个发展阶段。
- en: As software engineers, we should be able to predictably (and to some extent
    reproducibly) create software by following a defined procedure. As software craftsmen,
    we should be able to harness a particular development procedure as a tool to help
    fashion the best software possible. In this chapter, we'll investigate some of
    the recipes for creating software; we'll compare, contrast, criticize, and see
    how they affect the way we code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们应该能够通过遵循定义的程序来可预测地（并在一定程度上可重复地）创建软件。作为软件工匠，我们应该能够利用特定的开发程序作为工具来帮助打造尽可能优秀的软件。在本章中，我们将探讨一些创建软件的配方；我们将比较、对比、批评，并看看它们如何影响我们的编码方式。
- en: We programmed a ZX spectrum differently from a modern palmtop PDA, and that
    differently from a mainframe stock control system with a high-capacity web interface.
    We program differently alone than we would working in a pair, and differently
    than we would in a 200-strong worldwide project team. Differences in the target
    platform and development team (and their levels of experience) will shape the
    choice of recipe. The art of programming is much more than just edit, compile,
    link, and run.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编程ZX spectrum的方式与现代掌上个人数字助理（PDA）不同，与具有高容量网络界面的主机库存控制系统也不同。我们独自编程的方式与我们在对编程的方式不同，与在由200人组成的全球项目团队中编程的方式也不同。目标平台和开发团队（以及他们的经验水平）的差异将塑造配方选择。编程的艺术远不止编辑、编译、链接和运行。
- en: '**KEY CONCEPT**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Good programmers are aware of* how *they program—the methods and practices
    that shape their work*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*优秀的程序员意识到*他们是如何*编程的——塑造他们工作的方法和实践*。'
- en: What are these programming recipes?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编程配方是什么？
- en: Programming Styles
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程风格
- en: A programming style describes how a software problem is mapped out and how its
    solution is decomposed and then modeled by the target language. We have to *model*
    a solution, since useful systems can't be entirely held in the mind of a single
    developer. The programming style shapes how we split a project up into manageable
    pieces; it is the design paradigm used to express your code's intent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编程风格描述了软件问题是如何被映射出来，以及其解决方案是如何被分解并通过目标语言进行建模的。我们必须*建模*一个解决方案，因为有用的系统不能完全被单个开发者的心智所容纳。编程风格塑造了我们将项目拆分成可管理部分的方式；它是用来表达代码意图的设计范式。
- en: 'Different programming languages support different programming styles. Some
    are tailored to a specific one; some cater for a number of them. The programming
    styles fall into two main camps: *imperative* and *declarative*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言支持不同的编程风格。有些是为特定的一种定制的；有些则满足多种。编程风格分为两大阵营：*命令式*和*声明式*。
- en: Imperative (or procedural ) languages allow you to specify the explicit sequence
    of steps to follow to produce the program's output. It's what most programmers
    are used to.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式（或过程式）语言允许你指定明确的步骤序列以生成程序的输出。这是大多数程序员所习惯的。
- en: Declarative languages describe relationships between variables in terms of inference
    rules (or functions), and the language executor applies some fixed algorithm to
    these rules to produce the result. (This description might turn into understandable
    English once when we take a look at functional and logic programming.)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式语言通过推理规则（或函数）来描述变量之间的关系，语言执行器对这些规则应用一些固定的算法以产生结果。（当我们查看函数式和逻辑编程时，这种描述可能变成可理解的英语。）
- en: The programming language you choose will go some way to determine the style
    you design with. (However, it would be better to select a language that supports
    the style you want to use.) The programming language is not the ultimate determinant,
    though. It is perfectly possible to build structured code in an object-oriented
    language, in the same way that it is possible to write hateful code in any language.
    The next few sections describe the popular programming styles.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的编程语言将在一定程度上决定你设计的风格。（然而，选择支持你想要使用的风格的编程语言会更好。）尽管如此，编程语言并不是最终的决定因素。在面向对象的语言中构建结构化代码是完全可能的，就像在任何语言中编写令人讨厌的代码一样。接下来的几节将描述流行的编程风格。
- en: Structured Programming
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化编程
- en: 'This common imperative design method applies *algorithmic decomposition*—a
    process of breaking a system into parts, each of which represents a small step
    in the larger process. Design decisions focus on the flow of control and create
    a hierarchy of functional structure. As Dijkstra observed, "Hierarchical systems
    seem to have a property that something considered as an undivided entity on one
    level is considered as a composite object on the next lowest level of greater
    detail: as a result, the natural grain of space or time that is applicable at
    each level decreases by an order of magnitude when we shift our attention from
    one level to the next lower one. We understand walls in terms of bricks, bricks
    in terms of crystals, crystals in terms of molecules, etc." Indeed, it was Dijkstra''s
    seminal paper "Go To Statement Considered Harmful" that popularized structured
    programming. (Dijkstra 68)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种常见的命令式设计方法应用了*算法分解*——一个将系统分解成部分的过程，每个部分代表更大过程中的一个小步骤。设计决策集中在控制流程上，并创建了一个功能结构的层次。正如迪杰斯特拉观察到的那样，“分层系统似乎具有这样的特性：在较高层次上被视为一个不可分割实体的东西，在较低层次上被视为一个复合对象：因此，当我们从较高层次转向较低层次时，适用于每个层次的空间或时间自然粒度减少了一个数量级。我们用砖块来理解墙壁，用晶体来理解砖块，用分子来理解晶体，等等。”确实，是迪杰斯特拉的奠基性论文“Go
    To Statement Considered Harmful”使结构化编程流行起来。（迪杰斯特拉 68）
- en: Structured programming is a control-centered model and follows a top-down design
    technique. You start with the whole program in mind (e.g., `do_shopping`). Then
    you decompose it into sequential sub-blocks (e.g., `get_shopping_list`, `leave_house`,
    `walk_to_shop`, `collect_items`, `pay_at_checkout`, `return_to_house`, `put_shopping_away`).
    In turn, each sub-block is decomposed until it is at a level that can be easily
    implemented in code. The blocks are assembled into a whole, and the design is
    complete.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程是一个以控制为中心的模型，并遵循自顶向下的设计技术。你从整个程序的概念出发（例如，`do_shopping`）。然后将其分解成顺序子块（例如，`get_shopping_list`、`leave_house`、`walk_to_shop`、`collect_items`、`pay_at_checkout`、`return_to_house`、`put_shopping_away`）。然后，每个子块被进一步分解，直到达到可以轻松在代码中实现的水平。这些块被组装成一个整体，设计完成。
- en: 'The implications of a structured approach are:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化方法的影响是：
- en: Each step of the decomposition should be within the programmer's intellectual
    understanding. (Dijkstra said, "I now suggest that we confine ourselves to the
    design and implementation of intellectually manageable programs.")
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解的每一步都应该在程序员的智力理解范围内。（迪杰斯特拉说：“我现在建议我们将自己限制在智力可管理的程序的设计和实现上。”）
- en: 'Control flow should be carefully managed: Avoid the dreaded `goto` statement
    (an unstructured jump in the code to some arbitrary place), and instead prefer
    functions to have a single entry and single exit point (this is known as *SESE
    code*).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程应谨慎管理：避免使用令人恐惧的`goto`语句（代码中向某个任意位置的未结构化跳转），而应优先考虑函数只有一个入口和一个出口点（这被称为*SESE代码*）。
- en: Looping constructs and conditional statements are used within functional blocks
    to provide code structure. Short-circuit jumping out of the middle of a loop or
    from within a nested block of code is held in similar disdain to `goto`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环结构和条件语句在功能块中使用，以提供代码结构。从循环中间或嵌套代码块中跳出的短路跳转与`goto`一样受到鄙视。
- en: Common structured programming languages are C, Pascal, BASIC, and more venerable
    languages like Fortran and COBOL. Most other imperative languages can be easily
    used to write structured code, although it's not their design specialism; structured
    programmers often adopt new fashionable languages without adopting new idioms.^([[1](#ftn.CHP-22-FN-1)])
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的结构化编程语言有C、Pascal、BASIC，以及更古老的Fortran和COBOL。大多数其他命令式语言都可以轻松地用来编写结构化代码，尽管这不是它们的设计专长；结构化程序员通常在采用新时尚语言时不会采用新的惯用语。[^[[1](#ftn.CHP-22-FN-1])]
- en: Object-Oriented Programming
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Booch describes OO programming as "A method of implementation in which programs
    are organized as co-operative collections of objects, each of which represents
    an instance of some class, and whose classes are all members of a hierarchy of
    classes united via inheritance relationships." (Booch 94) It is another imperative
    style, but one that allows us to more naturally model the world in our code designs;
    we focus on the interacting entities being modeled rather than on the notion of
    a particular flow of execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 波斯描述面向对象编程为：“一种实现方法，其中程序被组织为协作的对象集合，每个对象代表某个类的实例，并且这些类都是通过继承关系联合起来的类层次结构中的成员。”（波斯94）这是另一种命令式风格，但它允许我们在代码设计中更自然地模拟世界；我们关注被模拟的交互实体，而不是特定的执行流程概念。
- en: This is very much a data-centred model (as opposed to structured programming's
    process-centric view). We think about the life of our data and how it moves about,
    rather than the sequence of steps that need to be taken to get the job done. Objects
    (the data) have behavior (they do things) and states (which change when they do
    things). This is implemented at language level by *methods* on *classes* of *objects*.
    We think of OO programs as sets of collaborating software components, rather than
    as monolithic lists of CPU instructions. OO design has allowed us to effectively
    model larger systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常以数据为中心的模型（与结构化编程的过程中心视角相反）。我们思考我们的数据生活以及它的移动方式，而不是完成任务所需的步骤序列。对象（数据）具有行为（它们做事情）和状态（当它们做事情时发生变化）。这是通过在对象的**类**上实现**方法**在语言级别上实现的。我们将面向对象程序视为协作的软件组件集合，而不是作为单一的CPU指令列表。面向对象设计使我们能够有效地模拟更大的系统。
- en: 'Object-oriented programming exploits the following computer science concepts:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程利用以下计算机科学概念：
- en: '**Abstraction**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象**'
- en: The art of selective ignorance—abstraction allows us to design code so that
    the higher levels of control can ignore gory implementation details below. Who
    cares whether `get_next_item` does a binary search in a list, indexes an array,
    or makes a phone call to Frankfurt? It returns the next item (whatever that is),
    and that's all the calling code has to care about.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 选择性无知的艺术——抽象使我们能够设计代码，使控制层次可以忽略下面的血腥实现细节。谁在乎`get_next_item`是否在列表中进行二分搜索，索引数组，或者给法兰克福打电话？它返回下一个项目（无论是什么），这就是调用代码需要关心的所有内容。
- en: Dijkstra's earlier exposition of hierarchy—go back and read it again—revealed
    a form of abstraction.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 迪杰斯特拉早期对层次结构的阐述——回去再读一遍——揭示了一种抽象形式。
- en: '**Encapsulation**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**'
- en: 'Encapsulation is the placing of cohesive units of execution into one tightly
    bound package that can only be accessed through a well-defined API: a code capsule.
    Users of that capsule can only call the defined API and cannot tinker directly
    with internal state. This provides a clear separation of concerns, helps us to
    reason about metaphysical questions like *What is an object?* and provides some
    assurance that no evil programmer can tinker with your innards when you''re not
    looking.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是将执行单元的紧密绑定包放置在一个只能通过定义良好的API（代码胶囊）访问的包中：一个代码胶囊。该胶囊的用户只能调用定义好的API，不能直接篡改内部状态。这提供了一个清晰的关注点分离，帮助我们思考形而上学问题，如**什么是对象**？，并提供了一些保证，即当您不在看的时候，没有恶意的程序员会篡改您的内部结构。
- en: '**Inheritance**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**'
- en: A mechanism to create an object type that is a specialized version of a parent
    object. Consider a parent type called `Shape`, with inherited child types `Square`,
    `Circle`, and `Triangle`. The inherited types provide more detail, specializing
    behavior (for example, knowing the exact number of sides the shape has). Like
    any other programming concept, inheritance can be abused to create unfathomable,
    surprising programs or leveraged to create logically sound, elegant code. Good
    OO programmers know how to create appropriate inheritance hierarchies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一种创建对象类型的机制，它是父对象的专业版本。考虑一个名为`Shape`的父类型，它有继承的子类型`Square`、`Circle`和`Triangle`。继承类型提供了更多细节，专门化行为（例如，知道形状的确切边数）。像任何其他编程概念一样，继承可以被滥用以创建难以理解、令人惊讶的程序，或者被利用来创建逻辑上合理、优雅的代码。好的面向对象程序员知道如何创建适当的继承层次结构。
- en: '**Polymorphism**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**'
- en: This allows the same code to use different underlying data types (what most
    OO programming languages call *classes*) depending on the context in which it
    runs. This technique emphasizes programming to explicitly defined interfaces,
    not to an implicit implementation—polymorphism provides a clear separation of
    concerns as you write code. There are two types of polymorphism, *dynamic* and
    *static*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许相同的代码根据它在运行时的上下文使用不同的底层数据类型（大多数面向对象编程语言称为*类*）。这种技术强调的是针对显式定义的接口进行编程，而不是针对隐式实现——多态在编写代码时提供了明确的关注点分离。有两种类型的多态，*动态*和*静态*。
- en: 'Dynamic polymorphism, as the name suggests, determines the actual operation
    to be performed at run time, based on the type of an operand or target object.
    This often exploits inheritance hierarchies: a client that deals with `Shape`
    types might currently be using a `Square` or a `Triangle` object—which one is
    figured out at run time.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 动态多态，正如其名所示，根据操作数或目标对象的类型，在运行时确定要执行的实际操作。这通常利用继承层次结构：处理`Shape`类型的客户端可能目前正使用`Square`或`Triangle`对象——具体使用哪个对象是在运行时确定的。
- en: 'Static polymorphism determines the exact code to be run at compile time. Language
    features that provide static polymorphism include: *function overloading* (functions
    with the same name accept different parameter lists—the compiler deduces the correct
    function to invoke from the arguments supplied), *operator overloading* (where
    you can define certain operations on types—including +, !=, <, and &—these functions
    are called when the types of operands match), and *generic programming facilities*
    like C++''s *template specialism* (where you can overload a template based on
    the template parameter type).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 静态多态在编译时确定要运行的精确代码。提供静态多态的语言特性包括：*函数重载*（具有相同名称的函数接受不同的参数列表——编译器根据提供的参数推断出要调用的正确函数）、*运算符重载*（你可以定义类型上的某些操作——包括+、!=、<和&——当操作数的类型匹配时调用这些函数），以及像C++的*模板特化*这样的*泛型编程设施*（你可以根据模板参数类型重载模板）。
- en: These facilities are all possible to use in non-OO languages, using non-OO practices.
    However, OO languages express them directly and OO designs exploit them to create
    a cohesive system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在非面向对象语言中也是可能的，使用非面向对象实践。然而，面向对象语言直接表达它们，面向对象设计利用它们来创建一个统一的系统。
- en: Object-oriented programming started with Simula around 1970 and has been recently
    popularized by C++ and Java. One of the few pure OO programming languages is Smalltalk.
    These days, OO is en vogue, and there are many OO languages; a number are structured
    languages with fashionable OO bolt-ons.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程始于1970年左右的Simula，最近由于C++和Java的普及而变得流行。少数纯面向对象编程语言之一是Smalltalk。如今，面向对象很流行，有众多面向对象的语言；其中一些是结构化语言，带有流行的面向对象功能。
- en: Functional Programming
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: This is a declarative programming style based on typed *lambda calculus*, a
    more mathematical model of programming. You work with values, functions, and functional
    forms. Functional programs are generally compact and elegant, although seldom
    compiled. They are therefore reliant on a language executor. The program's performance
    is governed by these executors—they can be quite slow and memory hungry.^([[2](#ftn.CHP-22-FN-2)])
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于类型化*λ演算*的声明式编程风格，是一种更数学化的编程模型。你处理的是值、函数和函数形式。函数式程序通常紧凑且优雅，尽管很少被编译。因此，它们依赖于语言执行器。程序的性能由这些执行器控制——它们可能相当慢且占用内存多。[^([2](#ftn.CHP-22-FN-2))]
- en: The structured and OO styles are far more popular in mainstream use than any
    declarative languages, although that doesn't diminish the usefulness of this breed
    of programming. They have different strong points and uses. Functional programs
    require a totally different approach to code design from the procedural methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化和面向对象（OO）风格在主流使用中比任何声明式语言都更受欢迎，尽管这并不减少这种编程类型的有用性。它们有不同的优点和用途。函数式程序需要与过程方法完全不同的代码设计方法。
- en: Common functional programming languages are Lisp (although it does contain nonfunctional
    elements), Scheme, ML, and Haskell.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的函数式编程语言包括Lisp（尽管它包含非函数式元素）、Scheme、ML和Haskell。
- en: Logic Programming
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑编程
- en: This is another declarative style, in which you provide the executor with a
    set of axioms (rules) and a goal statement. A set of built-in inference rules
    (over which the programmer has no control) are applied to determine whether the
    axioms are sufficient to ensure the truth of the goal statement. Program execution
    is essentially the proof of the goal statement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种另一种声明式风格，其中你向执行者提供一套公理（规则）和一个目标陈述。一套内置的推理规则（程序员无法控制）被应用于确定公理是否足以确保目标陈述的真实性。程序执行本质上是对目标陈述的证明。
- en: Interest in artificial intelligence was a huge boost to the development of logic
    programming languages. They are widely used for automatic theorem proving and
    in *expert systems* (which model large problem domains and generate specific answers
    based on the amassed body of knowledge).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对人工智能的兴趣极大地推动了逻辑编程语言的发展。它们被广泛用于自动定理证明和在*专家系统*（它们模拟大型问题域并根据积累的知识库生成特定答案）中。
- en: The best known logic programming language is Prolog.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的逻辑编程语言是Prolog。
- en: '* * *'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-22-FN-1)]) This is not necessarily a Bad Thing, unless the programmer
    believes that he's moved beyond structured coding without changing the way he
    designs code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-22-FN-1)]) 这并不一定是一件坏事，除非程序员认为他在没有改变代码设计方式的情况下已经超越了结构化编程。
- en: ^([[2](#CHP-22-FN-2)]) This is not a problem solely encountered by declarative
    languages (for example Java has an executor, the JVM). However, comparatively
    less optimization effort has gone into the declarative breed of language executors—they're
    more often backed by academic institutions than wealthy corporations.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-22-FN-2)]) 这不是仅由声明式语言（例如Java有一个执行器，JVM）遇到的问题。然而，相对较少的优化工作投入到声明式语言的执行器中——它们更常由学术机构而不是富有的公司支持。
- en: 'Recipes: The How and the What'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 食谱：如何和是什么
- en: 'There are two different aspects we''ll investigate. Software "recipes" employ
    a *development process* and also a *programming style*. The two are separate and
    connected:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究两个不同的方面。软件“食谱”采用*开发过程*和*编程风格*。这两个是分开的，也是相连的：
- en: 'The process is the larger picture: It describes the steps taken to construct
    software. This encompasses the *entire* development organization, not just the
    programmers. Most software construction is not a one-person job; the process explains
    how to get a number of people to build a coherent whole. Or at least, it should
    attempt to.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程是更大的图景：它描述了构建软件所采取的步骤。这包括整个开发组织，而不仅仅是程序员。大多数软件构建不是一个人的工作；这个过程解释了如何让许多人构建一个连贯的整体。或者至少，它应该尝试这样做。
- en: 'The programming style is the smaller picture: It is an underlying approach
    for dissecting, building, and gluing software components together. It will quite
    likely be influenced by the choice of development process, but doesn''t have to
    be.^([[3](#ftn.CHP-22-FN-3)]) It''s more likely to be influenced by a target language
    or the designer''s prior experience.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程风格是更小的图景：它是分解、构建和粘合软件组件的基本方法。它很可能受到开发过程选择的影响，但不必如此.^([[3](#ftn.CHP-22-FN-3)])
    它更有可能受到目标语言或设计者的先前经验的影响。
- en: You'll see both of these construction aspects called methodologies, so it's
    easy to get them confused.^([[4](#ftn.CHP-22-FN-4)]) We'll look in turn at styles
    and then development processes. It's important to have a grasp of the different
    development methods out there, to give you a better programming worldview and
    to help you choose a process, should you ever have the opportunity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这两个构建方面都被称为方法论，所以很容易混淆它们.^([[4](#ftn.CHP-22-FN-4)]) 我们将依次探讨风格和开发过程。了解不同的开发方法很重要，这可以给你一个更好的编程世界观，并帮助你选择一个过程，如果你有机会的话。
- en: '**KEY CONCEPT**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Our software development efforts are molded by the* styles *and* processes
    *we employ. These have an inevitable effect on the shape and quality of our code*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们的软件开发努力受到我们采用的*风格*和*过程*的影响。这些不可避免地影响了我们代码的形状和质量*。'
- en: The following sections do not provide a textbook description of these topics;
    they provide a suitably hand-wavy overview to help us compare and contrast. If
    you want or need more detail, you can easily find a hard-core software engineering
    textbook.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节并不提供这些主题的教科书描述；它们提供了一个适当的手势性概述，以帮助我们比较和对比。如果你需要或想要更多细节，你可以轻松地找到一本核心软件工程教科书。
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#CHP-22-FN-3)]) For example, OO styles are often picked in "iterative
    and incremental" processes; this is mostly by convention. (If you don't know what
    this means, *don't panic*! It will all be explained in "[Iterative and Incremental
    Development](ch22s03.html#iterative_and_incremental_development "Iterative and
    Incremental Development")" on page 432.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-22-FN-3)]) 例如，面向对象风格通常在“迭代和增量”过程中被选择；这主要是一种惯例。（如果你不知道这是什么意思，*不要慌张*！所有这些都会在第432页的"[迭代和增量开发](ch22s03.html#iterative_and_incremental_development
    "Iterative and Incremental Development")"中解释。）
- en: ^([[4](#CHP-22-FN-4)]) If you want to make a distinction, then what I call programming
    styles are often called methodologies (with a lowercase m). Development processes
    are often called Methodologies (with an uppercase M ); a kind of high-church/low-church
    classification. That's far too subtle. In this chapter I'll stick to styles and
    processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-22-FN-4)]) 如果你想做出区分，那么我所说的编程风格通常被称为方法（小写m）。开发过程通常被称为方法（大写M）；一种高教会/低教会分类。这太微妙了。在本章中，我将坚持使用风格和过程。
- en: Development Processes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发过程
- en: There are as many development processes as there are people who feel like inventing
    them. Many are slight evolutions of one or two basic development models. We'll
    look here at those basic variants. Some of them are closely related, as you will
    see.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少人想发明它们，就有多少种开发过程。许多是基本开发模型的一两个轻微演变。我们将在这里查看这些基本变体。其中一些非常相关，正如你将看到的。
- en: 'Your choice of development processes determines how projects are planned, how
    work flows between phases, and how the project team interacts. Processes vary
    along a number of axes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的发展过程决定了项目如何规划，工作如何在阶段之间流动，以及项目团队如何互动。过程沿着多个轴变化：
- en: '**Thick/thin**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**繁重/轻量级**'
- en: A *thick development process* is heavyweight and bureaucratic. It generates
    a lot of paperwork, regiments developer behavior, and presumes a certain team
    structure. It's characterized by the ISO 9000 organizational model, where every
    work procedure is slavishly written down in great detail, without regard for whether
    the process is flawed or appropriate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*繁重的开发过程*是重量级的，官僚主义的。它产生了大量的文件工作，规范了开发者的行为，并假设了某种团队结构。它以ISO 9000组织模型为特征，其中每个工作程序都详细地、盲目地记录下来，而不考虑该过程是否有缺陷或是否适当。'
- en: At the other end of the process spectrum, *thin development processes* eschew
    unnecessary bureaucracy, favoring leaner, people-centric principles. Agile processes,
    described in "[Agile Methodologies](ch22s03.html#agile_methodologies "Agile Methodologies")"
    on page 433, are built around thin practices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程光谱的另一端，*轻量级的开发过程*摒弃了不必要的官僚主义，更倾向于更精简、以人为本的原则。在第433页的"[敏捷方法](ch22s03.html#agile_methodologies
    "Agile Methodologies")"中描述的敏捷过程，是围绕轻量级实践构建的。
- en: '**Sequencing**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序**'
- en: Some development processes sensibly recognize that the world is not a predictable
    place and attempt to model and plan for this by running a number of iterations
    around a process loop. This provides an opportunity for the developers to incorporate
    feedback from one iteration into the work of the next. They can adapt to the natural
    changes that occur as software develops (changing customer requirements, unexpected
    problems encountered, etc.).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发过程合理地认识到世界不是一个可预测的地方，并试图通过在过程循环周围运行多个迭代来对此进行建模和规划。这为开发者提供了将一次迭代中的反馈纳入下一次工作的机会。他们可以适应软件开发过程中发生的自然变化（如变化的需求、意外遇到的问题等）。
- en: Other processes are more regimented and linear—predicting a formal progression
    of development from one phase to the next. They involve heavy up-front planning
    efforts and try to foresee the future in great detail. These predictions make
    it hard to change direction late in development.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他过程更加规范和线性——预测从一阶段到下一阶段的正式发展进程。它们涉及大量的前期规划工作，并试图详细预见未来。这些预测使得在开发后期改变方向变得困难。
- en: '**Design direction**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计方向**'
- en: A *top-down design* creates the system from an initial undetailed overview.
    Each top-level package is refined and split into subcomponents. This process iterates
    until the software is specified sufficiently to begin work. Top-down design emphasizes
    planning and a good understanding of the final system, and presumes that few requirements
    change en route.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*自上而下的设计*从最初的不详细概述创建系统。每个顶级包被细化并分解为子组件。这个过程迭代，直到软件被充分指定，可以开始工作。自上而下的设计强调规划和对最终系统的良好理解，并假设在途中很少有需求发生变化。'
- en: The opposite, *bottom-up design*, specifies individual parts of the system in
    detail and then determines how best to connect them to form a cohesive whole.
    This helps us to leverage existing software components in a new design. Modern
    processes tend to blend these two polar opposites—some idea of the entire system
    is required to begin initial planning, then the design progresses by identifying
    and coding low-level components and objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*自下而上的设计*详细指定系统的各个部分，然后确定如何将它们连接起来以形成一个统一的整体。这有助于我们在新的设计中利用现有的软件组件。现代流程倾向于融合这两个截然相反的方法——需要有一个关于整个系统的概念来开始初步规划，然后通过识别和编码低级组件和对象来推进设计。
- en: No one style of development process is better than any other. Extreme religious
    views are held about the correct position on any one of these axes. The correct
    methodology for any project is determined by a number of factors, including the
    development culture of the organization, the type of product being developed,
    and the experience of the development team.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种开发流程比其他任何一种更好。对于这些轴上的任何一个正确的位置，都持有极端的宗教观点。任何项目的正确方法是由许多因素决定的，包括组织的开发文化、正在开发的产品类型以及开发团队的经验。
- en: Now please buckle your seat belts for our roller coaster ride through the range
    of software development processes. Hold on tight.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请系好安全带，准备我们的软件开发生命周期之旅。紧紧抓住。
- en: Ad Hoc
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时性的
- en: This is a starting point, but it's really an anti-process. Here there is no
    process, or else it is undocumented. Everybody works to his or her own agenda,
    no one knows what anyone else is doing, and hopefully something useful will drop
    out at the end. Perhaps your team works like [Figure 22-1](ch22s03.html#engineering_a_release
    "Figure 22-1. Engineering a release")?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个起点，但实际上是一个反流程。这里没有流程，或者流程没有文档记录。每个人都按照自己的议程工作，没有人知道别人在做什么，希望最终能产生一些有用的东西。也许你的团队工作方式就像[图22-1](ch22s03.html#engineering_a_release
    "图22-1. 工程发布")？
- en: If an organization doesn't know how it builds software, then it's in an unforgivable
    state, even if it's a small outfit and it doesn't think it needs a process. In
    this state, there is no guarantee that the software will be delivered on time,
    since there's no accountability. Who can guarantee that all the features will
    be implemented?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组织不知道如何构建软件，那么它处于不可饶恕的状态，即使它是一个小组织，并且它认为不需要流程。在这种状态下，没有保证软件会按时交付，因为没有问责制。谁能保证所有功能都会实现？
- en: A lot of open source software is created using this chaotic method.^([[5](#ftn.CHP-22-FN-5)])
    If you have an infinite number of monkeys and an infinite number of computers,
    you might eventually get a program out—however it isn't feasible to wait the requisite
    infinite amount of time. Even back-of-napkin designs are a step toward a more
    formal, predictable development process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开源软件都是使用这种方法创建的.^([[5](#ftn.CHP-22-FN-5)]) 如果你有无穷多的猴子和无穷多的计算机，你最终可能会得到一个程序——然而等待必要的无穷长时间是不切实际的。即使是便条设计也是向更正式、可预测的开发过程迈出的一步。
- en: '**KEY CONCEPT**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Without a development process, your team is in a state of anarchy. Your software
    will be produced by luck, not on purpose*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有开发流程，你的团队处于无序状态。你的软件将是由运气产生，而不是有目的地产生*。'
- en: This case is development anarchy. Individual programmers may work hard, and
    their heroic efforts might eventually produce something of value. Such an outcome
    cannot be seriously relied upon, though. The team is likely to be very inefficient
    and will probably never deliver anything of value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例是开发无序。个别程序员可能非常努力工作，他们的英雄行为最终可能产生有价值的东西。但这种结果并不能被严重依赖。团队可能非常低效，并且可能永远不会交付有价值的东西。
- en: '![Engineering a release](tagoreillycom20080909nostarchimages207578.png.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![工程发布](tagoreillycom20080909nostarchimages207578.png.jpg)'
- en: '**Figure 22-1. Engineering a release**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22-1. 工程发布**'
- en: Waterfall Model
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水晶球模型
- en: The *waterfall model* is the classic software development life cycle model.
    It has been much criticized for its simplicity (even for being old fashioned).
    However practically every other development process is in some way based on it.
    It has numerous flaws, and yet it is still an instructional starting point in
    process study. It's modeled after a more conventional engineering life cycle and
    was described by W.W. Royce in 1970\. (Royce 70) It's the most predictive of the
    development processes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**瀑布模型**是经典的软件开发生命周期模型。它因其简单性（甚至被认为是过时的）而受到很多批评。然而，实际上其他每个开发流程都以某种方式基于它。它有许多缺陷，但仍然是过程研究中的教学起点。它是根据更传统的工程生命周期模型构建的，由W.W.
    Royce在1970年描述。（Royce 70）它是开发流程中最可预测的。'
- en: '**STAGES OF DEVELOPMENT**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发阶段**'
- en: The waterfall model describes five stages in the life of a software development
    process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 水晶模型描述了软件开发过程生命周期中的五个阶段。
- en: Many other processes identify the same phases but order them differently or
    change their relative emphasis.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他流程识别出相同的阶段，但它们的顺序不同或改变了它们的相对重点。
- en: '**Requirements analysis**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**需求分析**'
- en: 'First, the requirements for the software project are established. This scopes
    its goals, the services it will provide, and what constraints it needs to work
    within. This step is often preceded by a feasibility study to kick the project
    off, or feasibility is done at the same time. The feasibility study asks questions
    like: *Will this project work? Should we develop this software? What are the alternatives?*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确定软件项目的需求。这确定了其目标、它将提供的服务以及它需要在其内工作的约束。这一步骤通常在启动项目之前进行可行性研究，或者可行性研究是在同一时间进行的。可行性研究提出诸如：*这个项目能行吗？我们应该开发这个软件吗？有哪些替代方案？*等问题。
- en: '**Design and specification**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计和规范**'
- en: The established requirements flowing from the first stage are converted into
    software or hardware requirements. The software requirements are then transformed
    into a form that can be readily implemented in a computer program, perhaps by
    splitting into separately developed components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一阶段产生的既定需求被转换为软件或硬件需求。然后，软件需求被转换成可以在计算机程序中轻松实现的形式，可能通过将其拆分为单独开发的组件。
- en: '**Implementation**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**实施**'
- en: This is where the programs are created. Each program or subcomponent is a unit,
    and is unit tested. The unit test ensures that each unit meets its specification
    as defined in the previous step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建程序的地方。每个程序或子组件都是一个单元，并且会进行单元测试。单元测试确保每个单元都满足在之前步骤中定义的规格。
- en: '**Integration and testing**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成和测试**'
- en: All units are combined and the whole system is tested. We test that the code
    integrates correctly, that the entire system behaves as it should, and that it
    implements all system requirements. When successfully tested, the software is
    considered complete.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单元都被组合在一起，整个系统进行测试。我们测试代码是否正确集成，整个系统是否按预期运行，以及它是否实现了所有系统需求。当成功测试后，软件被认为是完整的。
- en: '**Maintenance**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护**'
- en: Finally, the product is delivered. We should never presume software is finished
    when it ships; it is naïve to do so. The largest phase of the software lifecycle
    is *maintenance* (see "[Maintenance of Existing Code](ch15s05.html#maintenance_of_existing_code
    "Maintenance of Existing Code")" on page 288). There will be bugs to fix, unnoticed
    requirements to accommodate, evolution of the original requirements, and other
    product support work for software deployed in the field.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，产品被交付。我们永远不应该假设软件在发货时就完成了；这样做是幼稚的。软件生命周期中最大的阶段是*维护*（参见第288页的“[现有代码的维护](ch15s05.html#maintenance_of_existing_code
    "现有代码的维护")”）。将会有需要修复的错误、需要满足的未注意到的需求、原始需求的演变，以及为在野外部署的软件提供的其他产品支持工作。
- en: It is a simple idea; the development process is broken up into a number of stages,
    which run one after the other. This is likened to a waterfall because of the steady,
    irreversible flow from one stage to another. Just as water always flows downward
    toward the river, the development always flows downward through each stage toward
    release.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的想法；开发过程被分解为多个阶段，这些阶段依次运行。这被比作瀑布，因为从一个阶段到另一个阶段的稳定、不可逆的流动。就像水总是流向河流一样，开发总是通过每个阶段向下流动到发布。
- en: The traditional waterfall model is shown in [Figure 22-2](ch22s03.html#the_traditional_waterfall_model
    "Figure 22-2. The traditional waterfall model").^([[6](#ftn.CHP-22-FN-6)]) You
    can see the five standard stages; these are described in the "[STAGES OF DEVELOPMENT](ch22s03.html#stages_of_development
    "STAGES OF DEVELOPMENT")" text box. Once a stage is successfully completed, progression
    is made via some *gating process* (usually a review meeting) to the next stage.
    The output of most stages is a document; a requirements specification, a design
    specification, or something similar. If the review finds an error or problem,
    it is fed back upstream, setting that stage back again.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的瀑布模型在[图22-2](ch22s03.html#the_traditional_waterfall_model "图22-2.传统的瀑布模型")中展示。^([[6](#ftn.CHP-22-FN-6)])
    你可以看到五个标准阶段；这些在"[开发阶段](ch22s03.html#stages_of_development "开发阶段")"文本框中有描述。一旦一个阶段成功完成，就会通过某种*关卡过程*（通常是审查会议）进入下一个阶段。大多数阶段的输出是一个文档；一个需求规范，一个设计规范，或者类似的东西。如果审查发现错误或问题，它会被反馈到上游，使该阶段再次回退。
- en: Following this model, you can't easily backtrack to make changes; it's like
    a salmon expending massive amounts of time and energy swimming back upstream.
    While salmon are genetically programmed to do this, programmers aren't. This means
    that the process is not helpful when changes are made late in the development
    process. The requirements must be fixed before system design, and it is difficult
    to accommodate too many alterations after the process is underway. Generally,
    problems at the design stage are not discovered until system testing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个模型，你很难回溯进行更改；这就像鲑鱼花费大量时间和能量逆流而上。虽然鲑鱼在基因上被编程来做这件事，但程序员不是。这意味着在开发后期进行更改时，这个过程并不有帮助。需求必须在系统设计之前确定，并且在过程开始后很难容纳太多的变更。通常，设计阶段的问题直到系统测试时才会被发现。
- en: In its defense, though, it is simple to manage—at least conceptually—and is
    the basis for most other development models. The waterfall doesn't scale well
    to very large projects; it works fine for a two-week project. Other development
    models exploit this by running many, smaller, waterfalls over the life of a large
    project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就其辩护而言，它易于管理——至少在概念上是这样——并且是大多数其他开发模型的基础。瀑布模型不适合非常大的项目；对于两周的项目来说效果很好。其他开发模型通过在大型项目的生命周期中运行许多较小的瀑布来利用这一点。
- en: '![The traditional waterfall model](tagoreillycom20080909nostarchimages207580.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![传统的瀑布模型](tagoreillycom20080909nostarchimages207580.png)'
- en: '**Figure 22-2. The traditional waterfall model**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22-2.传统的瀑布模型**'
- en: SSADM and PRINCE
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSADM和PRINCE
- en: Although *SSADM* sounds like development only partaken by consenting adults,
    it actually stands for *Structured Systems Analysis and Design Methodology*. It
    is a structured and rigorous method following the waterfall approach, perhaps
    the most regimented waterfall variant you'll encounter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*SSADM*听起来像是只有成年人参与的开发，但它实际上代表的是*结构化系统分析与设计方法*。它是一种遵循瀑布方法的严格和结构化的方法，可能是你遇到的最有规律的瀑布变体。
- en: 'It covers analysis and design, not implementation and testing, and is a well-defined
    open standard, heavily used in UK government organizations. SSADM consists of
    five main steps (each subdivided into many other procedures), which for our purposes
    are self-descriptive:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它涵盖了分析和设计，而不是实现和测试，是一个定义良好的开放标准，在英国政府机构中被广泛使用。SSADM由五个主要步骤（每个步骤又细分为许多其他程序）组成，就我们的目的而言，这些步骤是自我描述的：
- en: Feasibility study
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可行性研究
- en: Requirements analysis
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求分析
- en: Requirements specification
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求规范
- en: Logical system specification
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑系统规范
- en: Physical design
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理设计
- en: '*Projects In a Controlled Environment (PRINCE)* and its imaginatively named
    successor, *PRINCE2*, were created in 1989 and 1996 to supercede SSADM. Like SSADM,
    they define a heavyweight, document-centric model. They list regimented steps
    (this time in eight separate phases) that can be followed to produce a product,
    aiming to meet identified requirements and quality standards.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*受控环境中的项目（PRINCE）*及其富有创意命名的继任者，*PRINCE2*，分别于1989年和1996年创建，以取代SSADM。与SSADM一样，它们定义了一个重量级、以文档为中心的模型。它们列出了可以遵循的正规步骤（这次分为八个单独的阶段），以生产产品，旨在满足已识别的需求和质量标准。'
- en: V Model
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V模型
- en: This process model derives from the classic waterfall and was developed to regulate
    the software development process within German administration and military. It
    shares much in common with the waterfall model (including a propensity to attract
    criticism) but rather than model the processes as a cascade, it is visualized
    as a *V*, as shown in [Figure 22-3](ch22s03.html#the_v_model "Figure 22-3. The
    V model").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程模型源于经典瀑布模型，是为了规范德国政府和军事部门内的软件开发流程而开发的。它与瀑布模型有很多共同之处（包括倾向于吸引批评），但它不是将过程建模为瀑布，而是将其可视化为一个*V*，如图[图22-3](ch22s03.html#the_v_model
    "图22-3. V模型")所示。
- en: '![The V model](tagoreillycom20080909nostarchimages207582.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![V模型](tagoreillycom20080909nostarchimages207582.png)'
- en: '**Figure 22-3. The V model**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22-3. V模型**'
- en: 'On the left, we see the development phases leading up to software construction:
    the planning, design, and implementation work. The right-hand stream governs testing
    and approval.^([[7](#ftn.CHP-22-FN-7)]) Each level of test work is measured against
    the specification generated from the corresponding left-hand phase.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们看到软件开发阶段，直到软件构建：规划、设计和实施工作。右侧的流程控制测试和批准。[7](#ftn.CHP-22-FN-7)] 每个测试级别的工作都是与从相应的左侧阶段生成的规范进行衡量的。
- en: 'The V model''s difference from the waterfall is more than the orientation of
    a diagram. The testing phases (in the right branch) can begin in parallel to the
    development work (the left branch), and are given an equal importance. This is
    good because:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: V模型与瀑布模型的不同之处不仅仅是图表的方向。测试阶段（在右侧分支）可以与开发工作（左侧分支）并行开始，并且被赋予同等的重要性。这是好的，因为：
- en: Traditionally, testing is squeezed out during the dying stages of a slipping
    project. This is dangerous. Emphasizing testing as a keystone of the development
    process highlights this fact and helps to ensure product quality.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统上，在项目即将结束时，测试会被压缩。这是危险的。强调测试作为开发过程的关键环节，突出了这一事实，并有助于确保产品质量。
- en: 'We should always test more than the final software: reviewing and validating
    at *all* stages of development work, from the requirements specification through
    to the completed software. The V model highlights this.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该始终测试比最终软件更多的内容：从需求规格说明到完成的软件的所有开发阶段，都要进行审查和验证。V模型强调了这一点。
- en: In the Real World, testing and bug fixing often take up more than half of a
    project's total time. The waterfall model doesn't accurately reflect this.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，测试和错误修复通常占项目总时间的一半以上。瀑布模型并不能准确反映这一点。
- en: This model can shave time from the entire development process, since the test
    plans can be drawn up as soon as each development phase is complete. This streamlined,
    parallelized work will bring forward the project's end date because we don't need
    to wait for the waterfall's implementation phase to end before beginning test
    activity.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模型可以从整个开发过程中节省时间，因为测试计划可以在每个开发阶段完成后立即制定。这种简化和并行化的工作将提前项目的结束日期，因为我们不需要等待瀑布模型的实施阶段结束才开始测试活动。
- en: Prototyping
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: Despite our many years of research and experience in software development processes,
    the waterfall is still a standard reference model since it has a clear logic to
    it—you obviously can't perform useful implementation before requirements analysis
    or any design work. However, the waterfall makes it hard to evaluate a software
    system until development is complete. It is also hard to demonstrate the software
    to your customer until the integration phase has completed and the system is ready
    to alpha test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在软件开发流程方面有多年研究和经验，但瀑布模型仍然是一个标准的参考模型，因为它具有清晰的逻辑——显然，在需求分析或任何设计工作之前，你不能进行有用的实施。然而，瀑布模型使得在开发完成之前很难评估软件系统。同样，直到集成阶段完成并且系统准备进行alpha测试之前，也很难向客户展示软件。
- en: The *prototyping approach* attempts to work around this limitation. It helps
    to explore and evaluate implementation as development progresses and to refine
    unknown or ambiguous requirements (users never know what they *really* want).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*原型方法*试图克服这一限制。它有助于在开发过程中探索和评估实施，并细化未知或模糊的需求（用户永远不知道他们*真正*想要什么）。'
- en: The essence of the prototyping process is to create a number of throw-away prototypes
    of the software system. Each prototype is evaluated, shown to the customer, and
    customer feedback is used to shape the next prototype. This continues until enough
    is known to develop and deploy the real product.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 原型过程的本质是创建软件系统的多个可丢弃原型。每个原型都会被评估，展示给客户，并使用客户反馈来塑造下一个原型。这个过程会一直持续到对开发并部署真实产品有足够的了解。
- en: We see an analogy with other industries here. If you were developing a new car,
    you'd create many prototypes until you hit on exactly the right design. We aim
    to do the same with our software. However, there is an important difference that
    must be observed. When building a car, the major cost is in the manufacturing,
    not the development. It works the other way around with software. You can make
    multiple copies of the code for free; the development is the costly part. For
    this reason, the prototyping cycle needs to be controlled; it can't be repeated
    an unlimited number of times.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了与其他行业的类比。如果你在开发一款新车，你会创建许多原型，直到找到完全正确的设计。我们希望我们的软件也能做到这一点。然而，有一个重要的区别必须注意。在制造汽车时，主要成本在于制造，而不是开发。软件的情况正好相反。你可以免费制作代码的多个副本；开发才是成本高昂的部分。因此，原型周期需要得到控制；它不能无限次地重复。
- en: '**PROTOTYPE BLUES**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型之痛**'
- en: Releasing prototypes can cause severe maintenance problems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 发布原型可能会引起严重的维护问题。
- en: I did some work for a company that had a policy of only using one GUI library
    for its Java front ends. But in practice, it had some systems that used the library
    and some that didn't. Whenever a bug cropped up, the maintenance programmers had
    to jump through hoops to work out what the front end code was doing. They didn't
    understand the other GUI libraries, and often their fixes introduced yet more
    problems. The more this happened, the less respected the company's products became.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一家只有使用一个GUI库为其Java前端服务的公司工作过。但在实践中，它有一些系统使用了这个库，而有些则没有。每当出现错误时，维护程序员不得不跳过许多障碍来找出前端代码在做什么。他们不了解其他GUI库，而且他们经常引入更多的问题。这种情况发生得越多，公司的产品就越不受尊重。
- en: 'It didn''t take much software archeology to discover the cause of this problem:
    The front ends that didn''t use the correct GUI library had been prototypes that
    "accidentally" became products. A little time spent releasing correct code would
    have saved months of work later on and wouldn''t have destroyed the company''s
    reputation.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要进行太多的软件考古就能发现这个问题的原因：没有使用正确GUI库的前端已经变成了“意外”的产品。花点时间发布正确的代码，就可以节省后续数月的工作，而且不会破坏公司的声誉。
- en: 'The prototypes are developed quickly in very high-level languages. Sometimes
    they are simply drawn: The use of automated tool support^([[8](#ftn.CHP-22-FN-8)])
    can speed prototype production immensely. The prototypes are proofs-of-concept,
    so efficiency, stability, or a complete feature set are not primary concerns.
    For this reason, prototyping works best for systems with an emphasis on the user
    interface.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是用高级语言快速开发的。有时它们只是简单地绘制出来：使用自动化工具支持^([[8](#ftn.CHP-22-FN-8)])可以极大地加快原型生产。这些原型是概念验证，因此效率、稳定性或完整的功能集不是首要关注的问题。因此，原型设计最适合那些注重用户界面的系统。
- en: Prototypes help us to manage risk. We can use them to ensure that customers
    really do want what they *say* they want. We can also use prototypes to explore
    the use of a new technology or to check that our design decisions will stand up
    to real use.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 原型帮助我们管理风险。我们可以使用它们来确保客户确实想要他们所说的东西。我们还可以使用原型来探索新技术或检查我们的设计决策是否能经得起实际使用。
- en: The danger with prototyping is the temptation to continue developing the inefficient,
    quickly produced, not fully thought-out prototype code into a real release. This
    is especially true when a project is running out of time and the real development
    might not fit the schedule. Without education, customers will confuse the prototype
    with the finished product and be surprised that it takes a lot longer to receive
    their completed software. It needs very careful management to work. The best way
    to avoid this problem is to leave your prototypes deliberately rough around the
    edges, and to never get them near a releasable state. A prototype that has too
    much functionality is not a prototype!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计的危险在于继续开发低效、快速生产、没有充分考虑的原型代码，并将其开发成真正的发布版本。当项目时间紧迫，实际开发可能不符合进度时，这种情况尤其如此。没有教育，客户会混淆原型和最终产品，并惊讶于完成软件需要更长的时间。它需要非常谨慎的管理才能工作。避免这种问题的最好方法是故意让原型边缘粗糙，并且永远不要让它们接近可发布的状态。功能过多的原型不是原型！
- en: Iterative and Incremental Development
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代与增量开发
- en: All the recent advances on the waterfall approach are basically variations on
    a theme. The major improvement is performing development in an *iterative and
    incremental manner*. That is, many trips (iterations) around a small development
    life cycle run back to back (incrementally), with each cycle adding more and more
    functionality to the system until it is complete. Each single run of a mini lifecycle
    tends to follow the waterfall model and may last a number of weeks or months (depending
    on the scale of the project). Each phase of the waterfall therefore gets executed
    more than once. At each iteration end is a software release.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于瀑布方法最近的发展基本上都是主题的变体。主要的改进是以迭代和增量的方式进行开发。也就是说，许多次（迭代）围绕一个小型开发生命周期的连续运行（增量），每个周期都会向系统中添加更多和更多的功能，直到它完整。小型生命周期的每次运行通常遵循瀑布模型，可能持续几周或几个月（取决于项目的规模）。因此，瀑布的每个阶段都会执行多次。每个迭代的结束时都会有一个软件发布。
- en: Incremental development is neither a top-down nor a bottom-up approach. A complete
    version of the code is created for each code release, with all requisite high-
    and low-level components. During each iteration, the system grows, and subsequent
    design work can be done based on the existing design and implementation. There
    is a parallel to prototyping here, but we're not so focused on quick demonstrative
    hacks. With this approach each stage is less complex and easier to manage—and
    process progress is more easily monitored; you know how much of the system is
    built and integrated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 增量开发既不是自顶向下的方法，也不是自底向上的方法。每次代码发布都会创建一个完整的代码版本，包括所有必需的高层和底层组件。在每次迭代中，系统都会增长，后续的设计工作可以基于现有的设计和实现进行。这里与原型设计有相似之处，但我们并不专注于快速演示的快速破解。采用这种方法，每个阶段都更简单，更容易管理——并且进度更容易监控；你知道系统已经构建和集成了多少。
- en: 'This kind of process works well for projects whose requirements are less understood
    at the start. Let''s face it: That encompasses most projects in the Real World.
    It is more resilient to change, and it saves the lengthy redesign and reimplementation
    of the entire system that you''d encounter in the waterfall approach. Iterative
    and incremental development works well because it fits the fundamental nature
    of software development, it consequently helps us to better control the inherent
    chaos. Because iterative cycles are much shorter, there is greater opportunity
    for feedback and correction; you don''t have to wait until the end of your project
    to find out that it''s failing.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程对于在开始时对需求理解不充分的项目来说效果很好。让我们面对现实：这包括现实世界中大多数项目。它更能适应变化，并且可以节省在瀑布方法中会遇到的长篇大论的重设计和重实现。迭代和增量开发之所以有效，是因为它符合软件开发的基本性质，因此有助于我们更好地控制固有的混乱。由于迭代周期较短，有更多的机会进行反馈和纠正；你不必等到项目结束时才知道它失败了。
- en: Spiral Model
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 螺旋模型
- en: The *spiral model*, proposed by Barry Boehm in 1988 (Boehm 88), is a good example
    of the iterative and incremental approach.^([[9](#ftn.CHP-22-FN-9)]) The development
    process is modeled as a spiral, like [Figure 22-4](ch22s03.html#the_spiral_model
    "Figure 22-4. The spiral model"). It starts in the center and fans outward toward
    the later stages of the process. We start working on a very rough notion of the
    system, becoming more detailed over time, as we enter later stages of the spiral.
    Each 360-degree turn of the spiral sees us go through a single waterfall, and
    each iteration typically lasts six months to two years.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Barry Boehm于1988年提出的**螺旋模型**是迭代和增量方法的良好示例。[9](#ftn.CHP-22-FN-9) 开发过程被模拟为一个螺旋，就像[图22-4](ch22s03.html#the_spiral_model
    "图22-4. 螺旋模型")所示。它从中心开始，向外扩展到过程的后期阶段。我们开始对系统的非常粗略的概念进行工作，随着时间的推移变得越来越详细，当我们进入螺旋的后期阶段。螺旋的每个360度旋转都意味着我们经历了一次单一的水晶瀑布，并且每个迭代通常持续六个月到两年。
- en: Features are defined and implemented in order of decreasing priority; the most
    important facilities are created as soon as possible. This is a way of managing
    risk; it's safer because as you inch toward the ship date, you can be sure that
    the majority of the system is complete. In fact, it is very pragmatic approach;
    the programmers will not be spending 80 percent of their time on the trifling
    (but fun) 20 percent of the system.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 特性按优先级递减的顺序定义和实现；最重要的功能尽可能早地创建。这是一种管理风险的方法；它更安全，因为随着你接近交付日期，你可以确信大多数系统已经完成。实际上，这是一种非常务实的方法；程序员不会将80%的时间花在系统那20%的琐碎（但有趣）的部分上。
- en: '![The spiral model](tagoreillycom20080909nostarchimages207584.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![螺旋模型](tagoreillycom20080909nostarchimages207584.png)'
- en: '**Figure 22-4. The spiral model**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22-4. 螺旋模型**'
- en: 'Boehm splits the spiral into four quadrants or four distinct phases:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Boehm将螺旋分为四个象限或四个不同的阶段：
- en: '**Objective setting**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标设定**'
- en: Specific objectives for this phase are identified.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为此阶段确定具体目标。
- en: '**Risk assessment and reduction**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**风险评估和降低**'
- en: The key risks are identified and analyzed, and information is sought to reduce
    these risks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 确定并分析关键风险，并寻求信息以降低这些风险。
- en: '**Development and validation**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发和验证**'
- en: An appropriate model is chosen for next phase of development.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为下一阶段开发选择一个合适的模型。
- en: '**Planning**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**规划**'
- en: The project is reviewed, and plans are drawn up for the next round of the spiral.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 项目被审查，并为螺旋模型的下一轮制定计划。
- en: Agile Methodologies
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷方法论
- en: These were developed as a backlash against the bureaucratic and heavyweight
    methodologies that tried to straitjacket the software development process. Agile
    practitioners observed that software development cannot easily be made a predictable
    process; they claim that it is *very* different from the established engineering
    procedures, like constructing a bridge.^([[10](#ftn.CHP-22-FN-10)]) The old-fashioned,
    monumental methodologies only serve to get in the way of people trying to write
    good software, and so they should be thrown away.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法论是在对官僚主义和重量级方法论的反动中发展起来的，这些方法论试图将软件开发过程束缚起来。敏捷实践者观察到软件开发难以被转化为一个可预测的过程；他们声称这与既定的工程程序，如建造桥梁，**非常不同**。[10](#ftn.CHP-22-FN-10)
    过时的、宏伟的方法论只会妨碍人们编写好的软件，因此它们应该被摒弃。
- en: '*Agile methodology* is an umbrella term that describes a number of development
    processes, including the much-hyped Extreme Programming, as well as Crystal Clear
    and Scrum. Agile processes focus on nimbleness and risk reduction rather than
    on long-term planning or forcing (pretending to have) predictability.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷方法论**是一个总称，描述了包括备受瞩目的极限编程、Crystal Clear和Scrum在内的许多开发过程。敏捷过程侧重于灵活性和风险降低，而不是长期规划或强制（假装有）可预测性。'
- en: 'Agile processes share these central tenets:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷过程共享以下核心原则：
- en: Minimize risk by performing many small iterative development cycles. The software
    and all process artifacts are complete, consistent, and of releasable quality
    at the end of each cycle. Although the software seldom *is* released, it can be
    passed on to the customer to review and to comment on. This gives the customer
    reassurance of the team's progress.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过执行许多小的迭代开发周期来最小化风险。在每个周期结束时，软件和所有过程工件都是完整、一致且可发布的质量。尽管软件很少**真正**发布，但它可以被传递给客户进行审查和评论。这给客户提供了团队进展的保证。
- en: Agile process iterations tend to be much smaller than iterative and incremental
    process loops (typically lasting a number of weeks, rather than months).
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 敏捷过程迭代通常比迭代和增量过程循环要小得多（通常持续几周，而不是几个月）。
- en: Minimize risk by placing far more emphasis on a suite of automated regression
    tests that are run continually, rather than on a lengthy test cycle at the end
    of development.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在开发结束时进行漫长的测试周期，而不是更加强调一套持续运行的自动化回归测试，来最小化风险。
- en: Reduce the documentation that plagues heavyweight processes. Agile processes
    view the code itself as the design and as the implementation documentation. Good
    code stands on its own and doesn't need to be lumbered with bureaucratic documentation
    processes.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少那些困扰着重量级过程的文档。敏捷过程将代码本身视为设计和实现文档。好的代码可以自给自足，不需要被官僚主义的文档流程所拖累。
- en: Emphasize people and aim to facilitate communication, preferably face-to-face
    rather than through documents. This keeps the customer (or a customer representative)
    as close to the development team as possible, to take part in implementation and
    prioritization decisions.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调人员，并努力促进沟通，最好是面对面而不是通过文档。这样可以使客户（或客户代表）尽可能接近开发团队，以便参与实施和优先级决策。
- en: Consider *working software* as the measure of progress and performance, not
    specification writing or a manager's opinion of the team's position in a fictitious
    development cycle. The developers meet problems and respond to changes by modifying
    the code as development progresses.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将*工作软件*视为衡量进度和性能的标准，而不是规格编写或管理者对团队在虚构的开发周期中位置的看法。开发者会在开发过程中遇到问题，并通过修改代码来应对变化。
- en: The agile approach is not always appropriate. It tends to work best on smaller
    projects, with teams of less than 10 high-quality programmers who are geographically
    co-located. Agile processes excel in domains with a high degree of requirements
    change. They are hard to run in companies with a heavy process culture.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法并不总是适用。它最适合于较小的项目，拥有不到10名地理上集中在一起的高质量程序员的小团队。敏捷过程在需求变化程度高的领域表现卓越。在具有重过程文化的公司中很难运行。
- en: Other Development Processes
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他开发过程
- en: 'There are many other development processes: variations on these themes, each
    with its own distinct features. There are modified waterfall processes that overlap
    certain phases or contain subprojects, managed as mini-waterfalls. The *evolutionary
    prototyping* approach starts with an initial concept, designs and implements a
    prototype, iteratively refines the prototype until it is acceptable, and then
    releases this, perhaps planning to include some throw away prototypes in the process.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多其他开发过程：这些主题的变体，每个都有其独特的特点。有修改后的瀑布流程，它重叠某些阶段或包含子项目，作为迷你瀑布进行管理。*进化原型*方法从初始概念开始，设计和实现一个原型，迭代地改进原型，直到它被接受，然后发布这个原型，也许计划在过程中包括一些可丢弃的原型。
- en: '*Staged delivery* follows a sequential process up to architectural design and
    then implements the separate components showing them to the customer as each is
    completed, going back to previous development steps if needed. *Evolutionary delivery*
    is essentially a cross between evolutionary prototyping and staged delivery.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*分阶段交付*遵循一个顺序过程，直到架构设计，然后实现单独的组件，在完成每个组件时向客户展示，如果需要，返回到之前的发展步骤。*进化交付*基本上是进化原型和分阶段交付之间的结合。'
- en: Rapid Application Development (RAD) emphasizes user involvement and small development
    teams, and it makes heavy use of prototyping and automated tools. In a slight
    twist on other processes, the development time frame is established up front and
    considered immovable. Then as many features as feasible are incorporated into
    the design to accommodate the deadline—some features may be sacrificed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 快速应用开发（RAD）强调用户参与和小的开发团队，并且大量使用原型和自动化工具。与其他流程略有不同，开发时间表在前期确定，并被认为是不可移动的。然后尽可能地将尽可能多的功能纳入设计，以适应截止日期——某些功能可能需要牺牲。
- en: The *Rational Unified Process (RUP)* is a notable commercial methodology that
    stems from Ivar Jacobson's 1987 *Objectory Process*. It's a heavyweight but flexible
    object-oriented process that leans heavily on UML diagrams, with *use case-driven
    design* (a use case describes a single user activity or interaction with the software
    system). It favors iterative development, continuous testing, and careful change
    management. As a commercial process, it is supported by a suite of commercial
    tools.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*理性统一过程（RUP）* 是一种著名的商业方法论，源于Ivar Jacobson的1987年 *Objectory Process*。它是一个重量级但灵活的面向对象过程，高度依赖于UML图，具有
    *用例驱动设计*（一个用例描述单个用户活动或与软件系统的交互）。它倾向于迭代开发、持续测试和细致的变化管理。作为一个商业过程，它由一系列商业工具支持。'
- en: '* * *'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[5](#CHP-22-FN-5)]) And there, perhaps, it doesn't matter so much, since
    there's no paying customer and no formal set of requirements—a lot of open source
    software is developed because the programmer feels like it. However, applying
    some development process to ad hoc open source work will almost certainly yield
    better programs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-22-FN-5)]) 在那里，也许这并不那么重要，因为没有付费客户和正式的需求集——许多开源软件的开发是因为程序员想要这样做。然而，将一些开发过程应用于临时性的开源工作几乎肯定会产生更好的程序。
- en: ^([[6](#CHP-22-FN-6)]) This is a common simplicifcation of Royce's original
    paper. Royce *did* allow feedback up the waterfall, but didn't actively encourage
    it. Zealous managers imagined software development to be a strictly linear process,
    and soon removed these upstream paths; the waterfall was tarnished.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-22-FN-6)]) 这是对罗伊斯原始论文的一种常见简化。罗伊斯 *确实* 允许在瀑布中向上反馈，但并没有积极鼓励这样做。热情的管理者认为软件开发是一个严格的线性过程，很快就去掉了这些上游路径；瀑布被玷污了。
- en: ^([[7](#CHP-22-FN-7)]) Note how development flows downward, like the waterfall,
    but testing is seen as an uphill effort—a reasonably accurate model of software
    development!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-22-FN-7)]) 注意开发流程是如何向下流动的，就像瀑布一样，但测试被视为一项向上的努力——这是软件开发的一个相当准确的模型！
- en: ^([[8](#CHP-22-FN-8)]) For example, *Rapid Application Development (RAD)* tools
    with simple GUI builders.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-22-FN-8)]) 例如，具有简单GUI构建器的 *快速应用开发（RAD）* 工具。
- en: ^([[9](#CHP-22-FN-9)]) Boehm's process wasn't the first iterative model, but
    he was the first to popularize and emphasize the importance of iteration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#CHP-22-FN-9)]) 伯姆的过程并不是第一个迭代模型，但他是最先推广并强调迭代重要性的。
- en: '^([[10](#CHP-22-FN-10)]) This is a religious debate: Many programmers believe
    that it *is* possible to make the software development process a repeatable, predictable
    thing, but the industry is currently not mature or disciplined enough to do so.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-22-FN-10)]) 这是一个宗教般的辩论：许多程序员认为 *确实* 可以使软件开发过程变得可重复、可预测，但行业目前还不够成熟或不够自律来实现这一点。
- en: Enough, Already!
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已经足够了！
- en: If you've read this far and haven't gotten bored yet, then you're doing well.
    Finally, and perhaps more importantly, what are the key points to draw from all
    this? A software craftsman has a good working understanding of development processes
    and programming styles, but anyone can get this from the right books. How do we
    apply this stuff usefully to our work? How can it improve our skill set?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读到这儿还没有感到厌烦，那么你做得很好。最后，也许更重要的是，我们能从所有这些中提取哪些关键点？一个软件工匠对开发过程和编程风格有良好的工作理解，但任何人都可以从正确的书籍中获得这些知识。我们如何将这些知识有用地应用到我们的工作中？它如何提高我们的技能集？
- en: All of these processes share some common threads. The phases described in "[STAGES
    OF DEVELOPMENT](ch22s03.html#stages_of_development "STAGES OF DEVELOPMENT")" on
    page 428 are present in each. The processes really only differ in the length and
    relative positioning of these stages. Each activity is vital to the production
    of good-quality software. The better processes ensure that testing is not left
    as an afterthought, but is carried out continuously—and monitored—throughout the
    development process.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些过程都存在一些共同点。第428页上描述的 "[开发阶段](ch22s03.html#stages_of_development "开发阶段")"
    在每个过程中都存在。这些过程真正不同的是这些阶段的长度和相对位置。每个活动对于生产高质量的软件都是至关重要的。更好的过程确保测试不会被当作事后考虑，而是在整个开发过程中持续进行并得到监控。
- en: It's hard to compare or evaluate the different processes and programming styles.
    Which is best? Which will ensure that a high-quality product is shipped on time
    and to budget? There is no answer, because those are not the right questions.
    Which process is suitable depends on the nature of the project and the culture
    of your company. If you have 20 programmers who know nothing of object-oriented
    development and only ever use C, then trying to build an OO Java product is clearly
    a stupid idea.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 比较或评估不同的流程和编程风格是件困难的事情。哪一种最好？哪一种能确保按时且在预算内交付高质量的产品？没有答案，因为这些问题本身就不正确。适合的流程取决于项目的性质和公司的文化。如果你有20个程序员，他们对面向对象开发一无所知，而且只使用C语言，那么试图构建一个面向对象的Java产品显然是个愚蠢的想法。
- en: '**KEY CONCEPT**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*You''ll pick a software recipe for a number of reasons—make sure they''re
    good ones. The motivation for your choice of process says a lot about the maturity
    of your organization*.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*你选择软件配方的原因有很多——确保它们是好的。你对流程选择动机的说明在很大程度上反映了你组织的成熟度*。'
- en: 'We can see two procedural extremes: The anarchy of the ad hoc method contrasts
    with the strict regime of a rigid process. In the latter, any experimentation
    that could yield a more elegant architecture is discouraged. The user''s real
    requirements may never filter down to a developer since it''s lost in a sea of
    bureaucracy; the programmer just codes to a specification that''s passed on to
    him from the previous process phase.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两种流程的极端：临时方法的混乱与严格流程的严格制度形成对比。在后一种情况下，任何可能产生更优雅架构的实验都被禁止。用户的真实需求可能永远不会过滤到开发者那里，因为它们迷失在官僚主义的海洋中；程序员只是根据从上一个流程阶段传来的规格进行编码。
- en: Following the *Goldilocks prinicple*, the most flexible approach is somewhere
    in between. You *do* need to know the process you're working to and where it's
    defined. Effective development requires discipline; you need a coherent strategy
    to get something out of the door on time (having a realistic schedule is another
    topic in its own right—see "[The Planning Game](ch21s05.html "The Planning Game")"
    on page 409). Experienced programmers know the value of their development processes,
    as well as the faults. They know how to work with it and when to step outside
    it. Good programmers don't just program. They understand their recipes and how
    to adapt them as appropriate. This is why our science is still a craft.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 按照*金发姑娘原则*，最灵活的方法通常介于两者之间。你需要*知道*你正在遵循的流程以及它在哪定义。有效的开发需要纪律；你需要一个连贯的策略来确保按时交付产品（拥有一个现实的进度表也是另一个话题——参见第409页的"[规划游戏](ch21s05.html
    "The Planning Game")"）。经验丰富的程序员知道他们开发流程的价值，以及其中的缺陷。他们知道如何与之合作，何时跳出框架。优秀的程序员不仅仅是编程。他们理解他们的方法，并知道如何根据适当的情况进行适应。这就是我们的科学仍然是一门手艺的原因。
- en: It's important not to be uptight and legalistic about the process you follow,
    but you must have an agreed framework for producing software. It must be appropriate
    for your development team—not every organization needs a high-ceremony process
    with many hoops and hurdles to navigate and lengthy forms to fill in.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要对遵循的流程过于紧张和教条，但你必须有一个达成共识的软件生产框架。它必须适合你的开发团队——并不是每个组织都需要一个仪式感强、有许多圈套和障碍需要克服、以及需要填写冗长表格的高仪式流程。
- en: '**KEY CONCEPT**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*The process you adopt doesn''t have to be high-ceremony and hard to follow.
    In fact, the exact opposite characteristics are generally hallmarks of a good
    process. You must have a defined process, though*.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*你采用的流程不必是仪式感强且难以遵循的。事实上，相反的特征通常是良好流程的标志。尽管如此，你必须有一个定义明确的流程*。'
- en: New methodologies spring up (or rather evolve) from time to time. They tend
    to arrive with a big fanfare and a spurt of fireworks; they're claimed to be the
    silver bullet, the panacea that will make development better for our children
    and our children's children. Sadly, it's never the case. When it comes down to
    it, no matter which life cycle you follow, the programming team is only as good
    as its programmers. If there is no intuition, no flair, no experience, and no
    motivation present then, regardless of the development process you use, you won't
    reliably produce good code. You might be better able to track how far behind schedule
    you are, though.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法论时不时地出现（或者更确切地说，是演变）。它们往往伴随着巨大的宣传和烟花般的炒作；它们被宣称为银弹，是万应良药，将使我们的后代和孙后代的发展变得更好。遗憾的是，情况并非如此。归根结底，无论遵循哪种生命周期，编程团队的质量仅取决于其程序员。如果没有直觉、没有灵感、没有经验和没有动力，那么，无论使用哪种开发过程，你都无法可靠地编写出高质量的代码。你可能会更好地跟踪进度落后多少。
- en: Pick a Process
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个过程
- en: Many factors contribute to a good choice of development process. However, the
    choice is seldom made on sensible grounds; a development process is used because
    *It's the way we always do it*, *It works well enough*, or *It was the first thing
    we could think of*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 许多因素有助于选择合适的开发过程。然而，选择很少基于合理的理由；使用开发过程是因为*这是我们一贯的做法*，*它足够有效*，或者*它是我们能想到的第一件事*。
- en: How do you know what development method is appropriate? Ultimately, if the process
    works for your team—if you collaborate well and produce good software on time—then
    you have a good development approach.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道哪种开发方法适合？最终，如果这个过程对你的团队有效——如果你能很好地协作并在规定时间内交付高质量的软件——那么你就有了一个好的开发方法。
- en: A good choice of process is based on the type and size of the project. Small
    modifications to an existing codebase don't need a large iterative development
    cycle; three-year industrial projects starting from scratch probably do. A good
    process choice suits the experience of the existing team members, has the developers
    willing (even eager) to use it, and is something that the project manager really
    understands.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的过程取决于项目的类型和规模。对现有代码库的小修改不需要大型的迭代开发周期；从零开始的三年工业项目可能需要。好的过程选择适合现有团队成员的经验，让开发者愿意（甚至渴望）使用它，并且是项目经理真正理解的东西。
- en: On the flip side, there are plenty of bad reasons to choose a development process.
    There's no point in moving to a new process just because you feel like a change;
    a new process must be introduced to fix a problem with the current development
    model. There's no point in trying to make a political statement (I know people
    who've tried to foster an open development culture, just to swing the organization
    toward open sourcing their internal codebase). The ultimate bad motivation for
    picking a particular process is fashion. More buzzwords do not necessarily mean
    a more useful process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，选择开发过程有许多不良的理由。仅仅因为想要改变而转向新的过程是没有意义的；新的过程必须引入以解决当前开发模型中的问题。试图做出政治声明（我知道有些人试图培养开放的开发文化，只是为了推动组织开源其内部代码库）也是没有意义的。选择特定过程的最终不良动机是时尚。更多的
    buzzwords 并不一定意味着更有效的过程。
- en: 'This *is* important: An inappropriate process really can ruin the quality of
    your code; you''ll spend more time pandering to the demands of a procedural straitjacket
    than delivering software. A good process does not get in your way. Indeed, it
    enables your team to create more software, better and faster.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这*确实*很重要：不合适的过程真的会破坏代码的质量；你将花费更多的时间去迎合程序化紧身衣的需求，而不是交付软件。一个好的过程不会妨碍你。实际上，它使你的团队能够更快、更好地创建更多软件。
- en: '**KEY CONCEPT**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Process is vital. Most projects fail for nontechnical reasons. And bad process
    is almost always high on the list of reasons*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*过程至关重要。大多数项目失败的原因是非技术性的。而且，不良的过程几乎总是原因列表中的首要因素*。'
- en: In a Nutshell
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: 'Building software is like crime: It''s better when it''s organized. Every now
    and again, an undisciplined team will pull off something spectacular and create
    a software masterpiece. However, that *is* the exception. The development process
    needs to be defined and understood and carried out by team members with appropriate
    skills to stand a chance of working well. Otherwise, you''ll end up with software
    that''s criminal.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 构建软件就像犯罪：有组织的时候会更好。偶尔，一个无纪律的团队会完成一些惊人的事情，创造出软件杰作。然而，那*确实是例外*。开发过程需要被定义、理解，并由具备适当技能的团队成员执行，才有机会有效工作。否则，你最终会得到一个像犯罪一样的软件。
- en: We need to use proven development processes and established design styles to
    allow us to build software that meets expectations against a backdrop of timescales,
    budgets, and changing requirements. Building software is hard—and we've just looked
    at another way to make it easier.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用经过验证的开发过程和建立的设计风格，以便我们能够在时间表、预算和不断变化的需求背景下构建满足预期的软件。构建软件是困难的——我们刚刚看到了另一种使其更容易的方法。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的程序员... | 编程不好的程序员... |'
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand the programming style and development process they are expected to
    work within
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解他们预期工作的编程风格和开发过程
- en: Exploit their development process to shape interactions with other software
    factory inhabitants; when the process becomes constraining, they'll sidestep it
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用他们的开发过程来塑造与其他软件工厂居民的互动；当过程变得限制性时，他们会规避它
- en: Appreciate the pros and cons of different development recipes and can pick the
    appropriate one for any given situation
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估不同开发方案的优缺点，并能够为任何特定情况选择合适的方案
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Ignore development process issues, and attempt to do things their own way
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略开发过程问题，试图以自己的方式做事
- en: Do not know how the process shapes their interaction with other developers
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不知道过程如何塑造他们与其他开发者的互动
- en: Avoid thinking about this kind of stuff—*it's for managers to worry about*
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免思考这类事情——*这是经理们需要担心的事情*
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 测试时代")'
- en: Testing is a key phase of the development process. Often the pressures of Real
    World deadlines try to squeeze out room for it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是开发过程中的关键阶段。通常，现实世界截止日期的压力试图挤压出它的空间。
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](ch17.html "第17章. 站在一起")'
- en: 'Teamwork: the cornerstone of large scale software development.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 团队合作：大规模软件开发的基础。
- en: '[Chapter 19](ch19.html "Chapter 19. BEING SPECIFIC")'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章. 专门化")'
- en: Specifications are often the gates between phases of the development process.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 规范通常是开发过程各个阶段之间的门槛。
- en: '![See Also](tagoreillycom20080909nostarchimages207586.png.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![相关内容](tagoreillycom20080909nostarchimages207586.png.jpg)'
- en: Get Thinking
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 553.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些问题的详细讨论可以在第553页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: How do the choices of programming style and development process influence one
    another?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程风格和开发过程的选择如何相互影响？
- en: Which is the best programming style?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种编程风格是最好的？
- en: Which is the best development process?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种开发过程是最好的？
- en: Where does each development process listed in this chapter fall on the classification
    axes we saw in "[Development Processes](ch22s03.html "Development Processes")"
    on page 425?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章中列出的每个开发过程在"[开发过程](ch22s03.html "开发过程")"第425页中我们看到的分类轴上处于什么位置？
- en: If development processes and programming styles are recipes, what would a software
    development cookbook look like?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果开发过程和编程风格是配方，那么软件开发食谱会是什么样的？
- en: With a suitable process, can software construction become a predictable, repeatable
    task?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用合适的过程，软件构建能否变成一个可预测、可重复的任务？
- en: Getting Personal
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: What development process and programming language style are you currently using?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你目前使用的是哪种开发过程和编程语言风格？
- en: Has it been formally agreed upon by the development team, or do you use it by
    convention?
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否已经由开发团队正式同意，或者你是按照惯例使用它？
- en: How was it chosen? Was it chosen specifically for this project, or is it the
    recipe you always use?
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是如何被选择的？是专门为这个项目选择的，还是你总是使用的配方？
- en: Is it documented anywhere?
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否被记录在某个地方？
- en: Does the team stick to the process? When problems arise and your back is against
    the wall, do you maintain the process, or is all ivory tower theory ignored in
    a rush to produce something—anything?
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 团队是否坚持流程？当问题出现，你背靠墙壁时，你是否维持流程，还是在匆忙中忽视所有象牙塔理论，只为了生产出一些东西——任何东西？
- en: Are your current processes and styles appropriate? Are they the best way for
    you to develop your software right now?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你当前的过程和风格是否合适？这是你现在开发软件的最佳方式吗？
- en: Does your organization appreciate that there are other development models that
    might be worth investigating?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的组织是否意识到还有其他可能值得调查的开发模型？
- en: Chapter 23. THE OUTER LIMITS
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章。外延
- en: '*The Different Programming Disciplines*'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*不同的编程学科*'
- en: Everything that irritates us about others can lead us to an understanding of
    ourselves.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对他人感到的一切烦恼都可以引导我们了解自己。
- en: --Carl Jung
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: --卡尔·荣格
- en: I like sweeping generalizations and tenuous metaphors. Sue me. I've also been
    doing my research. I found that there are over 40 churches in the city I live
    in. Each one of these is subtly different; different types of people attend, and
    they do different things. They have different concerns and ways of working. They're
    located in different areas. However, they're all doing roughly the same thing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢广泛的概括和脆弱的隐喻。起诉我吧。我还在做我的研究。我发现我居住的城市有40多个教堂。每个教堂都有细微的差别；不同类型的人参加，他们做不同的事情。他们有不同的关注点和工作方式。他们位于不同的地区。然而，他们都在做大致相同的事情。
- en: '*What on earth has this got to do with programming?* I hear you ask. If you
    forgive the tenuous link, software development works in pretty much the same way.
    Okay, we don''t all file into a building every Sunday morning (well, most of us
    don''t). But, to outsiders, we do appear to engage in bizarre rituals and invoke
    arcane rites to get our own way with things that are out of the control of normal
    human beings.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*这究竟与编程有什么关系？* 你可能会问。如果你原谅这种脆弱的联系，软件开发基本上是以相同的方式进行。好吧，我们不是每个星期天早上都走进一栋大楼（嗯，我们中的大多数人不是）。但是，对于局外人来说，我们似乎在进行一些奇怪的仪式，召唤一些神秘的仪式来控制那些超出正常人类控制范围的事物。'
- en: The real comparison I draw, though, is that there is no single way to program,
    no one methodology that solves every problem. There is no one programming language.
    There are different classes of problems to be solved in many, many different arenas.
    The work in each differs by more than mere technology (i.e., which tools and code
    libraries are available); they differ by technique. Each requires a different
    skill set, a particular mindset, and subtly different ways of working. The differences
    might seem slight, but there is no replacement for specific experience of programming
    a particular type of system—if there was, job advertisements for programmers would
    be a lot more vague. It's important to know your field well and to appreciate
    its unique concerns. In a particular programming arena, the craftsman knows how
    to ply his trade, how to work his medium, and how to best use his tools.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我真正得出的结论是，没有一种编程方式，没有一种解决所有问题的单一方法。没有一种编程语言。有许多不同领域的问题需要解决，涉及许多不同的领域。每个领域的工作都不仅仅取决于技术（即哪些工具和代码库可用）；它们还取决于技术。每个领域都需要不同的技能集，特定的思维方式，以及微妙不同的工作方式。这些差异可能看起来很小，但如果没有特定类型系统的编程经验，就无法替代——如果有，程序员的招聘广告将会更加模糊。了解你的领域并欣赏其独特的关注点非常重要。在特定的编程领域中，工匠知道如何运用他的技艺，如何处理他的媒介，以及如何最好地使用他的工具。
- en: '**KEY CONCEPT**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*There are various types of programming, in different problem domains. Each
    presents its own unique problems and requires specific skills and experience*.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程有多种类型，涉及不同的问题领域。每种类型都提出了其独特的问题，并需要特定的技能和经验*。'
- en: In this chapter, we'll explore this. We'll take a guided tour of the vast field
    that is computer programming, discover some of the common problem domains we program
    in, see how they differ, and learn the particular problems and challenges of each.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这一点。我们将对计算机编程这个广阔的领域进行一次有指导性的游览，发现我们编程的一些常见问题领域，了解它们之间的差异，并学习每个领域的特定问题和挑战。
- en: Some of these arenas overlap. That's natural. Nothing is ever quite as clear-cut
    as you'd imagine. The following descriptions are necessarily general, since each
    of these is a big field with lots of variations within. Nonetheless, this should
    give you a taste of what's going on out there.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些领域中有一些是重叠的。这是自然的。没有什么事情会像你想象的那样清晰。以下描述必然是概括性的，因为每个领域都是一个很大的领域，其中有很多变化。尽管如此，这应该能让你对那里发生的事情有一个大致的了解。
- en: Applications Programming
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序编程
- en: This is what most non-techies think of when you mention the word *programming*.^([[1](#ftn.CHP-23-FN-1)])
    It's probably the broadest category we'll consider in this chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提到“编程”这个词时，大多数非技术人员会想到这个。这可能是我们在本章中考虑的最广泛的类别。
- en: It is programming *applications*—self-contained programs—typically for single-user,
    workstation-like computers. This world focuses on end users and how they use their
    desktop machines. For commercial reasons, we usually target the mainstream platforms—currently
    Windows and Mac OS. Although you hear a lot about Linux programming these days,
    that's still not where the applications work is (at least, at the time of writing).
    As portable devices become more powerful and their application development environments
    become richer, mobile applications work has moved from the embedded realm (see
    "[Embedded Programming](ch23s04.html "Embedded Programming")" on page 447) into
    this class of more general-purpose applications programming; the specific embedded
    hurdles have largely been removed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指编程**应用程序**——独立的程序——通常用于单用户、工作站式计算机。这个世界关注的是最终用户以及他们如何使用他们的桌面机器。出于商业原因，我们通常针对主流平台——目前是Windows和Mac
    OS。尽管现在你经常听到关于Linux编程的消息，但这仍然不是应用程序工作的领域（至少，在写作的时候是这样）。随着便携式设备的变得更加强大，它们的应用程序开发环境变得更加丰富，移动应用程序工作已经从嵌入式领域（参见第447页的“嵌入式编程”（[Embedded
    Programming](ch23s04.html "Embedded Programming")））转移到这一类更通用的应用程序编程；具体的嵌入式障碍在很大程度上已经被消除。
- en: There are many languages and environments for this kind of work; C and C++ are
    common. We also see common use of Visual Basic and Delphi, Java, and .NET, plus
    a number of libraries and frameworks like MFC and Qt. This choice is made according
    to what is convenient for the developers—something that's well-enough known and
    provides all required features.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于这种工作的语言和环境；C和C++很常见。我们还看到Visual Basic和Delphi、Java和.NET的普遍使用，以及MFC和Qt等许多库和框架。这种选择是根据开发者的便利性来决定的——一些足够为人所知并提供所有必需的功能。
- en: Modern applications programming has advanced rapidly since the dawn of personal
    computing. We now have rich development environments to work in with helpful framework
    code that automates a lot of tedious boilerplate stuff. We have threading support,
    libraries of standard user interface components, and facilities for network transparency.
    There is a lot of operating system support provided to make applications programming
    easier, but this also means that there's a lot to learn as you get started. You
    have to know a lot to *really* understand what's going on around you.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 自从个人计算机时代开始以来，现代应用程序编程已经迅速发展。我们现在拥有丰富的开发环境，可以工作在其中，并带有有助于自动执行大量繁琐模板代码的框架代码。我们有线程支持、标准用户界面组件库和网络透明度设施。为了使应用程序编程更容易，操作系统提供了大量的支持，但这同时也意味着在开始时有很多东西需要学习。你必须知道很多，才能真正理解你周围发生的事情。
- en: All this extra support raises the bar to determine what a good application is.
    What was acceptable application behavior years ago is not today. People expect
    high-quality, robust programs, with a standard interface and look-and-feel, good
    responsiveness, user-friendliness (the ability to cope with the most inept user),
    and a plethora of features (even if the user will only take advantage of a fraction
    of them). The huge professional applications marketed today are the results of
    large development teams with departments specifically focusing on usability issues.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些额外的支持提高了衡量一个好的应用程序的标准。几年前可以接受的应用程序行为现在不再适用。人们期望高质量的、健壮的程序，具有标准界面和外观，良好的响应性，用户友好性（能够应对最无能的用户），以及丰富的功能（即使用户只会利用其中的一小部分）。今天市场上销售的庞大专业应用程序是大型开发团队的结果，这些团队专门关注可用性问题。
- en: We are seeing a move toward web-based systems, applications that run on browsers,
    over a network. We'll look at them separately; this also cuts into the enterprise
    or distributed programming arenas somewhat (see "[Distributed Programming](ch23s05.html
    "Distributed Programming")" on page 450).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在看到向基于网络的系统转变，这些系统在浏览器上运行，通过网络。我们将单独研究它们；这也多少影响了企业或分布式编程领域（参见第 450 页的 "[分布式编程](ch23s05.html
    "Distributed Programming")"）。
- en: 'There are two main markets for applications programming: shrink-wrap software
    and custom applications.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程有两个主要市场：shrink-wrap 软件和定制应用程序。
- en: Shrink-Wrap Software
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shrink-wrap 软件
- en: 'Shrink-wrap software is developed for the mass market. It''s used by a large
    number of people, or at least that''s what the marketing departments are praying
    for. This is key: The market is speculative, so the software has to appeal to
    the broadest cross-section of consumers possible in order to make money. Since
    no customer commissions or pays for the development of shrink-wrap software, you
    must establish a profitable market before you begin work, or else you''re throwing
    away time and effort. The software needs to differentiate itself from competing
    products in terms of features, performance, or a unique approach to the problem.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: shrink-wrap 软件是为大众市场开发的。它被大量的人使用，或者至少市场营销部门是这样祈祷的。这是关键：市场是投机性的，因此软件必须吸引尽可能广泛的消费者群体以赚钱。由于没有客户委托或支付
    shrink-wrap 软件的开发，你必须在开始工作之前建立一个有利可图的市场，否则你就是在浪费时间和精力。软件需要在功能、性能或对问题的独特方法上与竞争产品区分开来。
- en: Shrink-wrap software might be bought over the counter in a box neatly wrapped
    in cellophane (hence the name), or it could be downloaded from the Internet. It
    could even be a subscription-based web service. The key point is the way you sell
    it and how that forces you to develop it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: shrink-wrap 软件可能被作为盒装产品在柜台上购买，这些盒子被透明纸包裹得整整齐齐（因此得名），或者可以从互联网上下载。它甚至可能是一个基于订阅的在线服务。关键点是你如何销售它以及这如何迫使你开发它。
- en: 'Life is hard for shrink-wrap applications programmers. You can''t control the
    environment the code runs in. It must gracefully handle all versions of the operating
    system, on different machine configurations, with different libraries and other
    apps installed, and it has to cope reliably with them all. That''s a testing nightmare!
    Web applications programmers win half the battle (as we''ll see later)—you have
    control over the server deployment. But you still have the headache of browser
    compatibility to contend with: Your web pages must render correctly on a wide
    range of target platforms.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 shrink-wrap 应用程序程序员来说，生活是艰难的。你无法控制代码运行的环境。它必须优雅地处理操作系统的所有版本，在不同的机器配置上，安装了不同的库和其他应用程序，并且必须可靠地应对它们。这是一场测试噩梦！Web
    应用程序程序员赢得了一半的战斗（我们稍后会看到）——你可以控制服务器部署。但你仍然需要应对浏览器兼容性的头疼问题：你的网页必须在广泛的平台目标上正确渲染。
- en: Custom Applications
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制应用程序
- en: Custom applications are made-to-order—developed to a specific brief for a specific
    customer. Therefore, the focus isn't so much on an inviting UI, a never-ending
    feature list, or even to get it perfect and bug free. There's no commercial imperative
    to do this. Get it working. Get it shipped. Get the cash. This is a more certain
    business model.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 定制应用程序是根据特定客户的具体需求定制的——为特定客户开发。因此，重点不是那么多的吸引人的用户界面，一个永无止境的功能列表，甚至是为了使其完美无瑕且无错误。没有商业上的必要性去做这些。让它工作。让它发货。让它带来现金。这是一个更确定的商业模式。
- en: Since a customer commissions this work, it will use this software or use nothing.
    With no real competition, the software only needs to be good *enough*. Given half
    a chance, programmers will keep tinkering and improving their code until it reaches
    some mythical state of perfection. But in this situation, it doesn't make commercial
    sense to do so. It doesn't really matter if the program works fine, but crashes
    once a week; it costs less to restart it periodically than to engage in a lengthy
    bug hunt (assuming that it doesn't trash any data as it goes down).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户委托这项工作，他们将使用这个软件或者什么都不用。在没有真正竞争的情况下，软件只需要“足够好”。如果给程序员一半的机会，他们会不断调整和改进他们的代码，直到它达到某种神话般的完美状态。但在这个情况下，这样做从商业角度来说并不合理。程序是否运行良好并不重要，但每周崩溃一次；定期重新启动它比进行漫长的错误搜索成本低（假设它不会在崩溃时破坏任何数据）。
- en: '**THE RUNDOWN**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Application work is fun. Modern PCs are powerful, so you don't have to worry
    too much about code size or performance, and you can concentrate on writing neat,
    elegant code. It's a buzz to know your application is used by tens of thousands
    of people around the world. —Steve (applications programmer for a major company)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序工作很有趣。现代个人电脑功能强大，因此你不必太担心代码大小或性能，你可以专注于编写整洁、优雅的代码。知道你的应用程序被全世界成千上万的人使用是一种兴奋的感觉。
    ——Steve（一家大公司的应用程序程序员）
- en: '**Typical products**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: Typical shrink-wrap products are desktop applications like web browsers, spreadsheets,
    and so on. Custom software could be anything—a highly tailored inventory management
    system for a large retailer, for example.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 shrink-wrap 产品是桌面应用程序，如网络浏览器、电子表格等。定制软件可以是任何东西——例如，为大型零售商量身定制的库存管理系统。
- en: '**Target platform**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: This tends to be the same kind of machine you are doing the development on (more
    often than not, an x86 Windows PC).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是你进行开发的那种机器（大多数情况下，是一个 x86 Windows PC）。
- en: '**Development environment**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: 'You''ll normally build code on the same workstation you run the program on.
    Modern *integrated development environments* (*IDEs*) provide comfortable working
    environments, bringing the editor, compiler, debugger, and help systems together
    in a single unified point-and-click interface. Many third-party components are
    available to simplify the development of common tasks. The full gamut of lan-guages
    is employed here: from low-level C/C++, through BASIC and Java, to scripting languages.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会在运行程序的工作站上构建代码。现代 *集成开发环境* (*IDEs*) 提供舒适的工作环境，将编辑器、编译器、调试器和帮助系统结合在一个单一的统一点选界面中。许多第三方组件可用于简化常见任务的开发。这里使用了全系列的语言：从低级的
    C/C++，通过 BASIC 和 Java，到脚本语言。
- en: '**Common problems and challenges**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Users expect high-quality programs that conform to standard interface principles.
    More features than any person could remember are the order of the day; this is
    a serious commercial requirement, and usually what differentiates one product
    from the next. New product revisions these days tend to introduce more features
    (and bugs) than any problems they might solve. This is what the market demands.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望高质量的程序，这些程序符合标准界面原则。比任何人都可能记住的功能要多的是日常事务；这是一个严肃的商业需求，通常也是区分一个产品与下一个产品之间的不同之处。如今，新产品修订通常引入的功能（和错误）比它们可能解决的问题要多。这就是市场需求。
- en: '* * *'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-23-FN-1)]) Which, of course, you don't. Admitting your job at a
    party can be an instant conversation killer. Well, unless it's a party full of
    nerds, in which case you're probably trying to escape, anyway!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-23-FN-1)]) 当然，你在聚会上承认你的工作是做这份工作可能会立即结束对话。嗯，除非这是一个满是书呆子的聚会，在这种情况下，你可能正试图逃离，无论如何！
- en: Games Programming
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏编程
- en: The exciting and glamorous world of games programming is a specific form of
    applications work, usually developing shrink-wrap software. A lot of the battle
    is waged with captivating marketing and a very good initial concept for the game
    play. This is a fine line that differentiates a great, successful game from the
    also-rans.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏编程这个激动人心且光鲜亮丽的世界是一种特定形式的应用程序工作，通常开发 shrink-wrap 软件。大部分的战斗都是在吸引人的营销和非常好的游戏玩法概念上进行的。这是区分一个伟大、成功的游戏和失败者的细微差别。
- en: These games often involve first-person, massive, immersive, 3D environments.
    To provide an absorbing experience, the graphics capability of the hardware is
    fully exploited, and the CPU is maxed out managing maps, enemies, and puzzles,
    while performing serious modeling of the physics of moving objects. This must
    all be coordinated in real time and stresses the hardware to its limits. A significant
    portion of games programming is optimizing the code to the execution platform.
    As faster hardware is released, the problem doesn't lessen; to stand out from
    other games, more optimization is required to squeeze a better experience out
    of the new platforms. This field is very much about staying on the cutting edge
    and using the latest state-of-the-art technology to do the coolest thing.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这些游戏通常涉及第一人称、大规模、沉浸式、3D 环境。为了提供吸引人的体验，硬件的图形能力被充分利用，CPU 被最大化用于管理地图、敌人和谜题，同时执行移动物体的物理建模。所有这些都必须实时协调，并使硬件达到极限。游戏编程的一个很大部分是优化代码以适应执行平台。随着更快的硬件发布，问题并没有减少；为了与其他游戏脱颖而出，需要更多的优化来从新平台上挤出更好的体验。这个领域非常注重保持前沿，并使用最新的尖端技术来做最酷的事情。
- en: '**THE RUNDOWN**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**概览**'
- en: Professional games development is about fun, but it's a hugely competitive industry
    where developers are expected to keep up with the latest technologies, furious
    deadlines, and nonnegotiable, last-minute change requests. Sweat, blood, and tears
    are required to write the software, only for it to meet the harsh public glare
    of a highly critical specialist press. But it can be hugely rewarding—once finished,
    you've made something that people can see, understand, and enjoy.—Thaddeus (professional
    games programmer)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 专业游戏开发关于乐趣，但这是一个高度竞争的行业，开发者需要跟上最新的技术、紧迫的截止日期和不可协商的最后一刻变更请求。编写软件需要汗水、鲜血和泪水，只为它能在高度批判性的专业媒体面前经受住严酷的公众审视。但回报可能非常丰厚——一旦完成，你创造出的东西就能被人们看到、理解并享受。——Thaddeus（专业游戏程序员）
- en: '**Typical products**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: First-person, immersive, 3D games, strategy games, online puzzles.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第一人称、沉浸式、3D游戏、策略游戏、在线谜题。
- en: '**Target platform**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: Desktop PC, games consoles, mobile devices (PDAs and mobile phones), arcade
    machines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面电脑、游戏机、移动设备（个人数字助理和移动电话）、街机。
- en: '**Development environment**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: Dedicated games platforms (including high-end graphics cards in standard PCs)
    have tailored development environments to help exploit their power. It still takes
    very talented developers to fully capitalize on the platform's functionality.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 专用游戏平台（包括标准PC中的高端显卡）提供了定制的开发环境来帮助充分利用它们的性能。仍然需要非常才华横溢的开发者才能充分利用平台的功能。
- en: '**Common problems and challenges**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Getting excellent game play; balancing features, user response, aesthetics,
    atmosphere, and difficulty. A good game unfolds very much like a story, and draws
    the player in.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 获得优秀的游戏体验；平衡功能、用户反应、美学、氛围和难度。一款好游戏的发展非常像故事一样，并能吸引玩家。
- en: Optimization is required to capitalize on the execution platform.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 需要优化以充分利用执行平台。
- en: Modern games development teams often have a cast more akin to Hollywood movie
    production than to standard bean-counting software. We see teams including graphics
    artists and level designers and the development of storyboards, concept art, and
    proof-of-concept designs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏开发团队往往更像好莱坞电影制作团队，而不是标准的会计软件团队。我们看到团队包括图形艺术家、关卡设计师，以及故事板、概念艺术和概念设计的发展。
- en: The software might target a (suitably souped-up) PC platform or dedicated games
    consoles. These machines have specific hardware to accelerate the many graphics
    operations required per second and special tools to help you harness their power.
    Console manufacturers provide development kits (special versions of the hardware
    and tailored software tools) to help you create products, assisting with code
    loading, testing, and debugging, while helping to avoid security features on production
    hardware that would impede development.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 软件可能针对（经过适当升级的）PC平台或专用游戏机。这些机器具有特定的硬件来加速每秒所需的许多图形操作，并提供了特殊的工具来帮助你利用它们的性能。游戏机制造商提供开发套件（硬件和定制软件工具的特殊版本）来帮助你创建产品，协助代码加载、测试和调试，同时帮助避免生产硬件上的安全特性，这些特性可能会阻碍开发。
- en: Multiplayer games provide richer game play. This brings network collaboration
    into the mix and requires some skill to get acceptable real-time performance out
    of slow Internet connections.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏提供了更丰富的游戏体验。这引入了网络协作，并需要一些技巧才能从缓慢的互联网连接中获得可接受的真实时间性能。
- en: 'The quality of the ultimate product is determined by the feel of the game play.
    Everything is tweaked until the game feels right: the level design, the physics
    models, the graphics, the color of your underwear. Nothing is sacred. You might
    write the most beautiful code in the world; the program might never crash; it
    might do everything it was specified to do; it might be highly efficient. But
    if it lacks that special spark that makes it a compelling, addictive game, it
    will not be successful. Tricky stuff.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最终产品的质量取决于游戏体验的感觉。一切都会调整，直到游戏感觉正确：关卡设计、物理模型、图形、内衣的颜色。没有什么是不神圣的。你可能编写了世界上最美丽的代码；程序可能永远不会崩溃；它可能完成了一切它被指定要做的事情；它可能非常高效。但如果它缺乏那种使它成为一个引人入胜、上瘾的游戏的特殊火花，它将不会成功。棘手的事情。
- en: Systems Programming
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统编程
- en: 'Applications sit atop rich system libraries: layers of code for networking,
    graphical interfaces, multitasking, file access, multimedia, peripheral control,
    inter-process communication, and more. If applications programmers receive a lot
    of support from the underlying system, then someone''s got to supply that underlying
    system. This is systems programming.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序位于丰富的系统库之上：用于网络、图形界面、多任务处理、文件访问、多媒体、外围设备控制、进程间通信等代码层。如果应用程序程序员从底层系统获得大量支持，那么就必须有人提供这个底层系统。这就是系统编程。
- en: It is generally for workstation machines too, but it's not aimed at the end
    users. Systems software is aimed at the application developer; the public façade
    is a set of APIs to be used by software layers higher up the food chain. Systems
    software is concerned with the low-level logic that interacts with the computer
    at a very basic level, and also middle-level support frameworks that don't interface
    directly to hardware but provide important services to the rest of the system.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它通常也适用于工作站，但并不是针对最终用户的。系统软件的目标是应用开发者；面向公众的界面是一套API，供软件链上更高层的软件层使用。系统软件关注的是与计算机在非常基本的层面上交互的低级逻辑，以及不直接与硬件接口但为系统其他部分提供重要服务的中间层支持框架。
- en: Work in this arena typically includes writing device drivers (controlling devices
    such as printers, storage media, output devices, etc.), writing common shared
    libraries and utilities for managing scarce resources, implementing the actual
    operating systems controlling the computer, and providing components such as filing
    systems and network stacks. Even compilers and installation tool suites can come
    under this heading, as they are support services for application programmers and
    are often intimately entwined with the program run-time environment.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域的工作通常包括编写设备驱动程序（控制打印机、存储媒体、输出设备等设备）、编写用于管理稀缺资源的通用共享库和实用程序、实现控制计算机的实际操作系统，以及提供文件系统和网络堆栈等组件。编译器和安装工具套件也可以归入此类，因为它们是应用程序程序员的支撑服务，并且通常与程序运行时环境紧密相连。
- en: '**THE RUNDOWN**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**概览**'
- en: I wrote the USB stack for a proprietary operating system. I had to understand
    the OS, USB hardware, and the USB protocol, so there was a lot to take in. I had
    to keep up performance so the system worked well. Acting as the middleman, I was
    abstracting the hardware interfaces and providing a neat API for applications
    to use. I had to make this platform agnostic, which added extra complexity.—Dave
    (systems component writer)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一种专有操作系统编写了USB堆栈。我必须理解操作系统、USB硬件和USB协议，因此有很多东西要学习。我必须保持性能，以确保系统运行良好。作为中间人，我抽象化了硬件接口，并为应用程序提供了一个整洁的API。我必须使这个平台无关，这增加了额外的复杂性。——Dave（系统组件编写者）
- en: '**Typical products**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: Operating systems, device drivers, a window manager, or a graphics subsystem.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统、设备驱动程序、窗口管理器或图形子系统。
- en: '**Target platform**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: Since every execution environment needs some form of run-time support, there
    is system-level software in almost every electronic device. Systems software is
    required in the smallest embedded device and the largest mainframe computer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个执行环境都需要某种形式的运行时支持，因此在几乎每个电子设备中都有系统级软件。即使在最小的嵌入式设备和最大的主机计算机中，也需要系统软件。
- en: '**Development environment**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: Writing device drivers and operating system components tends to screw with the
    computer and make your system unstable, so it's common to develop on one machine
    and run the code on a second system. C is by far the most common language in this
    arena, although some library-level work is done in other languages (C++ is popular,
    as it aims to be a systems-capable language).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 编写设备驱动程序和操作系统组件往往会干扰计算机并使系统不稳定，因此通常在一个机器上开发并在第二个系统上运行代码。C语言在这个领域是最常见的语言，尽管一些库级工作是用其他语言完成的（C++很受欢迎，因为它旨在成为具有系统能力的语言）。
- en: '**Common problems and challenges**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: The key here is stability, since these are foundational blocks of the entire
    computing environment. While an application might crash and have a chance to save
    work and gracefully recover, a device driver rarely has such a luxury; it is required
    to work correctly the entire time it runs. This could be an awfully long time,
    so even small memory leaks can become major problems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于稳定性，因为这些是整个计算环境的基础块。虽然应用程序可能会崩溃，有机会保存工作并优雅地恢复，但设备驱动程序很少有这样的奢侈；它要求在整个运行期间始终正确工作。这可能是一个非常长的时间，所以即使是小的内存泄漏也可能成为主要问题。
- en: The code must be efficient (enough), both in terms of space and speed, and will
    need to be appropriately tailored to the particular operating environment.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须在空间和速度上都足够高效，并且需要根据特定的操作环境进行适当的调整。
- en: Embedded Programming
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式编程
- en: 'Computer technology shows up everywhere in our daily lives, whether we''re
    aware of it or not. We''re constantly using devices and gizmos, from microwaves
    to watches, radios to thermostats. These consumer electronics products require
    software for control and operation. More often than not, this software is invisible
    to the device''s user. It''s not just consumer electronics appliances that contain
    embedded software: Anything with a microcontroller (e.g., laboratory instruments
    or the machines that issue parking tickets) is software driven. We must write
    programs that are embedded in the hardware devices: embedded software.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机技术无处不在地出现在我们的日常生活中，无论我们是否意识到。我们不断地使用各种设备和小玩意，从微波炉到手表，从收音机到恒温器。这些消费电子产品需要软件来控制和操作。通常情况下，这种软件对设备的用户来说是不可见的。不仅消费电子产品包含嵌入式软件：任何带有微控制器（例如，实验室仪器或发放停车票的机器）的东西都是软件驱动的。我们必须编写嵌入在硬件设备中的程序：嵌入式软件。
- en: 'Embedded developers work under tight constraints:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发者工作在严格的约束下：
- en: 'There are usually very scarce resources: restricted CPU power and/or strict
    memory limits. Memory limitations concern both ROM (for the program image) and
    RAM (space for the code to execute and to store information). On platforms without
    much capacity, you have to shoehorn a lot of software into the available device
    space. Sometimes this requires quite creative (and heroic) solutions, like decompressing
    program code or data on the fly.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常资源非常有限：有限的CPU功率和/或严格的内存限制。内存限制既涉及ROM（程序映像），也涉及RAM（代码执行和存储信息的空间）。在容量不大的平台上，你必须将大量软件塞入可用的设备空间。有时这需要相当有创意（和英雄般的）解决方案，比如在运行时动态解压缩程序代码或数据。
- en: 'The opportunities for user interface are quite limited: how do you pack all
    user interaction into two buttons and an LED? Indeed, there may be no user interface
    at all; there may be no direct interaction with a user—the software is expected
    to just work.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面的机会相当有限：你如何将所有用户交互压缩到两个按钮和一个LED灯中？实际上，可能根本就没有用户界面；可能没有与用户的直接交互——软件预期只是正常工作。
- en: These constraints have a profound impact on the nature of the code you write.
    Sadly, in the embedded environment (more than others), we end up sacrificing the
    purity of our code to get something working. Fast code that fits into the device's
    ROM and works is more important than theologically correct but large and slow
    software.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制对您编写的代码的本质产生了深远的影响。遗憾的是，在嵌入式环境中（比其他环境更多），我们最终不得不牺牲代码的纯洁性以实现某种功能。快速且适合设备ROM的代码，比神学上正确但庞大且缓慢的软件更重要。
- en: Embedded systems are designed to do one job and to do it reliably. It should
    appear as if the software is not there; the embedded device should just work,
    all the time. Failure is rarely an option; it might physically break the hardware.
    Contrast this to a desktop computer—it's a general-purpose machine. It has to
    be able to word process, play movies, browse websites, read email, manage your
    accounts, and so on. As users, we've been conditioned to accept the odd crash
    and a bit of instability. We'll sacrifice a little convenience for power and flexibility.
    Embedded work is a totally different ballpark.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统被设计来执行单一任务，并且要可靠地完成。它应该看起来就像软件不存在一样；嵌入式设备应该始终正常工作。故障很少是可选项；它可能会物理损坏硬件。这与台式计算机形成对比——它是一种通用机器。它必须能够进行文字处理、播放电影、浏览网站、阅读电子邮件、管理账户等等。作为用户，我们已经习惯了接受偶尔的崩溃和一点不稳定。我们会为了性能和灵活性牺牲一点便利。嵌入式工作完全是另一个领域。
- en: 'A good example is the modern car industry. We see vehicles manufactured with
    many embedded systems, controlling all sorts of things: engine management, ABS
    brakes, safety features like air bags and seat belt pre-tensioners, climate control,
    the odometer, and so on. However, the users (in this case the driver and/or passengers)
    don''t have to be at all aware that there are any microprocessors whirring away
    under the hood. They expect the car to just work. When an engine management system
    fails, the user becomes acutely aware of the software! Think also about mobile
    phones. They are obviously computer-driven devices, but few consumers think of
    them as a computer. We pack a lot of power into these small packages, but there
    are still strict operational limits that the software must work within.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是现代汽车工业。我们看到许多嵌入式系统被用于制造汽车，控制着各种功能：发动机管理、ABS刹车、安全特性如安全气囊和座椅安全带预紧器、气候控制、里程表等等。然而，用户（在这种情况下是驾驶员和/或乘客）根本不需要意识到引擎盖下有任何微处理器在运转。他们期望汽车能正常工作。当发动机管理系统出现故障时，用户会突然意识到软件的重要性！再想想手机。它们显然是计算机驱动的设备，但很少有消费者把它们当作计算机。我们在这些小包装中放入了大量的力量，但软件仍必须在一个严格的操作限制范围内工作。
- en: 'An embedded system is typically the combination of a small computer, some dedicated
    hardware, and either a real-time operating system or a simple controlling program.
    It will have direct control over the hardware on the device. Embedded systems
    are usually made-to-order: developed for specific hardware, for a specific purpose.
    Simple embedded systems have only one piece of software running on them; no highly
    complex threaded programming environments are used—not even an operating system.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统通常是小型计算机、一些专用硬件以及实时操作系统或简单的控制程序的组合。它将直接控制设备上的硬件。嵌入式系统通常是按需定制的：为特定的硬件、特定的目的而开发。简单的嵌入式系统上只运行一个软件；不使用高度复杂的线程编程环境——甚至不使用操作系统。
- en: The code is usually stored in firmware, permanently held in a read-only memory
    chip. It is seldom updatable, so it has to work correctly the first time. There's
    no chance to get it wrong and ship a version 1.1\. One simple mistake can render
    your miracle product a failure.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通常存储在固件中，永久保存在只读存储器芯片中。它很少可以更新，所以它必须第一次就正确无误。没有机会出错并发布1.1版本。一个简单的错误就可以让你的奇迹产品变成失败。
- en: Recently, memory and CPU power have become a lot cheaper as more and more mass
    market devices are created. Embedded environments have become more powerful and
    the constraints are widening. However, there will always be the need for very
    small devices with little horsepower that achieve just what they need to. Just.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，随着越来越多的大众市场设备被创造出来，内存和CPU功率变得便宜多了。嵌入式环境变得更加强大，限制也在扩大。然而，总会有对非常小型的设备的需求，这些设备只需要完成它们需要完成的事情。仅此而已。
- en: You might consider that programming applications for handheld devices like PDAs
    is embedded-level or applications-level work, depending on where you stand.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为为手持设备如PDA编写应用程序是嵌入式级别或应用级别的工作，这取决于你的立场。
- en: '**THE RUNDOWN**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: I like working near the metal—it really forces you to think about what's going
    on. You need tight code and a good understanding of what the hardware's doing.
    It can be tricky to debug problems, but these challenges are what makes it interesting.
    —Graham (embedded software developer)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在金属附近工作——这真的迫使你思考正在发生的事情。你需要紧凑的代码和对硬件所做事情的深入了解。调试问题可能会很棘手，但正是这些挑战使得它变得有趣。——格雷厄姆（嵌入式软件开发者）
- en: '**Typical products**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: Control software for washing machines, hi-fis, mobile phones.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 洗衣机、高保真音响、手机的控制软件。
- en: '**Target platform**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: Small, custom-made devices with very limited resources and meager UIs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 小型、定制设备，资源有限，用户界面简陋。
- en: '**Development environment**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: Since you work with custom-made devices, the toolchain is also often custom
    made. Frequently, it's not very advanced at all, compared to the relative luxury
    of the applications programmer. (As the market broadens, we are seeing improvements
    here.) The code is developed in a cross-compilation environment, where the target
    platform is different from host compilation environment. (Clearly you can't compile
    C on a washing machine . . . yet.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用的是定制设备，工具链也通常是定制的。通常，与应用程序程序员的相对奢华相比，它并不非常先进。（随着市场的扩大，我们在这里看到了一些改进。）代码是在交叉编译环境中开发的，目标平台与主机编译环境不同。（显然你无法在洗衣机上编译C语言程序……至少目前还不能。）
- en: We write specialized software for each specific device. Embedded programming
    almost universally uses C, apart from really low-level work, which resorts to
    assembly code. C++ is making inroads into this area, and ADA has also been used.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个特定设备编写专门的软件。嵌入式编程几乎普遍使用C语言，除了真正低级的工作，这些工作会使用汇编语言。C++正在进入这个领域，ADA语言也被使用过。
- en: '**Common problems and challenges**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: There are all sorts of problems you can encounter, largely depending on whether
    you are working with a commodity, off-the-shelf embedded platform or building
    your own. There are issues of real-time programming (for example, timely handling
    of hardware events and interrupts), direct hardware interfacing, and controlling
    peripheral connections, plus tedious low-level concerns like byte endianness and
    physical memory layout.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到各种各样的问题，这很大程度上取决于你是否在使用通用、现成的嵌入式平台，或者是在构建自己的平台。有实时编程的问题（例如，及时处理硬件事件和中断），直接硬件接口，以及控制外围连接的问题，还有诸如字节序和物理内存布局等繁琐的低级问题。
- en: To ensure the system is robust, there must be a great emphasis on product testing.^([[02](#ftn.CHP-23-FN-02)])
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保系统健壮，必须非常重视产品测试.^([[02](#ftn.CHP-23-FN-02)])
- en: '* * *'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[02](#CHP-23-FN-02)]) Of course any good software development—not just embedded
    work—needs a great emphasis on testing. In all environments, testing tends to
    suffer as it is squeezed out by overzealous marketing and management departments
    who do not really understand the nature of software. However, desktop applications
    can be more easily updated than the firmware in an embedded device.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[02](#CHP-23-FN-02)]) 当然，任何好的软件开发——不仅仅是嵌入式工作——都需要非常重视测试。在所有环境中，测试往往因为过于热情的市场营销和管理部门而受到挤压，他们并不真正了解软件的本质。然而，桌面应用程序比嵌入式设备的固件更容易更新。
- en: Distributed Programming
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式编程
- en: Distributed systems are comprised of more than one computer. As we'll see later,
    the World Wide Web is effectively a huge distributed system with information being
    stored on many computers across many continents and with applications delivered
    remotely via your web browser. It's not all about web browsers, though. Multimachine
    architectures are used in many situations. Working with and designing distributed
    systems ushers in a whole new world of problems.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式系统由多个计算机组成。正如我们稍后将会看到的，万维网实际上是一个巨大的分布式系统，信息存储在许多跨多个大陆的计算机上，并且通过您的网络浏览器远程提供应用程序。但这并不仅限于网络浏览器。在许多情况下都使用多机架构。与分布式系统一起工作和设计引入了一个全新的问题领域。
- en: You might need to distribute a software system for a number of reasons. Perhaps
    some types of computers are more suited to particular tasks than others. Perhaps
    the system is in high demand, and you can share the workload among many machines
    on a network to improve performance. Perhaps there are physical location restrictions
    for certain machines that mandate distributing the system. Perhaps you need to
    interoperate a new installation with a legacy system or some old hardware.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要出于多种原因分发一个软件系统。也许某些类型的计算机比其他类型的计算机更适合特定的任务。也许系统需求很高，你可以通过在网络上许多机器之间共享工作负载来提高性能。也许某些机器有物理位置限制，这要求系统进行分布式。也许你需要将新安装与遗留系统或某些旧硬件进行互操作。
- en: The goal is to design a system that is composed of a number of programs on different
    machines that all work as a cohesive whole. Tied together by a network connection,
    they might be physically co-located in a corporate server room or scattered across
    the globe, communicating over the Internet.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是设计一个由不同机器上的多个程序组成的系统，这些程序作为一个统一的整体工作。通过网络连接连接在一起，它们可能物理上位于企业服务器室中，或者分布在全球各地，通过互联网进行通信。
- en: 'The disparate parts need to be glued together somehow; each of the programs
    needs to communicate, and it is desirable to call functions on remote machines
    as if they were locally linked to the code. This is known as *remote procedure
    call (RPC)*, and such facilities are provided by a number of available *middleware
    technologies*. These act as brokers for data transfer between machines; they describe
    how you discover and talk to services on other machines and how you publish your
    services for other programs to call. Middleware manages the policies involved
    with interoperability: there are security issues (Who''s allowed to call whom?),
    network latency issues (What happens if a remote function call takes too long
    or a computer goes down?), considerations for balancing synchronous remote function
    calls with asynchronous calls, and more.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的部分需要以某种方式粘合在一起；每个程序都需要进行通信，并且希望能够在远程机器上调用函数，就像它们是本地链接到代码一样。这被称为 *远程过程调用 (RPC)*，并且这种功能由许多可用的
    *中间件技术* 提供。这些充当机器间数据传输的经纪人；它们描述了如何发现和与其他机器上的服务进行通信，以及如何发布您的服务供其他程序调用。中间件管理涉及互操作性的策略：存在安全问题（谁允许调用谁？），网络延迟问题（如果远程函数调用耗时过长或计算机崩溃会发生什么？），平衡同步远程函数调用与异步调用的考虑，等等。
- en: Some middleware systems employ object-oriented technologies; some take more
    of a procedural approach. The middleware is simply connectivity software and allows
    some degree of platform neutrality. As long as the middleware runs on a given
    platform, the client code shouldn't care what platform it's calling into—it could
    even be a ZX spectrum—the function calls all look the same. Of course, in the
    design of a distributed system, you will select the appropriate hardware for each
    task. It's doubtful you'll see any ZX spectrums hanging around!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一些中间件系统采用面向对象技术；一些则更多地采用过程式方法。中间件仅仅是连接软件，并允许一定程度的平台中立性。只要中间件在某个平台上运行，客户端代码就不必关心它调用的是哪个平台——甚至可能是ZX
    spectrum——函数调用看起来都是一样的。当然，在设计分布式系统时，您将为每个任务选择适当的硬件。您不太可能看到ZX spectrum四处游荡！
- en: Commonly used middlewares are CORBA, the Java RMI, Microsoft's DCOM, and .NET
    remoting. Using these, we split the system between user interface elements, the
    business logic (real workhorse code), and any storage required (e.g., a database
    and query engine). The user interface client may be a GUI program or a web-based
    front end. This is the classic *tiered architecture approach* (described in "[Client/Server
    Architecture](ch14s03.html#client_foreword_slash_server_architecture "Client/Server
    Architecture")" on page 271). We also see the emergence of *web APIs*—communications
    methods for services that use standard web protocols.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的中间件包括CORBA、Java RMI、微软的DCOM和.NET远程通信。使用这些，我们将系统分为用户界面元素、业务逻辑（真正的代码工作马）和所需的任何存储（例如，数据库和查询引擎）。用户界面客户端可能是一个GUI程序或基于Web的前端。这是经典的
    *分层架构方法*（在271页的"[客户端/服务器架构](ch14s03.html#client_foreword_slash_server_architecture
    "客户端/服务器架构")”中描述），我们也看到了 *Web API* 的出现——使用标准Web协议的服务通信方法。
- en: '*Grid computing* and *clustered systems* are specific distribution mechanisms
    that help numerical programming work (more on this later), enabling the creation
    of high performance, distributed computational algorithms. Clusters are tightly
    coupled systems; usually all the machines are in the same room, using the same
    hardware and OSes, linked by a specific cluster middleware. Grids are loosely
    coupled; they could be geographically scattered and run heterogeneous environments.
    They communicate via standard web protocols (e.g., HTTP/XML).'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*网格计算* 和 *集群系统* 是特定的分布式机制，有助于数值编程工作（关于这一点稍后还会详细介绍），能够创建高性能、分布式计算算法。集群是紧密耦合的系统；通常所有机器都在同一个房间，使用相同的硬件和操作系统，通过特定的集群中间件连接。网格是松散耦合的；它们可能在地理上分散，运行异构环境。它们通过标准Web协议（例如，HTTP/XML）进行通信。'
- en: '**THE RUNDOWN**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**概览**'
- en: The Smallpox project, completed in 2003, was a grid computing project to help
    find a cure for smallpox by screening a huge number of potential drug molecules.
    It was a collaboration between scientists, universities, and businesses that identified
    44 strong candidates for treatment of the disease.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 天花项目，于2003年完成，是一个网格计算项目，旨在通过筛选大量潜在的药物分子来帮助寻找天花的治疗方法。这是一个由科学家、大学和商业机构合作的项目，确定了44种治疗该疾病的有力候选药物。
- en: '**Typical products**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: An online purchase system, splitting work between front-end applications (web
    interface, in-shop kiosk, and/or phone ordering system), business logic (manages
    stock control, implements ordering system and secure billing) and the shared storage.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在线购物系统，将工作分配给前端应用程序（网页界面、店内自助终端和/或电话订购系统）、业务逻辑（管理库存控制、实现订购系统和安全计费）以及共享存储。
- en: '**Target platform**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: Many different computer systems connect via a middleware, almost always sitting
    on top of standard networking protocols.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同的计算机系统通过中间件连接，几乎总是位于标准网络协议之上。
- en: '**Development environment**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: Many and varied. This will depend on languages used, the nature of each computer
    in the system, and the type of middleware employed. Remotely callable interfaces
    are often defined in some form of interface definition language (IDL) and compiled
    to an implementation language representation that provides all the calling glue
    and provides hooks for each function implementation to be slotted in to.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 多样化和复杂。这取决于使用的语言、系统中每台计算机的性质以及使用的中间件类型。远程可调用的接口通常以某种形式的接口定义语言（IDL）定义，并编译成实现语言的表示形式，提供所有调用粘合剂，并为每个函数实现提供插槽。
- en: '**Common problems and challenges**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Designing the correct split of services between computers and streamlining the
    communications involved. This can severely affect the scalability of a distributed
    system. What works for a few transactions per day may not work efficiently for
    100 transactions per minute. This calls for a real need to design carefully. You
    also have to deal with computer availability and cope gracefully if one of the
    computers in the system becomes unavailable.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 设计计算机间服务正确的分割和简化涉及的通信。这可能会严重影响分布式系统的可扩展性。对于每天只有几笔交易可能有效，但对于每分钟100笔交易可能就不高效了。这要求我们精心设计。你还得处理计算机的可用性，并在系统中的某台计算机不可用时优雅地应对。
- en: Web Application Programming
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用程序编程
- en: 'In 1990, Tim Berners-Lee created the first HTML browser and server, and the
    World Wide Web was born. Today it is a pervasive technology, and servers can not
    only deliver static pages of information, but they can dynamically create pages
    based on programs running on the webserver. This is a very specific form of distributed
    computing, where the user interface is hosted on a remote client: the web browser.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 1990年，蒂姆·伯纳斯-李创建了第一个HTML浏览器和服务器，万维网诞生。今天，它是一种无处不在的技术，服务器不仅可以提供静态信息页面，还可以根据在web服务器上运行的程序动态创建页面。这是一种非常具体的分布式计算形式，其中用户界面托管在远程客户端上：网络浏览器。
- en: 'Examples of this kind of application include:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用的例子包括：
- en: Online shopping
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线购物
- en: Bulletin boards, messaging services, and web-based email packages
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公告板、消息服务和基于网络的电子邮件包
- en: Ticket availability and booking systems
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 票务可用性和预订系统
- en: Internet search engines
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网搜索引擎
- en: Most people now use web applications without thought; it's as natural as a local
    word processor. These programs clearly have different characteristics from ordinary
    (so-called *rich client*) desktop applications. There are different things that
    each can do well. Without heroic JavaScript coding, interaction in a browser-based
    application UI is a lot more limited.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数人使用网络应用程序而不加思考；这就像使用本地文字处理器一样自然。这些程序显然具有与普通（所谓“富客户端”）桌面应用程序不同的特性。每项都能做得很好。没有英勇的JavaScript编码，基于浏览器的应用程序UI的交互性会大大受限。
- en: '**THE RUNDOWN**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**概览**'
- en: A web app makes you treat the web browser as your OS. All good web developers
    start by learning client-side browser technologies inside out. Then you learn
    to write good server-side code (i.e., fast, concurrent, transactional, distributed,
    and correct). The best thing about the Web is that it is constantly evolving and
    users' expectations are always rising. The bad thing about the Web is that users'
    expectations are always rising and your code never stands still. —Alan (web applications
    programmer)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络应用程序使你将网络浏览器视为操作系统。所有优秀的网络开发者都是从学习客户端浏览器技术开始的。然后你学习编写良好的服务器端代码（即快速、并发、事务性、分布式和正确）。关于网络最好的事情是它始终在发展，用户的期望总是不断提高。关于网络不好的事情是用户的期望总是不断提高，而你的代码永远不会停滞不前。
    ——Alan（网络应用程序程序员）
- en: '**Typical products**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: 'Interactive services that require up-to-date infomation and feedback: ticket
    booking or shopping systems.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 需要最新信息和反馈的交互式服务：票务预订或购物系统。
- en: '**Target platform**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: The back end is a webserver (commonly Apache or IIS). This choice is under your
    control, since you deploy the web app. The clients are web browsers, and there
    are many variants. Each has its own quirks, and you have no control over what
    is used. You have to produce web pages that are compatible with most of these.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 后端是一个网络服务器（通常是Apache或IIS）。这个选择在你手中，因为你部署了网络应用程序。客户端是网络浏览器，有众多变体。每个都有自己的怪癖，你无法控制使用什么。你必须生成与大多数这些浏览器兼容的网页。
- en: '**Development environment**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: The environment consists of the specific webserver and the applications programming
    language you write the system in, running on that server. Common languages are
    Perl and PHP.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 环境包括特定的网络服务器和你在该服务器上编写的系统应用程序语言。常见的语言有Perl和PHP。
- en: '**Common problems and challenges**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Coping with different browsers; scalability.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 应对不同的浏览器；可扩展性。
- en: The web application operational model is different from vanilla applications
    programming—session state is held on a remote machine, which must manage numerous
    simultaneous client connections, storing their state between HTTP interactions
    and gracefully handling clients that stop connecting. To facilitate this, some
    information is stored on the server (e.g., the items each customer is ordering
    are placed in a database) and some on the local client (using web browser *cookies*—nuggets
    of stored session state—to record the current user/session ID). Frameworks like
    ASP.NET and Java Servlets exist to speed web application development. Numerous
    off-the-shelf systems exist, such as content management systems and shopping cart
    systems.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序的操作模型与传统的应用程序编程不同——会话状态存储在远程机器上，该机器必须管理众多同时的客户连接，在HTTP交互之间存储它们的状态，并优雅地处理停止连接的客户。为此，一些信息存储在服务器上（例如，每个客户订购的项目存储在数据库中），一些存储在本地客户端上（使用网络浏览器的*cookies*——存储的会话状态的小块来记录当前用户/会话ID）。像ASP.NET和Java
    Servlets这样的框架存在是为了加速网络应用程序的开发。存在许多现成的系统，如内容管理系统和购物车系统。
- en: Many open standard protocols and encoding systems are used to represent and
    transfer information. HTTP is the common data transfer mechanism, and XML is often
    used to encode data packets (e.g., SOAP is a web-based communication protocol
    based on an XML schema).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开放标准协议和编码系统被用来表示和传输信息。HTTP是常见的数据传输机制，XML通常用于编码数据包（例如，SOAP是基于XML模式的基于Web的通信协议）。
- en: 'The problems faced by web application programmers mainly revolve around interoperability
    with the many types of browsers that might be used, handling their HTML peculiarities
    and their odd JavaScript quirks. It''s not unusual to develop tortuous HTML output
    to cope with all manners of flaws in the popular browsers. Web programmers often
    have to interface with legacy systems (customer databases, existing order management
    systems, etc.) to generate their information; this can get quite messy. Scalability
    is a real concern: A system might work fine when tested by five simultaneous users.
    But when it goes live, it must withstand 500 users accessing it at the same time.
    *Load testing* is important here (see "Load testing" on page 139).'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序程序员面临的问题主要围绕着与可能使用的各种浏览器的互操作性，处理它们的HTML特性和奇特的JavaScript怪癖。为了应对流行浏览器中的各种缺陷，开发出复杂的HTML输出并不罕见。网络程序员经常需要与遗留系统（客户数据库、现有的订单管理系统等）接口以生成信息；这可能会变得相当混乱。可扩展性是一个真正的担忧：一个系统在测试时可能由五个同时用户使用时运行良好。但是当它上线时，它必须能够承受500个用户同时访问。*负载测试*在这里很重要（参见第139页的“负载测试”）。
- en: Enterprise Programming
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业编程
- en: '*Enterprise* is one of those tedious buzzwords that floats around, more management-speak
    than any programmer dialect. An enterprise is literally a business organization.
    So enterprise programming provides systems for entire companies, gluing all their
    separate systems together to form a unified, cohesive whole. Enterprise programming
    almost always means the development of large distributed systems.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*企业*是那些令人厌烦的流行词汇之一，它漂浮在周围，更多的是管理术语而不是任何程序员方言。企业字面上是一个商业组织。因此，企业编程为整个公司提供系统，将它们各自独立的系统粘合在一起，形成一个统一、协调的整体。企业编程几乎总是意味着大型分布式系统的开发。'
- en: They'll commonly be deployed on a company intranet (internal network) and link
    the different departments of the business together to improve workflow. The systems
    may or may not be customer facing. Once the organization is running an integrated
    computer system, it's generally not too hard to have automated customer interaction—for
    example, through a web-based shop interface. Perhaps an enterprise system will
    need to interface to other companies' systems too, to track the delivery status
    of goods being shipped, for example.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常会在公司内部网络（内部网络）上部署，将业务的不同部门连接起来，以提高工作流程。这些系统可能是面向客户的，也可能不是。一旦组织运行了集成的计算机系统，通常不太难实现自动化的客户互动——例如，通过基于网络的商店界面。也许企业系统还需要与其他公司的系统接口，例如跟踪正在运输的货物的交付状态。
- en: Enterprise programming shares a lot of characteristics with made-to-order applications
    software. The product only really needs to be good *enough*, since it's developed
    under contract for a specific customer, rather than speculatively for a general-market
    release. Quality here is not the measure of success (at least as determined by
    general stability and a larger feature set than any competitor); meeting the customer's
    objectives is.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 企业编程与定制应用软件有很多共同特征。产品只需要“足够好”，因为它是在合同下为特定客户开发的，而不是为了一般市场发布而投机性开发。在这里，质量不是成功的衡量标准（至少是由一般的稳定性和比任何竞争对手都大的功能集所决定的）；满足客户的目标才是。
- en: Enterprise systems are written for installation on specific machines in a company's
    server room or on locked-down desktop machines. You have reasonable control over
    the execution environment, so you don't need to worry about making the code work
    on every release of the operating system and under every conceivable hardware
    configuration. This deftly sidesteps a lot of the headaches that applications
    programmers suffer.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 企业系统是为安装在公司的服务器室或锁定桌面机器上的特定机器编写的。你对执行环境有合理的控制权，因此你不需要担心代码在操作系统的每个版本和每种可能的硬件配置下都能工作。这巧妙地避开了应用程序程序员所遭受的许多头痛问题。
- en: '**THE RUNDOWN**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**概览**'
- en: I work in the IT department of a large city bank. We write software to solve
    specific business needs. It's mission critical; what we do makes a real difference
    to the company's profits, so we have to take it seriously. With many thousands
    of dollars going through the system every hour, there's no room for error.—Richard
    (Enterprise programmer)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我在大城市的一家银行的IT部门工作。我们编写软件来解决特定的商业需求。这是至关重要的任务；我们所做的工作对公司利润有真正的影响，因此我们必须认真对待。每小时有成千上万美元通过系统，没有出错的空间。——理查德（企业程序员）
- en: '**Typical products**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: Business systems for an entire company, managing its commercial operations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 整个公司的商业系统，管理其商业运营。
- en: '**Target platform**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: A tailored distributed system.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 定制的分布式系统。
- en: '**Development environment**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: Same as for distributed systems. We'll probably be working with huge data stores,
    perhaps various database technologies from previous internal systems (legacy systems
    in manager-speak). XML is all the rage here.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与分布式系统相同。我们可能会处理巨大的数据存储，可能是来自以前内部系统（经理们所说的遗留系统）的各种数据库技术。在这里，XML非常流行。
- en: '**Common problems and challenges**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Same as for distributed systems.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 与分布式系统相同。
- en: Numerical Programming
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值编程
- en: This kind of work involves scientific, highly technical tasks making heavy use
    of mathematics. This is a very specialized area that requires writing applications
    specifically targeted at particular numerical problems. The programs are often
    aimed at supercomputers, the fastest type of computers, capable of massive number-crunching
    operations. Although we're living in times when the fastest computer changes from
    year to year, these are very expensive platforms, employed for specialized applications
    that require immense mathematical calculations.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作涉及科学性、高度技术性的任务，大量使用数学知识。这是一个非常专业化的领域，需要编写专门针对特定数值问题的应用程序。这些程序通常针对超级计算机，这是最快类型的计算机，能够进行大规模的数值计算操作。尽管我们生活在每年最快计算机都在变化的年代，但这些平台非常昂贵，用于需要巨大数学计算的专业应用。
- en: Weather forecasting, for example, requires a supercomputer (or perhaps a gift
    of prophesy!). We also see supercomputers used for animated graphics, fluid dynamic
    calculations, and other areas that require highly complex mathematical investigation
    and calculation.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，天气预报需要超级计算机（或者可能是一种预言的天赋！）我们还可以看到超级计算机被用于动画图形、流体动力学计算和其他需要高度复杂数学研究和计算的领域。
- en: A supercomputer is not a mainframe. The latter is a high-performance computer
    designed to concurrently execute as many programs as possible, often used as a
    centralized computing resource in a business setting. A supercomputer channels
    all its power into executing a few programs as fast as possible. There are a number
    of different supercomputer architectures exploiting different technological advances,
    each requiring different algorithmic approaches to fully exploit their power.
    General-purpose machines are now becoming powerful enough for serious numerical
    work—clustered, they can respectably make a poor man's supercomputer.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 超级计算机不是大型机。后者是一种高性能计算机，旨在尽可能并发执行尽可能多的程序，通常在企业环境中用作集中式计算资源。超级计算机将所有力量集中在尽可能快地执行少数几个程序上。有几种不同的超级计算机架构利用不同的技术进步，每种都需要不同的算法方法来充分利用其性能。通用机器现在变得足够强大，可以进行严肃的数值工作——集群化后，它们可以相当体面地成为一个穷人的超级计算机。
- en: 'Numerical work requires high-performance algorithms that execute calculations
    rapidly, to capitalize on the performance of the computing platform. It is common
    to make use of carefully designed, heavily optimized numerical libraries and to
    make explicit use of parallel processing, designing this into the computational
    algorithms and processes. This will involve both task and data parallelism: either
    performing many similar tasks on many CPUs at once or pipelining the algorithm,
    performing different parts of it on different CPUs.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 数值工作需要高性能算法来快速执行计算，以利用计算平台的性能。通常，人们会使用精心设计、高度优化的数值库，并明确使用并行处理，将这种设计融入计算算法和过程中。这将涉及任务并行和数据并行：要么同时在多个CPU上执行许多类似任务，要么流水线化算法，在不同的CPU上执行其不同部分。
- en: This branch of programming requires heavy optimization to the characteristics
    of the target platform to achieve acceptable performance.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编程分支需要对目标平台的特性进行大量优化，以实现可接受的性能。
- en: '**THE RUNDOWN**'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**概要**'
- en: I work on software systems for an engineering firm. We model large mechanical
    installations to figure out where physical problems might lie now or in the future.
    I have to represent the real world in a mathematical way, figuring out how things
    (should) work. Once I've done this, it's a case of finding the right mathematical
    constructs to represent the systems in an acceptable, accurate way.—Andy (Numerical
    programming expert)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我在一家工程公司工作，从事软件开发系统。我们模拟大型机械安装，以确定现在或未来可能存在的物理问题。我必须以数学方式表示现实世界，找出事物（应该如何）工作。一旦我这样做，就是找到合适的数学结构来以可接受、准确的方式表示系统的问题。——安迪（数值编程专家）
- en: '**Typical products**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**典型产品**'
- en: Fields involving highly complex mathematical investigation like nuclear energy
    research or petroleum exploration.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及高度复杂数学研究领域的领域，如核能研究或石油勘探。
- en: '**Target platform**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标平台**'
- en: Supercomputers or grid-based computing clusters.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 超级计算机或基于网格的计算集群。
- en: '**Development environment**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发环境**'
- en: 'Although there is work on advancing numerical programming support in C++, and
    some of this work is performed in C, a lot of numerical programming is done in
    Fortran, which has excellent numeric support (that was what it was designed for:
    formula translation).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有人在推进C++中的数值编程支持，并且其中一些工作是在C中完成的，但大量的数值编程是在Fortran中完成的，它具有出色的数值支持（这正是它被设计的目的：公式翻译）。
- en: '**Common problems and challenges**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**常见问题和挑战**'
- en: Crafting efficient algorithms to really exploit the power of the supercomputer.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 设计高效的算法，真正利用超级计算机的威力。
- en: So What?
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，这又如何呢？
- en: Freedom from the desire for an answer is essential to the understanding of a
    problem.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对答案的渴望的解脱对于理解问题至关重要。
- en: --Jiddu Krishnamurti
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: --吉杜·克里希那穆提
- en: 'How do these programming niches affect us? What do they make us do differently?
    To be a good programmer, a true craftsman, you must know:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编程细分领域如何影响我们？它们让我们做什么不同？要成为一名优秀的程序员，真正的工匠，你必须知道：
- en: What your discipline is—the kind of software you're producing.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的学科是什么——你正在生产的软件类型。
- en: How the discipline affects your architecture. (Is it a tiered enterprise system
    or tightly woven ball of embedded code? See [Chapter 14](ch14.html "Chapter 14. SOFTWARE
    ARCHITECTURE").)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该学科如何影响你的架构。（是分层的企业系统还是紧密编织的嵌入式代码？见[第14章](ch14.html "第14章。软件架构")。）
- en: What is an appropriate code design in this field and what isn't. (For example,
    should you sacrifice clarity and elegance for performance, try to squeeze the
    executable image into the smallest size possible, or perhaps incorporate many
    hooks for future extensibility?)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个领域，什么样的代码设计是合适的，什么样的不合适。（例如，你是否应该为了性能而牺牲清晰和优雅，试图将可执行映像压缩到尽可能小的尺寸，或者可能为了未来的可扩展性而包含许多钩子？）
- en: The tools you use—what's available and what isn't.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用的工具——什么可用，什么不可用。
- en: Which is the most appropriate choice of programming language and which coding
    idioms you should employ.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪种编程语言的选择最合适，以及你应该采用哪些编码惯例。
- en: '**KEY CONCEPT**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Know your discipline. Learn its intricacies. Understand how to write excellent
    software that appropriately meets its requirements*.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*了解你的学科。学习其复杂性。理解如何编写满足其要求的优秀软件*。'
- en: In a Nutshell
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Still round the corner there may wait, A new road or a secret gate.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在拐角处等待，一条新的道路或一扇秘密的大门。
- en: --J.R.R. Tolkien
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: --J.R.R. 托尔金
- en: 'We''ve dipped a toe in the water and sampled the different flavors of programming
    going on out there. Of course, there are other areas than those we''ve seen: some
    well defined, others more ephemeral. For example, *safety-critical software* drives
    high-reliability systems like medical equipment and aircraft control. Here failure
    is not an option, and the code must be *provably* correct; this has a profound
    affect on the way you design and write it.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涉足其中，品尝了那里正在进行的不同编程风味。当然，除了我们看到的这些领域之外，还有其他领域：一些定义明确，一些则更短暂。例如，*安全关键软件*驱动着高可靠性系统，如医疗设备和飞机控制系统。在这里，失败不是一种选择，代码必须是*可证明的*正确；这深刻地影响了你的设计和编写方式。
- en: 'What have we learned? These fields all have one thing in common: their differences.
    Each requires fundamental design decisions to be made to suit software to them.
    Application-level code is not generally suited to an embedded environment. A workstation
    application design may not scale when applied to a distributed system.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么？这些领域都有一个共同点：它们的差异。每个领域都需要做出基本的设计决策，以适应软件。应用层代码通常不适合嵌入式环境。工作站应用程序设计在应用于分布式系统时可能无法扩展。
- en: This means that software developers tend to specialize in particular fields
    and learn to think in particular patterns that suit their worlds. Understanding
    the very real concerns of each environment will make you a more flexible and mature
    programmer. Ultimately, you must know your programming church and practice its
    rites and rituals well.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着软件开发者往往会在特定领域专业化，并学会以适合他们世界的特定模式思考。理解每个环境的真实关注点将使你成为一个更灵活和成熟的程序员。最终，你必须了解你的编程教会，并熟练掌握其仪式和仪式。
- en: '| Good programmers . . . | Bad programmers . . . |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 精通编程的人... | 不擅长编程的人... |'
- en: '| --- | --- |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Understand the nature of the problems they face
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解他们面临的问题的本质
- en: Tailor their code and designs to the problem domain
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将他们的代码和设计定制到问题领域
- en: '|'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Have a naïvely narrow software worldview; they don't understand the forces that
    drive other types of software development
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个天真狭隘的软件世界观；他们不理解推动其他类型软件开发的力量
- en: Write code ill-suited for the problem domain (choosing unsympathetic architectures
    or inappropriate code idioms)
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不适合问题领域的代码（选择不友好的架构或不适用的代码惯例）
- en: '|'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: See Also
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。程序员的工具箱")'
- en: Different niches have different qualities and ranges of development tools.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的细分市场有不同的质量和开发工具的范围。
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。软件架构")'
- en: Different problem domains call for very different software solutions.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的问题领域需要非常不同的软件解决方案。
- en: '![See Also](tagoreillycom20080909nostarchimages207588.png.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![参考以下内容](tagoreillycom20080909nostarchimages207588.png.jpg)'
- en: Get Thinking
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 培养思考
- en: A detailed discussion of these questions can be found in the "[Appendix A](apa.html
    "Appendix A. Answers and Discussion")" section on page 557.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的详细讨论可以在第557页的"[附录A](apa.html "附录A. 答案和讨论")"部分找到。
- en: Mull It Over
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考
- en: Which of the programming niches we've looked at here are particularly similar
    or share common characteristics? Which are particularly different?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里探讨的编程细分领域中，哪些特别相似或具有共同特征？哪些特别不同？
- en: Which of these programming disciplines is hardest?
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种编程学科最难？
- en: Is it important to be an expert in one particular area or to have a good grounding
    in all of them without a particular specialism?
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成为某个特定领域的专家，或者在没有特定专业的情况下对所有领域都有良好的基础，哪个更重要？
- en: Which programming niche should trainee programmers be introduced to?
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该向训练中的程序员介绍哪个编程细分领域？
- en: Getting Personal
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: What programming arena are you working in right now? How does it affect the
    code that you're writing? What specific design and implementation decisions has
    it led you to make?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在正在哪个编程领域工作？这如何影响你编写的代码？它引导你做出了哪些具体的设计和实现决策？
- en: Do you have experience working in more than one programming discipline? How
    easy was it for you to switch mindsets and apply appropriate techniques in a different
    world?
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在多个编程学科中工作过吗？你切换思维模式和在不同世界中应用适当技术有多容易？
- en: Are any of the people you work with unaware of the forces that shape the particular
    kind of code you write? Do you have embedded software being written by programmers
    who only understand applications work? What can you do about this?
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你工作中的人是否不了解塑造你所编写特定类型代码的力量？你是否有由只理解应用程序工作的程序员编写的嵌入式软件？你能做些什么来解决这个问题？
- en: Chapter 24. WHERE NEXT?
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章。接下来是什么？
- en: '*All''s Well That Ends Well*'
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*一切皆好，只要结局圆满*'
- en: What we call the beginning is often the end. And to make an end is to make a
    beginning. The end is where we start from.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为开始的东西往往是结束。而结束就是开始。结束是我们出发的地方。
- en: --T.S. Eliot
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: --T.S. 艾略特
- en: 'Congratulations! You''ve reached the end of this book. Either that, or you''re
    the kind of person who likes to spoil an ending by reading the last page first.
    (If you are: *The butler did it*.) Presuming that you''ve read every chapter,
    by now you should have:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经到达了这本书的结尾。要么是这样，要么你就是那种喜欢先读最后一页来破坏结局的人。（如果你是的话：*管家干的*。）假设你已经阅读了每一章，到现在你应该已经：
- en: Learned many practical code-writing techniques that have already improved your
    source code.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学到了许多实用的代码编写技巧，这些技巧已经改进了你的源代码。
- en: Gained an understanding of how to write code in the Real World and the tricks
    that help you to produce useful code in the madness of the software factory.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解了如何在现实世界中编写代码以及帮助你在软件工厂的混乱中产生有用代码的技巧。
- en: Worked out some personal ways to improve your skill set. (You did attempt the
    questions, didn't you? If not, try them now.)
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定了一些个人方法来提高你的技能集。（你尝试过这些问题吗？如果没有，现在试试它们。）
- en: Discovered how to write effective code as part of a team, establishing practical
    steps to improve the way your team currently works together.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现了如何作为团队的一员编写有效的代码，确立了改善你们团队目前合作方式的实际步骤。
- en: Found out more about cartoon monkeys than you ever really needed to.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对卡通猴子的了解比你所需要的要多。
- en: 'But more importantly, you should now appreciate that an exceptional programmer
    is one with the right attitude: one who always seeks to write the best code in
    any situation, who works well with others, and who can make pragmatic decisions
    in the heat of the software factory. The craftsman knows how to manage technical
    debt and seeks to address problems early, before they become software snares.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，你现在应该认识到，一个卓越的程序员是拥有正确态度的人：在任何情况下都寻求编写最佳代码的人，与别人合作得很好，在软件工厂的热潮中能够做出实用决策的人。工匠知道如何管理技术债务，并试图在问题成为软件陷阱之前尽早解决它们。
- en: '**KEY CONCEPT**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Becoming a good programmer requires you to adopt effective *attitudes*—the
    angle of approach you take to software construction*.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*成为一名优秀的程序员需要你采取有效的*态度*——你对待软件构建的角度。'
- en: But What Now?
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 但接下来怎么办？
- en: The important thing is not to stop questioning. Curiosity has its own reason
    for existing. One cannot help but be in awe when he contemplates the mysteries
    of eternity, of life, of the marvelous structure of reality. It is enough if one
    tries merely to comprehend a little of this mystery every day. Never lose a holy
    curiosity.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要停止质疑。好奇心有其存在的理由。当人们思考永恒、生命、现实奇妙结构的奥秘时，不禁会感到敬畏。如果一个人每天只是试图理解这个奥秘的一小部分，那就足够了。永远不要失去神圣的好奇心。
- en: --Albert Einstein
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: --阿尔伯特·爱因斯坦
- en: As a code craftsman, you'll never reach perfection; the best you can ever achieve
    is a continual state of improvement. There's always more to learn. So what should
    you do now? The very fact that you're asking that question is pivotal—one of the
    most important charateristics of a code craftsman is a desire to improve.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名代码工匠，你永远不会达到完美；你所能达到的最好的状态是持续改进。总有更多东西要学习。那么你现在应该做什么呢？你提出这个问题的行为本身至关重要——一个代码工匠最重要的特征之一就是渴望改进。
- en: 'If I wanted to become a skilled soccer player, I might find some books on soccer,
    buy a soccer training video, and then sit down with some popcorn and a few beers
    to learn how to play the game. Great. Ask me how it''s going two months later.
    If I say, "I''ve read loads about it, and I know all the top moves of the premier
    players," then you won''t be at all impressed: How well can I actually *play*?
    It is a geniunely good idea to read about the game and to study it, but couch
    potato soccer skills aren''t any real use.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想成为一名技艺高超的足球运动员，我可能会找一些关于足球的书，买一张足球训练视频，然后坐下来，一边吃爆米花，一边喝几杯啤酒来学习如何踢球。很好。两个月后问我进展如何。如果我说，“我读了很多关于它的东西，我知道顶级球员的所有顶级技巧，”那么你不会感到丝毫的印象深刻：我实际上能踢得怎么样？阅读关于这项运动的内容并研究它是件好事，但沙发土豆式的足球技巧并没有什么实际用处。
- en: I can only learn soccer by doing it—by getting dirty, out on a field, playing
    the game. *Practice makes perfect*. I need to play with people who are skilled
    and who can train me well. I need to expend energy, feel the burn, and perhaps
    make a fool of myself in front of others. Slowly, gradually, painfully, I'll get
    better.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我只能通过实践来学习足球——通过在场上踢球，通过参与游戏。*熟能生巧*。我需要和技艺高超的人一起踢球，他们能很好地指导我。我需要消耗能量，感受痛苦，也许在别人面前出丑。慢慢地，逐渐地，痛苦地，我会变得更好。
- en: 'I hate to break it to you, but that''s the only way to get good at code craft
    too. Just reading this book won''t cut it. You have to get out there and *do it*.
    Properly. So how can we translate this into practice? Here are a few simple ideas:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我很遗憾地告诉你，这也是成为一名优秀的代码工匠的唯一途径。仅仅阅读这本书是不够的。你必须走出去，*真正地*去做。所以，我们如何将这个理念转化为实践呢？以下是一些简单的想法：
- en: Place this book on your bookshelf. Put what you've learned into practice as
    best you can right now. You can always refer to a specific chapter when you run
    into problems later on.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把这本书放在你的书架上。尽可能地将你学到的知识应用到实践中。你以后遇到问题时，可以随时查阅特定章节。
- en: After a few months of working with this advice, pull out the book once more
    and give it another read. Pay particular attention to the questions in the "[Getting
    Personal](ch23s12.html#getting_personal-id23 "Getting Personal")" sections—work
    out what your next steps must be to improve your code. Each time you go through
    this process, you'll identify new ways to improve your skills.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在几个月按照这些建议工作之后，再次拿出这本书，重新阅读一遍。特别注意“[个人成长](ch23s12.html#getting_personal-id23
    "个人成长")”部分中的问题——找出你为了提高代码质量必须采取的下一步行动。每次你完成这个过程，你都会发现提高技能的新方法。
- en: Maneuver your career into the path of great coders, and glean all you can from
    them. Learn what makes their code good and their attitudes constructive, and how
    you can apply these characteristics to yourself. Seek their advice, criticism,
    review, and opinion. Ask them to mentor you. (Bribe them with popcorn and alcohol
    if you have to!)
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的职业生涯引导到伟大程序员的道路上，并尽可能从他们那里汲取所有知识。学习是什么使得他们的代码优秀，他们的态度建设性，以及你如何将这些特点应用到你自己身上。寻求他们的建议、批评、审查和意见。请他们成为你的导师。（如果你需要，可以用爆米花和酒精来贿赂他们！）
- en: Keep programming, and expand your horizions. Write more code. Try out new techniques.
    Tackle new problems, different languages, and unfamiliar technologies.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续编程，拓展你的视野。编写更多的代码。尝试新的技术。解决新的问题，不同的语言，和不熟悉的技术。
- en: Don't be afraid of making mistakes; you won't become a perfect programmer overnight.
    As you learn, you will almost certainly make many embarrassing faux pas. Don't
    let these stunt your growth or define you as a programmer. Unless you try out
    new techniques, you'll never learn and won't improve. George Bernard Shaw wrote,
    "A life spent making mistakes is more useful than a life spent doing nothing."
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要害怕犯错误；你不可能一夜之间成为完美的程序员。在学习的过程中，你几乎肯定会犯许多令人尴尬的错误。不要让这些错误阻碍你的成长或定义你作为一个程序员的形象。除非你尝试新的技术，否则你永远不会学到东西，也不会有所改进。乔治·萧伯纳写道：“一生都在犯错误的生活比一生无所事事的生活更有价值。”
- en: Receive advice and code review comments with a constructive attitude. Look back
    at what you've done, and see how it can be improved.
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以建设性的态度接受建议和代码审查意见。回顾你所做的一切，看看如何改进。
- en: Develop outside interests that you can use as a frame of reference for technical
    knowledge. If all you ever study is programming, then you will become a very two-dimensional
    person and will not be able to fit code craft into the context of the Real World.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展你可以在技术知识中作为参考框架的课外兴趣。如果你只研究编程，那么你将是一个非常二维的人，并且无法将代码工艺融入现实世界的背景中。
- en: Find the classic books in your field. (*Code Craft* is obviously one of them!)
    Get a copy of each, and digest it well. Every disicpline and every language has
    its renowned gurus—ensure you know who they are and what they've written.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的领域找到经典书籍。（*《代码工艺》*显然是其中之一！）获取每一本书的副本，并好好消化。每个学科和每种语言都有其著名的宗师——确保你知道他们是谁以及他们写了什么。
- en: 'Read the classic software tomes, like:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阅读经典的软件著作，如：
- en: '*The Mythical Man-Month* (Brooks 95)'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《人月神话》* (Brooks 95)'
- en: '*The Psychology of Computer Programming* (Weinberg 71)'
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《计算机编程心理学》* (Weinberg 71)'
- en: '*Peopleware: Productive Projects and Teams* (DeMarco 99)'
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《人件集：高效的项目和团队》* (DeMarco 99)'
- en: '*The Pragmatic Programmer* (Hunt Davis 99)'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《程序员修炼之道》* (Hunt Davis 99)'
- en: '*Code Complete* (McConnell 04)'
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《代码大全》* (McConnell 04)'
- en: '*The Practice of Programming* (Kernighan Pike 99)'
  id: totrans-501
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《编程实践》* (Kernighan Pike 99)'
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* (Gamma et
    al. 94)'
  id: totrans-502
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《设计模式：可复用面向对象软件元素》* (Gamma 等人 94)'
- en: '*Refactoring: Improving the Design of Existing Code* (Fowler 99)'
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《重构：改善既有代码的设计》* (Fowler 99)'
- en: Ask your peers which books they have found valuable. Seek out relevant magazines,
    websites, and conferences.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向你的同行询问他们认为有价值的书籍。寻找相关的杂志、网站和会议。
- en: Teach. Mentor a lesser abled programmer. You'll learn a lot more by passing
    on your wisdom.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教学并指导一个能力较弱的程序员。通过传授你的智慧，你会学到更多。
- en: Broaden your skills base by joining a professional organization like the British
    Computer Society (BCS), the Association for Computing Machinery (ACM), or the
    ACCU ([www.accu.org](http://www.accu.org)). Then join in—contribute. The more
    you participate, the more you'll invest in yourself. The ACCU, for example, is
    highly contributory. It runs mentored developer projects and encourages members
    to write for its periodicals. These organizations run programming contests, provide
    forums for social networking, and often have local chapters where you can meet
    like-minded people who care about the craft of programming.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过加入像英国计算机协会（BCS）、计算机制造协会（ACM）或ACCU ([www.accu.org](http://www.accu.org)) 这样的专业组织来拓宽你的技能基础。然后加入其中——做出贡献。你参与的越多，你对自己投资的就越多。例如，ACCU是一个高度贡献的组织。它运行导师开发者项目，并鼓励成员为其期刊撰写文章。这些组织举办编程竞赛，提供社交网络论坛，并且通常有本地分会，你可以在这里遇到关心编程工艺的志同道合的人。
- en: Have fun! Enjoy cutting code to solve tricky problems. Produce software that
    makes you proud. Confucius said, "If you enjoy what you do, you'll never work
    another day in your life."
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享受乐趣！享受编写代码解决棘手问题。制作让你自豪的软件。孔子说：“如果你喜欢你所做的事情，你将永远不会觉得工作是一天。”
- en: '**KEY CONCEPT**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Take responsibility for improving your skills. Never lose your passion for
    programming or your desire to do it with excellence*.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*承担提高你技能的责任。永远不要失去你对编程的热情或追求卓越的愿望*。'
- en: Appendix A. Answers and Discussion
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 答案和讨论
- en: 'Principles for the Development of a Complete Mind: Study the science of art.
    Study the art of science. Develop your senses—especially learn how to see. Realize
    that everything connects to everything else.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 完整心智发展的原则：研究艺术科学。研究科学艺术。发展你的感官——特别是学习如何观察。认识到万物相互联系。
- en: --Leonardo DaVinci
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: --莱昂纳多·达·芬奇
- en: This part contains my musings on the questions at the end of each chapter. It's
    not a straight answer set—few of the questions have a definite *yes* or *no* response.
    Compare your answers with these.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含了我对每章末尾问题的思考。它不是一个直接的答案集——很少有问题是明确的*是*或*否*的回答。将你的答案与这些进行比较。
- en: The point of these questions is simply to get you thinking, to make you delve
    deeper into each subject, and to spur you to improve your programming skills.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的目的是简单地让你思考，让你深入每个主题，并激励你提高你的编程技能。
- en: If you're thinking of reading this just to get the "answers" without having
    thought about the questions first, I'd really encourage you not to. Spending even
    a little time mulling things over and getting personal will really pay off. As
    Confucius said, "I hear and I forget. I see and I remember. I do and I understand."
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想看看“答案”而不先思考问题，我真心建议你不要这样做。花点时间思考问题并形成个人见解会真正带来回报。正如孔子所说：“听而不闻，视而不见，做而能解。”
- en: '[Chapter 1](ch01.html "Chapter 1. ON THE DEFENSIVE")'
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。关于防御")'
- en: Mull It Over
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: '**Can you have** too much **defensive programming?**'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**防御性编程是否过多？**'
- en: Yes—just as too many comments can degrade code readability, so can many defensive
    checks, if they are bad. Redundant checks can be avoided with careful coding;
    for example, by making a good choice of types.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——正如过多的注释会降低代码可读性一样，过多的防御性检查如果做得不好，也会降低代码质量。通过仔细的编码可以避免冗余检查；例如，通过选择合适的类型。
- en: '**Should you add an assertion to your code for every bug you find and fix?**'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该为每个找到并修复的错误在代码中添加断言吗？**'
- en: Fundamentally, it's not a bad practice. But think about where you'd add the
    assertions. Many, many faults are due to incorrect honoring of API contracts.
    If you passed garbage into a function, you would want to put some *precondition*
    checking inside that function, rather than put a test at the call site. If the
    function returned garbage, you would either fix the function so that it won't
    again (and prove it's fixed) or write some *postconditions*.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这并不是一个坏习惯。但想想你会在哪里添加断言。许多错误都是由于未能正确遵守API契约。如果你向函数传递了垃圾数据，你会在该函数内部进行一些*前置条件*检查，而不是在调用点放置测试。如果函数返回了垃圾数据，你会修复该函数，使其不再发生（并证明其已修复），或者编写一些*后置条件*。
- en: It would be more beneficial to add a new unit test for every bug you find and
    fix.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个找到并修复的错误添加一个新的单元测试会更有益。
- en: '**Should assertions conditionally compile away to nothing in production builds?
    If not, which assertions should remain in release builds?**'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言是否应该在生产构建中条件编译为空？如果不是，哪些断言应该保留在发布构建中？**'
- en: People hold passionate beliefs on this subject. The answer isn't black and white;
    there are powerful arguments for both sides. There are always some very nit-picky
    assertions that really don't *need* to be left in production builds. But some
    assertion occurrences may still interest you in the field.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在这个问题上持有强烈的信念。答案并非非黑即白；双方都有强有力的论据。总有一些非常挑剔的断言实际上在生产构建中并不*需要*留下。但某些断言的出现可能仍然会吸引你的注意。
- en: Now, if you do leave any constraint checks in releases, they *must* change behavior—the
    program shouldn't abort on failure, just log the problem and move on.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在发布版本中留下任何约束检查，它们*必须*改变行为——程序在失败时不应终止，而应记录问题并继续运行。
- en: 'Remember: Genuine run-time error checks should *never* be removed; they should
    never be coded in assertions anyway.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：真正的运行时错误检查*永远*不应该被移除；它们本来就不应该在断言中编码。
- en: '**Are exceptions a better form of defensive barrier than C-style assertions?**'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**异常是否是比C风格断言更好的防御性屏障？**'
- en: They can be. Exceptions behave differently; while propagating back up the call
    stack, an exception can be caught and ignored—suppressing its effect. This makes
    exceptions more flexible tools. You can't ignore an `assert` that aborts execution;
    assertions are lower-level mechanisms.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以。异常的行为不同；在向上传播调用栈的过程中，异常可以被捕获并忽略——抑制其效果。这使得异常成为更灵活的工具。你不能忽略一个会终止执行的`assert`；断言是更低级的机制。
- en: '**Should the defensive checking of pre- and postconditions be put inside each
    function, or around each important function call ?**'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**前置和后置条件的防御性检查是否应该放在每个函数内部，或者围绕每个重要的函数调用？**'
- en: In the function, without a doubt. This way, you only need to write tests once.
    The only reason you'd want to move them out is to gain flexibility, to choose
    what happens when a constraint fails. This isn't a compelling gain for such an
    explosion in complexity and potential for failure.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，毫无疑问。这样，你只需要编写一次测试。你想要将它们移出的唯一原因是为了获得灵活性，以便选择在约束失败时会发生什么。这种复杂性激增和潜在失败的可能性并不足以带来令人信服的收益。
- en: '**Are constraints a perfect defensive tool? What are their drawbacks?**'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**约束是否是一个完美的防御性工具？它们有什么缺点？**'
- en: No, they are nowhere near perfect. Redundant constraints can be pests at best
    and hindrances at worst. For example, you could assert that a function parameter
    `i >= 0`. But it's much better to make `i` an unsigned type that can't contain
    invalid values anyway.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 不，它们远非完美。冗余的约束条件充其量是害虫，最坏的情况下是障碍。例如，你可以断言函数参数`i >= 0`。但将`i`设为无符号类型，这样它就不能包含无效值，会更好。
- en: 'Treat constraints that can be compiled out with a certain degree of suspicion:
    We must carefully check for any side effects (assertions can have subtle indirect
    consequences) and for timing issues in the debug build that alters its behavior
    from a release build. Ensure that assertions are logical constraints and not genuine
    run-time checks that mustn''t be compiled out. It *is* possible to put bugs in
    the bug-defense code!'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 对那些可以被编译掉的约束条件持一定程度的怀疑：我们必须仔细检查任何副作用（断言可能具有微妙间接后果）以及在调试构建中改变其行为的计时问题。确保断言是逻辑约束，而不是真正的运行时检查，这些检查不应该被编译掉。在**错误防御代码**中放入错误是**可能的**！
- en: But carefully used, constraints are still far better than dancing barefoot over
    the hot coals of chance.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果谨慎使用，限制条件仍然远比在机会的炽热煤炭上赤脚跳舞要好。
- en: '**Can you avoid defensive programming?**'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能避免防御性编程吗？**'
- en: '**If you designed a better language, would defensive programming still be necessary?
    How could you do this?**'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你设计了一种更好的语言，防御性编程仍然有必要吗？你该如何做到这一点？**'
- en: '**Does this show that C and C++ are flawed because they have so many areas
    for problems to manifest?**'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这表明C和C++因为存在许多问题表现区域而存在缺陷吗？**'
- en: Some language features certainly could be designed to avoid errors. For example,
    C doesn't check the index of any array lookup you perform. As a result, you can
    crash the program by accessing an invalid memory address. The Java run time, on
    the other hand, checks *every* array index before lookup, so such an catastrophe
    will never arise. (Bad indexes will still cause an error though, just a better
    defined class of failure.)
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言特性当然可以设计成避免错误。例如，C不会检查你执行的任何数组查找的索引。结果，你可以通过访问无效的内存地址来崩溃程序。另一方面，Java运行时在查找之前会检查**每个**数组索引，因此这种灾难永远不会发生。（坏索引仍然会导致错误，但错误类型定义得更好。）
- en: Despite the long list of "improvements" you could make to the liberal C specification
    (and I urge you to think of as many as you can), you'll never be able to create
    a language that doesn't need defensive programming. Functions will always need
    to validate parameters, and classes will always need invariants to check that
    their data is internally consistent.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以对宽松的C规范做出很多“改进”（我敦促你尽可能多地思考），但你永远无法创建一种不需要防御性编程的语言。函数始终需要验证参数，类始终需要检查不变性，以确保其数据内部一致。
- en: Although C and C++ do provide plenty of opportunity for things to go wrong,
    they also provide a great deal of power and expression. Whether that makes the
    languages flawed depends on your viewpoint—this is a topic ripe for holy war.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C和C++确实提供了很多出错的机会，但它们也提供了大量的功能和表达能力。这使语言存在缺陷取决于你的观点——这是一个容易引发圣战的议题。
- en: '**What sort of code do you not need to worry about writing defensively?**'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你不需要担心编写哪些类型的防御性代码？**'
- en: I've worked with people who refused to put any defensive code into an old program
    because it was *so bad* that their defenses would make no difference. I managed
    to resist the urge to whack them with a large mallet.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾与一些人合作，他们拒绝在旧程序中添加任何防御性代码，因为程序**太糟糕**了，他们的防御措施不会有任何作用。我设法抑制了用大锤敲打他们的冲动。
- en: You might argue that a small, stand-alone, single-file program or a test harness
    doesn't need this sort of careful defensive code or any rigorous constraints.
    But even in these situations, not being careful is just being sloppy. We should
    aim to be defensive all the time.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，一个小型独立单文件程序或测试框架不需要这种类型的谨慎防御性代码或任何严格的约束。但即使在这些情况下，不谨慎也只是粗心大意。我们应该始终努力进行防御。
- en: Getting Personal
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: '**How carefully do you consider each statement that you type? Do you relentlessly
    check every function return code, even if you''re **sure** a function will not
    return an error?**'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你仔细考虑过你输入的每一句话吗？即使你**确定**一个函数不会返回错误，你也会不懈地检查每个函数的返回代码吗？**'
- en: I bet you don't check everything. It's far too easy to overlook certain function
    return codes, especially since some are deemed more important than others. How
    many C programmers check the return value of `printf`? How many actually *know*
    that it returns anything?
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我打赌你不会检查每一件事。很容易忽略某些函数返回码，尤其是当一些被认为比其他更重要时。有多少C程序员检查`printf`的返回值？有多少人实际上*知道*它会返回某些内容？
- en: '**When you document a function, do you state the pre- and postconditions?**'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当你记录一个函数时，你会声明前和后置条件吗？**'
- en: '**Are they always implicit in the description of what the function does?**'
  id: totrans-548
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它们在函数功能的描述中总是隐含的吗？**'
- en: '**If there are no pre- or postconditions, do you explicitly document this?**'
  id: totrans-549
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果没有前或后置条件，你会明确记录这一点吗？**'
- en: 'No matter how obvious you think a contract is (from the function name or its
    description), explicitly stating the constraints removes any ambiguity—remember,
    it''s always better to remove areas of assumption. Explicitly writing *Preconditions:
    None* will document a contract explicitly.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你认为合同有多明显（从函数名称或其描述中），明确地陈述约束条件可以消除任何歧义——记住，总是最好消除假设的区域。明确写出*先决条件：无*将明确记录合同。
- en: Of course, you don't want every function to explicitly restate a global precondition.
    It would be laborious and tedious. If an entire API expects that pointer values
    mustn't be null, it's arguably better to document this once, globally.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不想让每个函数都明确重申全局先决条件。这将是一项繁重而乏味的工作。如果整个API都期望指针值不能为空，那么在全球范围内记录这一点可能更好。
- en: '**Many companies pay lip service to defensive programming. Does your team recommend
    it? Take a look at the codebase—do they really? How widely are constraints codified
    in assertions? How thorough is the error checking in each function?**'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**许多公司只是口头上提到防御性编程。你的团队推荐它吗？看看代码库——他们真的这样做吗？约束条件在断言中是如何编码的？每个函数中的错误检查有多彻底？**'
- en: Very few companies have a culture of excellent code with the right level of
    defense. Code reviews are a good way to bring a team's code up to a reasonable
    standard; many eyes see many more potential errors.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有公司拥有具有适当防御级别的优秀代码文化。代码审查是提高团队代码到合理标准的好方法；众人的眼睛能看到更多潜在的错误。
- en: '**Are you naturally paranoid enough? Do you look both ways before crossing
    the road? Do you eat your greens? Do you check for every potential error in your
    code, no matter how unlikely?**'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你天生就足够偏执吗？过马路前你会两边都看吗？你会吃你的绿色蔬菜吗？你会检查代码中每一个可能出现的错误，无论可能性有多小吗？**'
- en: '**How easy is it to do this thoroughly? Do you forget to think about errors?**'
  id: totrans-555
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**做到彻底有多容易？你会忘记考虑错误吗？**'
- en: '**Are there any ways to help yourself write more thorough defensive code?**'
  id: totrans-556
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有什么方法可以帮助你编写更全面的防御性代码吗？**'
- en: No one finds it naturally easy—thinking the worst of your carefully crafted
    new code is contrary to a programmer's instincts. Instead, expect the worst of
    any people who will be using your code. They're nowhere near as conscientious
    a programmer as you are!
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人觉得这很自然容易——认为你精心编写的代码会有问题，这与程序员的直觉相悖。相反，你应该预期任何将使用你的代码的人都会做出最坏的情况。他们远不如你那样尽责的程序员！
- en: A very helpful technique is to write unit tests for each function or class.
    Some experts strongly advise doing this *before* writing a function, which makes
    a lot of sense. It helps you to think about all the error cases, rather than happily
    trusting that your code will work.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的技术是为每个函数或类编写单元测试。一些专家强烈建议在编写函数之前就做这件事，这很有道理。这有助于你考虑所有可能的错误情况，而不是愉快地相信你的代码会正常工作。
- en: '[Chapter 2](ch02.html "Chapter 2. THE BEST LAID PLANS")'
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章。最佳计划")'
- en: Mull It Over
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: '**Should you alter the layout of legacy code to conform to your latest code
    style? Is this a valuable use of code reformatting tools?**'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该改变遗留代码的布局以符合你最新的代码风格吗？这是代码格式化工具的有价值用途吗？**'
- en: It's usually safest to leave legacy code however you find it, even if it's ugly
    and hard to work with. I'd only entertain reformatting if I was absolutely sure
    that none of the original authors would ever need to return.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，保留遗留代码的原始状态是最安全的，即使它很丑陋且难以操作。我只有在绝对确定原始作者永远不会需要返回时，才会考虑重新格式化。
- en: By reformatting, you lose the ability to easily compare a particular revision
    of the source with a previous one—you'll be thrown by many, many formatting changes
    which may hide the one important difference you really need to see. You also risk
    introducing program errors in the reformatting.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重排，你将失去轻松比较源代码特定版本与之前版本的能力——你将被许多、许多格式更改所困扰，这些更改可能会隐藏你真正需要看到的那个重要差异。你还有在重排中引入程序错误的风险。
- en: As far as code reformatting tools go, they're nice curiosities, but I don't
    advocate the use of them. Some companies insist on running source files through
    beautifiers before checking any code into their repository. The advantage is that
    all code is homogenized, pasteurized, and uniformly formatted. The major disadvantage
    is that no tool is perfect; you'll lose some helpful nuances of the author's layout.
    Unless all the programmers on your team are gibbons, don't use a reformatting
    tool.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 就代码重排工具而言，它们是很好的奇观，但我并不提倡使用它们。一些公司坚持在将任何代码检查到他们的存储库之前，通过美化器运行源文件。优点是所有代码都被同质化、消毒并统一格式化。主要缺点是没有任何工具是完美的；你将失去一些作者布局的有用细微差别。除非你团队上的所有程序员都是长臂猿，否则不要使用重排工具。
- en: '**A common layout convention is to split source lines at a set number of columns.
    What are the pros and cons of this? Is it useful?**'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**常见的布局约定是在一定数量的列中拆分源行。这种做法的优缺点是什么？它有用吗？**'
- en: As with many presentation concerns, there is no absolute answer; it is a matter
    of personal taste.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多展示关注点一样，没有绝对的答案；这是一个个人品味的问题。
- en: I like to split my code up so that it fits on an 80-column display. I've always
    done that, so it's a matter of habit as much as anything else. I don't disagree
    with people who like long lines, but I find long lines hard to work with. I set
    my editor up to wrap continuous lines rather than provide a horizontal scrollbar
    (horizontal scrolling is clumsy). In this environment, long lines tend to ruin
    the effect of any indentation.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢将我的代码拆分，以便它能在80列显示中显示。我一直这样做，所以这更多的是一种习惯，而不是其他任何事情。我不反对那些喜欢长行的人，但我发现长行很难处理。我将我的编辑器设置为自动换行而不是提供水平滚动条（水平滚动很笨拙）。在这种环境中，长行往往会破坏任何缩进的视觉效果。
- en: As I see it, the main advantage of fixed column widths is not printability,
    as some would claim. It's the ability to have several editor windows open side
    by side on the same display.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 如我看来，固定列宽的主要优势不是可打印性，正如有些人所声称的那样。它是在同一显示上并排打开几个编辑器窗口的能力。
- en: In practice, C++ produces very long lines. It's more verbose than C; you end
    up calling member functions on objects referenced by another object through a
    templated container. . . . There are strategies to manage the many, many, long
    lines this may lead to. You can store intermediate references in temporary variables,
    for example.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，C++会产生非常长的行。它比C更冗长；你最终会在通过模板容器引用的其他对象上调用成员函数。... 有策略可以管理由此产生的许多、许多长行。例如，你可以将中间引用存储在临时变量中。
- en: '**How detailed should a reasonable coding standard be?**'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个合理的编码标准应该有多详细？**'
- en: '**How serious are deviations from the style? How many limbs should be amputated
    for not following it?**'
  id: totrans-571
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**偏离风格的严重程度如何？不遵守它应该截肢多少肢？**'
- en: '**Can a standard become too detailed and restrictive? What would happen if
    it did?**'
  id: totrans-572
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个标准可以过于详细和限制性吗？如果它确实如此，会发生什么？**'
- en: Six limbs should be amputated for deviations from any coding standard.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何编码标准的偏离，应该截肢六肢。
- en: The correct answer really depends on the exhaustiveness of the coding standard
    and the coding culture you work in. There are usually much bigger software problems
    to address than a misplaced bracket, but brackets are easier to moan about. I
    have seen many coding standards that are so prescriptive and paralyzing that the
    poor programmers have just plain ignored them. To be useful and to be accepted,
    a coding standard should provide a little room for maneuvering, perhaps with a
    *best practice* approach given as an example.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案实际上取决于你所在环境中编码标准的详尽性和编码文化。通常有更大的软件问题需要解决，而不仅仅是括号放置不当的问题，但括号更容易抱怨。我见过许多如此规定性和令人瘫痪的编码标准，以至于可怜的程序员们只是简单地忽略了它们。为了有用和被接受，编码标准应该提供一些操作空间，也许可以通过提供作为例子的*最佳实践*方法来实现。
- en: '**When defining a new presentation style, how many items or cases need layout
    rules? What other presentation rules must be provided? List them**.'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在定义新的展示风格时，需要多少项目或案例来布局规则？还需要提供哪些其他展示规则？列出它们**。'
- en: 'If you write out each layout rule individually, there will be an awfully large
    number of cases to consider. Coding style is a delicate interplay of many forces:
    indentation, yes, but also internal spacing, naming, positioning of operators,
    presentation of parentheses, contents of files, use and ordering of header files,
    and more, and more.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你单独写出每个布局规则，将需要考虑大量的情况。编码风格是许多力量的微妙互动：缩进，是的，但还有内部空格、命名、操作符的位置、括号的展示、文件内容、头文件的使用和排序等等，还有更多。
- en: The following list of presentation items *is* long, but it's far from complete.
    It's a good starting point for a style checklist. In practice, some items are
    more important to standardize than others. As you read this list, make sure that
    you have considered a personal preference for each item. Also make sure that you
    know the correct convention for your current software project.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的展示项目 *是* 很长的，但远未完整。它是风格检查表的良好起点。在实践中，某些项目比其他项目标准化更重要。当你阅读这个列表时，确保你已经考虑了每个项目的个人偏好。同时，确保你知道你当前软件项目的正确约定。
- en: '**Code margins**'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码边距**'
- en: The number of spaces per indent shapes the left edge of the code. It's common
    to see two- or four-space indents, though some programmers diplomatically choose
    three spaces. Smaller indents mean that you don't run into the right margin as
    quickly, but they look cluttered and make it harder to differentiate among levels.
    Larger indents are more distinct, but you run out of space more quickly.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个缩进级别的空格数量决定了代码左侧的边缘形状。通常可以看到两或四个空格的缩进，尽管一些程序员选择三格作为外交策略。较小的缩进意味着你不会很快遇到右边缘，但它们看起来很杂乱，并且难以区分层次。较大的缩进更明显，但你很快就会用完空间。
- en: Whether to indent with tabs or spaces is a long-running debate that has driven
    many programmers to therapy. Spaces are more portable; they'll display the same
    width in any editor. When displaying code using a variable width font,^([[1](#ftn.APP-FN-1)])
    tabs can give better alignment.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用制表符或空格缩进是一个长期存在的争议，它驱使许多程序员寻求心理治疗。空格更便携；在任何编辑器中都会显示相同的宽度。当使用可变宽度字体显示代码时，^([[1](#ftn.APP-FN-1)]),
    制表符可以提供更好的对齐。
- en: Page width determines how you format the right-hand code edge. You can limit
    lines to a fixed number of columns or let them grow forever, requiring horizontal
    window navigation. Fixed pages are often 79 or 80 characters wide. This is historic;
    80 characters is a common terminal width, but the last column was not always usable
    for display.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面宽度决定了你如何格式化右侧代码边缘。你可以将行限制在固定数量的列中，或者让它们无限增长，需要水平窗口导航。固定页面通常宽度为79或80个字符。这是历史性的；80个字符是常见的终端宽度，但最后一列并不总是可用于显示。
- en: There are choices for aligning certain constructs. At which level do you put
    `public:`, `private:`, and `protected:` in a class declaration? Where do `case`
    labels go in `switch` statements? How do you format labels for the `goto` statements
    you never use?^([[2](#ftn.APP-FN-2)])
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对某些结构进行对齐时，有多种选择。在类声明中，你将 `public:`, `private:`, 和 `protected:` 放在哪个级别？在 `switch`
    语句中，`case` 标签应该放在哪里？你如何格式化你几乎从不使用的 `goto` 语句的标签？^([[2](#ftn.APP-FN-2)])
- en: '**Spacing and separation**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格和分隔**'
- en: 'You can line up pieces of code with an internal tabular layout; for example,
    aligning operators in the same column across subsequent lines. This provides visual
    emphasis for the function of a block of statements. However, it does require extra
    typing and maintenance effort, and some programmers don''t feel it is justified.
    A tabular horizontal layout would look something like:'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用内部表格布局来对齐代码片段；例如，在后续行中对同一列中的操作符进行对齐。这为语句块的功能提供了视觉强调。然而，这需要额外的输入和维护工作，并且一些程序员认为这样做是不合理的。表格式水平布局可能看起来像这样：
- en: '[PRE0]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Whitespace can appear pretty much anywhere, and there are different ways to
    space out individual code statements. It''s a good idea to put spaces around operators,
    like this: `hamster = "cute"`. It''s akin to having spaces between words when
    you write. The alternative, `hamster="ugly"`, looks cramped and dense.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白可以几乎出现在任何地方，并且有不同方式来分隔单个代码语句。在操作符周围放置空格是个好主意，例如：`hamster = "cute"`。这就像你在写的时候单词之间有空间一样。另一种选择，`hamster="ugly"`，看起来拥挤且密集。
- en: 'Similarly, function calls can be spaced in various ways. You might employ one
    of the following formats:'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，函数调用也可以以各种方式缩进。你可能采用以下格式之一：
- en: '[PRE1]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many view the latter option as bad—a mathematical equation wouldn't have a space
    after the function name. (The mother-in-law, however, might be a genuinely edible
    commodity.)
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多人认为后一种选择是错误的——数学方程式在函数名后面不会有空格。（然而，岳母可能真的是一种真正的可食用商品。）
- en: Should you follow a similar convention for keywords? How does `while(lionIsAsleep)`
    look? Cramped. Keywords aren't functions; they read more like words, so it's most
    common to see spaces around them.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你是否应该遵循类似的约定来处理关键字？`while(lionIsAsleep)`看起来如何？拥挤。关键字不是函数；它们读起来更像单词，因此通常在它们周围会有空格。
- en: If code gets too long for a single line, it must be split, but *where* to split
    is another choice. Naturally, you'd break in the most logical place, but one man's
    logic is another man's folly. Lines are generally broken around an operator, but
    whether before or after it—whether the operator appears on the end of the previous
    or beginning of the next line—is a matter of taste.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码太长，无法在一行中显示，就必须进行拆分，但拆分的位置又是一个选择。自然，你会在最合理的地方进行拆分，但一个人的逻辑可能是另一个人的愚蠢。通常，代码会在操作符周围进行拆分，但是在操作符之前还是之后——操作符是否出现在上一行的末尾或下一行的开头——这是一个品味问题。
- en: '**Variables**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**'
- en: 'A classic C/C++ contention is where to put the asterisk in a pointer declaration
    (a battle often called Star Wars). You can chose between these three:'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典的C/C++争论是指针声明中星号的位置（常被称为星球大战）。你可以在这三种选择之间进行选择：
- en: '[PRE2]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first two associate the "pointeryness" with the variable and with the type,
    respectively. The problem with associating with type is it doesn''t work as expected
    for statements like this: `int* weasel, ferret;`. The third version is a reasonable
    fence-sitting alternative, but isn''t as common.'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前两种将“指针性”与变量和类型分别关联。与类型关联的问题在于它对于像`int* weasel, ferret;`这样的语句并不像预期的那样工作。第三种是一个合理的折中方案，但并不常见。
- en: Some C/C++ standards mandate that all constant names should be in uppercase
    letters to make them clear. Some argue that only preprocessor macro names should
    be capitalized.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些C/C++标准规定，所有常量名称都应该使用大写字母，以便清晰。有些人认为只有预处理宏名称应该大写。
- en: '**Lines of code**'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码行**'
- en: Exactly *what* goes on each line is a layout concern; it is often mandated that
    every individual statement goes on its own line, making each one distinct and
    clear.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行上确切地放什么是一个布局问题；通常要求每个单独的语句都在自己的行上，使得每个语句都清晰且易于区分。
- en: This leads on to the issue of *side effects* in statements; should you allow
    code like `index[count++] = 2` or permit assignments in `if`s?
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这引出了语句中的*副作用*问题；你是否允许代码如`index[count++] = 2`或允许在`if`中赋值？
- en: 'Some presentation styles will place code on the same line as an opening brace:'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些展示风格会将代码放在与开括号相同的行上：
- en: '[PRE3]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Constructs**'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造**'
- en: 'Should you always include braces, even if there''s only one statement within
    them? You might allow braces to be missed when the code follows on the same line,
    like this:'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否应该始终包含大括号，即使其中只有一个语句？你可能允许当代码在同一行上继续时省略大括号，如下所示：
- en: '[PRE4]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's common to see `else` clauses aligned in the same column as their respective
    `if`, but you'll sometimes see them placed at a subordinate indent level.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常可以看到`else`子句与相应的`if`在同一列对齐，但有时也会看到它们放置在从属缩进级别。
- en: 'How important is it to make *special cases* clear? Some coding standards mandate
    that fall-throughs between `switch` statement `case`s should be flagged with comments.
    Similarly, *no-ops* in loops should be flagged to avoid confusion; otherwise,
    this little bodiless loop that finds the end of a C string `str` may confuse the
    unwary:'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使特殊情况清晰有多重要？一些编码标准规定，在`switch`语句的`case`之间应该用注释标记跳过；同样，循环中的`no-ops`应该标记以避免混淆；否则，这个没有身体的循环可能会让不小心的人困惑，它寻找C字符串`str`的结尾：
- en: '[PRE5]'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Should C++ inline methods be put inside the class declaration, outside it (directly
    afterward), or in a separate source file?
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++内联方法应该放在类声明内、外（直接之后），还是单独的源文件中？
- en: '**Files**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**'
- en: The most basic decision is how to split a project into files and what information
    to put into each one. Is there one file per class or per function? Or can you
    split files into smaller or larger units than this, perhaps per library or section
    of code? What if there are a lot of very small related classes? Do you really
    want lots of very small related files?^([[3](#ftn.APP-FN-3)])
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最基本的决定是如何将项目拆分成文件以及将什么信息放入每个文件中。是每个类或每个函数一个文件吗？或者可以将文件拆分成比这更小或更大的单元，比如每个库或代码部分？如果有许多非常小的相关类怎么办？你真的希望有很多非常小的相关文件吗？^([[3](#ftn.APP-FN-3)])
- en: Conventions for splitting a file into sections differ. Some programmers like
    to insert a number of blank lines as a separator, some prefer comment blocks,
    some like reams of ASCII art.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件分割成部分的约定不同。一些程序员喜欢插入一些空白行作为分隔符，一些更喜欢注释块，一些喜欢大量的 ASCII 艺术品。
- en: In C/C++, the exact order of `#include`d files may be fixed by a presentation
    style. There are different schools of thought here. Some prefer to neatly order
    system includes first, then project includes, then file-specific includes. Others
    feel that the exact opposite is safer; it *can* prevent one header file from accidentally
    relying on headers normally included before itself. Some standards suggest that
    no *header file* should *ever* `#include` another, leaving it to be done long-hand
    in every implementation file.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C/C++ 中，`#include` 文件的确切顺序可能由展示风格固定。这里有不同的观点。有些人喜欢首先整齐地排列系统包含，然后是项目包含，然后是特定文件包含。其他人认为完全相反的做法更安全；它*可以*防止一个头文件意外地依赖于通常在其之前包含的头文件。一些标准建议没有任何*头文件*应该*永远*
    `#include` 另一个，将其留给每个实现文件手动完成。
- en: '**Misc**'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**杂项**'
- en: There will always be plenty of other issues specific to particular coding situations.
    How do you format embedded SQL commands in code that performs database access?
    Do you require consistent formatting in a project across different languages?
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 总会有许多特定于特定编码情况的其他问题。如何在执行数据库访问的代码中格式化内嵌的 SQL 命令？你是否需要在跨不同语言的项目中保持一致的格式？
- en: '**Which is more important—good code presentation or good code design? Why?**'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个更重要——良好的代码展示还是良好的代码设计？为什么？**'
- en: This is really a very artificial question. Both are fundamental for good code,
    and you should never be asked to sacrifice one for the other. If you ever are,
    beware. However, which one you just chose may say a lot about you as a programmer.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个非常人为的问题。两者对良好的代码都是基本的，你不应该被要求为了另一个而牺牲其中一个。如果你被要求这样做，要小心。然而，你刚刚选择的是否能说很多关于你作为程序员的事情。
- en: Bad formatting is certainly easier to fix than bad design, especially if you
    use clever tools to homogenize your code's formatting.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的格式化当然比糟糕的设计更容易修复，特别是如果你使用巧妙的工具来统一你的代码格式。
- en: 'There is an interesting connection between presentation and design: Bad presentation
    often shows that the code was produced by a bad programmer, which probably means
    that it suffers from bad internal design too. Or it may imply that the code has
    been maintained by a series of different programmers, with a subsequent loss of
    the initial code design.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 展示和设计之间存在有趣的联系：糟糕的展示往往表明代码是由一个糟糕的程序员编写的，这可能意味着它也遭受了糟糕的内部设计。或者它可能意味着代码是由一系列不同的程序员维护的，随之而来的是初始代码设计的丢失。
- en: Getting Personal
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**Do you write in a consistent style?**'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否以一致的风格编写代码？**'
- en: '**When you work with other people''s code, which layout style do you adopt—theirs
    or your own?**'
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当你与其他人的代码一起工作时，你会采用哪种布局风格——他们的还是你自己的？**'
- en: '**How much of your coding style is dictated by your editor''s auto-formatting?
    Is this an adequate reason for adopting a particular style?**'
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的编码风格有多少是由你的编辑器的自动格式化决定的？这是采用特定风格的一个充分理由吗？**'
- en: If you can't alter the way your editor positions the cursor for you, you shouldn't
    be using it (either you're too inept, or your editor is).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能改变你的编辑器为你定位光标的方式，你不应该使用它（要么你太笨拙，要么你的编辑器有问题）。
- en: If you can't write code in a consistent style, you should have your programmer's
    license revoked. If you can't follow someone else's presentation style, you should
    be forced to maintain BASIC for the rest of your career.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能以一致的风格编写代码，你应该被撤销程序员执照。如果你不能遵循他人的展示风格，你应该被迫在余生中维护 BASIC。
- en: 'Guard your attitude: The typical programmer cares more about his code, personal
    practices, and individual layout fetishes than the overall health of the project.
    Too often, there is an *individual versus team* dilemma. If a programmer rebels
    against an imposed house style or can''t maintain code using its existing presentation
    style, it is a bad sign. This suggests that the programmer can''t see the big
    picture.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的态度：典型的程序员更关心他的代码、个人实践和个人的布局迷恋，而不是项目的整体健康。过于频繁地，会出现*个人与团队*的困境。如果一个程序员反抗强加的房屋风格或无法使用现有的展示风格来维护代码，这是一个坏信号。这表明程序员看不到大局。
- en: '**Tabs: Are they a work of the devil, or the best thing since sliced bread?
    Explain why**.'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**制表符：它们是魔鬼的杰作，还是自从切片面包以来最好的东西？请解释原因**。'
- en: '**Do you know if your editor inserts tabs automatically? Do you know what your
    editor''s tab stop is?**'
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你知道你的编辑器是否自动插入制表符吗？你知道你的编辑器的制表符停止位置是多少吗？**'
- en: '**Some hugely popular editors indent with a mixture of tabs and spaces. Does
    this make the code any less maintainable?**'
  id: totrans-628
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一些非常流行的编辑器使用制表符和空格的混合来缩进。这会使代码的可维护性降低吗？**'
- en: '**How many spaces should a tab correspond to?**'
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**制表符应该对应多少个空格？**'
- en: Since this is such a religious issue, I'll just say *Tabs suck!* and back away
    quickly. Well, actually I'll add that the only thing more evil than indenting
    with tabs is indenting with tabs *and* spaces—a nightmare!
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个如此宗教性的问题，我只能说**制表符很糟糕**，然后迅速退却。实际上，我会补充说，比使用制表符缩进更糟糕的是同时使用制表符和空格缩进——这是一个噩梦！
- en: If your editor *is* inserting tabs (and probably spaces) without you noticing,
    try using another editor for a while to appreciate how frustrating it is. Try
    setting your tab stop to a different value, and see what a mess it makes of the
    code. *Everyone uses the same editor, so it doesn't matter* is not a professional
    attitude. Everyone doesn't use the same editor, so it *does* matter.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编辑器正在不让你察觉的情况下插入制表符（以及可能的空间），尝试使用其他编辑器一段时间，以体会这是多么令人沮丧。尝试将你的制表符停止位置设置为不同的值，看看它会把代码搞成什么样子。“每个人都使用相同的编辑器，所以这无关紧要”不是一种专业态度。并不是每个人都使用相同的编辑器，所以这**确实**很重要。
- en: You'll hear people recommend their choice of tab-stop length and carefully justify
    their opinions. That's all very well; in fact a respected study claims that a
    *three-* or *four-* space tab stop provides optimum readability. (I favor four
    spaces because I don't like odd numbers!) However, a tab should correspond to
    *no* fixed number of spaces. A tab is a tab, which is not a space or any multiple
    thereof. For code laid out using tabs, it shouldn't matter exactly how many spaces
    the tab is displayed as—the code should read well, regardless. Unfortunately,
    I have rarely seen tab-indented code that works this way. All too often, tabs
    and spaces are mixed together to make code line up neatly. This works fine with
    a tab stop set as the author intended. But it makes an unholy mess with any other
    setting.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你会听到人们推荐他们选择的制表符长度，并仔细地为自己的观点辩护。这很好；事实上，一项受尊敬的研究声称，**三**个或**四**个空格的制表符停止位置提供最佳的可读性。（我更喜欢四个空格，因为我不喜欢奇数！）然而，制表符应该对应**不**是固定数量的空格。制表符就是制表符，它不是空格或其任何倍数。对于使用制表符布局的代码，制表符显示的确切空格数并不重要——代码应该易于阅读。不幸的是，我很少看到按照这种方式工作的制表符缩进代码。过于频繁地，制表符和空格被混合在一起，以使代码整齐对齐。当制表符停止位置设置为作者意图时，这没问题。但是，任何其他设置都会造成混乱。
- en: '**Do you have a preferred layout style?**'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你有偏好的布局风格吗？**'
- en: '**Describe it in a series of simple statements. Be complete. Include, for example,
    how you format** `switch` **statements and split up long lines**.'
  id: totrans-634
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用一系列简单的陈述来描述它。要完整。例如，说明你是如何格式化**`switch`**语句和拆分长行的。**'
- en: '**How many statements did it take? Is that what you expected?**'
  id: totrans-635
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**需要多少个语句？这是你预期的吗？**'
- en: '**Does your company have a coding standard?**'
  id: totrans-636
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的公司有编码标准吗？**'
- en: '**Do you know where it is? Is it advertised? Have you read it?**'
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你知道它在哪吗？它被宣传了吗？你读过它吗？**'
- en: '**If yes: Is it any good? Perform an honest critique, and feed your comments
    back to the document owners**.'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果答案是肯定的：它是否足够好？进行一次诚实的批判，并将你的评论反馈给文档所有者**。'
- en: '**If no: Should it? ( Justify your answer.) Is there a common unwritten code
    style that everyone adopts? Can you drive the adoption of a standard?**'
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果答案是否定的：它应该吗？（解释你的答案。）是否存在一个大家普遍遵循的未成文代码风格？你能推动标准的采用吗？**'
- en: '**Is there more than one standard used, perhaps one per project? If so, how
    is code shared among projects?**'
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是否使用了不止一个标准，也许每个项目一个？如果是这样，项目之间是如何共享代码的？**'
- en: Make sure you are aware of any style guides (or undocumented conventions) that
    you should work to.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你了解任何你应该努力遵守的风格指南（或未记录的惯例）。
- en: 'This question was partly motivated by personal experience: I was working in
    a large organization with several isolated departments, each following its own
    set of guidelines. As the separate products slowly converged, it made technological
    (and sound financial) sense to combine some parts of the codebases. The result
    was a mess of code with different styles of interface, different presentation,
    even different language use. It looked unorganized and unprofessional and was
    very hard to work with. It was painful.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题部分是由个人经验激发的：我在一个大型组织中工作，有几个孤立的部门，每个部门都遵循自己的一套指南。随着单独的产品逐渐合并，将代码库的一些部分合并起来在技术上（以及合理的财务上）是有意义的。结果是代码混乱，接口风格不同，展示方式不同，甚至语言使用也不同。它看起来杂乱无章，不够专业，而且很难工作。这很痛苦。
- en: '**How many different layout styles have you followed?**'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你跟随过多少种不同的布局风格？**'
- en: '**Which did you feel most comfortable with?**'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你感觉哪一个最舒适？**'
- en: '**Which was the most rigorously defined?**'
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪一个定义得最严格？**'
- en: '**Is there a link?**'
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有没有链接？**'
- en: After a few years of programming, it's easy to settle into your own peculiar
    layout style without really thinking about how or why you arrived at it. Undoubtedly,
    it was a result of other code you've read and worked with, mixed with your own
    personal tastes. Take some time to consider this, and ensure that your coding
    style is sound. Perhaps now is the time to modify and improve it.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 几年编程之后，很容易陷入自己独特的布局风格，而不真正思考你是如何或为什么达到这种风格的。毫无疑问，这是由于你阅读和合作过的其他代码，以及你自己的个人品味混合的结果。花点时间考虑这个问题，并确保你的编码风格是合理的。也许现在是时候修改和改进它了。
- en: Changing your style isn't straightforward. There will still be your old legacy
    code to deal with—should you convert it to the new style, or leave it in the previous
    state?
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 改变你的风格并不简单。你仍然需要处理你的旧遗留代码——你应该将其转换为新的风格，还是让它保持原来的状态？
- en: Grab a text editor and type in this bit of code; it calculates the *n* th prime
    number. It's written in one particular coding style. Present it as *you'd* like
    to see it. Don't try to change the implementation at all.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器，输入这段代码；它计算第 *n* 个素数。它使用了一种特定的编码风格。以你希望看到的方式呈现它。不要尝试改变实现方式。
- en: '[PRE6]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That is a representative bit of Real World code, so don't dismiss this as a
    stupid and tedious exercise.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段典型的现实世界代码，所以不要把它当作一个愚蠢而乏味的练习来忽视。
- en: Note that I haven't given any suggested answer here. My reformatting is just
    as valid as yours, and indeed as valid as the original format. That's why this
    is a *Getting Personal* question.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有在这里给出任何建议答案。我的重新格式化和你的一样有效，实际上和原始格式一样有效。这就是为什么这是一个*个人化*问题。
- en: If you're reading these answers without chewing over the questions at all, go
    on—give this one a try. The book can wait while you type in a few lines. . . .
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读这些答案时完全没有思考过这些问题，那就继续吧——试一试这个。书可以先放一放，等你输入几行文字……
- en: Now, take a look at what you've written.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看你写下的内容。
- en: How different is your version? How many specific changes did you make?
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的版本有多不同？你做了多少具体的变化？
- en: 'For each change, ask yourself: Is it a personal aesthetic preference, or can
    you justify the change with some rationale? Question this rationale—is it truly
    valid? How strongly would you be prepared to defend it?'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一次改变，问问自己：这是个人审美偏好，还是你能用某种理由来证明这个改变是合理的？质疑这个理由——它真的是有效的吗？你准备好多么坚定地捍卫它？
- en: How comfortable were you with the original format? Did it bother you to read?
    Could you work in that coding style if you encountered code like it? *Should*
    you be able to become comfortable with it?
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对原始格式有多舒适？阅读它让你感到困扰吗？如果你遇到类似这样的代码，你能在这种编码风格下工作吗？*你应该*能够适应它？
- en: Give yourself bonus points if you wanted to reimplement the code to be more
    efficient, and extra bonus points if you resisted the temptation. (Premature optimization
    is a Bad Thing—see "[The Nuts and Bolts](ch11s05.html "The Nuts and Bolts")" on
    page 206.)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要重新实现代码以使其更高效，那么给你加分。如果你抵制了诱惑，那么额外加分。（过早优化是一个坏习惯——参见第206页的“[螺丝钉和螺栓](ch11s05.html
    "螺丝钉和螺栓")”）。
- en: '* * *'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#APP-FN-1)]) More common in published code than in a source code editor.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#APP-FN-1)]) 在已发布的代码中比在源代码编辑器中更常见。
- en: ^([[2](#APP-FN-2)]) Because, of course, no high-quality programmer will use
    `goto`s in these enlightened times—see "[Structured Programming](ch22.html#structured_programming
    "Structured Programming")" on page 421.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#APP-FN-2)]) 因为，当然，在这样一个开明的时代，没有高质量的程序员会使用 `goto`——参见第421页的“[结构化编程](ch22.html#structured_programming
    "结构化编程")”。
- en: ^([[3](#APP-FN-3)]) Java answers this by mandating the physical mapping of classname
    to filename.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#APP-FN-3)]) Java通过强制类名到文件名的物理映射来回答这个问题。
- en: '[Chapter 3](ch03.html "Chapter 3. WHAT''S IN A NAME?")'
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。名称的含义是什么？")'
- en: Mull It Over
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Are these good variable names? Answer with either** yes (explain why, and
    in what context), no (explain why), or can''t tell (explain why).'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这些变量名是否合适？请回答是（解释原因，以及适用情境），否（解释原因），还是无法判断（解释原因）。**'
- en: '**`int apple_count`**'
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`int apple_count`**'
- en: '**`char foo`**'
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`char foo`**'
- en: '**`bool apple_count`**'
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`bool apple_count`**'
- en: '**`char *string`**'
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`char *string`**'
- en: '**`int loop_counter`**'
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`int loop_counter`**'
- en: 'The quality of a name depends on its context, and we can''t honestly tell whether
    any of these are good or bad names. That''s why the question asks for example
    contexts. There are some obvious contexts where the names might be bad: `apple_count`
    wouldn''t be a particularly good name for a grapefruit counter.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 名称的质量取决于其上下文，我们无法诚实地判断这些名称是否好或坏。这就是为什么问题要求提供示例上下文。有些明显的上下文中，名称可能是不好的：`apple_count`对于葡萄柚计数器来说可能不是一个特别好的名称。
- en: '`foo` is *never* a good name. I''ve yet to see anyone counting *foo*s. `loop_counter`
    is also bad; even if a loop gets too big for a short counter name, you can still
    pick a more descriptive name, one that reflects the actual *use* of the variable
    rather than its role as a loop counter.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`永远不是一个好的名称。我还没有见过有人计数`foo`s。`loop_counter`也是不好的；即使一个循环太大，不适合简短的计数器名称，你仍然可以选择一个更具描述性的名称，一个反映变量实际*用途*而不是其作为循环计数器角色的名称。'
- en: We can't really tell whether `bool apple_count` is a good name, but it looks
    like it isn't—a boolean cannot hold a number. Perhaps it's recording whether a
    separate count of apples is valid, but if this was the case, it ought to be called
    something like `is_apple_count_valid`.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的无法判断`bool apple_count`是否是一个好的名称，但它看起来好像不是——布尔值不能持有数字。也许它是在记录苹果的单独计数是否有效，但如果这是这种情况，它应该被命名为`is_apple_count_valid`。
- en: '**When would these be appropriate function names? Which return types or parameters
    might you expect? Which return types would make them nonsensical?**'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这些名称何时是合适的函数名称？你可能会期望哪些返回类型或参数？哪些返回类型会使它们变得没有意义？**'
- en: '**`doIt(...)`**'
  id: totrans-675
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`doIt(...)`**'
- en: '**`value(...)`**'
  id: totrans-676
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`value(...)`**'
- en: '**`sponge(...)`**'
  id: totrans-677
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`sponge(...)`**'
- en: '**`isApple(...)`**'
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`isApple(...)`**'
- en: What each of these might mean depends on where you find them. A name depends
    on its context for meaning; that context is provided by the enclosing scope of
    the function. Context information can also be given by function parameters or
    return variables.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能意味着什么取决于你找到它们的地方。一个名称依赖于其上下文来赋予意义；这个上下文由函数的封装作用域提供。上下文信息也可以由函数参数或返回变量提供。
- en: '**Should a naming scheme favor the easy reading or easy writing of code? How
    would you make either easy?**'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命名方案应该优先考虑代码的易读性还是易写性？你将如何使其中之一变得容易？**'
- en: '**How many times do you write a single piece of code? (Think about it.) How
    many times do you read it? Your answers should give some indication as to the
    relative importances**.'
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你写同一块代码的次数有多少？（想想看。）你阅读它的次数有多少？你的答案应该给出一些相对重要性的指示**。'
- en: '**What do you do when naming conventions collide? Say you''re working on camelCase
    C++ code and need to do STL (using_underscore) library work. What''s the best
    way to handle this situation?**'
  id: totrans-682
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当命名约定冲突时，你会怎么做？比如说你正在处理驼峰式命名的C++代码，需要做STL（使用下划线）库的工作。处理这种情况的最佳方法是什么？**'
- en: I've worked on C++ codebases that used such a collision of naming conventions
    to their advantage. The internal logic used camelCase, whereas libraries and components
    that extended the standard library followed STL naming_conventions. It actually
    worked quite well, neatly marking separate parts of the project.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾工作过使用这种命名约定冲突的C++代码库。内部逻辑使用驼峰式命名法，而扩展标准库的库和组件遵循STL命名约定。这实际上工作得相当好，清楚地标记了项目的不同部分。
- en: Unfortunately, it doesn't always work that nicely. I've seen plenty of inconsistent
    code where there was no rhyme or reason behind the changing styles.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不总是那么顺利。我见过很多不一致的代码，其中没有规律或理由来改变风格。
- en: '**How long should a loop be before you need to give a meaningful loop counter
    name?**'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在何时你需要给循环提供一个有意义的循环计数器名称？**'
- en: This depends on how long your piece of string is. It's clear, though, that a
    100-line loop with a counter called `i` is not best practice.^([[4](#ftn.APP-FN-4)])
    Whenever you insert new code into a loop, check the counter name to see if it
    now needs adjustment.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你的字符串有多长。然而，很明显，一个有100行且计数器名为`i`的循环不是最佳实践。[^4](#ftn.APP-FN-4) 每次你在循环中插入新代码时，都要检查计数器名称，看看是否需要调整。
- en: '**In C, if** `assert` **is a macro, why is its name lowercase? Why should we
    name macros so they stand out?**'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在C语言中，如果** `assert` **是一个宏，为什么它的名称是小写的？为什么我们应该给宏起名，让它们突出？**'
- en: '`assert` isn''t capitalized because `assert` isn''t capitalized. In an ideal
    world it would be, but standards being what they are, we have to live with this
    second-rate macro name. Sigh.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 不大写是因为 `assert` 不大写。在理想的世界里它应该是大写的，但标准就是这样，我们不得不忍受这个二流的宏名称。唉。'
- en: Fire is useful, but it can also be very dangerous. Macros are the same. Macros
    and `#define`d constant definitions *are* dangerous—adopting the UPPERCASE name
    convention will prevent nasty collisions with ordinary names. It's as sensible
    as wearing safety goggles when a lunatic is walking around with a big pointy stick.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 火是有用的，但它也可以非常危险。宏也是一样。宏和 `#define` 定义的常量 *确实是危险的*——采用大写字母的名称约定将防止与普通名称发生恶劣的冲突。这就像当疯子拿着一根大尖棒走来走去时戴上安全眼镜一样明智。
- en: Because macros can be so painful, you should choose names that are very unlikely
    to cause headaches. More importantly, avoid using the preprocessor as much as
    humanly possible.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 因为宏可能会很痛苦，你应该选择非常不可能引起头痛的名称。更重要的是，尽可能避免使用预处理器。
- en: Long calculations can be made more readable by putting intermediate results
    in temporary variables. Suggest good naming heuristics for these types of variables.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将中间结果放入临时变量中，可以使长计算更易于阅读。为这些类型的变量提出良好的命名启发式方法。
- en: Bad temporary names are `tmp`, `tmp1`, `tmp2`, and so on, or `a`, `b`, `c`,
    and so on. These, unfortunately, are all common intermediate names.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 恶劣的临时名称是 `tmp`、`tmp1`、`tmp2` 等等，或者 `a`、`b`、`c` 等等。不幸的是，这些都是常见的中间名称。
- en: Like any other item, temporary names should be meaningful (like `circle_radius`
    in a trigonometric calculation or `apple_count` in an arboreal analysis routine).
    In fact, in a complex calculation, good names can really serve to document the
    internal logic and show what's going on.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他项目一样，临时名称应该是有意义的（例如，在三角计算中使用 `circle_radius` 或在树形分析例程中使用 `apple_count`）。事实上，在复杂的计算中，好的名称真的可以用来记录内部逻辑并展示正在发生的事情。
- en: If you find a value that really has no nameable purpose, if it truly is an arbitrary
    intermediate value that's hard to name, then you'll begin to understand why `tmp`
    is so popular. Avoid calling anything `tmp` if possible—try to break the calculation
    in some other way that makes more sense.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你找到一个确实没有可命名用途的值，如果它确实是一个难以命名的任意中间值，那么你就会开始理解为什么 `tmp` 如此受欢迎。如果可能，避免将任何东西称为
    `tmp`——尝试以更有意义的方式打破计算。
- en: '**What are the pros and cons of following your language''s standard library
    naming conventions?**'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遵循你语言的标准库命名约定有哪些优点和缺点？**'
- en: Standard libraries are often a source of language best practice, so it can be
    valuable to follow their conventions. Other programmers are used to the naming
    style, so they will have fewer nasty reading surprises and will feel at home with
    your code.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库通常是语言最佳实践的来源，因此遵循它们的约定可能很有价值。其他程序员习惯了这种命名风格，因此他们阅读你的代码时会有更少的意外，并会感到舒适。
- en: On the other hand, the library might not always present best practices, so think
    first! C's horribly named `assert` macro is a good example of this.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，库可能并不总是提供最佳实践，所以首先要思考！C语言中可怕命名的 `assert` 宏就是这样一个例子。
- en: '**Can you wear out a name? Is it okay to repeat a local variable name in many
    different functions? Is it okay to use local names that override (and hide) global
    names? Why?**'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能用尽一个名称吗？在许多不同的函数中重复局部变量名是否可以？使用覆盖（并隐藏）全局名称的局部名称是否可以？为什么？**'
- en: 'It is perfectly acceptable to repeat a local variable name in many different
    contexts. Sometimes it''s good practice to: Why use a different loop index counter
    name all the time? It would only serve to make your code harder to read.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多不同的上下文中重复局部变量名是完全可接受的。有时，这样做是一种好的实践：为什么总是使用不同的循环索引计数器名称呢？这只会让代码更难阅读。
- en: '*Don''t* hide global names with local variable names; it''s really confusing.
    This is an indicator of brittle code.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要* 用局部变量名隐藏全局名称；这真的很令人困惑。这是一个脆弱代码的指标。'
- en: '**Describe the mechanics of Hungarian Notation. What are the pros and cons
    of this naming convention? Does it have a place in modern code design?**'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述匈牙利命名法的机制。这种命名约定的优缺点是什么？它在现代代码设计中有什么位置？**'
- en: Hungarian Notation is a naming convention that adorns variable and function
    names with cryptic prefixes to denote type. It's seen predominantly in C code.
    There are several subtly different dialects, but the most common Hungarian prefixes
    are shown in [Table A-1](apas03.html#common_hungarian_notation_prefixes "Table A-1. Common
    Hungarian Notation Prefixes").
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法是一种命名约定，通过在变量和函数名前加上神秘的缩写前缀来表示类型。它在C代码中尤为常见。有几种细微不同的方言，但最常见的匈牙利前缀在[表A-1](apas03.html#common_hungarian_notation_prefixes
    "表A-1. 常见匈牙利命名法前缀")中展示。
- en: '**Table A-1. Common Hungarian Notation Prefixes**'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**表A-1. 常见匈牙利命名法前缀**'
- en: '| Prefix | Which means . . . |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 它代表 . . . |'
- en: '| --- | --- |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `p` | pointer to . . . (`lp` means *long pointer*, an old architectural issue—if
    you don''t know, don''t ask) |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `p` | 指向 . . . 的指针（`lp`表示*长指针*，一个旧架构问题——如果你不知道，就别问）|'
- en: '| `r` | reference of . . . |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `r` | . . . 的引用 |'
- en: '| `k` | constant . . . |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| `k` | 常量 . . . |'
- en: '| `rg` | array of . . . |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| `rg` | . . . 的数组 |'
- en: '| `b` | boolean (`bool` or some C `typedef`) |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| `b` | boolean (`bool` 或某些C `typedef`) |'
- en: '| `c` | `char` |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `char` |'
- en: '| `si` | `short int` |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| `si` | `short int` |'
- en: '| `i` | `int` |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| `i` | `int` |'
- en: '| `li` | `long int` |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| `li` | `long int` |'
- en: '| `d` | `double` |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `double` |'
- en: '| `ld` | `long double` |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| `ld` | `long double` |'
- en: '| `sz` | zero-terminated `char` string (Note: *not* `p`) |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| `sz` | 以零结尾的`char`字符串（注意：*不是* `p`）|'
- en: '| `S` | `struct` |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| `S` | `struct` |'
- en: '| `C` | `class` (You can define your own class abbreviations, too.) |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| `C` | `class`（你也可以定义自己的类缩写。）|'
- en: Hungarian Notation was relatively unbearable in C (not to mention unnecessary
    once the language became more strongly typed), and is rapidly nauseating in C++,
    since it doesn't really scale up to the many new type definitions you can introduce.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利命名法在C语言中相对难以忍受（更不用说一旦语言变得更加强类型化就变得不必要了），在C++中更是迅速变得令人作呕，因为它实际上无法扩展到你可以引入的许多新类型定义。
- en: If you really want to confuse a maintenance programmer, use Hungarian Notation
    and then, a few months later, change the types of all the variables without correcting
    every single variable name (since it would take far too long to do *that*). This
    is a real weakness with the naming scheme.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想混淆维护程序员，使用匈牙利命名法，然后在几个月后，改变所有变量的类型而不纠正每个变量名（因为这会花费太多时间去做*那*）。这是命名方案的一个真正弱点。
- en: '**KEY CONCEPT**'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Avoid Hungarian Notation like the plague*.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '*像对待瘟疫一样避免使用匈牙利命名法*。'
- en: 'Some naming conventions have diluted Hungarian leanings. Witness the `foo_ptr`
    and `m_foo` ideas mentioned earlier in the chapter. There are other cute conventions
    with similar intent: Some programmers call their global variables `theFoo` and
    their member variables `myFoo`. Perhaps this shows that *some* Hungarian Notation
    is a good idea in principle; but taken to its logical extreme, it''s a dictatorial
    tyrant of a convention. Be on your guard.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命名约定已经削弱了匈牙利风格的影响。例如，本章前面提到的`foo_ptr`和`m_foo`的概念。还有其他一些类似意图的可爱约定：一些程序员将他们的全局变量称为`theFoo`，将他们的成员变量称为`myFoo`。也许这表明在原则上*一些*匈牙利命名法是一个好主意；但若过度使用，它就像一个独裁的暴君，需要引起警惕。
- en: '**We see many classes containing member functions acting as getters and setters;
    reading and writing the value of certain properties. What are the common naming
    conventions for these functions, and which is the best?**'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们看到了许多包含成员函数的类，这些函数充当获取器和设置器；读取和写入某些属性的值。这些函数有哪些常见的命名约定，哪一个是最好的？**'
- en: While some argue that the existence of get and set methods shows a weak design,
    we nonetheless see a lot of classes written like this. Some languages actually
    have built-in support for these operations.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人认为get和set方法的存在表明设计薄弱，但我们仍然看到很多类是这样编写的。一些语言实际上对这些操作有内置支持。
- en: 'There are several naming conventions to choose from. If you''re writing in
    C++, using camelCase, and have some property called *foo* of type *Foo*, you might
    pick:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种命名约定可供选择。如果你正在用C++编写，使用camelCase，并且有一个名为*foo*的属性，其类型为*Foo*，你可能选择：
- en: '[PRE7]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: or
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE8]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or perhaps
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也许
- en: '[PRE9]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your choice may be dictated by a coding standard; otherwise, it's down to your
    sense of aesthetics. This is a case where I'd violate the *Function name should
    always contain a verb* rule and go for the second option, since it reads the most
    naturally in code. Try it and see.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 你的选择可能受到编码标准的约束；否则，就取决于你的审美观。这是一个我会违反“函数名应始终包含动词”的规则而选择第二个选项的情况，因为它在代码中读起来最自然。试一试，看看效果如何。
- en: If a "getter" method has to perform a long calculation the first time it's run
    (even if it can cache the answer for future invocations), then I'd be wary. It's
    no longer a simple retrieval function, and these naming schemes don't imply this.
    `Tree::numApples` is a good getter name, unless the operation could block for
    a minute while an image recognition system detects all the apples. In that case,
    I'd like to see the behavior implied by name. `Tree::countApples()` hints at some
    greater activity—it's the verb in the name.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个“获取器”方法在第一次运行时需要进行长时间的计算（即使它可以缓存答案以供未来的调用），那么我会谨慎行事。它不再是一个简单的检索函数，而这些命名方案并不暗示这一点。`Tree::numApples`是一个好的获取器名称，除非这个操作可能需要一分钟的时间，而图像识别系统正在检测所有的苹果。在这种情况下，我希望看到名称所暗示的行为。`Tree::countApples()`暗示了一些更复杂的活动——它是名称中的动词。
- en: Getting Personal
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**How good are you at naming? How many of these heuristics do you follow already?
    Do you consciously think about your naming and these sorts of rules, or do you
    just** do it **all naturally? In which areas can you improve?**'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在命名方面有多好？你已经遵循了多少这样的启发式方法？你是否自觉地考虑过你的命名和这些规则，或者你只是**自然地**这样做？你在哪些方面可以改进？'
- en: Go back over the section "[The Nuts and Bolts](ch11s05.html "The Nuts and Bolts")"
    on page 44\. Compare those guidelines with the last piece of code you wrote. How
    does it match up? How much of your naming necessarily follows existing coding
    conventions (as you're exhorted to do on page 50), and how much have you established
    from scratch?
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第44页上的“[螺丝钉](ch11s05.html "螺丝钉")”部分。将这些指南与您最后编写的代码片段进行比较。您的命名有多少是遵循现有的编码规范（正如第50页上所要求的），又有多少是从零开始建立的？
- en: '**Does your coding standard mention naming at all?**'
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的编码标准是否提到了命名？**'
- en: '**Does it cover all the cases we''ve looked at here? Is it sufficient? Is it
    useful, or just superficial?**'
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它涵盖了我们在这里讨论的所有情况吗？它是足够的吗？是有用的，还是只是表面的？**'
- en: '**How much naming detail is appropriate in a coding standard?**'
  id: totrans-740
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编码标准中适当的命名细节有多少？**'
- en: Sometimes a coding standard with comprehensive naming mandates can make it *harder*
    to invent names—you have so many rules to try to satisfy that it's hard to remember
    and reconcile them all. Look with caution at anything more prescriptive than the
    guidelines laid out in [Chapter 3](ch03.html "Chapter 3. WHAT'S IN A NAME?").
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个具有全面命名要求的编码标准可能会使发明名称变得更**难**——你有这么多规则要尝试满足，以至于很难记住和协调它们。小心看待比[第3章](ch03.html
    "第3章。名称中有什么？")中概述的指南更具有规定性的任何东西。
- en: Good code craftsmen habitually name well, and don't need coding standards to
    "help" them. The standards-setters often claim that their standards will help
    less-experienced programmers to name well. But more often than not, these standards
    are not that helpful—inexperienced programmers commit more programming sins than
    just bad naming. Code reviews are required to ensure that their work is appropriate.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码工匠习惯于给出好的命名，不需要编码标准来“帮助”他们。标准的制定者经常声称他们的标准将帮助经验不足的程序员进行良好的命名。但更多的时候，这些标准并不那么有帮助——经验不足的程序员犯的编程错误不仅仅是命名不当。代码审查是确保他们的工作适当的必要手段。
- en: '**What''s the worst name you''ve come across recently? How have names ever
    misled you? How would you have changed them to avoid future confusion?**'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最近你遇到过最糟糕的命名是什么？命名是如何误导你的？你会如何修改它们以避免未来的混淆？**'
- en: Did you spot this in a formal review of someone else's work, or while trying
    to maintain some old, long-forgotten code?^([[5](#ftn.APP-FN-5)]) Finding and
    correcting bad names just after they've been written (when you still know what
    the thing should really be called) is best. And it takes the least effort. Working
    it out months later can sometimes be quite painful.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 你是在对别人的工作进行正式审查时发现这个问题，还是在尝试维护一些早已被遗忘的旧代码时？^([[5](#ftn.APP-FN-5)]) 在编写后不久（当你还知道这个事物应该叫什么时）发现并纠正糟糕的命名是最好的。这需要最少的努力。几个月后解决它有时可能会非常痛苦。
- en: '**Do you have to port code between platforms? How has this affected filenames,
    other names, and the overall code structure?**'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你需要在平台之间移植代码吗？这对文件名、其他名称以及整体代码结构有何影响？**'
- en: Older filesystems limited the number of characters you could use in a filename.
    This made file naming much messier (and more cryptic). Unless you have to port
    code to such an archaic system, this kind of limitation can be safely ignored.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 旧文件系统限制了你可以用在文件名中的字符数。这使得文件命名变得混乱（且更神秘）。除非你必须将代码移植到这样的古老系统，否则这种限制可以安全地忽略。
- en: '*File-based polymorphism* is a cunning way to exploit filenames to achieve
    code substitutability at build time. It''s often used to select platform-specific
    implementations in portable code. You can set up header file search paths, allowing
    one `#include` to pull in a different file depending on the current build platform.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于文件的泛型*是利用文件名在构建时实现代码可替换性的巧妙方法。它通常用于在可移植代码中选择特定平台的实现。你可以设置头文件搜索路径，允许一个`#include`根据当前的构建平台引入不同的文件。'
- en: '* * *'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#APP-FN-4)]) But generally a 100-line loop itself is not best practice.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#APP-FN-4)]) 但一般来说，一个100行的循环本身并不是最佳实践。
- en: ^([[5](#APP-FN-5)]) Obviously, it would never be a problem you found in your
    *own* code!
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#APP-FN-5)]) 显然，这绝不可能是在你自己的代码中遇到的问题！
- en: '[Chapter 4](ch04.html "Chapter 4. THE WRITESTUFF")'
  id: totrans-751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第4章](ch04.html "第4章。写作技巧")'
- en: Mull It Over
  id: totrans-752
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mull It Over
- en: '**Grouping related code will make its relationships clear. How can we perform
    this grouping? Which methods document the relationships most strongly?**'
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将相关代码分组可以使它们之间的关系变得清晰。我们如何进行这种分组？哪些方法最能体现这些关系？**'
- en: Obvious grouping devices are common name prefixes and suffixes; filesystem location;
    and putting items in the same class or structure, C++/C# namespace, Java package,
    source file, or code library. Can you think of more?
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的分组方法包括常见的名称前缀和后缀；文件系统位置；将项目放在同一类或结构中，C++/C#命名空间，Java包，源文件或代码库。你能想到更多吗？
- en: Relationships enforced by the language are the strongest—both obvious to read
    and also automatically checked for you. However, proximity of code layout is a
    more potent association than you'd think. Ordering also implies a lot—you'll think
    that the first item is more important than subsequent items. Exploit these facts
    to document your code.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 语言强制的关系是最强的——既易于阅读，又自动为你检查。然而，代码布局的邻近性比你想的更有影响力。顺序也暗示了很多——你会认为第一个项目比后续的项目更重要。利用这些事实来记录你的代码。
- en: '**We should avoid using magic numbers in our code. Is zero a magic number?
    What should you call a constant value representing zero?**'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们应该避免在代码中使用魔法数字。零是魔法数字吗？你应该如何称呼代表零的常量值？**'
- en: The number zero has magic properties in many different contexts; in C code it
    is used as a *null* pointer value, and the initial value for most loops. What
    *could* you replace 0 with?
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 数字零在许多不同的上下文中都具有魔法属性；在C代码中，它被用作*空指针*值，以及大多数循环的初始值。你能用什么来替换0？
- en: A single shared constant called `ZERO` is no better than writing `0`; it's *just
    as* magic. The name doesn't imply what any zero actually means—is it a null pointer
    value, or a loop initialization value? This approach would defeat the purpose.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一共享常量`ZERO`与直接写`0`一样，只是同样具有魔法性。这个名称并不暗示任何零的实际含义——它是空指针值，还是循环初始化值？这种方法会适得其反。
- en: A different name for each zero constant would get very tedious because you'd
    have to create many similar variations on the theme of `for (int i = SOME_ZERO_START_VALUE;
    i < SOME_END_VALUE; ++i)`. None of these zero constant names gives any new meaningful
    information, anyway.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个零常量取不同的名字会变得非常繁琐，因为你必须创建许多类似的主题变体，例如`for (int i = SOME_ZERO_START_VALUE;
    i < SOME_END_VALUE; ++i)`。但无论如何，这些零常量名称都没有提供任何新的有意义的 信息。
- en: You'd have to think carefully about names for zero constants. The obvious choice
    would be something like `NO_BANANAS`, meaning *no bananas counted*. But this `NO_`
    prefix could be confused as an abbreviation for number (like `NUM_`).
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须仔细思考零常量的名称。显然的选择可能是像`NO_BANANAS`这样的名字，意味着*没有香蕉计数*。但这个`NO_`前缀可能会被误解为数字的缩写（如`NUM_`）。
- en: '**Self-documenting code makes good use of context to convey information. Show
    how you do this, and give an example of how a particular name would lead to a
    different interpretation in different functions?**'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自文档化的代码充分利用上下文来传达信息。展示你是如何做到这一点的，并给出一个例子，说明特定的名称在不同的函数中会导致不同的解释？**'
- en: There are many ways to exploit context to your documentation's advantage. Consider
    a `Cat` class. Inside it, member functions don't need to be called `setCatName`,
    `setCatColor`, and so on; the *cat* part is implicit from the class context.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以利用上下文来提高文档的优势。考虑一个`Cat`类。在其内部，成员函数不需要被命名为`setCatName`、`setCatColor`等等；*猫*的部分从类上下文中是隐含的。
- en: Many English words have a dual meaning. You'd expect the `count` variable in
    a search function to hold different information than one in a vampire database
    schema. More practically, a `name` variable in our `Cat` class clearly holds the
    cat's name, whereas one in an `Employee` class is more likely to hold a human's—with
    first name, last name, and title information. Same variable name, different contents.
    Exploit context information as much as possible, but ensure that the context in
    which you write is truly obvious.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 许多英语单词都有双重含义。你期望在搜索函数中的`count`变量持有与在吸血鬼数据库模式中的`count`变量不同的信息。更实际的是，在我们的`Cat`类中，`name`变量显然持有猫的名字，而在`Employee`类中，它更有可能持有人的信息——包括名字、姓氏和头衔信息。相同的变量名，不同的内容。尽可能利用上下文信息，但确保你写的上下文真正明显。
- en: '**Is it realistic to expect a newcomer to pick up some self-documenting code
    and understand it totally?**'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**期望一个新手能够完全理解一些自文档化的代码，这是现实的吗？**'
- en: Yes, that's our aim—it *is* realistic. However, the reader will still need overview
    and design documents describing the entire system, what it does, and how it's
    structured. If the code comments try to explain this, then they're in the wrong
    place (or it's a very small system).
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这就是我们的目标——*这是现实的*。然而，读者仍然需要概述和设计文档来描述整个系统、它的功能以及它的结构。如果代码注释试图解释这一点，那么它们就放在了错误的位置（或者是一个非常小的系统）。
- en: With good code documentation, a newcomer should find it perfectly clear what
    a particular *section of code* is doing. Comprehensive API docs show the meaning
    of any function call the newcomer may come across.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码文档应该让新手清楚地知道特定的*代码部分*在做什么。全面的API文档展示了新手可能遇到的任何函数调用的含义。
- en: '**If code is truly self-documenting, how much other documentation is required?**'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果代码确实是自文档化的，还需要多少其他文档？**'
- en: It depends on the size and scope of the project. You'll require functional specifications
    and design documents. You may still need an implementation overview, and will
    definitely require thorough test specifications.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于项目的规模和范围。你需要功能规范和设计文档。你可能仍然需要一个实现概述，并且肯定需要一个彻底的测试规范。
- en: To document the design of a single piece of code, good literate comments mean
    that you shouldn't need any other documentation.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录单一段代码的设计，良好的文献注释意味着你不需要任何其他文档。
- en: '**Why must more people than the original author understand any piece of code?**'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么必须让比原作者更多的人理解任何一段代码？**'
- en: It's a reality of the software factory. Being the only person who understands
    some code is good job security for the unscrupulous programmer. Writing code that's
    worse than a cryptic crossword puzzle will guarantee you a job for life (or until
    the company folds, whichever happens first). The downside is that you'll spend
    your days immersed in your own foul concoctions.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这是软件工厂的现实。作为唯一理解某些代码的人，对于不择手段的程序员来说，这是一份很好的工作保障。编写比谜语更难以理解的代码将保证你终身有工作（或者直到公司倒闭，哪个先发生），缺点是你将整天沉浸在自己的糟糕混合物中。
- en: In reality, code is dangerous if it can't be understood by anyone else. If you
    leave the company, move to another department, get promoted, or no longer have
    time to perform maintenance, then someone else must be able to take over. And
    if it doesn't come down to that, sometime down the road, when you've forgotten
    how your code works, a fatal fault will turn up that must be fixed by last Tuesday.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果代码不能被其他人理解，那么代码就是危险的。如果你离开公司，转到另一个部门，晋升，或者不再有时间进行维护，那么其他人必须能够接管。而且如果事情没有发展到那一步，在未来的某个时候，当你忘记了你的代码是如何工作时，一个致命的错误将会出现，必须在周二之前修复。
- en: Code reviews can help to ensure that code is well understood and adequately
    documented.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查可以帮助确保代码被充分理解并且有足够的文档。
- en: '**This simple C bubblesort function could use some improvement. What specific
    things are wrong with it? Write an improved, self-documenting version**.'
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这个简单的C语言冒泡排序函数可以进行一些改进。它具体有哪些问题？请写一个改进的、自文档化的版本**。'
- en: '[PRE10]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first problem is that a bubblesort algorithm should never be used. There
    are plenty of better sorts. There's also probably a much better, generic language
    library function available; in C you can call `qsort`, for example. I've used
    bubblesort here as a simple code example.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是一个冒泡排序算法永远不应该使用。有足够多的更好的排序算法。可能还有一个更好的通用语言库函数可用；例如，在C中你可以调用`qsort`。我在这里使用冒泡排序作为一个简单的代码示例。
- en: The function's interface isn't clear *at all*. The function name is too cryptic,
    and the parameter names mean nothing. I'd like to see an API documentation comment
    provided too, but I'll leave that out in the rewrite below.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的接口完全不清晰。函数名太晦涩，参数名毫无意义。我也想看到提供的API文档注释，但在下面的重写中我将省略它。
- en: 'Internally, the code is a mess. Its intent would be much clearer if the code
    that transposes array values is split out as a `swap` function. Then the reader
    can see what''s going on. A little more massaging leads to this:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 内部代码一团糟。如果将交换数组值的代码拆分为一个`swap`函数，其意图将更加清晰。然后读者就能看到发生了什么。稍加整理后，结果如下：
- en: '[PRE11]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is adequate C, although there are some more changes you might prefer. Depending
    on your religion, you might want braces around the loops. `swap` could be made
    into a macro for efficiency. This isn't a clever optimization though; you should
    really choose a more efficient sort algorithm.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种足够的C语言，尽管你可能更喜欢一些其他的变化。根据你的信仰，你可能想在循环周围添加括号。`swap`可以为了效率而成为一个宏。但这并不是一个聪明的优化；你应该真正选择一个更有效的排序算法。
- en: In C++, I'd consider making `swap` inline, and take its parameters by reference
    (documenting the fact that they will be changed). The best choice would be to
    use the `std::swap` facility available in the language libraries.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我会考虑将`swap`函数定义为内联的，并通过引用传递其参数（记录它们将被更改的事实）。最佳选择是使用语言库中可用的`std::swap`功能。
- en: '**Working with code documentation tools brings up some interesting issues.
    What''s your opinion on these?**'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与代码文档工具一起工作会引发一些有趣的问题。你对这些有什么看法？**'
- en: '**When you review the documentation, should you perform a code review, looking
    at the comments in the source files, or a specification review, looking at the
    generated documents?**'
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在审查文档时，你应该进行代码审查，查看源文件中的注释，还是进行规范审查，查看生成的文档？**'
- en: '**Where do you put documentation of protocols and other non-API issues?**'
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你将协议和其他非API问题的文档放在哪里？**'
- en: '**Do you document private/internal functions? In C/C++, where do you place
    this documentation—in the header file or implementation file?**'
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你文档化私有/内部函数吗？在C/C++中，你将这个文档放在哪里——头文件还是实现文件？**'
- en: '**In a large system, should you create a single, large API document or several
    smaller documents, one per area? What are the advantages of each approach?**'
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在一个大型系统中，你应该创建一个单一的、大的API文档，还是创建几个较小的文档，每个区域一个？每种方法的优点是什么？**'
- en: 'My thoughts on these questions are:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这些问题的看法是：
- en: Review the generated spec; don't get too hung up about the layout of the comments
    in the source file. You're reviewing the content, not the code.
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查生成的规范；不要过于纠结于源文件中注释的布局。你是在审查内容，而不是代码。
- en: Don't be fooled into thinking documentation must be put in a *header file* or
    in an *implementation file*. Even if documentation tools are a Good Thing, it's
    not evil to have some separate "traditional" documents as well. Write about your
    protocol there.
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要被误导，认为文档必须放在*头文件*或*实现文件*中。即使文档工具是好事，但拥有一些独立的“传统”文档也不算邪恶。在那里写关于你的协议。
- en: Document any internal functions that *need* documentation. You don't necessarily
    have to write exhaustive docs on all private parts. These docs should be hived
    off into the implementation file if they're reasonably large, to keep the public
    interface neat and simple.
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录任何需要文档的内部函数。你不必对所有私有部分都编写详尽的文档。如果这些文档相当大，应该将它们分离到实现文件中，以保持公共接口整洁简单。
- en: Both! Use different invocations of the tool to generate a single, large document
    and documents for each subsystem.
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都要！使用工具的不同调用生成一个单一的大文档和每个子系统的文档。
- en: '**If you''re working on a codebase that isn''t literately documented, and you
    need to alter or add new methods or functions, is it a good idea to give them
    literate documentation comments, or should you leave them undocumented?**'
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你正在处理一个没有详细文档的代码库，并且需要修改或添加新的方法或函数，提供详细的文档注释是一个好主意，还是应该让它们保持未文档化？**'
- en: The craftsman *wants to* document and automatically feels the need to write
    comment blocks. Now, if the code has a separate specification document, then your
    documentation should go in there alongside everything else. Otherwise, it's not
    too bad to start adding literate comments. Make sure that the original programmer
    isn't going to take offense, though!
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠*希望*进行文档化，并且自然而然地感觉到需要写注释块。现在，如果代码有一个单独的规范文档，那么你的文档应该放在那里，与其他所有内容并列。否则，开始添加文献注释也还不错。不过，确保原始程序员不会因此感到冒犯！
- en: '**Is it possible to write self-documenting assembly code?**'
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**能否编写自文档化的汇编代码？**'
- en: You can give it your best shot, but it's not going to be easy. Assembly code
    isn't particularly expressive; you're not programming at the level of intent,
    more at the level of *do this, you dumb microprocessor*. Your code will be mostly
    comment blocks (probably good practice for assembly, anyway). Except for subroutine
    labels, there's not much else to self-document with.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尽力而为，但这不会容易。汇编代码并不特别具有表达性；你并不是在意图层面编程，而是在*这样做，你这个愚蠢的微处理器*的层面编程。你的代码将主要是注释块（无论如何，对于汇编来说，这可能是良好的实践）。除了子程序标签外，没有太多其他内容可以用来自文档化。
- en: Getting Personal
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人观点
- en: '**What do you consider to be the best documented code you''ve come across?
    What made it so?**'
  id: totrans-797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你认为你遇到的最佳文档化的代码是什么？是什么让它如此出色？**'
- en: '**Did this code have a large number of external specifications? How many of
    them did you read? How can you be sure you knew enough about the code without
    reading them all?**'
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这段代码是否有大量的外部规范？你读了多少？你如何确保在没有阅读所有这些规范的情况下，你对代码的了解足够？**'
- en: '**How much of this do you think was due to the author''s programming style,
    and how much was because of any house style or guidelines he or she worked to?**'
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你认为这其中的多少归因于作者的编程风格，又有多少是因为他或她遵循的任何房屋风格或指南？**'
- en: Well-documented code does not necessarily have any separate description documents.
    Internally, it employs good naming, logical modularization, simple techniques,
    clear layout, documented assumptions, and good commenting. House styles help,
    but they are no substitute for astute, sensitive programming. An idiot can follow
    the most stringent guidelines and still produce shabby shreds of code.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 代码文档化良好并不一定意味着有单独的描述文档。内部上，它采用良好的命名、逻辑模块化、简单技术、清晰的布局、文档化的假设和良好的注释。房屋风格有所帮助，但它们不能替代敏锐、敏感的编程。一个白痴可以遵循最严格的指南，仍然能产生糟糕的代码碎片。
- en: '**If you write in more than one language, how does your documentation strategy
    differ in each?**'
  id: totrans-801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你使用多种语言编写，你的文档策略在每种语言中是如何不同的？**'
- en: Different languages are more or less expressive, and so what can and can't be
    documented within the language syntax varies. As much as anything else, this will
    affect how many comments you'd write.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言表达性或多或少，因此语言语法中可以和不能文档化的内容也有所不同。这在很大程度上会影响你写多少注释。
- en: You're probably better at writing self-documenting code in your most familiar
    programming language.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在你最熟悉的编程语言中更擅长编写自文档化的代码。
- en: '**In the last code you wrote, how did you make the important stuff stand out?
    Did you hide private information away appropriately?**'
  id: totrans-804
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在你最后编写的代码中，你是如何使重要的内容突出显示的？你是否适当地隐藏了私有信息？**'
- en: Think carefully about this—the natural tendency is to dismissively say, *Yeah,
    I wrote it okay*. Look at your code as if it had been written by some other muppet.
    Criticize it.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细思考这个问题——自然的倾向是轻率地说，“嗯，我写得还可以。”把你自己的代码当作是别人写的，进行批评。
- en: '**If you''re working on a team, how often do others come to you to ask you
    how something works? Could you avoid this with better-documented code?**'
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你在一个团队中工作，其他人多久会来问你某个功能是如何工作的？你能通过更好的文档化来避免这种情况吗？**'
- en: 'A good two-pronged strategy to cope with this is:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 应对这一问题的良好策略是双管齐下：
- en: If the question is genuinely about something unclear in your code, after having
    explained it to the curious programmer (and learned what he really *needed* to
    know), capture the information in some appropriate documentation. You can email
    this to him afterward, too, to ensure he took away the right information.
  id: totrans-808
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果问题真正涉及到你代码中的某个不清楚的地方，在向好奇的程序员解释（并了解他真正*需要*知道的内容）之后，将信息记录在适当的文档中。之后，你也可以通过电子邮件发送给他，以确保他获得了正确的信息。
- en: If the question was about something that was already explained in the documentation,
    point him at it, shout RTFM,^([[6](#ftn.APP-FN-6)]) and give him a poke in the
    eye.
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果问题已经包含在文档中，就指向它，大声喊RTFM，^([[6](#ftn.APP-FN-6)]) 并给他一个白眼。
- en: '* * *'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#APP-FN-6)]) *Read The* (ahem . . . ) *Manual*.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#APP-FN-6)]) *阅读手册*（嗯，嗯，）。
- en: '[Chapter 5](ch05.html "Chapter 5. A PASSING COMMENT")'
  id: totrans-812
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第5章](ch05.html "第5章。一个恰当的注释")'
- en: Mull It Over
  id: totrans-813
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**How might the need for and the content of comments differ in the following
    types of code**:'
  id: totrans-814
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以下类型的代码中，注释的需求和内容可能会有哪些不同**：'
- en: '**Low-level assembly language (machine code)**'
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**低级汇编语言（机器代码**）'
- en: '**Shell scripts**'
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Shell脚本**'
- en: '**A single-file test harness**'
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单文件测试框架**'
- en: '**A large C/C++ project**'
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大型C/C++项目**'
- en: Assembly language is less expressive, providing fewer opportunities for self-documenting
    code. Therefore, you'd expect more comments in assembly code, and you'd expect
    those comments to be at a much lower level than comments in other languages—assembly
    language comments generally *would* explain how as well as why.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言的表达能力较弱，提供较少的机会来编写自文档化的代码。因此，你可能会预期汇编代码中有更多的注释，并且你可能会预期这些注释的级别比其他语言的注释低得多——汇编语言的注释通常*会*解释如何以及为什么。
- en: There isn't an enormous a difference between the remaining three. Shell scripts
    can be quite hard to read back; they are proto-Perl in this respect. Careful commenting
    helps. You're more likely to use literate programming techniques on a large C/C++
    codebase.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的三种类型之间没有巨大的差异。Shell脚本可能很难阅读；在这方面，它们是Perl的原型。仔细的注释有所帮助。你更有可能在大型C/C++代码库上使用文献编程技术。
- en: '**You can run tools to calculate what percentage of your source code lines
    are comments. How useful are these tools? How accurate a measure is this of comment
    quality?**'
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你可以运行工具来计算你的源代码行中有多少百分比是注释。这些工具有多有用？这个度量标准对注释质量的衡量有多准确？**'
- en: This kind of metric will give insight into the code, but you shouldn't get too
    concerned about it. It isn't an accurate reflection of code quality. Well-documented
    code might not contain *any* comments. Enormous revision histories or large corporate
    copyright messages can dominate small files, affecting this metric.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 这种度量标准将提供对代码的洞察，但你不必过于担心它。它并不是代码质量的准确反映。文档良好的代码可能不包含任何注释。巨大的修订历史或大型公司的版权信息可能会主导小文件，影响这个度量标准。
- en: '**If you come across some incomprehensible code, which is the better way to
    factor in some intelligibility: adding comments to document what you think is
    going on, or renaming variables/functions/types with more descriptive names? Which
    approach will most likely be easier? Which approach will be safer?**'
  id: totrans-823
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你遇到一些难以理解的代码，哪种方法更能提高可读性：添加注释来记录你认为正在发生的事情，还是用更具描述性的名称重命名变量/函数/类型？哪种方法最有可能更容易？哪种方法更安全？**'
- en: You should do both, as appropriate. Renaming is arguably the best approach,
    but it's dangerous if you don't know exactly what a function does. You might be
    giving it another equally bad name. When renaming, you must be sure you know the
    nature of the item you're changing.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该根据适当的情况做两件事。重命名可以说是最好的方法，但如果你不知道函数的确切功能，它就非常危险。你可能会给它另一个同样糟糕的名字。在重命名时，你必须确保你知道你正在更改的项目性质。
- en: Use the code's unit tests to ensure that your modifications don't break any
    behavior.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码的单元测试来确保你的修改不会破坏任何行为。
- en: '**When you document a C/C++ API with a code comment block, should it go in
    the public header file that declares the function or the source file containing
    the implementation? What are the pros and cons of each location?**'
  id: totrans-826
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当你用代码注释块来文档化C/C++ API时，它应该放在声明函数的公共头文件中，还是放在包含实现的源文件中？每个位置都有哪些优点和缺点？**'
- en: This question was the cause of a big fight at one place I worked. Some argued
    for descriptions to go in the `.c` file. Being close to the function means that
    it's harder to write an incorrect comment and harder to write code that doesn't
    match the documentation. The comment is also more likely to be changed in line
    with any code changes.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题曾在我工作过的一个地方引发了一场大争论。有些人主张描述应该放在`.c`文件中。靠近函数意味着写一个不正确的注释更难，编写与文档不匹配的代码也更难。注释也更有可能随着任何代码更改而更改。
- en: However, when placed in a header file, the description is visible alongside
    the public interface—a logical location. Why should someone have to look into
    the implementation to read any public API docs?
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当放在头文件中时，描述与公共接口并列显示——这是一个逻辑位置。为什么有人需要查看实现才能阅读任何公共API文档？
- en: A literate programming documentation tool should be able to pull comments out
    of either place, but sometimes it's quicker to just read comments in the source
    instead of using the tool—a bonus of the literate code approach. I favor placing
    the comments in header files.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有教养的编程文档工具应该能够从任何地方提取注释，但有时直接阅读源代码中的注释比使用工具更快——这是有教养的代码方法的一个优点。我倾向于将注释放在头文件中。
- en: Of course, in Java and C#, there's only one source file anyway; you'd conventionally
    use the Javadoc or C# XML comment format.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Java和C#中，源文件只有一个；你通常会使用Javadoc或C# XML注释格式。
- en: Getting Personal
  id: totrans-831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取个人
- en: '**Look carefully at the source files you''ve recently worked on. Inspect your
    commenting. Is it honestly any good? (I bet as you read through the code you''ll
    find yourself making a few changes!)**'
  id: totrans-832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**仔细查看你最近工作的源文件。检查你的注释。这真的好吗？（我打赌当你阅读代码时，你会发现自己做了一些修改！）**'
- en: When you read and review your own code, it's very easy to skip the comments,
    presuming they're correct or at least adequate. It is a good idea to spend some
    time looking at them and assess how well you've written them. Perhaps you could
    ask a trusted colleague to give you his or her (constructive) opinion on your
    commenting style.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读和审查自己的代码时，很容易跳过注释，假设它们是正确的或者至少是足够的。花些时间仔细查看它们，并评估你写得好不好。也许你可以请一个值得信赖的同事给你提供他或她的（建设性的）意见关于你的注释风格。
- en: '**How do you ensure that your comments are genuinely valuable and not just
    personal ramblings that only you can understand?**'
  id: totrans-834
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何确保你的注释真正有价值，而不仅仅是只有你自己才能理解的个人杂谈？**'
- en: 'Some considerations for this are: write whole sentences, avoid abbreviations,
    and keep comments neatly formatted and in a common language (both the native language
    and the selection of words used from the problem domain). Avoid inside jokes,
    throw-away statements, or anything that you''re not entirely sure about.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，可以考虑以下几点：写完整的句子，避免缩写，并保持注释整洁格式化，使用通用语言（包括母语和从问题域中选用的词汇）。避免内部玩笑、无关紧要的陈述或任何你不确定的事情。
- en: Code reviews will highlight weaknesses in your comment strategy.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查将突出你在注释策略中的弱点。
- en: '**Do the people you work with all comment to the same standard, in about the
    same way?**'
  id: totrans-837
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你和你的同事是否都按照相同的标准，以类似的方式注释？**'
- en: '**Who''s the best at writing comments? Why do you think that? Who''s the worst?
    How much of a correlation does this bear to these individuals'' general quality
    of coding?**'
  id: totrans-838
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谁在编写注释方面最擅长？你为什么这么认为？谁最差？这与这些个人的整体编码质量有多少关联？**'
- en: '**Do you think any imposed coding standards could raise the quality of the
    comments written by your team?**'
  id: totrans-839
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你认为任何强加的编码标准能提高你团队编写的注释质量吗？**'
- en: Use code reviews to inspect the comment quality of your peers and to move your
    team toward a consistent quality of commenting.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码审查来检查你同事的注释质量，并推动你的团队朝着一致的注释质量发展。
- en: '**Do you include history logging information in each source file? If yes:**'
  id: totrans-841
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在每个源文件中都包含历史记录日志信息吗？如果是的：**'
- en: '**Do you do maintain it manually? Why, if your revision control system will
    insert this for you automatically? Is the history kept particularly accurate?**'
  id: totrans-842
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是手动维护的吗？为什么，如果你的版本控制系统会自动插入这些内容？历史记录是否保持得特别准确？**'
- en: '**Is this really a sensible practice? How often is this information needed?
    Why is it better if placed in the source file than in another, separate mechanism?**'
  id: totrans-843
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这真的是一个合理的做法吗？这种信息需要多频繁？为什么将其放在源文件中比放在另一个单独的机制中更好？**'
- en: It's human nature not to keep a history accurate, even with the best intentions
    in the world. It requires a lot of manual work that gets skipped when time is
    tight. You should use tools to help maintain a history and put the right information
    in the right place (which I don't believe is the source file at all).
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有最好的意图，人类的天性也不太可能保持历史记录准确。这需要大量的手动工作，当时间紧迫时，这些工作往往会跳过。你应该使用工具来帮助维护历史记录，并将正确的信息放在正确的位置（我相信根本不是源文件）。
- en: '**Do you add your initials to or otherwise mark the comments you make in other
    people''s code? Do you ever date comments? When and why do you do this—is it a
    useful practice? Has it ever been useful to find someone else''s initials and
    timestamping?**'
  id: totrans-845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在别人的代码中添加你的首字母缩写或以其他方式标记你做出的注释吗？你曾经给注释加日期吗？何时以及为什么这样做——这是一个有用的实践吗？有人找到别人的首字母缩写和日期标记是否曾经有用过？**'
- en: For some comments, this is a useful practice. In other places, it's just inconvenient—extra
    comment noise that you have to read past to get to the really interesting stuff.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些注释，这是一种有用的实践。在其他地方，这仅仅是不方便——额外的注释噪音，你必须阅读过去才能到达真正有趣的内容。
- en: It's most useful with temporary `FIXME` or `TODO` comments, marking work in
    progress. Released production code probably shouldn't have these; no finished
    code should need a reader to understand the author or date of a particular change.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 这在标记临时`FIXME`或`TODO`注释，标记正在进行的工作时最有用。发布的生产代码可能不应该有这些；没有完成的代码不应该需要读者来理解作者或特定更改的日期。
- en: '[Chapter 6](ch06.html "Chapter 6. TO ERR IS HUMAN")'
  id: totrans-848
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第6章](ch06.html "第6章。人非圣贤，孰能无过")'
- en: Mull It Over
  id: totrans-849
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: '**Are return values and exceptions equivalent error reporting mechanisms? Prove
    it**.'
  id: totrans-850
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**返回值和异常是等价的错误报告机制吗？证明它**。'
- en: Return values are equivalent to global *status variables* because the same reason
    code information can be sent back by both mechanisms (although it is easier to
    ignore a status variable). You can write code that works in a similar manner using
    both of these approaches.^([[7](#ftn.APP-FN-7)])
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值等同于全局*状态变量*，因为这两种机制都可以通过相同的原因代码信息发送回来（尽管忽略状态变量更容易）。你可以编写使用这两种方法的代码，以类似的方式工作.^([[7](#ftn.APP-FN-7)])
- en: 'Exceptions are a very different beast. They involve a new control flow, something
    very different from simple reason codes. They are tightly bound into the language
    and program run time. While you *can* simulate exceptions by hand-crafting code
    that propagates errors, you''d have to carefully consider:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一种非常不同的生物。它们涉及新的控制流，这与简单的理由代码非常不同。它们与语言和程序运行时紧密绑定。虽然你可以通过手动编写传播错误的代码来模拟异常，但你必须仔细考虑：
- en: How to represent errors as arbitrary objects, not just as integer reason codes
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将错误表示为任意对象，而不仅仅是整数原因代码
- en: Supporting exception class hierarchies and providing the ability to catch by
    base class
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异常类层次结构并提供通过基类捕获的能力
- en: Propagating exceptions through *any* function, even those without `try`, `catch`,
    or `throw` statements
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过*任何*函数传播异常，即使是没有`try`、`catch`或`throw`语句的函数
- en: It's that final point which shows most clearly why the two are *not* equivalent.
    Implemented at a language level, exceptions are not at all intrusive in your code.
    A hand-crafted facsimile must manage the possibility of failure at every point.
    Every function is forced to return an error code—even if it cannot fail itself—just
    to propagate other error information. This requires serious adaptation of the
    code.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一个观点最清楚地表明了为什么两者*并不*等价。在语言级别实现，异常对你的代码并不具有侵入性。手工制作的仿制品必须在每个点上管理失败的可能性。每个函数都必须返回一个错误代码——即使它自己不能失败——只是为了传播其他错误信息。这需要对代码进行重大调整。
- en: '**What different implementations of tuple return types can you think of? Don''t
    limit yourself to a single programming language. What are the pros and cons of
    using tuples as a return value?**'
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能想到哪些元组返回类型的不同实现？不要限制自己于单一编程语言。使用元组作为返回值的优缺点是什么？**'
- en: 'In C you can create a `struct` for every return type, linking it with an error
    reason code. This would look something like:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，你可以为每个返回类型创建一个`struct`，将其与错误原因代码链接。这看起来可能像：
- en: '[PRE12]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is messy, tedious to write, cumbersome to use, and hard to read. You can
    exploit C++ templates or Java/C# generics to automatically build this scaffolding,
    or you can use C++'s `std::pair` class. Both approaches are seen in production
    C++ code. Both are tedious to use, with the extra declarations and the machinery
    necessary to return these types. Some languages, like Perl, support lists of arbitrary
    types; this is a much easier implementation mechanism. Functional languages also
    provide such a facility.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 这很混乱，编写起来很繁琐，使用起来很笨拙，阅读起来也很困难。你可以利用C++模板或Java/C#泛型来自动构建这个框架，或者你可以使用C++的`std::pair`类。这两种方法都在生产C++代码中看到。两者都使用起来很繁琐，需要额外的声明和必要的机制来返回这些类型。一些语言，如Perl，支持任意类型的列表；这是一个更简单的实现机制。函数式语言也提供了这样的功能。
- en: 'We''ve just seen some of the disadvantages of this technique: It''s very intrusive
    in the code and not at all sympathetic to the reader. It is also not an idiomatic
    coding practice. There may be a performance hit when returning more than one argument,
    but this is not a compelling argument, unless you''re working at the machine code
    level. The notable advantage is that a separate reason code doesn''t interfere
    with any return value.'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了这种技术的一些缺点：它在代码中非常侵入性，并且对读者一点也不友好。它也不是一种惯用的编码实践。当返回多个参数时可能会有性能损失，但这不是一个有说服力的论点，除非你在机器代码级别工作。一个显著的优势是，单独的理由代码不会干扰任何返回值。
- en: '**How do exception implementations differ between languages?**'
  id: totrans-862
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不同语言中的异常实现有何不同？**'
- en: 'The four main implementations we''ll consider are: C++, Java, .NET, and Win32
    structured exceptions. Win32 exceptions are bound to the operating platform, the
    others to their languages. Languages *may* be implemented in terms of such underlying
    platform facilities, or they may not be.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的四种主要实现方式是：C++、Java、.NET和Win32结构化异常。Win32异常绑定到操作系统平台，而其他的是绑定到它们的语言。语言*可能*可以通过这样的底层平台设施来实现，也可能不行。
- en: They all follow a similar approach; you can `throw` an exception, which is later
    handled by a `catch` statement placed after code wrapped in a `try` block. They
    all follow the termination model's behavior.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都遵循类似的方法；你可以`throw`一个异常，然后由放置在`try`块后代码中的`catch`语句来处理。它们都遵循终止模型的行为。
- en: Java, .NET, and Win32 also have a `finally` construct. It contains code that
    is run whether execution leaves the `try` block normally or abnormally. This can
    be a good place to put cleanup code to ensure that it always gets called. `finally`
    can be simulated in C++, but it isn't pleasant.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: Java、.NET和Win32也有`finally`构造。它包含无论执行是否正常或异常离开`try`块的代码。这可以是一个放置清理代码的好地方，以确保它总是被调用。在C++中可以模拟`finally`，但这并不愉快。
- en: The raw Win32 exceptions (minus any language support provided by compilers)
    don't clean up as they unwind the stack, because the OS has no concept of destructors.
    They must be used with care—they are intended to handle situations more akin to
    signals than code logic errors.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Win32异常（减去编译器提供的任何语言支持）在栈回溯时不会清理，因为操作系统没有析构函数的概念。它们必须谨慎使用——它们旨在处理类似于信号而不是代码逻辑错误的情况。
- en: Java exceptions (deriving from `Throwable`) and C# exceptions (deriving from
    `Exception`) automatically provide a diagnostic backtrace—very helpful in later
    debugging. .NET's CLI allows anything to be thrown, but C# does not expose the
    ability to do so (it does expose the ability to catch them, though). Other .NET
    languages can throw whatever they like.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: Java异常（从`Throwable`派生）和C#异常（从`Exception`派生）会自动提供诊断回溯——这在后续调试中非常有帮助。.NET的CLI允许抛出任何东西，但C#没有暴露出这样做的能力（尽管它暴露了捕获它们的能力）。其他.NET语言可以抛出它们喜欢的东西。
- en: '**Signals are an old-school Unix mechanism. Are they still needed now that
    we have modern techniques like exceptions?**'
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**信号是一种老式的Unix机制。现在我们有了像异常这样的现代技术，它们是否仍然需要？**'
- en: Yes, they are still needed. Signals are a part of the ISO C standard, and so
    they aren't easy to remove, anyway. Signals date from (pre) System-V Unix implementations.
    They are an asynchronous mechanism to report system-level problems/events. Exceptions
    solve a different problem, reporting code logic errors that can percolate up to
    a handler. It makes no sense to throw an exception for signal-type events, especially
    using the termination model—it doesn't provide asynchronous handling.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它们仍然需要。信号是ISO C标准的一部分，因此它们不容易被移除。信号起源于（前）System-V Unix实现。它们是一种异步机制，用于报告系统级问题/事件。异常解决的是不同的问题，报告的是可以渗透到处理器的代码逻辑错误。对于信号类型的事件抛出异常是没有意义的，特别是使用终止模型——它不提供异步处理。
- en: '**What is the best code structure for error handling?**'
  id: totrans-870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误处理的最佳代码结构是什么？**'
- en: There is simply no answer to this question. Different code strategies will work
    best in different situations. What's important is to reliably detect and handle
    errors with clear, readable, maintainable code.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，根本就没有答案。不同的代码策略在不同的情境下可能效果最佳。重要的是要使用清晰、可读、可维护的代码可靠地检测和处理错误。
- en: '**How should you handle errors that occur in your error-handling code?**'
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该如何处理在错误处理代码中发生的错误？**'
- en: Errors signaled within error handlers should be dealt with as you would any
    other error. It gets nasty fast, though—you end up with error handlers nested
    within error handlers nested within error handlers. Be very careful about this,
    and check for a neater way to structure your code.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误处理程序中发出的错误应该像处理任何其他错误一样处理。但这会很快变得棘手——你最终会有嵌套在嵌套在嵌套中的错误处理程序。对此要非常小心，并检查是否有更整洁的方式来结构化你的代码。
- en: A better approach is to only perform operations that are guaranteed to succeed
    (or that honor the nothrow exception guarantee) in your error handlers. That way,
    your world is a much nicer place to be.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '一个更好的方法是只在错误处理程序中执行保证成功的操作（或遵守nothrow异常保证），这样你的世界就会变得更好。 '
- en: Getting Personal
  id: totrans-875
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**How thorough is the error handling in your current codebase? How does this
    contribute to the stability of the program?**'
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你当前代码库中的错误处理有多彻底？这如何有助于程序的稳定性？**'
- en: There is a direct correlation between good error handling and stable code. Either
    your program is not required to be robust, or it *must* systematically detect
    and handle all error conditions. If this isn't deeply rooted in the program's
    philosophy, then you will not have a reliable system.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的错误处理与稳定的代码之间存在直接关联。要么你的程序不需要具有鲁棒性，要么它必须系统地检测和处理所有错误条件。如果这不是深深植根于程序哲学中的话，那么你将不会有一个可靠的系统。
- en: '**Do you naturally consider error handling as you write code, or do you find
    it a distraction, preferring to come back to it later?**'
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在编写代码时是否自然地考虑错误处理，还是觉得它是一种干扰，更愿意稍后回来处理？**'
- en: 'It''s natural to dislike error handling; no one wants to focus on the negative
    aspects of program functionality all the time.^([[8](#ftn.APP-FN-8)]) However,
    heed this important advice: Don''t put it off until later. If you do, some potential
    errors will inevitably be missed, one day causing unexpected program behavior.
    Get into the habit of thinking about errors *now*.'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 不喜欢错误处理是自然的；没有人想一直关注程序功能的负面方面。[^8](#ftn.APP-FN-8)。然而，请注意这条重要建议：不要推迟到以后。如果你这样做，一些潜在的错误不可避免地会被忽略，最终导致程序行为意外。
- en: '**Go to the last (reasonably sized) function you wrote or worked on, and perform
    a careful review of the code. Find every abnormal occurence and potential error
    situation. How many of these were actually handled in your code?**'
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回到你最近编写或修改的最后一个（合理大小的）函数，仔细审查代码。找出每一个异常情况以及潜在的错误情况。这些中有多少在你的代码中得到了实际处理？**'
- en: '**Now get someone else to review it. Don''t be shy! Did they find any more?
    Why? What does this tell you about the code you''re working on?**'
  id: totrans-881
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**现在让其他人来审查它。不要害羞！他们是否发现了更多？为什么？这对你正在工作的代码有什么启示？**'
- en: This is a telling insight into how thorough a programmer you really are. Make
    sure that you perform this exercise carefully—and *do* ask someone else. Even
    the most accomplished programmer will miss some error cases.^([[9](#ftn.APP-FN-9)])
    If these are unlikely to manifest as bugs, you'll probably never notice and live
    forever in the shadow of potentially weird behavior.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对你真正程序员程度的一个揭示性见解。确保你仔细地执行这个练习——并且真的要询问其他人。即使是经验最丰富的程序员也会错过一些错误情况。[^9](#ftn.APP-FN-9)。如果这些不太可能表现为错误，你可能永远不会注意到，并永远生活在可能奇怪行为阴影之下。
- en: When using exceptions, you can't easily ignore an error case—exceptions force
    their own way up the call stack, regardless of whether you handle them or not.
    You *can* still write bad code if it isn't exception safe (it may exit in a bad
    state, or with leaked resources) or if it performs over-eager catches (consuming
    errors that can't actually be handled at that level—for this reason, don't write
    `catch(...)` to catch all exceptions).
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异常时，你无法轻易忽略错误情况——无论你是否处理它们，异常都会强制自己的方式沿着调用栈向上传递。你仍然可以写出糟糕的代码，如果它不是异常安全的（它可能以不良状态退出，或者有资源泄露）或者如果它执行了过于激进的捕获（消耗了在那个级别实际上无法处理的错误——因此，不要写`catch(...)`来捕获所有异常）。
- en: '**Do you find it easier to manage and reason about error conditions using return
    values or exceptions? Are you sure you know what is involved in writing exception-safe
    code?**'
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你发现使用返回值或异常来管理和推理错误条件更容易吗？你确定你知道编写异常安全代码涉及哪些内容吗？**'
- en: To some extent, this depends on what you're used to. Exceptions complement and
    extend return values. An exception user can also understand return values, but
    the opposite doesn't necessarily hold. Return values are more obvious, hence easier
    to use properly.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，这取决于你习惯什么。异常补充并扩展了返回值。异常用户也可以理解返回值，但反之不一定成立。返回值更明显，因此更容易正确使用。
- en: If you do use exceptions, it's important to know what issues to be aware of.
    Exception safety affects *all* of your code, not just the parts that raise and
    catch errors. Exception safety is a large and involved subject that needs much
    study. Don't underestimate how seriously it affects the way you program.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实使用异常，了解需要注意的问题很重要。异常安全性影响*所有*你的代码，而不仅仅是引发和捕获错误的代码部分。异常安全性是一个庞大且复杂的话题，需要深入研究。不要低估它对你编程方式的影响。
- en: '* * *'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[7](#APP-FN-7)]) They are not quite the same, though. In C++ you can return
    a *proxy* value type that has behavior in its destructor. This infuses extra magic
    into the return code mechanism.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#APP-FN-7)]) 虽然它们并不完全相同。在C++中，你可以返回一个具有其析构函数行为的*代理*值类型。这为返回代码机制注入了额外的魔力。
- en: ^([[8](#APP-FN-8)]) If you are inclined that way, you'd probably make a very
    good software tester. But don't change careers just yet—really thorough programmers
    are few and far between.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#APP-FN-8)]) 如果你倾向于这样做，你可能会成为一个非常好的软件测试员。但不要急于改变职业——真正彻底的程序员是少数。
- en: ^([[9](#APP-FN-9)]) How often does anyone check for errors from C's `printf`,
    for example?
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#APP-FN-9)]) 例如，有多少人经常检查C的`printf`中的错误？
- en: '[Chapter 7](ch07.html "Chapter 7. THE PROGRAMMER''S TOOLBOX")'
  id: totrans-891
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。程序员的工具箱")'
- en: Mull It Over
  id: totrans-892
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细考虑
- en: '**Is it more important for everyone in a development team to use the same IDE,
    or for each person to pick the one that suits him or her best? What are the implications
    of different people using different tools?**'
  id: totrans-893
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对于开发团队中的每个人来说，使用相同的IDE是否比每个人选择最适合他们的IDE更重要？不同的人使用不同的工具会有什么影响？**'
- en: All professional programmers should be responsible and informed enough to select
    the tools that make them most productive. No two programmers are the same, and
    different people will naturally prefer different tools. As long as the choice
    is made based on practical considerations, the team's overall effectiveness will
    be improved. But forcing strong-minded techies to use particular tools rarely
    enthuses them to work well.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 所有专业程序员都应该足够负责任和有信息量，以选择最使他们高效工作的工具。没有两个程序员是相同的，不同的人自然会偏好不同的工具。只要选择是基于实际考虑的，团队的总体效率就会提高。但强迫有主见的技术人员使用特定的工具很少能激发他们高效工作的热情。
- en: If the people on a team *are* all using different development environments,
    then they must work together properly. They must build *identical* code, and each
    editor mustn't fight the others' layout rules every time a source file is edited.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 如果团队中的每个人都使用不同的开发环境，那么他们必须正确地合作。他们必须构建*相同*的代码，并且每次编辑源文件时，每个编辑器都不应该与其他人的布局规则发生冲突。
- en: '**What is the minimum set of tools that any programmer should have at his or
    her disposal?**'
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任何程序员应该拥有的最小工具集是什么？**'
- en: 'You can''t get by without at least:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 没有至少以下这些，你将无法生存：
- en: Some rudimentary form of editor
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些基本的编辑器形式
- en: The minimum language support required (either a compiler, an interpreter, or
    both—it depends on the language)
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的最小语言支持（编译器、解释器或两者兼而有之——这取决于语言）
- en: A computer to run them on
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于运行它们的计算机
- en: But that minimum set won't make a very productive programmer. You need a toolbox
    of other tools to get any serious work done.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个最小集合并不能使程序员非常高效。你需要一套其他工具来完成任何严肃的工作。
- en: There must be a revision control system, or work is downright dangerous.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个版本控制系统，否则工作将非常危险。
- en: A reasonable set of libraries will prevent reinventing wheels and lower the
    risk of introducing avoidable bugs.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个合理的库集合可以防止重复造轮子，并降低引入可避免错误的风险。
- en: You also need a build tool to help construct the software system.
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要一个构建工具来帮助构建软件系统。
- en: That's a more realistic minimum set. The more fundamental tools you add in,
    the easier it is to develop, and the better the code that will be produced.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更现实的最低要求。你添加的基础工具越多，开发就越容易，产生的代码质量就越好。
- en: '**Which are more powerful: command-line or GUI-based tools?**'
  id: totrans-906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**命令行工具和基于GUI的工具哪个更强大？**'
- en: I should break your arm if you even began to answer this question. Command-line
    and GUI tools are different. End of story.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你甚至开始回答这个问题，我应该打断你的手臂。命令行和 GUI 工具是不同的。这就是故事的结局。
- en: 'An interesting philosophical question is: *In this context, how do you define
    "powerful?"* Does it mean having more esoteric features? Does it mean how easy
    the tool is to use? Does it mean how fast it runs? Or does it determine how well
    a tool fits into the rest of the toolchain? Decide on a definition, and then try
    justifying your answer in terms of that. Then I might not break your arm.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的哲学问题是：*在这个背景下，你如何定义“强大”？* 这意味着拥有更多深奥的功能吗？这意味着工具使用起来有多容易吗？这意味着它运行得多快吗？或者这决定了工具如何融入整个工具链？确定一个定义，然后尝试用那个定义来证明你的答案。这样我可能就不会打断你的手臂。
- en: '**Are there construction tools that aren''t programs?**'
  id: totrans-909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有没有不是程序的构建工具？**'
- en: 'We already categorized languages and libraries as tools, so the answer is *yes*.
    Other good examples to consider are:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将语言和库分类为工具，所以答案是 *是的*。其他值得考虑的好例子包括：
- en: Regular expressions
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Graphical components (GUI "widgets")
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形组件（GUI "小部件"）
- en: Network services
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务
- en: Common protocols and formats (like XML)
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见协议和格式（如 XML）
- en: UML diagrams
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UML 图
- en: Design methodologies (like CRC cards)
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计方法（如 CRC 卡）
- en: '**What''s most important for a tool?**'
  id: totrans-917
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对于工具来说，最重要的是什么？**'
- en: '**Interoperability**'
  id: totrans-918
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**互操作性**'
- en: '**Flexibility**'
  id: totrans-919
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**灵活性**'
- en: '**Customization**'
  id: totrans-920
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定制**'
- en: '**Power**'
  id: totrans-921
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**力量**'
- en: '**Ease of use and learning**'
  id: totrans-922
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**易用性和学习**'
- en: Each of these is important. The balance probably changes for different types
    of tools and the situations in which you'll use them.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的每一个都很重要。平衡可能因不同类型的工具和您使用它们的情况而有所不同。
- en: Power is important; your tools must be powerful *enough* for the tasks you set
    them to, or your life will be hell. If this weren't the case, programmers would
    edit their source code using Notepad or vi.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 力量很重要；你的工具必须足够强大，才能完成你分配给它们的任务，否则你的生活将变得痛苦不堪。如果不是这样，程序员将使用记事本或 vi 编辑源代码。
- en: Getting Personal
  id: totrans-925
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个性化
- en: '**What are the common tools in your toolbox? Which do you use every day? Which
    do you use a few times a week? Which do you only call on occasionally?**'
  id: totrans-926
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你工具箱中的常用工具有哪些？你每天都用哪些？你一周用几次？你只是偶尔使用哪些？**'
- en: '**How well do you know how to use them?**'
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你了解如何使用它们吗？**'
- en: '**Are you getting the most from every tool?**'
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否从每个工具中获得了最大收益？**'
- en: '**How did you learn to use them? Did you ever spend any time improving your
    skill with them?**'
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是如何学会使用它们的？你是否花过时间提高使用它们的技能？**'
- en: '**Are these the best tools you could be using?**'
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这些是你能使用的最佳工具吗？**'
- en: The last question in that list is critical. Honestly appraise whether there
    are any better tools you could be using. It really is worth spending some time
    looking around. If there are better tools, get your hands on them and start experimenting.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '列表中的最后一个问题至关重要。诚实地评估是否有更好的工具可以使用。真的值得花些时间四处看看。如果有更好的工具，就动手尝试一下。 '
- en: '**How up to date are your tools? Does it matter if they''re not the latest
    cutting-edge versions?**'
  id: totrans-932
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的工具有多新？如果它们不是最新的尖端版本，这有关系吗？**'
- en: Out-of-date tools can cause nasty problems, but so can the latest tool versions.
    The nastiest problems occur when one tool version is out of sync with rest of
    the toolchain. There may be a subtle functional mismatch because of the version
    skew, causing the toolchain not to work together properly. The symptom is seldom
    a toolchain failure, but code that behaves in surprising ways.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的工具可能会引起棘手的问题，但最新的工具版本也可能如此。最棘手的问题发生在工具版本与工具链的其他部分不同步时。由于版本差异，可能会有细微的功能不匹配，导致工具链无法正常协同工作。症状很少是工具链故障，而是代码以令人惊讶的方式运行。
- en: Out-of-date tools may miss important bug fixes. An update might not seem important
    until you've been bitten by the bug it addresses. Hindsight is a wonderful thing.
    If you get out of date, you could end up relying on tools that are no longer supported,
    written by companies that no longer exist. This can become a serious problem in
    a critical project.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的工具可能会错过重要的错误修复。更新可能在你被它解决的错误咬到之前看起来并不重要。事后诸葛亮是件好事。如果你过时了，你可能会依赖不再受支持的工具，这些工具是由不再存在的公司编写的。这可能会在关键项目中成为一个严重问题。
- en: Of course, you can't always download and install a new tool version on a whim.
    It may not be practical to upgrade for a number of reasons. It may cost more than
    you can afford. The upgrade may force you to upgrade your OS or other critical
    parts of your toolchain, when this isn't practical.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不可能总是随意下载和安装新的工具版本。由于多种原因，升级可能并不实际。升级可能比你负担得起的花费还要多。升级可能迫使你升级你的操作系统或其他工具链的关键部分，而这并不实际。
- en: '**Do you favor an integrated tool set (like a visual development environment)
    or a discrete toolchain? What are the advantages of the other approach? How much
    experience do you have with both ways of working?**'
  id: totrans-936
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你更喜欢集成工具集（如可视化开发环境）还是离散的工具链？另一种方法的优点是什么？你对这两种工作方式有多少经验？**'
- en: A careless answer here might cost you your arm (see the answer to question 3
    in the "Mull It Over" section on page 491). Try to come up with a serious list
    of the benefits of the other way of working—to ensure you avoid a narrow-minded
    and opinionated view.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里给出一个粗心的答案可能会让你付出代价（参见第491页“Mull It Over”部分中关于第3个问题的答案）。试着列出其他工作方式的优点，以确保你避免狭隘和偏见的观点。
- en: '**Are you a Default Dan or a Tweaker Tom? Do you accept the default settings
    in your editor, or do you customize them to within an inch of their lives? Which
    is the "better" approach?**'
  id: totrans-938
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是默认的丹还是调整的汤姆？你接受编辑器的默认设置，还是将其调整到极致？哪种方法是“更好”的？**'
- en: You learn to use and get the most out of your editor by discovering how to configure
    it. In that case, Tom *might* have the most sensible approach. A pragmatic stance
    is probably somewhere between the two (a good example of the *Goldilocks principle*;
    behavior at the extremes is rarely best). There's no point configuring features
    you'll never touch. Some things really don't matter—I'm not all that worried about
    the color scheme an editor uses. But others things do matter—I don't want to be
    forced to accept a default code layout style if it's grotesque.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发现如何配置它，你学会了如何使用和最大限度地利用你的编辑器。在这种情况下，汤姆*可能*有最合理的做法。实用主义立场可能介于两者之间（*金发姑娘原则*的一个好例子；极端的行为很少是最好的）。配置你永远不会使用的功能是没有意义的。有些事情真的不重要——我对编辑器使用的颜色方案并不那么担心。但有些事情确实很重要——我不想被迫接受一个丑陋的默认代码布局风格。
- en: It's far better to code to your carefully chosen layout style than have it dictated
    by the editor's default settings. Indeed, your house coding style may *require*
    it. I'd rather configure my editor to automatically format code as I want, rather
    than fight its cursor positioning every time I hit ENTER.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按照你精心选择的布局风格编写比由编辑器的默认设置决定要好得多。事实上，你的家庭编码风格可能*要求*这样做。我宁愿配置我的编辑器自动格式化代码，而不是每次按下ENTER键时都与光标定位作斗争。
- en: This kind of discussion scales beyond editors to any kind of configurable software
    tool.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 这种讨论的范围不仅限于编辑器，还包括任何可配置的软件工具。
- en: '**How do you determine your budget for software tools? How do you know whether
    a tool is worth its cost?**'
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是如何确定你的软件工具预算的？你如何知道一个工具是否值得它的成本？**'
- en: It depends on what kind of organization you're working for and the kind of work
    you're doing. If your project has the tools budget of a small country's GDP, then
    the cost of tools is of no consequence—buy the best tools (which may not necessarily
    be the most expensive ones) and enjoy them. But a lone hacker working at home
    can't justify the same kind of expense for a top-notch toolchain. Often the freely
    available tools are more than adequate for this kind of home use.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你为哪种组织工作以及你正在做什么类型的工作。如果你的项目拥有一个小国GDP的工具预算，那么工具的成本就无关紧要了——买最好的工具（这不一定是最贵的）并享受它们。但一个在家工作的独立黑客无法为顶级的工具链提供同样的开销。通常，免费提供的工具对于这种家庭使用已经足够了。
- en: Indeed, the freely available tools are often of a very high quality, which makes
    it hard to draw the line as to when paying for tools is worthwhile. Paying for
    a toolchain usually means that you can *expect* good product support and demand
    future bug fixes or development work. However, this doesn't always pan out—companies
    go out of business and products are discontinued. This is *perhaps* an argument
    for picking the most popular, widely used tools. There's safety in numbers.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，免费提供的工具通常质量非常高，这使得很难确定何时为工具付费是值得的。为工具链付费通常意味着你可以*期望*良好的产品支持，并要求未来的错误修复或开发工作。然而，这并不总是如此——公司可能会倒闭，产品可能会被停止。这可能*或许*是选择最受欢迎、最广泛使用的工具的一个论据。数量上有安全。
- en: If all reasonable criteria fail, the more expensive a tool is, the larger its
    box should be. If it costs a fortune but comes in a small box, don't buy it!
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有合理的标准都失败了，一个工具越贵，它的盒子应该越大。如果它价值连城却装在一个小盒子里，那就不要买了！
- en: '[Chapter 8](ch08.html "Chapter 8. TESTING TIMES")'
  id: totrans-946
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第8章](ch08.html "第8章. 测试时代")'
- en: Mull It Over
  id: totrans-947
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思一下
- en: '**Write a test harness for the** `greatest_common_divisor` **code example earlier
    in this chapter. Make it as exhaustive as you can. How many individual test cases
    have you included?**'
  id: totrans-948
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为本章前面提到的`greatest_common_divisor`代码示例编写一个测试框架。尽可能使其全面。你包含了多少个单独的测试用例？**'
- en: '**How many of these passed?**'
  id: totrans-949
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有多少通过了？**'
- en: '**How many failed?**'
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有多少失败了？**'
- en: '**Using these tests, identify any faults and repair the code**.'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用这些测试，找出任何错误并修复代码**。'
- en: 'There are a large number of tests you should run, even though there are very
    few invalid input combinations. Thinking of invalid inputs first: Test for *zero*.
    It may or may not be an invalid value (we''ve seen no spec, so we can''t tell),
    but you''d expect the code to cope reasonably with it.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管无效输入组合非常少，但你应该运行大量的测试。首先考虑无效输入：测试*零*。它可能是一个无效值，也可能不是（我们没有看到任何规范，所以无法判断），但你希望代码能够合理地处理它。
- en: Next, write tests considering combinations of usual inputs (say of 1, 10, and
    100 in all orders). Then try numbers with no common multiple, like 733 and 449\.
    Test for some very large numbers and for some negative numbers.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写考虑常规输入组合（比如1、10和100的所有顺序）的测试。然后尝试没有公倍数的数字，比如733和449。测试一些非常大的数字和一些负数。
- en: 'How do you write these test cases? Write a simple unit test function, and then
    place it into an automated test framework. For each test, don''t programatically
    calculate what the correct output value should be;^([[10](#ftn.APP-FN-10)]) just
    check against a known constant value. Keep your test code as simple as possible:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何编写这些测试用例？编写一个简单的单元测试函数，然后将其放入自动化测试框架中。对于每个测试，不要程序性地计算正确的输出值应该是什么；^([[10](#ftn.APP-FN-10)))，只需检查一个已知的常量值。尽量使你的测试代码尽可能简单：
- en: '[PRE13]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a surprisingly large number of tests for this simple function. You
    could argue that for such a small piece of code, it's easier to inspect, review,
    and prove correctness rather than laborously create a set of tests. This seems
    like a valid argument. But—what if later on, someone makes modifications? Without
    the tests, you'd have to carefully reinspect and revalidate the code, an easy
    task to overlook.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的函数，有令人惊讶的大量测试。你可以争辩说，对于这样一小段代码，检查、审查和证明正确性比费力地创建测试集要容易。这似乎是一个合理的论点。但是——如果以后有人进行了修改呢？没有测试，你就必须仔细重新检查和重新验证代码，这是一个容易忽视的任务。
- en: 'Did you find the mistake in `greatest_common_divisor`? There''s a clue coming
    up. If you don''t want the puzzle spoiled, then look away now. . . . *Try feeding
    it a negative argument*. This is a more robust (and more efficient) version written
    in C++:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 你在`greatest_common_divisor`中找到错误了吗？线索即将揭晓。如果你不想破坏谜题，现在就请移开目光……*尝试给它一个负数参数*。这是一个更健壮（且更高效）的C++版本：
- en: '[PRE14]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**How should the testing of a spreadsheet application and an automatic aircraft
    pilot differ?**'
  id: totrans-959
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**电子表格应用程序和自动飞机驾驶员的测试应该如何不同？**'
- en: In an ideal world, there would be no faults in either. In this utopia, both
    would be exhaustively tested and not released until perfect. Reality is somewhat
    different. Whereas you expect spreadsheets to crash from time to time,^([[11](#ftn.APP-FN-11)])
    you expect an autopilot to contain no errors at all. When human lives hang in
    the balance, software is developed in a very different way—far more formally and
    with much greater care. It is tested rigorously. There are safety standards at
    play here.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，两者都不会有错误。在这个乌托邦中，它们都会被彻底测试，直到完美才发布。现实世界有些不同。虽然你期望电子表格偶尔会崩溃，^([[11](#ftn.APP-FN-11)))，但你期望自动驾驶仪完全不含错误。当人类生命处于危险之中时，软件的开发方式就非常不同——更加正式，并且更加小心。它被严格测试。这里有一些安全标准在发挥作用。
- en: '**Should you test all of the test code that you write?**'
  id: totrans-961
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该测试你写的所有测试代码吗？**'
- en: If you think about this for long enough it will give you a headache. You can't
    keep testing test code—how can you be sure the test code for your test code's
    test code is correct? The trick is to keep tests *as simple as possible*. This
    way, the most likely testing errors will be lack of important test cases, not
    problems with the actual lines of test code.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长时间思考这个问题，它会让你头疼。你不能一直测试测试代码——你怎么能确保你的测试代码的测试代码是正确的？诀窍是保持测试尽可能简单。这样，最可能出现的测试错误将是缺少重要的测试用例，而不是测试代码的实际行有问题。
- en: '**KEY CONCEPT**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Keep test code as simple as possible to prevent the introduction of errors*.'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽量保持测试代码尽可能简单，以防止引入错误*。'
- en: '**How does a programmer''s testing differ from a QA department member''s testing?**'
  id: totrans-965
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**程序员的测试与QA部门成员的测试有何不同？**'
- en: Testers are more concerned with the black box style of testing and usually only
    perform product testing. It's rare to have testers working at the code level,
    because most products are executable software; there are comparatively few code
    library vendors.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 测试人员更关注黑盒测试风格，通常只进行产品测试。测试人员很少在代码级别工作，因为大多数产品是可执行软件；相对较少的代码库供应商。
- en: Programmers are more concerned with white box tests, making sure their masterful
    creations work as they planned them to.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员更关注白盒测试，确保他们精湛的创造物按计划工作。
- en: The secret aim of any programmer writing tests is to prove that his code works,
    not to find cases where it doesn't! I can easily write a load of tests to show
    how perfect my code is by deliberately avoiding all the bits I know are problematic.
    This is a good argument for getting someone other than the original programmer
    to create test harnesses.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编写测试的程序员的秘密目标是证明他的代码是有效的，而不是找出它不工作的情况！我可以很容易地编写一大堆测试来展示我的代码是多么完美，通过故意避开所有我知道有问题的部分。这是让除原始程序员之外的其他人创建测试框架的好论据。
- en: '**Is it necessary to write a test harness for every single function?**'
  id: totrans-969
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是否需要为每个单独的函数编写测试框架？**'
- en: You don't need to be quite so extreme. Some functions are easy enough to verify
    by inspection. Be careful not to get sloppy, though—remember to read the code
    *cynically*. Simple getter and setter functions don't need a slew of individual
    tests.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要如此极端。有些函数很容易通过检查来验证。但要小心不要马虎——记得要批判性地阅读代码。简单的获取和设置函数不需要一大堆单独的测试。
- en: At what code size do test harnesses become attractive? Generally when the code
    becomes sufficiently complex to require it. When a single glance can't prove the
    code is correct, write some test cases.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么代码规模下测试框架变得有吸引力？通常当代码变得足够复杂需要它时。当单看一眼不能证明代码是正确的时候，就写一些测试用例。
- en: '**Test-driven development encourages you to write tests first, before any code.
    What sort of tests should you write?**'
  id: totrans-972
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试驱动开发鼓励你在编写任何代码之前先编写测试。你应该编写什么样的测试？**'
- en: Without having written any code, these can only be black box tests. Either that,
    or test-driven developers need a gift of prophecy.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有编写任何代码的情况下，这些只能是黑盒测试。要么这样，或者测试驱动开发者需要先知的能力。
- en: '**Should you write C/C++ tests to check for the handling of** `NULL` **(zero)
    pointer parameters? What''s the value of such a test?**'
  id: totrans-974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该编写C/C++测试来检查对`NULL`（零）指针参数的处理吗？这种测试的价值是什么？**'
- en: If zero is an expected input value, then of course you must test for it.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 如果零是一个预期的输入值，那么当然你必须测试它。
- en: But you don't always need to test for null pointers. If you don't specify magic
    behavior for a zero pointer value, then your function is quite within its rights
    to fall over when you pass it a bad pointer. In this case, zero could be as bad
    as a pointer to deallocated or invalid memory. It's rarely possible to test that
    the code will survive all bad pointers.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 但你并不总是需要测试空指针。如果你没有为零指针值指定魔法行为，那么当传递一个坏指针时，你的函数完全有权崩溃。在这种情况下，零可能和指向已释放或无效内存的指针一样糟糕。很少有可能测试代码能够应对所有坏指针。
- en: However, it *can* be valuable to write code that is robust in the face of zero
    pointers, since they tend to fly around a lot. Many allocation routines return
    zero pointers for failure, and undefined pointers are often set to zero. If the
    dog might bite, it's a good idea to put a muzzle on it.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编写面对零指针时仍然健壮的代码是有价值的，因为它们往往到处乱飞。许多分配例程在失败时返回零指针，未定义的指针通常被设置为零。如果狗可能会咬人，给它带上嘴套是个好主意。
- en: '**Your early code tests might not be on the final platform—you may not yet
    have access to it. Is it safest to defer testing until you do have a target test
    platform, or to steam ahead now?**'
  id: totrans-978
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的早期代码测试可能不在最终平台上——你可能还没有访问权限。是推迟测试直到你有一个目标测试平台更安全，还是现在就继续前进？**'
- en: '**If the code is intended to run in a different environment (perhaps on a high-capacity
    server, or some embedded device), how can you be sure that your tests are representative
    and adequate?**'
  id: totrans-979
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**如果代码打算在不同的环境中运行（可能在高性能服务器上，或者某些嵌入式设备上），你如何确保你的测试是具有代表性和充分的？**'
- en: It depends on the nature of the code you're testing—whether it's a simple function
    doing housekeeping work or some hardware access logic. You must understand the
    differences between the development platform and the target environment. Memory
    constraints or processor speed may affect how the code runs. This probably isn't
    a big deal for the majority of the code you write, for which it is perfectly possible
    to create local test harnesses.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你正在测试的代码的性质——它是一个简单的执行维护工作的函数，还是一些硬件访问逻辑。你必须理解开发平台和目标环境之间的差异。内存限制或处理器速度可能会影响代码的运行。对于你写的绝大多数代码来说，这可能不是什么大问题，对于这些代码，你可以创建本地测试工具。
- en: If your code exploits particular target platform features (parallel processors
    or particular hardware facilities), then you can't test fully without them. There
    may be simulators to check that the code runs; they are helpful, but not the definitive
    answer.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码利用特定的目标平台特性（如并行处理器或特定的硬件设施），那么没有它们你无法进行全面测试。可能有模拟器来检查代码是否运行；它们是有帮助的，但不是最终答案。
- en: Putting all testing off until you have a target platform is a dangerous practice.
    By then you'll have a large body of code that you will have neither the time nor
    the inclination to test fully. For maximum confidence, test as early as you reasonably
    can.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有测试推迟到你有一个目标平台是一种危险的做法。到那时，你将有一大堆代码，你既没有时间也没有意愿进行全面测试。为了获得最大的信心，尽早进行测试。
- en: '**How do you know when you''ve finished and can stop testing? How much is enough?**'
  id: totrans-983
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何知道何时结束测试并停止？多少才算足够？**'
- en: Since testing can't prove the absence of faults, you can never really tell when
    you're done. The task is potentially endless, and we're trying to come up with
    a test plan to make it a realistic exercise.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试不能证明错误的缺失，你永远无法真正知道何时结束。这项任务可能是无限的，我们正在尝试制定一个测试计划，使其成为一个现实的练习。
- en: For simple blocks of code under black box testing, successfully running all
    the test cases in "[Choosing Unit Test Cases](ch08s05.html "Choosing Unit Test
    Cases")" on page 142 is sufficient. The larger your code gets, the more work you
    have to do.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 对于黑盒测试下的简单代码块，在142页的"[选择单元测试用例](ch08s05.html "Choosing Unit Test Cases")"中成功运行所有测试用例就足够了。你的代码越大，你需要做的工作就越多。
- en: 'You can measure the adequacy and exhaustiveness of your tests by the angle
    of attack you''re taking. There are a few key strategies:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过攻击角度来衡量你测试的充分性和彻底性。有几个关键策略：
- en: '**Coverage-based testing**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于覆盖率的测试**'
- en: 'The test plan is specified in terms of *coverage* of the software. For example:
    You may plan to execute every line of code at least once, execute every conditional
    branch both ways, or ensure that all system requirements are exercised at least
    once.'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 测试计划是以软件的*覆盖率*来指定的。例如：你可能计划至少执行每一行代码一次，执行每个条件分支的两种情况，或者确保所有系统需求至少被测试一次。
- en: '**Fault-based testing**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于错误的测试**'
- en: This is based on weeding out a certain percentage of program faults. You start
    with a hypothetical number of faults, generally picked from prior experience.
    You then aim to detect and remove, say, 95 percent of them.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 这基于消除一定比例的程序错误。你从一个假设的错误数量开始，通常是从以往的经验中挑选的。然后，你旨在检测和移除，比如说，95%的错误。
- en: '**Error-based testing**'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于错误的测试**'
- en: This approach focuses on the common points of error, where the software is likely
    to be brittle. For example, you'd eliminate off-by-one errors by testing all boundary
    values.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法侧重于错误发生的常见点，在这些点上软件可能比较脆弱。例如，通过测试所有边界值来消除“差一”错误。
- en: 'Based on this, here are some good reasons to stop testing:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，以下是一些停止测试的好理由：
- en: Regression test cases complete with a certain percentage passed (and no major
    *show-stopping* failures remaining).
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试用例完成，通过了一定比例（并且没有剩余的重大*阻止性*失败）。
- en: Coverage of code, functionality, or requirements reaches a specified point.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码、功能或需求的覆盖率达到了指定的点。
- en: Exhibited bug rate falls below a certain level.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示的错误率低于一定水平。
- en: 'Beyond these are some physical barriers, seldom movable, which will have a
    final say in determining an end point:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有一些物理障碍，很少能移动，它们将在确定终点时发挥最终决定作用：
- en: Hitting scheduled deadlines (testing deadlines or release deadlines). Development
    work has a nasty habit of overrunning and eating into the scheduled test time;
    this requires very careful management.
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击中预定截止日期（测试截止日期或发布截止日期）。开发工作有一个糟糕的习惯，就是超时并消耗预定测试时间；这需要非常仔细的管理。
- en: The test budget is depleted (a very sad criteria for stopping).
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试预算耗尽（一个很悲伤的停止标准）。
- en: The beta or alpha testing period ends.
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的beta或alpha阶段结束。
- en: In most organizations, the decision to stop testing and ship the product comes
    at a deadline. It's a compromise based on the remaining known faults, their severity,
    and the frequency of their occurrence, pitched against the need to get to market.
    The tests allow an informed judgment to be made about how acceptable the software
    is.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数组织中，停止测试并发布产品的决定是在截止日期做出的。这是基于剩余已知故障的数量、严重程度和发生频率与进入市场的需求之间的妥协。测试允许做出关于软件可接受性的明智判断。
- en: Getting Personal
  id: totrans-1002
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**For what percentage of your code do you write tests? Are you happy with this?
    Are your tests an automated part of the build process? What sort of testing do
    you give the remaining code? Is this adequate? What will you do about it?**'
  id: totrans-1003
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你为多少代码编写了测试？你对这个满意吗？你的测试是构建过程的一部分吗？你对剩余代码进行什么样的测试？这是足够的吗？你将如何处理它？**'
- en: 'Don''t feel obliged to write a test harness for every scrap of code. But don''t
    forget to use your brain, either. The implementation of a small function is often
    a no-brainer—so you tend to code it with no brain—and voilà: stupid errors. Since
    a simple function only needs a simple test, it''s probably valuable to write it.
    In my code shop, we have a simple rule: *Every* piece of code has a unit test,
    or it''s not in the codebase.'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 不要觉得有必要为每一行代码编写测试框架。但也不忘使用你的大脑。一个小函数的实现通常是显而易见的——所以你倾向于无脑地编写它——然后：愚蠢的错误。由于一个简单的函数只需要一个简单的测试，所以编写它可能是很有价值的。在我的代码店，我们有一个简单的规则：**每一**段代码都有一个单元测试，否则它就不会在代码库中。
- en: 'Be sure that you *are* performing the adequate and appropriate testing for
    which you are responsible, not just skipping an unpleasant task. Ask yourself
    this: How many of the errors that have bitten you recently could have been prevented
    by a good set of tests? Make sure you do something about it.'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你**确实**在进行你负责的适当和足够的测试，而不仅仅是跳过一个不愉快的任务。问问自己这个问题：最近咬住你的错误中有多少可以通过一组良好的测试来预防？确保你对此采取行动。
- en: If your tests are not a part of the build system, then how do you ensure that
    the tests are ever run and that all the code passes them?
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的测试不是构建系统的一部分，那么你如何确保测试总是运行，并且所有代码都通过它们？
- en: '**How good is your relationship with the people in your QA department? What
    personal reputation do you think you have with them?**'
  id: totrans-1007
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你与QA部门的人的关系如何？你认为你在他们心中的个人声誉如何？**'
- en: It is vital to establish good working relationships between the QA department
    and the software developers. Rivalry often brews; the testing department is seen
    as a bunch of people who aim to get in the way of developers and hinder the path
    to release, rather than as a team who is helping to build a stable product. Usually
    the test and development departments sit far, far away from one another, only
    taking orders from their individual tribal chieftains.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 在QA部门和软件开发者之间建立良好的工作关系至关重要。竞争往往产生；测试部门被视为一群旨在阻碍开发者并阻碍发布进程的人，而不是作为帮助构建稳定产品的团队。通常测试和开发部门相隔很远，只听从各自部落首领的命令。
- en: Forget that.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 忘了这件事。
- en: Make them coffee. Take them out for lunch. Head down to the bar with them. Anything
    to prevent fostering a *them and us* attitude.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 给他们泡咖啡。带他们出去吃午餐。和他们一起去酒吧。做任何能防止培养“他们和我们”的态度的事情。
- en: Develop a professional working relationship. Make sure that you provide them
    with good, well-tested code—not just any old hurried junk. Throwing them your
    scraps to mop up will give the impression that you see them as servants working
    *for* you, not colleagues working *with* you.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 发展专业的工作关系。确保你给他们提供经过良好测试的好代码——而不仅仅是任何旧匆忙的垃圾。把你的碎片扔给他们清理会给人留下你把他们看作是为你工作的仆人，而不是与你一起工作的同事的印象。
- en: '**What''s your usual response to finding an error in your code?**'
  id: totrans-1012
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你通常对在代码中发现错误有何反应？**'
- en: 'There are several possible reactions:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可能的反应：
- en: Disgust and disappointment
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶心和失望
- en: An urge to blame someone else
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要责怪别人的冲动
- en: Happiness, if not downright *excitement*
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是直接的*兴奋*
- en: Pretending you didn't find it, ignoring it, and hoping it will go away (as if
    *that's* likely)
  id: totrans-1017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假装你没有发现它，忽略它，并希望它消失（就像这样很可能会发生）
- en: Some of those are so plainly wrong that I'll assume you can rise above them.
    Does it seem a little crazy to suggest that you might be *happy* to find a fault?
    Surely that's the reasonable reaction for a quality-conscious engineer—it's far
    better to find faults during development than for a user to find them in the field.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些错误如此明显，以至于我假设你可以超越它们。建议你可能会对发现一个故障感到高兴，这听起来是不是有点疯狂？当然，对于一个质量意识强的工程师来说，这显然是合理的反应——在开发过程中发现故障比用户在野外发现它们要好得多。
- en: Your level of excitement will depend on where in the development life cycle
    the fault is found. Discovering a show-stopping bug the day before release won't
    make anyone smile.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 你的兴奋程度将取决于在开发生命周期中发现故障的位置。发布前一天发现一个阻止发布的错误不会让任何人笑。
- en: '**Do you file a fault report for every code problem you uncover?**'
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否为每个发现的代码问题提交故障报告？**'
- en: 'It''s not really necessary to do this for every single fault: If no one''s
    seen your code yet and it''s not been integrated into the wider system, then you
    don''t need to broadcast your incompetence! If you don''t report a fault in the
    database, then you must make methodical notes so that you don''t forget about
    it. For this reason, you might find it easier to use the fault-tracking system
    from the outset. You might be forced to raise fault reports if delivery is so
    late that people *need* visibility of the remaining problems.'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个故障都需要这样做：如果还没有人看到你的代码，它还没有集成到更广泛系统中，那么你不需要广播你的无能！如果你没有在数据库中报告故障，那么你必须做系统的笔记，以免忘记。因此，你可能会发现从一开始就使用故障跟踪系统更容易。如果交付延迟得如此之晚，以至于人们*需要*看到剩余的问题，那么你可能会被迫提出故障报告。
- en: As soon as any code is released, you should make all of its faults public; you
    *have* to file fault reports. This shows that you have identified each issue and
    have a plan to deal with it.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 任何代码一经发布，你应该公开其所有故障；*必须*提交故障报告。这表明你已经识别了每个问题，并有一个计划来处理它。
- en: Whenever you discover a code fault, you should write a test case that excercises
    it and incorporate it into your suite of automatic tests to be run as a regression
    check. This acts as a form of documentation for the fault and ensures that it
    won't be reintroduced accidentally, later on.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你发现代码故障，你应该编写一个测试用例来测试它，并将其纳入你的自动测试套件中，作为回归检查的一部分。这作为故障的一种文档形式，并确保它不会意外地再次引入。
- en: '**How much testing are the project engineers expected to do?**'
  id: totrans-1024
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**项目工程师预期要进行多少测试？**'
- en: It's important to know what's expected of you and to deliver that level of testing.
    But above this, don't just do what's *expected*—do what *needs* to be done.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 了解对你有什么期望，并交付那个级别的测试是很重要的。但在此之上，不要只做*预期*要做的事情——做*需要*做的事情。
- en: Write a unit test for *every* piece of code you create. If you need to modify
    someone else's work, write a test for it first if there isn't one. That way, you
    will know how well it currently works, what needs to be fixed, and how to prove
    that your modifications haven't busted anything.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 为你创建的每一块代码编写单元测试。如果你需要修改他人的工作，如果还没有测试，先为它编写一个测试。这样，你就会知道它目前的工作情况如何，需要修复什么，以及如何证明你的修改没有破坏任何东西。
- en: '* * *'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[10](#APP-FN-10)]) This would open the door to more coding errors—imagine
    the pain of bugs in the test code!
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#APP-FN-10)]) 这将打开更多的编码错误之门——想象一下测试代码中错误带来的痛苦！
- en: ^([[11](#APP-FN-11)]) It's sad we've been conditioned to accept this.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#APP-FN-11)]) 很遗憾，我们已经习惯了接受这种情况。
- en: '[Chapter 9](ch09.html "Chapter 9. FINDING FAULT")'
  id: totrans-1030
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。寻找故障")'
- en: Mull It Over
  id: totrans-1031
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Is it best for faults to be fixed by the original programmer who wrote the
    code? Or is the programmer who discovered the problem better placed to make a
    fix?**'
  id: totrans-1032
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是让编写代码的原程序员修复故障最好，还是让发现问题的程序员更适合进行修复？**'
- en: It's always helpful to approach any problem with a fresh pair of eyes. When
    debugging, this method avoids the common problem of a programmer reading what
    he *meant* to write, not what the code actually says—too many bugs stay hidden
    that way.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 以全新的视角处理任何问题总是有帮助的。在调试时，这种方法避免了程序员阅读他*打算*写的内容，而不是代码实际说了什么——太多的错误就是这样隐藏起来的。
- en: On the other hand, the original programmer *is* probably best placed to make
    the fix. He understands the code inside out (hopefully). He knows what repercussions
    a particular change will have. He'll be the quickest to pinpoint the location
    of a fault.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，原始程序员*可能*是修复错误的最佳人选。他（希望）对代码了如指掌。他知道特定的更改将产生什么影响。他将是最快定位到错误位置的人。
- en: In Real World organizations, the choice of who makes a fix may be determined
    by individual free time and what other commitments the team has. For bugs that
    have been in the program since time immemorial, the original programmer is probably
    no longer available. He may have left the company, moved projects, or (worst of
    all) been promoted to management.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的组织中，谁负责修复可能取决于个人的空闲时间和团队的其他承诺。对于自程序诞生以来就存在的错误，原始程序员可能已经不再可用。他可能已经离开了公司，转到了其他项目，或者（最糟糕的是）被提升为管理层。
- en: '**How can you tell when to use a debugger and when to use your brain?**'
  id: totrans-1036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何判断何时使用调试器，何时使用你的大脑？**'
- en: Obviously, even the use of a debugger should be with your brain engaged. (Remember
    the golden rule of debugging?)
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，即使使用调试器也应该让你的大脑保持活跃。（还记得调试的黄金法则吗？）
- en: 'My rule of thumb is: Don''t fire up a debugger until you know exactly what
    information you need to get out of it. The danger lies in using a debugger to
    putter around in the running code, not really knowing what you are looking for.
    You can waste hours doing this, with no real reward.'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验法则是：在你确切知道你需要从调试器中获取哪些信息之前，不要启动调试器。危险在于使用调试器在运行中的代码中随意摆弄，而不真正知道你在寻找什么。你可以浪费几个小时做这件事，却没有任何真正的回报。
- en: '**You should learn unfamiliar code before you start trying to find and fix
    faults in it. But the time pressures of the software factory often dictate that
    you can''t spend any serious time studying and understanding the program you''re
    repairing. What''s the best way forward?**'
  id: totrans-1039
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在你开始尝试查找和修复代码中的错误之前，你应该先学习不熟悉的代码。但软件工厂的时间压力通常意味着你无法花太多时间研究和理解你正在修复的程序。最好的前进方式是什么？**'
- en: In your dreams, you'd slap the people who wrote the schedule and take as long
    as necessary to fix the fault properly. Wake up, Alice. . . .
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的梦中，你会责备编写日程表的人，并花尽可能多的时间去正确修复故障。醒来吧，爱丽丝……
- en: The best you can do is try to learn the code as you go along. Proceed with extra
    caution when working through it, and don't trust what you *think* is happening—always
    make sure that the code is doing what you expect it to. When you think that you've
    found the cause of the bug, see if anyone on your team knows about the offending
    section of code. Discuss with them what you're going to do. Often when you describe
    the situation, you'll explain *to yourself* the obvious thing you've just missed.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的最好的事情就是边走边学习代码。在处理它时格外小心，不要相信你*认为*正在发生的事情——总是确保代码正在做你期望它做的事情。当你认为你已经找到了错误的根源时，看看你的团队中是否有人知道关于有问题的代码部分。与他们讨论你打算做什么。通常当你描述情况时，你会向自己解释你刚刚忽略的明显问题。
- en: '**Describe good techniques to avoid memory-leak bugs**.'
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述一些避免内存泄漏错误的良好技巧**。'
- en: 'These are some good approaches:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些好的方法：
- en: Use a language where you're less likely to be bitten by them, such as Java or
    C#. (You can still be bitten by memory leaks in these languages. Do you know how?)
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你不太可能被其咬到的语言，例如Java或C#。（你仍然可能在这些语言中遇到内存泄漏。你知道如何吗？）
- en: Use "safe" data structures that manage memory for you, so you don't have to
    worry about it.
  id: totrans-1045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“安全”的数据结构来为你管理内存，这样你就不必担心它。
- en: Employ helpful language idioms, such as C++'s `auto_ptr`, to avoid problems.
  id: totrans-1046
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用有助于的语言习语，例如C++的`auto_ptr`，以避免问题。
- en: Be rigorous and methodical in your handling of memory. For every allocation
    point, make sure there is a balancing deallocation point and that it will always
    be called.
  id: totrans-1047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理内存时，要严谨和有系统。对于每个分配点，确保有一个平衡的释放点，并且它将始终被调用。
- en: Run your code through memory validator tools to ensure no bugs have crept through.
  id: totrans-1048
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的代码通过内存验证工具运行，以确保没有错误悄悄溜过。
- en: '**When is it justifiable to have a quick stab at finding and fixing a fault,
    rather than adopting a more methodical approach?**'
  id: totrans-1049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在什么情况下可以合理地快速尝试查找和修复错误，而不是采用更系统的方法？**'
- en: You *always* need to think about what you're doing. Even quick fiddling should
    be done with your brain firmly in gear. Don't blindly pepper the code with breakpoints
    to start digging around in the internals; try to think about how the code is designed
    and what it should be doing.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 你**总是**需要思考你在做什么。即使是快速调整也应该让你的大脑处于工作状态。不要盲目地在代码中设置断点，开始挖掘内部结构；试着思考代码是如何设计的以及它应该做什么。
- en: Gut feelings and your instant reactions may find a fault quickly in *very small
    programs* (say, a few tens of lines). But in a program that's many thousands of
    lines long, you really need to know what's going on. There is no substitute for
    insight. There's nothing wrong with tracing the program's execution in a debugger
    to examine what it's doing, but chose the test points methodically.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 直觉和你的即时反应可能在非常小的程序（比如几十行）中迅速找到错误。但在成千上万行长的程序中，你真的需要了解发生了什么。洞察力是无可替代的。在调试器中跟踪程序的执行以检查它在做什么并没有什么不妥，但选择测试点时要有条理。
- en: Getting Personal
  id: totrans-1052
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**How many debugging techniques/tools do you routinely use? What others have
    you seen that you might find useful?**'
  id: totrans-1053
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你通常使用多少调试技术/工具？你见过哪些可能对你有用的其他工具？**'
- en: Obviously the answer is *none*. You always write perfect code the first time!
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 显然答案是**没有**。你总是第一次就写出完美的代码！
- en: '**What are the common problems and pitfalls in your language(s) of choice?
    How do you guard against these kinds of bugs in your own code?**'
  id: totrans-1055
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你选择的语言中常见的错误和陷阱有哪些？你是如何在自己的代码中防范这些类型的错误的？**'
- en: It's important to know this kind of thing. It's what sets mediocre programmers
    apart from the experts. If you don't know where the dragons live, then you don't
    know how to avoid them.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这类事情很重要。这是平庸程序员与专家的区别所在。如果你不知道龙在哪里居住，那么你就不知道如何避开它们。
- en: '**Are most of the bugs that occur in your code sloppy programming errors, or
    are they more subtle issues?**'
  id: totrans-1057
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你代码中发生的错误大多是粗心的编程错误，还是更微妙的问题？**'
- en: If you get bitten over and over again by little language snafus, it shows that
    you should write code more carefully. Take time with your code. Proofread it,
    and then reread it—you'll save time overall. A classic mistake is fixing one fault,
    not testing that it works, and then being bitten by undesirable side effects of
    your "fix."
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一次又一次地被小的语言错误所困扰，这表明你应该更仔细地编写代码。花时间在你的代码上。校对它，然后重新阅读它——你总体上会节省时间。一个经典的错误是修复了一个错误，没有测试它是否工作，然后被你“修复”的不希望出现的副作用所困扰。
- en: There's no shame in having bugs in your code. Everyone gets them. Just make
    sure they're not stupid mistakes that you could have easily prevented.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中存在错误并不可耻。每个人都会遇到。只需确保它们不是你可以轻易避免的愚蠢错误。
- en: '**Do you know how to use a debugger on your platform? How routinely do you
    use it? Describe how to**:'
  id: totrans-1060
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你知道如何在你的平台上使用调试器吗？你通常多久使用一次？描述如何**：'
- en: '**Produce a backtrace**'
  id: totrans-1061
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成回溯**'
- en: '**Inspect variable values**'
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查变量值**'
- en: '**Inspect value of fields within a structure**'
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**检查结构中字段的值**'
- en: '**Run an arbitrary function**'
  id: totrans-1064
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行任意函数**'
- en: '**Swap thread contexts**'
  id: totrans-1065
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**交换线程上下文**'
- en: If you use a debugger all the time, then that's *too much*. If you never use
    one, then that's *too little*. Don't be afraid of your debugger, but don't use
    it as a crutch, either. Intelligent use of a debugger will allow you to hone right
    in to the location of a fault in little to no time.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总是使用调试器，那么这就是**太多**。如果你从不使用调试器，那么这就是**太少**。不要害怕你的调试器，但也不应该把它当作拐杖。智能地使用调试器将允许你在很短的时间内准确地找到错误的位置。
- en: '[Chapter 10](ch10.html "Chapter 10. THE CODE THAT JACK BUILT")'
  id: totrans-1067
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第10章](ch10.html "第10章。杰克建造的代码")'
- en: Mull It Over
  id: totrans-1068
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Why should people with nice integrated development environments worry about
    using a command-line make utility, when they can just hit a single button to build
    their project?**'
  id: totrans-1069
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么拥有良好集成开发环境的人还需要担心使用命令行make工具，当他们只需按一个按钮就可以构建他们的项目时？**'
- en: Besides learning what's really going on behind the build button, knowing how
    to use make is a route to more powerful, flexible software construction. Rarely
    does a GUI build tool compare to the capabilities and malleability of makefiles.
    Simplification often *is* a good thing, and GUI tools can help developers to create
    software quickly, but this simplicity comes at an expense.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 除了学习在构建按钮背后真正发生的事情外，了解如何使用make是一种通往更强大、更灵活的软件构建的途径。很少有GUI构建工具能与makefile的能力和可塑性相提并论。简化通常是好事，GUI工具可以帮助开发者快速创建软件，但这种简单性是有代价的。
- en: GUI build tools simply do not scale well and are of little use on really large
    projects. Make does have a cryptic syntax, but it lets you do far, far more. For
    example, makefiles allow nesting of directories, creating a build hierarchy. Simplistic
    GUI tools only provide one level of depth, the nesting of projects inside a workspace.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 图形界面构建工具在扩展性方面表现不佳，在真正的大型项目中几乎没有什么用处。Make确实有一个晦涩难懂的语法，但它让你可以做更多的事情。例如，makefile允许目录嵌套，创建构建层次结构。简单的图形界面工具只提供一层深度，即工作空间内项目的嵌套。
- en: People complain about make's complexity and that you can foul things up using
    it. This is a valid concern, but it is the same as with any power tool—you might
    injure yourself if you don't use it properly.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 人们抱怨make的复杂性，以及使用它可能会搞砸事情。这是一个合理的问题，但与任何强大的工具一样——如果你不正确使用，你可能会伤害到自己。
- en: 'This doesn''t mean that you should throw away all GUI build tools and start
    writing a raft of replacement makefiles. On the contrary: Use the right tool for
    the job. Balance simplicity and integration with power and extensibility; choose
    the tool that''s required each time.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你应该丢弃所有的图形界面构建工具，开始编写一系列的替换makefile。相反：使用适合的工具来完成工作。平衡简单性和集成与强大和可扩展性；选择每次所需的工具。
- en: '**Why is it important to treat the extraction of source code as a separate
    step from building it?**'
  id: totrans-1074
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么将源代码的提取视为与构建分开的单独步骤很重要？**'
- en: The two *are* logically different steps. In a properly crafted build system,
    you should be able to check out *any* version of the software, no matter how old,
    and then issue the same make instruction to build it. Later you should be able
    to clean the tree and rebuild it using the same instruction, without checking
    everything back out again.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤在逻辑上是不同的。在一个精心设计的构建系统中，你应该能够检出软件的任何版本，无论多旧，然后发出相同的make指令来构建它。稍后你应该能够清理树并使用相同的指令重新构建，而无需再次检出所有内容。
- en: It's no loss to have these as two separate steps. You can easily wrap a script
    around them to make a single-step retrieve/build procedure—this will then be useful
    for an overnight build script. For these overnight scripts, it's vital to start
    from a fresh source tree each time (to avoid being caught out by problems carried
    over from the last tree). This is a good test of your source tree; by deleting
    it and performing a complete rebuild, you'll check that no files are missing or
    out of date (you might have forgetten to check something in).
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些作为两个单独的步骤并没有损失。你可以轻松地围绕它们编写一个脚本来实现单步检索/构建过程——这将对于夜间构建脚本非常有用。对于这些夜间脚本，每次都从全新的源代码树开始（以避免被从上一个树中携带的问题所困扰）至关重要。这是对源代码树的良好测试；通过删除它并执行完整的重建，你可以检查是否有文件缺失或过时（你可能忘记检查某些内容）。
- en: 'Other problems with binding source extraction into the build step include the
    following:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码提取绑定到构建步骤中存在其他问题，包括以下内容：
- en: You don't want the build system to automatically check files out of the source
    repository as you do a build. You rarely want the whole world changing under your
    feet each time you rebuild. It's important to be in control of the code you're
    working on, not a slave to the build system behavior.
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不希望构建系统在构建过程中自动从源代码库中检出文件。你很少希望每次重新构建时，周围的环境都在发生变化。控制你正在工作的代码，而不是成为构建系统行为的奴隶，这一点很重要。
- en: 'There is a bootstrapping problem: If extraction is a part of the build process,
    where do you get a source tree from in order to start the build? You''d have to
    check it out manually anyway! Or you''d have to recite more magic incantations
    to partially check out the build portions of the tree in order to perform a real
    checkout and build. Don''t go there.'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个引导问题：如果提取是构建过程的一部分，你从哪里获得源代码树以开始构建？你无论如何都需要手动检出！或者，你需要念诵更多的咒语来部分检出树中的构建部分，以便执行真正的检出和构建。不要这么做。
- en: '**Where should the intermediate files from construction steps (e.g., object
    files) be put?**'
  id: totrans-1080
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建步骤的中间文件（例如，目标文件）应该放在哪里？**'
- en: 'Some build systems dump object files beside the source file that generated
    them. Advanced build systems can create a parallel directory tree and build objects
    into *there*, leaving the source directories intact. This keeps things neat, distinguishing
    source files from the build-generated files. There are downsides, though: It''s
    harder to search around the hierarchy. You might want to force a source file recompilation
    by deleting a `.o` file, but with split trees you have to navigate further from
    the source to do so.'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 一些构建系统将目标文件丢弃在生成它们的源文件旁边。高级构建系统可以创建一个并行目录树，并将对象构建到那里，同时保持源目录不变。这使事情变得整洁，区分源文件和构建生成的文件。尽管如此，也有一些缺点：在层次结构中搜索会更困难。你可能想通过删除`.o`文件来强制重新编译源文件，但使用分割树，你必须从源文件导航得更远才能做到这一点。
- en: Another neat approach for object file placement is to put intermediate files
    within the source tree, but in their own subdirectory; out of way of the source
    files, but still close to hand. You'd end up with a directory hierarchy looking
    like [Figure A-1](apas10.html#putting_built_object_files_in_a_subdirectory "Figure A-1. Putting
    built object files in a subdirectory").
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标文件的位置，另一种整洁的方法是将中间文件放在源树中，但放在它们自己的子目录中；远离源文件，但仍然方便。你最终会得到一个目录层次结构，看起来像[图A-1](apas10.html#putting_built_object_files_in_a_subdirectory
    "图A-1. 将构建的目标文件放入子目录")。
- en: 'This is a good way to support the building of *multiple targets* from one source
    tree—each target has its own build subdirectory. Without this mechanism, you could
    start a debug build, finish it off in release mode, and have a link stage that''s
    a disaster. Adopting this approach leads to a build tree looking [Figure A-2](apas10.html#even_better_colon_putting_object_files_in_a_named
    "Figure A-2. Even better: Putting object files in a named subdirectory").'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种从单个源树构建多个目标的好方法——每个目标都有自己的构建子目录。没有这个机制，你可能会开始一个调试构建，以发布模式完成它，并且链接阶段会变得一团糟。采用这种方法会导致构建树看起来像[图A-2](apas10.html#even_better_colon_putting_object_files_in_a_named
    "图A-2. 更好的做法：将目标文件放入命名子目录")。
- en: '![Putting built object files in a subdirectory](tagoreillycom20080909nostarchimages207590.png)'
  id: totrans-1084
  prefs: []
  type: TYPE_IMG
  zh: '![将构建的目标文件放入子目录](tagoreillycom20080909nostarchimages207590.png)'
- en: '**Figure A-1. Putting built object files in a subdirectory**'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '**图A-1. 将构建的目标文件放入子目录**'
- en: '![Even better: Putting object files in a named subdirectory](tagoreillycom20080909nostarchimages207592.png.jpg)'
  id: totrans-1086
  prefs: []
  type: TYPE_IMG
  zh: '![更好的做法：将目标文件放入命名子目录](tagoreillycom20080909nostarchimages207592.png.jpg)'
- en: '**Figure A-2. Even better: Putting object files in a *named* subdirectory**'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: '**图A-2. 更好的做法：将目标文件放入*命名*子目录**'
- en: '**If you add an automated test suite to the build system, should it run automatically
    after the software is built, or must you fire a separate command to invoke the
    tests?**'
  id: totrans-1088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你在构建系统中添加了一个自动测试套件，它应该在软件构建后自动运行，还是必须单独执行一个命令来调用测试？**'
- en: You can easily provide a separate command (something like a *tests* makefile
    target; you'd type `make tests` after `make all`). However, this extra step would
    be less likely to be performed—there's no requirement to do so. The tests may
    be overlooked. This is quite likely, human nature being what it is. The untested
    code could cause all sorts of problems, making the effort of writing tests fruitless.
    Ensure your unit tests are a part of the main build procedure.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地提供一个单独的命令（比如一个*tests* makefile目标；你会在`make all`之后输入`make tests`）。然而，这个额外的步骤可能不太会被执行——没有要求这样做。测试可能会被忽略。这在人类本性如此的情况下是很可能的。未经测试的代码可能会引起各种问题，使得编写测试的努力变得徒劳。确保你的单元测试是主构建过程的一部分。
- en: Automated stress tests and load tests probably shouldn't be part of this build
    step, though. They might take too long to execute, only intended to be run on
    the overnight build. In this case, make an automated scaffold to run them, but
    don't trigger it during a normal build.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化压力测试和负载测试可能不应该包含在这个构建步骤中。它们可能执行时间太长，只打算在夜间构建上运行。在这种情况下，创建一个自动化脚本来运行它们，但在正常构建期间不要触发它。
- en: '**Should the overnight build be a debug or release build?**'
  id: totrans-1091
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**夜间构建应该是调试构建还是发布构建？**'
- en: Both. It's very important to test the release build configuration as early as
    possible. Debug builds shouldn't be released to the QA department, let alone outside
    the company.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都要。尽早测试发布构建配置非常重要。调试构建不应该发布给QA部门，更不用说公司外部了。
- en: It's important to test that both release and development build processes work—not
    just once when the build system is created, but on an ongoing basis. It's remarkably
    easy to make a minor update that breaks one or other build. If a build isn't tested
    until the last minute, you're going to be very angry when it fails with a deadline
    looming.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要测试发布和开发构建过程是否正常工作——不仅是在构建系统创建时，而且要持续进行。很容易在更新时破坏一个或多个构建。如果直到最后一刻才测试构建，那么当它失败且截止日期临近时，你会非常生气。
- en: There may be serious differences between executables generated by debug and
    release builds. Some compilers exhibit markedly changed behavior in debug and
    release mode. One popular compiler is happy to pad out data buffers in debug builds,
    so memory overruns are harmless and go undetected—hardly a good debugging aid.
    If you only ever tested the debug build, switching to release mode just before
    the product ships means that you are bound to run into problems.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 由调试和发布构建生成的可执行文件之间可能存在严重差异。一些编译器在调试和发布模式下表现出明显不同的行为。有一种流行的编译器在调试构建中乐于填充数据缓冲区，因此内存溢出无害且不会被检测到——这几乎不是一个好的调试辅助工具。如果你只测试过调试构建，那么在产品发货前切换到发布模式，你很可能会遇到问题。
- en: '**Write a make rule to automatically generate dependency information from your
    compiler. Show how to use this information in the makefile**.'
  id: totrans-1095
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写一个make规则来自动从你的编译器生成依赖信息。展示如何在makefile中使用这些信息**。'
- en: 'There are several ways to achieve this, depending in part on how you get dependency
    information from your compiler. Say the hypothetical `compiler` takes an extra
    `-dep` parameter that cajoles it to create a dependency file as well as the object
    file. Let''s say that the format of this generated file is already in make''s
    dependency format.^([[12](#ftn.APP-FN-12)]) Using GNU Make, you can specify a
    compilation rule that has the side effect of generating dependencies:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点，部分取决于你如何从编译器获取依赖信息。假设`编译器`接受一个额外的`-dep`参数，诱使它创建一个依赖文件以及目标文件。假设这个生成文件的格式已经符合make的依赖格式。[^12](#ftn.APP-FN-12)]
    使用GNU Make，你可以指定一个编译规则，该规则具有生成依赖信息的副作用：
- en: '[PRE15]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can then incorporate all generated dependency files directly into the makefile
    by putting this at the bottom of `Makefile`:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过在`Makefile`底部添加以下内容，直接将所有生成的依赖文件合并到makefile中：
- en: '[PRE16]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It''s that easy! Of course, this is the simplest mechanism that will work.
    There are many refinements to clean this up. For example:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就这么简单！当然，这是最简单的机制，可以工作。有许多改进可以使其更整洁。例如：
- en: You can direct the dependency files into a separate directory. This prevents
    them from cluttering up the working directory and covering up the important files.
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将依赖文件直接指向一个单独的目录。这可以防止它们在工作目录中造成混乱并覆盖重要文件。
- en: 'You can write an include rule to only pull in the *correct* `.d` files. There
    may be other `.d` files lying around that you shouldn''t include, making the wildcard
    `include` line dangerous: The inclusion of random information from invalid files
    will confuse make. This problem can crop up easily: If you remove a source file
    from the makefile but don''t clean the build tree first, the old `.o` and `.d`
    files will hang around in the working directories until you remove them manually.'
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以编写一个包含规则，仅包含*正确的* `.d` 文件。可能存在其他你不应该包含的 `.d` 文件，这使得通配符 `include` 行变得危险：从无效文件中包含随机信息会令make困惑。这个问题很容易出现：如果你从makefile中删除了一个源文件，但未先清理构建树，那么旧的
    `.o` 和 `.d` 文件将保留在工作目录中，直到你手动删除它们。
- en: If the compiler permits, you can write a separate rule to create `.d` files,
    making them first-class citizens of the build system. This has the downside of
    slowing down the build process—the compiler will now be invoked *twice* for each
    source file.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器允许，你可以编写一个单独的规则来创建 `.d` 文件，使它们成为构建系统的第一公民。这的缺点是会减慢构建过程——现在编译器将针对每个源文件调用*两次*。
- en: '**Recursive make is a popular method of creating a modular build system spanning
    several directories. However, it is fundamentally flawed. Describe its problems
    and suggest alternatives**.'
  id: totrans-1104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**递归make是创建跨越多个目录的模块化构建系统的流行方法。然而，它存在根本性的缺陷。描述其问题并建议替代方案**。'
- en: Conventional wisdom suggests that all large codebases built with makefiles should
    use the recursive make technique. Yet as powerful as recursive make is, it's fundamentally
    flawed. Don't ignore it, though. It's important to understand how recursive make
    works (or doesn't work) because it's so prevalent (many codebases employ recursive
    make), and you need to you know its problems to understand what makes a better
    solution.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 传统智慧认为，所有使用makefile构建的大型代码库都应该使用递归Make技术。然而，尽管递归Make很强大，但它本质上是有缺陷的。尽管如此，不要忽视它。了解递归Make是如何（或如何不）工作的很重要，因为它非常普遍（许多代码库都使用递归Make），你需要了解它的问题，才能理解什么是一个更好的解决方案。
- en: 'What renders recursive make a liability? It has a number of pitfalls:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 什么使得递归Make成为一个缺陷？它有几个陷阱：
- en: '**Speed**'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: '**速度**'
- en: It's so *slooooooow*. If you try to rebuild a source tree that's already up
    to date, a recursive build still has to trawl faithfully through each directory.
    For a reasonably sized project this takes ages, which is nonsensical when no action
    is necessary.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如此*慢*。如果你尝试重新构建一个已经是最新的源树，递归构建仍然必须忠实地遍历每个目录。对于一个合理大小的项目来说，这需要很长时间，这在没有必要采取行动的情况下是没有意义的。
- en: Each directory is built as a *separate* make invocation.^([[13](#ftn.APP-FN-13)])
    This circumvents many potential optimizations; shared include files will be inspected
    over and over and over again. Although filesystems can cache information, this
    is still an unnecessary overhead. A sensible build system would only need to inspect
    each file once.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录都作为一个*独立的* make调用进行构建.^([[13](#ftn.APP-FN-13)]) 这绕过了许多潜在的优化；共享的包含文件会被反复检查。尽管文件系统可以缓存信息，但这仍然是不必要的开销。一个合理的构建系统只需要检查每个文件一次。
- en: '**Dependencies**'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖关系**'
- en: Recursive make cannot follow dependencies correctly; subdirectory makefiles
    have no way of determining all dependency information. Your module makefile can
    observe that its local `func1.c` source file depends on a `shared.h` header in
    another directory. It will happily rebuild `func1.c` every time `shared.h` is
    changed. But what happens if `shared.h` is automatically generated by a separate
    module, based on some template file `shared.tmpl`? Your module can't know about
    this extra dependency. Even if it could, it doesn't know how to rebuild `shared.h`—that
    isn't its job. So if `shared.tmpl` is changed, `func1.c` will not be rebuilt appropriately.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 递归Make无法正确地跟踪依赖关系；子目录makefile没有方法确定所有依赖信息。你的模块makefile可以观察到它的本地`func1.c`源文件依赖于另一个目录中的`shared.h`头文件。它会在`shared.h`每次更改时愉快地重新构建`func1.c`。但是，如果`shared.h`是由一个基于某些模板文件`shared.tmpl`的单独模块自动生成的，你的模块就无法知道这个额外的依赖。即使它能够知道，它也不知道如何重新构建`shared.h`——这不是它的任务。所以如果`shared.tmpl`被更改，`func1.c`将不会适当地重新构建。
- en: The only way to plaster over this crack is to arrange for `shared.h` to be built
    first, *before* `func1.c`'s module. The programmer must carefully define the *order*
    of recursion to make sure the software rebuilds correctly.^([[14](#ftn.APP-FN-14)])
    The more indirect dependencies that exist, the worse the mess gets.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的方法是安排`shared.h`在`func1.c`模块之前构建。程序员必须仔细定义递归的*顺序*，以确保软件能够正确地重新构建.^([[14](#ftn.APP-FN-14)])
    存在的间接依赖越多，混乱就越严重。
- en: Faced with this problem, programmers devise nefarious work-arounds, like making
    several build passes over the tree or manually removing certain files to force
    a rebuild every time. These hacks only serve to slow the build down more and unnecessarily
    complicate the procedure.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这个问题，程序员会设计出一些狡猾的解决方案，比如在树中多次进行构建遍历，或者手动删除某些文件以强制每次都重新构建。这些黑客行为只会使构建过程变得更慢，并无谓地复杂化。
- en: '**Puts onus back on the developer**'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '**将责任回归给开发者**'
- en: Make was created to manage the complexity of rebuilding code. Recursive make
    turns this inside out and forces you to get involved in the build process again.
    We've seen how the programmer has to manage the order of recursion, kludging each
    makefile to work around limitations.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: Make工具的创建是为了管理重建代码的复杂性。递归Make将这个过程颠倒过来，迫使你再次参与到构建过程中。我们看到了程序员如何管理递归的顺序，以及如何通过修改每个makefile来绕过限制。
- en: '**Subtlety**'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '**微妙之处**'
- en: Recursive make's problems are not at all obvious. That's why many people still
    think it's a good idea. When things go wrong, they do so in strange ways. The
    cause of a problem is rarely clear, so it'll be dismissed as "one of those freak
    events."
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 递归Make的问题并不明显。这就是为什么许多人仍然认为这是一个好主意。当事情出错时，它们以奇怪的方式出错。问题的原因很少是清晰的，所以它会被视为“那种怪异事件”之一。
- en: This adds up to a build system that is dangerously brittle.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个危险脆弱的构建系统。
- en: These are all problems people wrongly attribute to make itself, arguing that
    it is defective. But in this respect, make is an innocent bystander. It's our
    *use* of make that is at fault. The recursion introduces each of these problems;
    it inhibits make from doing its proper job.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是人们错误地归咎于 make 自身的问题，认为它是存在缺陷的。但在这个方面，make 只是一个无辜的旁观者。真正有问题的是我们对 make 的**使用**。递归引入了这些问题中的每一个；它阻碍了
    make 执行其本职工作。
- en: So what's the solution to this mess? Clearly we don't want to throw away the
    nesting in our source trees. We need a build process that supports nesting but
    doesn't split up the build process recursively. This isn't too hard; we'll call
    the technique *nested make*. It simply involves putting all build information
    in one master makefile. There is no longer a need for individual subdirectory
    makefiles. The über-makefile manages all source nesting internally.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个混乱的解决方案是什么？显然，我们不想丢弃源树中的嵌套。我们需要一个支持嵌套但不递归分割构建过程的构建过程。这并不难；我们将这种技术称为**嵌套
    make**。它仅仅涉及将所有构建信息放在一个主 makefile 中。不再需要单独的子目录 makefile。超级 makefile 内部管理所有源嵌套。
- en: '**KEY CONCEPT**'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**'
- en: '*Contrary to popular belief, recursive make is a* bad *build technique. Avoid
    it in favor of a more robust* nested make *approach*.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**与普遍看法相反，递归 make 是一种**不好的**构建技术。为了避免它，选择更健壮的**嵌套 make**方法。'
- en: You might be thinking that this is a more complex and less flexible approach.
    How can you manage a large build tree with just a single makefile?
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这是一个更复杂且灵活性更差的方案。你如何只用一个 makefile 管理一个大的构建树？
- en: 'A number of practical implementation techniques make it easy:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实用的实现技术使其变得容易：
- en: Use make's include file mechanism. Put the list of each directory's source files
    in *that* directory—it's far more maintainable and clear that way. Place this
    list in a file called something like `files.mk`, and include that from the master
    `Makefile`.
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 make 的包含文件机制。将每个目录的源文件列表放在**那个**目录中——这样更易于维护和清晰。将这些列表放在一个名为 `files.mk` 的文件中，并从主
    `Makefile` 中包含它。
- en: You can retain recursive make's modularity—entering *any* component subdirectory
    to type `make`—by defining more intermediate targets. These targets construct
    specific parts of the project. Constructing modular builds this way can be more
    meaningful than recursive make's arbitrary directory-based approach, and it ensures
    that each intermediate target is always built properly.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过定义更多的中间目标来保留递归 make 的模块化——进入**任何**组件子目录并输入 `make`。这些目标构建项目的特定部分。以这种方式构建模块化构建可能比递归
    make 的任意基于目录的方法更有意义，并且它确保每个中间目标总是被正确构建。
- en: Nested make is no more complex than recursive make; in fact it can be *less*
    complex. It produces more reliable, accurate, speedy builds.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套 make 与递归 make 一样不复杂；实际上，它可能更简单。它产生更可靠、准确、快速的构建。
- en: Getting Personal
  id: totrans-1128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**Do you know how to perform different types of compilation using your build
    system? How can you build a debug or release version of the application from the
    same sources, with the same makefiles?**'
  id: totrans-1129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你知道如何使用你的构建系统执行不同类型的编译吗？你如何从相同的源代码、相同的 makefile 构建调试或发布版本的应用程序？**'
- en: 'In an earlier answer, we saw a good solution to this problem: Build objects
    into different subdirectories, created by the build script, based on the type
    of build (one directory for debug files and one for release files).'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的回答中，我们看到了这个问题的良好解决方案：根据构建类型（一个目录用于调试文件，一个目录用于发布文件），通过构建脚本在不同的子目录中构建对象。
- en: 'You can achieve this in GNU Make by massaging filenames. Here''s an example:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对文件名进行操作在 GNU Make 中实现这一点。以下是一个示例：
- en: '[PRE17]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You''ll obviously be doing more with the selected `BUILD_TYPE`, altering the
    compiler flags, for example. Don''t forget that you''ll need a rule to create
    the subdirectories, or your compiler will complain when it tries to generate output.
    Here''s how to do this on Unix:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你将使用选定的 `BUILD_TYPE` 做更多的事情，比如更改编译器标志。别忘了你需要一个规则来创建子目录，否则当编译器尝试生成输出时，它会抱怨。以下是在
    Unix 上的做法：
- en: '[PRE18]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now you can type these two commands, one after the other, knowing the build
    system will cope perfectly:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以连续输入这两个命令，知道构建系统会完美应对：
- en: '[PRE19]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You *can* create a simpler system without this subdirectory technique, but it
    will rely on doing a cleanout whenever you change the `BUILD_TYPE`.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '你**可以**创建一个没有这种子目录技术的更简单的系统，但它将依赖于每次更改 `BUILD_TYPE` 时进行清理。 '
- en: '**How good is your current project''s build process? Does it rate well against
    the characteristics in this chapter? How could you improve it? How easy is it
    to**:'
  id: totrans-1138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的当前项目构建过程有多好？它与本章中提到的特性相比如何？你该如何改进它？改进它的难易程度如何？**'
- en: '**Add a new file to a library?**'
  id: totrans-1139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向库中添加一个新文件？**'
- en: '**Add a new directory of code?**'
  id: totrans-1140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个新的代码目录？**'
- en: '**Move or rename a file of code?**'
  id: totrans-1141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移动或重命名一个代码文件？**'
- en: '**Add a different build configuration (say, a demo build)?**'
  id: totrans-1142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加不同的构建配置（比如，演示构建）？**'
- en: '**Build two configurations in one copy of the source tree without doing a clean
    in between?**'
  id: totrans-1143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在一个源树副本中构建两个配置，而不进行清理？**'
- en: This shows both how well you know the build process and how maintainable it
    is. Comparing your build mechanism to other projects' is a good idea—it will show
    where your processes are inadequate and need improvement.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了你对构建过程的了解程度以及其可维护性。将你的构建机制与其他项目的构建机制进行比较是个好主意——这将显示出你的流程在哪里不足并需要改进。
- en: Consider moving and renaming source files. Both are common during refactoring
    and are very easy to overlook. These simple actions *can* cause build systems
    to calculate dependencies incorrectly and build flawed code. I've been bitten
    more than once by such a problem; it takes a while to notice when this goes wrong.
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑移动和重命名源文件。这两者在重构过程中都很常见，而且很容易被忽视。这些简单的操作*可能*会导致构建系统错误地计算依赖关系并构建有缺陷的代码。我曾经不止一次被这样的问题困扰；当这种情况发生时，要花一些时间才能注意到。
- en: Often there is "no time" in the programmers' busy schedules to spend on improving
    the build system; they are all far too busy trying to get a product out the door.
    This is a dangerous misconception. The build scripts are a part of the code and
    require as much maintenance and careful extension as any other source file. A
    safe and reliable build system is so important that time spent sorting it out
    is *not* time wasted. It's time invested in the future of the codebase.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，程序员在忙碌的日程中“没有时间”去改进构建系统；他们都在忙于试图将产品推出市场。这是一个危险的观点。构建脚本是代码的一部分，需要与其他任何源文件一样多的维护和仔细的扩展。一个安全可靠的构建系统如此重要，以至于花时间整理它并不是浪费时间。这是对代码库未来的投资。
- en: '**Have you ever created a build system from scratch? What drove you to its
    particular design?**'
  id: totrans-1147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否曾经从头开始创建一个构建系统？是什么驱使你选择了特定的设计？**'
- en: 'As with any programming task, the shape of your solution is influenced by a
    number of factors:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何编程任务一样，你的解决方案的形状受到许多因素的影响：
- en: Your prior experience
  id: totrans-1149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你以往的经验
- en: What you know
  id: totrans-1150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你所知道的信息
- en: Your understanding of the problem *at the moment*
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对问题的理解*目前*
- en: The limitations of the technology available
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用技术的局限性
- en: The amount of time you have to set it up
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你用来设置它的时间量
- en: 'Generally, a little time and a little usage will tell how good your design
    decisions were. You never appreciate all the requirements at first, and things
    change that no one can anticipate:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一点时间和一点使用经验就会告诉你设计决策有多好。你一开始永远不会欣赏所有的需求，而且事情会发生变化，没有人能预料到：
- en: Requirements change—if the product becomes really successful, you may need to
    build different internationalized versions or target a new processor architecture.
    The build system must accommodate extension.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求会变化——如果产品真的非常成功，你可能需要构建不同的国际化版本或针对新的处理器架构。构建系统必须能够扩展。
- en: The code may need to be moved across to a new build toolchain, when no one ever
    anticipated that this should be a selectable option.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有人预料到这应该是一个可选选项时，代码可能需要迁移到新的构建工具链。
- en: How easily these modifications can be incorporated is a testament to the quality
    of your design. You'll learn with each change, gaining valuable experience for
    the next build system you craft.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修改是否容易整合是对你设计质量的证明。你会在每次更改中学习，为下一个构建系统积累宝贵的经验。
- en: '**Everyone suffers from flaws in a build system from time to time. When programming
    a build script, you''re as likely to introduce bugs as you are when programming
    real code**.'
  id: totrans-1158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每个人在构建系统中都会时不时地遇到缺陷。当编写构建脚本时，你引入错误的可能性与编写真实代码时一样高**。'
- en: '**What kinds of build errors have you been bitten by, and how could you fix,
    or even prevent, them?**'
  id: totrans-1159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你遇到过哪些构建错误，你该如何修复，甚至防止它们？**'
- en: 'Common build errors include:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的构建错误包括：
- en: Picking up dependency information incorrectly
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误地获取依赖信息
- en: Not coping gracefully with file system failures, like running out of disk space
    or incorrect file permissions; the build may continue with no indication that
    one of the steps failed
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法优雅地处理文件系统故障，如磁盘空间不足或文件权限不正确；构建过程可能继续进行，没有任何迹象表明某个步骤失败
- en: 'Source control problems: merges go wrong, or the wrong version of some source
    code is checked out'
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制问题：合并出错，或检出了一些源代码的错误版本
- en: Library configuration errors, often using incompatible or out of date versions
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库配置错误，通常使用不兼容或过时的版本
- en: Programmers not understanding how to use the build system, and making silly
    mistakes
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员不理解如何使用构建系统，并犯下愚蠢的错误
- en: When something's not going as expected, step back and consider whether or not
    the build system is playing a part in the problem.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 当事情没有按预期进行时，退一步考虑构建系统是否在问题中扮演了角色。
- en: '* * *'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[12](#APP-FN-12)]) These are quite reasonable assumptions; many systems work
    like this.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#APP-FN-12)]) 这些是相当合理的假设；许多系统都是这样工作的。
- en: ^([[13](#APP-FN-13)]) Just think of the overhead of starting up all those child
    processes!
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#APP-FN-13)]) 想想启动所有这些子进程的开销吧！
- en: ^([[14](#APP-FN-14)]) This is a one-up for GUI tools—without recursive make,
    they tend to manage dependencies properly.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#APP-FN-14)]) 这是GUI工具的一个优势——没有递归make，它们通常能正确管理依赖关系。
- en: '[Chapter 11](ch11.html "Chapter 11. THE NEED FOR SPEED")'
  id: totrans-1171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。速度的需求")'
- en: Mull It Over
  id: totrans-1172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: '**Optimization is a process of making trade-offs—sacrificing one quality of
    code for another desirable quality. Describe the kinds of trade-offs that lead
    to a performance increase**.'
  id: totrans-1173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**优化是一个权衡的过程——为了另一个期望的质量牺牲代码的一个质量。描述导致性能提升的权衡类型**。'
- en: 'The kinds of decisions that profoundly influence a program''s performance are:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 影响程序性能的决策类型包括：
- en: Number of features versus size of code
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能数量与代码大小
- en: Program speed versus memory consumption
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序速度与内存消耗
- en: Storage and caching versus computation on demand
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和缓存与按需计算
- en: Guarded approach versus unguarded; optimistic versus pessimistic
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保守的方法与无保护的方法；乐观与悲观
- en: Approximate calculations versus exact calculations
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近似计算与精确计算
- en: Inline versus function call; monolithic versus modular
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联与函数调用；单一与模块化
- en: Indexing an array versus searching a list
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组进行索引与搜索列表
- en: Passing a parameter by reference or address versus passing a copy
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用或地址传递参数与传递副本
- en: Implemented in hardware versus software
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件实现与软件实现
- en: Hard-coded, direct access versus indirect access
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定编码，直接访问与间接访问
- en: Predetermined, fixed value versus variable and configurable
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预设的固定值与可变和可配置值
- en: Compile-time work versus run-time work
  id: totrans-1186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时工作与运行时工作
- en: Local function call versus remote call
  id: totrans-1187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数调用与远程调用
- en: Lazy computation versus eager computation
  id: totrans-1188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒计算与急计算
- en: '"Clever" algorithm versus clear code'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"巧妙"的算法与清晰的代码'
- en: '**Look at each of the optimization alternatives listed in "[Why Not Optimize?](ch11s03.html
    "Why Not Optimize?")" on page 202\. Describe what trade-offs are being made, if
    any**.'
  id: totrans-1190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**查看第202页上"[为什么不去优化？](ch11s03.html "为什么不去优化？")"中列出的每个优化替代方案。描述是否做出了权衡**。'
- en: Some of these alternatives *could* be considered optimizations, depending on
    how much of the system is under your control. If you specify the hardware platform
    that your program will run on, using a faster machine *is* an optimization. If
    not, it's more of a work-around.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些替代方案*可能*被认为是优化，具体取决于你对系统的控制程度。如果你指定了程序将运行的硬件平台，使用更快的机器*就是*一种优化。如果没有，它更多的是一种权宜之计。
- en: Many of the alternatives have hidden complexity costs. For example, relying
    on a certain host platform configuration (i.e., what services or background programs
    are running) leads to specific environmental dependencies that are hard to capture
    and easy to miss during installation or later maintenance.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 许多替代方案都有隐藏的复杂性成本。例如，依赖于特定的主机平台配置（即，运行的服务或后台程序）会导致特定的环境依赖性，这些依赖性难以捕捉，在安装或后续维护中容易忽略。
- en: '**Explain these terms and their exact relationship**:'
  id: totrans-1193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解释这些术语及其确切关系**：'
- en: '**Performance**'
  id: totrans-1194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**'
- en: '**Efficiency**'
  id: totrans-1195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**'
- en: '**Optimized**'
  id: totrans-1196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化**'
- en: The *efficiency* of code determines its *performance*. *Optimizing* is the act
    of improving the code's efficiency in order to improve performance. Notice that
    none of these terms directly describe *speed of execution*; the quality required
    may not be speed, but rather memory footprint or data throughput.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的*效率*决定了其*性能*。*优化*是指通过提高代码的效率来改善性能的行为。请注意，这些术语中没有一个直接描述*执行速度*；所需的质量可能不是速度，而是内存占用或数据吞吐量。
- en: '**What are the likely bottlenecks in a slow program?**'
  id: totrans-1198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个慢速程序可能存在哪些瓶颈？**'
- en: 'It''s common fallacy to think that everything is contending for the CPU and
    that bad code will be consuming all the processor time. Sometimes the CPU can
    be running almost idle, yet performance is dire. A program may stall for a number
    of reasons:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 认为所有东西都在争夺CPU，并且糟糕的代码会消耗所有处理器时间是一种常见的谬误。有时CPU可能几乎空闲，但性能却很糟糕。一个程序可能因为以下原因而停滞：
- en: Memory is being thrashed to and from swap space on the hard disk.
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存正在从硬盘上的交换空间中来回交换。
- en: It is waiting on disk access.
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在等待磁盘访问。
- en: It is waiting on slow database transactions.
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它正在等待缓慢的数据库事务。
- en: There is bad locking behavior.
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着糟糕的锁定行为。
- en: '**How can you avoid the need to optimize? What methods will prevent you from
    writing inefficient code?**'
  id: totrans-1204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何避免需要优化的需求？有哪些方法可以防止你编写低效的代码？**'
- en: We've seen how important it is to *design* performance into a software system
    from the very beginning. You can only do this if you already have a firm idea
    of what the required performance characteristics are.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，从一开始就将性能设计到软件系统中是多么重要。只有在你已经对所需性能特征有明确想法的情况下，你才能做到这一点。
- en: Once you have a sound design in place, write your code sensibly. Be aware which
    constructs are most efficient in your language, and avoid using the inefficient
    ones. For example, in C++, pass `const` references rather than expensive temporary
    copies.^([[15](#ftn.APP-FN-15)])
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个可靠的设计，就明智地编写你的代码。注意在你的语言中哪些构造最有效，并避免使用效率低下的构造。例如，在C++中，传递`const`引用而不是昂贵的临时副本.^([[15](#ftn.APP-FN-15)])
- en: It's useful to have a rough idea of the relative costs of different operations.
    If we scale time so that a processor executes one instruction a second, then a
    function call typically takes a few seconds, a virtual function call takes 10
    to 30 seconds, a disk seek takes a few months, and the time between keystrokes
    of an average typist is several years. Try to work out this kind of measure for
    operations like a memory allocation, claiming a lock, creating a new thread, and
    a simple data structure lookup.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 了解不同操作的相对成本是有用的。如果我们按比例缩放时间，使得处理器每秒执行一条指令，那么函数调用通常需要几秒钟，虚函数调用需要10到30秒，磁盘寻道需要几个月，而平均打字员的按键间隔是几年。尝试为内存分配、锁定请求、创建新线程和简单的数据结构查找等操作确定这种类型的度量。
- en: '**How does the presence of multiple threads affect optimization?**'
  id: totrans-1208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多个线程的存在如何影响优化？**'
- en: Threading can cause as many problems as it's supposed to solve. Naïvely threaded
    designs can introduce extra bottlenecks, particularly when locks are used badly,
    leading to long periods of deadlock.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能会引起与它解决的问题一样多的问题。天真地设计的线程可能会引入额外的瓶颈，尤其是在锁使用不当的情况下，导致长时间的死锁。
- en: Multithreaded programs are harder to profile, unless the profiler has good thread
    support; you need to interpret the profiler's results based on the relative thread
    priorities. If the threads are supposed to cooperate, you have to work out how
    the overall execution is progressing as several threads of control weave around
    one another.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序更难进行性能分析，除非分析器有良好的线程支持；你需要根据相对线程优先级来解释分析器的结果。如果线程应该协作，你必须弄清楚几个控制线程如何相互交织，以了解整体执行的进展。
- en: '**Why don''t we write efficient code? What stops us from using high-performance
    algorithms in the first place?**'
  id: totrans-1211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么我们不编写高效的代码？是什么阻止我们首先使用高性能算法？**'
- en: 'There are many perfectly valid reasons for not writing optimized code on the
    first attempt:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多完全合理的理由，使得第一次尝试编写优化代码变得困难：
- en: You don't know the final pattern of usage. With no Real World test data, how
    can you choose the code design that will work best?
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不知道最终的使用模式。在没有真实世界测试数据的情况下，你如何选择最佳的代码设计？
- en: It's hard enough to get the program *working*, let alone working *fast*. To
    prove it's feasible, we choose designs that are easy to implement so that prototypes
    get finished quickly.
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让程序*工作*已经足够困难，更不用说让它*快速*工作。为了证明这是可行的，我们选择易于实现的设计，以便快速完成原型。
- en: '"High-performance" algorithms can be more complex and daunting to implement.
    Programmers naturally shy away from them, since it''s an area where faults can
    be easily introduced.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"高性能"算法可能更复杂，实施起来也更令人畏惧。程序员自然会对它们有所顾虑，因为这是一个容易引入错误的领域。'
- en: Programmers often think that the time taken to run some code is proportional
    to the amount of effort spent writing it.^([[16](#ftn.APP-FN-16)]) You might have
    written some file-parsing code in hours, but it will always takes ages to execute,
    because disks are slow. The complex code you spent half a week getting right may
    only consume a few hundred processor cycles. In fact, neither the efficiency of
    a piece of code nor the amount of time you need to spend optimizing it bears any
    relation to the amount of time you spent writing it.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常常认为运行某些代码所需的时间与编写代码所花费的努力成正比.^([[16](#ftn.APP-FN-16)]) 你可能花了几小时编写一些文件解析代码，但它总是需要很长时间才能执行，因为磁盘很慢。你花了半周时间才正确编写复杂的代码，可能只消耗了数百个处理器周期。实际上，代码的效率以及你需要花费多少时间来优化它，与你在编写代码时花费的时间没有任何关系。
- en: '**A** `List` **data type is implemented using an array. What is the worst case
    algorithmic complexity of each of the following** `List` **methods?**'
  id: totrans-1217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`List`** **数据类型是通过数组实现的。以下每个`List`方法的算法复杂度最坏情况是什么？**'
- en: '**The constructor**'
  id: totrans-1218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构造函数**'
- en: '**`append`**—**places a new item on the end of the list**'
  id: totrans-1219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`append`**—**将新项放置在列表的末尾**'
- en: '`insert`—**slides a new item in between two existing list items, at a given
    position**'
  id: totrans-1220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insert`—**在两个现有列表项之间插入一个新项，在指定位置**'
- en: '`isEmpty`—**returns** `true` **if the list contains no items**'
  id: totrans-1221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isEmpty`—**如果列表不包含任何项，则返回** `true`'
- en: '`contains`—**returns** `true` **if the list contains a specified item**'
  id: totrans-1222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`contains`—**如果列表包含指定项，则返回** `true`'
- en: '`get`—**returns the item with a given index**'
  id: totrans-1223
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get`—**返回具有给定索引的项**'
- en: 'The worst cases are:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏的情况是：
- en: The constructor is `O(1)` since it only needs to create an array; the list is
    initially empty. However, it's worth considering that the size of this array will
    affect the complexity of the constructor—most languages create arrays fully populated
    with objects, even if you don't plan to use them yet. If the constructors for
    these objects are nontrivial, then the `List` constructor will take some time
    to execute.
  id: totrans-1225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数是`O(1)`，因为它只需要创建一个数组；列表最初是空的。然而，值得考虑的是，这个数组的大小将影响构造函数的复杂度——大多数语言在创建数组时都会用对象完全填充，即使你还没有计划使用它们。如果这些对象的构造函数非平凡，那么`List`构造函数将需要一些时间来执行。
- en: The array size might not be fixed—the constructor could take a parameter to
    determine this size (effectively setting the maximum possible list size). The
    method then becomes `O(n)`.
  id: totrans-1226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组大小可能不是固定的——构造函数可以接受一个参数来确定这个大小（实际上设置了最大可能的列表大小）。然后，该方法变为`O(n)`。
- en: 'The `append` operation is `O(1)` on average: It simply has to write an array
    entry and update the list size. *But*, if the array is full, it will have to reallocate,
    copy, and deallocate—a worst case complexity of `O(n)`, at least (it depends on
    the performance of your memory manager).'
  id: totrans-1227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`append`操作的平均时间复杂度是`O(1)`：它只需写入一个数组条目并更新列表大小。*但是*，如果数组已满，它将不得不重新分配、复制和释放——最坏情况下的复杂度为`O(n)`，至少（这取决于你的内存管理器的性能）。'
- en: '`insert` is `O(n)` on average. You might be asked to insert an element at the
    very beginning of the list. This requires all the elements in the array to be
    shuffled down one place before writing the first element. The more items in the
    `List`, the longer this will take. However, the worst case, again, involves memory
    reallocation and could be much more than `O(n)`.'
  id: totrans-1228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`insert`的平均时间复杂度是`O(n)`。你可能被要求在列表的非常开始处插入一个元素。这需要将数组中的所有元素向下移动一个位置，然后写入第一个元素。`List`中的项目越多，这需要的时间就越长。然而，最坏的情况，再次涉及内存重新分配，可能比`O(n)`多得多。'
- en: Unless you have a ridiculously bad implementation, `isEmpty` is `O(1)`. The
    list size will be known, so the return value is a single calculation based on
    this number.
  id: totrans-1229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非你有极其糟糕的实现，否则`isEmpty`是`O(1)`。列表大小将是已知的，所以返回值是基于这个数字的单个计算。
- en: '`contains` is `O(n)`, presuming the list contents are unordered. In the worst
    case, you will be asked to look for an item that doesn''t exist and will have
    to traverse every single list item.'
  id: totrans-1230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`contains`的时间复杂度是`O(n)`，假设列表内容是无序的。在最坏的情况下，你将被迫寻找一个不存在的项，并将不得不遍历列表中的每一个项。'
- en: '`get` is `O(1)`, thanks to the array implementation. Indexing an array is a
    constant time operation. If `List` had been implemented as a *linked list*, then
    this would have been an `O(n)` operation.'
  id: totrans-1231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get` 是 `O(1)`，多亏了数组实现。数组索引是一个常数时间操作。如果 `List` 被实现为*链表*，那么这将是一个 `O(n)` 操作。'
- en: Getting Personal
  id: totrans-1232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**How important (honestly) is code performance in your current project? What
    is the motivator for this performance requirement?**'
  id: totrans-1233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在你的当前项目中，代码性能有多重要（老实说）？这个性能要求的动机是什么？**'
- en: The performance requirements should not be arbitrarily chosen. They should be
    justified, not just a time limit pulled out of thin air. Every performance requirement
    is important; there are no specifications that don't matter. How much concern
    a particular requirement generates depends on how hard it is to meet. Whether
    it's hard or not, you still have to come up with a design that satisfies it.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 性能要求不应随意选择。它们应该是合理的，而不仅仅是凭空拉出的时间限制。每个性能要求都很重要；没有无关紧要的规范。特定要求引起多少关注取决于满足它的难度。无论难易程度如何，你都必须提出一个满足这些要求的设计。
- en: '**In your last optimization attempt**:'
  id: totrans-1235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在你最后的优化尝试中**：'
- en: '**Did you use a profiler?**'
  id: totrans-1236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你使用了分析器吗？**'
- en: '**If yes, how much improvement did you measure?**'
  id: totrans-1237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果是，你测量了多少改进？**'
- en: '**If no, how did you know whether you made any kind of improvement?**'
  id: totrans-1238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果没有，你是如何知道你做出了任何改进的吗？**'
- en: '**Did you test that the code still worked after optimizing?**'
  id: totrans-1239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在优化后测试了代码是否仍然正常工作吗？**'
- en: '**If yes, how thoroughly did you test?**'
  id: totrans-1240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果答案是肯定的，你测试得有多彻底？**'
- en: '**If no, why not? How could you be sure the code still worked properly for
    all cases?**'
  id: totrans-1241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果没有，为什么没有？你如何确保代码在所有情况下都仍然正常工作？**'
- en: Only the most dramatic performance improvements can be detected without a profiler
    or some other good timing tests. Human perception is easily fooled—when you've
    just slaved to speed up the program, it will always *appear* faster to you.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有分析器或其他良好的计时测试，只能检测到最显著的性能改进。人的感知很容易被欺骗——当你为了加快程序而辛勤工作时，它对你来说总是会*显得*更快。
- en: Test performance improvements carefully, and discard those that are not worthwhile.
    It's better to have clear code than a minuscule speed increase and unmaintainable
    logic.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细测试性能改进，并丢弃那些不值得的改进。有清晰的代码比微小的速度提升和不维护的逻辑更好。
- en: '**If you''ve not yet attempted to optimize the code you''re currently working
    on, take a guess at which parts are the slowest and which bits consume the most
    memory. Now run it through a profiler—how accurate were you?**'
  id: totrans-1244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你还没有尝试优化你目前正在工作的代码，猜测一下哪些部分是最慢的，哪些部分消耗了最多的内存。现在运行它通过分析器——你的预测有多准确？**'
- en: You'll probably be quite surprised at the results. The larger the program you
    profile, the less likely you are to correctly judge these bottlenecks.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对结果感到非常惊讶。你分析的程序越大，你正确判断这些瓶颈的可能性就越小。
- en: '**How well specified are your program''s performance requirements? Do you have
    a concrete plan to test that you meet these criteria?**'
  id: totrans-1246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的程序的性能要求有多明确？你是否有具体的计划来测试你是否满足这些标准？**'
- en: Without a clear specification, no one can really complain that your program
    isn't fast enough!
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确的规范，没有人真的会抱怨你的程序不够快！
- en: '* * *'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](#APP-FN-15)]) Conversely, this reference might inhibit other performance
    gains. Copies are guaranteed not to have aliasing issues; some compiler optimizations
    cannot be performed if there are potential variable aliases. As always, you must
    measure and work out what works best.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#APP-FN-15)]) 相反，这个引用可能会抑制其他性能提升。副本保证没有别名问题；如果存在潜在的变量别名，一些编译器优化无法执行。一如既往，你必须衡量并找出什么最适合。
- en: ^([[16](#APP-FN-16)]) That looks stupid when you see it written down, but it's
    a very easy trap to fall into at the codeface.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#APP-FN-16)]) 当你把它写下来时，这看起来很愚蠢，但这是一个很容易陷入的简单陷阱。
- en: '[Chapter 12](ch12.html "Chapter 12. AN INSECURITY COMPLEX")'
  id: totrans-1251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第12章](ch12.html "第12章。一个不安全感复杂")'
- en: Mull It Over
  id: totrans-1252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**What is a "secure" program?**'
  id: totrans-1253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**“安全”的程序是什么意思？**'
- en: A secure program is able to stand up against attempts to abuse it, to break
    into it, or to use it for a purpose it was not intended for. This is more than
    a robust program; robust code meets its specification and doesn't crash when you
    apply a little pressure. However, a robust program might not have been designed
    with security in mind and could still leak sensitive information under some extreme
    conditions. Sometimes it's preferable to crash when used wrongly, rather than
    provide unintended output. So secure code *might* crash!
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的程序能够抵御滥用、入侵或用于其未打算使用的目的的尝试。这不仅仅是一个健壮的程序；健壮的代码满足其规范，并在施加轻微压力时不会崩溃。然而，健壮的程序可能没有考虑到安全性，并且在某些极端条件下可能会泄露敏感信息。有时，当使用不当时崩溃，而不是提供意外的输出，可能是更好的选择。因此，安全的代码*可能*会崩溃！
- en: 'The definition of a secure program depends on the security requirements for
    the application. These are defined in part by what you can expect from the supporting
    services (the OS and other applications). Given these, your application''s objectives
    could be any of the following:'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 安全程序的定义取决于应用程序的安全要求。这些要求部分由支持服务（操作系统和其他应用程序）所能提供的内容定义。考虑到这些因素，您的应用程序的目标可以是以下任何一种：
- en: '**Confidentiality**'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: '**机密性**'
- en: The system will not disclose information to the wrong people. They will get
    an access denied message, or will have no idea that the information exists in
    the first place.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不会向错误的人透露信息。他们将会收到一个访问拒绝的消息，或者甚至不知道信息最初存在。
- en: '**Integrity**'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性**'
- en: The system won't allow unauthorized changing of information.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 系统不会允许未经授权的信息更改。
- en: '**Availability**'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性**'
- en: The system works continually—even while being attacked. It's hard to guard against
    *all* possible attacks (what if someone removes the power?), but it's possible
    to resist many attacks by including a level of redundancy in the design, or by
    providing a rapid restart after attack.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 系统持续工作——即使在受到攻击的情况下。很难防御*所有*可能的攻击（如果有人切断电源怎么办？），但通过在设计时包含一定程度的冗余或攻击后提供快速重启，可以抵抗许多攻击。
- en: '**Authentication**'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**'
- en: The system ensures that users are who they say they are, usually with a login
    and password mechanism.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 系统确保用户是他们所说的那个人，通常是通过登录和密码机制。
- en: '**Audit**'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: '**审计**'
- en: The system records information about all important operations, to catch or monitor
    the activities of attackers.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 系统记录所有重要操作的信息，以捕捉或监控攻击者的活动。
- en: '**What input must be validated in a secure program? What sort of validation
    is required?**'
  id: totrans-1266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在安全程序中，必须验证哪些输入？需要什么样的验证？**'
- en: '*All* input must be validated. This includes command-line parameters, environment
    variables, GUI inputs, web form inputs (even those with client-side JavaScript
    checking), CGI-encoded URLs, cookie contents, file contents, and filenames.'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有*输入都必须经过验证。这包括命令行参数、环境变量、GUI输入、Web表单输入（即使那些带有客户端JavaScript检查的）、CGI编码的URL、cookie内容、文件内容和文件名。'
- en: You should check the input's size (if it's not a simple numeric variable), the
    validity of its format, and the actual contents of the data (that numbers are
    in range, and there are no embedded query strings).
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该检查输入的大小（如果它不是一个简单的数值变量）、其格式的有效性以及数据的实际内容（数字在范围内，并且没有嵌入的查询字符串）。
- en: '**How can you guard against attacks from the pool of trusted users?**'
  id: totrans-1269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何防御来自受信任用户池的攻击？**'
- en: Not very easily. They have been given a specific level of privilege because
    they are trusted not to abuse it. Most users will not intentionally abuse your
    software, but a small number will try to subvert programs for their own advantage.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 并非很容易。他们被赋予了特定的权限级别，因为他们被认为不会滥用。大多数用户不会故意滥用您的软件，但一小部分人可能会试图为了自己的利益而篡改程序。
- en: 'There are a few techniques to manage this:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以管理这一点：
- en: Log every operation so you know who made what change and when.
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录每一次操作，以便您知道谁做了什么更改以及何时做的更改。
- en: Require two users to authenticate all really important operations.
  id: totrans-1273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有真正重要的操作，需要两个用户进行身份验证。
- en: Wrap each operation in an undoable transaction so it can be unrolled.
  id: totrans-1274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个操作包裹在一个可撤销的事务中，以便可以取消操作。
- en: Back up all data stores periodically so you can retrieve lost data.
  id: totrans-1275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期备份所有数据存储，以便您可以恢复丢失的数据。
- en: '**Where can an exploitable buffer overrun occur? What functions are particularly
    prone to buffer overrun?**'
  id: totrans-1276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在哪里可能会发生可利用的缓冲区溢出？哪些函数特别容易发生缓冲区溢出？**'
- en: Buffer overrun is probably the biggest security vulnerability, and it is a simple
    problem that is easy for an attacker to exploit. It can occur anywhere that a
    multi-location structure is addressed—either by copying data into or out of it
    or by indexing into it to access a specific item. Arrays and strings are the most
    common culprits.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出可能是最大的安全漏洞，这是一个简单的问题，攻击者很容易利用。它可能发生在任何多位置结构被寻址的地方——无论是通过将其数据复制到或从中复制出来，还是通过索引它来访问特定项。数组和字符串是最常见的罪魁祸首。
- en: It is most often seen in user input routines, although this is not the only
    habitat—it can exist within any data manipulation code. Exploitable buffers can
    be situated both on the stack (where function-local variables are placed) or on
    the heap (the pool of dynamically allocated memory).
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常出现在用户输入例程中，尽管这并不是唯一的栖息地——它可以在任何数据操作代码中存在。可利用的缓冲区可以位于栈上（函数局部变量放置的地方）或堆上（动态分配内存的池子）。
- en: '**Can you avoid buffer overruns altogether?**'
  id: totrans-1279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你能完全避免缓冲区溢出吗？**'
- en: Yes—as long as you are diligent in validating each function's input and can
    be sure that the stack of software leading up to each input (possibility implemented
    in the OS input routines or your language's run-time library) is safe.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——只要你在验证每个函数的输入上勤奋，并且可以确信每个输入（在操作系统输入例程或你的语言运行时库中实现的可能性）的软件堆栈是安全的。
- en: 'Here are some key techniques to safeguard your code:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关键技术来保护你的代码：
- en: 'Use a language with no fixed-size buffers—for example, a language that has
    automatically extending strings. It''s not just strings that are dangerous, though:
    Look for bounds-checked arrays and safe hash maps.'
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用没有固定大小缓冲区的语言——例如，具有自动扩展字符串的语言。然而，不仅仅是字符串是危险的：寻找边界检查的数组和安全的哈希映射。
- en: If you can't rely on language support, you *must* bounds check all input.
  id: totrans-1283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不能依赖语言支持，你**必须**对所有输入进行边界检查。
- en: In C, always use the safer standard library functions `strncpy`, `strncat`,
    `snprintf`, `fgets`, and so on. Don't use stdio routines like `printf`, and `scanf`—you
    can't guarantee their safety.
  id: totrans-1284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C中，始终使用更安全的标准库函数 `strncpy`、`strncat`、`snprintf`、`fgets` 等等。不要使用 `stdio` 例程，如
    `printf` 和 `scanf`——你不能保证它们的安全性。
- en: Never use third-party libraries that aren't provably safe.
  id: totrans-1285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要使用不可证明安全的第三方库。
- en: Write your code in a managed execution environment (like Java or C#). Then buffer
    overrun attacks become almost nonexistent—the executive traps most overruns automatically.
  id: totrans-1286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在受管理的执行环境中编写你的代码（如Java或C#）。然后缓冲区溢出攻击几乎不存在——执行器会自动捕获大多数溢出。
- en: '**How can you secure the memory in use by your application?**'
  id: totrans-1287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何确保应用程序使用的内存安全？**'
- en: 'There are three times to think about memory security:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个时刻需要考虑内存安全性：
- en: Before you use it. When you claim some memory, it contains arbitrary values.
    Don't write code that accidentally relies on the contents of uninitialized memory.
    A cracker could exploit this to attack your code. To be extra safe, zero all allocated
    memory before you use it.
  id: totrans-1289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用之前。当你请求一些内存时，它包含任意值。不要编写依赖于未初始化内存内容的代码。黑客可以利用这一点来攻击你的代码。为了额外的安全，在使用之前将所有分配的内存清零。
- en: During use. Lock memory containing sensitive information so it can't be swapped
    to disk. Obviously you must be using a secure OS—if one application can read any
    other's memory, then you've already lost!
  id: totrans-1290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用期间。锁定包含敏感信息的内存，使其不能被交换到磁盘。显然，你必须使用一个安全的操作系统——如果一个应用程序可以读取任何其他应用程序的内存，那么你已经输了！
- en: After use. Often forgotten by application programmers is that when you release
    memory, it should be cleaned before you hand it back for the OS to recycle. If
    you don't do this, a rogue process could mine memory for the secret data you leave
    behind.
  id: totrans-1291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用后。应用程序程序员常常忘记的是，当你释放内存时，应该在将其交回操作系统回收之前进行清理。如果你不这样做，恶意进程可能会挖掘你留下的秘密数据。
- en: '**Are C and C++ inherently less secure than alternative languages?**'
  id: totrans-1292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C和C++是否天生比其他语言更不安全？**'
- en: C and C++ produce more than their fair share of insecure applications and *allow*
    you to write code containing classic security vulnerabilities. You definitely
    have to keep your brain switched on; even experienced developers must pay attention
    when writing C/C++ code to avoid buffer overruns. These languages don't exactly
    encourage secure programming.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++产生了比其公平份额更多的不安全应用程序，并且**允许**你编写包含经典安全漏洞的代码。你绝对必须保持头脑清醒；即使是经验丰富的开发者，在编写C/C++代码时也必须注意以避免缓冲区溢出。这些语言并不鼓励安全的编程。
- en: However, other languages don't avoid all security problems either, just the
    ones C and C++ have made famous. A different language will most likely avoid potential
    buffer overruns, but you shouldn't have a false sense of security; many other
    problems that can't be avoided in the language itself remain. You must be aware
    of security issues when using *any* language—you can't pick a "safe" language
    and forget all about security.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他语言也无法避免所有安全问题，只是不像C和C++那样使这些问题变得众所周知。不同的语言可能会避免潜在的缓冲区溢出，但你不应有一种虚假的安全感；许多在语言本身中无法避免的其他问题仍然存在。在使用任何语言时，你必须意识到安全问题——你不能选择一个“安全”的语言而忘记所有关于安全的事情。
- en: Indeed, buffer overrun is a vulnerability that can be very easily audited and
    worked around. If you need to program secure applications, then the language you
    use is a small concern among all the other problems.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，缓冲区溢出是一种可以非常容易地进行审计和规避的漏洞。如果你需要编写安全的应用程序，那么你使用的语言只是所有其他问题中的一小部分。
- en: '**Has the experience of C led to C++ being a better, more securely designed
    language?**'
  id: totrans-1296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C语言的经验是否使C++成为一种更好、更安全设计的语言？**'
- en: 'C++ has gained an abstract `string` type that manages its own memory internally.
    This goes a long way toward avoiding buffer overruns, although traditional C-style
    `char` arrays remain for those who still want to shoot themselves in the foot.
    The `vector` is another handy device: a memory managing array. However, it is
    possible to overrun both of these structures—do you know how?'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: C++获得了一个内部管理其内存的抽象`string`类型。这有助于避免缓冲区溢出，尽管传统的C风格`char`数组仍然存在，供那些仍然想自毁前程的人使用。`vector`是另一个有用的工具：一个内存管理的数组。然而，这两种结构都有可能发生溢出——你知道如何吗？
- en: C++ could be considered more dangerous than C, because it stores a lot of function
    pointers on the heap (this is where virtual function tables are stored). If an
    attacker can overwrite one of those pointers, then he can redirect operation to
    his own evil code.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: C++可能被认为比C更危险，因为它在堆上存储了大量的函数指针（这是虚拟函数表存储的地方）。如果攻击者可以覆盖这些指针之一，那么他就可以将操作重定向到自己的恶意代码。
- en: In many ways, C++ is more secure, or rather, it is more easy to use securely.
    However, it was not designed with security solely in mind, and provides its own
    set of security problems that the developer must be aware of.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，C++更安全，或者说，它更容易安全地使用。然而，它并不是完全为了安全而设计的，并且提供了一套开发者必须意识到的安全问题。
- en: '**How do you know when your program has been compromised?**'
  id: totrans-1300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何知道你的程序已被入侵？**'
- en: Without detection measures, you'll have no idea—and you will just have to keep
    an eye out for unusual system behavior or different patterns of activity. This
    is hardly scientific. A hacked system can remain a secret indefinitely. Even if
    a victim (or his software vendor) *does* spot an attack, he probably doesn't want
    to release detailed information about it to invite more intruders. What company
    would publicize that its product has security flaws? If it is conscientious enough
    to release a security patch, not everyone will upgrade, leaving a well-documented
    security flaw in many operational systems.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 没有检测措施，你将一无所知——你只能密切关注异常的系统行为或不同的活动模式。这几乎不是科学的。被黑客攻击的系统可以无限期地保持秘密。即使受害者（或他的软件供应商）确实发现了攻击，他可能也不愿意发布关于攻击的详细信息，以吸引更多的入侵者。哪家公司会公布其产品存在安全漏洞？如果它足够负责任地发布安全补丁，并不是每个人都会升级，这将导致许多运行中的系统存在一个被充分记录的安全漏洞。
- en: Getting Personal
  id: totrans-1302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人观点
- en: '**What are the security requirements for your current project? How were these
    requirements established? Who knows about them? Where are they documented?**'
  id: totrans-1303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你当前项目的安全需求是什么？这些需求是如何建立的？谁了解它们？它们在哪里被记录？**'
- en: Answer this honestly. It's not too hard to make up something that sounds plausible.
    But unless the security requirements are formally documented, security has not
    really been addressed by your project. This should be something that every developer
    is aware of and knows how to fulfill.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 坦诚回答这个问题。编造一些听起来合理的东西并不难。但除非安全需求被正式记录，否则你的项目并没有真正解决安全问题。这应该是每个开发者都应意识到并知道如何满足的事情。
- en: '**What''s the worst security bug in one of your shipped applications?**'
  id: totrans-1305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你发布的应用程序中最严重的安全漏洞是什么？**'
- en: It's important to know about this, even if it's now ancient history. You have
    to know what you've got wrong in the past to stand any chance of avoiding it in
    the future. If you don't know of any past security vulnerabilities, then you've
    probably not been thorough in security testing—you've not been paying attention,
    or you've been very lucky to have nothing discovered.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点很重要，即使它现在已经成为历史。你必须知道你过去做错了什么，这样你才有可能在未来避免它。如果你不知道任何过去的安全漏洞，那么你可能没有在安全测试中做得彻底——你没有注意，或者你非常幸运，没有发现任何问题。
- en: '**How many security bulletins have been posted against your application?**'
  id: totrans-1307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**针对你的应用程序发布了多少安全公告？**'
- en: Have these been caused by silly developer mistakes like stupid code errors,
    or do they stem from larger design problems? Most common problems that get documented
    in bulletins are the former.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是由于愚蠢的开发者错误，比如愚蠢的代码错误，还是源于更大的设计问题？在公告中记录的最常见问题是前者。
- en: '**Have you ever run a security audit? What kinds of flaws did it reveal?**'
  id: totrans-1309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你曾经进行过安全审计吗？它揭示了哪些缺陷？**'
- en: Unless you have a professional security specialist running this test, it will
    surely miss some security vulnerabilities. However, the audit will still uncover
    many glaring problems and is *very* worthwhile.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有专业的安全专家进行这项测试，否则肯定会错过一些安全漏洞。然而，审计仍然会揭露许多明显的问题，并且*非常有价值*。
- en: '**What kind of person is most likely to attack your current system? How is
    this influenced by**'
  id: totrans-1311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**最有可能攻击你当前系统的人是什么样的？这如何受到**'
- en: '**Your company**'
  id: totrans-1312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的公司**'
- en: '**The type of user**'
  id: totrans-1313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户的类型**'
- en: '**The type of product**'
  id: totrans-1314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品的类型**'
- en: '**The popularity of the product**'
  id: totrans-1315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品的流行度**'
- en: '**The competition**'
  id: totrans-1316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争**'
- en: '**The platform you run on**'
  id: totrans-1317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你运行的平台**'
- en: '**The connectedness and public visibility of the system**'
  id: totrans-1318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统的连通性和公开可见性**'
- en: 'Everyone is a target to someone: a malicious user, unscrupulous competitors,
    and even terrorist organizations. Who do you trust?'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都是某个人的目标：恶意用户、无良竞争者，甚至是恐怖组织。你信任谁？
- en: '[Chapter 13](ch13.html "Chapter 13. GRAND DESIGNS")'
  id: totrans-1320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第13章](ch13.html "第13章。宏伟的设计")'
- en: Mull It Over
  id: totrans-1321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**How does project size affect your software design and the work involved in
    creating it?**'
  id: totrans-1322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**项目规模如何影响你的软件设计和创建它的工作？**'
- en: The larger a project gets, the more architectural design it requires in proportion
    to low-level code design. More time needs to be spent up front ensuring the design
    is right, because bad choices will have more serious consequences.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 项目越大，相对于底层代码设计，它需要的架构设计就越多。需要更多的时间在前期确保设计正确，因为错误的选择将会有更严重的后果。
- en: '**Is a well-documented bad design better than an undocumented good one?**'
  id: totrans-1324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详尽的糟糕设计是否比未记录的良好设计更好？**'
- en: Documentation is part of what makes a design good. A well-documented bad design
    provides a route in to the code, even if it's a brightly illuminated dirt track
    to a cesspit. At the very least, it will teach you never to touch the code again.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是使设计良好的部分原因。一个详尽的糟糕设计提供了进入代码的途径，即使它是一条通往化粪池的明亮的泥泞小道。至少，它会教会你永远不要再触碰这段代码。
- en: A sufficiently simple piece of code shouldn't need reams of documentation, but
    any reasonably complex piece of software becomes hard to work with when there
    isn't adequate description.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 一段足够简单的代码不需要大量的文档，但任何合理复杂的软件在没有适当描述的情况下都很难使用。
- en: 'Which is better? The undocumented good design is best: If it is a truly high-quality
    design, then it *should* be obvious and self-documenting.'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好？未记录的良好设计是最好的：如果它是一个真正高质量的设计，那么它*应该*是显而易见且自我说明的。
- en: '**How can you measure the design quality of a piece of code? How can you quantify
    its simplicity, elegance, modularity, and so on?**'
  id: totrans-1328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何衡量一段代码的设计质量？如何量化其简洁性、优雅性、模块化等？**'
- en: Quality is difficult to quantify; it's largely an aesthetic judgment for design.
    What makes a picture beautiful? The kind of thing you can't hold in your hand
    and count. Hindsight will show how easy the code was to pick up or to modify.
    But that doesn't really help when you first come across some code. If I have two
    designs *A* and *B*, and I think *A* is more elegant, but in practice *B* turns
    out to be more usable and copes with the pressures of reuse much better, then
    it is hard to argue that *A* is the better design.
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 质量难以量化；它主要是对设计的美学判断。是什么让一幅画变得美丽？这类东西你无法用手握住并计数。事后看来，代码的易读性或可修改性可能会显得很简单。但当你第一次遇到一些代码时，这并不真正有帮助。如果我有两个设计*A*和*B*，我认为*A*更优雅，但在实践中*B*证明更易于使用，并且更好地应对了重用的压力，那么很难说*A*是更好的设计。
- en: 'The only way to judge design quality is to *look* at the code. Reading a little
    code generally gives a good impression of overall quality; if one small bit appears
    good, then the rest is likely to be of reasonable quality too. This doesn''t always
    hold, but it''s a handy yardstick. A realistic approach is this: If that little
    bit of code is bad, expect the whole codebase to be terrible. If the little bit
    is any good, then just suspect the codebase of harboring more subtle problems.'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 判断设计质量的唯一方法就是*查看*代码。阅读一点代码通常可以给人留下对整体质量的良好印象；如果一小部分看起来很好，那么其余部分也很可能是合理的质量。这并不总是成立，但它是一个实用的标准。一种现实的方法是这样的：如果那小部分代码很糟糕，那么整个代码库可能都很糟糕。如果那小部分代码不错，那么只是怀疑代码库中可能隐藏着更微妙的问题。
- en: Running code tools that inspect the source, producing diagrams and documentation,
    can also help to gauge design quality.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 运行检查源代码的工具，生成图表和文档，也可以帮助评估设计质量。
- en: '**Is design a team activity? How important are teamworking skills in creating
    a good design?**'
  id: totrans-1332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计是一项团队活动吗？在创造一个好的设计中，团队合作技能有多重要？**'
- en: Very important. Programming tasks are seldom a lone activity. In the software
    factory, most large-scale design activities involve more than one designer. Even
    if the work is split into separate areas, those areas interface at some point—so
    the designers must interface. If there *is* only one designer, he or she must
    still be able to document and communicate the design effectively.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要。编程任务很少是单独的活动。在软件工厂中，大多数大规模设计活动涉及不止一个设计师。即使工作被分成不同的区域，这些区域在某个点上也会接口——因此设计师必须接口。如果只有一个设计师，他或她仍然必须能够有效地记录和传达设计。
- en: '**Are different methodologies more suitable to different projects?**'
  id: totrans-1334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**不同的方法是否更适合不同的项目？**'
- en: Yes, the scope of some projects will render certain design approaches unnecessary.
    If you are writing a set of device drivers, you won't find *much* use in a full-blown
    OO design process.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，某些项目的范围将使某些设计方法变得不必要。如果你正在编写一组设备驱动程序，你不会在全面的应用程序对象设计过程中找到很多用途。
- en: If you are working on a very formal project, perhaps for a government agency,
    you'll need to use a very formal process that documents every stage and provides
    accountability for every design decision made. This may be quite different from
    an exploratory R&D project in a software lab.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为一个非常正式的项目工作，可能是一个政府机构的项目，你可能需要使用一个非常正式的过程，该过程记录每个阶段并提供对每个设计决策的责任。这可能和软件实验室中的探索性研发项目大不相同。
- en: '**In what ways can you determine whether a design is highly cohesive or weakly
    coupled?**'
  id: totrans-1337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何确定一个设计是高度内聚还是弱耦合的？**'
- en: Ultimately you have to look at the code and see how it fits together, but that's
    boring! You can get a good feel for coupling in a C or C++ project by looking
    at the `#include`s at the top of the file. If there are tons of them, the coupling
    is probably disastrous. Alternatively, you can run inspection tools that produce
    pretty pictures of your code.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你必须查看代码并观察其如何组合在一起，但这很无聊！通过查看文件顶部的`#include`语句，你可以很好地了解C或C++项目中的耦合情况。如果有很多这样的语句，那么耦合可能非常糟糕。或者，你也可以运行检查工具，这些工具可以生成你代码的漂亮图片。
- en: '**If you''ve solved a similar design problem in the past, how good an indicator
    is it of how difficult this problem will be?**'
  id: totrans-1339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果你以前解决过类似的设计问题，这将是衡量这个问题难度的一个多好的指标？**'
- en: Experience teaches you how to design, so learn and then exploit your knowledge.
    But employ wisdom with this knowledge; don't run on autopilot. Different situations
    present different challenges—don't presume that one problem is the same as another
    just because it looks like it on the surface.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 经验教会你如何设计，所以学习和利用你的知识。但运用智慧来运用这些知识；不要自动驾驶。不同的情况会带来不同的挑战——不要仅仅因为表面看起来一样就假设一个问题与另一个问题相同。
- en: If you know how to use a hammer, don't make every problem into a nail.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何使用锤子，不要把每个问题都变成钉子。
- en: '**Is there a place for experimentation in design?**'
  id: totrans-1342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计中有实验的余地吗？**'
- en: Yes, any design *is* experimental until it has been implemented and found acceptable.
    Consider the "build one to throw away" approach that Frederick Brooks described.
    (Brooks 95) There's a lot to be said for experimentation.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，任何设计在实施并被接受之前都是实验性的。考虑Frederick Brooks描述的“先做一个扔掉”的方法。（Brooks 95）实验有很多可说的。
- en: Design is an iterative process; during each iteration you can try out design
    alternatives and decide which is most sensible. The more iterations you go through
    and the smaller in scope you make each one, the less painful any bad design decisions
    will be.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 设计是一个迭代的过程；在每次迭代中，你可以尝试不同的设计方案，并决定哪个最合理。你经历的迭代越多，每次迭代的范围越小，不良的设计决策带来的痛苦就越少。
- en: Getting Personal
  id: totrans-1345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**Look back and think about how you learned to design code. How could you convey
    the knowledge you''ve gained to a total novice?**'
  id: totrans-1346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回顾一下你是如何学会设计代码的。你如何将你获得的知识传达给一个完全的新手？**'
- en: How much do you honestly think you *could* teach, and how much would have to
    come from the novice's inherent abilities and experience? Could you create a set
    of exercises based on your experience that would help someone else?
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你能教多少，有多少需要来自新手的天赋和经验？你能根据你的经验设计一套练习，帮助其他人吗？
- en: You wouldn't give a novice a large system to design at first. You'd start him
    off on a small self-contained project, and then perhaps get him to make extensions
    to existing programs, all the time keeping a mentoring eye on what he's doing.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会一开始就给一个新手一个大的系统来设计。你会让他从一个小的自包含项目开始，然后可能让他对现有的程序进行扩展，同时始终关注他的进展。
- en: Most programmers didn't get this kind of help themselves when they were learning
    to design. They learned through a process of trial and error. Do consider teaching
    and mentoring a novice—it really helps you to grow in your own abilities.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员在学习设计时没有得到这种帮助。他们通过试错的过程来学习。请考虑教授和指导新手——这真的有助于你在自己的能力上成长。
- en: '**What experience do you have with using particular design methodologies? Were
    these good or bad experiences? What was the resulting code like? What might have
    worked better?**'
  id: totrans-1350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你使用特定设计方法的经验如何？这些经历是好的还是坏的？产生的代码是什么样的？什么可能做得更好？**'
- en: Was the taste left in your mouth by a methodology influenced by your prior experience
    and preferences? If you don't know how to use a particular methodology, it will
    be hard work and uncomfortable. A hard-core C programmer may dislike any form
    of object-oriented design, and his OO designs will be appalling. But that doesn't
    make OO a flawed approach.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 你的口味是否受到了先前经验和偏好的方法论的影响？如果你不知道如何使用特定的方法论，那将是一项艰巨且不舒服的工作。一个铁杆的C程序员可能不喜欢任何形式的面向对象设计，他的OO设计可能会令人震惊。但这并不意味着OO是一个有缺陷的方法。
- en: '**Do you find it important to stick rigidly to the methodology you''re using?**'
  id: totrans-1352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你认为坚持使用的方法论很重要吗？**'
- en: The design approach is a tool, a utility, like a programming language—you should
    only use it up to the point it remains *useful*. If it stops being useful, it's
    no longer a utility! A methodology won't work if no one on the team knows how
    to perform it; use something they do know, or teach them first.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 设计方法是一种工具，一种实用工具，就像编程语言一样——你应该只用到它仍然有用为止。如果它不再有用，它就不再是实用工具了！如果团队中没有一个人知道如何执行它，那么这种方法就不会起作用；使用他们知道的东西，或者先教他们。
- en: '**What was the best designed code you''ve ever seen? What was the worst designed?**'
  id: totrans-1354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你见过的最佳设计的代码是什么？最差设计的呢？**'
- en: I bet you'll easily remember the worst designed code. Bad code sticks out like
    a sore thumb, and likewise sticks in your memory. Well-designed code looks simple
    and obvious, so you probably won't step back and say, "What a great design!" You
    probably won't even notice there was much design work involved.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你会很容易记住最糟糕的设计代码。糟糕的代码就像一个明显的痛处，同样也深深地留在你的记忆中。设计良好的代码看起来简单明了，所以你可能不会退后一步说，“这是一个多么伟大的设计！”你可能甚至不会注意到其中涉及了很多设计工作。
- en: '**A programming language is essentially a tool to implement your design, not
    a religion to argue about. How important is it really to know language idioms?**'
  id: totrans-1356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编程语言本质上是一种实现你设计的工具，而不是一个争论的宗教。真正重要的是了解语言习惯吗？**'
- en: It's very important, or you'll end up with code that doesn't make sense.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，否则你最终会得到没有意义的代码。
- en: 'Some architectural decisions may be language independent, but low-level code
    design is *heavily* influenced by the implementation language. An obvious example:
    Don''t create a flat procedural design when you''re coding in Java—it''s just
    plain wrong.'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 一些架构决策可能是语言无关的，但低级代码设计受到实现语言的**严重影响**。一个明显的例子：当你用Java编程时，不要创建一个扁平的过程式设计——这纯粹是错误的。
- en: '**Do you think programming is an engineering discipline, a craft, or an art?**'
  id: totrans-1359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你认为编程是一门工程学科、一门手艺还是一门艺术？**'
- en: Quite simply, it depends on how you do it. It has elements of all three.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这取决于你如何做。它包含了所有三个要素。
- en: I prefer to think of programming as a craft—it requires skill, workmanship,
    discipline, and experience. Its products can be at once functional *and* beautiful.
    There is an element of artistry in it; it's a creative process. Allied with this
    artistry is the mastery of tools and techniques. These are the hallmarks of a
    craft.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将编程视为一门手艺——它需要技能、工艺、纪律和经验。其产品可以同时具有功能性和美观性。其中包含了一定的艺术性；它是一个创造性的过程。与这种艺术性相伴随的是对工具和技术的掌握。这些都是手艺的标志。
- en: '[Chapter 14](ch14.html "Chapter 14. SOFTWARE ARCHITECTURE")'
  id: totrans-1362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。软件架构")'
- en: Mull It Over
  id: totrans-1363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沉思
- en: '**Define where** architecture **ends and** software design **begins**.'
  id: totrans-1364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义架构的结束和软件设计的开始**。'
- en: 'In truth, both terms can be defined to whatever suits you. In their common
    usage, the distinctions are as follows:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这两个术语可以定义为适合你的任何定义。在它们的常见用法中，区别如下：
- en: '**Architecture** is the high-level structural design. It looks at the wide-ranging
    implications of its choices, seeing how it will impact construction and maintenance
    costs, overall system complexity, ability to accommodate future extensions, and
    marketing concerns. The architecture is devised at the start of a project. It
    has serious consequences, at the very least on the further software design.'
  id: totrans-1366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构**是高级结构设计。它考虑其选择的广泛影响，看它将如何影响建设和维护成本、整体系统复杂性、适应未来扩展的能力以及营销问题。架构是在项目开始时制定的。它至少对进一步软件设计有严重后果。'
- en: '**Software design** is the next level down, a more refined and focused activity.
    It''s concerned with code details—data structures, function signatures, and the
    exact flow of control through modules. Software design is conducted on a per-module
    basis. Its consequences are nowhere near as significant to the system as a whole.'
  id: totrans-1367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件设计**是下一层次的活动，更加精细和专注。它关注代码细节——数据结构、函数签名以及模块中精确的控制流。软件设计是按模块进行的。它的后果对整个系统的影响远远不如架构那么显著。'
- en: Exactly where the two meet depends in part on the size of the project. Software
    construction is an iterative and incremental process—although architecture is
    created first, design results can feed back up to the architecture.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个领域相交的地方部分取决于项目的规模。软件构建是一个迭代和逐步的过程——尽管架构首先创建，但设计结果可以反馈到架构中。
- en: '**In what ways can a bad architecture affect a system? Are there parts that
    wouldn''t be affected by architectural flaws?**'
  id: totrans-1369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**糟糕的架构以何种方式影响系统？有没有哪些部分不会受到架构缺陷的影响？**'
- en: Bad architecture will undermine any effort to write good software. It is fundamental
    to the quality of your code. If some code isn't affected by the flawed architecture,
    then it's probably either a stand-alone library or it never really belonged in
    the system in the first place.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的架构会破坏编写好软件的任何努力。它是你代码质量的基础。如果某些代码不受有缺陷的架构的影响，那么它可能要么是一个独立的库，要么它从一开始就不应该属于该系统。
- en: '**How easy is it to repair architectural deficiencies once they become apparent?**'
  id: totrans-1371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一旦建筑缺陷显现出来，修复起来有多容易？**'
- en: During the early formative stages of a project, it's relatively easy to massage
    the architecture. But once development is committed to that architecture, with
    sufficient investment (design and code) slotted into its scaffold, it's very,
    *very* hard to change. You might as well try rewriting the entire product from
    scratch.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的早期形成阶段，调整架构相对容易。但一旦开发承诺了该架构，并且有足够的投资（设计和代码）已经安排在其框架中，就非常，*非常*难以改变。你不妨尝试从头开始重写整个产品。
- en: This is why it is so important to get the architecture right the first time.
    You can refactor small bits of code, but not an entire structural foundation.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么第一次做对架构如此重要的原因。你可以重构一小部分代码，但不能重构整个结构基础。
- en: Of course, it is easier for us to rip up software and start it afresh than it
    is in the physical construction industry, but economics dictate that we can't
    do it. We usually only have one chance to get the architecture right, and if we
    don't, we will have to live with the consequences for the entire lifetime of the
    software system.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与物理建筑行业相比，我们撕毁软件并重新开始要容易得多，但经济因素决定了我们无法这样做。我们通常只有一次机会做对架构，如果我们没有，我们就必须忍受整个软件系统生命周期中的后果。
- en: '**To what extent does architecture affect the following things?**'
  id: totrans-1375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**架构在多大程度上影响以下事物？**'
- en: '**System configuration**'
  id: totrans-1376
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**系统配置**'
- en: '**Logging**'
  id: totrans-1377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日志记录**'
- en: '**Error handling**'
  id: totrans-1378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**错误处理**'
- en: '**Security**'
  id: totrans-1379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安全性**'
- en: The architecture has a profound impact on each of these, or more correctly,
    each of these has a profound impact on the architecture. You need to establish
    requirements for these areas before embarking on serious architectural design.
    It will be hard to graft such features into the code at a later date, let alone
    into the overriding architecture.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 架构对每一个都有深远的影响，或者更准确地说，每一个都对架构有深远的影响。在开始严肃的架构设计之前，你需要为这些领域建立要求。在以后日期将这些功能嫁接到代码中将会很困难，更不用说嫁接到主导架构中。
- en: 'The architecture determines *what* should be configurable (a lot or a little)
    and *how* it should be configured. The kind of configuration mechanism is determined
    by several factors: the importance of a shared "configuration manager" component,
    whether or not the system supports remote configuration, and who has rights to
    perform configuration (is it just the developers; should the software be tweaked
    by installers, maintainers, or users?). All of these concerns are fundamental
    architectural issues.'
  id: totrans-1381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 架构决定了*什么*应该可配置（很多或很少）以及*如何*进行配置。配置机制的类型由几个因素决定：共享“配置管理器”组件的重要性、系统是否支持远程配置，以及谁有权执行配置（仅仅是开发者；软件是否应该由安装程序、维护人员或用户进行调整？）。所有这些关注点都是基本架构问题。
- en: The separate components may log information using some shared facility, or they
    might use their own custom mechanisms. The architecture will define which approach
    is acceptable, how you access the logs, and also the sort of logging information
    that's important. This needs to address the requirements of the software developers
    as well as the software users. Should development logging information be produced
    by release versions?
  id: totrans-1382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立的组件可能使用某些共享设施来记录信息，或者它们可能使用自己的定制机制。架构将定义哪种方法是可以接受的，如何访问日志，以及重要的日志信息类型。这需要解决软件开发人员和软件用户的需求。是否应该由发布版本生成开发日志信息？
- en: 'Architectural error management concerns include whether or not there is a central
    error-logging service and the error-reporting scheme (how does an error propagate
    from the seedy back-end components to the user''s sanitized GUI interface?). It
    also defines what kind of error mechanisms are used: perhaps a centralized table
    of error codes shared across all components or a common exception hierarchy. It
    will address how errors from third-party code are incorporated into the system.'
  id: totrans-1383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 架构错误管理问题包括是否存在中央错误记录服务以及错误报告方案（错误是如何从污秽的后端组件传播到用户清洁的GUI界面？）。它还定义了使用哪种类型的错误机制：可能是一个跨所有组件共享的集中式错误代码表或一个通用的异常层次结构。它将解决第三方代码中的错误如何纳入系统。
- en: Security issues will depend on the kind of software under development. A distributed
    Internet-based shop-front system has different security requirements from a small
    piece of code that will only ever be deployed on a stand-alone computer. Security
    is an important topic and can't be grafted in at the last minute; it must be addressed
    in the early architectural designs.
  id: totrans-1384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全问题将取决于正在开发的软件类型。一个基于分布式互联网的店面系统与仅部署在独立计算机上的小段代码的安全需求不同。安全是一个重要的话题，不能在最后一刻仓促加入；它必须在早期架构设计中得到解决。
- en: '**What experience or qualifications are required to be called a software architect?**'
  id: totrans-1385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**成为软件架构师需要哪些经验和资质？**'
- en: You can decide to *call* yourself an architect, but you can't gain insight and
    experience overnight or magically conjure up the wisdom to make good design decisions.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以决定自称是架构师，但你不能一夜之间获得洞察力和经验，也不能神奇地召唤出做出良好设计决策的智慧。
- en: Good architectural design requires a wealth of prior experience—learning from,
    devising, and refining real software systems. This can only be learned by actually
    doing it, not by watching someone else. Be wary of people who call themselves
    architects after working on just one release of software.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的架构设计需要丰富的先前经验——从真实软件系统中学习、设计和改进。这只能通过实际操作来学习，而不是通过观察他人。要警惕那些在仅完成一个软件版本的工作后自称架构师的人。
- en: You can work on software architecture and not be called an architect; the use
    of this moniker often depends on company structure and culture. No formal qualifications
    are required before you claim the title—however in some countries, it is illegal
    to call yourself any kind of architect without professional accreditation.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从事软件架构工作而不被称为架构师；这个称号的使用通常取决于公司结构和文化。在声称这个称号之前不需要正式的资质——然而，在一些国家，没有专业认证就自称任何类型的架构师是非法的。
- en: '**Should sales strategy influence architecture? If so, how? If not, why?**'
  id: totrans-1389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**销售策略应该影响架构吗？如果是，如何？如果不是，为什么？**'
- en: Yes, commercial concerns will inevitably affect the technical architecture.
    Otherwise, you'll build a system that is not a viable product; you'll rapidly
    find yourself out of a job and your company in receivership.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，商业问题不可避免地会影响技术架构。否则，你会构建一个不可行的产品；你很快就会发现自己失业，你的公司陷入清算。
- en: We *must* address the commercial implications of our designs—for example, considering
    the consequences of failure modes and the cost associated with return-to-base
    or on-site system support. The architecture must minimize these events if they
    are problems (you can provide remote access and rich diagnostics to avoid such
    intense product support).
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决我们设计的商业影响——例如，考虑故障模式的影响以及与返回基地或现场系统支持相关的成本。如果这些问题存在，架构必须最小化这些事件（你可以提供远程访问和丰富的诊断来避免这种强烈的产品支持）。
- en: 'Commercial concerns also affect these architectural areas: customer support
    facilities (including how easy the system is to administer), the installation
    approach (performed by trained personnel or by an automated CD installer), and
    maintenance support and fee structures.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 商业问题也会影响这些架构领域：客户支持设施（包括系统管理的难易程度），安装方法（由受过培训的人员执行或由自动CD安装程序执行），以及维护支持和费用结构。
- en: '**How would you architect for** extensibility? **How would you architect for**
    performance? **How do these design goals affect the system, and how do they complement
    one another?**'
  id: totrans-1393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你将如何设计可扩展性？你将如何设计性能？这些设计目标如何影响系统，以及它们如何相互补充？**'
- en: There are a number of architectural decisions that follow from these two requirements.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多架构决策是从这两个要求中产生的。
- en: '**Extensibility** can be supported through architectural devices such as plug-ins,
    programmatic access to code (reflection), more language bindings, scripting capabilities,
    and extra levels of indirection.'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**可以通过架构设备如插件、代码的编程访问（反射）、更多语言绑定、脚本能力以及额外的间接层次来支持。'
- en: '**Performance** is achieved by streamlining the architecture, keeping it mean
    and lean. You must remove all unnecessary components and ensure the connections
    provided are timely and adequate. Perhaps caching layers must be incorporated
    to boost data throughput.'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**是通过简化架构，保持其简洁和精炼来实现的。你必须移除所有不必要的组件，并确保提供的连接及时且充足。可能需要包含缓存层来提高数据吞吐量。'
- en: As you can see, these two have little in common; every hook for extensibility
    will consume some, no matter how little, performance. Extra indirection has a
    cost—the indirection. If your goal is extensibility, this is an appropriate price
    to pay. A good architecture makes the correct high-level compromises to suit the
    perceived requirements.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这两者几乎没有共同之处；每个扩展的钩子都会消耗一些，无论多小，性能。额外的间接性是有成本的——那就是间接性。如果你的目标是可扩展性，这是你愿意付出的适当代价。一个好的架构会做出正确的高级妥协，以适应感知的需求。
- en: Getting Personal
  id: totrans-1398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人感悟
- en: '**How diverse is the range of architectural styles to which you are accustomed?
    What do you have the most experience with—how does it affect the software you
    write?**'
  id: totrans-1399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你对哪些架构风格最为熟悉？你最有经验的是哪一种——它如何影响你编写的软件？**'
- en: Architecture affects us in many ways. Different architectural styles lead to
    different design and coding techniques. We are creatures of habit, and these techniques
    will shape how we think and code, even when working within a different architecture
    later on.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 架构以多种方式影响我们。不同的架构风格导致不同的设计和编码技术。我们是习惯性的生物，这些技术将塑造我们的思维和编码方式，即使是在后来工作于不同的架构时也是如此。
- en: It is healthy to be exposed to a number of different architectures and to be
    able to work with them. In practice, you will focus on one particular style. Make
    sure you understand how your code is shaped by this architecture, and check that
    you're writing sympathetic code when you do change architectures.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 接触多种不同的架构并能够与之合作是健康的。在实践中，你将专注于一种特定的风格。确保你理解你的代码是如何被这种架构塑造的，并在改变架构时确保你编写的是同情的代码。
- en: '**What personal experience do you have of architectures that succeeded or failed?
    What made them winning solutions or a hindrances?**'
  id: totrans-1402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你有什么关于成功或失败的架构的个人经验？是什么使它们成为获胜的解决方案或障碍？**'
- en: First, we must define what architectural *success* means. Is it an architecture
    with technical merit? Is it a system that achieves commercial profitability? Is
    it a bit of both? Place your answer here.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义什么是架构的*成功*。是具有技术优势的架构吗？是实现了商业盈利的系统吗？是两者兼而有之吗？请在这里写下你的答案。
- en: Software that buckles under the weight of inappropriate architecture usually
    suffers because the architecture was not suitably extensible. Important features
    cannot be accommodated. This inevitably means the product loses market share to
    the more nimble competitors. History is strewn with software products that have
    fallen by the wayside like this.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 那些因不适当的架构而承受重压的软件通常是因为架构不适合扩展。重要的功能无法容纳。这不可避免地意味着产品会失去市场份额给更灵活的竞争对手。历史上充满了这样的软件产品。
- en: Another danger is legacy; a huge investment in architectural baggage is a great
    hindrance. It requires real insight and a fair bit of courage to throw away an
    old system or architecture and start from scratch. A rework must always learn
    lessons from the previous version.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个危险是遗留问题；对架构遗留投资的巨大投入是一个巨大的障碍。需要真正的洞察力和相当大的勇气才能丢弃旧系统或架构，从头开始。重做必须总是从上一个版本中学习经验教训。
- en: An over-engineered architecture is just as dangerous as an insufficient one.
    If the architecture supports too much, it will make the product overly complex,
    cumbersome, and unacceptably slow. It usually means that even the simplest change
    requires modifying many components.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 过度设计的架构和不足的架构一样危险。如果架构支持过多，它会使产品过于复杂、笨重，并且速度无法接受。通常这意味着即使是简单的更改也需要修改许多组件。
- en: '**Get every developer on your current project to draw a picture of the system
    architecture—individually (without talking to anyone) and without any reference
    to system documentation or the code. Compare the pictures. See what strikes you
    about each developer''s efforts—aside from the relative artistic merit!**'
  id: totrans-1407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让你们当前项目上的每个开发者都画一幅系统架构图——单独地（不与任何人交谈）且不参考任何系统文档或代码。比较这些图片。看看每个开发者的努力中有哪些让你印象深刻的地方——除了相对的艺术价值！**'
- en: Be fearful if the pictures bear no resemblance to one another. Don't worry if
    there are minor variations; different people will miss different small components,
    and each may be focused on different parts of the system. But if the diagrams
    contain wildly different components or the communication paths are not similar,
    then the team does not have the same mental model of the code. This will almost
    certainly lead to disaster. Pull the developers together and make sure they know
    what the system really looks like.
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图片之间没有相似之处，那就感到害怕。如果只有细微的差别，不要担心；不同的人会错过不同的微小组件，每个人可能都专注于系统的不同部分。但如果图表包含截然不同的组件或通信路径不相似，那么团队对代码就没有相同的心理模型。这几乎肯定会导致灾难。召集开发者们一起确保他们知道系统真正的样子。
- en: If all the diagrams *do* look similar, then give yourselves a pat on the back.
    You get bonus points if the components are positioned similarly on each sheet
    of paper. This is a hint that there is a central architecture specification and,
    more importantly, that everyone understands it.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有图表看起来都相似，那就给自己鼓掌。如果组件在每个纸张上位置相似，你将获得额外的分数。这是一个暗示，表明存在一个中心架构规范，更重要的是，每个人都理解它。
- en: '**Do you have an architectural description that''s commonly available for your
    current project? How up to date is it? Which kinds of view are you using? If you
    needed to explain the system to a newcomer or a potential customer, what would
    you really need to have documented?**'
  id: totrans-1410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你有一个当前项目普遍可用的架构描述吗？它有多新？你使用哪些类型的视图？如果你需要向新来者或潜在客户解释系统，你真正需要记录什么？**'
- en: Note how far your ideal documentation is from reality. What opportunities do
    you have to improve this situation? In a busy commercial environment, you'll rarely
    be able to schedule specific time to document the entire architecture, but you
    can plan to capture parts during the design and specification of new modules.
    In this way, you can construct a good architectural overview, piece by piece.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的理想文档与现实之间的差距。你有哪些机会来改善这种情况？在一个繁忙的商业环境中，你很少能够安排特定的时间来记录整个架构，但你可以在设计新模块和制定规范的过程中捕捉到部分内容。这样，你可以逐步构建一个良好的架构概述。
- en: '**How does your system''s architecture compare to the architecture of your
    competitors in the marketplace? How has your architecture been defined to determine
    your project''s success?**'
  id: totrans-1412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的系统架构与市场上竞争对手的架构相比如何？你的架构是如何定义的，以确定项目的成功？**'
- en: It's important to understand how your architecture is designed to meet all your
    requirements and to ensure your success. (If it has not been designed with this
    in mind, then you're in trouble.) We've seen how architecture has the most fundamental
    affect on the shape and quality of a software system—it therefore really does
    have a large influence on your product's success or failure. You'll rarely see
    software products thriving *despite* their bad architecture. If you do know of
    a successful one, it probably won't be around for very much longer.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 理解你的架构是如何设计以满足所有你的需求并确保你的成功是很重要的。（如果它没有考虑到这一点，那么你就有麻烦了。）我们已经看到架构对软件系统的形状和质量有最根本的影响——因此它确实对你的产品成功或失败有很大的影响。你很少会看到软件产品在糟糕的架构下繁荣。如果你知道一个成功的例子，它可能不会持续很长时间。
- en: An architecture must be able to support at least the same core functionality
    as competing systems and provide good support for the unique features that will
    cause someone to choose your product over anyone else's. The simple features that
    don't require architectural support are rarely as compelling as core functionality
    embedded deeply in the system.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 架构必须能够支持至少与竞争系统相同的核心功能，并为那些将导致有人选择你的产品而不是其他人的独特功能提供良好的支持。那些不需要架构支持的基本功能通常不如深深嵌入系统中的核心功能有吸引力。
- en: '[Chapter 15](ch15.html "Chapter 15. SOFTWARE EVOLUTION OR SOFTWARE REVOLUTION?")'
  id: totrans-1415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章. 软件进化或软件革命？")'
- en: Mull It Over
  id: totrans-1416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深思熟虑
- en: '**What is the best metaphor for software growth?**'
  id: totrans-1417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**软件增长的最好隐喻是什么？**'
- en: There is none. In the immortal words of Forrest Gump, "Software is as software
    does." (Groom 94) Code construction has many correlations, yet no metaphor fully
    conveys its subtleties, just as you could never fully describe the beauty of a
    sunrise in words.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 没有答案。用福雷斯特·冈普（Forrest Gump）不朽的话说，“软件就是软件所做。”（Groom 94）代码构建有许多相关性，但没有任何隐喻能够完全传达其微妙之处，就像你永远无法用言语完全描述日出之美。
- en: Analogies can be misleading; software is a very different substance from any
    physical item, and building it is accordingly different. There are fewer physical
    constraints, and you can manipulate it in many more ways.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 类比可能会误导；软件与任何物理物品都大不相同，相应地，构建它的方式也不同。物理约束较少，你可以以更多的方式操纵它。
- en: There is a glimpse of truth in each metaphor. Learn what you can from them,
    but don't be tunneled into an incorrect view of software.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 每个隐喻中都有一些真理。从它们中学到你能学到的，但不要被引入对软件的错误看法。
- en: '**Looking at a program''s development through the colorful lifetime metaphor
    I talked about in the introduction, what Real World events correspond to a program''s**:'
  id: totrans-1421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过我在引言中提到的多彩的生命周期隐喻来看一个程序的发展，以下现实世界的事件与程序相对应**：'
- en: '**Conception**'
  id: totrans-1422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构思**'
- en: '**Birth**'
  id: totrans-1423
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出生**'
- en: '**Growth**'
  id: totrans-1424
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成长**'
- en: '**Coming of age**'
  id: totrans-1425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成熟**'
- en: '**Sending out into the Big Wide World**'
  id: totrans-1426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**送入广阔的世界**'
- en: '**Middle age**'
  id: totrans-1427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中年**'
- en: '**Growing tired**'
  id: totrans-1428
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变得疲惫**'
- en: '**Retirement**'
  id: totrans-1429
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退休**'
- en: '**Death**'
  id: totrans-1430
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死亡**'
- en: Although we've seen that metaphors are imperfect, investigating this one does
    teach us a lot about the lifetime of a software system. It's certainly not practical
    to try to place one developmental stage before the preceding steps—you can't release
    software until it has come of age. Well, you can, but the consequences are dire.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经看到隐喻并不完美，但研究这个隐喻确实教会了我们很多关于软件系统生命周期的知识。将一个发展阶段放在前面的步骤之前肯定是不切实际的——你不能在软件成熟之前发布它。好吧，你可以，但后果是严重的。
- en: '**Conception**'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '**构思**'
- en: The company observes an opening for a new product. The market requirements are
    established. The decision is made to build it.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 公司观察到新的产品机会。市场需求得到确定。决定开始构建它。
- en: '**Birth**'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '**出生**'
- en: A project is initiated to build the software. Designers and programmers are
    drafted in. An architecture is established. The code is started.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个项目来构建软件。设计师和程序员被征召。建立了一个架构。代码开始编写。
- en: '**Growth**'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '**成长**'
- en: The code develops, and the program matures. It becomes more and more functionally
    complete. Deadlines loom.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 代码发展，程序成熟。它变得越来越功能完善。截止日期临近。
- en: '**Coming of age**'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '**成熟**'
- en: Finally, the code is complete. It passes all tests to QA's satisfaction. It's
    considered a job well done, and hopefully it wasn't too far behind schedule.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码完成。它通过了所有测试，让QA满意。它被认为是一项很好的工作，希望它没有落后太多进度。
- en: '**Sending out**'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '**送出**'
- en: The program is released as version 1.0\. It successfully meets the market's
    needs.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以1.0版本发布。它成功满足了市场需求。
- en: '**Middle age**'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '**中年**'
- en: The program is heavily used by clients and has been deployed for some time.
    Now, several revisions later, it has accumulated extra functionality and a degree
    of bloating.
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序被客户广泛使用，并且已经部署了一段时间。现在，经过几次修订后，它积累了额外的功能，并且出现了一定程度的膨胀。
- en: '**Growing tired**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**变得疲惫**'
- en: Eventually, more nimble competition overtakes the program, with a greater feature
    set and better performance. No new customers choose our program, but existing
    customers clamor for upgrades. The software has become hard (even uneconomical)
    to extend.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，更敏捷的竞争者超越了该程序，拥有更丰富的功能和更好的性能。没有新的客户选择我们的程序，但现有客户纷纷要求升级。软件变得难以扩展（甚至不经济）。
- en: '**Retirement**'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '**退休**'
- en: 'Finally, the company decides to give up on development and cease support. It
    announces support is ending in *x* months: a formal *end-of-life* statement. Development
    stops, although some maintenance work continues.'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，公司决定放弃开发并停止支持。它宣布将在*x*个月后结束支持：一个正式的*生命终结*声明。开发停止，尽管一些维护工作仍在继续。
- en: '**Death**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**死亡**'
- en: 'We reach the inevitable: All development and maintenance stops. There is no
    longer anything offered by way of support. The world has moved on; soon, no one
    will remember what the program was called, let alone how to use it.'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不可避免地达到了：所有开发和维护都停止了。不再提供任何支持。世界已经前进；很快，没有人会记得这个程序的名字，更不用说如何使用它了。
- en: '**Is there a limit to software life—how long can you keep developing and working
    on a program before you have to start afresh?**'
  id: totrans-1450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**软件的生命有限吗——在必须从头开始之前，你可以持续开发和维护一个程序多久？**'
- en: This depends more on the market for the program than the quality of the software
    itself. Code can last indefinitely if it's well maintained and extended carefully.
    However, technologies go out of date rapidly, and trends change. Operating systems
    evolve quickly, hardware platforms become obsolete, and something that began as
    state-of-the-art, market-leading functionality will be given away for free a few
    years later. You must work hard to maintain the program's competitive advantage.
    Perhaps you'll have to continually add new functions, or port the software to
    new platforms.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多地取决于程序的市场，而不是软件本身的质量。如果代码维护得当并谨慎扩展，它可以无限期地存在。然而，技术迅速过时，趋势在变化。操作系统快速进化，硬件平台变得过时，而最初作为最先进、市场领先的功能，几年后可能会免费提供。你必须努力保持程序的竞争优势。也许你不得不不断添加新功能，或将软件移植到新平台。
- en: Open source software is not immune to these competitive and market-related issues;
    in some cases the problem is worse. There may be little or no money involved,
    but there is a still a real market with advancing technology, lower barriers to
    entry, and greater chances to switch products.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件并非对这些竞争和市场相关的问题免疫；在某些情况下，问题更严重。可能涉及的资金很少或没有，但仍然有一个真实的市场，技术不断进步，进入门槛较低，转换产品的机会更大。
- en: '**Does the size of a codebase correspond to the maturity of the project?**'
  id: totrans-1453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码库的大小是否与项目的成熟度相对应？**'
- en: No. On many occasions, I have vastly improved a system by *removing* code from
    it. Duplication can lead to massive code growth with little functional gain. The
    use of external libraries provides a lot of functionality without any discernible
    increase in project code size.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 不。在许多场合，我通过*从系统中移除代码*大大改进了系统。重复可以导致代码量大幅增长，而功能性收益却很少。使用外部库提供了很多功能，而项目代码的大小却几乎没有增加。
- en: Many people quote *lines of code* as a good measurement of development progress.
    Such metrics are useless unless interpreted correctly. This is merely a view of
    the *amount of code written*, not of its quality or the purity of its design.
    It is certainly not a measure of its functionality.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人引用*代码行数*作为衡量开发进度的好指标。除非正确解释，否则此类指标毫无用处。这仅仅是对*编写代码的数量*的看法，而不是其质量或其设计的纯粹性。这当然不是其功能性的衡量标准。
- en: '**How important is** backward compatibility **when maintaining code?**'
  id: totrans-1456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在维护代码时，向后兼容性有多重要？**'
- en: This depends on the individual project and how it has been deployed. More often
    than not, it is very important to retain backward compatibility when you change
    code—especially with regard to file formats, data structures, and communication
    protocols. Few applications can justifiably break this rule—only systems with
    small deployments and no need to store, retrieve, or communicate legacy data.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于具体项目和它的部署方式。通常情况下，当你更改代码时，保持向后兼容性非常重要——尤其是在文件格式、数据结构和通信协议方面。很少有应用程序可以合理地打破这条规则——只有那些部署规模小且不需要存储、检索或通信旧数据的系统。
- en: You should also consider *forward compatibility*. That is, designing code for
    extension and ensuring that future events will not render it inoperable. The Y2K
    bug is a good example of this rule being ignored, with expensive and potentially
    disastrous consequences.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该考虑*向前兼容性*。也就是说，设计代码以便扩展，并确保未来的事件不会使其无法运行。Y2K错误是忽视这一规则的一个很好的例子，它带来了昂贵且可能灾难性的后果。
- en: '**Is code likely to rot more quickly if you alter it or if you leave it alone?**'
  id: totrans-1459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**修改代码或让它保持原样，哪种情况代码更容易腐烂？**'
- en: Code rots quickest when you attempt to alter it. It's true that leaving a program
    to slowly stagnate will ensure your competitors gain an advantage, eventually
    rendering your code worthless. Your *product* will hear its death knell, but the
    *code* itself is as beautiful as it ever was.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图修改代码时，代码会最快地腐烂。确实，让一个程序慢慢停滞不前会确保你的竞争对手获得优势，最终使你的代码变得毫无价值。你的*产品*将听到它的丧钟，但*代码*本身仍然像以前一样美丽。
- en: Careless maintenance and sloppy extension will really cripple code. New faults
    are introduced all too easily as other problems are cleaned up. The pressure for
    rapid turnaround leads to modifications that degrade code clarity and structure.
    Maintaining code often renders it unmaintainable.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 粗心大意地维护和草率扩展真的会削弱代码。在清理其他问题时，新错误很容易被引入。快速周转的压力导致了对代码清晰度和结构的修改，这降低了代码的可维护性。
- en: It takes good programmers and informed project management to avoid this.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况需要优秀的程序员和明智的项目管理。
- en: Getting Personal
  id: totrans-1463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取个人
- en: '**Is the majority of the code you write brand new or a modification of existing
    source?**'
  id: totrans-1464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你写的代码主要是全新的还是对现有源代码的修改？**'
- en: '**If it''s brand-new code, do you create entirely new systems or new extensions
    to existing systems?**'
  id: totrans-1465
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果这是全新的代码，你是创建全新的系统还是对现有系统进行新的扩展？**'
- en: '**Does this affect** how **you write? In what ways?**'
  id: totrans-1466
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这会影响你的写作方式吗？在哪些方面？**'
- en: Different forces come into play in these different scenarios. When extending
    existing code or fitting new software into an old framework, you have to do a
    *lot* of investigation up front to understand how all the existing stuff works.
    If you don't, you'll end up writing bad code that doesn't fit in properly, causing
    headaches in the future.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些不同场景中，不同的力量会发挥作用。在扩展现有代码或将新软件适配到旧框架中时，你必须事先进行大量的调查，以了解所有现有内容是如何工作的。如果你不这样做，你最终会写出不合适的糟糕代码，这会在未来造成头疼。
- en: Brand-new code must be created with a view to future modification. It must be
    clear, extensible, and malleable to prevent such problems from cropping up later.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码必须考虑到未来的修改。它必须清晰、可扩展和可塑性，以防止以后出现此类问题。
- en: '**Do you have experience of working with preexisting codebases? If so**:'
  id: totrans-1469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否有与现有代码库一起工作的经验？如果有，**：'
- en: '**How has it shaped your current skill set? What lessons did you learn?**'
  id: totrans-1470
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这对你的当前技能组合有何影响？你学到了哪些教训？**'
- en: '**Was it predominantly good or bad code? What did you have to judge it against?**'
  id: totrans-1471
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码主要是好的还是坏的？你是如何判断的？**'
- en: A few years experience helps you to judge what's good software and what's bad.
    The telltale signs become clear, and you're able to quickly detect code that must
    be handled with care.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 几年的经验有助于你判断什么是好的软件，什么是坏的。明显的迹象变得清晰，你能够快速检测出必须小心处理的代码。
- en: Although vaguely masochistic, it can be good experience to work with someone
    else's trashy code—it teaches you what *not* to do, how one programmer's shortsightedness
    can make other programmer's lives painful later on. It helps you to appreciate
    the importance of taking responsibility for the code you write.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些自虐，但与别人的糟糕代码一起工作可以是一种好的体验——它教会了你不要做什么，一个程序员的短视如何会在未来让其他程序员的处境变得痛苦。这有助于你欣赏对自己所写代码负责的重要性。
- en: '**Have you ever made changes that degraded the quality of code? Why?**'
  id: totrans-1474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否曾经做出过降低代码质量的更改？为什么？**'
- en: 'Common reasons (or excuses) are:'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的原因（或借口）包括：
- en: I didn't know any better at the time.
  id: totrans-1476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我当时不知道更好的方法。
- en: I was pressed for time and had to ship the code quickly.
  id: totrans-1477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我当时时间紧迫，不得不快速发布代码。
- en: It was too much work to do any other way.
  id: totrans-1478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以其他方式做会花费太多精力。
- en: I could only modify code that was under *our* control—the problem was in another
    team's code or in third-party library code that we only had binaries for.
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我只能修改我们控制的代码——问题是出在另一个团队的代码或第三方库代码上，我们只有二进制文件。
- en: None of these reasons are satisfactory.
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因都不令人满意。
- en: For bonus points, come up with counter arguments against each of those excuses
    and find ways to avoid each situation. For example, if you're pressured to ship
    a code release quickly, you can make a simple hacky change now, and revise the
    work once the software is released to create a more engineered solution.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加分，提出针对每个这些借口的反论点，并找到避免每种情况的方法。例如，如果你被迫快速发布代码，你现在可以做出一个简单的快速修复，一旦软件发布，就可以在发布后修订工作，创建一个更工程化的解决方案。
- en: '**How many revisions has your current project gone through?**'
  id: totrans-1482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的当前项目经过了多少次修订？**'
- en: '**How much changed functionally between revisions? How did the code change?**'
  id: totrans-1483
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在修订之间，功能上发生了多少变化？代码是如何变化的？**'
- en: '**Has it grown by** luck, **by** design, **or something between the two? How
    is this evident now?**'
  id: totrans-1484
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它是通过运气、设计，还是两者之间的某种东西而成长的？现在这是如何体现的？**'
- en: Here are some important things to consider.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的事情需要考虑。
- en: The two are not necessarily connected. Even some very simple functional changes
    may require fundamental code rewrites. I've seen many projects where this was
    the case, where the system architecture didn't support future requirements and
    had to be radically altered.
  id: totrans-1486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两者不一定相关。即使是一些非常简单的功能更改也可能需要基本的代码重写。我见过很多项目就是这样，系统架构不支持未来的需求，不得不进行根本性的改变。
- en: 'And I''ve also seen the opposite: releases that were functionally identical
    to their predecessor, but where almost everything had changed under the covers.
    There is no point in performing a complete project rewrite if the system is spiraling
    toward its death, but when it has a viable commercial future and the current code
    cannot accommodate future requirements, such action may be justified.'
  id: totrans-1487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我也见过相反的情况：与前辈功能上完全相同，但内部几乎一切都发生了变化。如果系统正在螺旋式地向死亡发展，那么进行完整的项目重写是没有意义的，但如果它有一个可行的商业未来，并且当前的代码无法满足未来的需求，那么这样的行动可能是合理的。
- en: It might be commercial suicide to release a new version with no new features—customers
    will refuse to upgrade unless it's worth their while. Therefore, a few minor features
    tend to be thrown in as bait, or the revision is released with a certain amount
    of spin (i.e., *This revision includes significant bug fixes*).
  id: totrans-1488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果发布的新版本没有任何新功能，可能会是商业自杀——除非它值得客户升级，否则客户会拒绝升级。因此，通常会添加一些小的功能作为诱饵，或者修订版会带有一定的宣传（即，“这次修订包括重要的错误修复”）。
- en: You must know the history of your codebase to understand how it grew to this
    current shape and to be able to make informed modifications and appropriate tidy-ups.
  id: totrans-1489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须了解你的代码库的历史，才能理解它是如何发展到当前形态的，以及能够进行有见地的修改和适当的整理。
- en: '**How does your team safeguard code so that it can''t be changed by more than
    one programmer at once?**'
  id: totrans-1490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的团队是如何保护代码，使其不能被一个以上的程序员同时更改的？**'
- en: Employ a *revision control system* to manage code changes. Blocking file checkouts
    prevent more than one person from modifying a file at once. However, this is not
    enough. One change can be checked in with a contradictory change immediately following.
    You need to *manage* the development carefully, so that each developer with access
    to the source code understands what his or her peers are doing and who is responsible
    for making which changes. Code reviews help to detect and correct when this kind
    of problem has occurred.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 采用*版本控制系统*来管理代码更改。阻止文件签出可以防止多人同时修改文件。然而，这还不够。一个更改可以立即跟随一个相反的更改被检查入。你需要*仔细管理*开发过程，以便每个有权访问源代码的开发者都了解他们的同伴在做什么，以及谁负责做出哪些更改。代码审查有助于检测和纠正这种问题时发生的情况。
- en: A good suite of regression tests will ensure that any modification you make
    does not break functionality.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的回归测试套件将确保你做出的任何修改都不会破坏功能。
- en: '[Chapter 16](ch16.html "Chapter 16. CODE MONKEYS")'
  id: totrans-1493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第16章](ch16.html "第16章。代码猴子")'
- en: Mull It Over
  id: totrans-1494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**How many programmers** does **it take to change a light bulb?**'
  id: totrans-1495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**需要多少程序员才能更换一个灯泡？**'
- en: The question's wrong. It's a hardware problem, not a software one. Get the hardware
    engineers to fix it. Of course, the hardware engineers will want to work around
    the problem in software. . . .
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题错了。这是一个硬件问题，而不是软件问题。让硬件工程师来修复它。当然，硬件工程师会想通过软件来绕过这个问题……
- en: '**Is it better to be enthusiastic and less skilled (not incompetent) or to
    be incredibly talented and unmotivated?**'
  id: totrans-1497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是热情但技术不那么熟练（不是无能）的人更好，还是天才但缺乏动力的人更好？**'
- en: '**Who will write the better code?**'
  id: totrans-1498
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谁会编写更好的代码？**'
- en: '**Who is the better programmer? (Not the same thing.)**'
  id: totrans-1499
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪个程序员更好？（不是同一件事。）**'
- en: '**Which does more to shape the code you write: your technical competence or
    your attitude?**'
  id: totrans-1500
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**是什么塑造了你编写的代码：你的技术能力还是你的态度？**'
- en: 'There are various types of software systems, and the creation of each requires
    a different set of skills. That''s how programmers can carve out niches in embedded
    programming, web services, financial systems, and so on. The coding task also
    differs with the heritage of the code. You might write:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统有多种类型，每种类型的创建都需要不同的技能集。这就是程序员如何在嵌入式编程、网络服务、金融系统等领域中找到自己的位置。编码任务也会随着代码的遗产而有所不同。你可能会写：
- en: Simple "toy" programs
  id: totrans-1502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的“玩具”程序
- en: New systems from scratch
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从零开始的新系统
- en: Extensions of existing systems
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有系统的扩展
- en: Maintenance work on old codebases
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对旧代码库的维护工作
- en: Each task requires a different level of skill and discipline, and a very different
    development approach. We'll see this in the next question. Not every programmer
    who can write a personal "toy" can create a brand-new, industrial-strength system.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 每项任务都需要不同水平的技能和纪律，以及非常不同的开发方法。我们将在下一个问题中看到这一点。并不是每个能够编写个人“玩具”程序的开发者都能创建一个全新的、工业级的系统。
- en: For all of these, the quality of the resulting code is determined as much by
    your technical competence as your *attitude* regarding the task—indeed, the two
    must complement one another. If you lack some technical skills, then you must
    have an attitude that acknowledges this and compensates for it.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有这些，结果的代码质量不仅取决于你的技术能力，还取决于你对任务的**态度**——实际上，这两者必须相互补充。如果你缺乏某些技术技能，那么你必须有一种承认这一点并弥补它的态度。
- en: Your attitude can do more to shape the code you write than your current skill
    set can. If you're less skilled but desire to do a good job, then you're more
    likely to work well. You're also more likely to learn and to improve your skills.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 你的态度在塑造你编写的代码方面可能比你的当前技能集更有影响力。如果你技术不够熟练但渴望做好工作，那么你更有可能做得好。你也更有可能学习和提高你的技能。
- en: '**There are various different types of programs we write, differentiated by
    code "heritage." How does writing the following types of code differ?**'
  id: totrans-1509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们编写的程序类型多种多样，通过代码“遗产”来区分。编写以下类型代码有何不同？**'
- en: '**A "toy" program**'
  id: totrans-1510
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个“玩具”程序**'
- en: '**A brand-new system**'
  id: totrans-1511
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**全新的系统**'
- en: '**Extensions to an existing system**'
  id: totrans-1512
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对现有系统的扩展**'
- en: '**Maintenance work on an old codebase**'
  id: totrans-1513
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对旧代码库的维护工作**'
- en: It might not look like there's a great different between these code scenarios,
    but they require surprisingly different approaches.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码场景之间可能看起来没有太大区别，但它们需要惊人的不同方法。
- en: '**A toy program**'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个“玩具”程序**'
- en: This might be a small fun hack for your own use or a little utility to help
    develop a larger system. This program doesn't need to be bulletproof, have in-depth
    design, or have exhaustive features. It just needs to do enough to solve the immediate
    problem. Then it's thrown away.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个仅供你个人使用的小巧的趣味性黑客工具，或者是一个帮助开发更大系统的实用工具。这个程序不需要是万无一失的，不需要深入的设计，也不需要详尽的功能。它只需要足够解决当前问题即可。然后就被丢弃了。
- en: Speed and ease of development is probably more important than design elegance
    or the theological purity of the construction process.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 开发速度和易用性可能比设计优雅或构建过程的宗教纯洁性更重要。
- en: '**A new system**'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个新系统**'
- en: Creating a brand-new professional system from scratch requires serious design
    and careful planning. You must take into account future use and extensions, and
    ensure that the whole system is adequately documented.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建全新的专业系统需要严肃的设计和周密的规划。你必须考虑到未来的使用和扩展，并确保整个系统得到充分的文档化。
- en: '**Extensions**'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展**'
- en: Few projects create a new system from the ground up. More often, we extend existing
    code, adding new features to an old codebase. The new work must knit correctly
    into the existing system. This can't be done properly without a thorough understanding
    of the original code and the ability to make changes that sit well alongside existing
    work.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有项目是从头开始创建一个新系统。更常见的是，我们扩展现有代码，向旧代码库添加新功能。新工作必须正确地融入现有系统。没有对原始代码的彻底理解和做出与现有工作相协调的改变的能力，这是无法正确完成的。
- en: '**Maintenance**'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护**'
- en: The most common software activity is the maintenance of existing code, fixing
    any remaining faults, and ensuring that it remains operational as the world around
    it changes. This needs a careful methodical approach. It probably requires a lot
    of exploratory work; it will stretch your deductive powers since few systems are
    ever documented well enough to easily maintain, especially as they grow old and
    near obsolescence.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的软件活动是对现有代码的维护，修复任何剩余的错误，并确保它在周围世界变化时保持运行。这需要谨慎的方法论。这可能需要大量的探索性工作；它将考验你的演绎能力，因为很少有系统被充分地文档化，以便轻松维护，尤其是当它们变得陈旧并接近淘汰时。
- en: '**If programming is an art, what is the correct balance of consideration and
    planning versus intuition and gut instinct? Do you program by gut or by plan?**'
  id: totrans-1524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果编程是一门艺术，那么考虑和计划的正确平衡与直觉和直觉之间的平衡是什么？你是通过直觉还是通过计划来编程？**'
- en: As we've seen, effective programmers use both approaches. Intuition and the
    artist's aesthetic sensibilities will help craft elegant code. Thoughtful planning
    works alongside to ensure the code is sound, pragmatic, and delivered on time.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，有效的程序员使用这两种方法。直觉和艺术家的审美感有助于编写优雅的代码。周密的规划与之并行，以确保代码是可靠的、实用的，并且按时交付。
- en: We can't formulate an exact ratio or formula for the optimum balance. Effective
    programmers have both and know how to moderate the use of each.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法制定一个精确的比例或公式来达到最佳平衡。有效的程序员两者兼备，并且知道如何适度地使用每种方法。
- en: '[Chapter 17](ch17.html "Chapter 17. TOGETHER WE STAND")'
  id: totrans-1527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第17章](ch17.html "第17章。我们站在一起")'
- en: Mull It Over
  id: totrans-1528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Why write software in teams? What are the real advantages over writing a
    system on your own?**'
  id: totrans-1529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么要在团队中编写软件？与独自编写系统相比，真正的优势是什么？**'
- en: Software development might be easier on your own; you don't have to work with
    other weird programmers, you don't need to coordinate work or suffer ineffective
    management. However, it isn't hard to see the many benefits of software development
    in teams.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发可能更易于个人进行；你不必与其他古怪的程序员合作，你不需要协调工作或忍受无效的管理。然而，不难看到团队合作在软件开发中的许多好处。
- en: In a team you can solve larger problems by decomposing them between individual
    members. And you can create code faster too. Groups of developers combine talents
    to make something greater than the sum of their parts. In cases where there is
    no well-established design or prior art, the wider skill set and knowledge of
    the group has a distinct advantage; a collaborative approach will filter ideas
    and generate better solutions. Peer reviews ensure that work is sound.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中，你可以通过将问题分解给个人成员来解决更大的问题。你还可以更快地编写代码。开发者群体结合才能，创造出大于其各部分总和的东西。在没有良好建立的设计或先例的情况下，团队的更广泛技能和知识具有明显优势；协作方法将筛选想法并产生更好的解决方案。同行评审确保工作质量。
- en: 'There is also a personal motivation: Techies like working on cool projects.
    You can work on systems well beyond your own ability when developing in a team.
    This might be software that is much larger than an individual could tackle, which
    requires specialized skills, or that provides the chance to work alongside more
    experienced programmers.'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 还有个人动机：技术人员喜欢参与酷项目。在团队开发中，你可以参与远远超出你自身能力的系统。这可能是一个单个个体无法应对的、需要专业技能的软件，或者提供了一个与更有经验的程序员一起工作的机会。
- en: In a Real World organization, even a lone developer is part of a larger team.
    If you're not working with other software developers, you are still part of a
    corporate team, working to create a final polished product. Without those other
    people, your software would never be released.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的组织中，即使是单独的开发者也是更大团队的一部分。如果你没有与其他软件开发者合作，你仍然属于一个企业团队，致力于创建一个最终精良的产品。没有这些人，你的软件永远不会发布。
- en: '**Describe the telltale signs of good and bad teamwork. What are the prerequisites
    for good teamwork, and what characterizes bad teamwork?**'
  id: totrans-1534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**描述良好和不良团队合作的明显迹象。良好团队合作的先决条件是什么，不良团队合作的特点是什么？**'
- en: 'For effective teamwork, all of these factors must be in place:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效的团队合作，所有这些因素都必须到位：
- en: The correct spread of people, with a range of appropriate technical skills.
  id: totrans-1536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人员分布要适当，具有各种合适的技术技能。
- en: Team members with a range of experience, who are each able to learn from others.
    A whole team of trainees will clearly be very unlikely to succeed. (However, they'd
    be much easier to mold and manage than a bunch of Demigurus who are far more set
    in their ways.)
  id: totrans-1537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员具有各种经验，每个人都能从他人那里学习。一个由实习生组成的整个团队显然不太可能成功。（然而，他们比那些固执己见的半神半人更容易塑造和管理。）
- en: Team member personality types must be complementary. To succeed, the team needs
    encouragers and motivators, not people who will drag morale down.
  id: totrans-1538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员的性格类型必须互补。为了成功，团队需要激励者和鼓舞人心的人，而不是那些会拖垮士气的人。
- en: A clear and realistic goal (even better if it's an exciting project that the
    team members really want to see completed).
  id: totrans-1539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个清晰且现实的目标（如果它是一个团队成员真正希望看到完成的项目那就更好了）。
- en: Motivation (whether financial or emotional).
  id: totrans-1540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动机（无论是财务的还是情感的）。
- en: Suitable specifications provided as soon as possible, so all members understand
    what they are building and to ensure that the individual pieces of work fit together.
  id: totrans-1541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽快提供合适的规范，以便所有成员都了解他们正在构建的内容，并确保各个部分的工作能够配合。
- en: Good management.
  id: totrans-1542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的管理。
- en: 'As small a team as realistically possible, but no smaller. Adding more people
    makes teamwork harder: There are more lines of communication, more people to coordinate,
    and more points of failure. We should try not to make things unnecessarily difficult.'
  id: totrans-1543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能小但不少于人的团队。增加人员会使团队合作变得更难：有更多的沟通线路，更多的人需要协调，以及更多的失败点。我们应尽量避免使事情变得不必要地困难。
- en: A clear and universally understood software engineering process for the team
    to follow.
  id: totrans-1544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个清晰且被团队普遍理解的软件工程流程，供团队遵循。
- en: Backing from the company, not hindrances and unnecessary bureaucracy.
  id: totrans-1545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自公司的支持，而不是阻碍和不必要的官僚主义。
- en: 'In contrast, these are sure indicators of a team that is not able to work effectively.
    Note that this list includes a mix of internal and external factors:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这些都是一个无法有效工作的团队的确定指标。请注意，这个列表包括内部和外部因素的混合：
- en: Unrealistic schedules with deadlines established before the team has scoped
    their work.
  id: totrans-1547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不切实际的进度安排，截止日期在团队确定工作范围之前就已经设定。
- en: Unclear project objectives and a lack of project requirements.
  id: totrans-1548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目目标不明确和缺乏项目需求。
- en: Communication failures.
  id: totrans-1549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沟通失败。
- en: Bad or unqualified team leaders.
  id: totrans-1550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕或不合格的团队领导。
- en: Badly defined individual roles and responsibilities—who's responsible for doing
    what?
  id: totrans-1551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊不清的个人角色和责任——谁负责做什么？
- en: Individual bad attitudes and personal agendas.
  id: totrans-1552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人不良态度和个人议程。
- en: Incompetent team members.
  id: totrans-1553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不称职的团队成员。
- en: Management not valuing individual engineers, and treating them like minions
    instead.
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理层不重视个人工程师，而是将他们视为仆人。
- en: Individual appraisals based on criteria that don't match the team objectives.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于不符合团队目标的标准的个人评估。
- en: Rapid turnover of team members.
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员快速更替。
- en: No change in management procedure.
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理程序没有变化。
- en: A lack of training or mentoring.
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏培训或指导。
- en: '**Compare software teamwork with the construction metaphor (see "[DO WE REALLY
    BUILD SOFTWARE?](ch10.html#do_we_really_build_software_question "DO WE REALLY
    BUILD SOFTWARE?")" on page 177). Does it reveal insights into our teamwork?**'
  id: totrans-1559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将软件团队合作与建筑隐喻进行比较（参见第177页的"[我们真的在构建软件吗？](ch10.html#do_we_really_build_software_question
    "我们真的在构建软件吗？")"）。这揭示了我们对团队合作的洞察吗？**'
- en: There are a number of different metaphors that can be used to describe our work
    (for example, DeMarco's *sports team* or *choral society* and the *factory* we
    joke about here). (DeMarco 99) The problem with any metaphor is that it can only
    tell a partial truth. Software engineering has its own problems and challenges.
    Chemical engineering is different from civil engineering, which is different from
    making a movie, which is different from writing software.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的隐喻可以用来描述我们的工作（例如，DeMarco的*运动队*或*合唱团*以及我们在这里开玩笑的*工厂*）。（DeMarco 99）任何隐喻的问题在于它只能讲述部分真理。软件工程有其自身的问题和挑战。化学工程与土木工程不同，土木工程与制作电影不同，制作电影与编写软件不同。
- en: 'While not perfect, *building construction* is a useful metaphor. After all,
    we construct software according to a plan, from different components (some of
    which we build ourselves, others which we buy or bring in). These are the useful
    parallels:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不完美，但*建筑建设*是一个有用的隐喻。毕竟，我们根据计划构建软件，从不同的组件（其中一些是我们自己构建的，其他的是我们购买的或引入的）。这些是有用的类比：
- en: 'You need a team: You can''t single-handedly build a skyscraper or an enterprise-level
    highly complex software superstructure.'
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要一个团队：你不能单枪匹马建造摩天大楼或企业级高度复杂的软件超结构。
- en: 'The team has a goal: It works to finish the construction on time and on budget.'
  id: totrans-1563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队有一个目标：它致力于按时按预算完成建设。
- en: 'Someone commissions the work, for a purpose: There is an end-purpose for the
    work.'
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人委托工作，出于某种目的：这项工作有一个最终目的。
- en: 'Each team member does something different: Different roles help to get the
    job done. There are architects, builders, carpenters, plumbers, electricians,
    foremen, office staff, security guards, and more. Each makes a valuable contribution.'
  id: totrans-1565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个团队成员都做不同的事情：不同的角色有助于完成工作。有建筑师、建造者、木匠、水管工、电工、工头、办公室工作人员、保安等等。每个人都做出了宝贵的贡献。
- en: 'There are team members with responsibility: The foreman is the people manager.'
  id: totrans-1566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有责任感的团队成员：工头是人员管理者。
- en: But of course, buildings are very different from programs. Buildings can't be
    developed in an iterative and incremental manner. Any change to a building's specification
    will result in costly demolition prior to rebuilding. In our world of pure thought
    stuff, we can tear down and rebuild with very little material cost (but with the
    costs of time and labor). In software, we are better able to build abstract interfaces
    between blocks. The engineering discipline is different, but that doesn't mean
    we can't learn from the parallels with other professions.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，建筑与程序非常不同。建筑不能以迭代和增量方式开发。对建筑规格的任何更改都将在重建之前导致昂贵的拆除。在我们的纯粹思想领域，我们可以以极低的材料成本（但有时间成本和劳动成本）进行拆除和重建。在软件中，我们更有能力在块之间构建抽象接口。工程学科不同，但这并不意味着我们不能从与其他职业的类比中学习。
- en: '**Will external or internal factors do the most to ruin the effectiveness of
    a software development team?**'
  id: totrans-1568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**外部或内部因素哪个最有可能破坏软件开发团队的有效性？**'
- en: 'They''ll both conspire to destroy your development work. Internal factors like:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都会密谋破坏你的开发工作。内部因素如：
- en: Ineffective team members
  id: totrans-1570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的团队成员
- en: Conflict
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲突
- en: Confusion
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混乱
- en: Show-stopping bugs late in development
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发后期出现的严重错误
- en: Inaccurate plans
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不准确的计划
- en: 'Mix with external factors like:'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部因素混合，如：
- en: Unclear or shifting requirements
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不明确或不断变化的需求
- en: Unrealistic deadlines
  id: totrans-1577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不切实际的截止日期
- en: Bad management
  id: totrans-1578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不善
- en: Corporate bureaucracy
  id: totrans-1579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业官僚主义
- en: This makes the life of a software developer incredibly difficult. Internal and
    external pressures are equally likely to destroy your teamwork, although it's
    widely recognized that most projects fail for nontechnical reasons.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得软件开发者的生活极其困难。内部和外部压力同样可能破坏你的团队合作，尽管普遍认为大多数项目失败的原因是非技术性的。
- en: 'One thing is certain: There are far more detrimental influences on team performance
    than there are success factors. For this reason, you must guard your team''s work
    closely, attempting to insulate yourself from both internal and external attacks.'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 一件事是肯定的：对团队绩效产生负面影响的影响因素比成功因素要多得多。因此，你必须密切保护团队的工作，试图使自己免受内部和外部攻击。
- en: '**How does a team''s size affect the team dynamics?**'
  id: totrans-1582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**团队规模如何影响团队动态？**'
- en: With more people, the team members suffer increased
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 随着人数的增加，团队成员承受的压力也增加
- en: Coordination effort
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调努力
- en: Communication effort (more people introduce more separate paths of communication;
    this grows exponentially)
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沟通努力（更多的人引入更多的独立沟通路径；这呈指数增长）
- en: Cooperation effort
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作努力
- en: Dependency on others (direct and indirect)
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖他人（直接和间接）
- en: Each of these *can* make your work harder. However, it's clear that a team of
    programmers can produce greater software than a single coder. This means that
    there must be an appropriate balance of team size versus size of task; this will
    change depending on the kind of system being developed.
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*都可能*使你的工作更难。然而，很明显，一个程序员团队可以比单个程序员产生更优秀的软件。这意味着团队规模与任务规模之间必须有一个适当的平衡；这会根据正在开发的系统类型而变化。
- en: As a team gets bigger, there is more likelihood that individual programmers
    will slacken the effort they put in, since they can be carried by the rest of
    the team. Brooks's *The Mythical Man-Month* shows that adding people to a project
    does not necessarily make it complete sooner. (Brooks 95)
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队规模的扩大，程序员个人可能会放松他们的努力，因为他们可以被团队的其他成员支持。布鲁克斯的《神话般的程序员月》表明，向项目中添加人员并不一定能使项目更快完成。（布鲁克斯
    95）
- en: With a larger project, there is more chance that management talent will differentiate
    success from failure and more scope for management to provoke catastrophic failure.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的项目中，管理层更有可能区分成功与失败，管理层有更大的空间引发灾难性的失败。
- en: In general, smaller development teams are better; but they must still be large
    enough to accomplish the task.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，较小的开发团队更好；但它们必须足够大以完成这项任务。
- en: '**How can you insulate a team from problems caused by inexperienced members?**'
  id: totrans-1592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何使团队免受缺乏经验的成员造成的问题的影响？**'
- en: There will always be inexperienced programmers. This is the same in any field
    of endeavor. In many professions, new recruits undergo some form of apprenticeship
    period and must complete a stage of academic study. This ensures that their skills
    are already honed to a reasonable level. Although ripe with academic programming
    courses (of varying quality), our software profession doesn't recognize any formal
    form of apprenticeship. Mentoring new programmers is a fantastic way to quickly
    bring fresh recruits to a reasonable standard.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 总会有缺乏经验的程序员。这在任何努力领域都是如此。在许多职业中，新员工会经历某种形式的学徒期，并必须完成学术研究阶段。这确保了他们的技能已经磨练到合理的水平。尽管我们的软件行业充满了各种质量的学术编程课程，但我们的软件行业并不承认任何正式的学徒形式。指导新程序员是一种快速将新员工提升到合理标准的方法。
- en: 'A few techniques contribute to making inexperienced coders'' work less risky:'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 一些技术有助于降低缺乏经验的程序员工作的风险：
- en: Have realistic expectations; don't expect miracles from them. Allot trainees
    appropriate tasks.
  id: totrans-1595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持现实的期望；不要期望他们能创造奇迹。为实习生分配适当的工作。
- en: Monitor their progress, and ensure they aren't afraid to raise questions and
    problems.
  id: totrans-1596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控他们的进度，并确保他们不害怕提出问题和问题。
- en: 'Don''t require too much prior experience: Use popular languages and tools that
    will require less time to get up-to-speed.'
  id: totrans-1597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要要求太多的先前经验：使用流行的语言和工具，这将需要更少的时间来熟悉。
- en: Don't use bleeding edge technologies and techniques.
  id: totrans-1598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用前沿技术和技术。
- en: Standardize tools across teams so trainees only need to learn a toolset once.
  id: totrans-1599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在团队间标准化工具，以便学员只需学习一次工具集。
- en: Train them.
  id: totrans-1600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培训他们。
- en: Review their code.
  id: totrans-1601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查他们的代码。
- en: Mentor them.
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培养他们。
- en: Pair program with them.
  id: totrans-1603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与他们结对编程。
- en: Getting Personal
  id: totrans-1604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**What kind of team are you working in right now? Which of the stereotypes
    on pages 322 through 332 is it most like?**'
  id: totrans-1605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你现在在哪个团队工作？322至332页上的哪些刻板印象最像它？**'
- en: '**Is it like this by design?**'
  id: totrans-1606
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是否是设计上的？**'
- en: '**Is it a healthy team?**'
  id: totrans-1607
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这是一个健康的团队吗？**'
- en: '**Does it need to be changed?**'
  id: totrans-1608
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是否需要改变？**'
- en: '**What factors have you encountered that prevent good teamwork?**'
  id: totrans-1609
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**你遇到了哪些因素阻碍了良好的团队合作？**'
- en: '**If you haven''t done so already, fill out the earlier action sheet carefully
    (see "[Action Sheet](ch17s10.html "Action Sheet")" on page 347). Make sure you
    work out how to improve your team and start to make the changes**.'
  id: totrans-1610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**如果你还没有这样做，请仔细填写早期的行动清单（见第347页的"[行动清单](ch17s10.html "行动清单")"）。确保你制定出如何改进团队并开始做出改变的方法**。'
- en: Work out how you will carry out any required changes. Set goals and review the
    team's health in a few months' time.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 制定如何执行任何必需变更的计划。设定目标，并在几个月后审查团队的健康状况。
- en: 'Common team problems include:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的团队问题包括：
- en: Unbalanced team composition
  id: totrans-1613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队构成不平衡
- en: Ineffective team members
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的团队成员
- en: Bad management
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理不善
- en: Unrealistic deadlines
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不切实际的截止日期
- en: Shifting requirements
  id: totrans-1617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整需求
- en: Communication failure
  id: totrans-1618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沟通失败
- en: '**Are you a good team player? How could you work better with your teammates
    and build better software?**'
  id: totrans-1619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是一个好的团队成员吗？你如何与你的团队成员更好地合作并构建更好的软件？**'
- en: Look again at the personal characteristics in "[Personal Skills and Characteristics
    for Good Teamwork](ch17s05.html "Personal Skills and Characteristics for Good
    Teamwork")" on page 333\. Determine how closely you model each of these and how
    you can improve.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看第333页的"[良好的团队合作所需个人技能和特点](ch17s05.html "良好的团队合作所需个人技能和特点")"中的个人特点。确定你与每个特点的匹配程度以及你可以如何改进。
- en: '**What is the exact responsibility of a software engineer on your current team?**'
  id: totrans-1621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你当前团队中软件工程师的职责是什么？**'
- en: How much responsibility and authority does a software developer have? Are there
    several ranks of programmer job titles—if so, how do these roles differ? Does
    a development role involve any of the following activities?
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发人员有多少责任和权限？是否有几个程序员职位等级——如果是这样，这些角色有何不同？开发角色是否涉及以下任何活动？
- en: Forming the project scope and objectives
  id: totrans-1623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定项目范围和目标
- en: Analysis
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析
- en: Estimating timescales
  id: totrans-1625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估算时间表
- en: Architecture
  id: totrans-1626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: Design
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计
- en: Review
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查
- en: Project management
  id: totrans-1629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目管理
- en: Being a mentor
  id: totrans-1630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为导师
- en: Investigating and implementing performance
  id: totrans-1631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查和实施绩效
- en: Documentation
  id: totrans-1632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Integrating systems
  id: totrans-1633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统集成
- en: Testing (to what level?)
  id: totrans-1634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（到什么程度？）
- en: Interaction with the customer
  id: totrans-1635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与客户的互动
- en: Planning enhancements or the next software revision
  id: totrans-1636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划增强功能或下一个软件版本
- en: This detail will differ from company to company and from project to project.
    Are there clear lines of accountability in your team? Are there technical and
    pastoral managers to whom developers are assigned?
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 这个细节会因公司而异，也会因项目而异。你的团队是否有明确的问责制？是否有技术和管理牧师，开发者被分配给他们？
- en: Do you have a job description? Do you have a set of personal objectives? If
    so, are you fulfilling them right now, or are they actually incorrect?
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 你有工作描述吗？你有个人目标吗？如果有，你现在是否正在实现它们，或者它们实际上是不正确的？
- en: '[Chapter 18](ch18.html "Chapter 18. PRACTICING SAFE SOURCE")'
  id: totrans-1639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章。实践安全源代码")'
- en: Mull It Over
  id: totrans-1640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**How can you reliably release your source code to other people?**'
  id: totrans-1641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何可靠地向其他人发布源代码？**'
- en: The easiest option for proprietary source code is *not* to release it—then you'll
    avoid all sorts of problems. If you must ship code, don't forget to sort out licensing
    and get NDAs in place first. Know the size and extent of your audience and, if
    it's important to you, take measures to ensure that the code doesn't leak further
    afield.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 对于专有源代码，最简单的方法是*不*发布它——这样你就可以避免所有问题。如果你必须发布代码，不要忘记整理许可并首先获得保密协议。了解你的受众规模和范围，如果你认为这很重要，采取措施确保代码不会进一步泄露。
- en: For open source projects, this is not such a big concern; by their nature, they
    ship as source.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源项目，这并不是一个大问题；根据其本质，它们以源代码的形式发布。
- en: Before release, make sure that there are clear copyright and license notices
    in every source code file.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布之前，确保每个源代码文件中都有清晰的版权和许可声明。
- en: 'There are several mechanisms for a source code release, with differing abilities
    to guard against your code getting into the wrong hands:'
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 存源代码发布有几种机制，它们在防止你的代码落入错误之手的能力上有所不同：
- en: Allow the external viewer to have access to your source control system. You
    can lock this down through an account that is granted read-only access, possibly
    using a shared *anonymous* account if your code is publicly available.
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许外部查看者访问你的源控制系统。你可以通过授予只读访问权限的账户来限制访问，如果你的代码是公开的，可能使用一个共享的*匿名*账户。
- en: Obviously, to see your VCS server, users must have some level of privilege and
    network access to your development environment, so this must be closely managed—both
    so that they don't do anything untoward and so that crackers can't get in to look
    at your code.
  id: totrans-1647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，要查看你的版本控制系统，用户必须具有一定的权限和网络访问你的开发环境，因此这必须得到严格控制——既是为了防止他们做出不当行为，也是为了防止黑客入侵查看你的代码。
- en: '*Tarball* the source tree (create a compressed archive of files—this term is
    named after Unix''s `tar` command). This tarball can be emailed, FTPed, or sent
    on a CD. Ensure that your method of dispatch is appropriately secure.'
  id: totrans-1648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源树*打包成tarball*（创建一个文件的压缩存档——这个术语是以Unix的`tar`命令命名的）。这个tarball可以通过电子邮件、FTP发送或刻录到CD上。确保你的分发方式是适当安全的。
- en: Include a set of release notes with your code, and clearly display the source
    tree revision information (usually a source control version or build number) for
    later reference. Mark the released code in your source control repository with
    a label so that you can retrieve it at a later date.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中包含一组发布说明，并清楚地显示源树修订信息（通常是一个源控制版本号或构建号），以便日后参考。在你的源控制仓库中用标签标记已发布的代码，这样你就可以在以后检索它。
- en: '**Of the two models for repository file editing (locking file checkouts or
    concurrent modification), which is best?**'
  id: totrans-1650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在仓库文件编辑的两个模型（锁定文件签出或并发修改）中，哪个更好？**'
- en: Neither model of operation is better or worse than its counterpart. Each hides
    different file editing problems and forces users to work differently when modifications
    might collide.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 两种操作模型都没有比对方更好或更差。每种模型都隐藏了不同的文件编辑问题，并在修改可能冲突时迫使用户以不同的方式工作。
- en: The locking model requires you to check out a file to reserve it before making
    any modifications. You can be sure that no other developer's change will interfere
    with your work and that you have sole access to that file until you check it back
    in or release the file unchanged. The downside is that a reserved file is blocked
    until the owner has relinquished control. You have no immediate way of knowing
    how long this will take.
  id: totrans-1652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定模型要求你在进行任何修改之前签出一个文件以保留它。你可以确信没有其他开发者的更改会干扰你的工作，并且在你签回或发布未更改的文件之前，你有对该文件的唯一访问权。缺点是保留的文件在所有者放弃控制之前会被阻塞。你无法立即知道这需要多长时间。
- en: If the owner sits at the desk next to you, then it's annoying but not hard to
    work out. However, if the owner is on another continent, works different hours,
    or accidentally leaves the file checked out while on vacation, then you're stuck.
    The best you can do is subvert the checkout by fiddling with the owner's computer
    to release the file. This will undoubtedly cause hassle and confusion later.
  id: totrans-1653
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有者坐在你旁边的桌子上，那么这很烦人，但并不难解决。然而，如果所有者在另一个大陆，工作时间不同，或者在度假期间意外地将文件签出，那么你就陷入了困境。你能做的最好的事情就是通过篡改所有者的电脑来撤销签出，以释放文件。这无疑会带来麻烦和混乱。
- en: The concurrent model avoids this problem and ensures that you can continue coding
    unhindered at all times. The hidden danger is the possibility of conflicting file
    modifications. If Fred alters lines 10 through 20 of `foo.c`, while George alters
    lines 15 through 25, a race is on! The first developer to check in the file won't
    have any problems, so if Fred wins, his work on lines 10 through 20 will be put
    into the repository. But when George tries to check in, the SCMS will tell him
    that his source tree is out of date—he has to merge Fred's change into his copy
    of `foo.c` first. The five conflicting lines will need to be merged manually;
    George must do extra work to understand Fred's change and integrate it with his
    own. Only then can he check his work in.
  id: totrans-1654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模型避免了这个问题，并确保你可以在任何时候无障碍地继续编码。隐藏的危险是可能发生冲突的文件修改。如果弗雷德修改了`foo.c`的第10到20行，而乔治修改了第15到25行，那么就会有一场竞争！第一个检查文件的开发者不会遇到任何问题，所以如果弗雷德赢了，他对第10到20行的修改将被放入仓库。但当乔治尝试检查时，SCMS会告诉他他的源树已经过时——他必须首先将弗雷德的更改合并到他的`foo.c`副本中。需要手动合并的五条冲突行；乔治必须额外工作来理解弗雷德的更改并将其与自己的工作集成。只有在这种情况下，他才能检查自己的工作。
- en: This isn't ideal, but it happens very rarely in reality, and most conflicts
    are not at all contentious. The more common case is when Fred modifies lines 10
    through 20 and George modifies lines 40 through 50; the two modifications don't
    conflict and the SCMS can merge the changes automatically. If you do encounter
    conflicting concurrent modifications, it's often a sign that the code needs some
    refactoring.
  id: totrans-1655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这并不理想，但在现实中这种情况很少发生，而且大多数冲突根本不是有争议的。更常见的情况是，当弗雷德修改第10到20行，乔治修改第40到50行时；这两个修改不冲突，SCMS可以自动合并更改。如果你遇到冲突的并发修改，这通常是一个迹象，表明代码需要一些重构。
- en: Neither mode of operation is perfect; but each works fine. Which you choose
    depends on the operation of your source control tool and the development process
    and culture you work in.
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 两种操作模式都不完美；但每种都工作得很好。你选择哪种取决于你的源控制工具的操作、你工作的开发过程和文化。
- en: '**How do the requirements for version control systems differ between a distributed
    and a single-site development team?**'
  id: totrans-1657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分布式和单个站点开发团队对版本控制系统的要求有何不同？**'
- en: 'If a SCMS can accommodate remote sites, it will definitely be able to cope
    with a single-site development team, so we''re mostly considering a set of *extra*
    requirements for multisite operation. These extra requirements include:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SCMS可以容纳远程站点，它肯定能够应对单个站点的开发团队，所以我们主要考虑的是多站点操作的一组额外要求。这些额外要求包括：
- en: There must be a scaleable client/server architecture.
  id: totrans-1659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一个可扩展的客户/服务器架构。
- en: The tool must work effectively over low-bandwidth network links (which are common
    for satelite sites), *or* your deployment must include a really high-quality intersite
    connection. Low-bandwidth links require intelligent data compression and sensible
    communications protocols (for example, the tools should send small file differences,
    rather than entire files).
  id: totrans-1660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具必须在低带宽网络链路上有效工作（这对于卫星站点来说很常见），或者你的部署必须包括一个真正高质量的低带宽网络链路。低带宽链路需要智能数据压缩和合理的通信协议（例如，工具应该发送小的文件差异，而不是整个文件）。
- en: There must be a centralized method to administer user accounts so that collaboration
    is seamless across sites.
  id: totrans-1661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一种集中化的方法来管理用户账户，以便跨站点协作无缝进行。
- en: 'There are two main designs: wide area network communication and remote repository
    replication. The first performs all client communication with a central server
    hosted at the parent location. This requires a sufficiently fast and reliable
    communication channel between sites. The latter method reduces communication overhead
    by replicating the repository onto a remote server at low-load times. However,
    this adds a lot complication to the development process; you need to understand
    that the two repositories are not costantly synchronized, and you must work out
    sensible branching strategies to avoid conflicting lines of development work.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要设计：广域网通信和远程仓库复制。第一种在父位置托管的一个中央服务器上与所有客户端进行通信。这需要在站点之间有一个足够快且可靠的通信通道。后者通过在低负载时间将仓库复制到远程服务器来减少通信开销。然而，这给开发过程增加了很多复杂性；你必须理解这两个仓库不是始终同步的，你必须制定合理的分支策略来避免冲突的开发工作。
- en: When evaluating source control systems, don't ignore these requirements, even
    if you only have one development site. In the future, you may need to add a secondary
    site or support for telecommuters. Bear this in mind as you scope your system.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估源代码控制系统时，不要忽略这些要求，即使您只有一个开发站点。将来，您可能需要添加一个辅助站点或支持远程工作者。在规划系统时请记住这一点。
- en: '**What is a sound rationale for selecting a source code management system?**'
  id: totrans-1664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择源代码管理系统的合理理由是什么？**'
- en: 'Good criteria for selecting a SCMS include:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 选择SCMS的良好标准包括：
- en: '**Reliability**'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠性**'
- en: Check that it is proven technology and won't suddenly lose your source files.
    The server must be robust and not prone to crashing every few days.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它是经过验证的技术，不会突然丢失您的源文件。服务器必须健壮，不会每隔几天就崩溃。
- en: '**Capacity**'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: '**容量**'
- en: The tool must scale up well, handling large teams and large projects as well
    as small ones. In more demanding situations, does it consume a lot of disk space,
    soak up all network bandwidth, or take an excruciating time to run? Perhaps you
    require multisite repository synchronization, or does it work well enough on a
    low-bandwidth link?
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 工具必须很好地扩展，能够处理大型团队、大型项目和小型项目。在更苛刻的情况下，它是否消耗大量磁盘空间，耗尽所有网络带宽，或者运行时间过长？也许您需要多站点存储库同步，或者它是否在低带宽链路上运行良好？
- en: '**Flexibility**'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: '**灵活性**'
- en: Does it provide all the operations and reports that you need? Does it handle
    all the filetypes that you want to control? Can it manage binary files? Does it
    support Unicode? Does it version directories, allowing the renaming and moving
    of files? Does it manage atomic change sets, or is each file individually versioned?
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否提供了您需要的所有操作和报告？它是否处理您想要控制的文件类型？它能否管理二进制文件？它是否支持Unicode？它是否对目录进行版本控制，允许重命名和移动文件？它是否管理原子更改集，或者每个文件都是单独版本化的？
- en: '**Branching**'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '**分支**'
- en: To support more than one release, product variants, concurrent feature work,
    or to help with logical development, the tool *must* support branching. Does it
    support sub-branches? Is merging easy, or is it prohibitively difficult?
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个版本、产品变体、并发功能工作或帮助逻辑开发，该工具*必须*支持分支。它支持子分支吗？合并是否容易，或者是否难以承受？
- en: '**Platforms**'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台**'
- en: Make sure that it works on all the platforms, hardware configurations, and operating
    systems that you work with.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 确保它在您工作的所有平台、硬件配置和操作系统上都能正常工作。
- en: '**Costs and licensing**'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本和许可**'
- en: The SCMS must meet your budget constraints (remember, there are some *very*
    free source systems). Consider whether there are extra license costs per client.
    Sometimes these are hidden extra costs; as your team grows, you must pay an SCMS
    tax.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: SCMS必须满足您的预算限制（记住，有一些*非常*免费的源代码系统）。考虑是否有额外的按客户端计费的许可费用。有时这些是隐藏的额外费用；随着团队的增长，您必须支付SCMS税。
- en: '**Audit**'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: '**审计**'
- en: 'The repository must record who makes each change: Don''t force everyone into
    one SCMS user account. The system must support your access policies, allowing
    you to restrict modification rights as required. Do you want it to provide automatic
    notification of changes?'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库必须记录谁进行了每次更改：不要强迫每个人都使用一个SCMS用户账户。系统必须支持您的访问策略，允许您根据需要限制修改权限。您希望它提供更改的自动通知吗？
- en: '**Simplicity**'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单性**'
- en: The tool must be easy to use, configure, and deploy. This is especially important
    if you don't have a full-time designated SCMS administrator.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 工具必须易于使用、配置和部署。如果您没有全职指定的SCMS管理员，这一点尤为重要。
- en: '**How can you separate bleeding-edge code under active development from stable
    code during team development?**'
  id: totrans-1682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何在团队开发中区分处于活跃开发中的前沿代码和稳定代码？**'
- en: 'You need a strategy to separate the two in the source control repository. Your
    choices are:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个策略在源代码存储库中分离这两者。您的选择是：
- en: Don't separate them. Everyone has bleeding-edge code and must learn to cope
    with it. Don't check in anything that is obviously broken or nonfunctional.
  id: totrans-1684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将它们分开。每个人都有前沿代码，必须学会应对它。不要提交任何明显损坏或非功能性的内容。
- en: Employ branches. Perform each line of development work on a separate branch,
    and merge the branches down at appropriate stable points. With this scheme, integration
    problems are only discovered on a merge; this places the burden of maintenance
    on the branch merger (which might be the developer working on the branch or a
    separate system integrator).
  id: totrans-1685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支。在每个单独的分支上执行每行开发工作，并在适当的稳定点合并分支。在这种方案中，集成问题仅在合并时被发现；这把维护的负担放在了分支合并者身上（可能是分支上的开发者或单独的系统集成商）。
- en: Use a *stable* label, applied to the entire source tree as a *baseline*. Developers
    check out this labeled baseline and then move the components they are developing
    to the latest version. They can then work and commit changes without affecting
    anyone else's stable source tree. When new development work is deemed stable (fit
    for public consumption) the label is moved. This change is picked up by other
    developers when they next synchronize to the baseline.
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个*稳定的*标签，将其应用于整个源树作为*基线*。开发者检出此标记的基线，然后将他们正在开发的组件移动到最新版本。然后他们可以工作并提交更改，而不会影响任何人的稳定源树。当新的开发工作被认为稳定（适合公开消费）时，标签会移动。其他开发者在下次同步到基线时会接收到这个更改。
- en: Which you chose depends on the facilities of your SCMS and your development
    culture.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择哪个取决于你的SCMS功能和你的开发文化。
- en: Getting Personal
  id: totrans-1688
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取个人
- en: '**Does your development team make effective use of source control?**'
  id: totrans-1689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你们开发团队是否有效地使用了源代码控制？**'
- en: 'Ultimately, does your SCMS help you to develop software easily, and does it
    facilitate collaboration better than any alternative? Consider tool setup issues
    like:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你的SCMS是否帮助你轻松地开发软件，并且它是否比任何其他替代方案更好地促进协作？考虑以下工具设置问题：
- en: Are you using the right tool with the right feature set?
  id: totrans-1691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否在使用具有正确功能集的正确工具？
- en: Do you have an SCMS administrator, or is it managed on an ad hoc basis?
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有SCMS管理员，或者它是基于临时管理方式？
- en: Does everyone know how to use it? Is there an appropriate training scheme?
  id: totrans-1693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人都知道如何使用它吗？是否有适当的培训方案？
- en: Is the repository integrated with your defect management or fault-tracking tool?
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库是否与你的缺陷管理或故障跟踪工具集成？
- en: 'Consider asset management issues like:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑资产管理问题，例如：
- en: Is there agreement over the contents of check-in messages and the use of other
    revision metadata?
  id: totrans-1696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提交消息的内容和其他修订元数据的用法是否有共识？
- en: Do you have a consistent labeling scheme to mark important source tree revisions?
  id: totrans-1697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有用于标记重要源树修订的一致标签方案？
- en: Do you have a defined (and documented) branching strategy, with provably correct
    merging?
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有定义（并记录）的分支策略，并且有可证明的正确合并？
- en: Can you automatically create release notes from the source repository?
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否从源存储库自动创建发布说明？
- en: Are you able to re-create old builds? Have you addressed when the build toolchain
    altered, affecting code compatibility?
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否重新创建旧版本构建？你是否解决了构建工具链更改的问题，这影响了代码兼容性？
- en: Can you build a product entirely from the contents of the repository, or do
    you need to supply any extra files?
  id: totrans-1701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能否完全从存储库的内容构建产品，或者你需要提供任何额外的文件？
- en: How important are each of these issues to your development team?
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题中的每一个对你们开发团队来说有多重要？
- en: '**Is your current work backed up? How important are backups to your development
    team? When are backups made?**'
  id: totrans-1703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的当前工作是否已备份？备份对你们开发团队来说有多重要？备份是在何时进行的？**'
- en: 'If you can be bothered to write some code, it must be important, and so it
    must be backed up. There are several levels at which backups can be employed:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意编写一些代码，那么它肯定很重要，因此它必须得到备份。备份可以在几个层面上进行：
- en: Personal workstation backups. These will ensure that no work is lost from your
    local hard drive or from your source tree sandbox.
  id: totrans-1705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人工作站备份。这将确保不会从你的本地硬盘或源树沙盒中丢失任何工作。
- en: The server holding the source control repository. This ensures that you won't
    lose the central source tree files and their revision histories.
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存源代码存储库的服务器。这确保你不会丢失中央源树文件及其修订历史。
- en: 'The latter is the most important: It''s criminally insane not to back up a
    source repository. If your workstation only contains sandbox development areas,
    then it''s not as critical to back it up; there should be little work at any time
    that isn''t checked in (remember to perform *little and often* check-ins), so
    a loss of a local disk is not critical.'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是至关重要的：不备份源存储库是犯罪性的疯狂行为。如果你的工作站只包含沙盒开发区域，那么备份它就不那么关键了；在任何时候，应该很少有未提交的工作（记住要执行*少量且频繁*的提交），因此本地磁盘的丢失不是关键。
- en: Consider also how you back up documents and any other non—source tree items
    you produce. Either check them in to the repository somewhere or make sure that
    they are stored in logical places on a shared fileserver, somewhere that is backed
    up. Without revision control, you will have to perform manual document versioning—it's
    as important to keep historical versions of specifications as it is to version
    the source code.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑你如何备份文档以及你产生的任何其他非源代码树项目。要么将它们检查到某个存储库中，要么确保它们存储在共享文件服务器上的逻辑位置，某个已备份的位置。如果没有版本控制，你将不得不手动进行文档版本管理——保留规格说明的历史版本与版本控制源代码一样重要。
- en: In a multiuser environment, the systems administrator will determine when backups
    are made. This is usually during the night when there is less computer activity
    and less information changing on the filesystems being backed up. (But what about
    multi-continent projects with massive time zone delays?)
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 在多用户环境中，系统管理员将决定何时进行备份。这通常是在夜间，那时计算机活动较少，被备份的文件系统上的信息变化也较少。（但多大陆项目存在巨大的时区延迟怎么办？）
- en: '**On which computers is your source code held?**'
  id: totrans-1710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的源代码存储在哪些计算机上？**'
- en: Obviously, it is held on the development servers and workstations within the
    company network. These sit safely in the office behind a corporate firewall. But
    also consider whether your code is held on laptops or on the home machines of
    telecommuters. How sensitive is the work? How should these machines be digitally
    and physically protected?
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，它存储在公司网络内的开发服务器和工作站上。这些设备安全地位于办公室内，背后有企业防火墙的保护。但也要考虑你的代码是否存储在笔记本电脑或远程工作人员的家用机器上。这项工作有多敏感？这些机器应该如何在数字和物理上得到保护？
- en: 'Chatper 19: Being Specific'
  id: totrans-1712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章：具体化
- en: Mull It Over
  id: totrans-1713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Is a poor specification better than no specification at all?**'
  id: totrans-1714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**糟糕的规格说明是否比完全没有规格说明要好？**'
- en: A factually incorrect or painfully out-of-date specification is definitely worse.
    It will send readers down a blind alley and waste a lot of their time. The false
    information it contains could easily lead to broken code that will cost a lot
    of time, energy, and money to fix later on.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 事实错误或过时的规格说明肯定更糟糕。它会让读者误入歧途，浪费大量时间。其中包含的错误信息可能导致代码损坏，修复这些代码将花费大量时间、精力和金钱。
- en: If a specification is ambiguous or misses important information, then you're
    hoping that the readers are experienced enough to recognize the problem and interpret
    the information carefully. Hopefully they'll all make the same set of assumptions
    about the missing information. A specification should really stand on its own
    and not require the intuition of its readership.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个规格说明含糊不清或遗漏了重要信息，那么你希望读者经验丰富，能够识别问题并仔细解释信息。希望他们都会对缺失的信息做出相同的假设。规格说明应该真正独立，不需要读者的直觉。
- en: If a specification is too verbose and hides information, then it is probably
    better (in the long run) to rewrite it.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个规格说明过于冗长并隐藏信息，那么从长远来看，重写它可能更好。
- en: The number of factual inaccuracies in your company's specifications will probably
    frighten you! In my experience, very few companies have a set of consistently
    good specifications.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 你公司规格说明中的事实错误数量可能会让你感到震惊！根据我的经验，很少有公司有一套始终如一的优秀规格说明。
- en: '**How detailed does a good specification have to be?**'
  id: totrans-1719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个好的规格说明需要有多详细？**'
- en: 'The answer is: *appropriately detailed*, where the value of "appropriate" depends
    on the project, the team, the contents, the quality of related documents, and
    the lunar phase. Too much detail can definitely be counterproductive: Clearly,
    if a design specification was too detailed it would *be* the code itself. However,
    ambiguity in key areas is a road to disaster.'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：*适当详细*，其中“适当”的价值取决于项目、团队、内容、相关文档的质量以及月相。过多的细节肯定会产生反效果：显然，如果设计规格说明过于详细，它就会变成代码本身。然而，关键领域的含糊不清是通往灾难的道路。
- en: '**Is it important that all the documents in a company/project have a common
    presentation style?**'
  id: totrans-1721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**公司/项目中的所有文档是否需要统一的呈现风格很重要吗？**'
- en: This is about as important as a uniform code style. That is, there are plenty
    of more important things to worry about, even if this is the most immediately
    visible problem with a specification. The importance of visual consistency depends
    (in part) on whether the documents are released outside the company or not. It
    looks more professional to ship consistent documents, all written in a similar
    style with the same template.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 这与统一代码风格的重要性相当。也就是说，还有更多更重要的事情需要担心，即使这是规范中最直接可见的问题。视觉一致性的重要性取决于（部分）文档是否在公司外部发布。发布风格一致、模板相同的文档看起来更专业。
- en: Ultimately, the content of your documents is far more important than their appearance.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您文档的内容比它们的表面外观更重要。
- en: '**How should you store documents? Should you provide an index of them (by type
    or by project), for example?**'
  id: totrans-1724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您应该如何存储文档？是否应该提供索引（按类型或按项目）？**'
- en: You must be able to quickly locate and retrieve a document that has been written.
    The actual storage scheme is unimportant, provided that it's well known and universally
    followed.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须能够快速定位和检索已编写的文档。实际的存储方案并不重要，只要它是众所周知的并且被普遍遵循。
- en: It usually makes sense to store all documents on a single central filestore,
    and group them by work package (this could be by project, by customer, by component,
    or by feature). It's helpful to maintain a central list of all stored documents
    to aid retrieval. However, this adds management overhead, and if not maintained,
    it will quickly fall out of use.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 通常有道理将所有文档存储在单个中央文件存储中，并按工作包（这可能是由项目、客户、组件或功能）分组。维护所有存储文档的中央列表以帮助检索是有帮助的。然而，这会增加管理开销，如果不维护，它将很快被弃用。
- en: Large companies employ people to deal with the storage and retrieval of documents.
    Though experts at this task, their presence adds more steps to the working procedure
    and more links in the development process chain.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 大型公司雇佣人员来处理文档的存储和检索。尽管他们在这项任务上很专业，但他们的存在增加了工作流程的步骤和开发流程链中的更多环节。
- en: It's essential to keep documents under some form of revision control and to
    monitor which versions of the documents apply to which versions of the code. This
    is part of a *configuration management* strategy (see "[Configuration Management](ch18s03.html
    "Configuration Management")" on page 356).
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 必须保持文档在某种形式的版本控制之下，并监控哪些文档版本适用于哪些代码版本。这是配置管理策略的一部分（参见第356页的“[配置管理](ch18s03.html
    "Configuration Management")”）。
- en: '**How should you conduct a specification review?**'
  id: totrans-1729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您应该如何进行规范审查？**'
- en: 'Document reviews work similarly to code reviews. They generally take place
    in a meeting, in which case there are some important prerequisites: the correct
    set of reviewers must be selected, and the material for review should be distributed
    with enough time for reviewers to adequately prepare.'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 文档审查与代码审查类似。通常在会议中进行，在这种情况下，有一些重要的前提条件：必须选择正确的审查人员，并且审查材料应在足够的时间内分发，以便审查人员有足够的时间准备。
- en: Alternatively, the review can be run virtually by soliciting email feedback
    or by giving a printed copy to each reviewer and receiving his or her marked-up
    copies for inspection.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过征求电子邮件反馈或给每位审查人员提供打印副本并接收其标记的副本进行审查来虚拟地进行审查。
- en: 'The review will address a number of things; the importance of each should be
    agreed upon up front:'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 审查将涉及许多方面；每个方面的重要性应在事先达成一致：
- en: The quality of the contents. (Is it complete, correct, and so on? This is paramount.)
  id: totrans-1733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容的质量。（是否完整、正确等？这是至关重要的。）
- en: The quality of the presentation style. (Does the document conform to project
    guidelines?)
  id: totrans-1734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现风格的质量。（文档是否符合项目指南？）
- en: The quality of the writing style. (Does the author write like Shakespeare or
    a five year old? For software specifications, both are bad!)
  id: totrans-1735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写作风格的质量。（作者是否像莎士比亚那样写作，或者像五岁孩子那样写作？对于软件规范来说，两者都不好！）
- en: 'In a meeting context, it''s best to discuss general comments about the material
    and the overall approach first. (But be careful here: It''s very easy to get waylaid
    by more specific technical issues at this stage.) Then the specifics of the material
    can be discussed. Since all the reviewers have looked at the material beforehand
    and have already amassed their comments, stepping through, section by section,
    is usually appropriate. Long sections might be traversed paragraph by paragraph
    if necessary.'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 在会议环境中，最好首先讨论关于材料的一般性评论和整体方法。（但在这里要小心：在这个阶段很容易被更具体的技术问题所分散。）然后可以讨论材料的细节。由于所有审阅者都事先审阅了材料，并且已经积累了他们的评论，因此逐节进行讨论通常是合适的。如果需要，长章节可以逐段遍历。
- en: '**Does self-documenting code render all specifications useless? Specific ones?**'
  id: totrans-1737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自文档化的代码是否使所有规范都变得无用？具体的规范？**'
- en: 'Not entirely. Self-documenting code can avoid the need for design specifications
    or other maintenance documents. Literate API documentation placed in code comments
    can even replace functional specifications in *some* cases, if the docs are really
    thorough. Be careful, though: If you try to write a lot of documentation in literate
    comments, you''d probably find it easier to type the same information into a word
    processor. Literate code documentation can never replace a requirements specification
    or a test specification.'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 并非完全如此。自文档化的代码可以避免需要设计规范或其他维护文档。放置在代码注释中的文献API文档甚至可以在*某些*情况下替代功能规范，如果文档真的很详尽。但是要小心：如果你试图在文献注释中编写大量文档，你可能会发现直接在文字处理程序中输入相同信息更容易。文献化的代码文档永远不能替代需求规范或测试规范。
- en: A comprehensive set of automated test cases *could* replace a software component's
    test specification, if the test were sufficiently clear and maintainable. However,
    they are seldom sufficient to replace final product validation tests.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 一套全面的自动化测试用例*可能*可以替代软件组件的测试规范，如果测试足够清晰且易于维护。然而，它们很少足够替代最终产品的验证测试。
- en: '**How can a document be collaborated on by more than one author?**'
  id: totrans-1740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如何让多个作者协作编写文档？**'
- en: With difficulty—few documentation systems provide the same collaborative facilities
    as a source code control tool. Look at wiki-webs for shared text editing, if you
    can cope with your documents being in an HTML-derivative form.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 有困难——很少有文档系统提供与源代码控制工具相同的协作功能。如果你能处理你的文档以HTML派生形式存在，可以查看wiki-webs进行共享文本编辑。
- en: Otherwise, you have to split the document into sections and give one section
    to each person. Each section will have an inevitable difference in writing style,
    quality of content, and will be based on a different set of assumptions; check
    for this as the work is stitched back together. You might find it easier to split
    the sections into their own documents and put an umbrella document over the top
    of them. A leader must be appointed to coordinate the work of several people—to
    guide the writing process, collate the parts, and encourage people to complete
    their sections on time.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你必须将文档分成几个部分，并将每个部分分配给一个人。每个部分将不可避免地存在写作风格、内容质量的不同，并且基于不同的假设集；在将工作拼凑在一起时要检查这一点。你可能发现将部分分成单独的文档，并在它们上面放置一个总文档更容易。必须指定一个领导者来协调多人的工作——指导写作过程，收集各部分，并鼓励人们按时完成他们的部分。
- en: An alternative approach is to give one person overall writing responsibility,
    but with a strong element of peer review. The document's content and structure
    is agreed upon in meetings beforehand, then the writer retires to craft the document
    alone, before offering it for group review.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是给一个人负责整体写作，但要有强烈的同行评审元素。在会议之前就文档的内容和结构达成一致，然后作者独自退下撰写文档，在提交给小组评审之前。
- en: Be careful with any of these approaches, as writing by committee can produce
    laborious documents and can take a very long time.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中要小心，因为集体写作可能会产生繁琐的文档，并且可能需要非常长的时间。
- en: Getting Personal
  id: totrans-1745
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**Who decides on the contents of your documents?**'
  id: totrans-1746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谁决定你文档的内容？**'
- en: This is defined by a company's development process, by a document template,
    or by convention. But just because there is a convention doesn't mean that it's
    actually good practice. Check that the types of documents you write, as well as
    their contents, are genuinely valuable to your software development process.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由公司的开发流程、文档模板或惯例定义的。但仅仅因为存在惯例并不意味着它实际上是一种好的实践。检查你编写的文档类型及其内容是否真正对你的软件开发过程有价值。
- en: '**Consider your current project. Do you have:**'
  id: totrans-1748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**考虑你的当前项目。你有：**'
- en: '**A requirements specification?**'
  id: totrans-1749
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**需求规范？**'
- en: '**An architecture specification?**'
  id: totrans-1750
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**架构规范？**'
- en: '**A design specification?**'
  id: totrans-1751
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计规范？**'
- en: '**A functional specification?**'
  id: totrans-1752
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**功能规范？**'
- en: '**Any other specification?**'
  id: totrans-1753
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**还有其他规范吗？**'
- en: '**Are they up to date? Are they complete? Do you know how to get the latest
    versions? Can you access historical revisions?**'
  id: totrans-1754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**它们是最新的吗？它们是完整的吗？你知道如何获取最新版本吗？你能访问历史版本吗？**'
- en: If you don't have some of these or they're substandard, why? How can you remedy
    the problem?
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这些或它们质量不高，为什么？你如何解决这个问题？
- en: Whose job is it to keep the documents up to date? Document versioning is an
    important aspect of specification generation—make sure that you have a clear plan
    for doing this.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 谁的工作是保持文档更新？文档版本控制是规范生成的重要方面——确保你有一个明确的计划来做这件事。
- en: '**Do you revision control your documents? If so, how?**'
  id: totrans-1757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你控制文档的版本吗？如果是这样，你是如何做的？**'
- en: 'Several techniques for managing document revisions are seen in the field:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 在该领域可以看到几种管理文档版本的技术：
- en: Store them in an SCMS alongside the code.
  id: totrans-1759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们存储在与代码一起的SCMS中。
- en: Use a document (or even a workflow) management system.
  id: totrans-1760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文档（甚至工作流程）管理系统。
- en: 'Use the filesystem: Encode the document revision in its filename (possibly
    archiving old versions in a separate old directory).'
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件系统：在文件名中编码文档版本（可能将旧版本存档到单独的旧目录中）。
- en: Store old revisions in an email attachment sent to a "magic" user (grotesque,
    but—yes—I *have* seen a company do this).
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将旧版本存储在发送给“魔法”用户的电子邮件附件中（虽然有些荒谬，但——是的，我确实见过公司这样做）。
- en: 'Whichever scheme you use, it must address these issues:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种方案，它都必须解决这些问题：
- en: Ease of use and document accessibility
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性和文档可访问性
- en: How to prevent two people from editing the same document at the same time
  id: totrans-1765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何防止两个人同时编辑同一份文档
- en: Differentiating the latest release version from the copy currently under development
  id: totrans-1766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分最新发布版本和当前正在开发的副本
- en: How to avoid accidental deletion or overwriting the wrong document version
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免意外删除或覆盖错误的文档版本
- en: How to maintain the document history with each change
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在每次更改时维护文档历史
- en: The ease of referencing a specific document revision
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用特定文档版本的便捷性
- en: '[Chapter 20](ch20.html "Chapter 20. A REVIEW TO A KILL")'
  id: totrans-1770
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章。一次致命的审查")'
- en: Mull It Over
  id: totrans-1771
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Does the required number of reviewers depend on the size of the code being
    reviewed?**'
  id: totrans-1772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所需的审查者数量是否取决于正在审查的代码的大小？**'
- en: Not really. If your code is particularly important, then you might consider
    inviting a few more reviewers, or you might make a particular effort to select
    reviewers with the most experience.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 未必。如果你的代码特别重要，那么你可能会考虑邀请更多的审查者，或者你可能特别努力地选择最有经验的审查者。
- en: However, if the code is too large, you don't need more reviewers—you need a
    rewrite!
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果代码太大，你不需要更多的审查者——你需要重写！
- en: '**Which tools are useful aids for code reviewing?**'
  id: totrans-1775
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪些工具对代码审查有帮助？**'
- en: Common sense, a keen pair of eyes, and an alert brain!
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 常识、敏锐的双眼和警觉的大脑！
- en: A number of software tools are also useful. Many different tools can inspect
    your code and help you to gauge its quality and relative risk to the entire codebase.
    They can trace the flow of execution, work out which code is executed most often,
    and calculate a value for each function's code complexity. This last metric is
    very useful when identifying which pieces of code need to be reviewed as soon
    as possible. A visual design program may help you to understand the code structure
    and its dependencies (particularly useful for reviewing class hierarchies in object-oriented
    languages).
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件工具也非常有用。许多不同的工具可以检查你的代码，并帮助你评估其质量以及相对于整个代码库的相对风险。它们可以追踪执行流程，确定哪些代码被执行得最频繁，并为每个函数的代码复杂度计算一个值。这个最后指标在确定哪些代码片段需要尽快审查时非常有用。一个视觉设计程序可以帮助你理解代码结构和其依赖关系（尤其是在面向对象语言中审查类层次结构时特别有用）。
- en: '**Should you perform a code review before or after running it through source
    code checking tools?**'
  id: totrans-1778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你应该在运行源代码检查工具之前还是之后进行代码审查？**'
- en: After. Reviewers should probably use these tools themselves during review preparation,
    but authors must perform all possible checking on their own code before releasing
    it for review. They'd be foolish not to. It makes no sense to waste reviewers'
    time on code that could have been easily improved. Reserve review time to find
    more interesting problems.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 之后。审查者可能应该在审查准备期间自己使用这些工具，但作者必须在发布审查之前对他们的代码进行所有可能的检查。不这样做是愚蠢的。没有理由浪费审查者的时间在可以轻松改进的代码上。保留审查时间来寻找更有趣的问题。
- en: If an issue is detected during a review, thought should be given to whether
    the same issue can be automatically detected in the future using a tool.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在审查过程中发现了一个问题，应该考虑是否可以使用工具自动检测到相同的问题。
- en: '**What preparation is required for a code review meeting?**'
  id: totrans-1781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码审查会议需要哪些准备？**'
- en: 'The author has completed the code satisfactorily (otherwise he or she is wasting
    the reviewers'' precious time). The chairman has arranged the meeting properly
    so that it will run smoothly. More interestingly, before the meeting, each reviewer
    must have already:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 作者已经满意地完成了代码（否则他或她是在浪费审查者的宝贵时间）。主席已经妥善安排了会议，以确保会议顺利进行。更有趣的是，在会议之前，每位审查者必须已经：
- en: Read (and understood) the specification
  id: totrans-1783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读（并理解）了规范
- en: Become familiar with the code
  id: totrans-1784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉了代码
- en: Drawn up a list of issues and questions (this step enforces discipline; if you
    don't force yourself to do this, it's easy to superficially skim the code and
    not really know it well enough to review thoroughly)
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出问题清单和问题（这一步骤强制执行纪律；如果你不强迫自己这样做，很容易对代码进行表面上的浏览，而不真正了解它，从而无法进行彻底的审查）
- en: There will always be things you'll find during methodical inspection in a review
    meeting that you missed beforehand. Even so, this prior preparation is essential
    to prevent the meeting from wasting a lot of people's time.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查会议中，你总会发现一些在之前检查中遗漏的事情。即便如此，这种前期准备对于防止会议浪费大量人的时间是至关重要的。
- en: '**How do you differentiate review comments to be acted upon immediately from
    those to chalk up for experience on the next project?**'
  id: totrans-1787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何区分需要立即处理的审查评论和那些可以在下一个项目中积累经验的问题？**'
- en: 'You must make a decision based on:'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须根据以下因素做出决定：
- en: How important the identified problem is
  id: totrans-1789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定的问题的重要性
- en: Whether it's a matter of personal aesthetics or it breaks an agreed best practice
  id: totrans-1790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是个人审美问题还是违反了达成的最佳实践
- en: How much work is involved in the fix
  id: totrans-1791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复涉及的工作量
- en: How serious the effect of the change is on the rest of the code
  id: totrans-1792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更对其他代码的影响程度
- en: How wrong (or misleading) the code is without the fix
  id: totrans-1793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有修复的情况下，代码的错误（或误导性）程度
- en: How fragile or dangerous the change work is
  id: totrans-1794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更工作的脆弱性或危险性
- en: Where the project is in the development cycle—you only want to make *essential*
    changes near a release deadlin.
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目在开发周期中的位置——你只想在发布截止日期附近进行**必要**的变更。
- en: There is no easy rule. If there is any ambiguity in a review meeting, then the
    chairman makes the ultimate choice. Sometimes problems are rated between *must
    fix and nice to have*—the author implements as many high priority fixes as feasible
    in the available time. Other issues may be deferred to the next iteration of the
    component's development.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的规则。如果审查会议中存在任何歧义，那么主席将做出最终决定。有时问题会被评为“必须修复”和“最好有”之间——作者在可用的时间内尽可能实现许多高优先级修复。其他问题可能被推迟到组件开发的下一个迭代。
- en: '**How do you run a virtual review meeting?**'
  id: totrans-1797
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何进行虚拟审查会议？**'
- en: Virtual reviews are commonly run by email. The review is organized by a chairman,
    who is usually the hub of communications. Certainly, the author must *not* be
    the hub of communications; it would be too easy for him to select which comments
    are important and to ignore all the things he doesn't like. This is obviously
    a bad idea.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟审查通常通过电子邮件进行。审查由主席组织，通常是沟通的中心。当然，作者绝对不能成为沟通的中心；否则，他很容易选择哪些评论是重要的，并忽略所有他不喜欢的事情。这显然是一个坏主意。
- en: 'There is an important question with this approach: Do the reviewers get to
    see each other''s comments? In a virtual review, debate is much harder to facilitate,
    especially if emails are directed only to the chairman. However, a 1,000-email
    conversation broadcast to all reviewers quickly becomes irritating and diverting.
    As an alternative, you could meet in a virtual chat room, use an instant messenger,
    a dedicated newsgroup, or a mailing list.'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一个重要的问题：审查员能看到彼此的评论吗？在虚拟审查中，辩论很难促进，尤其是如果电子邮件只发送给主席。然而，将1,000封电子邮件的对话广播给所有审查员很快就会变得令人烦恼和分心。作为替代，您可以在虚拟聊天室会面，使用即时消息、专用新闻组或邮件列表。
- en: 'An alternative virtual review mechanism is to distribute printouts of the code
    in question. The reviewers scribble comments on their copies and return them to
    the author. You can run a similar scheme using a wiki: Post your code on the wiki
    and let reviewers add comments to the page. The format of how you conduct a review
    is less important than simply doing it somehow.'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代的虚拟审查机制是将有问题的代码打印出来。审查员在他们自己的副本上写评论，然后将其退还给作者。您可以使用wiki运行类似的方案：在wiki上发布您的代码，并让审查员在页面上添加评论。你如何进行审查的格式不如简单地做它重要。
- en: '**How useful are informal code reviews?**'
  id: totrans-1801
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**非正式代码审查有多有用？**'
- en: Informal reviews are much better than no review at all, but since they are less
    thorough, they'll inevitably find fewer faults (for the same quality of code reviewer).
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式审查比完全没有审查要好，但由于它们不够彻底，它们不可避免地会发现更少的错误（对于相同质量的代码审查员）。
- en: 'Although terms are not officially defined, McConnell describes two types of
    informal review: (McConnell 96)'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管术语没有正式定义，McConnell描述了两种非正式审查的类型：（McConnell 96）
- en: '**Walkthroughs**'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码审查**'
- en: These are very informal gatherings where programmers look over the code together.
    This could be in front of an editor, with changes made on the fly.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非正式的聚会，程序员们一起查看代码。这可以在编辑器前进行，即时做出更改。
- en: '**Code reading**'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码阅读**'
- en: The author distributes copies of the code to a set of reviewers, who make comments
    on it and send them back to the author.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 作者将代码副本分发给一组审查员，他们对其做出评论，并将它们退回给作者。
- en: Getting Personal
  id: totrans-1808
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**个人观点**'
- en: '**Does your project perform code reviews? Does it perform** *enough* **code
    reviews?**'
  id: totrans-1809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的项目进行代码审查吗？它进行** *足够的* **代码审查吗？**'
- en: Even if it makes a vaguely regular event of code reviews, there probably still
    isn't enough reviewing going on. Too little value is put on this practice; if
    the code seems to work, then people think that there's no point wasting valuable
    time reviewing it.
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这使代码审查成为一项模糊的常规活动，可能仍然审查不足。对这个实践的价值评价太低；如果代码似乎能工作，那么人们认为没有必要浪费时间进行审查。
- en: This attitude is careless. The time taken to track lingering code faults is
    often far greater than the effort of review. Code reviews are a sensible and pragmatic
    way to take control of your development process and ensure that your software
    is of high quality.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 这种态度是粗心的。追踪遗留代码错误所需的时间通常远大于审查的努力。代码审查是控制你的开发过程和确保你的软件质量合理和实际的方法。
- en: What can you do to improve on this in your current project?
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做些什么来改善你当前项目中的这种情况？
- en: '**Do you work with any programmers whose code is considered to be above review?**'
  id: totrans-1813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你是否与任何被认为代码无需审查的程序员合作？**'
- en: A respected Guru programmer (see "[The Guru](ch16.html#the_guru "The Guru")"
    on page 299) is often held in awe, and no one ever suggests that his work should
    be reviewed. No one probably dares. This reverence is misguided and dangerous.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 受人尊敬的大师级程序员（参见第299页的"[The Guru](ch16.html#the_guru "The Guru")"）通常令人敬畏，没有人建议他的工作应该被审查。没有人可能敢这么做。这种敬畏是错误的，也是危险的。
- en: 'In my experience, Gurus write some of the most review-worthy code you''ll ever
    see: full of deep, incomprehensible, unmaintainable magic. The fact that they
    never put their code forward for review illustrates their incorrect attitude toward
    the task and the team. No one''s code is above review; all code should be carefully
    scrutinized.'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，大师级程序员写的代码中，有一些是最值得审查的：充满了深奥、难以理解、难以维护的魔法。他们从未将代码提交审查的事实说明了他们对这项任务和团队的不正确态度。没有人的代码是高于审查的；所有代码都应该仔细审查。
- en: '**What percentage of your code has ever been subject to code review?**'
  id: totrans-1816
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的代码中有多少比例曾经接受过代码审查？**'
- en: Unless you're a very unusual beast, this amount is undoubtedly small. How formal
    have the reviews been? How useful was each review, and how much did it contribute
    to the final quality of the code?
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是一个非常不寻常的生物，否则这个数量无疑很小。审查有多正式？每次审查有多有用？它对代码最终质量贡献了多少？
- en: How much of your unreviewed code was pair programmed? How much *should* have
    been reviewed? How much unreviewed code was critically important commercial code?
    How many bugs slipped through into production software, and how many of those
    bugs caused later problems?
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少未审查的代码是双人编程的？应该审查多少？多少未审查的代码是至关重要的商业代码？有多少错误滑进了生产软件，以及有多少错误导致了后续问题？
- en: Even if it's not a part of your project culture to run code reviews, make a
    point of inviting formal review for your work. Don't worry if no one else does
    it—your code will be exceptional by comparison!
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码审查不是你项目文化的一部分，也要确保邀请对你的工作进行正式审查。如果其他人没有这样做，也不要担心——与他们的代码相比，你的代码将非常出色！
- en: '[Chapter 21](ch21.html "Chapter 21. HOW LONG IS A PIECE OF STRING?")'
  id: totrans-1820
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第21章](ch21.html "第21章。一根绳子有多长？")'
- en: Mull It Over
  id: totrans-1821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**How can you rescue a slipping project and bring it back on track?**'
  id: totrans-1822
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何才能挽救一个即将失控的项目并使其回到正轨？**'
- en: One technique to protect yourself from a failing project is to run, fast, like
    a rat from a sinking ship. It's not very professional, though!
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 一种保护自己免受失败项目影响的技术是快速逃跑，就像一只从沉船中逃出的老鼠。这并不太专业！
- en: 'Once a project is behind schedule, there''s rarely anything you can do to bring
    it back on track—that is, unless there was a monster amount of contingency allocated.
    You might instead consider these strategies:'
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目落后于进度，通常很难将其拉回正轨——除非已经分配了大量的应急资金。你可能会考虑以下策略：
- en: Reschedule the project; see if you can agree a later delivery date with the
    customer.
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新安排项目；看看你是否可以与客户协商一个更晚的交付日期。
- en: De-scope the first release, possibly agreeing to a later release with the missing
    functionality. It's better to commit to doing less stuff, but doing it better
    and within the allotted time, than to implement loads of unnecessary functionality
    and slip badly.
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩小首次发布的范围，可能同意稍后发布带有缺失功能性的版本。最好是承诺做更少的事情，但做得更好，并在规定的时间内完成，而不是实现大量不必要的功能并严重延误。
- en: Don't blindly throw more developers at the project to speed things up. Brooks
    lucidly described how bad this idea is, especially when a project is failing.
    (Brooks 95) It would take the existing developers time to get the new guys up
    to speed, and there would then be extra overhead in managing the larger team.
    Any benefit would almost certainly be outweighed by the costs of new personnel.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 不要盲目地增加开发者数量来加快项目进度。布鲁克斯清晰地描述了这种想法是多么糟糕，尤其是在项目失败时。（布鲁克斯 95）现有开发者需要时间来让新成员熟悉情况，然后管理更大团队会有额外的开销。任何好处几乎肯定会被新人员成本所抵消。
- en: '**What''s the correct response to having a deadline imposed on you before feasibility
    or planning work commences?**'
  id: totrans-1828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在可行性或规划工作开始之前，对您施加截止日期的正确反应是什么？**'
- en: 'Tact! The fixed delivery deadline might be a valid business requirement: You''ll
    make money if you ship software on time; you''ll make nothing if you don''t. You
    can''t always do the theologically correct thing and move a deadline or adjust
    the scope of the work.'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 策略！固定的交付截止日期可能是一个有效的业务需求：如果你按时交付软件，你会赚钱；如果你不这样做，你将一无所获。你并不总是能做神学上正确的事情，比如移动截止日期或调整工作范围。
- en: Sometimes it helps your design effort to have early visibility of the anticipated
    project deadline. This information shows you how pure and well-thought-out your
    design can be, and it will help you to scope out the amount of code required and
    whether future flexibility can be considered. Ultimately, it will show you whether
    or not you need to hack out a quick-fix solution or the elegantly engineered code
    you always want to write. It might help you to make buy versus build decisions
    and to set the final quality expectations for the delivered software.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 早期了解预期的项目截止日期有时有助于你的设计工作。这些信息显示了你的设计有多纯净、思考得多周全，这将帮助你确定所需的代码量以及是否可以考虑未来的灵活性。最终，它将告诉你是否需要快速修复方案，还是你一直想要的优雅工程代码。这可能有助于你做出购买还是开发的决策，并设定最终交付软件的质量期望。
- en: Make it clear that this is not an ideal way to develop software. *Hopefully*
    someone will listen, and the managers will learn to stop promising such risky
    deadlines—it's a careless form of gambling with the success of a project and the
    future of an organization.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 明确指出这不是开发软件的理想方式。*希望*有人会倾听，管理者会学会停止承诺这样风险极高的截止日期——这是一种对项目成功和组织未来的粗心大意赌博。
- en: '**How do you ensure that a development plan is genuinely useful?**'
  id: totrans-1832
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你如何确保开发计划真正有用？**'
- en: 'High-quality development plans are:'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量的发展计划是：
- en: '**Accurate**'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: '**准确**'
- en: They include all the tasks required to build the software and are based on sound
    timescale estimates.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包括构建软件所需的所有任务，并且基于稳健的时间尺度估计。
- en: '**Fine-grained**'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: '**细粒度**'
- en: There aren't a few large tasks with rough estimates, but many small tasks carefully
    sequenced. Our confidence in the accuracy of a small task's timescale is higher,
    so the quality of the overall plan will be higher.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 没有少数几个大任务和粗略的估计，而是有许多小任务被精心排序。我们对小任务时间尺度的准确性更有信心，因此整体计划的品质会更高。
- en: If you think that a task comprises several parts (e.g., it is dependent on a
    third party and splits into the third-party release milestone, followed by a period
    of integration and bug fixing) then make this explicit on the plan.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为一个任务由几个部分组成（例如，它依赖于第三方，并分为第三方发布里程碑，然后是集成和错误修复的时期），那么在计划中明确这一点。
- en: '**Agreed**'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致**'
- en: 'Everyone buys into the plan: Management is happy with the level of inherent
    risk, while programmers agree that the timescales are accurate, no tasks are missing,
    and all the dependencies are correctly mapped out.'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都接受了这个计划：管理层对固有的风险水平感到满意，而程序员则认为时间尺度准确，没有遗漏的任务，所有依赖关系都正确地绘制出来。
- en: '**Visible**'
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: '**可见**'
- en: They are used to make important decisions by individual developers and by managers.
    Timescale changes are communicated through the plan. The plan is versioned, and
    progress against the plan is recorded clearly.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 他们习惯于由个人开发人员和经理做出重要决策。时间尺度变化通过计划进行传达。计划有版本号，并且对计划的进度有清晰的记录。
- en: '**Monitored**'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: '**监控**'
- en: If the schedule is poorly monitored, the timescale estimates become a worthless
    statistic. Progress must be checked against the plan. The course of the development
    effort is steered by this measurement.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进度监控不当，时间尺度估计就变成了毫无价值的统计数据。必须将进度与计划进行核对。开发工作的进程是通过这种测量来引导的。
- en: '**Why do different programmers work at different rates? How can you reflect
    this on the plan?**'
  id: totrans-1845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**为什么不同的程序员工作速度不同？你如何在计划中反映这一点？**'
- en: 'Programmers differ in many ways:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在许多方面都有所不同：
- en: They have different technical abilities and reason about problems in different
    ways. This affects the quality of work produced.
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们有不同的技术能力，以不同的方式推理问题。这影响了工作成果的质量。
- en: Different levels of experience lead to different design choices.
  id: totrans-1848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同级别的经验导致不同的设计选择。
- en: 'People have different levels of commitment: responsibility for old projects,
    levels of enthusiasm for the company or project, respect for the craft of software
    construction, and external commitments (family pressures, socializing, etc.).'
  id: totrans-1849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们有不同的承诺程度：对旧项目的责任、对公司或项目的热情程度、对软件构建工艺的尊重，以及外部承诺（家庭压力、社交等）。
- en: Some people are highly motivated and prepared to put in hours of overtime to
    get a project finished. Others want to work their minimum hours and then go party.
  id: totrans-1850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些人高度积极，愿意加班以完成项目。其他人则只想工作最少的时长然后去参加派对。
- en: It's not just the duration of a work package that differs between programmers.
    The quality of their code, the soundness of their design, and the bug count of
    their programs will differ too. It will even differ when the same programmer attempts
    the same task multiple times—with more experience, a programmer will work better
    the second time.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 并不仅仅是工作包的持续时间在程序员之间有所不同。他们的代码质量、设计的稳健性以及程序中的错误数量也会有所不同。即使是同一位程序员尝试同一任务多次，情况也会如此——有更多经验后，程序员第二次的工作会更好。
- en: To reflect this on a project plan, check which developer each task is allocated
    to. If the task is not within his or her core competency, then increase the timescale
    estimate, or add in a block of contingency to the end. Consider putting in an
    extra up-front task to get the developer up to speed with the work, and make sure
    that you include any training that might be required.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目计划中反映这一点，检查每个任务分配给哪个开发者。如果任务不在他的或她的核心能力范围内，那么增加时间尺度估计，或者添加一个应急块到末尾。考虑添加一个额外的前置任务，让开发者熟悉工作，并确保包括可能需要的任何培训。
- en: Getting Personal
  id: totrans-1853
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**What percentage of the projects that you''ve worked on have run to schedule?**'
  id: totrans-1854
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你参与的项目中有多少比例是按计划进行的？**'
- en: '**For those that did: What contributed to the success of the planning effort?**'
  id: totrans-1855
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对于成功者：什么因素导致了规划工作的成功？**'
- en: '**For those that failed: What were the main problems?**'
  id: totrans-1856
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对于失败者：主要问题是什么？**'
- en: It's easier to characterize failure than success; you'll identify the single
    reason that something went wrong far more easily than a delicate balance of things
    working together well. When everything on a project is healthy, the whole thing
    appears to just work.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 与成功相比，描述失败更容易；你更容易找到导致某件事出错的单个原因，而不是一个事物良好协作的微妙平衡。当项目中的每一件事都健康时，整个项目看起来就像是在正常工作。
- en: Iterative and incremental development helps to accommodate problems and de-risk
    the plan. Well-understood work packages, a fine-grained plan, and a good initial
    design are also key. High-quality testing performed early and often makes development
    much safer. Talented developers are also very useful!
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代和增量开发有助于适应问题和降低计划风险。理解良好的工作包、精细的计划和良好的初始设计也是关键。早期和经常进行的高质量测试使开发更加安全。有才华的开发者也非常有用！
- en: '**How accurate are your timescale estimates? How far off target are you normally?**'
  id: totrans-1859
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的时间尺度估计有多准确？你通常偏离目标有多远？**'
- en: This is a skill that you can continually improve. Experience is a great teacher.
    Hopefully, your later estimates have been more accurate than your earlier ones.
    Is this the case?
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你可以不断改进的技能。经验是一位伟大的老师。希望你的后期估计比早期估计更准确。是这样吗？
- en: If you haven't yet been asked to make timescale estimates, start practicing
    now! Make a mini-plan for your current development task. Estimate timescales for
    the small parts of this mini-plan and see how accurate you are. This has the added
    benefit of making you think carefully about what you're doing, putting a good
    initial design into place. It will also force you to leave enough time for testing,
    debugging, and documentation—all good things.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有被要求做出时间尺度估计，现在就开始练习吧！为你的当前开发任务制定一个迷你计划。估计这个迷你计划的小部分的时间尺度，看看你有多准确。这还有一个额外的好处，就是让你仔细思考你在做什么，把良好的初始设计放在合适的位置。它还会迫使你为测试、调试和文档留出足够的时间——这些都是好事。
- en: '[Chapter 22](ch22.html "Chapter 22. RECIPE FOR A PROGRAM")'
  id: totrans-1862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章。程序配方")'
- en: Mull It Over
  id: totrans-1863
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考
- en: '**How do the choices of programming style and development process influence
    one another?**'
  id: totrans-1864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编程风格和开发过程的选择是如何相互影响的？**'
- en: They don't need to have any bearing on one another, but hopefully they're the
    kinds of things you think about together as you begin a project.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不需要相互影响，但希望它们是你开始项目时一起考虑的事情。
- en: Iterative processes are easier to implement with programming methodologies that
    support componentization—the object-oriented paradigm. Linear processes are suitable
    for all types of programming styles, but are not necessarily the best match.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代过程更适合支持组件化的编程方法——面向对象范式。线性过程适合所有类型的编程风格，但并不一定是最佳匹配。
- en: The developers' prior experiences and their personal preferences for programming
    style will have the greatest affect on these choices.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的先前经验和他们对编程风格的个人偏好将对这些选择产生最大的影响。
- en: '**Which is the best programming style?**'
  id: totrans-1868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪种编程风格是最好的？**'
- en: Trick question! If you actually gave an answer, put down this book and give
    yourself 30 lashes with a wet noodle.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个陷阱问题！如果你真的给出了答案，就把这本书放下，用湿面条打自己30下。
- en: '**Which is the best development process?**'
  id: totrans-1870
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**哪种开发过程是最好的？**'
- en: You can't possibly have fallen for this too? Electric shock therapy with a 9-volt
    battery is your only option.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能也上当了吧？用9伏电池的电击疗法是你唯一的选择。
- en: '**Where does each development process listed in this chapter fall on the classification
    axes we saw in "[Development Processes](ch22s03.html "Development Processes")"
    on page 425?**'
  id: totrans-1872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**本章中列出的每个开发过程在“[开发过程](ch22s03.html "Development Processes")”页面425上看到的分类轴上处于什么位置？**'
- en: 'First, a quick recap: The thick/thin classification relates to the bureaucracy
    and paperwork involved in a process, *sequencing* describes how linear and predictive
    the process is, and the *design direction* determines whether design starts from
    the minuscule implementation details or from the grand overview:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速回顾一下：繁杂/简洁分类与一个过程中涉及的官僚主义和文件有关，*序列*描述了过程的线性和预测性，而*设计方向*决定了设计是从微小的实现细节开始还是从宏观的概述开始：
- en: '**Ad hoc**'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时**'
- en: Who knows how to classify this mess? An ad hoc process could be anywhere on
    any axis, even constantly moving. Ad hoc developers are typically low on bureaucracy,
    but with no discipline at all, things fall through the cracks or are repeated
    time and time again. There's no sequencing whatsoever, so this anti-process rates
    off the scale, and if there *is* any design, then it probably has nothing to do
    with what is actually being built, anyway!
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道如何分类这个混乱？一个临时过程可能在任何轴上任何位置，甚至不断移动。临时开发者通常官僚主义程度较低，但完全没有纪律，事情会不断出错或反复发生。完全没有序列，所以这种反过程评分极高，而且如果真的有任何设计，那么它可能根本与实际建造的东西无关！
- en: '**Waterfall model**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '**瀑布模型**'
- en: This is a reasonably thick, very linear process. It generally leads to a top-down
    design, although it doesn't enforce this.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当繁杂、非常线性的过程。它通常导致自上而下的设计，尽管它并不强制执行这一点。
- en: '**SSADM**'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSADM**'
- en: This scores full marks on the thick scale—there's paperwork and heavily documented
    steps aplenty here. The sequencing axis is full throttle toward linear.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 在繁杂程度量表上，这里得到了满分——有大量的文件和详细记录的步骤。序列轴全速向线性发展。
- en: '**V model**'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: '**V模型**'
- en: Another thick, linear process (although some parts of this process are explicitly
    parallelized for efficiency). As with other waterfall variants, it leans toward
    top-down design.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个繁杂、线性的过程（尽管这个过程中的某些部分为了效率而明确地并行化）。与其他瀑布变体一样，它倾向于自上而下的设计。
- en: '**Prototyping**'
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型**'
- en: 'An explicitly cyclical process (although by fixing the number of prototypes
    anticipated, we can enforce some level of linearity on the development process).
    This tends to edge toward the thin camp, sometimes too much so: Prototypes by
    themselves are not sufficient to capture user requirements or design decisions,
    so when prototyping, it''s dangerously easy to avoid capturing decisions in specifications.'
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个明确循环的过程（尽管通过固定预期的原型数量，我们可以在开发过程中强制执行一定程度的线性）。这往往倾向于简洁阵营，有时过于如此：原型本身不足以捕捉用户需求或设计决策，所以在原型设计时，很容易避免在规范中捕捉决策。
- en: '**Iterative and incremental**'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代和增量**'
- en: Again nonlinear by design, this process can be as bureaucratic as you like,
    but some variants (especially as seen in the agile movement) can be quite thin.
    Iterative and incremental processes tend to stick in the middle of the design
    direction axis—at each iteration, we perform high-level design right through to
    low-level design. These design decisions are revised in the next cycle, and additional
    work repeat the top-level and bottom-level design.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上也是非线性的，这个过程可以像你喜欢的那么官僚，但某些变体（尤其是在敏捷运动中看到的）可以相当简洁。迭代和增量过程往往停留在设计方向轴的中间——在每个迭代中，我们都会从高级设计一直做到低级设计。这些设计决策将在下一个周期中修订，并且额外的工作会重复顶层和底层设计。
- en: '**Spiral model**'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: '**螺旋模型**'
- en: A thick version of an iterative and incremental process.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迭代和增量过程的繁杂版本。
- en: '**Agile methodologies**'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: '**敏捷方法**'
- en: 'Agile processes are thin and nonlinear. They do not fix a design direction;
    you are constantly redirecting the design. Compare design to driving to Paris:
    In a traditional process, you would point your car at Paris and drive; in an agile
    process, you''d start driving and make constant streering tweaks. You *might*
    even map out sections of the middle of the journey before determining the best
    route out of your hometown.'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷过程是简洁且非线性的。它们不固定设计方向；你总是在不断调整设计。将设计比作开车去巴黎：在传统过程中，你会把车头指向巴黎然后驾驶；在敏捷过程中，你会开始驾驶并不断调整方向。你甚至*可能*在确定最佳路线之前，先规划出旅程中段的路线。
- en: Remember that an organization's implementation of a specific process model will
    be inevitably tailored to its particular ways of working. (This is perfectly healthy.)
    These tweaks can make a significant difference. For example, you might base your
    development around the V model but aim to make the interphase handoff procedure
    as lightweight as possible, to reduce unnecessary bureaucracy.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个组织对特定过程模型的实施不可避免地会根据其特定的工作方式进行调整。（这是完全健康的。）这些调整可以产生重大差异。例如，你可能会基于V模型进行开发，但目标是使接口移交程序尽可能轻量，以减少不必要的官僚主义。
- en: '**If development processes and programming styles are recipes, what would a
    software development cookbook look like?**'
  id: totrans-1891
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果开发流程和编程风格是食谱，那么软件开发食谱书会是什么样子呢？**'
- en: It would probably look dangerously like a software engineering textbook. There
    probably wouldn't be that many mouth-watering pictures! Just as the Naked Chef
    's^([[17](#ftn.APP-FN-17)]) recipes differ from Rachael Ray's, you could imagine
    a number of different approaches to a mythical software development cookbook.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像一本危险的安全工程教科书。可能不会有那么多令人垂涎的图片！正如裸体厨师与拉契尔·雷的食谱不同，你可以想象出许多不同的软件开发食谱方法。
- en: You don't really see that many software development cookbooks because people
    don't shop around for new recipes that often. These things only tend to spring
    up when a marketing machine can gather sufficient momentum behind the next big
    thing.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上看不到很多软件开发食谱书，因为人们并不经常寻找新的食谱。这些事情只有在营销机器能够为下一个大事件积累足够的动力时才会出现。
- en: '**With a suitable process, can software construction become a predictable,
    repeatable task?**'
  id: totrans-1894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有了合适的过程，软件构建能否成为一个可预测、可重复的任务？**'
- en: We're still not in a position where the software industry is able to make this
    claim. No matter how hard we try to homogenize the development process, the quality
    of code produced is ultimately determined by the quality (e.g., experience, ability,
    intuition, and flair) and the particular mood (e.g., ability to concentrate, being
    in the zone or constantly interrupted, see page 414) of the programmers doing
    the work. A master craftsman will produce more elegant, robust, and well-fashioned
    designs than a fresh apprentice.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有达到软件行业能够提出这种主张的地步。无论我们多么努力地使开发过程同质化，产生的代码质量最终是由程序员的质量（例如，经验、能力、直觉和风格）以及特定的情绪（例如，集中注意力的能力、处于状态或不断被打断，见第414页）决定的。一个大师工匠将比一个新手学徒创造出更优雅、更稳健、更精致的样式。
- en: With such variance, it's hard to reproducibly create software, even with the
    most prescriptive process. Using the same programmers, the same process, and trying
    to produce the same piece of software, you'll never get the exact same result.
    On different days, the team will make different choices, which will lead to radically
    different software with different inherent faults and strengths. (This point is
    hypothetical anyway; the same team would learn from its mistakes the first time
    around and create a different—probably better—piece of software on its second
    attempt.)
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的差异下，即使是最严格的过程也难以可重复地创建软件。使用相同的程序员、相同的过程，并试图生产相同的软件，你永远不会得到完全相同的结果。在不同的日子里，团队会做出不同的选择，这会导致截然不同的软件，具有不同的固有缺陷和优势。（这个观点本身就是假设性的；同一个团队会在第一次尝试中从错误中学习，并在第二次尝试中创建一个不同——可能更好的——软件。）
- en: Agile methods exploit this, and celebrate the unpredictability of software construction.
    They attempt to address uncertainty by choosing pragmatic approaches that minimize
    the inherent risk of an unpredictable task.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法利用这一点，并庆祝软件构建的不确定性。他们通过选择实用方法来尝试解决不确定性，这些方法最大限度地减少了不可预测任务固有的风险。
- en: Getting Personal
  id: totrans-1898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人化
- en: '**What development process and programming language style are you currently
    using?**'
  id: totrans-1899
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你目前使用的是哪种开发流程和编程语言风格？**'
- en: '**Has it been formally agreed upon by the development team, or do you use it
    by convention?**'
  id: totrans-1900
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它是被开发团队正式同意的，还是你按照惯例使用它？**'
- en: '**How was it chosen? Was it chosen specifically for this project, or is it
    the recipe you always use?**'
  id: totrans-1901
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是如何选择的？是专门为这个项目选择的，还是你总是使用的食谱？**'
- en: '**Is it documented anywhere?**'
  id: totrans-1902
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**它有被记录在某个地方吗？**'
- en: '**Does the team stick to the process? When problems arise and your back is
    against the wall, do you maintain the process, or is all ivory tower theory ignored
    in a rush to produce something—anything?**'
  id: totrans-1903
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**团队是否坚持流程？当问题出现且背水一战时，你是否会坚持流程，还是在一股脑地赶制任何东西的过程中忽略了所有象牙塔理论？**'
- en: This question is probing how organized your development team is—and whether
    you develop software on purpose or by accident. Do you really *know* how you produce
    software, or do you still rely on the heroic efforts of a few key team members
    to get your work done?
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是在探究你的开发团队是否组织有序——以及你是故意还是偶然地开发软件。你真的*知道*你是如何产生软件的吗，还是你仍然依赖少数关键团队成员的英雄式努力来完成工作？
- en: Can you point to a specific reference for your way of working? Is it documented?
    Is it understood? Is it understood by *all* the developers, by *all* the process
    managers, and by *all* those who play some part in the construction process?
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否指出你工作方式的具体参考文献？它是文档化的吗？它被理解了吗？它被所有开发者、所有流程经理以及所有在构建过程中扮演一定角色的人理解了吗？
- en: '**Are your current processes and styles appropriate? Are they the best way
    for you to develop your software right now?**'
  id: totrans-1906
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你们当前的过程和风格是否合适？它们是目前开发软件的最佳方式吗？**'
- en: If you don't know how you're producing software, or if you're not using the
    best approach, what would be better, and why?
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道你是如何产生软件的，或者如果你没有使用最佳方法，什么会更好，为什么？
- en: Watch for the danger of ad hoc methods. I've seen numerous organizations where
    there is no agreed method; one person produces wholly OO designs while another
    avoids OO and performs structural design. The code produced is ugly and inconsistent.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 注意即兴方法的危险。我见过许多组织没有达成一致的方法；一个人生产完全面向对象的设计，而另一个人避免面向对象并执行结构设计。产生的代码丑陋且不一致。
- en: '**Does your organization appreciate that there are other development models
    that might be worth investigating?**'
  id: totrans-1909
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的组织是否意识到还有其他可能值得调查的开发模型？**'
- en: 'Understand who makes decisions about this kind of thing—is it the developers,
    the software team leader, or the managers? Are these people sufficiently informed
    about software development processes? Understand why they''ve chosen to work in
    the current way: what problems have they already solved? Often the reason for
    an odd development procedure is historical—organizations evolve a set of working
    practices, they don''t fashion them consciously.'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 理解谁决定这类事情——是开发者、软件团队领导还是管理者？这些人是否充分了解软件开发流程？理解他们为什么选择以当前这种方式工作：他们已经解决了哪些问题？通常，奇怪的开发流程的原因是历史性的——组织会形成一套工作实践，他们并不是有意识地创造这些实践。
- en: What would it take to persuade your organization to adopt another process model?
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 要说服你的组织采用另一种流程模型需要什么？
- en: '* * *'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#APP-FN-17)]) If you think that sounds rude, see [www.jamieoliver.com](http://www.jamieoliver.com).
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#APP-FN-17)]) 如果你认为这听起来很粗鲁，请参阅 [www.jamieoliver.com](http://www.jamieoliver.com)。
- en: '[Chapter 23](ch23.html "Chapter 23. THE OUTER LIMITS")'
  id: totrans-1914
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[第23章](ch23.html "第23章。极限之外")'
- en: Mull It Over
  id: totrans-1915
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仔细思考
- en: '**Which of the programming niches we''ve looked at here are particularly similar
    or share common characteristics? Which are particularly different?**'
  id: totrans-1916
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我们在这里探讨的编程细分市场中，哪些特别相似或具有共同特征？哪些特别不同？**'
- en: 'There is more in common than you might think. Crossovers include:'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 共同之处比你想象的要多。交叉点包括：
- en: Games and web applications could both be considered specific forms of applications
    programming.
  id: totrans-1918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏和网络应用都可以被认为是特定形式的应用程序编程。
- en: Web programming is a form of distributed programming.
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程是一种分布式编程。
- en: Some enterprise work can take the form of web applications.
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些企业工作可以采取网络应用的形式。
- en: Some systems implementation is for embedded platforms.
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些系统实现是为嵌入式平台。
- en: Numerical work is sometimes optimized by parallelizing and distributing the
    computation.
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值工作有时通过并行化和分布计算来优化。
- en: '**Which of these programming disciplines is hardest?**'
  id: totrans-1923
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**这些编程学科中哪一个是最难的？**'
- en: Each type of programming presents a different set problems, and every individual
    program is complex in its own way. Otherwise, programming would take very little
    skill and any idiot could do it. (The fact that many idiots *do* program doesn't
    bear discussion here!)
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程类型都呈现不同的问题，每个程序都是以其独特的方式复杂的。否则，编程将不需要太多技能，任何傻瓜都能做到。（许多傻瓜确实编程的事实在这里不予讨论！）
- en: The "harder" programming worlds could be considered to be the ones that demand
    more formal processes to ensure adequate quality is met. For example, the world
    of safety-critical software (mentioned in "[In a Nutshell](ch23s10.html "In a
    Nutshell")" on page 456) is particularly fraught. Watertight specifications, very
    formal development and testing models, and certification to regulated standards
    are essential in this world, along with the inclusion of reliable failsafes.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为“更困难”的编程领域是那些要求更多正式流程以确保达到足够质量的地方。例如，安全关键软件的世界（在第456页的"[In a Nutshell](ch23s10.html
    "In a Nutshell")"中提到）尤其充满挑战。在这个世界中，严密的规格说明、非常正式的开发和测试模型，以及对监管标准的认证是必不可少的，同时还需要包括可靠的保险丝。
- en: Numerical work, in particular, would be hard for someone who doesn't have a
    head for math and designing complex algorithms. It requires extra statistical
    or scientific skills.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有数学头脑和设计复杂算法的人来说，数值工作尤其困难。它需要额外的统计或科学技能。
- en: '**Is it important to be an expert in one particular area or to have a good
    grounding in all of them without a particular specialism?**'
  id: totrans-1927
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**是否重要成为某一特定领域的专家，或者在没有特定专业的情况下对所有领域都有良好的基础？**'
- en: An understanding of each area is helpful. However, to truly excel in a given
    area requires specific skills and expertise that can only be gained from experience
    in the trenches. To get this good experience, you'll probably have to focus on
    one particular work area. Vincent van Gogh remarked, "If one is the master of
    one thing and understands one thing well, one has at the same time insight into
    and understanding of many things." Learn the particular intricacies that set your
    discipline apart from the others.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 理解每个领域都有帮助。然而，要在某个特定领域真正出类拔萃，需要特定的技能和专业知识，这些只能从战场上的经验中获得。为了获得这种良好的经验，你可能必须专注于一个特定的工作领域。文森特·梵高曾说过：“如果一个人精通一件事，并且对这件事有深刻的理解，那么他同时也会对许多事物有洞察力和理解。”学习使你的学科与其他学科区分开来的特定复杂性。
- en: '**Which programming niche should trainee programmers be introduced to?**'
  id: totrans-1929
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应该向培训程序员介绍哪个编程细分领域？**'
- en: This is seldom thought about by the writers of programming courses. It's a sad
    oversight; many courses are not tailored to programming in the Real World—more
    to some theoretical, androgynous branch of programming. Of course, this makes
    teaching programming much easier, and there are fewer issues to confuse the trainee
    with. But it is important to understand how to make appropriate coding choices
    when you're in the thick of the software factory, and someone has to teach this.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很少被编程课程的设计者所考虑。这是一个令人遗憾的疏忽；许多课程并没有针对现实世界的编程进行定制——更多的是针对一些理论上的、中性的编程分支。当然，这使得教授编程变得更加容易，并且减少了让学员感到困惑的问题。但是，当你身处软件工厂的繁忙之中时，了解如何做出适当的编码选择是非常重要的，而且有人必须教授这一点。
- en: Compared to the other programming areas, applications programming is relatively
    unencumbered by specific rituals and practices, so this is presumably the easiest
    area to introduce programmers to. Because trainees rarely appreciate the wider
    world of software development, this is probably what they'd expect to learn anyway.
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程领域相比，应用程序编程相对不受特定仪式和实践的束缚，因此这可能是向程序员介绍的最容易的领域。由于学员很少欣赏软件开发更广阔的世界，这可能是他们期望学习的内容。
- en: Getting Personal
  id: totrans-1932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 个人见解
- en: '**What programming arena are you working in right now? How does it affect the
    code that you''re writing? What specific design and implementation decisions has
    it led you to make?**'
  id: totrans-1933
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你现在在哪个编程领域工作？这对你的代码有什么影响？它引导你做出了哪些具体的设计和实现决策？**'
- en: It's important to understand the type of code you write so you can make the
    correct programming decisions. If you can't explain how your code has been shaped
    by the demands of the problem domain, then you may not have been thinking hard
    enough about what you're doing. Software has to survive in—and must therefore
    be shaped by—its environment.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 理解你编写的代码类型很重要，这样你才能做出正确的编程决策。如果你无法解释你的代码是如何被问题域的需求所塑造的，那么你可能没有足够深入地思考你所做的事情。软件必须在其环境中生存——因此必须由其环境来塑造。
- en: '**Do you have experience working in more than one programming discipline? How
    easy was it for you to switch mindsets and apply appropriate techniques in a different
    world?**'
  id: totrans-1935
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你在多个编程领域工作过吗？你切换思维模式和在不同领域应用适当技术有多容易？**'
- en: Be careful of the temptation to dismiss these differences and hop thoughtlessly
    from one domain to another. It can lead you to write bad code. You probably won't
    realize that your code isn't appropriate until the end of the game, when you're
    working on tedious bugs or trying to optimize your system to get it to meet the
    original requirements (e.g., code size or scalability). If that's when you realize
    your work isn't molded to its environment, then you're in a sticky position.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 小心忽视这些差异，毫无目的地从一个领域跳到另一个领域。这可能导致你编写出糟糕的代码。你可能直到游戏结束，当你正在处理乏味的错误或试图优化你的系统以满足原始要求（例如，代码大小或可扩展性）时，才会意识到你的代码不适合其环境。如果你那时意识到你的工作没有适应其环境，那么你将处于困境之中。
- en: '**Are any of the people you work with unaware of the forces that shape the
    particular kind of code you write? Do you have embedded software being written
    by programmers who only understand applications work? What can you do about this?**'
  id: totrans-1937
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你工作中是否有人不了解塑造你所写代码特定类型的力？是否有由只理解应用程序工作的程序员编写的嵌入式软件？你能做些什么？**'
- en: Programmers who don't tailor their work to the requirements of the problem domain
    endanger your project. If they don't understand the inherent constraints (scalability,
    performance, code size, interoperability, and so on), their code will not match
    the specifications, and they will be weak links in the development chain.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 没有根据问题域的要求调整其工作的程序员会危害你的项目。如果他们不理解固有的约束（可扩展性、性能、代码大小、互操作性等），他们的代码将不符合规范，并且将成为开发链中的薄弱环节。
- en: Code and design review will help to catch this, as would pair programming.
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和设计审查将有助于捕捉这一点，正如结对编程一样。
- en: BIBLIOGRAPHY
  id: totrans-1940
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BIBLIOGRAPHY
- en: (Alexander 79) AlexanderChristopher. The Timeless Way of Building. Oxford University
    Press, 1979. 0195024028.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: (Alexander 79) 亚历山大，克里斯托弗。 《永恒的建筑方式》。牛津大学出版社，1979. 0195024028。
- en: (Aristotle) Aristotle (384-322 bc). Rhetoric. Book 1, Chapter 11, Section 20\.
    350 bc.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: (Aristotle) 亚里士多德（公元前384-322年）。《修辞学》。第1卷，第11章，第20节。公元前350年。
- en: (Beck 99) BeckKent. Extreme Programming Explained. Addison-Wesley, 1999. 0201616416.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: (Beck 99) 贝克，肯特. 《极限编程之道》. 阿迪森-韦斯利出版社，1999. 0201616416.
- en: '(Belbin 81) BelbinMeredith. Management Teams: Why They Succeed or Fail. Butterworth
    Heinemann, 1981. 0750659106.'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: (Belbin 81) 贝尔宾，梅雷迪思。 《管理团队：为什么他们成功或失败》。巴特沃斯·海尼曼出版社，1981. 0750659106。
- en: (Bentley 82) BentleyJon Louis. Writing Efficient Programs. Prentice Hall Professional,
    1982. 013970244X.
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: (Bentley 82) 伯顿，乔恩·路易斯。 《编写高效程序》。普伦蒂斯·霍尔专业出版社，1982. 013970244X。
- en: '(Bersoff et al. 80) BersoffEdwardVilas HendersonStanley Siegel. Software Configuration
    Management: An Investment in Product Integrity. Longman Higher Education, 1980.
    0138217696.'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: (Bersoff et al. 80) 贝尔索夫，爱德华；维尔拉斯·亨德森；斯坦利·西格尔。 《软件配置管理：产品完整性的投资》。朗曼高等教育出版社，1980.
    0138217696.
- en: (Boehm 76) BoehmBarry. "Software Engineering." IEE Transactions on Computers.
    C-25, 12, 1,226-1,241. 1976. http://www.computer.org/tc.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: (Boehm 76) 博姆，巴里。 "软件工程。" 《IEEE计算机 Transactions on Computers》。C-25，12，1，226-1，241.
    1976. http://www.computer.org/tc.
- en: (Boehm 81) BoehmBarry. Software Engineering Economics. Prentice Hall, 1981.
    0138221227.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: (Boehm 81) 博姆，巴里。 《软件工程经济学》。普伦蒂斯·霍尔出版社，1981. 0138221227。
- en: (Boehm 87) BoehmBarry. "Improving Software Productivity." IEEE computer, 20,
    9. 1987.
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: (Boehm 87) 博姆，巴里。 "提高软件生产力。" 《IEEE计算机》，20，9. 1987.
- en: (Boehm 88) BoehmBarry. "A Spiral Model of Software Development and Enhancement."
    IEEE computer, 21. May 5, 1988.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: (Boehm 88) 博姆，巴里。 "软件开发与增强的螺旋模型。" 《IEEE计算机》，21. 1988年5月5日。
- en: (Booch 97) BoochGrady. Object Oriented Analysis and Design With Applications.
    Benjamin/Cummings, 1994. Second Edition. 0805353402.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: (Booch 97) 博och，格雷迪. 《面向对象分析与设计应用》. 本杰明/坎明斯出版社，1994. 第二版. 0805353402.
- en: '(Briggs 80) Briggs MyersIsabel. Gifts Differing: Understanding Personality
    Type. Consulting Psychologist''s Press, 1980. 0891060111.'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: (Briggs 80) 布里格斯，迈尔斯；伊莎贝尔·迈尔斯。 《不同的礼物：理解人格类型》。咨询心理学家出版社，1980. 0891060111。
- en: (Brooks 95) BrooksFrederick P. Jr. The Mythical Man Month. Addison-Wesley, 1995.
    Anniversary Edition. 0201835959.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: (Brooks 95) 布鲁克斯，弗雷德里克·P. 小. 《人月神话》. 阿迪森-韦斯利出版社，1995. 周年纪念版. 0201835959.
- en: '(DeMarco 99) DeMarcoTomTimothy Lister. Peopleware: Productive Projects and
    Teams. Dorset House, 1999. Second Edition. 0932633439.'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: (DeMarco 99) 德马克，汤姆·蒂莫西·利斯特. 《人件：高效的项目与团队》. 多塞特出版社，1999. 第二版. 0932633439.
- en: (Dijkstra 68) DijkstraEdsger W. "Go To Statement Considered Harmful." Communications
    of the ACM, 11, 3, 147-148. 1968.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: (Dijkstra 68) 迪杰斯特拉，埃德加·W. "goto语句有害。" 《ACM通讯》，11，3，147-148. 1968.
- en: (Doxygen) van HeeschDimitri. Doxygen. http://www.doxygen.org.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: (Doxygen) 范希施，迪米特里。 Doxygen。 http://www.doxygen.org.
- en: (Economist 01) "Agility counts." The Economist. September 20, 2001.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: (Economist 01) "敏捷很重要。" 《经济学人》。2001年9月20日。
- en: (Fagan 76) FaganMichael. "Design and code inspections to reduce errors in program
    development." IBM Systems Journal, 15, 3. 1976.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: (Fagan 76) FaganMichael. "Design and code inspections to reduce errors in program
    development." IBM Systems Journal, 15, 3. 1976.
- en: (Feldman 78) FeldmanStuart. "Make—A Program for Maintaining Computer Programs."
    Bell Laboratories Computering Science Technical Report 57. 1978.
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: (Feldman 78) FeldmanStuart. "Make—A Program for Maintaining Computer Programs."
    Bell Laboratories Computering Science Technical Report 57. 1978.
- en: '(Fowler 99) FowlerMartin. Refactoring: Improving the Design of Existing Code.
    Addison-Wesley, 1999. 0201485672.'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: (Fowler 99) FowlerMartin. 《重构：现有代码设计改进》。Addison-Wesley, 1999. 0201485672.
- en: '(Gamma et al. 94) GammaErichRichard HelmRalph JohnsonJohn Vlissides. Design
    Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1994.
    0201633612.'
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: (Gamma et al. 94) GammaErichRichard HelmRalph JohnsonJohn Vlissides. 《设计模式：可重用面向对象软件元素》。Addison-Wesley,
    1994. 0201633612.
- en: (Gosling et al. 94) GoslingJamesBill JoyGuy SteeleGilad Bracha. The Java Language
    Specification. Addison-Wesley, 2000. Second Edition. 0201310082\. http://java.sun.com.
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: (Gosling et al. 94) GoslingJamesBill JoyGuy SteeleGilad Bracha. 《Java语言规范》。Addison-Wesley,
    2000. 第二版。0201310082\. http://java.sun.com.
- en: (Gould 75) GouldJohn. "Some Psychological Evidence on How People Debug Computer
    Programs." International Journal of Man-Machine Studies. 1975.
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: (Gould 75) GouldJohn. "Some Psychological Evidence on How People Debug Computer
    Programs." International Journal of Man-Machine Studies. 1975.
- en: (Groom 94) GroomWinston. Forrest Gump. Black Swan, 1994. 0552996092.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: (Groom 94) GroomWinston. 《阿甘正传》。Black Swan, 1994. 0552996092.
- en: (Hoare 81) HoareCharles. "The Emperor's Old Clothes." Communications of the
    ACM, 24, 2. ACM, 1981.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: (Hoare 81) HoareCharles. "The Emperor's Old Clothes." Communications of the
    ACM, 24, 2. ACM, 1981.
- en: (Humphrey 97) HumphreyWatts S. Introduction to the Personal Software Process.
    Addison-Wesley, 1997. 0201548097.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: (Humphrey 97) HumphreyWatts S. 《个人软件过程导论》。Addison-Wesley, 1997. 0201548097.
- en: (Humphrey 98) HumphreyWatts S. "The Software Quality Profile." Software Quality
    Professional. December 1998. http://www.sei.cmu.edu/publications/articles/quality-profile/.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: (Humphrey 98) HumphreyWatts S. "The Software Quality Profile." Software Quality
    Professional. December 1998. http://www.sei.cmu.edu/publications/articles/quality-profile/.
- en: (Hunt Davis 99) HuntAndrewDavid Thomas. The Pragmatic Programmer. Addison-Wesley,
    1999. 020161622X.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: (Hunt Davis 99) HuntAndrewDavid Thomas. 《实用程序员》。Addison-Wesley, 1999. 020161622X.
- en: (IEEE 84) IEEE Standard Glossary of Software Engineering Terminology. ANSI/IEEE,
    1984. ANSI/IEEE Standard 729.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: (IEEE 84) IEEE标准软件工程术语词汇表。ANSI/IEEE, 1984. ANSI/IEEE标准 729.
- en: (ISO 84) ISO7498:1984(E) Information Processing Systems—Open Systems Interconnection—Basic
    Reference Model. International Standard for Information Systems, 1984. ISO Standard
    ISO 7498:1984(E).
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: (ISO 84) ISO7498:1984(E) 信息处理系统—开放系统互联—基本参考模型。信息系统国际标准，1984. ISO标准 ISO 7498:1984(E).
- en: (ISO 98) ISO/IEC 14882:1998, Programming Languages—C++. International Standard
    for Information Systems, 1998. ISO Standard ISO/IEC 14882:1998.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: (ISO 98) ISO/IEC 14882:1998, 编程语言—C++. 信息系统国际标准，1998. ISO标准 ISO/IEC 14882:1998.
- en: (ISO 99) ISO/IEC 9899:1999, Programming Languages—C. International Standard
    for Information Systems, 1999. ISO Standard ISO/IEC 9899:1999.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: (ISO 99) ISO/IEC 9899:1999, 编程语言—C. 信息系统国际标准，1999. ISO标准 ISO/IEC 9899:1999.
- en: (ISO 05) ISO/IEC 23270:2003, Information technology—C# Language Specification.
    International Standard for Information Systems, 2005. ISO Standard ISO/IEC 23270:2003.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: (ISO 05) ISO/IEC 23270:2003, 信息技术—C#语言规范。信息系统国际标准，2005. ISO标准 ISO/IEC 23270:2003.
- en: (Jackson 75) JacksonM.A. Principles of Program Design. Academic Press, 1975.
    0123790506.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: (Jackson 75) JacksonM.A. 《程序设计原理》。Academic Press, 1975. 0123790506.
- en: (Javadoc) Javadoc. Sun Microsystems, Inc. http://java.sun.com/products/jdk/javadoc".
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: (Javadoc) Javadoc. Sun Microsystems, Inc. http://java.sun.com/products/jdk/javadoc".
- en: (Kernighan Pike 99) KernighanBrian W.Rob Pike. The Practice of Programming.
    Addison-Wesley, 1999. 020161586X.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: (Kernighan Pike 99) KernighanBrian W.Rob Pike. 《程序实践》。Addison-Wesley, 1999.
    020161586X.
- en: (Kernighan Plaugher 76) KernighanBrian W.P.J. Plaugher. Software Tools. Addison-Wesley,
    1976. 020103669X.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: (Kernighan Plaugher 76) KernighanBrian W.P.J. Plaugher. 软件工具. Addison-Wesley,
    1976. 020103669X.
- en: (Kernighan Plaugher 78) KernighanBrian W.P.J. Plaugher. The Elements of Programming
    Style. McGraw-Hill, 1978. 0070341990.
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: (Kernighan Plaugher 78) KernighanBrian W.P.J. Plaugher. 《程序设计风格》。McGraw-Hill,
    1978. 0070341990.
- en: (Kernighan Ritchie 88) KernighanBrian W.Dennis M.Ritchie. The C Programming
    Language. Prentice Hall, 1988. Second Edition. 0131103628.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: (Kernighan Ritchie 88) KernighanBrian W.Dennis M.Ritchie. 《C程序设计语言》。Prentice
    Hall, 1988. 第二版。0131103628.
- en: (Knuth 92) KnuthDonald. Literate Programming. CSLI Publications, 1992. 0937073806.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: (Knuth 92) KnuthDonald. 《文献编程》。CSLI Publications, 1992. 0937073806.
- en: (Kurlansky 99) KurlanskyMark. The Basque History of the World. Jonathan Cope,
    1999. 0224060554.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: (Kurlansky 99) KurlanskyMark. 《巴斯克世界史》。Jonathan Cope, 1999. 0224060554.
- en: (McConnell 96) McConnellSteve. Rapid Development. Microsoft Press, 1996. 1556159005.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: (McConnell 96) McConnellSteve. 《快速开发》。Microsoft Press，1996. 1556159005.
- en: '(McConnell 04) McConnellSteve. Code Complete: A Practical Handbook of Software
    Construction. Microsoft Press, 2004. Second Edition. 0735619670.'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: (McConnell 04) McConnellSteve. 《软件构造实用手册》。Microsoft Press，2004. 第二版。0735619670.
- en: '(Meyers 97) MeyersScott. Effective C++. Addison-Wesley, 1997. Item 34: Minimize
    complication dependencies between files. 0201924889.'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: (Meyers 97) MeyersScott. 《Effective C++》。Addison-Wesley，1997. 条目34：最小化文件间的复杂性依赖。0201924889.
- en: '(Miller 56) MillerGeorge A. "The Magical Number Seven, Plus or Minus Two: Some
    Limits on our Capacity for Processing Information." First published in Psychological
    Review, 63, 81-97. 1956.'
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: (Miller 56) MillerGeorge A. "神奇的数字七，加减二：我们处理信息能力的某些限制。" 首次发表于《心理学评论》，63, 81-97.
    1956.
- en: (Myers 86) MyersWare. "Can software for the Strategic Defense Initiative ever
    be error-free?" IEEE computer. 19, 10, 61-67. 1986.
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: (Myers 86) MyersWare. "软件战略防御倡议的软件能否永远无错误?" IEEE计算机. 19, 10, 61-67. 1986.
- en: (Page Jones 96) Page-JonesMeilir. What Every Programmer Should Know About Object-oriented
    Design. Dorset House Publishing Co., 1996. 0932633315.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: (Page Jones 96) Page-JonesMeilir. 《每个程序员都应该了解的面向对象设计》。Dorset House Publishing
    Co.，1996. 0932633315.
- en: (Royce 70) RoyceW.W. "Managing the Development of Large Software Systems." Proceedings
    of IEEE WESCON, August 1970.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: (Royce 70) RoyceW.W. "大型软件开发管理。" IEEE WESCON会议论文集，1970年8月。
- en: (Simpsons 91) Simpsons, The. "Do the Bart Man." Geffen, 1991. GEF87CD.
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: (Simpsons 91) Simpsons, The. "Do the Bart Man." Geffen，1991. GEF87CD.
- en: (Stroustrup 97) StroustrupBjarne. The C++ Programming Language. Addison-Wesley,
    1997. Third Edition. 0-201-88954-4.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: (Stroustrup 97) StroustrupBjarne. 《C++编程语言》。Addison-Wesley，1997. 第三版。0-201-88954-4.
- en: (UML) Unified Modeling Language. Object Management Group. http://www.uml.org.
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: (UML) 统一建模语言。对象管理组。http://www.uml.org.
- en: (Vitruvius) Vitruvius PollioMarcus (c. 70-25 bc). De Architectura. Book 1, Chapter
    3, Section 2.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: (Vitruvius) Vitruvius PollioMarcus (约公元前70-25年). 《建筑十书》。第1卷，第3章，第2节。
- en: (Weinberg 71) WeinbergGerald. The Psychology Of Computer Programming. Van Nostrand
    Reinhold, 1971. 0932633420.
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: (Weinberg 71) WeinbergGerald. 《计算机编程心理学》。Van Nostrand Reinhold，1971. 0932633420.
- en: (Wulf 72) WulfWilliam A. "A Case Against the GOTO." Proceedings of the twenty-fifth
    National ACM Conference, 1972.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: (Wulf 72) WulfWilliam A. "反对GOTO语句。" 第二十五届全国ACM会议论文集，1972年。
