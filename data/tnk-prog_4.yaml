- en: Chapter 4. Solving Problems with Pointers and Dynamic Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 使用指针和动态内存解决问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: In this chapter, we’ll learn to solve problems using pointers and dynamic memory,
    which will allow us to write flexible programs that can accommodate data sizes
    that are unknown until the program runs. Pointers and dynamic memory allocation
    are “hard-core” programming. When you can write programs that grab blocks of memory
    on the fly, link them into useful structures, and clean up everything at the end
    so there is no residue, you’re not just someone who can do a little coding—you’re
    a programmer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用指针和动态内存解决问题，这将使我们能够编写灵活的程序，以适应程序运行时才知道的数据大小。指针和动态内存分配是“核心”编程。当你能够动态地获取内存块，将它们链接成有用的结构，并在结束时清理一切，以确保没有残留物时，你不仅仅是一个会写点代码的人——你是一个程序员。
- en: Because pointers are tricky, and because many popular languages, such as Java,
    appear to forgo the use of pointers, some fledgling programmers will convince
    themselves that they can skip this subject entirely. This is a mistake. Pointers
    and indirect memory access will always be used in advanced programming, even though
    they may be hidden by the mechanisms of a high-level language. Therefore, to truly
    think like a programmer, you have to be able to think your way through pointers
    and pointer-based problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针很复杂，并且许多流行的语言，如Java，似乎放弃了指针的使用，一些初学者程序员会说服自己可以完全跳过这个主题。这是一个错误。指针和间接内存访问将在高级编程中始终被使用，即使它们可能被高级语言机制所隐藏。因此，为了真正像程序员一样思考，你必须能够通过指针和基于指针的问题进行思考。
- en: Before we get down to solving pointer problems, though, we’re going to carefully
    examine all aspects of how pointers work, both on the surface and behind the scenes.
    This study provides two benefits. First, this knowledge will allow us to make
    the most effective use of pointers. Second, by dispelling the mysteries of pointers,
    we can employ them with confidence.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手解决指针问题之前，我们将仔细检查指针工作的所有方面，包括表面和幕后。这项研究提供了两个好处。首先，这些知识将使我们能够最有效地使用指针。其次，通过消除指针的神秘感，我们可以有信心地使用它们。
- en: Review of Pointer Fundamentals
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针基础回顾
- en: As with topics covered in previous chapters, you should have had some exposure
    to basic pointer use, but to make sure we’re on the same page, here’s a quick
    review.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面章节中介绍的主题一样，你应该已经接触过基本指针的使用，但为了确保我们处于同一页面上，这里有一个快速回顾。
- en: 'Pointers in C++ are indicated with an asterisk (`*`). Depending on the context,
    the asterisk indicates either that a pointer is being declared or that we mean
    the pointed-to memory, not the pointer itself. To declare a pointer, we place
    the asterisk between the type name and the identifier:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的指针用星号（`*`）表示。根据上下文，星号表示正在声明一个指针，或者我们指的是被指向的内存，而不是指针本身。要声明一个指针，我们在类型名和标识符之间放置星号：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This declares the variable `intPointer` as a pointer to an `int`. Note that
    the asterisk binds with the identifier, not the type. In the following, `variable1`
    is a pointer to an `int`, but `variable2` is just an `int`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量`intPointer`声明为一个指向`int`的指针。请注意，星号与标识符绑定，而不是与类型绑定。在下面的例子中，`variable1`是一个指向`int`的指针，但`variable2`只是一个`int`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An ampersand in front of a variable acts as the *address-of* operator. So we
    could assign the address of `variable2` to `variable1` with:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 变量前的符号“&”充当“地址-of”操作符。因此，我们可以将`variable2`的地址赋给`variable1`，如下所示：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also assign the value of one pointer variable to another directly:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接将一个指针变量的值赋给另一个指针变量：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perhaps most importantly, we can allocate memory during runtime that can be
    accessed only through a pointer. This is accomplished with the `new` operator:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也许是更重要的是，我们可以在运行时分配内存，并且只能通过指针访问。这是通过`new`操作符实现的：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Accessing the memory at the other end of the pointer is known as *dereferencing*
    and is accomplished with an asterisk to the left of a pointer identifier. Again,
    this is the same placement we would use for a pointer declaration. The context
    makes the meaning different. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问指针另一端的内存称为“解引用”，并且通过在指针标识符左侧使用星号来实现。同样，这也是我们用于指针声明的相同位置。上下文使意义不同。以下是一个例子：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We assign a value to the double allocated by the previous code ![](httpatomoreillycomsourcenostarchimages1273182.png)
    before copying the value from this memory location to the variable `localDouble`
    ![](httpatomoreillycomsourcenostarchimages1273191.png).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值从该内存位置复制到变量`localDouble`之前，我们给之前代码分配的`double`变量赋值 ![图片](http://atomoreilly.com/source/no_starch_images/1273182.png)
    ![图片](http://atomoreilly.com/source/no_starch_images/1273191.png)。
- en: 'To deallocate memory allocated with `new`, once we no longer need it, we use
    the keyword `delete`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了释放使用`new`分配的内存，一旦我们不再需要它，我们使用关键字`delete`：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The mechanics of this process are described in detail in [Memory Matters](ch04.html#memory_matters
    "Memory Matters") in [Memory Matters](ch04.html#memory_matters "Memory Matters").
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的机制在[内存问题](ch04.html#memory_matters "内存问题")中详细描述，在[内存问题](ch04.html#memory_matters
    "内存问题")中。
- en: Benefits of Pointers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针的好处
- en: 'Pointers give us abilities not available with static memory allocation and
    also provide new opportunities for efficient use of memory. The three main benefits
    of using pointers are:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 指针赋予我们静态内存分配所不具备的能力，同时也提供了高效使用内存的新机会。使用指针的三个主要好处是：
- en: Runtime-sized data structures
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时大小的数据结构
- en: Resizable data structures
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变大小的数据结构
- en: Memory sharing
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存共享
- en: Let’s take a look at each of these in a bit more detail.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些内容。
- en: Runtime-Sized Data Structures
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时大小的数据结构
- en: By using pointers, we can make an array with a size determined at runtime, rather
    than having to choose the size before building our application. This saves us
    from having to choose between potentially running out of space in the array and
    making the array as large as could possibly be needed, thereby wasting much of
    the array space in the average case. We first saw runtime data sizing in [Deciding
    When to Use Arrays](ch03.html#deciding_when_to_use_arrays "Deciding When to Use
    Arrays") in [Deciding When to Use Arrays](ch03.html#deciding_when_to_use_arrays
    "Deciding When to Use Arrays"). We’ll use this concept later in this chapter,
    in [Variable-Length Strings](ch04.html#variable-length_strings "Variable-Length
    Strings") in [Solving Pointer Problems](ch04.html#solving_pointer_problems "Solving
    Pointer Problems").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用指针，我们可以创建一个在运行时确定大小的数组，而不是在构建我们的应用程序之前就必须选择大小。这使我们免于在数组可能空间不足和使数组尽可能大之间做出选择，从而在平均情况下浪费大量数组空间。我们第一次在[何时使用数组](ch03.html#deciding_when_to_use_arrays
    "何时使用数组")中看到了运行时数据大小，在[何时使用数组](ch03.html#deciding_when_to_use_arrays "何时使用数组")中。我们将在本章后面使用这个概念，在[可变长度字符串](ch04.html#variable-length_strings
    "可变长度字符串")和[解决指针问题](ch04.html#solving_pointer_problems "解决指针问题")中。
- en: Resizable Data Structures
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变大小的数据结构
- en: We can also make pointer-based data structures that grow or shrink during runtime
    as needed. The most basic resizable data structure is the linked list, which you
    may have already seen. Although the data in the structure can be accessed only
    in sequential order, the linked list always has just as many places for data as
    it has data itself, with no wasted space. Other, more elaborate pointer-based
    data structures, as you will see later, have orderings and “shapes” that can reflect
    the relationship of the underlying data better than an array can. Because of this,
    even though an array offers full random-access that no pointer-based structure
    offers, the *retrieval* operation (where we find the element in the structure
    that best meets a certain criterion) can be much faster with a pointer-based structure.
    We’ll use this benefit later in this chapter to create a data structure for student
    records that grows as needed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建在运行时根据需要增长或缩小的基于指针的数据结构。最基本的可变大小数据结构是链表，你可能已经见过。尽管结构中的数据只能按顺序访问，但链表总是有与数据本身一样多的数据位置，没有浪费的空间。你将在后面看到的其他更复杂基于指针的数据结构，它们具有排序和“形状”，可以比数组更好地反映底层数据的关系。正因为如此，尽管数组提供了指针结构无法提供的完全随机访问，但*检索*操作（我们在结构中找到最符合一定标准的元素）在基于指针的结构中可以更快。我们将在本章后面利用这个优势创建一个按需增长的学生记录数据结构。
- en: Memory Sharing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存共享
- en: 'Pointers can improve program efficiency by allowing memory blocks to be shared.
    For example, when we call a function, we can pass a pointer to a block of memory
    instead of passing a copy of the block using *reference parameters*. You’ve most
    likely seen these before; they are parameters in which an ampersand (&) appears
    between the type and the name in the formal parameter list:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以通过允许内存块共享来提高程序效率。例如，当我们调用一个函数时，我们可以传递一个内存块的指针而不是使用*引用参数*传递该块的副本。你很可能之前见过这些；它们是形式参数列表中类型和名称之间出现&符号的参数：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The spaces shown before and after the ampersand symbol are not required—I just
    include them here for aesthetic reasons. In other developers’ code, you may see
    `int& x`, `int &x`, or perhaps even `int&x`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在&符号前后显示的空格不是必需的——我只是为了美观而包括它们。在其他开发者的代码中，你可能看到`int& x`、`int &x`，甚至可能是`int&x`。
- en: 'In this code, the formal parameter `x` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    is not a copy of the argument `number` ![](httpatomoreillycomsourcenostarchimages1273193.png);
    rather, it is a reference to the memory where `number` is stored. Therefore, when
    `x` is changed ![](httpatomoreillycomsourcenostarchimages1273191.png), the memory
    space for `number` is changed, and the output at the end of the code snippet is
    `10` ![](httpatomoreillycomsourcenostarchimages1273195.png). Reference parameters
    can be used as a mechanism to send values out of a function, as shown in this
    example. More broadly, reference parameters allow the called function and the
    calling function to share the same memory, thus lowering overhead. If a variable
    being passed as a parameter occupies a kilobyte of memory, passing the variable
    as a reference means copying a 32- or 64-bit pointer instead of the kilobyte.
    We can signal that we are using a reference parameter for performance, not its
    output, by using the `const` keyword:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，形式参数`x` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)
    并不是`number` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273193.png)
    参数的副本；相反，它是对存储`number`的内存的引用。因此，当`x`被修改 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png)
    时，`number`的内存空间也会改变，并且代码片段末尾的输出是`10` ![图片链接](http://atomoreilly.com/source/nostarch/images/1273195.png)。引用参数可以用作将值从函数中传出的机制，如本例所示。更广泛地说，引用参数允许被调用的函数和调用函数共享相同的内存，从而降低开销。如果一个作为参数传递的变量占用1千字节内存，那么以引用传递变量意味着复制一个32位或64位指针而不是1千字节。我们可以通过使用`const`关键字来表示我们正在使用引用参数以性能为目的，而不是输出：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By prefixing the word `const` in the declaration of the reference parameter
    `x`, `anotherFunction` will receive a reference to the argument passed in the
    call but will be unable to modify the value in that argument, just like any other
    `const` parameter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在引用参数`x`的声明前加上`const`，`anotherFunction`将接收调用中传递的参数的引用，但将无法修改该参数中的值，就像任何其他`const`参数一样。
- en: In general, we can use pointers in this way to allow different parts of a program,
    or different data structures within the program, to have access to the same data
    without the overhead of copying.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以这样使用指针，允许程序的不同部分或程序内部的不同数据结构访问相同的数据，而无需复制带来的开销。
- en: When to Use Pointers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用指针
- en: As we discussed with arrays, pointers have potential drawbacks and should be
    used only when appropriate. How do we know when pointer use is appropriate? Having
    just listed the benefits of pointers, we can say that pointers should be used
    only when we require one or more of their benefits. If your program needs a structure
    to hold an aggregate of data, but you can’t accurately estimate how much data
    ahead of runtime; if you need a structure that can grow and shrink during execution;
    or if you have large objects or other blocks of data being passed around your
    program, pointers may be the way to go. In the absence of any of these situations,
    though, you should be wary of pointers and dynamic memory allocation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论数组时提到的，指针有潜在的缺点，并且只有在适当的情况下才应使用。我们如何知道何时使用指针是合适的呢？在刚刚列出了指针的好处之后，我们可以说，指针应该只在需要其一个或多个好处时使用。如果你的程序需要一个结构来存储数据聚合，但你无法在运行时之前准确估计数据量；或者你需要一个在执行过程中可以增长和缩小的结构；或者如果你有大型对象或其他数据块在程序中传递，指针可能是可行的。然而，在没有这些情况的情况下，你应该对指针和动态内存分配持谨慎态度。
- en: 'Given pointers’ notorious reputation as one of the most difficult C++ features,
    you might think that no programmer would ever try to use a pointer when it isn’t
    necessary. I have been surprised many times, however, to find otherwise. Sometimes
    programmers simply trick themselves into thinking a pointer is required. Suppose
    you are making a call to a function written by someone else, from a library or
    application programming interface, perhaps, with the following prototype:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到指针臭名昭著的声誉，作为C++中最难用的特性之一，你可能会认为没有程序员会在不必要的时候尝试使用指针。然而，我多次惊讶地发现并非如此。有时程序员只是欺骗自己认为需要指针。假设你正在调用一个由其他人编写的函数，可能是从库或应用程序编程接口中，其原型如下：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We might imagine that this function is written in C, not C++, and that is why
    it uses a pointer rather than a reference (`&`) to make an “outgoing” parameter.
    In calling this function, a programmer might carelessly do something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想象这个函数是用C语言编写的，而不是C++，这就是为什么它使用指针而不是引用（`&`）来传递“输出”参数。在调用这个函数时，程序员可能会粗心大意地做如下操作：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is inefficient in space because it creates a pointer where none is
    needed. Instead of the space for two integers, it uses the space for two integers
    and a pointer. The code is also inefficient in time because the unnecessary memory
    allocation takes time (as explained in the next section). Lastly, the programmer
    now has to remember to `delete` the allocated memory. All of this could’ve been
    avoided by using the other aspect of the `&` operator, which allows you to get
    the address of a statically allocated variable, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在空间上效率低下，因为它在不需要指针的地方创建了一个指针。它不是使用两个整数的空间，而是使用了两个整数和一个指针的空间。代码在时间上的效率也低下，因为不必要的内存分配需要时间（如下一节所述）。最后，程序员现在必须记住要`delete`分配的内存。所有这些都可以通过使用`&`操作符的另一个方面来避免，它允许你获取静态分配变量的地址，如下所示：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Strictly speaking, we’re still using a pointer in the second version, but we’re
    using it implicitly, without a pointer variable or dynamic memory allocation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们在第二个版本中仍在使用指针，但我们是在隐式地使用它，没有使用指针变量或动态内存分配。
- en: Memory Matters
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存的重要性
- en: To understand how dynamic memory allocation gives us runtime sizing and memory
    sharing, we have to understand a little bit about how memory allocation works
    in general. This is one of the areas where I think it benefits new programmers
    to learn C++. All programmers must eventually understand how memory systems work
    in a modern computer, and C++ forces you to face this issue head-on. Other languages
    hide enough of the dirty details of memory systems that new programmers convince
    themselves that these details are of no concern, which is simply not the case.
    Rather, the details are of no concern so long as everything is working. As soon
    as there is a problem, however, ignorance of the underlying memory models creates
    an insurmountable obstacle between the programmer and the solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解动态内存分配如何为我们提供运行时大小调整和内存共享，我们必须稍微了解一下内存分配在一般情况下是如何工作的。这是我认为新程序员学习C++会受益的一个领域。所有程序员最终都必须理解现代计算机中内存系统的工作方式，而C++迫使你直面这个问题。其他语言隐藏了内存系统的大部分脏细节，新程序员会说服自己这些细节无关紧要，这显然是不对的。相反，只要一切正常，这些细节确实无关紧要。然而，一旦出现问题，对底层内存模型的缺乏了解就会在程序员和解决方案之间形成难以逾越的障碍。
- en: The Stack and the Heap
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈和堆
- en: 'C++ allocates memory in two places: the *stack* and the *heap*. As the names
    imply, the stack is organized and neat, and the heap is disjointed and messy.
    The name *stack* is especially descriptive because it helps you visualize the
    contiguous nature of the memory allocation. Think of a stack of crates, as in
    [Figure 4-1](ch04.html#a_stack_of_crates_and_a_stack_of_functio "Figure 4-1. A
    stack of crates and a stack of function calls") (a). When you have a crate to
    store, you place it on the top of the stack. To remove a particular crate from
    the stack, you have to first remove all the crates that are on top of it. In practical
    programming terms, this means that once you have allocated a block of memory (a
    crate) on the stack, there’s no way to resize it because at any time you may have
    other memory blocks immediately following it (other crates on top of it).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 在两个地方分配内存：*栈* 和 *堆*。正如其名所示，栈是有序且整洁的，而堆是零散且混乱的。*栈* 这个名字尤其具有描述性，因为它有助于你可视化内存分配的连续性。想象一下一堆箱子，就像[图4-1](ch04.html#a_stack_of_crates_and_a_stack_of_functio
    "图4-1. 一堆箱子以及一堆函数调用")（a）中所示。当你有箱子要存放时，你将其放在栈顶。要从栈中移除特定的箱子，你必须首先移除其上方的所有箱子。在实际编程术语中，这意味着一旦你在栈上分配了一块内存（一个箱子），就无法调整其大小，因为任何时间你可能有其他内存块紧随其后（在其上方的其他箱子）。
- en: 'In C++, you might explicitly create your own stack for use in a particular
    algorithm, but regardless, there is one stack your program will always be using,
    known as the program’s *runtime stack*. Every time a function is called (and this
    includes the `main` function), a block of memory is allocated on the top of the
    runtime stack. This block of memory is called an *activation record*. A full discussion
    of its contents is beyond the scope of this text, but for your understanding as
    a problem-solver, the main content of the activation record is the storage space
    for variables. Memory for all the local variables, including the function’s parameters,
    is allocated within the activation record. Let’s take a look at an example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，你可能会为特定的算法显式创建自己的栈，但无论如何，你的程序总是会使用一个栈，称为程序的 *运行时栈*。每次调用函数（包括 `main`
    函数），都会在运行时栈的顶部分配一块内存。这块内存称为 *激活记录*。对其内容的全面讨论超出了本文的范围，但为了你作为问题解决者的理解，激活记录的主要内容是变量的存储空间。所有局部变量的内存，包括函数的参数，都在激活记录内分配。让我们来看一个例子：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code, the `main` function calls `functionA`, which in turn calls `functionB`.
    [Figure 4-1](ch04.html#a_stack_of_crates_and_a_stack_of_functio "Figure 4-1. A
    stack of crates and a stack of function calls") (b) shows a simplified version
    of how the runtime stack would be arranged at the point right before we execute
    the return statement of `functionB` ![](httpatomoreillycomsourcenostarchimages1273182.png).
    The activation records for all three functions would be arranged in a stack of
    contiguous memory, with the `main` function at the bottom of the stack. (Just
    to make things extra confusing, it’s possible that the stack begins at the highest
    possible point in memory and is built downward to lower memory addresses rather
    than upward to higher memory addresses. You do yourself no harm, though, by ignoring
    the possibility.) Logically, the `main` function activation record is on the bottom
    of the stack, with the `functionA` activation record on top of it and the `functionB`
    activation record on top of `functionA`. Neither of the lower two activation records
    can be removed before `functionB`’s activation record is removed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`main` 函数调用 `functionA`，而 `functionA` 又调用 `functionB`。[图4-1](ch04.html#a_stack_of_crates_and_a_stack_of_functio
    "图4-1. 一堆箱子以及一堆函数调用")（b）展示了在执行 `functionB` 的返回语句之前，运行时栈的简化排列方式！![更多](httpatomoreillycomsourcenostarchimages1273182.png)。所有三个函数的激活记录将按连续内存的顺序排列，其中
    `main` 函数位于栈底。（为了使事情更加复杂，栈可能从内存中的最高点开始，向下构建到较低的内存地址，而不是向上构建到较高的内存地址。不过，忽略这种可能性并不会对你造成伤害。）从逻辑上讲，`main`
    函数的激活记录位于栈底，`functionA` 的激活记录位于其上方，而 `functionB` 的激活记录位于 `functionA` 的上方。在 `functionB`
    的激活记录被移除之前，下面两个较低的激活记录都不能被移除。
- en: '![A stack of crates and a stack of function calls](httpatomoreillycomsourcenostarchimages1273207.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![一堆箱子以及一堆函数调用](httpatomoreillycomsourcenostarchimages1273207.png.jpg)'
- en: Figure 4-1. A stack of crates and a stack of function calls
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 一堆箱子以及一堆函数调用
- en: While a stack is highly organized, a heap, by contrast, has little organization.
    Suppose you’re storing things in crates again, but these crates are fragile and
    you can’t stack them on top of each other. You’ve got a big, initially empty room
    to store the crates, and you can put them anywhere you want on the floor. The
    crates are heavy, however, so once you put one down, you’d rather just leave it
    where it is until you’re ready to take it out of the room. This system has advantages
    and disadvantages compared to the stack. On the one hand, this storage system
    is flexible and allows you to get to the contents of any crate at any time. On
    the other hand, the room is going to quickly become a mess. If the crates are
    all different sizes, it’s going to be especially difficult to make use of all
    of the available space on the floor. You’ll end up with a lot of gaps between
    crates that are too small to fill with another crate. Because the crates can’t
    be easily moved, removing several crates just creates several hard-to-fill gaps
    rather than providing the wide-open storage of our original empty floor. In practical
    programming terms, our heap is like the floor of that room. A block of memory
    is a contiguous series of addresses; thus, over the lifetime of a program with
    many memory allocations and deallocations, we’ll end up with lots of gaps between
    the remaining allocated memory blocks. This problem is known as *memory fragmentation*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然栈非常有序，但与之相比，堆的组织性很小。假设你再次用板条箱存储东西，但这些板条箱很脆弱，你不能把它们堆叠在一起。你有一个大房间，最初是空的，用来存放板条箱，你可以把它们放在地板上的任何地方。然而，板条箱很重，所以一旦放下，你宁愿把它放在那里，直到你准备好把它从房间里拿出来。这个系统与栈相比有优点也有缺点。一方面，这种存储系统很灵活，允许你在任何时间获取任何板条箱的内容。另一方面，房间很快就会变得杂乱无章。如果板条箱大小不一，那么充分利用地板上的所有空间将特别困难。你会在板条箱之间留下很多无法用另一个板条箱填充的空隙。由于板条箱不能轻易移动，移除几个板条箱只会产生几个难以填充的空隙，而不是提供我们最初空旷地板的宽敞存储空间。在实际编程术语中，我们的堆就像那个房间的地板。一块内存是一系列连续的地址；因此，在具有许多内存分配和释放的程序的生命周期中，我们最终会在剩余的分配内存块之间留下很多空隙。这个问题被称为*内存碎片化*。
- en: Every program has its own heap, from which memory is dynamically allocated.
    In C++, this usually means an invocation of the `new` keyword, but you will also
    see calls to the old C functions for memory allocation, such as `malloc`. Each
    call to `new` (or `malloc`) sets aside a chunk of memory in the heap and returns
    a pointer to the chunk, while each call to `delete` (or `free` if the memory was
    allocated with `malloc`) returns the chunk to the pool of available heap memory.
    Because of fragmentation, not all of the memory in the pool is equally useful.
    If our program begins by allocating variables A, B, and C in heap memory, we might
    expect those blocks to be contiguous. If we deallocate B, the gap it leaves behind
    can be filled only by another request that is of B’s size or smaller, until either
    A or C is also deallocated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都有自己的堆，内存在这里是动态分配的。在C++中，这通常意味着调用`new`关键字，但你也会看到对旧C函数的调用，例如`malloc`。每次调用`new`（或`malloc`）都会在堆中预留一块内存并返回该块的指针，而每次调用`delete`（或如果内存是用`malloc`分配的，则返回`free`）都会将块返回到可用的堆内存池中。由于碎片化，池中的内存并不都同样有用。如果我们程序一开始在堆内存中分配变量A、B和C，我们可能会期望这些块是连续的。如果我们释放B，它留下的空隙只能被另一个大小为B或更小的请求填充，直到A或C也被释放。
- en: '[Figure 4-2](ch04.html#a_fragmented_floor_comma_a_crate_that_ca "Figure 4-2. A
    fragmented floor, a crate that cannot be placed, and fragmented memory") clarifies
    the situation. In part (a), we see the floor of our room littered with crates.
    At one point the room was probably well organized, but over time, the arrangement
    became haphazard. Now there is a small crate (b) that cannot fit in any open space
    on the floor, even though the overall unused floor area greatly exceeds the footprint
    of the crate. In part (c), we represent a small heap. The dashed-line squares
    are the smallest (indivisible) chunks of memory, which might be a single byte,
    a memory word, or something larger, depending on the heap manager. The shaded
    areas represent allocations of contiguous memory; for clarity, one allocation
    has some of its chunks numbered. As with the fragmented floor, the fragmented
    heap has the unallocated memory chunks separated, which reduces their usability.
    There are a total of 85 unused chunks of memory, but the largest contiguous range
    of unused memory, as indicated by the arrow, is only 17 chunks long. In other
    words, if each chunk were a byte, this heap could not fulfill any request from
    an invocation of `new` for more than 17 bytes, even though the heap has 85 bytes
    free.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-2](ch04.html#a_fragmented_floor_comma_a_crate_that_ca "图4-2. 一个碎片化的地板，一个无法放置的箱子，以及碎片化的内存")阐明了这种情况。在部分(a)中，我们看到我们房间的地板上散落着箱子。在某个时刻，房间可能组织得很好，但随着时间的推移，布局变得杂乱无章。现在有一个小箱子(b)无法放入地板上的任何开放空间，尽管整体未使用的地板面积远远超过了箱子的占地面积。在部分(c)中，我们表示一个小堆。虚线方框是内存的最小（不可分割）块，可能是单个字节、内存字或更大的块，具体取决于堆管理器。阴影区域表示连续内存的分配；为了清晰起见，一个分配的部分块被编号。与碎片化的地板一样，碎片化的堆将未分配的内存块分开，这降低了其可用性。总共有85个未使用的内存块，但最大的连续未使用内存块，如箭头所示，只有17个块长。换句话说，如果每个块都是一个字节，这个堆无法满足`new`调用超过17字节的任何请求，尽管堆有85字节空闲。'
- en: '![A fragmented floor, a crate that cannot be placed, and fragmented memory](httpatomoreillycomsourcenostarchimages1273209.png.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![一个碎片化的地板，一个无法放置的箱子，以及碎片化的内存](httpatomoreillycomsourcenostarchimages1273209.png.jpg)'
- en: Figure 4-2. A fragmented floor, a crate that cannot be placed, and fragmented
    memory
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2. 一个碎片化的地板，一个无法放置的箱子，以及碎片化的内存
- en: Memory Size
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存大小
- en: The first practical issue with memory is limiting its use to what is necessary.
    Modern computer systems have so much memory that it’s easy to think of it as an
    infinite resource, but in fact each program has a limited amount of memory. Also,
    programs need to use memory efficiently to avoid overall system slowdown. In a
    multitasking operating system (which means just about every modern operating system),
    every byte of memory wasted by one program pushes the system as a whole toward
    the point where the set of currently running programs doesn’t have enough memory
    to run. At that point, the operating system constantly swaps out chunks of one
    program for another and thus grinds to a crawl. This condition is known as *thrashing*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆的第一个实际问题是要限制其使用范围在必要范围内。现代计算机系统拥有如此多的内存，很容易将其视为一种无限资源，但实际上每个程序都有有限的内存。此外，程序需要高效地使用内存，以避免整体系统变慢。在多任务操作系统（这意味着几乎所有的现代操作系统）中，一个程序浪费的每一个字节都会使整个系统趋向于这样一个点：当前运行程序集没有足够的内存来运行。在这个点上，操作系统会不断地将一个程序的块交换到另一个程序中，从而使得系统变得极其缓慢。这种情况被称为*颠簸*。
- en: 'Note that, beyond the desire to keep the overall program memory footprint as
    small as possible, the stack and the heap have maximum sizes. To prove this, let’s
    allocate memory from the heap a kilobyte at a time, until something blows up:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了希望将整个程序的内存占用尽可能小之外，栈和堆还有最大大小限制。为了证明这一点，让我们每次从堆中分配1千字节大小的内存，直到出现故障：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let me emphasize that this is horrible code written purely to demonstrate a
    point. If you try this code out on your system, you should save all of your work
    first, just to be safe. What should happen is that the program halts and your
    operating system complains that the code generated but did not handle a `bad_alloc`
    exception. This exception is thrown by `new` when no block of unallocated memory
    in the heap is large enough to fulfill the request. Running out of heap memory
    is called a *heap overflow*. On some systems, a heap overflow can be common, while
    on other systems, a program will cause thrashing long before it produces a `bad_alloc`
    (on my system, the `new` call didn’t fail until I had allocated two gigabytes
    in previous calls).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我强调，这段代码纯粹是为了演示某个观点而编写的糟糕代码。如果你想在你的系统上尝试这段代码，请先保存所有的工作，以确保安全。应该发生的情况是程序停止运行，你的操作系统会抱怨代码生成了一个但未处理的
    `bad_alloc` 异常。这个异常是在堆中没有足够大的未分配内存块来满足请求时由 `new` 抛出的。堆内存耗尽被称为 *堆溢出*。在某些系统中，堆溢出可能很常见，而在其他系统中，程序在产生
    `bad_alloc` 之前就会导致系统崩溃（在我的系统中，`new` 调用失败直到我在之前的调用中分配了两个吉字节）。
- en: 'A similar situation exists with the runtime stack. Each function call allocates
    space on the stack, and there is some fixed overhead for each activation record,
    even for a function with no parameters or local variables. The easiest way to
    demonstrate this is with a runaway recursive function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时栈也存在类似的情况。每个函数调用都会在栈上分配空间，即使是没有任何参数或局部变量的函数，每个激活记录也有一些固定的开销。最容易演示这一点的方法是使用一个失控的递归函数：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code has a global variable ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which in most cases is bad style, but here I need a value that persists throughout
    all of the recursive calls. As this variable is declared outside of the function,
    no memory is allocated for it in the function’s activation record, nor are there
    any other local variables or parameters. All the function does is increment `count`
    and make a recursive call ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Recursion is discussed extensively in [Chapter 6](ch06.html "Chapter 6. Solving
    Problems with Recursion") but is used here simply to make the chain of function
    calls as long as possible. The activation record of a function remains on the
    stack until that function ends. So when the first call is made to `stackOverflow`
    from `main`, an activation record is placed on the runtime stack that cannot be
    removed until that first function call ends. This will never happen because the
    function makes a second call to `stackOverflow`, placing another activation record
    on the stack, which then makes a third call, and so on. These activation records
    stack up until the stack runs out of room. On my system, `count` is around 4,900
    when the program bombs. My development environment, Visual Studio, defaults to
    a 1MB stack allocation, which means that each of these function calls, even without
    any local variables or parameters, creates an activation record of over 200 bytes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个全局变量 ![全局变量](http://atomoreilly.com/source/nostarch/images/1273182.png)，在大多数情况下这是不良的编程风格，但在这里我需要一个在整个递归调用中持续存在的值。因为这个变量是在函数外部声明的，所以在函数的激活记录中不会为其分配内存，也没有其他局部变量或参数。这个函数所做的只是增加
    `count` 并进行递归调用 ![递归调用](http://atomoreilly.com/source/nostarch/images/1273193.png)。递归在
    [第6章](ch06.html "第6章. 使用递归解决问题") 中有详细的讨论，但在这里只是简单地用来尽可能延长函数调用的链。函数的激活记录会一直留在栈上，直到该函数结束。所以当第一次从
    `main` 调用 `stackOverflow` 时，会在运行时栈上放置一个激活记录，直到第一个函数调用结束之前无法移除。这永远不会发生，因为函数会再次调用
    `stackOverflow`，在栈上放置另一个激活记录，然后它又会进行第三次调用，以此类推。这些激活记录会一直堆叠，直到栈空间耗尽。在我的系统中，当程序崩溃时
    `count` 大约是 4,900。我的开发环境 Visual Studio 默认的栈分配是 1MB，这意味着即使没有局部变量或参数，每个函数调用也会创建一个超过
    200 字节的激活记录。
- en: Lifetime
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'The *lifetime* of a variable is the time span between allocation and deallocation.
    With a stack-based variable, meaning either a local variable or a parameter, the
    lifetime is handled implicitly. The variable is allocated when the function is
    called and deallocated when the function ends. With a heap-based variable, meaning
    a variable dynamically allocated using `new`, the lifetime is in our hands. Managing
    the lifetime of dynamically allocated variables is the bane of every C++ programmer.
    The most obvious issue is the dreaded *memory leak*, a situation in which memory
    is allocated from the heap but never deallocated and not referenced by any pointer.
    Here’s a simple example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*生命周期*是从分配到释放的时间跨度。对于基于栈的变量，意味着局部变量或参数，其生命周期是隐式处理的。变量在函数调用时分配，在函数结束时释放。对于基于堆的变量，意味着使用`new`动态分配的变量，其生命周期在我们手中。管理动态分配变量的生命周期是每个C++程序员的噩梦。最明显的问题是可怕的*内存泄漏*，这是一种从堆中分配内存但从未释放且未由任何指针引用的情况。这里有一个简单的例子：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code, we declare a pointer to an integer ![](httpatomoreillycomsourcenostarchimages1273182.png),
    initializing it by allocating an integer from the heap. Then in the second line,
    we set our integer pointer to `NULL` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    (which is simply an alias for the number zero). The integer we allocated with
    `new` still exists, however. It sits, lonely and forlorn, in its place in the
    heap, awaiting a deallocation that can never come. We cannot deallocate the integer
    because to deallocate a block of memory, we use `delete` followed by a pointer
    to the block, and we no longer have a pointer to the block. If we tried to follow
    the code above with `delete intPtr`, we would get an error because `intPtr` is
    zero.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们声明了一个指向整数的指针 ![](httpatomoreillycomsourcenostarchimages1273182.png)，通过从堆中分配一个整数来初始化它。然后在第二行，我们将我们的整数指针设置为`NULL`
    ![](httpatomoreillycomsourcenostarchimages1273191.png)（它只是零的别名）。然而，我们使用`new`分配的整数仍然存在。它孤独地坐在堆中的位置，等待着永远无法到来的释放。我们无法释放这个整数，因为释放内存块，我们使用`delete`后跟指向该块的指针，而我们不再有指向该块的指针。如果我们尝试使用`delete
    intPtr`来跟随上面的代码，我们会得到一个错误，因为`intPtr`是零。
- en: 'Sometimes, instead of memory that never gets deallocated, we have the opposite
    problem, attempting to deallocate the same memory twice, which produces a runtime
    error. This might seem like an easy problem to avoid: Just don’t call `delete`
    twice on the same variable. What makes this situation tricky is that we may have
    multiple variables pointing to the same memory. If multiple variables point to
    the same memory and we call `delete` on any of those variables, we have effectively
    deallocated the memory for all of the variables. If we don’t explicitly clear
    the variables to `NULL`, they will be known as *dangling references*, and calling
    `delete` on any of them will produce a runtime error.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们遇到的问题不是从未释放的内存，而是试图两次释放相同的内存，这会产生运行时错误。这看起来像是一个容易避免的问题：只是不要对同一个变量两次调用`delete`。使这种情况变得棘手的是，我们可能有多个变量指向相同的内存。如果有多个变量指向相同的内存，并且我们在其中任何一个变量上调用`delete`，我们就有效地释放了所有这些变量的内存。如果我们没有明确地将变量清除为`NULL`，它们将被称为*悬垂引用*，在它们上调用`delete`将产生运行时错误。
- en: Solving Pointer Problems
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决指针问题
- en: By this point, you’re probably ready for some problems, so let’s look at a couple
    and see how we can use pointers and dynamic memory allocation to solve them. First
    we’ll work with some dynamically allocated arrays, which will demonstrate how
    to keep track of heap memory through all of our manipulations. Then we’ll get
    our feet wet with a truly dynamic structure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经准备好解决一些问题，所以让我们看看几个问题，看看我们如何使用指针和动态内存分配来解决它们。首先，我们将处理一些动态分配的数组，这将展示如何在所有操作中跟踪堆内存。然后，我们将真正地尝试一个动态结构。
- en: Variable-Length Strings
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变长度字符串
- en: 'In this first problem, we’re going to create functions to manipulate strings.
    Here, we’re using the term in its most general sense: a sequence of characters,
    regardless of how those characters are stored. Suppose we need to support three
    functions on our string type.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个问题中，我们将创建函数来操作字符串。在这里，我们使用这个术语的最一般意义：字符序列，无论这些字符是如何存储的。假设我们需要支持我们字符串类型上的三个函数。
- en: 'Problem: Variable-length string manipulation'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：可变长度字符串操作
- en: 'Write heap-based implementations for three required string functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为三个必需的字符串函数编写基于堆的实现：
- en: '**`append`**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**`append`**'
- en: This function takes a string and a character and appends the character to the
    end of the string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串和一个字符，并将该字符追加到字符串的末尾。
- en: '**`concatenate`**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**`concatenate`**'
- en: This function takes two strings and appends the characters of the second string
    onto the first.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个字符串，并将第二个字符串的字符追加到第一个字符串上。
- en: '**`characterAt`**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**`characterAt`**'
- en: This function takes a string and a number and returns the character at that
    position in the string (with the first character in the string numbered zero).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串和一个数字，并返回字符串中该位置的字符（字符串中的第一个字符编号为零）。
- en: Write the code with the assumption that `characterAt` will be called frequently,
    while the other two functions will be called relatively seldom. The relative efficiency
    of the operations should reflect the calling frequency.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码时，假设`characterAt`函数将被频繁调用，而其他两个函数相对较少调用。操作的相对效率应该反映调用的频率。
- en: 'In this case, we want to choose a representation for our string that allows
    for a fast `characterAt` function, which means we need a fast way to locate a
    particular character. As you probably recall from the previous chapter, this is
    what an array does best: random access. So let’s solve this problem using arrays
    of `char`. The `append` and `concatenate` functions change the size of the string,
    which means we run into all the array problems we discussed earlier. Because there’s
    no built-in limitation to the size of the string in this problem, we can’t pick
    a large initial size for our arrays and hope for the best. Instead, we’ll need
    to resize our arrays during runtime.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要选择一种字符串表示方式，允许快速`characterAt`函数，这意味着我们需要一种快速定位特定字符的方法。你可能还记得上一章，这正是数组做得最好的事情：随机访问。因此，让我们使用`char`数组来解决这个问题。`append`和`concatenate`函数会改变字符串的大小，这意味着我们会遇到我们之前讨论过的所有数组问题。由于这个问题中字符串的大小没有内置限制，我们不能选择一个大的初始大小来希望一切顺利。相反，我们将在运行时调整数组的大小。
- en: To start off, let’s create a `typedef` for our string type. We know we’re going
    to be dynamically creating our arrays, so we need to make our string type a pointer
    to `char`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的字符串类型创建一个`typedef`。我们知道我们将动态创建我们的数组，因此我们需要将字符串类型定义为指向`char`的指针。
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that in place, let’s start on the functions. Using the principle of starting
    with what we already know how to do, we can quickly write the `characterAt` function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们开始编写函数。使用从我们已知如何开始的原则，我们可以快速编写`characterAt`函数。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recall from [Chapter 3](ch03.html "Chapter 3. Solving Problems with Arrays")
    that if a pointer is assigned the address of an array, we can access elements
    in the array using normal array notation ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Note, however, that bad things can happen if `position` is not actually a valid
    element number for the array `s`, and this code places the responsibility of validating
    the second parameter on the caller. We’ll consider alternatives to this situation
    in the exercises. For now, let’s move onto the `append` function. We can imagine
    what this function will do generally, but to get the specifics right, we should
    consider an example. This is a technique I call *solving by sample case*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第3章](ch03.html "第3章. 使用数组解决问题")，如果指针被分配了数组的地址，我们可以使用正常的数组表示法访问数组中的元素 ![httpatomoreillycomsourcenostarchimages1273182.png]。然而，请注意，如果`position`实际上不是数组`s`的有效元素编号，那么会发生不好的事情，并且此代码将验证第二个参数的责任放在调用者身上。我们将在练习中考虑这种情况的替代方案。现在，让我们继续到`append`函数。我们可以想象这个函数大致会做什么，但要得到具体的细节，我们应该考虑一个例子。这是一个我称之为*通过示例案例解决*的技术。
- en: Start with a nontrivial sample input for the function or program. Write down
    all the details of that input along with all the details of the output. Then when
    you write your code, you’ll be writing for the general case while also double-checking
    how each step transforms your sample to make sure that you reach the desired output
    state. This technique is especially helpful when dealing with pointers and dynamically
    allocated memory, because so much of what happens in the program is outside of
    direct view. Following through a case on paper forces you to track all the changing
    values in memory—not just those directly represented by variables but also those
    in the heap.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数或程序的非平凡样本输入开始。写下该输入的所有细节以及输出的所有细节。然后当你编写代码时，你将针对一般情况进行编写，同时也要双重检查每个步骤如何将样本转换为所需的输出状态。这种技术在处理指针和动态分配的内存时特别有帮助，因为程序中发生的大部分事情都在直接视野之外。在纸上追踪一个案例迫使你必须跟踪内存中所有变化的值——不仅包括变量直接表示的值，还包括堆中的值。
- en: Suppose we start with the string `test`, which is to say we have an array of
    characters in the heap with `t`, `e`, `s`, and `t`, in that order, and we want
    to `append`, using our function, an exclamation point. [Figure 4-3](ch04.html#proposed_lbeforer_open_parenthesis_a_clo
    "Figure 4-3. Proposed “before” (a) and “after” (b) states for append function")
    shows the state of memory before (a) and after (b) this operation. In these diagrams,
    anything to the left of the dashed vertical line is stack memory (local variables
    or parameters) and anything to the right is heap memory, dynamically allocated
    using `new`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从字符串`test`开始，也就是说我们有一个在堆中的字符数组，包含`t`、`e`、`s`和`t`，顺序排列，并且我们想要使用我们的函数`append`添加一个感叹号。[图4-3](ch04.html#proposed_lbeforer_open_parenthesis_a_clo
    "图4-3。`append`函数的“之前”(a)和“之后”(b)状态")显示了此操作之前(a)和之后(b)内存的状态。在这些图中，虚线垂直线左侧的是栈内存（局部变量或参数），右侧的是堆内存，使用`new`动态分配。
- en: '![Proposed “before” (a) and “after” (b) states for append function](httpatomoreillycomsourcenostarchimages1273211.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![`append`函数的“之前”(a)和“之后”(b)状态](httpatomoreillycomsourcenostarchimages1273211.png)'
- en: Figure 4-3. Proposed “before” (a) and “after” (b) states for `append` function
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3。`append`函数的“之前”(a)和“之后”(b)状态
- en: Looking at this figure, right away I’m seeing a potential issue for our function.
    Based on our implementation approach for the strings, the function is going to
    create a new array that is one element larger than the original array and copy
    all the characters from the first array to the second. But how are we to know
    how large the first array is? From the previous chapter, we know that we have
    to track the size of our arrays ourselves. So something is missing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看着这个图，我立刻就看到了我们函数可能存在的问题。根据我们对字符串的实现方法，函数将创建一个比原始数组大一个元素的新数组，并将第一个数组中的所有字符复制到第二个数组中。但我们如何知道第一个数组有多大呢？从上一章我们知道，我们必须自己跟踪数组的大小。所以有些东西缺失了。
- en: If we’ve had experience working with strings in the standard C/C++ library,
    we will already know the missing ingredient, but if we don’t, we can quickly reason
    it out. Remember that one of our problem-solving techniques is *looking for analogies*.
    Perhaps we should think about other problems in which the length of something
    was unknown. Back in [Chapter 2](ch02.html "Chapter 2. Pure Puzzles"), we processed
    identification codes with an arbitrary number of digits for the “Luhn Checksum
    Validation” problem. In that problem, we didn’t know how many digits the user
    would enter. In the end, we wrote a `while` loop that continued until the last
    character read was the end-of-line.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有过在标准C/C++库中处理字符串的经验，我们就会知道缺失的成分，但如果没有，我们可以快速推理出来。记住，我们的问题解决技巧之一是*寻找类比*。也许我们应该考虑其他一些问题，其中某物的长度是未知的。在[第2章](ch02.html
    "第2章。纯难题")中，我们处理了用于“Luhn校验和验证”问题的具有任意数字位的识别码。在那个问题中，我们不知道用户会输入多少位数字。最后，我们编写了一个`while`循环，直到读取到最后一个字符为止。
- en: Unfortunately, there is no end-of-line character waiting for us at the end of
    our arrays. But what if we *put* an end-of-line character in the last element
    of all our string arrays? Then we could discover the length of our arrays the
    same way we discovered how many digits were in the identification codes. The only
    downside to this approach is that we could no longer use the end-of-line character
    in our strings, except as the string terminator. That’s not necessarily a huge
    restriction, depending on how the strings will be used, but for maximum flexibility,
    it would be best to choose a value that cannot be confused with any character
    anyone might actually want to use. Therefore, we’ll use a zero to terminate our
    arrays because a zero represents a null character in ASCII and other character
    code systems. This is exactly the method used by the standard C/C++ library.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我们数组的末尾并没有等待我们的换行符。但如果我们把换行符放在所有字符串数组的最后一个元素中会怎样呢？那么我们就可以像发现识别码中有多少数字一样，发现我们数组的长度。这种方法的唯一缺点是我们不能再在我们的字符串中使用换行符，除非作为字符串的终止符。这并不一定是一个巨大的限制，这取决于字符串的用途，但为了最大的灵活性，最好选择一个不会与任何人可能实际想要使用的任何字符混淆的值。因此，我们将使用零来终止我们的数组，因为零在ASCII和其他字符代码系统中代表空字符。这正是标准C/C++库所使用的方法。
- en: With that issue cleared up, let’s get more specific about what `append` will
    do with our sample data. We know our function is going to have two parameters,
    the first being an `arrayString`, a pointer to an array of characters in the heap,
    and the second being the `char` to be appended. To keep things straight, let’s
    go ahead and write the outline of the `append` function and the code to test it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这个问题之后，让我们更具体地了解一下`append`函数将如何处理我们的样本数据。我们知道我们的函数将有两个参数，第一个是一个`arrayString`，它是堆中字符数组的指针，第二个是要附加的`char`。为了保持清晰，让我们先写出`append`函数的轮廓和测试它的代码。
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `appendTester` function allocates our string in the heap ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Note that the size of the array is five, which is necessary so that we can assign
    all four letters of the word `test` along with our terminating null character
    ![](httpatomoreillycomsourcenostarchimages1273193.png). Then we call `append`
    ![](httpatomoreillycomsourcenostarchimages1273195.png), which at this point is
    just an empty shell. When I wrote the shell, I realized that the `arrayString`
    parameter had to be a reference (`&`) ![](httpatomoreillycomsourcenostarchimages1273182.png)
    because the function is going to create a new array in the heap. That’s the whole
    point, after all, of using dynamic memory here: to create a new array whenever
    the string is resized. Therefore, the value that the variable `a` has when passed
    to `append` is not the same value it should have when the function is through,
    because it needs to point to a new array. Note that because our arrays use the
    null-character termination expected by the standard libraries, we can send the
    array referenced by the pointer `a` directly to the output stream to check the
    value ![](httpatomoreillycomsourcenostarchimages1273197.png).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendTester`函数在堆中分配我们的字符串 ![http://atomoreilly.com/source/nostarch/images/1273191.png]。请注意，数组的大小是五个，这是必要的，以便我们可以分配单词`test`的所有四个字母以及我们的终止空字符
    ![http://atomoreilly.com/source/nostarch/images/1273193.png]。然后我们调用`append` ![http://atomoreilly.com/source/nostarch/images/1273195.png]，此时它只是一个空壳。当我编写这个壳时，我意识到`arrayString`参数必须是一个引用（`&`）
    ![http://atomoreilly.com/source/nostarch/images/1273182.png]，因为函数将在堆中创建一个新的数组。毕竟，使用动态内存的整个目的就是在字符串大小调整时创建一个新的数组。因此，当变量`a`传递给`append`时，它所具有的值与函数完成时它应该具有的值并不相同，因为它需要指向一个新的数组。请注意，因为我们的数组使用标准库期望的空字符终止，我们可以直接将指针`a`所引用的数组发送到输出流以检查其值
    ![http://atomoreilly.com/source/nostarch/images/1273197.png]。'
- en: '[Figure 4-4](ch04.html#updated_and_elaborated_memory_states_bef "Figure 4-4. Updated
    and elaborated memory states before (a) and after (b) the append function") shows
    our new understanding of what the function will do with our test case. The array
    terminators are in place, shown as `NULL` for clarity. In the after (b) state,
    it’s clear that `s` is pointing at a new allocation of memory. The previous array
    is now in a shaded box; in these diagrams, I’m using shaded boxes to indicate
    memory that has been deallocated. Including the allocated memory in our diagrams
    helps remind us to actually perform the deallocation.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](ch04.html#updated_and_elaborated_memory_states_bef "图4-4. 在append函数前后更新和详细展示的内存状态")
    展示了我们对我们测试用例的新理解。数组终止符已经就位，为了清晰起见，显示为`NULL`。在(b)状态之后，很明显`s`指向了一个新的内存分配。之前的数组现在在一个阴影框中；在这些图中，我使用阴影框来表示已释放的内存。在我们的图中包括分配的内存有助于提醒我们实际执行释放操作。'
- en: '![Updated and elaborated memory states before (a) and after (b) the append
    function](httpatomoreillycomsourcenostarchimages1273213.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![在append函数前后更新和详细展示的内存状态（a）和（b）](http://atomoreilly.com/source/nostarch/images/1273213.png.jpg)'
- en: Figure 4-4. Updated and elaborated memory states before (a) and after (b) the
    `append` function
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4. 在append函数前后更新和详细展示的内存状态
- en: 'With everything properly visualized, we can write this function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切都被正确可视化后，我们可以编写这个函数：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There’s a lot going on in this code, so let’s check it out piece by piece. At
    the beginning of the function, we have a loop to locate the null character that
    terminates our array ![](httpatomoreillycomsourcenostarchimages1273182.png). When
    the loop completes, `oldLength` will be the number of legitimate characters in
    the array (that is, not including the terminating null character). We allocate
    the new array from the heap with a size of `oldLength + 2` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    This is one of those details that is tricky to keep straight if you’re figuring
    it all out in your head but easy to get right if you have a diagram. Following
    the code through our example in [Figure 4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "Figure 4-5. Showing the relationship of a local variable, parameters, and allocated
    memory before and after the append function"), we see that `oldLength` would be
    four in this case. We know that `oldLength` would be four because test has four
    characters and that the new array in part (b) requires six characters because
    we need space for the appended character and the null terminator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中有很多事情在进行，所以让我们逐个检查。在函数开始时，我们有一个循环来定位终止我们的数组的空字符 ![http://atomoreilly.com/source/nostarch/images/1273182.png]。当循环完成后，`oldLength`将是数组中合法字符的数量（即不包括终止的空字符）。我们使用`oldLength
    + 2`的大小从堆中分配新数组 ![http://atomoreilly.com/source/nostarch/images/1273191.png]。这是那些如果你在脑海中全部想清楚会变得很棘手但如果你有图示就会很容易做对的一些细节。按照[图4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "图4-5. 显示在append函数前后局部变量、参数和分配的内存之间的关系")中的示例代码进行跟踪，我们可以看到在这种情况下`oldLength`将是四。我们知道`oldLength`将是四，因为test有四个字符，而(b)部分的新数组需要六个字符，因为我们需要为附加的字符和空终止符留出空间。
- en: With the new array allocated, we copy all of the legitimate characters from
    the old array to the new ![](httpatomoreillycomsourcenostarchimages1273193.png),
    and we then assign the appended character ![](httpatomoreillycomsourcenostarchimages1273195.png)
    and the null character terminator ![](httpatomoreillycomsourcenostarchimages1273197.png)
    to their appropriate locations in the new array. Again, our diagram helps us keep
    things straight. To make things even clearer, [Figure 4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "Figure 4-5. Showing the relationship of a local variable, parameters, and allocated
    memory before and after the append function") shows how the value of `oldLength`
    was computed and what position that value would indicate in the new array. With
    that visual reminder, it’s easy to get the subscripts correct in those two assignment
    statements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在为新数组分配空间后，我们将旧数组中的所有合法字符复制到新数组 ![http://atomoreilly.com/source/nostarch/images/1273193.png]，然后我们将附加的字符
    ![http://atomoreilly.com/source/nostarch/images/1273195.png] 和空字符终止符 ![http://atomoreilly.com/source/nostarch/images/1273197.png]
    分配到新数组中相应的位置。再次强调，我们的图示帮助我们理清思路。为了使事情更加清晰，[图4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "图4-5. 显示在append函数前后局部变量、参数和分配的内存之间的关系") 展示了`oldLength`的值是如何计算的，以及该值在新数组中的位置。有了这个视觉提示，我们很容易在这两个赋值语句中正确地得到下标。
- en: '![Showing the relationship of a local variable, parameters, and allocated memory
    before and after the append function](httpatomoreillycomsourcenostarchimages1273215.png.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![展示在`append`函数前后局部变量、参数和分配的内存之间的关系](httpatomoreillycomsourcenostarchimages1273215.png.jpg)'
- en: Figure 4-5. Showing the relationship of a local variable, parameters, and allocated
    memory before and after the `append` function
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5. 展示在`append`函数前后局部变量、参数和分配的内存之间的关系
- en: The last three lines in the `append` function are all about that shaded box
    in part (b) of the figure. To avoid a memory leak, we have to deallocate the array
    in the heap that our parameter `s` originally pointed to ![](httpatomoreillycomsourcenostarchimages1273199.png).
    Finally, we leave our function with `s` pointing to the new, longer array ![](httpatomoreillycomsourcenostarchimages1273203.png).
    Unfortunately, one of the reasons memory leaks are so common in C++ programming
    is that until the total amount of memory leaks is large, the program and overall
    system will display no ill effects. Thus, the leaks can go totally unnoticed by
    programmers during testing. As programmers, therefore, we must be diligent and
    always consider the lifetime of our heap memory allocations. Every time you use
    the keyword `new`, think about where and when the corresponding `delete` will
    occur.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`函数的最后三行都与图中(b)部分所示的那个阴影框有关。为了避免内存泄漏，我们必须在堆中释放我们的参数`s`最初指向的数组！[](httpatomoreillycomsourcenostarchimages1273199.png)。最后，我们让函数中的`s`指向新的、更长的数组！[](httpatomoreillycomsourcenostarchimages1273203.png)。不幸的是，C++编程中内存泄漏如此普遍的一个原因是，直到内存泄漏的总量变得很大，程序和整个系统都不会显示出任何不良影响。因此，在测试期间，程序员可能完全注意不到这些泄漏。因此，作为程序员，我们必须勤奋，并且始终考虑我们堆内存分配的寿命。每次使用关键字`new`时，都要考虑相应的`delete`将在哪里和何时发生。'
- en: 'Notice how everything in this function follows directly from our diagrams.
    Tricky programming becomes so much less tricky with good diagrams, and I wish
    more new programmers would take the time to draw before they code. This goes back
    to our most fundamental problem-solving principle: Always have a plan. A well-drawn
    diagram for a problem example is like having a mapped-out route to your destination
    before starting on a long vacation drive. It’s a little bit of extra effort at
    the start to potentially avoid much more effort and frustration at the end.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数中的所有内容是如何直接来自我们的图表的。有了好的图表，复杂的编程就会变得简单得多，我希望更多的初学者在编码之前花时间绘制图表。这回到了我们最基本的问题解决原则：始终有一个计划。对于问题示例的绘制良好的图表就像在长途驾车度假之前就已经规划好了路线。这虽然是一点点额外的努力，但可能会在最后避免更多的努力和挫败感。
- en: CREATING DIAGRAMS
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图表
- en: All you need to draw a diagram is a pencil and paper. If you’ve got the time,
    though, I would recommend using a drawing program. There are drawing tools with
    templates specifically for programming problems, but any general vector-based
    drawing program will get you started (the term vector here means the program works
    with lines and curves and isn’t a paintbox program like Photoshop). I made the
    original illustrations for this book using a program called Inkscape, which is
    freely available. Creating the diagrams on your computer allows you to keep them
    organized in the same place where you store the code that the diagrams illustrate.
    The diagrams are also likely to be neater and therefore more easily understood
    if you come back to them after an absence. Finally, it’s easy to copy and modify
    a computer-created diagram, as I did when I created [Figure 4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "Figure 4-5. Showing the relationship of a local variable, parameters, and allocated
    memory before and after the append function") from [Figure 4-4](ch04.html#updated_and_elaborated_memory_states_bef
    "Figure 4-4. Updated and elaborated memory states before (a) and after (b) the
    append function"), and if you want to make some quick temporary notations, you
    can always print out a copy to doodle on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 画图只需要铅笔和纸。如果你有时间的话，我建议使用绘图程序。有一些绘图工具专门针对编程问题提供模板，但任何通用的基于矢量的绘图程序都可以帮助你开始（这里的矢量意味着程序使用线条和曲线，而不是像Photoshop这样的画图程序）。我为这本书制作原始插图时使用了名为Inkscape的程序，它是免费可用的。在电脑上创建图表可以让你将它们组织在存储图表所展示代码的同一位置。如果你在一段时间后再次查看这些图表，它们也更有可能更整洁，因此更容易理解。最后，复制和修改电脑创建的图表很容易，就像我创建[图4-5](ch04.html#showing_the_relationship_of_a_local_vari
    "图4-5. 展示在append函数前后局部变量、参数和分配的内存之间的关系")时从[图4-4](ch04.html#updated_and_elaborated_memory_states_bef
    "图4-4. append函数前后（a）和（b）更新的和详细的内存状态")中提取的那样，如果你想要做一些快速的临时笔记，你总是可以打印出来涂鸦。
- en: Getting back to our `append` function, the code looks solid, but remember that
    we based this code on a particular sample case. Thus, we shouldn’t get cocky and
    assume that the code will work for all valid cases. In particular, we need to
    check for special cases. In programming, a *special case* is a situation in which
    valid data will cause the normal flow of code to produce erroneous results.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`append`函数，代码看起来很稳固，但请记住，我们基于特定的样本案例编写了这段代码。因此，我们不应该过于自信地假设代码对所有有效情况都适用。特别是，我们需要检查特殊情况。在编程中，*特殊情况*是指有效数据会导致正常代码流程产生错误结果的情况。
- en: Note that this problem is distinct from that of bad data, such as out-of-range
    data. In the code for this book, we’ve made the assumption of good input data
    for programs and individual functions. For example, if the program is expecting
    a series of integers separated by commas, we’ve assumed that’s what the program
    is getting, not extraneous characters, nonnumbers, and so on. Such an assumption
    is necessary to keep code length reasonable and to avoid repeating the same data-checking
    code over and over. In the real world, however, we should take reasonable precautions
    against bad input. This is known as robustness. A *robust* program performs well
    even with bad input. For example, such a program could display an error message
    to the user instead of crashing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题与不良数据（如超出范围的数据）的问题是不同的。在本书的代码中，我们假设程序和单个函数的输入数据是良好的。例如，如果程序期望得到一系列由逗号分隔的整数，我们假设程序得到的就是这些，而不是多余的字符、非数字等。这样的假设是必要的，以保持代码长度合理，并避免反复重复相同的数据检查代码。然而，在现实世界中，我们应该采取合理的预防措施来应对不良输入。这被称为鲁棒性。一个*鲁棒*的程序即使在不良输入的情况下也能良好地运行。例如，这样的程序可以向用户显示错误消息而不是崩溃。
- en: Checking for Special Cases
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查特殊情况
- en: Let’s look at `append` again, checking for special cases—in other words, making
    sure we don’t have any oddball situations among the possible good input values.
    The most common culprits for special cases are at the extremes, such as the smallest
    or largest possible input. With `append`, there’s no maximum size for our string
    array, but there is a minimum size. If the string has no legitimate characters,
    it would actually correspond to an array of one character (the one character being
    the null terminating character). As before, let’s make a diagram to keep things
    straight. Suppose we appended the exclamation point to a null string, as shown
    in [Figure 4-6](ch04.html#testing_the_smallest_case_for_the_append "Figure 4-6. Testing
    the smallest case for the append function").
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看 `append` 函数，检查特殊情况——换句话说，确保在可能的良好输入值中没有任何奇怪的情况。最常见的问题通常出现在极端情况，比如最小或最大的可能输入。对于
    `append` 函数来说，我们的字符串数组没有最大大小限制，但有一个最小大小。如果字符串没有合法字符，它实际上对应于一个只有一个字符的数组（这个字符是空终止字符）。像之前一样，让我们画一个图来保持事情清晰。假设我们将感叹号添加到一个空字符串中，如图
    [图 4-6](ch04.html#testing_the_smallest_case_for_the_append "图 4-6. 测试 `append`
    函数的最小情况") 所示。
- en: '![Testing the smallest case for the append function](httpatomoreillycomsourcenostarchimages1273217.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![测试 `append` 函数的最小情况](http://atomoreilly.com/source/no_starch_images/1273217.png.jpg)'
- en: Figure 4-6. Testing the smallest case for the `append` function
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6. 测试 `append` 函数的最小情况
- en: 'When we look at the diagram, this doesn’t appear to be a special case, but
    we should run the case through our function to check. Let’s add the -following
    to our `appendTester` code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看图表时，这似乎不是一个特殊情况，但我们应该运行这个案例通过我们的函数来检查。让我们在我们的 `appendTester` 代码中添加以下内容：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That works, too. Now that we’re reasonably sure that the `append` function is
    correct, do we like it? The code seemed straightforward, and I’m not getting any
    “bad smells,” but it does seem a little long for a simple operation. As I think
    ahead to the `concatenate` function, it occurs to me that, like `append`, the
    `concatenate` function will need to determine the length of a string array—or
    maybe the lengths of two string arrays. Because both operations will need a loop
    that finds the null character that terminates the string, we could put that code
    in its own function, which is then called from `append` and `concatenate` as needed.
    Let’s go ahead and do that and modify `append` accordingly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这也行得通。现在我们相当确信 `append` 函数是正确的，我们喜欢它吗？代码看起来很简单，我没有闻到任何“坏味道”，但它对于一个简单操作来说似乎有点长。当我展望
    `concatenate` 函数时，我突然想到，就像 `append` 一样，`concatenate` 函数也需要确定字符串数组的大小——或者可能是两个字符串数组的大小。因为这两个操作都需要一个找到终止字符串的空字符的循环，我们可以将这段代码放入自己的函数中，然后根据需要从
    `append` 和 `concatenate` 中调用它。让我们继续这样做并相应地修改 `append`。
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code in the `length` function ![](httpatomoreillycomsourcenostarchimages1273182.png)
    is essentially the same code that previously began the `append` function. In the
    `append` function itself, we’ve replaced that code with a call to `length` ![](httpatomoreillycomsourcenostarchimages1273191.png).
    The `length` function is what’s known as a *helper function*, a function that
    encapsulates an operation common to several other functions. Besides reducing
    the length of our code, the elimination of redundant code means our code is more
    reliable and easier to modify. It also helps our problem solving because helper
    functions divide our code into smaller chunks, making it easier for us to recognize
    opportunities for code reuse.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 函数中的代码 ![http://atomoreilly.com/source/no_starch_images/1273182.png]
    与之前开始 `append` 函数时使用的代码基本相同。在 `append` 函数本身中，我们已经用对 `length` 的调用替换了那段代码 ![http://atomoreilly.com/source/no_starch_images/1273191.png]。`length`
    函数被称为 *辅助函数*，是一种封装了多个其他函数共同操作的函数。除了减少代码长度外，消除冗余代码意味着我们的代码更加可靠且易于修改。它还有助于我们的问题解决，因为辅助函数将我们的代码分割成更小的块，使我们更容易识别代码复用的机会。'
- en: Copying Dynamically Allocated Strings
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制动态分配的字符串
- en: 'Now it’s time to tackle that `concatenate` function. We’ll take the same approach
    we did with `append`. First, we’ll write an empty shell version of the function
    to get the parameters and their types straight in our heads. Then, we’ll make
    a diagram of a test case, and finally, we’ll write code to match our diagram.
    Here is the shell of the function, along with additional testing code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决那个 `concatenate` 函数了。我们将采取与 `append` 相同的方法。首先，我们将编写一个空壳版本的函数，以在我们的脑海中清晰地了解参数及其类型。然后，我们将绘制一个测试用例的图表，最后我们将编写与图表匹配的代码。以下是函数的空壳，以及额外的测试代码：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remember that the description of this function says that the characters in
    the second string (the second parameter) are appended to the end of the first
    string. Therefore, the first parameter to `concatenate` will be a reference parameter
    ![](httpatomoreillycomsourcenostarchimages1273182.png), for the same reason as
    the first parameter of `append`. The second parameter ![](httpatomoreillycomsourcenostarchimages1273191.png),
    though, should not be changed by the function, so it will be a value parameter.
    Now for our sample case: We’re concatenating the strings `test` and `bed`. The
    before-and-after diagram is shown in [Figure 4-7](ch04.html#showing_the_lbeforer_open_parenthesis_a
    "Figure 4-7. Showing the “before” (a) and “after” (b) states for the concatenate
    method").'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个函数的描述说明第二个字符串（第二个参数）中的字符会被追加到第一个字符串的末尾。因此，`concatenate` 函数的第一个参数将是一个引用参数
    ![http://atomoreilly.com/source/no_starch_images/1273182.png](http://atomoreilly.com/source/no_starch_images/1273182.png)，原因与
    `append` 函数的第一个参数相同。然而，第二个参数 ![http://atomoreilly.com/source/no_starch_images/1273191.png](http://atomoreilly.com/source/no_starch_images/1273191.png)
    不应该被函数修改，所以它将是一个值参数。现在，对于我们的示例情况：我们正在连接字符串 `test` 和 `bed`。前后状态图显示在 [图 4-7](ch04.html#showing_the_lbeforer_open_parenthesis_a
    "图 4-7. 显示连接方法的前后状态（a 和 b）")。
- en: The details of the diagram should be familiar from the `append` function. Here,
    for `concatenate`, we start with two dynamically allocated arrays in the heap,
    pointed to by our two parameters, `s1` and `s2`. When the function is complete,
    `s1` will point to a new array in the heap that’s nine characters long. The array
    that `s1` previously pointed to has been deallocated; `s2` and its array are unchanged.
    While it might seem pointless to include `s2` and the `bed` array on our diagram,
    when trying to avoid coding errors, keeping track of what doesn’t change is as
    important as keeping track of what does. I’ve also numbered the elements of the
    old and new arrays, as that came in handy with the `append` function. Everything
    is in place now, so let’s write this function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的细节应该与 `append` 函数的细节相似。在这里，对于 `concatenate`，我们开始时在堆中有两个动态分配的数组，分别由我们的两个参数
    `s1` 和 `s2` 指向。当函数完成后，`s1` 将指向堆中的一个新数组，该数组长度为九个字符。`s1` 之前指向的数组已经被释放；`s2` 及其数组保持不变。虽然在我们试图避免编码错误时，在图表中包含
    `s2` 和 `bed` 数组可能看起来没有意义，但跟踪不变的部分与跟踪变化的部分一样重要。我还对旧数组和新数组的元素进行了编号，因为在 `append`
    函数中这很有用。现在一切就绪，让我们编写这个函数。
- en: '![Showing the “before” (a) and “after” (b) states for the concatenate method](httpatomoreillycomsourcenostarchimages1273219.png.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![显示连接方法的前后状态（a）和（b）](http://atomoreilly.com/source/no_starch_images/1273219.png.jpg)'
- en: Figure 4-7. Showing the “before” (a) and “after” (b) states for the `concatenate`
    method
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-7. 显示连接方法的前后状态（a）和（b）
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we determine the lengths of both of the strings we’re concatenating ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and then we sum those values to get the length the concatenated string will have
    when we are done. Remember that all of these lengths are for the number of legitimate
    characters, not including the null terminator. Thus, when we create the array
    in the heap to store the new string ![](httpatomoreillycomsourcenostarchimages1273191.png),
    we allocate one more than the combined length to have a space for the terminator.
    Then we copy the characters from the two original strings to the new string ![](httpatomoreillycomsourcenostarchimages1273193.png).
    The first loop is straightforward, but notice the computation of the subscript
    in the second loop ![](httpatomoreillycomsourcenostarchimages1273195.png). We’re
    copying from the beginning of `s2` into the middle of `newS`; this is yet another
    example of translating from one range of values to another range of values, which
    we’ve been doing in this text since [Chapter 2](ch02.html "Chapter 2. Pure Puzzles").
    By looking at the element numbers on my diagram, I’m able to see what variables
    I need to put together to compute the right destination subscript. The remainder
    of the function puts the null terminator in place at the end of the new string
    ![](httpatomoreillycomsourcenostarchimages1273197.png). As with `append`, we deallocate
    the original heap memory pointed to by our first parameter ![](httpatomoreillycomsourcenostarchimages1273199.png)
    and repoint the first parameter at the newly allocated string ![](httpatomoreillycomsourcenostarchimages1273203.png).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定我们要连接的两个字符串的长度 ![http://atomoreilly.com/source/nostarch/images/1273182.png]，然后我们将这些值相加，以得到我们完成时连接字符串的长度。记住，所有这些长度都是指有效字符的数量，不包括空终止符。因此，当我们创建堆中的数组来存储新的字符串
    ![http://atomoreilly.com/source/nostarch/images/1273191.png] 时，我们分配一个比总长度多一个的空间来放置终止符。然后我们将两个原始字符串中的字符复制到新的字符串
    ![http://atomoreilly.com/source/nostarch/images/1273193.png]。第一个循环很简单，但请注意第二个循环中的下标计算
    ![http://atomoreilly.com/source/nostarch/images/1273195.png]。我们是从`s2`的开始复制到`newS`的中间；这又是将一个值范围转换为另一个值范围的另一个例子，我们自从[第2章](ch02.html
    "第2章。纯难题")以来一直在做这件事。通过查看我的图上的元素编号，我能够看到我需要组合哪些变量来计算正确的目标下标。函数的其余部分将空终止符放置在新字符串的末尾
    ![http://atomoreilly.com/source/nostarch/images/1273197.png]。与`append`一样，我们释放由我们的第一个参数指向的原始堆内存
    ![http://atomoreilly.com/source/nostarch/images/1273199.png]，并将第一个参数重新指向新分配的字符串
    ![http://atomoreilly.com/source/nostarch/images/1273203.png]。
- en: 'This code appears to work, but as before, we want to make sure that we haven’t
    inadvertently made a function that succeeds for our test case but not all cases.
    The most likely trouble cases would be when either or both of the parameters are
    zero-length strings (just the null terminator). We should check these cases explicitly
    before moving on. Note that when you are checking for correctness in code that
    uses pointers, you should take care to look at the pointers themselves and not
    just the values in the heap that they reference. Here is one test case:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来是可行的，但就像之前一样，我们想要确保我们没有无意中创建了一个只在测试用例中成功但不是所有情况下都成功的函数。最可能的问题情况是当其中一个或两个参数是零长度字符串（仅包含空终止符）时。在继续之前，我们应该明确检查这些情况。请注意，当你检查使用指针的代码的正确性时，你应该注意查看指针本身，而不仅仅是它们引用的堆中的值。以下是一个测试用例：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I wanted to be sure that the call to `concatenate` results in `a` and `c` both
    pointing to the string `test`—that is, that they point to arrays with identical
    values. Equally important, though, is that they point to *different* strings,
    as shown in [Figure 4-8](ch04.html#concatenate_should_result_in_two_distinc "Figure 4-8. concatenate
    should result in two distinct strings (a), not two cross-linked pointers (b).")
    (a). I check this in the second output statement by changing the types of the
    variables to `void *`, which forces the output stream to display the raw value
    of the pointers ![](httpatomoreillycomsourcenostarchimages1273182.png). If the
    pointers themselves had the same value, then we would say that the pointers had
    become *cross-linked*, as shown in [Figure 4-8](ch04.html#concatenate_should_result_in_two_distinc
    "Figure 4-8. concatenate should result in two distinct strings (a), not two cross-linked
    pointers (b).") (b). When pointers have unknowingly become cross-linked, subtle
    problems occur because changing the contents of one variable in the heap mysteriously
    changes another variable—really the same variable, but in a large program, that
    can be hard to see. Also, remember that if two pointers are cross-linked, when
    one of them is deallocated via `delete`, the remaining pointer becomes a dangling
    reference. Therefore, we have to be diligent when we review our code and always
    check potential cross-linking.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我想确保`concatenate`的调用结果使得`a`和`c`都指向字符串`test`——也就是说，它们指向具有相同值的数组。同样重要的是，它们指向的是*不同的*字符串，如图[图4-8](ch04.html#concatenate_should_result_in_two_distinc
    "图4-8. concatenate应产生两个不同的字符串(a)，而不是两个交叉链接的指针(b)")(a)所示。我在第二个输出语句中通过将变量的类型更改为`void
    *`来检查这一点，这迫使输出流显示指针的原始值![图](httpatomoreillycomsourcenostarchimages1273182.png)。如果指针本身具有相同的值，那么我们就会说指针已经*交叉链接*，如图[图4-8](ch04.html#concatenate_should_result_in_two_distinc
    "图4-8. concatenate应产生两个不同的字符串(a)，而不是两个交叉链接的指针(b)")(b)所示。当指针无意中交叉链接时，会引发微妙的问题，因为改变堆中一个变量的内容神秘地改变了另一个变量——实际上它是同一个变量，但在大型程序中，这可能很难发现。此外，记住如果两个指针交叉链接，当其中一个通过`delete`释放时，剩余的指针就变成了悬空引用。因此，我们在审查代码时必须非常小心，并始终检查潜在的交叉链接。
- en: '![concatenate should result in two distinct strings (a), not two cross-linked
    pointers (b).](httpatomoreillycomsourcenostarchimages1273221.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![连接操作应产生两个不同的字符串（a），而不是两个交叉链接的指针（b）](httpatomoreillycomsourcenostarchimages1273221.png.jpg)'
- en: Figure 4-8. `concatenate` should result in two distinct strings (a), not two
    cross-linked pointers (b).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-8. `concatenate`应产生两个不同的字符串（a），而不是两个交叉链接的指针（b）。
- en: With all three functions implemented—`characterAt`, `append`, and -`concatenate`—we’ve
    completed the problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了所有三个函数——`charAt`、`append`和`concatenate`——我们就完成了这个问题。
- en: Linked Lists
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表
- en: Now we’re going to try something trickier. The pointer manipulations will be
    more complicated, but we’ll keep everything straight now that we know how to crank
    out the diagrams.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将尝试一些更复杂的事情。指针操作将会更复杂，但现在我们已经知道如何绘制图表，所以我们会保持一切井然有序。
- en: 'Problem: Tracking an unknown quantity of student records'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：跟踪未知数量的学生记录
- en: 'In this problem, you will write functions to store and manipulate a collection
    of student records. A student record contains a student number and a grade, both
    integers. The following functions are to be implemented:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，你需要编写函数来存储和操作学生记录的集合。学生记录包含一个学生编号和一个成绩，都是整数。以下函数需要实现：
- en: '**`addRecord`**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**`addRecord`**'
- en: This function takes a pointer to a collection of student records (a student
    number and a grade), and it adds a new record with this data to the collection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个指向学生记录集合（学生编号和成绩）的指针，并将包含此数据的新的记录添加到集合中。
- en: '**`averageRecord`**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**`averageRecord`**'
- en: This function takes a pointer to a collection of student records and returns
    the simple average of student grades in the collection as a `double`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个指向学生记录集合的指针，并返回集合中学生成绩的简单平均值，作为`double`类型。
- en: The collection can be of any size. The `addRecord` operation is expected to
    be called frequently, so it must be implemented efficiently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以是任何大小。预期`addRecord`操作会被频繁调用，因此它必须高效实现。
- en: 'A number of approaches would meet the specifications, but we’re going to choose
    a method that helps us practice our pointer-based problem-solving techniques:
    linked lists. You may have already seen a linked list before, but if not, know
    that the introduction of linked lists represents a kind of sea change from what
    we have discussed so far in this text. A good problem-solver could have developed
    any of the previous solutions given enough time and careful thought. Most programmers,
    however, wouldn’t come up with the linked list concept without help. Once you
    see it and master the basics, though, other linked structures will come to mind,
    and then you are off and running. A linked list is truly a dynamic structure.
    Our string arrays were stored in dynamically allocated memory, but once created,
    they were static structures, never getting any larger or smaller, just being replaced.
    A linked list, in contrast, grows piece by piece over time like a daisy chain.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以满足这些规范，但我们将选择一种帮助我们练习基于指针的问题解决技巧的方法：链表。你可能已经见过链表，如果没有，请知道链表的引入代表了从我们在本文中迄今为止讨论的内容的一个重大转变。一个优秀的解决问题者，如果给予足够的时间和仔细的思考，可能会开发出任何前述解决方案。然而，大多数程序员在没有帮助的情况下，可能不会想到链表的概念。一旦你看到了它并掌握了基础知识，其他链式结构就会浮现在脑海中，然后你就可以开始行动了。链表确实是一种动态结构。我们的字符串数组存储在动态分配的内存中，但一旦创建，它们就是静态结构，永远不会变大或变小，只是被替换。相比之下，链表随着时间的推移逐渐增长，就像一串花环。
- en: Building a List of Nodes
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建节点列表
- en: Let’s construct a sample linked list of student records. To make a linked list,
    you need a `struct` that contains a pointer to the same `struct`, in addition
    to whatever data you want to store in the collection represented by the linked
    list. For our problem, the `struct` will contain a student number and grade.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个学生记录的示例链表。为了创建链表，你需要一个`struct`，它包含指向相同`struct`的指针，以及你想要存储在链表表示的集合中的任何数据。对于我们的问题，`struct`将包含学生编号和成绩。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The name of our `struct` is `listNode` ![](httpatomoreillycomsourcenostarchimages1273182.png).
    A `struct` used to create a linked list is always referred to as a *node*. Presumably
    the name is an analogy to the botanical term, meaning a point on a stem from which
    a new branch grows. The node contains the student number ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and grade that make up the real “payload” of the node. The node also contains
    a pointer to the very type of `struct` we are defining ![](httpatomoreillycomsourcenostarchimages1273193.png).
    The first time most programmers see this, it looks confusing and perhaps even
    a syntactical impossibility: How can we define a structure in terms of itself?
    But this is legal, and the meaning will become clear shortly. Note that the self-referring
    pointer in a node is typically given a name like *next*, *nextPtr*, or the like.
    Lastly, this code declares a `typedef` for a pointer to our node type ![](httpatomoreillycomsourcenostarchimages1273195.png).
    This will help the readability of our functions. Now let’s build our sample linked
    list using these types:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`struct`名称是`listNode` ![图片](http://atomoreilly.com/source/nostarch/images/1273182.png)。用于创建链表的`struct`始终被称为*节点*。这个名字可能是对植物学术语的类比，意味着茎上的一个点，从这里长出新枝。节点包含学生编号
    ![图片](http://atomoreilly.com/source/nostarch/images/1273191.png) 和成绩，这些构成了节点的真实“有效负载”。节点还包含一个指向我们正在定义的`struct`类型的指针
    ![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)。大多数程序员第一次看到这个时，可能会觉得困惑，甚至可能是语法上的不可能：我们如何用自身来定义一个结构？但这在语法上是合法的，其含义很快就会变得清晰。请注意，节点中的自引用指针通常被命名为*next*、*nextPtr*或类似名称。最后，此代码为我们的节点类型声明了一个`typedef`
    ![图片](http://atomoreilly.com/source/nostarch/images/1273195.png)。这将有助于提高我们函数的可读性。现在让我们使用这些类型构建我们的示例链表：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We begin by declaring a `studentCollection`, `sc` ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which will eventually become the name for our linked list. Then we declare `node1`
    ![](httpatomoreillycomsourcenostarchimages1273191.png), a pointer to a `listNode`.
    Again, `studentCollection` is synonymous with `node *`, but for readability I’m
    using the `studentCollection` type only for variables that will refer to the whole
    list structure. After declaring `node1` and pointing it to a newly allocated `listNode`
    in the heap ![](httpatomoreillycomsourcenostarchimages1273191.png), we assign
    values to the `studentNum` and `grade` fields in that node ![](httpatomoreillycomsourcenostarchimages1273193.png).
    At this point, the `next` field is unassigned. This is not a book on syntax, but
    if you haven’t seen the `->` notation before, it’s used to indicate the field
    of a pointed-to `struct` (or `class`). So `node1->studentNum` means “the `studentNum`
    field in the `struct` pointed to by `node1`” and is equivalent to `(*node1).studentNum`.
    We then repeat the same process for `node2` and `node3`. After assigning the field
    values to the last node, the state of memory is as shown in [Figure 4-9](ch04.html#halfway_through_building_a_sample_linked
    "Figure 4-9. Halfway through building a sample linked list"). In these diagrams,
    we’ll use the divided-box notation we previously used for arrays to show the node
    `struct`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个`studentCollection`，即`sc` ![studentCollection声明](httpatomoreillycomsourcenostarchimages1273182.png)，这最终将成为我们链表的名字。然后我们声明`node1`
    ![node1声明](httpatomoreillycomsourcenostarchimages1273191.png)，一个指向`listNode`的指针。同样，`studentCollection`与`node
    *`同义，但为了可读性，我只使用`studentCollection`类型来表示将引用整个结构体的变量。在声明`node1`并将其指向堆中新分配的`listNode`
    ![node1指向listNode](httpatomoreillycomsourcenostarchimages1273191.png)之后，我们给该节点的`studentNum`和`grade`字段赋值
    ![studentNum和grade字段赋值](httpatomoreillycomsourcenostarchimages1273193.png)。此时，`next`字段尚未分配。这不是一本关于语法的书，但如果您之前没有见过`->`符号，它用于表示指向的`struct`（或`class`）的字段。所以`node1->studentNum`表示“由`node1`指向的`struct`中的`studentNum`字段”，等同于`(*node1).studentNum`。然后我们对`node2`和`node3`重复相同的步骤。在将字段值赋给最后一个节点后，内存的状态如图[图4-9](ch04.html#halfway_through_building_a_sample_linked
    "图4-9. 构建示例链表的一半")所示。在这些图中，我们将使用之前用于数组的分割框符号来表示节点`struct`。
- en: '![Halfway through building a sample linked list](httpatomoreillycomsourcenostarchimages1273227.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![构建示例链表的一半](httpatomoreillycomsourcenostarchimages1273227.png.jpg)'
- en: Figure 4-9. Halfway through building a sample linked list
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-9. 构建示例链表的一半
- en: 'Now that we have all of our nodes, we can string them together to form a linked
    list. That’s what the rest of the previous code listing does. First, we point
    our `studentCollection` variable to the first node ![](httpatomoreillycomsourcenostarchimages1273197.png),
    then we point the next field of the first node to the second node ![](httpatomoreillycomsourcenostarchimages1273199.png),
    and then we point the next field of the second node to the third node ![](httpatomoreillycomsourcenostarchimages1273203.png).
    In the next step, we assign `NULL` (again, this is just a synonym for zero) to
    the next field of the third node ![](httpatomoreillycomsourcenostarchimages1273223.png).
    We do this for the same reason we put a null character at the end of our arrays
    in the previous problem: to terminate the structure. Just as we needed a special
    character to show us the end of the array, we need a zero in the next field of
    the last node in our linked list so that we know it *is* the last node. Finally,
    to clean things up and avoid potential cross-linking problems, we assign `NULL`
    to each of the individual node pointers ![](httpatomoreillycomsourcenostarchimages1273225.png).
    The resulting state of memory is shown in [Figure 4-10](ch04.html#the_completed_sample_linked_list
    "Figure 4-10. The completed sample linked list").'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有的节点，我们可以将它们串联起来形成一个链表。这正是之前代码列表中剩余部分所做的事情。首先，我们将我们的`studentCollection`变量指向第一个节点
    ![第一个节点](httpatomoreillycomsourcenostarchimages1273197.png)，然后我们将第一个节点的`next`字段指向第二个节点
    ![第二个节点](httpatomoreillycomsourcenostarchimages1273199.png)，接着我们将第二个节点的`next`字段指向第三个节点
    ![第三个节点](httpatomoreillycomsourcenostarchimages1273203.png)。在下一步中，我们将第三个节点的`next`字段赋值为`NULL`（再次强调，这只是一个零的同义词）![第三个节点](httpatomoreillycomsourcenostarchimages1273223.png)。我们这样做的原因和我们在上一个问题中在数组末尾放置空字符的原因相同：为了终止结构。正如我们需要一个特殊字符来显示数组的结束一样，我们也在链表最后一个节点的`next`字段中需要一个零，这样我们就能知道它*确实是*最后一个节点。最后，为了清理并避免潜在的交叉链接问题，我们将每个单独的节点指针赋值为`NULL`
    ![节点指针](httpatomoreillycomsourcenostarchimages1273225.png)。内存的最终状态如图[图4-10](ch04.html#the_completed_sample_linked_list
    "图4-10. 完成的示例链表")所示。
- en: '![The completed sample linked list](httpatomoreillycomsourcenostarchimages1273229.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![完成的示例链表](http://atomoreilly.com/source/nostarch/images/1273229.png)'
- en: Figure 4-10. The completed sample linked list
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-10. 完成的示例链表
- en: 'With this visual in front of us, it’s clear why the structure is called a linked
    list: Each node in the list is linked to the next. You’ll often see linked lists
    drawn linearly, but I actually prefer the scattered-in-memory look of this diagram
    because it emphasizes that these nodes have no relationship to each other besides
    the links; each of them could be anywhere inside the heap. Make sure you trace
    through the code until you are confident you agree with the diagram.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们面前有这个视觉图，很明显为什么这个结构被称为链表：列表中的每个节点都链接到下一个。你经常会看到链表被线性绘制，但我实际上更喜欢这个图在内存中分散的外观，因为它强调这些节点之间除了链接外没有其他关系；它们中的每一个都可以在堆的任何地方。确保你跟踪代码，直到你确信你同意这个图。
- en: Notice that, in the concluding state, only one stack-based pointer remains in
    use, our `studentCollection` variable `sc`, which points to the first node. A
    pointer external to the list (that is, not the `next` field of a node in the list)
    that points to the first node in a linked list is known as a *head pointer*. On
    a symbolic level, this variable represents the list as a whole, but of course
    it directly references only the first node. To get to the second node, we have
    to go through the first, and to get to the third node, we have to go through the
    first two, and so on. This means that linked lists offer only sequential access,
    as opposed to the random access provided by arrays. Sequential access is the weakness
    of linked-list structures. The strength of linked-list structures, as previously
    alluded to, is our ability to grow or shrink the size of the structure by adding
    or removing nodes, without having to create an entirely new structure and copy
    the data over, as we’ve done with arrays.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最终状态中，只有一个基于栈的指针仍在使用，即我们的`studentCollection`变量`sc`，它指向第一个节点。指向链表中第一个节点的外部指针（即不是链表中节点的`next`字段）被称为*头指针*。在符号层面上，这个变量代表整个列表，但当然它直接引用的只是第一个节点。要到达第二个节点，我们必须通过第一个节点，要到达第三个节点，我们必须通过前两个节点，依此类推。这意味着链表只能提供顺序访问，而不是数组提供的随机访问。顺序访问是链表结构的弱点。正如之前提到的，链表结构的优势在于，我们可以通过添加或删除节点来增长或缩小结构的大小，而无需创建一个全新的结构并复制数据，就像我们处理数组那样。
- en: Adding Nodes to a List
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向链表中添加节点
- en: 'Now let’s implement the `addRecord` function. This function is going to create
    a new node and connect it into an existing linked list. We’ll use the same techniques
    we used in the previous problem. First up: a function shell and a sample call.
    For testing, we’ll add code to the previous listing, so `sc` already exists as
    the head pointer to the list of three nodes.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现`addRecord`函数。这个函数将创建一个新的节点并将其连接到现有的链表中。我们将使用之前问题中使用的相同技术。首先：一个函数外壳和一个示例调用。为了测试，我们将代码添加到上一个列表中，因此`sc`已经存在，作为指向三个节点列表的头指针。
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Again, the ![](httpatomoreillycomsourcenostarchimages1273182.png) call would
    come at the end of the previous listing. With the function shell outlining the
    parameters, we can diagram the “before” state of this call, as shown in [Figure 4-11](ch04.html#the_lbeforer_state_for_the_addrecord_fun
    "Figure 4-11. The “before” state for the addRecord function").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)的调用将在上一个列表的末尾进行。使用函数shell定义参数，我们可以绘制这个调用的“之前”状态，如图[图4-11](ch04.html#the_lbeforer_state_for_the_addrecord_fun
    "图4-11. addRecord函数的“之前”状态")所示。
- en: '![The “before” state for the addRecord function](httpatomoreillycomsourcenostarchimages1273231.png.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![addRecord函数的“之前”状态](http://atomoreilly.com/source/nostarch/images/1273231.png.jpg)'
- en: Figure 4-11. The “before” state for the `addRecord` function
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11. addRecord函数的“之前”状态
- en: Regarding the “after” state, though, we have a choice. We can guess that we’re
    going to create a new node in the heap and copy the values from the parameters
    `stuNum` and `gr` into the `studentNum` and `grade` fields of the new node. The
    question is where this node is going to go, logically, in our linked list. The
    most obvious choice would be at the end; there’s a `NULL` value in a `next` field
    just asking to be pointed to a new node. That would correspond to [Figure 4-12](ch04.html#proposed_lafterr_state_for_addrecord_fun
    "Figure 4-12. Proposed “after” state for addRecord function").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于“之后”的状态，我们有一个选择。我们可以猜测我们将在堆中创建一个新节点，并将参数`stuNum`和`gr`的值复制到新节点的`studentNum`和`grade`字段中。问题是这个节点在逻辑上将在我们的链表中去哪里。最明显的选择是在末尾；`next`字段中的`NULL`值正等着指向一个新节点。这对应于[图4-12](ch04.html#proposed_lafterr_state_for_addrecord_fun
    "图4-12. 为addRecord函数提出的“之后”状态")。
- en: '![Proposed “after” state for addRecord function](httpatomoreillycomsourcenostarchimages1273233.png.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![为addRecord函数提出的“之后”状态](httpatomoreillycomsourcenostarchimages1273233.png.jpg)'
- en: Figure 4-12. Proposed “after” state for `addRecord` function
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-12. 为`addRecord`函数提出的“之后”状态
- en: But if we can assume that the order of the records doesn’t matter (that we don’t
    need to keep the records in the same order they were added to the collection),
    then this is the wrong choice. To see why, consider a collection, not of three
    student records, but of 3,000\. To reach the last record in our linked list in
    order to modify its `next` field would require traveling through all 3,000 nodes.
    That’s unacceptably inefficient because we can get the new node into the list
    without traveling through *any* of the existing nodes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们假设记录的顺序不重要（即我们不需要按照记录添加到集合中的顺序来保留记录），那么这就不对了。为了理解原因，考虑一个包含3,000条学生记录的集合，而不是3条。为了按顺序到达链表的最后一个记录以修改其`next`字段，需要遍历所有3,000个节点。这是不可接受的低效，因为我们可以在不遍历任何现有节点的情况下将新节点放入列表中。
- en: '[Figure 4-13](ch04.html#acceptable_lafterr_state_for_addrecord_f "Figure 4-13. Acceptable
    “after” state for addRecord function. The dashed arrow indicates the previous
    value of the pointer stored in sc.") shows how. After the new node is created,
    it is linked into the list at the *beginning*, not at the end. In the “after”
    state, our head pointer `sc` points to the new node, while the `next` field of
    the new node points to what was previously the first node in the list, the one
    with student number 1001\. Note that while we assign a value to that `next` field
    of the new node, the only existing pointer that changes is `sc`, and none of the
    values in the existing nodes are altered or even inspected. Working from our diagram,
    here’s the code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-13](ch04.html#acceptable_lafterr_state_for_addrecord_f "图4-13. addRecord函数可接受的“之后”状态。虚线箭头表示存储在sc中的指针的先前值。")展示了如何实现。新节点创建后，它被链接到列表的*开头*，而不是末尾。在“之后”状态中，我们的头指针`sc`指向新节点，而新节点的`next`字段指向列表中之前的第一节点，即学生编号为1001的那个节点。请注意，虽然我们为新节点的`next`字段赋值，但唯一改变的现有指针是`sc`，且现有节点中的任何值都没有改变或被检查。根据我们的图，以下是代码：'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Acceptable “after” state for addRecord function. The dashed arrow indicates
    the previous value of the pointer stored in sc.](httpatomoreillycomsourcenostarchimages1273235.png.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![addRecord函数可接受的“之后”状态。虚线箭头表示存储在sc中的指针的先前值。](httpatomoreillycomsourcenostarchimages1273235.png.jpg)'
- en: Figure 4-13. Acceptable “after” state for `addRecord` function. The dashed arrow
    indicates the previous value of the pointer stored in `sc`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-13. 为`addRecord`函数提出的可接受的“之后”状态。虚线箭头表示存储在`sc`中的指针的先前值。
- en: Again, let me emphasize that translating a diagram and that code is a lot easier
    than trying to keep things straight in your head. The code comes directly from
    the illustration. We create a new node ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and assign the student number and grade from the parameters ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Then we link the new node into the list, first by pointing the `next` field of
    the new node to the former first node (by assigning it the value of `sc`) ![](httpatomoreillycomsourcenostarchimages1273193.png)
    and then by pointing `sc` itself at the new node ![](httpatomoreillycomsourcenostarchimages1273195.png).
    Note that the last two steps have to happen in that order; we need to use the
    original value of `sc` before we change it. Also note that because we change `sc`,
    it must be a reference parameter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，翻译图表和代码要比试图在脑海中保持事物清晰容易得多。代码直接来自插图。我们创建一个新节点![新节点](http://atomoreilly.com/source/no
    starch/images/1273182.png)并从参数![参数](http://atomoreilly.com/source/no starch/images/1273191.png)中分配学生编号和成绩。然后我们将新节点链接到列表中，首先通过将新节点的`next`字段指向前一个第一个节点（通过分配给它`sc`的值）![这个值](http://atomoreilly.com/source/no
    starch/images/1273193.png)，然后通过将`sc`本身指向新节点![这个值](http://atomoreilly.com/source/no
    starch/images/1273195.png)。注意，最后两个步骤必须按那个顺序发生；在我们改变它之前，我们需要使用`sc`的原始值。还要注意，因为我们改变了`sc`，它必须是一个引用参数。
- en: As always, when we build code from a sample case, we have to check potential
    special cases. Here, that means checking to see that the function works with an
    empty list. With our string arrays, an empty string was still a valid pointer
    because we still had an array to point to, an array with just the null terminating
    character. Here, though, the number of nodes is the same as the number of records,
    and an empty list would be a `NULL` head pointer. Will our code still hold up
    if we try to insert our sample data when the incoming head pointer is `NULL`?
    [Figure 4-14](ch04.html#the_lbeforer_and_lafterr_states_for_the "Figure 4-14. The
    “before” and “after” states for the smallest addRecord case") shows the “before”
    state and the desired “after” state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，当我们从一个示例案例构建代码时，我们必须检查潜在的特殊情况。这里，这意味着检查函数是否能够与空列表一起工作。在我们的字符串数组中，空字符串仍然是一个有效的指针，因为我们仍然有一个数组可以指向，一个只包含空终止字符的数组。然而，这里的节点数量与记录数量相同，一个空列表将是一个`NULL`头指针。如果我们尝试在传入的头指针为`NULL`时插入示例数据，我们的代码还能保持有效吗？[图4-14](ch04.html#the_lbeforer_and_lafterr_states_for_the
    "图4-14. 最小addRecord案例的“之前”和“之后”状态")显示了“之前”状态和期望的“之后”状态。
- en: Walking this example through our code, we see that it handles this case fine.
    The new node is created just as before. Because `sc` is `NULL` in the “before”
    state, when ![](httpatomoreillycomsourcenostarchimages1273193.png) this value
    is copied into the `next` field of our new node, that’s exactly what we want,
    and our one-node list is properly terminated. Note that if we had continued with
    the other implementation idea—adding the new node at the end of the linked list
    rather than at the beginning—an initially empty list *would* be a special case
    because it would then be the only case in which `sc` is modified.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个示例通过我们的代码走一遍，我们看到它很好地处理了这个情况。新节点就像之前一样被创建。因为“之前”状态下`sc`是`NULL`，当![这个值](http://atomoreilly.com/source/no
    starch/images/1273193.png)被复制到我们新节点的`next`字段时，这正是我们想要的，并且我们的单节点列表被正确终止。注意，如果我们继续使用其他实现想法——在链表末尾而不是在开头添加新节点——一个最初为空的列表*将会*是一个特殊情况，因为那时它将是唯一一个`sc`被修改的情况。
- en: '![The “before” and “after” states for the smallest addRecord case](httpatomoreillycomsourcenostarchimages1273237.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![最小addRecord案例的“之前”和“之后”状态](http://atomoreilly.com/source/no starch/images/1273237.png.jpg)'
- en: Figure 4-14. The “before” and “after” states for the smallest `addRecord` case
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-14. 最小`addRecord`案例的“之前”和“之后”状态
- en: List Traversal
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表遍历
- en: Now it’s time to figure out the `averageRecord` function. As before, we’ll start
    with a shell and a diagram. Here’s the function shell and sample call. Assume
    the sample call ![](httpatomoreillycomsourcenostarchimages1273182.png) occurs
    after the creation of our original sample list, as shown in [Figure 4-10](ch04.html#the_completed_sample_linked_list
    "Figure 4-10. The completed sample linked list").
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候弄清楚`averageRecord`函数了。和之前一样，我们将从一个shell和一个图表开始。这是函数shell和示例调用。假设示例调用![示例调用](http://atomoreilly.com/source/no
    starch/images/1273182.png)发生在我们原始示例列表创建之后，如图[图4-10](ch04.html#the_completed_sample_linked_list
    "图4-10. 完成的示例链表")所示。
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, I’ve chosen to compute the average as an `int`, as we did with
    arrays in the previous chapter. Depending on the problem, however, it might be
    better to compute it as a floating point value. Now we need a diagram, but we
    pretty much already have a “before” state with [Figure 4-9](ch04.html#halfway_through_building_a_sample_linked
    "Figure 4-9. Halfway through building a sample linked list"). We don’t need a
    diagram for the “after” state because this function isn’t going to change our
    dynamic structure, just report on it. We just need to know the expected result,
    which in this case is about 85.3333.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我选择将平均值计算为一个`int`，就像我们在上一章处理数组时做的那样。然而，根据问题的不同，可能最好将其计算为一个浮点数。现在我们需要一个图表，但我们几乎已经有了“之前”的状态，即[图4-9](ch04.html#halfway_through_building_a_sample_linked
    "图4-9. 构建一个示例链表的一半")。我们不需要“之后”状态的图表，因为这个函数不会改变我们的动态结构，只是报告它。我们只需要知道预期的结果，在这种情况下大约是85.3333。
- en: 'So how do we actually compute the average? From our experience computing the
    average of all values in an array, we know the general concept. We need to add
    up every value in the collection and then divide that sum by the number of values.
    With our array averaging code, we inspected every value using a `for` loop from
    0 to one less than the size of the array, using the loop counter as the array
    subscript. We can’t use a `for` loop here because we don’t know ahead of time
    how many numbers are in the linked list; we have to keep going until we reach
    the `NULL` value in a node’s `next` field indicating list termination. This suggests
    a `while` loop, something like what we used earlier in this chapter to process
    our arrays of unknown length. Running through a linked list like this, from beginning
    to terminus, is known as a *list traversal*. This is one of the basic operations
    on a linked list. Let’s put the traversal idea to work to solve this problem:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上是如何计算平均值的呢？从我们计算数组中所有值平均值的经验中，我们知道一般概念。我们需要将集合中的每个值加起来，然后将这个总和除以值的数量。使用我们的数组平均值代码，我们使用`for`循环从0到数组大小减一来检查每个值，使用循环计数器作为数组索引。我们在这里不能使用`for`循环，因为我们事先不知道链表中有多少数字；我们必须继续进行，直到我们到达节点`next`字段中的`NULL`值，这表示列表结束。这表明我们需要一个`while`循环，类似于我们在本章早期用于处理未知长度数组的循环。以这种方式遍历链表，从开始到结束，被称为*链表遍历*。这是链表上的基本操作之一。让我们将遍历的想法付诸实践来解决这个难题：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We start by declaring a variable `count` to store the number of nodes we encounter
    in the list ![](httpatomoreillycomsourcenostarchimages1273182.png); this will
    also be the number of values in the collection, which we’ll use to compute the
    average. Next we declare a variable `sum` to store the running total of grade
    values in the list ![](httpatomoreillycomsourcenostarchimages1273191.png). Then
    we declare a `listNode *` called `loopPtr`, which we’ll use to traverse the list
    ![](httpatomoreillycomsourcenostarchimages1273193.png). This is the equivalent
    of our integer loop variable in an array-processing `for` loop; it keeps track
    of where we are in the linked list, not with the position number but by storing
    a pointer to the node we are processing currently.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个变量`count`来存储我们在列表中遇到的节点数量 ![http://atomoreilly.com/source/no_starch_images/1273182.png](http://atomoreilly.com/source/no_starch_images/1273182.png)；这也会是集合中的值数，我们将用它来计算平均值。接下来，我们声明一个变量`sum`来存储列表中成绩值的累计总和
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]。然后我们声明一个名为`listNode
    *`的变量`loopPtr`，我们将用它来遍历列表 ![http://atomoreilly.com/source/no_starch_images/1273193.png]。这相当于数组处理`for`循环中的整数循环变量；它跟踪我们在链表中的位置，不是通过位置数字，而是通过存储我们正在处理的节点的指针。
- en: At this point, the traversal itself begins. The traversal loop continues until
    our loop-tracking pointer reaches our terminating `NULL` ![](httpatomoreillycomsourcenostarchimages1273195.png).
    Inside the loop, we add the value of the `grade` field in the currently referenced
    node to `sum` ![](httpatomoreillycomsourcenostarchimages1273197.png). We increment
    the `count` ![](httpatomoreillycomsourcenostarchimages1273199.png), and then we
    assign the `next` field of the current node to our loop-tracking pointer ![](httpatomoreillycomsourcenostarchimages1273203.png).
    This has the effect of moving our traversal one node ahead. This is the tricky
    part of the code, so let’s make sure we have this straight. In [Figure 4-15](ch04.html#how_the_local_variable_loopptr_changes_d
    "Figure 4-15. How the local variable loopPtr changes during loop iterations in
    the averageRecord function"), I’m showing how the node variable changes over time.
    The letters (a) through (d) mark different points during the execution of the
    code on our sample data, showing different points during the lifetime of `loopPtr`
    and the locations from which `loopPtr`’s value has been obtained. Point (a) is
    just as the loop begins; `loopPtr` has just been initialized with the value of
    `sc`. Therefore, `loopPtr` points to the first node in the list, just as `sc`
    does. During the first iteration of the loop, then, the first node’s grade value
    of `78` is added to `sum`. The first node’s next value is copied to `loopPtr`
    so that now `loopPtr` points to the second node of the list; this is point (b).
    During the second iteration, we add `93` to `sum` and copy the `next` field of
    the second node to `loopPtr`; this is point (c). Finally, during the third and
    last iteration of the loop, we add `85` to `sum` and assign the `NULL` of the
    `next` field in the third node to `loopPtr`; this is point (d). When we reach
    the top of the `while` loop again, the loop ends because `loopPtr` is `NULL`.
    Because we incremented `count` each time we iterated, `count` is three.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，遍历本身开始。遍历循环会一直持续到我们的遍历跟踪指针达到终止的`NULL` ![httpatomoreillycomsourcenostarchimages1273195.png](httpatomoreillycomsourcenostarchimages1273195.png)。在循环内部，我们将当前引用的节点中`grade`字段的值添加到`sum`
    ![httpatomoreillycomsourcenostarchimages1273197.png](httpatomoreillycomsourcenostarchimages1273197.png)。我们增加`count`
    ![httpatomoreillycomsourcenostarchimages1273199.png](httpatomoreillycomsourcenostarchimages1273199.png)，然后我们将当前节点的`next`字段赋值给我们的遍历跟踪指针
    ![httpatomoreillycomsourcenostarchimages1273203.png](httpatomoreillycomsourcenostarchimages1273203.png)。这相当于将我们的遍历移动到下一个节点。这是代码中的难点部分，所以让我们确保这一点是正确的。在[图4-15](ch04.html#how_the_local_variable_loopptr_changes_d
    "图4-15. 在`averageRecord`函数中循环迭代期间局部变量`loopPtr`如何变化")中，我展示了节点变量随时间的变化。字母(a)到(d)标记了代码在样本数据上执行的不同点，显示了`loopPtr`的生命周期中的不同点和`loopPtr`值被获取的位置。点(a)是循环开始时；`loopPtr`刚刚被初始化为`sc`的值。因此，`loopPtr`指向列表中的第一个节点，就像`sc`一样。在循环的第一次迭代中，第一个节点的成绩值`78`被添加到`sum`。第一个节点的`next`值被复制到`loopPtr`，因此现在`loopPtr`指向列表的第二个节点；这是点(b)。在第二次迭代中，我们将`93`添加到`sum`，并将第二个节点的`next`字段复制到`loopPtr`；这是点(c)。最后，在第三次也是最后一次迭代中，我们将`85`添加到`sum`，并将第三个节点的`next`字段的`NULL`赋值给`loopPtr`；这是点(d)。当我们再次到达`while`循环的顶部时，循环结束，因为`loopPtr`是`NULL`。因为我们每次迭代都会增加`count`，所以`count`是三。
- en: '![How the local variable loopPtr changes during loop iterations in the averageRecord
    function](httpatomoreillycomsourcenostarchimages1273239.png.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![在`averageRecord`函数中循环迭代期间局部变量`loopPtr`如何变化](httpatomoreillycomsourcenostarchimages1273239.png.jpg)'
- en: Figure 4-15. How the local variable `loopPtr` changes during loop iterations
    in the `averageRecord` function
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-15. 在`averageRecord`函数中循环迭代期间局部变量`loopPtr`如何变化
- en: Once the loop is all done, we just divide the sum by the count and return the
    result ![](httpatomoreillycomsourcenostarchimages1273223.png).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦循环全部完成，我们只需将总和除以计数并返回结果 ![httpatomoreillycomsourcenostarchimages1273223.png](httpatomoreillycomsourcenostarchimages1273223.png)。
- en: The code works on our sample case, but as always, we need to check for potential
    special cases. Again, with lists, the most obvious special case is an empty list.
    What happens with our code if `sc` is `NULL` when the function begins?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在我们的样本案例中是有效的，但就像往常一样，我们需要检查潜在的特殊情况。再次强调，对于列表来说，最明显的特殊情况是空列表。如果函数开始时`sc`是`NULL`，我们的代码会发生什么？
- en: 'Guess what? The code blows up. (I had to make one of these special cases turn
    out badly; otherwise, you wouldn’t take me seriously.) There’s nothing wrong with
    the loop for the processing of the linked list itself. If `sc` is `NULL`, then
    `loopPtr` is initialized to `NULL`, the loop ends as soon as it begins, and `sum`
    is left at zero, which seems reasonable enough. The problem is when we perform
    the division to compute the average ![](httpatomoreillycomsourcenostarchimages1273223.png),
    `count` is also zero, which means we are dividing by zero and which will result
    in either a program crash or a garbage result. To handle this special case, we
    could check `count` against zero at the end of the function, but why not handle
    the situation up front and check `sc`? Let’s add the following as the new first
    line in our `averageRecord` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？代码崩溃了。（我不得不让其中一个特殊情况结果不好；否则，你们就不会认真对待我了。）对于处理链表本身的循环没有问题。如果`sc`是`NULL`，则`loopPtr`初始化为`NULL`，循环一开始就结束，`sum`保持在零，这似乎是合理的。问题是当我们执行计算平均值的除法操作时，`count`也是零，这意味着我们在除以零，这将导致程序崩溃或产生垃圾结果。为了处理这个特殊情况，我们可以在函数末尾检查`count`是否为零，但为什么不一开始就处理这种情况并检查`sc`呢？让我们在`averageRecord`函数的新第一行添加以下内容：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As this example shows, handling special cases is usually pretty simple. We just
    have to make sure we take the time to identify them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个例子所示，处理特殊情况通常很简单。我们只需要确保我们花时间来识别它们。
- en: Conclusion and Next Steps
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论和下一步
- en: This chapter has just scratched the surface of problem solving using pointers
    and dynamic memory. You’ll see pointers and heap allocations throughout the rest
    of this text. For example, object-oriented programming techniques, which we’ll
    discuss in [Chapter 5](ch05.html "Chapter 5. Solving Problems with Classes"),
    are especially helpful when dealing with pointers. They allow us to encapsulate
    pointers in such a way that we don’t have to worry about memory leaks, dangling
    pointers, or any of the other common pointer pitfalls.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是刚刚触及使用指针和动态内存进行问题解决的一角。你将在本书的其余部分看到指针和堆分配。例如，面向对象编程技术，我们将在[第5章](ch05.html
    "第5章。使用类解决问题")中讨论，在处理指针时特别有用。它们允许我们将指针封装起来，这样我们就不必担心内存泄漏、悬垂指针或任何其他常见的指针陷阱。
- en: 'Even though there is much more to learn about problem solving in this area,
    you’ll be able to develop your skills with pointer-based structures of increasing
    complexity if you follow the basic ideas in this chapter: First, apply the general
    rules of problem solving. Then, apply specific rules for pointers, and use a diagram
    or similar tool to visualize each solution before you start coding.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个领域还有更多关于问题解决要学习的内容，但如果你遵循本章的基本思想，你将能够通过指针结构的递增复杂性来发展你的技能：首先，应用问题解决的一般规则。然后，应用指针的特定规则，并在开始编码之前使用图表或类似工具来可视化每个解决方案。
- en: Exercises
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: I’m not kidding about doing the exercises. You’re not just reading the chapters
    and moving on, are you?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是在开玩笑，关于做练习。你不是只是阅读章节然后继续前进，对吧？
- en: 'Design your own: Take a problem that you already know how to solve using an
    array but that is limited by the size of the array. Rewrite the code to remove
    that limitation using a dynamically allocated array.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的：取一个你已经知道如何使用数组解决的问题，但受限于数组大小。将代码重写为使用动态分配的数组来移除这种限制。
- en: 'For our dynamically allocated strings, create a function `substring` that takes
    three parameters: an `arrayString`, a starting position integer, and an integer
    length of characters. The function returns a pointer to a new dynamically allocated
    string array. This string array contains the characters in the original string,
    starting at the specified position for the specified length. The original string
    is unaffected by the operation. So if the original string was `abcdefg`, the position
    was 3, and the length was 4, then the new string would contain `cdef`.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们动态分配的字符串，创建一个名为`substring`的函数，该函数接受三个参数：一个`arrayString`，一个起始位置整数，以及一个字符长度的整数。该函数返回一个指向新动态分配的字符串数组的指针。这个字符串数组包含原始字符串中的字符，从指定的位置开始，长度为指定的长度。原始字符串不受此操作的影响。所以如果原始字符串是`abcdefg`，位置是3，长度是4，那么新字符串将包含`cdef`。
- en: 'For our dynamically allocated strings, create a function `replaceString` that
    takes three parameters, each of type `arrayString`: `source`, `target`, and `replaceText`.
    The function replaces every occurrence of `target` in `source` with `replaceText`.
    For example, if `source` points to an array containing `abcdabee`, `target` points
    to `ab`, and `replaceText` points to `xyz`, then when the function ends, `source`
    should point to an array containing `xyzcdxyzee`.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的动态分配的字符串，创建一个名为`replaceString`的函数，该函数接受三个参数，每个参数的类型为`arrayString`：`source`、`target`和`replaceText`。该函数将`source`中`target`的每个出现替换为`replaceText`。例如，如果`source`指向一个包含`abcdabee`的数组，`target`指向`ab`，而`replaceText`指向`xyz`，那么当函数结束时，`source`应该指向一个包含`xyzcdxyzee`的数组。
- en: Change the implementation of our strings such that `location[0]` in the array
    stores the size of the array (and therefore `location[1]` stores the first actual
    character in the string), rather than using a null-character terminator. Implement
    each of the three functions, `append`, `concatenate`, and `charactertAt`, taking
    advantage of the stored size information whenever possible. Because we’ll no longer
    be using the null-termination convention expected by the standard output stream,
    you’ll need to write your own `output` function that loops through its string
    parameter, displaying the characters.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改我们字符串的实现，使得数组中的`location[0]`存储数组的大小（因此`location[1]`存储字符串中的第一个实际字符），而不是使用空字符终止符。实现每个三个函数，`append`、`concatenate`和`charactertAt`，尽可能利用存储的大小信息。因为我们不再使用标准输出流期望的空终止符约定，你需要编写自己的`output`函数，该函数遍历其字符串参数，显示字符。
- en: Write a function `removeRecord` that takes a pointer to a `studentCollection`
    and a student number and that removes the record with that student number from
    the collection.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`removeRecord`的函数，该函数接受一个指向`studentCollection`的指针和一个学生编号，并从集合中删除具有该学生编号的记录。
- en: Let’s create an implementation for strings that uses a linked list of characters
    instead of dynamically allocated arrays. So we’ll have a linked list where the
    data payload is a single char; this will allow strings to grow without having
    to re-create the entire string. We’ll start by implementing the `append` and `characterAt`
    functions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为字符串创建一个实现，它使用字符链表而不是动态分配的数组。因此，我们将有一个链表，其数据负载是单个字符；这将允许字符串在不重新创建整个字符串的情况下增长。我们将从实现`append`和`characterAt`函数开始。
- en: Following up on the previous exercise, implement the `concatenate` function.
    Note that if we make a call `concatenate(s1, s2)`, where both parameters are pointers
    to the first nodes of their respective linked lists, the function should create
    a copy of each of the nodes in `s2` and append them to the end of `s1`. That is,
    the function should not simply point the `next` field of the last node in `s1`’s
    list to the first node of `s2`’s list.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个练习的基础上，实现`concatenate`函数。注意，如果我们调用`concatenate(s1, s2)`，其中两个参数都是它们各自链表第一个节点的指针，该函数应该创建`s2`中每个节点的副本并将它们追加到`s1`的末尾。也就是说，该函数不应该简单地将`s1`链表中最后一个节点的`next`字段指向`s2`链表中的第一个节点。
- en: Add a function to the linked-list string implementation called `removeChars`
    to remove a section of characters from a string based on the position and length.
    For example, `removeChars(s1, 5, 3)` would remove the three characters starting
    at the fifth character in the string. Make sure the removed nodes are properly
    deallocated.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向链表字符串实现添加一个名为`removeChars`的函数，用于根据位置和长度从字符串中删除一段字符。例如，`removeChars(s1, 5, 3)`将删除从第五个字符开始的三个字符。确保已正确释放被删除节点的内存。
- en: 'Imagine a linked list where instead of the node storing a character, the node
    stores a digit: an `int` in the range 0–9\. We could represent positive numbers
    of any size using such a linked list; the number 149, for example, would be a
    linked list in which the first node stores a 1, the second a 4, and the third
    and last a 9\. Write a function `intToList` that takes an integer value and produces
    a linked list of this sort. Hint: You may find it easier to build the linked list
    backward, so if the value were 149, you would create the 9 node first.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一个链表，其中节点存储的不是字符，而是数字：一个范围在0到9之间的`int`。我们可以使用这样的链表来表示任何大小的正数；例如，数字149将是一个链表，其中第一个节点存储一个1，第二个节点存储一个4，最后一个节点存储一个9。编写一个名为`intToList`的函数，该函数接受一个整数值并生成这种类型的链表。提示：你可能发现从后向前构建链表更容易，所以如果值是149，你首先创建9节点。
- en: For the digit list of the previous exercise, write a function that takes two
    such lists and produces a new list representing their sum.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于前一个练习的数字列表，编写一个函数，该函数接受两个这样的列表并生成一个表示它们和的新列表。
