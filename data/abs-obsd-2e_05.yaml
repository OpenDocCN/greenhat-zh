- en: Chapter 5. The Boot Process
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章. 引导过程
- en: '*Single-user mode*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*单用户模式*'
- en: '*unscheduled in the nighttime?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*夜间不按计划进行？*'
- en: '*Something just went “boom”!*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*有什么东西“砰”的一声爆炸了！*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) In order to properly
    manage any computing platform, you must understand the boot process. Many systems
    administration tasks cannot be done while the system is running. OpenBSD specifically
    requires that certain tasks be done before the boot process has completed. And,
    of course, on any operating system, sometimes a process starting up prevents the
    system from completing its boot. The only way to fix these problems is to interrupt
    the boot partway through.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![引导加载程序](httpatomoreillycomsourcenostarchimages1616079.png) 为了正确管理任何计算平台，你必须了解引导过程。许多系统管理任务在系统运行时无法完成。OpenBSD
    特别要求在引导过程完成之前完成某些任务。当然，在任何操作系统上，有时启动进程会阻止系统完成引导。解决这些问题的唯一方法是中断引导过程。'
- en: 'First, we’ll look at the key to OpenBSD’s booting process: the boot loader.
    Then we’ll move on to single-user mode, and finally multiuser startup. You can
    perform useful work at any of these stages.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨 OpenBSD 引导过程的关键：引导加载程序。然后，我们将继续讨论单用户模式，最后是多用户启动。在这些阶段中，你可以执行一些有用的工作。
- en: I recommend playing with the OpenBSD boot process on a test machine *before*
    one of your machines won’t boot. That way, when something breaks in the wee hours
    of the morning, you can spend your time fixing the problem instead of fumbling
    around with unfamiliar commands.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在机器无法引导之前在测试机器上玩 OpenBSD 引导过程。这样，当凌晨时分出现问题，你可以花时间解决问题，而不是笨拙地使用不熟悉的命令。
- en: Power-On and the Boot Loader
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开机与引导加载程序
- en: In general, when a PC-style computer first boots, it starts the BIOS. The BIOS
    is a small piece of software that figures out things like which drives are attached
    and what they’re attached to, what sort of CPU is installed, and how much memory
    is available. After getting that information, the BIOS loads a minimal boot loader
    from some kind of storage device.^([[11](#ftn.id369126)])
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当 PC 风格的计算机首次引导时，它会启动 BIOS。BIOS 是一小块软件，用于确定哪些驱动器已连接以及它们连接到什么，安装了哪种 CPU，以及有多少可用内存。在获取这些信息后，BIOS
    从某种存储设备加载一个最小引导加载程序。[^[[11](#ftn.id369126])]
- en: The *boot loader* is a small program that handles initial system configuration
    and boots the kernel. It finds and starts the kernel, which in turn detects hardware,
    attaches device drivers, and performs other core setup. Finally, the kernel calls
    `init(8)`, which starts processes and enables user programs, network interfaces,
    server software, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*引导加载程序* 是一个小程序，负责处理初始系统配置并引导内核。它找到并启动内核，内核随后检测硬件，附加设备驱动程序，并执行其他核心设置。最后，内核调用
    `init(8)`，该程序启动进程并启用用户程序、网络接口、服务器软件等。'
- en: While most of this process cannot be managed—no one actually configures `init`!—there’s
    plenty you can do before the system finishes booting and dumps you at the login
    screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数此过程无法管理——没有人实际配置 `init`！——但在系统完成引导并将你置于登录屏幕之前，你可以做很多事情。
- en: The OpenBSD boot loader lets you interrupt the boot process, configure the system
    before it boots, adjust kernel settings, and even boot an alternate kernel.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 引导加载程序允许你在引导过程中中断，在引导之前配置系统，调整内核设置，甚至引导备用内核。
- en: 'When the hardware hands control of the boot process over to the OpenBSD partition,
    you’ll see the boot loader prompt, which looks something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当硬件将引导过程控制权交给 OpenBSD 分区时，你会看到引导加载程序提示符，其外观可能如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The boot loader’s main purpose is to find the kernel, load it into memory, and
    start it. Because it runs before the kernel starts, the boot loader can pass instructions
    to the kernel itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序的主要目的是找到内核，将其加载到内存中，并启动它。因为它在内核启动之前运行，所以引导加载程序可以向内核本身传递指令。
- en: 'Here are some of the things you can do before booting is complete:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导完成之前，你可以执行以下操作：
- en: Use built-in help
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用内置帮助
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use the `help` function to print a brief list of commands that the boot loader
    supports.
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `help` 函数打印引导加载程序支持的命令的简要列表。
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Delay the boot process
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 延迟引导过程
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By default, the loader waits five seconds for instructions, and then boots the
    kernel. To pause the boot at the prompt, press the spacebar.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，加载程序等待五秒钟以获取指令，然后引导内核。要在提示符处暂停引导，请按空格键。
- en: Set the boot timeout
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置引导超时
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To set a new boot idle timeout, specify a number of seconds with the `set timeout`
    command.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要设置新的引导空闲超时，请使用 `set timeout` 命令指定秒数。
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the boot prompt is idle for 10 seconds, the system should boot.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在引导提示符空闲10秒后，系统应该启动。
- en: Boot the system
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 启动系统
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you’ve paused the boot process, the system won’t boot until you tell it
    to. When you’re ready to boot, use the `boot` command:'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你暂停了引导过程，系统将不会启动，直到你告诉它。当你准备好启动时，使用`boot`命令：
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll use various permutations of `boot` to configure the kernel, boot single-user
    mode, and so on. I’ll cover other boot commands in the appropriate sections. For
    full details on what you can do at the boot loader prompt, read the `boot(8)`
    man page.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`boot`的各种排列组合来配置内核、启动单用户模式等。我将在适当的部分介绍其他引导命令。有关引导提示符上可以执行的所有操作的完整细节，请阅读`boot(8)`手册页。
- en: Booting in Single-User Mode
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以单用户模式启动
- en: Single-user mode is the earliest point when OpenBSD can give you a Unix-style
    shell prompt. At this point, the kernel has probed all the hardware, attached
    drivers to all the hardware that it’s going to acknowledge, and started `init`.
    The system hasn’t mounted any filesystems except for the root partition, which
    is mounted in read-only mode. The network isn’t started, no services are running,
    security is not implemented, and filesystem permissions are ignored.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单用户模式是OpenBSD最早可以给你Unix风格shell提示的位置。在这个时候，内核已经探测了所有硬件，将驱动程序附加到它将要认可的所有硬件上，并启动了`init`。系统除了根分区外没有挂载任何文件系统，根分区是以只读模式挂载的。网络尚未启动，没有服务正在运行，安全性未实现，文件系统权限被忽略。
- en: To boot OpenBSD in single-user mode, enter **`boot -s`** at the loader prompt.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要以单用户模式启动OpenBSD，请在引导提示符下输入**`boot -s`**。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Why would you want to boot into single-user mode? If your computer has a problem
    that is preventing it from booting, you should be able to access single-user mode
    and fix the problem. Suppose a failed disk is preventing the system from booting
    during a multiuser boot, or you changed your terminal settings in */etc/ttys*
    and now you can’t log on to the system. Or maybe you put a daft setting in *rc.conf.local*,
    and the boot process hangs because it’s trying to do something impossible. At
    times like these, single-user mode is your best friend.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你想以单用户模式启动？如果你的计算机有问题阻止它启动，你应该能够访问单用户模式并修复问题。假设一个失败的磁盘阻止了系统在多用户引导期间启动，或者你更改了*/etc/ttys*中的终端设置，现在你无法登录到系统。或者你可能将一个愚蠢的设置放入*rc.conf.local*，引导过程挂起，因为它正在尝试做一些不可能的事情。在这些时候，单用户模式是你的最佳朋友。
- en: Also, some system administration tasks, such as clearing filesystem flags (see
    [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems")), can be done only in
    single-user mode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些系统管理任务，如清除文件系统标志（见[第8章](ch08.html "第8章。磁盘和文件系统")），只能在单用户模式下完成。
- en: Mounting Disks in Single-User Mode
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以单用户模式挂载磁盘
- en: 'Usually, you should have a fully functional filesystem before doing anything
    in single-user mode. If your system crashed, be sure to check the integrity of
    your filesystems before mounting them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在单用户模式下进行任何操作之前，你应该有一个完全功能的文件系统。如果你的系统崩溃了，在挂载它们之前，务必检查文件系统的完整性：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`fsck` and `mount` have many more options. We’ll cover them in more detail
    in [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems").'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsck`和`mount`有许多更多选项。我们将在第8章（第8章。磁盘和文件系统）中更详细地介绍它们。'
- en: Once you’ve mounted all of your filesystems, all usual command-line software
    should be available. You should be able to edit configuration files, start and
    stop programs, and generally do whatever you like to the system (including destroy
    it).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦挂载了所有文件系统，所有常规的命令行软件都应该可用。你应该能够编辑配置文件、启动和停止程序，并且通常可以对你喜欢的系统进行任何操作（包括破坏它）。
- en: Starting the Network in Single-User Mode
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以单用户模式启动网络
- en: 'Use the shell script */etc/netstart* to configure the network while in singleuser
    mode. (You could run all the appropriate commands by hand, but */etc/netstart*
    will read your system’s configuration files and do the grunt work for you.) You
    must explicitly run this script through `sh`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shell脚本*/etc/netstart*在单用户模式下配置网络。（你可以手动运行所有适当的命令，但*/etc/netstart*将读取你的系统配置文件并为你完成繁琐的工作。）你必须通过`sh`显式运行此脚本：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re booting into single-user mode because of network problems, this script
    will conveniently reproduce the issue for you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你因为网络问题而以单用户模式启动，这个脚本会方便地为你重现问题。
- en: Booting an Alternate Kernel
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动备用内核
- en: As we’ll cover in tedious detail in [Chapter 18](ch18.html "Chapter 18. Kernel
    Configuration"), you *can* configure the OpenBSD kernel, but before you do so,
    be sure that you can boot alternate kernels. You’ll need to be able to boot a
    different kernel if, say, you hose your filesystem so badly that it won’t even
    boot to single-user mode, and you need to recover using the installation kernel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第18章](ch18.html "第18章。内核配置")中将要详细介绍的，你可以配置OpenBSD内核，但在这样做之前，请确保你可以引导其他内核。如果你损坏了文件系统到连单用户模式都无法引导的程度，你需要能够引导不同的内核，并使用安装内核进行恢复。
- en: Booting a Different Kernel File
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导不同的内核文件
- en: 'An OpenBSD installation includes three kernels out of the box: the single-processor
    kernel */bsd*, the multiprocessor kernel */bsd.mp*, and the upgrade and install
    kernel */bsd.rd*. (If your machine has multiple processors, the installer renames
    */bsd* to */bsd.sp* and */bsd.mp* to */bsd*.)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD安装程序默认包含三个内核：单处理器内核 */bsd*，多处理器内核 */bsd.mp*，以及升级和安装内核 */bsd.rd*。（如果你的机器有多个处理器，安装程序会将
    */bsd* 重命名为 */bsd.sp*，将 */bsd.mp* 重命名为 */bsd*。）
- en: 'To boot a nonstandard kernel, first reboot and interrupt the boot process at
    the boot loader prompt. Run `boot`, and give the full path to the kernel you want
    to boot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要引导非标准内核，首先重启并中断引导过程，在引导加载程序提示符下运行`boot`，并给出你想要引导的内核的完整路径：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will start the system using your chosen kernel. You can use other boot
    options as well, such as booting the alternate kernel in single-user mode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用你选择的内核启动系统。你也可以使用其他引导选项，例如以单用户模式引导备用内核：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will let you recover from a bad kernel, try a new kernel, or anything in
    between.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让你能够从损坏的内核中恢复，尝试新的内核，或者介于两者之间的任何东西。
- en: Booting from an Alternate Hard Disk
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从备用硬盘引导
- en: 'Suppose you’ve really fouled everything up beyond all recognition, and you
    don’t have a usable kernel on your root partition. Fortunately, if you have a
    usable kernel on a different hard drive, you can boot from that. (Usually, this
    kernel lives on an alternate root partition, */altroot*, as discussed in [Chapter 8](ch08.html
    "Chapter 8. Disks and Filesystems").) In this section, I’ll break the task of
    booting from that alternate kernel into a few steps: finding the hard disk with
    the partition, finding the partition with the file, and booting the right file
    on that partition.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你真的把一切都搞砸了，你的根分区上没有可用的内核。幸运的是，如果你在另一个硬盘上有可用的内核，你可以从那个硬盘引导。通常，这个内核位于备用根分区，*/altroot*，如[第8章](ch08.html
    "第8章。磁盘和文件系统")中所述。）在本节中，我将把从那个备用内核引导的任务分解成几个步骤：找到包含分区的硬盘，找到包含文件的分区，并在该分区上引导正确的文件。
- en: Finding the Disk
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找硬盘
- en: Once you’re familiar with OpenBSD, you may begin to think of the hard drives
    in your system by their device names, such as */dev/sd0*, */dev/wd1*, and so on.
    Unfortunately, those are the kernel’s names for the disks; the boot loader recognizes
    only the BIOS’s disk names.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了OpenBSD，你可能会开始根据它们的设备名称来考虑系统中的硬盘，例如*/dev/sd0*，*/dev/wd1*等等。不幸的是，这些是内核对磁盘的命名；引导加载程序只识别BIOS的磁盘名称。
- en: 'To ask the boot loader about disks, use the `machine diskinfo` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要询问引导加载程序关于磁盘的信息，请使用`machine diskinfo`命令：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the boot loader has found four disk devices. The first, `fd0`, is a floppy
    disk drive. This drive might or might not have a disk in it, but whatever it has,
    it’s almost certainly not your alternate kernel. (It might be an installation
    disk, though, so don’t automatically rule out using it for disaster recovery.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，引导加载程序找到了四个磁盘设备。第一个，`fd0`，是一个软盘驱动器。这个驱动器可能没有磁盘，或者有磁盘，但无论它有什么，几乎可以肯定它不是你的备用内核。（它可能是一个安装盘，所以不要自动排除用于灾难恢复的可能性。）
- en: The other three devices—`hd0`, `hd1`, and `hd2`—are hard disks. The first, `hd0`,
    is the default system boot disk. If you can’t boot from that disk, you need to
    find the hard disk that contains your kernel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个设备—`hd0`，`hd1`和`hd2`—是硬盘。第一个，`hd0`，是默认的系统引导盘。如果你不能从这个磁盘引导，你需要找到包含你的内核的硬盘。
- en: Finding the Partition
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 寻找分区
- en: 'Vague stirrings of memory in this output lead me to think that `hd2` might
    be the disk that holds my backup root partition. To try it, tell the loader that
    disk partition `hd2a` is the new root partition:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中模糊的记忆让我想到`hd2`可能是包含我的备份根分区的磁盘。为了尝试它，告诉加载程序磁盘分区`hd2a`是新的根分区：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Before trying to boot from this partition, look at its contents:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试从这个分区引导之前，看看它的内容：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Apparently, disk `hd2` has no partition `a`. After service is restored, I’ll
    take this disk out behind my garage and beat its weakness out of it. For now,
    let’s try the only remaining disk, `hd1`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，磁盘 `hd2` 没有分区 `a`。在服务恢复后，我会把这块磁盘放在车库后面，把它的问题打掉。现在，让我们尝试剩下的唯一磁盘，`hd1`。
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This looks like an actual root partition (`altroot` offers a hint).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个实际的根分区（`altroot` 提供了提示）。
- en: Booting the Kernel
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 引导内核
- en: At this point, we could boot a different kernel, but we’ll just boot the */bsd*
    kernel on this partition in single-user mode, because the filesystem table would
    have the incorrect entry for the root filesystem, which would mess up all sorts
    of stuff.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以引导不同的内核，但我们将只以单用户模式引导这个分区上的 */bsd* 内核，因为文件系统表将会有错误的根文件系统条目，这会搞砸各种东西。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you could give the device name at the boot prompt:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在引导提示符处给出设备名称：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a general rule, you should mount the actual root partition on */mnt*, make
    the necessary changes for normal operation, and reboot into the proper root partition.
    You could also boot the */bsd.rd* kernel, giving you a cleaner boot at the cost
    of having fewer tools available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，您应该在 */mnt* 上挂载实际的根分区，进行必要的更改以进行正常操作，然后重新引导到正确的根分区。您还可以引导 */bsd.rd* 内核，这将使引导更加干净，但可用的工具会减少。
- en: Making Boot Loader Settings Permanent
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将引导加载程序设置永久化
- en: To make boot loader options permanent, edit */etc/boot.conf*. The boot loader
    reads and runs entries from this file before giving you the `boot>` prompt, which
    means you can use it to automatically run boot loader commands every time your
    computer boots. (Although if you would rather sit at your computer and enter your
    settings every time you reboot, don’t let me stop you.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使引导加载程序选项永久化，请编辑 */etc/boot.conf*。引导加载程序在给您 `boot>` 提示符之前读取并运行此文件中的条目，这意味着您可以使用它来在每次计算机启动时自动运行引导加载程序命令。（尽管如果您宁愿每次重新启动时都坐在电脑前输入设置，请不要阻止我。）
- en: 'Any command you might give at the loader prompt is a valid *boot.conf* entry.
    For example, if the default boot speed is too slow for your liking, you can set
    your boot timeout to two seconds by adding this line to *boot.conf*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您在引导加载程序提示符下可能给出的任何命令都是有效的 *boot.conf* 条目。例如，如果默认的引导速度太慢，您可以通过在 *boot.conf*
    中添加此行来将引导超时设置为两秒：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also tell the system to boot a different kernel with the correct *boot.conf*
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用正确的 *boot.conf* 命令告诉系统引导不同的内核。
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By far, *boot.conf* is most often used to configure a serial console.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，*boot.conf* 最常用于配置串行控制台。
- en: Serial Consoles
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行控制台
- en: All of these nifty boot functions let you do useful stuff when your system is
    in trouble, but how can you use them when your computer isn’t right in front of
    you? If your computer is in a data center on the other side of the country, or
    sitting in the basement behind the last decade of payroll records, a serial console
    will make your life far more pleasant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些巧妙的引导功能都让您在系统出现问题时能够做些有用的事情，但您如何在不坐在电脑前的情况下使用它们呢？如果您的电脑在国家的另一边的数据中心，或者坐在十年工资记录背后的地下室里，串行控制台会让您的生活更加愉快。
- en: A hardware serial console allows you to run a serial cable between a computer
    and a terminal server (on another computer) to access BIOS messages and operating
    system boot and startup messages which simplifies managing remote systems. Serial
    consoles are invaluable when debugging system crashes, too; error messages come
    over the serial port, where you can easily capture them.^([[12](#ftn.id418996)])
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件串行控制台允许您在计算机和终端服务器（在另一台计算机上）之间运行串行电缆，以访问 BIOS 消息和操作系统引导和启动消息，从而简化远程系统的管理。在调试系统崩溃时，串行控制台也极其宝贵；错误消息通过串行端口发送，您可以轻松地捕获它们。[^[[12](#ftn.id418996])]
- en: True UNIX hardware has serial console capabilities, as does most server-grade
    i386 and amd64 hardware. Most desktop-grade hardware, however, does not. But fortunately,
    even if you don’t have a hardware serial console, you can access all of OpenBSD’s
    startup messages with a serial port and a software serial console. While OpenBSD’s
    software serial console won’t give you access to the hardware BIOS, it will let
    you interface with the boot loader and remotely access the system console, even
    when the network is down.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的 UNIX 硬件具有串行控制台功能，大多数服务器级 i386 和 amd64 硬件也是如此。然而，大多数桌面级硬件则没有。但幸运的是，即使您没有硬件串行控制台，您也可以通过串行端口和软件串行控制台访问
    OpenBSD 的所有启动消息。虽然 OpenBSD 的软件串行控制台不会让您访问硬件 BIOS，但它会允许您与引导加载程序接口，并在网络断开时远程访问系统控制台。
- en: Other Platform Serial Consoles
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他平台串行控制台
- en: Every hardware platform has its own standards for serial consoles. If you’re
    running a less common platform, check your hardware’s documentation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬件平台都有自己的串行控制台标准。如果您运行的是不太常见的平台，请检查您的硬件文档。
- en: If your hardware supports a real serial console, you should usually configure
    it in the BIOS. OpenBSD supports whatever the hardware supports, so your Sparc64
    hardware will support OpenBSD’s serial console just as well as it supports any
    other operating system’s serial console.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的硬件支持真实串行控制台，您通常应该在 BIOS 中进行配置。OpenBSD 支持硬件支持的任何功能，因此您的 Sparc64 硬件将像支持任何其他操作系统的串行控制台一样支持
    OpenBSD 的串行控制台。
- en: Serial Console Physical Setup
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行控制台物理设置
- en: A serial console requires a null modem cable, which you should be able to get
    from any computer store or an online vendor. While gold-plated cables aren’t worth
    the money, don’t buy the cheapest cable you can find either. If you have an emergency
    and need the serial console right *now*, you won’t be in the mood to deal with
    a defective cable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 串行控制台需要一个 null modem 电缆，您应该可以从任何电脑店或在线供应商那里获得。虽然镀金电缆不值那么多钱，但也不要买最便宜的电缆。如果您有紧急情况，需要立即使用串行控制台，您可能不会愿意处理一根有缺陷的电缆。
- en: Plug one end of the null modem cable into your OpenBSD machine’s first serial
    port. (The serial console is supported on only the first serial port, or `com0`
    on i386 and amd64 hardware.) Plug the null modem cable’s other end into an open
    serial port on another system. (For simplicity’s sake, use either another OpenBSD
    or Unix-like system.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 null modem 电缆的一端插入您的 OpenBSD 机器的第一个串行端口。（串行控制台仅在第一个串行端口上受支持，或在 i386 和 amd64
    硬件上的 `com0`。）将 null modem 电缆的另一端插入另一个系统的空闲串行端口。（为了简单起见，使用另一个 OpenBSD 或类 Unix 系统。）
- en: If you have two OpenBSD machines at a remote location and you want to use serial
    consoles on both, you can have each machine act as the console client for the
    other. Attach the first serial port on each server to the second serial port on
    the other. If you have three machines, you can daisy-chain them in a loop. If
    you have four or more machines, pick up a used terminal server from your favorite
    auction site.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在远程位置有两台 OpenBSD 机器，并且想在两台机器上使用串行控制台，您可以让每台机器充当另一台的控制台客户端。将每台服务器的第一个串行端口连接到另一台服务器的第二个串行端口。如果您有三台机器，可以将它们串联成环。如果您有四台或更多机器，可以从您喜欢的拍卖网站上购买一台二手终端服务器。
- en: You can also use two DB9-to-RJ45 converters, one standard and one crossover,
    which will allow you to run your console connections over a standard CAT5 cable.
    If you have a lights-out data center where human beings are forbidden unless they
    are installing or removing equipment, you can stretch your serial console cables
    about 12 meters, which should reach into your warm room. (Most modern data facilities
    are better equipped to handle CAT5 cables than serial cables.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用两个 DB9-to-RJ45 转换器，一个标准和一个交叉，这将允许您通过标准 CAT5 电缆运行您的控制台连接。如果您有一个禁止人类进入（除非他们正在安装或拆除设备）的无人值守数据中心，您可以将串行控制台电缆延长约
    12 米，这应该可以到达您的温暖房间。（大多数现代数据中心比串行电缆更适合处理 CAT5 电缆。）
- en: Serial Console Configuration
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行控制台配置
- en: Now that you have the console physically ready, the next step is to configure
    your client to access the serial console. Then you can set up the serial console.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的控制台已经物理准备就绪，下一步是配置您的客户端以访问串行控制台。然后您可以设置串行控制台。
- en: Configuring the Serial Console Client
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置串行控制台客户端
- en: 'The following are the default settings for an OpenBSD i386 or amd64 system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 OpenBSD i386 或 amd64 系统的默认设置：
- en: 9600 baud
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9600 波特
- en: 8 bits
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 位
- en: No parity
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无奇偶校验
- en: 1 stop bit
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 停止位
- en: Enter these values into any terminal emulator on the client computer, and the
    serial console should Just Work. You can find terminal emulators for Microsoft
    platforms (I recommend PuTTY), OS X, and just about any other operating system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些值输入到客户端计算机上的任何终端仿真器中，串行控制台应该能够正常工作。您可以在 Microsoft 平台（我推荐 PuTTY）、OS X 和几乎所有其他操作系统上找到终端仿真器。
- en: 'OpenBSD includes the terminal emulator `tip(1)`, which reads its configuration
    from */etc/remote*. The configuration `tty00` in */etc/remote* matches the default
    OpenBSD serial console configuration for i386 and amd64 systems (as well as several
    other platforms). If you’ve attached your null modem cable to the first serial
    port on the client, connect with this command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD包括终端模拟器`tip(1)`，它从`/etc/remote`读取其配置。`/etc/remote`中的`tty00`配置与i386和amd64系统的默认OpenBSD串行控制台配置相匹配（以及几个其他平台）。如果您将null调制解调器电缆连接到客户端的第一个串行端口，请使用以下命令连接：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If it doesn’t say `connected`, your serial client is misconfigured. Fix your
    client before enabling your serial console on the server. You want your serial
    client ready before configuring the console.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显示`connected`，您的串行客户端配置不正确。在服务器上启用串行控制台之前，请修复您的客户端。您希望在配置控制台之前准备好串行客户端。
- en: Setting Up the Serial Console
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置串行控制台
- en: OpenBSD normally uses the local physical keyboard, video, and mouse as the console,
    but it can also use the first serial port as a serial console.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD通常使用本地物理键盘、视频和鼠标作为控制台，但它也可以使用第一个串行端口作为串行控制台。
- en: 'To set the console, use the boot loader. You must know the loader’s device
    name for your preferred console: `com0` for the first serial port or `pc0` for
    the physically attached video and keyboard.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置控制台，请使用引导加载程序。您必须知道您首选控制台的加载程序设备名称：`com0`用于第一个串行端口或`pc0`用于物理连接的视频和键盘。
- en: 'The first time you try to use a serial console, use a local test machine. Set
    up your client beforehand and start your terminal emulator, and then boot your
    test machine. At the boot loader prompt, enter this command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试使用串行控制台时，请使用本地测试机器。事先设置您的客户端并启动您的终端模拟器，然后引导测试机器。在引导加载程序提示符下，输入以下命令：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Your server’s monitor and keyboard should stop responding, and if you’ve set
    up everything correctly, you should see the boot loader prompt in your terminal
    emulator.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您服务器的显示器和键盘应该停止响应，如果您设置正确，您应该在终端模拟器中看到引导加载程序提示符。
- en: 'To switch back to the physical console, tell the boot loader to use the `pc0`
    device:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换回物理控制台，告诉引导加载程序使用`pc0`设备：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Poof! The server’s keyboard and monitor should work again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 嘭！服务器的键盘和显示器应该又能工作了。
- en: 'To have your machine use the serial console at every boot, add this statement
    in */etc/boot.conf*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要在每次引导时让您的机器使用串行控制台，请在`/etc/boot.conf`中添加此语句：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Be sure to test your serial console after the machine is installed in its permanent
    location, and always screw the serial cables to the server. A loose serial cable
    provides only a comforting illusion that betrays you when it will hurt the most.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在机器安装到永久位置后测试您的串行控制台，并且始终将串行电缆拧紧在服务器上。松散的串行电缆只能提供一种安慰的错觉，但在最需要的时候会背叛您。
- en: Testing the Serial Configuration
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试串行配置
- en: 'After configuring your serial console, return to your serial client and press
    ENTER. You should see something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置您的串行控制台后，返回您的串行客户端并按回车键。您应该看到类似以下内容：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Changing the Serial Console Speed
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改串行控制台速度
- en: Newer serial ports (meaning anything made within the past 10 years) can run
    at speeds far above 9600 baud. I have servers with serial consoles that run only
    at 115,200 baud. The BIOS messages display at 115,200 baud, but then the OpenBSD
    console runs at 9600 baud. My client displays one or the other as gibberish. (A
    lot of OpenBSD folks think that anything that won’t do serial at 9600 baud is
    broken, but you won’t always have control over the hardware you work with.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的串行端口（意味着在过去10年内制造的任何端口）可以以远高于9600波特的速度运行。我有一些串行控制台运行速度仅为115,200波特的服务器。BIOS信息以115,200波特显示，但OpenBSD控制台以9600波特运行。我的客户端显示为乱码。（许多OpenBSD用户认为不能以9600波特进行串行通信的任何东西都是损坏的，但您并不总是能控制您所使用的硬件。）
- en: To use these ports, I can either change my connection speed in my serial console
    client when switching between the BIOS messages and the OpenBSD messages, or change
    the speed of my OpenBSD console to match the hardware.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些端口，我可以在在切换BIOS信息和OpenBSD信息时更改我的串行控制台客户端的连接速度，或者更改OpenBSD控制台的速度以匹配硬件。
- en: 'At the boot loader, tell the serial console to run at 115,200 baud:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导加载程序中，告诉串行控制台以115,200波特运行：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If these settings work, copy them to */etc/boot.conf*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些设置有效，请将它们复制到`/etc/boot.conf`。
- en: 'Now configure your serial client. Modify `tip` to use the higher speed. First,
    find the entry for `tty00` in */etc/remote*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置您的串行客户端。修改`tip`以使用更高的速度。首先，在`/etc/remote`中找到`tty00`条目：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But don’t modify this entry! We’ll use it to illustrate the style of */etc/remote*
    entries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要修改这个条目！我们将用它来说明 */etc/remote* 条目的风格。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*/etc/remote* is designed much like a `termcap(5)` database. If you ever need
    to write your own *`termcap`* entries from scratch, you’re living your life wrong.
    But you can recognize the contents and modify existing entries without much pain.
    If you really want to learn everything about these entries, read the *`remote(5)`*
    man page.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/remote* 的设计类似于一个 `termcap(5)` 数据库。如果你需要从头开始编写自己的 *`termcap`* 条目，那么你的生活方向就错了。但你可以识别内容并修改现有条目而不会感到太多痛苦。如果你真的想了解有关这些条目的所有内容，请阅读
    *`remote(5)`* 手册页。'
- en: Backslashes (`\`) in this entry mean “continued on the next line.” Colons separate
    fields. Each line after the first must start with a colon, and each field is a
    key/value pair.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个条目中，反斜杠 (`\`) 表示“续到下一行”。冒号分隔字段。每一行在第一行之后都必须以冒号开头，并且每个字段都是一个键/值对。
- en: 'Now, to create a console entry that runs at 115,200 baud, use the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要创建一个以115,200波特率运行的控制台条目，请使用以下命令：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first field in an */etc/remote* entry is the name, and every entry must
    have a unique name. I named this entry `console`. The second field is the `br`
    value. According to `remote(5)`, `br` stands for bit rate. I’ve set the bit rate
    to 115,200 baud. The third field is `tc`, for “table continues,” which is equal
    to `tty00`. This means that the description of this entry continues in entry `tty00`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/remote* 条目的第一个字段是名称，每个条目都必须有一个唯一的名称。我给这个条目命名为 `console`。第二个字段是 `br` 值。根据
    `remote(5)`，`br` 代表比特率。我已经将比特率设置为 115,200 波特。第三个字段是 `tc`，代表“表继续”，等于 `tty00`。这意味着这个条目的描述将在
    `tty00` 条目中继续。'
- en: Taken as a whole, this entry means “copy the `tty00` entry, and add a bit rate
    of 115,200.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 整体来看，这个条目的意思是“复制 `tty00` 条目，并添加一个 115,200 的比特率。”
- en: Changing the Client Serial Port
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改客户端串行端口
- en: 'If you have two OpenBSD machines, each sending its serial console out its first
    serial port to the other machine’s second serial port, you must tell `tip` to
    connect to the second serial port. The command `tip tty00` doesn’t actually connect
    to the serial port named `tty00`—it connects to a port defined by the */etc/remote*
    entry named `tty00`. That means that you can’t run, say, `tip tty03` and connect
    to serial port tty03 unless you have an */etc/remote* entry named `tty03`. By
    default, there isn’t one, but you can define one easily, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个 OpenBSD 机器，每个机器都将其串行控制台发送到另一台机器的第一个串行端口，你必须告诉 `tip` 连接到第二个串行端口。命令 `tip
    tty00` 实际上并没有连接到名为 `tty00` 的串行端口——它连接到由 */etc/remote* 条目定义的端口，该条目名为 `tty00`。这意味着你不能运行，例如，`tip
    tty03` 并连接到串行端口 tty03，除非你有一个名为 `tty03` 的 */etc/remote* 条目。默认情况下，没有这样的条目，但你可以轻松地定义一个，如下所示：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This entry is named `tty01`. The `dv` setting tells */etc/remote* the physical
    device to use. Other than this, all settings are copied from the entry called
    `tty00`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目的名称是 `tty01`。`dv` 设置告诉 */etc/remote* 使用哪个物理设备。除了这个之外，所有设置都是从名为 `tty00` 的条目中复制的。
- en: With these examples, you should be able to use OpenBSD’s `tip` to connect to
    almost any serial console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，你应该能够使用 OpenBSD 的 `tip` 连接到几乎任何串行控制台。
- en: Serial Logins
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 串行登录
- en: The serial console lets you interact with the boot process. Once your machine
    is fully multiuser, however, a default serial console will not let you actually
    log in to OpenBSD. In multiuser mode, OpenBSD uses `getty(8)` to initialize terminals
    and handle logins, and in order to log in to your machine over a serial port,
    you will need to tell `getty` to take charge of the serial line by configuring
    */etc/ttys*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 串行控制台允许你与引导过程交互。然而，一旦你的机器完全进入多用户模式，默认的串行控制台将不会让你实际登录到 OpenBSD。在多用户模式下，OpenBSD
    使用 `getty(8)` 初始化终端并处理登录，为了通过串行端口登录到你的机器，你需要告诉 `getty` 通过配置 */etc/ttys* 来接管串行线路。
- en: 'We’ll discuss */etc/ttys* further in [Chapter 14](ch14.html "Chapter 14. Everything
    /etc"), but for now, here’s how to allow logins over the first serial port. Find
    the entry for `tty00`, which should look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第14章](ch14.html "第14章。一切 /etc") 中进一步讨论 */etc/ttys*，但到目前为止，以下是如何允许通过第一个串行端口进行登录的方法。找到名为
    `tty00` 的条目，它应该看起来像这样：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Remove the last two words, and replace them to match the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 删除最后两个单词，并将它们替换为以下内容：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now run `kill -1 1`, and you should get a login prompt over your serial line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `kill -1 1`，你应该通过串行线路获得登录提示。
- en: Multiuser Startup
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多用户启动
- en: When the kernel finishes its core setup and hands control over to userland,
    `init(8)` runs the shell script */etc/rc*. This script handles all system setup,
    including mounting filesystems, configuring device nodes, identifying shared libraries,
    and any other task required to make the system usable. Some tasks are delegated
    to separate scripts; for example, */etc/netstart* is used to configure the network.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核完成核心设置并将控制权交给用户空间后，`init(8)` 运行 shell 脚本 */etc/rc*。此脚本处理所有系统设置，包括挂载文件系统、配置设备节点、识别共享库以及任何其他使系统可用的任务。一些任务委托给单独的脚本；例如，*/etc/netstart*
    用于配置网络。
- en: In this section, we’ll cover how */etc/rc* and other startup scripts function,
    and the flow of the startup process. Armed with this understanding, you should
    be able to easily configure your OpenBSD machine to start exactly what you need—no
    more, no less.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 */etc/rc* 和其他启动脚本如何工作，以及启动过程的流程。有了这种理解，您应该能够轻松地配置您的 OpenBSD 机器启动您所需的确切内容——不多也不少。
- en: Startup System Scripts
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动系统脚本
- en: The startup system includes the scripts */etc/rc*, */etc/rc.conf*, */etc/rc.conf.local*,
    */etc/netstart*, */etc/rc.securelevel*, */etc/rc.local*, */etc/rc.shutdown*, */etc/rc.firsttime*,
    */etc/fastboot*, and the contents of the */etc/rc.d* directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 启动系统包括脚本 */etc/rc*、*/etc/rc.conf*、*/etc/rc.conf.local*、*/etc/netstart*、*/etc/rc.securelevel*、*/etc/rc.local*、*/etc/rc.shutdown*、*/etc/rc.firsttime*、*/etc/fastboot*
    以及 */etc/rc.d* 目录的内容。
- en: The /etc/rc Script
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc 脚本
- en: On OpenBSD, everything outside the kernel is configured with a shell command,
    from setting the hostname to starting server daemons. The master script is */etc/rc*,
    and it runs all of these commands in the correct order, ensuring that the system
    is configured exactly the same way at every boot. As a final step, */etc/rc* runs
    `getty(8)` to present login prompts on all the appropriate terminals.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 上，从设置主机名到启动服务器守护进程，所有非内核内容都是通过 shell 命令配置的。主脚本是 */etc/rc*，它按正确顺序运行所有这些命令，确保每次引导时系统配置完全相同。作为最后一步，*/etc/rc*
    运行 `getty(8)` 在所有适当的终端上显示登录提示。
- en: Never edit */etc/rc* unless you’re a very experienced systems administrator
    with truly unique needs. This is one of the several files in */etc* that is technically
    editable, but mere mortals are well advised to *treat as binary*. Instead, whenever
    you need to disable functions, deactivate them in */etc/rc.conf.local*. To add
    new functionality to the startup process, use the shell scripts */etc/rc.securelevel*
    and */etc/rc.local,* or write a shell script for */etc/rc.d*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您是一位经验非常丰富的系统管理员，并且有真正独特的需求，否则永远不要编辑 */etc/rc*。这是 */etc* 中可以技术上可编辑的几个文件之一，但普通人最好将其视为二进制文件。相反，每次您需要禁用功能时，请在
    */etc/rc.conf.local* 中将其停用。要向启动过程添加新功能，请使用 shell 脚本 */etc/rc.securelevel* 和 */etc/rc.local*，或者为
    */etc/rc.d* 编写 shell 脚本。
- en: The /etc/rc.conf Script
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.conf 脚本
- en: 'The */etc/rc.conf* file contains nothing but the default values for all other
    startup scripts. Read this file to see the configuration options for different
    system services. Here’s a small snippet of what you’ll find in *rc.conf*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/rc.conf* 文件只包含所有其他启动脚本的默认值。阅读此文件以查看不同系统服务的配置选项。以下是您将在 *rc.conf* 中找到的片段之一：'
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If a variable is set to `NO`, the associated service is disabled by default.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量设置为 `NO`，则默认禁用相关服务。
- en: 'As you can see, OpenBSD turns off almost everything by default, with one exception:
    the SSH daemon. Setting the variable to a pair of quotes, as shown after each
    entry in the preceding snippet, is enough to enable most daemons, and most daemons
    will run just fine without any command-line flags. However, if a daemon requires
    a command-line argument in order to run, that argument will be shown as it is
    in the `-a` attached to `rarpd_flags`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，OpenBSD 默认关闭几乎所有功能，只有一个例外：SSH 守护进程。将变量设置为成对的引号，如前一段代码片段中每个条目之后所示，就足以启用大多数守护进程，而且大多数守护进程在没有命令行标志的情况下运行得很好。然而，如果守护进程需要命令行参数才能运行，该参数将以
    `-a` 附加到 `rarpd_flags` 中的原样显示。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the risk of beating my dead server senseless, never edit */etc/rc.conf* (treat
    as binary—remember?). It will be replaced wholesale during a system upgrade. Instead,
    place your local values in */etc/rc.conf.local*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒着让我的服务器彻底崩溃的风险下，永远不要编辑 */etc/rc.conf*（将其视为二进制文件——记得吗？）在系统升级过程中，它将被全部替换。相反，将您的本地值放在
    */etc/rc.conf.local* 中。
- en: The /etc/rc.conf.local Script
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.conf.local 脚本
- en: 'I’ve mentioned this before, but I’m going to beat you over the head with it:
    Place your changes to *rc.conf* in *rc.conf.local*. Entries in *rc.conf.local*
    override the defaults in *rc.conf*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前已经提到过这一点，但我要反复强调：请将您的更改放置在 *rc.conf.local* 中。*rc.conf.local* 中的条目会覆盖 *rc.conf*
    中的默认设置。
- en: 'For example, say that on a particular machine, you want to run `sshd(8)` with
    extra debugging, and you also want to run `named(8)`. Additionally, you want to
    run the time server `ntpd(8)`, and have it correct the time at boot by using the
    `-s` flag. After consulting the documentation for those programs, you add the
    following lines to *rc.conf.local*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设在特定的机器上，您想以额外的调试方式运行 `sshd(8)`，并且您还想运行 `named(8)`。此外，您还想运行时间服务器 `ntpd(8)`，并在启动时使用
    `-s` 标志来校正时间。在查阅了这些程序的文档后，您将以下行添加到 *rc.conf.local* 中：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: OpenBSD will start the programs with the flags specified here. If you specify
    invalid, incorrect, or incompatible flags, the daemon will print error messages
    to the console.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 将启动此处指定的标志的程序。如果您指定了无效、不正确或不兼容的标志，守护进程将在控制台打印错误消息。
- en: The /etc/netstart Script
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/netstart 脚本
- en: While its name differs from the other scripts, */etc/netstart* is definitely
    a system startup script. It reads */etc/mygate*, */etc/myname*, and all the */etc/hostname.if*
    files, and uses the information in them to configure all network interfaces, bridges,
    routing, and so forth. The file */etc/rc* runs this script before starting any
    server daemons, network filesystems, and so on. In single-user mode, you’ll run
    this script by hand to bring up the network.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其名称与其他脚本不同，但 */etc/netstart* 确实是一个系统启动脚本。它读取 */etc/mygate*、*/etc/myname* 以及所有
    */etc/hostname.if* 文件，并使用其中的信息来配置所有网络接口、桥接、路由等。文件 */etc/rc* 在启动任何服务器守护进程、网络文件系统等之前运行此脚本。在单用户模式下，您需要手动运行此脚本以启动网络。
- en: The /etc/rc.securelevel Script
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.securelevel 脚本
- en: The */etc/rc.securelevel* shell script runs early in the boot process, before
    */etc/rc* raises the system securelevel, but after starting the network. Many
    programs, particularly those that touch the kernel or intimately affect the filesystem,
    will not run once the securelevel is raised. If you run such a program, you can
    add the command to start it to this script. If your local program doesn’t need
    to run before the system securelevel is raised, you’re better off starting it
    from *rc.local* or writing a proper *rc.d* script for it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/rc.securelevel* 脚本在启动过程中较早运行，在 */etc/rc* 提高系统安全级别之前，但在启动网络之后。一旦提高安全级别，许多程序，尤其是那些接触内核或密切影响文件系统的程序，将无法运行。如果您运行这样的程序，可以将启动它的命令添加到此脚本中。如果您的本地程序不需要在系统安全级别提高之前运行，您最好从
    *rc.local* 启动它或为其编写适当的 *rc.d* 脚本。'
- en: One important entry in *rc.securelevel* is the definition of the system securelevel.
    We’ll discuss securelevels in [Chapter 10](ch10.html "Chapter 10. Securing Your
    System"). For now, don’t touch the line that sets the securelevel unless you’re
    already familiar with BSD-based systems and know exactly which toe you’re shooting
    off.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*rc.securelevel* 中的一个重要条目是系统安全级别的定义。我们将在 [第 10 章](ch10.html "第 10 章。保护您的系统")
    中讨论安全级别。现在，除非您已经熟悉基于 BSD 的系统并且确切知道您要采取哪种行动，否则不要触摸设置安全级别的行。'
- en: The /etc/rc.local Script
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.local 脚本
- en: After */etc/rc* does just about everything else, it runs */etc/rc.local*. You
    can put commands to start local daemons in *rc.local*, but you’re better off writing
    an *rc.d* script to start local daemons so you can easily and consistently restart
    them later. Of course, if you’re lazy, you can get by with *rc.local*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */etc/rc* 完成几乎所有其他操作后，它会运行 */etc/rc.local*。您可以在 *rc.local* 中放置启动本地守护进程的命令，但最好编写一个
    *rc.d* 脚本来启动本地守护进程，这样您可以轻松且一致地稍后重新启动它们。当然，如果您比较懒惰，可以使用 *rc.local*。
- en: The /etc/rc.shutdown Script
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.shutdown 脚本
- en: Whenever you use `reboot(8)` or `halt(8)`, OpenBSD runs the */etc/rc.shutdown*
    script, which you can count on to run extra commands needed to safely shut down
    your server. Most server software shuts down cleanly without any special intervention,
    but software that requires data integrity (like databases) may need help shutting
    down without losing data. Again, if at all possible, write an *rc.d* script to
    manage your software.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您使用 `reboot(8)` 或 `halt(8)` 时，OpenBSD 都会运行 */etc/rc.shutdown* 脚本，您可以依赖它来运行安全关闭服务器所需的额外命令。大多数服务器软件在没有特殊干预的情况下可以干净地关闭，但需要数据完整性的软件（如数据库）可能需要帮助才能安全关闭而不会丢失数据。再次提醒，如果可能的话，编写一个
    *rc.d* 脚本来管理您的软件。
- en: The /etc/rc.firsttime Script
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.firsttime 脚本
- en: '*/etc/rc* runs the script */etc/rc.firsttime* once, mails the output to root,
    and deletes *rc.firsttime*. The installer uses *rc.firsttime* for tasks such as
    fetching firmware that can’t be legally redistributed. While you won’t normally
    use *rc.firsttime*, you should know that it exists and that you can use it to
    perform one-time tasks when a machine boots.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/rc* 一次运行 */etc/rc.firsttime* 脚本，将输出邮件发送给root，并删除 *rc.firsttime*。安装程序使用
    *rc.firsttime* 来执行诸如获取无法合法重新分发的固件等任务。虽然您通常不会使用 *rc.firsttime*，但您应该知道它存在，并且您可以使用它来在机器启动时执行一次性任务。'
- en: The /etc/fastboot Script
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/fastboot 脚本
- en: If the */etc/fastboot* file exists, OpenBSD assumes that all filesystems are
    clean (see [Chapter 8](ch08.html "Chapter 8. Disks and Filesystems")), and the
    boot process skips checking filesystem integrity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 */etc/fastboot* 文件存在，OpenBSD假定所有文件系统都是干净的（参见[第8章](ch08.html "第8章。磁盘和文件系统")），并且引导过程会跳过检查文件系统完整性。
- en: The /etc/rc.d Directory
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: /etc/rc.d 目录
- en: The */etc/rc.d* directory contains shell scripts for managing software, as discussed
    in the next section. While the system comes with scripts for software included
    in OpenBSD, add-on packages can provide their own scripts (see [Chapter 13](ch13.html
    "Chapter 13. Software Management")).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一节所述，*/etc/rc.d* 目录包含用于管理软件的shell脚本。虽然系统附带了一些包含在OpenBSD中的软件的脚本，但附加包可以提供自己的脚本（参见[第13章](ch13.html
    "第13章。软件管理")）。
- en: Software Startup Scripts
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件启动脚本
- en: OpenBSD uses shell scripts to start, stop, restart, check, and reconfigure server
    software. These scripts are found in the directory */etc/rc.d*. Every piece of
    server software that comes with OpenBSD has a script in this directory, as do
    most ports and packages that need scripts for proper startup and shutdown. Use
    these scripts to manage integrated software without rebooting the server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD使用shell脚本来启动、停止、重新启动、检查和重新配置服务器软件。这些脚本位于 */etc/rc.d* 目录中。OpenBSD附带的所有服务器软件以及大多数需要脚本以正确启动和关闭的ports和packages都有这个目录中的脚本。使用这些脚本来管理集成软件，而无需重新启动服务器。
- en: The *rc.d* scripts read their configuration from *rc.conf* and *rc.conf.local*.
    Most servers run the SSH daemon `sshd`, which can be enabled by adding the line
    `sshd_enable=""` to *rc.conf.local*. Look in */etc/rc.d*, and you’ll find the
    shell script *sshd*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*rc.d* 脚本从 *rc.conf* 和 *rc.conf.local* 中读取其配置。大多数服务器运行SSH守护进程`sshd`，可以通过在 *rc.conf.local*
    中添加行 `sshd_enable=""` 来启用它。查看 */etc/rc.d*，您会找到名为 *sshd* 的shell脚本。'
- en: If you change your `sshd` configuration, you must restart the daemon. Use the
    shell script to do this consistently.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改了您的`sshd`配置，您必须重新启动守护进程。使用shell脚本可以一致地完成此操作。
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Of course, you could do the same thing without the shell script simply by identifying
    the currently running `sshd(8)` process, reading the man page to see how to shut
    it down properly, and then restarting it with the same command-line flags. In
    the case of `sshd`, that’s easy: Running `pkill -1 sshd` would tell the daemon
    to reread its configuration file. But restarting a daemon that requires all sorts
    of flags *is* a big deal. Automating these system administration tasks ensures
    that your daemons run consistently.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以不使用shell脚本简单地通过识别当前运行的`sshd(8)`进程，阅读手册页以了解如何正确关闭它，然后使用相同的命令行标志重新启动它。对于`sshd`来说，这很简单：运行`pkill
    -1 sshd`会指示守护进程重新读取其配置文件。但是，重新启动需要各种标志的守护进程确实是一件大事。自动化这些系统管理任务确保您的守护进程始终运行。
- en: 'To see if a daemon is running, use the `check` command to check your shell
    for the return value. The script will return a `0` if the daemon is running and
    a `1` if it isn’t, as shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查守护进程是否正在运行，请使用`check`命令检查您的shell的返回值。如果守护进程正在运行，脚本将返回`0`，如果没有运行，则返回`1`，如下所示：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see by the `1`, `nfsd` is not running.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过`1`所见，`nfsd`并未运行。
- en: The most common use for `check` is in shell scripts. You can start the daemon
    with the argument `start` and terminate it with `stop`. Use the `restart` argument
    to tell the daemon to reload its configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`最常用的用途是在shell脚本中。您可以使用`start`参数启动守护进程，使用`stop`参数终止它。使用`restart`参数告诉守护进程重新加载其配置。'
- en: In OpenBSD, *rc.d* scripts run when the system boots and again when it shuts
    down. (Something needs to unmount all those hard drives, shut down daemons, and
    clean up.) At shutdown, every script in the */etc/rc.d* folder is called with
    the `stop` argument.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD中，*rc.d* 脚本在系统启动时运行，并在系统关闭时再次运行。（需要卸载所有这些硬盘驱动器，关闭守护进程，并清理。）在关闭时，*/etc/rc.d*
    目录中的每个脚本都会使用`stop`参数调用。
- en: Third-Party rc.d Scripts
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方rc.d脚本
- en: 'OpenBSD packages for third-party software include *rc.d* scripts as necessary.
    For example, the popular database server MySQL `mysql-server` package installs
    the script */etc/rc.d/mysqld*. To use the package, you must enable it in *rc.conf.local*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的第三方软件包包括必要的 *rc.d* 脚本。例如，流行的数据库服务器 MySQL 的 `mysql-server` 软件包安装了脚本
    */etc/rc.d/mysqld*。要使用该软件包，你必须将其在 *rc.conf.local* 中启用：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the package is enabled, you can manage your MySQL server just like any
    other OpenBSD daemon. However, packaged software will still not start automatically
    at boot, so you must tell OpenBSD to run this particular *rc.d* script at boot
    and shut down with the `pkg_scripts` variable in *rc.conf.local*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用该软件包，你就可以像管理任何其他 OpenBSD 守护进程一样管理你的 MySQL 服务器。然而，软件包化的软件在启动时仍然不会自动启动，所以你必须告诉
    OpenBSD 在启动时运行这个特定的 *rc.d* 脚本，并在 *rc.conf.local* 中的 `pkg_scripts` 变量中关闭：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The startup process runs the scripts in this variable, in the order given, at
    boot. The order is important for certain daemons. For example, if you have a database-driven
    website, you should start the database before the web server. At shutdown, it
    runs these scripts in reverse order.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 启动过程在启动时按给定顺序运行此变量中的脚本。对于某些守护进程，顺序很重要。例如，如果你有一个数据库驱动的网站，你应该在启动 web 服务器之前启动数据库。在关闭时，它以相反的顺序运行这些脚本。
- en: Force-Starting Software
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制启动软件
- en: Sometimes you don’t want to enable software globally; you just want to run a
    certain daemon for a short time or to address a specific situation. You can use
    *rc.d* scripts to manage this software using the `-f` flag to force the software
    to run.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不想全局启用软件；你只想运行某个守护进程一段时间或解决特定情况。你可以使用 *rc.d* 脚本通过 `-f` 标志强制软件运行。
- en: 'Now for a real-life example. I previously ran PostgreSQL on my server, but
    someone kidnapped my pet rats and blackmailed me into using MySQL in exchange
    for their safe return. I needed to check some data in the old database, however,
    so I force-started the disabled PostgreSQL server:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个现实生活中的例子。我之前在我的服务器上运行 PostgreSQL，但有人绑架了我的宠物老鼠，并威胁我使用 MySQL 以换取它们的平安归来。然而，我需要检查旧数据库中的某些数据，所以我强制启动了禁用的
    PostgreSQL 服务器：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you package or install your own software, I strongly recommend writing your
    own *rc.d* script. A few minutes spent reading the existing scripts will tell
    you most of what you need to know. For the rest, read the `rc.d(8)` and `rc.subr(8)`
    man pages.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打包或安装自己的软件，我强烈建议编写你自己的 *rc.d* 脚本。花几分钟阅读现有的脚本将告诉你你需要知道的大部分内容。对于其余部分，请阅读 `rc.d(8)`
    和 `rc.subr(8)` 手册页。
- en: Now that you can start OpenBSD, let’s set up some user accounts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以启动 OpenBSD 了，让我们设置一些用户账户。
- en: '* * *'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[11](#id369126)]) On i386 and amd64 systems, this is where the MBR comes
    in.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[11](#id369126)]) 在 i386 和 amd64 系统上，这就是 MBR 出现的地方。
- en: ^([[12](#id418996)]) Granted, a remote keyboard-video-mouse (KVM) system can
    give you all of this, but very few KVM applications let you copy and paste text
    from the remote console. That means you’ll need to copy error messages by hand.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#id418996)]) 当然，一个远程键盘视频鼠标（KVM）系统可以给你所有这些功能，但非常少的 KVM 应用程序允许你从远程控制台复制和粘贴文本。这意味着你需要手动复制错误信息。
