- en: Chapter 6. EXPLORE PROXIMITY
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 探索邻近性
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Maps are all about proximity. What's nearby? How far is it from one location
    to another? This chapter will help you answer those questions with your own maps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 地图都是关于邻近性的。附近有什么？从一个位置到另一个位置有多远？本章将帮助你通过自己的地图来回答这些问题。
- en: In some cases, you'll be using another service, such as Yahoo!'s Local Search
    API. In others, Mapstraction comes through with some handy functions. We'll also
    rely on some mathematicians far smarter than I am to help us make sense of a two-dimensional
    coordinate system applied to earth's three-dimensional sphere.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能需要使用其他服务，例如Yahoo!的本地搜索API。在其他情况下，Mapstraction提供了一些实用的函数。我们还将依赖一些比我聪明的数学家来帮助我们理解应用于地球三维球体的二维坐标系。
- en: '#36: Calculate Distance Between Two Points'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#36: 计算两点之间的距离'
- en: In the ancient times of paper maps, determining the distance between two places
    on a map required using the map's scale and some measuring device. I would often
    use a scrap of paper or my finger to duplicate the length for the number of times
    necessary to calculate the distance. Without a ruler, calculating the distance
    was not an exact science. Some providers still show scales, but Mapstraction makes
    performing the calculation yourself unnecessary.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在纸质地图的古代，确定地图上两点之间的距离需要使用地图的比例尺和一些测量工具。我经常会用一张纸片或手指来复制所需的长度，以计算距离。没有尺子，计算距离并不是一门精确的科学。一些提供商仍然显示比例尺，但Mapstraction使得自己进行计算变得不再必要。
- en: 'Let''s say you have a map with two markers: `marker1` and `marker2`. You can
    determine the latitude and longitude points of these markers and, from there,
    derive the distance. Or, you can let Mapstraction do it for you:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一张带有两个标记的地图：`marker1` 和 `marker2`。你可以确定这些标记的纬度和经度点，并据此计算距离。或者，你可以让Mapstraction为你完成这项工作：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The result is the number of kilometers from `marker1`'s location to `marker2`'s
    location. The `distance` function can be called on any `LatLonPoint`, with a second
    `LatLonPoint` passed as an argument. A marker's `LatLonPoint` is stored in the
    `location` property.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`marker1`位置到`marker2`位置之间的公里数。`distance`函数可以在任何`LatLonPoint`上调用，第二个`LatLonPoint`作为参数传递。标记的`LatLonPoint`存储在`location`属性中。
- en: What's really happening with this calculation? Isn't it the simple Pythagorean
    Theorem that we all learned in grade school—*a*² + *b*² = *c*²? Unfortunately,
    not quite. Pythagoras was working in two dimensions and the earth is a three-dimensional
    ellipsoid—that is, a slightly warped sphere.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算实际上发生了什么？这难道不就是我们在小学学过的简单勾股定理——*a*² + *b*² = *c*²吗？不幸的是，并非完全如此。毕达哥拉斯是在二维空间工作的，而地球是一个三维的椭球体——即一个略微变形的球体。
- en: In [Chapter 1](ch01.html "Chapter 1. MAPPING BASICS"), I described the latitude
    and longitude system, where the distance between degrees of longitude gets smaller
    the farther a point is from the equator. In other words, Pythagoras will get you
    *close enough* if you're in Ecuador, but your calculation would be way off in
    Sweden.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第1章](ch01.html "第1章. 地图基础") 中，我描述了纬度和经度系统，其中随着点离赤道的距离越远，经度之间的距离越小。换句话说，如果你在厄瓜多尔，使用勾股定理可以得到足够接近的结果，但在瑞典你的计算就会偏差很大。
- en: 'You need another strangely named formula—the *Haversine*. This function uses
    the radius of the earth and some fancy spherical trigonometry. Here is a slightly
    altered version of Mapstraction''s distance function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要另一个奇怪命名的公式——*哈弗辛公式*。这个函数使用地球半径和一些复杂的球面三角学。以下是Mapstraction距离函数的一个略微修改版本：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The very first thing this function does is calculate the multiplier ❶ needed
    to convert degrees into radians, which the trigonometry functions use to calculate
    the distance required. A radian is about 57 degrees (180 degrees divided by pi).
    To convert latitude and longitude decimal degrees to radians, we need to multiply
    by the number of radians in a degree, which is roughly 1/57 (pi divided by 180
    degrees).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先做的事情是计算将度数转换为弧度所需的乘数❶，这是三角函数用来计算所需距离的。弧度大约是57度（180度除以π）。要将纬度和经度十进制度数转换为弧度，我们需要乘以一度中的弧度数，这大约是1/57（π除以180度）。
- en: Then we get into the Haversine formula, which determines the shortest distance
    between two points on a sphere. To get a usable distance, we must know the radius
    of the sphere. In this case, we use the radius of the earth in kilometers ❷. To
    get miles, use a radius of 3958\. Or multiply the kilometer result by 0.6213\.
    Mapstraction also has two helper functions, `KMToMiles` and `milesToKM`, to perform
    these conversions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入哈弗辛公式，它确定了球面上两点之间的最短距离。为了得到一个可用的距离，我们必须知道球的半径。在这种情况下，我们使用地球的半径（千米）❷。要得到英里，使用半径3958。或者将千米结果乘以0.6213。Mapstraction还有两个辅助函数，`KMToMiles`和`milesToKM`，用于执行这些转换。
- en: Could You Throw an Object Across a River?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能扔一个物体过河吗？
- en: This math makes my head hurt, so let's look at a practical example. Well, throwing
    things may not be practical in your locale, but in Portland, the Willamette River
    runs through the middle of the city. Naturally, I often wonder whether something
    could be thrown across the river.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这道数学题让我头疼，让我们来看一个实际例子。嗯，在你所在的地方扔东西可能不实用，但在波特兰，威拉米特河穿过城市的中心。自然地，我经常想知道是否有什么东西可以扔过河。
- en: The farthest distance a human has thrown an object was when Erin Hemmings threw
    a disc 1333 feet, over a quarter mile (0.4 km). In this example, we'll see if
    the distance from Portland's downtown west bank to the east bank of the Willamette
    is less than Hemmings' toss.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 人类扔物体最远的距离是Erin Hemmings扔飞盘，距离为1333英尺，超过四分之一英里（0.4公里）。在这个例子中，我们将看看从波特兰市中心西岸到威拉米特河东岸的距离是否小于Hemmings的投掷距离。
- en: 'Naturally, we want to visualize this on a map, so we add the following code
    to the JavaScript section of our basic map, replacing any JavaScript already there:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们想在地图上可视化这个例子，所以我们向我们的基本地图的JavaScript部分添加以下代码，替换掉任何已有的JavaScript：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Be sure you call the `create_map` function when the page loads and that you
    have a `div` tag with its `id` set to `mymap`, just as you did with the basic
    map. Within the function, along with creating the Mapstraction map, this code
    creates two points, one for each side of the river. Then it calculates the distance
    between those two points ❶.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在页面加载时调用`create_map`函数，并且你有一个`div`标签，其`id`设置为`mymap`，就像你在基本地图中做的那样。在函数内部，除了创建Mapstraction地图外，这段代码还创建了两个点，一个在河的一侧，一个在另一侧。然后它计算这两个点之间的距离
    ❶。
- en: We could stop here, but let's add something visual to the map, so it makes more
    sense. Let's add a marker for each of the two points. Then, to make things really
    clear, let's draw a line between the points ❷. You can see how this map looks
    in [Figure 6-1](ch06.html#two_points_and_the_distance_between_them "Figure 6-1. Two
    points and the distance between them").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里停止，但让我们在地图上添加一些视觉元素，使其更有意义。让我们为两个点中的每一个添加一个标记。然后，为了使事情更加清晰，让我们在这两点之间画一条线
    ❷。你可以看到这个地图在[图6-1](ch06.html#two_points_and_the_distance_between_them "图6-1. 两点及其之间的距离")中的样子。
- en: Below the map, we show the user the distance that we calculated. We do this
    by adding a new text node below the map `div` ❸. The text will show the distance,
    which is 0.22 km. Compare this to the record, and you can see that, if your name
    is Erin Hemmings, you can indeed throw an object across the Willamette River!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图下方，我们向用户展示我们计算出的距离。我们通过在地图`div`下方添加一个新的文本节点来实现这一点 ❸。这个文本将显示距离，为0.22公里。与记录进行比较，你可以看到，如果你的名字是Erin
    Hemmings，你确实可以扔一个物体过威拉米特河！
- en: '![Two points and the distance between them](httpatomoreillycomsourcenostarchimages672049.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![两点及其之间的距离](httpatomoreillycomsourcenostarchimages672049.png.jpg)'
- en: Figure 6-1. Two points and the distance between them
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 两点及其之间的距离
- en: '#37: Find True Distance with Routing'
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#37: 使用路线查找真实距离'
- en: Determining the distance between two points is at the crux of searching. That's
    why Mapstraction gives you access to the distance function described in the previous
    project. However, this function only tells you the distance as the crow flies.
    I have yet to see any crows using maps.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确定两点之间的距离是搜索的关键。这就是为什么Mapstraction让你可以访问之前项目中描述的距离函数。然而，这个函数只告诉你鸟飞的距离。我还没有见过任何乌鸦使用地图。
- en: To be able to determine the driving distance between two points, you need a
    lot of information. You need to have a map's underlying data that stores intersections
    and whether a street is one way or two way. Then you need an algorithm to determine
    optimal routes. Creating this on your own would be a chore, so in this example,
    you'll take advantage of the driving directions service from the Google Maps API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两点之间的驾驶距离，你需要大量的信息。你需要有一个存储交叉点和街道是单向还是双向的地图底层数据。然后你需要一个算法来确定最佳路线。自己创建这些会是一项繁琐的工作，所以在这个例子中，你将利用
    Google Maps API 的驾驶路线服务。
- en: For this example, you'll still be using Mapstraction, but you'll be counting
    on Google to calculate the distance. That means you'll need to load the Google
    API, so you'll likely use Google as your mapping provider. You could load a second
    provider and display the Google routing results on its map, however.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你仍然会使用 Mapstraction，但你将依赖 Google 来计算距离。这意味着你需要加载 Google API，因此你可能会使用
    Google 作为你的地图服务提供商。然而，你也可以加载第二个提供商，并在其地图上显示 Google 的路线结果。
- en: You need to understand what's going on here. Unlike calculating the simple distance
    between points, which relies on a formula, here you need to send the points to
    Google and wait for a reply. Due to the wait time for results, performing this
    over many points is not advisable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解这里发生的事情。与依赖于公式的简单点间距离计算不同，这里你需要将点发送到 Google 并等待回复。由于结果等待时间，不建议对多个点执行此操作。
- en: 'Let''s get to the routing code. For this example, I''ll use the two points
    from the standard distance calculation and compare the results. Add this to the
    JavaScript section of your basic map, replacing any other code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看路线代码。在这个例子中，我将使用标准距离计算中的两个点，并比较结果。将以下代码添加到你的基本地图的 JavaScript 部分，替换任何其他代码：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because much of the setup is similar to the map in the previous distance project,
    let's start by discussing the Google-specific code. We can create a `DirectionsService`
    object ❶ because the Google API has been loaded. Even though we usually talk to
    Google through Mapstraction, here we're communicating with Google directly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大部分设置与之前距离项目中的地图相似，让我们先讨论一下 Google 特定的代码。由于 Google API 已经加载，我们可以创建一个 `DirectionsService`
    对象 ❶。尽管我们通常通过 Mapstraction 与 Google 交流，但在这里我们直接与 Google 通信。
- en: Once we've created the `DirectionsService` object, we can do something with
    it. The first thing we do is prepare options ❷, such as our starting and finishing
    points, for our directions search. Because our points were created for Mapstraction,
    we need to convert them to Google's proprietary format. Then we send those options
    to Google along with a callback function ❸ to receive the results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `DirectionsService` 对象，我们就可以用它做些事情。我们首先准备选项 ❷，例如我们的起点和终点，用于我们的路线搜索。由于我们的点是为
    Mapstraction 创建的，我们需要将它们转换为 Google 的专有格式。然后我们将这些选项连同回调函数 ❸ 一起发送给 Google，以接收结果。
- en: When the directions have loaded, Google calls our `setDDist` function. We add
    the driving directions route to the map as a proprietary Google polyline ❹, which
    will help us visually compare the two distance methods. Then we can get the driving
    distance for these directions in meters ❺. To convert to kilometers, just divide
    by 1000.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当路线加载完成后，Google 会调用我们的 `setDDist` 函数。我们将驾驶路线添加到地图上作为一个专有的 Google 多段线 ❹，这将帮助我们直观地比较两种距离方法。然后我们可以获取这些路线的驾驶距离（以米为单位）❺。要将公里转换为米，只需除以
    1000。
- en: Finally, we'll add a new text node below the map `div` ❻, which will communicate
    both distances to the user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在地图 `div` ❻ 下方添加一个新的文本节点，它将向用户传达距离信息。
- en: '![Driving distance compared to Haversine distance](httpatomoreillycomsourcenostarchimages672051.png.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![与 Haversine 距离相比的驾驶距离](httpatomoreillycomsourcenostarchimages672051.png.jpg)'
- en: Figure 6-2. Driving distance compared to Haversine distance
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2. 与 Haversine 距离相比的驾驶距离
- en: As you can see in [Figure 6-2](ch06s02.html#driving_distance_compared_to_haversine_d
    "Figure 6-2. Driving distance compared to Haversine distance"), the distance you
    have to drive is much farther than the lazy crow has to fly. Seeing as the shortest
    distance between two points is a straight line, the routing results will always
    be farther. In this case, because only so many bridges cross the Willamette River,
    the effect is magnified, at least until Google includes swimming directions in
    its API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-2](ch06s02.html#driving_distance_compared_to_haversine_d "图6-2. 驾驶距离与Haversine距离的比较")所示，你必须驾驶的距离比懒惰的乌鸦飞行的距离要远得多。鉴于两点之间的最短距离是直线，路由结果总是会更远。在这种情况下，因为只有这么多桥梁跨越威拉米特河，这种影响被放大了，至少直到谷歌在其API中包含游泳路线。
- en: '#38: Create Driving Directions'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#38：创建驾驶路线'
- en: Perhaps the most useful feature of mapping websites has always been their driving
    directions. The routing technology behind driving direction is more advanced than
    most developers can take on, but Google provides access to driving directions
    via its API. In this section, I'll create a directions widget that could help
    any business show its customers the way to the store. In this case, I'll use La
    Bonita, a Mexican restaurant where I wrote much of this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 地图网站最有用的功能可能一直是它们的驾驶路线。驾驶路线背后的路由技术比大多数开发者能够承担的更先进，但谷歌通过其API提供了驾驶路线的访问权限。在本节中，我将创建一个方向小部件，可以帮助任何企业向客户展示通往商店的路。在这种情况下，我将使用La
    Bonita，一家墨西哥餐厅，我在那里写下了这本书的大部分内容。
- en: 'This example depends heavily on the Google Maps API, so this project is one
    of the few where I won''t use Mapstraction. To start, let''s add some basic HTML
    to a new file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例严重依赖于Google Maps API，所以这个项目是我不会使用Mapstraction的少数项目之一。首先，让我们向一个新文件添加一些基本的HTML：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of this code is for a basic, pretty much empty HTML page. We'll fill it
    in with a form to accept user input and JavaScript to ask Google for driving directions.
    First, let's look at a few new elements, and I'll explain what they mean.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码主要用于一个基本的、几乎空白的HTML页面。我们将用表单来接受用户输入，并用JavaScript请求谷歌的驾驶路线。首先，让我们看看几个新元素，我会解释它们的意义。
- en: In the JavaScript section, I hard-coded La Bonita's address ❶. You can replace
    this with your business address or the location of a party. Then, customers or
    guests will later input their own address. Together, these two addresses will
    make up the start and end points for the driving directions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript部分，我硬编码了La Bonita的地址❶。你可以用你的商业地址或派对的地点替换它。然后，客户或客人将稍后输入他们自己的地址。这两个地址将共同构成驾驶路线的起点和终点。
- en: When the page loads, we're calling the `create_map` function ❷, just as we've
    done in most Mapstraction examples. That's because I made this function up; I
    could have called anything, as it's not tied to Mapstraction.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，我们调用`create_map`函数❷，就像我们在大多数Mapstraction示例中所做的那样。这是因为我想了这个函数；我可以叫任何名字，因为它与Mapstraction无关。
- en: 'Down in the HTML, I included a second `div` ❸. This tag will hold the driving
    direction text. This second `div` is after the map `div`, so the directions will
    be listed below the map. This part of the driving directions service is optional
    (in fact, I omitted it in [#37: Find True Distance with Routing](ch06s02.html
    "#37: Find True Distance with Routing") in [#37: Find True Distance with Routing](ch06s02.html
    "#37: Find True Distance with Routing")), but the text is important for this example.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML的下方，我包含了一个第二个`div`❸。这个标签将包含驾驶方向文本。这个第二个`div`在地图`div`之后，所以方向将列在地图下方。这个驾驶方向服务的部分是可选的（事实上，我在[#37：使用路由找到真实距离](ch06s02.html
    "#37：使用路由找到真实距离")中省略了它），但文本对这个示例很重要。
- en: 'Now that we''ve put the shell of an HTML page together, let''s add the pieces
    that will make this map work. In the blank space above the map `div` (and just
    below the `<h1>` tag), include this form:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经组装好了HTML页面的外壳，让我们添加使这个地图工作的组件。在地图`div`上方的空白区域（以及`<h1>`标签下方），包括以下表单：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most forms send data to the server, but with this example, we want to use JavaScript.
    This means when the user submits the form, we need to call a JavaScript function
    ❹. Then we need to return false to keep the browser from sending the data to the
    server anyway.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数表单都会将数据发送到服务器，但在这个示例中，我们想使用JavaScript。这意味着当用户提交表单时，我们需要调用一个JavaScript函数❹。然后我们需要返回false以防止浏览器将数据发送到服务器。
- en: 'This code asks for the user''s location in three pieces: address, city, and
    state. You could use just one or two fields if you want, but separating them out
    into separate fields helps make your format expectations clear. On the other hand,
    prepping the call to the driving directions service will be more work.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码请求用户的位置信息分为三个部分：地址、城市和州。如果您愿意，可以使用一个或两个字段，但将它们分开成单独的字段有助于使您的格式期望更清晰。另一方面，准备调用驾驶路线服务将需要更多的工作。
- en: The state is shown as a drop-down menu ❺. In the case of my example, I have
    only included Oregon and Washington. La Bonita's food is good, but nobody is going
    to travel very far to get it. You can include the states where your customers
    are most likely to live.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 州以下拉菜单的形式显示❺。在我的示例中，我只包括了俄勒冈州和华盛顿州。La Bonita的食物很好，但没有人会为了它而走很远的路。您可以包括客户最有可能居住的州。
- en: 'Now we''ll hook everything together with JavaScript. At a minimum, we need
    to create the two functions we''ve already referenced in our HTML: `create_map`
    will get the Google Map ready, and `loadDir` will send the addresses to Google''s
    driving directions service.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用JavaScript将所有这些连接起来。至少，我们需要创建我们在HTML中已经引用的两个函数：`create_map`将使Google地图准备就绪，而`loadDir`将发送地址到Google的驾驶路线服务。
- en: 'Add this to the JavaScript section, below La Bonita''s address:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到La Bonita地址下的JavaScript部分：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we make the `gdir` variable global by declaring it outside of a function
    ❶. That way, the variable can be referenced from anywhere in the code. After creating
    the map, we also need to initialize the `gdir` variable ❷, so Google knows we're
    going to be asking for driving directions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过在函数外部声明`gdir`变量使其全局❶。这样，变量就可以在代码的任何地方被引用。在创建地图后，我们还需要初始化`gdir`变量❷，这样Google就知道我们将要求驾驶路线。
- en: We are almost ready for a user to interact with our form. Let's look at the
    function, `loadDir`, that is called when the form is submitted. First, the function
    pieces together the address with the city/state ❸. You might prefer to check for
    empty or malformed content in these fields, but this simple example merely concatenates
    them together.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好让用户与我们的表单进行交互了。让我们看看当表单提交时被调用的函数`loadDir`。首先，该函数将地址与城市/州组合在一起❸。您可能更喜欢检查这些字段中的空或格式不正确的内容，但这个简单的示例只是将它们连接在一起。
- en: Next we set up the options ❹, including the two addresses, that tells Google
    what directions to find. Finally, the function sends the options to Google along
    with a callback function ❺. In the `setDir` function, which receives the driving
    directions, we simply tell Google to render the route on the map and the text
    below the map, as shown in [Figure 6-3](ch06s04.html#driving_directions_from_google
    "Figure 6-3. Driving directions from Google").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置选项❹，包括两个地址，告诉Google要查找哪些路线。最后，该函数将选项连同回调函数❺一起发送给Google。在`setDir`函数中，该函数接收驾驶路线，我们只是告诉Google在地图上以及地图下方显示路线，如图[图6-3](ch06s04.html#driving_directions_from_google
    "图6-3. Google的驾驶路线")所示。
- en: 'That''s it. We''ve created driving directions to get anyone to La Bonita. To
    use it for your business, simply alter the `myaddress` variable and fill in the
    appropriate states. To see an example that digs a little deeper into driving directions,
    see [#73: Find a Coffee Shop to Meet in the Middle](ch10s06.html "#73: Find a
    Coffee Shop to Meet in the Middle") in [#73: Find a Coffee Shop to Meet in the
    Middle](ch10s06.html "#73: Find a Coffee Shop to Meet in the Middle").'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '就这样。我们已经为任何人前往La Bonita创建了驾驶路线。要将其用于您的业务，只需更改`myaddress`变量并填写适当的州。要查看一个更深入探讨驾驶路线的示例，请参阅[#73:
    在中间找到一家咖啡店见面](ch10s06.html "#73: Find a Coffee Shop to Meet in the Middle")。'
- en: 'Check out the full documentation for Google''s driving directions: [http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService](http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Google驾驶路线服务的完整文档：[http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService](http://code.google.com/apis/maps/documentation/javascript/reference.html#DirectionsService)
- en: '#39: Determine Closest Marker'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#39: 确定最近的标记'
- en: Given a point and a whole bunch of markers, can you find the one closest to
    your point? In this project, we'll loop through every marker on the map and draw
    a line between wherever the user clicks and its closest marker, which we'll determine
    by calculating the distance between two points.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点和一大堆标记，你能找到离你的点最近的那个吗？在这个项目中，我们将遍历地图上的每个标记，并在用户点击的位置和最近的标记之间画一条线，我们将通过计算两点之间的距离来确定这个最近的标记。
- en: 'Before we can find the closest marker, however, we need a map with a handful
    of markers plotted. To do this, we''ll get five random points, as shown earlier
    in the chapter. Here, I''ve reprinted the `get_random_by_bounds` function you''ll
    need from that section. Add these lines to your JavaScript section at the top
    of your basic map, but make sure they are outside of the `create_map` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们找到最近的标记之前，我们需要一个带有一些标记的地图。为此，我们将获取五个随机点，如本章前面所示。在这里，我重新打印了您需要从该部分获取的`get_random_by_bounds`函数。将这些行添加到您基本地图的JavaScript部分顶部，但请确保它们在`create_map`函数外部：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Driving directions from Google](httpatomoreillycomsourcenostarchimages672053.png.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![来自Google的驾驶方向](httpatomoreillycomsourcenostarchimages672053.png.jpg)'
- en: Figure 6-3. Driving directions from Google
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3. 来自Google的驾驶方向
- en: 'With that helper function ready, add these lines to your basic map''s `create_map`
    function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个辅助函数之后，将这些行添加到基本地图的`create_map`函数中：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Assuming you''ve already initialized the map, you can almost dive into creating
    the markers. First, you need to create the bounds for the markers, which represents
    the area you''ll use to create the random location. In this case, I used some
    points ❶ that roughly define the "four corners" states in the United States: Arizona,
    Utah, Colorado, and New Mexico.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经初始化了地图，您几乎可以开始创建标记了。首先，您需要创建标记的边界，这代表您将用于创建随机位置的面积。在这种情况下，我使用了一些点❶，这些点大致定义了美国“四个角落”的州：亚利桑那州、犹他州、科罗拉多州和新墨西哥州。
- en: Now we can create a loop ❷ to perform the same bit of code five times. Each
    time through the loop, we'll get a new random point ❸, so our markers could be
    anywhere within the bounds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个循环❷来执行相同的代码五次。每次循环，我们都会得到一个新的随机点❸，因此我们的标记可以在边界内任何地方。
- en: Normally, I'd ask Mapstraction to center and zoom automatically when using random
    markers. Here, however, I set the bounds to be the quartet of states ❹, the same
    area that could possibly hold a marker. This way, I know the markers will all
    be visible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我会要求Mapstraction在使用随机标记时自动居中和缩放。然而，在这里，我设置了边界为四个州的组合❹，这个区域可能包含一个标记。这样，我知道所有的标记都将可见。
- en: 'Lastly, we listen for the user to click the map. Upon a click, we tell Mapstraction
    to call a function to find the closest marker ❺. Now we need to write that function.
    Add these lines to your JavaScript, outside of the `create_map` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待用户点击地图。点击后，我们告诉Mapstraction调用一个函数来找到最近的标记❺。现在我们需要编写这个函数。将这些行添加到您的JavaScript中，在`create_map`函数外部：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to find the closest marker to the point the user clicked, we need
    to check the distance between each marker and the click point. We need to keep
    two pieces of data during our search: the current closest marker we have found
    and its distance to the point.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到用户点击的点最近的标记，我们需要检查每个标记和点击点之间的距离。在搜索过程中，我们需要保留两份数据：我们找到的当前最近标记及其到点的距离。
- en: To begin, we create those two variables and assume the first marker (remember
    JavaScript array indexes start at zero) is currently closest ❻. So we know what
    distance to compare, we also calculate the first marker's distance to the point
    ❼. Now we're ready to loop through all the other markers ❽, starting with the
    second one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建这两个变量，并假设第一个标记（记住JavaScript数组索引从零开始）目前是最接近的❻。因此，我们知道要比较的距离，我们还计算了第一个标记到点的距离❽。现在我们准备好遍历所有其他标记❽，从第二个开始。
- en: Each time through the loop, we calculate the distance between the current marker
    and the click point. If the distance is farther than the closest distance we have
    found so far, we do nothing. If this current marker is now closer than the previous
    ❾ one, we replace our original two variables with new values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环中，我们计算当前标记和点击点之间的距离。如果距离比我们迄今为止找到的最近距离更远，我们就不做任何事情。如果这个当前标记现在比之前的❾个更近，我们就用新值替换原始的两个变量。
- en: After the loop, I created a new polyline between the point where the user clicked
    and the marker that we determined is closest ❿. Load this example into a web browser
    and click around a few times. You'll create several lines, connecting multiple
    markers if you move around enough (see [Figure 6-4](ch06s04.html#each_click_connects_to_its_closest_marke
    "Figure 6-4. Each click connects to its closest marker.")). Which marker is closest
    to Albuquerque? How about Denver?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，我在用户点击的位置和我们所确定的最近的标记之间创建了一条新的折线标记❿。将此示例加载到网页浏览器中并点击几次。如果你移动得足够多，你会创建几条线，连接多个标记（参见[图6-4](ch06s04.html#each_click_connects_to_its_closest_marke
    "图6-4. 每次点击都连接到最近的标记"))。哪个标记离阿尔伯克基最近？丹佛呢？
- en: '![Each click connects to its closest marker.](httpatomoreillycomsourcenostarchimages672055.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![每次点击都连接到最近的标记。](httpatomoreillycomsourcenostarchimages672055.png.jpg)'
- en: Figure 6-4. Each click connects to its closest marker.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4. 每次点击都连接到最近的标记。
- en: '#40: Find a Point Along a Line'
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#40：在一条线上找到一个点'
- en: Let's say you're taking a short flight with your forgetful pilot friend from
    Wichita, Kansas, to Tulsa, Oklahoma, about 140 miles. "Oops," he says nonchalantly
    after you're airborne, "I forgot to gas up." I know what you're thinking—turn
    around! But your friend assures you there is enough gas to go 80 miles, which
    should get you into Oklahoma where the gas is cheaper.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你和你那位健忘的飞行员朋友从堪萨斯州的威奇托飞往俄克拉荷马州的塔尔萨，大约140英里。飞机起飞后，他漫不经心地说：“哎呀，我忘记加油了。”我知道你在想什么——掉头！但你的朋友向你保证，油足够你开80英里，应该能让你到达俄克拉荷马州，那里的油价更便宜。
- en: Knowing the distance between two points is useful, but sometimes you want to
    know the story between those points. For example, what's the midpoint between
    two cities? Or, given point A and point B, what are the coordinates of point C
    that is nine miles along that line? It's a math-heavy problem to solve, but doing
    so makes for some fun possibilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 知道两点之间的距离是有用的，但有时你想要知道这两点之间的故事。例如，两个城市之间的中点在哪里？或者，给定点A和点B，沿着这条线九英里处的点C的坐标是什么？这是一个数学问题，但解决它会带来一些有趣的可能。
- en: 'Fun might not be the right word if you were really flying on a near-empty tank
    from Wichita to Tulsa. But you would definitely want to know where along that
    route you will be after 80 miles when the engine starts to sputter. You would
    be smart to double-check: *will you get to Oklahoma, as your friend claims?* After
    all, this information is coming from the guy who forgot to put gas in his airplane.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的是从威奇托飞往塔尔萨的几乎空油箱上，那么“乐趣”可能不是一个合适的词。但当你发动机开始噼啪作响时，你肯定想知道沿着那条路线80英里后你会在哪里。你最好再检查一下：*你会到达你的朋友所说的俄克拉荷马州吗？*毕竟，这个信息是从那个忘记给飞机加油的家伙那里来的。
- en: 'To find out the answer to the question, we''ll use a three step process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出这个问题的答案，我们将使用三个步骤的过程：
- en: Plot our starting and ending points on a map.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地图上标出我们的起始点和终点。
- en: Calculate our bearing (direction) using the two points.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个点计算我们的航向（方向）。
- en: Use the bearing and starting point to find a new point 80 miles away.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用航向和起始点找到一个80英里外的新点。
- en: Let's get started while there's still time to turn around.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在还有时间掉头之前开始。
- en: Plot Your Route
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制你的路线
- en: 'Since planes fly in a straight line, we''ll use a simple polyline, similar
    to the initial example in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on
    "#16: Draw Lines on a Map") in [#16: Draw Lines on a Map](ch04.html#number_symble_16_colon_draw_lines_on
    "#16: Draw Lines on a Map"). All we need are the starting and ending points for
    the two airports.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '由于飞机直线飞行，我们将使用一个简单的折线，类似于在[第16章：在地图上绘制线条](ch04.html#number_symble_16_colon_draw_lines_on
    "#16: Draw Lines on a Map")中的初始示例。我们只需要两个机场的起始点和终点。'
- en: 'To draw a line between Wichita and Tulsa, add the following function to your
    basic map, replacing your current `create_map` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要在威奇托和塔尔萨之间画一条线，请将以下函数添加到你的基本地图中，替换你当前的`create_map`函数：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file and load it up. Your map should look similar to [Figure 6-5](ch06s05.html#direct_route_between_wichita_and_tulsa
    "Figure 6-5. Direct route between Wichita and Tulsa").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并加载它。你的地图应该看起来类似于[图6-5](ch06s05.html#direct_route_between_wichita_and_tulsa
    "图6-5. 威奇托和塔尔萨之间的直接路线")。
- en: Do you think you can make it to Oklahoma? The 80 miles of fuel in the tank will
    take you almost 60 percent through your route. It's going to be close. Let's continue
    and find out.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你能到达俄克拉荷马州吗？油箱里的80英里油可以让你走完路线的大约60%。这将非常接近。让我们继续并找出答案。
- en: '![Direct route between Wichita and Tulsa](httpatomoreillycomsourcenostarchimages672057.png.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Wichita 和 Tulsa 之间的直接路线](httpatomoreillycomsourcenostarchimages672057.png.jpg)'
- en: Figure 6-5. Direct route between Wichita and Tulsa
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-5. Wichita 和 Tulsa 之间的直接路线
- en: Find Your Bearing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到你的方位角
- en: In order to find a point along a line, you first need to know the direction
    that the line is pointed. The direction is called the bearing, and it is a number
    expressed in degrees, from 0 to 359\. Most compasses mark these degrees around
    the outside, along with the four cardinal directions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到直线上的一个点，你首先需要知道直线的指向。这个方向被称为方位角，它是一个用度数表示的数字，范围从 0 到 359。大多数指南针在周围标记这些度数，以及四个基本方向。
- en: 'In this section, we''ll write a function to calculate the bearing for us, based
    on the work of Chris Veness of Movable Type Ltd. ([http://movable-type.co.uk/](http://movable-type.co.uk/)).
    Add the following code to the JavaScript section of your map file, but outside
    the `create_map` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个函数来计算方位角，这个函数基于 Movable Type Ltd. 的 Chris Veness 的工作。将以下代码添加到你的地图文件的
    JavaScript 部分，但不要放在 `create_map` 函数内部：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Along with the function to calculate the bearing, I've also included a couple
    helper functions to convert between degrees and radians. The trigonometry we use
    is less complicated when using radians (that's right—the math could be even more
    complicated). However, we also need to convert back since degrees are what Mapstraction
    expects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算方位角的函数外，我还包括了一些辅助函数，用于在度数和弧度之间进行转换。当我们使用弧度时，我们使用的三角学更简单（没错——数学可能更复杂）。然而，我们还需要转换回来，因为
    Mapstraction 期望的是度数。
- en: 'Now, from within your `create_map` function, add this line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 `create_map` 函数内部，添加以下这一行：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we call the `get_bearing` function, passing our two points. The result
    should be about 146 degrees. Notice that if you swap the order of the arguments
    to the function, the result will be different: about 326 degrees. That''s because
    you travel a different direction to go from Tulsa to Wichita. Since it''s the
    exact opposite direction, the two results are 180 degrees different.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `get_bearing` 函数，传递我们的两个点。结果应该是大约 146 度。注意，如果你交换函数参数的顺序，结果将不同：大约 326
    度。这是因为从 Tulsa 到 Wichita 的旅行方向不同。由于它是完全相反的方向，这两个结果相差 180 度。
- en: We're going from Wichita to Tulsa, so we'll take that result and use it in the
    next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是从 Wichita 到 Tulsa，所以我们将使用这个结果在下一节中。
- en: Determine New Point
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定新点
- en: Now we know the direction we're traveling. That's an important step toward finding
    the point that is 80 miles along our route. It's time to employ some more fancy
    math using the bearing and the coordinates of our starting point, Wichita.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的行进方向。这是找到我们路线上的 80 英里处的点的关键步骤。是时候使用一些更复杂的数学，结合方位角和我们的起点 Wichita 的坐标了。
- en: 'In this section we''ll write another function, again based on the work of Chris
    Veness. Add the following code to your JavaScript, taking care to not put it inside
    any other functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写另一个函数，同样基于 Chris Veness 的工作。将以下代码添加到你的 JavaScript 中，注意不要将其放在任何其他函数内部：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to call our newly created function. Add the following code inside
    the `create_map` function, just after the line that calculates the bearing:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要调用我们刚刚创建的函数。在 `create_map` 函数中，在计算方位角的行之后添加以下代码：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the distance we're passing to the new function is 128, not 80\.
    That's because the function expects the distance in *kilometers*, not miles. This
    matches the way Mapstraction calculates distance. To convert miles to kilometers,
    multiply the miles by 1.6.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递给新函数的距离是 128，而不是 80。这是因为该函数期望距离以 *千米* 为单位，而不是英里。这与 Mapstraction 计算距离的方式相匹配。要将英里转换为千米，将英里数乘以
    1.6。
- en: Take a deep breath before you load your changes. Along with determining the
    point 80 miles along the path, the code creates and adds a marker to the map,
    as shown in [Figure 6-6](ch06s05.html#miles_from_wichita_gets_you_into_oklahom
    "Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载你的更改之前深吸一口气。除了确定路径上的 80 英里处的点之外，代码还会创建并添加一个标记到地图上，如图 [图 6-6](ch06s05.html#miles_from_wichita_gets_you_into_oklahom
    "图 6-6. 从 Wichita 出发 80 英里就进入俄克拉荷马州！") 所示。
- en: '![80 Miles from Wichita gets you into Oklahoma!](httpatomoreillycomsourcenostarchimages672059.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![从 Wichita 出发 80 英里就进入俄克拉荷马州！](httpatomoreillycomsourcenostarchimages672059.png.jpg)'
- en: Figure 6-6. 80 Miles from Wichita gets you into Oklahoma!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-6. 从 Wichita 出发 80 英里就进入俄克拉荷马州！
- en: And you can take another deep breath, because it looks like 80 miles of gas
    will get you from Wichita into Oklahoma where, according to your forgetful pilot
    friend, you can fill up for less. As for finding a landing strip, that's another
    issue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再深吸一口气，因为看起来80英里的油量可以让你从威奇托开到俄克拉荷马州，根据你健忘的飞行员朋友的说法，在那里你可以以更低的价格加油。至于找到着陆点，那是另一个问题。
- en: 'Now that you know how to find a point along a line, try out a less hypothetical
    project. [#73: Find a Coffee Shop to Meet in the Middle](ch10s06.html "#73: Find
    a Coffee Shop to Meet in the Middle") in [#73: Find a Coffee Shop to Meet in the
    Middle](ch10s06.html "#73: Find a Coffee Shop to Meet in the Middle") combines
    the project you just finished with driving directions and local search results.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经知道了如何找到线上的一个点，尝试一个不那么假设性的项目。[#73: 在中间找到一个咖啡店见面](ch10s06.html "#73: Find
    a Coffee Shop to Meet in the Middle") 在 [#73: 在中间找到一个咖啡店见面](ch10s06.html "#73:
    Find a Coffee Shop to Meet in the Middle") 中将你刚刚完成的项目与行车路线和本地搜索结果结合起来。'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The point you find will only appear directly on the line over short distances,
    like the 140-mile trip in this example. For larger distances, the point will be
    correct, but the line will be wrong. Standard polylines do not take the curvature
    of the earth into consideration. To get a line that follows the "great circle"
    shortest distance between two points, you'll need to use a geodesic polyline,
    which is supported by Google.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你找到的点将只会在短距离内直接位于线上，就像这个例子中的140英里行程一样。对于更长的距离，点将是正确的，但线将是错误的。标准的多段线不考虑地球的曲率。为了得到两点之间“大圆”最短距离的线，你需要使用大地测量多段线，这是谷歌支持的。
- en: '#41: Plot Local Results on a Map'
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#41: 在地图上绘制本地结果'
- en: When you are searching nearby, sooner or later you want to find businesses that
    meet certain qualifications. For example, in Portland we're always looking for
    coffee. In San Francisco, where this example takes place, that means finding delicious,
    cheap burritos.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在附近搜索时，迟早你会想要找到符合某些条件的企业。例如，在波特兰，我们总是在寻找咖啡。在这次示例发生的旧金山，这意味着要找到美味且价格便宜的墨西哥卷饼。
- en: In this project we'll use JavaScript to perform a local search for the keyword
    *burritos*. Both Google and Yahoo! have APIs that allow for this type of search.
    In this example, we'll use Yahoo! because it is simple and to the point.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用JavaScript来执行针对关键词 *burritos* 的本地搜索。谷歌和雅虎都提供了允许这种搜索的API。在这个例子中，我们将使用雅虎，因为它简单直接。
- en: 'We''re starting with a basic Mapstraction map, so we minimize the number of
    provider-specific calls. Because most of my examples have used Google as a provider,
    double-check that you''re calling the Yahoo! Maps API:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基本的Mapstraction地图开始，因此我们最小化了特定提供者的调用次数。因为我的大多数示例都使用了谷歌作为提供者，请确保你正在调用雅虎地图API：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the external JavaScripts loaded, replace any existing inline JavaScript
    code with the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当外部JavaScript加载完成后，将任何现有的内联JavaScript代码替换为以下内容：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To be able to use Yahoo-specific calls, we need to grab the map object ❶. Then
    we need to let the map know that we're interested in an event, which will occur
    when our search is complete. We also reference a function where the results can
    be sent ❷. We'll create that function in a moment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用雅虎特定的调用，我们需要获取地图对象 ❶。然后我们需要让地图知道我们对一个事件感兴趣，这个事件将在我们的搜索完成后发生。我们还引用了一个可以发送结果的函数
    ❷。我们稍后会创建这个函数。
- en: 'Now, we need to write the code that actually initiates a local search to Yahoo!
    ❸. The `searchLocal` function requires four values to be passed to it: We send
    the center of the map, the search query, the search radius (in miles) ❹, and the
    number of results ❺.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写实际启动对雅虎进行本地搜索的代码 ❸。`searchLocal` 函数需要传递四个值：我们发送地图的中心、搜索查询、搜索半径（以英里为单位）
    ❹ 和结果数量 ❺。
- en: 'Then we write the `plotResults` function. Add the following lines below the
    `create_map` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编写 `plotResults` 函数。在 `create_map` 函数下方添加以下行：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The search results are passed from Yahoo! as a parameter ❶ to our function.
    The parameter is a special object that contains a number of pieces of information
    about each business we found. We want to extract the latitude, longitude, address,
    and business name from the object, which we do by looping ❷ through the results.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果作为参数 ❶ 从雅虎传递到我们的函数。该参数是一个特殊对象，其中包含我们找到的每个企业的许多信息。我们想要从对象中提取纬度、经度、地址和商家名称，我们通过遍历
    ❷ 结果来实现这一点。
- en: Each time through the loop, we access the four pieces of information we require
    for a business. To get usable latitude and longitude values, we need to use the
    JavaScript helper function `parseFloat` ❸. This function converts textual values
    into the floating point numbers required for coordinates.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，我们访问我们需要的四个商业信息。为了获取可用的经纬度值，我们需要使用 JavaScript 辅助函数 `parseFloat` ❸。这个函数将文本值转换为坐标所需的浮点数。
- en: The rest is probably old hat to you by now. We create a marker, put text in
    the message box (the name and address of the location), and when we've added all
    the markers, we make sure they can all be seen on the map ❹, as shown in [Figure 6-7](ch06s07.html#local_results_plotted_on_a_yahoo_exclama
    "Figure 6-7. Local results plotted on a Yahoo! map").
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的现在可能对你来说已经很熟悉了。我们创建一个标记，在消息框中输入文本（地点的名称和地址），当我们添加了所有标记后，我们确保它们都可以在地图上显示出来❹，如图
    [图 6-7](ch06s07.html#local_results_plotted_on_a_yahoo_exclama "图 6-7. Yahoo! 地图上的本地结果")
    所示。
- en: '#42: Retrieve Local Results with HTTP'
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#42: 使用 HTTP 获取本地结果'
- en: On many occasions you'll want to use something more powerful than JavaScript
    to perform a local search. For example, you may want to store the results in a
    database or output them into an RSS feed. In either case, the approach used in
    the previous project just won't do. Instead, we'll use Yahoo!'s Local Search API
    and access it with PHP, a popular server-side programming language available on
    many web hosts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能需要使用比 JavaScript 更强大的工具来执行本地搜索。例如，你可能希望将结果存储在数据库中或将它们输出到 RSS 源中。在任一情况下，之前项目中使用的方法都行不通。相反，我们将使用
    Yahoo! 的本地搜索 API，并通过 PHP 访问它，这是一种在许多网络主机上可用的流行服务器端编程语言。
- en: '![Local results plotted on a Yahoo! map](httpatomoreillycomsourcenostarchimages672061.png.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Yahoo! 地图上的本地结果](httpatomoreillycomsourcenostarchimages672061.png.jpg)'
- en: Figure 6-7. Local results plotted on a Yahoo! map
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-7. Yahoo! 地图上的本地结果
- en: Before we bring the results into code, let's see what they look like. One of
    the great things about an API like the one we're using is that it outputs plain-text
    XML, which can be interpreted by a web browser and is human-readable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将结果带入代码之前，让我们看看它们看起来像什么。我们使用的 API 中的一个优点是它输出纯文本 XML，这可以被网络浏览器解释，并且是可读的。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the concepts in this project may be considered advanced. They build
    upon those introduced in [Chapter 8](ch08.html "Chapter 8. DATA FORMATS") and
    [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目中的某些概念可能被认为是高级的。它们建立在 [第 8 章](ch08.html "第 8 章. 数据格式") 和 [第 9 章](ch09.html
    "第 9 章. 服务器端") 中介绍的概念之上。
- en: 'Just like going to an ordinary web page, you can access the Local Search API
    by visiting a URL. Try typing this search for burritos in San Francisco into your
    location bar:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像访问普通网页一样，你可以通过访问一个 URL 来访问本地搜索 API。尝试在地址栏中输入以下搜索：在旧金山搜索玉米卷：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The request parameters are highlighted in bold. The first, your `appid`, is
    your Yahoo! API key. The `query` is what you're searching for and the `location`
    is where you're searching.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请求参数以粗体显示。第一个，你的 `appid`，是你的 Yahoo! API 密钥。`query` 是你正在搜索的内容，而 `location` 是你正在搜索的位置。
- en: 'Once the results are loaded, you''ll see something like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结果被加载，你会看到类似以下的内容：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Like most XML documents, the results declare themselves to be XML ❶ on the first
    line. The second line is the root element ❷ of the document, meaning it contains
    all other tags below it. Every result is stored within a `<Result>` tag ❸, with
    data items stored within tags one level below.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 XML 文档一样，结果在第一行声明自己是 XML ❶。第二行是文档的根元素 ❷，这意味着它包含其下所有其他标签。每个结果都存储在 `<Result>`
    标签 ❸ 中，数据项存储在低于一级的标签中。
- en: 'For more on the terms used to describe XML, see [#52: Use XML](ch08.html#number_symble_52_colon_use_xml
    "#52: Use XML") in [#52: Use XML](ch08.html#number_symble_52_colon_use_xml "#52:
    Use XML"), which also contains a more in-depth description of parsing XML than
    I''ll provide in the next section.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '更多关于描述 XML 的术语，请参阅 [#52: 使用 XML](ch08.html#number_symble_52_colon_use_xml "#52:
    使用 XML")，其中还包含比我将在下一节中提供的更深入的 XML 解析描述。'
- en: Parse Local Results with PHP
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 解析本地结果
- en: Viewing the XML that Yahoo! returns within a browser is one thing. Even more
    useful is to read it into PHP, which allows you to do even more. In this example,
    we'll get the same burrito results as in the previous section and print out the
    name of the first restaurant found.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看 Yahoo! 返回的 XML 是一件事情。更有用的事情是将它读入 PHP，这允许你做更多的事情。在这个例子中，我们将获取与上一节相同的玉米卷结果，并打印出找到的第一家餐厅的名称。
- en: 'Create a new PHP file and add the following lines:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的PHP文件并添加以下行：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I've stored the three parameters as PHP variables. This makes it easy for you
    to include your own API key and change the search terms. Go ahead and change what
    we're searching for, or include your own city. Notice that, even though we're
    hard-coding the search criteria, I've used the `urlencode` function to make sure
    the URL remains valid. For example, the encoding of the location ❶ will replace
    the spaces and comma with URL-friendly versions of those characters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这三个参数存储为PHP变量。这使得你可以轻松地包含自己的API密钥并更改搜索词。继续更改我们正在搜索的内容，或者包含你自己的城市。请注意，尽管我们正在硬编码搜索条件，但我已经使用了`urlencode`函数来确保URL的有效性。例如，位置的编码❶将替换空格和逗号，以使用这些字符的URL友好版本。
- en: 'Next, I put the parameters together in URL form ❷, so we can retrieve the results.
    The actual call to download the web page happens in another function ❸, which
    you can find described in detail in [#61: Retrieve a Web Page](ch09s03.html "#61:
    Retrieve a Web Page") in [#61: Retrieve a Web Page](ch09s03.html "#61: Retrieve
    a Web Page").'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我将参数以URL形式组合在一起❷，这样我们就可以检索结果。实际下载网页的调用发生在另一个函数❸中，你可以在[第61节：检索网页](ch09s03.html
    "#61: Retrieve a Web Page")中找到详细描述。'
- en: 'Finally, the PHP code prints out the name of the first result: El Farolito
    in the example results. You are more likely to want to do something more interesting
    with the results than print out the first name, but this gives you an idea of
    how to access the items.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PHP代码打印出第一个结果的名字：示例结果中的El Farolito。你可能更希望对结果做些更有趣的事情，而不仅仅是打印出第一个名字，但这给你提供了一个如何访问这些条目的想法。
- en: Other Useful Parameters
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有用参数
- en: 'In the previous example, I showed just three parameters that you can use to
    search with Yahoo!''s Local Search API: `appid` (required), `query` (required
    for most searches), and `location`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我展示了你可以使用Yahoo!本地搜索API进行搜索的三个参数：`appid`（必需）、`query`（大多数搜索必需）和`location`。
- en: Many more options are available, the most interesting of which I've included
    in [Table 6-1](ch06s07.html#additional_parameters_accepted_by_yahoo "Table 6-1. Additional
    Parameters Accepted by Yahoo! Local Search").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多选项可用，其中最有趣的我已包括在[表6-1](ch06s07.html#additional_parameters_accepted_by_yahoo
    "表6-1. Yahoo!本地搜索接受的附加参数")中。
- en: Table 6-1. Additional Parameters Accepted by Yahoo! Local Search
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1. Yahoo!本地搜索接受的附加参数
- en: '| Parameter name | Description |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 参数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `city`, `state`, and `zip` | Any of these three can be used, alone or in
    combination, to replace the free-form `location` parameter used in the example.
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `city`、`state`和`zip` | 这三个中的任何一个都可以单独使用或组合使用，以替换示例中使用的自由格式`location`参数。|'
- en: '| `latitude` and `longitude` | If both of these are used, they take the place
    of any other location data and set the search center at the point created by the
    coordinates. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `latitude`和`longitude` | 如果这两个都使用，它们将取代任何其他位置数据，并将搜索中心设置在由坐标创建的点。|'
- en: '| `radius` | Sets the maximum distance (in miles) from the search location.
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `radius` | 设置搜索位置的最大距离（以英里为单位）。|'
- en: '| `results` | Declares the number of results, from 1 to 20\. The default value
    is 10. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `results` | 声明结果数量，从1到20。默认值是10。|'
- en: '| `sort` | Indicates how the results will be sorted, using one of four options:
    `distance`, `rating`, `relevance`, or `title`. The default value is `relevance`.
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 指示结果将如何排序，使用以下四个选项之一：`distance`（距离）、`rating`（评分）、`relevance`（相关性）或`title`（标题）。默认值是`relevance`。|'
- en: More parameters are listed in Yahoo!'s documentation,^([[2](#ftn.CHP-6-FN-1)])
    but with the examples here you should be able to get some interesting results.
    Where's your nearest taxidermist?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo!的文档中列出了更多参数^([[2](#ftn.CHP-6-FN-1)]），但通过这里提供的示例，你应该能够得到一些有趣的结果。你最近的动物标本制作师在哪里？
- en: '* * *'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#CHP-6-FN-1)]) [http://developer.yahoo.com/search/local/V3/localSearch.html](http://developer.yahoo.com/search/local/V3/localSearch.html)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-6-FN-1)]) [http://developer.yahoo.com/search/local/V3/localSearch.html](http://developer.yahoo.com/search/local/V3/localSearch.html)
- en: '#43: Check Whether a Point Is Within a Bounding Box'
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#43：检查点是否在边界框内'
- en: Among the most important shapes in mapping is the rectangle. After centuries,
    we still view maps in a rectangular shape, even with today's fancy JavaScript.
    A rectangle can also be easily described (you only need two points), and determining
    if a point is within a specific rectangle requires no fancy math.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图绘制中，矩形是最重要的形状之一。经过几个世纪，我们仍然以矩形形状查看地图，即使是在今天的JavaScript中也是如此。矩形也可以很容易地描述（你只需要两个点），判断一个点是否在特定的矩形内不需要复杂的数学计算。
- en: As you'll see in later in this project, checking for a point within a `BoundingBox`
    is the first step. You might also use this to determine, for example, whether
    all the markers are on the screen.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本项目的后续部分看到的那样，检查一个点是否在`BoundingBox`内是第一步。你也可以用它来确定，例如，所有标记是否都在屏幕上。
- en: Because finding if a point is within a rectangle is such a useful feature, Mapstraction
    has baked it in as a function. Given any `BoundingBox` object, you can pass a
    `LatLonPoint` and receive back either true (within the box) or false.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于判断一个点是否在矩形内是一个非常实用的功能，Mapstraction将其作为一个函数内置。给定任何`BoundingBox`对象，你可以传递一个`LatLonPoint`并返回true（在框内）或false。
- en: 'Here''s code to determine whether a point is within the map view:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是确定一个点是否在地图视图中的代码：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What's happening? It's not that complicated. A `BoundingBox` is determined by
    its southwest and northeast points (see [Figure 6-8](ch06s08.html#a_boundingbox_is_declared_by_its_southwe
    "Figure 6-8. A BoundingBox is declared by its southwest and northeast points.")).
    So to be within a box, your latitude must be between the latitude of those two
    points. Longitude is the same.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？这并不复杂。一个`BoundingBox`由其西南角和东北角点确定（见[图6-8](ch06s08.html#a_boundingbox_is_declared_by_its_southwe
    "图6-8. 一个 BoundingBox 通过其西南角和东北角点来声明."")）。所以要在框内，你的纬度必须在这两个点的纬度之间。经度是相同的。
- en: '![A BoundingBox is declared by its southwest and northeast points.](httpatomoreillycomsourcenostarchimages672063.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![一个 BoundingBox 通过其西南角和东北角点来声明。](httpatomoreillycomsourcenostarchimages672063.png.jpg)'
- en: Figure 6-8. A `BoundingBox` is declared by its southwest and northeast points.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8. 一个`BoundingBox`通过其西南角和东北角点来声明。
- en: 'Here is a slightly altered version of Mapstraction''s `BoundingBox contains`
    function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Mapstraction的`BoundingBox contains`函数的一个稍微修改过的版本：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Yes, the math is fairly straightforward, but that would be a lot of code to
    write out each time. I'm sure glad Mapstraction does it for us.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，数学相当直接，但每次都要编写很多代码。我很高兴Mapstraction为我们做了这件事。
- en: Can You Click Inside the Box?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你能在框内点击吗？
- en: Now that we know how to check for points inside a box, let's try it. This example
    will create a bounding box smaller than the viewable map. When the user clicks,
    we check whether the point where he or she clicked is inside our box.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何检查一个点是否在框内，让我们试试。这个例子将创建一个比可视地图小的边界框。当用户点击时，我们检查他或她点击的点是否在我们的框内。
- en: To make things clear, we'll draw a polyline around the bounding box, making
    it easy to tell whether Mapstraction returns the correct results. Do you think
    you can click inside the box?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更清晰，我们将在边界框周围绘制一个多边形，这样就可以很容易地判断Mapstraction是否返回了正确的结果。你认为你能在框内点击吗？
- en: 'Add the following code into the JavaScript section of a basic map, replacing
    any existing code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到基本地图的JavaScript部分，替换任何现有的代码：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After creating the map, we make a somewhat arbitrary bounding box ❶ around
    San Francisco. Then we take that same box and make it visible on the map by tracing
    its edges ❷. We use the `BoundingBox_to_Polyline` function, which I explain in
    detail in [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a
    Rectangle to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area"). For convenience, I have reprinted
    it here.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '在创建地图后，我们在旧金山周围创建了一个相当随意的边界框❶。然后我们用同样的框并沿着其边缘绘制使其在地图上可见❷。我们使用`BoundingBox_to_Polyline`函数，我在[第19章：绘制矩形声明区域](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area")中详细解释了它。为了方便，我在这里重新打印了它。'
- en: Next we need to listen for clicks on the map ❸. When the user clicks, we need
    to see if the clicked point is within the box. To do this, we call the `contains`
    function on the `BoundingBox` object we created ❹. The outcome (true or false)
    will determine what message we display to the user.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要监听地图上的点击❸。当用户点击时，我们需要查看点击的点是否在框内。为此，我们在我们创建的`BoundingBox`对象上调用`contains`函数❹。结果（true或false）将决定我们向用户显示什么信息。
- en: To communicate the outcome to the user, we add a new marker where the user clicked
    and open up its message box ❺ to display whether the click was inside the bounds.
    Try it a few times. Click inside, click outside—it gets it right every time! An
    example result is shown in [Figure 6-9](ch06s08.html#clicking_a_point_within_the_bounding_box
    "Figure 6-9. Clicking a point within the bounding box").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将结果传达给用户，我们在用户点击的位置添加一个新的标记，并打开其消息框❺以显示点击是否在边界内。试几次。点击内部，点击外部——它每次都能正确识别！一个示例结果如图[图6-9](ch06s08.html#clicking_a_point_within_the_bounding_box
    "图6-9. 点击边界框内的点")所示。
- en: '![Clicking a point within the bounding box](httpatomoreillycomsourcenostarchimages672065.png.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![点击边界框内的点](httpatomoreillycomsourcenostarchimages672065.png.jpg)'
- en: Figure 6-9. Clicking a point within the bounding box
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-9. 点击边界框内的点
- en: '#44: Get a Random Point in a Bounding Box'
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#44: 在边界框内获取一个随机点'
- en: Quick! Think of a number between −122.9 and −122.8! Though not an ordinary question,
    you may find yourself asking it while creating maps. Especially for testing, you'll
    want to be able to generate random geographic points, often within a specific
    area. In a way, finding a random point within a box is the opposite of the previous
    project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 快！想一个介于-122.9和-122.8之间的数字！虽然这不是一个普通的问题，但你可能会在创建地图时问自己。特别是对于测试，你希望能够生成随机地理点，通常在特定区域内。从某种意义上说，在矩形区域内找到一个随机点与上一个项目正好相反。
- en: I've created a special function just for creating random points. You may have
    even seen it in other parts of this book. In this section, I'll describe it briefly,
    and then use it in an example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个专门用于创建随机点的特殊函数。你可能甚至在其他部分这本书中见过它。在本节中，我将简要描述它，然后在一个示例中使用它。
- en: 'Here is the code to get a random point:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是获取随机点的代码：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The most important piece of information that this function needs is to know
    the general area, or the *bounds*, where you want the random point. This information
    is passed as the single parameter ❶ of this function, a Mapstraction `BoundingBox`
    object. The `BoundingBox` object is made up of the southwest (SW) and northeast
    (NE) corners of a rectangular area. Between those two points, you can determine
    the maximum and minimum values of the edges.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数最需要的信息是知道你想要随机点的大致区域，即*边界*。这个信息作为该函数的单个参数❶传递，是一个Mapstraction `BoundingBox`对象。`BoundingBox`对象由矩形区域的西南（SW）和东北（NE）角组成。在这两点之间，你可以确定边的最大和最小值。
- en: Now, we know where the point will be, but we still need to make the point random
    using a built-in JavaScript function ❷. The number returned by `Math.random` is
    a decimal between 0 and 1, which is not likely to be what you want. We can, however,
    use that number, multiplied by our range ❸, to determine the random coordinate.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道点将位于何处，但我们仍然需要使用内置的JavaScript函数❷来使点变得随机。`Math.random`返回的数字是一个介于0和1之间的十进制数，这很可能不是你想要的。然而，我们可以使用这个数字，乘以我们的范围❸，来确定随机坐标。
- en: For example, to get the random latitude, we take the NE latitude minus the SW
    latitude and multiply that answer (the distance in degrees between the two latitudes)
    by the random number. Then, we add the SW latitude (the smallest of the two) to
    the outcome. As a result, our smallest latitude (when the random number is zero)
    will be the same as the SW latitude; the largest latitude (when the random number
    is one) will be the same as the NE latitude.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取随机纬度，我们取东北纬度减去西南纬度，然后将这个答案（两个纬度之间以度为单位距离）乘以随机数。然后，我们将西南纬度（两者中最小的一个）加到结果上。因此，我们的最小纬度（当随机数为零时）将与西南纬度相同；最大纬度（当随机数为一时）将与东北纬度相同。
- en: The same process is then applied to the longitude but with a new random number.
    Now that we have a latitude and a longitude, we can return the two numbers as
    a new `LatLonPoint` ❹.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将相同的流程应用于经度，但使用一个新的随机数。现在我们有了纬度和经度，我们可以将这两个数字作为新的`LatLonPoint`❹返回。
- en: 'Here''s an example using a random point. Be sure you have the `get_random_by_bounds`
    function in your JavaScript code and then add the following lines to the `create_map`
    function of a basic map:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用随机点的示例。确保你的JavaScript代码中有`get_random_by_bounds`函数，然后向基本地图的`create_map`函数中添加以下行：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need some bounds to be able to pass to the random point function. In this
    case, I made up some points ❶ roughly located around my hometown of Portland,
    Oregon. When creating a new `BoundingBox`, we must pass four numbers in this order:
    SW latitude, SW longitude, NE latitude, and NE longitude.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些边界才能传递给随机点函数。在这种情况下，我虚构了一些点 ❶，大致位于我的家乡俄勒冈州波特兰市。在创建一个新的`BoundingBox`时，我们必须按以下顺序传递四个数字：SW纬度，SW经度，NE纬度，和NE经度。
- en: Next we get the random point ❷ by passing the bounds we just created. Remember
    the function we created used a `return` to share the new random point. When we
    call the function, we can declare a variable (which I called `pt`) to store that
    returned value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过传递我们刚刚创建的边界来获取随机点 ❷。记住我们创建的函数使用了`return`来共享新的随机点。当我们调用该函数时，我们可以声明一个变量（我称之为`pt`）来存储返回的值。
- en: 'To show the random point, I used it to create a new marker and then placed
    the marker on the map. If you want to visually check that the point is really
    within your bounds, try incorporating [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area") in [#19: Draw a Rectangle to Declare
    an Area](ch04s04.html "#19: Draw a Rectangle to Declare an Area") with this one.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '为了显示随机点，我使用它创建了一个新的标记，并将其放置在地图上。如果你想直观地检查这个点是否真的在你的边界内，尝试将[第19节：绘制一个矩形来声明一个区域](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area")与这个一起使用。'
- en: '#45: Check Whether a Point Is Within a Shape'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#45: 检查一个点是否在形状内'
- en: Did the user just click on Kansas? Is this address within the city limits? These
    questions are common ones you'll want to answer with a *hit test*, the process
    used to determine whether a point is inside a shape. To do so requires some data
    (the outline of the shape) and a little math. In this section, I'll show how you
    can crunch the coordinates and find the answers to these and other questions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用户刚刚点击了堪萨斯州吗？这个地址是否在城市的界限内？这些问题是你希望用碰撞测试来回答的常见问题，碰撞测试是用来确定一个点是否在形状内的过程。要做到这一点，需要一些数据（形状的轮廓）和一些数学知识。在本节中，我将展示如何处理坐标并找到这些以及其他问题的答案。
- en: First, the data. A shape can be described as a series of latitude and longitude
    points, where the start and end are the same point, enclosing a polygon. You may
    be able to create the shape you want by tracing the border. You can likely find
    someone sharing their shape online. For example, polygons for all 50 US states
    can be found at [http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，数据。一个形状可以描述为一系列纬度和经度点，其中起点和终点是同一个点，围成一个多边形。你可能可以通过绘制边界来创建你想要的形状。你很可能会在网上找到分享他们形状的人。例如，所有50个美国州的形状可以在[http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries)找到。
- en: We'll perform a hit test to see if the point where a user clicks is inside a
    state. Seeing as Kansas is somewhat rectangular, let's choose a state that has
    a slightly more complex shape, such as Utah (see [Figure 6-10](ch06s10.html#the_state_of_utah_apostrophy_s_panhandle
    "Figure 6-10. The state of Utah's panhandle makes for a good hit test.")). The
    edges of Utah are made up of six points, which means describing Utah as a line
    requires seven points (because the final point needs to reconnect with the first
    point).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行一个碰撞测试来查看用户点击的点是否在某个州内。鉴于堪萨斯州形状较为规则，让我们选择一个形状稍微复杂一些的州，比如犹他州（见[图6-10](ch06s10.html#the_state_of_utah_apostrophy_s_panhandle
    "图6-10. 犹他州手柄部分的状态非常适合进行碰撞测试。"))。犹他州的边缘由六个点组成，这意味着描述犹他州作为一条线需要七个点（因为最后一个点需要与第一个点重新连接）。
- en: 'Here is some Mapstraction code to describe the outline of Utah as a series
    of coordinates:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些Mapstraction代码，用来描述犹他州的轮廓作为一系列坐标：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we want to write a function that determines whether a particular point is
    within the polygon that could be created with these points. Our point could be
    anywhere on the earth. Seeing as Utah is a relatively small area, our point is
    quite likely not in the state. Let's rule that out quickly—before getting to the
    advanced math.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想编写一个函数，用来确定特定点是否在由这些点创建的多边形内。我们的点可能位于地球上的任何地方。鉴于犹他州是一个相对较小的区域，我们的点很可能不在该州内。让我们快速排除这一点——在进入高级数学之前。
- en: '![The state of Utah''s panhandle makes for a good hit test.](httpatomoreillycomsourcenostarchimages672067.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![犹他州手柄部分的状态非常适合进行碰撞测试。](httpatomoreillycomsourcenostarchimages672067.png.jpg)'
- en: Figure 6-10. The state of Utah's panhandle makes for a good hit test.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-10. 犹他州手柄部分的状态非常适合进行碰撞测试。
- en: Find the Polygon's Bounding Box
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到多边形的边界框
- en: The easiest way to determine that a point is *not* within a polygon is to show
    the point lies outside the polygon's bounding box. To determine the rectangular
    bounds of a polygon, we must look through each point, so we can find the minimum
    and maximum values for both latitude and longitude.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个点不在多边形内部的最简单方法就是证明这个点位于多边形边界框的外部。为了确定多边形的矩形边界，我们必须查看每个点，这样我们就可以找到纬度和经度的最小值和最大值。
- en: Once we have those values, we'll know what to use to create the bounding box.
    An example of one is shown in [Figure 6-11](ch06s10.html#a_polygon_apostrophy_s_rectangular_bound
    "Figure 6-11. A polygon's rectangular bounds").
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些值，我们就会知道如何创建边界框。一个例子在[图6-11](ch06s10.html#a_polygon_apostrophy_s_rectangular_bound
    "图6-11. 一个多边形的矩形边界")中展示。
- en: 'Let''s write a function to create a new Mapstraction `BoundingBox` from a series
    of `LatLonPoints`. Here is the code for the entire function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来从一系列`LatLonPoints`创建一个新的`Mapstraction` `BoundingBox`。以下是整个函数的代码：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![A polygon''s rectangular bounds](httpatomoreillycomsourcenostarchimages672069.png.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![一个多边形的矩形边界](httpatomoreillycomsourcenostarchimages672069.png.jpg)'
- en: Figure 6-11. A polygon's rectangular bounds
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-11. 一个多边形的矩形边界
- en: 'We want to determine four values: the smallest latitude, the largest latitude,
    the smallest longitude, and the largest longitude. Because we have to start somewhere,
    we begin with the assumption that the first point is both minimum and maximum.
    That''s simply so we have something to compare.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确定四个值：最小的纬度，最大的纬度，最小的经度，以及最大的经度。因为我们必须从一个地方开始，所以我们首先假设第一个点既是最小值也是最大值。这样做只是为了让我们有东西可以比较。
- en: Then, beginning with the second point (which has an index of one because JavaScript
    array indexes start at zero), we loop through all the other points ❶. Each time
    through the loop, we check whether we have found new minimum or maximum values.
    For example, if the current point has a latitude greater than what we currently
    think is the maximum ❷, then we need to set the maximum to be this value ❸.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从第二个点开始（因为JavaScript数组索引从零开始，所以它的索引为1），我们遍历所有其他点❶。每次循环中，我们检查是否找到了新的最小值或最大值。例如，如果当前点的纬度大于我们目前认为的最大值❷，那么我们需要将最大值设置为这个值❸。
- en: Once we have completed the loop, the four values will be correct. Those values
    represent the corners of a `BoundingBox`. The SW corner is made up of the minimum
    values, the NE corner of the maximum. We can create the `BoundingBox` and return
    it for use elsewhere ❹.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成循环，四个值将正确无误。这些值代表`BoundingBox`的四个角。西南角由最小值组成，东北角由最大值组成。我们可以创建`BoundingBox`并将其返回以供其他地方使用❹。
- en: Now that we have the bounds, we can check whether a point is within the polygon
    with the simple rectangle that surrounds our polygon. I covered this in detail
    earlier, and I'll demonstrate it again in a few sections when we perform the complete
    hit test.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了边界，我们可以通过围绕我们的多边形（简单矩形）来检查一个点是否在多边形内部。我之前已经详细介绍了这个方法，我将在接下来的几个部分再次演示，当我们执行完整的碰撞测试时。
- en: Connect Our Point to an Outside Point
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的点连接到外部点
- en: Okay, if we've gotten this far, we've determined that our point is inside the
    polygon's bounding box. This doesn't mean the point is within the polygon itself,
    but it's at least nearby. In our Utah example, our point is in the very northeast
    corner of the bounding box, but not inside the Utah polygon.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，如果我们已经走到这一步，我们就已经确定我们的点在多边形边界框内。这并不意味着这个点在多边形内部，但至少它附近。在我们的犹他州例子中，我们的点位于边界框的非常东北角，但不在犹他州多边形内部。
- en: Now the tricky stuff begins, but within this trickery, you'll find simplicity.
    We need to make a temporary line for testing. This line connects our point (the
    one that may be inside the polygon) to a point that we can guarantee is outside
    the polygon.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始有点棘手了，但在这个小把戏中，你会发现简单性。我们需要为测试制作一条临时线。这条线连接我们的点（可能位于多边形内部）到一个我们可以保证在多边形外部的点。
- en: When we draw the temporary line, it may intersect the line segments that make
    up our polygon. If the lines crosses the polygon an odd number of times, our point
    is inside. If it crosses the polygon an even number of times, or not at all, our
    point is outside. [Figure 6-12](ch06s10.html#polygon_representing_utah_only_intersect
    "Figure 6-12. Polygon representing Utah only intersected once—the point is inside
    the shape.") provides a visual of the Utah example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制临时线时，它可能会与组成我们的多边形的线段相交。如果线条与多边形相交奇数次，则我们的点在内部。如果它以偶数次或根本不相交，则我们的点在外部。[图6-12](ch06s10.html#polygon_representing_utah_only_intersect
    "图6-12. 仅表示犹他州的多边形只与形状相交一次——该点位于形状内部")提供了犹他州示例的视觉表示。
- en: '![Polygon representing Utah only intersected once—the point is inside the shape.](httpatomoreillycomsourcenostarchimages672071.png.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![仅表示犹他州的多边形只与形状相交一次——该点位于形状内部](httpatomoreillycomsourcenostarchimages672071.png.jpg)'
- en: Figure 6-12. Polygon representing Utah only intersected once—the point is inside
    the shape.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-12. 仅表示犹他州的多边形只与形状相交一次——该点位于形状内部。
- en: The hit test is only conclusive if we can guarantee the new point we create
    will be outside the polygon. How can we do that? We'll create a latitude for our
    new point that is less than the SW latitude.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们能保证我们创建的新点将位于多边形外部时，碰撞测试才是确定的。我们如何做到这一点？我们将为新点创建一个纬度，该纬度小于西南纬度。
- en: 'If the point we''re testing is called `mypt` and our `BoundingBox` is called
    `box`, here''s the code to create our testing point:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试的点称为`mypt`，我们的`BoundingBox`称为`box`，以下是创建我们的测试点的代码：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We don't need to move very far outside the bounding box. To determine how much
    to change the latitude, I took the number of degrees between the SW and NE ❶ and
    divided by 100\. In the case of Utah, our new point would be 0.05 degrees below
    the southern border. The smaller the difference between north and south latitudes,
    the closer the new point will be to the bounding box—but the point will always
    be outside of the box.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要移动到边界框外面很远。为了确定纬度需要改变多少，我取了西南和东北之间的度数差❶，然后除以100。在犹他州的情况下，我们的新点将位于南部边界下方0.05度。南北纬度之间的差异越小，新点就越接近边界框——但该点始终位于框外。
- en: For the longitude of the new point, I set it to be the same as the longitude
    of the point we're checking. That decision was arbitrary, as any longitude would
    create a point outside the bounding box, because the latitude is less than the
    box's smallest latitude.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新点的经度，我将其设置为与我们要检查的点的经度相同。这个决定是随意的，因为任何经度都会创建一个位于边界框外的点，因为纬度小于框的最小纬度。
- en: Check for Line Intersections
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查线段交点
- en: Now we have a bounding box and a point outside the box that can be connected
    with the point we want to test. The final step is to determine how many times
    the line connecting those two points crosses the polygon. To do this, we need
    to know how to check whether two lines intersect.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个边界框和一个位于框外的点，我们可以将这个点与我们要测试的点连接起来。最后一步是确定连接这两个点的线与多边形相交的次数。为此，我们需要知道如何检查两条线是否相交。
- en: The code becomes a little confusing because there are many variables, despite
    only working with two line segments. We have four separate points or eight different
    values. From two to four to eight. Like I said, things become confusing quickly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有两个线段，但变量很多，代码变得有些混乱。我们有四个单独的点或八个不同的值。从两个到四个到八个。就像我说的，事情很快就会变得混乱。
- en: 'Add in a little vector math (based on a solution written in Visual Basic and
    available at [http://www.vb-helper.com/howto_segments_intersect.html](http://www.vb-helper.com/howto_segments_intersect.html)),
    and the code starts to look complicated. Here is the JavaScript code to test whether
    a line segment from point A to B intersects with another from point C to D:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 加入一点向量数学（基于用Visual Basic编写的解决方案，可在[http://www.vb-helper.com/howto_segments_intersect.html](http://www.vb-helper.com/howto_segments_intersect.html)找到）后，代码开始变得复杂。以下是测试从点A到B的线段是否与从点C到D的另一个线段相交的JavaScript代码：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first thing the code does is calculate how far away the ends of each line
    are, such as the distance between the latitudes of point A and B ❶. These values
    become the foundation of the vector computations that will determine whether the
    lines intersect.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先计算每条线段的端点距离，例如点A和B的纬度之间的距离❶。这些值成为确定线是否相交的向量计算的基础。
- en: With just the latitude and longitude distances, we can make sure the lines aren't
    parallel ❷. Determining this saves us further computation because parallel lines
    will never intersect. More importantly, we won't divide by zero with our first
    segment test ❸.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用纬度和经度距离，我们可以确保线不平行 ❷。确定这一点可以节省我们进一步的计算，因为平行线永远不会相交。更重要的是，我们不会在第一个线段测试中除以零
    ❸。
- en: The `segtest1` and `segtest2` variables compare line AB to CD, then vice versa.
    The value determines where the two lines intersect. Because they aren't parallel,
    they *will* intersect somewhere. If both of the segment tests are between 0 and
    1 ❹, then we know the intersection happens within our line segments.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`segtest1` 和 `segtest2` 变量比较线段 AB 和 CD，然后反过来。值决定了两条线的交点。因为它们不平行，它们*将*在某处相交。如果两个线段测试都在
    0 和 1 之间 ❹，那么我们知道交点发生在我们的线段内。'
- en: Perform the Hit Test
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行碰撞测试
- en: At this point, we've found the bounding box of the polygon, drawn a line from
    the point outside the polygon to our point in question, and learned how to determine
    whether two line segments intersect. Do you feel like we've lost track of the
    original plan to find out whether our point is within the polygon? Okay then,
    let's put it all together and perform the hit test.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经找到了多边形的边界框，从多边形外的点到我们关注的点画了一条线，并学会了如何确定两个线段是否相交。你是否觉得我们已经失去了找到点是否在多边形内的原始计划？好吧，那么让我们把所有这些都放在一起，执行碰撞测试。
- en: Remember our point is within the polygon if the line that we created intersects
    an odd number of lines that make up the polygon. We'll need to test each and every
    segment against our line that we know at least *starts* outside the polygon.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我们所创建的线与构成多边形的线相交的次数是奇数，那么我们的点就在多边形内。我们需要将每个线段与我们的线进行测试，我们知道至少*开始*在多边形外。
- en: 'Here is the function, using the pieces we''ve put together earlier in this
    project, to determine whether a point is within a polygon:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是函数，使用我们在本项目中早期组合的组件来确定点是否在多边形内：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The hit test function is passed the point to check and the array of points that
    make up the polygon. From the latter, we're able to determine the bounding box
    of the polygon ❶. Then, of course, we don't have to do anything unless our point
    is within this box ❷. The point cannot be within the polygon if it isn't within
    the polygon's bounds.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞测试函数接收要检查的点以及构成多边形的点的数组。从后者，我们能够确定多边形的边界框 ❶。当然，除非我们的点在这个框内 ❷，否则我们不需要做任何事情。如果点不在多边形的边界内，它就不在多边形内。
- en: Now we're ready to check whether the point is inside the polygon. To do this,
    we create a temporary line between our point and a point outside the bounding
    box ❸. Then we need to check where this line intersects with the polygon. To do
    this, we'll loop through the polygon's points ❹, checking for intersections with
    this temporary line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备检查点是否在多边形内。为此，我们在我们的点和边界框外的点之间创建一条临时线 ❸。然后我们需要检查这条线与多边形的交点。为此，我们将遍历多边形的点
    ❹，检查与这条临时线的交点。
- en: Each time through the loop, we make two line segments from four points. The
    first segment is made from two consecutive points from the polygon. The other
    segment is created with our point and the point we found outside the bounding
    box.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环，我们从四个点制作两个线段。第一个线段是由多边形中的两个连续点组成的。另一个线段是用我们的点和我们在边界框外找到的点创建的。
- en: We pass these points to the function we created to check for intersections ❺.
    If the two segments cross, we increase the intersection count. Either way, we
    then move on to the next trip through the loop.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些点传递给创建的函数以检查交点 ❺。如果两个线段相交，我们增加交点计数。无论如何，我们接着进行循环的下一轮。
- en: When the loop finishes, we'll know whether our point is within the polygon.
    If the intersection count is odd, the point is inside. If the count is even, our
    point is outside. A number is odd if, when dividing it by two, you have a remainder
    of one. The modulus operator, `%`, gives us the remainder ❻. A remainder means
    we have an odd number of intersections, and we return true because the point is
    within the polygon. In all other cases, we return false because the point is not
    within the polygon.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环结束时，我们将知道我们的点是否在多边形内。如果交点计数是奇数，则点在内部。如果计数是偶数，则我们的点在外部。一个数是奇数，如果除以二时余数为 1。取模运算符
    `%` 给我们余数 ❻。余数意味着我们有奇数个交点，我们返回 true 因为点在多边形内。在所有其他情况下，我们返回 false 因为点不在多边形内。
- en: You Clicked in Utah!
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你在犹他州点击了！
- en: Now that we're able to check whether a point is within a polygon, let's incorporate
    it into a map. At the beginning of this chapter, we created a series of points
    shaped like the state of Utah. We'll use that, along with all the other code shown
    so far, to report whether the user has clicked inside the polygon described by
    the `utah` variable.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够检查一个点是否在多边形内，让我们将其整合到地图中。在本章的开头，我们创建了一系列形状像犹他州的多点。我们将使用这些点，以及到目前为止展示的所有其他代码，来报告用户是否点击了由`utah`变量描述的多边形内部。
- en: 'Create a basic map and add in the polygon points. We''ll need the functions
    we''ve created so far, too. Make sure to include the `check_polygon`, `check_intersection`,
    and `points_to_bounds` functions. Then add the following code, replacing the `create_map`
    function that already exists:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的地图并添加多边形点。我们还需要之前创建的函数。确保包括`check_polygon`、`check_intersection`和`points_to_bounds`函数。然后添加以下代码，替换已经存在的`create_map`函数：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first few lines create the new map, center it on Utah, and add zoom controls.
    Then we need to wait for the user to click somewhere on the map ❶. When is the
    user clicks, we initiate an inline, anonymous function, with the click point passed
    as an argument, as shown in [#27: The User Clicks the Map](ch05s02.html "#27:
    The User Clicks the Map") in [#27: The User Clicks the Map](ch05s02.html "#27:
    The User Clicks the Map").'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '前几行创建了一个新的地图，将其中心定位在犹他州，并添加了缩放控件。然后我们需要等待用户在地图上的某个位置点击 ❶。当用户点击时，我们初始化一个内联的匿名函数，将点击点作为参数传递，如[第27节：用户点击地图](ch05s02.html
    "#27: The User Clicks the Map")中所示。'
- en: The difficult work of checking for whether a point is within a polygon is passed
    off to the `check_polygon` function. This function, which we wrote in a previous
    section, returns either `true` or `false`. If the function returns true ❷, we
    create a text variable to tell the user "You clicked in Utah!" Otherwise, the
    user gets a message saying "That's not Utah!"
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个点是否在多边形内的困难工作被传递给了`check_polygon`函数。这个函数，我们在前面的部分中编写过，返回`true`或`false`。如果函数返回`true`
    ❷，我们创建一个文本变量来告诉用户“你点击在犹他州内！”否则，用户会收到一条消息说“那不是犹他州！”
- en: Now we need to report the click and the outcome. We do this by creating a marker
    at the click point ❸ and putting the text inside a message box. Then we add the
    marker to the page and open the message box.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要报告点击和结果。我们通过在点击点创建一个标记 ❸ 并将文本放入消息框中来实现这一点。然后我们将标记添加到页面并打开消息框。
- en: Try it out for yourself or see [Figure 6-13](ch06s10.html#you_can_apostrophy_t_trick_mathmthat_poi
    "Figure 6-13. You can't trick math—that point is outside of Utah!"). See if you
    can trick the test by clicking in the NE corner of the state, where Wyoming appears
    to intrude into Utah's bounding box. Sure enough, if you click outside of Utah,
    you'll see the correct message. Ditto when clicking inside of Utah. The hit test
    gets the right answer every time.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己操作或查看[图6-13](ch06s10.html#you_can_apostrophy_t_trick_mathmthat_poi "图6-13.
    你无法欺骗数学——那个点在犹他州之外！")。看看你是否能通过在州东北角点击（看起来怀俄明州似乎侵入了犹他州的边界框）来欺骗测试。确实如此，如果你点击在犹他州之外，你会看到正确的信息。在点击在犹他州内部时也是如此。每次击中测试都会得到正确答案。
- en: '![You can''t trick math—that point is outside of Utah!](httpatomoreillycomsourcenostarchimages672073.png.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![你无法欺骗数学——那个点在犹他州之外！](httpatomoreillycomsourcenostarchimages672073.png.jpg)'
- en: Figure 6-13. You can't trick math—that point is outside of Utah!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-13. 你无法欺骗数学——那个点在犹他州之外！
- en: '#46: Get Nearest Locations from Your Own Database'
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#46: 从您的数据库中获取最近的位置'
- en: 'Earlier in this chapter, I showed how to calculate the distance between two
    points and how to determine the closest marker to a point. Arguably more useful
    is what we''ll be doing in this project: getting the nearest location to a point
    from a list of many possibilities stored in a database.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我展示了如何计算两点之间的距离以及如何确定点到最近标记的位置。更有用可能是我们将在本项目中做的事情：从一个存储在数据库中的许多可能性列表中获取到点的最近位置。
- en: 'To look up locations in a database, we need to have something in the database
    in the first place. For this example, we''ll use the database table from [#63:
    Store Locations to a Database](ch09s05.html "#63: Store Locations to a Database")
    in [Install MySQL Yourself](ch09s04.html#install_mysql_yourself "Install MySQL
    Yourself"). Although we''re using MySQL as an engine, most databases will work
    with the SQL statements here. *Structured query language (SQL)* is a syntax to
    communicate with a database server.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '要在数据库中查找位置，我们首先需要在数据库中有一些内容。在这个例子中，我们将使用 [安装 MySQL 自己](ch09s04.html#install_mysql_yourself
    "安装 MySQL 自己") 中的 [第 63 节：将商店位置存储到数据库](ch09s05.html "#63: Store Locations to a
    Database") 的数据库表。尽管我们使用 MySQL 作为引擎，但大多数数据库都可以与这里的 SQL 语句一起工作。*结构化查询语言 (SQL)* 是与数据库服务器通信的语法。'
- en: Because we're looking for the nearest locations to a single point, we need to
    determine what that point is. I've chosen a point near me in Portland, Oregon,
    with a latitude of 45.517 and a longitude of −122.649\. Now we'll plug this into
    the Haversine formula—that's the same bit of trigonometry we used in JavaScript,
    but this time we'll use SQL.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在寻找离单个点最近的位置，我们需要确定那个点是什么。我选择了一个位于俄勒冈州波特兰附近、纬度为 45.517、经度为 −122.649 的点。现在我们将这个点代入
    Haversine 公式——这是我们在 JavaScript 中使用的相同三角函数，但这次我们将使用 SQL。
- en: 'From either the MySQL command interpreter or phpMyAdmin, type the following
    query:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MySQL 命令解释器或 phpMyAdmin 中，输入以下查询：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We select all the fields from the places table, plus an additional field, as
    described by the entire section in bold. That's a lot of code! It calculates the
    distance between our point and the points in the database using the latitude and
    longitude values stored with each place.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 places 表中选择了所有字段，以及一个额外的字段，正如粗体部分所描述的那样。这需要很多代码！它通过使用每个地点存储的纬度和经度值来计算我们的点与数据库中点的距离。
- en: 'The distance, which becomes a column named `dist`, is expressed in kilometers.
    As with the previous implementation of the Haversine formula, we multiply by the
    radius of the earth, which is 6371 km. For miles, replace the number ❶ with its
    mile equivalent: 3958.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 距离，成为名为 `dist` 的列，以公里为单位表示。与之前实现的 Haversine 公式一样，我们乘以地球半径，即 6371 公里。对于英里，将数字
    ❶ 替换为其英里等价值：3958。
- en: When you run this SQL query, your results will be the same as those shown in
    [Table 6-2](ch06s11.html#results_of_nearest_place_sql "Table 6-2. Results of Nearest
    Place SQL"). Because we ordered by the distance, the places nearest to our point
    come first in the table. Therefore, the nearest place to the point we selected
    is Old Faithful.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个 SQL 查询时，你的结果将与 [表 6-2](ch06s11.html#results_of_nearest_place_sql "表 6-2.
    Nearest Place SQL 的结果") 中显示的结果相同。因为我们按距离排序，所以离我们的点最近的地点在表中排在前面。因此，离我们选择的点最近的地方是
    Old Faithful。
- en: Table 6-2. Results of Nearest Place SQL
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2. Nearest Place SQL 的结果
- en: '| ID | Name | Latitude | Longitude | Distance |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| ID | 名称 | 纬度 | 经度 | 距离 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | Old Faithful Geyser | 44.4605 | − 110.828 | 936.12 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Old Faithful Geyser | 44.4605 | − 110.828 | 936.12 |'
- en: '| 2 | St. Louis Arch | 38.6247 | − 90.1851 | 2765.97 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 圣路易斯拱门 | 38.6247 | − 90.1851 | 2765.97 |'
