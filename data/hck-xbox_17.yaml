- en: Appendix D -
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录D -
- en: Getting Started with FPGAs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用FPGA
- en: Integration is the bane of hardware hackers. We like to take things apart, modify
    them, and improve them, but the trend has been to cram everything into one or
    two ASICs (Application Specific Integrated Circuit). This kind of integration
    is out of the reach of mere mortals, as the cost of a set of masks used for defining
    the features on chips is rapidly approaching one million dollars. That’s one million
    dollars *per unique* *revision* of the chip. If a mistake is made that requires
    a new mask set, you have to spend yet another million dollars to fix it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 集成是硬件黑客的噩梦。我们喜欢拆解东西，修改它们，并改进它们，但趋势是将一切塞入一个或两个ASIC（专用集成电路）中。这种集成对于普通人来说遥不可及，因为用于定义芯片上特征的掩模套件的成本正迅速接近一百万美元。这是一百万美元的*每个独特*
    *修订版*的芯片。如果犯了一个需要新掩模套件的错误，你必须再花一百万美元来修复它。
- en: Fortunately, a million dollars cash upfront for a chip is too much even for
    many corporations, and this has created a market for FPGAs — general-purpose,
    programmable (“reconfigurable”) hardware devices that can be used in place of
    an ASIC in many applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，即使是许多公司，一开始就投入一百万美元现金购买芯片也太多了，这为FPGA创造了一个市场——通用、可编程（“可重构”）的硬件设备，可以在许多应用中替代ASIC。
- en: '**What Is an FPGA?**'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**什么是FPGA？**'
- en: FPGA stands for field programmable gate array. In other words, it is an array
    of gates that can be programmed in the field by end users. You can think of FPGAs
    as custom silicon that you can build in the comfort of your own home, although
    the trend toward partial reconfigurability and context-sensitive reconfiguration
    adds a dimension to FPGAs that is not found in ASICs. While ASICs are cheaper
    per unit in volume, and they can have much higher clock speed performance, FPGAs
    have established themselves as the tool of choice for low to moderate volume applications
    and for prototyping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA代表现场可编程门阵列。换句话说，它是由用户在现场编程的门阵列。你可以将FPGA想象成可以在家中舒适构建的定制硅芯片，尽管向部分可重构和上下文相关重构的趋势为FPGA增加了一个在ASICs中找不到的维度。虽然ASICs在大量生产中每单位成本更低，并且它们可以具有更高的时钟速度性能，但FPGA已经确立了自己作为低到中等产量应用和原型设计的首选工具。
- en: The FPGA’s basic architecture is that of an array of hardware primitives embedded
    in a flexible routing network. The power of the FPGA comes from the fact that
    complex computations can be broken down into a sequence of simpler logic functions.
    These simpler functions can each be broken down in turn, until the entire computation
    is described by nothing more than a sequence of basic logic operations that can
    be mapped into the FPGA’s hardware primitives. Thus, the same FPGA can be used
    to implement a microprocessor, a video controller, or a tic-tac-toe game just
    by changing the configuration of the hardware primitives and the routing network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA的基本架构是在一个灵活的布线网络中嵌入的硬件原语数组。FPGA的力量在于复杂计算可以被分解成一系列更简单的逻辑函数。这些更简单的函数可以依次分解，直到整个计算仅由可以映射到FPGA硬件原语的基本逻辑操作序列来描述。因此，相同的FPGA可以通过改变硬件原语和布线网络的配置来实现微处理器、视频控制器或井字棋游戏。
- en: 'The kinds of hardware primitives implemented by an FPGA architecture strongly
    influence the FPGA’s implementation efficiency for a given target application.
    Modern FPGAs provide designers with mostly one bit wide primitives: a 4 or 5 input
    to 1-bit output lookup table, and a single bit of time-synchronized storage known
    as a flip flop. Lookup tables are used as the logic primitive because they can
    be programmed to perform any logic operation with as many terms as there are inputs
    to the lookup table. These primitives are then wired into a vast programmable
    network of wires; a typical high-end FPGA might have many tens of thousands of
    these primitive elements.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA架构实现的硬件原语类型强烈影响了FPGA针对特定目标应用的实现效率。现代FPGA为设计师提供了主要是单比特宽的原语：一个4或5输入到1比特输出的查找表，以及一个称为触发器的时间同步存储位。查找表被用作逻辑原语，因为它们可以被编程执行任何逻辑操作，其术语数量与查找表的输入数量相同。然后，这些原语被连接到一个庞大的可编程网络中；一个典型的高端FPGA可能有数万这些原语元素。
- en: It turns out that while single bit-wide structures are very general, they can
    be very resource-inefficient in applications where the natural data width is large.
    In particular, the area dedicated to the actual logic primitives is around 1 percent
    in many cases, with the remainder being configuration memory and interconnect.
    All of this wire is required to handle the many routing permutations that you
    might require for single-bit wide applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，虽然单比特宽的结构非常通用，但在自然数据宽度大的应用中，它们可能非常资源低效。特别是，实际逻辑原语所分配的面积在许多情况下约为1%，其余部分是配置存储器和互连。所有这些电线都是必需的，以处理你可能需要的许多单比特宽应用的布线排列。
- en: '![figure_d-1](../Images/figure_d-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![figure_d-1](../Images/figure_d-1.png)'
- en: '**Figure D-1**: Block diagram of a typical FPGA structure, illustrating the
    disparity between the amount of wire on an FPGA versus the amount of computational
    logic. A typical modern FPGA will contain several tens of thousands of these basic
    cells.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**图D-1**：典型FPGA结构的框图，说明了FPGA上的电线数量与计算逻辑数量之间的差异。一个典型的现代FPGA将包含数万个这样的基本单元。'
- en: 'In order to boost area efficiency, many FPGAs also include a few coarse-grain
    primitives, such as chunks of RAM or a multiplier block. Xilinx’s Virtex II-Pro
    FPGAs even include several PowerPC cores on-chip. While this sounds impressive,
    the actual area consumed by such a core is surprisingly small: A PowerPC processor
    probably consumes a little more than 1mm2 of silicon area, whereas the area of
    the FPGA is hundreds of square millimeters.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高面积效率，许多FPGA还包含一些粗粒度原语，例如RAM块或乘法器块。Xilinx的Virtex II-Pro FPGA甚至包含几个片上PowerPC核心。虽然这听起来很令人印象深刻，但这样的核心实际占用的面积出人意料地小：PowerPC处理器可能占用略多于1mm²的硅面积，而FPGA的面积是数百平方毫米。
- en: The most recent FPGAs on the market have very flexible I/Os in addition to having
    very flexible computational hardware. A typical FPGA can interface to all of the
    most popular high-speed signaling standards, including PCI, AGP, LVDS, HSTL, SSTL,
    and GTL. In addition, most FPGAs can handle DDR clocked signals as well. In case
    those acronyms didn’t mean anything to you, the basic idea is that an FPGA can
    be used to talk to just about any piece of hardware you might find on a typical
    PC motherboard, such as the Xbox. This is extremely good news to hardware hackers,
    because it means that an FPGA can be used to emulate or monitor almost any chip
    found in a PC. (Of course, the PC may have to be down-clocked in cases where the
    FPGA cannot keep up with the speed of the PC.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上最新的FPGA除了拥有非常灵活的计算硬件外，还拥有非常灵活的I/O接口。一个典型的FPGA可以与所有最流行的高速信号标准进行接口，包括PCI、AGP、LVDS、HSTL、SSTL和GTL。此外，大多数FPGA还可以处理DDR时钟信号。如果这些缩写对你来说没有意义，基本想法是FPGA可以用来与典型PC主板上的几乎所有硬件进行通信，例如Xbox。这对硬件黑客来说是个极好的消息，因为这意味着FPGA可以用来模拟或监控PC中找到的几乎所有芯片。（当然，如果FPGA无法跟上PC的速度，PC可能需要降低时钟频率。）
- en: '**Designing for an FPGA**'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**为FPGA设计**'
- en: You have a number of design entry options to choose from for a typical FPGA
    design flow. If you prefer to think graphically, most design flows support a schematic-capture
    tool. While schematic capture is often more intuitive for hardware designs, they
    can be more difficult to maintain and modify. For example, changing al instances
    of a net name can be tedious if you have to click on every wire and type in the
    new name. Furthermore, the size of any single level of design hierarchy is limited
    to the size of a schematic sheet, so a complex design will require a good deal
    of planning and forethought for just the schematic capture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的FPGA设计流程，您有许多设计输入选项可供选择。如果您喜欢图形化思考，大多数设计流程都支持原理图捕获工具。虽然原理图捕获对于硬件设计来说通常更直观，但它们可能更难以维护和修改。例如，如果您必须点击每根电线并输入新名称，更改所有实例的网名可能很繁琐。此外，任何单一设计层次级别的尺寸限制为原理图纸的尺寸，因此复杂设计需要大量的计划和前瞻性思考，仅用于原理图捕获。
- en: As a result, hardware description languages (HDLs) are the tool of choice for
    implementing complex designs. HDLs look very similar at first glance to normal
    programming languages. For example, the syntax of Verilog looks very similar to
    that of C or Java. However, the semantics of the language can be a bit of a challenge
    to understand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，硬件描述语言（HDLs）是实现复杂设计的首选工具。HDLs乍一看与常规编程语言非常相似。例如，Verilog的语法看起来与C或Java非常相似。然而，语言的语义可能有点难以理解。
- en: Hardware has an inherent parallelism that procedural languages such as C cannot
    express. If you think about it, every gate and every flip flop on an FPGA can
    compute in parallel, whereas in a C program, a single thread of execution is nominally
    assumed. As a result, HDLs represent hardware as a collection of processes that
    operate in parallel; it is up to the coder to group all of the functions into
    the correct processes so that the compiler can understand how to turn a process
    into gates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件具有固有的并行性，而像C这样的过程式语言无法表达。如果你仔细想想，FPGA上的每一个门和每一个触发器都可以并行计算，而在C程序中，通常假设只有一个执行线程。因此，硬件描述语言（HDLs）将硬件表示为一系列并行操作的过程；程序员需要将这些函数分组到正确的进程中，以便编译器能够理解如何将一个过程转换为门。
- en: '![figure_d-2](../Images/figure_d-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![figure_d-2](../Images/figure_d-2.png)'
- en: '**Figure D-2:** Typical FPGA design flow.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图D-2：典型的FPGA设计流程**。'
- en: 'For example, a single clocked storage element (a flip-flop) in Verilog is a
    “process” that typically has a structure similar to this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Verilog中一个单时钟存储元件（触发器）是一个“过程”，其结构通常如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code takes the value on input port inData, and on every rising clock edge,
    stores inData in a flip flop whose output is called bitOfStorage. Multiple processes
    delimited by always @( ... ) begin ... end syntax can exist in a single design,
    and all processes execute in parallel. Combinational logic can also be expressed
    as a process. For example, the following Verilog code implements a two-input multiplexer
    that has no clock:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从输入端口inData获取值，并在每个上升沿时钟边沿，将inData存储在一个输出称为bitOfStorage的触发器中。单个设计中可以存在由always
    @( ... ) begin ... end语法分隔的多个过程，并且所有过程都并行执行。组合逻辑也可以表示为过程。例如，以下Verilog代码实现了一个无时钟的两个输入多路复用器：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, the contents of the parenthesized block following the always
    keyword contains a *sensitivity list* that includes all of the inputs that might
    affect the output. Leaving a parameter out of the sensitivity list means that
    the output will not change, even if that parameter changes. For example, if you
    omitted a and b from the sensitivity list, then the only time the output would
    change would be when select changed: you would have built a latch that stores
    either a or b depending upon the state of select. However, the desired operation
    of a multiplexer is to relay changes on either a or b to the output at al times,
    even when select does not transition, so a and b must both be part of the sensitivity
    list.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，always关键字后面的括号内包含的*sensitivity list*包含了可能影响输出的所有输入。从sensitivity list中省略一个参数意味着即使该参数发生变化，输出也不会改变。例如，如果你从sensitivity
    list中省略了a和b，那么输出只会改变当select改变时：你会构建一个存储器，根据select的状态存储a或b。然而，多路复用器期望的操作是在任何时候都将a或b的变化传递到输出，即使select没有转换，所以a和b都必须是sensitivity
    list的一部分。
- en: There are a number of subtleties when learning an HDL that are beyond the scope
    of this book, but the two code segments above should give you a flavor for what
    to expect. A skilled software programmer may have more trouble adjusting to an
    HDL than a novice, because many software tricks that are taken for granted translate
    very poorly to direct hardware implementation. Arrays, structures, multiplication,
    and division primitives are all taken for granted in the software world, but each
    of these constructs translate to potentially large and inefficient blocks of hardware.
    Furthermore, in a hardware implementation, all possible cases in a case statement
    exist whether or not you intend for it; neglecting to fully specify a case statement
    with a default case often means that extra hardware will be synthesized to handle
    the implicit cases. Numerous tutorials and syntax reference manuals for Verilog
    are indexed in Google; verilog syntax and verilog tutorial are both good sets
    of keywords to start out with when searching for syntax references or tutorials.
    Xilinx’s website also has a good Verilog reference for FPGA designers, and Sutherland
    HDL, Inc. has a free Verilog quick reference guide at http://www.sutherland-hdl.com/on-line_ref_guide/vlog_ref_body.html.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习HDL时，有一些细微之处超出了本书的范围，但上面两个代码段应该能让你对预期有所了解。熟练的软件程序员可能比新手更难适应HDL，因为许多在软件世界中视为理所当然的技巧在直接硬件实现中转换得非常差。数组、结构、乘法和除法原语在软件世界中都是理所当然的，但每个这些结构都转换成可能很大且效率低下的硬件块。此外，在硬件实现中，case语句中的所有可能情况都存在，无论你是否有意为之；忽略为默认情况完全指定case语句通常意味着将生成额外的硬件来处理隐含的情况。Google上索引了大量的Verilog教程和语法参考手册；verilog语法和verilog教程都是搜索语法参考或教程时的好关键词集。Xilinx的网站也提供了针对FPGA设计者的良好的Verilog参考，Sutherland
    HDL公司在其网站http://www.sutherland-hdl.com/on-line_ref_guide/vlog_ref_body.html上提供了一份免费的Verilog快速参考指南。
- en: '**Overclocking FPGA Designs**'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**FPGA超频设计**'
- en: It is worth noting that the timing models used for an FPGA are quite conservative.
    This means that it is quite likely that an FPGA will operate properly at frequencies
    much higher than the timing analyzer will admit. In fact, careful hand-layout
    of an FPGA’s logic can stretch the performance of the FPGA much further than its
    stated specifications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，用于FPGA的时序模型相当保守。这意味着FPGA在比时序分析仪允许的频率更高的频率下正常工作是非常可能的。实际上，对FPGA逻辑进行仔细的手动布局可以将FPGA的性能提升到其标称规格之外。
- en: For example, the FPGA (Xilinx Virtex-E) used to implement the Xbox Hypertransport
    bus tap is only specified to handle data rates of around 200 Mbits/s/pin, but
    the application demanded 400 Mbits/s/pin. The reason I could pull this off is
    that the actual logic and storage elements can run very fast, but most of the
    performance is burned off in the wires and repeaters that carry the signals between
    logic elements. Specifically, some wires will have so much delay at 400 Mbits/s
    that they effectively store data for a single clock cycle.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于实现Xbox Hypertransport总线插件的FPGA（Xilinx Virtex-E）仅指定可以处理大约200 Mbits/s/pin的数据速率，但应用要求400
    Mbits/s/pin。我能实现这一点的原因是实际的逻辑和存储元件可以非常快地运行，但大部分性能都消耗在携带信号之间的线缆和重复器上。具体来说，一些线在400
    Mbits/s下的延迟会很大，以至于它们实际上存储了一个时钟周期的数据。
- en: I determined which wires were slower than the rest by capturing a sequence of
    data and comparing it against a pattern that I had previously discovered using
    an oscilloscope. Once the slow paths were identified, I inverted the clock and/or
    inserted flip-flops on channels that had too little delay. The end result was
    a set of signals that were time-skew corrected. These signals could then be trivially
    demultiplexed to a lower clock rate where conventionally compiled HDL design techniques
    could be used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过捕获一系列数据并将其与之前使用示波器发现的模式进行比较，确定了哪些线比其他线慢。一旦确定了慢路径，我就反转了时钟和/或在延迟过小的通道上插入触发器。最终结果是得到一组经过时间偏移校正的信号。然后，这些信号可以简单地解复用到较低的时钟速率，在那里可以使用传统编译的HDL设计技术。
- en: 'While this technique is very powerful, it is not generally applicable because
    the amount of delay caused by a wire varies from chip to chip and can depend on
    parameters such as the ambient temperature and the quality of the power supply
    voltage. However, for one specific chip under controlled circumstances, I was
    able to get 2x the rated performance. Another important difference between this
    application and a more general application is that bit error rates on the order
    of 1 error in a few thousand was tolerable, since I could just take three traces
    and XOR them to recover any information lost to random noise sources. However,
    1 in 10,000 bit error rates are not acceptable for normal applications; unrecoverable
    error rates better than 1 in 10,000,000,000,000 are more typical. This all goes
    back to a saying that I have: “It is easy to do something once, but doing something
    a million times perfectly is hard.”'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这项技术非常强大，但它并不普遍适用，因为由于芯片之间的差异，导线引起的延迟量各不相同，并且可能取决于环境温度和电源电压质量等参数。然而，在可控条件下针对一个特定的芯片，我能够获得2倍于额定性能。与此应用相比，另一个重要区别是，在每几千个中发生1个错误的比特错误率是可以容忍的，因为我可以只取三个轨迹并使用XOR操作来恢复由于随机噪声源而丢失的任何信息。然而，对于正常应用来说，每10000个中有一个错误的比特错误率是不可接受的；比每10000000000000个中有一个错误更典型的不可恢复错误率要好。这一切都回到了我常说的一句话：“做一次事情很容易，但完美地做一百万次就很难了。”
- en: Another advantage of the HDL design entry approach is the availability of free
    and paid “softcores.” Websites such as www.opencores.org offer general-public
    licensed HDL cores for functions such as USB interfaces, DES and AES crypto-engines,
    and various microprocessors. In addition, almost every standard function is offered
    by third-party vendors who will sell you cores for a fee.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: HDL设计输入方法的另一个优点是免费和付费“软核”的可用性。例如，www.opencores.org等网站提供了一般公众许可的HDL核，用于USB接口、DES和AES加密引擎以及各种微处理器等功能。此外，几乎每个标准功能都由第三方供应商提供，他们将以费用出售核心。
- en: After design entry, I highly recommended that you simulate your design before
    compiling it into hardware. Trying to track down bugs by twiddling code, pushing
    it to hardware and probing for changes is very inefficient. Simulation allows
    you to probe any node of the circuit with the push of a button. In addition, the
    effort required to simulate a code change is very small, especially when compared
    to the effort of pushing a change all the way through to hardware.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在将设计编译成硬件之前，强烈建议你在设计输入后对其进行模拟。试图通过调整代码、将其推送到硬件并探测变化来追踪错误是非常低效的。模拟允许你通过按按钮来探测电路的任何节点。此外，模拟代码更改所需的工作量非常小，尤其是与将更改推送到硬件所需的工作量相比。
- en: Once the design has been entered and simulated, it needs to be compiled or translated
    into a common netlist format. This netlist format is fed into a program that maps
    the netlist primitives into the target FPGA hardware primitives, after which the
    mapped primitives are placed and routed. The resulting design is analyzed for
    compliance with a set of constraints specified by the designer. If the design
    does not meet the designer’s specifications, it is iteratively refined through
    successive place and route passes. Once the design passes its design constraints,
    it goes to a configuration bitstream generator where the internal representation
    of the FPGA is translated into a binary file that the FPGA can use to configure
    itself. (All of these steps happen fairly seamlessly at the touch of a button
    in the later versions of the FPGA design tools.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计已经输入并模拟，就需要将其编译或转换成通用的网表格式。这种网表格式被输入到一个程序中，该程序将网表原语映射到目标FPGA硬件原语，之后映射的原语被放置和布线。结果设计被分析以符合设计者指定的约束条件。如果设计不符合设计者的规格，则需要通过连续的放置和布线迭代进行改进。一旦设计通过了设计约束，它就会进入配置位流生成器，在那里FPGA的内部表示被转换成一个二进制文件，该文件可以被FPGA用来配置自己。（所有这些步骤在FPGA设计工具的后期版本中都可以通过按一个按钮相当无缝地完成。）
- en: '**Project Ideas**'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目想法**'
- en: Now that you know a little bit about what an FPGA is and how you can program
    them, what sorts of things can you do with them?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些关于FPGA是什么以及如何编程它们的知识，你可以用它们做什么呢？
- en: As it turns out, FPGAs have enough logic capacity and performance these days
    to accomplish a very impressive range of tasks. The obvious industrial application
    of FPGAs is in the emulation of designs intended for hard-wired silicon. The cost
    of building a custom chip has been skyrocketing, and it will soon be the case
    where a single critical mistake can cost hundreds of thousands of dollars, if
    not millions, to fix.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，如今FPGA的逻辑容量和性能已经足够强大，可以完成非常令人印象深刻的任务范围。FPGA最明显的工业应用是在模拟为硬连线硅设计的电路。定制芯片的成本正在飞速上升，很快就会出现一个错误就能导致数十万美元，甚至数百万美元的修复费用。
- en: On the other hand, fixing a mistake made in an FPGA HDL description pretty much
    only costs time and design effort; you don’t throw away any parts, and you don’t
    have to buy any new parts. Thus, many companies have adopted the strategy of fully
    simulating a mock-up of the design in FPGAs before taping out the final silicon.
    A side benefit from this approach is that the software and hardware teams that
    are users of the custom silicon can begin validating their designs using the FPGA
    mock-up while the custom silicon is being fabricated; a process that can sometimes
    take a couple of months.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，修复FPGA HDL描述中的错误基本上只花费时间和设计努力；你不会丢弃任何部件，也不需要购买任何新部件。因此，许多公司已经采取了在最终硅片生产之前，在FPGA中完全模拟设计原型的策略。这种方法的一个附带好处是，使用定制硅片的软件和硬件团队可以在定制硅片制造的同时开始使用FPGA原型验证他们的设计；这个过程有时可能需要几个月的时间。
- en: 'For hackers, FPGAs are sort of a panacea for all kinds of complex projects.
    They are excellent choices for implementing cryptographic functions if you are
    interested in doing brute-force keysearches or encrypting large amounts of data
    quickly. They are also very useful for implementing signal processing functions,
    especially given the existence of free multiplier and digital filter cores. FPGAs
    can achieve higher performance for less power than a DSP, and thus they have a
    unique niche in applications such as battery-powered robotics. FPGAs are also
    useful for embedded controller applications: A small microprocessor core, equivalent
    to or better than a PIC, can easily fit in an FPGA today. Add all your custom
    hardware peripherals, such as a serial port and PWM timing generators, and you’re
    in business.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于黑客来说，FPGA似乎是各种复杂项目的万能药。如果你对进行暴力破解密钥搜索或快速加密大量数据感兴趣，FPGA是实施加密函数的绝佳选择。它们在实现信号处理功能方面也非常有用，特别是考虑到存在免费的乘数和数字滤波器核心。FPGA可以在比DSP更低的功耗下实现更高的性能，因此在电池供电的机器人等应用中拥有独特的市场空间。FPGA在嵌入式控制器应用中也很有用：今天的小型微处理器核心，相当于或优于PIC，可以轻松地集成到FPGA中。添加所有你的定制硬件外围设备，例如串行端口和PWM定时发生器，你就可以开始业务了。
- en: FPGAs are also useful in situations where the focus is not on big number crunching.
    An FPGA makes a great piece of glue logic in a tight spot, and well-placed FPGA
    can save you from having to ever add a wire jumper to patch a board due to a logic
    design error. FPGAs also make a cheap logic analyzer alternative for those of
    us who cannot afford a $10,000 Tek TLA mainframe. The high-speed I/O capabilities
    of the latest FPGAs combined with large autogenerated FIFO-configured embedded
    memories make short work of designing a signal capture and analysis system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA在那些不专注于大量数据处理的情况下也非常有用。在紧凑的空间中，FPGA可以作为一个出色的粘合逻辑，而且合理放置的FPGA可以让你免于因为逻辑设计错误而需要添加线跳线来修复电路板。对于无法负担1万美元Tek
    TLA主机的我们来说，FPGA也提供了一个廉价的逻辑分析仪替代品。最新FPGA的高速I/O能力与大型自动生成的FIFO配置嵌入式存储器相结合，使得设计信号捕获和分析系统变得轻而易举。
- en: Finally, FPGAs have applications in mixed-signal situations that are not immediately
    obvious. The most common mixed-signal application is probably using an FPGA to
    drive the analog signals of a VGA monitor. A couple of resistive dividers or a
    well-chosen output driver type is all you need, and al the timing and logic necessary
    to generate color images can be handled with logic inside the FPGA. FPGAs can
    also be trivially used as PWM D/A converters, or even as part of a sigma-delta
    D/A or A/D converters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，FPGA在混合信号情况下的应用可能并不立即明显。最常见的一种混合信号应用可能是使用FPGA来驱动VGA监视器的模拟信号。只需要几个电阻分压器或一个精心选择的输出驱动器类型，就可以处理生成彩色图像所需的所有时序和逻辑，这些都可以在FPGA内部的逻辑中完成。FPGA也可以简单地用作PWM
    D/A转换器，甚至可以作为sigma-delta D/A或A/D转换器的一部分。
- en: '**Where to Buy**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**购买渠道**'
- en: You’re probably thinking that any tool this versatile and powerful has to cost
    a fortune. While that was true about a decade ago, today you can buy 100,000 gate
    FPGAs for well under $50, and the design tools are often free for educational
    users and/or hobbyists.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这样多功能且强大的工具肯定要花费一大笔钱。虽然十年前是这样的，但如今你只需花费不到 50 美元就可以买到 10 万门的 FPGA，而且设计工具对于教育用户和/或爱好者通常是免费的。
- en: Of course, an FPGA on its own is not so useful; it needs to be mounted to a
    board with the proper connections in order to be used. To this end, a company
    cal ed XESS (www.xess.com) makes a line of fairly affordable FPGA starter kits.
    Their product line shifts as new FPGAs are introduced, but the current entry-level
    FPGA board is the XSA-50 board that comes with a 50,000 gate FPGA for about $150\.
    The board also includes a few megabytes of RAM, a parallel port, a VGA port, a
    PS/2 keyboard port, and a few other essential items.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单独的 FPGA 并不是那么有用；它需要安装到带有适当连接的板上才能使用。为此，一家名为 XESS（www.xess.com）的公司生产了一系列相对实惠的
    FPGA 入门套件。随着新 FPGA 的推出，其产品线会发生变化，但目前的入门级 FPGA 板是 XSA-50 板，它配备了一个 50,000 门的 FPGA，售价约为
    150 美元。该板还包括几兆字节的 RAM、并行端口、VGA 端口、PS/2 键盘端口以及其他一些基本设备。
- en: The other option is to build your own board from scratch, if you’re feeling
    bold. Other appendices in this book describe how to get into board layout and
    fabrication and how to attach fine-pitched FPGA devices to your boards. It is
    actually quite rewarding to try to build your own boards, and I recommend giving
    it a try; the cost of fabricating a board is well below $100 these days, so you
    don’t lose too much even if your board doesn’t work in the end.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是如果你有勇气，从头开始自己制作板。本书的其他附录描述了如何进入板布局和制造以及如何将细间距 FPGA 设备连接到你的板上。实际上，尝试自己制作板是非常有成就感的，我建议你尝试一下；如今，制作板的成本远远低于
    100 美元，所以即使你的板最终不起作用，你也不会损失太多。
- en: If you are making your own board, you will need to buy your FPGA from a Xilinx
    distributor. The Xilinx webpage (www.xilinx.com) has the most up-to-date links
    to distributors. As of this writing, one of the more convenient distributors is
    NuHorizons (www.nuhorizons.com), as they offer product availability and pricing
    information on their webpage without requiring registration or a special customer
    account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在制作自己的板，你需要从 Xilinx 分销商那里购买你的 FPGA。Xilinx 网页（www.xilinx.com）提供了最新的分销商链接。截至本文撰写时，较方便的分销商之一是
    NuHorizons（www.nuhorizons.com），因为他们在网页上提供产品可用性和定价信息，无需注册或特殊客户账户。
- en: FPGA development software can usually be acquired at a low price or for free.
    For example, Xilinx offers a free development environment for its Virtex-II (up
    to 300K gates), Spartan II-E and CoolRunner lines of parts. The development environment
    is called the Xilinx ISE WebPACK, and it is available for download after registration
    at www.xilinx.com. This free environment sports an impressive list of features,
    including schematic and HDL input, HDL synthesis, a flooplanner, timing driven
    place and route, timing analysis, and power analysis tools.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 开发软件通常可以以低价或免费获得。例如，Xilinx 为其 Virtex-II（高达 300K 门）、Spartan II-E 和 CoolRunner
    系列部件提供免费的开发环境。这个开发环境被称为 Xilinx ISE WebPACK，注册后可以在 www.xilinx.com 下载。这个免费环境拥有令人印象深刻的特性列表，包括原理图和
    HDL 输入、HDL 综合器、flop planner、时序驱动的布局和布线、时序分析和功耗分析工具。
- en: Xilinx also offers a version of its software called “Xilinx Student Edition”
    through Prentice-Hall. This software comes bundled with a number of tutorials
    and documentation that can help you get into FPGA design. You’ll find a wide variety
    of helpful tutorials and lectures on the Xilinx website under the “Education”
    tab.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Xilinx 还通过 Prentice-Hall 提供其软件的一个版本，称为“Xilinx 学生版”。此软件捆绑了大量的教程和文档，可以帮助你入门 FPGA
    设计。你可以在 Xilinx 网站的“教育”标签下找到各种有用的教程和讲座。
