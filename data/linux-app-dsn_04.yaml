- en: '![](../images/67-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/67-1.jpg)'
- en: '[**BUILDING AND SECURING DAEMONS**](toc.html#chapter4)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**构建和确保守护进程的安全**](toc.html#chapter4)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/as.jpg)'
- en: At the heart of almost all Linux appliances is one or more daemons, the background
    programs that provide a network or system service. You can get an idea of the
    daemons available on your Linux system by looking in the /etc/ rc.d/init.d directory
    or by using the ps ax command to show the daemons you have running on your system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有Linux设备的核心都是一个或多个守护进程，这些后台程序提供了网络或系统服务。您可以通过查看/etc/rc.d/init.d目录或使用ps ax命令来显示您系统上正在运行的守护进程，以了解您Linux系统上可用的守护进程。
- en: The term *daemon* refers to a program that runs in the background without a
    controlling terminal. Daemons also run in their own process group in order to
    avoid inadvertently receiving signals meant for other processes. A daemon usually
    redirects standard input, output, and error to /dev/null or to a log file. Many
    daemons use a Process ID file (or pidfile) to enforce mutual exclusion to a resource;
    this prevents more than one copy of the daemon from running at the same time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “守护进程”一词指的是在没有控制终端的情况下在后台运行的程序。守护进程也在它们自己的进程组中运行，以避免意外接收其他进程的信号。守护进程通常将标准输入、输出和错误重定向到/dev/null或日志文件。许多守护进程使用进程ID文件（或pidfile）来强制对资源的互斥访问；这防止了守护进程的多个副本同时运行。
- en: This chapter shows you how to build and secure the daemons you’ll be using in
    your appliances. It’s divided into three main sections.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示如何构建和确保您在设备中使用的守护进程的安全。它分为三个主要部分。
- en: How to Build a Daemon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建守护进程
- en: How to Secure a Daemon
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保守护进程的安全
- en: A Prototype Daemon
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护进程原型
- en: '[**How to Build a Daemon**](toc.html#chapter4.1)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[**如何构建守护进程**](toc.html#chapter4.1)'
- en: This section shows you how to build a daemon and offers a brief explanation
    of why each step is needed. Your application may not require all of the steps
    listed, and you may need to do them in a different order to meet your needs, but
    this will give you a general idea, nonetheless.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示如何构建守护进程，并简要解释为什么每个步骤都是必要的。您的应用程序可能不需要列出所有步骤，您可能需要以不同的顺序执行它们以满足您的需求，但这将给您一个大致的概念。
- en: Load the configuration.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载配置。
- en: Go into the background.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入后台。
- en: Become the process and session leader.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成为进程和会话领导者。
- en: Set the working directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置工作目录。
- en: Redirect stdin, stdout, and stderr.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重定向stdin、stdout和stderr。
- en: Set up logging.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置日志记录。
- en: Set group IDs and user IDs.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置组ID和用户ID。
- en: Check for a pidfile.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查pidfile。
- en: Set the umask.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置umask。
- en: Set up signal handlers.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置信号处理器。
- en: '**NOTE**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The sample daemon presented later in this chapter includes code for each of
    these steps. Some of the following sections use code taken from the sample daemon.*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章后面提供的示例守护进程包含了每个步骤的代码。以下的一些部分使用了来自示例守护进程的代码。*'
- en: '[***Load the Daemon’s Configuration***](toc.html#chapter4.2)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[***加载守护进程的配置***](toc.html#chapter4.2)'
- en: When a daemon starts, it needs to load a set of parameters that govern its operation.
    This usually means parsing options on the command line and reading settings from
    a configuration file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当守护进程启动时，它需要加载一组控制其操作的参数。这通常意味着解析命令行上的选项并从配置文件中读取设置。
- en: The command line used to start the daemon often contains entries such as the
    location of the configuration file, the user and group IDs to use while running,
    and whether or not the program should become a daemon or stay as a foreground
    process. Some daemons let you specify the daemon’s working directory as well as
    whether or not to do a chroot() before starting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用于启动守护进程的命令行通常包含配置文件的位置、运行时使用的用户和组ID，以及程序是否应该成为守护进程或保持为前台进程。一些守护进程允许您指定守护进程的工作目录，以及是否在启动前执行chroot()。
- en: There is a precedence to the configuration information. Specifically, compiled-in
    values are always loaded first, since they are loaded when the program starts.
    Next, the configuration values from the configuration file are loaded, overwriting
    the compiled-in values. Finally, the values from the command line are loaded,
    overwriting the values from the configuration file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 配置信息有优先级。具体来说，编译内嵌的值总是首先加载，因为它们是在程序启动时加载的。接下来，加载配置文件中的配置值，覆盖编译内嵌的值。最后，加载命令行上的值，覆盖配置文件中的值。
- en: Compiled-in values should focus more on security than functionality, since an
    attacker might delete or modify the configuration file as part of a break in.
    As a security precaution, some daemons refuse to run if they cannot open and load
    a configuration file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 集成的值应该更多地关注安全性而不是功能，因为攻击者可能会在入侵过程中删除或修改配置文件。作为安全预防措施，一些守护进程如果不能打开和加载配置文件则拒绝运行。
- en: 'Since the configuration file is often specified on the command line, your program
    may need to make two passes through it: once to get the configuration file and
    a second time to parse the command line again after the configuration file has
    been loaded. Parameters on the command line are often used while debugging, so
    their values normally override those in the configuration file.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置文件通常在命令行中指定，您的程序可能需要通过它进行两次遍历：一次获取配置文件，第二次在配置文件加载后再次解析命令行。在调试过程中，通常使用命令行参数，因此它们的值通常覆盖配置文件中的值。
- en: '**NOTE**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Make sure your program does a sanity check by verifying the consistency of
    the configuration and that it reports errors or exits if any problems are found.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*请确保您的程序通过验证配置的一致性来进行合理性检查，并在发现任何问题时报告错误或退出。*'
- en: '[***Go into the Background***](toc.html#chapter4.3)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[**进入后台**](toc.html#chapter4.3)'
- en: Once the configuration is loaded, the next step is for the process to (optionally)
    go into the background, where it can detach itself from the controlling terminal.
    This is achieved by calling the fork() function to create a child process. The
    parent process should exit after the fork.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了配置，下一步是让进程（可选地）进入后台，在那里它可以与控制终端断开连接。这是通过调用 fork() 函数来创建子进程实现的。父进程应该在 fork
    之后退出。
- en: In order to go into the background, the child process closes the file descriptors
    of the controlling terminal. The result is that we have a *background process*
    that is not attached to a controlling terminal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进入后台，子进程关闭了控制终端的文件描述符。结果是，我们有一个*后台进程*，它没有连接到控制终端。
- en: 'Your code might look like this example in which the parent process forks and
    exits, leaving the child process to continue setting up the daemon:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码可能看起来像这个示例，其中父进程进行 fork 并退出，留下子进程继续设置守护进程：
- en: '![](../images/69-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/69-1.jpg)'
- en: 'There are two times when you should not send your process into the background:
    when debugging (since you want your terminal to remain the controlling terminal
    for the program so that you see any diagnostic messages and can kill the program
    if you need to), and when you want to automatically respawn your program if it
    dies. In the latter case, the daemon should remain in the foreground so that the
    parent process will receive control when the daemon exits (whether gracefully
    or due to some error).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况你不应该将您的进程发送到后台：当调试时（因为您希望您的终端仍然是程序的控制器，以便您可以看到任何诊断消息，并在需要时杀死程序），以及当您希望程序死亡时自动重启它。在后一种情况下，守护进程应该保持在前台，以便在守护进程退出时（无论是优雅地退出还是由于某些错误）父进程将接收控制权。
- en: The following example shell script shows how you can automatically respawn a
    daemon.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例 shell 脚本展示了如何自动重启守护进程。
- en: '![](../images/69-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/69-2.jpg)'
- en: 'Two common alternatives to a shell script monitor are to add your daemon to
    /etc/inittab and let the init process respawn it, or to write a custom monitor
    program to respawn the various daemons on the appliance. The /etc/inittab approach
    might save memory and a few entries in the process table, and you don’t need to
    write any new software. The script to respawn mydaemon could be replaced with
    a single line in /etc/inittab. If the default runlevel is 3, the line might appear
    as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 两种常见的替代方案是向 /etc/inittab 添加您的守护进程并让 init 进程重启它，或者编写一个自定义监控程序来重启设备上的各种守护进程。/etc/inittab
    方法可能节省内存和进程表中的几个条目，并且您不需要编写任何新软件。重启 mydaemon 的脚本可以用 /etc/inittab 中的单行替换。如果默认运行级别是
    3，该行可能如下所示：
- en: ap:3:respawn:/usr/local/bin/mydaemon
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ap:3:respawn:/usr/local/bin/mydaemon
- en: The word *respawn* tells the init program to restart mydaemon if it dies.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 *respawn* 告诉 init 程序在 mydaemon 死亡时重启它。
- en: '[***Become the Process and Session Leader***](toc.html#chapter4.4)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[**成为进程和会话领导者**](toc.html#chapter4.4)'
- en: The Linux kernel assigns each process to a process group and to a session, both
    of which are used in the distribution of signals. In a *session,* all the processes
    are typically started from an xterm window or from a virtual console login. In
    a *process group,* all the processes are started in a command-line pipe. Each
    session has only one process group that receives input from the controlling terminal;
    that process group is called the *foreground process group.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核将每个进程分配到一个进程组和一个会话，这两个都用于信号的分配。在一个*会话*中，所有进程通常都是从xterm窗口或从虚拟控制台登录启动的。在一个*进程组*中，所有进程都是在命令行管道中启动的。每个会话只有一个进程组，它从控制终端接收输入；这个进程组被称为*前台进程组*。
- en: 'For example, open an xterm or log in to a virtual console, and enter these
    commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，打开一个xterm或登录到虚拟控制台，并输入以下命令：
- en: cat | sort | uniq | tr a d &
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: cat | sort | uniq | tr a d &
- en: cat | sort | uniq | tr a d
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: cat | sort | uniq | tr a d
- en: 'From another xterm or console, the output of ps xj might appear as:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个xterm或控制台，ps xj的输出可能如下所示：
- en: '![](../images/70-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![示例](../images/70-1.jpg)'
- en: All of the processes from the first command line will appear in a process group
    with ![](../images/1.jpg) the cat process (PID 5327 in the above example) as the
    process leader.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从第一个命令行开始的过程都将出现在一个进程组中，其中以![进程组](../images/1.jpg)中的cat进程（如上例中的PID 5327）作为进程组长。
- en: Now look at the Process Group ID (PGID) column in the output of ps xj. All of
    the programs on each command line have the PGID set to the PID of the cat command
    that starts the command line. All the commands for the first line have a PGID
    of 5327, and all the commands for the second line have a PGID of 5331\. The second
    command ![](../images/2.jpg), the one you did not put into the background, is
    the foreground process group for the session, so its PID (5331) is the Session
    Group ID (TPGID) for all of the processes running in the xterm session. Recall
    that the session leader (5331 in this example) is the process that gets standard
    input from the terminal (hence the term Terminal Process Group ID, TPGID).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看ps xj输出中的进程组ID（PGID）列。每行命令中的所有程序都将PGID设置为启动命令行的cat命令的PID。第一行的所有命令的PGID为5327，第二行的所有命令的PGID为5331。第二个命令![示例](../images/2.jpg)，您没有将其放入后台的那个命令，是会话的前台进程组，因此它的PID（5331）是会话组ID（TPGID）。回想一下，会话组长（本例中的5331）是从终端获取标准输入的进程（因此有终端进程组ID，TPGID）的称呼。
- en: The reason for having separate IDs for the process group and session is that
    if you kill a process group, you want the kernel to send the TERM signal to all
    of the processes in the group. The same is true if you want to kill the processes
    in a session.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为进程组和会话保留单独的ID的原因是，如果您杀死一个进程组，您希望内核向该组中的所有进程发送TERM信号。如果您想杀死会话中的进程，也是如此。
- en: 'We don’t want a daemon to receive signals that were not meant for it, and so
    we want the daemon to be in its own session and its own process group. Here is
    code that shows how to use setsid() to make your daemon a session and process
    group leader:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望守护进程接收到不是为其设计的信号，因此我们希望守护进程在其自己的会话和进程组中。以下代码展示了如何使用setsid()使您的守护进程成为会话和进程组长：
- en: '![](../images/71-1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![示例](../images/71-1.jpg)'
- en: As an exercise, you might try typing the ps jax command and examining the sessions,
    process groups, and foreground process groups for the daemons running on your
    system. You should be able to tell which processes belong to the different session
    and process groups.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，您可以尝试输入ps jax命令，并检查您系统上运行的守护进程的会话、进程组和前台进程组。您应该能够判断哪些进程属于不同的会话和进程组。
- en: '**NOTE**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a security precaution, do another fork() after calling setsid() and have
    the parent exit immediately, leaving the child to continue as the daemon. This
    removes the session leader status of the daemon in such a way that it can never
    regain a controlling terminal.*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为安全预防措施，在调用setsid()之后进行另一个fork()，并立即退出父进程，留下子进程继续作为守护进程。这样，守护进程的会话组长状态就被移除了，这样它就永远无法再获得控制终端。*'
- en: '[***Set the Working Directory***](toc.html#chapter4.5)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设置工作目录**](toc.html#chapter4.5)'
- en: Daemons traditionally use the root directory, /, as the working directory. This
    allows the daemon to continue working even if most other filesystems are unmounted.
    Using the root directory also makes it easier to put your daemon into a chroot
    jail for added security. (Chroot jails are described in “Chroot if Possible” on
    page 59.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程传统上使用根目录，/，作为工作目录。这允许守护进程即使在大多数其他文件系统未挂载的情况下也能继续工作。使用根目录也使得将你的守护进程放入chroot监狱以增加安全性变得更容易。（Chroot监狱在“如果可能的话，使用Chroot”一节中描述，见第59页。）
- en: Some daemons let you specify the working directory in the configuration file
    or on the command line. Whether you use the root directory, the /tmp directory,
    or a value from the configuration file, you should be deliberate in specifying
    the working directory of your daemon.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些守护进程允许你在配置文件或命令行中指定工作目录。无论你使用根目录、/tmp目录还是配置文件中的值，你应该在指定守护进程的工作目录时慎重考虑。
- en: Use chdir() to set the working directory of your daemon.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用chdir()设置守护进程的工作目录。
- en: '[***Redirect stdin, stdout, and stderr***](toc.html#chapter4.6)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[***重定向stdin、stdout和stderr***](toc.html#chapter4.6)'
- en: To remove itself from the controlling terminal, a daemon redirects the stdin,
    stdout, and stderr file descriptors by closing and then reopening them (usually
    to the /dev/null device). A daemon inherits all of the open file descriptors of
    the parent. For this reason, many daemons loop through all possible file descriptors
    and close each one. You can get the maximum number of file descriptors from OPEN_MAX
    at compile time or from mx = getdtablesize(); at run time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将自己从控制终端中移除，守护进程通过关闭然后重新打开它们（通常到/dev/null设备）来重定向stdin、stdout和stderr文件描述符。守护进程继承了父进程的所有打开的文件描述符。因此，许多守护进程会遍历所有可能的文件描述符并将每个都关闭。你可以在编译时从OPEN_MAX获取最大文件描述符数量，或者在运行时从mx
    = getdtablesize();获取。
- en: Once you’ve closed all open files, it is good practice to reopen stdin, stdout,
    and stderr; some libraries write to stderr, and therefore stderr should be initialized
    with a valid file descriptor. Instead of using /dev/null, some daemons open a
    log file as stderr.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦关闭了所有打开的文件，重新打开stdin、stdout和stderr是一个好的做法；一些库会写入stderr，因此stderr应该使用有效的文件描述符初始化。一些守护进程不是使用/dev/null，而是打开一个日志文件作为stderr。
- en: The following code redirects these three file descriptors by closing them and
    then reopening them to the /dev/null device. The code also closes all file descriptors
    up to the maximum returned from getdtablesize().
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过关闭它们然后重新打开到/dev/null设备来重定向这三个文件描述符。该代码还关闭了从getdtablesize()返回的最大文件描述符。
- en: '![](../images/72-1.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/72-1.jpg)'
- en: '[***Set Up Logging***](toc.html#chapter4.7)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[***设置日志记录***](toc.html#chapter4.7)'
- en: Your daemon should report errors and other events of interest. While you are
    working on the daemon, you will want to see debugging information, and you may
    want to record your daemon’s activity when it is in operation. Logging can fill
    all of these needs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你的守护进程应该报告错误和其他感兴趣的事件。当你正在处理守护进程时，你将想要看到调试信息，你可能还希望在守护进程运行时记录其活动。日志记录可以满足所有这些需求。
- en: The three common destinations for log messages are syslog, stderr, and a log
    file. It is fairly common to see debugging information directed to stderr, errors
    directed to syslog, and activity logs put into files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息的三个常见目的地是syslog、stderr和日志文件。将调试信息指向stderr、错误指向syslog以及将活动日志放入文件中是相当常见的。
- en: '**NOTE**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you save log files to a local disk, you should probably run crond and have
    logrotate delete old log files. Be sure to add any custom log files to logrotate’s
    configuration.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你将日志文件保存到本地磁盘，你可能需要运行crond并让logrotate删除旧日志文件。务必将任何自定义日志文件添加到logrotate的配置中。*'
- en: If you’re building a network appliance, you may want to send both errors and
    usage logs to syslog, then configure syslog to send log messages to a log host
    on the network instead of saving them in local disk files. This helps minimize
    your appliance’s disk requirements and, since all log message are saved on one
    host, makes it easier to analyze the messages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建网络设备，你可能希望将错误和用法日志都发送到syslog，然后配置syslog将日志消息发送到网络上的日志主机，而不是保存在本地磁盘文件中。这有助于最小化你的设备磁盘需求，并且由于所有日志消息都保存在一个主机上，使得分析消息变得更加容易。
- en: Many daemons let you set the verbosity of debug logging with a parameter on
    the command line. For example, typing -d 5 might turn on debugging output with
    a verbosity level of 5.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程允许你通过命令行上的参数设置调试日志的详细程度。例如，输入-d 5可能会打开详细程度为5的调试输出。
- en: There is no standard meaning for the debug levels in Linux. Some daemons have
    a simple on/off option, while others use a level between 0 and 9\. Some daemons
    let you turn debugging on and off while the program is running by sending it SIGUSR1
    and SIGUSR2 signals, and some daemons read the debug level from the configuration
    file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，调试级别的标准含义并不统一。一些守护进程有一个简单的开启/关闭选项，而另一些则使用介于0到9之间的级别。一些守护进程允许你在程序运行时通过发送SIGUSR1和SIGUSR2信号来开启和关闭调试，而一些守护进程则从配置文件中读取调试级别。
- en: On a large project with several developers, you may want to have separate debug
    levels for different parts of the code so that each developer can independently
    control the logging in his or her code. It is also nice if you can set the debug
    levels while the program is running. (Chapter 6 covers logging in greater detail,
    and shows how we use RTA to modify debug levels at run time.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个有多个开发者的大型项目中，您可能希望为代码的不同部分设置不同的调试级别，以便每个开发者可以独立控制其代码中的日志记录。如果在程序运行时可以设置调试级别，那就更好了。（第6章更详细地介绍了日志记录，并展示了我们如何使用RTA在运行时修改调试级别。）
- en: '[***Set Group and User IDs***](toc.html#chapter4.8)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[***设置组和用户ID***](toc.html#chapter4.8)'
- en: Many daemons start from inittab or from the rc scripts at boot time; others
    are started by cron. Thus, most daemons start with a root user ID, which presents
    a security risk if the program is ever compromised.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程在启动时从inittab或rc脚本启动；其他守护进程由cron启动。因此，大多数守护进程以root用户ID启动，如果程序被破坏，这会带来安全风险。
- en: To limit possible damage if the program is compromised, many daemons drop root
    privileges as soon as possible. For example, a webserver might drop root privileges
    as soon as it has bound to TCP port 80.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制程序被破坏时可能造成的损害，许多守护进程尽可能快地放弃root权限。例如，一个web服务器可能在绑定到TCP端口80后立即放弃root权限。
- en: Likewise, your daemon should drop root privileges if at all possible. But if
    not root, which user IDs and group IDs should you use? Many applications create
    their own users and groups. (A quick look at /etc/passwd and /etc/group confirms
    this.) If you decide to create a user for your daemon, try to keep the user shell
    as /bin/nologin. Your daemon can get the user IDs and group IDs from the configuration
    file or from the command line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果可能的话，您的守护进程应该放弃root权限。但如果不是root用户，应该使用哪些用户ID和组ID？许多应用程序会创建自己的用户和组。（快速查看/etc/passwd和/etc/group可以确认这一点。）如果您决定为您的守护进程创建用户，尽量保持用户shell为/bin/nologin。您的守护进程可以从配置文件或命令行中获取用户ID和组ID。
- en: You can drop root privileges and become another user by using the setuid() system
    call. Other routines that can change the user ID include seteuid() and setreuid(),
    which set both the real and effective user IDs. Your needs should dictate which
    of these to use.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用setuid()系统调用来放弃root权限并成为另一个用户。其他可以更改用户ID的例程包括seteuid()和setreuid()，它们设置真实用户ID和有效用户ID。您应该根据需要决定使用哪一个。
- en: The following code from our sample daemon ![](../images/1.jpg) gets the user
    ID (UID) name from Config[], a global configuration table, and calls ![](../images/2.jpg)
    getpwnam() to convert the name to a numeric UID. A call to ![](../images/3.jpg)
    setuid() sets the UID for the daemon. Our routine to set the group ID (GID) is
    similar, using setgid() instead of setuid(). (The LOG macro is explained later.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例守护进程中的以下代码从Config[]全局配置表中获取用户ID（UID）名称，并调用![](../images/2.jpg) getpwnam()将名称转换为数值UID。对![](../images/3.jpg)
    setuid()的调用为守护进程设置了UID。我们设置组ID（GID）的例程与此类似，使用setgid()代替setuid()。（LOG宏将在后面解释。）
- en: '![](../images/73-1.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/73-1.jpg)'
- en: '![](../images/74-1.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/74-1.jpg)'
- en: '[***Check for a pidfile***](toc.html#chapter4.9)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[***检查pidfile***](toc.html#chapter4.9)'
- en: Many daemons require exclusive access to the computer’s resources, such as a
    TCP port or a printer. In these cases, there should not be two instances of the
    daemon running, as both instances cannot have exclusive access to a resource.
    The most common way to reserve access is through the use of a pidfile.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多守护进程需要独占访问计算机资源，例如TCP端口或打印机。在这些情况下，不应同时运行两个守护进程实例，因为这两个实例都无法独占访问资源。最常见的方式是通过使用pidfile来保留访问权限。
- en: 'The *pidfile* is a text file containing the process ID (PID) of the running
    daemon and is usually located at /var/run/*xxx*.pid, where *xxx* is the name of
    the daemon. For example, you might see the following in /var/run:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*pidfile*是一个包含运行守护进程的进程ID（PID）的文本文件，通常位于/var/run/*xxx*.pid，其中*xxx*是守护进程的名称。例如，您可能在/var/run中看到以下内容：'
- en: '![](../images/74-2.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/74-2.jpg)'
- en: When a daemon starts, it checks to see if a pidfile exists. If the file does
    not exist, the daemon creates it and writes its own PID there. If the file does
    exist, the daemon checks to see if the process specified in the file is still
    running. Then it reads the PID from the file and calls kill(0) to send a signal
    to the process (this is just a test, kill(0) won’t actually terminate a running
    process). If the kill() succeeds, it means that the process specified in the file
    was running and able to accept the signal, so the new daemon can simply exit (optionally
    logging the event). There is no way to atomically check for and create a pidfile,
    so you have to use a Linux file lock to be sure another instance of the daemon
    does not also create a pidfile. The code given later in this section illustrates
    how to use a file lock.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当守护进程启动时，它会检查pidfile是否存在。如果文件不存在，守护进程会创建它并将自己的PID写入其中。如果文件存在，守护进程会检查文件中指定的进程是否仍在运行。然后它从文件中读取PID并调用kill(0)向进程发送信号（这只是一个测试，kill(0)实际上不会终止正在运行的进程）。如果kill()调用成功，这意味着文件中指定的进程正在运行并能接受信号，因此新的守护进程可以简单地退出（可选地记录事件）。无法原子性地检查和创建pidfile，因此您必须使用Linux文件锁来确保另一个守护进程实例不会也创建pidfile。本节后面给出的代码示例说明了如何使用文件锁。
- en: As a security precaution, you may want to configure your appliance so that one
    process is not allowed to kill() another. To do so, check for the existence of
    the daemon by looking for its PID in the /proc directory. If the PID specified
    in the pidfile is not running, the new daemon overwrites the pidfile with its
    PID and continues. (Your daemon should also verify that a process with a matching
    PID is an instance of your daemon and not some other program that happens to have
    a PID matching the one in the pidfile.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安全预防措施，您可能希望配置您的设备，以便一个进程不允许杀死()另一个进程。为此，通过在/proc目录中查找其PID来检查守护进程的存在。如果pidfile中指定的PID没有运行，新的守护进程将用其PID覆盖pidfile并继续。（您的守护进程还应验证具有匹配PID的进程是您的守护进程的实例，而不是某些其他程序，该程序偶然具有与pidfile中指定的PID匹配的PID。）
- en: Stale pidfiles are a nuisance, so when your daemon exits, it should remove its
    pidfile. Write a subroutine that deletes the pidfile and use atexit() to register
    the subroutine for execution at program termination. You may also want to modify
    your rc.sysinit or other initialization scripts to delete all of the old pidfiles
    from /var/run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 过时的pidfile很麻烦，因此当您的守护进程退出时，它应该删除其pidfile。编写一个删除pidfile的子例程，并使用atexit()注册该子例程在程序终止时执行。您还可能希望修改rc.sysinit或其他初始化脚本，以从/var/run中删除所有旧的pidfile。
- en: '**NOTE**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Be sure to delete stale pidfiles early in the boot sequence before the daemon
    is started so that your system initialization does not inadvertently remove active
    pidfiles.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*务必在启动守护进程之前，在引导序列的早期删除过时的pidfile，以免系统初始化意外删除活动pidfile。*'
- en: The name and location of the pidfile is often in the configuration file; if
    it is not there, it can be passed in from the command line. Being able to specify
    the pidfile in the configuration file or on the command line makes it easier to
    run multiple instances of the daemon should the need arise (during debugging,
    for instance).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: pidfile的名称和位置通常在配置文件中；如果不在那里，它可以从命令行传入。能够在配置文件或命令行中指定pidfile使得在需要时（例如在调试期间）运行多个守护进程实例变得更容易。
- en: The code below is taken from our sample daemon and presents one approach to
    the voluntary mutual exclusion of a pidfile. We ![](../images/1.jpg) get the name
    of the pidfile and try to open it. If the open succeeds, we read the PID from
    the file and ![](../images/2.jpg) try to send a signal to the process. If the
    kill() call succeeds, it means the process specified in the pidfile is still running
    and this instance should exit. If the pidfile exists, but the process it specifies
    is not running, the pidfile is stale and should be ![](../images/3.jpg) removed.
    If this instance of the daemon is the valid one, it ![](../images/4.jpg) creates
    a pidfile, ![](../images/5.jpg) locks it, and ![](../images/6.jpg) writes the
    PID into it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码取自我们的示例守护进程，展示了一种自愿互斥pidfile的方法。我们获取pidfile的名称并尝试打开它。如果打开成功，我们从文件中读取PID并尝试向进程发送信号。如果kill()调用成功，这意味着pidfile中指定的进程仍在运行，此实例应退出。如果pidfile存在，但指定的进程没有运行，pidfile已过时，应将其删除。如果此守护进程实例是有效的，它将创建一个pidfile，锁定它，并将PID写入其中。
- en: '![](../images/75-1.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/75-1.jpg)'
- en: '![](../images/76-1.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/76-1.jpg)'
- en: '[***Set the umask***](toc.html#chapter4.10)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设置 umask**](toc.html#chapter4.10)'
- en: The umask command sets the default read/write permissions for files created
    in the current shell. It is generally good practice to set the umask of your daemon
    to 0, which forces you to explicitly set the permissions of any files you create.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: umask 命令设置了当前 shell 中创建的文件的默认读写权限。通常，将守护进程的 umask 设置为 0 是一个好习惯，这会强制你明确设置你创建的任何文件的权限。
- en: 'Because there is no need to save the old value of the umask, we cast the return
    value to void:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不需要保存 umask 的旧值，我们将返回值强制转换为 void：
- en: (void) umask((mode_t) 000);
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (void) umask((mode_t) 000);
- en: '[***Set Up Signal Handlers***](toc.html#chapter4.11)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设置信号处理程序**](toc.html#chapter4.11)'
- en: A *signal handler is* a function that is compiled with the rest of your application.
    Instead of directly invoking the function, you use signal or sigaction to tell
    the operating system to call the function when a signal arrives.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号处理程序* 是一个与你的应用程序其余部分一起编译的函数。你不会直接调用该函数，而是使用信号或 sigaction 来告诉操作系统在信号到达时调用该函数。'
- en: 'The last step in setting up a daemon is to configure the signal handlers. The
    requirements for your application dictate which signals to catch and how to handle
    them. Running the man 7 signal command will give you an idea of the signals you
    might want to catch. Some of the most common signals and actions are:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设置守护进程的最后一步是配置信号处理程序。你的应用程序的要求决定了要捕获哪些信号以及如何处理它们。运行 man 7 signal 命令将给你一个关于你可能想要捕获的信号的想法。一些最常见的信号和操作如下：
- en: '**SIGHUP** Reread the configuration file and reinitialize as appropriate. Close
    and reopen any log files to give logrotate a chance to work.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIGHUP** 重新读取配置文件并适当地重新初始化。关闭并重新打开任何日志文件，以便 logrotate 有机会工作。'
- en: '**SIGTERM**, **SIGQUIT** Do a graceful shutdown of the daemon and exit.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIGTERM**，**SIGQUIT** 守护进程优雅地关闭并退出。'
- en: '**SIGUSR1** Toggle debug mode on or off.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIGUSR1** 切换调试模式开或关。'
- en: '**SIGCHLD** Handle the death of any child processes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIGCHLD** 处理任何子进程的死亡。'
- en: 'You should consult both the man page for sigaction() and your favorite Linux
    programming book before implementing your signal handler, but this simple example
    might help you get started:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现信号处理程序之前，你应该查阅 sigaction() 的手册页和你的最爱 Linux 编程书籍，但这个简单的示例可能有助于你开始：
- en: '![](../images/77-1.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/77-1.jpg)'
- en: The routine that will handle the signal is passed an integer with the signal
    number. The routine should be of type void.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 处理信号的例程会接收到一个包含信号编号的整数。该例程的类型应该是 void。
- en: '![](../images/77-2.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/77-2.jpg)'
- en: '**NOTE**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The code in a signal handler is not executed in the main execution path of
    your program, and since a signal can occur while the signal handler itself is
    running, signal handlers must be reentrant.*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号处理程序中的代码不在你的程序的主执行路径中执行，并且由于信号可以在信号处理程序本身运行时发生，因此信号处理程序必须是可重入的。*'
- en: Writing reentrant code can be a little tricky, and you might want to consider
    just setting a volatile flag and having your main loop examine the flag periodically,
    leaving the real work to be done in the main loop. The flag has to be volatile
    so that the compiler does not optimize away tests for it in the main loop. If
    you decide to do more than set a flag in your signal handler, make sure that all
    the glibc and system calls in your signal handler are reentrant safe.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写可重入的代码可能有点棘手，你可能想要考虑只是设置一个易失性标志，让主循环定期检查该标志，将实际的工作留到主循环中完成。该标志必须是易失性的，这样编译器就不会在主循环中优化掉对它的测试。如果你决定在信号处理程序中做更多的事情，比如设置标志，请确保你的信号处理程序中的所有
    glibc 和系统调用都是可重入安全的。
- en: '[**How to Secure a Daemon**](toc.html#chapter4.12)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[**如何安全地配置守护进程**](toc.html#chapter4.12)'
- en: This section will give you some general guidelines to help you write more secure
    programs. However, because your daemon’s security is much too important to use
    this document as the sole source of your security information, we urge you to
    read the books listed in the bibliography at the end of this chapter. The information
    here is really just an overview of the points you need to consider. Furthermore,
    this section does not tell you how to secure the Linux kernel or your appliance
    in general.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将为你提供一些一般性指南，帮助你编写更安全的程序。然而，由于你的守护进程的安全性非常重要，不能仅使用本文档作为你安全信息的唯一来源，我们强烈建议你阅读本章末尾参考文献中列出的书籍。这里的信息实际上只是你需要考虑的点的概述。此外，本节不会告诉你如何安全地配置
    Linux 内核或你的设备。
- en: 'We’ll break the topic of daemon security into three sections:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把守护进程安全的话题分为三个部分：
- en: Designing a secure daemon
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个安全的守护进程
- en: Writing a secure daemon
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写安全的守护进程
- en: Limiting damage in case of a breach
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在安全漏洞发生时限制损害
- en: '[***Designing a Secure Daemon***](toc.html#chapter4.13)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[***设计安全的守护进程***](toc.html#chapter4.13)'
- en: Securing your daemon starts when you begin thinking about its specification,
    architecture, and design. You have the greatest ability to make your application
    secure when you lay out your daemon’s foundation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 保护你的守护进程从你开始考虑其规范、架构和设计时开始。当你为你的守护进程奠定基础时，你拥有使你的应用程序更安全的最大能力。
- en: By secure, we mean that the daemon should respond to errors and malicious attacks
    in a predictable way. This implies that we must first detect errors (and attacks)
    and then handle them appropriately. One way to think about this is to always have
    a plan for each possible error condition and attack.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“安全”，是指守护进程应以可预测的方式对错误和恶意攻击做出响应。这意味着我们必须首先检测错误（和攻击），然后适当地处理它们。一种思考方式是，为每个可能的错误条件和攻击都制定一个计划。
- en: '**Always Have an Escape Plan**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终制定应急计划**'
- en: Many buildings post escape plans next to elevators and stairwells. The escape
    plan is a map showing the best route to take in case of an emergency. As you design
    your daemon, think about how you will recover or escape from each possible error
    condition. Laying the foundation for a good escape plan early makes it less burdensome
    for you to add the code after your daemon has been developed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多建筑物在电梯和楼梯旁边张贴逃生计划。逃生计划是一张在紧急情况下应采取的最佳路线图。当你设计你的守护进程时，考虑你将如何从每个可能出现的错误条件中恢复或逃生。在守护进程开发之后尽早为良好的逃生计划打下基础，会使你添加代码时更加轻松。
- en: An exit may mean a core dump and program termination, or it may mean aborting
    a single request, closing a network connection, or performing some other error
    recovery. Program termination may be appropriate if you detect an error during
    startup or during a configuration change, or if for any reason you think security
    has been breached. For example, if your daemon is a network server handling client
    requests, it may be appropriate to close a network connection if the daemon receives
    a badly formed request.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 退出可能意味着核心转储和程序终止，或者可能意味着中止单个请求、关闭网络连接或执行其他错误恢复操作。如果在启动期间或配置更改期间检测到错误，或者由于任何原因你认为安全受到侵犯，则程序终止可能是合适的。例如，如果你的守护进程是一个处理客户端请求的网络服务器，那么当守护进程收到格式错误的请求时，关闭网络连接可能是合适的。
- en: In practice, having an error escape plan usually means that all of your subroutines
    return an error code. No matter how deeply nested your subroutine calls are, you
    should be able to pass an error indicator up the chain of subroutine returns.
    An event-driven or state-machine-driven program can use a flag or separate state
    to indicate an error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，拥有错误逃生计划通常意味着所有子例程都返回一个错误代码。无论子例程调用嵌套有多深，你都应能够将错误指示符传递到子例程返回链中。事件驱动或状态机驱动的程序可以使用标志或单独的状态来指示错误。
- en: Your escape should always begin with a log message describing the location of
    the error and the inputs that generated it. You can have two log messages, one
    to detect the error, and another, at a higher level, to report how you’ve decided
    to handle the error.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你的逃生应始终从描述错误位置和生成它的输入的日志消息开始。你可以有两个日志消息，一个用于检测错误，另一个在更高层次上报告你决定如何处理错误。
- en: '**Be Restrictive**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制权限**'
- en: When designing a daemon from scratch, you can specify its operation in detail.
    Your specification and the resulting code should allow only the simplest subset
    of requests and configuration data. Setting a tight standard will make your daemon
    more secure and may help eliminate subtle bugs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始设计守护进程时，你可以详细指定其操作。你的规范和生成的代码应仅允许最简单的请求和配置数据子集。设定严格的标准将使你的守护进程更安全，并可能有助于消除微妙的错误。
- en: 'For example, let’s consider restrictions you could place on configuration or
    other internal filenames. Type the following at a bash prompt (noting the placement
    of single and double quotes):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，让我们考虑你可以对配置或其他内部文件名施加的限制。在bash提示符下输入以下内容（注意单引号和双引号的位置）:'
- en: '![](../images/79-1.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/79-1.jpg)'
- en: Amazing, isn’t it? The above command works. The string, cd ..; cd ..; cd ..;
    cd etc; echo 'nameserver 1.2.3.4'>resolv.conf is a perfectly valid Linux filename.
    While bash must honor this as a valid filename, you do not need to. Consider stating
    in your specification that filenames are limited to the characters [_a-zA-Z/.]
    but the sequences .. and // are invalid. In addition, the maximum length of a
    Linux path and filename is PATH_MAX in limits.h and is usually set to 4096 characters.
    You might want to restrict filename lengths to the minimum that your daemon needs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不令人惊讶吗？上面的命令是有效的。字符串 cd ..; cd ..; cd ..; cd etc; echo 'nameserver 1.2.3.4'>resolv.conf
    是一个完全有效的Linux文件名。虽然bash必须将其视为一个有效的文件名，但你不需要这样做。考虑在规范中声明文件名仅限于字符 [_a-zA-Z/.]，但
    .. 和 // 序列是无效的。此外，Linux路径和文件名的最大长度在 limits.h 中定义为 PATH_MAX，通常设置为4096个字符。你可能希望将文件名长度限制为你的守护进程所需的最小长度。
- en: Filenames are just one example. Give some thought to other ways in which you
    can tighten your daemon’s specification.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名只是其中一个例子。考虑其他你可以用来加强你的守护进程规范的方法。
- en: '[***Write a Secure Daemon***](toc.html#chapter4.14)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[***编写一个安全的守护进程***](toc.html#chapter4.14)'
- en: Security is only as good as the weakest link in its chain. Designing a secure
    daemon is not enough. You must also *write* a secure daemon.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性只有在其链条中最薄弱的环节才是有效的。设计一个安全的守护进程是不够的。你还必须 *编写* 一个安全的守护进程。
- en: '**Validate Input**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证输入**'
- en: Many of the recent Linux vulnerabilities stem from buffer overruns that allow
    an intruder to place executable code on the stack. The most effective defense
    against this kind of attack is to validate all input from a user or from any non-secure
    source. Verify string lengths and make sure strings do not contain any illegal
    characters. Verify that integers are reasonable, relative to their uses, and that
    counting integers are always positive.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多最近的Linux漏洞源于缓冲区溢出，这允许入侵者将可执行代码放置在堆栈上。对此类攻击最有效的防御是验证来自用户或任何非安全来源的所有输入。验证字符串长度，并确保字符串不包含任何非法字符。验证整数是否合理，相对于它们的用途，以及计数整数始终为正。
- en: Perform as much application-specific checking as possible before committing
    other resources. For example, make sure that HTTP requests are well formed and
    that SQL statements are valid. Checking early helps prevent the problem of trying
    to back out of a request once you’ve allocated buffers, sockets, or other resources
    for the request.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配其他资源之前，尽可能进行应用程序特定的检查。例如，确保HTTP请求格式正确，以及SQL语句有效。早期检查有助于防止在为请求分配了缓冲区、套接字或其他资源后尝试撤销请求的问题。
- en: 'Do not let any malformed input into your daemon. Remember: If it’s only 99
    percent right, then it’s still wrong.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让任何格式不正确的输入进入你的守护进程。记住：如果它只有99%正确，那么它仍然是错误的。
- en: '**Check All Return Codes**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查所有返回代码**'
- en: One of the best things you can do to enhance security is to check all return
    codes, especially from system calls. Normally, this would seem like a burden,
    but if you’ve laid out your design with an error escape plan, you’ll find that
    it does not take a lot of thought or effort to test every return code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强安全性，你可以做的最好的事情之一就是检查所有返回代码，尤其是来自系统调用的返回代码。通常，这会感觉像是一项负担，但如果你已经设计了一个带有错误逃生计划的设计，你会发现测试每个返回代码并不需要太多的思考或努力。
- en: '**Avoid Buffer Overrun Attacks**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免缓冲区溢出攻击**'
- en: Some library functions are considered unsafe because they do not limit how much
    memory they will overwrite. For example, the strcpy() function is considered unsafe,
    while the strncpy() function is considered safe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库函数被认为是不安全的，因为它们没有限制它们将覆盖多少内存。例如，strcpy() 函数被认为是不安全的，而 strncpy() 函数被认为是安全的。
- en: Nevertheless, we are not convinced that the strn routines are all that safe,
    since they do not guarantee that the resulting string is null terminated. The
    best thing to do is to check the length of the string before doing a copy. Let’s
    look at some examples.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们并不确信 strn 例程有多么安全，因为它们不能保证结果字符串是空终止的。最好的做法是在复制之前检查字符串的长度。让我们看看一些例子。
- en: '![](../images/80-1.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/80-1.jpg)'
- en: While it uses more code, the above protects the program and reports source strings
    that might be part of an attack on your program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它使用了更多的代码，但上面的方法保护了程序，并报告了可能是对程序攻击的一部分的源字符串。
- en: Several other function families are considered unsafe. Specifically, these include
    strcat(), sprintf(), gets(), and scanf().
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他函数族被认为是不安全的。具体来说，这些包括 strcat()、sprintf()、gets() 和 scanf()。
- en: '**Other Security Software**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他安全软件**'
- en: 'Even if you follow the best coding practices, you may want the added protection
    of the following software:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你遵循最佳编码实践，你也可能想要以下软件提供的额外保护：
- en: '**IBM’s ProPolice** GNU Compiler Collection (GCC) patch to help prevent buffer
    overruns'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**IBM的ProPolice**：GNU编译器集合（GCC）补丁，有助于防止缓冲区溢出'
- en: '**StackGuard** GCC patch to help prevent buffer overruns'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**StackGuard**：GCC补丁，有助于防止缓冲区溢出'
- en: '**Libsafe** Alternate library for strcpy() and other unsafe functions'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**Libsafe**：strcpy()和其他不安全函数的替代库'
- en: '**grsecurity** Kernel patch that can (among other things) make the stack non-executable'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**grsecurity**：一种内核补丁，可以使堆栈不可执行（以及其他功能）'
- en: '**Systrace** Kernel patch that can limit which system calls your daemon can
    make'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**Systrace**：一种内核补丁，可以限制你的守护进程可以做出的系统调用'
- en: We strongly recommend using grsecurity and configuring your system so that code
    is never executed from the stack. This feature uses the hardware in the memory
    management unit and will not affect your program’s performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议使用grsecurity，并配置你的系统，以便代码永远不会从堆栈中执行。这个功能使用内存管理单元的硬件，不会影响你的程序性能。
- en: '[***Limit Damage in Case of a Breach***](toc.html#chapter4.15)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[**在发生违规时限制损害**](toc.html#chapter4.15)'
- en: Almost every major Linux application has, at one time or another, been found
    to be vulnerable. Since the same may happen to your daemon at some point, you
    want to limit the amount of risk a compromised daemon might present to the appliance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个主要的Linux应用程序都曾一度被发现存在漏洞。由于你的守护进程在某个时刻也可能发生同样的事情，你想要限制被破坏的守护进程可能对设备造成的风险量。
- en: '**Prevent Library and Path Attacks**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**防止库和路径攻击**'
- en: If an attacker gains access to your appliance, he might be able to run your
    daemon having first set LD_LIBRARY_PATH or PATH to point to compromised libraries
    and commands. If your program is Set User ID (SUID) root, your attacker has just
    gained complete root control over your appliance. Don’t despair. There are a few
    things you can do to limit disaster in the event that your daemon is compromised.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者获得了对你的设备的访问权限，他们可能会首先设置LD_LIBRARY_PATH或PATH指向受损害的库和命令，然后运行你的守护进程。如果你的程序是Set
    User ID (SUID) root，你的攻击者刚刚获得了对你的设备完全的root控制权。不要绝望。如果你发现守护进程被破坏，你可以做几件事情来限制灾难的发生。
- en: First, do not run your application with an SUID of root. This is easier on an
    appliance than on a multi-user system where programs like passwd and the X server
    must be SUID root. It is better to drop root privileges or to run as a non-privileged
    user. (You’ll learn a few more details about this in the next section.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不要使用root的SUID运行你的应用程序。在设备上这样做比在多用户系统中更容易，因为在多用户系统中，像passwd和X服务器这样的程序必须以SUID
    root运行。最好是放弃root权限或以非特权用户身份运行。（你将在下一节中了解更多关于这个问题的细节。）
- en: The second defense is to do a static build of your daemon using -static as an
    option to your gcc invocation. A statically linked executable might not increase
    the size of your executable as much as you’d imagine, and if you are using chroot
    jails, it might actually save disk space. Statically linked executables usually
    load faster, too.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第二道防线是使用gcc调用中的`-static`选项来对你的守护进程进行静态构建。静态链接的可执行文件可能不会像你想象的那样增加你的可执行文件的大小，如果你使用chroot监狱，它实际上可能节省磁盘空间。静态链接的可执行文件通常也加载得更快。
- en: Another way to prevent a library or path attack is to ignore the environment
    variables that tell your program where to look for shared object libraries and
    system commands. If you are really security conscious, use the glibc clearenv()
    function to undefine all environment variables. You will need to give the full
    path to any commands you run with system(), but this is probably a good idea anyway.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 防止库或路径攻击的另一种方法是忽略告诉你的程序在哪里查找共享对象库和系统命令的环境变量。如果你非常注重安全，可以使用glibc的clearenv()函数来取消定义所有环境变量。你需要为使用system()运行的任何命令提供完整的路径，但这可能是一个好主意。
- en: '**Avoid Root Privileges**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免使用root权限**'
- en: Attackers want root privileges so they can take control of your appliance. If
    you run your daemon as root, you make your daemon a target for their attacks.
    Avoid root privileges if at all possible. Create a new user (with the login shell
    set to /bin/nologin) and use setuid() and setgid() to change to that user. This
    technique is used by most web- and database servers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者想要root权限，以便他们可以控制你的设备。如果你以root身份运行你的守护进程，你使你的守护进程成为他们攻击的目标。尽可能避免使用root权限。创建一个新的用户（登录shell设置为/bin/nologin），并使用setuid()和setgid()切换到该用户。这种技术被大多数Web和数据库服务器使用。
- en: 'Another approach is to modify your rc initialization scripts to launch your
    daemon with sudo to change to the appropriate user. For example, your rc script
    might start your webui daemon as user *wuser with* the command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是修改你的rc初始化脚本，使用sudo启动你的守护进程以切换到适当的用户。例如，你的rc脚本可能以以下命令启动你的webui守护进程作为用户*wuser*：
- en: sudo -l wuser webui
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: sudo -l wuser webui
- en: '**Drop Root Privileges and Set Capabilities**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**放弃根权限并设置能力**'
- en: If you must have root privileges to open network ports below 1024 or to write
    to root-owned files, try to drop as many root privileges as possible. The 2.2
    and later kernels make this possible with capabilities. *Capabilities* are separate
    permissions that perform very specific operations. Your SUID root program may
    drop individual capabilities and keep others.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须拥有根权限来打开低于1024的网络端口或写入根拥有的文件，尽量放弃尽可能多的根权限。2.2及以后的内核通过能力实现了这一点。*能力*是执行非常特定操作的独立权限。你的SUID
    root程序可以放弃单个能力并保留其他能力。
- en: 'The kernel keeps track of three sets of capabilities for each program:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为每个程序跟踪三组能力：
- en: '**Effective** What is currently allowed'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**有效** 当前允许的内容'
- en: '**Permitted** Maximum capabilities the process can use'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许** 进程可以使用的最大能力'
- en: '**Inherited** What to transfer across an execve()'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承** 在execve()过程中要传输的内容'
- en: The system call to set capabilities is capset(). You might also be able to use
    cap_set_proc(), which is more portable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置能力的系统调用是capset()。你也许还能使用cap_set_proc()，它更具有可移植性。
- en: Capabilities are seeing a lot of active development in Linux. Here is a sample
    of the more than 25 capabilities that your daemon should relinquish if possible.
    A list of all of the capabilities is available from the output of man capabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 能力在Linux中得到了很多活跃的开发。以下是一个示例，展示了你的守护进程如果可能的话应该放弃的超过25种能力。所有能力的列表可以从man capabilities的输出中获取。
- en: '![](../images/82-1.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/82-1.jpg)'
- en: The kernel itself honors a set of capabilities, and as the last step in your
    boot process, you might want to limit what the kernel can do. For example, if
    your kernel uses modules, at the end of system bootup, you may want to completely
    remove the kernel’s ability to load or remove modules.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 内核本身尊重一组能力，在你的引导过程的最后一步，你可能想要限制内核能做什么。例如，如果你的内核使用模块，在系统引导结束时，你可能想要完全移除内核加载或卸载模块的能力。
- en: '**NOTE**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A full description of capabilities is beyond the scope of what we can present
    here. A good place to start is man capabilities on your Linux system.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*能力的完整描述超出了我们在这里可以展示的范围。一个好的起点是在你的Linux系统上查看man capabilities。*'
- en: '**Chroot if Possible**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果可能，使用chroot**'
- en: One of the oldest and most trusted techniques to limit damage in case of a breech
    is to run a daemon in a chroot jail. The idea is to put all of the files that
    your daemon will need in a directory subtree and to then tell your daemon that
    the top of the subtree is the “root” of the filesystem. The system call is chroot(),
    and it is a good way to make the rest of the real filesystem invisible in case
    your daemon is breeched.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生违规时限制损害的最古老和最可靠的技巧之一是在chroot监狱中运行守护进程。想法是将你的守护进程需要的所有文件放在一个目录子树中，然后告诉你的守护进程子树的顶部是文件系统的“根”。系统调用是chroot()，这是在守护进程被突破时使真实文件系统其余部分不可见的好方法。
- en: 'It is fairly easy for a process owned by root to break out of a chroot jail,
    so be sure to drop root privileges after the chroot() call. A typical sequence
    of calls to build a chroot jail looks like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 根用户拥有的进程突破chroot监狱相对容易，所以在chroot()调用后一定要放弃根权限。构建chroot监狱的典型调用序列如下：
- en: chdir("/var/app_jail");
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: chdir("/var/app_jail");
- en: chroot("/var/app_jail")
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: chroot("/var/app_jail")
- en: setuid(500);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: setuid(500);
- en: Following the chroot() call, the application will be able to see only the files
    and directories under the directory specified in the chroot() call. You will need
    to close file descriptors to directories outside of the chroot jail, since they
    can provide a means to break out of the jail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在chroot()调用之后，应用程序将只能看到chroot()调用中指定的目录下的文件和目录。你需要关闭chroot监狱外目录的文件描述符，因为它们可能提供突破监狱的手段。
- en: The trick in building a successful chroot jail is in limiting the number of
    files and devices in the jail. Of course you will need all of your daemon’s working
    files, but do not include the startup configuration directory if it contains,
    for example, where to locate the chroot jail. If your program is dynamically linked,
    you will need to include a /lib directory and whatever shared object libraries
    your program uses. Consider doing a static build of your application to avoid
    the necessity of adding the /lib directory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构建成功的chroot监狱的技巧在于限制监狱中的文件和设备数量。当然，你需要你守护进程的所有工作文件，但如果启动配置目录包含例如定位chroot监狱的位置，则不要包括它。如果你的程序是动态链接的，你需要包括/lib目录以及你的程序使用的任何共享对象库。考虑进行应用程序的静态构建以避免添加/lib目录的必要性。
- en: 'The standard library logging routine, syslog(), assumes access to a Unix socket
    at /dev/log. Create a /dev directory in your jail and tell the system logging
    daemon, syslogd, to listen on an additional socket using the -a command line option.
    Here’s an example of how to start syslogd so that it listens on an additional
    socket:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库日志例程syslog()假设可以访问/dev/log的Unix套接字。在你的监狱中创建一个/dev目录，并告诉系统日志守护进程syslogd使用-a命令行选项监听额外的套接字。以下是如何启动syslogd以便它监听额外套接字的示例：
- en: syslogd -a /var/app_jail/dev/log
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: syslogd -a /var/app_jail/dev/log
- en: A common alternative to a chroot jail is a virtual machine. Programs such as
    VMware, VServer, and User-mode Linux all provide more isolation than a chroot
    jail but at the cost of higher memory or CPU requirements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: chroot监狱的一个常见替代方案是虚拟机。例如，VMware、VServer和User-mode Linux等程序提供的隔离性比chroot监狱更好，但代价是更高的内存或CPU需求。
- en: '[**A Prototype Daemon**](toc.html#chapter4.16)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[**原型守护进程**](toc.html#chapter4.16)'
- en: This book includes a bootable CD that turns a PC into a Linux-based appliance.
    The programming effort for the book’s sample appliance was divided among the authors,
    with each of us writing some of the programs. To make the appliance code easier
    for you to read (and easier for us to write), we decided to start by building
    a common core for each of our programs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含一个可启动的CD，可以将PC转换为基于Linux的设备。本书示例设备的编程工作由作者分担，我们每个人都编写了一些程序。为了使设备代码更容易阅读（以及更容易编写），我们决定从为每个程序构建一个共同的核心开始。
- en: The code for the empty daemon is available as part of the code for our appliance,
    and you can get it from the CD or from the book’s website. We’ve tried to build
    the empty daemon to reflect all of the lessons learned in the sections above,
    and you are welcome to copy our empty daemon code and use it as you see fit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 空守护进程的代码作为我们设备的代码的一部分提供，你可以从CD或从本书的网站上获取。我们试图构建空守护进程以反映上述部分学到的所有经验教训，欢迎你复制我们的空守护进程代码并按需使用。
- en: '[**Summary**](toc.html#chapter4.17)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter4.17)'
- en: In this chapter we have demonstrated the initialization steps a typical daemon
    takes—for example, redirecting stdin, stdout, and stderr, and going into the background.
    We’ve also introduced some concepts and techniques that you might use to make
    your daemons more secure.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了典型守护进程的初始化步骤——例如，重定向stdin、stdout和stderr，并进入后台。我们还介绍了一些你可能用来自我增强守护进程安全性的概念和技术。
- en: '[**Further Reading**](toc.html#chapter4.18)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[**进一步阅读**](toc.html#chapter4.18)'
- en: We’ve found the following books useful in determining how to secure a daemon.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现以下书籍在确定如何确保守护进程的安全性方面非常有用。
- en: '*Secure Programming for Linux and Unix HOWTO* by David A. Wheeler ([http://www.dwheeler.com/secure-programs](http://www.dwheeler.com/secure-programs),
    2003)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Secure Programming for Linux and Unix HOWTO* by David A. Wheeler ([http://www.dwheeler.com/secure-programs](http://www.dwheeler.com/secure-programs),
    2003)'
- en: '*Real World Linux Security* by Bob Toxen (Prentice Hall, 2000)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Real World Linux Security* by Bob Toxen (Prentice Hall, 2000)'
- en: '*Network Security Hacks* by Andrew Lockart (O’Reilly, 2004)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Network Security Hacks* by Andrew Lockart (O’Reilly, 2004)'
- en: '*SSH, The Secure Shell: The Definitive Guide* by Daniel J. Barrett and Richard
    E. Silverman (O’Reilly, 2001)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SSH, The Secure Shell: The Definitive Guide* by Daniel J. Barrett and Richard
    E. Silverman (O’Reilly, 2001)'
- en: '*Linux Security* by Shadab Siddiqui (Premier Press, 2002)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux Security* by Shadab Siddiqui (Premier Press, 2002)'
