- en: Part III-6. TCP/IP GENERAL FILE TRANSFER PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 III-6 部分。TCP/IP 通用文件传输协议
- en: '[Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第72章](ch72.html "第72章。文件传输协议 (FTP)")'
- en: '[Chapter 73](ch73.html "Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第73章](ch73.html "第73章。简单文件传输协议 (TFTP)")'
- en: 'File and message transfer protocols represent the most basic type of network
    communication: the simple movement of blocks of data. Of the many file and message
    transfer methods, the most fundamental application is what I call *general file
    transfer*. General file transfer protocols perform one main function: allowing
    files to be copied from one computer to another.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和消息传输协议代表了最基本的网络通信类型：简单的数据块移动。在众多文件和消息传输方法中，最基本的应用是我所说的 *通用文件传输*。通用文件传输协议执行一个主要功能：允许文件从一个计算机复制到另一个计算机。
- en: Since file transfer protocols move files from place to place without much consideration
    of their contents, they are relatively unsophisticated compared with certain message-processing
    applications. However, the idea of being able to move files around is so important
    that general file transfer protocols were one of the very first applications in
    internetworking. While many people now use electronic mail or web browsers to
    perform the functions formerly performed exclusively using general file transfer,
    these older protocols are still very important and widely used, and important
    to understand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件传输协议在移动文件时很少考虑其内容，因此与某些消息处理应用相比，它们相对简单。然而，能够移动文件的想法如此重要，以至于通用文件传输协议是互联网互连中最早的应用之一。尽管现在许多人使用电子邮件或网络浏览器来执行以前仅通过通用文件传输执行的功能，但这些较老的协议仍然非常重要且广泛使用，并且理解它们是很有必要的。
- en: 'This part covers the two TCP/IP general file transfer protocols: the File Transfer
    Protocol (FTP) and the Trivial File Transfer Protocol (TFTP). Each is described
    in its own chapter.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了两个 TCP/IP 通用文件传输协议：文件传输协议 (FTP) 和简单文件传输协议 (TFTP)。每个协议都在其各自的章节中进行了描述。
- en: The relationship between FTP and TFTP is similar to that of the two transport
    protocols, the Transmission Control Protocol (TCP) and the User Datagram Protocol
    (UDP) at layer 4 (discussed in [Part II-8](pt11.html "Part II-8. TCP/IP TRANSPORT
    LAYER PROTOCOLS")). FTP is full-featured, session-oriented, and somewhat complex.
    It is the more often used of the two protocols, providing a full command interface
    and taking advantage of the reliability and stream-transfer functions of TCP,
    over which it runs. TFTP, like the UDP it uses at the transport layer, is a stripped-down
    version of FTP. It has far fewer commands and capabilities than FTP, but it is
    ideal for cases where simplicity and small software program size are important,
    such as in the case of embedded software in devices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 和 TFTP 之间的关系类似于第 4 层的两个传输协议，即传输控制协议 (TCP) 和用户数据报协议 (UDP) 之间的关系（在第 II-8 部分中讨论）。FTP
    功能全面，面向会话，并且相对复杂。它是两种协议中更常使用的一种，提供完整的命令接口，并利用其运行的 TCP 的可靠性和流传输功能。TFTP，就像它在传输层使用的
    UDP 一样，是 FTP 的简化版本。它比 FTP 具有更少的命令和能力，但在需要简单性和小软件程序尺寸的情况下非常理想，例如在设备嵌入式软件的情况下。
- en: Chapter 72. FILE TRANSFER PROTOCOL (FTP)
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第72章。文件传输协议 (FTP)
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'The primary general file transfer protocol in the TCP/IP suite shows its generality
    directly through its unqualified name: the *File Transfer Protocol (FTP)*. FTP
    is one of the most widely used application protocols in the world. It was designed
    to allow the efficient transfer of files between any two devices on a TCP/IP internetwork.
    It automatically takes care of the details of how files are moved, provides a
    rich command syntax to allow various supporting file operations to be performed
    (such as navigating the directory structure and deleting files), and operates
    using the Transmission Control Protocol (TCP) transport service for reliability.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 套件中的主要通用文件传输协议通过其无修饰的名称直接展示了其通用性：*文件传输协议 (FTP)*。FTP 是世界上使用最广泛的应用协议之一。它被设计成允许在
    TCP/IP 互联网中的任何两个设备之间高效地传输文件。它自动处理文件移动的细节，提供丰富的命令语法以执行各种支持文件操作（如导航目录结构和删除文件），并使用传输控制协议
    (TCP) 传输服务来保证可靠性。
- en: In this chapter, I describe in detail the operation of FTP. I begin with an
    overview of FTP, a discussion of its long history, and the standards that define
    it. I then explain the key concepts related to FTP and how it functions. This
    includes a description of the FTP operational model and a look at how FTP control
    connections are established, how and when normal and passive data connections
    are used, and FTP's transmission modes and data representation methods. I then
    move on to the details of FTP commands and how they work, including a discussion
    of FTP command groups, reply codes, and user commands. Finally, I provide a sample
    illustration of a user FTP session showing the internal commands used for each
    action.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我详细描述了FTP的操作。我首先概述了FTP，讨论了其悠久的历史和定义它的标准。然后解释了与FTP相关的关键概念及其工作方式。这包括FTP操作模型的描述以及FTP控制连接的建立方式、何时以及如何使用正常和被动数据连接、FTP的传输模式和数据表示方法。然后我继续讨论FTP命令的细节及其工作方式，包括FTP命令组、回复代码和用户命令的讨论。最后，我提供了一个用户FTP会话的示例，展示了每个动作所使用的内部命令。
- en: FTP Overview, History, and Standards
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP概述、历史和标准
- en: The TCP/IP protocol suite as we know it today was developed in the late 1970s
    and early 1980s, with the watershed event probably the publishing of the version
    4 standards of IP and TCP in 1980\. Modern TCP/IP was the result of experimentation
    and development work that had been underway since the 1960s. This work included
    both the design and implementation of the protocols that would implement internetworks
    and also the creation of the first networking applications to allow users to perform
    different tasks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天所知道的TCP/IP协议套件是在20世纪70年代末和80年代初开发的，其中分水岭事件可能是1980年发布的IP和TCP版本4标准。现代TCP/IP是自20世纪60年代以来进行实验和开发工作的结果。这项工作包括设计并实现将实现互联网的协议，以及创建第一个允许用户执行不同任务的网络应用。
- en: FTP Development and Standardization
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP开发和标准化
- en: 'The developers of early applications conceptually divided methods of network
    use into two categories: *direct* and *indirect*. Direct network applications
    let a user access a remote host and use it as if it were local, creating the illusion
    that the remote network doesn''t even exist (or at least, minimizing the importance
    of distance). Indirect network use meant getting resources from a remote host
    and using them on the local system, and then transferring them back. These two
    methods of use became the models for the first two formalized TCP/IP networking
    applications: Telnet for direct access (see [Chapter 87](ch87.html "Chapter 87. TCP/IP
    INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")) and the FTP for indirect network
    use.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 早期应用程序的开发者从概念上将网络使用方法分为两类：*直接*和*间接*。直接网络应用程序允许用户访问远程主机并像使用本地主机一样使用它，创造出远程网络甚至不存在（或者至少最小化距离的重要性）的错觉。间接网络使用意味着从远程主机获取资源并在本地系统上使用它们，然后再将它们传输回去。这两种使用方法成为了第一个正式化的TCP/IP网络应用的模型：Telnet用于直接访问（见[第87章](ch87.html
    "第87章。TCP/IP交互式和远程应用协议"））和FTP用于间接网络使用。
- en: The first FTP standard was RFC 114, published in April 1971, before TCP and
    IP even existed. This standard defined the basic commands of the protocol and
    the formal means by which devices communicate using it. At this time, the predecessor
    of TCP (called the *Network Control Protocol* or *NCP*) was used for conveying
    network traffic. There was no Internet back then. Its precursor, the ARPAnet,
    was tiny, consisting of only a small group of development computers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个FTP标准是1971年4月发布的RFC 114，在TCP和IP出现之前。这个标准定义了协议的基本命令以及设备使用该协议进行通信的正式手段。当时，TCP的前身（称为*网络控制协议*或*NCP*）被用来传输网络流量。那时还没有互联网。它的前身ARPAnet非常小，仅由一小群开发计算机组成。
- en: A number of subsequent RFCs refined the operation of this early version of FTP,
    with revisions published as RFC 172 in June 1971 and RFC 265 in November 1971\.
    The first major revision was RFC 354, published in July 1972, which for the first
    time contained a description of the overall communication model used by modern
    TCP and details on many of the current features of the protocol. In subsequent
    months, many additional RFCs were published that defined features for FTP or raised
    issues with it. In RFC 542, published in August 1973, the FTP specification looks
    remarkably similar to the one we use today, more than three decades later, except
    that it was still defined to run over NCP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的一系列RFC对这种早期FTP版本的操作进行了细化，修订版分别在1971年6月的RFC 172和1971年11月的RFC 265中发布。第一次重大修订是1972年7月发布的RFC
    354，它首次包含了现代TCP使用的整体通信模型的描述以及关于许多当前协议特性的详细说明。在随后的几个月里，还发布了许多其他RFC，它们定义了FTP的特性或对其提出了问题。在1973年8月发布的RFC
    542中，FTP规范看起来与我们今天使用的规范非常相似，尽管它仍然被定义为在NCP上运行。
- en: After a number of subsequent RFCs that defined and discussed changes, the formal
    standard for modern FTP was published in RFC 765, "File Transfer Protocol Specification,"
    in June 1980\. This was the first standard to define FTP operation over modern
    TCP/IP and was created at around the same time as the other primary defining standards
    for TCP/IP.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义和讨论变化的后续RFC之后，现代FTP的正式标准在1980年6月的RFC 765，“文件传输协议规范”中发布。这是第一个定义FTP在现代TCP/IP上操作的标准，它与其他TCP/IP的主要定义标准几乎同时创建。
- en: RFC 959, "File Transfer Protocol (FTP)," was published in October 1985 and made
    some revisions to RFC 765, including the addition of several new commands, and
    it is now the base specification for FTP. Since that time, a number of other standards
    have been published that define extensions to FTP, better security measures, and
    other features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 959，“文件传输协议（FTP）”，于1985年10月发布，并对RFC 765进行了一些修订，包括添加了几个新命令，现在它是FTP的基础规范。从那时起，还发布了一系列其他标准，它们定义了FTP的扩展、更好的安全措施和其他特性。
- en: Overview of FTP Operation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP操作概述
- en: FTP was created with the overall goal of allowing indirect use of computers
    on a network by making it easy for users to move files from one place to another.
    Like most TCP/IP protocols, FTP is based on a client/server model, with an FTP
    client on a user machine creating a connection to an FTP server to send and retrieve
    files to and from the server. The main objectives of FTP were to make file transfer
    simple and to shield the user from implementation details of how the files are
    actually moved from one place to another. To this end, FTP is designed to deal
    automatically with many of the issues that can potentially arise due to format
    differences in files stored on differing systems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: FTP的创建旨在通过使用户能够轻松地将文件从一个地方移动到另一个地方，从而允许间接使用网络上的计算机。像大多数TCP/IP协议一样，FTP基于客户端/服务器模型，用户机器上的FTP客户端创建一个连接到FTP服务器，以便向服务器发送和检索文件。FTP的主要目标是使文件传输变得简单，并屏蔽用户对文件实际上是如何从一个地方移动到另一个地方的实现细节。为此，FTP被设计来自动处理许多可能由于存储在不同系统上的文件格式差异而出现的问题。
- en: To ensure that files are sent and received without loss of data that could corrupt
    them, FTP uses the reliable TCP at the transport layer. An authentication system
    is used to ensure that only authorized clients are allowed to access a server.
    At the same time, a feature sometimes called *anonymous FTP* allows an organization
    that wishes it to set up a general information server to provide files to anyone
    who might want to retrieve them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文件在发送和接收过程中不会丢失可能损坏文件的数据，FTP在传输层使用可靠的TCP。一个身份验证系统被用来确保只有授权的客户端才能访问服务器。同时，一个有时被称为*匿名FTP*的功能允许一个希望这样做的组织设置一个通用信息服务器，向任何可能想要检索文件的人提供文件。
- en: After a TCP connection is established, an FTP control connection is created.
    Internal FTP commands are passed over this logical connection based on formatting
    rules established by the Telnet Protocol. Each command sent by the client receives
    a reply from the server to indicate whether it succeeded or failed. A data connection
    is established for each individual data transfer to be performed. FTP supports
    normal and passive data connections, allowing either the server or client to initiate
    the data connection. Multiple data types and file types are supported to allow
    flexibility for various types of transfers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立TCP连接之后，会创建一个FTP控制连接。基于Telnet协议建立的格式化规则，内部FTP命令通过这个逻辑连接传递。客户端发送的每个命令都会从服务器收到一个回复，以指示它是否成功。为每个要执行的数据传输建立了一个数据连接。FTP支持正常和被动数据连接，允许服务器或客户端启动数据连接。支持多种数据类型和文件类型，以允许各种类型传输的灵活性。
- en: The interface between an FTP user and the protocol is provided in the form of
    a set of interactive user commands. After establishing a connection and completing
    authentication, two basic commands can be used to send or receive files. Additional
    support commands are provided to manage the FTP connection as well as to perform
    support functions such as listing the contents of a directory or deleting or renaming
    files. In recent years, graphical implementations of FTP have been created to
    allow users to transfer files using mouse clicks instead of having to memorize
    commands. Also, other applications can use FTP directly to move files from one
    place to another.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: FTP用户与协议之间的接口以一组交互式用户命令的形式提供。在建立连接并完成身份验证后，可以使用两个基本命令来发送或接收文件。还提供了额外的支持命令来管理FTP连接以及执行支持功能，如列出目录内容或删除或重命名文件。近年来，已经创建了FTP的图形实现，允许用户通过鼠标点击而不是记住命令来传输文件。此外，其他应用程序可以直接使用FTP将文件从一个地方移动到另一个地方。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The most important general file transfer protocol in TCP/IP
    is the simply named *File Transfer Protocol (FTP)*. The need to be able to move
    files of any type between machines is so fundamental that FTP''s history goes
    back more than 30 years. FTP runs over TCP to ensure that files are transferred
    reliably with no data loss. The protocol uses a set of *FTP commands* sent from
    an FTP client to an FTP server to perform file-transfer operations; the FTP server
    sends to the client *FTP replies* that indicate the success or failure of commands.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP中最重要的一般文件传输协议被简单地命名为 *文件传输协议 (FTP)*。能够在机器之间移动任何类型的文件的需求是如此基本，以至于FTP的历史可以追溯到30多年以前。FTP通过TCP运行以确保文件可靠传输且无数据丢失。该协议使用一组从FTP客户端发送到FTP服务器的
    *FTP命令* 来执行文件传输操作；FTP服务器向客户端发送 *FTP回复*，以指示命令的成功或失败。'
- en: FTP Operational Model, Protocol Components, and Key Terminology
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP操作模型、协议组件和关键术语
- en: The standards that define FTP describe its overall operation using a simple
    conceptual tool called the *FTP model*. This model defines the roles of the devices
    that participate in a file transfer and the two communication channels that are
    established between them. It also describes the components of FTP that manage
    these channels and defines the terminology used for the components. This makes
    it an ideal place for us to see how FTP works in broad terms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 定义FTP的标准使用一个简单的概念工具来描述其整体操作，这个工具被称为 *FTP模型*。该模型定义了参与文件传输的设备角色以及它们之间建立的两个通信通道。它还描述了管理这些通道的FTP组件，并定义了用于组件的术语。这使得它成为我们了解FTP在广义上如何工作的理想场所。
- en: The Server-FTP Process and User-FTP Process
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器-FTP进程和用户-FTP进程
- en: FTP is a classic client/server protocol, as mentioned earlier. However, the
    client is not called by that name, but rather is called the *user*. The name comes
    from the fact that the human user that issues FTP commands works on the client
    machine. The full set of FTP software operating on a device is called a *process*.
    The FTP software on the server is called the *server-FTP process*, while the software
    on the client is the *user-FTP process*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，FTP是一个经典的客户端/服务器协议。然而，客户端并不被称为这个名字，而是被称为 *用户*。这个名字来源于发出FTP命令的人类用户在客户端机器上工作的事实。在设备上运行的FTP软件的完整集合被称为
    *进程*。服务器上的FTP软件被称为 *服务器-FTP进程*，而客户端上的软件被称为 *用户-FTP进程*。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The FTP client is sometimes called the *user device*, since
    the human user interacts with the client directly. The FTP client software is
    called the *user-FTP process*; the FTP server software is the *server-FTP process*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP 客户端有时被称为 **用户设备**，因为人类用户直接与客户端交互。FTP 客户端软件被称为 **用户-FTP 进程**；FTP
    服务器软件是 **服务器-FTP 进程**。'
- en: FTP Control Connection and Data Connection
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP 控制连接和数据连接
- en: 'A critical concept in understanding FTP is that, although it uses TCP like
    many other applications, it does not use just one TCP connection for all communication
    the way most protocols do. Instead, the FTP model is designed around two logical
    channels of communication between the server and user FTP processes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 FTP 的一个关键概念是，尽管它像许多其他应用程序一样使用 TCP，但它不像大多数协议那样仅使用一个 TCP 连接进行所有通信。相反，FTP 模型是围绕服务器和用户
    FTP 进程之间的两个逻辑通信通道设计的：
- en: '**Control Connection** This is the main logical TCP connection that is created
    when an FTP session is established. It is maintained throughout the FTP session
    and is used only for passing control information, such as FTP commands and replies.
    It is not used to send files.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制连接** 这是当建立 FTP 会话时创建的主要逻辑 TCP 连接。它在整个 FTP 会话期间保持不变，并且仅用于传递控制信息，例如 FTP 命令和回复。它不用于发送文件。'
- en: '**Data Connection** Each time data is sent from the server to the client or
    vice versa, a distinct TCP data connection is established between them. Data is
    transferred over this connection. When the file transfer is complete, the connection
    is terminated.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据连接** 每次从服务器向客户端或相反方向发送数据时，它们之间都会建立一个独特的 TCP 数据连接。数据通过此连接传输。当文件传输完成后，连接被终止。'
- en: Using separate channels provides flexibility in how the protocol is used, but
    it also adds complexity to FTP.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的通道提供了在协议使用方面的灵活性，但它也增加了 FTP 的复杂性。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Unlike most protocols, FTP does not use a single TCP connection.
    When a session is set up, a permanent **control connection** is established using
    TCP for passing commands and replies. When files or other data are to be sent,
    they are passed over separate TCP *data connections* that are created and then
    dismantled as needed.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 与大多数协议不同，FTP 不使用单个 TCP 连接。当会话建立时，使用 TCP 建立一个永久的 **控制连接**，用于传递命令和回复。当需要发送文件或其他数据时，它们将通过创建并按需拆卸的单独
    TCP **数据连接**进行传递。'
- en: FTP Process Components and Terminology
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP 处理组件和术语
- en: Since the control and data functions are communicated using distinct channels,
    the FTP model divides the software on each device into two logical protocol components
    that are responsible for each channel. The *protocol interpreter (PI)* is a piece
    of software that is charged with managing the control connection, issuing and
    receiving commands and replies. The *data transfer process (DTP)* is responsible
    for actually sending and receiving data between the client and server. In addition
    to these two elements, the user FTP process includes a third component, a *user
    interface*, that interacts with the human FTP user; it is not present on the server
    side.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于控制和数据功能是通过不同的通道进行通信的，FTP 模型将每个设备上的软件分为两个逻辑协议组件，每个组件负责一个通道。**协议解释器（PI**）是一段负责管理控制连接、发布和接收命令及回复的软件。**数据传输过程（DTP**）负责在客户端和服务器之间实际发送和接收数据。除了这两个元素之外，用户
    FTP 进程还包括第三个组件，即 **用户界面**，它与人类 FTP 用户进行交互；它不在服务器端存在。
- en: Thus, two server process components and three client (user) process components
    are included in FTP. These components are referred to in the FTP model by specific
    names, which are used in the standard to describe the detailed operation of the
    protocol. I plan to do the same in this chapter, so I will now describe more fully
    the components in each device of this model, which are illustrated in [Figure 72-1](ch72s02.html#ftp_operational_model_ftp_is_a_clientser
    "Figure 72-1. FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.").
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，FTP中包含两个服务器过程组件和三个客户端（用户）过程组件。这些组件在FTP模型中用特定的名称来指代，这些名称在标准中用于描述协议的详细操作。我计划在本章中做同样的事情，因此现在我将更详细地描述该模型中每个设备上的组件，这些组件在[图72-1](ch72s02.html#ftp_operational_model_ftp_is_a_clientser
    "图72-1. FTP操作模型 FTP是一个客户端/服务器协议，客户端的用户-FTP过程与服务器端的服务器-FTP过程之间进行通信。命令、回复和状态信息通过控制连接在用户-PI和服务器-PI之间传递，该连接一旦建立就保持会话状态。数据通过为每次传输设置的数据连接在设备之间移动。")中进行了说明。
- en: '![FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.](httpatomoreillycomsourcenostarchimages288261.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![FTP操作模型 FTP是一个客户端/服务器协议，客户端的用户-FTP过程与服务器端的服务器-FTP过程之间进行通信。命令、回复和状态信息通过控制连接在用户-PI和服务器-PI之间传递，该连接一旦建立就保持会话状态。数据通过为每次传输设置的数据连接在设备之间移动。](httpatomoreillycomsourcenostarchimages288261.png.jpg)'
- en: Figure 72-1. FTP operational model FTP is a client/server protocol, with communication
    taking place between the user-FTP process on the client and the server-FTP process
    on the server. Commands, replies, and status information are passed between the
    user-PI and server-PI over the control connection, which is established once and
    maintained for the session. Data is moved between devices over data connections
    that are set up for each transfer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图72-1. FTP操作模型 FTP是一个客户端/服务器协议，客户端的用户-FTP过程与服务器端的服务器-FTP过程之间进行通信。命令、回复和状态信息通过控制连接在用户-PI和服务器-PI之间传递，该连接一旦建立就保持会话状态。数据通过为每次传输设置的数据连接在设备之间移动。
- en: Server-FTP Process Components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器-FTP过程组件
- en: 'The server-FTP process contains two protocol elements:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器-FTP过程包含两个协议元素：
- en: '**Server Protocol Interpreter (Server-PI)** The protocol interpreter is responsible
    for managing the control connection on the server. It listens on the main reserved
    FTP port for incoming connection requests from users (clients). Once a connection
    is established, it receives commands from the user-PI, sends back replies, and
    manages the server data transfer process.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器协议解释器（Server-PI）** 协议解释器负责管理服务器上的控制连接。它监听主保留FTP端口，等待来自用户的连接请求（客户端）。一旦建立连接，它接收来自用户-PI的命令，发送回回复，并管理服务器数据传输过程。'
- en: '**Server Data Transfer Process (Server-DTP)** The DTP on the server side is
    used to send or receive data to or from the user-DTP. The server-DTP may either
    establish a data connection or listen for a data connection coming from the user.
    It interacts with the server''s local file system to read and write files.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器数据传输过程（Server-DTP）** 服务器端的DTP用于向用户-DTP发送或接收数据。服务器-DTP可以建立数据连接或监听来自用户的连接。它与服务器的本地文件系统交互，以读取和写入文件。'
- en: User-FTP Process Components
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户-FTP过程组件
- en: 'The User-FTP Process contains three protocol elements:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 用户-FTP过程包含三个协议元素：
- en: '**User Protocol Interpreter (User-PI)** This protocol interpreter is responsible
    for managing the control connection on the client. It initiates the FTP session
    by issuing a request to the server-PI. Once a connection is established, it processes
    commands received from the user interface, sends them to the server-PI, and receives
    replies. It also manages the user data transfer process.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户协议解释器（User-PI）** 这个协议解释器负责管理客户端的控制连接。它通过向服务器-PI发出请求来启动FTP会话。一旦建立连接，它处理从用户界面接收到的命令，将它们发送到服务器-PI，并接收回复。它还管理用户数据传输过程。'
- en: '**User Data Transfer Process (User-DTP)** The DTP on the user side sends or
    receives data to or from the server-DTP. The user-DTP may either establish a data
    connection or listen for a data connection coming from the server. It interacts
    with the client device''s local file system.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据传输过程（User-DTP）** 用户侧的DTP向服务器-DTP发送或接收数据。用户-DTP可以建立数据连接或监听来自服务器的数据连接。它与客户端设备的本地文件系统交互。'
- en: '**User Interface** The user interface provides a more friendly FTP interface
    to a human user. It allows simpler user-oriented commands to be used for FTP functions
    rather than the somewhat cryptic internal FTP commands, and it allows results
    and information to be conveyed back to the person operating the FTP session.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面** 用户界面为人类用户提供了一个更友好的FTP接口。它允许使用更简单的面向用户的命令来执行FTP功能，而不是使用一些加密的内部FTP命令，并允许将结果和信息传达给操作FTP会话的人。'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The server-FTP process and user-FTP process both contain a
    *protocol interpreter (PI)* element and a *data transfer process (DTP)* element.
    The *server-PI* and *user-PI* are logically linked by the FTP control connection;
    the *server-DTP* and *user-DTP* are logically linked by data connections. The
    user-FTP process includes a third component, the *user interface*, which provides
    the means for the human user to issue commands and see responses from the FTP
    software.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 服务器-FTP进程和用户-FTP进程都包含一个*协议解释器（PI）*元素和一个*数据传输过程（DTP）*元素。*服务器-PI*和*用户-PI*通过FTP控制连接在逻辑上连接；*服务器-DTP*和*用户-DTP*通过数据连接在逻辑上连接。用户-FTP进程包括第三个组件，即*用户界面*，它为人类用户提供了一种更友好的FTP接口，允许使用更简单的面向用户的命令来执行FTP功能，而不是使用一些加密的内部FTP命令，并允许将结果和信息传达给操作FTP会话的人。'
- en: Third-Party File Transfer (Proxy FTP)
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方文件传输（代理FTP）
- en: 'The FTP standard actually defines a separate model for an alternative way of
    using the protocol. In this technique, a user on one host performs a file transfer
    from one server to another. This is done by opening two control connections: one
    each from the user-PI on the user''s machine to the two server-PIs on the two
    servers. Then, a server-DTP is invoked on each server to send data; the user-DTP
    is not used.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: FTP标准实际上定义了一个用于替代协议使用方式的独立模型。在这种技术中，一个主机上的用户从一个服务器向另一个服务器执行文件传输。这是通过打开两个控制连接来完成的：一个从用户的机器上的用户-PI到两个服务器上的两个服务器-PI。然后，在每个服务器上调用一个服务器-DTP来发送数据；用户-DTP没有被使用。
- en: This method, sometimes called *third-party file transfer* or *proxy FTP*, is
    not widely used today. A major reason for its lack of use is that it raises security
    concerns and has been exploited in the past. Thus, while it is worth mentioning,
    I will not be discussing it further in my coverage of FTP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，有时被称为*第三方文件传输*或*代理FTP*，目前在市场上并不常见。其主要原因在于它引发了安全担忧，并且在过去曾被滥用。因此，尽管它值得提及，但我不会在我的FTP介绍中进一步讨论它。
- en: FTP Control Connection Establishment, User Authentication, and Anonymous FTP
    Access
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP控制连接建立、用户认证和匿名FTP访问
- en: You just saw how FTP uses distinct logical data and control channels that are
    established between an FTP client (user) and an FTP server. Before the data connection
    can be used to send actual files, the control connection must be established.
    A specific process is followed to set up this connection and thereby create the
    permanent FTP session between devices that can be used for transferring files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚看到了FTP如何使用在FTP客户端（用户）和FTP服务器之间建立的独立逻辑数据和控制通道。在可以使用数据连接发送实际文件之前，必须建立控制连接。遵循特定的过程来设置此连接，从而在可以用于文件传输的设备之间创建永久的FTP会话。
- en: 'As with other client/server protocols, the FTP server assumes a passive role
    in the control connection process. The server protocol interpreter (server-PI)
    listens on the special well-known TCP port reserved for FTP control connections:
    port 21\. The user-PI initiates the connection by opening a TCP connection from
    the user device to the server on this port. It uses an ephemeral port number as
    its source port in the TCP connection.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他客户端/服务器协议一样，FTP服务器在控制连接过程中假定一个被动角色。服务器协议解释器（服务器-PI）监听为FTP控制连接保留的特殊知名TCP端口：端口21。用户-PI通过从用户设备到该端口的服务器打开TCP连接来启动连接。它在TCP连接中使用一个临时端口号作为其源端口。
- en: 'Once TCP has been set up, the control connection between the devices is established,
    allowing commands to be sent from the user-PI to the server-PI and reply codes
    to be sent back in response. The first order of business after the channel is
    operating is *user authentication*, which the FTP standard calls the *login sequence*.
    This process has two purposes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了TCP连接，设备之间的控制连接就建立起来，允许从用户-PI向服务器-PI发送命令，并回送响应代码。在通道运行后的首要任务是*用户认证*，FTP标准称之为*登录序列*。这个过程有两个目的：
- en: '**Access Control** The authentication process allows access to the server to
    be restricted to only authorized users. It also lets the server control what types
    of access each user has.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制** 认证过程允许将服务器访问限制仅限于授权用户。它还允许服务器控制每个用户具有哪些类型的访问权限。'
- en: '**Resource Selection** By identifying the user making the connection, the FTP
    server can make decisions about what resources to make available to the user.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源选择** 通过识别建立连接的用户，FTP服务器可以做出关于向用户提供哪些资源的决定。'
- en: FTP Login Sequence and Authentication
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP登录序列和认证
- en: 'The FTP''s regular authentication scheme is quite rudimentary: it is a simple
    *user name/password* login scheme, shown in [Figure 72-2](ch72s03.html#ftp_connection_establishment_and_user_au
    "Figure 72-2. FTP connection establishment and user authentication An FTP session
    begins with the establishment of a TCP connection between the client and server.
    The client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open."). Most of us are familiar with this type
    of authentication for various types of access on the Internet and elsewhere. First,
    the user is identified by sending a user name from the user-PI to the server-PI
    using the USER command. Then, the user''s password is sent using the PASS command.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: FTP的常规认证方案相当基础：它是一个简单的*用户名/密码*登录方案，如[图72-2](ch72s03.html#ftp_connection_establishment_and_user_au
    "图72-2. FTP连接建立和用户认证 一个FTP会话从客户端和服务器之间建立TCP连接开始。客户端随后发送用户名和密码以与服务器进行认证。如果服务器接受这些信息，它将向客户端发送问候回复，会话即打开。")所示。我们大多数人都熟悉这种类型的认证，无论是在互联网上还是在其他地方。首先，通过使用USER命令从用户-PI向服务器-PI发送用户名来识别用户。然后，使用PASS命令发送用户的密码。
- en: The server checks the user name and password against its user database to verify
    that the connecting user has valid authority to access the server. If the information
    is valid, the server sends back a greeting to the client to indicate that the
    session is opened. If the user improperly authenticates (by specifying an incorrect
    user name or password), the server will request that the user attempt authorization
    again. After a number of invalid authorization tries, the server may time out
    and terminate the connection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将用户名和密码与其用户数据库进行核对，以验证连接用户是否有有效权限访问服务器。如果信息有效，服务器将向客户端发送问候以表明会话已打开。如果用户认证不正确（指定了错误的用户名或密码），服务器将要求用户再次尝试授权。在多次无效授权尝试后，服务器可能会超时并终止连接。
- en: Assuming that the authentication succeeds, the server then sets up the connection
    to allow the type of access to which the user is authorized. Some users may have
    access to only certain files or certain types of files. Some servers may allow
    particular users to read and write files on the server, while other users may
    only retrieve files. The administrator can thus tailor FTP access as needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设认证成功，服务器随后建立连接以允许用户有权访问的类型。某些用户可能只能访问某些文件或某些类型的文件。某些服务器可能允许特定用户在服务器上读写文件，而其他用户可能只能检索文件。管理员可以根据需要调整FTP访问权限。
- en: '![FTP connection establishment and user authentication An FTP session begins
    with the establishment of a TCP connection between the client and server. The
    client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open.](httpatomoreillycomsourcenostarchimages288263.png.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![FTP连接建立和用户认证 FTP会话从客户端和服务器之间建立TCP连接开始。客户端随后发送用户名和密码以验证服务器。假设服务器接受这些信息，它将发送一个问候回复给客户端，会话即打开。](httpatomoreillycomsourcenostarchimages288263.png.jpg)'
- en: Figure 72-2. FTP connection establishment and user authentication An FTP session
    begins with the establishment of a TCP connection between the client and server.
    The client then sends the user name and password to authenticate with the server.
    Assuming that the information is accepted by the server, it sends a greeting reply
    to the client and the session is open.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图72-2. FTP连接建立和用户认证 FTP会话从客户端和服务器之间建立TCP连接开始。客户端随后发送用户名和密码以验证服务器。假设服务器接受这些信息，它将发送一个问候回复给客户端，会话即打开。
- en: Once the connection is established, the server can also make resource selection
    decisions based on the user's identity. For example, on a system with multiple
    users, the administrator can set up FTP so that when any user connects, she automatically
    is taken to her own home directory. The optional ACCT (account) command also allows
    a user to select a particular account if she has more than one.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，服务器也可以根据用户的身份做出资源选择决策。例如，在多用户系统中，管理员可以设置FTP，使得任何用户连接时，都会自动被带到她的个人主目录。可选的ACCT（账户）命令还允许用户在拥有多个账户时选择特定的账户。
- en: FTP Security Extensions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP安全扩展
- en: Like most older protocols, the simple login scheme used by FTP is a legacy of
    the relatively closed nature of the early Internet. It is not considered secure
    by today's global Internet standards, because the user name and password are sent
    across the control connection in clear text. This makes it relatively easy for
    login information to be intercepted by intermediate systems and accounts to be
    compromised. RFC 2228, "FTP Security Extensions," defines more sophisticated authentication
    and encryption options for those who need added security in their FTP software.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数较老的协议一样，FTP使用的简单登录方案是早期互联网相对封闭性质的遗产。它不符合当今全球互联网的安全标准，因为用户名和密码以明文形式通过控制连接发送。这使得登录信息被中间系统拦截相对容易，账户也可能被破坏。RFC
    2228，“FTP安全扩展”为那些需要在FTP软件中增加安全性的用户定义了更复杂的认证和加密选项。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** An FTP session begins with the establishment of a control connection
    between an FTP client and server. After the TCP connection is made, the user must
    authenticate with the server using a simple user name/password exchange between
    client and server. This provides only rudimentary security, so if more security
    is required, it must be implemented using FTP security extensions or through other
    means.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP会话从FTP客户端和服务器之间建立控制连接开始。在TCP连接建立后，用户必须通过客户端和服务器之间简单的用户名/密码交换来验证服务器。这仅提供了基本的安全保障，因此如果需要更高的安全性，必须通过FTP安全扩展或其他方式来实现。'
- en: Anonymous FTP
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名FTP
- en: 'Perhaps surprisingly, many organizations did not see the need for an enhanced
    level of security. These organizations, in fact, went in the opposite direction:
    They used FTP without any authentication at all. But why would any business want
    to allow just anybody access to its FTP server? The answer is pretty simple: Anyone
    who wants to use the server can do so to provide information to the general public.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可能令人惊讶的是，许多组织并没有看到提高安全级别的重要性。实际上，这些组织采取了相反的方向：它们使用FTP而不进行任何认证。但任何企业为什么要允许任何人访问其FTP服务器呢？答案很简单：任何想要使用服务器的人都可以用来向公众提供信息。
- en: Today, most organizations use the World Wide Web to distribute documents, software,
    and other files to customers and others who want to obtain them. But in the 1980s,
    before the Web became popular, FTP was often used to distribute such information.
    For example, today, if you had a 3Com network interface card and wanted to obtain
    a driver for it, you would go to the web server *www.3com.com*, but several years
    ago, you might have accessed the 3Com FTP server *(ftp.3com.com)* to download
    a driver.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数组织使用万维网向客户和其他希望获取文件的人分发文档、软件和其他文件。但在20世纪80年代，在万维网变得流行之前，FTP常被用来分发此类信息。例如，如果今天你有一张3Com网络接口卡并想获取其驱动程序，你会去访问网络服务器*www.3com.com*，但几年前，你可能需要访问3Com的FTP服务器*(ftp.3com.com)*来下载驱动程序。
- en: Clearly, requiring every customer to have a user name and password on such a
    server would be ridiculously difficult. For this reason, RFC 1635, published in
    1994, defined a use for the protocol called *anonymous FTP*. In this technique,
    a client connects to a server and provides a default user name to log in as a
    guest. Usually the names *anonymous* or *ftp* are supported. Seeing this name,
    the server responds back with a special message, saying something like "Guest
    login OK, send your complete email address as password." The password in this
    case isn't really a password; it is used simply to allow the server to log who
    is accessing it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，要求每位客户在这样一个服务器上都有一个用户名和密码将是非常困难的。因此，1994年发布的RFC 1635定义了该协议的一种用途，称为*匿名FTP*。在这种技术中，客户端连接到服务器，并提供一个默认用户名以作为访客登录。通常支持*匿名*或*ftp*这样的名称。看到这个名称后，服务器会回送一条特殊消息，例如“访客登录成功，请发送您的完整电子邮件地址作为密码。”在这种情况下，密码实际上并不是密码；它只是用来允许服务器记录谁在访问它。
- en: The guest is then able to access the site, though the server will usually severely
    restrict the access rights of guests on the system. Many FTP servers support both
    identified and anonymous access, with authorized users having more permissions
    (such as being able to traverse the full directory path and having the right to
    delete or rename files) and anonymous users restricted to only reading files from
    a particular directory set up for public access.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，访客能够访问该网站，尽管服务器通常会严格限制系统上访客的访问权限。许多FTP服务器同时支持已识别和匿名访问，授权用户拥有更多权限（例如能够遍历完整的目录路径，以及有删除或重命名文件的权限），而匿名用户仅限于从为公共访问设置的特定目录中读取文件。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Many FTP servers support *anonymous FTP*, which allows a guest
    who has no account on the server to have limited access to server resources. This
    is often used by organizations that wish to make files available to the public
    for purposes such as technical support, customer support, or distribution.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 许多FTP服务器支持*匿名FTP*，这允许没有服务器账户的访客有限地访问服务器资源。这通常用于希望向公众提供文件的组织，例如技术支持、客户支持或分发。'
- en: FTP Data Connection Management
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP数据连接管理
- en: The control channel created between the server-PI and the user-PI using the
    FTP connection establishment and authentication process is maintained throughout
    the FTP session. Over the control channel, the protocol interpreters exchange
    commands and replies, but not data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FTP连接建立和认证过程在服务器-PI和用户-PI之间创建的控制通道在整个FTP会话期间保持开放。在控制通道上，协议解释器交换命令和回复，但不传输数据。
- en: Each time files or other data need to be sent between the server and user FTP
    processes, a data connection must be created. The data connection links the user-DTP
    with the server-DTP. This connection is required both for explicit file transfer
    actions (getting or receiving a file) and for implicit data transfers, such as
    requesting a list of files from a directory on the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要在服务器和用户FTP进程之间发送文件或其他数据时，必须创建一个数据连接。数据连接将用户-DTP与服务器-DTP连接起来。此连接对于显式文件传输操作（获取或接收文件）和隐式数据传输（例如从服务器上的目录请求文件列表）都是必需的。
- en: The FTP standard specifies two different ways of creating a data connection,
    though it doesn't really explain them in a way that is very easy to understand.
    The two methods differ primarily in which device—the client or the server—initiates
    the connection. This may at first seem like a trivial matter, but as you'll see
    shortly, it is actually quite important.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: FTP标准指定了创建数据连接的两种不同方式，尽管它并没有以非常容易理解的方式解释它们。这两种方法主要区别在于哪个设备——客户端或服务器——发起连接。这最初可能看起来像是一件微不足道的事情，但正如你很快就会看到的，这实际上非常重要。
- en: Normal (Active) Data Connections
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正常（主动）数据连接
- en: The first method is sometimes called creating a *normal* data connection (because
    it is the default method) and sometimes an *active* data connection (in contrast
    with the passive method we will discuss in a moment). In this type of connection,
    the server-DTP initiates the data channel by opening a TCP connection to the user-DTP.
    The server uses the special reserved port number 20 (one less than the well-known
    control FTP port number 21) for the data connection. On the client machine, the
    default port number used is the same as the ephemeral port number used for the
    control connection, but as you'll see shortly, the client will often choose a
    different port for each transfer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法有时被称为创建一个**正常**数据连接（因为它默认是方法）有时也称为**主动**数据连接（与我们将要讨论的被动方法相对）。在这种类型的连接中，服务器-DTP通过打开到用户-DTP的TCP连接来启动数据通道。服务器使用特殊的保留端口号20（比知名的控制FTP端口号21小1）进行数据连接。在客户端机器上，默认使用的端口号与用于控制连接的临时端口号相同，但正如你很快就会看到的，客户端通常会为每次传输选择不同的端口号。
- en: Let's use an example to see how this works. Suppose the user-PI established
    a control connection from its ephemeral port number 1678 to the server's FTP control
    port of 21\. Then, to create a data connection for data transfer, the server-PI
    would instruct the server-DTP to initiate a TCP connection from the server's port
    20 to the client's port 1678\. The client would acknowledge this, and then data
    could be transferred (in either direction—remember that TCP is bidirectional).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看它是如何工作的。假设用户-PI从其临时端口号1678建立了一个到服务器FTP控制端口21的控制连接。然后，为了创建数据传输的数据连接，服务器-PI会指示服务器-DTP从服务器的端口20到客户端的端口1678发起一个TCP连接。客户端会确认这一点，然后就可以进行数据传输（双向——记住TCP是双向的）。
- en: In practice, having the client's control and data connection on the same port
    is not a good idea; it complicates the operation of FTP and can lead to some tricky
    problems. For this reason, it is strongly recommended that the client specify
    a different port number using the PORT command prior to the data transfer. For
    example, suppose the client specifies port 1742 using PORT. The server-DTP would
    then create a connection from its port 20 to the client's port 1742 instead of
    1678\. This process is shown in [Figure 72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi
    "Figure 72-3. FTP active data connection In a conventional, or active, FTP data
    connection, the server initiates the transfer of data by opening the data connection
    to the client. In this case, the client first sends a PORT command to tell the
    server to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将客户端的控制和数据连接放在同一个端口上不是一个好主意；它会复杂化FTP的操作，并可能导致一些棘手的问题。因此，强烈建议在数据传输之前，客户端使用PORT命令指定不同的端口号。例如，假设客户端使用PORT指定了端口号1742。那么，服务器-DTP就会从其端口20创建一个连接到客户端的端口1742，而不是1678。这个过程在[图72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi
    "图72-3. FTP主动数据连接 在传统的或主动的FTP数据连接中，服务器通过打开到客户端的数据连接来启动数据传输。在这种情况下，客户端首先发送一个PORT命令，告诉服务器使用端口1742。然后，服务器从其默认端口号20打开到客户端端口1742的数据连接。然后，使用这些端口在这些设备之间交换数据。")中展示。
- en: Passive Data Connections
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被动数据连接
- en: The second method is called a *passive* data connection. The client tells the
    server to be passive—that is, to accept an incoming data connection initiated
    by the client. The server replies, giving the client the server IP address and
    port number that it should use. The server-DTP then listens on this port for an
    incoming TCP connection from the user-DTP. By default, the user machine uses the
    same port number it used for the control connection, as in the active case. However,
    here again, the client can choose to use a different port number for the data
    connection if necessary (typically an ephemeral port number).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法被称为**被动**数据连接。客户端告诉服务器要处于被动状态——也就是说，接受由客户端发起的数据连接。服务器回复，向客户端提供它应该使用的服务器IP地址和端口号。服务器-DTP随后监听这个端口，等待来自用户-DTP的TCP连接。默认情况下，用户机器使用与控制连接相同的端口号，就像在主动情况下一样。然而，在这里，如果需要的话，客户端可以选择为数据连接使用不同的端口号（通常是临时端口号）。
- en: Let's consider our example again, with the control connection from port 1678
    on the client to port 21 on the server, but this time consider data transfer using
    a passive connection, as illustrated in [Figure 72-4](ch72s04.html#ftp_passive_data_connection_in_a_passive
    "Figure 72-4. FTP passive data connection In a passive FTP data connection, the
    client uses the PASV command to tell the server to wait for the client to establish
    the data connection. The server responds, telling the client what port it should
    use on the server for the data transmission—in this case, port 2223\. The client
    then opens the data connection using that port number on the server and a client
    port number of its own choosing—in this case, 1742."). The client would issue
    the PASV command to tell the server it wanted to use passive data control. The
    server-PI would reply with a port number for the client to use—say port 2223\.
    The server-PI would then instruct the server-DTP to listen on this port 2223\.
    The user-PI would instruct the user-DTP to create a connection from client port
    1742 to server port 2223\. The server would acknowledge this, and then data could
    be sent and received, again in either direction.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑我们的例子，客户端的控制连接从端口号1678到服务器的端口号21，但这次考虑使用被动连接进行数据传输，如图[图72-4](ch72s04.html#ftp_passive_data_connection_in_a_passive
    "图72-4. 被动FTP数据连接 在被动FTP数据连接中，客户端使用PASV命令告诉服务器等待客户端建立数据连接。服务器响应，告诉客户端它应该在服务器上使用哪个端口进行数据传输——在这个例子中，端口2223。然后，客户端使用服务器上的该端口号和它自己选择的客户端端口号（在这个例子中，1742）打开数据连接。")所示。客户端会发出PASV命令告诉服务器它想要使用被动数据控制。服务器-PI会回复一个客户端可以使用的端口号——比如说端口2223。然后，服务器-PI会指示服务器-DTP监听这个端口2223。用户-PI会指示用户-DTP从客户端端口1742到服务器端口2223创建连接。服务器会确认这一点，然后数据就可以发送和接收，再次是双向的。
- en: '![FTP active data connection In a conventional, or active, FTP data connection,
    the server initiates the transfer of data by opening the data connection to the
    client. In this case, the client first sends a PORT command to tell the server
    to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.](httpatomoreillycomsourcenostarchimages288265.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![FTP主动数据连接](httpatomoreillycomsourcenostarchimages288265.png.jpg) 在传统的或主动的FTP数据连接中，服务器通过打开到客户端的数据连接来启动数据传输。在这种情况下，客户端首先发送一个PORT命令，告诉服务器使用端口1742。然后，服务器从其默认端口20打开数据连接到客户端端口1742。然后，使用这些端口在设备之间交换数据。'
- en: Figure 72-3. FTP active data connection In a conventional, or active, FTP data
    connection, the server initiates the transfer of data by opening the data connection
    to the client. In this case, the client first sends a PORT command to tell the
    server to use port 1742\. The server then opens the data connection from its default
    port number of 20 to client port 1742\. Data is then exchanged between the devices
    using these ports.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图72-3. FTP主动数据连接 在传统的或主动的FTP数据连接中，服务器通过打开到客户端的数据连接来启动数据传输。在这种情况下，客户端首先发送一个PORT命令，告诉服务器使用端口1742。然后，服务器从其默认端口20打开数据连接到客户端端口1742。然后，使用这些端口在设备之间交换数据。
- en: Efficiency and Security Issues Related to the Connection Methods
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接方法相关的效率和安全性问题
- en: At this point, you may be wondering what the practical difference is between
    the active and passive connection types. I already said that in either case, the
    data transfer can go in both directions. So what does it matter who initiates
    the data connection? Isn't this like arguing over who makes a local telephone
    call?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道主动和被动连接类型之间的实际区别是什么。我之前已经说过，在两种情况下，数据传输都可以双向进行。那么，谁启动数据连接有什么关系呢？这不是像争论谁打本地电话一样吗？
- en: The answer is related to the dreaded "S word:" *security*. The fact that FTP
    uses more than one TCP connection can cause problems for the hardware and software
    that people use to ensure the security of their systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 答案与令人恐惧的“S”词有关：*安全*。FTP使用多个TCP连接的事实可能会给人们用来确保系统安全性的硬件和软件带来问题。
- en: Consider what is happening in the case of an active data connection, as described
    in [Figure 72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi "Figure 72-3. FTP
    active data connection In a conventional, or active, FTP data connection, the
    server initiates the transfer of data by opening the data connection to the client.
    In this case, the client first sends a PORT command to tell the server to use
    port 1742\. The server then opens the data connection from its default port number
    of 20 to client port 1742\. Data is then exchanged between the devices using these
    ports."). From the perspective of the client, an established control connection
    exists from the client's port 1678 to the server's port 21\. But the data connection
    is initiated by the server. So the client sees an incoming connection request
    to port 1678 (or some other port). Many clients are suspicious about receiving
    such incoming connections, since under normal circumstances, clients *establish*
    connections—they don't respond to them. Since incoming TCP connections can potentially
    be a security risk, many clients are configured to block them using firewall hardware
    or software.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到主动数据连接的情况，如[图72-3](ch72s04.html#ftp_active_data_connection_in_a_conventi
    "图72-3. FTP主动数据连接 在传统的或主动的FTP数据连接中，服务器通过打开到客户端的数据连接来启动数据传输。在这种情况下，客户端首先发送PORT命令来告知服务器使用端口1742。然后服务器从其默认端口20打开数据连接到客户端端口1742。数据随后通过这些端口在设备之间交换。")中所述。从客户端的角度来看，存在一个从客户端端口1678到服务器端口21的控制连接。但是数据连接是由服务器发起的。因此，客户端看到的是对端口1678（或另一个端口）的传入连接请求。由于在正常情况下，客户端是*建立*连接的——它们不会响应它们，许多客户端对收到此类传入连接持怀疑态度。由于传入TCP连接可能存在安全风险，许多客户端被配置为使用防火墙硬件或软件来阻止它们。
- en: '![FTP passive data connection In a passive FTP data connection, the client
    uses the PASV command to tell the server to wait for the client to establish the
    data connection. The server responds, telling the client what port it should use
    on the server for the data transmission—in this case, port 2223\. The client then
    opens the data connection using that port number on the server and a client port
    number of its own choosing—in this case, 1742.](httpatomoreillycomsourcenostarchimages288267.png.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![FTP被动数据连接 在一个被动FTP数据连接中，客户端使用PASV命令来告知服务器等待客户端建立数据连接。服务器响应，告诉客户端它应该在服务器上使用哪个端口进行数据传输——在这个例子中，端口2223。然后客户端使用服务器上的该端口号以及自己选择的客户端端口号（在这个例子中，1742）来打开数据连接。](httpatomoreillycomsourcenostarchimages288267.png.jpg)'
- en: Figure 72-4. FTP passive data connection In a passive FTP data connection, the
    client uses the PASV command to tell the server to wait for the client to establish
    the data connection. The server responds, telling the client what port it should
    use on the server for the data transmission—in this case, port 2223\. The client
    then opens the data connection using that port number on the server and a client
    port number of its own choosing—in this case, 1742.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图72-4. FTP被动数据连接 在一个被动FTP数据连接中，客户端使用PASV命令来告知服务器等待客户端建立数据连接。服务器响应，告诉客户端它应该在服务器上使用哪个端口进行数据传输——在这个例子中，端口2223。然后客户端使用服务器上的该端口号以及自己选择的客户端端口号（在这个例子中，1742）来打开数据连接。
- en: 'Why not just make it so that the client always accepts connections to the port
    number one above the ephemeral number used for the control connection? The problem
    here is that clients often use different port numbers for each transfer by using
    the PORT command. This is done because of the rules of TCP. As I describe in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION"),
    after a connection is closed, a period of time must elapse before the port can
    be used again to prevent mixing up consecutive sessions. This would cause delays
    when sending multiple files one after the other, so to avoid this, clients usually
    use different port numbers for each transfer. This is more efficient, but it means
    a firewall protecting the client would be asked to accept incoming connections
    that appear to be going to many unpredictable port numbers.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接让客户端总是接受比用于控制连接的临时端号高一个数字的端口的连接呢？这里的问题是客户端经常使用PORT命令为每次传输使用不同的端口号。这样做是因为TCP的规则。正如我在[第47章](ch47.html
    "第47章. TCP基本操作：连接建立、管理和终止")中描述的，在连接关闭后，必须经过一段时间才能再次使用该端口，以防止混淆连续的会话。这会导致在连续发送多个文件时出现延迟，因此为了避免这种情况，客户端通常为每次传输使用不同的端口号。这更有效率，但这也意味着保护客户端的防火墙需要接受看似将前往许多不可预测端口号的入站连接。
- en: The use of passive connections largely eliminates this problem. Most firewalls
    have a lot more difficulty dealing with incoming connections to odd ports than
    outgoing connections. RFC 1579, "Firewall-Friendly FTP," discusses this issue
    in detail. It recommends that clients use passive data connections by default
    instead of using normal connections with the PORT command to avoid the port-blocking
    problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 被动连接的使用在很大程度上消除了这个问题。大多数防火墙在处理入站连接到奇数端口方面比处理出站连接困难得多。RFC 1579，“防火墙友好的FTP”详细讨论了这个问题。它建议客户端默认使用被动数据连接，而不是使用带有PORT命令的正常连接，以避免端口阻塞问题。
- en: Of course, passive data connections don't really eliminate the problem; they
    just push it off onto servers. These servers now must face the issue of incoming
    connections to various ports. Still, it is, generally speaking, easier to deal
    with security issues on a relatively smaller number of servers than on a large
    number of clients. FTP servers must be able to accept passive mode transfers from
    clients anyway, so the usual approach is to set aside a block of ports for this
    purpose, which the server's security provisions allow to accept incoming connections,
    while blocking incoming connection requests on other ports.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，被动的数据连接并不能真正消除问题；它们只是将问题推给了服务器。现在，这些服务器必须面对各种端口上的入站连接问题。然而，总的来说，在相对较少的服务器上处理安全问题比在大量客户端上更容易。FTP服务器无论如何都必须能够接受来自客户端的被动模式传输，因此通常的做法是为这个目的预留一段端口，服务器的安全设置允许接受这些端口的入站连接，同时阻止其他端口的入站连接请求。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** FTP supports two different models for establishing data connections
    between the client and server. In normal, or *active*, data connections, the server
    initiates the connection when the client requests a transfer, and the client responds;
    in a *passive* data connection, the client tells the server it will initiate the
    connection, and the server responds. Since TCP is bidirectional, data can flow
    either way in both cases; the chief difference between the two modes has to do
    with security. In particular, passive mode is often used because many modern client
    devices are not able to accept incoming connections from servers.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP支持两种不同的模型来在客户端和服务器之间建立数据连接。在正常或*主动*数据连接中，当客户端请求传输时，服务器发起连接，客户端响应；在*被动*数据连接中，客户端告诉服务器它将发起连接，服务器响应。由于TCP是双向的，在两种情况下数据都可以双向流动；这两种模式的主要区别在于安全性。特别是，被动模式经常被使用，因为许多现代客户端设备无法接受来自服务器的入站连接。'
- en: Another point worth mentioning is that it is a significant violation of the
    layering principle of networks to pass IP addresses and port numbers in FTP commands
    such as PORT and PASV and the replies to them. This isn't just a philosophical
    issue. Applications aren't supposed to deal with port numbers, and this creates
    issues when certain lower-layer technologies are used. For example, consider the
    use of Network Address Translation (NAT; see [Chapter 28](ch28.html "Chapter 28. IP
    NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL")), which modifies IP addresses and
    possibly port numbers. To prevent NAT from "breaking" when FTP is used, special
    provisions must be made to handle the protocol.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的问题是，在FTP命令（如PORT和PASV）及其回复中传递IP地址和端口号违反了网络分层原则。这不仅仅是一个哲学问题。应用程序不应该处理端口号，这在使用某些底层技术时会引发问题。例如，考虑使用网络地址转换（NAT；见[第28章](ch28.html
    "第28章. IP网络地址转换(NAT)协议"))，它修改IP地址和可能端口的情况。为了防止NAT在FTP使用时“破坏”协议，必须采取特殊措施来处理该协议。
- en: FTP General Data Communication and Transmission Modes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP通用数据通信和传输模式
- en: Once a data connection has been established between the server-DTP and the user-DTP,
    data is sent directly from the client to the server, or the server to the client,
    depending on the specific command issued. Since control information is sent using
    the distinct control channel, the entire data channel can be used for data communication.
    (These two logical channels are multiplexed at lower layers along with all other
    TCP and User Datagram Protocol (UDP) connections on both devices, so this doesn't
    actually represent a performance improvement over a single channel.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在服务器-DTP和用户-DTP之间建立了数据连接，数据就会直接从客户端发送到服务器，或从服务器发送到客户端，具体取决于发出的特定命令。由于控制信息使用单独的控制通道发送，因此整个数据通道都可以用于数据通信。（这两个逻辑通道在底层与设备上的所有其他TCP和用户数据报协议（UDP）连接一起复用，因此这实际上并不代表性能上的提升。）
- en: 'FTP defines three different *transmission modes* (also called *transfer modes*)
    that specify exactly how data is sent from one device to another over an open
    data channel: *stream mode, block mode*, and *compressed mode*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: FTP定义了三种不同的*传输模式*（也称为*传输模式*），这些模式精确地指定了数据如何在开放数据通道中从一个设备发送到另一个设备：*流模式、块模式*和*压缩模式*。
- en: Stream Mode
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流模式
- en: In stream mode, data is sent simply as a continuous stream of unstructured bytes.
    The sending device simply starts pushing data across the TCP data connection to
    the recipient. No message format with distinct header fields is used, making this
    method quite different from the way many other protocols send information in discrete
    chunks. It relies strongly on the data streaming and reliable transport services
    of TCP. Since there is no header structure, the end of the file is indicated simply
    by the sending device closing the data connection when it is done.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在流模式下，数据被简单地作为无结构的字节流连续发送。发送设备只需开始将数据推送到TCP数据连接的接收方。不使用具有不同标题字段的报文格式，这使得这种方法与其他许多协议以离散块发送信息的方式大不相同。它强烈依赖于TCP的数据流和可靠传输服务。由于没有标题结构，文件结束的指示仅由发送设备在完成时关闭数据连接来表示。
- en: 'Of the three modes, stream is by far the most widely used in real FTP implementations,
    for three main reasons:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种模式中，流模式在现实FTP实现中是最广泛使用的，主要原因有三：
- en: It is the default and also the simplest method, so it is the easiest to implement
    and is required for compatibility.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是默认的，也是最简单的方法，因此最容易实现，并且对于兼容性是必需的。
- en: It is the most general, because it treats all files as simple streams of bytes
    without paying attention to their content.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是最通用的，因为它将所有文件视为简单的字节流，而不关注其内容。
- en: It is the most efficient method because no bytes are wasted on overhead such
    as headers.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是最有效的方法，因为不会浪费任何字节在标题等开销上。
- en: Block Mode
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块模式
- en: Block mode is a more conventional data transmission mode, in which data is broken
    into data blocks and encapsulated into individual FTP blocks, or records. Each
    record has a three-byte header that indicates its length and contains information
    about the data blocks being sent. A special algorithm is used to keep track of
    the transmitted data and to detect and restart an interrupted transfer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 块模式是一种更传统的数据传输模式，其中数据被分成数据块，并封装成单独的FTP块或记录。每个记录都有一个三字节的标题，指示其长度并包含有关正在发送的数据块的信息。使用一种特殊的算法来跟踪传输的数据，并检测和重新启动中断的传输。
- en: Compressed Mode
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩模式
- en: Compressed mode is a transmission mode in which a relatively simple compression
    technique called *run-length encoding* is used to detect repeated patterns in
    the data being sent, which then represents data in such a way that the overall
    message takes fewer bytes. The compressed information is sent in a way similar
    to block mode, using a header-plus-payload record format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩模式是一种传输模式，其中使用一种称为 *运行长度编码* 的相对简单的压缩技术来检测正在发送的数据中的重复模式，然后以这种方式表示数据，使得整体消息的字节数更少。压缩信息以类似于块模式的方式发送，使用标题加有效负载记录格式。
- en: Compressed mode seems on the surface to be useful. In practice, however, compression
    is often implemented in other places in a typical networking software stack, making
    it unnecessary in FTP. For example, if you are transferring a file over the Internet
    using an analog modem, your modem normally performs compression down at layer
    1\. Large files on FTP servers are also often already compressed using something
    like the ZIP format, meaning further compression would serve no purpose.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，压缩模式似乎很有用。然而，在实践中，压缩通常在网络软件堆栈的其他地方实现，使得在 FTP 中变得不必要。例如，如果你正在使用模拟调制解调器通过互联网传输文件，你的调制解调器通常在第一层执行压缩。FTP
    服务器上的大文件也经常使用类似 ZIP 格式的某种东西进行压缩，这意味着进一步的压缩没有意义。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** FTP includes three different *transmission modes: stream, block*,
    and *compressed*. In stream mode, the most commonly used mode, data is sent as
    a continuous sequence of bytes. In block mode, data is formatted into blocks with
    headers. In compressed mode, bytes are compacted using run-length encoding.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP 包含三种不同的 *传输模式：流模式、块模式和压缩模式*。在流模式下，这是最常用的模式，数据以连续的字节序列发送。在块模式下，数据被格式化为带有标题的块。在压缩模式下，字节使用运行长度编码进行压缩。'
- en: 'FTP Data Representation: Data Types, Format Control, and Data Structures'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 数据表示：数据类型、格式控制和数据结构
- en: The most general way of designing FTP would have been to make it treat all files
    as "black boxes." A file would be represented as just as a set of bytes. FTP would
    pay no attention to what the file contained and would simply move the file, one
    byte at a time, from one place to another. In this scenario, FTP would seem to
    be very similar to the Copy command that is implemented on most file systems,
    which likewise creates a copy without looking into the file to see what it contains.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 设计 FTP 的最通用方式可能是将其设计为将所有文件视为“黑盒”。文件将被表示为一组字节。FTP 不会关注文件包含的内容，而是一字节一字节地将文件从一个地方移动到另一个地方。在这种情况下，FTP
    似乎与大多数文件系统上实现的复制命令非常相似，后者同样创建一个副本，而不会查看文件的内容。
- en: So what would be the problem with that, you may wonder? Well, for some types
    of files, this is exactly what we want, but for others, it introduces a problem.
    Certain types of files use different representations on different systems. If
    you copy a file from one place to another on the same computer using a Copy command,
    there is no problem, because the same representation for files is used everywhere
    within that computer. But when you copy it to a computer that uses a different
    representation, you may encounter difficulties.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这会有什么问题呢？你可能想知道。嗯，对于某些类型的文件，这正是我们想要的，但对于其他文件，这会引入问题。某些类型的文件在不同的系统上使用不同的表示形式。如果你在同一台电脑上使用复制命令从一个地方复制文件到另一个地方，就没有问题，因为在该电脑内部，文件使用的是相同的表示形式。但是，当你将其复制到使用不同表示形式的电脑上时，你可能会遇到困难。
- en: 'The most common example of this is a type of file that may surprise you: simple
    text files. All ASCII text files use the ASCII character set, but they differ
    in the control characters used to mark the end of a line of text. On UNIX, a line
    feed (LF) character is used; on Apple computers, a carriage return (CR) is used;
    and Windows machines use both (CR+LF).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子可能会让你感到惊讶：简单的文本文件。所有 ASCII 文本文件都使用 ASCII 字符集，但它们在标记文本行结束的控制字符上有所不同。在 UNIX
    上，使用换行符（LF）；在苹果电脑上，使用回车符（CR）；而 Windows 机器则两者都使用（CR+LF）。
- en: If you move a text file from one type of system to another using regular FTP,
    the data will all get moved exactly as it is. Moving a text file from a UNIX system
    to a PC as just a set of bytes would mean programs would not properly recognize
    end-of-line markers. To avoid this predicament, FTP moves past the idea that all
    files are just bytes and incorporates some intelligence to handle different types
    of files. The FTP standard recognizes this by allowing the specification of certain
    details about a file's internal representation prior to transfer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用常规FTP将文本文件从一个系统类型移动到另一个系统，数据将完全按照原样移动。将文本文件从UNIX系统移动到PC作为一组字节意味着程序将无法正确识别行结束标记。为了避免这种困境，FTP超越了所有文件只是字节的想法，并融入了一些智能来处理不同类型的文件。FTP标准通过允许在传输之前指定有关文件内部表示的一些细节来认可这一点。
- en: FTP Data Types
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP数据类型
- en: 'The first piece of information that can be provided about a file is its *data
    type*, which dictates the overall representation of the file. Four different data
    types are specified in the FTP standard:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件可以提供的第一条信息是其*数据类型*，它决定了文件的整体表示。FTP标准中指定了四种不同的数据类型：
- en: '**ASCII** This data type defines an ASCII text file, with lines marked by some
    sort of end-of-line marker.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASCII** 此数据类型定义了一个ASCII文本文件，行由某种类型的行结束标记标记。'
- en: '**EBCDIC** Conceptually, EBCDIC is the same as the ASCII type, but it is used
    for files using IBM''s EBCDIC character set.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**EBCDIC** 从概念上讲，EBCDIC与ASCII类型相同，但它用于使用IBM的EBCDIC字符集的文件。'
- en: '**Image** With the image data type, the file has no formal internal structure
    and is sent one byte at a time without any processing; this is the black box mode
    mentioned earlier.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像** 使用图像数据类型，文件没有正式的内部结构，并且每次发送一个字节，没有任何处理；这就是之前提到的黑盒模式。'
- en: '**Local** This data type is used to handle files that may store data in logical
    bytes containing a number of bits other than eight. Specifying this type along
    with the way the data is structured allows the data to be stored on the destination
    system in a manner consistent with its local representation.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地** 此数据类型用于处理可能存储在包含多于八个比特的逻辑字节中的数据的文件。指定此类型以及数据结构的方式允许数据以与本地表示一致的方式存储在目标系统上。'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The term byte conventionally refers to eight bits, but strictly speaking,
    the term used to describe eight bits is octet. A byte may in fact contain a number
    of bits other than eight on certain systems. For details, see "Binary Information
    and Representation: Bits, Bytes, Nibbles, Octets, and Characters" in [Chapter 4](ch04.html
    "Chapter 4. A REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING")*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*术语字节传统上指代八个比特，但严格来说，描述八个比特的术语是八位组。在某些系统中，一个字节实际上可能包含多于八个比特。有关详细信息，请参阅[第4章](ch04.html
    "第4章. 数据表示和计算数学的回顾")中的“二进制信息和表示：比特、字节、半字节、八位组和字符”*。'
- en: In practice, the two data types most often used are ASCII and image. The ASCII
    type is used for text files, and allows them to be moved between systems with
    line-end codes converted automatically. The Image type is used for generic binary
    files, such as graphical images, ZIP files, and other data that is represented
    in a universal manner. It is also often called the *binary* type for that reason.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，最常使用的两种数据类型是ASCII和图像。ASCII类型用于文本文件，并允许它们在自动转换行结束码的系统之间移动。图像类型用于通用二进制文件，例如图形图像、ZIP文件以及其他以通用方式表示的数据。因此，它也常被称为*二进制*类型。
- en: ASCII Data Type Line-Delimiting Issues
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASCII数据类型行分隔问题
- en: When the ASCII data type is used, differences in internal representations between
    systems are handled by using a universal external representation that acts as
    a common language. Lines of the file being transmitted are converted by the sending
    FTP process from the sender's internal representation to the neutral ASCII representation
    used by the Telnet Protocol (NETASCII), with each line ending in CR+LF. The receiving
    device then converts from this neutral representation to the internal format used
    by the recipient file system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ASCII数据类型时，系统之间内部表示的差异通过使用一种通用的外部表示来处理，这种表示充当一种通用语言。正在传输的文件行由发送FTP进程从发送方的内部表示转换为Telnet协议（NETASCII）使用的中性ASCII表示，每行以CR+LF结束。接收设备然后将此中性表示转换为接收方文件系统使用的内部格式。
- en: For example, when using FTP to move a text file from a Macintosh to a UNIX system,
    each line would have the CR changed to a CR+LF for transmission over the FTP data
    channel. The receiving UNIX system would change each CR+LF to just LF so UNIX
    programs could read it properly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用FTP将文本文件从Macintosh传输到UNIX系统时，每行中的CR都会被转换为CR+LF，以便通过FTP数据通道进行传输。接收的UNIX系统会将每个CR+LF转换为仅LF，以便UNIX程序能够正确读取。
- en: Note that because of these changes, the resulting file can be bigger or smaller
    than the original if it is transferred between systems using ASCII mode. Also,
    since FTP works by converting to a neutral representation for universality, sending
    an ASCII file from a UNIX system to a UNIX system means each LF is changed to
    CR+LF for transmission, and then it's changed back to LF by the recipient. It's
    slightly inefficient, but not that big a deal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这些变化，如果使用ASCII模式在不同系统之间传输，生成的文件可能比原始文件大或小。此外，由于FTP通过转换为通用表示来工作，因此从UNIX系统发送ASCII文件到UNIX系统意味着每个LF都会被转换为CR+LF进行传输，然后接收方会将其转换回LF。这稍微有点低效，但不是什么大问题。
- en: It's very important that the correct data type be specified with the appropriate
    user command. Sending a text file between dissimilar systems without setting the
    ASCII mode will result in either a file that cannot be properly read on the destination
    or one that contains stray characters. Conversely, binary files must be sent in
    binary mode. If you send something like a ZIP file or a JPG graphic in ASCII mode,
    the FTP software will think it is a text file. It will treat the file as if it
    were text, and each time it encounters bytes in the file that look like CR, LF,
    or CR+LF, it will convert them, which you do not want. (Having the wrong data
    type set is a leading cause of corrupted files when using FTP to move files between
    PCs and UNIX systems. I know from experience!)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用适当的用户命令指定正确的数据类型非常重要。在没有设置ASCII模式的情况下，在类似系统之间发送文本文件会导致在目标系统上无法正确读取的文件，或者包含杂乱字符的文件。相反，二进制文件必须以二进制模式发送。如果您以ASCII模式发送类似ZIP文件或JPG图形，FTP软件会认为它是一个文本文件。它会将文件当作文本处理，并且每次遇到文件中看起来像CR、LF或CR+LF的字节时，都会将其转换，而这正是您不希望发生的。（设置错误的数据类型是使用FTP在PC和UNIX系统之间移动文件时文件损坏的主要原因之一。我有经验！）
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** FTP defines four data types: *ASCII, EBCDIC, image*, and *local.
    ASCII* and *EBCDIC* are used for text files in the ASCII and EBCDIC character
    sets, respectively. The *image* type is used for files with no specific structure.
    The local type is used for local representation. The ASCII type is important because
    it allows text files to be transferred successfully between file systems that
    may use different methods of indicating the end of a line of text. The image type,
    also called binary, is used for files that must be sent and received byte-for-byte
    with no transformation, such as executable files, graphics, and files with arbitrary
    formats.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP定义了四种数据类型：*ASCII、EBCDIC、图像*和*本地*。*ASCII*和*EBCDIC*分别用于ASCII和EBCDIC字符集中的文本文件。*图像*类型用于没有特定结构的文件。本地类型用于本地表示。ASCII类型很重要，因为它允许在可能使用不同方法指示文本行结束的文件系统之间成功传输文本文件。图像类型，也称为二进制，用于必须逐字节发送和接收且不进行转换的文件，例如可执行文件、图形和任意格式的文件。'
- en: FTP Format Control
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP格式控制
- en: For the ASCII and EBCDIC types, FTP defines an optional parameter called *format
    control*, which allows a user to specify a particular representation for how vertical
    formatting is used to describe a file. The format control option was created to
    handle files transferred from host devices to printers. It is not used today,
    to my knowledge (or if it is used, it is used only in special applications).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ASCII和EBCDIC类型，FTP定义了一个可选参数，称为*格式控制*，允许用户指定用于描述文件的特定表示方式，以使用垂直格式。格式控制选项是为了处理从主机设备传输到打印机的文件而创建的。据我所知，今天不再使用（或者如果使用，也仅限于特殊应用）。
- en: 'Three options can be used in this control:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用三种选项进行此控制：
- en: '**Non Print** This is the default, indicating no vertical formatting.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**非打印** 这是默认设置，表示没有垂直格式。'
- en: '**Telnet Format** The file uses vertical format control characters, as specified
    in the Telnet Protocol.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Telnet格式** 文件使用Telnet协议中指定的垂直格式控制字符。'
- en: '**Carriage Control/FORTRAN** The file uses format control characters given
    as the first character of each line, as specified for the FORTRAN programming
    language.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**回车控制/FORTRAN** 文件使用格式控制字符，作为每行的第一个字符，如FORTRAN编程语言中指定的那样。'
- en: FTP Data Structures
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP数据结构
- en: 'In addition to specifying a file''s data type, it is also possible to specify
    the file''s *data structure* in three ways:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定文件的数据类型外，还可以以三种方式指定文件的数据结构：
- en: '**File Structure** The file is a contiguous stream of bytes with no internal
    structure. This is the default and is used for most types of files.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件结构** 文件是一个没有内部结构的连续字节流。这是默认设置，用于大多数类型的文件。'
- en: '**Record Structure** The file consists of a set of sequential records, each
    of which is delimited by an end-of-record marker. The record structure can be
    used for ASCII text files, but these are more commonly sent with the regular file
    structure using the ASCII data type.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录结构** 文件由一系列顺序记录组成，每个记录都由一个记录结束标记分隔。记录结构可用于ASCII文本文件，但这些文件更常见的是使用ASCII数据类型与常规文件结构一起发送。'
- en: '**Page Structure** The file contains a set of special indexed data pages. This
    structure is not commonly used; it was initially created for a now archaic type
    of computer used in the early ARPAnet.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面结构** 文件包含一组特殊索引数据页面。这种结构不常用；它最初是为早期ARPAnet中使用的现已过时的计算机类型创建的。'
- en: FTP Internal Command Groups and Protocol Commands
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 内部命令组和协议命令
- en: Once a connection is established between an FTP server and user, all communication
    to manage the operation of the protocol takes place over the control channel.
    The user-PI sends *protocol commands* to the server-PI, which processes them and
    takes appropriate action. The server-PI responds with *reply codes* to tell the
    user-PI the result of the commands it issued and convey other important information.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦FTP服务器与用户之间建立连接，所有用于管理协议操作的通信都将在控制通道中进行。用户-PI向服务器-PI发送*协议命令*，服务器-PI处理这些命令并采取适当的行动。服务器-PI以*回复代码*的形式响应，告知用户-PI其发出的命令的结果，并传达其他重要信息。
- en: Interestingly, the actual transmission of FTP commands over the control channel
    is done using specifications based on the Telnet Protocol. You may recall from
    the "FTP Overview, History, and Standards" section earlier in this chapter that
    Telnet and FTP are two of the very oldest TCP/IP applications, the former being
    for direct network use and the latter for indirect resource access. They were
    developed at around the same time, and setting up the FTP control channel to act
    as a type of Telnet connection is a good example of how Internet standards try
    not to reinvent the wheel.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，FTP命令在控制通道中的实际传输是使用基于Telnet协议的规范进行的。您可能还记得本章前面的“FTP概述、历史和标准”部分，Telnet和FTP是两个非常古老的TCP/IP应用程序，前者用于直接网络使用，后者用于间接资源访问。它们是在大约同一时间开发的，而设置FTP控制通道以作为Telnet连接的一种类型，是互联网标准试图不重复造轮子的一个很好的例子。
- en: FTP Command Groups and Commands
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP命令组和命令
- en: 'Each command is identified by a short, three- or four-letter *command code*
    for convenience, and the command performs a specific task in the overall functionality
    of FTP. Several dozen of these protocol commands are available, and to help organize
    them, the FTP standard categorizes them into three groups, based on overall function
    type:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都通过一个简短的三或四字母*命令代码*来识别，以便于使用，并且命令在FTP的整体功能中执行特定的任务。有几十个这样的协议命令可用，为了帮助组织它们，FTP标准根据整体功能类型将它们分为三组：
- en: '**Access Control Commands** Commands that are part of the user login and authentication
    process, are used for resource access, or are part of general session control.
    See [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP Access
    Control Commands").'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**访问控制命令** 这些命令是用户登录和身份验证过程的一部分，用于资源访问，或是一般会话控制的一部分。参见[表72-1](ch72s07.html#ftp_access_control_commands
    "表72-1. FTP访问控制命令")。'
- en: '**Transfer Parameter Commands** Commands that specify parameters for how data
    transfers should occur. For example, commands in this group specify the data type
    of a file to be sent, indicate whether passive or active data connections will
    be used, and so forth. See [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands").'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输参数命令** 指定数据传输参数的命令。例如，本组中的命令指定要发送的文件的数据类型，指示是否使用被动或主动数据连接，等等。参见[表72-2](ch72s07.html#ftp_transfer_parameter_commands
    "表72-2. FTP传输参数命令")。'
- en: '**FTP Service Commands** Commands that actually perform file operations, such
    as sending and receiving files, and to implement support functions, such as deleting
    or renaming files. This is the largest group. See [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands").'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**FTP服务命令** 执行实际文件操作的命令，例如发送和接收文件，以及实现支持功能，如删除或重命名文件。这是最大的组。见[表72-3](ch72s07.html#ftp_protocol_service_commands
    "表72-3. FTP协议服务命令")。'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** FTP operation is controlled through the issuing of *protocol
    commands* from the FTP client to the FTP server. Each command has a three- or
    four-letter command code that indicates its function. The commands are organized
    into three groups: *access control commands* used for login and general session
    control, *transfer parameter commands* that control how transfers are performed,
    and *FTP service commands* that are used to perform actual file operations.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP操作通过FTP客户端向FTP服务器发出*协议命令*来控制。每个命令都有一个三或四字母的命令代码，表示其功能。命令被组织成三个组：*访问控制命令*用于登录和一般会话控制，*传输参数命令*用于控制传输方式，以及*FTP服务命令*用于执行实际文件操作。'
- en: Since the commands are based on the Telnet specifications, they are sent as
    plain text, as specified by Telnet's Network Virtual Terminal (NVT) conventions.
    Tables [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP
    Access Control Commands"), [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands"), and [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands") list and describe the FTP internal
    protocol commands in the access control, transfer parameters, and service command
    groups. They are shown in the order that they appear in the FTP standard (RFC
    959).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些命令基于Telnet规范，它们按照Telnet的网络虚拟终端(NVT)约定以纯文本形式发送。表[表72-1](ch72s07.html#ftp_access_control_commands
    "表72-1. FTP访问控制命令")、[表72-2](ch72s07.html#ftp_transfer_parameter_commands "表72-2.
    FTP传输参数命令")和[表72-3](ch72s07.html#ftp_protocol_service_commands "表72-3. FTP协议服务命令")列出并描述了FTP内部协议命令，包括访问控制、传输参数和服务命令组。它们按照在FTP标准（RFC
    959）中出现的顺序展示。
- en: Table 72-1. FTP Access Control Commands
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-1. FTP访问控制命令
- en: '| Command Code | Command | Description |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| USER | User name | Identifies the user attempting to establish an FTP session.
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| USER | 用户名 | 识别尝试建立FTP会话的用户。|'
- en: '| PASS | Password | Specifies the password for the user given previously by
    the USER command during login authentication. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| PASS | 密码 | 在登录认证期间指定由USER命令之前给出的用户的密码。|'
- en: '| ACCT | Account | Specifies an account for an authenticated user during the
    FTP session. Used only on systems that require this to be separately identified;
    most select an account automatically based on the name entered in the USER command.
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ACCT | 账户 | 在FTP会话期间指定已验证用户的账户。仅在需要单独识别的系统上使用；大多数系统根据USER命令中输入的名称自动选择账户。|'
- en: '| CWD | Change working directory | Allows the user to specify a different directory
    for file transfer during an FTP session. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| CWD | 更改工作目录 | 允许用户在FTP会话期间指定不同的目录进行文件传输。|'
- en: '| CDUP | Change to parent directory ("change directory up") | A special case
    of the CWD command that goes to the directory one level up in the server''s directory
    structure. It is implemented separately to abstract out differences in directory
    structures between file systems; the user can use CDUP instead of knowing the
    specific syntax for navigating up the directory tree on the server. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| CDUP | 切换到父目录（"更改目录向上"） | CWD命令的特殊情况，用于进入服务器目录结构中的一级目录。它被单独实现，以抽象出不同文件系统之间的目录结构差异；用户可以使用CDUP而不是知道在服务器上导航目录树的具体语法。|'
- en: '| SMNT | Structure mount | Allows the user to mount a particular file system
    for access to different resources. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| SMNT | 结构挂载 | 允许用户挂载特定的文件系统以访问不同的资源。|'
- en: '| REIN | Reinitialize | Reinitializes the FTP session, flushing all set parameters
    and user information. This returns the session to the state when the control connection
    is just established. It is, in essence, the opposite of the USER command. The
    next command issued is often USER, to log in a different user. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| REIN | 重新初始化 | 重新初始化FTP会话，清除所有设置的参数和用户信息。这使会话回到控制连接刚刚建立时的状态。本质上，它是USER命令的相反操作。接下来的命令通常是USER，用于登录不同的用户。|'
- en: '| QUIT | Logout | Terminates the FTP session and closes the control connection.
    Note that the naming of this command was unfortunate. The REIN command is really
    most similar to a conventional logout command, as it terminates a logged-in user
    and allows another user to log in. In contrast, the QUIT command shuts down the
    entire session. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| QUIT | 登出 | 终止FTP会话并关闭控制连接。请注意，此命令的命名是不幸的。REIN命令实际上与传统的登出命令最为相似，因为它终止已登录用户并允许其他用户登录。相比之下，QUIT命令关闭整个会话。|'
- en: Table 72-2. FTP Transfer Parameter Commands
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-2. FTP传输参数命令
- en: '| Command Code | Command | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| PORT | Data port | Used to tell the FTP server that the client wants to accept
    an active data connection on a specific port number. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| PORT | 数据端口 | 用于告诉FTP服务器客户端希望在特定端口号上接受一个主动数据连接。|'
- en: '| PASV | Passive | Requests that the FTP server allow the user-DTP to initiate
    passive data connections. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| PASV | 被动 | 请求FTP服务器允许用户-DTP发起被动数据连接。|'
- en: '| TYPE | Representation type | Specifies for the file to be transferred the
    data type (ASCII, EBCDIC, image, or local), and optionally the format control
    (Non Print, Telnet, or Carriage Control). |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| TYPE | 表示类型 | 指定要传输的文件的数据类型（ASCII、EBCDIC、图像或本地），以及可选的格式控制（非打印、Telnet或换行控制）。|'
- en: '| STRU | File structure | Specifies the data structure for the file (file,
    record, or page). |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| STRU | 文件结构 | 指定文件的数据结构（文件、记录或页面）。|'
- en: '| MODE | Transfer mode | Specifies the transmission mode to be used (stream,
    block, or compressed). |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| MODE | 传输模式 | 指定要使用的传输模式（流、块或压缩）。|'
- en: Table 72-3. FTP Protocol Service Commands
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-3. FTP协议服务命令
- en: '| Command Code | Command | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| RETR | Retrieve | Tells the server to send the user a file. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| RETR | 下载 | 告诉服务器向用户发送一个文件。|'
- en: '| STOR | Store | Sends a file to the server. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| STOR | 存储 | 向服务器发送一个文件。|'
- en: '| STOU | Store unique | Like STOR, but instructs the server to make sure the
    file has a unique name in the current directory. This is used to prevent overwriting
    a file that may already exist with the same name. The server replies back with
    the name used for the file. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| STOU | 存储唯一 | 与STOR类似，但指示服务器确保文件在当前目录中有唯一的名称。这用于防止覆盖可能已经存在的同名文件。服务器会回复用于文件的名称。|'
- en: '| APPE | Append (with create) | Like STOR, but if a file with the name specified
    already exists, the data being sent is appended to it instead of replacing it.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| APPE | 追加（与创建一起） | 与STOR类似，但如果指定的文件名已存在，则发送的数据将附加到它而不是替换它。|'
- en: '| ALLO | Allocate | An optional command used to reserve storage on the server
    before a file is sent. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ALLO | 分配 | 一个可选命令，用于在发送文件之前在服务器上预留存储空间。|'
- en: '| REST | Restart | Restarts a file transfer at a particular server marker.
    Used only for block or compressed transfer modes. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| REST | 重新启动 | 在特定的服务器标记处重新启动文件传输。仅用于块或压缩传输模式。|'
- en: '| RNFR | Rename from | Specifies the old name of a file to be renamed. See
    the RNTO command. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| RNFR | 重命名自 | 指定要重命名的文件的旧名称。参见RNTO命令。|'
- en: '| RNTO | Rename to | Specifies the new name of a file to be renamed. Used with
    the RNFR command. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| RNTO | 重命名到 | 指定要重命名的文件的新的名称。与RNFR命令一起使用。|'
- en: '| ABOR | Abort | Tells the server to abort the last FTP command and/or the
    current data transfer. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| ABOR | 中断 | 告诉服务器中断最后一个FTP命令和/或当前的数据传输。|'
- en: '| DELE | Delete | Deletes a specified file on the server. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| DELE | 删除 | 在服务器上删除指定的文件。|'
- en: '| RMD | Remove directory | Deletes a directory on the server. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| RMD | 删除目录 | 在服务器上删除一个目录。|'
- en: '| MKD | Make directory | Creates a directory. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| MKD | 创建目录 | 创建一个目录。|'
- en: '| PWD | Print working directory | Displays the current server working directory
    for the FTP session; shows the users where they are in the server''s file system.
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| PWD | 打印工作目录 | 显示FTP会话的当前服务器工作目录；显示用户在服务器文件系统中的位置。|'
- en: '| LIST | List | Requests a list of the contents of the current directory from
    the server, including both names and other information. Similar in concept to
    the `DIR` command in DOS/Windows or the `ls` command in UNIX. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| LIST | 列表 | 请求从服务器获取当前目录的内容列表，包括名称和其他信息。在概念上类似于DOS/Windows中的`DIR`命令或UNIX中的`ls`命令。|'
- en: '| NLST | Name list | Like LIST, but returns only the names in a directory.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| NLST | 名称列表 | 与LIST类似，但仅返回目录中的名称。|'
- en: '| SITE | Site parameters | Used to implement site-specific functions. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| SITE | 站点参数 | 用于实现特定站点的功能。|'
- en: '| SYST | System | Requests that the server send to the client information about
    the server''s operating system. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| SYST | 系统 | 请求服务器向客户端发送有关服务器操作系统的信息。|'
- en: '| STAT | Status | Prompts the server to send an indication of the status of
    a file or the transfer currently in progress. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| STAT | 状态 | 提示服务器发送关于当前正在进行的文件或传输状态的指示。|'
- en: '| HELP | Help | Asks the server for any help information that might be useful
    in allowing the user to determine how the server should be used. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| HELP | 帮助 | 向服务器请求可能有助于用户确定如何使用服务器的任何帮助信息。|'
- en: '| NOOP | No operation | Does nothing, other than prompting the server to send
    an "OK" response to verify that the control channel is alive. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| NOOP | 无操作 | 不执行任何操作，除了提示服务器向客户端发送一个“OK”响应以验证控制通道是否活跃。|'
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*FTP commands are not case-sensitive, but they have been shown in uppercase
    for clarity in Tables [Table 72-1](ch72s07.html#ftp_access_control_commands "Table 72-1. FTP
    Access Control Commands"), [Table 72-2](ch72s07.html#ftp_transfer_parameter_commands
    "Table 72-2. FTP Transfer Parameter Commands"), and [Table 72-3](ch72s07.html#ftp_protocol_service_commands
    "Table 72-3. FTP Protocol Service Commands")*.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*FTP命令对大小写不敏感，但在表格[表72-1](ch72s07.html#ftp_access_control_commands "表72-1.
    FTP访问控制命令")、[表72-2](ch72s07.html#ftp_transfer_parameter_commands "表72-2. FTP传输参数命令")和[表72-3](ch72s07.html#ftp_protocol_service_commands
    "表72-3. FTP协议服务命令")中为了清晰起见，已显示为大写字母*。'
- en: FTP commands are all sent between FTP elements; they are not usually issued
    directly by users. Instead, a special set of user commands is employed for this
    purpose. The FTP user interface implements the link between the user and the user-FTP
    process, including the translation of user commands into FTP commands. We'll explore
    these commands later in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: FTP命令都是在FTP元素之间发送的；它们通常不是由用户直接发出的。相反，使用一套特殊的用户命令来完成这个目的。FTP用户界面实现了用户与用户-FTP进程之间的连接，包括将用户命令转换为FTP命令。我们将在本章后面探讨这些命令。
- en: FTP Replies
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP响应
- en: 'Each time the user-PI sends a command to the server-PI over the control connection,
    the server sends back a reply. FTP replies serve three main purposes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户-PI通过控制连接向服务器-PI发送命令时，服务器都会发送一个回复。FTP响应有三个主要用途：
- en: They serve as confirmation that the server received a command.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们作为服务器已接收命令的确认。
- en: They tell the user device whether or not the command was accepted, and if an
    error occurred, what it was.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们告诉用户设备命令是否被接受，如果发生错误，错误是什么。
- en: They communicate various types of information to the user of the session, such
    as the status of a transfer.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将各种类型的信息传达给会话用户，例如传输的状态。
- en: Advantages of Using Both Text and Numeric Replies
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文本和数字响应的优点
- en: For a human user, a string of reply text would be sufficient to satisfy the
    requirements just mentioned, and FTP replies do include descriptive text. But
    having only a text string would make it difficult or impossible for FTP software
    on the client side to interpret results coming from the server. FTP was designed
    to allow software applications to interact with each other over the FTP command
    link. For this reason, the protocol's reply system uses *reply codes*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类用户来说，一串回复文本就足以满足上述要求，FTP响应确实包括描述性文本。但只有文本字符串会使客户端的FTP软件难以或无法解释来自服务器的结果。FTP被设计成允许软件应用程序通过FTP命令链相互交互。因此，该协议的回复系统使用*响应代码*。
- en: FTP reply codes are three-digit numeric responses that can be easily interpreted
    by a computer program. They are also useful for human users who are familiar with
    FTP, because they communicate at a glance the results of various operations. While
    each FTP server implementation may differ in the text sent for each type of reply,
    the reply codes are used in a consistent manner based on the specifications of
    the FTP standard. It is, therefore, the codes that are examined to determine the
    results of a command; the text is just descriptive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: FTP响应代码是三位数字响应，可以很容易地被计算机程序解释。它们对熟悉FTP的人类用户也很有用，因为它们可以一目了然地传达各种操作的结果。虽然每个FTP服务器实现可能对每种类型响应发送的文本不同，但响应代码的使用方式是基于FTP标准的规范。因此，检查代码以确定命令的结果；文本只是描述性的。
- en: Reply Code Structure and Digit Interpretation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应代码结构和数字解释
- en: To make reply codes even more useful, they are not just assigned in a linear
    or random order. Rather, a special encoding scheme is used, in which each code
    has three digits that each communicate a particular type of information and categorize
    replies. A code can be considered to be of the form *xyz*, where *x* is the first
    digit, *y* is the second, and *z* is the third.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使回复代码更加有用，它们不是按线性或随机顺序分配的。相反，使用了一种特殊的编码方案，其中每个代码有三个数字，每个数字都传达特定类型的信息并对回复进行分类。一个代码可以被认为是*xyz*的形式，其中*x*是第一位数字，*y*是第二位，*z*是第三位。
- en: 'The first digit indicates the success or failure of the command in general
    terms, whether a successful command is complete or incomplete, and whether or
    not an unsuccessful command should be retried. [Table 72-4](ch72s08.html#ftp_reply_code_format_first_digit_interp
    "Table 72-4. FTP Reply Code Format: First Digit Interpretation") shows the possible
    values.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一位数字表示命令在一般意义上的成功或失败，成功的命令是否完整，以及是否应该重试失败的命令。[表72-4](ch72s08.html#ftp_reply_code_format_first_digit_interp
    "表72-4. FTP回复代码格式：第一位数字解释")显示了可能的值。
- en: 'Table 72-4. FTP Reply Code Format: First Digit Interpretation'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-4. FTP回复代码格式：第一位数字解释
- en: '| Reply Code Format | Meaning | Description |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 回复代码格式 | 含义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1yz | Positive preliminary reply | An initial response indicating that the
    command has been accepted and processing is still in progress. The user should
    expect another reply before a new command may be sent. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1yz | 正初步回复 | 表示命令已被接受且处理仍在进行中的初始响应。用户应在发送新命令之前期待另一个回复。 |'
- en: '| 2yz | Positive completion reply | The command has been successfully processed
    and completed. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 2yz | 正完成回复 | 命令已成功处理并完成。 |'
- en: '| 3yz | Positive intermediate reply | The command was accepted, but processing
    has been delayed, pending receipt of additional information. This type of reply
    is used in the middle of command sequences. For example, it is used as part of
    the authentication sequence after receiving a USER command but before the matching
    PASS command is sent. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 3yz | 正中间回复 | 命令已被接受，但处理已被延迟，等待接收更多信息。这种回复用于命令序列的中间。例如，在收到USER命令后但在发送匹配的PASS命令之前，它用作身份验证序列的一部分。
    |'
- en: '| 4yz | Transient negative completion reply | The command was not accepted
    and no action was taken, but the error is temporary and the command may be tried
    again. This is used for errors that may be a result of temporary glitches or conditions
    that may change—for example, a file being busy due to another resource accessing
    it at the time a request was made for it. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 4yz | 临时负完成回复 | 命令未被接受且未采取任何行动，但错误是临时的，可以再次尝试该命令。这用于可能是暂时故障或可能改变的条件所导致的错误——例如，当请求文件时，由于其他资源正在访问它，文件正忙。
    |'
- en: '| 5yz | Permanent negative completion reply | The command was not accepted
    and no action was taken. Trying the same command again is likely to result in
    another error. For example, a request for a file that is not found on the server,
    or sending an invalid command like BUGU, would fall into this category. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 5yz | 永久负完成回复 | 命令未被接受且未采取任何行动。再次尝试相同的命令很可能会导致另一个错误。例如，请求服务器上找不到的文件，或发送无效命令（如BUGU）将属于此类。
    |'
- en: 'The second digit of the reply code is used to categorize messages into functional
    groups. These groups are shown in [Table 72-5](ch72s08.html#ftp_reply_code_format_second_digit_inter
    "Table 72-5. FTP Reply Code Format: Second Digit Interpretation").'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 回复代码的第二位数字用于将消息分类到功能组中。这些组在[表72-5](ch72s08.html#ftp_reply_code_format_second_digit_inter
    "表72-5. FTP回复代码格式：第二位数字解释")中显示。
- en: 'Table 72-5. FTP Reply Code Format: Second Digit Interpretation'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-5. FTP回复代码格式：第二位数字解释
- en: '| Reply Code Format | Meaning | Description |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 回复代码格式 | 含义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| x0z | Syntax | Syntax errors or miscellaneous messages |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| x0z | 语法 | 语法错误或杂项消息 |'
- en: '| x1z | Information | Replies to requests for information, such as status requests
    |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| x1z | 信息 | 对信息请求的回复，如状态请求 |'
- en: '| x2z | Connections | Replies related to the control connection or data connection
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| x2z | 连接 | 与控制连接或数据连接相关的回复 |'
- en: '| x3z | Authentication and accounting | Replies related to login procedures
    and accounting |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| x3z | 认证和计费 | 与登录程序和计费相关的回复 |'
- en: '| x4z | Unspecified | Not defined |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| x4z | 未指定 | 未定义 |'
- en: '| x5z | File system | Replies related to the server''s file system |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| x5z | 文件系统 | 与服务器文件系统相关的回复 |'
- en: The third digit indicates a specific type of message within each of the functional
    groups described by the second digit. The third digit allows each functional group
    to have ten different reply codes for each reply type given by the first code
    digit (preliminary success, transient failure, and so on).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个数字表示第二个数字描述的功能组中的特定消息类型。第三个数字允许每个功能组对于第一个代码数字（初步成功、暂时性失败等）给出的每种回复类型都有十个不同的回复代码。
- en: These *x, y*, and *z* digit meanings are combined to make specific reply codes.
    For example, consider reply code 530, diagrammed in [Figure 72-5](ch72s08.html#ftp_reply_code_format_this_diagram_shows
    "Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP
    reply code format is interpreted. In reply code 530, the 5 indicates a permanent
    error, the 3 specifies that the error is related to authentication or accounting,
    and the 0 is the specific error type. A similar method is used for reply codes
    in many other TCP/IP application protocols, including the Simple Mail Transfer
    Protocol (SMTP) and Hypertext Transfer Protocol (HTTP)."). The first digit tells
    you that this is a permanent negative reply, and the second indicates that it
    is related to login or accounting. (It is, in fact, an error message received
    when a login fails.) The third digit tells you the specific type of error that
    has occurred.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*x, y*和*z*数字含义的组合形成了特定的回复代码。例如，考虑回复代码530，如图[图72-5](ch72s08.html#ftp_reply_code_format_this_diagram_shows
    "图72-5. FTP回复代码格式 此图展示了三位FTP回复代码格式的解释。在回复代码530中，数字5表示永久错误，数字3指定错误与认证或计费相关，而数字0是具体的错误类型。在许多其他TCP/IP应用协议中，包括简单邮件传输协议（SMTP）和超文本传输协议（HTTP）的回复代码中，也使用了类似的方法。")。第一个数字告诉你这是一个永久性负面回复，第二个数字表示它与登录或计费相关。（实际上，这是在登录失败时接收到的错误消息。）第三个数字告诉你发生了特定类型的错误。
- en: '![FTP reply code format This diagram shows how the three-digit FTP reply code
    format is interpreted. In reply code 530, the 5 indicates a permanent error, the
    3 specifies that the error is related to authentication or accounting, and the
    0 is the specific error type. A similar method is used for reply codes in many
    other TCP/IP application protocols, including the Simple Mail Transfer Protocol
    (SMTP) and Hypertext Transfer Protocol (HTTP).](httpatomoreillycomsourcenostarchimages288269.png.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![FTP回复代码格式 此图展示了三位FTP回复代码格式的解释。在回复代码530中，数字5表示永久错误，数字3指定错误与认证或计费相关，而数字0是具体的错误类型。在许多其他TCP/IP应用协议中，包括简单邮件传输协议（SMTP）和超文本传输协议（HTTP）的回复代码中，也使用了类似的方法。](httpatomoreillycomsourcenostarchimages288269.png.jpg)'
- en: Figure 72-5. FTP reply code format This diagram shows how the three-digit FTP
    reply code format is interpreted. In reply code 530, the 5 indicates a permanent
    error, the 3 specifies that the error is related to authentication or accounting,
    and the 0 is the specific error type. A similar method is used for reply codes
    in many other TCP/IP application protocols, including the Simple Mail Transfer
    Protocol (SMTP) and Hypertext Transfer Protocol (HTTP).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图72-5. FTP回复代码格式 此图展示了三位FTP回复代码格式的解释。在回复代码530中，数字5表示永久错误，数字3指定错误与认证或计费相关，而数字0是具体的错误类型。在许多其他TCP/IP应用协议中，包括简单邮件传输协议（SMTP）和超文本传输协议（HTTP）的回复代码中，也使用了类似的方法。
- en: Using encoded reply codes allows the code itself to communicate information
    immediately and provides a way of keeping different types of responses organized.
    This idea was adapted for use by several other application protocols, including
    the Simple Mail Transfer Protocol (SMTP) for email, the Network News Transfer
    Protocol (NNTP) for network news, and the Hypertext Transfer Protocol (HTTP) for
    the World Wide Web.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编码的回复代码允许代码本身立即传达信息，并提供了一种保持不同类型响应组织的方式。这个想法被其他几个应用协议所采用，包括用于电子邮件的简单邮件传输协议（SMTP）、用于网络新闻的网络新闻传输协议（NNTP）和用于万维网的超文本传输协议（HTTP）。
- en: '[Table 72-6](ch72s08.html#ftp_reply_codes "Table 72-6. FTP Reply Codes") contains
    a list of some of the more common FTP reply codes taken from RFC 959\. They are
    shown in numerical order, along with the reply text presented as typical in that
    document and additional descriptive information as needed.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[表72-6](ch72s08.html#ftp_reply_codes "表72-6. FTP回复代码") 包含了从RFC 959中摘取的一些更常见的FTP回复代码列表。它们按数字顺序排列，并展示了在该文档中作为典型示例的回复文本以及所需的其他描述性信息。'
- en: Table 72-6. FTP Reply Codes
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-6. FTP回复代码
- en: '| Reply Code | Typical Reply Text | Description |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 回复代码 | 典型回复文本 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 110 | Restart marker reply. | Used as part of the marker restart feature
    when transferring in block mode. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 重启标记回复。 | 在块模式下传输时作为标记重启功能的一部分使用。 |'
- en: '| 120 | Service ready in *nnn* minutes. | *nnn* indicates the number of minutes
    until the service will be available. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 120 | 服务在 *nnn* 分钟后就绪。 | *nnn* 表示服务将可用的分钟数。 |'
- en: '| 125 | Data connection already open; transfer starting. |   |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 125 | 数据连接已打开；传输开始。 |   |'
- en: '| 150 | File status okay; about to open data connection. |   |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 150 | 文件状态正常；即将打开数据连接。 |   |'
- en: '| 200 | Command okay. | Sometimes the text indicates the name of the command
    that was successful. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 200 | 命令正常。 | 有时文本会指示成功执行的命令名称。 |'
- en: '| 202 | Command not implemented, or superfluous at this site. |   |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 202 | 命令未实现，或在此站点多余。 |   |'
- en: '| 211 | System status, or system help reply. | Will contain system-specific
    status or help information. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 211 | 系统状态，或系统帮助回复。 | 将包含特定于系统的状态或帮助信息。 |'
- en: '| 212 | Directory status. |   |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 212 | 目录状态。 |   |'
- en: '| 213 | File status. |   |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 213 | 文件状态。 |   |'
- en: '| 214 | Help message. | Includes help information of use to a human user of
    this server. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 214 | 帮助信息。 | 包括对服务器的人类用户有用的帮助信息。 |'
- en: '| 215 | *NAME* system type. | *NAME* is the name of a type of operating system.
    Often sent as a reply to the SYST command. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 215 | *NAME* 系统类型。 | *NAME* 是操作系统类型名称。通常在响应 SYST 命令时发送。 |'
- en: '| 220 | Service ready for new user. | Sent when the command channel is established
    before the USER command is sent. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 220 | 服务就绪，等待新用户。 | 在发送 USER 命令之前建立命令通道时发送。 |'
- en: '| 221 | Service closing control connection. | A "goodbye" message is sent when
    the session is closed. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 221 | 服务关闭控制连接。 | 在会话关闭时发送“再见”消息。 |'
- en: '| 225 | Data connection open; no transfer in progress. |   |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 225 | 数据连接已打开；没有传输进行。 |   |'
- en: '| 226 | Closing data connection. | Sent after a successful file transfer or
    a file abort. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 226 | 关闭数据连接。 | 在成功传输文件或文件中止后发送。 |'
- en: '| 227 | Entering Passive Mode (h1,h2,h3,h4,p1,p2). | Sent in reply to the PASV
    command, indicates the IP address and port to use for the data connection. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 227 | 进入被动模式（h1,h2,h3,h4,p1,p2）。 | 作为对 PASV 命令的回复发送，指示用于数据连接的 IP 地址和端口号。
    |'
- en: '| 230 | User logged in, proceed. | Sent after successful USER and PASS authentication.
    Systems often include additional greeting or other information with this code
    after a login. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 230 | 用户已登录，继续。 | 在成功进行 USER 和 PASS 认证后发送。系统通常在登录后使用此代码发送额外的问候或其他信息。 |'
- en: '| 250 | Requested file action okay, completed. | The text description will
    provide more details about what was successfully done, such as confirming a change
    of directory or deleted file. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 250 | 请求的文件操作正常，完成。 | 文本描述将提供有关成功完成的更多详细信息，例如确认更改目录或已删除文件。 |'
- en: '| 257 | *PATHNAME* created. | *PATHNAME* is replaced by the path created. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 257 | *PATHNAME* 已创建。 | *PATHNAME* 被替换为创建的路径。 |'
- en: '| 331 | User name okay, need password. | Intermediate result after sending
    USER but before sending PASS. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 331 | 用户名正确，需要密码。 | 在发送 USER 但在发送 PASS 之前的中继结果。 |'
- en: '| 332 | Need account for login. |   |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 332 | 需要账户登录。 |   |'
- en: '| 350 | Requested file action pending further information. |   |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 350 | 请求的文件操作待进一步信息。 |   |'
- en: '| 421 | Service not available, closing control connection. | Sometimes sent
    if the FTP server is in the process of shutting down. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 421 | 服务不可用，关闭控制连接。 | 有时在 FTP 服务器正在关闭的过程中发送。 |'
- en: '| 425 | Can''t open data connection. |   |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 425 | 无法打开数据连接。 |   |'
- en: '| 426 | Connection closed; transfer aborted. |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 426 | 连接关闭；传输已取消。 |   |'
- en: '| 450 | Requested file action not taken. File unavailable. | The file is not
    available; for example, it may be locked by another user. Contrast to reply code
    550. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 450 | 请求的文件操作未执行。文件不可用。 | 文件不可用；例如，它可能被另一个用户锁定。与回复代码 550 对比。 |'
- en: '| 451 | Requested action aborted: local error in processing. |   |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 451 | 请求的操作已取消：处理中的本地错误。 |   |'
- en: '| 452 | Requested action not taken. Insufficient storage space in system. |
    The file system is full. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 452 | 请求的操作未执行。系统存储空间不足。 | 文件系统已满。 |'
- en: '| 500 | Syntax error, command unrecognized. | Bad or excessively long command
    line was sent. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 语法错误，命令不可识别。 | 发送了不良或过长的命令行。 |'
- en: '| 501 | Syntax error in parameters or arguments. |   |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 501 | 参数或参数中的语法错误。 |   |'
- en: '| 502 | Command not implemented. |   |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 502 | 命令未实现。 |   |'
- en: '| 503 | Bad sequence of commands. |   |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 503 | 命令序列错误。 |   |'
- en: '| 504 | Command not implemented for that parameter. |   |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 504 | 对于该参数未实现命令。 |   |'
- en: '| 530 | Not logged in. | Sent if authentication fails due to a bad user name
    or incorrect password. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 530 | 未登录。| 如果由于用户名错误或密码不正确而导致身份验证失败，则发送。|'
- en: '| 550 | Requested action not taken. File unavailable. | File was not found
    or user does not have access to it. This error code may be sent in reply to any
    file transfer command if the user has not successfully logged in yet. Contrast
    to reply code 450. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 550 | 请求的操作未执行。文件不可用。| 文件未找到或用户无法访问。此错误代码可能在用户尚未成功登录时作为对任何文件传输命令的回复发送。与回复代码
    450 相对比。|'
- en: '| 551 | Requested action aborted: page type unknown. |   |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 551 | 请求的操作被终止：页面类型未知。| |'
- en: '| 552 | Requested file action aborted. Exceeded storage allocation. |   |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 552 | 请求的文件操作被终止。超出存储分配。| |'
- en: '| 553 | Requested action not taken. File name not allowed. |   |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 553 | 请求的操作未执行。文件名不允许。| |'
- en: Tip
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each command sent by the FTP client results in a reply sent
    by the FTP server. FTP replies consist of a three-digit numeric *reply code*,
    along with a line of descriptive text. The reply code serves to standardize FTP
    replies, both so they can be interpreted by client software and so experienced
    users can see at a glance the results of a command. The reply code is structured
    so that the first two digits indicate the type of reply and to what category it
    belongs.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个由 FTP 客户端发送的命令都会导致 FTP 服务器发送一个回复。FTP 回复由一个三位数的数字 *回复代码* 和一行描述性文本组成。回复代码用于标准化
    FTP 回复，以便它们可以被客户端软件解释，并且经验丰富的用户可以一眼看出命令的结果。回复代码的结构使得前两位数字表示回复的类型及其所属的类别。'
- en: FTP Multiple-Line Text Replies
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FTP 多行文本回复
- en: It is possible for a reply to contain more than one line of text. In this case,
    each line starts with the reply code, and all lines but the last have a hyphen
    between the reply code and the reply text, to indicate that the reply continues.
    The last line includes a space between the reply code and reply text, just like
    a single-line reply. This facility is often used to provide additional response
    information after a user logs in, via the 230 reply code. [Example 72-1](ch72s08.html#ftp_multiple-line_text_reply_example
    "Example 72-1. FTP multiple-line text reply example") contains an example.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 回复可能包含多行文本。在这种情况下，每一行都以回复代码开头，除了最后一行之外，回复代码和回复文本之间有一个连字符，以表示回复的继续。最后一行在回复代码和回复文本之间包含一个空格，就像单行回复一样。此功能通常用于用户登录后通过
    230 回复代码提供额外的响应信息。[示例 72-1](ch72s08.html#ftp_multiple-line_text_reply_example
    "示例 72-1. FTP 多行文本回复示例") 包含了一个示例。
- en: Example 72-1. FTP multiple-line text reply example
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 72-1. FTP 多行文本回复示例
- en: '[PRE0]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As I mentioned, the actual text string for each reply code is implementation-specific.
    You can sometimes find some rather humorous text strings associated with some
    of these error messages. For example, I tried some commands using the FreeBSD
    FTP client on one of my Internet accounts. I tried to send or receive a file before
    I was logged in, and it didn''t return an error like "Requested action not taken.
    File unavailable." Instead, it told me this: "Login first, then I might let you
    do that."'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，每个回复代码的实际文本字符串是特定于实现的。有时你可以找到一些与这些错误消息相关的一些相当幽默的文本字符串。例如，我尝试使用我的一个互联网账户上的
    FreeBSD FTP 客户端发送了一些命令。在我登录之前，我尝试发送或接收一个文件，它没有返回像“请求的操作未执行。文件不可用。”这样的错误，而是告诉我：“先登录，然后我可能让你做那件事。”
- en: FTP User Interface and User Commands
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 用户界面和用户命令
- en: The FTP command set provides a rich, complete set of instructions for implementing
    FTP. A human user could employ these commands to perform file-transfer functions
    directly with an FTP server. But to do this, the user must have an intimate knowledge
    of how FTP works. The user must know exactly which commands to send at which time,
    and in what order.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 命令集提供了一套丰富、完整的指令，用于实现 FTP。一个人类用户可以使用这些命令直接与 FTP 服务器执行文件传输功能。但要做到这一点，用户必须对
    FTP 的工作方式有深入了解。用户必须确切知道在何时发送哪些命令，以及它们的顺序。
- en: 'Gaining knowledge of internal FTP commands might be a reasonable assignment
    for an internetworking expert, but not for a typical TCP/IP application user.
    For this reason, the FTP protocol defines an additional protocol component as
    part of the user-FTP process: the FTP *user interface*. It provides three main
    benefits to the FTP user:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 了解内部 FTP 命令可能是一个网络专家的合理任务，但不是典型 TCP/IP 应用程序用户的任务。因此，FTP 协议定义了一个额外的协议组件，作为用户-FTP
    过程的一部分：FTP *用户界面*。它为 FTP 用户提供了三个主要好处：
- en: '**User Friendliness** The FTP user interface presents FTP to the human user
    in a way that is easier and simpler to use than issuing protocol commands. Instead
    of requiring the knowledge of all those four-letter codes, the user interface
    can allow functions to be performed with more intuitive human-language commands.
    For example, we can say `get` a file instead of having to use the command RETR.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户友好性** FTP 用户界面以比发出协议命令更容易、更简单的方式向人类用户展示 FTP。用户界面不需要用户了解所有那些四字母代码，可以允许使用更直观的人类语言命令来执行功能。例如，我们可以说
    `get` 一个文件，而不是必须使用 RETR 命令。'
- en: '**Customization** The command used to perform a particular function can be
    customized based on common parlance in the networking industry, without requiring
    changes to be made to FTP itself. For example, the image transfer mode is now
    also commonly called binary mode, so a user command called `binary` has been created
    to set this mode.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**定制** 执行特定功能的命令可以根据网络行业的常用术语进行定制，而无需对 FTP 本身进行更改。例如，图像传输模式现在也通常称为二进制模式，因此创建了一个名为
    `binary` 的用户命令来设置此模式。'
- en: '**Detail Abstraction and Command Sequence Simplification** A single user command
    can be made to issue multiple FTP protocol commands, hiding internal FTP details
    and making the protocol easier to use. In particular, commands that are related
    to the maintenance of the connection and other overhead issues that users don''t
    want to deal with can be automated. For example, an FTP client normally issues
    a PASV or PORT command prior to each data transfer. The user interface can take
    care of issuing this command automatically prior to a RETR or STOR command when
    a user tells FTP to get or send a file.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**细节抽象和命令序列简化** 单个用户命令可以发出多个 FTP 协议命令，隐藏内部 FTP 细节，使协议更容易使用。特别是，与维护连接和其他用户不希望处理的开销问题相关的命令可以自动化。例如，FTP
    客户端通常在每个数据传输之前发出 PASV 或 PORT 命令。用户界面可以在用户告诉 FTP 获取或发送文件时，自动在 RETR 或 STOR 命令之前发出此命令。'
- en: Command-Line and Graphical FTP Interfaces
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行和图形化 FTP 界面
- en: Traditionally, FTP clients have used a *command-line interface*. In this familiar
    arrangement, an FTP client is invoked and the user is automatically asked for
    a user name and password to establish an FTP session. Then the user is presented
    with a command prompt, where the user can type various FTP commands to perform
    different functions. Text responses from the server are displayed to the user
    to indicate the results of various commands. Normally, the internal protocol commands
    (such as PASV and STOR) sent by the client are suppressed to avoid screen clutter,
    but their display can be enabled in a debug mode.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，FTP 客户端使用 *命令行界面*。在这种熟悉的安排中，FTP 客户端被调用，用户会自动被要求输入用户名和密码以建立 FTP 会话。然后用户会看到一个命令提示符，用户可以在其中输入各种
    FTP 命令以执行不同的功能。服务器返回的文本响应会显示给用户，以指示各种命令的结果。通常，客户端发送的内部协议命令（如 PASV 和 STOR）会被抑制以避免屏幕杂乱，但在调试模式下可以启用显示。
- en: Command-line utilities are efficient, but some folks don't care for them. They
    are rather "old school" in the context of modern graphical operating systems and
    applications. Thus, many modern FTP clients are graphical in nature. They allow
    actions to be performed by the user clicking buttons instead of typing commands.
    Some FTP clients allow files to be transferred by dragging and dropping from a
    local file system display to one on a remote server. These make FTP even easier
    to use.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具效率高，但有些人并不喜欢它们。在现代图形操作系统和应用程序的背景下，它们显得有些“老式”。因此，许多现代 FTP 客户端本质上是图形化的。它们允许用户通过点击按钮而不是输入命令来执行操作。一些
    FTP 客户端允许通过从本地文件系统显示拖放到远程服务器上的显示来传输文件。这使得 FTP 更加易于使用。
- en: Tip
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The FTP *user interface* is the component on the FTP client
    that acts as an intermediary between the human user and the FTP software. The
    existence of the user interface allows FTP to be used in a friendly manner without
    requiring knowledge of FTP''s internal protocol commands. Most FTP software uses
    either a *command-line interface* that understands English-like user commands
    or a *graphical interface*, where mouse clicks and other graphical operations
    are translated into FTP commands.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** FTP *用户界面* 是 FTP 客户端中充当人类用户和 FTP 软件之间中介的组件。用户界面的存在使得 FTP 可以以友好的方式使用，而无需了解
    FTP 的内部协议命令。大多数 FTP 软件使用一种理解类似英语的用户命令的 *命令行界面* 或一种 *图形界面*，其中鼠标点击和其他图形操作被转换为 FTP
    命令。'
- en: Typical FTP User Commands
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见FTP用户命令
- en: To discover the specific commands supported by an FTP client, consult its documentation.
    In a command-line client, you can enter the command `?` to see a list of supported
    commands. [Table 72-7](ch72s09.html#common_ftp_user_commands "Table 72-7. Common
    FTP User Commands") shows some of the common commands encountered in typical FTP
    command-line clients, along with the typical parameters they require.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解FTP客户端支持的具体命令，请参阅其文档。在命令行客户端中，您可以输入命令`?`以查看支持命令的列表。[表72-7](ch72s09.html#common_ftp_user_commands
    "表72-7. 常见FTP用户命令")显示了在典型的FTP命令行客户端中遇到的常见命令，以及它们所需的典型参数。
- en: Note how many of these commands are actually synonyms, such as `bye`, `exit`,
    and `quit`. Similarly, you can use the command `type ascii` to set the ASCII data
    type or use the `ascii` command. This is all done for the user's convenience and
    is one of the benefits of having a flexible user interface that is distinct from
    the FTP command set.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些命令中有多少实际上是同义词，例如`bye`、`exit`和`quit`。同样，您可以使用命令`type ascii`来设置ASCII数据类型或使用`ascii`命令。这一切都是为了用户的方便，并且是具有与FTP命令集不同的灵活用户界面的好处之一。
- en: 'Finally, an alternative way of using FTP is through the specification of an
    FTP Uniform Resource Locator (URL). While FTP is at its heart an interactive system,
    FTP URLs allow simple functions, such as retrieving a single file, to be done
    quickly and easily. They also allow FTP file references to be integrated with
    hypertext (World Wide Web) documents. See "URL Schemes and Scheme-Specific Syntaxes"
    in [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION LAYER ADDRESSING: UNIFORM
    RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS, AND URNS)") for more on
    how FTP uses URLs.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用FTP的另一种方法是通过指定FTP统一资源定位符（URL）。虽然FTP本质上是一个交互式系统，但FTP URL允许快速简单地执行简单功能，例如检索单个文件。它们还允许将FTP文件引用与超文本（万维网）文档集成。有关FTP如何使用URL的更多信息，请参阅“URL方案和方案特定语法”部分，见[第70章](ch70.html
    "第70章. TCP/IP应用层寻址：统一资源标识符、定位符和名称（URIs、URLs和URNs）")。
- en: Table 72-7. Common FTP User Commands
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表72-7. 常见FTP用户命令
- en: '| User Command | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 用户命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `account <account-name>` | Sends the ACCT command to access a particular
    account on the server. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `account <account-name>` | 向服务器发送ACCT命令以访问特定账户。 |'
- en: '| `append <file-name>` | Appends data to a file using APPE. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `append <file-name>` | 使用APPE向文件追加数据。 |'
- en: '| `ascii` | Sets the ASCII data type for subsequent transfers. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `ascii` | 设置后续传输的ASCII数据类型。 |'
- en: '| `binary` | Sets the image data type for subsequent transfers. Same as the
    `image` command. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `binary` | 设置后续传输的图像数据类型。与`image`命令相同。 |'
- en: '| `bye` | Terminates FTP session and exits the FTP client (same as `exit` and
    `quit`). |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `bye` | 终止FTP会话并退出FTP客户端（与`exit`和`quit`相同）。 |'
- en: '| `cd <directory-path>` | Changes the remote server working directory (using
    CWD protocol command). |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `cd <directory-path>` | 使用CWD协议命令更改远程服务器的工作目录。 |'
- en: '| `cdup` | Goes to parent of current working directory. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `cdup` | 返回当前工作目录的父目录。 |'
- en: '| `chmod <file-name>` | On UNIX systems, changes file permissions of a file.
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `chmod <file-name>` | 在UNIX系统上，更改文件的权限。 |'
- en: '| `close` | Closes a particular FTP session but user stays at FTP command line.
    |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 关闭特定的FTP会话，但用户仍停留在FTP命令行。 |'
- en: '| `debug` | Sets debug mode. |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `debug` | 设置调试模式。 |'
- en: '| `delete <file-name>` | Deletes a file on the FTP server. |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `delete <file-name>` | 在FTP服务器上删除一个文件。 |'
- en: '| `dir [<optional-file-specification>]` | Lists contents of current working
    directory (or files matching the specification). |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `dir [<optional-file-specification>]` | 列出当前工作目录的内容（或匹配指定文件名的文件）。 |'
- en: '| `exit` | Another synonym for `bye` and `quit`. |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `exit` | `bye`和`quit`的另一个同义词。 |'
- en: '| `form <format>` | Sets the transfer format. |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `form <format>` | 设置传输格式。 |'
- en: '| `ftp <ftp-server>` | Opens session to the FTP server. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `ftp <ftp-server>` | 打开与FTP服务器的会话。 |'
- en: '| `get <file-name> [<dest-file-name>]` | Gets a file. If the *`<dest-file-name>`*
    parameter is specified, it is used for the name of the file retrieved; otherwise,
    the source filename is used. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `get <file-name> [<dest-file-name>]` | 获取一个文件。如果指定了*`<dest-file-name>`*参数，则用于获取文件的名称；否则，使用源文件名。
    |'
- en: '| `help [<optional-command-name>]` | Displays FTP client help information.
    Same as `?`. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `help [<optional-command-name>]` | 显示FTP客户端的帮助信息。与`?`相同。 |'
- en: '| `image` | Sets the image data type, like the `binary` command. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `image` | 设置图像数据类型，类似于`binary`命令。 |'
- en: '| `ls [<optional-file-specification>]` | Lists contents of current working
    directory (or files matching the specification). Same as `dir`. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `ls [<可选文件指定>]` | 列出当前工作目录的内容（或符合指定的文件）。等同于 `dir`。 |'
- en: '| `mget <file-specification>` | Gets multiple files from the server. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `mget <文件指定>` | 从服务器获取多个文件。 |'
- en: '| `mkdir <directory-name>` | Creates a directory on the remote server. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `mkdir <目录名>` | 在远程服务器上创建目录。 |'
- en: '| `mode` **`<transfer-mode>`** | Sets the file transfer mode. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `mode` **`<传输模式>`** | 设置文件传输模式。 |'
- en: '| `mput <file-specification>` | Sends (puts) multiple files to the server.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `mput <文件指定>` | 向服务器发送（放置）多个文件。 |'
- en: '| `msend <file-specification>` | Same as `mput`. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `msend <文件指定>` | 与 `mput` 相同。 |'
- en: '| `open <ftp-server>` | Opens a session to the FTP server (same as `ftp`).
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `open <ftp服务器>` | 打开到 FTP 服务器的会话（等同于 `ftp`）。 |'
- en: '| `passive` | Turns passive transfer mode on and off. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `passive` | 开启或关闭被动传输模式。 |'
- en: '| `put <file-name> [<dest-file-name>]` | Sends a file to the server. If the
    *`<dest-file-name>`* parameter is specified, it is used as the name for the file
    on the destination host; otherwise, the source filename is used. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `put <文件名> [<目标文件名>]` | 将文件发送到服务器。如果指定了 *`<目标文件名>`* 参数，则用作目标主机上文件的名称；否则，使用源文件名。
    |'
- en: '| `pwd` | Prints current working directory. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `pwd` | 打印当前工作目录。 |'
- en: '| `quit` | Terminates FTP session and exits FTP client (same as `bye` and `exit`).
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `quit` | 终止 FTP 会话并退出 FTP 客户端（等同于 `bye` 和 `exit`）。 |'
- en: '| `recv <file-name> [<dest-file-name>]` | Receives file (same as `get`). If
    the *`<dest-file-name>`* parameter is specified, it is used for the name of the
    file retrieved; otherwise, the source filename is used. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `recv <文件名> [<目标文件名>]` | 接收文件（等同于 `get`）。如果指定了 *`<目标文件名>`* 参数，则用作检索到的文件的名称；否则，使用源文件名。
    |'
- en: '| `rename <old-file-name> <new-file-name>` | Renames a file. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `rename <旧文件名> <新文件名>` | 重命名文件。 |'
- en: '| `rhelp` | Displays remote help information, obtained using FTP `HELP` command.
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `rhelp` | 显示远程帮助信息，使用 FTP `HELP` 命令获取。 |'
- en: '| `rmdir <directory-name>` | Removes a directory. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `rmdir <目录名>` | 删除目录。 |'
- en: '| `send <file-name> [<dest-file-name>]` | Sends a file (same as `put`). If
    the *`<dest-file-name>`* parameter is specified, it is used as the name for the
    file on the destination host; otherwise, the source file name is used. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `send <文件名> [<目标文件名>]` | 发送文件（等同于 `put`）。如果指定了 *`<目标文件名>`* 参数，则用作目标主机上文件的名称；否则，使用源文件名。
    |'
- en: '| `site` | Sends a site-specific command to the server. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `site` | 向服务器发送特定站点命令。 |'
- en: '| `size <file-name>` | Shows the size of a remote file. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `size <文件名>` | 显示远程文件的大小。 |'
- en: '| `status` | Displays current session status. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `status` | 显示当前会话状态。 |'
- en: '| `struct <structure-type>` | Sets the file structure. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `struct <结构类型>` | 设置文件结构。 |'
- en: '| `system` | Shows the server''s operating system type. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `system` | 显示服务器的操作系统类型。 |'
- en: '| `type <data-type>` | Sets the data type for transfers. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `type <数据类型>` | 设置传输的数据类型。 |'
- en: '| `user <user-name>` | Logs in to server as a new user. Server will prompt
    for a password. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `user <用户名>` | 以新用户身份登录到服务器。服务器将提示输入密码。 |'
- en: '| `? [<optional-command-name>]` | Displays FTP client help information. Same
    as `help`. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `? [<可选命令名>]` | 显示 FTP 客户端帮助信息。等同于 `help`。 |'
- en: Sample FTP Session
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 FTP 会话
- en: Having now seen all the details of how FTP works, let's tie everything together
    by looking at a sample FTP session between an FTP client and server, to see FTP
    commands and replies in action. In this example, I will invoke FTP from a client
    to retrieve a text file from an FTP server, and then I'll delete the file from
    the server and the directory that contained it. In the process, I will issue some
    additional commands to illustrate more of how FTP works. I will enable debug mode
    in the FTP client so that for each user command, you can see the actual FTP commands
    generated.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 FTP 的工作细节，让我们通过查看 FTP 客户端和服务器之间的一个示例 FTP 会话来将所有这些内容串联起来，以查看 FTP 命令和回复的实际操作。在这个例子中，我将从客户端调用
    FTP 来从 FTP 服务器检索一个文本文件，然后我会从服务器及其包含的目录中删除该文件。在这个过程中，我将发出一些额外的命令来展示 FTP 的工作方式。我将在
    FTP 客户端中启用调试模式，以便对于每个用户命令，您都可以看到实际生成的 FTP 命令。
- en: '[Table 72-8](ch72s10.html#sample_ftp_session-id001 "Table 72-8. Sample FTP
    Session") shows the sample FTP session, slightly simplified. The first column
    contains commands entered by the user (that''s me, of course) on the FTP client.
    The second shows the actual protocol command(s) sent to the FTP server in highlighted
    text and the reply returned from the server to the client in plain text. The third
    column contains descriptive comments.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 72-8](ch72s10.html#sample_ftp_session-id001 "表 72-8. 样本 FTP 会话") 展示了样本 FTP
    会话，略有简化。第一列包含用户在 FTP 客户端输入的命令（当然，那是我输入的）。第二列显示了发送到 FTP 服务器的实际协议命令（以高亮文本显示）和服务器返回给客户端的纯文本响应。第三列包含描述性注释。'
- en: Table 72-8. Sample FTP Session
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 表 72-8. 样本 FTP 会话
- en: '| User Command | FTP Protocol Command/FTP Server Reply | Comments |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 用户命令 | FTP 协议命令/FTP 服务器响应 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '| This is the command to start up FTP. The `-d` enables debug mode. In this
    initial step, the TCP control connection is made and the server replies with a
    220 reply code indicating that it''s ready for user identification. The FTP client
    automatically prompts for the user name. |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 这是启动 FTP 的命令。`-d` 选项启用调试模式。在这个初始步骤中，建立 TCP 控制连接，服务器以 220 响应码回复，表示它已准备好进行用户身份验证。FTP
    客户端会自动提示输入用户名。|'
- en: '| `ixl` |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `ixl` |'
- en: '[PRE3]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| I use `ixl` for user names commonly. Here, the FTP client sends the user
    name and the server responds, asking for the password. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 我通常使用 `ixl` 作为用户名。在这里，FTP 客户端发送用户名，服务器响应，请求密码。|'
- en: '| `****` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `****` |'
- en: '[PRE4]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| I enter my password, which is sent to the FTP server, and the server authenticates
    me and sends back a 230 message. This tells me the login was successful. It also
    provides additional information.The FTP client then automatically sends a SYST
    command to tell me what type of system the server is using, which is UNIX in this
    case. The client tells me that binary mode has been selected by default; this
    is often the default when doing FTP from UNIX to UNIX (as I am doing here), since
    there is no need for ASCII mode when moving text files between similar systems.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 我输入密码，密码被发送到 FTP 服务器，服务器验证我并发回一个 230 消息。这告诉我登录成功。它还提供了额外的信息。然后 FTP 客户端自动发送一个
    SYST 命令，告诉我服务器使用的是哪种类型的系统，在这个例子中是 UNIX。客户端告诉我默认选择了二进制模式；当从 UNIX 到 UNIX 进行 FTP
    操作时（就像我现在这样做），这通常是默认的，因为在类似系统之间移动文本文件时不需要 ASCII 模式。|'
- en: '| `pwd` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `pwd` |'
- en: '[PRE5]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| I check the current working directory (`cwd`), which the server tells me
    is my own home directory on this system. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 我检查当前工作目录（`cwd`），服务器告诉我这是该系统上的我的主目录。|'
- en: '| `cd ftptest` |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `cd ftptest` |'
- en: '[PRE6]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| I try to go to a directory called ftptest, but that was the wrong name, so
    I get a 550 error for my trouble. (I wasn''t trying to do this; I forgot the directory
    name but figured I might as well show it to you anyway!) |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 我尝试进入一个名为 ftptest 的目录，但名字错了，所以我得到了一个 550 错误。 （我并不是真的想这么做；我忘记了目录名，但我想我还是应该向你展示一下！）|'
- en: '| `cd ftpdemo` |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `cd ftpdemo` |'
- en: '[PRE7]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| I got the name right this time, and the server confirms the new working directory.
    |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 这次我输入的名字正确，服务器确认了新的工作目录。|'
- en: '| `dir` |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `dir` |'
- en: '[PRE8]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| I request a list of files from the server. The FTP client automatically issues
    a PASV command, and the server responds with a port number and IP address for
    it to use. (I have not shown the IP here for security reasons.) The directory
    listing is then transferred from the server to the client. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 我请求从服务器获取文件列表。FTP 客户端自动发出 PASV 命令，服务器响应并返回用于连接的端口号和 IP 地址。（出于安全原因，我没有在这里显示
    IP 地址。）然后目录列表从服务器传输到客户端。|'
- en: '| `asc` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `asc` |'
- en: '[PRE9]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| I set ASCII mode, although I didn''t really need to do that. Note that this
    client allowed me to abbreviate the `ascii` command as `asc`. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 我设置了 ASCII 模式，尽管我真的不需要这么做。请注意，这个客户端允许我将 `ascii` 命令缩写为 `asc`。|'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| I get the file in this demo directory using a `get` command. The server accepts
    the PASV command and sends the file. It initially sends a 150 reply as the transfer
    starts (initial positive reply), and then sends 226 when it is done. Note that
    the port numbers used here are different (for both server and client) than they
    were for the directory listing I did earlier. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 我使用 `get` 命令从这个演示目录获取文件。服务器接受 PASV 命令并发送文件。传输开始时，它最初发送一个 150 响应码（初始积极响应），完成后发送
    226 响应码。请注意，这里使用的端口号（服务器和客户端）与我之前进行的目录列表中的端口号不同。|'
- en: '|'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| I delete the original file on the server. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 我删除了服务器上的原始文件。|'
- en: '| `cdup` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `cdup` |'
- en: '[PRE14]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| I go up to the parent directory. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 我返回到父目录。|'
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| I remove the directory that the file was in. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 我删除了文件所在的目录。|'
- en: '| `quit` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `quit` |'
- en: '[PRE17]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| I end the FTP session. The `quit` command also automatically closes the FTP
    client and returns me to the UNIX shell. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 我结束了FTP会话。`quit`命令也会自动关闭FTP客户端并返回UNIX shell。|'
- en: Chapter 73. TRIVIAL FILE TRANSFER PROTOCOL (TFTP)
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第73章。简单文件传输协议 (TFTP)
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: In [Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)"), you saw
    how the File Transfer Protocol (FTP) implements a full set of commands and reply
    functionalities that enables a user to perform a wide range of file movement and
    manipulation tasks. Although FTP is ideal as a general-purpose protocol for file
    transfer between computers, on certain types of hardware, it is too complex to
    implement easily and provides more capabilities than are really needed. In cases
    where only the most basic file transfer functions are required while simplicity
    and small program size is of paramount importance, a companion to FTP called the
    *Trivial File Transfer Protocol (TFTP)* can be used.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第72章](ch72.html "第72章。文件传输协议 (FTP)")中，你看到了文件传输协议（FTP）如何实现一套完整的命令和回复功能，使用户能够执行一系列文件移动和操作任务。尽管FTP作为计算机之间文件传输的通用协议是理想的，但在某些类型的硬件上，它过于复杂，难以轻松实现，并且提供了实际上并不需要的更多功能。在只需要最基本文件传输功能，而简洁性和小程序大小至关重要的场合，可以使用FTP的伴侣协议，即*简单文件传输协议
    (TFTP)*。
- en: This chapter provides a description of the operation of TFTP, beginning with
    an overview description of the protocol, its history and motivation, and the relevant
    standards that describe it. I discuss its operation in general terms, cover how
    TFTP clients and servers communicate, and explain TFTP messaging in detail. I
    then discuss TFTP options and the TFTP option negotiation mechanism. The chapter
    concludes by showing the various TFTP message formats.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对TFTP操作的描述，从对协议的概述描述开始，包括其历史和动机，以及描述它的相关标准。我以一般性术语讨论其操作，涵盖TFTP客户端和服务器如何通信，并详细解释TFTP消息。然后讨论TFTP选项和TFTP选项协商机制。本章最后展示了各种TFTP消息格式。
- en: Tip
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *While TFTP is a distinct protocol from FTP, explaining
    the former is easier when the reader is familiar with the latter. I assume that
    the reader has some understanding of FTP, since it is the more commonly used protocol.
    If you have come to this chapter prior to reading [Chapter 72](ch72.html "Chapter 72. FILE
    TRANSFER PROTOCOL (FTP)"), I recommend at least reading the section "FTP Overview,
    History, and Standards" in that chapter before proceeding here*.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *虽然TFTP与FTP是不同的协议，但读者熟悉FTP时解释前者更容易。我假设读者对FTP有一些了解，因为它是更常用的协议。如果你在阅读[第72章](ch72.html
    "第72章。文件传输协议 (FTP)")之前来到这一章，我建议至少阅读该章节中的“FTP概述、历史和标准”部分，然后再继续阅读*。'
- en: TFTP Overview, History, and Standards
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP概述、历史和标准
- en: FTP is the main protocol used for the majority of general file transfers in
    TCP/IP internetworks. One of the objectives of the designers of FTP was to keep
    the protocol relatively simple, but that was possible only to a limited extent.
    To enable the protocol to be useful in a variety of cases and between many kinds
    of devices, FTP needed a fairly large set of features and capabilities. As a result,
    while FTP is not as complex as certain other protocols, it is still fairly complicated
    in a number of respects.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: FTP是TCP/IP互联网中大多数通用文件传输所使用的主要协议。FTP设计者的一个目标是将协议保持相对简单，但这只可能在一定程度上实现。为了使协议能够在各种情况下以及许多类型的设备之间有用，FTP需要一套相当大的功能和特性。因此，虽然FTP不像某些其他协议那样复杂，但在许多方面仍然相当复杂。
- en: Why TFTP Was Needed
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要TFTP
- en: The complexity of FTP is partly due to the protocol itself, with its dozens
    of commands and reply codes, and partly due to the need of using TCP for connections
    and data transport. The reliance on TCP means that any device wanting to use FTP
    needs not only the FTP program but a full TCP implementation as well. It must
    handle FTP's need for simultaneous data and control channel connections and other
    requirements.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: FTP的复杂性部分源于其自身协议，拥有数十条命令和回复代码，部分源于需要使用TCP进行连接和数据传输。对TCP的依赖意味着任何想要使用FTP的设备不仅需要FTP程序，还需要完整的TCP实现。它必须处理FTP对同时数据和控制通道连接的需求以及其他要求。
- en: For a conventional computer, such as a regular PC, Macintosh, or UNIX workstation,
    none of this is really an issue, especially with today's large hard disks and
    fast, cheap memory. But remember that FTP was developed more than three decades
    ago, when hardware was slow and memory was expensive. Furthermore, even today,
    regular computers are not the only devices used on networks. Some networked devices
    do not have the capabilities of true computers, but they still need to be able
    to perform file transfers. For these devices, a full FTP and TCP implementation
    is a nontrivial matter.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统的计算机，如常规PC、Macintosh或UNIX工作站，这些问题实际上并不重要，尤其是在今天的大硬盘和快速、廉价的内存的情况下。但请记住，FTP是在三十多年前开发的，当时硬件速度慢，内存昂贵。此外，即使在今天，常规计算机也不是网络中使用的唯一设备。一些网络设备没有真正的计算机功能，但它们仍然需要能够执行文件传输。对于这些设备，完整的FTP和TCP实现是一个非平凡的问题。
- en: One of the most notable examples of such devices are *diskless workstations*—computers
    that have no permanent storage, so when they start up, they cannot read a whole
    TCP/IP implementation from a hard disk like most computers easily do. They start
    with only a small amount of built-in software and must obtain configuration information
    from a server and then download the rest of their software from another network
    device. The same issue arises for certain other hardware devices with no hard
    disks.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设备的显著例子之一是*无盘工作站*——没有永久存储的计算机，因此当它们启动时，它们不能像大多数计算机那样轻松地从硬盘读取整个TCP/IP实现。它们仅从少量内置软件开始，必须从服务器获取配置信息，然后从另一个网络设备下载其余的软件。对于某些没有硬盘的硬件设备，也存在同样的问题。
- en: The process of starting up these devices is commonly called *bootstrapping*
    and occurs in two phases. First, the workstation is provided with an IP address
    and other parameters through the use of a host configuration protocol such as
    the Bootstrap Protocol (BOOTP; see [Chapter 60](ch60.html "Chapter 60. TCP/IP
    BOOTSTRAP PROTOCOL (BOOTP)")) or the Dynamic Host Control Protocol (DHCP; see
    Chapters [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION
    CONCEPTS") to [Chapter 64](ch64.html "Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION,
    FEATURES, AND IPV6 SUPPORT")). Second, the client downloads software, such as
    an operating system and drivers, that let it function on the network like any
    other device. This requires that the device have the ability to transfer files
    quickly and easily. The instructions to perform this bootstrapping must fit onto
    a read-only memory (ROM) chip, and this makes the size of the software an important
    issue—again, especially many years ago.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 启动这些设备的过程通常被称为*引导*，并分为两个阶段。首先，工作站通过使用主机配置协议，如引导协议（BOOTP；参见[第60章](ch60.html "第60章。TCP/IP
    引导协议 (BOOTP)"))或动态主机控制协议（DHCP；参见第[第61章](ch61.html "第61章。DHCP 概述和地址分配概念")至[第64章](ch64.html
    "第64章。DHCP 客户端/服务器实现、功能和 IPv6 支持"))，获得一个IP地址和其他参数。其次，客户端下载软件，例如操作系统和驱动程序，使其能够在网络上像其他设备一样运行。这要求设备能够快速且轻松地传输文件。执行此引导的指令必须适合写入只读存储器（ROM）芯片，这也使得软件的大小成为一个重要问题——再次强调，尤其是在许多年前。
- en: The solution to this need was to create a "light" version of FTP that would
    emphasize small program size and simplicity over functionality. This new protocol,
    TFTP, was initially developed in the late 1970s and first standardized in 1980\.
    The modern version, *TFTP version 2*, was documented in RFC 783 in 1981, which
    was revised and published as RFC 1350, "The TFTP Protocol (Revision 2)," in 1992\.
    This is the current version of the standard.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一需求，创建了一个“轻量级”的FTP版本，该版本强调小程序大小和简单性，而不是功能性。这种新协议TFTP最初在20世纪70年代末开发，并于1980年首次标准化。现代版本*TFTP版本2*在1981年的RFC
    783中进行了记录，该文件在1992年被修订并发布为RFC 1350，“TFTP协议（修订2）”。这是当前标准的版本。
- en: Comparing FTP and TFTP
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较FTP和TFTP
- en: Probably the best way to understand the relationship between TFTP and FTP is
    to compare it to the relationship between the Transmission Control Protocol (TCP)
    and User Datagram Protocol (UDP) at the transport layer. UDP is a simplified,
    stripped-down alternative to TCP that is used when simplicity is more important
    than rich functionality. Similarly, TFTP is a greatly simplified version of FTP
    that allows only basic operations and lacks some of FTP's fancy capabilities in
    order to keep its implementation easy (even trivial) and its program size small.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 TFTP 和 FTP 之间关系最好的方法可能是将其与传输控制协议（TCP）和用户数据报协议（UDP）在传输层的关系进行比较。UDP 是 TCP 的简化、精简的替代品，当简单性比丰富功能更重要时使用。同样，TFTP
    是 FTP 的极大简化版本，只允许基本操作，并缺乏 FTP 的一些复杂功能，以保持其实施简单（甚至简单）且程序大小小。
- en: Due to its limitations, TFTP is a complement to FTP, not a replacement for it.
    TFTP is used only when its simplicity is important and its lack of features is
    not. Its most common application is bootstrapping, as described above, though
    it can be used for other purposes. One specific application that the TFTP standard
    describes for the protocol is the transport of electronic mail (email). While
    the protocol supports this explicitly, TFTP is not generally used for this purpose
    today.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其局限性，TFTP 是 FTP 的补充，而不是替代品。只有在简单性很重要而功能不足不是问题时才会使用 TFTP。它最常见的应用是引导，如上所述，尽管它可以用于其他目的。TFTP
    标准为该协议描述的一个特定应用是传输电子邮件（电子邮件）。虽然该协议明确支持这一点，但今天 TFTP 并不通常用于此目的。
- en: 'FTP and TFTP have significant differences in at least four significant areas:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: FTP 和 TFTP 在至少四个重要方面存在显著差异：
- en: '**Transport** The comparison to TCP and UDP is apt not only based on the features/simplicity
    trade-off, but because FTP uses TCP for transport while TFTP uses UDP. Like TFTP,
    UDP is simple, and this makes the two ideal for embedding together as a hardware
    program set in a network device.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输** 与 TCP 和 UDP 的比较不仅基于功能/简单性权衡，而且因为 FTP 使用 TCP 进行传输，而 TFTP 使用 UDP。与 TFTP
    一样，UDP 简单，这使得两者非常适合在网络设备中作为硬件程序集嵌入。'
- en: '**Limited Command Set** FTP includes a rich set of commands to allow files
    to be sent, received, renamed, deleted, and so forth. TFTP allows files only to
    be sent and received.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限的命令集** FTP 包含丰富的命令集，允许文件发送、接收、重命名、删除等操作。TFTP 只允许文件发送和接收。'
- en: '**Limited Data Representations** TFTP does not include some of FTP''s fancy
    data representation options; it allows only simple ASCII or binary file transfers.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限的数据表示** TFTP 不包括 FTP 的一些复杂数据表示选项；它只允许简单的 ASCII 或二进制文件传输。'
- en: '**Lack of Authentication** UDP uses no login mechanism or other means of authentication.
    This is again a simplification, though it means the operators of TFTP servers
    must severely restrict the files they make available for access. (It is also part
    of why TFTP specifically does not allow the client to perform dangerous file operations
    such as deletion.)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺乏认证** UDP 不使用登录机制或其他认证手段。这又是一种简化，尽管这意味着 TFTP 服务器运营商必须严格限制他们提供的可访问文件。（这也是为什么
    TFTP 明确不允许客户端执行如删除等危险文件操作的原因。）'
- en: Overview of TFTP Operation
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP 操作概述
- en: Communication and messaging in TFTP is very different from FTP because of the
    different transport layer protocols used by each. FTP makes use of TCP's rich
    functionality, including its stream data orientation, to allow it to send bytes
    of data directly over the FTP data connection. TCP also takes care of reliable
    delivery of data for FTP, ensuring that files are received correctly. In contrast,
    since TFTP uses UDP, it must package data into individual messages for both protocol
    control and data communication. TFTP must also take care of timing transmissions
    to detect lost datagrams and then retransmitting as needed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个协议使用的传输层协议不同，TFTP 中的通信和消息与 FTP 非常不同。FTP 利用 TCP 的丰富功能，包括其流数据方向，允许它直接通过 FTP
    数据连接发送数据字节。TCP 还负责为 FTP 确保数据的可靠传输，确保文件正确接收。相比之下，由于 TFTP 使用 UDP，它必须将数据打包成单独的消息，用于协议控制和数据通信。TFTP
    还必须注意传输时间，以检测丢失的数据报，并在需要时重新传输。
- en: TFTP servers allow connections from TFTP clients to perform file send and receive
    operations. Many hosts that run FTP servers will also run a separate TFTP server
    module. TFTP users initiate connections by starting a TFTP client program, which
    generally uses a command-line interface similar to that of many FTP clients; the
    main difference is the much smaller number of commands in TFTP.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP服务器允许TFTP客户端建立连接以执行文件发送和接收操作。许多运行FTP服务器的宿主机也会运行一个单独的TFTP服务器模块。TFTP用户通过启动TFTP客户端程序来发起连接，该程序通常使用类似于许多FTP客户端的命令行界面；主要区别是TFTP中的命令数量要少得多。
- en: Tip
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** For situations in which the full FTP is either unnecessary
    or impractical, the simpler *Trivial File Transfer Protocol (TFTP)* was developed.
    TFTP is like FTP in that it is used for general file transfer between a client
    and server device, but it is stripped down in its capabilities. Rather than including
    a full command set and using TCP for communication, like FTP, TFTP can be used
    only for reading or writing a single file, and it uses the fast but unreliable
    UDP for transport. It is often preferred in situations where small files must
    be transferred quickly and simply, such as for bootstrapping diskless workstations.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 对于全FTP既不必要也不实用的场合，开发了更简单的*Trivial File Transfer Protocol (TFTP)*。TFTP与FTP类似，因为它用于客户端和服务器设备之间的通用文件传输，但其功能被简化了。与FTP不同，它包含完整的命令集并使用TCP进行通信，TFTP只能用于读取或写入单个文件，并且它使用快速但不可靠的UDP进行传输。在需要快速且简单地传输小文件的情况下，如引导无盘工作站，它通常更受欢迎。'
- en: The basic operation of TFTP has not changed since RFC 1350 was published, but
    a new feature was added to the protocol in 1995\. RFC 1782, "TFTP Option Extension,"
    defines a mechanism by which a TFTP client and TFTP server can negotiate certain
    parameters that will control a file transfer prior to the transfer commencing.
    This allows more flexibility in how TFTP is used, adding a slight amount of complexity
    to TFTP, but not a great deal.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 自从RFC 1350发布以来，TFTP的基本操作没有改变，但在1995年该协议中增加了一个新功能。RFC 1782，“TFTP选项扩展”定义了一种机制，通过该机制TFTP客户端和TFTP服务器可以在传输开始之前协商某些参数，这些参数将控制文件传输。这增加了TFTP的使用灵活性，给TFTP增加了一点点复杂性，但不是很多。
- en: 'The option extension is backward-compatible with regular TFTP and is used only
    if both server and client support it. Two subsequent RFCs define the actual options
    that can be negotiated: RFC 1783, "TFTP Blocksize Option," and RFC 1784, "TFTP
    Timeout Interval and Transfer Size Options." This set of three RFCs (1782, 1783,
    and 1784) was replaced in 1998 by updated versions in RFCs 2347, 2348, and 2349.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 选项扩展与常规TFTP向后兼容，并且仅在服务器和客户端都支持它时才使用。两个随后的RFC定义了可以协商的实际选项：RFC 1783，“TFTP块大小选项”和RFC
    1784，“TFTP超时间隔和传输大小选项”。这组三个RFC（1782、1783和1784）在1998年被RFC 2347、2348和2349中的更新版本所取代。
- en: TFTP General Operation, Connection Establishment, and Client/Server Communication
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP通用操作，连接建立和客户端/服务器通信
- en: 'Since the *T* in *TF TP* stands for *Trivial*, and the protocol was specifically
    designed to be simple, you would think that describing how it works would, in
    fact, be simple, wouldn''t you? And, actually, that''s pretty much true. TFTP
    communication is client/server based, as discussed in the overview. The process
    of transferring a file consists of three main phases:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在*TF TP*中的*T*代表*Trivial*，并且该协议被特别设计为简单，你可能认为描述它是如何工作的实际上应该是简单的，不是吗？实际上，这基本上是正确的。TFTP通信是基于客户端/服务器的，如概述中所述。文件传输的过程包括三个主要阶段：
- en: '**Initial Connection** The TFTP client establishes the connection by sending
    an initial request to the server. The server responds back to the client, and
    the connection is effectively opened.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始连接** TFTP客户端通过向服务器发送初始请求来建立连接。服务器回应客户端，连接实际上就打开了。'
- en: '**Data Transfer** Once the connection is established, the client and server
    exchange TFTP messages. One device sends data, and the other sends acknowledgments.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据传输** 一旦建立连接，客户端和服务器交换TFTP消息。一个设备发送数据，另一个发送确认。'
- en: '**Connection Termination** When the last TFTP message containing data has been
    sent and acknowledged, the connection is terminated.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接终止** 当发送并确认了包含数据的最后一个TFTP消息后，连接就被终止了。'
- en: Connection Establishment and Identification
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接建立和识别
- en: The matter of a connection is somewhat different in TFTP than it is with a protocol
    like FTP that uses TCP. FTP must establish a connection at the TCP level before
    anything can be done by FTP itself. TFTP, however, uses the connectionless UDP
    for transport, so there is no connection in the sense that one exists in TCP.
    In TFTP, the connection is more in a *logical* sense, meaning that the client
    and server are participating in the protocol and exchanging TFTP messages.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在TFTP中，连接的问题与使用TCP的FTP等协议有所不同。FTP必须在TCP级别建立连接之后才能执行任何操作。然而，TFTP使用无连接的UDP进行传输，因此在TCP中存在的那种连接不存在。在TFTP中，连接更多是在*逻辑*意义上，意味着客户端和服务器正在参与协议并交换TFTP消息。
- en: The TFTP server listens continuously for requests on well-known UDP port number
    69, which is reserved for TFTP. The client chooses for its initial communication
    an ephemeral port number, as is usually the case in TCP/IP. This port number actually
    identifies the data transfer and is called a *transfer identifier (TID)*.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP服务器持续监听在知名UDP端口号69上的请求，该端口号是为TFTP保留的。客户端在初始通信时选择一个临时端口号，这在TCP/IP中通常是这种情况。这个端口号实际上标识了数据传输，被称为*传输标识符（TID）*。
- en: What's different about TFTP, however, is that the server also selects a pseudorandom
    TID that it uses for sending responses back to the client; it doesn't send them
    from port number 69\. This is done because by using a unique client port number
    and source port number, multiple TFTP exchanges can be conducted simultaneously
    by a server. Each transfer is identified automatically by the source and destination
    port number, so there is no need to identify in data messages the transfer to
    which each block data belongs. This keeps the TFTP header size down, allowing
    more of each UDP message to contain actual data.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TFTP的不同之处在于服务器还选择了一个伪随机的TID，用于向客户端发送响应；它不是从端口号69发送的。这样做是因为通过使用唯一的客户端端口号和源端口号，服务器可以同时进行多个TFTP交换。每个传输通过源和目的端口号自动识别，因此不需要在数据消息中标识每个数据块所属的传输。这使TFTP头部大小降低，允许每个UDP消息包含更多的实际数据。
- en: For example, suppose the TFTP client selects a TID of 3145 for its initial message.
    It would send a UDP transmission from its port 3145 to the server's port 69\.
    Say the server selects a TID of 1114\. It would send its reply from its port 1114
    to the client's port 3145\. From then on, the client would send messages back
    to server port 1114 until the TFTP session was completed.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设TFTP客户端为其初始消息选择了一个TID为3145。它会从其端口3145向服务器的端口69发送UDP传输。假设服务器选择了一个TID为1114。它会从其端口1114向客户端的端口3145发送其回复。从那时起，客户端会向服务器端口1114发送消息，直到TFTP会话完成。
- en: Lock-Step Client/Server Messaging
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁步客户端/服务器消息
- en: 'After the initial exchange, the client and server exchange data and acknowledgment
    messages in *lock-step* fashion. Each device sends a message for each message
    it receives: one device sends data messages and waits for acknowledgments; the
    other sends acknowledgments and waits for data messages. This form of rigid communication
    is less efficient than allowing the transmitter to fire away with one data message
    after another, but it is important because it keeps TFTP simple when it comes
    to an important issue: retransmissions.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始交换之后，客户端和服务器以*锁步*方式交换数据和确认消息。每个设备为其收到的每条消息发送一条消息：一个设备发送数据消息并等待确认；另一个设备发送确认并等待数据消息。这种严格的通信方式不如允许发送者在发送一条数据消息后继续发送另一条数据消息高效，但它很重要，因为它使TFTP在重要问题上的处理变得简单：重传。
- en: Like all protocols using the unreliable UDP, TFTP has no assurances that any
    messages sent will actually arrive at their destination, so it must use timers
    to detect lost transmissions and resend them. What is different about TFTP is
    that both clients and servers perform retransmission. The device that is sending
    data messages will resend the data message if it doesn't receive an acknowledgment
    in a reasonable period of time; the device sending the acknowledgments will resend
    the acknowledgment if it doesn't receive the next data message promptly. The lock-step
    communication greatly simplifies this process, since each device needs to keep
    track of only one outstanding message at a time. It also eliminates the need to
    deal with complications such as reorganizing blocks received out of order (which
    protocols like FTP rely on TCP to manage).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有使用不可靠 UDP 的协议一样，TFTP 无法保证发送的消息实际上会到达目的地，因此它必须使用计时器来检测丢失的传输并重新发送。TFTP 与其他不同之处在于，客户端和服务器都会执行重传。发送数据消息的设备如果在合理的时间内没有收到确认，将会重新发送数据消息；发送确认的设备如果在没有及时收到下一个数据消息时，将会重新发送确认。这种同步通信大大简化了这一过程，因为每个设备只需同时跟踪一个未决消息。它还消除了处理诸如重新组织乱序接收到的块等复杂情况的需要（FTP
    等协议依赖于 TCP 来管理这些）。
- en: Tip
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since TFTP uses UDP rather than TCP, no explicit concept of
    a connection exists as in FTP. A TFTP session instead uses the concept of a logical
    connection, which is opened when a client sends a request to a server to read
    or write a file. Communication between the client and server is performed in lock-step
    fashion: one device sends data messages and receives acknowledgments so it knows
    the data messages were received; the other sends acknowledgments and receives
    data messages so it knows the acknowledgments were received.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于 TFTP 使用 UDP 而不是 TCP，因此不存在像 FTP 那样的显式连接概念。TFTP 会话使用逻辑连接的概念，当客户端向服务器发送请求以读取或写入文件时，该连接会被打开。客户端和服务器之间的通信以同步方式进行：一个设备发送数据消息并接收确认，以便知道数据消息已被接收；另一个设备发送确认并接收数据消息，以便知道确认已被接收。'
- en: Difficulties with TFTP's Simplified Messaging Mechanism
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP 简化消息机制的问题
- en: One of the most important drawbacks with this technique is that while it simplifies
    communication, it does so at the cost of performance. Since only one message can
    be in transit at a time, this limits throughput to a maximum of 512 bytes for
    exchange of messages between the client and server. In contrast, when using FTP,
    large amounts of data can be pipelined; there is no need to wait for an acknowledgment
    for the first piece of data before sending the second.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最大缺点之一是，虽然它简化了通信，但这样做是以性能为代价的。由于一次只能有一个消息在传输中，这限制了客户端和服务器之间消息交换的吞吐量，最大为
    512 字节。相比之下，当使用 FTP 时，可以大量数据流水线传输；在发送第二份数据之前，无需等待第一份数据的确认。
- en: Another complication is that if a data or an acknowledgment message is resent
    and the original was not lost but rather just delayed, two copies will show up.
    The original TFTP rules stated that upon receipt of a duplicate datagram, the
    device receiving it may resend the current datagram. So, receipt of a duplicate
    block 2 by a client doing a read would result in the client sending a duplicate
    acknowledgment for block 2\. This would result in two acknowledgments being received
    by the server, which would in turn send block 3 twice. Then there would be two
    acknowledgments for block 3, and so on.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂的问题是，如果数据或确认消息被重发，而原始消息并未丢失而是延迟了，将会出现两个副本。原始的 TFTP 规则指出，在接收到重复的数据报文时，接收该数据报文的设备可以重发当前的数据报文。因此，当客户端进行读取操作并接收到重复的块
    2 时，客户端会发送重复的块 2 确认。这会导致服务器接收到两个确认，进而发送两份块 3。然后会有两个块 3 的确认，以此类推。
- en: The end result of this is that once the initial duplication occurs, every message
    thereafter is sent twice. This has been affectionately dubbed the *Sorcerer's
    Apprentice bug*, after the story used as the basis of the famous scene in the
    movie *Fantasia*, where Mickey Mouse cuts animated brooms in half only to find
    that each half comes to life. This problem was fixed by changing the rules so
    that only the device receiving a duplicate data message may send a duplicate acknowledgment.
    Receipt of a duplicate acknowledgment does not result in sending a duplicate data
    message. Since only one of the two devices can send duplicates, this fixes the
    problem.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，一旦初始重复发生，之后的所有消息都会被发送两次。这个问题被亲切地称为*Sorcerer's Apprentice bug*，这个名字来源于电影*Fantasia*中著名的场景，米老鼠将动画扫帚切成两半，却发现每一半都复活了。这个问题通过改变规则得到解决，即只有接收重复数据消息的设备可以发送重复的确认消息。收到重复的确认消息不会导致发送重复的数据消息。由于只有两个设备中的一个可以发送重复消息，这解决了问题。
- en: It's also worth emphasizing that TFTP includes absolutely no security, so no
    login or authentication process is in place. As mentioned earlier, administrators
    must use caution in deciding what files to make available via TFTP and in allowing
    write access to TFTP servers.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得强调的是，TFTP根本不包含任何安全性，因此没有登录或认证过程。如前所述，管理员在决定通过TFTP提供哪些文件以及允许对TFTP服务器进行写入访问时必须谨慎。
- en: TFTP Detailed Operation and Messaging
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP详细操作和消息
- en: 'You saw earlier that TFTP operation consists of three general steps: initial
    connection, data transfer, and connection termination. All operations are performed
    through the exchange of specific TFTP messages. Let''s take a more detailed look
    now at these three phases of operation and the specifics of TFTP messaging.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到，TFTP操作由三个基本步骤组成：初始连接、数据传输和连接终止。所有操作都是通过交换特定的TFTP消息来完成的。现在让我们更详细地看看这三个操作阶段和TFTP消息的具体细节。
- en: Initial Message Exchange
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始消息交换
- en: 'The first message sent by the client to initiate TFTP is either a read request
    (RRQ) message or a write request (WRQ) message. This message serves implicitly
    to establish the logical TFTP connection and to indicate whether the file is to
    be sent from the server to the client (read request) or the client to the server
    (write request). The message also specifies the type of file transfer to be performed.
    TFTP supports two transfer modes: *netascii* mode (ASCII text files as used by
    the Telnet Protocol) and *octet* mode (binary files).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的第一个消息用于启动TFTP，要么是读取请求（RRQ）消息，要么是写入请求（WRQ）消息。这个消息隐式地建立了逻辑TFTP连接，并指示文件是从服务器发送到客户端（读取请求）还是从客户端发送到服务器（写入请求）。该消息还指定了要执行的类型文件传输。TFTP支持两种传输模式：*netascii*模式（ASCII文本文件，如Telnet协议所使用的）和*octet*模式（二进制文件）。
- en: Note
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Originally, a third file type option existed, called mail mode, but TFTP was
    never really designed for transmitting mail and this option is now obsolete*.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*最初，存在一个名为邮件模式的第三种文件类型选项，但TFTP从未真正设计用于传输邮件，这个选项现在已经过时了*。'
- en: Assuming no problem occurred with the request (such as a server problem, inability
    to find the file, and so on), the server will respond with a positive reply. In
    the case of a read request, the server will immediately send the first data message
    back to the client. In the case of a write request, the server will send an acknowledgment
    message to the client, telling it that it may proceed to send the first data message.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 假设请求过程中没有出现任何问题（例如服务器问题、无法找到文件等），服务器将返回一个积极的回复。在读取请求的情况下，服务器将立即将第一条数据消息发送回客户端。在写入请求的情况下，服务器将向客户端发送一个确认消息，告知它可以继续发送第一条数据消息。
- en: After the initial exchange, the client and server exchange data and acknowledgment
    messages in lock-step fashion as described earlier. For a read, the server sends
    one data message and waits for an acknowledgment from the client before sending
    the next one. For a write, the client sends one data message and the server sends
    an acknowledgment for it, before the client sends the next data message.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始交换之后，客户端和服务器按照之前描述的方式，以同步的方式交换数据和确认消息。对于读取操作，服务器发送一条数据消息，并在发送下一条消息之前等待客户端的确认。对于写入操作，客户端发送一条数据消息，服务器对它进行确认，然后客户端发送下一条数据消息。
- en: Data Block Numbering
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据块编号
- en: Each data message contains a block of between 0 and 512 bytes of data. The blocks
    are numbered sequentially, starting with 1\. The number of each block is placed
    in the header of the data message carrying that block and then used in the acknowledgment
    for that block so the original sender knows it was received. The device sending
    the data will always send 512 bytes of data at a time for as long as it has enough
    data to fill the message. When it gets to the end of the file and has fewer than
    512 bytes to send, it will send only as many bytes as remain. (Interestingly,
    this means that if the size of the file is an exact multiple of 512, the last
    message sent will have zero bytes of data!)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据消息包含0到512字节的数据块。这些块按顺序编号，从1开始。每个块的编号放在携带该块的数据消息的头部，并在对该块的确认中使用，以便原始发送者知道它已被接收。发送数据的设备将始终在它有足够的数据填充消息的情况下，每次发送512字节的数据。当它到达文件末尾并且要发送的数据少于512字节时，它将只发送剩余的字节数。（有趣的是，这意味着如果文件的大小是512的精确倍数，则最后发送的消息将没有数据字节！）
- en: The receipt of a data message with between 0 and 511 bytes of data signals that
    this is the last data message. Once this is acknowledged, it automatically signals
    the end of the data transfer. There is no need to terminate the connection explicitly,
    just as it was not necessary to establish it explicitly.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到包含0到511字节数据的数据消息表示这是最后一个数据消息。一旦确认，它将自动表示数据传输结束。无需显式终止连接，就像建立连接时不需要显式一样。
- en: TFTP Read Process Steps
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP读取过程步骤
- en: 'Let''s look at an example that shows how TFTP messaging works. Suppose the
    client wants to read a particular file that is 1200 bytes long. Here are the steps
    in simplified form (also displayed in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.")):'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看一个示例，展示TFTP消息是如何工作的。假设客户端想要读取一个长度为1200字节的具体文件。以下是简化的步骤（也显示在[图73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "图73-1. TFTP读取过程 在本例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送包含文件前512字节的块1的数据消息来确认此请求。客户端通过为块1发送确认消息来确认。然后服务器发送包含字节513到1024的块2，客户端对其进行确认。当客户端收到块3时，它意识到它只有176字节，这标志着它是文件的最后一个块。"))):'
- en: The client sends a read request to the server, specifying the name of the file.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送读取请求，指定文件名。
- en: The server sends back a data message containing block 1, carrying 512 bytes
    of data.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送包含块1的数据消息，携带512字节的数据。
- en: The client receives the data and sends back an acknowledgment for block 1.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端收到数据并发送对块1的确认。
- en: The server sends block 2, with 512 bytes of data.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送包含512字节数据的块2。
- en: The client receives block 2 and sends back an acknowledgment for it.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端收到块2并发送对其的确认。
- en: The server sends block 3, containing 176 bytes of data. It waits for an acknowledgment
    before terminating the logical connection.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送包含176字节数据的块3。它在终止逻辑连接之前等待确认。
- en: The client receives the data and sends an acknowledgment for block 3\. Since
    this data message had fewer than 512 bytes, it knows the file is complete.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端收到数据并发送对块3的确认。由于此数据消息少于512字节，它知道文件已完成。
- en: The server receives the acknowledgment and knows the file was received successfully.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器收到确认并知道文件已成功接收。
- en: '![TFTP read process In this example, the client starts the process of reading
    a file by sending a request for it to the server. The server acknowledges this
    request by immediately sending a DATA message carrying block 1, containing the
    first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.](httpatomoreillycomsourcenostarchimages288271.png.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP读取过程 在此示例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送携带块1的数据消息来确认此请求，其中包含文件的第一个512字节。客户端通过为块1发送ACK消息来确认。然后服务器发送包含字节513到1024的块2，客户端确认。当客户端收到包含176字节的块3时，它意识到这是文件的最后一个块。](httpatomoreillycomsourcenostarchimages288271.png.jpg)'
- en: Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-1. TFTP读取过程 在此示例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送携带块1的数据消息来确认此请求，其中包含文件的第一个512字节。客户端通过为块1发送ACK消息来确认。然后服务器发送包含字节513到1024的块2，客户端确认。当客户端收到包含176字节的块3时，它意识到这是文件的最后一个块。
- en: TFTP Write Process Steps
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP写入过程步骤
- en: 'Here are the steps in the same process, but where the client is writing the
    file (see [Figure 73-2](ch73s03.html#tftp_write_process_this_example_shows_th
    "Figure 73-2. TFTP write process This example shows the client sending the same
    1200-byte file to the server that it read in Figure 73-1\. The client sends a
    write request to the server, which acknowledges it; it uses block 0 to represent
    acknowledgment of the request prior to receipt of any data. The client then sends
    blocks of data one at a time, each of which is acknowledged by the server. When
    the server receives block 3 containing fewer than 512 bytes of data, it knows
    it has received the whole file.")):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同过程中的步骤，但客户端正在写入文件（参见[图73-2](ch73s03.html#tftp_write_process_this_example_shows_th
    "图73-2. TFTP写入过程 此示例显示客户端向服务器发送与图73-1中读取的相同1200字节的文件。客户端向服务器发送写入请求，服务器确认；在接收到任何数据之前，它使用块0来表示请求的确认。然后客户端逐个发送数据块，每个数据块都由服务器确认。当服务器接收到包含少于512字节数据的块3时，它知道已经接收了整个文件。"))）：
- en: The client sends a write request to the server, specifying the name of the file.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送写入请求，指定文件名。
- en: The server sends back an acknowledgment. Since this acknowledgment is prior
    to the receipt of any data, it uses block 0 in the acknowledgment.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送回确认。由于此确认是在接收到任何数据之前发送的，因此它在确认中使用块0。
- en: The client sends a data message containing block 1, with 512 bytes of data.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送包含块1的数据消息，其中包含512字节数据。
- en: The server receives the data and sends back an acknowledgment for block 1.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收数据并发送对块1的确认。
- en: The client sends block 2, containing 512 bytes of data.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送包含512字节数据的块2。
- en: The server receives the data and sends back an acknowledgment for block 2.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收数据并发送对块2的确认。
- en: The client sends block 3, containing 176 bytes of data. It waits for an acknowledgment
    before terminating the logical connection.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送包含176字节数据的块3。它在终止逻辑连接之前等待确认。
- en: The server receives block 3 and sends an acknowledgment for it. Since this data
    message had fewer than 512 bytes, the transfer is done.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收块3并发送对其的确认。由于此数据消息少于512字节，传输完成。
- en: The client receives the acknowledgment for block 3 and knows the file write
    was completed successfully.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端收到块3的确认，知道文件写入成功完成。
- en: '![TFTP write process This example shows the client sending the same 1200-byte
    file to the server that it read in . The client sends a write request to the server,
    which acknowledges it; it uses block 0 to represent acknowledgment of the request
    prior to receipt of any data. The client then sends blocks of data one at a time,
    each of which is acknowledged by the server. When the server receives block 3
    containing fewer than 512 bytes of data, it knows it has received the whole file.](httpatomoreillycomsourcenostarchimages288273.png.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP写入过程 本例展示了客户端向服务器发送与读取的相同1200字节文件。客户端向服务器发送写入请求，服务器确认后；它使用块0来表示在收到任何数据之前对请求的确认。客户端然后一次发送一个数据块，每个数据块都由服务器确认。当服务器收到包含少于512字节数据的数据块3时，它知道已经收到了整个文件。](httpatomoreillycomsourcenostarchimages288273.png.jpg)'
- en: Figure 73-2. TFTP write process This example shows the client sending the same
    1200-byte file to the server that it read in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."). The client sends
    a write request to the server, which acknowledges it; it uses block 0 to represent
    acknowledgment of the request prior to receipt of any data. The client then sends
    blocks of data one at a time, each of which is acknowledged by the server. When
    the server receives block 3 containing fewer than 512 bytes of data, it knows
    it has received the whole file.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-2. TFTP写入过程 本例展示了客户端向服务器发送与[图73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "图73-1. TFTP读取过程 在本例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送包含文件前512个字节的数据块1的消息来确认此请求。客户端通过发送对块1的ACK消息来确认。然后服务器发送包含字节513到1024的块2，客户端对其进行确认。当客户端收到包含176个字节的块3时，它意识到这是文件的最后一个块。")中读取的相同1200字节的文件。客户端向服务器发送写入请求，服务器确认后；它使用块0来表示在收到任何数据之前对请求的确认。然后客户端一次发送一个数据块，每个数据块都由服务器确认。当服务器收到包含少于512字节数据的数据块3时，它知道已经收到了整个文件。
- en: Tip
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** A TFTP *read operation* begins with the client sending a read
    request message to the TFTP server; the server then sends the file in 512-byte
    data messages, waiting after each one for the client to acknowledge receipt before
    sending the next. A TFTP *write operation* starts with a write request sent by
    the client to the server, which the server acknowledges. The client then sends
    the file in 512-byte data blocks, waiting after each for the server to acknowledge
    receipt. In both cases, there is no explicit means by which the end of a transfer
    is marked; the device receiving the file simply knows the transfer is complete
    when it receives a data message containing fewer than 512 bytes.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TFTP的*读取操作*开始于客户端向TFTP服务器发送读取请求消息；服务器随后发送512字节的文件数据消息，并在每次发送后等待客户端确认接收，然后再发送下一个。TFTP的*写入操作*开始于客户端向服务器发送写入请求，服务器进行确认。然后客户端以512字节的数据块发送文件，并在每次发送后等待服务器确认接收。在这两种情况下，都没有明确的方式来标记传输的结束；接收文件的设备只是在收到包含少于512字节的数据消息时知道传输已完成。'
- en: If a problem is encountered at any stage of the connection establishment or
    transfer process, a device may reply with an error message instead of a data or
    acknowledgment message, as appropriate. An error message normally results in the
    failure of the data transfer; this is one of the prices paid for the simplicity
    of TFTP.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在连接建立或传输过程的任何阶段遇到问题，设备可能会回复一个错误消息而不是数据或确认消息，具体情况而定。错误消息通常会导致数据传输失败；这是TFTP简单性所付出的代价之一。
- en: Each TFTP file transfer proceeds using the process described, which transfers
    a single file. If another file needs to be sent or received, a new logical communication
    is established, in a manner analogous to how FTP creates data connections. The
    main difference is that TFTP has no persistent control connection, as FTP does.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 每个TFTP文件传输都使用所描述的过程进行，该过程仅传输单个文件。如果需要发送或接收另一个文件，将建立一个新的逻辑通信，方式类似于FTP创建数据连接。主要区别是TFTP没有FTP那样的持久控制连接。
- en: TFTP Options and Option Negotiation
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP选项和选项协商
- en: One of the difficulties that designers of simple protocols and applications
    seem to have is keeping them simple. Many protocols start out small, but over
    time well-intentioned users suggest improvements that are added slowly but surely.
    Eventually, the program that was once lean and mean has become, shall we say,
    "well-marbled." In the software industry, this is called *feature creep* and has
    happened to many protocols and applications.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 简单协议和应用的设计者似乎面临的一个困难是保持它们的简单性。许多协议最初规模较小，但随着时间的推移，一些有良好意图的用户会逐渐提出改进建议，这些改进虽然缓慢但确实被采纳。最终，曾经精简高效的程序变得，让我们说，"过于复杂"。在软件行业中，这种现象被称为
    *功能蔓延*，并且已经发生在许多协议和应用中。
- en: 'The temptation to add features is especially strong when the program or protocol
    has few to begin with. Given this, the maintainers of TFTP have done a good job
    over the years of avoiding this pitfall. However, they did allow one new feature
    to be added to the protocol in 1995: the "TFTP Option Extension," which describes
    how a TFTP client and server can negotiate *options* before transferring a file.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序或协议最初功能较少时，增加功能的诱惑尤其强烈。鉴于这一点，TFTP的维护者多年来一直做得很好，避免了这种陷阱。然而，他们在1995年确实允许在协议中增加了一个新功能："TFTP选项扩展"，它描述了TFTP客户端和服务器在传输文件之前如何协商
    *选项*。
- en: The reason for adding this capability is that the original TFTP provided no
    way at all for the client and server to exchange important control information
    prior to sending a file. This limited the flexibility of the protocol to deal
    with special cases, such as the transfer of data over unusual network types. The
    TFTP option negotiation feature allows additional parameters to be exchanged between
    the client and server that govern how data is transferred. It does this without
    significantly complicating the protocol and is backward-compatible with normal
    TFTP. It is used only if both client and server support it, and one device trying
    to use the feature will not cause problems if the other doesn't support it.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这种功能的原因是原始的TFTP根本无法让客户端和服务器在发送文件之前交换重要的控制信息。这限制了协议处理特殊情况的灵活性，例如在非同寻常的网络类型上传输数据。TFTP选项协商功能允许客户端和服务器之间交换额外的参数，以控制数据传输的方式。它这样做而没有显著复杂化协议，并且与正常TFTP向后兼容。它仅在客户端和服务器都支持它的情况下使用，如果一个设备尝试使用该功能而另一个不支持，则不会引起问题。
- en: TFTP Option Negotiation Process
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP选项协商过程
- en: The client begins the negotiation by sending a modified TFTP read request or
    write request message. In addition to the normal information that appears in this
    message (described in the "TFTP Message Formats" section later in this chapter),
    a list of options may also be included. Each is specified with an option code
    and an option value. The names and values are expressed as ASCII strings, terminated
    by a null character (0 byte). Multiple options may be specified in the request
    message.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过发送修改后的TFTP读取请求或写入请求消息来开始协商。除了此消息中出现的正常信息（在本章后面的 "TFTP消息格式" 部分中描述）外，还可以包括一个选项列表。每个选项都指定了一个选项代码和一个选项值。名称和值以ASCII字符串的形式表达，并以空字符（0字节）结尾。请求消息中可以指定多个选项。
- en: The server receives the request containing the options, and if it supports the
    option extension, it processes them. It then returns a *special option acknowledgment
    (OACK*) message to the client, where it lists all the options that the client
    specified that the server recognizes and accepts. Any options that the client
    requested but the server rejects are not included in the OACK. The client may
    use only the options that the server accepts. If the client rejects the server's
    response, it may send back an error message (with error code 8) upon receipt of
    the unacceptable OACK message.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收包含选项的请求，如果它支持选项扩展，则处理它们。然后，它向客户端返回一个*特殊选项确认（OACK）*消息，其中列出客户端指定的服务器识别并接受的所有选项。客户端请求但服务器拒绝的任何选项都不包括在OACK中。客户端只能使用服务器接受的选项。如果客户端拒绝服务器的响应，它可以在收到不可接受的OACK消息时发送一个错误消息（错误代码8）。
- en: The server may specify an alternative value in its response for certain options,
    if it recognizes the option but doesn't like the client's suggested value. Obviously,
    if the server doesn't support options at all, it will ignore the client's option
    requests and respond with a data message (for a read) or a regular acknowledgment
    (for a write) as in normal TFTP.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器识别某个选项但不满意客户端建议的值，它可以在其响应中为某些选项指定一个替代值。显然，如果服务器根本不支持选项，它将忽略客户端的选项请求，并以正常TFTP的方式响应，发送数据消息（用于读取）或常规确认（用于写入）。
- en: If the server did send an OACK, the client proceeds to send messages using the
    regular messaging exchange described in the previous section. In the case of a
    write, the OACK replaces the regular acknowledgment in the message dialog. In
    the case of a read, the OACK is the server's first message instead of the first
    data block that it would normally send. TFTP doesn't allow the same device to
    send two datagrams in a row, so a reply from the client must be received before
    that first block can be sent. The client does this by sending a regular acknowledgment
    with a block number of 0 in it—the same form of acknowledgment a server normally
    sends for a write.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器确实发送了OACK，客户端将继续发送消息，使用上一节中描述的常规消息交换。在写操作的情况下，OACK替换了消息对话中的常规确认。在读取操作的情况下，OACK是服务器发送的第一个消息，而不是它通常发送的第一个数据块。TFTP不允许同一设备连续发送两个数据报，因此必须在发送第一个块之前收到客户端的回复。客户端通过发送一个包含0号块的常规确认来实现这一点——这与服务器通常用于写操作的确认形式相同。
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TFTP is supposed to be a small and simple protocol, so it includes
    few extra features. One that it does support is *option negotiation*, where a
    TFTP client and server attempt to come to agreement on additional parameters that
    they will use in transferring a file. The TFTP client includes one or more options
    in its read request or write request message; the TFTP server then sends an option
    acknowledgment (OACK) message listing each option the server agrees to use. The
    use of options when reading a file means that an extra acknowledgment must be
    sent by the client—to acknowledge the OACK—before the server sends the first block
    of the file.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TFTP本应是一个小而简单的协议，因此它包含很少的额外功能。它支持的一个功能是*选项协商*，其中TFTP客户端和服务器试图就他们将在文件传输中使用的附加参数达成一致。TFTP客户端在其读取请求或写入请求消息中包含一个或多个选项；然后，TFTP服务器发送一个选项确认（OACK）消息，列出服务器同意使用的每个选项。在读取文件时使用选项意味着客户端必须发送一个额外的确认——以确认OACK——在服务器发送文件的第一块之前。'
- en: 'For review, let''s take a look at each of the four possible cases: read and
    write, with and without options.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，让我们逐一查看四种可能的情况：读写操作，带选项和不带选项。
- en: 'The initial message exchange for a normal read (without option negotiation),
    as shown in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."), is as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 正常读取（无选项协商）的初始消息交换，如图[图73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "图73-1. TFTP读取过程在此示例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送携带块1的数据消息来确认此请求，其中包含文件的第一个512字节。客户端通过发送块1的ACK消息来确认。然后服务器发送包含字节513到1024的块2，客户端确认。当客户端收到块3时，它意识到它只有176字节，这标志着它是文件的最后一个块。")所示，如下：
- en: Client sends read request.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送读取请求。
- en: Server sends data block 1.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送数据块1。
- en: Client acknowledges data block 1.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端确认数据块1。
- en: And so on …
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以此类推 …
- en: 'With option negotiation, a read is as follows (see [Figure 73-3](ch73s04.html#tftp_read_process_with_option_negotiatio
    "Figure 73-3. TFTP read process with option negotiation This diagram shows the
    same example illustrated in Figure 73-1, but with one added message exchange used
    for option negotiation. The client''s initial read request here includes options
    that it wants to use for this transfer. The server responds not immediately with
    the first data block, but with an OACK. The client indicates receipt of the OACK
    by sending an acknowledgment using block 0\. The server sends data block 1, and
    the rest of the exchange proceeds as normal.")):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项协商过程中，读取过程如下（参见[图73-3](ch73s04.html#tftp_read_process_with_option_negotiatio
    "图73-3. 带选项协商的TFTP读取过程此图展示了与图73-1相同的示例，但增加了一个用于选项协商的消息交换。客户端的初始读取请求包括它希望用于此传输的选项。服务器不是立即发送第一个数据块，而是发送一个OACK。客户端通过发送使用块0的确认来表示已收到OACK。服务器发送数据块1，其余的交换过程按正常进行。"))）：
- en: Client sends read request with options.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送带有选项的读取请求。
- en: Server sends OACK.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送OACK。
- en: Client sends regular acknowledgment for block 0; that is, it acknowledges the
    OACK.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送对块0的常规确认；即，它确认了OACK。
- en: Server sends data block 1.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送数据块1。
- en: Client acknowledges data block 1.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端确认数据块1。
- en: And so on …
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以此类推 …
- en: '![TFTP read process with option negotiation This diagram shows the same example
    illustrated in , but with one added message exchange used for option negotiation.
    The client''s initial read request here includes options that it wants to use
    for this transfer. The server responds not immediately with the first data block,
    but with an OACK. The client indicates receipt of the OACK by sending an acknowledgment
    using block 0\. The server sends data block 1, and the rest of the exchange proceeds
    as normal.](httpatomoreillycomsourcenostarchimages288275.png.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![带选项协商的TFTP读取过程此图展示了与图73-1相同的示例，但增加了一个用于选项协商的消息交换。客户端的初始读取请求包括它希望用于此传输的选项。服务器不是立即发送第一个数据块，而是发送一个OACK。客户端通过发送使用块0的确认来表示已收到OACK。服务器发送数据块1，其余的交换过程按正常进行。](httpatomoreillycomsourcenostarchimages288275.png.jpg)'
- en: Figure 73-3. TFTP read process with option negotiation This diagram shows the
    same example illustrated in [Figure 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "Figure 73-1. TFTP read process In this example, the client starts the process
    of reading a file by sending a request for it to the server. The server acknowledges
    this request by immediately sending a DATA message carrying block 1, containing
    the first 512 bytes of the file. The client acknowledges this with an ACK message
    for block 1\. The server then sends block 2, containing bytes 513 to 1024, which
    the client acknowledges. When the client receives block 3, it realizes it has
    only 176 bytes, which marks it as the last block of the file."), but with one
    added message exchange used for option negotiation. The client's initial read
    request here includes options that it wants to use for this transfer. The server
    responds not immediately with the first data block, but with an OACK. The client
    indicates receipt of the OACK by sending an acknowledgment using block 0\. The
    server sends data block 1, and the rest of the exchange proceeds as normal.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 图 73-3. 带有选项协商的 TFTP 读取过程 此图显示了与 [图 73-1](ch73s03.html#tftp_read_process_in_this_example_the_cl
    "图 73-1. TFTP 读取过程 在本例中，客户端通过向服务器发送请求来启动读取文件的过程。服务器通过立即发送携带块 1 的 DATA 消息来确认此请求，其中包含文件的第一个
    512 字节。客户端通过发送块 1 的 ACK 消息来确认这一点。然后服务器发送包含字节 513 到 1024 的块 2，客户端确认。当客户端收到块 3 时，它意识到它只有
    176 字节，这标志着它是文件的最后一个块。"), 但增加了一个用于选项协商的消息交换。客户端的初始读取请求包括它希望用于此传输的选项。服务器不是立即发送第一个数据块，而是发送一个
    OACK。客户端通过发送使用块 0 的确认来表示已收到 OACK。服务器发送数据块 1，其余的交换按正常进行。
- en: 'The initial message exchange for a normal write (without option negotiation)
    is as follows:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 正常写操作的初始消息交换（没有选项协商）如下：
- en: Client sends write request.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送写请求。
- en: Server sends acknowledgment.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送确认。
- en: Client sends data block 1.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送数据块 1。
- en: Server acknowledges data block 1.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器确认数据块 1。
- en: And so on …
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等 …
- en: 'And here''s a write with option negotiation:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有选项协商的写操作：
- en: Client sends write request with options.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送带有选项的写请求。
- en: Server sends option acknowledgment (instead of regular acknowledgment).
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器发送选项确认（而不是常规确认）。
- en: Client sends data block 1.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送数据块 1。
- en: Server acknowledges data block 1.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器确认数据块 1。
- en: And so on …
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等等 …
- en: TFTP Options
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TFTP 选项
- en: '[Table 73-1](ch73s04.html#tftp_options-id001 "Table 73-1. TFTP Options") contains
    a summary of the three TFTP options currently defined.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 73-1](ch73s04.html#tftp_options-id001 "表 73-1. TFTP 选项") 包含了当前定义的三个 TFTP
    选项的摘要。'
- en: Table 73-1. TFTP Options
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 表 73-1. TFTP 选项
- en: '| TFTP Option Name | TFTP Option Code (Used in Request Messages) | Defining
    RFC | Description |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| TFTP 选项名称 | TFTP 选项代码（用于请求消息） | 定义 RFC | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Block Size | blksize | 2348 | Allows the client and server to send data blocks
    of a size other than 512 bytes to improve efficiency or address limitations of
    a particular type of network. |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| 块大小 | blksize | 2348 | 允许客户端和服务器发送大小为 512 字节以外的数据块，以提高效率或解决特定类型网络的限制。 |'
- en: '| Timeout Interval | interval | 2349 | Permits the client and server to agree
    on a specified number of seconds to use for their retransmission timers. Again,
    may be of value on certain networks with high latency or other special requirements.
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 超时间隔 | interval | 2349 | 允许客户端和服务器就用于重传计时器的指定秒数达成一致。在具有高延迟或其他特殊要求的某些网络上，这可能很有价值。
    |'
- en: '| Transfer Size | tsize | 2349 | Lets the device sending the file (client on
    a write, server on a read) tell the other device the size of the file before the
    transfer commences. This allows the receiving device to allocate space for it
    in advance. |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| 传输大小 | tsize | 2349 | 允许发送文件的设备（在写操作中为客户端，在读取操作中为服务器）在传输开始之前告诉另一设备文件的大小。这允许接收设备提前为其分配空间。
    |'
- en: TFTP Message Formats
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP 消息格式
- en: Unlike FTP, all communication in TFTP is accomplished in the form of discrete
    messages that follow a particular message format. The reason why TFTP and FTP
    are so different in this regard is because of the different transport protocols
    they use. FTP uses TCP, which allows data to be streamed a byte at a time; FTP
    also makes use of a dedicated channel for commands. TFTP runs on UDP, which uses
    a conventional header/data formatting scheme.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 与FTP不同，TFTP中的所有通信都是以离散消息的形式完成的，这些消息遵循特定的消息格式。TFTP和FTP在这方面差异如此之大的原因是它们使用的传输协议不同。FTP使用TCP，允许数据逐字节流式传输；FTP还使用一个专用通道来发送命令。TFTP运行在UDP上，它使用传统的头部/数据格式化方案。
- en: 'The original TFTP standard defines five different types of messages: read request
    (RRQ), write request (WRQ), data (DATA), acknowledgment (ACK), and error (ERROR).
    The TFTP option extension feature defines a sixth message: option acknowledgment
    (OACK). Of these six messages, the first two share the same message format. The
    only common field in every TFTP message is the operation code (Opcode), which
    tells the recipient of the message what type it is.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 原始TFTP标准定义了五种不同类型的消息：读取请求（RRQ）、写入请求（WRQ）、数据（DATA）、确认（ACK）和错误（ERROR）。TFTP选项扩展功能定义了第六种消息：选项确认（OACK）。在这六种消息中，前两种具有相同的消息格式。每个TFTP消息中唯一的公共字段是操作码（Opcode），它告诉消息的接收者消息的类型。
- en: TFTP's message formats are different than those used for certain other protocols,
    because many of the fields in TFTP are variable in length. Usually, variable-length
    fields in messages are expressed using a preceding length field that specifies
    the length of the variable-sized field. Instead, TFTP sends such fields as strings
    of ASCII characters using netascii, the Telnet version of ASCII. The end of the
    string is marked by a zero byte. The exception to this is the data field in data
    messages, the content of which depends on the transfer mode.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: TFTP的消息格式与某些其他协议使用的格式不同，因为TFTP中的许多字段长度是可变的。通常，消息中的可变长度字段使用前导长度字段来表示可变字段的大小。相反，TFTP使用ASCII字符的字符串形式通过netascii（ASCII的Telnet版本）发送这些字段。字符串的结尾由一个零字节标记。例外的是数据消息中的数据字段，其内容取决于传输模式。
- en: The remainder of the chapter contains the details on each of the TFTP messages.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分包含对每个TFTP消息的详细说明。
- en: Read Request and Write Request Messages
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取请求和写入请求消息
- en: These messages use a common message format, described in [Table 73-2](ch73s05.html#tftp_rrqwrq_message_format
    "Table 73-2. TFTP RRQ/WRQ Message Format") and shown graphically in [Figure 73-4](ch73s05.html#tftp_rrqwrq_message_format-id001
    "Figure 73-4. TFTP RRQ/WRQ message format").
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息使用一个通用的消息格式，在[表73-2](ch73s05.html#tftp_rrqwrq_message_format "表73-2. TFTP
    RRQ/WRQ消息格式")中描述，并在[图73-4](ch73s05.html#tftp_rrqwrq_message_format-id001 "图73-4.
    TFTP RRQ/WRQ消息格式")中以图形方式展示。
- en: Table 73-2. TFTP RRQ/WRQ Message Format
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 表73-2. TFTP RRQ/WRQ消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    1 indicates a RRQ message, while a value of 2 is a WRQ message. |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 操作码 | 2 | 操作码：指定TFTP消息类型。值为1表示RRQ消息，而值为2表示WRQ消息。 |'
- en: '| Filename | Variable | The name of the file to be read or written. |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 可变 | 要读取或写入的文件名。 |'
- en: '| Mode | Variable | Transfer Mode: The string netascii or octet, zero-terminated.
    |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 可变 | 传输模式：字符串netascii或字节，以零字节结尾。 |'
- en: '| Options | Variable | When the client supports TFTP options, it will encode
    them in sequence following the Mode field. Each option consists of two variable-length
    subfields. The optN subfield is the option code for option N, containing a string
    specifying the name of the option; currently, blksize, interval, and tsize are
    supported. The valueN subfield is the option value for option N, containing the
    value the client is requesting for this option. (Note that this is a zero-terminated
    string just like other TFTP variable-length fields, even for a numeric value.)
    |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 当客户端支持TFTP选项时，它将在模式字段之后按顺序编码它们。每个选项由两个可变长度子字段组成。optN子字段是选项N的选项代码，包含指定选项名称的字符串；目前支持blksize、interval和tsize。valueN子字段是选项N的选项值，包含客户端请求此选项的值。（注意，这与其他TFTP可变长度字段一样，是一个零终止的字符串，即使是数值。）
    |'
- en: '![TFTP RRQ/WRQ message format](httpatomoreillycomsourcenostarchimages288277.png)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP RRQ/WRQ消息格式](httpatomoreillycomsourcenostarchimages288277.png)'
- en: Figure 73-4. TFTP RRQ/WRQ message format
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-4. TFTP RRQ/WRQ消息格式
- en: Data Messages
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据消息
- en: Data blocks are sent using the simplified format shown in [Table 73-3](ch73s05.html#tftp_data_message_format
    "Table 73-3. TFTP Data Message Format") and [Figure 73-5](ch73s05.html#tftp_data_message_format-id001
    "Figure 73-5. TFTP data message format").
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 数据块使用[表73-3](ch73s05.html#tftp_data_message_format "表73-3. TFTP数据消息格式")和[图73-5](ch73s05.html#tftp_data_message_format-id001
    "图73-5. TFTP数据消息格式")中显示的简化格式发送。
- en: Table 73-3. TFTP Data Message Format
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 表73-3. TFTP数据消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    3 indicates a data message. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| 操作码 | 2 | 操作代码：指定TFTP消息类型。值为3表示数据消息。|'
- en: '| Block # | 2 | Block Number: The number of the data block being sent. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 块编号 | 2 | 块编号：正在发送的数据块的编号。|'
- en: '| Data | Variable | Data: 0 to 512 bytes of data. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 可变 | 数据：0到512字节的数据。|'
- en: '![TFTP data message format](httpatomoreillycomsourcenostarchimages288279.png)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP数据消息格式](httpatomoreillycomsourcenostarchimages288279.png)'
- en: Figure 73-5. TFTP data message format
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-5. TFTP数据消息格式
- en: Acknowledgment Messages
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认消息
- en: Acknowledgments have the simplest format of any TFTP message, as you can see
    in [Table 73-4](ch73s05.html#tftp_acknowledgment_message_format "Table 73-4. TFTP
    Acknowledgment Message Format") and [Figure 73-6](ch73s05.html#tftp_acknowledgment_message_format-id001
    "Figure 73-6. TFTP acknowledgment message format").
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 确认消息具有任何TFTP消息中最简单的格式，如[表73-4](ch73s05.html#tftp_acknowledgment_message_format
    "表73-4. TFTP确认消息格式")和[图73-6](ch73s05.html#tftp_acknowledgment_message_format-id001
    "图73-6. TFTP确认消息格式")所示。
- en: Table 73-4. TFTP Acknowledgment Message Format
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 表73-4. TFTP确认消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    4 indicates an ACK message. |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 操作码 | 2 | 操作代码：指定TFTP消息类型。值为4表示ACK消息。|'
- en: '| Block # | 2 | Block Number: The number of the data block being acknowledged;
    a value of 0 is used to acknowledge receipt of a write request without options
    or to acknowledge receipt of an OACK. |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 块编号 | 2 | 块编号：被确认的数据块的编号；值为0用于确认无选项的写入请求的接收或确认OACK的接收。|'
- en: '![TFTP acknowledgment message format](httpatomoreillycomsourcenostarchimages288281.png.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP确认消息格式](httpatomoreillycomsourcenostarchimages288281.png.jpg)'
- en: Figure 73-6. TFTP acknowledgment message format
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-6. TFTP确认消息格式
- en: Error Messages
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误消息
- en: Error messages can be sent by either the client or server in cases where a problem
    is detected in the communication. They have the format indicated in [Table 73-5](ch73s05.html#tftp_error_message_format-id001
    "Table 73-5. TFTP Error Message Format") and [Figure 73-7](ch73s05.html#tftp_error_message_format
    "Figure 73-7. TFTP error message format").
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到通信中的问题时，客户端或服务器都可以发送错误消息。它们的格式如[表73-5](ch73s05.html#tftp_error_message_format-id001
    "表73-5. TFTP错误消息格式")和[图73-7](ch73s05.html#tftp_error_message_format "图73-7. TFTP错误消息格式")所示。
- en: '![TFTP error message format](httpatomoreillycomsourcenostarchimages288283.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP错误消息格式](httpatomoreillycomsourcenostarchimages288283.png)'
- en: Figure 73-7. TFTP error message format
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 图73-7. TFTP错误消息格式
- en: Table 73-5. TFTP Error Message Format
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 表73-5. TFTP错误消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    5 indicates an error message. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| 操作码 | 2 | 操作代码：指定TFTP消息类型。值为5表示错误消息。|'
- en: '| Error Code | 2 | A numeric code indicating the type of message being communicated.
    Values 0 to 7 are defined by the TFTP standard, while value 8 was added by the
    TFTP option extension:0 = Not defined; see error message field for details1 =
    File not found2 = Access violation3 = Disk full or allocation exceeded4 = Illegal
    TFTP operation5 = Unknown transfer ID6 = File already exists7 = No such user8
    = Client transfer termination due to unacceptable option negotiation |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 错误代码 | 2 | 表示正在通信的消息类型的数字代码。值0到7由TFTP标准定义，而值8由TFTP选项扩展添加：0 = 未定义；请参阅错误消息字段以获取详细信息1
    = 文件未找到2 = 访问违规3 = 磁盘满或分配超出4 = 非法TFTP操作5 = 未知传输ID6 = 文件已存在7 = 没有此类用户8 = 由于不可接受选项协商，客户端传输终止
    |'
- en: '| Error Msg | Variable | Error Message: A descriptive text error message string,
    intended for "human consumption," as the standard puts it. |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 错误消息 | 可变 | 错误消息：描述性文本错误消息字符串，如标准所述，旨在供“人类消费”。|'
- en: Option Acknowledgment Messages
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项确认消息
- en: OACK messages are used to acknowledge receipt of TFTP options. They are structured
    as shown in [Table 73-6](ch73s05.html#tftp_oack_message_format "Table 73-6. TFTP
    OACK Message Format") and [Figure 73-8](ch73s05.html#tftp_oack_message_format-id001
    "Figure 73-8. TFTP OACK message format").
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: OACK 消息用于确认接收 TFTP 选项。其结构如 [表 73-6](ch73s05.html#tftp_oack_message_format "表
    73-6. TFTP OACK 消息格式") 和 [图 73-8](ch73s05.html#tftp_oack_message_format-id001
    "图 73-8. TFTP OACK 消息格式") 所示。
- en: Table 73-6. TFTP OACK Message Format
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 表 73-6. TFTP OACK 消息格式
- en: '| Field Name | Size (bytes) | Description |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Opcode | 2 | Operation Code: Specifies the TFTP message type. A value of
    6 indicates an OACK message. |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| 指令码 | 2 | 操作码：指定 TFTP 消息类型。值为 6 表示 OACK 消息。 |'
- en: '| Options | Variable | A list of options being acknowledged by the server.
    Each option consists of two variable-length subfields. The optN subfield is the
    option code for option N, containing a string specifying the name of the option,
    copied from the RRQ or WRQ message. The valueN subfield is the option value for
    option N, containing the acknowledged value for the option, which may be the value
    that the client specified or an alternative value, depending on the type of option.
    |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 服务器确认的选项列表。每个选项由两个可变长度的子字段组成。optN 子字段是选项 N 的选项码，包含指定选项名称的字符串，从
    RRQ 或 WRQ 消息中复制而来。valueN 子字段是选项 N 的选项值，包含选项的确认值，这可能是客户端指定的值或替代值，具体取决于选项类型。 |'
- en: '![TFTP OACK message format](httpatomoreillycomsourcenostarchimages288285.png.jpg)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![TFTP OACK 消息格式](httpatomoreillycomsourcenostarchimages288285.png.jpg)'
- en: Figure 73-8. TFTP OACK message format
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 图 73-8. TFTP OACK 消息格式
