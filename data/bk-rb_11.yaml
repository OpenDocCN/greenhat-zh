- en: Chapter 11. Symbols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。符号
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: Many newcomers to Ruby are confused by symbols. A symbol is an identifier whose
    first character is a colon (`:`), so `:this` is a symbol and so is `:that`. Symbols
    are, in fact, not at all complicated—and, in certain circumstances, they may be
    extremely useful, as you will see shortly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多新接触Ruby的人对符号感到困惑。符号是一个以冒号（`:`）开头的标识符，所以`:this`是一个符号，`:that`也是。实际上，符号并不复杂——在某些情况下，它们可能非常有用，您很快就会看到。
- en: 'Let’s first be clear about what a symbol is *not*: It is not a string, it is
    not a constant, and it is not a variable. A symbol is, quite simply, an identifier
    with no intrinsic meaning other than its own name. Whereas you might assign a
    value to a variable like this . . .'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先明确符号不是什么：它不是一个字符串，它不是一个常量，它也不是一个变量。符号简单地说，是一个没有内在意义的标识符，除了它的名字。而您可能像这样给变量赋值
    . . .
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'you would *not* assign a value to a symbol:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您**不会**给符号赋值：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value of a symbol is itself. So, the value of a symbol called `:name`is
    `:name`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的值就是它本身。因此，名为`:name`的符号的值是`:name`。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a more technical account of what a symbol is, refer to [Digging Deeper](ch11s03.html#digging_deeper-id10
    "Digging Deeper") in [Digging Deeper](ch11s03.html#digging_deeper-id10 "Digging
    Deeper").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于符号的更技术性描述，请参阅[深入挖掘](ch11s03.html#digging_deeper-id10 "深入挖掘")中的[深入挖掘](ch11s03.html#digging_deeper-id10
    "深入挖掘")。
- en: 'You have, of course, used symbols before. In [Chapter 2](ch02.html "Chapter 2. Class
    Hierarchies, Attributes, and Class Variables"), for instance, you created attribute
    readers and writers by passing symbols to the `attr_reader` and `attr_writer`
    methods, like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您之前已经使用过符号。例如，在[第2章](ch02.html "第2章。类层次结构、属性和类变量")中，您通过将符号传递给`attr_reader`和`attr_writer`方法来创建属性读取器和写入器，如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may recall that the previous code causes Ruby to create a `@description`
    instance variable plus a pair of getter (reader) and setter (writer) methods called
    `description`. Ruby takes the value of a symbol literally. The `attr_reader` and
    `attr_writer` methods create, from that name, variables and methods with matching
    names.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，之前的代码导致Ruby创建一个`@description`实例变量以及一对名为`description`的获取器（读取器）和设置器（写入器）方法。Ruby将符号的值视为字面量。`attr_reader`和`attr_writer`方法从该名称创建具有匹配名称的变量和方法。
- en: Symbols and Strings
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号和字符串
- en: It is a common misconception that a symbol is a type of string. After all, isn’t
    the symbol `:hello` pretty similar to the string `"hello"`? In fact, symbols are
    quite unlike strings. For one thing, each string is different—so, as far as Ruby
    is concerned, `"hello"`, `"hello"`, and `"hello"` are three separate objects with
    three separate `object_id`s.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 人们普遍认为符号是一种字符串类型。毕竟，符号`:hello`和字符串`"hello"`不是非常相似吗？实际上，符号与字符串截然不同。首先，每个字符串都是不同的——因此，从Ruby的角度来看，`"hello"`、`"hello"`和`"hello"`是三个具有三个不同`object_id`的独立对象。
- en: '*symbol_ids.rb*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbol_ids.rb*'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But a symbol is unique, so `:hello`, `:hello`, and `:hello` all refer to the
    same object with the same `object_id`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但符号是唯一的，所以`:hello`、`:hello`和`:hello`都指向具有相同`object_id`的相同对象。
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this respect, a symbol has more in common with an integer than with a string.
    Each occurrence of a given integer value, you may recall, refers to the same object,
    so `10`, `10`, and `10` may be considered to be the same object, and they have
    the same `object_id`. Remember that the actual IDs assigned to objects will change
    each time you run a program. The number itself is not significant. The important
    thing to note is that each separate object always has a unique ID, so when an
    ID is repeated, it indicates repeated references to the same object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，符号与整数的相似之处多于与字符串的相似之处。您可能记得，给定整数值的每个出现都指向同一个对象，所以`10`、`10`和`10`可以被认为是同一个对象，并且它们具有相同的`object_id`。记住，分配给对象的实际ID每次运行程序时都会改变。数字本身并不重要。重要的是要注意，每个独立的对象始终有一个唯一的ID，因此当ID重复时，它表示对同一对象的重复引用。
- en: '*ints_and_symbols.rb*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*ints_and_symbols.rb*'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also test for equality using the `equal?` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`equal?`方法进行相等性测试：
- en: '*symbols_strings.rb*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbols_strings.rb*'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Being unique, a symbol provides an unambiguous identifier. You can pass symbols
    as arguments to methods, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为独特的符号，提供了一个明确的标识符。您可以将符号作为参数传递给方法，例如：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A method might contain code to test the value of the incoming argument:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可能包含用于测试传入参数值的代码：
- en: '*symbols_1.rb*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbols_1.rb*'
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Symbols can also be used in `case` statements where they provide both the readability
    of strings and the uniqueness of integers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 符号也可以用于 `case` 语句中，它们提供了字符串的可读性和整数的唯一性：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The scope in which a symbol is declared does not affect its uniqueness. Consider
    the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声明符号的作用域不会影响其唯一性。考虑以下情况：
- en: '*symbol_ref.rb*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbol_ref.rb*'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, the variables `$f1`, `$f2`, and `$f3` are assigned the symbol `:Fred`
    in three different scopes: module `One`, module `Two`, and the “main” scope. Variables
    starting with `$` are global, so once created, they can be referenced anywhere.
    I’ll have more to say on modules in [Chapter 12](ch12.html "Chapter 12. Modules
    and Mixins"). For now, just think of them as “namespaces” that define different
    scopes. And yet each variable refers to the same symbol, `:Fred`, and has the
    same `object_id`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量 `$f1`、`$f2` 和 `$f3` 在三个不同的作用域中分别被赋值为符号 `:Fred`：模块 `One`、模块 `Two` 和“主”作用域。以
    `$` 开头的变量是全局的，因此一旦创建，就可以在任何地方引用。我将在第 12 章（[Chapter 12](ch12.html "Chapter 12. Modules
    and Mixins")）中详细介绍模块。现在，只需将它们视为定义不同作用域的“命名空间”即可。然而，每个变量都引用相同的符号 `:Fred`，并且具有相同的
    `object_id`。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even so, the “meaning” of the symbol changes according to its scope. In module
    `One`, `:Fred` refers to the class `Fred`; in module `Two`, it refers to the constant
    `Fred = 1`; and in the main scope, it refers to the method `Fred`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使如此，符号的“含义”会根据其作用域而改变。在模块 `One` 中，`:Fred` 指的是类 `Fred`；在模块 `Two` 中，它指的是常量 `Fred
    = 1`；在主作用域中，它指的是方法 `Fred`。
- en: 'A rewritten version of the previous program demonstrates this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前程序的改写版本展示了这一点：
- en: '*symbol_ref2.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbol_ref2.rb*'
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'First I access the `evalFred` method inside the module named `One` using two
    colons (`::`), which is the Ruby “scope resolution operator.” I then pass `$f1`
    to that method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我使用两个冒号（`::`）在名为 `One` 的模块内部访问 `evalFred` 方法，这是 Ruby 的“作用域解析运算符”。然后，我将 `$f1`
    传递给该方法：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this context, `Fred` is the name of a class defined inside module `One`,
    so when the `:Fred` symbol is evaluated, the module and class names are displayed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`Fred` 是在模块 `One` 内部定义的类的名称，因此当 `:Fred` 符号被评估时，会显示模块和类名：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next I pass `$f2` to the `evalFred` method of module `Two`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我将 `$f2` 传递给模块 `Two` 的 `evalFred` 方法：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this context, `Fred` is the name of a constant that is assigned the integer
    1, so that is what is displayed: `1`. And finally, I call a special method called
    simply `method`. This is a method of Object. It tries to find a method with the
    same name as the symbol passed to it as an argument and, if found, returns that
    method as an object that can then be called:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，`Fred` 是一个被赋值为整数 1 的常量，所以显示的是 `1`。最后，我调用一个名为 `method` 的特殊方法。这是一个 Object
    的方法。它试图找到与作为参数传递给它的符号具有相同名称的方法，如果找到，则返回该方法作为可以调用的对象：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Fred` method exists in the main scope, and when called, its output is
    this string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fred` 方法存在于主作用域中，当被调用时，其输出是以下字符串：'
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Naturally, since the variables `$f1`, `$f2`, and `$f3` reference the same symbol,
    it doesn’t matter which variable you use at any given point. Any variable to which
    a symbol is assigned, or, indeed, the symbol itself, will produce the same results.
    The following are equivalent:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，由于变量 `$f1`、`$f2` 和 `$f3` 引用了相同的符号，所以在任何特定时刻使用哪个变量都无关紧要。任何被符号赋值的变量，或者，实际上，符号本身，都会产生相同的结果。以下内容是等价的：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Symbols and Variables
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号和变量
- en: 'To understand the relationship between a symbol and an identifier such as a
    variable name, take a look at the *symbols_2.rb* program. It begins by assigning
    the value 1 to a local variable, `x`. It then assigns the symbol `:x` to a local
    variable, `xsymbol`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解符号和如变量名这样的标识符之间的关系，请查看 *symbols_2.rb* 程序。它首先将值 1 赋给局部变量 `x`。然后，它将符号 `:x`
    赋给局部变量 `xsymbol`：
- en: '*symbols_2.rb*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbols_2.rb*'
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At this point, there is no obvious connection between the variable `x` and
    the symbol `:x`. I have declared a method that simply takes some incoming argument
    and inspects and displays it using the `p` method. I can call this method with
    the variable and the symbol:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，变量 `x` 和符号 `:x` 之间没有明显的联系。我声明了一个方法，它简单地接受一些传入的参数，并使用 `p` 方法检查和显示它。我可以使用变量和符号调用此方法：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the data that the method prints as a result:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法打印出的数据：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In other words, the value of the `x` variable is 1, since that’s the value
    assigned to it and the value of `:x` is `:x`. But the interesting question that
    arises is this: If the value of `:x` is `:x` and this is also the symbolic name
    of the variable `x`, would it be possible to use the symbol `:x` to find the value
    of the variable `x`? Confused? I hope the next line of code will make this clearer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`x` 变量的值是 1，因为这是分配给它的值，`:x` 的值是 `:x`。但出现的一个有趣问题是：如果 `:x` 的值是 `:x`，这也是变量
    `x` 的符号名称，那么是否可以使用符号 `:x` 来找到变量 `x` 的值？困惑了吗？我希望下一行代码会使这一点更清晰：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `id2name` is a method of the Symbol class. It returns the name or string
    corresponding to the symbol (the `to_s` method would perform the same function);
    the end result is that, when given the symbol `:x` as an argument, `id2name` returns
    the string “x.” Ruby’s `eval` method (which is defined in the Kernel class) is
    able to evaluate expressions within strings. In the present case, that means it
    finds the string “x” and tries to evaluate it as though it were executable code.
    It finds that `x` is the name of a variable and that the value of `x` is 1\. So,
    the value 1 is passed to `amethod`. You can verify this by running *symbols2.rb*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`id2name` 是 Symbol 类的一个方法。它返回与符号对应的名称或字符串（`to_s` 方法会执行相同的功能）；最终结果是，当给定符号
    `:x` 作为参数时，`id2name` 返回字符串“x。”Ruby 的 `eval` 方法（在 Kernel 类中定义）能够评估字符串中的表达式。在本例中，这意味着它找到字符串“x”并尝试将其作为可执行代码进行评估。它发现
    `x` 是一个变量的名称，`x` 的值是 1。因此，值 1 被传递给 `amethod`。你可以通过运行 *symbols2.rb* 来验证这一点。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Evaluating data as code is explained in more detail in [Chapter 20](ch20.html
    "Chapter 20. Dynamic Programming").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据作为代码进行评估的详细解释请参阅[第20章](ch20.html "第20章。动态规划")。
- en: Things can get even trickier. Remember that the variable `xsymbol` has been
    assigned the symbol `:x`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事情可能会变得更加复杂。记住，变量 `xsymbol` 已经被分配了符号 `:x`。
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That means that if you eval `:xsymbol`, you can obtain the name assigned to
    it—that is, the symbol `:x`. Having obtained `:x`, you can go on to evaluate this
    also, giving the value of `x`, namely, 1:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你 eval `:xsymbol`，你可以获得分配给它的名称——即符号 `:x`。获得 `:x` 后，你可以继续评估这个符号，得到 `x`
    的值，即 1：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you’ve seen, when used to create attribute accessors, symbols can refer
    to method names. You can make use of this by passing a method name as a symbol
    to the `method` method and then calling the specified method using the `call`
    method:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当用于创建属性访问器时，符号可以引用方法名。你可以通过将方法名作为符号传递给 `method` 方法，然后使用 `call` 方法调用指定的方法来利用这一点：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `call` method lets you pass arguments, so, just for the heck of it, you
    could pass an argument by evaluating a symbol:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`call` 方法允许你传递参数，所以，只是为了好玩，你可以通过评估一个符号来传递一个参数：'
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If this seems complicated, take a look at a simpler example in *symbols_3.rb*.
    This begins with this assignment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很复杂，请查看 *symbols_3.rb* 中的更简单示例。它从以下赋值开始：
- en: '*symbols_3.rb*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*symbols_3.rb*'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here `method(:mymethod)` looks for a method with the name specified by the symbol
    passed as an argument (`:mymethod`), and if one is found, it returns the Method
    object with the corresponding name. In my code I have a method called `mymethod`,
    and this is now assigned to the variable `this_is_a_method_name`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `method(:mymethod)` 寻找由作为参数传递的符号指定的方法名（`:mymethod`），如果找到了，它将返回具有相应名称的方法对象。在我的代码中，我有一个名为
    `mymethod` 的方法，现在它被分配给了变量 `this_is_a_method_name`。
- en: 'When you run this program, you will see that the first line of output prints
    the value of the variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到输出第一行打印了变量的值：
- en: '[PRE28]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This shows that the variable `this_is_a_method_name` has been assigned the
    method, `mymethod`, which is bound to the Object class (as are all methods that
    are entered as “freestanding” functions). To double-check that the variable really
    is an instance of the Method class, the next line of code prints out its class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明变量 `this_is_a_method_name` 已经被分配了方法 `mymethod`，该方法绑定到 Object 类（所有作为“独立”函数输入的方法都是绑定到
    Object 类的）。为了验证变量确实是 Method 类的实例，下一行代码打印出它的类：
- en: '[PRE29]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Okay, so if it’s really and truly a method, then you should be able to call
    it, shouldn’t you? To do that, you need to use the `call` method. That is what
    the last line of code does:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果这真的是一个方法，那么你应该能够调用它，不是吗？要做到这一点，你需要使用 `call` 方法。这正是代码最后一行所做的事情：
- en: '[PRE30]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why Use Symbols?
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用符号？
- en: 'Some methods in the Ruby class library specify symbols as arguments. Naturally,
    if you need to call those methods, you are obliged to pass symbols to them. Other
    than in those cases, however, there is no absolute requirement to use symbols
    in your own programming. For many Ruby programmers, the “conventional” data types
    such as strings and integers are perfectly sufficient. However, many Ruby programmers
    do like to use symbols as the keys into hashes. When you look at the Rails framework
    in [Chapter 19](ch19.html "Chapter 19. Ruby on Rails"), for example, you will
    see examples similar to the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 类库中的一些方法指定符号作为参数。自然地，如果你需要调用这些方法，你必须向它们传递符号。然而，除了这些情况之外，在你的编程中并没有绝对必要使用符号。对于许多
    Ruby 程序员来说，“传统”的数据类型，如字符串和整数，已经足够完美。然而，许多 Ruby 程序员确实喜欢使用符号作为散列的键。例如，当你查看第 19 章（ch19.html
    "第 19 章。Ruby on Rails"）中的 Rails 框架时，你会看到类似以下示例的内容：
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Symbols do have a special place in “dynamic” programming, however. For example,
    a Ruby program is able to create a new method at runtime by calling, within the
    scope of a certain class, `define_method` with a symbol representing the method
    to be defined and a block representing the code of the method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，符号在“动态”编程中确实有一个特殊的位置。例如，Ruby 程序能够在某个类的范围内通过调用 `define_method` 并传递一个表示要定义的方法的符号和一个表示方法代码的代码块来在运行时创建一个新的方法：
- en: '*add_method.rb*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_method.rb*'
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After the previous code executes, the Array class will have gained a method
    named `aNewMethod`. You can verify this by calling `method_defined?` with a symbol
    representing the method name:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前的代码后，Array 类将获得一个名为 `aNewMethod` 的方法。你可以通过调用 `method_defined?` 并传递一个表示方法名称的符号来验证这一点：
- en: '[PRE33]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And, of course, you can call the method itself:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以调用该方法本身：
- en: '[PRE34]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can remove an existing method at runtime in a similar way by calling `remove_method`
    inside a class with a symbol providing the name of the method to be removed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在类内部调用 `remove_method` 并传递一个提供要删除的方法名称的符号来以类似的方式在运行时删除现有方法：
- en: '[PRE35]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Dynamic programming is invaluable in applications that need to modify the behavior
    of the Ruby program while that program is still executing. Dynamic programming
    is widely used in the Rails framework, for example, and it is discussed in depth
    in the final chapter of this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划在需要修改正在执行中的 Ruby 程序行为的应用中非常有价值。例如，在 Rails 框架中广泛使用动态规划，并在本书的最后一章中进行了深入讨论。
- en: Digging Deeper
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Symbols are fundamental to Ruby. Here you will learn why that is so and how
    you can display all the symbols available.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是 Ruby 的基础。在这里，你将了解为什么是这样，以及如何显示所有可用的符号。
- en: What Is a Symbol?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是符号？
- en: Previously, I said that a symbol is an identifier whose value is itself. That
    describes, in a broad sense, the way that symbols behave from the point of view
    of the Ruby programmer. But it doesn’t tell you what symbols are *literally* from
    the point of view of the Ruby interpreter. A symbol is, in fact, a pointer into
    the symbol table. The symbol table is Ruby’s internal list of known identifiers—such
    as variable and method names.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说过，符号是一个其值就是自身的标识符。从 Ruby 程序员的视角来看，这大致描述了符号的行为方式。但这并没有告诉你从 Ruby 解释器的视角来看符号是什么。实际上，符号是符号表的指针。符号表是
    Ruby 的已知标识符的内部列表——例如变量和方法名称。
- en: 'If you want to take a peek deep inside Ruby, you can display all the symbols
    that Ruby knows about like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要深入了解 Ruby，你可以像这样显示 Ruby 所知道的全部符号：
- en: '*allsymbols.rb*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*allsymbols.rb*'
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will shows thousands of symbols including method names such as `:to_s`
    and `:reverse`, global variables such as `:$/` and `:$DEBUG`, and class names
    such as `:Array` and `:Symbol`. You may restrict the number of symbols displayed
    using array indexes like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示包括 `:to_s` 和 `:reverse` 这样的方法名称、`:$/` 和 `:$DEBUG` 这样的全局变量、`:Array` 和 `:Symbol`
    这样的类名称在内的成千上万的符号。你可以使用数组索引来限制显示的符号数量，如下所示：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Ruby 1.8, you can’t sort symbols since symbols are not considered to be
    inherently sequential. In Ruby 1.9, sorting is possible, and the symbol characters
    are sorted as though they were strings:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 中，你不能对符号进行排序，因为符号不被认为是固有的顺序。在 Ruby 1.9 中，排序是可能的，符号字符被像字符串一样排序：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The easiest way to display a sorted list of symbols in a way that avoids incompatibility
    problems related to Ruby versions is to convert the symbols to strings and sort
    those. In the following code, I pass all the symbols known to Ruby into a block,
    convert each symbol to a string, and collect the strings into a new array that
    is assigned to the `str_array` variable. Now I can sort this array and display
    the results:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在避免与Ruby版本相关的兼容性问题的情况下，显示符号排序列表的最简单方法是将符号转换为字符串，并对这些字符串进行排序。在下面的代码中，我将Ruby所知的所有符号传递到一个块中，将每个符号转换为字符串，并将这些字符串收集到一个新的数组中，该数组被分配给`str_array`变量。现在我可以对这个数组进行排序并显示结果：
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
