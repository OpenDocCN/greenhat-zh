- en: Part III-2. NETWORK FILE AND RESOURCE SHARING PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 III-2 部分：网络文件和资源共享协议
- en: '[Chapter 58](ch58.html "Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE
    TCP/IP NETWORK FILE SYSTEM (NFS)")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 58 章](ch58.html "第 58 章。网络文件和资源共享与 TCP/IP 网络文件系统 (NFS)")'
- en: 'To the typical end user, networks were created for one main reason: to permit
    the sharing of information. Most information on computers exists in the form of
    files that reside on storage devices such as hard disks; thus, one primary purpose
    of networks is to let users share files. File transfer and message transfer protocols
    allow users to manually move files from one place to the next, but a more automated
    method is preferable in many cases. Internetworking protocols provide such capabilities
    in the form of *network file and resource sharing protocols*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用户来说，网络的创建主要是出于一个原因：允许信息共享。计算机上的大多数信息都以文件的形式存在，这些文件存储在硬盘等存储设备上；因此，网络的一个主要目的是让用户能够共享文件。文件传输和消息传输协议允许用户手动将文件从一个地方移动到另一个地方，但在许多情况下，更自动化的方法更受欢迎。互联网协议提供了一种以*网络文件和资源共享协议*的形式来实现这些功能的能力。
- en: 'In this brief part, I describe network file and resource sharing protocols
    from the standpoint of TCP/IP networks. The one chapter here provides an overview
    of the concepts and operation of this class of protocols, discussing some of the
    elements common to the different types. It then describes the most common one
    defined specifically for TCP/IP: the Network File System (NFS).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分简短的介绍中，我将从 TCP/IP 网络的角度描述网络文件和资源共享协议。这一章提供了这类协议的概念和操作概述，讨论了不同类型协议中的一些共同元素。然后，它描述了为
    TCP/IP 特定定义的最常见协议：网络文件系统（NFS）。
- en: Obviously, network file and resource sharing protocols and services are closely
    related to the file and message transfer protocols I mentioned earlier. For example,
    NFS can be used to accomplish tasks similar to those performed by TCP/IP file
    and message transfer applications such as the File Transfer Protocol (FTP) and
    the Hypertext Transfer Protocol (HTTP). I consider those protocols more like specific
    end-user applications unto themselves, and therefore describe them in later parts
    on application protocols (FTP in [Part III-6](pt17.html "Part III-6. TCP/IP GENERAL
    FILE TRANSFER PROTOCOLS") and HTTP in [Part III-8](pt19.html "Part III-8. TCP/IP
    WORLD WIDE WEB AND THE HYPERTEXT TRANSFER PROTOCOL (HTTP)")). I realize that this
    distinction between manual and automatic file transfer is somewhat arbitrary,
    but then, so are a lot of other things in the great world of networking.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，网络文件和资源共享协议和服务与我之前提到的文件和消息传输协议密切相关。例如，NFS 可以用来完成与 TCP/IP 文件和消息传输应用程序（如文件传输协议（FTP）和超文本传输协议（HTTP））执行的任务类似的任务。我认为这些协议更像是特定的终端用户应用程序，因此将在后面的应用协议部分（[第
    III-6 部分](pt17.html "第 III-6 部分。TCP/IP 通用文件传输协议") 中的 FTP 和 [第 III-8 部分](pt19.html
    "第 III-8 部分。TCP/IP 互联网和超文本传输协议 (HTTP)") 中的 HTTP）中描述它们。我意识到这种手动和自动文件传输之间的区别有些武断，但在这个广阔的网络世界中，许多其他事情也都是这样。
- en: Chapter 58. NETWORK FILE AND RESOURCE SHARING AND THE TCP/IP NETWORK FILE SYSTEM
    (NFS)
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 58 章：网络文件和资源共享与 TCP/IP 网络文件系统（NFS）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: File and resource sharing protocols are important because they let users seamlessly
    share files over a network. Due to the dominance of Microsoft operating systems
    in the industry, many people are familiar with the way Microsoft networking can
    be used in this way. However, Microsoft is somewhat of a "Johnny come lately"
    to file sharing protocols. Long before Microsoft Windows even existed, the *Network
    File System (NFS)* was letting users share files over a network using the UNIX
    operating system.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和资源共享协议很重要，因为它们允许用户在网络中无缝共享文件。由于微软操作系统在行业中的主导地位，许多人熟悉微软网络如何以这种方式使用。然而，微软在文件共享协议方面可以说是“后来者”。在微软
    Windows 存在之前很久，*网络文件系统（NFS）*就已经让用户使用 UNIX 操作系统在网络上共享文件。
- en: In this chapter, I provide a brief look at network file and resource sharing
    in TCP/IP, with a focus on the operation of NFS. I begin with a general look at
    file and resource sharing protocol concepts. Then I provide an overview and history
    of NFS, and discuss its common versions and standards. I describe the architecture
    of NFS and the three components that compose it. I then describe the NFS file
    system model and how data is encoded using the *External Data Representation (XDR)*
    standard. I explain the client/server operation of NFS using *Remote Procedure
    Calls (RPCs)*. I then list the procedures and operations used in NFS, and conclude
    with a description of the separate NFS Mount protocol, used to attach network
    resources to a device.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要介绍了TCP/IP中的网络文件和资源共享，重点关注NFS的操作。我首先概述了文件和资源共享协议的概念。然后，我提供了NFS的概述和历史，讨论了其常见版本和标准。我描述了NFS的架构和组成它的三个组件。接着，我描述了NFS文件系统模型以及如何使用*外部数据表示（XDR）*标准进行数据编码。我解释了NFS的客户端/服务器操作，使用*远程过程调用（RPCs）*。然后，我列出了NFS中使用的程序和操作，并以对用于将网络资源附加到设备的独立NFS挂载协议的描述结束。
- en: File and Resource Sharing Concepts and Components
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和资源共享概念和组件
- en: 'A primary reason why networks and internetworks are created is to allow files
    and other resources to be shared among computers. Thus, in any internetworking
    protocol stack, we need some mechanism by which users can easily move files across
    a network in a simple way. Application layer file and message transfer protocols
    like the File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP) were
    created for just this purpose: to let users access resources across a network
    while hiding the details of how the network operates at the layers below them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和互联网创建的一个主要原因是允许文件和其他资源在计算机之间共享。因此，在任何互联网协议栈中，我们需要某种机制，使用户能够以简单的方式轻松地在网络上移动文件。为了这个目的，创建了应用层文件和消息传输协议，如文件传输协议（FTP）和超文本传输协议（HTTP）。这些协议的目的是让用户能够访问网络上的资源，同时隐藏它们在下面操作层的细节。
- en: However, even though these protocols hide the lower layers, they are somewhat
    *manual* in nature. They require a user to invoke an application protocol and
    use specific commands that accomplish network-based resource access. In fact,
    the problem with such protocols isn't so much that they require manual intervention,
    but that they make sharing more difficult because they don't allow a file to be
    used directly on another resource.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这些协议隐藏了底层，但它们在本质上有些*手动*。它们需要用户调用应用程序协议并使用特定的命令来完成基于网络的资源访问。事实上，这类协议的问题并不在于它们需要手动干预，而在于它们使共享变得更加困难，因为它们不允许文件直接在另一个资源上使用。
- en: Consider a protocol like FTP. It does lets you share files between machines,
    but it draws a clear distinction between a file that is yours and a file that
    is someone else's. If you want to use a file on Joe's machine, you must transfer
    it to your machine, use it, and then transfer it back. Also, if you don't transfer
    the file back, Joe might never even see the updated version.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑像FTP这样的协议。它确实允许你在机器之间共享文件，但它清楚地区分了属于你的文件和属于别人的文件。如果你想使用乔机器上的文件，你必须将其传输到你的机器上，使用它，然后再传输回来。此外，如果你不将文件传回，乔可能永远也看不到更新的版本。
- en: The Power of File and Resource Sharing Protocols
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和资源共享协议的力量
- en: The ultimate in file and resource sharing is achieved when we can hide even
    the details of where the files are located and the commands required to move them
    around. Such a system would use an *automatic* sharing protocol that lets files
    and resources be used over a network seamlessly. Once set up, a network resource
    in such a scheme can be used in much the same way that one on a local computer
    is. Such protocols are sometimes called *network file and resource sharing protocols*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们能够隐藏文件所在位置和移动它们的命令的细节时，我们就达到了文件和资源共享的极致。这样的系统将使用一种*自动*共享协议，允许文件和资源在网络中无缝使用。一旦设置好，这种方案中的网络资源就可以像本地计算机上的资源一样使用。这些协议有时被称为*网络文件和资源共享协议*。
- en: It is this blurring of the line between a local file and a remote one that makes
    file and resource sharing protocols so powerful. Once the system is set up, users
    can access resources on another host as readily as on their own host. This is
    an extremely useful capability, especially in the modern era of client/server
    computing. For example, it allows a company to store information that is used
    by many individuals in a common place, such as in a directory on a server, where
    each of those individuals can access it. In essence, there is a virtual file system
    that spans network devices, instead of being simply on one storage device on a
    single computer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种本地文件和远程文件之间界限的模糊，使得文件和资源共享协议如此强大。一旦系统设置完成，用户就可以像访问自己的主机上的资源一样轻松地访问另一台主机上的资源。这是一种极其有用的功能，尤其是在客户端/服务器计算的现代时代。例如，它允许公司在一个共同的地方存储许多个人使用的信息，例如在服务器上的目录中，这样每个人都可以访问它。本质上，有一个跨越网络设备的虚拟文件系统，而不是仅仅在单台计算机的一个存储设备上。
- en: Components of a File and Resource Sharing Protocol
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件和资源共享协议的组成部分
- en: 'File and transfer protocols allow users to share files effortlessly, but that
    doesn''t mean no work is involved. The work is still there, but it''s shouldered
    by those who write the protocol and those who administer its operation. Generally
    speaking, these protocols require at least the following general components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和传输协议使用户能够轻松共享文件，但这并不意味着没有工作要做。工作仍然存在，但由编写协议和负责其操作的人员承担。一般来说，这些协议至少需要以下一般组件：
- en: '**File System Model and Architecture** A mechanism for defining resources and
    files to be shared, and for describing how the virtual file system works.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统模型和架构** 定义要共享的资源文件，并描述虚拟文件系统如何工作的机制。'
- en: '**Resource Access Method** Procedures that describe how users can attach or
    detach a distant resource from their local host.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源访问方法** 描述用户如何将远程资源附加或从其本地主机分离的操作过程。'
- en: '**Operation Set** A set of operations for accomplishing various tasks that
    the users need to perform on files on other hosts.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作集** 一组操作，用于完成用户需要在其他主机上的文件上执行的各种任务。'
- en: '**Messaging Protocol** Message formats that carry operations to be performed,
    status information, and more, and a protocol for exchanging these messages between
    devices.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息协议** 携带要执行的操作、状态信息等消息格式，以及在这些设备之间交换这些消息的协议。'
- en: '**Administrative Tools** Miscellaneous functionality needed to support the
    operation of the protocol and tie the other elements together.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理工具** 支持协议操作并将其他元素结合在一起所需的辅助功能。'
- en: NFS Design Goals, Versions, and Standards
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS 设计目标、版本和标准
- en: 'The histories of TCP/IP and the Internet are inextricably linked, as I discussed
    in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE").
    However, there is a third partner that is less often mentioned but very much part
    of the development history of these technologies. That is the operating system
    that ran on the machines in the early Internet and is still used on a large percentage
    of Internet servers today: the *UNIX* operating system.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在 [第 8 章](ch08.html "第 8 章。TCP/IP 协议套件和架构") 中讨论的那样，TCP/IP 和互联网的历史密不可分。然而，还有一个第三合作伙伴，虽然不常被提及，但却是这些技术发展历史的重要组成部分。那就是早期互联网上运行的操作系统，今天仍然被大量互联网服务器使用：*UNIX*
    操作系统。
- en: Sun Microsystems was one of the early pioneers in the development of UNIX and
    in TCP/IP networking. Early in the evolution of TCP/IP, certain tools were created
    to allow a user to access another machine over the network—after all, this is
    arguably the entire point of networking. Remote-access protocols such as Telnet
    allowed a user to log in to another host computer and use resources there. FTP
    allowed people to copy a file from a distant machine to their own and edit it.
    However, neither of these solutions really fit the bill of allowing a user to
    access a file on a remote machine in a way similar to how a local file is used.
    To fill this need, Sun created the *Network File System (NFS)*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Sun Microsystems 是 UNIX 和 TCP/IP 网络开发的早期先驱之一。在 TCP/IP 早期的发展中，创建了一些工具，允许用户通过网络访问另一台机器——毕竟，这可以说是网络的核心目的。远程访问协议如
    Telnet 允许用户登录到另一台主机计算机并使用那里的资源。FTP 允许人们从远程机器复制文件到自己的机器并编辑它。然而，这两种解决方案都无法真正满足用户以类似本地文件使用方式访问远程机器上的文件的需求。为了满足这一需求，Sun
    创建了 *网络文件系统 (NFS)*。
- en: NFS Design Goals
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS 设计目标
- en: NFS was specifically designed with the goal of eliminating the distinction between
    a local and a remote file. To a user, after the appropriate setup is performed,
    a file on a remote computer can be used as if it were on a hard disk on the user's
    local machine. Sun also crafted NFS specifically to be vendor-independent, to
    ensure that both hardware made by Sun and that made by other companies could interoperate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NFS专门设计的目标是消除本地和远程文件之间的区别。对于用户来说，在完成适当的设置后，远程计算机上的文件可以像在用户的本地机器上的硬盘上一样使用。Sun还专门设计了NFS以确保硬件的厂商独立性，以确保Sun和其他公司制造的硬件能够互操作。
- en: One of the most important design goals of NFS was performance. Obviously, even
    if you set up a file on a distant machine as if it were local, the actual read
    and write operations must travel across a network. Usually, this takes more time
    than simply sending data within a computer, so the protocol itself needed to be
    as lean and mean as possible. This decision led to some interesting choices, such
    as the use of the unreliable User Datagram Protocol (UDP) for transport in TCP/IP,
    instead of the reliable Transmission Control Protocol (TCP), as with most file
    transfer protocols. This, in turn, has interesting implications on how the protocol
    works as a whole.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NFS最重要的设计目标之一是性能。显然，即使你将文件设置在远程机器上，就像它是本地的一样，实际的读写操作也必须跨越网络。通常，这比在计算机内部发送数据花费的时间要多，因此协议本身需要尽可能精简高效。这个决定导致了一些有趣的选择，例如在TCP/IP中使用不可靠的用户数据报协议（UDP）进行传输，而不是像大多数文件传输协议那样使用可靠的传输控制协议（TCP）。这反过来又对整个协议的工作方式产生了有趣的影响。
- en: Another key design goal for NFS was simplicity (which of course is related to
    performance). NFS servers are said to be *stateless*, which means that the protocol
    is designed so that servers do not need to keep track of which files have been
    opened by which clients. This allows requests to be made independently of each
    other, and allows a server to gracefully deal with events such as crashes without
    the need for complex recovery procedures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: NFS的另一个关键设计目标是简单性（这当然与性能相关）。据说NFS服务器是无状态的，这意味着协议被设计成服务器不需要跟踪哪些客户端打开了哪些文件。这允许请求相互独立地发出，并允许服务器优雅地处理诸如崩溃等事件，而无需复杂的恢复程序。
- en: The protocol is also designed so that if requests are lost or duplicated, file
    corruption will not occur.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议还设计成，如果请求丢失或重复，不会发生文件损坏。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *Network File System (NFS)* was created to allow client
    hosts to access files on remote servers as if they were local. It was designed
    primarily with the goals of performance, simplicity, and cross-vendor compatibility.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 网络文件系统（NFS）的创建是为了允许客户端主机像访问本地文件一样访问远程服务器上的文件。它主要设计的目标是性能、简单性和跨厂商兼容性。'
- en: NFS Versions and Standards
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS版本和标准
- en: 'Since it was initially designed and marketed by Sun, NFS began as a de facto
    standard. The first widespread version of NFS was version 2 (NFSv2), and this
    is still the most common version of the protocol. NFSv2 was eventually codified
    as an official TCP/IP standard when RFC 1094, "NFS: Network File System Protocol
    Specification," was published in 1989.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它最初是由Sun设计和推广的，NFS最初是一个事实上的标准。NFS的第一个广泛使用的版本是版本2（NFSv2），这仍然是该协议最常用的版本。NFSv2最终在1989年发布的RFC
    1094，“NFS：网络文件系统协议规范”中被正式确定为TCP/IP标准。
- en: NFS version 3 (NFSv3) was subsequently developed, and it was published in 1995
    as RFC 1813, "NFS Version 3 Protocol Specification." It is similar to NFSv2, but
    makes a few changes and adds some new capabilities. These include support for
    larger files and file transfers, better support for setting file attributes, and
    several new file access and manipulation procedures.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随后开发了NFS版本3（NFSv3），并于1995年作为RFC 1813，“NFS版本3协议规范”发布。它与NFSv2相似，但进行了一些更改并添加了一些新功能。这些包括对大文件和文件传输的支持，更好的文件属性设置支持，以及几个新的文件访问和操作过程。
- en: 'NFS version 4 (NFSv4) was published in 2000 as RFC 3010, "NFS Version 4 Protocol."
    Where NFSv3 contained only relatively small changes to the previous version, NFSv4
    is virtually a rewrite of NFS. It includes numerous changes, most notably the
    following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NFS版本4（NFSv4）于2000年作为RFC 3010，“NFS版本4协议”发布。与NFSv3只包含对先前版本相对较小的更改相比，NFSv4几乎是对NFS的完全重写。它包括许多更改，最值得注意的是以下内容：
- en: Reflecting the needs of modern internetworking, NFSv4 puts greater emphasis
    on security.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反映现代互连网络的需求，NFSv4更加重视安全性。
- en: NFSv4 introduces the concept of a *compound* procedure, which allows several
    simpler procedures to be sent from a client to a server as a group.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFSv4 引入了 *复合过程* 的概念，允许将几个更简单的过程作为一个组从客户端发送到服务器。
- en: NFSv4 almost doubles the number of individual procedures that a client can use
    in accessing a file on an NFS server.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFSv4 几乎将客户端在访问 NFS 服务器上的文件时可以使用的单个过程数量翻了一番。
- en: NFSv4 makes a significant change in messaging, with the specification of TCP
    as the transport protocol for NFS.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFSv4 在消息传递方面进行了重大改变，指定 TCP 作为 NFS 的传输协议。
- en: NFSv4 integrates the functions of the Mount protocol into the basic NFS protocol,
    eliminating it as a separate protocol as it is in previous versions.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFSv4 将挂载协议的功能集成到基本的 NFS 协议中，消除了作为单独协议的存在，就像在之前的版本中那样。
- en: The NFSv4 standard also has a lot more details about implementation and optional
    features than the earlier standards—it's 275 pages long. So much for simplicity!
    RFC 3010 was later updated by RFC 3530, "Network File System (NFS) Version 4 Protocol,"
    in April 2003\. This standard makes several further revisions and clarifications
    to the operation of NFSv4.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期标准相比，NFSv4 标准在实现和可选功能方面有更多细节——它长达 275 页。这就是简单性的代价！RFC 3010 后来在 2003 年 4 月被
    RFC 3530 更新，即 "网络文件系统 (NFS) 版本 4 协议"。该标准对 NFSv4 的操作进行了进一步的修订和澄清。
- en: NFS Architecture and Components
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络文件系统架构和组件
- en: NFS follows the classic TCP/IP client/server model of operation. A hard disk
    or a directory on a storage device of a particular computer can be set up by an
    administrator as a shared resource. This resource can then be accessed by client
    computers, which *mount* the shared drive or directory, causing it to appear as
    if it were a local directory on the client machine. Some computers may act as
    only servers or only clients; others may be both, sharing some of their own resources
    and accessing resources provided by others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: NFS 遵循经典的 TCP/IP 客户端/服务器操作模型。管理员可以将特定计算机的硬盘或存储设备上的目录设置为共享资源。然后，客户端计算机可以访问此资源，通过
    *挂载* 共享驱动器或目录，使其在客户端机器上看起来就像是一个本地目录。有些计算机可能只作为服务器或只作为客户端；而其他计算机可能两者都是，共享它们的一些资源并访问他人提供的资源。
- en: Considered from the perspective of the TCP/IP protocol suite as a whole, NFS
    is a single protocol that resides at the application layer of the TCP/IP (DOD)
    model (described in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND
    ARCHITECTURE")). This TCP/IP layer encompasses the session, presentation, and
    application layers of the OSI Reference Model (described in [Chapter 6](ch06.html
    "Chapter 6. OSI REFERENCE MODEL LAYERS")). As I have said before in this book,
    I don't see much value in trying to differentiate between layers 5 through 7 most
    of the time. In some situations, however, these layers can be helpful in understanding
    the architecture of a protocol, and that's the case with NFS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从整个 TCP/IP 协议套件的视角来看，NFS 是一个位于 TCP/IP (DOD) 模型应用层的单一协议（在 [第 8 章](ch08.html "第
    8 章. TCP/IP 协议套件和架构") 中描述）。此 TCP/IP 层包括 OSI 参考模型（在 [第 6 章](ch06.html "第 6 章. OSI
    参考模型层") 中描述）的会话、表示和应用层。正如我在本书中之前所说，我通常不认为在大多数情况下尝试区分第 5 层到第 7 层有很大的价值。然而，在某些情况下，这些层可以帮助理解协议的架构，而
    NFS 就是这种情况。
- en: NFS Main Components
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络文件系统主要组件
- en: 'The operation of NFS is defined in the form of three main components that can
    be viewed as logically residing at each of the three OSI model layers corresponding
    to the TCP/IP application layer, as illustrated in [Figure 58-1](ch58s03.html#nfs_architectural_components
    "Figure 58-1. NFS architectural components"):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 网络文件系统 (NFS) 的操作以三个主要组件的形式定义，这些组件可以视为位于三个 OSI 模型层中，对应于 TCP/IP 应用层，如图 [图 58-1](ch58s03.html#nfs_architectural_components
    "图 58-1. 网络文件系统架构组件") 所示：
- en: '**Remote Procedure Call (RPC)** RPC is a generic session layer service used
    to implement client/server internetworking functionality. It extends the notion
    of a program calling a local procedure on a particular host computer to the calling
    of a procedure on a remote device across a network.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程过程调用 (RPC)** RPC 是一种通用的会话层服务，用于实现客户端/服务器互连功能。它将程序在特定主机计算机上调用本地过程的概念扩展到通过网络在远程设备上调用过程。'
- en: '**External Data Representation (XDR)** XDR is a descriptive language that allows
    data types to be defined in a consistent manner. XDR conceptually resides at the
    presentation layer. Its universal representations allow data to be exchanged using
    NFS between computers that may use very different internal methods of storing
    data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部数据表示 (XDR)** XDR 是一种描述性语言，它允许以一致的方式定义数据类型。从概念上讲，XDR 位于表示层。它的通用表示允许使用 NFS
    在可能使用非常不同的内部数据存储方法之间的计算机之间交换数据。'
- en: '**NFS Procedures and Operations** The actual functionality of NFS is implemented
    in the form of procedures and operations that conceptually function at layer 7
    of the OSI model. These procedures specify particular tasks to be carried out
    on files over the network, using XDR to represent data and RPC to carry the commands
    across an internetwork.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFS 程序和操作** NFS 的实际功能以程序和操作的形式实现，从概念上讲，这些程序在 OSI 模型的第 7 层运行。这些程序指定在网络上的文件上执行特定任务，使用
    XDR 表示数据，并通过 RPC 在互联网上传输命令。'
- en: These three key "subprotocols," if you will, compose the bulk of the NFS protocol.
    Each is described in more detail in a separate section in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个关键的“子协议”，如果你愿意这样称呼，构成了 NFS 协议的大部分。每个子协议在本章的单独部分中都有更详细的描述。
- en: '![NFS architectural components](httpatomoreillycomsourcenostarchimages288191.png.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![NFS 架构组件](httpatomoreillycomsourcenostarchimages288191.png.jpg)'
- en: Figure 58-1. NFS architectural components
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 58-1. NFS 架构组件
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** NFS resides architecturally at the TCP/IP application layer.
    Even though in the TCP/IP model no clear distinction is made generally between
    the functions of layers 5 through 7 of the OSI Reference Model, NFS''s three subprotocols
    correspond well to those three layers as shown.NFS resides architecturally at
    the application layer of the TCP/IP model. Its functions are implemented primarily
    through three distinct functional components that implement the functions of layers
    5 through 7 of the OSI Reference Model: the *Remote Procedure Call (RPC)*, which
    provide session-layer services; the *External Data Representation (XDR)* standard,
    which manages data representation and conversion; and *NFS procedures and operations*,
    which allow application layer tasks to be performed using the other two components.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 从架构上讲，NFS 位于 TCP/IP 应用层。尽管在 TCP/IP 模型中，OSI 参考模型第 5 层至第 7 层的功能通常没有明确的区分，但
    NFS 的三个子协议很好地对应了这三个层次，如图所示。NFS 位于 TCP/IP 模型的应用层。其功能主要通过三个不同的功能组件来实现，这些组件实现了 OSI
    参考模型第 5 层至第 7 层的功能：*远程过程调用 (RPC)*，提供会话层服务；*外部数据表示 (XDR)* 标准，管理数据表示和转换；以及 *NFS
    程序和操作*，允许使用其他两个组件在应用层执行任务。'
- en: Other Important NFS Functions
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他重要的 NFS 功能
- en: 'Aside from it three main components, the NFS protocol as a whole involves a
    number of other functions, most notably the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个主要组件之外，NFS 协议作为一个整体还涉及许多其他功能，最值得注意的是以下功能：
- en: '**Mount Protocol** A specific decision was made by the creators of NFS to not
    have NFS deal with the particulars of file opening and closing. Instead, a separate
    protocol called the *Mount* protocol is used for this purpose. Accessing a file
    or other resource over the network involves first *mounting* it using this protocol.
    The Mount protocol is architecturally distinct, but obviously closely related
    to NFS, and is even defined in an appendix of the NFS standard. I describe it
    in the last section in this chapter. (Note that in NFSv4, the functions of the
    Mount protocol have been incorporated into NFS proper.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载协议** NFS 的创建者做出了一个特定的决定，即不处理文件打开和关闭的细节。相反，使用一个名为 *挂载* 的单独协议来处理这个问题。通过网络访问文件或其他资源首先需要使用此协议进行
    *挂载*。挂载协议在架构上是独立的，但显然与 NFS 密切相关，甚至在 NFS 标准的附录中定义。我在本章的最后部分对其进行了描述。（注意，在 NFSv4
    中，挂载协议的功能已被纳入到 NFS 本身。）'
- en: '**NFS File System Model** NFS uses a particular model to implement the directory
    and file structure of the systems that use it. This model is closely based on
    the file system model of UNIX, but is not specific to only that operating system.
    It is discussed in conjunction with the explanation of the Mount protocol at the
    end of this chapter.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**NFS 文件系统模型** NFS 使用特定的模型来实现使用它的系统的目录和文件结构。这个模型与 UNIX 文件系统模型紧密相关，但并不仅限于该操作系统。它在本章末尾关于挂载协议的解释中进行了讨论。'
- en: '**Security** Versions 2 and 3 of NFS include only limited security provisions.
    They use UNIX-style authentication to check permissions for various operations.
    NFSv4 greatly increases the security options available for NFS implementations.
    These include provisions for multiple authentication and encryption algorithms,
    and many changes to the protocol as a whole to make it more secure.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性** NFS的版本2和3仅包含有限的安全措施。它们使用UNIX风格的认证来检查各种操作的权限。NFSv4大大增加了NFS实现可用的安全选项。这包括多个认证和加密算法的规定，以及整个协议的许多变化，使其更加安全。'
- en: NFS Data Definition with the External Data Representation (XDR) Standard
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部数据表示（XDR）标准的NFS数据定义
- en: The overall idea behind NFS is to allow you to read from or write to a file
    on another computer as readily as you do on your local machine. Of course, the
    files on your local machine are all stored in the same file system, using the
    same file structure and the same means of representing different types of data.
    You can't be sure that this will be the case when accessing a remote device, and
    this creates a bit of a Tower of Babel problem.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: NFS背后的整体思想是允许你像在本地机器上一样轻松地从另一台计算机的文件中读取或写入。当然，你本地机器上的所有文件都存储在同一个文件系统中，使用相同的文件结构和表示不同类型数据的方式。当你访问远程设备时，你无法确定这种情况是否成立，这会引发一点巴别塔问题。
- en: 'One approach would be to simply restrict access only to remote files on machines
    that use the same operating system. However, this would remove much of the effectiveness
    of NFS. It would also be highly impractical to require every computer to understand
    the internal representation of every other one. A more general method is needed
    to allow even very dissimilar machines to share data. To this end, the creators
    of NFS defined NFS so that it deals with data using a universal data description
    language. This language is called the *External Data Representation (XDR)* standard
    and was originally described in RFC 1014\. It was updated in RFC 1832, "XDR: External
    Data Representation Standard," in 1995.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将访问限制仅限于使用相同操作系统的机器上的远程文件。然而，这将大大降低NFS的有效性。要求每台计算机都理解其他每台计算机的内部表示方式也非常不切实际。需要一种更通用的方法，以便即使是非常不同的机器也能共享数据。为此，NFS的创造者定义了NFS，使其使用通用数据描述语言来处理数据。这种语言被称为*外部数据表示（XDR）*标准，最初在RFC
    1014中描述。它在1995年的RFC 1832，“XDR：外部数据表示标准”中进行了更新。
- en: 'A Method of Universal Data Exchange: XDR'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种通用数据交换方法：XDR
- en: 'The idea behind XDR is simple, and it can be easily understood in the form
    of an analogy. If you had delegates speaking 50 different languages at a convention,
    they would have a hard time communicating. You could hire translators to facilitate,
    but you would never find translators to handle all the different possible combinations
    of languages. A more practical solution is to declare one language, such as English,
    to be a common language. You then need only 49 translators: one to translate from
    English to each of the non-English languages and back again. To translate from
    Swedish to Portuguese, you translate from Swedish to English and then from English
    to Portuguese. The common language could be French, Spanish, or something else,
    as long as a translator could be found from all the other languages.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: XDR背后的思想很简单，可以通过类比轻松理解。如果你在大会上有50种不同语言的代表，他们很难进行沟通。你可以雇佣翻译人员来协助，但你永远找不到能够处理所有可能的语言组合的翻译人员。一个更实际的解决方案是宣布一种语言，例如英语，作为通用语言。然后你只需要49名翻译人员：一个将英语翻译成每种非英语语言，然后再翻译回来。要从瑞典语翻译成葡萄牙语，你需要先将瑞典语翻译成英语，然后再从英语翻译成葡萄牙语。通用语言可以是法语、西班牙语或其他任何语言，只要能够找到从所有其他语言到这种语言的翻译人员。
- en: XDR works in the same manner. When information about how to access a file is
    to be transferred from Device A to Device B, Device A first converts it from Device
    A's internal representation to the XDR representation of those data types. The
    information is transmitted across the network using XDR encoding. Then Device
    B translates from XDR back to its own internal representation, so it can be presented
    to the user as if it were on the local file system. Each device needs to know
    only how to convert from its own language to XDR and back again; Device A doesn't
    need to know Device B's internal details and vice versa. This sort of translation
    is a classic job of the presentation layer, which is where XDR resides in the
    OSI Reference Model. XDR is itself based on an International Organization for
    Standardization (ISO) standard called "Abstract Syntax Notation."
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: XDR 以相同的方式工作。当需要将如何访问文件的信息从设备 A 传输到设备 B 时，设备 A 首先将它从设备 A 的内部表示转换为这些数据类型的 XDR
    表示。信息通过网络使用 XDR 编码进行传输。然后设备 B 将 XDR 转换回其自身的内部表示，以便将其作为本地文件系统上的内容呈现给用户。每个设备只需要知道如何将其自己的语言转换为
    XDR 并再次转换回来；设备 A 不需要知道设备 B 的内部细节，反之亦然。这种转换是表示层的典型工作，而 XDR 正位于 OSI 参考模型中的表示层。XDR
    本身基于一个称为“抽象语法符号”的国际标准化组织 (ISO) 标准。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The idea behind XDR is also used in other protocols to allow the exchange
    of data independent of the nature of the underlying systems. For example, a similar
    idea is behind the way management information is exchanged using the Simple Network
    Management Protocol (SNMP), which is described in [Chapter 66](ch66.html "Chapter 66. TCP/IP
    STRUCTURE OF MANAGEMENT INFORMATION (SMI) AND MANAGEMENT INFORMATION BASES (MIBS)").
    The same basic idea underlies the important Network Virtual Terminal (NVT) paradigm
    used in the Telnet protocol, which is described in [Chapter 87](ch87.html "Chapter 87. TCP/IP
    INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*XDR 的理念也被用于其他协议中，以允许在底层系统的性质无关的情况下交换数据。例如，类似的想法在简单网络管理协议 (SNMP) 中用于交换管理信息，这在[第
    66 章](ch66.html "第 66 章。TCP/IP 管理信息结构 (SMI) 和管理信息库 (MIBs)")中有描述。同样基本的思想是 Telnet
    协议中使用的重要的网络虚拟终端 (NVT) 范式的基础，这在[第 87 章](ch87.html "第 87 章。TCP/IP 交互式和远程应用程序协议")中有描述*。'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The purpose of the *External Data Representation (XDR)* standard
    is to define a common method for representing common data types. Using this universal
    representation, data can be exchanged between devices, regardless of what internal
    file system each uses. This enables NFS to exchange file data between clients
    and servers that may be implemented using very different hardware and software
    platforms.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 外部数据表示 (XDR) 标准的目的是定义表示常见数据类型的通用方法。使用这种通用表示，数据可以在使用不同内部文件系统的设备之间进行交换。这使得
    NFS 能够在可能使用非常不同的硬件和软件平台的客户端和服务器之间交换文件数据。'
- en: XDR Data Types
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XDR 数据类型
- en: For XDR to be universal, it must allow the description of all the common types
    of data that are used in computers. For example, it must allow integers, floating-point
    numbers, strings, and other data constructs to be exchanged. The XDR standard
    describes the structure of many data types using a notation somewhat similar to
    the C programming language. As you may know, this is one of the most popular languages
    in computing history, and it is closely associated with UNIX (and thus, certain
    TCP/IP technologies as well).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 XDR 具有通用性，它必须允许描述计算机中使用的所有常见数据类型。例如，它必须允许整数、浮点数、字符串和其他数据结构进行交换。XDR 标准使用与
    C 编程语言类似的一种符号来描述许多数据类型的结构。正如您可能知道的，这是计算历史上最受欢迎的语言之一，它与 UNIX 密切相关（因此，也与某些 TCP/IP
    技术相关）。
- en: '[Table 58-1](ch58s04.html#nfs_external_data_representation_xdr_dat "Table 58-1. NFS
    External Data Representation (XDR) Data Types") shows the data types defined by
    XDR, which can be used by NFS in exchanging data between the client and server.
    For each, I have included the data type code, its size in bytes, and a brief description.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 58-1](ch58s04.html#nfs_external_data_representation_xdr_dat "表 58-1. NFS
    外部数据表示 (XDR) 数据类型") 展示了 XDR 定义的可以用于 NFS 在客户端和服务器之间交换数据的类型。对于每一种类型，我都包括了数据类型代码、其大小（以字节为单位）和简要描述。'
- en: Table 58-1. NFS External Data Representation (XDR) Data Types
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表 58-1. NFS 外部数据表示 (XDR) 数据类型
- en: '| Data Type Code | Size (Bytes) | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型代码 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| int | 4 | Signed integer: A 32-bit signed integer in two''s complement notation,
    capable of holding a value from -2,147,483,648 to +2,147,483,647. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| int | 4 | 有符号整数：以二进制补码表示的32位有符号整数，能够存储从-2,147,483,648到+2,147,483,647的值。 |'
- en: '| unsigned int | 4 | Unsigned integer: A 32-bit unsigned integer, from 0 to
    4,294,967,295. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| unsigned int | 4 | 无符号整数：32位无符号整数，范围从0到4,294,967,295。 |'
- en: '| enum | 4 | Enumeration: An alternate way of expressing a signed integer where
    some of the integer values are used to stand for particular constant values. For
    example, you could represent the colors of the rainbow, by defining the value
    1 to stand for PURPLE, 2 to stand for BLUE, and so on. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| enum | 4 | 枚举：表示有符号整数的一种替代方法，其中一些整数值用于表示特定的常量值。例如，您可以通过定义值为1表示紫色，2表示蓝色，等等来表示彩虹的颜色。
    |'
- en: '| bool | 4 | Boolean: A logical representation of an integer, analogous to
    a two-level enumeration where a value of 0 is defined as FALSE and 1 is TRUE.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| bool | 4 | 布尔值：整数的逻辑表示，类似于具有两个级别的枚举，其中0值定义为FALSE，1值定义为TRUE。 |'
- en: '| hyper | 8 | Signed hyper integer: Same as a regular signed integer, but 8
    bytes wide to allow much larger numbers. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| hyper | 8 | 有符号超整数：与常规有符号整数相同，但宽度为8字节，以允许更大的数字。 |'
- en: '| unsigned hyper | 8 | Unsigned hyper integer: Same as a regular unsigned integer
    but 8 bytes wide to allow much larger numbers. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| unsigned hyper | 8 | 无符号超整数：与常规无符号整数相同，但宽度为8字节，以允许更大的数字。 |'
- en: '| float | 4 | Floating-point number: A 32-bit signed floating-point number.
    1 bit holds the sign (positive or negative), 8 bits hold the exponent (power),
    in base 2, and 23 bits hold the mantissa (fractional part of the number). |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| float | 4 | 浮点数：32位有符号浮点数。1位用于符号（正或负），8位用于指数（幂），以2为基数，23位用于尾数（数字的小数部分）。 |'
- en: '| double | 8 | Double-precision floating-point number: The same as float but
    with more bits to allow greater precision. 1 bit is for the sign, 11 bits for
    the exponent, and 52 bits for the mantissa. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| double | 8 | 双精度浮点数：与float相同，但具有更多的位以允许更高的精度。1位用于符号，11位用于指数，52位用于尾数。 |'
- en: '| quadruple | 16 | Quadruple-precision floating-point number: The same as float
    and double but with still more bits to allow greater precision. 1 bit is for the
    sign, 15 bits for the exponent, and 112 bits for the mantissa. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| quadruple | 16 | 四倍精度浮点数：与float和double相同，但具有更多的位以允许更高的精度。1位用于符号，15位用于指数，112位用于尾数。
    |'
- en: '| opaque | Variable | Opaque data: Data that is to be passed between devices
    without being given a specific representation using XDR. The term *opaque* means
    that the data is treated like a "black box" whose insides cannot be seen. Obviously,
    any machines using this data type must themselves know how to deal with it, since
    NFS does not. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| opaque | Variable | 不可见数据：在设备之间传递的数据，不使用XDR给出特定的表示。术语*不可见*意味着数据被处理为一个“黑盒”，其内部无法看到。显然，任何使用此数据类型的机器都必须自己知道如何处理它，因为NFS不知道。
    |'
- en: '| string | Variable | String: A variable-length string of ASCII characters.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 变量 | 字符串：ASCII字符的变长字符串。 |'
- en: '| (array) | Variable | Arrays: A group of any single type of the elements above,
    such as integers, floating-point numbers, and so on, may be specified in an array
    to allow many to be referenced as a single unit. They are not indicated using
    a separate data type code. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| (数组) | Variable | 数组：可以是上述任何单一类型的元素组，如整数、浮点数等，可以指定为数组，以允许将多个元素作为一个单元引用。它们不使用单独的数据类型代码表示。
    |'
- en: '| struct | Variable | Structure: An arbitrary structure containing other data
    elements from this table. This allows the definition of complex data types. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| struct | Variable | 结构体：包含来自此表的其他数据元素的任意结构。这允许定义复杂的数据类型。 |'
- en: '| union | Variable | Discriminated union: A complex data type where a code
    value called a "discriminant" is used to determine the nature of the rest of the
    structure. See section 3.14 of RFC 1014 for details. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| union | Variable | 判别联合：一种复杂的数据类型，其中使用称为“判别符”的代码值来确定其余结构体的性质。有关详细信息，请参阅RFC
    1014的第3.14节。 |'
- en: '| void | 0 | Void: A null data type that contains nothing. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| void | 0 | 空类型：一个不包含任何内容的空数据类型。 |'
- en: '| const | 0 | Constant: A constant value used in other representations. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| const | 0 | 常量：用于其他表示的常量值。 |'
- en: As you can see, XDR provides considerable data description capabilities. If
    you know the C language, much of what is in [Table 58-1](ch58s04.html#nfs_external_data_representation_xdr_dat
    "Table 58-1. NFS External Data Representation (XDR) Data Types") is probably familiar
    to you. Unfortunately, I can't really describe many of the more complex data types
    without turning this into a guide to C programming.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，XDR提供了相当多的数据描述能力。如果你了解C语言，[表58-1](ch58s04.html#nfs_external_data_representation_xdr_dat
    "表58-1. NFS外部数据表示（XDR）数据类型")中的大部分内容可能对你来说很熟悉。不幸的是，没有将这变成C编程指南，我无法真正描述许多更复杂的数据类型。
- en: XDR also provides a means of defining new data types and a method for specifying
    optional data. This offers even more flexibility beyond the large number of specific
    types already specifically described. Each version of NFS has a slightly different
    list of data types it supports.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: XDR还提供了一种定义新数据类型和指定可选数据的方法。这为已经具体描述的大量特定类型提供了更多的灵活性。NFS的每个版本都支持略微不同的数据类型列表。
- en: NFS Client/Server Operation Using Remote Procedure Calls (RPCs)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程过程调用（RPC）的NFS客户端/服务器操作
- en: Almost all applications deal with files and other resources. When a software
    program on a particular computer wants to read a file, write a file, or perform
    related tasks, it needs to use the correct software instructions for this purpose.
    It would be inefficient to require each software program to contain a copy of
    these instructions, so instead, they are encoded as standardized software modules,
    sometimes called *procedures*. To perform an action, a piece of software *calls*
    the procedure. The procedure temporarily takes over for the main program and performs
    a task such as reading or writing data. The procedure then returns control of
    the program back to the software that called it, and optionally, returns data
    as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有应用程序都处理文件和其他资源。当特定计算机上的软件程序想要读取文件、写入文件或执行相关任务时，它需要使用为此目的的正确软件指令。要求每个软件程序都包含这些指令的副本将是不高效的，因此，它们被编码为标准化的软件模块，有时称为*过程*。为了执行一个动作，软件*调用*这个过程。过程暂时接管主程序并执行读取或写入数据等任务。然后，过程将程序的控制权返回给调用它的软件，并且可以选择性地返回数据。
- en: Since the key concept of NFS was to make remote file access look like local
    file access, it was designed around the use of a network-based version of this
    procedure calling method. A software application that wants to do something with
    a file still makes a procedure call, but it makes the call to a procedure on a
    different computer instead of the local one. A special set of routines is used
    to handle the transmission of the call across the network, in a way largely invisible
    to software performing the call.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS的关键概念是使远程文件访问看起来像本地文件访问，因此它是围绕使用基于网络的这种过程调用方法的版本来设计的。一个想要对文件进行操作的软件应用程序仍然会进行过程调用，但它调用的是另一台计算机上的过程，而不是本地计算机。使用一组特殊的例程来处理调用在网络中的传输，对执行调用的软件来说，这种方式在很大程度上是透明的。
- en: This functionality could have been implemented directly in NFS, but instead
    Sun created a separate session-layer protocol component called the *Remote Procedure
    Call (RPC)* specification, which defines how this works. RPC was originally created
    as a subcomponent of NFS, but it is generic enough and useful enough that it has
    been used for other client/server applications in TCP/IP. For this reason, it
    is really considered in many respects a distinct protocol.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能本来可以直接在NFS中实现，但Sun创建了一个名为*远程过程调用（RPC）*的独立会话层协议组件，它定义了如何实现这一点。RPC最初是作为NFS的一个子组件创建的，但它足够通用且有用，以至于它已被用于TCP/IP中的其他客户端/服务器应用程序。因此，在许多方面，它实际上被认为是一个独立的协议。
- en: Because RPC is the actual process of communicating in NFS, NFS itself is different
    from many other TCP/IP protocols. Its operation can't be described in terms of
    specific message exchanges and state diagrams the way a protocol like HTTP or
    the Dynamic Host Configuration Protocol (DHCP), or even TCP can, because RPC does
    all of that. NFS is defined in terms of a set of RPC server procedures and operations
    that an NFS server makes available to NFS clients. These procedures and operations
    each allow a particular type of action to be taken on a file, such as reading
    from it, writing to it, or deleting it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RPC是NFS中实际通信的过程，因此NFS本身与许多其他TCP/IP协议不同。它的操作不能像HTTP或动态主机配置协议（DHCP）或甚至TCP那样用特定的消息交换和状态图来描述，因为RPC做了所有这些。NFS是用一组RPC服务器过程和操作来定义的，这些过程和操作允许NFS服务器向NFS客户端提供，每个过程和操作都允许对文件执行特定类型的操作，例如从它读取、写入或删除它。
- en: RPC Operation and Transport Protocol Usage
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPC操作和传输协议使用
- en: When a client wants to perform some type of action on a file on a particular
    machine, it uses RPC to make a call to the NFS server on that machine. The server
    accepts the request and performs the action required, then returns a result code
    and possibly data back to the client, depending on the request. The result code
    indicates if the action was successful. If it was, the client can assume that
    whatever it asked to be done was completed. For example, in the case of writing
    data, the client can assume the data has been successfully written to long-term
    storage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要在特定机器上的文件上执行某种操作时，它使用RPC来调用该机器上的NFS服务器。服务器接受请求并执行所需操作，然后根据请求返回一个结果代码和可能的数据，返回给客户端。结果代码指示操作是否成功。如果是的话，客户端可以假设它请求执行的操作已经完成。例如，在写入数据的情况下，客户端可以假设数据已经成功写入长期存储。
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** NFS does not use a dedicated message format, like most other
    protocols do. Instead, clients and servers use the *Remote Procedure Call (RPC)*
    protocol to exchange file operation requests and data.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** NFS不使用像大多数其他协议那样的专用消息格式。相反，客户端和服务器使用*远程过程调用（RPC）*协议来交换文件操作请求和数据。'
- en: NFS can operate over any transport mechanism that has a valid RPC implementation
    at the session layer. NFS has seen an evolution of sorts in its use of transport
    protocol. The NFSv2 standard says that it operates normally using UDP, and this
    is still a common way that NFS information is carried. NFSv3 says that either
    UDP or TCP may be used, but NFSv4 specifies TCP to carry data. The nominal registered
    port number for use by NFS is 2049, but other port numbers are sometimes used
    for NFS, through the use of RPC's *port mapper* capability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NFS可以在任何具有有效RPC实现的会话层传输机制上运行。NFS在其传输协议的使用上经历了一定程度的演变。NFSv2标准指出它通常使用UDP进行操作，这仍然是NFS信息传输的一种常见方式。NFSv3表示可以使用UDP或TCP，但NFSv4指定使用TCP来传输数据。NFS使用的标准注册端口号为2049，但有时会通过使用RPC的*端口映射器*功能来使用其他端口号。
- en: Client and Server Responsibilities in NFS
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS中的客户端和服务器责任
- en: Since UDP is unreliable, the use of that protocol to transport important information
    may seem strange. For example, we obviously don't want data that we are trying
    to write to a file to be lost in transit. Remember, however, that UDP doesn't
    preclude the use of measures to ensure reliable communications; it simply doesn't
    provide those capabilities itself. UDP can be used by NFS because the protocol
    itself is designed to tolerate loss of transmitted data and to recover from it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP不可靠，使用该协议传输重要信息可能看起来很奇怪。例如，我们显然不希望试图写入文件的数据在传输过程中丢失。然而，请记住，UDP并不排除使用确保可靠通信的措施；它只是不提供这些功能。UDP可以被NFS使用，因为该协议本身设计为能够容忍传输数据的丢失并从中恢复。
- en: Consistent with this concept, the general design of NFS puts most of the responsibility
    for implementing the protocol on the client, not the server. As the NFSv3 standard
    says, "NFS servers are dumb, and NFS clients are smart." What this means is that
    the servers focus only on responding to requests, while clients must take care
    of most of the nitty-gritty details of the protocol, including recovery from failed
    communications. This is a common requirement when UDP is used, because if a client
    request is lost in transit, the server has no way of knowing that it was ever
    sent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与此概念一致，NFS的一般设计将实现协议的大部分责任放在客户端，而不是服务器上。正如NFSv3标准所说，“NFS服务器是简单的，NFS客户端是智能的。”这意味着服务器只专注于响应请求，而客户端必须处理协议的大部分繁琐细节，包括从失败的通信中恢复。当使用UDP时，这是一个常见的要求，因为如果客户端请求在传输过程中丢失，服务器就无法知道它曾经被发送过。
- en: As mentioned in the NFS overview earlier in this chapter, NFS servers are designed
    to be stateless. In simplified terms, this means that the NFS server does not
    keep track of the state of the clients using it from one request to another. Each
    request is independent of the previous one, and the server in essence has no memory
    of what it did before when it gets a new command from a client. This again requires
    more intelligence to be put into the clients, but has the important advantage
    of simplifying recovery in the case that the server crashes. Since there is nothing
    that the server was keeping track of for the client, there's nothing that can
    be lost. This is an important part of ensuring that files are not damaged as a
    result of network problems or congestion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面提到的NFS概述中所述，NFS服务器被设计成无状态的。简单来说，这意味着NFS服务器不会跟踪客户端从一个请求到另一个请求的状态。每个请求都是独立的，服务器本质上没有记忆它在收到客户端的新命令之前做了什么。这又要求客户端投入更多的智能，但具有简化服务器崩溃时恢复的重要优势。由于服务器没有为客户端跟踪任何东西，所以没有东西可以丢失。这是确保文件不会因为网络问题或拥塞而损坏的重要部分。
- en: Client and Server Caching
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端和服务器缓存
- en: Both NFS clients and servers can make use of caching to improve performance.
    Servers may use caching to store recently requested information in case it is
    needed again. They may also use *predictive* caching, sometimes called *prefetching*.
    In this technique, a server that receives a request to read a block of data from
    a file may load into memory the next block after it, on the theory that it will
    likely be requested next.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是NFS客户端还是服务器，都可以利用缓存来提高性能。服务器可能使用缓存来存储最近请求的信息，以防再次需要。它们也可能使用*预测性*缓存，有时也称为*预取*。在这种技术中，当服务器收到读取文件数据块的请求时，它可能会将下一个数据块加载到内存中，基于它可能会被下一个请求调用的理论。
- en: Client-side caching is used to satisfy repeat NFS requests from applications
    while avoiding additional RPC calls. Like almost everything else about NFS, caching
    is implemented much more thoroughly in NFSv4 than in the previous versions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端缓存用于满足应用程序对NFS的重复请求，同时避免额外的RPC调用。与NFS的其他许多方面一样，缓存在NFSv4中的实现比之前的版本更为彻底。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** NFS is designed to be a stateless protocol, with intelligent
    clients and relatively dumb servers that respond to requests and do not maintain
    status information about what files are in use. NFS was originally designed to
    use UDP for transport, for efficiency purposes. This requires that NFS clients
    take care of detecting lost requests and retransmitting them. NFSv4 uses TCP to
    take advantage of TCP''s reliability and other features.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** NFS被设计成一个无状态的协议，具有智能的客户端和相对简单的服务器，服务器响应请求而不维护关于正在使用的文件的状态信息。NFS最初被设计为使用UDP进行传输，以提高效率。这要求NFS客户端负责检测丢失的请求并重新传输它们。NFSv4使用TCP来利用TCP的可靠性和其他特性。'
- en: NFS Server Procedures and Operations
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS服务器程序和操作
- en: The actual exchange of information between an NFS client and server is performed
    by the underlying RPC protocol. NFS functionality is therefore described not in
    terms of specific protocol operations, but by delineating the different actions
    that a client may take on files residing on a server. In the original version
    of NFS, NFSv2, these are called NFS *server procedures*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，NFS客户端和服务器之间的信息交换是通过底层的RPC协议完成的。因此，NFS功能不是通过具体的协议操作来描述的，而是通过界定客户端可能对服务器上的文件执行的不同操作来描述的。在NFS的原始版本NFSv2中，这些被称为NFS
    *服务器程序*。
- en: Each procedure represents a particular action that a client may perform, such
    as reading from a file, writing to a file, or creating or removing a directory.
    The operations performed on the file require that the file be referenced using
    a data structure called a *file handle*. As the name suggests, the file handle,
    like the handle of a real object, lets the client and server "grasp" the file.
    The Mount protocol, described later in this chapter, is used to mount a file system,
    to enable a file handle to be accessed for use by NFS procedures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序代表客户端可能执行的一个特定操作，例如从文件中读取、写入文件或创建或删除目录。对文件执行的操作需要使用称为文件句柄的数据结构来引用文件。正如其名所示，文件句柄，就像真实对象的句柄一样，允许客户端和服务器“抓住”文件。本章后面将描述的挂载协议用于挂载文件系统，以便文件句柄可以被访问并用于NFS程序。
- en: NFSv3 uses the same basic model for server procedures, but makes certain changes.
    Two of the NFSv2 procedures were removed, and several new ones added to support
    new functionality. The numbers assigned to identify each procedure were also changed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: NFSv3使用与服务器程序相同的基本模型，但进行了一些更改。删除了两个NFSv2程序，并添加了几个新程序以支持新功能。分配给识别每个程序的数字也发生了变化。
- en: NFS Version 2 and Version 3 Server Procedures
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS版本2和版本3服务器程序
- en: '[Table 58-2](ch58s06.html#nfs_version__and_version__server_procedu "Table 58-2. NFS
    Version 2 and Version 3 Server Procedures") shows the server procedures defined
    in versions 2 and 3 of NFS. The table shows the procedure numbers for both NFSv2
    and NFSv3, as well as the name of each procedure and a description of what it
    does. I have kept the descriptions short so the table can serve as a useful summary
    of what NFS can do. They are listed in order of the procedure number used in NFSv2.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[表58-2](ch58s06.html#nfs_version__and_version__server_procedu "表58-2. NFS版本2和版本3服务器程序")显示了NFS版本2和版本3中定义的服务器程序。该表显示了NFSv2和NFSv3的进程编号，以及每个程序的名称和它所执行的操作的描述。我已将描述保持简短，以便表格可以作为NFS能做什么的有用摘要。它们按照NFSv2中使用的进程编号顺序列出。'
- en: Table 58-2. NFS Version 2 and Version 3 Server Procedures
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表58-2. NFS版本2和版本3服务器程序
- en: '| Procedure No. (v2) | Procedure No. (v3) | Procedure Name | Procedure Summary
    | Description |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 程序编号（v2） | 程序编号（v3） | 程序名称 | 程序摘要 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | null | Do nothing | Dummy procedure provided for testing purposes.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | null | 无操作 | 为测试目的提供的虚拟程序。|'
- en: '| 1 | 1 | getattr | Get file attributes | Retrieves the attributes of a file
    on a remote server. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | getattr | 获取文件属性 | 从远程服务器检索文件的属性。|'
- en: '| 2 | 2 | setattr | Set file attributes | Sets (changes) the attributes of
    a file on a remote server. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2 | setattr | 设置文件属性 | 设置（更改）远程服务器上文件的属性。|'
- en: '| 3 | — | root | Get file system root (obsolete) | This procedure was originally
    defined to allow a client to find the root of a remote file system, but is now
    obsolete. This function is instead now implemented as part of the Mount protocol.
    It was removed in NFSv3. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 3 | — | root | 获取文件系统根（已废弃） | 该程序最初被定义为允许客户端找到远程文件系统的根，但现在已废弃。此功能现在作为挂载协议的一部分实现。它在NFSv3中被删除。'
- en: '| 4 | 3 | lookup | Look up filename | Returns the file handle of a file for
    the client to use. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 3 | lookup | 查找文件名 | 返回文件句柄供客户端使用。|'
- en: '| 5 | 5 | readlink | Read from symbolic link | Reads the name of a file specified
    using a symbolic link. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 5 | readlink | 从符号链接读取 | 读取使用符号链接指定的文件名。|'
- en: '| 6 | 6 | read | Read from rile | Reads data from a file. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 6 | read | 从文件读取 | 从文件中读取数据。|'
- en: '| 7 | — | writecache | Write to cache | Proposed for future use in NFSv2 but
    abandoned and removed from NFSv3. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 7 | — | writecache | 写入缓存 | 建议用于NFSv2的未来使用，但已被放弃并在NFSv3中删除。|'
- en: '| 8 | 7 | write | Write to file | Writes data to a file. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 7 | write | 写入文件 | 将数据写入文件。|'
- en: '| 9 | 8 | create | Create file | Creates a file on the server. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 8 | create | 创建文件 | 在服务器上创建文件。|'
- en: '| 10 | 12 | remove | Remove file | Deletes a file from the server. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 12 | remove | 删除文件 | 从服务器删除文件。|'
- en: '| 11 | 14 | rename | Rename file | Changes the name of a file. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 14 | rename | 重命名文件 | 更改文件的名称。|'
- en: '| 12 | 15 | link | Create link to file | Creates a hard (nonsymbolic) link
    to a file. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 15 | link | 创建文件链接 | 创建指向文件的硬（非符号）链接。|'
- en: '| 13 | 10 | symlink | Create symbolic link | Creates a symbolic link to a file.
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 10 | symlink | 创建符号链接 | 创建指向文件的符号链接。|'
- en: '| 14 | 9 | mkdir | Create directory | Creates a directory on the server. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 9 | mkdir | 创建目录 | 在服务器上创建目录。|'
- en: '| 15 | 13 | rmdir | Remove directory | Deletes a directory. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 13 | rmdir | 删除目录 | 删除目录。|'
- en: '| 16 | 16 | readdir | Read from directory | Reads the contents of a directory.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 16 | readdir | 从目录读取 | 读取目录内容。|'
- en: '| 17 | — | statfs | Get file system attributes | Provides to the client general
    information about the remote file system, including the size of the file system
    and the amount of free space remaining. In NFSv3, this was replaced by fsstat
    and fsinfo. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 17 | — | statfs | 获取文件系统属性 | 向客户端提供有关远程文件系统的一般信息，包括文件系统的大小和剩余的可用空间。在NFSv3中，这被fsstat和fsinfo所取代。|'
- en: '| — | 4 | access | Check access permission | Determines the access rights that
    a user has for a particular file system object. This is new in NFSv3. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| — | 4 | access | 检查访问权限 | 确定用户对特定文件系统对象具有的访问权限。这是NFSv3中的新功能。|'
- en: '| — | 11 | mknod | Create a special device | Creates a special file such as
    a named pipe or device file. This is new in NFSv3. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| — | 11 | mknod | 创建特殊设备 | 创建特殊文件，如命名管道或设备文件。这是NFSv3中的新功能。|'
- en: '| — | 17 | readdirplus | Extended read from directory | Retrieves additional
    information from a directory. This is new in NFSv3. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| — | 17 | readdirplus | 扩展目录读取 | 从目录中检索附加信息。这是NFSv3中的新功能。|'
- en: '| — | 18 | fsstat | Get dynamic file system information | Returns volatile
    (dynamic) file system status information such as the current amount of file system
    free space and the number of free file slots. This is new in NFSv3. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| — | 18 | fsstat | 获取动态文件系统信息 | 返回易变（动态）文件系统状态信息，例如当前文件系统的可用空间和空闲文件槽的数量。这是NFSv3中的新功能。|'
- en: '| — | 19 | fsinfo | Get static file system information | Returns static information
    about the file system, such as general data about how the file system is used
    and parameters for how requests to the server should be structured. This is new
    in NFSv3. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| — | 19 | fsinfo | 获取静态文件系统信息 | 返回有关文件系统的静态信息，例如文件系统使用的一般数据和请求服务器应如何结构化的参数。这是NFSv3中的新功能。|'
- en: '| — | 20 | pathconf | Retrieve POSIX information | Retrieves additional information
    for a file or directory. This is new in NFSv3. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| — | 20 | pathconf | 获取POSIX信息 | 为文件或目录检索附加信息。这是NFSv3中的新功能。|'
- en: '| — | 21 | commit | Commit cached data on a server to stable storage | Flushes
    any data that the server is holding in a write cache to storage. This is used
    to ensure that any data that the client has sent to the server but that the server
    has held pending write to storage is written out. This is new in NFSv3. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| — | 21 | commit | 在服务器上提交缓存数据到稳定存储 | 将服务器持有的任何写入缓存中的数据刷新到存储中。这用于确保客户端已发送给服务器但服务器尚未写入存储的数据被写入。这是NFSv3中的新功能。|'
- en: It is common that a client may want to perform multiple actions on a file, such
    as several consecutive reads. One of the problems with the server procedure system
    in NFSv2 and NFSv3 is that each client action required a separate procedure call.
    This was somewhat inefficient, especially when NFS was used over a high-latency
    link.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端可能希望对文件执行多个操作是很常见的，例如连续的多次读取。NFSv2和NFSv3中服务器过程系统的一个问题是，每个客户端操作都需要一个单独的过程调用。这在NFS通过高延迟链路使用时效率较低。
- en: NFS Version 4 Server Procedures and Operations
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS版本4服务器过程和操作
- en: To improve the efficiency of server procedures, NFSv4 makes a significant change
    to the way that server procedures are implemented. Instead of each client action
    being a separate procedure, a single procedure, called a *compound procedure*,
    is defined. Within this compound procedure, a large number of *server operations*
    are encapsulated. These are all sent as a single unit, and the server interprets
    and follows the instructions in each operation in sequence.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高服务器过程的效率，NFSv4对服务器过程的实现方式进行了重大改变。不是每个客户端操作都是一个单独的过程，而是定义了一个单一的过程，称为*复合过程*。在这个复合过程中，封装了大量的*服务器操作*。这些操作作为一个单元发送，服务器按顺序解释和执行每个操作中的指令。
- en: This change means there are actually only two RPC procedures in NFSv4, as shown
    in [Table 58-3](ch58s06.html#nfs_version__server_procedures "Table 58-3. NFS Version
    4 Server Procedures").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变意味着在NFSv4中实际上只有两个RPC过程，如[表58-3](ch58s06.html#nfs_version__server_procedures
    "表58-3. NFS版本4服务器过程")所示。
- en: Table 58-3. NFS Version 4 Server Procedures
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表58-3. NFS版本4服务器过程
- en: '| Procedure Number | Procedure Name | Procedure Summary | Description |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 过程编号 | 过程名称 | 过程摘要 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | null | Do nothing | Dummy procedure provided for testing purposes. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 0 | null | 不执行任何操作 | 为测试目的提供的虚拟过程。|'
- en: '| 1 | compound | Compound operations | Combines a number of NFS operations
    into a single request. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 1 | compound | 复合操作 | 将多个 NFS 操作组合成一个单一请求。|'
- en: All the real client actions are defined as operations within the compound procedure,
    as shown in [Table 58-4](ch58s06.html#nfs_version__server_operations "Table 58-4. NFS
    Version 4 Server Operations"). You'll notice that the number of NFSv4 operations
    is much larger than the number of procedures in NFSv2 and NFSv3\. This is due
    both to the added features in NSFv4 and the fact that it incorporates functions
    formerly performed by the separate Mount protocol.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有真实客户端操作都定义为复合过程内的操作，如[表 58-4](ch58s06.html#nfs_version__server_operations
    "表 58-4. NFS 版本 4 服务器操作")所示。你会注意到，NFSv4 操作的数量比 NFSv2 和 NFSv3 中的程序数量多得多。这既是因为 NSFv4
    中增加了功能，也是因为它结合了以前由单独的挂载协议执行的功能。
- en: Table 58-4. NFS Version 4 Server Operations
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表 58-4. NFS 版本 4 服务器操作
- en: '| Operation Number | Operation Name | Operation Summary | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 操作编号 | 操作名称 | 操作摘要 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 3 | access | Check access rights | Determines the access rights a user has
    for an object. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 3 | access | 检查访问权限 | 确定用户对对象的访问权限。|'
- en: '| 4 | close | Close file | Closes a file. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 4 | close | 关闭文件 | 关闭文件。|'
- en: '| 5 | commit | Commit cached data | Flushes any data that the server is holding
    in a write cache to storage, to ensure that any pending data is permanently recorded.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 5 | commit | 提交缓存数据 | 将服务器在写缓存中持有的任何数据刷新到存储中，以确保任何挂起的数据被永久记录。|'
- en: '| 6 | create | Create a nonregular file object | This is similar to the mknod
    procedure in NFSv3; it creates a "nonregular" (special) object file. (Regular
    files are created using the open operation.) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 6 | create | 创建非常规文件对象 | 这类似于 NFSv3 中的 mknod 程序；它创建一个“非常规”（特殊）对象文件。（常规文件使用打开操作创建。）|'
- en: '| 7 | delepurge | Purge delegations awaiting recovery | NFSv4 has a feature
    where a server may delegate to a client responsibility for certain files. This
    operation removes delegations awaiting recovery from a client. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 7 | delepurge | 清除待恢复的委托 | NFSv4 具有一个功能，即服务器可以委托客户端负责某些文件。此操作从客户端移除等待恢复的委托。|'
- en: '| 8 | delegreturn | Return delegation | Returns a delegation from a client
    to the server that granted it. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 8 | delegreturn | 返回委托 | 返回客户端授予的服务器委托。|'
- en: '| 9 | getattr | Get attributes | Obtains the attributes for a file. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 9 | getattr | 获取属性 | 获取文件的属性。|'
- en: '| 10 | getfh | Get current file handle | Returns a file handle, which is a
    logical object used to allow access to a file. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 10 | getfh | 获取当前文件句柄 | 返回一个文件句柄，这是一个逻辑对象，用于允许访问文件。|'
- en: '| 11 | link | Create link to a file | Creates a hard (nonsymbolic) link to
    a file. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 11 | link | 创建文件链接 | 创建指向文件的硬链接（非符号链接）。|'
- en: '| 12 | lock | Create lock | Creates a lock on a file. Locks are used to manage
    access to a file—for example, to prevent two clients from trying to write to a
    file simultaneously and thus corrupting it. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 12 | lock | 创建锁 | 在文件上创建锁。锁用于管理对文件的访问——例如，防止两个客户端同时尝试写入文件，从而损坏它。|'
- en: '| 13 | lockt | Test for lock | Tests for the existence of a lock on an object
    and returns information about it. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 13 | lockt | 测试锁 | 测试对象上锁的存在，并返回有关它的信息。|'
- en: '| 14 | locku | Unlock lile | Removes a lock previously created on a file. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 14 | locku | 解锁文件 | 移除之前在文件上创建的锁。|'
- en: '| 15 | lookup | Look up filename | Looks up or finds a file. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 15 | lookup | 查找文件名 | 查找或找到文件。|'
- en: '| 16 | lookupp | Look up parent directory | Returns the file handle of an object''s
    parent directory. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 16 | lookupp | 查找父目录 | 返回对象的父目录的文件句柄。|'
- en: '| 17 | nverify | Verify difference in attributes | Checks to see if attributes
    have changed on a file. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 17 | nverify | 验证属性差异 | 检查文件上的属性是否已更改。|'
- en: '| 18 | open | Open a regular file | Opens a file. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 18 | open | 打开常规文件 | 打开文件。|'
- en: '| 19 | openattr | Open named attribute directory | Opens an attribute directory
    associated with a file. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 19 | openattr | 打开命名属性目录 | 打开与文件关联的属性目录。|'
- en: '| 20 | open_confirm | Confirm open | Confirms information related to an opened
    file. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 20 | open_confirm | 确认打开 | 确认与打开文件相关的信息。|'
- en: '| 21 | open_ downgrade | Reduce open file access | Adjusts the access rights
    for a file that is already open. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 21 | open_ downgrade | 降低打开文件访问权限 | 调整已打开文件的访问权限。|'
- en: '| 22 | putfh | Set current file handle | Replaces one file handle with another.
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 22 | putfh | 设置当前文件句柄 | 用另一个文件句柄替换一个文件句柄。|'
- en: '| 23 | putpubfh | Set public file handle | Sets the current file handle to
    be the public file handle of the server. This may or may not be the same as the
    root file handle. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 23 | putpubfh | 设置公共文件句柄 | 将当前文件句柄设置为服务器的公共文件句柄。这可能或可能不与根文件句柄相同。|'
- en: '| 24 | putrootfh | Set root file handle | Sets the current file handle to be
    the root of the server''s file system. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 24 | putrootfh | 设置根文件句柄 | 将当前文件句柄设置为服务器文件系统的根。|'
- en: '| 25 | read | Read from file | Reads data from a file. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 25 | read | 从文件读取 | 从文件中读取数据。|'
- en: '| 26 | readdir | Read directory | Reads the contents of a directory. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 26 | readdir | 读取目录 | 读取目录的内容。|'
- en: '| 27 | readlink | Read symbolic link | Reads the name of a file specified using
    a symbolic link. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 27 | readlink | 读取符号链接 | 读取使用符号链接指定的文件名。|'
- en: '| 28 | remove | Remove file system object | Removes (deletes) an object. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 28 | remove | 移除文件系统对象 | 移除（删除）一个对象。|'
- en: '| 29 | rename | Rename directory entry | Changes the name of an object. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 29 | rename | 重命名目录条目 | 更改对象名称。|'
- en: '| 30 | renew | Renew a lease | Renews an NFS delegation made by a server. (Note
    that these leases have nothing to do with DHCP leases, which are discussed in
    [Chapter 61](ch61.html "Chapter 61. DHCP OVERVIEW AND ADDRESS ALLOCATION CONCEPTS").)
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 30 | renew | 续订租约 | 续订服务器做出的NFS委托。（注意，这些租约与DHCP租约无关，DHCP租约在[第61章](ch61.html
    "第61章。DHCP概述和地址分配概念")中讨论。）|'
- en: '| 31 | restorefh | Restore saved file handle | Allows a file handle previously
    saved to be made the current file handle. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 31 | restorefh | 恢复保存的文件句柄 | 允许将先前保存的文件句柄恢复为当前文件句柄。|'
- en: '| 32 | savefh | Save current file handle | Allows a file handle to be saved
    so it can later be restored when needed. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 32 | savefh | 保存当前文件句柄 | 允许保存文件句柄，以便在需要时可以稍后恢复。|'
- en: '| 33 | secinfo | Obtain available security | Retrieves NFS security information.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 33 | secinfo | 获取可用安全信息 | 获取NFS安全信息。|'
- en: '| 34 | setattr | Set attributes | Changes one or more attributes of a file.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 34 | setattr | 设置属性 | 更改一个或多个文件的属性。|'
- en: '| 35 | setclientid | Negotiate client ID | Allows a client to communicate information
    to the server regarding how the client wants to use NFS. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 35 | setclientid | 协商客户端ID | 允许客户端向服务器传达有关客户端如何使用NFS的信息。|'
- en: '| 36 | setclientid_confirm | Confirm client ID | Used to confirm the results
    of a previous negotiation using setclientid. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 36 | setclientid_confirm | 确认客户端ID | 用于通过setclientid确认先前协商的结果。|'
- en: '| 37 | verify | Verify same attributes | Allows a client to verify certain
    attributes before proceeding with a particular action. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 37 | verify | 验证相同属性 | 允许客户端在执行特定操作之前验证某些属性。|'
- en: '| 38 | write | Write to file | Writes data to a file. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 38 | write | 写入文件 | 将数据写入文件。|'
- en: '| 39 | release_lockowner | Release lock owner state | Used by a client to tell
    a server to release certain information related to file locks. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 39 | release_lockowner | 释放锁所有者状态 | 由客户端用于告诉服务器释放与文件锁相关的某些信息。|'
- en: '| 10044 | illegal | Illegal operation | A placeholder (dummy) operation used
    to support error reporting when an invalid operation is used in a request from
    a client. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 10044 | illegal | 非法操作 | 当客户端请求中使用无效操作时，用于支持错误报告的占位符（虚拟）操作。|'
- en: Tip
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** File operations in NFS are carried out using NFS *server procedures*.
    In versions 2 and 3 of NFS, each procedure performs one action, such as reading
    data from a file. In NFSv4, a special *compound* action is defined that allows
    many individual *operations* to be sent in a single request to a server.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在NFS中，文件操作是通过NFS *服务器过程*来执行的。在NFS的2和3版本中，每个过程执行一个动作，例如从文件中读取数据。在NFSv4中，定义了一个特殊的
    *复合* 动作，允许将多个单个 *操作* 在一个请求中发送到服务器。'
- en: NFS File System Model and the Mount Protocol
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS 文件系统模型和挂载协议
- en: Since NFS is used by a client to simulate access to remote directories of files
    as if they were local, the protocol must present the files from the remote system
    to the local user. Just as files on a local storage device are arranged using
    a particular file system, NFS uses a *file system model* to represent how files
    are shown to a user.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS允许客户端模拟对远程文件系统的访问，就像它们是本地的一样，因此协议必须将远程系统的文件呈现给本地用户。就像本地存储设备上的文件使用特定的文件系统进行组织一样，NFS使用
    *文件系统模型* 来表示文件如何呈现给用户。
- en: The NFS File System Model
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS 文件系统模型
- en: 'The file system model used by NFS is the same one that most of us are familiar
    with: a hierarchical arrangement of directories that contain files and subdirectories.
    The top of the hierarchy is the *root*, which contains any number of files and
    first-level directories. Each directory may contain more files or other directories,
    allowing an arbitrary tree structure to be created.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: NFS使用的文件系统模型是我们大多数人所熟悉的：包含文件和子目录的目录的分层排列。分层结构的顶部是*根目录*，它包含任意数量的文件和一级目录。每个目录可以包含更多的文件或其他目录，允许创建任意树形结构。
- en: 'A file can be uniquely specified by using its *filename* and a *path name*
    that shows the sequence of directories one must traverse from the root to find
    the file. Since NFS is associated with UNIX, files in NFS discussions are usually
    shown in UNIX notation; for example, */etc/hosts*. The same basic tree idea can
    also be expressed using the method followed by Windows operating systems: *C:\WINDOWS\HOSTS*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件可以通过其*文件名*和显示从根目录到该文件所需遍历的目录序列的*路径名*来唯一指定。由于NFS与UNIX相关联，NFS讨论中的文件通常以UNIX格式表示；例如，*/etc/hosts*。同样的基本树形概念也可以使用Windows操作系统遵循的方法来表示：*C:\WINDOWS\HOSTS*。
- en: The Mount Protocol
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载协议
- en: Before NFS can be used to allow a client to access a file on a remote server,
    the client must be given a way of accessing the file. This means that a portion
    of the remote file system must be made available to the client, and the file opened
    for access. A specific decision was made when NFS was created to not put file
    access, opening, and closing functions into NFS proper. Instead, a separate protocol
    was created to work with NFS, so that if the method of providing file access needed
    to be changed later, it wouldn't require changes to NFS itself. This separate
    mechanism is called the *Mount protocol* and is described in Appendix A of RFC
    1094 (NFSv2). Note that while its functionally distinct, Mount is considered part
    of the overall NFS package.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在NFS可以使用来允许客户端访问远程服务器上的文件之前，客户端必须有一种访问文件的方式。这意味着必须将远程文件系统的一部分提供给客户端，并打开文件以供访问。在创建NFS时，做出了一个特定的决定，即不在NFS本身中放置文件访问、打开和关闭功能。相反，创建了一个单独的协议与NFS一起工作，这样如果以后需要更改提供文件访问的方法，就不需要修改NFS本身。这个单独的机制被称为*挂载协议*，并在RFC
    1094（NFSv2）附录A中描述。请注意，尽管它在功能上独立，但挂载被视为NFS整体包的一部分。
- en: When NFS was revised to version 3, the Mount protocol was similarly modified.
    The NFSv3 version of the Mount protocol is defined in Appendix I of RFC 1813 (NFSv3).
    It contains some changes to how the protocol works, but the overall operation
    of the two versions of Mount is pretty much the same.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当NFS修订到版本3时，挂载协议也相应地进行了修改。NFSv3版本的挂载协议在RFC 1813（NFSv3）附录I中定义。它包含了一些对协议工作方式的变化，但NFS挂载的两个版本的整体操作基本上是相同的。
- en: The term *mount* is actually an analog to a hardware term that refers to making
    a physical storage volume available. In the past, storage devices were usually
    removable disk packs, and to use one, you mounted it onto a drive unit. In a similar
    manner, NFS resources are logically mounted using the Mount protocol, which makes
    the shared file system available to the client. A file can then be opened and
    a file handle returned to the NFS client, so it can reference the file for operations
    such as reading and writing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: “挂载”这个术语实际上是一个与硬件术语相对应的术语，指的是使物理存储卷可用。在过去，存储设备通常是可移动的磁盘包，要使用它，你需要将其挂载到驱动器单元上。以类似的方式，NFS资源通过挂载协议在逻辑上挂载，从而使共享文件系统对客户端可用。然后可以打开一个文件，并将文件句柄返回给NFS客户端，以便它可以引用该文件进行读取和写入等操作。
- en: Tip
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Versions 2 and 3 of NFS do not include procedures for opening
    or closing resources on a remote server. Before NFS tasks can be accomplished
    on these versions, the special *Mount* protocol must be employed to mount a file
    system and create a file handle to access a file on it. The protocol is also used
    to unmount the file system when no longer required. The Mount protocol is implemented
    in a manner similar to NFS itself, defining a sequence of procedures that use
    RPC and XDR. In NFSv4, the Mount protocol is no longer needed, because the tasks
    it performs have been implemented as NFSv4 operations.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** NFS的版本2和3不包括在远程服务器上打开或关闭资源的流程。在这些版本上完成NFS任务之前，必须使用特殊的*挂载*协议来挂载文件系统并创建一个文件句柄以访问该文件系统上的文件。当不再需要时，该协议也用于卸载文件系统。挂载协议的实现方式与NFS本身类似，定义了一系列使用RPC和XDR的流程。在NFSv4中，挂载协议不再需要，因为它执行的任务已经被实现为NFSv4操作。'
- en: The actual implementation of the Mount protocol is very similar to that of NFS
    itself. Like NFS, the Mount protocol uses XDR to define data types to be exchanged
    between the client and server and RPC to define a set of server procedures that
    clients may use to perform different operations. The main difference between Mount
    and NFS is simply that Mount defines procedures related to opening and closing
    file systems, rather than file access operations. [Table 58-5](ch58s07.html#nfs_mount_protocol_server_procedures
    "Table 58-5. NFS Mount Protocol Server Procedures") shows the server procedures
    used in the Mount protocol.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载协议的实际实现与NFS本身非常相似。像NFS一样，挂载协议使用XDR来定义客户端和服务器之间交换的数据类型，并使用RPC来定义一组客户端可以用来执行不同操作的服务器流程。挂载与NFS之间的主要区别仅仅是挂载定义了与打开和关闭文件系统相关的流程，而不是文件访问操作。[表58-5](ch58s07.html#nfs_mount_protocol_server_procedures
    "表58-5. NFS挂载协议服务器流程")显示了挂载协议中使用的服务器流程。
- en: Table 58-5. NFS Mount Protocol Server Procedures
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表58-5. NFS挂载协议服务器流程
- en: '| Procedure Number | Procedure Name | Procedure Summary | Description |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 流程编号 | 流程名称 | 流程摘要 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | null | Do nothing | Dummy procedure provided for testing purposes. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 0 | null | 不做任何事情 | 提供的用于测试的虚拟流程。 |'
- en: '| 1 | mnt | Add mount entry | Performs a mount operation by mapping a path
    on a server to a file handle for the client to use. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 1 | mnt | 添加挂载条目 | 通过将服务器上的路径映射到客户端使用的文件句柄来执行挂载操作。 |'
- en: '| 2 | dump | Return mount entries | Returns a list of remotely mounted file
    systems. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 2 | dump | 返回挂载条目 | 返回远程挂载的文件系统列表。 |'
- en: '| 3 | umnt | Remove mount entry | Performs an unmount operation by removing
    a mount entry. (Yes, it should be *dismount*; techies usually aren''t English
    majors.) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 3 | umnt | 删除挂载条目 | 通过删除挂载条目来执行卸载操作。（是的，应该是*dismount*；技术人员通常不是英语专业。） |'
- en: '| 4 | umntall | Remove all mount entries | Removes all mount entries, thus
    eliminating all mounted file systems between server and client. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 4 | umntall | 删除所有挂载条目 | 删除所有挂载条目，从而消除服务器和客户端之间的所有挂载文件系统。 |'
- en: '| 5 | export | Return export list | Returns a list of exported file systems
    and indicates which clients are allowed to mount them. This is used to let the
    client see which served file systems are available for use. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 5 | export | 返回导出列表 | 返回导出的文件系统列表，并指示哪些客户端被允许挂载它们。这用于让客户端看到哪些被服务的文件系统可供使用。
    |'
- en: Again, NFSv4 does away with the notion of a separate Mount protocol, incorporating
    file mounting operations into NFS directly.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，NFSv4摒弃了单独的挂载协议的概念，直接将文件挂载操作纳入NFS。
