- en: Chapter 15. Marshal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章：Marshal
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: An alternative way of saving and loading data is provided by Ruby’s Marshal
    library. This has a similar set of methods to YAML to enable you to save and load
    data to and from disk.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 Marshal 库提供了一种保存和加载数据的替代方法。它有一组类似 YAML 的方法，使你能够将数据保存到磁盘并从磁盘加载数据。
- en: Saving and Loading Data
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载数据
- en: 'Compare the following program with *yaml_dump2.rb* from the previous chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下程序与上一章的 *yaml_dump2.rb* 进行比较：
- en: '*marshal1.rb*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*marshal1.rb*'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The two programs are pretty much identical except that each occurrence of `YAML`
    (as in `YAML.dump` and `YAML.load`) has been replaced with `Marshal`. Moreover,
    Marshal is “built in” to Ruby as standard, so you don’t have to `require` any
    extra files in order to use it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个程序几乎完全相同，只是将每个 `YAML`（如 `YAML.dump` 和 `YAML.load`）的出现都替换成了 `Marshal`。此外，Marshal
    是 Ruby 的标准库之一，所以你不需要 `require` 任何额外的文件来使用它。
- en: If you look at the data files produced (such as *friends.sav*), you will immediately
    see that there is a major difference, however. Whereas YAML files are in plaintext
    format, Marshal files are in binary format. So although you may be able to read
    *some* characters, such as those in the strings, you won’t simply be able to load
    the saved data and modify it in a text editor.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看生成的数据文件（例如 *friends.sav*），你会立即看到有一个主要区别。然而，YAML 文件是纯文本格式，而 Marshal 文件是二进制格式。所以尽管你可能能够读取
    *一些* 字符，例如字符串中的字符，但你无法简单地加载保存的数据并在文本编辑器中修改它。
- en: 'As with YAML, most data structures can be automatically serialized using Marshal
    just by dumping the top-level object and loading it when you want to reconstruct
    all the objects beneath it. For an example, take a look at my little adventure
    game program. In the previous chapter, I explained how to save and restore a Map
    containing Rooms containing Treasures just by dumping and loading the Map object,
    `mymap` (see *gamesave_y.rb* in [Adventures in YAML](ch14s07.html "Adventures
    in YAML")). You can do the same using Marshal instead of YAML:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与 YAML 类似，大多数数据结构可以通过简单地序列化顶层对象并在需要重建其下所有对象时加载它来自动序列化使用 Marshal。例如，看看我的小型冒险游戏程序。在前一章中，我解释了如何通过序列化和加载
    Map 对象 `mymap`（见 [Adventures in YAML](ch14s07.html "Adventures in YAML") 中的 *gamesave_y.rb*）来保存和恢复包含宝物的房间。你可以用
    Marshal 而不是 YAML 来做同样的事情：
- en: '*gamesave_m.rb*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*gamesave_m.rb*'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Objects cannot be so easily serialized in a few special circumstances. These
    exceptions are documented in the code of Ruby’s `Marshal` module (*marshal.c*),
    which states, “If the objects to be dumped include bindings, procedure or method
    objects, instances of class IO, or singleton objects, a TypeError will be raised.”
    I’ll show an example of this while discussing how you might go about saving singletons
    with marshaling.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊情况下，对象不能如此轻易地序列化。这些异常在 Ruby 的 `Marshal` 模块（*marshal.c*）的代码中有记录，它指出，“如果待序列化的对象包括绑定、过程或方法对象、IO
    类的实例或单例对象，将引发 TypeError。” 我将在讨论如何使用序列化保存单例对象时展示一个例子。
- en: Omitting Variables on Saving
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存时省略变量
- en: As with YAML serialization, it is possible to limit the variables that are saved
    when serializing using Marshal. In YAML, you did this by writing a method called
    `to_yaml_properties`. With Marshal, you need to write a method named `marshal_dump`.
    In the code of this method you should create an array containing the *actual variables*
    to be saved (in YAML, you created an array of *strings* containing the variable
    *names*).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与 YAML 序列化一样，使用 Marshal 序列化时可以限制要保存的变量。在 YAML 中，你通过编写一个名为 `to_yaml_properties`
    的方法来完成此操作。对于 Marshal，你需要编写一个名为 `marshal_dump` 的方法。在这个方法的代码中，你应该创建一个包含要保存的 *实际变量*
    的数组（在 YAML 中，你创建了一个包含变量 *名称* 的字符串数组的数组）。
- en: 'This is an example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another difference is that, with YAML, you were able simply to load the data
    in order to re-create an object. With Marshal, you need to add a special method
    called `marshal_load` to which any loaded data is passed as an argument. This
    will be invoked automatically when you call `Marshal.load`, and it will be passed
    the data in the form of an array. The previously saved objects can be parsed from
    this array. You can also assign values to any variables that were omitted (such
    as `@some_other_variable` here) when the data was saved:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，使用 YAML，你可以简单地加载数据以重新创建对象。而使用 Marshal，你需要添加一个名为 `marshal_load` 的特殊方法，将任何加载的数据作为参数传递给它。当你调用
    `Marshal.load` 时，它将自动被调用，并将数据以数组的形式传递。之前保存的对象可以从这个数组中解析出来。你还可以为在保存数据时省略的任何变量（例如这里的
    `@some_other_variable`）分配值：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a complete program that saves and restores the variables `@num` and
    `@arr` but omits `@str`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的程序，它保存和恢复了 `@num` 和 `@arr` 变量，但省略了 `@str`：
- en: '*limit_m.rb*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*limit_m.rb*'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that although the serialization is done here in memory, the same techniques
    can be used when using Marshal to save and load objects to and from disk.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这里的序列化是在内存中完成的，但相同的技巧也可以用于使用 Marshal 将对象保存到磁盘和从磁盘加载。
- en: Saving Singletons
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存单例
- en: 'Let’s take a look at a concrete example of a problem mentioned earlier, namely,
    the inability to use marshaling to save and load a singleton. In *singleton_m.rb*
    I have created an instance of Object, `ob`, and then extended it in the form of
    a singleton class that is given the additional method, `xxx`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前提到的一个具体问题，即无法使用 marshaling 来保存和加载单例。在 *singleton_m.rb* 中，我创建了一个 Object
    实例，名为 `ob`，然后以单例类的形式扩展它，并给它添加了一个额外的 `xxx` 方法：
- en: '*singleton_m.rb*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_m.rb*'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The problem arises when I try to save this data to disk using `Marshal.dump`.
    Ruby displays an error message: “singleton can’t be dumped (TypeError).”'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试使用 `Marshal.dump` 将这些数据保存到磁盘时，Ruby 显示了一个错误信息：“singleton can’t be dumped
    (TypeError)。”
- en: YAML and Singletons
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 和 单例
- en: 'Before considering how you might deal with this, let’s briefly take a look
    at how YAML would cope in this situation. The program *singleton_y.rb* tries to
    save the singleton that I created a moment ago using `YAML.dump`, and, unlike
    `Marshal.dump`, it succeeds—well, sort of:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何处理这个问题之前，让我们简要地看看 YAML 在这种情况下会如何应对。程序 *singleton_y.rb* 尝试使用 `YAML.dump`
    保存我刚才创建的单例，与 `Marshal.dump` 不同，它成功了——好吧，算是吧：
- en: '*singleton_y.rb*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_y.rb*'
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you look at the YAML file that is saved, *test.yml*, you’ll find that it
    defines an instance of a plain-vanilla Object to which a variable named `x` is
    appended that has the string value `hello world`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看保存的 YAML 文件，名为 *test.yml*，你会发现它定义了一个普通的 Object 实例，并附加了一个名为 `x` 的变量，该变量的字符串值为
    `hello world`：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That’s all well and good. However, when you reconstruct the object by loading
    the saved data, the new `ob` will be a standard instance of Object, which happens
    to contain an additional instance variable, `@x`. Since it is no longer the original
    singleton, this `ob` will not have access to any of the methods (here the `xxx`
    method) defined in that singleton. So, although YAML serialization is more permissive
    about saving and loading data items that were created in a singleton, it does
    not automatically re-create the singleton itself when the saved data is reloaded.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很好。然而，当你通过加载保存的数据重新构建对象时，新的 `ob` 将是一个标准的 Object 实例，它恰好包含一个额外的实例变量，`@x`。由于它不再是原始的单例，这个
    `ob` 将无法访问在该单例中定义的任何方法（这里是指 `xxx` 方法）。因此，尽管 YAML 序列化在保存和加载数据项方面对在单例中创建的数据项更为宽容，但它不会在重新加载保存的数据时自动重新创建单例。
- en: Marshal and Singletons
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marshal 和 单例
- en: Let’s now return to the Marshal version of this program. The first thing I need
    to do is find a way of at least making it save and load data items. Once I’ve
    done that, I’ll try to figure out how to reconstruct singletons on reloading.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到这个程序的 Marshal 版本。我需要做的第一件事是找到至少保存和加载数据项的方法。一旦我做到了这一点，我就会尝试找出如何在重新加载时重建单例。
- en: To save specific data items, I can define the `marshal_dump` and `marshal_load`
    methods as explained earlier (see *limit_m.rb*). These should normally be defined
    in a class from which the singleton derives, *not* in the singleton itself. This
    is because, as already explained, when the data is saved, it will be stored as
    a representation of the class from which the singleton derives. This means that
    although you could indeed add `marshal_dump` to a singleton derived from class
    X, when you reconstruct the object, you will be loading data for an object of
    the generic type X, not of the specific singleton instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存特定的数据项，我可以定义前面解释过的`marshal_dump`和`marshal_load`方法（参见*limit_m.rb*）。这些方法通常应该定义在单例派生的类中，而不是单例本身。这是因为，正如前面解释的，当数据被保存时，它将以单例派生类的表示形式存储。这意味着尽管你确实可以向从类X派生的单例添加`marshal_dump`，但在重构对象时，你将加载一个通用类型X的对象的数据，而不是特定单例实例的数据。
- en: 'This code creates a singleton, `ob`, of class X, saves its data, and then re-creates
    a generic object of class X:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个类X的单例`ob`，保存其数据，然后重新创建了一个类X的通用对象：
- en: '*singleton_m2.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_m2.rb*'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code here uses `Marshal.dump` to save an object, `ob`, of class X and then
    calls the singleton method, `xxx`, to assign a different string to the `@x` variable
    before reloading the saved data using `Marshal.load` and using this data to re-create
    the object. The contents of `ob` are displayed using `p()` before it is saved,
    then again after a new string is assigned to it, and finally once again when it
    is reloaded. This lets you verify that `@x` is assigned the value that was saved
    when the reloaded object is reconstructed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的代码使用`Marshal.dump`保存类X的对象`ob`，然后调用单例方法`xxx`在重新加载保存的数据之前将不同的字符串分配给`@x`变量，然后使用`Marshal.load`重新加载保存的数据，并使用这些数据重新创建对象。使用`p()`显示`ob`的内容，在保存之前，然后在新字符串分配给它之后，最后在重新加载时再次显示。这让你可以验证在重新加载的对象重构时`@x`被分配了保存时的值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In terms of the data it contains, the object saved and the object reloaded
    are identical. However, the object that is reloaded knows nothing about the singleton
    class. The method `xxx` that the singleton class contains forms no part of the
    reconstructed object. The following, then, would fail:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含的数据方面，保存的对象和重新加载的对象是相同的。然而，重新加载的对象对单例类一无所知。单例类中包含的`xxx`方法并不构成重构对象的一部分。因此，以下操作将失败：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This Marshal version of the code is equivalent to the YAML version given earlier.
    It saves and restores the data correctly, but it does not reconstruct the singleton.
    How, then, is it possible to reconstruct a singleton from saved data? There are,
    no doubt, many clever and subtle ways in which this might be accomplished. I shall,
    however, opt for a very simple technique:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的Marshal版本与前面给出的YAML版本等效。它正确地保存和恢复了数据，但它不会重构单例。那么，如何从保存的数据中重构单例呢？无疑，有许多巧妙和微妙的方法可以实现这一点。然而，我将选择一个非常简单的技术：
- en: '*singleton_m3.rb*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_m3.rb*'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code first checks whether a file containing the saved data can be found.
    (This sample has been kept deliberately simple—in a real application you would
    of course need to write some exception-handling code to deal with the possibility
    of reading in invalid data.) If the file is found, the data is loaded into an
    object of the generic `X` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码首先检查是否可以找到包含保存数据的文件。（这个示例被故意保持简单——在实际应用中，你当然需要编写一些异常处理代码来处理读取无效数据的可能性。）如果找到文件，数据将被加载到一个通用类型`X`的对象中。
- en: 'Only when this has been done is this object “transformed” into a singleton
    in the usual way. In other words, the object is loaded, and then the code beginning
    `class << ob` executes (simply because the singleton-creation code occurs after
    the loading code and so is executed in sequence by the Ruby interpreter). This
    provides the object with the additional `xxx` singleton method. You can then save
    the new data back to disk and reload and re-create the modified singleton, as
    explained earlier, at a later stage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只有完成此操作后，此对象才会以通常的方式“转换”为单例。换句话说，对象被加载，然后执行以`class << ob`开始的代码（简单地因为单例创建代码在加载代码之后，所以由Ruby解释器按顺序执行）。这为对象提供了额外的`xxx`单例方法。然后你可以将新数据保存回磁盘，并在稍后阶段按照前面解释的方法重新加载和重新创建修改后的单例：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you wanted to save and load singletons in a real application, the singleton
    “reconstruction” code could, naturally, be given its own method so that you don’t
    have to rely upon its position in your code as in the previous example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在真实的应用程序中保存和加载单例，单例“重建”代码自然可以有自己的方法，这样你就不必像上一个例子那样依赖于它在代码中的位置。
- en: '*singleton_m4.rb*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*singleton_m4.rb*'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Digging Deeper
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: If you attempt to load data that was saved with a different version of the Marshal
    library you may run into problems. Here you will learn how to verify the version
    of Marshal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试加载使用不同版本的 Marshal 库保存的数据，可能会遇到问题。在这里，你将学习如何验证 Marshal 的版本。
- en: Marshal Version Numbers
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Marshal 版本号
- en: 'The embedded documentation of the Marshal library (a C language file named
    *marshal.c*) states the following: “Marshaled data has major and minor version
    numbers stored along with the object information. In normal use, marshaling can
    only load data written with the same major version number and an equal or lower
    minor version number.”'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Marshal 库的嵌入式文档（一个名为 *marshal.c* 的 C 语言文件）声明如下：“序列化的数据存储了与对象信息一起的主版本号和次版本号。在正常使用中，序列化只能加载与相同主版本号和相同或更低次版本号的数据。”
- en: This clearly raises the potential problem that the format of data files created
    by marshaling may be incompatible with the current Ruby application. The Marshal
    version number, incidentally, is not dependent on the Ruby version number, so
    it is not safe to make assumptions of compatibility based solely on the Ruby version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这明显提出了一个潜在问题，即序列化创建的数据文件格式可能与当前的 Ruby 应用程序不兼容。顺便提一下，Marshal 版本号不依赖于 Ruby 版本号，因此仅基于
    Ruby 版本做出兼容性的假设是不安全的。
- en: This possibility of incompatibility means you should always check the version
    number of the saved data before attempting to load it. But how do you get hold
    of the version number? Once again, the embedded documentation provides a clue.
    It states, “You can extract the version by reading the first two bytes of marshaled
    data.”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不兼容的可能性意味着在尝试加载之前，你应该始终检查保存数据的版本号。但你怎么获取版本号呢？再次，嵌入式文档提供了线索。它声明，“你可以通过读取序列化数据的前两个字节来提取版本号。”
- en: 'Ruby 1.8 provides this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8 提供了以下示例：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Okay, so let’s try this in a fully worked piece of code. Here goes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们尝试在一个完整的代码块中实现这个功能。下面是代码：
- en: '*version_m.rb*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*version_m.rb*'
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the previous code, `x` is a string, and its first two bytes are the major
    and minor version numbers. In Ruby 1.8, this prints out the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，`x` 是一个字符串，其前两个字节是主版本号和次版本号。在 Ruby 1.8 中，它会输出以下内容：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Ruby 1.9, however, no numbers are displayed. This is because the first two
    bytes are returned as integers in Ruby 1.8 but as strings in Ruby 1.9\. These
    strings are not necessarily printable. You can see this quite simply by using
    the `p()` method to display the elements at index 0 and index 1 of the array `x`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Ruby 1.9 中，没有显示任何数字。这是因为 Ruby 1.8 中前两个字节作为整数返回，但在 Ruby 1.9 中作为字符串返回。这些字符串不一定可打印。你可以通过使用
    `p()` 方法来显示数组 `x` 的索引 0 和索引 1 的元素来简单地看到这一点：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The strings returned by Ruby 1.9 may be shown either as hexadecimal values
    or as escape characters. Here you can see that, for Marshal version 4.8, the first
    value is \x04, which is the hexadecimal representation of 4, while the second
    value is \b, which is the escape character for the backspace that happens to have
    the ASCII value of 8\. The `ord` method can be used to do the necessary conversion
    from string to integer. This is the Ruby 1.9 version:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 返回的字符串可以显示为十六进制值或转义字符。在这里，你可以看到，对于 Marshal 版本 4.8，第一个值是 \x04，这是 4 的十六进制表示，而第二个值是
    \b，它是退格符的转义字符，恰好具有 ASCII 值 8。可以使用 `ord` 方法将字符串转换为整数。这是 Ruby 1.9 的版本：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This now correctly displays the version number: `4:8`. Of course, if you are
    using a different version of the Marshal library, the numbers displayed will be
    different. The Marshal library also declares two constants, `MAJOR_VERSION` and
    `MINOR_VERSION`, which store the version numbers of the Marshal library currently
    in use. So, at first sight, it looks as though it should be easy to compare the
    version number of saved data with the current version number.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正确地显示了版本号：`4:8`。当然，如果你使用的是 Marshal 库的不同版本，显示的数字将不同。Marshal 库还声明了两个常量，`MAJOR_VERSION`
    和 `MINOR_VERSION`，它们存储当前正在使用的 Marshal 库的版本号。所以，乍一看，似乎应该很容易比较保存数据的版本号和当前版本号。
- en: 'There is just one problem: When you save data to a file on disk, the `dump`
    method takes an IO or File object, and it returns an IO (or File) object rather
    than a string:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题：当你将数据保存到磁盘上的文件时，`dump` 方法接受一个 IO 或 File 对象，并返回一个 IO（或 File）对象，而不是一个字符串：
- en: '*version_error.rb*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*version_error.rb*'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you now try to get the values of `x[0]` and `x[1]`, you will receive an
    error message:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试获取 `x[0]` 和 `x[1]` 的值，你会收到一个错误信息：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Loading the data back from the file is no more instructive:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中重新加载数据并没有什么指导意义：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The two `puts` statements here don’t (as I was naively hoping) print out the
    major and minor version numbers of the marshaled data; in fact, they print out
    the names “fred” and “bert”—that is, the two first items loaded into the array,
    `x`, from the data file, *friends.sav*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个 `puts` 语句并没有（正如我天真地希望的那样）打印出被序列化数据的版本号的主版本和次版本号；实际上，它们打印出的是名称“fred”和“bert”——也就是说，从数据文件
    *friends.sav* 中加载到数组 `x` 的前两个元素。
- en: 'So, how the heck can you get the version number from the saved data? I have
    to admit that I was forced to read my way through the C code (not my favorite
    activity!) in *marshal.c* and examine the hexadecimal data in a saved file to
    figure this out. It turns out that, just as the documentation says, “You can extract
    the version by reading the first two bytes of marshaled data.” However, this isn’t
    done for you. You have to read this data explicitly, as shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟如何从保存的数据中获取版本号呢？我必须承认，我不得不阅读 *marshal.c* 中的 C 代码（这不是我最喜欢的活动！）并检查保存文件中的十六进制数据来找出答案。结果证明，正如文档所说，“你可以通过读取序列化数据的前两个字节来提取版本号。”然而，这并不是自动完成的。你必须显式地读取这些数据，如下所示：
- en: '*version_m2.rb*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*version_m2.rb*'
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here the `getc` method reads the next 8-bit byte from the input stream. Notice
    that I have once again written a test to make this compatible both with Ruby 1.8,
    in which `getc` returns a numeric character value, and with Ruby 1.9, in which
    `getc` returns a one-character string that has to be converted to an integer using
    `ord`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getc` 方法从输入流中读取下一个 8 位字节。请注意，我再次编写了一个测试，使其与 Ruby 1.8 兼容，在 Ruby 1.8 中 `getc`
    返回一个数值字符值，以及与 Ruby 1.9 兼容，在 Ruby 1.9 中 `getc` 返回一个必须使用 `ord` 转换为整数的单字符字符串。
- en: My sample project, *version_m2.rb*, shows a simple way of comparing the version
    number of the saved data with that of the current Marshal library in order to
    establish whether the data formats are likely to be compatible before attempting
    to reload the data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我的示例项目 *version_m2.rb* 展示了一种简单的方法，用于比较保存数据的版本号与当前 Marshal 库的版本号，以便在尝试重新加载数据之前确定数据格式是否可能兼容。
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
