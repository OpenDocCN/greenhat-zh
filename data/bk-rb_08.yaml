- en: Chapter 8. Passing Arguments and Returning Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。传递参数和返回值
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: In this chapter, you’ll be looking at many of the effects (and side effects)
    of passing arguments and returning values to and from methods. First, though,
    I’ll take a moment to summarize the types of methods you’ve used up to now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解许多传递参数和从方法返回值的效果（以及副作用）。首先，我将花一点时间总结一下你到目前为止所使用的方法类型。
- en: Summarizing Instance, Class, and Singleton Methods
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结实例、类和单例方法
- en: 'An instance method is declared inside a class definition and is intended for
    use by a specific object or “instance” of the class, like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法是在类定义内部声明的，并旨在由特定的对象或类的“实例”使用，如下所示：
- en: '*methods.rb*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*methods.rb*'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A class method may be declared inside a class definition, in which case the
    method name may be preceded by the class name, or a `class << self` block may
    contain a “normal” method definition. Either way, a class method is intended for
    use by the class itself, not by a specific object, like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法可以在类定义内部声明，在这种情况下，方法名可能前面有类名，或者一个 `class << self` 块可以包含一个“正常”的方法定义。无论哪种方式，类方法都是为类本身使用，而不是为特定的对象使用，如下所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Singleton methods are methods that are added to a single object and cannot
    be used by other objects. A singleton method may be defined by appending the method
    name to the object name followed by a dot or by placing a “normal” method definition
    inside an *`ObjectName`* `<< self` block like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单例方法是添加到单个对象中的方法，不能被其他对象使用。单例方法可以通过将方法名附加到对象名后跟一个点来定义，或者将一个“正常”的方法定义放在一个 *`ObjectName`*
    `<< self` 块中，如下所示：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Returning Values
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: In many programming languages, a distinction is made between functions or methods
    that return a value to the calling code and those that do not. In Pascal, for
    example, a *function* returns a value, but a *procedure* does not. No such distinction
    is made in Ruby. All methods always return a value, though of course you are not
    obliged to use it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，区分了返回值给调用代码的函数或方法和不返回值的函数或方法。例如，在 Pascal 中，一个 *函数* 会返回一个值，但一个 *过程*
    不会。Ruby 中没有这样的区分。所有方法总是返回一个值，尽管当然你不必使用它。
- en: 'When no return value is specified, Ruby methods return the result of the last
    expression evaluated. Consider this method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当未指定返回值时，Ruby 方法返回最后评估的表达式的结果。考虑这个方法：
- en: '*return_vals.rb*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*return_vals.rb*'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last expression evaluated is `a + b`, which happens to return 3, so that
    is the value returned by this method. There may often be times when you don’t
    want to return the last expression evaluated. In such cases, you can specify the
    return value using the `return` keyword:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后评估的表达式是 `a + b`，它恰好返回 3，因此这是此方法返回的值。可能经常会有你不想返回最后评估的表达式的情况。在这种情况下，你可以使用 `return`
    关键字指定返回值：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A method is not obliged to make any assignments in order to return a value.
    If a simple piece of data happens to be the last thing evaluated in a method,
    that will be the value the method returns. When nothing is evaluated, `nil` is
    returned:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方法不一定要进行任何赋值以返回一个值。如果简单数据恰好是方法中最后评估的内容，那么它将是方法返回的值。如果没有内容被评估，则返回 `nil`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: My own programming prejudice is to write code that is clear and unambiguous
    whenever possible. For that reason, whenever I plan to use the value returned
    by a method, I prefer to specify it using the `return` keyword; only when I do
    not plan to use the returned value do I omit this. However, this is not obligatory—Ruby
    leaves the choice to you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我的编程偏见是尽可能编写清晰且无歧义的代码。因此，每当我计划使用方法返回的值时，我更喜欢使用 `return` 关键字来指定它；只有在我不打算使用返回值时，我才省略这个关键字。然而，这并非强制性的——Ruby
    将选择权留给了你。
- en: Returning Multiple Values
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个值
- en: But what about those occasions when you need a method to return more than one
    value? In other program languages, you may be able to “fake” this by passing arguments
    by reference (pointers to the original data items) rather than by value (a copy
    of the data); when you alter the values of “by reference” arguments, you alter
    the original values without explicitly having to return any values to the calling
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你需要一种方法返回多个值时怎么办？在其他程序语言中，你可能可以通过传递引用（原始数据项的指针）而不是值（数据的副本）来实现“伪造”这一功能；当你改变“引用”参数的值时，你会改变原始值，而无需明确地将任何值返回给调用代码。
- en: 'Ruby doesn’t make a distinction between “by reference” and “by value,” so this
    technique is not available to you (though you will see some exceptions to the
    rule shortly). However, Ruby is capable of returning multiple values all in one
    go, as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 不会区分“按引用”和“按值”，因此这项技术对你不可用（尽管你很快就会看到一些规则的例外）。然而，Ruby 能够一次性返回多个值，如下所示：
- en: '*return_many.rb*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*return_many.rb*'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Multiple return values are placed into an array. If you were to evaluate `ret_things.class`,
    Ruby would inform you that the returned object is an Array. You could, however,
    explicitly return a different collection type such as a Hash:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多个返回值被放入一个数组中。如果你要评估 `ret_things.class`，Ruby 会告诉你返回的对象是一个数组。然而，你可以显式地返回不同的集合类型，例如一个哈希表：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Default and Multiple Arguments
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值和多个参数
- en: 'Ruby lets you specify default values for arguments. Default values can be assigned
    in the parameter list of a method using the usual assignment operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 允许你为参数指定默认值。默认值可以在方法参数列表中使用常规赋值运算符进行分配：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If an unassigned variable is passed to that method, the default value will
    be assigned to it. If an assigned variable is passed, however, the assigned value
    takes precedence over the default. Here I use the `p()` method to inspect and
    print the return values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将未分配的变量传递给该方法，则将分配默认值。但是，如果传递已分配的变量，则分配的值将优先于默认值。在这里，我使用 `p()` 方法来检查和打印返回值：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In some cases, a method may need to be capable of receiving an uncertain number
    of arguments—say, for example, a method that processes a variable-length list
    of items. In this case, you can “mop up” any number of trailing items by preceding
    the final argument with an asterisk:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个方法可能需要能够接收不确定数量的参数——比如，例如处理可变长度项目列表的方法。在这种情况下，你可以通过在最后一个参数前加上星号来“清除”任何数量的尾随项：
- en: '*default_args.rb*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*default_args.rb*'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Assignment and Parameter Passing
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值和参数传递
- en: Most of the time, Ruby methods come with two access points—like the doors into
    and out of a room. The argument list provides the way in; the return value provides
    the way out. Modifications made to the input arguments do not affect the original
    data for the simple reason that when Ruby evaluates an expression, the result
    of that evaluation creates a new object, so any changes made to an argument affect
    only the new object, not the original piece of data. But there are exceptions
    to this rule, which I’ll show you now.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Ruby 方法有两个访问点——就像进入和离开房间的门。参数列表提供了进入的方式；返回值提供了离开的方式。对输入参数所做的修改不会影响原始数据，简单的理由是当
    Ruby 评估一个表达式时，该评估的结果会创建一个新的对象，因此对参数所做的任何更改只会影响新的对象，而不会影响原始数据。但这个规则也有例外，我现在会向你展示。
- en: 'Let’s start by looking at the simplest case—a method that takes one value as
    a named parameter and returns another value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的情况开始看起——一个接受一个命名参数并返回另一个值的方法：
- en: '*in_out.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*in_out.rb*'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'On the face of it, you might think you are dealing with a single object, `x`,
    here: The object `x` goes into the `change` method, and the same object `x` is
    returned. In fact, that is not the case. One object goes in (the argument), and
    a different object comes out (the return value). You can easily verify this using
    the `object_id` method to show a number that uniquely identifies each object in
    your program:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，你可能会认为你在这里处理的是一个单一的对象 `x`：对象 `x` 进入 `change` 方法，并且相同的对象 `x` 被返回。实际上并非如此。一个对象进入（参数），另一个不同的对象出来（返回值）。你可以通过使用
    `object_id` 方法来轻松验证这一点，该方法显示一个唯一标识程序中每个对象的数字：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The identifier of the variable, `num`, is different before and after you call
    the `change` method. This shows that even though the variable name remains the
    same, the `num` object that is returned by the `change` method is different from
    the `num` object that was sent to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 变量标识符 `num` 在调用 `change` 方法前后是不同的。这表明尽管变量名保持不变，但 `change` 方法返回的 `num` 对象与发送给它的
    `num` 对象是不同的。
- en: 'The method call itself has nothing to do with the change of the object. You
    can verify this by running *method_call.rb*. This simply passes the `num` object
    to the change method and returns it:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用本身与对象的改变无关。你可以通过运行 *method_call.rb* 来验证这一点。这仅仅是将 `num` 对象传递给 `change` 方法并返回它：
- en: '*method_call.rb*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*method_call.rb*'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the `object_id` is the same after `num` is returned as it was
    before `num` was sent to the method. In other words, the object that went into
    the method is the same object as the one that came out again. That leads to the
    inevitable conclusion that there is something about the *assignment* in the `change`
    method (`x += 1`) that caused the creation of a new object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`object_id` 在返回 `num` 之后与发送到方法之前相同。换句话说，进入方法的对象与再次出来的对象是同一个对象。这导致了一个不可避免的结论，那就是
    `change` 方法（`x += 1`）中的 `assignment` 导致了新对象的创建。
- en: 'But assignment itself isn’t the whole explanation. If you simply assign a variable
    to itself, no new object is created:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但赋值本身并不是全部的解释。如果你只是将一个变量赋值给自己，不会创建新的对象：
- en: '*assignment.rb*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*assignment.rb*'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you now display the `object_id` of the `num` variable, the number is the
    same before an after assignment, proving that this really is the same object.
    So, what if you assign to the object the same value that it already has?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在显示 `num` 变量的 `object_id`，赋值前后数字相同，这证明了这确实是一个相同的对象。那么，如果你将对象赋值为它已经拥有的相同值呢？
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once again, the `object_id` is unchanged after the assignment. This demonstrates
    that assignment alone does not necessarily create a new object. Now let’s try
    assigning a new value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，赋值后 `object_id` 没有改变。这表明仅赋值本身并不一定会创建新对象。现在让我们尝试赋一个新的值：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, if you display `num.object_id` before and after the assignment, you
    will see a different number—say 21 before and 23 after. The actual numbers are
    automatically determined by Ruby and may vary. The important thing to understand
    is that a different object ID indicates a different object. If the same variable
    returns a different `object_id` when a value is assigned to it, that means a new
    object has been created.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如果你在赋值前后显示 `num.object_id`，你会看到不同的数字——比如说赋值前是21，赋值后是23。实际的数字是由 Ruby 自动确定的，可能不同。重要的是要理解，不同的对象ID表示不同的对象。如果相同的变量在赋值时返回不同的
    `object_id`，这意味着已经创建了新的对象。
- en: Most data items are treated as unique, so one string “hello” is considered to
    be different from another string “hello,” and one float 10.5 is considered to
    be different from another float 10.5\. Thus, any string or float assignment will
    create a new object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据项被视为唯一的，所以一个字符串“hello”被认为与另一个字符串“hello,”不同，一个浮点数10.5被认为与另一个浮点数10.5不同。因此，任何字符串或浮点数的赋值都会创建一个新的对象。
- en: But when working with integers, only when the assignment value is *different*
    from the previous value is a new object created. You can do all kinds of complicated
    operations on the right side of the assignment, but if the yielded value is the
    same as the original value, no new object is created.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但当与整数一起工作时，只有当赋值值与之前的值不同时，才会创建新对象。你可以在赋值号的右侧进行所有种类的复杂操作，但如果产生的值与原始值相同，则不会创建新对象。
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the previous code, the first assignment creates a new `num` object with
    the integer value 11\. Even though the result of a fairly complex expression is
    used in the next assignment, this still has the value 11\. Since the value of
    `num` is not changed, no new objects are created, and its `object_id` remains
    the same:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一次赋值创建了一个具有整数值11的新 `num` 对象。即使下一个赋值使用了相当复杂的表达式的结果，这个值仍然是11。由于 `num`
    的值没有改变，因此没有创建新的对象，它的 `object_id` 保持不变：
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Integers Are Special
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数是特殊的
- en: 'In Ruby, an integer (or Fixnum) has a fixed identity. Every instance of the
    number 10 or every variable to which the value 10 is assigned will have the same
    `object_id`. The same cannot be said of other data types. Each instance of a floating-point
    number such as 10.5 or of a string such as “hello world” will be a different object
    with a unique `object_id`. Be aware that when you assign an integer to a variable,
    that variable will have the `object_id` *of the integer itself*. But when you
    assign some other type of data to a variable, a new object will be created even
    if the data itself is the same at each assignment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，整数（或 Fixnum）有一个固定的身份。每个数字10的实例或被赋予值10的变量都将具有相同的 `object_id`。这不能适用于其他数据类型。例如，10.5这样的浮点数或“hello
    world”这样的字符串的每个实例都将是一个具有唯一 `object_id` 的不同对象。请注意，当你将整数赋给变量时，该变量将具有整数的 `object_id`。但当你将其他类型的数据赋给变量时，即使每次赋值的数据本身相同，也会创建一个新的对象：
- en: '*object_ids.rb*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*object_ids.rb*'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But why does all this matter?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么这一切都这么重要？
- en: It matters because of a few rare exceptions to the rule. As I said earlier,
    most of the time, a method has a well-defined way in and a well-defined way out.
    Once an argument goes inside a method, it enters a closed room. Any code outside
    that method has no way of learning about any changes that have been made to the
    argument until it comes out again in the form of a returned value. This is, in
    fact, one of the deep secrets of “pure” object orientation. The implementation
    details of methods should, in principle, be hidden away, or *encapsulated*. This
    ensures that code outside an object cannot be dependent on things that happen
    inside that object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为有一些罕见的例外情况。正如我之前所说的，大多数时候，一个方法有一个明确的进入方式和一个明确的退出方式。一旦参数进入方法，它就进入了一个封闭的房间。任何在该方法之外的外部代码都无法了解对参数所做的任何更改，直到它以返回值的形态再次出现。这实际上是“纯”面向对象的一个深层次秘密。方法的具体实现细节应该，原则上，被隐藏起来，或者*封装*。这确保了对象之外的外部代码不能依赖于对象内部发生的事情。
- en: The One-Way-In, One-Way-Out Principle
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向进入，单向退出原则
- en: 'In most modern object-oriented languages such as Java and C#, encapsulation
    and information hiding are not rigorously enforced. In Smalltalk, on the other
    hand—the most famous and influential object-oriented language—encapsulation and
    information hiding are fundamental principles: If you send a variable `x` to a
    method `y` and the value of `x` is changed inside `y`, you cannot obtain the changed
    value of `x` from outside the method—*unless the method explicitly returns that
    value*.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代面向对象的语言，如Java和C#中，封装和信息隐藏并没有得到严格的强制执行。另一方面，在Smalltalk——最著名和最有影响力的面向对象语言中——封装和信息隐藏是基本原理：如果你将变量`x`发送到方法`y`，并且`x`的值在`y`中被更改，你无法从方法外部获得`x`的更改后的值——*除非方法明确返回该值*。
- en: Encapsulation or Information Hiding?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 封装或信息隐藏？
- en: Often these two terms are used interchangeably. To be nitpicky, however, there
    is a difference. *Encapsulation* refers to the grouping together of an object’s
    “state” (its data) and the operations that may alter or interrogate its state
    (its methods). *Information hiding* refers to the fact that data is sealed off
    and can be accessed only using well-defined routes in and out—in object-oriented
    terms, this implies “accessor methods” to get or return values. In procedural
    languages, information hiding may take other forms; for example, you might have
    to define interfaces to retrieve data from code “units” or “modules” rather than
    from objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这两个术语是互换使用的。然而，要吹毛求疵的话，它们之间还是存在差异。*封装*指的是将对象的“状态”（其数据）和可能改变或查询其状态的运算（其方法）组合在一起。*信息隐藏*指的是数据被封闭起来，只能通过定义良好的进出路径访问——在面向对象术语中，这暗示了“访问器方法”来获取或返回值。在过程式语言中，信息隐藏可能采取其他形式；例如，你可能必须定义接口从代码“单元”或“模块”而不是从对象中检索数据。
- en: In object-oriented terms, encapsulation and information hiding are almost synonymous—true
    encapsulation necessarily implies that the internal data of an object is hidden.
    However, many modern object-oriented languages such as Java, C#, C++, and Object
    Pascal are quite permissive in the degree to which information hiding is enforced
    (if at all).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的概念中，封装和信息隐藏几乎是同义的——真正的封装必然意味着对象的内部数据是隐藏的。然而，许多现代面向对象的语言，如Java、C#、C++和Object
    Pascal，在强制执行信息隐藏的程度（如果有的话）上相当宽容。
- en: 'Usually, Ruby adheres to this principle: Arguments go into a method, but any
    changes made inside the method cannot be accessed from the outside unless Ruby
    returns the changed value:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Ruby遵循这一原则：参数进入方法，但方法内部所做的任何更改都无法从外部访问，除非Ruby返回更改后的值：
- en: '*hidden.rb*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*hidden.rb*'
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous code, the string value of the second object, `str2`, is received
    by the `anotherStr` argument of the `hidden` method. The argument is assigned
    a new string value and reversed. Even so, neither of the original variables, `str1`
    or `str2`, is changed. Only the variable assigned the return value, `str3`, contains
    the changed “hello world” string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，第二个对象`str2`的字符串值被接收为`hidden`方法的`anotherStr`参数。该参数被分配了一个新的字符串值并反转。即便如此，原始变量`str1`或`str2`都没有改变。只有被分配返回值`str3`的变量包含了更改后的“hello
    world”字符串。
- en: It turns out that there are occasions when arguments passed to a Ruby method
    can be used like the “by reference” arguments of other languages (that is, changes
    made *inside* the method may affect variables *outside* the method). This is because
    some Ruby methods modify the original object rather than yielding a value and
    assigning this to a new object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在某些情况下，传递给Ruby方法的参数可以像其他语言的“按引用”参数一样使用（也就是说，在方法内部做出的更改可能会影响方法外部的变量）。这是因为一些Ruby方法修改了原始对象，而不是返回一个值并将其分配给新对象。
- en: 'For example, there are some methods ending with an exclamation mark that alter
    the original object. Similarly, the String append method `<<` concatenates the
    string on its right to the string on its left but does not create a new string
    object in the process: So, the value of the string on the left is modified, but
    the string object itself retains its original `object_id`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一些以感叹号结尾的方法会改变原始对象。同样，String的追加方法`<<`将右侧的字符串连接到左侧的字符串，但在过程中不会创建新的字符串对象：因此，左侧字符串的值被修改，但字符串对象本身保留了其原始的`object_id`。
- en: 'The consequence of this is that if you use the `<<` operator instead of the
    `+` operator in a method, your results will change:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的后果是，如果你在方法中使用`<<`运算符而不是`+`运算符，你的结果将会改变：
- en: '*not_hidden.rb*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*not_hidden.rb*'
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code, the `anotherStr` argument is concatenated with a space
    and the `aStr` argument using `<<`, and the resulting string is reversed when
    returned. If information hiding were rigorously enforced, this might be expected
    to produce the same results as in the previous program—that is, `str1` and `str2`
    would remain unchanged. However, the use of `<<` has had profound effects because
    it has caused the modifications made to the `aStr` argument *inside* the `nothidden`
    method to change the value of the `str1` object *outside* the method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`anotherStr`参数使用`<<`与`aStr`参数连接，并使用`<<`返回的结果字符串被反转。如果严格实施信息隐藏，这可能会产生与上一个程序相同的结果，即`str1`和`str2`将保持不变。然而，使用`<<`产生了深远的影响，因为它导致在`nothidden`方法内部对`aStr`参数所做的修改改变了方法外部的`str1`对象的值。
- en: 'This behavior, incidentally, would be the same if the `nothidden` method were
    placed into a separate class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果将`nothidden`方法放入一个单独的类中，这种行为也会相同：
- en: '*nothidden2.rb*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*nothidden2.rb*'
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This shows that, in certain cases, the internal implementation details of an
    object’s methods may accidentally alter the code that calls it. It is generally
    safer to make implementation details hidden; otherwise, when code is rewritten
    inside a class, the changes may have side effects on code that uses that class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，在某些情况下，对象方法的内部实现细节可能会意外地改变调用它的代码。通常，隐藏实现细节更安全；否则，当类内部重写代码时，这些更改可能会对使用该类的代码产生副作用。
- en: Modifying Receivers and Yielding New Objects
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改接收者并返回新对象
- en: You may recall from [Chapter 4](ch04.html "Chapter 4. Arrays and Hashes") that
    I made the distinction between methods that modify their receiver and those that
    do not. (Remember that a *receiver* is the object that “owns” the method.) In
    most cases, Ruby methods do not modify the receiver object. However, some methods,
    such as those ending with `!`, do modify their receiver.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在[第4章](ch04.html "第4章。数组和哈希")中，我区分了修改其接收者的方法和不修改其接收者的方法。（记住，*接收者*是“拥有”方法的对象。）在大多数情况下，Ruby方法不会修改接收者对象。然而，一些方法，如以`!`结尾的方法，确实会修改它们的接收者。
- en: 'The *str_reverse.rb* sample program should help clarify this. This shows that
    when you use the `reverse` method, for example, no change is made to the receiver
    object (that is, an object such as `str1`). But when you use the `reverse!` method,
    a change *is* made to the object (its letters are reversed). Even so, no new object
    is created: `str1` is the same object before and after the `reverse!` method is
    called.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*str_reverse.rb* 示例程序应该有助于阐明这一点。这表明，当你使用`reverse`方法时，例如，不会对接收者对象（即`str1`这样的对象）做出任何更改。但是，当你使用`reverse!`方法时，对象（其字母顺序被反转）会发生变化。即便如此，也不会创建新对象：在调用`reverse!`方法之前和之后，`str1`仍然是同一个对象。'
- en: 'Here `reverse` operates like most Ruby methods: It yields a value, and in order
    to use that value, you must assign it to a new object. Consider the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`reverse`方法像大多数Ruby方法一样工作：它返回一个值，为了使用这个值，你必须将它分配给一个新的对象。考虑以下情况：
- en: '*str_reverse.rb*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*str_reverse.rb*'
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, `str1` is unaffected by calling `reverse`. It still has the value “hello”
    and still has its original `object_id`. Now look at this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`str1` 调用 `reverse` 后不受影响。它仍然具有值“hello”和它的原始 `object_id`。现在看看这个：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, `str1` *is* changed (it becomes “olleh”). Even so, no new object
    is created: `str1` has the same `object_id` with which it started. So, how about
    this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`str1` 被改变了（变成了“olleh”）。即便如此，也没有创建新的对象：`str1` 仍然具有它开始时的相同的 `object_id`。那么，看看这个：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time, the value yielded by `str1.reverse` is assigned to `str1`. The yielded
    value is a new object, so `str1` is now assigned the reversed string (“olleh”),
    and it now has a new `object_id`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`str1.reverse` 产生的值被分配给了 `str1`。产生的值是一个新对象，所以 `str1` 现在分配了反转的字符串（“olleh”），并且它现在有一个新的
    `object_id`。
- en: 'Refer to the sample program *concat.rb* for an example of the string concatenation
    method, `<<`, which, just like those methods that end with `!`, modifies the receiver
    object without creating a new object (once again, the actual `object_id` numbers
    may be different when you run the code):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参考示例程序 *concat.rb*，了解字符串连接方法 `<<` 的示例，它就像以 `!` 结尾的方法一样，修改接收器对象而不创建新对象（再次强调，当你运行代码时实际的
    `object_id` 数字可能不同）：
- en: '*concat.rb*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*concat.rb*'
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, `str1` is never modified, so it has the same `object_id` throughout;
    `str2` *is* modified through concatenation. However, the `<<` operator does not
    create a new object, so `str2` also retains its original `object_id`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`str1` 永远没有被修改，所以它始终具有相同的 `object_id`；`str2` 通过连接操作被修改。然而，`<<` 操作符不会创建一个新的对象，所以
    `str2` 也保留了其原始的 `object_id`。
- en: 'But `str3` is a different object at the end than at the beginning, because
    it is assigned the value yielded by this expression: `str2 << str1`. This value
    happens to be the `str2` object itself, so the `object_id` of `str3` is now identical
    to that of `str2` (that is, `str2` and `str3` *now reference the same object*).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `str3` 在结束时与开始时是不同的对象，因为它被分配了这个表达式的值：`str2 << str1`。这个值恰好是 `str2` 对象本身，所以
    `str3` 的 `object_id` 现在与 `str2` 的相同（也就是说，`str2` 和 `str3` *现在引用了同一个对象*）。
- en: In summary, then, methods ending with a `!` such as `reverse!`, plus some other
    methods such as the `<<` concatenation method, change the value of the receiver
    object. Most other methods do not change the value of the receiver object. To
    use any new value yielded as a result of calling one of these methods, you have
    to assign that value to a variable (or pass the yielded value as an argument to
    a method).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，那么，以 `!` 结尾的方法，如 `reverse!`，以及一些其他方法，如 `<<` 连接方法，会改变接收器对象的值。大多数其他方法不会改变接收器对象的值。要使用调用这些方法之一产生的新值，你必须将该值赋给一个变量（或将产生的值作为参数传递给一个方法）。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The fact that a few methods modify the receiver object whereas most do not
    may seem harmless enough, but beware: This behavior provides you with the ability
    to retrieve the values of arguments “by reference” rather than retrieving values
    that are explicitly returned. Doing so breaks encapsulation by allowing your code
    to rely upon the internal implementation details of a method. This can potentially
    lead to unpredictable side effects and, in my view, should be avoided.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，只有少数方法会修改接收器对象，而大多数方法则不会，这看起来可能无害，但请注意：这种行为为你提供了通过“引用”检索参数值的能力，而不是检索显式返回的值。这样做会破坏封装，允许你的代码依赖于方法的内部实现细节。这可能导致不可预测的副作用，在我看来，应该避免。
- en: Potential Side Effects of Reliance on Argument Values
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖参数值而非显式返回值的潜在副作用
- en: 'For a simple (but, in real-world programming, potentially serious) example
    of how relying on the modified values of arguments rather than on explicit return
    values can introduce undesirable dependencies on implementation details, see *side_effects.rb*.
    Here is a method called `stringProcess` that takes two string arguments, messes
    about with them, and returns the results:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单（但在现实世界的编程中可能严重的）例子，说明依赖参数的修改值而不是显式返回值如何引入对实现细节的不希望依赖，请参阅 *side_effects.rb*。这里有一个名为
    `stringProcess` 的方法，它接受两个字符串参数，对它们进行操作，并返回结果：
- en: '*side_effects.rb*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*side_effects.rb*'
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s assume the object of the exercise is to take two lowercase strings and
    return a single string that combines these two strings, separated by a space and
    with the first and last letters capitalized. So, the two original strings might
    be “hello” and “world,” and the returned string is “Hello worlD.” This works fine:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设练习的目标是取两个小写字符串，并返回一个将这两个字符串结合起来的单个字符串，用空格分隔，并且首尾字母大写。所以，两个原始字符串可能是“hello”和“world”，返回的字符串是“Hello
    worlD”。这没问题：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But now there is an impatient programmer who can’t be bothered with return
    values. He notices that the modifications made inside the method change the values
    of the ingoing arguments. So, heck! (he decides), he might as well use the arguments
    themselves! This is his version:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在有一个急躁的程序员不愿意处理返回值。他注意到方法内部所做的修改改变了传入参数的值。所以，他心想！（他决定），他干脆使用这些参数本身！这是他的版本：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By using the values of the input arguments, `str1` and `str2`, he has obtained
    the same result as if he had used the returned value, `str3`. He then goes away
    and writes a fabulously complicated text-processing system with thousands of bits
    of code reliant on the changed values of those two arguments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用输入参数的值`str1`和`str2`，他已经得到了与使用返回值`str3`相同的结果。然后他离开并编写了一个极其复杂的文本处理系统，有成千上万的代码依赖于这两个参数的改变值。
- en: 'But now the programmer who originally wrote the `stringProcess` method decides
    that the original implementation was inefficient or inelegant and so rewrites
    the code confident in the knowledge that the return value is unchanged (if “hello”
    and “world” are sent as arguments, “Hello worlD” is returned just as it was by
    the previous version):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，最初编写`stringProcess`方法的程序员决定原始实现效率低下或不够优雅，因此重新编写了代码，并确信返回值没有改变（如果发送“hello”和“world”作为参数，将返回“Hello
    worlD”，就像上一个版本一样）：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Aha! But the new implementation causes the values of the input arguments to
    be changed inside the body of the method. So, the impatient programmer’s text-processing
    system, which relies on those *arguments* rather than on the return value, is
    now filled with bits of text saying “hello Dlrow” instead of the “Hello worlD”
    he was expecting (actually, it turns out that his program was processing the works
    of Shakespeare, so a generation of actors will end up declaiming, “To eb or ton
    to eb, that si the noitseuq...”). This is the kind of unexpected side effect that
    can easily be avoided by following the one-way-in, one-way-out principle.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哎！但新的实现导致方法体内输入参数的值被改变。所以，那个急躁的程序员依赖这些*参数*而不是返回值的文本处理系统，现在充满了“hello Dlrow”这样的文本片段，而不是他预期的“Hello
    worlD”（实际上，他的程序正在处理莎士比亚的作品，所以一代演员最终会大声朗诵，“To eb or ton to eb, that si the noitseuq...”）。这是可以很容易避免的意外副作用，只要遵循单向输入、单向输出的原则。
- en: Parallel Assignment
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行赋值
- en: I mentioned earlier that it is possible for a method to return multiple values,
    separated by commas. Often you will want to assign these returned values to a
    set of matching variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，一个方法可以返回多个值，这些值通过逗号分隔。通常，你希望将这些返回的值分配给一组匹配的变量。
- en: 'In Ruby, you can do this in a single operation by parallel assignment. This
    means you can have several variables to the left or an assignment operator and
    several values to the right. The values to the right will be assigned, in order,
    to the variables on the left, like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，你可以通过并行赋值在单个操作中完成这个操作。这意味着你可以有多个左侧变量或赋值运算符，以及多个右侧值。右侧的值将按顺序分配给左侧的变量，如下所示：
- en: '*parallel_assign.rb*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*parallel_assign.rb*'
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This ability not only gives you a shortcut way to make multiple assignments;
    it also lets you swap the values of variables (you just change their orders on
    either side of the assignment operator):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力不仅为你提供了快速进行多次赋值的方法；它还允许你交换变量的值（你只需改变赋值运算符两侧的顺序）：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And you can make multiple assignments from the values returned by a method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从方法返回的值中进行多次赋值：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you specify more variables to the left than there are values on the right
    of an assignment, any “trailing” variables will be assigned `nil`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定赋值号右侧的值比左侧的变量多，任何“剩余”的变量将被赋值为`nil`：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Multiple values returned by a method are put into an array. When you put an
    array to the right of a multiple-variable assignment, its individual elements
    will be assigned to each variable, and once again if too many variables are supplied,
    the extra ones will be assigned `nil`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 方法返回的多个值被放入一个数组中。当你将数组放在多个变量赋值的右侧时，其各个元素将被分配给每个变量，并且如果提供的变量太多，额外的变量将被分配`nil`：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Digging Deeper
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: In this section we look at some of the inner workings of parameter-passing and
    object equality. I also discuss the value of parentheses for code clarity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了一些参数传递和对象相等性的内部工作原理。我还讨论了括号对于代码清晰性的价值。
- en: By Reference or By Value?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用还是通过值？
- en: Earlier, I said that Ruby does not make a distinction between arguments that
    are passed “by value” and “by reference.” Even so, if you search the Internet,
    you’ll soon discover that Ruby programmers often get into arguments about how
    exactly arguments are passed. In many procedural programming languages such as
    Pascal or C, there is a clear distinction between arguments passed by value or
    by reference.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我说过，Ruby在“通过值”传递的参数和“通过引用”传递的参数之间没有区别。即便如此，如果你在互联网上搜索，很快就会发现Ruby程序员经常就参数的确切传递方式发生争论。在许多过程式编程语言，如Pascal或C中，传递值或引用的参数之间存在明显的区别。
- en: A *by value* argument is a *copy* of the original variable; you can pass it
    to a function and mess around with it, and the value of the original variable
    remains unchanged.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: “通过值”的参数是原始变量的“副本”；你可以将它传递给一个函数并对其进行操作，而原始变量的值保持不变。
- en: A *by reference* argument, on the other hand, is a *pointer* to the original
    variable. When this gets passed to a procedure, you are not passing a new copy
    but a reference to the bit of memory in which the original data is stored. So,
    any changes made inside the procedure are made to the original data and necessarily
    affect the value of the original variable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，“通过引用”的参数是原始变量的“指针”。当这个指针传递给一个过程时，你传递的不是一个新的副本，而是指向存储原始数据的内存块的引用。因此，在过程中所做的任何更改都会影响原始数据，并必然影响原始变量的值。
- en: So, which way does Ruby pass arguments? It’s actually pretty easy to resolve
    this issue. If Ruby passes by value, then it makes a copy of the original variable,
    and that copy will therefore have a different `object_id`. In fact, this is not
    the case. Try the *arg_passing.rb* program to prove this point.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Ruby是以哪种方式传递参数的呢？实际上，解决这个问题非常简单。如果Ruby通过值传递，那么它会复制原始变量，因此这个副本将具有不同的`object_id`。实际上，情况并非如此。尝试运行`*arg_passing.rb*`程序来证明这一点。
- en: '*arg_passing.rb*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`*arg_passing.rb*`'
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This prints out the object IDs of an integer, a floating-point number, a string,
    and a custom object both when they are originally declared and when they are passed
    as arguments to the `aMethod()` method. In each case, the ID of the argument is
    the same as the ID of the original variable, so the arguments must be passed by
    reference.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在原始声明时以及将它们作为`aMethod()`方法的参数传递时，打印出整数、浮点数、字符串和自定义对象的`object_id`。在每种情况下，参数的ID与原始变量的ID相同，因此参数必须是通过引用传递的。
- en: Now, it may well be that in certain circumstances the passing of arguments could,
    “behind the scenes” so to speak, be *implemented* as “by value.” However, such
    implementation details should be of interest to writers of Ruby interpreters and
    compilers rather than to Ruby programmers. The plain fact of the matter is that
    if you program in a “pure” object-oriented way—by passing arguments into methods
    but only subsequently using the values that those methods return—the implementation
    details (by value or by reference) will be of no consequence to you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某种情况下，参数的传递可能“幕后”被“实现”为“通过值”。然而，这样的实现细节应该对Ruby解释器和编译器的编写者而不是Ruby程序员感兴趣。简单的事实是，如果你以“纯”面向对象的方式编程——通过将参数传递给方法，但只随后使用这些方法返回的值——那么实现细节（通过值或通过引用）对你来说将无关紧要。
- en: Nevertheless, because Ruby can occasionally modify arguments (for example, using
    `!` methods or `<<`, as explained in [Modifying Receivers and Yielding New Objects](ch08s08.html
    "Modifying Receivers and Yielding New Objects") in [Modifying Receivers and Yielding
    New Objects](ch08s08.html "Modifying Receivers and Yielding New Objects")), some
    programmers have formed the habit of using the modified values of the arguments
    themselves (equivalent to using by reference arguments in C) rather than using
    the values returned. In my view, this is a bad practice. It makes your programs
    reliant upon the implementation details of methods and should, therefore, be avoided.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，由于 Ruby 有时可以修改参数（例如，使用 `!` 方法或 `<<`，如 [修改接收者和返回新对象](ch08s08.html "修改接收者和返回新对象")
    中所述），一些程序员养成了使用参数自身修改后的值的习惯（相当于在 C 中使用按引用参数），而不是使用返回的值。在我看来，这是一种不良做法。它使你的程序依赖于方法的实现细节，因此应该避免。
- en: Are Assignments Copies or References?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作业是副本还是引用？
- en: 'I said earlier that a new object is created when a value is *yielded* by some
    expression. So, for example, if you assign a new value to a variable called `x`,
    the object after the assignment will be a different object from the one before
    the assignment (that is, it will have a different `object_id`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，当某个表达式 *yield* 一个值时，会创建一个新的对象。所以，例如，如果你将新值赋给一个名为 `x` 的变量，赋值后的对象将与赋值前的对象不同（即，它将具有不同的
    `object_id`）：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But it isn’t the assignment that creates a new object. It is the value that
    is yielded that causes a new object to be created. In the previous example, `+=1`
    is an expression that yields a value (`x+=1` is equivalent to the expression `x=x+1`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建新对象的不是赋值操作，而是产生的值。在上面的例子中，`+=1` 是一个产生值的表达式（`x+=1` 等价于表达式 `x=x+1`）。
- en: 'Simple assignment of one variable to another does not create a new object.
    So, let’s assume you have one variable called `num` and another called `num2`.
    If you assign `num2` to `num`, both variables will refer to the same object. You
    can test this using the `equal?` method of the Object class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将一个变量的值赋给另一个变量不会创建一个新的对象。所以，假设你有一个名为 `num` 的变量和另一个名为 `num2` 的变量。如果你将 `num2`
    赋值给 `num`，这两个变量将引用同一个对象。你可以使用 Object 类的 `equal?` 方法来测试这一点：
- en: '*assign_ref.rb*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*assign_ref.rb*'
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Tests for Equality: == or equal?'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性测试：== 还是 equal？
- en: 'By default (as defined in Ruby’s `Kernel` module), a test using `==` returns
    `true` when both objects being tested are the same object. So, it will return
    `false` if the values are the same but the objects are different:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下（如 Ruby 的 `Kernel` 模块中定义的），使用 `==` 进行测试，当被测试的两个对象是同一个对象时返回 `true`。因此，如果值相同但对象不同，则返回
    `false`：
- en: '*equal_tests.rb*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*equal_tests.rb*'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In fact, `==` is frequently overridden by classes such as String and will then
    return `true` when the values are the same but the objects are different:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`==` 经常被 String 等类覆盖，然后当值相同但对象不同时返回 `true`：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For that reason, the `equal?` method is preferable when you want to establish
    whether two variables refer to the same object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你想要确定两个变量是否引用同一个对象时，`equal?` 方法更可取：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When Are Two Objects Identical?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 何时两个对象是相同的？
- en: 'As a general rule, if you initialize 10 variables with 10 values, each variable
    will refer to a different object. For example, if you create two strings like
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，如果你用 10 个值初始化 10 个变量，每个变量将引用不同的对象。例如，如果你这样创建两个字符串：
- en: '*identical.rb*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*identical.rb*'
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'then `s1` and `s2` will refer to independent objects. The same goes for two
    floats:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `s1` 和 `s2` 将引用独立的对象。对于两个浮点数也是一样：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But, as mentioned earlier, integers are different. Create two integers with
    the same value, and they will end up referencing the same object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如前所述，整数是不同的。创建具有相同值的两个整数，它们最终会引用同一个对象：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is even true with literal integer values. If in doubt, use the `equals?`
    method to test whether two variables or values reference exactly the same object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至适用于字面整数值。如果有疑问，请使用 `equals?` 方法来测试两个变量或值是否引用了完全相同的对象：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Parentheses Avoid Ambiguity
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 括号避免歧义
- en: 'Methods may share the same name as local variables. For example, you might
    have a variable called `name` and a method called `name`. If it is your habit
    to call methods without parentheses, it may not be obvious whether you are referring
    to a method or a variable. Once again, parentheses avoid ambiguity:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可能与局部变量有相同的名称。例如，你可能有一个名为 `name` 的变量和一个名为 `name` 的方法。如果你习惯于不带括号调用方法，那么可能不清楚你是在指方法还是变量。再次强调，括号可以避免歧义：
- en: '*parentheses.rb*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*parentheses.rb*'
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
