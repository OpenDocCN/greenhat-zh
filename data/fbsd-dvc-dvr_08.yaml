- en: Chapter 8. Interrupt Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 中断处理
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1137497.png.jpg)'
- en: Hardware devices often have to perform (or deal with) external events, such
    as spinning disk platters, winding tapes, waiting for I/O, and so on. Most of
    these external events occur in a timeframe that is much slower than the processor’s—that
    is, if the processor were to wait for the completion (or arrival) of these events,
    it would be idle for some time. To avoid wasting the processor’s valuable time,
    interrupts are employed. An *interrupt* is simply a signal that a hardware device
    can send when it wants the processor’s attention (Corbet et al., 2005). For the
    most part, a driver only needs to register a handler function to service its device’s
    interrupts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件设备通常必须执行（或处理）外部事件，例如旋转磁盘盘片、卷带、等待 I/O 等。这些外部事件发生的时间框架通常比处理器的慢得多——也就是说，如果处理器等待这些事件的完成（或到达），它将空闲一段时间。为了避免浪费处理器的宝贵时间，使用了中断。*中断*简单地说是一个硬件设备在需要处理器注意时可以发送的信号（Corbet
    et al., 2005）。在大多数情况下，驱动程序只需要注册一个处理程序函数来处理其设备的中断。
- en: Registering an Interrupt Handler
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册中断处理程序
- en: 'The following functions, declared in `<sys/bus.h>`, register or tear down an
    interrupt handler:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数，在 `<sys/bus.h>` 中声明，用于注册或拆除中断处理程序：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `bus_setup_intr` function registers an interrupt handler with an IRQ. This
    IRQ must be allocated beforehand with `bus_alloc_resource`, as described in [Hardware
    Resource Management](ch07s03.html "Hardware Resource Management") in [Don’t Panic](ch07s02.html#donat_panic-id6
    "Don’t Panic").
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_setup_intr` 函数使用中断请求（IRQ）注册一个中断处理程序。此IRQ必须先通过 `bus_alloc_resource` 分配，如《Don’t
    Panic》中的[硬件资源管理](ch07s03.html "Hardware Resource Management")中所述。'
- en: The `bus_setup_intr` function is normally called during `device_attach`. The
    arguments for this function are described in the next few paragraphs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_setup_intr` 函数通常在 `device_attach` 期间被调用。此函数的参数将在接下来的几段中描述。'
- en: The `dev` argument is the device whose interrupts are to be handled. This device
    must have an IRQ.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev` 参数是要处理中断的设备。此设备必须有一个中断请求（IRQ）。'
- en: The `r` argument demands the return value from the successful `bus_alloc_resource`
    call that assigned an IRQ for `dev`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 参数要求从成功调用的 `bus_alloc_resource` 返回值中获取返回值，该调用为 `dev` 分配了一个中断请求。'
- en: The `flags` argument classifies the interrupt handler and/or the interrupt.
    Valid values for this argument are defined in the `intr_type` enumeration, found
    in `<sys/bus.h>`. [Table 8-1](ch08.html#bus_underscore_setup_underscore_intr_sym
    "Table 8-1. bus_setup_intr Symbolic Constants") describes the more commonly used
    values.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 参数对中断处理程序和/或中断进行分类。此参数的有效值在 `<sys/bus.h>` 中的 `intr_type` 枚举中定义。[表8-1](ch08.html#bus_underscore_setup_underscore_intr_sym
    "表8-1. `bus_setup_intr` 符号常量")描述了更常用的值。'
- en: Table 8-1. bus_setup_intr Symbolic Constants
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1. `bus_setup_intr` 符号常量
- en: '| Constant | Description |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `INTR_MPSAFE` | Indicates that the interrupt handler is multiprocessor safe
    and does not need to be protected by `Giant`—that is, any race conditions are
    to be handled by the interrupt handler itself; contemporary code should always
    pass this flag |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `INTR_MPSAFE` | 表示中断处理程序是多处理器安全的，并且不需要由 `Giant` 保护——也就是说，任何竞争条件都应该由中断处理程序本身处理；当代代码应始终传递此标志
    |'
- en: '| `INTR_ENTROPY` | Indicates that the interrupt is a good source of entropy
    and may be employed by the entropy device `/dev/random` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `INTR_ENTROPY` | 表示中断是一个良好的熵源，并且可能被熵设备 `/dev/random` 使用 |'
- en: The `filter` and `ithread` arguments specify the filter and ithread routines
    for the interrupt handler. For now, don’t worry about these arguments; I’ll discuss
    them in the following section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 和 `ithread` 参数指定中断处理程序的过滤和ithread例程。现在，不要担心这些参数；我将在下一节中讨论它们。'
- en: The `arg` argument is the sole argument that gets passed to the interrupt handler.
    Generally, you’ll always set `arg` to `dev`’s software context.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg` 参数是传递给中断处理程序的唯一参数。通常，您会始终将 `arg` 设置为 `dev` 的软件上下文。'
- en: The `cookiep` argument expects a pointer to void *. If `bus_setup_intr` is successful,
    a cookie is returned in `cookiep`; this cookie is needed to destroy the interrupt
    handler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookiep` 参数期望一个指向 `void *` 的指针。如果 `bus_setup_intr` 成功，则在 `cookiep` 中返回一个cookie；此cookie用于销毁中断处理程序。'
- en: As you would expect, the `bus_teardown_intr` function tears down an interrupt
    handler.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，`bus_teardown_intr` 函数会拆除一个中断处理程序。
- en: Interrupt Handlers in FreeBSD
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeBSD中的中断处理程序
- en: Now that you know how to register an interrupt handler, let’s discuss how interrupt
    handlers are implemented.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何注册中断处理程序，让我们讨论中断处理程序是如何实现的。
- en: In FreeBSD, interrupt handlers are composed of a filter routine, an ithread
    routine, or both. A *filter routine* executes in primary interrupt context (that
    is, it does not have its own context). Thus, it cannot block or context switch,
    and it can use only spin mutexes for synchronization. Due to these constraints,
    filter routines are typically used only with devices that require a nonpreemptive
    interrupt handler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FreeBSD 中，中断处理程序由一个过滤例程、一个 ithread 例程或两者组成。*过滤例程* 在主要中断上下文中执行（即，它没有自己的上下文）。因此，它不能阻塞或进行上下文切换，并且只能使用自旋互斥锁进行同步。由于这些限制，过滤例程通常只用于需要非抢占式中断处理程序的设备。
- en: A filter routine may either completely handle an interrupt or defer the computationally
    expensive work to its associated ithread routine, assuming it has one. [Table 8-2](ch08s02.html#filter_routine_return_values
    "Table 8-2. Filter Routine Return Values") details the values that a filter routine
    can return.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤例程可以完全处理中断，或者将计算密集型的工作推迟到其关联的 ithread 例程中，前提是它有一个。 [表 8-2](ch08s02.html#filter_routine_return_values
    "表 8-2. 过滤例程返回值") 详细说明了过滤例程可以返回的值。
- en: Table 8-2. Filter Routine Return Values
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2. 过滤例程返回值
- en: '| Constant | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FILTER_STRAY` | Indicates that the filter routine can’t handle this interrupt;
    this value is equivalent to an error code. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_STRAY` | 表示过滤例程无法处理此中断；此值等同于错误代码。 |'
- en: '| `FILTER_HANDLED` | Indicates that the interrupt has been completely handled;
    this value is equivalent to a success code. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_HANDLED` | 表示中断已被完全处理；此值等同于成功代码。 |'
- en: '| `FILTER_SCHEDULE_THREAD` | Schedules the ithread routine to execute; this
    value can be returned if and only if the filter routine has an associated ithread
    routine. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_SCHEDULE_THREAD` | 安排 ithread 例程执行；只有当过滤例程有一个关联的 ithread 例程时，才能返回此值。
    |'
- en: An *ithread routine*, unlike a filter routine, executes in its own thread context.
    You can do whatever you want in an ithread routine, except voluntarily context
    switch (that is, sleep) or wait on a condition variable. Because filter routines
    are nonpreemptive, most interrupt handlers in FreeBSD are just ithread routines.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与过滤例程不同，*ithread 例程* 在其自己的线程上下文中执行。你可以在 ithread 例程中做任何你想做的事情，除了自愿进行上下文切换（即休眠）或等待条件变量。因为过滤例程是非抢占式的，FreeBSD
    中的大多数中断处理程序只是 ithread 例程。
- en: Implementing an Interrupt Handler
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现中断处理程序
- en: '[Example 8-1](ch08s03.html#pint.c "Example 8-1. pint.c") is a contrived Newbus
    driver designed to demonstrate interrupt handlers. [Example 8-1](ch08s03.html#pint.c
    "Example 8-1. pint.c") sets up an interrupt handler on the parallel port; on read,
    it sleeps until it receives an interrupt.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](ch08s03.html#pint.c "示例 8-1. pint.c") 是一个设计用来演示中断处理程序的新旧总线驱动程序。[示例
    8-1](ch08s03.html#pint.c "示例 8-1. pint.c") 在并行端口上设置了一个中断处理程序；在读取时，它会休眠直到接收到中断。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take a quick look at this code and try to discern some of its structure. If
    you don’t understand all of it, don’t worry; an explanation follows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 快速看一下这段代码，并尝试辨别其结构。如果你不完全理解它，不要担心；解释将随后提供。
- en: Example 8-1. pint.c
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-1. pint.c
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To make things easier to understand, I’ll describe the functions in [Example 8-1](ch08s03.html#pint.c
    "Example 8-1. pint.c") in the order they were written, instead of in the order
    they appear. To that end, I’ll begin with the `pint_identify` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更容易理解，我将按照它们编写的顺序描述 [示例 8-1](ch08s03.html#pint.c "示例 8-1. pint.c") 中的函数，而不是它们出现的顺序。为此，我将从
    `pint_identify` 函数开始。
- en: pint_identify Function
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_identify 函数
- en: The `pint_identify` function is the `device_identify` implementation for this
    driver. Logically, this function is required because the parallel port cannot
    identify its children unaided.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_identify` 函数是这个驱动程序的 `device_identify` 实现方式。从逻辑上讲，这个函数是必需的，因为并行端口无法在没有辅助的情况下识别其子设备。'
- en: 'Here is the function definition for `pint_identify` (again):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `pint_identify` 函数的定义（再次）：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) determines
    whether the parallel port has (ever) identified a child device named ![](httpatomoreillycomsourcenostarchimages1137501.png)
    `PINT_NAME`. If it has not, then `pint_identify` ![](httpatomoreillycomsourcenostarchimages1137503.png)
    adds `PINT_NAME` to the parallel port’s list of identified children.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先![图片](http://atomoreilly.com/source/nostarch/images/1137499.png)确定并行端口是否曾经识别了一个名为![图片](http://atomoreilly.com/source/nostarch/images/1137501.png)`PINT_NAME`的子设备。如果没有，那么`pint_identify`![图片](http://atomoreilly.com/source/nostarch/images/1137503.png)会将`PINT_NAME`添加到并行端口的已识别子设备列表中。
- en: pint_probe Function
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_probe 函数
- en: 'The `pint_probe` function is the `device_probe` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_probe`函数是此驱动程序的`device_probe`实现。以下是它的函数定义（再次）：'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this function always ![](httpatomoreillycomsourcenostarchimages1137499.png)
    returns the success code `BUS_PROBE_SPECIFIC`, so [Example 8-1](ch08s03.html#pint.c
    "Example 8-1. pint.c") attaches to every device it probes. This may seem erroneous,
    but it is the correct behavior, as devices identified by a `device_identify` routine,
    using `BUS_ADD_CHILD`, are probed only by drivers with the same name. In this
    case, the identified device and driver name is `PINT_NAME`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此函数始终![图片](http://atomoreilly.com/source/nostarch/images/1137499.png)返回成功代码`BUS_PROBE_SPECIFIC`，因此[示例
    8-1](ch08s03.html#pint.c "示例 8-1. pint.c")会连接到它所探测到的每个设备。这看起来可能有些错误，但实际上是正确的行为，因为通过`device_identify`例程、使用`BUS_ADD_CHILD`识别的设备，只有具有相同名称的驱动程序才会进行探测。在这种情况下，识别的设备和驱动程序名称是`PINT_NAME`。
- en: pint_attach Function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_attach 函数
- en: 'The `pint_attach` function is the `device_attach` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_attach`函数是此驱动程序的`device_attach`实现。以下是它的函数定义（再次）：'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function first ![](httpatomoreillycomsourcenostarchimages1137499.png)
    allocates an IRQ. If unsuccessful, the error code `ENXIO` (which stands for *error:
    device not configured*) is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    returned. Next, the ![](httpatomoreillycomsourcenostarchimages1137505.png) `pint_intr`
    function is ![](httpatomoreillycomsourcenostarchimages1137503.png) set up as the
    interrupt handler for `dev` (in this case, the interrupt handler is just an ithread
    routine). Afterward, a buffer of `BUFFER_SIZE` bytes is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    allocated. Then `sc->sc_device` is ![](httpatomoreillycomsourcenostarchimages1137509.png)
    set to `dev`, [Example 8-1](ch08s03.html#pint.c "Example 8-1. pint.c")’s character
    device node is ![](httpatomoreillycomsourcenostarchimages1137511.png) created,
    and a pointer to the software context (`sc`) is ![](httpatomoreillycomsourcenostarchimages1137513.png)
    saved in `sc->sc_cdev->si_drv1`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先![图片](http://atomoreilly.com/source/nostarch/images/1137499.png)分配一个IRQ。如果失败，则返回错误代码`ENXIO`（代表*错误：设备未配置*）。接下来，![图片](http://atomoreilly.com/source/nostarch/images/1137501.png)`pint_intr`函数被![图片](http://atomoreilly.com/source/nostarch/images/1137503.png)设置为`dev`（在这种情况下，中断处理程序只是一个ithread例程）的中断处理程序。之后，分配一个`BUFFER_SIZE`字节的缓冲区。然后`sc->sc_device`被![图片](http://atomoreilly.com/source/nostarch/images/1137509.png)设置为`dev`，[示例
    8-1](ch08s03.html#pint.c "示例 8-1. pint.c")的字符设备节点![图片](http://atomoreilly.com/source/nostarch/images/1137511.png)被创建，并且软件上下文(`sc`)的指针![图片](http://atomoreilly.com/source/nostarch/images/1137513.png)被保存在`sc->sc_cdev->si_drv1`中。
- en: pint_detach Function
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_detach 函数
- en: 'The `pint_detach` function is the `device_detach` implementation for this driver.
    Here is its function definition (again):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_detach`函数是此驱动程序的`device_detach`实现。以下是它的函数定义（再次）：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function starts by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    destroying [Example 8-1](ch08s03.html#pint.c "Example 8-1. pint.c")’s device node.
    Once this is done, it ![](httpatomoreillycomsourcenostarchimages1137501.png) tears
    down `dev`’s interrupt handler, ![](httpatomoreillycomsourcenostarchimages1137503.png)
    releases `dev`’s IRQ, and ![](httpatomoreillycomsourcenostarchimages1137505.png)
    frees the allocated memory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先![图片](http://atomoreilly.com/source/nostarch/images/1137499.png)销毁[示例 8-1](ch08s03.html#pint.c
    "示例 8-1. pint.c")的设备节点。一旦完成，它![图片](http://atomoreilly.com/source/nostarch/images/1137501.png)拆除了`dev`的中断处理程序，![图片](http://atomoreilly.com/source/nostarch/images/1137503.png)释放了`dev`的IRQ，并且![图片](http://atomoreilly.com/source/nostarch/images/1137505.png)释放了分配的内存。
- en: pint_open Function
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_open 函数
- en: The `pint_open` function is defined in `pint_cdevsw` (that is, [Example 8-1](ch08s03.html#pint.c
    "Example 8-1. pint.c")’s character device switch table) as the `d_open` operation.
    Recall that `d_open` operations prepare the device for I/O.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_open`函数定义在`pint_cdevsw`（即[示例 8-1](ch08s03.html#pint.c "示例 8-1. pint.c")的字符设备切换表中）作为`d_open`操作。回想一下，`d_open`操作准备设备进行I/O。'
- en: 'Here is the function definition for `pint_open` (again):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`pint_open`函数的定义（再次）：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) acquires
    the parallel port mutex. Then the value of `sc->sc_state` is ![](httpatomoreillycomsourcenostarchimages1137501.png)
    examined. If it does not equal 0, which indicates that another process has opened
    the device, the error code `EBUSY` is ![](httpatomoreillycomsourcenostarchimages1137503.png)
    returned; otherwise, `pint_open` ![](httpatomoreillycomsourcenostarchimages1137505.png)
    “opens” the device. Opening the device, in this case, means setting `sc->sc_state`
    to `PINT_OPEN`. Afterward, the `ppb_request_bus` function is ![](httpatomoreillycomsourcenostarchimages1137507.png)
    called to mark `pint_device` as the owner of the parallel port. Naturally, `pint_device`
    is our device (that is, it points to dev from `pint_attach`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先获取并行端口的互斥锁。然后检查`sc->sc_state`的值。如果它不等于0，这表示另一个进程已经打开了设备，将返回错误代码`EBUSY`；否则，`pint_open`“打开”设备。在这种情况下，打开设备意味着将`sc->sc_state`设置为`PINT_OPEN`。之后，调用`ppb_request_bus`函数将`pint_device`标记为并行端口的拥有者。自然地，`pint_device`是我们的设备（即，它从`pint_attach`指向dev）。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Owning the parallel port lets a device transfer data to and from it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有并行端口允许设备在它之间传输数据。
- en: Finally, before ![](httpatomoreillycomsourcenostarchimages1137511.png) enabling
    interrupts, `pint_open` ![](httpatomoreillycomsourcenostarchimages1137509.png)
    clears the parallel port’s control register.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在启用中断之前，`pint_open`清除并行端口的控制寄存器。
- en: pint_close Function
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_close 函数
- en: 'The `pint_close` function is defined in `pint_cdevsw` as the `d_close` operation.
    Here is its function definition (again):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_close`函数在`pint_cdevsw`中被定义为`d_close`操作。以下是它的函数定义（再次）：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This function first ![](httpatomoreillycomsourcenostarchimages1137499.png) acquires
    the parallel port mutex. Then interrupts on the parallel port are ![](httpatomoreillycomsourcenostarchimages1137501.png)
    disabled (for all intents and purposes, clearing the control register, which is
    what the above code does, disables interrupts). Next, the `ppb_release_bus` function
    is ![](httpatomoreillycomsourcenostarchimages1137503.png) called to relinquish
    ownership of the parallel port. Finally, `sc->sc_state` is ![](httpatomoreillycomsourcenostarchimages1137505.png)
    zeroed, so that another process can open this device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先获取并行端口的互斥锁。然后禁用并行端口上的中断（从所有目的来看，清除控制寄存器，这就是上面代码所做的事情，禁用中断）。接下来，调用`ppb_release_bus`函数来放弃对并行端口的控制权。最后，将`sc->sc_state`清零，以便另一个进程可以打开这个设备。
- en: pint_write Function
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_write 函数
- en: The `pint_write` function is defined in `pint_cdevsw` as the `d_write` operation.
    This function acquires a character string from user space and stores it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_write`函数在`pint_cdevsw`中被定义为`d_write`操作。这个函数从用户空间获取一个字符字符串并将其存储。'
- en: 'Here is the function definition for `pint_write` (again):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`pint_write`函数的定义（再次）：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function is fundamentally identical to the `echo_write` function described
    in [echo_write Function](ch03s03.html#echo_underscore_write_function-id1 "echo_write
    Function"). Consequently, I won’t walk through it again here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与在[echo_write 函数](ch03s03.html#_echo_underscore_write_function-id1 "echo_write
    函数")中描述的`echo_write`函数在本质上完全相同。因此，我这里不再重复介绍。
- en: pint_read Function
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_read 函数
- en: The `pint_read` function is defined in `pint_cdevsw` as the `d_read` operation.
    This function sleeps on entry. It also returns the stored character string to
    user space.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_read`函数在`pint_cdevsw`中被定义为`d_read`操作。这个函数在进入时会睡眠。它也会将存储的字符字符串返回到用户空间。'
- en: 'Here is the function definition for `pint_read` (again):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`pint_read`函数的定义（再次）：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function begins by ![](httpatomoreillycomsourcenostarchimages1137499.png)
    acquiring the parallel port mutex. Then it ![](httpatomoreillycomsourcenostarchimages1137501.png)
    sleeps on the channel ![](httpatomoreillycomsourcenostarchimages1137503.png) `pint_device`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先获取并行端口的互斥锁。然后它在`pint_device`通道上睡眠。![图片](httpatomoreillycomsourcenostarchimages1137499.png)
    然后在通道![图片](httpatomoreillycomsourcenostarchimages1137501.png)上睡眠。![图片](httpatomoreillycomsourcenostarchimages1137503.png)
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ppb_sleep` function releases the parallel port mutex before sleeping. Of
    course, it also reacquires the parallel port mutex before returning to its caller.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ppb_sleep` 函数在休眠之前释放并行端口互斥锁。当然，在返回调用者之前，它也会重新获取并行端口互斥锁。'
- en: The remnants of this function are basically identical to the `echo_read` function
    described in [echo_read Function](ch01s06.html#echo_underscore_read_function "echo_read
    Function"), so we won’t discuss them again here.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的残留部分基本上与 [echo_read 函数](ch01s06.html#_echo_underscore_read_function "echo_read
    函数") 中描述的 `echo_read` 函数相同，所以我们在这里不再讨论它们。
- en: pint_intr Function
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pint_intr 函数
- en: 'The `pint_intr` function is the interrupt handler for [Example 8-1](ch08s03.html#pint.c
    "Example 8-1. pint.c"). Here is its function definition (again):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pint_intr` 函数是 [示例 8-1](ch08s03.html#pint.c "示例 8-1. pint.c") 的中断处理程序。以下是它的函数定义（再次）：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this function simply ![](httpatomoreillycomsourcenostarchimages1137499.png)
    wakes up every thread sleeping on `pint_device`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个函数只是 ![](http://atomoreilly.com/source/no_starch_images/1137499.png)
    唤醒在 `pint_device` 上休眠的每个线程。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Parallel port interrupt handlers are unique, because they get invoked with the
    parallel port mutex already held. Conversely, normal interrupt handlers need to
    explicitly acquire their own locks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并行端口的中断处理程序是独特的，因为它们在获取并行端口互斥锁的情况下被调用。相反，正常的中断处理程序需要显式获取它们自己的锁。
- en: Don’t Panic
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要慌张
- en: 'Now that we’ve walked through [Example 8-1](ch08s03.html#pint.c "Example 8-1. pint.c"),
    let’s give it a try:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经走过了 [示例 8-1](ch08s03.html#pint.c "示例 8-1. pint.c")，让我们试一试：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Apparently it works. But how do we generate an interrupt to test our interrupt
    handler?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 显然它工作得很好。但我们如何生成一个中断来测试我们的中断处理程序？
- en: Generating Interrupts on the Parallel Port
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行端口上生成中断
- en: Once interrupts are enabled, the parallel port generates an interrupt whenever
    the electrical signal at pin 10, dubbed the *ACK bit*, changes from low to high
    (Corbet et al., 2005).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用中断，当引脚10的电信号，被称为 *ACK 位*，从低电平变为高电平时，并行端口会生成一个中断（Corbet 等人，2005年）。
- en: To toggle the electrical signal at pin 10, I connected pin 10 to pin 9 (using
    a resistor) and then I executed the program shown in [Example 8-2](ch08s04.html#tint.c
    "Example 8-2. tint.c").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换引脚10的电信号，我将引脚10连接到引脚9（使用一个电阻），然后执行 [示例 8-2](ch08s04.html#tint.c "示例 8-2.
    tint.c") 中显示的程序。
- en: Example 8-2. tint.c
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-2. tint.c
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, ![](httpatomoreillycomsourcenostarchimages1137499.png) `BASE_ADDRESS`
    denotes the base address of the parallel port. On most contemporary PCs, `0x378`
    is the base address of the parallel port. However, you can check your machine’s
    BIOS to be sure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，![](http://atomoreilly.com/source/no_starch_images/1137499.png) `BASE_ADDRESS`
    表示并行端口的基址。在大多数现代个人计算机上，`0x378` 是并行端口的基址。但是，您可以通过检查机器的 BIOS 来确保这一点。
- en: This program changes the electrical signal at pin 9 of the parallel port from
    ![](httpatomoreillycomsourcenostarchimages1137501.png) low to ![](httpatomoreillycomsourcenostarchimages1137503.png)
    high.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将并行端口引脚9的电信号从 ![http://atomoreilly.com/source/no_starch_images/1137501.png](http://atomoreilly.com/source/no_starch_images/1137501.png)
    低电平变为 ![http://atomoreilly.com/source/no_starch_images/1137503.png](http://atomoreilly.com/source/no_starch_images/1137503.png)
    高电平。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re curious, pin 9 is the most significant bit of the parallel data byte
    (Corbet et al., 2005).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，引脚9是并行数据字节的最重要位（Corbet 等人，2005年）。
- en: 'Here are the results from executing [Example 8-2](ch08s04.html#tint.c "Example 8-2. tint.c"):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是执行 [示例 8-2](ch08s04.html#tint.c "示例 8-2. tint.c") 的结果：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Conclusion
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'This chapter focused primarily on implementing an interrupt handler. In [Chapter 9](ch09.html
    "Chapter 9. Case Study: Parallel Port Printer Driver"), we’ll build upon the concepts
    and code described here to write a nontrivial, interrupt-driven driver.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注实现中断处理程序。在 [第 9 章](ch09.html "第 9 章. 案例研究：并行端口打印机驱动程序") 中，我们将基于这里描述的概念和代码编写一个非平凡的、中断驱动的驱动程序。
