- en: Chapter 0x500. SHELLCODE
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第0x500章。脚本代码
- en: So far, the shellcode used in our exploits has been just a string of copied
    and pasted bytes. We have seen standard shell-spawning shellcode for local exploits
    and port-binding shellcode for remote ones. Shellcode is also sometimes referred
    to as an exploit payload, since these self-contained programs do the real work
    once a program has been hacked. Shellcode usually spawns a shell, as that is an
    elegant way to hand off control; but it can do anything a program can do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们攻击中使用的脚本代码只是一串复制粘贴的字节。我们看到了用于本地攻击的标准shell启动脚本代码和用于远程攻击的端口绑定脚本代码。脚本代码有时也被称为攻击有效载荷，因为这些自包含的程序在程序被黑客攻击后执行实际工作。脚本代码通常启动一个shell，因为这是一种优雅的控制权移交方式；但它可以做任何程序能做的事情。
- en: Unfortunately, for many hackers the shellcode story stops at copying and pasting
    bytes. These hackers are just scratching the surface of what's possible. Custom
    shellcode gives you absolute control over the exploited program. Perhaps you want
    your shellcode to add an admin account to /etc/passwd or to automatically remove
    lines from log files. Once you know how to write your own shellcode, your exploits
    are limited only by your imagination. In addition, writing shellcode develops
    assembly language skills and employs a number of hacking techniques worth knowing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于许多黑客来说，脚本故事在复制粘贴字节的地方就结束了。这些黑客只是触及了可能性的表面。定制的脚本代码让你对被利用的程序有绝对的控制权。也许你希望你的脚本代码向
    /etc/passwd 添加管理员账户，或者自动从日志文件中删除行。一旦你学会了如何编写自己的脚本代码，你的攻击手段就只受你的想象力限制了。此外，编写脚本代码可以培养汇编语言技能，并运用许多值得了解的攻击技术。
- en: Assembly vs. C
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编与C
- en: The shellcode bytes are actually architecture-specific machine instructions,
    so shellcode is written using the assembly language. Writing a program in assembly
    is different than writing it in C, but many of the principles are similar. The
    operating system manages things like input, output, process control, file access,
    and network communication in the kernel. Compiled C programs ultimately perform
    these tasks by making system calls to the kernel. Different operating systems
    have different sets of system calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本字节实际上是特定架构的机器指令，因此脚本是用汇编语言编写的。在汇编语言中编写程序与在C语言中编写不同，但许多原则是相似的。操作系统在内核中管理诸如输入、输出、进程控制、文件访问和网络通信等事务。编译后的C程序最终通过向内核发出系统调用来执行这些任务。不同的操作系统有不同的系统调用集。
- en: In C, standard libraries are used for convenience and portability. A C program
    that uses `printf()` to output a string can be compiled for many different systems,
    since the library knows the appropriate system calls for various architectures.
    A C program compiled on an *x*86 processor will produce *x*86 assembly language.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，标准库用于方便和可移植性。一个使用 `printf()` 输出字符串的C程序可以编译成许多不同的系统，因为库知道各种架构的适当系统调用。在
    *x*86 处理器上编译的C程序将产生 *x*86汇编语言。
- en: By definition, assembly language is already specific to a certain processor
    architecture, so portability is impossible. There are no standard libraries; instead,
    kernel system calls have to be made directly. To begin our comparison, let's write
    a simple C program, then rewrite it in *x*86 assembly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，汇编语言已经针对特定的处理器架构进行了特定化，因此不可移植。没有标准库；相反，必须直接调用内核系统调用。为了开始我们的比较，让我们先写一个简单的C程序，然后将其重写为
    *x*86汇编。
- en: Assembly vs. C
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编与C
- en: helloworld.c
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helloworld.c
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the compiled program is run, execution flows through the standard I/O library,
    eventually making a system call to write the string *Hello, world!* to the screen.
    The strace program is used to trace a program's system calls. Used on the compiled
    helloworld program, it shows every system call that program makes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译后的程序运行时，执行流程会通过标准I/O库，最终通过系统调用将字符串 *Hello, world!* 写入屏幕。strace程序用于跟踪程序的系统调用。在编译好的helloworld程序上使用它，它会显示该程序做出的每一个系统调用。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the compiled program does more than just print a string. The
    system calls at the start are setting up the environment and memory for the program,
    but the important part is the `write()` syscall shown in bold. This is what actually
    outputs the string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译后的程序不仅仅是打印一个字符串。开始处的系统调用是在设置程序的环境和内存，但重要的是显示在粗体中的 `write()` 系统调用。这正是实际输出字符串的地方。
- en: 'The Unix manual pages (accessed with the `man` command) are separated into
    sections. Section 2 contains the manual pages for system calls, so `man 2 write`
    will describe the use of the `write()` system call:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 手册页（通过 `man` 命令访问）分为几个部分。第 2 节包含系统调用手册页，因此 `man 2 write` 将描述 `write()`
    系统调用的用法：
- en: Man Page for the write() System Call
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`write()` 系统调用手册页'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The strace output also shows the arguments for the syscall. The `buf`and `count`
    arguments are a pointer to our string and its length. The `fd` argument of `1`
    is a special standard file descriptor. File descriptors are used for almost everything
    in Unix: input, output, file access, network sockets, and so on. A file descriptor
    is similar to a number given out at a coat check. Opening a file descriptor is
    like checking in your coat, since you are given a number that can later be used
    to reference your coat. The first three file descriptor numbers (0, 1, and 2)
    are automatically used for standard input, output, and error. These values are
    standard and have been defined in several places, such as the /usr/include/unistd.h
    file on the following page.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: strace 输出还显示了系统调用的参数。`buf` 和 `count` 参数是指向我们的字符串及其长度的指针。`fd` 参数的 `1` 是一个特殊的标准文件描述符。文件描述符在
    Unix 中用于几乎所有事情：输入、输出、文件访问、网络套接字等。文件描述符类似于在衣帽间领取的号码。打开文件描述符就像登记你的大衣，因为你得到了一个可以后来用来引用你的大衣的号码。前三个文件描述符号码（0、1
    和 2）自动用于标准输入、输出和错误。这些值是标准的，并在多个地方定义过，例如在下一页的 `/usr/include/unistd.h` 文件中。
- en: From /usr/include/unistd.h
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 /usr/include/unistd.h
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing bytes to standard output's file descriptor of `1` will print the bytes;
    reading from standard input's file descriptor of `0` will input bytes. The standard
    error file descriptor of `2` is used to display the error or debugging messages
    that can be filtered from the standard output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节写入标准输出的文件描述符 `1` 将打印字节；从标准输入的文件描述符 `0` 读取将输入字节。标准错误文件描述符 `2` 用于显示可以从标准输出过滤的错误或调试消息。
- en: Linux System Calls in Assembly
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 系统调用汇编
- en: Every possible Linux system call is enumerated, so they can be referenced by
    numbers when making the calls in assembly. These syscalls are listed in /usr/include/asm-i386/unistd.h.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了所有可能的 Linux 系统调用，以便在汇编调用时可以通过数字引用它们。这些系统调用在 `/usr/include/asm-i386/unistd.h`
    中列出。
- en: From /usr/include/asm-i386/unistd.h
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 /usr/include/asm-i386/unistd.h
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For our rewrite of helloworld.c in assembly, we will make a system call to
    the `write()` function for the output and then a second system call to `exit()`
    so the process quits cleanly. This can be done in *x*86 assembly using just two
    assembly instructions: `mov` and `int`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们用汇编重写的 `helloworld.c`，我们将对 `write()` 函数进行系统调用以输出，然后对 `exit()` 函数进行第二次系统调用，以便进程干净地退出。这可以在
    *x*86 汇编中使用仅两个汇编指令来完成：`mov` 和 `int`。
- en: Assembly instructions for the *x*86 processor have one, two, three, or no operands.
    The operands to an instruction can be numerical values, memory addresses, or processor
    registers. The *x*86 processor has several 32-bit registers that can be viewed
    as hardware variables. The registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP
    can all be used as operands, while the EIP register (execution pointer) cannot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*86 处理器的汇编指令有一个、两个、三个或没有操作数。指令的操作数可以是数值、内存地址或处理器寄存器。*x*86 处理器有几个 32 位寄存器，可以视为硬件变量。EAX、EBX、ECX、EDX、ESI、EDI、EBP
    和 ESP 寄存器都可以用作操作数，而 EIP 寄存器（执行指针）不能。'
- en: The `mov` instruction copies a value between its two operands. Using Intel assembly
    syntax, the first operand is the destination and the second is the source. The
    `int` instruction sends an interrupt signal to the kernel, defined by its single
    operand. With the Linux kernel, interrupt `0x80` is used to tell the kernel to
    make a system call. When the `int 0x80` instruction is executed, the kernel will
    make a system call based on the first four registers. The EAX register is used
    to specify which system call to make, while the EBX, ECX, and EDX registers are
    used to hold the first, second, and third arguments to the system call. All of
    these registers can be set using the `mov` instruction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令在两个操作数之间复制一个值。使用英特尔汇编语法，第一个操作数是目标，第二个是源。`int` 指令向内核发送一个中断信号，由其单个操作数定义。在
    Linux 内核中，中断 `0x80` 用于告诉内核执行系统调用。当执行 `int 0x80` 指令时，内核将根据前四个寄存器执行系统调用。EAX 寄存器用于指定要执行哪个系统调用，而
    EBX、ECX 和 EDX 寄存器用于保存系统调用的第一个、第二个和第三个参数。所有这些寄存器都可以使用 `mov` 指令设置。'
- en: In the following assembly code listing, the memory segments are simply declared.
    The string `"Hello, world!"` with a newline character (`0x0a`) is in the data
    segment, and the actual assembly instructions are in the text segment. This follows
    proper memory segmentation practices.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的汇编代码列表中，内存段被简单地声明。带有换行符（`0x0a`）的字符串`"Hello, world!"`在数据段中，实际的汇编指令在文本段中。这遵循了正确的内存分段实践。
- en: helloworld.asm
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helloworld.asm
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The instructions of this program are straight forward. For the `write()` syscall
    to standard output, the value of `4` is put in EAX since the `write()` function
    is system call number 4\. Then, the value of `1` is put into EBX, since the first
    argument of `write()` should be the file descriptor for standard output. Next,
    the address of the string in the data segment is put into ECX, and the length
    of the string (in this case, 14 bytes) is put into EDX. After these registers
    are loaded, the system call interrupt is triggered, which will call the `write()`
    function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的说明非常直接。对于写入标准输出的`write()`系统调用，将`4`的值放入EAX，因为`write()`函数是系统调用号4。然后，将`1`的值放入EBX，因为`write()`的第一个参数应该是标准输出的文件描述符。接下来，将数据段中字符串的地址放入ECX，并将字符串的长度（在这种情况下，14个字节）放入EDX。在这些寄存器被加载后，触发系统调用中断，这将调用`write()`函数。
- en: To exit cleanly, the `exit()` function needs to be called with a single argument
    of `0`. So the value of `1` is put into EAX, since `exit()` is system call number
    1, and the value of `0` is put into EBX, since the first and only argument should
    be 0\. Then the system call interrupt is triggered again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了干净地退出，需要用单个参数`0`调用`exit()`函数。因此，将`1`的值放入EAX，因为`exit()`是系统调用号1，将`0`的值放入EBX，因为第一个且唯一的参数应该是0。然后再次触发系统调用中断。
- en: To create an executable binary, this assembly code must first be assembled and
    then linked into an executable format. When compiling C code, the GCC compiler
    takes care of all of this automatically. We are going to create an executable
    and linking format (ELF) binary, so the `global _start` line shows the linker
    where the assembly instructions begin.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可执行二进制文件，这个汇编代码必须首先被汇编，然后链接成可执行格式。当编译C代码时，GCC编译器会自动处理所有这些。我们将创建一个可执行和链接格式（ELF）的二进制文件，所以`global
    _start`行告诉链接器汇编指令的开始位置。
- en: The `nasm` assembler with the `-f elf` argument will assemble the helloworld.asm
    into an object file ready to be linked as an ELF binary. By default, this object
    file will be called helloworld.o. The linker program ld will produce an executable
    a.out binary from the assembled object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-f elf`参数的`nasm`汇编器将`helloworld.asm`汇编成一个准备链接为ELF二进制的目标文件。默认情况下，这个目标文件将被称为`helloworld.o`。链接程序ld将从汇编的目标文件生成可执行的`a.out`二进制文件。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This tiny program works, but it's not shellcode, since it isn't self-contained
    and must be linked.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序可以工作，但它不是shellcode，因为它不是自包含的，必须进行链接。
- en: The Path to Shellcode
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到Shellcode的路径
- en: Shellcode is literally injected into a running program, where it takes over
    like a biological virus inside a cell. Since shellcode isn't really an executable
    program, we don't have the luxury of declaring the layout of data in memory or
    even using other memory segments. Our instructions must be self-contained and
    ready to take over control of the processor regardless of its current state. This
    is commonly referred to as position-independent code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode实际上是注入到一个正在运行的程序中，就像生物病毒在细胞内一样接管。由于shellcode实际上不是一个可执行程序，我们没有声明内存中数据布局或使用其他内存段的便利。我们的指令必须是自包含的，并且准备好无论处理器的当前状态如何都能接管处理器控制。这通常被称为位置无关代码。
- en: In shellcode, the bytes for the string `"Hello, world!"` must be mixed together
    with the bytes for the assembly instructions, since there aren't definable or
    predictable memory segments. This is fine as long as EIP doesn't try to interpret
    the string as instructions. However, to access the string as data we need a pointer
    to it. When the shellcode gets executed, it could be anywhere in memory. The string's
    absolute memory address needs to be calculated relative to EIP. Since EIP cannot
    be accessed from assembly instructions, however, we need to use some sort of trick.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在shellcode中，字符串`"Hello, world!"`的字节必须与汇编指令的字节混合在一起，因为不存在可定义或可预测的内存段。只要EIP不尝试将字符串解释为指令，这就可以了。然而，为了将字符串作为数据访问，我们需要一个指向它的指针。当shellcode被执行时，它可能在内存中的任何位置。需要计算字符串的绝对内存地址，相对于EIP。然而，由于EIP不能从汇编指令中访问，因此我们需要使用某种技巧。
- en: Assembly Instructions Using the Stack
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用堆栈的汇编指令
- en: The stack is so integral to the *x*86 architecture that there are special instructions
    for its operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 栈对于*x*86架构来说是如此重要，以至于有专门的指令用于其操作。
- en: '| Instruction | Description |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `push <source>` | Push the source operand to the stack. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `push <source>` | 将源操作数压入栈中。|'
- en: '| `pop <destination>` | Pop a value from the stack and store in the destination
    operand. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `pop <destination>` | 从栈中弹出一个值并将其存储在目标操作数中。|'
- en: '| `call <location>` | Call a function, jumping the execution to the address
    in the location operand. This location can be relative or absolute. The address
    of the instruvtion following the call is pushed to the stack, so that execution
    can return later. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `call <location>` | 调用一个函数，将执行跳转到位置操作数中的地址。这个位置可以是相对的或绝对的。调用之后的指令地址被压入栈中，以便稍后执行返回。|'
- en: '| `ret` | Return from a function, popping the return address from the stack
    and jumping execution there. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `ret` | 从函数返回，从栈中弹出返回地址并跳转到那里执行。|'
- en: Stack-based exploits are made possible by the `call` and `ret` instructions.
    When a function is called, the return address of the next instruction is pushed
    to the stack, beginning the stack frame. After the function is finished, the `ret`instruction
    pops the return address from the stack and jumps EIP back there. By overwriting
    the stored return address on the stack before the `ret` instruction, we can take
    control of a program's execution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于栈的漏洞利用是由`call`和`ret`指令实现的。当一个函数被调用时，下一条指令的返回地址被压入栈中，开始栈帧。函数执行完毕后，`ret`指令从栈中弹出返回地址并跳转EIP回到那里。通过在`ret`指令之前覆盖存储在栈上的返回地址，我们可以控制程序的执行。
- en: This architecture can be misused in another way to solve the problem of addressing
    the inline string data. If the string is placed directly after a call instruction,
    the address of the string will get pushed to the stack as the return address.
    Instead of calling a function, we can jump past the string to a `pop`instruction
    that will take the address off the stack and into a register. The following assembly
    instructions demonstrate this technique.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构可以通过另一种方式被滥用来解决内联字符串数据寻址的问题。如果字符串直接放置在调用指令之后，字符串的地址将作为返回地址被压入栈中。而不是调用一个函数，我们可以跳过字符串到一个`pop`指令，该指令将从栈中取出地址并放入寄存器。下面的汇编指令展示了这种技术。
- en: helloworld1.s
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helloworld1.s
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The call instruction jumps execution down below the string. This also pushes
    the address of the next instruction to the stack, the next instruction in our
    case being the beginning of the string. The return address can immediately be
    popped from the stack into the appropriate register. Without using any memory
    segments, these raw instructions, injected into an existing process, will execute
    in a completely position-independent way. This means that, when these instructions
    are assembled, they cannot be linked into an executable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用指令将执行跳转到字符串下方。这也将下一条指令的地址压入栈中，在我们的例子中是字符串的开始。返回地址可以立即从栈中弹出并放入适当的寄存器。不使用任何内存段，这些原始指令注入到现有进程中将以完全位置无关的方式执行。这意味着，当这些指令被汇编时，它们不能被链接到可执行文件中。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `nasm` assembler converts assembly language into machine code and a corresponding
    tool called ndisasm converts machine code into assembly. These tools are used
    above to show the relationship between the machine code bytes and the assembly
    instructions. The disassembly instructions marked in bold are the bytes of the
    `"Hello, world!"` string interpreted as instructions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`nasm`汇编器将汇编语言转换为机器代码，一个相应的工具ndisasm将机器代码转换为汇编。这些工具在上文中用于显示机器代码字节和汇编指令之间的关系。加粗的解汇编指令是将`"Hello,
    world!"`字符串解释为指令的字节。'
- en: Now, if we can inject this shellcode into a program and redirect EIP, the program
    will print out *Hello, world!* Let's use the familiar exploit target of the notesearch
    program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们能将这个shellcode注入到一个程序中并重定向EIP，程序将打印出*Hello, world!*让我们使用笔记搜索程序的熟悉漏洞目标。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Failure. Why do you think it crashed? In situations like this, GDB is your best
    friend. Even if you already know the reason behind this specific crash, learning
    how to effectively use a debugger will help you solve many other problems in the
    future.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 失败。你认为它为什么会崩溃？在这种情况下，GDB是你的最佳朋友。即使你已经知道这次崩溃背后的原因，学习如何有效地使用调试器将有助于你解决未来的许多其他问题。
- en: Investigating with GDB
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GDB进行调试
- en: Since the notesearch program runs as root, we can't debug it as a normal user.
    However, we also can't just attach to a running copy of it, because it exits too
    quickly. Another way to debug programs is with core dumps. From a root prompt,
    the OS can be told to dump memory when the program crashes by using the command
    `ulimit -c unlimited`. This means that dumped core files are allowed to get as
    big as needed. Now, when the program crashes, the memory will be dumped to disk
    as a core file, which can be examined using GDB.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 notesearch 程序以 root 身份运行，我们无法以普通用户身份对其进行调试。然而，我们也不能直接附加到正在运行的副本上，因为它退出得太快了。另一种调试程序的方法是使用核心转储。从
    root 提示符开始，可以使用命令 `ulimit -c unlimited` 告诉操作系统在程序崩溃时转储内存。这意味着转储的核心文件可以变得任意大。现在，当程序崩溃时，内存将作为核心文件转储到磁盘上，可以使用
    GDB 进行检查。
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once GDB is loaded, the disassembly style is switched to Intel. Since we are
    running GDB as root, the .gdbinit file won't be used. The memory where the shellcode
    should be is examined. The instructions look incorrect, but it seems like the
    first incorrect call instruction is what caused the crash. At least, execution
    was redirected, but something went wrong with the shellcode bytes. Normally, strings
    are terminated by a null byte, but here, the shell was kind enough to remove these
    null bytes for us. This, however, totally destroys the meaning of the machine
    code. Often, shellcode will be injected into a process as a string, using functions
    like `strcpy()`. Such functions will simply terminate at the first null byte,
    producing incomplete and unusable shellcode in memory. In order for the shellcode
    to survive transit, it must be redesigned so it doesn't contain any null bytes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载 GDB，反汇编风格将切换到 Intel 格式。由于我们以 root 身份运行 GDB，因此不会使用 .gdbinit 文件。将检查放置 shellcode
    的内存。指令看起来不正确，但似乎第一个错误的调用指令导致了崩溃。至少，执行被重定向了，但 shellcode 字节出了问题。通常，字符串以空字节结尾，但这里，shell
    仁慈地为我们移除了这些空字节。然而，这完全破坏了机器代码的意义。通常，shellcode 会作为字符串注入到进程，使用像 `strcpy()` 这样的函数。这样的函数会在第一个空字节处终止，产生不完整且不可用的
    shellcode。为了使 shellcode 能够在传输过程中存活，它必须被重新设计，以确保不包含任何空字节。
- en: Removing Null Bytes
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除空字节
- en: Looking at the disassembly, it is obvious that the first null bytes come from
    the `call` instruction.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 查看反汇编代码，很明显，第一个空字节来自 `call` 指令。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This instruction jumps execution forward by 19 (`0x13`) bytes, based on the
    first operand. The `call` instruction allows for much longer jump distances, which
    means that a small value like 19 will have to be padded with leading zeros resulting
    in null bytes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令根据第一个操作数将执行跳转前进了 19 (`0x13`) 个字节。`call` 指令允许更长的跳转距离，这意味着像 19 这样的小值需要用前导零填充，从而产生空字节。
- en: 'One way around this problem takes advantage of two''s complement. A small negative
    number will have its leading bits turned on, resulting in `0xff`bytes. This means
    that, if we call using a negative value to move backward in execution, the machine
    code for that instruction won''t have any null bytes. The following revision of
    the helloworld shellcode uses a standard implementation of this trick: Jump to
    the end of the shellcode to a call instruction which, in turn, will jump back
    to a pop instruction at the beginning of the shellcode.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是利用二进制补码。一个小负数将它的前导位设置为 1，从而得到 `0xff` 字节。这意味着，如果我们使用负值来向后移动执行，该指令的机器代码将不会包含任何空字节。以下
    helloworld shellcode 的修订版本使用了这种技巧的标准实现：跳转到 shellcode 的末尾到一个调用指令，然后该调用指令会跳转回 shellcode
    开头的 pop 指令。
- en: helloworld2.s
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helloworld2.s
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After assembling this new shellcode, disassembly shows that the call instruction
    (shown in italics below) is now free of null bytes. This solves the first and
    most difficult null-byte problem for this shellcode, but there are still many
    other null bytes (shown in bold).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装这个新的 shellcode 之后，反汇编显示，调用指令（如下所示，用斜体表示）现在没有空字节了。这解决了这个 shellcode 的第一个也是最难解决的问题，但仍然有许多其他的空字节（如下所示，用粗体表示）。
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These remaining null bytes can be eliminated with an understanding of register
    widths and addressing. Notice that the first `jmp` instruction is actually `jmp
    short`. This means execution can only jump a maximum of approximately 128 bytes
    in either direction. The normal `jmp` instruction, as well as the call instruction
    (which has no short version), allows for much longer jumps. The difference between
    assembled machine code for the two jump varieties is shown below:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些剩余的空字节可以通过理解寄存器宽度和寻址来消除。注意，第一个`jmp`指令实际上是`jmp short`。这意味着执行只能向上或向下跳转最多约128个字节。正常的`jmp`指令以及调用指令（没有短版本），允许进行更长的跳转。两种跳转类型的汇编代码差异如下所示：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: versus
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP registers are 32 bits in width.
    The *E* stands for *extended*, because these were originally 16-bit registers
    called AX, BX, CX, DX, SI, DI, BP, and SP. These original 16-bit versions of the
    registers can still be used for accessing the first 16 bits of each corresponding
    32-bit register. Furthermore, the individual bytes of the AX, BX, CX, and DX registers
    can be accessed as 8-bit registers called AL, AH, BL, BH, CL, CH, DL, and DH,
    where *L* stands for *low byte* and *H* for *high byte*. Naturally, assembly instructions
    using the smaller registers only need to specify operands up to the register's
    bit width. The three variations of a `mov` instruction are shown below.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP寄存器都是32位宽。*E*代表*扩展*，因为这些最初是16位寄存器，称为AX、BX、CX、DX、SI、DI、BP和SP。这些原始的16位寄存器版本仍然可以用来访问每个相应32位寄存器的第一个16位。此外，AX、BX、CX和DX寄存器的各个字节可以作为8位寄存器访问，称为AL、AH、BL、BH、CL、CH、DL和DH，其中*L*代表*低字节*，*H*代表*高字节*。自然地，只使用较小寄存器的汇编指令只需要指定到寄存器位宽度的操作数。下面显示了`mov`指令的三种变体。
- en: '| Machine code | Assembly |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 机代码 | 汇编 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `B8 04 00 00 00` | `mov eax,0x4` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `B8 04 00 00 00` | `mov eax,0x4` |'
- en: '| `66 B8 04 00` | `mov ax,0x4` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `66 B8 04 00` | `mov ax,0x4` |'
- en: '| `B0 04` | `mov al,0x4` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `B0 04` | `mov al,0x4` |'
- en: Using the AL, BL, CL, or DL register will put the correct least significant
    byte into the corresponding extended register without creating any null bytes
    in the machine code. However, the top three bytes of the register could still
    contain anything. This is especially true for shellcode, since it will be taking
    over another process. If we want the 32-bit register values to be correct, we
    need to zero out the entire register before the `mov` instructions—but this, again,
    must be done without using null bytes. Here are some more simple assembly instructions
    for your arsenal. These first two are small instructions that increment and decrement
    their operand by one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AL、BL、CL或DL寄存器可以将正确的最低有效字节放入相应的扩展寄存器中，而不会在机器代码中创建任何空字节。然而，寄存器的最高三个字节可能包含任何内容。这对于shellcode尤其如此，因为它将接管另一个进程。如果我们想使32位寄存器值正确，我们需要在`mov`指令之前将整个寄存器清零——但这，同样，不能使用空字节。以下是一些额外的简单汇编指令，供您使用。这些前两个是小的指令，它们将它们的操作数增加或减少1。
- en: '| Instruction | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `inc <target>` | Increment the target operand by adding 1 to it. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `inc <target>` | 将目标操作数增加1。|'
- en: '| `dec <target>` | Decrement the target operand by subtracting 1 from it. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `dec <target>` | 从目标操作数中减去1。|'
- en: The next few instructions, like the `mov` instruction, have two operands. They
    all do simple arithmetic and bitwise logical operations between the two operands,
    storing the result in the first operand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几条指令，如`mov`指令，有两个操作数。它们都在两个操作数之间执行简单的算术和位逻辑运算，并将结果存储在第一个操作数中。
- en: '| Instruction | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add <dest>, <source>` | Add the source operand to the destination operand,
    storing the result in the destination. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `add <dest>, <source>` | 将源操作数加到目的操作数上，并将结果存储在目的操作数中。|'
- en: '| `sub <dest>, <source>` | Subtract the source operand from the destination
    operand, storing the result in the destination. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `sub <dest>, <source>` | 从目的操作数中减去源操作数，并将结果存储在目的操作数中。|'
- en: '| `or <dest>, <source>` | Perform a bitwise `or` logic operation, comparing
    each bit of one operand with the corresponding bit of the other operand.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| `or <dest>, <source>` | 执行位或逻辑运算，比较一个操作数的每个位与另一个操作数对应位的比较。|'
- en: '&#124; 1 or 0 = 1 &#124;'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 0 = 1 |'
- en: '&#124; 1 or 1 = 1 &#124;'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 1 = 1 |'
- en: '&#124; 0 or 1 = 1 &#124;'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 1 = 1 |'
- en: '&#124; 0 or 0 = 0 &#124;'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 0 = 0 |'
- en: If the source bit or the destination bit is on, or if both of them are on, the
    result bit is on; otherwise, the result is off. The final result is stored in
    the destination operand. |
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源位或目标位打开，或者两者都打开，结果位打开；否则，结果关闭。最终结果存储在目标操作数中。|
- en: '| `and <dest>, <source>` | Perform a bitwise `and` logic operation, comparing
    each bit of one operand with the corresponding bit of the other operand.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| `and <dest>, <source>` | 执行位运算逻辑操作，比较一个操作数的每个位与另一个操作数的对应位。'
- en: '&#124; 1 or 0 = 0 &#124;'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 0 = 0 | '
- en: '&#124; 1 or 1 = 1 &#124;'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 1 = 1 | '
- en: '&#124; 0 or 1 = 0 &#124;'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 1 = 0 | '
- en: '&#124; 0 or 0 = 0 &#124;'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 0 = 0 | '
- en: The result bit is on only if both the source bit and the destination bit are
    on. The final result is stored in the destination operand. |
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当源位和目标位都打开时，结果位才打开。最终结果存储在目标操作数中。|
- en: '| `xor <dest>, <source>` | Perform a bitwise exclusive `or (xor)` logical operation,
    comparing each bit of one operand with the corresponding bit of the other operand.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| `xor <dest>, <source>` | 执行位运算排他或（xor）逻辑操作，比较一个操作数的每个位与另一个操作数的对应位。'
- en: '&#124; 1 or 0 = 1 &#124;'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 0 = 1 | '
- en: '&#124; 1 or 1 = 0 &#124;'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 或 1 = 0 | '
- en: '&#124; 0 or 1 = 1 &#124;'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 1 = 1 | '
- en: '&#124; 0 or 0 = 0 &#124;'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0 或 0 = 0 | '
- en: If the bits differ, the result bit is on; if the bits are the same, the result
    bit is off. The final result is stored in the destination operand. |
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位不同，结果位打开；如果位相同，结果位关闭。最终结果存储在目标操作数中。|
- en: 'One method is to move an arbitrary 32-bit number into the register and then
    subtract that value from the register using the `mov` and `sub` instructions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将一个任意的32位数字移入寄存器，然后使用`mov`和`sub`指令从这个寄存器中减去该值：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While this technique works, it takes 10 bytes to zero out a single register,
    making the assembled shellcode larger than necessary. Can you think of a way to
    optimize this technique? The DWORD value specified in each instruction comprises
    80 percent of the code. Subtracting any value from itself also produces 0 and
    doesn''t require any static data. This can be done with a single two-byte instruction:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个技术可行，但清零单个寄存器需要10个字节，使得汇编的shellcode比必要的更大。你能想到优化这个技术的方法吗？每个指令中指定的DWORD值占代码的80%。从任何值中减去该值也会产生0，并且不需要任何静态数据。这可以用一个单字节指令完成：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the `sub` instruction will work fine when zeroing registers at the beginning
    of shellcode. This instruction will modify processor flags, which are used for
    branching, however. For that reason, there is a preferred two-byte instruction
    that is used to zero registers in most shellcode. The `xor` instruction performs
    an e`x` clusive `or` operation on the bits in a register. Since 1 `xor` ed with
    1 results in a 0, and 0 `xor`ed with 0 results in a 0, any value `xor` ed with
    itself will result in 0\. This is the same result as with any value subtracted
    from itself, but the `xor` instruction doesn't modify processor flags, so it's
    considered to be a cleaner method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在shellcode开始时清零寄存器时，使用`sub`指令将工作良好。然而，这个指令会修改处理器标志，这些标志用于分支。因此，有一个首选的双字节指令，在大多数shellcode中用于清零寄存器。`xor`指令在寄存器的位上执行一个排他或（xor）操作。由于1
    `xor` 1的结果是0，0 `xor` 0的结果也是0，任何与自身`xor`的值都将得到0。这与从自身减去任何值得到的结果相同，但`xor`指令不会修改处理器标志，因此被认为是一种更干净的方法。
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can safely use the `sub` instruction to zero registers (if done at the beginning
    of the shellcode), but the `xor` instruction is most commonly used in shellcode
    in the wild. This next revision of the shellcode makes use of the smaller registers
    and the `xor` instruction to avoid null bytes. The `inc` and `dec`instructions
    have also been used when possible to make for even smaller shellcode.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地使用`sub`指令来清零寄存器（如果是在shellcode的开始处执行），但`xor`指令在野外的shellcode中最为常用。这个shellcode的下一个版本利用了较小的寄存器和`xor`指令来避免空字节。在可能的情况下，也使用了`inc`和`dec`指令，以使shellcode更小。
- en: helloworld3.s
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: helloworld3.s
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After assembling this shellcode, hexdump and grep are used to quickly check
    it for null bytes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编这个shellcode之后，使用hexdump和grep来快速检查它是否有空字节。
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now this shellcode is usable, as it doesn't contain any null bytes. When used
    with an exploit, the notesearch program is coerced into greeting the world like
    a newbie.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个shellcode可以使用了，因为它不包含任何空字节。当与漏洞利用程序一起使用时，notesearch程序被强制以新手的身份问候世界。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Shell-Spawning Shellcode
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell-Spawning Shellcode
- en: Now that you've learned how to make system calls and avoid null bytes, all sorts
    of shellcodes can be constructed. To spawn a shell, we just need to make a system
    call to execute the /bin/sh shell program. System call number 11, `execve()`,
    is similar to the C `execute()` function that we used in the previous chapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何进行系统调用并避免空字节，可以构建各种shellcode。要启动一个shell，我们只需要调用系统调用来执行/bin/sh shell程序。系统调用号11，`execve()`，与我们在前几章中使用的C语言`execute()`函数类似。
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first argument of the filename should be a pointer to the string `"/bin/sh"`,
    since this is what we want to execute. The environment array— the third argument—can
    be empty, but it still need to be terminated with a 32-bit null pointer. The argument
    array—the second argument—must be nullterminated, too; it must also contain the
    string pointer (since the zeroth argument is the name of the running program).
    Done in C, a program making this call would look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名的前一个参数应该是字符串`"/bin/sh"`的指针，因为这是我们想要执行的。环境数组（第三个参数）可以空，但仍需要以32位空指针结尾。参数数组（第二个参数）也必须是null终止的；它还必须包含字符串指针（因为零参数是正在运行的程序的名字）。在C中完成这个调用，程序看起来会是这样：
- en: Shell-Spawning Shellcode
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell启动Shellcode
- en: exec_shell.c
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec_shell.c
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To do this in assembly, the argument and environment arrays need to be built
    in memory. In addition, the `"/bin/sh"` string needs to be terminated with a null
    byte. This must be built in memory as well. Dealing with memory in assembly is
    similar to using pointers in C. The `lea` instruction, whose name stands for *load
    effective address*, works like the `address-of` operator in C.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编中做这件事，需要在内存中构建参数数组和环境数组。此外，`"/bin/sh"`字符串需要以空字节结尾。这也必须在内存中构建。在汇编中处理内存类似于在C中使用指针。`lea`指令，其名称代表*加载有效地址*，在C中类似于`address-of`运算符。
- en: '| Instruction | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `lea <dest>, <source>` | Load the effective address of the source operand
    into the destination operand. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `lea <dest>, <source>` | 将源操作数的有效地址加载到目标操作数。|'
- en: With Intel assembly syntax, operands can be dereferenced as pointers if they
    are surrounded by square brackets. For example, the following instruction in assembly
    will treat EBX+12 as a pointer and write `eax` to where it's pointing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Intel汇编语法，如果操作数被方括号包围，则可以作为指针解引用。例如，汇编中的以下指令将把EBX+12作为指针处理，并将`eax`写入它所指向的位置。
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following shellcode uses these new instructions to build the `execve()`
    arguments in memory. The environment array is collapsed into the end of the argument
    array, so they share the same 32-bit null terminator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shellcode使用这些新指令在内存中构建`execve()`参数。环境数组被折叠到参数数组的末尾，因此它们共享同一个32位空终止符。
- en: exec_shell.s
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec_shell.s
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After terminating the string and building the arrays, the shellcode uses the
    `lea` instruction (shown in bold above) to put a pointer to the argument array
    into the ECX register. Loading the effective address of a bracketed register added
    to a value is an efficient way to add the value to the register and store the
    result in another register. In the example above, the brackets dereference EBX+8
    as the argument to `lea`, which loads that address into EDX. Loading the address
    of a dereferenced pointer produces the original pointer, so this instruction puts
    EBX+8 into EDX. Normally, this would require both a `mov` and an `add` instruction.
    When assembled, this shellcode is devoid of null bytes. It will spawn a shell
    when used in an exploit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在终止字符串并构建数组之后，shellcode使用`lea`指令（如上所示加粗）将参数数组的指针放入ECX寄存器。将一个加值后的括号寄存器的有效地址加载是一个高效地将值加到寄存器并将结果存储在另一个寄存器中的方法。在上面的例子中，括号将EBX+8作为`lea`的参数，将这个地址加载到EDX。加载一个解引用指针的地址会产生原始指针，因此这个指令将EBX+8放入EDX。通常，这需要`mov`和`add`指令。当汇编时，这个shellcode不包含空字节。当用于漏洞利用时，它将启动一个shell。
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This shellcode, however, can be shortened to less than the current 45 bytes.
    Since shellcode needs to be injected into program memory somewhere, smaller shellcode
    can be used in tighter exploit situations with smaller usable buffers. The smaller
    the shellcode, the more situations it can be used in. Obviously, the `XAAAABBBB`
    visual aid can be trimmed from the end of the string, which brings the shellcode
    down to 36 bytes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个shellcode可以缩短到当前45字节以下。由于shellcode需要注入到程序内存的某个地方，较小的shellcode可以在更紧凑的利用情况下使用较小的可用缓冲区。shellcode越小，可以使用的场景就越多。显然，可以从字符串末尾剪掉`XAAAABBBB`这种视觉辅助工具，将shellcode缩短到36字节。
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shellcode can be shrunk down further by redesigning it and using registers
    more efficiently. The ESP register is the stack pointer, pointing to the top of
    the stack. When a value is pushed to the stack, ESP is moved up in memory (by
    subtracting 4) and the value is placed at the top of the stack. When a value is
    popped from the stack, the pointer in ESP is moved down in memory (by adding 4).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shellcode可以通过重新设计并更有效地使用寄存器来进一步缩小。ESP寄存器是栈指针，指向栈顶。当值被推入栈时，ESP在内存中向上移动（通过减去4），值被放置在栈顶。当值从栈中弹出时，ESP中的指针在内存中向下移动（通过加上4）。
- en: The following shellcode uses `push` instructions to build the necessary structures
    in memory for the `execve()` system call.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shellcode使用`push`指令在内存中构建`execve()`系统调用所需的必要结构。
- en: tiny_shell.s
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tiny_shell.s
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This shellcode builds the null-terminated string `"/bin//sh"` on the stack,
    and then copies ESP for the pointer. The extra backslash doesn't matter and is
    effectively ignored. The same method is used to build the arrays for the remaining
    arguments. The resulting shellcode still spawns a shell but is only 25 bytes,
    compared to 36 bytes using the `jmp` call method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shellcode在栈上构建了以null结尾的字符串`"/bin//sh"`，然后复制ESP作为指针。多余的反斜杠无关紧要，并且实际上会被忽略。同样的方法用于构建剩余参数的数组。结果shellcode仍然会启动一个shell，但只有25字节，而使用`jmp`调用方法则是36字节。
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A Matter of Privilege
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限问题
- en: To help mitigate rampant privilege escalation, some privileged processes will
    lower their effective privileges while doing things that don't require that kind
    of access. This can be done with the `seteuid()` function, which will set the
    effective user ID. By changing the effective user ID, the privileges of the process
    can be changed. The manual page for the `seteuid()` function is shown below.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助缓解权限提升的泛滥，一些特权进程在执行不需要那种访问权限的事情时，会降低其有效权限。这可以通过`seteuid()`函数来完成，该函数将设置有效用户ID。通过更改有效用户ID，可以改变进程的权限。`seteuid()`函数的手册页如下所示。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function is used by the following code to drop privileges down to those
    of the "games" user before the vulnerable `strcpy()` call.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在以下代码中用于在调用有漏洞的`strcpy()`之前将权限降低到“games”用户。
- en: drop_privs.c
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: drop_privs.c
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Even though this compiled program is setuid root, the privileges are dropped
    to the games user before the shellcode can execute. This only spawns a shell for
    the games user, without root access.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个编译后的程序被设置为root的setuid，但在shellcode执行之前，权限被降低到games用户。这只为games用户启动了一个shell，而没有root访问权限。
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Fortunately, the privileges can easily be restored at the beginning of our shellcode
    with a system call to set the privileges back to root. The most complete way to
    do this is with a `setresuid()` system call, which sets the real, effective, and
    saved user IDs. The system call number and manual page are shown below.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在shellcode的开始处通过系统调用来恢复权限，将权限设置回root。最完整的方法是使用`setresuid()`系统调用来设置真实、有效和保存的用户ID。系统调用号和手册页如下所示。
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The following shellcode makes a call to `setresuid()` before spawning the shell
    to restore root privileges.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shellcode在启动shell之前调用`setresuid()`来恢复root权限。
- en: priv_shell.s
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: priv_shell.s
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This way, even if a program is running under lowered privileges when it's exploited,
    the shellcode can restore the privileges. This effect is demonstrated below by
    exploiting the same program with dropped privileges.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使程序在利用时以降低的权限运行，shellcode也可以恢复权限。以下通过以降低的权限利用相同的程序来演示这种效果。
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And Smaller Still
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更小了
- en: A few more bytes can still be shaved off this shellcode. There is a single-byte
    *x*86 instruction called `cdq`, which stands for *convert doubleword to quadword*.
    Instead of using operands, this instruction always gets its source from the EAX
    register and stores the results between the EDX and EAX registers. Since the registers
    are 32-bit doublewords, it takes two registers to store a 64-bit quadword. The
    conversion is simply a matter of extending the sign bit from a 32-bit integer
    to 64-bit integer. Operationally, this means if the sign bit of EAX is `0`, the
    `cdq` instruction will zero the EDX register. Using `xor` to zero the EDX register
    requires two bytes; so, if EAX is already zeroed, using the `cdq` instruction
    to zero EDX will save one byte
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Shellcode还可以进一步减少几个字节。有一个单字节*x*86指令叫做`cdq`，代表*将双字转换为四字*。这个指令不使用操作数，总是从EAX寄存器获取源数据，并将结果存储在EDX和EAX寄存器之间。由于寄存器是32位双字，需要两个寄存器来存储64位四字。转换仅仅是将32位整数的符号位扩展到64位整数。从操作的角度来看，这意味着如果EAX的符号位是`0`，`cdq`指令将清零EDX寄存器。使用`xor`来清零EDX寄存器需要两个字节；所以，如果EAX已经是零，使用`cdq`指令来清零EDX将节省一个字节
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: compared to
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Another byte can be saved with clever use of the stack. Since the stack is 32-bit
    aligned, a single byte value pushed to the stack will be aligned as a doubleword.
    When this value is popped off, it will be sign-extended, filling the entire register.
    The instructions that push a single byte and pop it back into a register take
    three bytes, while using `xor` to zero the register and moving a single byte takes
    four bytes
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过巧妙地使用堆栈，还可以节省一个字节。由于堆栈是32位对齐的，向堆栈推送的单字节值将被对齐为双字。当这个值被弹出时，它将被符号扩展，填充整个寄存器。推送单个字节并将其弹回到寄存器的指令需要三个字节，而使用`xor`来清零寄存器和移动单个字节需要四个字节
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: compared to
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These tricks (shown in bold) are used in the following shellcode listing. This
    assembles into the same shellcode as that used in the previous chapters.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技巧（以粗体显示）在下面的Shellcode列表中使用。这些汇编成与上一章中使用的相同的Shellcode。
- en: shellcode.s
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shellcode.s
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The syntax for pushing a single byte requires the size to be declared. Valid
    sizes are `BYTE` for one byte, `WORD` for two bytes, and `DWORD` for four bytes.
    These sizes can be implied from register widths, so moving into the AL register
    implies the `BYTE` size. While it's not necessary to use a size in all situations,
    it doesn't hurt and can help readability.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 推送单个字节的语法需要声明大小。有效的大小有`BYTE`表示一个字节，`WORD`表示两个字节，`DWORD`表示四个字节。这些大小可以从寄存器宽度中推断出来，因此将数据移动到AL寄存器意味着`BYTE`大小。虽然不是所有情况下都需要使用大小，但这并不妨碍，并且可以帮助提高可读性。
- en: Port-Binding Shellcode
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口绑定Shellcode
- en: When exploiting a remote program, the shellcode we've designed so far won't
    work. The injected shellcode needs to communicate over the network to deliver
    an interactive root prompt. Port-binding shellcode will bind the shell to a network
    port where it listens for incoming connections. In the previous chapter, we used
    this kind of shellcode to exploit the tinyweb server. The following C code binds
    to port 31337 and listens for a TCP connection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当利用远程程序时，我们迄今为止设计的Shellcode将不起作用。注入的Shellcode需要通过网络进行通信以提供交互式root提示符。端口绑定Shellcode将Shell绑定到监听传入连接的网络端口。在上一章中，我们使用这种Shellcode来利用tinyweb服务器。下面的C代码绑定到端口31337并监听TCP连接。
- en: Port-Binding Shellcode
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口绑定Shellcode
- en: bind_port.c
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bind_port.c
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These familiar socket functions can all be accessed with a single Linux system
    call, aptly named `socketcall()`. This is syscall number 102, which has a slightly
    cryptic manual page.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些熟悉的套接字函数都可以通过单个Linux系统调用访问，这个系统调用被恰当地命名为`socketcall()`。这是系统调用号102，它的手册页有些晦涩。
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The possible call numbers for the first argument are listed in the linux/net.h
    include file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首个参数的可能调用号列在`linux/net.h`包含文件中。
- en: From /usr/include/linux/net.h
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 /usr/include/linux/net.h
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So, to make socket system calls using Linux, EAX is always 102 for `socketcall()`,
    EBX contains the type of socket call, and ECX is a pointer to the socket call's
    arguments. The calls are simple enough, but some of them require a `sockaddr`
    structure, which must be built by the shellcode. Debugging the compiled C code
    is the most direct way to look at this structure in memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使用Linux进行套接字系统调用，EAX总是`102`对于`socketcall()`，EBX包含套接字调用的类型，而ECX是指向套接字调用参数的指针。这些调用很简单，但其中一些需要`sockaddr`结构，这必须由Shellcode构建。通过调试编译的C代码是最直接查看这种结构在内存中的方法。
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first breakpoint is just before the socket call happens, since we need to
    check the values of `PF_INET` and `SOCK_STREAM`. All three arguments are pushed
    to the stack (but with `mov` instructions) in reverse order. This means `PF_INET`
    is `2` and `SOCK_STREAM` is `1`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断点发生在套接字调用之前，因为我们需要检查`PF_INET`和`SOCK_STREAM`的值。所有三个参数都是按相反顺序推入堆栈的（但使用`mov`指令）。这意味着`PF_INET`是`2`，`SOCK_STREAM`是`1`。
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next breakpoint happens after the `sockaddr` structure is filled with values.
    The debugger is smart enough to decode the elements of the structure when `host_addr`
    is printed, but now *you* need to be smart enough to realize the port is stored
    in network byte order. The `sin_family` and `sin_port` elements are both words,
    followed by the address as a `DWORD`. In this case, the address is `0`, which
    means any address can be used for binding. The remaining eight bytes after that
    are just extra space in the structure. The first eight bytes in the structure
    (shown in bold) contain all the important information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个断点发生在`sockaddr`结构体填充值之后。当打印`host_addr`时，调试器足够智能以解码结构体的元素，但现在你需要足够聪明，意识到端口号以网络字节序存储。`sin_family`和`sin_port`元素都是单词，后面跟着一个`DWORD`地址。在这种情况下，地址是`0`，这意味着可以使用任何地址进行绑定。之后的剩余八个字节只是结构体中的额外空间。结构体中的前八个字节（以粗体显示）包含所有重要信息。
- en: The following assembly instructions perform all the socket calls needed to bind
    to port 31337 and accept TCP connections. The `sockaddr` structure and the argument
    arrays are each created by pushing values in reverse order to the stack and then
    copying ESP into ECX. The last eight bytes of the `sockaddr` structure aren't
    actually pushed to the stack, since they aren't used. Whatever random eight bytes
    happen to be on the stack will occupy this space, which is fine.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下汇编指令执行了绑定到端口31337和接受TCP连接所需的全部套接字调用。`sockaddr`结构体和参数数组都是通过将值以相反顺序推入堆栈，然后将ESP复制到ECX中创建的。`sockaddr`结构体的最后八个字节实际上没有推入堆栈，因为它们没有被使用。堆栈上随机出现的八个字节将占据这个空间，这是可以的。
- en: bind_port.s
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bind_port.s
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When assembled and used in an exploit, this shellcode will bind to port 31337
    and wait for an incoming connection, blocking at the accept call. When a connection
    is accepted, the new socket file descriptor is put into EAX at the end of this
    code. This won't really be useful until it's combined with the shell-spawning
    code described earlier. Fortunately, standard file descriptors make this fusion
    remarkably simple.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇编并用于攻击时，此shellcode将绑定到端口31337并等待传入的连接，在`accept`调用处阻塞。当建立连接时，新的套接字文件描述符将放在此代码的EAX寄存器中。这实际上直到与前面描述的shell创建代码结合使用时才有用。幸运的是，标准文件描述符使得这种融合变得非常简单。
- en: Duplicating Standard File Descriptors
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制标准文件描述符
- en: Standard input, standard output, and standard error are the three standard file
    descriptors used by programs to perform standard I/O. Sockets, too, are just file
    descriptors that can be read from and written to. By simply swapping the standard
    input, output, and error of the spawned shell with the connected socket file descriptor,
    the shell will write output and errors to the socket and read its input from the
    bytes that the socket received. There is a system call specifically for duplicating
    file descriptors, called `dup2`. This is system call number 63.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入、标准输出和标准错误是程序执行标准输入输出所使用的三个标准文件描述符。套接字也是如此，它们是可以被读取和写入的文件描述符。通过简单地将创建的shell的输入、输出和错误标准文件描述符与连接的套接字文件描述符交换，shell就会将输出和错误写入套接字，并从套接字接收的字节中读取输入。有一个专门用于复制文件描述符的系统调用，称为`dup2`。这是系统调用编号63。
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The bind_port.s shellcode left off with the connected socket file descriptor
    in EAX. The following instructions are added in the file bind_shell_beta.s to
    duplicate this socket into the standard I/O file descriptors; then, the tiny_shell
    instructions are called to execute a shell in the current process. The spawned
    shell's standard input and output file descriptors will be the TCP connection,
    allowing remote shell access.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: bind_port.s shellcode在EAX寄存器中留下连接的套接字文件描述符。在文件bind_shell_beta.s中添加了以下指令以将此套接字复制到标准I/O文件描述符中；然后调用tiny_shell指令在当前进程中执行shell。创建的shell的标准输入和输出文件描述符将是TCP连接，允许远程shell访问。
- en: New Instructions from bind_shell1.s
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从bind_shell1.s的新指令
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When this shellcode is assembled and used in an exploit, it will bind to port
    31337 and wait for an incoming connection. In the output below, grep is used to
    quickly check for null bytes. At the end, the process hangs waiting for a connection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段shellcode被汇编并用于攻击时，它将绑定到端口31337并等待传入的连接。在下面的输出中，grep被用来快速检查空字节。最后，进程挂起等待连接。
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: From another terminal window, the program netstat is used to find the listening
    port. Then, netcat is used to connect to the root shell on that port.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用netstat程序来查找监听端口。然后，使用netcat连接到该端口的root shell。
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Branching Control Structures
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支控制结构
- en: The control structures of the C programming language, such as for loops and
    if-then-else blocks, are made up of conditional branches and loops in the machine
    language. With control structures, the repeated calls to `dup2` could be shrunk
    down to a single call in a loop. The first C program written in previous chapters
    used a for loop to greet the world 10 times. Disassembling the main function will
    show us how the compiler implemented the for loop using assembly instructions.
    The loop instructions (shown below in bold) come after the function prologue instructions
    save stack memory for the local variable `i`. This variable is referenced in relation
    to the EBP register as `[ebp-4]`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: C编程语言的控制结构，如for循环和if-then-else块，由机器语言中的条件分支和循环组成。使用控制结构，`dup2`的重复调用可以被缩减为一个循环中的单个调用。在前面章节中编写的第一个C程序使用了for循环来向世界问候10次。反汇编主函数将显示编译器如何使用汇编指令实现for循环。循环指令（如下所示，加粗）位于函数前导指令之后，为局部变量`i`保存栈内存。这个变量相对于EBP寄存器被引用为`[ebp-4]`。
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The loop contains two new instructions: `cmp` (compare) and `jle` (jump if
    less than or equal to), the latter belonging to the family of conditional jump
    instructions. The `cmp` instruction will compare its two operands, setting flags
    based on the result. Then, a conditional jump instruction will jump based on the
    flags. In the code above, if the value at `[ebp-4]` is less than or equal to 9,
    execution will jump to `0x8048393`, past the next `jmp` instruction. Otherwise,
    the next `jmp` instruction brings execution to the end of the function at `0x080483a6`,
    exiting the loop. The body of the loop makes the call to `printf()`, increments
    the counter variable at `[ebp-4]`, and finally jumps back to the compare instruction
    to continue the loop. Using conditional jump instructions, complex programming
    control structures such as loops can be created in assembly. More conditional
    jump instructions are shown below.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 循环包含两个新的指令：`cmp`（比较）和`jle`（如果小于或等于则跳转），后者属于条件跳转指令家族。`cmp`指令将比较其两个操作数，并根据结果设置标志。然后，条件跳转指令将根据标志进行跳转。在上面的代码中，如果`[ebp-4]`中的值小于或等于9，执行将跳转到`0x8048393`，跳过下一个`jmp`指令。否则，下一个`jmp`指令将执行跳转到函数末尾的`0x080483a6`，退出循环。循环体调用`printf()`，增加`[ebp-4]`处的计数器变量，并最终跳回比较指令以继续循环。使用条件跳转指令，可以在汇编中创建复杂的编程控制结构，如循环。下面显示了更多的条件跳转指令。
- en: '| Instruction | Description |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cmp <dest>, <source>` | Compare the destination operand with the source,
    setting flags for use with a conditional jump instruction. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `cmp <dest>, <source>` | 比较目标操作数与源操作数，根据结果设置标志，用于条件跳转指令。|'
- en: '| `je <target>` | Jump to target if the compared values are equal. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `je <target>` | 如果比较的值相等则跳转到目标。|'
- en: '| `jne <target>` | Jump if not equal. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `jne <target>` | 如果不相等则跳转。|'
- en: '| `jl <target>` | Jump if less than. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `jl <target>` | 如果小于则跳转。|'
- en: '| `jle <target>` | Jump if less than or equal to. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `jle <target>` | 如果小于或等于则跳转。|'
- en: '| `jnl <target>` | Jump if not less than. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `jnl <target>` | 如果不小于则跳转。|'
- en: '| `jnle <target>` | Jump if not less than or equal to. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `jnle <target>` | 如果不小于或等于则跳转。|'
- en: '| `jg jge` | Jump if greater than, or greater than or equal to. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `jg jge` | 如果大于，或大于等于则跳转。|'
- en: '| `jng jnge` | Jump if not greater than, or not greater than or equal to. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `jng jnge` | 如果不大于，或不大于等于则跳转。|'
- en: 'These instructions can be used to shrink the `dup2` portion of the shellcode
    down to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令可以用来将shellcode中的`dup2`部分缩减到以下内容：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This loop iterates ECX from `0` to `2`, making a call to `dup2` each time. With
    a more complete understanding of the flags used by the `cmp` instruction, this
    loop can be shrunk even further. The status flags set by the `cmp` instruction
    are also set by most other instructions, describing the attributes of the instruction's
    result. These flags are carry flag (CF), parity flag (PF), adjust flag (AF), overflow
    flag (OF), zero flag (ZF), and sign flag (SF). The last two flags are the most
    useful and the easiest to understand. The zero flag is set to true if the result
    is zero, otherwise it is false. The sign flag is simply the most significant bit
    of the result, which is true if the result is negative and false otherwise. This
    means that, after any instruction with a negative result, the sign flag becomes
    true and the zero flag becomes false.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环从 `0` 迭代到 `2`，每次调用 `dup2`。通过对 `cmp` 指令使用的标志的更完整理解，这个循环可以进一步缩短。由 `cmp` 指令设置的标志也被大多数其他指令设置，描述了指令结果的属性。这些标志包括进位标志
    (CF)、奇偶标志 (PF)、调整标志 (AF)、溢出标志 (OF)、零标志 (ZF) 和符号标志 (SF)。最后两个标志最有用且最容易理解。如果结果是零，则零标志设置为真，否则为假。符号标志简单地是结果的最重要位，如果结果是负数则设置为真，否则为假。这意味着，在执行任何产生负结果的指令后，符号标志变为真，而零标志变为假。
- en: '| Abbreviation | Name | Description |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| Abbreviation | Name | Description |'
- en: '| --- | --- | --- |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ZF | zero flag | True if the result is zero. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| ZF | 零标志 | 如果结果是零则为真。 |'
- en: '| SF | sign flag | True if the result is negative (equal to the most significant
    bit of result). |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| SF | 符号标志 | 如果结果是负数（等于结果的最重要位）则为真。 |'
- en: 'The `cmp` (compare) instruction is actually just a `sub` (subtract) instruction
    that throws away the results, only affecting the status flags. The `jle` (jump
    if less than or equal to) instruction is actually checking the zero and sign flags.
    If either of these flags is true, then the destination (first) operand is less
    than or equal to the source (second) operand. The other conditional jump instructions
    work in a similar way, and there are still more conditional jump instructions
    that directly check individual status flags:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`（比较）指令实际上只是一个 `sub`（减法）指令，它丢弃了结果，只影响状态标志。`jle`（如果小于或等于则跳转）指令实际上是在检查零和符号标志。如果这两个标志中的任何一个为真，则目标（第一个）操作数小于或等于源（第二个）操作数。其他条件跳转指令以类似的方式工作，并且还有更多直接检查单个状态标志的条件跳转指令：'
- en: '| Instruction | Description |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| Instruction | Description |'
- en: '| --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `jz <target>` | Jump to target if the zero flag is set. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `jz <target>` | 如果零标志被设置，则跳转到目标。 |'
- en: '| `jnz <target>` | Jump if the zero flag is not set. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `jnz <target>` | 如果零标志没有被设置，则跳转。 |'
- en: '| `js <target>` | Jump if the sign flag is set. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `js <target>` | 如果符号标志被设置，则跳转。 |'
- en: '| `jns <target>` | Jump is the sign flag is not set. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `jns <target>` | 如果符号标志没有被设置，则跳转。 |'
- en: With this knowledge, the `cmp` (compare) instruction can be removed entirely
    if the loop's order is reversed. Starting from `2` and counting down, the sign
    flag can be checked to loop until `0`. The shortened loop is shown below, with
    the changes shown in bold.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，如果循环的顺序被反转，可以完全删除 `cmp`（比较）指令。从 `2` 开始计数向下，可以检查符号标志直到 `0`。缩短后的循环如下所示，变化以粗体显示。
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first two instructions before the loop can be shortened with the `xchg`(exchange)
    instruction. This instruction swaps the values between the source and destination
    operands:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 循环之前的前两个指令可以使用 `xchg`（交换）指令缩短。这个指令交换源和目标操作数之间的值：
- en: '| Instruction | Description |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| Instruction | Description |'
- en: '| --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `xchg <dest>, <source>` | Exchange the values between the two operands. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `xchg <dest>, <source>` | 交换两个操作数之间的值。 |'
- en: 'This single instruction can replace both of the following instructions, which
    take up four bytes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这条单独的指令可以替换以下两条指令，它们占用四个字节：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The EAX register needs to be zeroed to clear only the upper three bytes of
    the register, and EBX already has these upper bytes cleared. So swapping the values
    between EAX and EBX will kill two birds with one stone, reducing the size to the
    following single-byte instruction:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: EAX 寄存器需要被清零以仅清除寄存器的最高三个字节，而 EBX 已经清除了这些最高字节。所以交换 EAX 和 EBX 之间的值可以一石二鸟，将大小减少到以下单字节指令：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the `xchg` instruction is actually smaller than a `mov` instruction between
    two registers, it can be used to shrink shellcode in other places. Naturally,
    this only works in situations where the source operand's register doesn't matter.
    The following version of the bind port shellcode uses the exchange instruction
    to shave a few more bytes off its size.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`xchg`指令实际上比两个寄存器之间的`mov`指令要小，因此它可以用来缩小其他地方的shellcode。自然，这仅在源操作数的寄存器不重要的情况下才有效。以下版本的绑定端口shellcode使用了交换指令来进一步减少其大小。
- en: bind_shell.s
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bind_shell.s
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This assembles to the same 92-byte bind_shell shellcode used in the previous
    chapter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成与上一章中使用的92字节bind_shell shellcode相同的bind_shell shellcode。
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Connect-Back Shellcode
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接回Shellcode
- en: Port-binding shellcode is easily foiled by firewalls. Most firewalls will block
    incoming connections, except for certain ports with known services. This limits
    the user's exposure and will prevent port-binding shellcode from receiving a connection.
    Software firewalls are now so common that port-bind shellcode has little chance
    of actually working in the wild.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 端口绑定shellcode很容易被防火墙挫败。大多数防火墙会阻止入站连接，除非是已知服务的特定端口。这限制了用户的暴露，并将防止端口绑定shellcode接收连接。软件防火墙现在如此普遍，端口绑定shellcode在野外实际工作的机会很小。
- en: However, firewalls typically do not filter outbound connections, since that
    would hinder usability. From inside the firewall, a user should be able to access
    any web page or make any other outbound connections. This means that if the shellcode
    initiates the outbound connection, most firewalls will allow it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，防火墙通常不会过滤出站连接，因为这会阻碍可用性。从防火墙内部，用户应该能够访问任何网页或建立任何其他出站连接。这意味着如果shellcode发起出站连接，大多数防火墙都会允许它。
- en: Instead of waiting for a connection from an attacker, connect-back shellcode
    initiates a TCP connection back to the attacker's IP address. Opening a TCP connection
    only requires a call to `socket()` and a call to `connect()`. This is very similar
    to the bind-port shellcode, since the socket call is exactly the same and the
    `connect()` call takes the same type of arguments as `bind()`. The following connect-back
    shellcode was made from the bind-port shellcode with a few modifications (shown
    in bold).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 连接回shellcode不是等待攻击者的连接，而是发起一个TCP连接回攻击者的IP地址。打开TCP连接只需要调用`socket()`和调用`connect()`。这与绑定端口shellcode非常相似，因为socket调用完全相同，`connect()`调用接受与`bind()`相同的类型参数。以下连接回shellcode是从绑定端口shellcode经过一些修改（以粗体显示）得到的。
- en: Connect-Back Shellcode
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接回Shellcode
- en: connectback_shell.s
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: connectback_shell.s
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the shellcode above, the connection IP address is set to 192.168.42.72,
    which should be the IP address of the attacking machine. This address is stored
    in the `in_addr` structure as `0x482aa8c0`, which is the hexadecimal representation
    of 72, 42, 168, and 192\. This is made clear when each number is displayed in
    hexadecimal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的shellcode中，连接IP地址设置为192.168.42.72，这应该是攻击机的IP地址。这个地址以`0x482aa8c0`的形式存储在`in_addr`结构中，这是72、42、168和192的十六进制表示。当每个数字以十六进制形式显示时，这一点很清楚：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Since these values are stored in network byte order but the *x*86 architecture
    is in little-endian order, the stored DWORD seems to be reversed. This means the
    DWORD for 192.168.42.72 is `0x482aa8c0`. This also applies for the two-byte WORD
    used for the destination port. When the port number 31337 is printed in hexadecimal
    using gdb, the byte order is shown in little-endian order. This means the displayed
    bytes must be reversed, so WORD for 31337 is `0x697a`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些值以网络字节序存储，但*x*86架构是小端序，所以存储的DWORD看起来是反转的。这意味着192.168.42.72的DWORD是`0x482aa8c0`。这也适用于用于目标端口的两个字节的WORD。当使用gdb以十六进制形式打印端口号31337时，字节序显示为小端序。这意味着显示的字节必须反转，所以31337的WORD是`0x697a`。
- en: The netcat program can also be used to listen for incoming connections with
    the `-l` command-line option. This is used in the output below to listen on port
    31337 for the connect-back shellcode. The `ifconfig` command ensures the IP address
    of eth0 is 192.168.42.72 so the shellcode can connect back to it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: netcat程序也可以使用`-l`命令行选项来监听入站连接。在下面的输出中，它用于监听端口31337的连接回shellcode。`ifconfig`命令确保eth0的IP地址是192.168.42.72，这样shellcode就可以连接回它。
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, let's try to exploit the tinyweb server program using the connectback shellcode.
    From working with this program before, we know that the request buffer is 500
    bytes long and is located at `0xbffff5c0` in stack memory. We also know that the
    return address is found within 40 bytes of the end of the buffer.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用connectback shellcode来利用tinyweb服务器程序。从之前与这个程序的工作中，我们知道请求缓冲区长度为500字节，位于栈内存的`0xbffff5c0`位置。我们还知道返回地址位于缓冲区末尾40字节内。
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since the offset from the beginning of the buffer to the return address is 540
    bytes, a total of 544 bytes must be written to overwrite the four-byte return
    address. The return address overwrite also needs to be properly aligned, since
    the return address uses multiple bytes. To ensure proper alignment, the sumof
    the NOP sled and shellcode bytes must be divisible by four. In addition, the shellcode
    itself must stay within the first 500 bytes of the overwrite. These are the bounds
    of the response buffer, and the memory afterward corresponds to other values on
    the stack that might be written to before we change the program's control flow.
    Staying within these bounds avoids the risk of random overwrites to the shellcode,
    which inevitably lead to crashes. Repeating the return address 16 times will generate
    64 bytes, which can be put at the end of the 544-byte exploit buffer and keeps
    the shellcode safely within the bounds of the buffer. The remaining bytes at the
    beginning of the exploit buffer will be the NOP sled. The calculations above show
    that a 402-byte NOP sled will properly align the 78-byte shellcode and place it
    safely within the bounds of the buffer. Repeating the desired return address 12
    times spaces the final 4 bytes of the exploit buffer perfectly to overwrite the
    saved return address on the stack. Overwriting the return address with `0xbffff688`
    should return execution right to the middle of the NOP sled, while avoiding bytes
    near the beginning of the buffer, which might get mangled. These calculated values
    will be used in the following exploit, but first the connect-back shell needs
    some place to connect back to. In the output below, netcat is used to listen for
    incoming connections on port 31337.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区起始到返回地址的偏移量为540字节，因此必须写入总共544字节来覆盖四个字节的返回地址。由于返回地址使用多个字节，返回地址覆盖还需要正确对齐。为了确保正确对齐，NOP
    sled和shellcode字节的和必须能被四整除。此外，shellcode本身必须保持在覆盖的第一500字节内。这些是响应缓冲区的界限，之后的内存对应于在改变程序控制流之前可能写入栈上的其他值。保持在这些界限内可以避免随机覆盖shellcode的风险，这不可避免地会导致崩溃。重复返回地址16次将生成64字节，可以将这些字节放在544字节exploit缓冲区的末尾，并确保shellcode安全地位于缓冲区界限内。exploit缓冲区开头的剩余字节将是NOP
    sled。上述计算表明，402字节的NOP sled可以正确对齐78字节的shellcode，并将其安全地放置在缓冲区界限内。重复所需的返回地址12次将完美地间隔exploit缓冲区的最后4字节，以覆盖栈上保存的返回地址。用`0xbffff688`覆盖返回地址应该将执行返回到NOP
    sled的中间，同时避免接近缓冲区开始的字节，这些字节可能会被破坏。上述计算出的值将在以下exploit中使用，但首先connect-back shell需要一些地方来连接回。以下输出中，netcat用于监听端口31337的传入连接。
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, in another terminal, the calculated exploit values can be used to exploit
    the tinyweb program remotely.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个终端中，可以使用计算出的exploit值远程利用tinyweb程序。
- en: From Another Terminal Window
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Back in the original terminal, the shellcode has connected back to the netcat
    process listening on port 31337\. This provides root shell access remotely.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始终端中，shellcode已经连接回监听端口31337的netcat进程。这提供了远程root shell访问。
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The network configuration for this example is slightly confusing because the
    attack is directed at 127.0.0.1 and the shellcode connects back to 192.168.42.72\.
    Both of these IP addresses route to the same place, but 192.168.42.72 is easier
    to use in shellcode than 127.0.0.1\. Since the loopback address contains two null
    bytes, the address must be built on the stack with multiple instructions. One
    way to do this is to write the two null bytes to the stack using a zeroed register.
    The file loopback_shell.s is a modified version of connectback_shell.s that uses
    the loopback address of 127.0.0.1\. The differences are shown in the following
    output.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的网络配置稍微有些令人困惑，因为攻击目标是127.0.0.1，而shellcode连接回192.168.42.72。这两个IP地址都路由到同一个地方，但192.168.42.72在shellcode中使用起来比127.0.0.1更方便。由于回环地址包含两个空字节，地址必须通过多个指令在栈上构建。一种方法是将两个空字节写入栈中，使用一个清零的寄存器。文件loopback_shell.s是connectback_shell.s的修改版本，它使用127.0.0.1的回环地址。以下输出显示了这些差异。
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: After pushing the value `0x01BBBB7f` to the stack, the ESP register will point
    to the beginning of this DWORD. By writing a two-byte WORD of null bytes at ESP+1,
    the middle two bytes will be overwritten to form the correct return address.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在将值`0x01BBBB7f`推送到栈后，ESP寄存器将指向这个DWORD的开始。通过在ESP+1处写入两个空字节（null bytes）的WORD，中间的两个字节将被覆盖，从而形成正确的返回地址。
- en: This additional instruction increases the size of the shellcode by a few bytes,
    which means the NOP sled also needs to be adjusted for the exploit buffer. These
    calculations are shown in the output below, and they result in a 397-byte NOP
    sled. This exploit using the loopback shellcode assumes that the tinyweb program
    is running and that a netcat process is listening for incoming connections on
    port 31337.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这条额外的指令使shellcode的大小增加了几个字节，这意味着NOP sled也需要调整以适应漏洞缓冲区。这些计算在下面的输出中显示，并导致一个397字节的NOP
    sled。这个使用loopback shellcode的漏洞利用假设tinyweb程序正在运行，并且有一个netcat进程正在监听端口31337上的传入连接。
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As with the previous exploit, the terminal with netcat listening on port 31337
    will receive the rootshell.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的漏洞利用一样，监听端口31337的netcat终端将接收rootshell。
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It almost seems too easy, doesn't it?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎看起来太简单了，不是吗？
