- en: Chapter 9. Exception Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章。异常处理
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: Even the most carefully written program will sometimes encounter unforeseen
    errors. For example, if you write a program that needs to read some data from
    disk, it works on the assumption that the specified disk is actually available
    and the data is valid. If your program does calculations based on user input,
    it works on the assumption that the input is suitable to be used in a calculation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最精心编写的程序有时也会遇到未预见到的错误。例如，如果你编写了一个需要从磁盘读取一些数据的程序，它基于这样的假设：指定的磁盘实际上是可用的，数据是有效的。如果你的程序基于用户输入进行计算，它基于这样的假设：输入适合用于计算。
- en: Although you may try to anticipate some potential problems before they arise—for
    example, by writing code to check that a file exists before reading data from
    it or checking that user input is numerical before doing a calculation—you will
    never be able to predict every possible problem in advance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能在问题出现之前尝试预测一些潜在的问题——例如，通过编写代码来检查在从文件中读取数据之前文件是否存在，或者在执行计算之前检查用户输入是否为数值型——但你永远无法提前预测到每一个可能的问题。
- en: The user may remove a data disk after you’ve already started reading data from
    it, for example; or some obscure calculation may yield 0 just before your code
    attempts to divide by this value. When you know that there is the possibility
    that your code may be “broken” by some unforeseen circumstances at runtime, you
    can attempt to avoid disaster by using *exception handling*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可能在已经开始从数据盘中读取数据后移除该数据盘；或者某些晦涩的计算可能在你的代码尝试除以这个值之前得到0。当你知道代码在运行时可能会因为一些未预见的情况而“出错”，你可以通过使用*异常处理*来尝试避免灾难。
- en: An *exception* is an error that is packaged into an object. The object is an
    instance of the Exception class (or one of its descendants). You can handle exceptions
    by trapping the Exception object, optionally using information that it contains
    (to print an appropriate error message, for instance) and taking any actions needed
    to recover from the error—perhaps by closing any files that are still open or
    assigning a sensible value to a variable that may have been assigned some nonsensical
    value as the result of an erroneous calculation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是一个封装成对象的错误。该对象是Exception类（或其子类）的一个实例。你可以通过捕获Exception对象来处理异常，可选地使用它包含的信息（例如打印适当的错误消息）并采取任何必要的措施来从错误中恢复——可能通过关闭任何仍然打开的文件或将变量赋值为一个有意义的值，该变量可能由于错误的计算而被赋予了一些无意义的值。'
- en: 'rescue: Execute Code When Error Occurs'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rescue：当发生错误时执行代码
- en: 'The basic syntax of exception handling can be summarized as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理的语法可以总结如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When an exception is unhandled, your program may crash, and Ruby is likely
    to display a relatively unfriendly error message:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常未被处理时，你的程序可能会崩溃，Ruby可能会显示一个相对不友好的错误消息：
- en: '*div_by_zero.rb*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*div_by_zero.rb*'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program terminates with this error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以这个错误终止：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To prevent this from happening, you should handle exceptions yourself. Here
    is an example of an exception handler that deals with an attempt to divide by
    zero:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，你应该自己处理异常。以下是一个处理尝试除以零的异常处理器的示例：
- en: '*exception1.rb*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*exception1.rb*'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When this runs, the code following `rescue Exception` executes and displays
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，跟随`rescue Exception`的代码执行并显示以下内容：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code between `begin` and `end` is my exception-handling block. I’ve placed
    the troublesome code after `begin`. When an exception occurs, it is handled in
    the section beginning with `rescue`. The first thing I’ve done is to set the variable
    `x` to a meaningful value. Next come these two inscrutable statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`begin`和`end`之间的代码是我的异常处理块。我将麻烦的代码放在了`begin`之后。当发生异常时，它会在以`rescue`开始的段落中处理。我首先做的事情是将变量`x`设置为一个有意义的值。接下来是这两个难以理解的语句：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Ruby, `$!` is a global variable to which is assigned the last exception.
    Printing `$!.class` displays the class name, which here is ZeroDivisionError;
    printing the variable `$!` alone has the effect of displaying the error message
    contained by the Exception object, which here is “divided by 0.”
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，`$!`是一个全局变量，它被分配了最后一个异常。打印`$!.class`会显示类名，这里为ZeroDivisionError；单独打印变量`$!`的效果是显示Exception对象包含的错误消息，这里为“除以0。”
- en: 'I am not generally keen on relying upon global variables, particularly when
    they have names as undescriptive as `$!`. Fortunately, there is an alternative.
    You can associate a variable name with the exception by placing the “assoc operator”
    (`=>`) after the class name of the exception and before the variable name:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常不太喜欢依赖于全局变量，尤其是当它们有像`$!`这样不描述性的名字时。幸运的是，有一个替代方案。你可以在异常的类名之后和变量名之前放置“关联运算符”（`=>`）来将变量名与异常关联起来：
- en: '*exception2.rb*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`exception2.rb`'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now use the variable name (here `exc`) to refer to the Exception object:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用变量名（这里为`exc`）来引用异常对象：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although it may seem pretty obvious that when you divide by zero, you are going
    to get a ZeroDivisionError exception, in real-world code there may be times when
    the type of exception is not so predictable. Let’s suppose, for instance, that
    you have a method that does a division based on two values supplied by a user:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当除以零时，你可能会得到ZeroDivisionError异常似乎很明显，但在实际代码中，有时异常的类型并不那么可预测。假设，例如，你有一个基于用户提供的两个值进行除法的方法：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This could potentially produce a variety of different exceptions. Obviously,
    if the second value entered by the user is 0, you will get a ZeroDivisionError.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会产生各种不同的异常。显然，如果用户输入的第二个值是0，你将得到一个ZeroDivisionError。
- en: Exceptions Have a Family Tree
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异常有一个家族树
- en: 'To understand how `rescue` clauses trap exceptions, just remember that exceptions
    are objects, and like all other objects, they are defined by a class. There is
    also a clear “line of descent” that starts with the base class: Object (in Ruby
    1.8) or BasicObject (Ruby 1.9). Run *exception_tree.rb* to display the ancestors
    of an exception. This is what is displayed by Ruby 1.9:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`rescue`子句如何捕获异常，只需记住异常是对象，就像所有其他对象一样，它们由一个类定义。还有一个清晰的“继承链”，从基类开始：Object（在Ruby
    1.8中）或BasicObject（Ruby 1.9中）。运行`exception_tree.rb`来显示异常的祖先。这是Ruby 1.9显示的内容：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*exception_tree.rb*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`exception_tree.rb`'
- en: 'However, if the *second* value is a string, the exception will be a TypeError,
    whereas if the *first* value is a string, it will be a NoMethodError (because
    the String class does not define the “division operator,” which is `/`). Here
    the `rescue` block handles all possible exceptions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果第二个值是一个字符串，异常将是一个TypeError，而如果第一个值是一个字符串，它将是一个NoMethodError（因为String类没有定义“除法运算符”，即`/`）。在这里，`rescue`块处理所有可能的异常：
- en: '*multi_except.rb*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`multi_except.rb`'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can test this by deliberately generating different error conditions:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过故意生成不同的错误条件来测试这一点：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Often it will be useful to take different actions for different exceptions.
    You can do that by adding multiple `rescue` clauses. Each `rescue` clause can
    handle multiple exception types, with the exception class names separated by commas.
    Here my `calc` method handles TypeError and NoMethodError exceptions in one clause
    with a catchall Exception handler to deal with other exception types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于不同的异常采取不同的行动会有所帮助。你可以通过添加多个`rescue`子句来实现这一点。每个`rescue`子句可以处理多种异常类型，异常类名用逗号分隔。在这里，我的`calc`方法在一个子句中处理TypeError和NoMethodError异常，并使用一个通用的Exception处理程序来处理其他类型的异常：
- en: '*multi_except2.rb*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`multi_except2.rb`'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This time, when a TypeError or NoMethodError is handled (but no other sort
    of error), my additional error message is displayed like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当处理TypeError或NoMethodError（但没有其他类型的错误）时，我的附加错误信息将显示如下：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When handling multiple exception types, you should always put the `rescue` clauses
    dealing with specific exceptions first and then follow these with `rescue` clauses
    dealing with more generalized exceptions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多种异常类型时，你应该始终将处理特定异常的`rescue`子句放在前面，然后跟随处理更通用异常的`rescue`子句。
- en: When a specific exception such as TypeError is handled, the `begin..end` exception
    block exits so the flow of execution won’t “trickle down” to more generalized
    `rescue` clauses. However, if you put a generalized exception-handling `rescue`
    clause first, that will handle all exceptions, so any more specific clauses lower
    down will never execute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理特定的异常，例如TypeError时，`begin..end`异常块会退出，这样执行流程就不会“滴漏”到更通用的`rescue`子句中。然而，如果你首先放置一个通用的异常处理`rescue`子句，那么它将处理所有异常，所以任何更具体的子句都不会执行。
- en: 'If, for example, I had reversed the order of the `rescue` clauses in my `calc`
    method, placing the generalized Exception handler first, this would match all
    exception types so the clause for the specific TypeError and NoMethodError exceptions
    would never be run:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我在`calc`方法中反转了`rescue`子句的顺序，将通用的异常处理程序放在前面，这将匹配所有异常类型，因此特定类型错误（TypeError）和NoMethodError异常的子句将永远不会被执行：
- en: '*multi_except_err.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*multi_except_err.rb*'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'ensure: Execute Code Whether or Not an Error Occurs'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'ensure: 无论是否发生错误都执行代码'
- en: There may be some circumstances in which you want to take some particular action
    whether or not an exception occurs. For example, whenever you are dealing with
    some kind of unpredictable input/output—say, when working with files and directories
    on disk—there is always the possibility that the location (the disk or directory)
    or the data source (the file) either may not be there at all or may provide some
    other kinds of problems—such as the disk being full when you attempt to write
    to it or the file containing the wrong kind of data when you attempt to read from
    it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望在发生异常与否的情况下都执行某些特定的操作。例如，无论何时你处理某种不可预测的输入/输出——比如说，当你在磁盘上的文件和目录工作时——总有可能位置（磁盘或目录）或数据源（文件）根本不存在，或者可能提供其他类型的问题——例如，当你尝试写入时磁盘已满，或者当你尝试读取时文件包含错误类型的数据。
- en: You may need to perform some final “cleanup” procedures whether or not you have
    encountered any problems, such as logging onto a specific working directory or
    closing a file that was previously opened. You can do this by following a `begin..rescue`
    block of code with another block starting with the `ensure` keyword. The code
    in the `ensure` block will always execute, whether or not an exception has arisen
    beforehand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否遇到任何问题，你可能都需要执行一些最终的“清理”程序，比如登录特定的工作目录或关闭之前打开的文件。你可以通过在`begin..rescue`代码块后面跟着另一个以`ensure`关键字开始的代码块来实现。`ensure`块中的代码将始终执行，无论之前是否发生了异常。
- en: 'Let’s look at two simple examples. In the first one, I try to log onto a disk
    and display the directory listing. At the end of this, I want to be sure that
    my working directory (given by `Dir.getwd`) is always restored to its original
    location. I do this by saving the original directory in the `startdir` variable
    and once again making this the working directory in the `ensure` block:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两个简单的例子。在第一个例子中，我尝试登录磁盘并显示目录列表。在这一点上，我想要确保我的工作目录（由`Dir.getwd`给出）总是恢复到其原始位置。我通过在`startdir`变量中保存原始目录，并在`ensure`块中再次将其设置为工作目录来实现这一点：
- en: '*ensure.rb*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*ensure.rb*'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When I run this, the following is displayed:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行这个程序时，显示以下内容：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s now see how to deal with the problem of reading the incorrect data from
    a file. This might happen if the data is corrupt, if you accidentally open the
    wrong file, or—quite simply—if your program code contains a bug.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何处理从文件中读取错误数据的问题。这可能发生在数据损坏、你意外打开了错误的文件，或者——非常简单地说——如果你的程序代码中存在错误。
- en: 'Here I have a file, *test.txt*, containing six lines. The first five lines
    are numbers; the sixth line is a string, “six.” My code opens this file and reads
    in all six lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个文件，*test.txt*，包含六行。前五行是数字；第六行是字符串，“six。”我的代码打开这个文件并读取所有六行：
- en: '*ensure2.rb*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*ensure2.rb*'
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The lines are read in as strings (using `gets`), and the code attempts to convert
    them to integers (using `to_i`). No error is produced when the conversion fails;
    instead, Ruby returns the value 0\. The problem arises in the next line of code,
    which attempts a division by the converted number.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 行被读取为字符串（使用`gets`），代码尝试将它们转换为整数（使用`to_i`）。当转换失败时不会产生错误；相反，Ruby返回值0。问题出现在下一行代码中，它尝试除以转换后的数字。
- en: Having opened the data file at the outset, I want to ensure that the file is
    closed whether or not an error occurs. If, for example, I read in only the first
    five lines by editing the range in the `for` loop to `(1..5)`, then there would
    be no exception. I would still want to close the file. But it would be no good
    putting the file-closing code (`f.close`) in the `rescue` clause because it would
    not, in this case, be executed. By putting it in the `ensure` clause, however,
    I can be certain that the file will be closed whether or not an exception occurs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始打开数据文件后，我想确保无论是否发生错误，文件都会被关闭。例如，如果我只通过编辑 `for` 循环中的范围来读取前五行，那么就不会有异常。但我仍然希望关闭文件。但是将文件关闭代码（`f.close`）放在
    `rescue` 子句中是没有用的，因为在这种情况下，它不会执行。然而，通过将其放在 `ensure` 子句中，我可以确保无论是否发生异常，文件都会被关闭。
- en: 'else: Execute Code When No Error Occurs'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'else: 当没有错误发生时执行代码'
- en: If the `rescue` section executes when an error occurs and `ensure` executes
    whether or not an error occurs, how can you specifically execute some code only
    when an error does *not* occur?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `rescue` 部分在发生错误时执行，而 `ensure` 部分无论是否发生错误都会执行，那么如何具体执行仅在错误 *不* 发生时的一些代码？
- en: 'The way to do this is to add an optional `else` clause after the `rescue` section
    and before the `ensure` section (if there is one), like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，可以在 `rescue` 部分之后和 `ensure` 部分之前（如果有）添加一个可选的 `else` 子句，如下所示：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '*else.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*else.rb*'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Try running the previous program and enter a number such as 10, which won’t
    cause an error, so `msg` will be assigned in the `else` clause; then try entering
    0, which will cause an error, so `msg` will be assigned in the `rescue` clause.
    Whether or not there is an error, the `ensure` section will execute to create
    a `msg` string that begins with “You entered ” followed by any other messages.
    For example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行前面的程序并输入一个不会引起错误的数字，例如 10，这样 `msg` 将在 `else` 子句中赋值；然后尝试输入 0，这将引起错误，因此 `msg`
    将在 `rescue` 子句中赋值。无论是否有错误，`ensure` 部分都将执行以创建一个以“您输入了”开头，后跟任何其他信息的 `msg` 字符串。例如：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Error Numbers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误号
- en: If you ran the *ensure.rb* program earlier and you were watching closely, you
    may have noticed something unusual when you tried to log onto a nonexistent drive
    (for example, on my system that might be the *X:\* drive). Often, when an exception
    occurs, the exception class is an instance of a specific named type such as ZeroDivisionError
    or NoMethodError. In this case, however, the class of the exception is shown to
    be `Errno::ENOENT`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前运行了 *ensure.rb* 程序并且密切关注，当你尝试登录一个不存在的驱动器（例如，在我的系统中可能是 *X:\* 驱动器）时，你可能已经注意到了一些异常情况。通常，当发生异常时，异常类是一个特定命名的类型的实例，例如
    ZeroDivisionError 或 NoMethodError。然而，在这种情况下，异常的类显示为 `Errno::ENOENT`。
- en: 'It turns out that there is quite a variety of `Errno` errors in Ruby. Try *disk_err.rb*.
    This defines a method, `chDisk`, which attempts to log onto a disk identified
    by the character, `aChar`. So if you pass “A” as an argument to `chDisk`, it will
    try to log onto the *A:\* drive. I’ve called the `chDisk` method three times,
    passing to it a different string each time:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在 Ruby 中存在相当多的 `Errno` 错误。尝试 *disk_err.rb*。这个文件定义了一个方法，`chDisk`，它尝试通过字符
    `aChar` 识别的磁盘登录。所以如果你将“A”作为参数传递给 `chDisk`，它将尝试登录到 *A:\* 驱动器。我已经调用了 `chDisk` 方法三次，每次传递不同的字符串：
- en: '*disk_err.rb*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*disk_err.rb*'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You might, of course, need to edit the paths to something different on your
    computer. On my PC, *F:\* is my DVD drive. At the moment, it is empty, and when
    my program tries to log onto it, Ruby returns an exception of this type: `Errno::EACCES`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能需要编辑你电脑上的路径以适应不同的环境。在我的电脑上，*F:\* 是我的 DVD 驱动器。目前它是空的，当我的程序尝试登录到它时，Ruby
    返回这种类型的异常：`Errno::EACCES`。
- en: 'I have no *X:\* drive on my PC, and when I try to log onto that, Ruby returns
    an exception of this type: `Errno::ENOENT`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我电脑上没有 *X:\* 驱动器，当我尝试登录到那个驱动器时，Ruby 返回这种类型的异常：`Errno::ENOENT`。
- en: 'In the previous example, I pass the string parameter “ABC,” which is invalid
    as a disk identifier, and Ruby returns an exception of this type: `Errno::EINVAL`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我传递了字符串参数“ABC”，它作为磁盘标识符是无效的，Ruby 返回这种类型的异常：`Errno::EINVAL`。
- en: Errors of this type are descendants of the SystemCallError class. You can easily
    verify this by uncommenting the line of code to show the class’s family where
    indicated in the source code of *disk_err.rb*. This calls the same `showFamily`
    method, which you used earlier in the *exception_tree.rb* program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误是 SystemCallError 类的子类。你可以通过取消注释 *disk_err.rb* 源代码中指示的行来轻松验证这一点。这会调用相同的
    `showFamily` 方法，你之前在 *exception_tree.rb* 程序中使用过。
- en: These Error classes, in effect, wrap up integer error values that are returned
    by the underlying operating system. Both the names and the values of constants
    may vary according to the operating system and the version of Ruby. Here `Errno`
    is the name of the module containing the constants, such as `EACCES` and `ENOENT`,
    which match the integer error values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误类实际上封装了底层操作系统返回的整数错误值。常量的名称和值可能根据操作系统和 Ruby 的版本而有所不同。在这里，`Errno` 是包含常量的模块的名称，例如
    `EACCES` 和 `ENOENT`，它们与整数错误值相匹配。
- en: 'To see a complete list of `Errno` constants, run this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `Errno` 常量的完整列表，请运行以下命令：
- en: '*errno.rb*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*errno.rb*'
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To view the corresponding numerical value of any given constant, append `::Errno`
    to the constant name, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看任何给定常量的对应数值，请将 `::Errno` 追加到常量名称之后，例如：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can use the following code to display a list of all `Errno` constants along
    with their numerical values (here the `eval` method evaluates the expression passed
    to it—you’ll look at how this works in [Chapter 20](ch20.html "Chapter 20. Dynamic
    Programming")):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码显示所有 `Errno` 常量的列表及其数值（在这里，`eval` 方法评估传递给它的表达式——你将在 [第 20 章](ch20.html
    "第 20 章。动态规划") 中了解它是如何工作的）：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'retry: Attempt to Execute Code Again After an Error'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'retry: 在错误后再次尝试执行代码'
- en: 'If you think an error condition may be transient or may be corrected (by the
    user, perhaps?), you can rerun all the code in a `begin..end` block using the
    keyword `retry`, as in this example that prompts the user to re-enter a value
    if an error such as ZeroDivisionError occurs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为错误条件可能是瞬时的或者可能被纠正（可能是用户？），你可以在 `begin..end` 块中重新运行所有代码，使用关键字 `retry`，如下例所示，如果发生像
    ZeroDivisionError 这样的错误，会提示用户重新输入值：
- en: '*retry.rb*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*retry.rb*'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you want to append the message from an exception object such as `e` to
    a string such as `"Error: "`, Ruby 1.9 insists that you explicitly convert `e`
    to a string ( `"Error: " + e.to_s`), whereas Ruby 1.8 does the conversion for
    you ( `"Error: " + e`).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '当你想将异常对象（如 `e`）的消息附加到字符串（如 `"Error: "`）时，Ruby 1.9 强制你显式地将 `e` 转换为字符串（`"Error:
    " + e.to_s`），而 Ruby 1.8 会为你完成转换（`"Error: " + e`）。'
- en: There is, of course, the danger that the error may not be as transient as you
    think, so if you use `retry`, you may want to provide a clearly defined exit condition
    to ensure that the code stops executing after a fixed number of attempts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，错误可能并不像你想象的那么短暂，所以如果你使用 `retry`，你可能想提供一个明确定义的退出条件，以确保代码在固定次数尝试后停止执行。
- en: 'You could, for example, increment a local variable in the `begin` clause. (If
    you do this, make sure it is incremented *before* any code that is liable to generate
    an exception since once an exception occurs, the remainder of the code prior to
    the `rescue` clause will be skipped!) Then test the value of that variable in
    the `rescue` section, like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `begin` 子句中增加一个局部变量。（如果你这样做，确保它在任何可能生成异常的代码之前增加，因为一旦发生异常，`rescue` 子句之前的代码将跳过！）然后在
    `rescue` 部分测试该变量的值，如下所示：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is a complete example, in which I test the value of a variable named `tries`
    to ensure no more than three tries to run the code without error before the exception-handling
    block exits:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个完整的示例，我测试了一个名为 `tries` 的变量的值，以确保在异常处理块退出之前，代码在没有错误的情况下不超过三次尝试运行：
- en: '*retry2.rb*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*retry2.rb*'
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the user were to enter 0 three times in a row, this would be the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户连续三次输入 0，这将产生以下输出：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'raise: Reactivate a Handled Error'
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'raise: 重新激活已处理错误'
- en: 'Sometimes you may want to keep an exception “alive” even after it has been
    trapped in an exception-handling block. You can do this, for example, to defer
    the handling of the exception, say by passing it on to some other method. You
    can do this using the `raise` method. You need to be aware, however, that, once
    raised, an exception needs to be rehandled; otherwise, it may cause your program
    to crash. Here is a simple example of raising a ZeroDivisionError exception and
    passing on the exception to a method called, in this case, `handleError`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想在异常被捕获后仍然保持异常“活跃”，即使它已经被异常处理块捕获。例如，你可以通过将其传递给其他方法来延迟处理异常，比如传递给名为 `handleError`
    的方法。你可以使用 `raise` 方法来做这件事。然而，你需要意识到，一旦抛出，异常需要被重新处理；否则，它可能会导致你的程序崩溃。以下是一个抛出 `ZeroDivisionError`
    异常并将异常传递给名为 `handleError` 的方法的简单示例：
- en: '*raise.rb*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*raise.rb*'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here `divbyzero` is the name of a method in which the divide-by-zero operation
    takes place, and `handleError` is a method that prints more detailed information
    on the exception:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`divbyzero` 是一个方法的名字，其中包含了除以零的操作，而 `handleError` 是一个打印异常更详细信息的方法：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice that this uses the `backtrace` method, which displays an array of strings
    showing the filenames and line numbers where the error occurred and, in this case,
    the line that called the error-producing `divbyzero` method. This is an example
    of this program’s output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这使用了 `backtrace` 方法，它显示了一个字符串数组，显示了错误发生的文件名和行号，以及在这种情况下调用产生错误 `divbyzero`
    方法的行。这是该程序输出的一个示例：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also specifically raise your exceptions to force an error condition
    even when the program code has not caused an exception. Calling `raise` on its
    own raises an exception of the type RuntimeError (or whatever exception is in
    the global variable `$!`):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以专门抛出异常来强制错误条件，即使程序代码本身没有引发异常。单独调用 `raise` 会引发一个 `RuntimeError` 类型的异常（或者全局变量
    `$!` 中存储的任何异常）：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By default, this will have no descriptive message associated with it. You can
    add a message as a parameter, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这不会与任何描述性消息相关联。你可以添加一个消息作为参数，如下所示：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can raise a specific type of error:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以抛出一个特定的错误类型：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also create an object of a specific exception type and initialize it
    with a custom message:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建一个特定异常类型的对象，并用自定义消息初始化它：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is a simple example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '*raise2.rb*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*raise2.rb*'
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This outputs the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the standard exception types don’t meet your requirements, you can, of course,
    create new ones just by subclassing existing exceptions. Provide your classes
    with a `to_str` method in order to give them a default message.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准异常类型不符合你的需求，你当然可以通过继承现有异常来创建新的异常。为你的类提供一个 `to_str` 方法，以便为它们提供一个默认消息。
- en: '*raise3.rb*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*raise3.rb*'
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is an example of how you might raise a custom exception:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于如何抛出自定义异常的示例：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you now enter `sayHello( nil )`, this would be the output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在输入 `sayHello( nil )`，这将产生以下输出：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Digging Deeper
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: When trapping exceptions, the `begin` keyword may, in some circumstances, be
    omitted. Here you will learn about this syntax. I will also clarify some potential
    confusion about `catch` and `throw`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获异常时，在某些情况下，可以省略 `begin` 关键字。在这里，你将了解这种语法。我还会澄清一些关于 `catch` 和 `throw` 的潜在混淆。
- en: Omitting begin and end
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 省略 begin 和 end
- en: 'You can optionally omit `begin` and `end` when trapping exceptions inside a
    method, a class, or a module. For example, all the following are legal:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法、类或模块内部捕获异常时，你可以选择性地省略 `begin` 和 `end`。例如，以下所有这些都是合法的：
- en: '*omit_begin_end.rb*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*omit_begin_end.rb*'
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In all the previous cases, the exception-handling will also work if you place
    the `begin` and `end` keywords at the start and end of the exception-handling
    code in the usual way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的案例中，如果以通常的方式在异常处理代码的开始和结束处放置 `begin` 和 `end` 关键字，异常处理也将正常工作。
- en: catch..throw
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: catch..throw
- en: 'In some languages, exceptions are trapped using the keyword `catch` and may
    be raised using the keyword `throw`. Although Ruby provides `catch` and `throw`
    methods, these are not directly related to its exception handling. Instead, `catch`
    and `throw` are used to break out of a defined block of code when some condition
    is met. You could, of course, use `catch` and `throw` to break out of a block
    of code when an exception occurs (though this may not be the most elegant way
    of handling errors). For example, this code will exit the block delimited by curly
    brackets if a ZeroDivisionError occurs:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，异常是通过使用关键字`catch`来捕获的，并且可以使用关键字`throw`来引发。尽管Ruby提供了`catch`和`throw`方法，但这些方法与其异常处理没有直接关系。相反，`catch`和`throw`用于在满足某些条件时跳出定义的代码块。当然，您可以使用`catch`和`throw`在发生异常时跳出代码块（尽管这可能不是处理错误的最优雅方式）。例如，如果发生`ZeroDivisionError`，此代码将退出由大括号分隔的代码块：
- en: '*catch_except.rb*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*catch_except.rb*'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See [Chapter 6](ch06.html "Chapter 6. Conditional Statements") for more on `catch`
    and `throw`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 详见[第6章](ch06.html "第6章. 条件语句")了解`catch`和`throw`的更多内容。
