- en: Chapter 10. More Complex Utilities and Tricks, Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。更复杂的工具和技巧，第二部分
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: In this chapter, I’ll describe an important functional technique called the
    *callback*, in which a general-purpose method uses a Proc to determine its specific
    result. We’ve actually seen this plenty of times before, because it’s built right
    into many Ruby methods. Let’s say we want to double every number in a list. That’s
    easy. We just use `[0, 1, 2].map { |x| x * 2 }` and get `[0, 2, 4]` as the result.
    If we want to find all numbers greater than 1, we use `[0, 1, 2].find_all { |x|
    x > 1 }` and get [2] instead.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将描述一个重要的功能技术，称为*回调*，其中通用方法使用Proc来确定其具体结果。我们之前已经多次见过这种情况，因为它直接嵌入到许多Ruby方法中。假设我们想要将列表中的每个数字都翻倍。这很简单。我们只需使用
    `[0, 1, 2].map { |x| x * 2 }` 并得到 `[0, 2, 4]` 作为结果。如果我们想找到所有大于1的数字，我们使用 `[0, 1,
    2].find_all { |x| x > 1 }` 并得到 [2]。
- en: All we’re doing in either case is using a general purpose method like `map`
    or `find_all` that takes a block, like `{ |x| x * 2 }` or `{ |x| x > 1 }`, and
    bases its output on the results of that block. The `map` method performs the block’s
    operation on every member of its calling object, while `find_all` returns a collection
    that only contains members that passed the test that the block describes. In both
    cases, the specifics are completely determined by the block. Conceptually, that’s
    all a callback is. Let’s see a specific useful example that uses Procs instead
    of blocks to describe callbacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们只是在使用像 `map` 或 `find_all` 这样的通用方法，这些方法接受一个块，如 `{ |x| x * 2 }` 或 `{
    |x| x > 1 }`，并根据该块的结果生成输出。`map` 方法对其调用对象中的每个成员执行块的运算，而 `find_all` 返回一个只包含通过块描述的测试的成员的集合。在这两种情况下，具体内容完全由块确定。从概念上讲，这就是回调的全部。让我们看看一个使用Proc而不是块来描述回调的具体有用示例。
- en: '#37 Overnight DJ (radio_player1.rb)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#37 夜间DJ（radio_player1.rb）'
- en: 'One of my friends has had a very colorful employment history. He’s been a DJ
    and general manager of a radio station, a union organizer, a journalist and translator
    in Japan, and a professional nightclub musician.^([[28](#ftn.CHP-10-FNOTE-1)])
    Back when he was running a jazz radio station, he had a problem: His station relied
    heavily on volunteers and automation, as many jazz stations do, and the station
    operators would set up an automated computer system to play sound files overnight.
    The drawback was that the system had no logging, so if a listener heard something
    he or she liked at 2:47 AM, the operators couldn’t find out what the specific
    tune was. No one was at the station to take a phone call, and the next morning,
    there was no log of what sound file was played when, so no one could track down
    what was playing at a specific time that morning before anyone came in.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一个朋友有着非常丰富多彩的就业历史。他曾是一名DJ和电台总经理，是一名工会组织者，在日本是一名记者和翻译，还是一名专业夜总会音乐家.^([[28](#ftn.CHP-10-FNOTE-1)])
    当他经营一家爵士电台时，他遇到了一个问题：他的电台像许多爵士电台一样，严重依赖志愿者和自动化，电台运营商会设置一个自动化的计算机系统在夜间播放声音文件。缺点是系统没有日志记录，所以如果有人在凌晨2:47听到了喜欢的东西，运营商无法找出具体是哪首曲子。没有人会在电台接电话，第二天早上也没有记录播放了哪些声音文件，因此没有人能在任何人到来之前追踪到那天早上播放的具体内容。
- en: Enter `radio_player1.rb` and `radio_player2.rb`. These programs demonstrate
    a solution to this type of problem. The `radio_player1.rb` script gets us started
    with the basics, including an explanation of how Ruby uses callbacks, and `radio_player2.rb`
    does the real heavy lifting, including logging. Note that `radio_player1.rb` doesn’t
    really do any playback, it just demonstrates the techniques.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了 `radio_player1.rb` 和 `radio_player2.rb`。这些程序展示了这种问题的解决方案。`radio_player1.rb`
    脚本让我们从基础知识开始，包括解释Ruby如何使用回调，而 `radio_player2.rb` 执行真正的重头戏，包括日志记录。请注意，`radio_player1.rb`
    并没有真正进行回放，它只是展示了这些技术。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: First, we define our callbacks as Proc Constants. At ❶, we have the `PLAY_FILE_PROC`,
    and at ❷, we have the `DONT_PLAY_FILE_PROC`. Since `radio_player1.rb` is just
    a demonstration script, both of these Procs merely report what they would do instead
    of actually doing anything. Think of them as “dry run” testing examples. At ❸
    we define a new class called `RadioPlayer`. We’ll detail that class soon, but
    for now, it’ll be easier to understand how this script works if we skip down to
    ❿, where we see how the class is used.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的回调为进程常量。在 ❶ 处，我们有 `PLAY_FILE_PROC`，在 ❷ 处，我们有 `DONT_PLAY_FILE_PROC`。由于
    `radio_player1.rb` 只是一个演示脚本，这两个进程只是报告它们将要做什么，而不是真正地做任何事情。把它们看作是“干运行”测试示例。在 ❸ 处，我们定义了一个新的类
    `RadioPlayer`。我们很快会详细介绍这个类，但现在，如果我们跳到 ❿，我们会更容易理解这个脚本是如何工作的。
- en: We define a variable called `dir`, with the value `‘extras/soundfiles’`. That’s
    where I stored the audio files used by this example; it’s analogous to the directory
    that contains the radio station’s songs, sound bites, station identification,
    and so forth. We then set the value of a variable called `callback`. It stores
    the appropriate Proc, either `PLAY_FILE_PROC` or `DONT_PLAY_FILE_PROC`. If the
    first argument to the script (`ARGV[0]`) is `‘play’`, it uses `PLAY_FILE_PROC`.
    Otherwise, it uses `DONT_PLAY_FILE_PROC`. Next, we define a variable called `dir_filter`,
    which is either a defined RegExp instance or `nil`. As the name suggests, this
    filters directories within the main `dir` soundfile directory. If `dir_filter`
    is `nil`, it does no filtering, and it assumes the entire contents of `dir` are
    available for playing. We then call the `walk` (❾) class method of `RadioPlayer`
    with the arguments `dir, callback`, and `dir_filter`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `dir` 的变量，其值为 `‘extras/soundfiles’`。这就是我存储本示例所使用的音频文件的地方；它类似于包含广播电台歌曲、声音剪辑、电台标识等内容的目录。然后，我们设置了一个名为
    `callback` 的变量的值。它存储了适当的进程，即 `PLAY_FILE_PROC` 或 `DONT_PLAY_FILE_PROC`。如果脚本的第一个参数
    (`ARGV[0]`) 是 `‘play’`，则使用 `PLAY_FILE_PROC`。否则，它使用 `DONT_PLAY_FILE_PROC`。接下来，我们定义了一个名为
    `dir_filter` 的变量，它可以是定义的 RegExp 实例或 `nil`。正如其名所示，它过滤主 `dir` 音频文件目录内的目录。如果 `dir_filter`
    是 `nil`，则不进行过滤，并假设 `dir` 的全部内容都可用于播放。然后，我们调用 `RadioPlayer` 类的 `walk` (❾) 方法，并传递参数
    `dir, callback` 和 `dir_filter`。
- en: 'The `self.walk` method takes three arguments: `dir, callback_proc`, and `dir_filter`.
    The first two are mandatory, while `dir_filter` is optional, defaulting to `nil`.
    It prints an empty line with `puts`, and if the script is called with the `-d`
    flag (which sets `$DEBUG` to `true`), `self.walk` also prints some boilerplate
    indicating what it’s doing. It then executes a `call` to a Proc Constant called
    `PICK_FROM_DIR_PROC`, using the same three arguments—`dir, callback_proc`, and
    `dir_filter`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.walk` 方法接受三个参数：`dir, callback_proc` 和 `dir_filter`。前两个是必需的，而 `dir_filter`
    是可选的，默认为 `nil`。它使用 `puts` 打印一个空行，如果脚本带有 `-d` 标志（将 `$DEBUG` 设置为 `true`），则 `self.walk`
    还会打印一些样板文本，表明它在做什么。然后，它执行一个对名为 `PICK_FROM_DIR_PROC` 的进程常量的 `call` 调用，使用相同的三个参数——`dir,
    callback_proc` 和 `dir_filter`。'
- en: 'Now, to understand what that means, we’ll describe the `RadioPlayer` class
    at ❸. It has two Constants: `DIRS_TO_IGNORE` and `PICK_FROM_DIR_PROC. DIRS_TO_IGNORE`
    (❹) lists the directories that the script should not care about. It includes the
    current directory (`‘.’`), the directory up a level (`‘..’`), and the directory
    used by CVS.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了理解这意味着什么，我们将描述 `RadioPlayer` 类在 ❸ 处。它有两个常量：`DIRS_TO_IGNORE` 和 `PICK_FROM_DIR_PROC`。`DIRS_TO_IGNORE`
    (❹) 列出了脚本不应关心的目录。它包括当前目录 (`‘.’`)、上一级目录 (`‘..’`) 和由 CVS 使用的目录。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Concurrent Versions System (CVS) is a program that keeps track of different
    versions of files. It’s most often used for software development. You can read
    more about it at* [http://www.nongnu.org/cvs](http://www.nongnu.org/cvs).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发版本系统 (CVS) 是一个跟踪文件不同版本的程序。它最常用于软件开发。您可以在[http://www.nongnu.org/cvs](http://www.nongnu.org/cvs)上了解更多关于它的信息*。'
- en: 'The second Constant within `RadioPlayer` is `PICK_FROM_DIR_PROC` (❺), which
    is a Proc that picks from directories. We create it in the usual way with `lambda`
    and define it to take three arguments: `dir, callback_proc`, and `dir_filter`.
    These correspond to the three arguments to `walk` (❾) that we described at the
    bottom of this script at ❿.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadioPlayer` 中的第二个常量是 `PICK_FROM_DIR_PROC` (❺)，它是一个从目录中选择进程。我们以通常的方式使用 `lambda`
    创建它，并定义它接受三个参数：`dir, callback_proc` 和 `dir_filter`。这些对应于我们在脚本底部 ❿ 描述的 `walk` (❾)
    的三个参数。'
- en: Now we get to see what these arguments end up being used for. The `PICK_FROM_DIR_PROC`
    Constant has several debugging lines that `puts` a given message if `$DEBUG` is
    set to `true`. I won’t detail each of them, as they should be fairly self explanatory.
    We start by looping through `each` sorted `filename`, based on the `entries` within
    `dir`, minus the `DIRS_TO_IGNORE` (❻). Next, we verify that either the `filename`
    matches the `dir_filter` with a regular expression test, or there is no `dir_filter`
    in place (❼). Assuming we should proceed, we assign the interpolated String `“#{dir}/#{filename}”`
    into a local variable called `item`. We’ll be using `item` frequently enough that
    it’s worthwhile to set it once and reuse it, rather than recalculate it every
    time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到这些参数最终被用于什么。`PICK_FROM_DIR_PROC` 常量包含几个调试行，如果 `$DEBUG` 设置为 `true`，则
    `puts` 一个给定消息。我不会详细说明每一个，因为它们应该相当容易理解。我们首先根据 `dir` 内的 `entries` 对 `each` 排序的 `filename`
    进行循环，减去 `DIRS_TO_IGNORE`（❻）。接下来，我们验证 `filename` 是否与 `dir_filter` 通过正则表达式测试匹配，或者没有设置
    `dir_filter`（❼）。假设我们应该继续，我们将插值字符串 `“#{dir}/#{filename}”` 赋值给一个名为 `item` 的局部变量。我们将频繁使用
    `item`，因此一次性设置并重用它比每次都重新计算它更有价值。
- en: 'Next, we use the `File.directory?` predicate (❽) to determine whether or not
    `item` is a directory. If it is a directory, we need to pick from that directory
    as well, so we recursively call `PICK_FROM_DIR_PROC`, with the arguments `item,
    callback_proc`, and `dir_filter`. The current value of `item` now becomes the
    value of `dir` in the new recursive call, so when we get to the assignment into
    `item` within the recursive call, that item consists of a String like the following:
    `“#{top_dir}/{next_dir}/#{filename}”`, and so on. This keeps happening until we
    reach a non-directory `filename`. What happens then?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `File.directory?` 断言（❽）来确定 `item` 是否是一个目录。如果是目录，我们需要从该目录中选取，因此我们递归地调用
    `PICK_FROM_DIR_PROC`，并传递参数 `item, callback_proc, dir_filter`。当前 `item` 的值现在成为新递归调用中
    `dir` 的值，因此当我们到达递归调用中的 `item` 赋值时，该项由以下字符串组成：`“#{top_dir}/{next_dir}/#{filename}”`，等等。这会一直发生，直到我们到达一个非目录的
    `filename`。那时会发生什么呢？
- en: 'In this case we consult the `else` clause within the `if` block at ❽. Here,
    we finally call the `callback_proc`, with `item` as the argument. Let’s assume
    that we are using `PLAY_FILE_PROC` as the `callback_proc`. We’ll therefore `puts`
    a message saying that we’re playing `filename`. This happens for every terminal
    (non-directory) `filename` within the execution of `self.walk` (❾). Let’s see
    it in action. First let’s see the contents of `extras/soundfiles`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 ❽ 的 `if` 块中咨询 `else` 子句。在这里，我们最终以 `item` 作为参数调用 `callback_proc`。假设我们使用
    `PLAY_FILE_PROC` 作为 `callback_proc`。因此，我们将输出一条消息，说明我们正在播放 `filename`。这发生在 `self.walk`
    执行中的每个终端（非目录）`filename`（❾）。让我们看看它的实际效果。首先，让我们看看 `extras/soundfiles` 的内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Other than those CVS directories I mentioned, we have a file called `01-Neal_And_Jack_And_Me.ogg`
    at the top level, a directory called `legal` with the files `legal1` and `legal2`,
    and a directory called `promo` with the files `promo1` and `promo2`. Now, let’s
    run `radio_player1.rb` with various arguments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我提到的那些 CVS 目录外，我们还有一个名为 `01-Neal_And_Jack_And_Me.ogg` 的文件位于顶层，一个名为 `legal`
    的目录，包含文件 `legal1` 和 `legal2`，以及一个名为 `promo` 的目录，包含文件 `promo1` 和 `promo2`。现在，让我们用各种参数运行
    `radio_player1.rb`。
- en: The Results
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We provided no `ARGV[0]`, so it assumed `DONT_PLAY_FILE_PROC` for the callback.
    It also had no `dir_filter`, so it “not played” every file within `extras/soundfiles`,
    except within the directories we told it to ignore—maybe it’s silly to explicitly
    “not play” sound files, but I just wanted a callback that could show in an obvious
    fashion that it was being called. Let’s see some more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有提供 `ARGV[0]`，所以它假设 `DONT_PLAY_FILE_PROC` 作为回调。它也没有 `dir_filter`，所以它“不播放”
    `extras/soundfiles` 中的每个文件，除了我们告诉它忽略的目录——也许明确“不播放”声音文件是愚蠢的，但我只是想有一个可以明显显示它被调用的回调。让我们再看一些。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `ARGV[0]` is `‘play’`, and `ARGV[1]` limits available files to those matching
    `/legal/`. It worked.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ARGV[0]` 是 `‘play’`，而 `ARGV[1]` 限制了可用的文件，使其匹配 `/legal/`。它成功了。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It worked again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它又成功了。
- en: Hacking the Script
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: The most basic hack of this script is to call it with the `-d` command-line
    option. That tells you where the script is at any given point, and it may reveal
    some useful information as you try different arguments, create your own files
    and directories with `extras/soundfiles`, or do whatever other customization you
    think is appropriate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的最低级修改就是使用 `-d` 命令行选项来调用它。这会告诉你脚本在任何给定点的位置，并且在你尝试不同的参数、使用 `extras/soundfiles`
    创建自己的文件和目录，或者进行其他你认为合适的自定义时，可能会揭示一些有用的信息。
- en: The beauty of callbacks is that you can hack your program by simply using a
    different one. The overall structure of the manner in which you do some particular
    operation stays the same, while the specific operation being done can change,
    often quite drastically. We’ll see an example of that in the next script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回调的优点在于，你可以通过简单地使用不同的回调来修改你的程序。你执行某些特定操作的方式的整体结构保持不变，而正在执行的具体操作可以改变，通常相当剧烈。我们将在下一个脚本中看到这个例子。
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[28](#CHP-10-FNOTE-1)]) Now he blogs and podcasts at [http://thejasoncraneshow.com](http://thejasoncraneshow.com).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-10-FNOTE-1)]) 现在他博客和播客在 [http://thejasoncraneshow.com](http://thejasoncraneshow.com)。
- en: '#38 Better Overnight DJ (radio_player2.rb)'
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#38 更好的夜间DJ (radio_player2.rb)'
- en: This script, `radio_player2.rb`, is an improvement on `radio_player1.rb`. Instead
    of placeholder Procs, it will actually play sound files, as well as log playback
    with specific times.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本，`radio_player2.rb`，是 `radio_player1.rb` 的改进版。它不仅会播放声音文件，还会记录播放的具体时间，而不是使用占位符进程。
- en: The Code
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How It Works
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: For this section, I’ll merely detail the changes between `radio_player1.rb`
    and `radio_player2.rb`. The first change is the definition of the `LOG_FILE` Constant
    at ❶. As you might expect, this is the filename into which `radio_player2.rb`
    writes logging messages. Next, we declare a Hash Constant called `PLAYERS` at
    ❷, with keys of file extensions for particular types of soundfiles and values
    of the names of programs that one might use to play those types of files on a
    Unix system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我只会详细说明 `radio_player1.rb` 和 `radio_player2.rb` 之间的变化。第一个变化是在❶处定义 `LOG_FILE`
    常量。正如你所期望的，这是 `radio_player2.rb` 将日志消息写入的文件名。接下来，我们在❷处声明一个名为 `PLAYERS` 的哈希常量，其键为特定类型声音文件的文件扩展名，值为在
    Unix 系统上播放这些类型文件可能使用的程序名称。
- en: Next, we define our Procs at ❸, this time as variables rather than Constants.
    There’s no particular reason to use variables instead of Constants, as the comment
    notes. I just wanted to show that either approach works well for our purposes.
    Aside from being variables rather than Constants, the playing Proc is substantively
    different.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在❸处定义我们的进程，这次作为变量而不是常量。没有特别的原因要使用变量而不是常量，正如注释所注明的。我只是想展示这两种方法都可以很好地为我们服务。除了是变量而不是常量之外，播放进程实质上也有所不同。
- en: The `play_file_proc` acts as a closure, binding the `PLAYERS` Hash inside itself.
    It establishes the extension (and therefore, type) of its `filename` argument
    as `ext` at ❹. It then tries to play that filename using `system` at ❺, but only
    if the `PLAYERS` Hash has an appropriate player for that file extension. I made
    sure that `PLAYERS` had an entry for no file extension at all, so `radio_player2.rb`
    could still demonstrate that it was either playing or not playing the dummy files
    like `legal1` and `promo2` that have no file extension. Since I just wanted to
    show the dummy files, I decided that the Unix command `ls`, which just lists files,
    was the appropriate value to use in `PLAYERS`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`play_file_proc` 作为闭包，将内部的 `PLAYERS` 哈希绑定在其自身。它在❹处建立了 `filename` 参数的扩展名（因此，类型）为
    `ext`。然后它尝试使用 `system` 在❺处播放该文件名，但仅当 `PLAYERS` 哈希有适合该文件扩展名的适当播放器时。我确保 `PLAYERS`
    有一个没有文件扩展名的条目，这样 `radio_player2.rb` 仍然可以演示它是否在播放没有文件扩展名的虚拟文件，如 `legal1` 和 `promo2`。由于我只是想展示虚拟文件，我决定使用
    Unix 命令 `ls`，它只是列出文件，作为 `PLAYERS` 中使用的适当值。'
- en: The `radio_player2.rb` script also logs playback within the `play_file_proc`.
    At ❻, it opens a new file for appending, using `‘a’` as the second argument to
    `File.open`. It then refers to that log file as `log`, and uses `log`’s `puts`
    method to append the current `Time` and the `filename` being played, separated
    by tabs, all followed by a carriage return. Whenever we use `radio_player2.rb`,
    we can check the contents of `LOG_FILE` to see what’s been played.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`radio_player2.rb`脚本也在`play_file_proc`中记录回放。在❻处，它使用`‘a’`作为`File.open`的第二个参数打开一个新文件用于追加。然后它将那个日志文件称为`log`，并使用`log`的`puts`方法将当前的`Time`和正在播放的`filename`，用制表符分隔，然后跟一个回车符。每次我们使用`radio_player2.rb`时，我们都可以检查`LOG_FILE`的内容，以查看播放了什么。'
- en: The only other differences are the removal of the debugging messages and referring
    to the Procs by the lowercase variable names rather than the all-caps Constant
    names. Let’s see this version in action.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他区别是移除了调试信息，并且用小写变量名而不是大写常量名来引用进程。让我们看看这个版本的实际效果。
- en: The Results
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s try a basic playback of everything.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试回放所有内容的基本操作。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That command-line call played the Ogg file (again, from my favorite band King
    Crimson) using a `system` call with `ogg123`, the appropriate value within `PLAYERS`
    for the `.ogg` extension, and then it “played” the other files with `ls`, the
    appropriate `PLAYERS` value for files with no extension at all.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令行调用使用`ogg123`和`PLAYERS`中为`.ogg`扩展名指定的适当值通过`system`调用播放了Ogg文件（再次，来自我最喜欢的乐队King
    Crimson），然后使用`ls`和没有扩展名的文件的适当`PLAYERS`值播放了其他文件。
- en: Now let’s filter, with fake playback.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用模拟回放进行过滤。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And again, without fake playback.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，没有模拟回放。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that playback merely lists the dummy files, while non-playback executes
    the full `dont_play_file_proc`, including the immature `So there.` suffix.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，回放只列出虚拟文件，而非回放则执行完整的`dont_play_file_proc`，包括不成熟的`So there.`后缀。
- en: Hacking the Script
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: The value of `LOG_FILE` is Unix-specific. Windows users (or anyone else) can
    certainly change that filename to something more appropriate for their operating
    system. Also, if you prefer a more robust system for the dummy files, you could
    give them their own extension, like `dummy`, and change `PLAYERS` so that the
    key for `‘ls’` is that new extension.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOG_FILE`的值是Unix特定的。Windows用户（或其他人）当然可以将该文件名更改为更适合其操作系统的名称。此外，如果您更喜欢一个更健壮的虚拟文件系统，可以为它们分配自己的扩展名，例如`dummy`，并更改`PLAYERS`，使`‘ls’`的键为这个新扩展名。'
- en: '#39 Numbers by Name (to_lang.rb)'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#39 按名称编号（to_lang.rb）'
- en: 'In previous scripts, notably [#16 Adding Commas to Numbers (commify.rb)](ch05s02.html
    "#16 Adding Commas to Numbers (commify.rb)") on page 75 and [#17 Roman Numerals
    (roman_numeral.rb)](ch05s03.html "#17 Roman Numerals (roman_numeral.rb)") on page
    81, we talked about how numbers can be represented in a variety of ways. Both
    of those scripts showed meaningful ways of representing Integers as Strings, other
    than the handy but trivially different `to_s` method. This script, `to_lang.rb`,
    extends that discussion by representing Integers as Strings consisting of how
    those numbers are spoken in two real-world languages: English and Spanish.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，特别是在第75页的[第16节 添加逗号到数字（commify.rb）](ch05s02.html "#16 Adding Commas
    to Numbers (commify.rb)")和第81页的[第17节 罗马数字（roman_numeral.rb）](ch05s03.html "#17
    Roman Numerals (roman_numeral.rb)")中，我们讨论了数字可以以各种方式表示。这两个脚本都展示了将整数作为字符串表示的有意义的方法，除了方便但微不足道的不同`to_s`方法。这个脚本`to_lang.rb`通过将整数表示为字符串，这些字符串表示了这些数字在两种现实世界语言中的发音：英语和西班牙语。
- en: The Code
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: This code is broken into three separate files, for reasons that I will make
    clear in [How It Works](ch10s03.html#how_it_works-id037 "How It Works") on page
    198.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被拆分为三个独立的文件，原因我将在第198页的[工作原理](ch10s03.html#how_it_works-id037 "工作原理")中详细说明。
- en: representable_in_english.rb
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: representable_in_english.rb
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next will be a very similar file, also storing a module/mixin definition. The
    only meaningful differences pertain to the choice of language: this one details
    Spanish, rather than English.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将是一个非常相似的文件，也存储模块/混合定义。唯一有意义的区别是语言的选择：这个文件详细介绍了西班牙语，而不是英语。
- en: representable_in_spanish.rb
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: representable_in_spanish.rb
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, we have the code that directly gives Integers the ability to represent
    themselves in spoken languages. It does so through the use of the modules above,
    as you’ll see.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有直接赋予整数在口语中自我表示能力的代码。它通过使用上述模块来实现，您将看到。
- en: to_lang.rb
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: to_lang.rb
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How It Works
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Let’s examine each file in turn. Since `representable_in_english.rb` and `representable_in_spanish.rb`
    are so similar, we can deal with them simultaneously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查每个文件。由于`representable_in_english.rb`和`representable_in_spanish.rb`非常相似，我们可以同时处理它们。
- en: The Two Mixins
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个Mixins
- en: 'Both `representable_in_english.rb` and `representable_in_spanish.rb` are *mixins*,
    the mechanism Ruby uses to give shared behavior to classes with different ancestry,
    like giving both bats and birds the ability to fly. In our case, instead of giving
    organisms the ability to fly, we’re giving the object we mix our mixins into the
    ability to represent itself in some human languages: English and Spanish, in this
    case.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`representable_in_english.rb`和`representable_in_spanish.rb`都是*mixins*，这是Ruby用来给不同祖先的类提供共享行为的机制，就像给蝙蝠和鸟都赋予飞行的能力一样。在我们的情况下，我们不是赋予生物飞行的能力，而是赋予我们将mixins混合到对象中的能力，使其能够用某些人类语言（在这种情况下是英语和西班牙语）表示自己。'
- en: We define the appropriate Module, in both `representable_in_english.rb` and
    `representable_in_spanish.rb`, at ❶. I’ll keep the numbered callouts in the code
    in parallel across these two files throughout this example. At ❷, we define our
    `create_english` or `create_spanish` methods. The purpose of either method is
    to return a Hash whose keys are Integers and whose values are the representation
    of those Integers in the module’s language. The resulting Hash’s pairs will form
    our base cases, and we’ll use them very similarly to the ones we used in the `roman_numeral.rb`
    script in [Chapter 5](ch05.html "Chapter 5. Number Utilities"). Then at ❸, we
    define a special replacements method, customized and named for the language. Every
    language is likely to have some special treatment, even beyond what we can do
    with the differences in the Hash returned by `create_english` or `create_spanish`.
    So far, all we need to do is add hyphens to numbers with tens components. To accomplish
    that task, we call the `add_hyphens_to_tens` method, which we define at ❼.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`representable_in_english.rb`和`representable_in_spanish.rb`中定义了适当的模块，位于❶。在这个例子中，我将保持这两个文件中的代码编号提示并行。在❷处，我们定义了`create_english`或`create_spanish`方法。这两个方法的目的是返回一个哈希，其键是整数，其值是这些整数在模块语言中的表示。生成的哈希对将形成我们的基本案例，我们将非常类似于在[第5章](ch05.html
    "第5章。数字工具")中使用的`roman_numeral.rb`脚本中使用它们。然后，在❸处，我们定义了一个特殊替换方法，根据语言定制并命名。每种语言都可能有一些特殊处理，甚至超出了我们通过`create_english`或`create_spanish`返回的哈希差异所能做到的。到目前为止，我们只需要为具有十位数的数字添加连字符。为了完成这个任务，我们调用在❼处定义的`add_hyphens_to_tens`方法。
- en: At ❹ and ❺, we add some of what programmers call *syntactic sugar*, or a simplification
    of a language’s syntax. The term *syntactic* sugar can have a negative connotation,
    but it doesn’t have to. It generally refers to a shortcut that a programmer uses
    to more easily accomplish a commonly needed technique, such as adding method aliases
    with `alias`. It’s relatively easy to add syntactic sugar to Ruby, as our examples
    show. We can add methods like `to_english` or `to_spanish` by calling `to_lang`
    (soon to be defined in `to_lang.rb`) with the appropriate `lang` argument.^([[29](#ftn.CHP-10-FNOTE-2)])
    We can also use `alias` to make `to_en` refer to `to_english`, and `to_es` refer
    to `to_spanish`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在❹和❺处，我们添加了一些程序员所说的*语法糖*，或者是对语言语法的简化。术语*语法糖*可能有负面含义，但并不一定。它通常指的是程序员用来更轻松地完成常用技术的一种快捷方式，例如使用`alias`添加方法别名。正如我们的示例所示，向Ruby添加语法糖相对容易。我们可以通过调用`to_lang`（很快将在`to_lang.rb`中定义）并使用适当的`lang`参数来添加像`to_english`或`to_spanish`这样的方法。我们还可以使用`alias`使`to_en`指向`to_english`，`to_es`指向`to_spanish`。
- en: 'Some of our methods can be private, so we declare that at ❻. We’ve already
    discussed `add_hyphens_to_tens` ❼, so we can move on to `need_ones_in_english`
    and `need_ones_in_spanish` ❽. This method returns a Hash whose keys are Integers
    and whose values are the representation of those Integers in the module’s language.
    This should sound familiar. What makes the pairs in this Hash notable is a characteristic
    they all share: They all need the prefix *one* (in the appropriate language) when
    there is in fact only one of those numbers. The number *100* is pronounced *one
    hundred* in English, for example.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些方法可以是私有的，所以我们声明❻。我们已经讨论了`add_hyphens_to_tens`❼，因此我们可以继续到`need_ones_in_english`和`need_ones_in_spanish`❽。这个方法返回一个哈希，其键是整数，其值是这些整数在模块语言中的表示。这应该听起来很熟悉。使这个哈希中的对值得注意的是它们共有的一个特征：当实际上只有一个这样的数字时，它们都需要（在适当的语言中）前缀*one*。例如，数字*100*在英语中读作*one
    hundred*。
- en: “Of course!” you might think. However, contrast the Hashes returned by `need_ones_in_english`
    ❽ and `dont_need_ones_in_english` ❾. The Integer keys of the Hash created at ❾
    do not need the *one* prefix. You don’t say *one twenty* for *20*, for example,
    so we need a way to differentiate between numbers that need the prefix and those
    that don’t. The different methods at ❽ and ❾ are our way to do so. When we want
    all of them together and when we don’t care about the prefix issue we can simply
    `merge` the two Hashes together. This is exactly what we will do in the `to_lang.rb`
    file, which we’re about to examine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “当然！”你可能这么想。然而，对比`need_ones_in_english`❽和`dont_need_ones_in_english`❾返回的哈希表。在❾处创建的哈希表的整数键不需要`*one*`前缀。例如，你不会说`*one
    twenty*`来表示`20`，所以我们需要一种方法来区分需要前缀的数字和不需要的数字。❽和❾处的不同方法是我们这样做的方式。当我们想要它们全部在一起，并且我们不在乎前缀问题时，我们可以简单地`merge`这两个哈希表。这正是我们将在`to_lang.rb`文件中做的，我们即将要检查这个文件。
- en: The Main Code
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主代码
- en: The first thing we do in `to_lang.rb` is open the Integer class, since we want
    to add new behavior to Integers. At ❶, we `require` the mixin files just discussed,
    and at ❷, we `include` them within the Integer class, giving all Integers the
    methods defined in the mixin files, including both aliases. We also want some
    Constants, mainly for convenient text manipulation, so we define those at ❸. We
    close off the pre-methods section by defining a class variable called `@@lang_of`
    at ❹. It’s a Hash that will eventually store the merged result of the two Hashes
    from the mixins’ markers at ❽ and ❾. Since we define it with `||=`, it is only
    defined in the first Integer instantiated, and then it is shared among all of
    them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`to_lang.rb`中，我们首先打开整数类，因为我们想为整数添加新的行为。在❶处，我们`require`了刚刚讨论的混合文件，并在❷处，我们在整数类中`include`了它们，这样所有的整数都将获得混合文件中定义的方法，包括别名。我们还想定义一些常量，主要是为了方便文本操作，所以在❸处定义了它们。通过定义一个名为`@@lang_of`的类变量来关闭预方法部分，在❹处。它是一个哈希表，最终将存储来自混合标记的❽和❾的两个哈希表的合并结果。由于我们使用`||=`定义它，它只定义在第一个实例化的整数中，然后它被所有整数共享。
- en: At ❺, we define a predicate called `need_ones?`, which takes a `lang` argument
    and simply makes a call to either `need_ones_in_english` (defined in `representable_in_english.rb`)
    or `need_ones_in_spanish` (defined in `representable_in_spanish.rb`), as appropriate
    to the `lang` argument. It doesn’t matter which of the files the called method
    is defined in, because they are both included at ❷ in `to_lang.rb`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在❺处，我们定义了一个名为`need_ones?`的谓词，它接受一个`lang`参数，并根据`lang`参数简单地调用`need_ones_in_english`（在`representable_in_english.rb`中定义）或`need_ones_in_spanish`（在`representable_in_spanish.rb`中定义），适当地处理`lang`参数。调用方法定义在哪个文件中并不重要，因为它们都在`to_lang.rb`的❷处被包含。
- en: Our main workhorse method `to_lang`, appears at ❻; this method takes a single,
    mandatory `lang` argument. It returns early with the `EMPTY_STRING` if `self`
    is zero. This means that if we call `0.to_lang(‘english’)`, we get the empty string
    as the result, instead of the String `‘zero’`. (See [Hacking the Script](ch10s03.html#hacking_the_script-id027
    "Hacking the Script") on page 202 for a way to change that.) Assuming the case
    should proceed beyond that, `to_lang` then sets the value of `@@lang_of[lang]`.
    The `@@lang_of` class variable had already been declared as a Hash when the first
    Integer was instantiated, but only as a Hash with no keys or values. The value
    put into `@@lang_of[lang]` is the result of calling a method called send with
    the argument `“create_#{lang}”`, which you should recognize as an interpolating
    String.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要工作方法`to_lang`出现在❻处；这个方法接受一个单一的、必须的`lang`参数。如果`self`是零，它将提前返回`EMPTY_STRING`。这意味着如果我们调用`0.to_lang('english')`，我们将得到一个空字符串作为结果，而不是字符串`‘zero’`。（有关如何更改此方法的详细信息，请参阅第202页的[Hacking
    the Script](ch10s03.html#hacking_the_script-id027 "Hacking the Script")。）假设情况应该继续下去，`to_lang`然后设置`@@lang_of[lang]`的值。`@@lang_of`类变量已经在第一个整数实例化时被声明为一个哈希表，但只作为一个没有键或值的哈希表。放入`@@lang_of[lang]`的值是调用名为`send`的方法的结果，该方法的参数是`“create_#{lang}”`，你应该能认出这是一个插值字符串。
- en: 'The `send` method takes any number of arguments, the first of which must be
    an expression that evaluates to the name of a method. It then calls that method
    with the rest of the arguments. This allows you to do exactly what we’re doing
    here, which is dynamically calling a method whose name you don’t yet know. You
    could work around this by having a test on the `lang` argument, and there are
    many ways to do so. Instead of a traditional method like `create_english` or `create_spanish`,
    you could use Procs as Hash values, as we’ve done many times since [Chapter 6](ch06.html
    "Chapter 6. Functionalism with Blocks and Procs"). You could also do something
    like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`send` 方法可以接受任意数量的参数，其中第一个参数必须是一个表达式，该表达式评估为方法名。然后，它使用其余参数调用该方法。这允许你做我们在这里做的事情，即动态调用一个你还不了解其名称的方法。你可以通过在
    `lang` 参数上进行测试来解决这个问题，而且有很多方法可以做到这一点。你不必使用像 `create_english` 或 `create_spanish`
    这样的传统方法，而可以使用 Procs 作为哈希值，就像我们在 [第 6 章](ch06.html "第 6 章。使用块和 Procs 的功能主义") 中多次做的那样。你也可以这样做：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we take advantage of the fact that all statements in Ruby return the
    last expression evaluated, including the `if` statement. You have many different
    options for calling a method whose name you don’t know, but the point is that
    it doesn’t need to be that difficult. Ruby provides us with the `send` method,
    which is incredibly useful and appropriate.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们利用了 Ruby 中所有语句都返回最后一个评估表达式的特点，包括 `if` 语句。你有多种不同的方法可以调用一个你不知道其名称的方法，但关键是这不需要那么困难。Ruby
    为我们提供了 `send` 方法，这是一个非常实用且合适的方法。
- en: At this point, `@@lang_of[lang]` will contain the Hash that is the `merge`d
    result of both `need_ones_in_english` and `dont_need_ones_in_english` (for English)
    or `need_ones_in_spanish` and `dont_need_ones_in_spanish` (for Spanish.) Let’s
    take a cue from `send` and express those as `“need_ones_in#{lang}”` and `“dont_need_ones_in#{lang}”`.
    We then want to create some local variables called `base, mult`, and `remaining`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`@@lang_of[lang]` 将包含 `need_ones_in_english` 和 `dont_need_ones_in_english`（对于英语）或
    `need_ones_in_spanish` 和 `dont_need_ones_in_spanish`（对于西班牙语）合并的结果的哈希。让我们从 `send`
    方法中汲取灵感，将其表示为 `“need_ones_in#{lang}”` 和 `“dont_need_ones_in#{lang}”`。然后，我们想要创建一些局部变量，称为
    `base, mult` 和 `remaining`。
- en: The `base` variable is the highest Integer key within `@@lang_of[lang]` that
    is equal to or less than `self`. We get it from the `get_base` method, defined
    at ❽, which finds the first key in a reverse-sorted version of `@@lang_of[lang]`
    that is equal to or less than `self`. It does this via the `detect` method (which
    I like to think of as “find first”). It also has a return guard, where it returns
    `self` if `self` is actually one of the keys of `@@lang_of[lang]`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 变量是 `@@lang_of[lang]` 中最高的整数键，等于或小于 `self`。我们通过 `get_base` 方法获得它，该方法在❽处定义，它通过
    `detect` 方法（我喜欢将其视为“查找第一个”）在 `@@lang_of[lang]` 的逆序版本中找到第一个等于或小于 `self` 的键。它还包含一个返回守卫，如果
    `self` 实际上是 `@@lang_of[lang]` 的键之一，则返回 `self`。'
- en: The `mult` variable is simply how many times `base` can go into `self`, rounded
    down to the nearest Integer. The `remaining` variable is whatever’s left. We then
    want to create `raw_output`, a String that holds the eventual output, before we
    make any of the special replacements already mentioned in [The Two Mixins](ch10s03.html#the_two_mixins
    "The Two Mixins") on page 198\. The `raw_output` String will consist of something
    representing `(base * mult)`, a space, and then the result of making a recursive
    call to `to_lang` on whatever is left (`remaining.to_lang(lang)`).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`mult` 变量简单地表示 `base` 可以进入 `self` 的次数，向下取整到最接近的整数。`remaining` 变量是剩余的部分。然后，在执行任何已提到的特殊替换之前，我们想要创建一个名为
    `raw_output` 的字符串，该字符串将包含最终的输出。`raw_output` 字符串将包含表示 `(base * mult)` 的内容，一个空格，然后是对剩余部分进行递归调用
    `to_lang` 的结果（`remaining.to_lang(lang)`）。'
- en: 'We accomplish that by constructing an Array. The first element is the output
    of a method called `mult_prefix`, defined at ❾; it takes the arguments `base,
    mult`, and `lang`. If `mult` is greater than one, we know we need to have a prefix:
    the number *200* is pronounced *two hundred*, so we need the *two*. If `base`
    needs a one (as described already, pertaining to the `need_ones?` predicate),
    we know that we need to have *one* as a prefix, such as for *one hundred* or *one
    thousand*. Finally, in all other cases, we return a prefix that is the `EMPTY_STRING`,
    so the number *20* is pronounced *twenty* rather than *one twenty*, and *5* is
    *five* rather than *one five*. That’s the multiple prefix and the first part of
    our eventual output.^([[30](#ftn.CHP-10-FNOTE-3)])'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构建一个数组来实现这一点。第一个元素是名为 `mult_prefix` 的方法的输出，该方法定义在❾处；它接受 `base`、`mult` 和
    `lang` 作为参数。如果 `mult` 大于一，我们知道我们需要一个前缀：数字 *200* 读作 *two hundred*，所以我们需要 *two*。如果
    `base` 需要一个一（如前所述，与 `need_ones?` 断言相关），我们知道我们需要一个作为前缀的 *one*，例如在 *one hundred*
    或 *one thousand* 中。最后，在所有其他情况下，我们返回一个空字符串作为前缀，所以数字 *20* 读作 *twenty* 而不是 *one twenty*，而
    *5* 读作 *five* 而不是 *one five*。这就是多个前缀以及我们最终输出的第一部分.^([[30](#ftn.CHP-10-FNOTE-3)])
- en: Next, we need whatever `base` is, as pronounced in `lang`. We get that via `@@lang_of[lang][base]`.
    Finally, we need the rest of the number, which we get via `remaining.to_lang(lang)`.
    This keeps happening recursively, with a smaller Integer calling `to_lang` and
    appending its results, until `base` is `0`. Then `to_lang` returns the `EMPTY_STRING`
    due to its return guard, and the entire output is concatenated together within
    the first calling to `remaining.to_lang`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要 `lang` 中发音的 `base`。我们通过 `@@lang_of[lang][base]` 来获取它。最后，我们需要数字的其余部分，我们通过
    `remaining.to_lang(lang)` 来获取。这会递归地发生，较小的整数调用 `to_lang` 并附加其结果，直到 `base` 为 `0`。然后
    `to_lang` 由于其返回保护而返回空字符串，整个输出在第一次调用 `remaining.to_lang` 时连接在一起。
- en: That’s the Array. You’ll notice that `to_lang` joins that Array on a `SPACE`,
    so that the words in `raw_output` are separated by spaces, which is normal. Before
    we’re done, we want to call our special replacements method (whichever one is
    appropriate for `lang`) on `raw_output`, and `return` the result of doing that.
    Since we again have a method name that depends on `lang`, we’ll use `send`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数组。你会注意到 `to_lang` 在一个 `SPACE` 上连接这个数组，所以 `raw_output` 中的单词由空格分隔，这是正常的。在我们完成之前，我们想在
    `raw_output` 上调用我们的特殊替换方法（适用于 `lang` 的任何一种），并返回执行该操作的结果。由于我们再次有一个依赖于 `lang` 的方法名，我们将使用
    `send`。
- en: The Results
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Let’s take it out for a spin. I’ve written a simple test script called `test_lang.rb`
    that I stored inside the `tests` directory. It uses `Test::Unit::TestCase` again,
    in a manner similar to the way we tested the temperature converter in [Chapter 7](ch07.html
    "Chapter 7. Using, Optimizing, and Testing Functional Techniques"). Here’s its
    code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。我编写了一个简单的测试脚本，名为 `test_lang.rb`，我将其存储在 `tests` 目录中。它再次使用了 `Test::Unit::TestCase`，方式类似于我们在第
    7 章（[第 7 章。使用、优化和测试功能技术](ch07.html "第 7 章。使用、优化和测试功能技术")）中测试温度转换器的方式。以下是它的代码：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And here’s its output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的输出：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hacking the Script
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解脚本
- en: We could modify `to_lang` to allow the pronunciation of zero, instead of returning
    the `EMPTY_STRING` Constant. In order to do that and still work with the recursion,
    we’ll need to send another optional argument into `to_lang` that keeps track of
    the recursion depth (how many levels of recursion we have performed). We only
    care about distinguishing between the first call to `to_lang` and the rest of
    the calls. We could then `return` the `EMPTY_STRING` if `self` is zero and it’s
    the first call to `to_lang`; we can skip the return guard in all other cases.
    We’d also need to change the value for `0` in both `dont_need_ones_in_english`
    and `dont_need_ones_in_spanish`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `to_lang` 修改为允许发音为零，而不是返回 `EMPTY_STRING` 常量。为了做到这一点，并且仍然与递归一起工作，我们需要将另一个可选参数发送到
    `to_lang`，该参数跟踪递归深度（我们执行了多少层递归）。我们只关心区分对 `to_lang` 的第一次调用和其他调用。如果我们返回 `EMPTY_STRING`，则
    `self` 为零并且是 `to_lang` 的第一次调用；我们可以在所有其他情况下跳过返回保护。我们还需要在 `dont_need_ones_in_english`
    和 `dont_need_ones_in_spanish` 中更改 `0` 的值。
- en: '* * *'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[29](#CHP-10-FNOTE-2)]) Note that our definitions of `to_english` and `to_spanish`
    essentially curry `to_lang`, making new curried methods that are simpler to call
    (i.e., that take fewer arguments) by making assumptions, namely which language
    to convert into.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-10-FNOTE-2)]) 注意，我们的 `to_english` 和 `to_spanish` 的定义本质上是对 `to_lang`
    的柯里化，通过做出假设（即转换成哪种语言）来创建新的柯里方法，这些方法更容易调用（即需要更少的参数）。
- en: ^([[30](#CHP-10-FNOTE-3)]) All of these specific examples assume English, of
    course. Substitute the Spanish terms when `lang` is `‘spanish’`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-10-FNOTE-3)]] 当然，所有这些具体的例子都假设是英语。当 `lang` 是 `'spanish'` 时，用西班牙语术语替换。
- en: '#40 Elegant Maps and Injects (symbol.rb)'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#40 优雅的 Maps 和 Injects (symbol.rb)'
- en: I’ll close this chapter with a tiny script that I didn’t even write. I certainly
    wish I had, because it’s remarkably useful, especially for making your use of
    `map, inject`, and similar methods much more elegant. It’s an example of the best
    kind of syntactic sugar, and it comes directly from the Ruby Extensions Project
    at [http://extensions.rubyforge.org](http://extensions.rubyforge.org). This script
    and all other scripts at that site are licensed under the same terms as Ruby itself,
    which is what allows me to use it in this chapter.^([[31](#ftn.CHP-10-FNOTE-4)])
    The code is extremely simple.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以一个我甚至没有写的微小脚本来结束这一章。我当然希望我写了，因为它非常实用，尤其是在使你的 `map, inject` 和类似方法的使用更加优雅方面。这是一个最好的语法糖的例子，它直接来自
    Ruby 扩展项目 [http://extensions.rubyforge.org](http://extensions.rubyforge.org)。这个脚本和该网站上所有的脚本都遵循与
    Ruby 本身相同的许可条款，这就是我能在这一章中使用它的原因。[^[[31](#ftn.CHP-10-FNOTE-4)]] 代码非常简单。
- en: The Code
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What’s the point of this? It lets you use `uc_words = lc_words.map(&:upcase)`
    to accomplish the same thing as `uc_words = lc_words.map { |word| word.upcase
    }`. In both cases, the `uc_words` variable now contains uppercase versions of
    all the words in `lc_words`. As I said, it’s basically just syntactic sugar, but
    it’s very, very nice and clever.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用？它让你可以使用 `uc_words = lc_words.map(&:upcase)` 来完成与 `uc_words = lc_words.map
    { |word| word.upcase }` 相同的事情。在两种情况下，`uc_words` 变量现在都包含了 `lc_words` 中所有单词的大写版本。正如我说的，这基本上只是语法糖，但它非常、非常棒且巧妙。
- en: How It Works
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'First of all, this script creates a Proc using `Proc.new` that takes an object
    called `obj` and a variable number of `args`. Remember from `to_lang.rb` that
    `obj.send(methodname)` is the same as `obj.methodname`, so these are equivalent,
    with an Array `a`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个脚本使用 `Proc.new` 创建了一个 Proc，它接受一个名为 `obj` 的对象和可变数量的 `args`。记得从 `to_lang.rb`
    中，`obj.send(methodname)` 与 `obj.methodname` 相同，所以这些是等效的，有一个数组 `a`：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The remaining arguments (represented by `*args`) are also passed along to `obj`,
    which is using `each` or `map` or some other iterating method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的参数（用 `*args` 表示）也会传递给 `obj`，它正在使用 `each` 或 `map` 或其他迭代方法。
- en: Secondly, you may remember previous discussion about how to convert between
    Procs and blocks using the ampersand (`&`), but we can also use the ampersand
    to cast more than blocks into Procs. Doing so calls a method called `to_proc`,
    which you can see we’ve overridden. We end up using a double character prefix
    of `&:`, because a colon is already the prefix for a Symbol. When we use the expression
    `&:some_name`, what we mean is *the expression returned by the* *`to_proc`* method
    of the Symbol named *`some_name`*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可能还记得之前关于如何使用 ampersand (`&`) 在 Procs 和 blocks 之间进行转换的讨论，但我们也可以使用 ampersand
    将更多东西转换为 Procs。这样做会调用一个名为 `to_proc` 的方法，你可以看到我们已经覆盖了它。我们最终使用双字符前缀 `&:`，因为冒号已经是
    Symbol 的前缀。当我们使用表达式 `&:some_name` 时，我们的意思是 *由名为 *`some_name`* 的 Symbol 的 *`to_proc`*
    方法返回的表达式*。
- en: The Results
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s see it in action in irb.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 irb 中看看它的实际应用。
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hacking the Script
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: This script is already a very elegant hack. Note that you need to use `Proc.new`
    rather than `lambda`, because you want it to be able to handle a variable number
    of `args`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本已经是一个非常优雅的技巧。请注意，你需要使用 `Proc.new` 而不是 `lambda`，因为你希望它能够处理可变数量的 `args`。
- en: '* * *'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[31](#CHP-10-FNOTE-4)]) Those terms are made explicit at [http://www.ruby-lang.org/en/about/license.txt](http://www.ruby-lang.org/en/about/license.txt)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#CHP-10-FNOTE-4)]] 这些术语在 [http://www.ruby-lang.org/en/about/license.txt](http://www.ruby-lang.org/en/about/license.txt)
    中有明确的说明）
- en: Chapter Recap
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节摘要
- en: What was new in this chapter?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章有什么新内容？
- en: Callbacks
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: CVS
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CVS
- en: Mixins in action
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混入（Mixins）的实际应用
- en: Calling methods with variable names via `send`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `send` 调用具有变量名称的方法
- en: Syntactic sugar
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法糖
- en: '`Symbol.to_proc`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbol.to_proc`'
- en: That’s it for this chapter. It tended to focus less on completely new concepts
    and more on new applications for familiar things, but it still managed to introduce
    more than a few novel ideas. The next chapter focuses on web programming, a venue
    in which Ruby has become quite popular.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这一章的全部内容。它更多地关注于熟悉事物的应用，而不是全新的概念，但它仍然引入了几个新颖的想法。下一章将专注于网络编程，这是 Ruby 已经变得相当受欢迎的领域。
