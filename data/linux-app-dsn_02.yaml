- en: '![](../images/31-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/31-1.jpg)'
- en: '[**MANAGING DAEMONS**](toc.html#chapter2)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**管理守护进程**](toc.html#chapter2)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/as.jpg)'
- en: At their core, most appliances have an application or daemon that performs the
    defining function of the appliance, with one or more user interfaces managing
    the core application or daemon. Figure 2-1 shows a typical appliance architecture
    that might already be similar to what you have in mind for your appliance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，大多数设备都有一个应用程序或守护进程执行设备的定义功能，一个或多个用户界面管理核心应用程序或守护进程。图 2-1 显示了一种典型的设备架构，这可能已经与您对设备的想法相似。
- en: In the same way that the defining application is managed by user interfaces
    (UIs), the common services, such as a webserver or system logger, need to be managed
    as well. Because the main application and most common services are implemented
    as daemons, the problem of management comes down to the problem of managing daemons.
    The focus of this chapter is how best to manage daemons.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如定义应用程序是由用户界面（UI）管理一样，常见的服务，如网络服务器或系统日志，也需要进行管理。由于主要应用程序和大多数常见服务都是作为守护进程实现的，因此管理问题归结为管理守护进程的问题。本章的重点是如何最好地管理守护进程。
- en: 'In this chapter, we’ll cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: • Common approaches to managing daemons
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • 管理守护进程的常见方法
- en: • Control and status protocol
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: • 控制和状态协议
- en: '![](../images/32-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/32-1.jpg)'
- en: '*Figure 2-1: Typical user interfaces to an application*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：应用程序的典型用户界面*'
- en: '[**Common Approaches to Managing Daemons**](toc.html#chapter2.1)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[**管理守护进程的常见方法**](toc.html#chapter2.1)'
- en: By *managing* a daemon, we mean configuring the daemon, collecting statistics
    from it, and being able to view its current status. Most Linux daemons use ASCII
    text files for such communication, but there are other options for you to consider
    when building your daemon. The next few sections will describe various daemon-management
    methods and their pros and cons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*管理*守护进程，我们指的是配置守护进程，从它那里收集统计数据，并能够查看其当前状态。大多数 Linux 守护进程使用 ASCII 文本文件进行此类通信，但在构建您的守护进程时，您还有其他选项可以考虑。接下来的几节将描述各种守护进程管理方法及其优缺点。
- en: '[***File-Based Management***](toc.html#chapter2.2)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[***基于文件的管理***](toc.html#chapter2.2)'
- en: Daemons are commonly managed or monitored through a few configuration files
    that control their run-time parameters, status, and logging. For example, the
    DHCP daemon, dhcpd, is controlled by the /etc/dhcpd.conf configuration file; its
    status is displayed in /var/state/dhcp/dhcpd.leases; its start-up script is in
    /etc/rc.d/init.d/dhcpd; and its logs are in /var/log/messages. There is little
    uniformity, however, in how a daemon’s configuration is stored or how its status
    is made available. Status and other state changes are often logged using syslog(),
    but many applications use custom routines for logging and store their log files
    in a non-standard format. Figure 2-2 shows the typical flow of a daemon that uses
    files for configuration and management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程通常通过几个配置文件进行管理或监控，这些文件控制它们的运行时参数、状态和日志。例如，DHCP 守护进程 dhcpd 由 /etc/dhcpd.conf
    配置文件控制；其状态显示在 /var/state/dhcp/dhcpd.leases 中；其启动脚本在 /etc/rc.d/init.d/dhcpd 中；其日志在
    /var/log/messages 中。然而，在守护进程的配置存储方式或其状态如何提供方面，几乎没有一致性。状态和其他状态变化通常使用 syslog() 进行记录，但许多应用程序使用自定义例程进行记录，并将它们的日志文件存储在非标准格式中。图
    2-2 显示了使用文件进行配置和管理的守护进程的典型流程。
- en: 'A file-based approach has the following limitations for appliances:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的方法对设备有以下局限性：
- en: • There is no good way to get status or statistics from most running applications.
    While an application could write status and statistics to files, to do so in real
    time (or anything close to real time) would probably be too heavy a load on the
    CPU and filesystem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 从大多数运行中的应用程序中获取状态或统计数据没有好方法。虽然应用程序可以将状态和统计数据写入文件，但在实时（或接近实时）这样做可能会对 CPU 和文件系统造成过重的负载。
- en: • You need to be able to edit the configuration file, which is not always easy
    on an appliance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要能够编辑配置文件，这在设备上并不总是容易的。
- en: • To apply new settings, you usually have to restart a running daemon, which
    may disrupt service and cause problems for users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 要应用新设置，通常必须重新启动正在运行的守护进程，这可能会中断服务并给用户带来问题。
- en: '![](../images/33-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/33-1.jpg)'
- en: '*Figure 2-2: The most common way to manage a daemon*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：管理守护进程最常见的方式*'
- en: Despite the limitations of file-based interfaces, many applications use them
    for Unix system administration, and they will probably remain popular. If you
    are building a new application and you’ve chosen to use file-based application
    management, consider using libini or an XML parsing library. Also, applications
    like Webmin can help by offering a web front end that allows you to display and
    edit many configuration files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于文件的接口存在局限性，但许多应用程序使用它们进行 Unix 系统管理，并且它们可能会继续保持流行。如果您正在构建新的应用程序，并且您已经选择使用基于文件的程序管理，请考虑使用
    libini 或 XML 解析库。此外，像 Webmin 这样的应用程序可以通过提供允许您显示和编辑许多配置文件的 Web 前端来提供帮助。
- en: Keep in mind that very simple applications (including some daemons) may never
    need run-time access to status, statistics, and configuration. There might not
    be any reason to switch from the traditional .conf and .log file approach of Unix.
    It is up to you to decide which approach is best for your particular application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，非常简单的应用程序（包括一些守护进程）可能永远不需要运行时访问状态、统计信息和配置。可能没有理由从传统的 Unix .conf 和 .log 文件方法切换。决定哪种方法最适合您的特定应用程序取决于您自己。
- en: '[***A Daemon-Based Web Interface***](toc.html#chapter2.3)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[***基于守护进程的 Web 界面***](toc.html#chapter2.3)'
- en: 'Another common approach to daemon management is to offer a web interface directly
    from the daemon. For example, cupsd, the daemon for the print spooler CUPS, provides
    its own web interface on TCP port 631\. This approach is viable for simple daemons,
    but it has two problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的守护进程管理方法是直接从守护进程提供 Web 界面。例如，cupsd 是 CUPS 打印队列守护进程的守护进程，它在 TCP 端口 631
    上提供自己的 Web 界面。这种方法适用于简单的守护进程，但它有两个问题：
- en: • You will need to maintain code in your daemon to support the HTTP implementations
    in many different browsers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: • 您需要在您的守护进程中维护代码以支持许多不同浏览器中的 HTTP 实现。
- en: • It can be difficult to add additional interfaces when they are required.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: • 当需要添加额外的接口时，这可能很困难。
- en: Case in point, we needed run-time access to status and configuration for one
    of our projects, so we added a built-in web interface. What a coding nightmare!
    It seemed to take forever to get all of the details of HTTP right and to make
    the resulting code compatible with all of the major web browsers. If you decide
    to build a web interface directly into your daemon, do yourself a favor and use
    an HTTP library like libhttpd from Hughes Technologies. Because other coders,
    experts in HTTP, keep it up to date regarding the quirks of various browsers,
    your maintenance will be much easier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为例，我们项目中需要运行时访问状态和配置，因此我们添加了一个内置的 Web 界面。多么糟糕的编码噩梦！似乎需要花费很长时间才能正确处理所有 HTTP
    细节，并使生成的代码与所有主要网络浏览器兼容。如果您决定直接在您的守护进程中构建 Web 界面，请自己行个方便，使用 Hughes Technologies
    的 libhttpd 这样的 HTTP 库。因为其他程序员，HTTP 专家，会不断更新有关各种浏览器怪癖的信息，您的维护工作将会容易得多。
- en: This same project also highlights the second problem. Once the web interface
    was working, the customer requested we add an SNMP interface. The fastest way
    to do this was to add SNMP directly to the daemon as we did with the web interface.
    This addition put us well on the path to what we call an “all-in-one” approach,
    which is described in the next section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的项目也突出了第二个问题。一旦 Web 界面开始工作，客户要求我们添加一个 SNMP 接口。最快的方法是将 SNMP 直接添加到守护进程中，就像我们添加
    Web 界面一样。这次添加使我们走上了所谓的“一体化”方法的道路，这在下一节中将有描述。
- en: '[***An All-in-One Approach***](toc.html#chapter2.4)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[***一体化方法***](toc.html#chapter2.4)'
- en: If you know that your users need to interact with your daemon while it is running,
    and if your running daemon needs more than one type of interface, you might be
    tempted to add the necessary interfaces directly to the daemon. Figure 2-3 shows
    a daemon that is not only trying to perform its real task but is also trying to
    support multiple, simultaneous user interfaces.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道您的用户需要在守护进程运行时与之交互，并且您的运行守护进程需要超过一种类型的接口，您可能会倾向于直接将必要的接口添加到守护进程中。图 2-3
    显示了一个不仅试图执行其实际任务，还试图支持多个、同时用户界面的守护进程。
- en: '![](../images/34-1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/34-1.jpg)'
- en: '*Figure 2-3: Adding all the user interfaces directly to the daemon*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：直接将所有用户界面添加到守护进程中*'
- en: We used a bundling approach like this in one of our early designs, but we found
    that it created a lot of problems. Because only a few developers could work on
    the appliance at a time, development became serial, so developers had to code
    both the main daemon and all of the user interfaces. The tight coupling between
    UI and daemon made it more difficult to isolate changes to one section of code.
    We were afraid that even simple user interface changes might have side effects,
    so we made every change wait for the full regression testing of a major release.
    The whole development and release cycle became much slower.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期设计中使用了一种类似的捆绑方法，但我们发现它带来了很多问题。因为一次只能有少数开发者对设备进行操作，所以开发变成了串行，开发者必须同时编写主守护进程和所有用户界面。UI和守护进程之间的紧密耦合使得隔离代码的一个部分变得更加困难。我们担心即使是简单的用户界面更改也可能有副作用，因此我们要求每次更改都要等待主要发布版本的全面回归测试。整个开发和发布周期变得非常缓慢。
- en: Another problem with the all-in-one approach is performance. If all the user
    interfaces run directly from the daemon, the daemon may spend all of its CPU cycles
    in some possibly unimportant interface request while ignoring the real work it
    needs to do.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 全面方法的一个问题是性能。如果所有用户界面都直接从守护进程运行，守护进程可能会将所有的CPU周期都花在一些可能并不重要的接口请求上，而忽略了它需要做的真正工作。
- en: '[**Control and Status Protocols**](toc.html#chapter2.5)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[**控制和状态协议**](toc.html#chapter2.5)'
- en: One way to overcome the limitations of the approaches described above is to
    use a protocol for control and status to separate the daemon from the user interfaces.
    Figure 2-4 illustrates a daemon offering a single application programming interface
    (API) to be used by all of the clients and user interfaces.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 克服上述方法局限性的一个方法是通过控制和状态协议将守护进程与用户界面分离。图2-4展示了守护进程提供一个单一的应用程序编程接口（API），供所有客户端和用户界面使用。
- en: '![](../images/35-1.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/35-1.jpg)'
- en: '*Figure 2-4: Using one protocol between the daemon and user interfaces*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在守护进程和用户界面之间使用一个协议*'
- en: 'A control and status protocol has several advantages over the alternatives:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 控制和状态协议相对于其他替代方案具有几个优点：
- en: '**Reduced complexity for multiple user interfaces**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少多个用户界面的复杂性**'
- en: A control and status protocol simplifies the user interface logic in the daemon,
    since the daemon only needs to implement that protocol. The user interfaces can
    be implemented independently using the languages and tools appropriate to the
    interface. For example, a web interface could be built with Apache and PHP, while
    an SNMP interface could be built with Net-SNMP and C.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制和状态协议简化了守护进程的用户界面逻辑，因为守护进程只需要实现该协议。用户界面可以使用适合该界面的语言和工具独立实现。例如，可以使用Apache和PHP构建Web界面，而SNMP界面则可以使用Net-SNMP和C语言构建。
- en: '**Access to the daemon while it is running**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**在守护进程运行时访问它**'
- en: Users want access to an application while it is running in order to get status,
    statistics, and run-time debugging information. A control and status protocol
    can give you a competitive advantage over applications that are limited to configuration
    file access only at startup and SIGHUP. You might note that Microsoft users do
    not configure a daemon by editing a file; they configure the daemon through the
    daemon itself. Therefore, designing your daemon to be configured in this way can
    make it easier for Microsoft users to migrate to your software.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户希望在应用程序运行时能够访问它，以便获取状态、统计信息和运行时调试信息。控制和状态协议可以使你的应用程序在启动时和SIGHUP信号时仅限于配置文件访问的应用程序中具有竞争优势。你可能已经注意到，Microsoft用户不是通过编辑文件来配置守护进程的；他们通过守护进程本身来配置守护进程。因此，设计你的守护进程以这种方式进行配置可以使Microsoft用户更容易迁移到你的软件。
- en: '**Remote network access**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程网络访问**'
- en: Remote access can speed development and testing, since you can work on the appliance
    from almost any networked workstation. Remote access is useful to your customers
    who manage a large number of appliances from a central operations management center.
    Furthermore, good remote access will be required by your technical support staff
    to help diagnose problems in the field.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 远程访问可以加快开发和测试速度，因为你可以从几乎任何联网的工作站上对设备进行操作。对于管理大量设备的中枢运营管理中心，远程访问对你的客户非常有用。此外，你的技术支持人员也需要良好的远程访问来帮助诊断现场的问题。
- en: '**Parallel development**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行开发**'
- en: 'Decoupling the management user interfaces from the daemon means that you can
    have two teams working on the project in parallel. Staffing is easier because
    you can hire people with just the skills needed to develop a specific piece of
    the project. Separating user interface developers and daemon developers has another
    advantage: It forces you to think through and define your daemon’s interface early
    in the development, when changes are easiest to make.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将管理用户界面与守护进程解耦意味着你可以让两个团队并行工作在项目上。人员配备更容易，因为你可以雇佣只需要开发项目特定部分所需技能的人。将用户界面开发者和守护进程开发者分开还有一个优点：它迫使你在开发早期就考虑并定义你的守护进程接口，那时进行更改最容易。
- en: '**Easy test scaffolding**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单的测试框架**'
- en: Because the user interface is separate from the daemon, building a test scaffold
    around each piece of code is a clean and easy process. Once you build a scaffold,
    you can test even if all the pieces aren’t in place.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户界面与守护进程分离，围绕每段代码构建测试框架是一个干净且简单的过程。一旦构建了框架，即使所有部件尚未就位，你也可以进行测试。
- en: '**Improved security**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强安全性**'
- en: Using a control and status protocol for your daemon can increase the security
    of your appliance in two ways. First, the user interfaces need not run with the
    same special privileges as the daemon, which means that less code with special
    privileges is running at any given time. Second, using a tightly defined protocol
    lets you focus on securing the protocol and its API. This is much easier than
    securing, say, an all-in-one approach.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制和状态协议为你的守护进程可以以两种方式提高你的设备的安全性。首先，用户界面不需要与守护进程运行相同的特殊权限，这意味着在任何给定时间运行的具有特殊权限的代码更少。其次，使用严格定义的协议让你能够专注于保护协议及其API。这比保护，比如说，一个一体化的方法要容易得多。
- en: A control and status protocol can use a serial connection, a Unix or TCP socket,
    or file reads and writes, or it might be hidden in a library call. These techniques
    are described later in this chapter. As a preview, consider the following examples,
    which set a single bit called *cntl_pt*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 控制和状态协议可以使用串行连接、Unix或TCP套接字、文件读写，或者它可能隐藏在库调用中。这些技术将在本章后面进行描述。作为预览，考虑以下示例，它们设置了一个名为*cntl_pt*的单个位。
- en: AT commands ATS301=1
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: AT命令 ATS301=1
- en: XML <rpc><cntrl_pt><value>1</value></cntrl_pt></rpc>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: XML <rpc><cntrl_pt><value>1</value></cntrl_pt></rpc>
- en: Library call ret = set_cntl_pt(1);
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 库调用 ret = set_cntl_pt(1);
- en: /proc echo 1 > /proc/sys/mydev/cntl_pt
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: /proc echo 1 > /proc/sys/mydev/cntl_pt
- en: SQL UPDATE my_table SET cntl_pt = 1
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQL UPDATE my_table SET cntl_pt = 1
- en: '[***Requirements for a Control and Status Protocol***](toc.html#chapter2.6)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[***控制和状态协议的要求***](toc.html#chapter2.6)'
- en: 'If you design your own control and status protocol, you should judge your design
    on the following criteria: its data model on client and daemon, its re-use of
    existing protocols and software, the constraints it places on clients and daemons,
    and the ease with which you can discover its system:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设计自己的控制和状态协议，你应该根据以下标准来评估你的设计：客户端和守护进程的数据模型，对现有协议和软件的重用，对客户端和守护进程施加的约束，以及你发现其系统的容易程度：
- en: '**The data model**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据模型**'
- en: The control and status protocol should allow the client and daemon to have the
    same data model. That is, if the daemon uses variables, structures, lists, and
    arrays, then the client on the other side of the control and status protocol should
    also support variables, structures, lists, and arrays. Having the same data models
    on both sides of the protocol can make it easier to re-use code, and it helps
    programmers maintain a consistent view of the problem they’re trying to solve.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 控制和状态协议应允许客户端和守护进程具有相同的数据模型。也就是说，如果守护进程使用变量、结构、列表和数组，那么控制状态协议另一侧的客户端也应支持变量、结构、列表和数组。在协议的两端具有相同的数据模型可以更容易地重用代码，并帮助程序员保持对试图解决的问题的一致看法。
- en: '**Use existing standards and code**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用现有标准和代码**'
- en: The control and status protocol should use existing software and standards whenever
    possible. You may be able to find developers who already know the protocols and
    software, and existing protocols and software are likely to have good documentation
    for the developers who need to learn them. Using existing code is almost always
    a good idea, since less new code means fewer new bugs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制和状态协议应尽可能使用现有的软件和标准。你可能能够找到已经了解这些协议和软件的开发者，并且现有的协议和软件很可能为需要学习它们的开发者提供了良好的文档。使用现有代码几乎总是好主意，因为新代码越少，新错误就越少。
- en: '**Few constraints on the daemon and clients**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**对守护进程和客户端的限制很少**'
- en: 'Ideally, the protocol would place few constraints on how you design your daemon
    and wouldn’t increase the daemon’s size. You should be able to add the control
    and status protocol to your program with few changes to the main source files.
    When retrofitting old programs with the control and status protocol, you should
    be able to put the bulk of the new code in separate source files, instead of interweaving
    the changes into the main code base. Client binding for your protocol should be
    available for all the major programming languages: at least Java and PHP for web
    interfaces, and C and C++ for compiled code.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，协议应该对您设计守护进程的方式施加很少的限制，并且不会增加守护进程的大小。您应该能够通过在主要源文件中做很少的更改就将控制和状态协议添加到您的程序中。当将控制和状态协议添加到旧程序中时，您应该能够将大部分新代码放入单独的源文件中，而不是将更改交织到主要代码库中。您的协议客户端绑定应该对所有主要编程语言都可用：至少
    Java 和 PHP 用于网络界面，以及 C 和 C++ 用于编译代码。
- en: '**Discovery mechanism**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**发现机制**'
- en: We want to discover the information that is available from the appliance without
    relying on documentation. For example, the ls command discovers which files are
    available in a Unix filesystem; the get-next operator discovers what is in a SNMP
    MIB; and the system tables in a database describe the database itself. In a similar
    way, we want a mechanism whereby a user can discover what can be configured on
    an appliance and what information is available from the appliance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在不依赖文档的情况下发现设备可用的信息。例如，ls 命令可以发现 Unix 文件系统中可用的文件；get-next 操作符可以发现 SNMP MIB
    中的内容；数据库中的系统表描述了数据库本身。以类似的方式，我们希望有一个机制，用户可以通过它发现可以在设备上配置的内容以及设备可提供的信息。
- en: '[***Common Control and Status Protocols***](toc.html#chapter2.7)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[***常见控制和状态协议***](toc.html#chapter2.7)'
- en: In our work we have developed several control and status protocols, which we
    will describe in this section. As you’re reading, try to judge them in terms of
    the four criteria presented in the previous section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作中，我们开发了几个控制和状态协议，我们将在本节中描述它们。在阅读时，请尝试根据前一个章节中提出的四个标准来评估它们。
- en: '**AT Commands**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**AT 命令**'
- en: In our first control and status protocol, we used a variation of the Hayes AT
    command set. The appliance we were working with was a radio modem, so most of
    our customers were already familiar with that command set, making it a logical
    choice. Our daemon listened for incoming TCP connections and offered an AT command
    interpreter to accepted connections. Using TCP gave us remote access for diagnostics
    and configuration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个控制和状态协议中，我们使用了 Hayes AT 命令集的变体。我们正在工作的设备是无线电调制解调器，因此我们的大多数客户已经熟悉该命令集，这使得它成为一个合理的选择。我们的守护进程监听传入的
    TCP 连接，并为已接受的连接提供一个 AT 命令解释器。使用 TCP 给我们提供了远程访问以进行诊断和配置。
- en: We stored the system configuration as a list of AT commands. At system startup
    the daemon would read the configuration file and run it through the AT command
    interpreter. This approach meant that we did not need to add code to process a
    different format for the configuration files. While XML and INI are the standards
    in storing configuration, we did not want to add code and complexity if we could
    easily avoid it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将系统配置存储为 AT 命令列表。在系统启动时，守护进程会读取配置文件并通过 AT 命令解释器运行它。这种方法意味着我们不需要为处理不同格式的配置文件添加代码。虽然
    XML 和 INI 是存储配置的标准，但我们不想在不必要的情况下增加代码和复杂性。
- en: The AT command protocol had two limitations. First, we could not conveniently
    access data arrays using the standard AT S-register syntax. Second, client-side
    programmers had to write a lot of code to generate the AT commands and parse the
    replies.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: AT 命令协议有两个限制。首先，我们无法方便地使用标准的 AT S-register 语法访问数据数组。其次，客户端程序员必须编写大量代码来生成 AT
    命令并解析回复。
- en: '**Extensible Markup Language**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**'
- en: 'We used Extensible Markup Language (XML) as the control and status format in
    a project to manage Juniper routers. Examples of XML protocols include XML-RPC,
    SOAP, and JUNOScript. JUNOScript manages Juniper routers through a telnet or SSH
    connection. It enables you to encode commands in XML, and the router then replies
    with XML responses. For example, a request for the running configuration looks
    like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个项目中使用了可扩展标记语言（XML）作为管理 Juniper 路由器的控制和状态格式。XML 协议的例子包括 XML-RPC、SOAP 和 JUNOScript。JUNOScript
    通过 telnet 或 SSH 连接管理 Juniper 路由器。它允许你使用 XML 编码命令，然后路由器会以 XML 响应回复。例如，请求运行配置看起来像这样：
- en: <rpc>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <rpc>
- en: <get-configuration/>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <get-configuration/>
- en: </rpc>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: </rpc>
- en: Prior to the availability of JUNOScript Juniper routers were configured via
    a command-line interface (CLI). The advantages of XML over CLI become apparent
    when you manage routers with a program rather than by hand (especially if you
    have to write that program). It is easier to write code for parsing XML responses
    than for parsing CLI responses. Other advantages of XML include its flexibility
    in representing rich data and the availability of software libraries for processing
    XML formats.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUNOScript可用之前，Juniper路由器通过命令行界面（CLI）进行配置。当使用程序而不是手动管理路由器时（尤其是当你必须编写该程序时），XML相对于CLI的优势变得明显。解析XML响应的代码比解析CLI响应的代码更容易编写。XML的其他优点包括其在表示丰富数据方面的灵活性以及处理XML格式的软件库的可用性。
- en: Exchanging XML data between a client and server requires the addition of a transport
    protocol. You could use telnet or SSH, like JUNOScript does, or you could use
    HTTP, as specified by the SOAP and XML-RPC standards.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间交换XML数据需要添加传输协议。你可以使用telnet或SSH，就像JUNOScript所做的那样，或者你可以使用SOAP和XML-RPC标准所指定的HTTP。
- en: Typically, you would use a library to parse the XML on the server side, and
    then marshal the parsed XML elements into the server’s internal data structures.
    The code to map the XML to the internal data structures can be complex and error
    prone, since the XML structure seldom maps directly onto the data model used in
    the daemon.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在服务器端使用库来解析XML，然后将解析后的XML元素映射到服务器的内部数据结构中。将XML映射到内部数据结构的代码可能很复杂且容易出错，因为XML结构很少直接映射到守护进程中使用的数据模型。
- en: If you build your control and status protocol using XML, you should consider
    using the Simple API for XML (SAX). SAX uses an event-driven model for processing
    the XML, and it is a better fit for the kinds of dialogs found in a control and
    status protocol.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用XML构建你的控制和状态协议，你应该考虑使用简单的XML API（SAX）。SAX使用事件驱动模型来处理XML，它更适合控制和状态协议中发现的对话类型。
- en: '**Library Calls**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**库调用**'
- en: For another project, we used the popular technique of hiding the protocol from
    the developer by wrapping it in the subroutines of an API. In this case, the daemon
    and client programmers included shared object libraries in their code, and neither
    dealt with the protocol directly. The library routines in the API *became* the
    protocol as far as the developers were concerned. So ubiquitous is this approach
    that many programmers cannot imagine an alternative. They start a project with
    the assumption that they’ll build a daemon and a library, and clients of the daemon
    must include the library in order to talk to the daemon.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于另一个项目，我们使用了流行的技术，通过将协议封装在API的子例程中来隐藏协议，从而避免开发者直接接触协议。在这种情况下，守护进程和客户端程序员在他们的代码中包含了共享对象库，并且都没有直接处理协议。对于开发者来说，API中的库例程*变成了*协议。这种方法如此普遍，以至于许多程序员无法想象有其他替代方案。他们开始一个项目时，假设他们将构建一个守护进程和一个库，而守护进程的客户端必须包含该库才能与守护进程通信。
- en: Our advice is to let other programmers write libraries and to avoid it yourself.
    Most of the reasons for saying this distill down to minimizing the number of lines
    of code you have to write and maintain. Hiding the protocol in a library API does
    not remove the need to code the protocol and library. You still need to think
    about which IPC to use and the actual protocol to use over that IPC. Perhaps the
    biggest burden is writing and maintaining the client-side libraries for all of
    the programming languages of interest—gone are the days when you could write a
    C library and be done. You’ll want the library available in Java and PHP for web
    interfaces, and in Perl and as a shell command for scripts and testing. Few companies
    have all the experts on staff that are needed to write and document these libraries,
    and fewer still have the time to properly maintain and update the libraries after
    each revision change.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是让其他程序员编写库，而你自己避免这样做。大多数说这个的理由归结为最小化你必须编写和维护的代码行数。在库API中隐藏协议并不能消除编写协议和库的需要。你仍然需要考虑使用哪种IPC以及在该IPC上使用哪种实际协议。可能最大的负担是编写和维护所有感兴趣编程语言的客户端库——那些可以编写C库并完成所有工作的日子已经过去了。你希望库在Java和PHP中可用，用于Web界面，以及在Perl和shell命令中用于脚本和测试。很少有公司拥有编写和记录这些库所需的所有专家，更少的公司有时间和资源在每次修订更改后正确维护和更新库。
- en: We’ve gone the route of trying to write libraries for our daemons, and one of
    the things we found was that we kept reinventing the wheel. Every library, no
    matter how similar to the previous, was written for the daemon at hand, so we
    had to write a different library for every daemon. While we tried to re-use code,
    this process fell far short of ideal. How nice it would have been to have just
    one library (and one underlying protocol) that we could have used for all of our
    daemons.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试为我们的守护进程编写库，我们发现我们一直在重复造轮子。每个库，无论与之前的相似程度如何，都是为当前的守护进程编写的，因此我们必须为每个守护进程编写不同的库。虽然我们试图重用代码，但这个过程远远达不到理想状态。如果只有一个库（以及一个底层协议）我们可以用于所有守护进程，那该有多好。
- en: Having one library per daemon is particularly problematic for embedded systems,
    in that you may have to give up a lot of system RAM in order to load all the libraries
    needed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入式系统来说，每个守护进程有一个库尤其成问题，因为你可能不得不放弃大量的系统RAM来加载所有需要的库。
- en: '**Structured Query Language**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**'
- en: In an attempt to have just one control and status protocol for all of our daemons,
    we tried Structured Query Language (SQL) text commands over TCP and modeled the
    data in our daemon as tables in a database. The daemon accepted a TCP connection
    and presented an SQL command line interpreter to the client. This protocol allowed
    us to represent arrays (and lists) in the control and status protocol, thus solving
    one of the limitations of the AT command protocol. Figure 2-5 illustrates the
    basic idea.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有守护进程只有一个控制和状态协议，我们尝试在TCP上使用结构化查询语言（SQL）文本命令，并将我们守护进程中的数据建模为数据库中的表。守护进程接受TCP连接并向客户端提供了一个SQL命令行解释器。此协议使我们能够在控制和状态协议中表示数组（和列表），从而解决了AT命令协议的一个限制。图2-5说明了基本思想。
- en: '![](../images/39-1.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/39-1.jpg)'
- en: '*Figure 2-5: SQL as a control and status protocol*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：SQL作为控制和状态协议*'
- en: 'For example, a typical command over the TCP connection might be the string:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，TCP连接上的典型命令可能是以下字符串：
- en: SELECT Column_A FROM Table_A
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT Column_A FROM Table_A
- en: The command interpreter was then responsible for parsing the SQL string and
    accessing the appropriate “table.” Table is in quotations because the data in
    the daemon could be represented by arbitrary data structures, and it was the responsibility
    of the SQL interpreter to make these arbitrary data structures appear as tables
    to the client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那时，命令解释器负责解析SQL字符串并访问适当的“表”。表用引号括起来，因为守护进程中的数据可以表示为任意数据结构，而将任意数据结构呈现为表格是SQL解释器的责任。
- en: Similar to the AT control and status protocol, our configuration files were
    stored as text files with SQL commands; this eliminated the need for libraries
    to parse XML or INI files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与AT控制和状态协议类似，我们的配置文件存储为包含SQL命令的文本文件；这消除了解析XML或INI文件的需要。
- en: The best part of this approach was that the data in the daemon was already stored
    as arrays of structs, so the shift to a “table” paradigm was trivially easy for
    the programmers. The limitation of this protocol was the amount of code that had
    to be developed on the user interface or client side. Because the protocol was
    text based, we had to write client-side code to format and send the request and
    to parse the response. This code had to be rewritten for each programming language
    that the particular client was written in. In our case, there was significant
    effort required because we developed a Windows C++ client, a Java client, a Mac
    OS 9 C client, and a Linux C client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最好部分是，守护进程中的数据已经以结构体的数组形式存储，因此对于程序员来说，转向“表”范式是极其容易的。这种协议的限制在于用户界面或客户端必须开发的代码量。因为该协议是基于文本的，我们必须编写客户端代码来格式化和发送请求以及解析响应。这些代码必须为特定客户端编写的每种编程语言重写。在我们的案例中，需要大量的努力，因为我们开发了Windows
    C++客户端、Java客户端、Mac OS 9 C客户端和Linux C客户端。
- en: '**PostgreSQL**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**PostgreSQL**'
- en: Our final control and status protocol overcomes the limitations of the previous
    one. It is similar to our SQL protocol in that it models the daemon’s data as
    tables in a database and it uses TCP or Unix sockets between the daemon and the
    client. The difference is that instead of a proprietary text-based protocol, it
    uses the PostgreSQL protocol. Using PostgreSQL means we can use the client-side
    PostgreSQL binding for C, Java, PHP, bash, and many others.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的控制和状态协议克服了之前协议的限制。它在某种程度上类似于我们的SQL协议，因为它将守护程序的数据建模为数据库中的表，并在守护程序和客户端之间使用TCP或Unix套接字。区别在于，它使用的是PostgreSQL协议，而不是专有的基于文本的协议。使用PostgreSQL意味着我们可以使用C、Java、PHP、bash等客户端的PostgreSQL绑定。
- en: All of the hard work of offering up a daemon’s internal data structures as database
    tables is handled by a library called *Run-Time Access (RTA)*. We link our daemons
    with the RTA library, and after the daemons tell RTA about our tables, it offers
    them up as PostgreSQL database tables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将守护程序的内部数据结构作为数据库表提供出来的所有艰苦工作都由一个名为*运行时访问（RTA）*的库来处理。我们将我们的守护程序与RTA库链接，在守护程序告诉RTA关于我们的表之后，它将它们作为PostgreSQL数据库表提供出来。
- en: Although RTA uses PostgreSQL as the control and status protocol, it is *not*
    a database. Rather, it uses a subset of the PostgreSQL protocol and client-side
    bindings as a means of reading and writing memory variables in a running daemon.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然RTA使用PostgreSQL作为控制和状态协议，但它**不是**一个数据库。相反，它使用PostgreSQL协议的一个子集和客户端绑定，作为在运行中的守护程序中读取和写入内存变量的手段。
- en: PostgreSQL and RTA have several advantages as a control and status protocol.
    As mentioned, there are a number of PostgreSQL bindings already available in various
    languages, including C, C++, Java, Perl, Tcl, and Python. The availability of
    these bindings means that you will have less code to develop on the UI or client,
    so you are less constrained in how you write your UI clients. PostgreSQL has a
    liberal license and is exceptionally well documented, and the system tables in
    RTA can be used as a way to browse the data offered to the UI programs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL和RTA作为控制和状态协议具有几个优势。如前所述，已经有一些PostgreSQL绑定在各种语言中可用，包括C、C++、Java、Perl、Tcl和Python。这些绑定的可用性意味着您在UI或客户端上的开发代码将更少，因此您在编写UI客户端时受到的限制更少。PostgreSQL具有宽松的许可证，并且文档非常完善，RTA的系统表可以用作浏览提供给UI程序的数据的方式。
- en: Security can be enhanced by using a Unix socket and setting the ownership and
    read/write permissions carefully. Use SELinux and the Linux Security Module for
    even more precise control over which programs can connect to RTA on the daemon.
    Consider using Stunnel or SSH with port forwarding for secure remote access.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Unix套接字并仔细设置所有权和读写权限，可以提高安全性。使用SELinux和Linux安全模块，可以对连接到守护程序上的RTA的程序进行更精确的控制。考虑使用Stunnel或SSH与端口转发来实现安全的远程访问。
- en: While XML is popular, RTA and PostgreSQL have a few advantages over it. PostgreSQL
    offers both a data exchange format and a transport protocol. With RTA, you don’t
    need to marshal code to map the tree structure of XML into the daemon’s internal
    data structures, so the RTA approach requires less development than XML-based
    approaches. With RTA, the client can look directly at the daemon’s internal memory
    variables, and this functionality requires no additional development.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然XML很流行，但RTA和PostgreSQL相对于它有一些优势。PostgreSQL提供了一种数据交换格式和传输协议。使用RTA，您不需要将代码序列化以将XML的树结构映射到守护程序的内部数据结构，因此RTA方法比基于XML的方法需要更少的开发。使用RTA，客户端可以直接查看守护程序的内部内存变量，并且这种功能不需要额外的开发。
- en: 'RTA is presented in greater detail in the next chapter, but a simple example
    might show how RTA works as seen from the UI client. Suppose that the daemon has
    an array of the following structures:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: RTA将在下一章中更详细地介绍，但一个简单的示例可以展示RTA从UI客户端的角度是如何工作的。假设守护程序有一个以下结构的数组：
- en: '![](../images/41-1.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](../images/41-1.jpg)'
- en: 'After telling RTA about the array (with rta_add_table()) you can use any PostgreSQL-enabled
    client to read and write data in the array. If you use psql, a PostgreSQL shell
    program, you can read the Zone table with the following SELECT command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在向RTA告知数组（使用rta_add_table()）之后，您可以使用任何启用了PostgreSQL的客户端来读取和写入数组中的数据。如果您使用psql，一个PostgreSQL外壳程序，您可以使用以下SELECT命令读取区域表：
- en: '![](../images/41-2.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](../images/41-2.jpg)'
- en: This example shows a simple way to read variables from a running daemon.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了从运行中的守护程序读取变量的简单方法。
- en: There are some disadvantages to RTA. One is that the RTA library is written
    in C, which means that you can’t use RTA if your server process is written in
    another language—say, Java. Another disadvantage is that if your appliance is
    composed of multiple daemons, you’ll need to develop a management process to manage
    these daemons, while exposing only a *single* management point to the clients.
    To be fair, this last disadvantage is true of all control and status protocols.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: RTA有一些缺点。其中之一是RTA库是用C语言编写的，这意味着如果你的服务器进程是用另一种语言编写的——比如说Java，你就无法使用RTA。另一个缺点是，如果你的设备由多个守护进程组成，你需要开发一个管理过程来管理这些守护进程，同时只向客户端暴露一个*单一*的管理点。公平地说，这个最后一个缺点适用于所有控制和状态协议。
- en: '[**Summary**](toc.html#chapter2.8)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter2.8)'
- en: In this chapter we discussed various ways to manage daemons. Simple daemons
    can use files for all management, but we believe that for Linux appliances with
    multiple user interfaces, a control and status protocol is best. We described
    the reasons to use a control and status protocol and presented some guidelines
    to follow if you decide to build your own.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了管理守护进程的各种方法。简单的守护进程可以使用文件进行所有管理，但我们认为对于具有多个用户界面的Linux设备，控制和状态协议是最好的。我们描述了使用控制和状态协议的原因，并提出了如果你决定自己构建时需要遵循的一些指南。
- en: In the next chapter we’ll show you how to incorporate RTA into a daemon so that
    the client has access to the daemon’s status, configuration, and statistics.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何将RTA集成到守护进程中，以便客户端可以访问守护进程的状态、配置和统计信息。
- en: All of the examples used in the remainder of the book use PostgreSQL and the
    RTA library as the management protocol between daemons and user interfaces. Don’t
    be concerned if you choose not to use RTA, though. The book is more about appliance
    *design* than using particular libraries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本书余下的所有示例都使用PostgreSQL和RTA库作为守护进程和用户界面之间的管理协议。尽管如此，如果你选择不使用RTA，也无需担心。本书更多地关注设备*设计*，而不是使用特定的库。
