- en: Chapter 4. PICTURE UTILITIES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。图片工具
- en: '![PICTURE UTILITIES](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片工具](../Images/00001.jpg)'
- en: Photography is a wonderful hobby. It happens to be one of mine, and since I'm
    a techie, I have a monster Digital Single-Lens Reflex (DSLR) camera. I take tons
    of pictures with it and enjoy the digital editing involved afterward. But I have
    found that I take many more pictures with my digital camera than I did with my
    traditional film camera. The scripts in this chapter help me manage the daunting
    task of editing, converting, and resizing my vast photo collection. To edit 500
    pictures one at a time would take days, but with a few tweaks to these scripts,
    that time is cut down to mere minutes. Break out your photos and let's start editing!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 摄影是一项美好的爱好。碰巧这也是我的爱好之一，而且作为一个技术爱好者，我有一台超级数码单反相机（DSLR）。我用它拍了大量的照片，并享受之后的数字编辑过程。但我发现，我用数码相机拍的照片比用传统胶片相机拍的多得多。本章中的脚本帮助我管理编辑、转换和调整大量照片的艰巨任务。逐个编辑500张照片需要好几天，但通过调整这些脚本，时间可以缩短到几分钟。拿出你的照片，让我们开始编辑吧！
- en: Mass Editing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量编辑
- en: Mass Editing
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量编辑
- en: massEdit.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: massEdit.rb
- en: All right, I mentioned that I like to take pictures. I mean, I *really* like
    to take pictures, and I have gigabytes of photographs to prove it. If I needed
    to manipulate all of them in some way, such as renaming, performing that action
    on each picture individually would be very time consuming. This script will take
    a group of pictures and rename them numerically to something more manageable than
    *DSC_0127.JPEG*; work that would have taken a week now takes just minutes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我提到我喜欢拍照。我是说，我真的很喜欢拍照，我有数吉字节的照片来证明这一点。如果需要以某种方式（如重命名）处理所有这些照片，那么逐个对每张照片执行该操作将会非常耗时。这个脚本将一组照片按数字顺序重命名，使其比
    *DSC_0127.JPEG* 更易于管理；原本需要一周的工作现在只需几分钟。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) unless ARGV[0]      puts "\n\n\nYou need to specify
    a filename:  massEdit.rb <filename>\n\n\n"      exit  end  ![](../Images/00003.jpg) name
    = ARGV[0]  x=0  ![](../Images/00004.jpg)  Dir[''*.[Jj][Pp]*[Gg]''].each do |pic|
    ![](../Images/00005.jpg)      new_name = "#{name}_#{"%.2d" % x+=1}#{File.extname(pic)}"
         puts "Renaming #{pic} ---> #{new_name}" ![](../Images/00006.jpg)     File.rename(pic,
    new_name)  end`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) 除非 ARGV[0] puts "\n\n\n你需要指定一个文件名： massEdit.rb <filename>\n\n\n"
    exit  end  ![](../Images/00003.jpg) name = ARGV[0]  x=0  ![](../Images/00004.jpg)
     Dir[''*.[Jj][Pp]*[Gg]''].each do |pic| ![](../Images/00005.jpg)      new_name
    = "#{name}_#{"%.2d" % x+=1}#{File.extname(pic)}"      puts "重命名 #{pic} ---> #{new_name}"
    ![](../Images/00006.jpg)     File.rename(pic, new_name)  end`'
- en: Running the Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Let''s assume you have a directory full of pictures from a Jamaican vacation.
    Presumably you''d want to rename the photos from *DSC_0*XXX.*jpeg* to *Jamaica*XX.*jpeg*.
    Make sure the script is in the directory that contains the pictures you want to
    rename and type the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个装满了牙买加度假照片的目录。你可能会想将照片从 *DSC_0*XXX.*jpeg* 重命名为 *Jamaica*XX.*jpeg*。确保脚本位于包含你想要重命名的照片的目录中，并输入以下内容：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Results
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '``Renaming *`DSC_0001.jpeg ---> Jamaica01.jpeg`* Renaming *`DSC_0002.jpeg --->
    Jamaica02.jpeg`* Renaming *`DSC_0003.jpeg ---> Jamaica03.jpeg`* Renaming *`DSC_0004.jpeg
    ---> Jamaica04.jpeg`* Renaming *`DSC_0005.jpeg ---> Jamaica05.jpeg`* Renaming
    *`DSC_0006.jpeg ---> Jamaica06.jpeg`* Renaming *`DSC_0007.jpeg ---> Jamaica07.jpeg`*
    Renaming *`DSC_0008.jpeg ---> Jamaica08.jpeg`* [...]``'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '``重命名 *`DSC_0001.jpeg ---> Jamaica01.jpeg`* 重命名 *`DSC_0002.jpeg ---> Jamaica02.jpeg`*
    重命名 *`DSC_0003.jpeg ---> Jamaica03.jpeg`* 重命名 *`DSC_0004.jpeg ---> Jamaica04.jpeg`*
    重命名 *`DSC_0005.jpeg ---> Jamaica05.jpeg`* 重命名 *`DSC_0006.jpeg ---> Jamaica06.jpeg`*
    重命名 *`DSC_0007.jpeg ---> Jamaica07.jpeg`* 重命名 *`DSC_0008.jpeg ---> Jamaica08.jpeg`*
    [...]``'
- en: How It Works
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Renaming files has to be one of the most common headaches I've dealt with throughout
    my digital photography career. This script is a really big aspirin to relieve
    the pain. The script starts by using the standard usage/error message to clue
    the user in on the proper command-line arguments ![](../Images/00002.jpg). The
    script expects you to assign a generic name for all the pictures. For the purposes
    of this example, I renamed several pictures from a trip to Jamaica, so it only
    made sense to make the generic name *Jamaica*. Now that `name` is set to the generic
    picture name *Jamaica*, the variable `x` is initialized to represent the trailing
    numbers on each photograph ![](../Images/00003.jpg).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名文件肯定是我整个数码摄影生涯中遇到的最常见的头痛问题之一。这个脚本真的是一个很大的阿司匹林，可以缓解痛苦。脚本首先使用标准的用法/错误消息来提示用户正确的命令行参数
    ![图片](../Images/00002.jpg)。脚本期望你为所有图片分配一个通用名称。为了这个示例，我将从牙买加之旅中重命名了几张图片，所以将通用名称命名为
    *Jamaica* 只是有道理的。现在 `name` 已经设置为通用图片名称 *Jamaica*，变量 `x` 被初始化以表示每张照片上的尾随数字 ![图片](../Images/00003.jpg)。
- en: I decided to use the `Dir::glob` method (in the form of the shortcut `Dir::[]`)
    in this script ![](../Images/00004.jpg). The importance of `Dir::glob` can be
    seen in the expression I used to hunt for each photograph in the directory. I
    always put groups of pictures in the same folder, and running this script in that
    folder will capture every picture. In English, `*.[Jj][Pp]*[Gg]` is saying that
    every file ending in a variation of *JPEG* should be manipulated. If you don't
    believe me, create four pictures with the extensions *jpg, jpeg, JPG*, and *JPEG*.
    The `Dir::glob` will get them all, and that is great for flexibility! The `Dir::glob`
    returns an array, so the `each` method is used to iterate through each discovered
    picture. The hard part was finding all the pictures; all that's left now is to
    rename them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定在这个脚本中使用 `Dir::glob` 方法（以快捷方式 `Dir::[]` 的形式）。`Dir::glob` 的重要性可以从我用来在目录中查找每张照片的表达式中看出。我总是将图片分组放在同一个文件夹中，在这个文件夹中运行这个脚本将捕获所有图片。用英语来说，`*.[Jj][Pp]*[Gg]`
    表示所有以 *JPEG* 变体结尾的文件都应该被处理。如果你不相信我，创建四个扩展名为 *jpg, jpeg, JPG*, 和 *JPEG* 的图片。`Dir::glob`
    会获取所有这些文件，这对于灵活性来说是非常好的！`Dir::glob` 返回一个数组，因此使用 `each` 方法遍历每个发现的图片。难点在于找到所有图片；现在剩下的只是重命名它们。
- en: I used a simple convention when renaming the pictures. The new filename is constructed
    from the object returned by the `File.extname` method, `name`, an underscore,
    and then a numeric value ![](../Images/00005.jpg). The `File.extname` method may
    not be obvious in its function; it simply grabs the file extension of the picture
    being renamed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在重命名图片时，我使用了简单的约定。新文件名由 `File.extname` 方法返回的对象、`name`、一个下划线和然后是一个数值组成 ![图片](../Images/00005.jpg)。`File.extname`
    方法的功能可能并不明显；它只是简单地获取正在重命名的图片的文件扩展名。
- en: You may be asking yourself, "Why did he bother adding that crazy `x` incrementing
    piece ![](../Images/00005.jpg)"? Good question. Some operating systems aren't
    intelligent enough to know that *Jamaica10.jpeg* is the tenth photo in a series
    of pictures and not the second. So, I have succumbed to the operating systems'
    will and made the picture names have two numbers to ensure sequential display.
    If you are going to be renaming more than 99 photos, you'll want to change the
    `%.2d` to `%.3d`, which adds a third placeholder, for the hundreds place.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己在想，“他为什么要费劲添加那个疯狂的 `x` 增量部分 ![图片](../Images/00005.jpg)”？这是个好问题。有些操作系统并不足够智能，不知道
    *Jamaica10.jpeg* 是一系列图片中的第十张，而不是第二张。因此，我屈服于操作系统的意愿，让图片名称具有两个数字以确保顺序显示。如果你要重命名超过99张图片，你需要将
    `%.2d` 改为 `%.3d`，这样就会增加一个三位数的占位符，用于百位。
- en: After the name has been set and saved to the `new_name` variable, the script
    prints out the old filename and the new filename as a courtesy to the user. To
    execute the rename, the `File.rename` method is used with the original filename
    as the first parameter and the new filename as the second parameter ![](../Images/00006.jpg).
    That's all there is to mass file renaming!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称设置并保存到 `new_name` 变量之后，脚本会出于礼貌打印出旧文件名和新文件名。要执行重命名，使用 `File.rename` 方法，将原始文件名作为第一个参数，新文件名作为第二个参数
    ![图片](../Images/00006.jpg)。这就是所有批量文件重命名的全部内容！
- en: Image Information Extraction
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片信息提取
- en: Image Information Extraction
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片信息提取
- en: imageInfo.rb
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: imageInfo.rb
- en: There is a wealth of information about a digital picture stored within the file
    itself. Some of the picture's data, such as colors, resolution, exposure, and
    flash settings, can be useful as you learn your craft. This script will help you
    pull the data out of your pictures for further analysis, giving insight into your
    best (and worst) shots.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数字图片文件本身存储了大量的信息。其中一些图片数据，如颜色、分辨率、曝光和闪光设置，在你学习技艺时可能很有用。此脚本将帮助你从图片中提取数据以进行进一步分析，从而深入了解你最佳（和最差）的拍摄效果。
- en: The Code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''exifr''  include EXIFR  ![](../Images/00003.jpg) unless
    ARGV[0] and File.exists?(ARGV[0])      puts "\n\n\nYou need to specify a filename:
     ruby imageInfo.rb <filename>"      exit  end   ![](../Images/00004.jpg) info
    = JPEG.new(ARGV[0])  ![](../Images/00005.jpg) File.open("info_#{File.basename(ARGV[0])}.txt",
    "w") do |output| ![](../Images/00006.jpg)     output.puts info.exif.to_hash.map{
    |k,v| "#{k}: #{v}"}  end`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''exifr''  ![](../Images/00003.jpg) include
    EXIFR  ![](../Images/00004.jpg) unless ARGV[0] and File.exists?(ARGV[0])   ![](../Images/00005.jpg)
    puts "\n\n\n你需要指定一个文件名：ruby imageInfo.rb <filename>"   ![](../Images/00006.jpg)
    exit  end   ![](../Images/00007.jpg) info = JPEG.new(ARGV[0])  ![](../Images/00008.jpg)
    File.open("info_#{File.basename(ARGV[0])}.txt", "w") do |output|   ![](../Images/00009.jpg)
    output.puts info.exif.to_hash.map{ |k,v| "#{k}: #{v}"}  end`'
- en: Running the Code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'This script takes an image file as input and returns a detailed text file that
    lists all of the available information stored within the image. In this example,
    I used a Nikon D50 DSLR camera image. Type the following to run the script:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本接受一个图像文件作为输入，并返回一个详细的文本文件，列出图像中存储的所有可用信息。在这个例子中，我使用了尼康D50 DSLR相机的图像。输入以下内容以运行脚本：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`Image Description: Make:                       NIKON CORPORATION Model:  
                       NIKON D50 Orientation:                EXIFR::TIFF::TopLeftOrientation
    X Resolution:               300 Y Resolution:               300 Resolution unit:
               2 Software:                   Ver.1.00 Date & Time:                Sat
    Jun 02 13:40:26 +0400 2007 YCB cr positioning:         2 sensing_method:      
          2 color_space:                1 metering_mode:              5 x_resolution:
                  300 white_balance:              0 f_number:                   9
    saturation:                 0 pixel_x_dimension:          3008 light_source:  
                0 date_time_original:         Wed Sep 12 05:52:34 -0400 2007 y_resolution:
                  300 resolution_unit:            2 digital_zoom_ratio:         1
    subsec_time:                70 exposure_program:           0 ycb_cr_positioning:
            2 sharpness:                  0 pixel_y_dimension:          2000 flash:
                         0 date_time_digitized:        Wed Sep 12 05:52:34 -0400 2007
    make:                       NIKON CORPORATION focal_length_in_35mm_film:  82 subsec_time_original:
          70 exposure_bias_value:        0 focal_length:               55 model:  
                       NIKON D50 software:                   Ver.1.00 scene_capture_type:
            0 subsec_time_digitized:      70 max_aperture_value:         5 subject_distance_range:
        0 custom_rendered:            0 compressed_bits_per_pixel:  4 date_time:  
                   Wed Sep 12 05:52:34 -0400 2007 gain_control:               0 exposure_mode:
                 0 exposure_time:              1/320`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`图像描述：制造商：NIKON CORPORATION 模型：NIKON D50 方向：EXIFR::TIFF::TopLeftOrientation
    X 分辨率：300 Y 分辨率：300 分辨率单位：2 软件：Ver.1.00 日期和时间：Sat Jun 02 13:40:26 +0400 2007 YCB
    cr 定位：2 感应方法：2 颜色空间：1 测光模式：5 x 分辨率：300 白平衡：0 光圈：9 饱和度：0 像素X尺寸：3008 光源：0 原始日期和时间：Wed
    Sep 12 05:52:34 -0400 2007 y 分辨率：300 分辨率单位：2 数码变焦比率：1 子秒时间：70 曝光程序：0 YCB cr 定位：2
    锐度：0 像素Y尺寸：2000 闪光：0 数字化日期和时间：Wed Sep 12 05:52:34 -0400 2007 制造商：NIKON CORPORATION
    35mm胶片等效焦距：82 子秒时间原始：70 曝光偏差值：0 焦距：55 模型：NIKON D50 软件：Ver.1.00 场景捕获类型：0 子秒时间数字化：70
    最大光圈值：5 主题距离范围：0 自定义渲染：0 压缩每像素比特数：4 日期和时间：Wed Sep 12 05:52:34 -0400 2007 增益控制：0
    曝光模式：0 曝光时间：1/320`'
- en: How It Works
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: How about that for information hidden in a digital photograph? The information
    isn't really hidden; it's placed in an image according to the *Exchangeable Image
    File Format (EXIF)*. In addition to the information listed above, geographic information
    can also be included in the EXIF section of the image file if the camera has GPS
    capabilities. Every camera writes to its images differently, so check your camera
    for the specifics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数字照片中隐藏的信息怎么样？这些信息并不是真正隐藏的；它们是根据*可交换图像文件格式（EXIF）*放置在图像中的。除了上述信息外，如果相机具有GPS功能，地理信息也可以包含在图像文件的EXIF部分。每个相机对其图像的写入方式都不同，所以请检查你的相机以获取具体信息。
- en: This script relies on the exifr library to retrieve the important data in the
    image, so the library is required ![](../Images/00002.jpg). This script also contains
    an `include` statement that prevents us from having to type `EXIFR` in front of
    every `exifr` method call. Next is the command-line argument verification ![](../Images/00003.jpg).
    The `unless` statement verifies that a file was included at the command line and
    that it is actually a file. Command-line arguments make script execution a bit
    more streamlined, which is why you see them used so frequently throughout this
    book. If a command-line argument is provided and the file exists, then the script
    creates a new `JPEG` object called `info` ![](../Images/00004.jpg).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本依赖于exifr库来检索图像中的重要数据，因此需要该库！![图片](../Images/00002.jpg)。此脚本还包含一个`include`语句，它防止我们在每次调用`exifr`方法时前面都要写`EXIFR`。接下来是命令行参数验证！![图片](../Images/00003.jpg)。`unless`语句验证是否在命令行中包含文件，并且它确实是一个文件。命令行参数使脚本执行更加流畅，这就是为什么你会在整本书中频繁看到它们的使用。如果提供了命令行参数并且文件存在，则脚本创建一个新的名为`info`的`JPEG`对象！![图片](../Images/00004.jpg)。
- en: The next step is an exercise in writing to a file, which you may recall from
    previous chapters. I've condensed the code section to a few lines. Instead of
    initializing a new `File` object, saving it to a variable, then directing output
    to the variable, I just pass the `File` object as part of the code block ![](../Images/00005.jpg).
    Because of the differences with each camera's EXIF output, not all of the available
    fields will be used. For example, if your camera does not support the GPS feature,
    then all of those fields will be blank. I chose to use the `to_hash` function
    in conjunction with `map` to convert the EXIF output to something easily readable
    ![](../Images/00006.jpg). In the results, the empty fields are removed because
    `nil` attributes don't concern us. You can modify the output to display the fields,
    but I omit them here for brevity's sake.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向文件写入的练习，你可能还记得之前章节中的内容。我已经将代码部分缩减为几行。不是初始化一个新的`File`对象，将其保存到变量中，然后将输出定向到变量，我只是将`File`对象作为代码块的一部分传递！![图片](../Images/00005.jpg)。由于每个相机的EXIF输出不同，并非所有可用的字段都会被使用。例如，如果你的相机不支持GPS功能，那么所有这些字段都将为空。我选择使用`to_hash`函数与`map`一起将EXIF输出转换为易于阅读的内容！![图片](../Images/00006.jpg)。在结果中，空字段被移除，因为`nil`属性与我们无关。你可以修改输出以显示字段，但为了简洁起见，我在这里省略了它们。
- en: Hacking the Script
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: Once you are comfortable with the data in the EXIF section of your images, you
    can tweak this script to output only what is necessary. Many professional photographers
    are interested in viewing specific aspects of the camera configuration for a given
    photograph. This script is a tool that is entirely customizable. Take a look at
    the options and see what uses you might come up with.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对图像EXIF部分的数据感到舒适，你可以调整此脚本以仅输出必要的内容。许多专业摄影师对查看特定照片的相机配置的特定方面感兴趣。此脚本是一个完全可定制的工具。查看选项，看看你可能想出的用途。
- en: Creating a Thumbnail
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建缩略图
- en: Creating a Thumbnail
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建缩略图
- en: thumbnail.rb
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: thumbnail.rb
- en: Thumbnails are useful for displaying multiple images at the same time, especially
    on the Web. A perfect example is the ability to quickly view 25 photographs in
    a photo gallery without having to click *next* or wait for each large image to
    load. With lots of pictures to view, thumbnails can make browsing a much more
    relaxing and enjoyable experience. I find myself getting frustrated with websites
    that post each picture as big as possible so you end up with a huge stack of pictures
    that you have to scroll through. This script is the first step in making a web
    photo gallery. If you have the need for sample images for web design or smaller
    image sizes for faster transfers, then this script is for you.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缩略图在同时显示多张图像时非常有用，尤其是在网页上。一个完美的例子是能够在相册中快速查看 25 张照片，而无需点击 *下一页* 或等待每张大图加载。当有大量图片要查看时，缩略图可以使浏览变得更加轻松愉快。我发现自己在浏览那些将每张图片都放大到最大尺寸的网站时会感到沮丧，最终你会得到一大堆需要滚动查看的图片。这个脚本是制作网页相册的第一步。如果你需要用于网页设计的样本图像或更小的图像尺寸以实现更快的传输，那么这个脚本就适合你。
- en: The Code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''RMagick'' ![](../Images/00003.jpg) include
    Magick ![](../Images/00004.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each do |pic| ![](../Images/00005.jpg)  
      image = Image.read(pic)[0] ![](../Images/00006.jpg)     next if pic =~ /^th_/
         puts "Scaling down by 10% --- #{pic}" ![](../Images/00007.jpg)     thumbnail
    = image.scale(0.10)      if File.exists?("th_#{pic}")          puts "Could not
    write file, thumbnail already exists."          next      end ![](../Images/00008.jpg)  
      thumbnail.write "th_#{pic}"  end`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''RMagick'' ![](../Images/00003.jpg) include
    Magick ![](../Images/00004.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each do |pic| ![](../Images/00005.jpg)  
      image = Image.read(pic)[0] ![](../Images/00006.jpg)     next if pic =~ /^th_/
         puts "缩小 10% --- #{pic}" ![](../Images/00007.jpg)     thumbnail = image.scale(0.10)
         if File.exists?("th_#{pic}")          puts "无法写入文件，缩略图已存在。"          next
         end ![](../Images/00008.jpg)     thumbnail.write "th_#{pic}"  end`'
- en: Running the Code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Run this script from the same directory as the images are located by typing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令在包含图像的同一目录下运行此脚本：
- en: '``**`ruby thumbnail.rb`**``'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby thumbnail.rb`**``'
- en: The Results
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The result will be new images that are 10 percent of the original size called:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是新图像，其大小为原始图像的 10%，命名为：
- en: '`th_DSC_0001.JPG th_DSC_0002.JPG th_DSC_0003.JPG th_DSC_0004.JPG th_DSC_0005.JPG`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`th_DSC_0001.JPG th_DSC_0002.JPG th_DSC_0003.JPG th_DSC_0004.JPG th_DSC_0005.JPG`'
- en: How It Works
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script is relatively small owing to the RMagick library and ImageMagick's
    power. Most of the work happens in the background—as it should! This is the first
    script that uses RMagick's methods, so I will take a moment to explain what RMagick
    is all about.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RMagick 库和 ImageMagick 的强大功能，脚本相对较小。大部分工作都在后台完成——正如它应该做的那样！这是第一个使用 RMagick
    方法的脚本，所以我将花点时间解释 RMagick 是什么。
- en: RMagick is the Ruby way to interface with ImageMagick. You're probably thinking,
    "What's ImageMagick?" ImageMagick is a free, open source suite of tools used to
    manipulate images. Now that we have the "Magick" straight, you must have the ImageMagick
    suite installed on your machine ([http://www.imagemagick.org/](http://www.imagemagick.org/)),
    and you must also have the Ruby gem RMagick installed. Now we can get to the good
    stuff.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: RMagick 是 Ruby 与 ImageMagick 交互的方式。你可能想知道，“什么是 ImageMagick？”ImageMagick 是一套用于处理图像的免费、开源工具。现在我们已经明确了“Magick”，你必须在你的机器上安装
    ImageMagick 工具包 ([http://www.imagemagick.org/](http://www.imagemagick.org/))，并且你还必须安装
    Ruby gem RMagick。现在我们可以进入正题。
- en: With RMagick, you will find numerous methods to manipulate image files. For
    instance, when creating thumbnails, there are several choices, such as `resize`,
    `scale`, and `thumbnail`. But don't worry about that until you get the hang of
    RMagick.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 RMagick，你会发现许多用于操作图像文件的方法。例如，在创建缩略图时，有几种选择，如 `resize`、`scale` 和 `thumbnail`。但不必担心这些，直到你熟悉
    RMagick。
- en: This script begins by requiring RMagick ![](../Images/00002.jpg). ImageMagick
    isn't required because RMagick handles all of the interactions. The next line
    includes Magick, which prevents the script from specifically calling each Magick
    method ![](../Images/00003.jpg). Instead of `Magick::Image.read()`, I can simply
    type `Image.read()`. Again, by using an `include`, you save space and typing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本首先通过 require RMagick ![](../Images/00002.jpg). 由于 RMagick 处理了所有交互，因此不需要
    ImageMagick。下一行包含 Magick，这防止脚本专门调用每个 Magick 方法 ![](../Images/00003.jpg)。而不是使用
    `Magick::Image.read()`，我可以直接输入 `Image.read()`。再次强调，通过使用 `include`，你可以节省空间和输入。
- en: Next is the directory scan ![](../Images/00004.jpg). Learn this line if you
    plan on doing much directory searching while writing scripts. The line tells Ruby
    to find every file within the current directory that matches some filename with
    a variation of the JPEG extension. Next, the block starts to manipulate every
    JPEG image that is found.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是目录扫描 ![图片](../Images/00004.jpg)。如果您计划在编写脚本时进行大量目录搜索，请记住这一行。这行代码告诉Ruby在当前目录中查找所有与JPEG扩展名变体匹配的文件名。接下来，代码块开始处理找到的每个JPEG图像。
- en: The first part of any image manipulation with RMagick is reading the image into
    an RMagick object ![](../Images/00005.jpg). Next, we need to ensure we aren't
    making a thumbnail out of a thumbnail. If the filename matches the regular expression
    (i.e., begins with *th*_), then it is skipped and the next image will be processed
    ![](../Images/00006.jpg). The script outputs the result by scaling the picture
    down to 10 percent of the original size ![](../Images/00007.jpg). We use the method
    `scale` and 0.10 to signify 10 percent and save all of the manipulations to a
    variable appropriately named `thumbnail`. The last step is to output the file
    with the new filename. As always, we look before we write, and if no other files
    with the new name exist, the thumbnail is written to the directory ![](../Images/00008.jpg).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: RMagick任何图像处理的第一个部分是将图像读入RMagick对象 ![图片](../Images/00005.jpg)。接下来，我们需要确保我们不是在将缩略图变成缩略图。如果文件名与正则表达式匹配（即以*th*开头），则跳过并处理下一个图像
    ![图片](../Images/00006.jpg)。脚本通过将图片缩小到原始大小的10%来输出结果 ![图片](../Images/00007.jpg)。我们使用`scale`方法和0.10来表示10%，并将所有操作保存到名为`thumbnail`的变量中。最后一步是将文件以新文件名输出。一如既往，我们在写入之前检查，如果不存在其他具有新名称的文件，则缩略图将被写入目录
    ![图片](../Images/00008.jpg)。
- en: Hacking the Script
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: Some variations to this script are saving the thumbnails into a separate folder
    or running through subdirectories searching for images. One of my colleagues even
    made an addition to label images based on the color heuristics. I'll leave these
    to your amusement.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对此脚本的一些变体包括将缩略图保存到单独的文件夹或递归搜索子目录以查找图像。我的一个同事甚至添加了一个基于颜色启发式标记图像的功能。我将把这些留给你自己娱乐。
- en: Resize a Picture
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整图片大小
- en: Resize a Picture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整图片大小
- en: resizePhoto.rb
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: resizePhoto.rb
- en: Digital SLR cameras provide tremendous resolution, but that makes for very large
    files. Many times I have found myself wanting to use a picture in a website or
    email and am forced to fire up the GIMP to shrink the pictures to a more manageable
    size. This script will tear through shrinking a picture to whatever size you want.
    We already covered how to rip through files to generate thumbnails in a previous
    script (see "#24 Creating a Thumbnail" on [Creating a Thumbnail](../Text/dummy_split_170.html#filepos355400)).
    This script is similar, but instead of shrinking everything to 10 percent, we'll
    set the final dimensions in the code—a nice feature if you're embedding images
    into the frame of a website.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数码单反相机提供了极高的分辨率，但这使得文件变得非常大。很多时候，我发现自己想在网站或电子邮件中使用一张图片，却不得不启动GIMP来缩小图片到更易管理的尺寸。这个脚本将快速将图片缩小到您想要的任何尺寸。我们已经在之前的脚本中介绍了如何快速处理文件以生成缩略图（参见“#24
    创建缩略图”在[创建缩略图](../Text/dummy_split_170.html#filepos355400)）。这个脚本与此类似，但不是将所有内容缩小到10%，而是在代码中设置最终尺寸——如果您要将图片嵌入到网站框架中，这是一个很棒的功能。
- en: The Code
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''RMagick''  include Magick  ![](../Images/00003.jpg) unless
    ARGV[0]      puts "\n\n\nYou need to specify a filename:  resizePhoto.rb <filename>\n\n\n"
         exit  end  ![](../Images/00004.jpg) img = Image.read(ARGV[0]).first  width
    = nil  height = nil  ![](../Images/00005.jpg) img.change_geometry!(''400x400'')
    do |cols, rows, img| ![](../Images/00006.jpg)      img.resize!(cols, rows)   
      width = cols      height = rows  end   file_name = "#{width}x#{height}_#{ARGV[0]}"   if
    File.exists?(file_name)      puts "File already exists.  Unable to write file."
         exit  end  ![](../Images/00007.jpg) img.write(file_name)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](../Images/00002.jpg) require ''RMagick'' include Magick ![图片](../Images/00003.jpg)
    unless ARGV[0] puts "\n\n\n您需要指定一个文件名：resizePhoto.rb <filename>\n\n\n" exit end
    ![图片](../Images/00004.jpg) img = Image.read(ARGV[0]).first width = nil height
    = nil ![图片](../Images/00005.jpg) img.change_geometry!(''400x400'') do |cols, rows,
    img| ![图片](../Images/00006.jpg) img.resize!(cols, rows) width = cols height =
    rows end file_name = "#{width}x#{height}_#{ARGV[0]}" if File.exists?(file_name)
    puts "文件已存在。无法写入文件。" exit end ![图片](../Images/00007.jpg) img.write(file_name)`'
- en: Running the Code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: As with most of the picture utility scripts, this takes an image as a command-line
    argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数图片实用脚本一样，这个脚本接受一个图像作为命令行参数。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The result will be a new image created called:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将创建一个新图像，其名称为：
- en: '``*`400x267_DSC_0001.JPG`*``'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`400x267_DSC_0001.JPG`*``'
- en: How It Works
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Using two methods from the RMagick bag of tricks, this script resizes an image
    while maintaining the aspect ratio. First we `require` RMagick and `include Magick`
    ![](../Images/00002.jpg). Just to make sure the user is playing by our rules,
    we run his input through the verification line. If command-line arguments aren't
    supplied, he needs to be educated on how to run the script ![](../Images/00003.jpg).
    To begin the image manipulation, a new `Image` object is initialized, creatively
    called `img` ![](../Images/00004.jpg). `height` and `width` are initialized, too,
    and will be used later for file naming specifics.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RMagick工具包中的两种方法，此脚本在保持宽高比的同时调整图像大小。首先我们`require` RMagick 和 `include Magick`
    ![图片2](../Images/00002.jpg)。为了确保用户遵守我们的规则，我们将他的输入通过验证行运行。如果没有提供命令行参数，他需要了解如何运行脚本
    ![图片3](../Images/00003.jpg)。为了开始图像处理，初始化一个新的`Image`对象，命名为`img` ![图片4](../Images/00004.jpg)。`height`
    和 `width` 也被初始化，稍后将被用于文件命名的具体细节。
- en: The first method, and the one which maintains the aspect ratio, is `change_geometry`
    ![](../Images/00005.jpg). I used the exclamation point variation to directly manipulate
    the image. In plain English, line ![](../Images/00005.jpg) says "the image must
    be smaller than 400 by 400" and whatever measurement exceeds the limits first
    will determine the other measurement. So, for an original image of 3,008 by 2,000
    and a limit of 400 by 400, the width measurement is the larger of the width and
    height. To preserve the aspect ratio, the image will be 400 by 267\. Of course,
    you could manually calculate the values to insert into the resize method, but
    that doesn't allow for much flexibility.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，也是保持宽高比的方法是 `change_geometry` ![图片5](../Images/00005.jpg)。我使用了感叹号变体来直接操作图像。用简单的话说，代码![图片5](../Images/00005.jpg)表示“图像必须小于400x400”，超过限制的第一个测量值将决定另一个测量值。因此，对于原始图像为3,008x2,000且限制为400x400的情况，宽度测量值是宽度和高度中的较大值。为了保持宽高比，图像将是400x267。当然，你可以手动计算值以插入到调整大小方法中，但这并不提供太多灵活性。
- en: Once `change_geometry!` has determined the correct aspect ratio, `resize!` is
    called upon to execute the new measurements ![](../Images/00006.jpg) (again, the
    exclamation point signifies direct image manipulation). Two other variables, `width`
    and `length`, store the measurements for use when naming the file. The new image
    name will be the width by the length, all prepended to the original filename ![](../Images/00007.jpg).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `change_geometry!` 确定了正确的宽高比，就会调用 `resize!` 来执行新的测量 ![图片6](../Images/00006.jpg)（再次，感叹号表示直接图像操作）。另外两个变量
    `width` 和 `length` 存储测量值，用于文件命名时使用。新的图像名称将是宽度乘以长度，所有这些都附加到原始文件名前 ![图片7](../Images/00007.jpg)。
- en: Hacking the Script
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: This script is straightforward, but some interesting tweaks are possible; you
    could make the dimensions a command-line argument or choose from a few preset
    dimensions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本简单直接，但可以进行一些有趣的调整；你可以将维度作为命令行参数，或者从几个预设维度中选择。
- en: Adding a Watermark to Pictures
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为图片添加水印
- en: Adding a Watermark to Pictures
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为图片添加水印
- en: watermark.rb
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: watermark.rb
- en: If you want to receive credit for your pictures while sharing them on the Internet,
    watermarks are a nice tool (see [Figure 4-1](#filepos374986)). Watermarks help
    ensure you remain the owner of your digital property. If there is a standard watermark
    you use, this script can incorporate it—big or small.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在互联网上分享图片时获得认可，水印是一个很好的工具（见[图4-1](#filepos374986)）。水印有助于确保你仍然是你的数字财产的所有者。如果你有一个标准的水印，此脚本可以将其整合——无论大小。
- en: '![Cover image with watermark](../Images/00013.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![带水印的封面图片](../Images/00013.jpg)'
- en: Figure 4-1. Cover image with watermark
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 带水印的封面图片
- en: The Code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''RMagick''  include Magick   unless ARGV[0]
    and File.exists?(ARGV[0])      puts "\n\n\nYou need to specify a filename:  watermark.rb
    <filename>\n\n\n"      exit  end   img = Image.read(ARGV[0]).first ![](../Images/00003.jpg) watermark
    = Image.new(600, 50)  ![](../Images/00004.jpg) watermark_text = Draw.new ![](../Images/00005.jpg) watermark_text.annotate(watermark,
    0,0,0,0, "No Starch Press") do ![](../Images/00006.jpg)     watermark_text.gravity
    = CenterGravity      self.pointsize = 50      self.font_family = "Arial"     
    self.font_weight = BoldWeight      self.stroke = "none"  end  ![](../Images/00007.jpg) watermark.rotate!(45)
    ![](../Images/00008.jpg) watermark = watermark.shade(true, 310, 30) ![](../Images/00009.jpg) img.composite!(watermark,
    SouthWestGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    NorthWestGravity, HardLightCompositeOp)  watermark.rotate!(90)  img.composite!(watermark,
    NorthEastGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    SouthEastGravity, HardLightCompositeOp)      if File.exists?("wm_#{ARGV[0]}")
         puts "Image already exists.  Unable to write file."      exit  end   puts
    "Writing wm_#{ARGV[0]}" ![](../Images/00011.jpg) img.write("wm_#{ARGV[0]}")`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''RMagick''  include Magick   unless ARGV[0]
    and File.exists?(ARGV[0])      puts "\n\n\n您需要指定一个文件名：  watermark.rb <filename>\n\n\n"
         exit  end   img = Image.read(ARGV[0]).first ![](../Images/00003.jpg) watermark
    = Image.new(600, 50)  ![](../Images/00004.jpg) watermark_text = Draw.new ![](../Images/00005.jpg) watermark_text.annotate(watermark,
    0,0,0,0, "No Starch Press") do ![](../Images/00006.jpg)     watermark_text.gravity
    = CenterGravity      self.pointsize = 50      self.font_family = "Arial"     
    self.font_weight = BoldWeight      self.stroke = "none"  end  ![](../Images/00007.jpg) watermark.rotate!(45)
    ![](../Images/00008.jpg) watermark = watermark.shade(true, 310, 30) ![](../Images/00009.jpg) img.composite!(watermark,
    SouthWestGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    NorthWestGravity, HardLightCompositeOp)  watermark.rotate!(90)  img.composite!(watermark,
    NorthEastGravity, HardLightCompositeOp)  watermark.rotate!(-90)  img.composite!(watermark,
    SouthEastGravity, HardLightCompositeOp)      if File.exists?("wm_#{ARGV[0]}")
         puts "Image already exists.  Unable to write file."      exit  end   puts
    "Writing wm_#{ARGV[0]}" ![](../Images/00011.jpg) img.write("wm_#{ARGV[0]}")`'
- en: Running the Code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Run the script with the image to be watermarked as the command-line argument:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用要添加水印的图片作为命令行参数运行脚本：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Results
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The result will be a new image with *No Starch Press* in every corner. The
    image is called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个新的图像，每个角落都有*No Starch Press*。这个图像被命名为：
- en: '``*`wm_DSC_0001.JPG`*``'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`wm_DSC_0001.JPG`*``'
- en: How It Works
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Watermarking has become the norm for rights holders in the age of ubiquitous
    copying. This script really flexes the RMagick muscles, so I'll spend a bit more
    time explaining exactly what is going on. The first two instructions are the same
    as in the previous RMagick script, save the usage line ![](../Images/00002.jpg).
    To begin editing the image and creating the watermark, the script reads the photograph
    into an `Image` object called `img`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制无处不在的时代，水印已成为版权所有者的规范。这个脚本真正地锻炼了RMagick的功能，所以我将花更多的时间来解释具体发生了什么。前两个指令与之前的RMagick脚本相同，除了使用说明行！[](../Images/00002.jpg)。为了开始编辑图片并创建水印，脚本将照片读入一个名为`img`的`Image`对象。
- en: The next step is designing the watermark that will be placed in our photograph.
    A new image measuring 600 by 50 pixels is created and called `watermark` ![](../Images/00003.jpg).
    This image isn't anything as of yet, but it will be after we follow a few more
    instructions. If you already have an image you want to use for watermarking, this
    is the area in which you'd want to put it. Since we want the words *No Starch
    Press* on the picture, the script will create them from scratch. A new `Draw`
    object is created which will hold our wicked cool text ![](../Images/00004.jpg).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设计将要放置在我们照片中的水印。创建了一个新的600x50像素的图像，并命名为`watermark`！[](../Images/00003.jpg)。这个图像目前什么也没有，但之后我们会遵循一些指令。如果您已经有了想要用于水印的图像，这将是在您想要放置它的区域。由于我们想在图片上显示*No
    Starch Press*，脚本将从头开始创建这些文字。创建了一个新的`Draw`对象，它将包含我们酷炫的文字！[](../Images/00004.jpg)。
- en: After the `Draw` and `Image` objects have been created, the `annotate` method
    is called on the `Draw` object ![](../Images/00005.jpg). The arguments passed
    to this method are the image which will be annotated, width of the rectangle,
    height of the rectangle, x-axis offset of the text, y-axis offset of the text,
    and, finally, the text to use. I specified zeros for the width and height to let
    the method know to use the entire 600-by-50-pixel rectangle.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Draw`和`Image`对象之后，在`Draw`对象上调用`annotate`方法 ![注释效果](../Images/00005.jpg)。传递给此方法的参数是要注释的图像、矩形宽度、矩形高度、文本的x轴偏移量、文本的y轴偏移量，以及最后要使用的文本。我指定了宽度和高度为零，以便让该方法知道使用整个600x50像素的矩形。
- en: Within the `annotate` method, the text is styled and centered. In this script,
    I've centered the text and made the font Arial, bold weight, and size 50 points
    ![](../Images/00006.jpg). Play around with these variables to customize the text
    to your liking.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`annotate`方法中，文本被格式化和居中。在这个脚本中，我将文本居中，字体设置为Arial，加粗，字号为50点 ![文本样式](../Images/00006.jpg)。玩转这些变量，以自定义您喜欢的文本样式。
- en: 'The watermark has now been created as flat text. The next section will include
    placing the watermark image on the original photograph. You can literally put
    the watermark anywhere in the photograph that you think is appropriate. Caution:
    Try to disrupt the digital content as little as possible. In this example, the
    first watermark placement is on the lower-left corner of the photograph.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 水印现在已经被创建为平面文本。下一节将包括将水印图像放置在原始照片上的内容。您可以将水印放置在照片的任何您认为合适的位置。注意：尽量减少对数字内容的干扰。在这个例子中，第一个水印放置在照片的左下角。
- en: I wanted the watermark to be angled so that when all four watermarks are set,
    the picture looks framed. To achieve the proper angles, I used the `.rotate!`
    method, which manipulates the image ![](../Images/00007.jpg). The exclamation
    point reminds the user that the rotation will be "in place," or saved to the same
    variable permanently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让水印倾斜，以便当所有四个水印都设置好时，图片看起来像是有画框的。为了达到正确的角度，我使用了`.rotate!`方法，它操作图像 ![旋转效果](../Images/00007.jpg)。感叹号提醒用户旋转将是“就地”的，或者永久保存到相同的变量中。
- en: To make the watermark stand out, I used the shade method, which adds a cool
    3D effect ![](../Images/00008.jpg). Essentially, these arguments make the image
    appear to be embossed and transparent. The first argument turns the shade attribute
    on, and the last two arguments specify the angle and height for the apparent light
    source. RMagick's website ([http://rmagick.rubyforge.org/](http://rmagick.rubyforge.org/))
    has a great explanation of the different shades.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使水印更加突出，我使用了阴影方法，这为图像添加了酷炫的3D效果 ![阴影效果](../Images/00008.jpg)。本质上，这些参数使图像看起来像是浮雕和透明的。第一个参数打开阴影属性，最后两个参数指定了模拟光源的角度和高度。RMagick的网站([http://rmagick.rubyforge.org/](http://rmagick.rubyforge.org/))对不同的阴影有很好的解释。
- en: To complete the watermarks, the `composite` method is used to blend the original
    photo and watermark images together ![](../Images/00009.jpg). The `composite`
    method is given the watermark image, the type of *gravity* (or where on the image
    the watermark will be placed), and also the `composite operator` to use. For a
    complete listing of `CompositeOperator` options, visit [http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/](http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/).
    The final step is to ensure that a file with the same name doesn't already exist
    and then write the file ![](../Images/00011.jpg).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成水印，使用了`composite`方法将原始照片和水印图像混合在一起 ![混合效果](../Images/00009.jpg)。`composite`方法接收水印图像、*重力*类型（或水印在图像上的位置）以及要使用的`composite
    operator`。要查看`CompositeOperator`选项的完整列表，请访问[http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/](http://www.imagemagick.org/RMagick/doc/constants.html#CompositeOperator/)。最后一步是确保没有与文件名相同的文件存在，然后写入文件
    ![写入效果](../Images/00011.jpg)。
- en: Convert to Black and White
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为黑白
- en: Convert to Black and White
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换为黑白
- en: bwPhoto.rb
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bwPhoto.rb
- en: Today most computer monitors are compared by how many colors they can display.
    Television screens can display almost 100 percent of all the colors a human eye
    can perceive. Yet, with all the colors in the world, black-and-white photography
    still captures beauty like nothing else. This script is awesome.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数计算机显示器是通过它们能显示多少颜色来比较的。电视屏幕可以显示人类眼睛能感知的所有颜色的几乎100%。然而，在世界上所有的颜色中，黑白摄影仍然能捕捉到其他任何东西都无法比拟的美。这个脚本很棒。
- en: A year ago, I had some of my orchid photographs on display in an art gallery
    in Alexandria, Virginia. One of the photographs was of a very ugly blossom, a
    sort of cream with muddled brown spots. It wasn't the vibrant fuchsia nor the
    angelic white most commonly associated with orchids. However, when the flower
    was converted to black and white, it showed itself to be a rare beauty. Now it's
    one of my personal favorites. This just goes to show the power of black-and-white
    photography.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一年前，我在弗吉尼亚州亚历山大的一个艺术画廊里展示了一些我的兰花照片。其中一张照片展示了一朵非常丑陋的花朵，一种奶油色，上面有模糊的棕色斑点。它既不是兰花最常见的鲜艳的粉红色，也不是天使般纯洁的白色。然而，当花朵被转换为黑白时，它展现出了罕见的美丽。现在，它已成为我个人的最爱之一。这正好说明了黑白摄影的力量。
- en: The Code
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''RMagick''  include Magick   unless ARGV[0]      puts "\n\n\nYou
    need to specify a filename:  bwPhoto.rb <filename>\n\n\n"      exit  end   new_img
    = "bw_#{ARGV[0]}" ![](../Images/00002.jpg) img = Image.read(ARGV[0]).first  ![](../Images/00003.jpg) img
    = img.quantize(256, GRAYColorspace)   if File.exists?(new_img)      puts "Could
    not write file. Image name already exists."      exit  end  ![](../Images/00004.jpg) img.write(new_img)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''RMagick''  include Magick   unless ARGV[0]      puts "\n\n\n您需要指定一个文件名：
     bwPhoto.rb <filename>\n\n\n"      exit  end   new_img = "bw_#{ARGV[0]}" ![图片](../Images/00002.jpg) img
    = Image.read(ARGV[0]).first ![图片](../Images/00003.jpg) img = img.quantize(256,
    GRAYColorspace)   if File.exists?(new_img)      puts "无法写入文件。图像名称已存在。"      exit
     end ![图片](../Images/00004.jpg) img.write(new_img)`'
- en: Running the Code
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: As with most of the picture utility scripts, this one takes an image as a command-line
    argument.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数图片实用脚本一样，这个脚本接受一个图像作为命令行参数。
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Results
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The result will be a new image called:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个名为的新图像：
- en: '``*`bw_DSC_0001.JPG`*``'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '``*`bw_DSC_0001.JPG`*``'
- en: How It Works
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The elegance of this script really impresses me every time I look at it. In
    essentially three lines of Ruby code, the script can completely transform a picture.
    (You could condense the script to one line, but I'll let you figure out how to
    do that.) By now, you should be getting used to the user input validation of command-line
    arguments. The main body begins by reading in the image that will be converted
    to black and white ![](../Images/00002.jpg). Next, the image is *quantized*, which
    means that the colors within the image are analyzed and a subset is used to represent
    the picture ![](../Images/00003.jpg).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我看到这个脚本，它的优雅性都让我印象深刻。在本质上三行 Ruby 代码中，这个脚本可以完全改变一张图片。（你可以将脚本压缩成一行，但我将让你自己想出如何做到这一点。）到现在为止，你应该已经习惯了命令行参数的用户输入验证。主体部分首先读取将被转换为黑白的图像
    ![图片](../Images/00002.jpg)。接下来，图像被 *量化*，这意味着图像中的颜色被分析，并使用一个子集来表示图片 ![图片](../Images/00003.jpg)。
- en: The `GRAYColorspace` is used as the second argument to convert the color image
    from red-green-blue (RGB) to grayscale. The first argument of `quantize` tells
    RMagick how many colors you want to use during the sampling. For a purely black-and-white
    photo, the first argument would be two. After the quantize method finishes execution,
    `img` will contain the black-and-white image ![](../Images/00004.jpg). Naturally,
    we want to save the image by using the `write` method. The file will be prepended
    with `bw_` to signify a black-and-white image.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`GRAYColorspace` 被用作转换颜色图像从红绿蓝（RGB）到灰度的第二个参数。`quantize` 的第一个参数告诉 RMagick 在采样期间想要使用多少种颜色。对于一张纯黑白照片，第一个参数应该是两个。在量化方法执行完毕后，`img`
    将包含黑白图像 ![图片](../Images/00004.jpg)。自然地，我们希望通过使用 `write` 方法保存图像。文件名将添加 `bw_` 前缀以表示这是一张黑白图像。'
- en: Creating a Photo Gallery
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建相册
- en: Creating a Photo Gallery
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建相册
- en: createGallery.rb
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: createGallery.rb
- en: Electronic photo galleries provide a perfect forum for sharing pictures with
    friends and family. Stacks of full-size photos aren't very inviting, nor do they
    stand up by themselves. A nice gallery is needed to present them in the proper
    way. This is a quick photo gallery script with a clean, simple style. The gallery
    can be modified and personalized as much as you like. You can get fancy, but for
    this example, I'll keep it as simple as possible. Familiarity with HTML is helpful
    but not necessary.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 电子相册为与朋友和家人分享图片提供了一个完美的论坛。一堆全尺寸照片并不吸引人，也无法自立。需要一个漂亮的画廊来正确展示它们。这是一个简洁、简单的快速相册脚本。你可以根据需要修改和个性化这个画廊。你可以做得更复杂，但在这个例子中，我会尽可能保持简单。熟悉
    HTML 有帮助，但不是必需的。
- en: The Code
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''RMagick''  require ''ftools''  include
    Magick  ![](../Images/00003.jpg) photos_row = 4  table_border = 1  html_rows =
    1  ![](../Images/00004.jpg) File.makedirs("gallery/thumbs", "gallery/resize")
    ![](../Images/00005.jpg) output = File.new("gallery/index.html","w+b")  html =
    <<EOF  <html>      <head>          <title>My Photos</title>      </head>     
    <body bgcolor="#d0d0d0">          <h1>Welcome To My Photo Gallery</h1>       
      <table border=#{table_border}>  EOF  output.puts html  ![](../Images/00006.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each
    do |pic| ![](../Images/00007.jpg)      thumb = Image.read(pic)[0]       thumb.change_geometry!(''150x150'')
    do |cols, rows, img|           thumb.resize!(cols, rows)       end       if File.exists?("gallery/thumbs/th_#{pic}")
              puts "Could not write file. Thumbnail already exists."       else   
           thumb.write "gallery/thumbs/th_#{pic}"       end  ![](../Images/00008.jpg)  
       resize = Image.read(pic)[0]        resize.change_geometry!(''800x600'') do
    |cols, rows, img|          resize.resize!(cols, rows)       end       if File.exists?("gallery/resize/resize_#{pic}")
             puts "Could not write file. Resized image already exists."       else
             resize.write("gallery/resize/resize_#{pic}")       end  ![](../Images/00009.jpg)  
       if html_rows % photos_row == 1           output.puts "\n<tr>"       end  ![](../Images/00011.jpg) output.puts
    <<EOF          <td><a href="resize/resize_#{pic}/" title="#{pic}"  target="_blank"><img
    src="thumbs/th_#{pic}" alt="#{pic}"/></a></td>  EOF       if html_rows % photos_row
    == 0          output.puts "</tr>"      end      html_rows+=1  end   unless html_rows
    % photos_row == 1      output.puts "</tr>"  end  ![](../Images/00012.jpg) output.puts
    "</body>\n</html>"  output.puts "<!-- Courtesy of No Starch Press: Wicked Cool
    Ruby Scripts -->"  output.close`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''RMagick'' require ''ftools'' include Magick
    ![](../Images/00003.jpg) photos_row = 4 table_border = 1 html_rows = 1 ![](../Images/00004.jpg)
    File.makedirs("gallery/thumbs", "gallery/resize") ![](../Images/00005.jpg) output
    = File.new("gallery/index.html","w+b") html = <<EOF <html> <head> <title>我的相册</title>
    </head> <body bgcolor="#d0d0d0"> <h1>欢迎来到我的相册</h1> <table border=#{table_border}>
    EOF output.puts html ![](../Images/00006.jpg) Dir[''*.[Jj][Pp]*[Gg]''].each do
    |pic| ![](../Images/00007.jpg)   thumb = Image.read(pic)[0] thumb.change_geometry!(''150x150'')
    do |cols, rows, img| thumb.resize!(cols, rows) end if File.exists?("gallery/thumbs/th_#{pic}")
    puts "无法写入文件。缩略图已存在。" else thumb.write "gallery/thumbs/th_#{pic}" end ![](../Images/00008.jpg)  
    resize = Image.read(pic)[0] resize.change_geometry!(''800x600'') do |cols, rows,
    img| resize.resize!(cols, rows) end if File.exists?("gallery/resize/resize_#{pic}")
    puts "无法写入文件。调整大小后的图片已存在。" else resize.write("gallery/resize/resize_#{pic}") end
    ![](../Images/00009.jpg)   if html_rows % photos_row == 1 output.puts "\n<tr>"
    end ![](../Images/00011.jpg) output.puts <<EOF <td><a href="resize/resize_#{pic}/"
    title="#{pic}" target="_blank"><img src="thumbs/th_#{pic}" alt="#{pic}"/></a></td>
    EOF   if html_rows % photos_row == 0 output.puts "</tr>" end html_rows+=1 end
    unless html_rows % photos_row == 1 output.puts "</tr>" end ![](../Images/00012.jpg)
    output.puts "</body>\n</html>" output.puts "<!-- 感谢No Starch Press提供：Wicked Cool
    Ruby Scripts -->" output.close'
- en: Running the Code
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: To run the code, simply run the script from the image directory in which you
    want the photo gallery created.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，只需从你想要创建相册的图片目录中运行脚本即可。
- en: '``**`ruby createGallery.rb`**``'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby createGallery.rb`**``'
- en: Results
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The result is a self-contained photo gallery in the same directory as the pictures
    ([Figure 4-2](../Text/dummy_split_201.html#filepos400625)). Navigate to the *gallery*
    directory and open *index.html*. There will be two subdirectories containing the
    thumbnail and resized images: *thumbs* and *resize*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含在图片同一目录下的独立相册（[图4-2](../Text/dummy_split_201.html#filepos400625)）。导航到*gallery*目录并打开*index.html*。这里将有两个子目录，包含缩略图和调整大小后的图片：*thumbs*和*resize*。
- en: How It Works
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Two libraries are required in this script ![](../Images/00002.jpg). RMagick
    is required for the image manipulation, and ftools is required because the script
    will create three directories. Magick is included so each RMagick method doesn't
    have to be called with an explicit (or fully qualified) receiver. Next, the three
    variables are initialized that will determine the final HTML output ![](../Images/00003.jpg).
    Two of these variables will format the web page output, and the third variable
    is a counter. The script is set up to display four images per row, but you can
    simply change the variable `photo_row` to any number you prefer. The same options
    go for the `table_border`, which specifies how thick the HTML table border will
    be.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中需要两个库 ![图片](../Images/00002.jpg)。RMagick 用于图像处理，而 ftools 是必需的，因为脚本将创建三个目录。Magick
    已包含在内，因此每个 RMagick 方法不需要使用显式（或完全限定）的接收者来调用。接下来，初始化三个变量，这些变量将决定最终的 HTML 输出 ![图片](../Images/00003.jpg)。其中两个变量将格式化网页输出，第三个变量是一个计数器。脚本被设置为每行显示四张图片，但你可以简单地更改变量
    `photo_row` 为你喜欢的任何数字。对于 `table_border`，它指定了 HTML 表格边框的厚度。
- en: '![Photo gallery made by Ruby](../Images/00014.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![由 Ruby 制作的相册](../Images/00014.jpg)'
- en: Figure 4-2. Photo gallery made by Ruby
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2. 由 Ruby 制作的相册
- en: The directory structure the photo gallery uses includes a main folder called
    *gallery* with a separate directory for the thumbnail images and resized images.
    To set up this directory structure, `File.makedirs` is called ![](../Images/00004.jpg).
    Each argument within the method will create a directory. Additionally, if the
    directory is buried within several directories, the method will create the parent
    directories. So, for *gallery/thumbs*, I don't need to separately specify the
    folder *gallery* since the method creates the directory *gallery* while making
    *thumbs*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 照片画廊使用的目录结构包括一个名为 *gallery* 的主文件夹，以及用于缩略图和调整大小图片的单独目录。为了设置此目录结构，调用 `File.makedirs`
    ![图片](../Images/00004.jpg)。方法内的每个参数都将创建一个目录。此外，如果目录位于几个目录的深处，该方法将创建父目录。因此，对于 *gallery/thumbs*，我不需要单独指定文件夹
    *gallery*，因为该方法在创建 *thumbs* 的同时也会创建目录 *gallery*。
- en: The main result of this script will be a web page. We'll call the web page *index.html*
    so a web server will know it is the main photo gallery page. Because *index.html*
    doesn't exist, we must create it using the `File.new` method. The file will be
    created in our new *gallery* directory ![](../Images/00005.jpg). The next block
    of code is called a *here-doc*, and it lets me write text as I would in a normal
    text editor. I don't have to worry about escaping quotes or adding `\n` for line
    breaks—the here-doc preserves it all. The here-doc in this script contains the
    beginnings of the HTML output with several tags. The first few pieces create the
    web page title, and the last two lines create the bold title and start our table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的最终结果将是一个网页。我们将网页命名为 *index.html*，这样 web 服务器就会知道它是主要的照片画廊页面。因为 *index.html*
    不存在，我们必须使用 `File.new` 方法来创建它。文件将创建在我们的新 *gallery* 目录中 ![图片](../Images/00005.jpg)。接下来的代码块被称为
    *here-doc*，它允许我像在普通文本编辑器中一样写入文本。我不必担心转义引号或添加 `\n` 来实现换行——here-doc 会保留所有这些。此脚本中的
    here-doc 包含了 HTML 输出的开始部分，包含几个标签。前几部分创建网页标题，最后两行创建粗体标题并开始我们的表格。
- en: 'After the directories have been put in place and the web page has been created,
    it''s time to start adding some photos. To do this, we need to scan the directory
    for any JPEG images. If you''re going to be adding other types of images, you''ll
    need to change this line accordingly ![](../Images/00006.jpg). The main directory
    traversal block is broken down into three distinct sections: thumbnail creation,
    resizing the original image, and adding the appropriate HTML code to our web page.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好目录并创建网页之后，是时候开始添加一些照片了。为此，我们需要扫描目录以查找任何 JPEG 图片。如果你打算添加其他类型的图片，你需要相应地更改这一行
    ![图片](../Images/00006.jpg)。主目录遍历块分为三个不同的部分：创建缩略图、调整原始图片大小以及将适当的 HTML 代码添加到我们的网页中。
- en: To create thumbnails, I used a different function than in the previous thumbnail
    script (see "#24 Creating a Thumbnail" on [Creating a Thumbnail](../Text/dummy_split_170.html#filepos355400)).
    The reason I used a different method was to ensure uniformity within the web page.
    I wanted the thumbnails to all be the same size since it looks better. First,
    a new Image object is created, called `thumb` ![](../Images/00007.jpg). Then `thumb`
    is passed into the aspect ratio preserving `change_geometry!` method. Thumbnails
    are typically around 150 by 150 pixels, so that is the limit set as the `change_geometry!`
    argument. After the `thumb` image had been resized, it was written into the *thumbs*
    directory with a `th_` prepended to the image name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建缩略图，我使用了与之前缩略图脚本不同的函数（参见[创建缩略图](../Text/dummy_split_170.html#filepos355400)中的“#24
    创建缩略图”）。我之所以使用不同的方法，是为了确保网页内的统一性。我希望所有缩略图都保持相同的大小，因为这样看起来更好。首先，创建了一个新的图像对象，命名为`thumb`
    ![图片](../Images/00007.jpg)。然后，将`thumb`传递给保持宽高比的`change_geometry!`方法。缩略图通常大小为150x150像素，因此这是作为`change_geometry!`参数设置的极限。在`thumb`图像被调整大小后，它被写入到`*thumbs*`目录中，并在图像名称前加上`th_`前缀。
- en: A similar manipulation of the image was done to resize it ![](../Images/00008.jpg).
    Instead of limiting the image to 150 by 150 pixels, a larger scale of 800 by 600
    pixels was used. The full-scale size can be as big as the screen resolution of
    your viewers. In my experience with website visitors, most have a resolution of
    1,280 by 1,024, but there are some who choose a smaller 800-by-600 resolution.
    You'll need to keep that in mind when deciding on an appropriate image resolution
    for your purposes. When creating the thumbnails and resizing the image, we never
    want to overwrite an existing file. So, an error message is displayed stating
    the image name that could not be created because that image name already exists.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对图像进行了类似的修改以调整其大小 ![图片](../Images/00008.jpg)。不是将图像限制在150x150像素，而是使用800x600像素的更大比例。全尺寸可以大到你观众的屏幕分辨率。根据我的网站访问者经验，大多数人的分辨率为1280x1024，但有些人选择较小的800x600分辨率。在决定适合你目的的图像分辨率时，你需要考虑到这一点。在创建缩略图和调整图像大小时，我们绝对不希望覆盖现有的文件。因此，会显示一条错误消息，指出无法创建的图像名称，因为该名称已存在。
- en: 'After the images have been created, the script turns its attention back to
    the HTML file. This script uses a table to organize the images. With a bit of
    math trickery and some precise calculations, that table is symmetrical ![](../Images/00009.jpg).
    The `%`, or *modulo*, operator returns the remainder of a division operation.
    If there is a remainder of 1, the script knows a new row should be started. The
    script uses that same modulo operator, now looking for a remainder of 0, to calculate
    whether a row should be closed. No matter what number `$photos_row` contains,
    a table matching the specifications will be created. In between each row are columns
    signified by `<td>` and `</td>`: This is where each image is inserted. Again,
    using a here-doc on line ![](../Images/00011.jpg), the HTML text tells the web
    page to insert a new column entry, a hyperlink to the larger image that opens
    in a new window, a title, and, lastly, the image thumbnail. This process is done
    for each image.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完图像后，脚本将注意力转回到HTML文件上。此脚本使用表格来组织图像。通过一些数学技巧和一些精确的计算，该表格是对称的 ![图片](../Images/00009.jpg)。`%`，或称*取模*运算符，返回除法操作的余数。如果有余数为1，脚本就知道应该开始新的一行。脚本使用相同的取模运算符，现在寻找余数为0，以计算是否应该关闭行。无论`$photos_row`包含什么数字，都会创建一个符合规格的表格。在每行之间，由`<td>`和`</td>`表示的列：这是插入每个图像的位置。再次使用行号![图片](../Images/00011.jpg)上的here-doc，HTML文本告诉网页插入一个新的列条目，一个指向较大图像的超链接，该图像在新窗口中打开，一个标题，最后是图像缩略图。这个过程为每个图像重复进行。
- en: Once all the images have been manipulated and added to the web page, the script
    checks to see if a row needs to be closed and then outputs some final HTML comments
    to tidy up the web page ![](../Images/00012.jpg). The HTML file is then closed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有图像都被处理并添加到网页中，脚本会检查是否需要关闭行，然后输出一些最终的HTML注释来整理网页 ![图片](../Images/00012.jpg)。然后关闭HTML文件。
- en: You can test the image gallery by going to the gallery folder and clicking the
    *index.html* file you just created. Building a photo gallery doesn't get much
    easier than that!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过进入相册文件夹并点击你刚刚创建的`*index.html*`文件来测试图像库。创建照片库没有比这更简单的方法了！
- en: Hacking the Script
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: Take some time to play around with the embedded HTML code and make the photo
    gallery your own! There are endless possibilities with tables, colors, fonts,
    and so on. If you come up with a wicked cool photo gallery, feel free to send
    it to me.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空玩玩嵌入的HTML代码，把相册变成你自己的风格！表格、颜色、字体等等，都有无限的可能性。如果你设计出一个酷炫的相册，随时可以发给我。
