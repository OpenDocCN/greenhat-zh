- en: Chapter 1. Strings, Numbers, Classes, and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。字符串、数字、类和对象
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: 'The first thing to know about Ruby is that it’s easy to use. To prove this,
    let’s look at the code of the traditional “Hello world” program:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Ruby 的第一件事是它很容易使用。为了证明这一点，让我们看看传统“Hello world”程序的代码：
- en: '*1helloworld.rb*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*1helloworld.rb*'
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s it in its entirety. The program contains one method, `puts`, and one
    string, “hello world.” It doesn’t have any headers or class definitions, and it
    doesn’t have any import sections or “main” functions. This really is as simple
    as it gets. Load the code, *1helloworld.rb*, and try it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的全部内容。程序包含一个方法，`puts`，和一个字符串，“hello world。”它没有任何头文件或类定义，也没有任何导入部分或“main”函数。这真的是简单到极致。加载代码，`*1helloworld.rb*`，然后尝试运行。
- en: Getting and Putting Input
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和输出输入
- en: 'Having “put” a string to the output (here, a command window), the obvious next
    step is to “get” a string. As you might guess, the Ruby method for this is `gets`.
    The *2helloname.rb* program prompts the user for his or her name—let’s suppose
    it’s Fred—and then displays a greeting: “Hello Fred.” Here is the code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串“输出”到输出（这里是一个命令窗口）后，明显的下一步是“获取”一个字符串。正如你可能猜到的，Ruby 用于此的方法是 `gets`。`*2helloname.rb*`
    程序提示用户输入他的或她的名字——假设它是 Fred——然后显示问候：“Hello Fred。”以下是代码：
- en: '*2helloname.rb*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*2helloname.rb*'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although this is still very simple, a few important details need to be explained.
    First, notice that I’ve used `print` rather than `puts` to display the prompt.
    This is because `puts` adds a line feed at the end of the printed string, whereas
    `print` does not; in this case, I want the cursor to remain on the same line as
    the prompt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这仍然非常简单，但需要解释一些重要的细节。首先，请注意，我使用了 `print` 而不是 `puts` 来显示提示。这是因为 `puts` 在打印的字符串末尾添加一个换行符，而
    `print` 则不会；在这种情况下，我希望光标保持在提示的同一行。
- en: On the next line, I use `gets()` to read in a string when the user presses enter.
    This string is assigned to the variable `name`. I have not predeclared this variable,
    nor have I specified its type. In Ruby, you can create variables as and when you
    need them, and the interpreter “infers” their types. In the example, I have assigned
    a string to `name` so Ruby knows that the type of the `name` variable must be
    a string.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我使用 `gets()` 读取用户按下回车键时输入的字符串。这个字符串被分配给变量 `name`。我没有预先声明这个变量，也没有指定其类型。在
    Ruby 中，你可以在需要时创建变量，解释器“推断”它们的类型。在这个例子中，我将一个字符串分配给 `name`，这样 Ruby 就知道 `name` 变量的类型必须是字符串。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ruby is case sensitive. A variable called `myvar` is different from one called
    `myVar`. A variable such as `name` in the sample project must begin with a lowercase
    character. If it begins with an uppercase character, Ruby will treat it as a constant.
    I’ll have more to say on constants in [Chapter 6](ch06.html "Chapter 6. Conditional
    Statements").
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 区分大小写。一个名为 `myvar` 的变量与一个名为 `myVar` 的变量不同。在示例项目中，变量如 `name` 必须以小写字母开头。如果它以大写字母开头，Ruby
    会将其视为常量。我将在[第 6 章](ch06.html "第 6 章。条件语句")中更多地讨论常量。
- en: Incidentally, the parentheses following `gets()` are optional, as are the parentheses
    enclosing the strings after `print` and `puts`; the code would run just the same
    if you removed them. However, parentheses can help resolve ambiguities, and in
    some cases, the interpreter will warn you if you omit them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`gets()` 后面的括号是可选的，`print` 和 `puts` 后面括号包围的字符串也是可选的；如果你去掉它们，代码仍然会正常运行。然而，括号可以帮助解决歧义，并且在某些情况下，如果省略了它们，解释器会警告你。
- en: Strings and Embedded Evaluation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和嵌入式评估
- en: 'The last line in the sample code is rather interesting:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的最后一行相当有趣：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here the `name` variable is embedded into the string. You do this by placing
    the variable between two curly brackets preceded by a *hash mark* (or “number”
    or “pound” character), as in `#{}`. This kind of *embedded* evaluation works only
    with strings delimited by double quotes. If you were to try this with a string
    delimited by single quotes, the variable would not be evaluated, and the string
    `''Hello #{name}''` would be displayed exactly as entered.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`name` 变量被嵌入到字符串中。你这样做是通过将变量放在由星号（或“数字”或“井号”字符）前缀的两个大括号之间，例如 `#{}`。这种*嵌入式*评估仅适用于双引号分隔的字符串。如果你尝试用单引号分隔的字符串这样做，变量将不会被评估，字符串
    `''Hello #{name}''` 将会按原样显示。'
- en: 'You can also embed nonprinting characters such as newlines (`"\n"`) and tabs
    (`"\t"`), and you can even embed bits of program code and mathematical expressions.
    For instance, let’s assume you have a method called `showname` that returns the
    string “Fred.” The following string would, in the process of evaluation, call
    the `showname` method and display “Hello Fred”:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以嵌入非打印字符，如换行符（`"\n"`）和制表符（`"\t"`），甚至可以嵌入程序代码和数学表达式。例如，假设你有一个名为 `showname`
    的方法，它返回字符串 “Fred.”。以下字符串在评估过程中会调用 `showname` 方法并显示 “Hello Fred”：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'See whether you can figure out what would be displayed by the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能猜出以下代码会显示什么：
- en: '*3string_eval.rb*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*3string_eval.rb*'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now run the *3string_eval.rb* program to see whether you are right.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 *3string_eval.rb* 程序，看看你是否正确。
- en: Numbers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Numbers are just as easy to use as strings. For example, let’s suppose you
    want to calculate the selling price or grand total of some item based on its pretax
    value or subtotal. To do this, you would need to multiply the subtotal by the
    applicable tax rate and add the result to the value of the subtotal. Assuming
    the subtotal to be $100 and the tax rate to be 17.5 percent, this Ruby program
    does the calculation and displays the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的使用与字符串一样简单。例如，假设你想根据某项商品不含税价值或小计来计算销售价格或总金额。为此，你需要将小计乘以适用的税率，并将结果加到小计的价值上。假设小计为
    $100，税率为 17.5%，以下 Ruby 程序执行计算并显示结果：
- en: '*4calctax.rb*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*4calctax.rb*'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Obviously, this program would be more useful if it could perform calculations
    on a variety of subtotals rather than calculating the same value time after time!
    Here is a simple calculator that prompts the user to enter a subtotal:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果这个程序能够对各种小计进行计算，而不是反复计算相同的值，将会更有用！以下是一个简单的计算器，它会提示用户输入小计：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here `s.to_f` is a method of the String class. It attempts to convert the string
    to a floating-point number. For example, the string `"145.45"` would be converted
    to the floating-point number 145.45\. If the string cannot be converted, 0.0 is
    returned. For instance, `"Hello world".to_f` would return 0.0.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `s.to_f` 是 String 类的一个方法。它尝试将字符串转换为浮点数。例如，字符串 `"145.45"` 将被转换为浮点数 145.45。如果字符串无法转换，则返回
    0.0。例如，`"Hello world".to_f` 将返回 0.0。
- en: Comments
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Many of the source code examples that come with this book are documented with
    comments that are ignored by the Ruby interpreter. You can place a comment after
    the hash mark (`#`). The text on a line following this character is all treated
    as a comment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与本书一起提供的源代码示例都带有注释，这些注释会被 Ruby 解释器忽略。你可以在散列符号（`#`）之后放置注释。该符号之后的整行文本都被视为注释：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to comment out multiple lines of text, you can place `=begin` at
    the start and `=end` at the end (both `=begin` and `=end` must be flush with the
    left margin):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想注释掉多行文本，可以在开始处放置 `=begin`，在结尾处放置 `=end`（`=begin` 和 `=end` 必须与左边缘对齐）：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Testing a Condition: if..then'
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试条件：if..then
- en: 'The problem with the simple tax calculator code shown earlier is that it accepts
    negative subtotals and calculates negative tax on them—a situation upon which
    the government is unlikely to look favorably! I therefore need to check for negative
    numbers and, when found, set them to zero. This is my new version of the code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的简单税费计算器代码的问题在于它接受负小计并对其计算负税费——这种情况政府可能不会持乐观态度！因此，我需要检查负数，并在找到时将它们设置为零。这是我的新代码版本：
- en: '*5taxcalculator.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*5taxcalculator.rb*'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The Ruby `if` test is similar to an `if` test in other programming languages.
    Note, however, that the parentheses are once again optional, as is the keyword
    `then`. However, if you were to write the following, with no line break after
    the test condition, the `then` would be obligatory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 `if` 测试与其他编程语言中的 `if` 测试类似。注意，然而，括号是可选的，关键字 `then` 也是可选的。然而，如果你要写以下内容，且测试条件后没有换行，则
    `then` 是必需的：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Putting everything on one line like this adds nothing to the clarity of the
    code, which is why I tend to avoid it. My long familiarity with Pascal instinctively
    makes me want to add a `then` after the `if` condition, but because this really
    is not required, you may look upon this as a willful eccentricity of mine. The
    `end` keyword that terminates the `if` block is *not* optional. If you forget
    to add it, your code will not run.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一行中，像这样并不会增加代码的清晰度，这就是为什么我倾向于避免这样做。我对Pascal的长期熟悉使我本能地想要在`if`条件之后添加一个`then`，但因为这个实际上并不是必需的，你可以把这看作是我的一种任性的古怪行为。终止`if`块的`end`关键字是*不是*可选的。如果你忘记添加它，你的代码将无法运行。
- en: Local and Global Variables
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部和全局变量
- en: 'In the previous example, I assigned values to variables such as `subtotal`,
    `tax`, and `taxrate`. Variables such as these that begin with a lowercase character
    are called *local variables*. This means they exist only within a specific part
    of a program—in other words, they are restricted to a well-defined scope. Here
    is an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我给变量如`subtotal`、`tax`和`taxrate`赋值。以小写字母开头的变量，如这些，被称为*局部变量*。这意味着它们只存在于程序的一个特定部分——换句话说，它们被限制在一个明确的范围内。以下是一个例子：
- en: '*variables.rb*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*variables.rb*'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the previous code, there are two functions (or *methods*), `amethod` and
    `anotherMethod`, each of which is declared using the keyword `def` and contains
    code up to the keyword `end`. There are three local variables called `localvar`.
    One is assigned the value `"hello"` within the “main scope” of the program; two
    others are assigned integers within the scope of two separate methods. Since each
    local variable has a different scope, the assignments have no effect on the other
    local variables with the same name in different scopes. You can verify this by
    calling the methods in turn. The following examples show output in comments followed
    by the `=>` characters. In this book, output or returned values will often be
    indicated in this way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，有两个函数（或*方法*），`amethod`和`anotherMethod`，每个都使用关键字`def`声明，并包含到`end`关键字之前的代码。有三个名为`localvar`的局部变量。一个在程序的“主要作用域”内被赋予了`"hello"`的值；另外两个在两个不同的方法的作用域内被赋予了整数。由于每个局部变量有不同的作用域，这些赋值对在不同作用域中具有相同名称的其他局部变量没有影响。你可以通过依次调用这些方法来验证这一点。以下示例显示了注释后的输出，后跟`=>`字符。在这本书中，输出或返回值通常会以这种方式表示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the other hand, a *global variable*—one that begins with the dollar sign
    character (`$`)—has global scope. When an assignment is made to a global variable
    inside a method, that affects the value of that variable elsewhere in the program
    too:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一个*全局变量*——以美元符号字符（`$`）开头——具有全局作用域。当在方法内部对一个全局变量进行赋值时，这也会影响程序其他地方该变量的值：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Classes and Objects
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: Instead of going through all the rest of Ruby’s syntax—its types, loops, modules,
    and so on—let’s move rapidly on and look at how to create classes and objects.
    (But fear not, we’ll return to those other topics soon.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不一一介绍Ruby的所有语法——它的类型、循环、模块等等——而是快速地看看如何创建类和对象。（但别担心，我们很快就会回到那些其他主题。）
- en: 'Basic Terminology: Classes, Objects, and Methods'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本术语：类、对象和方法
- en: 'A class is the blueprint for an object. It defines the data an object contains
    and the way it behaves. Many different objects can be created from a single class.
    So, you might have one Cat *class* but three cat *objects*: tiddles, cuddles,
    and flossy. A *method* is like a function or subroutine that is defined inside
    the class.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的蓝图。它定义了对象包含的数据以及它的行为方式。可以从单个类创建许多不同的对象。因此，你可能有一个Cat *类*，但三个cat *对象*：tiddles、cuddles和flossy。*方法*就像是在类内部定义的函数或子程序。
- en: 'It may seem like no big deal to say that Ruby is object-oriented. Aren’t all
    languages these days? Well, up to a point. Most modern “object-oriented” languages
    (Java, C++, C#, Object Pascal, and so on) have a greater or lesser degree of object-oriented
    programming (OOP) features. Ruby, on the other hand, is obsessively object-oriented.
    In fact, unless you have programmed in Smalltalk or Eiffel (languages that are
    even more obsessive than Ruby about objects), it is likely to be the most object-oriented
    language you have ever used. Every chunk of data—from a simple number or string
    to something more complicated like a file or a module—is treated as an object.
    And almost everything you do with an object is done by a method. Even operators
    such as plus (`+`) and minus (`−`) are methods. Consider the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 说 Ruby 是面向对象的可能看起来没什么大不了的。现在不是所有语言都是这样吗？好吧，在一定程度上是这样的。大多数现代的“面向对象”语言（Java、C++、C#、Object
    Pascal 等等）都有不同程度的面向对象编程（OOP）特性。然而，Ruby 则是极度面向对象的。实际上，除非你曾经使用过 Smalltalk 或 Eiffel（这些语言对对象的执着甚至超过
    Ruby），否则 Ruby 可能是你用过的最面向对象的编程语言。每一块数据——从简单的数字或字符串到更复杂的东西，如文件或模块——都被视为对象。而且，你几乎用对象做的所有事情都是通过方法完成的。甚至像加号（`+`）和减号（`−`）这样的运算符也是方法。考虑以下例子：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here `+` is a method of the Fixnum (Integer) object 1\. The value 2 is sent
    to this method; the result, 3, is returned, and this is assigned to the object
    x. Incidentally, the assignment operator (`=`) is one of the rare exceptions to
    the rule that “everything you do with an object is done by a method.” The assignment
    operator is a special built-in “thingummy” (this is not the formal terminology,
    I hasten to add), and it is not a method of anything.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`+` 是 Fixnum（整数）对象 1 的一个方法。值 2 被发送到这个方法；结果是 3，然后返回，并分配给对象 x。顺便提一下，赋值运算符（`=`）是“你用对象做的所有事情都是通过方法完成”的规则中罕见的例外之一。赋值运算符是一个特殊的内置“东西”（我急忙补充，这不是正式术语），它不是任何东西的方法。
- en: 'Now you’ll see how to create objects of your own. As in most other OOP languages,
    a Ruby object is defined by a class. The class is like a blueprint from which
    individual objects are constructed. For example, this class defines a dog:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到如何创建自己的对象。在大多数其他面向对象编程语言中，Ruby 对象是由类定义的。类就像一个蓝图，从该蓝图构建单个对象。例如，这个类定义了一只狗：
- en: '*6dogs.rb*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*6dogs.rb*'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the class definition begins with the keyword `class` (all lowercase)
    and the name of the class itself, which must begin with an uppercase letter. The
    class contains a method called `set_name`. This takes an incoming argument, `aName`.
    The body of the method assigns the value of `aName` to a variable called `@myname`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类定义以关键字 `class`（全部小写）和类名本身开始，类名必须以大写字母开头。该类包含一个名为 `set_name` 的方法。该方法接受一个传入参数，`aName`。方法体将
    `aName` 的值赋给一个名为 `@myname` 的变量。
- en: Instance Variables
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例变量
- en: 'Variables beginning with the at sign (`@`) are *instance variables*, which
    means they belong to individual objects (or *instances*) of the class. It is not
    necessary to predeclare instance variables. I can create instances of the Dog
    class (that is, “dog objects”) by calling the `new` method. Here I am creating
    two dog objects (note that although class names begin with uppercase letters,
    object names begin with lowercase letters):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以井号（`@`）开头的变量是 *实例变量*，这意味着它们属于类的单个对象（或 *实例*）。不需要预先声明实例变量。我可以通过调用 `new` 方法来创建
    Dog 类的实例（即“狗对象”）。在这里，我创建了两个狗对象（注意，尽管类名以大写字母开头，但对象名以小写字母开头）：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the moment, these two dogs have no names. So, the next thing I do is call
    the `set_name` method to give them names:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这两只狗还没有名字。所以，接下来我要做的是调用 `set_name` 方法来给它们命名：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Retrieving Data from an Object
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从对象中检索数据
- en: 'Having given each dog a name, I need to have some way to find out their names
    later. How should I do this? I can’t poke around inside an object to get at the
    `@name` variable, since the internal details of each object are known only to
    the object itself. This is a fundamental principle of “pure” object orientation:
    The data inside each object is private. There are precisely defined ways into
    each object (for example, the method `set_name`) and precisely defined ways out.
    Only the object itself can mess around with its internal state; the outside world
    cannot. This is called *data hiding*, and it is part of the principle of *encapsulation*.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 给每只狗取了名字后，我需要有一种方法来在以后找出它们的名字。我该如何做呢？我不能在对象内部乱翻来获取 `@name` 变量，因为每个对象的内部细节只有对象本身才知道。这是“纯”面向对象的一个基本原则：每个对象内部的数据是私有的。每个对象都有精确的进入和退出方式（例如，`set_name`
    方法）和精确的退出方式。只有对象本身可以随意处理其内部状态；外部世界不能。这被称为 *数据隐藏*，它是 *封装* 原则的一部分。
- en: Encapsulation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 封装
- en: '*Encapsulation* describes the fact that an object contains both its own data
    and the methods required to manipulate that data. Some object-oriented languages
    encourage or enforce *data hiding* so that the data encapsulated within an object
    cannot be accessed by code outside that object. In Ruby, data hiding is not quite
    as rigorously enforced as it initially appears. You can use some very dirty tricks
    to mess around inside an object, but to keep things simple, I’ll silently pass
    over these features of the language for now.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装* 描述了对象包含其自己的数据和操作这些数据所需的方法的事实。一些面向对象的语言鼓励或强制执行 *数据隐藏*，以便对象内部封装的数据不能被该对象之外的其他代码访问。在
    Ruby 中，数据隐藏的执行并不像最初看起来那么严格。你可以使用一些非常脏的技巧来在对象内部捣乱，但为了简单起见，我现在会默默地忽略这个语言的这些特性。'
- en: 'Since you need each dog to know its own name, let’s provide the Dog class with
    a `get_name` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你需要每只狗都知道自己的名字，让我们为 Dog 类提供一个 `get_name` 方法：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `return` keyword here is optional. When it is omitted, Ruby methods will
    return the last expression evaluated. However, for the sake of clarity—and to
    avoid unexpected results from methods more complex than this one—I will make a
    habit of explicitly returning any values that I plan to use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `return` 关键字是可选的。当它被省略时，Ruby 方法将返回最后一个评估的表达式。然而，为了清晰起见——以及避免比这个更复杂的方法带来的意外结果——我将养成显式返回任何我打算使用的值的习惯。
- en: 'Finally, let’s give the dog some behavior by asking it to talk. Here is the
    finished class definition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过让狗说话来给它一些行为。下面是完成后的类定义：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you can create a dog, name it, display its name, and ask it to talk:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建一只狗，给它取名字，显示它的名字，并让它说话：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I’ve written an expanded version of this code in the *6dogs.rb* program. This
    also contains a Cat class that is similar to the Dog class except that its `talk`
    method, naturally enough, returns a *meow* instead of a *woof*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 *6dogs.rb* 程序中编写了这个代码的扩展版本。这个版本还包含一个与 Dog 类相似的 Cat 类，除了它的 `talk` 方法，自然地返回一个
    *喵喵* 而不是 *汪汪*。
- en: What Happens When a Variable Is Unassigned?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量未分配时会发生什么？
- en: 'Oops! It seems that this program contains an error. The object named `someotherdog`
    never has a value assigned to its `@name variable` since its `set_name()` method
    is never called. This means the following code, which attempts to print its name,
    cannot succeed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！看来这个程序包含了一个错误。名为 `someotherdog` 的对象从未为其 `@name` 变量分配值，因为它的 `set_name()` 方法从未被调用。这意味着以下尝试打印其名称的代码无法成功：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Fortunately, Ruby doesn’t blow up when you try to display this dog’s name. Instead,
    it just prints “nil.” You’ll shortly look at a simple way of making sure that
    errors like this don’t happen again.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当你尝试显示这只狗的名字时，Ruby 并不会崩溃。相反，它只是打印出“nil。”你很快就会看到一种简单的方法来确保这种错误不再发生。
- en: Messages, Methods, and Polymorphism
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息、方法和多态性
- en: This cats and dogs example, incidentally, is based on a classic Smalltalk demo
    program that illustrates how the same “message” (such as `talk`) can be sent to
    different objects (such as cats and dogs), and each different object responds
    differently to the same message with its own special method (here the `talk` method).
    The ability to have different classes containing methods with the same name goes
    by the fancy object-oriented name of *polymorphism*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这个猫和狗的例子是基于一个经典的 Smalltalk 演示程序，它说明了相同的“消息”（例如 `talk`）可以发送到不同的对象（例如猫和狗），并且每个不同的对象都会用其自己的特殊方法（这里是指
    `talk` 方法）对相同的消息做出不同的响应。具有包含具有相同名称的方法的不同类的能力，可以用花哨的面向对象术语 *多态性* 来描述。
- en: When you run a program such as *6dogs.rb*, the code is executed in sequence.
    The code of the classes themselves is not executed until instances of those classes
    (that is, objects) are created by the code at the bottom of the program. You will
    see that I frequently mix class definitions with “free-standing” bits of code
    that execute when the program is run. This may not be the way you would want to
    write a major application, but for just trying things, it is extremely convenient.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个如 *6dogs.rb* 的程序时，代码是按顺序执行的。类本身的代码不会执行，直到程序底部的代码创建了这些类的实例（即对象）。你会发现我经常将类定义与在程序运行时执行的“自由”代码块混合。这可能不是你编写主要应用程序的方式，但仅用于尝试事情，它非常方便。
- en: Free-Standing Bits of Code?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 自由代码块？
- en: 'If Ruby is really an object-oriented language, you may think it’s odd that
    you can enter “free-floating” methods. In fact, when you run a program, Ruby creates
    a main object, and any code that appears inside your main code unit—that is, the
    main Ruby code file you have loaded and run—is actually running inside that object.
    You can easily verify this by creating a new source file and adding the following
    code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为 Ruby 真的是一个面向对象的语言，你可能觉得可以输入“自由浮动”的方法很奇怪。实际上，当你运行一个程序时，Ruby 会创建一个主对象，而你主代码单元（即你加载并运行的主
    Ruby 代码文件）中的任何代码实际上都是在那个对象内部运行的。你可以通过创建一个新的源文件并添加以下代码来轻松验证这一点：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run this program, you’ll see the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到以下输出：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: One obvious defect of this program is that the two classes, Cat and Dog, are
    highly repetitious. It would make more sense to have one class, Animal, that has
    `get_name` and `set_name` methods and two descendant classes, Cat and Dog, that
    contain only the behavior specific to that species of animal (woofing or meowing).
    We’ll find out how to do this in the next chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的一个明显缺陷是，两个类，猫和狗，非常重复。有一个类，动物（Animal），它有 `get_name` 和 `set_name` 方法，而两个子类，猫和狗，只包含特定物种动物的行为（汪汪叫或喵喵叫）会更合理。我们将在下一章中了解到如何做到这一点。
- en: 'Constructors: new and initialize'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数：new 和 initialize
- en: Let’s take a look at another example of a user-defined class. Load *7treasure.rb*.
    This is an adventure game in the making. It contains two classes, Thing and Treasure.
    The Thing class is similar to the Cat and Dog classes from the previous program—except
    that it doesn’t woof or meow, that is.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个用户自定义类的另一个例子。加载 *7treasure.rb*。这是一个正在制作中的冒险游戏。它包含两个类，物品（Thing）和宝藏（Treasure）。物品类与之前程序中的猫（Cat）和狗（Dog）类类似——只不过它不会汪汪叫或喵喵叫，就是这样。
- en: '*7treasure.rb*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*7treasure.rb*'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Treasure class doesn’t have `get_name` and `set_name` methods. Instead,
    it contains a method named `initialize`, which takes two arguments. Those two
    values are then assigned to the `@name` and `@description` variables. When a class
    contains a method named `initialize`, it will be called automatically when an
    object is created using the `new` method. This makes it a convenient place to
    set the values of an object’s instance variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 宝藏类没有 `get_name` 和 `set_name` 方法。相反，它包含一个名为 `initialize` 的方法，它接受两个参数。这两个值随后被分配给
    `@name` 和 `@description` 变量。当一个类包含一个名为 `initialize` 的方法时，当使用 `new` 方法创建对象时，它将自动被调用。这使得它是一个设置对象实例变量值的方便位置。
- en: This has two clear benefits over setting each instance variable using methods
    such `set_name`. First, a complex class may contain numerous instance variables,
    and you can set the values of all of them with the single `initialize` method
    rather than with many separate “set” methods; second, if the variables are all
    automatically initialized at the time of object creation, you will never end up
    with an “empty” variable (like the “nil” value returned when you tried to display
    the name of someotherdog in the previous program).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个明显的优点，比使用 `set_name` 这样的方法设置每个实例变量要好。首先，一个复杂的类可能包含许多实例变量，你可以使用单个 `initialize`
    方法设置所有这些变量的值，而不是使用许多单独的“设置”方法；其次，如果变量在对象创建时自动初始化，你就不会得到一个“空”变量（就像在之前程序中尝试显示某个其他狗的名字时返回的“nil”值）。
- en: Finally, I have created a method called `to_s`, which returns a string representation
    of a Treasure object. The method name, `to_s`, is not arbitrary—the same method
    name is used throughout the standard Ruby object hierarchy. In fact, the `to_s`
    method is defined for the Object class itself, which is the ultimate ancestor
    of all other classes in Ruby (with the exception of the BasicObject class, which
    you’ll look at more closely in the next chapter). By redefining the `to_s` method,
    I have added new behavior that is more appropriate to the Treasure class than
    the default method. In other words, I have *overridden* its `to_s` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我创建了一个名为 `to_s` 的方法，它返回 Treasure 对象的字符串表示形式。方法名 `to_s` 不是任意的——在标准的 Ruby 对象层次结构中使用了相同的方法名。实际上，`to_s`
    方法是为 Object 类本身定义的，它是 Ruby 中所有其他类的最终祖先（除了 BasicObject 类，你将在下一章中更详细地了解）。通过重新定义
    `to_s` 方法，我添加了更适合 Treasure 类的新行为。换句话说，我 *重写* 了它的 `to_s` 方法。
- en: Since the `new` method creates an object, it can be thought of as the object’s
    *constructor*. A constructor is a method that allocates memory for an object and
    then executes the `initialize` method, if it exists, to assign any specified values
    to the new object’s internal variables. You should not normally implement your
    own version of the `new` method. Instead, when you want to perform any “setup”
    actions, do so in the `initialize` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `new` 方法创建了一个对象，它可以被认为是对象的 *构造函数*。构造函数是一个为对象分配内存并执行（如果存在）`initialize` 方法以将指定的值分配给新对象的内部变量的方法。你通常不应该实现自己的
    `new` 方法版本。相反，当你想要执行任何“设置”操作时，应在 `initialize` 方法中执行。
- en: Garbage Collection
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: In many languages (such as C++ and Delphi for Win32), it is the programmer’s
    responsibility to destroy any object that has been created when it is no longer
    required. In other words, objects are given *destructors* as well as constructors.
    This isn’t necessary in Ruby, since a built-in *garbage collector* automatically
    destroys objects and reclaims the memory they used when they are no longer referenced
    in your program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言（如 C++ 和 Delphi for Win32）中，当对象不再需要时，程序员有责任销毁任何创建的对象。换句话说，对象既有 *析构函数* 也有
    *构造函数*。在 Ruby 中这不是必要的，因为内置的 *垃圾回收器* 会自动销毁对象并回收它们不再被程序引用时使用的内存。
- en: Inspecting Objects
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象
- en: 'Notice that in the *7treasure.rb* program I “looked inside” the Treasure object
    t1 using the `inspect` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 *7treasure.rb* 程序中，我使用了 `inspect` 方法“查看”了 Treasure 对象 t1 的内部结构：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `inspect` method is defined for all Ruby objects. It returns a string containing
    a human-readable representation of the object. In the present case, it displays
    something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect` 方法为所有 Ruby 对象定义。它返回一个包含对象人类可读表示的字符串。在本例中，它显示如下：'
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This begins with the class name, Treasure. This is followed by a number, which
    may be different from the number shown earlier—this is Ruby’s internal identification
    code for this particular object. Next the names and values of the object’s variables
    are shown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这以类名 Treasure 开头。接下来是一个数字，这个数字可能与之前显示的数字不同——这是 Ruby 为这个特定对象提供的内部识别码。接下来显示了对象的变量名称和值。
- en: 'Ruby also provides the `p` method as a shortcut to inspect objects and print
    their details, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 还提供了 `p` 方法作为检查对象和打印其详细信息的快捷方式，如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'where `anobject` can be any type of Ruby object. For example, let’s suppose
    you create the following three objects: a string, a number, and a Treasure object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `anobject` 可以是任何类型的 Ruby 对象。例如，假设你创建了以下三个对象：一个字符串、一个数字和一个 Treasure 对象：
- en: '*p.rb*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*p.rb*'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now you can use `p` to display those objects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `p` 来显示这些对象：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is what Ruby displays:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Ruby 显示的内容：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To see how you can use `to_s` with a variety of objects and test how a Treasure
    object would be converted to a string in the absence of an overridden `to_s` method,
    try the *8to_s.rb* program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 `to_s` 与各种对象，并测试在没有重写 `to_s` 方法的情况下 Treasure 对象将如何转换为字符串，请尝试 *8to_s.rb*
    程序。
- en: '*8to_s.rb*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*8to_s.rb*'
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you will see, classes such as Class, Object, String, and Treasure simply
    return their names when the `to_s` method is called. An object, such as the Treasure
    object t, returns its identifier—which is the same identifier returned by the
    `inspect` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当调用 `to_s` 方法时，Class、Object、String 和 Treasure 等类会简单地返回它们的名称。一个对象，例如 Treasure
    对象 t，会返回它的标识符——这个标识符与 `inspect` 方法返回的标识符相同：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Although the *7treasure.rb* program may lay the foundations for a game containing
    a variety of different object types, its code is still repetitive. After all,
    why have a Thing class that contains a name and a Treasure class that also contains
    a name? It would make more sense to regard a Treasure as a “type of” Thing. In
    a complete game, other objects such as Rooms and Weapons might be yet other types
    of Thing. It is clearly time to start working on a proper class hierarchy, which
    is what you will do in the next chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 *7treasure.rb* 程序可能为包含多种不同对象类型的游戏奠定了基础，但其代码仍然重复。毕竟，为什么会有一个包含名称的 Thing 类和一个也包含名称的
    Treasure 类？将 Treasure 视为“一种” Thing 更有意义。在一个完整的游戏中，其他对象如 Rooms 和 Weapons 可能是 Thing
    的其他类型。显然，是时候开始构建合适的类层次结构了，这正是你将在下一章中要做的。
