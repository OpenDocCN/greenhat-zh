- en: Chapter 7. Root, and How to Avoid It
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。根用户，以及如何避免它
- en: '*The root of all evil*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*万恶之源*'
- en: '*is never far from your touch.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远都不会离你太远。*'
- en: '*sudo saves your life.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*sudo可以救你的命。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) The security of most
    Unix-like operating systems has long been considered coarsely grained. One superuser,
    root, can do anything. Other users are lowly sharecroppers who endure the shackles
    root places upon them. The problem is that root doesn’t have many shackles and
    it can’t individualize the ones that it has very well. Some operating systems
    use POSIX access control lists (ACLs) to provide more fine-grained access controls,
    but these are difficult to configure correctly.^([[15](#ftn.id411230)])'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages1616079.png) 大多数类Unix操作系统的安全性长期以来一直被认为是大粒度的。一个超级用户，root，可以做任何事情。其他用户则是低微的佃农，忍受着root强加在他们身上的枷锁。问题是root没有多少枷锁，而且它并不能很好地个性化它所拥有的枷锁。一些操作系统使用POSIX访问控制列表（ACLs）来提供更细粒度的访问控制，但这些配置起来很困难.^([[15](#ftn.id411230)])'
- en: While it’s true that Unix-like operating systems don’t have detailed access
    controls, the fact is that most people don’t bother using the controls that *do*
    exist. Fortunately, you can combine groups and permissions to handle almost any
    problem securely.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类Unix操作系统的确没有详细的访问控制，但事实是大多数人并不麻烦去使用那些确实存在的控制。幸运的是，你可以结合组和权限来安全地处理几乎所有问题。
- en: The Root Password
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根用户密码
- en: The root user owns the system and has absolute power over every piece of hardware
    as well as certain actions that require absolute control, such as manipulating
    the kernel and changing authentication sources. You need root permissions to perform
    these tasks. You can log in as root, use `su(1)` to become root, or use `sudo(8)`
    (discussed later this chapter) to get certain root-level privileges without actually
    using the root account.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: root用户拥有系统，并对每一块硬件以及某些需要绝对控制的动作拥有绝对权力，例如操作内核和更改认证源。你需要root权限来执行这些任务。你可以以root身份登录，使用`su(1)`成为root，或者使用`sudo(8)`（本章后面将讨论）来获取某些root级别的权限，而不必实际使用root账户。
- en: 'To use the root password, you can either log in as root at a console login
    prompt or, if you belong to the group `wheel`, log in as yourself and use the
    switch user command `su(1)`. Of the two, I recommend using `su`; it logs who uses
    it and can be used when you are logged in from a remote system. To use `su`, run
    the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用root密码，你可以要么在控制台登录提示符下以root身份登录，要么如果你属于`wheel`组，以自己的身份登录并使用切换用户命令`su(1)`。在这两种方法中，我推荐使用`su`；它会记录谁在使用它，并且当你从远程系统登录时也可以使用。要使用`su`，请运行以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When prompted, enter the root password. Now check your current user ID with
    `id(1)`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示时，输入root密码。现在使用`id(1)`检查你的当前用户ID。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the UID is 0, which means that you now own the system, and I
    do mean *own* it. Consider every keystroke carefully. Carelessness could return
    your hard drive to its primordial, unformatted state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，UID是0，这意味着你现在拥有系统，而且我确实是指*拥有*它。仔细考虑每一个按键。粗心大意可能会让你的硬盘回到原始的、未格式化的状态。
- en: Only users in the group `wheel` can use the root password to become root via
    `su`. If you give the root password to users without physical console access and
    who are in the `wheel` group, they can enter `su` and the root password as many
    times as they want, and it won’t work. (But anyone can use the root account and
    password at the system console, so don’t make a habit of blabbing the root password
    all around the office.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`wheel`组中的用户才能使用root密码通过`su`成为root。如果你将root密码给了没有物理控制台访问权限且在`wheel`组中的用户，他们可以多次输入`su`和root密码，但这不会起作用。（但任何人都可以在系统控制台使用root账户和密码，所以不要养成在办公室到处泄露root密码的习惯。）
- en: Requiring group membership to use the root password leads to the question, “Who
    needs root access?” Root is required to configure many parts of OpenBSD, but once
    the system is running properly, you can greatly decrease or discontinue your use
    of root. For any remaining tasks that absolutely require root, use `sudo`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要求加入组才能使用root密码引发了一个问题：“谁需要root访问权限？”root是配置OpenBSD许多部分所必需的，但一旦系统正常运行，你可以大大减少或停止使用root。对于任何绝对需要root的剩余任务，请使用`sudo`。
- en: Using Groups
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组
- en: One of the simplest ways to reduce the need for root is with groups. Unix-like
    operating systems classify users into groups, which consist of accounts of users
    who perform similar administrative functions. You can, for example, define a group
    named `dnsadmins` and add the accounts of every user who edits DNS zone files
    to that group. Then, by setting the permissions of the zone files and their directory
    appropriately, members of that group can edit zone files and reload the name server
    without the root password. The good news is that you could create such a group
    for almost any system function, and thereby avoid giving those users root access.
    Using groups in this manner is a powerful and often neglected system administration
    tool. I use groups for administering my own servers—just because I *can* use root
    doesn’t mean that I *want* to use root. Users can identify the groups they belong
    to by using `id(1)`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 减少对root需求的最简单方法之一是使用组。类Unix操作系统将用户分类到组中，这些组由执行类似管理功能的用户账户组成。例如，你可以定义一个名为 `dnsadmins`
    的组，并将编辑DNS区域文件的每个用户的账户添加到该组中。然后，通过适当地设置区域文件及其目录的权限，该组的成员可以编辑区域文件并重新加载名称服务器，而无需root密码。好消息是，你可以为几乎任何系统功能创建这样的组，从而避免给这些用户root访问权限。以这种方式使用组是一种强大且常被忽视的系统管理工具。我使用组来管理我自己的服务器——仅仅因为我
    *可以* 使用root，并不意味着我 *想要* 使用root。用户可以通过使用 `id(1)` 来识别他们所属的组。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: My UID is 1000, and my username is `mwlucas`. My GID, the primary group ID,
    is also 1000 and is also named `mwlucas`. I’m also in the `wheel` and `dnsadmin`
    groups.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我的UID是1000，我的用户名是 `mwlucas`。我的GID，即主要组ID，也是1000，并且也命名为 `mwlucas`。我还在 `wheel`
    和 `dnsadmin` 组中。
- en: The /etc/group File
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /etc/group 文件
- en: 'The file */etc/group* contains all group information. Each line contains four
    colon-delimited fields: the group name, password, ID number, and list of members.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 */etc/group* 包含所有组信息。每一行包含四个由冒号分隔的字段：组名、密码、ID号和成员列表。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *group name* is a human-friendly name for the group. This group is named
    `wheel`. Group names are completely arbitrary and you could call a group `lickspittles`
    if you want, but you should choose a name that gives an idea of the group’s purpose.
    While you might remember that `lickspittles` can edit the company web page, will
    that group name make any sense to your coworkers? If it does, you probably need
    better coworkers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*组名* 是组的一个便于人类理解的名字。这个组被命名为 `wheel`。组名完全是任意的，如果你想，你可以将一个组命名为 `lickspittles`，但你应该选择一个能让人想到组目的的名字。虽然你可能记得
    `lickspittles` 可以编辑公司网页，但这个组名对你的同事来说有意义吗？如果有，你可能需要更好的同事。'
- en: The second field, the group password, was a great theory that became an appalling
    practice once exposed to the real world. Modern Unix-like systems don’t do anything
    with the group password, but the field remains because old programs expect to
    find something here. The asterisk is just a placeholder to placate such software.
    (While OpenBSD could eliminate this field, some enterprises share */etc/group*
    across operating systems.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段是组密码，这是一个伟大的理论，一旦暴露在现实世界中就变成了令人震惊的实践。现代类Unix系统对组密码不做什么处理，但这个字段仍然保留，因为旧程序期望在这里找到一些内容。星号只是一个占位符，用来安抚这样的软件。（虽然OpenBSD可以消除这个字段，但一些企业会在操作系统之间共享
    */etc/group*。）
- en: The third field gives the group’s unique numeric GID. Many programs use the
    GID rather than the name to identify a group. The `wheel` group has a GID of 0\.
    The maximum GID is 232, or 4,294,967,296.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段给出了组的唯一数字GID。许多程序使用GID而不是名称来识别组。`wheel` 组的GID为0。最大的GID是232，即4,294,967,296。
- en: Last is a comma-separated list of all users in the group. As you can see, the
    users `root`, `mwlucas`, and `pkdick` are all members of the `wheel` group. To
    add users to a group, add their username to this list, but remember that no */etc/group*
    entry can contain more than 200 users or be longer than 1024 characters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是一个用逗号分隔的该组所有用户的列表。正如你所见，用户 `root`、`mwlucas` 和 `pkdick` 都是 `wheel` 组的成员。要向组中添加用户，请将他们的用户名添加到这个列表中，但请记住，没有任何
    */etc/group* 条目可以包含超过200个用户或超过1024个字符。
- en: Creating Groups
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建组
- en: In order to create a new group, you need a name and GID number. OpenBSD usually
    assigns the next free GID to a newly created group with GIDs below 1000 reserved
    for OpenBSD. Programs included in OpenBSD that need a dedicated group ID use one
    below 1000\. Software installed via the OpenBSD package system or ports (discussed
    in [Chapter 13](ch13.html "Chapter 13. Software Management")) assigns dedicated
    GIDs in the 500 to 1000 range. GIDs for user accounts start at 1000 and go up.
    If you create groups for special roles, start at a high GID so that these administrative
    groups will be obviously different from user accounts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新组，你需要一个名称和 GID 号码。OpenBSD 通常将下一个可用的 GID 分配给 GID 小于 1000 的新创建的组，因为 GID
    小于 1000 的是为 OpenBSD 保留的。需要专用 GID 的 OpenBSD 包含的程序使用小于 1000 的 GID。通过 OpenBSD 软件包系统或
    ports（在第 13 章中讨论）安装的软件在 500 到 1000 范围内分配专用 GID。用户账户的 GID 从 1000 开始并向上。如果你为特殊角色创建组，从高
    GID 开始，这样这些管理组将明显不同于用户账户。
- en: Groups, Unprivileged Users, and Group Permissions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组、非特权用户和组权限
- en: The simplest way to create a new group is to use `adduser` to create an unprivileged
    user for the role, and use that user’s group to assign file permissions. As with
    any other unprivileged user, give this account the home directory */var/empty*
    and a shell of `nologin`. Do not add this user to any other groups (especially
    not `wheel`). Lastly, let `adduser` disable the account. Sure, the shell will
    prevent logins, but an extra layer of defense won’t hurt.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新组的最简单方法是用 `adduser` 命令为该角色创建一个非特权用户，并使用该用户的组来分配文件权限。与任何其他非特权用户一样，给这个账户分配
    */var/empty* 作为家目录和 `nologin` 作为 shell。不要将此用户添加到任何其他组中（特别是不要添加到 `wheel` 组）。最后，让
    `adduser` 禁用此账户。当然，shell 会阻止登录，但多一层防御也不会有害。
- en: Now that you have an administrative user and a group, you can assign file ownership.
    A user and a group own every file. To view the permissions on existing files,
    including hidden ones, use `ls -la`. (If you’ve forgotten how file ownership and
    permissions work, read `ls(1)` and `chmod(1)`.) Many system administrators focus
    on file ownership and owner permissions, invest somewhat less time on worldwide
    permissions, and gloss over group permissions as if they don’t exist. Look closely
    at the sample DNS files that follow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个管理用户和一个组，你可以分配文件所有权。每个文件都有一个用户和一个组拥有。要查看现有文件的权限，包括隐藏文件，使用 `ls -la` 命令。（如果你忘记了文件所有权和权限是如何工作的，请阅读
    `ls(1)` 和 `chmod(1)`。）许多系统管理员专注于文件所有权和所有者权限，在全局权限上花费的时间较少，并且像它们不存在一样忽略了组权限。仔细查看以下示例
    DNS 文件。
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This directory contains two files. The file *rndc.key* can be read and written
    by the user `mwlucas`; anyone in the `wheel` group can read *rndc.key*; and no
    one else can even read it. The file *michaelwlucas.com.db* can be read or written
    by the user `mwlucas` or anyone in the group `wheel`, but others can only read
    it. If you’re in the group `mwlucas`, you can edit this file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含两个文件。文件 *rndc.key* 可以被用户 `mwlucas` 读写；`wheel` 组中的任何人都可读取 *rndc.key*；其他人甚至无法读取。文件
    *michaelwlucas.com.db* 可以被用户 `mwlucas` 或 `wheel` 组中的任何人读写，但其他人只能读取。如果你在 `mwlucas`
    组中，你可以编辑此文件。
- en: 'Say I want my junior DNS administrators to be able to edit zone files but not
    be able to edit the `rndc(8)` configuration. The file permissions are correct,
    but I need the files to be owned by my DNS administrative user, `dnsadmin`. I
    also want my DNS admins to be able to create new zone files, so they need write
    permissions on the directory. Here’s how I would do that:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想让我的初级 DNS 管理员能够编辑区域文件，但不能编辑 `rndc(8)` 配置。文件权限是正确的，但我需要文件的所有权属于我的 DNS 管理用户
    `dnsadmin`。我还想让我 DNS 管理员能够创建新的区域文件，因此他们需要在目录上拥有写权限。以下是我将如何做到这一点：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, these files are now owned by the user `dnsadmin` and the group
    `dnsadmin`. Anyone in the group `dnsadmin` should be able to edit *michaelwlucas.com.db*
    without using the root password. The user `named`—the unprivileged user for the
    DNS server—should be able to read both files. Add your DNS administrators to the
    `dnsadmin` group in */etc/group*, and they should no longer need the root password
    to do their jobs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些文件现在归用户 `dnsadmin` 和组 `dnsadmin` 所有。组 `dnsadmin` 中的任何人都应该能够在不使用 root
    密码的情况下编辑 *michaelwlucas.com.db* 文件。用户 `named`——DNS 服务器的非特权用户——应该能够读取这两个文件。将你的
    DNS 管理员添加到 */etc/group* 中的 `dnsadmin` 组，他们就不需要 root 密码来完成他们的工作。
- en: This model has limitations, however. While your junior admins can’t accidentally
    edit *rndc.conf*, they can delete and replace it. It would be better to put that
    file in a directory they can read but not edit. And while our DNS administrators
    might think that they need the root password to restart the name server, they’re
    wrong. Use `rndc(8)` to manage the DNS server; other tasks can be managed via
    `cron(8)` or through `sudo`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模型也有局限性。虽然初级管理员无法意外编辑 *rndc.conf*，但他们可以删除和替换它。最好是将该文件放在一个他们可以读取但不能编辑的目录中。而且，尽管我们的
    DNS 管理员可能认为他们需要 root 密码来重新启动名称服务器，但他们错了。使用 `rndc(8)` 来管理 DNS 服务器；其他任务可以通过 `cron(8)`
    或通过 `sudo` 来管理。
- en: Hiding Root with sudo
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `sudo` 隐藏 root 访问
- en: While the proper use of groups can almost eliminate the need for root access
    to edit files, that won’t help with commands that can be run only by root. You
    could set up a cron job to reload the name server each day at midnight, but every
    piece of software occasionally needs a manual restart. Because root is an all-or-nothing
    affair, people who have one minor task to perform have traditionally needed the
    root password.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管正确使用组可以几乎消除编辑文件时需要 root 访问的需求，但这对于只能由 root 运行的命令没有帮助。您可以设置一个 cron 作业，每天午夜重新加载名称服务器，但每款软件偶尔都需要手动重启。因为
    root 是全有或全无的事情，所以那些只有一项小任务要执行的人传统上需要 root 密码。
- en: OpenBSD includes `sudo(8)` and its associated tools, which implement fine-grained
    access control for commands that can be run only by particular users. When configured
    properly, `sudo` lets normal users run specific programs as other users, including
    root. Configured improperly, `sudo` permits full root access. I’ll explain a basic
    `sudo` setup that covers almost all uses, but remember that many more combinations
    are possible. And don’t be afraid to read `sudo(8)`, `sudoers(5)`, and the documentation
    at the `sudo` home page (*[http://www.gratisoft.us/sudo/](http://www.gratisoft.us/sudo/)*).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 包含 `sudo(8)` 及其相关工具，这些工具实现了仅对特定用户可运行的命令的细粒度访问控制。当配置正确时，`sudo` 允许普通用户以其他用户身份运行特定程序，包括
    root。配置不当，`sudo` 允许完全的 root 访问。我将解释一个基本的 `sudo` 设置，它涵盖了几乎所有用途，但请记住，还有许多其他可能的组合。而且不要害怕阅读
    `sudo(8)`、`sudoers(5)` 以及 `sudo` 主页上的文档（[http://www.gratisoft.us/sudo/](http://www.gratisoft.us/sudo/)*）。
- en: Why Use sudo?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么使用 `sudo`？
- en: The `sudo` tool provides benefits beyond fine-grained privilege control. Every
    command run via `sudo` is logged, making it very easy to track who did what. The
    senior sysadmin can change the root password and not give it out, even to people
    who have root-level access.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 工具提供的功能远不止细粒度权限控制。通过 `sudo` 运行的每个命令都会被记录，这使得跟踪谁做了什么变得非常容易。高级系统管理员可以更改
    root 密码，而无需将其提供给具有 root 级别访问权限的人。'
- en: The `sudo` configuration file is designed to be shared across multiple systems,
    so one `sudo` policy can cover your entire network and every operating system.
    Admittedly, you’ll have trouble using a single `sudo` configuration on operating
    systems with wildly unique directory layouts, such as Mac OS X, but you can easily
    share one configuration among OpenBSD, other BSDs, Linux, and even OpenSolaris
    or AIX.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 配置文件旨在跨多个系统共享，因此一个 `sudo` 策略可以覆盖您的整个网络和每个操作系统。诚然，在具有独特目录布局的操作系统上使用单个
    `sudo` 配置会遇到麻烦，例如 Mac OS X，但您可以在 OpenBSD、其他 BSD、Linux 以及甚至 OpenSolaris 或 AIX 之间轻松共享一个配置。'
- en: sudo Disadvantages
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sudo` 的缺点'
- en: The most common problem with `sudo` is getting your users to accept it. People
    who have historically had access to the root account think they “lose something”
    by working through `sudo`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 最常见的问题是让用户接受它。那些历史上可以访问 root 账户的人认为，通过 `sudo` 工作会“失去一些东西”。'
- en: The key to overcoming this is to give users access only to what’s required to
    perform the tasks for which they’re responsible. A junior administrator who complains
    about insufficient privileges has either overreached his responsibilities or needs
    more privileges. One sure way to discover what people actually do is to implement
    a minimal `sudo` permissions scheme and wait for complaints. If no one complains,
    they’re not working very hard.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这一问题的关键是只给用户授予他们完成任务所需的访问权限。一个抱怨权限不足的初级管理员要么超出了他的职责范围，要么需要更多的权限。发现人们实际做什么的一个可靠方法是实施一个最小的
    `sudo` 权限方案，并等待投诉。如果没有人投诉，那么他们可能并没有非常努力地工作。
- en: The configuration syntax for `sudo` can be confusing because its configuration
    doesn’t closely resemble any other configuration file, and getting everything
    right can be difficult at first. The configuration file is actually well suited
    to its purpose, however. Once you understand it, adjusting privileges is quick
    and easy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 的配置语法可能会令人困惑，因为它的配置与任何其他配置文件都不太相似，而且一开始要完全正确可能很困难。然而，配置文件实际上非常适合其目的。一旦你理解了它，调整权限就会变得快速且容易。'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More seriously, a faulty `sudo` setup can create the appearance of security
    while leaving gaps for a user to become root. Be sure to test `sudo` every time
    you make a change, and avoid the common configuration mistakes I document here.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更严重的是，一个有缺陷的 `sudo` 设置可能会给人一种安全的感觉，同时留下用户成为root的漏洞。确保每次更改后都测试 `sudo`，并避免我在此处记录的常见配置错误。
- en: Some users will do their best to push the limits of their access, for no other
    reason than to see if they can outsmart you. These users are best managed with
    a combination of careful configuration, administrative policy, and a cricket bat.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户会尽力扩大他们的访问权限，没有其他原因，只是想看看他们是否能智胜你。这些用户最好通过仔细的配置、管理政策和一根板球棒来管理。
- en: An Overview of the sudo Software
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sudo软件概述
- en: The `sudo` program is a `setuid` root wrapper that can run commands as any other
    user. Use `sudo` by giving it the command you want to run.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 程序是一个 `setuid` root包装器，可以以任何其他用户身份运行命令。通过提供你想要运行的命令来使用 `sudo`。'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `sudo` software compares the desired command (in this case, `/etc/rc.d/named
    restart`) to its internal list of permissions and privileges. If the configuration
    file allows that particular user to run that command as root, `sudo` runs it as
    root. And, because root can run any command as any user, `sudo` can also run commands
    as any arbitrary system user. You can use this fact to grant any user the ability
    to run specific commands as chosen users; for example, administrators of certain
    database servers must frequently run commands as the database user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 软件将所需的命令（在这种情况下，`/etc/rc.d/named restart`）与其内部权限和特权列表进行比较。如果配置文件允许特定用户以root身份运行该命令，`sudo`
    就会以root身份运行它。而且，因为root可以以任何用户身份运行任何命令，`sudo` 也可以以任何任意系统用户身份运行命令。你可以利用这个事实来授予任何用户以选择用户身份运行特定命令的能力；例如，某些数据库服务器的管理员必须经常以数据库用户身份运行命令。'
- en: The `sudo` software is a suite with four pieces. The first piece is the actual
    `sudo(8)` command, the `setuid` root wrapper. The second is the configuration
    file */etc/sudoers*, which describes who may run which commands as what user.
    (*/etc/sudoers* is fully documented in `sudoers(5)`.) Third is the `visudo(8)`
    command that opens */etc/sudoers* in an editor and checks the configuration file
    syntax before exiting. Finally, the `sudoedit(8)` program is specifically for
    editing files as another user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 软件是一个包含四个部分的套件。第一个部分是实际的 `sudo(8)` 命令，`setuid` root包装器。第二个是配置文件 */etc/sudoers*，它描述了谁可以以什么用户身份运行哪些命令。（*/etc/sudoers*
    在 `sudoers(5)` 中有完整文档。）第三个是 `visudo(8)` 命令，它在一个编辑器中打开 */etc/sudoers* 并在退出前检查配置文件语法。最后，`sudoedit(8)`
    程序专门用于以其他用户身份编辑文件。'
- en: The visudo(8) Command
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: visudo(8) 命令
- en: If */etc/sudoers* contains incorrect syntax, `sudo` will not run. If you rely
    on `sudo` to provide root-level access to the system and you break your *sudoers*
    file, you’ll lock yourself out of the root account and lose the ability to correct
    your error. That is bad.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 */etc/sudoers* 包含错误的语法，`sudo` 将无法运行。如果你依赖 `sudo` 来提供对系统的root级别访问，而你又破坏了 *sudoers*
    文件，你将无法访问root账户，并失去纠正错误的能力。这是很糟糕的。
- en: Fortunately, the `visudo(8)` program provides some protection against this sort
    of error by locking */etc/sudoers* so that only one person can edit the configuration
    at a time. It then opens */etc/sudoers* in a text editor (vi by default, but it
    respects the `$EDITOR` environment variable). Make your changes and save your
    work. When you exit the editor, `visudo` should parse the file for syntactic correctness.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`visudo(8)` 程序通过锁定 */etc/sudoers* 以防止同时有人编辑配置文件来提供一些保护，这样只有一个人可以同时编辑配置文件。然后，它会在文本编辑器中打开
    */etc/sudoers*（默认为vi，但会尊重 `$EDITOR` 环境变量）。做出你的更改并保存你的工作。当你退出编辑器时，`visudo` 应该解析文件以检查语法正确性。
- en: If `visudo` detects an error, it prints out the offending line number and asks
    what you want to do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `visudo` 检测到错误，它会打印出有问题的行号，并询问你想要做什么。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, I’ve made an error near line 34\. I can reedit the file to fix the error,
    quit without saving any changes, or force `visudo` to accept this file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我在第34行附近犯了一个错误。我可以重新编辑文件以修复错误，退出而不保存任何更改，或者强制 `visudo` 接受此文件。
- en: Press the E key, and `visudo` should return you to the editor. Go to the offending
    line, fix your error, save the file, and exit the editor again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 按 E 键，`visudo` 应该返回到编辑器。转到有问题的行，修复你的错误，保存文件，然后再次退出编辑器。
- en: Enter the X key, and `visudo` should quit and revert the configuration file
    to its original state. Your changes will be lost, but that might be acceptable.
    It’s better to have an old, working configuration than a new, broken one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 X 键，`visudo` 应该退出并恢复配置文件到其原始状态。你的更改将会丢失，但这可能是可以接受的。拥有一个旧的、可工作的配置比一个新出故障的配置要好。
- en: Pressing Q forces `visudo` to accept the file, busted syntax and all. If `sudo`
    can’t parse */etc/sudoers*, it will immediately exit. Essentially, you’re telling
    `visudo` to break `sudo` until you log in as root to fix the problem. If you think
    you understand */etc/sudoers* better than `visudo` does, you’re probably wrong.
    Even if you’re right, you’re wrong.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按 Q 键会强制 `visudo` 接受文件，包括所有错误的语法。如果 `sudo` 无法解析 `/etc/sudoers`，它将立即退出。本质上，你是在告诉
    `visudo` 在你以 root 身份登录并修复问题之前破坏 `sudo`。如果你认为你对 `/etc/sudoers` 的理解比 `visudo` 更好，你可能是错的。即使你是对的，你也是错的。
- en: The `visudo` program doesn’t guarantee that the configuration will do what you
    desire, only that the configuration parses and is valid. A properly formatted
    configuration that declares “No one may do anything via `sudo`” is perfectly acceptable
    to `visudo`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`visudo` 程序并不能保证配置会按照你的期望执行，它只能确保配置能够解析并且是有效的。一个正确格式的配置，声明“任何人不得通过 `sudo` 执行任何操作”，对于
    `visudo` 来说是完全可以接受的。'
- en: The /etc/sudoers File
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`/etc/sudoers` 文件'
- en: The */etc/sudoers* file determines who may run which commands as which users.
    Never edit */etc/sudoers* directly, even if you think you know exactly what change
    you want to make. Always use `visudo` to change */etc/sudoers*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/sudoers` 文件决定了谁可以以哪个用户身份运行哪些命令。永远不要直接编辑 `/etc/sudoers`，即使你认为你确切知道要做的更改。始终使用
    `visudo` 来更改 `/etc/sudoers`。'
- en: 'The various *sudoers* sample configurations you’ll find are usually very complicated,
    as they demonstrate all the nifty things `sudo` can do. At this point, however,
    you want to do only simple, boring things, like giving particular users access
    to run specific commands. And the bare syntax is very simple. Every *sudoers*
    rule follows this format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现的各种 `sudoers` 样本配置通常非常复杂，因为它们展示了 `sudo` 可以做的一切巧妙的事情。然而，在这个阶段，你只想做简单、无聊的事情，比如给特定的用户授权运行特定的命令。而基本的语法非常简单。每个
    `sudoers` 规则都遵循以下格式：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *`username`* is the username of the user who may execute the command, an
    alias for usernames, or a system group.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`用户名*` 是可以执行命令的用户名，是用户名的别名，或者是一个系统组。'
- en: The *`host`* is the hostname of the system this rule applies to. You can share
    */etc/sudoers* across multiple systems. This entry permits per-host rules.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`主机*` 是此规则应用到的系统的主机名。你可以将 `/etc/sudoers` 在多个系统之间共享。此条目允许按主机设置规则。'
- en: The *`command`* space lists the commands this rule applies to. You must list
    the full path to each command, or `sudo` will not recognize it. If this weren’t
    a requirement, some untrustworthy soul could just adjust his `$PATH` to access
    renamed versions of commands.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`命令*` 空间列出了此规则应用的命令。你必须列出每个命令的完整路径，否则 `sudo` 将不会识别它。如果不是这个要求，某个不可信的人可能会调整他的
    `$PATH` 来访问命令的重命名版本。'
- en: 'For example, suppose I trust user `sbaxter` to run any command, on any system,
    as root. I use the keyword `ALL` to match all possible options for host and command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我信任用户 `sbaxter` 可以以 root 身份在任意系统上运行任何命令。我使用关键字 `ALL` 来匹配主机和命令的所有可能选项：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the lead sysadmin, I should know which duties I have assigned `sbaxter`,
    and exactly which commands he needs. Suppose `sbaxter` is my DNS minion. I control
    the actual editing of zone files with group permissions, but there are many legitimate
    occasions for him to stop, restart, or otherwise slap around the name server program.
    I want him to use the system script */etc/rc.d/named* for this task, and this
    *sudoers* entry gives him permission to use the script on all machines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为首席系统管理员，我应该知道我分配给 `sbaxter` 的职责，以及他确切需要哪些命令。假设 `sbaxter` 是我的 DNS 从属。我通过组权限控制实际编辑区域文件，但有许多合法场合他需要停止、重启或以其他方式处理名称服务器程序。我希望他使用系统脚本
    `/etc/rc.d/named` 来完成这项任务，而这个 `sudoers` 条目给了他在所有机器上使用该脚本的权限。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If I share this file across several machines, it’s likely that many of those
    machines don’t even run a name server. To restrict my minion’s access to only
    the DNS server, I’ll change the host field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将这个文件在多台机器之间共享，那么很可能许多机器甚至没有运行名称服务器。为了限制我的从属机器只能访问 DNS 服务器，我会更改主机字段。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then again, `sbaxter` is the administrator of the email server `mail1`. This
    server is his responsibility, so he needs to run any command. I can set entirely
    different privileges for him on the mail server and still use the same *sudoers*
    file on all the systems.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`sbaxter` 是电子邮件服务器 `mail1` 的管理员。这个服务器是他的责任，因此他需要运行任何命令。我可以在邮件服务器上为他设置完全不同的权限，同时在所有系统上使用相同的
    *sudoers* 文件。
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Yes, `sbaxter` can use `visudo` on `mail1`, but he already has full privileges
    on that machine. I’m comfortable with this, as he knows I’ll hold him responsible
    for any downtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，`sbaxter` 可以在 `mail1` 上使用 `visudo`，但他已经拥有该机器上的全部权限。我对此感到满意，因为他知道我会对他负责任何停机时间。
- en: Multiple Entries in a sudoers Field
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sudoers字段中的多个条目
- en: Separate multiple entries in a single field with commas. For example, after
    a while, I get tired of `sbaxter` asking me to mount NFS shares on the DNS server,
    so I add `mount_nfs` to his privileges.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个字段中用逗号分隔多个条目。例如，过了一段时间，我厌倦了 `sbaxter` 让我在DNS服务器上挂载NFS共享，所以我将 `mount_nfs`
    添加到他的权限中。
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: He can now mount his own blasted NFS shares and leave me alone.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 他现在可以挂载他自己的NFS共享，并且不再打扰我。
- en: Running Commands As Non-root Users
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 以非root用户运行命令
- en: Specify a username in parentheses before a command to say that the user can
    use `sudo` to run commands as a particular user. For example, my user `dwsmith`
    is a database administrator and needs to run any command as the user `_postgresql`
    on the database server `db1`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令之前指定一个用户名，用括号括起来，表示该用户可以使用 `sudo` 以特定用户身份运行命令。例如，我的用户 `dwsmith` 是数据库管理员，需要在数据库服务器
    `db1` 上以用户 `_postgresql` 的身份运行任何命令。
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_postgresql` user can’t successfully run critical system programs like
    `fdisk` and `newfs`, but it can restart the database, back it up, and perform
    other database-administration tasks. By choosing a specific user, a specific machine,
    and a specific command, you can define arbitrarily complex *sudoers* policies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`_postgresql` 用户无法成功运行像 `fdisk` 和 `newfs` 这样的关键系统程序，但它可以重启数据库、备份数据库并执行其他数据库管理任务。通过选择特定的用户、特定的机器和特定的命令，你可以定义任意复杂的
    *sudoers* 策略。'
- en: Long Lines
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 长行
- en: If you have several commands, usernames, or hosts on a line, that line might
    become uncomfortably long. Use a backslash (`\`) to indicate that a rule continues
    on the next line.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行中有多个命令、用户名或主机，那么这一行可能会变得不舒服地长。使用反斜杠 (`\`) 来表示规则继续在下一行。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use as many lines as you like to make your *sudoers* file easier to manage.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用尽可能多的行来使你的 *sudoers* 文件更容易管理。
- en: /etc/sudoers Aliases
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /etc/sudoers 别名
- en: Take several machines with different roles, add multiple sysadmins with differing
    privilege levels, and your */etc/sudoers* file will quickly become complicated.
    When you have a few users with identical privileges and long lists of commands
    that you would like them to access, maintaining consistency in each user’s privilege
    list becomes tedious. *Aliases* simplify these tasks and make */etc/sudoers* much
    more comprehensible, which makes your life easier.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有不同角色的多台机器，添加多个具有不同权限级别的系统管理员，你的 */etc/sudoers* 文件会迅速变得复杂。当你有几个具有相同权限和希望他们访问的长命令列表的用户时，维护每个用户权限列表的一致性会变得繁琐。*别名*
    简化了这些任务，并使 */etc/sudoers* 文件更容易理解，这使得你的生活更加轻松。
- en: An alias is a group of users, hosts, or commands. You can use aliases anywhere
    you would normally use users, hosts, or commands. You might, for example, create
    an alias called `DATABASE_COMMANDS` that contains all of the commands your database
    administrators need to run using `sudo`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是一组用户、主机或命令。你可以在任何通常使用用户、主机或命令的地方使用别名。例如，你可以创建一个名为 `DATABASE_COMMANDS` 的别名，其中包含所有数据库管理员需要使用
    `sudo` 运行的命令。
- en: Let’s take database administrator `dwsmith` and use an alias to specify his
    commands.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以数据库管理员 `dwsmith` 为例，并使用别名来指定他的命令。
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This alias might not seem to save us much, but suppose we have several database
    administrators. We could create an alias called `DBAs` that includes all of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个别名可能看起来没有为我们节省多少，但假设我们有几个数据库管理员。我们可以创建一个名为 `DBAs` 的别名，包括所有他们。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Suddenly, this one line represents multiple rules. All of the database admins
    have identical `sudo` privileges, and when you discover that you need to give
    them access to an additional command, add the command to the alias, and it immediately
    becomes available to every database admin. There’s no tedious and error-prone
    copying of entries between users.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，这一行代表了多条规则。所有数据库管理员都有相同的 `sudo` 权限，当你发现你需要给他们访问额外命令的权限时，只需将命令添加到别名中，它就会立即对每个数据库管理员可用。无需在用户之间繁琐且容易出错地复制条目。
- en: You must define an alias before you can use it, so aliases normally appear at
    the top of the file. Each alias is made up of a label identifying its type, a
    name, and a list of its items. Alias types include user aliases, run as aliases,
    host aliases, and command aliases.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用之前，必须定义一个别名，因此别名通常位于文件顶部。每个别名由一个标识其类型的标签、一个名称和其项目列表组成。别名类型包括用户别名、运行时别名、主机别名和命令别名。
- en: User Aliases
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户别名
- en: A *user alias* is a group of users, and it is labeled with the string `User_Alias`.
    Put only usernames in this alias.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户别名* 是一组用户，并且用字符串 `User_Alias` 标记。在这个别名中只放置用户名。'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the user alias `DBAs` contains the users `dwsmith` and `kkrusch`. By using
    the alias in my *sudoers* rules instead of the usernames, I ensure that these
    users receive exactly the same `sudo` privileges.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户别名 `DBAs` 包含用户 `dwsmith` 和 `kkrusch`。通过在我的 *sudoers* 规则中使用别名而不是用户名，我确保这些用户获得完全相同的
    `sudo` 权限。
- en: You can use system groups in user aliases by prefacing them with a percent sign
    (`%`). I might create a group in */etc/groups* called `databaseteam`, and make
    `dwsmith` and `kkrusch` part of that team.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用系统组在用户别名中，通过在前面加上百分号（`%`）来实现。我可能在 */etc/groups* 中创建一个名为 `databaseteam`
    的组，并将 `dwsmith` 和 `kkrusch` 加入到这个团队中。
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Perhaps the most common usage of this is giving the `wheel` group unlimited
    `sudo` access.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法中最常见的是给 `wheel` 组无限的 `sudo` 访问权限。
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This rule permits the `wheel` group to run any command as root through `sudo`.
    It doesn’t change the group members’ privileges, but gives them access via `sudo`.
    This is convenient for running single commands.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则允许 `wheel` 组通过 `sudo` 以 root 身份运行任何命令。这不会改变组成员的权限，但通过 `sudo` 给他们访问权限。这对于运行单个命令来说很方便。
- en: Run as Aliases
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行时别名
- en: A *run as* alias is a list of users that other users can run commands as. For
    example, on certain application servers, the database admins need to run commands
    both as the database owner `_postgresql` and as the web server owner `www`. If
    the user must run commands as multiple users, however, you would need a separate
    *sudoers* entry for each target user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时别名* 是一组用户，其他用户可以以这些用户身份运行命令。例如，在特定的应用服务器上，数据库管理员需要以数据库所有者 `_postgresql`
    和 Web 服务器所有者 `www` 的身份运行命令。然而，如果用户必须以多个用户身份运行命令，则需要为每个目标用户创建单独的 *sudoers* 条目。'
- en: 'A run as alias lets you group these accounts:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时别名* 允许您将这些账户分组：'
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can now write a single rule allowing users to run commands as either `_postgresql`
    or `www`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以编写一条规则，允许用户以 `_postgresql` 或 `www` 身份运行命令。
- en: Host Aliases
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主机别名
- en: 'A *host alias* is a list of hosts, defined as hostnames, IP addresses, or network
    blocks. Label host aliases with the string `Host_Alias`. Here are examples of
    all host alias types:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*主机别名* 是一组主机，定义为主机名、IP 地址或网络块。用字符串 `Host_Alias` 标记主机别名。以下是所有主机别名类型的示例：'
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I warn elsewhere in this book about how security rules based on a hostname are
    vulnerable to DNS spoofing attacks. An intruder can’t spoof the machine’s local
    hostname, however, so you can safely use the hostname from */etc/myname* in *sudoers*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书的其他地方警告过，基于主机名的安全规则容易受到 DNS 欺骗攻击的威胁。然而，入侵者不能欺骗机器的本地主机名，因此您可以在 *sudoers*
    中安全地使用 */etc/myname* 中的主机名。
- en: Command Aliases
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令别名
- en: A *command alias* is a list of commands. For example, you might have a command
    alias that includes all of the commands needed to back up the system or restore
    from a backup. They’re labeled with the string `Cmnd_Alias`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令别名* 是一组命令。例如，您可能有一个包含备份系统或从备份中恢复所需的所有命令的命令别名。它们用字符串 `Cmnd_Alias` 标记。'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can tell a command alias to include everything in a particular directory
    by using a wildcard.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用通配符告诉命令别名包含特定目录中的所有内容。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also list partial command names. For example, most of PostgreSQL’s
    commands begin with the `pg_` prefix. To give a user access to these commands,
    use a wildcard like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以列出部分命令名称。例如，大多数 PostgreSQL 的命令都以 `pg_` 前缀开始。要给用户访问这些命令的权限，可以使用如下通配符：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you find yourself writing command aliases that include paths like */sbin/**,
    stop and reconsider, because you’re essentially giving the user unlimited root
    access.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己正在编写包含路径如 */sbin/** 的命令别名，请停止并重新考虑，因为您实际上是在给用户无限的 root 权限。
- en: Using Aliases in /etc/sudoers
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 /etc/sudoers 中使用别名
- en: 'Use an alias exactly as you would normally list the user, command, or hostname.
    In the previous examples, I defined the user alias `DBAs`, the run as alias `APPOWNER`,
    the host alias `DB`, and the command alias `APPCOMMANDS`. Here’s how they might
    be used:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下，使用别名就像列出用户、命令或主机名一样。在之前的示例中，我定义了用户别名 `DBAs`、运行别名 `APPOWNER`、主机别名 `DB`
    和命令别名 `APPCOMMANDS`。以下是它们可能的使用方式：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the user group `DBAs` can run any command on any server in the `DB` group,
    as any user. The members of the group own the servers, and if they screw them
    up, it’s not my problem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户组 `DBAs` 可以以任何用户身份在任何 `DB` 组的服务器上运行任何命令。该组的成员拥有服务器，如果他们搞砸了，这不是我的问题。
- en: Well, this attitude sounds good, but the truth is that when they destroy the
    server, I must get involved. Even if it’s not my fault that they drove the database
    server into the ditch, it *is* my problem. I must lock down the commands that
    they can run, restricting them to only the commands in the `APPCOMMANDS` alias.
    So, the `DBAs` group can now run any command in `APPCOMMANDS` on the `DB` servers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这种态度听起来不错，但事实是，当他们破坏服务器时，我必须介入。即使他们把数据库服务器推入沟里不是我的错，但这**是我的问题**。我必须锁定他们可以运行的命令，只允许他们运行
    `APPCOMMANDS` 别名中的命令。因此，`DBAs` 组现在可以在 `DB` 服务器上运行 `APPCOMMANDS` 中的任何命令。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then I discover that my database admins are either cleverer or dafter than I
    thought. They run certain database commands as root, creating log files owned
    by root. The unprivileged database user `_postgresql` cannot write to these log
    files, and so the application server crashes. Fixing this requires changing the
    permissions on those log files, but the database admins do not have permission
    to run `chown`. If I give them the ability to change the permissions on arbitrary
    files, I might as well just give them root access.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我发现我的数据库管理员要么比我之前想的聪明，要么比我之前想的愚蠢。他们以 root 身份运行某些数据库命令，创建了 root 所拥有的日志文件。无特权的数据库用户
    `_postgresql` 无法写入这些日志文件，因此应用程序服务器崩溃。解决这个问题需要更改这些日志文件的权限，但数据库管理员没有运行 `chown` 的权限。如果我把更改任意文件权限的能力给他们，那我就不如直接给他们
    root 权限。
- en: To keep this from happening again, I restrict their privileges so they can run
    their commands only as the application unprivileged users.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况再次发生，我限制了他们的权限，使他们只能以应用程序无特权的用户身份运行他们的命令。
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Everyone in the `DBAs` group can run any command in `APPCOMMANDS`, as any user
    in `APPOWNER`, on any server in `DB`. I can change their access by adding entries
    to the various aliases.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBAs` 组中的每个人都可以在 `APPCOMMANDS` 中运行任何命令，就像 `APPOWNER` 中的任何用户一样，在任何 `DB` 服务器上。我可以通过向各种别名中添加条目来更改他们的访问权限。'
- en: Without aliases, what would this rule look like?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 没有别名，这条规则会是什么样子？
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That’s ugly, and it does exactly the same thing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很丑，但它确实做了完全相同的事情。
- en: If you name your aliases well, you’ll find rules easier to understand. While
    these example aliases are fairly short, I’ve used aliases with up to 20 members.
    The resulting rules are appalling without aliases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给别名起名得当，你会发现规则更容易理解。虽然这些示例别名相当简短，但我已经使用了有最多 20 个成员的别名。没有别名的情况下，这些规则看起来令人震惊。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the permissions granted by `sudo` in this case are unnecessary. For
    example, the unprivileged web server user doesn’t need to run the various PostgreSQL
    utilities, and if `www` did try to run the database, nothing much would happen.
    If you don’t like this, make two separate rules. Either way, it’s tighter security
    than giving database administrators the root password.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`sudo` 授予的一些权限是不必要的。例如，无特权的网络服务器用户不需要运行各种 PostgreSQL 工具，如果 `www` 尝试运行数据库，也不会发生什么。如果你不喜欢这样，可以制定两条不同的规则。无论如何，这比给数据库管理员提供
    root 密码更安全。
- en: Nesting Aliases
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 别名嵌套
- en: 'You can include aliases in aliases. Here, I combine two user aliases into a
    single alias for my application administrators:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在别名中包含别名。在这里，我将两个用户别名合并为一个用于我的应用程序管理员的单一别名：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Alias Naming Conventions
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 别名命名约定
- en: 'It’s traditional, but not mandatory, to give aliases names in all capital letters
    to help differentiate them from users, hosts, and so on. And though it’s valid
    syntax, it’s best to avoid naming aliases after users or hosts. Here’s an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的做法（但不是强制性的）是将别名命名为全大写字母，以帮助区分用户、主机等。尽管这是有效的语法，但最好避免将别名命名为用户或主机。以下是一个示例：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This would quickly drive me batty.^([[16](#ftn.id365199)])
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这会让我很快变得疯狂.^([[16](#ftn.id365199)])
- en: You can also reuse alias names if they are for different types of aliases. For
    example, the following is perfectly legal, but perfectly offensive.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以重复使用别名名称，如果它们是为不同类型的别名。例如，以下是完全合法的，但完全令人反感。
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you do this, anyone who must debug your `sudo` configuration will curse your
    name. Even if you consider being cursed a job perk, this naming scheme makes your
    phone ring at inconvenient times.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，任何必须调试您的`sudo`配置的人都会诅咒您的名字。即使您认为被诅咒是一种工作福利，这种命名方案也会在不方便的时候让您手机响个不停。
- en: Changing sudo’s Default Behavior
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变sudo的默认行为
- en: You can customize `sudo`’s behavior, or its behavior for certain users, hosts,
    or aliases, with the `Defaults` field. For example, one feature of `sudo` is that
    if you enter the wrong password, it insults you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`默认`字段自定义`sudo`的行为，或某些用户、主机或别名的行为。例如，`sudo`的一个特性是如果您输入了错误的密码，它会侮辱您。
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I typed my password incorrectly. `sudo` insulted me and offered me a chance
    to enter my password again. If I enter the wrong password three times, `sudo`
    exits.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入了错误的密码。`sudo`侮辱了我，并给了我再次输入密码的机会。如果我连续三次输入错误的密码，`sudo`将退出。
- en: 'Insulting the user is just fine in an open source environment, but if you’re
    in a company, someone will complain to management. You can either go to sensitivity
    training or proactively disable insults by adding the following line to *sudoers*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源环境中侮辱用户是可以的，但如果您在公司，有人会向管理层投诉。您可以选择参加敏感性培训或通过在*sudoers*中添加以下行来主动禁用侮辱：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `Defaults` statement indicates that the following item affects one or more
    `sudo` defaults. The `insults` option controls insulting the user. The exclamation
    point (`!`) is a negation symbol. By putting an exclamation point in front of
    the option, you turn off the feature. The system will no longer insult users when
    they demonstrate that they cannot type as well as my pet rat.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`默认`语句表示以下项目会影响一个或多个`sudo`默认值。`insults`选项控制侮辱用户。感叹号（`!`）是一个否定符号。通过在选项前放置感叹号，您将关闭该功能。当用户证明他们打字不如我的宠物老鼠时，系统将不再侮辱用户。'
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can override defaults globally or on a per-alias basis.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以全局或按别名覆盖默认值。
- en: Overriding Defaults per Host
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按主机覆盖默认值
- en: 'To override the defaults on a per-host basis, use an `@` symbol after `Defaults`
    and give either a host or a host alias. Here, I want to insult users who can’t
    type their password on `caddis` or on a machine in the alias `APPSERVERS`, while
    leaving insults disabled for all other servers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要按主机覆盖默认值，请在`默认`后使用`@`符号，并给出主机或主机别名。在这里，我想侮辱那些在`caddis`或`APPSERVERS`别名中的机器上无法输入密码的用户，同时为所有其他服务器禁用侮辱：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This lets me enable or disable functions for any combination of servers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我能够为任何服务器组合启用或禁用功能。
- en: Overriding Defaults per User
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按用户覆盖默认值
- en: To change `sudo` defaults on a per-user basis, use a `%` and the user or user
    alias.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要按用户更改`sudo`的默认值，请使用`%`和用户或用户别名。
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It doesn’t matter where `lasnyder` logs in—I’m going to insult him, as well
    as the users in the `DBAs` alias. But database administrators are used to poor
    treatment by their software, and to not insult them would confuse and disappoint
    them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`lasnyder`在哪里登录——我将侮辱他，以及`DBAs`别名中的用户。但是数据库管理员已经习惯了软件的恶劣待遇，如果不侮辱他们，可能会让他们感到困惑和失望。
- en: Overriding Defaults per Command
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按命令覆盖默认值
- en: You can also change how `sudo` behaves on a command-by-command basis by putting
    an exclamation point between `Defaults` and the command list.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在`默认`和命令列表之间放置感叹号来按命令逐个更改`sudo`的行为。
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Anyone who tries to use `newfs(8)` or `fsck(8)` (discussed in [Chapter 8](ch08.html
    "Chapter 8. Disks and Filesystems")) and cannot type their password needs insulting.
    The application administration commands might not merit insults, but I can always
    claim it was an oversight.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试使用`newfs(8)`或`fsck(8)`（在第8章[第8章。磁盘和文件系统](ch08.html "第8章。磁盘和文件系统"）中讨论）且无法正确输入密码的人都需要受到侮辱。应用程序管理命令可能不值得侮辱，但我可以声称这是一个疏忽。
- en: Overriding Defaults per Run As
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按运行方式覆盖默认值
- en: Lastly, you can change the defaults based on who the command is being run as.
    Use a right angle bracket (`<`) to indicate changing behavior for a run as alias.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以根据命令的运行者更改默认值。使用右尖括号（`<`）来表示更改运行别名的行为。
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If a user runs a command as `_postgresql`, or as any user in the `APPOWNER`
    run as alias, and types his password incorrectly, he gets insulted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户以`_postgresql`或`APPOWNER`运行别名中的任何用户身份运行命令，并且输入密码错误，他将受到侮辱。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the rest of this chapter, we’ll use `Default` widely. Please assume that
    each section includes the text “Restrict this as necessary by user, host, command,
    or run as.”
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将广泛使用`默认`。请假设每个部分都包含文本“根据用户、主机、命令或以运行方式限制”。
- en: sudo and the Environment
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sudo 和环境
- en: Certain environment variables can cause problems. For example, `$HOME` is an
    obvious one—a user cannot create files in another user’s home directory. Others,
    such as `LD_LIBRARY_PATH`, can cause endless annoyance as well as security issues,
    as applications try to link against the wrong libraries. The `sudo` program can
    remove suspicious environment variables, completely reset the user’s environment,
    or be configured to preserve the original user’s environment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 某些环境变量可能会引起问题。例如，`$HOME` 是一个明显的例子——用户无法在另一个用户的家目录中创建文件。其他，如 `LD_LIBRARY_PATH`，也可能引起无尽的烦恼以及安全问题，因为应用程序尝试链接到错误的库。`sudo`
    程序可以删除可疑的环境变量，完全重置用户的环境，或者配置为保留原始用户的环境。
- en: The `env_reset` *sudoers* option is set by default. It purges all environment
    variables except `LOGNAME`, `SHELL`, `USER`, `USERNAME`, and anything beginning
    with `SUDO_`. You can change this behavior by disabling `env_reset`, but I strongly
    recommend against disabling environment purging.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下设置了 `env_reset` *sudoers* 选项。它清除所有环境变量，除了 `LOGNAME`、`SHELL`、`USER`、`USERNAME`
    和以 `SUDO_` 开头的任何内容。你可以通过禁用 `env_reset` 来改变这种行为，但我强烈建议不要禁用环境清除。
- en: Instead of letting users blindly carry all the random garbage in their environment
    along with them, create a list of necessary and safe environment variables that
    they can retain. You’ll see examples in OpenBSD’s default *sudoers* file using
    the `env_keep` option.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让用户盲目地将他们环境中所有的随机垃圾一起带走，创建一个包含必要且安全的环境变量的列表，他们可以保留。你可以在 OpenBSD 默认的 *sudoers*
    文件中使用 `env_keep` 选项看到示例。
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The OpenBSD team deems these environment variables safe to pass into a new user
    account. The `+=` means “add these to the existing list of items to keep.” The
    environment variables themselves are in quotation marks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 团队认为这些环境变量可以安全地传递给新的用户账户。`+=` 表示“将这些添加到现有项目列表中。”环境变量本身用引号括起来。
- en: If you need to pass your SSH environment around your servers, you can use `scp(1)`
    and `sftp(1)` to move files to other servers. Read the documentation, create a
    list of approved environment variables, and add an entry.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将你的 SSH 环境在服务器之间传递，可以使用 `scp(1)` 和 `sftp(1)` 将文件移动到其他服务器。阅读文档，创建一个批准的环境变量列表，并添加条目。
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ability to copy files to other servers probably should be restricted to
    people in a certain group. Sysadmins might need to copy files to other servers,
    but many other users don’t need this access.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件复制到其他服务器的权限可能应该仅限于特定组的人员。系统管理员可能需要将文件复制到其他服务器，但许多其他用户不需要这种访问权限。
- en: Using sudo
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sudo
- en: Now that you know how to set `sudo` permissions, let’s see how to actually use
    it. First, let’s tell `sudo` that your account has permission to run any command.
    (You should have root access on your test machine, at least, so this won’t be
    a security issue.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何设置 `sudo` 权限，让我们看看如何实际使用它。首先，让我们告诉 `sudo` 你的账户有权限运行任何命令。（你应该至少在测试机器上有
    root 访问权限，所以这不会是一个安全问题。）
- en: The easy way to accomplish this is to uncomment the *sudoers* entry allowing
    `wheel` members access to all commands.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的简单方法是取消注释 *sudoers* 中的条目，允许 `wheel` 成员访问所有命令。
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As a user in `wheel`, check your `sudo` permissions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `wheel` 组的用户，检查你的 `sudo` 权限。
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When `sudo` asks for a password, enter your own password, not the root password.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `sudo` 要求输入密码时，输入你自己的密码，而不是 root 密码。
- en: The `-l` flag tells `sudo` to show you which privileges and settings you have.
    In response, `sudo` parses */etc/sudoers* and spits out all of the settings that
    apply to your account on this system. Any host-specific limitations are already
    evaluated and do not appear.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l` 标志告诉 `sudo` 显示你有哪些权限和设置。作为回应，`sudo` 解析 */etc/sudoers* 并输出适用于该系统上你账户的所有设置。任何特定主机的限制已经评估过，不会显示。'
- en: sudo Password Caching
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sudo 密码缓存
- en: When you enter your password correctly, `sudo` records the time, and for the
    next five minutes, it remembers that you’ve recently entered your password and
    will work without requiring you to enter it again. After five minutes, you must
    reauthenticate. This simplifies work when entering a series of `sudo` commands,
    but it times out reasonably quickly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正确输入密码时，`sudo` 记录时间，接下来五分钟内，它会记住你最近输入了密码，并且无需再次输入即可工作。五分钟后，你必须重新认证。这简化了输入一系列
    `sudo` 命令的工作，但它的超时时间相对较短。
- en: 'You can tell `sudo` to forget your cached password by running `sudo -k`. You
    can control the number of minutes before `sudo` asks for the password again with
    the `timestamp_timeout` option in *sudoers*. Here, we tell `sudo` to not time
    out the password for 10 minutes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `sudo -k` 来让 `sudo` 忘记您的缓存密码。您可以使用 `sudoers` 中的 `timestamp_timeout`
    选项来控制 `sudo` 再次请求密码之前的时间。在这里，我们告诉 `sudo` 不要在 10 分钟内超时密码：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you set the timeout to 0, `sudo` always asks for a password. If you set it
    to a negative value, `sudo` caches the password throughout this login session.
    You must run `sudo -k` to make `sudo` forget that you entered your password.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将超时设置为 0，`sudo` 总是会要求输入密码。如果您将其设置为负值，`sudo` 将在整个登录会话中缓存密码。您必须运行 `sudo -k`
    来让 `sudo` 忘记您输入了密码。
- en: Running Commands Under sudo
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 sudo 下运行命令
- en: 'To run commands via `sudo`, just put the command name after the `sudo` command.
    For example, here’s how you would run `tcpdump` via `sudo`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `sudo` 运行命令，只需在 `sudo` 命令后跟命令名称。例如，这是您如何通过 `sudo` 运行 `tcpdump` 的方法：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `sudo` command should prompt for your password. Enter it correctly, and
    `tcpdump` should run as root.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 命令应该提示您输入密码。正确输入后，`tcpdump` 应该以 root 身份运行。'
- en: You can also run commands that include arguments under `sudo`. For example,
    I use `tail -f` to view the end of a log file and show new entries as they appear.
    But some log files are accessible only to root, such as the authentication log
    and the log that contains detailed `sudo` logs. You can view these logs without
    becoming root by using `sudo`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在 `sudo` 下运行包含参数的命令。例如，我使用 `tail -f` 来查看日志文件的末尾，并显示新出现的条目。但某些日志文件只能由 root
    访问，例如认证日志和包含详细 `sudo` 日志的日志。您可以使用 `sudo` 而不成为 root 来查看这些日志。
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can configure *sudoers* to permit any combination of commands and arguments.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 *sudoers* 以允许任何组合的命令和参数。
- en: Running Commands as Other Users
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以其他用户身份运行命令
- en: Earlier, you saw how to give some users permission to run commands as users
    other than root. Specify the user with the `-u` flag.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您看到了如何授予一些用户以非 root 用户身份运行命令的权限。使用 `-u` 标志指定用户。
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you don’t have permission to run that command as that user, you’ll get an
    error.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有权限以该用户身份运行该命令，您将收到错误。
- en: sudoedit
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sudoedit
- en: 'My flunky `sbaxter` needs to edit the *named* configuration file, */etc/named.conf*.
    Consider this `sudo` configuration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我的助手 `sbaxter` 需要编辑 *命名* 配置文件，`/etc/named.conf`。考虑以下 `sudo` 配置：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Looks good, right?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？
- en: Uh, no.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，不行。
- en: The first problem is that I’m requiring `sbaxter` to use a specific editor.
    Minimal competence in vi is required for system administrators, but I don’t want
    to force him to use a specific editor to do his day-to-day job. Also, many editors
    offer shell escapes. While most people are aware of escaping to a shell in vi,
    emacs has a shell escape as well. If my flunky can escape to a shell while running
    an editor as root, he gains root access. This is exactly what I want to avoid.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我要求 `sbaxter` 使用特定的编辑器。系统管理员需要具备 vi 的最低能力，但我不想强迫他使用特定的编辑器来完成日常工作。此外，许多编辑器提供
    shell 转义功能。虽然大多数人知道在 vi 中转义到 shell，但 emacs 也有 shell 转义功能。如果我的助手在以 root 身份运行编辑器时能够转义到
    shell，他将获得 root 权限。这正是我想避免的。
- en: The `sudoedit` feature lets users edit specific files with their preferred editor,
    or a default chosen by the sysadmin, without working as root.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudoedit` 功能允许用户使用他们首选的编辑器或由系统管理员选择的默认编辑器编辑特定文件，而无需以 root 身份工作。'
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The keyword `sudoedit` is followed by a list of the files that the user can
    edit, thereby permitting the user to change those files without root privileges.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `sudoedit` 后跟一个文件列表，用户可以编辑这些文件，从而允许用户更改这些文件而无需 root 权限。
- en: The user edits the file by passing a filename to `sudoedit`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过传递文件名给 `sudoedit` 来编辑文件。
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Technically, the user doesn’t edit the actual file; instead, `sudoedit` copies
    the file to a temporary file owned by the user, and when the user closes the editor,
    it copies the temporary file to the original location. The user never runs the
    editor as root.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，用户并没有编辑实际的文件；相反，`sudoedit` 将文件复制到由用户拥有的临时文件中，当用户关闭编辑器时，它将临时文件复制到原始位置。用户永远不会以
    root 身份运行编辑器。
- en: The `sudoedit` keyword uses the editor given by the environment variable `$SUDO_EDITOR`,
    `$VISUAL`, or `$EDITOR`. Users can set that variable in their shell if they don’t
    like what the system offers them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudoedit` 关键字使用环境变量 `$SUDO_EDITOR`、`$VISUAL` 或 `$EDITOR` 中给出的编辑器。如果用户不喜欢系统提供的选项，他们可以在他们的
    shell 中设置该变量。'
- en: 'The Biggest sudo Mistake: Exclusions'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大的 `sudo` 错误：排除
- en: Now that you know the basics of `sudo`, let’s consider a configuration that
    trips up even experienced system administrators. Sometimes you want to prevent
    users from executing specific commands but give them access to every other command.
    The *sudoers* documentation says that you can do this using the exclamation point
    (`!`) as a negation character, but that’s not entirely effective. Because this
    is a popular method, however, I’ll discuss how it works, and then demonstrate
    how your users automatically get root if you use it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `sudo` 的基础知识，让我们考虑一个即使是经验丰富的系统管理员也会陷入困境的配置。有时你想要阻止用户执行特定的命令，但又要让他们能够访问其他所有命令。`sudoers`
    文档说明你可以使用感叹号（`!`）作为否定字符来实现这一点，但这并不完全有效。然而，由于这是一个流行的方法，所以我将讨论它是如何工作的，然后演示如果你使用它，你的用户将如何自动获得
    root 权限。
- en: Start by defining command aliases that contain the forbidden commands. One popular
    exclusion is `su`. Another common exclusion is user shells, because if you execute
    a shell as a user, you become that user.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义包含禁止命令的命令别名。一个流行的排除项是 `su`。另一个常见的排除项是用户 shell，因为如果你以用户身份执行 shell，你将变成那个用户。
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now configure a command alias that excludes those commands.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置一个排除那些命令的命令别名。
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Looks sensible, doesn’t it? And it seems to work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很有道理，不是吗？而且它似乎能正常工作。
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here’s the catch: Commands are defined by full paths. You’re allowing the user
    to run any command except for a few specified by full path. All this user needs
    to do is copy the command to another location and run it.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这里有个问题：命令是通过完整路径定义的。你允许用户运行除了少数通过完整路径指定的命令之外的所有命令。这个用户需要做的只是将命令复制到另一个位置并运行它。
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Welcome to root!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 root！
- en: Negating commands can be bypassed by anyone who understands even the basics
    of `sudo`, as you’ll find well documented in the `sudo` manual and other literature.
    People *still* insist on using it to protect production systems. Don’t be one
    of those people.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 否定命令可以被任何理解 `sudo` 基础知识的人绕过，正如你在 `sudo` 手册和其他文献中会发现的那样。人们 *仍然* 坚持使用它来保护生产系统。不要成为那些人之一。
- en: sudo Logs
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sudo 日志
- en: Every `sudo` command is logged to */var/log/secure* by `syslogd`. Each log message
    contains a timestamp, a username, a terminal, the directory where the command
    was run, the user the command was run as, and the command used.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个使用 `sudo` 的命令都会被 `syslogd` 记录到 */var/log/secure*。每条日志消息都包含一个时间戳、一个用户名、一个终端、运行命令的目录、运行命令的用户以及所使用的命令。
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By checking the file *secure*, you can track exactly who did what and when.
    (Send your *syslog* messages to a logging server that your users cannot access
    to prevent those who screw up from deleting the logs of their screwup.)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查文件 *secure*，你可以精确追踪谁做了什么以及何时做的。（将你的 *syslog* 消息发送到一个你的用户无法访问的日志服务器，以防止那些搞砸的人删除他们错误的日志。）
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: I know exactly who broke this system and when. The log entry transforms what’s
    about to happen from “homicide” to “justifiable manslaughter.” That alone makes
    `sudo` worth using properly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我确切地知道谁破坏了这个系统以及何时破坏的。日志条目将即将发生的事情从“谋杀”转变为“正当的杀人”。仅此一点就使得正确使用 `sudo` 值得。
- en: This chapter has given you some tips on how to avoid screwing up your system
    accidentally. Now let’s look at ways to really mess up your system, by mucking
    with disks and filesystems.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了一些避免意外破坏系统的技巧。现在让我们看看如何通过操作磁盘和文件系统真正地破坏你的系统。
- en: '* * *'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](#id411230)]) I could just say that “I have never seen POSIX ACLs configured
    correctly,” but personal anecdotal evidence is not proof. Even the dozens of horrifying
    personal anecdotes I’ve gathered over decades in this business are not proof.
    Feel free to prove me wrong, but please, do it on *your* server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#id411230)]) 我可以简单地说“我从未见过配置正确的 POSIX ACLs”，但个人的轶事证据并不构成证明。即使我在这个行业中几十年收集到的数十个令人毛骨悚然的个人轶事也不构成证明。请随意证明我错了，但请，请在
    *你的* 服务器上这么做。
- en: ^([[16](#id365199)]) Oh, all right—battier. Happy?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#id365199)]) 哦，好吧——battier。高兴了吗？
