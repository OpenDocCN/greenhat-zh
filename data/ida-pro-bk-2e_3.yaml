- en: Part III. Advanced IDA Usage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分. 高级IDA使用
- en: Chapter 11. Customizing IDA
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 定制IDA
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: After spending some time with IDA, you may have developed some preferred settings
    that you wish to use as defaults every time you open a new database. Some of the
    options you have changed may already carry over from session to session, while
    other options seem to need resetting every time you load a new database. In this
    chapter we examine the various ways in which you can modify IDA’s behavior through
    configuration files and menu-accessible options. We also examine where IDA stores
    various configuration settings and discuss the difference between database-specific
    settings and global settings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用IDA一段时间后，你可能已经开发了一些你希望每次打开新数据库时都作为默认设置的偏好设置。你更改的一些选项可能已经从会话传递到会话，而其他选项似乎每次加载新数据库时都需要重置。在本章中，我们将探讨你可以通过配置文件和菜单访问的选项来修改IDA行为的各种方式。我们还将检查IDA存储各种配置设置的位置，并讨论数据库特定设置和全局设置之间的差异。
- en: Configuration Files
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件
- en: Much of IDA’s default behavior is governed by settings contained in various
    configuration files. For the most part, configuration files are stored in the
    *<IDADIR>/cfg* directory, with one notable exception being the plug-ins configuration
    file, which resides at *<IDADIR>/plugins/plugins.cfg* (*plugins.cfg* will be covered
    in [Chapter 17](ch17.html "Chapter 17. The IDA Plug-in Architecture")). While
    you may notice quite a few files in the main configuration directory, the majority
    of the files are used by processor modules and are applicable only when certain
    CPU types are being analyzed. The three principal configuration files are *ida.cfg*,
    *idagui.cfg*, and *idatui.cfg*. Options that apply to all versions of IDA are
    generally found in *ida.cfg*, while *idagui.cfg* and *idatui.cfg* contain options
    specific to the GUI versions and the text-mode versions of IDA, respectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的大部分默认行为由各种配置文件中的设置控制。大部分配置文件存储在*<IDADIR>/cfg*目录中，一个值得注意的例外是插件配置文件，它位于*<IDADIR>/plugins/plugins.cfg*（*plugins.cfg*将在[第17章](ch17.html
    "第17章. IDA插件架构")中介绍）。虽然你可能注意到主配置目录中有许多文件，但大多数文件是由处理器模块使用的，并且仅在分析特定CPU类型时适用。三个主要的配置文件是*ida.cfg*、*idagui.cfg*和*idatui.cfg*。适用于IDA所有版本的选项通常可以在*ida.cfg*中找到，而*idagui.cfg*和*idatui.cfg*分别包含针对GUI版本和文本模式版本的IDA的特定选项。
- en: 'The Main Configuration File: ida.cfg'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要配置文件：ida.cfg
- en: IDA’s principal configuration file is *ida.cfg*. Early in the startup process,
    this file is read to assign default processor types for various file extensions
    and to tune IDA’s memory usage parameters. Once a processor type has been specified,
    the file is then read a second time to process additional configuration options.
    The options contained in *ida.cfg* apply to all versions of IDA regardless of
    the user interface that is being used.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的主要配置文件是*ida.cfg*。在启动过程的早期，该文件被读取以分配各种文件扩展名的默认处理器类型，并调整IDA的内存使用参数。一旦指定了处理器类型，文件就会被第二次读取以处理额外的配置选项。*ida.cfg*中包含的选项适用于IDA的所有版本，无论使用的是哪种用户界面。
- en: General options of interest in *ida.cfg* include memory-tuning parameters (`VPAGESIZE`),
    whether backup files are created (`CREATE_BACKUPS`), and the name of the external
    graph viewer (`GRAPH_VISUALIZER`).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ida.cfg*中值得关注的一般选项包括内存调整参数（`VPAGESIZE`）、是否创建备份文件（`CREATE_BACKUPS`）以及外部图形查看器的名称（`GRAPH_VISUALIZER`）。
- en: Occasionally when working with very large input fields, IDA may report that
    not enough memory is available to create a new database. In such cases, increasing
    the `VPAGESIZE` and then reopening the input file is usually sufficient to solve
    the problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在处理非常大的输入字段时，IDA可能会报告没有足够的内存来创建新的数据库。在这种情况下，增加`VPAGESIZE`然后重新打开输入文件通常足以解决问题。
- en: A large number of options that control the format of disassembly lines are also
    contained in *ida.cfg*, including the default values for many of the options accessible
    via Options ▸ General. These include default values for the number of opcode bytes
    to display (`OPCODE_BYTES`), how far instructions should be indented (`INDENTATION`),
    whether the stack pointer offset should be displayed with each instruction (`SHOW_SP`),
    and the maximum number of cross-references to be displayed with a disassembly
    line (`SHOW_XREFS`). Additional options control the format of disassembly lines
    while in graph mode.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多控制反汇编行格式的选项也包含在 *ida.cfg* 文件中，包括通过“选项”▸“常规”可访问的许多选项的默认值。这些包括显示的指令字节数的默认值（`OPCODE_BYTES`）、指令应缩进的距离（`INDENTATION`）、是否应显示每个指令的堆栈指针偏移（`SHOW_SP`），以及与反汇编行一起显示的最大交叉引用数（`SHOW_XREFS`）。其他选项控制图形模式下的反汇编行格式。
- en: The global option specifying the maximum name length for named program locations
    (as opposed to stack variables) is contained in *ida.cfg* and is called `MAX_NAMES_LENGTH`.
    This option defaults to 15 characters and causes IDA to generate a warning message
    any time you enter a name longer than the current limit. The default length is
    kept small because some assemblers cannot handle names longer than 15 characters.
    If you do not plan to run an IDA-generated disassembly back through an assembler,
    then you may safely increase the limit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 全局选项指定了命名程序位置（与堆栈变量相对）的最大名称长度，该选项包含在 *ida.cfg* 文件中，并称为 `MAX_NAMES_LENGTH`。此选项默认为15个字符，当您输入的名称超过当前限制时，IDA会生成一个警告信息。默认长度保持较小，因为一些汇编器无法处理超过15个字符的名称。如果您不打算将IDA生成的反汇编代码再次通过汇编器运行，那么您可以安全地提高此限制。
- en: The list of characters allowed in user-assigned names is governed by the `NameChars`
    options. By default this list allows alphanumeric characters and the four special
    characters `_$?@`. If IDA complains about the characters that you wish to use
    when you assign new names to locations or stack variables, then you may want to
    add additional characters to the `NameChars` set. For example, `NameChars` is
    the option to modify if you want to make the dot (`.`) character legal for use
    in IDA names. You should avoid the use of the semicolon, colon, comma, and space
    characters within names because they may lead to confusion, as these characters
    are typically considered delimiters for various disassembly line parts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 用户分配的名称中允许使用的字符列表受 `NameChars` 选项控制。默认情况下，此列表允许字母数字字符和四个特殊字符 `_$?@`。如果您在为位置或堆栈变量分配新名称时遇到IDA对您希望使用的字符的抱怨，那么您可能需要向
    `NameChars` 集合中添加额外的字符。例如，如果您想使点 (`.`) 字符在IDA名称中使用合法，则需要修改 `NameChars` 选项。您应避免在名称中使用分号、冒号、逗号和空格字符，因为这些字符可能会引起混淆，因为这些字符通常被认为是各种反汇编行部分的分隔符。
- en: The last two options worth mentioning influence IDA’s behavior when parsing
    C header files (see [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures")).
    The `C_HEADER_PATH` option specifies a list of directories that IDA will search
    to resolve `#include` dependencies. By default, a common directory used by Microsoft’s
    Visual Studio is listed. If you use a different compiler or if your C header files
    are in a nonstandard location, you should consider editing this option. The `C_PREDEFINED_MACROS`
    option can be used to specify a default list of preprocessor macros that IDA will
    incorporate regardless of whether IDA has encountered them while parsing a C header
    file. This option offers a limited workaround facility for dealing with macros
    that may be defined in header files to which you do not have access.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个值得注意的选项会影响IDA解析C头文件时的行为（参见[第8章](ch08.html "第8章。数据类型和数据结构")）。`C_HEADER_PATH`
    选项指定了IDA将搜索以解决 `#include` 依赖的目录列表。默认情况下，列出了Microsoft Visual Studio常用的目录。如果您使用不同的编译器或您的C头文件位于非标准位置，您应该考虑编辑此选项。`C_PREDEFINED_MACROS`
    选项可以用来指定IDA将无论是否在解析C头文件时遇到它们，都将包含的默认预处理器宏列表。此选项提供了一种有限的解决方案，用于处理可能定义在您无法访问的头文件中的宏。
- en: The second half of *ida.cfg* contains options specific to various processor
    modules. The only documentation available for options in this section of the file
    comes in the form of the comments (if any) associated with each option. The processor-specific
    options specified in *ida.cfg* generally dictate the default settings in the `Processor
    options` section of IDA’s initial file-loading dialog.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*ida.cfg*的第二部分包含针对各种处理器模块的特定选项。此文件部分中可用的唯一文档是以注释的形式（如果有）与每个选项相关联。在*ida.cfg*中指定的处理器特定选项通常决定了IDA初始文件加载对话框中`处理器选项`部分的默认设置。'
- en: The last step in processing *ida.cfg* is to search for a file named *<IDADIR>/cfg/idauser.cfg*.
    If present,^([[72](#ftn.CHP-11-FN-1)]) this file is treated as an extension of
    *ida.cfg*, and any options in the file will override corresponding options in
    *ida.cfg*. If you do not feel comfortable editing *ida.cfg*, then you should create
    *idauser.cfg* and add to it all of the options that you wish to override. In addition,
    *idauser.cfg* offers the easiest means for transferring your customized options
    from one version of IDA to another. For example, with *idauser.cfg* you do not
    need to re-edit *ida.cfg* each time you upgrade your copy of IDA. Instead, simply
    copy your existing *idauser.cfg* to your new IDA installation any time you upgrade.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 处理*ida.cfg*的最后一步是搜索一个名为*<IDADIR>/cfg/idauser.cfg*的文件。如果存在，^([[72](#ftn.CHP-11-FN-1)))，则该文件被视为*ida.cfg*的扩展，文件中的任何选项都将覆盖*ida.cfg*中的相应选项。如果您不习惯编辑*ida.cfg*，则应创建*idauser.cfg*并将您希望覆盖的所有选项添加到其中。此外，*idauser.cfg*提供了将自定义选项从一个IDA版本转移到另一个版本的最简单方法。例如，使用*idauser.cfg*，您每次升级IDA副本时无需重新编辑*ida.cfg*。相反，只需在升级时将现有的*idauser.cfg*复制到新的IDA安装目录即可。
- en: 'The GUI Configuration File: idagui.cfg'
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI配置文件：idagui.cfg
- en: 'Configuration items specific to the GUI version of IDA are located in their
    own file: *<IDADIR>/cfg/idagui.cfg*. This file is organized into roughly three
    sections: default GUI behaviors, keyboard hotkey mappings, and file extension
    configuration for the File ▸ Open dialog. In this section we discuss a few of
    the more interesting options. Consult *idagui.cfg* for the complete list of available
    options, which in most cases are accompanied by comments describing their purpose.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 专门针对IDA GUI版本的配置项位于它们自己的文件中：*<IDADIR>/cfg/idagui.cfg*。此文件大致分为三个部分：默认GUI行为、键盘热键映射以及文件扩展配置（用于文件▸打开对话框）。在本节中，我们将讨论一些更有趣的选项。有关完整选项列表，请参阅*idagui.cfg*，其中大多数选项都附有描述其目的的注释。
- en: The Windows GUI version of IDA allows a secondary help file to be specified
    using the `HELPFILE` option. Any file specified here does not replace IDA’s primary
    help file. The intended purpose of this option is to provide access to supplemental
    information that may apply in specific reverse engineering situations. When a
    supplemental help file is specified, ctrl-F1 causes IDA to open the named file
    and search for a topic that matches the word under the cursor. If no match is
    found, then you are taken to the help file’s index. As an example, unless you
    count auto comments, IDA does not offer any help information regarding the instruction
    mnemonics in a disassembly. If you are analyzing an x86 binary, you might like
    to have an x86 instruction reference available on command. If you can locate a
    help file that happens to contain topics for each x86 instruction,^([[73](#ftn.CHP-11-FN-2)])
    then help for any instruction is only a hotkey away. The only word of caution
    concerning supplemental help files is that IDA supports only the older WinHelp-style
    help files (*.hlp*). IDA does not support the use of compiled HTML help files
    (*.chm*) as secondary help files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的Windows GUI版本允许使用`HELPFILE`选项指定一个辅助帮助文件。在此处指定的任何文件都不会替换IDA的主帮助文件。此选项的预期目的是提供可能适用于特定逆向工程情况的相关补充信息。当指定了补充帮助文件时，按Ctrl-F1将导致IDA打开指定的文件并搜索与光标下单词匹配的主题。如果没有找到匹配项，则将您带到帮助文件的索引。例如，除非您计算自动注释，否则IDA不会提供有关反汇编中指令助记符的任何帮助信息。如果您正在分析x86二进制文件，您可能希望在命令行上有一个x86指令参考。如果您能找到一个恰好包含每个x86指令主题的帮助文件，^([[73](#ftn.CHP-11-FN-2)))，那么任何指令的帮助信息都只需一个热键即可获得。关于补充帮助文件的唯一注意事项是，IDA仅支持较旧的WinHelp风格帮助文件
    (*.hlp*)。IDA不支持作为辅助帮助文件使用编译的HTML帮助文件 (*.chm*)。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Microsoft Windows Vista and later do not provide native support for 32-bit WinHelp
    files because the *WinHlp32.exe* file does not ship with these operating systems.
    Please refer to Microsoft Knowledge Base article 917607^([[74](#ftn.CHP-11-FN-3)])
    for more information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Windows Vista 及以后的版本不提供对 32 位 WinHelp 文件的本地支持，因为 *WinHlp32.exe* 文件不随这些操作系统一起提供。有关更多信息，请参阅
    Microsoft 知识库文章 917607^([[74](#ftn.CHP-11-FN-3)])。
- en: A common question asked about using IDA is “How can I patch binaries using IDA?”
    In a nutshell, the answer is “You can’t,” but we will put off discussing the details
    of this issue until [Chapter 14](ch14.html "Chapter 14. Patching Binaries and
    Other IDA Limitations"). What you can do with IDA is patch the database to modify
    instructions or data in almost any way you see fit. Once we discuss scripting
    ([Chapter 15](ch15.html "Chapter 15. IDA Scripting")), you will understand that
    modifying the database is not terribly difficult. But what if you are not interested
    in or not ready to learn IDA’s scripting language? IDA contains a database-patching
    menu that is not shown by default. The `DISPLAY_PATCH_SUBMENU` option is used
    to show or hide IDA’s patching menu, which shows up as Edit ▸ Patch Program. The
    options available on this menu are discussed in [Chapter 14](ch14.html "Chapter 14. Patching
    Binaries and Other IDA Limitations").
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 IDA 常见的问题之一是：“我如何使用 IDA 修补二进制文件？” 简而言之，答案是“你不能”，但我们将在 [第 14 章](ch14.html
    "第 14 章。修补二进制文件和其他 IDA 限制") 中推迟讨论这个问题的细节。你可以用 IDA 修补数据库来修改指令或数据，几乎可以按照你想要的方式。一旦我们讨论了脚本（[第
    15 章](ch15.html "第 15 章。IDA 脚本"）），你就会明白修改数据库并不特别困难。但如果你对学习 IDA 的脚本语言不感兴趣或还没有准备好学习呢？IDA
    包含一个默认不显示的数据库修补菜单。`DISPLAY_PATCH_SUBMENU` 选项用于显示或隐藏 IDA 的修补菜单，该菜单显示为“编辑 ▸ 修补程序”。此菜单上的选项将在
    [第 14 章](ch14.html "第 14 章。修补二进制文件和其他 IDA 限制") 中讨论。
- en: The single-line input box at the bottom of your IDA workspace is known as the
    IDA comand line. You can use the `DISPLAY_COMMAND_LINE` option to control whether
    this field is displayed or not. By default the command will be shown. If you are
    tight on screen space and you don’t anticipate the need to enter one-line scripts,
    then turning this feature off can help you regain a small amount of room in your
    IDA display. Note that this command line does not allow you to execute operating
    system commands as if you were entering them at a command prompt.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你 IDA 工作区底部的单行输入框被称为 IDA 命令行。你可以使用 `DISPLAY_COMMAND_LINE` 选项来控制是否显示此字段。默认情况下，命令将被显示。如果你屏幕空间紧张，并且你预计不需要输入单行脚本，那么关闭此功能可以帮助你在
    IDA 显示中恢复一小部分空间。请注意，此命令行不允许你像在命令提示符中输入一样执行操作系统命令。
- en: The hotkey configuration section of *idagui.cfg* is used to specify mappings
    between IDA actions and hotkey sequences. Hotkey reassignment is useful in many
    instances, including making additional commands available via hot-keys, changing
    default sequences to sequences that are easier to remember, or changing sequences
    that might conflict with other sequences in use by the operating system or your
    terminal application (useful primarily for the console version of IDA).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*idagui.cfg* 的热键配置部分用于指定 IDA 动作与热键序列之间的映射。在许多情况下，热键重新分配很有用，包括通过热键提供额外的命令、将默认序列更改为更容易记忆的序列，或者更改可能与操作系统或您的终端应用程序使用的其他序列冲突的序列（主要适用于
    IDA 的控制台版本）。'
- en: 'Virtually every option that IDA makes available through menu items or toolbar
    buttons is listed in this section. Unfortunately, the names of the commands tend
    not to match the text used on IDA’s menus, so it may take some effort to determine
    exactly which configuration file option maps to a specific menu option. For example,
    the Jump ▸ Jump to Problem command equates to the `JumpQ` option (which *does*
    happen to match its hotkey: ctrl-Q) in *idagui.cfg*. In addition, while many commands
    have matching comments to describe their purpose, many commands have no description
    at all, so you are left to determine the behavior of a command based on its name
    within the configuration file. A trick that may help you figure out what menu
    item a configuration file action is associated with is to *search* for the action
    in IDA’s help system. The results of such searches usually lead to the description
    of the action’s corresponding menu item.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 IDA 通过菜单项或工具栏按钮提供的选项都列在本节中。不幸的是，命令的名称往往不与 IDA 菜单上使用的文本相匹配，因此可能需要一些努力来确定确切的配置文件选项映射到特定的菜单选项。例如，跳转
    ▸ 跳转到问题的命令等同于 *idagui.cfg* 中的 `JumpQ` 选项（该选项恰好与其热键：ctrl-Q 相匹配）。此外，虽然许多命令都有匹配的注释来描述其目的，但许多命令完全没有描述，因此你必须根据配置文件中的名称来确定命令的行为。一个可能有助于你弄清楚配置文件动作与哪个菜单项相关联的技巧是在
    IDA 的帮助系统中搜索该动作。此类搜索的结果通常会导致描述动作对应菜单项的描述。
- en: 'The following lines represent example hotkey assignments in *idagui.cfg*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了 *idagui.cfg* 中的示例热键分配。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line is the hotkey assignment for IDA’s `Abort` command, which in
    this case has no hotkey assignment. The unquoted value `0` indicates that no hotkey
    has been assigned to a command. The second line shows the hotkey assignment for
    IDA’s `Quit` action. Hotkey sequences are specified as a quoted string naming
    the key sequence. Numerous examples of hotkey assignments exist within *idagui.cfg*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是 IDA 的 `Abort` 命令的热键分配，在这种情况下没有分配热键。未引用的值 `0` 表示没有为命令分配热键。第二行显示了 IDA 的 `Quit`
    动作的热键分配。热键序列指定为一个命名键序列的引号字符串。*idagui.cfg* 中存在许多热键分配的示例。
- en: The final portion of *idagui.cfg* associates file type descriptions with their
    associated file extensions and specifies which file types will be listed in the
    Files of type drop-down list within the File ▸ Open dialog. A large number of
    file types are already described in the configuration file; however, if you find
    yourself frequently working with a file type that is not available, you may want
    to edit the file types list to add your file type to the list. The `FILE_EXTENSIONS`
    option describes all file associations known to IDA. The following line is an
    example of a typical file type association.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*idagui.cfg* 文件的最后一部分将文件类型描述与其关联的文件扩展名相联系，并指定了哪些文件类型将在文件 ▸ 打开对话框中的“文件类型”下拉列表中列出。配置文件中已经描述了大量的文件类型；然而，如果你经常使用配置文件中没有的文件类型，你可能需要编辑文件类型列表，将你的文件类型添加到列表中。`FILE_EXTENSIONS`
    选项描述了 IDA 所知的所有文件关联。以下是一般文件类型关联的示例。'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The line contains three comma-separated components: a name for the association
    (`CLASS_JAVA`), a description, and a filename pattern. Wildcards are allowed in
    the filename pattern, and multiple patterns can be specified by using a semicolon
    to separate them. A second type of file association allows several existing associations
    to be grouped into a single category. For example, the following line groups all
    associations whose names begin with `EXE_` into a single association named `EXE`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该行包含三个以逗号分隔的组件：关联的名称（`CLASS_JAVA`）、描述和文件名模式。文件名模式中允许使用通配符，并且可以通过分号分隔来指定多个模式。第二种类型的文件关联允许将几个现有的关联组合成一个单独的分类。例如，以下行将所有名称以
    `EXE_` 开头的关联组合成一个名为 `EXE` 的单个关联。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the pattern specifier in this case is not quoted. We might define
    our own file association as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，模式指定符没有被引号括起来。我们可以定义自己的文件关联如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can choose any name we like for the association as long as it is not already
    in use; however, simply adding a new association to the `FILE_EXTENSIONS` list
    is not sufficient to make that association appear in the File ▸ Open dialog. The
    `DEFAULT_FILE_FILTER` option lists the names of all associations that will appear
    in the File ▸ Open dialog. To complete the process and make our new association
    available, we would need to add `IDA_BOOK` to the `DEFAULT_FILE_FILTER` list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为关联选择任何我们喜欢的名称，只要它尚未被使用；然而，仅仅将新的关联添加到 `FILE_EXTENSIONS` 列表中并不足以使该关联出现在文件
    ▸ 打开对话框中。`DEFAULT_FILE_FILTER` 选项列出了将在文件 ▸ 打开对话框中出现的所有关联的名称。为了完成此过程并使我们的新关联可用，我们需要将
    `IDA_BOOK` 添加到 `DEFAULT_FILE_FILTER` 列表中。
- en: Similar to the *idauser.cfg* file, the last line in *idagui.cfg* contains a
    directive to include a file named *<IDADIR>/cfg/idauserg.cfg*. If you do not feel
    comfortable editing *idagui.cfg*, then you should create *idauserg.cfg* and add
    to it all of the options that you wish to override.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *idauser.cfg* 文件类似，*idagui.cfg* 中的最后一行包含一个指令，用于包含一个名为 *<IDADIR>/cfg/idauserg.cfg*
    的文件。如果您不习惯编辑 *idagui.cfg*，那么您应该创建 *idauserg.cfg* 并添加您希望覆盖的所有选项。
- en: 'The Console Configuration File: idatui.cfg'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台配置文件：idatui.cfg
- en: The analog to *idagui.cfg* for users of the console version of IDA is *<IDADIR>/cfg/idatui.cfg*.
    This file is very similar in layout and functionality to *idagui.cfg*. Among other
    things, hotkey specifications are made in the exact same manner as they are in
    *idagui.cfg*. Because the two files are so similar, we will detail only the differences
    here.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IDA 控制台版本的用户来说，*idatui.cfg* 是 *idagui.cfg* 的对应文件。这个文件在布局和功能上与 *idagui.cfg*
    非常相似。在众多方面中，热键的指定方式与 *idagui.cfg* 中完全相同。由于这两个文件非常相似，我们在这里只详细说明它们之间的差异。
- en: First, the options `DISPLAY_PATCH_SUBMENU` and `DISPLAY_COMMAND_LINE` are not
    available in the console version and are not included in *idatui.cfg*. The File
    ▸ Open dialog used in the console version is far simpler than the dialog used
    in the GUI version, so all of the file association commands available in *idagui.cfg*
    are missing in *idatui.cfg*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`DISPLAY_PATCH_SUBMENU` 和 `DISPLAY_COMMAND_LINE` 选项在控制台版本中不可用，并且不包括在 *idatui.cfg*
    中。控制台版本中使用的文件 ▸ 打开对话框比 GUI 版本中使用的对话框简单得多，因此 *idagui.cfg* 中可用的所有文件关联命令在 *idatui.cfg*
    中都缺失。
- en: On the other hand, a few options are available *only* for console versions of
    IDA. For example, you can use the `NOVICE` option to have IDA start in a beginner
    mode, in which it disables some of its more complex functionality in an attempt
    to be easier to learn. A notable difference in novice mode is the almost complete
    lack of subviews.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一些选项仅适用于 IDA 的控制台版本。例如，您可以使用 `NOVICE` 选项让 IDA 以初学者模式启动，在这种模式下，它会禁用一些更复杂的功能，以便更容易学习。初学者模式的一个显著区别是几乎完全缺乏子视图。
- en: 'Console users are far more likely to rely on the use of hotkey sequences. To
    facilitate the automation of common hotkey sequences, console mode IDA provides
    a keyboard macro definition syntax. Several example macros can be found in *idatui.cfg*;
    however, the ideal location to place any macros that you develop is *<IDADIR>/cfg/idausert.cfg*
    (the console equivalent of *idauserg.cfg*). A sample macro contained in the default
    *idatui.cfg* might look like the following (in the actual *idatui.cfg*, this macro
    is commented out):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台用户更有可能依赖于热键序列的使用。为了便于自动化常见的热键序列，控制台模式的 IDA 提供了键盘宏定义语法。在 *idatui.cfg* 中可以找到几个示例宏；然而，放置您开发的任何宏的理想位置是
    *<IDADIR>/cfg/idausert.cfg*（*idauserg.cfg* 的控制台版本）。默认 *idatui.cfg* 中包含的一个示例宏可能看起来如下（在实际的
    *idatui.cfg* 中，此宏已被注释掉）：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Macro` definitions are introduced with the `MACRO` keyword ![](httpatomoreillycomsourcenostarchimages854061.png)
    followed by the hotkey ![](httpatomoreillycomsourcenostarchimages854063.png) to
    be associated with the macro. The macro sequence itself is specified between braces
    as a sequence of key name strings or characters, which may in turn represent hotkey
    sequences themselves. The preceding example macro, activated using alt-H, opens
    the Jump to Address dialog using the G hotkey, enters the label *start* into the
    dialog one character at a time, and then closes the dialog using the enter key.
    Note that we could not use the syntax “start” to enter the name of the symbol,
    as this would be taken as the name of a hotkey and result in an error.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`宏`定义通过`MACRO`关键字引入，后跟要关联的快捷键 ![](httpatomoreillycomsourcenostarchimages854061.png)，宏序列本身在花括号中指定，为键名字符串或字符的序列，这些键名字符串或字符本身也可以代表快捷键序列。前一个示例宏，通过按alt-H激活，使用G快捷键打开转到地址对话框，逐个字符地将标签*start*输入到对话框中，然后使用回车键关闭对话框。请注意，我们不能使用“start”语法来输入符号名称，因为这将被视为快捷键名称并导致错误。'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Macros and novice mode are not available in the GUI version of IDA.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 宏和初学者模式在IDA的GUI版本中不可用。
- en: As a final note about configuration file options, it is important to know that
    if IDA encounters any errors while parsing its configuration files, it immediately
    terminates with an error message that attempts to describe the nature of the problem.
    It is not possible to start IDA until the error condition has been corrected.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置文件选项的最后一项说明，重要的是要知道，如果IDA在解析配置文件时遇到任何错误，它会立即终止并显示错误消息，尝试描述问题的性质。只有在错误条件被纠正后，才能启动IDA。
- en: '* * *'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[72](#CHP-11-FN-1)]) This file does not ship with IDA. Users must generate
    this file on their own if they wish IDA to find it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[72](#CHP-11-FN-1)]) 此文件不随IDA一起提供。如果用户希望IDA能够找到它，他们必须自己生成此文件。
- en: '^([[73](#CHP-11-FN-2)]) Pedram Amini swears by this WinHelp32 file: [http://pedram.redhive.com/openrce/opcodes.hlp](http://pedram.redhive.com/openrce/opcodes.hlp).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[73](#CHP-11-FN-2)]) Pedram Amini 对这个WinHelp32文件深信不疑：[http://pedram.redhive.com/openrce/opcodes.hlp](http://pedram.redhive.com/openrce/opcodes.hlp)。
- en: ^([[74](#CHP-11-FN-3)]) See [http://support.microsoft.com/kb/917607](http://support.microsoft.com/kb/917607).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[74](#CHP-11-FN-3)]) 请参阅 [http://support.microsoft.com/kb/917607](http://support.microsoft.com/kb/917607)。
- en: Additional IDA Configuration Options
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA的其他配置选项
- en: IDA has a tremendous number of additional options that must be configured through
    the IDA user interface. Options for formatting individual disassembly lines were
    discussed in [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation"). Additional
    IDA options are accessed via the Options menu, and in most cases, any options
    that you modify apply only to the currently opened database. Values for those
    options are stored in the associated database file when the database is closed.
    IDA’s Color (Options ▸ Colors) and Font (Options ▸ Font) options are two of the
    exceptions to this rule in that they are global options that, once set, remain
    in effect in all future IDA sessions. For Windows versions of IDA, option values
    are stored in the Windows registry under the `HKEY_CURRENT_USER\Software\Hex-Rays\IDA`
    registry key. For non-Windows versions of IDA, these values are stored in your
    home directory in a proprietary format file named `$HOME/.idapro/ida.reg`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: IDA有大量的其他选项，必须通过IDA用户界面进行配置。在第7章（第7.反汇编操作）中讨论了格式化单个反汇编行的选项。通过选项菜单可以访问额外的IDA选项，在大多数情况下，您修改的任何选项仅适用于当前打开的数据库。这些选项的值在关闭数据库时存储在相关的数据库文件中。IDA的颜色（选项
    ▸ 颜色）和字体（选项 ▸ 字体）选项是此规则的例外，因为它们是全局选项，一旦设置，在所有未来的IDA会话中都将保持有效。对于IDA的Windows版本，选项值存储在Windows注册表中的`HKEY_CURRENT_USER\Software\Hex-Rays\IDA`注册表键下。对于非Windows版本的IDA，这些值存储在您的家目录中，以名为`$HOME/.idapro/ida.reg`的专有格式文件中。
- en: Another piece of information that is saved in the registry concerns dialogs
    for which you may choose the Do not display this dialog box again option. This
    message occasionally appears in the form of a checkbox in the lower-right portion
    of some informational message dialogs that you may not wish to see in the future.
    Should you select this option, a registry value is created under the `HKEY_CURRENT_USER\Software\Hex-Rays\IDA\Hidden
    Messages` registry key. If, at a later time, you wish to have a hidden dialog
    displayed once again, you will need to delete the appropriate value under this
    registry key.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表中保存的另一条信息是你可以选择“不再显示此对话框”选项的对话框。此消息偶尔以复选框的形式出现在某些你可能不想在未来看到的 informational
    message dialogs 的右下角。如果你选择此选项，将在 `HKEY_CURRENT_USER\Software\Hex-Rays\IDA\Hidden
    Messages` 注册键下创建一个注册表值。如果在以后的时间你想再次显示隐藏的对话框，你需要删除此注册键下的相应值。
- en: IDA Colors
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 颜色
- en: The color of virtually every item in an IDA display can be customized via the
    Options ▸ Colors dialog shown in [Figure 11-1](ch11s02.html#the_color_selection_dialog
    "Figure 11-1. The color selection dialog").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 显示中几乎每个项目的颜色都可以通过 [图 11-1](ch11s02.html#the_color_selection_dialog "图 11-1.
    颜色选择对话框") 中显示的“选项 ▸ 颜色”对话框进行自定义。
- en: '![The color selection dialog](httpatomoreillycomsourcenostarchimages854231.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![颜色选择对话框](httpatomoreillycomsourcenostarchimages854231.png.jpg)'
- en: Figure 11-1. The color selection dialog
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1. 颜色选择对话框
- en: The Disassembly tab controls the colors used for various parts of each line
    in the disassembly window. Examples of each type of text that can appear in a
    disassembly are given in the example window ![](httpatomoreillycomsourcenostarchimages854061.png).
    When you select an item in the example window, the item’s type is listed at ![](httpatomoreillycomsourcenostarchimages854063.png).
    Using the Change Color button, you may assign any color you wish to any item you
    wish.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解码标签页控制解码窗口中每行各个部分的颜色。解码窗口中可以出现的文本类型示例在示例窗口中给出 ![示例窗口](httpatomoreillycomsourcenostarchimages854061.png)。当你选择示例窗口中的某个项目时，该项目类型会在
    ![项目类型列表](httpatomoreillycomsourcenostarchimages854063.png) 中列出。使用更改颜色按钮，你可以将任何你希望的颜色分配给任何你希望的项目。
- en: The color selection dialog contains tabs for assigning colors used in the navigation
    band, the debugger, the jump arrows in the left margin of the text disassembly
    view, and various components in the graph view. Specifically, the Graph tab controls
    the coloring of graph nodes, their title bars, and the edges that connect each
    node, while the Disassembly tab controls the coloring of disassembled text in
    the graph view. The Misc tab allows for customizing the colors used in IDA’s message
    window.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色选择对话框包含用于分配导航栏、调试器、文本解码视图左侧边距中的跳转箭头以及图形视图中各种组件颜色的标签页。具体来说，图形标签页控制图形节点的着色、它们的标题栏以及连接每个节点的边，而解码标签页控制图形视图中解码文本的着色。杂项标签页允许自定义
    IDA 消息窗口中使用的颜色。
- en: Customizing IDA Toolbars
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 IDA 工具栏
- en: In addition to menus and hotkeys, the GUI version of IDA offers a large number
    of toolbar buttons spread across more than two dozen toolbars. Toolbars are typically
    docked in the main toolbar area beneath IDA’s menu bar. Two predefined toolbar
    arrangements accessible using the View ▸ Toolbars menu are Basic mode, which enables
    seven of IDA’s toolbars, and Advanced mode, which enables every IDA toolbar. Individual
    toolbars can be detached, dragged, and relocated to any location on the screen
    to suit your personal taste. If you find that you have no need for a particular
    toolbar, you can remove it from the display entirely via the View ▸ Toolbars menu,
    which is shown in [Figure 11-2](ch11s02.html#the_toolbar_configuration_menu "Figure 11-2. The
    toolbar configuration menu").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了菜单和快捷键之外，IDA 的 GUI 版本提供了超过二十多个工具栏上的大量工具栏按钮。工具栏通常停靠在 IDA 菜单栏下方的工具栏区域。使用“查看
    ▸ 工具栏”菜单可以访问两个预定义的工具栏布局：基本模式，它启用了 IDA 的七个工具栏，以及高级模式，它启用了所有 IDA 工具栏。可以单独拆分、拖动和重新定位工具栏到屏幕上的任何位置以适应个人喜好。如果你发现你不需要特定的工具栏，你可以通过“查看
    ▸ 工具栏”菜单将其从显示中完全删除，该菜单在 [图 11-2](ch11s02.html#the_toolbar_configuration_menu "图
    11-2. 工具栏配置菜单") 中显示。
- en: This menu also appears if you right-click anywhere within the docking area of
    the IDA display. Turning off the Main toolbar removes all toolbars from the docking
    area and is useful if you need to maximize the amount of screen space dedicated
    to the disassembly window. Any changes that you make to your toolbar arrangement
    are stored with the current database. Opening a second database will restore the
    toolbars to the arrangement that was in effect when the second database was last
    saved. Opening a new binary to create a new database restores the toolbar arrangement
    based on IDA’s current default toolbar settings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜单也会在你在IDA显示的停靠区域内任何位置右键单击时出现。关闭主工具栏将从停靠区域移除所有工具栏，这在需要最大化分配给反汇编窗口的屏幕空间时很有用。你对工具栏布局所做的任何更改都将与当前数据库一起保存。打开第二个数据库将恢复到在第二个数据库上次保存时生效的工具栏布局。打开新的二进制文件以创建新的数据库将恢复基于IDA当前默认工具栏设置的工具栏布局。
- en: '![The toolbar configuration menu](httpatomoreillycomsourcenostarchimages854233.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![工具栏配置菜单](httpatomoreillycomsourcenostarchimages854233.png.jpg)'
- en: Figure 11-2. The toolbar configuration menu
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2. 工具栏配置菜单
- en: If you settle on a toolbar arrangement that you happen to like and wish to make
    it the default, then you should save the current desktop arrangement as your default
    desktop using Windows ▸ Save Desktop, which opens the dialog shown in [Figure 11-3](ch11s02.html#the_save_disassembly_desk-top_dialog
    "Figure 11-3. The Save Disassembly Desktop dialog").
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了一个你喜欢的工具栏布局并希望将其设置为默认，那么你应该使用Windows ▸ 保存桌面来保存当前的桌面布局为默认桌面，这将打开显示在[图11-3](ch11s02.html#the_save_disassembly_desk-top_dialog
    "图11-3. 保存反汇编桌面对话框")中的对话框。
- en: '![The Save Disassembly Desktop dialog](httpatomoreillycomsourcenostarchimages854235.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![保存反汇编桌面对话框](httpatomoreillycomsourcenostarchimages854235.png.jpg)'
- en: Figure 11-3. The Save Disassembly Desktop dialog
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3. 保存反汇编桌面对话框
- en: Each time you save a desktop configuration, you are asked to supply a name for
    the configuration. When the Default checkbox is selected, the current desktop
    layout becomes the default for all new databases and the desktop to which you
    will revert if you choose Windows ▸ Reset desktop. To restore the display to one
    of your custom desktops, select **Windows** ▸ **Load Desktop** and choose the
    named layout that you wish to load. Saving and restoring desktops is particularly
    useful in situations that involve using multiple monitors with different sizes
    and/or resolutions (which may be common with laptops using different docking stations
    or when connecting to projectors for presentations).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你保存桌面配置时，都会要求你为该配置提供一个名称。当选择默认复选框时，当前桌面布局将成为所有新数据库的默认布局，以及如果你选择Windows ▸ 重置桌面将返回的桌面。要恢复到你的自定义桌面之一，选择**Windows**
    ▸ **加载桌面**并选择你希望加载的命名布局。保存和恢复桌面在涉及使用不同尺寸和/或分辨率的多个显示器的情况下特别有用（这在使用不同坞站或连接到投影仪进行演示的笔记本电脑中可能很常见）。
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When starting out with IDA, you may be perfectly satisfied with both its default
    behaviors and its default GUI layout. As you become more comfortable with IDA’s
    basic features, you are certain to find ways to customize IDA to your particular
    tastes. While there is no way to provide complete coverage of every possible option
    IDA offers in a single chapter, we have attempted to provide pointers to the principal
    locations in which those options may be found. We have also attempted to highlight
    those options that you are most likely to want to manipulate at some point in
    your IDA experience. Discovering additional useful options is left as a matter
    of exploration for inquisitive readers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始使用IDA时，你可能会对它的默认行为和默认GUI布局感到非常满意。随着你对IDA的基本功能越来越熟悉，你一定会找到将IDA定制到你个人喜好的方法。虽然无法在一个章节中提供IDA提供的每个可能选项的完整覆盖，但我们已经尝试提供指向那些选项可能被找到的主要位置的指针。我们还尝试突出显示那些你可能在IDA体验的某个时刻想要操作的最有可能的选项。发现更多有用的选项留作好奇读者的探索任务。
- en: Chapter 12. Library Recognition Using FLIRT Signatures
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。使用FLIRT签名进行库识别
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: At this point it is time to start moving beyond IDA’s more obvious capabilities
    and begin our exploration of what to do after “The initial autoanalysis has been
    finished.”^([[75](#ftn.CHP-12-FN-1)]) In this chapter we discuss techniques for
    recognizing standard code sequences such as the library code contained in statically
    linked binaries or standard initialization and helper functions inserted by compilers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，是时候开始超越 IDA 更明显的功能，并开始探索“初始自动分析完成后”要做的事情了^([[75](#ftn.CHP-12-FN-1)))。在本章中，我们讨论了识别标准代码序列的技术，例如静态链接二进制文件中包含的库代码或编译器插入的标准初始化和辅助函数。
- en: When you set out to reverse engineer any binary, the last thing that you want
    to do is waste time reverse engineering library functions whose behavior you could
    learn much more easily simply by reading a man page, reading some source code,
    or doing a little Internet research. The challenge presented by statically linked
    binaries is that they blur the distinction between application code and library
    code. In a statically linked binary, entire libraries are combined with application
    code to form a single monolithic executable file. Fortunately for us, tools are
    available that enable IDA to recognize and mark library code, allowing us to focus
    our attention on the unique code within the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始逆向工程任何二进制文件时，你最不想做的事情就是浪费时间逆向工程那些你可以通过阅读手册页、阅读一些源代码或进行一点网络研究就能轻易了解其行为的库函数。静态链接二进制文件所提出的挑战在于它们模糊了应用程序代码和库代码之间的区别。在静态链接的二进制文件中，整个库与应用程序代码结合形成一个单一的庞大可执行文件。幸运的是，我们有可用的工具，使
    IDA 能够识别并标记库代码，从而让我们将注意力集中在应用程序中的独特代码上。
- en: Fast Library Identification and Recognition Technology
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速库识别和识别技术
- en: Fast Library Identification and Recognition Technology, better known as FLIRT,^([[76](#ftn.CHP-12-FN-2)])
    encompasses the set of techniques employed by IDA to identify sequences of code
    as library code. At the heart of FLIRT are pattern-matching algorithms that enable
    IDA to quickly determine whether a disassembled function matches one of the many
    signatures known to IDA. The *<IDADIR>/sig* directory contains the signature files
    that ship with IDA. For the most part, these are libraries that ship with common
    Windows compilers, though a few non-Windows signatures are also included.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 快速库识别和识别技术，更广为人知的是 FLIRT^([[76](#ftn.CHP-12-FN-2)))，它包括 IDA 用来识别代码序列作为库代码所采用的一系列技术。FLIRT
    的核心是模式匹配算法，它使 IDA 能够快速确定反汇编的函数是否与 IDA 已知的许多签名之一相匹配。《<IDADIR>/sig》目录包含与 IDA 一起提供的签名文件。大多数情况下，这些是随常见
    Windows 编译器一起提供的库，尽管也包括一些非 Windows 签名。
- en: 'Signature files utilize a custom format in which the bulk of the signature
    data is compressed and wrapped in an IDA-specific header. In most cases, signature
    filenames do not clearly indicate which library the associated signatures were
    generated from. Depending on how they were created, signature files may contain
    a library name comment that describes their contents. If we view the first few
    lines of extracted ASCII content from a signature file, this comment is often
    revealed. The following Unix-style command^([[77](#ftn.CHP-12-FN-3)]) generally
    reveals the comment in the second or third line of output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 签名文件使用一种自定义格式，其中大部分签名数据被压缩并包裹在一个 IDA 特定的头部中。在大多数情况下，签名文件的名称并不清楚地表明与之关联的签名是从哪个库生成的。根据它们的创建方式，签名文件可能包含一个库名称注释，描述其内容。如果我们查看从签名文件中提取的前几行
    ASCII 内容，这个注释通常会被揭示出来。以下 Unix 风格的命令^([[77](#ftn.CHP-12-FN-3))) 通常会在输出的第二行或第三行中揭示注释：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within IDA, there are two ways to view comments associated with signature files.
    First, you can access the list of signatures that have been applied to a binary
    via View ▸ Open Subviews ▸ Signatures. Second, the list of all signature files
    is displayed as part of the manual signature application process, which is initiated
    via File ▸ Load File ▸ FLIRT Signature File.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDA 中，有两种方式可以查看与签名文件关联的注释。首先，你可以通过“查看”▸“打开子视图”▸“签名”访问应用于二进制文件的签名列表。其次，所有签名文件的列表作为手动签名应用过程的一部分显示，该过程通过“文件”▸“加载文件”▸“FLIRT
    签名文件”启动。
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[75](#CHP-12-FN-1)]) IDA generates this message in the Output window when
    it has finished its automated processing of a newly loaded binary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[75](#CHP-12-FN-1)]) 当 IDA 完成对新加载的二进制文件的自动处理时，它会在输出窗口生成此消息。
- en: ^([[76](#CHP-12-FN-2)]) See [http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[76](#CHP-12-FN-2)]) 请参阅[http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm)。
- en: ^([[77](#CHP-12-FN-3)]) The `strings` command was discussed in [Chapter 2](ch02.html
    "Chapter 2. Reversing and Disassembly Tools"), while the `head` command is used
    to view only the first few lines (three in the example) of its input source.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[77](#CHP-12-FN-3)]) 在[第2章](ch02.html "第2章。逆向和反汇编工具")中讨论了`strings`命令，而`head`命令用于仅查看其输入源的最初几行（例如示例中的三行）。
- en: Applying FLIRT Signatures
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用FLIRT签名
- en: When a binary is first opened, IDA attempts to apply special signature files,
    designated as startup signatures, to the entry point of the binary. It turns out
    that the entry point code generated by various compilers is sufficiently unique
    that matching entry point signatures is a useful technique for identifying the
    compiler that may have been used to generate a given binary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次打开二进制文件时，IDA会尝试将特殊签名文件应用于二进制文件的入口点，这些签名文件被称为启动签名。结果证明，由各种编译器生成的入口点代码足够独特，匹配入口点签名是识别可能用于生成给定二进制文件的编译器的一种有用技术。
- en: MAIN VS. _START
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MAIN VS. _START
- en: Recall that a program’s entry point is the address of the first instruction
    that will be executed. Many longtime C programmers incorrectly believe that this
    is the address of the function named `main`, when in fact it is not. The file
    type of the program, *not* the language used to create the program, dictates the
    manner in which command-line arguments are provided to a program. In order to
    reconcile any differences between the way the loader presents command-line arguments
    and the way the program expects to receive them (via parameters to `main`, for
    example), some initialization code must execute prior to transferring control
    to `main`. It is this initialization that IDA designates as the entry point of
    the program and labels `_start`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，程序的人口点是第一条将要执行的指令的地址。许多长期从事C语言编程的开发者错误地认为这是名为`main`的函数的地址，而实际上并非如此。程序的文件类型，*而不是*创建程序所使用的语言，决定了向程序提供命令行参数的方式。为了解决加载器呈现命令行参数的方式与程序期望接收它们的方式（例如通过`main`的参数）之间的任何差异，必须在将控制权传递给`main`之前执行一些初始化代码。IDA将此初始化指定为程序的入口点，并标记为`_start`。
- en: This initialization code is also responsible for any initialization tasks that
    must take place before `main` is allowed to run. In a C++ program, this code is
    responsible for ensuring that constructors for globally declared objects are called
    prior to execution of `main`. Similarly, cleanup code is inserted that executes
    after `main` completes in order to invoke destructors for all global objects prior
    to the actual termination of the program.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此初始化代码还负责在允许`main`运行之前必须执行的所有初始化任务。在C++程序中，此代码负责确保在执行`main`之前调用全局声明的对象的构造函数。同样，在`main`完成后插入清理代码，以便在程序实际终止之前调用所有全局对象的析构函数。
- en: If IDA identifies the compiler used to create a particular binary, then the
    signature file for the corresponding compiler libraries is loaded and applied
    to the remainder of the binary. The signatures that ship with IDA tend to be related
    to proprietary compilers such as Microsoft Visual C++ or Borland Delphi. The reason
    behind this is that a finite number of binary libraries ship with these compilers.
    For open source compilers, such as GNU gcc, the binary variations of the associated
    libraries are as numerous as the operating systems the compilers ship with. For
    example, each version of FreeBSD ships with a unique version of the C standard
    library. For optimal pattern matching, signature files would need to be generated
    for each version of the library. Consider the difficulty in collecting every variation
    of *libc.a*^([[78](#ftn.CHP-12-FN-4)]) that has shipped with every version of
    every Linux distribution. It simply is not practical. In part, these differences
    are due to changes in the library source code that result in different compiled
    code, but huge differences also result from the use of different compilation options,
    such as optimization settings and the use of different compiler versions to build
    the library. The net result is that IDA ships with very few signature files for
    open source compiler libraries. The good news, as you shall soon see, is that
    Hex-Rays makes tools available that allow you to generate your own signature files
    from static libraries.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 IDA 识别出用于创建特定二进制的编译器，那么相应的编译器库的签名文件将被加载并应用于二进制的其余部分。IDA 随附的签名通常与专有编译器相关，例如
    Microsoft Visual C++ 或 Borland Delphi。背后的原因是这些编译器随附的二进制库数量是有限的。对于开源编译器，如 GNU gcc，相关库的二进制变体数量与编译器支持的操作系统数量一样多。例如，FreeBSD
    的每个版本都附带一个独特的 C 标准库版本。为了进行最佳模式匹配，需要为库的每个版本生成签名文件。考虑收集每个 Linux 发行版中每个版本所附带的 *libc.a*^([[78](#ftn.CHP-12-FN-4)])
    的所有变体是多么困难。这根本不切实际。部分差异是由于库源代码的变化导致的编译代码不同，但巨大的差异也源于不同的编译选项的使用，例如优化设置和使用不同的编译器版本来构建库。最终结果是，IDA
    为开源编译器库提供的签名文件非常少。好消息，正如你很快就会看到的，是 Hex-Rays 提供了工具，允许你从静态库中生成自己的签名文件。
- en: So, under what circumstances might you be required to manually apply signatures
    to one of your databases? Occasionally IDA properly identifies the compiler used
    to build the binary but has no signatures for the related compiler libraries.
    In such cases, either you will need to live without signatures, or you will need
    to obtain copies of the static libraries used in the binary and generate your
    own signatures. Other times, IDA may simply fail to identify a compiler, making
    it impossible to determine which signatures should be applied to a database. This
    is common when analyzing obfuscated code in which the startup routines have been
    sufficiently mangled to preclude compiler identification. The first thing to do,
    then, would be to de-obfuscate the binary sufficiently before you could have any
    hope of matching library signatures. We will discuss techniques for dealing with
    obfuscated code in [Chapter 21](ch21.html "Chapter 21. Obfuscated Code Analysis").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在什么情况下你可能需要手动将签名应用于你的数据库之一？偶尔 IDA 正确识别出构建二进制的编译器，但没有相关编译器库的签名。在这种情况下，你可能需要没有签名地生活，或者你需要获取二进制中使用的静态库的副本并生成自己的签名。有时，IDA
    可能简单地无法识别编译器，这使得确定应应用于数据库的签名变得不可能。这在分析混淆代码时很常见，其中启动例程被充分混淆，以至于无法识别编译器。因此，首先需要做的是在有任何希望匹配库签名之前，足够地去除二进制的混淆。我们将在
    [第 21 章](ch21.html "第 21 章。混淆代码分析") 中讨论处理混淆代码的技术。
- en: Regardless of the reason, if you wish to manually apply signatures to a database,
    you do so via File ▸ Load File ▸ FLIRT Signature File, which opens the signature
    selection dialog shown in [Figure 12-1](ch12s02.html#flirt_signature_selection
    "Figure 12-1. FLIRT signature selection").
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于什么原因，如果你希望手动将签名应用于数据库，你可以通过 File ▸ Load File ▸ FLIRT Signature File 来完成，这将打开显示在
    [图 12-1](ch12s02.html#flirt_signature_selection "图 12-1. FLIRT 签名选择") 中的签名选择对话框。
- en: '![FLIRT signature selection](httpatomoreillycomsourcenostarchimages854237.png.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![FLIRT 签名选择](httpatomoreillycomsourcenostarchimages854237.png.jpg)'
- en: Figure 12-1. FLIRT signature selection
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1. FLIRT 签名选择
- en: The File column reflects the name of each *.sig* file in IDA’s *<IDADIR>/sig*
    directory. Note that there is no means to specify an alternate location for *.sig*
    files. If you ever generate your own signatures, they need to be placed into *<IDADIR>/sig*
    along with every other *.sig* file. The Library name column displays the library
    name comment that is embedded within each file. Keep in mind that these comments
    are only as descriptive as the creator of the signatures (which could be you!)
    chooses to make them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 文件列反映了IDA的 *<IDADIR>/sig* 目录中每个 *.sig* 文件的名字。请注意，没有方法可以指定 *.sig* 文件的替代位置。如果您生成自己的签名，它们需要与每个其他的
    *.sig* 文件一起放入 *<IDADIR>/sig* 目录中。库名称列显示每个文件中嵌入的库名称注释。请记住，这些注释的描述性仅取决于签名创建者（这可能是您自己！）选择的程度。
- en: When a library module is selected, the signatures contained in the corresponding
    *.sig* file are loaded and compared against every function within the database.
    Only one set of signatures may be applied at a time, so you will need to repeat
    the process if you wish to apply several different signature files to a database.
    When a function is found to match a signature, the function is marked as a library
    function, and the function is automatically renamed according to the signature
    that has been matched.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择库模块时，对应 *.sig* 文件中包含的签名会被加载并与数据库中的每个函数进行比较。一次只能应用一组签名，因此如果您想对一个数据库应用多个不同的签名文件，您需要重复此过程。当找到一个与签名匹配的函数时，该函数会被标记为库函数，并且根据匹配到的签名自动重命名。
- en: Warning
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Only functions named with an IDA dummy name can be automatically renamed. In
    other words, if you have renamed a function, and that function is later matched
    by a signature, then the function will not be renamed as a result of the match.
    Therefore, it is to your benefit to apply signatures as early in your analysis
    process as possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用IDA虚拟名称命名的函数才能自动重命名。换句话说，如果您已经重命名了一个函数，并且该函数后来与一个签名匹配，那么该函数不会因为匹配而重命名。因此，在分析过程的早期尽可能早地应用签名对您是有益的。
- en: Recall that statically linked binaries blur the distinction between application
    code and library code. If you are fortunate enough to have a statically linked
    binary that has not had its symbols stripped, you will at least have useful function
    names (as useful as the trustworthy programmer has chosen to create) to help you
    sort your way through the code. However, if the binary has been stripped, you
    will have perhaps hundreds of functions, all with IDA-generated names that fail
    to indicate what the function does. In both cases, IDA will be able to identify
    library functions only if signatures are available (function names in an unstripped
    binary do not provide IDA with enough information to definitively identify a function
    as a library function). [Figure 12-2](ch12s02.html#statically_linked_with_no_signatures
    "Figure 12-2. Statically linked with no signatures") shows the Overview Navigator
    for a statically linked binary.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，静态链接的二进制模糊了应用程序代码和库代码之间的区别。如果您有幸拥有一个没有符号剥离的静态链接二进制文件，您至少会有有用的函数名（如可信的程序员选择创建的那样）来帮助您在代码中导航。然而，如果二进制文件已被剥离，您可能会有一百多个函数，所有这些函数都有IDA生成的名称，这些名称无法表明函数的功能。在这两种情况下，只有当有签名可用时，IDA才能识别库函数（未剥离的二进制文件中的函数名称不提供足够的信息让IDA确定性地将函数识别为库函数）。[图12-2](ch12s02.html#statically_linked_with_no_signatures
    "图12-2. 没有签名的静态链接")显示了静态链接二进制的概览导航器。
- en: '![Statically linked with no signatures](httpatomoreillycomsourcenostarchimages854239.png.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![没有签名的静态链接](httpatomoreillycomsourcenostarchimages854239.png.jpg)'
- en: Figure 12-2. Statically linked with no signatures
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2. 没有签名的静态链接
- en: In this display, no functions have been identified as library functions, so
    you may find yourself analyzing far more code than you really need to. After application
    of an appropriate set of signatures, the Overview Navigator is transformed as
    shown in [Figure 12-3](ch12s02.html#statically_linked_binary_with_signatures "Figure 12-3. Statically
    linked binary with signatures applied").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个显示中，没有识别出库函数，因此您可能会发现自己需要分析比实际需要的更多代码。在应用适当的签名集后，概览导航器会像[图12-3](ch12s02.html#statically_linked_binary_with_signatures
    "图12-3. 应用了签名的静态链接二进制")所示那样转换。
- en: '![Statically linked binary with signatures applied](httpatomoreillycomsourcenostarchimages854241.png.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![应用了签名的静态链接二进制](httpatomoreillycomsourcenostarchimages854241.png.jpg)'
- en: Figure 12-3. Statically linked binary with signatures applied
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3. 应用了签名的静态链接二进制
- en: As you can see, the Overview Navigator provides the best indication of the effectiveness
    of a particular set of signatures. With a large percentage of matched signatures,
    substantial portions of code will be marked as library code and renamed accordingly.
    In the example in [Figure 12-3](ch12s02.html#statically_linked_binary_with_signatures
    "Figure 12-3. Statically linked binary with signatures applied"), it is highly
    likely that the actual application-specific code is concentrated in the far left
    portion of the navigator display.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Overview Navigator提供了特定一组签名有效性的最佳指示。当匹配的签名比例很大时，大量代码将被标记为库代码并相应地重命名。在[图12-3](ch12s02.html#statically_linked_binary_with_signatures
    "图12-3. 应用了签名的静态链接二进制文件")的例子中，实际的应用特定代码很可能集中在navigator显示的左侧远端部分。
- en: There are two points worth remembering when applying signatures. First, signatures
    are useful even when working with a binary that has not been stripped, in which
    case you are using signatures more to help IDA identify library functions than
    to rename those functions. Second, statically linked binaries may be composed
    of several separate libraries, requiring the application of several sets of signatures
    in order to completely identify all library functions. With each additional signature
    application, additional portions of the Overview Navigator will be transformed
    to reflect the discovery of library code. [Figure 12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "Figure 12-4. Static binary with first of several signatures applied") shows one
    such example. In this figure, you see a binary that was statically linked with
    both the C standard library and the OpenSSL^([[79](#ftn.CHP-12-FN-5)]) cryptographic
    library.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用签名时有两个要点值得记住。首先，即使在与未剥离的二进制文件一起工作时，签名也是有用的，在这种情况下，你使用签名更多的是帮助IDA识别库函数，而不是重命名这些函数。其次，静态链接的二进制文件可能由几个独立的库组成，需要应用几组签名才能完全识别所有库函数。随着每次额外的签名应用，Overview
    Navigator的更多部分将被转换以反映库代码的发现。[图12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "图12-4. 应用了第一个几个签名后的静态二进制")显示了这样一个例子。在这个图中，你可以看到一个静态链接了C标准库和OpenSSL^([[79](#ftn.CHP-12-FN-5)])加密库的二进制文件。
- en: '![Static binary with first of several signatures applied](httpatomoreillycomsourcenostarchimages854243.png.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![应用了第一个几个签名后的静态二进制](httpatomoreillycomsourcenostarchimages854243.png.jpg)'
- en: Figure 12-4. Static binary with first of several signatures applied
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4. 应用了第一个几个签名后的静态二进制
- en: Specifically, you see that following application of the appropriate signatures
    for the version of OpenSSL in use in this application, IDA has marked a small
    band (the lighter band toward the left edge of the address range) as library code.
    Statically linked binaries are often created by taking the application code first
    and then appending required libraries to create the resulting executable. Given
    this picture, we can conclude that the memory space to the right of the OpenSSL
    library is likely occupied by additional library code, while the application code
    is most likely in the very narrow band to the left of the OpenSSL library. If
    we continue to apply signatures to the binary shown in [Figure 12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "Figure 12-4. Static binary with first of several signatures applied"), we eventually
    arrive at the display of [Figure 12-5](ch12s02.html#static_binary_following_application_of_s
    "Figure 12-5. Static binary following application of several signatures").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你可以看到在为该应用程序中使用的OpenSSL版本应用适当的签名后，IDA标记了一个小带（地址范围的左侧较亮的带）为库代码。静态链接的二进制文件通常是通过首先取应用程序代码，然后附加所需的库来创建结果的可执行文件。根据这个图，我们可以得出结论，OpenSSL库右侧的内存空间很可能被额外的库代码占用，而应用程序代码最有可能位于OpenSSL库左侧非常狭窄的带中。如果我们继续对[图12-4](ch12s02.html#static_binary_with_first_of_several_sign
    "图12-4. 应用了第一个几个签名后的静态二进制")中显示的二进制文件应用签名，我们最终会到达[图12-5](ch12s02.html#static_binary_following_application_of_s
    "图12-5. 应用了几个签名后的静态二进制")的显示。
- en: '![Static binary following application of several signatures](httpatomoreillycomsourcenostarchimages854245.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![应用了几个签名后的静态二进制](httpatomoreillycomsourcenostarchimages854245.png.jpg)'
- en: Figure 12-5. Static binary following application of several signatures
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5. 应用了几个签名后的静态二进制
- en: In this example, we have applied signatures for *libc*, *libcrypto*, *libkrb5*,
    *libresolv*, and others. In some cases we selected signatures based on strings
    located within the binary; in other cases we chose signatures based on their close
    relationship to other libraries already located within the binary. The resulting
    display continues to show a dark band in the middle of the navigation band and
    a smaller dark band at the extreme left edge of the navigation band. Further analysis
    is required to determine the nature of these remaining nonlibrary portions of
    the binary. In this case we would learn that the wider dark band in the middle
    is part of an unidentified library, while the dark band on the left is the application
    code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为 *libc*、*libcrypto*、*libkrb5*、*libresolv* 以及其他库应用了签名。在某些情况下，我们根据二进制文件中的字符串选择签名；在其他情况下，我们根据它们与二进制文件中已存在的其他库的紧密关系选择签名。结果显示在导航带中间仍然有一个深色带，在导航带最左边的边缘有一个较小的深色带。需要进一步分析以确定这些剩余的非库部分的二进制文件性质。在这种情况下，我们会发现中间较宽的深色带是某个未识别库的一部分，而左边的深色带是应用程序代码。
- en: '* * *'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[78](#CHP-12-FN-4)]) *libc.a* is the version of the C standard library used
    in statically linked binaries on Unix-style systems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[78](#CHP-12-FN-4)]) *libc.a* 是在 Unix 风格系统上用于静态链接二进制文件的 C 标准库版本。
- en: ^([[79](#CHP-12-FN-5)]) See [http://www.openssl.org/](http://www.openssl.org/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[79](#CHP-12-FN-5)]) 请参阅 [http://www.openssl.org/](http://www.openssl.org/).
- en: Creating FLIRT Signature Files
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 FLIRT 签名文件
- en: As we discussed previously, it is simply impractical for IDA to ship with signature
    files for every static library in existence. In order to provide IDA users with
    the tools and information necessary to create their own signatures, Hex-Rays distributes
    the Fast Library Acquisition for Identification and Recognition (FLAIR) tool set.
    The FLAIR tools are made available on your IDA distribution CD or via download
    from the Hex-Rays website^([[80](#ftn.CHP-12-FN-6)]) for authorized customers.
    Like several other IDA add-ons, the FLAIR tools are distributed in a Zip file.
    Hex-Rays does not necessarily release a new version of the FLAIR tools with each
    version of IDA, so you should use the most recent version of FLAIR that does not
    exceed your version of IDA.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，对于 IDA 来说，为现有的每个静态库提供签名文件是不切实际的。为了向 IDA 用户提供创建他们自己的签名所需的工具和信息，Hex-Rays
    分发了快速库获取识别工具集 (FLAIR)。FLAIR 工具对授权客户在 IDA 分发 CD 上或通过 Hex-Rays 网站下载提供^([[80](#ftn.CHP-12-FN-6)])。像其他几个
    IDA 扩展一样，FLAIR 工具以 Zip 文件的形式分发。Hex-Rays 并不一定在每个 IDA 版本中都发布 FLAIR 工具的新版本，因此您应该使用不超过您
    IDA 版本的最新 FLAIR 版本。
- en: 'Installation of the FLAIR utilities is a simple matter of extracting the contents
    of the associated Zip file, though we highly recommend that you create a dedicated
    *flair* directory as the destination because the Zip file is not organized with
    a top-level directory. Inside the FLAIR distribution you will find several text
    files that constitute the documentation for the FLAIR tools. Files of particular
    interest include these:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIR 工具的安装只需提取相关 Zip 文件的文件内容即可，尽管我们强烈建议您创建一个专门的 *flair* 目录作为目标，因为 Zip 文件没有组织成顶层目录。在
    FLAIR 分发中，您将找到几个构成 FLAIR 工具文档的文本文件。特别感兴趣的文件包括这些：
- en: '**readme.txt**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**readme.txt**'
- en: This is a top-level overview of the signature-creation process.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对签名创建过程的顶层概述。
- en: '**plb.txt**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**plb.txt**'
- en: This file describes the use of the static library parser, *plb.exe*. Library
    parsers are discussed in more detail in [Creating Pattern Files](ch12s03.html#creating_pattern_files
    "Creating Pattern Files") in [Creating Pattern Files](ch12s03.html#creating_pattern_files
    "Creating Pattern Files").
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件描述了静态库解析器 *plb.exe* 的使用。库解析器在 [创建模式文件](ch12s03.html#creating_pattern_files
    "创建模式文件") 中有更详细的讨论。
- en: '**pat.txt**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**pat.txt**'
- en: This file details the format of pattern files, which represent the first step
    in the signature-creation process. Pattern files are also described in [Creating
    Pattern Files](ch12s03.html#creating_pattern_files "Creating Pattern Files") in
    [Creating Pattern Files](ch12s03.html#creating_pattern_files "Creating Pattern
    Files").
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件详细说明了模式文件的格式，它是签名创建过程的第一步。模式文件也在 [创建模式文件](ch12s03.html#creating_pattern_files
    "创建模式文件") 中有描述。
- en: '**sigmake.txt**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**sigmake.txt**'
- en: This file describes the use of *sigmake.exe* for generating *.sig* files from
    pattern files. Please refer to [Creating Signature Files](ch12s03.html#creating_signature_files
    "Creating Signature Files") in [Creating Signature Files](ch12s03.html#creating_signature_files
    "Creating Signature Files") for more details.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件描述了使用`*sigmake.exe*`从模式文件生成`*.sig`文件的使用方法。请参阅[创建签名文件](ch12s03.html#creating_signature_files
    "创建签名文件")以获取更多详细信息。
- en: Additional top-level content of interest includes the *bin* directory, which
    contains all of the FLAIR tools executable files, and the *startup* directory,
    which contains pattern files for common startup sequences associated with various
    compilers and their associated output file types (PE, ELF, and so on). Prior to
    version 6.1, the FLAIR tools area is available for Windows only; however, the
    resulting signature files may be used with all IDA variants (Windows, Linux, and
    OS X).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的顶级内容包括`*bin*`目录，其中包含所有FLAIR工具的可执行文件，以及`*startup*`目录，其中包含与各种编译器及其相关输出文件类型（PE、ELF等）相关联的常见启动序列的模式文件。在版本6.1之前，FLAIR工具区域仅适用于Windows；然而，生成的签名文件可以与所有IDA变体（Windows、Linux和OS
    X）一起使用。
- en: Signature-Creation Overview
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名创建概述
- en: The basic process for creating signatures files does not seem complicated, as
    it boils down to four simple-sounding steps.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建签名文件的基过程似乎并不复杂，因为它归结为四个听起来简单的步骤。
- en: Obtain a copy of the static library for which you wish to create a signature
    file.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取你希望为其创建签名文件的静态库的副本。
- en: Utilize one of the FLAIR parsers to create a pattern file for the library.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用FLAIR解析器之一为库创建一个模式文件。
- en: Run *sigmake.exe* to process the resulting pattern file and generate a signature
    file.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`*sigmake.exe*`来处理生成的模式文件并生成签名文件。
- en: Install the new signature file in IDA by copying it to *<IDADIR>/sig*.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将其复制到`*<IDADIR>/sig*`来在IDA中安装新的签名文件。
- en: Unfortunately, in practice, only the last step is as easy as it sounds. In the
    following sections, we discuss the first three steps in more detail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在实践中，只有最后一步像听起来那么简单。在接下来的几节中，我们将更详细地讨论前三个步骤。
- en: Identifying and Acquiring Static Libraries
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别和获取静态库
- en: The first step in the signature-generation process is to locate a copy of the
    static library for which you wish to generate signatures. This can pose a bit
    of a challenge for a variety of reasons. The first obstacle is to determine which
    library you actually need. If the binary you are analyzing has not been stripped,
    you might be lucky enough to have actual function names available in your disassembly,
    in which case an Internet search will probably provide several pointers to likely
    candidates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 签名生成过程的第一步是找到你希望为其生成签名的静态库的副本。这可能会因为各种原因而带来一些挑战。第一个障碍是确定你实际上需要哪个库。如果你正在分析的二进制文件尚未去符号，你可能很幸运，在反汇编中实际有函数名可用，在这种情况下，网络搜索可能会提供几个可能的候选者的线索。
- en: 'Stripped binaries are not quite as forthcoming regarding their origins. Lacking
    function names, you may find that a good `strings` search may yield sufficiently
    unique strings to allow for library identification, such as the following, which
    is a dead giveaway:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 去掉符号的二进制文件在提供其来源方面并不十分乐意。由于缺少函数名，你可能发现一个好的`strings`搜索可以产生足够独特的字符串，从而允许进行库识别，例如以下内容，这是一个明显的线索：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Copyright notices and error strings are often sufficiently unique that once
    again you can use an Internet search to narrow your candidates. If you choose
    to run `strings` from the command line, remember to use the `-a` option to force
    `strings` to scan the entire binary; otherwise you may miss some potentially useful
    string data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 版权声明和错误字符串通常足够独特，因此你还可以使用网络搜索来缩小候选者范围。如果你选择从命令行运行`strings`，请记住使用`-a`选项强制`strings`扫描整个二进制文件；否则，你可能会错过一些可能有用的字符串数据。
- en: In the case of open source libraries, you are likely to find source code readily
    available. Unfortunately, while the source code may be useful in helping you understand
    the behavior of the binary, you cannot use it to generate your signatures. It
    might be possible to use the source to build your own version of the static library
    and then use that version in the signature-generation process. However, in all
    likelihood, variations in the build process will result in enough differences
    between the resulting library and the library you are analyzing that any signatures
    you generate will not be terribly accurate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源库，你可能会发现源代码很容易获得。不幸的是，虽然源代码可能有助于你理解二进制文件的行为，但你不能用它来生成你的签名。可能可以使用源代码构建你自己的静态库版本，然后在该版本中用于签名生成过程。然而，很可能会在构建过程中的变化导致生成的库与你要分析的库之间有足够的不同，以至于你生成的任何签名都不会非常准确。
- en: 'The best option is to attempt to determine the exact origin of the binary in
    question. By this we mean the exact operating system, operating system version,
    and distribution (if applicable). Given this information, the best option for
    creating signatures is to copy the libraries in question from an identically configured
    system. Naturally, this leads to the next challenge: Given an arbitrary binary,
    on what system was it created? A good first step is to use the `file` utility
    to obtain some preliminary information about the binary in question. In [Chapter 2](ch02.html
    "Chapter 2. Reversing and Disassembly Tools") we saw some sample output from `file`.
    In several cases, this output was sufficient to provide likely candidate systems.
    The following is just one example of very specific output from `file`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳选项是尝试确定所讨论的二进制文件的精确来源。我们这里指的是确切的操作系统、操作系统版本和发行版（如果适用）。有了这些信息，创建签名的最佳选项是从一个配置相同的系统中复制相关的库。自然地，这导致下一个挑战：给定一个任意的二进制文件，它在什么系统上创建的？一个很好的第一步是使用`file`实用程序来获取有关所讨论的二进制文件的一些初步信息。在[第2章](ch02.html
    "第2章。逆向和反汇编工具")中，我们看到了`file`的一些示例输出。在几个案例中，这个输出足以提供可能的候选系统。以下是从`file`输出的一个非常具体的例子：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case we might head straight to a FreeBSD 8.0 system and track down
    *libc.a* for starters. The following example is somewhat more ambiguous, however:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会直接转向一个FreeBSD 8.0系统，并首先追踪*libc.a*。然而，以下例子有些模糊不清：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We appear to have narrowed the source of the file to a Linux system, which,
    given the abundance of available Linux distributions, is not saying much. Turning
    to `strings` we find the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们似乎已经缩小了文件的来源到一个Linux系统，考虑到有大量的Linux发行版，这并没有说太多。转向`strings`，我们发现以下内容：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the search has been narrowed to Red Hat distributions (or derivatives)
    that shipped with gcc version 4.5.1\. GCC tags such as this are not uncommon in
    binaries compiled using gcc, and fortunately for us, they survive the stripping
    process and remain visible to `strings`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，搜索已经缩小到带有gcc版本4.5.1的Red Hat发行版（或衍生版）。在用gcc编译的二进制文件中，这样的GCC标签并不罕见，而且幸运的是，它们在剥离过程中幸存下来，并且对`strings`可见。
- en: Keep in mind that the `file` utility is not the be all and end all in file identification.
    The following output demonstrates a simple case in which `file` seems to know
    the type of the file being examined but for which the output is rather nonspecific.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`file`实用程序并不是文件识别的全部。以下输出演示了一个简单的情况，其中`file`似乎知道正在检查的文件类型，但输出相当不具体。
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example was taken from a Solaris 10 x86 system. Here again, the `strings`
    utility might be useful in pinpointing this fact.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是从一个Solaris 10 x86系统取出的。在这里，`strings`实用程序可能有助于确定这一事实。
- en: Creating Pattern Files
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模式文件
- en: 'At this point you should have one or more libraries for which you wish to create
    signatures. The next step is to create a pattern file for each library. Pattern
    files are created using an appropriate FLAIR parser utility. Like executable files,
    library files are built to various file format specifications. FLAIR provides
    parsers for several popular library file formats. As detailed in FLAIR’s *readme.txt*
    file, the following parsers can be found in FLAIR’s *bin* directory:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该已经有一到多个库，你希望为它们创建签名。下一步是为每个库创建一个模式文件。模式文件是通过使用适当的FLAIR解析器工具创建的。与可执行文件一样，库文件是根据各种文件格式规范构建的。FLAIR为几种流行的库文件格式提供了解析器。正如FLAIR的*readme.txt*文件中详细说明的，以下解析器可以在FLAIR的*bin*目录中找到：
- en: '**plb.exe/plb**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**plb.exe/plb**'
- en: Parser for OMF libraries (commonly used by Borland compilers)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OMF 库解析器（通常由 Borland 编译器使用）
- en: '**pcf.exe/pcf**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**pcf.exe/pcf**'
- en: Parser for COFF libraries (commonly used by Microsoft compilers)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: COFF 库解析器（通常由 Microsoft 编译器使用）
- en: '**pelf.exe/pelf**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**pelf.exe/pelf**'
- en: Parser for ELF libraries (found on many Unix systems)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ELF 库解析器（在许多 Unix 系统上找到）
- en: '**ppsx.exe/ppsx**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**ppsx.exe/ppsx**'
- en: Parser for Sony PlayStation PSX libraries
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Sony PlayStation PSX 库解析器
- en: '**ptmobj.exe/ptmobj**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**ptmobj.exe/ptmobj**'
- en: Parser for TriMedia libraries
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: TriMedia 库解析器
- en: '**pomf166.exe/pomf166**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**pomf166.exe/pomf166**'
- en: Parser for Kiel OMF 166 object files
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kiel OMF 166 对象文件解析器
- en: 'To create a pattern file for a given library, specify the parser that corresponds
    to the library’s format, the name of the library you wish to parse, and the name
    of the resulting pattern file that should be generated. For a copy of *libc.a*
    from a FreeBSD 8.0 system, you might use the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要为给定的库创建一个模式文件，请指定与库格式相对应的解析器、您希望解析的库的名称以及应生成的结果模式文件的名称。对于来自 FreeBSD 8.0 系统的
    *libc.a* 的副本，您可能使用以下命令：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the parser reports the file that was parsed (*libc.a*), the number of
    functions that were skipped (1),^([[81](#ftn.CHP-12-FN-7)]) and the number of
    signature patterns that were generated (1089). Each parser accepts a slightly
    different set of command-line options documented only through the parser’s usage
    statement. Executing a parser with no arguments displays the list of command-line
    options accepted by that parser. The *plb.txt* file contains more detailed information
    on the options accepted by the *plb* parser. This file is a good basic source
    of information, since other parsers accept many of the options it describes as
    well. In many cases, simply naming the library to be parsed and the pattern file
    to be generated is sufficient.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，解析器报告了解析的文件（*libc.a*）、跳过的函数数量（1）^([[81](#ftn.CHP-12-FN-7)）和生成的签名模式数量（1089）。每个解析器接受一组略有不同的命令行选项，这些选项仅在解析器的用法说明中进行了文档化。不带参数执行解析器将显示该解析器接受的命令行选项列表。*plb.txt*
    文件包含有关 *plb* 解析器接受的选项的更详细信息。该文件是很好的基本信息来源，因为其他解析器也接受其中描述的许多选项。在许多情况下，只需指定要解析的库和要生成的模式文件就足够了。
- en: 'A pattern file is a text file that contains, one per line, the extracted patterns
    that represent functions within a parsed library. A few lines from the pattern
    file created previously are shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 模式文件是一个文本文件，其中每行包含一个表示解析库中函数的提取模式。以下展示了之前创建的模式文件中的几行：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The format of an individual pattern is described in FLAIR’s *pat.txt* file.
    In a nutshell, the first portion of a pattern lists the initial byte sequence
    of the function to a maximum of 32 bytes. Allowance is made for bytes that may
    vary as a result of relocation entries. Such bytes are displayed using two dots.
    Dots are also used to fill the pattern out to 64 characters^([[82](#ftn.CHP-12-FN-8)])
    when a function is shorter than 32 bytes (as `_ffs` is in the previous code).
    Beyond the initial 32 bytes, additional information is recorded to provide more
    precision in the signature-matching process. Additional information encoded into
    each pattern line includes a CRC16^([[83](#ftn.CHP-12-FN-9)]) value computed over
    a portion of the function, the length of the function in bytes, and a list of
    symbol names referenced by the function. In general, longer functions that reference
    many other symbols yield more complex pattern lines. In the file *libc_FreeBSD80.pat*
    generated previously, some pattern lines exceed 20,000 characters in length.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 单个模式的格式在 FLAIR 的 *pat.txt* 文件中描述。简而言之，模式的第一个部分列出了函数的初始字节序列，最多 32 字节。考虑到由于重定位条目而可能变化的字节，这些字节使用两个点表示。当函数小于
    32 字节（如前代码中的 `_ffs`）时，也使用点来填充模式至 64 个字符^([[82](#ftn.CHP-12-FN-8)])。在最初的 32 字节之后，记录了额外的信息，以在签名匹配过程中提供更高的精度。编码到每个模式行中的额外信息包括对函数部分计算出的
    CRC16^([[83](#ftn.CHP-12-FN-9)]) 值、函数的字节数以及函数引用的符号名称列表。一般来说，引用许多其他符号的较长的函数会产生更复杂的模式行。在之前生成的
    *libc_FreeBSD80.pat* 文件中，一些模式行的长度超过 20,000 个字符。
- en: Several third-party programmers have created utilities designed to generate
    patterns from existing IDA databases. One such utility is IDB_2_PAT,^([[84](#ftn.CHP-12-FN-10)])
    an IDA plug-in written by J.C. Roberts that is capable of generating patterns
    for one or more functions in an existing database. Utilities such as these are
    useful if you expect to encounter similar code in additional databases and have
    no access to the original library files used to create the binary being analyzed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几位第三方程序员创建了旨在从现有的 IDA 数据库生成模式的工具。其中之一是 IDB_2_PAT，^([[84](#ftn.CHP-12-FN-10)])，这是一个由
    J.C. Roberts 编写的 IDA 插件，能够从现有数据库中为一个或多个函数生成模式。如果你预计将在其他数据库中遇到类似的代码，但没有访问创建被分析二进制文件的原版库文件的权限，这类工具非常有用。
- en: Creating Signature Files
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建签名文件
- en: Once you have created a pattern file for a given library, the next step in the
    signature-creation process is to generate a *.sig* file suitable for use with
    IDA. The format of an IDA signature file is substantially different from that
    of a pattern file. Signature files utilize a proprietary binary format designed
    both to minimize the amount of space required to represent all of the information
    present in a pattern file and to allow for efficient matching of signatures against
    actual database content. A high-level description of the structure of a signature
    file is available on the Hex-Rays website.^([[85](#ftn.CHP-12-FN-11)])
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为某个库创建了一个模式文件，签名创建过程的下一步就是生成一个适合与 IDA 一起使用的 *.sig* 文件。IDA 签名文件的格式与模式文件有显著不同。签名文件使用一种专有二进制格式，旨在最小化表示模式文件中所有信息的空间需求，并允许对签名与实际数据库内容进行高效匹配。关于签名文件结构的详细描述可在
    Hex-Rays 网站上找到.^([[85](#ftn.CHP-12-FN-11)])
- en: 'FLAIR’s *sigmake* utility is used to create signature files from pattern files.
    By splitting pattern generation and signature generation into two distinct phases,
    the signature-generation process is completely independent of the pattern-generation
    process, which allows for the use of third-party pattern generators. In its simplest
    form, signature generation takes place by using *sigmake* to parse a *.pat* file
    and create a *.sig* file, as shown here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIR 的 *sigmake* 工具用于从模式文件创建签名文件。通过将模式生成和签名生成分为两个不同的阶段，签名生成过程完全独立于模式生成过程，这允许使用第三方模式生成器。在最简单的形式中，签名生成是通过使用
    *sigmake* 解析 *.pat* 文件并创建 *.sig* 文件来实现的，如下所示：
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If all goes well, a *.sig* file is generated and ready to install into *<IDADIR>/sig*.
    However, the process seldom runs that smoothly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，将生成 *.sig* 文件并准备好安装到 *<IDADIR>/sig*。然而，这个过程很少如此顺利。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `sigmake` documentation file, *sigmake.txt*, recommends that signature filenames
    follow the MS-DOS 8.3 name-length convention. This is not a hard-and-fast requirement,
    however. When longer filenames are used, only the first eight characters of the
    base filename are displayed in the signature-selection dialog.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigmake` 文档文件 *sigmake.txt* 建议签名文件名应遵循 MS-DOS 8.3 的命名长度约定。但这并不是一个严格的要求。当使用较长的文件名时，签名选择对话框中仅显示基本文件名的第一个八个字符。'
- en: Signature generation is often an iterative process, as it is during this phase
    when *collisions* must be handled. A collision occurs anytime two functions have
    identical patterns. If collisions are not resolved in some manner, it is not possible
    to determine which function is actually being matched during the signature-application
    process. Therefore, `sigmake` must be able to resolve each generated signature
    to exactly one function name. When this is not possible, based on the presence
    of identical patterns for one or more functions, `sigmake` refuses to generate
    a *.sig* file and instead generates an *exclusions file* (*.exc*). A more typical
    first pass using `sigmake` and a new *.pat* file (or set of *.pat* files) might
    yield the following.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 签名生成通常是一个迭代过程，因为在这一阶段必须处理 *碰撞*。碰撞发生在两个函数具有相同模式的情况下。如果以某种方式未解决碰撞，则在签名应用过程中无法确定实际匹配的是哪个函数。因此，`sigmake`
    必须能够将每个生成的签名解析为确切的一个函数名。当这不可能实现时，基于一个或多个函数存在相同模式的情况，`sigmake` 拒绝生成 *.sig* 文件，并生成一个
    *排除文件* (*.exc*)。使用 `sigmake` 和新的 *.pat* 文件（或一组 *.pat* 文件）的典型第一次尝试可能产生以下结果。
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The documentation being referred to is *sigmake.txt*, which describes the use
    of `sigmake` and the collision-resolution process. In reality, each time `sigmake`
    is executed, it searches for a corresponding exclusions file that might contain
    information on how to resolve any collisions that `sigmake` may encounter while
    processing the named pattern file. In the absence of such an exclusions file,
    and when collisions occur, `sigmake` generates such an exclusions file rather
    than a signature file. In the previous example, we would find a newly created
    file named *libc_FreeBSD80.exc*. When first created, exclusions files are text
    files that detail the conflicts that `sigmake` encountered while processing the
    pattern file. The exclusions file must be edited to provide `sigmake` with guidance
    as to how it should resolve the conflicting patterns. The general process for
    editing an exclusions file follows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所指的文档是`*sigmake.txt*`，它描述了`sigmake`的使用和冲突解决过程。实际上，每次执行`sigmake`时，它都会搜索一个可能包含有关如何解决`sigmake`在处理命名模式文件时可能遇到的任何冲突信息的排除文件。如果没有这样的排除文件，并且发生冲突，`sigmake`将生成这样的排除文件而不是签名文件。在前面的例子中，我们会找到一个新创建的名为`*libc_FreeBSD80.exc*`的文件。当首次创建时，排除文件是文本文件，详细说明了`sigmake`在处理模式文件时遇到的冲突。必须编辑排除文件以向`sigmake`提供有关如何解决冲突模式的指导。编辑排除文件的一般过程如下。
- en: 'When generated by `sigmake`, all exclusions files begin with the following
    lines:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当由`sigmake`生成时，所有排除文件都以以下几行开始：
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The intent of these lines it to remind you what to do to resolve collisions
    before you can successfully generate signatures. The most important thing to do
    is delete the four lines that begin with semicolons, or `sigmake` will fail to
    parse the exclusions file during subsequent execution. The next step is to inform
    `sigmake` of your desire for collision resolution. A few lines extracted from
    *libc_FreeBSD80.exc* appear here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行的目的是在您成功生成签名之前提醒您如何解决冲突。最重要的事情是删除以分号开始的四行，否则`sigmake`将在后续执行中无法解析排除文件。下一步是通知`sigmake`您希望解决冲突的愿望。以下是从`*libc_FreeBSD80.exc*`中提取的一些行：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These lines detail three separate collisions. In this case, we are being told
    that the function `index` is indistinguishable from `strchr`, `rindex` has the
    same signature as `strrchr`, and `flsl` collides with `fls`. If you are familiar
    with any of these functions, this result may not surprise you, as the colliding
    functions are essentially identical (for example, `index` and `strchr` perform
    the same action).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行详细说明了三个不同的冲突。在这种情况下，我们被告知函数`index`与`strchr`不可区分，`rindex`与`strrchr`具有相同的签名，而`flsl`与`fls`冲突。如果您熟悉这些函数中的任何一个，这个结果可能不会让您感到惊讶，因为冲突的函数基本上是相同的（例如，`index`和`strchr`执行相同的操作）。
- en: 'In order to leave you in control of your own destiny, `sigmake` expects you
    to designate no more than one function in each group as the proper function for
    the associated signature. You select a function by prefixing the name with a plus
    character (`+`) if you want the name applied anytime the corresponding signature
    is matched in a database or a minus character (`-`) if you simply want a comment
    added to the database whenever the corresponding signature is matched. If you
    do not want any names applied when the corresponding signature is matched in a
    database, then you do not add any characters. The following listing represents
    one possible way to provide a valid resolution for the three collisions noted
    previously:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您能够掌控自己的命运，`sigmake`期望您在每个组中指定不超过一个函数作为相关签名的正确函数。如果您想使名称在数据库中匹配相应签名时被应用，可以通过在名称前加上加号字符（`+`）来选择一个函数；如果您只想在数据库中匹配相应签名时添加注释，则使用减号字符（`-`）。如果您不想在数据库中匹配相应签名时应用任何名称，则不需要添加任何字符。以下列表表示为之前提到的三个冲突提供有效解决方法的一种可能方式：
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case we elect to use the name `index` whenever the first signature
    is matched, do nothing at all when the second signature is matched, and have a
    comment about `fls` added when the third signature is matched. The following points
    are useful when attempting to resolve collisions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择在第一个签名匹配时使用名称`index`，在第二个签名匹配时什么都不做，并在第三个签名匹配时添加关于`fls`的注释。在尝试解决冲突时，以下几点是有用的：
- en: To perform minimal collision resolution, simply delete the four commented lines
    at the beginning of the exclusions file.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行最小化冲突解决，只需删除排除文件开头的四行注释即可。
- en: Never add a `+/-` to more than one function in a collision group.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 永远不要在冲突组中的多个函数前添加 `+/-`。
- en: If a collision group contains only a single function, *do not* add a `+/-` in
    front of that function; simply leave it alone.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果冲突组中只有一个函数，*不要* 在该函数前添加 `+/-`；只需让它保持原样。
- en: Subsequent failures of `sigmake` cause data, including comment lines, to be
    appended to any existing exclusions file. This extra data should be removed and
    the original data corrected (if the data was correct, `sigmake` would not have
    failed a second time) before rerunning `sigmake`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sigmake` 的后续失败会导致数据（包括注释行）被附加到任何现有的排除文件中。在重新运行 `sigmake` 之前，应该删除这些额外数据并更正原始数据（如果数据是正确的，`sigmake`
    不会在第二次尝试时失败）。'
- en: 'Once you have made appropriate changes to your exclusions file, you must save
    the file and rerun `sigmake` using the same command-line arguments that you used
    initially. The second time through, `sigmake` should locate, and abide by, your
    exclusions file, resulting in the successful generation of a *.sig* file. Successful
    operation of `sigmake` is noted by the lack of error messages and the presence
    of a *.sig* file, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您对排除文件进行了适当的更改，您必须保存文件并使用最初使用的相同命令行参数重新运行 `sigmake`。第二次运行时，`sigmake` 应该能够定位并遵守您的排除文件，从而成功生成一个
    *.sig* 文件。`sigmake` 的成功运行可以通过没有错误消息和存在 *.sig* 文件来识别，如下所示：
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After a signature file has been successfully generated, you make it available
    to IDA by copying it to your *<IDADIR>/sig* directory. Then your new signatures
    are available using File ▸ Load File ▸ FLIRT Signature File.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功生成签名文件后，您可以通过将其复制到您的 *<IDADIR>/sig* 目录来使它可供 IDA 使用。然后您的新签名可以通过文件 ▸ 加载文件 ▸
    FLIRT 签名文件来使用。
- en: 'Note that we have purposefully glossed over all of the options that can be
    supplied to both the pattern generators and `sigmake`. A rundown of available
    options is provided in *plb.txt* and *sigmake.txt*. The only option we will make
    note of is the `-n` option used with `sigmake`. This option allows you to embed
    a descriptive name inside a generated signature file. This name is displayed during
    the signature-selection process (see [Figure 12-1](ch12s02.html#flirt_signature_selection
    "Figure 12-1. FLIRT signature selection")), and it can be very helpful when sorting
    through the list of available signatures. The following command line embeds the
    name string “FreeBSD 8.0 C standard library” within the generated signature file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们故意省略了可以提供给模式生成器和 `sigmake` 的所有选项。有关可用选项的概述请参阅 *plb.txt* 和 *sigmake.txt*。我们将注意的唯一选项是
    `sigmake` 中使用的 `-n` 选项。此选项允许您在生成的签名文件中嵌入描述性名称。此名称在签名选择过程中显示（参见 [图 12-1](ch12s02.html#flirt_signature_selection
    "图 12-1. FLIRT 签名选择"))，并且在整理可用签名列表时非常有帮助。以下命令行将名称字符串“FreeBSD 8.0 C 标准库”嵌入到生成的签名文件中：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As an alternative, library names can be specified using directives within exclusion
    files. However, since exclusion files may not be required in all signature-generation
    cases, the command-line option is generally more useful. For further details,
    please refer to *sigmake.txt*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，可以使用排除文件中的指令指定库名称。然而，由于在所有签名生成情况下可能不需要排除文件，因此命令行选项通常更有用。有关更多详细信息，请参阅 *sigmake.txt*。
- en: Startup Signatures
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动签名
- en: IDA also recognizes a specialized form of signatures called *startup signatures*.
    Startup signatures are applied when a binary is first loaded into a database in
    an attempt to identify the compiler that was used to create the binary. If IDA
    can identify the compiler used to build a binary, then additional signature files,
    associated with the identified compiler, are automatically loaded during the initial
    analysis of the binary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 还识别一种称为 *启动签名* 的特殊签名形式。当二进制文件首次加载到数据库中时，会应用启动签名，以尝试识别用于创建二进制文件的编译器。如果 IDA
    能够识别用于构建二进制文件的编译器，那么在二进制文件的初始分析过程中，将自动加载与识别的编译器相关的附加签名文件。
- en: Given that the compiler type is initially unknown when a file is first loaded,
    startup signatures are grouped by and selected according to the file type of the
    binary being loaded. For example, if a Windows PE binary is being loaded, then
    startup signatures specific to PE binaries are loaded in an effort to determine
    the compiler used to build the PE binary in question.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在文件首次加载时编译器类型是未知的，启动签名根据正在加载的二进制文件的文件类型进行分组和选择。例如，如果正在加载 Windows PE 二进制文件，那么将加载特定于
    PE 二进制文件的启动签名，以确定用于构建相关 PE 二进制文件的编译器。
- en: In order to generate startup signatures, `sigmake` processes patterns that describe
    the startup routine^([[86](#ftn.CHP-12-FN-12)]) generated by various compilers
    and groups the resulting signatures into a single type-specific signature file.
    The `startup` directory in the FLAIR distribution contains the startup patterns
    used by IDA, along with the script, *startup.bat*, used to create the corresponding
    startup signatures from those patterns. Refer to *startup.bat* for examples of
    using `sigmake` to create startup signatures for a specific file format.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成启动签名，`sigmake` 处理描述由各种编译器生成的启动例程^([[86](#ftn.CHP-12-FN-12))) 的模式，并将生成的签名分组到一个单一类型的签名文件中。FLAIR分发的
    *startup* 目录包含IDA使用的启动模式，以及用于从这些模式创建相应启动签名的脚本 *startup.bat*。请参阅 *startup.bat*
    以获取使用 `sigmake` 为特定文件格式创建启动签名的示例。
- en: In the case of PE files, you would notice several *pe_*.pat* files in the startup
    directory that describe startup patterns used by several popular Windows compilers,
    including *pe_vc.pat* for Visual Studio patterns and *pe_gcc.pat* for Cygwin/gcc
    patterns. If you wish to add additional startup patterns for PE files, you would
    need to add them to one of the existing PE pattern files or create a new pattern
    file with a `pe_` prefix in order for the startup signature-generation script
    to properly find your patterns and incorporate them into the newly generated PE
    signatures.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在PE文件的情况下，你会在启动目录中注意到几个 *pe_*.pat* 文件，这些文件描述了几个流行的Windows编译器使用的启动模式，包括用于Visual
    Studio模式的 *pe_vc.pat* 和用于Cygwin/gcc模式的 *pe_gcc.pat*。如果你希望为PE文件添加额外的启动模式，你需要将它们添加到现有的PE模式文件之一，或者创建一个以
    `pe_` 前缀的新模式文件，以便启动签名生成脚本能够正确地找到你的模式并将它们纳入新生成的PE签名中。
- en: One last note about startup patterns concerns their format, which unfortunately
    is slightly different from patterns generated for library functions. The difference
    lies in the fact that a startup pattern line is capable of relating the pattern
    to additional sets of signatures that should also be applied if a match against
    the pattern is made. Other than the example startup patterns included in the *startup*
    directory, the format of a startup pattern is not documented in any of the text
    files included with FLAIR.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于启动模式的一个注意事项是它们的格式，不幸的是，它与为库函数生成的模式略有不同。这种差异在于启动模式行能够将模式与额外的签名集相关联，如果与模式匹配，也应应用这些签名集。除了包含在
    *startup* 目录中的示例启动模式之外，启动模式的格式在FLAIR提供的任何文本文件中都没有文档说明。
- en: '* * *'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[80](#CHP-12-FN-6)]) The current version is *flair61.zip* and is available
    here: [http://www.hex-rays.com/idapro/ida/flair61.zip](http://www.hex-rays.com/idapro/ida/flair61.zip).
    A username and password supplied by Hex-Rays are required to access the download.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[80](#CHP-12-FN-6))) 当前版本是 *flair61.zip*，可在以下链接获取：[http://www.hex-rays.com/idapro/ida/flair61.zip](http://www.hex-rays.com/idapro/ida/flair61.zip)。要访问下载，需要Hex-Rays提供的用户名和密码。
- en: ^([[81](#CHP-12-FN-7)]) The plb and pcf parsers may skip some functions depending
    on the command-line options supplied to the parsers and the structure of the library
    being parsed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[81](#CHP-12-FN-7)]) plb和pcf解析器可能会根据提供给解析器的命令行选项和正在解析的库的结构跳过一些函数。
- en: ^([[82](#CHP-12-FN-8)]) At two characters per byte, 64 hexadecimal characters
    are required to display the contents of 32 bytes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[82](#CHP-12-FN-8))) 每字节两个字符，显示32个字节的内容需要64个十六进制字符。
- en: ^([[83](#CHP-12-FN-9)]) This is a 16-bit cyclic redundancy check value. The
    CRC16 implementation utilized for pattern generation is included with the FLAIR
    tool distribution in the file *crc16.cpp*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[83](#CHP-12-FN-9))) 这是一个16位循环冗余校验值。用于模式生成的CRC16实现包含在FLAIR工具分发的 *crc16.cpp*
    文件中。
- en: ^([[84](#CHP-12-FN-10)]) See [http://www.openrce.org/downloads/details/26/IDB_2_PAT](http://www.openrce.org/downloads/details/26/IDB_2_PAT).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[84](#CHP-12-FN-10))) 请参阅 [http://www.openrce.org/downloads/details/26/IDB_2_PAT](http://www.openrce.org/downloads/details/26/IDB_2_PAT)。
- en: ^([[85](#CHP-12-FN-11)]) See [http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[85](#CHP-12-FN-11)]) 请参阅 [http://www.hex-rays.com/idapro/flirt.htm](http://www.hex-rays.com/idapro/flirt.htm)。
- en: ^([[86](#CHP-12-FN-12)]) The startup routine is generally designated as the
    program’s entry point. In a C/C++ program, the purpose of the startup routine
    is to initialize the program’s environment prior to passing control to the `main`
    function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[86](#CHP-12-FN-12))) 启动例程通常被指定为程序的入口点。在C/C++程序中，启动例程的目的是在将控制权传递给 `main`
    函数之前初始化程序的环境。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated library code identification is an essential capability that significantly
    reduces the amount of time required to analyze statically linked binaries. With
    its FLIRT and FLAIR capabilities, IDA makes such automated code recognition not
    only possible but extensible by allowing users to create their own library signatures
    from existing static libraries. Familiarity with the signature-generation process
    is an essential skill for anyone who expects to encounter statically linked binaries.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自动库代码识别是一个基本功能，它可以显著减少分析静态链接二进制文件所需的时间。凭借其FLIRT和FLAIR功能，IDA不仅使这种自动代码识别成为可能，而且还允许用户从现有的静态库中创建自己的库签名，从而使其可扩展。熟悉签名生成过程对于预期会遇到静态链接二进制文件的人来说是一项基本技能。
- en: Chapter 13. Extending IDA’s Knowledge
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。扩展IDA的知识
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: By now it should be clear that a high-quality disassembly is much more than
    a list of mnemonics and operands derived from a sequence of bytes. In order to
    make a disassembly useful, it is important to augment the disassembly with information
    derived from the processing of various API-related data such as function prototypes
    and standard datatypes. In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data
    Structures") we discussed IDA’s handling of data structures, including how to
    access standard API data structures and how to define your own custom data structures.
    In this chapter, we continue our discussion of extending IDA’s knowledge by examining
    the use of IDA’s `idsutils` and `loadint` utilities. These utilities are available
    on your IDA distribution CD or via download at the Hex-Rays download site.^([[87](#ftn.CHP-13-FN-1)])
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该已经很清楚，高质量的反汇编远不止是从字节序列中派生出的助记符和操作数列表。为了使反汇编变得有用，重要的是要使用从各种API相关数据处理中获取的信息来增强反汇编，例如函数原型和标准数据类型。在[第8章](ch08.html
    "第8章。数据类型和数据结构")中，我们讨论了IDA处理数据结构的方法，包括如何访问标准API数据结构和如何定义自己的自定义数据结构。在本章中，我们继续通过检查IDA的`idsutils`和`loadint`实用程序的使用来扩展IDA的知识。这些实用程序可在您的IDA分发CD上找到，或者通过Hex-Rays下载站点下载。[^([[87](#ftn.CHP-13-FN-1))]]
- en: Augmenting Function Information
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强函数信息
- en: 'IDA derives its knowledge of functions from two sources: type library (*.til*)
    files and IDS utilities (*.ids*) files. During the initial analysis phase, IDA
    uses information stored in these files to both improve the accuracy of the disassembly
    and make the disassembly more readable. It does so by incorporating function parameter
    names and types as well as comments that have been associated with various library
    functions.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: IDA从两个来源获取其关于函数的知识：类型库 (*.til*) 文件和IDS实用程序 (*.ids*) 文件。在初始分析阶段，IDA使用存储在这些文件中的信息来提高反汇编的准确性，并使反汇编更易于阅读。它是通过包含函数参数名称和类型以及与各种库函数相关联的注释来实现的。
- en: In [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures") we discussed
    type library files as the mechanism by which IDA stores the layout of complex
    data structures. Type library files are also the means by which IDA records information
    about a function’s calling conventions and parameter sequence. IDA uses function
    signature information in several ways. First, when a binary uses shared libraries,
    IDA has no way to know what calling conventions may be employed by the functions
    in those libraries. In such cases, IDA attempts to match library functions against
    their associated signatures in a type library file. If a matching signature is
    found, IDA can understand the calling convention used by the function and make
    adjustments to the stack pointer as necessary (recall that `stdcall` functions
    perform their own stack cleanup). The second use for function signatures is to
    annotate the parameters being passed to a function with comments that denote exactly
    which parameter is being pushed on the stack prior to calling the function. The
    amount of information present in the comment depends on how much information was
    present in the function signature that IDA was able to parse. The two signatures
    that follow are both legal C declarations, though the second provides more insight
    into the function, as it provides formal parameter names in addition to datatypes.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。数据类型和数据结构")中，我们讨论了类型库文件作为IDA存储复杂数据结构布局的机制。类型库文件也是IDA记录关于函数调用约定和参数序列信息的手段。IDA以几种方式使用函数签名信息。首先，当一个二进制文件使用共享库时，IDA无法知道那些库中的函数可能采用哪种调用约定。在这种情况下，IDA试图将库函数与类型库文件中关联的签名进行匹配。如果找到匹配的签名，IDA可以理解函数使用的调用约定，并根据需要调整栈指针（回想一下，`stdcall`函数会自行清理栈）。函数签名的第二种用途是使用注释来注释传递给函数的参数，这些注释表明在调用函数之前哪个参数被推入栈中。注释中包含的信息量取决于IDA能够解析的函数签名中包含的信息量。以下两个签名都是合法的C声明，尽管第二个提供了对函数的更多洞察，因为它除了数据类型外还提供了形式参数名称。
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'IDA’s type libraries contain signature information for a large number of common
    API functions, including a substantial portion of the Windows API. A default disassembly
    of a call to the `RegOpenKey` function is shown here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的类型库包含大量常见API函数的签名信息，其中包括Windows API的大部分内容。这里展示了调用`RegOpenKey`函数的默认反汇编示例：
- en: '[PRE21]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that IDA has added comments in the right margin ![](httpatomoreillycomsourcenostarchimages854061.png),
    indicating which parameter is being pushed at each instruction leading up to the
    call to `RegOpenKey`. When formal parameter names are available in the function
    signature, IDA attempts to go one step further and automatically name variables
    that correspond to specific parameters. In two cases in the preceding example
    ![](httpatomoreillycomsourcenostarchimages854063.png), we can see that IDA has
    named a local variable (`hKey`) and a global variable (`SubKey`) based on their
    correspondence with formal parameters in the `RegOpenKey` prototype. If the parsed
    function prototype had contained only type information and no formal parameter
    names, then the comments in the preceding example would name the datatypes of
    the corresponding arguments rather than the parameter names. In the case of the
    `lpSubKey` parameter, the parameter name is not displayed as a comment because
    the parameter happens to point to a global string variable, and the content of
    the string is being displayed using IDA’s repeating comment facility. Finally,
    note that IDA has recognized `RegOpenKey` as a `stdcall` function and automatically
    adjusted the stack pointer ![](httpatomoreillycomsourcenostarchimages854093.png)
    as `RegOpenKey` would do upon returning. All of this information is extracted
    from the function’s signature, which IDA also displays as a comment within the
    disassembly at the appropriate import table location, as shown in the following
    listing:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IDA在右侧边栏添加了注释 ![图片](httpatomoreillycomsourcenostarchimages854061.png)，指明在调用`RegOpenKey`之前的每条指令中正在推送哪个参数。当函数签名中可用正式参数名称时，IDA会尝试更进一步，并自动命名与特定参数对应的变量。在前面的示例
    ![图片](httpatomoreillycomsourcenostarchimages854063.png)中的两个情况下，我们可以看到IDA已经根据与`RegOpenKey`原型中正式参数的对应关系命名了一个局部变量（`hKey`）和一个全局变量（`SubKey`）。如果解析的函数原型只包含类型信息而没有正式参数名称，那么前面示例中的注释将命名相应参数的数据类型而不是参数名称。对于`lpSubKey`参数，由于该参数恰好指向一个全局字符串变量，并且字符串内容正在使用IDA的重复注释功能显示，因此参数名称没有以注释的形式显示。最后，请注意，IDA已将`RegOpenKey`识别为`stdcall`函数，并在返回时自动调整了堆栈指针
    ![图片](httpatomoreillycomsourcenostarchimages854093.png)。所有这些信息都是从函数的签名中提取的，IDA也会在适当的导入表位置将此信息作为注释显示在反汇编中，如下所示：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The comment displaying the function prototype comes from an IDA .*til* file
    containing information on Windows API functions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 显示函数原型的注释来自包含Windows API函数信息的IDA .*til* 文件。
- en: Under what circumstances might you wish to generate your own function type signatures?^([[88](#ftn.CHP-13-FN-2)])
    Whenever you encounter a binary that is linked, either dynamically or statically,
    to a library for which IDA has no function prototype information, you may want
    to generate type signature information for all of the functions contained in that
    library in order to provide IDA with the ability to automatically annotate your
    disassembly. Examples of such libraries might include common graphics or encryption
    libraries that are not part of a standard Windows distribution but that might
    be in widespread use. The OpenSSL cryptographic library is one example of such
    a library.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下你可能希望生成自己的函数类型签名？^([[88](#ftn.CHP-13-FN-2)]) 当你遇到一个与IDA没有函数原型信息的库动态或静态链接的二进制文件时，你可能希望为该库中包含的所有函数生成类型签名信息，以便为IDA提供自动注释你的反汇编的能力。此类库的例子可能包括常见的图形或加密库，这些库不是标准Windows分发的部分，但可能在广泛使用。OpenSSL加密库就是这样一个库的例子。
- en: Just as we were able to add complex datatype information to a database’s local
    .*til* file in [Chapter 8](ch08.html "Chapter 8. Datatypes and Data Structures"),
    we can add function prototype information to that same .*til* file by having IDA
    parse one or more function prototypes via File ▸ Load File▸ Parse C Header File.
    Similarly, you may use *tilib.exe* (see [Chapter 8](ch08.html "Chapter 8. Datatypes
    and Data Structures")) to parse header files and create standalone *.til* files,
    which can be made globally available by copying them into *<IDADIR>/til*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们能够在[第8章](ch08.html "第8章。数据类型和数据结构")中向数据库的本地 .*til* 文件添加复杂的数据类型信息一样，我们可以通过让IDA通过“文件”▸“加载文件”▸“解析C头文件”来解析一个或多个函数原型，将函数原型信息添加到同一个
    .*til* 文件中。同样，你也可以使用 *tilib.exe*（见[第8章](ch08.html "第8章。数据类型和数据结构")）来解析头文件并创建独立的
    *.til* 文件，这些文件可以通过将它们复制到 *<IDADIR>/til* 中而全局可用。
- en: This is all well and good when you happen to have access to source code that
    you then allow IDA (or *tilib.exe*)to parse on your behalf. Unfortunately, more
    often than you would like, you will have no access to source code, yet you will
    want the same high-quality disassembly. How can you go about educating IDA if
    you have no source code for it to consume? This is the precisely the purpose of
    the IDS utilities, or `idsutils`. The IDS utilities are a set of three utility
    programs used to create .*ids* files. We first discuss what a .*ids* file is and
    then turn our attention to creating our own .*ids* files.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你恰好可以访问源代码，并允许IDA（或*tilib.exe*）为你解析时，这一切都很好。不幸的是，比你想象的更常见的情况是，你无法访问源代码，但你仍然希望得到相同的高质量反汇编。如果你没有源代码来教育IDA，你该如何进行？这正是IDS工具或`idsutils`的目的。IDS工具是一组用于创建.*ids*文件的三个实用程序。我们首先讨论什么是.*ids*文件，然后转向创建我们自己的.*ids*文件。
- en: MANUALLY OVERRIDING PURGED BYTES
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 手动覆盖清除的字节数
- en: Library functions that make use of the `stdcall` calling convention can wreak
    havoc with IDA’s stack-pointer analysis. Lacking any type library or *.ids* file
    information, IDA has no way of knowing whether an imported function uses the `stdcall`
    convention. This is significant, as IDA may not be able to properly track the
    behavior of the stack pointer across calls to functions for which it has no calling
    convention information. Beyond knowing that a function utilizes `stdcall`, IDA
    must also know exactly how many bytes the function removes from the stack when
    the function completes. Lacking information on calling conventions, IDA attempts
    to automatically determine whether a function utilizes `stdcall` using a mathematical
    analysis technique known as the *simplex* method.^([[89](#ftn.CHP-13-FN-3)]) Alternatively,
    users may intervene manually to specify the number of purged bytes themselves.
    [Figure 13-1](ch13.html#editing_an_imported_function "Figure 13-1. Editing an
    imported function") shows a specialized form of the function editing dialog used
    for imported functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdcall`调用约定的库函数可能会对IDA的栈指针分析造成破坏。由于缺乏任何类型库或*.ids*文件信息，IDA无法知道导入的函数是否使用了`stdcall`约定。这一点很重要，因为IDA可能无法正确跟踪没有调用约定信息的函数调用过程中的栈指针行为。除了知道一个函数使用了`stdcall`之外，IDA还必须确切知道函数在完成时从栈中移除了多少字节。缺乏关于调用约定的信息，IDA会尝试使用一种称为*单纯形法*的数学分析技术自动确定函数是否使用了`stdcall`。^([[89](#ftn.CHP-13-FN-3)])
    另外，用户也可以手动干预来指定自己清除的字节数。[图13-1](ch13.html#editing_an_imported_function "图13-1.
    编辑导入的函数")显示了用于导入函数的特定形式的函数编辑对话框。
- en: '![Editing an imported function](httpatomoreillycomsourcenostarchimages854247.png.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![编辑导入的函数](httpatomoreillycomsourcenostarchimages854247.png.jpg)'
- en: Figure 13-1. Editing an imported function
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1. 编辑导入的函数
- en: You can access this dialog by navigating to the import table entry for a given
    function and then editing the function (Edit ▸ Functions ▸ Edit Function, or alt-P).
    Note the limited functionality of this particular dialog (as opposed to the Edit
    Function dialog of [Figure 7-7](ch07s03.html#function_editing_dialog "Figure 7-7. Function
    editing dialog")). Because this is an imported function entry, IDA has no access
    to the compiled body of the function and therefore no associated information regarding
    the structure of the function’s stack frame and no direct evidence that the function
    uses the `stdcall` convention. Lacking such information, IDA sets the Purged bytes
    field to −1, indicating that it does not know whether the function clears any
    bytes from the stack upon return. To override IDA in such cases, enter the correct
    value for the number of purged bytes, and IDA will incorporate the provided information
    into its stack-pointer analysis wherever the associated function is called. In
    cases for which IDA is aware of the behavior of the function (as in [Figure 13-1](ch13.html#editing_an_imported_function
    "Figure 13-1. Editing an imported function")), the Purged bytes field may already
    be filled in. Note that this field is never filled in as a result of simplex method
    analysis.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到给定函数的导入表条目并编辑该函数来访问此对话框（编辑 ▸ 函数 ▸ 编辑函数，或 alt-P）。请注意，此特定对话框的功能有限（与[图
    7-7](ch07s03.html#function_editing_dialog "图 7-7. 函数编辑对话框")中的编辑函数对话框相比）。因为这是一个导入的函数条目，IDA
    无法访问函数的编译体，因此没有关于函数堆栈结构的关联信息，也没有函数使用 `stdcall` 约定的直接证据。缺乏此类信息，IDA 将清除字节字段设置为 −1，表示它不知道函数在返回时是否清除任何字节。在这种情况下，要覆盖
    IDA，请输入清除字节的正确值，IDA 将将提供的信息纳入其堆栈指针分析中，无论关联函数何时被调用。对于 IDA 已知函数行为的情况（如[图 13-1](ch13.html#editing_an_imported_function
    "图 13-1. 编辑导入函数")所示），清除字节字段可能已经填写。请注意，此字段永远不会因单纯形方法分析而填写。
- en: IDS Files
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDS 文件
- en: IDA uses .*ids* files to supplement its knowledge of library functions. A .*ids*
    file describes the content of a shared library by listing every exported function
    contained within the library. Information detailed for each function includes
    the function’s name, its associated ordinal number,^([[90](#ftn.CHP-13-FN-4)])
    whether the function utilizes `stdcall`, and if so, how many bytes the function
    clears from the stack upon return, and optional comments to be displayed when
    the function is referenced within a disassembly. In practice, .*ids* files are
    actually compressed .*idt* files, with .*idt* files containing the textual descriptions
    of each library function.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 使用 .*ids* 文件来补充其对库函数的了解。一个 .*ids* 文件通过列出库中包含的每个导出函数来描述共享库的内容。每个函数的详细信息包括函数的名称、其关联的序号，^([[90](#ftn.CHP-13-FN-4)])函数是否使用
    `stdcall`，如果是，函数在返回时清除多少字节，以及在反汇编中引用函数时显示的可选注释。实际上，.*ids* 文件实际上是压缩的 .*idt* 文件，其中
    .*idt* 文件包含每个库函数的文本描述。
- en: When an executable file is first loaded into a database, IDA determines which
    shared library files the executable depends on. For each shared library, IDA searches
    for a corresponding .*ids* file in the *<IDADIR>/ids* hierarchy in order to obtain
    descriptions of any library functions that the executable may reference. It is
    important to understand that .*ids* files do not necessarily contain function
    signature information. Therefore, IDA may not provide function parameter analysis
    based on information contained solely in .*ids* files. IDA can, however, perform
    accurate stack pointer accounting when a .*ids* file contains correct information
    concerning the calling conventions employed by functions and the number of bytes
    that the functions clear from the stack. In situations where a DLL exports mangled
    names, IDA may be able to infer a function’s parameter signature from the mangled
    name, in which case this information becomes available when the .*ids* file is
    loaded. We describe the syntax of .*idt* files in the next section. In this regard,
    .*til* files contain more useful information with respect to disassembling function
    calls, though source code is required in order to generate .*til* files.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当可执行文件首次加载到数据库中时，IDA确定该可执行文件依赖的共享库文件。对于每个共享库，IDA在*<IDADIR>/ids*层次结构中搜索相应的.*ids*文件，以获取可执行文件可能引用的任何库函数的描述。重要的是要理解.*ids*文件不一定包含函数签名信息。因此，IDA可能无法仅基于.*ids*文件中包含的信息提供函数参数分析。然而，当.*ids*文件包含有关函数使用的调用约定和函数从堆栈中清除的字节数的正确信息时，IDA可以执行准确的堆栈指针会计。在DLL导出混淆名称的情况下，IDA可能能够从混淆名称中推断出函数的参数签名，在这种情况下，当.*ids*文件被加载时，此信息变得可用。我们将在下一节中描述.*idt*文件的语法。在这方面，.*til*文件在反汇编函数调用方面包含更有用的信息，尽管生成.*til*文件需要源代码。
- en: Creating IDS Files
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建IDS文件
- en: 'IDA’s `idsutils` utilities are used to create .*ids* files. The utilities include
    two library parsers, *dll2idt* for extracting information from Windows DLLs and
    *ar2idt* for extracting information from ar-style libraries. In both cases, the
    output is a text .*idt* file containing a single line per exported function that
    maps the exported function’s ordinal number to the function’s name. The syntax
    for .*idt* files, which is very straightforward, is described in the *readme.txt*
    file included with `idsutils`. The majority of lines in a .*idt* file are used
    to describe exported functions according to the following scheme:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: IDA的`idsutils`工具用于创建.*ids*文件。这些工具包括两个库解析器，*dll2idt*用于从Windows DLLs中提取信息，以及*ar2idt*用于从ar风格的库中提取信息。在这两种情况下，输出都是一个文本.*idt*文件，每行包含一个导出函数，将导出函数的序号映射到函数的名称。.*idt*文件的语法非常直接，在`idsutils`提供的*readme.txt*文件中有描述。在.*idt*文件中的大多数行都用于根据以下方案描述导出函数：
- en: An export entry begins with a positive number. This number represents the ordinal
    number of the exported function.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出条目以一个正数开始。这个数字代表导出函数的序号。
- en: 'The ordinal number is followed by a space and then a `Name` directive in the
    form `Name=`*`function`*, for example, `Name=RegOpenKeyA`. If the special ordinal
    value zero is used, then the `Name` directive is used to specify the name of the
    library described in the current .*idt* file, such as in this example:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序号后面跟着一个空格，然后是一个`Name`指令，形式为`Name=`*`function`*，例如，`Name=RegOpenKeyA`。如果使用特殊的序号零，则`Name`指令用于指定当前.*idt*文件中描述的库的名称，例如在这个例子中：
- en: '[PRE23]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'An optional `Pascal` directive may be used to specify that a function uses
    the `stdcall` calling convention and to indicate how many bytes the function removes
    from the stack upon return. Here is an example:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用可选的`Pascal`指令来指定一个函数使用`stdcall`调用约定，并指示函数返回时从堆栈中移除多少字节。以下是一个示例：
- en: '[PRE24]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'An optional `Comment` directive can be appended to an export entry to specify
    a comment to be displayed with the function at each reference to the function
    within a disassembly. A completed export entry might look like the following:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将可选的`Comment`指令附加到导出条目中，以指定在反汇编中每次引用函数时显示的注释。一个完成的导出条目可能看起来像以下这样：
- en: '[PRE25]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additional, optional directives are described in the `idsutils` *readme.txt*
    file. The purpose of the `idsutils` parsing utilities is to automate, as much
    as possible, the creation of .*idt* files. The first step in creating a .*idt*
    file is to obtain a copy of the library that you wish to parse; the next step
    is to parse it using the appropriate parsing utility. If we wished to create a
    .*idt* file for the OpenSSL -related library *ssleay32.dll*, we would use the
    following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可选指令在 `idsutils` 的 *readme.txt* 文件中描述。`idsutils` 解析工具的目的尽可能自动化地创建 .*idt*
    文件。创建 .*idt* 文件的第一步是获取你希望解析的库的副本；下一步是使用适当的解析工具解析它。如果我们想为与 OpenSSL 相关的库 *ssleay32.dll*
    创建 .*idt* 文件，我们会使用以下命令：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Successful parsing in this case results in a file named *SSLEAY32.idt*. The
    difference in capitalization between the input filename and the output filename
    is due to the fact that *dll2idt* derives the name of the output file based on
    information contained within the DLL itself. The first few lines of the resulting
    .*idt* file are shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，成功的解析会产生一个名为 *SSLEAY32.idt* 的文件。输入文件名和输出文件名之间的大小写差异是由于 *dll2idt* 根据DLL本身包含的信息推导输出文件名。以下展示了生成的
    .*idt* 文件的前几行：
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that it is not possible for the parsers to determine whether a function
    uses `stdcall` and, if so, how many bytes are purged from the stack. The addition
    of any `Pascal` or `Comment` directives must be performed manually using a text
    editor prior to creating the final .*ids* file. The final steps for creating a
    .*ids* are to use the *zipids* utility to compress the .*idt* file and then to
    copy the resulting .*ids* file to *<IDADIR>/ids*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，解析器无法确定一个函数是否使用 `stdcall` 以及如果是的话，从堆栈中清除了多少字节。任何 `Pascal` 或 `Comment` 指令的添加都必须在创建最终的
    .*ids* 文件之前手动使用文本编辑器执行。创建 .*ids* 的最终步骤是使用 *zipids* 工具压缩 .*idt* 文件，然后将生成的 .*ids*
    文件复制到 *<IDADIR>/ids*。
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, IDA loads *SSLEAY32.ids* anytime a binary that links to *ssleay32.dll*
    is loaded. If you elect not to copy your newly created .*ids* files into *<IDADIR>/ids*,
    you can load them at any time via File ▸ Load File ▸ IDS File.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，IDA 在加载链接到 *ssleay32.dll* 的任何二进制文件时都会加载 *SSLEAY32.ids*。如果你选择不将新创建的 .*ids*
    文件复制到 *<IDADIR>/ids*，你可以通过 File ▸ Load File ▸ IDS File 在任何时间加载它们。
- en: 'An additional step in the use of .*ids* files allows you to link .*ids* files
    to specific .*sig* or .*til* files. When you choose .*ids* files, IDA utilizes
    an IDS configuration file named *<IDADIR>/ida/idsnames*. This text file contains
    lines to allow for the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 .*ids* 文件的一个附加步骤允许你将 .*ids* 文件链接到特定的 .*sig* 或 .*til* 文件。当你选择 .*ids* 文件时，IDA
    使用名为 *<IDADIR>/ida/idsnames* 的 IDS 配置文件。此文本文件包含允许以下操作的行：
- en: 'Map a shared library name to its corresponding .*ids* filename. This allows
    IDA to locate the correct .*ids* file when a shared library name does not translate
    neatly to an MS-DOS-style 8.3 filename as with the following:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将共享库名称映射到相应的 .*ids* 文件名。这允许 IDA 在共享库名称不能干净地映射到 MS-DOS 风格的 8.3 文件名时定位正确的 .*ids*
    文件，如下所示：
- en: '[PRE29]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Map a .*ids* file to a .*til* file. In such cases, IDA automatically loads
    the specified .*til* file whenever it loads the specified .*ids* file. The following
    example would cause *openssl.til* to be loaded anytime *SSLEAY32.ids* is loaded
    (see `idsnames` for syntax details):'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 .*ids* 文件映射到 .*til* 文件。在这种情况下，IDA 在加载指定的 .*ids* 文件时自动加载指定的 .*til* 文件。以下示例会在加载
    *SSLEAY32.ids* 时加载 *openssl.til*（有关语法细节，请参阅 `idsnames`）：
- en: '[PRE30]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Map a .*sig* file to a corresponding .*ids* file. In this case, IDA loads the
    indicated .*ids* file anytime the named .*sig* file is applied to a disassembly.
    The following line directs IDA to load *SSLEAY32.ids* anytime a user applies the
    *libssl.sig* FLIRT signature:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 .*sig* 文件映射到相应的 .*ids* 文件。在这种情况下，IDA 在将命名的 .*sig* 文件应用于反汇编时加载指定的 .*ids* 文件。以下行指示
    IDA 在用户应用 *libssl.sig* FLIRT 签名时加载 *SSLEAY32.ids*：
- en: '[PRE31]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In [Chapter 15](ch15.html "Chapter 15. IDA Scripting") we will look at a script-oriented
    alternative to the library parsers provided by `idsutils`, and we’ll leverage
    IDA’s function-analysis capabilities to generate more descriptive .*idt* files.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 15 章](ch15.html "第 15 章。IDA 脚本") 中，我们将探讨 `idsutils` 提供的库解析器的脚本化替代方案，并利用
    IDA 的函数分析功能生成更详细的 .*idt* 文件。
- en: '* * *'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[87](#CHP-13-FN-1)]) See [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm).
    A valid IDA username and password are required.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[87](#CHP-13-FN-1)]) 查看 [http://www.hex-rays.com/idapro/idadown.htm](http://www.hex-rays.com/idapro/idadown.htm)。需要有效的
    IDA 用户名和密码。
- en: ^([[88](#CHP-13-FN-2)]) In this case we are using the term *signature* to refer
    to a function’s parameter type(s), quantity, and sequence rather than a pattern
    of code to match the compiled function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[88](#CHP-13-FN-2)]) 在这个例子中，我们使用术语*签名*来指代函数的参数类型（s）、数量和顺序，而不是匹配编译函数的代码模式。
- en: '^([[89](#CHP-13-FN-3)]) Use of the simplex method as introduced in IDA version
    5.1 is described in a blog post by Ilfak here: [http://www.hexblog.com/2006/06/](http://www.hexblog.com/2006/06/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[89](#CHP-13-FN-3)]) 简单形法（simplex method）的使用，如IDA版本5.1中介绍的那样，在Ilfak的博客文章中有描述：[http://www.hexblog.com/2006/06/](http://www.hexblog.com/2006/06/).
- en: ^([[90](#CHP-13-FN-4)]) An *ordinal number* is an integer index associated with
    each exported function. The use of ordinals allows a function to be located using
    an integer lookup table rather than by a slower string comparison against the
    function’s name.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[90](#CHP-13-FN-4)]) 序列号是一个与每个导出函数关联的整数索引。使用序列号允许通过整数查找表而不是通过较慢的字符串比较函数名来定位函数。
- en: Augmenting Predefined Comments with loadint
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 loadint 增强预定义注释
- en: 'In [Chapter 7](ch07.html "Chapter 7. Disassembly Manipulation") we covered
    IDA’s concept of *auto comments*, which, when enabled, cause IDA to display comments
    describing each assembly language instruction. Two examples of such comments are
    shown in the following listing:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。反汇编操作") 中，我们介绍了 IDA 的 *自动注释* 概念，当启用时，会导致 IDA 显示描述每个汇编语言指令的注释。以下列表显示了此类注释的两个示例：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The source of these predefined comments is the file *<IDADIR>/ida.int*, which
    contains comments sorted first by CPU type and second by instruction type. When
    auto comments are turned on, IDA searches for comments associated with each instruction
    in the disassembly and displays them in the right margin if they are present in
    *ida.int*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些预定义注释的来源是文件 *<IDADIR>/ida.int*，其中注释首先按 CPU 类型排序，其次按指令类型排序。当自动注释开启时，IDA 会搜索与反汇编中每个指令关联的注释，并在它们存在于
    *ida.int* 中时在右侧显示。
- en: 'The `loadint`^([[91](#ftn.CHP-13-FN-5)]) utilities provide you with the ability
    to modify existing comments or add new comments to *ida.int*. As with the other
    add-on utilities we have discussed, `loadint` is documented in a *readme.txt*
    file included with the `loadint` distribution. The `loadint` distribution also
    contains the predefined comments for all of IDA’s processor modules in the form
    of numerous .*cmt* files. Modifying existing comments is a simple matter of locating
    the comment file associated with your processor of interest (for example, *pc.cmt*
    for x86), making changes to any comments whose text you wish to modify, running
    *loadint* to re-create the *ida.int* comment file, and finally copying the resulting
    *ida.int* file into your main IDA directory, where it will be loaded the next
    time IDA is launched. A simple run to rebuild the comment database looks like
    the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadint`^([[91](#ftn.CHP-13-FN-5)]) 工具提供您修改现有注释或向 *ida.int* 添加新注释的能力。与其他我们讨论过的附加工具一样，`loadint`
    在 `loadint` 分发中包含的 *readme.txt* 文件中有文档说明。`loadint` 分发还包含所有 IDA 处理器模块的预定义注释，形式为多个
    .*cmt* 文件。修改现有注释是一个简单的过程，包括定位与您感兴趣的处理器相关的注释文件（例如，*pc.cmt* 用于 x86），修改您希望修改的任何注释的文本，运行
    *loadint* 重新创建 *ida.int* 注释文件，最后将生成的 *ida.int* 文件复制到您的 IDA 主目录中，下次启动 IDA 时将加载它。重建注释数据库的简单运行如下所示：'
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Examples of changes that you might wish to make include modifying existing
    comments or enabling comments for instructions that have no assigned comment.
    In the *pc.cmt* file, for example, several of the more common instructions are
    commented out so as not to generate too many comments when auto comments are enabled.
    The following lines, extracted from *pc.cmt*, demonstrate that x86 `mov` instructions
    do not generate comments by default:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望进行的更改示例包括修改现有注释或为没有分配注释的指令启用注释。例如，在 *pc.cmt* 文件中，一些更常见的指令被注释掉，以防止在自动注释开启时生成过多的注释。以下是从
    *pc.cmt* 中提取的行，展示了 x86 `mov` 指令默认不生成注释：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Should you wish to enable comments for `mov` instructions, you would uncomment
    the middle line and rebuild the comment database as detailed previously.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望为 `mov` 指令启用注释，您将取消中间行的注释，并按之前详细说明的方式重建注释数据库。
- en: A note buried within the documentation for `loadint` points out that *loadint*
    must be able to locate the file *ida.hlp*, which is included with your IDA distribution.
    If you receive the following error message, you should copy *ida.hlp* into your
    *loadint* directory and then rerun *loadint*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loadint` 的文档中有一个隐藏的注释指出，*loadint* 必须能够定位到与你的 IDA 发行版一起提供的文件 *ida.hlp*。如果你收到以下错误信息，你应该将
    *ida.hlp* 复制到你的 *loadint* 目录中，然后重新运行 *loadint*。
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, you may use the `-n` switch with `loadint` to specify the location
    of `<IDADIR>`, as shown in the following command line:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 `loadint` 的 `-n` 开关来指定 `<IDADIR>` 的位置，如下面的命令行所示：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The file *comment.cmt* serves as the master input file to the `loadint` process.
    The syntax for this file is described in the `loadint` documentation. In a nutshell,
    *comment.cmt* creates the mappings from processor types to associated comment
    files. Individual processor-specific comment files in turn specify the mappings
    from specific instructions to the associated comment text for each instruction.
    The entire process is governed by several sets of enumerated (C-style enums) constants
    that define all of the processor types (found in *comment.cmt*) and all of the
    possible instructions for each processor (found in *allins.hpp*).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *comment.cmt* 作为 `loadint` 过程的主输入文件。该文件的语法在 `loadint` 文档中描述。简而言之，*comment.cmt*
    创建从处理器类型到关联注释文件的映射。各个处理器特定的注释文件反过来指定从特定指令到每个指令的关联注释文本的映射。整个过程由几组枚举（C 风格枚举）常量控制，这些常量定义了所有处理器类型（在
    *comment.cmt* 中找到）和每个处理器的所有可能的指令（在 *allins.hpp* 中找到）。
- en: If you want to add predefined comments for a completely new processor type,
    the process is somewhat more involved than simply changing existing comments and
    is fairly closely linked to the process for creating new processor modules (see
    [Chapter 19](ch19.html "Chapter 19. IDA Processor Modules")). Without diving too
    deeply into processor modules, providing comments for a completely new processor
    type requires that you first create a new enumerated constant set (shared with
    your processor module) within *allins.hpp* that defines one constant for each
    instruction in the instruction set of interest. Second, you must create a comment
    file that maps each enumerated instruction constant to its associated comment
    text. Third, you must define a new constant for your processor type (again, shared
    with your processor module) and create an entry in *comment.cmt* that maps your
    processor type to its associated comment file. Once you have completed these steps,
    you must run *loadint* to build a new comment database that incorporates your
    new processor type and associated comments.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为全新的处理器类型添加预定义的注释，这个过程比简单地更改现有注释要复杂一些，并且与创建新处理器模块的过程（见 [第 19 章](ch19.html
    "第 19 章. IDA 处理器模块")）相当紧密相关。在不深入处理器模块的情况下，为全新的处理器类型提供注释需要你首先在 *allins.hpp* 中创建一个新的枚举常量集（与你的处理器模块共享），为感兴趣的指令集中的每个指令定义一个常量。其次，你必须创建一个注释文件，将每个枚举指令常量映射到其关联的注释文本。第三，你必须为你的处理器类型定义一个新的常量（再次，与你的处理器模块共享），并在
    *comment.cmt* 中创建一个条目，将你的处理器类型映射到其关联的注释文件。完成这些步骤后，你必须运行 *loadint* 来构建一个新的注释数据库，该数据库包含你的新处理器类型及其关联的注释。
- en: '* * *'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[91](#CHP-13-FN-5)]) The current version is *loadint61.zip*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[91](#CHP-13-FN-5)]) 当前版本是 *loadint61.zip*。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While `idsutils` and `loadint` may not seem immediately useful to you, you will
    learn to appreciate their capabilities once you begin to step outside IDA’s more
    common use cases. For a relatively small investment of time, the creation of a
    single .*ids* or .*til* file can save you countless hours whenever you encounter
    the libraries described by those files in future projects. Keep in mind that it
    is not possible for IDA to ship with descriptions for every library in existence.
    The intended purpose of the tools covered in this chapter is to provide you with
    the flexibility to address gaps in IDA’s library coverage whenever you stray off
    IDA’s beaten path.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `idsutils` 和 `loadint` 可能看起来对你来说并不立即有用，但一旦你开始超出 IDA 更常见的使用案例，你就会学会欣赏它们的性能。对于相对较少的时间投入，创建单个
    .*ids* 或 .*til* 文件可以在你未来项目中遇到那些文件描述的库时节省你无数小时。请记住，IDA 无法为所有存在的库提供描述。本章中涵盖的工具的预期目的是在你偏离
    IDA 的常规路径时，为你提供灵活性，以解决 IDA 库覆盖的空白。
- en: Chapter 14. Patching Binaries and Other IDA Limitations
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章. 修补二进制文件和其他 IDA 限制
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages854059.png.jpg)'
- en: One of the most frequently asked questions by new or prospective IDA users is
    “How can I use IDA to patch binaries?” The simple answer is “You can’t.” IDA’s
    intended purpose is to assist you in understanding the behavior of a binary by
    offering you the best disassembly possible. IDA is not designed to make it easy
    for you to modify the binaries you are examining. Not wanting to take no for an
    answer, die-hard patchers often follow up with questions such as “What about the
    Edit ▸ Patch Program menu?” and “What is the purpose of File ▸ Produce File ▸
    Create EXE File?” In this chapter we discuss these apparent anomalies and see
    if we can’t coax IDA into helping us, at least a little bit, with developing patches
    for binary program files.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 新手或潜在 IDA 用户最常问的问题之一是“我如何使用 IDA 来修补二进制文件？”简单的回答是“你不能。”IDA 的预期目的是通过提供最佳的反汇编功能来帮助您理解二进制文件的行为。IDA
    并非设计来让您轻松修改正在检查的二进制文件。不愿意接受“不”作为答案的顽固修补者通常会接着问“编辑 ▸ 补丁程序菜单是什么？”和“文件 ▸ 生成文件 ▸ 创建
    EXE 文件”有什么作用？”在本章中，我们将讨论这些明显的异常情况，看看我们是否能说服 IDA 至少在开发二进制程序文件的补丁方面提供一些帮助。
- en: The Infamous Patch Program Menu
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声名狼藉的补丁程序菜单
- en: First mentioned in [Chapter 11](ch11.html "Chapter 11. Customizing IDA"), the
    Edit ▸ Patch Program menu is a hidden feature in the GUI version of IDA that must
    be enabled by editing the *idagui.cfg* configuration file (the Patch menu is available
    by default in console versions of IDA). [Figure 14-1](ch14.html#the_patch_program_submenu
    "Figure 14-1. The Patch Program submenu") shows the options available on the Edit
    ▸ Patch Program submenu.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在[第 11 章](ch11.html "第 11 章。自定义 IDA")中提到，编辑 ▸ 补丁程序菜单是 IDA 图形界面版本中的一个隐藏功能，必须通过编辑
    *idagui.cfg* 配置文件来启用（补丁菜单在 IDA 控制台版本中默认可用）。[图 14-1](ch14.html#the_patch_program_submenu
    "图 14-1. 补丁程序子菜单")显示了编辑 ▸ 补丁程序子菜单中的选项。
- en: '![The Patch Program submenu](httpatomoreillycomsourcenostarchimages854250.png.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![补丁程序子菜单](httpatomoreillycomsourcenostarchimages854250.png.jpg)'
- en: Figure 14-1. The Patch Program submenu
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1. 补丁程序子菜单
- en: Each of the submenu items teases you with the notion that you are going to be
    able to modify the binary in potentially interesting ways. In actuality, what
    these options offer are three different ways to modify the database. In fact,
    these menu items, perhaps more than any others, make perfectly clear the distinction
    between an IDA database and the binary file from which the database was created.
    Once a database is created, IDA never references the original binary. Given its
    true behavior, this menu item would be more aptly named *Patch Database*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子菜单项都让您觉得您将能够以可能有趣的方式修改二进制文件。实际上，这些选项提供的是三种不同的修改数据库的方法。实际上，这些菜单项，可能比其他任何菜单项都更能清楚地说明
    IDA 数据库和创建数据库的二进制文件之间的区别。一旦创建数据库，IDA 从不引用原始二进制文件。考虑到其真实行为，这个菜单项更恰当地命名为 *修补数据库*。
- en: All is not completely lost, however, as the menu options in [Figure 14-1](ch14.html#the_patch_program_submenu
    "Figure 14-1. The Patch Program submenu") do offer you the easiest way to observe
    the effect of any changes that you might eventually make to the original binary.
    Later in this chapter you will learn how to export the changes you have made and
    eventually use that information to patch the original binary.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非一切都已失去，因为[图 14-1](ch14.html#the_patch_program_submenu "图 14-1. 补丁程序子菜单")中的菜单选项确实提供了观察您可能对原始二进制文件进行更改后效果的最简单方法。在本章的后面部分，您将学习如何导出您所做的更改，并最终使用这些信息来修补原始二进制文件。
- en: Changing Individual Database Bytes
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改单个数据库字节
- en: The Edit ▸ Patch Program ▸ Change Byte menu option is used to edit one or more
    byte values within an IDA database. [Figure 14-2](ch14.html#the_patch_bytes_dialog
    "Figure 14-2. The Patch Bytes dialog") shows the related byte-editing dialog.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 ▸ 补丁程序 ▸ 修改字节菜单选项用于编辑 IDA 数据库中的一个或多个字节值。[图 14-2](ch14.html#the_patch_bytes_dialog
    "图 14-2. 修改字节对话框")显示了相关的字节编辑对话框。
- en: '![The Patch Bytes dialog](httpatomoreillycomsourcenostarchimages854253.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![修改字节对话框](httpatomoreillycomsourcenostarchimages854253.png.jpg)'
- en: Figure 14-2. The Patch Bytes dialog
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2. 修改字节对话框
- en: The dialog displays 16-byte values beginning at the current cursor location.
    You may change some or all of the displayed bytes, but you cannot make changes
    beyond the 16th byte without closing the dialog, repositioning the cursor to a
    new location farther into the database, and reopening the dialog. Note that the
    dialog displays the virtual address and the file offset value for the bytes that
    you are changing. This File offset value reflects the hexa-decimal offset at which
    the bytes reside within the original binary file. The fact that IDA retains the
    original file offset information for every byte in the database will be useful
    if you do wish to develop a patch for the original binary. Finally, regardless
    of the number of changes that have been made to the bytes in the database, the
    Original value field of the dialog always displays the original byte values loaded
    into the database. There is no automated capability for reverting changes to their
    original byte values, though it is possible to create an IDA script to perform
    such a task.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框显示从当前光标位置开始的16字节值。您可以更改显示的字节的一部分或全部，但如果不关闭对话框、将光标重新定位到数据库中的新位置并重新打开对话框，则不能更改超过第16个字节。请注意，对话框显示您正在更改的字节的虚拟地址和文件偏移量值。此文件偏移量值反映了字节在原始二进制文件中的十六进制偏移量。如果确实希望为原始二进制文件开发修补程序，那么IDA保留数据库中每个字节的原始文件偏移量信息将是有用的。最后，无论对数据库中的字节进行了多少更改，对话框的“原始值”字段始终显示加载到数据库中的原始字节值。没有自动化的功能可以撤销更改到原始字节值，尽管可以创建一个IDA脚本来执行此任务。
- en: A better method for editing database bytes was introduced in IDA 5.5 in the
    form of a more capable Hex View window (see [Chapter 5](ch05.html "Chapter 5. IDA
    Data Displays")). With an integrated hex-editing capability, there is little need
    to use IDA’s change bytes capability.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDA 5.5中，通过引入一个功能更强大的十六进制视图窗口（见[第5章](ch05.html "第5章。IDA数据显示"））引入了编辑数据库字节的一种更好的方法。有了集成的十六进制编辑功能，几乎不需要使用IDA的更改字节功能。
- en: Changing a Word in the Database
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改数据库中的单词
- en: Somewhat less useful than the byte-patching capability is IDA’s word-patching
    capability. [Figure 14-3](ch14.html#the_patch_word_dialog "Figure 14-3. The Patch
    Word dialog") shows IDA’s Patch Word dialog, which is capable of patching only
    one 2-byte word at a time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节修补功能相比，IDA的单词修补功能稍微不那么有用。[图14-3](ch14.html#the_patch_word_dialog "图14-3. 单词修补对话框")显示了IDA的单词修补对话框，它一次只能修补一个2字节的单词。
- en: '![The Patch Word dialog](httpatomoreillycomsourcenostarchimages854256.png.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![单词修补对话框](httpatomoreillycomsourcenostarchimages854256.png.jpg)'
- en: Figure 14-3. The Patch Word dialog
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3. 单词修补对话框
- en: As with the byte-patching dialog, the virtual address and file offset are displayed.
    An important point to remember is that the word value is displayed using the natural
    byte ordering of the underlying processor. For example, in an x86 disassembly,
    words are treated as little-endian values, while in a MIPS disassembly, words
    are treated as big-endian values. Keep this in mind when entering new word values.
    As with the byte-patching dialog, the Original value field always displays the
    initial value loaded from the original binary file regardless of the number of
    times the word value may have been modified using the word-patching dialog. As
    with byte editing, it may be easier to perform your editing within IDA’s Hex View
    window.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节修补对话框一样，虚拟地址和文件偏移量都会显示。需要记住的一个重要点是，单词值使用底层处理器的自然字节顺序来显示。例如，在x86反汇编中，单词被视为小端值，而在MIPS反汇编中，单词被视为大端值。在输入新的单词值时请记住这一点。与字节修补对话框一样，“原始值”字段始终显示从原始二进制文件加载的初始值，无论单词值可能使用单词修补对话框进行了多少次修改。与字节编辑一样，在IDA的十六进制视图窗口中进行编辑可能更容易。
- en: Using the Assemble Dialog
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用汇编对话框
- en: Perhaps the most interesting capability accessible from the Patch Program menu
    is the Assemble option (Edit ▸ Patch Program ▸ Assemble). Unfortunately, this
    capability is not available for all processor types, as it relies on the presence
    of an internal assembler capability within the current processor module. For example,
    the x86 processor module is known to support assembly, while the MIPS processor
    module is known not to support assembly. When an assembler is not available, you
    will receive an error message stating, “Sorry, this processor module doesn’t support
    the assembler.”
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从Patch程序菜单中可访问的最有趣的选项可能是Assemble选项（编辑 ▸ Patch程序 ▸ Assemble）。不幸的是，这个功能并非对所有处理器类型都可用，因为它依赖于当前处理器模块中存在内部汇编器功能。例如，已知x86处理器模块支持汇编，而MIPS处理器模块则不支持汇编。当汇编器不可用时，您将收到一个错误消息，内容为：“抱歉，此处理器模块不支持汇编器。”
- en: The Assemble option allows you to enter assembly language statements that are
    assembled using an internal assembler. The resulting instruction bytes are then
    written to the current screen location. [Figure 14-4](ch14.html#the_assemble_instruction_dialog
    "Figure 14-4. The Assemble Instruction dialog") shows the Assemble Instruction
    dialog used for instruction entry.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Assemble选项允许您输入汇编语言语句，这些语句将使用内部汇编器进行汇编。生成的指令字节随后将被写入当前屏幕位置。[图14-4](ch14.html#the_assemble_instruction_dialog
    "图14-4. Assemble指令对话框")显示了用于指令输入的Assemble指令对话框。
- en: '![The Assemble Instruction dialog](httpatomoreillycomsourcenostarchimages854259.png.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![Assemble指令对话框](httpatomoreillycomsourcenostarchimages854259.png.jpg)'
- en: Figure 14-4. The Assemble Instruction dialog
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4. Assemble指令对话框
- en: You can enter one instruction at a time into the Instruction field. The assembler
    component for IDA’s x86 processor module accepts the same syntax used in x86 disassembly
    listings. When you click OK (or press enter), your instruction is assembled, and
    the corresponding instruction bytes are entered into the database beginning at
    the virtual address displayed in the Address field. The internal IDA assembler
    allows you to use symbolic names within your instructions as long as those names
    exist within the program. Syntax such as `mov [ebp+var_4], eax` and `call sub_401896`
    is perfectly legal, and the assembler will correctly resolve symbolic references.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以一次将一条指令输入到指令字段中。IDA的x86处理器模块的汇编器组件接受与x86反汇编列表中使用的相同语法。当您点击“确定”（或按回车键）时，您的指令将被汇编，相应的指令字节将被输入到数据库中，从地址字段中显示的虚拟地址开始。内部IDA汇编器允许您在指令中使用符号名称，只要这些名称存在于程序中。例如，`mov
    [ebp+var_4], eax`和`call sub_401896`这样的语法是合法的，汇编器将正确解析符号引用。
- en: Following entry of an instruction, the dialog remains open and ready to accept
    a new instruction at the virtual address immediately following the previously
    entered instruction. While you enter additional instructions, the dialog displays
    the previous instruction entered in the Previous line field.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 输入指令后，对话框保持打开状态，准备接受在之前输入指令的虚拟地址立即之后的新的指令。当您输入额外的指令时，对话框在先前的指令字段中显示之前输入的指令。
- en: When entering new instructions, you must pay attention to instruction alignment,
    especially when the instruction that you are entering is a different length than
    the instruction it is replacing. When a new instruction is shorter than the instruction
    it is replacing, you need to consider what to do with the excess bytes left over
    from the old instruction (inserting NOP^([[92](#ftn.CHP-14-FN-1)]) instructions
    is one possible option). When a new instruction is longer than the instruction
    that it is replacing, IDA will overwrite as many bytes of subsequent instructions
    as is required to fit the new instruction. This may or may not be the behavior
    you want, which is why careful planning is necessary before using the assembler
    to modify program bytes. One way to view the assembler is as a word processor
    that is stuck in overwrite mode. There is no easy way to open up space to insert
    new instructions without overwriting existing instructions.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入新指令时，您必须注意指令对齐，尤其是在您要输入的指令长度与替换的指令不同时。当新指令比替换的指令短时，您需要考虑如何处理旧指令留下的多余字节（插入NOP^([[92](#ftn.CHP-14-FN-1)])指令是一个可能的选项）。当新指令比替换的指令长时，IDA将覆盖后续指令所需的字节，以适应新指令。这可能是也可能不是您想要的行为，这就是为什么在使用汇编器修改程序字节之前进行仔细规划是必要的。一种看待汇编器的方式是将其视为处于覆盖模式的文字处理器。没有简单的方法在不覆盖现有指令的情况下打开空间来插入新指令。
- en: 'It is important to remember that IDA’s database-patching capabilities are limited
    to small, simple patches that easily fit into existing space within the database.
    If you have a patch that requires substantial additional space, you will need
    to locate space that is allocated within the original binary but not used by the
    binary. Such space is often present in the form of padding, inserted by compilers
    to align sections of a binary to particular file boundaries. For example, in many
    Windows PE files, individual program sections must begin at file offsets that
    are multiples of 512 bytes. When a section does not consume an even multiple of
    512 bytes of space, that section must be padded within the file in order to maintain
    a 512-byte boundary for the next section. The following lines from a disassembled
    PE file demonstrate this situation:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，IDA的数据库修补功能仅限于小型、简单的修补，这些修补可以轻松地适应数据库中的现有空间。如果你有一个需要大量额外空间的修补，你需要找到在原始二进制文件中分配但未被使用的空间。这种空间通常以填充的形式存在，由编译器插入，以使二进制文件的各个部分对齐到特定的文件边界。例如，在许多Windows
    PE文件中，各个程序部分必须从文件偏移量为512字节的倍数的位置开始。当一个部分不消耗512字节的偶数倍空间时，该部分必须在文件中进行填充，以保持下一个部分的512字节边界。以下是从反汇编的PE文件中的几行展示了这种情况：
- en: '[PRE37]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, IDA is using an align directive ![](httpatomoreillycomsourcenostarchimages854061.png)
    to indicate that the section is padded to a 512-byte (`200h`) boundary beginning
    from address `.text:00409644`. The upper end of the padding is the next multiple
    of 512 bytes, or `.text:00409800`. The padded area is generally filled with zeros
    by the compiler and stands out quite prominently in hex view. In this particular
    binary, there is space within the file to insert up to 444 (0x1BC = 409800h –
    409644h) bytes of patched program data, which would overwrite some or all of the
    zero padding at the end of the `.text` section. You might patch a function to
    jump to this area of the binary, execute the newly inserted program instructions,
    and then jump back to the original function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，IDA正在使用对齐指令 ![](httpatomoreillycomsourcenostarchimages854061.png) 来指示该部分被填充到从地址
    `.text:00409644` 开始的512字节（`200h`）边界。填充的上限是下一个512字节的倍数，即 `.text:00409800`。填充区域通常由编译器填充为零，并在十六进制视图中非常突出。在这个特定的二进制文件中，文件内部有空间可以插入多达444（0x1BC
    = 409800h – 409644h）字节的修补程序数据，这将覆盖`.text`部分末尾的一些或全部零填充。你可能可以将函数修补到这个二进制区域的某个位置，执行新插入的程序指令，然后跳回原始函数。
- en: Note that the next section in the binary, the `.idata` section, does not actually
    begin until address `.idata:0040A000`. This is a result of a memory- (not file-)
    alignment restriction that requires PE sections to begin in 4Kb (one memory page)
    boundaries. In theory it should be possible to inject an additional 2,048 bytes
    of patched data into the memory range `00409800-0040A000`. The difficulty in doing
    so lies in the fact that no bytes corresponding to this memory range are present
    within the disk image of the executable. In order to use this space, we would
    need to perform more than a simple overwrite of portions of the original binary
    file. First we would need to insert a 2,048-byte block of data between the end
    of the existing `.text` section and the beginning of the `.idata` section. Second,
    we would need to adjust the size of the `.text` section within the PE file headers.
    Finally, we’d need to adjust the location of `.idata` and all subsequent sections
    within the PE headers to reflect the fact that all following sections are now
    located 2,048 bytes deeper into the file. These changes may not sound terribly
    complicated, but they require some attention to detail and a good working knowledge
    of the PE file format.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，二进制文件中的下一个部分，即`.idata`部分，实际上直到地址 `.idata:0040A000` 才开始。这是由于内存（而非文件）对齐限制的结果，该限制要求PE部分以4Kb（一个内存页）边界开始。理论上，应该可以在内存范围
    `00409800-0040A000` 中注入额外的2,048字节修补数据。这样做困难之处在于，可执行文件的磁盘映像中不存在对应这个内存范围的字节。为了使用这个空间，我们需要执行比简单覆盖原始二进制文件部分更复杂的操作。首先，我们需要在现有`.text`部分的末尾和`.idata`部分的开始之间插入一个2,048字节的
    数据块。其次，我们需要调整PE文件头中`.text`部分的大小。最后，我们需要调整`.idata`和PE头中所有后续部分的位置，以反映所有后续部分现在都位于文件中2,048字节更深的位置。这些更改可能听起来并不复杂，但它们需要一些细节关注和良好的PE文件格式知识。
- en: '* * *'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[92](#CHP-14-FN-1)]) *NOP* stands for *no operation* and is an instruction
    often used simply to fill in space in a program.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[92](#CHP-14-FN-1)]) *NOP*代表*无操作*，是一种常用于在程序中填充空间的指令。
- en: IDA Output Files and Patch Generation
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA输出文件和补丁生成
- en: One of the more interesting menu options in IDA is the File ▸ Produce File menu.
    According to the options on this menu, IDA can generate MAP, ASM, INC, LST, EXE,
    DIF, and HTML files. Many of these sound intriguing, so each is described in the
    following sections.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: IDA中更有趣的菜单选项之一是“文件”▸“生成文件”菜单。根据此菜单上的选项，IDA可以生成MAP、ASM、INC、LST、EXE、DIF和HTML文件。其中许多听起来很有趣，因此以下各节将分别描述每个选项。
- en: IDA-Generated MAP Files
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的MAP文件
- en: A *.map* file describes the overall layout of a binary, including information
    about the sections that make up the binary and the location of symbols within
    each section. When generating a *.map* file, you are asked for the name of the
    file you wish to create and the types of symbols you would like to store in the
    *.map* file. [Figure 14-5](ch14s02.html#map_file-generation_options "Figure 14-5. MAP
    file-generation options") shows the MAP file options dialog, in which you select
    the information you wish to include in the *.map* file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*.map*文件描述了二进制文件的整体布局，包括组成二进制文件的节的信息以及每个节中符号的位置。在生成*.map*文件时，您将被要求输入您希望创建的文件名以及您希望在*.map*文件中存储的符号类型。[图14-5](ch14s02.html#map_file-generation_options
    "图14-5. MAP文件生成选项")显示了MAP文件选项对话框，其中您可以选择要包含在*.map*文件中的信息。'
- en: '![MAP file-generation options](httpatomoreillycomsourcenostarchimages854262.png.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![MAP文件生成选项](httpatomoreillycomsourcenostarchimages854262.png.jpg)'
- en: Figure 14-5. MAP file-generation options
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5. MAP文件生成选项
- en: Address information in a *.map* file is represented using *logical addresses*.
    A logical address describes a symbol’s location using a segment number and a segment
    offset. The first few lines of a simple *.map* file are shown in the following
    listing. In this listing we show three segments and the first two of many symbols.
    The logical address of `_fprintf` indicates that it resides at byte offset `69h`
    within the first (`.text`) segment.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*.map*文件中的地址信息使用*逻辑地址*表示。逻辑地址使用段号和段偏移来描述符号的位置。以下列出的简单*.map*文件的前几行显示了。在这个列表中，我们展示了三个段和许多符号中的前两个。`_fprintf`的逻辑地址表明它位于第一个（`.text`）段的字节偏移`69h`处。'
- en: '[PRE38]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: MAP files generated by IDA are compatible with Borland’s Turbo Debugger. The
    principle purpose of *.map* files is to assist in restoring symbol names when
    debugging binaries that may have been stripped.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由IDA生成的MAP文件与Borland的Turbo Debugger兼容。*.map*文件的主要目的是在调试可能已被删除的二进制文件时帮助恢复符号名称。
- en: IDA-Generated ASM Files
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的ASM文件
- en: IDA can generate a *.asm* file from the current database. The general idea is
    to create a file that could be run through an assembler to re-create the underlying
    binary file. IDA attempts to dump enough information, including such things as
    structure layouts, to make successful assembly possible. Whether you will be able
    to successfully assemble the generated *.asm* file depends on a number of factors,
    not the least of which is whether your particular assembler understands the syntax
    IDA uses.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: IDA可以从当前数据库生成一个*.asm*文件。一般思路是创建一个可以通过汇编器运行的文件，以重新创建底层二进制文件。IDA试图转储足够的信息，包括结构布局等，以便成功汇编。您是否能够成功汇编生成的*.asm*文件取决于许多因素，其中最重要的是您的汇编器是否理解IDA使用的语法。
- en: The target assembly language syntax is determined by the Target assembler setting
    found on the Analysis tab under the Options ▸ General menu. By default IDA generates
    an assembly file representing the entire database. However, you may limit the
    scope of the listing by clicking and dragging or using shift-up arrow or shift-down
    arrow to scroll and select the region you wish to dump. In console versions of
    IDA, you would utilize the `Anchor` (alt-L) command to set an anchor point at
    the start of a selection region and then use the arrow keys to extend the size
    of the region.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 目标汇编语言语法由“选项”▸“常规”菜单下的“分析”选项卡中的目标汇编器设置确定。默认情况下，IDA会生成一个代表整个数据库的汇编文件。然而，您可以通过点击和拖动或使用shift-up箭头或shift-down箭头滚动并选择您希望转储的区域来限制列表的范围。在IDA的控制台版本中，您将使用`锚点`（alt-L）命令在所选区域的开始设置一个锚点，然后使用箭头键来扩展区域的大小。
- en: IDA-Generated INC Files
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的INC文件
- en: An INC (include) file contains definitions of data structures and enumerated
    datatypes. This is essentially a dump of the contents of the Structures windows
    in a form suitable for consumption by an assembler.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: INC（包含）文件包含数据结构和枚举数据类型的定义。这本质上是将结构窗口的内容以适合汇编器消费的形式导出的一个转储。
- en: IDA-Generated LST Files
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的LST文件
- en: An LST file is nothing more than a text file dump of the contents of the IDA
    disassembly window. You can narrow the scope of the generating listing by selecting
    a range of addresses to dump, as described previously for ASM files.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: LST文件不过是IDA反汇编窗口内容的文本文件转储。你可以通过选择要转储的地址范围来缩小生成列表的范围，正如之前为ASM文件所描述的那样。
- en: IDA-Generated EXE Files
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的EXE文件
- en: While this is the most promising menu option, it unfortunately is also the most
    crippled. In a nutshell, it doesn’t work for most file types, and you can expect
    to receive an error message stating, “This type of output file is not supported.”
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是最有前途的菜单选项，但遗憾的是它也是最不健全的。简而言之，它对大多数文件类型不起作用，你可能会收到一个错误消息，指出，“不支持此类输出文件。”
- en: While this would be an ideal capability for a patcher, in general it is very
    difficult to regenerate executable files from an IDA database. The information
    that you are presented with in an IDA database is comprised primarily of the contents
    of the sections that make up the original input file. In many cases, however,
    IDA does not process every section of an input file, and certain information is
    lost when the file is loaded into the database, making generation of an executable
    from the database impossible. The simplest example of such loss is the fact that
    IDA does not load the resource (`.rsrc`) section of PE files by default, which
    makes restoration of the resource section from the database impossible.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于修补器来说是一个理想的功能，但通常从IDA数据库中重新生成可执行文件是非常困难的。你在一个IDA数据库中看到的信息主要由组成原始输入文件的段的内容组成。然而，在许多情况下，IDA并不处理输入文件的每个部分，当文件被加载到数据库中时，某些信息会丢失，这使得从数据库中生成可执行文件成为不可能。这种损失的最简单例子是，IDA默认不加载PE文件的资源（`.rsrc`）部分，这使得从数据库中恢复资源部分成为不可能。
- en: In other cases, IDA processes information from the original binary but does
    not make it easily accessible in its original form. Examples include symbol tables,
    import tables, and export tables, which would require a fair amount of effort
    to properly reconstruct in order to generate a functional executable file.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，IDA处理原始二进制文件的信息，但并不以原始形式使其易于访问。例如，包括符号表、导入表和导出表，这些需要相当大的努力才能正确重建，以便生成一个功能性的可执行文件。
- en: 'One effort to provide an EXE-generation capability for IDA is the pe_scripts^([[93](#ftn.CHP-14-FN-2)])
    of Atli Mar Gudmundsson. These are a set of IDA scripts for working with PE files.
    One of the scripts is titled *pe_write.idc*, and its goal is to dump a working
    PE image out of an existing database. If you intend to patch a PE file, the proper
    sequence of events for using the scripts is as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为IDA提供EXE生成能力的一个尝试是Atli Mar Gudmundsson的pe_scripts^([[93](#ftn.CHP-14-FN-2))).
    这些是一套用于处理PE文件的IDA脚本。其中有一个脚本名为*pe_write.idc*，其目标是从一个现有的数据库中转储一个可工作的PE镜像。如果你打算修补PE文件，使用脚本的正确事件顺序如下：
- en: Load the desired PE file into IDA. Make sure that you uncheck the **Make imports
    section** option in the loader dialog.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所需的PE文件加载到IDA中。确保你在加载对话框中取消选中**创建导入部分**选项。
- en: Run the included *pe_sections.idc* script to map all sections from the original
    binary into the new database.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行包含的*pe_sections.idc*脚本，将原始二进制文件中的所有部分映射到新数据库中。
- en: Make any desired changes to the database.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对数据库进行任何所需的更改。
- en: Execute the *pe_write.idc* script to dump the database contents to a new PE
    file.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行*pe_write.idc*脚本，将数据库内容转储到新的PE文件中。
- en: Scripting with IDC is the subject of [Chapter 15](ch15.html "Chapter 15. IDA
    Scripting").
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDC进行脚本编写是[第15章](ch15.html "第15章。IDA脚本")的主题。
- en: IDA-Generated DIF Files
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA生成的DIF文件
- en: 'An IDA DIF file is a plaintext file that lists all bytes that have been modified
    within an IDA database. This is the most useful file format if your goal is to
    patch an original binary based on changes made to an IDA database. The format
    of the file is quite simple, as shown in the example *.dif* file here:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: IDA DIF文件是一个明文文件，列出了在IDA数据库中已修改的所有字节。如果你的目标是基于对IDA数据库所做的更改修补原始二进制文件，这是最有用的文件格式。文件格式相当简单，如这里示例的*.dif*文件所示：
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The file includes a one-line header comment followed by the name of the original
    binary file and then a list of bytes within the file that have changed. Each change
    line specifies the file offset (not virtual address) of the changed byte, the
    original value of the byte, and the current value of the byte within the database.
    In this example, the database for *dif_example.exe* has been modified at four
    locations corresponding to byte offsets `0x2F8`–`0x2FB` within the original file.
    It is a trivial task to write a program to parse IDA *.dif* files and apply the
    changes to the original binary file to generate a patched version of the binary.
    One such utility is available at the companion website for this book.^([[94](#ftn.CHP-14-FN-3)])
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含一行头部注释，随后是原始二进制文件的名称，然后是文件中已更改的字节列表。每一行更改指定了更改字节的文件偏移量（不是虚拟地址），原始字节的值以及数据库中当前字节的值。在这个例子中，*dif_example.exe*
    的数据库在原始文件中的四个位置被修改，对应于字节偏移量 `0x2F8`–`0x2FB`。编写一个程序来解析 IDA *.dif* 文件并将更改应用到原始二进制文件以生成修补版本的二进制文件是一个简单任务。此类实用程序可在本书的配套网站上找到。[94](#ftn.CHP-14-FN-3)]
- en: IDA-Generated HTML Files
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDA 生成的 HTML 文件
- en: IDA takes advantage of the markup capabilities available with HTML in order
    to generate colorized disassembly listings. An IDA-generated HTML file is essentially
    an LST file with HTML tags added to produce a listing that is colored similarly
    to the actual IDA disassembly window. Unfortunately, the generated HTML files
    do not contain any hyperlinks that would make navigating the file any easier than
    if one used a standard text listing. For example, one useful feature would be
    the addition of hyperlinks to all name references, which would make following
    name references as simple as following a link.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 利用 HTML 提供的标记功能来生成彩色反汇编列表。一个由 IDA 生成的 HTML 文件本质上是一个带有 HTML 标签的 LST 文件，以产生一个与实际
    IDA 反汇编窗口颜色相似的列表。不幸的是，生成的 HTML 文件不包含任何超链接，这会使导航文件比使用标准文本列表更容易。例如，一个有用的功能是添加所有名称引用的超链接，这将使跟踪名称引用变得像跟随链接一样简单。
- en: '* * *'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[93](#CHP-14-FN-2)]) See [http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip](http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[93](#CHP-14-FN-2)]) 查看 [http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip](http://www.hex-rays.com/idapro/freefiles/pe_scripts.zip)。
- en: ^([[94](#CHP-14-FN-3)]) See [http://www.idabook.com/chapter14/ida_patcher.c](http://www.idabook.com/chapter14/ida_patcher.c).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[94](#CHP-14-FN-3)]) 查看 [http://www.idabook.com/chapter14/ida_patcher.c](http://www.idabook.com/chapter14/ida_patcher.c)。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: IDA is not a binary file editor. Keep that fact in mind anytime you think about
    patching a binary with IDA. However, it is a particularly good tool for helping
    you enter and visualize potential changes. By familiarizing yourself with IDA’s
    full range of features and combining the information that IDA can generate with
    appropriate scripts or external programs, binary patching easily becomes possible.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: IDA 不是一个二进制文件编辑器。每次您考虑使用 IDA 修补二进制文件时，请记住这一点。然而，它是一个特别好的工具，可以帮助您输入和可视化潜在更改。通过熟悉
    IDA 的全部功能，并将 IDA 可以生成的信息与适当的脚本或外部程序结合，二进制修补变得容易可行。
- en: In the coming chapters, we will cover the many ways in which IDA’s capabilities
    can be extended. For anyone interested in making the most out of IDA’s capabilities,
    basic scripting skills and an understanding of IDA’s plug-in architecture are
    essential, as they offer you the capability to add behaviors wherever you feel
    IDA is lacking.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍许多扩展 IDA 功能的方法。对于任何希望充分利用 IDA 功能的人来说，基本的脚本技能和对 IDA 插件架构的理解是必不可少的，因为它们为您提供了在任何您觉得
    IDA 缺乏功能的地方添加行为的能力。
