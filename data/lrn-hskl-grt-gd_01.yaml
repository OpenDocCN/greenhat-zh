- en: Chapter 1. Starting Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 开始
- en: If you’re the horrible sort of person who doesn’t read introductions, you might
    want to go back and read the last section anyway—it explains how to use this book,
    as well as how to load functions with GHC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是不读前言的糟糕类型的人，你可能仍然想回去读最后一节——它解释了如何使用这本书，以及如何使用 GHC 加载函数。
- en: 'First, let’s start GHC’s interactive mode and call some functions, so we can
    get a very basic feel for Haskell. Open a terminal and type **`ghci`**. You will
    be greeted with something like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们启动 GHC 的交互模式并调用一些函数，这样我们就可以对 Haskell 有一个非常基本的了解。打开一个终端并输入 **`ghci`**。你会看到类似这样的内容：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GHCi’s default prompt is `Prelude>`, but we’ll be using `ghci>` as our prompt
    for the examples in this book. To make your prompt match the book’s, enter **`:set
    prompt "ghci> "`** into GHCi. If you don’t want to do this every time you run
    GHCi, create a file called *.ghci* in your home folder and set its contents to
    **`:set prompt "ghci> "`**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 的默认提示符是 `Prelude>`，但我们将使用 `ghci>` 作为本书中示例的提示符。要使你的提示符与本书匹配，请在 GHCi 中输入
    **`:set prompt "ghci> "`**。如果你不想每次运行 GHCi 都这样做，在你的主目录中创建一个名为 *.ghci* 的文件，并将其内容设置为
    **`:set prompt "ghci> "`**。
- en: 'Congratulations, you’re in GHCi! Now let’s try some simple arithmetic:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你进入了 GHCi！现在让我们尝试一些简单的算术：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802506.png.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802506.png.jpg)'
- en: If we use several operators in one expression, Haskell will execute them in
    an order that takes into account the precedence of the operators. For instance,
    `*` has higher precedence than `-`, so `50 * 100 - 4999` is treated as `(50 *
    100) - 4999`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个表达式中使用多个运算符，Haskell 将按照考虑运算符优先级的顺序执行它们。例如，`*` 的优先级高于 `-`，所以 `50 * 100
    - 4999` 被视为 `(50 * 100) - 4999`。
- en: 'We can also use parentheses to explicitly specify the order of operations,
    like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用括号来明确指定运算的顺序，如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Pretty cool, huh? (Yeah, I know it’s not, yet, but bear with me.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷，不是吗？（我知道现在还不是，但请耐心等待。）
- en: One pitfall to watch out for is negative number constants. It’s always best
    to surround these with parentheses wherever they occur in an arithmetic expression.
    For example, entering `5 * -3` will make GHCi yell at you, but entering `5 * (-3)`
    will work just fine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的一个陷阱是负数常量。始终最好在算术表达式中它们出现的地方用括号包围。例如，输入 `5 * -3` 会让 GHCi 大喊大叫，但输入 `5 * (-3)`
    会正常工作。
- en: 'Boolean algebra is also straightforward in Haskell. Like many other programming
    languages, Haskell has the Boolean values `True` and `False`, and uses the `&&`
    operator for conjunction (Boolean *and*), the `||` operator for disjunction (Boolean
    *or*), and the `not` operator to negate a `True` or `False` value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔代数在 Haskell 中也很简单。像许多其他编程语言一样，Haskell 有布尔值 `True` 和 `False`，并使用 `&&` 运算符进行合取（布尔
    *和*），使用 `||` 运算符进行析取（布尔 *或*），以及使用 `not` 运算符来否定 `True` 或 `False` 值：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can test two values for equality or inequality with the `==` and `/=` operators,
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `==` 和 `/=` 运算符测试两个值的相等或不等，如下所示：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Watch out when mixing and matching values, however! If we enter something like
    `5 + "llama"`, we get the following error message:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在混合匹配值时要小心！如果我们输入类似 `5 + "llama"` 的内容，我们会得到以下错误信息：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What GHCi is telling us here is that `"llama"` is not a number, so it does not
    know how to add it to 5\. The `+` operator expects both of its inputs to be numbers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 告诉我们的是 `"llama"` 不是一个数字，所以它不知道如何将 5 加到它上面。`+` 运算符期望它的两个输入都是数字。
- en: 'On the other hand, the `==` operator works on any two items that can be compared,
    with one catch: they both have to be of the same type. For instance, if we tried
    entering `True == 5`, GHCi would complain.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`==` 运算符适用于任何可以比较的两个项目，有一个例外：它们都必须是相同类型的。例如，如果我们尝试输入 `True == 5`，GHCi 会抱怨。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`5 + 4.0` is a valid expression, because although `4.0` isn’t an integer, `5`
    is sneaky and can act like either an integer or a floating-point number. In this
    case, `5` adapts to match the type of the floating-point value `4.0`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`5 + 4.0` 是一个有效的表达式，因为虽然 `4.0` 不是一个整数，但 `5` 很狡猾，可以像整数或浮点数一样行动。在这种情况下，`5` 适应以匹配浮点值
    `4.0` 的类型。'
- en: We’ll take a closer look at types a bit later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更仔细地看看类型。
- en: Calling Functions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802508.png.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802508.png.jpg)'
- en: You may not have realized it, but we’ve actually been using functions this whole
    time. For instance, `*` is a function that takes two numbers and multiplies them.
    As you’ve seen, we apply (or *call*) it by sandwiching it between the two numbers
    we want to multiply. This is called an *infix* function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有意识到，但我们实际上一直在使用函数。例如，`*`是一个接受两个数字并将它们相乘的函数。正如你所看到的，我们通过将其夹在我们要相乘的两个数字之间来应用（或*调用*）它。这被称为中缀函数。
- en: 'Most functions, however, are *prefix* functions. When calling prefix functions
    in Haskell, the function name comes first, then a space, then its parameters (also
    separated by spaces). As an example, we’ll try calling one of the most boring
    functions in Haskell, `succ`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数函数都是前缀函数。在Haskell中调用前缀函数时，函数名首先出现，然后是一个空格，然后是其参数（也用空格分隔）。例如，我们将尝试调用Haskell中最无聊的函数之一，`succ`：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `succ` function takes one parameter that can be anything that has a well-defined
    successor, and returns that value. The successor of an integer value is just the
    next higher number.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`succ`函数接受一个参数，可以是任何有明确定义的后继的值，并返回该值。整数值的后继只是下一个更大的数。'
- en: 'Now let’s call two prefix functions that take multiple parameters, `min` and
    `max`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用两个接受多个参数的前缀函数，`min`和`max`：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `min` and `max` functions each take two parameters that can be put in some
    order (like numbers!), and they return the one that’s smaller or larger, respectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`min`和`max`函数各自接受两个参数，可以将它们按某种顺序排列（如数字！），并分别返回较小或较大的值。'
- en: Function application has the highest precedence of all the operations in Haskell.
    In other words, these two statements are equivalent.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用在Haskell中具有所有操作的最高优先级。换句话说，这两个语句是等价的。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that if we want to get the successor of `9 * 10`, we couldn’t simply
    write
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想得到`9 * 10`的后继，我们不能简单地写下
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because of the precedence of operations, this would evaluate as the successor
    of 9 (which is 10) multiplied by 10, yielding 100\. To get the result we want,
    we need to instead enter
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运算符的优先级，这将评估为9的后继（即10）乘以10，得到100。要得到我们想要的结果，我们需要输入
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This returns 91.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了91。
- en: 'If a function takes two parameters, we can also call it as an infix function
    by surrounding its name with backticks (`` ` ``). For instance, the `div` function
    takes two integers and executes an integral division, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数接受两个参数，我们也可以通过在其名称周围加上反引号（`` ` ``）将其作为中缀函数调用。例如，`div`函数接受两个整数并执行整数除法，如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, when we call it like that, there may be some confusion as to which
    number is being divided by which. By using backticks, we can call it as an infix
    function, and suddenly it seems much clearer:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们这样称呼它时，可能会对哪个数字被哪个数字除产生一些混淆。通过使用反引号，我们可以将其称为中缀函数，突然间它似乎变得清晰多了：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Many programmers who are used to imperative languages tend to stick to the notion
    that parentheses should denote function application, and they have trouble adjusting
    to the Haskell way of doing things. Just remember, if you see something like `bar
    (bar 3)`, it means that we’re first calling the `bar` function with `3` as the
    parameter, then passing that result to the `bar` function again. The equivalent
    expression in C would be something like `bar(bar(3))`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多习惯于命令式语言的程序员倾向于坚持括号表示函数应用的观点，他们难以适应Haskell的方式。只需记住，如果你看到类似`bar (bar 3)`的东西，这意味着我们首先以`3`作为参数调用`bar`函数，然后将该结果传递给`bar`函数。在C语言中，等效的表达式可能是`bar(bar(3))`。
- en: Baby's First Functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宝宝的第一函数
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802510.png.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802510.png.jpg)'
- en: 'The syntax of a function definition is similar to that of a function call:
    the function name is followed by parameters, which are separated by spaces. But
    then the parameter list is followed by the `=` operator, and the code that makes
    up the body of the function follows that.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的语法与函数调用类似：函数名后面跟着参数，参数之间用空格分隔。然后参数列表后面跟着`=`运算符，函数体由随后的代码组成。
- en: 'As an example, we’ll write a simple function that takes a number and multiplies
    it by two. Open up your favorite text editor and type in the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个简单的函数，该函数接受一个数字并将其乘以2。打开你最喜欢的文本编辑器，输入以下内容：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save this file as *baby.hs*. Now run `ghci`, making sure that *baby.hs* is
    in your current directory. Once in GHCi, enter **`:l baby`** to load the file.
    Now we can play with our new function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 *baby.hs*。现在运行 `ghci`，确保 *baby.hs* 文件位于你的当前目录中。一旦进入 GHCi，输入 **`:l baby`**
    来加载文件。现在我们可以玩我们的新函数：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because `+` works on integers as well as on floating point numbers (indeed,
    on anything that can be considered a number), our function also works with any
    of these types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `+` 既可以作用于整数，也可以作用于浮点数（实际上，作用于任何可以被认为是数字的东西），所以我们的函数也可以与这些类型中的任何一种一起使用。
- en: 'Now let’s make a function that takes two numbers, multiplies each by two, then
    adds them together. Append the following code to *baby.hs*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个函数，它接受两个数字，将每个数字乘以二，然后将它们相加。将以下代码添加到 *baby.hs* 文件中：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functions in Haskell don’t have to be defined in any particular order, so it
    doesn’t matter which function comes first in the *baby.hs* file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中的函数不必按任何特定顺序定义，所以 *baby.hs* 文件中哪个函数先来并不重要。
- en: 'Now save the file, and enter **`:l baby`** in GHCi to load your new function.
    Testing this function yields predictable results:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件，并在 GHCi 中输入 **`:l baby`** 来加载你的新函数。测试这个函数会产生可预测的结果：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Functions that you define can also call each other. With that in mind, we could
    redefine `doubleUs` in the following way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义的函数也可以相互调用。考虑到这一点，我们可以按以下方式重新定义 `doubleUs`：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a very simple example of a common pattern you will see when using Haskell:
    Basic, obviously correct functions can be combined to form more complex functions.
    This is a great way to avoid code repetition. For example, what if one day mathematicians
    figure out that 2 and 3 are actually the same, and you have to change your program?
    You could just redefine `doubleMe` to be `x + x + x`, and since `doubleUs` calls
    `doubleMe`, it would now also automatically work correctly in this strange new
    world where 2 is equal to 3.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用 Haskell 时你会看到的一个常见模式的简单示例：基本且显然正确的函数可以组合成更复杂的函数。这是一种避免代码重复的好方法。例如，如果有一天数学家发现
    2 和 3 实际上是相同的，并且你必须更改你的程序，你只需将 `doubleMe` 重新定义为 `x + x + x`，由于 `doubleUs` 调用了
    `doubleMe`，它现在也会在这个奇怪的、新的世界里自动正确地工作，在这个世界里 2 等于 3。
- en: Now let’s write a function that multiplies a number by 2, but only if that number
    is less than or equal to 100 (because numbers bigger than 100 are big enough as
    it is!).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个函数，该函数将一个数字乘以 2，但仅当该数字小于或等于 100 时（因为大于 100 的数字已经足够大了！）。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example introduces Haskell’s `if` statement. You’re probably already familiar
    with if statements from other languages, but what makes Haskell’s unique is that
    the `else` part is mandatory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子介绍了 Haskell 的 `if` 语句。你可能已经从其他语言中熟悉了 if 语句，但 Haskell 的独特之处在于 `else` 部分是强制性的。
- en: Programs in imperative languages are essentially a series of steps that the
    computer executes when the program is run. When there is an `if` statement that
    doesn’t have a corresponding `else`, and the condition isn’t met, then the steps
    that fall under the `if` statement don’t get executed. Thus, in imperative languages,
    an `if` statement can just do nothing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式语言中的程序在程序运行时，计算机执行一系列步骤。当存在没有相应 `else` 的 `if` 语句且条件不满足时，那么属于 `if` 语句的步骤就不会被执行。因此，在命令式语言中，`if`
    语句可以什么也不做。
- en: 'On the other hand, a Haskell program is a collection of functions. Functions
    are used to transform data values into result values, and every function should
    return some value, which can in turn be used by another function. Since every
    function has to return something, this implies that every `if` has to have a corresponding
    `else`. Otherwise, you could write a function that has a return value when a certain
    condition is met but doesn’t have one when that condition isn’t met! Briefly:
    Haskell’s `if` is an *expression* that must return a value, and not a statement.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Haskell 程序是一系列函数的集合。函数用于将数据值转换为结果值，每个函数都应该返回某个值，这个值反过来又可以被另一个函数使用。由于每个函数都必须返回某些值，这意味着每个
    `if` 都必须有一个相应的 `else`。否则，你可能会编写一个在满足某个条件时具有返回值但在不满足该条件时没有返回值的函数！简而言之：Haskell 的
    `if` 是一个必须返回值的 *表达式*，而不是一个语句。
- en: 'Let’s say we want a function that adds one to every number that would be produced
    by our previous `doubleSmallNumber` function. The body of this new function would
    look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个函数，该函数将 `doubleSmallNumber` 函数生成的每个数字加一。这个新函数的主体看起来像这样：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the placement of the parentheses. If we had omitted them, the function
    would only add one if `x` is less than or equal to 100\. Also note the apostrophe
    (`'`) at the end of the function’s name. The apostrophe doesn’t have any special
    meaning in Haskell’s syntax, which means it’s a valid character to use in a function
    name. We usually use `'` to denote either a *strict* version of a function (i.e.,
    one that isn’t lazy), or a slightly modified version of a function or variable
    with a similar name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意括号的放置。如果我们省略了它们，函数只会添加一个，如果 `x` 小于或等于 100。还要注意函数名末尾的单引号 (`'`)。单引号在 Haskell
    的语法中没有特殊含义，这意味着它是一个有效的函数名字符。我们通常使用 `'` 来表示函数的*严格*版本（即不是懒加载的版本），或者是一个与类似名称的函数或变量的略微修改版本。
- en: 'Since `''` is a valid character for function names, we can write a function
    that looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单引号 `'` 是函数名中的一个有效字符，我们可以编写一个看起来像这样的函数：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are two things to note here. The first is that we didn’t capitalize *Conan*
    in the name of the function. In Haskell, functions can’t begin with capital letters.
    (We’ll see why a bit later.) The second thing to note is that this function doesn’t
    take any parameters. When a function doesn’t take any parameters, we usually call
    it a *definition* or a *name*. Because we cannot change what names (or functions)
    mean once we have defined them, the function `conanO'Brien` and the string `"It's
    a-me, Conan O'Brien!"` can be used interchangeably.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两点需要注意。首先，我们没有在函数名中将 *Conan* 大写。在 Haskell 中，函数不能以大写字母开头。（我们稍后会看到原因。）其次，需要注意的是，这个函数没有接受任何参数。当一个函数不接受任何参数时，我们通常称其为*定义*或*名称*。因为我们一旦定义了名称（或函数），就不能更改它们的意思，所以函数
    `conanO'Brien` 和字符串 `"It's a-me, Conan O'Brien!"` 可以互换使用。
- en: An Intro to Lists
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表简介
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802512.png.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802512.png.jpg)'
- en: Lists in Haskell are *homogeneous* data structures, which means they store several
    elements of the same type. We can have a list of integers or a list of characters,
    for example, but we can’t have a list made up of both integers and characters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中的列表是*同构*数据结构，这意味着它们存储相同类型的多个元素。例如，我们可以有一个整数列表或字符列表，但不能有一个同时包含整数和字符的列表。
- en: 'Lists are surrounded by square brackets, and the list values are separated
    by commas:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表被方括号包围，列表值由逗号分隔：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the `let` keyword to define a name in GHCi. Entering `let a = 1` in GHCi
    is equivalent to writing `a = 1` in a script, then loading it with `:l`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `let` 关键字在 GHCi 中定义名称。在 GHCi 中输入 `let a = 1` 等同于在脚本中写入 `a = 1`，然后使用 `:l`
    加载它。
- en: Concatenation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'One of the most common operations when working with lists is concatenation.
    In Haskell, this is done using the `++` operator:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理列表时，最常见的操作之一是连接。在 Haskell 中，这是使用 `++` 操作符完成的：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Haskell, strings are really just lists of characters. For example, the string
    `"hello"` is actually the same as the list `['h','e','l','l','o']`. Because of
    this, we can use list functions on strings, which is really handy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，字符串实际上只是字符列表。例如，字符串 `"hello"` 实际上与列表 `['h','e','l','l','o']` 相同。正因为如此，我们可以在字符串上使用列表函数，这非常方便。
- en: Be careful when repeatedly using the `++` operator on long strings. When you
    put together two lists, Haskell has to walk through the entire first list (the
    one on the left side of `++`). That’s not a problem when dealing with smaller
    lists, but appending something to the end of a list with fifty million entries
    is going to take a while.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当反复在长字符串上使用 `++` 操作符时要小心。当你组合两个列表时，Haskell 必须遍历整个第一个列表（`++` 左侧的列表）。当处理较小的列表时，这没问题，但将内容追加到包含五千万条记录的列表末尾将花费一些时间。
- en: 'However, adding something to the beginning of a list is a nearly instantaneous
    operation. We do this with the `:` operator (also called the *cons* operator):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将内容添加到列表的开头是一个几乎瞬时的操作。我们使用 `:` 操作符（也称为*cons*操作符）来完成这项操作：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how in the first example, `:` takes a character and a list of characters
    (a string) as its arguments. Similarly, in the second example, `:` takes a number
    and a list of numbers. The first argument to the `:` operator always needs to
    be a single item of the same type as the values in the list it’s being added to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第一个例子中，`:` 接受一个字符和一个字符列表（字符串）作为其参数。同样，在第二个例子中，`:` 接受一个数字和一个数字列表。`:` 操作符的第一个参数始终需要是列表中值的单个项目，并且与它被添加到的列表中的值类型相同。
- en: 'The `++` operator, on the other hand, always takes two lists as arguments.
    Even if you’re only adding a single element to the end of a list with `++`, you
    still have to surround that item with square brackets, so Haskell will treat it
    like a list:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`++` 操作符始终接受两个列表作为参数。即使你只使用 `++` 向列表末尾添加单个元素，你也必须用方括号将其包围，这样 Haskell 才会将其视为列表：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing `[1,2,3,4] ++ 5` is wrong, because both parameters to `++` should be
    lists, and `5` isn’t a list; it’s a number.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `[1,2,3,4] ++ 5` 写作是错误的，因为 `++` 的两个参数都应该列表，而 `5` 不是一个列表；它是一个数字。
- en: Interestingly, in Haskell, `[1,2,3]` is just syntactic sugar for `1:2:3:[]`.
    `[]` is an empty list. If we prepend `3` to that, it becomes `[3]`. Then if we
    prepend `2` to that, it becomes `[2,3]`, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在 Haskell 中，`[1,2,3]` 只是 `1:2:3:[]` 的语法糖。`[]` 是一个空列表。如果我们向其中添加 `3`，它就变成了
    `[3]`。然后如果我们向其中添加 `2`，它就变成了 `[2,3]`，依此类推。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`[]`, `[[]]` and `[[],[],[]]` are all different things. The first is an empty
    list, the second is a list that contains one empty list, and the third is a list
    that contains three empty lists.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`、`[[]]` 和 `[[],[],[]]` 都是不同的事物。第一个是一个空列表，第二个是一个包含一个空列表的列表，第三个是一个包含三个空列表的列表。'
- en: Accessing List Elements
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问列表元素
- en: 'If you want to get an element of a list by index, use the `!!` operator. As
    with most programming languages, the indices start at 0:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过索引获取列表中的元素，请使用 `!!` 操作符。与大多数编程语言一样，索引从 0 开始：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, if you try (say) to get the sixth element from a list that only has
    four elements, you’ll get an error, so be careful!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试（比如说）从一个只有四个元素的列表中获取第六个元素，你会得到一个错误，所以请小心！
- en: Lists Inside Lists
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表嵌套
- en: Lists can contain lists as elements, and lists can contain lists that contain
    lists, and so on. . . .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含列表作为元素，列表可以包含包含列表的列表，依此类推。 . . .
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Lists within a list can be of different lengths, but they can’t be of different
    types. Just like you can’t have a list that has some characters and some numbers
    as elements, you also can’t have a list that contains some lists of characters
    and some lists of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的列表可以有不同的长度，但它们不能有不同的类型。就像你不能有一个包含一些字符和一些数字作为元素的列表一样，你也不能有一个包含一些字符列表和一些数字列表的列表。
- en: Comparing Lists
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较列表
- en: Lists can be compared if the items they contain can be compared. When using
    `<`, `<=`, `>=` and `>` to compare two lists, they are compared in lexicographical
    order. This means that first the two list heads are compared, and if they’re equal,
    the second elements are compared. If the second elements are also equal, the third
    elements are compared, and so on, until differing elements are found. The order
    of the two lists is determined by the order of the first pair of differing elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中包含的项可以进行比较，则可以比较列表。当使用 `<`、`<=`、`>=` 和 `>` 来比较两个列表时，它们按字典顺序进行比较。这意味着首先比较两个列表的头部，如果它们相等，则比较第二个元素。如果第二个元素也相等，则比较第三个元素，依此类推，直到找到不同的元素。两个列表的顺序由第一对不同元素的顺序决定。
- en: For example, when we evaluate `[3,4,2] < [3,4,3]`, Haskell sees that `3` and
    `3` are equal, so it compares `4` and `4`. Those two are also equal, so it compares
    `2` and `3`. `2` is smaller than `3`, so it comes to the conclusion that the first
    list is smaller than the second one. The same goes for `<=`, `>=`, and `>`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们评估 `[3,4,2] < [3,4,3]` 时，Haskell 会看到 `3` 和 `3` 是相等的，所以它比较 `4` 和 `4`。这两个也是相等的，所以它比较
    `2` 和 `3`。`2` 小于 `3`，所以它得出结论，第一个列表小于第二个列表。对于 `<=`、`>=` 和 `>` 也是如此。
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Also, a nonempty list is always considered to be greater than an empty one.
    This makes the ordering of two lists well defined in all cases, including when
    one is a proper initial segment of the other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，非空列表始终被认为大于空列表。这使得两个列表的排序在所有情况下都定义良好，包括当一个列表是另一个列表的正确初始段时。
- en: More List Operations
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多列表操作
- en: Here are some more basic list functions, followed by examples of their usage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更基本的列表函数，以及它们使用示例。
- en: 'The `head` function takes a list and returns its head, or first element:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`head` 函数接受一个列表并返回其头部，或第一个元素：'
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `tail` function takes a list and returns its tail. In other words, it chops
    off a list’s head:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 函数接受一个列表并返回其尾部。换句话说，它切掉了列表的头部：'
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `last` function returns a list’s last element:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`last` 函数返回列表的最后一个元素：'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `init` function takes a list and returns everything except its last element:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 函数接受一个列表并返回除了其最后一个元素之外的所有内容：'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To help us visualize these functions, we can think of a list as a monster,
    like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们可视化这些函数，我们可以将列表想象成一个怪物，如下所示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802514.png.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802514.png.jpg)'
- en: But what happens if we try to get the head of an empty list?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们尝试获取一个空列表的头部会发生什么呢？
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Oh my—it blows up in our face! If there’s no monster, it doesn’t have a head.
    When using `head`, `tail`, `last`, and `init`, be careful not to use them on empty
    lists. This error cannot be caught at compile time, so it’s always good practice
    to take precautions against accidentally telling Haskell to give you elements
    from an empty list.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 哇——它在我们面前爆炸了！如果没有怪物，它就没有头部。当使用`head`、`tail`、`last`和`init`时，要小心不要在空列表上使用它们。这个错误在编译时无法捕获，因此总是好的做法是预防意外地让Haskell给你从空列表中获取元素。
- en: 'The `length` function takes a list and returns its length:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`函数接受一个列表并返回其长度：'
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `null` function checks if a list is empty. If it is, it returns `True`,
    otherwise it returns `False`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`函数检查列表是否为空。如果是，它返回`True`，否则返回`False`。'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `reverse` function reverses a list:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`函数反转列表：'
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `take` function takes a number and a list. It extracts the specified number
    elements from the beginning of the list, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`take`函数接受一个数字和一个列表。它从列表的开头提取指定数量的元素，如下所示：'
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we try to `take` more elements than there are in the list, Haskell just returns
    the entire list. If we `take` 0 elements, we get an empty list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试获取比列表中元素更多的元素，Haskell会返回整个列表。如果我们获取0个元素，我们会得到一个空列表。
- en: 'The `drop` function works in a similar way, only it drops (at most) the specified
    number of elements from the beginning of a list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop`函数的工作方式类似，但它只从列表的开头删除（最多）指定数量的元素：'
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `maximum` function takes a list of items that can be put in some kind of
    order and returns the largest element. The `minimum` function is similar, but
    it returns the smallest item:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`maximum`函数接受可以按某种顺序排列的项目列表，并返回最大元素。`minimum`函数类似，但它返回最小项：'
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `sum` function takes a list of numbers and returns their sum. The `product`
    function takes a list of numbers and returns their product:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数接受一个数字列表并返回它们的和。`product`函数接受一个数字列表并返回它们的乘积：'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `elem` function takes an item and a list of items and tells us if that item
    is an element of the list. It’s usually called as an infix function because it’s
    easier to read that way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`elem`函数接受一个项目和项目列表，并告诉我们该项目是否是列表的元素。它通常被用作中缀函数，因为这样更容易阅读。'
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Texas Ranges
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 德克萨斯范围
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802516.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802516.png.jpg)'
- en: What if we need a list made up of the numbers between 1 and 20? Sure, we could
    just type them all out, but that’s not a solution for gentlemen who demand excellence
    from their programming languages. Instead, we’ll use *ranges*. Ranges are used
    to make lists composed of elements that can be *enumerated*, or counted off in
    order.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要一个由1到20之间的数字组成的列表呢？当然，我们可以直接输入它们，但这不是对那些对他们的编程语言有卓越要求的绅士们的解决方案。相反，我们将使用*范围*。范围用于创建由可以*编号*或按顺序计数的元素组成的列表。
- en: 'For example, numbers can be enumerated: 1, 2, 3, 4, and so on. Characters can
    also be enumerated: the alphabet is an enumeration of characters from A to Z.
    Names, however, can’t be enumerated. (What comes after “John?” I don’t know!)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字可以进行编号：1, 2, 3, 4，等等。字符也可以进行编号：字母表是从A到Z的字符编号。然而，名字却不能进行编号。（“John”之后是什么？我不知道！）
- en: To make a list containing all the natural numbers from 1 to 20, you can just
    type `[1..20]`. In Haskell, this is exactly the same as typing `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`.
    The only difference between the two is that writing out long enumeration sequences
    manually is stupid.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含从1到20的所有自然数的列表，你只需输入`[1..20]`。在Haskell中，这与输入`[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`完全相同。这两者之间的唯一区别是手动编写长的编号序列是愚蠢的。
- en: 'Here are a few more examples:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的例子：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also specify a *step* between items in your range. What if we want
    a list of every even number between 1 and 20? Or every third number between 1
    and 20? It’s simply a matter of separating the first two elements with a comma
    and specifying the upper limit:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定范围中元素之间的*步长*。如果我们想要一个包含1到20之间所有偶数的列表，或者1到20之间每隔一个数的列表呢？这只是一个用逗号分隔前两个元素并指定上限的问题：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While they are pretty convenient, ranges with steps aren’t always as smart as
    people expect them to be. For example, you can’t enter `[1,2,4,8,16..100]` and
    expect to get all the powers of 2 that are no greater than 100\. For one thing,
    you can only specify a single step size. Also, some sequences that aren’t arithmetic
    can’t be specified unambiguously by giving only their first few terms.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们非常方便，但带有步长的范围并不总是像人们期望的那样智能。例如，你不能输入 `[1,2,4,8,16..100]` 并期望得到所有不大于100的2的幂。首先，你只能指定一个步长大小。此外，一些不是算术的序列不能仅通过给出它们的前几个项来明确指定。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To make a list with all the numbers from 20 down to 1, you can’t just type `[20..1]`,
    you have to type `[20,19..1]`. When you use a range without steps (like `[20..1]`),
    Haskell will start with an empty list and then keep increasing the starting element
    by one until it reaches or surpasses the end element in the range. Because 20
    is already greater than 1, the result will just be an empty list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含从20到1的所有数字的列表，你不能只输入 `[20..1]`，你必须输入 `[20,19..1]`。当你使用不带步长的范围（如 `[20..1]`）时，Haskell将从空列表开始，然后不断将起始元素增加1，直到它达到或超过范围的结束元素。因为20已经大于1，所以结果将只是一个空列表。
- en: 'You can also use ranges to make infinite lists by not specifying an upper limit.
    For example, let’s create a list containing the first 24 multiples of 13\. Here’s
    one way to do it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过不指定上限来使用范围创建无限列表。例如，让我们创建一个包含前24个13的倍数的列表。这是其中一种方法：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But there’s actually a better way—using an infinite list:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上有一个更好的方法——使用一个无限列表：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Because Haskell is *lazy*, it won’t try to evaluate the entire infinite list
    immediately (which is good because it would never finish anyway). Instead, it
    will wait to see which elements you need to get from that infinite list. In the
    above example, it sees that you just want the first 24 elements, and it gladly
    obliges.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Haskell是*惰性*的，它不会立即尝试评估整个无限列表（这是好事，因为它永远不会完成）。相反，它将等待查看你需要从那个无限列表中获取哪些元素。在上面的例子中，它看到你只需要前24个元素，并且它很乐意满足你的要求。
- en: 'Here are a few functions that can be used to produce long or infinite lists:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以用来生成长列表或无限列表的函数：
- en: '`cycle` takes a list and replicates its elements indefinitely to form an infinite
    list. If you try to display the result, it will go on forever, so make sure to
    slice it off somewhere:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle`函数接受一个列表并无限复制其元素以形成一个无限列表。如果你尝试显示结果，它将永远继续，所以请确保在某个地方将其切片：'
- en: '[PRE45]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`repeat` takes an element and produces an infinite list of just that element.
    It’s like cycling a list with only one element:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`函数接受一个元素并生成一个只包含该元素的无限列表。这就像用一个只有一个元素的列表进行循环：'
- en: '[PRE46]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`replicate` is an easier way to create a list composed of a single item. It
    takes the length of the list and the item to replicate, as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicate`是一个创建由单个元素组成的列表的更简单方法。它接受列表的长度和要复制的元素，如下所示：'
- en: '[PRE47]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'One final note about ranges: watch out when using them with floating-point
    numbers! Because floating-point numbers, by their nature, only have finite precision,
    using them in ranges can yield some pretty funky results, as you can see here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关于范围的最后一点：在使用浮点数时要小心！因为浮点数，由于其本质，只有有限的精度，所以在范围内使用它们可能会得到一些相当奇怪的结果，就像你在这里看到的那样：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I'm a List Comprehension
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我是一个列表推导
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802518.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802518.png)'
- en: '*List comprehensions* are a way to filter, transform, and combine lists.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表推导*是一种过滤、转换和组合列表的方法。'
- en: 'They’re very similar to the mathematical concept of *set comprehensions*. Set
    comprehensions are normally used for building sets out of other sets. An example
    of a simple set comprehension is: { 2 · *x*|*x* ∈ **N**, *x* ≤ 10}. The exact
    syntax used here isn’t crucial—what’s important is that this statement says, “take
    all the natural numbers less than or equal to 10, multiply each one by 2, and
    use these results to create a new set.”'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 它们与数学中的*集合推导*概念非常相似。集合推导通常用于从其他集合中构建集合。一个简单的集合推导示例是：{ 2 · *x*|*x* ∈ **N**, *x*
    ≤ 10}。这里使用的确切语法并不重要——重要的是这个语句说的是，“取所有小于或等于10的自然数，将每个数乘以2，并使用这些结果创建一个新的集合。”
- en: 'If we wanted to write the same thing in Haskell, we could do something like
    this with list operations: `take 10 [2,4..]`. However, we could also do the same
    thing using list comprehensions, like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在Haskell中写出相同的内容，我们可以使用列表操作：`take 10 [2,4..]`。然而，我们也可以使用列表推导来完成同样的事情，如下所示：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let’s take a closer look at the list comprehension in this example to better
    understand list comprehension syntax.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个例子中的列表推导式，以更好地理解列表推导式的语法。
- en: In `[x*2 | x <- [1..10]]`, we say that we *draw* our elements from the list
    `[1..10]`. `[x <- [1..10]]` means that `x` takes on the value of each element
    that is drawn from `[1..10]`. In other words, we *bind* each element from `[1..10]`
    to `x`. The part before the vertical pipe (`|`) is the *output* of the list comprehension.
    The output is the part where we specify how we want the elements that we’ve drawn
    to be reflected in the resulting list. In this example, we say that we want each
    element that is drawn from the list `[1..10]` to be doubled.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `[x*2 | x <- [1..10]]` 中，我们说我们 *提取* 元素来自列表 `[1..10]`。`[x <- [1..10]]` 意味着
    `x` 取每个从 `[1..10]` 中提取的元素的值。换句话说，我们将 `[1..10]` 中的每个元素 *绑定* 到 `x`。垂直管道（`|`）之前的部分是列表推导式的
    *输出*。输出是我们指定我们希望提取的元素如何在结果列表中反映的部分。在这个例子中，我们说我们希望从列表 `[1..10]` 中提取的每个元素都加倍。
- en: This may seem longer and more complicated than the first example, but what if
    we want to do something more complex than just doubling these numbers? This is
    where list comprehensions really come in handy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来比第一个例子更长更复杂，但如果我们想要做的不仅仅是加倍这些数字，会怎么样呢？这正是列表推导式真正派上用场的地方。
- en: 'For example, let’s add a condition (also called a *predicate*) to our comprehension.
    Predicates go at the end of the list comprehension and are separated from the
    rest of the comprehension by a comma. Let’s say we want only the elements which,
    after being doubled, are greater than or equal to 12:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在我们的理解中添加一个条件（也称为 *谓词*）。谓词位于列表推导式的末尾，并通过逗号与理解的其他部分分开。假设我们只想包含那些在加倍后大于或等于12的元素：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'What if we want all numbers from 50 to 100 whose remainder when divided by
    7 is 3? Easy:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要所有50到100之间，除以7余数为3的数字，会怎样？很简单：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Weeding out parts of lists using predicates is also called *filtering*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用谓词去除列表的部分也称为 *过滤*。
- en: 'Now for another example. Let’s say we want a comprehension that replaces every
    odd number greater than 10 with `"BANG!"`, and every odd number less than 10 with
    `"BOOM!"`. If a number isn’t odd, we throw it out of our list. For convenience,
    we’ll put that comprehension inside a function so we can easily reuse it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看另一个例子。假设我们想要一个理解，将大于10的奇数替换为 `"BANG!"`，将小于10的奇数替换为 `"BOOM!"`。如果一个数字不是奇数，我们就将其从列表中排除。为了方便，我们将这个理解放入一个函数中，这样我们就可以轻松地重用它：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember, if you’re trying to define this function inside GHCi, you have to
    include a `let` before the function name. However, if you’re defining this function
    inside a script and then loading that script into GHCi, you don’t have to mess
    around with `let`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你试图在GHCi中定义这个函数，你必须在函数名之前包含一个 `let`。然而，如果你在脚本中定义这个函数，然后将其加载到GHCi中，你就不需要与
    `let` 糟糕地打交道。
- en: The `odd` function returns `True` when passed an odd number, otherwise it returns
    `False`. The element is included in the list only if all the predicates evaluate
    to `True`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递一个奇数给 `odd` 函数时，它返回 `True`，否则返回 `False`。只有当所有谓词评估为 `True` 时，元素才包含在列表中。
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can include as many predicates as we want, all separated by commas. For
    instance, if we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we’d
    do:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含尽可能多的谓词，所有谓词都由逗号分隔。例如，如果我们想要所有10到20之间的数字，但不包括13、15或19，我们会这样做：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Not only can we have multiple predicates in list comprehensions, we can also
    draw values from several lists. When drawing values from several lists, every
    combination of elements from these lists is reflected in the resulting list:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以在列表推导式中包含多个谓词，还可以从几个列表中提取值。当从几个列表中提取值时，这些列表的所有元素组合都会反映在结果列表中：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `x` is drawn from `[1,2,3]` and `y` is drawn from `[10,100,1000]`. These
    two lists are combined in the following way. First, `x` becomes `1`, and while
    `x` is `1`, `y` takes on every value from `[10,100,1000]`. Because the output
    of the list comprehension is `x+y`, the values `11`, `101`, and `1001` are added
    to the beginning of the resulting list (`1` is added to `10`, `100`, and `1000`).
    After that, `x` becomes `2` and the same thing happens, resulting in the elements
    `12`, `102`, and `1002` being added to the resulting list. The same goes when
    `x` draws the value `3`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`是从`[1,2,3]`中抽取的，而`y`是从`[10,100,1000]`中抽取的。这两个列表以以下方式组合。首先，`x`变为`1`，当`x`为`1`时，`y`取`[10,100,1000]`中的每一个值。因为列表推导式的输出是`x+y`，所以值`11`、`101`和`1001`被添加到结果列表的开头（`1`被添加到`10`、`100`和`1000`）。之后，`x`变为`2`，同样的事情发生，导致元素`12`、`102`和`1002`被添加到结果列表中。当`x`抽取值`3`时，情况也是如此。
- en: In this manner, each element `x` from `[1,2,3]` is combined with each element
    `y` from `[10,100,1000]` in all possible ways, and `x+y` is used to make the resulting
    list from those combinations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，列表`[1,2,3]`中的每个元素`x`都会与列表`[10,100,1000]`中的每个元素`y`以所有可能的方式组合，使用`x+y`来生成这些组合的结果列表。
- en: 'Here’s another example: if we have two lists, `[2,5,10]` and `[8,10,11]`, and
    we want to get the products of all possible combinations of numbers in those lists,
    we could use the following comprehension:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：如果我们有两个列表`[2,5,10]`和`[8,10,11]`，并且我们想要得到那些列表中所有可能数字组合的乘积，我们可以使用以下推导式：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As expected, the length of the new list is 9\. Now, what if we wanted all possible
    products that are more than 50? We can just add another predicate:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，新列表的长度是9。现在，如果我们想得到所有大于50的可能乘积呢？我们只需添加另一个谓词：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For epic hilarity, let’s make a list comprehension that combines a list of adjectives
    and a list of nouns.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到史诗般的幽默效果，让我们创建一个结合形容词列表和名词列表的列表推导式。
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can even use list comprehensions to write our own version of the `length`
    function! We’ll call it `length'`. This function will replace every element in
    a list with `1`, then add them all up with `sum`, yielding the length of the list.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用列表推导式来编写我们自己的`length`函数版本！我们将它称为`length'`。这个函数将列表中的每个元素替换为`1`，然后使用`sum`将它们全部加起来，得到列表的长度。
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here we use underscore (`_`) as a temporary variable to store the items as we
    draw them from the input list, since we don’t actually care about the values.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用下划线（`_`）作为临时变量来存储我们从中提取的项目，因为我们实际上并不关心这些值。
- en: 'Remember, strings are lists too, so we can use list comprehensions to process
    and produce strings. Here’s an example of a function that takes a string and removes
    all the lowercase letters from it:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，字符串也是列表，所以我们可以使用列表推导式来处理和生成字符串。以下是一个函数的示例，它接受一个字符串并从中删除所有小写字母：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The predicate here does all the work. It says that the character will be included
    in the new list only if it’s an element of the list `[''A''..''Z'']`. We can load
    the function in GHCi and test it out:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谓词在这里做了所有的工作。它表示，只有当字符是列表`['A'..'Z']`的元素时，它才会被包含在新列表中。我们可以在GHCi中加载这个函数并测试它：
- en: '[PRE61]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can also create nested list comprehensions if you’re operating on lists
    that contain lists. For example, let’s take a list that contains several lists
    of numbers and remove all the odd numbers without flattening the list:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在操作包含列表的列表，你也可以创建嵌套的列表推导式。例如，让我们取一个包含几个数字列表的列表，并移除所有奇数而不展开列表：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here the output of the outer list comprehension is another list comprehension.
    A list comprehension always results in a list of something, so we know that the
    result here will be a list of lists of numbers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里外层列表推导式的输出是另一个列表推导式。列表推导式总是产生某种列表，所以我们可以知道这里的输出将是一个数字列表的列表。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can split list comprehensions across several lines to improve their readability.
    If you’re not in GHCi, this can be a great help, especially when dealing with
    nested comprehensions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将列表推导式拆分到多行以提高其可读性。如果你不在GHCi中，这可以是一个很大的帮助，尤其是在处理嵌套推导式时。
- en: Tuples
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802520.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802520.png)'
- en: '*Tuples* are used to store several heterogeneous elements as a single value.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*元组*用于存储多个异构元素作为单个值。'
- en: In some ways, tuples are a lot like lists. However, there are some fundamental
    differences. First, as mentioned, tuples are heterogeneous. This means that a
    single tuple can store elements of several different types. Second, tuples have
    a fixed size—you need to know how many elements you’ll be storing ahead of time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，元组与列表非常相似。然而，有一些基本区别。首先，如前所述，元组是异构的。这意味着单个元组可以存储几种不同类型的元素。其次，元组具有固定的大小——你需要提前知道你将存储多少个元素。
- en: 'Tuples are surrounded by parentheses, and their components are separated by
    commas:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 元组被圆括号包围，并且它们的组件由逗号分隔：
- en: '[PRE63]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using Tuples
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元组
- en: 'As an example of when tuples would be useful, let’s think about how we’d represent
    a two-dimensional vector in Haskell. One way would be to use a two item list,
    in the form of `[x,y]`. But suppose we wanted to make a list of vectors, to represent
    the corners of a two-dimensional shape in a coordinate plane. We could just create
    a list of lists, like this: `[[1,2],[8,11],[4,5]]`.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为元组何时有用的例子，让我们考虑在 Haskell 中如何表示二维向量。一种方法是将两个项目列表表示为 `[x,y]`。但是，假设我们想要创建一个向量列表，以表示坐标平面中二维形状的角。我们可以简单地创建一个列表的列表，如下所示：`[[1,2],[8,11],[4,5]]`。
- en: The problem with this method, however, is that we could also make a list like
    `[[1,2],[8,11,5],[4,5]]` and try to use it in the place of a list of vectors.
    Even though it doesn’t make sense as a list of vectors, Haskell has no problem
    with this list appearing wherever the previous list can, since both are of the
    same type (a list of lists of numbers). This could make it more complicated to
    write functions to manipulate vectors and shapes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的问题是我们也可以创建一个列表，如 `[[1,2],[8,11,5],[4,5]]` 并尝试将其用作向量列表。尽管它作为向量列表没有意义，但
    Haskell 没有问题地将此列表出现在之前列表可以出现的地方，因为它们都是同一类型（数字的列表的列表）。这可能会使编写操作向量和形状的函数变得更加复杂。
- en: In contrast, a tuple of size two (also called a *pair*) and a tuple of size
    three (also called a *triple*) are treated as two distinct types, which means
    a list can’t be composed of both pairs and triples. This makes tuples much more
    useful for representing vectors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，大小为二的元组（也称为*对*）和大小为三的元组（也称为*三元组*）被视为两种不同的类型，这意味着列表不能由对和三元组组成。这使得元组在表示向量时非常有用。
- en: 'We can change our vectors to tuples by surrounding them with parentheses instead
    of square brackets, like this: `[(1,2),(8,11),(4,5)]`. Now, if we try to mix pairs
    and triples, we get an error, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用圆括号而不是方括号包围它们来将向量更改为元组，如下所示：`[(1,2),(8,11),(4,5)]`。现在，如果我们尝试混合成对和三元组，我们会得到一个错误，如下所示：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Haskell also considers tuples that have the same length but contain different
    types of data to be distinct types of tuples. For example, you can’t make a list
    of tuples like `[(1,2),("One",2)]`, because the first is a pair of numbers, and
    the second is a pair containing a string followed by a number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 还认为具有相同长度但包含不同类型数据的元组是不同的元组类型。例如，你不能创建一个包含元组的列表，如 `[(1,2),("One",2)]`，因为第一个是数字的对，而第二个是包含字符串后跟数字的对。
- en: 'Tuples can be used to easily represent a wide variety of data. For instance,
    if we wanted to represent someone’s name and age in Haskell, we could use a triple:
    `("Christopher", "Walken", 55)`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以用来轻松地表示各种数据。例如，如果我们想在 Haskell 中表示某人的姓名和年龄，我们可以使用一个三元组：`("Christopher", "Walken",
    55)`。
- en: Remember, tuples are of a fixed size—you should only use them when you know
    in advance how many elements you’ll need. The reason tuples are so rigid in this
    way is that, as mentioned, the size of a tuple is treated as part of its type.
    Unfortunately, this means that you can’t write a general function to append an
    element to a tuple—you’d have to write a function for appending to a pair (to
    produce a triple), another one for appending to a triple (to produce a 4-tuple),
    another one for appending to a 4-tuple, and so on.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，元组的大小是固定的——你应该只在事先知道你需要多少个元素时才使用它们。元组之所以如此严格，是因为，如前所述，元组的大小被视为其类型的一部分。不幸的是，这意味着你不能编写一个通用的函数来向元组追加元素——你需要为追加到对（以产生三元组）编写一个函数，为追加到三元组（以产生四元组）编写另一个函数，为追加到四元组编写另一个函数，依此类推。
- en: Like lists, tuples can be compared with each other if their components can be
    compared. However, unlike lists, you can’t compare two tuples of different sizes.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，如果它们的组件可以比较，元组可以相互比较。然而，与列表不同，你不能比较不同大小的两个元组。
- en: 'Although there are singleton lists, there’s no such thing as a singleton tuple.
    It makes sense when you think about it: a singleton tuple’s properties would simply
    be those of the value it contains, so distinguishing a new type wouldn’t give
    us any benefit.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在单元素列表，但没有单元素元组。当你这么想的时候，这是有道理的：单元素元组的属性将仅仅是它包含的值的属性，所以区分新的类型不会给我们带来任何好处。
- en: Using Pairs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对
- en: 'Storing data in pairs is very common in Haskell, and there are some useful
    functions in place to manipulate them. Here are two functions that operate on
    pairs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，以对的形式存储数据非常常见，并且有一些有用的函数来操作它们。以下是对对进行操作的两种函数：
- en: '`fst` takes a pair and returns its first component:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fst`接受一个对并返回其第一个组件：'
- en: '[PRE65]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`snd` takes a pair and—surprise!—returns its second component:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snd`接受一个对并——惊喜！——返回其第二个组件：'
- en: '[PRE66]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These functions only operate on pairs. They won’t work on triples, 4-tuples,
    5-tuples, etc. We’ll go over extracting data from tuples in different ways a bit
    later.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数只对对进行操作。它们不会在三元组、四元组、五元组等上工作。我们稍后会介绍从元组中提取数据的不同方法。
- en: 'The `zip` function is a cool way to produce a list of pairs. It takes two lists,
    then “zips” them together into one list by joining the matching elements into
    pairs. It’s a really simple function, but it can be very useful when you want
    to combine two lists in a particular way or traverse two lists simultaneously.
    Here’s a demonstration:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`函数是一种产生对列表的酷方法。它接受两个列表，然后将它们“压缩”成一个列表，通过将匹配的元素组合成对来实现。这是一个非常简单的函数，但它可以在你想要以特定方式组合两个列表或同时遍历两个列表时非常有用。以下是一个演示：'
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Notice that because pairs can have different types in them, `zip` can take two
    lists that contain elements of different types. But what happens if the lengths
    of the lists don’t match?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于对可以包含不同类型的元素，`zip`可以接受包含不同类型元素的两个列表。但如果列表的长度不匹配会发生什么呢？
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As you can see in the above example, only as much of the longer list is used
    as needed—the rest is simply ignored. And because Haskell uses lazy evaluation,
    we can even zip finite lists with infinite lists:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的例子中看到的，只有与所需的一样多的较长列表被使用——其余的只是被忽略。而且因为Haskell使用惰性求值，我们甚至可以将有限列表与无限列表`zip`：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Finding the Right Triangle
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找直角三角形
- en: 'Let’s wrap things up with a problem that combines tuples and list comprehensions.
    We’ll use Haskell to find a right triangle that fits all of these conditions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个结合元组和列表解析的问题来结束。我们将使用Haskell找到一个符合所有这些条件的直角三角形：
- en: The lengths of the three sides are all integers.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三边的长度都是整数。
- en: The length of each side is less than or equal to 10.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条边的长度都小于或等于10。
- en: The triangle’s perimeter (the sum of the side lengths) is equal to 24.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形的周长（边长的总和）等于24。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802522.png.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802522.png.jpg)'
- en: A triangle is a right triangle if one of its angles is a right angle (a 90-degree
    angle). Right triangles have the useful property that if you square the lengths
    of the sides forming the right angle and then add those squares, that sum is equal
    to the square of the length of the side that’s opposite the right angle. In the
    picture, the sides that lie next to the right angle are labeled `a` and `b`, and
    the side opposite the right angle is labeled `c`. We call that side the *hypotenuse*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个三角形的一个角是直角（90度角），那么这个三角形就是直角三角形。直角三角形有一个有用的性质：如果你平方形成直角的边的长度，然后将这些平方相加，那么这个和等于与直角相对的边的长度的平方。在图片中，与直角相邻的边被标记为`a`和`b`，与直角相对的边被标记为`c`。我们称那个边为*斜边*。
- en: 'As a first step, let’s generate all possible triples with elements that are
    less than or equal to 10:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们生成所有可能的由小于或等于10的元素组成的三元组：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We’re drawing from three lists on the right-hand side of the comprehension,
    and the output expression on the left combines them into a list of triples. If
    you evaluate `triples` in GHCi, you’ll get a list that is 1,000 entries long,
    so we won’t show it here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在理解右侧的三个列表中抽取，输出表达式左侧将它们组合成一个三元组列表。如果你在GHCi中评估`triples`，你会得到一个包含1,000个条目的列表，所以我们在这里不会显示它。
- en: 'Next, we’ll filter out triples that don’t represent right triangles by adding
    a predicate that checks to see if the Pythagorean theorem (`a^2 + b^2 == c^2`)
    holds. We’ll also modify the function to ensure that side `a` isn’t larger than
    the hypotenuse `c`, and that side `b` isn’t larger than side `a`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加一个检查勾股定理（`a^2 + b^2 == c^2`）是否成立的谓词来过滤掉不代表直角三角形的三角形。我们还将修改函数以确保边`a`不大于斜边`c`，并且边`b`不大于边`a`：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how we changed the ranges in the lists that we draw values from. This
    ensures that we don’t check unnecessary triples, such as ones where side `b` is
    larger than the hypotenuse (in a right triangle, the hypotenuse is always the
    longest side). We also assumed that side `b` is never larger than side `a`. This
    doesn’t harm anything, because for every triple `(a,b,c)` with `a^2 + b^2 == c^2`
    and `b` > `a` that is left out of consideration, the triple `(b,a,c)` is included—and
    is the same triangle, just with the legs reversed. (Otherwise, our list of results
    would contain pairs of triangles that are essentially the same.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何改变了从列表中抽取值的范围。这确保了我们不会检查不必要的三角形，例如边`b`大于斜边（在直角三角形中，斜边总是最长的边）的情况。我们还假设边`b`永远不会大于边`a`。这不会造成任何损害，因为对于每个被排除在外的、满足`a^2
    + b^2 == c^2`和`b` > `a`的三角形`(a,b,c)`，都会包含三角形`(b,a,c)`——只是边长顺序相反。（否则，我们的结果列表将包含实际上是相同三角形的成对三角形。）
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In GHCi, you can’t break up definitions and expressions across multiple lines.
    In this book, however, we occasionally need to break up a single line so the code
    can all fit on the page. (Otherwise the book would have to be really wide, and
    it wouldn’t fit on any normal shelf—and then you’d have to buy bigger shelves!)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在GHCi中，你不能将定义和表达式拆分到多行。然而，在这本书中，我们偶尔需要将单行拆分，以便代码可以全部适合在页面上。（否则这本书会非常宽，无法放在任何正常的书架上——然后你就得买更大的书架了！）
- en: 'We’re almost done. Now, we just need to modify the function to only output
    the triangles whose perimeter equals 24:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。现在，我们只需要修改函数，使其只输出周长等于24的三角形：
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And there’s our answer! This is a common pattern in functional programming:
    you start with a certain set of candidate solutions, and successively apply transformations
    and filters to them until you’ve narrowed the possibilities down to the one solution
    (or several solutions) that you’re after.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的答案就在这里！这是函数式编程中的一种常见模式：你从一个特定的候选解决方案集合开始，然后依次对这些解决方案应用转换和过滤，直到将可能性缩小到你想要的那个（或几个）解决方案。
