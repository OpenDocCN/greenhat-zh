- en: Chapter 0x300. EXPLOITATION
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第0x300章。利用
- en: Program exploitation is a staple of hacking. As demonstrated in the previous
    chapter, a program is made up of a complex set of rules following a certain execution
    flow that ultimately tells the computer what to do. Exploiting a program is simply
    a clever way of getting the computer to do what you want it to do, even if the
    currently running program was designed to prevent that action. Since a program
    can really only do what it's designed to do, the security holes are actually flaws
    or oversights in the design of the program or the environment the program is running
    in. It takes a creative mind to find these holes and to write programs that compensate
    for them. Sometimes these holes are the products of relatively obvious programmer
    errors, but there are some less obvious errors that have given birth to more complex
    exploit techniques that can be applied in many different places.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序利用是黑客攻击的基石。正如前一章所展示的，一个程序由一系列复杂的规则组成，遵循一定的执行流程，最终告诉计算机做什么。利用程序就是以巧妙的方式让计算机做你想让它做的事，即使当前运行的程序被设计成防止这种操作。由于程序实际上只能做它被设计去做的事，因此安全漏洞实际上是程序或程序运行环境的缺陷或疏忽。需要具有创造性的思维来发现这些漏洞并编写补偿这些漏洞的程序。有时这些漏洞是相对明显的程序员错误的结果，但也有一些不太明显的错误产生了更复杂的利用技术，这些技术可以应用于许多不同的地方。
- en: 'A program can only do what it''s programmed to do, to the letter of the law.
    Unfortunately, what''s written doesn''t always coincide with what the programmer
    intended the program to do. This principle can be explained with a joke:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序只能按照其编程去做，字面意思。不幸的是，写下的内容并不总是与程序员希望程序去做的事情相一致。这个原则可以用一个笑话来解释：
- en: A man is walking through the woods, and he finds a magic lamp on the ground.
    Instinctively, he picks the lamp up, rubs the side of it with his sleeve, and
    out pops a genie. The genie thanks the man for freeing him, and offers to grant
    him three wishes. The man is ecstatic and knows exactly what he wants.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个男人正在穿过森林，他发现地上有一个魔法灯。出于本能，他拿起灯，用袖子擦了擦它的侧面，一个精灵突然出现。精灵感谢那个人释放了他，并承诺给他三个愿望。那个人欣喜若狂，确切地知道他想要什么。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"First," says the man, "I want a billion dollars."'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “首先，”那个人说，“我想得到十亿美元。”
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The genie snaps his fingers and a briefcase full of money materializes out of
    thin air.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 灵魂摆动手指，一个装满钱的公文包从空中出现。
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The man is wide eyed in amazement and continues, "Next, I want a Ferrari."
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那个人惊讶地睁大了眼睛，继续说：“接下来，我要一辆法拉利。”
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The genie snaps his fingers and a Ferrari appears from a puff of smoke.
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 灵魂摆动手指，一辆法拉利从烟雾中冒了出来。
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The man continues, "Finally, I want to be irresistible to women."
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那个人继续说：“最后，我想对女人有不可抗拒的吸引力。”
- en: ''
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The genie snaps his fingers and the man turns into a box of chocolates.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 灵魂摆动手指，那个人变成了一个巧克力盒子。
- en: Just as the man's final wish was granted based on what he said, rather than
    what he was thinking, a program will follow its instructions exactly, and the
    results aren't always what the programmer intended. Sometimes the repercussions
    can be catastrophic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一个人的最终愿望是基于他说的话而不是他的想法而得到满足一样，一个程序会严格按照其指令执行，结果并不总是程序员所期望的。有时，后果可能是灾难性的。
- en: 'Programmers are human, and sometimes what they write isn''t exactly what they
    mean. For example, one common programming error is called an *off-by-one* error.
    As the name implies, it''s an error where the programmer has miscounted by one.
    This happens more often than you might think, and it is best illustrated with
    a question: If you''re building a 100-foot fence, with fence posts spaced 10 feet
    apart, how many fence posts do you need? The obvious answer is 10 fence posts,
    but this is incorrect, since you actually need 11\. This type of off-by-one error
    is commonly called a *fencepost error*, and it occurs when a programmer mistakenly
    counts items instead of spaces between items, or vice versa. Another example is
    when a programmer is trying to select a range of numbers or items for processing,
    such as items *`N`* through *`M`*. If `N = 5` and `M = 17`, how many items are
    there to process? The obvious answer is `M - N`, or `17 - 5 = 12` items. But this
    is incorrect, since there are actually `M - N + 1` items, for a total of `13`
    items. This may seem counterintuitive at first glance, because it is, and that''s
    exactly why these errors happen.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员也是人，有时他们写的代码并不完全符合他们的意图。例如，一种常见的编程错误被称为*差一错误*。正如其名所示，这是一种程序员多计算了一个的错误。这种情况比你想的更常见，而且最好用一个问题来解释：如果你正在建造一个100英尺的栅栏，栅栏柱之间的距离是10英尺，你需要多少个栅栏柱？显然的答案是10个栅栏柱，但这是不正确的，因为你实际上需要11个。这种类型的“差一”错误通常被称为*栅栏错误*，它发生在程序员错误地计算项目数量而不是项目之间的空间，或者反之亦然。另一个例子是当程序员试图选择一个用于处理的数字或项目范围时，例如处理项目*`N`*到*`M`*。如果`N
    = 5`和`M = 17`，需要处理多少个项目？显然的答案是`M - N`，即`17 - 5 = 12`个项目。但这是不正确的，因为实际上有`M - N +
    1`个项目，总共是`13`个项目。这种看似反直觉的情况正是这些错误发生的原因。
- en: Often, fencepost errors go unnoticed because programs aren't tested for every
    single possibility, and the effects of a fencepost error don't generally occur
    during normal program execution. However, when the program is fed the input that
    makes the effects of the error manifest, the consequences of the error can have
    an avalanche effect on the rest of the program logic. When properly exploited,
    an off-by-one error can cause a seemingly secure program to become a security
    vulnerability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，栅栏错误会被忽视，因为程序并没有针对每一种可能性进行测试，而且栅栏错误的效果通常在正常程序执行期间不会出现。然而，当程序接收到使错误效果显现的输入时，错误的后果可能会对程序逻辑的其他部分产生连锁反应。当被适当利用时，一个“差一”错误可以使看似安全的程序变成安全漏洞。
- en: 'One classic example of this is OpenSSH, which is meant to be a secure terminal
    communication program suite, designed to replace insecure and unencrypted services
    such as telnet, rsh, and rcp. However, there was an off-by-one error in the channel-allocation
    code that was heavily exploited. Specifically, the code included an if statement
    that read:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的例子是OpenSSH，它本应是一个安全的终端通信程序套件，旨在取代不安全且未加密的服务，如telnet、rsh和rcp。然而，在通道分配代码中存在一个“差一”错误，并被大量利用。具体来说，代码中包含了一个if语句，其内容如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It should have been
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In plain English, the code reads *If the ID is less than 0 or the ID is greater
    than the channels allocated, do the following stuff*, when it should have been
    *If the ID is less than 0 or the ID is greater than* or equal to *the channels
    allocated, do the following stuff*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用通俗易懂的话来说，这段代码的读法是*如果ID小于0或者ID大于分配的通道数，执行以下操作*，而它本应该是*如果ID小于0或者ID大于或等于分配的通道数，执行以下操作*。
- en: This simple off-by-one error allowed further exploitation of the program, so
    that a normal user authenticating and logging in could gain full administrative
    rights to the system. This type of functionality certainly wasn't what the programmers
    had intended for a secure program like OpenSSH, but a computer can only do what
    it's told.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的“差一”错误允许进一步利用程序，以至于一个正常用户在验证和登录后能够获得对系统的完全管理权限。这种功能显然不是程序员为像OpenSSH这样的安全程序所期望的，但计算机只能做它被告诉的事情。
- en: Another situation that seems to breed exploitable programmer errors is when
    a program is quickly modified to expand its functionality. While this increase
    in functionality makes the program more marketable and increases its value, it
    also increases the program's complexity, which increases the chances of an oversight.
    Microsoft's IIS webserver program is designed to serve static and interactive
    web content to users. In order to accomplish this, the program must allow users
    to read, write, and execute programs and files within certain directories; however,
    this functionality must be limited to those particular directories. Without this
    limitation, users would have full control of the system, which is obviously undesirable
    from a security perspective. To prevent this situation, the program has path-checking
    code designed to prevent users from using the backslash character to traverse
    backward through the directory tree and enter other directories.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种似乎会滋生可利用的程序员错误的情况是，当程序被快速修改以扩展其功能时。虽然这种功能增加使得程序更具市场吸引力并提高了其价值，但它也增加了程序的复杂性，从而增加了疏忽的可能性。微软的IIS网络服务器程序旨在向用户提供服务静态和交互式网络内容。为了实现这一点，程序必须允许用户在特定目录内读取、写入和执行程序和文件；然而，这种功能必须限制在这些特定目录内。如果没有这种限制，用户将完全控制系统，这显然从安全角度来看是不理想的。为了防止这种情况，程序设计了路径检查代码，旨在防止用户使用反斜杠字符在目录树中向后遍历并进入其他目录。
- en: With the addition of support for the Unicode character set, though, the complexity
    of the program continued to increase. *Unicode* is a double-byte character set
    designed to provide characters for every language, including Chinese and Arabic.
    By using two bytes for each character instead of just one, Unicode allows for
    tens of thousands of possible characters, as opposed to the few hundred allowed
    by single-byte characters. This additional complexity means that there are now
    multiple representations of the backslash character. For example, `%5c` in Unicode
    translates to the backslash character, but this translation was done *after* the
    path-checking code had run. So by using `%5c` instead of \, it was indeed possible
    to traverse directories, allowing the aforementioned security dangers. Both the
    Sadmind worm and the CodeRed worm used this type of Unicode conversion oversight
    to deface web pages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管增加了对Unicode字符集的支持，但程序的复杂性仍然持续增加。*Unicode*是一种双字节字符集，旨在为包括中文和阿拉伯语在内的每一种语言提供字符。通过为每个字符使用两个字节而不是一个字节，Unicode允许有数万个可能的字符，相比之下，单字节字符只能允许几百个字符。这种额外的复杂性意味着现在存在多个反斜杠字符的表示形式。例如，在Unicode中`%5c`翻译为反斜杠字符，但这种翻译是在路径检查代码运行之后完成的。因此，使用`%5c`而不是\，确实可以遍历目录，从而允许上述安全风险。Sadmind蠕虫和CodeRed蠕虫就是利用这种Unicode转换疏忽来篡改网页的。
- en: A related example of this letter-of-the-law principle used outside the realm
    of computer programming is the LaMacchia Loophole. Just like the rules of a computer
    program, the US legal system sometimes has rules that don't say exactly what their
    creators intended, and like a computer program exploit, these legal loopholes
    can be used to sidestep the intent of the law. Near the end of 1993, a 21-year-old
    computer hacker and student at MIT named David LaMacchia set up a bulletin board
    system called Cynosure for the purposes of software piracy. Those who had software
    to give would upload it, and those who wanted software would download it. The
    service was only online for about six weeks, but it generated heavy network traffic
    worldwide, which eventually attracted the attention of university and federal
    authorities. Software companies claimed that they lost one million dollars as
    a result of Cynosure, and a federal grand jury charged LaMacchia with one count
    of conspiring with unknown persons to violate the wire fraud statue. However,
    the charge was dismissed because what LaMacchia was alleged to have done wasn't
    criminal conduct under the Copyright Act, since the infringement was not for the
    purpose of commercial advantage or private financial gain. Apparently, the lawmakers
    had never anticipated that someone might engage in these types of activities with
    a motive other than personal financial gain. (Congress closed this loophole in
    1997 with the No Electronic Theft Act.) Even though this example doesn't involve
    the exploiting of a computer program, the judges and courts can be thought of
    as computers executing the program of the legal system as it was written. The
    abstract concepts of hacking transcend computing and can be applied to many other
    aspects of life that involve complex systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个法律条文原则在计算机编程领域之外的另一个相关例子是拉马奇亚漏洞。就像计算机程序的规则一样，美国的法律体系有时会有一些规则并没有明确说明其创造者的意图，就像计算机程序漏洞一样，这些法律漏洞可以被用来规避法律的意图。1993年底，一个名叫大卫·拉马奇亚的21岁计算机黑客和麻省理工学院的学生建立了一个名为Cynosure的公告板系统，用于软件盗版。那些有软件要分享的人会上传，而那些想要软件的人会下载。这个服务只在线大约六周，但产生了全球范围内的巨大网络流量，最终引起了大学和联邦当局的注意。软件公司声称由于Cynosure，他们损失了一百万美元，联邦大陪审团指控拉马奇亚犯有一项与未知人员合谋违反电信诈骗法的罪行。然而，指控被撤销，因为拉马奇亚被指控的行为并不构成《版权法》下的犯罪行为，因为侵权不是为了商业利益或私人财务收益。显然，立法者从未预料到有人可能会出于除个人财务收益以外的动机从事这些活动。（国会于1997年通过《无电子盗窃法》关闭了这个漏洞。）尽管这个例子并不涉及利用计算机程序，但法官和法院可以被视为执行法律体系程序的计算机。黑客的抽象概念超越了计算，可以应用于涉及复杂系统的许多其他生活方面。
- en: Generalized Exploit Techniques
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用利用技术
- en: Off-by-one errors and improper Unicode expansion are all mistakes that can be
    hard to see at the time but are glaringly obvious to any programmer in hindsight.
    However, there are some common mistakes that can be exploited in ways that aren't
    so obvious. The impact of these mistakes on security isn't always apparent, and
    these security problems are found in code everywhere. Because the same type of
    mistake is made in many different places, generalized exploit techniques have
    evolved to take advantage of these mistakes, and they can be used in a variety
    of situations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 离差一的错误和不正确的Unicode扩展都是当时可能难以察觉但事后任何程序员都会明显察觉到的错误。然而，有一些常见的错误可以通过不明显的方式被利用。这些错误对安全性的影响并不总是显而易见，这些安全问题在代码的各个地方都有发现。由于相同的错误在许多不同的地方都会发生，因此已经发展出通用的利用技术来利用这些错误，并且它们可以在各种情况下使用。
- en: Most program exploits have to do with memory corruption. These include common
    exploit techniques like buffer overflows as well as less-common methods like format
    string exploits. With these techniques, the ultimate goal is to take control of
    the target program's execution flow by tricking it into running a piece of malicious
    code that has been smuggled into memory. This type of process hijacking is known
    as *execution of arbitrary code*, since the hacker can cause a program to do pretty
    much anything he or she wants it to. Like the LaMacchia Loophole, these types
    of vulnerabilities exist because there are specific unexpected cases that the
    program can't handle. Under normal conditions, these unexpected cases cause the
    program to crash— metaphorically driving the execution flow off a cliff. But if
    the environment is carefully controlled, the execution flow can be controlled—preventing
    the crash and reprogramming the process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序漏洞都与内存损坏有关。这包括常见的漏洞利用技术，如缓冲区溢出，以及不太常见的格式化字符串漏洞等。使用这些技术，最终目标是通过对目标程序执行流程进行欺骗，使其运行已偷偷运入内存的恶意代码，从而控制目标程序的执行流程。这种进程劫持过程被称为*任意代码执行*，因为黑客可以迫使程序执行几乎任何他们想要的事情。像
    LaMacchia 漏洞一样，这类漏洞存在是因为程序无法处理特定的意外情况。在正常情况下，这些意外情况会导致程序崩溃——比喻地说，将执行流程推下悬崖。但如果环境被仔细控制，执行流程可以被控制——防止崩溃并重新编程进程。
- en: Buffer Overflows
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: Buffer overflow vulnerabilities have been around since the early days of computers
    and still exist today. Most Internet worms use buffer overflow vulnerabilities
    to propagate, and even the most recent zero-day VML vulnerability in Internet
    Explorer is due to a buffer overflow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出漏洞自计算机的早期就已经存在，并且至今仍然存在。大多数网络蠕虫都使用缓冲区溢出漏洞进行传播，甚至最近在 Internet Explorer 中发现的零日
    VML 漏洞也是由于缓冲区溢出。
- en: C is a high-level programming language, but it assumes that the programmer is
    responsible for data integrity. If this responsibility were shifted over to the
    compiler, the resulting binaries would be significantly slower, due to integrity
    checks on every variable. Also, this would remove a significant level of control
    from the programmer and complicate the language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C 是一种高级编程语言，但它假定程序员负责数据完整性。如果这种责任转移到编译器，生成的二进制文件会显著变慢，因为每个变量都需要进行完整性检查。此外，这也会从程序员手中移走相当一部分控制权，并使语言变得复杂。
- en: While C's simplicity increases the programmer's control and the efficiency of
    the resulting programs, it can also result in programs that are vulnerable to
    buffer overflows and memory leaks if the programmer isn't careful. This means
    that once a variable is allocated memory, there are no built-in safeguards to
    ensure that the contents of a variable fit into the allocated memory space. If
    a programmer wants to put ten bytes of data into a buffer that had only been allocated
    eight bytes of space, that type of action is allowed, even though it will most
    likely cause the program to crash. This is known as a *buffer overrun* or *buffer
    overflow*, since the extra two bytes of data will overflow and spill out of the
    allocated memory, overwriting whatever happens to come next. If a critical piece
    of data is overwritten, the program will crash. The overflow_example.c code offers
    an example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C 语言的简洁性增加了程序员的控制力以及生成程序的效率，但它也可能导致程序员不小心编写出易受缓冲区溢出和内存泄漏影响的程序。这意味着一旦变量分配了内存，就没有内置的安全措施来确保变量的内容适合分配的内存空间。如果一个程序员想要将十个字节的数据放入只分配了八个字节空间的缓冲区中，这种操作是被允许的，尽管它很可能会使程序崩溃。这种情况被称为*缓冲区溢出*或*缓冲区越界*，因为额外的两个字节数据会溢出并从分配的内存中溢出，覆盖任何随后发生的内容。如果关键数据被覆盖，程序将崩溃。overflow_example.c
    代码提供了一个示例。
- en: Buffer Overflows
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: overflow_example.c
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: overflow_example.c
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By now, you should be able to read the source code above and figure out what
    the program does. After compilation in the sample output below, we try to copy
    ten bytes from the first command-line argument into `buffer_two`, which only has
    eight bytes allocated for it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该能够阅读上面的源代码并弄清楚程序的功能。在下面的示例输出中进行编译后，我们尝试将十个字节从第一个命令行参数复制到只有八个字节分配的`buffer_two`中。
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that `buffer_one` is located directly after `buffer_two` in memory, so
    when ten bytes are copied into `buffer_two`, the last two bytes of `90` overflow
    into `buffer_one` and overwrite whatever was there.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`buffer_one`在内存中直接位于`buffer_two`之后，因此当将十个字节复制到`buffer_two`时，最后的两个字节`90`会溢出到`buffer_one`并覆盖掉原来的内容。
- en: A larger buffer will naturally overflow into the other variables, but if a large
    enough buffer is used, the program will crash and die.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的缓冲区自然会溢出到其他变量中，但如果使用足够大的缓冲区，程序将崩溃并死亡。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These types of program crashes are fairly common—think of all of the times a
    program has crashed or blue-screened on you. The programmer's mistake is one of
    omission—there should be a length check or restriction on the user-supplied input.
    These kinds of mistakes are easy to make and can be difficult to spot. In fact,
    the notesearch.c program on [notesearch.c](ch02s08.html#notesearchc "notesearch.c")
    contains a buffer overflow bug. You might not have noticed this until right now,
    even if you were already familiar with C.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这类程序崩溃相当常见——想想看有多少次程序在你面前崩溃或蓝屏。程序员的错误是遗漏——应该有长度检查或对用户提供的输入进行限制。这类错误很容易犯，并且很难发现。实际上，[notesearch.c](ch02s08.html#notesearchc
    "notesearch.c")程序中就包含一个缓冲区溢出漏洞。即使你已经熟悉C语言，你可能直到现在才注意到这一点。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Program crashes are annoying, but in the hands of a hacker they can become downright
    dangerous. A knowledgeable hacker can take control of a program as it crashes,
    with some surprising results. The exploit_notesearch.c code demonstrates the danger.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序崩溃很烦人，但在黑客手中，它们可能变得非常危险。一个知识渊博的黑客可以在程序崩溃时控制程序，并产生一些令人惊讶的结果。exploit_notesearch.c代码展示了这种危险。
- en: exploit_notesearch.c
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exploit_notesearch.c
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This exploit''s source code will be explained in depth later, but in general,
    it''s just generating a command string that will execute the notesearch program
    with a command-line argument between single quotes. It uses string functions to
    do this: `strlen()` to get the current length of the string (to position the buffer
    pointer) and `strcat()` to concatenate the closing single quote to the end. Finally,
    the system function is used to execute the command string. The buffer that is
    generated between the single quotes is the real meat of the exploit. The rest
    is just a delivery method for this poison pill of data. Watch what a controlled
    crash can do.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞的源代码将在稍后进行深入解释，但总的来说，它只是生成一个命令字符串，该字符串将在单引号之间执行notesearch程序，并带有命令行参数。它使用字符串函数来完成这个任务：`strlen()`获取当前字符串的长度（以定位缓冲区指针）和`strcat()`将结尾的单引号连接到末尾。最后，使用系统函数执行命令字符串。单引号之间的缓冲区是漏洞的真正核心。其余的只是将这种数据毒药传递出去的方法。看看一个可控的崩溃能做什么。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The exploit is able to use the overflow to serve up a root shell—providing full
    control over the computer. This is an example of a stack-based buffer overflow
    exploit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该漏洞能够利用溢出提供一个root shell——提供对计算机的完全控制。这是一个基于堆的缓冲区溢出漏洞的例子。
- en: Stack-Based Buffer Overflow Vulnerabilities
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于堆的缓冲区溢出漏洞
- en: The notesearch exploit works by corrupting memory to control execution flow.
    The auth_overflow.c program demonstrates this concept.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: notesearch漏洞通过破坏内存来控制执行流程。auth_overflow.c程序展示了这一概念。
- en: auth_overflow.c
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: auth_overflow.c
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example program accepts a password as its only command-line argument and
    then calls a `check_authentication()` function. This function allows two passwords,
    meant to be representative of multiple authentication methods. If either of these
    passwords is used, the function returns 1, which grants access. You should be
    able to figure most of that out just by looking at the source code before compiling
    it. Use the `-g` option when you do compile it, though, since we will be debugging
    this later.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例程序接受一个密码作为其唯一的命令行参数，然后调用一个`check_authentication()`函数。这个函数允许两个密码，旨在代表多种认证方法。如果使用这两个密码中的任何一个，函数返回1，从而允许访问。你应该能够在编译之前通过查看源代码来理解大部分内容。不过，在编译时请使用`-g`选项，因为我们稍后将对这个程序进行调试。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, everything works as the source code says it should. This is to be expected
    from something as deterministic as a computer program. But an overflow can lead
    to unexpected and even contradictory behavior, allowing access without a proper
    password.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切如源代码所述正常工作。对于像计算机程序这样确定性的东西来说，这是可以预料的。但是溢出可能导致意外甚至矛盾的行为，允许在没有正确密码的情况下访问。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You may have already figured out what happened, but let's look at this with
    a debugger to see the specifics of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了发生了什么，但让我们用调试器来看一下它的具体细节。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The GDB debugger is started with the `-q` option to suppress the welcome banner,
    and breakpoints are set on lines 9 and 16\. When the program is run, execution
    will pause at these breakpoints and give us a chance to examine memory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-q`选项启动GDB调试器以抑制欢迎横幅，并在第9行和第16行设置断点。当程序运行时，执行将在这些断点处暂停，给我们一个检查内存的机会。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first breakpoint is before the `strcpy()` happens. By examining the `password_buffer`
    pointer, the debugger shows it is filled with random uninitialized data and is
    located at `0xbffff7a0` in memory. By examining the address of the `auth_flag`
    variable, we can see both its location at `0xbffff7bc` and its value of 0\. The
    print command can be used to do arithmetic and shows that `auth_flag` is 28 bytes
    past the start of `password_buffer`. This relationship can also be seen in a block
    of memory starting at `password_buffer`. The location of `auth_flag` is shown
    in bold.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断点出现在`strcpy()`函数执行之前。通过检查`password_buffer`指针，调试器显示它被填充了随机的未初始化数据，并且位于内存中的`0xbffff7a0`地址。通过检查`auth_flag`变量的地址，我们可以看到它在`0xbffff7bc`的位置，其值为0。使用打印命令可以进行算术运算，并显示`auth_flag`位于`password_buffer`起始点之后28个字节。这种关系也可以在以`password_buffer`开始的内存块中看到。`auth_flag`的位置用粗体表示。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Continuing to the next breakpoint found after the `strcpy()`, these memory locations
    are examined again. The `password_buffer` overflowed into the `auth_flag`, changing
    its first two bytes to `0x41`. The value of `0x00004141` might look backward again,
    but remember that *x*86 has little-endian architecture, so it's supposed to look
    that way. If you examine each of these four bytes individually, you can see how
    the memory is actually laid out. Ultimately, the program will treat this value
    as an integer, with a value of 16705.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到`strcpy()`之后找到的下一个断点，再次检查这些内存位置。`password_buffer`溢出到`auth_flag`，将其前两个字节改为`0x41`。`0x00004141`的值可能看起来又向后了，但请记住，*x*86是小端架构，所以它应该是这样的。如果你单独检查这四个字节中的每一个，你可以看到内存的实际布局。最终，程序将把这个值当作一个整数，其值为16705。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After the overflow, the `check_authentication()` function will return 16705
    instead of 0\. Since the if statement considers any nonzero value to be authenticated,
    the program's execution flow is controlled into the authenticated section. In
    this example, the `auth_flag` variable is the execution control point, since overwriting
    this value is the source of the control.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在溢出之后，`check_authentication()`函数将返回16705而不是0。由于if语句将任何非零值视为已认证，程序的执行流程将控制到认证部分。在这个例子中，`auth_flag`变量是执行控制点，因为覆盖这个值是控制来源。
- en: But this is a very contrived example that depends on memory layout of the variables.
    In auth_overflow2.c, the variables are declared in reverse order. (Changes to
    auth_overflow.c are shown in bold.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是一个非常人为的例子，它依赖于变量的内存布局。在`auth_overflow2.c`中，变量是按相反顺序声明的。（对`auth_overflow.c`的更改用粗体表示。）
- en: auth_overflow2.c
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`auth_overflow2.c`'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This simple change puts the `auth_flag` variable before the `password_buffer`
    in memory. This eliminates the use of the return_value variable as an execution
    control point, since it can no longer be corrupted by an overflow.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改将`auth_flag`变量放在内存中的`password_buffer`之前。这消除了使用`return_value`变量作为执行控制点的需要，因为它不能再被溢出所破坏。
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similar breakpoints are set, and an examination of memory shows that `auth_flag`
    (shown in bold above and below) is located before `password_buffer` in memory.
    This means `auth_flag` can never be overwritten by an overflow in `password_buffer`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 设置类似的断点，并检查内存，显示`auth_flag`（上面和下面都用粗体表示）在内存中位于`password_buffer`之前。这意味着`auth_flag`永远不会被`password_buffer`中的溢出覆盖。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As expected, the overflow cannot disturb the `auth_flag` variable, since it's
    located before the buffer. But another execution control point does exist, even
    though you can't see it in the C code. It's conveniently located after all the
    stack variables, so it can easily be overwritten. This memory is integral to the
    operation of all programs, so it exists in all programs, and when it's overwritten,
    it usually results in a program crash.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，溢出不会干扰`auth_flag`变量，因为它位于缓冲区之前。但确实存在另一个执行控制点，尽管你无法在C代码中看到它。它方便地位于所有栈变量之后，因此可以很容易地被覆盖。这种内存对于所有程序的操作都是至关重要的，因此它存在于所有程序中，当它被覆盖时，通常会导致程序崩溃。
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Recall from the previous chapter that the stack is one of five memory segments
    used by programs. The stack is a FILO data structure used to maintain execution
    flow and context for local variables during function calls. When a function is
    called, a structure called a *stack frame* is pushed onto the stack, and the EIP
    register jumps to the first instruction of the function. Each stack frame contains
    the local variables for that function and a return address so EIP can be restored.
    When the function is done, the stack frame is popped off the stack and the return
    address is used to restore EIP. All of this is built in to the architecture and
    is usually handled by the compiler, not the programmer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章回顾，堆栈是程序使用的五个内存段之一。堆栈是一种FILO（先进后出）数据结构，用于在函数调用期间维护局部变量的执行流程和上下文。当一个函数被调用时，一个称为**栈帧**的结构会被推入堆栈，并且EIP寄存器跳转到函数的第一个指令。每个栈帧包含该函数的局部变量以及一个返回地址，以便EIP能够恢复。当函数执行完毕后，栈帧从堆栈中弹出，并使用返回地址来恢复EIP。所有这些功能都是架构内建的，通常由编译器处理，而不是程序员。
- en: When the `check_authentication()` function is called, a new stack frame is pushed
    onto the stack above `main()`'s stack frame. In this frame are the local variables,
    a return address, and the function's arguments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`check_authentication()`函数时，一个新的栈帧会被推入`main()`函数栈帧之上。在这个栈帧中包含局部变量、返回地址以及函数的参数。
- en: We can see all these elements in the debugger.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在调试器中看到所有这些元素。
- en: '![](httpatomoreillycomsourcenostarchimages254428.png.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](httpatomoreillycomsourcenostarchimages254428.png.jpg)'
- en: Figure 0x300-1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x300-1.
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first breakpoint is right before the call to `check_authentication()`in
    `main()`. At this point, the stack pointer register (ESP) is `0xbffff7e0`, and
    the top of the stack is shown. This is all part of `main()`'s stack frame. Continuing
    to the next breakpoint inside `check_authentication()`, the output below shows
    ESP is smaller as it moves up the list of memory to make room for `check_authentication()`'s
    stack frame (shown in bold), which is now on the stack. After finding the addresses
    of the `auth_flag` variable (![](httpatomoreillycomsourcenostarchimages254488.png))
    and the variable `password_buffer` (![](httpatomoreillycomsourcenostarchimages254530.png)),
    their locations can be seen within the stack frame.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断点位于`main()`中调用`check_authentication()`之前。在这个点上，栈指针寄存器（ESP）是`0xbffff7e0`，堆栈的顶部如下所示。这都属于`main()`的栈帧。继续到`check_authentication()`内部的下一个断点，下面的输出显示ESP随着向上移动内存列表而减小，为`check_authentication()`的栈帧腾出空间（以粗体显示），现在它已经在堆栈上。在找到`auth_flag`变量（![](httpatomoreillycomsourcenostarchimages254488.png)）和变量`password_buffer`（![](httpatomoreillycomsourcenostarchimages254530.png)）的地址后，它们在栈帧中的位置就可以看到了。
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Continuing to the second breakpoint in `check_authentication()`, a stack frame
    (shown in bold) is pushed onto the stack when the function is called. Since the
    stack grows upward toward lower memory addresses, the stack pointer is now 64
    bytes less at `0xbffff7a0`. The size and structure of a stack frame can vary greatly,
    depending on the function and certain compiler optimizations. For example, the
    first 24 bytes of this stack frame are just padding put there by the compiler.
    The local stack variables, `auth_flag` and `password_buffer`, are shown at their
    respective memory locations in the stack frame. The `auth_flag` ![](httpatomoreillycomsourcenostarchimages254488.png)
    is shown at `0xbffff7bc`, and the 16 bytes of the password buffer ![](httpatomoreillycomsourcenostarchimages254530.png)
    are shown at `0xbffff7c0`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 继续到`check_authentication()`中的第二个断点，当函数被调用时，一个栈帧（以粗体显示）被推入堆栈。由于堆栈向上增长到较低的内存地址，栈指针现在在`0xbffff7a0`处减少了64字节。栈帧的大小和结构可以因函数和某些编译器优化而大不相同。例如，这个栈帧的前24字节只是编译器放置的填充。局部栈变量`auth_flag`和`password_buffer`在栈帧中的相应内存位置显示。`auth_flag`（![](httpatomoreillycomsourcenostarchimages254488.png)）显示在`0xbffff7bc`，密码缓冲区的16字节（![](httpatomoreillycomsourcenostarchimages254530.png)）显示在`0xbffff7c0`。
- en: The stack frame contains more than just the local variables and padding. Elements
    of the `check_authentication()` stack frame are shown below.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 栈帧包含的不仅仅是局部变量和填充。下面显示了`check_authentication()`栈帧的元素。
- en: First, the memory saved for the local variables is shown in italic. This starts
    at the `auth_flag` variable at `0xbffff7bc` and continues through the end of the
    16-byte `password_buffer` variable. The next few values on the stack are just
    padding the compiler threw in, plus something called the *saved frame pointer*.
    If the program is compiled with the flag `-fomit-frame-pointer` for optimization,
    the frame pointer won't be used in the stack frame. At ![](httpatomoreillycomsourcenostarchimages254537.png)
    the value `0x080484bb` is the return address of the stack frame, and at ![](httpatomoreillycomsourcenostarchimages254461.png)
    the address `0xbffffe9b7` is a pointer to a string containing 30 *A*s. This must
    be the argument to the `check_authentication()` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用斜体显示为局部变量保存的内存。这从`auth_flag`变量`0xbffff7bc`开始，一直延续到16字节的`password_buffer`变量的末尾。栈上的下几个值只是编译器添加的填充，以及称为*保存的帧指针*的东西。如果程序使用优化标志`-fomit-frame-pointer`编译，则不会在栈帧中使用帧指针。在![httpatomoreillycomsourcenostarchimages254537.png](httpatomoreillycomsourcenostarchimages254537.png)处，值`0x080484bb`是栈帧的返回地址，在![httpatomoreillycomsourcenostarchimages254461.png](httpatomoreillycomsourcenostarchimages254461.png)处，地址`0xbffffe9b7`是指向包含30个*A*的字符串的指针。这必须是`check_authentication()`函数的参数。
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The return address in a stack frame can be located by understanding how the
    stack frame is created. This process begins in the `main()` function, even before
    the function call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解栈帧是如何创建的，可以定位栈帧中的返回地址。这个过程从`main()`函数开始，甚至在函数调用之前。
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice the two lines shown in bold on page 131\. At this point, the EAX register
    contains a pointer to the first command-line argument. This is also the argument
    to `check_authentication()`. This first assembly instruction writes EAX to where
    ESP is pointing (the top of the stack). This starts the stack frame for `check_authentication()`
    with the function argument. The second instruction is the actual call. This instruction
    pushes the address of the next instruction to the stack and moves the execution
    pointer register (EIP) to the start of the `check_authentication()` function.
    The address pushed to the stack is the return address for the stack frame. In
    this case, the address of the next instruction is `0x080484bb`, so that is the
    return address.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第131页上用粗体显示的两行。此时，EAX寄存器包含第一个命令行参数的指针。这也是`check_authentication()`函数的参数。第一条汇编指令将EAX写入ESP所指向的位置（栈顶）。这为`check_authentication()`函数的函数参数开始了栈帧。第二条指令是实际的调用指令。这条指令将下一条指令的地址压入栈中，并将执行指针寄存器（EIP）移动到`check_authentication()`函数的开始处。压入栈中的地址是栈帧的返回地址。在这种情况下，下一条指令的地址是`0x080484bb`，因此这就是返回地址。
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Execution will continue into the `check_authentication()` function as EIP is
    changed, and the first few instructions (shown in bold above) finish saving memory
    for the stack frame. These instructions are known as the function prologue. The
    first two instructions are for the saved frame pointer, and the third instruction
    subtracts `0x38` from ESP. This saves 56 bytes for the local variables of the
    function. The return address and the saved frame pointer are already pushed to
    the stack and account for the additional 8 bytes of the 64-byte stack frame.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当EIP改变时，执行将继续进入`check_authentication()`函数，并且上面用粗体显示的前几条指令完成了栈帧内存的保存。这些指令被称为函数序言。前两条指令用于保存帧指针，第三条指令从ESP中减去`0x38`。这为函数的局部变量保存了56个字节。返回地址和保存的帧指针已经压入栈中，并占用了64字节栈帧中的额外8个字节。
- en: When the function finishes, the `leave` and `ret` instructions remove the stack
    frame and set the execution pointer register (EIP) to the saved return address
    in the stack frame (![](httpatomoreillycomsourcenostarchimages254488.png)). This
    brings the program execution back to the next instruction in `main()` after the
    function call at `0x080484bb`. This process happens every time a function is called
    in any program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数结束时，`leave`和`ret`指令移除栈帧，并将执行指针寄存器（EIP）设置为栈帧中保存的返回地址（![httpatomoreillycomsourcenostarchimages254488.png](httpatomoreillycomsourcenostarchimages254488.png)）。这使程序执行回到`main()`函数中`0x080484bb`函数调用之后的下一条指令。这个过程在程序中的任何函数调用时都会发生。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When some of the bytes of the saved return address are overwritten, the program
    will still try to use that value to restore the execution pointer register (EIP).
    This usually results in a crash, since execution is essentially jumping to a random
    location. But this value doesn't need to be random. If the overwrite is controlled,
    execution can, in turn, be controlled to jump to a specific location. But where
    should we tell it to go?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存的返回地址的一些字节被覆盖时，程序仍然会尝试使用该值来恢复执行指针寄存器（EIP）。这通常会导致崩溃，因为执行实际上是在跳转到随机位置。但这个值不一定是随机的。如果覆盖是受控制的，执行可以反过来被控制以跳转到特定位置。但我们应该告诉它去哪里？
- en: Experimenting with BASH
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试使用 BASH
- en: Since so much of hacking is rooted in exploitation and experimentation, the
    ability to quickly try different things is vital. The BASH shell and Perl are
    common on most machines and are all that is needed to experiment with exploitation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于黑客技术很大程度上根植于利用和实验，快速尝试不同事情的能力至关重要。BASH 壳和 Perl 在大多数机器上都很常见，并且是进行利用实验所需的一切。
- en: '*Perl* is an interpreted programming language with a `print` command that happens
    to be particularly suited to generating long sequences of characters. Perl can
    be used to execute instructions on the command line by using the `-e` switch like
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*Perl* 是一种解释型编程语言，它有一个 `print` 命令，这个命令恰好非常适合生成长序列的字符。Perl 可以通过使用 `-e` 开关在命令行上执行指令，如下所示：'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command tells Perl to execute the commands found between the single quotes—in
    this case, a single command of `print "A" x 20;`. This command prints the character
    *A* 20 times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 Perl 执行单引号之间的命令——在这种情况下，一个命令 `print "A" x 20;`。这个命令打印字符 *A* 20 次。
- en: 'Any character, such as a nonprintable character, can also be printed by using
    `\x##`, where ## is the hexadecimal value of the character. In the following example,
    this notation is used to print the character *A*, which has the hexadecimal value
    of `0x41`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '任何字符，例如不可打印字符，也可以通过使用 `\x##` 来打印，其中 ## 是字符的十六进制值。在下面的例子中，这种表示法用于打印字符 *A*，其十六进制值为
    `0x41`。'
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In addition, string concatenation can be done in Perl with a period (.). This
    can be useful when stringing multiple addresses together.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Perl 中可以使用点号 (.) 进行字符串连接。这在将多个地址连接起来时可能很有用。
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'An entire shell command can be executed like a function, returning its output
    in place. This is done by surrounding the command with parentheses and prefixing
    a dollar sign. Here are two examples:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像函数一样执行整个 shell 命令，并返回其输出。这是通过将命令用括号括起来并在前面加美元符号来完成的。以下有两个例子：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In each case, the output of the command found between the parentheses is substituted
    for the command, and the command `uname` is executed. This exact command-substitution
    effect can be accomplished with grave accent marks (', the tilted single quote
    on the tilde key). You can use whichever syntax feels more natural for you; however,
    the parentheses syntax is easier to read for most people.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，括号中找到的命令的输出被替换为命令，并执行 `uname` 命令。这个精确的命令替换效果可以通过重音符号（', tilde 键上的倾斜单引号）来实现。你可以使用对你来说更自然的语法；然而，括号语法对大多数人来说更容易阅读。
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Command substitution and Perl can be used in combination to quickly generate
    overflow buffers on the fly. You can use this technique to easily test the overflow_example.c
    program with buffers of precise lengths.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以结合使用命令替换和 Perl 来快速生成动态的溢出缓冲区。你可以使用这种技术轻松地测试具有精确长度的缓冲区的 overflow_example.c
    程序。
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the output above, GDB is used as a hexadecimal calculator to figure out the
    distance between `buffer_two (0xbfffff7e0`) and the `value` variable (`0xbffff7f4`),
    which turns out to be 20 bytes. Using this distance, the `value`variable is overwritten
    with the exact value `0x44434241`, since the characters *A, B, C*, and *D* have
    the hex values of `0x41, 0x42, 0x43`, and `0x44`, respectively. The first character
    is the least significant byte, due to the little-endian architecture. This means
    if you wanted to control the value variable with something exact, like `oxdeadbeef`,
    you must write those bytes into memory in reverse order.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，GDB 被用作十六进制计算器来计算 `buffer_two (0xbfffff7e0)` 和 `value` 变量 (`0xbffff7f4`)
    之间的距离，结果为 20 字节。使用这个距离，`value` 变量被覆盖为确切的值 `0x44434241`，因为字符 *A, B, C* 和 *D* 的十六进制值分别为
    `0x41, 0x42, 0x43` 和 `0x44`。第一个字符是最不显著的字节，因为是小端架构。这意味着如果你想要用确切的东西控制 `value` 变量，比如
    `oxdeadbeef`，你必须以相反的顺序将这些字节写入内存。
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This technique can be applied to overwrite the return address in the auth_overflow2.c
    program with an exact value. In the example below, we will overwrite the return
    address with a different address in `main()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以应用于用确切值覆盖auth_overflow2.c程序中的返回地址。在下面的例子中，我们将覆盖`main()`中的不同地址的返回地址。
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This section of code shown in bold contains the instructions that display the
    *Access Granted* message. The beginning of this section is at `0x080484bf`, so
    if the return address is overwritten with this value, this block of instructions
    will be executed. The exact distance between the return address and the start
    of the `password_buffer` can change due to different compiler versions and different
    optimization flags. As long as the start of the buffer is aligned with DWORDs
    on the stack, this mutability can be accounted for by simply repeating the return
    address many times. This way, at least one of the instances will overwrite the
    return address, even if it has shifted around due to compiler optimizations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在粗体显示的这段代码中，包含了显示“*访问已允许*”信息的指令。该部分的起始地址为`0x080484bf`，因此如果返回地址被覆盖为这个值，这段指令就会被执行。由于不同的编译器版本和不同的优化标志，返回地址与`password_buffer`起始地址之间的确切距离可能会变化。只要缓冲区的起始地址与堆栈上的DWORD对齐，这种可变性可以通过简单地多次重复返回地址来解释。这样，至少有一个实例会覆盖返回地址，即使它由于编译器优化而发生了偏移。
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the example above, the target address of `0x080484bf` is repeated 10 times
    to ensure the return address is overwritten with the new target address. When
    the `check_authentication()` function returns, execution jumps directly to the
    new target address instead of returning to the next instruction after the call.
    This gives us more control; however, we are still limited to using instructions
    that exist in the original programming.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，将`0x080484bf`的目标地址重复了10次，以确保返回地址被新的目标地址覆盖。当`check_authentication()`函数返回时，执行会直接跳转到新的目标地址，而不是返回到调用之后的下一个指令。这给了我们更多的控制权；然而，我们仍然局限于使用原始编程中存在的指令。
- en: The notesearch program is vulnerable to a buffer overflow on the line marked
    in bold here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: notesearch程序在粗体标记的这一行上容易受到缓冲区溢出的影响。
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The notesearch exploit uses a similar technique to overflow a buffer into the
    return address; however, it also injects its own instructions into memory and
    then returns execution there. These instructions are called *shellcode*, and they
    tell the program to restore privileges and open a shell prompt. This is especially
    devastating for the notesearch program, since it is suid root. Since this program
    expects multiuser access, it runs under higher privileges so it can access its
    data file, but the program logic prevents the user from using these higher privileges
    for anything other than accessing the data file—at least that's the intention.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: notesearch 漏洞利用采用了类似的技巧来溢出缓冲区到返回地址；然而，它还会将自身的指令注入到内存中，然后从那里返回执行。这些指令被称为*shellcode*，它们指示程序恢复权限并打开一个shell提示符。这对于notesearch程序来说尤其致命，因为它具有suid
    root权限。由于这个程序期望多用户访问，它以更高的权限运行，以便访问其数据文件，但程序逻辑阻止用户使用这些更高的权限进行除访问数据文件之外的其他操作——至少这是预期意图。
- en: But when new instructions can be injected in and execution can be controlled
    with a buffer overflow, the program logic is meaningless. This technique allows
    the program to do things it was never programmed to do, while it's still running
    with elevated privileges. This is the dangerous combination that allows the notesearch
    exploit to gain a root shell. Let's examine the exploit further.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当可以注入新指令并且可以通过缓冲区溢出来控制执行时，程序逻辑就变得无关紧要了。这种技术允许程序执行它从未被编程去执行的事情，同时它仍然以提升的权限运行。这是notesearch漏洞利用能够获得root
    shell的危险组合。让我们进一步研究这个漏洞利用。
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The notesearch exploit generates a buffer in lines 24 through 27 (shown above
    in bold). The first part is a for loop that fills the buffer with a 4-byte address
    stored in the `ret` variable. The loop increments `i` by 4 each time. This value
    is added to the buffer address, and the whole thing is typecast as a unsigned
    integer pointer. This has a size of 4, so when the whole thing is dereferenced,
    the entire 4-byte value found in `ret` is written.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: notesearch漏洞利用在24到27行（如上粗体所示）生成一个缓冲区。第一部分是一个for循环，它使用存储在`ret`变量中的4字节地址填充缓冲区。每次循环，`i`增加4。这个值被加到缓冲区地址上，整个内容被转换为无符号整数指针。这个大小为4，所以当整个内容被解引用时，`ret`中找到的整个4字节值将被写入。
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At the first breakpoint, the buffer pointer shows the result of the for loop.
    You can also see the relationship between the command pointer and the buffer pointer.
    The next instruction is a call to `memset()`, which starts at the beginning of
    the buffer and sets 60 bytes of memory with the value `0x90`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个断点处，缓冲区指针显示了for循环的结果。你还可以看到命令指针和缓冲区指针之间的关系。下一条指令是调用`memset()`，它从缓冲区的开始处开始，将60个字节的内存设置为值`0x90`。
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, the call to `memcpy()` will copy the shellcode bytes into `buffer+60`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`memcpy()`的调用将shellcode字节复制到`buffer+60`。
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the buffer contains the desired shellcode and is long enough to overwrite
    the return address. The difficulty of finding the exact location of the return
    address is eased by using the repeated return address technique. But this return
    address must point to the shellcode located in the same buffer. This means the
    actual address must be known ahead of time, before it even goes into memory. This
    can be a difficult prediction to try to make with a dynamically changing stack.
    Fortunately, there is another hacking technique, called the NOP sled, that can
    assist with this difficult chicanery. *NOP* is an assembly instruction that is
    short for *no operation*. It is a single-byte instruction that does absolutely
    nothing. These instructions are sometimes used to waste computational cycles for
    timing purposes and are actually necessary in the Sparc processor architecture,
    due to instruction pipelining. In this case, NOP instructions are going to be
    used for a different purpose: as a fudge factor. We''ll create a large array (or
    sled) of these NOP instructions and place it before the shellcode; then, if the
    EIP register points to any address found in the NOP sled, it will increment while
    executing each NOP instruction, one at a time, until it finally reaches the shellcode.
    This means that as long as the return address is overwritten with any address
    found in the NOP sled, the EIP register will slide down the sled to the shellcode,
    which will execute properly. On the *x*86 architecture, the NOP instruction is
    equivalent to the hex byte 0x90\. This means our completed exploit buffer looks
    something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缓冲区包含所需的shellcode，并且足够长，可以覆盖返回地址。通过使用重复的返回地址技术，找到返回地址的确切位置变得容易。但是，这个返回地址必须指向同一缓冲区中位于shellcode的位置。这意味着实际的地址必须在它进入内存之前就预先知道。在动态变化的堆栈上尝试做出这样的预测可能很困难。幸运的是，还有一种称为NOP滑梯的黑客技术，可以帮助完成这项困难的诡计。"NOP"是一种汇编指令，代表"无操作"。它是一个单字节指令，什么都不做。这些指令有时用于浪费计算周期以达到定时目的，在Sparc处理器架构中，由于指令流水线，这些指令实际上是必要的。在这种情况下，NOP指令将被用于不同的目的：作为调整因素。我们将创建一个由这些NOP指令组成的大数组（或滑梯），并将其放置在shellcode之前；然后，如果EIP寄存器指向NOP滑梯中找到的任何地址，它将在执行每个NOP指令时逐个递增，直到最终到达shellcode。这意味着只要返回地址被覆盖为NOP滑梯中找到的任何地址，EIP寄存器就会沿着滑梯滑到shellcode，并正确执行。在*x*86架构上，NOP指令相当于十六进制字节0x90。这意味着我们的完成后的漏洞缓冲区看起来可能像这样：
- en: '![](httpatomoreillycomsourcenostarchimages254213.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254213.png.jpg)'
- en: Figure 0x300-2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图0x300-2。
- en: Even with a NOP sled, the approximate location of the buffer in memory must
    be predicted in advance. One technique for approximating the memory location is
    to use a nearby stack location as a frame of reference. By subtracting an offset
    from this location, the relative address of any variable can be obtained.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有NOP滑梯，也必须在事先预测内存中缓冲区的近似位置。一种近似内存位置的技术是使用附近的堆栈位置作为参考框架。通过从这个位置减去一个偏移量，可以获取任何变量的相对地址。
- en: Experimenting with BASH
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在BASH中进行实验
- en: From exploit_notesearch.c
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从exploit_notesearch.c
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the notesearch exploit, the address of the variable `i` in `main()`'s stack
    frame is used as a point of reference. Then an offset is subtracted from that
    value; the result is the target return address. This offset was previously determined
    to be 270, but how is this number calculated?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在notesearch漏洞利用中，`main()`堆栈帧中变量`i`的地址被用作参考点。然后从这个值中减去一个偏移量；结果是目标返回地址。这个偏移量之前被确定为270，但这个数字是如何计算的呢？
- en: The easiest way to determine this offset is experimentally. The debugger will
    shift memory around slightly and will drop privileges when the suid root notesearch
    program is executed, making debugging much less useful in this case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确定这个偏移量最简单的方法是进行实验。调试器会稍微移动内存，并在执行suid root notesearch程序时降级权限，这使得在这种情况下调试变得非常无用。
- en: Since the notesearch exploit allows an optional command-line argument to define
    the offset, different offsets can quickly be tested.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于notesearch漏洞利用允许通过命令行参数定义偏移量，因此可以快速测试不同的偏移量。
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, doing this manually is tedious and stupid. BASH also has a for loop
    that can be used to automate this process. The `seq` command is a simple program
    that generates sequences of numbers, which is typically used with looping.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，手动做这件事既繁琐又愚蠢。BASH还有一个for循环可以用来自动化这个过程。`seq`命令是一个简单的程序，用于生成数字序列，通常与循环一起使用。
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When only two arguments are used, all the numbers from the first argument to
    the second are generated. When three arguments are used, the middle argument dictates
    how much to increment each time. This can be used with command substitution to
    drive BASH's for loop.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当只使用两个参数时，会生成从第一个参数到第二个参数的所有数字。当使用三个参数时，中间的参数决定了每次增加的量。这可以与命令替换一起使用，以驱动BASH的for循环。
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function of the for loop should be familiar, even if the syntax is a little
    different. The shell variable `$i` iterates through all the values found in the
    grave accents (generated by `seq`). Then everything between the `do` and `done`
    keywords is executed. This can be used to quickly test many different offsets.
    Since the NOP sled is 60 bytes long, and we can return anywhere on the sled, there
    is about 60 bytes of wiggle room. We can safely increment the offset loop with
    a step of 30 with no danger of missing the sled.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: for循环的功能应该很熟悉，即使语法略有不同。shell变量`$i`遍历由`seq`生成的所有值。然后，在`do`和`done`关键字之间执行所有内容。这可以用来快速测试许多不同的偏移量。由于NOP
    sled长度为60字节，并且我们可以在sled上的任何位置返回，因此大约有60字节的调整空间。我们可以安全地以30为步长递增偏移量循环，而不用担心错过sled。
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the right offset is used, the return address is overwritten with a value
    that points somewhere on the NOP sled. When execution tries to return to that
    location, it will just slide down the NOP sled into the injected shellcode instructions.
    This is how the default offset value was discovered.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用正确的偏移量时，返回地址会被覆盖为一个指向NOP sled上某个位置的值。当执行尝试返回到该位置时，它将滑入注入的shellcode指令。这就是默认偏移量值被发现的方式。
- en: Using the Environment
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Sometimes a buffer will be too small to hold even shellcode. Fortunately, there
    are other locations in memory where shellcode can be stashed. Environment variables
    are used by the user shell for a variety of things, but what they are used for
    isn't as important as the fact they are located on the stack and can be set from
    the shell. The example below sets an environment variable called `MYVAR` to the
    string *test*. This environment variable can be accessed by prepending a dollar
    sign to its name. In addition, the `env` command will show all the environment
    variables. Notice there are several default environment variables already set.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时缓冲区可能太小，甚至无法容纳shellcode。幸运的是，内存中还有其他位置可以存放shellcode。环境变量被用户shell用于各种目的，但它们被用于什么目的并不重要，重要的是它们位于栈上，并且可以从shell中设置。下面的示例将名为`MYVAR`的环境变量设置为字符串*test*。可以通过在其名称前加美元符号来访问这个环境变量。此外，`env`命令将显示所有环境变量。注意，已经设置了一些默认环境变量。
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Similarly, the shellcode can be put in an environment variable, but first it
    needs to be in a form we can easily manipulate. The shellcode from the notesearch
    exploit can be used; we just need to put it into a file in binary form. The standard
    shell tools of `head`, `grep`, and `cut` can be used to isolate just the hex-expanded
    bytes of the shellcode.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，shellcode可以放入环境变量中，但首先它需要是我们容易操作的形式。notesearch漏洞中的shellcode可以用来；我们只需要将其放入一个二进制格式的文件中。标准的shell工具`head`、`grep`和`cut`可以用来隔离shellcode的十六进制展开字节。
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first 10 lines of the program are piped into `grep`, which only shows the
    lines that begin with a quotation mark. This isolates the lines containing the
    shellcode, which are then piped into `cut` using options to display only the bytes
    between two quotation marks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的前10行被管道传输到`grep`，它只显示以引号开头的行。这可以隔离包含shellcode的行，然后使用选项将它们管道传输到`cut`，以显示两个引号之间的字节。
- en: BASH's for loop can actually be used to send each of these lines to an `echo`
    command, with command-line options to recognize hex expansion and to suppress
    adding a newline character to the end.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: BASH的for循环实际上可以用来将每一行发送到`echo`命令，带有命令行选项以识别十六进制展开并抑制在末尾添加换行符。
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now we have the shellcode in a file called shellcode.bin. This can be used with
    command substitution to put shellcode into an environment variable, along with
    a generous NOP sled.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`shellcode.bin`的文件，其中包含shellcode。这可以通过命令替换与shellcode一起放入环境变量中，并附带一个慷慨的NOP滑梯。
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And just like that, the shellcode is now on the stack in an environment variable,
    along with a 200-byte NOP sled. This means we just need to find an address somewhere
    in that range of the sled to overwrite the saved return address with. The environment
    variables are located near the bottom of the stack, so this is where we should
    look when running notesearch in a debugger.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，shellcode现在被放在了栈中的环境变量里，附带一个200字节的NOP滑梯。这意味着我们只需要在该滑梯范围内的某个地址上覆盖保存的返回地址即可。环境变量位于栈的底部附近，因此在调试器中运行notesearch时，我们应该在这里查找。
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A breakpoint is set at the beginning of `main()`, and the program is run. This
    will set up memory for the program, but it will stop before anything happens.
    Now we can examine memory down near the bottom of the stack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`的开始处设置一个断点，并运行程序。这将设置程序的内存，但在发生任何操作之前会停止。现在我们可以检查栈底附近的内存。
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The debugger reveals the location of the shellcode, shown in bold above. (When
    the program is run outside of the debugger, these addresses might be a little
    different.) The debugger also has some information on the stack, which shifts
    the addresses around a bit. But with a 200-byte NOP sled, these inconsistencies
    aren't a problem if an address near the middle of the sled is picked. In the output
    above, the address `0xbffff947` is shown to be close to the middle of the NOP
    sled, which should give us enough wiggle room. After determining the address of
    the injected shellcode instructions, the exploitation is simply a matter of overwriting
    the return address with this address.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器揭示了shellcode的位置，如上图中加粗所示。（当程序在调试器外运行时，这些地址可能略有不同。）调试器还有一些关于栈的信息，这会稍微改变地址。但是，如果有200字节的NOP滑梯，如果选择滑梯中间的地址，这些不一致性就不会成为问题。在上面的输出中，地址`0xbffff947`显示接近NOP滑梯的中间，这应该给我们足够的操作空间。在确定注入的shellcode指令的地址后，利用方法就是简单地用这个地址覆盖返回地址。
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The target address is repeated enough times to overflow the return address,
    and execution returns into the NOP sled in the environment variable, which inevitably
    leads to the shellcode. In situations where the overflow buffer isn't large enough
    to hold shellcode, an environment variable can be used with a large NOP sled.
    This usually makes exploitations quite a bit easier.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 目标地址被重复足够多次以溢出返回地址，执行返回到环境变量中的NOP滑梯，不可避免地导致shellcode。在溢出缓冲区不足以容纳shellcode的情况下，可以使用带有大NOP滑梯的环境变量。这通常使利用变得容易得多。
- en: A huge NOP sled is a great aid when you need to guess at the target return addresses,
    but it turns out that the locations of environment variables are easier to predict
    than the locations of local stack variables. In C's standard library there is
    a function called `getenv()`, which accepts the name of an environment variable
    as its only argument and returns that variable's memory address. The code in getenv_example.c
    demonstrates the use of `getenv()`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个巨大的NOP滑梯在需要猜测目标返回地址时非常有帮助，但结果表明，环境变量的位置比局部栈变量的位置更容易预测。在C的标准库中有一个名为`getenv()`的函数，它接受环境变量的名称作为其唯一参数，并返回该变量的内存地址。`getenv_example.c`中的代码展示了`getenv()`的使用。
- en: getenv_example.c
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getenv_example.c`'
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When compiled and run, this program will display the location of a given environment
    variable in its memory. This provides a much more accurate prediction of where
    the same environment variable will be when the target program is run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行此程序将显示给定环境变量在内存中的位置。这为预测目标程序运行时相同环境变量将位于何处提供了更准确的预测。
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is accurate enough with a large NOP sled, but when the same thing is attempted
    without a sled, the program crashes. This means the environment prediction is
    still off.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大NOP滑梯时，这已经足够准确，但如果没有滑梯尝试做同样的事情，程序会崩溃。这意味着环境预测仍然不准确。
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In order to be able to predict an exact memory address, the differences in the
    addresses must be explored. The length of the name of the program being executed
    seems to have an effect on the address of the environment variables. This effect
    can be further explored by changing the name of the program and experimenting.
    This type of experimentation and pattern recognition is an important skill for
    a hacker to have.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够预测一个确切的内存地址，必须探索地址之间的差异。正在执行程序的名称长度似乎对环境变量的地址有影响。通过更改程序名称并进行实验可以进一步探索这种影响。这种实验和模式识别对于黑客来说是一项重要的技能。
- en: '[PRE54]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As the preceding experiment shows, the length of the name of the executing program
    has an effect on the location of exported environment variables. The general trend
    seems to be a decrease of two bytes in the address of the environment variable
    for every single-byte increase in the length of the program name. This holds true
    with the program name *a.out*, since the difference in length between the names
    *a.out* and *a* is four bytes, and the difference between the address `0xbfffff4e`
    and `0xbfffff46` is eight bytes. This must mean the name of the executing program
    is also located on the stack somewhere, which is causing the shifting.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的实验显示，执行程序的名称长度会影响导出环境变量的位置。一般趋势似乎是在程序名称长度每增加一个字节的情况下，环境变量的地址减少两个字节。这对于程序名称
    *a.out* 也是成立的，因为 *a.out* 和 *a* 之间的长度差异是四个字节，而地址 `0xbfffff4e` 和 `0xbfffff46` 之间的差异是八个字节。这意味着执行程序的名称也位于某个位置的栈上，这导致了偏移。
- en: Armed with this knowledge, the exact address of the environment variable can
    be predicted when the vulnerable program is executed. This means the crutch of
    a NOP sled can be eliminated. The getenvaddr.c program adjusts the address based
    on the difference in program name length to provide a very accurate prediction.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种知识，当易受攻击的程序执行时，可以预测环境变量的确切地址。这意味着可以消除 NOP 滑梯的辅助手段。getenvaddr.c 程序根据程序名称长度的差异调整地址，以提供非常准确的预测。
- en: getenvaddr.c
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getenvaddr.c
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When compiled, this program can accurately predict where an environment variable
    will be in memory during a target program's execution. This can be used to exploit
    stack-based buffer overflows without the need for a NOP sled.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译时，此程序可以准确预测在目标程序执行期间环境变量将在内存中的位置。这可以用来利用基于栈的缓冲区溢出，而无需 NOP 滑梯。
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, exploit code isn't always needed to exploit programs. The use
    of environment variables simplifies things considerably when exploiting from the
    command line, but these variables can also be used to make exploit code more reliable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，利用程序并不总是需要利用代码。在命令行中进行利用时，使用环境变量可以大大简化事情。但也可以使用这些变量来使利用代码更加可靠。
- en: The `system()` function is used in the notesearch_exploit.c program to execute
    a command. This function starts a new process and runs the command using `/bin/sh
    -c`. The `-c` tells the `sh` program to execute commands from the command-line
    argument passed to it. Google's code search can be used to find the source code
    for this function, which will tell us more. Go to [http://www.google.com/codesearch?q=package:libc+system](http://www.google.com/codesearch?q=package:libc+system)
    to see this code in its entirety.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 notesearch_exploit.c 程序中，使用 `system()` 函数执行命令。此函数启动一个新的进程，并使用 `/bin/sh -c`
    运行命令。`-c` 告诉 `sh` 程序执行从命令行参数传递给它的命令。可以使用 Google 的代码搜索来查找此函数的源代码，这将告诉我们更多信息。请访问
    [http://www.google.com/codesearch?q=package:libc+system](http://www.google.com/codesearch?q=package:libc+system)
    以查看此代码的完整内容。
- en: Code from libc-2.2.2
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 libc-2.2.2 的代码
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The important part of this function is shown in bold. The `fork()` function
    starts a new process, and the `execl()` function is used to run the command through
    /bin/sh with the appropriate command-line arguments.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的重要部分以粗体显示。`fork()` 函数启动一个新的进程，而 `execl()` 函数用于通过 /bin/sh 运行命令，并带有适当的命令行参数。
- en: The use of `system()` can sometimes cause problems. If a setuid program uses
    `system()`, the privileges won't be transferred, because /bin/sh has been dropping
    privileges since version two. This isn't the case with our exploit, but the exploit
    doesn't really need to be starting a new process, either. We can ignore the `fork()`
    and just focus on the `execl()` function to run the command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `system()` 有时可能会引起问题。如果一个 setuid 程序使用 `system()`，权限不会传递，因为从版本二开始 /bin/sh
    就在放弃权限。这种情况并不适用于我们的漏洞利用，但漏洞利用实际上也不需要启动新的进程。我们可以忽略 `fork()`，只关注 `execl()` 函数来运行命令。
- en: The `execl()` function belongs to a family of functions that execute commands
    by replacing the current process with the new one. The arguments for `execl()`
    start with the path to the target program and are followed by each of the command-line
    arguments. The second function argument is actually the zeroth command-line argument,
    which is the name of the program. The last argument is a NULL to terminate the
    argument list, similar to how a null byte terminates a string.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl()` 函数属于一组通过替换当前进程为新进程来执行命令的函数。`execl()` 的参数从目标程序的路径开始，后面跟着每个命令行参数。第二个函数参数实际上是零号命令行参数，即程序的名称。最后一个参数是一个NULL，用于终止参数列表，类似于空字节终止字符串的方式。'
- en: The `execl()` function has a sister function called `execle()`, which has one
    additional argument to specify the environment under which the executing process
    should run. This environment is presented in the form of an array of pointers
    to null-terminated strings for each environment variable, and the environment
    array itself is terminated with a NULL pointer.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl()` 函数有一个姐妹函数叫做 `execle()`，它有一个额外的参数来指定执行进程应该运行的环境。这个环境以每个环境变量的空终止字符串指针数组的形式呈现，环境数组本身以一个NULL指针终止。'
- en: With `execl()`, the existing environment is used, but if you use `execle()`,
    the entire environment can be specified. If the environment array is just the
    shellcode as the first string (with a NULL pointer to terminate the list), the
    only environment variable will be the shellcode. This makes its address easy to
    calculate. In Linux, the address will be `0xbffffffa`, minus the length of the
    shellcode in the environment, minus the length of the name of the executed program.
    Since this address will be exact, there is no need for a NOP sled. All that's
    needed in the exploit buffer is the address, repeated enough times to overflow
    the return address in the stack, as shown in exploit_nosearch_env.c.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `execl()` 时，会使用现有的环境，但如果使用 `execle()`，则可以指定整个环境。如果环境数组只是作为第一个字符串的shellcode（以NULL指针终止列表），则唯一的环境变量将是shellcode。这使得其地址很容易计算。在Linux中，地址将是
    `0xbffffffa` 减去环境中的shellcode长度，减去执行程序名称的长度。由于这个地址将是精确的，因此不需要NOP sled。漏洞利用缓冲区中只需要地址，重复足够次数以溢出栈中的返回地址，如exploit_nosearch_env.c所示。
- en: exploit_notesearch_env.c
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exploit_notesearch_env.c
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This exploit is more reliable, since it doesn't need a NOP sled or any guesswork
    regarding offsets. Also, it doesn't start any additional processes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞利用方法更可靠，因为它不需要NOP sled或对偏移量的任何猜测。此外，它不会启动任何额外的进程。
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Overflows in Other Segments
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他段的溢出
- en: Buffer overflows can happen in other memory segments, like heap and bss. As
    in auth_overflow.c, if an important variable is located after a buffer vulnerable
    to an overflow, the program's control flow can be altered. This is true regardless
    of the memory segment these variables reside in; however, the control tends to
    be quite limited. Being able to find these control points and learning to make
    the most of them just takes some experience and creative thinking. While these
    types of overflows aren't as standardized as stack-based overflows, they can be
    just as effective.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区溢出也可能发生在其他内存段，如堆和bss。在 auth_overflow.c 中，如果重要的变量位于易受溢出攻击的缓冲区之后，程序的控制流可能会被改变。这一点适用于这些变量所在的任何内存段；然而，控制通常相当有限。能够找到这些控制点并学会充分利用它们只需要一些经验和创造性思维。虽然这些类型的溢出不像基于栈的溢出那样标准化，但它们同样有效。
- en: A Basic Heap-Based Overflow
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于堆的基本溢出
- en: The notetaker program from [Chapter 0x200](ch02.html "Chapter 0x200. PROGRAMMING")
    is also susceptible to a buffer overflow vulnerability. Two buffers are allocated
    on the heap, and the first command-line argument is copied into the first buffer.
    An overflow can occur here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [第 0x200 章](ch02.html "第 0x200 章。编程") 的记事本程序也容易受到缓冲区溢出漏洞的影响。在堆上分配了两个缓冲区，第一个命令行参数被复制到第一个缓冲区。这里可能会发生溢出。
- en: Excerpt from notetaker.c
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自 notetaker.c 的摘录
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Under normal conditions, the buffer allocation is located at `0x804a008`, which
    is before the `datafile` allocation at `0x804a070`, as the debugging output shows.
    The distance between these two addresses is 104 bytes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，缓冲区分配位于 `0x804a008`，在 `datafile` 分配的 `0x804a070` 之前，正如调试输出所示。这两个地址之间的距离是
    104 字节。
- en: '[PRE61]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since the first buffer is null terminated, the maximum amount of data that can
    be put into this buffer without overflowing into the next should be 104 bytes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个缓冲区是空终止的，因此在不溢出到下一个缓冲区的情况下，可以放入此缓冲区的最大数据量应该是 104 字节。
- en: '[PRE62]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As predicted, when 104 bytes are tried, the null-termination byte overflows
    into the beginning of the `datafile` buffer. This causes the `datafile` to be
    nothing but a single null byte, which obviously cannot be opened as a file. But
    what if the `datafile` buffer is overwritten with something more than just a null
    byte?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当尝试 104 字节时，空终止字节溢出到 `datafile` 缓冲区的开始处。这导致 `datafile` 只是一个单独的空字节，显然不能作为一个文件打开。但如果
    `datafile` 缓冲区被覆盖的内容不仅仅是空字节呢？
- en: '[PRE63]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This time, the overflow is designed to overwrite the `datafile` buffer with
    the string *testfile*. This causes the program to write to testfile instead of
    /var/notes, as it was originally programmed to do. However, when the heap memory
    is freed by the `free()` command, errors in the heap headers are detected and
    the program is terminated. Similar to the return address overwrite with stack
    overflows, there are control points within the heap architecture itself. The most
    recent version of glibc uses heap memory management functions that have evolved
    specifically to counter heap unlinking attacks. Since version 2.2.5, these functions
    have been rewritten to print debugging information and terminate the program when
    they detect problems with the heap header information. This makes heap unlinking
    in Linux very difficult. However, this particular exploit doesn't use heap header
    information to do its magic, so by the time `free()` is called, the program has
    already been tricked into writing to a new file with root privileges.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，溢出被设计用来用字符串 *testfile* 覆盖 `datafile` 缓冲区。这导致程序将数据写入 testfile 而不是按照最初编程的方式写入
    /var/notes。然而，当通过 `free()` 命令释放堆内存时，检测到堆头错误，程序被终止。与堆溢出导致的返回地址覆盖类似，堆架构本身内部存在控制点。glibc
    的最新版本使用的是专门为了对抗堆解除链接攻击而演化的堆内存管理函数。自 2.2.5 版本以来，这些函数已被重写，以便在检测到堆头信息问题时打印调试信息并终止程序。这使得
    Linux 中的堆解除链接变得非常困难。然而，这个特定的漏洞利用并没有使用堆头信息来施展其魔法，因此在调用 `free()` 之前，程序已经被欺骗写入了一个新的文件，并且具有
    root 权限。
- en: '[PRE64]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A string is read until a null byte is encountered, so the entire string is written
    to the file as the `userinput`. Since this is a suid root program, the file that
    is created is owned by root. This also means that since the filename can be controlled,
    data can be appended to any file. This data does have some restrictions, though;
    it must end with the controlled filename, and a line with the user ID will be
    written, also.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 读取字符串直到遇到空字节，因此整个字符串作为 `userinput` 写入文件。由于这是一个 suid root 程序，因此创建的文件属于 root。这也意味着，由于可以控制文件名，可以将数据追加到任何文件。尽管这些数据有一些限制；它必须以受控的文件名结束，并且还会写入一个包含用户
    ID 的行。
- en: There are probably several clever ways to exploit this type of capability. The
    most apparent one would be to append something to the /etc/passwd file. This file
    contains all of the usernames, IDs, and login shells for all the users of the
    system. Naturally, this is a critical system file, so it is a good idea to make
    a backup copy before messing with it too much.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在几种巧妙的方式来利用这种能力。最明显的一种是将内容追加到 /etc/passwd 文件中。该文件包含系统中所有用户的用户名、ID 和登录 shell。显然，这是一个关键的系统文件，所以在对其进行大量操作之前，制作一个备份副本是个好主意。
- en: '[PRE65]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The fields in the /etc/passwd file are delimited by colons, the first field
    being for login name, then password, user ID, group ID, username, home directory,
    and finally the login shell. The password fields are all filled with the *x* character,
    since the encrypted passwords are stored elsewhere in a shadow file. (However,
    this field can contain the encrypted password.) In addition, any entry in the
    password file that has a user ID of 0 will be given root privileges. That means
    the goal is to append an extra entry with both root privileges and a known password
    to the password file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: /etc/passwd 文件中的字段由冒号分隔，第一个字段是登录名，然后是密码，用户 ID，组 ID，用户名，家目录，最后是登录 shell。密码字段都填充了
    *x* 字符，因为加密密码存储在别处的一个影子文件中。（然而，这个字段可以包含加密密码。）此外，任何具有用户 ID 为 0 的密码文件条目都将获得 root
    权限。这意味着目标是向密码文件追加一个具有 root 权限和已知密码的额外条目。
- en: The password can be encrypted using a one-way hashing algorithm. Because the
    algorithm is one way, the original password cannot be recreated from the hash
    value. To prevent lookup attacks, the algorithm uses a *salt value*, which when
    varied creates a different hash value for the same input password. This is a common
    operation, and Perl has a `crypt()` function that performs it. The first argument
    is the password, and the second is the salt value. The same password with a different
    salt produces a different salt.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 密码可以使用单向哈希算法进行加密。由于算法是单向的，原始密码不能从哈希值中重新创建。为了防止查找攻击，算法使用一个 *盐值*，该值的变化会为相同的输入密码生成不同的哈希值。这是一个常见的操作，Perl
    有一个 `crypt()` 函数可以执行这个操作。第一个参数是密码，第二个是盐值。使用不同的盐值生成的相同密码会产生不同的盐。
- en: '[PRE66]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that the salt value is always at the beginning of the hash. When a user
    logs in and enters a password, the system looks up the encrypted password for
    that user. Using the salt value from the stored encrypted password, the system
    uses the same one-way hashing algorithm to encrypt whatever text the user typed
    as the password. Finally, the system compares the two hashes; if they are the
    same, the user must have entered the correct password. This allows the password
    to be used for authentication without requiring that the password be stored anywhere
    on the system.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到盐值总是在哈希的开始处。当用户登录并输入密码时，系统会查找该用户的加密密码。使用存储的加密密码中的盐值，系统使用相同的单向哈希算法加密用户输入的任何文本作为密码。最后，系统比较这两个哈希值；如果它们相同，则用户必须输入了正确的密码。这允许使用密码进行身份验证，而无需在系统上的任何地方存储密码。
- en: 'Using one of these hashes in the password field will make the password for
    the account be *password*, regardless of the salt value used. The line to append
    to /etc/passwd should look something like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码字段中使用这些哈希值之一将使账户的密码为 *password*，无论使用的盐值如何。要追加到 /etc/passwd 的行可能看起来像这样：
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'However, the nature of this particular heap overflow exploit won''t allow that
    exact line to be written to /etc/passwd, because the string must end with /etc/passwd.
    However, if that filename is merely appended to the end of the entry, the passwd
    file entry would be incorrect. This can be compensated for with the clever use
    of a symbolic file link, so the entry can both end with /etc/passwd and still
    be a valid line in the password file. Here''s how it works:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个特定的堆溢出漏洞的性质不允许将这条确切的行写入 /etc/passwd，因为字符串必须以 /etc/passwd 结尾。然而，如果将那个文件名仅仅追加到条目末尾，密码文件条目就会不正确。这可以通过巧妙地使用符号文件链接来补偿，这样条目就可以以
    /etc/passwd 结尾，同时仍然是密码文件中的一个有效行。下面是如何工作的：
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now /tmp/etc/passwd points to the login shell /bin/bash. This means that a
    valid login shell for the password file is also /tmp/etc/passwd, making the following
    a valid password file line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 /tmp/etc/passwd 指向登录 shell /bin/bash。这意味着密码文件的合法登录 shell 也是 /tmp/etc/passwd，因此以下行是一个有效的密码文件行：
- en: '[PRE69]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The values of this line just need to be slightly modified so that the portion
    before /etc/passwd is exactly 104 bytes long:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这行值的修改只需稍微调整，使得在 /etc/passwd 之前的部分正好是 104 字节长：
- en: '[PRE70]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If /etc/passwd is added to the end of that final string (shown in bold), the
    string above will be appended to the end of the /etc/passwd file. And since this
    line defines an account with root privileges with a password we set, it won't
    be difficult to access this account and obtain root access, as the following output
    shows.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 /etc/passwd 添加到那个最终字符串的末尾（如粗体所示），上面的字符串将被追加到 /etc/passwd 文件的末尾。由于这一行定义了一个具有我们设置的密码的
    root 权限账户，因此访问此账户并获得 root 权限不会很难，如下面的输出所示。
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Overflowing Function Pointers
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出函数指针
- en: If you have played with the game_of_chance.c program enough, you will realize
    that, similar to at a casino, most of the games are statistically weighted in
    favor of the house. This makes winning credits difficult, despite how lucky you
    might be. Perhaps there's a way to even the odds a bit. This program uses a function
    pointer to remember the last game played. This pointer is stored in the `user`
    structure, which is declared as a global variable. This means all the memory for
    the user structure is allocated in the bss segment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经足够多地玩过`game_of_chance.c`程序，你会意识到，类似于在赌场，大多数游戏在统计上偏向于庄家。这使得赢得积分变得困难，尽管你可能很幸运。也许有一种方法可以稍微平衡一下概率。这个程序使用函数指针来记住最后玩过的游戏。这个指针存储在`user`结构中，该结构被声明为全局变量。这意味着用户结构的所有内存都在bss段中分配。
- en: From game_of_chance.c
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 来自`game_of_chance.c`
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The name buffer in the user structure is a likely place for an overflow. This
    buffer is set by the `input_name()` function, shown below:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用户结构中的名称缓冲区很可能是溢出的地方。这个缓冲区是由下面的`input_name()`函数设置的：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This function only stops inputting at a newline character. There is nothing
    to limit it to the length of the destination name buffer, meaning an overflow
    is possible. In order to take advantage of the overflow, we need to make the program
    call the function pointer after it is overwritten. This happens in the `play_the_game()`
    function, which is called when any game is selected from the menu. The following
    code snippet is part of the menu selection code, used for picking and playing
    a game.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只在换行符处停止输入。没有任何东西限制它只能输入到目标名称缓冲区的长度，这意味着可能发生溢出。为了利用溢出，我们需要让程序在覆盖函数指针后调用它。这发生在`play_the_game()`函数中，该函数在从菜单中选择任何游戏时被调用。以下代码片段是菜单选择代码的一部分，用于选择和玩游戏。
- en: '[PRE74]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If `last_game` isn't the same as the current choice, the function pointer of
    `current_game` is changed to the appropriate game. This means that in order to
    get the program to call the function pointer without overwriting it, a game must
    be played first to set the `last_game` variable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`last_game`与当前选择不同，`current_game`的函数指针将被更改为适当的游戏。这意味着为了使程序调用函数指针而不覆盖它，必须先玩一个游戏来设置`last_game`变量。
- en: '[PRE75]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can temporarily suspend the current process by pressing CTRL-Z. At this
    point, the `last_game` variable has been set to 1, so the next time 1 is selected,
    the function pointer will simply be called without being changed. Back at the
    shell, we figure out an appropriate overflow buffer, which can be copied and pasted
    in as a name later. Recompiling the source with debugging symbols and using GDB
    to run the program with a breakpoint on `main()` allows us to explore the memory.
    As the output below shows, the name buffer is 100 bytes from the `current_game`
    pointer within the user structure.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按CTRL-Z来暂时挂起当前进程。此时，`last_game`变量已被设置为1，所以下次选择1时，函数指针将直接被调用而不会被更改。回到shell后，我们找出一个合适的溢出缓冲区，稍后可以作为名称粘贴进去。通过带有调试符号重新编译源代码并使用GDB在`main()`上设置断点来运行程序，我们可以探索内存。如下面的输出所示，名称缓冲区位于用户结构中的`current_game`指针100字节处。
- en: '[PRE76]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Using this information, we can generate a buffer to overflow the name variable
    with. This can be copied and pasted into the interactive Game of Chance program
    when it is resumed. To return to the suspended process, just type `fg`, which
    is short for *foreground*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以生成一个缓冲区来溢出名称变量。这可以在程序恢复时复制并粘贴到交互式“机会游戏”程序中。要返回挂起的进程，只需输入`fg`，这是*前台*的缩写。
- en: '[PRE77]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Select menu option 5 to change the username, and paste in the overflow buffer.
    This will overwrite the function pointer with `0x42424242`. When menu option 1
    is selected again, the program will crash when it tries to call the function pointer.
    This is proof that execution can be controlled; now all that's needed is a valid
    address to insert in place of *BBBB*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 选择菜单选项5来更改用户名，并将溢出缓冲区粘贴进去。这将用`0x42424242`覆盖函数指针。当再次选择菜单选项1时，程序在尝试调用函数指针时会崩溃。这证明了执行可以被控制；现在所需的就是一个有效的地址来替换*BBBB*。
- en: The `nm` command lists symbols in object files. This can be used to find addresses
    of various functions in a program.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`nm`命令列出了目标文件中的符号。这可以用来查找程序中各种函数的地址。'
- en: '[PRE78]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `jackpot()` function is a wonderful target for this exploit. Even though
    the games give terrible odds, if the `current_game` function pointer is carefully
    overwritten with the address of the `jackpot()` function, you won't even have
    to play the game to win credits. Instead, the `jackpot()` function will just be
    called directly, doling out the reward of 100 credits and tipping the scales in
    the player's direction.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`jackpot()`函数是这种攻击的一个很好的目标。尽管游戏给出的赔率很差，但如果将`current_game`函数指针小心地覆盖为`jackpot()`函数的地址，您甚至不需要玩游戏就能赢得积分。相反，将直接调用`jackpot()`函数，发放100积分，并使玩家处于有利地位。'
- en: This program takes its input from standard input. The menu selections can be
    scripted in a single buffer that is piped to the program's standard input. These
    selections will be made as if they were typed. The following example will choose
    menu item 1, try to guess the number 7, select `n` when asked to play again, and
    finally select menu item 7 to quit.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序从标准输入获取输入。菜单选择可以脚本化在一个单独的缓冲区中，然后通过程序的标准输入管道传输。这些选择将像输入一样被做出。以下示例将选择菜单项1，尝试猜测数字7，当被要求再次玩游戏时选择`n`，最后选择菜单项7以退出。
- en: '[PRE79]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This same technique can be used to script everything needed for the exploit.
    The following line will play the Pick a Number game once, then change the username
    to 100 *A*'s followed by the address of the `jackpot()` function. This will overflow
    the `current_game` function pointer, so when the Pick a Number game is played
    again, the `jackpot()` function is called directly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术可以用来脚本化攻击所需的所有内容。以下行将玩一次“选择一个数字”游戏，然后更改用户名为100个`A`，后面跟着`jackpot()`函数的地址。这将溢出`current_game`函数指针，所以当再次玩“选择一个数字”游戏时，将直接调用`jackpot()`函数。
- en: '[PRE80]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: After confirming that this method works, it can be expanded upon to gain any
    number of credits.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认这种方法有效后，它可以扩展以获得任意数量的积分。
- en: '[PRE81]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As you might have already noticed, this program also runs suid root. This means
    shellcode can be used to do a lot more than win free credits. As with the stack-based
    overflow, shellcode can be stashed in an environment variable. After building
    a suitable exploit buffer, the buffer is piped to the game_of_chance's standard
    input. Notice the dash argument following the exploit buffer in the cat command.
    This tells the cat program to send standard input after the exploit buffer, returning
    control of the input. Even though the root shell doesn't display its prompt, it
    is still accessible and still escalates privileges.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，此程序还以suid root运行。这意味着shellcode可以用来做比赢得免费积分更多的事情。与基于堆的溢出一样，shellcode可以存储在环境变量中。在构建合适的攻击缓冲区后，该缓冲区被管道传输到`game_of_chance`的标准输入。注意cat命令中在攻击缓冲区后面的破折号参数。这告诉cat程序在攻击缓冲区之后发送标准输入，返回输入控制。即使root
    shell不显示其提示符，它仍然可访问，并且仍然提升权限。
- en: '[PRE82]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Format Strings
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: A format string exploit is another technique you can use to gain control of
    a privileged program. Like buffer overflow exploits, *format string exploits*
    also depend on programming mistakes that may not appear to have an obvious impact
    on security. Luckily for programmers, once the technique is known, it's fairly
    easy to spot format string vulnerabilities and eliminate them. Although format
    string vulnerabilities aren't very common anymore, the following techniques can
    also be used in other situations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串漏洞攻击是另一种可以用来控制特权程序的技术。与缓冲区溢出攻击一样，*格式化字符串漏洞攻击*也依赖于可能不会对安全性产生明显影响的编程错误。幸运的是，对于程序员来说，一旦知道了这种技术，就相当容易发现格式化字符串漏洞并消除它们。尽管格式化字符串漏洞现在已不太常见，但以下技术也可以用于其他情况。
- en: Format Parameters
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化参数
- en: You should be fairly familiar with basic format strings by now. They have been
    used extensively with functions like `printf()` in previous programs. A function
    that uses format strings, such as `printf()`, simply evaluates the format string
    passed to it and performs a special action each time a format parameter is encountered.
    Each format parameter expects an additional variable to be passed, so if there
    are three format parameters in a format string, there should be three more arguments
    to the function (in addition to the format string argument).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该对基本的格式化字符串相当熟悉了。它们在之前的程序中广泛使用了像`printf()`这样的函数。使用格式化字符串的函数，如`printf()`，简单地评估传递给它的格式化字符串，并在遇到格式参数时执行特殊操作。每个格式参数都期望传递一个额外的变量，所以如果格式字符串中有三个格式参数，那么应该有更多的函数参数（除了格式字符串参数）。
- en: Recall the various format parameters explained in the previous chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一章中解释的各种格式参数。
- en: '| Parameter | Input Type | Output Type |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 输入类型 | 输出类型 |'
- en: '| --- | --- | --- |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%d` | Value | Decimal |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 值 | 十进制 |'
- en: '| `%u` | Value | Unsigned decimal |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 值 | 无符号十进制 |'
- en: '| `%x` | Value | Hexadecimal |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 值 | 十六进制 |'
- en: '| `%s` | Pointer | String |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 指针 | 字符串 |'
- en: '| `%n` | Pointer | Number of bytes written so far |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `%n` | 指针 | 已写入的字节数 |'
- en: The previous chapter demonstrated the use of the more common format parameters,
    but neglected the less common `%n` format parameter. The fmt_uncommon.c code demonstrates
    its use.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章演示了更常见的格式参数的使用，但忽略了较少见的 `%n` 格式参数。`fmt_uncommon.c` 代码演示了其使用。
- en: fmt_uncommon.c
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fmt_uncommon.c
- en: '[PRE83]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This program uses two `%n` format parameters in its `printf()` statement. The
    following is the output of the program's compilation and execution.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在其 `printf()` 语句中使用两个 `%n` 格式参数。以下是程序编译和执行的输出。
- en: '[PRE84]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `%n` format parameter is unique in that it writes data without displaying
    anything, as opposed to reading and then displaying data. When a format function
    encounters a `%n` format parameter, it writes the number of bytes that have been
    written by the function to the address in the corresponding function argument.
    In `fmt_uncommon`, this is done in two places, and the unary address operator
    is used to write this data into the variables `count_one` and `count_two`, respectively.
    The values are then outputted, revealing that 46 bytes are found before the first
    `%n` and 113 before the second.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`%n` 格式参数独特之处在于它写入数据而不显示任何内容，与读取然后显示数据相反。当格式函数遇到 `%n` 格式参数时，它将函数已写入的字节数写入对应函数参数中的地址。在
    `fmt_uncommon` 中，这是在两个地方完成的，使用一元地址运算符将此数据写入变量 `count_one` 和 `count_two`，分别。然后输出这些值，揭示在第一个
    `%n` 之前找到了 46 个字节，在第二个 `%n` 之前找到了 113 个。'
- en: 'The stack example at the end is a convenient segue into an explanation of the
    stack''s role with format strings:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的栈示例很方便地过渡到解释栈在格式字符串中的作用：
- en: '[PRE85]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: When this `printf()` function is called (as with any function), the arguments
    are pushed to the stack in reverse order. First the value of `B`, then the address
    of `A`, then the value of `A`, and finally the address of the format string.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此 `printf()` 函数（就像调用任何函数一样），参数以相反的顺序推送到栈中。首先是 `B` 的值，然后是 `A` 的地址，接着是 `A`
    的值，最后是格式字符串的地址。
- en: The stack will look like the diagram here.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 栈看起来就像这里的图示。
- en: The format function iterates through the format string one character at a time.
    If the character isn't the beginning of a format parameter (which is designated
    by the percent sign), the character is copied to the output. If a format parameter
    is encountered, the appropriate action is taken, using the argument in the stack
    corresponding to that parameter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 格式函数逐字符遍历格式字符串。如果字符不是格式参数的开始（由百分号指定），则字符被复制到输出。如果遇到格式参数，则采取相应的操作，使用与该参数对应的栈中的参数。
- en: '![](httpatomoreillycomsourcenostarchimages254207.png.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](httpatomoreillycomsourcenostarchimages254207.png.jpg)'
- en: Figure 0x300-3.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x300-3。
- en: But what if only two arguments are pushed to the stack with a format string
    that uses three format parameters? Try removing the last argument from the `printf()`
    line for the stack example so it matches the line shown below.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果只有两个参数被推送到栈中，而格式字符串使用了三个格式参数，会怎样呢？尝试从栈示例的 `printf()` 行中移除最后一个参数，使其与下面的行匹配。
- en: '[PRE86]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This can be done in an editor or with a little bit of `sed` magic.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在编辑器中完成，或者使用一点 `sed` 魔法。
- en: '[PRE87]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The result is `b7fd6ff4`. What the hell is `b7fd6ff4`? It turns out that since
    there wasn't a value pushed to the stack, the format function just pulled data
    from where the third argument should have been (by adding to the current frame
    pointer). This means `0xb7fd6ff4` is the first value found below the stack frame
    for the format function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `b7fd6ff4`。`b7fd6ff4` 是什么意思？结果证明，由于没有值被推送到栈中，格式函数只是从第三参数应该存在的地方（通过增加当前帧指针）拉取数据。这意味着
    `0xb7fd6ff4` 是格式函数栈帧下面的第一个值。
- en: This is an interesting detail that should be remembered. It certainly would
    be a lot more useful if there were a way to control either the number of arguments
    passed to or expected by a format function. Luckily, there is a fairly common
    programming mistake that allows for the latter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应该记住的有趣细节。如果有一种方法可以控制传递给或期望格式函数的参数数量，那将非常有用。幸运的是，有一个相当常见的编程错误允许这样做。
- en: The Format String Vulnerability
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式字符串漏洞
- en: Sometimes programmers use `printf(string)` instead of `printf("%s", string)`
    to print strings. Functionally, this works fine. The format function is passed
    the address of the string, as opposed to the address of a format string, and it
    iterates through the string, printing each character. Examples of both methods
    are shown in fmt_vuln.c.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有时程序员使用 `printf(string)` 而不是 `printf("%s", string)` 来打印字符串。从功能上讲，这没问题。格式函数接收字符串的地址，而不是格式字符串的地址，并遍历字符串，打印每个字符。这两种方法的示例在
    fmt_vuln.c 中展示。
- en: fmt_vuln.c
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fmt_vuln.c
- en: '[PRE88]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The following output shows the compilation and execution of fmt_vuln.c.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了 fmt_vuln.c 的编译和执行过程。
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Both methods seem to work with the string *testing*. But what happens if the
    string contains a format parameter? The format function should try to evaluate
    the format parameter and access the appropriate function argument by adding to
    the frame pointer. But as we saw earlier, if the appropriate function argument
    isn't there, adding to the frame pointer will reference a piece of memory in a
    preceding stack frame.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法似乎都可以与字符串 *testing* 一起工作。但如果字符串包含格式参数会怎样呢？格式函数应该尝试评估格式参数，并通过增加帧指针来访问适当的函数参数。但正如我们之前看到的，如果适当的函数参数不存在，增加帧指针将引用前一个栈帧中的内存。
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: When the `%x` format parameter was used, the hexadecimal representation of a
    four-byte word in the stack was printed. This process can be used repeatedly to
    examine stack memory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `%x` 格式参数时，打印了栈中四字节单词的十六进制表示。这个过程可以重复使用来检查栈内存。
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This is what the lower stack memory looks like. Remember that each four-byte
    word is backward, due to the little-endian architecture. The bytes `0x25, 0x30,
    0x38, 0x78`, and `0x2e` seem to be repeating a lot. Wonder what those bytes are?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是低栈内存的样貌。记住，由于小端架构，每个四字节单词是反向的。字节`0x25, 0x30, 0x38, 0x78`和`0x2e`似乎重复很多。想知道这些字节是什么吗？
- en: '[PRE92]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: As you can see, they're the memory for the format string itself. Because the
    format function will always be on the highest stack frame, as long as the format
    string has been stored anywhere on the stack, it will be located below the current
    frame pointer (at a higher memory address). This fact can be used to control arguments
    to the format function. It is particularly useful if format parameters that pass
    by reference are used, such as `%s` or `%n`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们是格式字符串本身的内存。因为格式函数始终位于最高的栈帧中，只要格式字符串存储在栈上的任何位置，它就会位于当前帧指针下方（在更高的内存地址）。这个事实可以用来控制格式函数的参数。如果使用通过引用传递的格式参数，如
    `%s` 或 `%n`，这尤其有用。
- en: Reading from Arbitrary Memory Addresses
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从任意内存地址读取
- en: 'The `%s` format parameter can be used to read from arbitrary memory addresses.
    Since it''s possible to read the data of the original format string, part of the
    original format string can be used to supply an address to the `%s` format parameter,
    as shown here:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s` 格式参数可以用来从任意内存地址读取。由于可以读取原始格式字符串的数据，原始格式字符串的一部分可以用来向 `%s` 格式参数提供一个地址，如下所示：'
- en: '[PRE93]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The four bytes of `0x41` indicate that the fourth format parameter is reading
    from the beginning of the format string to get its data. If the fourth format
    parameter is `%s` instead of `%x`, the format function will attempt to print the
    string located at `0x41414141`. This will cause the program to crash in a segmentation
    fault, since this isn't a valid address. But if a valid memory address is used,
    this process could be used to read a string found at that memory address.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x41` 的四个字节表明第四个格式参数正在从格式字符串的起始位置读取以获取其数据。如果第四个格式参数是 `%s` 而不是 `%x`，格式函数将尝试打印位于
    `0x41414141` 的字符串。这将导致程序在段错误中崩溃，因为这不是一个有效的地址。但如果使用有效的内存地址，这个过程可以用来读取位于该内存地址的字符串。'
- en: '[PRE94]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here the `getenvaddr` program is used to get the address for the environment
    variable `PATH`. Since the program name *fmt_vuln* is two bytes less than *getenvaddr*,
    four is added to the address, and the bytes are reversed due to the byte ordering.
    The fourth format parameter of `%s` reads from the beginning of the format string,
    thinking it's the address that was passed as a function argument. Since this address
    is the address of the `PATH` environment variable, it is printed as if a pointer
    to the environment variable were passed to `printf()`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `getenvaddr` 程序来获取环境变量 `PATH` 的地址。由于程序名 *fmt_vuln* 比程序名 *getenvaddr*
    少两个字节，所以地址上加了四，由于字节序的原因，字节被反转。`%s` 的第四个格式参数从格式字符串的起始位置读取，认为它是作为函数参数传递的地址。由于这个地址是
    `PATH` 环境变量的地址，所以它被打印出来，就像将环境变量的指针传递给 `printf()` 一样。
- en: Now that the distance between the end of the stack frame and the beginning of
    the format string memory is known, the field-width arguments can be omitted in
    the `%x` format parameters. These format parameters are only needed to step through
    memory. Using this technique, any memory address can be examined as a string.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已知栈帧末尾和格式字符串内存起始之间的距离，可以省略 `%x` 格式参数中的字段宽度参数。这些格式参数只需要用来遍历内存。使用这种技术，任何内存地址都可以作为字符串来检查。
- en: Writing to Arbitrary Memory Addresses
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向任意内存地址写入
- en: If the `%s` format parameter can be used to read an arbitrary memory address,
    you should be able to use the same technique with `%n` to write to an arbitrary
    memory address. Now things are getting interesting.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以使用 `%s` 格式参数读取任意内存地址，那么你应该能够使用相同的技巧与 `%n` 一起写入任意内存地址。现在事情变得有趣了。
- en: The `test_val` variable has been printing its address and value in the debug
    statement of the vulnerable fmt_vuln.c program, just begging to be overwritten.
    The test variable is located at `0x08049794`, so by using a similar technique,
    you should be able to write to the variable.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_val` 变量已经在 fmt_vuln.c 程序的调试语句中打印其地址和值，这正是一个容易被覆盖的地方。测试变量位于 `0x08049794`，因此通过使用类似的技术，你应该能够向该变量写入数据。'
- en: '[PRE95]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As this shows, the `test_val` variable can indeed be overwritten using the `%n`
    format parameter. The resulting value in the test variable depends on the number
    of bytes written before the `%n`. This can be controlled to a greater degree by
    manipulating the field width option.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，`test_val` 变量确实可以使用 `%n` 格式参数被覆盖。测试变量中的结果值取决于在 `%n` 之前写入的字节数。这可以通过操作字段宽度选项来更好地控制。
- en: '[PRE96]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: By manipulating the field-width option of one of the format parameters before
    the `%n`, a certain number of blank spaces can be inserted, resulting in the output
    having some blank lines. These lines, in turn, can be used to control the number
    of bytes written before the `%n` format parameter. This approach will work for
    small numbers, but it won't work for larger ones, like memory addresses.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `%n` 之前的格式参数中操作字段宽度选项，可以插入一定数量的空格，导致输出中出现一些空白行。这些行反过来可以用来控制 `%n` 格式参数之前写入的字节数。这种方法适用于较小的数字，但对于较大的数字，如内存地址，则不适用。
- en: 'Looking at the hexadecimal representation of the `test_val` value, it''s apparent
    that the least significant byte can be controlled fairly well. (Remember that
    the least significant byte is actually located in the first byte of the fourbyte
    word of memory.) This detail can be used to write an entire address. If four writes
    are done at sequential memory addresses, the least significant byte can be written
    to each byte of a four-byte word, as shown here:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 `test_val` 值的十六进制表示，很明显最低有效字节可以很好地控制。（记住，最低有效字节实际上位于四个字节的内存单词的第一个字节。）这个细节可以用来写入整个地址。如果按顺序在连续的内存地址上写入四次，最低有效字节可以写入四个字节的每个字节，如下所示：
- en: '[PRE97]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: As an example, let's try to write the address `0xDDCCBBAA` into the test variable.
    In memory, the first byte of the test variable should be `0xAA`, then `0xBB`,
    then `0xCC`, and finally `0xDD`. Four separate writes to the memory addresses
    `0x08049794, 0x08049795, 0x08049796`, and `0x08049797` should accomplish this.
    The first write will write the value `0x000000aa`, the second `0x000000bb`, the
    third `0x000000cc`, and finally `0x000000dd`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试将地址 `0xDDCCBBAA` 写入测试变量。在内存中，测试变量的第一个字节应该是 `0xAA`，然后是 `0xBB`，然后是 `0xCC`，最后是
    `0xDD`。通过向内存地址 `0x08049794, 0x08049795, 0x08049796` 和 `0x08049797` 分别写入，应该能够完成这个操作。第一次写入将写入值
    `0x000000aa`，第二次 `0x000000bb`，第三次 `0x000000cc`，最后 `0x000000dd`。
- en: The first write should be easy.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次写入应该很简单。
- en: '[PRE98]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The last `%x` format parameter uses 8 as the field width to standardize the
    output. This is essentially reading a random DWORD from the stack, which could
    output anywhere from 1 to 8 characters. Since the first overwrite puts 28 into
    test_val, using 150 as the field width instead of 8 should control the least significant
    byte of `test_val` to `0xAA`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个 `%x` 格式参数使用 8 作为字段宽度以标准化输出。这本质上是从堆中读取一个随机的 DWORD，它可以输出从 1 到 8 个字符。由于第一次覆盖将
    28 放入 test_val，使用 150 作为字段宽度而不是 8 应该控制 test_val 的最低有效字节为 `0xAA`。
- en: Now for the next write. Another argument is needed for another `%x`format parameter
    to increment the byte count to 187, which is 0xBB in decimal. This argument could
    be anything; it just has to be four bytes long and must be located after the first
    arbitrary memory address of `0x08049754`. Since this is all still in the memory
    of the format string, it can be easily controlled. The word *JUNK* is four bytes
    long and will work fine.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是下一次写入。需要另一个参数来为另一个 `%x` 格式参数增加字节计数到 187，即十进制的 0xBB。这个参数可以是任何东西；它只需要是四个字节长，并且必须位于第一个任意内存地址
    `0x08049754` 之后。由于这仍然是在格式字符串的内存中，它可以很容易地被控制。单词 *JUNK* 是四个字节长，将工作得很好。
- en: After that, the next memory address to be written to, `0x08049755`, should be
    put into memory so the second `%n` format parameter can access it. This means
    the beginning of the format string should consist of the target memory address,
    four bytes of junk, and then the target memory address plus one. But all of these
    bytes of memory are also printed by the format function, thus incrementing the
    byte counter used for the `%n` format parameter. This is getting tricky.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，下一个要写入的内存地址 `0x08049755` 应该放入内存中，以便第二个 `%n` 格式参数可以访问它。这意味着格式字符串的起始部分应该由目标内存地址、四个字节的垃圾数据，然后是目标内存地址加一组成。但是，这些内存字节也会被格式函数打印出来，从而增加用于
    `%n` 格式参数的字节计数器。这变得越来越复杂。
- en: 'Perhaps we should think about the beginning of the format string ahead of time.
    The goal is to have four writes. Each one will need to have a memory address passed
    to it, and among them all, four bytes of junk are needed to properly increment
    the byte counter for the `%n` format parameters. The first `%x` format parameter
    can use the four bytes found before the format string itself, but the remaining
    three will need to be supplied data. For the entire write procedure, the beginning
    of the format string should look like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们应该提前考虑格式字符串的起始部分。目标是进行四次写入。每次写入都需要传递一个内存地址，并且在这其中，需要四个字节的垃圾数据来正确增加 `%n`
    格式参数的字节计数器。第一个 `%x` 格式参数可以使用在格式字符串本身之前找到的四个字节，但剩下的三个将需要提供数据。对于整个写入过程，格式字符串的起始部分应该看起来像这样：
- en: '![](httpatomoreillycomsourcenostarchimages254358.png.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](httpatomoreillycomsourcenostarchimages254358.png.jpg)'
- en: Figure 0x300-4.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 0x300-4。
- en: Let's give it a try.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。
- en: '[PRE99]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The addresses and junk data at the beginning of the format string changed the
    value of the necessary field width option for the `%x` format parameter. However,
    this is easily recalculated using the same method as before. Another way this
    could have been done is to subtract 24 from the previous field width value of
    150, since 6 new 4-byte words have been added to the front of the format string.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串起始部分的地址和垃圾数据改变了 `%x` 格式参数所需的字段宽度选项的值。然而，这可以通过之前的方法轻松重新计算。另一种可能的方法是从之前的字段宽度值
    150 中减去 24，因为格式字符串前面增加了 6 个新的 4 字节单词。
- en: Now that all the memory is set up ahead of time in the beginning of the format
    string, the second write should be simple.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的内存都在格式字符串的起始部分设置好了，第二次写入应该很简单。
- en: '[PRE100]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The next desired value for the least significant byte is `0xBB`. A hexadecimal
    calculator quickly shows that 17 more bytes need to be written before the next
    `%n` format parameter. Since memory has already been set up for a `%x` format
    parameter, it's simple to write 17 bytes using the field width option.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个期望的最低有效字节值是 `0xBB`。一个十六进制计算器很快就会显示在下一个 `%n` 格式参数之前需要写入 17 个字节。由于已经为 `%x`
    格式参数设置了内存，使用字段宽度选项写入 17 个字节很简单。
- en: This process can be repeated for the third and fourth writes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以重复进行第三次和第四次写入。
- en: '[PRE101]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: By controlling the least significant byte and performing four writes, an entire
    address can be written to any memory address. It should be noted that the three
    bytes found after the target address will also be overwritten using this technique.
    This can be quickly explored by statically declaring another initialized variable
    called `next_val`, right after `test_val`, and also displaying this value in the
    debug output. The changes can be made in an editor or with some more `sed` magic.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制最低有效字节并执行四次写入，可以写入任何内存地址的整个地址。需要注意的是，使用这种技术也会覆盖目标地址之后的三个字节。这可以通过在 `test_val`
    之后立即静态声明另一个初始化变量 `next_val` 并在调试输出中显示此值来快速探索。这些更改可以在编辑器中或使用一些 `sed` 魔法来完成。
- en: Here, `next_val` is initialized with the value `0x11111111`, so the effect of
    the write operations on it will be apparent.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`next_val` 被初始化为值 `0x11111111`，因此写入操作对它的影响将很明显。
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: As the preceding output shows, the code change has also moved the address of
    the `test_val` variable. However, `next_val` is shown to be adjacent to it. For
    practice, let's write an address into the variable `test_val` again, using the
    new address.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的输出所示，代码更改也移动了 `test_val` 变量的地址。然而，`next_val` 显示出它紧邻 `test_val`。为了练习，让我们再次将地址写入变量
    `test_val`，使用新的地址。
- en: Last time, a very convenient address of `oxdccbbaa` was used. Since each byte
    is greater than the previous byte, it's easy to increment the byte counter for
    each byte. But what if an address like `0x0806abcd` is used? With this address,
    the first byte of `0xCD` is easy to write using the `%n` format parameter by outputting
    205 bytes total bytes with a field width of 161\. But then the next byte to be
    written is `0xAB`, which would need to have 171 bytes outputted. It's easy to
    increment the byte counter for the `%n` format parameter, but it's impossible
    to subtract from it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 上次使用了一个非常方便的地址 `0xodccbbaa`。由于每个字节都大于前一个字节，因此很容易为每个字节增加字节计数器。但是，如果使用像 `0x0806abcd`
    这样的地址呢？使用这个地址，`0xCD` 的第一个字节很容易通过 `%n` 格式参数写入，输出总共 205 个字节，字段宽度为 161。但是接下来要写入的下一个字节是
    `0xAB`，需要输出 171 个字节。虽然很容易增加 `%n` 格式参数的字节计数器，但无法从中减去。
- en: '[PRE103]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Instead of trying to subtract 34 from 205, the least significant byte is just
    wrapped around to `0x1AB` by adding 222 to 205 to produce 427, which is the decimal
    representation of `0x1AB`. This technique can be used to wrap around again and
    set the least significant byte to `0x06` for the third write.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是尝试从 205 减去 34，最低有效字节通过将 205 加上 222 得到 427（这是 `0x1AB` 的十进制表示），被循环到 `0x1AB`。这种技术可以再次循环并设置第三次写入的最低有效字节为
    `0x06`。
- en: '[PRE104]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: With each write, bytes of the `next_val` variable, adjacent to `test_val`, are
    being overwritten. The wraparound technique seems to be working fine, but a slight
    problem manifests itself as the final byte is attempted.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每次写入都会覆盖 `test_val` 旁边 `next_val` 变量的字节。循环技术似乎工作得很好，但在尝试最后一个字节时出现了一个小问题。
- en: '[PRE105]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: What happened here? The difference between `0x06` and `0x08` is only two, but
    eight bytes are output, resulting in the byte `0x0e` being written by the `%n`format
    parameter, instead. This is because the field width option for the `%x` format
    parameter is only a *minimum* field width, and eight bytes of data were output.
    This problem can be alleviated by simply wrapping around again; however, it's
    good to know the limitations of the field width option.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？`0x06` 和 `0x08` 之间的差异只有两个，但输出了八个字节，导致 `%n` 格式参数写入了字节 `0x0e`。这是因为 `%x`
    格式参数的字段宽度选项只是一个 *最小* 字段宽度，并且输出了八个字节的数据。这个问题可以通过再次循环来缓解；然而，了解字段宽度选项的限制是很好的。
- en: '[PRE106]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Just like before, the appropriate addresses and junk data are put in the beginning
    of the format string, and the least significant byte is controlled for four write
    operations to overwrite all four bytes of the variable `test_val`. Any value subtractions
    to the least significant byte can be accomplished by wrapping the byte around.
    Also, any additions less than eight may need to be wrapped around in a similar
    fashion.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，适当的地址和垃圾数据被放在格式字符串的开头，并且最低有效字节通过四次写入操作来控制，以覆盖变量 `test_val` 的所有四个字节。对最低有效字节的任何减值都可以通过循环字节来实现。同样，任何小于八的加法可能也需要以类似的方式循环。
- en: Direct Parameter Access
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接参数访问
- en: Direct parameter access is a way to simplify format string exploits. In the
    previous exploits, each of the format parameter arguments had to be stepped through
    sequentially. This necessitated using several `%x` format parameters to step through
    parameter arguments until the beginning of the format string was reached. In addition,
    the sequential nature required three 4-byte words of junk to properly write a
    full address to an arbitrary memory location.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 直接参数访问是一种简化格式字符串漏洞的方法。在之前的漏洞中，每个格式参数参数都必须按顺序遍历。这需要使用多个`%x`格式参数来遍历参数参数，直到达到格式字符串的开头。此外，顺序性质需要三个4字节的垃圾数据来正确地将一个地址写入任意内存位置。
- en: As the name would imply, *direct parameter access* allows parameters to be accessed
    directly by using the dollar sign qualifier. For example, *`%n`*`$d` would access
    the *n*th parameter and display it as a decimal number.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，*直接参数访问*允许通过使用美元符号限定符直接访问参数。例如，`*%n``$d`会访问第*n*个参数并以十进制形式显示它。
- en: '[PRE107]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The preceding `printf()` call would have the following output:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`printf()`调用将产生以下输出：
- en: '[PRE108]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: First, the *70* is outputted as a decimal number when the format parameter of
    `%7$d` is encountered, because the seventh parameter is 70\. The second format
    parameter accesses the fourth parameter and uses a field width option of `05`.
    All of the other parameter arguments are untouched. This method of direct access
    eliminates the need to step through memory until the beginning of the format string
    is located, since this memory can be accessed directly. The following output shows
    the use of direct parameter access.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当遇到格式参数`%7$d`时，数字`70`以十进制形式输出，因为第七个参数是70。第二个格式参数访问第四个参数并使用字段宽度选项`05`。所有其他参数参数保持不变。这种直接访问方法消除了需要遍历内存直到找到格式字符串开头的需求，因为可以直接访问这段内存。以下输出显示了直接参数访问的使用。
- en: '[PRE109]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: In this example, the beginning of the format string is located at the fourth
    parameter argument. Instead of stepping through the first three parameter arguments
    using `%x` format parameters, this memory can be accessed directly. Since this
    is being done on the command line and the dollar sign is a special character,
    it must be escaped with a backslash. This just tells the command shell to avoid
    trying to interpret the dollar sign as a special character. The actual format
    string can be seen when it is printed correctly.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，格式字符串的开头位于第四个参数参数。而不是使用`%x`格式参数遍历前三个参数参数，可以直接访问这段内存。由于这是在命令行上进行的，而美元符号是一个特殊字符，因此必须使用反斜杠转义。这仅仅告诉命令shell避免尝试将美元符号解释为特殊字符。正确的格式字符串可以在打印时看到。
- en: Direct parameter access also simplifies the writing of memory addresses. Since
    memory can be accessed directly, there's no need for four-byte spacers of junk
    data to increment the byte output count. Each of the `%x` format parameters that
    usually performs this function can just directly access a piece of memory found
    before the format string. For practice, let's use direct parameter access to write
    a more realistic-looking address of `0xbffffd72` into the variable `test_val`s.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 直接参数访问还简化了内存地址的编写。由于可以直接访问内存，因此不需要四个字节的垃圾数据空格来增加字节数输出计数。通常执行此功能的每个`%x`格式参数可以直接访问格式字符串之前找到的一块内存。为了练习，让我们使用直接参数访问将看起来更真实的地址`0xbffffd72`写入变量`test_val`s中。
- en: '[PRE110]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Since the stack doesn't need to be printed to reach our addresses, the number
    of bytes written at the first format parameter is 16\. Direct parameter access
    is only used for the `%n` parameters, since it really doesn't matter what values
    are used for the `%x` spacers. This method simplifies the process of writing an
    address and shrinks the mandatory size of the format string.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不需要打印堆栈来达到我们的地址，第一个格式参数写入的字节数是16。直接参数访问仅用于`%n`参数，因为对于`%x`空格参数使用的值实际上并不重要。这种方法简化了编写地址的过程，并缩小了必需的格式字符串大小。
- en: Using Short Writes
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简短写作
- en: Another technique that can simplify format string exploits is using short writes.
    A *short* is typically a two-byte word, and format parameters have a special way
    of dealing with them. A more complete description of possible format parameters
    can be found in the printf manual page. The portion describing the length modifier
    is shown in the output below.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以简化格式字符串漏洞的技术是使用短写。通常，*短* 是一个双字节字，格式参数有特殊的方式来处理它们。有关可能的格式参数的更完整描述可以在printf手册页中找到。描述长度修饰符的部分如下所示。
- en: '[PRE111]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This can be used with format string exploits to write two-byte shorts. In the
    output below, a short (shown in bold) is written in at both ends of the four-byte
    `test_val` variable. Naturally, direct parameter access can still be used.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与格式字符串漏洞一起使用来写入双字节短整型。在下面的输出中，一个短整型（粗体显示）被写入四个字节 `test_val` 变量的两端。自然地，仍然可以直接访问参数。
- en: '[PRE112]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Using short writes, an entire four-byte value can be overwritten with just two
    `%hn` parameters. In the example below, the `test_val` variable will be overwritten
    once again with the address `0xbffffd72`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短写，可以使用两个 `%hn` 参数覆盖整个四个字节的值。在下面的示例中，`test_val` 变量将被再次覆盖，地址为 `0xbffffd72`。
- en: '[PRE113]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The preceding example used a similar wraparound method to deal with the second
    write of `0xbfff` being less than the first write of `0xfd72`. Using short writes,
    the order of the writes doesn't matter, so the first write can be `0xfd72` and
    the second `0xbfff`, if the two passed addresses are swapped in position. In the
    output below, the address `0x08049796` is written to first, and `0x08049794` is
    written to second.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了一个类似的环绕方法来处理 `0xbfff` 的第二次写入小于 `0xfd72` 的第一次写入。使用短写，写入的顺序并不重要，因此第一次写入可以是
    `0xfd72`，第二次是 `0xbfff`，如果两个传递的地址在位置上交换。在下面的输出中，首先写入地址 `0x08049796`，然后写入地址 `0x08049794`。
- en: '[PRE114]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The ability to overwrite arbitrary memory addresses implies the ability to control
    the execution flow of the program. One option is to overwrite the return address
    in the most recent stack frame, as was done with the stack-based overflows. While
    this is a possible option, there are other targets that have more predictable
    memory addresses. The nature of stack-based overflows only allows the overwrite
    of the return address, but format strings provide the ability to overwrite any
    memory address, which creates other possibilities.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 覆写任意内存地址的能力意味着能够控制程序的执行流程。一个选项是覆盖最近栈帧中的返回地址，就像在基于栈的溢出中所做的那样。虽然这是一个可能的选项，但还有其他具有更可预测内存地址的目标。基于栈的溢出性质仅允许覆盖返回地址，但格式字符串提供了覆盖任何内存地址的能力，这创造了其他可能性。
- en: Detours with .dtors
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .dtors 的旁路
- en: In binary programs compiled with the GNU C compiler, special table sections
    called `.dtors` and `.ctors` are made for destructors and constructors, respectively.
    Constructor functions are executed before the `main()` function is executed, and
    destructor functions are executed just before the `main()` function exits with
    an exit system call. The destructor functions and the `.dtors` table section are
    of particular interest.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GNU C编译器编译的二进制程序中，为析构函数和构造函数分别创建了名为 `.dtors` 和 `.ctors` 的特殊表部分。构造函数在执行 `main()`
    函数之前执行，析构函数在 `main()` 函数通过退出系统调用退出之前执行。析构函数和 `.dtors` 表部分特别引人关注。
- en: A function can be declared as a destructor function by defining the destructor
    attribute, as seen in dtors_sample.c.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过定义析构属性来声明为析构函数，如dtors_sample.c中所示。
- en: dtors_sample.c
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dtors_sample.c
- en: '[PRE115]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the preceding code sample, the `cleanup()` function is defined with the destructor
    attribute, so the function is automatically called when the `main()` function
    exits, as shown next.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`cleanup()` 函数使用析构属性定义，因此当 `main()` 函数退出时，函数会自动调用，如下所示。
- en: '[PRE116]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This behavior of automatically executing a function on exit is controlled by
    the `.dtors` table section of the binary. This section is an array of 32-bit addresses
    terminated by a NULL address. The array always begins with `0xffffffff` and ends
    with the NULL address of `0x00000000`. Between these two are the addresses of
    all the functions that have been declared with the destructor attribute.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在退出时自动执行函数的行为是由二进制的 `.dtors` 表部分控制的。这个部分是一个以NULL地址结尾的32位地址数组。数组始终以 `0xffffffff`
    开头，以 `0x00000000` 的NULL地址结束。在这两者之间是所有已声明具有析构属性的函数的地址。
- en: The `nm` command can be used to find the address of the `cleanup()` function,
    and `objdump` can be used to examine the sections of the binary.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `nm` 命令找到 `cleanup()` 函数的地址，并使用 `objdump` 检查二进制的部分。
- en: '[PRE117]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `nm` command shows that the `cleanup()` function is located at `0x080483e8`
    (shown in bold above). It also reveals that the `.dtors` section starts at `0x080495ac`
    with `__DTOR_LIST__` ![](httpatomoreillycomsourcenostarchimages254530.png) and
    ends at `0x080495b4` with `__DTOR_END__`( ![](httpatomoreillycomsourcenostarchimages254488.png)).
    This means that `0x080495ac` should contain `0xffffffff, 0x080495b4` should contain
    `0x00000000`, and the address between them (`0x080495b0`) should contain the address
    of the `cleanup()` function (`0x080483e8`).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`nm` 命令显示 `cleanup()` 函数位于 `0x080483e8`（如下所示加粗）。它还揭示了 `.dtors` 部分从 `0x080495ac`
    开始以 `__DTOR_LIST__`（![](httpatomoreillycomsourcenostarchimages254530.png)）结束，并在
    `0x080495b4`（![](httpatomoreillycomsourcenostarchimages254488.png)）结束。这意味着 `0x080495ac`
    应该包含 `0xffffffff`，`0x080495b4` 应该包含 `0x00000000`，它们之间的地址（`0x080495b0`）应该包含 `cleanup()`
    函数的地址（`0x080483e8`）。'
- en: The `objdump` command shows the actual contents of the `.dtors` section (shown
    in bold below), although in a slightly confusing format. The first value of `80495ac`
    is simply showing the address where the `.dtors` section is located. Then the
    actual bytes are shown, opposed to DWORDs, which means the bytes are reversed.
    Bearing this in mind, everything appears to be correct.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`objdump` 命令显示了 `.dtors` 部分的实际内容（如下所示加粗），尽管格式略令人困惑。`80495ac` 的第一个值只是显示了 `.dtors`
    部分所在的位置地址。然后显示了实际的字节，而不是 DWORD，这意味着字节是反向的。考虑到这一点，一切看起来都是正确的。'
- en: '[PRE118]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: An interesting detail about the `.dtors` section is that it is writable. An
    object dump of the headers will verify this by showing that the `.dtors` section
    isn't labeled `READONLY`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `.dtors` 部分的另一个有趣细节是它是可写的。通过显示 `.dtors` 部分未标记为 `READONLY`，对象转储将验证这一点。
- en: '[PRE119]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Another interesting detail about the `.dtors` section is that it is included
    in all binaries compiled with the GNU C compiler, regardless of whether any functions
    were declared with the destructor attribute. This means that the vulnerable format
    string program, fmt_vuln.c, must have a `.dtors` section containing nothing. This
    can be inspected using `nm` and `objdump`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `.dtors` 部分的另一个有趣细节是，它是所有使用 GNU C 编译器编译的二进制文件的一部分，无论是否声明了具有析构器属性的函数。这意味着易受攻击的格式字符串程序
    fmt_vuln.c 必须有一个不包含任何内容的 `.dtors` 部分可以使用 `nm` 和 `objdump` 进行检查。
- en: '[PRE120]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: As this output shows, the distance between `__DTOR_LIST__` and `__DTOR_END__`
    is only four bytes this time, which means there are no addresses between them.
    The object dump verifies this.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如此输出所示，`__DTOR_LIST__` 和 `__DTOR_END__` 之间的距离这次只有四个字节，这意味着它们之间没有其他地址。对象转储验证了这一点。
- en: Since the `.dtors` section is writable, if the address after the `0xffffffff`
    is overwritten with a memory address, the program's execution flow will be directed
    to that address when the program exits. This will be the address of `__DTOR_LIST__`
    plus four, which is `0x08049694` (which also happens to be the address of `__DTOR_END__`
    in this case).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `.dtors` 部分是可写的，如果将 `0xffffffff` 之后的地址覆盖为内存地址，程序退出时程序执行流程将被导向该地址。这将是指向 `__DTOR_LIST__`
    加四的地址，即 `0x08049694`（在这种情况下，这也恰好是 `__DTOR_END__` 的地址）。
- en: If the program is suid root, and this address can be overwritten, it will be
    possible to obtain a root shell.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序是 suid root，并且这个地址可以被覆盖，那么将有可能获得 root shell。
- en: '[PRE121]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Shellcode can be put into an environment variable, and the address can be predicted
    as usual. Since the program name lengths of the helper program getenvaddr.c and
    the vulnerable fmt_vuln.c program differ by two bytes, the shellcode will be located
    at `0xbffff9ec` when fmt_vuln.c is executed. This address simply has to be written
    into the `.dtors` section at `0x08049694` (shown in bold below) using the format
    string vulnerability. In the output below the short write method is used.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Shellcode 可以放入环境变量中，地址可以像往常一样预测。由于辅助程序 getenvaddr.c 和易受攻击的 fmt_vuln.c 程序的文件名长度相差两个字节，当
    fmt_vuln.c 执行时，Shellcode 将位于 `0xbffff9ec`。这个地址只需使用格式字符串漏洞将其写入 `.dtors` 部分的 `0x08049694`（如下所示加粗）即可。下面的输出中使用了简短写入方法。
- en: '[PRE122]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Even though the `.dtors` section isn't properly terminated with a NULL address
    of `0x00000000`, the shellcode address is still considered to be a destructor
    function. When the program exits, the shellcode will be called, spawning a root
    shell.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`.dtors`部分没有用`0x00000000`的空地址正确终止，shellcode地址仍然被视为一个析构函数。当程序退出时，shellcode将被调用，启动一个root
    shell。
- en: Another notesearch Vulnerability
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个notesearch漏洞
- en: In addition to the buffer overflow vulnerability, the notesearch program from
    [Chapter 0x200](ch02.html "Chapter 0x200. PROGRAMMING") also suffers from a format
    string vulnerability. This vulnerability is shown in bold in the code listing
    below.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缓冲区溢出漏洞外，来自[第0x200章](ch02.html "第0x200章。编程")的notesearch程序还遭受格式化字符串漏洞。下面的代码列表中显示了该漏洞加粗。
- en: '[PRE123]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This function reads the `note_buffer` from the file and prints the contents
    of the note without supplying its own format string. While this buffer can't be
    directly controlled from the command line, the vulnerability can be exploited
    by sending exactly the right data to the file using the notetaker program and
    then opening that note using the notesearch program. In the following output,
    the notetaker program is used to create notes to probe memory in the notesearch
    program. This tells us that the eighth function parameter is at the beginning
    of the buffer.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从文件中读取`note_buffer`并打印注释的内容，而不提供自己的格式字符串。虽然此缓冲区不能直接从命令行控制，但可以通过使用notetaker程序发送正确数据到文件并使用notesearch程序打开该注释来利用漏洞。在以下输出中，notetaker程序用于创建notes以探测notesearch程序中的内存。这告诉我们第八个函数参数位于缓冲区的开始处。
- en: '[PRE124]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now that the relative layout of memory is known, exploitation is just a matter
    of overwriting the `.dtors` section with the address of injected shellcode.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已知内存的相对布局，利用攻击只需将注入的shellcode地址覆盖`.dtors`部分即可。
- en: '[PRE125]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Overwriting the Global Offset Table
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆写全局偏移表
- en: Since a program could use a function in a shared library many times, it's useful
    to have a table to reference all the functions. Another special section in compiled
    programs is used for this purpose—the *procedure linkage table (PLT)*.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序可能多次使用共享库中的函数，因此有一个表格来引用所有函数是有用的。编译程序中的另一个特殊部分用于此目的——*程序链接表（PLT）*。
- en: This section consists of many jump instructions, each one corresponding to the
    address of a function. It works like a springboard—each time a shared function
    needs to be called, control will pass through the PLT.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分由许多跳转指令组成，每个指令对应一个函数的地址。它就像一个跳板——每次需要调用共享函数时，控制权将通过PLT传递。
- en: 'An object dump disassembling the PLT section in the vulnerable format string
    program (fmt_vuln.c) shows these jump instructions:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对易受攻击的格式化字符串程序（fmt_vuln.c）中的PLT部分进行对象转储解构显示这些跳转指令：
- en: '[PRE126]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: One of these jump instructions is associated with the `exit()` function, which
    is called at the end of the program. If the jump instruction used for the `exit()`
    function can be manipulated to direct the execution flow into shellcode instead
    of the `exit()` function, a root shell will be spawned. Below, the procedure linking
    table is shown to be read only.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这些跳转指令之一与`exit()`函数相关联，该函数在程序结束时被调用。如果用于`exit()`函数的跳转指令可以被操纵以将执行流程导向shellcode而不是`exit()`函数，则会启动一个root
    shell。下面显示了程序链接表是只读的。
- en: '[PRE127]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: But closer examination of the jump instructions (shown in bold below) reveals
    that they aren't jumping to addresses but to pointers to addresses. For example,
    the actual address of the `printf()` function is stored as a pointer at the memory
    address `0x08049780`, and the `exit()` function's address is stored at `0x08049784`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 但更仔细地检查跳转指令（如下所示加粗）揭示它们并不是跳转到地址，而是跳转到地址的指针。例如，`printf()`函数的实际地址存储在内存地址`0x08049780`处的指针，而`exit()`函数的地址存储在`0x08049784`。
- en: '[PRE128]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: These addresses exist in another section, called the *global offset table (GOT)*,
    which is writable. These addresses can be directly obtained by displaying the
    dynamic relocation entries for the binary by using `objdump`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些地址存在于另一个部分，称为*全局偏移表（GOT）*，它是可写的。这些地址可以通过使用`objdump`显示二进制的动态重定位条目来直接获得。
- en: '[PRE129]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This reveals that the address of the `exit()` function (shown in bold above)
    is located in the GOT at `0x08049784`. If the address of the shellcode is overwritten
    at this location, the program should call the shellcode when it thinks it's calling
    the `exit()` function.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `exit()` 函数的地址（如上图中加粗所示）位于 GOT 的 `0x08049784`。如果在此位置覆盖 shellcode 的地址，当程序认为它在调用
    `exit()` 函数时，它应该调用 shellcode。
- en: As usual, the shellcode is put in an environment variable, its actual location
    is predicted, and the format string vulnerability is used to write the value.
    Actually, the shellcode should still be located in the environment from before,
    meaning that the only things that need adjustment are the first 16 bytes of the
    format string. The calculations for the `%x` format parameters will be done once
    again for clarity. In the output below, the address of the shellcode (![](httpatomoreillycomsourcenostarchimages254488.png))
    is written into the address of the `exit()` function (![](httpatomoreillycomsourcenostarchimages254530.png)).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，shellcode 被放入环境变量中，其实际位置被预测，并利用格式字符串漏洞来写入值。实际上，shellcode 应该仍然位于之前的环境变量中，这意味着需要调整的只有格式字符串的前
    16 个字节。为了清晰起见，将对 `%x` 格式参数的计算再次进行。在下面的输出中，shellcode 的地址（![shellcode 地址](http://atomoreilly.com/source/no_starch_images/254488.png)）被写入
    `exit()` 函数的地址（![exit() 函数地址](http://atomoreilly.com/source/no_starch_images/254530.png)）。
- en: '[PRE130]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: When fmt_vuln.c tries to call the `exit()` function, the address of the `exit()`
    function is looked up in the GOT and is jumped to via the PLT. Since the actual
    address has been switched with the address for the shellcode in the environment,
    a root shell is spawned.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当 fmt_vuln.c 尝试调用 `exit()` 函数时，`exit()` 函数的地址在 GOT 中查找，并通过 PLT 跳转。由于实际地址已被环境中的
    shellcode 地址所替换，因此会启动一个 root shell。
- en: Another advantage of overwriting the GOT is that the GOT entries are fixed per
    binary, so a different system with the same binary will have the same GOT entry
    at the same address.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 GOT 的另一个优点是，GOT 条目对每个二进制文件是固定的，因此具有相同二进制文件的不同系统将在同一地址处具有相同的 GOT 条目。
- en: The ability to overwrite any arbitrary address opens up many possibilities for
    exploitation. Basically, any section of memory that is writable and contains an
    address that directs the flow of program execution can be targeted.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 能够覆盖任何任意地址为利用提供了许多可能性。基本上，任何可写且包含指向程序执行流程的地址的内存部分都可以成为目标。
