- en: Part III-10. INTERACTIVE AND ADMINISTRATIVE UTILITIES AND PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分-第10章. 交互式和行政工具及协议
- en: '[Chapter 87](ch87.html "Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION
    PROTOCOLS")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第87章](ch87.html "第87章. TCP/IP 交互式和远程应用协议")'
- en: '[Chapter 88](ch88.html "Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING
    UTILITIES AND PROTOCOLS")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第88章](ch88.html "第88章. TCP/IP 管理和故障排除工具及协议")'
- en: File and message transfer applications include the File Transfer Protocol (FTP),
    electronic mail (email), and the World Wide Web, which makes file and message
    transfer the most important category of classic TCP/IP applications. However,
    those applications do not represent the only ways that TCP/IP internetworks are
    used. While not as glamorous as some of the application protocols we have examined
    so far in this section, interactive and administrative protocols are also important
    and worth understanding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和消息传输应用包括文件传输协议（FTP）、电子邮件（email）和万维网，这使得文件和消息传输成为经典TCP/IP应用中最重要的一类。然而，这些应用并不代表TCP/IP互连网使用的唯一方式。虽然不像本节中我们之前检查的一些应用协议那样引人注目，但交互式和行政协议同样重要，值得理解。
- en: This final part of the book covers a couple other categories of TCP/IP applications.
    The first chapter describes interactive and remote application protocols, which
    are used traditionally to allow a user of one computer to access another, or to
    permit the real-time exchange of information. The second chapter discusses TCP/IP
    administration and troubleshooting utilities, which can be employed by both administrators
    and end users to manage TCP/IP networks and diagnose problems with them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书最后一部分涵盖了TCP/IP应用的几个其他类别。第一章描述了交互式和远程应用协议，这些协议传统上用于允许一台计算机的用户访问另一台计算机，或者允许信息的实时交换。第二章讨论了TCP/IP管理和故障排除工具，这些工具可以被管理员和最终用户用来管理TCP/IP网络并诊断与之相关的问题。
- en: Chapter 87. TCP/IP INTERACTIVE AND REMOTE APPLICATION PROTOCOLS
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第87章. TCP/IP 交互式和远程应用协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: When it comes to TCP/IP applications, file and message transfer applications
    get the most attention, because they are the ones used most often on modern internetworks.
    Another category of TCP/IP application protocols that is less well known is the
    group that allows users to interactively access and use other computers directly
    over an internetwork, such as the public Internet. These applications are not
    often employed by end users today, but they are still important—both from a historical
    perspective and because of their usefulness in certain circumstances, especially
    to network administrators.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到TCP/IP应用时，文件和消息传输应用受到最多的关注，因为它们是现代互连网中最常使用的应用。另一个不太为人所知的TCP/IP应用协议类别是允许用户通过互连网直接交互式访问和使用其他计算机的组，例如公共互联网。这些应用今天并不常被最终用户使用，但它们仍然很重要——从历史角度来看，以及在某些情况下，特别是对网络管理员来说，因为它们的实用性。
- en: In this chapter, I provide a brief description of the classic interactive and
    remote application protocols used in TCP/IP. I first describe the Telnet Protocol,
    one of the earliest and most conceptually important application protocols in TCP/IP.
    This discussion includes a description of Telnet client/server communication,
    the Telnet Network Virtual Terminal (NVT), and Telnet's protocol commands and
    options. I then describe the Berkeley remote access family, often called the *r
    commands* or protocols because their command names begin with that letter. Finally,
    I provide a brief overview of the Internet Relay Chat (IRC) protocol, the original
    interactive chat application of the Internet and one still used widely today.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要介绍了TCP/IP中使用的经典交互式和远程应用协议。我首先描述了Telnet协议，这是TCP/IP中最早且概念上最重要的应用协议之一。这次讨论包括对Telnet客户端/服务器通信、Telnet网络虚拟终端（NVT）以及Telnet的协议命令和选项的描述。然后，我描述了伯克利远程访问家族，通常被称为*r命令*或协议，因为它们的命令名以该字母开头。最后，我简要概述了互联网中继聊天（IRC）协议，这是互联网最初的交互式聊天应用，至今仍被广泛使用。
- en: Telnet Protocol
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Telnet 协议
- en: In the very earliest days of internetworking, one of the most important problems
    that computer scientists needed to solve was how to allow someone operating one
    computer to access and use another as if that remote user were connected to it
    locally. The protocol created to meet this need was called *Telnet*, and the effort
    to develop it was tied closely to that of the Internet and TCP/IP as a whole.
    Even though most Internet users today never invoke the Telnet Protocol directly,
    they use some of its underlying principles indirectly all the time. Every time
    you send a piece of email, use the File Transfer Protocol (FTP) to transfer a
    file, or load a web page, you are using technology based on Telnet. For this reason,
    the Telnet Protocol can make a valid claim to the title of the most historically
    important application protocol in TCP/IP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网的最初阶段，计算机科学家需要解决的最重要的问题之一是如何让操作一台计算机的用户能够访问并使用另一台计算机，就像那个远程用户是本地连接到它一样。为了满足这一需求而创建的协议被称为
    *Telnet*，开发它的努力与整个互联网和TCP/IP紧密相连。尽管如今的大多数互联网用户从未直接调用Telnet协议，但他们一直在间接地使用其一些基本原理。每次你发送一封电子邮件，使用文件传输协议（FTP）传输文件，或加载一个网页时，你都在使用基于Telnet的技术。因此，Telnet协议可以声称是TCP/IP历史上最重要的应用协议。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**BACKGROUND INFORMATION** *A basic comprehension of the Transmission Control
    Protocol (TCP), especially its sliding window mechanism and flow control features,
    will be helpful in understanding Telnet. Those topics are covered in Chapters
    [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER")
    and [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES").*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** 对传输控制协议（TCP）的基本理解，特别是其滑动窗口机制和流量控制功能，将有助于理解Telnet。这些主题在[第48章](ch48.html
    "第48章。TCP消息格式和数据传输")和[第49章](ch49.html "第49章。TCP可靠性和流量控制功能")中有详细说明。'
- en: Telnet Overview, History, and Standards
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet 概述、历史和标准
- en: 'The history of Telnet actually goes back over a decade before the modern TCP/IP
    protocol suite that we know today. As I mentioned in my overview of FTP, the early
    developers of TCP/IP internetworking technologies identified two overall application
    needs for networks to fill: enabling *direct access* to resources and also allowing
    *indirect access* to resources. FTP was created for indirect access, by allowing
    users to retrieve a resource from a remote host, use it locally, and if desired,
    copy it back to its source. Telnet was designed for direct access, by allowing
    users to access a remote machine and use it as if they were connected to it locally.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet的历史实际上可以追溯到我们今天所知道的现代TCP/IP协议套件之前的十多年。正如我在FTP概述中提到的，TCP/IP互联网技术早期开发者确定了网络需要满足的两个总体应用需求：允许对资源的
    *直接访问* 和允许对资源的 *间接访问*。FTP是为了间接访问而创建的，允许用户从远程主机检索资源，在本地使用它，如果需要的话，将其复制回源。Telnet是为了直接访问而设计的，允许用户访问远程机器，就像他们本地连接到它一样。
- en: Telnet History
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Telnet 历史
- en: 'Telnet was initially developed in the late 1960s. This was well before the
    era of the small personal computers that so many of us use exclusively today.
    All computers of that period were large and usually shared by many users. To work
    on a computer, you had to access a physical terminal connected to that machine,
    which was usually specially tailored to the needs and requirements of the host.
    Two specific issues resulted from this situation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet最初是在20世纪60年代末开发的。这比我们现在许多人专用的个人电脑时代要早得多。那个时期的所有计算机都很大，通常由许多用户共享。要在计算机上工作，你必须访问连接到该机器的物理终端，这通常是根据主机的需求和要求特别定制的。由此产生了两个具体问题：
- en: If an organization had several different computers, each user needed a separate
    terminal to access each computer that he or she used. This was expensive and inefficient.
    I can recall reading a quote from a book that compared this situation to having
    a room containing a number of television sets, each of which could only display
    a single channel.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组织拥有几台不同的计算机，每个用户都需要一个单独的终端来访问他们使用的每一台计算机。这既昂贵又低效。我记得曾读过一本书中的引用，将这种情况比作一个房间里有许多电视，每个电视只能显示一个频道。
- en: Perhaps a more significant issue was the difficulty in allowing a user at one
    site to access and use a machine at another site. The only method at the time
    for accomplishing this was to install a dedicated data circuit from the site of
    the computer to the site of the user, to connect the user's terminal to the remote
    machine. Again, each circuit would enable access to only one machine. Every combination
    of user and computer required a separate, expensive circuit to be installed and
    maintained.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能一个更显著的问题是，允许一个站点的一个用户访问并使用另一个站点的机器的困难。当时实现这一点的唯一方法是，从计算机的站点安装一条专用数据电路到用户的站点，将用户的终端连接到远程机器。同样，每个电路只能使一台机器可访问。每个用户和计算机的组合都需要安装和维护一个单独、昂贵的电路。
- en: The solution to both of these issues was to create a more general way of allowing
    any terminal to access any computer. The underlying internetwork provided the
    mechanism for communicating information between computers. This became the physical
    network connecting sites and the TCP/IP protocol suite connecting networks. On
    top of this ran an application protocol that allowed a user to establish a session
    to any networked computer and use it. That application protocol is Telnet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这两个问题的方案是创建一种更通用的方式，允许任何终端访问任何计算机。底层互联网提供了在计算机之间传递信息的机制。这成为了连接站点的物理网络，以及连接网络的TCP/IP协议套件。在此基础上运行的应用协议允许用户与任何网络计算机建立会话并使用它。这个应用协议就是Telnet。
- en: Telnet was the first application protocol demonstrated on the fledgling ARPAnet,
    in 1969\. The first RFC specifically defining Telnet was RFC 97, "First Cut at
    a Proposed Telnet Protocol," published in February 1971\. Development of Telnet
    continued throughout the 1970s, with quite a number of different RFCs devoted
    to revisions of the protocol and discussions of issues related to it. It took
    many years to refine Telnet and resolve all the difficulties that were associated
    with its development. The final version of the protocol, "Telnet Protocol Specification,"
    was published as RFC 854 in May 1983\. Over the years, other RFCs have been published
    to clarify the use of the protocol and address various issues such as authentication.
    There are also a number of other RFCs that define Telnet options, as discussed
    in the "Telnet Options and Option Negotiation" section later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet是1969年在初生的ARPAnet上演示的第一个应用协议。第一个专门定义Telnet的RFC是RFC 97，“对建议的Telnet协议的第一次尝试”，于1971年2月发布。Telnet的开发在整个1970年代持续进行，有相当多的不同RFC致力于协议的修订和与其相关的问题讨论。花了多年时间来完善Telnet并解决与其开发相关联的所有困难。该协议的最终版本，“Telnet协议规范”，于1983年5月作为RFC
    854发布。多年来，还发布了其他RFC来阐明协议的使用并解决诸如身份验证等问题。此外，还有许多其他RFC定义了Telnet选项，如本章后面的“Telnet选项和选项协商”部分所述。
- en: Fundamental Telnet Concepts
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本Telnet概念
- en: At first glance, it may be surprising that Telnet took so long to develop, because
    in theory, it should be a very simple protocol to define. All it needs to do is
    send keystrokes and program output over the network like any other protocol. Its
    definition would be simple if every terminal and computer used the same communication
    method, but they do not. Telnet becomes complicated because it needs to allow
    a terminal from one manufacturer to be able to talk to a computer that may use
    a very different data representation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，Telnet开发得如此之慢可能会令人惊讶，因为在理论上，它应该是一个非常简单的协议来定义。它只需要像其他任何协议一样在网络中发送按键和程序输出。如果每个终端和计算机都使用相同的通信方法，其定义将是简单的，但它们并不相同。Telnet之所以变得复杂，是因为它需要允许一个制造商的终端能够与可能使用非常不同的数据表示的计算机进行通信。
- en: Telnet solves this problem by defining a method that ensures compatibility between
    terminal types and computers, while allowing special features to be used by computers
    and terminals that agree to support them. The protocol is built on a foundation
    of three main concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet通过定义一种确保终端类型和计算机之间兼容性的方法来解决此问题，同时允许计算机和终端使用它们同意支持的特殊功能。该协议建立在三个主要概念的基础上。
- en: '**Network Virtual Terminal (NVT)** Telnet defines a standardized, fictional
    terminal called the *Network Virtual Terminal (NVT)* that is used for universal
    communication by all devices. A Telnet client takes input from a user and translates
    it from its native form to the NVT format to send to a Telnet server running on
    a remote computer. The server translates from NVT to whatever representation the
    computer being accessed requires. The process is reversed when data is sent from
    the remote computer back to the user. This system allows clients and servers to
    communicate even if they use entirely different hardware and internal data representations.
    Special Telnet commands are interspersed with the data to allow the client and
    server devices to perform various functions needed to manage the operation of
    the protocol.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络虚拟终端 (NVT)** Telnet 定义了一个标准化的、虚构的终端，称为 *网络虚拟终端 (NVT)*，它被所有设备用于通用通信。Telnet
    客户端从用户那里获取输入，并将其从其原生形式转换为 NVT 格式，以便发送到在远程计算机上运行的 Telnet 服务器。服务器将 NVT 转换为被访问计算机所需的任何表示形式。当数据从远程计算机发送回用户时，这个过程是相反的。这个系统允许客户端和服务器即使使用完全不同的硬件和内部数据表示也能进行通信。在数据中穿插特殊的
    Telnet 命令，以便客户端和服务器设备执行管理协议操作所需的各种功能。'
- en: '**Options and Option Negotiation** Having Telnet clients and servers act as
    NVTs avoids incompatibilities between devices, but does so by stripping all terminal-specific
    functionality to provide a common base representation that is understood by everyone.
    Since there are many cases where more intelligent terminals and computers may
    wish to use more advanced communication features and services, Telnet defines
    a rich set of options and a mechanism by which a Telnet client and server can
    negotiate their use. If the client and server agree on the use of an option, it
    can be enabled; if not, they can always fall back on the NVT to ensure basic communication.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项和选项协商** Telnet 客户端和服务器作为 NVT 行动，避免了设备之间的不兼容性，但这样做是通过去除所有终端特定功能来提供一个大家都能理解的通用基础表示。由于有许多情况下，更智能的终端和计算机可能希望使用更高级的通信功能和服务的场合，Telnet
    定义了一个丰富的选项集和一种机制，通过这种机制，Telnet 客户端和服务器可以协商它们的使用。如果客户端和服务器就选项的使用达成一致，则可以启用该选项；如果不一致，它们始终可以回退到
    NVT 以确保基本通信。'
- en: '**Symmetric Operation** While Telnet is a client/server protocol, it is specifically
    designed to not make assumptions about the nature of the client and server software.
    Once a Telnet session is established, the computers can each send and receive
    data as equals. They can also each initiate the negotiation of options. This makes
    the protocol extremely flexible and has led to its use in a variety of places,
    as discussed in the next section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**对称操作** 虽然 Telnet 是一个客户端/服务器协议，但它专门设计为不对客户端和服务器软件的性质做出假设。一旦建立 Telnet 会话，计算机就可以作为平等的角色发送和接收数据。它们还可以各自启动选项协商。这使得该协议非常灵活，并导致它在各种地方得到应用，如下一节所述。'
- en: Telnet Applications
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Telnet 应用
- en: Telnet is most often associated with remote login, which is its common traditional
    use. A user typically uses a Telnet client program to open a Telnet connection
    to a remote server, which then treats the Telnet client like a local terminal,
    allowing the user to log in and access the server's resources as if he were using
    a directly attached terminal. Telnet is still used this way quite extensively
    by UNIX users, who often need to log in to remote hosts from their local machines
    (I use Telnet in this manner every day to access a machine hundreds of miles away).
    However, this use of Telnet is not nearly as common among the majority of Internet
    users who work on Windows or Apple computers, where network resources are accessed
    not through direct login, but by other means.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 最常与远程登录相关联，这是它的常见传统用途。用户通常使用 Telnet 客户端程序打开到远程服务器的 Telnet 连接，然后服务器将 Telnet
    客户端视为本地终端，允许用户登录并访问服务器的资源，就像他正在使用直接连接的终端一样。UNIX 用户仍然广泛使用这种方式，他们经常需要从本地机器登录到远程主机（我每天使用
    Telnet 以这种方式访问数百英里外的机器）。然而，对于大多数在 Windows 或 Apple 计算机上工作的互联网用户来说，这种 Telnet 的使用并不常见，他们通过网络资源不是通过直接登录，而是通过其他方式访问。
- en: Although remote login is a big part of what Telnet is about, the protocol was
    not inherently designed for that specific function. When Telnet is used to access
    a remote device, the protocol itself is used only to set up the connection between
    the client and server machines, encode data to be transmitted according to the
    rules of the Telnet NVT, and facilitate the negotiation and use of options. The
    client and server devices decide whether Telnet is used for remote access or for
    some other purpose.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然远程登录是 Telnet 的一个重要部分，但该协议并非最初就是为了那个特定功能而设计的。当使用 Telnet 访问远程设备时，该协议本身仅用于在客户端和服务器机器之间建立连接，根据
    Telnet NVT 规则编码要传输的数据，并促进选项的协商和使用。客户端和服务器设备决定是否使用 Telnet 进行远程访问或其他目的。
- en: This flexibility, combined with Telnet's age in the TCP/IP suite, has led to
    its being adopted for a variety of other protocols. Since Telnet doesn't make
    assumptions about what a client is and what a server is, any program or application
    can use it. Many of the file and message transfer applications—such as FTP, Simple
    Mail Transfer Protocol (SMTP), Network News Transfer Protocol (NNTP), and Hypertext
    Transfer Protocol (HTTP)—communicate by sending text commands and messages, and
    use Telnet's NVT specification to ensure the compatibility of communication between
    devices. They don't actually establish Telnet sessions or use features like option
    negotiation; they just send data in a manner consistent with how Telnet works.
    Thus, even though modern Internet users may never intentionally invoke Telnet
    specifically, they use it indirectly every time they send or receive email or
    browse the Web. Administrators can even use Telnet client software to access devices
    such as FTP and HTTP servers, and send those devices commands manually.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性，加上 Telnet 在 TCP/IP 套件中的历史，导致了它在各种其他协议中的应用。由于 Telnet 对客户端和服务器是什么没有假设，任何程序或应用都可以使用它。许多文件和消息传输应用，如
    FTP、简单邮件传输协议 (SMTP)、网络新闻传输协议 (NNTP) 和超文本传输协议 (HTTP)，通过发送文本命令和消息进行通信，并使用 Telnet
    的 NVT 规范确保设备之间通信的兼容性。它们实际上并没有建立 Telnet 会话或使用选项协商等特性；它们只是以与 Telnet 工作方式一致的方式发送数据。因此，尽管现代互联网用户可能从未有意调用
    Telnet，但每次发送或接收电子邮件或浏览网页时，他们都在间接地使用它。管理员甚至可以使用 Telnet 客户端软件访问 FTP 和 HTTP 服务器等设备，并手动向这些设备发送命令。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Telnet* is one of the oldest protocols in the TCP/IP suite,
    first developed in the 1960s to allow a user on one computer system to directly
    access and use another. It is most often used for remote login, with Telnet client
    software on a user''s machine establishing a session with a Telnet server on a
    remote host to let the user work with the host as if connected directly. To ensure
    compatibility between terminals and hosts that use different hardware and software,
    communication between Telnet client and server software is based on a simplified,
    fictional data representation, called the *Network Virtual Terminal (NVT)*, which
    can be enhanced through the negotiation of options.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *Telnet* 是 TCP/IP 套件中最古老的协议之一，最早在 1960 年代开发，允许一个计算机系统上的用户直接访问和使用另一个系统。它最常用于远程登录，用户的机器上的
    Telnet 客户端软件与远程主机上的 Telnet 服务器建立会话，使用户能够像直接连接一样与主机工作。为了确保使用不同硬件和软件的终端和主机之间的兼容性，Telnet
    客户端和服务器软件之间的通信基于一个简化的、虚构的数据表示，称为 *网络虚拟终端 (NVT)*，可以通过协商选项来增强。'
- en: Telnet Connections and Client/Server Operation
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet 连接和客户端/服务器操作
- en: Telnet's overall function is to define a means by which a user or process on
    one machine can access and use another machine as if it were locally connected.
    This makes Telnet inherently client/server in operation, like so many other application
    protocols in TCP/IP. Usually, the Telnet client is a piece of software that acts
    as an interface to the user, processing keystrokes and user commands and presenting
    output from the remote machine. The Telnet server is a program running on a remote
    computer that has been set up to allow remote sessions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 的整体功能是定义一种方式，允许一台机器上的用户或进程可以访问并使用另一台机器，就像它本地连接一样。这使得 Telnet 在操作上本质上是客户端/服务器模式，就像
    TCP/IP 中许多其他应用协议一样。通常，Telnet 客户端是一段软件，作为用户界面的接口，处理按键和用户命令，并展示远程机器的输出。Telnet 服务器是在远程计算机上运行的程序，已配置为允许远程会话。
- en: TCP Sessions and Client/Server Communication
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP 会话和客户端/服务器通信
- en: 'Telnet is used for the interactive communication of data and commands between
    a client and server over a prolonged period of time, and is thus strongly based
    on the concept of a *session*. For this reason, Telnet runs over the connection-oriented
    Transmission Control Protocol (TCP). Telnet servers listen for connections on
    well-known TCP port number 23\. When a client wants to access a particular server,
    it initiates a TCP connection to the appropriate server, which responds to set
    up a TCP connection using the standard TCP three-way handshake (described in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet用于在客户端和服务器之间进行长时间的数据和命令交互，因此它强烈依赖于*会话*的概念。因此，Telnet通过面向连接的传输控制协议（TCP）运行。Telnet服务器监听在著名的TCP端口号23上的连接。当客户端想要访问特定的服务器时，它会向相应的服务器发起一个TCP连接，服务器会响应并使用标准的TCP三次握手（在[第47章](ch47.html
    "第47章。TCP基本操作：连接建立、管理和终止")中描述）来建立TCP连接。
- en: The TCP connection is maintained for the duration of the Telnet session, which
    can remain alive for hours, days, or even weeks at a time. The quality of service
    features of TCP guarantee that data is received reliably and in order, and ensure
    that data is not sent at too high a rate for either client or server. A machine
    offering Telnet service can support multiple simultaneous sessions with different
    users, keeping each distinct by identifying it using the IP address and port number
    of the client.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接在整个Telnet会话期间保持，Telnet会话可以持续数小时、数天甚至数周。TCP的服务质量特性保证数据可靠且有序地接收，并确保数据不会以过高的速率发送给客户端或服务器。提供Telnet服务的机器可以支持与不同用户的多个同时会话，通过使用客户端的IP地址和端口号来区分每个会话。
- en: Since TCP is a full-duplex protocol, both the client and server can send information
    at will over the Telnet session. By default, both devices begin by using the standard
    NVT method for encoding data and control commands (which we will explore fully
    a little later in this chapter). They can also negotiate the use of Telnet options
    to provide greater functionality for the session. While option negotiation can
    occur at any time, it is normal for there to be a burst of such option exchanges
    when a Telnet session is first established and only occasional option command
    exchanges thereafter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP是一种全双工协议，客户端和服务器都可以在Telnet会话中随意发送信息。默认情况下，两个设备开始时都使用标准的NVT方法来编码数据和控制命令（我们将在本章稍后全面探讨）。它们还可以协商使用Telnet选项来为会话提供更强大的功能。虽然选项协商可以在任何时候发生，但在Telnet会话首次建立时通常会有一个选项交换的爆发，之后则只有偶尔的选项命令交换。
- en: With the TCP connection in place and the Telnet session active, the client and
    server software begin their normal jobs of interfacing the user to the remote
    host. To the user, the Telnet session appears fundamentally the same as sitting
    down at a terminal directly connected to the remote host. In most cases, the server
    will begin the user's session by sending a login prompt to ask for a user name
    and password. The Telnet client will accept this information from the user and
    send it to the server. Assuming the information is valid, the user will be logged
    in and can use the host in whatever manner her account authorizes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP连接建立且Telnet会话活跃时，客户端和服务器软件开始执行它们正常的任务，即使用户与远程主机进行交互。对于用户来说，Telnet会话看起来基本上与坐在直接连接到远程主机的终端上是一样的。在大多数情况下，服务器将通过发送登录提示来开始用户的会话，要求输入用户名和密码。Telnet客户端将从用户那里接受这些信息并将其发送到服务器。假设信息有效，用户将被登录并可以使用主机，方式取决于其账户的授权。
- en: As mentioned in the Telnet overview, even though the protocol is commonly used
    for remote login, it does not need to be used in this manner. The administrator
    of the computer that is running the Telnet server determines how it is to be used
    on that machine. As just one example, a Telnet server can be interfaced directly
    to a process or program providing a service. I can recall years ago using an Internet
    server that provided weather information to the public using Telnet. After using
    the protocol to connect to that machine, users were presented not with a login
    prompt, but with a menu of weather display options. Today, the Web has replaced
    most of such facilities, as it is far better suited to this type of information
    retrieval.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Telnet 概述中所述，尽管该协议通常用于远程登录，但它并不需要以这种方式使用。运行 Telnet 服务器的计算机管理员决定在该机器上如何使用它。举一个例子，一个
    Telnet 服务器可以直接与提供服务的进程或程序接口。我记得几年前使用过一个提供公共天气信息的互联网服务器，它使用 Telnet。在通过该协议连接到该机器后，用户看到的不是登录提示，而是一个天气显示选项菜单。如今，Web
    已经取代了大多数此类设施，因为它更适合此类信息检索。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Telnet is a client/server protocol that uses TCP to establish
    a session between a user terminal and a remote host. The Telnet client software
    takes input from the user and sends it to the server, which feeds it to the host
    machine''s operating system. The Telnet server takes output from the host and
    sends it to the client to display to the user. While Telnet is most often used
    to implement remote login capability, it is not specifically designed for logins.
    The protocol is general enough to allow it to be used for a variety of functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet 是一种客户端/服务器协议，它使用 TCP 在用户终端和远程主机之间建立会话。Telnet 客户端软件从用户那里获取输入并将其发送到服务器，服务器将其传递给主机机器的操作系统。Telnet
    服务器从主机获取输出并将其发送到客户端以显示给用户。虽然 Telnet 最常用于实现远程登录功能，但它并非专门为登录而设计。该协议足够通用，允许它用于各种功能。'
- en: Use of Telnet to Access Other Servers
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Telnet 访问其他服务器
- en: 'The Telnet NVT representation is used by a variety of other protocols such
    as SMTP and HTTP. This means that the same Telnet client that allows you to access
    a Telnet server can be used to directly access other application servers. All
    you need to do is specify the port number corresponding to the service. For example,
    the following command will allow you to directly interface to a web server:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet NVT 表示被 SMTP 和 HTTP 等各种其他协议使用。这意味着，允许您访问 Telnet 服务器的相同 Telnet 客户端也可以用来直接访问其他应用程序服务器。您只需指定对应于服务的端口号即可。例如，以下命令将允许您直接与一个
    Web 服务器接口：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will not receive a login prompt, but instead the server will wait for you
    to send an HTTP Request message, as if you were a web browser. If you enter a
    valid request, the server will send you an HTTP Response message. Used in this
    way, Telnet can be very valuable as a diagnostic tool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不会收到登录提示，而是服务器将等待您发送 HTTP 请求消息，就像您是一个网页浏览器一样。如果您输入一个有效的请求，服务器将发送一个 HTTP 响应消息。以这种方式使用，Telnet
    可以作为一个非常有价值的诊断工具。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Telnet Network Virtual Terminal (NVT) data representation
    has been adopted by a host of other TCP/IP protocols as the basis for their messaging
    systems. Telnet client software can thus be used not only to connect to Telnet
    servers, but also to connect to servers of protocols such as SMTP and HTTP, which
    is useful for diagnostic purposes.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet 网络虚拟终端 (NVT) 数据表示已被众多其他 TCP/IP 协议采纳作为其消息系统的基础。因此，Telnet 客户端软件不仅可以用来连接到
    Telnet 服务器，还可以用来连接到 SMTP 和 HTTP 等协议的服务器，这在诊断目的上非常有用。'
- en: Telnet Communications Model and the Network Virtual Terminal (NVT)
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet 通信模型和网络虚拟终端 (NVT)
- en: 'At its heart, Telnet is a rather simple protocol. Once a TCP connection is
    made and the Telnet session begins, the only real task for the client and server
    software is to capture input and output, and redirect it over the network. So,
    when the user presses a key on his local terminal, the Telnet client software
    captures it and sends it over the network to the remote machine. There, the Telnet
    server software sends the keypress to the operating system, which treats it as
    if it had been typed locally. When the operating system produces output, the process
    is reversed: Telnet server software captures the output and sends it over the
    network to the user''s client program, which displays it on the printer or monitor.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet的核心实际上是一个相当简单的协议。一旦建立了TCP连接并开始Telnet会话，客户端和服务器软件的唯一真正任务是捕获输入和输出，并将其通过网络重定向。因此，当用户在其本地终端上按下一个键时，Telnet客户端软件会捕获它并将其通过网络发送到远程机器。在那里，Telnet服务器软件将按键发送到操作系统，操作系统将其视为在本地输入。当操作系统产生输出时，过程相反：Telnet服务器软件捕获输出并将其通过网络发送到用户的客户端程序，该程序将其显示在打印机或监视器上。
- en: To invoke two well-known clichés, I could say that this looks good on paper,
    but that the devil is in the details. This simplified implementation would work
    only if every computer and terminal used the exact same hardware, software, and
    data representation. Of course, this is far from the case today, and was even
    worse when Telnet was being developed. Computers back in the "good old days" were
    highly proprietary and not designed to interoperate. They differed in numerous
    ways—from the type of keyboard a terminal used and the keystrokes it could send,
    to the number of characters per line and lines per screen on a terminal, to the
    character set used to encode data and control functions. In short, Computer A
    was designed to accept input in a particular form from its own terminals, and
    not those of Computer B.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用两个众所周知的陈词滥调来说，我可以说这看起来在纸上不错，但魔鬼在于细节。这个简化的实现只有在所有计算机和终端都使用完全相同的硬件、软件和数据表示时才会工作。当然，这今天远非如此，当Telnet正在开发时情况更糟。在“美好的旧时光”里，计算机非常专有，并且没有设计成可以互操作。它们在许多方面都不同——从终端使用的键盘类型和它可以发送的按键到终端每行和每屏的字符数，再到用于编码数据和控制功能的字符集。简而言之，计算机A被设计成只能接受来自其自己的终端的特定形式的输入，而不是来自计算机B的终端。
- en: This is actually a fairly common issue in the world of networking, and one to
    which I can draw a real-world analogy to help explain the problem and how it may
    be solved. Suppose that an important international conference was attended by
    30 ambassadors from different nations, each of which had one assistant. Every
    ambassador and assistant pair spoke only their own language and thus could only
    speak to each other—just like a computer and terminal designed to interface only
    to each other. To allow the assistant from one country to speak to the ambassador
    from the others, one solution would be to train the assistants to speak the languages
    of all the other attending nations. Back in the computing world, this would be
    like defining the Telnet Protocol so that every Telnet client software implementation
    understood how to speak to every computer in existence. This would work, but it
    would be quite impractical and difficult to do.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是在网络世界中相当常见的问题，我可以举一个现实世界的例子来帮助解释这个问题以及它可能如何被解决。假设一个重要的国际会议有来自不同国家的30位大使参加，每位大使都有一位助手。每个大使和助手对只说自己的语言，因此只能相互交流——就像是为相互接口而设计的计算机和终端一样。为了让一个国家的助手能与来自其他国家的大使交流，一个解决方案就是训练助手们说所有其他参加国家的语言。回到计算世界，这就像定义Telnet协议，使得每个Telnet客户端软件都能理解如何与现有的每台计算机通信。这可以工作，但会非常不切实际且难以实现。
- en: An alternative approach is to define a single common language and have all the
    ambassadors and assistants learn it. While this would require some work, it would
    be a lot less than requiring people to learn dozens of languages. Each ambassador
    and assistant would speak both a native language and this chosen common language.
    Each could communicate with all of the others using this common language, without
    needing to know all of the languages that might be used by anyone at the conference.
    Even more important, if an ambassador and assistant showed up at the conference
    speaking a new, 31st language, all the other delegates wouldn't need to learn
    it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是定义一种单一的共同语言，并让所有的大使和助手都学习这种语言。虽然这需要一些工作，但远不如要求人们学习几十种语言那么多。每位大使和助手都会说一种母语和这种选定的共同语言。他们可以使用这种共同语言与所有人进行交流，而无需知道会议中可能使用的所有语言。更重要的是，如果一位大使和助手在会议上说一种新的、第
    31 种语言，其他所有代表就不需要学习它。
- en: Telnet uses a very similar approach for dealing with its problem of hardware
    and software compatibility. Rather than having terminals and hosts communicate
    using their various native languages, all Telnet clients and servers agree to
    send data and commands that adhere to a fictional, virtual terminal type call
    the NVT.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 使用了一种非常类似的方法来处理其硬件和软件兼容性问题。而不是让终端和主机使用它们各自的原生语言进行通信，所有的 Telnet 客户端和服务器都同意发送符合虚构的、虚拟终端类型（NVT）的数据和命令。
- en: The NVT
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NVT
- en: The NVT defines a set of rules for how information is formatted and sent, such
    as character set, line termination, and how information about the Telnet session
    itself is sent.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: NVT 定义了信息格式化和发送的规则集，例如字符集、行终止符以及如何发送关于 Telnet 会话本身的信息。
- en: Each Telnet client running on a terminal understands both its native language
    and the NVT language. When users enter information on their local terminal, it
    is converted to NVT form for transmission over the network. When the Telnet server
    receives this information, it translates it from NVT form to the format that the
    remote host expects to receive it. The identical process is performed for transmissions
    from the server to the client, in reverse. This is illustrated in [Figure 87-1](ch87.html#telnet_communication_and_the_network_vir
    "Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet
    uses the Network Virtual Terminal (NVT) representation to allow a user terminal
    and remote host that use different internal formats to communicate.").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上运行的每个 Telnet 客户端都理解其原生语言和 NVT 语言。当用户在本地终端上输入信息时，它会被转换为 NVT 格式以便通过网络传输。当
    Telnet 服务器接收到这些信息时，它会将其从 NVT 格式转换为远程主机期望接收的格式。从服务器到客户端的传输也执行相同的反向过程。这如图 [图 87-1](ch87.html#telnet_communication_and_the_network_vir
    "图 87-1. Telnet 通信和网络虚拟终端 (NVT) Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。")
    所示。
- en: '![Telnet communication and the Network Virtual Terminal (NVT) Telnet uses the
    Network Virtual Terminal (NVT) representation to allow a user terminal and remote
    host that use different internal formats to communicate.](httpatomoreillycomsourcenostarchimages288325.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Telnet 通信和网络虚拟终端 (NVT) Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。](httpatomoreillycomsourcenostarchimages288325.png.jpg)'
- en: Figure 87-1. Telnet communication and the Network Virtual Terminal (NVT) Telnet
    uses the Network Virtual Terminal (NVT) representation to allow a user terminal
    and remote host that use different internal formats to communicate.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 87-1. Telnet 通信和网络虚拟终端 (NVT) Telnet 使用网络虚拟终端 (NVT) 表示法，允许使用不同内部格式的用户终端和远程主机进行通信。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Telnet *Network Virtual Terminal (NVT)* is a uniform data
    representation that ensures the compatibility of communication between terminals
    and hosts that may use very different hardware, software, and data formats. The
    Telnet client translates user input from the terminal''s native form to NVT form
    for transport to the Telnet server, where it is converted to the host''s internal
    format. The process is reversed for output from the host to the user.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet 的 *网络虚拟终端 (NVT)* 是一种统一的数据表示，确保了可能使用非常不同硬件、软件和数据格式的终端和主机之间通信的兼容性。Telnet
    客户端将终端的原生格式输入转换为 NVT 格式以便传输到 Telnet 服务器，在那里它被转换为主机的内部格式。从主机到用户的输出过程是相反的。'
- en: The NVT is defined to consist of a logical keyboard for input and a logical
    printer for output (the age of the protocol is reflected in these terms; decades
    ago there were no monitors, all output was on paper). NVT uses the 7-bit *United
    States ASCII (US-ASCII)* character set. Each character is encoded using one 8-bit
    byte.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: NVT 被定义为包含一个逻辑键盘用于输入和一个逻辑打印机用于输出（协议的年龄在这些术语中得到了反映；几十年前没有显示器，所有输出都在纸上）。NVT 使用
    7 位 *美国 ASCII (US-ASCII)* 字符集。每个字符使用一个 8 位字节进行编码。
- en: However, a client and server can use Telnet options to negotiate other data
    representations, including the transmission of either extended ASCII or even full
    8-bit binary data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端和服务器可以使用 Telnet 选项协商其他数据表示，包括传输扩展 ASCII 或甚至完整的 8 位二进制数据。
- en: NVT ASCII Control Codes
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NVT ASCII 控制码
- en: Regular ASCII consists of 95 regular, printable characters (codes 32 through
    126) and 33 control codes (0 through 31 and 127). The Telnet standard specifies
    that the output device must be able to handle all the printable characters, and
    it mandates how several of the other common ASCII control codes should be interpreted.
    Of these codes, three (0, 10, and 13) are required to be accepted by all Telnet
    software; five others are optional, but if supported, must be interpreted in a
    manner consistent with the Telnet specification. [Table 87-1](ch87.html#interpretation_of_standard_telnet_nvt_as
    "Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes") describes
    the standard Telnet NVT ASCII control codes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正规 ASCII 由 95 个常规的可打印字符（代码 32 至 126）和 33 个控制码（0 至 31 和 127）组成。Telnet 标准规定输出设备必须能够处理所有可打印字符，并强制规定如何解释其他一些常见的
    ASCII 控制码。在这些码中，有三个（0、10 和 13）必须被所有 Telnet 软件接受；另外五个是可选的，但如果支持，则必须以与 Telnet 规范一致的方式进行解释。[表 87-1](ch87.html#interpretation_of_standard_telnet_nvt_as
    "表 87-1. 标准 Telnet NVT ASCII 控制码的解释") 描述了标准 Telnet NVT ASCII 控制码。
- en: Table 87-1. Interpretation of Standard Telnet NVT ASCII Control Codes
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表 87-1. 标准 Telnet NVT ASCII 控制码的解释
- en: '| ASCII Value (Decimal) | ASCII Character Code | ASCII Character | Description
    | Support Optional/Mandatory |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| ASCII 值（十进制） | ASCII 字符代码 | ASCII 字符 | 描述 | 支持可选/强制 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | NUL | Null | No operation (no effect on output). | Mandatory |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 0 | NUL | 空字符 | 无操作（对输出无影响）。 | 强制 |'
- en: '| 7 | BEL | Bell | Produces an audible or visible signal on the output without
    moving the print head. This notification may be used to get the user''s attention,
    as in the case of an error. | Optional |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 7 | BEL | 铃声 | 在输出上产生可听或可视的信号，而不移动打印头。此通知可用于吸引用户的注意，例如在错误的情况下。 | 可选 |'
- en: '| 8 | BS | Backspace | Moves the print position one character to the left.
    | Optional |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 8 | BS | 退格 | 将打印位置向左移动一个字符。 | 可选 |'
- en: '| 9 | HT | Horizontal Tab | Moves the printer to the next horizontal tab stop.
    The standard does not specify how devices agree on tab stop positions; this can
    be negotiated using Telnet options. | Optional |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 9 | HT | 水平制表符 | 将打印机移动到下一个水平制表位。标准没有指定设备如何就制表位位置达成一致；这可以通过 Telnet 选项进行协商。
    | 可选 |'
- en: '| 10 | LF | Line Feed | Moves the printer to the next line, keeping the print
    position the same. | Mandatory |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 10 | LF | 换行 | 将打印机移动到下一行，保持打印位置不变。 | 强制 |'
- en: '| 11 | VT | Vertical Tab | Moves the print line to the next vertical tab stop.
    As with the HT character, devices must use an option to come to an agreement on
    vertical tab stop positions. | Optional |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 11 | VT | 垂直制表符 | 将打印行移动到下一个垂直制表位。与 HT 字符一样，设备必须使用选项来达成关于垂直制表位位置的协议。 | 可选
    |'
- en: '| 12 | FF | Form Feed | Moves the printer to the top of the next page (or on
    a display, clears the screen and positions the cursor at the top). | Optional
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 12 | FF | 进纸 | 将打印机移动到下一页的顶部（或在显示器上，清除屏幕并将光标定位在顶部）。 | 可选 |'
- en: '| 13 | CR | Carriage Return | Moves the printer to the left margin of the current
    print line. | Mandatory |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 13 | CR | 回车 | 将打印机移动到当前打印行的左边缘。 | 强制 |'
- en: The Telnet NVT scheme defines the combination of the carriage return (CR) and
    line feed (LF) characters to represent the end of a line of ASCII text. The literal
    meaning of these two characters is return to the left margin (the CR) and go to
    the next line (the LF). However, NVT treats the CRLF sequence as more than just
    two independent characters; they are taken collectively to define a *logical end-of-line
    character*. This is necessary because not all terminal types define an end of
    line using both CR and LF. Translation of end-of-line characters between the native
    and NVT formats is one of the functions that Telnet client and server software
    must perform to ensure compatibility between terminals and hosts.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet NVT方案定义了回车（CR）和换行（LF）字符的组合来表示ASCII文本行的结束。这两个字符的字面意思是回到左边界（CR）和进入下一行（LF）。然而，NVT将CRLF序列视为不仅仅是两个独立的字符；它们被整体地用来定义一个*逻辑行结束字符*。这是必要的，因为并非所有终端类型都使用CR和LF来定义行结束。在本地格式和NVT格式之间转换行结束字符是Telnet客户端和服务器软件必须执行的功能之一，以确保终端和主机之间的兼容性。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Telnet NVT format is based on 7-bit US-ASCII, with each
    byte carrying one character. The standard specifies that devices must handle all
    standard printable ASCII characters, as well as three mandatory control characters.
    Two of these are the carriage return (CR) and line feed (LF) characters; when
    combined, these define the logical end of a line of text. The Telnet standard
    also describes the interpretation of five other optional ASCII control characters.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet NVT格式基于7位US-ASCII，每个字节携带一个字符。标准规定设备必须处理所有标准可打印ASCII字符，以及三个强制性的控制字符。其中两个是回车（CR）和换行（LF）字符；当组合在一起时，它们定义了文本行的逻辑结束。Telnet标准还描述了五种其他可选ASCII控制字符的解释。'
- en: Half-Duplex and Full-Duplex Modes
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半双工和全双工模式
- en: 'Another artifact of the age of Telnet is that for maximum compatibility, the
    NVT specification is designed under the assumption of half-duplex operation: only
    one device can transmit at a time. A device that is sending data is supposed to
    end its transmission with the special Telnet Go Ahead command, telling the other
    device that it may now transmit (the next section describes Telnet protocol commands).
    This is similar to how people using walkie-talkies end each transmission with
    "Over," to tell their partners that they may now respond.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet时代的另一个遗迹是，为了实现最大兼容性，NVT规范是在假设半双工操作的情况下设计的：一次只能有一个设备传输。发送数据的设备应该用特殊的Telnet前进命令结束其传输，告诉另一个设备现在可以传输（下一部分将描述Telnet协议命令）。这类似于使用对讲机的人在每个传输结束时说“Over”，告诉他们的伙伴现在可以回应。
- en: Of course, modern networks operate in a full-duplex mode, and using half-duplex
    communication would be needlessly inefficient. In most cases, the Telnet client
    and server agree to use an option (Suppress Go Ahead) that eliminates the need
    to send this command. However, having this as the default is a good example of
    how NVT acts as a least common denominator in Telnet, in case the simpler operating
    mode is needed by either device.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现代网络以全双工模式运行，使用半双工通信将是无谓的低效。在大多数情况下，Telnet客户端和服务器同意使用一个选项（抑制前进）来消除发送此命令的需要。然而，将其作为默认设置是NVT在Telnet中充当最小公倍数的一个好例子，以防任一设备需要更简单的操作模式。
- en: Telnet Protocol Commands
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet协议命令
- en: Most of the input that users enter at a terminal takes the form of data and
    commands that are sent to the application program they are using. However, computer
    systems also provide a means by which users can instruct the terminal to send
    certain commands that control how the terminal itself operates, and how it interacts
    with the computer to which it is connected. The best example of this is the command
    to interrupt a process, which is usually sent by pressing a special key or key
    combination on the user terminal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在终端输入的大部分输入都是以数据和命令的形式发送给他们正在使用的应用程序。然而，计算机系统也提供了一种方法，用户可以通过它来指示终端发送某些命令，以控制终端本身的操作以及它与连接的计算机的交互。最好的例子是中断进程的命令，通常是通过在用户终端上按下特殊键或键组合来发送的。
- en: 'Telnet needs to have a way to allow such commands to be entered by the user.
    However, here we run into the same problem that arises in the communication of
    data between terminals and computers: a lack of uniformity in representation.
    While all terminals and computers support the ability to interrupt a running program,
    for example, they may each use a different keystroke to invoke it. For example,
    on most UNIX systems, the key combination ctrl-C interrupts a program, but typing
    this on a Windows system will not (it usually represents the copy data function!).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 需要有一个方式允许用户输入这样的命令。然而，在这里我们遇到了在终端和计算机之间通信数据时出现的问题：表示的不一致性。虽然所有终端和计算机都支持中断正在运行程序的能力，例如，它们可能使用不同的按键来调用它。例如，在大多数
    UNIX 系统中，ctrl-C 组合键可以中断程序，但在 Windows 系统上输入这个键组合将不会（它通常代表复制数据功能！）。
- en: 'Since the problem is the same as the one we ran into in representing data flow,
    it''s not too surprising that the solution is the same: the use of a universal
    representation for a set of standard commands to be passed between the terminal
    and host computer. All keystrokes that represent these commands are translated
    to the standard Telnet codes for transmission, and then translated to the specific
    needs of the host computer. So, if a user presses ctrl-C on a UNIX terminal where
    this is defined as the interrupt function, instead of sending that exact keystroke,
    the Telnet client sends the special Telnet Interrupt Process command, which is
    translated by the Telnet server to the command code appropriate for the connected
    host.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于问题与我们在表示数据流时遇到的问题相同，因此解决方案相同并不令人惊讶：使用一组标准命令的通用表示，这些命令在终端和主机计算机之间传递。所有表示这些命令的按键都转换为标准
    Telnet 代码进行传输，然后转换为主机计算机的特定需求。因此，如果用户在将 ctrl-C 定义为中断功能的 UNIX 终端上按下，而不是发送那个确切的按键，Telnet
    客户端会发送特殊的 Telnet 中断进程命令，该命令由 Telnet 服务器转换为适合连接的主机的适当命令代码。
- en: The Telnet standard includes a number of these special codes to allow a user
    to control the operation of the remote computer. It also defines a set of commands
    that are specific to the Telnet Protocol itself; these let the Telnet client and
    Telnet server software communicate. Collectively, these are called Telnet *protocol
    commands*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 标准包括一系列这些特殊代码，允许用户控制远程计算机的操作。它还定义了一组特定于 Telnet 协议本身的命令；这些命令允许 Telnet
    客户端和 Telnet 服务器软件进行通信。这些统称为 Telnet *协议命令*。
- en: All Telnet commands are sent in the same communication stream as regular data.
    They are represented using special byte values in the range from 240 to 254\.
    To differentiate between data bytes of these values and Telnet commands, every
    command is preceded by a special *escape character*, given the name *Interpret
    As Command (IAC)*. IAC has a value of 255; when the recipient sees this character,
    it knows the next byte is a command, not data. So, since the Telnet Interrupt
    Process command has the value 244, to send this command, the Telnet client would
    transmit the byte 255 and then 244\. If the actual data byte value 255 needs to
    be sent, it is transmitted as two 255 bytes. Some Telnet commands also include
    additional bytes of data, which are sent after the command code itself. A good
    example is the use of parameters in Telnet option negotiation, as you will see
    in the "Telnet Options and Option Negotiation" section later in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '所有 Telnet 命令都发送在与常规数据相同的通信流中。它们使用从 240 到 254 范围内的特殊字节值来表示。为了区分这些值的字节数据和 Telnet
    命令，每个命令前面都有一个特殊的 *转义字符*，被称为 *解释为命令 (IAC)*。IAC 的值为 255；当接收方看到这个字符时，它知道下一个字节是命令，而不是数据。因此，由于
    Telnet 中断进程命令的值为 244，要发送此命令，Telnet 客户端会传输字节 255 然后是 244。如果需要发送实际数据字节值 255，它将以两个
    255 字节的形式传输。一些 Telnet 命令还包括额外的数据字节，这些数据字节在命令代码本身之后发送。一个很好的例子是在“Telnet 选项和选项协商”部分后面，您将看到的
    Telnet 选项协商中使用参数。 '
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The Telnet Protocol defines a set of *protocol commands* that
    are used for two purposes: first, to represent standard control functions that
    need to be sent between a terminal and host, such as the command to interrupt
    a process, and second, to enable protocol communication between the Telnet client
    and server software. Protocol commands are sent in the normal data communication
    stream over the Telnet session''s TCP connection. Each is represented by a byte
    value from 240 to 254, and is preceded by the Interpret As Command (IAC) command,
    byte value 255, which tells the recipient that the next byte in the stream is
    a command.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet协议定义了一组*协议命令*，用于两个目的：首先，表示需要在终端和主机之间发送的标准控制功能，例如中断进程的命令，其次，使Telnet客户端和服务器软件之间的协议通信成为可能。协议命令在Telnet会话的TCP连接的正常数据通信流中发送。每个命令由240到254之间的字节值表示，并且由Interpret
    As Command (IAC)命令（字节值255） precedes，它告诉接收者流中的下一个字节是命令。'
- en: You may be wondering at this point why the IAC character is needed at all. After
    all, Telnet uses US-ASCII, which is 7-bit data in the byte range of 0 to 127,
    and the Telnet commands have values higher than 127\. One general rationale for
    using the IAC escape character is to be explicit that a command is being sent.
    A more specific reason is to accommodate the optional sending of 8-bit binary
    data over Telnet, which the client and server can negotiate. If this mode were
    enabled and commands were not preceded by the IAC character, this would require
    all data bytes with values from 240 to 255 to be marked somehow so they would
    be interpreted as data and not commands. It is more efficient to include an extra
    byte for commands than data, since commands are sent less frequently. By escaping
    commands, only data byte value 255 requires two bytes to be sent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这个时候想知道为什么IAC字符真的有必要。毕竟，Telnet使用US-ASCII，它是0到127字节范围内的7位数据，而Telnet命令的值高于127。使用IAC转义字符的一般理由是明确表示正在发送命令。一个更具体的原因是适应通过Telnet发送可选的8位二进制数据，客户端和服务器可以协商此功能。如果启用此模式且命令不以IAC字符开头，则需要以某种方式标记所有值从240到255的数据字节，以便它们被解释为数据而不是命令。由于命令发送的频率较低，包含额外的命令字节比数据字节更有效。通过转义命令，只有数据字节值255需要发送两个字节。
- en: '[Table 87-2](ch87.html#telnet_protocol_commands-id001 "Table 87-2. Telnet Protocol
    Commands") lists the Telnet protocol commands in numerical byte value order, showing
    for each its command code and name, and describing its meaning and use.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[表87-2](ch87.html#telnet_protocol_commands-id001 "表87-2. Telnet协议命令")按数值字节值顺序列出Telnet协议命令，显示每个命令的代码和名称，并描述其含义和使用方法。'
- en: Table 87-2. Telnet Protocol Commands
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表87-2. Telnet协议命令
- en: '| Command Byte Value (Decimal) | Command Code | Command | Description |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 命令字节值（十进制） | 命令代码 | 命令 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 240 | SE | Subnegotiation End | Marks the end of a Telnet option subnegotiation,
    used with the SB code to specify more specific option parameters. See the "Telnet
    Options and Option Negotiation" section later in this chapter for details. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 240 | SE | 子协商结束 | 标记Telnet选项子协商的结束，与SB代码一起使用以指定更具体的选项参数。有关详细信息，请参阅本章后面的“Telnet选项和选项协商”部分。
    |'
- en: '| 241 | NOP | No Operation | Null command; does nothing. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 241 | NOP | 无操作 | 空命令；不执行任何操作。 |'
- en: '| 242 | DM | Data Mark | Used to mark the end of a sequence of data that the
    recipient should scan for urgent Telnet commands. See the discussion of Telnet
    interrupt handling in the following section for details. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 242 | DM | 数据标记 | 用于标记接收者应扫描以查找紧急Telnet命令的数据序列的结束。有关详细信息，请参阅下一节中关于Telnet中断处理的讨论。
    |'
- en: '| 243 | BRK | Break | Represents the pressing of the "break" or "attention"
    key on the terminal. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 243 | BRK | 断开连接 | 表示在终端上按下“断开连接”或“注意”键。 |'
- en: '| 244 | IP | Interrupt Process | Tells the recipient to interrupt, abort, suspend,
    or terminate the process currently in use. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 244 | IP | 中断进程 | 告诉接收者中断、中止、挂起或终止当前正在使用的进程。 |'
- en: '| 245 | AO | Abort Output | Instructs the remote host to continue running the
    current process but discard all remaining output from it. This may be needed if
    a program starts to send unexpectedly large amounts of data to the user. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 245 | AO | 终止输出 | 指示远程主机继续运行当前进程，但丢弃其所有剩余输出。如果程序开始向用户发送意外大量数据，则可能需要这样做。 |'
- en: '| 246 | AYT | Are You There | May be used to check that the remote host is
    still "alive." When this character is sent, the remote host returns some type
    of output to indicate that it is still functioning. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 246 | AYT | Are You There | 可能用于检查远程主机是否仍然“活跃”。当发送此字符时，远程主机会返回某种类型的输出以指示它仍在运行。|'
- en: '| 247 | EC | Erase Character | Instructs the recipient to delete the last undeleted
    character from the data stream. Used to undo the sending of a character. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 247 | EC | Erase Character | 指示接收方删除数据流中最后一个未删除的字符。用于撤销发送字符。|'
- en: '| 248 | EL | Erase Line | Tells the recipient to delete all characters from
    the data stream back to (but not including) the last end-of-line (CRLF) sequence.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 248 | EL | Erase Line | 告诉接收方删除从最后一个换行符（CRLF）序列（但不包括）回的数据流中的所有字符。|'
- en: '| 249 | GA | Go Ahead | Used in Telnet half-duplex mode to signal the other
    device that it may transmit. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 249 | GA | Go Ahead | 在 Telnet 半双工模式下使用，以向其他设备发出可以传输的信号。|'
- en: '| 250 | SB | Subnegotiation | Marks the beginning of a Telnet option subnegotiation,
    used when an option requires the client and server to exchange parameters. See
    the "Telnet Options and Option Negotiation" section later in this chapter for
    a full description. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 250 | SB | Subnegotiation | 标记 Telnet 选项子协商的开始，当选项需要客户端和服务器交换参数时使用。有关完整描述，请参阅本章后面的“Telnet
    选项和选项协商”部分。|'
- en: '| 251 | WILL | Will Perform | In Telnet option negotiation, indicates that
    the device sending this code is willing to perform or continue performing a particular
    option. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 251 | WILL | Will Perform | 在 Telnet 选项协商中，表示发送此代码的设备愿意执行或继续执行特定选项。|'
- en: '| 252 | WONT | Won''t Perform | In Telnet option negotiation, indicates that
    the device sending this code is either not willing to perform a particular option
    or is now refusing to continue to perform it. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 252 | WONT | Won''t Perform | 在 Telnet 选项协商中，表示发送此代码的设备要么不愿意执行特定选项，要么现在拒绝继续执行它。|'
- en: '| 253 | DO | Do Perform | In Telnet option negotiation, requests that the other
    device perform a particular option or confirms the expectation that the other
    device will perform that option. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 253 | DO | Do Perform | 在 Telnet 选项协商中，请求其他设备执行特定选项或确认对方执行该选项的期望。|'
- en: '| 254 | DONT | Don''t Perform | In Telnet option negotiation, specifies that
    the other party not perform an option or confirms a device''s expectation that
    the other party not perform an option. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 254 | DONT | Don''t Perform | 在 Telnet 选项协商中，指定对方不执行选项或确认设备对对方不执行选项的期望。|'
- en: '| 255 | IAC | Interpret As Command | Precedes command values 240 through 254
    as described in the preceding descriptions. A pair of IAC bytes in a row represents
    the data value 255. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 255 | IAC | Interpret As Command | 在前面描述中描述的命令值 240 到 254 前面。连续的两个 IAC 字节表示数据值
    255。|'
- en: Perhaps ironically, the Telnet commands are not used as much today as they were
    when Telnet was in its early days, because many of the compatibility issues that
    we discussed earlier no longer exist. ASCII has become the standard character
    set of the computing world, so many of the functions such as aborting output or
    interrupting a process no longer require the use of Telnet commands. They are
    still widely used, however, for internal Telnet operations such as option negotiation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也许具有讽刺意味的是，Telnet 命令不像在 Telnet 早期那样被广泛使用，因为许多我们之前讨论的兼容性问题现在不再存在。ASCII 已成为计算世界的标准字符集，因此许多如终止输出或中断进程的功能不再需要使用
    Telnet 命令。然而，它们仍然被广泛用于内部 Telnet 操作，如选项协商。
- en: Telnet Interrupt Handling
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet 中断处理
- en: All the bytes of data sent from a Telnet client to a server are received in
    the order that they were sent, and vice versa. This is the way that we expect
    an application to operate. In fact, ensuring that data is not received out of
    order is one of the jobs that we assume of the reliable transport protocol TCP,
    over which Telnet runs. However, this can cause a problem for Telnet because of
    the way Telnet sends both data and commands over the same connection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Telnet 客户端发送到服务器的所有数据字节都是按照发送的顺序接收的，反之亦然。这是我们期望应用程序运行的方式。实际上，确保数据不会乱序接收是我们对可靠传输协议
    TCP（Telnet 在其上运行）所承担的一项工作。然而，由于 Telnet 以相同的方式在同一个连接上发送数据和命令，这可能会给 Telnet 带来问题。
- en: The most important case where this issue arises is when a user needs to interrupt
    a process. Suppose that you are using Telnet to run an interactive program that
    takes user input, processes it, and then produces output. You are merrily typing
    away when you notice that you haven't seen any output from the program for a while.
    It has apparently hung up due to a programming error or other glitch.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题最典型的例子是当用户需要中断一个进程时出现。假设你正在使用 Telnet 运行一个需要用户输入、处理输入并产生输出的交互式程序。当你愉快地输入时，你注意到已经有一段时间没有看到程序输出。这显然是由于编程错误或其他故障而挂起了。
- en: If you were using the program on a directly connected terminal, you would simply
    use the key or keystroke command appropriate to that terminal to interrupt or
    abort the process and restart it. Instead, you are using Telnet, so you enter
    the appropriate keystroke, which gets converted to the special Telnet Interrupt
    Process command code (byte value 244, preceded by the Telnet Interpret As Command
    code, 255).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个直接连接的终端上使用该程序，你只需使用适合该终端的键或按键命令来中断或终止进程，然后重新启动它。相反，你正在使用 Telnet，所以你输入适当的按键，它被转换成特殊的
    Telnet 中断进程命令代码（字节值为 244，前面是 Telnet 解释为命令代码，255）。
- en: Since Telnet uses only a single stream for commands and data, that code is placed
    into the TCP data stream to be sent over to the Telnet server. Since you were
    entering data for a while, that Telnet Interrupt Process code will be sitting
    behind a bunch of regular data bytes. Now the remote process has stopped reading
    this data, which means the TCP receive buffer on the server will start to fill
    up. The Interrupt Process command will thus remain stuck in the buffer, waiting
    to be read. In fact, if the number of data bytes in front of the command is high
    enough, the TCP buffer on the server may fill entirely, causing the server to
    close the client's TCP send window. This means the Interrupt Process command will
    wait in the client's outgoing TCP queue and *never* be sent to the remote host!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Telnet 只使用单个流来传输命令和数据，因此该代码被放入 TCP 数据流中，以便发送到 Telnet 服务器。由于你输入了一段时间的数据，Telnet
    中断进程代码将位于大量常规数据字节之后。现在远程进程已经停止读取这些数据，这意味着服务器的 TCP 接收缓冲区将开始填满。因此，中断进程命令将卡在缓冲区中，等待被读取。实际上，如果命令前面的数据字节足够多，服务器上的
    TCP 缓冲区可能会完全填满，导致服务器关闭客户端的 TCP 发送窗口。这意味着中断进程命令将等待在客户端的出站 TCP 队列中，并且*永远不会*发送到远程主机！
- en: What we need here is some way to be able to flag the Interrupt Process command,
    so that it can be sent to the remote host regardless of the number of data bytes
    outstanding in front of it. If you've already perused the chapters devoted to
    TCP, you may be thinking that you have already read about a feature of that protocol
    that seems ideally suited for this exact problem, and you would be correct! The
    TCP urgent function (described in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE
    FORMATTING AND DATA TRANSFER")) allows an important piece of data to be marked
    so that it is given priority over regular data, a process sometimes called *out-of-band
    signaling* (because the signal is outside the normal data stream). Telnet uses
    this feature of TCP to define what it calls the *synch function*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法，能够标记中断进程命令，以便无论其前面的数据字节数量如何，都可以发送到远程主机。如果你已经阅读了关于 TCP 的章节，你可能认为你已经阅读了关于该协议的一个特性，这个特性似乎非常适合这个问题，而且你是对的！TCP
    紧急功能（在第 48 章[Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA
    TRANSFER")中描述）允许重要数据被标记，以便它比常规数据具有优先级，这个过程有时被称为*带外信号*（因为信号在正常数据流之外）。Telnet 使用
    TCP 的这个特性来定义它所说的*同步功能*。
- en: When needed, the synch function is invoked by the client sending the special
    Telnet Data Mark (DM) protocol command, while instructing its TCP layer to mark
    that data as urgent. The URG bit in the TCP segment carrying this command causes
    it to bypass TCP's normal flow control mechanism so it is sent over to the remote
    host. The Telnet server software, seeing the synch in the data stream, searches
    through all of the data in its buffer looking only for Telnet control commands
    such as Interrupt Process, Abort Output, and Are You There. These commands are
    then executed immediately. The server continues to search for important commands
    up to the point where the Data Mark command is seen. All intervening data is discarded;
    it will need to be retransmitted. After the Data Mark is processed, the server
    returns to normal operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，客户端通过发送特殊的 Telnet 数据标记（DM）协议命令来调用同步功能，同时指示其 TCP 层将该数据标记为紧急。携带此命令的 TCP 段中的
    URG 位使其绕过 TCP 的正常流量控制机制，从而将其发送到远程主机。Telnet 服务器软件看到数据流中的同步，在其缓冲区中的所有数据中搜索，只寻找 Telnet
    控制命令，如中断进程、中止输出和你在吗。然后立即执行这些命令。服务器继续搜索重要命令，直到看到数据标记命令为止。所有中间数据都被丢弃；它需要重新传输。在处理完数据标记后，服务器返回到正常操作。
- en: It is also possible for the server to use the synch function in communication
    with the user on the client device. For example, if the user sends the Abort Output
    command to the server, she is telling the server to discard all remaining output
    from the current process. The server will stop sending that output, and can also
    use the synch function to clear all outstanding data that is waiting in buffers
    to be sent to the client machine (since it causes data to be discarded).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器也可以在与其客户端设备上的用户通信时使用同步功能。例如，如果用户向服务器发送中止输出命令，她是在告诉服务器丢弃当前进程的所有剩余输出。服务器将停止发送该输出，并可以使用同步功能清除所有等待发送到客户端机器的未处理数据（因为它会导致数据被丢弃）。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Telnet protocol commands are sent in the same stream with user
    data, which means a problem with the remote host that stops the flow of data might
    cause user commands to become backed up and never received by the host. Since
    this may include commands issued by the user to try to fix the problem on the
    host, this can be a serious problem. To alleviate this situation, Telnet includes
    the *synch function*, which uses TCP''s urgent data transmission feature to force
    the receipt of essential commands, even when regular data is not being processed.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet 协议命令与用户数据在同一数据流中发送，这意味着远程主机的问题可能会停止数据流，导致用户命令积压并且主机无法接收。由于这可能包括用户尝试解决主机问题的命令，这可能会成为一个严重的问题。为了缓解这种情况，Telnet
    包含了 *同步功能*，它使用 TCP 的紧急数据传输功能强制接收关键命令，即使常规数据没有被处理。'
- en: Telnet Options and Option Negotiation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Telnet 选项和选项协商
- en: 'The basic Telnet NVT specification solves the problem of compatibility between
    different terminal and computer types by defining a common representation for
    data and commands that every Telnet client and server uses. The price for this
    universal representation, however, is very high: All of the advanced or special
    capabilities of terminals and hosts are stripped off. The result is a language
    that everyone can speak but that is not capable of much more than basic conversation.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Telnet NVT 规范通过定义每个 Telnet 客户端和服务器使用的通用数据表示和命令，解决了不同终端和计算机类型之间的兼容性问题。然而，这种通用表示的代价非常高：所有终端和主机的先进或特殊功能都被剥离。结果是，虽然每个人都能使用这种语言，但它并不能进行比基本对话更多的功能。
- en: The creators of Telnet recognized that, while it was important to define NVT
    as a common base to ensure cross-device compatibility, it was also essential that
    some means be provided by which clients and servers could agree to use more advanced
    means of communication. They defined a set of *Telnet options* and a mechanism
    by which a Telnet client and server can *negotiate* which options they want to
    use.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 的创造者认识到，虽然定义 NVT 作为确保跨设备兼容性的共同基础很重要，但同时也必须提供一种方式，让客户端和服务器能够同意使用更先进的通信方式。他们定义了一套
    *Telnet 选项* 和一种机制，通过这种机制，Telnet 客户端和服务器可以 *协商* 他们想要使用的选项。
- en: Most Telnet options are used for improving the efficiency of how data is transferred
    between devices. For example, by default, the NVT assumes half-duplex operation
    with each device, requiring it to use the Go Ahead command after each transmission.
    However, virtually all hardware now supports full-duplex communication, so devices
    will usually agree to use the Suppress Go Ahead option to eliminate the need to
    send this character. Similarly, it is possible for devices to negotiate the sending
    of 8-bit binary data instead of the standard 7-bit ASCII of the Telnet NVT.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Telnet选项用于提高设备之间数据传输的效率。例如，默认情况下，NVT假设每个设备使用半双工操作，需要在每次传输后使用Go Ahead命令。然而，现在几乎所有硬件都支持全双工通信，因此设备通常会同意使用抑制Go
    Ahead选项来消除发送此字符的需要。同样，设备可以协商发送8位二进制数据而不是Telnet NVT的标准7位ASCII码。
- en: The process of Telnet option negotiation is described in the main Telnet standard
    document, RFC 854, as well as a companion document, RFC 855, "Telnet Option Specifications."
    The options themselves are described in a separate set of Internet standards.
    Several of these were published at the same time as RFCs 854 and 855; others were
    defined earlier as part of previous versions of Telnet; and still others have
    been added over the years. There are now several dozen different Telnet options
    in existence. A master list is maintained by Internet Assigned Numbers Authority
    (IANA), just as it maintains other TCP/IP parameters. An up-to-date listing of
    all Telnet options can be found on the IANA website at [http://www.iana.org/assignments/telnet-options/](http://www.iana.org/assignments/telnet-options/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet选项协商的过程在主Telnet标准文档RFC 854中以及配套文档RFC 855，“Telnet选项规范”中进行了描述。这些选项本身在单独的因特网标准集中进行了描述。其中一些与RFC
    854和RFC 855同时发布；其他一些作为Telnet先前版本的组成部分在较早时定义；还有一些在多年后被添加。现在存在几十种不同的Telnet选项。互联网数字分配机构（IANA）维护了一个主列表，就像它维护其他TCP/IP参数一样。所有Telnet选项的最新列表可以在IANA网站上找到，网址为[http://www.iana.org/assignments/telnet-options/](http://www.iana.org/assignments/telnet-options/)。
- en: Common Telnet Options
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见Telnet选项
- en: Each Telnet option is identified using a decimal byte code with a possible value
    of 0 to 254\. The value 255 is reserved to extend the option list should more
    than 255 options ever be needed. Each option also has a text code string associated
    with it, which is often used as a symbol in place of the code number in both protocol
    discussions and diagnostic output. [Table 87-3](ch87.html#common_telnet_options-id001
    "Table 87-3. Common Telnet Options") lists some of the more interesting Telnet
    options and provides a brief description of each.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Telnet选项都使用一个十进制字节码来标识，其可能值为0到254。值255保留用于扩展选项列表，以防需要超过255个选项。每个选项还与一个文本代码字符串相关联，这通常在协议讨论和诊断输出中用作代码号的符号。[表 87-3](ch87.html#common_telnet_options-id001
    "表 87-3. 常见Telnet选项")列出了一些更有趣的Telnet选项，并对每个选项提供了简要描述。
- en: Table 87-3. Common Telnet Options
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表 87-3. 常见Telnet选项
- en: '| Option Number | Option Code | Option Name | Description | Defining RFC |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 选项编号 | 选项代码 | 选项名称 | 描述 | 定义RFC |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | TRANSMIT-BINARY | Binary Transmission | Allows devices to send data in
    8-bit binary form instead of 7-bit ASCII. | 856 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 0 | TRANSMIT-BINARY | 二进制传输 | 允许设备以8位二进制形式发送数据，而不是7位ASCII码。 | 856 |'
- en: '| 1 | ECHO | Echo | Allows devices to negotiate any of a variety of different
    echo modes. (When you press a key on a terminal, you also expect to see the character
    you entered appear on the terminal screen as output; this is called echoing the
    input.) | 857 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ECHO | 回显 | 允许设备协商各种不同的回显模式。（当你在一个终端上按下一个键时，你也期望看到你输入的字符作为输出出现在终端屏幕上；这被称为回显输入。）
    | 857 |'
- en: '| 3 | SUPPRESS-GO-AHEAD | Suppress Go Ahead | Allows devices not operating
    in half-duplex mode to no longer need to end transmissions using the Telnet Go
    Ahead command. | 858 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 3 | SUPPRESS-GO-AHEAD | 抑制Go Ahead | 允许不使用半双工模式的设备不再需要使用Telnet Go Ahead命令来结束传输。
    | 858 |'
- en: '| 5 | STATUS | Status | Lets a device request the status of a Telnet option.
    | 859 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 5 | STATUS | 状态 | 允许设备请求Telnet选项的状态。 | 859 |'
- en: '| 6 | TIMING-MARK | Timing Mark | Allows devices to negotiate the insertion
    of a special timing mark into the data stream, which is used for synchronization.
    | 860 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 6 | TIMING-MARK | 定时标记 | 允许设备协商在数据流中插入一个特殊的定时标记，用于同步。 | 860 |'
- en: '| 10 | NAOCRD | Output Carriage Return Disposition | Lets the devices negotiate
    how carriage returns will be handled. | 652 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 10 | NAOCRD | 输出回车符处理 | 允许设备协商如何处理回车符。 | 652 |'
- en: '| 11 | NAOHTS | Output Horizontal Tab Stops | Allows the devices to determine
    what horizontal tab stop positions will be used for output display. | 653 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 11 | NAOHTS | 输出水平制表符位置 | 允许设备确定用于输出显示的水平制表符位置。 | 653 |'
- en: '| 12 | NAOHTD | Output Horizontal Tab Stop Disposition | Allows the devices
    to negotiate how horizontal tabs will be handled and by which end of the connection.
    | 654 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 12 | NAOHTD | 输出水平制表符处理 | 允许设备协商如何处理水平制表符，以及通过连接的哪一端处理。 | 654 |'
- en: '| 13 | NAOFFD | Output Form Feed Disposition | Allows the devices to negotiate
    how form feed characters will be handled. | 655 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 13 | NAOFFD | 输出换页符处理 | 允许设备协商如何处理换页符字符。 | 655 |'
- en: '| 14 | NAOVTS | Output Vertical Tab Stops | Used to determine what vertical
    tab stop positions will be used for output display. | 656 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 14 | NAOVTS | 输出垂直制表符位置 | 用于确定用于输出显示的垂直制表符位置。 | 656 |'
- en: '| 15 | NAOVTD | Output Vertical Tab Disposition | Lets devices negotiate the
    disposition of vertical tab stops. | 657 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 15 | NAOVTD | 输出垂直制表符处理 | 允许设备协商垂直制表符的位置处理。 | 657 |'
- en: '| 16 | NAOLFD | Output Line Feed Disposition | Allows devices to decide how
    line feed characters should be handled. | 658 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 16 | NAOLFD | 输出换行符处理 | 允许设备决定如何处理换行符字符。 | 658 |'
- en: '| 17 | EXTEND-ASCII | Extended ASCII | Lets devices agree to use extended ASCII
    for transmissions and negotiate how it will be used. | 698 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 17 | EXTEND-ASCII | 扩展 ASCII | 允许设备同意使用扩展 ASCII 进行传输，并协商其使用方式。 | 698 |'
- en: '| 24 | TERMINAL-TYPE | Terminal Type | Allows the client and server to negotiate
    the use of a specific terminal type. If they agree, this allows the output from
    the server to be ideally customized to the needs of the particular terminal the
    user is using. | 1091 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 24 | TERMINAL-TYPE | 终端类型 | 允许客户端和服务器协商使用特定的终端类型。如果他们达成一致，这将允许服务器的输出根据用户使用的特定终端的需求进行理想化的定制。
    | 1091 |'
- en: '| 31 | NAWS | Negotiate About Window Size | Permits communication of the size
    of the terminal window. | 1073 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 31 | NAWS | 协商窗口大小 | 允许通信终端窗口的大小。 | 1073 |'
- en: '| 32 | TERMINAL-SPEED | Terminal Speed | Allows devices to report on the current
    terminal speed. | 1079 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 32 | TERMINAL-SPEED | 终端速度 | 允许设备报告当前的终端速度。 | 1079 |'
- en: '| 33 | TOGGLE-FLOW-CONTROL | Remote Flow Control | Allows flow control between
    the client and the server to be enabled and disabled. | 1372 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 33 | TOGGLE-FLOW-CONTROL | 远程流控制 | 允许在客户端和服务器之间启用和禁用流控制。 | 1372 |'
- en: '| 34 | LINEMODE | Line Mode | Allows the client to send data one line at a
    time instead of one character at a time. This improves performance by replacing
    a large number of tiny TCP transmissions with a smaller number of larger ones.
    | 1184 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 34 | LINEMODE | 行模式 | 允许客户端一次发送一行数据而不是一个字符，通过将大量的小型 TCP 传输替换为少量的大型传输来提高性能。
    | 1184 |'
- en: '| 37 | AUTHENTICATION | Authentication | Lets the client and server negotiate
    a method of authentication to secure connections. | 1416 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 37 | AUTHENTICATION | 认证 | 允许客户端和服务器协商一种认证方法以安全连接。 | 1416 |'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Telnet NVT specification ensures that all devices using
    Telnet can talk to each other, but accomplishes this communication at the lowest
    level. To allow the use of more sophisticated formats and services, Telnet defines
    a number of *options*. If a client and server both implement a particular option,
    they can enable its use through a process of *negotiation*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Telnet NVT 规范确保所有使用 Telnet 的设备都能相互通信，但这是在最低级别上完成的通信。为了允许使用更复杂的格式和服务，Telnet
    定义了一系列 *选项*。如果客户端和服务器都实现了特定的选项，它们可以通过 *协商* 过程来启用其使用。'
- en: Telnet Option Negotiation
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Telnet 选项协商
- en: The first stage in Telnet option negotiation is for the client and server to
    decide whether they want to enable a particular option. One of the aspects of
    Telnet's symmetry of operation is that either device may choose to initiate the
    use of an option. The initiating device may either specify that it wants to start
    using an option or that it wants the other device to start using it. The responding
    device may agree or disagree. An option can be enabled only if both devices agree
    to its use.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 选项协商的第一阶段是客户端和服务器决定是否启用特定的选项。Telnet 操作对称性的一个方面是，任何设备都可以选择启动一个选项的使用。启动设备可以指定它想要开始使用一个选项，或者它想要其他设备开始使用它。响应设备可以同意或不同意。只有当两个设备都同意使用该选项时，才能启用选项。
- en: 'This negotiation is performed using four Telnet protocol commands: WILL, WONT,
    DO, and DONT.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此协商是通过四个 Telnet 协议命令来执行的：WILL、WONT、DO 和 DONT。
- en: 'To specify that it wants to start using an option, the initiator sends the
    WILL command to the other device. There are two possible replies by the responding
    device:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定它想要开始使用一个选项，启动器将 WILL 命令发送到其他设备。响应设备可能有两种可能的回复：
- en: '**DO** Sent to indicate agreement that the initiator should use the option;
    it is then considered enabled.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**DO** 发送以表示同意启动器应使用该选项；然后它被认为是启用的。'
- en: '**DONT** Sent to specify that the initiator must not use the option.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**DONT** 发送以指定启动器不得使用该选项。'
- en: 'If the initiator wants the other device to start using an option, it sends
    the DO command. That device may respond in two ways:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动器希望其他设备开始使用一个选项，它将发送 DO 命令。该设备可能会以两种方式响应：
- en: '**WILL** Sent to specify that the responding device will agree to use the option;
    the option is enabled.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**WILL** 发送以指定响应设备将同意使用该选项；选项被启用。'
- en: '**WONT** Sent to tell the initiator that the responder will not use the option
    requested.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**WONT** 发送以告知启动器，响应器将不会使用请求的选项。'
- en: The symmetry of Telnet and the fact that both DO and WILL can be used either
    to initiate a negotiation or respond to one make Telnet's option negotiation potentially
    complicated. Since either device can initiate negotiation of an option at any
    time, this could result in acknowledgment loops if both devices were to try to
    enable an option simultaneously or each kept responding to the other's replies.
    For this reason, the Telnet standard specifies restrictions on when the WILL and
    DO commands are used. One is that a device may send a negotiation command only
    to request a change in the status of an option; it cannot send DO or WILL just
    to confirm or reinforce the current state of the option. Another is that a device
    receiving a request to start using an option it is already using should not acknowledge
    it using DO or WILL.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet 的对称性以及 DO 和 WILL 都可以用来启动协商或响应协商的事实，使得 Telnet 的选项协商可能变得复杂。由于任何设备都可以在任何时候启动选项的协商，如果两个设备同时尝试启用一个选项或各自持续响应对方的回复，这可能会导致确认循环。因此，Telnet
    标准指定了 WHEN 使用 WILL 和 DO 命令的限制。一个是设备只能发送协商命令以请求更改选项的状态；它不能仅为了确认或加强当前选项的状态而发送 DO
    或 WILL。另一个是，当设备收到请求开始使用它已经使用的选项时，它不应使用 DO 或 WILL 进行确认。
- en: 'Since an option may be activated only if both devices agree to use it, either
    may disable the use of an option at any time by sending one of these commands:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个选项只能在两个设备都同意使用它的情况下被激活，因此任何设备都可以在任何时候通过发送这些命令之一来禁用选项的使用：
- en: '**WONT** Sent by a device to indicate that it is going to stop using an option.
    The other device must respond with DONT as a confirmation.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**WONT** 由设备发送，表示它将停止使用一个选项。其他设备必须以 DONT 作为确认进行响应。'
- en: '**DONT** Sent by a device to indicate that it wants the other device to stop
    using an option. The other device must respond with WONT.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**DONT** 由设备发送，表示它希望其他设备停止使用一个选项。其他设备必须以 WONT 响应。'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Either device may choose to negotiate the use of a Telnet option.
    The initiator uses the WILL command to specify that it wants to start using a
    particular option; if the other device agrees, it responds with DO; otherwise,
    it sends DONT. Alternatively, the initiator can use the DO command to indicate
    that it wants the other device to start using an option; that device responds
    with WILL if it agrees to do so or WONT if it does not. Either device may disable
    the use of an option at any time by sending the other a WONT or DONT command.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 任何设备都可以选择协商使用Telnet选项。发起者使用WILL命令来指定它想要开始使用特定选项；如果另一设备同意，它将响应DO；否则，它发送DONT。或者，发起者可以使用DO命令来指示它希望另一设备开始使用选项；如果该设备同意这样做，它将响应WILL，如果不同意，则响应WONT。任何设备都可以通过发送WONT或DONT命令在任何时候禁用选项的使用。'
- en: Option Subnegotiation
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项子协商
- en: All of the DO/DONT/WILL/WONT negotiation just described serves only to enable
    or disable an option. Some options, such as the binary transmission option (TRANSMIT-BINARY),
    are either only off or on; in which case, this option negotiation is sufficient.
    Other options require that after they are enabled, the client and server exchange
    parameters to control how the option works. For example, the TERMINAL-TYPE option
    requires some way for the client to send the server the name of the terminal.
    Telnet allows the client and server to send an arbitrary amount of data related
    to the option using a process called *option subnegotiation*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所述的DO/DONT/WILL/WONT协商仅用于启用或禁用选项。某些选项，如二进制传输选项（TRANSMIT-BINARY），要么是开启要么是关闭；在这种情况下，此选项协商就足够了。其他选项在启用后需要客户端和服务器交换参数以控制选项的工作方式。例如，TERMINAL-TYPE选项需要客户端以某种方式向服务器发送终端名称。Telnet允许客户端和服务器通过称为*选项子协商*的过程发送与选项相关的任意数量的数据。
- en: A device begins the subnegotiation process by sending a special sequence of
    Telnet protocol commands and data. First, the device sends the SB (subnegotiation)
    command, followed by the option number and parameters as defined by the particular
    option, and then ending the subnegotiation data by sending the SE (subnegotiation
    end) command. Both SB and SE must be preceded by the Interpret As Command (IAC)
    command byte.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通过发送一系列特殊的Telnet协议命令和数据开始子协商过程。首先，设备发送SB（子协商）命令，然后是特定选项定义的选项号和参数，最后通过发送SE（子协商结束）命令结束子协商数据。SB和SE都必须在Interpret
    As Command（IAC）命令字节之前。
- en: 'Let''s take the terminal type negotiation as an example. Suppose the server
    supports this option and would like the client to use it. The server starts option
    negotiation by sending the DO command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以终端类型协商为例。假设服务器支持此选项并希望客户端使用它。服务器通过发送DO命令开始选项协商：
- en: '[PRE1]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assuming the client agrees, it will respond with the WILL command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设客户端同意，它将使用WILL命令响应：
- en: '[PRE2]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the terminal type option is in effect, but the server still doesn''t know
    which terminal the client is using. It can prompt the client to provide that information
    by sending this command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终端类型选项已生效，但服务器仍然不知道客户端使用的是哪种终端。它可以通过发送此命令来提示客户端提供该信息：
- en: '[PRE3]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The client receiving this option subnegotiation command will respond with the
    following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接收此选项子协商命令的客户端将使用以下方式响应：
- en: '[PRE4]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The WILL and DO commands only turn on a Telnet option that
    a client and server agree to use. In some cases, an option requires additional
    information to be sent between the client and server device for it to function
    properly. This is accomplished through a process of *option subnegotiation*. Either
    device sends the other a set of data relevant to the option, bracketed by the
    SB (subnegotiation) and SE (subnegotiation end) Telnet protocol commands.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** WILL和DO命令仅用于开启客户端和服务器同意使用的Telnet选项。在某些情况下，选项需要在客户端和服务器设备之间发送额外的信息才能正常工作。这是通过一个称为*选项子协商*的过程来实现的。任何设备都可以通过发送包含SB（子协商）和SE（子协商结束）Telnet协议命令的数据集来向另一设备发送与选项相关的数据。'
- en: Berkeley Remote (r) Commands
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伯克利远程（r）命令
- en: TCP/IP has achieved success in large part due to its universality—it has been
    implemented on virtually every major computing platform. While the suite is thus
    not specific to any operating system, there is no denying that its history is
    closely tied to a particular one—UNIX. Most of the computers on the early Internet
    used UNIX, and the development of TCP/IP has paralleled that of UNIX in a number
    of respects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP之所以取得成功，在很大程度上是由于其通用性——它几乎在所有主要的计算平台上都得到了实现。虽然该套件因此并非针对任何特定的操作系统，但不可否认的是，它的历史与UNIX紧密相连。早期互联网上的大多数计算机都使用UNIX，TCP/IP的发展在许多方面与UNIX的发展并行。
- en: One of the most important organizations involved in the development of UNIX,
    and thus TCP/IP indirectly, was the University of California at Berkeley (UCB).
    The USB-developed well-known *Berkeley Software Distribution (BSD)* UNIX has been
    in widespread use for over 20 years. They also developed a set of commands for
    BSD UNIX to facilitate various remote operation functions over a TCP/IP internetwork.
    Each of these programs begins with the letter *r* (for remote), so they have come
    to be known as both the *Berkeley remote commands* (or utilities) and also simply
    the *r commands*. Since their initial creation, they have been adopted for most
    variations of UNIX and some other operating systems as well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX开发中起着重要作用的组织之一，因此间接地影响了TCP/IP的发展，是加利福尼亚大学伯克利分校（UCB）。USB开发的知名*伯克利软件发行版（BSD）*
    UNIX已经广泛使用超过20年。他们还为BSD UNIX开发了一套命令，以方便在TCP/IP互联网上进行各种远程操作功能。这些程序都以字母*r*（代表远程）开头，因此它们被称为*伯克利远程命令*（或实用程序）以及简单地称为*r命令*。自从它们最初创建以来，它们已经被大多数UNIX变体和一些其他操作系统所采用。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *This section will probably make much more sense
    to those who have some understanding of the UNIX operating system than those who
    do not.*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *这一部分对于那些对UNIX操作系统有一定了解的人来说可能更容易理解，而对于那些没有了解的人来说可能就不那么容易理解了*。'
- en: Berkeley Remote Login (rlogin)
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伯克利远程登录（rlogin）
- en: The head of the Berkeley remote protocol family is the remote login command,
    `rlogin`. As the name clearly implies, the purpose of this program is to allow
    a user on a UNIX host to log in to another host over a TCP/IP internetwork. Since
    Telnet is also often used for remote login, `rlogin` and Telnet are sometimes
    considered alternatives to each other for TCP/IP remote login. While they can
    be used in a similar way, they are quite different in a few respects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 伯克利远程协议家族的头部是远程登录命令，`rlogin`。正如其名明显暗示的那样，该程序的目的允许UNIX主机上的用户通过TCP/IP互联网登录到另一台主机。由于Telnet也经常用于远程登录，因此`rlogin`和Telnet有时被认为是TCP/IP远程登录的替代品。虽然它们可以以类似的方式使用，但在一些方面它们是相当不同的。
- en: From a conceptual standpoint, Telnet is designed as a protocol to enable terminal/host
    communication. As I mentioned in the Telnet overview earlier in this chapter,
    that protocol was not designed specifically for the purpose of remote login. In
    contrast, `rlogin` was intended for that specific purpose, and this is reflected
    in its operation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Telnet被设计成一种协议，以实现终端/主机通信。正如我在本章前面的Telnet概述中提到的，该协议并非专门为远程登录而设计。相比之下，`rlogin`旨在实现这一特定目的，这在它的操作中得到了体现。
- en: 'The protocol requires `rlogin` server software to be running on the host that
    is going to allow remote access; it is usually called `rlogind` (for `rlogin`
    *daemon*, the latter word being the standard UNIX term for a background server
    process). The server listens for incoming connection requests on TCP port 513\.
    Users who want to remotely log in to the server run the `rlogin` command on their
    local host and specify the name of the server. The client makes a TCP connection
    to the server and then sends to the server a string containing the following information:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议要求在将要允许远程访问的主机上运行`rlogin`服务器软件；它通常被称为`rlogind`（对于`rlogin` *守护进程*，后一词是标准UNIX术语，指后台服务器进程）。服务器监听TCP端口513上的传入连接请求。想要远程登录到服务器的用户在其本地主机上运行`rlogin`命令并指定服务器名称。客户端与服务器建立TCP连接，然后向服务器发送包含以下信息的字符串：
- en: The login name of the user on the client machine
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户机上的用户登录名
- en: The login name that the user wants to use on the server (which is often the
    same as the user's login name on the client, but not always)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户希望在服务器上使用的登录名（这通常与客户端上的用户登录名相同，但并不总是如此）
- en: Control information such as the type and speed of the terminal
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制信息，例如终端的类型和速度
- en: The server processes this information and begins the login process. It will
    normally prompt the user for a password to log in to the remote host. Assuming
    the password is correct, the user will be logged in to the remote host and can
    use it as if the user were locally connected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器处理这些信息并开始登录过程。它通常会提示用户输入密码以登录到远程主机。假设密码正确，用户将登录到远程主机，并可以像本地连接的用户一样使用它。
- en: 'From a practical standpoint, the `rlogin` command is much simpler than Telnet;
    it does not support Telnet''s full command structure, nor capabilities such as
    option negotiation. It does include a small set of commands, however. The client
    is able to send to the server one key piece of information: the current size of
    the terminal window in use. The server is able to tell the client to turn on or
    off flow control, request that the client send it the current window size, or
    ask the client to flush pending output that the server has sent, up to a certain
    point in the data stream.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际角度来看，`rlogin` 命令比 Telnet 简单得多；它不支持 Telnet 的完整命令结构，也不支持选项协商等能力。然而，它确实包括一组小命令。客户端能够向服务器发送一条关键信息：当前使用的终端窗口的大小。服务器能够通知客户端开启或关闭流量控制，请求客户端发送当前窗口大小，或者要求客户端清除服务器已发送的挂起输出，直到数据流中的某个特定点。
- en: Some organizations have many different UNIX hosts that are used every day, and
    needing to constantly type passwords when using `rlogin` can be somewhat of a
    chore. On these systems, it is possible for administrators to set up control files
    that specify combinations of host names, user names, and passwords. If set up
    correctly, this enables an authorized user to use `rlogin` to remotely access
    a host automatically, without needing to enter either a login name or password.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织每天使用许多不同的 UNIX 主机，使用 `rlogin` 时需要不断输入密码可能有些繁琐。在这些系统中，管理员可以设置控制文件，指定主机名、用户名和密码的组合。如果设置正确，这允许授权用户使用
    `rlogin` 自动远程访问主机，而无需输入登录名或密码。
- en: As originally designed, `rlogin` is a classic example of a protocol from the
    early days of TCP/IP, since it emphasizes simplicity and usability over security.
    This is especially true of the automated login process just described. The original
    schemes used by `rlogin` for authentication are considered inadequate for modern
    TCP/IP internetworks, especially those connected to the Internet. Later versions
    of `rlogin` have been enhanced with more secure authorization methods. There is
    also a newer program called `slogin` (for *secure login*) that uses stronger authentication
    and encryption, which is intended to replace `rlogin` on newer systems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如最初设计的那样，`rlogin` 是 TCP/IP 早期协议的一个经典例子，因为它强调的是简洁性和可用性而非安全性。这一点在前面描述的自动登录过程中尤为明显。`rlogin`
    最初用于身份验证的方案被认为不足以满足现代 TCP/IP 互连网络，尤其是连接到互联网的网络。`rlogin` 的后续版本增加了更安全的授权方法。还有一个名为
    `slogin`（代表 *secure login*）的新程序，它使用更强的身份验证和加密，旨在在新系统上取代 `rlogin`。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Berkeley remote, or *r*, commands facilitate remote operations
    between UNIX hosts on a TCP/IP internetwork. The base command of the family is
    the *remote login* command, `rlogin`, which allows a device on one host to access
    and use another as if it were locally connected to it. rlogin is often used as
    an alternative to Telnet. It is simpler than Telnet, both conceptually and practically.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 伯克利远程，或 *r* 命令，简化了 TCP/IP 互连网络中 UNIX 主机之间的远程操作。这个系列的基本命令是 *远程登录* 命令，`rlogin`，它允许一个主机上的设备访问并使用另一个主机，就像它本地连接到它一样。`rlogin`
    常常被用作 Telnet 的替代品。在概念上和实际操作上，它都比 Telnet 简单。'
- en: Berkeley Remote Shell (rsh)
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伯克利远程壳（rsh）
- en: A user would normally use `rlogin` when he needs to log in to a server to perform
    a number of tasks. There are some situations, however, where a user needs to only
    enter one command on a remote host. With `rlogin`, the user would need to log
    in to the host, execute the command, and then log back out again. This isn't exactly
    an earth-shattering amount of inconvenience, especially when the correct configuration
    files are set up to allow automatic login. Over the course of time, however, all
    the extra logging in and out can become tedious. As a convenience, a variation
    of `rlogin`, called `rsh` (for *remote shell*), allows a user to access a remote
    host and execute a single command on it without requiring the login and logout
    steps.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要登录到服务器执行多项任务时，通常会使用 `rlogin`。然而，在某些情况下，用户只需要在远程主机上输入一条命令。使用 `rlogin`，用户需要登录到主机，执行命令，然后再次登出。这并不是一个巨大的不便，尤其是当正确配置了允许自动登录的配置文件时。然而，随着时间的推移，所有额外的登录和登出步骤都可能变得繁琐。为了方便起见，`rlogin`
    的一个变体，称为 `rsh`（代表 *远程 shell*），允许用户访问远程主机并在其上执行单个命令，而无需进行登录和登出步骤。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shell *is the standard term used in UNIX to refer to the user interface that
    accepts commands from the user and displays output on the screen*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 是 UNIX 中用来指代接受用户命令并在屏幕上显示输出的用户界面的标准术语。
- en: The `rsh` command is based on `rlogin` and works in much the same way, except
    that it is oriented around executing a command rather than establishing a persistent
    login session. The server process on the remote host is usually called `rshd`
    (for *remote shell daemon*) and listens for incoming `rsh` requests. When one
    is received, the user is logged in through the same mechanism as `rlogin`. The
    command runs on the remote host, and then the user is automatically logged out.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsh` 命令基于 `rlogin` 并以类似的方式工作，但它围绕执行命令而不是建立持久的登录会话。远程主机上的服务器进程通常称为 `rshd`（代表
    *远程 shell 守护进程*）并监听传入的 `rsh` 请求。当收到请求时，用户将通过与 `rlogin` 相同的机制登录。命令在远程主机上运行，然后用户会自动登出。'
- en: '`rsh` is most useful when automatic login is employed, so that the program
    can be run without the need for the user to enter a login name or password. In
    that case, it is possible to have programs use `rsh` to automatically run commands
    on remote hosts without the need for human intervention, which opens up a number
    of possibilities for UNIX users. The normal UNIX user interface concepts of *standard
    input (stdin), standard output (stdout), and standard error (stderr)* also apply
    to `rsh`, so you can use it to execute a remote command and redirect the output
    to a local file. For example, the following command would let a user get a listing
    of his home directory on the host server and store it in the local file named
    remotelist:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自动登录时，`rsh` 最有用，这样程序就可以运行而无需用户输入登录名或密码。在这种情况下，程序可以使用 `rsh` 在远程主机上自动运行命令，而无需人工干预，这为
    UNIX 用户打开了多种可能性。正常的 UNIX 用户界面概念，如 *标准输入（stdin）、标准输出（stdout）和标准错误（stderr）* 也适用于
    `rsh`，因此您可以使用它来执行远程命令并将输出重定向到本地文件。例如，以下命令可以让用户获取主机服务器上其主目录的列表并将其存储在名为 remotelist
    的本地文件中：
- en: '[PRE5]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The `rsh` (remote shell) command is similar to the Berkeley
    `rlogin` command, but instead of opening a login session on a remote host, it
    executes a single, user-provided command. `rsh` can be helpful for users who need
    to perform a quick operation on a remote host, and it can also be employed by
    other programs to automate network tasks.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** `rsh`（远程 shell）命令类似于伯克利 `rlogin` 命令，但它不是在远程主机上打开登录会话，而是执行一个用户提供的单个命令。`rsh`
    对于需要快速在远程主机上执行操作的用户非常有用，它还可以被其他程序用来自动化网络任务。'
- en: Since `rsh` is based on `rlogin`, all of the concerns that apply to `rlogin`
    are also relevant here, especially with regard to security. (We really don't want
    unauthorized users running commands on our servers!) As with `rlogin`, newer versions
    of `rsh` support more advanced authentication options than the original software.
    Also, just as `slogin` is a newer, more secure version of `rlogin`, there is a
    program called `ssh` (for *secure shell*) that replaces `rsh` on many systems.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `rsh` 基于 `rlogin`，所有适用于 `rlogin` 的担忧也与此相关，尤其是在安全方面。（我们真的不希望未经授权的用户在我们的服务器上运行命令！）与
    `rlogin` 一样，`rsh` 的新版本支持比原始软件更先进的身份验证选项。同样，正如 `slogin` 是 `rlogin` 的一个更新、更安全的版本一样，有一个名为
    `ssh`（代表 *安全 shell*）的程序在许多系统中取代了 `rsh`。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On some systems, if* `rsh` *is entered without a command specified to execute,
    an interactive remote session is established, exactly as if the* `rlogin` *command
    had been entered instead of* `rsh`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*在某些系统上，如果* `rsh` *没有指定要执行的命令，则会建立交互式远程会话，就像输入了* `rlogin` *命令而不是* `rsh` *一样。'
- en: Other Berkeley Remote Commands
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他伯克利远程命令
- en: The `rlogin` and `rsh` commands are the generic members of the Berkeley *r*
    family of programs that allow remote access to a host. To complement these, the
    developers also defined a small number of specific remote commands. These are
    essentially remote versions of some of the more common UNIX functions. Instead
    of the command being applied to only one system, however, it is used between two
    systems or across all systems on a TCP/IP network.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlogin` 和 `rsh` 命令是伯克利 *r* 程序家族的通用成员，允许远程访问主机。为了补充这些，开发者还定义了一小部分特定的远程命令。这些命令本质上是一些常见
    UNIX 功能的远程版本。然而，命令不是只应用于一个系统，而是在两个系统之间或整个 TCP/IP 网络上的所有系统之间使用。'
- en: 'All of these commands are based on `rlogin` in the same way as `rsh` is. They
    work in the same way, but instead of opening a session or passing a user-specified
    command to the remote host, they execute a particular function. The following
    are the most common of these remote commands:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令都与 `rlogin` 一样基于 `rsh`。它们以相同的方式工作，但不是打开会话或将用户指定的命令传递给远程主机，而是执行特定功能。以下是最常见的这些远程命令：
- en: '**Remote Copy (**`rcp`**)** This is the remote version of the UNIX copy (`cp`)
    command. It allows a file to be copied between the local host and the remote host
    or between two remote hosts. The usual syntax is basically the same as the regular
    `cp` command, but the source and/or destination is specified as being on a remote
    host. The `rcp` command can be used in a manner similar to FTP, but is much simpler
    and less capable. Or, to put it another way, `rcp` is to FTP what `rlogin` is
    to Telnet. (That''s not a perfect analogy, but it''s pretty close.)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程复制（**`rcp`**）** 这是 UNIX 复制 (`cp`) 命令的远程版本。它允许在本地主机和远程主机之间或两个远程主机之间复制文件。通常的语法基本上与常规
    `cp` 命令相同，但源和/或目标被指定为位于远程主机上。`rcp` 命令可以像 FTP 一样使用，但更简单、功能更少。或者换句话说，`rcp` 相对于 FTP，就像
    `rlogin` 相对于 Telnet。这不是一个完美的类比，但非常接近。'
- en: '**Remote Uptime (**`ruptime`**)** The UNIX command `uptime` displays how long
    a computer has been running since it was last booted, along with information related
    to its current load. `ruptime` is the remote version of this command; it displays
    the current status of each machine on the network (up or down), how long each
    up machine has been up since its last boot, and its load statistics.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程运行时间（**`ruptime`**）** UNIX 命令 `uptime` 显示计算机自上次启动以来运行了多长时间，以及与其当前负载相关的信息。`ruptime`
    是此命令的远程版本；它显示网络上每台机器的当前状态（运行或关闭），每台运行机器自上次启动以来运行了多长时间，以及其负载统计信息。'
- en: '**Remote Who (**`rwho`**)** This is the remote version of the `who` command.
    Where `who` shows all the users logged on to the host where it is run, `rwho`
    shows all users logged on to all machines on the network.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程谁（**`rwho`**）** 这是 `who` 命令的远程版本。`who` 命令显示运行其上的主机上所有登录的用户，而 `rwho` 命令显示网络上所有机器上登录的所有用户。'
- en: The `ruptime` and `rwho` commands both rely on the presence of the `rwhod` (for
    *remote who daemon*) running in the background on networked machines. These processes
    routinely share information with each other about host uptime and who is logged
    on to each system, so it can be quickly displayed when either `ruptime` or `rwho`
    is run.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ruptime` 和 `rwho` 命令都依赖于在联网机器上后台运行的 `rwhod`（远程谁守护进程）。这些进程会定期相互共享有关主机运行时间和每个系统登录用户的信息，因此当运行
    `ruptime` 或 `rwho` 时可以快速显示。'
- en: On some operating systems, other remote commands may also be implemented. As
    with `rlogin` and `rsh`, security issues may apply to these commands, and there
    may be efficiency concerns with others (such as `rwho`). For these reasons, on
    many networks, these commands are no longer used.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些操作系统上，还可能实现其他远程命令。与 `rlogin` 和 `rsh` 一样，这些命令可能存在安全问题，而其他命令（如 `rwho`）可能存在效率问题。因此，在许多网络上，这些命令不再使用。
- en: Internet Relay Chat Protocol (IRC)
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网中继聊天协议（IRC）
- en: The primary advantage that electronic mail (email) offers over conventional
    mail is *speed*. Instead of needing to wait for days or weeks for a message to
    be delivered, it usually arrives in minutes or even seconds. This makes email
    far more useful than the regular postal service for most types of information
    transfer. There are some cases, however, where speed of delivery is not sufficient
    to make email an ideal mechanism for communication. One such case is where a *dialogue*
    is required between two parties.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件（email）相对于传统邮件的主要优势是*速度*。不需要等待几天或几周才能将消息送达，它通常在几分钟甚至几秒钟内到达。这使得电子邮件对于大多数类型的信息传输来说比常规邮政服务更有用。然而，在某些情况下，送达速度不足以使电子邮件成为理想的通信机制。其中一种情况是，需要双方进行*对话*。
- en: Consider that even though email may be delivered very quickly, it uses a decoupled
    model of communication. Say that Ellen sends an email to Jane. The message may
    show up in Jane's inbox in a matter of seconds, but Jane may not be around to
    read it at the time it arrives. Jane might not see the message until hours later.
    Then Jane would send a response to Ellen, who might not see it for a while. If
    the subject they are discussing requires several dozen iterations of this sort,
    it could take a very long time before the exchange is completed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到即使电子邮件可能非常快地送达，它也使用了解耦的通信模型。假设Ellen给Jane发送了一封电子邮件。消息可能在几秒钟内出现在Jane的收件箱中，但Jane可能不在那里阅读它。Jane可能要过几个小时才能看到这条消息。然后Jane会向Ellen发送回复，而Ellen可能要过一段时间才能看到。如果他们讨论的主题需要几十次这样的迭代，那么完成交流可能需要很长时间。
- en: In the real world, of course, most of us would never use email for such a conversation,
    preferring instead that high-tech communication device that we call the telephone.
    Many people using computers realized that it would be useful to have a way for
    two or more people to interactively discuss issues in a manner similar to a telephone
    conversation. In the online world, this is commonly called *chatting*, and one
    of the first and most important application protocols designed to implement it
    in TCP/IP was the *Internet Relay Chat (IRC) Protocol*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，当然，我们大多数人永远不会用电子邮件进行这样的对话，而是更倾向于使用我们称之为电话的高科技通信设备。许多使用计算机的人意识到，如果两个人或更多人能够以类似电话对话的方式交互式地讨论问题，那将是有用的。在在线世界中，这通常被称为*聊天*，而第一个也是最重要的应用协议之一，旨在在TCP/IP中实现它，就是*互联网中继聊天（IRC）协议*。
- en: 'Prior to the widespread use of the Internet, people with computers would often
    communicate by dialing in to a bulletin board system (*BBS)* or other proprietary
    service. IRC was originally created by a gentleman from Finland named Jarkko Oikarinen,
    based on his experience with chat applications on BBSes. He wrote the first client
    and server software in 1988\. The protocol was later formally defined in RFC 1459,
    "Internet Relay Chat Protocol," published May 1993\. In April 2000, the IRC standard
    was revised and enhanced with several new extended capabilities, and published
    as a set of four smaller documents: RFCs 2810 through 2813\. Each of these focuses
    on one particular area of IRC functionality.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网广泛使用之前，拥有计算机的人通常会通过拨号进入公告板系统（*BBS*）或其他专有服务进行通信。IRC最初是由一位名叫Jarkko Oikarinen的芬兰人创建的，基于他在BBS上的聊天应用经验。他在1988年编写了第一个客户端和服务器软件。该协议后来在1993年5月正式定义在RFC
    1459，“互联网中继聊天协议”中。2000年4月，IRC标准经过修订和增强，增加了几个新的扩展功能，并作为一套四份较小的文档发布：RFC 2810至RFC
    2813。这些文档中的每一份都专注于IRC功能的一个特定领域。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*RFC 1459 has the experimental RFC status, and the RFC 2810 to 2813 group is
    designated Informational. This makes IRC optional; it does not need to be implemented
    on TCP/IP devices*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*RFC 1459具有实验性RFC状态，而RFC 2810至RFC 2813组被指定为信息性。这使得IRC成为可选的；它不需要在TCP/IP设备上实现*。'
- en: IRC Communication Model and Client/Server Operation
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IRC通信模型和客户端/服务器操作
- en: IRC is an interesting protocol in that it is not based strictly on the standard
    client/server model of TCP/IP protocol operation. *IRC servers* are TCP/IP machines
    that run IRC server software. They are configured with information that allows
    them to establish TCP connections to each other. IRC uses TCP because the connections
    are maintained over a long period of time, and reliable transport of data is required.
    Server connections are used to exchange control information and user data, forming
    a logical *IRC network* at the application level, which allows any server to send
    to any other server, using intermediate servers as conduits. Servers are managed
    by *IRC operators (IRCops)* who have special privileges that allow them to ensure
    that everything runs smoothly on the network.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 是一个有趣的协议，因为它并不严格基于 TCP/IP 协议操作的客户端/服务器模型。*IRC 服务器* 是运行 IRC 服务器软件的 TCP/IP
    机器。它们配置了允许它们相互建立 TCP 连接的信息。IRC 使用 TCP 是因为连接会维持很长时间，并且需要可靠的数据传输。服务器连接用于交换控制信息和用户数据，形成一个在应用层的逻辑
    *IRC 网络*，这使得任何服务器都可以向任何其他服务器发送消息，使用中间服务器作为通道。服务器由 *IRC 运营商 (IRCops)* 管理，他们拥有特殊权限，可以确保网络上的一切运行顺利。
- en: The IRC network forms the backbone of the IRC communication service. A user
    can access the network by running *IRC client* software on any TCP/IP-enabled
    device. The user enters the name of one of the servers on the network and establishes
    a TCP connection to that server. This causes the user to be connected directly
    to one server, and thus, indirectly to all of the others on the network. This
    allows that user to send and receive messages to and from all other users connected
    either to the user's server or other servers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 网络构成了 IRC 通信服务的骨干。用户可以通过在任何 TCP/IP 兼容设备上运行 *IRC 客户端* 软件来访问网络。用户输入网络上的一个服务器名称，并建立与该服务器的
    TCP 连接。这会导致用户直接连接到一个服务器，从而间接连接到网络上的所有其他服务器。这使得用户可以向所有其他用户发送和接收消息，无论他们是否连接到用户的服务器或其他服务器。
- en: Messaging and IRC Channels
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息和 IRC 频道
- en: 'The most common type of communication in IRC is *group messaging*, which is
    accomplished using *IRC channels*. A channel is a virtual meeting place of sorts
    and is also sometimes called a *chat room* (though IRC purists scoff at the use
    of that term). Every IRC network has hundreds or even thousands of different channels,
    each of which is dedicated to a particular type of discussion, ranging from the
    serious to the silly. For example, a group of people interested in talking about
    meteorology could establish a channel called #weather, where they would meet regularly
    to discuss various aspects of climatology and interesting weather events.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '在 IRC 中最常见的通信类型是 *群组消息*，这是通过 *IRC 频道* 实现的。频道是一种虚拟的会议场所，有时也被称为 *聊天室*（尽管 IRC
    纯粹主义者对使用该术语嗤之以鼻）。每个 IRC 网络都有数百甚至数千个不同的频道，每个频道都致力于特定类型的讨论，从严肃到滑稽不等。例如，一群对谈论气象学感兴趣的人可以建立一个名为
    #weather 的频道，他们会在那里定期讨论气候学的各个方面和有趣的天气事件。'
- en: IRC is an inherently text-based protocol (though it is also possible to use
    IRC clients to transfer arbitrary files between users, including images and executable
    programs). To communicate in a channel, all a user needs to do is enter text in
    the appropriate spot in the IRC client program, and then the program automatically
    sends this text to every other member of the channel. The IRC network handles
    the relaying of these messages in real time from the sender's connected server
    to other servers in the network, and then to all user machines on those servers.
    When other users see the first user's message, they can reply with messages of
    their own, which will, in turn, be propagated across the network. Each IRC user
    chooses a nickname (often abbreviated *nick*) that is like a *handle* used for
    communication while connected to the network.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 是一种本质上基于文本的协议（尽管也可以使用 IRC 客户端在用户之间传输任意文件，包括图像和可执行程序）。要在频道中通信，用户只需在 IRC 客户端程序中适当的位置输入文本，然后程序会自动将此文本发送给频道的每一位成员。IRC
    网络实时处理这些消息的转发，从发送者连接的服务器到网络中的其他服务器，然后到那些服务器上的所有用户机器。当其他用户看到第一位用户的消息时，他们可以用自己的消息回复，这些消息反过来也会在网络中传播。每个
    IRC 用户都会选择一个昵称（通常缩写为 *nick*），这就像是在连接到网络时用于通信的 *handle*。
- en: IRC also supports one-to-one communication, which can be used for private conversation.
    To use this method, a user just needs the nickname of another user to whom she
    wants to talk. She uses a special command to send messages directly to that user,
    who can respond in kind. This is not a secure form of communication, since the
    messages are not encrypted, and they pass through servers where they could be
    monitored. However, there is so much traffic on a typical IRC network that any
    given message is unlikely to be monitored.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 还支持一对一的通信，这可以用于私人对话。要使用这种方法，用户只需要知道她想要与之交谈的另一个用户的昵称。她使用一个特殊的命令直接向该用户发送消息，该用户可以相应地回复。这不是一种安全的通信方式，因为消息没有被加密，并且它们会通过服务器传输，这些服务器可能会被监控。然而，在典型的
    IRC 网络上流量如此之大，任何给定的消息不太可能被监控。
- en: The IRC Protocol defines a rich command set that allows users to perform essential
    functions, such as joining or leaving a channel, changing nicknames, changing
    servers, setting operating modes for channels, and so forth. The exact command
    set and features available depend both on the specific software used for the user's
    IRC client and the features available on the IRC network itself. Not all IRC networks
    run the same version of the protocol.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 协议定义了一个丰富的命令集，允许用户执行基本功能，例如加入或离开频道、更改昵称、更改服务器、为频道设置操作模式等等。确切的命令集和可用功能既取决于用户使用的特定
    IRC 客户端软件，也取决于 IRC 网络本身的功能。并非所有 IRC 网络都运行相同的协议版本。
- en: IRC and the Modern Internet
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IRC 与现代互联网
- en: IRC became very popular in the early 1990s because of the powerful way that
    it allows users from anywhere on the Internet to meet and share information dynamically.
    It acts like a text-based telephone, but users across the globe don't have the
    expense of long-distance calls.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它允许来自互联网任何地方的用户动态地相遇和共享信息，IRC 在 20 世纪 90 年代初变得非常流行。它就像一个基于文本的电话，但全球的用户不需要长途电话的费用。
- en: One of the most important characteristics of IRC is its open-ended nature; it
    gives every person the freedom to communicate in whatever way he or she considers
    best. For example, every IRC channel has an owner, who has certain rights related
    to how the channel is used, including the ability to decide who should be allowed
    in the channel. This may seem autocratic, but IRC lets anyone start a new channel
    instantly and become that channel's owner, without the need for prior registration
    or authorization. This means that if you don't like how a particular channel is
    run, you can start your own with a minimum of fuss. You are not forced to adhere
    to anyone's rules, other than the rules set forth for the server (which are usually
    just intended to prevent abuse).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: IRC 最重要的一项特性是其开放性；它给每个人提供了自由，以他们认为最好的方式进行沟通。例如，每个 IRC 频道都有一个所有者，他拥有与频道使用相关的某些权利，包括决定谁应该被允许进入频道。这可能看起来是专制的，但
    IRC 允许任何人立即启动一个新的频道并成为该频道的所有者，而无需事先注册或授权。这意味着如果你不喜欢某个频道的运行方式，你可以以最小的麻烦启动自己的频道。你不必遵守任何人的规则，除了服务器设定的规则（通常只是旨在防止滥用）。
- en: This same principle extends to the IRC networks themselves. There isn't just
    one single IRC network; there are dozens of different ones. Some are large, well-established
    networks that may have more than 100 servers and thousands of users; others are
    smaller and devoted to specific areas of interest or geographical regions. Anyone
    can set up their own IRC network if they have the hardware and software, and some
    organizations have set up private, dedicated IRC servers for their own use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则也适用于 IRC 网络。并不是只有一个单一的 IRC 网络；有几十个不同的网络。有些是大型、成熟的网络，可能有超过 100 个服务器和数千名用户；其他则是较小，专注于特定的兴趣领域或地理区域。任何人只要有硬件和软件，都可以设置自己的
    IRC 网络，并且一些组织已经为自身使用设置了私有、专用的 IRC 服务器。
- en: IRC is considered by many to be the most important ancestor of the related interactive
    applications collectively known as *instant messaging*. These services are offered
    by several organizations, including America Online (AOL), Yahoo, and Microsoft's
    MSN. The idea behind them is very similar to that of IRC. Each allows a message
    sent by one user to be displayed immediately to another, though most are focused
    primarily on user-to-user messages rather than group messaging. Instant messaging
    has surpassed IRC in overall use, perhaps due to the large subscriber base of
    services like AOL. However, IRC is still widely used by thousands of enthusiasts
    on a daily basis for both entertainment and business purposes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多用户来说，IRC 被认为是被称为 *即时消息* 的相关交互式应用的最重要的祖先。这些服务由多个组织提供，包括美国在线（AOL）、雅虎和微软的 MSN。它们背后的理念与
    IRC 非常相似。每个都允许一个用户发送的消息立即显示给另一个用户，尽管大多数服务主要关注用户之间的消息，而不是群组消息。即时消息在整体使用上已经超过了 IRC，这或许是由于像
    AOL 这样的服务拥有庞大的用户群。然而，IRC 仍然被成千上万的爱好者每天广泛用于娱乐和商业目的。
- en: Chapter 88. TCP/IP ADMINISTRATION AND TROUBLESHOOTING UTILITIES AND PROTOCOLS
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第88章. TCP/IP 管理和故障排除工具及协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: This final chapter on application protocols is a bit different from the previous
    ones. It doesn't describe applications designed for end users. Rather, it discusses
    a set of TCP/IP troubleshooting utilities and protocols, which are normally the
    province of internetwork administrators. Even though millions of people use TCP/IP
    every day without even knowing that these applications exist—much less how they
    work—they are critically important to those who maintain TCP/IP internetworks.
    Since many of you are studying TCP/IP so that you can implement and administer
    this technology, understanding how these applications work is well worth your
    time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章关于应用协议的最后一部分与前面的章节略有不同。它不描述为最终用户设计的应用。相反，它讨论了一组 TCP/IP 故障排除工具和协议，这些通常是内部网络管理员的领域。尽管数百万人在每天使用
    TCP/IP 时甚至不知道这些应用的存在——更不用说它们是如何工作的——但对于维护 TCP/IP 内部网络的人来说，它们至关重要。由于你们中的许多人学习 TCP/IP
    是为了实施和管理这项技术，因此了解这些应用是如何工作的值得你们花时间。
- en: In this chapter, I provide an overview of a number of software utilities that
    are commonly employed to help set up, configure, and maintain TCP/IP internetworks.
    These programs allow a network administrator to perform functions such as checking
    the identity of a host, verifying connectivity between two hosts, checking the
    path of routers between devices, examining the configuration of a computer, and
    looking up a Domain Name System (DNS) domain name.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我概述了多种常用的软件工具，这些工具通常用于帮助设置、配置和维护 TCP/IP 内部网络。这些程序允许网络管理员执行诸如检查主机身份、验证两个主机之间的连接、检查设备之间的路由器路径、检查计算机配置以及查找域名系统（DNS）域名等功能。
- en: The goal of this chapter is to provide explanations of the general purpose and
    function of troubleshooting utilities, so you will know how they can help you
    manage TCP/IP networks. As part of these descriptions, I demonstrate the typical
    syntax used to invoke each utility in both UNIX and Windows. Due to variations
    in software implementations, you will need to consult your operating system documentation
    for the details on exactly how each program should be used on your network. On
    Windows systems, try `<`*`program`*`> /?` to see the syntax of the program; on
    UNIX/Linux, try `man <`*`program`*`>`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是解释故障排除工具的一般用途和功能，这样你们就会知道它们如何帮助你们管理 TCP/IP 网络。作为这些描述的一部分，我演示了在 UNIX 和
    Windows 中调用每个工具的典型语法。由于软件实现的不同，你们需要查阅操作系统的文档，以了解每个程序在你们网络上的具体使用细节。在 Windows 系统上，尝试
    `<`*`program`*`> /?` 来查看程序的语法；在 UNIX/Linux 上，尝试 `man <`*`program`*`>`。
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *Many of the software tools described in this section
    are designed to manage the operation of other TCP/IP protocols, such as the Internet
    Protocol (IP), the Domain Name System (DNS), and the Dynamic Host Configuration
    Protocol (DHCP). To fully appreciate how these utilities work, you need to understand
    the basics of these and other key TCP/IP protocols. In particular, a number of
    the utilities discussed here communicate use Internet Control Message Protocol
    (ICMP) messages, so I would recommend familiarity with ICMP (discussed in [Part II-6](pt09.html
    "Part II-6. IP SUPPORT PROTOCOLS")) before proceeding*.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** 许多在本节中描述的软件工具旨在管理其他TCP/IP协议的操作，例如互联网协议（IP）、域名系统（DNS）和动态主机配置协议（DHCP）。要充分理解这些实用程序的工作原理，你需要了解这些和其他关键TCP/IP协议的基础知识。特别是，这里讨论的一些实用程序使用互联网控制消息协议（ICMP）消息进行通信，因此我建议在继续之前熟悉ICMP（在[第二部分-6](pt09.html
    "第二部分-6. IP支持协议")中讨论）。'
- en: TCP/IP Host Name Utility (hostname)
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP主机名称实用程序（hostname）
- en: One of the most fundamental of tasks in diagnosing problems with a networked
    computer is identifying it. Just as the first thing we usually do when we meet
    someone is exchange names, one of the first actions an administrator takes when
    accessing a device is to determine its name, if it is not known. This is accomplished
    using the `hostname` utility.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在诊断网络计算机问题时，最基本的一项任务是识别它。正如我们通常在见到某人时首先交换名字一样，管理员访问设备时采取的第一个行动之一是确定其名称，如果不知道的话。这是通过使用`hostname`实用程序来完成的。
- en: You may recall from our discussion of TCP/IP name systems in [Part III-1](pt12.html
    "Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION AND NAME RESOLUTION") that
    there are two different ways that hosts can be named. The first way is to manually
    assign flat names to devices using host tables or equivalent means; this is most
    often used for devices that not going to be accessed on the public Internet. The
    second is to give a device a domain name within DNS. The `hostname` utility can
    be used for both types of named hosts, but it functions in a slightly different
    way for each.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们在[第三部分-1](pt12.html "第三部分-1. 命名系统、TCP/IP名称注册和名称解析")中关于TCP/IP名称系统的讨论，其中提到主机命名有两种不同的方式。第一种方式是手动使用主机表或等效方式为设备分配平坦名称；这通常用于不会在公共互联网上访问的设备。第二种是在DNS中为设备分配域名。`hostname`实用程序可以用于这两种类型的命名主机，但它在每种类型中的功能略有不同。
- en: 'On most systems, including Windows and many UNIX implementations, the `hostname`
    utility is very simple. When you enter the command by itself on a line with no
    arguments, it displays the full name of the host. If it is entered with the `-s`
    (short) parameter and the host name is a fully qualified DNS domain name, only
    the local label of the node is shown and not the full domain name; if the host
    has a flat (non-DNS) name, the `-s` parameter has no effect. Here is a simple
    example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，包括Windows和许多UNIX实现，`hostname`实用程序非常简单。当你单独在带有无参数的行中输入该命令时，它会显示主机的完整名称。如果使用`-s`（短）参数并且主机名是一个完全限定的DNS域名，则仅显示节点的本地标签，而不是完整的域名；如果主机有一个平坦（非DNS）名称，则`-s`参数没有效果。以下是一个简单的例子：
- en: '[PRE6]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `hostname` utility is also intended to allow an administrator to set the
    name of a host. The syntax for this is also simple; you just supply the name of
    the host as a parameter, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostname`实用程序还旨在允许管理员设置主机的名称。这种语法的设置也很简单；你只需将主机名称作为参数提供，如下所示：'
- en: '[PRE7]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, in most implementations, the use of the `hostname` command for setting
    a device's name is either disabled or restricted. In Windows systems, a special
    applet in the Control Panel is used to set the device's name; attempting to set
    it using `hostname` will result in an error message. In UNIX, the superuser of
    the system can use `hostname` to set the device's name, but it is more common
    for this to be done by other means, such as editing the configuration file `/etc/hosts`.
    If a simple flat name is being assigned to this host, the administrator has full
    control over it. However, if DNS is used, then the proper procedures for registering
    the name must be followed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数实现中，使用`hostname`命令设置设备名称的功能已被禁用或受限。在Windows系统中，控制面板中有一个特殊的小程序用于设置设备名称；尝试使用`hostname`设置它将导致错误消息。在UNIX中，系统超级用户可以使用`hostname`设置设备名称，但更常见的是通过其他方式完成，例如编辑配置文件`/etc/hosts`。如果为该主机分配的是简单的平坦名称，则管理员对其有完全控制权。然而，如果使用DNS，则必须遵循注册名称的正确程序。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* `hostname` *utility is not, strictly speaking, tied into the operation
    of DNS or other formal mechanisms for identifying a host. It simply displays what
    the administrator has set it to show. It makes sense for this to be set to the
    host''s DNS name, but there may be exceptions, such as in small networks that
    might not use DNS*.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*The* `hostname` *utility is not, strictly speaking, tied into the operation
    of DNS or other formal mechanisms for identifying a host. It simply displays what
    the administrator has set it to show. It makes sense for this to be set to the
    host''s DNS name, but there may be exceptions, such as in small networks that
    might not use DNS*.'
- en: In most operating systems, the `-s` parameter is the only one that this command
    supports. The parameter is not supported on all implementations of the `hostname`
    command, however. On some implementations, if you use `hostname -s`, the system
    may report its host name as being *–s*. On certain Linux systems, the `hostname`
    utility includes a few additional parameters that allow different ways for the
    host name to be displayed, as well as some miscellaneous functions such as showing
    the version number of the program.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数操作系统中，`-s` 参数是此命令支持的唯一参数。然而，并非所有 `hostname` 命令的实现都支持此参数。在某些实现中，如果您使用 `hostname
    -s`，系统可能会报告其主机名为 *–s*。在某些 Linux 系统中，`hostname` 工具包含一些额外的参数，允许以不同的方式显示主机名，以及一些其他功能，例如显示程序的版本号。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The simplest and most basic of TCP/IP administrative utilities
    is hostname, which returns the name of the host on which it is run.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 最简单、最基本的 TCP/IP 管理工具是 `hostname`，它返回运行它的主机名称。'
- en: TCP/IP Communication Verification Utility (ping)
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 通信验证工具（ping）
- en: One of the most common problems that network administrators are asked to solve
    is that two hosts are not able to communicate. For example, a user on a corporate
    network might not be able to retrieve one of his files from a local server, or
    another user might be having difficulty loading her favorite website. In these
    and similar situations, one important step in diagnosing the problem is to verify
    that basic communication is possible between the TCP/IP software stacks on the
    two machines. This is most often done using the `ping` utility, or `ping6` in
    Internet Protocol version 6 (IPv6) implementations. The IPv6 version of `ping`
    works in much the same way as IPv4 ping, but `ping6`'s options and parameters
    reflect the changes made in addressing and routing in IPv6.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员被要求解决的最常见问题之一是两个主机无法通信。例如，企业网络中的用户可能无法从本地服务器检索他的文件，或者另一个用户可能难以加载她最喜欢的网站。在这些和类似情况下，诊断问题的第一步重要步骤是验证两台机器上的
    TCP/IP 软件堆栈之间基本通信是否可行。这通常是通过使用 `ping` 工具或 IPv6 实现中的 `ping6` 来完成的。IPv6 版本的 `ping`
    与 IPv4 ping 的工作方式非常相似，但 `ping6` 的选项和参数反映了 IPv6 中地址和路由的变化。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some people say that* `ping` *is an acronym for Packet Internet Groper, while
    others insist that it is actually based on the use of the term to refer to a sonar
    pulse sent by a submarine to check for nearby objects. I really don''t know which
    of these is true, but I prefer the second explanation. Consider that the utility
    works in a way similar to a sonar ping, and that it was originally written by
    a gentleman named Mike Muuss, who worked at the United States Army Ballistics
    Research Laboratory*.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*Some people say that* `ping` *is an acronym for Packet Internet Groper, while
    others insist that it is actually based on the use of the term to refer to a sonar
    pulse sent by a submarine to check for nearby objects. I really don''t know which
    of these is true, but I prefer the second explanation. Consider that the utility
    works in a way similar to a sonar ping, and that it was originally written by
    a gentleman named Mike Muuss, who worked at the United States Army Ballistics
    Research Laboratory*.'
- en: '`ping` is one of the most commonly used diagnostic utilities, and it is present
    in just about every TCP/IP implementation. It is usually implemented and accessed
    as a command-line utility, though there are also now graphical and menu-based
    versions of the program on some operating systems.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping` 是最常用的诊断工具之一，几乎在每个 TCP/IP 实现中都有。它通常以命令行工具的形式实现和访问，尽管在某些操作系统中现在也有图形和基于菜单的程序版本。'
- en: Operation of the ping Utility
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ping 工具的操作
- en: The `ping` utility is implemented using Internet Control Message Protocol (ICMP)
    Echo (Request) and Echo Reply messages, which are designed specifically for this
    type of diagnostic use. When Device A sends an ICMP Echo message to Device B,
    Device B responds by sending an ICMP Echo Reply message back to Device A. The
    same functionality exists in ICMPv6, the IPv6 version of ICMP; the ICMPv6 Echo
    and Echo Reply messages differ from the IPv4 ones only slightly in their field
    structure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ping实用程序是使用互联网控制消息协议（ICMP）回声（请求）和回声回复消息实现的，这些消息专门为这种诊断用途而设计。当设备A向设备B发送ICMP回声消息时，设备B通过发送ICMP回声回复消息回传给设备A。在ICMPv6中，即ICMP的IPv6版本，也存在相同的功能；ICMPv6回声和回声回复消息在字段结构上仅与IPv4的略有不同。
- en: 'This would seem to indicate that `ping` would be an extremely simple utility
    that would send one Echo message and wait to see if an Echo Reply was received
    back. If so, this would mean that the two devices were able to communicate; if
    not, this would indicate a problem somewhere on the internetwork between the two.
    However, almost all `ping` implementations are much more complex than this. They
    use multiple sets of Echo and Echo Reply messages, along with considerable internal
    logic, to allow an administrator to determine all of the following, and more:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎表明ping将是一个非常简单的实用程序，它会发送一个回声消息并等待查看是否收到回声回复。如果是这样，这意味着两个设备能够通信；如果没有，这表明在两个设备之间的互联网上存在某个问题。然而，几乎所有ping实现都比这复杂得多。它们使用多组回声和回声回复消息，以及相当多的内部逻辑，允许管理员确定以下所有内容，以及更多：
- en: Whether or not the two devices can communicate
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个设备是否能够通信
- en: Whether congestion or other problems exist that might allow communication to
    succeed sometimes but cause it to fail in others, seen as packet loss; if so,
    how bad the loss is
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在拥塞或其他问题，有时可能允许通信成功，但有时会导致失败，这被视为数据包丢失；如果是这样，丢失有多严重
- en: How much time it takes to send a simple ICMP message between devices, which
    gives an indication of the overall latency between the hosts and also indicates
    if there are certain types of problems
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备之间发送简单的ICMP消息需要多少时间，这可以指示主机之间的整体延迟，同时也表明是否存在某些类型的问题
- en: Basic Use of ping
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ping的基本用法
- en: The most basic use of the `ping` command is to enter it by itself with the IP
    address of a host. Virtually all implementations also allow you to use a host
    name, which will be resolved to an IP address automatically. When you invoke the
    utility with no additional options, it uses default values for parameters such
    as what size message to send, how many messages to be sent, how long to wait for
    a reply, and so on. The utility will transmit a series of Echo messages to the
    host and report back whether or not a reply was received for each. If a reply
    is seen, it will also indicate how long it took for the response to be received.
    When the program is finished, it will provide a statistical summary showing what
    percentage of the Echo messages received a reply and the average amount of time
    it took for them to be received.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ping命令最基本的使用方法是仅输入命令本身，并带有主机的IP地址。几乎所有的实现也允许您使用主机名，它将被自动解析为IP地址。当您使用没有额外选项的实用程序时，它将使用默认值来设置参数，例如发送的消息大小、要发送的消息数量、等待回复的时间等。实用程序将向主机发送一系列回声消息，并报告是否收到每个消息的回复。如果看到回复，它还会指示接收响应所需的时间。当程序完成后，它将提供一个统计摘要，显示收到的回声消息中有多少百分比收到了回复，以及它们接收的平均时间。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While the inability to get a response from a device to a* `ping` *has traditionally
    been interpreted as a problem in communication, this is not always necessarily
    the case. In the current era of increased security consciousness, some networks
    are set up to not respond to Echo messages, to protect against attacks that use
    floods of such messages. In this case, a* `ping` *will fail, even though the host
    may be quite reachable*.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然设备对ping命令无响应传统上被解释为通信问题，但这并不总是必然的情况。在当前提高安全意识的时代，一些网络被设置为不响应回声消息，以防止使用此类消息洪水的攻击。在这种情况下，ping命令将失败，尽管主机可能非常可达*。'
- en: '[Example 88-1](ch88s02.html#verifying_communication_using_the_ping_u "Example 88-1. Verifying
    communication using the ping utility") shows an example of using the `ping` command
    on a Windows XP computer (mine!), which, by default, sends four 32-byte Echo messages
    and allows four seconds before considering an Echo message lost. I use a satellite
    Internet connection that has fairly high latency and also occasionally drops packets.
    This isn''t great for me, but it is useful for illustrating how `ping` works.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-1](ch88s02.html#verifying_communication_using_the_ping_u "示例 88-1. 使用`ping`实用程序验证通信")
    展示了在Windows XP计算机上使用`ping`命令的例子（我的！），默认情况下，它发送四个32字节的回显消息，并在认为回显消息丢失之前允许四秒钟。我使用的是具有相当高延迟和偶尔丢包的卫星互联网连接。这对我不太理想，但有助于说明`ping`是如何工作的。'
- en: Example 88-1. Verifying communication using the ping utility
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-1. 使用`ping`实用程序验证通信
- en: '[PRE8]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Methods of Diagnosing Connectivity Problems Using ping
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ping`诊断连接问题的方法
- en: 'Most people find that using `ping` with default settings is enough for their
    needs. In fact, the utility can be used in this simplest form to perform a surprising
    number of diagnostic checks. In many cases, you can use the `ping` command to
    diagnose connectivity problems by issuing it multiple times in sequence, often
    starting with checks at or close to the transmitting device and then proceeding
    outward toward the other device with which the communication problem has been
    observed. Here are some examples of how ping can be used in this way:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人发现使用默认设置的`ping`就足够满足他们的需求。实际上，这个实用程序可以以这种最简单的形式执行许多诊断检查。在许多情况下，你可以通过连续多次执行`ping`命令来诊断连接问题，通常从检查发送设备或接近发送设备的检查开始，然后向外扩展到观察到通信问题的其他设备。以下是一些如何使用`ping`的例子：
- en: '**Internal Device TCP/IP Stack Operation** By performing a `ping` on the device''s
    own address, you can verify that its internal TCP/IP stack is working. This can
    also be done using the standard IP loopback address, 127.0.0.1.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部设备TCP/IP堆栈操作** 通过对设备的自身地址执行`ping`操作，你可以验证其内部TCP/IP堆栈是否正常工作。这也可以使用标准的IP环回地址，127.0.0.1来完成。'
- en: '**Local Network Connectivity** If the internal test succeeds, it''s a good
    idea to do a `ping` on another device on the local network, to verify that local
    communication is possible.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地网络连接** 如果内部测试成功，对本地网络上的另一台设备执行`ping`操作是个好主意，以验证本地通信是否可行。'
- en: '**Local Router Operation** If there is no problem on the local network, it
    makes sense to `ping` whatever local router the device is using to make sure it
    is operating and reachable.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地路由器操作** 如果本地网络没有问题，对设备使用的任何本地路由器执行`ping`操作是有意义的，以确保它正在运行且可访问。'
- en: '**Domain Name Resolution Functionality** If a `ping` performed on a DNS domain
    name fails, you should try it with the device''s IP address instead. If that works,
    this implies either a problem with domain name configuration or resolution.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**域名解析功能** 如果对一个DNS域名执行的`ping`操作失败，你应该尝试使用设备的IP地址来执行。如果那样可以工作，这表明可能存在域名配置或解析的问题。'
- en: '**Remote Host Operation** If all the preceding checks succeed, you can try
    performing a `ping` to a remote host to see if it responds. If it does not, you
    can try a different remote host. If that one works, it is possible that the problem
    is actually with the first remote device itself and not with your local device.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程主机操作** 如果所有前面的检查都成功了，你可以尝试对一个远程主机执行`ping`操作，看看它是否响应。如果它没有响应，你可以尝试另一个远程主机。如果那个主机可以工作，那么问题可能实际上是在第一个远程设备本身，而不是你的本地设备。'
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The TCP/IP ping utility is used to verify the ability of two
    devices on a TCP/IP internetwork to communicate. It operates by having one device
    send ICMP Echo (Request) messages to another, which responds with Echo Reply messages.
    The program can be helpful in diagnosing a number of connectivity issues, especially
    if it is used to test the ability to communicate with other devices in different
    locations. It also allows the average round-trip delay to exchange messages with
    another device to be estimated.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP `ping`实用程序用于验证TCP/IP互联网上两个设备之间的通信能力。它通过一个设备向另一个设备发送ICMP回显（请求）消息，另一个设备以回显响应消息进行响应。这个程序在诊断许多连接问题方面非常有用，特别是如果用它来测试与不同位置的设备通信的能力。它还允许估计与另一个设备交换消息的平均往返延迟。'
- en: ping Options and Parameters
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ping`选项和参数'
- en: In addition to the basic uses described in the previous sections, all `ping`
    implementations include a number of options and parameters that allow an administrator
    to fine-tune how it works. They allow ping to be used for more extensive or specific
    types of testing. For example, `ping` can be set in a mode where it sends Echo
    messages continually, to check for an intermittent problem over a long period
    of time. You can also increase the size of the messages sent or the frequency
    with which they are transmitted, to test the ability of the local network to handle
    large amounts of traffic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前几节中描述的基本用法之外，所有`ping`实现都包含一些选项和参数，允许管理员微调其工作方式。它们允许ping用于更广泛的或更具体的测试类型。例如，`ping`可以设置为连续发送Echo消息的模式，以检查长时间内间歇性问题。您还可以增加发送消息的大小或它们的传输频率，以测试本地网络处理大量流量的能力。
- en: As with the other utilities described in this chapter, the exact features of
    the `ping` program are implementation-dependent. Even though UNIX and Windows
    systems often include many of the same options, they usually use completely different
    option codes. [Table 88-1](ch88s02.html#common_unix_ping_utility_options_and_par
    "Table 88-1. Common UNIX ping Utility Options and Parameters") shows some of the
    more important options that are often defined for the utility on many UNIX systems,
    and where appropriate, the parameters supplied with the option. [Table 88-2](ch88s02.html#common_windows_ping_utility_options_and_
    "Table 88-2. Common Windows ping Utility Options and Parameters") shows `ping`
    options for a typical Windows system.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中描述的其他工具一样，`ping`程序的确切功能取决于实现。尽管UNIX和Windows系统通常包括许多相同的选项，但它们通常使用完全不同的选项代码。[表88-1](ch88s02.html#common_unix_ping_utility_options_and_par
    "表88-1. 常见的UNIX ping实用工具选项和参数")显示了在许多UNIX系统上为该工具定义的一些更重要选项，以及适当的选项参数。[表88-2](ch88s02.html#common_windows_ping_utility_options_and_
    "表88-2. 常见的Windows ping实用工具选项和参数")显示了典型Windows系统的`ping`选项。
- en: Table 88-1. Common UNIX ping Utility Options and Parameters
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表88-1. 常见的UNIX ping实用工具选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-c <`*`count`*`>` | Specifies the number of Echo messages that should be
    sent. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `-c <`*`count`*`>` | 指定应发送的Echo消息的数量。 |'
- en: '| `-f` | Flood mode; sends Echo packets at high speed to stress test a network.
    This can cause serious problems if not used carefully! |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `-f` | 洪水模式；以高速发送Echo数据包以对网络进行压力测试。如果不小心使用，这可能会引起严重问题！ |'
- en: '| `-i <`*`wait-interval`*`>` | Tells the utility how long to wait between transmissions.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `-i <`*`wait-interval`*`>` | 告诉工具在传输之间等待多长时间。 |'
- en: '| `-m <`*`ttl-value`*`>` | Overrides the default Time to Live (TTL) value for
    outgoing Echo messages. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `-m <`*`ttl-value`*`>` | 覆盖输出Echo消息的默认生存时间（TTL）值。 |'
- en: '| `-n` | Numeric output only; suppresses lookups of DNS host names to save
    time. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 仅输出数字；抑制DNS主机名的查找以节省时间。 |'
- en: '| `-p <`*`pattern`*`>` | Allows a byte pattern to be specified for inclusion
    in the transmitted Echo messages. This can be useful for diagnosing certain odd
    problems that may occur only with certain types of transmissions. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `-p <`*`pattern`*`>` | 允许指定一个字节模式，并将其包含在传输的Echo消息中。这可以用于诊断某些仅在特定类型传输中出现的奇怪问题。
    |'
- en: '| `-q` | Quiet output; only summary lines are displayed at the start and end
    of the program''s execution, while the lines for each individual message are suppressed.
    |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `-q` | 静默输出；仅在程序执行的开始和结束时显示摘要行，而抑制每个单独消息的行。 |'
- en: '| `-R` | Tells the utility to include the Record Route IP option, so the route
    taken by the ICMP Echo message can be displayed. This option is not supported
    by all implementations. Using the `traceroute` utility (described in the next
    section) is usually a better idea. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| `-R` | 告诉工具包含记录路由IP选项，以便可以显示ICMP Echo消息的路径。此选项并非所有实现都支持。使用下一节中描述的`traceroute`工具通常是一个更好的选择。
    |'
- en: '| `-s <`*`packet-size`*`>` | Specifies the size of outgoing message to use.
    |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| `-s <`*`packet-size`*`>` | 指定要使用的输出消息的大小。 |'
- en: '| `-S <`*`src-addr`*`>` | On devices that have multiple IP interfaces (addresses),
    allows a `ping` sent from one interface to use an address from one of the others.
    |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `-S <`*`src-addr`*`>` | 在具有多个IP接口（地址）的设备上，允许从其中一个接口发送的`ping`命令使用其他接口中的一个地址。
    |'
- en: '| `-t <`*`timeout`*`>` | Specifies a timeout period, in seconds, after which
    the `ping` utility will terminate, regardless of how many requests or replies
    have been sent or received. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `-t <`*`timeout`*`>` | 指定超时时间，以秒为单位，在此之后`ping`工具将终止，无论已发送或接收了多少请求或回复。|'
- en: Table 88-2. Common Windows ping Utility Options and Parameters
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-2. 常见的Windows ping工具选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-a` | If the target device is specified as an IP address, forces the address
    to be resolved to a DNS host name and displayed. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 如果目标设备指定为IP地址，则强制将地址解析为DNS主机名并显示。|'
- en: '| `-f` | Sets the Don''t Fragment bit in the outgoing datagram. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `-f` | 在出站数据报中设置不要分段位。|'
- en: '| `-i <`*`ttl-value`*`>` | Specifies the Time to Live (TTL) value to be used
    for outgoing Echo messages. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `-i <`*`ttl-value`*`>` | 指定用于出站Echo消息的生存时间（TTL）值。|'
- en: '| `-j <`*`host-list`*`>` | Sends the outgoing messages using the specified
    loose source route. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `-j <`*`host-list`*`>` | 使用指定的松散源路由发送出站消息。|'
- en: '| `-k <`*`host-list`*`>` | Sends the outgoing messages using the indicated
    strict source route. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `-k <`*`host-list`*`>` | 使用指示的严格源路由发送出站消息。|'
- en: '| `-l <`*`buffer-size`*`>` | Specifies the size of the data field in the transmitted
    Echo messages. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `-l <`*`buffer-size`*`>` | 指定传输Echo消息中的数据字段的大小。|'
- en: '| `-n <`*`count`*`>` | Tells the utility how many Echo messages to send. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `-n <`*`count`*`>` | 告诉工具发送多少个Echo消息。|'
- en: '| `-r <`*`count`*`>` | Specifies the use of the Record Route IP option and
    the number of hops to be recorded. It''s usually preferable to use the `traceroute`
    utility (described in the next section). |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `-r <`*`count`*`>` | 指定使用记录路由IP选项和要记录的跳数。通常，使用`traceroute`工具（下一节将描述）更为可取。|'
- en: '| `-s <`*`count`*`>` | Specifies the use of the IP Timestamp option to record
    the arrival time of the Echo and Echo Reply messages. |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `-s <`*`count`*`>` | 指定使用IP时间戳选项来记录Echo和Echo回复消息的到达时间。|'
- en: '| `-t` | Sends Echo messages continuously until the program is interrupted.
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 连续发送Echo消息，直到程序被中断。|'
- en: '| `-w <`*`timeout`*`>` | Specifies how long the program should wait for each
    Echo Reply before giving up, in milliseconds (default is 4,000, for 4 seconds).
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `-w <`*`timeout`*`>` | 指定程序在放弃之前应等待每个Echo回复的时间长度，以毫秒为单位（默认为4,000，即4秒）。|'
- en: TCP/IP Route Tracing Utility (traceroute)
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP路由跟踪工具（traceroute）
- en: The `ping` utility is extremely helpful for checking whether two devices are
    able to communicate with each other. However, it provides very little information
    regarding what is going on between those two devices. In the event that `ping`
    shows either a total inability to communicate or intermittent connectivity with
    high loss of transmitted data, administrators need to know more about what is
    happening to IP datagrams as they are carried across the internetwork. This is
    especially important when the two devices are far from each other, especially
    if you are trying to reach a server on the public Internet.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`工具对于检查两个设备是否能够相互通信非常有帮助。然而，它提供的关于两个设备之间发生情况的信息非常有限。如果`ping`显示完全无法通信或间歇性连接且传输数据丢失率很高，管理员需要了解IP数据报在跨越互联网传输时的具体情况。当两个设备相距很远时，这一点尤为重要，尤其是当你试图连接到公共互联网上的服务器时。'
- en: I described in my overview of IP datagram delivery that when two devices are
    not on the same network, data sent between them must be delivered from one network
    to the next until it reaches its destination. This means that any time data is
    sent from Device A on one network to Device B on another, it follows a route,
    which may not be the same for each transmission. When communication problems arise,
    it is very useful to be able to check the specific route taken by data between
    two devices. A special route tracing utility is provided for this function, called
    `traceroute` (abbreviated `tracert` in Windows systems, a legacy of the old eight-character
    limit for DOS program names).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在我对IP数据报交付的概述中，我描述了当两个设备不在同一网络中时，它们之间发送的数据必须从一个网络传递到下一个网络，直到到达目的地。这意味着，每当从网络A的设备A向网络B的设备B发送数据时，它都会遵循一条路径，这条路径可能对每次传输都不相同。当出现通信问题时，能够检查两个设备之间数据的具体路径非常有用。为此，提供了一个特殊的路由跟踪工具，称为`traceroute`（在Windows系统中简称为`tracert`，这是DOS程序名旧八字符限制的遗留问题）。
- en: The IPv6 equivalent of this program is called `traceroute6`, which functions
    in a very similar manner to its IPv4 predecessor. It obviously uses IPv6 datagrams
    instead of IPv4 ones, and responses from traced devices are in the form of ICMPv6
    Time Exceeded and Destination Unreachable messages rather than their ICMPv4 counterparts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的IPv6等价物被称为`traceroute6`，其工作方式与IPv4前辈非常相似。它显然使用IPv6数据报而不是IPv4数据报，并且被追踪设备的响应以ICMPv6超时和目标不可达消息的形式出现，而不是它们的ICMPv4对应消息。
- en: Operation of the traceroute Utility
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: traceroute工具的操作
- en: Like the `ping` utility, `traceroute` is implemented using ICMP messages. However,
    unlike `ping`, `traceroute` was not originally designed to use a special ICMP
    message type intended exclusively for route tracing. Instead, it makes clever
    use of the IP and ICMP features that are designed to prevent routing problems.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ping`工具一样，`traceroute`使用ICMP消息实现。然而，与`ping`不同，`traceroute`最初并不是设计用来使用专门为路由跟踪而设计的特殊ICMP消息类型。相反，它巧妙地使用了旨在防止路由问题的IP和ICMP功能。
- en: Recall that the IP datagram format includes a Time to Live (TTL) field. This
    field is set to the maximum number of times that a datagram may be forwarded before
    it must be discarded; it exists to prevent datagrams from circling an internetwork
    endlessly. If a datagram must be discarded due to expiration of the TTL field,
    the device that discards it is supposed to send an ICMP Time Exceeded message
    back to the device that sent the discarded datagram. (This is explained in detail
    in [Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS").)
    Under normal circumstances, this occurs only when there is a problem, such as
    a router loop or another misconfiguration issue. What `traceroute` does is to
    force each router in a route to report back to it by intentionally setting the
    TTL value in test datagrams to a value too low to allow them to reach their destination.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，IP数据报格式包括一个生存时间（TTL）字段。该字段设置为数据报在必须丢弃之前可以转发的最大次数；它存在是为了防止数据报在互联网中无限循环。如果一个数据报必须因为TTL字段的过期而被丢弃，那么丢弃它的设备应该向发送丢弃数据报的设备发送ICMP超时消息。（这在[第32章](ch32.html
    "第32章. ICMPV4错误消息类型和格式")中有详细解释。）在正常情况下，这仅在存在问题时才会发生，例如路由器循环或其他配置问题。`traceroute`所做的是通过故意将测试数据报中的TTL值设置为太低，以至于无法到达其目的地，来强制路由中的每个路由器向它报告。
- en: 'Suppose you have Device A and Device B, which are separated by Routers R1 and
    R2—three hops total (A to R1, R1 to R2 and R2 to B). If you do a `traceroute`
    from Device A to Device B, here''s what happens (see [Figure 88-1](ch88s03.html#operation_of_the_traceroutetracert_utili
    "Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility
    identifies the devices in a route by forcing them to report back failures to route
    datagrams with parameters intentionally set to invalid values. The first message
    sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router
    R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The
    second message has a TTL value of 2, so it will be dropped and reported by Router
    R2\. The third message will pass both routers and get to the destination host,
    Device B, but since the message is deliberately chosen with a bogus port number,
    this will cause an ICMP Destination Unreachable message to be returned. These
    error messages identify the sequence of devices in the route between Devices A
    and B.")):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你拥有设备A和设备B，它们通过路由器R1和R2（总共三个跳数，即A到R1，R1到R2，R2到B）相隔。如果你从设备A到设备B执行`traceroute`，以下是会发生的情况（参见[图88-1](ch88s03.html#operation_of_the_traceroutetracert_utili
    "图88-1. traceroute/tracert工具的操作 traceroute工具通过强制设备报告带有故意设置为无效值的参数的路由数据报的失败来识别路由中的设备。设备A在这里发送的第一条消息具有1的生存时间（TTL）值，这将导致路由器R1丢弃它并向设备A发送ICMP超时消息。第二条消息的TTL值为2，因此它将被丢弃并由路由器R2报告。第三条消息将穿过两个路由器并到达目标主机，设备B，但由于消息故意选择了无效的端口号，这将导致返回ICMP目标不可达消息。这些错误消息确定了设备A和设备B之间路由中的设备序列。"））：
- en: The `traceroute` utility sends a dummy User Datagram Protocol (UDP) message
    (sometimes called a *probe*) to a port number that is intentionally selected to
    be invalid. The TTL field of the IP datagram is set to 1\. When Router R1 receives
    the message, it decrements the field, which will make its value 0\. That router
    discards the probe and sends an ICMP Time Exceeded message back to Device A.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`traceroute` 工具向一个故意选为无效的端口号发送一个虚拟的用户数据报协议（UDP）消息（有时称为*探测*）。IP 数据报的TTL字段被设置为1。当路由器R1接收到该消息时，它会递减该字段，使其值变为0。该路由器将丢弃探测并给设备A发送一个ICMP超时消息。'
- en: Device A sends a second UDP message with the TTL field set to 2\. This time,
    Router R1 reduces the TTL value to 1 and sends it to Router R2, which reduces
    the TTL field to 0 and sends a Time Exceeded message back to Device A.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备A发送一个带有TTL字段设置为2的第二个UDP消息。这次，路由器R1将TTL值减少到1，并将其发送到路由器R2，R2将TTL字段减少到0，并发送一个超时消息回设备A。
- en: Device A sends a third UDP message, with the TTL field set to 3\. This time,
    the message will pass through both routers and be received by Device B. However,
    since the port number was invalid, the message is rejected by Device B, which
    sends back a Destination Unreachable message to Device A.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备A发送一个带有TTL字段设置为3的第三个UDP消息。这次，消息将通过两个路由器，并被设备B接收。然而，由于端口号无效，消息被设备B拒绝，并给设备A发送一个目标不可达消息。
- en: So Device A sends out three messages to Device B, and it gets back three error
    messages and is happy about it! The route to Device B is thus indicated by the
    identities of the devices sending back the error messages, in sequence. By keeping
    track of the time between when it sent each UDP message and received back the
    corresponding error message, the `traceroute` utility can also display how long
    it took to communicate with each device. In practice, usually three dummy messages
    are sent with each TTL value, so their transit times can be averaged by the user
    if desired.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设备A向设备B发送了三条消息，并收到了三条错误消息，对此感到很高兴！通过错误消息发送设备的标识顺序，从而指示了到设备B的路由。通过跟踪发送每个UDP消息和接收相应错误消息之间的时间，`traceroute`
    工具还可以显示与每个设备通信所需的时间。在实践中，通常为每个TTL值发送三个虚拟消息，因此如果用户需要，可以对这些传输时间进行平均。
- en: Note
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Not all* `traceroute` *utility implementations use the technique described
    here. Microsoft''s* `tracert` *works by sending ICMP Echo messages with increasing
    TTL values, rather than UDP packets. It knows it has reached the final host when
    it gets back an Echo Reply message. A special ICMP Traceroute message was also
    developed in 1993, which was intended to improve the efficiency of* `traceroute`
    *by eliminating the need to send many UDP messages for each route tracing. Despite
    its technical advantages, since this message was introduced long after TCP/IP
    was widely deployed, it never became a formal Internet standard and its use is
    not seen as often as the traditional method*.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '*并非所有* `traceroute` 工具实现都使用这里描述的技术。微软的 `tracert` 通过发送带有递增TTL值的ICMP回显消息，而不是UDP数据包来工作。当它收到一个回显应答消息时，它知道已经到达了最终主机。1993年还开发了一种特殊的ICMP
    Traceroute消息，其目的是通过消除每个路由跟踪需要发送许多UDP消息的需要来提高 `traceroute` 的效率。尽管它在技术上具有优势，但由于这个消息是在TCP/IP广泛部署之后很久才被引入的，它从未成为正式的互联网标准，并且其使用并不像传统方法那样常见*。'
- en: '![Operation of the traceroute/tracert utility The traceroute utility identifies
    the devices in a route by forcing them to report back failures to route datagrams
    with parameters intentionally set to invalid values. The first message sent by
    Device A here has a Time to Live (TTL) value of 1, which will cause Router R1
    it to drop it and send an ICMP Time Exceeded message back to Device A. The second
    message has a TTL value of 2, so it will be dropped and reported by Router R2\.
    The third message will pass both routers and get to the destination host, Device
    B, but since the message is deliberately chosen with a bogus port number, this
    will cause an ICMP Destination Unreachable message to be returned. These error
    messages identify the sequence of devices in the route between Devices A and B.](httpatomoreillycomsourcenostarchimages288327.png.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![`traceroute/tracert` 工具的操作 `traceroute` 工具通过强制设备报告带有故意设置为无效值的参数的路由数据报的失败来识别路由中的设备。在这里，设备
    A 发送的第一条消息的生存时间 (TTL) 值为 1，这将导致路由器 R1 丢弃它并向设备 A 发送 ICMP 时间超限消息。第二条消息的 TTL 值为 2，因此它将被丢弃并由路由器
    R2 报告。第三条消息将穿过两个路由器并到达目标主机，设备 B，但由于消息是故意选择了一个无效的端口号，这将导致返回 ICMP 目标不可达消息。这些错误消息确定了设备
    A 和 B 之间路由中设备的顺序。](httpatomoreillycomsourcenostarchimages288327.png.jpg)'
- en: Figure 88-1. Operation of the traceroute/tracert utility The traceroute utility
    identifies the devices in a route by forcing them to report back failures to route
    datagrams with parameters intentionally set to invalid values. The first message
    sent by Device A here has a Time to Live (TTL) value of 1, which will cause Router
    R1 it to drop it and send an ICMP Time Exceeded message back to Device A. The
    second message has a TTL value of 2, so it will be dropped and reported by Router
    R2\. The third message will pass both routers and get to the destination host,
    Device B, but since the message is deliberately chosen with a bogus port number,
    this will cause an ICMP Destination Unreachable message to be returned. These
    error messages identify the sequence of devices in the route between Devices A
    and B.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 88-1. `traceroute/tracert` 工具的操作 `traceroute` 工具通过强制设备报告带有故意设置为无效值的参数的路由数据报的失败来识别路由中的设备。在这里，设备
    A 发送的第一条消息的生存时间 (TTL) 值为 1，这将导致路由器 R1 丢弃它并向设备 A 发送 ICMP 时间超限消息。第二条消息的 TTL 值为 2，因此它将被丢弃并由路由器
    R2 报告。第三条消息将穿过两个路由器并到达目标主机，设备 B，但由于消息是故意选择了一个无效的端口号，这将导致返回 ICMP 目标不可达消息。这些错误消息确定了设备
    A 和 B 之间路由中设备的顺序。
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The `traceroute` utility takes the idea behind ping one step
    further, allowing administrators to not only check communication between two devices,
    but also letting them see a list of all the intermediate devices between the pair.
    It works by having the initiating host send a series of test datagrams with TTL
    values that cause each to expire sequentially at each device on the route. The
    `traceroute` program also shows how much time it takes to communicate with each
    device between the sending host and a destination device.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** `traceroute` 工具将 ping 的理念进一步发展，允许管理员不仅检查两个设备之间的通信，还可以看到这对设备之间所有中间设备的列表。它通过让发起主机发送一系列测试数据报，每个数据报的
    TTL 值都设置为在路由上的每个设备上依次超时来实现。`traceroute` 程序还会显示从发送主机到目标设备之间与每个设备通信所需的时间。'
- en: Basic Use of the traceroute Utility
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`traceroute` 工具的基本用法'
- en: '[Example 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili "Example 88-2. Route
    tracing using the traceroute utility") shows an example of a `traceroute` sent
    between two of the UNIX computers I use on a regular basis. I added the `-q2`
    parameter to change the default of three dummy messages per hop to two, so the
    output would fit better on the page.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili "示例 88-2. 使用
    `traceroute` 工具进行路由跟踪") 展示了在两个我经常使用的 UNIX 计算机之间发送的 `traceroute` 示例。我添加了 `-q2`
    参数来将每跳的默认三个虚拟消息更改为两个，以便输出更适合页面。'
- en: Example 88-2. Route tracing using the traceroute utility
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-2. 使用 `traceroute` 工具进行路由跟踪
- en: '[PRE9]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the servers are separated by 14 hops. Notice how the elapsed time
    generally increases as the distance from the transmitting device increases, but
    it is not consistent because of random elements in the delay between any two devices
    (see the incongruously large value in hop 10, for example). Also notice the asterisk
    (*) in the seventh hop, which means that no response was received before the timeout
    period for the second transmission with a TTL value of 7\. Finally, there is no
    report at all for hop 13\. This machine may have been configured not to send Time
    Exceeded messages.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器之间相隔14跳。注意，随着与发送设备距离的增加，经过的时间通常会增加，但由于任何两个设备之间延迟的随机元素，它并不一致（例如，第10跳的不一致的大值）。还要注意第七跳中的星号（*），这意味着在TTL值为7的第二次传输的超时期间没有收到任何响应。最后，第13跳没有任何报告。这台机器可能被配置为不发送超时消息。
- en: Additional unusual results may be displayed under certain circumstances. For
    example, the `traceroute` program may display a code such a `!H`, `!N`, or `!P`
    to indicate receipt of an unexpected Destination Unreachable message for a host,
    network, or protocol, respectively. Other error messages may also exist, depending
    on the implementation.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下可能会显示一些不寻常的结果。例如，`traceroute`程序可能会显示一个代码，如`!H`、`!N`或`!P`，分别表示收到针对主机、网络或协议的意外目的地不可达消息。根据实现，也可能存在其他错误消息。
- en: traceroute Options and Parameters
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: traceroute 选项和参数
- en: As is the case with `ping`, `traceroute` can be used with an IP address or host
    name. If no parameters are supplied, default values will be used for key parameters.
    On the system I use, the defaults are three probes for each TTL value, a maximum
    of 64 hops tested, and packets 40 bytes in size. However, my implementation also
    supports a number of options and parameters to give me more control over how the
    utility functions (such as the `-q` parameter I used in [Example 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili
    "Example 88-2. Route tracing using the traceroute utility")). Some of the typical
    options available in UNIX systems are described in [Table 88-3](ch88s03.html#common_unix_traceroute_utility_options_a
    "Table 88-3. Common UNIX traceroute Utility Options and Parameters"). A smaller
    set of options exists in Windows, as shown in [Table 88-4](ch88s03.html#common_windows_tracert_utility_options_a
    "Table 88-4. Common Windows tracert Utility Options and Parameters").
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ping`类似，`traceroute`可以使用IP地址或主机名。如果没有提供参数，将使用关键参数的默认值。在我使用的系统中，默认值是每个TTL值3个探测，最多测试64跳，数据包大小为40字节。然而，我的实现也支持许多选项和参数，以便我可以更好地控制工具的功能（例如，我在[示例 88-2](ch88s03.html#route_tracing_using_the_traceroute_utili
    "示例 88-2. Route tracing using the traceroute utility")中使用的`-q`参数）。UNIX系统中可用的典型选项在[表 88-3](ch88s03.html#common_unix_traceroute_utility_options_a
    "表 88-3. Common UNIX traceroute Utility Options and Parameters")中描述。Windows中存在一组更小的选项，如[表 88-4](ch88s03.html#common_windows_tracert_utility_options_a
    "表 88-4. Common Windows tracert Utility Options and Parameters")所示。
- en: Table 88-3. Common UNIX traceroute Utility Options and Parameters
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-3. Common UNIX traceroute Utility Options and Parameters
- en: '| Option/Parameters | Description |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-g <`*`host-list`*`>` | Specifies a source route to be used for the trace.
    |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `-g <`*`host-list`*`>` | 指定用于跟踪的源路由。|'
- en: '| `-M <`*`initial-ttl-value`*`>` | Overrides the default value of 1 for the
    initial TTL value of the first outgoing probe message. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `-M <`*`initial-ttl-value`*`>` | 覆盖第一个发出的探测消息的初始TTL值的默认值1。|'
- en: '| `-m <`*`max-ttl-value`*`>` | Sets the maximum TTL value to be used. This
    limits how long a route the utility will attempt to trace. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `-m <`*`max-ttl-value`*`>` | 设置要使用的最大TTL值。这限制了工具尝试跟踪的路由长度。|'
- en: '| `-n` | Displays the route using numeric addresses only, rather than showing
    both IP addresses and host names. This speeds up the display by saving the utility
    from needing to perform reverse DNS lookups on all the devices in the route (ICMP
    messages use IP addresses, not domain names). |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 仅使用数字地址显示路由，而不是同时显示IP地址和主机名。这通过节省工具在路由中的所有设备上执行反向DNS查找的需要来加快显示速度（ICMP消息使用IP地址，而不是域名）。|'
- en: '| `-p <`*`port-number`*`>` | Specifies the port number to be used as the destination
    of the probe messages. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `-p <`*`port-number`*`>` | 指定用作探测消息目的地的端口号。|'
- en: '| `-q <`*`queries`*`>` | Tells the utility how many probes to send to each
    device in the route (the default is 3). |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `-q <`*`queries`*`>` | 告诉工具为路由中的每个设备发送多少个探测（默认为3）。|'
- en: '| `-r` | Tells the program to bypass the normal routing tables and send directly
    to a host on an attached network. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 告诉程序绕过正常路由表，直接发送到连接网络上的主机。|'
- en: '| `-s <`*`src-addr`*`>` | On devices that have multiple IP interfaces (addresses),
    allows the device to use an address from one interface on a `traceroute` using
    another interface. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `-s <`*`源地址`*`>` | 在具有多个 IP 接口（地址）的设备上，允许设备在 `traceroute` 使用另一个接口时使用一个接口的地址。|'
- en: '| `-S` | Instructs the program to display a summary of how many probes did
    not receive a reply. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `-S` | 指示程序显示未收到回复的探测数量摘要。|'
- en: '| `-v` | Sets verbose output mode, which informs the user of all ICMP messages
    received during the trace. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 设置详细输出模式，告知用户在跟踪过程中接收到的所有 ICMP 消息。|'
- en: '| `-w <`*`wait-time`*`>` | Specifies how long the utility should wait for a
    reply to each probe, in seconds (the typical default is 3 to 5). |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `-w <`*`等待时间`*`>` | 指定工具等待每个探测回复的时间长度，以秒为单位（典型默认值为 3 到 5 秒）。|'
- en: Table 88-4. Common Windows tracert Utility Options and Parameters
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-4. 常见 Windows tracert 工具选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| `-d` | Displays the route using numeric addresses only, rather than showing
    both IP addresses and host names, for faster display. This is the same as the
    `-n` option on UNIX systems. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 仅使用数字地址显示路由，而不是同时显示 IP 地址和主机名，以便更快地显示。这在 UNIX 系统上的 `-n` 选项中相同。|'
- en: '| `-h <`*`maximum-hops`*`>` | Specifies the maximum number of hops to use for
    tracing (the default is 30). |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `-h <`*`最大跳数`*`>` | 指定用于跟踪的最大跳数（默认为 30）。|'
- en: '| `-j <`*`host-list`*`>` | Sends the outgoing probes using the specified loose
    source route. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `-j <`*`主机列表`*`>` | 使用指定的松散源路由发送出站探测。|'
- en: '| `-w <`*`wait-time`*`>` | Specifies how long to wait for a reply to each probe,
    in milliseconds (the default is 4,000, for 4 seconds). |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `-w <`*`等待时间`*`>` | 指定等待每个探测回复的时间长度，以毫秒为单位（默认为 4,000 毫秒，即 4 秒）。|'
- en: TCP/IP Address Resolution Protocol Utility (arp)
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 地址解析协议工具 (arp)
- en: All devices on an internetwork are considered to be virtually connected at layer
    3, since the process of routing lets any device communicate with any other device.
    However, there is no way for devices on distant networks to communicate directly.
    The internetwork communication at layer 3 actually consists of a number of steps,
    called *hops*, that carry the data from its source to destination. Each hop in
    a route requires that data be sent between a pair of hardware devices, and each
    transmission must use layer 2 hardware addresses. Since TCP/IP uses layer 3 addresses,
    this means each hop requires that we translate the IP address of the target of
    the hop to a hardware address. This is called *address resolution*; the reasons
    why it is needed and the methods used for it are explained in detail in [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)").
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网中，所有设备都被视为在第三层虚拟连接，因为路由过程允许任何设备与任何其他设备通信。然而，远程网络上的设备无法直接通信。第三层的互联网通信实际上包括多个步骤，称为
    *跳数*，这些跳数将数据从源传输到目的地。路由中的每个跳数都需要在成对的硬件设备之间发送数据，并且每次传输都必须使用第二层的硬件地址。由于 TCP/IP 使用第三层地址，这意味着每个跳数都需要将跳数的目标
    IP 地址转换为硬件地址。这被称为 *地址解析*；为什么需要它以及用于它的方法在 [第 13 章](ch13.html "第 13 章。地址解析与 TCP/IP
    地址解析协议 (ARP)") 中有详细解释。
- en: In TCP/IP, address resolution functions are performed by the aptly named Address
    Resolution Protocol (ARP). When a device needs to transmit to a device with a
    particular IP address, it can use ARP's request/reply messaging protocol to find
    out which hardware device corresponds to that IP address. However, each such message
    exchange takes time and network bandwidth, so for efficiency, every device maintains
    an ARP cache, which is a table containing mappings between IP and hardware addresses.
    The ARP cache table can contain a combination of static cache entries that are
    manually inserted for frequently accessed devices, and dynamic entries, which
    are entered automatically when a request/reply resolution is done. The next time
    it is necessary to send a device mapped in the ARP cache table, the lookup process
    can be avoided.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TCP/IP 中，地址解析功能由恰如其分的名称地址解析协议（ARP）执行。当设备需要向具有特定 IP 地址的设备传输时，它可以使用 ARP 的请求/回复消息协议来找出与该
    IP 地址对应的硬件设备。然而，每次这样的消息交换都需要时间和网络带宽，因此为了效率，每个设备都维护一个 ARP 缓存，这是一个包含 IP 地址和硬件地址之间映射的表。ARP
    缓存表可以包含静态缓存条目的组合，这些条目是手动插入以供频繁访问的设备使用，以及动态条目，这些条目在请求/回复解析完成后自动插入。下次需要向 ARP 缓存表中的设备发送数据时，可以避免查找过程。
- en: 'To allow administrators to manage this ARP cache table, TCP/IP devices include
    an `arp` utility. It has the following three basic functions, which are invoked
    using three different versions of the command (which, for once, are the same in
    UNIX and Windows):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许管理员管理此 ARP 缓存表，TCP/IP 设备包括一个 `arp` 实用程序。它具有以下三个基本功能，这些功能通过使用三个不同的命令版本（这一次，UNIX
    和 Windows 中的命令版本是相同的）来调用：
- en: '**ARP Cache Table Display** When the `-a` option is used with the utility,
    it displays the current contents of the ARP cache table. The syntax is `arp -d
    <`*`host-name`*`>`. Each entry in the table shows the IP address and hardware
    address pair for one device (interface, actually). Usually, it also indicates
    whether each entry is static or dynamic. The exact format of the display varies
    from one implementation to the next; some programs show IP addresses, others show
    host names, and still others may show both. Some systems default to displaying
    host names but allow the `-n` option to also be used to force only IP addresses
    (not names) to be displayed.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARP 缓存表显示** 当使用 `-a` 选项与该实用程序一起使用时，它会显示 ARP 缓存表当前的内容。语法是 `arp -d <`*`主机名`*`>`。表中的每个条目都显示一个设备（接口）的
    IP 地址和硬件地址对。通常，它还指示每个条目是静态的还是动态的。显示的确切格式因实现而异；一些程序显示 IP 地址，其他程序显示主机名，还有一些程序可能两者都显示。某些系统默认显示主机名，但允许使用
    `-n` 选项来强制只显示 IP 地址（而不是名称）。'
- en: '**ARP Cache Table Entry Addition** This version allows an administrator to
    make a new manual ARP cache table entry that maps the given host name to the specified
    hardware address. The syntax is `arp -s <`*`host-name`*`> <`*`hw-addr`*`>`.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARP 缓存表条目添加** 此版本允许管理员创建一个新的手动 ARP 缓存表条目，将给定的主机名映射到指定的硬件地址。语法是 `arp -s <`*`主机名`*`>`
    <`*`硬件地址`*`>`。'
- en: '**ARP Cache Table Entry Deletion** Using `arp` with the `-d` option removes
    the specified cache entry from the table. Some implementations allow the addition
    of another parameter to specify that all entries should be removed from the cache.
    The basic syntax is `arp -d <`*`host-name`*`>`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARP 缓存表条目删除** 使用 `arp` 命令的 `-d` 选项可以从表中删除指定的缓存条目。某些实现允许添加另一个参数来指定应从缓存中删除所有条目。基本语法是
    `arp -d <`*`主机名`*`>`。'
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The TCP/IP arp utility is used by an administrator to inspect
    or modify a host''s ARP cache table, which contains mappings between TCP/IP host
    names and IP addresses.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP 的 arp 实用程序由管理员用于检查或修改主机的 ARP 缓存表，该表包含 TCP/IP 主机名和 IP 地址之间的映射。'
- en: Certain versions of the software may also supplement these basic commands with
    additional features. One common additional option on UNIX systems is the ability
    to specify a file from which cache table entries may be read, using the syntax
    `arp -f <`*`file-name`*`>`. This saves a considerable amount of time and effort
    compared to typing each entry manually using `arp -s`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 某些软件版本也可能通过附加功能来补充这些基本命令。UNIX 系统上常见的附加选项是能够指定一个文件，从中可以读取缓存表条目，使用语法 `arp -f <`*`文件名`*`>`。与手动使用
    `arp -s` 输入每个条目相比，这可以节省大量时间和精力。
- en: Note also that the operating system may allow only authorized users to access
    options that cause the ARP cache table to be changed. This is especially true
    of the delete function.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，操作系统可能只允许授权用户访问可以更改ARP缓存表的选项。这一点在删除功能上尤为明显。
- en: TCP/IP DNS Name Resolution and Lookup Utilities (nslookup, host, and dig)
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP DNS名称解析和查找实用程序（nslookup、host和dig）
- en: 'DNS is a critically important part of TCP/IP internetworks, especially the
    modern Internet, because it allows hosts to be accessed using easily remembered
    names rather than confusing numerical addresses. Two different primary types of
    devices are involved in the operation of DNS: DNS name servers that store information
    about domains and DNS resolvers that query DNS servers to transform names into
    addresses, as well as perform other necessary functions.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: DNS是TCP/IP互连网的一个关键重要部分，特别是现代互联网，因为它允许使用易于记忆的名称而不是令人困惑的数字地址来访问主机。DNS操作涉及两种不同的主要设备类型：存储有关域的信息的DNS名称服务器和查询DNS服务器以将名称转换为地址以及执行其他必要功能的DNS解析器。
- en: DNS resolvers are employed by Internet users on a continual basis to translate
    DNS names into address, but under normal circumstances, they are always invoked
    indirectly. Each time a user types a DNS name into a program such as a web browser
    or File Transfer Protocol (FTP) client—or even uses it in one of the other utilities
    described in this chapter, such as `ping` or `traceroute`—the resolver automatically
    performs the name resolution without the user having to ask. For this reason,
    there is no need for users to manually resolve DNS names into addresses.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网用户持续使用DNS解析器将DNS名称转换为地址，但在正常情况下，它们总是间接调用的。每次用户在网页浏览器或文件传输协议（FTP）客户端等程序中输入DNS名称，或者在其他本章描述的实用程序（如`ping`或`traceroute`）中使用它时，解析器都会自动执行名称解析，而无需用户请求。因此，用户无需手动将DNS名称解析为地址。
- en: 'However, administrators often do need to perform a DNS resolution manually.
    For example, when troubleshooting a problem, the administrator may know a host''s
    name but not its address. In the case of a security problem, the address may show
    up in a log file but the host name may not be known. In addition, even though
    users do not need to know the specifics of the resource records that define a
    DNS domain, administrators often need to be able to check these details, to make
    sure a domain is set up properly. Administrators also need some way to be able
    to diagnose problems with DNS servers themselves. To support all of these needs,
    modern TCP/IP implementations come equipped with one or more DNS name resolution
    and information lookup utilities. Here, we will look at three such utilities:
    `nslookup`, `host`, and `dig`.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，管理员经常需要手动执行DNS解析。例如，在解决问题时，管理员可能知道主机的名称但不知道其地址。在安全问题的案例中，地址可能出现在日志文件中，但主机名称可能未知。此外，尽管用户不需要知道定义DNS域的资源记录的详细信息，但管理员经常需要能够检查这些细节，以确保域设置正确。管理员还需要某种方式来诊断DNS服务器本身的问题。为了支持所有这些需求，现代TCP/IP实现配备了至少一个DNS名称解析和信息查找实用程序。在这里，我们将探讨三个这样的实用程序：`nslookup`、`host`和`dig`。
- en: The nslookup Utility
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`nslookup`实用程序'
- en: 'One of the most common DNS diagnostic utilities is `nslookup` (for name server
    lookup), which has been around for many years. The details of how the program
    is implemented depend on the operating system, though most of them offer versions
    that are quite similar in operation and settings. The utility can normally be
    used in two modes: interactive or noninteractive.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的DNS诊断实用程序之一是`nslookup`（用于名称服务器查找），它已经存在很多年了。程序实现的细节取决于操作系统，尽管它们中的大多数在操作和设置上提供了相当相似版本。该实用程序通常可以在两种模式下使用：交互式或非交互式。
- en: 'The noninteractive version of `nslookup` is the simplest, and it is most often
    used when an administrator wants to just quickly translate a name into an address
    or vice versa. To run this version, issue the `nslookup` command using the following
    simple syntax:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`nslookup`的非交互式版本是最简单的，当管理员只想快速将名称转换为地址或相反时，通常使用此版本。要运行此版本，使用以下简单的语法发出`nslookup`命令：'
- en: '[PRE10]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `<`*`host`*`>` can be a DNS domain name, for performing a normal resolution,
    or it may be an IP address, for a reverse resolution to return the associated
    DNS domain name. The `<`*`server`*`>` parameter is optional; if it's omitted,
    the program uses the default name server of the host where the command was issued.
    [Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u "Example 88-3. DNS
    name resolution using the nslookup utility") shows a simple example of noninteractive
    use of `nslookup`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<`*`host`*`>` 可以是一个 DNS 域名，用于执行正常解析，或者它可能是一个 IP 地址，用于反向解析以返回相关的 DNS 域名。`<`*`server`*`>`
    参数是可选的；如果省略，程序将使用发出命令的主机的默认名称服务器。[示例 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "示例 88-3. 使用 nslookup 工具进行 DNS 名称解析") 显示了 `nslookup` 的非交互式使用的一个简单示例。
- en: Example 88-3. DNS name resolution using the nslookup utility
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-3. 使用 nslookup 工具进行 DNS 名称解析
- en: '[PRE11]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example was done on my home PC that uses the Starband satellite Internet
    service, which is configured to use Starband's name server (`ns1-mar.starband.com`).
    The answer provided here is labeled *non-authoritative*, because it came from
    the Starband name server's DNS cache, rather than one of the DNS name servers
    that is a DNS authority for [www.pcguide.com](http://www.pcguide.com).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是在我使用 Starband 卫星互联网服务的家用电脑上完成的，该服务配置为使用 Starband 的名称服务器 (`ns1-mar.starband.com`)。这里提供的答案被标记为
    *非权威性*，因为它来自 Starband 名称服务器的 DNS 缓存，而不是 [www.pcguide.com](http://www.pcguide.com)
    的 DNS 权威服务器之一。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It is also possible to specify one or more options to modify the behavior
    of the lookup in noninteractive mode. These options are the same as the parameters
    controlled by the* `nslookup` *set command described in [Table 88-5](ch88s05.html#typical_nslookup_utility_commands
    "Table 88-5. Typical nslookup Utility Commands"). They are specified by preceding
    them with a dash. For example*, `nslookup -timeout=10 www.pcguide.com` *would
    perform the same lookup as in [Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "Example 88-3. DNS name resolution using the nslookup utility"), but with the
    timeout interval set to 10 seconds*.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*也可以在非交互模式下指定一个或多个选项来修改查找行为。这些选项与[表 88-5](ch88s05.html#typical_nslookup_utility_commands
    "表 88-5. 典型的 nslookup 工具命令")中描述的由 `nslookup` set 命令控制的参数相同。它们通过在前面加一个破折号来指定。例如，`nslookup
    -timeout=10 www.pcguide.com` 将执行与[示例 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "示例 88-3. 使用 nslookup 工具进行 DNS 名称解析")中相同的查找，但将超时时间设置为 10 秒*。'
- en: The interactive mode of `nslookup` is selected by simply issuing the name of
    the command with no parameters. This will cause the program to display the current
    default name server's DNS name and address, and then provide a prompt at which
    the administrator may enter commands. Interactive mode allows someone to perform
    multiple lookups easily without having to type `nslookup` each time. More important,
    it provides more convenient control over the types of information that can be
    requested and how the lookups are performed.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地不带参数发出命令名，可以选择 `nslookup` 的交互模式。这将导致程序显示当前默认名称服务器的 DNS 名称和地址，然后提供一个提示，管理员可以在其中输入命令。交互模式允许用户轻松地执行多个查找，而无需每次都输入
    `nslookup`。更重要的是，它提供了更方便的控制方式，可以请求哪些类型的信息以及如何执行查找。
- en: You can usually determine the exact command set available in an `nslookup` implementation
    by issuing the command `help` or `?` at the `nslookup` prompt. [Table 88-5](ch88s05.html#typical_nslookup_utility_commands
    "Table 88-5. Typical nslookup Utility Commands") shows some of the commands that
    are usually found in most `nslookup` implementations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过在 `nslookup` 提示符下发出 `help` 或 `?` 命令来确定 `nslookup` 实现中可用的确切命令集。[表 88-5](ch88s05.html#typical_nslookup_utility_commands
    "表 88-5. 典型的 nslookup 工具命令") 显示了大多数 `nslookup` 实现中通常可以找到的一些命令。
- en: Table 88-5. Typical nslookup Utility Commands
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-5. 典型的 nslookup 工具命令
- en: '| Command and Parameters | Description |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 命令和参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<`*`host`*`> [<`*`server`*`>]` | Look up the specified host, optionally
    using the specified DNS name server. Note that there is no actual command here;
    you just enter the name directly at the command prompt. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `<`*`host`*`> [<`*`server`*`>]` | 查找指定的主机，可选地使用指定的 DNS 名称服务器。注意，这里实际上没有命令；你只需在命令提示符中直接输入名称即可。
    |'
- en: '| `server <`*`server`*`>` | Change the default server to `<`*`server`*`>`,
    using information obtained from the current default server. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `server <`*`server`*`>` | 将默认服务器更改为 `<`*`server`*`>`，使用从当前默认服务器获得的信息。 |'
- en: '| `lserver <`*`server`*`>` | Change the default server to `<`*`server`*`>`,
    using information obtained from the initial name server; that is, the system''s
    default server that was in place when the `nslookup` command was started (prior
    to any preceding changes of the current name server in this session). |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `lserver <`*`server`*`>` | 将默认服务器更改为 `<`*`server`*`>`，使用从初始名称服务器获得的信息；即，在启动
    `nslookup` 命令时（在会话中当前名称服务器任何先前更改之前）系统默认的服务器。 |'
- en: '| `root` | Changes the default name server to one of the DNS root name servers.
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `root` | 将默认名称服务器更改为 DNS 根名称服务器之一。 |'
- en: '| `ls [-t <`*`type`*`>] <`*`name`*`>` | Requests a list of information available
    for the specified domain name, by conducting a zone transfer. By default, the
    host names and addresses associated with the domain are listed; the `-t` option
    may be used to restrict the output to a particular record type. Other options
    may also be defined. (Most servers restrict the use of zone transfers to designated
    slave servers, so this command may not work for ordinary clients.) |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `ls [-t <`*`type`*`>] <`*`name`*`>` | 通过执行区域传输请求指定域名可用的信息列表。默认情况下，与域名关联的主机名和地址将被列出；可以使用
    `-t` 选项将输出限制为特定记录类型。还可以定义其他选项。（大多数服务器将区域传输的使用限制为指定的从服务器，因此此命令可能对普通客户端不起作用。） |'
- en: '| `help` | Displays help information (usually a list of valid commands and
    options). |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `help` | 显示帮助信息（通常是有效命令和选项的列表）。 |'
- en: '| `?` | Same as `help` (works on only some systems). |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 与 `help` 相同（仅在某些系统上有效）。 |'
- en: '| `set all` | Displays the current value of all `nslookup` options. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `set all` | 显示所有 `nslookup` 选项的当前值。 |'
- en: '| `set <`*`option`*`>[=<`*`value`*`>]` | Sets an option to control the behavior
    of the utility. Most implementations include quite a number of options, some of
    which are controlled by just specifying a keyword, while others require a value
    for the option. For example, `set recurse` tells the program to use recursive
    resolution, while `set norecurse` turns it off. `set retry=3` sets the number
    of retries to 3. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `set <`*`option`*`>[=<`*`value`*`>]` | 设置一个选项以控制实用工具的行为。大多数实现包括相当多的选项，其中一些只需指定一个关键字即可控制，而其他选项则需要为选项指定一个值。例如，`set
    recurse` 告诉程序使用递归解析，而 `set norecurse` 关闭它。`set retry=3` 将重试次数设置为 3。 |'
- en: '| `exit` | Quits the program. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `exit` | 退出程序。 |'
- en: 'The `nslookup` utility is widely deployed on both UNIX and Windows systems,
    but the program is not without its critics. The complaints about it mainly center
    around its use of nonstandard methods of obtaining information, rather than standard
    resolution routines. I have also read reports that it can produce spurious results
    in some cases. One example of a significant problem with the command is that it
    will abort if it is unable to perform a reverse lookup of its own IP address.
    This can cause confusion, because users mistake that error for an error trying
    to find the name they were looking up. For this and other reasons, a number of
    people in UNIX circles consider `nslookup` to be a hack of sorts. In some newer
    UNIX systems, `nslookup` has been deprecated (still included in the operating
    system for compatibility, but not recommended and may be removed in the future).
    Instead, a pair of newer utilities is provided: `host` and `dig`.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`nslookup` 工具在 UNIX 和 Windows 系统上都得到了广泛部署，但该程序并非没有批评者。对其的投诉主要集中在它使用非标准的信息获取方法，而不是标准的解析例程。我也阅读过一些报告，称在某些情况下它可能会产生虚假的结果。命令的一个重大问题示例是，如果它无法执行其自身
    IP 地址的反向查找，它将终止。这可能会造成混淆，因为用户会将该错误误认为是试图查找他们正在查找的名称时发生的错误。因此，出于这个和其他原因，UNIX 圈中的一些人认为
    `nslookup` 是一种某种形式的黑客行为。在一些较新的 UNIX 系统中，`nslookup` 已被弃用（为了兼容性仍包含在操作系统中，但不推荐，未来可能会被移除）。取而代之的是，提供了一对较新的实用工具：`host`
    和 `dig`。'
- en: The host Utility
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`host` 实用工具'
- en: 'The `host` utility is most often used for simple queries such as those normally
    performed using `nslookup`''s noninteractive mode. It is invoked in the same way
    as noninteractive `nslookup`:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`host` 工具最常用于简单的查询，例如通常使用 `nslookup` 的非交互模式执行的查询。它以与非交互式 `nslookup` 相同的方式调用：'
- en: '[PRE12]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is also similar to that of noninteractive `nslookup`, but less verbose.
    Here is an example:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与非交互式 `nslookup` 的输出类似，但更简洁。以下是一个示例：
- en: '[PRE13]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Even though `host` does not operate interactively, it includes a number of options
    that can allow an administrator to get the same information that would have been
    obtained using `nslookup`'s interactive mode. Some of the more common options
    are shown in [Table 88-6](ch88s05.html#typical_host_utility_options_and_paramet
    "Table 88-6. Typical host Utility Options and Parameters").
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `host` 不支持交互式操作，但它包括一些选项，允许管理员获取使用 `nslookup` 交互模式所获得的信息。一些更常见的选项显示在 [表 88-6](ch88s05.html#typical_host_utility_options_and_paramet
    "表 88-6. 典型的 host 实用程序选项和参数") 中。
- en: Table 88-6. Typical host Utility Options and Parameters
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-6. 典型的 host 实用程序选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-d` | Turns on debug mode. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 打开调试模式。|'
- en: '| `-l` | Provides a complete list of information for a domain; this is similar
    to the `ls` command in interactive `nslookup`. This may be used with the `-t`
    option to select only a particular type of resource record for the domain. |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 为域名提供完整的信息列表；这与交互式 `nslookup` 中的 `ls` 命令类似。这可以与 `-t` 选项一起使用，以仅选择域名中特定类型的资源记录。|'
- en: '| `-r` | Disables recursion in the request. When this is specified, only the
    server directly queried will return any information; it will not query other servers.
    |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 禁用请求中的递归。当指定此选项时，只有直接查询的服务器会返回任何信息；它不会查询其他服务器。|'
- en: '| `-t <`*`query-type`*`>` | Specifies a query for a particular resource record
    type, allowing any type of DNS information to be retrieved. |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `-t <`*`查询类型`*`>` | 指定对特定资源记录类型的查询，允许检索任何类型的 DNS 信息。|'
- en: '| `-v` | Uses verbose mode for output (additional details are provided). |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 使用详细模式输出（提供额外细节）。|'
- en: '| `-w` | Waits as long as necessary for a response (no timeout). |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `-w` | 等待必要的响应时间（无超时）。|'
- en: The dig Utility
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`dig` 实用程序'
- en: The second alternative to `nslookup` is `dig`, which stands for Domain Information
    Groper (likely a play on the supposed origin of the name `ping`). It differs from
    the `host` command in that it provides considerably more information about a domain,
    even when invoked in the simplest of ways. It is also quite a bit more complicated,
    with a large number of options and features, such as a batch mode for obtaining
    information about many domains.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`nslookup` 的第二种选择是 `dig`，代表域名信息探索者（可能是对 `ping` 命名来源的一种戏谑）。它与 `host` 命令不同，即使在最简单的方式下调用，它也提供了关于域的相当多的信息。它也相当复杂，具有大量选项和功能，例如用于获取多个域信息的批处理模式。'
- en: 'The basic syntax for the `dig` command is different from that of `nslookup`
    and `host`. If you specify a nondefault name server, it is prepended with an at
    sign (@) and comes before the host to be looked up. You can also specify a specific
    type of resource record, like this:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig` 命令的基本语法与 `nslookup` 和 `host` 不同。如果您指定了一个非默认的名字服务器，它将以一个符号 `@` 开头，并在要查询的主机之前。您还可以指定特定的资源记录类型，如下所示：'
- en: '[PRE14]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Example 88-4](ch88s05.html#dns_name_resolution_using_the_nslo-id001 "Example 88-4. DNS
    name resolution using the nslookup utility") shows the output from running `dig`
    on the same domain ([www.pcguide.com](http://www.pcguide.com)) that I used as
    an example for nslookup ([Example 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "Example 88-3. DNS name resolution using the nslookup utility")) and `host`. You
    can see that it provides much more information about the domain.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-4](ch88s05.html#dns_name_resolution_using_the_nslo-id001 "示例 88-4. 使用
    nslookup 实用程序进行 DNS 名称解析") 展示了在同一个域名 ([www.pcguide.com](http://www.pcguide.com))
    上运行 `dig` 的输出，我将其用作 `nslookup` ([示例 88-3](ch88s05.html#dns_name_resolution_using_the_nslookup_u
    "示例 88-3. 使用 nslookup 实用程序进行 DNS 名称解析")) 和 `host` 的示例。您可以看到它提供了关于域的更多信息。'
- en: Example 88-4. DNS name resolution using the nslookup utility
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-4. 使用 nslookup 实用程序进行 DNS 名称解析
- en: '[PRE15]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* `dig` *utility is very useful, but has still not been implemented on
    some systems. Fortunately, there is an online* `dig` *utility you can access using
    your browser on the Internet. Find it at* [http://www.gont.com.ar/tools/dig](http://www.gont.com.ar/tools/dig).'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*`dig` 实用程序非常有用，但仍然没有在一些系统上实现。幸运的是，有一个在线的 `dig` 实用程序，您可以通过在互联网上的浏览器访问。在 [http://www.gont.com.ar/tools/dig](http://www.gont.com.ar/tools/dig)
    找到它。*'
- en: The `dig` command includes dozens of options and settings. Since this chapter
    is already getting very long and `dig` is by far the most advanced of the three
    utilities, I will stop here. Consult your system's documentation for the full
    instructions on how `dig` works and a list of its parameters.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig`命令包括数十个选项和设置。由于本章已经非常长，而`dig`是这三个工具中功能最强大的，我将在这里停止。请查阅您系统的文档，以获取有关`dig`如何工作及其参数列表的完整说明。'
- en: Tip
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Most TCP/IP implementations provide one or more utilities that
    can be employed by an administrator to manually resolve DNS domain names to IP
    addresses or perform related searches for DNS information. One of the most common
    is nslookup, which allows a host name to be translated to an address or vice versa;
    it has both interactive and noninteractive modes. On some operating systems, nslookup
    has been replaced by the host utility for simple DNS lookups and by the dig program
    for more detailed inspections of DNS resource information.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 大多数TCP/IP实现提供了一到多个管理员可以使用的工具，这些工具可以手动将DNS域名解析为IP地址或执行相关的DNS信息搜索。其中最常见的是nslookup，它允许将主机名翻译为地址或反之亦然；它具有交互和非交互两种模式。在某些操作系统上，nslookup已被host实用程序替换用于简单的DNS查找，以及dig程序用于更详细地检查DNS资源信息。'
- en: TCP/IP DNS Registry Database Lookup Utility (whois/nicname)
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP DNS注册数据库查找实用程序（whois/nicname）
- en: Utilities such as `nslookup` and `host` allow administrators to resolve a DNS
    domain name to an address and also view detailed information about a domain's
    resource records. There are cases, however, where administrators need to know
    its DNS registration information, rather technical information about a domain.
    This includes details such as which organization owns the domain, when its registration
    expires, and who are the designated contacts who manage it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`nslookup`和`host`这样的实用程序允许管理员将DNS域名解析为地址，并查看有关域名资源记录的详细信息。然而，在某些情况下，管理员需要知道其DNS注册信息，而不是域名的技术信息。这包括诸如哪个组织拥有该域名、其注册何时到期以及谁是被指定的管理联系人等详细信息。
- en: In the early days of DNS, all domain names were centrally registered by a single
    authority, called the Internet Network Information Center (InterNIC or just NIC).
    To allow Internet users to look up information about domains and contacts, InterNIC
    set up a special server. To allow users to retrieve information from this server,
    developers created a protocol called both `nicname` and `whois`. It was initially
    described in RFC 812 (in 1982) and then later in RFC 943 (in 1985). Over time,
    the name `whois` has become the preferred of the two, and it is the one used today
    for the utility program that allows an administrator to look up DNS registration
    data. (It can also be used to look up information about IP addresses, but is used
    for that purpose much less commonly.)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在DNS的早期，所有域名都由一个称为互联网网络信息中心（InterNIC或简称NIC）的单一机构集中注册。为了允许互联网用户查找有关域名和联系人的信息，InterNIC建立了一个特殊的服务器。为了允许用户从该服务器检索信息，开发者创建了一个被称为`nicname`和`whois`的协议。它最初在1982年的RFC
    812中描述，后来在1985年的RFC 943中进一步描述。随着时间的推移，`whois`这个名字已经成为了两个中的首选，并且它是今天用于允许管理员查找DNS注册数据的实用程序的名称。（它也可以用来查找有关IP地址的信息，但用于此目的的频率要低得多。）
- en: As the Internet grew and expanded, it moved away from having a single centralized
    authority. The modern Internet has a hierarchical structure of authorities that
    are responsible for registering domain names in different portions of the DNS
    name space. In recent years, this has been further complicated by the deregulation
    process that allows multiple registries for the generic top-level domains such
    as .COM, .NET, and .ORG. All of this means that more work is needed to look up
    domain registration information, since it is distributed across many databases
    on different servers.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的增长和扩展，它逐渐摆脱了单一集中授权的状态。现代互联网有一个负责在不同DNS名称空间部分注册域名的权威机构的分层结构。近年来，由于允许为通用顶级域名（如.COM、.NET和.ORG）设立多个注册机构的不规范过程，这变得更加复杂。所有这些都意味着查找域名注册信息需要更多的工作，因为这些信息分布在不同的服务器上的许多数据库中。
- en: 'To make it easier for administrators to find information about domains in this
    large distributed database, modern TCP/IP implementations generally come with
    an intelligent version of the `whois` utility. It is able to accept as input the
    name of a domain and automatically locate the appropriate registry in which that
    domain''s information is located. The utility is usually used as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让管理员更容易在这个大型分布式数据库中找到有关域的信息，现代TCP/IP实现通常附带一个智能版的`whois`工具。它能够接受域名作为输入，并自动定位包含该域名信息的适当注册机构。该工具通常按以下方式使用：
- en: '[PRE16]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this syntax, `<`*`domain`*`>` represents the name about which registration
    information is requested. The administrator can use the `-h` parameter to force
    the program to query a particular whois server, but again, this is usually not
    required. Some implementations also include other options that can be used to
    direct queries to particular registries.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语法中，`<domain>`表示请求注册信息的域名。管理员可以使用`-h`参数强制程序查询特定的whois服务器，但通常不需要这样做。一些实现还包括其他选项，可以用来将查询定向到特定的注册机构。
- en: '[Example 88-5](ch88s06.html#dns_domain_registry_lookup_using_the_who "Example 88-5. DNS
    domain registry lookup using the whois program") shows the sample output of the
    `whois` command on a FreeBSD UNIX machine (I have stripped out some of the preliminary
    general information and legal disclaimers to shorten the listing).'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-5](ch88s06.html#dns_domain_registry_lookup_using_the_who "示例 88-5. 使用
    whois 程序进行 DNS 域名注册查询") 展示了在FreeBSD UNIX机器上`whois`命令的示例输出（我已经删除了一些初步的一般信息和法律免责声明以缩短列表）。'
- en: Example 88-5. DNS domain registry lookup using the whois program
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-5. 使用 whois 程序进行 DNS 域名注册查询
- en: '[PRE17]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the registrar of the domain [pcguide.com](http://pcguide.com)
    is pairNIC, the DNS registry division of pair Networks, the company I have used
    for web hosting for many years (since 1997, as you can see). This output is public
    information and lets anyone who has an interest in pcguide.com determine that
    I own the domain and learn how to contact me. (No, 555-5555 is not my real phone
    number.) It also tells them that pair Networks runs the name servers that contain
    domain information for my domain.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，域名[pcguide.com](http://pcguide.com)的注册商是pairNIC，这是pair Networks的DNS注册部门，我多年来（自1997年以来，如你所见）一直在使用的公司。这个输出是公开信息，让任何对pcguide.com感兴趣的人都能确定我拥有该域名，并了解如何联系我。（不，555-5555不是我的真实电话号码。）它还告诉他们，pair
    Networks运行包含我的域名信息的名称服务器。
- en: Many operating systems, including Windows, do not come with a `whois` command
    implementation, but there are third-party programs that will support the function.
    In recent years, many different organizations have also set up websites that implement
    the `whois` function, which is much more convenient and user-friendly to those
    more accustomed to graphical user interface operating systems like Windows. Many
    of these sites are provided as free services by DNS registrars, so customers can
    check if a name they are interested in is already taken, and if so, by whom.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作系统，包括Windows，都没有附带`whois`命令的实现，但有一些第三方程序将支持该功能。近年来，许多不同的组织也建立了实施`whois`功能的网站，对于那些更习惯于Windows等图形用户界面操作系统的用户来说，这要方便得多。许多这些网站都是由DNS注册商提供的免费服务，因此客户可以检查他们感兴趣的名称是否已被占用，如果是的话，由谁占用。
- en: One drawback of some of these systems is that they usually do not have the intelligence
    to check all the different registries where domain name records are stored. In
    most cases, a `whois` service provided by a registrar will search for names only
    in the particular top-level domains in which the registrar operates. So, if the
    registrar deals with .COM, .ORG, and .NET, it may support `whois` queries only
    for those top-level domains. To check the registration information for domains
    in more obscure domains, such as some of the less common geopolitical (country
    code) domains, a considerable amount of searching may be required.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统的一些缺点是，它们通常没有智能地检查存储域名记录的所有不同注册机构。在大多数情况下，注册商提供的`whois`服务只会搜索注册商运营的特定顶级域名中的名称。因此，如果注册商处理.COM、.ORG和.NET，它可能只支持那些顶级域的`whois`查询。要检查更不为人知的域名（如一些不太常见的地理政治（国家代码）域名）的注册信息，可能需要进行相当多的搜索。
- en: Tip
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The TCP/IP `whois` utility allows registration information
    to be displayed for a DNS domain, such as its owner, contact information, and
    the date that its registration expires. The program is most commonly found on
    UNIX operating systems, where it is given intelligence that allows it to automatically
    query the correct servers to find the information for most domains. Newer Web-based
    `whois` utilities also exist, but they are usually limited to displaying information
    about domains in only a specific subset of top-level domains.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP 的 `whois` 实用程序允许显示 DNS 域的注册信息，例如其所有者、联系信息和注册到期日期。该程序最常见于 UNIX
    操作系统，其中它被赋予了智能，允许它自动查询正确的服务器以找到大多数域的信息。较新的基于 Web 的 `whois` 实用程序也存在，但它们通常仅限于显示特定顶级域子集的域信息。'
- en: TCP/IP Network Status Utility (netstat)
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 网络状态实用程序（netstat）
- en: Given how complex TCP/IP is, it's actually quite amazing that most of the time,
    all of the different protocols, services, and programs perform their jobs both
    efficiently and silently. Most of us don't even realize just how much is going
    on in the background, and that's as it should be. On the other hand, when a problem
    does occur on a TCP/IP network, the administrator charged with fixing it needs
    to obtain as much information as possible about what all those bits and pieces
    of the suite are doing behind the scenes. The network status utility, `netstat`,
    serves this purpose.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 TCP/IP 的复杂性，实际上，大多数时候，所有不同的协议、服务和程序都能高效且无声地完成它们的工作，这实际上是非常令人惊讶的。我们大多数人甚至都没有意识到后台正在进行多少工作，而这正是应该如此。另一方面，当
    TCP/IP 网络出现问题时，负责修复问题的管理员需要尽可能多地了解套件背后所有这些片段和部分都在做什么。网络状态实用程序 `netstat` 就是为了这个目的。
- en: 'The `netstat` program is very simple in concept, being designed for only one
    purpose: to show information about the operation of TCP/IP on a device. The complexity
    of TCP/IP, however, leads to `netstat` being rather elaborate itself. The program
    can provide a large variety of information. As usual, the options and output of
    `netstat` depend on the particular operating system type and version. It is somewhat
    different on UNIX and Windows machines, so I will describe each platform''s version
    separately.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat` 程序在概念上非常简单，它被设计为只有一个目的：显示设备上 TCP/IP 运行的信息。然而，TCP/IP 的复杂性使得 `netstat`
    本身相当复杂。该程序可以提供大量信息。通常，`netstat` 的选项和输出取决于特定的操作系统类型和版本。在 UNIX 和 Windows 机器上有所不同，因此我将分别描述每个平台的版本。'
- en: The UNIX netstat Utility
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNIX netstat 实用程序
- en: On most UNIX systems, the `netstat` utility is very full-featured, with a typical
    implementation including dozens of options that can be used to control what information
    is displayed. These options may not all be used simultaneously; rather, they are
    arranged into option groups, each of which presents one class of information.
    Within each group, one option is mandatory, and that is the one that identifies
    the group, and hence the general kind of information that will be displayed. Other
    options are also possible in each group, which are optional and modify the command
    to provide better control of exactly what is output. In essence, `netstat` is
    like many related utilities rolled into one.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 UNIX 系统上，`netstat` 实用程序功能非常全面，典型的实现包括数十个选项，可以用来控制显示哪些信息。这些选项可能不会同时使用；相反，它们被组织成选项组，每个选项组展示一类信息。在每个组内，一个选项是强制性的，即标识该组的选项，因此也会显示一般类型的信息。每个组内还可能有其他选项，它们是可选的，并修改命令以提供对输出的更好控制。本质上，`netstat`
    就像许多相关实用程序合并为一个。
- en: '[Table 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio "Table 88-7. Typical
    UNIX netstat Option Groups, Options, and Parameters") provides a simplified summary
    of the option groups for a typical UNIX `netstat` implementation, in this case
    FreeBSD.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio "表 88-7. 典型的
    UNIX netstat 选项组，选项和参数") 提供了典型 UNIX `netstat` 实现的选项组简化总结，在此例中为 FreeBSD。'
- en: Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-7. 典型的 UNIX netstat 选项组、选项和参数
- en: '| Option Group, Options, and Parameters | Description |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 选项组、选项和参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `netstat [-AaLSW] [-f <`*`family`*`>] [-p <`*`protocol`*`>] [-n]` | Default
    invocation of `netstat`, with no mandatory options. It prompts the utility to
    display a list of active sockets on the host machine. The other options shown
    can be used to control what precisely is output; for example, `-a` also shows
    server processes. |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `netstat [-AaLSW] [-f <`*`family`*`>] [-p <`*`protocol`*`>] [-n]` | 默认的 `netstat`
    调用，没有强制选项。它提示实用程序显示主机机器上的活动套接字列表。显示的其他选项可以用来控制精确输出内容；例如，`-a` 也会显示服务器进程。 |'
- en: '| `netstat -i [-abdt] [-f <`*`family`*`>] [-n] netstat -I <`*`interface`*`>
    [-abdt] [-f <`*`family`*`>] [-n]` | Tells `netstat` to provide information about
    all network interfaces (`-i`) or a particular network interface (`-I <`*`interface`*`>`).
    The `-a` option shows multicast addresses as well, `-b` displays bytes of data
    in and out on the interface, `-d` shows the number of dropped packets, and `-t`
    displays the value of watchdog timers. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -i [-abdt] [-f <`*`family`*`>] [-n] netstat -I <`*`interface`*`>
    [-abdt] [-f <`*`family`*`>] [-n]` | 告诉 `netstat` 提供所有网络接口（`-i`）或特定网络接口（`-I <`*`interface`*`>`）的信息。`-a`
    选项还显示多播地址，`-b` 显示接口上进出数据的字节数，`-d` 显示丢弃的报文数量，`-t` 显示看门狗定时器的值。 |'
- en: '| `netstat -w <`*`interval`*`> -d [-I <`*`interface`*`>]` | Displays packet
    traffic information on all interfaces every `<`*`interval`*`>` seconds, or just
    on the specified interface if `-I <`*`interface`*`>` is included. If `-d` is included,
    it also indicates the number of dropped packets. |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -w <`*`interval`*`> -d [-I <`*`interface`*`>]` | 每 `<`*`interval`*`>`
    秒显示所有接口的报文流量信息，或者如果包含 `-I <`*`interface`*`>`，则仅显示指定接口的信息。如果包含 `-d`，则还指示丢弃的报文数量。
    |'
- en: '| `netstat -s [-s] [-z] [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | Shows
    systemwide statistics for each of the protocols on the system (which may be modified
    to show information for only a particular address family or protocol). If the
    `-s` option is repeated, counters that have a value of zero are suppressed. The
    `-z` option resets the statistics after they are displayed. |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -s [-s] [-z] [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | 显示系统上每个协议的全局统计信息（可能修改为仅显示特定地址族或协议的信息）。如果重复使用
    `-s` 选项，则抑制值为零的计数器。使用 `-z` 选项在显示统计信息后重置统计信息。 |'
- en: '| `netstat -i -s [-f <`*`family`*`>] [-p <`*`protocol`*`>] netstat -I <`*`interface`*`>
    -s [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | Displays statistics as for `netstat
    -s`, but on a per-interface basis rather than aggregated for the whole system.
    |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -i -s [-f <`*`family`*`>] [-p <`*`protocol`*`>] netstat -I <`*`interface`*`>
    -s [-f <`*`family`*`>] [-p <`*`protocol`*`>]` | 显示与 `netstat -s` 相同的统计信息，但基于每个接口而不是整个系统的汇总。
    |'
- en: '| `netstat -m` | Outputs memory management routine statistics. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -m` | 输出内存管理例程统计信息。 |'
- en: '| `netstat -r [-Aa] [-f <`*`family`*`>] [-n] [-W]` | Displays the contents
    of the host''s routing tables. The options `-A` and `-a` provide additional information
    about the routes. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -r [-Aa] [-f <`*`family`*`>] [-n] [-W]` | 显示主机的路由表内容。`-A` 和 `-a`
    选项提供有关路由的附加信息。 |'
- en: '| `netstat -rs [-s]` | Displays routing statistics. The `-s` option suppresses
    counters with a zero value. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -rs [-s]` | 显示路由统计信息。`-s` 选项抑制值为零的计数器。 |'
- en: '| `netstat -g [-W] [-f <`*`family`*`>]` | Shows multicast routing information.
    |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -g [-W] [-f <`*`family`*`>]` | 显示多播路由信息。 |'
- en: '| `netstat -gs [-s] [-f <`*`family`*`>]` | Shows multicast routing statistics.
    The `-s` option suppresses counters with a zero value. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -gs [-s] [-f <`*`family`*`>]` | 显示多播路由统计信息。`-s` 选项抑制值为零的计数器。 |'
- en: Most of the options shown in the option groups in [Table 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio
    "Table 88-7. Typical UNIX netstat Option Groups, Options, and Parameters") are
    particular to those groups; for example, you cannot use `-s` when issuing the
    command `netstat -i`. However, there are also a number of universal options that
    can be used with more than one of these groups to modify the behavior of `netstat`
    variations in a consistent way. These options are described in [Table 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "Table 88-8. Typical UNIX netstat Universal Options and Parameters").
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在 [表 88-7](ch88s07.html#typical_unix_netstat_option_groups_optio "表 88-7.
    典型 UNIX netstat 选项组、选项和参数") 中的选项特定于这些组；例如，在发出 `netstat -i` 命令时不能使用 `-s`。然而，也有一些通用选项可以与这些组中的多个组合使用，以一致的方式修改
    `netstat` 变体的行为。这些选项在 [表 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "表 88-8. 典型 UNIX netstat 通用选项和参数") 中描述。
- en: Table 88-8. Typical UNIX netstat Universal Options and Parameters
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-8. 典型 UNIX netstat 通用选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-f <`*`family`*`>` | Limits the output of the command to information on
    a particular protocol address family, for hosts running multiple protocol suites.
    For example, the address family for regular TCP/IP is `inet`; for IPv6, it is
    `inet6`. Others may also be supported. |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `-f <`*`地址族`*`>` | 限制命令的输出只显示特定协议地址族的信息，对于运行多个协议套件的宿主。例如，常规 TCP/IP 的地址族是
    `inet`；对于 IPv6，它是 `inet6`。其他也可能被支持。 |'
- en: '| `-p <`*`protocol`*`>` | Restricts output to data related only to a particular
    protocol, such as IP, TCP, UDP, or ICMP. |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| `-p <`*`协议`*`>` | 限制输出只显示与特定协议相关的数据，例如 IP、TCP、UDP 或 ICMP。 |'
- en: '| `-n` | Shows network addresses in numeric form, instead of showing them as
    symbolic names. Also shows ports as numbers instead of converting well-known UDP
    and TCP port numbers to the protocol names that use them (for example, 23 rather
    than telnet). |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 以数字形式显示网络地址，而不是以符号名称显示。还以数字形式显示端口号，而不是将已知的 UDP 和 TCP 端口号转换为使用它们的协议名称（例如，23
    而不是 telnet）。 |'
- en: '| `-W` | Suppresses the automatic truncation of addresses (which is sometimes
    done for display formatting). |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `-W` | 禁止自动截断地址（有时为了显示格式而这样做）。 |'
- en: 'The `netstat` command can produce a startling amount of output, especially
    if you do not restrict it with some of the options in [Table 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "Table 88-8. Typical UNIX netstat Universal Options and Parameters"). This is
    particularly true for `netstat` by itself and with the `-s` option. [Example 88-6](ch88s07.html#sample_connections_list_from_the_unix_ne
    "Example 88-6. Sample connections list from the UNIX netstat utility") shows sample
    output from running "plain" `netstat`, but I have truncated the list of connections
    so it would not be too long (I also reformatted the listing so it would fit on
    the page better). Notice the last column, which shows the current state of the
    TCP connection (see the TCP finite state machine description in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION")).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat` 命令可以产生大量的输出，尤其是如果你没有使用 [表 88-8](ch88s07.html#typical_unix_netstat_universal_options_a
    "表 88-8. 典型的 UNIX netstat 通用选项和参数") 中的某些选项进行限制。这对于单独使用 `netstat` 以及使用 `-s` 选项尤其如此。[示例
    88-6](ch88s07.html#sample_connections_list_from_the_unix_ne "示例 88-6. 来自 UNIX
    netstat 工具的样本连接列表") 展示了运行 "plain" `netstat` 的样本输出，但我已经截断了连接列表，使其不会太长（我还重新格式化了列表，以便更好地适应页面）。注意最后一列，它显示了
    TCP 连接的当前状态（参见 [第 47 章](ch47.html "第 47 章. TCP 基本操作：连接建立、管理和终止") 中的 TCP 有限状态机描述）。'
- en: Example 88-6. Sample connections list from the UNIX netstat utility
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-6. 来自 UNIX netstat 工具的样本连接列表
- en: '[PRE18]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Example 88-7](ch88s07.html#sample_ip_statistics_from_the_unix_netst "Example 88-7. Sample
    IP statistics from the UNIX netstat utility") shows an example of the output of
    `netstat -s.` Here, I have limited the output by using `-p ip` to tell the program
    to show me only the statistics for IP.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-7](ch88s07.html#sample_ip_statistics_from_the_unix_netst "示例 88-7. 来自
    UNIX netstat 工具的样本 IP 统计信息") 展示了 `netstat -s.` 的输出示例。在这里，我通过使用 `-p ip` 限制了输出，告诉程序只显示与
    IP 相关的统计信息。'
- en: Example 88-7. Sample IP statistics from the UNIX netstat utility
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-7. 来自 UNIX netstat 工具的样本 IP 统计信息
- en: '[PRE19]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Windows netstat Utility
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows netstat 工具
- en: The Windows `netstat` utility is quite a bit simpler than the UNIX one, because
    it has a lot fewer options. This is good news for those learning about the program,
    but not so wonderful for those who want maximum power and flexibility in using
    it.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Windows `netstat` 工具比 UNIX 版本简单得多，因为它有更少的选项。这对于学习该程序的人来说是个好消息，但对于那些希望在使用它时获得最大功能和灵活性的人来说，可能就不是那么好了。
- en: Like the UNIX `netstat` version, the Windows utility has a set of options groups
    that dictate the general type of information shown, and a few universal options
    that can be used with multiple groups. The option groups and generic options are
    shown in Tables [Table 88-9](ch88s07.html#typical_windows_netstat_option_groups_op
    "Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters")
    and [Table 88-10](ch88s07.html#typical_windows_netstat_universal_option "Table 88-10. Typical
    Windows netstat Universal Options and Parameters"), respectively.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UNIX `netstat` 版本一样，Windows 工具有一组选项组，用于指定显示的一般信息类型，以及一些可以与多个组一起使用的通用选项。选项组和通用选项分别显示在
    [表 88-9](ch88s07.html#typical_windows_netstat_option_groups_op "表 88-9. 典型的 Windows
    netstat 选项组和参数") 和 [表 88-10](ch88s07.html#typical_windows_netstat_universal_option
    "表 88-10. 典型的 Windows netstat 通用选项和参数") 中。
- en: Table 88-9. Typical Windows netstat Option Groups, Options, and Parameters
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-9. 常见的 Windows netstat 选项组、选项和参数
- en: '| Option Group, Options, and Parameters | Description |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 选项组、选项和参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `netstat [-n] [-o] [<`*`interval`*`>] netstat -a [-n] [-o]` | When called
    with no mandatory options, `netstat` displays information about active TCP connections.
    |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `netstat [-n] [-o] [<`*`间隔`*`>] netstat -a [-n] [-o]` | 当不带强制选项调用时，`netstat`
    显示有关活动 TCP 连接的信息。|'
- en: '| `[-p <`*`protocol`*`> [<`*`interval`*`>]` | Displays all active TCP connections,
    as well as both TCP and UDP ports to which the host is listening. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `[-p <`*`协议`*`> [<`*`间隔`*`>]` | 显示所有活动的 TCP 连接，以及主机正在监听的所有 TCP 和 UDP 端口。|'
- en: '| `netstat -e [<`*`interval`*`>]` | Shows statistics for Ethernet interfaces.
    |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -e [<`*`间隔`*`>]` | 显示以太网接口的统计信息。|'
- en: '| `netstat -r [<`*`interval`*`>]` | Displays the current routing table for
    the device. |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -r [<`*`间隔`*`>]` | 显示设备的当前路由表。|'
- en: '| `netstat -s [-p <`*`protocol`*`>] [<`*`interval`*`>]` | Displays TCP/IP statistics
    for the system by protocol. |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| `netstat -s [-p <`*`协议`*`>] [<`*`间隔`*`>]` | 通过协议显示系统的 TCP/IP 统计信息。|'
- en: Table 88-10. Typical Windows netstat Universal Options and Parameters
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-10. 常见的 Windows netstat 通用选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-n` | Displays network addresses in numeric form instead of symbolic name
    form. Also shows ports in numeric form instead of displaying standard process
    names associated with well-known UDP or TCP port numbers. |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 以数字形式显示网络地址，而不是符号名称形式。还以数字形式显示端口，而不是显示与知名 UDP 或 TCP 端口号关联的标准进程名称。|'
- en: '| `-o` | Displays the process ID associated with each connection. |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `-o` | 显示与每个连接关联的进程 ID。|'
- en: '| `-p <`*`protocol`*`>` | Limits the display to only the information associated
    with the specified protocol. |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `-p <`*`协议`*`>` | 限制显示仅与指定协议关联的信息。|'
- en: '| `<`*`interval`*`>` | Causes the `netstat` command to be repeated every `<`*`interval`*`>`
    seconds, rather than just displaying its information once. This can be used with
    any of the `netstat` option groups. For example, `netstat -s 5` displays TCP/IP
    statistics every 5 seconds. |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `<`*`间隔`*`>` | 使 `netstat` 命令每隔 `<`*`间隔`*`>` 秒重复一次，而不仅仅是显示其信息一次。这可以与任何 `netstat`
    选项组一起使用。例如，`netstat -s 5` 每 5 秒显示一次 TCP/IP 统计信息。|'
- en: The output from the Windows `netstat` program is fairly similar to that of the
    UNIX utility when the same or similar options are given, but the UNIX version
    usually provides more details. [Example 88-8](ch88s07.html#sample_icmp_statistics_from_the_windows_
    "Example 88-8. Sample ICMP statistics from the Windows netstat utility") shows
    an example illustrating TCP/IP statistics on my home Windows XP machine, using
    `-p icmp` to restrict the output to ICMP statistics only.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供相同或类似选项时，Windows `netstat` 程序的输出与 UNIX 工具的输出相当相似，但 UNIX 版本通常提供更多详细信息。[示例
    88-8](ch88s07.html#sample_icmp_statistics_from_the_windows_ "示例 88-8. Windows
    netstat 工具的样本 ICMP 统计信息") 展示了一个示例，说明如何在我的家用 Windows XP 机器上使用 `-p icmp` 限制输出仅显示
    ICMP 统计信息。
- en: Example 88-8. Sample ICMP statistics from the Windows netstat utility
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-8. Windows netstat 工具的样本 ICMP 统计信息
- en: '[PRE20]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 88-9](ch88s07.html#sample_routing_table_display_from_the_wi "Example 88-9. Sample
    routing table display from the Windows netstat utility") shows the routing table
    display from `netstat` (which I modified slightly to fit the page). You would
    get similar output using the UNIX `netstat -s -p icmp` or `netstat -r` command,
    but with additional information.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-9](ch88s07.html#sample_routing_table_display_from_the_wi "示例 88-9. Windows
    netstat 工具的样本路由表显示") 展示了 `netstat`（我稍作修改以适应页面）的路由表显示。您可以使用 UNIX 的 `netstat -s
    -p icmp` 或 `netstat -r` 命令获得类似的输出，但包含更多信息。'
- en: Example 88-9. Sample routing table display from the Windows netstat utility
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-9. Windows netstat 工具的样本路由表显示
- en: '[PRE21]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP/IP implementations include the `netstat` utility to allow
    information about network status to be displayed. On UNIX systems, `netstat` is
    a full-featured program with many options arranged into option groups, each of
    which shows a particular type of information about the operation of TCP/IP protocols.
    On Windows systems, `netstat` is somewhat more limited in function, but it still
    can display a considerable amount of information.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP 实现包括 `netstat` 工具，以便显示有关网络状态的信息。在 UNIX 系统上，`netstat` 是一个功能齐全的程序，具有许多选项，这些选项被组织成选项组，每个选项组都显示有关
    TCP/IP 协议操作特定类型的信息。在 Windows 系统上，`netstat` 的功能相对有限，但它仍然可以显示大量信息。'
- en: TCP/IP Configuration Utilities (ifconfig, ipconfig, and winipcfg)
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP 配置工具（ifconfig、ipconfig 和 winipcfg）
- en: A significant part of any network administrator's job is setting up and maintaining
    the devices that make a TCP/IP network function, a process generally called *configuration*.
    Networked hosts consist of both hardware and software that work together to implement
    all the layers and functions of the protocol stack. An administrator uses hardware
    tools to configure physical devices, performing tasks such as installing network
    interface cards, connecting cables, and manipulating switches and other hardware
    settings. Similarly, administrators need tools to configure the software that
    runs TCP/IP interfaces and controls the operation of higher-layer protocols on
    networked hosts. UNIX administrators use the `ifconfig` utility. On Windows NT,
    2000, and XP, the configuration tool is `ipconfig`. Earlier versions of Windows
    have the `winipcfg` utility.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理员工作的一个重要部分是设置和维护使 TCP/IP 网络功能的各种设备，这个过程通常被称为 *配置*。网络主机由硬件和软件组成，它们协同工作以实现协议栈的所有层和功能。管理员使用硬件工具来配置物理设备，执行安装网络接口卡、连接电缆、操作开关和其他硬件设置等任务。同样，管理员需要工具来配置运行
    TCP/IP 接口并控制网络主机上高层协议操作的软件。UNIX 管理员使用 `ifconfig` 工具。在 Windows NT、2000 和 XP 上，配置工具是
    `ipconfig`。Windows 的早期版本有 `winipcfg` 工具。
- en: The ifconfig Utility for UNIX
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UNIX 的 ifconfig 工具
- en: On UNIX systems, administrators use the interface configuration utility, `ifconfig`,
    to view and modify the software settings that control how TCP/IP functions on
    a host. It is a very powerful program that allows an administrator to set up and
    manage a very wide array of network settings. The implementation of `ifconfig`
    varies greatly between flavors of UNIX; while most are similar in general terms,
    they may have different options and syntaxes.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 系统中，管理员使用接口配置工具 `ifconfig` 来查看和修改控制主机上 TCP/IP 功能的软件设置。这是一个非常强大的程序，允许管理员设置和管理非常广泛的网络设置。`ifconfig`
    在不同类型的 UNIX 中的实现差异很大；虽然它们在一般术语上相似，但它们可能有不同的选项和语法。
- en: 'You can use the `ifconfig` program for a variety of purposes: to create or
    remove a network interface, change its settings, or simply examine the existing
    configuration. Thus, like the `netstat` utility, `ifconfig` is like several related
    programs combined into one, and how it works depends on the syntax you used to
    invoke it. And also like `netstat`, `ifconfig` has a number of universal options
    that can be applied to many of its different uses.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `ifconfig` 程序进行各种目的：创建或删除网络接口、更改其设置，或者简单地检查现有配置。因此，像 `netstat` 工具一样，`ifconfig`
    将几个相关程序合并为一个，其工作方式取决于您调用它的语法。同样，像 `netstat` 一样，`ifconfig` 有许多通用选项可以应用于其许多不同用途。
- en: '[Table 88-11](ch88s08.html#typical_unix_ifconfig_syntaxes_options_a "Table 88-11. Typical
    UNIX ifconfig Syntaxes, Options, and Parameters") provides a simplified summary
    of the different functions that `ifconfig` can perform and the syntaxes that are
    used to specify each in a typical UNIX implementation (NetBSD in this case). You
    can use `ifconfig` to modify an interface''s configuration by setting any of several
    dozen configuration parameters, using the syntax shown in the last row of that
    table. [Table 88-12](ch88s08.html#typical_unix_ifconfig_universal_options_ "Table 88-12. Typical
    UNIX ifconfig Universal Options and Parameters") describes the common options
    and parameters that can be used for many of these different modes. I have provided
    a brief description of some sample parameters in [Table 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters") (see
    your `ifconfig` documentation for a complete list).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 88-11](ch88s08.html#typical_unix_ifconfig_syntaxes_options_a "表 88-11. 典型
    UNIX ifconfig 语法、选项和参数") 提供了 `ifconfig` 可以执行的不同功能以及用于在典型 UNIX 实现（本例中为 NetBSD）中指定每个功能的语法的简化总结。您可以使用
    `ifconfig` 通过设置几十个配置参数之一来修改接口的配置，使用表中最后一行所示的语法。[表 88-12](ch88s08.html#typical_unix_ifconfig_universal_options_
    "表 88-12. 典型 UNIX ifconfig 通用选项和参数") 描述了可用于许多不同模式的常见选项和参数。我在 [表 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "表 88-13. 典型 UNIX ifconfig 接口配置参数") 中提供了一些样本参数的简要说明（有关完整列表，请参阅您的 `ifconfig` 文档）。'
- en: Table 88-11. Typical UNIX ifconfig Syntaxes, Options, and Parameters
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-11. 典型 UNIX ifconfig 语法、选项和参数
- en: '| Syntax, Options and Parameters | Description |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 语法、选项和参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ifconfig [-L] [-m] <`*`interface`*`>` | When `ifconfig` is called with just
    an interface specification and no other options (other than possibly `-L` and
    `-m`), it displays the configuration information for that network interface.Note
    that entering `ifconfig` by itself with no interface displays just help information
    for the parameter. To see all interfaces, use the `-a` parameter. |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig [-L] [-m] <`*`interface`*`>` | 当仅使用接口指定（除 `-L` 和 `-m` 之外）调用 `ifconfig`
    时，它显示该网络接口的配置信息。请注意，仅输入 `ifconfig` 而不指定接口将仅显示参数的帮助信息。要查看所有接口，请使用 `-a` 参数。|'
- en: '| `ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [<`*`family`*`>]` | Displays information
    about all the interfaces on the host. The output may be restricted using the universal
    parameters shown or by specifying an address family (see [Table 88-12](ch88s08.html#typical_unix_ifconfig_universal_options_
    "Table 88-12. Typical UNIX ifconfig Universal Options and Parameters")). |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig -a [-L] [-m] [-b] [-d] [-u] [-s] [<`*`family`*`>]` | 显示主机上所有接口的信息。可以使用显示的通用参数或指定地址族来限制输出（参见[表
    88-12](ch88s08.html#typical_unix_ifconfig_universal_options_ "表 88-12. 典型的 UNIX
    ifconfig 通用选项和参数")).|'
- en: '| `ifconfig -l [-b] [-d] [-u] [-s]` | Lists all available interfaces on the
    system. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig -l [-b] [-d] [-u] [-s]` | 列出系统上所有可用的接口。|'
- en: '| `ifconfig <`*`interface`*`> create` | Creates the specified logical network
    interface on the host, which is then configured using the syntax shown in the
    last row of this table. Note that some variations of UNIX allow certain parameters
    to be set at the time of creation. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig <`*`interface`*`> create` | 在主机上创建指定的逻辑网络接口，然后使用此表中最后一行所示的语法进行配置。请注意，某些
    UNIX 变体允许在创建时设置某些参数。|'
- en: '| `ifconfig <`*`interface`*`> destroy` | Destroys the specified logical interface.
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig <`*`interface`*`> destroy` | 销毁指定的逻辑接口。|'
- en: '| `ifconfig <`*`interface`*`> [<`*`family`*`>] [<`*`address`*`> [<`*`dest-address`*`>]]
    [<`*`parameters`*`>]` | Configures parameters for a particular interface on the
    host. If the address is being set, it is the first parameter specified, after
    the optional address family, if present. The `<dest-address>` is used to specify
    a destination address for a point-to-point link. After this, any of several dozen
    parameters may be specified for the interface, some of which are shown in [Table 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters"). |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `ifconfig <`*`interface`*`> [<`*`family`*`>] [<`*`address`*`> [<`*`dest-address`*`>]]
    [<`*`parameters`*`>]` | 配置主机上特定接口的参数。如果正在设置地址，则它是可选地址族之后的第一个参数。`<dest-address>`
    用于指定点对点链路的目标地址。之后，可以指定几十个参数来配置接口，其中一些在[表 88-13](ch88s08.html#typical_unix_ifconfig_interface_configur
    "表 88-13. 典型的 UNIX ifconfig 接口配置参数")中显示。|'
- en: Table 88-12. Typical UNIX ifconfig Universal Options and Parameters
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-12. 典型的 UNIX ifconfig 通用选项和参数
- en: '| Option/Parameter | Description |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-L` | Displays the address lifetime for IPv6 addresses. |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| `-L` | 显示 IPv6 地址的地址生存时间。|'
- en: '| `-m` | Displays all supported media for the interface. |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `-m` | 显示接口支持的所有媒体。|'
- en: '| `-b` | Limits the display of interface information to broadcast interfaces.
    |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `-b` | 将接口信息显示限制为广播接口。|'
- en: '| `-d` | Shows only interfaces that are presently down (disabled). |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 仅显示当前处于关闭状态（禁用）的接口。|'
- en: '| `-u` | Shows only interfaces that are presently up (operational). |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 仅显示当前处于开启状态（操作中）的接口。|'
- en: '| `-s` | Shows only interfaces that may be connected. |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 仅显示可能连接的接口。|'
- en: '| `<`*`family`*`>` | Specifies a particular address family, either to limit
    output or indicate what address type is being configured. The value `inet` is
    used for IPv4 and `inet6` for IPv6. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `<`*`family`*`>` | 指定特定的地址族，用于限制输出或指示正在配置的地址类型。值 `inet` 用于 IPv4，`inet6` 用于
    IPv6。|'
- en: Table 88-13. Typical UNIX ifconfig Interface Configuration Parameters
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-13. 典型的 UNIX ifconfig 接口配置参数
- en: '| Parameters | Description |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `alias / -alias` | Establishes or removes a network address alias. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `alias / -alias` | 建立或删除网络地址别名。|'
- en: '| `arp / -arp` | Enables or disables the use of ARP on this interface. |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `arp / -arp` | 启用或禁用在此接口上使用 ARP。|'
- en: '| `delete` | Removes the specified network address. |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 删除指定的网络地址。|'
- en: '| `down` | Marks an interface as being down, disabling it. |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `down` | 将接口标记为已关闭，禁用它。|'
- en: '| `media <`*`type`*`>` | Sets the media type of the interface to a particular
    value. |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `media <`*`type`*`>` | 将接口的媒体类型设置为特定值。|'
- en: '| `mtu <`*`n`*`>` | Sets the maximum transmission unit (MTU) of the interface.
    |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `mtu <`*`n`*`>` | 设置接口的最大传输单元（MTU）。|'
- en: '| `netmask <`*`mask`*`>` | Sets the network or subnet mask for the interface''s
    address. |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `netmask <`*`掩码`*`>` | 为接口地址设置网络或子网掩码。|'
- en: '| `pref`ixlen <*`n`*`>` | Same as `netmask` but allows the mask to be specified
    using a CIDR-style prefix length. |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `prefixlen <*`n`*`>` | 与`netmask`相同，但允许使用CIDR风格的前缀长度来指定掩码。|'
- en: '| `up` | Sets an interface up, enabling it. |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `up` | 设置接口为启用状态。|'
- en: Note
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Since creating, destroying, or modifying interfaces can cause a host to stop
    working properly, administrative (superuser) rights are generally required on
    most systems in order to do anything with* `ifconfig` *other than examining the
    existing configuration*.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于创建、销毁或修改接口可能导致主机无法正常工作，因此在大多数系统中，通常需要管理员（超级用户）权限才能使用`ifconfig`进行除检查现有配置之外的操作*。'
- en: '[Example 88-10](ch88s08.html#sample_output_of_the_unix_ifconfig_-a_co "Example 88-10. Sample
    output of the UNIX ifconfig -a command") shows sample output of the `ifconfig
    -a` command on one of the UNIX machines I use regularly, showing the settings
    for its interfaces.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-10](ch88s08.html#sample_output_of_the_unix_ifconfig_-a_co "示例 88-10. UNIX
    ifconfig -a命令的示例输出")显示了我在使用的一台UNIX机器上`ifconfig -a`命令的示例输出，显示了其接口的设置。'
- en: Example 88-10. Sample output of the UNIX ifconfig -a command
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-10. UNIX ifconfig -a命令的示例输出
- en: '[PRE22]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The ipconfig for Windows NT, 2000, and XP
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows NT、2000和XP的ipconfig
- en: Windows takes a somewhat different approach to network configuration than UNIX.
    As described in the previous section, you can use the UNIX `ifconfig` program
    both to view and modify a wide range of configuration parameters. In Windows,
    however, most setup and parameter modification is done using the Windows Control
    Panel. Windows does include a utility that is somewhat similar to UNIX's `ifconfig`,
    but it has far less functionality and is used mainly to inspect the existing configuration,
    not change it. It also allows an administrator to easily perform a few simple
    functions on a host.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Windows在网络配置方面与UNIX采取的方法略有不同。如前所述，您可以使用UNIX的`ifconfig`程序查看和修改广泛的配置参数。然而，在Windows中，大多数设置和参数修改都是通过Windows控制面板完成的。Windows确实包含一个与UNIX的`ifconfig`类似的小工具，但它的功能远不如`ifconfig`，主要用于检查现有配置，而不是更改配置。它还允许管理员轻松地在主机上执行一些简单功能。
- en: On Windows NT, 2000, and XP, the equivalent of `ifconfig` is a command-line
    utility called `ipconfig`. Like `ifconfi`g, the Windows utility is controlled
    using options that are supplied to the program. However, because it is so much
    simpler than `ifconfig`, there are only a few options, as summarized in [Table 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "Table 88-14. Typical Windows ipconfig Options and Parameters").
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows NT、2000和XP上，`ifconfig`的等效命令行实用程序是`ipconfig`。与`ifconfig`一样，Windows实用程序通过提供给程序选项来控制。然而，由于它比`ifconfig`简单得多，因此只有少数选项，如[表 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "表 88-14. 典型的Windows ipconfig选项和参数")中总结的。
- en: Table 88-14. Typical Windows ipconfig Options and Parameters
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-14. 典型的Windows ipconfig选项和参数
- en: '| Option/Parameters | Description |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 选项/参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| (none) | When called with no options or parameters, `ipconfig` displays the
    IP address, subnet mask, and default gateway for each interface on the host. |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| (none) | 当不带选项或参数调用时，`ipconfig`显示主机上每个接口的IP地址、子网掩码和默认网关。|'
- en: '| `/all` | Similar to calling `ipconfig` with no options, but displays more
    detailed configuration information about the host''s interfaces. |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `/all` | 与不带选项调用`ipconfig`类似，但显示有关主机接口的更详细配置信息。|'
- en: '| `/release [<`*`adapter`*`>]` | Releases (terminates) the DHCP lease on either
    the specified adapter (interface) or all interfaces, if none is provided. |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `/release [<`*`适配器`*`>]` | 释放（终止）指定适配器（接口）或所有接口的DHCP租约，如果没有提供则释放所有接口。|'
- en: '| `/`renew [<*`adapter`*`>]` | Manually renews the DHCP lease for either the
    specified adapter (interface) or all adapters, if none is mentioned. |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `/`renew [<*`适配器`*`>]` | 手动续订指定适配器（接口）或所有适配器的DHCP租约，如果没有指定则续订所有适配器。|'
- en: '| `/displaydns` | Displays the contents of the host''s DNS resolver cache.
    |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `/displaydns` | 显示主机的DNS解析器缓存内容。|'
- en: '| `/flushdns` | Clears the host''s DNS resolver cache. |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `/flushdns` | 清除主机的DNS解析器缓存。|'
- en: '| `/re`gisterdns | Refreshes (renews) all DHCP leases and also reregisters
    any DNS names associated with the host. |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `/re`gisterdns | 刷新（续订）所有DHCP租约，并重新注册与主机关联的任何DNS名称。|'
- en: '| `/showclassid <`*`adapter`*`>` | Displays DHCP class IDs associated with
    this adapter (these are used to arrange clients into groups that are given different
    treatment by DHCP servers). The adapter must be specified, even if there is only
    one. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `/showclassid <`*`适配器`*`>` | 显示与此适配器关联的 DHCP 类 ID（这些用于将客户端分组，以便 DHCP 服务器对它们进行不同的处理）。即使只有一个适配器，也必须指定适配器。|'
- en: '| `/setclassid <`*`adapter`*`> [<`*`classid`*`>]` | Modifies the DHCP class
    ID for the specified adapter. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `/setclassid <`*`适配器`*`> [<`*`classid`*`>]` | 修改指定适配器的 DHCP 类 ID。|'
- en: As mentioned earlier, `ipconfig` is most often used to just examine the existing
    configuration. You can see from the list of options in [Table 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "Table 88-14. Typical Windows ipconfig Options and Parameters") that most of the
    other uses of `ipconfig` are related to controlling the operation of protocols
    such as DNS and the Dynamic Host Configuration Protocol (DHCP), rather than configuring
    a host. One common use of `ipconfig` is to force a host to seek out a new DHCP
    lease, which can be done using `ipconfig /release` followed by `ipconfig /renew`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ipconfig` 最常用于仅检查现有配置。您可以从 [表 88-14](ch88s08.html#typical_windows_ipconfig_options_and_par
    "表 88-14. 典型的 Windows ipconfig 选项和参数") 中的选项列表中看到，`ipconfig` 的其他大多数用途都与控制 DNS 和动态主机配置协议
    (DHCP) 等协议的操作有关，而不是配置主机。`ipconfig` 的一个常见用途是强制主机寻找新的 DHCP 租约，这可以通过先使用 `ipconfig
    /release` 然后使用 `ipconfig /renew` 来完成。
- en: '[Example 88-11](ch88s08.html#simplified_configuration_information_fro "Example 88-11. Simplified
    configuration information from the Windows ipconfig utility") shows an example
    of the output from using the `ipconfig` command without any options. For detailed
    information on interfaces, you can use the `/all` option, as shown in the example
    in [Example 88-12](ch88s08.html#detailed_configuration_information_from_ "Example 88-12. Detailed
    configuration information from the Windows ipconfig utility") (which I''ve modified
    slightly so it is easier to read).'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 88-11](ch88s08.html#simplified_configuration_information_fro "示例 88-11.
    Windows ipconfig 工具的简化配置信息") 展示了使用 `ipconfig` 命令不带任何选项时的输出示例。要获取接口的详细信息，可以使用 `/all`
    选项，如 [示例 88-12](ch88s08.html#detailed_configuration_information_from_ "示例 88-12.
    Windows ipconfig 工具的详细配置信息") 中的示例所示（我已经稍作修改以便更容易阅读）。'
- en: Example 88-11. Simplified configuration information from the Windows ipconfig
    utility
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-11. Windows ipconfig 工具的简化配置信息
- en: '[PRE23]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example 88-12. Detailed configuration information from the Windows ipconfig
    utility
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 88-12. Windows ipconfig 工具的详细配置信息
- en: '[PRE24]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The winipcfg Utility for Windows 95, 98, and Me
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 95、98 和 Me 的 winipcfg 工具
- en: Windows 95, 98, and Me have a graphical tool called `winipcfg`, instead of the
    `ipconfig` command-line utility. This program allows you to examine the configuration
    parameters in much the same way as `ipconfig`, and also to release and renew DHCP
    leases, but it does not support the other options of `ipconfig` (such as displaying
    the host's DNS cache). An example of the main `winipcfg` screen is shown in [Figure 88-2](ch88s08.html#windows_9598me_winipcfg_utility_the_wini
    "Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used
    in older, consumer-oriented versions of Windows to check the configuration of
    a host and release/renew DHCP leases.").
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 95、98 和 Me 有一个名为 `winipcfg` 的图形工具，而不是 `ipconfig` 命令行工具。此程序允许您以与 `ipconfig`
    相似的方式检查配置参数，并且还可以释放和更新 DHCP 租约，但它不支持 `ipconfig` 的其他选项（例如显示主机的 DNS 缓存）。[图 88-2](ch88s08.html#windows_9598me_winipcfg_utility_the_wini
    "图 88-2. Windows 95/98/Me winipcfg 工具 winipcfg 工具可用于较旧的面向消费者的 Windows 版本，以检查主机的配置并释放/更新
    DHCP 租约。") 展示了 `winipcfg` 主屏幕的一个示例。
- en: Tip
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** On UNIX systems, the `ifconfig` utility can be used to display
    or modify a large number of TCP/IP configuration settings. Windows systems provide
    either the command-line utility `ipconfig` or the graphical tool winipcfg. Both
    let an administrator see basic TCP/IP configuration information for a host and
    allow tasks to be performed such as renewing a DHCP lease, but they are otherwise
    quite limited compared with the UNIX `ifconfig` program.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在 UNIX 系统中，`ifconfig` 工具可以用来显示或修改大量 TCP/IP 配置设置。Windows 系统提供命令行工具
    `ipconfig` 或图形工具 winipcfg。两者都允许管理员查看主机的 TCP/IP 基本配置信息，并允许执行诸如更新 DHCP 租约等任务，但与
    UNIX 的 `ifconfig` 程序相比，它们在其他方面相当有限。'
- en: '![Windows 95/98/Me winipcfg utility The winipcfg utility can be used in older,
    consumer-oriented versions of Windows to check the configuration of a host and
    release/renew DHCP leases.](httpatomoreillycomsourcenostarchimages288329.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![Windows 95/98/Me winipcfg 实用程序 winipcfg 实用程序可用于较旧的面向消费者的Windows版本，以检查主机的配置并释放/续订DHCP租约。](httpatomoreillycomsourcenostarchimages288329.png)'
- en: Figure 88-2. Windows 95/98/Me winipcfg utility The winipcfg utility can be used
    in older, consumer-oriented versions of Windows to check the configuration of
    a host and release/renew DHCP leases.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图 88-2. Windows 95/98/Me winipcfg 实用程序 winipcfg 实用程序可用于较旧的面向消费者的Windows版本，以检查主机的配置并释放/续订DHCP租约。
- en: Miscellaneous TCP/IP Troubleshooting Protocols
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多种 TCP/IP 故障排除协议
- en: As soon as you set up a network, it will very quickly develop problems that
    you will need to address. Recognizing that the complexity of TCP/IP internetworks
    would make diagnosing certain problems difficult, the suite's architects defined
    a number of miscellaneous utility protocols that can be helpful in testing and
    troubleshooting networks. Despite having been around for more than 20 years, these
    protocols are somewhat obscure and get little attention. However, even though
    they are no longer implemented on many systems, I feel they are worth a quick
    look.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了网络，它将很快出现你需要解决的问题。认识到TCP/IP互连网络的复杂性会使诊断某些问题变得困难，该套件的架构师定义了一系列有助于测试和故障排除网络的杂项实用程序协议。尽管这些协议已经存在超过20年，但它们相对不为人知，并且很少受到关注。然而，尽管它们在许多系统中不再实现，但我认为它们值得快速查看。
- en: These simple protocols are designed to be implemented as services that run on
    TCP/IP servers. Each listens for requests on a dedicated well-known port number
    and then responds with a particular type of information. These protocols can be
    used with both TCP and UDP, enabling each transport protocol to be tested. In
    the case of UDP, the server counts each UDP datagram sent to it as a request and
    sends a response to it. When used with TCP, a connection is first established
    by the client to the server. In some of the protocols, this connection is then
    used to send data continuously between the client and server; in others, the establishment
    of the connection is considered an implied request to the server, which will immediately
    send a response and then close the connection.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的协议被设计为在TCP/IP服务器上运行的服务。每个服务都在一个专用的已知端口号上监听请求，然后以特定类型的信息进行响应。这些协议可以与TCP和UDP一起使用，使得每种传输协议都可以进行测试。在UDP的情况下，服务器将其收到的每个UDP数据报计为一个请求，并向其发送响应。当与TCP一起使用时，客户端首先与服务器建立连接。在某些协议中，这个连接随后被用来在客户端和服务器之间连续发送数据；在其他协议中，建立连接被视为向服务器的一个隐含请求，服务器将立即发送响应并关闭连接。
- en: '[Table 88-15](ch88s09.html#miscellaneous_tcpip_troubleshootin-id001 "Table 88-15. Miscellaneous
    TCP/IP Troubleshooting Protocols") provides a brief description of each of these
    troubleshooting protocols under both UDP and TCP. I have shown for each the port
    number that the service uses and also the RFC that defines it.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 88-15](ch88s09.html#miscellaneous_tcpip_troubleshootin-id001 "表 88-15. 多种
    TCP/IP 故障排除协议") 提供了这些故障排除协议在UDP和TCP下的简要描述。我为每个协议展示了服务使用的端口号以及定义它的RFC。'
- en: Table 88-15. Miscellaneous TCP/IP Troubleshooting Protocols
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 表 88-15. 多种 TCP/IP 故障排除协议
- en: '| Protocol | Well-Known Port Number | Defining RFC | Description |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 已知端口号 | 定义RFC | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Echo Protocol | 7 | 862 | Echoes received data back to its originator. When
    used on UDP, the payload of each message is simply packaged into a return UDP
    datagram and sent back. For TCP, each byte sent by the client is echoed back by
    the server until the connection is closed. |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 回声协议 | 7 | 862 | 将接收到的数据回显给其发送者。当在UDP上使用时，每条消息的有效负载被简单地封装成一个返回的UDP数据报并发送回去。对于TCP，服务器将回显客户端发送的每个字节，直到连接关闭。|'
- en: '| Discard Protocol | 9 | 863 | Throws away all data that is sent to it. |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 丢弃协议 | 9 | 863 | 丢弃发送给它的所有数据。|'
- en: '| Character Generator Protocol | 19 | 864 | Generates random characters of
    data and sends them to a device. When used with UDP, each UDP message sent to
    the server causes it to send back a UDP message containing a random amount (0
    to 512 bytes) of data. When used with TCP, the server just starts sending characters
    as soon as a client establishes a connection, and continues until the connection
    is terminated by the client. |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| 字符生成器协议 | 19 | 864 | 生成随机数据字符并发送给设备。当与UDP一起使用时，每个发送到服务器的UDP消息都会导致它发送一个包含随机数量（0到512字节）数据的UDP消息。当与TCP一起使用时，服务器在客户端建立连接后立即开始发送字符，直到客户端终止连接。
    |'
- en: '| Quote of the Day Protocol | 17 | 865 | Sends a short message (selected by
    the server''s administrator) to a client device. For UDP, the message is sent
    for each incoming UDP message; for TCP, the message is sent by the server once
    when the connection is established, which is then closed. |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 每日名言协议 | 17 | 865 | 向客户端设备发送一条简短的消息（由服务器管理员选择）。对于UDP，对于每个传入的UDP消息都会发送消息；对于TCP，在建立连接后，服务器发送一次消息，然后关闭连接。
    |'
- en: '| Active Users | 11 | 866 | Sends a list of active users to a device. For UDP,
    the list is sent for each incoming UDP message; if it is longer than 512 bytes,
    it will be sent in multiple messages. For TCP, the list is sent automatically
    when the connection is made to the server, and then the connection is terminated.
    |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 活跃用户 | 11 | 866 | 向设备发送活跃用户列表。对于UDP，对于每个传入的UDP消息都会发送列表；如果列表长度超过512字节，它将在多个消息中发送。对于TCP，在连接到服务器时自动发送列表，然后终止连接。
    |'
- en: '| Daytime Protocol | 13 | 867 | Returns the current time on the server in human-readable
    form, in response to receipt of a UDP message or an incoming TCP connection. |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 白天协议 | 13 | 867 | 在接收到UDP消息或传入的TCP连接后，以人类可读的形式返回服务器上的当前时间。 |'
- en: '| Time Protocol | 37 | 868 | Returns the current time in machine-readable form—specifically,
    the number of seconds since midnight, January 1, 1900 GMT. The time is sent for
    each UDP message received by the server or upon establishment of a TCP connection.Note
    that this protocol cannot be used for time synchronization of servers, because
    it does not compensate for variability in the time required for the messages to
    be carried over the internetwork. |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 时间协议 | 37 | 868 | 以机器可读的形式返回当前时间——具体来说，是自1900年1月1日凌晨以来经过的秒数。服务器接收到每个UDP消息或建立TCP连接时都会发送时间。请注意，此协议不能用于服务器的时间同步，因为它不补偿消息在互联网中传输所需时间的变化。
    |'
