- en: Chapter 18. Debugging and Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 18 章。调试与测试
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: The development of any real-world application progresses in steps. Most of us
    would prefer to take more steps forward than backward. To minimize the backward
    steps—caused by coding errors or unforeseen side effects—you can take advantage
    of testing and debugging techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现实世界的应用程序的开发都是逐步进行的。我们大多数人更愿意向前迈出更多步伐而不是向后。为了最小化由编码错误或未预见的副作用引起的后退步伐，你可以利用测试和调试技术。
- en: This chapter provides a brief overview of some of the most useful debugging
    tools available to Ruby programmers. Bear in mind, however, that if you are using
    a dedicated Ruby IDE, you may have more powerful visual debugging tools at your
    disposal. I will be discussing only the “standard” tools available to Ruby in
    this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了 Ruby 程序员可用的一些最有用的调试工具。然而，请注意，如果你使用的是专门的 Ruby IDE，你可能会有更多强大的可视化调试工具可用。在本章中，我将仅讨论
    Ruby 可用的“标准”工具。
- en: 'IRB: Interactive Ruby'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IRB：交互式 Ruby
- en: 'Sometimes you may just want to “try something” with Ruby. It is possible to
    do this using the standard Ruby interpreter: Enter `ruby` at the command prompt,
    and then enter your code one line at a time. However, this is far from being an
    ideal interactive environment. For one thing, the code you enter will be executed
    only when you enter an end-of-file character such as `^Z` or `^D` (that is, ctrl-Z
    on Windows or ctrl-D on some other operating systems). So, to do something as
    simple as displaying the value of 1 plus 1, you would enter the following sequence
    commands (remembering to enter whichever end-of-file character is required on
    your operating system).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能只是想用 Ruby “尝试做某事”。你可以使用标准的 Ruby 解释器来做这件事：在命令提示符下输入 `ruby`，然后逐行输入你的代码。然而，这远非一个理想的交互式环境。首先，你输入的代码只有在输入文件结束字符（例如
    `^Z` 或 `^D`，即 Windows 上的 Ctrl-Z 或某些其他操作系统上的 Ctrl-D）时才会执行。因此，为了执行像显示 1 加 1 的值这样简单的事情，你需要输入以下序列命令（记住输入你操作系统所需的文件结束字符）。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Only once the end-of-file character (here `^Z`) has been entered does Ruby
    execute the code and display the result:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在输入文件结束字符（这里为 `^Z`）后，Ruby 才会执行代码并显示结果：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For a better way to interact with Ruby, use the Interactive Ruby shell (IRB).
    To start IRB, go to a command prompt and enter the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地与 Ruby 交互，请使用交互式 Ruby 壳（IRB）。要启动 IRB，请转到命令提示符并输入以下内容：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should now see a prompt similar to the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到一个类似于以下提示符的界面：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you are ready to start entering some Ruby code. You can enter an expression
    over more than one line; as soon as the expression is complete, IRB will evaluate
    it and display the result. Try the following (pressing enter after the `+` on
    the first line):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始输入一些 Ruby 代码了。你可以输入多行表达式；一旦表达式完成，IRB 将评估它并显示结果。尝试以下操作（在第一行的 `+` 后按回车键）：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, press enter after the closing parenthesis. Now IRB will evaluate the
    expression and show the result:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在闭括号后按回车键。现在 IRB 将评估表达式并显示结果：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can now evaluate `x`. Enter this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以评估 `x`。输入以下内容：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'IRB shows this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: IRB 显示如下：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, up to this point, your entire IRB session should look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，你的整个 IRB 会话应该看起来像这样：
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Be careful, though. Try entering this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要小心。尝试输入以下内容：
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time the result is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的结果如下：
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is, in fact, normal Ruby behavior. It is normal because a line break acts
    as a terminator, while the `+` operator, when it begins the new line, acts as
    a unary operator (that is, rather than adding together *two* values—one to its
    left and one to its right—it merely asserts that the *single* expression that
    follows the `+` is positive). You will find a fuller explanation of this in [Digging
    Deeper](ch18s03.html#digging_deeper-id17 "Digging Deeper") in [Digging Deeper](ch18s03.html#digging_deeper-id17
    "Digging Deeper").
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是正常的 Ruby 行为。这是正常的，因为换行符充当终止符，而 `+` 操作符在开始新行时充当一元操作符（也就是说，它不是将两个值相加——一个在其左侧，一个在其右侧——而是断言
    `+` 后面的单个表达式是正的）。你可以在 [深入挖掘](ch18s03.html#digging_deeper-id17 "深入挖掘") 中找到对这个问题的更全面解释。[深入挖掘](ch18s03.html#digging_deeper-id17
    "深入挖掘")。
- en: 'For now, just be aware that when entering expressions one line at a time, the
    position of the line break is important! When using IRB, you can tell whether
    the interpreter considers that you have ended a statement. If you have done so,
    a prompt is displayed ending with `>` like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请注意，当逐行输入表达式时，行断点的位置很重要！当使用IRB时，您可以判断解释器是否认为您已经结束了一个语句。如果您已经这样做，则会显示一个以`>`结尾的提示符，如下所示：
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a statement is complete and returns a result, a `=>` prompt is displayed
    followed by the result. For example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个语句完整并返回一个结果，则会显示一个`=>`提示符，后跟结果。例如：
- en: '[PRE12]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the statement is incomplete, the prompt ends with an asterisk:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语句不完整，提示符以星号结尾：
- en: '[PRE13]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To end an IRB session, enter the word `quit` or `exit` at the prompt. You can,
    if you want, load a Ruby program into IRB by passing to it the program name when
    you run IRB like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束IRB会话，请在提示符中输入单词`quit`或`exit`。如果您愿意，可以通过在运行IRB时传递程序名称来将Ruby程序加载到IRB中，如下所示：
- en: '[PRE14]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You may also invoke IRB with a variety of options to do things such as load
    a module (`irb -r` *`[load-module]`*) or display the IRB version number (`irb
    -v`). Many of the available IRB options are rather esoteric and are not likely
    to be required by most users. The full range of options may be listed by entering
    this at the command line:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用各种选项调用IRB，例如加载一个模块（`irb -r` *`[load-module]`*）或显示IRB版本号（`irb -v`）。许多可用的IRB选项相当晦涩，并且不太可能被大多数用户需要。可以通过在命令行输入以下内容来列出所有选项：
- en: '[PRE15]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although IRB may be useful for trying out some code, it does not provide all
    the features you need for debugging programs. Ruby does, however, provide a command-line
    debugger.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然IRB可能对尝试一些代码很有用，但它并不提供您进行程序调试所需的所有功能。然而，Ruby确实提供了一个命令行调试器。
- en: Debugging
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: 'The default Ruby debugger allows you to set breakpoints and watchpoints and
    evaluate variables while your programs execute. To run a program in the debugger,
    use the `-r debug` option (where `-r` means “require” and `debug` is the name
    of the debugging library) when you start the Ruby interpreter. For example, this
    is how you would debug a program called *debug_test.rb*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Ruby调试器允许您在程序执行时设置断点和监视点以及评估变量。要在调试器中运行程序，请在启动Ruby解释器时使用`-r debug`选项（其中`-r`表示“require”，`debug`是调试库的名称）。例如，这样就可以调试名为*debug_test.rb*的程序：
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the debugger has started, you can enter various commands to step through
    your code, set breakpoints to cause the execution to pause at specific lines,
    set watches to monitor the values of variables, and so on. The following are the
    available debugging commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器启动，您就可以输入各种命令来逐步执行代码，设置断点以在特定行暂停执行，设置监视点以监视变量的值，等等。以下是可以用的调试命令：
- en: '**`b[reak] [file|class:]<line|method>`** and **`b[reak] [file|class:]<line|method>`**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**`b[reak] [file|class:]<line|method>`** 和 **`b[reak] [file|class:]<line|method>`**'
- en: Sets breakpoint to some position
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点到某个位置
- en: '**`b[reak] [class.]<line|method>`**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**`b[reak] [class.]<line|method>`**'
- en: Sets breakpoint to some position
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点到某个位置
- en: '**`wat[ch] <expression>`**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**`wat[ch] <expression>`**'
- en: Sets watchpoint to some expression
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置监视点到某个表达式
- en: '**`cat[ch] <an Exception>`**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**`cat[ch] <an Exception>`**'
- en: Sets catchpoint to an exception
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置捕获点为异常
- en: '**`b[reak]`**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**`b[reak]`**'
- en: Lists breakpoints
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列出断点
- en: '**`cat[ch]`**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**`cat[ch]`**'
- en: Shows catchpoint
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显示捕获点
- en: '**`del[ete][ nnn]`**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**`del[ete][ nnn]`**'
- en: Deletes some or all breakpoints
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一些或所有断点
- en: '**`disp[lay] <expression>`**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**`disp[lay] <expression>`**'
- en: Adds expression to display expression list
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式添加到显示表达式列表
- en: '**`undisp[lay][ nnn]`**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**`undisp[lay][ nnn]`**'
- en: Deletes one particular or all display expressions
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个特定的或所有显示表达式
- en: '**`c[ont]`**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**`c[ont]`**'
- en: Runs until end or breakpoint
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行到结束或断点
- en: '**`s[tep][ nnn]`**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**`s[tep][ nnn]`**'
- en: Steps (into code) one line or to line `nnn`
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 步进（进入代码）一行或到行`nnn`
- en: '**`n[ext][ nnn]`**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**`n[ext][ nnn]`**'
- en: Goes over one line or until line `nnn`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过一行或直到行`nnn`
- en: '**`w[here]`**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**`w[here]`**'
- en: Displays frames
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 显示框架
- en: '**`f[rame]`**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**`f[rame]`**'
- en: Is the alias for `where`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 是`where`的别名
- en: '**`l[ist][ (-|nn-mm)]`**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**`l[ist][ (-|nn-mm)]`**'
- en: Lists program, lists backward `nn-mm`, lists given lines
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列出程序，列出反向`nn-mm`，列出指定的行
- en: '**`up[ nn]`**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**`up[ nn]`**'
- en: Moves to higher frame
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到更高的框架
- en: '**`down[ nn]`**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**`down[ nn]`**'
- en: Moves to lower frame
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到较低的框架
- en: '**`fin[ish]`**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**`fin[ish]`**'
- en: Returns to outer frame
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 返回外部框架
- en: '**`tr[ace] (on|off)`**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tr[ace] (on|off)`**'
- en: Sets trace mode of current thread
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设置当前线程的跟踪模式
- en: '**`tr[ace] (on|off) all`**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**`tr[ace] (on|off) all`**'
- en: Sets trace mode of all threads
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有线程的跟踪模式
- en: '**`q[uit]`**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**`q[uit]`**'
- en: Exits from debugger
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 退出调试器
- en: '**`v[ar] g[lobal]`**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**`v[ar] g[lobal]`**'
- en: Shows global variables
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显示全局变量
- en: '**`v[ar] l[ocal]`**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**`v[ar] l[ocal]`**'
- en: Shows local variables
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显示局部变量
- en: '**`v[ar] i[nstance] <object>`**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**`v[ar] i[nstance] <object>`**'
- en: Shows instance variables of object
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的实例变量
- en: '**`v[ar] c[onst] <object>`**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**`v[ar] c[onst] <object>`**'
- en: Shows constants of object
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的常量
- en: '**`m[ethod] i[nstance] <obj>`**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**`m[ethod] i[nstance] <obj>`**'
- en: Shows methods of object
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对象的方法
- en: '**`m[ethod] <class|module>`**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**`m[ethod] <class|module>`**'
- en: Shows instance methods of class or module
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 显示类或模块的实例方法
- en: '**`th[read] l[ist]`**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**`th[read] l[ist]`**'
- en: Lists all threads
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有线程
- en: '**`th[read] c[ur[rent]]`**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**`th[read] c[ur[rent]]`**'
- en: Shows current thread
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显示当前线程
- en: '**`th[read] [sw[itch]] <nnn>`**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**`th[read] [sw[itch]] <nnn>`**'
- en: Switches thread context to `nnn`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将线程上下文切换到 `nnn`
- en: '**`th[read] stop <nnn>`**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**`th[read] stop <nnn>`**'
- en: Stops thread `nnn`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 停止线程 `nnn`
- en: '**`th[read] resume <nnn>`**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`th[read] resume <nnn>`**'
- en: Resumes thread `nnn`
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复线程 `nnn`
- en: '**`p expression`**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**`p expression`**'
- en: Evaluates expression and prints its value
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 评估表达式并打印其值
- en: '**`h[elp]`**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**`h[elp]`**'
- en: Prints this help
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 打印此帮助
- en: '**`<everything else>`**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<everything else>`**'
- en: Evaluates
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 评估
- en: Ubygems? What’s Ubygems?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ubygems？什么是Ubygems？
- en: 'In some cases, if you enter the command `ruby -r debug`, you may see an inscrutable
    message similar to the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果你输入命令 `ruby -r debug`，你可能会看到一个难以理解的类似以下的消息：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If this happens, when you then start debugging, you will find yourself trying
    to debug the file *ubygems.rb* rather than your program! This problem may occur
    when some software (for example, some customized Ruby installers) set the environment
    variable `RUBYOPT=-rubygems`. In most cases, this has the desirable effect of
    allowing your Ruby programs to use the Ruby Gems “packaging system,” which helps
    install Ruby libraries. When you try to use the `-r` option, however, this is
    interpreted as `-r ubygems`, which is why an attempt is made to load the file
    *ubygems.rb*. Ruby conveniently (or possibly confusingly?) provides a file named
    *ubygems.rb* that does nothing apart from requiring *rubygems.rb*. There are two
    ways of dealing with this. You can remove `RUBYOPT` permanently, or you can disable
    it temporarily. If you choose to remove it permanently, however, you may encounter
    side effects when using Ruby Gems later. The way in which environment variables
    are added or removed varies according to your operating system. On Windows, you
    would need to click the Start menu (then Settings if using XP) and click Control
    Panel (then System and Maintenance if using Vista); then click System (on Vista,
    you should now click Advanced System Settings). In the System Properties dialog,
    select the Advanced tab. Next, click Environment Variables; finally, in the System
    Variables panel, find `RUBYOPT` and delete it. A safer alternative is to disable
    the variable at the command prompt prior to loading the debugger. To do this,
    enter the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，当你开始调试时，你会发现自己试图调试文件 *ubygems.rb* 而不是你的程序！这个问题可能发生在某些软件（例如，某些定制的Ruby安装程序）设置了环境变量
    `RUBYOPT=-rubygems` 的时候。在大多数情况下，这会有一个期望的效果，即允许你的Ruby程序使用Ruby Gems“打包系统”，这有助于安装Ruby库。然而，当你尝试使用
    `-r` 选项时，这会被解释为 `-r ubygems`，这就是为什么会尝试加载文件 *ubygems.rb*。Ruby方便地（或者可能是令人困惑地？）提供了一个名为
    *ubygems.rb* 的文件，该文件除了要求 *rubygems.rb* 外不做任何事情。处理这个问题有两种方法。你可以永久地删除 `RUBYOPT`，或者暂时禁用它。但是，如果你选择永久删除它，那么在以后使用Ruby
    Gems时可能会遇到副作用。环境变量添加或删除的方式因操作系统而异。在Windows上，你需要点击开始菜单（如果使用XP，则点击设置），然后点击控制面板（如果使用Vista，则点击系统和维护），然后点击系统（在Vista上，你现在应该点击高级系统设置）。在系统属性对话框中，选择高级选项卡。接下来，点击环境变量；最后，在系统变量面板中找到
    `RUBYOPT` 并删除它。一个更安全的替代方法是，在加载调试器之前在命令提示符中禁用变量。为此，请输入以下内容：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will disable the `RUBYOPT` environment variable for this command session
    only. You can verify this by entering the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅为此命令会话禁用 `RUBYOPT` 环境变量。你可以通过输入以下内容来验证这一点：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should see the message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下消息：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, open another command window and enter `set RUBYOPT`, and you will see
    that the environment variable here retains its default value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，打开另一个命令窗口并输入 `set RUBYOPT`，你会看到这里的环境变量保留了其默认值。
- en: 'Let’s see how a few of these commands might be used in a real debugging session.
    Open a system prompt, and navigate to the directory containing the file *debug_test.rb*,
    which is supplied in the sample code for this chapter. Start the debugger by entering
    this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些命令如何在实际的调试会话中使用。打开一个系统提示符，导航到包含文件 *debug_test.rb* 的目录，该文件包含在本章的示例代码中。通过输入以下内容启动调试器：
- en: '*debug_test.rb*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*debug_test.rb*'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s try a few commands. In these examples, I’ve written `[Enter]` to
    show that you should press the enter key after each command. First let’s see a
    code listing (here note that `l` is a lowercase *L* character):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试几个命令。在这些示例中，我已用`[Enter]`来表示您应该在每个命令后按回车键。首先让我们查看代码列表（请注意，`l`是一个小写的*L*字符）：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see this, which is a partial listing of the file *debug_test.rb*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个，这是文件*debug_test.rb*的部分列表：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you see a listing from a file called *ubygems.rb* at this point instead of
    your program, refer to [Ubygems? What’s Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? What’s Ubygems?") in [Ubygems? What’s Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? What’s Ubygems?") for ways of correcting this problem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时您看到的是名为*ubygems.rb*的文件列表而不是您的程序，请参阅[Ubygems? 什么是Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? 什么是Ubygems?")中的[Ubygems? 什么是Ubygems?](ch18s02.html#ubygems_question_whatas_ubygems_question
    "Ubygems? 什么是Ubygems?")部分，了解如何纠正此问题。
- en: 'The `l` you entered is the “list” command, which instructs the debugger to
    list the code in bite-sized chunks. The actual number of lines will vary with
    the code being debugged. Let’s list some more:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入的`l`是“list”命令，它指示调试器以小块形式列出代码。实际行数将根据正在调试的代码而变化。让我们列出更多：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now list a specific number of lines. Enter the letter `l` followed by the digit
    `1`, a hyphen, and `100`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列出特定数量的行。输入字母`l`后跟数字`1`，一个连字符，然后是`100`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s put a breakpoint on line 78:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第78行设置一个断点：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Ruby debugger should reply with this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby调试器应该回复如下：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You might also set one or more *watchpoints*. A watchpoint can be used to trigger
    a break on a simple variable (for example, entering `wat @t2` would break when
    the `@t2` object is created); or it may be set to match a specific value (for
    example, `i == 10`). Here I want to set a watchpoint that breaks when the `name`
    attribute of `@t4` is “wombat”. Enter this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可能设置一个或多个*观察点*。观察点可以用来在创建简单变量（例如，输入`wat @t2`会在创建`@t2`对象时中断）时触发中断；或者它可以设置为匹配特定值（例如，`i
    == 10`）。在这里，我想设置一个当`@t4`的`name`属性为“wombat”时中断的观察点。输入以下内容：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The debugger should confirm this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器应该确认这一点：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice the watchpoint number is 2\. You’ll need that number if you subsequently
    decide to delete the watchpoint. Okay, so now let’s continue (`c`) execution:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意观察点编号是2。如果您随后决定删除观察点，您将需要这个编号。好的，现在让我们继续（`c`）执行：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The program will run until it hits the breakpoint. You will see a message similar
    to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将运行直到遇到断点。您将看到类似于以下的消息：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here it shows the line number it’s stopped on and the code on that line. Let’s
    continue:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了它停止的行号和该行的代码。让我们继续：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time it breaks here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它在这里中断：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the line immediately following the successful evaluation of the watchpoint
    condition. Check that by listing the line number indicated:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是紧随成功评估观察点条件之后的行。通过列出指示的行号来检查：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The debugger shows a set of lines with the current line of execution (86) preceded
    by the `=>` marker:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器显示了一组带有当前执行行（86）的行，前面有`=>`标记：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, line 86 contains the code that matches the watchpoint condition.
    Notice that execution did not stop after line 82, where `@t4` was originally created,
    because the watchpoint condition was not met there (its `name` attribute was “potto”
    and not “wombat”). If you want to inspect the value of a variable when paused
    at a breakpoint or watchpoint, just enter its name. Try this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，第86行包含匹配观察点条件的代码。请注意，执行并没有在创建`@t4`的原始位置（第82行）停止，因为那里的观察点条件未满足（其`name`属性是“potto”而不是“wombat”）。如果您想在断点或观察点暂停时检查变量的值，只需输入其名称。试一试：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The debugger will display the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器将显示以下内容：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can similarly enter other expressions to be evaluated. Try this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以类似地输入其他要评估的表达式。试一试：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This shows `800`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`800`。
- en: 'Or enter some arbitrary expression such as this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者输入一些任意的表达式，例如这个：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shows `12`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`12`。
- en: 'Now delete the watchpoint (recall that its number is 2):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在删除观察点（回想一下，其编号是2）：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And continue until the program exits:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后继续直到程序退出：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can use many more commands to debug a program in this way, and you may
    want to experiment with those shown in the table given earlier. You can also view
    a list of commands during a debugging session by entering `help` or just `h`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用更多命令以这种方式调试程序，您可能想尝试之前给出的表格中显示的命令。您还可以通过输入`help`或只是`h`来查看调试会话期间的命令列表：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To quit a debugging session, enter `quit` or `q`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出调试会话，输入 `quit` 或 `q`：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although the standard Ruby debugger has its uses, it is far from as simple or
    convenient to use as one of the graphical debuggers provided by integrated development
    environments. Moreover, it is quite slow. In my view, it is fine for debugging
    simple scripts but cannot be recommended for debugging large and complex programs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准的Ruby调试器有其用途，但它远不如集成开发环境提供的图形调试器简单或方便使用。此外，它相当慢。在我看来，它适合调试简单的脚本，但不建议用于调试大型和复杂的程序。
- en: Unit Testing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: '*Unit testing* is a postdebugging testing technique that lets you try bits
    of your program in order to verify that they work as expected. Some programmers
    use unit testing habitually in addition to or even instead of interactive debugging;
    other programmers use it rarely or never. Entire books have been written on the
    techniques and methodologies of unit testing, and I will only cover its fundamentals
    here.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试* 是一种调试后的测试技术，它允许你尝试程序的一部分，以验证它们是否按预期工作。一些程序员习惯性地使用单元测试，除了或甚至代替交互式调试；其他程序员很少或从不使用它。关于单元测试的技术和方法已经写成了整本书，我这里只介绍其基础。'
- en: The basic idea of unit testing is that you can write a number of “assertions”
    stating that certain results should be obtained as the consequence of certain
    actions. For example, you might assert that the return value of a specific method
    should be 100, that it should be a Boolean, or that it should be an instance of
    a specific class. If, when the test is run, the assertion proves to be correct,
    it passes the test; if it is incorrect, the test fails.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的基本思想是你可以编写一系列“断言”，声明某些结果应该是某些行为的后果。例如，你可能断言某个特定方法的返回值应该是100，它应该是一个布尔值，或者它应该是一个特定类的实例。如果在测试运行时，断言被证明是正确的，则测试通过；如果它是不正确的，则测试失败。
- en: 'Here’s an example, which will fail if the `getVal` method of the object, `t`,
    returns any value other than 100:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，如果对象 `t` 的 `getVal` 方法返回的任何值不是100，它将会失败：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But you can’t just pepper your code with assertions of this sort. There are
    precise rules to the game. First you have to require the *test/unit* file. Then
    you need to derive a test class from the TestCase class, which is found in the
    `Unit` module, which is itself in the `Test` module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你不能只是随意在你的代码中添加这种类型的断言。这个游戏有精确的规则。首先，你必须 require `test/unit` 文件。然后，你需要从一个在
    `Test` 模块中的 `TestCase` 类派生一个测试类，该类本身位于 `Unit` 模块中：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Inside this class you can write one or more methods, each of which constitutes
    a test containing one or more assertions. The method names must begin with `test`
    (so methods called `test1` or `testMyProgram` are okay, but a method called `myTestMethod`
    isn’t). The following method contains a test that makes the single assertion that
    the return value of `TestClass.new(100).getVal` is 1,000:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，你可以编写一个或多个方法，每个方法都包含一个或多个断言的测试。方法名必须以 `test` 开头（因此名为 `test1` 或 `testMyProgram`
    的方法是允许的，但名为 `myTestMethod` 的方法则不行）。以下方法包含一个测试，该测试断言 `TestClass.new(100).getVal`
    的返回值应该是1,000：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And here is a complete (albeit simple) test suite in which I have defined a
    TestCase class called MyTest that tests the class, TestClass. Here (with a little
    imagination!), TestClass may be taken to represent a whole program that I want
    to test:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整的（尽管简单）测试套件，其中我定义了一个名为 MyTest 的 TestCase 类来测试 TestClass。在这里（稍加想象！），TestClass
    可以代表我想要测试的整个程序：
- en: '*test1.rb*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*test1.rb*'
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This test suite contains two tests: `test1` (which contains three assertions)
    and `test2` (which contains one). To run the tests, you just need to run the program;
    you don’t have to create an instance of MyClass. You will see a report of the
    results that states there were two tests, three assertions, and one failure:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件包含两个测试：`test1`（包含三个断言）和 `test2`（包含一个）。要运行测试，你只需运行程序；你不需要创建 MyClass 的实例。你将看到结果报告，显示有两个测试，三个断言和一个失败：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In fact, I made *four* assertions. However, assertions following a failure
    are not evaluated in a given test. In `test1`, this assertion fails:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我做出了 *四个* 断言。然而，在测试失败之后的断言不会被评估。在 `test1` 中，这个断言失败了：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Having failed, the next assertion is skipped. If I now correct this failed
    assertion (asserting 100 instead of 101), this next assertion will also be tested:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 失败后，下一个断言将被跳过。如果我现在纠正这个失败的断言（断言100而不是101），下一个断言也将被测试：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But this too fails. This time, the report states that four assertions have
    been evaluated with one failure:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但这也失败了。这次，报告指出有四个断言被评估，其中有一个失败：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Of course, in a real-life situation, you should aim to write correct assertions,
    and when any failures are reported, it should be the failing code that is rewritten—not
    the assertion!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在现实生活中的情况下，你应该努力编写正确的断言，并且当报告任何失败时，应该重写失败的代码而不是断言！
- en: 'For a slightly more complex example of testing, see the *test2.rb* program
    (which requires a file called *buggy.rb*). This is a small adventure game that
    includes the following test methods:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个稍微复杂一些的测试示例，请参阅*test2.rb*程序（需要名为*buggy.rb*的文件）。这是一个小型冒险游戏，包括以下测试方法：
- en: '*test2.rb*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*test2.rb*'
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here the first method, `test1`, performs an `assert` test on an array of objects
    passed into a block, and it fails when a `value` attribute is *not* less than
    2,000\. The second method, `test2`, tests the class types of two objects using
    the `assert_kind_of` method. The second test in this method fails when `@game.map`
    is found to be of the type `TestMod::Adventure::Map` rather than `Array` as is
    asserted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个方法`test1`对一个传递给块的对象数组执行`assert`测试，当`value`属性不小于2,000时失败。第二个方法`test2`使用`assert_kind_of`方法测试两个对象的类类型。在这个方法的第二个测试中，当`@game.map`被发现是`TestMod::Adventure::Map`类型而不是断言的`Array`类型时失败。
- en: 'The code also contains two more methods named `setup` and `teardown`. When
    defined, methods with these names will be run before and after each test method.
    In other words, in *test2.rb*, the following methods will run in this order:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还包含两个名为`setup`和`teardown`的额外方法。当定义了这些名称的方法时，它们将在每个测试方法之前和之后运行。换句话说，在*test2.rb*中，以下方法将按此顺序运行：
- en: '| 1\. `setup` | 2\. `test1` | 3\. `teardown` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1\. `setup` | 2\. `test1` | 3\. `teardown` |'
- en: '| 4\. `setup` | 5\. `test2` | 6\. `teardown` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 4\. `setup` | 5\. `test2` | 6\. `teardown` |'
- en: 'This gives you the opportunity of reinitializing any variables to specific
    values prior to running each test or, as in this case, re-creating objects to
    ensure that they are in a known state as in the following example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了你在运行每个测试之前重新初始化任何变量到特定值的机会，或者在这个例子中，重新创建对象以确保它们处于已知状态，如下面的例子所示：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Digging Deeper
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: This section contains a summary of assertions for unit testing, explains why
    IRB may show different results for what appears to be the same code, and considers
    the merits of more advanced debugging tools.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含单元测试断言的摘要，解释了为什么IRB可能对看似相同的代码显示不同的结果，并考虑了更高级调试工具的优点。
- en: Assertions Available When Unit Testing
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可用的断言
- en: The list of assertions shown next is provided for ease of reference. A full
    explanation of each assertion is beyond the scope of this book. You can find complete
    documentation of the testing libraries at [http://ruby-doc.org/stdlib/](http://ruby-doc.org/stdlib/).
    On this site, select the class listing for `Test::Unit::Assertions` in order to
    view the full documentation of the available assertions plus numerous code samples
    demonstrating their usage.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的断言列表提供方便参考。每个断言的完整解释超出了本书的范围。您可以在[http://ruby-doc.org/stdlib/](http://ruby-doc.org/stdlib/)找到测试库的完整文档。在这个网站上，选择`Test::Unit::Assertions`的类列表，以查看可用断言的完整文档以及许多演示它们用法的代码示例。
- en: '**`assert(boolean, message=nil)`**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert(boolean, message=nil)`**'
- en: Asserts that boolean is not false or nil.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 断言布尔值不是false或nil。
- en: '**`assert_block(message="assert_block failed.") {|| ...}`**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_block(message="assert_block failed.") {|| ...}`**'
- en: The assertion upon which all other assertions are based. Passes if the block
    yields true.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他断言基于的断言。如果块返回true则通过。
- en: '**`assert_equal(expected, actual, message=nil`**`)`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_equal(expected, actual, message=nil`**`)**'
- en: Passes if `expected` == `actual`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expected`等于`actual`则通过。
- en: '**`assert_in_delta(expected_float, actual_float, delta, message="")`**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_in_delta(expected_float, actual_float, delta, message="")`**'
- en: Passes if `expected_float` and `actual_float` are equal within `delta` tolerance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`expected_float`和`actual_float`在`delta`容差内相等则通过。
- en: '**`assert_instance_of(klass, object, message="")`**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_instance_of(klass, object, message="")`**'
- en: Passes if object `.instance_of?` klass.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象`.instance_of?` klass则通过。
- en: '**`assert_kind_of(klass, object, message="")`**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_kind_of(klass, object, message="")`**'
- en: Passes if object `.kind_of?` klass.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象`.kind_of?` klass则通过。
- en: '**`assert_match(pattern, string, message="")`**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_match(pattern, string, message="")`**'
- en: Passes if string `=˜` pattern.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串`=˜`模式则通过。
- en: '**`assert_nil(object, message="")`**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_nil(object, message="")`**'
- en: Passes if object is `nil`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是`nil`则通过。
- en: '**`assert_no_match(regexp, string, message="")`**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_no_match(regexp, string, message="")`**'
- en: Passes if regexp `!˜` string.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正则表达式 `!˜` 字符串，则通过。
- en: '**`assert_not_equal(expected, actual, message="")`**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_not_equal(expected, actual, message="")`**'
- en: Passes if expected `!=` actual.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期 `!=` 实际，则通过。
- en: '**`assert_not_nil(object, message="")`**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_not_nil(object, message="")`**'
- en: Passes if `!` object .nil?.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `!` 对象 .nil?，则通过。
- en: '**`assert_not_same(expected, actual, message="")`**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_not_same(expected, actual, message="")`**'
- en: Passes if `!` actual `.equal?` expected.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `!` 实际 `.equal?` 预期，则通过。
- en: '**`assert_nothing_raised(*args) {|| ...}`**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_nothing_raised(*args) {|| ...}`**'
- en: Passes if block does not raise an exception.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果块没有引发异常，则通过。
- en: '**`assert_nothing_thrown(message="", &proc)`**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_nothing_thrown(message="", &proc)`**'
- en: Passes if block does not throw anything.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果块没有抛出任何东西，则通过。
- en: '**`assert_operator(object1, operator, object2, message="")`**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_operator(object1, operator, object2, message="")`**'
- en: Compares the `object1` with `object2` using operator. Passes if `object1.send(operator,
    object2)` is true.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作符比较 `object1` 和 `object2`。如果 `object1.send(operator, object2)` 为真，则通过。
- en: '**`assert_raise(*args) {|| ...}`**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_raise(*args) {|| ...}`**'
- en: Passes if the block raises one of the given exceptions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果块引发给定的任何一个异常，则通过。
- en: '**`assert_raises(*args, &block)`**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_raises(*args, &block)`**'
- en: Alias of `assert_raise`. (Deprecated in Ruby 1.9 and to be removed in 2.0.)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert_raise` 的别名。（在 Ruby 1.9 中已弃用，并在 2.0 中将被删除。）'
- en: '**`assert_respond_to(object, method, message="")`**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_respond_to(object, method, message="")`**'
- en: Passes if object `.respond_to?` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象 `.respond_to?` 方法，则通过。
- en: '**`assert_same(expected, actual, message="")`**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_same(expected, actual, message="")`**'
- en: Passes if actual `.equal?` expected (in other words, they are the same instance).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实际 `.equal?` 预期（换句话说，它们是同一个实例），则通过。
- en: '**`assert_send(send_array, message="")`**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_send(send_array, message="")`**'
- en: Passes if the method send returns a true value.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法发送返回一个真值，则通过。
- en: '**`assert_throws(expected_symbol, message="", &proc)`**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**`assert_throws(expected_symbol, message="", &proc)`**'
- en: Passes if the block throws `expected_symbol`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果块抛出 `expected_symbol`，则通过。
- en: '**`build_message(head, template=nil, *arguments)`**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**`build_message(head, template=nil, *arguments)`**'
- en: Builds a failure message; head is added before the template and `*arguments`
    replaces the question marks positionally in the template.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个失败消息；在模板之前添加标题，`*arguments` 位置替换模板中的问号。
- en: '**`flunk(message="Flunked")`**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**`flunk(message="Flunked")`**'
- en: '`flunk` always fails.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`flunk` 总是失败。'
- en: Line Breaks Are Significant
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符很重要
- en: 'I said earlier that you need to take care when entering line breaks into the
    interactive Ruby console (IRB) since the position of line breaks may alter the
    meaning of your Ruby code. So, for example, the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，在交互式 Ruby 控制台（IRB）中输入换行符时需要小心，因为换行符的位置可能会改变 Ruby 代码的含义。所以，例如，以下：
- en: '*linebreaks.rb*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*linebreaks.rb*'
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'assigns `18` to `x`, but the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `18` 分配给 `x`，但以下：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: assigns `8` to `x`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `8` 分配给 `x`。
- en: This is not merely a quirk of IRB. This is normal behavior of Ruby code even
    when entered into a text editor and executed by the Ruby interpreter. The second
    example just shown evaluates `10` on the first line, finds this to be a perfectly
    acceptable value, and promptly forgets about it; then it evaluates `+ (2*4)`,
    which it also finds to be an acceptable value (`8`), but it has no connection
    with the previous value (`10`), so `8` is returned and assigned to `x`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是 IRB 的一个怪癖。这是 Ruby 代码的正常行为，即使是在文本编辑器中输入并执行时也是如此。第二个例子只是展示了在第一行上评估 `10`，认为这是一个完全可接受的价值，并立即忘记它；然后它评估
    `+ (2*4)`，它也认为这是一个可接受的价值（`8`），但它与前面的值（`10`）没有关联，所以 `8` 被返回并分配给 `x`。
- en: 'If you want to tell Ruby to evaluate expressions split over multiple lines,
    ignoring the line breaks, you can use the line continuation character (`\`). This
    is what I’ve done here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让 Ruby 评估跨越多行的表达式，忽略换行符，你可以使用行续行符（`\`）。这就是我在这里所做的事情：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This time, `x` is assigned the value `18`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`x` 被赋予了值 `18`。
- en: Graphical Debuggers
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图形调试器
- en: For serious debugging, I strongly recommend a graphical debugger. For example,
    the debugger in the Ruby In Steel IDE allows you to set breakpoints and watchpoints
    by clicking the margin of the editor.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于严重的调试，我强烈推荐使用图形调试器。例如，Ruby In Steel IDE 中的调试器允许您通过单击编辑器的边缘来设置断点和观察点。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860166.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860166.png)'
- en: It lets you monitor the values of selected “watch variables” or all local variables
    in separate docked windows. It maintains a “callstack” of all method calls leading
    to the current point of execution and allows you to navigate “backward” through
    the callstack to view the changing values of variables. It also has “drill-down”
    expansion of variables to allow you to expand arrays and hashes and look inside
    complex objects. These capabilities go well beyond the features of the standard
    Ruby debugger. For information on Ruby IDEs, see [Appendix D](apd.html "Appendix D. Ruby
    and Rails Development Software").
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你在单独的浮动窗口中监控所选的“监视变量”或所有局部变量的值。它维护一个指向当前执行点的所有方法调用的“调用栈”，并允许你通过调用栈“向后导航”以查看变量的变化值。它还具有变量的“钻取”展开功能，允许你展开数组、散列并查看复杂对象内部。这些功能远远超出了标准Ruby调试器的功能。有关Ruby
    IDE的信息，请参阅[附录D](apd.html "附录D. Ruby和Rails开发软件")。
