- en: Chapter 3. Escape from the WWW Zone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 逃离WWW区域
- en: Note
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Thursday, August 23, 2007*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*2007年8月23日，星期四*'
- en: '*Dear Diary*,'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*亲爱的日记*，'
- en: I’ve always been a big fan of vulnerabilities in operating system kernels because
    they’re usually quite interesting, very powerful, and tricky to exploit. I recently
    combed through several operating system kernels in search of bugs. One of the
    kernels that I searched through was the kernel of Sun Solaris. And guess what?
    I was successful. ![](httpatomoreillycomsourcenostarchimages939227.png)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直对操作系统内核中的漏洞很感兴趣，因为它们通常很有趣，非常强大，而且很难利用。我最近仔细检查了几个操作系统内核以寻找漏洞。我检查的一个内核是Sun
    Solaris的内核。猜猜看？我成功了。![更多](httpatomoreillycomsourcenostarchimages939227.png)
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On January 27, 2010, Sun was acquired by Oracle Corporation. Oracle now generally
    refers to Solaris as “Oracle Solaris.”*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*2010年1月27日，Sun被甲骨文公司收购。甲骨文现在通常将Solaris称为“Oracle Solaris”。*'
- en: 3.1 Vulnerability Discovery
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 漏洞发现
- en: Since the launch of OpenSolaris in June 2005, Sun has made most of its Solaris
    10 operating system freely available as open source, including the kernel. So
    I downloaded the source code^([[23](ch03s05.html#ftn.CHP-3-FN-1)]) and started
    reading the kernel code, focusing on the parts that implement the user-to-kernel
    interfaces, like IOCTLs and system calls.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2005年6月OpenSolaris发布以来，Sun已经将大多数Solaris 10操作系统作为开源软件免费提供，包括内核。因此，我下载了源代码[23](ch03s05.html#ftn.CHP-3-FN-1)]并开始阅读内核代码，重点关注实现用户到内核接口的部分，如IOCTLs和系统调用。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Input/output controls* (*IOCTLs*) are used for communication between user-mode
    applications and the kernel.^([[24](ch03s05.html#ftn.CHP-3-FN-2)])'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入/输出控制（IOCTLs）用于用户模式应用程序和内核之间的通信。[24](ch03s05.html#ftn.CHP-3-FN-2)]'
- en: '*Any user-to-kernel interface or API that results in information being passed
    over to the kernel for processing creates a potential attack vector. The most
    commonly used are*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何导致信息被传递到内核进行处理的用户到内核接口或API都会创建一个潜在的攻击向量。最常用的包括*：'
- en: '*IOCTLs*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IOCTLs*'
- en: '*System calls*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统调用*'
- en: '*Filesystems*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统*'
- en: '*Network stack*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网络栈*'
- en: '*Hooks of third-party drivers*'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三方驱动程序的钩子*'
- en: The vulnerability that I found is one of the most interesting I’ve discovered
    because its cause—an undefined error condition—is unusual for an exploitable vulnerability
    (compared to the average overflow bugs). It affects the implementation of the
    `SIOCGTUNPARAM` IOCTL call, which is part of the IP-in-IP tunneling mechanism
    provided by the Solaris kernel.^([[25](ch03s05.html#ftn.CHP-3-FN-3)])
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现的漏洞是我发现的最有趣的之一，因为其成因——一个未定义的错误条件——对于一个可利用的漏洞来说是不寻常的（与平均的溢出漏洞相比）。它影响了`SIOCGTUNPARAM`
    IOCTL调用的实现，这是Solaris内核提供的IP-in-IP隧道机制的一部分。[25](ch03s05.html#ftn.CHP-3-FN-3)
- en: 'I took the following steps to find the vulnerability:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我采取了以下步骤来发现漏洞：
- en: 'Step 1: List the IOCTLs of the kernel.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步：列出内核的IOCTLs。
- en: 'Step 2: Identify the input data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步：识别输入数据。
- en: 'Step 3: Trace the input data.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3步：跟踪输入数据。
- en: These steps are described in detail below.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在下面将详细描述。
- en: 'Step 1: List the IOCTLs of the Kernel'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步：列出内核的IOCTLs。
- en: 'There are different ways to generate a list of the IOCTLs of a kernel. In this
    case, I simply searched the kernel source code for the customary IOCTL macros.
    Every IOCTL gets its own number, usually created by a macro. Depending on the
    IOCTL type, the Solaris kernel defines the following macros: `_IOR`, `_IOW`, and
    `_IOWR`. To list the IOCTLs, I changed to the directory where I unpacked the kernel
    source code and used the Unix `grep` command to search the code.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法可以生成内核IOCTLs的列表。在这种情况下，我简单地搜索了内核源代码中的常用IOCTL宏。每个IOCTL都有自己的编号，通常由宏创建。根据IOCTL类型，Solaris内核定义了以下宏：`_IOR`、`_IOW`和`_IOWR`。要列出IOCTLs，我切换到了解包内核源代码的目录，并使用Unix的`grep`命令搜索代码。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I now had a list of IOCTL names supported by the Solaris kernel. To find the
    source files that actually process these IOCTLs, I searched the whole kernel source
    for each IOCTL name on the list. Here is an example search for the `SIOCTONLINK`
    IOCTL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了Solaris内核支持的IOCTL名称列表。为了找到实际处理这些IOCTLs的源文件，我在整个内核源代码中搜索列表中的每个IOCTL名称。以下是对`SIOCTONLINK`
    IOCTL的搜索示例：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Step 2: Identify the Input Data'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步：识别输入数据
- en: 'The Solaris kernel provides different interfaces for IOCTL processing. The
    interface that is relevant for the vulnerability I found is a programming model
    called *STREAMS*.^([[26](ch03s05.html#ftn.CHP-3-FN-4)]) Intuitively, the fundamental
    STREAMS unit is called a *Stream*, which is a data transfer path between a process
    in user space and the kernel. All kernel-level input and output under STREAMS
    are based on STREAMS messages, which usually contain the following elements: a
    data buffer, a data block, and a message block. The *data buffer* is the location
    in memory where the actual data of the message is stored. The *data block* (`struct
    datab`) describes the data buffer. The *message block* (`struct msgb`) describes
    the data block and how the data is used.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Solaris 内核为 IOCTL 处理提供了不同的接口。与我发现的漏洞相关的接口是一个称为 *STREAMS* 的编程模型。[26](ch03s05.html#ftn.CHP-3-FN-4)]
    直观地说，基本的 STREAMS 单元被称为 *Stream*，它是用户空间进程和内核之间的数据传输路径。所有在 STREAMS 下的内核级输入和输出都基于
    STREAMS 消息，这些消息通常包含以下元素：数据缓冲区、数据块和消息块。*数据缓冲区* 是消息实际数据存储在内存中的位置。*数据块* (`struct
    datab`) 描述了数据缓冲区。*消息块* (`struct msgb`) 描述了数据块以及数据的使用方式。
- en: The message block structure has the following public elements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块结构具有以下公共元素。
- en: '**Source code file**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/sys/stream.h*^([[27](ch03s05.html#ftn.CHP-3-FN-5)])'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/sys/stream.h*^([[27](ch03s05.html#ftn.CHP-3-FN-5)])'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The structure elements `b_rptr` and `b_wptr` specify the current read and write
    pointers in the data buffer pointed to by `b_datap` (see [Figure 3-1](ch03.html#diagram_of_a_simple_streams_message
    "Figure 3-1. Diagram of a simple STREAMS message")).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 结构元素 `b_rptr` 和 `b_wptr` 指定了由 `b_datap` 指向的数据缓冲区中的当前读和写指针（参见 [图 3-1](ch03.html#diagram_of_a_simple_streams_message
    "图 3-1. 简单 STREAMS 消息的示意图")）。
- en: '![Diagram of a simple STREAMS message](httpatomoreillycomsourcenostarchimages939249.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![简单 STREAMS 消息的示意图](httpatomoreillycomsourcenostarchimages939249.png.jpg)'
- en: Figure 3-1. Diagram of a simple STREAMS message
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1. 简单 STREAMS 消息的示意图
- en: When using the STREAMS model, the IOCTL input data is referenced by the `b_rptr`
    element of the `msgb` structure, or its typedef `mblk_t`. Another important component
    of the STREAMS model is the so-called *linked message blocks*. As described in
    the *STREAMS Programming Guide*, “[a] complex message can consist of several linked
    message blocks. If buffer size is limited or if processing expands the message,
    multiple message blocks are formed in the message” (see [Figure 3-2](ch03.html#diagram_of_linked_streams_message_blocks
    "Figure 3-2. Diagram of linked STREAMS message blocks")).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 STREAMS 模型时，`msgb` 结构的 `b_rptr` 元素或其类型定义 `mblk_t` 引用了 IOCTL 输入数据。STREAMS
    模型的另一个重要组成部分是所谓的 *链式消息块*。如 *STREAMS 编程指南* 所述，“一个复杂消息可以由多个链式消息块组成。如果缓冲区大小有限或处理扩展了消息，则消息中会形成多个消息块”（参见
    [图 3-2](ch03.html#diagram_of_linked_streams_message_blocks "图 3-2. 链式 STREAMS
    消息块的示意图")）。
- en: '![Diagram of linked STREAMS message blocks](httpatomoreillycomsourcenostarchimages939251.png.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![链式 STREAMS 消息块的示意图](httpatomoreillycomsourcenostarchimages939251.png.jpg)'
- en: Figure 3-2. Diagram of linked STREAMS message blocks
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2. 链式 STREAMS 消息块的示意图
- en: 'Step 3: Trace the Input Data'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步：追踪输入数据
- en: I then took the list of IOCTLs and started reviewing the code. As usual, I searched
    the code for input data and then traced that data while looking for coding errors.
    After a few hours, I found the vulnerability.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后审查了 IOCTL 列表，并像往常一样在代码中搜索输入数据，同时追踪这些数据以寻找编码错误。几小时后，我发现了一个漏洞。
- en: '**Source code file**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip.c*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip.c*'
- en: '**Function**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_process_ioctl()`^([[28](ch03s05.html#ftn.CHP-3-FN-6)])'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_process_ioctl()`^([[28](ch03s05.html#ftn.CHP-3-FN-6)])'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When a `SIOCGTUNPARAM` IOCTL request is sent to the kernel, the function `ip_process_ioctl()`
    is called. In line 26717, the value of `ci.ci_ipif` is explicitly set to `NULL`.
    Because of the `SIOCGTUNPARAM` IOCTL call, the switch case `TUN_CMD` is chosen
    (see line 26735), and the function `ip_extract_tunreq()` is called (see line 26740).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当向内核发送 `SIOCGTUNPARAM` IOCTL 请求时，会调用 `ip_process_ioctl()` 函数。在第 26717 行，`ci.ci_ipif`
    的值被显式设置为 `NULL`。由于 `SIOCGTUNPARAM` IOCTL 调用，选择开关 `TUN_CMD`（参见第 26735 行），并调用 `ip_extract_tunreq()`
    函数（参见第 26740 行）。
- en: '**Source code file**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_extract_tunreq()`^([[29](ch03s05.html#ftn.CHP-3-FN-7)])'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_extract_tunreq()`^([[29](ch03s05.html#ftn.CHP-3-FN-7)])'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In line 8178, a linked STREAMS message block is referenced, and on line 8179,
    the structure `ta` is filled with the user-controlled IOCTL data. Later on, the
    function `ipif_lookup_on_name()` is called (see line 8192). The first two parameters
    of `ipif_lookup_on_name()` derive from the user-controllable data of structure
    `ta`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8178 行，引用了一个链接的 STREAMS 消息块，在第 8179 行，结构 `ta` 被填充了用户控制的 IOCTL 数据。稍后，调用了函数
    `ipif_lookup_on_name()`（见第 8192 行）。`ipif_lookup_on_name()` 的前两个参数来自结构 `ta` 的用户可控制数据。
- en: '**Source code file**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ipif_lookup_on_name()`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipif_lookup_on_name()`'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In line 19139, the value of `error` is explicitly set to 0\. Then in line 19161,
    the interface name provided by the user-controlled IOCTL data is checked for the
    presence of a colon (`IPIF_SEPARATOR_CHAR` is defined as a colon). If a colon
    is found in the name, the bytes after the colon are treated as an interface alias.
    If an alias has two or more digits and the first is zero (ASCII zero or hexadecimal
    `0x30`; see line 19175), the function `ipif_lookup_on_name()` returns to `ip_extract_tunreq()`
    with a return value of `NULL`, and the variable `error` is still set to 0 (see
    lines 19139 and 19176).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 19139 行，`error` 的值被显式设置为 0。然后在第 19161 行，用户通过 IOCTL 数据提供的接口名称检查是否存在冒号（`IPIF_SEPARATOR_CHAR`
    被定义为冒号）。如果在名称中找到冒号，冒号之后的字节被视为接口别名。如果别名有两个或更多数字，并且第一个是零（ASCII 零或十六进制 `0x30`；见第
    19175 行），则函数 `ipif_lookup_on_name()` 将返回 `NULL` 给 `ip_extract_tunreq()`，并且变量 `error`
    仍然设置为 0（见第 19139 和 19176 行）。
- en: '**Source code file**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_extract_tunreq()`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_extract_tunreq()`'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Back in `ip_extract_tunreq()`, the pointer `ipif` is set to `NULL` if `ipif_lookup_on_name()`
    returns that value (see line 8192). Since `ipif` is `NULL`, the `if` statement
    in line 8195 returns `TRUE`, and line 8196 is executed. The `ip_extract_tunreq()`
    function then returns to `ip_process_ioctl()` with `error` as a return value,
    which is still set to 0.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `ip_extract_tunreq()`，如果 `ipif_lookup_on_name()` 返回该值，则指针 `ipif` 被设置为 `NULL`（见第
    8192 行）。由于 `ipif` 是 `NULL`，第 8195 行的 `if` 语句返回 `TRUE`，第 8196 行被执行。然后 `ip_extract_tunreq()`
    函数将 `error` 作为返回值返回给 `ip_process_ioctl()`，该返回值仍然设置为 0。
- en: '**Source code file**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip.c*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip.c*'
- en: '**Function**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_process_ioctl()`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_process_ioctl()`'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Back in `ip_process_ioctl()`, the variable `err` is set to 0 since `ip_extract_tunreq()`
    returns that value (see line 26740). Because `err` equals 0, the `if` statement
    in line 26741 returns `FALSE`, and lines 26742 and 26743 are not executed. In
    line 26788, the function pointed to by `ipip->ipi_func`—in this case the function
    `ip_sioctl_tunparam()`—is called while the first parameter, `ci.ci_ipif`, is still
    set to `NULL` (see line 26717).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ip_process_ioctl()` 函数中，变量 `err` 被设置为 0，因为 `ip_extract_tunreq()` 返回该值（见第
    26740 行）。由于 `err` 等于 0，第 26741 行的 `if` 语句返回 `FALSE`，第 26742 和 26743 行不执行。在第 26788
    行，`ipip->ipi_func` 指向的函数——在本例中是 `ip_sioctl_tunparam()` 函数——被调用，而第一个参数 `ci.ci_ipif`
    仍然设置为 `NULL`（见第 26717 行）。
- en: '**Source code file**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_sioctl_tunparam()`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_sioctl_tunparam()`'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the first parameter of `ip_sioctl_tunparam()` is `NULL`, the reference
    `ipif->ipif_ill` in line 9432 can be represented as `NULL->ipif_ill`, which is
    a classic NULL pointer dereference. If this NULL pointer dereference is triggered,
    the whole system will crash due to a kernel panic. (See Section A.2 for more information
    on NULL pointer dereferences.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ip_sioctl_tunparam()` 的第一个参数是 `NULL`，第 9432 行的 `ipif->ipif_ill` 引用可以表示为
    `NULL->ipif_ill`，这是一个经典的空指针解引用。如果触发这种空指针解引用，整个系统将由于内核恐慌而崩溃。（有关空指针解引用的更多信息，请参阅第
    A.2 节。）
- en: 'Summary of the results so far:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前结果总结：
- en: An unprivileged user of a Solaris system can call the `SIOCGTUNPARAM` IOCTL
    (see (1) in [Figure 3-3](ch03.html#summary_of_the_results_so_far._an_unpriv "Figure 3-3. Summary
    of the results so far. An unprivileged user can force a system crash by triggering
    a NULL pointer dereference in the Solaris kernel.")).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris 系统的无权限用户可以调用 `SIOCGTUNPARAM` IOCTL（见[图 3-3](ch03.html#summary_of_the_results_so_far._an_unpriv
    "图 3-3. 目前结果总结。无权限用户可以通过触发 Solaris 内核中的空指针解引用强制系统崩溃。")中的(1)）。
- en: If the IOCTL data sent to the kernel is carefully crafted—there has to be an
    interface name with a colon directly followed by an ASCII zero and another arbitrary
    digit—it’s possible to trigger a NULL pointer dereference (see (2) in [Figure 3-3](ch03.html#summary_of_the_results_so_far._an_unpriv
    "Figure 3-3. Summary of the results so far. An unprivileged user can force a system
    crash by triggering a NULL pointer dereference in the Solaris kernel.")) that
    leads to a system crash (see (3) in [Figure 3-3](ch03.html#summary_of_the_results_so_far._an_unpriv
    "Figure 3-3. Summary of the results so far. An unprivileged user can force a system
    crash by triggering a NULL pointer dereference in the Solaris kernel.")).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发送到内核的 IOCTL 数据被精心构造——必须有一个接口名称，该名称直接跟一个 ASCII 零和一个任意数字——则可以触发空指针解引用（见图 3-3
    中的（2）），这会导致系统崩溃（见图 3-3 中的（3））。
- en: But why is it possible to trigger that NULL pointer dereference? Where exactly
    is the coding error that leads to the bug?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么可以触发那个空指针解引用？导致错误的编码错误究竟在哪里？
- en: The problem is that `ipif_lookup_on_name()` can be forced to return to its caller
    function without an appropriate error condition being set.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `ipif_lookup_on_name()` 可以被强制返回到其调用函数，而无需设置适当的错误条件。
- en: 'This bug exists in part because the `ipif_lookup_on_name()` function reports
    error conditions to its caller in two different ways: through the return value
    of the function (`return (null)`) as well as through the variable `error` (`*error
    != 0`). Each time the function is called, the authors of the kernel code must
    ensure that both error conditions are properly set and are properly evaluated
    within the caller function. Such a coding style is error-prone and therefore not
    recommended. The vulnerability described in this chapter is an excellent example
    of the kind of problem that can arise from such code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误部分存在是因为 `ipif_lookup_on_name()` 函数以两种不同的方式向其调用函数报告错误条件：通过函数的返回值（`return
    (null)`）以及通过变量 `error`（`*error != 0`）。每次函数被调用时，内核代码的作者必须确保两个错误条件都得到适当的设置，并在调用函数中正确评估。这种编码风格容易出错，因此不推荐使用。本章中描述的漏洞是这种代码可能引起的问题的一个很好的例子。
- en: '![Summary of the results so far. An unprivileged user can force a system crash
    by triggering a NULL pointer dereference in the Solaris kernel.](httpatomoreillycomsourcenostarchimages939253.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![到目前已经的结果总结。一个非特权用户可以通过在 Solaris 内核中触发空指针解引用来强制系统崩溃。](httpatomoreillycomsourcenostarchimages939253.png.jpg)'
- en: Figure 3-3. Summary of the results so far. An unprivileged user can force a
    system crash by triggering a NULL pointer dereference in the Solaris kernel.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3. 到目前为止的结果总结。一个非特权用户可以通过在 Solaris 内核中触发空指针解引用来强制系统崩溃。
- en: '**Source code file**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ipif_lookup_on_name()`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipif_lookup_on_name()`'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In line 19139, the value of `error`, which holds one of the error conditions,
    is explicitly set to 0\. Error condition 0 means that no error has occurred so
    far. By supplying a colon directly followed by an ASCII zero and an arbitrary
    digit in the interface name, it is possible to trigger the code in line 19176,
    which leads to a return to the caller function. The problem is that no valid error
    condition is set for `error` before the function returns. So `ipif_lookup_on_name()`
    returns to `ip_extract_tunreq()` with `error` still set to 0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 19139 行，保存一个错误条件的 `error` 的值被明确设置为 0。错误条件 0 表示到目前为止没有发生错误。通过在接口名称中直接提供一个冒号后跟一个
    ASCII 零和一个任意数字，可以触发第 19176 行的代码，这会导致返回调用函数。问题是函数返回之前没有为 `error` 设置有效的错误条件。因此，`ipif_lookup_on_name()`
    以 `error` 仍然设置为 0 的状态返回到 `ip_extract_tunreq()`。
- en: '**Source code file**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_extract_tunreq()`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_extract_tunreq()`'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Back in `ip_extract_tunreq()`, the error condition is returned to its caller
    function `ip_process_ioctl()` (see line 8196).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ip_extract_tunreq()` 函数中，错误条件被返回给其调用函数 `ip_process_ioctl()`（见第 8196 行）。
- en: '**Source code file**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip.c*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip.c*'
- en: '**Function**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_process_ioctl()`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_process_ioctl()`'
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then in `ip_process_ioctl()`, the error condition is still set to 0\. Thus,
    the `if` statement in line 26741 returns `FALSE`, and the kernel continues the
    execution of the rest of the function leading to the NULL pointer dereference
    in `ip_sioctl_tunparam()`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `ip_process_ioctl()` 函数中，错误条件仍然设置为 0。因此，第 26741 行的 `if` 语句返回 `FALSE`，内核继续执行函数的其余部分，导致在
    `ip_sioctl_tunparam()` 中发生空指针解引用。
- en: What a nice bug!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 多好的一个漏洞啊！
- en: '[Figure 3-4](ch03.html#call_graph_summarizing_the_relationships "Figure 3-4. Call
    graph summarizing the relationships of the functions involved in the NULL pointer
    dereference bug. The numbers shown refer to the chronological order of events.")
    shows a call graph summarizing the relationships of the functions involved in
    the NULL pointer dereference bug.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-4](ch03.html#call_graph_summarizing_the_relationships "图 3-4. 总结涉及空指针解引用错误的函数之间关系的调用图。显示的数字表示事件的顺序。")
    显示了一个调用图，总结了涉及空指针解引用错误的函数之间的关系。'
- en: '![Call graph summarizing the relationships of the functions involved in the
    NULL pointer dereference bug. The numbers shown refer to the chronological order
    of events.](httpatomoreillycomsourcenostarchimages939255.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![总结涉及空指针解引用错误的函数之间关系的调用图。显示的数字表示事件的顺序。](httpatomoreillycomsourcenostarchimages939255.png.jpg)'
- en: Figure 3-4. Call graph summarizing the relationships of the functions involved
    in the NULL pointer dereference bug. The numbers shown refer to the chronological
    order of events.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4. 总结涉及空指针解引用错误的函数之间关系的调用图。显示的数字表示事件的顺序。
- en: 3.2 Exploitation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 利用
- en: Exploiting this bug was an exciting challenge. NULL pointer dereferences are
    usually labeled as unexploitable bugs because they can generally be used for a
    denial-of-service attack but not for arbitrary code execution. However, this NULL
    pointer dereference is different, as it can be successfully exploited for arbitrary
    code execution at the kernel level.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个漏洞是一个令人兴奋的挑战。空指针解引用通常被标记为不可利用的错误，因为它们通常可以用于拒绝服务攻击，但不能用于任意代码执行。然而，这个空指针解引用是不同的，因为它可以在内核级别成功用于任意代码执行。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The platform that I used throughout this section was the default installation
    of Solaris 10 10/08 x86/x64 DVD Full Image (sol-10-u6-ga1-x86-dvd.iso), which
    is called Solaris 10 Generic_137138-09*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在本节中使用的平台是 Solaris 10 10/08 x86/x64 DVD 全镜像（sol-10-u6-ga1-x86-dvd.iso），被称为
    Solaris 10 Generic_137138-09*。'
- en: 'To exploit the vulnerability, I performed the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这个漏洞，我执行了以下步骤：
- en: Trigger the NULL pointer dereference for a denial of service.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发空指针解引用以实现拒绝服务。
- en: Use the zero page to get control over `EIP`/`RIP`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用零页来控制 `EIP`/`RIP`。
- en: 'Step 1: Trigger the NULL Pointer Dereference for a Denial of Service'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 步：触发空指针解引用以实现拒绝服务
- en: To trigger the NULL pointer dereference, I wrote the following proof-of-concept
    (POC) code (see [Example 3-1](ch03s02.html#proof-of-concept_code "Example 3-1. Proof-of-concept
    code (poc.c) that I wrote to trigger the NULL pointer dereference bug I found
    in Solaris")).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发空指针解引用，我编写了以下 PoC 代码（见 [示例 3-1](ch03s02.html#proof-of-concept_code "示例 3-1.
    我编写的用于触发在 Solaris 中发现的空指针解引用错误的 PoC 代码 (poc.c)"))。
- en: Example 3-1. Proof-of-concept code (*poc.c*) that I wrote to trigger the NULL
    pointer dereference bug I found in Solaris
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1. 我编写的用于触发在 Solaris 中发现的空指针解引用错误的 PoC 代码（*poc.c*）。
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The POC code first opens the kernel network device `/dev/arp` (see line 14).
    Note that the devices `/dev/tcp` and `/dev/udp` also support the `SIOCGTUNPARAM`
    IOCTL and could therefore be used instead of `/dev/arp`. Next, the IOCTL data
    is prepared (see lines 22–25). The data consists of an interface name with invalid
    alias `:01` to trigger the bug. Finally the `SIOCGTUNPARAM` IOCTL is called and
    the IOCTL data is sent to the kernel (see line 28).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PoC 代码首先打开内核网络设备 `/dev/arp`（见第 14 行）。请注意，设备 `/dev/tcp` 和 `/dev/udp` 也支持 `SIOCGTUNPARAM`
    IOCTL，因此可以用它们代替 `/dev/arp`。接下来，准备 IOCTL 数据（见第 22-25 行）。数据由一个具有无效别名 `:01` 的接口名称组成，以触发错误。最后调用
    `SIOCGTUNPARAM` IOCTL 并将 IOCTL 数据发送到内核（见第 28 行）。
- en: 'I then compiled and tested the POC code as an unprivileged user on a Solaris
    10 64-bit system:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将 PoC 代码作为一个无特权的用户在 Solaris 10 64 位系统上编译和测试：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The system crashed immediately and rebooted. After the reboot, I logged in
    as root and inspected the kernel crash files with the help of Solaris Modular
    Debugger (mdb)^([[30](ch03s05.html#ftn.CHP-3-FN-8)]) (see Section B.1 for a description
    of the following debugger commands):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 系统立即崩溃并重新启动。重启后，我以root身份登录，并在Solaris模块化调试器（mdb）的帮助下检查了内核崩溃文件^([[30](ch03s05.html#ftn.CHP-3-FN-8)])（有关以下调试器命令的描述，请参阅B.1节）：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I used the `::msgbuf` debugger command to display the message buffer, including
    all console messages up to the kernel panic:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`::msgbuf`调试器命令来显示消息缓冲区，包括所有控制台消息，直到内核恐慌：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The debugger output shows that the kernel panic happened due to a NULL pointer
    dereference at address `0xfffffffff6314c7c` (see the value of the `RIP` register).
    Next, I asked the debugger to display the instruction at that address:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器输出显示，内核恐慌是由于地址`0xfffffffff6314c7c`处的空指针解引用引起的（请参阅`RIP`寄存器的值）。接下来，我要求调试器显示该地址处的指令：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The crash was caused by the instruction `movq 0x8(%r13),%r14` at address `ip_sioctl_tunparam+0x5c`.
    The instruction tried to reference the value pointed to by register `r13`. As
    the debugger output of the `::msgbuf` command shows, `r13` had the value 0 at
    the time of the crash. So the assembler instruction is equivalent to the NULL
    pointer dereference that happens in `ip_sioctl_tunparam()` (see line 9432 in the
    following code snippet).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 崩溃是由地址`ip_sioctl_tunparam+0x5c`处的指令`movq 0x8(%r13),%r14`引起的。该指令试图引用寄存器`r13`指向的值。正如`::msgbuf`命令的调试器输出所示，在崩溃时`r13`的值为0。因此，汇编指令相当于在`ip_sioctl_tunparam()`中发生的空指针解引用（请参阅以下代码片段中的第9432行）。
- en: '**Source code file**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_sioctl_tunparam()`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_sioctl_tunparam()`'
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I was able to demonstrate that this bug can be successfully exploited by an
    unprivileged user to crash the system. Because all Solaris Zones share the same
    kernel, it’s also possible to crash the whole system (all zones), even if the
    vulnerability is triggered in an unprivileged, non-global zone (see Section C.3
    for more information on the Solaris Zones technology). Any hosting provider using
    the Solaris Zones functionality could be greatly impacted if it were exploited
    by someone with malicious intent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我能够证明这个漏洞可以被无权限用户成功利用来使系统崩溃。因为所有Solaris Zones共享相同的内核，所以即使漏洞在无权限的非全局区域触发，也有可能使整个系统（所有区域）崩溃（请参阅C.3节以获取有关Solaris
    Zones技术的更多信息）。如果被恶意意图的人利用，任何使用Solaris Zones功能的托管服务提供商都可能受到严重影响。
- en: 'Step 2: Use the Zero Page to Get Control over EIP/RIP'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤2：使用零页来控制EIP/RIP
- en: 'After I was able to crash the system, I decided to attempt arbitrary code execution.
    To do this, I had to solve the following two problems:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我能够使系统崩溃后，我决定尝试任意代码执行。为此，我必须解决以下两个问题：
- en: Prevent the system from crashing as the NULL pointer dereference gets triggered.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止系统因空指针解引用而崩溃。
- en: Take control over `EIP`/`RIP`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制EIP/RIP。
- en: 'The system crash is caused by the NULL pointer dereference. As the zero or
    NULL page is normally not mapped, the dereference leads to an access violation
    that crashes the system (see also Section A.2). All I had to do to prevent the
    system from crashing was to map the zero page before triggering the NULL pointer
    dereference. This can be done easily on the x86 and AMD64 architecture, because
    Solaris segregates the virtual address space of processes on these platforms into
    two parts: user space and kernel space (see [Figure 3-5](ch03s02.html#virtual_address_space_of_a_process_open
    "Figure 3-5. Virtual address space of a process (Solaris x86 64-bit)")). User
    space is where all user-mode applications run, while kernel space is where the
    kernel itself, as well as kernel extensions (e.g., drivers), run. However, the
    kernel and the user space of a process share the same zero page.^([[31](ch03s05.html#ftn.CHP-3-FN-9)])'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 系统崩溃是由空指针解引用引起的。由于零页或空页通常未映射，解引用会导致访问违规，从而使系统崩溃（也请参阅A.2节）。为了防止系统崩溃，我必须在触发空指针解引用之前映射零页。在x86和AMD64架构上，这可以很容易地完成，因为Solaris将这些平台上的进程的虚拟地址空间划分为两部分：用户空间和内核空间（请参阅[图3-5](ch03s02.html#virtual_address_space_of_a_process_open
    "图3-5. 进程的虚拟地址空间（Solaris x86 64位）")）。用户空间是所有用户模式应用程序运行的地方，而内核空间是内核本身以及内核扩展（例如，驱动程序）运行的地方。然而，内核和一个进程的用户空间共享相同的零页.^([[31](ch03s05.html#ftn.CHP-3-FN-9)])
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each user-mode address space is unique to a particular process, while the kernel
    address space is shared across all processes. Mapping the NULL page in one process
    only causes it to be mapped in that process’s address space only.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户模式地址空间都是特定进程独有的，而内核地址空间是所有进程共享的。在一个进程中映射NULL页只会导致它在该进程的地址空间中映射。
- en: '![Virtual address space of a process (Solaris x86 64-bit)](httpatomoreillycomsourcenostarchimages939257.png.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![进程的虚拟地址空间（Solaris x86 64位）](httpatomoreillycomsourcenostarchimages939257.png.jpg)'
- en: Figure 3-5. Virtual address space of a process (Solaris x86 64-bit)^([[32](ch03s05.html#ftn.CHP-3-FN-10)])
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5.进程的虚拟地址空间（Solaris x86 64位）^([[32](ch03s05.html#ftn.CHP-3-FN-10)])
- en: 'By mapping the zero page before triggering the NULL pointer dereference, I
    was able to prevent the system from crashing. That got me to the next problem:
    How to gain control over `EIP`/`RIP`? The only data that was under my full control
    was the IOCTL data sent to the kernel and the user-space data of a process, including
    the zero page. The only way to get control was to make the kernel reference some
    data from the zero page that would later be used to control the execution flow
    of the kernel. I thought that approach would not work, but I was wrong.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在触发空指针解引用之前映射零页，我能够防止系统崩溃。这让我遇到了下一个问题：如何控制`EIP`/`RIP`？唯一完全受我控制的数据是发送给内核的IOCTL数据和进程的用户空间数据，包括零页。唯一的方法是让内核引用零页中的某些数据，这些数据将后来用于控制内核的执行流程。我以为这种方法不会奏效，但我错了。
- en: '**Source code file**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/inet/ip/ip_if.c*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/inet/ip/ip_if.c*'
- en: '**Function**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`ip_sioctl_tunparam()`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip_sioctl_tunparam()`'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The NULL pointer dereference happens in line 9432, when `ipif` is forced to
    be `NULL`. This leads to the system crash. But if the zero page is mapped before
    `NULL` is dereferenced, the access violation won’t be triggered, and the system
    won’t crash. Instead, the value of the `ill` structure is determined while referencing
    valid user-controlled data from the zero page. Therefore, all values of the `ill`
    structure can be controlled by carefully crafting the zero page data. I was pleased
    to find that in line 9446, the function `putnext()` is called with the user-controllable
    value of `ill->ill_wq` as a parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ipif`被强制设置为`NULL`时，在第9432行发生空指针解引用，这导致系统崩溃。但如果在解引用`NULL`之前映射零页，则不会触发访问违规，系统也不会崩溃。相反，在引用零页中的有效用户可控数据时，会确定`ill`结构体的值。因此，可以通过精心构建零页数据来控制`ill`结构体的所有值。我很高兴地发现，在第9446行，`putnext()`函数被调用，其参数是用户可控的`ill->ill_wq`值。
- en: '**Source code file**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码文件**'
- en: '*uts/common/os/putnext.c*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*uts/common/os/putnext.c*'
- en: '**Function**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数**'
- en: '`putnext()`^([[33](ch03s05.html#ftn.CHP-3-FN-11)])'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`putnext()`^([[33](ch03s05.html#ftn.CHP-3-FN-11)])'
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The user can fully control the data of the first function parameter of `putnext()`,
    which means that the values of `qp`, `sq`, and `qi` can also be controlled through
    the data of the mapped zero page (see lines 176, 177, and 180). Furthermore, the
    user can control the value of the function pointer declared in line 154 (see line
    273). This function pointer is then called in line 277.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以完全控制`putnext()`的第一个函数参数的数据，这意味着`qp`、`sq`和`qi`的值也可以通过映射零页的数据来控制（参见第176、177和180行）。此外，用户还可以控制第154行声明的函数指针的值（参见第273行）。然后，该函数指针在第277行被调用。
- en: So, in summary, if the data of the mapped zero page is carefully crafted, it’s
    possible to take control of a function pointer, thereby gaining full control over
    `EIP`/`RIP` and resulting in arbitrary code execution at the kernel level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结来说，如果映射零页的数据被精心构建，就有可能控制函数指针，从而完全控制`EIP`/`RIP`，并在内核级别实现任意代码执行。
- en: 'I used the following POC code to gain control over `EIP`/`RIP`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了以下POC代码来控制`EIP`/`RIP`：
- en: Example 3-2. POC code (*poc2.c*) used to gain control of EIP/RIP and thereby
    achieve arbitrary code execution at the kernel.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-2.用于控制EIP/RIP并因此实现内核任意代码执行的POC代码（*poc2.c*）。
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In line 19 of [Example 3-2](ch03s02.html#poc_code_open_parenthesis "Example 3-2. POC
    code (poc2.c) used to gain control of EIP/RIP and thereby achieve arbitrary code
    execution at the kernel."), the zero page is mapped using `mmap()`. But the most
    interesting part of the POC code is the layout of the zero page data (see lines
    32–63). [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page "Figure 3-6. Data
    layout of the zero page") illustrates the relevant parts of this layout.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-2](ch03s02.html#poc_code_open_parenthesis "示例 3-2. 用于获取 EIP/RIP 控制并实现内核任意代码执行的
    POC 代码 (poc2.c)") 的第 19 行，零页通过 `mmap()` 进行映射。但 POC 代码中最有趣的部分是零页数据的布局（见第 32-63
    行）。[图 3-6](ch03s02.html#data_layout_of_the_zero_page "图 3-6. 零页数据布局") 展示了该布局的相关部分。
- en: '![Data layout of the zero page](httpatomoreillycomsourcenostarchimages939259.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![零页数据布局](httpatomoreillycomsourcenostarchimages939259.png.jpg)'
- en: Figure 3-6. Data layout of the zero page
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6. 零页数据布局
- en: The left-hand side of [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page
    "Figure 3-6. Data layout of the zero page") shows the offsets into the zero page.
    The middle lists the actual values of the zero page. The right-hand side shows
    the references the kernel makes into the zero page. [Table 3-1](ch03s02.html#description_of_the_zero_page_data_layout
    "Table 3-1. Description of the Zero Page Data Layout") describes the zero page
    data layout illustrated in [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page
    "Figure 3-6. Data layout of the zero page").
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](ch03s02.html#data_layout_of_the_zero_page "图 3-6. 零页数据布局") 的左侧显示了零页的偏移量。中间列出了零页的实际值。右侧显示了内核对零页的引用。[表
    3-1](ch03s02.html#description_of_the_zero_page_data_layout "表 3-1. 零页数据布局描述")
    描述了 [图 3-6](ch03s02.html#data_layout_of_the_zero_page "图 3-6. 零页数据布局") 中展示的零页数据布局。'
- en: Table 3-1. Description of the Zero Page Data Layout
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1. 零页数据布局描述
- en: '| Function/Line of code | Data referenced by the kernel | Description |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 函数/代码行 | 内核引用的数据 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ip_sioctl_tunparam()`9432 | `ill = ipif-> ipif_ill;` | `ipif` is `NULL`,
    and the offset of `ipif_ill` within the `ipif` structure is `0x8`. Therefore,
    `ipif->ipif_ill` references address `0x8`. The value at address `0x8` is assigned
    to `ill`. So the `ill` structure starts at address `0x10` (see (1) in [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page
    "Figure 3-6. Data layout of the zero page")). |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `ip_sioctl_tunparam()`9432 | `ill = ipif-> ipif_ill;` | `ipif` 是 `NULL`，`ipif_ill`
    在 `ipif` 结构体中的偏移量是 `0x8`。因此，`ipif->ipif_ill` 引用地址 `0x8`。地址 `0x8` 中的值被分配给 `ill`。所以
    `ill` 结构体从地址 `0x10` 开始（见 [图 3-6](ch03s02.html#data_layout_of_the_zero_page "图
    3-6. 零页数据布局") 中的（1））。|'
- en: '| `ip_sioctl_tunparam()`9446 | `putnext(ill-> ill_wq, mp1);` | The value of
    `ill->ill_wq` is used as a parameter for `putnext()`. The offset of `ill_wq` inside
    the `ill` structure is `0x10`. The `ill` structure starts at address `0x10`, so
    `ill->ill_wq` is referenced at address `0x20`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `ip_sioctl_tunparam()`9446 | `putnext(ill-> ill_wq, mp1);` | `ill->ill_wq`
    的值用作 `putnext()` 的参数。`ill_wq` 在 `ill` 结构体中的偏移量是 `0x10`。`ill` 结构体从地址 `0x10` 开始，因此
    `ill->ill_wq` 在地址 `0x20` 处被引用。|'
- en: '| `putnext()`147 | `putnext(queue_t *qp, mblk_t *mp)` | The address of `qp`
    equals the value pointed to by `ill->ill_wq`. Therefore, `qp` starts at address
    `0x28` (see (2) in [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page "Figure 3-6. Data
    layout of the zero page")). |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `putnext()`147 | `putnext(queue_t *qp, mblk_t *mp)` | `qp` 的地址等于 `ill->ill_wq`
    指向的值。因此，`qp` 从地址 `0x28` 开始（见 [图 3-6](ch03s02.html#data_layout_of_the_zero_page
    "图 3-6. 零页数据布局") 中的（2））。|'
- en: '| `putnext()`176 | `qp = qp->q_next;` | The offset of `q_next` inside the `qp`
    structure is `0x18`. Therefore, the next `qp` gets assigned the value from address
    `0x40:` the start address of `qp` (`0x28`) + offset of `q_next` (`0x18`). The
    value at address `0x40` is again `0x28`, so the next `qp` structure starts at
    the same address as the one before (see (3) in [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page
    "Figure 3-6. Data layout of the zero page")). |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `putnext()`176 | `qp = qp->q_next;` | `q_next` 在 `qp` 结构体中的偏移量是 `0x18`。因此，下一个
    `qp` 被分配从地址 `0x40:` 开始的值，即 `qp` 的起始地址（`0x28`）加上 `q_next` 的偏移量（`0x18`）。地址 `0x40`
    中的值再次是 `0x28`，所以下一个 `qp` 结构体从与之前相同的地址开始（见 [图 3-6](ch03s02.html#data_layout_of_the_zero_page
    "图 3-6. 零页数据布局") 中的（3））。|'
- en: '| `putnext()`177 | `sq = qp->q_syncq;` | The offset of `q_syncq` inside the
    `qp` structure is `0x78`. Since `q_syncq` is referenced later, it has to point
    to a valid memory address. I chose `0x7d0`, which is an address in the mapped
    zero page. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `putnext()`177 | `sq = qp->q_syncq;` | `q_syncq` 在 `qp` 结构中的偏移量是 `0x78`。由于
    `q_syncq` 在之后被引用，它必须指向一个有效的内存地址。我选择了 `0x7d0`，这是一个映射零页中的地址。|'
- en: '| `putnext()`180 | `qi = qp->q_qinfo;` | The value of `qp->q_qinfo` is assigned
    to `qi`. The offset of `q_qinfo` inside the `qp` structure is `0x0`. Since the
    `qp` structure starts at address `0x28`, the value `0x0` is assigned to `qi` (see
    (4) in [Figure 3-6](ch03s02.html#data_layout_of_the_zero_page "Figure 3-6. Data
    layout of the zero page")). |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `putnext()`180 | `qi = qp->q_qinfo;` | `qp->q_qinfo` 的值被分配给 `qi`。`q_qinfo`
    在 `qp` 结构中的偏移量是 `0x0`。由于 `qp` 结构从地址 `0x28` 开始，值 `0x0` 被分配给 `qi`（参见[图3-6](ch03s02.html#data_layout_of_the_zero_page
    "图3-6. 零页的数据布局")中的(4)）。|'
- en: '| `putnext()`273 | `putproc = qi-> qi_putp;` | The value of `qi->qi_putp` is
    assigned to the function pointer `putproc`. The offset of `qi_putp` inside the
    `qi` structure is `0x0`. Therefore, `qi->qi_putp` is referenced at address `0x0`,
    `and` the value at this address (`0x0000000041414141`) is assigned to the function
    pointer. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `putnext()`273 | `putproc = qi-> qi_putp;` | `qi->qi_putp` 的值被分配给函数指针 `putproc`。`qi_putp`
    在 `qi` 结构中的偏移量是 `0x0`。因此，`qi->qi_putp` 在地址 `0x0` 处被引用，并且该地址的值（`0x0000000041414141`）被分配给函数指针。|'
- en: 'I then compiled and tested the POC code as an unprivileged user inside a restricted,
    non-global Solaris Zone:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我随后以无特权的用户身份在受限的非全局Solaris Zone中编译并测试了POC代码：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The system crashed immediately and rebooted. After the reboot, I inspected
    the kernel crash files (see Section B.1 for a description of the following debugger
    commands):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 系统立即崩溃并重新启动。重启后，我检查了内核崩溃文件（有关以下调试器命令的描述，请参阅B.1节）：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This time, the system crashed as the kernel tried to execute code at address
    `0x41414141` (the value of the `RIP` register, as shown in bold in the debugger
    output above). That means I had managed to gain full control over `EIP`/`RIP`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，系统崩溃了，因为内核试图在地址 `0x41414141`（`RIP` 寄存器的值，如上图中调试器输出所示，加粗显示）处执行代码。这意味着我已经成功获得了对
    `EIP`/`RIP` 的完全控制。
- en: With the right exploit payload, this bug can be used to escape from a restricted,
    non-global Solaris Zone and then gain superuser privileges in the global zone.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的利用有效载荷，这个漏洞可以被用来从受限的非全局Solaris Zone中逃逸，然后在全局区域中获得超级用户权限。
- en: Because of the strict laws in my home country, I am not allowed to provide you
    with a full working exploit. However, if you are interested, you can go to the
    book’s website to watch a video I recorded that shows the exploit in action.^([[34](ch03s05.html#ftn.CHP-3-FN-12)])
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我家乡的严格法律，我无法向您提供完整的有效利用程序。但是，如果您感兴趣，您可以去本书的网站观看我录制的一段视频，展示了该利用程序的实际操作.^([[34](ch03s05.html#ftn.CHP-3-FN-12)])
- en: 3.3 Vulnerability Remediation
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 漏洞修复
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Thursday, June 12, 2008*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*星期四，2008年6月12日*'
- en: After I informed Sun about the bug, it developed the following patch to address
    the vulnerability:^([[35](ch03s05.html#ftn.CHP-3-FN-13)])
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向Sun报告了该错误之后，它开发了以下补丁来解决这个问题：^([[35](ch03s05.html#ftn.CHP-3-FN-13)])
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To fix the bug, Sun introduced the new error definition in lines 19180 and 19181
    of `ipif_lookup_on_name()`. That successfully prevents the NULL pointer dereference
    from happening. Although this measure rectifies the vulnerability described in
    this chapter, it doesn’t solve the basic problem. The `ipif_lookup_on_name()`
    function, as well as other kernel functions, still report error conditions to
    their caller functions in two different ways, so chances are good that a similar
    bug will occur again if the API isn’t used with great care. Sun should have changed
    the API to prevent future bugs, but it didn’t.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个漏洞，Sun在 `ipif_lookup_on_name()` 的第19180行和第19181行引入了新的错误定义。这成功地防止了空指针解引用的发生。尽管这项措施纠正了本章中描述的漏洞，但它并没有解决基本问题。`ipif_lookup_on_name()`
    函数以及其他内核函数仍然以两种不同的方式向它们的调用函数报告错误条件，因此如果API没有被小心使用，很可能再次出现类似的漏洞。Sun本应该更改API以防止未来的漏洞，但它没有这样做。
- en: 3.4 Lessons Learned
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 经验教训
- en: 'As a programmer:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名程序员：
- en: Always define proper error conditions.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是定义适当的错误条件。
- en: Always validate return values correctly.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是正确验证返回值。
- en: Not all kernel NULL pointer dereferences are simple denial-of-service conditions.
    Some of them are really bad vulnerabilities that can lead to arbitrary code execution.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有内核空指针解引用都是简单的拒绝服务条件。其中一些确实是严重的漏洞，可能导致任意代码执行。
- en: 'As a system administrator:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员：
- en: Don’t blindly trust zones, compartments, fine-grained access controls, or virtualization.
    If there is a bug in the kernel, there’s a good chance that every security feature
    can be bypassed or evaded. And that’s true not only for Solaris Zones.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要盲目相信区域、组件、细粒度访问控制或虚拟化。如果内核中存在漏洞，那么几乎每个安全特性都有可能被绕过或规避。这不仅仅适用于 Solaris Zones。
- en: 3.5 Addendum
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 补遗
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*Wednesday, December 17, 2008*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*周三，2008年12月17日*'
- en: Since the vulnerability was fixed and a patch for Solaris is available, I released
    a detailed security advisory on my website today.^([[36](ch03s05.html#ftn.CHP-3-FN-14)])
    The bug was assigned CVE-2008-568\. Sun took **471 days** to provide a fixed version
    of its operating system (see [Figure 3-7](ch03s05.html#timeline_from_notification_of_the_bug_to
    "Figure 3-7. Timeline from notification of the bug to the release of the fixed
    operating system")). That’s an unbelievably long time!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于漏洞已修复且提供了 Solaris 的补丁，我今天在我的网站上发布了一份详细的安全警告。[^([[36](ch03s05.html#ftn.CHP-3-FN-14)])]
    该漏洞被分配了 CVE-2008-568。Sun 公司用了 **471 天** 才提供了其操作系统的修复版本（见 [图 3-7](ch03s05.html#timeline_from_notification_of_the_bug_to
    "图 3-7. 从通知到发布修复操作系统的时序图")）。这简直是一个难以置信的漫长时间！
- en: '![Timeline from notification of the bug to the release of the fixed operating
    system](httpatomoreillycomsourcenostarchimages939261.png.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![从通知到发布修复操作系统的时序图](httpatomoreillycomsourcenostarchimages939261.png.jpg)'
- en: Figure 3-7. Timeline from notification of the bug to the release of the fixed
    operating system
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7. 从通知到发布修复操作系统的时序图
- en: Notes
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备注
- en: ^([[23](#ftn.CHP-3-FN-1)])
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-3-FN-1)])
- en: ^([[24](#ftn.CHP-3-FN-2)])
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#ftn.CHP-3-FN-2)])
- en: ^([[25](#ftn.CHP-3-FN-3)])
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-3-FN-3)])
- en: ^([[26](#ftn.CHP-3-FN-4)])
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#ftn.CHP-3-FN-4)])
- en: ^([[27](#ftn.CHP-3-FN-5)])
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#ftn.CHP-3-FN-5)])
- en: ^([[28](#ftn.CHP-3-FN-6)])
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-3-FN-6)])
- en: ^([[29](#ftn.CHP-3-FN-7)])
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#ftn.CHP-3-FN-7)])
- en: ^([[30](#ftn.CHP-3-FN-8)])
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#ftn.CHP-3-FN-8)])
- en: ^([[31](#ftn.CHP-3-FN-9)])
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#ftn.CHP-3-FN-9)])
- en: ^([[32](#ftn.CHP-3-FN-10)])
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#ftn.CHP-3-FN-10)])
- en: ^([[33](#ftn.CHP-3-FN-11)])
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[33](#ftn.CHP-3-FN-11)])
- en: ^([[34](#ftn.CHP-3-FN-12)])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#ftn.CHP-3-FN-12)])
- en: ^([[35](#ftn.CHP-3-FN-13)])
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#ftn.CHP-3-FN-13)])
- en: ^([[36](#ftn.CHP-3-FN-14)])
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#ftn.CHP-3-FN-14)])
- en: '* * *'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[23](#CHP-3-FN-1)]) The source code of OpenSolaris can be downloaded at [http://dlc.sun.com/osol/on/downloads/](http://dlc.sun.com/osol/on/downloads/).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-3-FN-1)]) OpenSolaris 的源代码可在 [http://dlc.sun.com/osol/on/downloads/](http://dlc.sun.com/osol/on/downloads/)
    下载。
- en: ^([[24](#CHP-3-FN-2)]) See [http://en.wikipedia.org/wiki/Ioctl](http://en.wikipedia.org/wiki/Ioctl).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-3-FN-2)]) 请参阅 [http://en.wikipedia.org/wiki/Ioctl](http://en.wikipedia.org/wiki/Ioctl)。
- en: ^([[25](#CHP-3-FN-3)]) For more information on the IP-in-IP tunneling mechanism,
    refer to [http://download.oracle.com/docs/cd/E19455-01/806-0636/6j9vq2bum/index.html](http://download.oracle.com/docs/cd/E19455-01/806-0636/6j9vq2bum/index.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-3-FN-3)]) 关于 IP-in-IP 隧道机制的更多信息，请参阅 [http://download.oracle.com/docs/cd/E19455-01/806-0636/6j9vq2bum/index.html](http://download.oracle.com/docs/cd/E19455-01/806-0636/6j9vq2bum/index.html)。
- en: ^([[26](#CHP-3-FN-4)]) See the *STREAMS Programming Guide* from Sun Microsystems
    Inc., which can be downloaded at [http://download.oracle.com/docs/cd/E19504-01/802-5893/802-5893.pdf](http://download.oracle.com/docs/cd/E19504-01/802-5893/802-5893.pdf).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-3-FN-4)]) 请参阅 Sun Microsystems Inc. 的 *STREAMS 编程指南*，可在 [http://download.oracle.com/docs/cd/E19504-01/802-5893/802-5893.pdf](http://download.oracle.com/docs/cd/E19504-01/802-5893/802-5893.pdf)
    下载。
- en: '^([[27](#CHP-3-FN-5)]) OpenGrok source browser reference of OpenSolaris: [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/stream.h?r=4823%3A7c9aaea16585](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/stream.h?r=4823%3A7c9aaea16585).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-3-FN-5)]) OpenGrok 源代码浏览器参考 of OpenSolaris：[http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/stream.h?r=4823%3A7c9aaea16585](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/sys/stream.h?r=4823%3A7c9aaea16585).
- en: '^([[28](#CHP-3-FN-6)]) OpenGrok source browser reference of OpenSolaris: [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip.c?r=4823%3A7c9aaea16585](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip.c?r=4823%3A7c9aaea16585).'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[28](#CHP-3-FN-6)]) OpenSolaris 的 OpenGrok 源代码浏览器参考：[http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip.c?r=4823%3A7c9aaea16585](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip.c?r=4823%3A7c9aaea16585).
- en: '^([[29](#CHP-3-FN-7)]) OpenGrok source browser reference of OpenSolaris: [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r=5240%3Ae7599510dd03](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r=5240%3Ae7599510dd03).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[29](#CHP-3-FN-7)]) OpenSolaris 的 OpenGrok 源代码浏览器参考：[http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r=5240%3Ae7599510dd03](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r=5240%3Ae7599510dd03)。
- en: ^([[30](#CHP-3-FN-8)]) The official *Solaris Modular Debugger Guide* can be
    found at [http://dlc.sun.com/osol/docs/content/MODDEBUG/moddebug.html](http://dlc.sun.com/osol/docs/content/MODDEBUG/moddebug.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[30](#CHP-3-FN-8)]) 官方的 *Solaris 模块化调试指南* 可以在 [http://dlc.sun.com/osol/docs/content/MODDEBUG/moddebug.html](http://dlc.sun.com/osol/docs/content/MODDEBUG/moddebug.html)
    找到。
- en: '^([[31](#CHP-3-FN-9)]) For more information, refer to the paper “Attacking
    the Core: Kernel Exploiting Notes” by twiz & sgrakkyu, which can be found at [http://www.phrack.com/issues.html?issue=64&id=6](http://www.phrack.com/issues.html?issue=64&id=6).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[31](#CHP-3-FN-9)]) 更多信息，请参阅 twiz & sgrakkyu 撰写的论文“攻击核心：内核利用笔记”，可在 [http://www.phrack.com/issues.html?issue=64&id=6](http://www.phrack.com/issues.html?issue=64&id=6)
    找到。
- en: ^([[32](#CHP-3-FN-10)]) More information on the virtual address space of Solaris
    processes can be found at [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/i86pc/os/startup.c?r=10942:eaa343de0d06](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/i86pc/os/startup.c?r=10942:eaa343de0d06).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[32](#CHP-3-FN-10)]) 关于 Solaris 进程虚拟地址空间的信息可以在 [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/i86pc/os/startup.c?r=10942:eaa343de0d06](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/i86pc/os/startup.c?r=10942:eaa343de0d06)
    找到。
- en: '^([[33](#CHP-3-FN-11)]) OpenGrok source browser reference of OpenSolaris: [http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/os/putnext.c?r=0%3A68f95e015346](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/os/putnext.c?r=0%3A68f95e015346).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[33](#CHP-3-FN-11)]) OpenSolaris 的 OpenGrok 源代码浏览器参考：[http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/os/putnext.c?r=0%3A68f95e015346](http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/os/putnext.c?r=0%3A68f95e015346)。
- en: ^([[34](#CHP-3-FN-12)]) See [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[34](#CHP-3-FN-12)]) 请参阅 [http://www.trapkit.de/books/bhd/](http://www.trapkit.de/books/bhd/)。
- en: ^([[35](#CHP-3-FN-13)]) The patch from Sun can be found at [http://cvs.opensolaris.org/source/diff/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r1=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5240&r2=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5335&format=s&full=0](http://cvs.opensolaris.org/source/diff/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r1=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5240&r2=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5335&format=s&full=0).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[35](#CHP-3-FN-13)]) Sun 提供的补丁可以在 [http://cvs.opensolaris.org/source/diff/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r1=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5240&r2=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5335&format=s&full=0](http://cvs.opensolaris.org/source/diff/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c?r1=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5240&r2=/onnv/onnv-gate/usr/src/uts/common/inet/ip/ip_if.c@5335&format=s&full=0)
    找到。
- en: ^([[36](#CHP-3-FN-14)]) My security advisory that describes the details of the
    Solaris kernel vulnerability can be found at [http://www.trapkit.de/advisories/TKADV2008-015.txt](http://www.trapkit.de/advisories/TKADV2008-015.txt).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[36](#CHP-3-FN-14)]) 描述 Solaris 内核漏洞详细信息的我的安全公告可以在 [http://www.trapkit.de/advisories/TKADV2008-015.txt](http://www.trapkit.de/advisories/TKADV2008-015.txt)
    找到。
