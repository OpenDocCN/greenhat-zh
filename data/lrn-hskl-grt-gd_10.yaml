- en: Chapter 10. Functionally Solving Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。函数式解决问题
- en: In this chapter, we’ll look at a couple of interesting problems, and we’ll think
    about how to solve them as elegantly as possible using functional programming
    techniques. This will give you the opportunity to flex your newly acquired Haskell
    muscles and practice your coding skills.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个有趣的问题，并思考如何尽可能优雅地使用函数式编程技术来解决它们。这将给你一个机会来锻炼你新学会的 Haskell 技能，并练习你的编码技巧。
- en: Reverse Polish Notation Calculator
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆波兰表示法计算器
- en: Usually, when we work with algebraic expressions in school, we write them in
    an infix manner. For instance, we write `10 - (4 + 3) * 2`. Addition (`+`), multiplication
    (`*`), and subtraction (`-`) are infix operators, just like the infix functions
    in Haskell (`` + `elem` ``, and so on). As humans, we can parse this form easily
    in our minds. The downside is that we need to use parentheses to denote precedence.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在学校处理代数表达式时，会以中缀方式书写。例如，我们写成 `10 - (4 + 3) * 2`。加法（`+`）、乘法（`*`）和减法（`-`）都是中缀运算符，就像
    Haskell 中的中缀函数（`+`, `elem` 等）。作为人类，我们可以在脑海中轻松解析这种形式。缺点是我们需要使用括号来表示优先级。
- en: 'Another way to write algebraic expressions is to use *reverse polish notation*,
    or *RPN*. In RPN, the operator comes after the numbers, rather than being sandwiched
    between them. So, instead of writing `4 + 3`, we write `4 3 +`. But how do we
    write expressions that contain several operators? For example, how would we write
    an expression that adds `4` and `3` and then multiplies that by `10`? It’s simple:
    `4 3 + 10 *`. Because `4 3 +` is equivalent to `7`, that whole expression is the
    same as `7 10 *`.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种书写代数表达式的方法是使用逆波兰表示法，或称 RPN。在 RPN 中，运算符位于数字之后，而不是夹在它们之间。所以，我们不是写 `4 + 3`，而是写
    `4 3 +`。但是，我们如何写包含多个运算符的表达式呢？例如，我们如何写一个将 `4` 和 `3` 相加然后乘以 `10` 的表达式？很简单：`4 3 +
    10 *`。因为 `4 3 +` 等于 `7`，所以整个表达式等同于 `7 10 *`。
- en: Calculating RPN Expressions
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算逆波兰表达式
- en: To get a feel for how to calculate RPN expressions, think of a stack of numbers.
    We go over the expression from left to right. Every time a number is encountered,
    put it on top of the stack (*push* it onto the stack). When we encounter an operator,
    we take the two numbers that are on top of the stack (*pop* them), use the operator
    with those two, and then push the resulting number back onto the stack. When we
    reach the end of the expression, we should be left with a single number that represents
    the result (assuming the expression was well formed).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何计算逆波兰表达式，想象一个数字栈。我们从左到右遍历表达式。每次遇到一个数字，就将其放在栈顶（将其压入栈中）。当我们遇到一个运算符时，我们从栈顶弹出两个数字（现在栈中只剩
    `10`），使用这两个数字和运算符，然后将结果数压回栈中。当我们到达表达式的末尾时，我们应该剩下代表结果的单个数字（假设表达式是正确形成的）。
- en: 'Let’s see how we would calculate the RPN expression `10 4 3 + 2 * -`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何计算逆波兰表达式 `10 4 3 + 2 * -`：
- en: We push `10` onto the stack, so the stack consists of `10`.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `10` 压入栈中，因此栈现在包含 `10`。
- en: The next item is `4`, so we push it onto the stack as well. The stack is now
    `10, 4`.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个项目是 `4`，所以我们也将它压入栈中。栈现在是 `10, 4`。
- en: We do the same with `3`, and the stack is now `10, 4, 3`.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用同样的方法处理 `3`，栈现在是 `10, 4, 3`。
- en: 'We encounter an operator: `+`. We pop the two top numbers from the stack (so
    now the stack is just `10`), add those numbers together, and push that result
    to the stack. The stack is now `10, 7`.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遇到了一个运算符：`+`。我们从栈顶弹出两个数字（现在栈中只剩 `10`），将这两个数字相加，然后将结果压回栈中。栈现在是 `10, 7`。
- en: We push `2` to the stack, and the stack becomes `10, 7, 2`.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `2` 压入栈中，栈现在变为 `10, 7, 2`。
- en: We encounter another operator. We pop `7` and `2` off the stack, multiply them,
    and push that result to the stack. Multiplying `7` and `2` produces `14`, so the
    stack is now `10, 14`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遇到了另一个运算符。我们从栈中弹出 `7` 和 `2`，将它们相乘，然后将结果压回栈中。`7` 和 `2` 相乘得到 `14`，因此栈现在是 `10,
    14`。
- en: Finally, there’s a `-`. We pop `10` and `14` from the stack, subtract `14` from
    `10`, and push that back.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们遇到了一个 `-`。我们从栈中弹出 `10` 和 `14`，从 `10` 中减去 `14`，然后将结果压回栈中。
- en: The number on the stack is now `-4`. Because there are no more numbers or operators
    in our expression, that’s our result!
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈中的数字现在是 `-4`。因为我们的表达式中没有更多的数字或运算符，这就是我们的结果！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802634.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802634.png.jpg)'
- en: So, that’s how to calculate an RPN expression by hand. Now let’s think about
    how to make a Haskell function to do the same thing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是手动计算逆波兰表达式的方法。现在让我们考虑如何编写一个 Haskell 函数来完成同样的工作。
- en: Writing an RPN Function
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写逆波兰表达式（RPN）函数
- en: Our function will take a string that contains an RPN expression as its parameter
    (like `"10 4 3 + 2 * -"`) and give us back that expression’s result.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数将接受一个包含逆波兰表达式（RPN）的字符串作为参数（例如 `"10 4 3 + 2 * -"`），并返回该表达式的结果。
- en: 'What would the type of that function be? We want it to take a string as a parameter
    and produce a number as its result. Let’s say that we want the result to be a
    floating-point number of double precision, because we want to include division
    as well. So its type will probably be something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那这个函数的类型会是什么样子呢？我们希望它接受一个字符串作为参数，并返回一个数字作为结果。比如说，我们希望结果是双精度浮点数，因为我们还想包含除法操作。所以它的类型可能类似于以下这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It really helps to first think what the type declaration of a function should
    be before dealing with the implementation. In Haskell, a function’s type declaration
    tells you a whole lot about the function, due to the very strong type system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理实现之前先思考函数的类型声明非常有帮助。在 Haskell 中，函数的类型声明由于非常强的类型系统，可以告诉你很多关于函数的信息。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802636.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802636.png.jpg)'
- en: 'When implementing a solution to a problem in Haskell, it can be helpful to
    consider how you did it by hand. For our RPN expression calculation, we treated
    every number or operator that was separated by a space as a single item. So it
    might help us if we start by breaking a string like `"10 4 3 + 2 * -"` into a
    list of items, like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Haskell 中实现一个问题的解决方案时，考虑你是如何手动解决这个问题的可能会有所帮助。对于我们的逆波兰表达式计算，我们将每个由空格分隔的数字或运算符视为一个单独的项目。因此，如果我们首先将字符串
    `"10 4 3 + 2 * -"` 分解成如下的项目列表，可能会有所帮助：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next up, what did we do with that list of items in our head? We went over it
    from left to right and kept a stack as we did that. Does that process remind you
    of anything? In [I Fold You So](ch05s05.html "I Fold You So") in [I Fold You So](ch05s05.html
    "I Fold You So"), you saw that pretty much any function where you traverse a list
    element by element, and build up (*accumulate*) some result—whether it’s a number,
    a list, a stack, or something else—can be implemented with a fold.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们是如何处理我们头上的这个项目列表的？我们是从左到右遍历它的，并在这样做的同时保持一个栈。这个过程让你想起了什么吗？在 [I Fold You
    So](ch05s05.html "I Fold You So") 中，你看到了几乎任何通过逐个遍历列表元素并构建（累加）一些结果——无论是数字、列表、栈还是其他东西——的函数都可以通过折叠来实现。
- en: In this case, we’re going to use a left fold, because we go over the list from
    left to right. The accumulator value will be our stack, so the result from the
    fold will also be a stack (though as we’ve seen, it will contain only one item).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用左折叠，因为我们是从左到右遍历列表的。累加值将是我们的栈，所以折叠的结果也将是一个栈（尽管如我们所见，它将只包含一个项目）。
- en: One more thing to think about is how we will represent the stack. Let’s use
    a list and keep the top of our stack at the head of the list. Adding to the head
    (beginning) of a list is much faster than adding to the end of it. So if we have
    a stack of, say, `10, 4, 3`, we’ll represent that as the list `[3,4,10]`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事需要考虑，那就是我们如何表示这个栈。让我们使用一个列表，并将栈顶放在列表的头部。在列表头部（开始处）添加元素比在末尾添加要快得多。所以如果我们有一个包含
    `10, 4, 3` 的栈，我们将它表示为列表 `[3,4,10]`。
- en: Now we have enough information to roughly sketch our function. It’s going to
    take a string like `"10 4 3 + 2 * -"` and break it down into a list of items by
    using `words`. Next, we’ll do a left fold over that list and end up with a stack
    that has a single item (in this example, `[-4]`). We take that single item out
    of the list, and that’s our final result!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了足够的信息来大致勾勒出我们的函数。它将接受一个类似于 `"10 4 3 + 2 * -"` 的字符串，并使用 `words` 函数将其分解成一系列项目。接下来，我们将对这个列表进行左折叠操作，最终得到一个只有一个项目的栈（在这个例子中，是
    `[-4]`）。我们将这个单一的项目从列表中取出，这就是我们的最终结果！
- en: 'Here’s a sketch of that function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数的草图：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We take the expression and turn it into a list of items. Then we fold over that
    list of items with the folding function. Notice the `[]`, which represents the
    starting accumulator. The accumulator is our stack, so `[]` represents an empty
    stack, which is what we start with. After getting the final stack with a single
    item, we apply `head` to that list to get the item out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将表达式转换成一个项目列表。然后我们使用折叠函数对这个项目列表进行折叠。注意`[]`，它代表起始累加器。累加器是我们的栈，所以`[]`代表一个空栈，这是我们开始的地方。在得到只有一个项目的最终栈后，我们应用`head`函数到这个列表上以获取项目。
- en: All that’s left now is to implement a folding function that will take a stack,
    like `[4,10]`, and an item, like `"3"`, and return a new stack `[3,4,10]`. If
    the stack is `[4,10]` and the item is `"*"`, then the function will need to return
    `[40]`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下实现一个折叠函数，它将接受一个栈，如`[4,10]`，和一个项目，如`"3"`，并返回一个新的栈`[3,4,10]`。如果栈是`[4,10]`且项目是`"*"`，那么该函数需要返回`[40]`。
- en: 'Before we write the folding function, let’s turn our function into point-free
    style, because it has a lot of parentheses that are kind of freaking me out:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写折叠函数之前，让我们将我们的函数转换为无参数风格，因为它有很多让我感到不安的括号：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s much better.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就好多了。
- en: 'The folding function will take a stack and an item and return a new stack.
    We’ll use pattern matching to get the top items of a stack and to pattern match
    against operators like `"*"` and `"-"`. Here it is with the folding function implemented:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠函数将接受一个栈和一个项目，并返回一个新的栈。我们将使用模式匹配来获取栈的顶部项目，并对操作符如`"*"`和`"-"`进行模式匹配。这里就是实现了折叠函数的样子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We laid this out as four patterns. The patterns will be tried from top to bottom.
    First, the folding function will see if the current item is `"*"`. If it is, then
    it will take a list like `[3,4,9,3]` and name its first two elements `x` and `y`,
    respectively. So in this case, `x` would be `3`, and `y` would be `4`. `ys` would
    be `[9,3]`. It will return a list that’s just like `ys`, but with `x` and `y`
    multiplied as its head. With this, we pop the two topmost numbers off the stack,
    multiply them, and push the result back onto the stack. If the item is not `"*"`,
    the pattern matching will fall through, `"+"` will be checked, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其展开为四种模式。模式将从顶部开始尝试。首先，折叠函数将检查当前项目是否是`"*"`。如果是，那么它将取一个如`[3,4,9,3]`的列表，并将其前两个元素分别命名为`x`和`y`。所以在这种情况下，`x`将是`3`，`y`将是`4`。`ys`将是`[9,3]`。它将返回一个与`ys`相同的列表，但以`x`和`y`的乘积作为头部。有了这个，我们将弹出栈中最上面的两个数字，将它们相乘，然后将结果推回栈上。如果项目不是`"*"`，模式匹配将失败，将检查`"+"`，依此类推。
- en: If the item is none of the operators, we assume it’s a string that represents
    a number. If it’s a number, we just apply `read` to that string to get a number
    from it and return the previous stack but with that number pushed to the top.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目不是操作符之一，我们假设它是一个表示数字的字符串。如果是数字，我们只需将`read`函数应用到这个字符串上，从中获取数字，并返回之前栈的状态，但将这个数字推到栈顶。
- en: For the list of items `["2","3","+"]`, our function will start folding from
    the left. The initial stack will be `[]`. It will call the folding function with
    `[]` as the stack (accumulator) and `"2"` as the item. Because that item is not
    an operator, it will be read and then added to the beginning of `[]`. So the new
    stack is now `[2]`. The folding function will be called with `[2]` as the stack
    and `"3"` as the item, producing a new stack of `[3,2]`. Then it’s called for
    the third time with `[3,2]` as the stack and `"+"` as the item. This causes these
    two numbers to be popped off the stack, added together, and pushed back. The final
    stack is `[5]`, which is the number that we return.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目列表`["2","3","+"]`，我们的函数将从左侧开始折叠。初始栈将是`[]`。它将使用`[]`作为栈（累加器）和`"2"`作为项目调用折叠函数。因为这个项目不是操作符，所以它将被读取并添加到`[]`的开头。所以新的栈现在是`[2]`。折叠函数将使用`[2]`作为栈和`"3"`作为项目再次被调用，生成新的栈`[3,2]`。然后它第三次被调用，栈是`[3,2]`，项目是`"+"`。这导致这两个数字从栈中弹出，相加，然后推回。最终的栈是`[5]`，这是我们返回的数字。
- en: 'Let’s play around with our function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一下我们的函数：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Cool, it works!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它工作了！
- en: Adding More Operators
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加更多操作符
- en: One nice thing about this solution is that it can be easily modified to support
    various other operators. They don’t even need to be binary operators. For instance,
    we can make an operator `"log"` that just pops one number off the stack and pushes
    back its logarithm. We can also make operators that operate on several numbers,
    like `"sum"`, which pops off all the numbers and pushes back their sum.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的一个优点是它可以很容易地修改以支持各种其他运算符。它们甚至不需要是二元运算符。例如，我们可以创建一个名为 `"log"` 的运算符，它只需从栈中弹出一个数字并返回其对数。我们还可以创建操作多个数字的运算符，例如
    `"sum"`，它将弹出所有数字并返回它们的总和。
- en: Let’s modify our function to accept a few more operators.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的函数以接受更多的一些运算符。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `/` is division, of course, and `**` is exponentiation. With the logarithm
    operator, we just pattern match against a single element and the rest of the stack,
    because we need only one element to perform its natural logarithm. With the sum
    operator, we return a stack that has only one element, which is the sum of the
    stack so far.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 当然是除法，`**` 是指数。对于对数运算符，我们只需对单个元素和其余栈进行模式匹配，因为我们只需要一个元素来执行其自然对数。对于求和运算符，我们返回一个只有一个元素的栈，这个元素是到目前为止栈中所有元素的总和。'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I think that making a function that can calculate arbitrary floating-point RPN
    expressions and has the option to be easily extended in 10 lines is pretty awesome.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为创建一个能够计算任意浮点逆波兰表示法（RPN）表达式并且可以在10行代码内轻松扩展的函数是非常棒的。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This RPN calculation solution is not really fault tolerant. When given input
    that doesn’t make sense, it might result in a runtime error. But don’t worry,
    you’ll learn how to make this function more robust in [Chapter 14](ch14.html "Chapter 14. For
    a Few Monads More").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逆波兰表示法（RPN）计算解决方案实际上并不具备容错性。当输入不合理的值时，可能会导致运行时错误。但别担心，你将在[第14章](ch14.html
    "第14章。更多单子")中学习如何使这个函数更加健壮。
- en: Heathrow to London
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伦敦希思罗机场到伦敦
- en: Suppose that we’re on a business trip. Our plane has just landed in England,
    and we rent a car. We have a meeting really soon, and we need to get from Heathrow
    Airport to London as fast as we can (but safely!).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在出差。我们的飞机刚刚在英国降落，我们租了一辆车。我们有一个会议马上就要开始了，我们需要尽快（但安全地！）从希思罗机场赶到伦敦。
- en: There are two main roads going from Heathrow to London, and a number of regional
    roads cross them. It takes a fixed amount of time to travel from one crossroad
    to another. It’s up to us to find the optimal path to take so that we get to our
    meeting in London on time. We start on the left side and can either cross to the
    other main road or go forward.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从希思罗机场到伦敦有两条主要道路，以及许多区域道路与之交叉。从一个交叉点到另一个交叉点的旅行时间是固定的。我们必须找到最佳路径，以确保我们按时到达伦敦的会议。我们从左侧开始，可以选择穿越到另一条主要道路或前进。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802638.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802638.png.jpg)'
- en: As you can see in the picture, the quickest path from Heathrow to London in
    this case is to start on main road B, cross over, go forward on A, cross over
    again, and then go forward twice on B. If we take this path, it takes us 75 minutes.
    Had we chosen any other path, it would take longer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图片中看到的，在这种情况下，从希思罗机场到伦敦的最快路径是从主道路 `B` 开始，穿过，然后在 `A` 上前进，再次穿过，然后在 `B` 上前进两次。如果我们选择这条路径，需要75分钟。如果我们选择其他任何路径，都会花费更长的时间。
- en: 'Our job is to make a program that takes input that represents a road system
    and prints out the quickest path across it. Here’s what the input would look like
    for this case:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是编写一个程序，它接受表示道路系统的输入并打印出穿过它的最快路径。以下是这个案例的输入示例：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To mentally parse the input file, read it in threes and mentally split the road
    system into sections. Each section is composed of road `A`, road `B`, and a crossing
    road. To have it neatly fit into threes, we say that there’s a last crossing section
    that takes 0 minutes to drive over. That’s because we don’t care where we arrive
    in London, as long as we’re in London, mate!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在心理上解析输入文件，以三为单位读取它，并将道路系统划分为几个部分。每个部分由道路 `A`、道路 `B` 和一条交叉道路组成。为了使其整齐地分成三部分，我们说有一个最后的交叉部分，需要0分钟来驾驶通过。这是因为我们不在乎到达伦敦的地点，只要我们在伦敦，伙计！
- en: 'Just as we did when considering the RPN calculator problem, we’ll solve this
    problem in three steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在考虑逆波兰计算器问题时所做的那样，我们将分三步解决这个问题：
- en: Forget Haskell for a minute and think about how to solve the problem by hand.
    In the RPN calculator section, we first figured out that when calculating an expression
    by hand, we keep a sort of stack in our minds and then go over the expression
    one item at a time..
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 先放下Haskell，想想我们如何手动解决这个问题。在逆波兰表达式计算器部分，我们首先确定在手动计算表达式时，我们在心中保持一种堆栈，然后逐个处理表达式中的每个项。
- en: Think about how we’re going to represent our data in Haskell. For our RPN calculator,
    we decided to use a list of strings to represent our expression..
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑我们如何在Haskell中表示我们的数据。对于我们的逆波兰表达式计算器，我们决定使用字符串列表来表示我们的表达式。
- en: Figure out how to operate on that data in Haskell so that we produce a solution.
    For the calculator, we used a left fold to walk over the list of strings, while
    keeping a stack to produce a solution.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出如何在Haskell中操作这些数据，以便我们产生一个解决方案。对于计算器，我们使用了左折叠来遍历字符串列表，同时保持一个堆栈以产生解决方案。
- en: Calculating the Quickest Path
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算最快路径
- en: So how do we figure out the quickest path from Heathrow to London by hand? Well,
    we can just look at the whole picture and try to guess what the quickest path
    is and hope our guess is correct. That solution works for very small inputs, but
    what if we have a road that has 10,000 sections? Yikes! We also won’t be able
    to say for certain that our solution is the optimal one; we can just say that
    we’re pretty sure. So, that’s not a good solution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何手动计算出从希思罗机场到伦敦的最快路径呢？嗯，我们只需看看整个图景，尝试猜测最快路径，并希望我们的猜测是正确的。这个解决方案对于非常小的输入是有效的，但如果我们有一个有10,000个路段的道路呢？哎呀！我们也不能肯定我们的解决方案是最优的；我们只能说我们相当肯定。所以，这不是一个好的解决方案。
- en: 'Here’s a simplified picture of our road system:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们道路系统的简化图：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802640.png.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802640.png.jpg)'
- en: Can we figure out the quickest path to the first crossroads (the first dot on
    `A`, marked `A1`) on road `A`? That’s pretty trivial. We just see if it’s faster
    to go directly forward on `A` or to go forward on `B` and then cross over. Obviously,
    it’s faster to go forward via `B` and then cross over, because that takes 40 minutes,
    whereas going directly via `A` takes 50 minutes. What about crossroads `B1`? We
    see that it’s a lot faster to just go directly via `B` (incurring a cost of 10
    minutes), because going via `A` and then crossing over would take us 80 minutes!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否计算出在道路`A`上的第一个交叉点（`A`上的第一个点，标记为`A1`）的最快路径？这相当简单。我们只需看看直接在`A`上前进是否比在`B`上前进然后横穿更快。显然，通过`B`前进然后横穿更快，因为这样只需要40分钟，而直接通过`A`需要50分钟。那么交叉点`B1`呢？我们看到直接通过`B`（成本为10分钟）要快得多，因为通过`A`然后横穿需要我们80分钟！
- en: 'Now we know the quickest path to `A1`: Go via `B` and then cross over. We’ll
    say that’s path `B, C` with a cost of 40 minutes. We also know the quickest path
    to `B1`: Go directly via `B`. So that’s a path consisting just of `B` for 10 minutes.
    Does this knowledge help us at all if we want to know the quickest path to the
    next crossroads on both main roads? Gee golly, it sure does!'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了到达`A1`的最快路径：通过`B`然后横穿。我们将这称为路径`B, C`，成本为40分钟。我们还知道到达`B1`的最快路径：直接通过`B`。所以这是一个只有`B`的路径，耗时10分钟。如果我们想知道两条主路上下一个交叉点的最快路径，这些知识对我们有帮助吗？哎呀，当然有帮助了！
- en: Let’s see what the quickest path to `A2` would be. To get to `A2`, we’ll either
    go directly to `A2` from `A1` or we’ll go forward from `B1` and then cross over
    (remember that we can only move forward or cross to the other side). And because
    we know the cost to `A1` and `B1`, we can easily figure out the best path to `A2`.
    It takes us 40 minutes to get to `A1` and then 5 minutes to get from `A1` to `A2`,
    so that’s path `B, C, A`, for a cost of 45\. It takes us only 10 minutes to get
    to `B1`, but then it would take an additional 110 minutes to go to `B2` and then
    cross over! So obviously, the quickest path to `A2` is `B, C, A`. In the same
    way, the quickest way to `B2` is to go forward from `A1` and then cross over.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到达`A2`的最快路径是什么。要到达`A2`，我们要么直接从`A1`到`A2`，要么从`B1`前进然后横穿（记住我们只能向前移动或横穿到另一边）。因为我们知道到达`A1`和`B1`的成本，我们可以轻松地找出到达`A2`的最佳路径。到达`A1`需要我们40分钟，然后从`A1`到`A2`需要5分钟，所以这是路径`B,
    C, A`，总成本为45分钟。到达`B1`只需要10分钟，但然后还需要额外110分钟才能到达`B2`并横穿！所以显然，到达`A2`的最快路径是`B, C,
    A`。同样，到达`B2`的最快方式是从`A1`前进然后横穿。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Maybe you’re asking yourself, “But what about getting to `A2` by first crossing
    over at `B1` and then going forward?” Well, we already covered crossing from `B1`
    to `A1` when we were looking for the best way to `A1`, so we don’t need to take
    that into account in the next step as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能自己在想，“但通过在`B1`处先交叉然后前进，如何到达`A2`？” 好吧，当我们寻找到`A1`的最佳路径时，我们已经涵盖了从`B1`到`A1`的交叉，所以在下一步中我们也不需要考虑这一点。
- en: Now that we have the best path to `A2` and `B2`, we can repeat this until we
    reach the end. Once we have calculated the best paths for `A4` and `B4`, the one
    that takes less time is the optimal path.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了到`A2`和`B2`的最佳路径，我们可以重复这个过程，直到到达终点。一旦我们计算了`A4`和`B4`的最佳路径，耗时较短的那个就是最优路径。
- en: So in essence, for the second section, we just repeat the step we did at first,
    but we take into account the previous best paths on `A` and `B`. We could say
    that we also took into account the best paths on `A` and on `B` in the first step—they
    were both empty paths with a cost of 0 minutes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，对于第二个部分，我们只是重复我们最初所做的步骤，但我们要考虑`A`和`B`上的先前最佳路径。我们可以说，在第一步中，我们也考虑了`A`和`B`上的最佳路径——它们都是成本为0分钟的空路径。
- en: 'In summary, to get the best path from Heathrow to London, we do this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，为了从希思罗机场到伦敦找到最佳路径，我们这样做：
- en: We see what the best path to the next crossroads on main road `A` is. The two
    options are going directly forward or starting at the opposite road, going forward
    and then crossing over. We remember the cost and the path.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查看通往主路`A`上下一个路口的最佳路径。有两种选择：直接前进或从相对的道路开始，然后前进并交叉。我们记住成本和路径。
- en: We use the same method to find the best path to the next crossroads on main
    road `B` and remember that.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用相同的方法来找到通往主路`B`上下一个路口的最佳路径，并记住它。
- en: We see if the path to the next crossroads on `A` takes less time if we go from
    the previous `A` crossroads or if we go from the previous `B` crossroads and then
    cross over. We remember the quicker path. We do the same for the crossroads opposite
    of it.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查从上一个`A`路口到下一个路口的路径是否比从上一个`B`路口过去然后交叉的时间更短。我们记住较快的路径。我们对相对的路口也做同样的处理。
- en: We do this for every section until we reach the end.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对每个部分都这样做，直到达到最后。
- en: Once we’ve reached the end, the quicker of the two paths that we have is our
    optimal path.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们到达终点，两个路径中较快的那个就是我们的最优路径。
- en: So, in essence, we keep one quickest path on the `A` road and one quickest path
    on the `B` road. When we reach the end, the quicker of those two is our path.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本质上，我们保持`A`路上的一个最快路径和一个`B`路上的最快路径。当我们到达终点时，这两个路径中较快的那个就是我们的路径。
- en: We now know how to figure out the quickest path by hand. If you had enough time,
    paper, and pencils, you could figure out the quickest path through a road system
    with any number of sections.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何手动找出最快的路径。如果你有足够的时间、纸张和铅笔，你可以找出任何数量部分的公路系统的最快路径。
- en: Representing the Road System in Haskell
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Haskell 表示道路系统
- en: How do we represent this road system with Haskell’s data types?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用 Haskell 的数据类型表示这个道路系统？
- en: 'Thinking back to our solution by hand, we checked the durations of three road
    parts at once: the road part on the `A` road, its opposite part on the `B` road,
    and part `C`, which touches those two parts and connects them. When we were looking
    for the quickest path to `A1` and `B1`, we dealt with the durations of only the
    first three parts, which were 50, 10, and 30\. We’ll call that one section. So
    the road system that we use for this example can be easily represented as four
    sections:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们手动解决问题的方法，我们同时检查了三个道路部分的时间：`A`路上的道路部分，它在`B`路上的相对部分，以及`C`部分，它接触那两个部分并将它们连接起来。当我们寻找到`A1`和`B1`的最快路径时，我们只处理了前三个部分的时间，分别是50、10和30。我们将那称为一个部分。所以，我们用于这个示例的道路系统可以很容易地表示为四个部分：
- en: '`50, 10, 30`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`50, 10, 30`'
- en: '`5, 90, 20`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5, 90, 20`'
- en: '`40, 2, 25`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`40, 2, 25`'
- en: '`10, 8, 0`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10, 8, 0`'
- en: 'It’s always good to keep our data types as simple as possible (although not
    any simpler!). Here’s the data type for our road system:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总是保持我们的数据类型尽可能简单（尽管不能更简单了！）以下是我们的道路系统的数据类型：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is as simple as it gets, and I have a feeling it will work perfectly for
    implementing our solution.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的情况，我有一种感觉，它将完美地适用于实现我们的解决方案。
- en: '`Section` is a simple algebraic data type that holds three integers for the
    durations of its three road parts. We introduce a type synonym as well, saying
    that `RoadSystem` is a list of sections.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Section` 是一个简单的代数数据类型，它包含三个整数，表示其三个道路部分的时间。我们还引入了一个类型同义词，表示`RoadSystem`是一个部分的列表。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could also use a triple of `(Int, Int, Int)` to represent a road section.
    Using tuples instead of making your own algebraic data types is good for some
    small, localized stuff, but it’s usually better to make a new type for more complex
    representations. It gives the type system more information about what’s what.
    We can use `(Int, Int, Int)` to represent a road section or a vector in 3D space,
    and we can operate on those two, but that allows us to mix them up. If we use
    `Section` and `Vector` data types, then we can’t accidentally add a vector to
    a section of a road system.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`(Int, Int, Int)`三元组来表示一个道路部分。使用元组而不是创建自己的代数数据类型对于一些小而局部的东西来说很好，但对于更复杂的表现通常更好。它给类型系统提供了更多关于是什么的信息。我们可以使用`(Int,
    Int, Int)`来表示一个道路部分或三维空间中的向量，并且我们可以对这两个进行操作，但这允许我们混淆它们。如果我们使用`Section`和`Vector`数据类型，那么我们就不可能意外地将一个向量加到道路系统的部分上。
- en: 'Our road system from Heathrow to London can now be represented like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从希思罗到伦敦的道路系统现在可以表示如下：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All we need to do now is implement the solution in Haskell.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是用Haskell实现这个解决方案。
- en: Writing the Optimal Path Function
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写最优路径函数
- en: What should the type declaration for a function that calculates the quickest
    path for any given road system be? It should take a road system as a parameter
    and return a path. We’ll represent a path as a list as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的道路系统计算最短路径的函数的类型声明应该是什么？它应该接受一个道路系统作为参数并返回一个路径。我们将路径表示为一个列表。
- en: Let’s introduce a `Label` type that’s just an enumeration of `A`, `B`, or `C`.
    We’ll also make a type synonym called `Path`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个`Label`类型，它只是`A`、`B`或`C`的枚举。我们还将创建一个名为`Path`的类型同义词。
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our function, which we’ll call `optimalPath`, should have the following type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称之为`optimalPath`的函数应该具有以下类型：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If called with the road system `heathrowToLondon`, it should return the following
    path:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用`heathrowToLondon`道路系统调用，它应该返回以下路径：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’re going to need to walk over the list with the sections from left to right
    and keep the optimal path on `A` and optimal path on `B` as we go along. We’ll
    accumulate the best path as we walk over the list, left to right. What does that
    sound like? Ding, ding, ding! That’s right, a *left fold*!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要从左到右遍历包含部分的列表，并在过程中保持`A`和`B`上的最优路径。我们将随着列表的遍历，从左到右累积最佳路径。那听起来像什么？叮，叮，叮！没错，一个*左折叠*！
- en: 'When doing the solution by hand, there was a step that we repeated over and
    over. It involved checking the optimal paths on `A` and `B` so far and the current
    section to produce the new optimal paths on `A` and `B`. For instance, at the
    beginning, the optimal paths were `[]` and `[]` for `A` and `B`, respectively.
    We examined the section `Section 50 10 30` and concluded that the new optimal
    path to `A1` was `[(B,10),(C,30)]` and the optimal path to `B1` was `[(B,10)]`.
    If you look at this step as a function, it takes a pair of paths and a section
    and produces a new pair of paths. So its type is this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动解决问题时，有一个步骤我们反复进行。这涉及到检查到目前为止的`A`和`B`上的最优路径以及当前部分，以生成`A`和`B`上的新最优路径。例如，一开始，`A`和`B`的最优路径分别是`[]`和`[]`。我们检查了`Section
    50 10 30`并得出结论，`A1`的新最优路径是`[(B,10),(C,30)]`，而`B1`的最优路径是`[(B,10)]`。如果你把这个步骤看作一个函数，它接受一对路径和一个部分，并生成一对新的路径。所以它的类型是：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s implement this function, because it’s bound to be useful:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现这个函数，因为它肯定是有用的：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What’s going on here? First, we calculate the optimal time on road A based on
    the best so far on `A`, and we do the same for `B`. We do `sum (map snd pathA)`,
    so if `pathA` is something like `[(A,100),(C,20)]`, `timeA` becomes `120`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？首先，我们根据`A`上的最佳时间计算道路`A`上的最优时间，并为`B`做同样的操作。我们做`sum (map snd pathA)`，所以如果`pathA`类似于`[(A,100),(C,20)]`，则`timeA`变为`120`。
- en: '`forwardTimeToA` is the time that it would take to get to the next crossroads
    on `A` if we went there directly from the previous crossroads on `A`. It equals
    the best time to our previous `A` plus the duration of the `A` part of the current
    section.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`forwardTimeToA`是如果我们直接从`A`上的前一个交叉路口前往下一个交叉路口，到达`A`上的下一个交叉路口所需的时间。它等于我们之前`A`上的最佳时间加上当前部分的`A`部分持续时间。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802642.png.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802642.png.jpg)'
- en: '`crossTimeToA` is the time that it would take if we went to the next `A` by
    going forward from the previous `B` and then crossing over. It’s the best time
    to the previous `B` so far plus the `B` duration of the section plus the `C` duration
    of the section.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossTimeToA` 是如果我们从上一个 `B` 向前走到下一个 `A` 然后交叉过去所需的时间。这是到目前为止到达上一个 `B` 的最佳时间加上该部分
    `B` 的时间加上该部分 `C` 的时间。'
- en: We determine `forwardTimeToB` and `crossTimeToB` in the same manner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以同样的方式确定 `forwardTimeToB` 和 `crossTimeToB`。
- en: Now that we know the best way to `A` and `B`, we just need to make the new paths
    to `A` and `B` based on that. If it’s quicker to go to `A` by just going forward,
    we set `newPathToA` to be `(A, a):pathA`. Basically, we prepend the `Label A`
    and the section duration `a` to the optimal path on `A` so far. We say that the
    best path to the next `A` crossroads is the path to the previous `A` crossroads
    and then one section forward via `A`. Remember that `A` is just a label, whereas
    `a` has a type of `Int`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了到达 `A` 和 `B` 的最佳方式，我们只需要根据这个新路径到 `A` 和 `B`。如果我们只是向前走就能更快地到达 `A`，我们将 `newPathToA`
    设置为 `(A, a):pathA`。基本上，我们将 `Label A` 和该部分的持续时间 `a` 预先添加到迄今为止的 `A` 上最优路径中。我们说到达下一个
    `A` 交叉路口的最佳路径是到达前一个 `A` 交叉路口然后通过 `A` 向前走一步。记住，`A` 只是一个标签，而 `a` 有 `Int` 类型。
- en: Why do we prepend instead of doing `pathA ++ [(A, a)]`? Well, adding an element
    to the beginning of a list is much faster than adding it to the end. This means
    that the path will be the wrong way around once we fold over a list with this
    function, but it’s easy to reverse the list later.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们选择在列表开头添加元素而不是执行 `pathA ++ [(A, a)]`？嗯，将元素添加到列表的开头比添加到末尾要快得多。这意味着一旦我们使用这个函数折叠列表，路径就会是错误的顺序，但稍后很容易反转列表。
- en: If it’s quicker to get to the next `A` crossroads by going forward from road
    `B` and then crossing over, `newPathToA` is the old path to `B` that then goes
    forward and crosses to `A`. We do the same thing for `newPathToB`, except that
    everything is mirrored.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过从道路 `B` 向前走到下一个 `A` 交叉路口并交叉过去更快，则 `newPathToA` 是到 `B` 的旧路径，然后向前走并交叉到 `A`。对于
    `newPathToB`，我们做同样的事情，只是一切都进行了镜像。
- en: Finally, we return `newPathToA` and `newPathToB` in a pair.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以一对的形式返回 `newPathToA` 和 `newPathToB`。
- en: Let’s run this function on the first section of `heathrowToLondon`. Because
    it’s the first section, the best paths on `A` and `B` parameter will be a pair
    of empty lists.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `heathrowToLondon` 的第一个部分上运行这个函数。因为这是第一个部分，`A` 和 `B` 参数上最好的路径将是一对空列表。
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Remember that the paths are reversed, so read them from right to left. From
    this, we can read that the best path to the next `A` is to start on `B` and then
    cross over to `A`. The best path to the next `B` is to just go directly forward
    from the starting point at `B`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住路径是反转的，所以从右到左读取它们。从这一点，我们可以看出到达下一个 `A` 的最佳路径是从 `B` 开始然后交叉到 `A`。到达下一个 `B` 的最佳路径是直接从
    `B` 的起点向前走。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we do `timeA = sum (map snd pathA)`, we’re calculating the time from the
    path on every step. We wouldn’t need to do that if we implemented `roadStep` to
    take and return the best times on `A` and `B`, along with the paths themselves.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `timeA = sum (map snd pathA)` 时，我们正在计算每一步路径上的时间。如果我们实现 `roadStep` 以接受并返回
    `A` 和 `B` 上的最佳时间以及路径本身，我们就不需要这样做。
- en: 'Now that we have a function that takes a pair of paths and a section, and produces
    a new optimal path, we can easily do a left fold over a list of sections. `roadStep`
    is called with `([], [])` and the first section, and returns a pair of optimal
    paths to that section. Then it’s called with that pair of paths and the next section,
    and so on. When we’ve walked over all the sections, we’re left with a pair of
    optimal paths, and the shorter of them is our answer. With this in mind, we can
    implement `optimalPath`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数，它接受一对路径和一个部分，并生成一条新的最优路径，我们可以轻松地对一系列部分进行左折叠。`roadStep` 使用 `([], [])`
    和第一个部分调用，并返回到该部分的两个最优路径。然后它使用这对路径和下一个部分调用，依此类推。当我们走过所有部分后，我们剩下的是一对最优路径，其中较短的那个是我们的答案。考虑到这一点，我们可以实现
    `optimalPath`：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We left fold over `roadSystem` (remember that it’s a list of sections) with
    the starting accumulator being a pair of empty paths. The result of that fold
    is a pair of paths, so we pattern match on the pair to get the paths themselves.
    Then we check which one of these was quicker and return it. Before returning it,
    we also reverse it, because the optimal paths so far were reversed due to us choosing
    prepending over appending.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `roadSystem`（记住它是一个部分的列表）进行左折叠，初始累加器是一个空路径对的组合。这个折叠的结果是一对路径，所以我们在这个对上模式匹配以获取路径本身。然后我们检查哪一个更快，并返回它。在返回之前，我们还反转了它，因为到目前为止的最优路径由于我们选择在前面添加而不是在后面添加而被反转了。
- en: Let’s test this!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下！
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the result that we were supposed to get! It differs from our expected
    result a bit, because there’s a step `(C,0)` at the end, which means that we cross
    over to the other road once we’re in London. But because that crossing doesn’t
    take any time, this is still the correct result.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该得到的结果！它与我们的预期结果略有不同，因为有一个 `(C,0)` 步骤在末尾，这意味着一旦我们到达伦敦，我们就跨越到另一条道路上。但由于这次穿越不占用任何时间，这仍然是正确的结果。
- en: Getting a Road System from the Input
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从输入中获取道路系统
- en: We have the function that finds an optimal path, so now we just need to read
    a textual representation of a road system from the standard input, convert it
    into a type of `RoadSystem`, run that through our `optimalPath` function, and
    print the resulting path.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了找到最优路径的函数，所以现在我们只需要从标准输入读取道路系统的文本表示，将其转换为 `RoadSystem` 类型，通过我们的 `optimalPath`
    函数运行它，并打印出结果路径。
- en: 'First, let’s make a function that takes a list and splits it into groups of
    the same size. We’ll call it `groupsOf`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个函数，它接受一个列表并将其分成相同大小的组。我们将它命名为 `groupsOf`：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For a parameter of `[1..10]`, `groupsOf 3` should result in the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `[1..10]` 的参数，`groupsOf 3` 应该产生以下结果：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, it’s a standard recursive function. Doing `groupsOf 3 [1..10]`
    equals the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个标准的递归函数。执行 `groupsOf 3 [1..10]` 等于以下内容：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the recursion is done, we get our list in groups of three. And here’s
    our main function, which reads from the standard input, makes a `RoadSystem` out
    of it, and prints out the shortest path:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当递归完成后，我们得到我们的列表，以三个为一组。这是我们的主函数，它从标准输入读取，将其制作成 `RoadSystem`，并打印出最短路径：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we get all the contents from the standard input. Then we apply `lines`
    to our contents to convert something like `"50\n10\n30\n ...` to something cleaner,
    like `["50","10","30" ...`. We then map `read` over that to convert it to a list
    of numbers. We apply `groupsOf 3` to it so that we turn it to a list of lists
    of length 3\. We map the lambda `(\[a,b,c] -> Section a b c)` over that list of
    lists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从标准输入获取所有内容。然后，我们将 `lines` 应用到我们的内容上，将类似 `"50\n10\n30\n ...` 的内容转换为更干净的内容，如
    `["50","10","30" ...`。然后，我们映射 `read` 到它上面，将其转换为数字列表。我们将 `groupsOf 3` 应用到它上面，使其变成长度为
    3 的列表的列表。然后，我们将 lambda 函数 `(\[a,b,c] -> Section a b c)` 映射到这个列表的列表上。
- en: 'As you can see, the lambda just takes a list of length 3 and turns it into
    a section. So `roadSystem` is now our system of roads, and it even has the correct
    type: `RoadSystem` (or `[Section]`). We apply `optimalPath` to that, get the path
    and the total time in a nice textual representation, and print it out.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，lambda 函数只是将长度为 3 的列表转换为一个部分。因此，`roadSystem` 现在是我们的道路系统，它甚至具有正确的类型：`RoadSystem`（或
    `[Section]`）。我们将其应用于 `optimalPath`，得到路径和总时间的良好文本表示，并将其打印出来。
- en: 'We save the following text in a file called *paths.txt*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下文本保存到名为 *paths.txt* 的文件中：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then we feed it to our program like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像这样将其输入到我们的程序中：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Works like a charm!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得很好！
- en: 'You can use your knowledge of the `Data.Random` module to generate a much longer
    system of roads, which you can then feed to the code we just wrote. If you get
    stack overflows, you can change `foldl` to `foldl''` and `sum` to `foldl'' (+)
    0`. Alternatively, try compiling it like this before running it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用对 `Data.Random` 模块的了解来生成一个更长的道路系统，然后将其输入到我们刚刚编写的代码中。如果您遇到栈溢出，可以将 `foldl`
    改为 `foldl'`，将 `sum` 改为 `foldl' (+) 0`。或者，在运行之前，尝试按以下方式编译它：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Including the `O` flag turns on optimizations that help prevent functions such
    as `foldl` and `sum` from causing stack overflows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 `O` 标志会开启优化，这有助于防止 `foldl` 和 `sum` 等函数导致栈溢出。
