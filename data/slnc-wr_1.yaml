- en: Part I. The Source
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分。源头
- en: '*On the problems that surface long before one sends any information over the
    network*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*关于在发送任何网络信息之前就显现出来的问题*'
- en: —
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: Chapter 1. I Can Hear You Typing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。我能听到你在打字
- en: '*Where we investigate how your keystrokes can be monitored from far, far away*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们调查你的按键如何从远远的地方被监控*'
- en: —
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: From the moment you press the first key on your keyboard, the information you
    are sending begins a long journey through the virtual world. Microseconds before
    packets speed through fiber-optic links and bounce off satellite transceivers,
    a piece of information goes a long way through an amazing maze of circuits. Prior
    to your keystrokes being received by the operating system and any applications
    it might be running, many precise and subtle low-level mechanisms are engaged
    in a process that is of interest to all sorts of hackers and has proven to be
    of significance to the security crowd as well. The path to user land has many
    surprises lurking along the way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从你按下键盘上的第一个键的那一刻起，你发送的信息就开始在虚拟世界中进行漫长的旅程。在数据包通过光纤链路快速传输并从卫星收发器反射之前，几微秒内，一条信息就会通过一个令人惊叹的电路迷宫走很长的路。在你按下的键被操作系统及其可能运行的应用程序接收之前，许多精确和微妙的基础机制都在进行一个对各种黑客都感兴趣的过程，并且已经证明对安全群体也具有重要意义。通往用户空间的道路上潜伏着许多惊喜。
- en: This chapter focuses on these early stages of moving data and on the opportunities
    that arise for your fellow (and possibly naughty) users to find out way too much
    about what you are doing in the comfort of your own terminal.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论这些数据传输的早期阶段，以及你的同行（可能还有淘气的用户）有机会在你自己的终端中了解你正在做什么的机会。
- en: 'A prominent example of a potential information disclosure scenario related
    to the way a computer processes your input is associated with a subject that,
    at first glance, appears to be unrelated at best: the difficult task of producing
    random numbers on a machine that behaves in a fully predictable manner. It is
    difficult to imagine a less obvious connection, yet the problem I mention is very
    real, and may allow a sneaky observer to deduce much of a user’s activity, from
    his passwords to private email that he is typing.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与计算机处理输入方式相关的潜在信息泄露场景的显著例子，与一个乍一看似乎完全不相关的主题相关联：在一个完全可预测的行为的机器上产生随机数的困难任务。很难想象一个不那么明显的联系，然而我提到的这个问题是非常真实的，可能允许一个狡猾的观察者推断出用户的大部分活动，从他的密码到他正在输入的私人电子邮件。
- en: The Need for Randomness
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要随机性
- en: Computers are completely deterministic. They process data in a way that is governed
    by a well-defined set of laws. Engineers do their best to compensate for imperfections
    associated with the manufacturing process and the properties of the electronic
    components themselves (interference, heat noise, and so on), all to ensure that
    the systems always follow the same logic and work properly; when, with time and
    stress, components refuse to act as expected, we consider the computer to be faulty.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是完全确定性的。它们以受一组明确定义的法律所控制的方式处理数据。工程师们尽最大努力补偿与制造过程和电子元件本身的特性（干扰、热噪声等）相关的缺陷，所有这些都是为了确保系统始终遵循相同的逻辑并正常工作；当随着时间的推移和压力，组件拒绝按预期行事时，我们认为计算机出现了故障。
- en: 'The ability of machines to achieve this level of consistency, combined with
    their marvelous calculation capabilities, is what makes computers such a great
    tool for those who manage to master and control them. Naturally, one thing has
    to be said: not all is roses, and those who complain of computers being unreliable
    are not all that mistaken. Despite the perfect operation of the equipment, computer
    programs themselves do misbehave on various occasions. This is because even though
    computer hardware can be and often is consistent and reliable, you typically can’t
    make long-term predictions about the behavior of a sufficiently complex computer
    program, let alone a complex matrix of interdependent programs (such as a typical
    operating system); this makes validating a computer program quite difficult, even
    assuming we could come up with a detailed, sufficiently strict and yet flawless
    hypothetical model of what the program should be doing. Why? Well, in 1936, Alan
    Turing, the father of modern computing, proved by *reductio ad absurdum* (reduction
    to the absurd) that there can be no *general* method for determining an outcome
    of *any* computer procedure, or algorithm, in a finite time (although there may
    be *specific* methods for *some* algorithms).^([[41](apb.html#ftn.CHP-1-BIB-1)])'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 机器能够达到这种一致性水平的能力，加上它们惊人的计算能力，这就是为什么计算机对于那些能够掌握和控制它们的人来说是一个如此伟大的工具。自然，有一件事必须说：并非一切尽善尽美，那些抱怨计算机不可靠的人并不完全错。尽管设备运行得完美无缺，但计算机程序本身在许多场合还是会出问题。这是因为尽管计算机硬件可以并且通常是一致和可靠的，但你通常无法对足够复杂的计算机程序的行为做出长期预测，更不用说一个复杂的相互依赖的程序矩阵（如典型的操作系统）了；这使得验证计算机程序变得相当困难，即使我们能够提出一个详细、足够严格且无懈可击的假设模型，来描述程序应该做什么。为什么？好吧，在1936年，现代计算机之父艾伦·图灵通过**归谬法**（reductio
    ad absurdum）证明，在有限时间内确定任何计算机程序或算法的结果的**通用**方法是不可行的（尽管对于某些算法可能有**特定**的方法）.^([[41](apb.html#ftn.CHP-1-BIB-1)])
- en: This in practice means that while you cannot expect your operating system or
    text editor to ever behave precisely the way you or the author intend it to, you
    can reasonably expect that two instances of a text editor on systems running on
    the same hardware will exhibit consistent and identical behavior given the same
    input (unless, of course, one of the instances gets crushed by a falling piano
    or is otherwise influenced by other pesky external events). This is great news
    for software companies, but nevertheless, in some cases we, the security crowd,
    would prefer that the computer be a bit less deterministic. Not necessarily in
    how it behaves, but in what it can come up with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中意味着，虽然你不能期望你的操作系统或文本编辑器始终如你或作者所期望的那样表现，但你合理地期望在相同硬件上运行的同一文本编辑器的两个实例在相同的输入下会表现出一致和相同的行为（除非，当然，其中一个实例被一架掉落的钢琴压碎或受到其他讨厌的外部事件的影响）。这对软件公司来说是个好消息，但无论如何，在某些情况下，我们这些安全专家宁愿计算机的确定性稍微低一点。不一定是在它的行为上，而是在它能提出什么上。
- en: 'Take data encryption and especially that mysterious beast, public key cryptography.
    This novel and brilliant form of encryption (and more), first proposed in the
    1970s by Whitfield Diffie and Martin Hellman, and shortly thereafter turned into
    a full-blown encryption system by Ron Rivest, Adi Shamir, and Len Adleman, is
    based on a simple concept: some things are more difficult than others. That seems
    obvious, of course, but just throw in several higher math concepts, and you’re
    all set for a groundbreaking invention.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以数据加密和特别是那神秘的生物，公钥加密为例。这种新颖而卓越的加密形式（以及更多），最早在20世纪70年代由惠特菲尔德·迪菲和马丁·赫尔曼提出，不久之后由罗恩·里维斯、阿迪·沙米尔和伦·阿德勒曼将其发展成为完整的加密系统，其基础是一个简单的概念：有些事情比其他事情更难。当然，这似乎很明显，但只要加入几个高等数学概念，你就为突破性发明做好了准备。
- en: Traditional, symmetrical cryptography called for an identical shared “secret”
    value (a key) to be distributed among all parties involved in a secret communication.
    The key is required and sufficient to encrypt and later decrypt the information
    transferred, so that a third-party observer who knows the encryption method still
    cannot figure out the message. The need for a shared secret made the entire approach
    not always practical in terms of computer communications, primarily because the
    parties had to establish a secure exchange channel prior to communicating; transferring
    the secret over a nonsecure stream would render the scheme vulnerable to decryption.
    In the world of computers, you often communicate with systems or people you have
    never seen before and with whom you have no other affordable and secure communication
    channel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统对称加密要求所有参与秘密通信的各方共享一个相同的“秘密”值（一个密钥）。这个密钥是必需的，也是足够的，用于加密和随后解密传输的信息，使得即使知道加密方法的第三方观察者也无法解读信息。共享秘密的需求使得整个方法在计算机通信方面并不总是实用，主要是因为各方在通信之前必须建立一个安全的交换通道；通过非安全流传输秘密会使该方案容易受到解密攻击。在计算机的世界里，你经常与之前从未见过的人或系统进行通信，而且没有其他负担得起且安全的通信渠道。
- en: 'Public key cryptography, on the other hand, is not based on a shared secret.
    Each party holds two pieces of information: one (the public key) useful for creating
    an encrypted message, but next to useless for decryption, and the other (the private
    key) useful for decrypting a previously encrypted message. The parties can now
    exchange their public keys using an insecure channel even if it is being snooped.
    They provide each other with the information (meaningless to an observer) needed
    to encrypt messages between parties, but they keep the portion needed to access
    the encrypted data private. All of a sudden, secure communications between complete
    strangers—such as a customer sitting on a sofa in his apartment and an online
    shopping server—became closer to reality.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，公钥密码学不是基于共享秘密。每个参与者持有两份信息：一份（公钥）用于创建加密消息，但对于解密几乎毫无用处，另一份（私钥）用于解密之前加密的消息。现在，各方可以通过一个不安全的通道交换他们的公钥，即使有人在监听。他们提供了给对方所需的信息（对观察者来说毫无意义），以在各方之间加密消息，但他们将访问加密数据的部分保持私密。突然之间，完全陌生的人之间的安全通信——比如坐在公寓沙发上的一位顾客和在线购物服务器——变得接近现实。
- en: Fundamentally, the original RSA (Rivest, Shamir, and Adleman) public key cryptosystem
    is based on the observation that the computational complexity of multiplying two
    arbitrarily large numbers is fairly low; it is directly proportional to the number
    of digits to be multiplied. On the other hand, the complexity of finding factors
    (factorization) of a large number is considerably higher, unless you are a mythical
    crypto-genius working for the National Security Agency. The RSA algorithm first
    chooses two arbitrary, very large primes,^([[1](#ftn.CHP-1-FN-1)]) *p* and *q*,
    and multiplies them. It then uses the product along with a coprime,^([[2](#ftn.CHP-1-FN-2)])
    (*p-1*)(*q-1*), to construct a public key. This key can be used to encrypt information,
    but it alone is not sufficient to decrypt that information without resorting to
    factorization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，原始RSA（Rivest, Shamir, 和 Adleman）公钥密码系统是基于这样一个观察：任意两个大数相乘的计算复杂度相对较低；它直接与要相乘的数字位数成正比。另一方面，找到大数的因子（分解）的复杂度要高得多，除非你是为国家安全局工作的神话般的密码天才。RSA算法首先选择两个任意非常大的质数，记为*p*和*q*，然后将它们相乘。然后它使用这个乘积以及一个互质数，记为(*p-1*)(*q-1*)，来构造一个公钥。这个密钥可以用来加密信息，但仅凭这个密钥本身不足以解密该信息，除非通过分解。
- en: 'And the catch: Factorization of products of two large prime numbers is often
    impractical, foiling such attacks. The fastest universal integer factorization
    algorithm on traditional computers, general number field sieve (GNFS), would require
    over a thousand years to find factors of such a 1,024-bit integer, at a rate of
    one million tests per second. Finding two primes that yield a product that big
    is, on the other hand, a matter of seconds for an average PC.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 而且还有一个问题：两个大质数的乘积的分解通常是不切实际的，这阻碍了这种攻击。在传统计算机上，最快的通用整数分解算法，即通用数域筛法（GNFS），需要超过一千年才能找到这样一个1024位整数的因子，以每秒一百万次测试的速度。另一方面，找到一个产生如此大乘积的两个质数，对于一台普通的PC来说，只需要几秒钟。
- en: As indicated before, in RSA, in addition to your public key, you also produce
    a private key. The private key carries an additional piece of information about
    the primes that can be used to decrypt any information encrypted with your public
    key. The trick is possible, thanks to the Chinese Remainder Theorem, Euler’s Theorem,
    and other somewhat scary but fascinating mathematical concepts a particularly
    curious reader may want to explore on his own.^([[42](apb.html#ftn.CHP-1-BIB-2)])
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在RSA中，除了你的公钥外，你还会生成一个私钥。私钥携带有关质数的额外信息，可用于解密使用你的公钥加密的任何信息。这种技巧之所以可能，得益于中国剩余定理、欧拉定理以及其他一些可能令人畏惧但非常迷人的数学概念，特别好奇的读者可能希望自行探索.^([[42](apb.html#ftn.CHP-1-BIB-2)])
- en: Some other public key cryptosystems that rely on other hard problems in mathematics
    were also devised later on (including elliptic curve cryptosystems and so on),
    but all share the underlying concept of public and private keys. This method has
    proved practical for securing email, web transactions, and so forth, even if two
    parties have never communicated and do not have a secure channel to exchange any
    additional information prior to establishing a connection.^([[3](#ftn.CHP-1-FN-3)])
    Almost every encryption design that we use everyday, from Secure Shell (SSH) and
    Secure Sockets Layer (SSL) to digitally signed updates or smart cards, are here
    thanks to the contributions of Diffie, Hellman, Rivest, Shamir, and Adleman.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之后还设计了一些其他依赖于数学中其他难题的公钥加密系统（包括椭圆曲线加密系统等），但所有这些系统都共享公钥和私钥的基本概念。这种方法已被证明对于保护电子邮件、网络交易等非常实用，即使双方之前从未交流，并且在建立连接之前没有安全的通道来交换任何额外的信息.^([[3](#ftn.CHP-1-FN-3)])
    我们每天使用的几乎所有加密设计，从安全壳（SSH）和安全套接字层（SSL）到数字签名的更新或智能卡，都是由于Diffie、Hellman、Rivest、Shamir和Adleman的贡献。
- en: Automated Random Number Generation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动随机数生成
- en: 'There is only one problem: When implementing RSA on a deterministic machine,
    the first step is to generate two very large primes, *p* and *q*. It is simple
    for a computer to find a large prime, but there is a tiny issue: the primes also
    must be impossible for others to guess, and they cannot be the same on every machine.
    (If they were, the attack on this algorithm would not require any factorization,
    and *p* and *q* would be known to anyone who owns a similar computer.)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题：在确定性机器上实现RSA时，第一步是生成两个非常大的质数，*p* 和 *q*。对于计算机来说，找到一个大的质数很简单，但有一个小问题：这些质数还必须是不可能被他人猜到的，并且它们不能在每台机器上都是相同的。（如果它们是相同的，那么对这个算法的攻击就不需要任何分解，而且
    *p* 和 *q* 将为拥有类似计算机的任何人所知。）
- en: Many algorithms have been developed over the past few years to quickly find
    prime number candidates (pseudo-primes) and to perform rapid preliminary primality
    tests (used to verify pseudo-primes).^([[43](apb.html#ftn.CHP-1-BIB-3)]) But to
    generate a truly unpredictable prime, we need to use a good dose of entropy or
    randomness in order to either blindly choose one of the primes within a range,
    or start at a random place and pick the first prime we stumble upon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，已经开发出许多算法来快速找到质数候选者（伪质数）并执行快速的初步质数测试（用于验证伪质数).^([[43](apb.html#ftn.CHP-1-BIB-3)])
    但要生成一个真正不可预测的质数，我们需要使用大量的熵或随机性，以便盲目地选择一个范围内的质数之一，或者从一个随机位置开始，选择遇到的第一个质数。
- en: Although the need for some randomness at the time of key generation is essential,
    the demand does not end there. Public key cryptography relies on fairly complex
    calculations and is thus fairly slow, particularly when compared with the traditional
    symmetric key cryptography that uses short shared keys and a set of operations
    machines that are known to execute very fast.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在密钥生成时需要一些随机性是必不可少的，但需求并不止于此。公钥加密依赖于相当复杂的计算，因此速度相对较慢，尤其是在与传统对称密钥加密相比时，后者使用短共享密钥和一组已知执行非常快的操作机器。
- en: To implement functionality such as SSH, in which reasonable performance is expected,
    it is more sensible to establish the initial communication and basic verification
    using public key algorithms, thus creating a secure channel. The next step is
    to exchange a compact, perhaps 128-bit symmetric encryption key and continue communicating
    by switching to old-style symmetric cryptography. The main problem with symmetric
    cryptography is remedied by creating an initial (and slow) secure stream to exchange
    a shared secret, and then switching to faster algorithms, hence enabling the user
    to benefit from the higher performance without sacrificing security. Yet, to use
    symmetric cryptography in a sensible way, we still need to use a certain amount
    of entropy in order to generate an unpredictable symmetric session key for every
    secured communication.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现如 SSH 这样的功能，其中期望有合理的性能，更合理的方法是使用公钥算法建立初始通信和基本验证，从而创建一个安全通道。下一步是交换一个紧凑的、可能是
    128 位的对称加密密钥，并通过切换到旧式对称加密继续通信。对称加密的主要问题通过创建一个初始（且缓慢）的安全流来解决，以交换共享秘密，然后切换到更快的算法，从而使用户能够在不牺牲安全性的情况下受益于更高的性能。然而，为了以合理的方式使用对称加密，我们仍然需要使用一定量的熵来为每次安全通信生成一个不可预测的对称会话密钥。
- en: '* * *'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-1-FN-1)]) A prime number is a positive integer that divides only
    by 1 and itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-1-FN-1)]) 质数是只能被 1 和自身整除的正整数。
- en: ^([[2](#CHP-1-FN-2)]) A number that is *coprime to x* (also called *relatively
    prime to x*) shares no common factors with x, other than 1 and −1\. (Their greatest
    common divisor is 1.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[2](#CHP-1-FN-2)]) 与 x * *互质*（也称为与 x * *相对质*）的数与 x 没有除了 1 和 -1 以外的共同因子。（它们的最大公约数是
    1。）
- en: ^([[3](#CHP-1-FN-3)]) For the sake of completeness, it should be noted that
    adhoc public key cryptography is, among other things, vulnerable to “man in the
    middle” attacks, where an attacker impersonates one of the endpoints and provides
    its own, fake public key, in order to be able to intercept communications. To
    prevent such attacks, additional means of verifying the authenticity of a key
    must be devised, either by arranging a secure exchange or establishing a central
    authority to issue or certify keys (public key infrastructure, PKI).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[3](#CHP-1-FN-3)]) 为了完整性起见，应该指出，临时公钥加密，在其他方面，容易受到“中间人”攻击的威胁，攻击者假冒其中一个端点并提供自己的、伪造的公钥，以便能够拦截通信。为了防止此类攻击，必须设计额外的手段来验证密钥的真实性，无论是通过安排安全交换还是建立一个中央机构来颁发或认证密钥（公钥基础设施，PKI）。
- en: The Security of Random Number Generators
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数生成器的安全性
- en: Programmers have invented many ways for computers to generate seemingly random
    numbers; the general name for these algorithms is pseudorandom number generators
    (PRNGs).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员们为计算机发明了许多生成看似随机数的方法；这些算法的通用名称是伪随机数生成器（PRNGs）。
- en: 'PRNGs suffice for trivial applications, such as generating “random” events
    for computer games or meaningless subject lines for particularly obtrusive unsolicited
    bulk mailings. For instance, take the linear congruent (aka power residue) generator,^([[44](apb.html#ftn.CHP-1-BIB-4)])
    a classic example of such an algorithm. Despite its obscure name, this random
    number generator performs a sequence of simple operations (multiplication, addition,
    and modulus^([[4](#ftn.CHP-1-FN-4)])) every time it generates its “random” output.
    The generator uses its previous output r[t] to calculate the next output value,
    *r*[*t*+1] (where *t* denotes time):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PRNGs 对于简单的应用足够了，例如为计算机游戏生成“随机”事件或为特别侵扰性的垃圾邮件创建无意义的主题行。例如，考虑线性同余（也称为幂余数）生成器，^([[44](apb.html#ftn.CHP-1-BIB-4)])
    这是一个此类算法的经典例子。尽管其名称晦涩，但这个随机数生成器每次生成“随机”输出时都会执行一系列简单的操作（乘法、加法和模运算^([[4](#ftn.CHP-1-FN-4)]))。生成器使用其前一个输出
    r[t] 来计算下一个输出值，*r*[*t*+1]（其中 *t* 表示时间）：
- en: '| *r[t]* + 1 = (*a* × *r[t]* + *c*) mod *M* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| *r[t]* + 1 = (*a* × *r[t]* + *c*) mod *M* |'
- en: The modulo operator controls the range and prevents overflows, a situation that
    occurs when the result at some point goes beyond the predefined range of values.
    If *r*[*0*], *a*, *M*, and *c*—a set of control variables for the generator—are
    all positive integers, all results of this equation fall in the range of 0 to
    *M-1*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符控制范围并防止溢出，这是一种当结果在某个点超出预定义值范围时发生的情况。如果 *r*[*0*]，*a*，*M* 和 *c*——生成器的控制变量集——都是正整数，则此方程的所有结果都落在
    0 到 *M-1* 的范围内。
- en: 'Yet, while the output of this algorithm may, with some fine-tuning, exhibit
    statistical properties that make it suitable for generating random number lookalikes,
    nothing is genuinely unpredictable about its operations. And therein lies the
    problem: An attacker can easily develop their own copy of the generator and use
    it to determine any number of results that our generator will produce. Even if
    we start with an initial generator state (*r*[*0*]) that is unknown to the attacker,
    they can often successfully deduce important properties of this value by observing
    subsequent outputs of the victim’s generator and then use this knowledge to tweak
    their version of it to mimick ours. In fact, a general method to reconstruct and
    predict all polynomial congruent generators was devised over a decade ago,^([[45](apb.html#ftn.CHP-1-BIB-5)])
    and it would be quite unwise to ignore this little, perhaps somewhat inconvenient
    detail, as it creates a gaping hole in this algorithm when used for mission-critical
    purposes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管，通过一些微调，这个算法的输出可能表现出适合生成随机数类似物的统计特性，但其操作本身并没有真正不可预测。这正是问题所在：攻击者可以轻松地开发他们自己的生成器副本，并使用它来确定我们的生成器将产生的任何数量的结果。即使我们从一个攻击者不知道的初始生成器状态（*r*[*0*]）开始，他们通常也可以通过观察受害者的生成器的后续输出，然后利用这些知识来调整他们的版本以模仿我们的版本。事实上，早在十年前就设计了一种通用的方法来重建和预测所有多项式同余生成器，[[45](apb.html#ftn.CHP-1-BIB-5)]，在用于关键任务时忽视这个可能有些不便的小细节是非常不明智的，因为它在这个算法中留下了巨大的漏洞。
- en: Over time, we have realized that the only sane way for a computer to produce
    practically unpredictable data, short of suffering a massive memory failure or
    processor meltdown, is to try to gather as much practically unpredictable information
    from its physical surroundings as possible and then use that as a value passed
    to any application that demands good randomness. The problem is, an average computer
    has no “senses” with which it could probe the environment for seemingly random
    external signals. Nevertheless, we know a fairly good way to work around this
    inconvenience.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们意识到，在计算机没有发生大规模内存故障或处理器崩溃的情况下，产生实际不可预测数据的唯一合理方式，就是尽可能多地从其物理环境中收集实际不可预测的信息，然后将这些信息作为值传递给任何需要良好随机性的应用程序。问题是，一台普通的计算机没有“感官”来探测环境中的看似随机的外部信号。然而，我们知道一种相当好的方法来克服这种不便。
- en: '* * *'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[4](#CHP-1-FN-4)]) The modulo operator returns the remainder of an integer
    division of two numbers. For example, 7 is divided by 3 yielding an integer result
    of 2 and a remainder of 1 (7 = 2 * 3 + 1); 7 modulo 3 is thus 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[4](#CHP-1-FN-4)]) 模运算符返回两个数整数除法的余数。例如，7除以3得到整数结果2和余数1（7 = 2 * 3 + 1）；因此，7模3等于1。
- en: 'I/O Entropy: This Is Your Mouse Speaking'
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'I/O Entropy: This Is Your Mouse Speaking'
- en: On almost every computer system, external devices communicate relevant asynchronous
    events, such information being made available from the network card or the keyboard,
    using a hardware interrupt mechanism. Each device has an assigned hardware interrupt
    (IRQ) number and reports important developments by changing the voltage on a designated
    hardware line inside the computer, corresponding to this particular IRQ. The change
    is then interpreted by a device called a *programmable interrupt controller* (PIC),
    which serves as a personal butler for the main processor (or processors).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎每个计算机系统中，外部设备通过硬件中断机制通信相关的事件，这种信息可以通过网卡或键盘从网络卡或键盘获取。每个设备都有一个分配的硬件中断（IRQ）号，并通过改变计算机内部指定硬件线上的电压来报告重要的发展情况，对应于这个特定的IRQ。然后，这种变化被一个称为*可编程中断控制器*（PIC）的设备解释，它作为主处理器（或处理器）的个人管家。
- en: Once instructed by the CPU, the PIC decides if, when, how, and with what priority
    to deliver requests from the external devices to the main unit, which makes it
    easier for the processor to manage events in an efficient and reliable manner.
    Upon receipt of a signal from the PIC, the processor postpones its current task,
    unless of course the CPU had chosen to ignore all interrupt requests at the moment
    (if it’s really busy). Next, it invokes a code assigned by your operating system
    to handle feedback from this device or group of devices. Once the program handles
    the event, the CPU restores the original process and its context—the information
    about the state of its environment at the time of the interruption—and continues
    as if nothing has happened.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CPU发出指令，PIC（可编程中断控制器）将决定何时、如何以及以何种优先级将外部设备对主单元的请求发送出去，这使得处理器能够以高效和可靠的方式管理事件。当PIC接收到信号时，处理器会推迟其当前任务，除非当然CPU已经选择在那一刻忽略所有中断请求（如果它真的很忙）。接下来，它会调用操作系统分配的代码来处理来自该设备或设备组的反馈。一旦程序处理了事件，CPU就会恢复原始进程及其上下文——即中断发生时其环境状态的信息——然后继续就像什么都没发生一样。
- en: 'Delivering Interrupts: A Practical Example'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送中断：一个实际例子
- en: In practice, many additional steps are involved in detecting an external condition
    and then generating and receiving an IRQ. For example, [Figure 1-1](ch01s03.html#keyboard-to-computer_communications
    "Figure 1-1. Keyboard-to-computer communications") shows the sequence of events
    triggered by pressing or releasing a key on the keyboard. Before you even touch
    a single key, a tiny microcontroller chip inside your keyboard, serving as a keyboard
    controller, is busy sweeping the keyboard for any changes to its state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，检测外部条件并生成和接收一个中断请求（IRQ）涉及许多额外的步骤。例如，[图1-1](ch01s03.html#keyboard-to-computer_communications
    "图1-1. 键盘与计算机通信")展示了按下或释放键盘上的键时触发的事件序列。在你甚至触摸单个键之前，你键盘内部的一个微控制器芯片，作为键盘控制器，正忙于扫描键盘的状态变化。
- en: '![Keyboard-to-computer communications](httpatomoreillycomsourcenostarchimages1137996.png.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![键盘与计算机通信](httpatomoreillycomsourcenostarchimages1137996.png.jpg)'
- en: Figure 1-1. Keyboard-to-computer communications
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1. 键盘与计算机通信
- en: The keyboard is organized as an array of horizontal and vertical wires. Keys
    (microswitches or pressure-sensitive membrane switches) are installed at the intersection
    of each row and column. The controller tests every row and column separately,
    at very high speed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘被组织成一个水平和垂直线的阵列。按键（微开关或压力敏感膜开关）安装在每一行和每一列的交叉点。控制器以非常高的速度单独测试每一行和每一列。
- en: If, for example, the keyboard controller detects a closed circuit when testing
    row 3, column 5 (which is signified by low resistance when voltage is applied
    to these lines), it concludes that the key at this particular location (J) is
    pressed. When the keyboard controller senses a change, it converts row and column
    coordinates into a scan code, a value that identifies a key by its unique identifier.
    The scan code information is then queued in the internal buffer of a chip, which
    then tells the CPU that there’s new data and goes back to minding its own business.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果键盘控制器在测试第3行第5列时检测到一个闭合电路（当电压施加到这些线时表现为低电阻），它就会得出结论，该特定位置的键（J）被按下。当键盘控制器感知到变化时，它会将行列坐标转换为扫描码，这是一个通过其唯一标识符识别键的值。然后，扫描码信息被排队在芯片的内部缓冲区中，然后告诉CPU有新数据，并回到自己的事务中。
- en: An input controller chip is the keyboard controller’s counterpart on the motherboard.
    The input controller usually handles all basic input devices, such as the mouse
    and keyboard. It receives a single scan code from the keyboard chip and signals
    an appropriate interrupt to the CPU’s butler, the PIC. As soon as the PIC determines
    that it can deliver this particular IRQ, the PIC passes this signal to the processor,
    which then usually interrupts its current task and invokes the interrupt handler
    installed by the operating system. The handler is expected to read the data and
    to tell the chip that it has read the scan code successfully. The input controller
    then resumes its normal operations and eventually reads another scan code from
    the keyboard if there is any data in the buffer.^([[5](#ftn.CHP-1-FN-5)])
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输入控制器芯片是主板上的键盘控制器对应的部分。输入控制器通常处理所有基本输入设备，例如鼠标和键盘。它从键盘芯片接收一个单一的扫描码，并向CPU的管家，即PIC发出适当的中断信号。一旦PIC确定它可以传递这个特定的IRQ，它就会将这个信号传递给处理器，处理器随后通常会中断当前任务并调用操作系统安装的中断处理程序。处理程序预计会读取数据，并告诉芯片它已成功读取扫描码。然后输入控制器继续其正常操作，并最终从键盘读取另一个扫描码，如果缓冲区中有数据的话。[^5](#ftn.CHP-1-FN-5)
- en: This scheme is important to random number generation, although its significance
    is indirect. The computer, using the asynchronous event notification scheme (interrupts),
    receives almost instantaneous and precise feedback about user activity—perhaps
    most interestingly, accurately measured delays between keystrokes. Although the
    information is not always unpredictable, it is perhaps the best source of external,
    measurable, somewhat indeterministic signal the machine can get. And so, in order
    to work around the deterministic nature of the computer and to insert randomness
    in their calculations, authors of secure PRNG implementations resort to gathering
    entropy from generally unpredictable behavior of certain devices, such as the
    mouse, keyboard, network interfaces, and sometimes disk drives. To do so, they
    add an extra code inside an interrupt handler for the operating system that records
    certain parameters for every acceptable event.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案对于随机数生成非常重要，尽管其重要性是间接的。计算机使用异步事件通知方案（中断）几乎立即且精确地接收关于用户活动的反馈——也许最有趣的是，按键之间的准确延迟测量。尽管信息并不总是不可预测的，但可能是机器能够获得的最好的外部、可测量、某种程度上不可确定性的信号。因此，为了绕过计算机的决定论性质并在计算中插入随机性，安全PRNG实现的作者们求助于从某些设备的通常不可预测行为中收集熵，例如鼠标、键盘、网络接口，有时甚至是硬盘驱动器。为此，他们在操作系统的中断处理程序中添加了额外的代码，以记录每个可接受事件的某些参数。
- en: Although it can be argued that neither of those sources provide truly random
    feedback all the time—for example, it is likely that after the user types `aardva`,
    the next two characters are going to be `rk`—some of the behavior, such as my
    thinking of aardvarks to begin with, is indeed rather unpredictable, from a practical
    standpoint (and not getting into an academic discussion of free will and deterministic
    universes). This method of adding entropy works reasonably well because it incorporates
    several factors that cannot be reasonably considered and monitored or predicted
    by an attacker while still maintaining their sanity. By gathering data from all
    those sources for an extended period of time, the laws of probability tell us
    that we will collect a certain amount of entropy. By collecting the data in a
    buffer, we construct an entropy pool that can be full or depleted, depending on
    the supply and demand for unpredictable data. Unfortunately, these small bits
    of randomness within the pool—where our typing was influenced by cosmic events—is
    still mixed with plenty of easily predictable data and as such can’t be immediately
    used for random number generation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以争辩说，那些来源中的任何一个都无法始终如一地提供真正的随机反馈——例如，用户输入了`aardva`之后，接下来的两个字符很可能是`rk`——但某些行为，比如一开始想到鸵鸟，确实相当不可预测，从实际的角度来看（而不涉及关于自由意志和决定论宇宙的学术讨论）。这种方法增加熵的效果相当不错，因为它包含了几个攻击者难以合理考虑、监控或预测的因素，同时还能保持他们的理智。通过长时间从所有这些来源收集数据，概率定律告诉我们，我们将收集一定量的熵。通过在缓冲区中收集数据，我们构建了一个熵池，它可以充满或耗尽，这取决于不可预测数据的供应和需求。不幸的是，池中的这些随机小片段——我们的打字受到宇宙事件的影响——仍然与大量容易预测的数据混合在一起，因此不能立即用于随机数生成。
- en: To ensure that the amount of actual entropy collected in the process of maintaining
    and replenishing the entropy pool is spread evenly over all PRNG output bits (with
    all unpredictable data expended), the pool has to be hashed; that is, it has to
    be stirred and mixed throughly so that no section of the data is easier to predict
    than any other. Every bit of the output must depend equally on all the input bits,
    in a nontrivial way. Achieving this without knowing which pieces of information
    are predictable and which are not (information that is not readily available to
    a computer monitoring keystrokes or mouse movements) can be a difficult task.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在维护和补充熵池的过程中实际收集到的熵量均匀地分布在所有PRNG输出位上（所有不可预测的数据都耗尽），池必须进行哈希；也就是说，必须彻底搅拌和混合，以便没有数据部分比其他部分更容易预测。输出中的每一个比特都必须以非平凡的方式同等依赖于所有输入比特。在没有知道哪些信息是可预测的，哪些是不可预测的（这些信息对于监控按键或鼠标移动的计算机来说并不容易获得）的情况下实现这一点可能是一项艰巨的任务。
- en: One-Way Shortcut Functions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向快捷键函数
- en: 'Luckily enough, secure one-way hashing (“message digest”) functions, a flagship
    product of modern cryptography, can assist us with mixing data to get the most
    entropy into every bit of output, regardless of how nonuniform the input. These
    are functions that generate a fixed-length shortcut: a unique identifier of an
    arbitrary block of input data. But that is not all.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，安全的单向哈希函数（“消息摘要”），现代密码学的旗舰产品，可以帮助我们混合数据，将最多的熵输入到每个输出比特中，无论输入如何不均匀。这些是生成固定长度快捷键的函数：任意块输入数据的唯一标识符。但这还不是全部。
- en: 'All one-way hashing functions have two important properties:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单向哈希函数都有两个重要特性：
- en: It is easy to calculate the shortcut, but not possible to deduce the original
    message or any of its properties from the result. Any specific change to the message
    is just as likely to affect all properties of the output as any other change.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算快捷键很容易，但无法从结果中推断出原始消息或其任何属性。对消息的任何特定更改都有可能影响输出的一切属性，就像任何其他更改一样。
- en: The likelihood of two distinct messages having the same shortcut is determined
    only by the size of the shortcut. With a sufficiently large shortcut (large enough
    to make exhaustive searches impractical, nowadays set at around 128 to 160 bits,
    or circa 3.4E+38 to 1.46E+48 combinations), it is not possible to find two messages
    that would have the same shortcut.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个不同消息具有相同快捷键的可能性仅由快捷键的大小决定。拥有足够大的快捷键（大到使穷举搜索变得不切实际，如今设定在约128到160位，或大约3.4E+38到1.46E+48种组合），就找不到两个具有相同快捷键的消息。
- en: 'As a result, shortcut functions provide a means for distributing entropy present
    in the input data in a uniform way over the output data. This solves the problem
    with generally random but locally predictable entropy sources: we gather an approximate
    amount of entropy from the environment, mixed with predictable data or not, and
    can generate a shortcut that is guaranteed to be just as unpredictable as the
    entropy collected in the first place, regardless of how the input entropy was
    distributed in the input data.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，快捷键函数提供了一种方法，将输入数据中存在的熵以均匀的方式分布到输出数据中。这解决了通常随机但局部可预测的熵源的问题：我们从环境中收集大约数量的熵，与可预测的数据混合或不混合，并可以生成一个保证与最初收集的熵一样不可预测的快捷键，无论输入数据中的熵是如何分布的。
- en: How do shortcut functions work? Some again rely on mathematical problems that
    are, as far as we know, very difficult to solve. In fact, any safe symmetrical
    or public key cryptography algorithm can be easily turned into a secure hashing
    function. As long as humanity does not come up with a really clever solution to
    any of these problems, relying on this approach should be fine.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 快捷键函数是如何工作的？一些又依赖于我们已知非常难以解决的数学问题。事实上，任何安全的对称或公钥加密算法都可以很容易地转换成一个安全的哈希函数。只要人类没有找到解决这些问题的真正巧妙解决方案，依赖这种方法应该是可以的。
- en: Yet, by rolling out heavy artillery, we end up with slow and overly complicated
    tools to generate shortcuts, which is often impractical for compact implementations,
    particularly when integrating such a solution with an operating system. The alternative
    is to process the data so that the interdependency between all bits of input and
    output is sufficiently complex so as to fully obfuscate the input message and
    hope this is “good enough” to stop known cryptoanalysis techniques. Because “hopefully
    good enough” is actually the motto for a good chunk of computer science, we gladly
    accept this as a reasonable approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用重型武器，我们最终得到了缓慢且过于复杂的生成快捷方式的工具，这在紧凑型实现中通常是不切实际的，尤其是在将此类解决方案与操作系统集成时。另一种选择是处理数据，使得输入和输出所有比特之间的相互依赖关系足够复杂，以便完全混淆输入消息，并希望这“足够好”以阻止已知的密码分析技术。因为“希望足够好”实际上是计算机科学中很大一部分的座右铭，我们欣然接受这作为一个合理的做法。
- en: The advantage of the latter group of algorithms, which includes popular functions
    such as MD2, MD4, MD5, and SHA-1, is that they are generally much faster and easier
    to use than their counterparts based on difficult mathematical challenges and,
    when well designed, are not susceptible to cryptoanalysis tricks of the trade.
    Their weakness is that they are not provably secure because none of them reduces
    to a classic, hard-to-solve problem. Indeed, some have been proved to have specific
    weaknesses.^([[46](apb.html#ftn.CHP-1-BIB-6)])
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 后者这类算法的优点，包括 MD2、MD4、MD5 和 SHA-1 等流行函数，是它们通常比基于困难数学挑战的对应算法快得多，而且当设计得当，它们不易受到行业中的密码分析技巧的影响。它们的弱点是它们不是可证明安全的，因为它们都没有简化为经典且难以解决的问题。事实上，一些已经被证明具有特定的弱点.^([[46](apb.html#ftn.CHP-1-BIB-6)])
- en: As suggested earlier, a great service of shortcut functions to pseudorandom
    number generation is that they can be run on a segment of data that contains *n*
    random bits, and any number of predictable bits, to produce a shortcut that will
    spread *n* bits of entropy evenly across all bits of the shortcut (thanks to the
    two fundamental one-way shortcut function properties discussed earlier). As a
    result, the shortcut function becomes a convenient entropy extractor. By running
    a sufficient amount of data collected from a generally unpredictable interrupt
    handler through a shortcut function, we can generate random numbers without disclosing
    any valuable information about the exact shape of the information used to generate
    the number, and without the risk of imperfect input affecting the output in any
    meaningful way. All we need to do is to ensure that there is a sufficient amount
    of entropy collected and feed into a shortcut function within a chunk of interrupt
    data, else we risk compromising the entire scheme. If the attacker can predict
    considerable portions of the data we use for random number generation, and the
    remainder has only a handful of possible combinations, they can throw a successful
    brute-force attack against our implementation by simply trying and verifying all
    possible values. If, for example, we use a shortcut function that produces 128-bit
    digests, no matter how much data we actually collected, be it 200 bytes or 2 megabytes
    worth of keyboard tapping, we must be sure that at least 128 of these input bits
    are unpredictable to the attacker before hashing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，伪随机数生成中的快捷函数的一项重要服务是它们可以在包含 *n* 个随机比特和任意数量可预测比特的数据段上运行，从而产生一个快捷方式，将 *n*
    比特的熵均匀地分布在快捷方式的全部比特上（这得益于之前讨论的两个基本单向快捷函数属性）。因此，快捷函数成为了一个方便的熵提取器。通过将收集到的足够多的、通常不可预测的中断处理程序数据通过快捷函数处理，我们可以生成随机数，而无需透露用于生成该数的具体信息形状的任何有价值信息，也不会因为输入不完善而影响输出的任何有意义方式。我们所需做的只是确保在一段中断数据中收集到足够的熵并输入到快捷函数中，否则我们可能会危及整个方案。如果攻击者可以预测我们用于随机数生成的大量数据，而剩余的部分只有少数几种可能的组合，他们可以通过尝试并验证所有可能的值来对我们的实现进行成功的暴力攻击。例如，如果我们使用产生
    128 位摘要的快捷函数，无论我们实际收集了多少数据，无论是 200 字节还是 2 兆字节的键盘敲击数据，我们都必须确保在哈希之前至少有 128 个输入比特对攻击者来说是不可预测的。
- en: The Importance of Being Pedantic
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严谨的重要性
- en: As an example of when things can go wrong, consider a user who decides to write
    a shell script when a system entropy pool is empty, perhaps due to some random
    number-hungry operation that was performed a while ago. The attacker notices that
    the user is writing a script because `vi delallusers.sh` is being executed; they
    further assume that the script must have started with something along the lines
    of `#!/bin/sh`. Although they cannot be sure what is coming next, they can reasonably
    expect that the script will open with an invocation of a shell command and that
    it is somewhat less likely to continue with a tacky poem about aardvarks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为事物可能出错的一个例子，考虑一个用户在系统熵池为空时决定编写一个shell脚本的情况，这可能是由于之前执行的一些需要随机数的操作。攻击者注意到用户正在编写脚本，因为正在执行`vi
    delallusers.sh`；他们进一步假设脚本必须以类似`#!/bin/sh`的内容开始。尽管他们不能确定接下来会发生什么，但他们可以合理地预期脚本将以调用一个shell命令开始，并且不太可能接着是一首关于河马的蹩脚诗。
- en: At this point, an encryption utility of some kind suddenly asks the system for
    a 128-bit random number to be used as a session key to protect communications.
    However, the system fails to correctly estimate the amount of entropy available
    in the buffer that recorded the process of writing the first lines of the script,
    and the attacker now has an easy task. The computer is devoid of the information
    whether this particular action performed by the user at the very moment is predictable
    to others or not. It can only speculate (aided by the assumptions made by the
    programmer) that, over the course of a couple of minutes or hours, users’ actions
    will sum up to something that could not be precisely predicted and that, on average,
    this much of the input indeed would depend on factors unpredictable to the attacker.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，某种加密实用工具突然向系统请求一个128位的随机数，用作会话密钥来保护通信。然而，系统未能正确估计记录脚本第一行写入过程的缓冲区中可用的熵量，攻击者现在有一个简单的任务。计算机没有信息表明用户此时所执行的这个特定动作是否对他人来说是可预测的。它只能推测（在程序员的假设帮助下），在几分钟或几小时的过程中，用户的行为将汇总成某种无法精确预测的东西，并且平均而言，这么多的输入确实会依赖于攻击者无法预测的因素。
- en: The attacker, at this point, knows most of the entropy pool contents and is
    left with barely thousands of options to choose from when it comes to the unknown
    part—despite the fact that the operating system is convinced that there is far
    more entropy in the buffer. These thousands are hardly a big challenge for someone
    assisted by a computer. Consequently, instead of getting a 128-bit random number,
    which has a 39-digit number of combinations, an unsuspecting cryptography application
    ends up with a number generated from input that could have been only one of a
    couple thousand of options, easily verifiable by the attacker by trial and error,
    and the attacker can soon decrypt the information that was supposed to remain
    secure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，攻击者已经知道了熵池的大部分内容，在未知部分的选择上只剩下寥寥数千种可能——尽管操作系统确信缓冲区中有更多的熵。对于有计算机辅助的人来说，这数千种选择几乎不是什么大挑战。因此，而不是得到一个有39位数字组合的39位随机数，一个无知的加密应用程序最终得到了一个由输入生成的数字，这个输入可能只是成千上万个选项中的一个，攻击者可以通过试错法轻松验证，攻击者很快就能解密原本应该保持安全的信息。
- en: '* * *'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[5](#CHP-1-FN-5)]) On many architectures, it is necessary to manually instruct
    the PIC that the interrupt has been processed and that it should no longer block
    subsequent interrupts. This is done with the End of Interrupt (EOI) code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[5](#CHP-1-FN-5)]) 在许多架构上，必须手动指示PIC（中断控制器）中断已被处理，并且它不应再阻止后续的中断。这是通过结束中断（EOI）代码来完成的。
- en: Entropy Is a Terrible Thing to Waste
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熵是一种可怕的东西，浪费它
- en: Because it is next to impossible to accurately predict the amount of entropy
    collected from a user in a short run, in order to prevent the predictable PRNG
    output problem discussed previously, all implementations include the shortcut
    or internal PRNG state in the process of generating new output. The previous output
    becomes a part of the equation used to calculate the next PRNG value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在短期内准确预测从用户那里收集到的熵量几乎是不可能的，为了防止之前讨论过的可预测的PRNG输出问题，所有实现都包括在生成新输出过程中的快捷方式或内部PRNG状态。之前的输出成为计算下一个PRNG值所使用的方程的一部分。
- en: In this design, once a sufficient amount of entropy is initially gathered in
    the system, the most recent data used to replenish the entropy pool does not need
    to be fully random at all times in order to ensure basic security.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，一旦系统最初收集了足够的熵，用于补充熵池的最新数据并不需要在任何时候都是完全随机的，以确保基本的安全性。
- en: Yet, there is another problem. If the implementation runs for a prolonged period
    of time on old, inherited entropy, only hashed again and again with MD5 or SHA-1,
    it becomes fully dependent on the security of the shortcut algorithm, which cannot
    be completely trusted due to the performance and security trade-off discussed
    before. Moreover, the hashing functions have not necessarily undergone an appropriate
    evaluation of suitability for this particular use from competent cryptographers.
    The implementation no longer relies simply on the bit hashing properties of a
    shortcut function and now fully depends on its invulnerability to cracking attacks.
    If, with every subsequent step, a small amount of information about the internal
    state of the generator is disclosed, and no new unpredictable data is added to
    the pool, in the long run, the data may suffice to reconstruct or guess the internal
    state with reasonable certainty, which makes it possible to predict the future
    behavior of the device. On the other hand, if new random data is added at a rate
    that, at least statistically, prevents a significant reuse of the internal state,
    the attack becomes much less feasible even if the hashing function is fundamentally
    broken.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题。如果实现过程在旧的、继承的熵上运行了很长时间，只是反复使用MD5或SHA-1进行哈希，它就完全依赖于快捷算法的安全性，由于之前讨论的性能和安全权衡，这一点无法完全信赖。此外，哈希函数未必经过了合格密码学家对这一特定用途的适当适用性评估。实现不再仅仅依赖于快捷函数的位哈希属性，现在完全依赖于其免受破解攻击的不可攻破性。如果，在每一步后续操作中，都会泄露一些关于生成器内部状态的信息，并且没有向池中添加新的不可预测数据，从长远来看，这些数据可能足以以合理的确定性重建或猜测内部状态，这使得预测设备未来的行为成为可能。另一方面，如果以至少统计上防止内部状态大量重用的速率添加新的随机数据，即使哈希函数在本质上被破坏，攻击也变得不太可行。
- en: Many experts believe this level of trust and reliance on the hashing function
    should not be exercised for the most demanding applications. Hence, it is important
    for an implementation to keep track of an estimated amount of entropy collected
    in the system, which, even if not momentarily correct, reflects a general statistical
    trend we would expect from the sources used. Minor short-term fluctuations in
    the availability of external entropy, such as the script editing example discussed
    previously, may occur and will be compensated for by the output reuse algorithm.
    Still, it is necessary to make accurate long-term predictions to ensure frequent
    replenishing of the internal entropy pool and to minimize exposure should the
    hashing function turn out to leak internal state over time. As such, the implementation
    has to account for all entropy spent in data supplied to user processes and refuse
    to supply more random numbers until a sufficient amount of entropy is available.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专家认为，对于最苛刻的应用，不应进行这种程度的对哈希函数的信任和依赖。因此，对于实现来说，跟踪系统中收集的估计熵量非常重要，即使它不是瞬间的正确，但它反映了我们从使用的源中期望的一般统计趋势。外部熵可用性的短期波动，如之前讨论的脚本编辑示例，可能会发生，并且将通过输出重用算法得到补偿。然而，为了确保频繁地补充内部熵池并最小化哈希函数随着时间的推移可能泄露内部状态的风险，有必要进行准确的长远预测。因此，实现必须考虑提供给用户进程的数据中消耗的所有熵，并在足够的熵可用之前拒绝提供更多的随机数。
- en: A good example of a proper PRNG implementation that takes all the above into
    account is the excellent system devised and implemented in 1994 by Theodore Ts’o
    of the Massachusetts Institute of Technology. His mechanism, /dev/random, was
    first implemented in Linux and later introduced to systems such as FreeBSD, NetBSD,
    and HP/UX. Ts’o’s mechanism monitors a number of system I/O events, measuring
    time intervals and other important interrupt characteristics. It also preserves
    the entropy pool during system shutdowns by saving it to disk, which prevents
    the system from booting up to a fully predictable state, making it even more difficult
    to attack.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个考虑了上述所有因素的适当PRNG实现的良好例子是麻省理工学院Theodore Ts’o在1994年设计和实施的优秀系统。他的机制，/dev/random，最初在Linux中实现，后来被引入到FreeBSD、NetBSD和HP/UX等系统中。Ts’o的机制监控多个系统I/O事件，测量时间间隔和其他重要的中断特征。它还通过将熵池保存到磁盘来在系统关闭期间保留熵池，从而防止系统启动到完全可预测的状态，这使得攻击更加困难。
- en: 'Attack: The Implications of a Sudden Paradigm Shift'
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击：突然范式转变的影响
- en: What could be the problem with this seemingly fool-proof scheme for supplying
    unpredictable random numbers to demanding applications? Nothing, at least not
    where you would expect it. The numbers generated are indeed difficult to predict.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于为要求严格的应用程序提供不可预测随机数的看似万无一失的方案，可能存在什么问题？至少在你期望的地方没有问题。生成的数字确实难以预测。
- en: There is, however, one slight but disastrous mistake in the reasoning of the
    designer of this technology. Mr. Ts’o’s design assumes that the attacker is interested
    in predicting random numbers based on knowledge of the machine and its environment.
    But what if the attacker wants to do quite the opposite?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个技术的设计师的推理中存在一个微小但灾难性的错误。Ts’o先生的设计假设攻击者对基于对机器及其环境的了解来预测随机数感兴趣。但如果攻击者想要做的是完全相反的事情呢？
- en: The attacker with an account on the machine, even though they have no direct
    access to the information the user is typing, can deduce the exact moment input
    activity is occurring in the system by emptying the entropy pool (which can be
    achieved by simply requesting random data from the system and discarding it) and
    then monitoring the availability of PRNG output. If there is no I/O activity,
    the PRNG will not have any new data available, because the entropy estimate won’t
    change. If a keystroke or a key release occurs, a small amount of information
    will be available to the attacker, who may then deduce that a key was pressed
    or released.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使攻击者有机器上的账户，尽管他们无法直接访问用户正在输入的信息，但通过清空熵池（可以通过简单地从系统中请求随机数据并将其丢弃来实现）然后监控PRNG输出的可用性，他们可以推断出系统输入活动发生的确切时刻。如果没有I/O活动，PRNG将没有新的数据可用，因为熵估计不会改变。如果发生按键或按键释放，攻击者将获得少量信息，然后可以推断出某个键被按下或释放。
- en: Other events, such as disk activity, also generate some PRNG output, but the
    amount and timing patterns of entropy gathered this way differ from the characteristics
    of keyboard interrupt data. As such, it is possible and easy to discern events
    by the amount of data available at any given time. The data from keystrokes will
    look different from the data from disk activity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其他事件，例如磁盘活动，也会生成一些伪随机数生成器（PRNG）输出，但通过这种方式收集到的熵的数量和时序模式与键盘中断数据的特征不同。因此，根据任何给定时间可用的数据量，可以区分事件。按键数据与磁盘活动数据看起来将不同。
- en: 'In the end, a method for assuring the highest possible level of safety for
    secure random number generation actually results in degrading the privacy of the
    user: the availability of this mechanism to estimate the amount of entropy available
    from an external source can be abused and used to monitor certain aspects of input
    activities on the system. Although the attacker cannot detect exactly what is
    being typed, there are strong timing patterns for writing different words on the
    keyboard, especially if precise key press and release information is present,
    as it is in this case. By examining those patterns, the attacker can deduce the
    actual input, or at least guess it more easily.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保安全随机数生成最高可能安全水平的方法实际上会降低用户的隐私：这种机制可以用来估计从外部来源可用的熵的数量，可能会被滥用并用于监控系统输入活动的某些方面。尽管攻击者无法检测到正在输入的确切内容，但键盘上输入不同单词的时序模式非常明显，特别是如果存在精确的按键和释放信息，就像在这个案例中一样。通过检查这些模式，攻击者可以推断出实际的输入，或者至少更容易地猜测它。
- en: A Closer Look at Input Timing Patterns
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入时序模式的近距离观察
- en: An in-depth analysis led by a team of researchers at the University of California^([[47](apb.html#ftn.CHP-1-BIB-7)])
    indicates that it is possible to deduce certain properties of user input, or even
    fully reconstruct the data, by looking only at inter-keystroke timing. The research
    concluded that, for seamless typing and a keyboard-proficient operator, there
    might be some variation in inter-keystroke timings, but dominant timing patterns
    for each key-to-key transition are clearly visible.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由加州大学的研究团队进行的一项深入分析表明，仅通过观察按键间隔时间，就有可能推断出用户输入的某些属性，甚至可以完全重建数据。研究得出结论，对于无缝打字和键盘熟练的操作者，按键间隔时间可能会有所变化，但每个键到键转换的主导时间模式是明显可见的。
- en: The reason is that our hands lie on the keyboard a certain way and that the
    key position on the keyboard affects how fast we can reach a key with our fingertips.
    For example, the interval between pressing e and n is generally different from
    the interval between m and l. In the first case, because one hand controls the
    left side of the keyboard, and the other controls the right side (see [Figure 1-2](ch01s05.html#the_usual_territory_for_each_hand._dark
    "Figure 1-2. The usual territory for each hand. Dark-gray keys are usually controlled
    by the left hand, and white areas are controlled by the right hand.")), typing
    both characters requires almost no movement, and both keys are pressed almost
    simultaneously, with a time interval of less than 100 milliseconds. Typing m and
    l requires a fairly awkward fingering and takes much longer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们的手以某种方式放在键盘上，而键盘上的键位位置会影响我们用指尖到达键位的速度。例如，按e和n之间的间隔通常与按m和l之间的间隔不同。在前一种情况下，因为一只手控制键盘的左侧，另一只手控制右侧（参见[图1-2](ch01s05.html#the_usual_territory_for_each_hand._dark
    "图1-2. 每只手通常的领域。深灰色键通常由左手控制，白色区域由右手控制。")），同时输入这两个字符几乎不需要移动，并且两个键几乎同时按下，时间间隔小于100毫秒。输入m和l则需要相当不自然的指法，并且需要更长的时间。
- en: '![The usual territory for each hand. Dark-gray keys are usually controlled
    by the left hand, and white areas are controlled by the right hand.](httpatomoreillycomsourcenostarchimages1137998.png.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![每只手通常的领域。深灰色键通常由左手控制，白色区域由右手控制。](httpatomoreillycomsourcenostarchimages1137998.png.jpg)'
- en: Figure 1-2. The usual territory for each hand. Dark-gray keys are usually controlled
    by the left hand, and white areas are controlled by the right hand.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2. 每只手通常的领域。深灰色键通常由左手控制，白色区域由右手控制。
- en: After analyzing a number of samples, the authors of this research estimate that
    approximately 1.2 bits of information per key pressed can be acquired from the
    timing data. By observing sequence delays, it is possible to determine the set
    of keyboard inputs most likely to generate this pattern, thus making it easier
    to guess the exact sequence of keys pressed. The idea of counting fractions of
    bits may sound ridiculous, but what this really means is that the number of possibilities
    for every key can be reduced by 2^(1.2), or approximately 2.40 times. For a single
    regular keystroke, which usually carries no more than 6 bits of randomness to
    begin with, this reduces the option set from about 64 to 26 elements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析了大量样本之后，这项研究的作者估计，从按键时间数据中可以获得大约每个按键1.2比特的信息。通过观察序列延迟，可以确定最有可能产生这种模式的一组键盘输入，从而更容易猜测按键的确切顺序。计算比特分数的想法可能听起来很荒谬，但它的真正含义是，每个键的可能性可以减少到2^(1.2)，或者大约2.40倍。对于一个普通的按键，它一开始通常携带不超过6比特的随机性，这将从大约64个元素减少到26个元素。
- en: The net effect is that this reduces the level of search space; we can see that
    there’s a way to limit the number of possibilities if we want to guess at what
    keys are being typed. Although this reduction may not be particularly impressive
    on its own, add to this that the data entered from the keyboard is not likely
    to be just random garbage to start with. The entropy of English text is estimated
    to be as low as 0.6 to 1.3 bits per character,^([[48](apb.html#ftn.CHP-1-BIB-8)])
    meaning that it on average takes approximately 1.5 to 2.5 attempts to successfully
    predict the next character. With a method to further reduce the search space,
    it is possible to find nonambiguous dictionary word matches for almost all the
    input data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种净效应是减少了搜索空间水平；如果我们想猜测正在输入的键，我们可以看到有一种方法可以限制可能性的数量。尽管这种减少本身可能并不特别令人印象深刻，但加上从键盘输入的数据不太可能是随机的垃圾。英语文本的熵估计为每字符0.6到1.3比特，这意味着平均需要大约1.5到2.5次尝试才能成功预测下一个字符。有了进一步减少搜索空间的方法，几乎可以找到所有输入数据的非歧义性词典单词匹配。
- en: To verify their estimates and demonstrate the issue in practice, the researchers
    used the Hidden Markov Model and Viterbi algorithm to guess keystrokes. A Markov
    Model is a method for describing a discrete system in which the next value depends
    only on its current state, and not on the previous values (Markov chain). The
    Hidden Markov Model is a variant that provides a method for describing a system
    for which each internal state generates an observation, but for which the actual
    state is not known. This model is commonly used in applications such as speech
    recognition, in which the goal is to obtain pure data (a textual representation
    of the spoken word) from its specific manifestation (sampled waveform).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证他们的估计并在实践中展示问题，研究人员使用了隐马尔可夫模型和维特比算法来猜测按键。马尔可夫模型是一种描述离散系统的方法，其中下一个值仅取决于其当前状态，而不是先前值（马尔可夫链）。隐马尔可夫模型是一种变体，它提供了一种描述系统的方法，其中每个内部状态都产生一个观察结果，但对于实际状态却不知道。该模型在语音识别等应用中常用，其目标是获得纯数据（口头语言的文本表示）。
- en: The authors conclude that the Hidden Markov Model is applicable to keystroke
    analysis, and they consider the internal state of the system to be the information
    about keys pressed; the observation in the Hidden Markov Model is the inter-keystroke
    timing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作者得出结论，隐马尔可夫模型适用于按键分析，他们认为系统的内部状态是按键信息；隐马尔可夫模型中的观察结果是按键间的时序。
- en: It might be argued that this is an oversimplification, because, most notably
    in the situation pictured in [Figure 1-3](ch01s05.html#the_need_to_move_the_left_hand_to_a_diff
    "Figure 1-3. The need to move the left hand to a different position in the previous
    step affects the P-V timing. The Markov Model is unable to take a previous location
    of the hand on hand-switch scenarios into account."), there might be a deeper
    dependency.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有人认为这是一种过度简化，因为在图1-3[图1-3. 在前一步中需要将左手移动到不同的位置会影响P-V时间。马尔可夫模型无法考虑手切换场景中手的先前位置。](ch01s05.html#the_need_to_move_the_left_hand_to_a_diff
    "图1-3. 在前一步中需要将左手移动到不同的位置会影响P-V时间。马尔可夫模型无法考虑手切换场景中手的先前位置。")所示的情况下，可能存在更深层次的依赖关系。
- en: '![The need to move the left hand to a different position in the previous step
    affects the P-V timing. The Markov Model is unable to take a previous location
    of the hand on hand-switch scenarios into account.](httpatomoreillycomsourcenostarchimages1138000.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图1-3. 在前一步中需要将左手移动到不同的位置会影响P-V时间。马尔可夫模型无法考虑手切换场景中手的先前位置。](httpatomoreillycomsourcenostarchimages1138000.png.jpg)'
- en: Figure 1-3. The need to move the left hand to a different position in the previous
    step affects the P-V timing. The Markov Model is unable to take a previous location
    of the hand on hand-switch scenarios into account.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3. 在前一步中需要将左手移动到不同的位置会影响P-V时间。马尔可夫模型无法考虑手切换场景中手的先前位置。
- en: The Viterbi algorithm is one way to solve Hidden Markov Model problems. The
    algorithm can be used to find the most likely sequence of internal states based
    on a sequence of observations. In this particular case, we use it to determine
    the most likely sequence of characters based on a sequence of timings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 维特比算法是解决隐马尔可夫模型问题的一种方法。该算法可以根据观察序列找到最可能的内部状态序列。在这种情况下，我们使用它来确定基于时序的最可能的字符序列。
- en: The final result of applying the Viterbi algorithm is a reduction of the search
    space for nondictionary eight-character passwords by a factor of 50\. For reconstruction
    of typed dictionary-based English text, the factor is likely to be considerably
    higher.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用维特比算法的最终结果是，将非字典八字符密码的搜索空间减少了50倍。对于基于字典的英语文本的重建，这个因素可能要高得多。
- en: Now let’s look at interrupt monitoring. The research we’ve just discussed focused
    on partial information available by snooping on Secure Shell (SSH) traffic patterns.
    In the case of interrupt monitoring, the attacker has considerably more information
    available. For one thing, keystroke duration information is available as well
    as inter-keystroke timings, with the duration of a single keystroke depending
    on the finger used. For example the index finger usually makes the shortest contact
    with the key, the ring finger is probably the slowest, and so on. This is valuable
    information, which makes it much easier to locate an approximate area of keys
    on the keyboard.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看中断监控。我们刚才讨论的研究主要集中在通过监听安全壳（SSH）流量模式可获得的部分信息。在中断监控的情况下，攻击者可以获得的信息要多得多。首先，按键持续时间信息以及按键间的时序信息都是可用的，单个按键的持续时间取决于使用的手指。例如，食指通常与键的接触时间最短，无名指可能是最慢的，依此类推。这是非常有价值的信息，使得定位键盘上按键的大致区域变得容易得多。
- en: Second, the data also enables the attacker to monitor hand transitions, the
    moment when the first character is typed by the left hand, and the second by the
    right hand, or vice versa. Because each hand is controlled by a different hemisphere
    of the brain, almost all proficient keyboard users often press the second key
    before releasing the first when switching hands. Although key press and release
    events are indistinguishable as such, a particularly short interval of time between
    two keyboard events is a clear sign of this phenomenon. In some rare situations,
    particularly when the typist is in a hurry, the second key press occurs not only
    before the release, but even before the press of the first key. This results in
    popular typographic errors such as “teh” instead of “the.”
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这些数据还使攻击者能够监控手部转换，即当左手首先输入第一个字符，右手输入第二个字符，或者反之亦然的时刻。因为每只手都受大脑不同半球的控制，几乎所有熟练的键盘用户在切换手时通常会在释放第一个键之前按下第二个键。尽管按键和释放事件本身是不可区分的，但两个键盘事件之间特别短的时间间隔是这种现象的明显迹象。在某些罕见的情况下，尤其是当打字员匆忙时，第二个按键不仅会在释放之前发生，甚至会在第一个键按下之前发生。这导致了诸如“teh”而不是“the”这样的常见打字错误。
- en: '[Figure 1-4](ch01s05.html#key_press_and_release_timing_for_hand_tr "Figure 1-4. Key
    press and release timing for hand transitions") shows a capture of sample keyboard
    timings. The user types the word *evil*. The middle finger of the left hand presses
    e for a medium period of time. Then, there is a considerable interval before the
    typist presses v due to the need to move the entire hand in order to reach v with
    the index finger. (The thumb cannot be used because the spacebar gets in the way.)
    “The v is pressed for a short period of time, as is i, with both accessed by the
    index finger. There is also a visible overlap: i is pressed before v is released
    due to a hand transition. Finally, the ring finger presses l after a while (there
    is no need to move the hand), and the contact is quite long.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-4](ch01s05.html#key_press_and_release_timing_for_hand_tr "图1-4. 按键和释放时间的手部转换")
    展示了样本键盘时序的捕获。用户输入单词 *evil*。左手的中指按键e持续了中等的时间。然后，由于需要整个手移动以使用食指按键v，因此在按键v之前有一个相当长的间隔。（因为空格键挡住了，所以不能用大拇指。）“v按键的时间很短，i也是如此，两者都通过食指访问。还有一个明显的重叠：由于手部转换，i在v释放之前被按下。最后，一段时间后，无名指按下l（不需要移动手），接触时间相当长。'
- en: '![Key press and release timing for hand transitions](httpatomoreillycomsourcenostarchimages1138002.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![按键和释放时间的手部转换](httpatomoreillycomsourcenostarchimages1138002.png.jpg)'
- en: Figure 1-4. Key press and release timing for hand transitions
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4. 按键和释放时间的手部转换
- en: Hence, it is reasonable to expect that it is possible to achieve a much higher
    success ratio in this attack. (Most of this information was not available in the
    scenario discussed in the aforementioned white paper.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，合理地预期，在这个攻击中可以达到更高的成功率。（上述白皮书中讨论的场景中，大部分这些信息是不可用的。）
- en: Immediate Defense Tactics
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即防御战术
- en: Now that we know the potential for keyboard sniffing, how do we thwart it? The
    best way is to employ a separate keyboard entropy buffer of a reasonable size.
    The buffer is flushed and passed down to the core PRNG implementation only after
    it overflows or after a time interval considerably larger than the usual inter-keystroke
    delay (that is, at least several seconds) passes, thus eliminating the attacker’s
    ability to measure timing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道键盘嗅探的潜在可能性，我们该如何阻止它？最好的办法是使用一个合理大小的独立键盘熵缓冲区。只有在缓冲区溢出或经过比通常的按键延迟（即至少几秒钟）大得多的时间间隔之后，缓冲区才会被刷新并传递到核心PRNG实现，从而消除攻击者测量时间的能力。
- en: With this solution, only two types of information are available to the attacker.
    The first results from the flush on overflow procedure and discloses to the attacker
    that a number of keys (depending on the buffer size) were pressed in a measurable
    period of time, but does not divulge exact key interval timings. The second possibility
    is a result of a timed flush sequence, and informs the attacker that a key or
    several keys were pressed during a fixed time frame, but does not provide any
    information about the number of events and their precise time of occurrence. The
    information provided in this way is of a marginal value for timing attacks and
    can only be used for generating general statistics of keyboard activity, the latter
    not posing a threat in most multiuser environments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种解决方案，攻击者只能获得两种类型的信息。第一种来自溢出时的刷新程序，向攻击者透露在可测量的时间段内按下了多少个键（取决于缓冲区大小），但不会透露确切的键间隔时间。第二种可能是定时刷新序列的结果，并告知攻击者在一个固定的时间框架内按下了键或几个键，但不会提供有关事件数量及其精确发生时间的任何信息。以这种方式提供的信息对于时间攻击的价值很小，只能用于生成键盘活动的通用统计数据，后者在大多数多用户环境中不构成威胁。
- en: 'Hardware RNG: A Better Solution?'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件随机数生成器：更好的解决方案？
- en: A number of today’s hardware platforms implement physical random number generators,
    often referred to as TRNGs, or true random number generators. These devices provide
    a more reliable way of generating truly unpredictable data, as opposed to gathering
    information that is merely expected to be difficult to predict, and are a recommended
    way of acquiring entropy on all machines equipped with this hardware. Two popular
    solutions, as of this writing, are integrated circuits developed by Intel and
    VIA.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，许多硬件平台实现了物理随机数生成器，通常称为TRNGs，即真正的随机数生成器。这些设备提供了一种更可靠的方式来生成真正不可预测的数据，而不是收集仅预期难以预测的信息，并且是所有配备此硬件的机器获取熵的推荐方式。目前两种流行的解决方案是英特尔和VIA开发的集成电路。
- en: Intel RNG is integrated with chip sets such as i810 and uses a conventional
    design of two oscillators. The high-frequency oscillator generates a base signal,
    which is essentially a pattern of alternating logical states (010101010101...).
    The other oscillator is a low-frequency device, working at a nominal rate of 1/100
    the frequency of the high-speed oscillator, but its actual frequency is modulated
    by a resistor, which serves as a primary source of entropy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔随机数生成器（Intel RNG）与i810等芯片组集成，并采用传统的双振荡器设计。高频振荡器产生一个基本信号，本质上是一种交替逻辑状态的模式（010101010101...）。另一个振荡器是一个低频设备，以高速振荡器频率的1/100的标称速率工作，但其实际频率由一个电阻调制，该电阻作为熵的主要来源。
- en: Certain measurable characteristics of a resistor change as a result of thermal
    noise and other random material effects. The low-frequency oscillator is used
    to drive sampling of the alternating signal at now random frequencies (falling
    edge of the oscillator output). The signal, after some necessary conditioning
    and “whitening” using von Neumann correction, is then made available to the outside
    world. A careful analysis of the design and actual output of the generator performed
    by Benjamin Jun and Paul Kocher of Cryptography Research^([[49](apb.html#ftn.CHP-1-BIB-9)])
    has shown that the quality of the output is consistently high and that the generator
    provides an estimated 0.999 bits of entropy per output bit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于热噪声和其他随机材料效应，电阻的一些可测量特性会发生变化。低频振荡器用于在现在随机的频率下驱动采样交替信号（振荡器输出的下降沿）。信号经过一些必要的条件处理和“白化”使用冯·诺伊曼校正后，然后对外界可用。密码学研究公司（Cryptography
    Research）的本杰明·朱（Benjamin Jun）和保罗·科赫（Paul Kocher）对设计者和实际输出进行了仔细分析，表明输出质量始终很高，并且该生成器每输出一个比特提供大约0.999比特的熵。
- en: VIA C3 “Nehemiah” RNG is based on a slightly different design that uses a set
    of oscillators, but not a separate source of noise, such as a special resistor
    hookup. Instead, it relies on the internal jitter of the oscillators, an effect
    that can be attributed to a number of internal and external factors and additionally
    controlled by a configurable “bias” setting.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: VIA C3 “Nehemiah” RNG基于一个稍微不同的设计，它使用一组振荡器，但没有使用如特殊电阻连接等单独的噪声源。相反，它依赖于振荡器的内部抖动，这是一个可以归因于许多内部和外部因素的效果，并且可以通过可配置的“偏差”设置进行控制。
- en: In this case, a separate analysis led by Cryptography Research^([[50](apb.html#ftn.CHP-1-BIB-10)])
    indicated the generator apparently delivers a lower-quality entropy than its counterpart,
    ranging from 0.855 to 0.95 bits per output bit. This is a dangerous result if
    the RNG output is taken as fully random as-is and used for key generation or other
    critical tasks 1:1, because the amount of actual entropy is reduced accordingly.
    To solve this problem, we can acquire more data than necessary from the generator
    and then run the data via a secure hashing function, such as SHA-1, to eliminate
    any eventual bias or entropy deficiency. The solution is a general good practice
    for preventing TRNG issues, as long as these undesirable effects are within reasonable
    limits—that is, each bit still carries some useful entropy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由密码学研究进行的单独分析表明，生成器显然提供的熵量低于其对应物，范围从每个输出比特0.855到0.95比特。如果将RNG输出视为完全随机的并直接用于密钥生成或其他关键任务，这将是一个危险的结果，因为实际熵量相应减少。为了解决这个问题，我们可以从生成器获取比必要更多的数据，然后通过一个安全的哈希函数，如SHA-1，来消除任何可能的偏差或熵不足。这个解决方案是防止TRNG问题的通用良好实践，只要这些不良影响在合理范围内——也就是说，每个比特仍然携带一些有用的熵。
- en: 'Several researchers have also suggested using certain nonspecialized input
    devices, such as webcams or built-in microphones, as a source of entropy: Charge
    Coupled Device (CCD) sensors in digital cameras tend to exhibit pixel noise, and
    a severely overamplified microphone signal is essentially a good source of random
    noise. However, there is no universal method for setting up such a generator due
    to the differences in circuits of popular media devices from various manufacturers,
    and as such the quality of “random” numbers generated this way cannot be assured.
    In fact, some devices pick up seemingly random but fully predictable radio interference
    or certain in-circuit signals. Additionally, some devices, in particular CCD sensors,
    exhibit static noise patterns. While seemingly random, this noise is not changing
    rapidly and may be dangerous to rely on.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些研究人员还建议使用某些非专用输入设备，如网络摄像头或内置麦克风，作为熵的来源：数字相机的电荷耦合器件（CCD）传感器往往会表现出像素噪声，而严重过放的麦克风信号基本上是一个好的随机噪声来源。然而，由于不同制造商的流行媒体设备电路的不同，没有通用的设置此类生成器的方法，因此这种方式生成的“随机”数质量无法保证。实际上，一些设备会接收到看似随机但实际上完全可预测的无线电干扰或某些电路信号。此外，一些设备，特别是CCD传感器，表现出静态噪声模式。虽然看似随机，但这种噪声变化不快，可能不可靠。
- en: Food for Thought
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考食物
- en: I have decided to omit in-depth discussion of a few interesting concepts, but
    these may be a valuable inspiration for further explorations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经决定省略对一些有趣概念的深入讨论，但这些可能对进一步的探索具有宝贵的启发。
- en: Remote Timing Attacks
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程定时攻击
- en: In theory, it might be possible to deploy the PRNG timing attack over a network.
    Certain cryptography-enabled services implement symmetrical cryptography. After
    establishing a slower asymmetric stream using public key infrastructure and verifying
    both parties, a symmetrical session key is generated, and both endpoints switch
    to a faster symmetrical alternative.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，可能通过网络部署PRNG定时攻击。某些启用了密码学的服务实现了对称密码学。在通过公钥基础设施建立较慢的非对称流并验证双方后，生成一个对称会话密钥，然后两个端点切换到更快的对称替代方案。
- en: It might be possible to time keystrokes by causing the application to exhaust
    an existing entropy pool in the system to the point that there is not enough entropy
    to seed a new session key, but only by a small fraction. The application will
    then delay generating a symmetrical key until enough entropy to seed the remainder
    of a key is available, and this will occur, among other possibilities, on the
    next key press or release.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能通过使应用程序耗尽系统中的现有熵池，直到没有足够的熵来生成新的会话密钥，但仅是微小的一部分。然后应用程序将延迟生成对称密钥，直到有足够的熵来生成密钥的剩余部分，这可能会在下一个按键或释放时发生。
- en: It is my belief that the attack is more likely to succeed in a laboratory setup
    than in any real-world practical application, although my technical reviewer disagrees
    with my skepticism, and so, consider it to be merely an opinion. An interesting
    analysis from the University of Virginia criticized the original SSH timing research
    discussed in the paper mentioned before on the grounds that network jitter is
    sufficient to render timing data unusable, although it is worth noting that if
    a specific activity is repeated over time (for example, the same password is entered
    upon every login), random network performance fluctuations may very well average
    out.^([[51](apb.html#ftn.CHP-1-BIB-11)])
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我认为这种攻击更有可能在实验室环境中成功，而不是在任何实际应用中，尽管我的技术审稿人不同意我的怀疑态度，因此，这只是一个观点。弗吉尼亚大学的一项有趣的分析批评了之前在论文中讨论的原始SSH时间研究，理由是网络抖动足以使时间数据变得不可用，尽管值得注意的是，如果某个特定活动在一段时间内重复进行（例如，每次登录都输入相同的密码），随机网络性能波动可能会很好地平均化.^([[51](apb.html#ftn.CHP-1-BIB-11)])
- en: Exploiting System Diagnostics
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用系统诊断
- en: Some systems have better ways to recover the keystroke information and other
    timing data. After publishing my PRNG timing research, it was pointed out to me
    that Linux provides a /proc/interrupts interface that displays interrupt summary
    statistics, with the intention of providing some useful performance data. By examining
    interrupt counter changes for IRQ 1, it is possible to obtain the same timing
    information that is acquired via PRNG, already filtered of any eventual disk and
    network activity inclusions, thus causing a privacy exposure similar to the one
    discussed before.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统有更好的方法来恢复按键信息和其他时间数据。在我发布PRNG时间研究之后，有人指出Linux提供了一个/proc/interrupts接口，该接口显示中断摘要统计信息，目的是提供一些有用的性能数据。通过检查中断计数器变化对于IRQ
    1，可以获得与通过PRNG获取的相同的时间信息，已经过滤掉了任何可能的磁盘和网络活动，从而造成与之前讨论过的类似的隐私泄露。
- en: Reproducible Unpredictability
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可复现的不确定性
- en: Other issues worth considering are related to the PRNG implementation itself.
    Buying identical hardware in bulk and installing the same system on each device
    is a common practice and can be a problem for servers that do not experience heavy
    console activity. There is also a risk of mirroring an installation using specialized
    duplication tools and then propagating the image across a number of servers. In
    all situations, systems can end up with low real entropy for perhaps a bit too
    long.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得考虑的其他问题与PRNG实现本身有关。批量购买相同硬件并在每个设备上安装相同的系统是一种常见做法，但对于没有经历大量控制台活动的服务器来说可能会成为问题。使用专门的复制工具镜像安装并随后在多台服务器上传播镜像也存在风险。在所有情况下，系统可能会因为实际熵过低而持续一段时间。
- en: Chapter 2. Extra Efforts Never Go Unnoticed
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 付出额外努力永远不会被忽视
- en: '*Where we learn how to build a wooden computer and how to obtain information
    from watching a real computer run*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里我们学习如何构建木制计算机以及如何通过观察真实计算机的运行来获取信息*'
- en: —
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: The data you entered is now safe in the hands of the application you chose to
    run. The program will take its time deciding what to do with the information,
    how to interpret it, and which actions to take next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您输入的数据现在已安全地存储在您选择的运行应用程序的手中。程序将花费时间决定如何处理信息，如何解释它，以及下一步要采取哪些行动。
- en: In this chapter, we examine the low-level mechanics of data processing in detail
    and explore some of the pitfalls that can lurk deep beneath the heat sink of your
    processor. We pay particular attention to the information we can deduce simply
    by observing how a machine executes given programs and how much time it takes
    to complete certain tasks. As a bonus, we’ll also build a fully functional wooden
    computer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了数据处理的基础机制，并探讨了可能潜伏在处理器散热片之下的某些陷阱。我们特别关注我们可以通过观察机器执行给定程序以及完成某些任务所需的时间来推断的信息。作为额外奖励，我们还将构建一个完全功能的木制计算机。
- en: Boole’s Heritage
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔的遗产
- en: 'To understand the design of a processor, we must return to the days when processors
    had not yet been dreamed of. It all started quite innocently back in the 19th
    century, when self-taught mathematician George Boole (1815–64) devised a simple
    binary algebra system intended to provide a framework for understanding and modeling
    formal calculus. His approach reduced the fundamental concepts of logic to a set
    of three, simple algebraic operations that could be applied to elements representing
    two opposite states, true and false. These operations are:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解处理器的结构，我们必须回到处理器尚未被梦想出来的时代。这一切始于19世纪，当时自学成才的数学家乔治·布尔（1815–64）设计了一种简单的二进制代数系统，旨在为理解建模形式推理提供一个框架。他的方法将逻辑的基本概念简化为三组简单的代数运算，这些运算可以应用于代表两种相反状态的元素，即真和假。这些运算包括：
- en: The disjunction operator, **OR**. This is true when at least one of its operands^([[6](#ftn.CHP-2-FN-1)])
    is true.^([[7](#ftn.CHP-2-FN-2)])
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析取运算符，**OR**。当至少有一个操作数^([[6](#ftn.CHP-2-FN-1)])为真时，这个运算符才为真.^([[7](#ftn.CHP-2-FN-2)])
- en: The conjunction operator, **AND**. This is only true when all its operands are
    true.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接运算符，**AND**。只有当所有操作数都为真时，这个运算符才为真。
- en: The complement (negation) operator, **NOT**. This is true when its only operand
    is false.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补码（否定）运算符，**NOT**。当它的唯一操作数为假时，这个运算符才为真。
- en: Although simple in design, the Boolean algebraic model turned out to be a powerful
    tool for solving logic problems and certain other mathematical challenges. Ultimately,
    it made it possible for many brave visionaries to dream of clever analytic machines
    that would one day change our daily lives.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管布尔代数模型在设计上很简单，但它最终成为了解决逻辑问题和某些其他数学挑战的有力工具。最终，它使得许多勇敢的先知能够梦想出聪明的分析机器，这些机器有一天将改变我们的日常生活。
- en: Today, Boolean logic is seldom a mystery for the experienced computer user,
    but the path from this set of trivial operations to today’s computer often is.
    We’ll begin exploring this path by first attempting to capture the essence of
    this model at its simplest.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，布尔逻辑对于经验丰富的计算机用户来说很少是神秘的，但从这一组简单操作到今天的计算机的道路往往如此。我们将首先通过尝试捕捉这个模型在最简单形式下的本质来开始探索这条道路。
- en: '* * *'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[6](#CHP-2-FN-1)]) The operand is something that is operated on by the operator.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[6](#CHP-2-FN-1)]) 操作数是操作符操作的对象。
- en: '^([[7](#CHP-2-FN-2)]) The meaning of logical OR differs from the common English
    understanding of this term: the resulting statement remains true both when only
    one of the OR parameters is true and when all are. In English, “or” typically
    means that *only* one option is true.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[7](#CHP-2-FN-2)]) 逻辑或的意义与英语中对这一术语的常见理解不同：当只有其中一个或所有参数为真时，结果语句仍然为真。在英语中，“或”通常意味着*只有*一个选项为真。
- en: Toward the Universal Operator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通向通用运算符之路
- en: The path to simplicity often leads through a seemingly needless level of complexity—and
    this case is no exception. To even begin, we must consider the work of another
    19th-century mathematician, Augustus DeMorgan (1806–71). DeMorgan’s law states
    that “a complement of disjunction is the conjunction of complements.” This infamous
    exercise in obfuscating trivial concepts has some profound consequences for Boolean
    logic and, ultimately, the design of digital circuits.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的道路往往要通过看似不必要的复杂级别——这个例子也不例外。为了开始，我们必须考虑另一位19世纪数学家奥古斯都·德摩根（1806–71）的工作。德摩根定律指出，“析取的补码是补码的合取。”这种臭名昭著的混淆简单概念的做法对布尔逻辑以及最终数字电路的设计产生了深远的影响。
- en: In plain English, DeMorgan’s law explains that when any (or both) of two conditions
    is not satisfied, a sentence that claims that both conditions are met (or, in
    other words, a conjunction of conditions occurs) will be false as well—oh, and
    vice versa.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，德摩根定律解释了当任何（或两个）条件不满足时，声称两个条件都满足的句子（或者说，条件合取发生）也将是错误的——哦，反之亦然。
- en: 'The law concludes that NOT OR (a, b) should be logically equivalent to AND
    (NOT a, NOT b). Consider a real-world example in which a and b represent the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这条定律得出结论，NOT OR (a, b) 应该在逻辑上等同于AND (NOT a, NOT b)。考虑一个现实世界的例子，其中a和b代表以下内容：
- en: '| a = “Bob likes milk” |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| a = “Bob 喜欢牛奶” |'
- en: '| b = “Bob likes apples” |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| b = “Bob 喜欢苹果” |'
- en: 'The two sides of the DeMorgan’s equation can be now written as:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将德摩根方程的两侧写成：
- en: '| OR (NOT a, NOT b) ⇔ Bob does NOT like milk OR does NOT like apples |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| OR (NOT a, NOT b) ⇔ Bob 不喜欢牛奶或不喜欢苹果 |'
- en: '| NOT AND (a, b) ⇔ It is NOT true that Bob likes both milk AND apples |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| NOT AND (a, b) ⇔ 不正确的是 Bob 同时喜欢牛奶和苹果 |'
- en: Both expressions are functionally equivalent. If it is true that Bob dislikes
    either milk or apples, the first expression is true; it is then also true that
    he does not like both, which means that the second expression is also true.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表达式在功能上是等价的。如果Bob不喜欢牛奶或苹果中的任何一个，第一个表达式就是真的；那么他也不喜欢两者，这意味着第二个表达式也是真的。
- en: 'Reversing the situation also results in agreement: If it is not true that Bob
    dislikes at least one of the choices, he likes both (and the first expression
    is false). In that case, it is also not true that he does not like both (and the
    second expression is also false).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 反转情况也会得到一致的结果：如果Bob不喜欢至少一个选择，他喜欢两者（第一个表达式是假的）。在这种情况下，他也不喜欢两者（第二个表达式也是假的）。
- en: DeMorgan at Work
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 德摩根定律的应用
- en: To evaluate logic statements beyond appeals to intuition and some hand waving,
    it helps to construct so-called truth tables that demonstrate all the results
    that can be calculated from all possible combinations of true and false operators.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估超出直觉和一些手势的逻辑语句，构建所谓的真值表是有帮助的，这些真值表展示了从所有可能的真值和假值操作符组合中可以计算出的所有结果。
- en: The following two tables represent each expression from the previous example.
    Each table includes columns for both operators and the corresponding results for
    all possible true and false combinations. And so, in the first row, you can see
    that two first columns—both operands to NOT AND(a, b)—are false. This causes AND(a,
    b) to be false, as well, hence causing NOT AND(a, b) to be true. The outcome is
    denoted in the third column.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个表格表示了上一个例子中的每个表达式。每个表格都包括操作符和所有可能的真值和假值组合的对应结果列。因此，在第一行中，你可以看到前两列——NOT
    AND(a, b)的两个操作数——都是假的。这导致AND(a, b)也是假的，因此NOT AND(a, b)是真的。结果在第三列中给出。
- en: 'As you can see, the two expressions behave identically:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，两个表达式的行为相同：
- en: '| NOT AND(a, b): AND w/Result Negated |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| NOT AND(a, b): 与结果取反 |'
- en: '| --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Operand 1 (a) | Operand 2 (b) | Result |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 1 (a) | 操作数 2 (b) | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| FALSE | FALSE | TRUE |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | FALSE | TRUE |'
- en: '| FALSE | TRUE | TRUE |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | TRUE | TRUE |'
- en: '| TRUE | FALSE | TRUE |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | FALSE | TRUE |'
- en: '| TRUE | TRUE | FALSE |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | TRUE | FALSE |'
- en: '| OR(NOT a, NOT b): OR w/Operands Negated |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| OR(NOT a, NOT b): 操作数取反的OR |'
- en: '| --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Operand 1 | Operand 2 | Result |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 1 | 操作数 2 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| FALSE | FALSE | TRUE |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | FALSE | TRUE |'
- en: '| FALSE | TRUE | TRUE |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | TRUE | TRUE |'
- en: '| TRUE | FALSE | TRUE |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | FALSE | TRUE |'
- en: '| TRUE | TRUE | FALSE |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | TRUE | FALSE |'
- en: 'But why do computer designers care about Bob’s food preferences? Because in
    the context of Boolean operators, DeMorgan’s law means that the set of basic operations
    proposed by Boolean algebra is actually partially redundant: a combination of
    NOT and any of the two other operators (OR and AND) is always sufficient to synthesize
    the remaining one. For example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么计算机设计师关心Bob的食物偏好呢？因为在布尔操作符的背景下，德摩根定律意味着布尔代数提出的基本操作集实际上是部分冗余的：NOT和另外两个操作符（OR和AND）中的任何一个的组合总是足以合成剩下的一个。例如：
- en: '| OR (a, b) ⇔ NOT AND (NOT a, NOT b) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| OR (a, b) ⇔ NOT AND (NOT a, NOT b) |'
- en: '| AND (a, b) ⇔ NOT OR(NOT a, NOT b) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| AND (a, b) ⇔ NOT OR(NOT a, NOT b) |'
- en: This understanding reduces the set of operators to two, but the Boolean system
    can be simplified still further.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种理解将操作符集减少到两个，但布尔系统还可以进一步简化。
- en: Convenience Is a Necessity
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 便利性是必需的
- en: 'Several additional operators are not crucial for implementing Boolean logic,
    but complement the existing set of operations. These additional operators, NAND
    and NOR, are true only when AND and OR respectively are false:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的操作符对于实现布尔逻辑不是必需的，但补充了现有的操作集。这些额外的操作符，即NAND和NOR，仅在AND和OR分别为假时才为真：
- en: '| NAND(a, b) ⇔ NOT AND(a, b) ⇔ OR(NOT a, NOT b) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| NAND(a, b) ⇔ NOT AND(a, b) ⇔ OR(NOT a, NOT b) |'
- en: '| NOR(a, b) ⇔ NOT OR(a, b) ⇔ AND(NOT a, NOT b) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| NOR(a, b) ⇔ NOT OR(a, b) ⇔ AND(NOT a, NOT b) |'
- en: These new functions are no more complex than AND and OR. Each has a four-state
    (four-row) truth table, and hence its value can determined with just as much effort.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新函数并不比 AND 和 OR 更复杂。每个都有四个状态（四行）的真值表，因此其值可以用同样的努力确定。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: NOR and NAND are not found in the basic set of operands because neither one
    corresponds to a commonly used, basic type of logical relation between sentences
    and has no atomic representation in the common language.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: NOR 和 NAND 都不在基本操作数集中，因为它们都不对应于句子之间常用的基本逻辑关系，也没有在通用语言中的原子表示。
- en: I have just introduced a set of new operators, derived from the existing set,
    that seem to offer nothing but a dubious convenience feature for those wanting
    to express more bizarre logic dependencies or problems using formal notation.
    What for?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚介绍了一套新运算符，这些运算符是从现有集合中派生出来的，似乎只为那些想要使用形式化符号表达更奇特逻辑依赖或问题的人提供了一种可疑的便利功能。这又是为了什么？
- en: The introduction of NAND or NOR alone makes it possible to get rid of AND, OR,
    and NOT altogether. This furthers our goal of simplicity and affords us the ability
    to describe the entire Boolean algebra system with fewer elements and operators.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仅引入 NAND 或 NOR 就可以完全消除 AND、OR 和 NOT。这进一步实现了我们的简化目标，并使我们能够用更少的元素和运算符来描述整个布尔代数系统。
- en: 'The importance of those negated auxiliary operators is that you can use any
    one of them to build a complete Boolean algebra system. In fact, you can construct
    all basic operators using NAND, as shown here (*T* stands for a true statement,
    and *F* stands for false^([[8](#ftn.CHP-2-FN-3)])). How? Well, quite obviously,
    the following pairs of statements are equivalent:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那些否定辅助运算符的重要性在于你可以使用它们中的任何一个来构建一个完整的布尔代数系统。实际上，你可以使用 NAND 构造所有基本运算符，如下所示（*T*
    代表一个真命题，*F* 代表一个假命题^([[8](#ftn.CHP-2-FN-3)]))。怎么做？很明显，以下成对的陈述是等价的：
- en: '| NOT a ⇔ NAND(*T*, a) |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| NOT a ⇔ NAND(*T*, a) |'
- en: '| AND(a, b) ⇔ NOT NAND(a, b) ⇔ NAND(*T*, NAND(a, b)) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| AND(a, b) ⇔ NOT NAND(a, b) ⇔ NAND(*T*, NAND(a, b)) |'
- en: '| OR(a, b) ⇔ NAND(NOT a, NOT b) ⇔ NAND(NAND(*T*, a), NAND(*T*, b)) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| OR(a, b) ⇔ NAND(NOT a, NOT b) ⇔ NAND(NAND(*T*, a), NAND(*T*, b)) |'
- en: or, if we prefer to rely exclusively on NOR, rather than NAND, we can say
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们更愿意只依赖 NOR 而不是 NAND，我们可以说
- en: '| NOT a ⇔ NOR(*F*, a) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| NOT a ⇔ NOR(*F*, a) |'
- en: '| OR(a, b) ⇔ NOT NOR(a, b) ⇔ NOR(*F*, NOR(a, b)) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| OR(a, b) ⇔ NOT NOR(a, b) ⇔ NOR(*F*, NOR(a, b)) |'
- en: '| AND(a, b) ⇔ NOR(NOT a, NOT b) ⇔ NOR(NOR(*F*, a), NOR(*F*, b)) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| AND(a, b) ⇔ NOR(NOT a, NOT b) ⇔ NOR(NOR(*F*, a), NOR(*F*, b)) |'
- en: Embracing the Complexity
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受复杂性
- en: 'It can be hard to believe that the essence of all computing can be captured
    within one of the universal logic operators. You can implement most complex algorithms,
    advanced computations, cutting-edge games, and Internet browsing using an array
    of simple circuits that involve one of the following truth tables, which convert
    input signals to output signals:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 很难相信所有计算的精髓都可以被包含在某个通用逻辑运算符中。你可以使用包含以下真值表的简单电路来实现大多数复杂算法、高级计算、尖端游戏和互联网浏览，这些真值表将输入信号转换为输出信号：
- en: '| NAND State Table |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| NAND 状态表 |'
- en: '| --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Operand 1 | Operand 2 | Result |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 1 | 操作数 2 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| FALSE | FALSE | TRUE |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | FALSE | TRUE |'
- en: '| FALSE | TRUE | TRUE |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | TRUE | TRUE |'
- en: '| TRUE | FALSE | TRUE |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | FALSE | TRUE |'
- en: '| TRUE | TRUE | FALSE |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | TRUE | FALSE |'
- en: '| NOR State Table |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| NOR 状态表 |'
- en: '| --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Operand 1 | Operand 2 | Result |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 操作数 1 | 操作数 2 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| FALSE | FALSE | TRUE |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | FALSE | TRUE |'
- en: '| FALSE | TRUE | FALSE |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| FALSE | TRUE | FALSE |'
- en: '| TRUE | FALSE | FALSE |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | FALSE | FALSE |'
- en: '| TRUE | TRUE | FALSE |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| TRUE | TRUE | FALSE |'
- en: It would seem we are going nowhere, though. . . . How come this trivial set
    of dependencies make it possible to build a device capable of solving complex
    problems, such as rejecting your credit application in a tactful manner? And what
    does a piece of theory based on the states “true” and “false” have in common with
    digital circuits?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们似乎没有进展。然而……为什么这个看似微不足道的依赖集使得构建一个能够解决复杂问题的设备成为可能，比如以得体的方式拒绝你的信用申请？基于“真”和“假”状态的这块理论又与数字电路有什么共同之处？
- en: '* * *'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[8](#CHP-2-FN-3)]) Purists may want to assume that *T* is equivalent to AND(a,
    a), for example, which is always true, and *F* is equivalent to NOT AND (a, a),
    which is always false. In other words, we do not introduce a new concept or equation
    element—we only simplify the notation a bit at this point.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[8](#CHP-2-FN-3)]) 纯粹主义者可能想要假设 *T* 等同于 AND(a, a)，例如，这始终为真，而 *F* 等同于 NOT AND
    (a, a)，这始终为假。换句话说，我们并没有引入新的概念或方程元素——我们只是在这一点上稍微简化了符号。
- en: Toward the Material World
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走向物质世界
- en: 'There is nothing complex about the mechanism devised by Boole: it calls for
    two opposite logic states, “true” and “false,” 0 and 1, “cyan” and “purple,” 999
    and 999 ½. The actual meaning, the physical representation, and the medium are
    irrelevant; what matters is the arbitrarily chosen convention that assigns certain
    states of the medium to a specific set of logic values.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔设计的机制并不复杂：它需要两种相反的逻辑状态，“真”和“假”，0和1，“青色”和“紫色”，999和999 ½。实际意义、物理表示和介质都是无关紧要的；重要的是任意选择的约定，将介质中的一些状态分配给特定的逻辑值集合。
- en: Computers as we know them use two different voltage levels in an electronic
    circuit and interpret them as values their designers refer to as 0 and 1\. These
    values, which are carried through the electric circuit, represent two digits in
    the binary system—but nothing is stopping a person from using just about any method
    to convey the data, from water flow, to chemical reactions, to smoke signals,
    to torques transmitted by a set of masterfully crafted wooden gears. The information
    remains the same, regardless of its carrier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所知道的计算机在电子电路中使用两种不同的电压水平，并将它们解释为设计师称为0和1的值。这些值通过电路传输，代表二进制系统中的两个数字——但没有任何阻止一个人使用几乎任何方法来传递数据的方法，从水流到化学反应，到烟雾信号，到由一组精心制作的木齿轮传递的扭矩。信息保持不变，无论其载体如何。
- en: The key to implementing Boolean logic in the physical world is simple, once
    we agree on the physical representation of logic values. Next, we need only find
    a way to arrange a set of components to manipulate those values in order to accommodate
    any task we want our computer to perform (but more about this later). First, let’s
    try to find out how to manipulate signals and implement real-world logic devices,
    commonly referred to as gates. Wooden gates, that is.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中实现布尔逻辑的关键很简单，一旦我们同意逻辑值的物理表示。接下来，我们只需要找到一种方法来安排一组组件，以操纵这些值以适应我们想要计算机执行的任务（但关于这一点稍后还会讨论）。首先，让我们尝试找出如何操纵信号和实现现实世界的逻辑设备，通常称为门。即木门。
- en: A Nonelectric Computer
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无电计算机
- en: Moving from a set of theoretical operations spawned by the world of pure mathematics
    to a device that can moderate water flow, torques, or electrical signals in a
    way that mimics one of the logic operators appears to be a difficult task—but
    it isn’t.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯数学世界产生的一组理论操作转移到可以调节水流、扭矩或电信号的设备，以模仿逻辑运算器之一的方式，这似乎是一项艰巨的任务——但实际上并非如此。
- en: '[Figure 2-1](ch02s04.html#mechanical_nor_gate_design "Figure 2-1. Mechanical
    NOR gate design") shows a trivial gear set mechanism that implements NOR functionality
    using torque-based logic. The “output” wheel at idle represents state 0; when
    a torque is applied to the wheel, its state is 1\. The device transmits torque
    from an external source to the output *only* if no torque is applied to two control
    “input” wheels. In theory, there is no need for an external source of energy,
    and the design could be simpler; in practice, however, friction and other problems
    would make it fairly difficult to build a more complex set of fully self-contained
    gates.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2-1](ch02s04.html#mechanical_nor_gate_design "图2-1. 机械NOR门设计")展示了使用扭矩逻辑实现NOR功能的简单齿轮组机制。在闲置状态下，“输出”齿轮代表状态0；当对齿轮施加扭矩时，其状态为1。该设备仅在外部源未对两个控制“输入”齿轮施加扭矩时将扭矩从外部源传输到输出。在理论上，不需要外部能源，设计可以更简单；然而，实际上，摩擦和其他问题会使构建更复杂的完全自包含门集相当困难。'
- en: '![Mechanical NOR gate design](httpatomoreillycomsourcenostarchimages1138004.png.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![机械NOR门设计](httpatomoreillycomsourcenostarchimages1138004.png.jpg)'
- en: Figure 2-1. Mechanical NOR gate design
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1. 机械NOR门设计
- en: Applying a torque to either or both of the inputs will pull out the tiny connector
    gear and make the “output” gear idle. When inputs go idle, a spring pulls the
    connector gear back to its position. The truth table for this device is exactly
    what NOR should be.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对输入之一或两个施加扭矩将拉出微小的连接齿轮，使“输出”齿轮闲置。当输入闲置时，弹簧将连接齿轮拉回其位置。该设备的真值表正是NOR应有的样子。
- en: As you will recall, NOR or NAND are all we need to implement any Boolean logic
    operator. Although adding the ability to implement other operators without recombining
    NAND and NOR gates would make our device smaller and more efficient, the device
    does not need this ability in order to work.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的那样，NOR或NAND都是我们实现任何布尔逻辑运算器所需的所有。尽管添加实现其他运算的能力而不需要重新组合NAND和NOR门会使我们的设备更小、更高效，但设备不需要这种能力才能工作。
- en: Assuming we skip the pesky detail of making all the gates work together in a
    way we are accustomed with, we can conclude that computers can be built with almost
    any technology.^([[9](#ftn.CHP-2-FN-4)])
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们跳过所有门一起以我们习惯的方式工作的繁琐细节，我们可以得出结论，计算机可以用几乎任何技术来构建.^([[9](#ftn.CHP-2-FN-4)])
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[9](#CHP-2-FN-4)]) And, needless to say, nonelectric computers are not a
    tall tale. Famous examples of such devices include Charles Babbage’s Analytical
    Engine, and technologies such as nanotechnology also hold some promise. See Ralph
    C. Merkle, “Two Types of Mechanical Reversible Logic,” *Nanotechnology* 4 (1993).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[9](#CHP-2-FN-4)]) 不言而喻，非电子计算机并非空穴来风。此类设备的著名例子包括查尔斯·巴贝奇的解析机，以及如纳米技术等技术也持有一些希望。参见Ralph
    C. Merkle，“两种机械可逆逻辑类型”，*纳米技术* 4 (1993)。
- en: A Marginally More Popular Computer Design
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种稍微更受欢迎的计算机设计
- en: Although the computer boom of the last several decades sprang from the ingenious
    transistor, our reliance on it is not associated with any magical value or unique
    quality. Quite simply, it is the most affordable, usable, and efficient design
    we have at the moment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管过去几十年计算机的繁荣源于巧妙的晶体管，但我们对其的依赖并非与任何神奇的价值或独特的品质相关联。简单来说，它目前是我们最经济、最易用和最高效的设计。
- en: Unlike the possibly far superior wooden gear machine, the electronic computers
    we use relay electrical signals using transistors, which are tiny devices that
    let a current flow in one direction between two of their nodes (connection points)
    when a voltage is applied to the third node. Transistors can be miniaturized quite
    efficiently, require little power, and are reliable and cheap.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与可能远优于木制齿轮机的电子计算机不同，我们使用的电子计算机使用晶体管传递电信号，晶体管是微小的设备，当在第三个节点（连接点）施加电压时，它们在两个节点之间允许电流单向流动。晶体管可以非常有效地小型化，功耗低，且可靠且便宜。
- en: Logic Gates
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑门
- en: The transistor is simple. In fact, it alone is too simple a device to implement
    any meaningful Boolean logic. Yet, when properly arranged in logic gates, transistors
    make it easy to perform all basic and supplementary Boolean algebra operations.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管很简单。实际上，它本身是一个非常简单的设备，无法实现任何有意义的布尔逻辑。然而，当在逻辑门中正确排列时，晶体管使得执行所有基本和补充布尔代数运算变得容易。
- en: The AND gate can be implemented by arranging two transistors serially, so that
    both must have low resistance (be “on”) before the voltage can flow to the output.
    Each transistor is controlled (activated) by a separate input line. The output
    is nominally “pulled down” using a resistor, so that it has the ground voltage
    0 (“false”), but will go up past 0 once both transistors switch on and allow a
    slight current flow.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: AND门可以通过串联两个晶体管来实现，这样电压才能流向输出，前提是两个晶体管都必须具有低电阻（“开启”）。每个晶体管由单独的输入线控制（激活）。输出通过一个电阻“拉低”，因此它具有地电压0（“假”），但一旦两个晶体管都开启并允许轻微的电流流动，输出就会超过0。
- en: The OR gate is implemented by setting up a parallel transistor so that it is
    sufficient for any of the transistors to enable in order for the output to be
    set to a nonzero voltage, signifying “truth.”
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: OR门通过设置一个并联晶体管来实现，这样只要任何一个晶体管被激活，输出就能被设定为非零电压，表示“真”。
- en: The last basic gate, NOT, is implemented using a single transistor and a resistor.
    “NOT” output is 1 in the idle state (pulled up through the resistor) and gets
    pulled down to 0 when the transistor opens.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个基本门，NOT门，使用一个晶体管和一个电阻来实现。“NOT”输出在空闲状态下为1（通过电阻拉高），当晶体管开启时被拉低到0。
- en: '[Figure 2-2](ch02s05.html#transistor-based_logic_gatesmconstructio "Figure 2-2. Transistor-based
    logic gates—construction and symbols") shows the three most basic transistor gate
    designs: AND, OR, and NOT.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-2](ch02s05.html#transistor-based_logic_gatesmconstructio "图2-2. 基于晶体管的逻辑门——构造和符号")展示了三种最基本的晶体管门设计：AND、OR和NOT。'
- en: '![Transistor-based logic gates—construction and symbols](httpatomoreillycomsourcenostarchimages1138006.png.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![基于晶体管的逻辑门——构造和符号](httpatomoreillycomsourcenostarchimages1138006.png.jpg)'
- en: Figure 2-2. Transistor-based logic gates—construction and symbols
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2. 基于晶体管的逻辑门——构造和符号
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: You might notice that both AND and OR gates can be turned into NAND and NOR
    without introducing additional components. It is sufficient to use a design observed
    on the schematics for a NOT gate—that is, by moving the resistor and “output point”
    toward the supply voltage, thus reverting the output logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，AND门和OR门都可以通过不引入额外组件的方式转换为NAND和NOR。这只需要使用NOT门电路图上观察到的设计——即通过将电阻和“输出点”移向电源电压，从而反转输出逻辑。
- en: We have now reached a point where we can combine transistors to implement one
    of the universal gates, but regardless of how many gates we can build, it is still
    quite far from real computing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了可以组合晶体管以实现一个通用门之一的时候了，但无论我们可以构建多少个门，这仍然离真正的计算相当远。
- en: The preceding discussion is all well and good, but what makes Boolean logic
    more than a powerful tool for solving puzzles about Bob’s diet?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论都很好，但是什么让布尔逻辑不仅仅是一个解决关于鲍勃饮食谜题的强大工具？
- en: From Logic Operators to Calculations
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从逻辑运算符到计算
- en: Combining trivial Boolean logic operations can lead to a number of surprising
    capabilities, such as the ability to perform arithmetic operations on binary representations
    of numbers. This is where things get interesting.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 组合简单的布尔逻辑运算可以带来许多令人惊讶的能力，例如在数字的二进制表示上执行算术运算。这就是事情变得有趣的地方。
- en: A set of XOR and AND gates, for example, can be used to increase an input number
    by 1, and this is the first step on our way toward addition. [Figure 2-3](ch02s06.html#trivial_increase-by-one_circuit
    "Figure 2-3. Trivial increase-by-one circuit") shows a design for a counter, based
    on this concept.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一组XOR和AND门，例如，可以用来增加输入数字1，这是我们走向加法的第一步。[图2-3](ch02s06.html#trivial_increase-by-one_circuit
    "图2-3. 简单的加一电路")展示了基于这个概念的设计。
- en: 'Ah, a new term! XOR is yet another “convenient” Boolean logic operator that
    is true only when one of its operands is true. In this regard, it is closer to
    the usual meaning of “or” in English. XOR is often used to simplify notation,
    but otherwise easy to implement by other means, by recombining AND, NOT, and OR.
    It is defined this way:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，一个新术语！XOR是另一个“方便”的布尔逻辑运算符，只有当其操作数之一为真时才为真。在这方面，它更接近英语中“或”的通常含义。XOR通常用于简化符号，但通常可以通过重新组合AND、NOT和OR来实现，其他方法也容易实现。它被定义为以下方式：
- en: '| XOR(a, b) ⇔ AND(OR(a, b), NOT AND(a, b)) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| XOR(a, b) ⇔ AND(OR(a, b), NOT AND(a, b)) |'
- en: Back to the circuit of ours . . . what can it do? The device shown in [Figure 2-3](ch02s06.html#trivial_increase-by-one_circuit
    "Figure 2-3. Trivial increase-by-one circuit") is fed with a number written in
    binary. In this example, that num-ber is limited to three bits, although this
    design could easily be extended to allow for a larger number of inputs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的电路……它能做什么？[图2-3](ch02s06.html#trivial_increase-by-one_circuit "图2-3. 简单的加一电路")中展示的设备用二进制数供电。在这个例子中，这个数字限制在三个位上，尽管这个设计可以很容易地扩展以允许更多的输入。
- en: '![Trivial increase-by-one circuit](httpatomoreillycomsourcenostarchimages1138008.png.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![简单的加一电路](httpatomoreillycomsourcenostarchimages1138008.png.jpg)'
- en: Figure 2-3. Trivial increase-by-one circuit
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3. 简单的加一电路
- en: This simple computation device works the way humans add decimal numbers on a
    piece of paper—working from right to left, eventually carrying a value to the
    next column. The only real difference is that it uses binary.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的计算设备的工作方式与人类在一张纸上加十进制数字的方式相同——从右到左工作，最终将一个值带到下一列。唯一的真正区别是它使用二进制。
- en: Let’s see how that would happen. We have a binary number written in a line.
    We want to increase it by one; we start at the rightmost digit, the way we would
    do with decimal addition.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看会发生什么。我们有一行写着的二进制数。我们想要增加它1；我们从最右边的数字开始，就像我们做十进制加法一样。
- en: 'We have a binary digit there; when increasing a binary digit by 1, only two
    outcomes are possible: if the input digit is 0, the output is 1 (0 + 1 = 1); otherwise,
    the output is 0, and we need to carry 1 to the next column (1 + 1 = 10). In other
    words, we do two things: we produce an output that is a negation of the input
    (1 for 0, 0 for 1), and, if the input digit is 1, we must keep that in mind and
    include it later.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里有一个二进制位；当增加一个二进制位时，只有两种可能的结果：如果输入位是0，输出是1（0 + 1 = 1）；否则，输出是0，并且我们需要将1带到下一列（1
    + 1 = 10）。换句话说，我们做了两件事：我们产生一个输出，它是输入的否定（0对应1，1对应0），并且，如果输入位是1，我们必须记住这一点并在稍后包含它。
- en: 'The circuit does just that: for the first input, I[0.] The topmost gate processes
    the input by negating it and supplying it on output O[0] and also feeds the input
    value itself to the gates that are responsible for handling the next column (O[1]).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 电路正是这样做的：对于第一个输入，I[0.] 顶部的门通过否定输入并将其提供给输出O[0]，同时也将输入值本身提供给负责处理下一列的门（O[1]）。
- en: '| O[0] = NOT I[0] |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| O[0] = NOT I[0] |'
- en: '| C[0] = I[0] |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| C[0] = I[0] |'
- en: 'Well, we have increased the number by one; there is nothing else for us to
    do in the remaining columns if there is no carry from the previous one. If there
    is no carry, O[1] should mirror I[1]. If there is a carry value, however, we need
    to treat the case the same way we handled adding 1 to the previous column: negate
    the output and carry a value to the next column if applicable.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经将数字增加了一；如果没有来自前一位的进位，我们就没有其他事情可做在剩余的列中。如果没有进位，O[1]应该与I[1]相同。然而，如果有进位值，我们需要以相同的方式处理这种情况，就像我们处理向上一列加1一样：否定输出，并在适用的情况下将进位值传递到下一列。
- en: 'From now on, every subsequent output (O[n] for n > 0) will be either copied
    directly from I[n] if there is no bit carried over from the previous column or
    increased by 1 (which, again, boils down to negation) due to addition of a carry
    bit. And so, if I[n] is 1, the carry from this column, C[n], will also be 1, and
    O[n] will be 0 (because, in binary, 1 + 1 is 10). As you might notice, the actual
    output at position *n* is simply a result of XOR of the input value at position
    *n*, and the carry bit from column *n*−1\. Hence, the circuit generates O[n] by
    XORing the bit carried from C[n−1] with the value of I[n] and then ANDing the
    carry from O[n−1] with I[n] to determine if there should be a carry to the next
    column:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每个后续的输出（对于n > 0的O[n]）将直接从I[n]复制，如果没有从前一列传递过来的位，或者由于进位位的增加而增加1（这再次归结为否定）。因此，如果I[n]是1，这一列的进位C[n]也将是1，O[n]将是0（因为在二进制中，1
    + 1是10）。你可能已经注意到，位置*n*的实际输出仅仅是位置*n*的输入值和来自列*n*−1的进位位的异或的结果。因此，电路通过将C[n−1]携带的位与I[n]的值进行异或，然后通过将O[n−1]的进位与I[n]进行与操作来确定是否应该向下一列传递进位来生成O[n]：
- en: '| O[n] = XOR(I[n], C[n−1]) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| O[n] = XOR(I[n], C[n−1]) |'
- en: '| C[n] = AND (I[n], C[n−1]) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| C[n] = AND (I[n], C[n−1]) |'
- en: 'Consider the following example. We want to increase an input value, 3 (011
    in binary), by 1\. Inputs are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。我们想要将一个输入值，3（二进制中的011），增加1。输入如下：
- en: '| I[0] = 1 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| I[0] = 1 |'
- en: '| I[1] = 1 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| I[1] = 1 |'
- en: '| I[2] = 0 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| I[2] = 0 |'
- en: The circuit produces O[0] by negating I[0]; hence O[0] = 0\. Because I[0] was
    nonzero, there is also a carry passed to the next column. In the next column,
    the XOR gate sets O[1] to 0, because, even though I[1] was 1, there was a carry
    value from the previous column (1 + 1 = 10). Again, there is a carry to the next
    column.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 电路通过否定I[0]来产生O[0]，因此O[0] = 0。因为I[0]不为零，所以也有一个进位传递到下一列。在下一列，XOR门将O[1]设置为0，因为尽管I[1]是1，但前一个列有一个进位值（1
    + 1 = 10）。同样，也有一个进位传递到下一列。
- en: 'In yet another column, I[2] = 0, but the AND gate indicates a carry value from
    the previous row, because two previous inputs were both set to 1\. Hence, the
    output is 1\. There will be no carry to the last column. The output is:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一列中，I[2] = 0，但AND门指示前一行有一个进位值，因为前两个输入都设置为1。因此，输出是1。最后一列不会有进位。输出如下：
- en: '| O[0] = 0 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| O[0] = 0 |'
- en: '| O[1] = 0 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| O[1] = 0 |'
- en: '| O[2] = 1 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| O[2] = 1 |'
- en: '| O[0] = 0 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| O[0] = 0 |'
- en: '| . . . or 0100, which, quite incidentally, is 4 when converted to decimal
    numbers. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '...或者0100，这偶然地，当转换为十进制数时是4。'
- en: And voilà—that’s +1, written in binary.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦——这就是+1，用二进制表示。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: We have just expressed the first computing problem in terms of Boolean algebra.
    You might be tempted to extend the design to be able to sum two arbitrary numbers,
    rather than just one number and the number 1\. Nonetheless, this basic circuitry
    is much where computing starts and ends.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用布尔代数表达了这个第一个计算问题。你可能想扩展设计，使其能够对两个任意数进行求和，而不仅仅是求一个数和1的和。然而，这个基本的电路是计算开始和结束的地方。
- en: Digital arithmetic circuitry works by running certain input data through an
    array of cleverly arranged logic gates that, in turn, add, subtract, multiply,
    or perform other trivial modifications on an array of bits. Little magic is involved.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数字算术电路通过将某些输入数据通过一系列巧妙排列的逻辑门来运行，这些逻辑门随后对一系列位进行加、减、乘或其他简单的修改。其中涉及到的魔法很少。
- en: 'So far, I have explained the ability of silicon chips or crafted wood to perform
    certain fixed, basic operations such as integer arithmetics. Yet, something is
    missing from this picture: computers do not come with text editors, games, and
    peer-to-peer software hard-coded in a painstakingly complex array of gates inside
    the CPU. Where is the software kept?'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经解释了硅芯片或手工制作的木材执行某些固定、基本操作的能力，例如整数算术。然而，这幅画面中缺少了某些东西：计算机并没有在CPU内部一个复杂而费力的门阵列中硬编码文本编辑器、游戏和对等软件。软件在哪里？
- en: From Electronic Egg Timer to Computer
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从电子计时器到计算机
- en: The true value of a computer lies in its ability to be programmed to act in
    a specific way—to execute a sequence of software commands according to some plan.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的真正价值在于其能够被编程以特定方式行动——根据某个计划执行一系列软件命令。
- en: '[Figure 2-4](ch02s07.html#flip-flop_memory_with_a_practical_interf "Figure 2-4. Flip-flop
    memory with a practical interface") illustrates the next step on our way toward
    developing a flexible machine that can do more than just a single, hard-wired
    task: data storage and memory. In this figure, we see a type of memory storage
    unit known as a *flip-flop design*. This memory cell has two control lines, “set”
    and “reset.” When both are down, the gate maintains its current state, thanks
    to a feedback connection between its input and output to the OR gate. Previous
    output from OR is passed through an AND gate because its other line is set to
    1 (negated “reset”), and through OR once again, because its other input is 0 (“set”).
    The state of the output is sustained for as long as the gates are powered.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-4](ch02s07.html#flip-flop_memory_with_a_practical_interf "图2-4. 具有实用接口的触发器内存")展示了我们朝着开发一种能够执行更多任务（而不仅仅是单一、硬连线任务）的灵活机器的下一步：数据存储和内存。在这张图中，我们看到一种称为*触发器设计*的内存存储单元。这个内存单元有两个控制线，“设置”和“复位”。当两者都为低电平时，门通过其输入和输出到或门的反馈连接保持其当前状态。来自或门的先前输出通过一个与门，因为它的另一条线被设置为1（否定“复位”），然后再次通过或门，因为它的另一个输入是0（“设置”）。输出状态保持，直到门有电。'
- en: '![Flip-flop memory with a practical interface](httpatomoreillycomsourcenostarchimages1138010.png.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![具有实用接口的触发器内存](httpatomoreillycomsourcenostarchimages1138010.png.jpg)'
- en: Figure 2-4. Flip-flop memory with a practical interface
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4. 具有实用接口的触发器内存
- en: When “set” goes high, the OR gate is forced to output 1 and will retain this
    value when “set” goes back down. When “reset” line goes high, the AND gate is
    forced to output 0 and break the feedback loop, thus forcing the circuit to output
    0\. Once “reset” goes down, the output remains 0\. When both control lines are
    up, the circuit becomes unstable—something not quite pretty, especially when the
    computer in question is mechanical.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当“设置”信号变为高电平时，或门被迫输出1，并且当“设置”信号变回低电平时，它将保持这个值。当“复位”线变为高电平时，与门被迫输出0并打破反馈回路，从而迫使电路输出0。一旦“复位”信号变回低电平，输出保持为0。当两个控制线都为高电平时，电路变得不稳定——这在机械计算机中尤其不美观。
- en: 'The truth table for this design is as follows (*V* denotes an arbitrary logic
    value):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计的真值表如下（*V*表示任意逻辑值）：
- en: '| Flip-Flop Truth Table |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 触发器真值表 |'
- en: '| --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Set | Reset | Q[t-1] | Q[t] |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 设置 | 复位 | Q[t-1] | Q[t] |'
- en: '| --- | --- | --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | *V* | *V* |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | *V* | *V* |'
- en: '| 1 | 0 | - | 1 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | - | 1 |'
- en: '| 0 | 1 | - | 0 |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | - | 0 |'
- en: '| 1 | 1 | - | unstable |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | - | 不稳定 |'
- en: A more practical variant of a flip-flop circuit, which incorporates an “update
    interface” (see [Figure 2-4](ch02s07.html#flip-flop_memory_with_a_practical_interf
    "Figure 2-4. Flip-flop memory with a practical interface")), uses two AND gates
    and one NOT gate so that the state of an input line is captured (sampled and held)
    whenever an external “strobe” control signal occurs. This design eliminates unstable
    combinations of inputs and makes this sort of memory easier to use for storing
    information.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器电路的一个更实用的变体，它包含一个“更新接口”（见[图2-4](ch02s07.html#flip-flop_memory_with_a_practical_interf
    "图2-4. 具有实用接口的触发器内存"))，使用两个与门和一个非门，以便在发生外部“触发”控制信号时捕获输入线的状态（采样并保持）。这种设计消除了不稳定的输入组合，使得这种类型的内存更容易用于存储信息。
- en: '| Improved Flip-Flop Truth Table |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 改进的触发器真值表 |'
- en: '| --- |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Input | Strobe | Q[t-1] | Q[t] |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 触发 | Q[t-1] | Q[t] |'
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| - | 0 | *V* | *V* |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| - | 0 | *V* | *V* |'
- en: '| *S* | 1 | - | *S* |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| *S* | 1 | - | *S* |'
- en: 'This trivial gate configuration exhibits an important property: it can store
    data. A single cell can store only a single bit, but combining a number of flip-flops
    can extend the storage capacity. Although today’s memory designs vary, the significance
    of this functionality remains the same: it allows programs to execute. But how?'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的门配置表现出一个重要的特性：它可以存储数据。单个单元只能存储一个比特，但通过组合多个触发器可以扩展存储容量。尽管今天的内存设计各不相同，但这一功能的重要性仍然相同：它允许程序执行。但这是如何实现的呢？
- en: In the basic design, the chip stores a special value, usually called the *instruction
    pointer*, in an internal on-chip memory latch (register) consisting of several
    flip-flops. Because popular computers work synchronously, with all processes timed
    by a clock signal generator working at a high frequency, the pointer selects a
    memory cell from the main memory on every clock cycle. The control data retrieved
    this way then selects and activates the appropriate arithmetic circuit to process
    the input data.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本设计中，芯片在内部芯片内存锁存器（寄存器）中存储一个特殊值，通常称为*指令指针*，该锁存器由几个触发器组成。由于流行的计算机是同步工作的，所有进程都由一个高频时钟信号发生器计时，因此指针在每个时钟周期从主存储器中选择一个内存单元格。通过这种方式检索的控制数据然后选择并激活适当的算术电路来处理输入数据。
- en: For some control data, our hypothetical chip performs addition; for others,
    it gets involved in an input-output operation. After fetching each piece of control
    data (every machine instruction), the chip has to advance its internal instruction
    pointer so that it will be prepared to read the next command in the next cycle.
    Thanks to this functionality, we can use the chip to execute a sequence of machine
    instructions, or a program.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些控制数据，我们的假设芯片执行加法；对于其他数据，它涉及到输入输出操作。在获取每一块控制数据（每条机器指令）之后，芯片必须前进其内部指令指针，以便在下个周期准备好读取下一条命令。多亏了这种功能，我们可以使用芯片来执行一系列机器指令，或者一个程序。
- en: It is now time to find out which operations the chip has to implement in order
    for it to be usable.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候找出芯片必须实现哪些操作才能使其可用的了。
- en: Turing and Instruction Set Complexity
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图灵与指令集复杂性
- en: As it turns out, the processor does not have to be complex. In fact, the set
    of instructions required for a chip to be able to execute just about any task
    is surprisingly small. The Church-Turing thesis states that every real-world computation
    can be carried out by a Turing machine, which is a primitive model of a computer.
    The Turing machine, named after its inventor, is a trivial device that operates
    on a potentially infinite tape consisting of single cells, a hypothetical, purely
    abstract storage medium. Each cell can store a single character from a machine
    “alphabet,” which is simply a name for a finite ordered set of possible values.
    (This alphabet has absolutely nothing to do with human alphabets; it was named
    this way to promote a healthy dose of confusion among the laity.)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，处理器并不需要复杂。实际上，一个芯片能够执行几乎所有任务的指令集非常小。图灵-丘奇定理指出，每个现实世界的计算都可以通过图灵机来完成，图灵机是计算机的原始模型。图灵机以发明者的名字命名，是一种简单的设备，它在一个可能无限长的由单个单元格组成的磁带上操作，这是一种假设的、纯粹抽象的存储介质。每个单元格可以存储机器“字母表”中的一个字符，这个“字母表”只是对可能的有限有序值集合的命名。（这个字母表与人类字母表毫无关系；这样命名是为了在门外汉中引起一些混乱。）
- en: The device is also equipped with an internal register that can hold a finite
    number of equally internal states. A Turing machine starts at a certain position
    on the tape, in a given state, and then reads a character from a cell on the tape.
    Every automaton has an associated set of transition patterns that describe how
    to modify its internal state, what to store on the tape based on the situation
    after the read, and how to (optionally) move the tape either way by one cell.
    Such a set of transitions defines the rules for calculating the system’s next
    state based on its current characteristics. These rules are often documented using
    a *state transition table* like this.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备还配备了一个内部寄存器，可以存储有限数量的内部状态。图灵机从磁带上的某个位置开始，处于给定状态，然后从磁带上的一个单元格中读取一个字符。每个自动机都有一个与之相关的转换模式集合，描述了如何修改其内部状态，根据读取后的情况在磁带上存储什么，以及如何（可选地）将磁带向一个方向移动一个单元格。这样一组转换定义了基于系统当前特性的计算系统下一个状态的规则。这些规则通常使用像这样的*状态转换表*来记录。
- en: '| State Transition Table |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 状态转换表 |'
- en: '| --- |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Current State | New State/Action |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 当前状态 | 新状态/动作 |'
- en: '| --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| C[t] | S[t] | C[t+1] | S[t+1] | MOVE |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| C[t] | S[t] | C[t+1] | S[t+1] | MOVE |'
- en: '| 0 | S0 | 1 | S1 | - |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 0 | S0 | 1 | S1 | - |'
- en: '| 1 | S0 | 0 | S0 | LEFT |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 1 | S0 | 0 | S0 | LEFT |'
- en: The table tells us that, if the current value of a cell under which the machine
    is currently positioned is 0, and the machine’s internal state at that moment
    is S0, the device will alter the state of C to 1, will alter its internal state
    to S1, and will not move the reading head.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 表格告诉我们，如果机器当前位于其下的单元格的当前值是0，并且机器在那个时刻的内部状态是S0，设备将改变C的状态为1，将内部状态改变为S1，并且不会移动读取头。
- en: '[Figure 2-5](ch02s08.html#sample_turing_machine_execution_stages "Figure 2-5. Sample
    Turing machine execution stages") shows an example of a Turing machine positioned
    at cell C with internal state S.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-5](ch02s08.html#sample_turing_machine_execution_stages "图2-5. 样例图灵机执行阶段")展示了图灵机位于单元格C并处于内部状态S的示例。'
- en: '![Sample Turing machine execution stages](httpatomoreillycomsourcenostarchimages1138012.png.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![样例图灵机执行阶段](httpatomoreillycomsourcenostarchimages1138012.png.jpg)'
- en: Figure 2-5. Sample Turing machine execution stages
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5. 样例图灵机执行阶段
- en: 'Let’s walk through this. As you can see in [Figure 2-5](ch02s08.html#sample_turing_machine_execution_stages
    "Figure 2-5. Sample Turing machine execution stages"), the machine uses an alphabet
    of two characters, 0 and 1, and has two internal states, S0 and S1\. It starts
    with S0\. (Starting conditions can be defined arbitrarily; I chose to start it
    there for no particular reason.) When positioned at the end (the least significant
    bit) of a binary number stored on the tape (C[0]), the machine follows this logic:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来看。正如你在[图2-5](ch02s08.html#sample_turing_machine_execution_stages "图2-5.
    样例图灵机执行阶段")中可以看到的，机器使用两个字符的字母表，0和1，并且有两个内部状态，S0和S1。它从S0开始。（起始条件可以任意定义；我选择在那里开始没有任何特别的原因。）当位于磁带上存储的二进制数（C[0]）的末尾（最低有效位）时，机器遵循以下逻辑：
- en: If the character under the machine head is 0, it is changed to 1, and the state
    of the machine is changed to S1, according to the first transition rule documented
    in the table preceding. Because there is no transition rule from S1, the machine
    stops in the next cycle.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果机器头下方的字符是0，它将变为1，根据表格中记录的第一个转换规则，机器的状态将变为S1。因为没有从S1到其他状态的转换规则，机器将在下一个周期停止。
- en: If the character read from beneath the head is 1, it changes to 0, and the state
    remains the same. The machine also moves the reading head on the tape to the left,
    per the second transition rule. The entire process then repeats, starting at the
    new location, because the machine remains in its current state, for which further
    transition rules are defined.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从头部下方读取的字符是1，它将变为0，状态保持不变。根据第二个转换规则，机器还将读取头在磁带上向左移动。整个过程然后从新位置开始重复，因为机器仍然处于当前状态，对于该状态，定义了进一步的转换规则。
- en: Functionality, at Last
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性，终于实现了
- en: 'Although this may come as a surprise, this particular machine is actually useful
    and implements a task that can be of more than theoretical value: it performs
    basic arithmetic. It does precisely the same thing as our increase-by-one circuit
    discussed earlier in this chapter. In fact, it implements the same algorithm:
    bits on the tape, starting at the rightmost position, are inverted until after
    0 is encountered (and also inverted).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能会让人惊讶，但这台特定的机器实际上是有用的，并实现了具有超过理论价值的任务：它执行基本的算术。它与我们本章前面讨论的增加电路做完全相同的事情。事实上，它实现了相同的算法：磁带上从最右边位置开始的位被反转，直到遇到0（也被反转）。
- en: This is, naturally, just the tip of the iceberg. A proper Turing machine can
    implement any algorithm ever conceived. The only problem is that every algorithm
    requires the implementation of a separate set of transition rules and internal
    states; in other words, we need to build a new Turing machine for every new task,
    which is not quite practical in the long run.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是冰山一角。一个合适的图灵机可以实施任何曾经构思过的算法。唯一的问题是每个算法都需要实施一组单独的转换规则和内部状态；换句话说，我们需要为每个新任务构建一个新的图灵机，这在长期来看并不十分实用。
- en: Thankfully, a special type of such a machine, a Universal Turing Machine (UTM),
    has an instruction set that is advanced enough to implement all specific Turing
    machines and to execute any algorithm without the need to alter the transition
    table.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种特殊类型的机器，即通用图灵机（UTM），具有足够先进的指令集，可以实施所有特定的图灵机并执行任何算法，而无需更改转换表。
- en: This über-machine is neither particularly abstract nor complex. Its existence
    is guaranteed because a specific Turing machine can be devised to perform any
    finite algorithm (according to the aforementioned Church-Turing thesis). Because
    the method for “running” a Turing machine is itself a finite algorithm, a machine
    can be devised to execute it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这台超级机器既不特别抽象，也不复杂。它的存在是有保证的，因为可以设计一个特定的图灵机来执行任何有限算法（根据上述丘奇-图灵论题）。因为“运行”图灵机的方法本身就是一个有限算法，所以可以设计一个机器来执行它。
- en: As to the complexity of this machine, a one-bit, two-element alphabet machine
    (the smallest UTM devised) requires 22 internal states and instructions describing
    state transitions, in order to execute algorithms on a sequential infinite memory
    tape.^([[52](apb.html#ftn.CHP-2-BIB-1)]) That’s not that big a deal.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 至于这台机器的复杂性，一个单比特、两个元素的字母表机器（设计出的最小通用图灵机）需要22个内部状态和描述状态转换的指令，以便在顺序无限内存带上执行算法。[^([52](apb.html#ftn.CHP-2-BIB-1))]
    这并不是什么大问题。
- en: 'Holy Grail: The Programmable Computer'
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圣杯：可编程计算机
- en: The Turing machine is also far more than just a hypothetical abstract device
    that mathematicians use to entertain themselves. It is a construct that begs to
    be implemented using a specially designed, Boolean, logic-based electronic (or
    mechanical) device and perhaps extended to make it far more useful, which brings
    us one step closer to useful computing. The only problem is that the prerequisite
    for an infinitely long input tape cannot be satisfied in the real world. Nevertheless,
    we can provide plenty of it, making such a hardware Turing machine quite usable
    for most of our everyday problems. Enter the universal computer.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机也远不止是数学家用来娱乐自己的假设性抽象设备。这是一个需要用专门设计的、基于布尔逻辑的电子（或机械）设备实现的构造，也许可以扩展使其更加有用，这使我们离实用计算更近一步。唯一的问题是，在现实世界中无法满足无限长输入带的前提条件。尽管如此，我们可以提供大量的输入带，使得这样的硬件图灵机对于我们的大多数日常问题来说非常实用。通用计算机的时代到来了。
- en: Real computers, of course, go far beyond the sequential access single-bit memory,
    thus significantly reducing the set of instructions required to achieve Turing
    completeness. A UTM with an alphabet of 18 characters requires only two internal
    states in order to work. Real computers, on the other hand, usually operate on
    an “alphabet” of at least 4,294,967,296 characters (32 bits), and often far more,
    which allows for nonsequential memory access and for the use of a large number
    of registers with an astronomical number of possible internal states.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，真正的计算机远远超出了顺序访问单比特内存，从而显著减少了实现图灵完备性所需的指令集。一个具有18个字符的字母表通用图灵机只需要两个内部状态才能工作。另一方面，真正的计算机通常在一个至少有4,294,967,296个字符（32位）的“字母表”上运行，通常更多，这允许非顺序内存访问和使用大量具有天文数字般可能内部状态的寄存器。
- en: In the end, the UTM model proves and everyday practice confirms that it is possible
    to build a flexible, programmable processing unit using only a handful of features,
    composed of two or three internal registers (instruction pointer, data read/write
    pointer, and perhaps an accumulator) and a small set of instructions. It is perfectly
    feasible to assemble such a device with just hundreds of logic gates, even though
    today’s designs may use many more.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通用图灵机模型证明了，日常实践也证实了，仅使用少量特性（由两个或三个内部寄存器组成，如指令指针、数据读写指针，可能还有一个累加器）和一小套指令，就可以构建一个灵活、可编程的处理单元。仅用几百个逻辑门就能组装这样的设备，尽管今天的设计可能需要更多。
- en: As you can see, the notion of building a computer from scratch is not so absurd—even
    a wooden one.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从头开始构建计算机的想法并不那么荒谬——即使是木制的。
- en: Advancement through Simplicity
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单化进步
- en: Coming up with such an unimpressive set of instructions is, of course, not going
    to make the device fast or easy to program. Universal Turing Machines can do just
    about everything (in many cases, by virtue of their simplicity), but they are
    painfully slow and difficult to program, to a degree that even implementing machine-assisted
    translation from more human-readable languages to machine code is difficult, at
    least without driving the programmer clinically insane.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，提出这样一套不起眼的指令集并不会使设备变得快速或易于编程。通用图灵机几乎可以做任何事情（在很多情况下，得益于它们的简单性），但它们运行缓慢且难以编程，到了甚至实现从更易读的语言到机器码的机器辅助翻译都变得困难，至少在没有让程序员临床性疯狂的情况下。
- en: Architectures or languages that come too close to implementing bare-bones Turing
    completeness are often referred to as *Turing tarpits*. This means that, while
    it is theoretically possible to carry out just about any task with their help,
    in practice, it is barely feasible, too time-consuming, and too burdensome to
    actually try. Even simpler tasks such as integer multiplication or moving the
    contents of memory can take forever to set up, and twice as long to execute. The
    less effort and time required to complete simple and repetitive tasks, and the
    fewer the tasks that have to be accomplished by software using a number of separate
    instructions, the better.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接近实现裸骨Turing完整性的架构或语言通常被称为*图灵陷阱*。这意味着，虽然理论上使用它们可以完成几乎所有任务，但在实践中，这几乎是不可能的，也太耗时、太费力。即使是像整数乘法或移动内存内容这样简单的任务，设置起来可能需要很长时间，执行起来可能需要两倍的时间。完成简单和重复性任务所需的时间和精力越少，以及软件使用多个指令完成的任务越少，就越好。
- en: One popular way to improve the functionality and performance of a processing
    unit is to implement certain common tasks in the hardware that would be quite
    annoying to perform in software. These tasks are implemented using an array of
    specialized circuits (and include multiplication and home-loan-rejection processing),
    thus adding convenient extensions to the architecture and enabling the faster
    and saner deployment of programs, while still enabling the system to execute those
    functions in a programmed, flexible order.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 提高处理单元的功能性和性能的一种流行方法是在硬件中实现某些常见任务，这些任务在软件中执行可能会相当麻烦。这些任务通过使用一系列专用电路来实现（包括乘法和房屋贷款拒绝处理），从而为架构添加方便的扩展，并使程序的部署更快、更合理，同时仍然允许系统以编程和灵活的顺序执行这些功能。
- en: Surprisingly, beyond the few initial steps, it is not always desirable when
    designing a processor to linearly increase the complexity of the circuitry in
    order to make processors achieve higher speeds, be more energy efficient, and
    provide a better feature set. You can, of course, build a large number of circuits
    to handle just about any frequently used complex operation imaginable. However,
    this won’t be practical until the architecture is truly mature, and your budget
    allows you to invest additional effort and resources in making a chip. Although
    programs on such a platform indeed require less time to execute and are easier
    to write, the device itself is far more difficult to build, requires more power,
    and could become too bulky or expensive for routine use. Complex algorithms such
    as division or floating-point operations require an insanely large array of usually
    idle gates to complete such a task in a single step.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在设计处理器时，除了最初的几个步骤之外，并不总是希望线性增加电路的复杂性，以使处理器达到更高的速度、更高的能效和更好的功能集。当然，你可以构建大量的电路来处理几乎所有可以想象到的常用复杂操作。然而，除非架构真正成熟，并且你的预算允许你投入额外的努力和资源来制造芯片，否则这并不实用。在这样的平台上运行的程序确实需要更少的时间来执行，并且编写起来更容易，但设备本身构建起来更困难，需要更多的电力，并且可能因为体积过大或价格过高而不适合常规使用。像除法或浮点运算这样的复杂算法需要大量的通常处于闲置状态的门，才能在单步中完成这样的任务。
- en: Split the Task
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解任务
- en: Rather than following this expensive and possibly naive path of building blocks
    to carry out entire instructions at once, it is best to abandon the single-cycle
    execution model until you have a working design and plenty of time to improve
    it. A better way to achieve complex functionality in hardware is to hack the job
    into tiny bits and execute advanced tasks in a number of cycles.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，在拥有工作设计和大量时间来改进它之前，最好是放弃单周期执行模型。在硬件中实现复杂功能的一个更好的方法是将其分解成微小的部分，并在多个周期中执行高级任务。
- en: In such a multicycle design, the processor goes through a number of internal
    stages, much like the add-one Turing machine example. It runs the data through
    simple circuits in the right order, thus implementing a more complex functionality
    step by step, which relies on more basic components. Rather than use a complex
    device to do all the math at once, it might use a circuit to multiply subsequent
    bits of 32-bit integers and track carry values and then produce a final result
    in the 33rd cycle. Or, it could perform certain independent, preparation tasks
    that precede the actual operation. This would free us from having to design dozens
    of circuits for every variant of an opcode, depending on where it should get its
    operands or store results.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的多周期设计中，处理器会经过多个内部阶段，就像加一图灵机示例一样。它按照正确的顺序运行数据通过简单的电路，从而逐步实现更复杂的功能，这依赖于更基本的组件。而不是使用一个复杂的设备一次性完成所有数学运算，它可能使用一个电路来乘以32位整数的后续位，跟踪进位值，然后在第33个周期产生最终结果。或者，它还可以执行某些独立的、准备性的任务，这些任务在实际操作之前进行。这将使我们免于为每个操作码变体设计数十个电路，取决于它应该从哪里获取操作数或存储结果。
- en: 'The added benefit of this approach is that it enables more efficient hardware
    resource management: for trivial operands; a variable-complexity algorithm can
    complete sooner, taking only as many cycles as absolutely necessary. For example,
    division by 1 is likely to require less time than division by 187,371.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的额外好处是它使得硬件资源管理更加高效：对于简单的操作数；一个可变复杂性的算法可以更快完成，只需要绝对必要的周期数。例如，除以1可能比除以187,371所需时间更少。
- en: A simple, cheap circuit, with maximum usage and a variable execution time could
    quite easily be more cost efficient than a complex and power-consuming one with
    a constant execution time. Although some of today’s processors have attempted
    to use a fixed number of cycles to complete more and more tasks, virtually all
    began as multicycle architectures. Even for these big boys, the model seldom remains
    truly single cycle, as you’ll see in a moment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单、便宜、使用率最高且执行时间可变的电路，可能比一个复杂且耗电的、具有恒定执行时间的电路更经济高效。尽管一些今天的处理器试图使用固定数量的周期来完成越来越多的任务，但几乎所有处理器最初都是多周期架构。即使是这些大块头，模型也很少真正保持单周期，正如你马上就会看到的。
- en: But first, let’s take a look at how this very advantage of simplicity through
    multicycle execution can backfire.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看这种通过多周期执行实现的简单优势是如何产生反效果的。
- en: Execution Stages
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行阶段
- en: One of the variations of multicycle execution is a method that splits a task
    not into a number of repetitive steps, but rather into a number of distinct yet
    generic preparation and execution stages. This method, called *staging*, is used
    in today’s processors to make them perform better without necessarily becoming
    linearly more complex. Execution staging has become one of a processor’s more
    important features.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 多周期执行的一种变体是将任务分割成若干个不同的、但通用的准备和执行阶段，而不是分割成若干个重复的步骤。这种方法被称为*阶段化*，在今天的处理器中被用来使它们在没有必要线性增加复杂性的情况下表现更好。执行阶段化已经成为处理器的一个重要特性。
- en: Today’s processors can translate every instruction into a set of largely independent
    small steps. Certain steps can be achieved using generic circuits shared by all
    instructions, thus contributing to the overall simplicity. For example, the circuitry
    specific to a given task (our favorite multiplication comes to mind once more)
    can be made more universal and reusable as a part of various advanced instructions
    by separating it from any generic I/O handling tasks, and so on. The set of execution
    stages and transitions depends on the architecture, but it is usually similar
    to the scheme shown in [Figure 2-6](ch02s08.html#baseline_instruction_execution_stages
    "Figure 2-6. Baseline instruction execution stages").
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的处理器可以将每条指令转换成一组大量独立的小步骤。某些步骤可以使用所有指令共享的通用电路来完成，从而有助于整体的简单性。例如，特定任务（再次想到我们最喜欢的乘法）的电路可以通过将其从任何通用I/O处理任务中分离出来，作为各种高级指令的一部分而变得更加通用和可重用。执行阶段和转换的集合取决于架构，但通常类似于[图2-6](ch02s08.html#baseline_instruction_execution_stages
    "图2-6. 基线指令执行阶段")中所示的方案。
- en: '![Baseline instruction execution stages](httpatomoreillycomsourcenostarchimages1138014.png.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![基线指令执行阶段](httpatomoreillycomsourcenostarchimages1138014.png.jpg)'
- en: Figure 2-6. Baseline instruction execution stages
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6. 基线指令执行阶段
- en: '[Figure 2-6](ch02s08.html#baseline_instruction_execution_stages "Figure 2-6. Baseline
    instruction execution stages") shows the following stages:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](ch02s08.html#baseline_instruction_execution_stages "图2-6. 基线指令执行阶段")显示了以下阶段：'
- en: '**Instruction fetch/decode**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**指令获取/解码**'
- en: The processor retrieves an instruction from memory, translates it to a low-level
    sequence, and decides how to proceed and which data to pass to all subsequent
    stages. The circuit is shared for all operations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器从内存中检索指令，将其转换为低级序列，并决定如何进行以及将哪些数据传递给所有后续阶段。该电路对所有操作都是共享的。
- en: '**Operand fetch/decode**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作数获取/解码**'
- en: The processor uses a generic circuit to fetch operands from sources for this
    particular instruction (for example, from specified internal registers) so that
    the main circuit does not have to support all possible operand combinations and
    fetch strategies.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器使用一个通用电路从源中获取操作数以执行特定指令（例如，从指定的内部寄存器中获取），这样主电路就不必支持所有可能的操作数组合和获取策略。
- en: '**ALU**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**ALU**'
- en: An arithmetic logic unit (ALU) tailored to perform this particular operation,
    perhaps in a number of steps, is invoked to perform a specified arithmetic task.
    For nonarithmetic (memory transfer) instructions, generic or dedicated ALU circuits
    are sometimes used to calculate source and destination addresses.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个针对执行此特定操作（可能需要多个步骤）而定制的算术逻辑单元（ALU）被调用以执行指定的算术任务。对于非算术（内存传输）指令，有时使用通用或专用ALU电路来计算源和目标地址。
- en: '**Memory store**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存存储**'
- en: The result is stored at its destination. For nonarithmetic operations, the memory
    is copied between calculated locations.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 结果存储在其目标位置。对于非算术操作，内存将在计算的位置之间进行复制。
- en: This, alone, may appear to be merely a variation of regular multicycle execution
    and a circuit reuse measure—one that is prevalent in most of today’s CPU designs.
    But as you will see, it is also of utmost importance to execution speed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此而已，可能看起来只是常规多周期执行和电路重用措施的一种变化——这在今天的大多数CPU设计中都很普遍。但正如你将看到的，这对执行速度也极其重要。
- en: The Lesser Memory
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**较少的内存**'
- en: The simplicity of circuitry is not where this story ends. One additional advantage
    to the multicycle design is that the processor speed is no longer limited by the
    memory, the slowest component of the system. Consumer-grade external memory is
    considerably slower than today’s processors and has a high access and write latency.
    A single-cycle processor can be no faster than it takes to reliably access memory,
    even though it is not accessing memory all the time. It needs to be slow simply
    because one of the single-cycle instructions it could encounter *might* require
    memory access; and hence, there must be enough time to accomplish this. Multicycle
    designs, on the other hand, allow the CPU to take its time and even idle for a
    couple of cycles as necessary (during memory I/O, for example), but run at full
    speed when performing internal computations. Too, when using multicycle designs,
    its easier to speed up memory-intensive operations without having to invest in
    faster main memory.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 电路的简单性并不是这个故事结束的地方。多周期设计的另一个额外优势是处理器速度不再受限于系统中最慢的组件——内存。消费级外部内存的访问速度远低于今天的处理器，并且具有高访问和写入延迟。即使处理器并非始终在访问内存，单周期处理器的速度也无法超过可靠访问内存所需的时间。它需要慢的原因之一是它可能遇到的单周期指令中**可能**需要内存访问；因此，必须有足够的时间来完成这项任务。另一方面，多周期设计允许CPU根据需要花费时间，甚至在必要时闲置几个周期（例如，在内存I/O期间），但在执行内部计算时以全速运行。此外，在使用多周期设计时，更容易加快内存密集型操作的速度，而无需投资于更快的内存。
- en: The flip-flop design, commonly referred to as SRAM (static RAM), offers low-access
    latency and consumes little power. Current designs require about 5 nanoseconds,
    which is comparable to the cycle interval of some processors. Unfortunately, the
    design also requires a considerable number of components per flip-flop, typically
    about six transistors per bit.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 反转门设计，通常被称为SRAM（静态RAM），提供低访问延迟并消耗少量电力。当前设计需要大约5纳秒，这相当于一些处理器的周期间隔。不幸的是，该设计还需要每个触发器相当数量的组件，通常每个比特大约需要六个晶体管。
- en: Unlike SRAM, DRAM, (dynamic RAM) the other memory design popular today, uses
    an array of capacitors to store the information. Capacitors, however, tend to
    discharge and need to be refreshed regularly. DRAM requires more power than SRAM
    and has a considerably higher access and modification latency, as high as 50 nanoseconds.
    On the upside, DRAM is much cheaper to manufacture than SRAM.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 与SRAM、DRAM（动态RAM）等其他今天流行的内存设计不同，DRAM使用电容器阵列来存储信息。然而，电容器往往会放电，需要定期刷新。DRAM比SRAM消耗更多的电力，并且访问和修改的延迟相当高，高达50纳秒。从积极的一面来看，DRAM的制造成本比SRAM低得多。
- en: The use of SRAM for main memory is practically unheard of because its cost is
    prohibitive. Besides, we would have trouble using all that increase in performance,
    which would require us to run the memory at nearly the same speed as the CPU.
    Alas, because main memory is sizable and designed to be extensible, it must be
    placed outside the CPU. Although the CPU core can usually run at a speed much
    higher than the world around it, serious reliability issues (such as track capacitance
    on the motherboard, interference, costs of high-speed peripheral chips, and so
    on) arise when data must be transferred over longer distances.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于成本过高，使用SRAM作为主内存几乎是不可能的。此外，我们还会遇到使用所有增加的性能的困难，这将要求我们以几乎与CPU相同的速度运行内存。遗憾的是，由于主内存体积较大且设计为可扩展，它必须放置在CPU外部。尽管CPU核心通常可以以比周围世界更高的速度运行，但当数据必须通过更长的距离传输时，会出现严重的可靠性问题（如主板上的轨道电容器、干扰、高速外围芯片的成本等）。
- en: Rather than take the cost-prohibitive routes of using faster external memory
    or integrating all memory with the CPU, manufacturers usually adopt a more reasonable
    approach. Advanced CPUs are equipped with fast but considerably smaller in-core
    memory, SRAM or some derivative, that caches the most frequently accessed memory
    regions and sometimes stores certain additional CPU-specific data. Thus, whenever
    a chunk of memory is found in cache *(cache hit)*, it can be accessed rapidly.
    Only when a chunk of memory has to be fetched from the main memory *(cache miss)*
    can there be a considerable delay, at which point the processor has to postpone
    some of its operations for some time. (Single-cycle processors cannot take full
    advantage of internal caching.)
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是采用使用更快的外部内存或集成所有内存与CPU的成本高昂的方法，制造商通常采用更合理的方法。先进的CPU配备了快速但相对较小的内核内存，SRAM或某些衍生品，它缓存了最常访问的内存区域，有时还存储某些特定的CPU数据。因此，每当在缓存中找到内存块（缓存命中）时，它就可以快速访问。只有当必须从主内存中获取内存块（缓存未命中）时，才会出现相当大的延迟，此时处理器必须暂时推迟一些操作。
    （单周期处理器不能充分利用内部缓存。）
- en: 'Do More at Once: Pipelining'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次做更多：流水线
- en: 'As I have mentioned, staging offers a considerable performance advantage that
    goes far beyond a traditional multicycle approach. There is one major difference
    between them, though: because many of the stages are shared by various instructions,
    there is no reason not to optimize execution a bit.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，流水线化提供了相当大的性能优势，这远远超过了传统的多周期方法。尽管如此，它们之间有一个主要区别：由于许多阶段被各种指令共享，因此没有必要不稍微优化一下执行过程。
- en: '[Figure 2-6](ch02s08.html#baseline_instruction_execution_stages "Figure 2-6. Baseline
    instruction execution stages") shows that, with separate stages executing separately,
    only a specific part of the device is used in every cycle. Even though the instruction
    currently executed has already passed the first stages, it blocks the entire CPU
    until it completes. For systems with a high number of execution stages (the count
    often reaches or exceeds 10 on today’s chips, with the Pentium 4 exceeding 20)
    this proves to be a terrible waste of computing power.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](ch02s08.html#baseline_instruction_execution_stages "图2-6. 基线指令执行阶段")显示，当各个阶段分别执行时，每个周期只使用设备的一部分。尽管当前正在执行的指令已经通过了第一阶段，但它会阻塞整个CPU，直到它完成。对于具有大量执行阶段（在今天芯片上，这个数字通常达到或超过10，Pentium
    4甚至超过20）的系统来说，这证明是一种严重的计算能力浪费。'
- en: One solution is to let the next instruction enter the execution pipeline as
    soon as the previous one moves to the following stage, as shown in [Figure 2-7](ch02s08.html#pipeline_execution_model
    "Figure 2-7. Pipeline execution model"). As soon as a particular stage of the
    first instruction is finished, and the execution moves to the next stage, the
    previous stage is fed with a portion of the subsequent instruction, and so forth.
    By the time the first instruction completes, the next is only one stage from being
    completed, and the third instruction is two stages apart. Execution time is thus
    decreased rather dramatically, and chip usage becomes optimal, using this cascading
    method.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是让下一条指令在上一条指令移动到下一个阶段后立即进入执行流水线，如图 [图2-7](ch02s08.html#pipeline_execution_model
    "图2-7. 流水线执行模型") 所示。一旦第一条指令的某个阶段完成，并且执行移动到下一个阶段，前一个阶段就会用后续指令的一部分来填充，依此类推。当第一条指令完成时，下一条指令只差一个阶段就能完成，第三条指令则相隔两个阶段。因此，通过这种级联方法，执行时间可以显著减少，芯片使用也变得最优化。
- en: '![Pipeline execution model](httpatomoreillycomsourcenostarchimages1138016.png.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![流水线执行模型](httpatomoreillycomsourcenostarchimages1138016.png.jpg)'
- en: Figure 2-7. Pipeline execution model
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7. 流水线执行模型
- en: Pipelining works fine as long as the instructions are not interdependent and
    neither operates on the output of its predecessor still in the pipeline. If the
    instructions do depend on each other, serious problems are bound to ensue. As
    such, a special circuit must be implemented to supervise the pipeline and to prevent
    such interlocking situations.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 只要指令不相互依赖，并且没有操作在其前驱仍在流水线中的输出上操作，流水线就可以正常工作。如果指令确实相互依赖，那么必然会出现严重问题。因此，必须实施一个特殊电路来监督流水线，以防止这种锁定情况。
- en: There are more challenges when it comes to pipelining. For example, on some
    processors, the set of stages may be different for distinct operations. Not all
    stages are always applicable, and it might be more optimal to skip some. Certain
    simple operations could conceivably be run through the pipeline much faster, because
    there are no operands to be fetched or stored. In addition, some stages can take
    a variable number of cycles, which contributes to the risk of collisions when
    two instructions reach the same execution stage at the same point. To prevent
    this, certain additional mechanisms such as pipeline “bubbles,” no-op stages designed
    to introduce ephemeral delays when necessary, must be devised.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在流水线方面还有更多的挑战。例如，在某些处理器上，不同的操作可能具有不同的阶段集合。并非所有阶段都始终适用，有时跳过一些阶段可能更优。某些简单操作可能通过流水线运行得更快，因为没有要取或存储的操作数。此外，某些阶段可能需要可变数量的周期，这增加了两条指令在同一执行阶段同时到达的风险。为了防止这种情况，必须设计某些额外的机制，例如流水线“气泡”，以及设计用于在必要时引入短暂延迟的无操作阶段。
- en: The Big Problem with Pipelines
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线的重大问题
- en: 'Traditional pipelines are a great tool for achieving high performance with
    simple, multistaged chip design, by reducing the latency of subsequent instructions
    and ensuring optimal circuit usage, but they are not without concerns: it is not
    possible to pipeline instructions past a conditional branch instruction if those
    instructions could alter further program execution.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的流水线是利用简单、多阶段芯片设计实现高性能的伟大工具，通过减少后续指令的延迟并确保电路使用最优化，但它们并非没有问题：如果这些指令可能会改变进一步的程序执行，则无法将指令流水线到条件分支指令之后。
- en: In fact, it often is possible, but the processor has no idea which execution
    path to follow, and if an incorrect decision is made, the entire pipeline has
    to be flushed down immediately after a branch instruction. (The CPU must also
    delay committing any changes made by these instructions that, after all, were
    not to be executed.) Dumping the pipeline introduces an additional delay.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通常是有可能的，但处理器不知道应该遵循哪个执行路径，如果做出了错误的决定，整个流水线必须在分支指令之后立即被清空。（CPU还必须延迟提交这些指令所做的任何更改，因为这些指令毕竟是没有被执行的。）清空流水线引入了额外的延迟。
- en: And, unfortunately for this design, many CPU-intensive tasks, including plenty
    of video and audio algorithms, rely on small conditional-exit loops executed millions
    of times in sequence, thus inflicting a terrible performance impact on the pipelined
    architecture.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于这种设计，许多CPU密集型任务，包括大量的视频和音频算法，都依赖于执行数百万次的小型条件退出循环，从而对流水线架构造成了巨大的性能影响。
- en: The answer to this problem is *branch prediction*. Branch predictors are usually
    fairly simple counter circuits that track the most recent code execution and maintain
    a small history buffer to make educated guesses about the most likely outcome
    of a conditional branch operation (although more complex designs are also often
    deployed^([[53](apb.html#ftn.CHP-2-BIB-2)])).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是*分支预测*。分支预测器通常是相当简单的计数电路，它跟踪最近的代码执行并维护一个小型历史缓冲区，以便对条件分支操作的最可能结果做出明智的猜测（尽管也经常部署更复杂的设计^([[53](apb.html#ftn.CHP-2-BIB-2)])）。
- en: 'All branch predictors employ a strategy that is designed to offer the best
    pipelining performance for a given code: if a specific branch instruction is executed
    more often than it is skipped, it is better to fetch and pipeline instructions.
    Of course, the prediction can fail, in which case, the entire queue must be dropped.
    However, today’s predictors achieve up to 90 percent success rates in typical
    code.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 所有分支预测器都采用一种策略，旨在为给定的代码提供最佳的流水线性能：如果特定的分支指令执行次数多于跳过次数，则最好取指令并流水线化。当然，预测可能会失败，在这种情况下，整个队列必须被丢弃。然而，今天的预测器在典型代码中达到了高达90%的成功率。
- en: 'Implications: Subtle Differences'
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 影响：细微的差异
- en: 'The advanced set of optimizations employed in today’s processors results in
    an interesting set of consequences. We observe that execution times depend on
    the following characteristics, which can be divided into three groups:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 今天处理器中采用的先进优化集产生了一系列有趣的结果。我们观察到执行时间取决于以下特征，这些特征可以分为三组：
- en: '| **Type of instruction and the complexity of the operation**. Some operations
    execute much faster than others. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **指令类型和操作的复杂性**。某些操作比其他操作执行得更快。|'
- en: '| **Operand values**. Certain multiple cycle algorithms prove faster for trivial
    inputs. For example, multiplying a value by 0 is generally rather trivial and
    can be done quickly. |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **操作数值**。某些多周期算法对于简单输入证明更快。例如，将一个值乘以0通常相当简单，可以快速完成。|'
- en: '| **The memory location from which the data needed for the instruction must
    be retrieved**. Cached memory is available sooner. |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **指令所需数据的内存位置**。缓存内存可以更快地访问。|'
- en: The importance, prevalence, and impact of each of these characteristics depends
    on the exact nature of the CPU architecture in question. The first characteristic—variable
    instruction execution times—is shared by all multi-cycle architectures, but might
    be absent on some basic chips. The second—dependence on operands—is increasingly
    extinct in top-of-the-line processors.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征的重要性、普遍性和影响取决于所讨论的CPU架构的确切性质。第一个特征——可变指令执行时间——是所有多周期架构共有的，但在一些基本芯片上可能不存在。第二个特征——对操作数的依赖性——在顶级处理器中越来越少见。
- en: In top-end devices, ALU and Floating Point Unit (FPU) components sometimes work
    at a speed higher than the CPU itself. Hence, even if there are computation speed
    differences, they cannot be precisely measured because much of the arithmetic
    is done within one CPU clock tick.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在高端设备中，算术逻辑单元（ALU）和浮点运算单元（FPU）组件有时的工作速度高于CPU本身。因此，即使存在计算速度差异，也无法精确测量，因为大部分算术运算都是在单个CPU时钟周期内完成的。
- en: The last group of timing patterns—memory location dependence—is, for a change,
    exclusive to today’s, high-performance computers and is unheard of in low-end
    controllers and various embedded designs.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组时序模式——内存位置依赖性——与以往不同，仅限于今天的、高性能的计算机，而在低端控制器和各种嵌入式设计中闻所未闻。
- en: The first two timing pattern groups—operation complexity and operand value dependences—can
    also manifest themselves on a level slightly higher than the CPU itself, namely
    software. Processors feature arithmetic units that deal well with fairly small
    integers (usually from 8 to 128 bits) and some floating-point numbers, but today’s
    cryptography and many other applications require the manipulation of large numbers
    (often hundreds or thousands of digits), high-precision floats, or various mathematic
    operations that are not implemented in hardware. Therefore, this functionality
    is commonly implemented in software libraries. Algorithms in those libraries are
    again likely to take variable time, depending on the specifics of the operation
    and operands.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个时间模式组——操作复杂性和操作数值依赖——也可以在CPU本身略高的层面上表现出来，即软件层面。处理器具有处理相当小的整数（通常从8位到128位）和一些浮点数的算术单元，但今天的密码学以及许多其他应用需要操作大数（通常是数百或数千位）、高精度浮点数或各种未在硬件中实现的高级数学运算。因此，这种功能通常在软件库中实现。这些库中的算法可能因操作和操作数的具体细节而具有可变的时间。
- en: Using Timing Patterns to Reconstruct Data
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用时间模式重构数据
- en: It can be argued that an attacker could deduce certain properties of the operands
    or of an operation performed by monitoring how long it takes for a program to
    process data. This poses a potential security risk because in several scenarios,
    at least one of the operands can be a secret value that is not supposed to be
    disclosed to a third party.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 可以认为，攻击者可以通过监控程序处理数据所需的时间来推断操作数或操作的某些属性。这构成了潜在的安全风险，因为在几个场景中，至少有一个操作数可能是一个不应向第三方透露的秘密值。
- en: Although the concept of recovering data by watching someone with a stopwatch
    in your hand might sound surreal, today’s CPUs offer precise counters that allow
    parties to determine exact time intervals. Too, some operations can be considerably
    more time-consuming, with certain advanced opcodes on the Intel platform taking
    as much as thousands of cycles to complete. With ever-increasing network throughput
    and ever-improving response times, it is not entirely impossible to deduce this
    information, even from a remote system.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用手中的秒表观察某人恢复数据的概念可能听起来很超现实，但今天的CPU提供了精确的计数器，使得各方能够确定确切的时间间隔。此外，某些操作可能需要更多的时间，例如在英特尔平台上，某些高级操作码可能需要数千个周期才能完成。随着网络吞吐量的不断增长和响应时间的持续改善，从远程系统中推断出这些信息并非完全不可能。
- en: The nature of information leaked as computation complexity measurements may
    not be immediately clear. If so, Paul Kocher from Cryptography Research demonstrated
    a great example of this attack last century (that is, back in the ’90s^([[54](apb.html#ftn.CHP-2-BIB-3)])),
    using an example of the RSA algorithm we discussed in [Chapter 1](ch01.html "Chapter 1. I
    Can Hear You Typing").
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算复杂度测量的信息泄露的性质可能并不立即清楚。如果是这样，密码学研究公司的保罗·科赫在上个世纪（即20世纪90年代）展示了一个很好的攻击示例（即，在20世纪90年代），使用我们在[第1章](ch01.html
    "第1章。我能听到你在打字")中讨论的RSA算法。
- en: Bit by Bit . . .
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐位……
- en: 'Kocher observed that the process of decrypting data in the RSA algorithm is
    rather simple and is based on solving the following equation:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 科赫观察到，RSA算法中解密数据的过程相当简单，它基于解决以下方程：
- en: '| *T* = *c*^(*k*) mod *M* |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| *T* = *c*^(*k*) mod *M* |'
- en: in which *T* is the decrypted message, *c* is the encrypted message, *k* is
    the secret key, and *M* is a moduli, which are a part of the key pair.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *T* 是解密的消息，*c* 是加密的消息，*k* 是密钥，*M* 是模数，它们是密钥对的一部分。
- en: 'A trivial integer modulo exponentiation algorithm used in a typical implementation
    has an important property: if a specific bit of the exponent is one, a portion
    of the result is calculated by performing modulo multiplication on a portion of
    the base (some bits of *c*). If the bit is 0, the step is skipped. Even when the
    step is not actually skipped, the time needed by software to carry out multiplication
    varies, as indicated earlier. Most trivial cases—such as multiplying by a power
    of 2—are solved more quickly than others.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型实现中使用的简单整数模幂指数算法有一个重要的特性：如果指数的某个位是1，则结果的一部分是通过在基数的一部分（*c*的一些位）上执行模乘法来计算的。如果位是0，则跳过该步骤。即使实际上没有跳过该步骤，软件执行乘法所需的时间也会变化，如前所述。大多数简单情况——例如乘以2的幂——比其他情况解决得更快。
- en: Hence, on such a system, it would appear that we can determine plenty of information
    about the key (*k*) by repeatedly checking to see how long it takes to decrypt
    a piece of information. Even on platforms on which hardware multiplication takes
    a fixed amount of time, a timing pattern often results from the use of software
    multiplication algorithms (such as Karatsuba multiplication algorithm) that are
    needed for processing large numbers such as the ones used by public key cryptography.
    Subsequent bits of the exponent make the private key, whereas the base is a representation
    of the message supplied or visible to the curious bystander.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这样的系统中，我们可以通过反复检查解密信息所需的时间来确定关于密钥（*k*）的大量信息。即使在硬件乘法需要固定时间的平台上，软件乘法算法（如Karatsuba乘法算法）的使用也会产生时间模式，这些算法是处理大数（如公钥密码学中使用的数）所必需的。指数的后续位构成私钥，而基数是提供给好奇旁观者或可见的消息的表示。
- en: The attack is rather trivial. The villain sends the attacker two similar but
    slightly different portions of encrypted data. They differ in a section *X*, so
    that decrypting that section would presumably take a different amount of time
    to decrypt. One of the variants of *X*, as far as the villain’s idea of victim’s
    modulo multiplication implementation goes, is a trivial case that would hence
    make the task of decrypting *X* fast. The other variant is expected to take more
    time.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击相当简单。反派发送攻击者两个相似但略有不同的加密数据部分。它们在部分 *X* 上有所不同，因此解密该部分可能需要不同的时间。就反派对受害者模乘实现的想法而言，*X*
    的一个变体是一个简单的情况，因此解密 *X* 的任务会很快完成。另一个变体预计需要更多时间。
- en: If it takes the same amount of time for the attacker to decode and respond to
    both sequences, the attacker can safely assume that the part of the key that was
    used to decode section *X* consisted of zeros. They can also assume that the multiplication
    algorithm took the early optimization path, that of not performing any multiplication
    at all.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者解码和响应两个序列所需的时间相同，攻击者可以安全地假设用于解码部分 *X* 的密钥部分由零组成。他们还可以假设乘法算法采用了早期优化路径，即根本不执行任何乘法。
- en: If, on the other hand, one of the scenarios takes more time, it’s obvious that
    in both cases, the multiplication was carried out, with one case being simpler
    to solve. The corresponding part of the secret key bit must have been set to a
    nonzero value.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果其中一个场景花费更多时间，那么很明显，在两种情况下都进行了乘法运算，其中一种情况更容易解决。相应的密钥位必须设置为非零值。
- en: By following this procedure, treating subsequent bits of the encrypted message
    as our “section *X*” and generating, or even (if one has more time) simply waiting
    for encrypted messages that will happen to work with this scenario, it is possible
    to reconstruct every bit of the key.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循此程序，将加密消息的后续位视为我们的“部分 *X*”，生成或（如果时间允许）简单地等待与该场景兼容的加密消息，可以重建密钥的每一位。
- en: Note
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Research suggests that this approach can be successfully extended to just about
    any algorithm that is carried out in a variable time and discusses some practical
    optimizations for the attack, such as the ability to deploy limited error detection
    and correction functionality.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 研究表明，这种方法可以成功扩展到几乎所有在可变时间内执行的计算算法，并讨论了一些攻击的实用优化，例如部署有限的错误检测和纠正功能。
- en: In Practice
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中
- en: The ability to deduce tangible properties of operands for arithmetic instructions
    based solely on timing information is the most obvious, effective, and interesting
    vector for performing computational complexity attacks. Other techniques, such
    as cache hit and miss timing, usually require considerably more detailed analysis
    and reveal less information in every cycle.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 仅根据时间信息推断算术指令操作数的可感知属性，是执行计算复杂度攻击最明显、最有效和最有意思的向量。其他技术，如缓存命中和未命中时间，通常需要更详细的分析，并且在每个周期中揭示的信息较少。
- en: 'It is clear that this problem would, to a degree, affect many software algorithms,
    such as large-number arithmetic libraries commonly used in cryptographic applications.
    But software algorithms and theory aside, a couple of important questions remain:
    how real is the execution time dependency on the hardware level, and how can it
    be measured?'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个问题在一定程度上会影响许多软件算法，例如在加密应用中常用的大数算术库。但抛开软件算法和理论，还有一些重要的问题仍然存在：执行时间对硬件级别的依赖程度有多真实，以及如何进行测量？
- en: An example is well within reach. At least a portion of the Intel IA32 architecture
    exhibits this behavior. The *80386 Programmer’s Reference Manual*^([[55](apb.html#ftn.CHP-2-BIB-4)])
    describes an integer-signed multiplication opcode, denoted by the mnemonic IMUL.
    The opcode, in its basic form, multiplies the value stored in the *accumulator*
    (a multipurpose working register going by the name [E]AX on this platform), by
    a value stored in another register. The result is then stored back in the accumulator.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子很容易找到。至少英特尔 IA32 架构的一部分表现出这种行为。《*80386 程序员参考手册*》^([[55](apb.html#ftn.CHP-2-BIB-4)])
    描述了一个整数有符号乘法操作码，用助记符 IMUL 表示。该操作码在其基本形式下，将存储在*累加器*（一个多功能工作寄存器，在此平台上称为 [E]AX）中的值与另一个寄存器中存储的值相乘。然后，结果被存储回累加器。
- en: 'The documentation further explains:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 文档进一步解释道：
- en: 'The 80386 uses an early-out multiply algorithm. The actual number of clocks
    depends on the position of the most significant bit in the optimizing multiplier
    [...]. The optimization occurs for positive and negative values. Because of the
    early-out algorithm, clock counts given are minimum to maximum. To calculate the
    actual clocks, use the following formula:'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 80386 使用早期退出乘法算法。实际时钟数取决于优化乘数中最显著位的位位置 [...]。优化适用于正数和负数。由于早期退出算法，给出的时钟数是最大值到最小值。为了计算实际时钟数，请使用以下公式：
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actual clock = if m <> 0 then max(ceiling(log2(m)), 3) + 6 clocks
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际时钟数 = 如果 m <> 0 则 max(ceiling(log2(m)), 3) + 6 个时钟
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Actual clock = if m = 0 then 9 clocks
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际时钟数 = 如果 m = 0 则 9 个时钟
- en: 'Although this may look cryptic, its meaning is simple: The processor optimizes
    multiplication based on the value of the multiplier. Instead of multiplying the
    multiplicand until all bits of the multiplier are exhausted, it skips zeros at
    the beginning of the operand.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能有些晦涩，但其含义很简单：处理器根据乘数的值优化乘法。它不是将乘数乘到乘数的所有位都耗尽，而是跳过操作数开头的零。
- en: Early-Out Optimization
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期退出优化
- en: To understand the relevance of this tactic to integer multiplication, imagine
    a traditional iterative multiplication method taught in schools, except this time
    in binary. A hypothetical “dumb” implementation of this algorithm performs the
    following set of operations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这种策略对整数乘法的相关性，可以想象一下学校里教授的传统迭代乘法方法，只不过这次是在二进制下。一个假设的“愚蠢”实现算法执行以下一系列操作。
- en: '[PRE0]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It should be obvious that a large number of these operations are completely
    unnecessary and unwarranted and that continuing the operation once nothing but
    zeros remain at subsequent bits of the multiplier is simply pointless. A more
    reasonable approach is to skip them:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些操作中的许多是完全不必要的和不合理的，而且一旦乘数的后续位只剩下零，继续操作就毫无意义。一个更合理的方法是跳过它们：
- en: '[PRE1]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And this is, in essence, the nature of the *early-out optimization* that Intel
    deployed.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是英特尔部署的*早期退出优化*的本质。
- en: Note
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This optimization makes multiplication nonsymmetrical in time. 2*100 will compute
    more slowly than 100*2 (!), even though the result is obviously the same.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化使得乘法在时间上不对称。2*100 的计算速度会比 100*2 慢 (!)，尽管结果显然是相同的。
- en: 'With early-out optimization, Intel processors require a variable number of
    cycles to perform multiplication, and the length is directly proportional to the
    location of the oldest (most significant) bit set in the second operand. By applying
    the clock count algorithm provided in the documentation, it is possible to determine
    the correlation between the multiplier and IMUL time, as shown here:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过早期退出优化，英特尔处理器执行乘法需要可变数量的周期，其长度与第二个操作数中最老（最显著）位被设置的位的位置成正比。通过应用文档中提供的时钟计数算法，可以确定乘数和
    IMUL 时间的相关性，如下所示：
- en: '| Multiplier Value Range | Cycles to Complete |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 乘数值范围 | 完成周期数 |'
- en: '| --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 – 7 | 9 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 0 – 7 | 9 |'
- en: '| 8 – 15 | 10 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 8 – 15 | 10 |'
- en: '| 16 – 31 | 11 |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 16 – 31 | 11 |'
- en: '| 32 – 63 | 12 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 32 – 63 | 12 |'
- en: '| 64 – 127 | 13 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 64 – 127 | 13 |'
- en: '| 128 – 255 | 14 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 128 – 255 | 14 |'
- en: '| 256 – 1,023 | 15 |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| 256 – 1,023 | 15 |'
- en: '| 1,024 – 2,047 | 16 |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 1,024 – 2,047 | 16 |'
- en: '| 2,048 – 4,095 | 17 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 2,048 – 4,095 | 17 |'
- en: '| 4,096 – 8,191 | 18 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 4,096 – 8,191 | 18 |'
- en: '| 8,192 – 16,383 | 19 |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 8,192 – 16,383 | 19 |'
- en: '| 16,384 – 32,767 | 20 |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 16,384 – 32,767 | 20 |'
- en: '| 32,768 – 65,535 | 21 |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 32,768 – 65,535 | 21 |'
- en: '| 65,536 – 131,071 | 22 |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 65,536 – 131,071 | 22 |'
- en: '| 131,072 – 262,143 | 23 |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 131,072 – 262,143 | 23 |'
- en: '| 262,144 – 524,287 | 24 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 262,144 – 524,287 | 24 |'
- en: '| 524,288 – 1,048,575 | 25 |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 524,288 – 1,048,575 | 25 |'
- en: '| 1,048,576 – 2,097,151 | 26 |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 1,048,576 – 2,097,151 | 26 |'
- en: '| 2,097,152 – 4,194,303 | 27 |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 2,097,152 – 4,194,303 | 27 |'
- en: '| 4,194,304 – 8,388,607 | 28 |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| 4,194,304 – 8,388,607 | 28 |'
- en: '| 8,388,608 – 16,777,215 | 29 |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| 8,388,608 – 16,777,215 | 29 |'
- en: '| 16,777,216 – 33,554,431 | 30 |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| 16,777,216 – 33,554,431 | 30 |'
- en: '| 33,554,432 – 67,108,863 | 31 |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 33,554,432 – 67,108,863 | 31 |'
- en: '| 67,108,864 – 134,217,727 | 32 |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| 67,108,864 – 134,217,727 | 32 |'
- en: '| 134,217,728 – 268,435,455 | 33 |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| 134,217,728 – 268,435,455 | 33 |'
- en: '| 268,435,456 – 536,870,911 | 34 |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| 268,435,456 – 536,870,911 | 34 |'
- en: '| 536,870,912 – 1,073,741,823 | 35 |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| 536,870,912 – 1,073,741,823 | 35 |'
- en: '| 1,073,741,824 – 2,147,483,647 | 36 |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| 1,073,741,824 – 2,147,483,647 | 36 |'
- en: A similar dependency exists for negative multiplier values.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负乘数值也存在类似的依赖关系。
- en: Working Code—Do It Yourself
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作代码—自己动手做
- en: 'The following code listing shows a practical implementation in C for Unix-type
    systems that can be used to confirm and measure differences in timing patterns.
    The program is invoked with two parameters: *multiplicand* (which should not affect
    performance in any way) and *multiplier* (presumably used in early-out optimizations
    and hence impacting the speed of the entire operation). The program performs 256
    tests of 500 subsequent multiplications with the chosen parameters and returns
    the shortest measured time.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表展示了适用于 Unix 类系统的 C 语言的实际实现，可用于确认和测量计时模式的不同。程序使用两个参数调用：*乘数*（不应以任何方式影响性能）和*乘数*（可能用于早期退出优化，因此影响整个操作的速度）。程序使用所选参数执行
    256 次测试，每次测试 500 次后续乘法，并返回最短测量时间。
- en: We run 256 tests and select the best result in order to compensate for cases
    in which execution is interrupted by the system for some period of time, a condition
    fairly common in multitasking environments. Although a single test can be affected
    by such an event, at least some of the test in a rapid sequence of short tests
    can be expected to complete without interruption.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了 256 次测试，并选择最佳结果以补偿系统在一段时间内中断执行的情况，这在多任务环境中相当常见。尽管单个测试可能会受到此类事件的影响，但至少在一系列快速进行的短测试中，可以预期至少有一些测试可以无中断地完成。
- en: The code uses the system clock to measure execution time in micro-seconds.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用系统时钟来测量执行时间（微秒）。
- en: Note
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Several of today’s Intel chips feature a precise timing mechanism available
    through RDTSC opcode. This method for accessing the internal clock cycle counter
    is not available on older platforms, and so we will not rely on it.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的一些英特尔芯片具有通过 RDTSC 指令码提供的精确计时机制。这种方法访问内部时钟周期计数器在旧平台上不可用，因此我们不会依赖它。
- en: '[PRE2]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By compiling the code with the IMUL instruction initially commented out and
    invoking the program with arbitrary parameters, we can estimate the timing code
    overhead (T[idle]). If the value falls outside the range of 10 to 100 microseconds—which
    is high enough to provide a fine-grained readout, but low enough to maximize the
    chance of not being interrupted by the operating system—readjust the loop repetition
    counter R, which is set to 500 by default.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 IMUL 指令最初注释掉并使用任意参数调用程序，我们可以估计计时代码的开销（T[idle]）。如果该值超出 10 到 100 微秒的范围——这足以提供精细的读数，但足够低以最大化操作系统中断的机会——则调整循环重复计数器
    R，默认设置为 500。
- en: 'After restoring the IMUL instruction and recompiling and running the program
    with a chosen multiplicand D and repetition counter R, it is possible to use the
    returned time approximation T[D,R] to estimate the number of CPU cycles spent
    on IMUL operation (C[D,R]), as long as the operating frequency of the processor
    (F[MHz]) is known:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复 IMUL 指令并使用选定的乘数 D 和重复计数器 R 重新编译和运行程序后，可以使用返回的时间近似值 T[D,R] 来估计 IMUL 操作（C[D,R]）所花费的
    CPU 周期数，只要知道处理器的运行频率（F[MHz]）：
- en: '| *C*[*D, R*] = (*T*[*D, R*] − *T*[*idle*]) · *F*[*MHz*]/*R* |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| *C*[*D, R*] = (*T*[*D, R*] − *T*[*idle*]) · *F*[*MHz*]/*R* |'
- en: As expected, pipelining and branch predictors on newer and more advanced chips
    will kick in and skew the result slightly, but a good estimate can be made.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在更新和更先进的芯片上的流水线和分支预测器将启动并略微扭曲结果，但可以做出良好的估计。
- en: Note
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On newer Intel processors, the time needed to complete multiplication is already
    constant.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的英特尔处理器上，完成乘法所需的时间已经是恒定的。
- en: Prevention
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防
- en: You can take a number of approaches to protect against computational effort
    analysis. The most obvious is to make all operations take the same amount of time
    to execute. However, this is difficult and often results in severe performance
    penalties because the time taken by all computations would have to be extended
    to match that of the slowest one.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取多种方法来防止计算工作量分析。最明显的方法是使所有操作执行所需的时间相同。然而，这很困难，并且通常会导致严重的性能惩罚，因为所有计算所需的时间都必须延长以匹配最慢的那个。
- en: Introducing random delays sometimes appears to be an acceptable defense tactic
    for applications if latency is not critical, in particular many noninteractive
    network services, and puts less stress on the processor itself. However, this
    random noise can be effectively filtered out if the attack can be carried out
    repeatedly.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟不是关键因素，引入随机延迟有时似乎是应用程序的可接受防御策略，特别是对于许多非交互式网络服务，并且对处理器的压力较小。然而，如果攻击可以重复进行，这种随机噪声可以被有效地过滤掉。
- en: Another approach, known as *blinding*, relies on introducing a certain amount
    of noise in the system by running random or otherwise bogus and unpredictable
    data combined with the actual input to the algorithm in order to make it impossible
    for the attacker to deduct meaningful properties of the input even if the encryption
    algorithm is vulnerable to timing attacks—then discarding the surplus information
    we did not intend to send out. Although the performance penalty is considerably
    lower in this scenario, it is difficult to perform blinding well.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，称为“遮蔽”，通过运行随机或其他虚假且不可预测的数据，结合算法的实际输入，在系统中引入一定量的噪声，以使攻击者无法从输入中推断出有意义的属性，即使加密算法容易受到时间攻击——然后丢弃我们无意发送的额外信息。尽管在这种情况下性能惩罚相对较低，但很难很好地执行遮蔽。
- en: Food for Thought
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考之食
- en: 'I’ve taken you on a long ride, but I hope it was worth it. As usual, I will
    leave you several possibly quite interesting problems to consider:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我带你经历了一段漫长的旅程，但我希望它是值得的。像往常一样，我将给你留下几个可能相当有趣的问题供你思考：
- en: First, although I have focused on the impact that computational complexity attacks
    have on cryptography-related application, the problem is not strictly limited
    to this area, and often manifests itself whenever private or confidential information
    is processed. Certainly, various basic information about HTTP requests or SMTP
    traffic can be deduced by carefully observing the appropriate service on a system;
    can you think of any more practical scenarios?
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，尽管我专注于计算复杂度攻击对密码学相关应用的影响，但这个问题并不严格局限于这个领域，并且通常在处理私人或机密信息时表现出来。当然，通过仔细观察系统上的适当服务，可以推断出有关HTTP请求或SMTP流的各种基本信息；你能想到更多实际的应用场景吗？
- en: Second, even if no secret data is being processed by a service, computational
    complexity information may be of some use. Consider applications such as network
    daemons that prevent disclosure of secrets by providing perhaps overly generic
    error or success messages, with the goal of, for example, making it difficult
    for an attacker to find out whether he is getting “login incorrect” because of
    a mistyped password or a non-existent user. However, depending on the time it
    takes to receive this message, a careful observer may determine which path in
    the code was indeed executed, and whether the error occurred earlier (when just
    checking for a valid username), or later on (when verifying the password). I encourage
    you to experiment with common network services such as SSH, POP3, and Telnet to
    see whether there is a measurable and consistent difference.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，即使服务没有处理任何秘密数据，计算复杂度信息也可能有些用处。考虑一下像网络守护进程这样的应用，它们通过提供可能过于通用的错误或成功消息来防止秘密泄露，目的是例如使攻击者难以确定他是否因为密码输入错误或用户不存在而收到“登录失败”的消息。然而，根据接收此消息所需的时间，一个细心的观察者可能能够确定代码中确实执行了哪条路径，以及错误是在早期（仅检查有效用户名时）还是稍后（在验证密码时）发生的。我鼓励你通过实验常见的网络服务，如SSH、POP3和Telnet，看看是否存在可测量的和一致的区别。
- en: 'As always, even the best defenses against information disclosure tend to fail
    unexpectedly. Too, computational complexity is not the only way to determine what’s
    going on inside a silicon chip. Consider this example: Biham and Shamir^([[56](apb.html#ftn.CHP-2-BIB-5)])
    have devised a brilliant scheme for cracking “secure” chip designs used in smart
    cards. Smart cards are designed to securely store a piece of information such
    as personal identification data or cryptographic keys and to divulge it only to
    certain authentication services and trusted clients. As it turns out, you can
    deduce the properties of the guarded data or the protection mechanism by abusing
    the device and inducing faults due to mechanical stress, high-energy radiation,
    overheating, or similar external factors that cause the device to misbehave.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如往常一样，即使是对信息泄露的最佳防御也往往会意外失败。此外，计算复杂性并不是确定硅芯片内部发生什么情况的唯一方法。考虑以下例子：Biham和Shamir^([[56](apb.html#ftn.CHP-2-BIB-5)])设计了一种巧妙的方法来破解用于智能卡的“安全”芯片设计。智能卡被设计成安全存储个人信息或加密密钥，并且只向特定的认证服务和受信任的客户披露。结果证明，通过滥用设备并诱导由于机械应力、高能辐射、过热或类似的外部因素导致的故障，可以推断出受保护数据或保护机制的性质。
- en: Just thought I’d share.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 只是想分享一下。
- en: Chapter 3. Ten Heads of the Hydra
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 水蛇的十个头
- en: '*Where we explore several other tempting scenarios that occur very early on
    in the process of communications*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在探索过程中非常早期出现的其他诱人场景*'
- en: —
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: In [Chapter 1](ch01.html "Chapter 1. I Can Hear You Typing") and [Chapter 2](ch02.html
    "Chapter 2. Extra Efforts Never Go Unnoticed"), I discussed two distinct information
    disclosure scenarios that occur as a result of brilliant, but in the end poorly
    thought out, attempts to make computers either more functional or easier to maintain.
    The passive snooping vectors these design decisions open are buried deep beneath
    the actual implementation and provide a fascinating insight into the earliest
    threats to processed information.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.html "第一章。我能听到你在打字")和[第二章](ch02.html "第二章。额外的努力永远不会被忽视")中，我讨论了由于设计上的巧妙但最终考虑不周，导致计算机要么功能更强大，要么更容易维护而出现的两种不同的信息披露场景。这些设计决策所开启的被动监听向量隐藏在实际实现的深处，并为处理信息最早期的威胁提供了迷人的洞察。
- en: On the other hand, the exposure is naturally limited to the physical or logical
    proximity of the environment monitored. Although a nearly endless number of information
    disclosure possibilities arise early along the route of a portion of information,
    I’ve chosen to single out these two cases for their uniqueness, beauty, and the
    relative ease with which a potential attack can be carried out by a determined
    attacker. The other scenarios are also worth mentioning, though, and in this chapter,
    I touch on some of the more interesting possibilities that may not warrant a detailed
    discussion but that you might want to explore in more detail on your own.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '另一方面，暴露自然限于被监控环境的物理或逻辑邻近性。尽管在信息泄露的可能性的早期阶段就出现了几乎无穷无尽的可能性，但我选择单独提出这两个案例，因为它们具有独特性、美丽性，以及一个坚定的攻击者相对容易实施潜在攻击的相对容易性。尽管其他场景也值得提及，但在本章中，我简要提到了一些可能不需要详细讨论但你可以自己更深入探索的更有趣的可能性。 '
- en: 'Revealing Emissions: TEMPEST in the TV'
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示的辐射：电视中的TEMPEST
- en: In the 1950s, researchers concluded that electromagnetic radiation (EMR) can
    often be practically and easily used to recover or reconstruct information about
    the behavior of the device emitting it. EMR is undesirable noise caused by virtually
    all electronic, electromechanical, and electric devices, regardless of their design
    and intended purpose, and often propagated over considerable distances via power
    lines or by air.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪50年代，研究人员得出结论，电磁辐射（EMR）通常可以实际且容易地用来恢复或重建发射该辐射的设备的行为信息。EMR是由几乎所有电子、机电和电气设备产生的不可取的噪声，无论其设计和预期用途如何，并且通常通过电力线或空气传播到相当远的距离。
- en: Prior to their findings, the problem of EMR was believed to be relevant to engineering
    due to a risk of unexpected interference between separate devices or circuits,
    but not confirmed to be of any value to a person monitoring the radio frequencies
    polluted by the device. However, with the world on the brink of the era of information
    warfare, and with the development and increasing deployment of electronic data
    processing and telecommunications devices (some used to transfer or store classified
    or sensitive information), the conclusion that a remote observer can reconstruct
    some of the information processed by a system by merely listening to a specific
    frequency became quite worrisome for governments of the free (or not so free)
    world.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的发现之前，电磁辐射问题被认为与工程相关，因为存在不同设备或电路之间意外干扰的风险，但并未证实对监测设备污染的射频频率的人有任何价值。然而，随着世界即将进入信息战时代，以及电子数据处理和电信设备（一些用于传输或存储机密或敏感信息）的发展和不断增加的部署，一个远程观察者仅通过监听特定频率就能重建系统处理的一些信息的结论，对自由（或不太自由的）世界的政府来说变得相当令人担忧。
- en: The term TEMPEST (Transient Electromagnetic Pulse Emanation Standard) originated
    from a classified EMR emissions study commissioned for the U.S. military in the
    1960s and was originally used to denote a set of practices to prevent revealing
    emissions in electronic circuits processing sensitive data. It later became just
    a buzzword for describing a general class of problems and techniques related to
    intercepting and reconstructing radio frequency (RF) emissions.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 术语TEMPEST（瞬态电磁脉冲辐射标准）起源于20世纪60年代为美国军方委托进行的一项机密电磁辐射发射研究，最初用于表示一套防止在处理敏感数据的电子电路中泄露辐射的实践。后来，它仅仅成为描述与截获和重建射频（RF）辐射相关的一般问题和技术的流行语。
- en: Although this risk initially sounded more like bad science-fiction than an actual
    threat in the ears of skeptics, an important research paper released in 1985 by
    Wim van Eck,^([[57](apb.html#ftn.CHP-3-BIB-1)]) demonstrated that it would be—and
    in fact is—quite easy to reconstruct the image displayed on a CRT monitor by intercepting
    radio frequency signals generated by high-voltage circuits inside such a device.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种风险最初在怀疑者的耳朵里听起来更像是一部糟糕的科幻小说，而不是一个实际的威胁，但1985年Wim van Eck发表的一篇重要研究论文^([[57](apb.html#ftn.CHP-3-BIB-1)])证明了通过截获这种设备内部高压电路产生的射频信号，可以非常容易地重建CRT显示器上显示的图像。
- en: A typical CRT (see [Figure 3-1](ch03.html#a_crt_display_image_scan_and_the_buildup
    "Figure 3-1. A CRT display image scan and the buildup process"))builds its display
    by illuminating every pixel of the image in sequence, line by line and then row
    by row, at very high speed, and modulating the strength of the signal depending
    on the location of the screen that is lit up at any moment. To achieve this, a
    narrow beam of electrons is emitted from a cathode gun in the back of the device.
    This electron beam hits the anode (a conductive layer of material on the display),
    which, in turn, emits photons of visible light that we see. The electron beam
    is modulated by a special circuit, but also positioned by a set of electro-magnets
    that cause it to sweep the entire display area from left to right and top to bottom
    to produce and update the image on the screen. Wim noted that the oscillators
    controlling the electromagnets and the electron gun electronics emit several types
    of characteristic signals at standard frequencies. It is rather trivial to spot
    these signals in the radio spectrum,^([[10](#ftn.CHP-3-FN-1)]) and each of the
    signals is usually clear and strong enough to make it easy to build a fairly inexpensive
    device that can snoop on CRT displays, even from a considerable distance.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的CRT显示器（见图3-1[Figure 3-1](ch03.html#a_crt_display_image_scan_and_the_buildup
    "Figure 3-1. A CRT display image scan and the buildup process"))）通过按顺序照亮图像的每个像素，逐行逐行，然后逐行逐行，以非常高的速度构建其显示，并根据任何时刻被照亮的屏幕位置调节信号的强度。为此，从设备后部的阴极枪发射出一束窄电子束。这个电子束击中阳极（显示器上的导电材料层），然后阳极反过来发出我们看到的可见光光子。电子束由一个特殊电路调节，但也由一组电磁铁定位，使它从左到右和从上到下扫过整个显示区域，以产生和更新屏幕上的图像。Wim指出，控制电磁铁和电子枪电子学的振荡器发出几种类型的特征信号，这些信号在标准频率下。在无线电频谱中捕捉这些信号相当简单，^([[10](#ftn.CHP-3-FN-1)])并且每个信号通常都足够清晰和强烈，足以构建一个相当便宜的设备，可以窃听CRT显示器，甚至从相当远的距离。
- en: '![A CRT display image scan and the buildup process](httpatomoreillycomsourcenostarchimages1138018.png.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![CRT显示器图像扫描和建立过程](httpatomoreillycomsourcenostarchimages1138018.png.jpg)'
- en: Figure 3-1. A CRT display image scan and the buildup process
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1. CRT显示器图像扫描和建立过程
- en: Note
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Emissions are, of course, not limited to CRT screens and are just as common
    in LCD (TFT, or thin film transistor) displays and any computer circuitry. They
    are also just as common on databuses, where the information between separate chips
    is carried over a large set of usually fairly long and sharply cornered conductive
    tracks laid out on the main board that, among other things, serve as a great antenna
    (although the ease of extracting and interpreting a specific signal, as well as
    the range of an emission, can vary rather significantly).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 电磁辐射当然不仅限于CRT屏幕，在LCD（TFT，或薄膜晶体管）显示器和任何计算机电路中也很常见。它们在数据总线上的出现同样普遍，信息通过主板上通常相当长且尖锐拐角的大量导电轨道传输，这些轨道除了其他用途外，还充当了一个大天线（尽管提取和解释特定信号以及辐射范围的变化可能相当显著）。
- en: Although there are no verifiable accounts of emission attacks being carried
    out in the wild, other than for military and intelligence applications (particularly
    during the Cold War^([[58](apb.html#ftn.CHP-3-BIB-2)])), some anecdotal accounts
    of industrial espionage can be found in the literature.^([[59](apb.html#ftn.CHP-3-BIB-3)])
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有关于野外进行电磁辐射攻击的可验证报道，除了军事和情报应用（尤其是在冷战期间[[58](apb.html#ftn.CHP-3-BIB-2)]))之外，但在文献中可以找到一些关于工业间谍活动的轶事报道[[59](apb.html#ftn.CHP-3-BIB-3)]）。
- en: 'Obviously, this kind of attack has its limitations: The attacker must be near
    the target. Too, except when snooping on analog CRT displays, the attacker must
    be armed with expensive and nontrivial equipment, especially when snooping on
    today’s low-interference displays and higher CPU and bus speeds. Still, any such
    attack is difficult and costly to prevent.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种攻击有其局限性：攻击者必须靠近目标。此外，除了监听模拟CRT显示器外，攻击者还必须配备昂贵且复杂的设备，尤其是在监听今天低干扰显示器和更高CPU和总线速度的情况下。尽管如此，任何此类攻击都难以防范且成本高昂。
- en: '* * *'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[10](#CHP-3-FN-1)]) For this reason, and because of power line interference,
    “nature radio” enthusiasts who want to listen to earth’s ultra-low frequency signals
    must often travel with their recording equipment to distant, secluded areas.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[10](#CHP-3-FN-1)]) 由于这个原因，以及电源线干扰，想要收听地球超低频信号的“自然无线电”爱好者必须经常携带他们的录音设备前往偏远、隐蔽的地区。
- en: Privacy, Limited
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐私，有限
- en: The exposure scenarios discussed so far can be classified as the undesired or
    unexpected results of the way a specific technology was designed and deployed,
    despite the identical goals or expectations of both the developer and the end
    user. In some cases, however, the exposure results in small differences in the
    goals and expectations of the two groups. Although software-level privacy problems
    resulting from the incompetence or malice of a programmer are notorious and usually
    pervasive, more subtle design problems that are not a flaw per se are also being
    seen. Some of the more interesting groups of problems in this area fall into the
    category of data disclosure in electronic documents.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的暴露场景可以归类为特定技术设计和部署方式的不希望或意外结果，尽管开发者和最终用户的目标或期望是相同的。然而，在某些情况下，暴露结果导致两组的目标和期望存在微小差异。尽管由于程序员的疏忽或恶意导致的软件级隐私问题臭名昭著且通常具有普遍性，但一些不那么明显的设计问题，本身并非缺陷，也开始出现。在这个领域，一些更有趣的问题组属于电子文档数据披露的范畴。
- en: We naturally assume when authoring a document that all information not related
    to the document’s contents (and in particular, any information that uniquely identifies
    the originator) is hidden from other parties able to access the document, unless
    specifically disclosed by the author. But the days of plain-text editors are long
    gone. Today’s document formats support extensive meta-information storage functionality,
    in an effort to make it easier to uniquely tag and later index, search, and track
    documents. What is worrisome, though, is that the designers of authoring tools
    often decide to fill in certain information automatically, frequently giving the
    author little or no control over the process and without making them immediately
    aware of this practice. Although the practice can be considered just another exercise
    in making the environment more user friendly and transparent to the user, the
    lack of widespread awareness of this process is appreciated only by a few.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写文档时自然地假设，与文档内容无关的所有信息（尤其是任何唯一标识原作者的信息）都会被其他能够访问文档的各方隐藏，除非作者明确披露。但纯文本编辑器的时代已经一去不复返了。今天的文档格式支持广泛的元信息存储功能，旨在使文档的独特标记、后续索引、搜索和跟踪变得更加容易。然而，令人担忧的是，编写工具的设计者经常决定自动填写某些信息，通常给予作者很少或没有控制权，并且没有让他们立即意识到这种做法。尽管这种做法可以被视为使环境更加用户友好和透明的另一种练习，但只有少数人对此过程缺乏广泛的认知表示赞赏。
- en: 'Tracking the Source: “He Did It!”'
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪来源：“他做了这件事！”
- en: 'One common problem with authoring software is that certain applications store
    unique identification tags that make it possible to correlate a document with
    its source. In particular, Microsoft Word long used the hardware address of a
    computer’s network card (if the computer had one) to construct a Globally Unique
    Identifier (GUID) field in a document—be it a cookie recipe or a terrorist’s handbook.
    Although the problem has been fixed in the most recent versions of Microsoft’s
    Office suite of applications, the practice has had some interesting implications:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 编写软件的一个常见问题是，某些应用程序存储了唯一标识标签，这使得将文档与其来源相关联成为可能。特别是，Microsoft Word长期以来一直使用计算机网络卡的硬件地址（如果有的话）来在文档中构建一个全局唯一标识符（GUID）字段——无论是饼干食谱还是恐怖分子的手册。尽管这个问题已经在微软Office应用套件的最新版本中得到了解决，但这种做法产生了一些有趣的后果：
- en: Every device has a unique hardware card address. Because hardware addresses
    are used to locate a specific device on a local network, this uniqueness is necessary
    in order to prevent problems that would arise were two computers with the same
    hardware address to connect to the same network. As such, the number recorded
    in the GUID field of a Microsoft Word document can be used to uniquely identify
    the document’s author, whether that person wrote the document anonymously or signed
    it. This can serve both as a valuable forensics investigation tool and as an effective
    way to suppress the freedom of speech in certain situations (by an employer hunting
    down whistle-blowers, for example).
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个设备都有一个唯一的硬件卡地址。由于硬件地址用于在本地网络上定位特定设备，这种唯一性是必要的，以防止两个具有相同硬件地址的计算机连接到同一网络时出现的问题。因此，记录在Microsoft
    Word文档GUID字段中的数字可以用来唯一地识别文档的作者，无论这个人是否匿名编写了文档或签了名。这既可以作为一项有价值的法医调查工具，也可以作为在某些情况下抑制言论自由的有效方式（例如，雇主追查告密者）。
- en: Hardware addresses are assigned in batches to a specific manufacturer. Furthermore,
    in many cases, network cards are manufactured with numbers in sequence and then
    sold in batches to computer manufacturers. Thus, a knowledgeable person can determine
    not only who made a specific card, but also who sold it and to whom. In many situations,
    it can be possible to actually track a specific hardware address to an individual
    machine and, effectively, to a private entity or a particular corporation. This
    might then make it possible for a determined investigator to figure out the origin
    of a specific document.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件地址是分批分配给特定制造商的。此外，在许多情况下，网卡是按顺序制造的，然后批量出售给计算机制造商。因此，一个有知识的人不仅可以确定谁制造了特定的卡，还可以确定谁出售了它以及出售给了谁。在许多情况下，实际上可以将特定的硬件地址追踪到一台特定的机器，并有效地追踪到一个私人实体或特定的公司。这可能会使一个坚定的调查员能够确定特定文档的来源。
- en: Because hardware addresses are assigned in batches, it might also be possible
    to draw limited conclusions as to the hardware configuration of the system on
    which a document was authored. Although this poses a mild threat, it can be an
    interesting source of information for the easily amused or particularly curious.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于硬件地址是批量分配的，也可能有可能从创建文档的系统硬件配置中得出有限的结论。尽管这构成了轻微的威胁，但它可能是容易开心或特别好奇的人有趣的信息来源。
- en: Some functionality, although accessible to the user, is buried deep enough within
    the interface that a typical user is unaware of what is being saved and how to
    change these defaults. Productivity software such as Microsoft Word and [OpenOffice.org](http://openoffice.org)
    are notorious for inserting “default author” information. This information is
    usually taken from the data provided with the software license or automatically
    stored after the first run, deep inside the metadata in the document where most
    users do not bother to look. Although this is a mildly useful feature that comes
    in handy when sharing documents, its privacy implications usually far outweigh
    any eventual benefit for an end user.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 一些功能虽然对用户可用，但被深深埋藏在界面中，以至于典型用户不知道正在保存什么以及如何更改这些默认设置。例如，Microsoft Word和[OpenOffice.org](http://openoffice.org)这样的生产力软件因插入“默认作者”信息而臭名昭著。这些信息通常来自软件许可提供的数据或首次运行后自动存储在文档的元数据深处，而大多数用户不会费心去查看。尽管这是一个在共享文档时有用的功能，但其隐私影响通常远超过对最终用户可能带来的任何潜在好处。
- en: Another example is the “user-friendly” practice of automatically filling the
    “title” field in metaheaders of a document based on the first sentence in the
    document. This is a nice touch, but the selection is often permanent, meaning
    that even if the first paragraph is changed later (so that, for example, the new
    business offer is now addressed to a competitor), the original contents can be
    deduced by a careful observer. This “feature” once again exposes more than the
    author expected to be revealed to the recipient of a document.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是“用户友好”的做法，即根据文档中的第一句话自动填写元头部的“标题”字段。这是一个很好的细节，但选择通常是永久的，这意味着即使后来第一段被更改（例如，新的商业报价现在面向竞争对手），细心观察者也能推断出原始内容。这个“功能”再次暴露了作者预期之外的信息给文档的接收者。
- en: Older versions of Microsoft Word also saved documents without properly clearing
    out all the data that had been edited out, effectively providing undo information,
    and recording all previous revisions of the text. This information could easily
    be recovered later by any sufficiently skilled attacker with software to parse
    object linking and embedding (OLE) containers, the format in which the editor
    stores all its data. The problem is particularly severe when a previous version
    of a document is reused as a template and sent to another party, perhaps a competitor.
    The ability to recover the previous version of an offer, a motivation letter,
    or an official response to a customer is definitely entertaining and enlightening,
    but not always desirable for the sender.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的Microsoft Word也保存了未正确清除所有已编辑数据的文档，实际上提供了撤销信息，并记录了文本的所有先前修订。这些信息可以很容易地被任何足够熟练的攻击者通过解析对象链接和嵌入（OLE）容器（编辑器存储所有数据的格式）的软件恢复。当将文档的先前版本用作模板并发送给另一方，例如竞争对手时，问题尤其严重。恢复报价的先前版本、动机信或对客户的官方回应的能力无疑是令人娱乐和启发的，但并不总是发送者所希望的。
- en: Of course, with the recent push for trusted computing and increased “accountability”
    for the purpose of reducing piracy, it is reasonable to expect that it will become
    commonplace to tag all documents so that they can be traced to their originator.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着最近对可信计算和为减少盗版而增加“问责制”的推动，预期所有文档都将被标记以便追踪其来源，这是合理的。
- en: '“Oops” Exposure: *_~1q''@@ . . . and the Password Is . . .'
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “哎呀”曝光：_*~1q'@@ . . . 以及密码是 . . .
- en: The last group of problems shared by a variety of text editors is that of leaking
    random memory. This type of disclosure is the result of sheer incompetence or
    insufficient testing, but it differs from other coding flaws in that it doesn’t
    so much render the code vulnerable to an attack, as it divulges some useful hints
    to a careful observer. Whether this problem is limited to the program alone or
    is caused by systemwide leaks (the latter on systems with poor memory protection,
    such as Windows 3.*x* or 9*x*), this leaked data can include such sensitive information
    as other documents, browse history, email contents, or even passwords.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 各种文本编辑器共同面临的最后一个问题是随机内存泄露。这种披露纯粹是由于无能或测试不足造成的，但它与其他编码缺陷不同，它更多地是向细心观察者透露一些有用的提示，而不是使代码容易受到攻击。无论这个问题是否仅限于程序本身，还是由系统范围内的泄露（在内存保护较差的系统上，如Windows
    3.*x*或9*x*）引起，泄露的数据可以包括其他文档、浏览历史、电子邮件内容，甚至密码等敏感信息。
- en: The problem occurs when an application allocates a chunk of memory (to an editing
    buffer, for example), perhaps used previously for some other task, and forgets
    to clear it before reusing it for a wholly different purpose. For performance
    reasons, the memory is not always zeroed before being granted to an application.
    The application can then operate on and overwrite only a small portion of the
    chunk of memory, but write the entire allocated block of data when saving the
    file, storing both the data it wanted to and some leftover contents from who knows
    how long ago. And, not surprisingly, older versions of Microsoft Word were once
    notorious for dumping sizable chunks of random memory within almost every document
    produced.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序分配一块内存（例如用于编辑缓冲区），可能之前用于其他任务，并且在重新用于完全不同的目的之前忘记清除它时，就会发生这个问题。出于性能原因，在分配给应用程序之前，内存并不总是被清零。应用程序可以操作并覆盖内存块的一小部分，但在保存文件时，会写入整个分配的数据块，包括它想要的数据和一些来自不知多久以前的遗留内容。而且，不出所料，较老的微软Word版本曾经因在几乎每个文档中丢弃大量随机内存而臭名昭著。
- en: This problem has surfaced a number of times in Microsoft Windows, first in 1998
    on all systems, and then on Mac OS only in 2001\. Some anecdotal evidence suggests
    other sightings, but those are rather poorly documented.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在微软Windows操作系统中多次出现，最早在1998年出现在所有系统上，然后在2001年只出现在Mac OS上。一些轶事证据表明还有其他发现，但这些记录相当不完整。
- en: Chapter 4. Working for the Common Good
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 为公共利益工作
- en: '*Where a question of how the computer may determine the intent of its user
    is raised and left unanswered*'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '*当提出并留下关于计算机如何确定用户意图的问题时*'
- en: —
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: —
- en: The beauty of, but also one of the biggest problems with, any sufficiently extensive
    and diverse computer network is that you cannot blindly trust any connected party
    to be who they claim to be, and it is impossible to determine their intentions
    or the real driving force behind their actions.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 任何足够广泛和多样化的计算机网络的美妙之处，但也是最大的问题之一，是你不能盲目地相信任何连接的方就是他们所声称的那样，而且无法确定他们的意图或他们行动背后的真实驱动力。
- en: I’ll discuss the issue of confirming the identity of a source in the third part
    of this book, when I dissect the architecture of the network and explore the risks
    that result from the way a network is built. However, the issue of the originator’s
    intentions is a separate and fascinating aspect of computer security, with often
    serious and far-fetched social and judicial implications that extend beyond the
    world of computing. As we make computers better and better at predicting what
    their users want to do (itself a means of achieving intuitiveness and ease of
    use) and give them more autonomy, it becomes increasingly easy to trick machines
    into becoming a tool to be used by someone else, instead of helping the user.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书的第三部分讨论确认来源身份的问题，届时我将剖析网络架构并探讨由此产生的风险。然而，发起者意图的问题是计算机安全的一个独立且迷人的方面，它通常具有严重且牵涉广泛的社交和法律影响，这些影响超出了计算领域。随着我们使计算机在预测用户想要做什么（这是一种实现直观性和易用性的手段）方面越来越好，并赋予它们更多的自主权，欺骗机器成为他人使用的工具变得越来越容易，而不是帮助用户。
- en: A long river of words has been written on the subject, followed by a number
    of heated disputes about where to put the blame and whom to sue when things go
    wrong. I believe it is important to tackle the problem but not appropriate to
    impose any particular viewpoint on you. As such, I will close this section of
    the book with a short and mostly technical paper that I originally published in
    2001 in *Phrack* magazine, vol. 57\. I’ve made some minor edits to it and will
    refrain from further commentary.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题已经写下了长篇大论，随后是一系列关于当事情出错时应该把责任归咎于谁以及应该起诉谁的激烈争论。我相信解决这个问题是重要的，但并不适合强加任何特定的观点给你。因此，我将用一篇简短且主要技术性的论文结束这本书的这一部分，这篇论文我最初于2001年在*Phrack*杂志第57期上发表。我对它做了一些小的编辑，并将避免进一步的评论。
- en: 'Let me dig it up . . . /me searches for paper . . . Ah, here it is:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来找找……/我在找纸张……啊，找到了：
- en: '[PRE3]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It appears nearly impossible to fully prevent the automated abuse without the
    ability to anticipate and classify the actual intent behind a particular user
    action, which is not likely to happen any time soon. Meanwhile, the number of
    systems that rely on automated interaction with other entities increases every
    year, making this issue perhaps even more interesting than when I originally wrote
    this article, particularly with more and more sophisticated and populous worms
    hitting the Internet in the past several years.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有能力预测和分类特定用户行为背后的实际意图的情况下，几乎不可能完全防止自动化滥用，而这种情况在短期内不太可能发生。与此同时，每年依赖与其它实体自动化交互的系统数量都在增加，这使得这个问题可能比最初写这篇文章时更有趣，尤其是在过去几年中，越来越多的复杂和数量庞大的蠕虫病毒袭击了互联网。
- en: Is there a moral to this story or a clear conclusion we should be drawing? Not
    really. It is, however, important to remember that machines do not always act
    on behalf of their operators, even when they are not clearly compromised or downright
    abused to become hostile. Determining the intent and the place where the desire
    to carry out a malicious action originated may be a tremendous challenge, as you’ll
    see in later chapters.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事有没有道德寓意或者我们应该得出的明确结论？实际上并没有。然而，记住这一点很重要，即机器并不总是代表其操作者行事，即使它们并没有被明显地损害或直接滥用以变得敌对。确定意图和恶意行为欲望起源的地点可能是一个巨大的挑战，正如你将在后面的章节中看到的。
