- en: Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-3. 互联网协议版本 4 (IP/IPV4)
- en: '[Chapter 15](ch15.html "Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND
    OVERVIEW")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html "第15章. 互联网协议版本、概念和概述")'
- en: '[Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16章](ch16.html "第16章. IPv4 寻址概念和问题")'
- en: '[Chapter 17](ch17.html "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](ch17.html "第17章. 类别 (传统) 寻址")'
- en: '[Chapter 18](ch18.html "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.html "第18章. IP 子网寻址 (子网划分) 概念")'
- en: '[Chapter 19](ch19.html "Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND
    ADDRESS DETERMINATION EXAMPLE")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19章](ch19.html "第19章. IP 子网划分 实践子网设计和地址确定示例")'
- en: '[Chapter 20](ch20.html "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN
    ROUTING (CIDR)/SUPERNETTING")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第20章](ch20.html "第20章. 无类 IP 地址——无类域间路由 (CIDR)/超网")'
- en: '[Chapter 21](ch21.html "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION
    AND FORMATTING")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第21章](ch21.html "第21章. 互联网协议数据报封装和格式")'
- en: '[Chapter 22](ch22.html "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22章](ch22.html "第22章. IP 数据报大小、分片和重组")'
- en: '[Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING")'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[第23章](ch23.html "第23章. IP 路由和多播")'
- en: The idea of singling out any one protocol as being more important than the others
    in a network is kind of pointless, if you think about it. The protocols and technologies
    work as a team to accomplish the goal of communication across the network. As
    with any team, no single member can get the job done alone, no matter how good
    it is. Still, if we were to try to pick a "most valuable player" in the world
    of networking, a good case could be made that we have it in the TCP/IP *Internet
    Protocol (IP)*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑到网络中任何一种协议比其他协议更重要，那么这种想法似乎有点没有意义。协议和技术作为一个团队工作，以实现网络通信的目标。就像任何团队一样，无论成员多么优秀，没有单个成员能够独立完成任务。尽管如此，如果我们试图在网络世界中挑选一个“最有价值球员”，那么可以说我们找到了
    TCP/IP 的 *互联网协议 (IP)*。
- en: Even though it gets second billing in the name of the TCP/IP protocol suite,
    IP is the workhorse of TCP/IP. It implements key network layer functions including
    addressing, datagram handling, and routing, and it is the foundation on which
    other TCP/IP protocols are built. Even the ones lower in the TCP/IP architecture,
    such as the Address Resolution Protocol (ARP) and the Point-to-Point Protocol
    (PPP), are easier to understand when you know how IP works.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 TCP/IP 协议套件的名称中它排在第二位，IP 协议仍然是 TCP/IP 的主力。它实现了关键的网络层功能，包括寻址、数据报处理和路由，并且是其他
    TCP/IP 协议建立的基础。即使是 TCP/IP 架构中较低层的协议，如地址解析协议 (ARP) 和点对点协议 (PPP)，在了解 IP 协议的工作原理后也更容易理解。
- en: This part includes nine chapters that provide considerable coverage of IP. The
    first chapter gives an overview of IP as a whole, including a discussion of its
    versions, while the rest of the chapters focus on the details of operation of
    the most popular current version of the protocol, *IP version 4 (IPv4)*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括九个章节，对 IP 协议进行了相当全面的介绍。第一章对 IP 协议的整体进行了概述，包括对其版本的讨论，而其余章节则专注于当前最受欢迎的协议版本——*IP
    版本 4 (IPv4)* 的操作细节。
- en: The second through sixth chapters discuss in great detail the concepts and practice
    behind IP addressing. The second chapter provides an overview of IPv4 addressing
    concepts and issues. The third discusses the original, class-based (*classful*)
    IP addressing scheme and how the different classes work. The fourth and fifth
    chapters are devoted to IP subnets and subnet addressing. They discuss subnetting
    concepts and include an illustration of practical step-by-step subnetting. The
    sixth chapter describes the new classless addressing system, also sometimes called
    *supernetting*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二至第六章详细讨论了 IP 寻址的概念和实践。第二章提供了 IPv4 寻址概念和问题的概述。第三章讨论了原始的基于类别的 (*类别*) IP 寻址方案以及不同类别的工作方式。第四和第五章致力于
    IP 子网和子网寻址。它们讨论了子网划分的概念，并包括了一个实际步骤的子网划分示例。第六章描述了新的无类别寻址系统，有时也称为 *超网*。
- en: The seventh through ninth chapters discuss important practical issues related
    to how IPv4 datagrams are created and handled. You'll find a full description
    of the IPv4 message format and options in the seventh chapter; explanations of
    IP datagram sizing, fragmentation, and reassembly in the eighth chapter; and coverage
    of routing and multicasting in the ninth chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第七章到第九章讨论了与IPv4数据报创建和处理相关的重要实际问题。你将在第七章中找到IPv4消息格式和选项的完整描述；第八章中解释了IP数据报的大小、分片和重组；第九章涵盖了路由和多播。
- en: As the title of this part implies, the coverage here is limited to IPv4\. (For
    simplicity, in this part, I use the simpler designation *IP* rather than *IPv4*,
    except where the version number is required for clarity.) IP version 6 (IPv6)
    is covered in its separate section ([Part II-4](pt07.html "Part II-4. INTERNET
    PROTOCOL VERSION 6 (IPV6)")), as are the IP-related protocols. That said, some
    of the principles here will also apply to IPv6, as well as IP Network Address
    Translation (NAT), IPsec, and Mobile IP ([Part II-4](pt07.html "Part II-4. INTERNET
    PROTOCOL VERSION 6 (IPV6)")) in a limited manner.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如本部分标题所示，这里的覆盖范围仅限于IPv4。为了简单起见，在本部分中，我使用更简单的标识符*IP*而不是*IPv4*，除非需要清晰地区分版本号。IPv6（IP版本6）在其单独的部分（[第二部分-4](pt07.html
    "第二部分-4. 互联网协议版本6 (IPv6)"))中介绍，以及与IP相关的协议。尽管如此，这里的一些原则也将以有限的方式适用于IPv6，以及IP网络地址转换（NAT）、IPsec和移动IP（[第二部分-4](pt07.html
    "第二部分-4. 互联网协议版本6 (IPv6)"))。
- en: Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND OVERVIEW
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章：互联网协议版本、概念和概述
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The Internet Protocol (IP) is a very important protocol in internetworking.
    It would be no exaggeration to say that you can't really comprehend modern networking
    without a good understanding of IP. Unfortunately, IP can be somewhat difficult
    to understand. A large amount of complexity has become associated with it over
    the years, and this has allowed it to meet the many demands placed on it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）是互联网互连中非常重要的一个协议。可以说，没有对IP的良好理解，你实际上是无法真正理解现代网络的。不幸的是，IP可能有些难以理解。多年来，大量复杂性与之相关联，这使得它能够满足所面临的众多需求。
- en: Before diving into the details of how IP works, we'll look at the basic concepts
    underlying IP. In this chapter, I explain how IP operates in basic terms and the
    most important aspects of how it does its job. We'll look at its main functions,
    its history, and how it has spawned the development of several IP-related protocols.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨IP的工作原理之前，我们将先了解IP的基本概念。在本章中，我将用基本术语解释IP的工作原理以及它完成工作的最重要的方面。我们将探讨其主要功能、历史以及它是如何催生多个与IP相关的协议的发展。
- en: IP Overview and Key Operational Characteristics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP概述和关键操作特性
- en: IP is the core of the TCP/IP protocol suite and the main protocol at the network
    layer. The network layer is primarily concerned with the delivery of data between
    devices that may be on different networks, which are interconnected in an arbitrary
    manner. In other words, an *internetwork*. IP is the mechanism by which this data
    is sent on TCP/IP networks (with help from other protocols at the network layer,
    too, of course).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: IP是TCP/IP协议族的核心，也是网络层的主要协议。网络层主要关注在不同网络之间传输数据，这些网络以任意方式相互连接。换句话说，就是一个*互联网*。IP是通过这种机制在TCP/IP网络上发送数据（当然，也需要网络层其他协议的帮助）。
- en: 'Let''s look at the TCP/IP layer model and consider what IP does from an architectural
    standpoint. As the layer 3 protocol, it provides a service to layer 4 in the TCP/IP
    stack, represented mainly by the Transmission Control Protocol (TCP) and User
    Datagram Protocol (UDP) (see [Part II-8](pt11.html "Part II-8. TCP/IP TRANSPORT
    LAYER PROTOCOLS")). IP takes data that has been packaged by either TCP or UDP,
    manipulates it as necessary, and sends it out (see [Figure 15-1](ch15.html#the_main_function_of_ip_internetwork_dat
    "Figure 15-1. The main function of IP: internetwork datagram delivery IP''s overall
    responsibility is to deliver data between devices on unconnected networks. This
    figure shows how IP delivers datagrams from one device to another over an internetwork;
    in this case, a distant client and server communicate with each other by passing
    IP datagrams over a series of interconnected networks.")).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看TCP/IP层模型，并从架构的角度考虑IP的功能。作为第3层协议，它为TCP/IP堆栈的第4层提供服务，主要由传输控制协议（TCP）和用户数据报协议（UDP）代表（见[第二部分-8](pt11.html
    "第二部分-8. TCP/IP传输层协议")）。IP接收由TCP或UDP打包的数据，根据需要对其进行操作，并将其发送出去（见[图15-1](ch15.html#the_main_function_of_ip_internetwork_dat
    "图15-1. IP的主要功能：互联网数据报传输 IP的整体责任是在未连接的网络设备之间传输数据。此图展示了IP如何在互联网中从一个设备向另一个设备传输数据报；在这种情况下，远程客户端和服务器通过在一系列互联网络中传递IP数据报来相互通信。")）。
- en: This service is sometimes called *internetwork datagram delivery*. There are
    many details that explain exactly how this service is accomplished, but in a nutshell,
    IP sends data from point A to point B over an internetwork of connected networks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务有时被称为互联网数据报传输。有许多细节解释了这项服务是如何完成的，但简而言之，IP通过连接的网络互联网从A点发送数据到B点。
- en: '![The main function of IP: internetwork datagram delivery IP''s overall responsibility
    is to deliver data between devices on unconnected networks. This figure shows
    how IP delivers datagrams from one device to another over an internetwork; in
    this case, a distant client and server communicate with each other by passing
    IP datagrams over a series of interconnected networks.](httpatomoreillycomsourcenostarchimages287789.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![IP的主要功能：互联网数据报传输 IP的整体责任是在未连接的网络设备之间传输数据。此图展示了IP如何在互联网中从一个设备向另一个设备传输数据报；在这种情况下，远程客户端和服务器通过在一系列互联网络中传递IP数据报来相互通信。](httpatomoreillycomsourcenostarchimages287789.png.jpg)'
- en: 'Figure 15-1. The main function of IP: internetwork datagram delivery IP''s
    overall responsibility is to deliver data between devices on unconnected networks.
    This figure shows how IP delivers datagrams from one device to another over an
    internetwork; in this case, a distant client and server communicate with each
    other by passing IP datagrams over a series of interconnected networks.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-1. IP的主要功能：互联网数据报传输 IP的整体责任是在未连接的网络设备之间传输数据。此图展示了IP如何在互联网中从一个设备向另一个设备传输数据报；在这种情况下，远程客户端和服务器通过在一系列互联网络中传递IP数据报来相互通信。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** While the *Internet Protocol* has many functions and characteristics,
    it can be boiled down to one primary purpose: the delivery of datagrams across
    an internetwork of connected networks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 虽然互联网协议有许多功能和特性，但它可以归结为一个主要目的：在连接的网络互联网中传输数据报。'
- en: 'Of course, there are many ways in which IP could have been implemented in order
    to accomplish this task. To understand how the designers of TCP/IP made IP work,
    let''s take a look at the key characteristics used to describe IP and the general
    manner in which it operates:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有许多方法可以实现IP来完成这项任务。为了了解TCP/IP的设计者是如何让IP工作的，让我们来看看描述IP的关键特性以及它的一般操作方式：
- en: '**Universally Addressed** In order to send data from point A to point B, it
    is necessary to ensure that devices know how to identify which device is point
    B. IP defines the addressing mechanism for the network and uses these addresses
    for delivery purposes.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用寻址** 为了从A点发送数据到B点，必须确保设备知道如何识别B点。IP定义了网络的寻址机制，并使用这些地址进行传输目的。'
- en: '**Underlying Protocol-Independent** IP is designed to allow the transmission
    of data across any type of underlying network that is designed to work with a
    TCP/IP stack. It includes provisions that allow it to adapt to the requirements
    of various lower-level protocols such as Ethernet or IEEE 802.11\. IP can also
    run on the special data link protocols, Serial Line Interface Protocol (SLIP)
    and Point-to-Point Protocol (PPP), that were created for it (see [Part II-1](pt04.html
    "Part II-1. TCP/IP NETWORK INTERFACE LAYER PROTOCOLS")). An important example
    is IP''s ability to fragment large blocks of data into smaller ones in order to
    match the size limitations of physical networks, and then have the recipient reassemble
    the pieces again as needed.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**底层协议无关** IP 被设计成允许数据跨越任何类型的底层网络传输，这些网络被设计成与 TCP/IP 堆栈一起工作。它包括允许其适应各种底层协议（如以太网或
    IEEE 802.11）要求的条款。IP 还可以在为它专门创建的特殊数据链路协议上运行，例如串行线路接口协议（SLIP）和点对点协议（PPP）（请参阅[第二部分第
    1 章](pt04.html "第二部分第 1 章. TCP/IP 网络接口层协议"））。一个重要的例子是 IP 能够将大量数据分成小块，以匹配物理网络的大小限制，然后根据需要让接收方重新组装这些数据块。'
- en: '**Connectionless Delivery** IP is a *connectionless protocol*. This means that
    when point A wants to send data to point B, it doesn''t first set up a connection
    to point B and then send the data—it just makes the datagram and sends it. (See
    the section in [Chapter 1](ch01.html "Chapter 1. NETWORKING INTRODUCTION, CHARACTERISTICS,
    AND TYPES") on connection-oriented and connectionless protocols for more information
    on this.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**无连接交付** IP 是一种 *无连接协议*。这意味着当点 A 想要向点 B 发送数据时，它不会首先与点 B 建立连接然后发送数据——它只是创建数据报并发送。有关面向连接和无连接协议的更多信息，请参阅[第
    1 章](ch01.html "第 1 章. 网络简介、特性和类型"）中的相关部分。'
- en: '**Unreliable Delivery** IP is said to be an unreliable protocol. That doesn''t
    mean that one day your IP software will decide to go fishing rather than run your
    network. It does mean that when datagrams are sent from Device A to Device B,
    Device A just sends each one and then moves on to the next. IP doesn''t keep track
    of the ones it sent. It does not provide reliability or service-quality capabilities,
    such as error protection for the data it sends (though it does on the IP header),
    flow control, or retransmission of lost datagrams. For this reason, IP is sometimes
    called a *best-effort* protocol. It does what it can to get data to where it needs
    to go, but makes no guarantees that the data will actually get there.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可靠交付** 人们常说 IP 是一种不可靠的协议。这并不意味着有一天你的 IP 软件会决定去钓鱼而不是运行你的网络。这确实意味着当数据报从设备
    A 发送到设备 B 时，设备 A 只会发送每一个，然后继续下一个。IP 不会跟踪它发送的数据。它不提供可靠性或服务质量功能，例如对发送的数据进行错误保护（尽管它在
    IP 头中这样做），流量控制或重传丢失的数据报。因此，IP 有时被称为 *尽力而为* 协议。它尽力将数据送到需要的地方，但不会保证数据实际上会到达那里。'
- en: '**Unacknowledged Delivery** Corresponding with its unreliable nature, IP doesn''t
    use acknowledgements. When Device B gets a datagram from Device A, it doesn''t
    send back a "thank you note" to tell Device A that the datagram was received.
    It leaves Device A in the dark, so to speak.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**无确认交付** 与其不可靠的特性相对应，IP 不使用确认。当设备 B 从设备 A 接收到数据报时，它不会发送回一个“感谢信”来告诉设备 A 数据报已被接收。它让设备
    A 处于黑暗中，换句话说。'
- en: These last three characteristics might be enough to make you cringe, thinking
    that giving your data to IP would be somewhat like trusting a new car to your
    16-year-old son. If you are going to build an entire network around this protocol,
    why design it so that it works without connections, doesn't guarantee that the
    data will get there, and has no means of acknowledging receipt of data?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后三个特性可能足以让你感到不适，认为将数据交给 IP 就像是将新车托付给你的 16 岁儿子一样。如果你打算围绕这个协议构建整个网络，为什么还要设计它以使其在没有连接的情况下工作，不保证数据会到达，并且没有确认数据接收的手段呢？
- en: 'The reason is simple: Establishing connections, guaranteeing delivery, error
    checking, and similar insurance-type functions have a cost in *performance*. It
    takes time, computer resources, and network bandwidth to perform these tasks,
    and they aren''t always necessary for every application. Now, consider that IP
    carries pretty much *all* user traffic on a TCP/IP network. To build this complexity
    into IP would burden all traffic with this overhead, whether or not it was needed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单：建立连接、保证交付、错误检查和类似的保险类型功能都会在*性能*上产生成本。执行这些任务需要时间、计算机资源和网络带宽，而且它们并不总是对每个应用程序都是必要的。现在，考虑到IP在TCP/IP网络上承载了几乎所有用户流量。将这种复杂性构建到IP中将会使所有流量都承担这种开销，无论是否需要。
- en: 'The solution taken by the designers of TCP/IP was to exploit the power of layering.
    If service-quality features such as connections, error checking, or guaranteed
    delivery are required by an application, they are provided at the transport layer
    (or possibly, the application layer). On the other hand, applications that don''t
    need these features can avoid using them. This is the major distinction between
    the two TCP/IP transport layer protocols: TCP and UDP. TCP is full featured but
    a bit slower than UDP; UDP is spartan in its capabilities, but faster than TCP.
    This system is really the best of both worlds, and it works.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP的设计者采取的解决方案是利用分层的力量。如果一个应用程序需要诸如连接、错误检查或保证交付等服务质量特性，它们将在传输层（或可能的应用层）提供。另一方面，不需要这些特性的应用程序可以避免使用它们。这是两个TCP/IP传输层协议（TCP和UDP）之间的主要区别：TCP功能全面但比UDP慢；UDP在功能上较为简陋，但比TCP快。这个系统实际上是两者的最佳结合，并且它确实有效。
- en: IP Functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP功能
- en: 'The exact number of IP functions depends on where you draw the line between
    certain activities. For explanatory purposes, however, I view IP as having four
    basic functions (or more accurately, function sets):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: IP的确切功能数量取决于你在哪些活动之间划界。然而，为了解释目的，我认为IP有四个基本功能（或者更准确地说，功能集）：
- en: '**Addressing** Before it can deliver datagrams, IP must know where to deliver
    them. For this reason, IP includes a mechanism for host addressing. Furthermore,
    since IP operates over internetworks, its system is designed to allow for the
    unique addressing of devices across arbitrarily large networks. It also contains
    a structure to facilitate the routing of datagrams to distant networks, if that
    is required. Since most of the other TCP/IP protocols use IP, an understanding
    the IP addressing scheme is of vital importance to comprehending much of what
    goes on in TCP/IP. It is explored fully in Chapters [Chapter 16](ch16.html "Chapter 16. IPV4
    ADDRESSING CONCEPTS AND ISSUES") through [Chapter 20](ch20.html "Chapter 20. IP
    CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING").'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址解析** 在IP能够交付数据报文之前，它必须知道将它们发送到何处。因此，IP包含了一个用于主机地址解析的机制。此外，由于IP在互联网中运行，其系统设计为允许在任意大的网络中对设备进行唯一地址分配。它还包含了一个结构，以便在需要时将数据报文路由到远程网络。由于大多数其他TCP/IP协议都使用IP，因此理解IP地址方案对于理解TCP/IP中的许多内容至关重要。这在第[第16章](ch16.html
    "第16章. IPV4地址概念和问题")到[第20章](ch20.html "第20章. 无类地址——无类域间路由(CIDR)/超网")中进行了全面探讨。'
- en: '**Data Encapsulation and Formatting/Packaging** As the TCP/IP network layer
    protocol, IP accepts data from the transport layer protocols UDP and TCP. It then
    encapsulates this data into an IP datagram using a special format prior to transmission.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据封装和格式化/包装** 作为TCP/IP网络层协议，IP从传输层协议UDP和TCP接收数据。然后，它使用一种特殊格式在传输之前将此数据封装成IP数据报。'
- en: '**Fragmentation and Reassembly** IP datagrams are passed down to the data link
    layer for transmission on the local network. However, the maximum frame size of
    each physical and data link network using IP may be different. For this reason,
    IP includes the ability to *fragment* IP datagrams into pieces, so that they can
    each be carried on the local network. The receiving device uses the *reassembly*
    function to re-create the whole IP datagram. Some people view fragmentation and
    reassembly as distinct functions, though clearly they are complementary, and I
    view them as being part of the same job.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片和重组** IP数据报被传递到数据链路层，以便在本地网络上进行传输。然而，使用IP的每个物理和数据链路网络的最大帧大小可能不同。因此，IP包括将IP数据报分成片段的能力，这样它们就可以分别携带到本地网络。接收设备使用*重组*功能来重新创建整个IP数据报。尽管很明显它们是互补的，但有些人将分片和重组视为不同的功能，而我将它们视为同一工作的组成部分。'
- en: '**Routing and Indirect Delivery** When an IP datagram must be sent to a destination
    on the same local network, you can do this easily with the network''s underlying
    local area network (LAN), wireless LAN (WLAN), or wide area network (WAN) protocol,
    using what is sometimes called *direct delivery*. However, in many (if not most
    cases) the final destination is on a distant network that isn''t directly attached
    to the source. In this situation, the datagram must be delivered indirectly. This
    is accomplished by routing the datagram through intermediate devices (*routers*).
    IP accomplishes this in concert with support from the other protocols including
    the Internet Control Message Protocol (ICMP) and the TCP/IP gateway/routing protocols
    such as the Routing Information Protocol (RIP) and the Border Gateway Protocol
    (BGP).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由和间接投递** 当一个IP数据报必须发送到同一本地网络上的目的地时，你可以通过使用网络的底层局域网（LAN）、无线局域网（WLAN）或广域网（WAN）协议，以所谓的*直接投递*方式轻松完成。然而，在许多（如果不是大多数情况下），最终目的地是在一个与源不直接相连的远程网络上。在这种情况下，数据报必须间接投递。这是通过将数据报通过中间设备（*路由器*）进行路由来实现的。IP与包括互联网控制消息协议（ICMP）和TCP/IP网关/路由协议（如路由信息协议RIP和边界网关协议BGP）在内的其他协议的支持下完成这一任务。'
- en: IP History, Standards, Versions, and Closely Related Protocols
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP的历史、标准、版本和密切相关协议
- en: Since IP is really the architectural foundation for the entire TCP/IP protocol
    suite, you might have expected that it was created first, and that the other protocols
    were built upon it. That's usually how you build a structure, after all! The history
    of IP, however, is a bit more complex. The functions it *performs* were defined
    at the birth of the protocol, but IP itself didn't exist for the first few years
    that the protocol suite was being defined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP实际上是整个TCP/IP协议套件的架构基础，你可能预计它是最先被创建的，其他协议都是建立在它之上的。毕竟，这是构建结构的方式！然而，IP的历史要复杂得多。它的功能在协议诞生时就已经定义，但在定义协议套件的最初几年里，IP本身并不存在。
- en: I explore the early days of TCP/IP in [Chapter 8](ch08.html "Chapter 8. TCP/IP
    PROTOCOL SUITE AND ARCHITECTURE"), which provides an overview of the suite as
    a whole. What is notable about the development of IP is that its functions were
    originally part of TCP. As a formal protocol, IP was born when an early version
    of TCP developed in the 1970s for predecessors of the modern Internet was split
    into TCP at layer 4 and IP at layer 3\. The key milestone in the development of
    IP was the publication of RFC 791, "Internet Protocol," in September 1981\. This
    standard, a revision of the similar RFC 760 of the previous year, defined the
    core functionality and characteristics of the version of IP that has been in widespread
    use for the last two decades.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第8章](ch08.html "第8章。TCP/IP协议套件和架构")中探讨了TCP/IP的早期阶段，该章提供了整个套件的概述。IP发展的一个显著特点是，它的功能最初是TCP的一部分。作为一个正式的协议，IP是在20世纪70年代为现代互联网的前身开发的一个早期版本的TCP中，当它在第4层分割成TCP，在第3层分割成IP时诞生的。IP发展的关键里程碑是1981年9月发布的RFC
    791，“互联网协议”。这个标准是前一年类似RFC 760的修订版，定义了在过去二十年里广泛使用的IP版本的核心功能和特性。
- en: IP Versions and Version Numbers
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP版本和版本号
- en: The IP defined in RFC 791 was the first widely used version of IP. Interestingly,
    however, it is not version 1 of IP but version 4! This would of course imply that
    there were earlier versions of the protocol at one point. Interestingly, however,
    there really weren't. IP was created when its functions were split out from an
    early version of TCP that combined both TCP and IP functions. TCP evolved through
    three earlier versions and was split into TCP and IP for version 4\. That version
    number was applied to both TCP and IP for consistency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 791中定义的IP是第一个广泛使用的IP版本。然而，有趣的是，这并不是IP的第1版，而是第4版！这当然意味着在某个时候，该协议有更早的版本。然而，实际上并没有。IP是在其功能从早期版本的TCP中分离出来时创建的，该TCP结合了TCP和IP的功能。TCP通过三个更早的版本演变，并在第4版时被分割成TCP和IP。这个版本号被应用于TCP和IP以保持一致性。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Version 4 of the *Internet Protocol* (IP) is actually the first
    version that was widely deployed and is currently the one in widespread use.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 第4版的*互联网协议*（IP）实际上是第一个广泛部署的版本，目前仍在广泛使用。'
- en: So, when you use IP today, you are using IP version 4, which is frequently abbreviated
    IPv4\. Unless otherwise qualified, it's safe to assume that *IP* means IP version
    4—at least for the next few years. (This version number is carried in the appropriate
    field of all IP datagrams, as described in the topic discussing the IP datagram
    format in [Chapter 21](ch21.html "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION
    AND FORMATTING").)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你今天使用IP时，你使用的是IP版本4，通常简称为IPv4。除非另有说明，否则可以安全地假设*IP*指的是IP版本4——至少在未来几年内是这样。（这个版本号包含在所有IP数据报的适当字段中，如[第21章](ch21.html
    "第21章. 互联网协议数据报封装和格式")中讨论的IP数据报格式所述。）
- en: Given that it was originally designed for an internetwork a tiny fraction of
    the size of our current Internet, IPv4 has proven itself remarkably capable. Various
    additions and changes have been made over time to how IP is used, especially with
    respect to addressing, but the core protocol is basically what it was in the early
    1980s. There's good reason for this. Changing something as fundamental as IP requires
    a great deal of development effort and also introduces complexities during transition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到它最初是为一个比我们当前互联网小得多的互连网设计的，IPv4已经证明了自己具有非凡的能力。随着时间的推移，对IP的使用方式进行了各种补充和变更，尤其是在地址方面，但核心协议基本上与20世纪80年代初相同。这有很好的理由。改变像IP这样基本的东西需要大量的开发工作，并且在过渡期间也会引入复杂性。
- en: IPv4 has served us well, but people understood that, for various reasons, a
    new version of IP would eventually be required. Due to the difficulties associated
    with making such an important change, development of this new version of IP has
    actually been under way since the mid-1990s. This new version of IP is formally
    called *Internet Protocol version 6 (IPv6)* and also sometimes referred to as
    *IP Next Generation* or *IPng*. I discuss the reasons why IPv6 was developed and
    how it differs from IPv4 in considerable detail in [Part II-4](pt07.html "Part II-4. INTERNET
    PROTOCOL VERSION 6 (IPV6)") of this book.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4为我们服务得很好，但人们理解，由于各种原因，最终将需要一个新的IP版本。由于进行如此重要变更的困难，这个新版本的IP开发实际上从20世纪90年代中期就开始了。这个新版本的IP正式称为*互联网协议版本6（IPv6）*，有时也被称为*IP下一代*或*IPng*。我在本书的[第二部分-4](pt07.html
    "第二部分-4. 互联网协议版本6 (IPv6)")中详细讨论了IPv6的开发原因以及它与IPv4的不同之处。
- en: A natural question at this point is, "What happened to version 5 of IP?" The
    answer is that it doesn't exist. While this may seem confusing, version 5 was
    in fact intentionally skipped in order to *avoid* confusion, or at least to rectify
    it. The problem with version 5 relates to an experimental TCP/IP protocol called
    the *Internet Stream Protocol, version 2*, originally defined in RFC 1190\. This
    protocol was originally seen by some as being a peer of IP at the Internet layer
    in the TCP/IP architecture, and in its standard version, these packets were assigned
    IP version 5 to differentiate them from normal IP packets (version 4). This protocol
    apparently never went anywhere, but to be absolutely sure that there would be
    no confusion, version 5 was skipped over in favor of version 6.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，一个自然的问题就是，“IP的第五版发生了什么？”答案是它根本不存在。虽然这可能会让人感到困惑，但第五版实际上是有意跳过的，以*避免*混淆，或者至少是纠正它。第五版的问题与一个名为*互联网流协议，版本2*的实验性TCP/IP协议有关，最初在RFC
    1190中定义。这个协议最初被一些人视为TCP/IP架构中互联网层IP的同等协议，在其标准版本中，这些数据包被分配了IP版本5，以区分它们与正常的IP数据包（版本4）。这个协议显然并没有走得太远，但为了绝对确保不会有混淆，版本5被跳过，转而使用版本6。
- en: IP-Related Protocols
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与IP相关的协议
- en: 'In addition to the old and new versions of IP, there are several protocols
    that are *IP-related*. These are protocols that add to or expand on the capabilities
    of IP functions for special circumstances, but they are not part of IP proper.
    These are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了旧的和新的IP版本之外，还有一些*与IP相关的*协议。这些协议是为了在特殊情况下增强或扩展IP功能，但它们不是IP本身的一部分。具体如下：
- en: '**IP Network Address Translation (IP NAT or NAT)** This protocol provides IP
    address translation capabilities that allow private networks to be interfaced
    to public networks in a flexible manner. It allows public IP addresses to be shared
    and improves security by making it more difficult for hosts on the public network
    to gain unauthorized access to hosts. It is commonly called *NAT*. This protocol
    is discussed in [Chapter 28](ch28.html "Chapter 28. IP NETWORK ADDRESS TRANSLATION
    (NAT) PROTOCOL").'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP网络地址转换（IP NAT或NAT）** 该协议提供了IP地址转换功能，允许以灵活的方式将私有网络连接到公共网络。它允许共享公共IP地址，并通过使公共网络上的主机更难未经授权访问主机来提高安全性。它通常被称为*NAT*。本协议在[第28章](ch28.html
    "第28章。IP网络地址转换（NAT）协议")中进行了讨论。'
- en: '**IP Security (IPsec)** IPsec defines a set of subprotocols that provide a
    mechanism for the secure transfer of data using IP. It is rapidly growing in popularity
    as a security protocol that enables virtual private networks. This protocol is
    discussed in [Chapter 29](ch29.html "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS").'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP安全（IPsec）** IPsec定义了一组子协议，提供了一种使用IP安全传输数据的机制。作为能够启用虚拟专用网络的安全协议，它正迅速增长其受欢迎程度。本协议在[第29章](ch29.html
    "第29章。IP安全（IPsec）协议")中进行了讨论。'
- en: '**Mobile IP** This is a protocol that addresses some of the difficulties associated
    with using IP on computers that frequently move from one network to another. It
    provides a mechanism that allows data to be automatically routed to a mobile host
    (such as a notebook computer), without requiring a constant reconfiguration of
    the device''s IP address. This protocol is discussed in [Chapter 30](ch30.html
    "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)").'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动IP** 这是一个协议，用于解决在使用IP时，频繁在不同网络间移动的计算机所遇到的一些困难。它提供了一种机制，允许数据自动路由到移动主机（如笔记本电脑），而无需不断重新配置设备的IP地址。本协议在[第30章](ch30.html
    "第30章。互联网协议移动支持（移动IP）")中进行了讨论。'
- en: Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。IPV4寻址概念和问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The primary job of the Internet Protocol (IP) is delivering messages between
    devices, and like any good delivery service, it can't do its job too well if it
    doesn't know where the recipients are located. Obviously then, one of the most
    important functions of IP is *addressing*. IP addressing is used not only to uniquely
    identify IP addresses, but also to facilitate the routing of IP datagrams over
    internetworks. IP addresses are used and referred to extensively in TCP/IP networking.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）的主要任务是传递设备之间的消息，就像任何优秀的递送服务一样，如果不知道收件人的位置，它就无法很好地完成其工作。显然，IP最重要的功能之一就是*寻址*。IP寻址不仅用于唯一标识IP地址，而且还用于在互联网中路由IP数据报。IP地址在TCP/IP网络中被广泛使用和提及。
- en: Even though the original IP addressing scheme was relatively simple, it has
    become complex over time as changes have been made to it to allow it to deal with
    various addressing requirements. The more advanced styles of IP addressing, such
    as subnetting and classless addressing, are the ones used most in modern networks.
    However, they can be a bit confusing to understand. To help make sense of them,
    we must start at the beginning with a discussion of the fundamentals of IP addressing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管原始的IP寻址方案相对简单，但随着对其进行的修改以适应各种寻址需求，它已经变得复杂。更高级的IP寻址风格，如子网划分和无类别寻址，是现代网络中最常用的。然而，它们可能有点难以理解。为了帮助理解它们，我们必须从讨论IP寻址的基本原理开始。
- en: In this chapter, I begin a larger exploration of IP addressing by explaining
    the key concepts and issues behind it. I begin with an overview of IP addressing
    and a discussion of what it is all about. I describe the size of IP addresses,
    the concept of its address space, and the notation usually used for IP addresses.
    I provide basic information on the structure of an IP address and how it is divided
    into a network identifier and host identifier. I then describe the different types
    of IP addresses and the additional information, such as a subnet mask and default
    gateway, that often accompanies an IP address on larger networks. I provide a
    brief description of how multiple addresses are sometimes assigned to single devices
    and why. I conclude with a description of the process by which public IP addresses
    are registered and managed, and the organizations that do this work for the global
    Internet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我通过解释 IP 地址背后的关键概念和问题，开始对 IP 地址分配进行更深入的研究。我首先概述 IP 地址分配，并讨论其内容。我描述了 IP
    地址的大小、其地址空间的概念以及通常用于 IP 地址的表示法。我提供了关于 IP 地址结构的基本信息以及它是如何分为网络标识符和主机标识符的。然后，我描述了不同类型的
    IP 地址以及通常伴随 IP 地址出现在大型网络中的附加信息，如子网掩码和默认网关。我简要描述了有时将多个地址分配给单个设备的原因。最后，我描述了公共 IP
    地址的注册和管理过程，以及执行这项工作的组织。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *If you are not familiar with at least the basics
    of how binary numbers work, and also with how to convert between binary and decimal
    numbers, I recommend reading [Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA
    REPRESENTATION AND THE MATHEMATICS OF COMPUTING"), which provides some background
    on data representation and the mathematics of computing, before you proceed here*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *如果你不熟悉至少二进制数的基本工作原理，以及如何将二进制数和十进制数相互转换，我建议你在继续阅读之前阅读[第 4 章](ch04.html
    "第 4 章. 数据表示和计算数学的回顾")，该章节提供了关于数据表示和计算数学的一些背景信息*。'
- en: IP Addressing Overview and Fundamentals
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 地址分配概述和基础知识
- en: 'IP addressing is important because it facilitates the primary function of the
    IP: the delivery of datagrams across an internetwork. When you examine this in
    more detail, it becomes apparent that the IP address actually has two different
    functions, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址分配非常重要，因为它促进了 IP 的主要功能：在互联网中传递数据报。当你更详细地检查这一点时，你会发现 IP 地址实际上有两个不同的功能，如下所示：
- en: '**Network Interface Identification** Like a street address, the IP address
    provides unique identification of the interface between a device and the network.
    This is required to ensure that the datagram is delivered to the correct recipients.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络接口标识** 就像街道地址一样，IP 地址为设备与网络之间的接口提供了唯一的标识。这是确保数据报被交付给正确收件人的必要条件。'
- en: '**Routing** When the source and destination of an IP datagram are not on the
    same network, the datagram must be delivered indirectly using intermediate systems.
    This is a process called *routing*. The IP address is an essential part of the
    system used to route datagrams.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由** 当 IP 数据报的源和目标不在同一网络时，必须通过中间系统间接交付数据报。这个过程称为 *路由*。IP 地址是用于路由数据报的系统的基本组成部分。'
- en: You may have noticed a couple of things about this short list. One is that I
    said the IP address identifies the *network interface*, not that it identifies
    the *device* itself. This distinction is important because it underscores the
    concept that IP is oriented around connections to a large, virtual network at
    layer 3, which can span multiple physical networks. Some devices, such as routers,
    will have more than one network connection, necessary to take datagrams from one
    network and route them onto another. This means they will also have more than
    one IP address—one per connection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了这个简短列表中的几个问题。一个是我说 IP 地址标识的是 *网络接口*，而不是标识 *设备* 本身。这种区别很重要，因为它强调了 IP
    是围绕连接到大型、虚拟网络的概念，该网络位于第 3 层，可以跨越多个物理网络。一些设备，如路由器，将拥有多个网络连接，这是必要的，以便从一个网络中提取数据报并将它们路由到另一个网络。这意味着它们也将拥有多个
    IP 地址——每个连接一个。
- en: You might also find it curious that I said that the IP address facilitates routing.
    How can it do that? The answer is that the addressing system is designed with
    a structure that can be interpreted to allow routers to determine what to do with
    a datagram based on the values in the address. Numbers related to the IP address,
    such as the subnet mask when subnetting is used, support this function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会觉得奇怪，我之前说IP地址有助于路由。它是如何做到这一点的呢？答案是，这个地址系统是设计成具有一种结构，可以解释为允许路由器根据地址中的值来确定对数据报的处理方式。与IP地址相关的数字，如使用子网划分时的子网掩码，支持这一功能。
- en: Let's look at some of the more important issues and characteristics associated
    with IP addresses in general terms.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一般性地探讨一些与IP地址相关的重要问题和特性。
- en: Number of IP Addresses Per Device
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个设备的IP地址数量
- en: 'Any device that has data sent to it at the network layer will have at least
    one IP address: one per network interface. This means that normal hosts such as
    computers and network-capable printers usually get one IP address, while routers
    get more than one IP address. Some special hosts may have more than one IP address
    if they are multihomed—connected to more than one network.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在网络层发送数据给它的设备至少有一个IP地址：每个网络接口一个。这意味着像计算机和网络打印机这样的普通主机通常只有一个IP地址，而路由器则拥有多个IP地址。如果某些特殊主机是多宿主的——连接到多个网络——它们可能拥有多个IP地址。
- en: Lower-level network interconnection devices—such as repeaters, bridges, and
    switches—don't require an IP address because they pass traffic based on layer
    2 (data link layer) addresses. Network segments connected by bridges and switches
    form a single broadcast domain, and any devices on them can send data to each
    other directly without routing. To IP, these devices are essentially invisible;
    they are no more significant than the wires that connect devices together (with
    a couple of exceptions). Such devices may, however, optionally have an IP address
    for management purposes. In this regard, they are acting like a regular host on
    the network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 较低级别的网络互联设备，如中继器、网桥和交换机，不需要IP地址，因为它们根据第二层（数据链路层）地址传递流量。通过网桥和交换机连接的网络段形成一个单一的广播域，并且任何连接到它们的设备都可以直接发送数据给对方，而无需路由。对于IP来说，这些设备基本上是看不见的；它们的重要性不比连接设备的电线大（有几个例外）。然而，这些设备可能为了管理目的而选择性地拥有一个IP地址。在这方面，它们表现得就像网络上的普通主机。
- en: '[Figure 16-1](ch16.html#ip_interfaces_for_common_network_devices "Figure 16-1. IP
    interfaces for common network devices Regular hosts have one interface; routers
    usually have more than one; and switches have none (because they operate at layer
    2).") shows the IP interfaces of a few common LAN devices as small circles. Each
    regular host has one interface, while the router that serves this LAN has three,
    since it connects to three different networks. Note that the LAN switch has no
    IP interfaces; it connects the hosts and router at layer 2\. (Also see [Figure 16-5](ch16s06.html#multihomed_devices_on_an_ip_internetwork
    "Figure 16-5. Multihomed devices on an IP internetwork This internetwork consists
    of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown
    with two IP network interface "circles." The two LANs are connected together through
    a multihomed, shared server that has been configured to route traffic between
    them. Note that this server also handles all traffic passing between LAN B and
    the Internet (since the Internet connection is in LAN A only)."), which shows
    the IP interfaces of devices in a more complex configuration.)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.html#ip_interfaces_for_common_network_devices "图16-1. 常见网络设备的IP接口
    正常主机有一个接口；路由器通常有多个；而交换机没有（因为它们在第二层操作）。")展示了几个常见局域网设备的IP接口，以小圆圈表示。每个正常主机有一个接口，而服务于这个局域网的路由器有三个，因为它连接到三个不同的网络。请注意，局域网交换机没有IP接口；它在第二层连接主机和路由器。（也参见[图16-5](ch16s06.html#multihomed_devices_on_an_ip_internetwork
    "图16-5. IP互联网上的多宿主设备 这个互联网由两个局域网A（上方）和B（下方）组成。局域网A有一个多宿主工作站，用两个IP网络接口“圆圈”表示。两个局域网通过一个多宿主、共享的服务器连接在一起，该服务器已被配置为在它们之间路由流量。请注意，这个服务器还处理在局域网B和互联网之间传递的所有流量（因为互联网连接仅在局域网A中）。"),它展示了更复杂配置中设备的IP接口。)'
- en: '![IP interfaces for common network devices Regular hosts have one interface;
    routers usually have more than one; and switches have none (because they operate
    at layer 2).](httpatomoreillycomsourcenostarchimages287791.png.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![常见网络设备的IP接口 正常主机有一个接口；路由器通常有多个；而交换机没有（因为它们在第二层操作）。](httpatomoreillycomsourcenostarchimages287791.png.jpg)'
- en: Figure 16-1. IP interfaces for common network devices Regular hosts have one
    interface; routers usually have more than one; and switches have none (because
    they operate at layer 2).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-1.常见网络设备的IP接口常规主机有一个接口；路由器通常有多个；而交换机没有（因为它们在层2操作）。
- en: Address Uniqueness and Network Specificity
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址唯一性和网络特定性
- en: Each IP address on a single internetwork must be unique. (This seems rather
    obvious, although there are exceptions in IPv6, in the form of special anycast
    addresses, as discussed in [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING").)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单个互联网上的每个IP地址都必须是唯一的。（这似乎非常明显，尽管在IPv6中存在例外，形式为特殊的任播地址，如第25章[第25章。IPv6寻址](ch25.html
    "Chapter 25. IPV6 ADDRESSING")中所述。）
- en: Since IP addresses represent network interfaces and are used for routing, the
    IP address is specific to the network to which it is connected. If the device
    moves to a new network, the IP address will usually have to change as well. For
    the full reason why, see the discussion of basic IP address structure later in
    this chapter. This issue was a primary motivation for the creation of Mobile IP
    (covered in [Chapter 30](ch30.html "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT
    (MOBILE IP)")).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP地址代表网络接口并用于路由，因此IP地址特定于连接的网络。如果设备移动到新的网络，IP地址通常也必须更改。关于这一点的完整原因，请参阅本章后面关于基本IP地址结构的讨论。这个问题是创建移动IP（在第30章[第30章。互联网协议移动支持（移动IP）](ch30.html
    "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)")中介绍）的主要动机之一。
- en: Contrasting IP Addresses and Data Link Layer Addresses
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对比IP地址和链路层地址
- en: IP addresses are used for network-layer data delivery across an internetwork.
    This makes IP addresses quite different from the data link layer address of a
    device, such as its Ethernet MAC address. (In TCP/IP parlance, these are sometimes
    called *physical addresses* or *hardware addresses*.)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址用于在互联网中跨网络层的数据传输。这使得IP地址与设备的链路层地址（如其以太网MAC地址）有很大不同。（在TCP/IP术语中，这些有时被称为*物理地址*或*硬件地址*。）
- en: At the network layer, a single datagram may be sent from Device A to Device
    B. However, the actual delivery of the datagram may require that it passes through
    a dozen or more physical devices if Device A and Device B are not on the same
    network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络层，一个数据报可以从设备A发送到设备B。然而，如果设备A和设备B不在同一网络中，实际的数据报交付可能需要它通过十几个或更多的物理设备。
- en: It is also necessary to provide a function that maps between IP and data link
    layer addresses. In TCP/IP, this is the job of the Address Resolution Protocol
    (ARP; see [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP
    ADDRESS RESOLUTION PROTOCOL (ARP)")).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提供一个将IP地址和链路层地址之间进行映射的功能。在TCP/IP中，这是地址解析协议（ARP）的工作（见第13章[第13章。地址解析和TCP/IP地址解析协议（ARP）](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")）。
- en: In a physical network such as an Ethernet, the MAC address is all the information
    needed to send data between devices. In contrast, an IP address represents only
    the final delivery point of the datagram. The route taken depends on the characteristics
    of the network paths between the source and destination devices. It is even possible
    that there may not be a route between any two devices, which means two devices
    cannot exchange data, even if they know each other's addresses!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个物理网络（如以太网）中，MAC地址是发送设备之间数据所需的所有信息。相比之下，IP地址仅代表数据报的最终交付点。所采取的路径取决于源设备和目标设备之间网络路径的特性。甚至可能不存在任何两个设备之间的路由，这意味着即使它们知道彼此的地址，两个设备也无法交换数据！
- en: Private and Public IP Network Addresses
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有和公共IP网络地址
- en: There are two distinct ways that a network can be set up with IP addresses.
    On a *private network*, a single organization controls the assignment of the addresses
    for all devices; they have pretty much absolute control to do what they wish in
    selecting numbers, as long as each address is unique.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IP地址设置网络有两种不同的方式。在*私有网络*中，单个组织控制所有设备的地址分配；他们在选择数字方面几乎有绝对的自由，只要每个地址都是唯一的。
- en: In contrast, on a *public network*, a mechanism is required to ensure that organizations
    don't use overlapping addresses and that they enable efficient routing of data
    between organizations. The best-known example of this is the Internet, where public
    IP registration and management facilities have been created to address this issue.
    There are also advanced techniques now, such as IP Network Address Translation
    (NAT), which allow a network using private addresses to be interfaced to a public
    TCP/IP network.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在*公共网络*上，需要一个机制来确保组织不会使用重叠的地址，并且能够有效地在组织之间路由数据。最著名的例子是互联网，为了解决这个问题，已经创建了公共IP注册和管理设施。现在还有一些高级技术，如IP网络地址转换（NAT），允许使用私有地址的网络与公共TCP/IP网络接口。
- en: IP Address Configuration and Addressing Types
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址配置和寻址类型
- en: IP addresses can be set up as either a static or dynamic configuration. In a
    *static configuration* setup, each device is manually configured with an IP address
    that doesn't change. This is fine for small networks but quickly becomes an administrative
    nightmare in larger networks, when changes are required. The alternative, *dynamic
    configuration*, allows IP addresses to be assigned to devices and changed under
    software control. The two host configuration protocols, BOOTP and DHCP, were created
    to fill this latter function (see [Part III-3](pt14.html "Part III-3. HOST CONFIGURATION
    AND TCP/IP HOST CONFIGURATION PROTOCOLS")).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址可以设置为静态或动态配置。在*静态配置*设置中，每个设备都会手动配置一个不会改变的IP地址。这对于小型网络来说是可以的，但在大型网络中，当需要更改时，这会迅速变成一个管理噩梦。另一种选择，*动态配置*，允许在软件控制下分配和更改IP地址。为了填补这一后者的功能，创建了两种主机配置协议，即BOOTP和DHCP（参见[第三部分-3](pt14.html
    "第三部分-3. 主机配置和TCP/IP主机配置协议")）。
- en: 'Additionally, provision is included in the IP addressing scheme for all three
    basic types of addressing: unicast, multicast, and broadcast.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，IP寻址方案还包括所有三种基本寻址类型：单播、多播和广播。
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IP addresses serve the dual function of device identification
    and routing. Each network interface requires one IP address, which is network
    specific. IP addresses can be either statically or dynamically allocated, and
    come in unicast, multicast, and broadcast forms.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP地址具有设备标识和路由的双重功能。每个网络接口需要一个IP地址，这是网络特定的。IP地址可以是静态或动态分配的，并且有单播、多播和广播形式。'
- en: IP Address Size, Address Space, and Notation
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址的大小、地址空间和表示法
- en: Now that you have looked at the general issues and characteristics associated
    with IP addresses, it's time to get past the introductions and dig into the "meat"
    of the IP address discussion. Let's start by looking at the physical construction
    and size of the IP address and how it is referred to and used.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了与IP地址相关的一般问题和特征，是时候超越介绍，深入探讨IP地址的“实质”讨论了。让我们首先看看IP地址的物理结构和大小，以及它是如何被引用和使用的。
- en: IP Address Size and Binary Notation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址大小和二进制表示法
- en: 'At its simplest, the IP address is just a 32-bit binary number: a set of 32
    ones or zeros. At their lowest levels, computers always work in binary, and this
    also applies to networking hardware and software. While different meanings are
    ascribed to different bits in the address, the address itself is just a 32-digit
    binary number.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，IP地址只是一个32位的二进制数：一组32个1或0。在最低级别，计算机总是以二进制形式工作，这同样适用于网络硬件和软件。虽然地址中的不同位被赋予了不同的含义，但地址本身只是一个32位的二进制数。
- en: 'People don''t work too well with binary numbers, because they are long and
    complicated, and the use of only two digits makes them hard to differentiate.
    (Quick, which of these is larger: 11100011010100101001100110110001 or 11100011010100101001101110110001?)
    For this reason, when you use IP addresses, you don''t work with them in binary
    except when absolutely necessary.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 人们不太擅长处理二进制数，因为它们很长且复杂，仅使用两个数字使得它们难以区分。（快，以下哪个更大：11100011010100101001100110110001
    还是 11100011010100101001101110110001？）因此，当使用IP地址时，除非绝对必要，否则不会以二进制形式处理它们。
- en: 'The first thing that people would naturally do with a long string of bits is
    to split it into four eight-bit octets (or bytes, even though the two aren''t
    technically the same; see [Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA REPRESENTATION
    AND THE MATHEMATICS OF COMPUTING")), to make it more manageable. So 11100011010100101001101110110001
    would become 11100011 - 01010010 - 10011101 - 10110001\. Then you could convert
    each of those octets into a more manageable two-digit hexadecimal number to yield
    the following: E3 - 52 - 9D - B1\. This is, in fact, the notation used for IEEE
    802 MAC addresses, except that they are 48 bits long, so they have six two-digit
    hex numbers, and they are usually separated by colons, not dashes, as I used here.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 人们自然会对一长串比特进行的第一件事就是将其分成四个八位字节（或者字节，尽管这两个词在技术上并不完全相同；参见[第4章](ch04.html "第4章.
    数据表示和计算数学的回顾"))，以便更容易管理。所以11100011010100101001101110110001将变成11100011 - 01010010
    - 10011101 - 10110001。然后你可以将每个字节转换成一个更易管理的两位十六进制数，得到以下结果：E3 - 52 - 9D - B1。实际上，这是IEEE
    802 MAC地址所使用的表示法，只是它们是48位长的，所以它们有六个两位的十六进制数，并且通常用冒号而不是破折号分隔，就像我这里所做的那样。
- en: (Incidentally, the second binary number is the larger one.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便提一下，第二个二进制数是较大的那个。）
- en: IP Address Dotted Decimal Notation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址点分十进制表示法
- en: Most people still find hexadecimal a bit difficult to work with. So, IP addresses
    are normally expressed with each octet of eight bits converted to a decimal number
    and the octets separated by a period (a *dot*). Thus, the previous example would
    become 227.82.157.177, as shown in [Figure 16-2](ch16s02.html#ip_address_binary_hexadecimal_and_dotted
    "Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations
    The binary, hexadecimal, and decimal representations of an IP address are all
    equivalent."). This is usually called *dotted decimal notation* for rather obvious
    reasons. Each of the octets in an IP address can take on the values from 0 to
    255, so the lowest value is theoretically 0.0.0.0 and the highest is 255.255.255.255.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人仍然觉得十六进制数有点难以处理。因此，IP地址通常以每个八位字节转换为十进制数，并且字节之间用点（*点*）分隔来表示。因此，前面的例子将变成227.82.157.177，如[图16-2](ch16s02.html#ip_address_binary_hexadecimal_and_dotted
    "图16-2. IP地址的二进制、十六进制和点分十进制表示形式。IP地址的二进制、十六进制和十进制表示都是等效的")所示。这通常被称为*点分十进制表示法*，原因相当明显。IP地址中的每个八位字节可以取从0到255的值，因此最低值理论上为0.0.0.0，最高值为255.255.255.255。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IP addresses are 32-bit binary numbers, which can be expressed
    in binary, hexadecimal, or decimal form. Most commonly, they are expressed by
    dividing the 32 bits into four bytes and converting each to decimal, then separating
    these numbers with dots to create dotted decimal notation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP地址是32位的二进制数，可以用二进制、十六进制或十进制形式表示。最常见的是，它们通过将32位分成四个字节并将每个字节转换为十进制来表示，然后用点分隔这些数字以创建点分十进制表示法。'
- en: '![IP address binary, hexadecimal, and dotted decimal representations The binary,
    hexadecimal, and decimal representations of an IP address are all equivalent.](httpatomoreillycomsourcenostarchimages287793.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![IP地址的二进制、十六进制和点分十进制表示形式。IP地址的二进制、十六进制和十进制表示都是等效的](httpatomoreillycomsourcenostarchimages287793.png.jpg)'
- en: Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations
    The binary, hexadecimal, and decimal representations of an IP address are all
    equivalent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-2. IP地址的二进制、十六进制和点分十进制表示形式。IP地址的二进制、十六进制和十进制表示都是等效的](httpatomoreillycomsourcenostarchimages287793.png.jpg)'
- en: Dotted decimal notation provides a convenient way to work with IP addresses
    when communicating among people. Never forget that to the computers, the IP address
    is always a 32-bit binary number; you'll understand the importance of this when
    you look at how the IP address is logically divided into components in the next
    topic, and when you examine techniques that manipulate IP addresses, such as subnetting.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点分十进制表示法为人们在通信中处理IP地址提供了一个方便的方法。永远不要忘记，对于计算机来说，IP地址始终是一个32位的二进制数；当你查看下一个主题中IP地址的逻辑组成部分时，以及当你检查操作IP地址的技术，如子网划分时，你会理解这一点的重要性。
- en: IP Address Space
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP地址空间
- en: Since the IP address is 32 bits wide, this provides a theoretical *address space*
    of 2^(32), or 4,294,967,296 addresses. This seems like quite a lot of addresses,
    and in some ways, it is. However, as you will see, due to how IP addresses are
    structured and allocated, not every one of those addresses can actually be used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP地址是32位宽，这提供了理论上的*地址空间*为2^(32)，或4,294,967,296个地址。这似乎有很多地址，从某些方面来看确实是这样的。然而，正如您将看到的，由于IP地址的结构和分配方式，并非所有这些地址都可以实际使用。
- en: One of the unfortunate legacies of the fact that IP was originally created on
    a rather small internetwork is that decisions were made that wasted much of the
    address space. For example, all IP addresses starting with 127 in the first octet
    are reserved for the loopback function. Just this one decision makes 1/256th of
    the total number, or 16,277,216 addresses, no longer available. There are also
    other ways that the IP address space was not conserved. This caused difficulty
    as the Internet grew in size. (You'll see more about this in [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING"), which covers classful addressing.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: IP最初是在一个相当小的互联网上创建的，这一事实的一个不幸遗产是，所做的决定浪费了大部分地址空间。例如，所有以127开头的第一个八位字节中的IP地址都保留用于环回功能。仅此一项决定就使得总地址的1/256，即16,277,216个地址不再可用。还有其他一些方式没有保存IP地址空间。随着互联网规模的扩大，这造成了困难。（您将在第17章中了解更多关于这一点，该章涵盖了类别地址。）
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Since IP addresses are 32 bits long, the total address space
    of IPv4 is 2^(32) or 4,294,967,296 addresses. However, not all of these addresses
    can be used, for a variety of reasons.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于IP地址是32位长，因此IPv4的总地址空间为2^(32)或4,294,967,296个地址。然而，由于各种原因，并非所有这些地址都可以使用。'
- en: This IP address space dictates the limit on the number of addressable interfaces
    in *each* IP internetwork. So, if you have a private network, you can, in theory,
    have four-billion-plus addresses. However, in a public network such as the Internet,
    alldevices must share the available address space. Techniques such as Classless
    Inter-Domain Routing (CIDR), or supernetting, and NAT were designed in part to
    utilize the existing Internet IP address space more efficiently. IPv6 expands
    the IP address size from 32 bits all the way up to 128, which increases the address
    space to a ridiculously large number and makes the entire matter of address space
    size moot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个IP地址空间决定了每个IP互联网中可寻址接口数量的限制。因此，如果您有一个私有网络，从理论上讲，您可以拥有超过四十亿的地址。然而，在像互联网这样的公共网络中，所有设备必须共享可用的地址空间。设计诸如无类别域间路由（CIDR）、超网技术或NAT等技术部分是为了更有效地利用现有的互联网IP地址空间。IPv6将IP地址的大小从32位扩展到128位，地址空间增加到极其庞大的数字，使得整个地址空间大小的问题变得无关紧要。
- en: IP Basic Address Structure and Main Components
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP基本地址结构和主要组件
- en: As I mentioned in the IP addressing overview, one of the ways that IP addresses
    are used is to facilitate the routing of datagrams in an IP internetwork. This
    is made possible because of the way that IP addresses are structured and how that
    structure is interpreted by network routers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在IP地址概述中提到的，IP地址被用来促进IP互联网中数据报的路由。这是由于IP地址的结构以及网络路由器如何解释这种结构而成为可能。
- en: Network ID and Host ID
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络ID和主机ID
- en: 'As you just saw, each IPv4 address is 32 bits long. When you refer to the IP
    address, you use a dotted decimal notation, while the computer converts this into
    binary. However, even though these sets of 32 bits are considered a single entity,
    they have an internal structure containing two components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您刚才看到的，每个IPv4地址都是32位长。当您引用IP地址时，您使用点分十进制表示法，而计算机将其转换为二进制。然而，尽管这些32位的集合被视为一个单一实体，但它们包含两个组成部分的内部结构：
- en: '**Network Identifier (Network ID)** A certain number of bits, starting from
    the leftmost bit, is used to identify the network where the host or other network
    interface is located. This is also sometimes called the *network prefix* or even
    just the *prefix*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络标识符（网络ID）** 从最左边的位开始的一定数量的位用于标识主机或其他网络接口所在的网络。这有时也被称为*网络前缀*，甚至只是*前缀*。'
- en: '**Host Identifier (Host ID)** The remainder of the bits is used to identify
    the host on the network.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机标识符（主机ID）** 剩余的位用于标识网络上的主机。'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*By convention, IP devices are often called hosts for simplicity, as I do throughout
    this book. Even though each host usually has a single IP address, you should remember
    that IP addresses are strictly associated with network layer network interfaces,
    not physical devices, and a device may therefore have more than one IP address
    (especially a router or multihomed host)*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，为了简便起见，IP 设备通常被称为主机，正如我在本书中一直所做的那样。尽管每个主机通常只有一个 IP 地址，但你应该记住，IP 地址严格关联于网络层的网络接口，而不是物理设备，因此一个设备可能拥有多个
    IP 地址（尤其是路由器或多宿主主机）。
- en: 'As you can see in [Figure 16-3](ch16s03.html#basic_ip_address_division_network_id_and
    "Figure 16-3. Basic IP address division: network ID and host ID This diagram shows
    one of the many ways to divide an IP address into a network ID and host ID."),
    this really is a fairly simple concept. The fundamental division of the bits of
    an IP address is into a network ID and host ID. In this illustration, the network
    ID is 8 bits long, and the host ID is 24 bits in length. This is similar to the
    structure used for phone numbers in North America. The telephone number (401)
    555-7777 is a ten-digit number that''s usually referred to as a single phone number.
    However, it has a structure. In particular, it has an area code (401) and a local
    number (555-7777).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[图 16-3](ch16s03.html#basic_ip_address_division_network_id_and "图 16-3. 基本
    IP 地址划分：网络 ID 和主机 ID 此图展示了将 IP 地址划分为网络 ID 和主机 ID 的多种方法之一.")中可以看到，这实际上是一个相当简单的概念。IP
    地址位的根本划分是网络 ID 和主机 ID。在此图中，网络 ID 长度为 8 位，主机 ID 长度为 24 位。这与北美电话号码的结构相似。电话号码（401）555-7777
    是一个十位数的号码，通常被称为一个单独的电话号码。然而，它有一个结构。特别是，它有一个区号（401）和一个本地号码（555-7777）。
- en: The fact that the network ID is contained in the IP address is what partially
    facilitates the routing of IP datagrams when the address is known. Routers look
    at the network portion of the IP address to first determine if the destination
    IP address is on the same network as the host IP address. Then routing decisions
    are made based on information the routers keep about where various networks are
    located. Again, this is conceptually similar to how the area code is used by the
    equivalent of routers in the phone network to switch telephone calls. The host
    portion of the address is used by devices on the local portion of the network.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 网络 ID 包含在 IP 地址中，这在地址已知时部分促进了 IP 数据报的路由。路由器查看 IP 地址的网络部分，首先确定目标 IP 地址是否与主机 IP
    地址在同一网络上。然后根据路由器保留的有关各种网络位置的信息做出路由决策。再次强调，这与电话网络中相当于路由器的实体使用区号切换电话呼叫的概念上是相似的。地址的主机部分由网络本地部分的设备使用。
- en: '![Basic IP address division: network ID and host ID This diagram shows one
    of the many ways to divide an IP address into a network ID and host ID.](httpatomoreillycomsourcenostarchimages287795.png.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![基本 IP 地址划分：网络 ID 和主机 ID 此图展示了将 IP 地址划分为网络 ID 和主机 ID 的多种方法之一。](httpatomoreillycomsourcenostarchimages287795.png.jpg)'
- en: 'Figure 16-3. Basic IP address division: network ID and host ID This diagram
    shows one of the many ways to divide an IP address into a network ID and host
    ID.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-3. 基本 IP 地址划分：网络 ID 和主机 ID 此图展示了将 IP 地址划分为网络 ID 和主机 ID 的多种方法之一。
- en: Location of the Division Between Network ID and Host ID
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络 ID 和主机 ID 之间的划分位置
- en: One difference between IP addresses and phone numbers is that the dividing point
    between the bits used to identify the network and those that identify the host
    isn't fixed. It depends on the nature of the address, the type of addressing being
    used, and other factors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址和电话号码之间的一个区别是，用于标识网络和标识主机的位之间的划分点不是固定的。它取决于地址的性质、所使用的寻址类型和其他因素。
- en: Take the previous example of 227.82.157.177 (see [Figure 16-2](ch16s02.html#ip_address_binary_hexadecimal_and_dotted
    "Figure 16-2. IP address binary, hexadecimal, and dotted decimal representations
    The binary, hexadecimal, and decimal representations of an IP address are all
    equivalent.")). It is possible to divide this into a network ID of 227.82 and
    a host ID of 157.177\. Alternatively, the network ID might be 227 and the host
    ID might be 82.157.177 within that network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以先前的例子 227.82.157.177 为例（见[图 16-2](ch16s02.html#ip_address_binary_hexadecimal_and_dotted
    "图 16-2. IP 地址的二进制、十六进制和点分十进制表示 IP 地址的二进制、十六进制和十进制表示都是等效的"))。可以将其划分为网络 ID 227.82
    和主机 ID 157.177。或者，网络 ID 可能是 227，而网络内的主机 ID 可能是 82.157.177。
- en: To express the network and host IDs as 32-bit addresses, you add zeros to replace
    the missing pieces. With a network ID of 227 and a host ID of 82.157.177, the
    address of the network becomes 227.0.0.0 and the address of the host 0.82.157.177\.
    (In practice, network addresses of this sort are routinely seen with the added
    zeros; network IDs are not seen as often in 32-bit form this way.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将网络ID和主机ID表示为32位地址，你需要添加零来替换缺失的部分。以网络ID为227和主机ID为82.157.177为例，网络地址变为227.0.0.0，主机地址为0.82.157.177。（在实践中，这种类型的网络地址通常会看到添加的零；网络ID以这种方式以32位形式出现的频率不高。）
- en: Lest you think from these examples that the division must always be between
    whole octets of the address, you should know that it's also possible to divide
    it in the middle of an octet. For example, you could split the IP address 227.82.157.177
    so that there were 20 bits for the network ID and 12 bits for the host ID. The
    process is the same, but determining the dotted decimal ID values is more tricky
    because here, the 157 is split into two binary numbers. The results are 227.82.144.0
    for the network ID and 0.0.0.13.177 for the host ID, as shown in [Figure 16-4](ch16s03.html#mid-octet_ip_address_division_ip_address
    "Figure 16-4. Mid-octet IP address division IP addresses need not be divided between
    network ID and host ID on octet boundaries. The division here is into a 20-bit
    network ID and a 12-bit host ID.").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不要认为从这些例子中可以得出分割必须总是在整个八位字节之间进行的结论，你应该知道它也可以在八位字节的中部进行分割。例如，你可以将IP地址227.82.157.177分割，使得网络ID有20位，主机ID有12位。过程是相同的，但确定点分十进制ID值更为复杂，因为在这里，157被分割成两个二进制数。结果是网络ID为227.82.144.0，主机ID为0.0.0.13.177，如图16-4所示。[图16-4](ch16s03.html#mid-octet_ip_address_division_ip_address
    "图16-4. 中八位字节IP地址分割 IP地址不需要在八位字节边界上分割网络ID和主机ID。这里的分割是一个20位网络ID和一个12位主机ID。")。
- en: Since IP addresses are normally expressed as four dotted-decimal numbers, educational
    resources often show the division between the network ID and host ID occurring
    on an octet boundary. However, it's essential to remember that the dividing point
    often appears in the middle of one of these eight-bit numbers. In [Figure 16-4](ch16s03.html#mid-octet_ip_address_division_ip_address
    "Figure 16-4. Mid-octet IP address division IP addresses need not be divided between
    network ID and host ID on octet boundaries. The division here is into a 20-bit
    network ID and a 12-bit host ID."), the network ID is 20 bits long, and the host
    ID 12 bits long. This results in the third number of the original IP address,
    157, being split into 144 and 13.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP地址通常表示为四个点分十进制数字，教育资源通常会显示网络ID和主机ID在八位字节边界上的分割。然而，必须记住，分割点通常出现在这些八位数字的中间。在[图16-4](ch16s03.html#mid-octet_ip_address_division_ip_address
    "图16-4. 中八位字节IP地址分割 IP地址不需要在八位字节边界上分割网络ID和主机ID。这里的分割是一个20位网络ID和一个12位主机ID。")中，网络ID为20位，主机ID为12位。这导致原始IP地址的第三个数字157被分割成144和13。
- en: The place where the line is drawn between the network ID and the host ID must
    be known in order for devices such as routers to know how to interpret the address.
    This information is conveyed either implicitly or explicitly, depending on the
    type of IP addressing in use, as I discuss next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让像路由器这样的设备知道如何解释地址，必须知道网络ID和主机ID之间的分割位置。这个信息要么隐含地传达，要么明确地传达，具体取决于使用的IP地址类型，正如我接下来要讨论的。
- en: '![Mid-octet IP address division IP addresses need not be divided between network
    ID and host ID on octet boundaries. The division here is into a 20-bit network
    ID and a 12-bit host ID.](httpatomoreillycomsourcenostarchimages287797.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![中八位字节IP地址分割 IP地址不需要在八位字节边界上分割网络ID和主机ID。这里的分割是一个20位网络ID和一个12位主机ID。](httpatomoreillycomsourcenostarchimages287797.png.jpg)'
- en: Figure 16-4. Mid-octet IP address division IP addresses need not be divided
    between network ID and host ID on octet boundaries. The division here is into
    a 20-bit network ID and a 12-bit host ID.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-4. 中八位字节IP地址分割 IP地址不需要在八位字节边界上分割网络ID和主机ID。这里的分割是一个20位网络ID和一个12位主机ID。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The basic structure of an IP address consists of two components:
    the network ID and host ID. The dividing point of the 32-bit address is not fixed,
    but depends on a number of factors and can occur in a variety of places, including
    in the middle of a dotted-decimal octet.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP地址的基本结构由两个部分组成：网络ID和主机ID。32位地址的分割点不是固定的，而是取决于多个因素，并且可能出现在各种位置，包括点分十进制八位字节的中部。'
- en: Since the IP address can be split into network ID and host ID components, it
    is also possible to use either one or the other by itself, depending on context.
    These addresses are assigned special meanings. For example, if the network ID
    is used with all ones as the host ID, this indicates a broadcast to the entire
    network. Similarly, if the host ID is used by itself with all zeros for the network
    ID, this implies an IP address sent to the host of that ID on the local network,
    whatever that might be. This is explained in much more detail in [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 IP 地址可以被分成网络 ID 和主机 ID 组件，因此根据上下文，也可以单独使用其中一个或另一个。这些地址被赋予了特殊的意义。例如，如果使用全
    1 作为主机 ID 的网络 ID，这表示向整个网络广播。同样，如果主机 ID 单独使用，网络 ID 为全 0，这表示发送到本地网络中该 ID 主机的 IP
    地址，无论该主机是什么。这将在[第 17 章](ch17.html "第 17 章。分类（传统）寻址")中详细解释。
- en: It is the inclusion of the network ID in the IP address of each host on the
    network that causes the IP addresses to be network-specific. If you move a device
    from one network to a different one, the network ID must change to that of the
    new network. Therefore, the IP address must change as well. This is an unfortunate
    drawback that shows up most commonly when dealing with mobile devices; see [Chapter 30](ch30.html
    "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)").
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正是网络 ID 包含在每个网络上的每个主机的 IP 地址中，才使得 IP 地址具有网络特定的性质。如果你将设备从一个网络移动到另一个网络，网络 ID 必须更改为新网络的网络
    ID。因此，IP 地址也必须更改。这是一个不幸的缺点，在处理移动设备时最常见；请参阅[第 30 章](ch30.html "第 30 章。互联网协议移动支持（移动
    IP）")。
- en: IP Addressing Categories and IP Address Adjuncts
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 寻址类别和 IP 寻址辅助
- en: We just explored how the 32 bits in an IP address are fundamentally divided
    into the network ID and host ID. The network ID is used for routing purposes,
    and the host ID uniquely identifies each network interface on the network. In
    order for devices to know how to use IP addresses on the network, they must be
    able to tell which bits are used for each ID. However, the dividing line is not
    predefined. It depends on the type of addressing used in the network.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚探讨了 IP 地址中的 32 位是如何在本质上分为网络 ID 和主机 ID 的。网络 ID 用于路由目的，而主机 ID 唯一标识网络上的每个网络接口。为了设备能够知道如何在网络上使用
    IP 地址，它们必须能够判断哪些位用于每个 ID。然而，这条分界线并不是预先定义的。它取决于网络中使用的寻址类型。
- en: 'Understanding how these IDs are determined leads us into a larger discussion
    of the three main categories of IP addressing schemes: classful, subnetted, and
    classless. Each of these uses a slightly different system of indicating where
    in the IP address the host ID is found.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这些 ID 如何确定，使我们进入了对 IP 寻址方案三个主要类别的更广泛讨论：分类、子网化和无类。每个都使用稍微不同的系统来指示主机 ID 在 IP
    地址中的位置。
- en: Conventional (Classful) Addressing
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的（分类）寻址
- en: 'The original IP addressing scheme is set up so that the dividing line occurs
    only in one of a few locations: on octet boundaries. Three main classes of addresses—A,
    B, and C—are differentiated based on how many octets are used for the network
    ID and how many for the host ID. For example, Class C addresses devote 24 bits
    to the network ID and 8 bits to the host ID. This type of addressing is now often
    referred to by the made-up word *classful* to differentiate it from the newer
    classless scheme.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 IP 寻址方案被设置为仅在少数几个位置之一发生分界：在八位字节边界上。根据用于网络 ID 和主机 ID 的八位字节数，区分了三个主要类别的地址——A、B
    和 C。例如，C 类地址将 24 位用于网络 ID，8 位用于主机 ID。这种寻址方式现在通常被称为虚构的词 *classful*，以区分较新的无类方案。
- en: 'This most basic addressing type uses the simplest method to divide the network
    and host IDs: The class, and therefore the dividing point, are encoded into the
    first few bits of each address. Routers can tell from these bits which octets
    belong to which identifier.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最基本的寻址类型使用最简单的方法来划分网络 ID 和主机 ID：将类别及其分界点编码到每个地址的前几位中。路由器可以通过这些位判断哪些八位字节属于哪个标识符。
- en: Subnetted Classful Addressing
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网化分类寻址
- en: In the subnet addressing system, the two-tier network and host division of the
    IP address is made into a three-tier system by taking some number of bits from
    a Class A, B, or C host ID and using them for a *subnet identifier (subnet ID)*.
    The network ID is unchanged. The subnet ID is used for routing within the different
    subnetworks that constitute a complete network, thereby providing extra flexibility
    for administrators. For example, consider a Class C address that normally uses
    the first 24 bits for the network ID and remaining 8 bits for the host ID. The
    host ID can be split into, say, 3 bits for a subnet ID and 5 bits for the host
    ID.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在子网寻址系统中，通过从类别A、B或C的主机ID中取出一些位，并将它们用于一个*子网标识符（子网ID）*，将IP地址的网络和主机部分从两层系统扩展为三层系统。网络ID保持不变。子网ID用于在构成整个网络的各个子网络之间进行路由，从而为管理员提供额外的灵活性。例如，考虑一个通常使用前24位作为网络ID和剩余8位作为主机ID的类别C地址。主机ID可以被分成，比如说，3位用于子网ID和5位用于主机ID。
- en: This system is based on the original classful scheme, so the dividing line between
    the network ID and full host ID is based on the first few bits of the address
    as before. The dividing line between the subnet ID and the "subhost" ID is indicated
    by a 32-bit number called a *subnet mask*. In the previous example, the subnet
    mask would be 27 ones followed by 5 zeros—the zeros indicate what part of the
    address is the host. In dotted decimal notation, this would be 255.255.255.224.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统基于原始的类别方案，因此网络ID和完整主机ID之间的分割线仍然基于地址的前几位，就像之前一样。子网ID和“子主机”ID之间的分割线由一个称为*子网掩码*的32位数字表示。在先前的例子中，子网掩码将是27个1位后面跟着5个0位——0位表示地址的哪一部分是主机。以点分十进制表示，这将表示为255.255.255.224。
- en: Classless Addressing
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无类别寻址
- en: In the classless system, the classes of the original IP addressing scheme are
    tossed out the window. The division between the network ID and host ID can occur
    at an arbitrary point, not just on octet boundaries, as in the classful scheme.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在无类别系统中，原始IP寻址方案中的类别被摒弃。网络ID和主机ID的分割可以发生在任意点，而不仅仅是类别方案中的八位边界。
- en: The dividing point is indicated by putting the number of bits used for the network
    ID, called the *prefix length*, after the address. (Recall that the network ID
    bits are also sometimes called the *network prefix*, so the network ID size is
    the prefix length.) For example, if 227.82.157.177 is part of a network where
    the first 27 bits are used for the network ID, that network would be specified
    as 227.82.157.160/27\. The /27 is conceptually the same as the 255.255.255.224
    subnet mask, since it has 27 one bits followed by 5 zeros.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在地址后放置用于网络ID的位数，即所谓的*前缀长度*，来指示分割点。（回想一下，网络ID位有时也被称为*网络前缀*，因此网络ID的大小就是前缀长度。）例如，如果227.82.157.177是使用前27位作为网络ID的网络的一部分，那么该网络将被指定为227.82.157.160/27。/27在概念上等同于255.255.255.224子网掩码，因为它有27个1位后面跟着5个0位。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** An essential factor in determining how an IP address is interpreted
    is the addressing scheme in which it is used. The three methods, arranged in increasing
    order of age, complexity, and flexibility, are classful addressing, subnetted
    classful addressing, and classless addressing.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 决定一个IP地址如何被解释的一个基本因素是它所使用的寻址方案。这三种方法按照年龄、复杂性和灵活性的递增顺序排列，分别是类别寻址、子网类别寻址和无类别寻址。'
- en: This introduction to the concepts of classful, subnetted, and classless addressing
    was designed to show you how they impact the way the IP address is interpreted.
    I have greatly summarized important concepts here. All three methods are explained
    in their own chapters in full detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇关于类别寻址、子网寻址和无类别寻址概念的介绍旨在展示它们如何影响IP地址的解释方式。我在这里大大简化了重要概念。所有三种方法都在各自的章节中进行了详细解释。
- en: Subnet Mask and Default Gateway
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网掩码和默认网关
- en: In the original classful scheme, the division between network ID and host ID
    is implied. However, if either subnetting or classless addressing is used, then
    the *subnet mask* (or *slash number*, which is equivalent) is required to fully
    qualify the address. These numbers are considered adjuncts to the IP address and
    usually mentioned with the address itself, because without them, it is not possible
    to know where the network ID ends and the host ID begins.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的类别划分方案中，网络ID和主机ID之间的划分是隐含的。然而，如果使用子网划分或无类别寻址，则需要*子网掩码*（或*斜杠号*，两者等价）来完全指定地址。这些数字被视为IP地址的补充，通常与地址一起提及，因为没有它们，就无法知道网络ID在哪里结束，主机ID在哪里开始。
- en: One other number that is often specified along with the IP address for a device
    is the *default gateway* identifier. In simplest terms, this is the IP address
    of the router that provides default routing functions for a particular device.
    When a device on an IP network wants to send a datagram to a device it can't see
    on its local IP network, it sends it to the default gateway, which takes care
    of routing functions. Without this, each IP device would also need to have knowledge
    of routing functions and routes, which would be inefficient. See [Chapter 23](ch23.html
    "Chapter 23. IP ROUTING AND MULTICASTING"), which discusses IP routing concepts,
    and [Chapter 37](ch37.html "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS")
    through 41, which cover TCP/IP routing protocols, for more information.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与设备IP地址一起经常指定的另一个数字是*默认网关*标识符。简单来说，这是为特定设备提供默认路由功能的路由器的IP地址。当一个IP网络上的设备想要向其本地IP网络上看不到的设备发送数据报时，它会将其发送到默认网关，该网关负责路由功能。没有这个，每个IP设备都需要了解路由功能和路由，这将是不高效的。参见[第23章](ch23.html
    "第23章。IP路由和多播")，其中讨论了IP路由概念，以及从[第37章](ch37.html "第37章。关键路由协议概念概述")到41章，这些章节涵盖了TCP/IP路由协议，以获取更多信息。
- en: Number of IP Addresses and Multihoming
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址数量和多宿主
- en: Each network interface on an IP internetwork has a separate IP address. In a
    classic network, each regular computer, usually called a *host*, attaches to the
    network in exactly only one place, so it will have only one IP address. This is
    what most of us are familiar with when using an IP network (and is also why most
    people use the term *host* when they really mean *network interface*).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP互联网上的每个网络接口都有一个独立的IP地址。在一个经典网络中，每台常规计算机，通常称为*主机*，只连接到网络的一个地方，因此它只有一个IP地址。这是我们使用IP网络时最熟悉的情况（这也是为什么大多数人使用术语*主机*而不是*网络接口*的原因）。
- en: If a device has more than one interface to the internetwork, it will have more
    than one IP address. The most obvious case where this occurs is with routers,
    which connect together different networks and thus must have an IP address for
    the interface on each one. It is also possible for hosts to have more than one
    IP address, however. Such a device is sometimes said to be *multihomed*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个设备与互联网有多个接口，它将拥有多个IP地址。最明显的例子是路由器，它们连接不同的网络，因此必须为每个接口分配一个IP地址。然而，主机也可能拥有多个IP地址。这样的设备有时被称为*多宿主*。
- en: 'There are two ways that a host can be multihomed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 主机可以多宿主有两种方式：
- en: '**Two or More Interfaces to the Same Network** Devices such as servers or high-powered
    workstations may be equipped with two physical interfaces to the same network
    for performance and reliability reasons. They will have two IP addresses on the
    same network with the same network ID.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**同一网络上的两个或更多接口** 服务器或高性能工作站等设备可能出于性能和可靠性原因配备了连接到同一网络的两个物理接口。它们将在同一网络上有两个具有相同网络ID的IP地址。'
- en: '**Interfaces to Two or More Different Networks** Devices may have multiple
    interfaces to different networks. The IP addresses will typically have different
    network IDs in them.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到两个或更多不同网络的接口** 设备可能具有连接到不同网络的多个接口。IP地址通常包含不同的网络ID。'
- en: '[Figure 16-5](ch16s06.html#multihomed_devices_on_an_ip_internetwork "Figure 16-5. Multihomed
    devices on an IP internetwork This internetwork consists of two LANs, A (above)
    and B (below). LAN A has a multihomed workstation, shown with two IP network interface
    "circles." The two LANs are connected together through a multihomed, shared server
    that has been configured to route traffic between them. Note that this server
    also handles all traffic passing between LAN B and the Internet (since the Internet
    connection is in LAN A only).") shows examples of both types of multihomed device.
    Of course, these could be combined, with a host having two connections to one
    network and a third to another network. There are also some other special cases,
    such as a host with a single network connection having multiple IP address aliases.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-5](ch16s06.html#multihomed_devices_on_an_ip_internetwork "图16-5. IP互联网上的多宿主设备。这个互联网由两个局域网A（上方）和B（下方）组成。局域网A有一个多宿主工作站，用两个IP网络接口“圆圈”表示。两个局域网通过一个配置为在它们之间路由流量的多宿主共享服务器连接在一起。请注意，这个服务器还处理在局域网B和互联网之间传递的所有流量（因为互联网连接仅在局域网A中）")展示了这两种类型的多宿主设备的示例。当然，这些可以组合，一个主机可以有一个连接到一个网络，另一个连接到另一个网络。还有一些其他特殊情况，例如一个具有单个网络连接的主机有多个IP地址别名。'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*When subnetting is used, the same distinction can be made between multihoming
    to the same subnet or a different subnet*.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*当使用子网划分时，可以在同一子网或不同子网的多宿主之间做出相同的区分*。'
- en: Now, let's consider the second case. If a host has interfaces to two or more
    different networks, could it pass IP datagrams between them? Yes, if it had the
    right software running on it. And wouldn't that make the host a router, of sorts?
    In fact, that is exactly the case. A multihomed host with interfaces to two networks
    can use software to function as a router. This is sometimes called *software routing*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑第二种情况。如果一个主机连接到两个或更多不同的网络，它能否在这两个网络之间传递IP数据报？是的，如果它在上面运行了正确的软件。那么这不会使主机变成一种路由器吗？实际上，这正是这种情况。一个具有连接到两个网络的接口的多宿主主机可以使用软件作为路由器。这有时被称为*软件路由*。
- en: Using a host as a router has certain advantages and disadvantages compared to
    a hardware router. A server that is multihomed can perform routing functions and
    also, well, act as a server. A dedicated hardware router is designed for the job
    of routing and usually will be more efficient than a software program running
    on a host.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件路由器相比，使用主机作为路由器具有某些优点和缺点。一个多宿主的服务器可以执行路由功能，同时，嗯，充当服务器。专门设计的硬件路由器是为了路由任务而设计的，通常会比在主机上运行的软件程序更有效率。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A host with more than one IP network interface is said to be
    multihomed. A multihomed device can have multiple connections to the same network,
    to different networks, or both. A host connected to two networks can be configured
    to function as a router.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 拥有多个IP网络接口的主机被称为多宿主。一个多宿主设备可以连接到同一网络、不同网络或两者。一个连接到两个网络的主机可以被配置为作为路由器。'
- en: Multihoming was once considered a fairly esoteric application, but has become
    more common in recent years. This is also true of multihoming on different networks
    for software routing use. In fact, you may be doing this in your home without
    realizing it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多宿主曾经被认为是一种相当晦涩的应用，但近年来变得更加普遍。这在软件路由用途的多宿主不同网络方面也是正确的。实际上，你可能在家里做着这样的事情而自己并没有意识到。
- en: Suppose you have two PCs networked together and a single phone line to connect
    to the Internet. One computer dials up to your Internet service provider (ISP)
    and runs software such as Microsoft's Internet Connection Sharing (ICS) to let
    the other computer access the Internet. Millions of people do this every day—they
    have a multihomed system (the one connecting to the Internet and the other PC)
    with ICS acting in the role of a software router (though there are some technical
    differences between ICS and a true router, of course).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两台联网的PC和一个电话线路来连接到互联网。一台计算机拨号连接到你的互联网服务提供商（ISP），并运行如微软的互联网连接共享（ICS）软件，以便另一台计算机可以访问互联网。每天有成千上万的人这样做——他们有一个多宿主系统（连接到互联网和另一台PC），其中ICS充当软件路由器的角色（尽管ICS和真正的路由器之间当然有一些技术差异）。
- en: IP Address Management and Assignment Methods and Authorities
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址管理、分配方法和权限
- en: What would happen if you told someone that you lived at 34 Elm Street, and when
    he turned onto your road, he found four different houses with the number 34 on
    them? He probably would find your place eventually but wouldn't be too pleased.
    Neither would you or your mail carrier! And all of you folks are much smarter
    than computers. Like street addresses, IP addresses must be unique for them to
    be useful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你告诉某人你住在34号橡树街，当他驶入你的道路时，发现四栋房子上都有34号，会发生什么？他可能最终会找到你的地方，但不会太高兴。你和你家的信使也不会高兴。而且你们都比计算机聪明得多。就像街道地址一样，IP地址也必须是唯一的，才能发挥作用。
- en: '![Multihomed devices on an IP internetwork This internetwork consists of two
    LANs, A (above) and B (below). LAN A has a multihomed workstation, shown with
    two IP network interface "circles." The two LANs are connected together through
    a multihomed, shared server that has been configured to route traffic between
    them. Note that this server also handles all traffic passing between LAN B and
    the Internet (since the Internet connection is in LAN A only).](httpatomoreillycomsourcenostarchimages287799.png.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![IP互联网上的多宿主设备 该互联网由两个局域网A（上方）和B（下方）组成。局域网A有一个多宿主工作站，用两个IP网络接口“圆圈”表示。两个局域网通过一个配置为在它们之间路由流量的多宿主共享服务器连接在一起。请注意，该服务器还处理所有在局域网B和互联网之间传递的流量（因为互联网连接仅在局域网A中）](httpatomoreillycomsourcenostarchimages287799.png.jpg)'
- en: Figure 16-5. Multihomed devices on an IP internetwork This internetwork consists
    of two LANs, A (above) and B (below). LAN A has a multihomed workstation, shown
    with two IP network interface "circles." The two LANs are connected together through
    a multihomed, shared server that has been configured to route traffic between
    them. Note that this server also handles all traffic passing between LAN B and
    the Internet (since the Internet connection is in LAN A only).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-5. IP互联网上的多宿主设备 该互联网由两个局域网A（上方）和B（下方）组成。局域网A有一个多宿主工作站，用两个IP网络接口“圆圈”表示。两个局域网通过一个配置为在它们之间路由流量的多宿主共享服务器连接在一起。请注意，该服务器还处理所有在局域网B和互联网之间传递的流量（因为互联网连接仅在局域网A中）。
- en: Since IP datagrams are sent only within the confines of the IP internetwork,
    they must be unique within each internetwork. If you are a company with your own
    private internetwork, this isn't really a big problem. Whoever is in charge of
    maintaining the internetwork keeps a list of what numbers have been used where
    and makes sure that no two devices are given the same address. However, what happens
    in a public network with many different organizations? Here, it is essential that
    the IP address space be managed across the organizations to ensure that they use
    different addresses. It's not feasible to have each organization coordinate its
    activities with each other one. Therefore, some sort of centralized *management
    authority* is required.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IP数据报只发送在IP互联网的范围内，它们必须在每个互联网内是唯一的。如果你是一家拥有自己的私有互联网的公司，这并不是一个大问题。负责维护互联网的人会保留一个列表，记录哪些数字在哪里被使用，并确保没有两个设备被分配相同的地址。然而，在公共网络中，有多个不同的组织会发生什么？在这里，确保IP地址空间在组织间得到管理，以确保它们使用不同的地址是至关重要的。让每个组织与其他组织协调其活动是不切实际的。因此，需要某种形式的集中式*管理机构*。
- en: At the same time that you need someone to ensure that there are no conflicts
    in address assignment, you don't want users of the network to have to go to this
    central authority every time they need to make a change to their network. It makes
    more sense to have the authority assign numbers in blocks or chunks to organizations
    based on the number of devices they want to connect to the network. The organizations
    can manage those blocks as they see fit, and the authority's job is made easier
    because it deals in blocks instead of billions of individual addresses and machines.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在你需要有人确保地址分配没有冲突的同时，你不想让网络的用户每次需要更改他们的网络时都要去这个中央机构。根据他们想要连接到网络的设备数量，由该机构分配块或块状数字更有意义。组织可以根据自己的需要管理这些块，而权威机构的任务也因为处理的是块而不是数十亿个单独的地址和机器而变得更容易。
- en: 'The Internet, as the big IP internetwork, requires this coordination task to
    be performed for millions of organizations worldwide. The job of managing IP address
    assignment on the Internet was originally carried out by a single organization:
    the *Internet Assigned Number Authority (IANA)*. IANA was responsible for allocating
    IP addresses, along with other important centralized coordination functions such
    as managing universal parameters used for TCP/IP protocols. In the late 1990s,
    a new organization called the *Internet Corporation for Assigned Names and Numbers
    (ICANN)* was created. ICANN now oversees the IP address assignment task of IANA,
    as well as managing other tasks such as Domain Name System (DNS) name registration
    (see [Chapter 54](ch54.html "Chapter 54. DNS NAME REGISTRATION, PUBLIC ADMINISTRATION,
    ZONES, AND AUTHORITIES")).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网作为大的 IP 互联网，需要为全球数百万组织执行这项协调任务。最初，管理互联网上 IP 地址分配的工作由一个组织执行：互联网分配号码权威机构 (IANA)。IANA
    负责分配 IP 地址，以及管理其他重要的集中式协调功能，例如管理用于 TCP/IP 协议的通用参数。在 1990 年代末，一个新的组织——互联网名称和数字地址分配公司
    (ICANN) 被创建。ICANN 现在负责监督 IANA 的 IP 地址分配任务，以及管理其他任务，如域名系统 (DNS) 名称注册（参见[第 54 章](ch54.html
    "第 54 章。DNS 名称注册、公共管理、区域和权威")）。
- en: IP addresses were originally allocated directly to organizations. The original
    IP addressing scheme was based on classes, and so IANA would assign addresses
    in Class A, B, and C blocks. Today, addressing is classless, using CIDR's hierarchical
    addressing scheme. IANA doesn't assign addresses directly, but rather delegates
    them to regional Internet registries (RIRs). These are APNIC, ARIN, LACNIC, and
    RIPE NCC. Each RIR can, in turn, delegate blocks of addresses to lower-level registries
    such as national Internet registries (NIRs) and local Internet registries (LIRs).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址最初是直接分配给组织的。原始的 IP 地址方案基于类别，因此 IANA 会分配 A 类、B 类和 C 类块中的地址。今天，地址是无类的，使用
    CIDR 的分层地址方案。IANA 不直接分配地址，而是将它们委派给区域互联网注册机构 (RIRs)。这些是 APNIC、ARIN、LACNIC 和 RIPE
    NCC。每个 RIR 可以反过来将地址块委派给低级注册机构，如国家互联网注册机构 (NIRs) 和本地互联网注册机构 (LIRs)。
- en: Eventually, blocks of addresses are obtained by ISPs for distribution to end-user
    organizations. Some of the ISP's customers are end-user organizations, but others
    are (smaller) ISPs themselves. They can, in turn, use or delegate the addresses
    in their blocks. This can continue for several stages in a hierarchical fashion.
    This arrangement helps ensure that IP addresses are assigned and used in the most
    efficient manner possible. See [Chapter 20](ch20.html "Chapter 20. IP CLASSLESS
    ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"), which discusses
    CIDR, for more information on how this works.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，地址块由 ISP 获取，用于分配给最终用户组织。一些 ISP 的客户是最终用户组织，但其他的是（较小的）ISP 本身。他们可以反过来使用或委派他们块中的地址。这可以以分层的方式继续进行几个阶段。这种安排有助于确保
    IP 地址以最有效的方式分配和使用。有关如何工作的更多信息，请参阅[第 20 章](ch20.html "第 20 章。无类地址——无类域间路由 (CIDR)/超网")，其中讨论了
    CIDR。
- en: IANA, ICANN, and the RIRs are responsible for more than just IP address allocation,
    though I have concentrated on IP addresses here for obvious reasons. For more
    general information on IANA, ICANN, APNIC, ARIN, LACNIC, and RIPE NCC, try a can
    of alphabet soup—or [Chapter 3](ch03.html "Chapter 3. NETWORK STANDARDS AND STANDARDS
    ORGANIZATIONS"), which provides an overview of the Internet registration authorities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: IANA、ICANN 和 RIRs 负责的不仅仅是 IP 地址分配，尽管我这里主要关注 IP 地址，这是显而易见的原因。有关 IANA、ICANN、APNIC、ARIN、LACNIC
    和 RIPE NCC 的更一般信息，可以尝试一罐字母汤——或者查看[第 3 章](ch03.html "第 3 章。网络标准和标准组织")，其中提供了互联网注册机构的概述。
- en: Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 17 章。类地址（传统）地址
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The original addressing method for IP addresses divided the IP address space
    into five chunks of different sizes called *classes*, and assigned blocks of addresses
    to organizations from these classes based on the size and requirements of the
    organization. In this classful addressing scheme, each class is reserved for a
    particular purpose, with the main address classes differentiated based on how
    many octets are used for the network identifier (network ID) and how many are
    used for the host identifier (host ID).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 IP 地址地址方法将 IP 地址空间划分为五个不同大小的块，称为 *类别*，并根据组织的大小和需求从这些类别中分配地址块。在这个分类地址方案中，每个类别都保留用于特定目的，主要地址类别根据用于网络标识符（网络
    ID）的八位组数量以及用于主机标识符（主机 ID）的八位组数量来区分。
- en: In this chapter, I describe classful IP addressing. I begin with an overview
    of the concept and general description of the different classes. I discuss the
    network and host IDs and address ranges associated with the different classes.
    I discuss the capacities of each of the commonly used classes, meaning how many
    networks belong to each and how many hosts each network can contain. I discuss
    the special meanings assigned to certain IP address patterns and the special ranges
    reserved for private IP addressing, loopback functions, and multicasting. I conclude
    with a discussion of the problems with this type of addressing, which led to it
    being abandoned in favor of subnetting, and eventually, classless assignment of
    the IP address space.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了分类 IP 地址。我首先概述了该概念和不同类别的通用描述。我讨论了与不同类别相关的网络标识符和主机标识符以及地址范围。我讨论了常用类别的容量，即每个类别包含多少网络以及每个网络可以包含多少主机。我讨论了分配给某些
    IP 地址模式的特殊含义以及为私有 IP 地址、环回功能和多播保留的特殊范围。我最后讨论了这种地址类型的问题，这些问题导致了它被弃用，转而采用子网划分，最终实现了
    IP 地址空间的非分类分配。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The classful addressing scheme has been replaced by the classless addressing
    system described in [Chapter 20](ch20.html "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS
    INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"). However, I think it is still important
    to understand how this original system operates, as it forms the basis for the
    more sophisticated addressing mechanisms.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*分类地址方案已被第 20 章中描述的无类别地址系统所取代（ch20.html "第 20 章. IP 无类别地址——无类别域间路由（CIDR）/超网”）。然而，我认为了解这个原始系统是如何运作的仍然很重要，因为它构成了更复杂地址机制的基础。*'
- en: IP Classful Addressing Overview and Address Classes
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 地址分类概述及地址类别
- en: The developers of the Internet Protocol (IP) recognized that organizations come
    in different sizes and would therefore need varying numbers of IP addresses on
    the Internet. They devised a system to divide the IP address space into *classes*,
    each of which contained a portion of the total addresses and was dedicated to
    specific uses. Some classes would be devoted to large networks on the Internet,
    while others would be reserved for smaller organizations or special purposes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）的开发者认识到，组织的大小各不相同，因此需要在互联网上使用不同数量的 IP 地址。他们设计了一个系统来将 IP 地址空间划分为 *类别*，每个类别包含总地址的一部分，并专门用于特定用途。一些类别将用于互联网上的大型网络，而其他类别则保留给较小的组织或特殊用途。
- en: This original system had no name; it was simply "the" IP addressing system.
    Today it is called the *classful addressing scheme* to differentiate it from the
    newer classless scheme.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原始系统没有名称；它只是“IP 地址系统”。今天，它被称为 *分类地址方案*，以区分较新的无类别方案。
- en: IP Address Classes
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 地址类别
- en: There are five classes in the classful system, which are assigned the letters
    A through E. [Table 17-1](ch17.html#ip_address_classes_and_class_characteris "Table 17-1. IP
    Address Classes and Class Characteristics and Uses") provides some general information
    about the classes, their intended uses, and their characteristics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在分类系统中，有五个类别，分别用字母 A 到 E 表示。[表 17-1](ch17.html#ip_address_classes_and_class_characteris
    "表 17-1. IP 地址类别及其特性与用途") 提供了有关类别、其旨在用途和其特性的某些一般信息。
- en: Table 17-1. IP Address Classes and Class Characteristics and Uses
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-1. IP 地址类别及其特性与用途
- en: '| IP Address Class | Fraction of Total IP Address Space | Number of Network
    ID Bits | Number of Host ID Bits | Intended Use |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| IP 地址类别 | 总 IP 地址空间的比例 | 网络标识符位数 | 主机标识符位数 | 旨在用途 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Class A** | 1/2 | 8 | 24 | Unicast addressing for very large organizations
    with hundreds of thousands or millions of hosts to connect to the Internet |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **类别 A** | 1/2 | 8 | 24 | 用于连接到互联网的非常大型组织，拥有数十万或数百万个主机 |'
- en: '| **Class B** | 1/4 | 16 | 16 | Unicast addressing for medium to large organizations
    with many hundreds to thousands of hosts to connect to the Internet |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **类别 B** | 1/4 | 16 | 16 | 用于连接到互联网的中等到大型组织，拥有数百到数千个主机 |'
- en: '| **Class C** | 1/8 | 24 | 8 | Unicast addressing for smaller organizations
    with no more than about 250 hosts to connect to the Internet |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **类别 C** | 1/8 | 24 | 8 | 用于连接到互联网的小型组织，不超过约 250 个主机 |'
- en: '| **Class D** | 1/16 | n/a | n/a | IP multicasting |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **类别 D** | 1/16 | n/a | n/a | IP 多播 |'
- en: '| **Class E** | 1/16 | n/a | n/a | Reserved for experimental use |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **类别 E** | 1/16 | n/a | n/a | 保留用于实验用途 |'
- en: Looking at this table (and [Figure 17-1](ch17.html#division_of_ipv4_address_space_into_clas
    "Figure 17-1. Division of IPv4 address space into classes")), you can see that
    Classes A, B, and C take up most of the total address space (seven-eighths of
    it). These are the classes used for *unicast* IP addressing and messages sent
    to a single network interface. (The blocks also include associated broadcast addresses
    for these networks.) This is what I usually consider normal IP addressing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这张表格（以及[图 17-1](ch17.html#division_of_ipv4_address_space_into_clas "图 17-1.
    IPv4 地址空间的类别划分"))，您可以看到类别 A、B 和 C 占据了大部分的总地址空间（七分之八）。这些类别用于 *单播* IP 地址和发送到单个网络接口的消息。（这些块还包括这些网络的关联广播地址。）这就是我通常认为的正常
    IP 地址。
- en: '![Division of IPv4 address space into classes](httpatomoreillycomsourcenostarchimages287801.png.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4 地址空间的类别划分](httpatomoreillycomsourcenostarchimages287801.png.jpg)'
- en: Figure 17-1. Division of IPv4 address space into classes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-1. IPv4 地址空间的类别划分
- en: You can think of Classes A, B, and C as the papa bear, mama bear, and baby bear
    of traditional IP addressing. They allow the Internet to provide addressing for
    a small number of very large networks, a moderate number of medium-sized organizations,
    and a large number of smaller companies. This approximately reflects the distribution
    of organization sizes in the real world, though the large gulf in the maximum
    number of hosts allowed for each address class leads to inflexibility, as I will
    discuss later in the chapter.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将类别 A、B 和 C 视为传统 IP 地址中的大熊爸爸、大熊妈妈和小熊宝宝。它们允许互联网为少量非常大的网络、中等数量的中等规模组织和大量的小公司提供地址。这大致反映了现实世界中组织规模的分布，尽管每个地址类别允许的最大主机数量之间的巨大差距导致了一定的不灵活性，我将在本章后面讨论这一点。
- en: As you can see, the classes differ in where they draw the line between the network
    ID and the host ID portions of the addresses they contain. However, in each case,
    the division is made on octet boundaries. In classful addressing, the division
    does not occur within an octet.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类别之间的区别在于它们在地址的网络 ID 和主机 ID 部分之间划定的界限。然而，在每种情况下，划分都是在八位字节边界上进行的。在类别地址中，划分不会在八位字节内部发生。
- en: Classes D and E are special—to the point where many people don't even realize
    they exist. Class D is used for IP multicasting, while Class E is reserved for
    experimental use (by designers of the Internet). I discuss IP multicast addressing
    later in this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类别 D 和 E 是特殊的——以至于许多人甚至没有意识到它们的存在。类别 D 用于 IP 多播，而类别 E 保留用于实验用途（由互联网的设计师）。我在本章后面讨论
    IP 多播地址。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The classful IP addressing scheme divides the IP address space
    into five classes, A through E, of differing sizes. Classes A, B, and C are the
    most important ones, designated for conventional unicast addresses and taking
    up seven-eighths of the address space. Class D is reserved for IP multicasting,
    and Class E is reserved for experimental use.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 类别 IP 地址方案将 IP 地址空间划分为五个不同大小的类别，从 A 到 E。类别 A、B 和 C 是最重要的，指定用于传统单播地址，占据了地址空间的七分之八。类别
    D 保留用于 IP 多播，类别 E 保留用于实验用途。'
- en: Rationale for Classful Addressing
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别地址划分的原理
- en: 'While the drawbacks of the classful system are often discussed today (as you''ll
    see later in this chapter), it''s important to keep in context what the size of
    the Internet was when this system was developed. The Internet was tiny then, and
    the 32-bit address space seemed enormous by comparison to even the number of machinesits
    creators envisioned years into the future. It''s only fair to also remember the
    following advantages of the classful system developed over 25 years ago:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然今天经常讨论类别寻址方案的缺点（您将在本章后面看到），但了解在开发此系统时互联网的大小是很重要的。当时互联网很小，与创造者多年后预想的机器数量相比，32位地址空间似乎巨大无比。公平地说，也应该记住25年前开发的类别寻址系统的以下优点：
- en: '**Simplicity and Clarity** There are only a few classes to choose from, and
    it''s very simple to understand how the addresses are split up. The distinction
    between classes is clear and obvious. The divisions between network ID and host
    ID in Classes A, B, and C are on octet boundaries, making it easy to tell what
    the network ID is of any address.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单明了** 可供选择的类别只有几个，理解地址如何划分非常简单。类别的区别清晰且明显。A、B和C类中网络ID和主机ID之间的划分在八位字节边界上，这使得确定任何地址的网络ID变得容易。'
- en: '**Reasonable Flexibility** Three levels of granularity match the sizes of large,
    medium-sized, and small organizations reasonably well. The original system provided
    enough capacity to handle the anticipated growth rate of the Internet at the time.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**合理的灵活性** 三种粒度级别与大型、中型和小型组织的规模相当匹配。原始系统提供了足够的容量来处理当时互联网预期的增长速度。'
- en: '**Routing Ease** As you will see shortly, the class of the address is encoded
    right into the address to make it easy for routers to know what part of any address
    is the network ID and what part is the host ID. There was no need for adjunct
    information such as a subnet mask.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由便捷性** 如您很快就会看到的，地址类别被编码到地址中，以便路由器知道任何地址的哪一部分是网络ID，哪一部分是主机ID。不需要附加信息，如子网掩码。'
- en: '**Reserved Addresses** Certain addresses are reserved for special purposes.
    This includes not just Classes D and E, but also special reserved address ranges
    for private addressing.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留地址** 某些地址被保留用于特殊目的。这不仅包括D类和E类，还包括用于私有寻址的特殊保留地址范围。'
- en: Of course, it turned out that some of the decisions in the original IP addressing
    scheme were regrettable—but that's the benefit of hindsight. I'm sure we would
    all like to have back the 268-odd million addresses that were set aside for Class
    E. While it may seem wasteful now to have reserved a full one-sixteenth of the
    address space for experimental use, remember that the current size of the Internet
    was never anticipated even 10 years ago, never mind 25\. Furthermore, it's good
    practice to reserve some portion of any scarce resource for future use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，后来发现原始IP寻址方案中的一些决策是令人遗憾的——但这正是事后诸葛亮的益处。我相信我们都会希望收回为E类保留的约2.68亿个地址。虽然现在看来为实验用途保留地址空间的三分之一似乎有些浪费，但请记住，即使在10年前，也从未预料到互联网的当前规模，更不用说25年前了。此外，为任何稀缺资源预留一部分以备将来使用是良好的实践。
- en: IP Classful Addressing Network and Host Identification and Address Ranges
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP类别寻址网络和主机标识及地址范围
- en: 'The classful IP addressing scheme divides the total IP address space into five
    classes, A through E. One of the benefits of the relatively simple classful scheme
    is that information about the classes is encoded directly into the IP address.
    This means you can determine in advance which address ranges belong to each class.
    It also means the opposite is possible: You can identify which class is associated
    with any address by examining just a few bits of the address. This latter benefit
    was one of the main motivators for the initial creation of the classful system.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类别IP寻址方案将整个IP地址空间划分为A到E五个类别。相对简单的类别寻址方案的一个好处是，关于类别的信息直接编码到IP地址中。这意味着你可以事先确定哪些地址范围属于每个类别。这也意味着相反的情况是可能的：你只需检查地址的一小部分就能确定与任何地址关联的类别。这种后者的好处是类别寻址系统最初创建的主要动机之一。
- en: Classful Addressing Class Determination Algorithm
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别寻址类别确定算法
- en: When TCP/IP was first created, computer technology was still in its infancy.
    Routers needed to be able to quickly make decisions about how to move IP datagrams
    around. The IP address space was split into classes in such a way that, by looking
    at only the first few bits of any IP address, the router could easily tell how
    to choose between the network and host ID, and thus what to do with the datagram.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当TCP/IP最初创建时，计算机技术还处于起步阶段。路由器需要能够快速做出关于如何移动IP数据报的决定。IP地址空间被划分为类别，使得通过查看任何IP地址的前几个比特，路由器可以轻松地判断如何选择网络ID和主机ID，从而确定对数据报的处理方式。
- en: The number of bits the router needs to look at may be as few as one or as many
    as four, depending on what it finds when it starts looking. The algorithm used
    to determine the class corresponds to the system used to divide the address space,
    as illustrated in [Figure 17-2](ch17s02.html#class_determination_algorithm_for_classf
    "Figure 17-2. Class determination algorithm for classful IP addresses The simplicity
    of the classful IP addressing can be seen in the very uncomplicated algorithm
    used to determine the class of an address.").
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器需要查看的位数可能从1位到4位不等，这取决于它开始查找时发现的内容。用于确定类别的算法对应于用于划分地址空间的系统，如图17-2所示。
- en: '![Class determination algorithm for classful IP addresses The simplicity of
    the classful IP addressing can be seen in the very uncomplicated algorithm used
    to determine the class of an address.](httpatomoreillycomsourcenostarchimages287803.png.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![类别确定算法用于类别IP地址 类别IP地址的简单性可以从用于确定地址类别的非常简单的算法中看出。](httpatomoreillycomsourcenostarchimages287803.png.jpg)'
- en: Figure 17-2. Class determination algorithm for classful IP addresses The simplicity
    of the classful IP addressing can be seen in the very uncomplicated algorithm
    used to determine the class of an address.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-2. 类别确定算法用于类别IP地址 类别IP地址的简单性可以从用于确定地址类别的非常简单的算法中看出。
- en: 'Here are the four very basic steps in the algorithm:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是算法中的四个非常基本的步骤：
- en: If the first bit is a 0, it's a Class A address, and you're done. (Half the
    address space has a 0 for the first bit, so this is why Class A takes up half
    the address space.) If it's a 1, continue to step 2.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第一个比特是0，则这是一个A类地址，任务完成。（地址空间的一半以0作为第一个比特，这就是为什么A类占据一半地址空间的原因。）如果它是1，继续到步骤2。
- en: If the second bit is a 0, it's a Class B address, and you're done. (Half of
    the remaining non–Class A addresses, or one quarter of the total.) If it's a 1,
    continue to step 3.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第二位是0，则这是一个B类地址，任务完成。（剩余的非A类地址的一半，或者总量的四分之一。）如果它是1，继续到步骤3。
- en: If the third bit is a 0, it's a Class C address, and you're done. (Half again
    of what's left, or one-eighth of the total.) If it's a 1, continue to step 4.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第三位是0，则这是一个C类地址，任务完成。（剩余部分再减半，或者总量的八分之一。）如果它是1，继续到步骤4。
- en: If the fourth bit is a 0, it's a Class D address. (Half the remainder, or one-sixteenth
    of the address space.) If it's a 1, it's a Class E address. (The other half, one-sixteenth.)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果第四位是0，则这是一个D类地址。（剩余部分的一半，或者地址空间的十六分之一。）如果它是1，则是一个E类地址。（另一半，十六分之一。）
- en: And that's pretty much it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 大概就是这样。
- en: Determining Address Class from the First Octet Bit Pattern
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从第一个八位字节位模式确定地址类别
- en: As humans, of course, we generally work with addresses in dotted decimal notation
    and not in binary, but it's pretty easy to see the ranges that correspond to the
    classes. For example, consider Class B. The first two bits of the first octet
    are 10\. The remaining bits can be any combination of ones and zeros. This is
    normally represented as 10xx xxxx (shown as two groups of four for readability).
    Thus, the binary for the first octet can range from **10**00 0000 to **10**11
    1111 (128 to 191 in decimal). So in the classful scheme, any IP address whose
    first octet is between 128 and 191 inclusive is a Class B address.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为人类，我们通常使用点分十进制地址而不是二进制地址来工作，但很容易看出与类别相对应的范围。例如，考虑B类。第一个八位字节的头两位是10。剩余的位可以是任意组合的1和0。这通常表示为10xx
    xxxx（为了可读性，显示为两组四个）。因此，第一个八位字节的二进制范围可以从**10**00 0000到**10**11 1111（十进制中的128到191）。因此，在类别方案中，任何第一个八位字节在128到191（含）之间的IP地址都是B类地址。
- en: '[Table 17-2](ch17s02.html#ip_address_class_bit_patterns_first-octe "Table 17-2. IP
    Address Class Bit Patterns, First-Octet Ranges, and Address Ranges") shows the
    bit patterns for each of the five classes and the way that the first octet ranges
    can be calculated. The first column shows the format of the first octet of the
    IP address; the *x*s can be either a zero or a one. Next are the lowest and highest
    value columns for each class in binary (the fixed few bits are in bold print so
    you can see that they do not change while the others do), followed by the corresponding
    range for the first octet, in decimal.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 17-2](ch17s02.html#ip_address_class_bit_patterns_first-octet "表 17-2. IP
    地址类别位模式、第一个八位字节范围和地址范围") 显示了每个五个类别的位模式以及如何计算第一个八位字节的范围。第一列显示了IP地址第一个八位字节的格式；*x*可以是零或一。接下来是每个类别的最低和最高值列（固定的几个位以粗体字打印，以便您可以看到它们在变化时保持不变），然后是第一个八位字节的对应范围，以十进制表示。'
- en: Table 17-2. IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-2. IP 地址类别位模式、第一个八位字节范围和地址范围
- en: '| IP Address Class | First Octet of IP Address | Lowest Value of First Octet
    (Binary) | Highest Value of First Octet (Binary) | Range of First Octet Values
    (Decimal) | Octets in Network ID/Host ID | Theoretical IP Address Range |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| IP 地址类别 | IP 地址的第一个八位字节 | 第一个八位字节的最低值（二进制） | 第一个八位字节的最大值（二进制） | 第一个八位字节的值范围（十进制）
    | 网络ID/主机ID的八位字节 | 理论上的IP地址范围 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Class A** | **0**xxx xxxx | **0**000 0001 | **0**111 1110 | 1 to 126 |
    1 / 3 | 1.0.0.0 to 126.255.255.255 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **A类** | **0**xxx xxxx | **0**000 0001 | **0**111 1110 | 1 to 126 | 1 / 3
    | 1.0.0.0 to 126.255.255.255 |'
- en: '| **Class B** | **10**xx xxxx | **10**00 0000 | **10**11 1111 | 128 to 191
    | 2 / 2 | 128.0.0.0 to 191.255.255.255 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **B类** | **10**xx xxxx | **10**00 0000 | **10**11 1111 | 128 to 191 | 2 /
    2 | 128.0.0.0 to 191.255.255.255 |'
- en: '| **Class C** | **110**x xxxx | **110**0 0000 | **110**1 1111 | 192 to 223
    | 3 / 1 | 192.0.0.0 to 223.255.255.255 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **C类** | **110**x xxxx | **110**0 0000 | **110**1 1111 | 192 to 223 | 3 /
    1 | 192.0.0.0 to 223.255.255.255 |'
- en: '| **Class D** | **1110** xxxx | **1110** 0000 | **1110** 1111 | 224 to 239
    | — | 224.0.0.0 to 239.255.255.255 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **D类** | **1110** xxxx | **1110** 0000 | **1110** 1111 | 224 to 239 | — |
    224.0.0.0 to 239.255.255.255 |'
- en: '| **Class E** | **1111** xxxx | **1111** 0000 | **1111** 1111 | 240 to 255
    | — | 240.0.0.0 to 255.255.255.255 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **E类** | **1111** xxxx | **1111** 0000 | **1111** 1111 | 240 to 255 | — |
    240.0.0.0 to 255.255.255.255 |'
- en: This table also shows the *theoretical* lowest and highest IP address ranges
    for each of the classes. This means that they are the result of taking the full
    span of binary numbers possible in each class. In reality, some of the values
    are not available for normal use. For example, even though the range 192.0.0.0
    to 192.0.0.255 is technically in Class C, it is reserved and not actually used
    by hosts on the Internet.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此表还显示了每个类别的*理论*最低和最高IP地址范围。这意味着它们是取每个类别中可能的完整二进制数范围的结果。实际上，某些值可能无法用于常规使用。例如，尽管192.0.0.0到192.0.0.255的范围在技术上属于C类，但它被保留，并且实际上并未被互联网上的主机使用。
- en: Also, certain IP addresses cannot be used because they have special meaning.
    For example, 255.255.255.255 is a reserved broadcast address. In a similar vein,
    note that the range for Class A is from 1 to 126 and not 0 to 127 as you might
    have expected. This is because Class A networks 0 and 127 are reserved; 127 is
    the network that contains the IP loopback address. These special and reserved
    addresses are discussed later in this chapter.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些IP地址不能使用，因为它们具有特殊含义。例如，255.255.255.255是一个保留的广播地址。类似地，请注意，A类的范围是从1到126，而不是您可能预期的0到127。这是因为A类网络中的0和127是保留的；127是包含IP环回地址的网络。这些特殊和保留的地址将在本章后面讨论。
- en: 'Recall that Classes A, B, and C differ in where the dividing line is between
    the network ID and the host ID: 1 for network and 3 for host for Class A, 2 for
    each for Class B, and 3 for network and 1 for host for Class C. Based on this
    division, in [Table 17-2](ch17s02.html#ip_address_class_bit_patterns_first-octe
    "Table 17-2. IP Address Class Bit Patterns, First-Octet Ranges, and Address Ranges"),
    I have highlighted the network ID portion of the IP address ranges for each of
    Classes A, B, and C. The plain text corresponds to the range of host IDs for each
    allowable network ID. [Figure 17-3](ch17s02.html#ip_address_class_bit_assignments_and_net
    "Figure 17-3. IP address class bit assignments and network/host ID sizes This
    illustration shows how the 32 bits of IP address are assigned for each of the
    five IP address classes. Classes A, B, and C are the normal classes used for regular
    unicast addresses; each has a different dividing point between the network ID
    and host ID. Classes D and E are special and are not divided in this manner.")
    shows graphically how bits are used in each of the five classes.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，类别 A、B 和 C 在网络 ID 和主机 ID 之间的分割线是不同的：类别 A 为网络 1 位，主机 3 位；类别 B 为每个 2 位；类别
    C 为网络 3 位，主机 1 位。基于这种分割，我在 [表 17-2](ch17s02.html#ip_address_class_bit_patterns_first-octe
    "表 17-2. IP 地址类别位模式，第一字节范围和地址范围") 中突出了每个类别 A、B 和 C 的 IP 地址范围中的网络 ID 部分。纯文本对应于每个允许的网络
    ID 的主机 ID 范围。[图 17-3](ch17s02.html#ip_address_class_bit_assignments_and_net "图
    17-3. IP 地址类别位分配和网络/主机 ID 大小 此图示展示了 IP 地址的 32 位是如何分配给五个 IP 地址类别的。类别 A、B 和 C 是用于常规单播地址的正常类别；每个类别在网络
    ID 和主机 ID 之间都有不同的分割点。类别 D 和 E 是特殊的，并且不以这种方式分割。") 以图形方式展示了每个类别中位的使用情况。
- en: '![IP address class bit assignments and network/host ID sizes This illustration
    shows how the 32 bits of IP address are assigned for each of the five IP address
    classes. Classes A, B, and C are the normal classes used for regular unicast addresses;
    each has a different dividing point between the network ID and host ID. Classes
    D and E are special and are not divided in this manner.](httpatomoreillycomsourcenostarchimages287805.png.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![IP 地址类别位分配和网络/主机 ID 大小 此图示展示了 IP 地址的 32 位是如何分配给五个 IP 地址类别的。类别 A、B 和 C 是用于常规单播地址的正常类别；每个类别在网络
    ID 和主机 ID 之间都有不同的分割点。类别 D 和 E 是特殊的，并且不以这种方式分割。](httpatomoreillycomsourcenostarchimages287805.png.jpg)'
- en: Figure 17-3. IP address class bit assignments and network/host ID sizes This
    illustration shows how the 32 bits of IP address are assigned for each of the
    five IP address classes. Classes A, B, and C are the normal classes used for regular
    unicast addresses; each has a different dividing point between the network ID
    and host ID. Classes D and E are special and are not divided in this manner.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17-3. IP 地址类别位分配和网络/主机 ID 大小 此图示展示了 IP 地址的 32 位是如何分配给五个 IP 地址类别的。类别 A、B 和
    C 是用于常规单播地址的正常类别；每个类别在网络 ID 和主机 ID 之间都有不同的分割点。类别 D 和 E 是特殊的，并且不以这种方式分割。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In the classful IP addressing scheme, the class of an IP address
    is identified by looking at the first one, two, three, or four bits of the address.
    This can be done both by humans working with these addresses and routers making
    routing decisions. The use of these bit patterns means that IP addresses in different
    classes fall into particular address ranges that allow an address''s class to
    be determined by looking at the first byte of its dotted decimal address.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在类别 IP 地址方案中，IP 地址的类别是通过查看地址的第一位、两位、三位或四位来确定的。这既可以通过处理这些地址的人类完成，也可以通过做出路由决策的路由器完成。使用这些位模式意味着不同类别的
    IP 地址落入特定的地址范围，通过查看其点分十进制地址的第一字节即可确定地址的类别。'
- en: For example, consider Class C. The lowest IP address is **192.0.0**.0, and the
    highest is **223.255.255**.255\. The first three octets are the network ID and
    can range from **192.0.0** to **223.255.255**. For each network ID in that range,
    the host ID can range from 0 to 255.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑类别 C。最低的 IP 地址是 **192.0.0**.0，最高的 IP 地址是 **223.255.255**.255。前三个八位字节是网络
    ID，其范围从 **192.0.0** 到 **223.255.255**。对于该范围内的每个网络 ID，主机 ID 的范围从 0 到 255。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It is common to see resources refer to the network ID of a classful address
    as including only the significant bits; that is, only the ones that are not common
    to all networks of that class. For example, you may see a Class B network ID shown
    in a diagram as having 14 bits, with the 10 that starts all such networks shown
    separately, as if it were not part of the network ID. Remember that the network
    ID does include those bits as well; it is 8 full bits for Class A, 16 for Class
    B, and 24 for Class C. In the case of Class D addresses, all 32 bits are part
    of the address, but only the lower 28 bits are part of the multicast group address;
    see the topic on multicast addressing later in this chapter for more*.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*通常人们会看到资源将类别地址的网络 ID 仅指包括重要的位；也就是说，只有那些不属于该类别所有网络的位。例如，你可能会看到一个类别 B 网络ID在图中显示为14位，其中起始所有此类网络的10位被单独显示，好像它不是网络
    ID 的一部分。记住，网络 ID 也包括这些位；对于类别 A 是8个完整的位，对于类别 B 是16位，对于类别 C 是24位。在类别 D 地址的情况下，所有的32位都是地址的一部分，但只有低位的28位是组播组地址的一部分；有关更多内容，请参阅本章后面的多播地址主题*。'
- en: IP Address Class A, B, and C Network and Host Capacities
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 地址类别 A、B 和 C 的网络和主机容量
- en: So far, I have introduced the concepts of IP address classes and showed how
    the classes relate to ranges of IP addresses. Of the five classes, D and E are
    dedicated to special purposes, so I will leave those alone for now. Classes A,
    B, and C are the ones actually assigned for normal (unicast) addressing purposes
    on IP internetworks, and therefore they are the primary focus of our continued
    attention.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经介绍了 IP 地址类别的概念，并展示了类别如何与 IP 地址的范围相关联。在五个类别中，D 和 E 类别是专门用于特殊目的的，所以我现在将暂时不讨论这些。类别
    A、B 和 C 是实际分配用于在 IP 互联网上执行正常（单播）地址目的的类别，因此它们是我们持续关注的重点。
- en: As you've seen, the classes differ in the number of bits (and octets) used for
    the network ID compared to the host ID. The number of different networks possible
    in each class is a function of the number of bits assigned to the network ID,
    and likewise, the number of hosts possible in each network depends on the number
    of bits provided for the host ID. You must also take into account the fact that
    one, two, or three of the bits in the IP address are used to indicate the class
    itself, so it is effectively excluded from use in determining the number of networks
    (though again, it is still part of the network ID).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，类别之间的区别在于用于网络 ID 的位数（和八位字节）与用于主机 ID 的位数。每个类别可能的不同网络数量是分配给网络 ID 的位数的一个函数，同样，每个网络可能的主机数量取决于为主机
    ID 提供的位数。你还必须考虑到，IP 地址中的1、2或3位被用来指示类别本身，因此实际上这些位被排除在用于确定网络数量的计算之外（尽管它仍然是网络 ID
    的一部分）。
- en: Based on this information, you can calculate the number of networks in each
    class, and for each class, the number of host IDs per network. [Table 17-3](ch17s03.html#ip_address_class_network_and_host_capaci
    "Table 17-3. IP Address Class Network and Host Capacities") shows the calculations.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，你可以计算出每个类别的网络数量，以及每个类别的每个网络的主机ID数量。[表 17-3](ch17s03.html#ip_address_class_network_and_host_capaci
    "表 17-3. IP 地址类别网络和主机容量")显示了计算结果。
- en: Table 17-3. IP Address Class Network and Host Capacities
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-3. IP 地址类别网络和主机容量
- en: '| IP Address Class | Total # of Bits for Network ID/Host ID | First Octet of
    IP Address | # of Network ID Bits Used To Identify Class | Usable # of Network
    ID Bits | Number of Possible Network IDs | # of Host IDs Per Network ID |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| IP 地址类别 | 网络ID/主机ID的总位数 | IP 地址的第一个八位字节 | 用于识别类别的网络ID位数 | 可用的网络ID位数 | 可能的网络ID数量
    | 每个网络ID的主机ID数量 |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **Class A** | 8/24 | 0xxx xxxx | 1 | 8-1 = 7 | 2⁷-2 = 126 | 2^(24)-2 = 16,277,214
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **类别 A** | 8/24 | 0xxx xxxx | 1 | 8-1 = 7 | 2⁷-2 = 126 | 2^(24)-2 = 16,277,214
    |'
- en: '| **Class B** | 16/16 | 10xx xxxx | 2 | 16-2 = 14 | 2^(14) = 16,384 | 2^(16)-2
    = 65,534 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **类别 B** | 16/16 | 10xx xxxx | 2 | 16-2 = 14 | 2^(14) = 16,384 | 2^(16)-2
    = 65,534 |'
- en: '| **Class C** | 24/8 | 110x xxxx | 3 | 24-3 = 21 | 2^(21) = 2,097,152 | 2⁸-2
    = 254 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **类别 C** | 24/8 | 110x xxxx | 3 | 24-3 = 21 | 2^(21) = 2,097,152 | 2⁸-2 =
    254 |'
- en: Let's walk through one line of this table so you can see how it works using
    Class B as an example. The basic division is into 16 bits for network ID and 16
    bits for host ID. However, the first 2 bits of all Class B addresses must be 10,
    so that leaves only 14 bits to uniquely identify the network ID. This gives us
    a total of 2^(14) or 16,384 Class B network IDs. For each of these, you have 2^(16)
    host IDs, less two, for a total of 65,534.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个表格中的一行，以便您了解它是如何工作的，以B类为例。基本的划分是16位用于网络ID，16位用于主机ID。然而，所有B类地址的前两位必须是10，这样就只剩下14位来唯一标识网络ID。这给我们提供了总共2^14或16,384个B类网络ID。对于这些中的每一个，您都有2^16个主机ID，减去两个，总共为65,534。
- en: 'Why less two? For each network ID, two host IDs cannot be used: the host ID
    with all zeros and the ID with all ones. These are addresses with special meanings,
    as described in the next section. Also notice that two is subtracted from the
    number of network IDs for Class A. This is because two of the Class A network
    IDs (0 and 127) are reserved.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么减去两个？对于每个网络ID，有两个主机ID不能使用：全零的主机ID和全一的主机ID。这些地址具有特殊含义，如下一节所述。同时请注意，从A类网络ID的数量中减去两个。这是因为两个A类网络ID（0和127）被保留。
- en: Several other address ranges are set aside in all three of the classes shown
    here. They are listed in the "IP Reserved, Private, and Loopback Addresses" section
    later in this chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的三个类中，都预留了几个其他的地址范围。它们将在本章后面的“IP保留、私有和环回地址”部分列出。
- en: Tip
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In the classful IP addressing scheme, a Class A network contains
    addresses for about 16 million network interfaces; a Class B network contains
    about 65,000; and a Class C network contains 254.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在按类IP编址方案中，一个A类网络包含大约1600万个网络接口的地址；一个B类网络包含大约65,000个；一个C类网络包含254个。'
- en: As you can see, there is quite a disparity in the number of hosts available
    for each network in each of these classes. What happens if an organization needs
    1,000 IP addresses? It must use either four Class Cs or one Class B (and in so
    doing, waste over 90 percent of the possible addresses in the Class B network).
    Bear in mind that there are only about 16,000 Class B network IDs available worldwide,
    and you begin to understand one of the big problems with classful addressing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这些类中，每个网络可用的主机数量差异很大。如果一个组织需要1,000个IP地址，它必须使用四个C类或者一个B类（这样做会浪费B类网络中超过90%的可能地址）。请记住，全球只有大约16,000个B类网络ID可用，您开始理解按类编址的一个大问题。
- en: IP Addresses with Special Meanings
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有特殊含义的IP地址
- en: Some IP addresses do not refer directly to specific hardware devices; instead,
    they are used to refer indirectly to one or more devices. To draw an analogy with
    language, most IP addresses refer to proper nouns, like "John" or "the red table
    in the corner." However, some are used more the way you use pronouns such as "this
    one" or "that group over there." I call these IP addresses with *special meanings*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些IP地址并不直接指向特定的硬件设备；相反，它们被用来间接地指向一个或多个设备。为了与语言进行类比，大多数IP地址指的是专有名词，如“John”或“角落里的那张红桌子。”然而，有些被用来更类似于您使用代词的方式，如“这个”或“那边的那组。”我把这些具有*特殊含义*的IP地址称为特殊IP地址。
- en: 'These special addresses are constructed by replacing the normal network ID
    or host ID (or both) in an IP address with one of two special patterns:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊地址是通过在IP地址中将正常的网络ID或主机ID（或两者）替换为两种特殊模式之一来构建的：
- en: '**All Zeros** When the network ID or host ID bits are replaced by a set of
    all zeros, the special meaning is the equivalent of the pronoun *this*, referring
    to whatever was replaced. It can also be interpreted as *the default* or the *current*.
    For example, if you replace the network ID with all zeros but leave the host ID
    alone, the resulting address means "the device with the host ID given, on *this
    network*,"or "the device with the host ID specified, on *the default network*
    or *the current network*."'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**全零** 当网络ID或主机ID位被一组全零位替换时，特殊含义等同于代词*这个*，指代被替换的内容。它也可以解释为*默认*或*当前*。例如，如果您用全零替换网络ID，但保留主机ID不变，那么得到的地址意味着“具有给定主机ID的设备，在*这个网络*上，”或“具有指定主机ID的设备，在*默认网络*或*当前网络*上。”'
- en: '**All Ones** When the network ID or host ID bits are replaced by a set of all
    ones, this has the special meaning of *all*, meaning that the IP address refers
    to all hosts on the network. This is generally used as a broadcast address for
    sending a message to everyone.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**全一** 当网络ID或主机ID位被全部为一的集合替换时，这具有“所有”的特殊含义，意味着IP地址指的是网络上的所有主机。这通常用作广播地址，向所有人发送消息。'
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** When the network ID or host ID of an IP address is replaced
    by a pattern of all ones or all zeros, the result is an address with a special
    meaning. Examples of such addresses include "all hosts" broadcast addresses and
    addresses that refer to a specific host or a whole network.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当IP地址的网络ID或主机ID被全部为一的图案替换时，结果是具有特殊含义的地址。此类地址的示例包括“所有主机”广播地址和指向特定主机或整个网络的地址。'
- en: There are many special addresses. A small number apply to the entire TCP/IP
    network, while others exist for each network or host ID. Since two special patterns
    can be applied to the network ID, host ID, or both, there are six potential combinations,
    each of which has its own meaning. Of these, five are used.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多特殊地址。其中一小部分适用于整个TCP/IP网络，而其他则存在于每个网络或主机ID。由于两个特殊模式可以应用于网络ID、主机ID或两者，因此有六种可能的组合，每种组合都有其自己的含义。其中五种被使用。
- en: '[Table 17-4](ch17s04.html#ip_address_patterns_with_special_meaning "Table 17-4. IP
    Address Patterns with Special Meanings") describes each of these special meanings
    and includes examples from Class A, B, and C. Note how an IP address in each of
    the common classes can be modified to have special meaning forms. (The first row
    shows the examples in their normal form, for reference.)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[表17-4](ch17s04.html#ip_address_patterns_with_special_meaning "表17-4. 特殊含义的IP地址模式")
    描述了这些特殊含义，并包括A、B、C类中的示例。注意，每个常见类别的IP地址如何修改以具有特殊含义形式。 (第一行显示了它们的正常形式，供参考。)'
- en: Table 17-4. IP Address Patterns with Special Meanings
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-4. 特殊含义的IP地址模式
- en: '| Network ID | Host ID | Class A Example | Class B Example | Class C Example
    | Special Meaning and Description |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 网络ID | 主机ID | A类示例 | B类示例 | C类示例 | 特殊含义和描述 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **Network ID** | **Host ID** | 77.91.215.5 | 154.3.99.6 | 227.82.157.160
    | **Normal Meaning**: Refers to a specific device. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **网络ID** | **主机ID** | 77.91.215.5 | 154.3.99.6 | 227.82.157.160 | **正常含义**:
    指的是特定的设备。|'
- en: '| **Network ID** | **All Zeros** | 77.0.0.0 | 154.3.0.0 | 227.82.157.0 | **The
    Specified Network**: This notation, with a 0 at the end of the address, refers
    to an entire network. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **网络ID** | **全零** | 77.0.0.0 | 154.3.0.0 | 227.82.157.0 | **指定的网络**: 这种表示法，地址末尾有一个0，指的是整个网络。|'
- en: '| **All Zeros** | **Host ID** | 0.91.215.5 | 0.0.99.6 | 0.0.0.160 | **Specified
    Host on This Network**: This addresses a host on the current or default network
    when the network ID is not known or when it doesn''t need to be explicitly stated.
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **全零** | **主机ID** | 0.91.215.5 | 0.0.99.6 | 0.0.0.160 | **指定网络上的主机**: 当网络ID未知或不需要明确指出时，此地址指向当前或默认网络上的主机。|'
- en: '| **All Zeros** | **All Zeros** | 0.0.0.0 | **Me**: Used by a device to refer
    to itself when it doesn''t know its own IP address. (Alternatively, "this host,"
    or "the current/default host.") The most common use is when a device attempts
    to determine its address using a host-configuration protocol like DHCP. May also
    be used to indicate that any address of a multihomed host may be used. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| **全零** | **全零** | 0.0.0.0 | **我**: 当设备不知道自己的IP地址时，用于指代自身。（或者“此主机”、“当前/默认主机”）。最常见的用法是当设备尝试使用如DHCP之类的主机配置协议确定其地址时。也可以用来表示多宿主机的任何地址都可以使用。|'
- en: '| **Network ID** | **All Ones** | 77.255.255.255 | 154.3.255.255 | 227.82.157.255
    | **All Hosts on the Specified Network**: Used for broadcasting to all hosts on
    the local network. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **网络ID** | **全一** | 77.255.255.255 | 154.3.255.255 | 227.82.157.255 | **指定网络上的所有主机**:
    用于向本地网络上的所有主机广播。|'
- en: '| **All Ones** | **All Ones** | 255.255.255.255 | **All Hosts on the Network**:
    Specifies a global broadcast to all hosts on the directly connected network. Note
    that there is no address that would imply sending to all hosts everywhere on the
    global Internet, since this would be very inefficient and costly. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **全一** | **全一** | 255.255.255.255 | **网络上的所有主机**: 指定向直接连接的网络上的所有主机进行全局广播。请注意，没有地址可以暗示向全球互联网上的所有主机发送，因为这会非常低效且成本高昂。|'
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*The missing combination from [Table 17-4](ch17s04.html#ip_address_patterns_with_special_meaning
    "Table 17-4. IP Address Patterns with Special Meanings") is that of the network
    ID being all ones and the host ID normal. Semantically, this would refer to "all
    hosts of a specific ID on all networks," which doesn''t really mean anything useful
    in practice, so it''s not used. Note also that, in theory, a special address where
    the network ID is all zeros and the host ID is all ones would have the same meaning
    as the all-ones limited broadcast address. The latter is used instead, however,
    because it is more general, not requiring knowledge of where the division is between
    the network ID and the host ID*.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*[表17-4](ch17s04.html#ip_address_patterns_with_special_meaning "表17-4。具有特殊含义的IP地址模式")中缺失的组合是网络ID全为1而主机ID正常的情况。从语义上讲，这将指代“所有网络上的特定ID的主机”，这在实践中并没有什么实际意义，所以它没有被使用。注意，从理论上讲，一个特殊地址，其中网络ID全为零而主机ID全为1，将具有与全一有限广播地址相同的含义。然而，后者被使用，因为它更通用，不需要知道网络ID和主机ID之间的划分在哪里。'
- en: 'Since the all-zeros and all-ones patterns are reserved for these special meanings,
    they cannot be used for regular IP addresses. This is why, when you looked at
    the number of hosts per network in each of the classes, you had to subtract two
    from the theoretical maximum: one for the all-zeros case and one for the all-ones
    case.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于全零和全一的模式被保留用于这些特殊含义，因此它们不能用于常规IP地址。这就是为什么，当你查看每个类别的网络中每台主机的数量时，你必须从理论上的最大值中减去两个：一个用于全零的情况，一个用于全一的情况。
- en: Similarly, the network ID cannot be all zeros either. However, this doesn't
    require specific exclusion because the entire block of addresses with 0 in the
    first octet (0.x.x.x) is one of the reserved sets of IP addresses. These reserved
    addresses, described in the next section, further restrict the use of certain
    addresses in the IP address space for regular uses.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，网络ID也不能全为零。然而，这不需要特定的排除，因为第一个八位字节中包含0的整个地址块（0.x.x.x）是保留的IP地址集合之一。这些在下一节中描述的保留地址，进一步限制了某些地址在IP地址空间中的常规使用。
- en: IP Reserved, Private, and Loopback Addresses
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP保留地址、私有地址和环回地址
- en: 'In addition to the unusable numbers with special meanings just discussed, several
    other sets of IP addresses have special uses, and are therefore not available
    for normal address assignment. These generally fall into three categories: reserved,
    private, and loopback addresses.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了刚才讨论的具有特殊含义的不可用数字外，还有几组IP地址有特殊用途，因此它们不可用于常规地址分配。这些通常分为三类：保留地址、私有地址和环回地址。
- en: Reserved Addresses
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留地址
- en: Several blocks of addresses were designated as reserved with no specific indication
    given as to what they were reserved for. Perhaps they were set aside for future
    experimentation or for internal use in managing the Internet. (In general, it's
    a good idea to set aside some portion of any limited resource for unanticipated
    needs.)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 几个地址块被指定为保留，但没有给出它们被保留的具体用途。也许它们是为未来的实验或为在互联网内部使用而预留的。（一般来说，为未预见的需要预留任何有限资源的一部分是个好主意。）
- en: A couple of these blocks appear in each of the three main classes (A, B, and
    C), at the beginning and end of each class. (All of Class D and E are also reserved,
    since they aren't used for regular addressing.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块在每个主要类别（A、B和C）的开始和结束处都出现。 （由于D类和E类不用于常规寻址，所以它们也是保留的。）
- en: Private, Unregistered, Nonroutable Addresses
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有、未注册、不可路由地址
- en: You'll recall that in the IP address overview in [Chapter 16](ch16.html "Chapter 16. IPV4
    ADDRESSING CONCEPTS AND ISSUES"), I contrasted private and public IP addresses.
    Every IP address on an IP network must be unique. In the case of a public IP network,
    addresses are allocated by a central authority to ensure that there is no overlap.
    In contrast, on a private network, you can use whatever addresses you want.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，在[第16章](ch16.html "第16章。IPV4地址概念和问题概述")的IP地址概述中，我对比了私有和公共IP地址。IP网络上的每个IP地址都必须是唯一的。在公共IP网络的情况下，地址由中央机构分配，以确保没有重叠。相比之下，在私有网络中，你可以使用你想要的任何地址。
- en: Then why not just pick any random block of Class A, B, or C addresses for your
    private network and use that? You could, and some people did. For example, if
    you weren't connected to the Internet you could use, say, the Class A network
    18.x.x.x that is reserved on the Internet to the Massachusetts Institute of Technology
    (MIT). Since you aren't connected to MIT, you would think that wouldn't matter.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不随便选择任何A类、B类或C类地址块来为你的私有网络使用呢？你可以这样做，有些人确实这样做了。例如，如果你没有连接到互联网，你可以使用互联网上预留给麻省理工学院（MIT）的A类网络18.x.x.x。由于你没有连接到MIT，你可能认为这不会有什么影响。
- en: However, as the Internet grew, those disconnected private networks needed to
    connect to the public Internet after all, and then they had a conflict. If they
    used the 18.x.x.x addresses, they would have to renumber all their devices to
    avoid getting a big bunch of computer geeks really angry. (There were, in fact,
    cases where companies that had used IP address space belonging to other companies
    accidentally connected those machines to the Internet, causing a small amount
    of ruckus in the process.)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着互联网的发展，那些独立的私有网络最终需要连接到公共互联网，然后它们就产生了冲突。如果它们使用18.x.x.x地址，它们就必须重新分配所有设备的地址，以避免引起一大群计算机极客的愤怒。（实际上，有些公司不小心将属于其他公司的IP地址空间中的机器连接到互联网上，在这个过程中造成了一些混乱。）
- en: RFC 1918 (superseding RFC 1597) provided the solution. It defines a set of unroutable,
    special address blocks just for private addresses. These addresses simply don't
    exist on the public Internet. For this reason, they are not registered like other
    public addresses; they are sometimes called *unregistered*. Anyone can use them,
    but they cannot connect to the Internet because routers are not programmed to
    forward traffic with these address ranges outside of local organizations. RFC
    1918 was published to encourage the use of these private blocks in order to cut
    down on the number of devices on the public Internet that didn't really need to
    be publicly accessible. This was in response to the need to conserve the public
    address space.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 1918（取代RFC 1597）提供了解决方案。它定义了一组专为私有地址而设的不可路由的特殊地址块。这些地址在公共互联网上根本不存在。因此，它们不像其他公共地址那样注册；有时被称为*未注册的*。任何人都可以使用它们，但它们不能连接到互联网，因为路由器没有编程来转发这些地址范围内的流量到本地组织之外。RFC
    1918的发布是为了鼓励使用这些私有块，以减少公共互联网上不需要公开访问的设备数量。这是对节约公共地址空间需求的回应。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In order to connect a network using private addressing to the public Internet,
    it is necessary to employ additional hardware and software. A gateway machine
    can be used as an interface between the public and private networks. Technologies
    such as Network Address Translation (NAT; see [Chapter 28](ch28.html "Chapter 28. IP
    NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL")) are often used in conjunction with
    private IP addresses to allow these hosts to communicate on the public IP network*.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了将使用私有地址的网络连接到公共互联网，需要使用额外的硬件和软件。可以使用网关机器作为公共网络和私有网络之间的接口。网络地址转换（NAT；见第28章[Chapter
    28. IP网络地址转换（NAT）协议](ch28.html "Chapter 28. IP网络地址转换（NAT）协议")）等技术通常与私有IP地址一起使用，以允许这些主机在公共IP网络上进行通信*。'
- en: Tip
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Private address blocks were created to allow private IP Internets
    to be created using addresses that were guaranteed not to conflict with public
    IP addresses. They are commonly used in internetworks that aren''t connected to
    the global Internet; devices using them can also access the global Internet by
    using NAT.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 私有地址块是为了允许使用不会与公共IP地址冲突的地址来创建私有IP互联网而创建的。它们通常用于未连接到全球互联网的互联网中；使用它们的设备也可以通过使用NAT来访问全球互联网。'
- en: Loopback Addresses
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回环地址
- en: Normally, when a TCP/IP application wants to send information, that information
    travels down the protocol layers to IP, where it is encapsulated in an IP datagram.
    That datagram then passes down to the data link layer of the device's physical
    network for transmission to the next hop, on the way to the IP destination.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个TCP/IP应用程序想要发送信息时，该信息会沿着协议层向下传输到IP层，在那里它被封装在一个IP数据报中。然后该数据报会传递到设备的物理网络的数据链路层，以便在前往IP目标的过程中传输到下一个跳点。
- en: However, one special range of addresses, 127.0.0.0 to 127.255.255.255, is set
    aside for *loopback* functionality. IP datagrams sent by a host to a 127.x.x.x
    loopback address are not passed down to the data link layer for transmission;
    instead, they loop back to the source device at the IP level. In essence, this
    short-circuits the normal protocol stack; data is sent by a device's layer 3 IP
    implementation and then immediately received by it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一组特殊的地址范围，从127.0.0.0到127.255.255.255，被预留用于*环回*功能。主机发送到127.x.x.x环回地址的IP数据报不会传递到数据链路层进行传输；相反，它们在IP层回环到源设备。本质上，这绕过了正常的协议栈；数据由设备的第3层IP实现发送，然后立即被它接收。
- en: This loopback range is used for testing the TCP/IP protocol implementation on
    a host. Since the lower layers are short-circuited, sending to a loopback address
    allows you to isolate and test the higher layers (IP and above) without interference
    from the lower layers. 127.0.0.1 is the address most commonly used for testing
    purposes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个环回范围用于在主机上测试TCP/IP协议的实现。由于底层被短路，向环回地址发送允许你隔离并测试高层（IP及以上）而不会受到底层干扰。127.0.0.1是最常用的测试地址。
- en: Tip
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Portions of the IP address space are set aside for reserved,
    private, and loopback addresses.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP地址空间的部分被预留用于预留、私有和环回地址。'
- en: Reserved, Private, and Loopback Addressing Blocks
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预留、私有和环回地址块
- en: '[Table 17-5](ch17s05.html#reserved_private_and_loopback_ip_address "Table 17-5. Reserved,
    Private, and Loopback IP Addresses") shows all of the special blocks set aside
    from the normal IP address space in numerical order, with a brief explanation
    of how each is used. It lists both the classful and the classless notation representing
    each of these blocks because the Internet now uses classless addressing, and because
    some of the private blocks don''t correspond to single Class A, B, or C networks.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[表17-5](ch17s05.html#reserved_private_and_loopback_ip_address "表17-5. 预留、私有和环回IP地址")显示了从正常的IP地址空间中预留的所有特殊块，按数字顺序排列，并简要说明了每个块的使用方法。它列出了表示每个块的类地址和无类地址表示，因为现在互联网使用无类地址，并且因为一些私有块不对应于单个A、B或C类网络。'
- en: Note especially the private address block from 192.168.0.0 to 192.168.255.255\.
    This is the size of a Class B network, but it isn't Class B in the classful scheme,
    because the first octet of 192 puts it in the Class C part of the address space.
    It is actually 256 contiguous Class C networks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意从192.168.0.0到192.168.255.255的私有地址块。这是一个B类网络的大小，但在类地址方案中不是B类，因为192的第一个八位字节将其放在地址空间的C类部分。它实际上是256个连续的C类网络。
- en: You may also notice the special Class B (/16) block 169.254.x.x. This is reserved
    for *Automatic Private IP Addressing (APIPA)*, discussed in [Chapter 64](ch64.html
    "Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES, AND IPV6 SUPPORT").
    Systems that are configured to use this feature will automatically assign systems
    addresses from this block to enable them to communicate even if no server can
    be found for proper IP address assignment using the Dynamic Host Control Protocol
    (DHCP).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能注意到特殊的B类(/16)块169.254.x.x。这是为*自动私有IP地址分配(APIPA)*预留的，在[第64章](ch64.html "第64章。DHCP客户端/服务器实现、特性和IPv6支持")中讨论。配置为使用此功能的系统将自动从该块分配系统地址，以便它们即使在找不到服务器进行适当的IP地址分配（使用动态主机控制协议DHCP）的情况下也能进行通信。
- en: Table 17-5. Reserved, Private, and Loopback IP Addresses
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-5. 预留、私有和环回IP地址
- en: '| Range Start Address | Range End Address | Classful Address Equivalent | Classless
    Address Equivalent | Description |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 范围起始地址 | 范围结束地址 | 类地址等效 | 无类地址等效 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0.0.0.0** | **0.255.255.255** | Class A network 0.x.x.x | 0/8 | Reserved
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **0.0.0.0** | **0.255.255.255** | A类网络0.x.x.x | 0/8 | 预留 |'
- en: '| **10.0.0.0** | **10.255.255.255** | Class A network 10.x.x.x | 10/8 | Class
    A private address block |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **10.0.0.0** | **10.255.255.255** | A类网络10.x.x.x | 10/8 | A类私有地址块 |'
- en: '| **127.0.0.0** | **127.255.255.255** | Class A network 127.x.x.x | 127/8 |
    Loopback address block |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **127.0.0.0** | **127.255.255.255** | A类网络127.x.x.x | 127/8 | 环回地址块 |'
- en: '| **128.0.0.0** | **128.0.255.255** | Class B network 128.0.x.x | 128.0/16
    | Reserved |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **128.0.0.0** | **128.0.255.255** | B类网络128.0.x.x | 128.0/16 | 预留 |'
- en: '| **169.254.0.0** | **169.254.255.255** | Class B network 169.254.x.x | 169.254/16
    | Class B private address block reserved for automatic private address allocation
    (see [Chapter 64](ch64.html "Chapter 64. DHCP CLIENT/SERVER IMPLEMENTATION, FEATURES,
    AND IPV6 SUPPORT") for details) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| **169.254.0.0** | **169.254.255.255** | Class B网络169.254.x.x | 169.254/16
    | 保留，用于自动私有地址分配（有关详细信息，请参阅[第64章](ch64.html "第64章. DHCP客户端/服务器实现、功能和IPv6支持")） |'
- en: '| **172.16.0.0** | **172.31.255.255** | 16 contiguous Class B networks from
    172.16.x.x through 172.31.x.x | 172.16/12 | Class B private address blocks |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| **172.16.0.0** | **172.31.255.255** | 从172.16.x.x到172.31.x.x的16个连续的Class
    B网络 | 172.16/12 | Class B私有地址块 |'
- en: '| **191.255.0.0** | **191.255.255.255** | Class B network 191.255.x.x | 191.255/16
    | Reserved |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| **191.255.0.0** | **191.255.255.255** | Class B网络191.255.x.x | 191.255/16
    | 保留 |'
- en: '| **192.0.0.0** | **192.0.0.255** | Class C network 192.0.0.x | 192.0.0/24
    | Reserved |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **192.0.0.0** | **192.0.0.255** | Class C网络192.0.0.x | 192.0.0/24 | 保留 |'
- en: '| **192.168.0.0** | **192.168.255.255** | 256 contiguous Class C networks from
    192.168.0.x through 192.168.255.x | 192.168/16 | Class C private address blocks
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **192.168.0.0** | **192.168.255.255** | 从192.168.0.x到192.168.255.x的256个连续的Class
    C网络 | 192.168/16 | Class C私有地址块 |'
- en: '| **223.255.255.0** | **223.255.255.255** | Class C network 223.255.255.x |
    223.255.255/24 | Reserved |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **223.255.255.0** | **223.255.255.255** | Class C网络223.255.255.x | 223.255.255/24
    | 保留 |'
- en: IP Multicast Addressing
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP多播寻址
- en: The vast majority of traffic on IP internetworks is *unicast*, which is one
    source device sending to one destination device. IP also supports *multicasting*,
    which is a source device sending to a group of devices. Multicasting is not used
    a great deal on the present-day Internet, mainly due to a lack of widespread hardware
    support, though it is useful in certain circumstances, especially as a more efficient
    alternative to broadcasting.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: IP互联网上的绝大多数流量是*单播*，即一个源设备向一个目的设备发送。IP还支持*多播*，即源设备向一组设备发送。尽管在当今的互联网上多播使用不多，主要是因为缺乏广泛的硬件支持，但在某些情况下它很有用，尤其是在作为广播的更有效替代方案时。
- en: The classful IP addressing scheme sets aside one-sixteenth of the address space
    for multicast addresses as Class D. Multicast addresses are identified by the
    pattern 1110 in the first four bits, which corresponds to a first octet of 224
    to 239\. Thus, the full range of multicast addresses is from 224.0.0.0 to 239.255.255.255.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 类别IP寻址方案将地址空间的六分之一留作多播地址，作为D类。多播地址通过前四位中的模式1110来识别，这对应于第一个八位字节为224到239。因此，多播地址的全范围是从224.0.0.0到239.255.255.255。
- en: Since multicast addresses represent a group of IP devices (sometimes called
    a *host group*), they can be used only as the destination of a datagram, never
    the source.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多播地址代表一组IP设备（有时称为*主机组*），它们只能作为数据报的目的地使用，而不能作为源地址。
- en: Multicast Address Types and Ranges
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播地址类型和范围
- en: The other 28 bits in the IP address define the *multicast group address*. The
    size of the Class D multicast address space is therefore 2^(28), or 268,435,456
    multicast groups. No substructure defines the use of these 28 bits, and there
    is no specific concept of a network ID and host ID as in Class A, B, and C. However,
    certain portions of the address space are set aside for specific uses. [Table 17-6](ch17s06.html#ip_multicast_address_ranges_and_uses
    "Table 17-6. IP Multicast Address Ranges and Uses") and [Figure 17-4](ch17s06.html#ip_multicast_address_ranges_and_uses_all
    "Figure 17-4. IP Multicast address ranges and uses All multicast addresses begin
    with 1110\. The well-known group has zeros for the first 20 bits of the multicast
    group address, with 8 bits available to define 255 special multicast addresses.
    Multicast addresses starting with 1110 1111 are locally scoped; all other addresses
    are globally scoped (this includes addresses starting with 1110 0000 other than
    the 255 well-known addresses).") show the general allocation of the Class D address
    space.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址中的其他28位定义了*多播组地址*。因此，D类多播地址空间的大小是2^(28)，即268,435,456个多播组。这28位没有子结构定义其用途，也没有像A、B和C类中那样的网络ID和主机ID的具体概念。然而，地址空间的一部分被留作特定用途。[表17-6](ch17s06.html#ip_multicast_address_ranges_and_uses
    "表17-6. IP多播地址范围和用途")和[图17-4](ch17s06.html#ip_multicast_address_ranges_and_uses_all
    "图17-4. IP多播地址范围和用途 所有多播地址以1110开头。知名组的多播组地址的前20位为零，有8位可用于定义255个特殊的多播地址。以1110 1111开头的是本地作用域；所有其他地址都是全局作用域（这包括以1110
    0000开头但不是255个知名地址的地址）")显示了D类地址空间的一般分配。
- en: Table 17-6. IP Multicast Address Ranges and Uses
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-6。IP多播地址范围和用途
- en: '| Range Start Address | Range End Address | Description |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 范围起始地址 | 范围结束地址 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **224.0.0.0** | **224.0.0.255** | Reserved for special well-known multicast
    addresses |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.0** | **224.0.0.255** | 保留用于特殊知名多播地址 |'
- en: '| **224.0.1.0** | **238.255.255.255** | Globally scoped (Internetwide) multicast
    addresses. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.1.0** | **238.255.255.255** | 全局范围（互联网范围）多播地址。 |'
- en: '| **239.0.0.0** | **239.255.255.255** | Administratively scoped (local) multicast
    addresses |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **239.0.0.0** | **239.255.255.255** | 管理范围（本地）多播地址 |'
- en: Note
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*As with the other IP address classes, the entire 32 bits of the address is
    always used. It is only the least significant 28 bits that are interesting, because
    the upper four bits never change*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '*与其他IP地址类一样，地址的整个32位始终被使用。只有最低的28位是有趣的，因为最高4位永远不会改变*。'
- en: '![IP Multicast address ranges and uses All multicast addresses begin with 1110\.
    The well-known group has zeros for the first 20 bits of the multicast group address,
    with 8 bits available to define 255 special multicast addresses. Multicast addresses
    starting with 1110 1111 are locally scoped; all other addresses are globally scoped
    (this includes addresses starting with 1110 0000 other than the 255 well-known
    addresses).](httpatomoreillycomsourcenostarchimages287807.png.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![IP多播地址范围和用途 所有多播地址以1110开头。知名组的多播组地址的前20位为零，有8位可用于定义255个特殊的多播地址。以1110 1111开头的多播地址是本地范围的；所有其他地址都是全局范围的（这包括以1110
    0000开头但不是255个知名地址的地址）](httpatomoreillycomsourcenostarchimages287807.png.jpg)'
- en: Figure 17-4. IP Multicast address ranges and uses All multicast addresses begin
    with 1110\. The well-known group has zeros for the first 20 bits of the multicast
    group address, with 8 bits available to define 255 special multicast addresses.
    Multicast addresses starting with 1110 1111 are locally scoped; all other addresses
    are globally scoped (this includes addresses starting with 1110 0000 other than
    the 255 well-known addresses).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-4。IP多播地址范围和用途 所有多播地址以1110开头。知名组的多播组地址的前20位为零，有8位可用于定义255个特殊的多播地址。以1110 1111开头的多播地址是本地范围的；所有其他地址都是全局范围的（这包括以1110
    0000开头但不是255个知名地址的地址）。
- en: Tip
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *The concept of multicast address scope was more completely
    defined in IPv6, and I discuss it in more detail in the in the discussion of IPv6
    multicast addresses in [Chapter 25](ch25.html "Chapter 25. IPV6 ADDRESSING")*.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *多播地址范围的概念在IPv6中得到了更完整的定义，我在[第25章](ch25.html "第25章。IPv6寻址")中对其进行了更详细的讨论*。'
- en: The bulk of the address space is in the middle multicast range. These are normal
    multicast addresses, like the Class A, B, and C unicast addresses, and they can
    be assigned to various groups.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 地址空间的大部分在中段多播范围内。这些是正常的多播地址，就像A类、B类和C类单播地址一样，它们可以被分配给各种组。
- en: The last address range is for *administratively scoped* multicast groups. This
    is a fancy term for multicast groups used within a private organization. This
    block, representing one-sixteenth of the total multicast address space, is comparable
    to the private addresses you saw earlier in this chapter. It is further subdivided
    into site-local multicast addresses, organization-local addresses, and so forth.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的地址范围是用于*管理范围*的多播组。这是一个用于私人组织内部的多播组的术语。这个块代表了总多播地址空间的六分之一，与本章前面看到的私有地址相当。它进一步细分为站点本地多播地址、组织本地地址等。
- en: Well-Known Multicast Addresses
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 知名多播地址
- en: The first block of 256 addresses is used to define special, well-known multicast
    address blocks ([Table 17-7](ch17s06.html#well-known_ip_multicast_addresses "Table 17-7. Well-Known
    IP Multicast Addresses") has a selective listing). These do not represent arbitrary
    groups of devices and cannot be assigned in that manner. Instead, they have a
    special meaning that allows a source to send a message to a predefined group.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 第一块256个地址用于定义特殊、知名的多播地址块（[表17-7](ch17s06.html#well-known_ip_multicast_addresses
    "表17-7。知名IP多播地址")有选择性列表）。这些地址不代表任意设备组，也不能以这种方式分配。相反，它们具有特殊含义，允许源向预定义的组发送消息。
- en: Table 17-7. Well-Known IP Multicast Addresses
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-7。知名IP多播地址
- en: '| Range Start Address | Description |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 范围起始地址 | 描述 |'
- en: '| --- | --- |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **224.0.0.0** | Reserved; not used |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.0** | 保留；未使用 |'
- en: '| **224.0.0.1** | All devices on the subnet |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.1** | 子网上的所有设备 |'
- en: '| **224.0.0.2** | All routers on the subnet |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.2** | 子网上的所有路由器 |'
- en: '| **224.0.0.3** | Reserved |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.3** | 保留 |'
- en: '| **224.0.0.4** | All routers using DVMRP |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.4** | 使用DVMRP的所有路由器 |'
- en: '| **224.0.0.5** | All routers using OSPF |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.5** | 使用OSPF的所有路由器 |'
- en: '| **224.0.0.6** | Designated routers using OSPF |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.6** | 使用OSPF指定的路由器 |'
- en: '| **224.0.0.9** | Designated routers using RIP-2 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.9** | 使用RIP-2指定的路由器 |'
- en: '| **224.0.0.11** | Mobile agents (for Mobile IP) |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.11** | 移动代理（用于移动IP） |'
- en: '| **224.0.0.12** | DHCP server/relay agent |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **224.0.0.12** | DHCP服务器/中继代理 |'
- en: Delivery of IP multicast traffic is more complex than unicast traffic due to
    the existence of multiple recipients. Instead of the normal resolution method
    through the Address Resolution Protocol (ARP) used for unicast datagrams, the
    IP multicast group and a hardware multicast group are mapped.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多个接收者，IP多播流量的传输比单播流量更复杂。不是通过用于单播数据报的地址解析协议（ARP）的正常解析方法，而是将IP多播组和硬件多播组进行映射。
- en: Problems with Classful IP Addressing
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类IP寻址的问题
- en: The classful addressing system was the first major attempt to define a method
    for universal addressing of a large IP internetwork. There was a reasonable rationale
    for the system, as I mentioned in the overview of the classful scheme, and given
    that it was developed decades ago for a network that was limited in size, it did
    the job remarkably well for a long time.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 分类寻址系统是第一个尝试定义大型IP互联网通用寻址方法的重大尝试。正如我在分类方案概述中提到的，该系统有一个合理的理论基础，并且鉴于它是几十年前为规模有限的网络开发的，它在长时间内出色地完成了任务。
- en: No one ever expected the Internet to mushroom to anything close to its current
    size. As the Internet grew, the classful IP addressing mechanism showed some problems.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人曾预料到互联网会发展到如今这样的规模。随着互联网的发展，分类的IP寻址机制出现了一些问题。
- en: 'The three main problems with classful addressing are as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 分类寻址的三个主要问题如下：
- en: '**Lack of Internal Address Flexibility** Big organizations are assigned large,
    monolithic blocks of addresses that aren''t a good match for the structure of
    their underlying internal networks.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部地址灵活性不足** 大型组织被分配了大型、单一的地址块，这与它们底层内部网络的架构并不匹配。'
- en: '**Inefficient Use of Address Space** The existence of only three block sizes
    (Classes A, B, and C) leads to a waste of limited IP address space.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址空间使用效率低下** 只存在三种块大小（A类、B类和C类）会导致有限的IP地址空间浪费。'
- en: '**Proliferation of Router Table Entries** As the Internet grows, more and more
    entries are required for routers to route IP datagrams. This causes performance
    problems for routers. Attempting to reduce inefficient address space allocation
    leads to even more router table entries.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器表条目激增** 随着互联网的增长，路由器需要更多的条目来路由IP数据报。这导致路由器性能问题。试图减少低效的地址空间分配会导致更多的路由器表条目。'
- en: The first issue results primarily from the fact that in the classful system,
    big companies are assigned a rather large (Class B) or truly enormous (Class A)
    block of addresses. They are considered by the Internet routers to be a single
    network, with one network ID. Now imagine that you are running a medium-to-large-sized
    company with 5,000 computers, and you are assigned a Class B address for your
    network. Do you really have 5,000 computers all hooked into a single network?
    I sure as heck hope you don't! Yet you would be forced to try to fit all of these
    into a single IP network in the original classful method. There was no way to
    create an internal hierarchy of addresses.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题主要源于分类系统中，大型公司被分配了相当大的（B类）或真正巨大的（A类）地址块。它们被互联网路由器视为一个单一的网络，具有一个网络ID。现在想象一下，你正在经营一个中等至大型公司，拥有5,000台计算机，并且你的网络被分配了一个B类地址。你真的有5,000台计算机都连接到一个单一的网络中吗？我肯定希望你不是！然而，你将被迫在原始的分类方法中将所有这些设备都放入一个IP网络中。无法创建地址的内部层次结构。
- en: The second and third issues both stem from the fact that the granularity in
    the classful system is simply too low to be practical in a large internetwork;
    there are simply too few choices in the sizes of available networks. Three sizes
    seem fine in principle, but the gaps between the sizes are enormous, and the sizes
    don't match up well with the distribution of organizations in the real world.
    Consider the difference in size between Class C and Class B networks—a jump from
    254 hosts all the way up to over 65,000! There are many, many companies that need
    more than 254 IP address but a lot fewer than 65,000\. And what about Class A?
    How many companies need 16 *million* IP addresses, even the truly large ones?
    Probably none, if you think about it, yet that's half the IP address space right
    there.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个问题都源于这样一个事实，即类地址系统中的粒度太低，在大规模互联网中不实用；可用的网络大小选择太少。原则上，三种大小看起来是合适的，但大小之间的差距巨大，而且大小与现实世界中组织的分布不太匹配。考虑C类和B类网络之间的大小差异——从254个主机直接跳到超过65,000个！有许许多多的公司需要的IP地址数量超过254个，但远少于65,000个。那么A类呢？有多少公司需要1600万个IP地址，即使是真正的大型公司？如果你这么想，可能没有，但那占了IP地址空间的一半。
- en: What class of network should the company with 5,000 computers use? As [Figure 17-5](ch17s07.html#the_main_problem_with_classful_addressin
    "Figure 17-5. The main problem with classful addressing In this scale diagram,
    each square represents 50 available addresses. Since a Class C address has only
    254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000
    hosts is caught in the middle. It can only choose to either waste 90 percent of
    a Class B address or use 20 different Class C networks.") shows, the classful
    scheme offers no good match for this company's needs. If it were assigned a Class
    B, over 90 percent of the IP addresses would be wasted.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有5000台计算机的公司应该使用哪种网络类别？如图17-5所示，类地址方案无法满足这家公司的需求。如果它被分配了一个B类地址，那么超过90%的IP地址将会被浪费。
- en: 'The alternative to wasting all these IP addresses would be to give this fictitious
    company a bunch of Class C addresses instead of one Class B; but they would need
    20 of them. While this would use the address space more efficiently, it leads
    to the third issue: Every router on the Internet then has to replace the single
    Class B router table entry with 20 Class C router entries. Multiply this by a
    few thousand medium-sized companies, and you can see that this method would add
    dramatically to the size of router tables. The larger these tables, the more time
    it takes for routers to make routing decisions.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 浪费所有这些IP地址的替代方案是给这家虚构的公司分配一大堆C类地址而不是一个B类地址；但它们需要20个这样的地址。虽然这样做会使地址空间的使用效率更高，但它导致了第三个问题：互联网上的每个路由器都必须将单个B类路由表条目替换为20个C类路由表条目。将这个数字乘以几千家中等规模的公司，你就会发现这种方法会极大地增加路由表的大小。这些表越大，路由器做出路由决策所需的时间就越长。
- en: '![The main problem with classful addressing In this scale diagram, each square
    represents 50 available addresses. Since a Class C address has only 254 addresses,
    and a Class B contains 65,534 addresses, an organization with 5,000 hosts is caught
    in the middle. It can only choose to either waste 90 percent of a Class B address
    or use 20 different Class C networks.](httpatomoreillycomsourcenostarchimages287809.png.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![类地址的主要问题 在这个比例图中，每个方块代表50个可用的地址。由于C类地址只有254个地址，而B类包含65,534个地址，拥有5000个主机的组织处于中间位置。它只能选择浪费B类地址的90%或者使用20个不同的C类网络。](http://atomoreilly.com/source/nostarch/images/287809.png.jpg)'
- en: Figure 17-5. The main problem with classful addressing In this scale diagram,
    each square represents 50 available addresses. Since a Class C address has only
    254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000
    hosts is caught in the middle. It can only choose to either waste 90 percent of
    a Class B address or use 20 different Class C networks.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-5. 类地址的主要问题 在这个比例图中，每个方块代表50个可用的地址。由于C类地址只有254个地址，而B类包含65,534个地址，拥有5000个主机的组织处于中间位置。它只能选择浪费B类地址的90%或者使用20个不同的C类网络。
- en: The problems with classful addressing have been solved by three enhancements,
    as you'll see in later chapters. The first, which primarily addresses the first
    issue, was the development of subnetting. The second was the move to classless
    addressing and routing, which replaces the classful system with a new method with
    higher granularity. This tackles the second and third issues by letting addresses
    be assigned based on real organizational needs, without requiring numerous routing
    table entries for each organization. The third improvement is the new IP version
    6 (IPv6), which finally does away with the cramped 32-bit IP address space in
    favor of a gargantuan 128-bit one.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 类寻址的问题通过三个增强得到了解决，您将在后面的章节中看到。第一个，主要解决第一个问题，是子网划分的发展。第二个是转向无类寻址和路由，用具有更高粒度的新方法替换了类寻址系统。这通过根据实际组织需求分配地址来解决第二个和第三个问题，而不需要为每个组织创建大量的路由表条目。第三个改进是新的IP版本6（IPv6），它最终摒弃了拥挤的32位IP地址空间，转而采用巨大的128位地址空间。
- en: Other support technologies, such as NAT, have helped to extend the life of IPv4
    by allowing multiple devices to share public addresses. This alone has added years
    to the life of the IPv4 addressing system.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持技术，如NAT，通过允许多个设备共享公共地址，帮助延长了IPv4的生命周期。这本身就让IPv4寻址系统的寿命增加了数年。
- en: Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章. IP子网寻址（子网划分）概念
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: In the previous chapter, we looked at the original classful IP addressing scheme,
    which conceptually divides a large internetwork into a simple two-level hierarchy
    that includes many *networks* of different sizes, each of which contains a number
    of *hosts*. The system works well for smaller organizations that may connect all
    their machines in a single network. However, it lacks flexibility for large organizations
    that often have many subnetworks, or *subnets*. To better meet the administrative
    and technical requirements of larger organizations, the classful IP addressing
    system was enhanced through a technique known as *subnet addressing*, or more
    simply, *subnetting*.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了原始的类IP寻址方案，从概念上讲，它将大型互联网划分为一个简单的两级层次结构，包括许多不同大小的*网络*，每个网络包含一定数量的*主机*。该系统对于可能将所有机器连接到单个网络的小型组织来说效果很好。然而，对于通常有许多子网络或*子网*的大型组织来说，它缺乏灵活性。为了更好地满足大型组织的行政和技术需求，通过称为*子网寻址*或更简单的*子网划分*的技术增强了类IP寻址系统。
- en: In this chapter, I describe the concepts and general techniques associated with
    IP subnet addressing. I begin with an overview of subnetting, including a discussion
    of the motivation for the system and its advantages. I discuss how the traditional
    two-level method for dividing IP addresses becomes three-level for subnetting.
    I talk about subnet masks and how they are used in calculations for addressing
    and routing. I discuss the default subnet masks used to represent the classful
    Class A, B, and C networks in a subnetting environment and then how custom subnet
    masks are used for these classes. I then discuss subnet identifiers and general
    concepts behind determining subnet and host addresses in a subnet environment.
    I provide summary tables for subnetting Class A, B, and C networks. I conclude
    with a brief discussion of *Variable Length Subnet Masking (VLSM)*, an enhancement
    of conventional subnetting that improves its flexibility further.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了与IP子网寻址相关的概念和一般技术。我首先概述了子网划分，包括对该系统动机及其优点的讨论。我讨论了传统的两级IP地址划分方法如何变为三级子网划分。我谈论了子网掩码及其在寻址和路由计算中的应用。我讨论了在子网环境中用于表示类A、B和C网络的默认子网掩码，然后讨论了如何为这些类别使用自定义子网掩码。然后我讨论了子网标识符以及在子网环境中确定子网和主机地址的一般概念。我提供了子网划分A类、B类和C类网络的总结表格。我最后简要讨论了*可变长度子网掩码（VLSM）*，这是对传统子网划分的增强，进一步提高了其灵活性。
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I provide a great deal of coverage of subnetting, because understanding it
    is an important part of learning about how IP addresses work, and hence, how TCP/IP
    functions. However, the technique is today considered mostly* historical *because
    it is based on classful addressing. The concept of a subnet and subnet mask has
    certainly not disappeared, but the idea of being assigned a Class A, B, or C Internet
    address block and then explicitly subnetting it is no longer relevant*.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*我详细介绍了子网划分，因为理解它是了解IP地址如何工作以及TCP/IP如何工作的重要部分。然而，这项技术今天主要被认为是历史的，因为它基于类地址。子网和子网掩码的概念当然没有消失，但被分配一个A类、B类或C类互联网地址块然后明确划分它的想法已经不再相关了*。'
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *This is the first of two chapters dedicated to IP
    address subnetting. [Chapter 19](ch19.html "Chapter 19. IP SUBNETTING PRACTICAL
    SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE") describes the step-by-step process
    for subnetting using examples. If you find that after reading this concepts section
    that you don''t quite understand subnetting, try reading the example-based section,
    and you may find that it helps make it all click. On the other hand, if you are
    already somewhat familiar with subnetting, you may find that you can skip this
    concepts section and just go through the step-by-step examples. You will find
    much more in that chapter in the way of gory details of subnet mask, subnet address,
    and host address calculations. Putting the practical details there allows this
    section to concentrate on concepts without getting too bogged down in numbers*.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *这是两章中关于IP地址子网划分的第一章。[第19章](ch19.html "第19章. IP子网划分 实践子网设计和地址确定示例")描述了使用示例的子网划分的逐步过程。如果你在阅读了这一概念部分后仍然不太理解子网划分，可以尝试阅读基于示例的部分，可能会发现这有助于使一切变得清晰。另一方面，如果你已经对子网划分有些了解，你可能发现可以跳过这一概念部分，直接进入逐步示例。你将在那一章中找到关于子网掩码、子网地址和主机地址计算的更多详细信息。将实际细节放在那里，使得这一部分可以专注于概念，而不至于过于陷入数字*。'
- en: Tip
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *Understanding subnetting requires familiarity with
    binary numbers and how they are manipulated. This includes the concept of using
    boolean operators such as* AND *to "mask" binary digits. If reading that last
    sentence made you go "huh?" I strongly recommend reviewing the background section
    on computing mathematics ([Chapter 4](ch04.html "Chapter 4. A REVIEW OF DATA REPRESENTATION
    AND THE MATHEMATICS OF COMPUTING")) before you proceed*.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *理解子网划分需要熟悉二进制数及其操作方式。这包括使用布尔运算符，如* AND *来“屏蔽”二进制位。如果你读到最后一句话感到困惑，我强烈建议你在继续之前先复习一下计算数学的背景部分（[第4章](ch04.html
    "第4章. 数据表示和计算数学的复习"））*。'
- en: IP Subnet Addressing Overview, Motivation, and Advantages
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网寻址概述、动机和优势
- en: 'As I discussed in the previous chapter, IP addressing was originally designed
    around the assumption of a strict two-level hierarchy for internetworks: the first
    level was the network, and the second level the host. Each organization was usually
    represented by a single network identifier (network ID) that indicated a Class
    A, B, or C block dedicated to them. Within that network, the organization needed
    to put all of the devices it wanted to connect to the public IP network.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在上一章所述，IP地址最初是在假设互联网具有严格的两级层次结构的基础上设计的：第一级是网络，第二级是主机。每个组织通常用一个单一的网际标识符（网络ID）来表示，这个标识符指示一个专门为他们分配的A类、B类或C类块。在该网络内，组织需要放置所有希望连接到公共IP网络的设备。
- en: It did not take long after this scheme was developed for serious inadequacies
    in it to be noticed, especially by larger organizations. In order to address this
    problem, RFC 950 [1985] defined a new addressing procedure called *subnet addressing*
    or *subnetting*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方案开发出来不久后，人们就发现了它的严重不足，尤其是大型组织注意到了这一点。为了解决这个问题，RFC 950 [1985] 定义了一种新的寻址过程，称为*子网寻址*或*子网划分*。
- en: 'Subnet addressing adds an additional hierarchical level to the way IP addresses
    are interpreted: Instead of having just hosts, the network has *subnets* and hosts.
    Each subnet is a subnetwork, and functions much the way a full network does in
    conventional classful addressing. A three-level hierarchy is thus created: networks,
    which contain subnets, each of which then has a number of hosts. Thus, an organization
    can organize hosts into subnets that reflect the way internal networks are structured.
    In essence, subnet addressing allows each organization to have its own internetwork
    within the Internet. This change brought numerous advantages over the old system,
    such as the following:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 子网寻址为IP地址的解析方式增加了一个额外的层次：你不再只有主机，网络有*子网*和主机。每个子网是一个子网络，其功能与常规的类地址中完整网络的功能相似。因此，创建了一个三级层次结构：网络，其中包含子网，每个子网又包含一定数量的主机。因此，组织可以将主机组织到子网中，以反映内部网络的架构。本质上，子网寻址允许每个组织在互联网内部拥有自己的互连网络。这种变化与旧系统相比带来了许多优势，例如以下所述：
- en: '**Better Match to Physical Network Structure** Hosts can be grouped into subnets
    that reflect the way they are actually structured in the organization''s physical
    network.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好地匹配物理网络结构** 主机可以被分组到子网中，这些子网反映了它们在组织物理网络中的实际结构。'
- en: '**Flexibility** The number of subnets and number of hosts per subnet can be
    customized for each organization. Each can decide on its own subnet structure
    and change it as required.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**灵活性** 每个组织可以自定义子网的数量和每个子网的主机数量。每个组织都可以根据自己的需要决定子网结构，并根据需要更改它。'
- en: '**Invisibility to Public Internet** Subnetting was implemented so that the
    internal division of a network into subnets is visible only within the organization.
    To the rest of the Internet, the organization is still just one big, flat network.
    This also means that any changes made to the internal structure are not visible
    outside the organization.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**对公共互联网不可见** 子网划分的实施是为了使网络内部对子网的划分仅在组织内部可见。对于互联网的其他部分，该组织仍然是一个大型的、扁平的网络。这也意味着对内部结构所做的任何更改对外部都是不可见的。'
- en: '**No Need to Request New IP Addresses** Organizations don''t need to constantly
    requisition more IP addresses, as they would in the workaround of using multiple
    small Class C blocks.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需请求新的IP地址** 组织不需要不断请求更多的IP地址，就像在多个小型C类块的工作方案中那样。'
- en: '**No Routing Table Entry Proliferation** Since the subnet structure exists
    only within the organization, routers outside that organization know nothing about
    it. The organization still maintains a single (or perhaps a few) routing table
    entries for all of its devices. Only routers inside the organization need to worry
    about routing between subnets.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需路由表条目激增** 由于子网结构仅存在于组织内部，该组织外部的路由器对此一无所知。该组织仍然只为其所有设备维护单个（或可能几个）的路由表条目。只有组织内部的路由器需要担心子网之间的路由问题。'
- en: The change to subnetting affects both addressing and routing in IP networks.
    Addressing changes because, instead of having just a network ID and host ID, you
    now also have a *subnet ID* to be concerned with. The size of the subnet ID can
    vary for each network, so an additional piece of information is needed to supplement
    the IP address to indicate what part of the address is the subnet ID and what
    part is the host ID. This is a 32-bit number commonly called a *subnet mask*.
    The mask is used both for calculating subnet and host addresses, and by routers
    for determining how to move IP datagrams around a subnetted network.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 子网划分的改变影响了IP网络中的寻址和路由。寻址发生变化，因为，你不再只有一个网络ID和主机ID，现在你还需要关注一个*子网ID*。子网ID的大小可以因网络而异，因此需要额外的信息来补充IP地址，以指示地址的哪一部分是子网ID，哪一部分是主机ID。这是一个32位的数字，通常称为*子网掩码*。掩码既用于计算子网和主机地址，也由路由器用于确定如何在子网化的网络中移动IP数据报。
- en: 'Routing changes because of the additional level of hierarchy. In regular classful
    addressing, when a router receives an IP datagram, it only needs to decide if
    the destination is on the same network or a different network. Under subnetting,
    it must also look at the subnet ID of the destination and make one of three choices:
    same subnet, different subnet on the same network, or different network. Changes
    are also required to routing protocols, such as the Routing Information Protocol
    (RIP; see [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION PROTOCOL (RIP,
    RIP-2, AND RIPNG)")), to deal with subnets and subnet masks.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 路由因为增加了层次而发生变化。在常规的类地址中，当路由器接收到一个IP数据报时，它只需要决定目标是否在同一网络或不同网络。在子网划分中，它还必须查看目标的子网ID，并做出三种选择之一：同一子网、同一网络上的不同子网或不同网络。还需要对路由协议，如路由信息协议（RIP；见[第38章](ch38.html
    "第38章. 路由信息协议 (RIP, RIP-2, AND RIPNG)"))进行更改，以处理子网和子网掩码。
- en: Tip
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Subnet addressing adds an additional hierarchical level to
    how IP addresses are interpreted by dividing an organization''s IP network into
    subnets. This allows each organization to structure its address space to match
    its internal physical networks, rather than being forced to treat them a flat
    block. This solves a number of problems with the original classful addressing
    scheme, but requires changes to how addressing and routing work, as well as modifications
    to several TCP/IP protocols.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 子网地址通过将组织的IP网络划分为子网，为IP地址的解释增加了另一个层次化级别。这使得每个组织都能将其地址空间结构化以匹配其内部物理网络，而不是被迫将它们视为平面块。这解决了原始类地址方案中的许多问题，但需要改变地址和路由的工作方式，以及修改几个TCP/IP协议。'
- en: It's funny, but the main drawbacks to subnetting, compared with the older addressing
    scheme, have more to do with understanding how subnetting works than with the
    technology itself. More effort is required to deal with addressing and routing
    in a subnet environment, and administrators must learn how to subdivide their
    network into subnets and properly assign addresses. This can be a bit confusing
    to someone who is new to subnetting. However, the technology today is quite well
    established, so even this is not much of a problem.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有趣，但与较旧的地址方案相比，子网划分的主要缺点更多地与理解子网划分的工作原理有关，而不是与这项技术本身有关。在子网环境中处理地址和路由需要更多的努力，管理员必须学习如何将他们的网络划分为子网，并正确分配地址。这对子网划分的新手来说可能有点令人困惑。然而，今天这项技术已经相当成熟，所以这并不是一个大问题。
- en: 'IP Subnetting: Three-Level Hierarchical IP Subnet Addressing'
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分：三级层次化IP子网地址
- en: As I mentioned earlier, subnetting adds an additional level to the hierarchy
    of structures used in IP addressing. To support this, IP addresses must be broken
    into three elements instead of two. This is done by leaving the network ID alone
    and dividing the host ID into a subnet ID and host ID. These subnet ID bits are
    used to identify each subnet within the network. Hosts are assigned to the subnets
    in whatever manner makes the most sense for that network.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，子网划分在IP地址使用的结构层次中增加了一个额外的层次。为了支持这一点，IP地址必须被分成三个元素而不是两个。这是通过保持网络ID不变，并将主机ID划分为子网ID和主机ID来实现的。这些子网ID位用于识别网络中的每个子网。主机以对网络最有意义的方式分配到子网中。
- en: 'Interestingly, the earlier analogy to telephone numbers still holds in the
    world of subnetting and shows how subnetting changes the way IP addresses are
    interpreted. For example, a phone number like (401) 555-7777 has an area code
    (401) and a local number (555-7777). The local number, however, can itself be
    broken down into two parts: the exchange (555) and the local extension (7777).
    This means phone numbers really are comprised of three hierarchical components,
    just as IP addresses are in subnetting.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，之前对电话号码的类比在子网划分的世界中仍然适用，并展示了子网划分如何改变对IP地址的解释方式。例如，像(401) 555-7777这样的电话号码有一个区号(401)和一个本地号码(555-7777)。然而，本地号码本身可以分解为两部分：交换机(555)和本地分机(7777)。这意味着电话号码实际上由三个层次化的组件组成，就像子网划分中的IP地址一样。
- en: Of course, the number of bits in an IP address is fixed at 32\. This means that
    in splitting the host ID into subnet ID and host ID, you reduce the size of the
    host ID portion of the address. In essence, you are stealing bits from the host
    ID to use for the subnet ID. Class A networks have 24 bits to split between the
    subnet ID and host ID; Class B networks have 16; and Class C networks have only
    8.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，IP地址中的位数是固定的，为32位。这意味着在将主机ID划分为子网ID和主机ID时，你减小了地址中主机ID部分的尺寸。本质上，你是在从主机ID中窃取位数来用于子网ID。A类网络有24位可以分配给子网ID和主机ID；B类网络有16位；C类网络只有8位。
- en: Tip
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** A classful network is subnetted by dividing its host ID portion,
    leaving some of the bits for the host ID while allocating others to a new subnet
    ID. These bits are then used to identify individual subnets within the network,
    into which hosts are assigned.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 类地址通过将主机ID部分进行划分来进行子网划分，保留一些位用于主机ID，而将其他位分配给新的子网ID。这些位随后用于识别网络中的各个子网，主机被分配到这些子网中。'
- en: Now remember that when we looked at the sizes of each of the main classes in
    the previous chapter, we saw that, for each class, the number of networks and
    the number of hosts per network are a function of how many bits we use for each.
    The same applies to the splitting of the host ID. Since we are dealing with binary
    numbers, the number of subnets is two to the power of the size of the subnet ID
    field. Similarly, the number of hosts per subnet is two to the power of the size
    of the host ID field (less two for excluded special cases).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住，当我们查看上一章中每个主要类的大小的时候，我们看到了对于每个类，网络的数量和每个网络的主机数是每个类使用的位数的函数。同样适用于主机ID的划分。由于我们处理的是二进制数，子网的数量是子网ID字段大小的2的幂。同样，每个子网的主机数是主机ID字段大小的2的幂（减去两个排除的特殊情况）。
- en: 'Let''s take a brief example to see how this works. Imagine that you start with
    Class B network 154.71.0.0, with 16 bits for the network ID (154.71) and 16 are
    for the host ID. In regular classful addressing, there are no subnets and 65,534
    hosts total. To subnet this network, you can decide to split those 16 bits however
    you feel best suits the needs of the network: 1 bit for the subnet ID and 15 for
    the host ID, or 2 and 14, 3 and 13, and so on. Most any combination will work,
    as long as the total is 16; I''ve used 5 and 11 in the example shown in [Figure 18-1](ch18s02.html#subnetting_class_b_network_we_begin_with
    "Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0,
    which has 16 bits in its host ID block. We then subnet this network by dividing
    the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated
    to the subnet ID, leaving 11 bits for the host ID."). The more bits you steal
    from the host ID for the subnet ID, the more subnets you can have, but the fewer
    hosts you can have for each subnet.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简短的例子来看看这是如何工作的。想象一下，你从一个B类网络154.71.0.0开始，网络ID（154.71）有16位，主机ID也有16位。在常规的类地址中，没有子网，总共有65,534个主机。为了划分这个网络，你可以决定如何划分那16位，以最好地满足网络的需求：1位用于子网ID和15位用于主机ID，或者2和14，3和13，等等。只要总数是16，大多数任何组合都是可行的；我在[图18-1](ch18s02.html#subnetting_class_b_network_we_begin_with
    "图18-1. 子网划分B类网络 我们从B类网络154.71.0.0开始，该网络在其主机ID块中有16位。然后我们通过将主机ID划分为子网ID和主机ID来划分这个网络。在这种情况下，5位被分配给了子网ID，剩下11位用于主机ID。")中使用了5和11。从主机ID中为子网ID窃取的位数越多，你可以拥有的子网就越多，但每个子网的主机数就越少。
- en: '![Subnetting Class B network We begin with the Class B network 154.71.0.0,
    which has 16 bits in its host ID block. We then subnet this network by dividing
    the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated
    to the subnet ID, leaving 11 bits for the host ID.](httpatomoreillycomsourcenostarchimages287811.png.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![子网划分B类网络 我们从B类网络154.71.0.0开始，该网络在其主机ID块中有16位。然后我们通过将主机ID划分为子网ID和主机ID来划分这个网络。在这种情况下，5位被分配给了子网ID，剩下11位用于主机ID。](httpatomoreillycomsourcenostarchimages287811.png.jpg)'
- en: Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0,
    which has 16 bits in its host ID block. We then subnet this network by dividing
    the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated
    to the subnet ID, leaving 11 bits for the host ID.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-1. 子网划分B类网络 我们从B类网络154.71.0.0开始，该网络在其主机ID块中有16位。然后我们通过将主机ID划分为子网ID和主机ID来划分这个网络。在这种情况下，5位被分配给了子网ID，剩下11位用于主机ID。
- en: Choosing how to split the host ID into subnet and host bits is one of the most
    important design considerations in setting up a subnetted IP network. The number
    of subnets is generally determined based on the number of physical subnetworks
    in the overall organizational network, and the number of hosts per subnetwork
    must not exceed the maximum allowed for the particular subnetting choice you make.
    Choosing how to divide the original host ID bits into subnet ID bits and host
    ID bits is sometimes called *custom subnetting* and is described in more detail
    later in this chapter.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置子网IP网络时，如何将主机ID分割成子网位和主机位是设计时最重要的考虑因素之一。子网的数量通常基于整个组织网络中物理子网的数量来确定，并且每个子网中的主机数量不能超过你所选择的特定子网划分允许的最大值。如何将原始的主机ID位分割成子网ID位和主机ID位有时被称为*自定义子网划分*，本章后面将更详细地描述。
- en: IP Subnet Masks, Notation, and Subnet Calculations
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网掩码、表示法和子网计算
- en: Subnetting divides an organization's network into a two-level structure of subnets
    and hosts that is entirely internal and hidden from all other organizations on
    the Internet. One of the many advantages of this is that each organization gets
    to make its own choice about how to divide the classful host ID into subnet ID
    and host ID.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 子网划分将组织的网络划分为一个完全内部且对互联网上所有其他组织隐藏的两级结构：子网和主机。其许多优点之一是每个组织都可以根据自己的选择来划分类别的主机ID为子网ID和主机ID。
- en: In a nonsubnetted classful environment, routers use the first octet of the IP
    address to determine what the class of the address is, and from this they know
    which bits are the network ID and which are the host ID. When you use subnetting,
    these routers also need to know how that host ID is divided into subnet ID and
    host ID. However, this division can be arbitrary for each network. Furthermore,
    there is no way to tell how many bits belong to each simply by looking at the
    IP address.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在非子网划分的类环境，路由器使用IP地址的第一个八位字节来确定地址的类别，并据此知道哪些位是网络ID，哪些位是主机ID。当你使用子网划分时，这些路由器也需要知道如何将主机ID划分为子网ID和主机ID。然而，这种划分对每个网络来说是任意的。此外，仅通过查看IP地址就无法判断属于每个类别的位数。
- en: In a subnetting environment, the additional information about which bits are
    for the subnet ID and which are for the host ID must be communicated to devices
    that interpret IP addresses. This information is given in the form of a 32-bit
    binary number called a *subnet mask*. The term *mask* comes from the binary mathematics
    concept called *bit masking*. This is a technique where a special pattern of ones
    and zeros can be used in combination with boolean functions such as AND and OR
    to select or clear certain bits in a number. (I explain bit masking in the background
    section on binary numbers and mathematics, in [Chapter 4](ch04.html "Chapter 4. A
    REVIEW OF DATA REPRESENTATION AND THE MATHEMATICS OF COMPUTING").)
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在子网划分环境中，关于哪些位是子网ID位和哪些位是主机ID位的信息必须传达给解释IP地址的设备。这些信息以一个32位的二进制数的形式给出，称为*子网掩码*。术语*掩码*来自二进制数学概念中的*位掩码*。这是一种技术，可以使用特殊的1和0的模式与布尔函数（如AND和OR）结合使用，以选择或清除数字中的某些位。（我在关于二进制数和数学的背景部分中解释了位掩码，在[第4章](ch04.html
    "第4章. 数据表示和计算数学的回顾")中。）
- en: Function of the Subnet Mask
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网掩码的功能
- en: There's something about subnet masks that seems to set people's hair on end,
    especially if they aren't that familiar with binary numbers. However, the idea
    behind them is quite straightforward. The mask is a 32-bit number, just as the
    IP address is a 32-bit number. Each of the 32 bits in the subnet mask corresponds
    to the bit in the IP address in the same location in the number. The bits of the
    mask in any given subnetted network are chosen so that the bits used for either
    the network ID or subnet ID are ones, while the bits used for the host ID are
    zeros.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 子网掩码似乎让人感到不安，尤其是如果他们对二进制数不熟悉的话。然而，其背后的理念非常简单。掩码是一个32位的数字，就像IP地址也是一个32位的数字一样。子网掩码中的每一个32位对应于IP地址中相同位置的位。任何给定子网中掩码的位被选择，使得用于网络ID或子网ID的位是1，而用于主机ID的位是0。
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The *subnet mask* is a 32-bit binary number that accompanies
    an IP address. It is created so that it has a one bit for each corresponding bit
    of the IP address that is part of its network ID or subnet ID, and a zero for
    each bit of the IP address''s host ID. The mask thus tells TCP/IP devices which
    bits in that IP address belong to the network ID and subnet ID, and which are
    part of the host ID.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 子网掩码是一个32位二进制数，与IP地址一起使用。它是这样创建的，即对于IP地址中属于其网络ID或子网ID的每个对应位都有一个1位，而对于IP地址的主机ID的每个位都有一个0位。因此，掩码告诉TCP/IP设备哪些位属于网络ID和子网ID，哪些位是主机ID的一部分。'
- en: 'Why bother doing this with a 32-bit binary number? The answer is the magic
    of boolean logic. You use the subnet mask by applying the boolean AND function
    between it and the IP address. For each of the 32 "bit pairs" in the IP address
    and subnet mask, you employ the AND function, the output of which is one only
    if both bits are one. What this means in practical terms is the following, for
    each of the 32 bits:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要用32位二进制数来做这件事呢？答案是布尔逻辑的魔力。你通过将布尔AND函数应用于子网掩码和IP地址来使用子网掩码。对于IP地址和子网掩码中的每个32个“位对”，你使用AND函数，其输出只有当两个位都是1时才为1。这在实际意义上的含义如下，对于每个32位：
- en: '**Subnet Bit Is a One** In this case, you are ANDing either a zero or one in
    the IP address with a one. If the IP address bit is a zero, the result of the
    AND will be zero; if it is a one, the AND will be one. In other words, *where
    the subnet bit is a one, the IP address is preserved unchanged*.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网位为1** 在这种情况下，你正在将IP地址中的0或1与1进行AND操作。如果IP地址位是0，AND操作的结果将是0；如果是1，AND操作将是1。换句话说，*当子网位为1时，IP地址保持不变*。'
- en: '**Subnet Bit Is a Zero** Here, you are ANDing with a zero, so the result is
    always zero, regardless of what the IP address is. Thus, *when the subnet bit
    is a zero, the IP address bit is always cleared to zero*.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网位为0** 在这种情况下，你正在与0进行AND操作，所以结果总是0，无论IP地址是什么。因此，*当子网位为0时，IP地址位总是被清除为零*。'
- en: Thus, when you use the subnet mask on an IP address, the bits in the network
    ID and subnet ID are left intact, while the host ID bits are removed. Like a mask
    that blocks part of your face but lets other parts show, the subnet mask blocks
    some of the address bits (the host bits) and leaves others alone (the network
    and subnet bits). A router that performs this function is left with the address
    of the subnet. Since it knows from the class of the network what part is the network
    ID, it also knows what subnet the address is on.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你在IP地址上使用子网掩码时，网络ID和子网ID中的位保持不变，而主机ID位被移除。就像一个只遮挡你面部一部分但让其他部分露出的面具一样，子网掩码遮挡了地址的一部分位（主机位），而其他位保持不变（网络和子网位）。执行此功能的路由器将保留子网的地址。由于它知道从网络类别中哪个部分是网络ID，它也知道地址位于哪个子网。
- en: Tip
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To use a subnet mask, a device performs a boolean AND operation
    between each bit of the subnet mask and each corresponding bit of an IP address.
    The resulting 32-bit number contains only the network ID and subnet ID of the
    address, with the host ID cleared to zero.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 要使用子网掩码，设备会在子网掩码的每一位与IP地址的对应位之间执行布尔AND操作。结果32位数字仅包含地址的网络ID和子网ID，主机ID被清除为零。'
- en: Subnet Mask Notation
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网掩码表示法
- en: Like IP addresses, subnet masks are always used as a 32-bit binary number by
    computers. And like IP addresses, using them as 32-bit binary numbers is difficult
    for humans. Therefore, they are usually converted to dotted decimal notation for
    convenience, just as IP addresses are.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 就像IP地址一样，子网掩码在计算机中总是以32位二进制数的形式使用。并且，就像IP地址一样，将它们作为32位二进制数使用对人类来说很困难。因此，它们通常被转换为点分十进制表示法以便于使用，就像IP地址一样。
- en: For example, suppose you decide to subnet the Class B network 154.71.0.0 using
    5 bits for the subnet ID and 11 bits for the host ID (see [Figure 18-2](ch18s03.html#determining_the_subnet_mask_of_a_subnett
    "Figure 18-2. Determining the subnet mask of a subnetted network The Class B network
    from Figure 18-1 is shown at the top, with 5 bits assigned to the subnet ID and
    11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit
    number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit.
    You can then convert this to dotted decimal.")). In this case, the subnet mask
    will have 16 ones for the network portion (since this is Class B) followed by
    5 ones for the subnet ID, and 11 zeros for the host ID. That's 11111111 11111111
    **11111**000 00000000 in binary, with the bits corresponding to the subnet ID
    highlighted. In dotted decimal, the subnet mask would be 255.255.248.0.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你决定使用5位作为子网ID和11位作为主机ID来子网化B类网络154.71.0.0（参见[图18-2](ch18s03.html#determining_the_subnet_mask_of_a_subnett
    "图18-2. 确定子网化网络的子网掩码。图18-1中的B类网络从顶部开始，分配了5位给子网ID，剩下11位用于主机ID。要创建子网掩码，你需要将一个32位的数字填充为每个网络ID和子网ID位为1，每个主机ID位为0。然后你可以将其转换为点分十进制。")）。在这种情况下，子网掩码将有16个1用于网络部分（因为这是B类），然后是5个1用于子网ID，接着是11个0用于主机ID。这在二进制中表示为11111111
    11111111 **11111**000 00000000，其中对应子网ID的位被突出显示。在点分十进制中，子网掩码将是255.255.248.0。
- en: '![Determining the subnet mask of a subnetted network The Class B network from
    is shown at the top, with 5 bits assigned to the subnet ID and 11 bits left for
    the host ID. To create the subnet mask, you fill in a 32-bit number with 1 for
    each network ID and subnet ID bit, and 0 for each host ID bit. You can then convert
    this to dotted decimal.](httpatomoreillycomsourcenostarchimages287813.png.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![确定子网掩码的子网化网络 示例图](httpatomoreillycomsourcenostarchimages287813.png.jpg) 在此图中，显示的是从顶部开始的B类网络，其中5位分配给了子网ID，剩下11位用于主机ID。要创建子网掩码，你需要将一个32位的数字填充为每个网络ID和子网ID位为1，每个主机ID位为0。然后你可以将其转换为点分十进制。'
- en: Figure 18-2. Determining the subnet mask of a subnetted network The Class B
    network from [Figure 18-1](ch18s02.html#subnetting_class_b_network_we_begin_with
    "Figure 18-1. Subnetting Class B network We begin with the Class B network 154.71.0.0,
    which has 16 bits in its host ID block. We then subnet this network by dividing
    the host ID into a subnet ID and host ID. In this case, 5 bits have been allocated
    to the subnet ID, leaving 11 bits for the host ID.") is shown at the top, with
    5 bits assigned to the subnet ID and 11 bits left for the host ID. To create the
    subnet mask, you fill in a 32-bit number with 1 for each network ID and subnet
    ID bit, and 0 for each host ID bit. You can then convert this to dotted decimal.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-2. 确定子网化网络的子网掩码。图18-1中的B类网络从顶部开始，分配了5位给子网ID，剩下11位用于主机ID。要创建子网掩码，你需要将一个32位的数字填充为每个网络ID和子网ID位为1，每个主机ID位为0。然后你可以将其转换为点分十进制。
- en: 'Applying the Subnet Mask: An Example'
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用子网掩码：示例
- en: Now, let's see how the subnet mask might be used. Suppose you have a host on
    this network with an IP of 154.71.150.42 and a router needs to figure out which
    subnet this address is on. To do so, it performs the masking operation shown in
    [Table 18-1](ch18s03.html#determining_the_subnet_id_of_an_ip_addre "Table 18-1. Determining
    the Subnet ID of an IP Address Through Subnet Masking") and [Figure 18-3](ch18s03.html#determining_the_subnet_id_of_an_ip-id001
    "Figure 18-3. Determining the subnet ID of an IP address through subnet masking
    Subnet masking involves performing a boolean AND between each corresponding bit
    in the subnet mask and the IP address. The subnet mask can be likened to a physical
    mask; each 1 in it lets the corresponding bit of the IP address show through,
    while each 0 blocks the corresponding IP address bit. In this way the host ID
    bits of the address are stripped so the device can determine the subnet to which
    the address belongs.").
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看子网掩码可能如何被使用。假设你在这个网络上有主机，其IP地址为154.71.150.42，而路由器需要确定这个地址所在的子网。为此，它执行了[表18-1](ch18s03.html#determining_the_subnet_id_of_an_ip_addre
    "表18-1. 通过子网掩码确定IP地址的子网ID")和[图18-3](ch18s03.html#determining_the_subnet_id_of_an_ip-id001
    "图18-3. 通过子网掩码确定IP地址的子网ID 子网掩码涉及在子网掩码和IP地址的每个对应位之间执行布尔AND操作。子网掩码可以比作物理掩码；其中的每个1都允许IP地址的对应位显示出来，而每个0则阻止IP地址的对应位。这样，地址的主机ID位就被剥离，以便设备可以确定地址所属的子网。")中显示的掩码操作。
- en: Table 18-1. Determining the Subnet ID of an IP Address Through Subnet Masking
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-1. 通过子网掩码确定IP地址的子网ID
- en: '| Component | Octet 1 | Octet 2 | Octet 3 | Octet 4 |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 八位字节1 | 八位字节2 | 八位字节3 | 八位字节4 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **IP Address** | 10011010 (154) | 01000111 (71) | 10010110 (150) | 00101010
    (42) |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| **IP地址** | 10011010 (154) | 01000111 (71) | 10010110 (150) | 00101010 (42)
    |'
- en: '| **Subnet Mask** | 11111111 (255) | 11111111 (255) | **11111**000 (248) |
    00000000 (0) |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| **子网掩码** | 11111111 (255) | 11111111 (255) | **11111**000 (248) | 00000000
    (0) |'
- en: '| **Result of AND Masking** | 10011010 (154) | 01000111(71) | **10010**000
    (144) | 00000000 (0) |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| **AND掩码结果** | 10011010 (154) | 01000111(71) | **10010**000 (144) | 00000000
    (0) |'
- en: '![Determining the subnet ID of an IP address through subnet masking Subnet
    masking involves performing a boolean AND between each corresponding bit in the
    subnet mask and the IP address. The subnet mask can be likened to a physical mask;
    each 1 in it lets the corresponding bit of the IP address show through, while
    each 0 blocks the corresponding IP address bit. In this way the host ID bits of
    the address are stripped so the device can determine the subnet to which the address
    belongs.](httpatomoreillycomsourcenostarchimages287815.png.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![通过子网掩码确定IP地址的子网ID 子网掩码涉及在子网掩码和IP地址的每个对应位之间执行布尔AND操作。子网掩码可以比作物理掩码；其中的每个1都允许IP地址的对应位显示出来，而每个0则阻止IP地址的对应位。这样，地址的主机ID位就被剥离，以便设备可以确定地址所属的子网。](httpatomoreillycomsourcenostarchimages287815.png.jpg)'
- en: Figure 18-3. Determining the subnet ID of an IP address through subnet masking
    Subnet masking involves performing a boolean AND between each corresponding bit
    in the subnet mask and the IP address. The subnet mask can be likened to a physical
    mask; each 1 in it lets the corresponding bit of the IP address show through,
    while each 0 blocks the corresponding IP address bit. In this way the host ID
    bits of the address are stripped so the device can determine the subnet to which
    the address belongs.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-3. 通过子网掩码确定IP地址的子网ID 子网掩码涉及在子网掩码和IP地址的每个对应位之间执行布尔AND操作。子网掩码可以比作物理掩码；其中的每个1都允许IP地址的对应位显示出来，而每个0则阻止IP地址的对应位。这样，地址的主机ID位就被剥离，以便设备可以确定地址所属的子网。
- en: 'This result, 154.71.144.0, is the IP address of the subnet to which 154.71.150.42
    belongs. There is no need to explicitly differentiate the network ID bits from
    the subnet ID bits, because you are still using classful addresses. Any router
    can see that since the first two bits of the address are 10, this is a Class B
    address. So the network ID is 16 bits, and this means the subnet ID must be bits
    17 to 21, counting from the left. Here, the subnet is the portion highlighted
    earlier: 10010, or subnet 18\. (I''ll explain this better in the "IP Custom Subnet
    Masks" section later in this chapter.)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果，154.71.144.0，是154.71.150.42所属子网的IP地址。由于你仍在使用类别地址，因此没有必要明确区分网络ID位和子网ID位。任何路由器都可以看到，由于地址的前两位是10，这是一个B类地址。因此，网络ID是16位，这意味着子网ID必须是从左边数起的第17到21位。在这里，子网是之前突出显示的部分：10010，或子网18。（我将在本章后面的“IP自定义子网掩码”部分更好地解释这一点。）
- en: Tip
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The subnet mask is often expressed in dotted decimal notation
    for convenience, but is used by computers as a binary number and usually must
    be expressed in binary to understand how the mask works and the number of subnet
    ID bits it represents.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 子网掩码通常以点分十进制表示法表示，以便于使用，但计算机将其用作二进制数，通常必须以二进制形式表示，以便理解掩码的工作原理以及它所代表的子网ID位数。'
- en: Rationale for Subnet Mask Notation
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网掩码表示法的理由
- en: 'In practical terms, the subnet mask actually conveys only a single piece of
    information: the line between the subnet ID and host ID. Then why bother with
    a big 32-bit binary number in that case, instead of just specifying the bit number
    where the division occurs? Instead of carrying the subnet mask of 255.255.248.0
    around, why not just divide the IP address after bit 21? Even if devices want
    to perform a masking operation, couldn''t they just create the mask as needed?'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，子网掩码实际上只传达一条信息：子网ID和主机ID之间的界限。那么为什么还要费心使用一个大的32位二进制数，而不是只指定发生分割的位数呢？为什么不在21位之后直接分割IP地址？即使设备想要执行掩码操作，它们不能按需创建掩码吗？
- en: 'That''s a very good question. There are two historical reasons: efficiency
    considerations and support for noncontiguous masks. The subnet mask expression
    is efficient because it allows routers to perform a quick masking operation to
    determine the subnet address. (This is not really an issue today given the speed
    of today''s machines.)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题。有两个历史原因：效率考虑和对非连续掩码的支持。子网掩码表达式是高效的，因为它允许路由器快速执行掩码操作以确定子网地址。（考虑到今天机器的速度，这实际上并不是一个问题。）
- en: When splitting the bits in the host ID for subnet ID and host ID, RFC 950 specifies
    that they may be split in more than one place. In the previous example, you could,
    instead of splitting the 16 bits into 5 bits for subnet ID and 11 for host ID,
    have done it as 2 bits for the subnet ID, then 4 bits for the host ID, then 3
    more bits for the subnet ID, and finally 7 more bits for host ID. This would be
    represented by the subnet mask pattern 11000011 10000000 for those 16 bits (following
    the 16 ones for the network ID). Of course, subnetting this way makes assigning
    addresses *extremely* confusing. For this reason, while technically legal, noncontiguous
    subnet masking is not recommended and not done in practice.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当将主机ID中的位分割为子网ID和主机ID时，RFC 950指定它们可以在多个地方分割。在先前的例子中，你不仅可以把16位分割成5位作为子网ID和11位作为主机ID，还可以将其分割为2位作为子网ID，然后4位作为主机ID，接着再分割3位作为子网ID，最后再分割7位作为主机ID。对于这16位，子网掩码模式将是11000011
    10000000（紧随网络ID的16个1之后）。当然，以这种方式进行子网划分会使得分配地址变得极其混乱。因此，虽然技术上合法，但非连续子网掩码不被推荐，并且在实践中也不这样做。
- en: Given that noncontiguous masks are not used, and today's computers are faster,
    the alternative method of expressing masks with just a single number is now often
    used. Instead of writing "IP address of 154.71.150.42 with subnet mask of 255.255.248.0,"
    you can simply write "154.71.150.42**/21**." This is sometimes called *slash notation*
    or *Classless Inter-Domain Routing* *(CIDR) notation*. While this is more commonly
    used in Variable Length Subnet Masking (VLSM) environments and is the standard
    for specifying classless addresses under the CIDR addressing scheme (see [Chapter 20](ch20.html
    "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING")),
    it is also sometimes seen in regular subnetting discussions.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 由于非连续掩码不再使用，并且今天的计算机速度更快，现在经常使用仅用一个数字来表示掩码的替代方法。与其写“IP地址为154.71.150.42，子网掩码为255.255.248.0”，你只需简单地写“154.71.150.42**/21**”。这有时被称为*斜线表示法*或*无类别域间路由（CIDR）表示法*。虽然这在可变长度子网掩码（VLSM）环境中更为常见，并且在CIDR地址方案下指定无类别地址是标准（见[第20章](ch20.html
    "第20章。IP无类别地址——无类别域间路由（CIDR）/超网"）），但它有时也出现在常规子网划分讨论中。
- en: Note
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Since these weird masks were never really used, some resources say that the
    subnet mask always had to be contiguous, but this is not true—originally, it was
    legal but advised against. Later, this practice became so out of favor that many
    hardware devices would not support it. Today, now that classless addressing and
    CIDR are standard, noncontiguous masks are simply illegal*.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于这些奇怪的掩码从未真正使用过，一些资料称子网掩码总是必须连续的，但这并不正确——最初，这是合法的但被建议不要这样做。后来，这种做法变得不再受欢迎，以至于许多硬件设备都不支持它。如今，随着无类别地址和CIDR成为标准，非连续掩码现在是非法的*。'
- en: IP Default Subnet Masks for Address Classes A, B, and C
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP地址类A、B和C的默认子网掩码
- en: In order to better understand how subnets divide a Class A, B, or C network,
    let's look at how the Class A, B, and C networks are represented in a subnetted
    environment. This might seem unnecessary if you aren't planning to create subnets,
    but the fact is, once subnetting became popular, most operating systems, networking
    hardware, and software assumed that subnetting would be used. Even if you decide
    not to subnet, you may need to express your unsubnetted network using a subnet
    mask.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解子网是如何划分A类、B类或C类网络的，让我们看看在子网环境中的A类、B类和C类网络是如何表示的。如果你不打算创建子网，这可能会显得没有必要，但事实是，一旦子网划分变得流行，大多数操作系统、网络硬件和软件都假设会使用子网划分。即使你决定不进行子网划分，你也可能需要使用子网掩码来表示你的非子网网络。
- en: In essence, a nonsubnetted Class A, B, or C network can be considered the default
    for the more general, custom-subnetted network. You can think of a nonsubnetted
    network as being the case where you choose to divide the host ID so that exactly
    zero bits are used for the subnet ID, and all the bits are used for the host ID.
    This default case is the basis for the more practical subnetting you will examine
    shortly.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，非子网划分的A类、B类或C类网络可以被视为更一般、自定义子网划分网络的默认情况。你可以将非子网划分网络视为你选择将主机ID划分为恰好零位用于子网ID，所有位都用于主机ID的情况。这个默认情况是你在稍后将要检查的更实用的子网划分的基础。
- en: As is always the case, the subnet mask for a default, unsubnetted Class A, B,
    or C network has ones for each bit that is used for the network ID or subnet ID
    and zeros for the host ID bits. Of course, I just said you aren't subnetting,
    so there *are* no subnet ID bits! Thus, the subnet mask for this default case
    has ones for the network ID portion and zeros for the host ID portion. This is
    called the *default subnet mask* for each of the IP address classes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 正如通常情况一样，默认的、未子网划分的A类、B类或C类网络的子网掩码对于每个用于网络ID或子网ID的位都是1，而对于主机ID位是0。当然，我刚才说过你不会进行子网划分，所以没有子网ID位！因此，这个默认情况的子网掩码对于网络ID部分是1，对于主机ID部分是0。这被称为每个IP地址类的*默认子网掩码*。
- en: Since Class A, B, and C divide the network ID from the host ID on octet boundaries,
    the subnet mask will always have all ones or all zeros in an octet. Therefore,
    the default subnet masks will always have 255s or 0s when expressed in decimal
    notation. [Table 18-2](ch18s04.html#default_subnet_masks_for_class_a_class_b "Table 18-2. Default
    Subnet Masks for Class A, Class B, and Class C Networks") summarizes the default
    subnet masks for each of the classes. They are also shown graphically in [Figure 18-4](ch18s04.html#default_subnet_masks_for_class_a_c-id001
    "Figure 18-4. Default subnet masks for Class A, Class B, and Class C networks").
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Class A、B 和 C 在八位边界上从网络 ID 划分到主机 ID，子网掩码在八位中总是全部为 1 或全部为 0。因此，默认子网掩码在十进制表示中总是包含
    255 或 0。[表 18-2](ch18s04.html#default_subnet_masks_for_class_a_class_b "表 18-2.
    Class A、Class B 和 Class C 网络的默认子网掩码") 总结了每个类别的默认子网掩码。它们也以图形方式显示在[图 18-4](ch18s04.html#default_subnet_masks_for_class_a_c-id001
    "图 18-4. Class A、Class B 和 Class C 网络的默认子网掩码")中。
- en: Table 18-2. Default Subnet Masks for Class A, Class B, and Class C Networks
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-2. Class A、Class B 和 Class C 网络的默认子网掩码
- en: '| IP Address Class | Total # of Bits for Network ID/Host ID | Default Subnet
    Mask |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| IP 地址类别 | 网络 ID/主机 ID 的总位数 | 默认子网掩码 |'
- en: '| --- | --- | --- |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   |   | First Octet | Second Octet | Third Octet | Fourth Octet |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 第一字节 | 第二字节 | 第三字节 | 第四字节 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Class A | **8/24** | 11111111 (255) | 00000000 (0) | 00000000 (0) | 00000000
    (0) |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| Class A | **8/24** | 11111111 (255) | 00000000 (0) | 00000000 (0) | 00000000
    (0) |'
- en: '| Class B | **16/16** | 11111111 (255) | 11111111 (255) | 00000000 (0) | 00000000
    (0) |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| Class B | **16/16** | 11111111 (255) | 11111111 (255) | 00000000 (0) | 00000000
    (0) |'
- en: '| Class C | **24/8** | 11111111 (255) | 11111111 (255) | 11111111 (255) | 00000000
    (0) |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| Class C | **24/8** | 11111111 (255) | 11111111 (255) | 11111111 (255) | 00000000
    (0) |'
- en: '![Default subnet masks for Class A, Class B, and Class C networks](httpatomoreillycomsourcenostarchimages287817.png.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![Class A、Class B 和 Class C 网络的默认子网掩码](httpatomoreillycomsourcenostarchimages287817.png.jpg)'
- en: Figure 18-4. Default subnet masks for Class A, Class B, and Class C networks
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-4. Class A、Class B 和 Class C 网络的默认子网掩码
- en: Thus, the three default subnet masks are 255.0.0.0 for Class A, 255.255.0.0
    for Class B, and 255.255.255.0 for Class C.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，三个默认子网掩码分别是 Class A 的 255.0.0.0，Class B 的 255.255.0.0，以及 Class C 的 255.255.255.0。
- en: 'While all default subnet masks use only 255 and 0, not all subnet masks with
    255 and 0 are defaults. There are a small number of custom subnets that divide
    on octet boundaries as well. These are as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有默认子网掩码都只使用 255 和 0，但并非所有包含 255 和 0 的子网掩码都是默认的。还有一些自定义子网在八位边界上划分，如下所示：
- en: '**255.255.0.0** This is the default mask for Class B, but can also be the custom
    subnet mask for dividing a Class A network using 8 bits for the subnet ID (leaving
    16 bits for the host ID).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**255.255.0.0** 这是 Class B 的默认掩码，但也可以是使用 8 位子网 ID（为主机 ID 留下 16 位）来划分 Class
    A 网络的自定义子网掩码。'
- en: '**255.255.255.0** This is the default subnet mask for Class C, but can be a
    custom Class A with 16 bits for the subnet ID *or* a Class B with 8 bits for the
    subnet ID.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**255.255.255.0** 这是 Class C 的默认子网掩码，但可以是具有 16 位子网 ID 的自定义 Class A 或具有 8 位子网
    ID 的 Class B。'
- en: Tip
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each of the three IP unicast and broadcast address classes,
    A, B, and C, has a *default subnet mask* defined that has a one for each bit of
    the class''s network ID, a zero for each bit of its host ID, and no subnet ID
    bits. The three default subnet masks are 255.0.0.0 for Class A, 255.255.0.0 for
    Class B, and 255.255.255.0 for Class C.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个三个 IP 单播和广播地址类别，A、B 和 C，都有一个 *默认子网掩码* 定义，该掩码在每个类别的网络 ID 的位上有一个 1，在其主机
    ID 的位上有一个 0，并且没有子网 ID 位。三个默认子网掩码分别是 Class A 的 255.0.0.0，Class B 的 255.255.0.0，以及
    Class C 的 255.255.255.0。'
- en: IP Custom Subnet Masks
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 自定义子网掩码
- en: A default subnet mask doesn't really represent subnetting because you are assigning
    zero bits to the subnet ID. To do real subnetting, you must dedicate at least
    one of the bits of the presubnetted host ID to the subnet ID.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 默认子网掩码实际上并不代表子网划分，因为您正在将零位分配给子网 ID。要进行真正的子网划分，您必须将 presubnetted 主机 ID 的至少一位位分配给子网
    ID。
- en: Since you can choose the dividing point between subnet ID and host ID to suit
    the network, this is sometimes called *customized subnetting*. The subnet mask
    that you use when creating a customized subnet is, in turn, called a *custom subnet
    mask*. The custom subnet mask is used by network hardware to determine how you
    have decided to divide the subnet ID from the host ID in the network.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以选择子网ID和主机ID之间的分隔点以适应网络，这有时被称为*定制子网划分*。在创建定制子网时使用的子网掩码，反过来，被称为*定制子网掩码*。定制子网掩码由网络硬件用于确定如何在网络中将子网ID从主机ID中划分。
- en: Deciding How Many Subnet Bits to Use
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定使用多少子网位
- en: The key decision in customized subnetting is how many bits to take from the
    host ID portion of the IP address to put into the subnet ID. You'll recall that
    the number of subnets possible on the network is two to the power of the number
    of bits you use to express the subnet ID, and the number of hosts possible per
    subnet is two to the power of the number of bits left in the host ID (less two,
    as I explain later in this section).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 定制子网划分中的关键决策是从IP地址的主机ID部分取出多少位放入子网ID。你会记得，网络中可能的子网数量是用于表示子网ID的位的数量的2的幂，每个子网可能的主机数量是主机ID中剩余位的2的幂（减去两个，如我在本节后面解释的那样）。
- en: 'Thus, the decision of how many bits to use for each of the subnet ID and host
    ID represents a fundamental trade-off in subnet addressing:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定为每个子网ID和主机ID使用多少位代表了子网寻址中的一个基本权衡：
- en: Each bit taken from the host ID for the subnet ID doubles the number of subnets
    that are possible in the network.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机ID中取出的每个位用于子网ID，都会使网络中可能的子网数量加倍。
- en: Each bit taken from the host ID for the subnet ID (approximately) halves the
    number of hosts that are possible within each subnet on the network.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机ID中取出的每个位用于子网ID（大约）将网络中每个子网内可能的主机数量减半。
- en: 'For example, say you start with a Class B network with the network address
    154.71.0.0\. Since this is Class B, 16 bits are for the network ID (154.71) and
    16 are for the host ID. In the default case, there are no subnets and 65,534 hosts
    total. To subnet this network, you can use the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你从一个B类网络开始，网络地址为154.71.0.0。由于这是B类，16位用于网络ID（154.71）和16位用于主机ID。在默认情况下，没有子网，总共有65,534个主机。要划分这个网络，你可以使用以下方法：
- en: One bit for the subnet ID and 15 bits for the host ID. If you do this, then
    the total number of subnets is 2¹, or 2\. The first subnet is 0, and the second
    is 1\. The number of hosts available for each subnet is 2^(15)–2, or 32,766.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网ID使用1位，主机ID使用15位。如果你这样做，子网总数将是2¹，即2。第一个子网是0，第二个是1。每个子网可用的主机数量是2^(15)–2，即32,766。
- en: 'Two bits for the subnet ID and 14 for the host ID. In this case, you double
    the number of subnets. You now have 2², or 4 subnets: 00, 01, 10, and 11 (subnets
    0, 1, 2, and 3). But the number of hosts is now only 2^(14)–2, or 16,382.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网ID使用2位，主机ID使用14位。在这种情况下，子网数量加倍。现在你有2²，即4个子网：00、01、10和11（子网0、1、2和3）。但主机数量现在只有2^(14)–2，即16,382。
- en: 'Any combination of bits that add up to 16 as long as they allow you at least
    two hosts per subnet: 4 and 12, 5 and 11, and so on.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何位组合，只要总和为16，并且每个子网至少有2个主机：4和12，5和11等等。
- en: The way you decide to divide the classful host ID into subnet ID and host ID
    bits is the key design decision in subnetting. You make your choice based on the
    number of subnets in the network, and also on the maximum number of hosts that
    need to be assigned to each subnet in the network. For example, if you have 10
    total subnets for your Class B network, you need 4 bits to represent this, because
    2⁴ is 16 while 2³ is only 8\. This leaves 12 bits for the host ID, for a maximum
    of 4,094 hosts per subnet.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你决定如何将类C主机ID划分为子网ID和主机ID位是子网划分中的关键设计决策。你的选择基于网络中的子网数量，以及网络中每个子网需要分配的最大主机数量。例如，如果你有10个总子网用于你的B类网络，你需要4位来表示这一点，因为2⁴是16，而2³只是8。这留下了12位用于主机ID，每个子网最多有4,094个主机。
- en: However, suppose instead that you have 20 subnets. If so, 4 bits for subnet
    ID won't suffice; you need 5 bits (2⁵=32). This means that you now have only 11
    bits for the host ID, for a maximum of 2,046 hosts per subnet. (Step 2 of the
    practical subnetting example in [Chapter 19](ch19.html "Chapter 19. IP SUBNETTING
    PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE") discusses these decisions
    in more detail.)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你有20个子网。如果是这样，子网ID的4位将不足以使用；你需要5位（2⁵=32）。这意味着你现在只有11位用于主机ID，每个子网最多有2,046个主机。（[第19章](ch19.html
    "第19章. IP子网划分实践子网设计和地址确定示例")中的实际子网划分示例的第二步详细讨论了这些决策。）
- en: Now if you have 20 subnets and also need a maximum of 3,000 hosts per subnet,
    you have a problem. You need 5 bits to express 20 different subnets, but you need
    12 bits to express the number 3,000 for the host ID. That's 17 bits—too many.
    What's the solution? You might be able to shuffle your physical networks so that
    you only have 16\. If not, you need a second Class B network.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有20个子网，并且每个子网最多需要3,000个主机，你遇到了问题。你需要5位来表示20个不同的子网，但你需要12位来表示主机的ID号。这是17位——太多了。解决方案是什么？你可能能够重新排列你的物理网络，使得你只有16个。如果不能，你需要第二个B类网络。
- en: Tip
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The fundamental trade-off in subnetting is that each addition
    of a bit to the subnet ID (and thus, subtraction of that bit from the host ID)
    doubles the number of subnets, and approximately halves the number of hosts in
    each subnet. Each subtraction of a bit from the subnet ID (and addition of that
    bit to the host ID) does the opposite.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 子网划分的基本权衡是，每个子网ID位（因此，从主机ID中减去该位）的增加都会使子网数量翻倍，并且大约将每个子网中的主机数量减半。从子网ID中减去位（并将该位加到主机ID上）会做相反的事情。'
- en: Determining the Custom Subnet Mask
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定自定义子网掩码
- en: Once you determine how many bits to devote to the subnet and host IDs, you can
    determine the subnet mask. You begin with the default subnet mask in binary for
    the appropriate class of the network. You start with the leftmost zero in that
    mask and change as many bits to one as you have dedicated to the subnet ID, at
    which point you can express the subnet mask in dotted decimal form. [Figure 18-5](ch18s05.html#custom_subnet_masks_for_class_c_networks
    "Figure 18-5. Custom subnet masks for Class C networks Since there are host ID
    bits in a Class C network address, there are six different ways that the network
    can be subnetted. Each corresponds to a different custom subnet mask, which is
    created by changing the allocated subnet ID bits from zero to one.") shows how
    the custom subnet mask can be determined for each of the subnetting options of
    a Class C network in both binary and decimal.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了分配给子网和主机ID的位数，你就可以确定子网掩码。你从网络适当类别的默认子网掩码的二进制形式开始。你从该掩码中最左边的零开始，将你分配给子网ID的位数改为一，此时你可以用点分十进制形式表示子网掩码。[图18-5](ch18s05.html#custom_subnet_masks_for_class_c_networks
    "图18-5. Class C网络的自定义子网掩码，由于Class C网络地址中有主机ID位，因此网络可以有六种不同的子网划分方式。每种方式对应一个不同的自定义子网掩码，这是通过将分配的子网ID位从零改为一来创建的。")显示了如何为Class
    C网络的每个子网划分选项确定自定义子网掩码，既以二进制形式又以十进制形式。
- en: 'Consider the Class C network 200.13.94.0 in [Figure 18-5](ch18s05.html#custom_subnet_masks_for_class_c_networks
    "Figure 18-5. Custom subnet masks for Class C networks Since there are host ID
    bits in a Class C network address, there are six different ways that the network
    can be subnetted. Each corresponds to a different custom subnet mask, which is
    created by changing the allocated subnet ID bits from zero to one."). There are
    eight bits in the original host ID, which gives you six different subnetting options
    (you can''t use seven or eight bits for the subnet ID, for reasons I will discuss
    shortly). Suppose you use three of these for the subnet ID, leaving five for the
    host ID. To determine the custom subnet mask, you start with the Class C default
    subnet mask:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图18-5](ch18s05.html#custom_subnet_masks_for_class_c_networks "图18-5. Class
    C网络的自定义子网掩码，由于Class C网络地址中有主机ID位，因此网络可以有六种不同的子网划分方式。每种方式对应一个不同的自定义子网掩码，这是通过将分配的子网ID位从零改为一来创建的。")中的Class
    C网络200.13.94.0。原始主机ID中有8位，这为你提供了六种不同的子网划分选项（你无法使用七位或八位作为子网ID，原因我将在稍后讨论）。假设你使用其中的三位作为子网ID，剩下五位作为主机ID。为了确定自定义子网掩码，你从Class
    C默认子网掩码开始：
- en: '| 11111111 11111111 11111111 00000000 |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 11111111 11111111 11111111 00000000 |'
- en: '| You then change the first three zeros to ones, to get the custom subnet mask:
    |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 然后你将前三个零改为一，以获得自定义子网掩码：|'
- en: '| 11111111 11111111 11111111 **111**00000 |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 11111111 11111111 11111111 **111**00000 |'
- en: '| In dotted decimal format, this is 255.255.255.224. |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 以点分十进制格式，这表示为 255.255.255.224. |'
- en: Note
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Once you''ve made the choice of how to subnet, you determine the custom subnet
    mask by starting with the default subnet mask for the network and changing each
    subnet ID bit from a zero to a one*.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦你选择了子网划分的方法，你就可以通过从网络的默认子网掩码开始，将每个子网ID位从零改为一来确定自定义子网掩码*。'
- en: Note
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In regular subnetting, the choice of how many bits to use for the subnet ID
    is fixed for the entire network. You can''t have subnets of different sizes—they
    must all be the same. Thus, the number of hosts in the largest subnet will dictate
    how many bits you need for the host ID. This means that in the previous case,
    if you had a strange configuration where 19 subnets had only 100 hosts each but
    the 20th had 3,000, you would have a problem. If this were the case, you could
    solve the problem easily by dividing that one oversized subnet into two or more
    smaller ones. An enhancement to subnetting called Variable Length Subnet Masking
    (VLSM) was created in large part to remove this restriction. VLSM is described
    later in the chapter*.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '*在常规子网划分中，用于子网ID的位数在整个网络中是固定的。你不能有不同大小的子网——它们必须相同。因此，最大子网中的主机数将决定你需要多少位用于主机ID。这意味着在先前的例子中，如果你有一个奇怪的配置，其中19个子网每个只有100个主机，但第20个子网有3,000个，你将遇到问题。如果这种情况发生，你可以通过将那个超大的子网分成两个或更多较小的子网来轻松解决这个问题。子网划分的一个增强功能，称为可变长度子网掩码（VLSM），在很大程度上是为了消除这一限制。VLSM将在本章后面进行描述*。'
- en: '![Custom subnet masks for Class C networks Since there are host ID bits in
    a Class C network address, there are six different ways that the network can be
    subnetted. Each corresponds to a different custom subnet mask, which is created
    by changing the allocated subnet ID bits from zero to one.](httpatomoreillycomsourcenostarchimages287819.png.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![C 类网络的自定义子网掩码 由于C类网络地址中有主机ID位，因此网络可以有六种不同的子网划分方式。每种方式对应一个不同的自定义子网掩码，这是通过将分配的子网ID位从零改为一来创建的。](httpatomoreillycomsourcenostarchimages287819.png.jpg)'
- en: Figure 18-5. Custom subnet masks for Class C networks Since there are host ID
    bits in a Class C network address, there are six different ways that the network
    can be subnetted. Each corresponds to a different custom subnet mask, which is
    created by changing the allocated subnet ID bits from zero to one.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18-5. C 类网络的自定义子网掩码 由于C类网络地址中有主机ID位，因此网络可以有六种不同的子网划分方式。每种方式对应一个不同的自定义子网掩码，这是通过将分配的子网ID位从零改为一来创建的。
- en: Subtracting Two from the Number of Hosts per Subnet and (Possibly) Subnets per
    Network
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从每个子网的主机数中减去两个，以及（可能）从每个网络中的子网数中减去两个
- en: 'You''ve seen how you must subtract two from the number of hosts allowed in
    each network in regular classful addressing. This is necessary because two host
    IDs in each subnet have special meanings: the all-zeros host ID (for "this network")
    and the all-ones host ID (for broadcasts to all hosts on the network). These restrictions
    apply to each subnet under subnetting, too, which is why you must continue to
    subtract two from the number of hosts per subnet. (This is also why dividing the
    eight host ID bits of a Class C network into seven bits for subnet ID and one
    bit for host ID is meaningless: It leaves 2¹–2 = 0 hosts per subnet, which is
    not particularly useful.)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了在常规的类地址中，你必须从每个网络允许的主机数中减去两个。这是必要的，因为每个子网中有两个主机ID有特殊含义：全零的主机ID（表示“此网络”）和全一的主机ID（表示向网络上的所有主机广播）。这些限制也适用于子网划分下的每个子网，这就是为什么你必须继续从每个子网的主机数中减去两个的原因。（这也是为什么将C类网络的八个主机ID位分为七个用于子网ID和一个用于主机ID是没有意义的：它留下了2¹–2
    = 0个主机每个子网，这并不特别有用。）
- en: A similar issue occurs with the subnet ID as well. When subnetting was originally
    defined in RFC 950, the standard specifically excluded the use of the all-zeros
    and all-ones subnets. This was due to concern that routers might become confused
    by these cases. A later standard, RFC 1812, "Requirements for IP Version 4 Routers,"
    removed this restriction in 1995\. Thus, modern hardware now has no problem with
    the all-zeros or all-ones subnets, but some very old hardware may still balk at
    it.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 子网ID也存在类似的问题。当最初在RFC 950中定义子网划分时，标准明确排除了使用全零和全一的子网。这是由于担心路由器可能会被这些情况弄混淆。后来的标准RFC
    1812，“IP版本4路由器的要求”，在1995年移除了这一限制。因此，现代硬件现在对全零或全一的子网没有问题，但一些非常旧的硬件可能仍然会对此表示抗拒。
- en: Tip
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The number of hosts allowed in each subnet is the binary power
    of the number of host ID bits remaining after subnetting, less two. The reduction
    by two occurs because the all-zeros and all-ones host IDs within each subnet are
    reserved for two special meaning addresses: to refer to the subnetwork itself
    and to refer to its local broadcast address. In some implementations, the number
    of subnets is also reduced by two because the all-zeros and all-ones subnet IDs
    were originally not allowed to be used.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个子网允许的主机数是子网划分后剩余的主机ID位数的二进制幂减去二。减去两个是因为每个子网内的全零和全一主机ID被保留用于两个特殊意义地址：指代子网本身和指代其本地广播地址。在某些实现中，子网的数量也减少了两个，因为最初不允许使用全零和全一的子网ID。'
- en: 'For this reason, you will sometimes see discussions of subnetting that exclude
    these cases. When that is done, you lose two potential subnets: the all-zeros
    and all-ones subnets. If you do this, then choosing one bit for subnet ID is no
    longer valid, as it yields 2¹–2=0 subnets. You must choose two bits if you need
    two subnets.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时你会看到排除这些情况的子网划分讨论。当这样做时，你会失去两个潜在的子网：全零和全一的子网。如果你这样做，那么选择一个位作为子网ID就不再有效，因为它会产生2¹–2=0个子网。如果你需要两个子网，你必须选择两个位。
- en: Note
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In this book, I assume you are dealing with modern hardware and do not exclude
    the all-zeros and all-ones subnets, but I do try to make explicit note of this
    fact wherever relevant. Summary tables later in this chapter show the trade-off
    in subnetting each of Classes A, B, and C, and the subnet mask for each of the
    choices*.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这本书中，我假设你正在处理现代硬件，不排除全零和全一的子网，但我确实会在相关的地方明确指出这一点。本章后面的总结表格显示了A、B和C类每个子网划分的权衡，以及每个选择的子网掩码*。'
- en: IP Subnet Identifiers, Subnet Addresses, and Host Addresses
  id: totrans-510
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网标识符、子网地址和主机地址
- en: 'The main advantage that conventional classful addressing without subnets offers
    over subnets is simplicity. For example, even though there can be problems with
    managing thousands of devices in a single Class B network, it is simple to assign
    addresses within the network: They are all lumped together, so any combination
    of bits can be used within the host ID (except for all-zeros and all-ones).'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 与子网相比，传统的不使用子网的类属地址的主要优势是简单性。例如，尽管在单个B类网络中管理数千个设备可能会有问题，但在网络内分配地址是简单的：它们都被合并在一起，所以可以在主机ID中使用任何位组合（除了全零和全一）。
- en: 'When you subnet, however, you create a two-level structure within the classful
    host ID: subnet ID and host ID. This means you must choose IP addresses for devices
    more carefully. In theory, you are selecting subnets to correspond to the physical
    networks within the organization, so you want to assign IP addresses in a way
    that is consistent with the physical network structure.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行子网划分时，然而，你会在类属主机ID内部创建一个两级结构：子网ID和主机ID。这意味着你必须更仔细地选择设备的IP地址。从理论上讲，你正在选择子网以对应组织内的物理网络，因此你希望以与物理网络结构一致的方式分配IP地址。
- en: Subnet Identifiers
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网标识符
- en: Once you decide how many subnets you will have, you need to identify the subnets
    and determine their addresses. You begin with the *subnet identifier*, the *subnet
    ID* of any subnets on our network. Subnets are numbered starting with zero and
    increasing up to one less than the maximum number of subnets, which is a function
    of how many bits are in the subnet ID. (If the all-zero and all-ones subnet IDs
    are excluded, as specified in RFC 950, then the first subnet ID is one.)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定将有多少个子网，你需要识别子网并确定它们的地址。你从*子网标识符*开始，即我们网络中任何子网的*子网ID*。子网从零开始编号，增加到小于最大子网数，这是子网ID中位数数的函数。（如果排除全零和全一的子网ID，如RFC
    950中指定，则第一个子网ID为1。）
- en: Of course, you may not need all of the subnets that can be defined. For example,
    if you have 20 subnets, you need five bits for the subnet identifier, which allows
    a theoretical maximum of 32 subnets. You would use only subnets 0 to 19; 20 through
    31 would be reserved for future use. These subnets could be expressed either in
    decimal form (0, 1, 2 … up to 19) or in binary (00000, 00001, 00010, and so on,
    up to 10011).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能不需要定义的所有子网。例如，如果你有20个子网，你需要五个位作为子网标识符，这允许理论上的最大32个子网。你将只使用子网0到19；20到31将被保留供将来使用。这些子网可以用十进制形式（0，1，2……直到19）或二进制形式（00000，00001，00010，等等，直到10011）表示。
- en: Subnet Addresses
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子网地址
- en: For each subnet, you can also determine the *subnet address*. To do this, you
    start with the IP address for the overall network, which has all zeros in the
    classful host ID field (8 bits, 16 bits, or 24 bits). You then insert the subnet
    ID for a particular subnet into the designated subnet bits.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个子网，你也可以确定其**子网地址**。为此，你需要从整个网络的IP地址开始，该地址在类别的主机ID字段中所有位都是零（8位、16位或24位）。然后，你将特定子网的子网ID插入指定的子网位中。
- en: 'For example, to subnet the Class B network 154.71.0.0 shown in [Figure 18-2](ch18s03.html#determining_the_subnet_mask_of_a_subnett
    "Figure 18-2. Determining the subnet mask of a subnetted network The Class B network
    from Figure 18-1 is shown at the top, with 5 bits assigned to the subnet ID and
    11 bits left for the host ID. To create the subnet mask, you fill in a 32-bit
    number with 1 for each network ID and subnet ID bit, and 0 for each host ID bit.
    You can then convert this to dotted decimal."), in which you use five subnet ID
    bits, you start with the following network IP address, with the subnet ID bits
    highlighted:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要子网化[图18-2](ch18s03.html#determining_the_subnet_mask_of_a_subnett "图18-2.
    确定子网掩码的子网化网络 图18-1中的B类网络显示在顶部，其中5位分配给子网ID，11位留给主机ID。要创建子网掩码，你用一个32位数填充，每个网络ID和子网ID位为1，每个主机ID位为0。然后你可以将其转换为点分十进制。")中显示的154.71.0.0的B类网络，其中你使用五个子网ID位，你从以下带有高亮显示的子网ID位的网络IP地址开始：
- en: '| 10011010 01000111 **00000**000 00000000 |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 10011010 01000111 **00000**000 00000000 |'
- en: 'To find the address of say, subnet 11, you substitute 01011 for these bits,
    leaving the host ID bits zero, as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到例如子网11的地址，你需要将这些位替换为01011，保留主机ID位为零，如下所示：
- en: '| 10011010 01000111 **01011**000 00000000 |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 10011010 01000111 **01011**000 00000000 |'
- en: You can then convert this from binary form to dotted decimal, resulting in a
    subnet address of 154.71.**88**.0.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将其从二进制形式转换为点分十进制，得到子网地址为154.71.**88**.0。
- en: Tip
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The subnet *identifier* of a subnet is just its subnet ID.
    The subnet address of a subnet is determined by substituting its subnet ID into
    the subnet bits of the overall network address.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 子网的**标识符**就是其子网ID。子网的子网地址是通过将子网ID替换到整个网络地址的子网位中确定的。'
- en: When you look at subnet addressing, especially when you substitute subnet IDs
    in sequence, a pattern becomes immediately visible. The first subnet address is
    always the address of the overall network, because the subnet ID is all zeros.
    Then you find the second subnet address in decimal form by adding a specific multiple
    of two to one of the octets. The third address is then found by adding this same
    number to the second address, and so on.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看子网寻址时，尤其是在按顺序替换子网ID时，一个模式会立即变得明显。第一个子网地址总是整个网络的地址，因为子网ID全部为零。然后，通过向一个八位字节添加一个特定的二倍数来找到十进制形式的第二个子网地址。然后，通过将这个相同的数字添加到第二个地址来找到第三个地址，依此类推。
- en: 'In fact, the decimal value of each subnet address can be expressed as a formula,
    based on the class of the original network and the number of bits being used for
    the subnet ID. For example, consider a Class B network with the overall address
    of x.y.0.0 (it doesn''t matter what x and y are for these purposes). Now say you
    are using two bits for the subnet ID. You have four subnet addresses here:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，每个子网地址的十进制值可以表示为一个公式，基于原始网络的类别和用于子网ID的位数。例如，考虑一个具有整体地址x.y.0.0的B类网络（对于这些目的，x和y是什么并不重要）。现在假设你使用两个位作为子网ID。这里有四个子网地址：
- en: 'The address of subnet 0 will be the same as the network address: x.y.0.0.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网0的地址将与网络地址相同：x.y.0.0。
- en: The address of subnet 1 will be found by substituting 01 for the first two bits
    of the third octet. This yields an address of x.y.01000000.0000000, or x.y.64.0
    in straight decimal.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网1的地址是通过将01替换为第三个八位字节的前两位来找到的。这产生了一个地址为x.y.01000000.0000000，或者说是x.y.64.0的纯十进制形式。
- en: Subnet 2's address is found by substituting 10 for the subnet ID bits, so it
    is x.y.10000000.0000000, or x.y.128.0 in straight decimal.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网2的地址是通过将10替换为子网ID位来找到的，因此它是x.y.10000000.0000000，或者说是x.y.128.0的纯十进制形式。
- en: Subnet 3's address will be x.y.192.0.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网3的地址将是x.y.192.0。
- en: So, the formula in this case for subnet *N* is x.y.*N*^*64.0\. If you use five
    bits for a subnet, the formula is x.y.*N*^*8.0\. As you saw earlier, the subnet
    address for subnet 11 in network 154.71.0.0 is 154.71.**88**.0\. I have shown
    the formulas for all of the combinations of subnet ID and host ID size in the
    subnetting summary tables (Tables [Table 18-3](ch18s07.html#subnetting_summary_table_for_class_a_net
    "Table 18-3. Subnetting Summary Table for Class A Networks"), [Table 18-4](ch18s07.html#subnetting_summary_table_for_class_b_net
    "Table 18-4. Subnetting Summary Table for Class B Networks"), and [Table 18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "Table 18-5. Subnetting Summary Table for Class C Networks")). These formulas
    can be a real time-saver once you become more familiar with subnetting.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，子网*N*的公式是x.y.*N*^*64.0\. 如果您为子网使用五个比特，公式是x.y.*N*^*8.0\. 正如您之前看到的，网络154.71.0.0中子网11的子网地址是154.71.**88**.0\.
    我已经在子网划分总结表中（表[Table 18-3](ch18s07.html#subnetting_summary_table_for_class_a_net
    "表18-3。A类网络子网划分总结表")，[Table 18-4](ch18s07.html#subnetting_summary_table_for_class_b_net
    "表18-4。B类网络子网划分总结表")，和[Table 18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "表18-5。C类网络子网划分总结表")）展示了所有子网ID和主机ID大小组合的公式。一旦您对子网划分更加熟悉，这些公式可以真正节省时间。
- en: Host Addresses Within Each Subnet
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个子网内的主机地址
- en: Once you know the subnet address for a particular subnet, you assign IP addresses
    by plugging in values into the remaining host ID bits. You skip the all-zeros
    value, so the first host in the subnet has all zeros for the host ID except for
    a one in the rightmost bit position. Then the next host has all zeros except for
    "10" at the end (2 in decimal). You can do this all the way up to one less than
    the all-ones value. Again, you then convert each IP address from binary to decimal.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您知道了特定子网的子网地址，您就可以通过将值插入剩余的主机ID比特中来分配IP地址。您跳过全零值，因此子网中的第一个主机的主机ID除了最右边的比特位置为1之外都是零。然后下一个主机除了末尾的"10"（十进制中的2）之外都是零。您可以一直做到全一的值之前的一个值。同样，然后您将每个IP地址从二进制转换为十进制。
- en: Note
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can find exactly these details in [Chapter 19](ch19.html "Chapter 19. IP
    SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE")''s coverage
    of practical subnetting*.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*您可以在第19章[实际子网划分](ch19.html "第19章。实际子网划分与地址确定示例")的覆盖中找到这些详细信息*。'
- en: IP Subnetting Summary Tables for Class A, Class B, and Class C Networks
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A类、B类和C类网络的IP子网划分总结表
- en: Since there are only a few options for how to subnet Class A, Class B, and Class
    C networks, I list the options for each class in summary Tables [Table 18-3](ch18s07.html#subnetting_summary_table_for_class_a_net
    "Table 18-3. Subnetting Summary Table for Class A Networks") through [Table 18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "Table 18-5. Subnetting Summary Table for Class C Networks"). These tables can
    help you quickly decide how many bits to use for subnet ID and host ID, and then
    what the subnet mask is for their selection. They also summarize nicely what I've
    discussed so far in this chapter.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 由于A类、B类和C类网络的子网划分选项有限，我在总结表[Table 18-3](ch18s07.html#subnetting_summary_table_for_class_a_net
    "表18-3。A类网络子网划分总结表")到[Table 18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "表18-5。C类网络子网划分总结表")中列出了每个类别的选项。这些表格可以帮助您快速决定子网ID和主机ID应使用多少比特，以及选择它们的子网掩码是什么。它们还很好地总结了本章到目前为止我所讨论的内容。
- en: Each row of each table shows one possible subnetting option for that class,
    including the number of bits for each of the subnet ID and host ID, and the number
    of subnets and hosts based on the number of bits. I then show the subnet mask
    in binary and decimal form, as well as in CIDR notation (covered in [Chapter 20](ch20.html
    "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING")).
    Finally, I include the formula for calculating the addresses for each subnet under
    each of the options.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表格的每一行显示了该类的一个可能的子网划分选项，包括子网ID和主机ID的比特数，以及基于比特数的子网和主机数量。然后我展示了子网掩码的二进制和十进制形式，以及CIDR表示法（在第20章[无类别IP地址——无类别域间路由（CIDR）/超网](ch20.html
    "第20章。无类别IP地址——无类别域间路由（CIDR）/超网")中介绍）。最后，我包括了每个选项下计算每个子网地址的公式。
- en: 'A few additional explanatory notes are in order regarding these tables:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些表格，有一些额外的解释性说明是必要的：
- en: The values for the number of subnets per network assume that the all-zeros and
    all-ones subnets are allowed. If not, you must subtract two from those figures.
    This also means that the option using only one bit for the subnet ID becomes invalid,
    and the subnet address formulas no longer work as shown.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个网络中子网数目的值假设允许全零和全一子网。如果不允许，则必须从这些数字中减去两个。这也意味着仅使用一个比特位用于子网ID的选项变得无效，子网地址公式也不再按所示工作。
- en: The number of hosts per subnet excludes the all-zeros and all-ones cases, so
    it is two to the power of the number of host ID bits, less two.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子网的主机数不包括全零和全一的情况，因此是主机ID比特数的2的幂次，减去2。
- en: The first row of each table shows the default case where the number of subnet
    bits is zero, and thus the subnet mask is the default subnet mask for the class.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表格的第一行显示了默认情况，其中子网位数为零，因此子网掩码是类默认子网掩码。
- en: In the subnet mask for all options but the default, I have highlighted the portion
    of the subnet mask corresponding to the subnet ID, for clarity. This has been
    done for each individual bit of the binary mask, and for each octet in the dotted
    decimal representation of the mask where part of the subnet ID is found.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有选项的子网掩码中，除了默认选项外，我都突出了对应于子网ID的子网掩码部分，以增强清晰度。这已经针对二进制掩码的每个单独比特位以及掩码的点分十进制表示中的每个八位字节（其中包含子网ID的一部分）进行了操作。
- en: In looking at these tables, you will see that not all of the divisions make
    a great deal of sense in the real world, though you might be surprised. For example,
    at first glance, it seems silly to think that you might want to assign 14 bits
    of a Class B host ID to the subnet ID and leave 2 bits for the host ID—what sort
    of real network has 16,384 subnets with two hosts on each? Yet, some larger Internet
    service companies may indeed require thousands of tiny subnets when setting up
    connections between routers or between their core network and their customers.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查看这些表格时，你会发现并非所有的划分在现实世界中都有很大的意义，尽管你可能感到惊讶。例如，乍一看，认为你可能想要将类B主机ID的14位分配给子网ID，并留下2位用于主机ID似乎很荒谬——什么样的真实网络会有16,384个子网，每个子网有两个主机？然而，一些大型互联网服务公司确实在设置路由器之间的连接或其核心网络与客户之间的连接时可能需要成千上万的微小子网。
- en: The subnet address formulas in the last column of each table show the address
    for subnet *N* (numbering from zero up to one less than the maximum number of
    subnets). See the end of step 4 in the step-by-step subnetting discussion ([Chapter 19](ch19.html
    "Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE"))
    for a full explanation of how these formulas work.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表格最后一列的子网地址公式显示了子网*N*（从零开始编号，到最大子网数减一）的地址。请参阅逐步子网划分讨论的步骤4的结尾（[第19章](ch19.html
    "第19章. IP子网划分 实践子网设计和地址确定示例"））以了解这些公式的完整解释。
- en: Table 18-3. Subnetting Summary Table for Class A Networks
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-3. 类A网络子网划分摘要表
- en: '| # of Subnet ID Bits | # of Host ID Bits | # of Subnets per Network | # of
    Hosts per Subnet | Subnet Mask (Binary/Dotted Decimal) | Subnet Mask (Slash/ CIDR
    Notation) | Subnet Address #N Formula (N=0, 1, # of Subnets -1) |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: 子网ID比特数 | 主机ID比特数 | 每个网络中的子网数 | 每个子网的主机数 | 子网掩码（二进制/点分十进制） | 子网掩码（斜线/ CIDR表示法）
    | 子网地址#N公式（N=0，1，子网数-1） |
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0 (Default)** | **24** | 1 | 16,277,214 | 11111111.00000000.00000000.00000000255.0.0.0
    | /8 | — |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| **0 (默认)** | **24** | 1 | 16,277,214 | 11111111.00000000.00000000.00000000255.0.0.0
    | /8 | — |'
- en: '| **1** | **23** | 2 | 8,388,606 | 11111111.**1**0000000.00000000.00000000255.**128**.0.0
    | /9 | x.N*128.0.0 |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| **1** | **23** | 2 | 8,388,606 | 11111111.**1**0000000.00000000.00000000255.**128**.0.0
    | /9 | x.N*128.0.0 |'
- en: '| **2** | **22** | 4 | 4,194,302 | 11111111.**11**000000.00000000.00000000255.**192**.0.0
    | /10 | x.N*64.0.0 |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| **2** | **22** | 4 | 4,194,302 | 11111111.**111**000000.00000000.00000000255.**192**.0.0
    | /10 | x.N*64.0.0 |'
- en: '| **3** | **21** | 8 | 2,097,150 | 11111111.**111**00000.00000000.00000000255.**224**.0.0
    | /11 | x.N*32.0.0 |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| **3** | **21** | 8 | 2,097,150 | 11111111.**111**00000.00000000.00000000255.**224**.0.0
    | /11 | x.N*32.0.0 |'
- en: '| **4** | **20** | 16 | 1,048,574 | 11111111.**1111**0000.00000000.00000000255.**240**.0.0
    | /12 | x.N*16.0.0 |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| **4** | **20** | 16 | 1,048,574 | 11111111.**1111**0000.00000000.00000000255.**240**.0.0
    | /12 | x.N*16.0.0 |'
- en: '| **5** | **19** | 32 | 524,286 | 11111111.**11111**000.00000000.00000000255.**248**.0.0
    | /13 | x.N*8.0.0 |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| **5** | **19** | 32 | 524,286 | 11111111.**11111**000.00000000.00000000255.**248**.0.0
    | /13 | x.N*8.0.0 |'
- en: '| **6** | **18** | 64 | 262,142 | 11111111.**111111**00.00000000.00000000255.**252**.0.0
    | /14 | x.N*4.0.0 |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| **6** | **18** | 64 | 262,142 | 11111111.**111111**00.00000000.00000000255.**252**.0.0
    | /14 | x.N*4.0.0 |'
- en: '| **7** | **17** | 128 | 131,070 | 11111111.**1111111**0.00000000.00000000255.**254**.0.0
    | /15 | x.N*2.0.0 |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| **7** | **17** | 128 | 131,070 | 11111111.1111111**0.00000000.00000000255.**254**.0.0
    | /15 | x.N*2.0.0 |'
- en: '| **8** | **16** | 256 | 65,534 | 11111111.**11111111**.00000000.00000000255.**255**.0.0
    | /16 | x.N.0.0 |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| **8** | **16** | 256 | 65,534 | 11111111.11111111.00000000.00000000255.**255**.0.0
    | /16 | x.N.0.0 |'
- en: '| **9** | **15** | 512 | 32,766 | 11111111.**11111111**.10000000.00000000255.**255.128**.0
    | /17 | x.N/2.(N%2)*128.0 |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| **9** | **15** | 512 | 32,766 | 11111111.11111111.10000000.00000000255.**255.128**.0
    | /17 | x.N/2.(N%2)*128.0 |'
- en: '| **10** | **14** | 1,024 | 16,382 | 11111111.**11111111**.11000000.00000000255.**255.192**.0
    | /18 | x.N/4.(N%4)*64.0 |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| **10** | **14** | 1,024 | 16,382 | 11111111.11111111.11000000.00000000255.**255.192**.0
    | /18 | x.N/4.(N%4)*64.0 |'
- en: '| **11** | **13** | 2,048 | 8,190 | 11111111.**11111111**.11100000.00000000255.**255.224**.0
    | /19 | x.N/8.(N%8)*32.0 |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| **11** | **13** | 2,048 | 8,190 | 11111111.11111111.11100000.00000000255.**255.224**.0
    | /19 | x.N/8.(N%8)*32.0 |'
- en: '| **12** | **12** | 4,096 | 4,094 | 11111111.**11111111**.**1111**0000.00000000255.**255.240**.0
    | /20 | x.N/16.(N%16)*16.0 |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| **12** | **12** | 4,096 | 4,094 | 11111111.11111111.**1111**0000.00000000255.**255.240**.0
    | /20 | x.N/16.(N%16)*16.0 |'
- en: '| **13** | **11** | 8,192 | 2,046 | 11111111.**11111111**.**11111**000.00000000255.**255.248**.0
    | /21 | x.N/32.(N%32)*8.0 |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| **13** | **11** | 8,192 | 2,046 | 11111111.11111111.**11111**000.00000000255.**255.248**.0
    | /21 | x.N/32.(N%32)*8.0 |'
- en: '| **14** | **10** | 16,384 | 1,022 | 11111111.**11111111**.**111111**00.00000000255.**255.252**.0
    | /22 | x.N/64.(N%64)*4.0 |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| **14** | **10** | 16,384 | 1,022 | 11111111.11111111.**111111**00.00000000255.**255.252**.0
    | /22 | x.N/64.(N%64)*4.0 |'
- en: '| **15** | **9** | 32,768 | 510 | 11111111.**11111111**.**1111111**0.00000000255.**255.254**.0
    | /23 | x.N/128.(N%128)*2.0 |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| **15** | **9** | 32,768 | 510 | 11111111.11111111.**1111111**0.00000000255.**255.254**.0
    | /23 | x.N/128.(N%128)*2.0 |'
- en: '| **16** | **8** | 65,536 | 254 | 11111111.**11111111**.**11111111**.00000000255.**255.255**.0
    | /24 | x.N/256.N%256.0 |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| **16** | **8** | 65,536 | 254 | 11111111.11111111.**11111111**.00000000255.**255.255**.0
    | /24 | x.N/256.N%256.0 |'
- en: '| **17** | **7** | 131,072 | 126 | 11111111.**11111111**.**11111111**.**1**0000000255.**255.255.128**
    | /25 | x.N/512.(N/2)%256.(N%2)*128 |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| **17** | **7** | 131,072 | 126 | 11111111.11111111.**11111111**.**1**0000000255.**255.255.128**
    | /25 | x.N/512.(N/2)%256.(N%2)*128 |'
- en: '| **18** | **6** | 262,144 | 62 | 11111111.**11111111**.**11111111**.**11**000000255.**255.255.192**
    | /26 | x.N/1024.(N/4)%256.(N%4)*64 |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| **18** | **6** | 262,144 | 62 | 11111111.11111111.11111111.**11**000000255.**255.255.192**
    | /26 | x.N/1024.(N/4)%256.(N%4)*64 |'
- en: '| **19** | **5** | 524,288 | 30 | 11111111.**11111111**.**11111111**.**111**00000255.**255.255.224**
    | /27 | x.N/2048.(N/8)%256.(N%8)*32 |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| **19** | **5** | 524,288 | 30 | 11111111.11111111.**11111111**.**111**00000255.**255.255.224**
    | /27 | x.N/2048.(N/8)%256.(N%8)*32 |'
- en: '| **20** | **4** | 1,048,576 | 14 | 11111111.**11111111**.**11111111**.**1111**0000255.**255.255.240**
    | /28 | x.N/4096.(N/16)%256.(N%16)*16 |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| **20** | **4** | 1,048,576 | 14 | 11111111.11111111.**11111111**.**1111**0000255.**255.255.240**
    | /28 | x.N/4096.(N/16)%256.(N%16)*16 |'
- en: '| **21** | **3** | 2,097,152 | 6 | 11111111.**11111111**.**11111111**.**11111**000255.**255.255.248**
    | /29 | x.N/8192.(N/32)%256.(N%32)*8 |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| **21** | **3** | 2,097,152 | 6 | 11111111.11111111.**11111111**.**11111**000255.**255.255.248**
    | /29 | x.N/8192.(N/32)%256.(N%32)*8 |'
- en: '| **22** | **2** | 4,194,304 | 2 | 11111111.**11111111**.**11111111**.**111111**00255.**255.255.252**
    | /30 | x.N/16384.(N/64)%256.(N%64)*4 |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| **22** | **2** | 4,194,304 | 2 | 11111111.11111111.**11111111**.**111111**00255.**255.255.252**
    | /30 | x.N/16384.(N/64)%256.(N%64)*4 |'
- en: Table 18-4. Subnetting Summary Table for Class B Networks
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Table 18-4. 子网划分汇总表，适用于B类网络
- en: '| # of Subnet ID Bit | # of Host ID Bits | # of Subnets per Network | # of
    Hosts per Subnet | Subnet Mask (Binary/Dotted Decimal) | Subnet Mask (Slash/ CIDR
    Notation) | Subnet Address #N Formula (N=0, 1, # of Subnets -1) |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 子网ID位数 | 主机ID位数 | 每个网络中的子网数量 | 每个子网中的主机数量 | 子网掩码（二进制/点分十进制） | 子网掩码（斜杠/ CIDR表示法）
    | 子网地址#N公式（N=0, 1, 子网数量-1） |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 (Default) | 16 | 1 | 65,534 | 11111111.11111111.00000000.00000000255.255.0.0
    | /16 | - |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 0 (默认) | 16 | 1 | 65,534 | 11111111.11111111.00000000.00000000255.255.0.0
    | /16 | - |'
- en: '| 1 | 15 | 2 | 32,766 | 11111111.11111111.10000000.00000000255.255.**128**.0
    | /17 | x.y.N*128.0 |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 15 | 2 | 32,766 | 11111111.11111111.10000000.00000000255.255.**128**.0
    | /17 | x.y.N*128.0 |'
- en: '| 2 | 14 | 4 | 16,382 | 11111111.11111111.**11**000000.00000000255.255.**192**.0
    | /18 | x.y.N*64.0 |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 14 | 4 | 16,382 | 11111111.11111111.**11**000000.00000000255.255.**192**.0
    | /18 | x.y.N*64.0 |'
- en: '| 3 | 13 | 8 | 8,190 | 11111111.11111111.**111**00000.00000000255.255.**224**.0
    | /19 | x.y.N*32.0 |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 13 | 8 | 8,190 | 11111111.11111111.**111**00000.00000000255.255.**224**.0
    | /19 | x.y.N*32.0 |'
- en: '| 4 | 12 | 16 | 4,094 | 11111111.11111111.**1111**0000.00000000255.255.**240**.0
    | /20 | x.y.N*16.0 |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 12 | 16 | 4,094 | 11111111.11111111.**1111**0000.00000000255.255.**240**.0
    | /20 | x.y.N*16.0 |'
- en: '| 5 | 11 | 32 | 2,046 | 11111111.11111111.**11111**000.00000000255.255.**248**.0
    | /21 | x.y.N*8.0 |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 11 | 32 | 2,046 | 11111111.11111111.**11111**000.00000000255.255.**248**.0
    | /21 | x.y.N*8.0 |'
- en: '| 6 | 10 | 64 | 1,022 | 11111111.11111111.**111111**00.00000000255.255.**252**.0
    | /22 | x.y.N*4.0 |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 10 | 64 | 1,022 | 11111111.11111111.**111111**00.00000000255.255.**252**.0
    | /22 | x.y.N*4.0 |'
- en: '| 7 | 9 | 128 | 510 | 11111111.11111111.**1111111**0.00000000255.255.**254**.0
    | /23 | x.y.N*2.0 |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 9 | 128 | 510 | 11111111.11111111.**1111111**0.00000000255.255.**254**.0
    | /23 | x.y.N*2.0 |'
- en: '| 8 | 8 | 256 | 254 | 11111111.11111111.**11111111**.00000000255.255.**255**.0
    | /24 | x.y.N.0 |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 8 | 256 | 254 | 11111111.11111111.**11111111**.00000000255.255.**255**.0
    | /24 | x.y.N.0 |'
- en: '| 9 | 7 | 512 | 126 | 11111111.11111111.**11111111**.**1**0000000255.255.**255.128**
    | /25 | x.y.N/2.(N%2)*128 |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 7 | 512 | 126 | 11111111.11111111.**11111111**.**1**0000000255.255.**255.128**
    | /25 | x.y.N/2.(N%2)*128 |'
- en: '| 10 | 6 | 1,024 | 62 | 11111111.11111111.**11111111**.**11**000000255.255.**255.192**
    | /26 | x.y.N/4.(N%4)*64 |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 6 | 1,024 | 62 | 11111111.11111111.**11111111**.**11**000000255.255.**255.192**
    | /26 | x.y.N/4.(N%4)*64 |'
- en: '| 11 | 5 | 2,048 | 30 | 11111111.11111111.**11111111**.**111**00000255.255.**255.224**
    | /27 | x.x.N/8.(N%8)*32 |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 5 | 2,048 | 30 | 11111111.11111111.**11111111**.**111**00000255.255.**255.224**
    | /27 | x.x.N/8.(N%8)*32 |'
- en: '| 12 | 4 | 4,096 | 14 | 11111111.11111111.**11111111.1111**0000255.255.**255.240**
    | /28 | x.y.N/16.(N%16)*16 |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4 | 4,096 | 14 | 11111111.11111111.**11111111.1111**0000255.255.**255.240**
    | /28 | x.y.N/16.(N%16)*16 |'
- en: '| 13 | 3 | 8,192 | 6 | 11111111.11111111.**11111111.11111**000255.255.**255.248**
    | /29 | x.y.N/32.(N%32)*8 |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 3 | 8,192 | 6 | 11111111.11111111.**11111111.11111**000255.255.**255.248**
    | /29 | x.y.N/32.(N%32)*8 |'
- en: '| 14 | 2 | 16,384 | 2 | 11111111.11111111.**11111111.111111**00255.255.**255.252**
    | /30 | x.y.N/64.(N%64)*4 |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 2 | 16,384 | 2 | 11111111.11111111.**11111111.111111**00255.255.**255.252**
    | /30 | x.y.N/64.(N%64)*4 |'
- en: Table 18-5. Subnetting Summary Table for Class C Networks
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-5. C类网络的子网划分汇总表
- en: '| # of Subnet ID Bit | # of Host ID Bits | # of Subnets per Network | # of
    Hosts per Subnet | Subnet Mask (Binary/Dotted Decimal) | Subnet Mask (Slash/ CIDR
    Notation) | Subnet Address #N Formula (N=0, 1, # of Subnets-1) |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 子网ID位数 | 主机ID位数 | 每个网络中的子网数 | 每个子网中的主机数 | 子网掩码（二进制/点分十进制） | 子网掩码（斜杠/ CIDR表示法）
    | 子网地址#N公式（N=0, 1, 子网数-1） |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 (Default) | 8 | 1 | 254 | 11111111.11111111.11111111.00000000255.255.255.0
    | /24 | — |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 0 (默认) | 8 | 1 | 254 | 11111111.11111111.11111111.00000000255.255.255.0 |
    /24 | — |'
- en: '| 1 | 7 | 2 | 126 | 11111111.11111111.11111111.**1**0000000255.255.255.**128**
    | /25 | x.y.z.N*128 |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 7 | 2 | 126 | 11111111.11111111.11111111.**1**0000000255.255.255.**128**
    | /25 | x.y.z.N*128 |'
- en: '| 2 | 6 | 4 | 62 | 11111111.11111111 .11111111.**11**000000255.255.255.**192**
    | /26 | x.y.z.N*64 |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 6 | 4 | 62 | 11111111.11111111 .11111111.**11**000000255.255.255.**192**
    | /26 | x.y.z.N*64 |'
- en: '| 3 | 5 | 8 | 30 | 11111111.11111111.11111111.**111**00000255.255.255.**224**
    | /27 | x.y.z.N*32 |'
  id: totrans-596
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 5 | 8 | 30 | 11111111.11111111.11111111.**111**00000255.255.255.**224**
    | /27 | x.y.z.N*32 |'
- en: '| 4 | 4 | 16 | 14 | 11111111.11111111.11111111.**11110**000255.255.255.**240**
    | /28 | x.y.z.N*16 |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 4 | 16 | 14 | 11111111.11111111.11111111.**11110**000255.255.255.**240**
    | /28 | x.y.z.N*16 |'
- en: '| 5 | 3 | 32 | 6 | 11111111.11111111.11111111.**11111**000255.255.255.**248**
    | /29 | x.y.z.N*8 |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 3 | 32 | 6 | 11111111.11111111.11111111.**11111**000255.255.255.**248**
    | /29 | x.y.z.N*8 |'
- en: '| 6 | 2 | 64 | 2 | 11111111.11111111.11111111.**111111**00255.255.255.**252**
    | /30 | x.y.z.N*4 |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 2 | 64 | 2 | 11111111.11111111.11111111.**111111**00255.255.255.**252**
    | /30 | x.y.z.N*4 |'
- en: IP Variable Length Subnet Masking (VLSM)
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP可变长度子网掩码（VLSM）
- en: The main weakness with conventional subnetting is that the subnet ID represents
    only *one* additional hierarchical level in how IP addresses are interpreted and
    used for routing.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 传统子网划分的主要弱点在于子网ID仅代表IP地址解释和使用路由中的**一个**额外的层次级别。
- en: It may seem greedy to look at subnetting and say, "What, only *one* additional
    level?" However, in large networks, the need to divide the entire network into
    only one level of subnetworks doesn't represent the best use of the IP address
    block.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来贪婪地看待子网划分并说，“什么，只有**一个**额外的级别？”然而，在大型网络中，将整个网络仅划分为一个级别的子网并不代表IP地址块的最佳使用。
- en: Furthermore, you have already seen that since the subnet ID is the same length
    throughout the network, you can have problems if you have subnetworks with very
    different numbers of hosts on them. The subnet ID must be chosen based on whichever
    subnet has the greatest number of hosts, even if most of subnets have far fewer.
    This is inefficient even in small networks, and can result in the need to use
    extra addressing blocks while wasting many of the addresses in each block.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您已经看到，由于子网ID在整个网络中长度相同，如果您有子网数量差异很大的子网，可能会出现问题。子网ID必须根据具有最大主机数的子网来选择，即使大多数子网的主机数要少得多。即使在小型网络中，这也可能是不高效的，并且可能导致需要使用额外的地址块，同时浪费每个块中的许多地址。
- en: For example, consider a relatively small company with a Class C network, 201.45.222.0/24\.
    The administrators have six subnetworks in their network. The first four subnets
    (S1, S2, S3, and S4) are relatively small, containing only 10 hosts each. However,
    one of them (S5) is for their production floor and has 50 hosts, and the last
    (S6) is their development and engineering group, which has 100 hosts. The total
    number of hosts needed is thus 196.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个相对较小的公司，拥有一个C类网络，201.45.222.0/24。管理员在其网络中有六个子网。前四个子网（S1、S2、S3和S4）相对较小，每个子网只包含10个主机。然而，其中一个（S5）是为他们的生产线而设，有50个主机，最后一个（S6）是他们的开发和工程团队，有100个主机。因此，所需的总主机数为196。
- en: Without subnetting, the company has enough hosts in the Class C network to handle
    them all. However, when they try to subnet, they have a big problem. In order
    to have six subnets, they need to use three bits for the subnet ID. This leaves
    only five bits for the host ID, which means every subnet has the identical capacity
    of 30 hosts, as shown in [Figure 18-6](ch18s08.html#class_c_24_network_split_into_eight_conv
    "Figure 18-6. Class C (/24) network split into eight conventional subnets With
    traditional subnetting, all subnets must be the same size, which creates problems
    when there are some subnets that are much larger than others. Contrast this with
    Figure 18-7."). This is enough for the smaller subnets but not enough for the
    larger ones. The only solution with conventional subnetting, other than shuffling
    the physical subnets, is to get another Class C block for the two big subnets
    and use the original for the four small ones. But this is expensive and means
    wasting hundreds of IP addresses!
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有子网划分的情况下，公司在其C类网络中有足够的主机来处理它们。然而，当他们尝试进行子网划分时，他们会遇到一个大问题。为了拥有六个子网，他们需要使用三个位来表示子网ID。这仅留下五个位用于主机ID，这意味着每个子网都有相同的容量，即30个主机，如[图18-6](ch18s08.html#class_c_24_network_split_into_eight_conv
    "图18-6。C类（/24）网络划分为八个传统子网。使用传统子网划分，所有子网必须具有相同的大小，当某些子网的大小远大于其他子网时，这会引发问题。与此相对比图18-7。")所示。这对于较小的子网来说是足够的，但对于较大的子网来说则不够。除了重新排列物理子网之外，使用传统子网划分的唯一解决方案是为两个大子网获取另一个C类地址块，并使用原始的地址块来处理四个小子网。但这很昂贵，意味着浪费了数百个IP地址！
- en: '![Class C (/24) network split into eight conventional subnets With traditional
    subnetting, all subnets must be the same size, which creates problems when there
    are some subnets that are much larger than others. Contrast this with .](httpatomoreillycomsourcenostarchimages287821.png.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![C类（/24）网络划分为八个传统子网。使用传统子网划分，所有子网必须具有相同的大小，当某些子网的大小远大于其他子网时，这会引发问题。与此相对比。](httpatomoreillycomsourcenostarchimages287821.png.jpg)'
- en: Figure 18-6. Class C (/24) network split into eight conventional subnets With
    traditional subnetting, all subnets must be the same size, which creates problems
    when there are some subnets that are much larger than others. Contrast this with
    [Figure 18-7](ch18s08.html#class_c_24_network_split_using_vlsm_usin "Figure 18-7. Class
    C (/24) network split using VLSM Using VLSM, an organization can divide its IP
    network multiple times to create subnets that match the size requirements of its
    physical networks much better. Contrast this with Figure 18-6.").
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-6。C类（/24）网络划分为八个传统子网。使用传统子网划分，所有子网必须具有相同的大小，当某些子网的大小远大于其他子网时，这会引发问题。与此相对比[图18-7](ch18s08.html#class_c_24_network_split_using_vlsm_usin
    "图18-7。C类（/24）网络使用VLSM划分。使用VLSM，组织可以将其IP网络多次划分，以创建更符合其物理网络大小要求的子网。与此相对比图18-6。")。
- en: 'The Solution: Variable Length Subnet Masking'
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案：可变长度子网掩码
- en: The solution is an enhancement to the basic subnet addressing scheme called
    *Variable Length Subnet Masking (VLSM)*. The idea is that you subnet the network
    and then subnet the subnets just the way you originally subnetted the network.
    In fact, you can do this multiple times, creating subnets of subnets of subnets,
    as many times as you need (subject to how many bits you have in the host ID of
    your address block).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是对基本子网寻址方案的一种增强，称为*可变长度子网掩码（VLSM）*。其理念是，你首先对网络进行子网划分，然后对子网进行子网划分，就像你最初对网络进行子网划分一样。实际上，你可以多次这样做，创建子网中的子网网段，次数取决于你的地址块中主机ID的位数。
- en: It is possible to choose to apply this multiple-level splitting to only some
    of the subnets, thereby allowing you to selectively cut the IP address pie so
    that some of the slices are bigger than others. This means that the company in
    the previous example could create six subnets to match the needs of its networks,
    as shown in [Figure 18-7](ch18s08.html#class_c_24_network_split_using_vlsm_usin
    "Figure 18-7. Class C (/24) network split using VLSM Using VLSM, an organization
    can divide its IP network multiple times to create subnets that match the size
    requirements of its physical networks much better. Contrast this with Figure 18-6.").
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择将这种多级分割仅应用于某些子网，从而允许您有选择地切割IP地址块，使得一些块比其他块大。这意味着在先前的例子中，公司可以创建六个子网来满足其网络的需求，如图[图18-7](ch18s08.html#class_c_24_network_split_using_vlsm_usin
    "图18-7. 使用VLSM对C类(/24)网络进行分割。使用VLSM，一个组织可以多次将其IP网络分割成与其实际网络大小要求更匹配的子网。与图18-6进行比较。")所示。
- en: '![Class C (/24) network split using VLSM Using VLSM, an organization can divide
    its IP network multiple times to create subnets that match the size requirements
    of its physical networks much better. Contrast this with .](httpatomoreillycomsourcenostarchimages287823.png.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![C类(/24)网络使用VLSM进行分割。使用VLSM，一个组织可以多次将其IP网络分割成与其实际网络大小要求更匹配的子网。与进行比较。](httpatomoreillycomsourcenostarchimages287823.png.jpg)'
- en: Figure 18-7. Class C (/24) network split using VLSM Using VLSM, an organization
    can divide its IP network multiple times to create subnets that match the size
    requirements of its physical networks much better. Contrast this with [Figure 18-6](ch18s08.html#class_c_24_network_split_into_eight_conv
    "Figure 18-6. Class C (/24) network split into eight conventional subnets With
    traditional subnetting, all subnets must be the same size, which creates problems
    when there are some subnets that are much larger than others. Contrast this with
    Figure 18-7.").
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-7. 使用VLSM对C类(/24)网络进行分割。使用VLSM，一个组织可以多次将其IP网络分割成与其实际网络大小要求更匹配的子网。与[图18-6](ch18s08.html#class_c_24_network_split_into_eight_conv
    "图18-6. 将C类(/24)网络分割成八个传统子网。在传统子网划分中，所有子网必须具有相同的大小，当某些子网比其他子网大得多时，这会引发问题。与图18-7进行比较。")。
- en: Tip
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Variable Length Subnet Masking (VLSM)* is a technique for
    which subnetting is performed multiple times in iteration to allow a network to
    be divided into a hierarchy of subnetworks that vary in size. This allows an organization
    to better match the size of its subnets to the requirements of its networks.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *可变长度子网掩码（VLSM）* 是一种技术，通过迭代多次进行子网划分，允许网络被划分为大小不同的子网层次结构。这使得组织能够更好地匹配其子网的大小以满足其网络的需求。'
- en: Multiple-Level Subnetting Using VLSM
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VLSM进行多级子网划分
- en: VLSM subnetting is done the same way as regular subnetting; it just involves
    extra levels of subnetting hierarchy. To implement it, you first subnet the network
    into large subnets and then further break down one or more of the subnets as required.
    You add bits to the subnet mask for each of the sub-subnets and sub-sub-subnets
    to reflect their smaller size.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: VLSM子网划分与常规子网划分的方式相同；它只是涉及额外的子网划分层次级别。要实现它，您首先将网络划分为大型子网，然后根据需要进一步分解一个或多个子网。您为每个次子网和次次子网添加位到子网掩码，以反映它们较小的尺寸。
- en: In VLSM, the slash notation of classless addressing is commonly used instead
    of binary subnet masks (it works very much like CIDR), so that's what I will use.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在VLSM中，通常使用无类别地址的斜线表示法而不是二进制子网掩码（它的工作方式非常类似于CIDR），因此我将使用这种方法。
- en: Note
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you''re feeling a bit uncomfortable with how subnetting works, consider
    reading the chapter on practical subnetting ([Chapter 19](ch19.html "Chapter 19. IP
    SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE")) before
    proceeding with the VLSM example that follows*.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您对子网划分的工作方式感到有些不舒服，在继续进行下面的VLSM示例之前，请考虑阅读关于实际子网划分的章节([第19章](ch19.html "第19章。IP子网划分
    实际子网设计及地址确定示例"))*。'
- en: For example, consider the class C network, 201.45.222.0/24\. You do three subnettings
    as follows (see [Figure 18-8](ch18s08.html#vlsm_example_this_diagram_illustrates_th
    "Figure 18-8. VLSM example This diagram illustrates the example described in the
    text, of a Class C (/24) network divided using three hierarchical levels. It is
    first divided into two subnets; one subnet is divided into two sub-subnets; and
    one sub-subnet is divided into four sub-sub-subnets. The resulting six subnets,
    shown with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14,
    and 14 hosts.") for an illustration of the process).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑C类网络，201.45.222.0/24。您按照以下方式执行三次子网划分（参见[图18-8](ch18s08.html#vlsm_example_this_diagram_illustrates_th
    "图18-8. VLSM示例 此图展示了文本中描述的示例，即一个使用三个分层级别划分的C类（/24）网络。它首先被划分为两个子网；其中一个子网被划分为两个二级子网；而一个二级子网被划分为四个三级子网。结果显示的六个子网，用粗黑边框表示，最大容量分别为126、62、14、14、14和14个主机。")以展示过程）。
- en: '![VLSM example This diagram illustrates the example described in the text,
    of a Class C (/24) network divided using three hierarchical levels. It is first
    divided into two subnets; one subnet is divided into two sub-subnets; and one
    sub-subnet is divided into four sub-sub-subnets. The resulting six subnets, shown
    with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14, and
    14 hosts.](httpatomoreillycomsourcenostarchimages287825.png.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![VLSM示例 此图展示了文本中描述的示例，即一个使用三个分层级别划分的C类（/24）网络。它首先被划分为两个子网；其中一个子网被划分为两个二级子网；而一个二级子网被划分为四个三级子网。结果显示的六个子网，用粗黑边框表示，最大容量分别为126、62、14、14、14和14个主机。](httpatomoreillycomsourcenostarchimages287825.png.jpg)'
- en: Figure 18-8. VLSM example This diagram illustrates the example described in
    the text, of a Class C (/24) network divided using three hierarchical levels.
    It is first divided into two subnets; one subnet is divided into two sub-subnets;
    and one sub-subnet is divided into four sub-sub-subnets. The resulting six subnets,
    shown with thick black borders, have a maximum capacity of 126, 62, 14, 14, 14,
    and 14 hosts.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 图18-8. VLSM示例 此图展示了文本中描述的示例，即一个使用三个分层级别划分的C类（/24）网络。它首先被划分为两个子网；其中一个子网被划分为两个二级子网；而一个二级子网被划分为四个三级子网。结果显示的六个子网，用粗黑边框表示，最大容量分别为126、62、14、14、14和14个主机。
- en: 'You first do an initial subnetting by using one bit for the subnet ID, leaving
    you seven bits for the host ID and two subnets: 201.45.222.0/25 and 201.45.222.128/25\.
    Each of these can have a maximum of 126 hosts. You set aside the first of these
    for subnet S6 and its 100 hosts.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您首先使用一个位作为子网ID进行初始子网划分，留下七个位用于主机ID和两个子网：201.45.222.0/25和201.45.222.128/25。每个子网最多可以容纳126个主机。您将这些中的第一个留作子网S6及其100个主机。
- en: You take the second subnet, 201.45.222.128/25, and subnet it further into two
    sub-subnets by taking one bit from the seven bits left in the host ID. This gives
    you the sub-subnets 201.45.222.128/26 and 201.45.222.192/26, each of which can
    have 62 hosts. You set aside the first of these for subnet S5 and its 50 hosts.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您选择第二个子网，201.45.222.128/25，并从主机ID中剩余的七个位中取出一个位，这为您提供了两个二级子网：201.45.222.128/26和201.45.222.192/26，每个子网可以容纳62个主机。您将这些中的第一个留作子网S5及其50个主机。
- en: You take the second sub-subnet, 201.45.222.192/26, and subnet it further into
    four sub-sub-subnets. You take two bits from the six that are left in the host
    ID, which gives you four sub-sub-subnets that each can have a maximum of 14 hosts.
    These are used for S1, S2, S3, and S4.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您选择第二个二级子网，201.45.222.192/26，并将其进一步划分为四个三级子网。您从主机ID中剩余的六个位中取出两个位，这为您提供了四个三级子网，每个子网最多可以容纳14个主机。这些用于S1、S2、S3和S4。
- en: Although I've chosen these numbers so that they work out perfectly, you should
    get the picture. VLSM greatly improves both the flexibility and the efficiency
    of subnetting.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我选择了这些数字以确保它们完美匹配，但您应该已经明白了。VLSM大大提高了子网划分的灵活性和效率。
- en: Note
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In order to use VLSM, routers that support VLSM-capable routing protocols
    must be employed. VLSM also requires more care in how routing tables are constructed
    to ensure that there is no ambiguity in how to interpret an address in the network*.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了使用VLSM，必须使用支持VLSM路由协议的路由器。VLSM还要求在构建路由表时更加小心，以确保对网络中地址的解释没有歧义*。'
- en: As I mentioned earlier, VLSM is similar in concept to the way CIDR is performed.
    The difference between VLSM and CIDR is primarily one of focus. VLSM deals with
    subnets of a single network in a private organization. CIDR takes the concept
    you just saw in VLSM to the Internet as a whole by changing how organizational
    networks are allocated, replacing the single-level classful hierarchy with a multiple-layer
    hierarchy.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，VLSM（可变长度子网掩码）在概念上与CIDR（无类别域间路由）的执行方式相似。VLSM与CIDR之间的主要区别在于关注的焦点不同。VLSM处理的是私有组织内单个网络的子网。CIDR将你在VLSM中看到的理念扩展到整个互联网，通过改变组织网络的分配方式，用多层层次结构取代了单层类别的层次结构。
- en: Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION
    EXAMPLE
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章。IP子网划分 实践子网设计和地址确定示例
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: When educators ask students what they consider to be the most confusing aspect
    in learning about networking, many say that it is IP address subnetting. While
    subnetting isn't all that difficult in concept, it can be a bit mind-boggling,
    in part due to the manipulations of binary numbers required. Many people understand
    the ideas behind subnetting but find it hard to follow the actual steps required
    to subnet a network.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当教育工作者询问学生他们认为在了解网络时最令人困惑的方面是什么时，许多人说那是IP地址子网划分。虽然子网划分在概念上并不那么困难，但它可能会让人感到有些令人困惑，部分原因是因为需要操作二进制数。许多人理解子网划分背后的理念，但发现难以跟随实际的网络子网划分步骤。
- en: For this reason, even though I explained the concepts behind subnetting in detail
    in the previous chapter, I felt it would be valuable to have another that provides
    a step-by-step look at how to perform custom subnetting. This chapter divides
    subnetting into five relatively straightforward stages that cover determining
    requirements; deciding how many bits to use for the subnet ID and host ID; and
    then determining important numbers such as the subnet mask, subnet addresses,
    and host addresses.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管我在上一章详细解释了子网划分的概念，但我认为再有一个提供逐步查看如何执行自定义子网划分的章节将非常有价值。本章将子网划分分为五个相对简单的阶段，包括确定需求；决定用于子网ID和主机ID的位数；然后确定诸如子网掩码、子网地址和主机地址等重要数字。
- en: My focus here is on showing the practical "how" of subnetting. The topics work
    through two examples using a Class B and a Class C sample network to show you
    how subnetting is done, and I am explicit in showing how everything is calculated.
    This means the section is a bit number heavy. Also, I try not to duplicate conceptual
    issues covered in the previous section, though a certain amount of overlap does
    occur. Overall, if you are not familiar with how subnetting works at all, you
    will want to read the previous chapter first. I do refer to topics in that chapter
    where appropriate, especially the summary tables. Incidentally, I only cover conventional
    subnetting here, not Variable Length Subnet Masking (VLSM).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里的重点是展示子网划分的实用“如何做”。这些主题通过使用B类和C类示例网络进行两个示例来说明子网划分是如何进行的，并且我在展示如何计算一切时是明确的。这意味着本节数字较多。此外，我尽量不重复前节中涵盖的概念问题，尽管确实存在一定程度的重叠。总的来说，如果你对子网划分的工作方式完全不熟悉，你将首先想要阅读上一章。我在适当的地方引用了那一章的内容，特别是总结表。顺便说一下，我只在这里介绍传统的子网划分，而不是可变长度子网掩码（VLSM）。
- en: This section may serve as a useful refresher or summary of subnetting for someone
    who is already familiar with the basics but just wants to review the steps performed
    in subnetting. Again, bear in mind that subnetting is based on the older, classful
    IP addressing scheme, and today's Internet is classless, using Classless Inter-Domain
    Routing (CIDR; see [Chapter 20](ch20.html "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS
    INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING")).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 本节可能对已经熟悉基础知识但只想回顾子网划分步骤的人来说是一个有用的复习或总结。再次提醒，子网划分基于较旧的类别IP地址方案，而今天的互联网是无类别的，使用无类别域间路由（CIDR；见[第20章](ch20.html
    "第20章。IP无类别地址——无类别域间路由（CIDR）/超网")）。
- en: Note
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If in reading this chapter, you find yourself wanting to do binary-to-decimal
    conversions or binary math, remember that most versions of Windows (and many other
    operating systems) have a calculator program that incorporates scientific functions*.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果在阅读本章时，你发现自己想要进行二进制到十进制的转换或二进制数学运算，请记住，大多数版本的Windows（以及许多其他操作系统）都有一个包含科学功能的计算器程序*。'
- en: 'IP Subnetting Step 1: Analyzing Requirements'
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分步骤1：分析需求
- en: When you are building or upgrading a network as a whole, the first step isn't
    buying hardware, or figuring out protocols, or even design. It's *requirements
    analysis*, the process of determining what it is the network needs to do. Without
    this foundation, you risk implementing a network that may perfectly match your
    design, but not meet the needs of your organization. The same rule applies to
    subnetting as well. Before you look at the gory details of host addresses and
    subnet masks, you must decide how to subnet the network. To do that, you must
    understand the requirements of the network.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为一个整体构建或升级网络时，第一步不是购买硬件，也不是确定协议，甚至不是设计。而是**需求分析**，即确定网络需要做什么的过程。没有这个基础，你可能会实施一个与你的设计完美匹配的网络，但无法满足你组织的需求。同样的规则也适用于子网划分。在你查看主机地址和子网掩码的详细信息之前，你必须决定如何划分网络。为了做到这一点，你必须了解网络的需求。
- en: 'Analyzing the requirements of the network for subnetting isn''t difficult,
    because there are only a few issues that you need to consider. Since requirements
    analysis is usually done by asking questions, here''s a list of the most important
    questions in analyzing subnetting requirements:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 分析网络划分的需求并不困难，因为只有几个问题需要考虑。由于需求分析通常是通过提问来完成的，以下是在分析子网划分需求时最重要的问题列表：
- en: What class is the IP address block?
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址块属于哪一类？
- en: How many physical subnets are on the network today? (A *physical subnet* generally
    refers to a broadcast domain on a LAN—a set of hosts on a physical network bounded
    by routers.)
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在网络上有多少物理子网络？（一个**物理子网络**通常指的是LAN上的广播域——由路由器界定的物理网络上的主机集合。）
- en: Do you anticipate adding any more physical networks in the near future, and
    if so, how many?
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预计在不久的将来会添加任何更多的物理网络吗？如果是这样，那么会有多少？
- en: How many hosts do you have in the largest of the subnets today?
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在最大的子网络中有多少主机？
- en: How many hosts do you anticipate having in the largest subnet in the near future?
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你预计在不久的将来最大的子网络中会有多少主机？
- en: Tip
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To successfully subnet a network, you must begin by learning
    what the requirements of the network will be. The most important parameters to
    determine are the number of subnets required and the maximum number of hosts needed
    per subnet. Numbers should not be based on just present needs, but also take into
    account requirements anticipated in the near future.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 要成功划分网络，你必须首先了解网络的需求。最重要的参数是确定所需的子网数量和每个子网络所需的最大主机数。数字不应仅基于当前需求，还应考虑近期预期的需求。'
- en: The first question is important because everything in subnetting is based around
    dividing up a Class A, Class B, or Class C network, so you need to know which
    one you are dealing with. If you are in the process of designing a network from
    scratch and don't have a Class A, B, or C block yet, then you will determine which
    one you need based on the approximate size of the organization.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题很重要，因为子网划分中的所有内容都是围绕划分A类、B类或C类网络进行的，所以你需要知道你正在处理哪一类。如果你正在从头开始设计网络，还没有A类、B类或C类块，那么你将根据组织的近似规模来确定你需要哪一类。
- en: 'After that, you need to determine two key numbers: how many physical subnets
    you have and the maximum number of hosts per subnet. You need to know these not
    only for the present network, but for the *near future* as well. The current values
    for these two numbers represent how the network needs to be designed today. However,
    designing only for the present is not a good idea.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要确定两个关键数字：你有多少物理子网络，以及每个子网络的最大主机数。你需要了解这些数字不仅是为了现在的网络，也是为了**近期未来**。这两个数字的当前值代表了网络今天应该如何设计。然而，只为现在设计并不是一个好主意。
- en: Suppose you have exactly four subnetworks in the network now. In theory, you
    could use only two bits for the subnet ID, since 2² equals 4\. However, if the
    company were growing rapidly, this would be a poor choice. When you needed to
    add a fifth subnet, you would have a problem!
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在网络中恰好有四个子网络。从理论上讲，你只需要两个比特位来表示子网ID，因为2的平方等于4。然而，如果公司正在快速发展，这将是一个糟糕的选择。当你需要添加第五个子网络时，你会遇到问题！
- en: Similarly, consider the growth in the number of hosts in a subnet. If the current
    largest subnet has 60 hosts, you don't want six bits for the host ID, because
    that limits you to 62 hosts. You can divide large subnets into smaller ones, but
    this may just mean unnecessary additional work.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，考虑子网中主机数量的增长。如果当前最大的子网有60个主机，你不想为主机ID分配六个比特位，因为这会限制你只能有62个主机。你可以将大型子网划分为更小的子网，但这可能只是意味着不必要的额外工作。
- en: So what is the "near future?" The term is necessarily vague, because it depends
    on how far into the future the organization wants to look. On the one hand, planning
    for several years' growth can make sense, if you have enough IP addresses to do
    it. On the other, you don't want to plan too far out, since changes in the short
    term may cause you to completely redesign your network anyway.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，“近期”是什么意思呢？这个术语必然是模糊的，因为它取决于组织想要展望多远的未来。一方面，如果你有足够的IP地址，规划几年的增长是有意义的。另一方面，你不想规划得太远，因为短期内可能的变化可能会让你不得不完全重新设计你的网络。
- en: 'IP Subnetting Step 2: Partitioning Network Address Host Bits'
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分步骤2：划分网络地址主机位
- en: 'After you complete the brief requirements analysis, you should know the two
    critical parameters that you must have in order to subnet the network: the number
    of subnets required for the network and the maximum number of hosts per subnetwork.
    In using these figures to design the subnetted network, you will be faced with
    the key design decision in subnetting: how to divide the 8, 16, or 24 bits in
    the classful host ID into the subnet ID and host ID.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成简短的需求分析后，你应该知道你必须有两个关键参数才能对网络进行子网划分：网络所需的子网数量和每个子网的最大主机数量。在使用这些数字来设计子网化网络时，你将面临子网划分的关键设计决策：如何将类地址的主机ID中的8、16或24比特位划分为子网ID和主机ID。
- en: 'Put another way, you need to decide how many bits to steal from the host ID
    to use for the subnet ID. As I explained in the section on custom subnet masks
    in the previous chapter, the fundamental trade-off in choosing this number is
    as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你需要决定从主机ID中窃取多少比特位用于子网ID。正如我在上一章关于自定义子网掩码的部分所解释的，选择这个数字的基本权衡如下：
- en: Each bit taken from the host ID for the subnet ID doubles the number of subnets
    that are possible in the network.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机ID中为子网ID取出的每个比特位将网络中可能的子网数量翻倍。
- en: Each bit taken from the host ID for the subnet ID (approximately) halves the
    number of hosts that are possible within each subnet on the network.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机ID中为子网ID取出的每个比特位（大约）将网络中每个子网可能的主机数量减半。
- en: There are six possible ways this decision can be made for a Class C network,
    as illustrated in [Figure 19-1](ch19s02.html#subnetting_design_trade-off_for_class_c_
    "Figure 19-1. Subnetting design trade-off for Class C networks This drawing shows
    the options for subnetting a Class C network. As you increase the number of bits
    for the host ID, you increase the number of subnets, but decrease the size of
    each.").
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C类网络，有六种可能的决策方式，如图19-1所示。[图19-1](ch19s02.html#subnetting_design_trade-off_for_class_c_
    "图19-1. C类网络的子网设计权衡图。这幅图显示了C类网络子网化的选项。随着主机ID比特位的增加，子网的数量增加，但每个子网的大小减少。")
- en: '![Subnetting design trade-off for Class C networks This drawing shows the options
    for subnetting a Class C network. As you increase the number of bits for the host
    ID, you increase the number of subnets, but decrease the size of each.](httpatomoreillycomsourcenostarchimages287827.png.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![C类网络的子网设计权衡图。这幅图显示了C类网络子网化的选项。随着主机ID比特位的增加，子网的数量增加，但每个子网的大小减少。](httpatomoreillycomsourcenostarchimages287827.png.jpg)'
- en: Figure 19-1. Subnetting design trade-off for Class C networks This drawing shows
    the options for subnetting a Class C network. As you increase the number of bits
    for the host ID, you increase the number of subnets, but decrease the size of
    each.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-1. C类网络的子网设计权衡图。这幅图显示了C类网络子网化的选项。随着主机ID比特位的增加，子网的数量增加，但每个子网的大小减少。
- en: 'The relationship between the bits and the number of subnets and hosts is as
    follows:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 比特位与子网数量和主机数量的关系如下：
- en: The number of subnets allowed in the network is two to the power of the number
    of subnet ID bits.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中允许的子网数量是子网ID比特位数量的2的幂。
- en: The number of hosts allowed per subnet is two to the power of the number of
    host ID bits, less two.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子网允许的主机数量是主机ID比特位数量的2的幂，减去2。
- en: You subtract two from the number of hosts in each subnet to exclude the special
    meaning cases where the host ID is all zeros or all ones. As I explained in the
    previous chapter, this exclusion was originally also applied to the subnet ID,
    but is no longer in newer systems.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从每个子网的主机数中减去两个，以排除主机ID全零或全一的具有特殊意义的案例。正如我在上一章中解释的，这种排除最初也应用于子网ID，但在较新的系统中不再如此。
- en: 'To choose how many bits to use for the subnet, you could use trial and error.
    By this, I mean you could try to first calculate the number of subnets and hosts
    when you use one bit for the subnet ID and leave the rest for the host ID. You
    could then try with two bits for the subnet ID, and then try with three, and so
    on. This would be silly, however; it''s time-consuming and makes it hard for you
    to choose the best option. There''s an easier method: You can use the subnetting
    summary tables, presented in the previous chapter. They let you look at all the
    options, and you can usually see immediately the best one for you.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择用于子网的位数，你可以使用试错法。我的意思是，你可以先尝试使用一个位作为子网ID，其余位留给主机ID来计算子网和主机的数量。然后你可以尝试使用两个位作为子网ID，接着是三个位，以此类推。然而，这样做会很愚蠢；它既耗时又难以让你选择最佳选项。有一个更简单的方法：你可以使用上一章中介绍的子网划分总结表。它们让你可以看到所有选项，你通常可以立即看到最适合你的选项。
- en: Class C Subnetting Design Example
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C类子网划分设计示例
- en: 'Let''s take an example. Suppose you have a Class C network, base address 211.77.20.0,
    with a total of seven subnets. The maximum number of hosts per subnet is 25\.
    Looking at the subnetting summary table for Class C ([Table 18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "Table 18-5. Subnetting Summary Table for Class C Networks") in [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS")), the answer is instantly
    clear: You need three bits for the subnet ID. Why? This allows you eight subnets
    and 30 hosts per subnet. If you try to choose two bits, you can''t define enough
    subnets (only four). As [Figure 19-2](ch19s02.html#example_of_class_c_subnetting_in_this_pa
    "Figure 19-2. Example of Class C subnetting In this particular example, where
    seven subnets are needed and 25 hosts are needed for the largest subnet, there
    is only one choice of subnet ID size that meets the requirements. It''s an easy
    decision!") shows, if you choose four bits for the subnet ID, then you can have
    only 14 hosts per subnet.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子。假设你有一个C类网络，基本地址为211.77.20.0，总共需要七个子网。每个子网的最大主机数是25。查看C类子网划分总结表（第18章中的[表18-5](ch18s07.html#subnetting_summary_table_for_class_c_net
    "表18-5. C类网络子网划分总结表")），答案立刻清晰：你需要三个位用于子网ID。为什么？这允许你拥有八个子网，每个子网有30个主机。如果你尝试选择两个位，你无法定义足够多的子网（只有四个）。正如[图19-2](ch19s02.html#example_of_class_c_subnetting_in_this_pa
    "图19-2. C类子网划分示例 在这个特定的例子中，需要七个子网，最大的子网需要25个主机，只有一个子网ID大小的选择符合要求。这是一个简单的决定！")所示，如果你选择四个位作为子网ID，那么每个子网就只能有14个主机。
- en: '![Example of Class C subnetting In this particular example, where seven subnets
    are needed and 25 hosts are needed for the largest subnet, there is only one choice
    of subnet ID size that meets the requirements. It''s an easy decision!](httpatomoreillycomsourcenostarchimages287829.png.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![C类子网划分示例](httpatomoreillycomsourcenostarchimages287829.png.jpg)'
- en: Figure 19-2. Example of Class C subnetting In this particular example, where
    seven subnets are needed and 25 hosts are needed for the largest subnet, there
    is only one choice of subnet ID size that meets the requirements. It's an easy
    decision!
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-2. C类子网划分示例 在这个特定的例子中，需要七个子网，最大的子网需要25个主机，只有一个子网ID大小的选择符合要求。这是一个简单的决定！
- en: Class B Subnetting Design Example
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B类子网划分设计示例
- en: In some cases, especially with larger networks, you may have multiple choices.
    Consider, as a more interesting example, the larger Class B network 166.113.0.0,
    where you have a total of 15 subnets and the largest has 450 hosts. Examining
    the subnet summary table for Class B ([Table 18-4](ch18s07.html#subnetting_summary_table_for_class_b_net
    "Table 18-4. Subnetting Summary Table for Class B Networks") in [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS")) suggests four acceptable
    options, as shown in [Figure 19-3](ch19s02.html#example_of_class_b_subnetting_this_class
    "Figure 19-3. Example of Class B subnetting This Class B network needs at least
    15 subnets and must allow up to 450 hosts per subnet. Three subnet ID bits are
    too few, and eight bits means only 254 hosts per subnet, which is insufficient.
    This leaves four acceptable options, so you must choose wisely.").
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，尤其是对于较大的网络，你可能有多重选择。以一个更有趣的例子来说明，更大的B类网络166.113.0.0，其中总共有15个子网，最大的子网有450个主机。查看B类网络的子网汇总表（[表18-4](ch18s07.html#subnetting_summary_table_for_class_b_net
    "表18-4. B类网络子网划分汇总表")，位于[第18章](ch18.html "第18章. IP子网地址（子网划分）概念")）表明有四种可接受的选择，如图[图19-3](ch19s02.html#example_of_class_b_subnetting_this_class
    "图19-3. B类子网划分示例图，这个B类网络需要至少15个子网，并且每个子网必须允许最多450个主机。三个子网ID位太少，八个位意味着每个子网只有254个主机，这显然是不够的。这留下了四个可接受的选择，所以你必须明智地选择。"）所示。
- en: In all four of these options, the number of subnets is equal to 15 or greater,
    and the number of hosts per subnet is over 450\. So which option should you choose?
    Usually, you want to pick something in the middle. If you use four bits for the
    subnet ID, this gives you a maximum of only 16 subnets, which limits growth in
    the number of subnets, since you already have 15\. The same applies to the choice
    of seven bits for the subnet ID, since you already have 450 hosts in one subnet
    now, and that limits you to 510\. Thus, you probably want either five or six bits
    here. If you expect more growth in the number of hosts in the largest subnet,
    you should choose five bits; if you expect more growth in the number of subnets,
    you should choose six bits. If you're unsure, it's probably best to assume more
    growth in the number of hosts per subnet, so here you would choose five bits.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四种选择中，子网的数量都是15个或更多，每个子网的主机数量超过450个。那么你应该选择哪个选项呢？通常，你希望选择一个中间的方案。如果你为子网ID使用四个位，这将给你最多只有16个子网，这限制了子网数量的增长，因为你已经有15个子网了。同样，如果你选择七个位作为子网ID，因为你现在已经有了一个子网中的450个主机，这将限制你到510个。因此，你可能在这里想要选择五个或六个位。如果你预计最大子网中的主机数量会有更多增长，你应该选择五个位；如果你预计子网数量会有更多增长，你应该选择六个位。如果你不确定，最好假设每个子网中的主机数量会有更多增长，所以在这里你会选择五个位。
- en: 'The converse problem may also occur: You may be in a position where there don''t
    appear to be any options—no rows in the summary table match. For example, if the
    Class C example had 35 hosts in the largest subnet instead of 25, you would be
    out of luck, because there is no combination of subnet ID and host ID size that
    works. The same is true in the Class B example if you had 4,500 hosts in that
    big subnet instead of 450\. In this situation, you would need to divide the large
    subnet into a smaller one, use more than one IP address block, or upgrade to a
    larger block.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的问题也可能发生：你可能处于一个似乎没有选择的情况——汇总表中没有匹配的行。例如，如果C类网络的例子中最大的子网有35个主机而不是25个，你就没有选择了，因为没有子网ID和主机ID大小的组合是可行的。在B类网络的例子中，如果你在那个大子网中有4,500个主机而不是450个，情况也是一样。在这种情况下，你需要将大子网划分为更小的子网，使用多个IP地址块，或者升级到更大的块。
- en: '![Example of Class B subnetting This Class B network needs at least 15 subnets
    and must allow up to 450 hosts per subnet. Three subnet ID bits are too few, and
    eight bits means only 254 hosts per subnet, which is insufficient. This leaves
    four acceptable options, so you must choose wisely.](httpatomoreillycomsourcenostarchimages287831.png.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![B类子网划分示例图](httpatomoreillycomsourcenostarchimages287831.png.jpg)'
- en: Figure 19-3. Example of Class B subnetting This Class B network needs at least
    15 subnets and must allow up to 450 hosts per subnet. Three subnet ID bits are
    too few, and eight bits means only 254 hosts per subnet, which is insufficient.
    This leaves four acceptable options, so you must choose wisely.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-3. B类子网划分示例 这个B类网络至少需要15个子网，并且必须允许每个子网最多450个主机。三个子网ID位太少，而八个位意味着每个子网只有254个主机，这不够。这留下了四个可接受的选择，所以你必须明智地选择。
- en: Tip
  id: totrans-676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** If there is more than one combination of subnet ID and host
    ID sizes that will meet requirements, try to choose a middle-of-the-road option
    that best anticipates future growth requirements. If no combination meets the
    requirements, the requirements have to change!'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 如果有多个子网ID和主机ID大小的组合可以满足要求，尽量选择一个折中的选项，以最好地预测未来的增长需求。如果没有组合满足要求，则必须更改要求！'
- en: 'IP Subnetting Step 3: Determining the Custom Subnet Mask'
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分步骤3：确定自定义子网掩码
- en: Once you have decided how many bits to use for the subnet ID and how many to
    leave for the host ID, you can determine the custom subnet mask for the network.
    Now, don't go running for cover on me. A lot of people's eyes glaze over at mention
    of the subnet mask, but it's really quite simple to figure out once you have done
    the homework in making the design decision you did in step 2\. In fact, there
    are two ways of doing this; one is less work than the other, but they're both
    quite easy. I was going to call them the hard way and the easy way, but instead,
    I'll call them easy and easier.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定了用于子网ID的位数以及用于主机ID的位数，你就可以确定网络的自定义子网掩码。现在，不要因为我而躲起来。很多人一提到子网掩码就会眼花缭乱，但一旦你完成了在第2步中做出的设计决策的作业，它实际上是非常简单的。事实上，有两种方法来做这件事；一种比另一种工作量小，但它们都很简单。我本来想称它们为“难方法”和“易方法”，但相反，我将称它们为“简单”和“更简单”。
- en: Calculating the Custom Subnet Mask
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算自定义子网掩码
- en: 'Let''s start with the easy method, in which you calculate the subnet mask in
    binary form from the information you already have about the network, and then
    convert the mask to decimal. To refresh your memory and guide the process, remember
    this: The subnet mask is a 32-bit binary number where a one represents each bit
    that is part of the network ID or subnet ID, and a zero represents each bit of
    the host ID.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单方法开始，即根据你已有的关于网络的信息，以二进制形式计算子网掩码，然后将掩码转换为十进制。为了刷新你的记忆并指导这个过程，请记住这一点：子网掩码是一个32位的二进制数，其中一位代表网络ID或子网ID的一部分，而零代表主机ID的一部分。
- en: Class C Custom Subnet Mask Calculation Example
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C类自定义子网掩码计算示例
- en: 'Refer back to the Class C example in the previous section ([Figure 19-2](ch19s02.html#example_of_class_c_subnetting_in_this_pa
    "Figure 19-2. Example of Class C subnetting In this particular example, where
    seven subnets are needed and 25 hosts are needed for the largest subnet, there
    is only one choice of subnet ID size that meets the requirements. It''s an easy
    decision!")). Say you decided to use three bits for the subnet ID, leaving five
    bits for the host ID. Here are the steps you will follow to determine the custom
    subnet mask for this network (illustrated in [Figure 19-4](ch19s03.html#determining_the_custom_subnet_mask_for_a
    "Figure 19-4. Determining the custom subnet mask for a Class C network")):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 参考上一节中的C类示例（[图19-2](ch19s02.html#example_of_class_c_subnetting_in_this_pa "图19-2.
    本例中C类子网划分的示例"））。在这个特定的例子中，需要七个子网，最大的子网需要25个主机，只有一个子网ID大小的选择可以满足要求。这是一个简单的决定！）。假设你决定为子网ID使用三个位，为主机ID留下五个位。以下是确定此网络自定义子网掩码的步骤（如图19-4所示）：
- en: '**Determine Default Subnet Mask** Each of Classes A, B, and C has a default
    subnet mask, which is the subnet mask for the network prior to subnetting. It
    has a one for each network ID bit and a zero for each host ID bit. For Class C,
    the subnet mask is 255.255.255.0\. In binary, this is:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定默认子网掩码** A类、B类和C类每个都有一个默认子网掩码，这是子网划分之前的网络子网掩码。它对于每个网络ID位有一个一，对于每个主机ID位有一个零。对于C类，子网掩码是255.255.255.0。在二进制中，它是：'
- en: '| 11111111 11111111 11111111 00000000 |'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11111111 11111111 11111111 00000000 |'
- en: '**Change Leftmost Zeros to Ones for Subnet Bits** You have decided to use three
    bits for the subnet ID. The subnet mask must have a one for each of the network
    ID or subnet ID bits. The network ID bits are already one from the default subnet
    mask, so, you change the three *leftmost* zero bits in the default subnet mask
    from a 0 to 1, as shown in bold here. This results in the following custom subnet
    mask for the network:'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将最左边的零位转换为子网位的一** 你已经决定使用三个位作为子网ID。子网掩码必须对网络ID或子网ID位中的每一个都有一个1。网络ID位已经从默认子网掩码中有一个1，所以，你将默认子网掩码中的三个*最左边的*零位从0转换为1，如粗体所示。这导致了以下自定义子网掩码：'
- en: '| 11111111 11111111 11111111 **111**00000 |'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11111111 11111111 11111111 **111**00000 |'
- en: '**Convert Subnet Mask to Dotted Decimal Notation** You take each of the octets
    in the subnet mask and convert it to decimal. The result is the custom subnet
    mask in the form you usually see it: 255.255.255.224.'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将子网掩码转换为点分十进制表示** 你将子网掩码中的每个八位字节转换为十进制。结果是通常看到的自定义子网掩码形式：255.255.255.224。'
- en: '**Express Subnet Mask in Slash Notation** Alternatively, you can express the
    subnet mask in *slash notation*. This is just a slash followed by the number of
    ones in the subnet mask. 255.255.255.224 is equivalent to /27.'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以斜杠表示法表达子网掩码** 或者，你也可以用斜杠表示法表达子网掩码。这只是一个斜杠后跟子网掩码中的1的数量。255.255.255.224相当于/27。'
- en: Class B Custom Subnet Mask Calculation Example
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B类自定义子网掩码计算示例
- en: 'Now let''s do the same example with the Class B network (166.113.0.0) with
    five bits for the subnet ID (with a bit less narration this time; see [Figure 19-5](ch19s03.html#determining_the_custom_subnet_mask-id001
    "Figure 19-5. Determining the custom subnet mask for a Class B network")):'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用具有五个位子网ID的B类网络（166.113.0.0）来做同样的例子（这次叙述少一些；见[图19-5](ch19s03.html#determining_the_custom_subnet_mask-id001
    "图19-5. 确定B类网络的自定义子网掩码"))：
- en: '**Determine Default Subnet Mask** For Class B, the subnet mask is 255.255.0.0\.
    In binary, this is:'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确定默认子网掩码** 对于B类，子网掩码是255.255.0.0。在二进制中，它是这样的：'
- en: '| 11111111 11111111 00000000 00000000 |'
  id: totrans-693
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11111111 11111111 00000000 00000000 |'
- en: '**Change Leftmost Zeros to Ones for Subnet Bits** If you use five bits for
    the subnet ID, you change the five leftmost zero bits from a 0 to 1, as shown
    in bold, to give you the binary custom subnet mask, as follows:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将最左边的零位转换为子网位的一** 如果你使用五个位作为子网ID，你将五个最左边的零位从0转换为1，如粗体所示，以得到二进制自定义子网掩码，如下所示：'
- en: '| 11111111 11111111 **11111**000 00000000 |'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 11111111 11111111 **11111**000 00000000 |'
- en: '![Determining the custom subnet mask for a Class C network](httpatomoreillycomsourcenostarchimages287833.png.jpg)'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![确定C类网络的自定义子网掩码](httpatomoreillycomsourcenostarchimages287833.png.jpg)'
- en: Figure 19-4. Determining the custom subnet mask for a Class C network
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19-4. 确定C类网络的自定义子网掩码
- en: '**Convert Subnet Mask to Dotted Decimal Notation** You take each of the octets
    in the subnet mask and convert it to decimal to give you a custom subnet mask
    of 255.255.**248**.0.'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将子网掩码转换为点分十进制表示** 你将子网掩码中的每个八位字节转换为十进制，以得到255.255.**248**.0的自定义子网掩码。'
- en: '**Express Subnet Mask in Slash Notation** You can express the subnet mask 255.255.248.0
    as /21, since it is 21 ones followed by 11 zeros. In other words, its prefix length
    is 21.'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以斜杠表示法表达子网掩码** 你可以将子网掩码255.255.248.0表示为/21，因为它有21个1后面跟着11个0。换句话说，它的前缀长度是21。'
- en: '![Determining the custom subnet mask for a Class B network](httpatomoreillycomsourcenostarchimages287835.png.jpg)'
  id: totrans-700
  prefs: []
  type: TYPE_IMG
  zh: '![确定B类网络的自定义子网掩码](httpatomoreillycomsourcenostarchimages287835.png.jpg)'
- en: Figure 19-5. Determining the custom subnet mask for a Class B network
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-5. 确定B类网络的自定义子网掩码
- en: Determining the Custom Subnet Mask Using Subnetting Tables
  id: totrans-702
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子网划分表确定自定义子网掩码
- en: Now, what could be easier than that? Well, you could simply refer to the subnetting
    summary tables, presented in [Chapter 18](ch18.html "Chapter 18. IP SUBNET ADDRESSING
    (SUBNETTING) CONCEPTS"). Find the table for the appropriate class, and then find
    the row that you selected in the previous step that matches the number of subnet
    ID bits you want to use. You can see the matching subnet mask right there.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有什么比这更容易的吗？嗯，你可以简单地参考第18章中提供的子网划分摘要表[第18章](ch18.html "第18章. IP子网地址（子网划分）概念")。找到适合的类别的表格，然后找到你在上一步中选择的行，该行与你想使用的子网ID位数相匹配。你可以在那里看到匹配的子网掩码。
- en: (Hey, it's good to know how to do it yourself! You may not always have tables
    to refer to!)
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: （嘿，知道如何自己做到这一点是很好的！你可能并不总是有表格可以参考！）
- en: 'IP Subnetting Step 4: Determining Subnet Identifiers and Subnet Addresses'
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分步骤4：确定子网标识符和子网地址
- en: The network ID assigned to the network applies to the entire network. This includes
    all subnets and all hosts in all subnets. Each subnet, however, needs to be identified
    with a unique *subnet identifier*, or *subnet ID*, so it can be differentiated
    from the other subnets in the network. This is the purpose of the subnet ID bits
    that you took from the host ID bits in subnetting. After you have identified each
    subnet, you need to determine the address of each subnet, so you can use this
    in assigning hosts specific IP addresses.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给网络的网络ID适用于整个网络。这包括所有子网以及所有子网中的所有主机。然而，每个子网都需要一个唯一的*子网标识符*或*子网ID*，以便可以将其与网络中的其他子网区分开来。这就是你在子网划分中从主机ID位中提取的子网ID位的目的。在你识别了每个子网之后，你需要确定每个子网的地址，以便可以在分配主机特定IP地址时使用。
- en: This is another step in subnetting that is not really hard to understand or
    do. The key to understanding how to determine subnet IDs and subnet addresses
    is to always work in binary form, and then convert to decimal later. You will
    also look at a shortcut for determining addresses in decimal directly, which is
    faster but less conceptually simple.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子网划分中的一个步骤，实际上并不难理解或执行。理解如何确定子网ID和子网地址的关键是始终以二进制形式工作，然后稍后转换为十进制。你还将查看一个直接确定十进制地址的捷径，这更快，但概念上不太简单。
- en: Note
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I assume in this description that you will be using the all-zeros and all-ones
    subnet numbers. In the original RFC 950 subnetting system, those two subnets are
    not used, which changes most of the following calculations. See [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS") for an explanation*.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '*我假设在这个描述中，你将使用全零和全一的子网号。在原始RFC 950子网划分系统中，这两个子网没有被使用，这改变了以下大多数计算。参见[第18章](ch18.html
    "第18章。IP子网地址（子网划分）概念")以获取解释*。'
- en: 'You number the subnets starting with 0, and then 1, 2, 3, and so on, up to
    the highest subnet ID that you need. You determine the subnet IDs and addresses
    as follows:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你从0开始编号子网，然后是1，2，3，依此类推，直到你需要的高个子网ID。你确定子网ID和地址如下：
- en: '**Subnet ID** This is just the subnet number, and it can be expressed in either
    binary or decimal form.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网ID** 这只是子网号，它可以以二进制或十进制形式表示。'
- en: '**Subnet Address** This is the address formed by taking the address of the
    network as a whole and substituting the (binary) subnet ID for the subnet ID bits.
    You need to do this in binary, but only for the octets where there are subnet
    ID bits; the ones where there are only network ID bits or only host ID bits are
    left alone.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网地址** 这是通过将整个网络的地址替换为（二进制）子网ID来形成的地址。你需要以二进制形式这样做，但只针对有子网ID位的八位字节；那些只有网络ID位或只有主机ID位的字节保持不变。'
- en: Seem complicated? Let's go back to the examples, and you'll see that it really
    isn't.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂？让我们回到例子，你会发现这实际上并不复杂。
- en: Class C Subnet ID and Address Determination Example
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C类子网ID和地址确定示例
- en: 'You''ll recall the Class C example network, 211.77.20.0\. The network address
    in binary is as follows:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得C类示例网络，211.77.20.0。该网络的二进制地址如下：
- en: '| 11010011 01001101 00010100 00000000 |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 00000000 |'
- en: 'You are subnetting using three bits for the subnet ID, leaving five bits for
    the host ID. Now let''s see the network address with the subnet bits in bold:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用三个位作为子网ID进行子网划分，剩下五位用于主机ID。现在让我们看看带有粗体子网位的网络地址：
- en: '| 11010011 01001101 00010100 **000**00000 |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **000**00000 |'
- en: These are the bits that you substitute with the subnet ID for each subnet. Notice
    that since the first three octets contain network ID bits, and the network ID
    is the same for every subnet, they never change. You don't even really need to
    look at them in binary form, though for clarity, you will do so here.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你可以用子网ID替换的位。注意，由于前三个八位字节包含网络ID位，并且每个子网的网络ID都是相同的，所以它们永远不会改变。尽管如此，你实际上并不需要查看它们的二进制形式，但为了清晰起见，你将在这里这样做。
- en: 'Here''s how you determine the subnet IDs and addresses, again, starting with
    0 (see [Figure 19-6](ch19s04.html#determining_subnet_addresses_for_a_class "Figure 19-6. Determining
    subnet addresses for a Class C network This diagram shows each of the eight possible
    subnets created when you use three bits for the subnet ID in a Class C network.
    The binary subnet ID is simply substituted for the subnet bits, and the resulting
    32-bit number is converted to dotted decimal form.")):'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '这就是确定子网ID和地址的方法，再次强调，从0开始（见[图19-6](ch19s04.html#determining_subnet_addresses_for_a_class
    "图19-6. 确定C类网络的子网地址 此图显示了在C类网络中使用三个位作为子网ID时创建的八个可能的子网。二进制的子网ID简单地替换了子网位，得到的32位数字被转换为点分十进制形式。"))):'
- en: '**Subnet 0** This has a subnet ID of 0, or 000 in binary. To find the address,
    you start with the network address in binary and substitute 000 for the subnet
    ID bits. Well gee, those bits are already all zero! What this means is that the
    address for subnet 0 is the same as the address for the network as a whole: 211.77.20.0\.
    This is always the case: subnet 0 always has the same address as the network.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网0** 这个子网的子网ID是0，或二进制的000。要找到地址，你从二进制的网络地址开始，用000替换子网ID位。哎呀，这些位已经都是零了！这意味着子网0的地址与整个网络的地址相同：211.77.20.0。这始终是这种情况：子网0始终与网络的地址相同。'
- en: '**Subnet 1** This has a subnet ID of 1 in decimal or 001 in binary. To find
    the address, you substitute 001 for the subnet ID bits, which yields the following:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网1** 这个子网的子网ID是十进制的1或二进制的001。要找到地址，你需要用001替换子网ID位，得到以下结果：'
- en: '| 11010011 01001101 00010100 **001**00000 |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **001**00000 |'
- en: '| Converting to decimal, you get 211.77.20.32. |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 转换为十进制，得到211.77.20.32。 |'
- en: '**Subnet 2** This has a subnet ID of 2, or 010 in binary. To find its address,
    you substitute 010 for the subnet ID bits, to give you the following:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网2** 这个子网的子网ID是2，或二进制的010。要找到它的地址，你需要用010替换子网ID位，得到以下结果：'
- en: '| 11010011 01001101 00010100 **010**00000 |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **010**00000 |'
- en: '| Which is 211.77.20.64 in binary. |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| 这在二进制中是211.77.20.64。 |'
- en: '**Subnet 3** This has a subnet ID of 011\. As you can see, the first three
    octets of the address are always 211.77.20\. The last octet here is **011**00000,
    which is 96 in decimal, so the whole address is 211.77.20.96.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网3** 这个子网的子网ID是011。正如你所看到的，地址的前三个八位组总是211.77.20。这里的最后一个八位组是**011**00000，在十进制中是96，所以整个地址是211.77.20.96。'
- en: Starting to see a pattern here? Yes, the address of any subnet can be found
    by adding 32 to the last octet of the previous subnet. This pattern occurs for
    all subnetting choices; the increment depends on how many bits you are using for
    the subnet ID. Here, the increment is 32, which is 2⁵; 5 is the number of host
    ID bits left after you took three subnet ID bits.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始看到模式了吗？是的，任何子网的地址都可以通过将前一个子网的最后一个八位组加32来找到。这个模式适用于所有子网划分选择；增量取决于你为子网ID使用的位数。在这里，增量是32，即2⁵；5是在你取了三个子网ID位之后剩下的主机ID位的数量。
- en: '**Subnet 4** This has a subnet ID of 100\. Its address is 211.77.20.128.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网4** 这个子网的子网ID是100。它的地址是211.77.20.128。'
- en: '**Subnet 5** This has a subnet ID of 101\. Its address is 211.77.20.160.'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网5** 这个子网的子网ID是101。它的地址是211.77.20.160。'
- en: '**Subnet 6** This has a subnet ID of 110\. Its address is 211.77.20.192.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网6** 这个子网的子网ID是110。它的地址是211.77.20.192。'
- en: '**Subnet 7** This has a subnet ID of 111\. Its address is 211.77.20.224.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网7** 这个子网的子网ID是111。它的地址是211.77.20.224。'
- en: '![Determining subnet addresses for a Class C network This diagram shows each
    of the eight possible subnets created when you use three bits for the subnet ID
    in a Class C network. The binary subnet ID is simply substituted for the subnet
    bits, and the resulting 32-bit number is converted to dotted decimal form.](httpatomoreillycomsourcenostarchimages287837.png.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![确定C类网络的子网地址 此图显示了在C类网络中使用三个位作为子网ID时创建的八个可能的子网。二进制的子网ID简单地替换了子网位，得到的32位数字被转换为点分十进制形式。](httpatomoreillycomsourcenostarchimages287837.png.jpg)'
- en: Figure 19-6. Determining subnet addresses for a Class C network This diagram
    shows each of the eight possible subnets created when you use three bits for the
    subnet ID in a Class C network. The binary subnet ID is simply substituted for
    the subnet bits, and the resulting 32-bit number is converted to dotted decimal
    form.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-6. 确定C类网络的子网地址 此图显示了在C类网络中使用三个位作为子网ID时创建的八个可能的子网。二进制的子网ID简单地替换了子网位，得到的32位数字被转换为点分十进制形式。
- en: Tip
  id: totrans-736
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The subnet addresses in a subnetted network are always evenly
    spaced numerically, with the spacing depending on the number of subnet ID bits.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在子网化网络中，子网地址总是以数值均匀分布，间隔取决于子网ID位的数量。'
- en: This example needed only seven subnets, 0 through 6\. Subnet 7 would be a spare.
    Notice that the last subnet has the same last octet as the subnet mask for the
    network? That's because I substituted 111 for the subnet ID bits, just as in the
    subnet mask calculation.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只需要七个子网，从0到6。子网7将是备用。注意，最后一个子网与网络的子网掩码具有相同的最后一个八位字节？这是因为我在子网掩码计算中用111替换了子网ID位。
- en: Class B Subnet ID and Address Determination Example
  id: totrans-739
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B类子网ID和地址确定示例
- en: 'Let''s look at the other example now, Class B network 166.113.0.0\. In binary
    this is as follows:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，B类网络166.113.0.0。在二进制中，它如下所示：
- en: '| 0100110 01110001 00000000 00000000 |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| 0100110 01110001 00000000 00000000 |'
- en: 'You''re using five bits for the subnet ID, leaving 11 host ID bits. The network
    address with the subnet ID bits highlighted is as follows:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用五个位作为子网ID，剩下11个主机ID位。具有突出显示的子网ID位的网络地址如下：
- en: '| 0100110 01110001 **00000**000 00000000 |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| 0100110 01110001 **00000**000 00000000 |'
- en: 'Here, only the third octet will ever change for the different subnets. The
    first two will always be 166.113, and the last octet will always be 0\. There
    are 32 possible subnets; I''ll list the first few so you can see the pattern (refer
    to [Figure 19-7](ch19s04.html#determining_subnet_addresses_for_a-id001 "Figure 19-7. Determining
    subnet addresses for a Class B network This is the same as Figure 19-6, but for
    a Class B network with five subnet ID bits (I have not shown all 32 subnets, for
    obvious reasons).") as well):'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有第三个八位字节会因不同的子网而改变。前两个始终是166.113，最后一个八位字节始终是0。共有32个可能的子网；我将列出前几个，以便你可以看到模式（参见图19-7）：
- en: '**Subnet 0** This has a subnet ID of 00000\. This means the address will be
    166.113.0.0, which is the network address, as you would expect.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网0** 这具有子网ID 00000。这意味着地址将是166.113.0.0，正如你所期望的那样，这是网络地址。'
- en: '**Subnet 1** This has a subnet ID of 00001\. The address becomes'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网1** 这具有子网ID 00001。地址变为'
- en: '| 10100110 01110001 **00001**000 00000000 |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| 10100110 01110001 **00001**000 00000000 |'
- en: '| This is 116.113.8.0 in decimal. |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| 这是以十进制表示的116.113.8.0。 |'
- en: '**Subnet 2** This has a subnet ID of 00010, giving an address of 116.113.**00010**000.0
    or 116.113.16.0.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网2** 这具有子网ID 00010，地址为116.113.**00010**000.0或116.113.16.0。'
- en: '**Subnet 3** This has a subnet ID of 00011 and a subnet address of 116.113.24.0.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网3** 这具有子网ID 00011和子网地址116.113.24.0。'
- en: '![Determining subnet addresses for a Class B network This is the same as ,
    but for a Class B network with five subnet ID bits (I have not shown all 32 subnets,
    for obvious reasons).](httpatomoreillycomsourcenostarchimages287839.png.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![确定B类网络的子网地址 这与相同，但针对具有五个子网ID位的B类网络（出于明显的原因，我没有显示所有32个子网）](httpatomoreillycomsourcenostarchimages287839.png.jpg)'
- en: Figure 19-7. Determining subnet addresses for a Class B network This is the
    same as [Figure 19-6](ch19s04.html#determining_subnet_addresses_for_a_class "Figure 19-6. Determining
    subnet addresses for a Class C network This diagram shows each of the eight possible
    subnets created when you use three bits for the subnet ID in a Class C network.
    The binary subnet ID is simply substituted for the subnet bits, and the resulting
    32-bit number is converted to dotted decimal form."), but for a Class B network
    with five subnet ID bits (I have not shown all 32 subnets, for obvious reasons).
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-7。确定B类网络的子网地址 这与[图19-6](ch19s04.html#determining_subnet_addresses_for_a_class
    "图19-6。确定C类网络的子网地址 此图显示了在C类网络中使用三个位作为子网ID时创建的八个可能的子网。二进制子网ID简单地替换为子网位，并将生成的32位数字转换为点分十进制形式。")相同，但针对具有五个子网ID位的B类网络（出于明显的原因，我没有显示所有32个子网）。
- en: 'Again, the pattern here is obvious: You add eight to the third octet to get
    successive addresses. The last subnet here is 31, which has a subnet address of
    116.113.248.0, which has the same third and fourth octets as the subnet mask of
    255.255.248.0.'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里的模式很明显：你将第三个八位字节加八以获得连续的地址。这里的最后一个子网是31，其子网地址为116.113.248.0，其第三个和第四个八位字节与子网掩码255.255.248.0相同。
- en: Using Subnet Address Formulas to Calculate Subnet Addresses
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用子网地址公式计算子网地址
- en: Since the subnet addresses form a pattern, and the pattern depends on the number
    of subnet ID bits, it is possible to express the subnet addresses using a single
    formula for each subnetting option. I have shown these formulas for each of the
    Classes A, B, and C in the subnetting summary tables in [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS"). The formulas can be
    used to directly calculate the address of subnet *N*, where *N* is numbered from
    0 up to one less than the total number of subnets, as I have done earlier.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子网地址形成一种模式，而这种模式取决于子网ID位的数量，因此可以使用单个公式来表示每个子网选项的子网地址。我在[第18章](ch18.html "第18章。IP子网地址（子网划分）概念")的子网划分总结表中展示了A、B和C类每个类的公式。这些公式可以直接计算子网*N*的地址，其中*N*从0开始编号，直到少于总子网数，正如我之前所做的那样。
- en: In these formulas, the network ID bits are shown as x., x.y., or x.y.z. for
    the three classes. This just means that the subnet addresses have as those octets
    whatever the numbers are in those octets for the network address. In the examples,
    x.y would be 166.113 for the Class B network, and x.y.z would be 211.77.20 for
    the Class C network.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些公式中，网络ID位以x.、x.y.或x.y.z.的形式表示三个类别。这仅仅意味着子网地址具有与网络地址中相应八位相同的数字。在示例中，x.y对于B类网络将是166.113，而x.y.z对于C类网络将是211.77.20。
- en: When the number of subnet bits is eight or less, the formula is relatively simple,
    and a calculation is done for only one octet, as a multiplication of *N*, such
    as *N**4 or *N**32\. This is usually the case, since the number of subnets is
    usually less than 256, and it's the case with both of the examples.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 当子网位数为大于八位时，一些八位的形式是*N*除以一个整数，例如*N*/8。这是一个整数除法，意味着将*N*除以8，保留整数部分，并丢弃小数部分或余数。其他八位基于*N*的模数计算，表示为*N*%8。这是完全相反的：这意味着将*N*除以8，丢弃整数，并保留余数。例如，在整数数学中33/5是6（6余3，丢弃余数，或者换句话说，6.6，丢弃小数），而33%5是3（6余3，丢弃6，保留余数）。
- en: In the Class C network with three subnet ID bits, the formula from the table
    is x.y.z.*N**32\. For this network, all subnets are of the form 211.77.20.*N**32,
    with *N* going from zero to seven. So, subnet 5 is 211.77.20.(5*32), which is
    211.77.20.160, as you saw before. Similarly, in the Class B network with five
    subnet ID bits, the formula is x.y.*N**8.0\. In this case, x.y is 166.113\. Subnet
    26 would have the address 166.113.(26*8).0, or 166.113.208.0.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有三个子网ID位的C类网络中，表中的公式是x.y.z.*N**32\. 对于这个网络，所有子网都采用211.77.20.*N**32的形式，其中*N*从零到七。因此，子网5是211.77.20.(5*32)，即211.77.20.160，正如你之前看到的。同样，在具有五个子网ID位的B类网络中，公式是x.y.*N**8.0\.
    在这种情况下，x.y是166.113\. 子网26将具有地址166.113.(26*8).0，或者166.113.208.0。
- en: This is pretty simple stuff, and it makes the formulas a good shortcut for quickly
    determining subnet addresses, especially when there are many subnets. They can
    also be used in a spreadsheet.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，这使得公式成为快速确定子网地址的好方法，尤其是在有多个子网的情况下。它们也可以用在电子表格中。
- en: The only place where using the formulas requires a bit of care is when the number
    of subnet bits is nine or more. This means that the subnet identifier crosses
    an octet boundary, and this causes the formula to become more complex.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公式时唯一需要小心的地方是当子网位数为九位或更多时。这意味着子网标识符跨越了八位边界，这导致公式变得更加复杂。
- en: 'When the number of subnet bits is greater than eight, some of the octets are
    of the form *N* divided by an integer, such as *N*/8\. This is an integer division,
    which means divide *N* by 8, keep the integer part, and drop the fractional part
    or remainder. Other octets are calculated based on the modulo of *N*, shown as
    *N*%8\. This is the exact opposite: It means divide *N* by 8, drop the integer,
    and keep the remainder. For example, 33/5 in integer math is 6 (6 with a remainder
    of 3, drop the remainder, or alternately, 6.6, drop the fraction), and 33%5 is
    3 (6 with a remainder of 3, drop the 6, keep the remainder).'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 当子网位数为八位或更少时，公式相对简单，只需计算一个八位，例如*N**4或*N**32的乘法。这通常是这种情况，因为子网的数量通常少于256，这两个示例都是这种情况。
- en: Let's take as an example the Class B network and suppose that for some strange
    reason you decided to use ten bits for the subnet ID instead of five. In this
    case, the formula is x.y.*N*/4.(N%4)*64\. Subnet 23 in this case would have the
    address 166.113.23/4.(23%4)*64\. The 23/4 becomes just 5 (the fractional .75 is
    dropped). 23 modulo 4 is 3, which is multiplied by 64 to get 192\. So the subnet
    address is 166.113.5.192\. Subnet 709 would be 116.113.709/4.(709%4)*64, which
    is 116.113.177.64.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以B类网络为例，假设出于某种奇怪的原因，你决定使用10位作为子网ID而不是5位。在这种情况下，公式是x.y.*N*/4.(N%4)*64。在这种情况下，子网23的地址将是166.113.23/4.(23%4)*64。23除以4等于5（小数点后的.75被省略）。23模4等于3，乘以64得到192。因此，子网地址是166.113.5.192。子网709将是116.113.709/4.(709%4)*64，即116.113.177.64。
- en: Okay, now for the real fun! If you subnet a Class A address using more than
    16 bits for the subnet ID, you are crossing *two* octet boundaries, and the formulas
    become very … interesting, involving both integer division *and* modulo. Suppose
    you were in charge of Class A address 21.0.0.0 and decide to subnet it. However,
    you sat down to do this after having had a few stiff ones at the office holiday
    party, so your judgment is a bit impaired. You decide that it would be a great
    idea to choose 21 bits for the subnet ID, since you like the number 21\. This
    gives you a couple million subnets.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在让我们进入真正的乐趣！如果你使用超过16位用于子网ID的Class A地址进行子网划分，你将跨越*两个*八位字节边界，公式变得非常……有趣，涉及到整数除法和模数。假设你负责Class
    A地址21.0.0.0，并决定对其进行子网划分。然而，你在办公室的节日派对上喝了几杯烈酒之后才开始做这件事，所以你的判断有点受损。你决定选择21位作为子网ID是一个很好的主意，因为你喜欢数字21。这给你带来了几百万个子网。
- en: 'The formula for subnet addresses in this case is rather long and complicated:
    x.*N*/8192.(*N*/32)%256.(*N*%32)*8\. Yikes. Well, this is a bit involved—so much
    so that it might be easier to just take a subnet number and do it in binary, the
    long way. But let''s take an example and see how it works for, say, subnet 987654\.
    The first octet is 21\. The second octet is 987654/8192, integer division. This
    is 120\. The third octet is (987654/32)%256\. The result of the division is 30864
    (you drop the fraction). Then you take 30864%256, which yields a remainder of
    144\. The fourth octet is (987654%32)*8\. This is 6*8 or 48\. So subnet address
    987654 is 21.120.144.48.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，子网地址的公式相当长且复杂：x.*N*/8192.(*N*/32)%256.(*N*%32)*8。哎呀。这有点复杂——复杂到可能更容易直接取一个子网号，用二进制的方式来做。但让我们用一个例子来看看它对子网987654是如何工作的。第一个八位字节是21。第二个八位字节是987654/8192，整数除法。这是120。第三个八位字节是(987654/32)%256。除法的结果是30864（省略小数部分）。然后你取30864%256，得到余数144。第四个八位字节是(987654%32)*8。这是6*8或48。因此，子网地址987654是21.120.144.48。
- en: (Don't drink and drive. Don't drink and subnet either.)
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: （不要酒后驾车。也不要酒后子网划分。）
- en: 'IP Subnetting Step 5: Determining Host Addresses for Each Subnet'
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP子网划分步骤5：确定每个子网的主机地址
- en: Once you know the addresses of each of the subnets in the network, you use these
    addresses as the basis for assigning IP addresses to the individual hosts in each
    subnet. You start by associating a subnet base address with each physical network
    (since at least in theory, the subnets correspond to the physical networks). You
    then sequentially assign hosts particular IP addresses within the subnet (or in
    a different manner, if you prefer!).
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了网络中每个子网地址，你就可以将这些地址作为分配给每个子网中各个主机IP地址的基础。你首先将每个物理网络与一个子网基本地址关联起来（因为至少在理论上，子网对应于物理网络）。然后，你按顺序在子网内为各个主机分配特定的IP地址（或者如果你愿意的话，用不同的方式！）。
- en: Determining host addresses is really quite simple once you know the subnet address.
    All you do is substitute the numbers 1, 2, 3, and so on for the host ID bits in
    the subnet address. You must do this in binary and then convert the address to
    decimal form. Again, you can take some shortcuts once the rather obvious pattern
    of how to assign addresses emerges. You'll look at those near the end of the chapter.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了子网地址，确定主机地址实际上非常简单。你所做的就是用数字1、2、3等替换子网地址中的主机ID位。你必须用二进制来做这件事，然后转换成十进制形式。再次提醒，一旦出现了如何分配地址的相当明显的模式，你就可以采取一些捷径。你将在本章的末尾看到这些。
- en: Class C Host Address Determination Example
  id: totrans-769
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C类主机地址确定示例
- en: 'Let''s start with the Class C example again, 211.77.20.0, which you divided
    into eight subnets using three subnet bits. Here''s how the address appears with
    the subnet bits shown in bold, and the host ID bits shown in italics:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次从Class C示例开始，211.77.20.0，你使用三个子网位将其划分为八个子网。以下是带有子网位（粗体）和主机ID位（斜体）显示的地址：
- en: '| 11010011 01001101 00010100 **000**00000 |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **000**00000 |'
- en: 'The first subnet is subnet 0, which has all zeros for those subnet bits, and
    thus the same address as the network as a whole: 211.77.20.0\. You substitute
    the numbers 1, 2, 3, and so on for the italicized bits to get the host IDs. (Remember
    that you don''t start with zero here because for the host ID, the all-zeros and
    all-ones binary patterns have special meaning). So it goes like this:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个子网是子网0，这些子网位全部为零，因此与整个网络的地址相同：211.77.20.0。你用1、2、3等数字替换斜体位以获得主机ID。记住，这里你不从零开始，因为对于主机ID，全零和全一的二进制模式有特殊含义。所以它如下所示：
- en: 'The first host address has the number 1 for the host ID, or 00001 in binary.
    So it is as follows:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主机地址的主机ID为1，或者二进制表示为00001。因此，它如下所示：
- en: '| 11010011 01001101 00010100 **000**00001 |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **000**00001 |'
- en: In decimal, this is 211.77.20.1.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制中，这是211.77.20.1。
- en: 'The second host address has the number 2 for the host ID, or 00010 in binary.
    Its binary value is as follows:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主机地址的主机ID为2，或者二进制表示为00010。它的二进制值如下所示：
- en: '| 11010011 01001101 00010100 **000**00010 |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **000**00010 |'
- en: In decimal, this is 211.77.20.2.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制中，这是211.77.20.2。
- en: I'm sure you get the picture already; the third host will be 211.77.20.3, the
    fourth 211.77.20.4, and so on. There is a maximum of 30 hosts in each subnet,
    as you saw earlier. So the last host in this subnet will be found by substituting
    30 (11110 in binary) for the host ID bits, resulting in a decimal address of 211.77.20.30.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经明白了；第三个主机将是211.77.20.3，第四个是211.77.20.4，以此类推。每个子网最多有30个主机，正如你之前看到的。因此，这个子网的最后一个主机将通过将30（二进制中的11110）替换为主机ID位来找到，结果是一个十进制地址211.77.20.30。
- en: You can do the same thing for each of the other subnets; the only thing that
    changes is the values in the subnet ID bits. Let's take subnet 6, for example.
    It has 110 for the subnet bits instead of 000\. So its subnet base address is
    211.77.20.192, or
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为其他每个子网做同样的事情；唯一改变的是子网ID位中的值。以子网6为例。它的子网位是110，而不是000。因此，它的子网基本地址是211.77.20.192，或者
- en: '| 11010011 01001101 00010100 **110**00000 |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **110**00000 |'
- en: 'You assign hosts to this subnet by substituting 00001, then 00010, then 00011
    for the host ID bits as shown earlier. Let''s take the hosts one at a time:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过替换主机ID位中的00001、然后00010、然后00011来分配主机到这个子网，如前所述。让我们逐个考虑主机：
- en: 'The first host address is as follows:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个主机地址如下所示：
- en: '| 11010011 01001101 00010100 **110**00001 |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **110**00001 |'
- en: or 211.77.20.193.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 或者211.77.20.193。
- en: The second host address is
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主机地址是
- en: '| 11010011 01001101 00010100 **110**00010 |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| 11010011 01001101 00010100 **110**00010 |'
- en: or 211.77.20.194.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 或者211.77.20.194。
- en: And so on, all the way up to the last host in the subnet, which is 211.77.20.222\.
    [Figure 19-8](ch19s05.html#determining_host_addresses_for_a_class_c "Figure 19-8. Determining
    host addresses for a Class C network This diagram shows how both subnet addresses
    and host addresses are determined in a two-step process. The subnet addresses
    are found by substituting subnet ID values (shown in bold) for the subnet ID bits
    of the network. Then, for any given subnet address, you can determine a host address
    by substituting a host number (shown in bold and italicized) for the host ID bits
    within that subnet. So, for example, host 2 in subnet 6 has 110 for the subnet
    ID and 00010 for the host ID, resulting in a final octet value of 11000010, or
    194.") shows graphically how subnet and host addresses are calculated for this
    sample network.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 以此类推，直到子网的最后一个主机，即211.77.20.222。[图19-8](ch19s05.html#determining_host_addresses_for_a_class_c
    "图19-8。确定C类网络的子网地址和主机地址。此图显示了如何通过两步过程图形化地计算此示例网络的子网地址和主机地址。子网地址是通过将子网ID值（以粗体显示）替换为网络中的子网ID位来找到的。然后，对于任何给定的子网地址，你可以通过在该子网中替换主机号（以粗体和斜体显示）来为主机ID位确定一个主机地址。例如，子网6中的主机2具有子网ID为110，主机ID为00010，最终八位值为11000010，或194。")显示了如何计算此示例网络的子网和主机地址。
- en: One more address you may wish to calculate is the broadcast address for the
    subnet. This is one of the special cases, as discussed in [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS"), found by substituting
    all ones for the host ID. For subnet 0, this would be 211.77.20.31\. For subnet
    6, it would be 211.77.20.223\. That's pretty much all there is to it.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想计算的是子网的广播地址。这是一个特殊情况，如第18章[第18章](ch18.html "第18章。IP子网地址（子网划分）概念")中讨论的那样，通过将所有位替换为主机ID来找到。对于子网0，这将是在211.77.20.31。对于子网6，它将是211.77.20.223。这就是全部内容。
- en: '![Determining host addresses for a Class C network This diagram shows how both
    subnet addresses and host addresses are determined in a two-step process. The
    subnet addresses are found by substituting subnet ID values (shown in bold) for
    the subnet ID bits of the network. Then, for any given subnet address, you can
    determine a host address by substituting a host number (shown in bold and italicized)
    for the host ID bits within that subnet. So, for example, host 2 in subnet 6 has
    110 for the subnet ID and 00010 for the host ID, resulting in a final octet value
    of 11000010, or 194.](httpatomoreillycomsourcenostarchimages287841.png.jpg)'
  id: totrans-791
  prefs: []
  type: TYPE_IMG
  zh: '![确定C类网络的宿主地址 此图展示了通过两步过程确定子网地址和宿主地址的方法。子网地址是通过将子网ID值（粗体显示）替换网络子网ID位来找到的。然后，对于任何给定的子网地址，你可以通过在该子网内将一个宿主号（粗体和斜体显示）替换宿主ID位来确定一个宿主地址。例如，子网6中的宿主2具有110作为子网ID和00010作为宿主ID，最终八位字节值为11000010，或194。](httpatomoreillycomsourcenostarchimages287841.png.jpg)'
- en: Figure 19-8. Determining host addresses for a Class C network This diagram shows
    how both subnet addresses and host addresses are determined in a two-step process.
    The subnet addresses are found by substituting subnet ID values (shown in bold)
    for the subnet ID bits of the network. Then, for any given subnet address, you
    can determine a host address by substituting a host number (shown in bold and
    italicized) for the host ID bits within that subnet. So, for example, host 2 in
    subnet 6 has 110 for the subnet ID and 00010 for the host ID, resulting in a final
    octet value of 11000010, or 194.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 图19-8. 确定C类网络的宿主地址 此图展示了通过两步过程确定子网地址和宿主地址的方法。子网地址是通过将子网ID值（粗体显示）替换网络子网ID位来找到的。然后，对于任何给定的子网地址，你可以通过在该子网内将一个宿主号（粗体和斜体显示）替换宿主ID位来确定一个宿主地址。例如，子网6中的宿主2具有110作为子网ID和00010作为宿主ID，最终八位字节值为11000010，或194。
- en: Class B Host Address Determination Example
  id: totrans-793
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B类宿主地址确定示例
- en: 'You can do the same thing for the Class B network, naturally. The address of
    that network is 166.113.0.0\. Now say you want to define the hosts that go in
    subnet 13\. You substitute 13 in binary (01101) for the subnet ID bits to get
    the following subnet address, which is shown with the subnet ID bits in bold and
    the host ID bits in italics:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然也可以为B类网络做同样的事情。该网络的地址是166.113.0.0。现在假设你想定义要放入子网13的宿主。你将13的二进制（01101）替换为子网ID位，得到以下子网地址，子网ID位用粗体显示，宿主ID位用斜体显示：
- en: '| 10100110 01110001 **01101**000 00000000 |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '| 10100110 01110001 **01101**000 00000000 |'
- en: This is the subnet address 166.113.104.0\. Now you have 11 bits of host ID,
    so you can have a maximum of 2,046 hosts. The first is found by substituting 000
    00000001 for the host ID bits, which gives an address of 166.113.104.1\. The second
    host is 166.113.104.2, and so on. The last is found by substituting 111 11111110,
    which gives an address of 166.113.111.254\. Note that since the host ID bits extend
    over two octets, two octets change as you increment the host ID, unlike the Class
    C example. The broadcast address is 166.113.111.255.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子网地址166.113.104.0。现在你有11位宿主ID，所以你可以有最多2046个宿主。第一个是通过将000 00000001替换为宿主ID位来找到的，这给出了地址166.113.104.1。第二个宿主是166.113.104.2，以此类推。最后一个是通过将111
    11111110替换，这给出了地址166.113.111.254。注意，由于宿主ID位跨越了两个八位字节，当你增加宿主ID时，两个八位字节都会改变，这与C类示例不同。广播地址是166.113.111.255。
- en: Tip
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In a subnetted network, the address of Host H within subnet
    number *S* is found by plugging in the binary value of *S* for the network''s
    subnet ID bits, and the binary value of *H* for the subnet''s host ID bits.'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在子网化网络中，子网号*S*内宿主H的地址是通过将*S*的二进制值插入网络的子网ID位，将*H*的二进制值插入子网的宿主ID位来找到的。'
- en: Shortcuts for Computing Host Addresses
  id: totrans-799
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算宿主地址的快捷方式
- en: As you can see, defining the host IDs is really quite straightforward. If you
    can substitute bits and convert to decimal, you have all you need to know. You
    can also see that, as was the case with defining the subnet addresses, there are
    patterns that you can use in defining host IDs and understanding how they work.
    These generally define ways for which you can more quickly determine certain host
    addresses by working directly in decimal instead of bothering with binary substitutions.
    This is a bit more complex conceptually, so proceed only if you are feeling a
    bit brave.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，定义主机ID实际上非常直接。如果你能替换位并转换为十进制，你就知道所有你需要知道的信息了。你还可以看到，正如定义子网地址的情况一样，在定义主机ID和理解它们如何工作方面，你可以使用一些模式。这些通常定义了你可以通过直接在十进制中工作而不是烦恼二进制替换来更快地确定某些主机地址的方法。这个概念上稍微复杂一些，所以只有当你感到有点勇敢时才继续。
- en: 'The following are some of the shortcuts you can use in determining host IP
    addresses in a subnet environment:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定子网环境中的主机IP地址时，你可以使用以下一些快捷方式：
- en: '**First Host Address** *The first host address is always the subnet address
    with the last octet incremented by 1*. So in the Class C example, subnet 3''s
    base address is 211.77.20.96\. The first host address in subnet 3 is thus 211.77.20.97.'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一个主机地址** *第一个主机地址总是子网地址，最后八位加1*。所以在C类示例中，子网3的基本地址是211.77.20.96。因此，子网3的第一个主机地址是211.77.20.97。'
- en: '**Subsequent Host Addresses** After you find the first host address, to get
    the next one, you just add one to the last octet of the previous address. If this
    makes the last octet 256 (which can happen only if there are more than eight host
    ID bits), you "wrap around" this to zero and increment the third octet.'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '**后续主机地址** 找到第一个主机地址后，要获取下一个地址，你只需将前一个地址的最后八位加1。如果这使得最后八位为256（这只有在有超过八位的主机ID位时才会发生），你“回绕”到零并增加第三八位。'
- en: '**Directly Calculating Host Addresses** If the number of host ID bits is eight
    or less, you can find host *N*''s address by adding *N* to the last octet''s decimal
    value. For example, in the Class C example, subnet 3''s base address is 211.77.20.96\.
    Therefore, host 23 in this subnet has an address of 211.77.20.119\. If there are
    more than eight bits in the host ID, this works for only the first 255 hosts,
    after which you need to wrap around and increase the value of the third octet.
    Consider again subnet 13 in the Class B example, which has a base address of 166.113.104.0\.
    Host 214 on this subnet has address 166.113.104.0, but host 314 isn''t 166.113.104.314\.
    It is 166.113.105.58 (host 255 is 166.113.104.255, then host 256 is 166.113.105.0,
    and you count up 58 more (314–256) to get to 314, 166.113.105.58).'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接计算主机地址** 如果主机ID的位数是八位或更少，你可以通过将N加到最后八位的十进制值来找到主机*N*的地址。例如，在C类示例中，子网3的基本地址是211.77.20.96。因此，这个子网中的主机23的地址是211.77.20.119。如果有超过八位的主机ID位，这仅适用于前255个主机，之后你需要回绕并增加第三八位的值。再次考虑B类示例中的子网13，其基本地址为166.113.104.0。这个子网上的主机214的地址是166.113.104.0，但主机314不是166.113.104.314。它是166.113.105.58（主机255是166.113.104.255，然后主机256是166.113.105.0，你再数58个（314-256）以得到314，166.113.105.58）。'
- en: '**Range of Host Addresses** For a range of hosts for any subnet, the first
    address is the base address of subnet with last octet incremented by one. The
    last address is the base address of *next subnet after this one*, less two in
    the last octet (which may require changing a 0 in the last octet to 254 and reducing
    the value of the third octet by 1). For example, consider subnet 17 in the Class
    B example. Its subnet address is 166.113.136.0\. The address of subnet 18 is 166.113.144.0\.
    So the range of hosts for subnet 17 is 166.113.136.1 to 166.113.143.254.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '**主机地址范围** 对于任何子网的主机范围，第一个地址是子网的基本地址，最后八位加1。最后一个地址是此子网之后下一个子网的基本地址，最后八位减2（这可能需要将最后八位中的0改为254，并将第三八位的值减少1）。例如，考虑B类示例中的子网17。其子网地址是166.113.136.0。子网18的地址是166.113.144.0。因此，子网17的主机地址范围是166.113.136.1到166.113.143.254。'
- en: '**Broadcast Address** *The broadcast address for a subnet is always one less
    than the base address of the subsequent subnet*. Or alternatively, one more than
    the last real host address of the subnet. So for subnet 17 in the Class B example,
    the broadcast address is 166.113.143.255.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播地址** *子网的广播地址总是比下一个子网的基本地址少1*。或者，也可以说是比子网的最后一个实际主机地址多1。所以在B类示例中的子网17，广播地址是166.113.143.255。'
- en: Did I just confuse you? Well, remember that these are shortcuts, and sometimes
    when you take a shortcut, you get lost. Just kidding; it's really not that hard
    once you play around with it a bit.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我是不是让你困惑了？好吧，记住这些只是捷径，有时当你走捷径时，你可能会迷失方向。开个玩笑；一旦你玩得多了，其实并不难。
- en: 'In closing, remember the following quick summary when working with IP addresses
    in a subnet environment:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，当在子网环境中处理IP地址时，请记住以下快速总结：
- en: The network ID is the same for all hosts in all subnets and for all subnets
    in the network.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络ID对于所有子网中的所有主机以及网络中的所有子网都是相同的。
- en: The subnet ID is the same for all hosts in each subnet, but it's unique to each
    subnet in the network.
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网ID对于每个子网中的所有主机都是相同的，但在网络中每个子网是唯一的。
- en: The host ID is unique within each subnet. Each subnet has the same set of host
    IDs.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机ID在每个子网内是唯一的。每个子网都有相同的主机ID集合。
- en: Subnetting is fun! (Okay, okay, sorry….)
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子网编址很有趣！（好吧，好吧，对不起……）
- en: Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING
  id: totrans-813
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章。IP无类编址—无类域间路由（CIDR）/超网
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: As the Internet began to grow dramatically, three main problems arose with the
    original classful addressing scheme described in the previous chapters. These
    difficulties were addressed partially through subnet addressing, which provides
    more flexibility for the administrators of individual networks on an Internet.
    Subnetting, however, doesn't really tackle the problems in general terms. Some
    of these issues remain due to the use of classes even with subnets.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的急剧增长，在前面章节中描述的原有按类编址方案出现了三个主要问题。这些问题部分通过子网编址得到解决，这为互联网上各个网络的管理员提供了更多的灵活性。然而，子网编址并没有真正从一般意义上解决这些问题。由于使用了类别，一些问题仍然存在。
- en: While development began on version 6 of the Internet Protocol (IPv6; see [Part II-4](pt07.html
    "Part II-4. INTERNET PROTOCOL VERSION 6 (IPV6)")) and its roomy 128-bit addressing
    system in the mid-1990s, developers recognized that it would take many years before
    widespread deployment of IPv6 would be possible. In order to extend the life of
    IPv4 until the newer version could be completed, it was necessary to take a new
    approach to addressing IPv4 devices. This new system calls for eliminating the
    notion of address classes entirely, creating a new *classless addressing* scheme
    sometimes called *Classless Inter-Domain Routing (CIDR)*.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在20世纪90年代中期开始开发互联网协议（IPv6；参见[第二部分-4](pt07.html "第二部分-4。互联网协议版本6（IPv6）"))及其宽敞的128位编址系统，但开发者认识到，在IPv6得到广泛部署之前还需要许多年。为了在新的版本完成之前延长IPv4的生命周期，有必要采取一种新的方法来编址IPv4设备。这个新系统要求完全消除地址类别的概念，创建一个新的*无类编址*方案，有时称为*无类域间路由（CIDR）*。
- en: In this chapter, I describe modern classless IP addressing. I begin with an
    overview of the concepts behind classless addressing and the idea behind *supernetting*,
    including why it was created and what its advantages and disadvantages are. I
    then define CIDR and describe how the system works in more detail, including the
    notation used for address blocks. I list each of the CIDR address block sizes
    and show how they relate to the older Class A, B, and C networks. I conclude with
    a CIDR addressing example that's similar to the examples in [Chapter 19](ch19.html
    "Chapter 19. IP SUBNETTING PRACTICAL SUBNET DESIGN AND ADDRESS DETERMINATION EXAMPLE"),
    but this one focuses on CIDR and is a bit more condensed.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了现代的无类IP编址。我首先概述了无类编址背后的概念和*超网*背后的想法，包括为什么它被创建以及它的优缺点。然后我定义了CIDR，并更详细地描述了该系统的工作原理，包括用于地址块的符号。我列出了每个CIDR地址块的大小，并展示了它们如何与较老的A类、B类和C类网络相关联。最后，我给出了一个CIDR编址示例，它与[第19章](ch19.html
    "第19章。IP子网划分实践子网设计和地址确定示例")中的示例类似，但这个示例专注于CIDR，并且更加简洁。
- en: IP Classless Addressing and Supernetting Overview
  id: totrans-818
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无类IP编址和超网概述
- en: Subnet addressing was an important development in the evolution of IP addressing,
    because it solved some important issues with the conventional, two-level class-based
    addressing scheme. Subnetting's contribution to flexibility in IP addressing was
    to allow each network to have its own two-level hierarchy, thereby giving the
    administrator of each network the equivalent of an Internet within the Internet.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 子网地址划分是IP地址划分演变过程中的一个重要发展，因为它解决了传统两级基于类别的地址方案的一些重要问题。子网划分对IP地址划分灵活性的贡献是允许每个网络拥有自己的两级层次结构，从而为每个网络管理员提供了相当于互联网内部的互联网。
- en: 'When you looked at the advantages of subnetting in [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS"), you saw that subnetting was local within
    each organization and invisible to other organizations. This is an advantage in
    that it lets each organization tailor its network without other groups having
    to worry about the details of how this is done. Unfortunately, this invisibility
    also represents a key *disadvantage* of subnetted classful addressing: It cannot
    correct the fundamental inefficiencies associated with that type of addressing,
    because organizations are still assigned address blocks based on classes.'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第18章](ch18.html "第18章. IP子网地址划分（子网划分）概念")中看到子网划分的优势时，你会发现子网划分在每个组织内部是局部的，对其他组织来说是不可见的。这是一个优势，因为它允许每个组织根据需要定制其网络，而无需其他团体担心如何操作的细节。不幸的是，这种不可见性也代表了子网化类地址划分的一个关键*缺点*：它不能纠正与那种类型地址划分相关的根本低效，因为组织仍然根据类别分配地址块。
- en: The Main Problem with Classful Addressing
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类地址划分的主要问题
- en: A key weakness of the subnetting system is its low granularity. A Class B address
    block contains a very large number of addresses (65,534), but a Class C block
    has only a relatively small number (254). There are many thousands of medium-sized
    organizations that need more than 254 IP addresses, but a small percentage of
    these needs 65,534 or anything even close to it. (The lack of a good match to
    a medium-sized organization with 5,000 hosts is illustrated in [Figure 17-5](ch17s07.html#the_main_problem_with_classful_addressin
    "Figure 17-5. The main problem with classful addressing In this scale diagram,
    each square represents 50 available addresses. Since a Class C address has only
    254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000
    hosts is caught in the middle. It can only choose to either waste 90 percent of
    a Class B address or use 20 different Class C networks.") in [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING").) When setting up their networks,
    these companies and groups would tend to request Class B address blocks and not
    Class C blocks, because they needed more than 254 hosts, without considering how
    many of the 65,000-odd addresses they really would use.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 子网划分系统的关键弱点是其粒度低。一个B类地址块包含一个非常大的地址数量（65,534），但一个C类地址块只有相对较小的数量（254）。有成千上万的组织中等的组织需要超过254个IP地址，但其中只有一小部分需要65,534个或任何接近这个数量的地址。（[图17-5](ch17s07.html#the_main_problem_with_classful_addressin
    "图17-5. B类地址划分的主要问题 在这个比例图中，每个方块代表50个可用的地址。由于C类地址只有254个地址，而B类地址包含65,534个地址，拥有5000个主机的组织处于中间位置。它只能选择浪费90%的B类地址或者使用20个不同的C类网络。")说明了在[第17章](ch17.html
    "第17章. 类地址划分")中中等规模组织与5,000个主机匹配不良的问题。）当这些公司和团体设置他们的网络时，他们往往会请求B类地址块而不是C类地址块，因为他们需要超过254个主机，而不考虑他们实际上会使用65,000多个地址中的多少。
- en: Due to how the classes of the older system were designed, there are over two
    million Class C address blocks, but only 16,384 Class B networks. While 16,384
    seems like a lot at first glance, there are millions of organizations and corporations
    around the world. Class B allocations were being consumed at a rapid pace, while
    the smaller Class C networks were relatively unused.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 由于旧系统中的类别设计方式，有超过两百万个C类地址块，但只有16,384个B类网络。乍一看，16,384似乎很多，但世界上有成千上万的组织和公司。B类分配正在迅速消耗，而较小的C类网络相对未被使用。
- en: The folks handing out Internet addresses needed a way to better utilize the
    address space so that it would not run out before the transition to IPv6\. Subnetting
    didn't help a great deal with this problem. Why? Because it only works *within*
    the classful address blocks. If an organization needing 2,000 IP addresses requested
    a Class B block, they could use subnetting to more efficiently manage their block.
    However, subnetting could do nothing about the fact that this organization would
    never use over 62,000 of the addresses in its block—about 97 percent of their
    allocated address space.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 分配互联网地址的人们需要一种更好的方式来利用地址空间，以便在过渡到IPv6之前不会耗尽。子网划分在这方面并没有太大的帮助。为什么？因为它只适用于**类别**地址块内部。如果一个需要2,000个IP地址的组织请求一个B类块，他们可以使用子网划分来更有效地管理他们的块。然而，子网划分对这样一个事实无能为力：这个组织永远不会使用其块中超过62,000个地址——大约97%的分配地址空间。
- en: 'The only solution to this would be to convince—or at worst case, force—companies
    to use many smaller Class C blocks instead of wasting the bulk of a Class B assignment.
    Many organizations resisted this due to the complexity involved, and this caused
    the other main problem that subnetting didn''t correct: the growth of Internet
    routing tables. Replacing one Class B network with 10 Class C networks means ten
    times as many entries for routers to maintain.'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一方法就是说服——在最坏的情况下，强迫——公司使用许多较小的C类块而不是浪费B类分配的大部分。许多组织由于涉及到的复杂性而抵制这种做法，这导致了另一个主要问题，即子网划分没有解决的问题：互联网路由表的增长。用一个B类网络替换10个C类网络意味着路由器需要维护的条目数量增加了十倍。
- en: 'The Solution: Eliminate Address Classes'
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案：消除地址类别
- en: 'It was clear that as long as there were only three sizes of networks, the allocation
    efficiency problem could never be properly rectified. The solution was to get
    rid of the classes completely, in favor of a *classless* allocation scheme. This
    system would solve both of the main problems with classful addressing: inefficient
    address space use and the exponential growth of routing tables.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，只要网络只有三种大小，分配效率问题就永远无法得到妥善解决。解决方案是完全取消类别，转而采用**无类别**分配方案。这个系统将解决类别地址的主要两个问题：地址空间使用效率低下和路由表指数级增长。
- en: This system was developed in the early 1990s and formalized in 1993 in RFCs
    1517, 1518, 1519, and 1520\. The technology was called *Classless Inter-Domain
    Routing (CIDR)*. Despite this name, the scheme deals with both addressing and
    routing matters, since they are inextricably linked.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统是在20世纪90年代初开发的，并在1993年的RFC 1517、1518、1519和1520中正式化。这项技术被称为**无类别域间路由（CIDR）**。尽管这个名字如此，但该方案处理了地址和路由问题，因为它们是密不可分的。
- en: 'The idea behind CIDR is to adapt the concept of subnetting a single network
    to the entire Internet. In essence, classless addressing means that instead of
    breaking a particular network into subnets, you can aggregate networks into larger
    "supernets." CIDR is sometimes called *supernetting* for this reason: It applies
    the principles of subnetting to larger networks. It is this aggregation of networks
    into supernets that allowed CIDR to resolve the problem of growing Internet routing
    tables.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: CIDR背后的想法是将单个网络的子网划分概念应用到整个互联网上。本质上，无类别地址意味着你不需要将特定网络划分为子网，而是可以将网络聚合到更大的“超网”中。正因为如此，CIDR有时被称为**超网划分**：它将子网划分的原则应用到更大的网络上。正是这种将网络聚合到超网中的做法，使得CIDR能够解决互联网路由表增长的问题。
- en: Of course, if you are going to apply subnetting concepts to the entire Internet,
    you need to be able to have subnets of different sizes. After all, that's one
    of the primary goals in eliminating the classes. So, more accurately, CIDR is
    an Internet-wide application of not just regular one-level subnetting, but of
    Variable Length Subnet Masking (VLSM), introduced in [Chapter 18](ch18.html "Chapter 18. IP
    SUBNET ADDRESSING (SUBNETTING) CONCEPTS"). Just as VLSM allows you split a network
    as many times as you want to create subnets, sub-subnets, and sub-sub-subnets,
    CIDR lets you do this with the entire Internet, as many times as needed.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你打算将子网划分的概念应用到整个互联网上，你需要能够拥有不同大小的子网。毕竟，消除类别的一个主要目标就是实现这一点。因此，更准确地说，CIDR不仅是在整个互联网上应用了一级子网划分，还包括了在[第18章](ch18.html
    "第18章。IP子网地址（子网划分）概念”）中引入的可变长度子网掩码（VLSM）。正如VLSM允许你根据需要将网络划分成任意多次以创建子网、子子网和子子子网一样，CIDR也允许你将整个互联网进行这样的划分，次数不限。
- en: Tip
  id: totrans-831
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Classless Inter-Domain Routing (CIDR)* is a system of IP addressing
    and routing that solves the many problems of classful addressing by eliminating
    fixed address classes in favor of a flexible, multiple-level, hierarchical structure
    of networks of varying sizes.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *无类别域间路由（CIDR）*是一种IP编址和路由系统，通过消除固定地址类别，采用灵活的、多级、分层结构来解决类别编址的许多问题。'
- en: The Many Benefits of Classless Addressing and Routing
  id: totrans-833
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无类别编址和路由的众多好处
- en: 'CIDR provides numerous advantages over the classful addressing scheme, whether
    or not subnetting is used:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否使用子网划分，CIDR相对于类别编址方案都提供了许多优势：
- en: '**Efficient Address Space Allocation** Instead of allocating addresses in fixed-size
    blocks of low granularity, under CIDR, addresses are allocated in sizes of any
    binary multiple. So a company that needs 5,000 addresses can be assigned a block
    of 8,190 instead of 65,534, as shown in [Figure 20-1](ch20.html#classless_addressing_cidr_solves_the_gra
    "Figure 20-1. Classless addressing (CIDR) solves the granularity problem Figure 17-5
    in Chapter 17 illustrates the primary problem with classful addressing: the great
    distance between the size of Class B and Class C networks. CIDR solves this issue
    by allowing any number of bits to be used for the network ID. In the case of an
    organization with 5,000 hosts, a /19 network with 8,190 hosts can be assigned.
    This reduces the address space waste for such an organization by about 95.").
    Or to think of it another way, the equivalent of a single Class B network can
    be shared among eight companies that each need 8,190 or fewer IP addresses.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '**高效的地址空间分配** 在CIDR中，地址不是在固定大小的低粒度块中分配，而是在任意二进制倍数的大小中分配。因此，一个需要5,000个地址的公司可以分配一个8,190个地址的块，而不是65,534个地址，如图[图20-1](ch20.html#classless_addressing_cidr_solves_the_gra
    "图20-1。无类别编址（CIDR）解决了粒度问题 图17-5在第17章中说明了类别编址的主要问题：B类和C类网络大小之间的巨大差距。CIDR通过允许使用任意数量的位来表示网络ID来解决此问题。对于一个拥有5,000个主机的组织，可以分配一个/19网络，该网络有8,190个主机。这减少了此类组织地址空间的浪费，大约减少了95%。")所示。或者换一种方式思考，一个B类网络的等效地址可以由需要8,190个或更少IP地址的八家公司共享。'
- en: '**Elimination of Class Imbalances** There are no more Class A, B, and C networks,
    so there is no problem with some portions of the address space being widely used
    while others are neglected.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**消除类别不平衡** 没有更多A类、B类和C类网络，因此不存在某些地址空间部分被广泛使用而其他部分被忽视的问题。'
- en: '**Efficient Routing Entries** CIDR''s multiple-level hierarchical structure
    allows a small number of routing entries to represent a large number of networks.
    Network descriptions can be aggregated and represented by a single entry. Since
    CIDR is hierarchical, the detail of lower-level, smaller networks can be hidden
    from routers that move traffic between large groups of networks. This is discussed
    more completely in [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING"),
    which covers IP routing issues.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '**高效的路由条目** CIDR的多级分层结构允许少量路由条目代表大量网络。网络描述可以被聚合并由单个条目表示。由于CIDR是分层的，因此可以隐藏低级别、较小网络的详细信息，这些信息对于在大型网络组之间移动流量的路由器来说是隐藏的。这一点在[第23章](ch23.html
    "第23章。IP路由和多播")中有更详细的讨论，该章节涵盖了IP路由问题。'
- en: '**No Separate Subnetting Method** CIDR implements the concepts of subnetting
    within the Internet itself. An organization can use the same method used on the
    Internet to subdivide its internal network into subnets of arbitrary complexity,
    without needing a separate subnetting mechanism.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需单独的子网划分方法** CIDR在互联网本身中实现了子网划分的概念。一个组织可以使用在互联网上使用的相同方法将其内部网络划分为任意复杂性的子网，而无需单独的子网划分机制。'
- en: '![Classless addressing (CIDR) solves the granularity problem in illustrates
    the primary problem with classful addressing: the great distance between the size
    of Class B and Class C networks. CIDR solves this issue by allowing any number
    of bits to be used for the network ID. In the case of an organization with 5,000
    hosts, a /19 network with 8,190 hosts can be assigned. This reduces the address
    space waste for such an organization by about 95.](httpatomoreillycomsourcenostarchimages287843.png.jpg)'
  id: totrans-839
  prefs: []
  type: TYPE_IMG
  zh: '![无类别编址（CIDR）解决了粒度问题，如图所示类别编址的主要问题：B类和C类网络大小之间的巨大差距。CIDR通过允许使用任意数量的位来表示网络ID来解决此问题。对于一个拥有5,000个主机的组织，可以分配一个/19网络，该网络有8,190个主机。这减少了此类组织地址空间的浪费，大约减少了95%。](httpatomoreillycomsourcenostarchimages287843.png.jpg)'
- en: 'Figure 20-1. Classless addressing (CIDR) solves the granularity problem [Figure 17-5](ch17s07.html#the_main_problem_with_classful_addressin
    "Figure 17-5. The main problem with classful addressing In this scale diagram,
    each square represents 50 available addresses. Since a Class C address has only
    254 addresses, and a Class B contains 65,534 addresses, an organization with 5,000
    hosts is caught in the middle. It can only choose to either waste 90 percent of
    a Class B address or use 20 different Class C networks.") in [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING") illustrates the primary problem
    with classful addressing: the great distance between the size of Class B and Class
    C networks. CIDR solves this issue by allowing any number of bits to be used for
    the network ID. In the case of an organization with 5,000 hosts, a /19 network
    with 8,190 hosts can be assigned. This reduces the address space waste for such
    an organization by about 95.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 图20-1. 无类地址（CIDR）解决了粒度问题[图17-5](ch17s07.html#the_main_problem_with_classful_addressin
    "图17-5. 无类地址的主要问题 在这个比例图中，每个方块代表50个可用的地址。由于C类地址只有254个地址，而B类地址包含65,534个地址，拥有5,000个主机的组织处于中间位置。它只能选择浪费90%的B类地址或者使用20个不同的C类网络。")在[第17章](ch17.html
    "第17章. 类别地址（传统地址）")中说明了类别地址的主要问题：B类和C类网络大小之间的巨大差距。CIDR通过允许使用任意数量的位来表示网络ID来解决这一问题。对于一个拥有5,000个主机的组织，可以分配一个/19网络，包含8,190个主机。这减少了此类组织地址空间的浪费，大约95%。
- en: Since the main benefit of classful addressing was its simplicity, it's no surprise
    that the main drawback of CIDR is its greater complexity. One issue is that it
    is no longer possible to determine, by looking at the first octet, how many bits
    of an IP address represent the network ID and how many represent the host ID.
    A bit more care needs to be used in setting up routers as well, to make sure that
    routing is accomplished correctly.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类别地址的主要优点是其简单性，因此CIDR的主要缺点是其复杂性增加也就不足为奇了。一个问题是通过查看第一个八位字节，现在无法确定IP地址中有多少位代表网络ID，有多少位代表主机ID。在设置路由器时也需要更加小心，以确保正确完成路由。
- en: 'IP Supernetting: CIDR Hierarchical Addressing and Notation'
  id: totrans-842
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP超网：CIDR分层地址和表示法
- en: When you first looked at IP addressing in [Chapter 17](ch17.html "Chapter 17. CLASSFUL
    (CONVENTIONAL) ADDRESSING"), you saw that IP addresses were designed to be divided
    into a network identifier (network ID) and host identifier (host ID). Then, when
    subnets were introduced, you "stole" bits from the host ID to create a subnet
    ID, giving the IP address a total of three hierarchical levels. With VLSM, you
    further subnetted the subnets, taking more bits from the host ID to give you a
    multiple-level hierarchy with sub-subnets, sub-sub-subnets, and so forth.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次在[第17章](ch17.html "第17章. 类别地址（传统地址）")中查看IP地址时，你看到IP地址被设计成分为网络标识符（网络ID）和主机标识符（主机ID）。然后，当引入子网时，你从主机ID“偷取”位来创建子网ID，使IP地址具有总共三个层次。使用VLSM，你进一步对子网进行子网划分，从主机ID中取出更多位，从而得到一个多级层次结构，包括子子网、子子子网等等。
- en: In a classless environment, you completely change how you look at IP addresses
    by applying VLSM concepts not just to one network, but to the entire Internet.
    In essence, the Internet becomes just one giant network that is subnetted into
    a number of large blocks. Some of these large blocks are then broken down into
    smaller blocks, which can in turn be broken down further. This breaking down can
    occur multiple times, allowing you to split the "pie" of Internet addresses into
    slices of many different sizes to suit the needs of the organization.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在无类环境中，你通过应用VLSM概念，不仅针对一个网络，而是针对整个互联网，完全改变了看待IP地址的方式。本质上，互联网变成了一个巨大的网络，被划分为多个大型块。其中一些大型块随后被划分为更小的块，这些块又可以进一步划分。这种划分可以多次发生，允许你将互联网地址的“饼”分割成许多不同大小的片，以满足组织的需要。
- en: As the name implies, classless addressing completely eliminates the prior notions
    of classes. There are no more Class A, B, and C blocks that are divided by the
    first few bits of the address. Instead, under CIDR, all Internet blocks can be
    of arbitrary size. Instead of having all networks use 8 (Class A), 16 (Class B),
    or 24 (Class C) bits for the network ID, you can have large networks with, say,
    13 bits for the network ID (leaving 19 bits for the host ID), or very small ones
    that use 28 bits for the network ID (only 4 bits for the host ID). The size of
    the network is still based on the binary power of the number of host ID bits.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，无类别寻址完全消除了之前的类别概念。不再有A类、B类和C类块，它们由地址的前几位来划分。在CIDR下，所有互联网块都可以是任意大小。你不必让所有网络都使用8位（A类）、16位（B类）或24位（C类）作为网络ID，你可以有大型网络，例如，使用13位作为网络ID（留下19位用于主机ID），或者非常小的网络，使用28位作为网络ID（只有4位用于主机ID）。网络的大小仍然基于主机ID位数的二进制幂。
- en: CIDR (Slash) Notation
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIDR（斜线）表示法
- en: 'You''ll recall that when you used subnetting, you had a problem: Subnetting
    could be done by taking any number of available host ID bits, so how would devices
    know where the line was between the subnet ID and host ID? The same problem occurs
    under CIDR. There are no classes, so you can''t tell anything by looking at the
    first few bits of an IP address. Since addresses can have the dividing point between
    host ID and network ID occur anywhere, you need additional information in order
    to interpret IP addresses properly. Under CIDR, this impacts not only addresses
    within an organization, but also addresses in the entire Internet, since there
    are no classes and each network can be a different size.'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，当你使用子网划分时，你遇到了一个问题：子网划分可以通过取任意数量的可用主机ID位来完成，那么设备如何知道子网ID和主机ID之间的界限在哪里？在CIDR下也会出现同样的问题。没有类别，所以通过查看IP地址的前几位无法得知任何信息。由于地址的主机ID和网络ID之间的分隔点可以出现在任何位置，因此你需要额外的信息来正确解释IP地址。在CIDR下，这不仅影响组织内的地址，还影响整个互联网的地址，因为不存在类别，每个网络都可以是不同的大小。
- en: For this reason, just as subnetting required the use of a subnet mask to show
    which bits belong to the network ID or subnet ID and which belong to the host
    ID, CIDR uses a subnet mask to show where the line is drawn between host ID and
    network ID. However, for simplicity, under CIDR you don't usually work with 32-bit
    binary subnet masks. Instead, you use *slash notation*, more properly called *CIDR
    notation*. This notation shows the size of the network, sometimes called the *prefix
    length*, by following an IP address with an integer that tells you how many bits
    are used for the network ID (prefix).
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如子网划分需要使用子网掩码来显示哪些位属于网络ID或子网ID，哪些位属于主机ID一样，CIDR也使用子网掩码来显示主机ID和网络ID之间的界限在哪里。然而，为了简化，在CIDR下，你通常不使用32位的二进制子网掩码。相反，你使用*斜线表示法*，更准确地称为*CIDR表示法*。这种表示法通过在IP地址后跟一个整数来显示网络的大小，有时称为*前缀长度*，这个整数告诉你用于网络ID（前缀）的位数。
- en: Tip
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since there are no address classes in CIDR, you cannot tell
    the size of the network ID of an address from the address alone. In CIDR, the
    length of the prefix (network ID) is indicated by placing it following a slash
    after the address. This is called *CIDR notation*, or *slash notation*.'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于CIDR中没有地址类别，你不能仅从地址本身判断网络ID的大小。在CIDR中，前缀（网络ID）的长度通过在地址后跟一个斜线来表示。这被称为*CIDR表示法*，或*斜线表示法*。'
- en: 'For example, consider the network specification 184.13.152.0/22\. The 22 means
    this network has 22 bits for the network ID and 10 bits for the host ID. This
    is equivalent to specifying a network with an address of 184.13.152.0 and a subnet
    mask of 255.255.252.0, as you can see in [Figure 20-2](ch20s02.html#cidr_slash_notation_and_its_subnet_mask_
    "Figure 20-2. CIDR (slash) notation and its subnet mask equivalent A classless
    network is normally specified in CIDR, or slash notation, such as this example:
    184.13.152.0/22\. Here, the /22 means the first 22 bits of the address are the
    network ID. The equivalent subnet mask can be calculated by creating a 32-bit
    number with 22 ones followed by 10 zeros."). This sample network provides a total
    of 1,022 hosts (210–2). The table in the following section shows all the different
    possible network sizes that can be configured under CIDR.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑网络规范184.13.152.0/22。这里的22表示这个网络有22位用于网络ID，10位用于主机ID。这相当于指定一个地址为184.13.152.0，子网掩码为255.255.252.0的网络，正如你可以在[图20-2](ch20s02.html#cidr_slash_notation_and_its_subnet_mask_
    "图20-2. CIDR（斜杠）表示法及其子网掩码等效图。无类别网络通常在CIDR或斜杠表示法中指定，例如这个示例：184.13.152.0/22。这里，/22表示地址的前22位是网络ID。等效的子网掩码可以通过创建一个32位数字，其中前22位是1，后面跟着10位是0来计算。")中看到的那样。这个示例网络总共提供了1,022个主机（2^10-2）。下一节中的表格显示了在CIDR下可以配置的所有不同可能的网络大小。
- en: '![CIDR (slash) notation and its subnet mask equivalent A classless network
    is normally specified in CIDR, or slash notation, such as this example: 184.13.152.0/22\.
    Here, the /22 means the first 22 bits of the address are the network ID. The equivalent
    subnet mask can be calculated by creating a 32-bit number with 22 ones followed
    by 10 zeros.](httpatomoreillycomsourcenostarchimages287845.png.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![CIDR（斜杠）表示法及其子网掩码等效图](httpatomoreillycomsourcenostarchimages287845.png.jpg)'
- en: 'Figure 20-2. CIDR (slash) notation and its subnet mask equivalent A classless
    network is normally specified in CIDR, or slash notation, such as this example:
    184.13.152.0/22\. Here, the /22 means the first 22 bits of the address are the
    network ID. The equivalent subnet mask can be calculated by creating a 32-bit
    number with 22 ones followed by 10 zeros.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 图20-2. CIDR（斜杠）表示法及其子网掩码等效图。无类别网络通常在CIDR或斜杠表示法中指定，例如这个示例：184.13.152.0/22。这里，/22表示地址的前22位是网络ID。等效的子网掩码可以通过创建一个32位数字，其中前22位是1，后面跟着10位是0来计算。
- en: Note
  id: totrans-854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You may recall that under classful subnetting, the bits used for the subnet
    ID did not need to be contiguous. Even though this ability was almost never used
    to avoid confusion, noncontiguous subnet ID bits were possible. Under CIDR, the
    requirement for contiguous subnet ID bits has been made official—you could not
    use slash notation otherwise*.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能还记得，在类别子网划分中，用于子网ID的位不需要连续。尽管这种能力几乎从未被用来避免混淆，但非连续的子网ID位是可能的。在CIDR中，对连续子网ID位的要求已经正式化——否则你不能使用斜杠表示法*。'
- en: 'Supernetting: Subnetting the Internet'
  id: totrans-856
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超网划分：互联网的子网划分
- en: In theory, then, what CIDR does is provide the central address-assignment authority
    with the flexibility to hand out address blocks of different sizes to organizations
    based on their need. However, when CIDR was developed, a shift was made in the
    method by which public IP addresses were assigned. Having everyone in the world
    attempt to get addresses from one organization wasn't the best method. It was
    necessary under the classful scheme because the hierarchy was only two levels
    deep. The Internet Assigned Numbers Authority (IANA) handed out network IDs to
    everyone, who then assigned host IDs (or subnetted).
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，CIDR所做的是为中央地址分配权威机构提供灵活性，根据组织的需求分配不同大小的地址块。然而，当CIDR被开发时，公共IP地址分配的方法发生了变化。让世界上每个人都试图从一个组织获取地址并不是最好的方法。在类别子网划分方案下这是必要的，因为层次结构只有两层深。互联网数字分配机构（IANA）向每个人分配网络ID，然后他们分配主机ID（或进行子网划分）。
- en: 'Under CIDR, you have many hierarchical levels: You split big blocks into smaller
    blocks, and then still-smaller blocks, and so on. It makes sense to manage blocks
    in a similar hierarchical manner as well. So what happens is that IANA/ICANN divides
    addresses into large blocks, which it distributes to the four *regional Internet
    registries (RIRs)*: APNIC, ARIN, LACNIC, and RIPE NCC. These then further divide
    the address blocks and distribute them to lower-level national Internet registries
    (NIRs), local Internet registries (LIRs), and/or individual organizations such
    as Internet service providers (ISPs). This is all explained in the background
    discussion of Internet authorities and registries in [Chapter 3](ch03.html "Chapter 3. NETWORK
    STANDARDS AND STANDARDS ORGANIZATIONS").'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 在CIDR下，你有许多分层级别：你将大块分割成小块，然后再将小块分割成更小的块，依此类推。以类似分层的方式管理块是有意义的。所以，实际上，IANA/ICANN将地址划分为大块，并将其分配给四个*区域互联网注册机构（RIRs）*：APNIC、ARIN、LACNIC和RIPE
    NCC。然后，它们进一步将地址块分割并分配给下一级的国家互联网注册机构（NIRs）、本地互联网注册机构（LIRs）和/或个人组织，例如互联网服务提供商（ISPs）。这一切都在[第3章](ch03.html
    "第3章. 网络标准和标准组织")中关于互联网权威机构和注册机构的背景讨论中解释。
- en: ISPs can then divide these blocks into smaller ones and then allocate them to
    their customers. These customers are sometimes smaller ISPs themselves, which
    repeat the process. They split their blocks into pieces of different sizes and
    allocate them to their customers, some of whom are even smaller ISPs and some
    of whom are end users. The number of times this can occur is limited only by how
    many addresses are in the original block.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，ISP可以将这些块分割成更小的块，并将它们分配给客户。这些客户有时本身就是较小的ISP，它们会重复这个过程。他们将块分割成不同大小的块，并将它们分配给客户，其中一些客户甚至是更小的ISP，还有一些是最终用户。这种分割可以发生的次数仅限于原始块中的地址数量。
- en: It's also worth noting that while CIDR is based on subnetting concepts, subnetting
    itself is not used in CIDR—or at least, not in the way it is used under classful
    addressing. There is no explicit subnetting using a subnet ID within CIDR. All
    IP addresses are interpreted only as having a network ID and a host ID. An organization
    does the equivalent of subnetting by dividing its own network into subnetworks
    using the same general method that ISPs do. This probably seems a bit confusing.
    Later in this chapter, I provide a detailed example of hierarchical address block
    assignments and how splitting works under CIDR.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管CIDR基于子网划分的概念，但子网划分本身并不用于CIDR——至少，不是在类地址方式下使用的那种方式。CIDR中没有使用子网ID进行显式子网划分。所有IP地址仅被解释为具有网络ID和主机ID。组织通过使用与ISP相同的一般方法将其自己的网络划分为子网，这相当于子网划分。这可能会有些令人困惑。在本章的后面部分，我将提供一个详细的分层地址块分配示例以及CIDR下的分割是如何工作的。
- en: Common Aspects of Classful and Classless Addressing
  id: totrans-861
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类地址和无类地址的共同特点
- en: 'There are a few aspects of addressing that were defined under the "classful"
    scheme that don''t change under CIDR:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在“类地址”方案下定义的一些地址方面在CIDR下并没有改变：
- en: '**Private Address Blocks** Certain blocks of addresses are still reserved for
    private network addressing. These addresses are not directly routed on the Internet,
    but can be used in conjunction with Network Address Translation (NAT; see [Chapter 28](ch28.html
    "Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL")) to allow IP hosts
    without public addresses to access the Internet.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有地址块** 某些地址块仍然保留用于私有网络地址。这些地址不能直接在互联网上路由，但可以与网络地址转换（NAT；参见[第28章](ch28.html
    "第28章. IP网络地址转换（NAT）协议")）结合使用，以允许没有公共地址的IP主机访问互联网。'
- en: '**Addresses with Special Meanings** The special meanings assigned to certain
    network ID and host ID patterns are the same as before. This is also why you still
    must subtract two from the number of hosts in each network. These represent the
    all-zeros case that refers to the network as a whole and the all-ones address
    used for broadcast.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有特殊含义的地址** 某些网络ID和主机ID模式所赋予的特殊含义与之前相同。这也是为什么你仍然必须从每个网络的主机数中减去两个的原因。这些代表整个网络的全部零地址和用于广播的全一地址。'
- en: '**Loopback Addresses** The network 127.0.0.0 is still reserved for loopback
    functionality. (In CIDR it is given the notation 127.0.0.0/8.)'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '**环回地址** 网络127.0.0.0仍然保留用于环回功能。（在CIDR中，它被表示为127.0.0.0/8。）'
- en: Finally, note that use of classless addressing requires hardware and software
    designed to handle it. If the hardware and software are still assuming that they
    are operating in a classful environment, they will not properly interpret addresses.
    Since CIDR has now been around for more than a decade, this is usually not a problem
    with modern systems.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，使用无类地址需要设计用于处理它的硬件和软件。如果硬件和软件仍然假设它们在类环境中运行，它们将无法正确解释地址。由于CIDR现在已经存在十多年了，这在现代系统中通常不是问题。
- en: IP Classless Addressing Block Sizes and Classful Network Equivalents
  id: totrans-867
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无类地址块大小和类网络等效
- en: Because CIDR allows you to divide IP addresses into network IDs and host IDs
    along any bit boundary, it allows for the creation of dozens of different sizes
    of networks. As with subnetting, the size of network is a trade-off between the
    number of bits used for the network ID and the number used for the host ID. Unlike
    conventional subnetting, where a single choice is made for all subnets, CIDR allows
    many levels of hierarchical division of the Internet, so many sizes of networks
    exist simultaneously. Larger networks are created and subdivided into smaller
    ones.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CIDR允许你根据任何位边界将IP地址划分为网络ID和主机ID，因此它可以创建数十种不同大小的网络。与子网划分一样，网络的大小是网络ID位数和主机ID位数之间的权衡。与传统的子网划分不同，在传统的子网划分中，所有子网都做出单一的选择，而CIDR允许对互联网进行多级分层划分，因此存在许多不同大小的网络。较大的网络被创建并进一步划分为较小的网络。
- en: Since many people are used to looking at IP address blocks in terms of their
    classful sizes, it is common to express CIDR address blocks in terms of their
    classful equivalents. First, at this point it should be simple to see that a CIDR
    /8 network is equal in size to a Class A network, a /16 is equivalent to a Class
    B network, and a/24 is equivalent to a Class C network. This is because Class
    A networks use 8 bits for the network ID, Class B networks use 16, and Class C
    networks use 24\. However, remember that these CIDR equivalents do not need to
    have any particular ranges for their first octets as in the classful scheme.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多人习惯于根据它们的类大小查看IP地址块，因此通常用它们的类等效来表示CIDR地址块。首先，在这个阶段，应该很容易看出CIDR /8网络的大小与A类网络相等，/16与B类网络等效，/24与C类网络等效。这是因为A类网络使用8位作为网络ID，B类网络使用16位，C类网络使用24位。然而，请记住，这些CIDR等效不需要像类方案那样有特定的第一个八位字节范围。
- en: Each time you reduce the prefix length, you are defining a network about double
    the size of the one with the higher number, since you have increased the number
    of bits in the host ID by one. So, a /15 network is equal in size to two /16 networks.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你减少前缀长度，你都在定义一个大约是前一个具有更高数字的网络大小两倍的网络，因为你已经通过增加主机ID中的一个位数。因此，/15网络的大小等于两个/16网络。
- en: '[Table 20-1](ch20s03.html#cidr_address_blocks_and_classful_address "Table 20-1. CIDR
    Address Blocks and Classful Address Equivalents") shows each of the possible theoretical
    ways to divide the 32 bits of an IP address into network ID and host ID bits under
    CIDR. For each, I have shown the number of hosts in each network, and the way
    a network of each size is represented in both slash notation and as a conventional
    subnet mask. I have also shown the equivalent number of Class A, Class B, and
    Class C networks for each.'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '[表20-1](ch20s03.html#cidr_address_blocks_and_classful_address "表20-1. CIDR地址块和类地址等效")显示了在CIDR下将IP地址的32位划分为网络ID和主机ID位数的所有可能的理论方法。对于每一种方法，我都展示了每个网络中的主机数量，以及每种大小的网络在斜杠表示法和传统子网掩码中的表示方式。我还展示了每个的A类、B类和C类网络的等效数量。'
- en: 'Keep the following things in mind while looking at this table:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此表时，请记住以下几点：
- en: Some of the entries shown are more theoretical than practical and are included
    merely for completeness. This is particularly the case with the larger networks.
    For example, I doubt anyone ever actually works with a /1 or /2 CIDR network;
    there would be only two of the former and four of the latter encompassing the
    entire IP address space! Most of the time, you will be working with smaller networks,
    /16 and below.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示的一些条目比实际更理论化，仅为了完整性而包含。这尤其适用于较大的网络。例如，我怀疑没有人真正使用过/1或/2 CIDR网络；前者只有两个，后者有四个，涵盖了整个IP地址空间！大多数时候，你将处理较小的网络，/16以下。
- en: 'Under normal circumstances, you cannot have a /31 or /32 CIDR network, because
    it would have zero valid host IDs. (There is a special case: /31 networks can
    be used for point-to-point links, where it is obvious who the intended recipient
    is of each transmission, and where broadcasts are not necessary. This is described
    in RFC 3021.)'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正常情况下，您不能有/31或/32 CIDR网络，因为它将没有有效的主机ID。（有一个特殊情况：/31网络可以用于点对点链路，在这种情况下，每个传输的预期接收者很明显，并且不需要广播。这已在RFC
    3021中描述。）
- en: In the columns showing the number of equivalent Class A, B, and C networks I
    have only shown numbers in the range of 1/256 to 256 for simplicity. Obviously,
    a /6 network, in addition to being equal in size to four Class A networks, also
    equals 1,024 Class B networks, and 262,144 Class C networks, but few people would
    bother referring to a /6 as being 262,144 Class C networks.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示等效A、B和C类网络数量的列中，为了简化，我只显示了1/256到256范围内的数字。显然，/6网络除了与四个A类网络大小相等外，还等于1,024个B类网络和262,144个C类网络，但很少有人会费心将/6网络称为262,144个C类网络。
- en: Table 20-1. CIDR Address Blocks and Classful Address Equivalents
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 表20-1. CIDR地址块和类地址等效
- en: '| # of Bits for Network ID | # of Bits for Host ID | # of Hosts per Network
    | Prefix Length in Slash Notation | Equivalent Subnet Mask | # of Equivalent Classful
    Addressing Networks |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '| 网络ID位数 | 主机ID位数 | 每个网络的主机数 | 斜杠表示法中的前缀长度 | 等效子网掩码 | 等效类地址网络数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '|   |   |   |   |   | Class A | Class B | Class C |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   | A类 | B类 | C类 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 1 | 31 | 2,147,483,646 | /1 | 128.0.0.0 | 128 | — | — |'
  id: totrans-881
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 31 | 2,147,483,646 | /1 | 128.0.0.0 | 128 | — | — |'
- en: '| 2 | 30 | 1,073,741,822 | /2 | 192.0.0.0 | 64 | — | — |'
  id: totrans-882
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 30 | 1,073,741,822 | /2 | 192.0.0.0 | 64 | — | — |'
- en: '| 3 | 29 | 536,870,910 | /3 | 224.0.0.0 | 32 | — | — |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 29 | 536,870,910 | /3 | 224.0.0.0 | 32 | — | — |'
- en: '| 4 | 28 | 268,435,454 | /4 | 240.0.0.0 | 16 | — | — |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 28 | 268,435,454 | /4 | 240.0.0.0 | 16 | — | — |'
- en: '| 5 | 27 | 134,217,726 | /5 | 248.0.0.0 | 8 | — | — |'
  id: totrans-885
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 27 | 134,217,726 | /5 | 248.0.0.0 | 8 | — | — |'
- en: '| 6 | 26 | 67,108,862 | /6 | 252.0.0.0 | 4 | — | — |'
  id: totrans-886
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 26 | 67,108,862 | /6 | 252.0.0.0 | 4 | — | — |'
- en: '| 7 | 25 | 33,554,430 | /7 | 254.0.0.0 | 2 | — | — |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 25 | 33,554,430 | /7 | 254.0.0.0 | 2 | — | — |'
- en: '| 8 | 24 | 16,777,214 | /8 | 255.0.0.0 | 1 | 256 | — |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 24 | 16,777,214 | /8 | 255.0.0.0 | 1 | 256 | — |'
- en: '| 9 | 23 | 8,388,606 | /9 | 255.128.0.0 | 1/2 | 128 | — |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 23 | 8,388,606 | /9 | 255.128.0.0 | 1/2 | 128 | — |'
- en: '| 10 | 22 | 4,194,302 | /10 | 255.192.0.0 | 1/4 | 64 | — |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 22 | 4,194,302 | /10 | 255.192.0.0 | 1/4 | 64 | — |'
- en: '| 11 | 21 | 2,097,150 | /11 | 255.224.0.0 | 1/8 | 32 | — |'
  id: totrans-891
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 21 | 2,097,150 | /11 | 255.224.0.0 | 1/8 | 32 | — |'
- en: '| 12 | 20 | 1,048,574 | /12 | 255.240.0.0 | 1/16 | 16 | — |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 20 | 1,048,574 | /12 | 255.240.0.0 | 1/16 | 16 | — |'
- en: '| 13 | 19 | 524,286 | /13 | 255.248.0.0 | 1/32 | 8 | — |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 19 | 524,286 | /13 | 255.248.0.0 | 1/32 | 8 | — |'
- en: '| 14 | 18 | 262,142 | /14 | 255.252.0.0 | 1/64 | 4 | — |'
  id: totrans-894
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 18 | 262,142 | /14 | 255.252.0.0 | 1/64 | 4 | — |'
- en: '| 15 | 17 | 131,070 | /15 | 255.254.0.0 | 1/128 | 2 | — |'
  id: totrans-895
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 17 | 131,070 | /15 | 255.254.0.0 | 1/128 | 2 | — |'
- en: '| 16 | 16 | 65,534 | /16 | 255.255.0.0 | 1/256 | 1 | 256 |'
  id: totrans-896
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 16 | 65,534 | /16 | 255.255.0.0 | 1/256 | 1 | 256 |'
- en: '| 17 | 15 | 32,766 | /17 | 255.255.128.0 | — | 1/2 | 128 |'
  id: totrans-897
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 15 | 32,766 | /17 | 255.255.128.0 | — | 1/2 | 128 |'
- en: '| 18 | 14 | 16,382 | /18 | 255.255.192.0 | — | 1/4 | 64 |'
  id: totrans-898
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 14 | 16,382 | /18 | 255.255.192.0 | — | 1/4 | 64 |'
- en: '| 19 | 13 | 8,190 | /19 | 255.255.224.0 | — | 1/8 | 32 |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 13 | 8,190 | /19 | 255.255.224.0 | — | 1/8 | 32 |'
- en: '| 20 | 12 | 4,094 | /20 | 255.255.240.0 | — | 1/16 | 16 |'
  id: totrans-900
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 12 | 4,094 | /20 | 255.255.240.0 | — | 1/16 | 16 |'
- en: '| 21 | 11 | 2,046 | /21 | 255.255.248.0 | — | 1/32 | 8 |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 11 | 2,046 | /21 | 255.255.248.0 | — | 1/32 | 8 |'
- en: '| 22 | 10 | 1,022 | /22 | 255.255.252.0 | — | 1/64 | 4 |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 10 | 1,022 | /22 | 255.255.252.0 | — | 1/64 | 4 |'
- en: '| 23 | 9 | 510 | /23 | 255.255.254.0 | — | 1/128 | 2 |'
  id: totrans-903
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 9 | 510 | /23 | 255.255.254.0 | — | 1/128 | 2 |'
- en: '| 24 | 8 | 254 | /24 | 255.255.255.0 | — | 1/256 | 1 |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 8 | 254 | /24 | 255.255.255.0 | — | 1/256 | 1 |'
- en: '| 25 | 7 | 126 | /25 | 255.255.255.128 | — | — | 1/2 |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 7 | 126 | /25 | 255.255.255.128 | — | — | 1/2 |'
- en: '| 26 | 6 | 62 | /26 | 255.255.255.192 | — | — | 1/4 |'
  id: totrans-906
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 6 | 62 | /26 | 255.255.255.192 | — | — | 1/4 |'
- en: '| 27 | 5 | 30 | /27 | 255.255.255.224 | — | — | 1/8 |'
  id: totrans-907
  prefs: []
  type: TYPE_TB
  zh: '| 27 | 5 | 30 | /27 | 255.255.255.224 | — | — | 1/8 |'
- en: '| 28 | 4 | 14 | /28 | 255.255.255.240 | — | — | 1/16 |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 4 | 14 | /28 | 255.255.255.240 | — | — | 1/16 |'
- en: '| 29 | 3 | 6 | /29 | 255.255.255.248 | — | — | 1/32 |'
  id: totrans-909
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 3 | 6 | /29 | 255.255.255.248 | — | — | 1/32 |'
- en: '| 30 | 2 | 2 | /30 | 255.255.255.252 | — | — | 1/64 |'
  id: totrans-910
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 2 | 2 | /30 | 255.255.255.252 | — | — | 1/64 |'
- en: IP CIDR Addressing Example
  id: totrans-911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP CIDR地址示例
- en: The multiple hierarchical levels of CIDR make the technology seem rather complicated.
    However, understanding how CIDR works really is not that difficult, assuming you
    already know how subnetting is done. In particular, if you know how VLSM functions,
    you basically already know how CIDR works, since they are pretty much the same
    thing. They differ only in the way that the hierarchical division of networks
    is accomplished, and in the terminology.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: CIDR的多个分层级别使这项技术看起来相当复杂。然而，如果你已经知道如何进行子网划分，理解CIDR的工作原理实际上并不困难。特别是，如果你知道VLSM的功能，你基本上已经知道了CIDR的工作原理，因为它们基本上是同一件事。它们的不同之处仅在于网络分层划分的实现方式和术语。
- en: 'To show how CIDR works better, let''s take an example that will illustrate
    the power of classless addressing: its ability to selectively subdivide a large
    block of addresses into smaller ones that suit the needs of various organizations.
    Since address allocation in CIDR typically starts with larger blocks owned by
    larger ISPs, let''s start there as well.'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示CIDR如何更好地工作，让我们举一个例子，这个例子将说明无类别地址的强大功能：它能够选择性地将一个大块地址细分为适合各种组织需求的小块。由于CIDR中的地址分配通常从较大的ISP拥有的较大块开始，因此我们也从这里开始。
- en: Suppose you have an ISP that is just starting up. It's not a major ISP, but
    a moderate-sized one with only a few customers, so it needs only a relatively
    small allocation. It begins with the block 71.94.0.0/15\. The /15 on the end of
    the block address tells you that this is a block of addresses where the first
    15 bits are the network ID and the last 17 are the host ID. This block was obtained
    from a larger ISP, carved from a larger block of addresses by that ISP. For example,
    71.94.0.0/15 would be equal to half of the address block 71.92.0.0/14, a quarter
    of the block 71.88.0.0/13, and so on.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个刚刚起步的ISP。它不是一个主要ISP，而是一个规模适中的ISP，只有少数客户，因此它只需要相对较小的分配。它从71.94.0.0/15这个块开始。块地址末尾的/15告诉你，这是一个地址块，其中前15位是网络ID，后17位是宿主ID。这个块是从一个更大的ISP那里获得的，由该ISP从一个更大的地址块中切割而来。例如，71.94.0.0/15等于71.92.0.0/14地址块的一半，71.88.0.0/13块的四分之一，等等。
- en: The ISP's block is equal in size to two Class B networks and has a total of
    131,070 possible host addresses. This ISP can choose to divide this block in a
    variety of ways, depending on the needs of its clients and its own internal use.
    However, this ISP is just starting up, so it is not even sure of what its ultimate
    needs will be. Let's say it expects to resell about half of its address space
    to other ISPs, but isn't sure what sizes they will need yet. Of the other half,
    it plans to split it into four different sizes of blocks to match the needs of
    different-sized organizations.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 该ISP的地址块大小等于两个B类网络的大小，总共有131,070个可能的宿主地址。这个ISP可以选择以各种方式划分这个地址块，这取决于其客户的需求以及其自身的内部使用。然而，这个ISP刚刚起步，甚至还不确定其最终需求是什么。假设它预计将大约一半的地址空间转售给其他ISP，但还不确定他们需要多大的地址空间。在剩下的另一半中，它计划将其分成四种不同大小的块，以适应不同规模组织的需要。
- en: To imagine how the ISP divides its address space, you can consider the analogy
    of cutting up a pie. The ISP will first cut the pie in half and reserve one-half
    for its future ISP customers. It will then cut the other half into some large
    pieces and some small pieces. This is illustrated in [Figure 20-3](ch20s04.html#example_of_a_hierarchical_division_of_a_
    "Figure 20-3. Example of a hierarchical division of a /15 CIDR address block This
    diagram shows one method by which an ISP with a relatively large /15 address block
    (131,070 hosts) might choose to hierarchically divide it. In this case it is first
    divided in half into two /16 blocks. One is reserved, while the other is divided
    into four /18 blocks. Each of those is divided into blocks of a different size
    to allow allocation to organizations requiring up to 62, 126, 254, or 510 hosts,
    respectively."). (Okay, I know it's a square pie. I wanted to show the individual
    small blocks to scale.)
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 为了想象ISP如何划分其地址空间，你可以考虑将一块饼切开的类比。ISP首先将饼切成两半，保留一半给未来的ISP客户。然后，它将另一半切成一些大块和一些小块。这如图[图20-3](ch20s04.html#example_of_a_hierarchical_division_of_a_
    "图20-3. 一个/15 CIDR地址块分层划分的例子。此图显示了一个拥有相对较大的/15地址块（131,070个宿主）的ISP可能选择的一种分层划分方法。在这种情况下，它首先被分成两个/16块。一个被保留，而另一个被分成四个/18块。每个这样的块被进一步划分为不同大小的块，以便分配给需要最多62、126、254或510个宿主的组织。")所示。（好吧，我知道它是一个方形的饼。我想按比例展示单独的小块。）
- en: The actual process of division might follow the progression described in the
    following section and illustrated in [Figure 20-4](ch20s04.html#hierarchical_address_division_using_cidr
    "Figure 20-4. Hierarchical address division using CIDR").
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的划分过程可能遵循以下章节中描述的进展，并在 [图 20-4](ch20s04.html#hierarchical_address_division_using_cidr
    "图 20-4. 使用 CIDR 进行分层地址划分") 中展示。
- en: First Level of Division
  id: totrans-918
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一层划分
- en: 'The "pie" is initially cut down the middle by using the single leftmost host
    ID bit as an extra network bit. Here''s the network address block, 71.94.0.0/15
    in binary, with the leftmost host ID bit shown in bold:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: “饼”最初是通过使用单个最左边的宿主 ID 位作为额外的网络位来切成两半的。以下是网络地址块，71.94.0.0/15 的二进制表示，其中最左边的宿主
    ID 位以粗体显示：
- en: '| 01000111 0101111**0** 00000000 00000000 |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**0** 00000000 00000000 |'
- en: '![Example of a hierarchical division of a /15 CIDR address block This diagram
    shows one method by which an ISP with a relatively large /15 address block (131,070
    hosts) might choose to hierarchically divide it. In this case it is first divided
    in half into two /16 blocks. One is reserved, while the other is divided into
    four /18 blocks. Each of those is divided into blocks of a different size to allow
    allocation to organizations requiring up to 62, 126, 254, or 510 hosts, respectively.](httpatomoreillycomsourcenostarchimages287847.png.jpg)'
  id: totrans-921
  prefs: []
  type: TYPE_IMG
  zh: '![/15 CIDR 地址块的分层划分示例 此图展示了 ISP 如何将相对较大的 /15 地址块（131,070 个主机）进行分层划分的一种方法。在这种情况下，它首先被分成两个
    /16 块。其中一个被保留，而另一个被分成四个 /18 块。这些块被进一步划分为不同大小的块，以便分配给需要 62、126、254 或 510 个主机的组织。](httpatomoreillycomsourcenostarchimages287847.png.jpg)'
- en: Figure 20-3. Example of a hierarchical division of a /15 CIDR address block
    This diagram shows one method by which an ISP with a relatively large /15 address
    block (131,070 hosts) might choose to hierarchically divide it. In this case it
    is first divided in half into two /16 blocks. One is reserved, while the other
    is divided into four /18 blocks. Each of those is divided into blocks of a different
    size to allow allocation to organizations requiring up to 62, 126, 254, or 510
    hosts, respectively.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-3. /15 CIDR 地址块的分层划分示例 此图展示了 ISP 如何将相对较大的 /15 地址块（131,070 个主机）进行分层划分的一种方法。在这种情况下，它首先被分成两个
    /16 块。其中一个被保留，而另一个被分成四个 /18 块。这些块被进一步划分为不同大小的块，以便分配给需要 62、126、254 或 510 个主机的组织。
- en: 'To make the split, you make one network equal to this binary network address
    with the highlighted bit remaining zero, and the other one with it changed to
    a one. This creates two subnetworks—not subnets as in the classful sense of the
    word, but portions of the original network—that I have numbered based on the numeric
    value of what is substituted into the new network ID bits, as follows:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行划分，你将一个网络设置为具有高亮显示的位保持为零的该二进制网络地址，另一个网络则将其改为一位。这创建了两个子网络——不是在类 B 意义上的子网，而是原始网络的部分——我根据将替代新网络
    ID 位的数值进行编号，如下所示：
- en: '| Subnetwork 0: 01000111 0101111**0** 00000000 00000000 |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| 子网络 0: 01000111 0101111**0** 00000000 00000000 |'
- en: '| Subnetwork 1: 01000111 0101111**1** 00000000 00000000 |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| 子网络 1: 01000111 0101111**1** 00000000 00000000 |'
- en: 'Because bit 16 is now also part of the network address, these are /16 networks,
    the size of a classful Class B network. So the subnetworks are as follows:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第 16 位现在也是网络地址的一部分，这些是 /16 网络，相当于一个类 B 网络的大小。因此，子网络如下：
- en: '| Subnetwork 0: 71.94.0.0/16 |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| 子网络 0: 71.94.0.0/16 |'
- en: '| Subnetwork 1: 71.95.0.0/16 |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| 子网络 1: 71.95.0.0/16 |'
- en: You'll notice subnetwork 0 has the same IP address as the larger network it
    came from; this is always true of the subnetwork 0 in a network.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到子网络 0 与它所来自的较大网络的 IP 地址相同；在网络的子网络 0 中，这始终是正确的。
- en: '![Hierarchical address division using CIDR](httpatomoreillycomsourcenostarchimages287849.png.jpg)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
  zh: '![使用 CIDR 进行分层地址划分](httpatomoreillycomsourcenostarchimages287849.png.jpg)'
- en: Figure 20-4. Hierarchical address division using CIDR
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 图 20-4. 使用 CIDR 进行分层地址划分
- en: Second Level of Division
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二层划分
- en: 'Let''s say you set aside subnetwork 0 earlier for future ISP allocations. You
    then choose to divide the second subnetwork into four. These you will then further
    subdivide into different sizes to meet the customer''s needs. To divide into four
    groups, you need two more bits from the host ID of subnetwork 1, as shown here
    in bold and underlined next to the original subnet bit:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你之前为未来的 ISP 分配保留了子网络 0。然后你选择将第二个子网络分成四份。然后你将进一步将这些子网络划分为不同的大小以满足客户的需求。要将它们分成四组，你需要从子网络
    1 的主机 ID 中再借用两个位，如下所示，粗体和下划线显示在原始子网位旁边：
- en: '| 01000111 0101111**1 00**000000 00000000 |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**1 00**000000 00000000 |'
- en: 'These two bits are replaced by the patterns 00, 01, 10, and 11 to get four
    sub-subnetworks. They will be /18 networks, since you took two extra bits from
    the host ID of a /16 as shown here:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个位被替换为模式00、01、10和11，以获得四个子子子网络。它们将是/18网络，因为您从/16的主机ID中提取了两个额外的位，如下所示：
- en: '| Sub-subnetwork 1-0: 01000111 0101111**1 00**000000 00000000 (71.95.0.0/18)
    |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| 子子子网络 1-0: 01000111 0101111**1 00**000000 00000000 (71.95.0.0/18) |'
- en: '| Sub-subnetwork 1-1: 01000111 0101111**1 01**000000 00000000 (71.95.64.0/18)
    |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '| 子子子网络 1-1: 01000111 0101111**1 01**000000 00000000 00000000 (71.95.64.0/18)
    |'
- en: '| Sub-subnetwork 1-2: 01000111 0101111**1 10**000000 00000000 (71.95.128.0/18)
    |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| 子子子网络 1-2: 01000111 0101111**1 10**000000 00000000 (71.95.128.0/18) |'
- en: '| Sub-subnetwork 1-3: 01000111 0101111**1 11**000000 00000000 (71.95.192.0/18)
    |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| 子子子网络 1-3: 01000111 0101111**1 11**000000 00000000 (71.95.192.0/18) |'
- en: Each of these has 16,382 addresses.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都有16382个地址。
- en: Third Level of Division
  id: totrans-941
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三级划分
- en: 'You now take each of the four /18 networks and further subdivide it. You want
    to make each of these contain a number of blocks of different sizes corresponding
    to the potential customers. One way to do this would be as follows:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将每个四个/18网络进一步细分。您希望每个都包含不同大小的块，以对应潜在的客户。一种方法如下：
- en: '**Larger Organizations** Customers needing up to 510 addresses require a /23
    network. You divide sub-subnetwork 1-0, 71.95.0.0/18 by taking five bits from
    the host ID field:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '**大型组织** 需要最多510个地址的客户需要/23网络。您通过从主机ID字段中提取五个位来分割子子子网络1-0，71.95.0.0/18：'
- en: '| 01000111 0101111**1 00**000000 00000000 |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**1 00**000000 00000000 |'
- en: 'You substitute into these five bits 00000, 00001, 00010 and so on, giving you
    32 different /23 networks in this block, each containing nine bits for the host
    ID, for 510 hosts. The first will be sub-sub-subnetwork 1-0-0, 71.95.0.0/23; the
    second sub-sub-subnetwork 1-0-1, 71.95.2.0/23; the last will be sub-sub-subnetwork
    1-0-31: 71.95.62.0/23.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 您将这些五位替换为00000、00001、00010等，从而在这个块中提供32个不同的/23网络，每个网络包含九位用于主机ID，共510个主机。第一个将是子子子子网络1-0-0，71.95.0.0/23；第二个是子子子子网络1-0-1，71.95.2.0/23；最后一个将是子子子子网络1-0-31：71.95.62.0/23。
- en: '**Medium-Sized Organizations** For customers needing up to 254 addresses, you
    divide sub-subnetwork 1-1, 71.95.64.0/18, by taking six bits from the host ID
    field:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '**中型组织** 对于需要最多254个地址的客户，您可以通过从主机ID字段中提取六个位来分割子子子网络1-1，71.95.64.0/18：'
- en: '| 01000111 0101111**1 01**000000 00000000 |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**1 01**000000 00000000 |'
- en: This gives you 64 different /24 networks. The first will be sub-sub-subnetwork
    1-1-0, 71.95.64.0/24, the second sub-sub-subnetwork 1-1-1, 71.95.65.0/24, and
    so on.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了64个不同的/24网络。第一个将是子子子子网络1-1-0，71.95.64.0/24，第二个是子子子网络1-1-1，71.95.65.0/24，依此类推。
- en: '**Smaller Organizations** For customers with up to 126 hosts, you divide sub-subnetwork
    1-2, 71.95.128.0/18, by taking seven bits from the host ID field, as follows:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**小型组织** 对于拥有最多126个主机的客户，您可以通过从主机ID字段中提取七个位来分割子子子网络1-2，71.95.128.0/18，如下所示：'
- en: '| 01000111 0101111**1** **10**000000 00000000 |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**1** **10**000000 00000000 |'
- en: Seven bits allow 128 of these /25 networks within the /18 block. The first will
    be 71.95.128.0/25, the second 71.95.128.128/25, the third 71.95.129.0/25, and
    so on.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 七位允许在/18块内包含128个这些/25网络。第一个将是71.95.128.0/25，第二个是71.95.128.128/25，第三个是71.95.129.0/25，依此类推。
- en: '**Very Small Organizations** For customers with up to 60 hosts, you divide
    sub-subnetwork 1-3, 71.95.192.0/18, by taking eight bits from the host ID field:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**微型组织** 对于拥有最多60个主机的客户，您可以通过从主机ID字段中提取八个位来分割子子子网络1-3，71.95.192.0/18：'
- en: '| 01000111 0101111**1 11**000000 00000000 |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '| 01000111 0101111**1 11**000000 00000000 |'
- en: This gives you 256 different /26 networks within the /18 block. The first will
    be 71.95.192.0/26, the second 71.95.192.64/26, and so on.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 这在/18块内为您提供了256个不同的/26网络。第一个将是71.95.192.0/26，第二个是71.95.192.64/26，依此类推。
- en: This example shows only one of many different ways to slice up this pie. The
    ISP might decide that creating four different sizes of customer networks in advance
    was not the right way to go. It might instead just take the tack of dividing the
    pie in half, dividing it in half again, and so on, as many times as needed to
    create slices of the right size. Alternatively, if most of their customers needed
    around 50, 100, 200, or 500 hosts, the previous example might be the easiest to
    administer.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅显示了分割这个蛋糕的许多不同方法之一。ISP可能会决定预先创建四种不同大小的客户网络不是正确的做法。它可能会选择将蛋糕分成两半，然后再分成两半，依此类推，直到创建出正确大小的块。或者，如果大多数客户需要的主机数量大约是50、100、200或500，那么前面的例子可能是最容易管理的。
- en: It would still be possible for the ISP to divide any of the smaller blocks further
    if they needed to do so. They could split a /26 sub-sub-subnetwork into four /28
    sub-sub-sub-subnetworks for very small customers, for example. Also, an individual
    customer of this ISP could do the same thing, dividing its own block to suit the
    internal structure of its network.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ISP需要这样做，他们仍然可以将任何较小的块进一步分割。例如，他们可以将一个/26子子子网络分割成四个/28子子子子网络，以适应非常小的客户。同样，这个ISP的个别客户也可以做同样的事情，将其自己的块分割以适应其网络的内部结构。
- en: Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION AND FORMATTING
  id: totrans-957
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章. 互联网协议数据报封装和格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The primary job of the Internet Protocol (IP) is to deliver data between devices
    over an internetwork. On its journey between two hosts in an internetwork, this
    data may travel across many physical networks. To help ensure that the data is
    sent and received properly, it is *encapsulated* within a message called an *IP
    datagram*. This datagram includes several fields that help manage the operation
    of IP and ensure that data gets where it needs to go.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）的主要任务是将在互联网中不同设备之间传输的数据。在互联网中两个主机之间的旅程中，这些数据可能穿越许多物理网络。为了确保数据被正确发送和接收，它被封装在一个称为*IP数据报*的消息中。这个数据报包含几个字段，有助于管理IP的操作并确保数据到达它需要去的地方。
- en: In this chapter, I take a look at how IP takes data passed to it from higher
    layers and packages it for transmission. I begin with a general discussion of
    IP datagrams and encapsulation. I then describe the general format of IP datagrams,
    including the fields used in the IP header and how they are interpreted. I also
    include a brief discussion of IP datagram options and their use.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我探讨了IP协议如何从上层接收数据并将其打包以进行传输。我首先对IP数据报和封装进行了概述性讨论。然后，我描述了IP数据报的一般格式，包括IP头部中使用的字段及其解释方式。我还简要讨论了IP数据报选项及其用途。
- en: Tip
  id: totrans-961
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**BACKGROUND INFORMATION** *This chapter assumes at least passing familiarity
    with IP addressing concepts, as outlined in Chapters [Chapter 16](ch16.html "Chapter 16. IPV4
    ADDRESSING CONCEPTS AND ISSUES")–[Chapter 20](ch20.html "Chapter 20. IP CLASSLESS
    ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"). It also makes
    reference to the chapter on datagram fragmentation and reassembly ([Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY"))*.'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *本章假定至少对IP寻址概念有基本的了解，这些概念在[第16章](ch16.html "第16章. IPV4 寻址概念和问题")–[第20章](ch20.html
    "第20章. 无类IP寻址—无类域间路由(CIDR)/超网")中概述。它还参考了关于数据报分片和重组的章节([第22章](ch22.html "第22章. IP数据报大小、分片和重组"))*。'
- en: Note
  id: totrans-963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*IP datagrams are sometimes called* IP packets. *Whether* datagram *or* packet
    *is the preferred term seems to depend on whom you ask; even the standards don''t
    use one term exclusively. On the other hand, I have seen IP datagrams called*
    IP frames, *and that''s definitely not correct! [Chapter 1](ch01.html "Chapter 1. NETWORKING
    INTRODUCTION, CHARACTERISTICS, AND TYPES") describes these terms more completely*.'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '*IP数据报有时被称为* IP数据包。*数据报*或*数据包*哪个是首选术语似乎取决于你问的是谁；甚至标准也不使用一个术语。另一方面，我见过IP数据报被称为*IP帧*，这绝对是错误的！[第1章](ch01.html
    "第1章. 网络介绍、特性和类型")更完整地描述了这些术语*。'
- en: IP Datagram Encapsulation
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP数据报封装
- en: In [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES AND
    CONCEPTS"), which described OSI Reference Model concepts, I looked at several
    ways that protocols at various layers in a networking protocol stack interact
    with each other. One of the most important concepts in interprotocol operation
    is that of *encapsulation*. Most data originates within the higher layers of the
    OSI model. The protocols at these layers pass the data down to lower layers for
    transmission, usually in the form of discrete messages. Upon receipt, each lower-level
    protocol takes the entire contents of the message received and encapsulates it
    into its own message format, adding a header and possibly a footer that contain
    important control information.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第五章](ch05.html "第五章. OSI参考模型问题和概念")中，我描述了OSI参考模型的概念，我探讨了网络协议栈中各层协议之间相互交互的几种方式。在协议间操作中最重要的概念之一就是*封装*。大多数数据都起源于OSI模型的高层。这些层的协议将数据向下传递到较低层进行传输，通常是以离散消息的形式。在接收时，每个较低层的协议都会接收到的整个消息内容，并将其封装成自己的消息格式，可能还会添加一个头部和可能的尾部，这些头部和尾部包含重要的控制信息。
- en: You might think of encapsulation as similar to sending a letter enclosed in
    an envelope. You write a letter and put it in an envelope with a name and address,
    but if you give it to a courier for overnight delivery; the courier takes that
    envelope and puts it in a larger delivery envelope. In a similar way, messages
    at higher networking layers are encapsulated in lower-layer messages, which can
    then in turn be further encapsulated.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会把封装想象成类似于将一封信装入信封的过程。你写一封信，放入一个带有名字和地址的信封中，但如果你要通过快递员进行隔夜送达；快递员会取走那个信封，并将其放入一个更大的快递信封中。以类似的方式，在网络协议栈中，较高层的消息会被封装在较低层的消息中，而这些较低层的消息又可以进一步封装。
- en: 'Due to the prominence of TCP/IP, IP is one of the most important places where
    data encapsulation occurs on a modern network. Data is passed to IP typically
    from one of the two main transport layer protocols: the Transmission Control Protocol
    (TCP) or User Datagram Protocol (UDP). This data is already in the form of a TCP
    or UDP message with TCP or UDP headers. This is then encapsulated into the body
    of an IP message, usually called an *IP datagram* or *IP packet*. Encapsulation
    and formatting of an IP datagram is also sometimes called *packaging*—again, the
    envelope is an obvious comparison.'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP/IP的突出地位，IP是现代网络中数据封装发生的重要位置之一。数据通常从两个主要的传输层协议之一传递给IP：传输控制协议（TCP）或用户数据报协议（UDP）。这些数据已经以TCP或UDP消息的形式存在，带有TCP或UDP头部。然后这些数据被封装进IP消息的主体中，通常称为*IP数据报*或*IP数据包*。IP数据报的封装和格式化有时也被称为*包装*——再次强调，信封是一个明显的类比。
- en: '[Figure 21-1](ch21.html#ip_datagram_encapsulation_the_upper-laye "Figure 21-1. IP
    datagram encapsulation The upper-layer message is packaged into a TCP or UDP message,
    which becomes the payload of an IP datagram. The IP datagram is then passed down
    to layer 2, where it is encapsulated in a LAN, WAN, or WLAN frame. It is then
    converted to bits and transmitted at the physical layer.") displays this entire
    process, which looks very similar to the drawing of the OSI Reference Model as
    a whole, as shown in [Figure 5-5](ch05s03.html#osi_reference_model_data_encapsulation_e
    "Figure 5-5. OSI Reference Model data encapsulation Each protocol creates a protocol
    data unit (PDU) for transmission, each of which includes headers required by that
    protocol and data to be transmitted. This data becomes the service data unit (SDU)
    of the next layer below it.") in [Chapter 5](ch05.html "Chapter 5. GENERAL OSI
    REFERENCE MODEL ISSUES AND CONCEPTS"). As you can see, an upper-layer message
    is packaged into a TCP or UDP message. This then becomes the payload of an IP
    datagram, shown here with only one header (things can get a bit more complex than
    this). The IP datagram is then passed down to layer 2, where it is encapsulated
    into some sort of local area network (LAN), wide area network (WAN), or wireless
    LAN (WLAN) frame, and then converted to bits and transmitted at the physical layer.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '[图21-1](ch21.html#ip_datagram_encapsulation_the_upper-laye "图21-1. IP数据报封装上层消息被封装成TCP或UDP消息，这成为IP数据报的有效负载。然后IP数据报被传递到第2层，在那里它被封装在LAN、WAN或WLAN帧中。随后它被转换为比特并在物理层传输。")展示了整个过程，这个过程看起来与OSI参考模型的整体绘制非常相似，如[图5-5](ch05s03.html#osi_reference_model_data_encapsulation_e
    "图5-5. OSI参考模型数据封装每个协议为传输创建一个协议数据单元（PDU），每个PDU都包含该协议所需的头部和数据要传输的数据。这些数据成为下一层的服务数据单元（SDU）。")在[第5章](ch05.html
    "第5章. 一般OSI参考模型问题和概念")中所示。正如您所看到的，上层消息被封装成TCP或UDP消息。然后它成为IP数据报的有效负载，这里只显示了一个头部（事情可能比这复杂一些）。然后IP数据报被传递到第2层，在那里它被封装成某种局域网（LAN）、广域网（WAN）或无线局域网（WLAN）帧，然后转换为比特并在物理层传输。'
- en: If the message to be transmitted is too large to pass through the underlying
    network, it may first be fragmented. This is analogous to splitting up a large
    delivery into multiple smaller envelopes or boxes. In this case, each IP datagram
    carries only part of the higher-layer message. The receiving device must reassemble
    the message from the IP datagrams.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要传输的消息太大，无法通过底层网络传输，它可能首先被分片。这类似于将一个大件拆分成多个较小的信封或盒子。在这种情况下，每个IP数据报只携带高层消息的一部分。接收设备必须从IP数据报中重新组装消息。
- en: '![IP datagram encapsulation The upper-layer message is packaged into a TCP
    or UDP message, which becomes the payload of an IP datagram. The IP datagram is
    then passed down to layer 2, where it is encapsulated in a LAN, WAN, or WLAN frame.
    It is then converted to bits and transmitted at the physical layer.](httpatomoreillycomsourcenostarchimages287851.png.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据报封装上层消息被封装成TCP或UDP消息，这成为IP数据报的有效负载。然后IP数据报被传递到第2层，在那里它被封装在LAN、WAN或WLAN帧中。随后它被转换为比特并在物理层传输。](httpatomoreillycomsourcenostarchimages287851.png.jpg)'
- en: Figure 21-1. IP datagram encapsulation The upper-layer message is packaged into
    a TCP or UDP message, which becomes the payload of an IP datagram. The IP datagram
    is then passed down to layer 2, where it is encapsulated in a LAN, WAN, or WLAN
    frame. It is then converted to bits and transmitted at the physical layer.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-1. IP数据报封装上层消息被封装成TCP或UDP消息，这成为IP数据报的有效负载。然后IP数据报被传递到第2层，在那里它被封装在LAN、WAN或WLAN帧中。随后它被转换为比特并在物理层传输。
- en: The IP datagram is somewhat similar in concept to a frame used in Ethernet or
    another data link layer, except that IP datagrams are designed to facilitate transmission
    across an internetwork, while data link layer frames are used only for direct
    delivery within a physical network. The fields included in the IP header are used
    to manage internetwork datagram delivery. This includes key information for delivery,
    such as the address of the destination device, identification of the type of frame,
    and control bits. The header follows a format that you will examine shortly.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，IP数据报与以太网或其他数据链路层使用的帧有些相似，但IP数据报的设计是为了促进跨互联网的传输，而数据链路层帧仅用于物理网络内的直接交付。IP头部中包含的字段用于管理互联网数据报的交付。这包括交付的关键信息，如目标设备的地址、帧类型的标识和控制位。头部遵循您将很快要检查的格式。
- en: Once data is encapsulated into an IP datagram, it is passed down to the data
    link layer for transmission across the current "hop" of the internetwork. There
    it is further encapsulated, IP header and all, into a data link layer frame such
    as an Ethernet frame. An IP datagram may be encapsulated into many such data link
    layer frames as it is routed across the internetwork; on each hop, the IP datagram
    is removed from the data link layer frame and then repackaged into a new one for
    the next hop. The IP datagram, however, is not changed (except for some control
    fields) until it reaches its final destination.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被封装进IP数据报，它就会被传递到数据链路层，以便在互联网的当前“跳”中进行传输。在那里，它被进一步封装，包括IP头部，进入一个数据链路层帧，例如以太网帧。IP数据报可能被封装进许多这样的数据链路层帧，因为它在互联网中路由；在每次跳转中，IP数据报从数据链路层帧中移除，然后重新封装成一个新的帧，以便进行下一跳。然而，IP数据报在到达最终目的地之前不会改变（除了某些控制字段）。
- en: IP Datagram General Format
  id: totrans-975
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP数据报通用格式
- en: Data transmitted over an internetwork using IP is carried in messages called
    *IP datagrams*. As is the case with all network protocol messages, IP uses a specific
    format for its datagrams. Here, I will discuss the IP version 4 (IPv4) datagram
    format, which was defined in RFC 791 along with the rest of IPv4.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IP在互联网上传输的数据被包含在称为*IP数据报*的消息中。与所有网络协议消息一样，IP为其数据报使用特定的格式。在这里，我将讨论IP版本4（IPv4）数据报格式，该格式在RFC
    791中定义，与IPv4的其他部分一起。
- en: 'The IPv4 datagram is conceptually divided into two pieces: the *header* and
    the *payload*. The header contains addressing and control fields, while the payload
    carries the actual data to be sent over the internetwork. Unlike some message
    formats, IP datagrams do not have a footer following the payload.'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4数据报在概念上分为两部分：*头部*和*有效载荷*。头部包含寻址和控制字段，而有效载荷携带要发送到互联网的实际数据。与某些消息格式不同，IP数据报在有效载荷之后没有跟随着尾部。
- en: Even though IP is a relatively simple, connectionless, and unreliable protocol,
    the IPv4 header carries a fair bit of information, which makes it rather large.
    It is at least 20 bytes long, and with options it can be significantly longer.
    The IP datagram format is described in Tables [Table 21-1](ch21s02.html#internet_protocol_version__ipv_datagram
    "Table 21-1. Internet Protocol Version 4 (IPv4) Datagram Format"), [Table 21-2](ch21s02.html#ipv_flags_subfields
    "Table 21-2. IPv4 Flags Subfields"), and [Table 21-3](ch21s02.html#ipv_protocol_subfields
    "Table 21-3. IPv4 Protocol Subfields"), and illustrated in [Figure 21-2](ch21s02.html#ipv4_datagram_format_this_diagram_shows_
    "Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4 datagram
    format. The first 20 bytes are the fixed IP header, followed by an optional Options
    section, and a variable-length Data area. Note that the Type of Service field
    is shown as originally defined in the IPv4 standard.").
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IP是一个相对简单、无连接和不可靠的协议，但IPv4头部携带了相当多的信息，这使得它相当大。它至少有20字节长，带有选项时可以更长。IP数据报格式在表[表21-1](ch21s02.html#internet_protocol_version__ipv_datagram
    "表21-1. 互联网协议版本4 (IPv4) 数据报格式")、[表21-2](ch21s02.html#ipv_flags_subfields "表21-2. IPv4
    标志子字段")和[表21-3](ch21s02.html#ipv_protocol_subfields "表21-3. IPv4 协议子字段")中描述，并在[图21-2](ch21s02.html#ipv4_datagram_format_this_diagram_shows_
    "图21-2. IPv4数据报格式 此图显示了至关重要的IPv4数据报格式。前20字节是固定的IP头部，后面是可选的选项部分，以及可变长度的数据区域。请注意，服务类型字段显示为在IPv4标准中最初定义的。")中展示。
- en: Table 21-1. Internet Protocol Version 4 (IPv4) Datagram Format
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-1. 互联网协议版本4（IPv4）数据报格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-981
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Version | 1/2 (4 bits) | Identifies the version of IP used to generate the
    datagram. For IPv4, this is the number 4\. This field ensures compatibility between
    devices that may be running different versions of IP. In general, a device running
    an older version of IP will reject datagrams created by newer implementations,
    under the assumption that the older version may not be able to interpret the newer
    datagram correctly. |'
  id: totrans-982
  prefs: []
  type: TYPE_TB
  zh: '| 版本 | 1/2（4位） | 识别用于生成数据报的IP版本。对于IPv4，这个数字是4。该字段确保了可能运行不同IP版本设备之间的兼容性。一般来说，运行较旧IP版本设备将拒绝由较新实现创建的数据报，假设较旧版本可能无法正确解释较新的数据报。|'
- en: '| IHL | 1/2 (4 bits) | Specifies the length of the IP header, in 32-bit words.
    This includes the length of any options fields and padding. The normal value of
    this field when no options are used is 5 (5 32-bit words = 5*4 = 20 bytes). Contrast
    this with the longer Total Length field in this table. |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '| IHL | 1/2 (4 bits) | 指定IP头部长度，以32位字为单位。这包括任何选项字段和填充的长度。当不使用选项时，此字段的正常值为5（5个32位字
    = 5*4 = 20字节）。与表中较长的总长度字段进行对比。 |'
- en: '| TOS | 1 | A field designed to carry information to provide quality-of-service
    features, such as prioritized delivery for IP datagrams. This has not been as
    widely used as originally defined, and its meaning has been redefined for use
    by a technique called *Differentiated Services (DS)*, as discussed in the "IP
    Datagram Type of Service (TOS) Field" section of this chapter. |'
  id: totrans-984
  prefs: []
  type: TYPE_TB
  zh: '| TOS | 1 | 这是一个设计用来携带信息以提供服务质量功能的字段，例如为IP数据报提供优先级交付。这并没有像最初定义的那样被广泛使用，并且其含义已被重新定义为使用称为*区分服务（DS）*的技术，如本章“IP数据报服务类型（TOS）字段”部分所述。
    |'
- en: '| TL | 2 | Specifies the total length of the IP datagram, in bytes. Since this
    field is 16 bits wide, the maximum length of an IP datagram is 65,535 bytes, though
    most are much smaller. |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '| TL | 2 | 指定IP数据报的总长度，以字节为单位。由于此字段为16位宽，IP数据报的最大长度为65,535字节，尽管大多数数据报的长度要小得多。
    |'
- en: '| Identification | 2 | This field contains a 16-bit value that is common to
    each of the fragments belonging to a particular message; for datagrams originally
    sent unfragmented, it is still filled in so it can be used if the datagram must
    be fragmented by a router during delivery. The recipient uses this field to reassemble
    messages without accidentally mixing fragments from different messages. This is
    needed because fragments may arrive from multiple messages mixed together, since
    IP datagrams can be received out of order from any device. (See the discussion
    of IP message fragmentation in [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM
    SIZE, FRAGMENTATION, AND REASSEMBLY").) |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '| Identification | 2 | 此字段包含一个16位值，该值属于特定消息的每个分片；对于原本未分片发送的数据报，此字段仍然填写，以便在数据报在传输过程中必须由路由器分片时使用。接收方使用此字段重新组装消息，而不会意外地将来自不同消息的分片混合在一起。这是必要的，因为分片可能来自多个混合在一起的消息，因为IP数据报可以从任何设备无序接收。（有关IP消息分片的讨论，请参见[第22章](ch22.html
    "第22章. IP数据报大小、分片和重组")。） |'
- en: '| Flags | 3/8 (3 bits) | Three control flags, two of which are used to manage
    fragmentation (as described in the topic on fragmentation), and one that is reserved.
    See [Table 21-2](ch21s02.html#ipv_flags_subfields "Table 21-2. IPv4 Flags Subfields").
    |'
  id: totrans-987
  prefs: []
  type: TYPE_TB
  zh: '| Flags | 3/8 (3 bits) | 三个控制标志，其中两个用于管理分片（如分片主题中所述），另一个保留。参见[表21-2](ch21s02.html#ipv_flags_subfields
    "表21-2. IPv4标志子字段")。 |'
- en: '| Fragment Offset | 1 5/8 (13 bits) | When fragmentation of a message occurs,
    this field specifies the offset, or position, in the message where the data in
    this fragment goes in units of eight bytes (64 bits). The first fragment has an
    offset of 0\. (See the discussion of fragmentation in [Chapter 27](ch27.html "Chapter 27. IPV6
    DATAGRAM SIZE, FRAGMENTATION, REASSEMBLY, AND ROUTING") for a description of how
    the field is used.) |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
  zh: '| Fragment Offset | 1 5/8 (13 bits) | 当发生消息分片时，此字段指定偏移量或位置，即此分片中的数据在消息中的位置，以8字节（64位）为单位。第一个分片的偏移量为0。（有关该字段的使用方法，请参见[第27章](ch27.html
    "第27章. IPV6 数据报大小、分片、重组和路由")中的分片讨论。） |'
- en: '| TTL | 1 | This specifies how long the datagram is allowed to live on the
    network, in router hops. Each router decrements the value of the TTL field (reduces
    it by one) prior to transmitting it. If the TTL field drops to zero, the datagram
    is assumed to have taken too long a route and is discarded. (See the "IP Datagram
    Time to Live (TTL) Field" section later in this chapter for more information.)
    |'
  id: totrans-989
  prefs: []
  type: TYPE_TB
  zh: '| TTL | 1 | 这指定数据报在网络中允许存活的时间，以路由器跳数为单位。每个路由器在传输之前都会递减TTL字段的值（减一）。如果TTL字段降至零，则假定数据报已采取过长的路由，并将其丢弃。（有关更多信息，请参见本章后面的“IP数据报生存时间（TTL）字段”部分。）
    |'
- en: '| Protocol | 1 | Identifies the higher-layer protocol (generally either a transport
    layer protocol or encapsulated network layer protocol) carried in the datagram.
    [Table 21-3](ch21s02.html#ipv_protocol_subfields "Table 21-3. IPv4 Protocol Subfields")
    shows the protocol values of this field, which were originally defined by the
    IETF "Assigned Numbers" standard, RFC 1700, and are now maintained by the Internet
    Assigned Numbers Authority (IANA). |'
  id: totrans-990
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 1 | 识别数据报中携带的更高层协议（通常是传输层协议或封装的网络层协议）。[表21-3](ch21s02.html#ipv_protocol_subfields
    "表21-3. IPv4 协议子字段")显示了此字段的协议值，这些值最初由IETF“分配号码”标准RFC 1700定义，现在由互联网分配号码权威机构（IANA）维护。|'
- en: '| Header Checksum | 2 | A checksum is computed over the header to provide basic
    protection against corruption in transmission. This is not the more complex cyclic
    redundancy check (CRC) code that''s typically used by data link layer technologies
    such as Ethernet; it''s just a 16-bit checksum. It is calculated by dividing the
    header bytes into words (a word is two bytes) and then adding them together. Only
    the header is checksummed; not the data. At each hop, the device receiving the
    datagram does the same checksum calculation, and if there is a mismatch, it discards
    the datagram as damaged. |'
  id: totrans-991
  prefs: []
  type: TYPE_TB
  zh: '| 头部校验和 | 2 | 对头部进行校验和计算，以提供对传输中损坏的基本保护。这不是数据链路层技术（如以太网）通常使用的更复杂的循环冗余检查（CRC）代码；它只是一个16位的校验和。它是通过将头部字节分成字（一个字是两个字节）然后将它们相加来计算的。只有头部被校验和；不是数据。在每个跳转点，接收数据报的设备执行相同的校验和计算，如果存在不匹配，它将丢弃数据报作为损坏的数据报。|'
- en: '| Source Address | 4 | This is the 32-bit IP address of the originator of the
    datagram. Note that even though intermediate devices such as routers may handle
    the datagram, they do not normally put their address into this field—the address
    is always that of the device that originally sent the datagram. |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '| 源地址 | 4 | 这是数据报发起者的32位IP地址。请注意，尽管中间设备如路由器可能处理数据报，但它们通常不会将它们的地址放入此字段——地址始终是最初发送数据报的设备的地址。|'
- en: '| Destination Address | 4 | This is the 32-bit IP address of the intended recipient
    of the datagram. Again, even though devices such as routers may be the intermediate
    targets of the datagram, this field is always used to specify the ultimate destination.
    |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 4 | 这是数据报预期接收者的32位IP地址。尽管路由器等设备可能是数据报的中间目标，但此字段始终用于指定最终目的地。|'
- en: '| Options | Variable | One or more of several types of options may be included
    after the standard headers in certain IP datagrams, as discussed later in this
    chapter, in the "IP Datagram Options and Option Format" section. |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | 在某些IP数据报的标准头部之后，可以包含几种类型的选项之一，如本章后面“IP数据报选项和选项格式”部分所述。|'
- en: '| Padding | Variable | If one or more options are included, and the number
    of bits used for them is not a multiple of 32, enough 0 bits are added to pad
    out the header to a multiple of 32 bits (four bytes). |'
  id: totrans-995
  prefs: []
  type: TYPE_TB
  zh: '| 填充 | 可变 | 如果包含一个或多个选项，并且用于它们的位数不是32的倍数，则需要添加足够的0位来填充头部，使其成为32位的倍数（四个字节）。|'
- en: '| Data | Variable | This is the data that will be transmitted in the datagram.
    It is either an entire higher-layer message or a fragment of one. |'
  id: totrans-996
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 可变 | 这是将在数据报中传输的数据。它可以是整个高层消息或其一部分。|'
- en: Table 21-2. IPv4 Flags Subfields
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-2. IPv4 标志子字段
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-999
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Reserved | 1/8 (1 bit) | Not used. |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 1/8（1位） | 未使用。|'
- en: '| DF | 1/8 (1 bit) | When set to 1, this says that the datagram should not
    be fragmented. Since the fragmentation process is generally invisible to higher
    layers, most protocols don''t care about this and don''t set this flag. It is,
    however, used for testing the maximum transmission unit (MTU) of a link. |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '| DF | 1/8（1位） | 当设置为1时，这意味着数据报不应该被分段。由于分段过程通常对高层来说是不可见的，大多数协议都不关心这一点，也不设置此标志。然而，它用于测试链路的最大传输单元（MTU）。|'
- en: '| MF | 1/8 (1 bit) | When set to 0, this indicates the last fragment in a message;
    when set to 1, it indicates that more fragments are yet to come in the fragmented
    message. If no fragmentation is used for a message, there is only one fragment
    (the whole message), and this flag is 0\. If fragmentation is used, all fragments
    but the last set this flag to 1 so that the recipient knows when all fragments
    have been sent. |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '| MF | 1/8 (1位) | 当设置为0时，表示消息中的最后一个分段；当设置为1时，表示在分段消息中还有更多分段尚未到来。如果消息未使用分段，则只有一个分段（整个消息），此标志为0。如果使用分段，除了最后一个分段之外的所有分段都将此标志设置为1，以便接收者知道何时已发送所有分段。|'
- en: Table 21-3. IPv4 Protocol Subfields
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-3. IPv4协议子字段
- en: '| Value (Hexadecimal) | Value (Decimal) | Protocol |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制值 | 十进制值 | 协议 |'
- en: '| --- | --- | --- |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 00 | 0 | Reserved |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '| 00 | 0 | 保留 |'
- en: '| 01 | 1 | ICMP |'
  id: totrans-1007
  prefs: []
  type: TYPE_TB
  zh: '| 01 | 1 | ICMP |'
- en: '| 02 | 2 | IGMP |'
  id: totrans-1008
  prefs: []
  type: TYPE_TB
  zh: '| 02 | 2 | IGMP |'
- en: '| 03 | 3 | GGP |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '| 03 | 3 | GGP |'
- en: '| 04 | 4 | IP-in-IP Encapsulation |'
  id: totrans-1010
  prefs: []
  type: TYPE_TB
  zh: '| 04 | 4 | IP-in-IP封装 |'
- en: '| 06 | 6 | TCP |'
  id: totrans-1011
  prefs: []
  type: TYPE_TB
  zh: '| 06 | 6 | TCP |'
- en: '| 08 | 8 | EGP |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '| 08 | 8 | EGP |'
- en: '| 11 | 17 | UDP |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 17 | UDP |'
- en: '| 32 | 50 | Encapsulating Security Payload (ESP) Extension Header |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 50 | 封装安全载荷（ESP）扩展头部 |'
- en: '| 33 | 51 | Authentication Header (AH) Extension Header |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '| 33 | 51 | 认证头部（AH）扩展头部 |'
- en: Note
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '*The last two entries in [Table 21-3](ch21s02.html#ipv_protocol_subfields "Table 21-3. IPv4
    Protocol Subfields") are used when IPSec inserts additional headers into the datagram:
    the AH or ESP headers. See [Chapter 29](ch29.html "Chapter 29. IP SECURITY (IPSEC)
    PROTOCOLS") for more information*.'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '*[表21-3](ch21s02.html#ipv_protocol_subfields "表21-3. IPv4协议子字段")的最后两个条目用于在数据报中插入额外的头部：AH或ESP头部。更多信息请参见[第29章](ch29.html
    "第29章. IP安全（IPSEC）协议")*。'
- en: '![IPv4 datagram format This diagram shows the all-important IPv4 datagram format.
    The first 20 bytes are the fixed IP header, followed by an optional Options section,
    and a variable-length Data area. Note that the Type of Service field is shown
    as originally defined in the IPv4 standard.](httpatomoreillycomsourcenostarchimages287853.png.jpg)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4数据报格式 此图显示了至关重要的IPv4数据报格式。前20个字节是固定的IP头部，后面是可选的选项部分，以及可变长度的数据区域。注意，服务类型字段显示的是IPv4标准中最初定义的形式。](httpatomoreillycomsourcenostarchimages287853.png.jpg)'
- en: Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4
    datagram format. The first 20 bytes are the fixed IP header, followed by an optional
    Options section, and a variable-length Data area. Note that the Type of Service
    field is shown as originally defined in the IPv4 standard.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-2. IPv4数据报格式 此图显示了至关重要的IPv4数据报格式。前20个字节是固定的IP头部，后面是可选的选项部分，以及可变长度的数据区域。注意，服务类型字段显示的是IPv4标准中最初定义的形式。
- en: IP Datagram Time to Live (TTL) Field
  id: totrans-1020
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP数据报生存时间（TTL）字段
- en: Let's look at the Time to Live (TTL) field. Since IP datagrams are sent from
    router to router as they travel across an internetwork, a datagram could be passed
    from Router A to Router B to Router C, and then back to Router A. This is called
    a *router loop*, and it's something that we don't want to happen.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看生存时间（TTL）字段。由于IP数据报在穿越互联网时作为路由器到路由器的传输，一个数据报可能会从路由器A传递到路由器B，再到路由器C，然后又回到路由器A。这被称为*路由器循环*，这是我们不想发生的事情。
- en: To ensure that datagrams don't circle around endlessly, the TTL field was designed
    to contain a time value (in seconds), which would be filled in when the datagram
    was originally sent. Routers would decrease the time value periodically, and if
    it ever hit zero, destroy the datagram. The TTL field was also designed to ensure
    that time-critical datagrams wouldn't become stale or pass their expiration date.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保数据报不会无限循环，TTL字段被设计为包含一个时间值（以秒为单位），在数据报最初发送时填充。路由器会定期减少时间值，如果时间值达到零，则销毁数据报。TTL字段也被设计用来确保时间敏感的数据报不会过时或错过其到期日期。
- en: In practice, this field is not used in exactly this manner. Routers today are
    fast and usually take far less than a second to forward a datagram, which makes
    it impractical to measure the time that a datagram lives. Instead, this field
    is used as a maximum hop count for the datagram. Each time a router processes
    a datagram, it reduces the value of the TTL field by one. If doing this results
    in the field being zero, the datagram is said to have expired, at which point
    it is dropped, and usually an Internet Control Message Protocol (ICMP) Time Exceeded
    message is sent to inform the originator of the message that it has expired. The
    TTL field is one of the primary mechanisms by which networks are protected from
    router loops. (See the description of ICMP Time Exceeded messages in [Chapter 32](ch32.html
    "Chapter 32. ICMPV4 ERROR MESSAGE TYPES AND FORMATS") for more on how TTL helps
    IP handle router loops.)
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这个字段并不是以这种方式使用的。今天的路由器速度很快，通常在不到一秒的时间内就可以转发一个数据报，这使得测量数据报存活时间变得不切实际。相反，这个字段被用作数据报的最大跳数。每次路由器处理一个数据报时，它都会将TTL字段的值减一。如果这样做导致字段为零，则称数据报已过期，此时它将被丢弃，并且通常会发送一个Internet控制消息协议（ICMP）超时消息，通知消息的发送者该消息已过期。TTL字段是网络保护免受路由器环路的主要机制之一。（有关TTL如何帮助IP处理路由器环路的更多内容，请参阅[第32章](ch32.html
    "第32章. ICMPV4错误消息类型和格式")中ICMP超时消息的描述。）
- en: IP Datagram Type of Service (TOS) Field
  id: totrans-1024
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP数据报服务类型（TOS）字段
- en: The Type of Service (TOS) field is a one-byte field that was originally intended
    to provide certain quality-of-service (QoS) features for IP datagram delivery.
    It allowed IP datagrams to be tagged with information indicating not only their
    precedence, but also the preferred manner in which they should be delivered. It
    was divided into a number of subfields, as shown in [Table 21-4](ch21s02.html#original_definition_of_ipv_type_of_servi
    "Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field") and [Figure 21-2](ch21s02.html#ipv4_datagram_format_this_diagram_shows_
    "Figure 21-2. IPv4 datagram format This diagram shows the all-important IPv4 datagram
    format. The first 20 bytes are the fixed IP header, followed by an optional Options
    section, and a variable-length Data area. Note that the Type of Service field
    is shown as originally defined in the IPv4 standard.").
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类型（TOS）字段是一个一字节的字段，最初旨在为IP数据报的交付提供某些服务质量（QoS）特性。它允许IP数据报被标记上信息，不仅表明它们的优先级，而且还表明它们应该以何种方式交付。它被划分为多个子字段，如[表21-4](ch21s02.html#original_definition_of_ipv_type_of_servi
    "表21-4. IPv4服务类型（TOS）字段的原始定义")和[图21-2](ch21s02.html#ipv4_datagram_format_this_diagram_shows_
    "图21-2. IPv4数据报格式 此图显示了至关重要的IPv4数据报格式。前20个字节是固定的IP头部，后面是可选的选项部分，以及一个可变长度的数据区域。请注意，服务类型字段显示的是在IPv4标准中最初定义的形式。")所示。
- en: The lack of QoS features has been considered a weakness of IP for a long time.
    But as you can see in [Table 21-4](ch21s02.html#original_definition_of_ipv_type_of_servi
    "Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field"), these
    features were built into IP from the start. The fact is that even though this
    field was defined in the standard in the early 1980s, it was not widely used by
    hardware and software. For years, it was just passed around with all zeros in
    the bits and mostly ignored.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 长久以来，缺乏服务质量（QoS）特性一直被认为是IP的一个弱点。但正如你在[表21-4](ch21s02.html#original_definition_of_ipv_type_of_servi
    "表21-4. IPv4服务类型（TOS）字段的原始定义")中可以看到的，这些特性从一开始就被构建到IP中。事实上，尽管这个字段在20世纪80年代初的标准中就已经定义，但它并没有被硬件和软件广泛使用。多年来，它只是以所有位都为零的形式传递，大部分时间都被忽略了。
- en: The Internet Engineering Task Force (IETF), seeing the field unused, attempted
    to revive its use. In 1998, RFC 2474 redefined the first six bits of the TOS field
    to support a technique called *Differentiated Services (DS)*. Under DS, the values
    in the TOS field are called *codepoints* and are associated with different service
    levels. (See RFC 2474 for all the details.)
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网工程任务组（IETF）看到这个字段未被使用，试图复兴其使用。1998年，RFC 2474重新定义了TOS字段的前六位，以支持一种称为*区分服务（DS）*的技术。在DS下，TOS字段中的值被称为*代码点*，并与不同的服务级别相关联。（有关所有详细信息，请参阅RFC
    2474。）
- en: Tip
  id: totrans-1028
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *Be sure to read the remainder of this chapter for
    more information on how IP options are used in datagrams and [Chapter 22](ch22.html
    "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY") for some more context
    on the use of fragmentation-related fields such as Identification, Fragment Offset,
    and More Fragments*.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *务必阅读本章剩余部分以获取有关如何在数据报中使用IP选项的更多信息，并在[第22章](ch22.html "第22章。IP数据报大小、分片和重组")中了解有关使用与分片相关的字段（如标识符、分片偏移和更多分片）的更多背景信息*。'
- en: Table 21-4. Original Definition of IPv4 Type of Service (TOS) Field
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-4. IPv4服务类型（TOS）字段的原始定义
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Precedence | 3/8 (3 bits) | A field indicating the priority of the datagram.
    There were eight defined values, from lowest to highest priority:000: Routine001:
    Priority010: Immediate011: Flash100: Flash Override101: CRITIC/ECP110: Internetwork
    Control111: Network Control |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| 优先级 | 3/8 (3 bits) | 表示数据报优先级的字段。定义了八个值，从最低到最高优先级：000：常规001：优先010：立即011：闪光100：闪光优先101：CRITIC/ECP110：互联网控制111：网络控制|'
- en: '| D | 1/8 (1 bit) | Set to 0 to request normal delay in delivery; set to 1
    if a low delay delivery is requested. |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '| D | 1/8 (1 bit) | 设置为0以请求正常交付延迟；如果请求低延迟交付，则设置为1。|'
- en: '| T | 1/8 (1 bit) | Set to 0 to request normal delivery throughput; set to
    1 if higher throughput delivery is requested. |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '| T | 1/8 (1 bit) | 设置为0以请求正常交付吞吐量；如果请求更高的吞吐量交付，则设置为1。|'
- en: '| R | 1/8 (1 bit) | Set to 0 to request normal reliability in delivery; set
    to 1 if higher reliability delivery is requested. |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '| R | 1/8 (1 bit) | 设置为0以请求正常交付可靠性；如果请求更高的可靠性交付，则设置为1。|'
- en: '| Reserved | 2/8 (2 bits) | Not used. |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 2/8 (2 bits) | 未使用。|'
- en: IP Datagram Options and Option Format
  id: totrans-1038
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP数据报选项和选项格式
- en: All IP datagrams must include the standard 20-byte header that contains key
    information such as the source and destination address of the datagram, fragmentation
    control parameters, length information, and more. In addition to these invariable
    fields, the creators of IPv4 included the ability to add *options* that provide
    additional flexibility in how IP handles datagrams. Use of these options is, of
    course, optional. However, all devices that handle IP datagrams must be capable
    of properly reading and handling them.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 所有IP数据报都必须包含包含数据报源和目的地址、分片控制参数、长度信息等关键信息的标准20字节报头。除了这些固定字段外，IPv4的创建者还包括了添加*选项*的能力，这些选项为IP处理数据报提供了额外的灵活性。当然，使用这些选项是可选的。然而，所有处理IP数据报的设备都必须能够正确读取和处理它们。
- en: The IP datagram may contain zero, one, or more options, so the total length
    of the Options field in the IP header is variable. Each of the options can be
    a single byte or multiple bytes in length, depending on how much information the
    option needs to convey. When more than one option is included, they are concatenated
    and put into the Options field as a whole. Since the IP header must be a multiple
    of 32 bits, a Padding field is included if the number of bits in all options together
    is not a multiple of 32 bits.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: IP数据报可能包含零个、一个或多个选项，因此IP头中选项字段的长度是可变的。每个选项可以是单个字节或多个字节，具体取决于选项需要传达多少信息。当包含多个选项时，它们被连接起来作为一个整体放入选项字段中。由于IP头必须是32位的倍数，如果所有选项中的位数不是32位的倍数，则包括一个填充字段。
- en: 'Each IP option has its own subfield format, generally structured as shown in
    Tables [Table 21-5](ch21s03.html#ipv_option_format "Table 21-5. IPv4 Option Format")
    and [Table 21-6](ch21s03.html#ipv_options_option_type_subfields "Table 21-6. IPv4
    Options: Option Type Subfields"), and illustrated in [Figure 21-3](ch21s03.html#ipv4_options_field_format_this_diagram_s
    "Figure 21-3. IPv4 Options field format This diagram shows the full field format
    for an IPv4 option. Note that a few simple options may consist of only the Option
    Type subfield, with the Option Length and Option Data subfields omitted."). For
    most options, all three subfields are used: Option Type, Option Length, and Option
    Data. For a few simple options, however, this complex substructure is not needed.
    In those cases, the option type itself communicates all the information required,
    so the Option Type field appears, and the Option Length and Option Data subfields
    are omitted.'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 每个IP选项都有自己的子字段格式，通常结构如[表21-5](ch21s03.html#ipv_option_format "表21-5. IPv4选项格式")和[表21-6](ch21s03.html#ipv_options_option_type_subfields
    "表21-6. IPv4选项：选项类型子字段")所示，并在[图21-3](ch21s03.html#ipv4_options_field_format_this_diagram_s
    "图21-3. IPv4选项字段格式 此图显示了IPv4选项的完整字段格式。注意，一些简单的选项可能只包含选项类型子字段，省略了选项长度和选项数据子字段。")中说明。对于大多数选项，都使用所有三个子字段：选项类型、选项长度和选项数据。然而，对于一些简单的选项，这种复杂的子结构是不必要的。在这些情况下，选项类型本身就包含了所需的所有信息，因此只出现选项类型字段，省略了选项长度和选项数据子字段。
- en: Table 21-5. IPv4 Option Format
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-5. IPv4选项格式
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Option Type | 1 | The Option Type subfield is divided into three subsubfields,
    as shown in [Table 21-6](ch21s03.html#ipv_options_option_type_subfields "Table 21-6. IPv4
    Options: Option Type Subfields"). |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| 选项类型 | 1 | 选项类型子字段分为三个子子字段，如[表21-6](ch21s03.html#ipv_options_option_type_subfields
    "表21-6. IPv4选项：选项类型子字段")所示。 |'
- en: '| Option Length | 0 or 1 | For variable-length options, indicates the size
    of the entire option, including all three subfields shown here, in bytes. |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '| 选项长度 | 0或1 | 对于可变长度选项，指示整个选项的大小，包括此处显示的所有三个子字段，以字节为单位。 |'
- en: '| Option Data | 0 or variable | For variable-length options, contains data
    to be sent as part of the option. |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
  zh: '| 选项数据 | 0或可变 | 对于可变长度选项，包含作为选项一部分发送的数据。 |'
- en: 'Table 21-6. IPv4 Options: Option Type Subfields'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-6. IPv4选项：选项类型子字段
- en: '| Sub-Subfield Name | Size (Bytes) | Description |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '| 子子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1050
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Copied Flag | 1/8 (1 bit) | This bit is set to 1 if the option is intended
    to be copied into all fragments when a datagram is fragmented; it is cleared to
    0 if the option should not be copied into fragments. |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '| 复制标志 | 1/8 (1位) | 如果选项旨在在数据报分片时复制到所有分片中，则此位设置为1；如果选项不应复制到分片中，则清除为0。 |'
- en: '| Option Class | 2/8 (2 bits) | Specifies one of four potential values that
    indicate the general category into which the option belongs. In fact, only two
    of the values are used: 0 is for Control options, and 2 for Debugging and Measurement.
    |'
  id: totrans-1052
  prefs: []
  type: TYPE_TB
  zh: '| 选项类别 | 2/8 (2位) | 指定选项所属的四个潜在值之一，表示选项的一般类别。实际上，只使用了其中的两个值：0用于控制选项，2用于调试和测量。
    |'
- en: '| Option Number | 5/8 (5 bits) | Specifies the kind of option. 32 different
    values can be specified for each of the two option classes. Of these, a few are
    more commonly employed. See [Table 21-7](ch21s03.html#common_ipv_options "Table 21-7. Common
    IPv4 Options") for more information on the specific options. |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '| 选项编号 | 5/8 (5位) | 指定选项的类型。对于两个选项类别中的每一个，可以指定32个不同的值。其中，一些值更常用。有关特定选项的更多信息，请参阅[表21-7](ch21s03.html#common_ipv_options
    "表21-7. 常见IPv4选项")。 |'
- en: '[Table 21-7](ch21s03.html#common_ipv_options "Table 21-7. Common IPv4 Options")
    lists the most common IPv4 options, showing the option class, option number, and
    length for each (a length of 1 indicates that an option consists of only an Option
    Type field). The table also provides a brief description of how each is used.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '[表21-7](ch21s03.html#common_ipv_options "表21-7. 常见IPv4选项")列出了最常见的IPv4选项，显示了每个选项的选项类别、选项编号和长度（长度为1表示选项仅由选项类型字段组成）。该表还提供了每个选项的简要使用说明。'
- en: '![IPv4 Options field format This diagram shows the full field format for an
    IPv4 option. Note that a few simple options may consist of only the Option Type
    subfield, with the Option Length and Option Data subfields omitted.](httpatomoreillycomsourcenostarchimages287855.png.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4选项字段格式 此图显示了IPv4选项的完整字段格式。请注意，一些简单的选项可能仅包含选项类型子字段，省略了选项长度和选项数据子字段。](httpatomoreillycomsourcenostarchimages287855.png.jpg)'
- en: Figure 21-3. IPv4 Options field format This diagram shows the full field format
    for an IPv4 option. Note that a few simple options may consist of only the Option
    Type subfield, with the Option Length and Option Data subfields omitted.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 图21-3. IPv4选项字段格式 此图显示了IPv4选项的完整字段格式。请注意，一些简单的选项可能仅包含选项类型子字段，省略了选项长度和选项数据子字段。
- en: Table 21-7. Common IPv4 Options
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-7. 常见IPv4选项
- en: '| Option Class | Option Number | Length (Bytes) | Option Name | Description
    |'
  id: totrans-1058
  prefs: []
  type: TYPE_TB
  zh: '| 选项类 | 选项号 | 长度（字节） | 选项名称 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-1059
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 1 | End of Options List | An option containing just a single zero
    byte, used to mark the end of a list of options. |'
  id: totrans-1060
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 选项列表结束 | 包含单个零字节的选项，用于标记选项列表的结束。 |'
- en: '| 0 | 1 | 1 | No Operation | A "dummy option" used as internal padding to align
    certain options on a 32-bit boundary when required. |'
  id: totrans-1061
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 无操作 | 一种“虚拟选项”，用作内部填充，以便在需要时将某些选项对齐到32位边界。 |'
- en: '| 0 | 2 | 11 | Security | An option provided for the military to indicate the
    security classification of IP datagrams. |'
  id: totrans-1062
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 2 | 11 | 安全 | 为军事部门提供的一个选项，用于指示IP数据报的安全分类。 |'
- en: '| 0 | 3 | Variable | Loose Source Route | One of two options for source routing
    of IP datagrams. |'
  id: totrans-1063
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 3 | 可变 | 松散源路由 | IP数据报源路由的两种选项之一。 |'
- en: '| 0 | 7 | Variable | Record Route | Allows the route used by a datagram to
    be recorded within the header for the datagram itself. If a source device sends
    a datagram with this option in it, each router that handles the datagram adds
    its IP address to this option. The recipient can then extract the list of IP addresses
    to see the route taken by the datagram. Note that the length of this option is
    set by the originating device. It cannot be enlarged as the datagram is routed,
    and if it fills up before it arrives at its destination, only a partial route
    will be recorded. |'
  id: totrans-1064
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 7 | 可变 | 记录路由 | 允许将数据报使用的路由记录在数据报本身的头部中。如果源设备发送包含此选项的数据报，则处理数据报的每个路由器都会将其IP地址添加到此选项中。接收者可以提取IP地址列表，以查看数据报所经过的路由。请注意，此选项的长度由源设备设置。在数据报路由过程中不能扩大，如果它在到达目的地之前填满，则只能记录部分路由。
    |'
- en: '| 0 | 9 | Variable | Strict Source Route | One of two options for source routing
    of IP datagrams. |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 9 | 可变 | 严格源路由 | IP数据报源路由的两种选项之一。 |'
- en: '| 2 | 4 | Variable | Timestamp | Works similar to the Record Route option,
    but each device puts in a timestamp, so the recipient can see how long it took
    for the datagram to travel between routers. As with the Record Route option, the
    length of this option is set by the originating device and cannot be enlarged
    by intermediate devices. |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 可变 | 时间戳 | 与记录路由选项类似，但每个设备都会放入一个时间戳，因此接收者可以看到数据报在路由器之间传输所需的时间。与记录路由选项一样，此选项的长度由源设备设置，中间设备不能扩大。
    |'
- en: '| 2 | 18 | 12 | Traceroute | Used in the enhanced implementation of the traceroute
    utility, as described in RFC 1393\. Also see [Chapter 33](ch33.html "Chapter 33. ICMPV4
    INFORMATIONAL MESSAGE TYPES AND FORMATS"), which discusses ICMP traceroute messages.
    |'
  id: totrans-1067
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 18 | 12 | 跟踪路由 | 用于跟踪路由实用程序的增强实现，如RFC 1393所述。另见[第33章](ch33.html "第33章。ICMPV4信息消息类型和格式")，其中讨论了ICMP跟踪路由消息。'
- en: Tip
  id: totrans-1068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Each IPv4 datagram has a 20-byte mandatory header and may also
    include one or more *options*. Each option has its own field format, and most
    are variable in size.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个IPv4数据报包含一个20字节的强制头，并且可能包含一个或多个*选项*。每个选项都有自己的字段格式，并且大多数的大小是可变的。'
- en: Normally, IP datagrams are routed without any specific instructions from devices
    about the path a datagram should take from the source to the destination. It's
    the job of routers to use routing protocols and to figure out those details. In
    some cases, however, it may be advantageous to have the source of a datagram specify
    the route a datagram takes through the network. This process is called *source
    routing*.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，IP 数据报在没有任何特定指令的情况下被路由，这些指令说明数据报应从源到目的地采取的路径。这是路由器的任务，使用路由协议并找出这些细节。然而，在某些情况下，让数据报的源指定数据报在网络中采取的路径可能是有利的。这个过程被称为*源路由*。
- en: There are two IP options that support source routing. In each, the option includes
    a list of IP addresses that specify the routers that must be used to reach the
    destination. When *strict* source routing is used, the path specified in the option
    must be used exactly, in sequence, with no other routers permitted to handle the
    datagram at all. In contrast, *loose* source routing specifies a list of IP addresses
    that must be followed in sequence, but it allows intervening hops between the
    devices on the list. (For full details on the exact structure used by each option
    type, please refer to RFC 791.)
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种 IP 选项支持源路由。在每个选项中，选项包括一个 IP 地址列表，指定了必须使用的路由器以到达目的地。当使用*严格*源路由时，选项中指定的路径必须完全、按顺序使用，不允许其他路由器处理数据报。相比之下，*宽松*源路由指定了一个必须按顺序遵循的
    IP 地址列表，但它允许列表中设备之间的中间跳数。（有关每种选项类型使用的确切结构的完整详细信息，请参阅 RFC 791。）
- en: Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY
  id: totrans-1072
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 22 章。IP 数据报大小、分片和重组
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-1073
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The main responsibility of the Internet Protocol (IP) is to deliver data between
    internetworked devices. As you saw in the preceding chapter, this requires that
    data received from higher layers be encapsulated into IP datagrams for transmission.
    These datagrams are then passed down to the data link layer, where they are sent
    over physical network links. In order for this to work properly, each datagram
    must be small enough to fit within the frame format of the underlying technology.
    If the message is bigger than the maximum frame size of the underlying network,
    it may be necessary to fragment the message. The datagrams are then sent individually
    and reassembled into the original message.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）的主要责任是在互连设备之间传输数据。正如你在上一章中看到的，这要求从高层接收到的数据必须封装成 IP 数据报进行传输。然后，这些数据报被传递到数据链路层，在那里它们通过物理网络链路发送。为了使这个过程正常工作，每个数据报必须足够小，以便能够适应底层技术的帧格式。如果消息比底层网络的帧大小最大值还要大，可能需要将消息分片。然后，这些数据报单独发送，并重新组装成原始消息。
- en: IP is designed to manage datagram size and to make fragmentation and reassembly
    seamless. This chapter explores issues related to managing the size of IP datagrams.
    I start with an overview of datagram size issues and the important concept of
    a network's maximum transmission unit (MTU), discussing why fragmentation is necessary.
    I then describe the process by which messages are fragmented by the source device,
    and possibly by routers along the path to the destination, and how they are reassembled
    by the recipient.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: IP 被设计用来管理数据报大小，并使分片和重组无缝。本章探讨了与 IP 数据报大小管理相关的问题。我从对数据报大小问题的概述和网络的传输单元（MTU）这一重要概念进行讨论开始，讨论为什么分片是必要的。然后，我描述了消息如何由源设备分片，以及可能由路径上的路由器分片，以及它们如何被接收者重新组装。
- en: Tip
  id: totrans-1076
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *Understanding fragmentation and reassembly requires
    some knowledge of the basic format of IP datagrams and some of the fields they
    contain. If you haven''t yet read the chapter describing the general format of
    IP datagrams in [Chapter 21](ch21.html "Chapter 21. INTERNET PROTOCOL DATAGRAM
    ENCAPSULATION AND FORMATTING"), you may wish to review it before proceeding here.*'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** 理解分片和重组需要一些关于 IP 数据报基本格式及其包含的一些字段的知识。如果你还没有阅读描述第 21 章中 IP 数据报通用格式的章节[第
    21 章](ch21.html "第 21 章。互联网协议数据报封装和格式化")，你可能希望在继续之前先复习一下。'
- en: IP Datagram Size, MTU, and Fragmentation Overview
  id: totrans-1078
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 数据报大小、MTU 和分片概述
- en: As the core network layer protocol of the TCP/IP protocol suite, IP is designed
    to implement potentially large internetworks of devices. When we work with IP,
    we get used to the concept of hosts being able to send information back and forth,
    even though the hosts may be quite far apart. Although we can usually consider
    the TCP/IP internetwork to be like a large, abstract virtual network of devices,
    we must always remember that underneath the network layer, data always travels
    across one or more physical networks. The implementation of IP must take this
    reality into account as well.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 作为TCP/IP协议套件的核心网络层协议，IP被设计用来实现可能非常大的设备互联网。当我们使用IP时，我们习惯了主机能够相互发送信息，尽管这些主机可能相隔甚远。尽管我们通常可以将TCP/IP互联网视为一个大型、抽象的虚拟设备网络，但我们必须始终记住，在网络层之下，数据总是穿越一个或多个物理网络。IP的实现必须考虑到这一现实。
- en: 'In order to send messages using IP, we encapsulate the higher-layer data into
    IP datagrams. These datagrams must then be sent down to the data link layer, where
    they are further encapsulated into the frames of whatever technology will be used
    to physically convey them, either directly to their destination or indirectly
    to the next intermediate step in their journey to their intended recipient. The
    data link layer implementation puts the entire IP datagram into the data portion
    (the payload) of its frame format, just as IP puts transport layer messages—transport
    headers and all—into its IP Data field. This immediately presents us with a potential
    issue: matching the size of the IP datagram to the size of the underlying data
    link layer frame size.'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用IP发送消息，我们将高层数据封装成IP数据报。然后，这些数据报必须发送到数据链路层，在那里它们被进一步封装成用于物理传输的帧格式，无论是直接发送到目的地还是间接发送到旅程中的下一个中间步骤。数据链路层实现将整个IP数据报放入其帧格式的数据部分（有效载荷），就像IP将传输层消息——包括传输头——放入其IP数据字段一样。这立即向我们提出了一个潜在问题：匹配IP数据报的大小与底层数据链路层帧大小。
- en: IP Datagram Size and the Underlying Network Frame Size
  id: totrans-1081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP数据报大小和底层网络帧大小
- en: The underlying network that a device uses to connect to other devices could
    be a local area network (LAN) connection (like Ethernet or Token Ring), wireless
    LAN (WLAN) link (such as 802.11), dial-up connection, Digital Subscriber Line
    (DSL) connection, T1 link, or other wide area network (WAN) connection. Each physical
    network will generally use its own frame format, and each format has a limit on
    how much data can be sent in a single frame. If the IP datagram is too large for
    the data link layer frame format's payload section, we have a problem!
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 设备用于连接其他设备的底层网络可能是局域网（LAN）连接（如以太网或令牌环），无线局域网（WLAN）链路（如802.11），拨号连接，数字用户线路（DSL）连接，T1链路，或其他广域网（WAN）连接。每个物理网络通常使用自己的帧格式，每种格式都有限制，即单帧可以发送多少数据。如果IP数据报太大，无法适应数据链路层帧格式的有效载荷部分，我们就遇到了问题！
- en: For example, consider a Fiber Distributed Data Interface (FDDI) network. The
    maximum size of the data field in FDDI is around 4,470 bytes. This means FDDI
    can handle an IP datagram of up to 4,470 bytes. In contrast, a regular Ethernet
    frame uses a frame format that limits the size of the payload it sends to 1,500
    bytes. This means that Ethernet cannot deal with IP datagrams greater than 1,500
    bytes.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个光纤分布式数据接口（FDDI）网络。FDDI数据字段的最大大小约为4,470字节。这意味着FDDI可以处理最大为4,470字节的IP数据报。相比之下，常规以太网帧使用一个帧格式，限制了其发送的有效载荷大小为1,500字节。这意味着以太网无法处理大于1,500字节的IP数据报。
- en: Now, remember that in sending a datagram across an internetwork, it may pass
    across more than one physical network. To access a site on the Internet, for example,
    we typically send a request through our local router, which then connects to other
    routers that eventually relay the request to the Internet site. Each hop as the
    datagram is forwarded may use a different physical network, with a different maximum
    underlying frame size.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请记住，在发送数据报跨互联网时，它可能穿过多个物理网络。例如，为了访问互联网上的一个站点，我们通常通过我们的本地路由器发送请求，然后该路由器连接到其他路由器，最终将请求转发到互联网站点。数据报在转发过程中每跳可能使用不同的物理网络，具有不同的最大帧大小。
- en: The whole idea behind a network layer protocol is to implement this concept
    of a virtual network where devices can communicate over great distances. This
    means that higher layers shouldn't need to worry about details like the size limits
    of underlying data link layer technologies. This task falls to IP.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层协议背后的整个想法是实现这个虚拟网络的概念，在这个网络中，设备可以在很远的距离上通信。这意味着高层不需要担心底层数据链路层技术的尺寸限制等细节。这项任务由IP层负责。
- en: MTU and Datagram Fragmentation
  id: totrans-1086
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MTU和数据报分片
- en: Each device on an IP internetwork must know the capacity of its immediate data
    link layer connection to other devices. This capacity is called the *maximum transmission
    unit (MTU)* of the network, also known as the *maximum transfer unit*.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: IP互联网上的每个设备都必须知道其与其它设备直接数据链路层连接的容量。这个容量被称为网络的*最大传输单元（MTU）*，也称为*最大传输单元*。
- en: If an IP layer receives a message to be sent across the internetwork, it looks
    at the size of the message and then computes how large the IP datagram would be
    after the addition of the 20 or more bytes needed for the IP header. If the total
    length is greater than the MTU of the underlying network, the IP layer will fragment
    the message into multiple IP fragments. Thus, if a host is connected to its local
    network using an Ethernet LAN, it may use an MTU of 1,500 bytes for IP datagrams,
    and it will fragment anything larger.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IP层收到一个需要通过互联网发送的消息，它会查看消息的大小，然后计算在添加20个或更多字节（用于IP头部）后，IP数据报的大小。如果总长度超过底层网络的MTU（最大传输单元），IP层将把消息分成多个IP片段。因此，如果一个主机通过以太网局域网连接到其本地网络，它可能为IP数据报使用1,500字节的MTU，并且它会将任何更大的数据报进行分片。
- en: '[Figure 22-1](ch22.html#ip_maximum_transmission_unit_mtu_and_fra "Figure 22-1. IP
    maximum transmission unit (MTU) and fragmentation In this simple example, Device
    A is sending to Device B over a small internetwork consisting of one router and
    two physical links. The link from Device A to the router has an MTU of 3,300 bytes,
    but from the router to Device B, it is only 1,300 bytes. Thus, any IP datagrams
    larger than 1,300 bytes will need to be fragmented.") shows an example of different
    MTUs and fragmentation.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: '[图22-1](ch22.html#ip_maximum_transmission_unit_mtu_and_fra "图22-1. IP最大传输单元（MTU）和分片
    在这个简单的例子中，设备A通过一个由一个路由器和两个物理链路组成的小型互联网向设备B发送数据。从设备A到路由器的链路MTU为3,300字节，但从路由器到设备B，它只有1,300字节。因此，任何大于1,300字节的IP数据报都需要进行分片。")展示了不同MTU和分片的例子。'
- en: Tip
  id: totrans-1090
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The size of the largest IP datagram that can be transmitted
    over a physical network is called that network''s *maximum transmission unit (MTU)*.
    If a datagram is passed from a network with a high MTU to one with a low MTU,
    it must be fragmented to fit the other network''s smaller MTU.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 可以通过物理网络传输的最大IP数据报的大小被称为该网络的*最大传输单元（MTU）*。如果一个数据报从一个MTU较高的网络传递到MTU较低的网络，它必须被分片以适应另一个网络较小的MTU。'
- en: 'Since some physical networks on the path between devices may have a smaller
    MTU than others, it may be necessary to fragment the datagram more than once.
    For example, suppose the source device wants to send an IP message 12,000 bytes
    long. Its local connection has an MTU of 3,300 bytes. It will need to divide this
    message into four fragments for transmission: three that are about 3,300 bytes
    long and a fourth remnant about 2,100 bytes long. (I''m oversimplifying by ignoring
    the extra headers required; the "The IP Message Fragmentation Process" section
    later in this chapter includes the full details of the fragmentation process.)'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备之间的路径上的一些物理网络可能具有比其他网络更小的MTU，可能需要多次分片数据报。例如，假设源设备想要发送一个12,000字节长的IP消息。它的本地连接MTU为3,300字节。它需要将这个消息分成四个片段进行传输：三个大约3,300字节长，一个剩余大约2,100字节长。（我在简化过程中忽略了额外的头部；本章后面的“IP消息分片过程”部分包括了分片过程的全部细节。）
- en: '![IP maximum transmission unit (MTU) and fragmentation In this simple example,
    Device A is sending to Device B over a small internetwork consisting of one router
    and two physical links. The link from Device A to the router has an MTU of 3,300
    bytes, but from the router to Device B, it is only 1,300 bytes. Thus, any IP datagrams
    larger than 1,300 bytes will need to be fragmented.](httpatomoreillycomsourcenostarchimages287857.png.jpg)'
  id: totrans-1093
  prefs: []
  type: TYPE_IMG
  zh: '![IP最大传输单元（MTU）和分片 在这个简单的例子中，设备A通过一个由一个路由器和两个物理链路组成的小型互联网向设备B发送数据。从设备A到路由器的链路MTU为3,300字节，但从路由器到设备B，它只有1,300字节。因此，任何大于1,300字节的IP数据报都需要进行分片。](httpatomoreillycomsourcenostarchimages287857.png.jpg)'
- en: Figure 22-1. IP maximum transmission unit (MTU) and fragmentation In this simple
    example, Device A is sending to Device B over a small internetwork consisting
    of one router and two physical links. The link from Device A to the router has
    an MTU of 3,300 bytes, but from the router to Device B, it is only 1,300 bytes.
    Thus, any IP datagrams larger than 1,300 bytes will need to be fragmented.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 图 22-1. IP 最大传输单元 (MTU) 和分片 在这个简单的例子中，设备 A 通过一个由一个路由器和两个物理链路组成的小型互联网向设备 B 发送数据。从设备
    A 到路由器的链路 MTU 为 3,300 字节，但从路由器到设备 B，仅为 1,300 字节。因此，任何大于 1,300 字节的 IP 数据报都需要进行分片。
- en: Multiple-Stage Fragmentation
  id: totrans-1095
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多阶段分片
- en: While the IP fragments are in transit, they may need to pass over a hop between
    two routers where the physical network's MTU is only 1,300 bytes. In this case,
    each of the fragments will again need to be fragmented. The 3,300-byte fragments
    will end up in three pieces each (two of about 1,300 bytes and one of around 700
    bytes), and the final 2,100-byte fragment will become a 1,300-byte and 800-byte
    fragment. So, instead of having four fragments, we will end up with eleven (3*3+1*2)
    fragments, as shown in [Figure 22-2](ch22.html#ipv4_datagram_fragmentation_this_example
    "Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step
    fragmentation of a large IP datagram. The boxes represent datagrams or datagram
    fragments and are shown to scale. The original datagram is 12,000 bytes, represented
    by the large, gray box. To transmit this data over the first local link, Device
    A splits it into four fragments, shown on the left. The first router must fragment
    each of these into smaller fragments to send them over the 1,300-byte MTU link,
    as shown on the bottom. Note that the second router does not reassemble the 1,300-byte
    fragments, even though its link to Device B has an MTU of 3,300 bytes. (The "IP
    Fragmentation Process" section later in this chapter describes the process by
    which the fragments in this example are created.)").
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 当 IP 分片在传输过程中，它们可能需要通过一个物理网络 MTU 只有 1,300 字节的两个路由器之间的跳。在这种情况下，每个分片又需要再次分片。3,300
    字节的分片最终将分成三块（两块大约 1,300 字节和一块大约 700 字节），最后的 2,100 字节分片将变成一个 1,300 字节和一个 800 字节的分片。因此，我们最终将得到
    11 个分片（3*3+1*2），如图 [图 22-2](ch22.html#ipv4_datagram_fragmentation_this_example
    "图 22-2. IPv4 数据报分片。本例说明了大型 IP 数据报的两步分片过程。方框代表数据报或数据报片段，并按比例显示。原始数据报为 12,000 字节，由大灰框表示。为了通过第一个本地链路传输这些数据，设备
    A 将其分成四个片段，如图左侧所示。第一个路由器必须将这些每个分片进一步分割成更小的片段，以便通过 1,300 字节 MTU 链路发送，如图底部所示。请注意，第二个路由器不会重新组装
    1,300 字节的数据报片段，尽管其与设备 B 的链路 MTU 为 3,300 字节。（本章后面的“IP 分片过程”部分描述了创建本例中片段的过程。）")
    所示。
- en: '![IPv4 datagram fragmentation. This example illustrates a two-step fragmentation
    of a large IP datagram. The boxes represent datagrams or datagram fragments and
    are shown to scale. The original datagram is 12,000 bytes, represented by the
    large, gray box. To transmit this data over the first local link, Device A splits
    it into four fragments, shown on the left. The first router must fragment each
    of these into smaller fragments to send them over the 1,300-byte MTU link, as
    shown on the bottom. Note that the second router does not reassemble the 1,300-byte
    fragments, even though its link to Device B has an MTU of 3,300 bytes. (The "IP
    Fragmentation Process" section later in this chapter describes the process by
    which the fragments in this example are created.)](httpatomoreillycomsourcenostarchimages287859.png.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4 数据报分片。本例说明了大型 IP 数据报的两步分片过程。方框代表数据报或数据报片段，并按比例显示。原始数据报为 12,000 字节，由大灰框表示。为了通过第一个本地链路传输这些数据，设备
    A 将其分成四个片段，如图左侧所示。第一个路由器必须将这些每个分片进一步分割成更小的片段，以便通过 1,300 字节 MTU 链路发送，如图底部所示。请注意，第二个路由器不会重新组装
    1,300 字节的数据报片段，尽管其与设备 B 的链路 MTU 为 3,300 字节。（本章后面的“IP 分片过程”部分描述了创建本例中片段的过程。）](httpatomoreillycomsourcenostarchimages287859.png.jpg)'
- en: Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step
    fragmentation of a large IP datagram. The boxes represent datagrams or datagram
    fragments and are shown to scale. The original datagram is 12,000 bytes, represented
    by the large, gray box. To transmit this data over the first local link, Device
    A splits it into four fragments, shown on the left. The first router must fragment
    each of these into smaller fragments to send them over the 1,300-byte MTU link,
    as shown on the bottom. Note that the second router does not reassemble the 1,300-byte
    fragments, even though its link to Device B has an MTU of 3,300 bytes. (The "IP
    Fragmentation Process" section later in this chapter describes the process by
    which the fragments in this example are created.)
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 图22-2. IPv4数据报分片。此示例说明了大型IP数据报的两步分片。方框代表数据报或数据报片段，并按比例显示。原始数据报为12,000字节，由大灰框表示。为了通过第一个本地链路传输这些数据，设备A将其分成四个片段，如图左侧所示。第一个路由器必须将这些每个分片进一步分割成更小的片段，以便通过1,300字节的MTU链路发送，如图底部所示。请注意，第二个路由器不会重新组装1,300字节的片段，尽管其连接到设备B的链路的MTU为3,300字节。（本章后面的“IP分片过程”部分将描述创建此示例中片段的过程。）
- en: 'Internet Minimum MTU: 576 Bytes'
  id: totrans-1099
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网最小MTU：576字节
- en: Routers are required to handle an MTU of at least 576 bytes. This value is specified
    in RFC 791; it was chosen to allow a data block of at least 512 bytes, plus room
    for the standard IP header and options. Since this is the minimum size specified
    in the IP standard, 576 bytes has become a common default MTU value used for IP
    datagrams. Even if a host is connected over a local network with an MTU larger
    than 576 bytes, it may choose to use an MTU value of 576 to ensure that no further
    fragmentation will be required by intermediate routers.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器需要处理至少576字节的MTU（最大传输单元）。这个值在RFC 791中指定；它被选择以允许至少512字节的数据块，以及标准IP头和选项的空间。由于这是IP标准中指定的最小尺寸，576字节已成为用于IP数据报的常见默认MTU值。即使主机通过大于576字节的MTU的本地网络连接，它也可能选择使用576字节的MTU值，以确保中间路由器不需要进一步分片。
- en: Note
  id: totrans-1101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*While intermediate routers may further fragment an already-fragmented IP message,
    they do not reassemble fragments. Reassembly is done only by the recipient device.
    This has some advantages and some disadvantages, as we will see when we examine
    the reassembly process in the "IP Message Reassembly" section later in this chapter*.'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然中间路由器可能会进一步分片已经分片的IP消息，但它们不会重新组装片段。重新组装仅由接收设备完成。这有一些优点和缺点，我们将在本章后面的“IP消息重新组装”部分检查重新组装过程时看到。*'
- en: MTU Path Discovery
  id: totrans-1103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MTU路径发现
- en: When we're trying to send a great deal of data, efficiency in message transmissions
    becomes important. The larger the IP datagram we send, the smaller the percentage
    of bytes wasted for overhead such as header fields. This means that, ideally,
    we want to use the largest MTU possible without requiring fragmentation for its
    transmission.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图发送大量数据时，消息传输的效率变得很重要。我们发送的IP数据报越大，用于开销（如头部字段）的字节浪费百分比就越小。这意味着，理想情况下，我们希望使用尽可能大的MTU，而无需对其进行传输分片。
- en: To determine the optimal MTU to use for a route between two devices, we would
    need to know the MTU of every link on that route—information that the endpoints
    of the connection simply don't have. However, the connection endpoint can determine
    the MTU of the overall route by using *MTU path discovery*, which uses an error-reporting
    mechanism built into TCP/IP Internet Control Message Protocol (ICMP).
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定两个设备之间路由的最佳MTU，我们需要知道该路由上每个链路的MTU——这是连接端点所没有的信息。然而，连接端点可以通过使用*MTU路径发现*来确定整个路由的MTU，该机制使用TCP/IP互联网控制消息协议（ICMP）中内置的错误报告机制。
- en: One of the message types defined in ICMP version 4 (ICMPv4) is the Destination
    Unreachable message (see [Chapter 32](ch32.html "Chapter 32. ICMPV4 ERROR MESSAGE
    TYPES AND FORMATS")), which is returned under various conditions where an IP datagram
    cannot be delivered. One of these situations is when a datagram is too large to
    be forwarded by a router over a physical link, but this datagram has its Don't
    Fragment (DF) flag set to prevent fragmentation. In this case, the datagram must
    be discarded and a Destination Unreachable message sent back to the source. A
    device can exploit this capability by testing the path with datagrams of different
    sizes, to see how large they must be before they are rejected.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 在ICMP版本4（ICMPv4）中定义的消息类型之一是目标不可达消息（见[第32章](ch32.html "第32章。ICMPV4错误消息类型和格式")），在IP数据报无法交付的各种情况下返回。这些情况之一是当数据报太大，无法通过物理链路上的路由器转发，但该数据报的“不要分片”（DF）标志被设置为防止分片。在这种情况下，必须丢弃数据报并向源发送目标不可达消息。设备可以通过使用不同大小的数据报测试路径来利用这种功能，以查看它们必须有多大才会被拒绝。
- en: The source node typically sends a datagram that has the MTU of its local physical
    link, since that represents an upper bound for any path to or from that device.
    If this datagram goes through without any errors, the device knows it can use
    that value for future datagrams to that destination. If it gets back any Destination
    Unreachable - Fragmentation Needed and DF Set messages, it knows that a link between
    it and the destination has a smaller MTU. It tries again using a smaller datagram
    size, and it continues until it finds the largest MTU that can be used on the
    path.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 源节点通常发送一个具有其本地物理链路MTU的数据报，因为这代表从该设备到任何路径的上限。如果这个数据报没有错误地通过，设备就知道它可以使用这个值来发送到该目的地的未来数据报。如果它收到任何“目标不可达
    - 需要分片和DF设置”消息，它就知道它和目的地之间的链路有一个更小的MTU。它再次尝试使用更小的数据报大小，并继续直到它找到路径上可以使用的最大MTU。
- en: IP Message Fragmentation Process
  id: totrans-1108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP消息分片过程
- en: As explained in the previous section, when an IP datagram is too large for the
    MTU of the underlying data link layer technology used for the next leg of its
    journey, it must be fragmented before it can be sent across the network. The higher-layer
    message to be transmitted is not sent in a single IP datagram, but rather broken
    down into fragments that are sent separately. In some cases, the fragments themselves
    may need to be fragmented further.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当一个IP数据报对于用于其旅程下一阶段的底层数据链路层技术的MTU太大时，它必须在发送到网络之前进行分片。要传输的较高层消息不是在一个单独的IP数据报中发送，而是分解成单独发送的片段。在某些情况下，这些片段本身可能还需要进一步分片。
- en: 'Fragmentation is key to implementing a network-layer internetwork that is independent
    of lower-layer details, but it introduces significant complexity to IP. Remember
    that IP is an unreliable, connectionless protocol. IP datagrams can take any of
    several routes on their way from the source to the destination, and some may not
    even make it to the destination at all. When a message is fragmented, this converts
    a single datagram into many, which introduces several new concerns:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 分片是实现独立于底层细节的网络层互连的关键，但它给IP带来了显著复杂性。记住，IP是一个不可靠的无连接协议。IP数据报可以从源到目的地的任何路径中选择，有些甚至可能根本无法到达目的地。当消息被分片时，这会将单个数据报转换为多个，从而引入几个新的问题：
- en: '**Sequencing and Placement** The fragments will typically be sent in sequential
    order from the beginning of the message to the end, but they won''t necessarily
    show up in the order in which they were sent. The receiving device must be able
    to determine the sequence of the fragments to reassemble them in the correct order.
    In fact, some implementations send the last fragment first, so the receiving device
    will immediately know the full size of the original, complete datagram. This makes
    keeping track of the order of segments even more essential.'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化和放置** 片段通常按照从消息开始到结束的顺序发送，但它们不一定按照发送的顺序出现。接收设备必须能够确定片段的顺序，以便按正确顺序重新组装它们。实际上，某些实现首先发送最后一个片段，这样接收设备就会立即知道原始完整数据报的大小。这使得跟踪段顺序变得更加重要。'
- en: '**Separation of Fragmented Messages** A source device may need to send more
    than one fragmented message at a time, or it may send multiple datagrams that
    are fragmented en route. This means that the destination may be receiving multiple
    sets of fragments that must be put back together. Imagine a box containing pieces
    from two, three, or more jigsaw puzzles, and you understand this issue.'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '**碎片化消息的分离** 源设备可能需要一次发送多个碎片化消息，或者它可能发送在途中被碎片化的多个数据报。这意味着目标设备可能正在接收多组碎片，这些碎片需要重新组合。想象一个包含来自两个、三个或更多拼图碎片的大盒子，你就理解这个问题了。'
- en: '**Completion** The destination device must be able to tell when it has received
    all of the fragments so it knows when to start reassembly (or when to give up
    if it didn''t get all the pieces).'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '**完成** 目标设备必须能够判断它是否已经收到了所有碎片，以便知道何时开始重组（或者如果它没有收到所有碎片，何时放弃）。'
- en: To address these concerns and allow the proper reassembly of the fragmented
    message, IP includes several fields in the IP format header that convey information
    from the source to the destination about the fragments. Some of these fields contain
    a common value for all the fragments of the message; others are different for
    each fragment.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些担忧并允许正确重组碎片化的消息，IP协议在IP格式头部中包含几个字段，这些字段从源地址传递到目标地址有关碎片的信息。其中一些字段包含消息所有碎片的公共值；而其他字段则对每个碎片不同。
- en: The IP Fragmentation Process
  id: totrans-1115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP碎片化过程
- en: The device performing the fragmentation follows a specific algorithm to divide
    the message into fragments for transmission. The exact implementation of the fragmentation
    process depends on the device. For example, consider an IP message 12,000 bytes
    wide (including the 20-byte IP header) that needs to be sent over a link with
    an MTU of 3,300 bytes. [Figure 22-3](ch22s02.html#ipv4_datagram_fragmentation_process_in_t
    "Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and
    Fragment Offset fields of each fragment are shown for reference. The Data fields
    are shown to scale (the length of each is proportional to the number of bytes
    in the fragment).") depicts a typical method by which this fragmentation might
    be performed.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行碎片化的设备遵循一个特定的算法将消息分成用于传输的碎片。碎片化过程的精确实现取决于设备。例如，考虑一个宽度为12,000字节（包括20字节IP头部）的IP消息，需要通过一个MTU为3,300字节的链路发送。[图22-3](ch22s02.html#ipv4_datagram_fragmentation_process_in_t
    "图22-3. IPv4数据报碎片化过程 在此图中，每个碎片的MF和碎片偏移字段以供参考。数据字段按比例显示（每个的长度与碎片中的字节数成正比")描述了执行这种碎片化的一种典型方法。
- en: '![IPv4 datagram fragmentation process In this diagram, the MF and Fragment
    Offset fields of each fragment are shown for reference. The Data fields are shown
    to scale (the length of each is proportional to the number of bytes in the fragment).](httpatomoreillycomsourcenostarchimages287861.png.jpg)'
  id: totrans-1117
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4数据报碎片化过程 在此图中，每个碎片的MF和碎片偏移字段以供参考。数据字段按比例显示（每个的长度与碎片中的字节数成正比)](httpatomoreillycomsourcenostarchimages287861.png.jpg)'
- en: Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and
    Fragment Offset fields of each fragment are shown for reference. The Data fields
    are shown to scale (the length of each is proportional to the number of bytes
    in the fragment).
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 图22-3. IPv4数据报碎片化过程 在此图中，每个碎片的MF和碎片偏移字段以供参考。数据字段按比例显示（每个的长度与碎片中的字节数成正比)
- en: 'The four fragments shown in [Figure 22-3](ch22s02.html#ipv4_datagram_fragmentation_process_in_t
    "Figure 22-3. IPv4 datagram fragmentation process In this diagram, the MF and
    Fragment Offset fields of each fragment are shown for reference. The Data fields
    are shown to scale (the length of each is proportional to the number of bytes
    in the fragment).") are created as follows:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图22-3](ch22s02.html#ipv4_datagram_fragmentation_process_in_t "图22-3. IPv4数据报碎片化过程
    在此图中，每个碎片的MF和碎片偏移字段以供参考。数据字段按比例显示（每个的长度与碎片中的字节数成正比")中显示的四个碎片创建如下：'
- en: The first fragment is created by taking the first 3,300 bytes of the 12,000-byte
    IP datagram. This includes the original header, which becomes the IP header of
    the first fragment (with certain fields changed, as described in the next section).
    So, 3,280 bytes of data are in the first fragment. This leaves 8,700 bytes (11,980–3,280)
    to encapsulate.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个碎片是通过取12,000字节IP数据报的前3,300字节创建的。这包括原始头部，它成为第一个碎片的IP头部（某些字段已更改，如下一节所述）。因此，第一个碎片中有3,280字节的数据。这留下了8,700字节（11,980-3,280）需要封装。
- en: The next 3,280 bytes of data are taken from the 8,700 bytes that remain after
    the first fragment is built and paired with a new header to create the second
    fragment. This leaves 5,420 bytes.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的3,280个字节的数据是从第一个分片构建后剩余的8,700字节中提取的，并与一个新的头部配对以创建第二个分片。这留下了5,420个字节。
- en: The third fragment is created from the next 3,280 bytes of data, with a 20-byte
    header. This leaves 2,140 bytes of data.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三段是从接下来的3,280个字节的数据中创建的，包含一个20字节的头部。这留下了2,140个字节的数据。
- en: The remaining 2,140 bytes are placed into the fourth fragment, with a 20-byte
    header.
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的2,140个字节被放入第四个分片，包含一个20字节的头部。
- en: There are two important points here. First, IP fragmentation does *not* work
    by fully encapsulating the original IP message into the Data fields of the fragments.
    If this were the case, the first 20 bytes of the Data field of the first fragment
    would contain the original IP header. (This technique is used by some other protocols,
    such as the PPP Multilink Protocol, discussed in [Chapter 9](ch09.html "Chapter 9. TCP/IP
    SERIAL LINE INTERNET PROTOCOL (SLIP) AND POINT-TO-POINT PROTOCOL (PPP) OVERVIEW
    AND FUNDAMENTALS").) The original IP header is transformed into the IP header
    of the first fragment.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的点。首先，IP分片并不是通过将原始IP消息完全封装到分片的数据字段中来工作的。如果是这样的话，第一个分片数据字段的头20个字节将包含原始IP头部。（这种技术被一些其他协议使用，例如第9章中讨论的PPP多链路协议。）原始IP头部被转换成第一个分片的IP头部。
- en: 'Second, note that the total number of bytes transmitted increases: we are sending
    12,060 bytes (3,300*3+2,160), instead of 12,000 bytes. The extra 60 bytes are
    from the additional headers in the second, third, and fourth fragments. (The increase
    in size could theoretically be even larger if the headers contain options.)'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，请注意，传输的字节总数增加了：我们现在发送12,060字节（3,300*3+2,160），而不是12,000字节。额外的60字节来自第二、第三和第四分片中的附加头部。（如果头部包含选项，理论上大小增加可能会更大。）
- en: Fragmentation-Related IP Datagram Header Fields
  id: totrans-1126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分片相关IP数据报头部字段
- en: 'When a sending device or router fragments a datagram, it must provide information
    that will allow the receiving device to identify the fragments and reassemble
    them into the original datagram. This information is recorded by the fragmenting
    device in a number of fields in the IP datagram header:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个发送设备或路由器对数据报进行分片时，它必须提供信息，以便接收设备能够识别分片并将它们重新组装成原始数据报。这些信息由分片设备在IP数据报头部的一些字段中记录：
- en: '**Total Length** After fragmenting, the Total Length field indicates the length
    of each fragment, not the length of the overall message. Normally, the fragment
    size is selected to match the MTU value in bytes. However, fragments must have
    a length that is a multiple of 8, to allow proper offset specification (handled
    by the Fragment Offset field). The last fragment will usually be shorter than
    the others because it will contain a leftover piece, unless the message length
    happens to be an exact multiple of the fragment size.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '**总长度** 分片后，总长度字段表示每个分片的长度，而不是整个消息的长度。通常，分片大小被选择以匹配字节的MTU值。然而，分片必须具有是8的倍数的长度，以便正确指定偏移量（由分片偏移量字段处理）。最后一个分片通常会比其他分片短，因为它将包含剩余的部分，除非消息长度恰好是分片大小的整数倍。'
- en: '**Identification** To solve the problem of pieces from many jigsaw puzzles
    in the same box, a unique identifier is assigned to each message being fragmented.
    This is like writing a different number on the bottom of each piece of a jigsaw
    puzzle before tossing it in the box. This value is placed in the Identification
    field in the IP header of each fragment sent. The Identification field is 16 bits
    wide, so a total of 65,536 different identifiers can be used. Obviously, we want
    to make sure that each message that is being fragmented for delivery has a different
    identifier. The source can decide how it generates unique identifiers. This may
    be done through something as simple as a counter that is incremented each time
    a new set of fragments is created.'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '**标识** 为了解决同一盒子里多个拼图碎片的问题，为每个正在分片的消息分配一个唯一的标识符。这就像在将拼图碎片扔进盒子之前，在每个拼图碎片底部写上不同的数字。这个值放在每个发送的分片IP头部的标识字段中。标识字段是16位宽，因此总共可以使用65,536个不同的标识符。显然，我们想确保每个正在分片以供传输的消息都有一个不同的标识符。源可以决定如何生成唯一的标识符。这可能通过某种简单的方法实现，比如每次创建一个新的分片集时，计数器就会增加。'
- en: '**More Fragments** The More Fragments flag is set to a 1 for all fragments
    except the last one, which has it set to 0\. When the fragment with a value of
    0 in the More Fragments flag is seen, the destination knows it has received the
    last fragment of the message.'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多分片** 更多分片标志对所有分片都设置为 1，除了最后一个分片，它的设置为 0。当看到更多分片标志值为 0 的分片时，目标设备就知道它已经收到了消息的最后一个分片。'
- en: '**Fragment Offset** The Fragment Offset field solves the problem of sequencing
    fragments by indicating to the recipient device where in the overall message each
    particular fragment should be placed. The field is 13 bits wide, so the offset
    can be from 0 to 8,191\. Fragments are specified in units of 8 bytes, which is
    why fragment length must be a multiple of 8\. Uncoincidentally, 8,191*8 is 65,528,
    just about the maximum size allowed for an IP datagram. In the example shown in
    [Figure 22-3](ch22s02.html#ipv4_datagram_fragmentation_process_in_t "Figure 22-3. IPv4
    datagram fragmentation process In this diagram, the MF and Fragment Offset fields
    of each fragment are shown for reference. The Data fields are shown to scale (the
    length of each is proportional to the number of bytes in the fragment)."), the
    first fragment would have a Fragment Offset of 0, the second would have an offset
    of 410 (3,280/8), the third would have an offset of 820 (6,560/8), and the fourth
    would have an offset of 1,230.'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片偏移** 分片偏移字段通过指示接收设备在每个整体消息中每个特定分片应该放置的位置来解决分片排序的问题。该字段宽度为 13 位，因此偏移量可以从
    0 到 8,191。分片以 8 字节为单位指定，这就是为什么分片长度必须是 8 的倍数。巧合的是，8,191 乘以 8 等于 65,528，这几乎是 IP
    数据报允许的最大大小。在图 22-3 中所示示例中，第一个分片的分片偏移为 0，第二个分片的偏移为 410（3,280/8），第三个分片的偏移为 820（6,560/8），第四个分片的偏移为
    1,230。'
- en: An IP datagram has a couple of other fields related to fragmentation. First,
    if a datagram containing options must be fragmented, some of the options may be
    copied to each of the fragments. This is controlled by the Copied flag in each
    option field.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IP 数据报还有一些与分片相关的其他字段。首先，如果一个包含选项的数据报必须进行分片，那么一些选项可能会被复制到每个分片中。这是通过每个选项字段中的复制标志来控制的。
- en: Second, in the IP header, there is a flag called Don't Fragment. This field
    can be set to 1 by a transmitting device to specify that a datagram should not
    be fragmented in transit. This may be used in certain circumstances where the
    entire message must be delivered intact for some reason. It may also be used if
    the destination device has a limited IP implementation and cannot reassemble fragments,
    and it is also used for testing the MTU of a link. Normally, however, devices
    don't care about fragmentation, and this field is left at 0.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在 IP 头部中，有一个称为“不要分片”的标志。这个字段可以被发送设备设置为 1，以指定数据报在传输过程中不应该被分片。这可能在某些情况下使用，例如，由于某种原因整个消息必须完整地交付。如果目标设备具有有限的
    IP 实现，无法重新组装分片，也可以使用它，并且它也用于测试链路的 MTU。然而，通常设备不会关心分片，这个字段保留为 0。
- en: 'If a router encounters a datagram too large to pass over the next physical
    network but with the Don''t Fragment bit set to 1, it cannot fragment the datagram
    and it cannot pass it along either, so it is stuck. It will generally drop the
    datagram and return an ICMP Destination Unreachable error message: "Fragmentation
    Needed and Don''t Fragment Bit Set." This is used in MTU path discovery, as described
    earlier in this chapter.'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个路由器遇到一个太大而无法通过下一个物理网络传输的数据报，但“不要分片”位设置为 1，它不能分片数据报，也不能将其传递下去，因此它就卡住了。它通常会丢弃数据报，并返回一个
    ICMP 目标不可达错误消息：“需要分片，但设置了不要分片位。”这用于 MTU 路径发现，如本章前面所述。
- en: Tip
  id: totrans-1135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** When an MTU requirement forces a datagram to be fragmented,
    it is split into several smaller IP datagrams, each containing part of the original.
    The header of the original datagram is changed into the header of the first fragment,
    and new headers are created for the other fragments. Each is set to the same Identification
    value to mark them as part of the same original datagram. The Fragment Offset
    of each is set to the location where the fragment belongs in the original. The
    More Fragments field is set to 1 for all fragments but the last, to let the recipient
    know when it has received all the fragments.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当MTU（最大传输单元）要求迫使数据报被分片时，它会被分割成几个较小的IP数据报，每个数据报都包含原始数据报的一部分。原始数据报的头部被改变为第一个分片的头部，并为其他分片创建新的头部。每个分片的标识值被设置为相同的值，以标记它们是同一原始数据报的一部分。每个分片的分片偏移量被设置为分片在原始数据报中的位置。除了最后一个分片外，所有分片的更多分片字段都被设置为1，以便让接收方知道何时已收到所有分片。'
- en: IP Message Reassembly
  id: totrans-1137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP消息重组
- en: When a datagram is fragmented, it becomes multiple fragment datagrams. The destination
    of the overall message must collect these fragments and reassemble them into the
    original message.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据报被分片时，它变成了多个分片数据报。整体消息的目的地必须收集这些分片并将它们重新组装成原始消息。
- en: While reassembly is the complement to fragmentation, the two processes are not
    symmetric. A primary differentiation between the two is that intermediate routers
    can fragment a single datagram or further fragment a datagram that is already
    a fragment, but intermediate devices do not perform reassembly; reassembly happens
    only at the message's ultimate destination. Thus, if a datagram at an intermediate
    router on one side of a physical network with an MTU of 1,300 bytes causes fragmentation
    of a 3,300-byte datagram, the router on the other end of this 1,300 MTU link will
    *not* restore the 3,300-byte datagram to its original state. It will send all
    the 1,300-byte fragments on down the internetwork, as shown in [Figure 22-2](ch22.html#ipv4_datagram_fragmentation_this_example
    "Figure 22-2. IPv4 datagram fragmentation. This example illustrates a two-step
    fragmentation of a large IP datagram. The boxes represent datagrams or datagram
    fragments and are shown to scale. The original datagram is 12,000 bytes, represented
    by the large, gray box. To transmit this data over the first local link, Device
    A splits it into four fragments, shown on the left. The first router must fragment
    each of these into smaller fragments to send them over the 1,300-byte MTU link,
    as shown on the bottom. Note that the second router does not reassemble the 1,300-byte
    fragments, even though its link to Device B has an MTU of 3,300 bytes. (The "IP
    Fragmentation Process" section later in this chapter describes the process by
    which the fragments in this example are created.)"), earlier in the chapter.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重组是分片的补充，但这两个过程并不对称。两者之间的主要区别在于，中间路由器可以分片单个数据报或进一步分片已经分片的数据报，但中间设备不执行重组；重组仅在消息的最终目的地发生。因此，如果一个在具有1,300字节MTU的物理网络一侧的中间路由器上的数据报导致3,300字节数据报的分片，那么该1,300
    MTU链路另一端的路由器*不会*将3,300字节的数据报恢复到其原始状态。它将发送所有1,300字节的分片，如[图22-2](ch22.html#ipv4_datagram_fragmentation_this_example
    "图22-2. IPv4数据报分片。本例说明了将大IP数据报分片为两步的过程。方框代表数据报或数据报分片，并按比例显示。原始数据报为12,000字节，由大灰框表示。为了通过第一个本地链路传输这些数据，设备A将其分割成四个分片，如左侧所示。第一个路由器必须将这些分片进一步分割成更小的分片，以便通过1,300字节的MTU链路发送，如底部所示。请注意，第二个路由器不会重组1,300字节的分片，即使它的链路到设备B的MTU为3,300字节。（本章后面的“IP分片过程”部分描述了创建本例中分片的过程。”）]中所示，在章节的早期部分。
- en: In IP version 4 (IPv4), fragmentation can be performed by a router between the
    source and destination of an IP datagram, but reassembly is done only by the destination
    device.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP版本4（IPv4）中，路由器可以在IP数据报的源和目的地之间执行分片，但重组仅由目的地设备执行。
- en: There are a number of reasons why the decision was made to implement IP reassembly
    this way. Perhaps the most important reason is that fragments can take different
    routes to get from the source to destination, so any given router may not see
    all the fragments in a message. Another reason is that if routers needed to worry
    about reassembling fragments, their complexity would increase. Finally, reassembly
    of a message requires that we wait for all fragments before sending on the reassembled
    message. Having routers do this would slow down routing. Since routers don't reassemble
    messages, they can immediately forward all fragments on to the ultimate recipient.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 决定以这种方式实现IP重新组装的原因有很多。也许最重要的原因是片段可以走不同的路线从源到达目的地，因此任何给定的路由器可能看不到消息中的所有片段。另一个原因是，如果路由器需要担心重组片段，它们的复杂性会增加。最后，重新组装一个消息需要我们等待所有片段到达后再发送重组后的消息。让路由器这样做会减慢路由速度。由于路由器不重组消息，它们可以立即将所有片段转发给最终接收者。
- en: However, there are drawbacks to this design as well. One is that it results
    in more, smaller fragments traveling over longer routes than if intermediate reassembly
    occurred. This increases the chances of a fragment getting lost and the entire
    message being discarded. Another is a potential inefficiency in the utilization
    of data link layer frame capacity. In the example of a 3,300-byte datagram being
    fragmented for a 1,300-byte MTU link, the 1,300-byte fragments would not be reassembled
    back into a 3,300-byte datagram at the end of the 1,300-MTU link. If the next
    link after that one also had an MTU of 3,300 bytes, we would need to send three
    frames, each encapsulating a 1,300-byte fragment, instead of a single larger frame,
    which is slightly slower.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计也存在一些缺点。一是它会导致比中间重组时更多的、更小的片段在更长的路线上传输。这增加了片段丢失和整个消息被丢弃的可能性。另一个缺点是数据链路层帧容量的潜在低效。例如，对于一个3,300字节的报文被分割成适用于1,300字节MTU链路的片段，这些1,300字节的片段在1,300-MTU链路的末端不会被重新组装成一个3,300字节的报文。如果下一个链路也有3,300字节的MTU，我们就需要发送三个帧，每个帧封装一个1,300字节的片段，而不是一个更大的单一帧，这会稍微慢一些。
- en: As described in the previous section, several IP header fields are filled in
    when a message is fragmented to give the receiving device the information it requires
    to properly reassemble the fragments. The receiving device follows a procedure
    to keep track of the fragments as they are received and build up its copy of the
    total received message from the source device. Most of its efforts are geared
    toward dealing with the potential difficulties associated with IP being an unreliable
    protocol.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当消息被分割时，会填充几个IP头部字段，以便为接收设备提供所需的信息，以便正确地重新组装片段。接收设备遵循一个程序来跟踪接收到的片段，并从源设备构建其接收到的总消息副本。它的大部分努力都是为了应对与IP作为不可靠协议相关的潜在困难。
- en: 'The details of implementation of the reassembly process are specific to each
    device, but reassembly generally includes the following functions:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 重新组装过程的实现细节因设备而异，但重新组装通常包括以下功能：
- en: '**Fragment Recognition and Fragmented Message Identification** The recipient
    knows it has received a message fragment the first time it sees a datagram with
    the More Fragments bit set to 1 or the Fragment Offset a value other than 0\.
    It identifies the message based on the source and destination IP addresses, the
    protocol specified in the header, and the Identification field generated by the
    sender.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '**片段识别和分割消息标识** 当接收方第一次看到设置更多片段位为1或片段偏移量不为0的报文时，它知道它接收到了一个消息片段。它根据源和目的IP地址、头部中指定的协议以及发送方生成的标识字段来识别消息。'
- en: '**Buffer Initialization** The receiving device initializes a buffer where it
    can store the fragments of the message as they are received. It keeps track of
    which portions of this buffer have been filled with received fragments, perhaps
    using a special table. By doing this, it knows when the buffer is partially filled
    with received fragments and when it is completely full.'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲区初始化** 接收设备初始化一个缓冲区，用于存储接收到的消息片段。它通过可能使用特殊表的方式来跟踪缓冲区中哪些部分已被接收到的片段填充。通过这种方式，它知道何时缓冲区部分填充了接收到的片段，何时完全填满。'
- en: '**Timer Initialization** The receiving device sets up a timer for reassembly
    of the message. Since it is possible that some fragments may never show up, this
    timer ensures that the device will not wait an infinite time trying to reassemble
    the message.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器初始化** 接收设备为消息的重组设置一个定时器。由于可能有些分片永远不会出现，这个定时器确保设备不会无限期地等待尝试重组消息。'
- en: '**Fragment Receipt and Processing** Whenever a fragment of this message arrives
    (as indicated by it having the same source and destination addresses, protocol,
    and Identification as the first fragment), the fragment is processed. It is inserted
    into the message buffer in the location indicated by its Fragment Offset field.
    The device also makes note of the fact that this portion of the message has been
    received.'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片接收和处理** 当这个消息的某个分片到达时（如通过它具有与第一个分片相同的源地址、目的地址、协议和标识符来指示），该分片将被处理。它将被插入到消息缓冲区中，位置由其分片偏移字段指示。设备还会记录这一部分消息已被接收的事实。'
- en: Reassembly is complete when the entire buffer has been filled and the fragment
    with the More Fragments bit set to 0 is received, indicating that it is the last
    fragment of the datagram. The reassembled datagram is then processed in the same
    way as a normal, unfragmented datagram. On the other hand, if the timer for the
    reassembly expires with any of the fragments missing, the message cannot be reconstructed.
    The fragments are discarded, and an ICMP Time Exceeded message is generated. Since
    IP is unreliable, it relies on higher-layer protocols such as the Transmission
    Control Protocol (TCP) to determine that the message was not properly received
    and then retransmit it.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 当整个缓冲区被填满并且收到设置了更多分片位的分片（表示它是数据报的最后一个分片）时，重组完成。重组后的数据报随后以与正常、未分片的数据报相同的方式进行处理。另一方面，如果重组定时器超时且任何分片丢失，则消息无法重建。这些分片将被丢弃，并生成一个ICMP超时消息。由于IP是不可靠的，它依赖于更高层的协议，如传输控制协议（TCP），以确定消息是否被正确接收，然后重新传输它。
- en: Chapter 23. IP ROUTING AND MULTICASTING
  id: totrans-1150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章。IP路由和多播
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-1151
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The essential functions of Internet Protocol (IP) datagram encapsulation and
    addressing are sometimes compared to putting a letter in an envelope and then
    writing the address of the recipient on it. Once our IP datagram "envelope" is
    filled and labeled, it is ready to go, but it's still sitting on our desk. The
    last of the main functions of IP is to get the envelope to our intended recipient.
    This is the process of datagram *delivery*. When the recipient is not on our local
    network, this delivery requires that the datagram be *routed* from our network
    to the one where the destination resides.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）数据报封装和寻址的基本功能有时可以比作将一封信放入信封，然后在上面写上收件人的地址。一旦我们的IP数据报“信封”被填写并贴上标签，它就准备出发了，但它仍然放在我们的桌子上。IP的最后一个主要功能是将信封送到预期的收件人那里。这是数据报的*投递*过程。当收件人不在我们本地网络时，这种投递需要将数据报从我们的网络路由到目的地所在的网络。
- en: This chapter concludes our look at IP version 4 (IPv4) with a discussion of
    some of the particulars of how it routes datagrams over an internetwork. I begin
    with an overview of the process and contrast direct and indirect delivery of data
    between devices. I discuss the main method used to route datagrams over the internetwork,
    and I explain briefly how IP routing tables are built and maintained. I describe
    how the move from classful to classless addressing using Classless Inter-Domain
    Routing (CIDR) has impacted routing.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过讨论IPv4（互联网协议版本4）在互联网上路由数据报的一些具体细节来结束我们对IPv4的探讨。我首先概述了这个过程，并对比了设备之间直接和间接的数据传输。我讨论了在互联网上路由数据报的主要方法，并简要解释了IP路由表是如何构建和维护的。我还描述了从类别到无类别寻址的迁移，即使用无类别域间路由（CIDR）对路由的影响。
- en: I conclude with a brief look at the issues related to IP multicasting. Multicasting
    isn't really a part of routing, but many of the issues in multicasting are related
    to datagram delivery and routing.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 我最后简要地看了看与IP多播相关的问题。多播实际上并不是路由的一部分，但多播中的许多问题都与数据报的投递和路由有关。
- en: Tip
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RELATED INFORMATION** *This chapter focuses on routing issues that are directly
    related to how IP works. Routing is a complex and important topic in networking,
    and you''ll find much more information about it in Chapters [Chapter 37](ch37.html
    "Chapter 37. OVERVIEW OF KEY ROUTING PROTOCOL CONCEPTS") through [Chapter 41](ch41.html
    "Chapter 41. OTHER ROUTING PROTOCOLS")*.'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**相关信息** *本章重点介绍与IP工作方式直接相关的路由问题。路由是网络中的一个复杂且重要的话题，你可以在第[第37章](ch37.html "第37章.
    关键路由协议概念概述")到[第41章](ch41.html "第41章. 其他路由协议")中找到更多关于它的信息*。'
- en: IP Datagram Delivery
  id: totrans-1157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP数据报交付
- en: 'The overall job of IP is to transmit messages from higher-layer protocols over
    an internetwork of devices. These messages must be packaged and addressed, and
    fragmented if necessary, and then they must be *delivered*. The process of delivery
    can be either simple or complex, depending on the proximity of the source and
    destination devices. We can divide all IP datagram deliveries into two general
    types: direct delivery and indirect delivery. [Figure 23-1](ch23.html#direct_and_indirect_routed_delivery_of_i
    "Figure 23-1. Direct and indirect (routed) delivery of IP datagrams This diagram
    shows three examples of IP datagram delivery. The first transmission (#1, dark
    arrow) shows a direct delivery between two devices on the local network. The second
    (#2, light arrow) shows indirect delivery within the local network, between a
    client and server separated by a router. The third (#3, medium arrow) shows a
    more distant indirect delivery, between a client on the local network and a server
    across the Internet.") shows some examples of IP datagram delivery types.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: IP的整体任务是将在更高层协议中传输的消息通过设备互联网传输。这些消息必须被封装和标记地址，如果需要，还要进行分片，然后它们必须被*交付*。交付过程可以是简单的也可以是复杂的，这取决于源设备和目标设备之间的距离。我们可以将所有IP数据报交付分为两种一般类型：直接交付和间接交付。[图23-1](ch23.html#direct_and_indirect_routed_delivery_of_i
    "图23-1. IP数据报的直接和间接（路由）交付 此图展示了IP数据报交付的三个示例。第一个传输（#1，深色箭头）显示了本地网络中两个设备之间的直接交付。第二个（#2，浅色箭头）显示了本地网络内的间接交付，客户端和服务器之间由路由器隔开。第三个（#3，中等箭头）显示了更远的间接交付，本地网络中的客户端和互联网上的服务器之间。")展示了IP数据报交付类型的示例。
- en: '![Direct and indirect (routed) delivery of IP datagrams This diagram shows
    three examples of IP datagram delivery. The first transmission (#1, dark arrow)
    shows a direct delivery between two devices on the local network. The second (#2,
    light arrow) shows indirect delivery within the local network, between a client
    and server separated by a router. The third (#3, medium arrow) shows a more distant
    indirect delivery, between a client on the local network and a server across the
    Internet.](httpatomoreillycomsourcenostarchimages287863.png.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据报的直接和间接（路由）交付 此图展示了IP数据报交付的三个示例。第一个传输（#1，深色箭头）显示了本地网络中两个设备之间的直接交付。第二个（#2，浅色箭头）显示了本地网络内的间接交付，客户端和服务器之间由路由器隔开。第三个（#3，中等箭头）显示了更远的间接交付，本地网络中的客户端和互联网上的服务器之间。](httpatomoreillycomsourcenostarchimages287863.png.jpg)'
- en: Figure 23-1. Direct and indirect (routed) delivery of IP datagrams This diagram
    shows three examples of IP datagram delivery. The first transmission (#1, dark
    arrow) shows a direct delivery between two devices on the local network. The second
    (#2, light arrow) shows indirect delivery within the local network, between a
    client and server separated by a router. The third (#3, medium arrow) shows a
    more distant indirect delivery, between a client on the local network and a server
    across the Internet.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 图23-1. IP数据报的直接和间接（路由）交付 此图展示了IP数据报交付的三个示例。第一个传输（#1，深色箭头）显示了本地网络中两个设备之间的直接交付。第二个（#2，浅色箭头）显示了本地网络内的间接交付，客户端和服务器之间由路由器隔开。第三个（#3，中等箭头）显示了更远的间接交付，本地网络中的客户端和互联网上的服务器之间。
- en: Direct Datagram Delivery
  id: totrans-1161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接数据报交付
- en: When datagrams are sent between two devices on the same physical network, the
    datagrams may be delivered directly from the source to the destination. For example,
    if you wanted to deliver a letter to a neighbor on your street, you would probably
    just put her name on the envelope and stick it right in her mailbox.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据报在相同物理网络上的两个设备之间发送时，数据报可以直接从源发送到目标。例如，如果你想给你的街上的邻居送信，你可能会直接在信封上写上她的名字，然后直接放入她的邮箱。
- en: Direct delivery is obviously a simple delivery method. The source simply sends
    the IP datagram down to its data link layer implementation. The data link layer
    encapsulates the datagram in a frame that is sent over the physical network directly
    to the recipient's data link layer, which passes it up to the IP layer.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 直接投递显然是一种简单的投递方法。源端只需将 IP 数据报发送到其数据链路层实现。数据链路层将数据报封装在帧中，并通过物理网络直接发送到接收者的数据链路层，该层再将数据报向上传递到
    IP 层。
- en: Indirect Datagram Delivery (Routing)
  id: totrans-1164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 间接数据报投递（路由）
- en: When two devices are not on the same physical network, the delivery of datagrams
    from one to the other is *indirect*. Since the source device cannot see the destination
    on its local network, it must send the datagram through one or more intermediate
    devices to deliver it. Indirect delivery is like mailing a letter to a friend
    in a different city. You don't deliver it yourself; you use the postal system.
    The letter journeys through the postal system, possibly taking several intermediate
    steps, and ends up in your friend's neighborhood, where a postal carrier puts
    it into his mailbox.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个设备不在同一物理网络中时，从一个设备到另一个设备的数据报投递是 *间接的*。由于源设备在其本地网络中看不到目的地，它必须通过一个或多个中间设备发送数据报以进行投递。间接投递就像给不同城市的友人寄信一样。你不会亲自投递；你使用邮政系统。信件通过邮政系统旅行，可能经过几个中间步骤，最终到达你的友人的街区，那里的邮递员将其放入他的邮箱。
- en: Indirect delivery is much more complicated, because we can't send the data straight
    to the recipient. In fact, we usually will not even know exactly where the recipient
    is. Sure, we have its address, but we may not know what network it is on, or where
    that network is relative to our own. (If I told you my address, you would know
    it's somewhere in Bennington, Vermont, but could you find it?) Just as we must
    rely on the postal system in the envelope analogy, we must rely on the internetwork
    itself to indirectly deliver datagrams. And like the postal system, IP doesn't
    require you to know how to get the message to its recipient; you just put it into
    the system.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 间接投递要复杂得多，因为我们不能直接将数据发送给接收者。实际上，我们通常甚至不知道接收者的确切位置。当然，我们有它的地址，但我们可能不知道它所在的网络，或者该网络相对于我们自己的网络的位置。（如果我告诉你我的地址，你就会知道它在佛蒙特州的贝宁顿，但你能找到它吗？）就像我们必须在信封类比中依赖邮政系统一样，我们必须依赖互联网本身来间接投递数据报。而且就像邮政系统一样，IP
    不要求你知道如何将消息送到接收者；你只需将其放入系统。
- en: The devices that accomplish this magic of indirect delivery are generally known
    as *routers*, and indirect delivery is more commonly called *routing*. Like entrusting
    a letter to your local mail carrier or mailbox, a host that needs to deliver a
    message to a distant device generally sends datagrams to its local router. The
    router connects to one or more other routers, and they each maintain information
    about where to send datagrams so that they reach their final destination.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种间接投递魔法的设备通常被称为 *路由器*，而间接投递更常见地被称为 *路由*。就像将一封信托付给当地的邮递员或邮箱一样，需要将消息发送到远程设备的宿主机通常会将数据报发送到其本地路由器。路由器连接到一个或多个其他路由器，并且它们各自维护有关如何发送数据报以到达最终目的地的信息。
- en: Indirect delivery is almost always required when communicating with distant
    devices, such as those on the Internet or across a wide area network (WAN) link.
    However, it may also be needed even to send a message to a device in the next
    room of your office, if that device is not connected directly to your device at
    layer 2.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程设备（如互联网或广域网（WAN）链接上的设备）通信时，几乎总是需要间接投递。然而，即使要发送的消息是给办公室隔壁的设备，如果该设备在第二层没有直接连接到你的设备，也可能需要间接投递。
- en: Note
  id: totrans-1169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In the past, routers were often called gateways. Today, this term more generally
    can refer to devices that connect networks in a variety of ways. You will still
    sometimes hear routers called gateways, especially in the context of terms like
    default gateway, but since it is ambiguous, the term router is preferred*.'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: '*在过去，路由器通常被称为网关。今天，这个术语更普遍地可以指代以各种方式连接网络的设备。你有时仍会听到路由器被称为网关，尤其是在默认网关等术语的上下文中，但由于其含糊不清，更倾向于使用路由器这个术语*。'
- en: The Relationship Between Datagram Routing and Addressing
  id: totrans-1171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据报路由与寻址之间的关系
- en: 'Each time a datagram is to be sent, the sender must determine first whether
    it can be delivered directly or if routing is required. IP addressing is what
    allows a device to quickly determine whether or not it is on the same network
    as its intended recipient. The following are the three main categories of addressing
    (see [Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES")):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 每次发送数据报时，发送者必须首先确定是否可以直接交付，或者是否需要路由。IP编址允许设备快速确定它是否与其预期接收者位于同一网络。以下是有三种主要编址类别（请参阅[第16章](ch16.html
    "第16章。IPv4编址概念和问题"))：
- en: '**Conventional Classful Addressing** We know the class of each address by looking
    at the first few bits. This tells us which bits of an address are the network
    ID. If the network ID of the destination is the same as our own, the recipient
    is on the same network; otherwise, it is not. Refer to [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING") for more on classful addressing.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统按类编址** 通过查看地址的前几位，我们可以知道每个地址的类别。这告诉我们地址中哪些位是网络ID。如果目标地址的网络ID与我们的相同，则接收者位于同一网络；否则，它不在。有关按类编址的更多信息，请参阅[第17章](ch17.html
    "第17章。按类（传统）编址")。'
- en: '**Subnetted Classful Addressing** We use our subnet mask to determine our network
    ID and subnet ID and that of the destination address. If the network ID and subnet
    are the same, the recipient is on the same subnet. If only the network ID is the
    same, the recipient is on a different subnet of the same network. If the network
    ID is different, the destination is on a different network entirely. See [Chapter 18](ch18.html
    "Chapter 18. IP SUBNET ADDRESSING (SUBNETTING) CONCEPTS") for a full discussion
    of subnetting.'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网划分的按类编址** 我们使用子网掩码来确定我们的网络ID和子网ID以及目标地址的网络ID和子网ID。如果网络ID和子网相同，则接收者位于同一子网。如果只有网络ID相同，则接收者位于同一网络的不同子网。如果网络ID不同，则目标位于完全不同的网络。请参阅[第18章](ch18.html
    "第18章。IP子网编址（子网划分）概念")以了解子网划分的全面讨论。'
- en: '**Classless Addressing** The same basic technique is used as for subnetted
    classful addressing, except that there are no subnets. We use the slash number
    to determine what part of the address is the network ID and compare the source
    and destination as before; see [Chapter 20](ch20.html "Chapter 20. IP CLASSLESS
    ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING"). (There are complications
    here, however, as discussed in the "IP Routing in a Subnet or Classless Addressing
    (CIDR) Environment" section later in this chapter.)'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**无类编址** 与子网划分的按类编址使用相同的基本技术，只是没有子网。我们使用斜杠数字来确定地址的哪一部分是网络ID，并像以前一样比较源地址和目标地址；请参阅[第20章](ch20.html
    "第20章。IP无类编址—无类域间路由（CIDR）/超网")。（然而，这里有一些复杂性，将在本章后面的“子网或无类编址（CIDR）环境中的IP路由”部分讨论。）'
- en: Tip
  id: totrans-1176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The delivery of IP datagrams is divided into two categories:
    *direct* and *indirect*. Direct delivery is possible when two devices are on the
    same physical network. When they are not, indirect delivery, more commonly called
    *routing*, is required to get the datagrams from the source to the destination.
    A device can tell which type of delivery is required by looking at the IP address
    of the destination, in conjunction with supplemental information such as the subnet
    mask, which tells the device what network or subnet it is on.'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP数据报的交付分为两类：*直接*和*间接*。当两个设备位于同一物理网络时，可以进行直接交付。当它们不在同一网络时，需要间接交付，通常称为*路由*，才能将数据报从源传输到目标。设备可以通过查看目标IP地址以及补充信息（如子网掩码）来确定需要哪种类型的交付，这些补充信息告诉设备它位于哪个网络或子网。'
- en: The determination of what type of delivery is required is the first step in
    the source deciding where to send a datagram. If it realizes the destination is
    on the same local network, it will address the datagram to the recipient directly
    at the data link layer. Otherwise, it will send the datagram to the data link
    layer address of one of the routers to which it is connected. The IP address of
    the datagram will still be that of the ultimate destination. Mapping between IP
    addresses and data link layer addresses is accomplished using the TCP/IP Address
    Resolution Protocol (ARP), which is discussed in [Chapter 13](ch13.html "Chapter 13. ADDRESS
    RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)").
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 确定需要哪种类型的交付是源决定将数据报发送到何处的第一步。如果它意识到目的地在同一本地网络，它将在数据链路层直接将数据报地址发送给接收者。否则，它将数据报发送到它连接的一个路由器的数据链路层地址。数据报的IP地址仍然是最终目的地的地址。IP地址与数据链路层地址之间的映射是通过使用TCP/IP地址解析协议（ARP）完成的，该协议在第13章中讨论（ch13.html
    "第13章。地址解析和TCP/IP地址解析协议（ARP）"）。
- en: Routing is done in indirect delivery to get the datagram to the local network
    of the recipient. Once the datagram has been routed to the recipient's physical
    network, it is sent to the recipient by the recipient's local router. So, you
    could say that indirect delivery includes direct delivery as its final step.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是通过间接交付来完成的，以便将数据报发送到接收者的本地网络。一旦数据报被路由到接收者的物理网络，它就会通过接收者的本地路由器发送给接收者。因此，可以说间接交付包括直接交付作为其最终步骤。
- en: Note
  id: totrans-1180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Strictly speaking, any process of delivery between a source and destination
    device can be considered routing, even if the devices are on the same network.
    It is common, however, for the process of routing to refer more specifically to
    indirect delivery*.'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '*严格来说，任何在源设备和目的地设备之间的交付过程都可以被认为是路由，即使这些设备在同一网络中。然而，通常将路由过程更具体地指代为间接交付*。'
- en: IP Routing Concepts and the Process of Next-Hop Routing
  id: totrans-1182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP路由概念和下一跳路由过程
- en: IP's ability to route information is what allows us to use it to create the
    equivalent of a virtual internetwork that spans potentially thousands of physical
    networks, allowing devices even on opposite ends of the globe communicate. Let's
    take a brief look at key IP routing concepts.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: IP路由信息的能力使我们能够使用它来创建一个跨越可能成千上万个物理网络的虚拟互联网，即使设备位于地球两端也能进行通信。让我们简要地看一下关键的IP路由概念。
- en: To continue with our postal system analogy, I can send a letter from my home
    in the United States to someone in, say, India, and the postal systems of both
    countries will work (or should work) to deliver the letter to its destination.
    However, when I drop a letter in the mailbox, it's not like someone shows up,
    grabs the letter, and hand-delivers it to the right address in India. The letter
    travels from the mailbox to my local post office. From there, it probably goes
    to a regional distribution center, and then from there, to a hub for international
    traffic. It goes to India, perhaps via an intermediate country. When it gets to
    India, the Indian postal system uses its own network of offices and facilities
    to route the letter to its destination. The envelope hops from one location to
    the next, until it reaches its destination.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们的邮政系统类比，我可以从我在美国的家中给印度某地的人寄一封信，两个国家的邮政系统都会工作（或者应该工作）以将信件送到目的地。然而，当我把信件投入邮箱时，并不是有人出现，拿起信件，然后亲手将其送到印度的正确地址。信件从邮箱运送到我的本地邮局。从那里，它可能被送到一个区域配送中心，然后从那里送到国际邮件枢纽。它可能通过一个中间国家运往印度。当它到达印度时，印度邮政系统使用其自己的办公室和设施网络将信件路由到目的地。信封从一个地点跳到另一个地点，直到到达目的地。
- en: IP routing works in very much the same manner. Even though IP lets devices connect
    over the internetwork using indirect delivery, all of the actual communication
    of datagrams occurs over physical networks using routers. We don't know exactly
    where the destination device's network is, and we certainly don't have any way
    to connect directly to each of the thousands of networks out there. Instead, we
    rely on these intermediate devices—routers—that are each physically connected
    to each other in a variety of ways to form a mesh containing millions of paths
    between networks. The datagram is handed off from one router to the next, until
    it gets to the physical network of the destination device. This process is called
    *next-hop routing*, as illustrated in [Figure 23-2](ch23s02.html#ip_datagram_next-hop_routing_this_is_the
    "Figure 23-2. IP datagram next-hop routing This is the same diagram as that shown
    in Figure 23-1, except it explicitly shows the hops taken by each of the three
    sample transmissions. The direct delivery of the first transmission has only one
    hop (remember that the switch doesn't count because it is invisible at layer 3).
    The local indirect delivery passes through one router, so it has two hops. The
    Internet delivery has six hops. (Actual Internet routes can be much longer.)").
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: IP路由以非常相似的方式工作。尽管IP允许设备通过间接交付连接到互联网，但所有数据报的实际通信都是通过物理网络使用路由器进行的。我们不知道目标设备网络的确切位置，当然也没有任何方法直接连接到那里成千上万的网络。相反，我们依赖于这些中间设备——路由器，它们以各种方式相互物理连接，形成一个包含数百万网络之间路径的网状结构。数据报从一个路由器传递到下一个，直到到达目标设备物理网络。这个过程称为*下一跳路由*，如图[图23-2](ch23s02.html#ip_datagram_next-hop_routing_this_is_the
    "图23-2. IP数据报下一跳路由 这个图与图23-1所示相同，但它明确显示了三个样本传输的跳转。第一次传输的直接交付只有一步（记住交换机不计入，因为它在第三层是不可见的）。本地间接交付通过一个路由器，因此有两步。互联网交付有六步。（实际的互联网路由可以更长。）")所示。
- en: 'This is a critical concept in how IP works: routing is done step by step, one
    hop at a time. When we decide to send a datagram to a device on a distant network,
    we don''t know the exact path that the datagram will take; we have only enough
    information to send it to the correct router to which we are attached. That router,
    in turn, looks at the IP address of the destination and decides where the datagram
    should hop to next. This process continues until the datagram reaches the destination
    host''s network.'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是IP工作方式中的一个关键概念：路由是逐步进行的，一次跳一步。当我们决定向远程网络上的设备发送数据报时，我们不知道数据报将采取的确切路径；我们只有足够的信息将其发送到我们连接的正确路由器。然后，该路由器查看目标IP地址并决定数据报应该跳转到下一个位置。这个过程会一直持续到数据报到达目标主机的网络。
- en: At first, next-hop routing may seem like a strange way of sending datagrams
    over an internetwork. In fact, it is part of what makes IP so powerful. On each
    step of the journey to any other host, a router needs to know only where the next
    step for the datagram is. Without this concept, each device and router would need
    to know what path to take to every other host on the internetwork, which would
    be quite impractical.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，下一跳路由可能看起来像是一种在互联网中发送数据报的奇怪方式。实际上，它是使IP如此强大的部分原因之一。在前往任何其他主机的每一步中，路由器只需要知道数据报的下一步在哪里。如果没有这个概念，每个设备和路由器都需要知道如何到达互联网上每个其他主机的路径，这将非常不切实际。
- en: Tip
  id: totrans-1188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Indirect delivery of IP datagrams is accomplished using a process
    called *next-hop routing*, where each message is handed from one router to the
    next until it reaches the network of the destination. The main advantage of this
    is that each router needs to know only which neighboring router should be the
    next recipient of a given datagram, rather than needing to know the exact route
    to every destination network.'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 使用称为*下一跳路由*的过程来实现IP数据报的间接交付，其中每个消息从一个路由器传递到下一个，直到到达目标网络的网络。这种方式的主要优势是每个路由器只需要知道哪个相邻路由器应该是给定数据报的下一个接收者，而不是需要知道到达每个目标网络的精确路由。'
- en: '![IP datagram next-hop routing This is the same diagram as that shown in ,
    except it explicitly shows the hops taken by each of the three sample transmissions.
    The direct delivery of the first transmission has only one hop (remember that
    the switch doesn''t count because it is invisible at layer 3). The local indirect
    delivery passes through one router, so it has two hops. The Internet delivery
    has six hops. (Actual Internet routes can be much longer.)](httpatomoreillycomsourcenostarchimages287865.png.jpg)'
  id: totrans-1190
  prefs: []
  type: TYPE_IMG
  zh: '![IP数据报下一跳路由 此图与图所示相同，但它明确显示了三个样本传输的跳转。第一次传输的直接交付只有一个跳转（记住交换机不计入，因为在第3层它是不可见的）。本地间接交付通过一个路由器，因此有两个跳转。互联网交付有六个跳转。（实际的互联网路由可以更长。）](http://atomoreilly.com/source/nostarch/images/287865.png.jpg)'
- en: Figure 23-2. IP datagram next-hop routing This is the same diagram as that shown
    in [Figure 23-1](ch23.html#direct_and_indirect_routed_delivery_of_i "Figure 23-1. Direct
    and indirect (routed) delivery of IP datagrams This diagram shows three examples
    of IP datagram delivery. The first transmission (#1, dark arrow) shows a direct
    delivery between two devices on the local network. The second (#2, light arrow)
    shows indirect delivery within the local network, between a client and server
    separated by a router. The third (#3, medium arrow) shows a more distant indirect
    delivery, between a client on the local network and a server across the Internet."),
    except it explicitly shows the hops taken by each of the three sample transmissions.
    The direct delivery of the first transmission has only one hop (remember that
    the switch doesn't count because it is invisible at layer 3). The local indirect
    delivery passes through one router, so it has two hops. The Internet delivery
    has six hops. (Actual Internet routes can be much longer.)
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 图23-2. IP数据报下一跳路由 这与图所示相同，但它明确显示了三个样本传输的跳转。第一次传输的直接交付只有一个跳转（记住交换机不计入，因为在第3层它是不可见的）。本地间接交付通过一个路由器，因此有两个跳转。互联网交付有六个跳转。（实际的互联网路由可以更长。）
- en: Another key concept related to the principle of next-hop routing is that routers,
    not hosts, are designed to accomplish routing. Most hosts are connected to the
    rest of the internetwork (or Internet) using only one router. It would be a maintenance
    nightmare to need to give each host the intelligence to know how to route to every
    other host. Instead, hosts decide only if they are sending to their own local
    network or to another network. If the destination is another network, a host just
    sends the datagram to its router and says, "Here, *you* take care of this." If
    a host has a connection to more than one router, it needs to know only which router
    to use for certain sets of distant networks.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 与下一跳路由原则相关的另一个关键概念是，路由器而不是主机被设计用来完成路由任务。大多数主机仅通过一个路由器连接到互联网的其余部分（或互联网）。如果需要给每个主机提供智能以知道如何路由到其他每个主机，那将是一场维护噩梦。相反，主机只需决定它们是发送到自己的本地网络还是另一个网络。如果目的地是另一个网络，主机只需将数据报发送到其路由器，并说：“这里，*你*来处理这个。”如果一个主机连接到多个路由器，它只需知道为某些远程网络集使用哪个路由器。
- en: Again, each hop consists of the traversal of a physical network. Once a source
    sends a datagram to its local router, the data link layer on the router passes
    it up to the router's IP layer. There, the datagram's header is examined, and
    the router decides which device should get the datagram next. It then passes the
    datagram back down to the data link layer to be sent over one of the router's
    physical network links, typically to another router. The router will have a record
    of the physical addresses of the routers to which it is connected, or it will
    use ARP to determine these addresses.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，每个跳转都包括物理网络的遍历。一旦源主机将其数据报发送到其本地路由器，路由器上的数据链路层将数据报向上传递到路由器的IP层。在那里，检查数据报的报头，路由器决定哪个设备应该接收下一个数据报。然后，它将数据报向下传递到数据链路层，通过路由器的物理网络链路发送，通常是发送到另一个路由器。路由器将记录其连接的路由器的物理地址，或者它将使用ARP来确定这些地址。
- en: IP Routes and Routing Tables
  id: totrans-1194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP路由和路由表
- en: As described in the previous section, routers are responsible for forwarding
    traffic on an IP internetwork. Each router accepts datagrams from a variety of
    sources, examines the IP address of the destination, and decides the next hop
    that the datagram needs to take to get it that much closer to its final destination.
    But how does a router know where to send different datagrams?
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，路由器负责在 IP 互联网上转发流量。每个路由器从各种来源接收数据报，检查目的地的 IP 地址，并决定数据报需要采取的下一个跃点，以便更接近其最终目的地。但是，路由器如何知道将不同数据报发送到何处？
- en: Each router maintains a set of information that provides a mapping between different
    network IDs and the other routers to which it is connected. This information is
    contained in a data structure normally called a *routing table*. Each entry in
    the table, called a *routing entry*, provides information about one network (or
    subnetwork or host). It basically says, "If the destination of this datagram is
    in the following network, the next hop you should take is to the following device."
    Each time a datagram is received, the router checks its destination IP address
    against the routing entries in its table to decide where to send the datagram
    and then sends it on to its next hop.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由器维护一组信息，这些信息提供了不同网络 ID 与其连接的其他路由器之间的映射。这些信息包含在一个通常称为 *路由表* 的数据结构中。表中的每个条目，称为
    *路由条目*，提供有关一个网络（或子网络或主机）的信息。它基本上说，“如果这个数据报的目的地在这个网络中，你应该采取的下一步是到以下设备。”每次接收到数据报时，路由器都会将其目的
    IP 地址与其表中的路由条目进行比较，以决定将数据报发送到何处，然后将其发送到下一个跃点。
- en: Tip
  id: totrans-1197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A router make decisions about how to route datagrams using
    its internal *routing table*. The table contains entries specifying to which router
    datagrams should be sent in order to reach a particular network.'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 路由器通过其内部 *路由表* 来决定如何路由数据报。该表包含条目，指定数据报应发送到哪个路由器，以便到达特定的网络。'
- en: Obviously, the fewer entries in this table, the faster the router can decide
    what to do with datagrams. (This was a big part of the motivation for classless
    addressing, which aggregates routes into supernetworks to reduce router table
    size, as described in the next section.) Some routers have connections to only
    two other devices, so they don't have much of a decision to make. Typically, the
    router will simply take datagrams coming from one of its interfaces and, if necessary,
    send them out on the other one. For example, consider a small company's router
    acting as the interface between a network of three hosts and the Internet. Any
    datagrams sent to the router from a host on this network will need to go over
    the router's connection to the router at the Internet service provider (ISP).
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，表中条目越少，路由器决定如何处理数据报的速度就越快。（这是无类别寻址动机的一部分，它将路由聚合到超网络中，以减少路由表的大小，如下一节所述。）一些路由器只连接到两个其他设备，因此它们没有太多决策要做。通常，路由器将简单地从其接口接收数据报，如果需要，通过另一个接口发送它们。例如，考虑一个小公司的路由器作为三个主机网络与互联网之间的接口。从这个网络的主机发送到路由器的任何数据报都需要通过路由器与互联网服务提供商（ISP）的路由器连接。
- en: When a router has connections to more than two devices, things become considerably
    more complex. A certain distant network may be more easily reachable using a particular
    connection. The routing table not only contains information about the networks
    directly connected to the router, but also information that the router has learned
    about more distant networks.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 当路由器连接到两个以上的设备时，事情会变得相当复杂。使用特定的连接，某个远程网络可能更容易到达。路由表不仅包含有关直接连接到路由器的网络的信息，还包含路由器关于更远程网络的信息。
- en: '[Figure 23-3](ch23s03.html#ip_routing_and_routing_tables_this_diagr "Figure 23-3. IP
    routing and routing tables This diagram shows a small, simple internetwork consisting
    of four LANs each served by a router. The routing table for each lists the router
    to which datagrams for each destination network should be sent. Notice that due
    to the triangle, R1, R2, and R3 can send to each other. However, R2 and R3 must
    send through R1 to deliver to R4, and R4 must use R1 to reach either of the others.")
    shows an example with four routers. Routers R1, R2, and R3 are connected in a
    triangle, so that each router can send directly to the others, as well as to its
    own local network. R1''s local network is 11.0.0.0/8, R2''s is 12.0.0.0/8, and
    R3''s is 13.0.0.0/8\. R1 knows that any datagram it sees with 11 as the first
    octet is on its local network. It will also have a routing entry that says that
    any IP address starting with 12 should go to R2, and any IP address starting with
    13 should go to R3\. R1 also connects to router R4, which has 14.0.0.0/8 as its
    local network. R1 will have an entry for this local network, but R2 and R3 also
    need to know how to reach 14.0.0.0/8, even though they don''t connect to its router
    directly. Most likely, they will have an entry that says that any datagrams intended
    for 14.0.0.0/8 should be sent to R1\. R1 will then forward them to R4\. Similarly,
    R4 will send any traffic intended for 12.0.0.0/8 or 13.0.0.0/8 through R1.'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图23-3](ch23s03.html#ip_routing_and_routing_tables_this_diagr "图23-3. IP路由和路由表
    此图显示了一个由四个局域网组成的小型、简单的互联网，每个局域网都由一个路由器提供服务。每个路由表列出了应将每个目标网络的报文发送到哪个路由器。注意，由于三角形的结构，R1、R2和R3可以相互发送数据。然而，R2和R3必须通过R1来将数据发送到R4，而R4必须使用R1来到达其中的任何一个。")展示了包含四个路由器的示例。路由器R1、R2和R3以三角形的形式连接，这样每个路由器都可以直接向其他路由器发送数据，以及向其自己的本地网络发送。R1的本地网络是11.0.0.0/8，R2的是12.0.0.0/8，R3的是13.0.0.0/8。R1知道任何以11开头的八位字节的数据报都在其本地网络中。它还将有一个路由条目，说明任何以12开头的IP地址应发送到R2，任何以13开头的IP地址应发送到R3。R1还连接到路由器R4，其本地网络为14.0.0.0/8。R1将有一个关于这个本地网络的条目，但R2和R3也需要知道如何到达14.0.0.0/8，即使它们没有直接连接到其路由器。很可能会有一个条目说明，任何针对14.0.0.0/8的数据报应发送到R1。然后R1将它们转发到R4。同样，R4将任何针对12.0.0.0/8或13.0.0.0/8的流量通过R1发送。'
- en: '![IP routing and routing tables This diagram shows a small, simple internetwork
    consisting of four LANs each served by a router. The routing table for each lists
    the router to which datagrams for each destination network should be sent. Notice
    that due to the triangle, R1, R2, and R3 can send to each other. However, R2 and
    R3 must send through R1 to deliver to R4, and R4 must use R1 to reach either of
    the others.](httpatomoreillycomsourcenostarchimages287867.png.jpg)'
  id: totrans-1202
  prefs: []
  type: TYPE_IMG
  zh: '![IP路由和路由表 此图显示了一个由四个局域网组成的小型、简单的互联网，每个局域网都由一个路由器提供服务。每个路由表列出了应将每个目标网络的报文发送到哪个路由器。注意，由于三角形的结构，R1、R2和R3可以相互发送数据。然而，R2和R3必须通过R1来将数据发送到R4，而R4必须使用R1来到达其中的任何一个。](httpatomoreillycomsourcenostarchimages287867.png.jpg)'
- en: Figure 23-3. IP routing and routing tables This diagram shows a small, simple
    internetwork consisting of four LANs each served by a router. The routing table
    for each lists the router to which datagrams for each destination network should
    be sent. Notice that due to the triangle, R1, R2, and R3 can send to each other.
    However, R2 and R3 must send through R1 to deliver to R4, and R4 must use R1 to
    reach either of the others.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 图23-3. IP路由和路由表 此图显示了一个由四个局域网组成的小型、简单的互联网，每个局域网都由一个路由器提供服务。每个路由表列出了应将每个目标网络的报文发送到哪个路由器。注意，由于三角形的结构，R1、R2和R3可以相互发送数据。然而，R2和R3必须通过R1来将数据发送到R4，而R4必须使用R1来到达其中的任何一个。
- en: Now, imagine that this process is expanded to handle thousands of networks and
    routers. Not only do routers need to know which of their local connections to
    use for each network, but they want to know, if possible, what is the *best* connection
    to use for each network. Since routers are interconnected in a mesh, there are
    usually multiple routes between any two devices, but we want to take the best
    route whenever we can. This may be the shortest route, the least congested route,
    or the route considered optimal based on other criteria.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象这个过程被扩展以处理成千上万的网络和路由器。路由器不仅需要知道它们为每个网络使用哪个本地连接，而且如果可能的话，它们还想知道每个网络的最佳连接是什么。由于路由器以网状形式相互连接，通常任何两个设备之间都有多条路由，但我们希望尽可能选择最佳路由。这可能是最短的路由，最不拥挤的路由，或者基于其他标准被认为是最佳的路由。
- en: Determining which routes we should use for different networks is an important
    but very complex job. Routers plan routes and exchange information about routes
    and networks using IP *routing protocols*. R2 and R3 use these protocols to find
    out that 14.0.0.0/8 exists and that it is connected to them via R1\. (I discuss
    these support protocols in Chapters [Chapter 37](ch37.html "Chapter 37. OVERVIEW
    OF KEY ROUTING PROTOCOL CONCEPTS") through [Chapter 41](ch41.html "Chapter 41. OTHER
    ROUTING PROTOCOLS").)
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们应该为不同的网络使用哪些路由是一项重要但非常复杂的工作。路由器通过使用IP *路由协议*来规划路由并交换有关路由和网络的信息。R2和R3使用这些协议来找出14.0.0.0/8的存在以及它是通过R1连接到它们的。（我在[第37章](ch37.html
    "第37章. 关键路由协议概念概述")到[第41章](ch41.html "第41章. 其他路由协议")中讨论了这些支持协议。）
- en: Note
  id: totrans-1206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There is a difference between a routable protocol and a routing protocol.
    IP is a routable protocol, which means its messages (datagrams) can be routed.
    Examples of routing protocols are the Routing Information Protocol (RIP) and Border
    Gateway Protocol (BGP), which are used to exchange routing information between
    routers (see [Chapter 38](ch38.html "Chapter 38. ROUTING INFORMATION PROTOCOL
    (RIP, RIP-2, AND RIPNG)") and [Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY
    PROTOCOL (BGP/BGP-4)"))*.'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: '*可路由协议和路由协议之间是有区别的。IP是一个可路由协议，这意味着它的消息（数据报）可以被路由。路由协议的例子有路由信息协议（RIP）和边界网关协议（BGP），它们用于在路由器之间交换路由信息（见[第38章](ch38.html
    "第38章. 路由信息协议（RIP、RIP-2和RIPNG)")和[第40章](ch40.html "第40章. 边界网关协议（BGP/BGP-4)"))*。'
- en: IP Routing in a Subnet or Classless Addressing (CIDR) Environment
  id: totrans-1208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网或无类别地址（CIDR）环境中的IP路由
- en: 'As discussed in the previous chapters, there are three main categories of IP
    addressing: classful, subnetted classful, and classless. The method used for determining
    whether direct or indirect delivery of a datagram is required is different for
    each type of addressing. The type of addressing used in the network also impacts
    how routers decide to forward traffic in an internetwork.'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，IP寻址主要有三种类型：类别寻址、子网类别寻址和无类别寻址。确定是否需要直接或间接交付数据报的方法因寻址类型而异。网络中使用的寻址类型也会影响路由器在互联网中转发流量的决策。
- en: One of the main reasons why the traditional class-based addressing scheme was
    created was that it made both addressing and routing relatively simple. Remember
    that IPv4 was developed in the late 1970s, when the cheap and powerful computer
    hardware we take for granted today was still science fiction. For the internetwork
    to function properly, routers needed to be able to look at an IP address and quickly
    decide what to do with it.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 传统基于类别的寻址方案被创造出来的主要原因是它使得寻址和路由相对简单。记住，IPv4是在20世纪70年代末开发的，当时我们今天视为理所当然的廉价且强大的计算机硬件仍然是科幻。为了使互联网能够正常工作，路由器需要能够查看IP地址并快速决定如何处理它。
- en: 'Classful addressing was intended to make this possible. There was only a two-level
    hierarchy for the entire internetwork: network ID and host ID. Routers could tell
    by looking at the first four bits which of the bits in any IP address were the
    network ID and which were the host ID. Then they needed only consult their routing
    tables to find the network ID and see which router offered the best route to that
    network.'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 类别寻址旨在实现这一点。整个互联网只有两级层次结构：网络ID和主机ID。路由器可以通过查看IP地址的前四个比特来判断任何IP地址中的哪些比特是网络ID，哪些是主机ID。然后他们只需要查阅他们的路由表来找到网络ID并查看哪个路由器提供了到达该网络的最佳路由。
- en: The addition of subnetting to conventional addressing didn't really change this
    for the main routers on the Internet, because subnetting is internal to the organization.
    The main routers handling large volumes of traffic on the Internet didn't look
    at subnets at all. The additional level of hierarchy that subnets represent existed
    only for the routers within each organization that chose to use subnetting. These
    routers, when deciding what to do with datagrams within the organization's network,
    needed to extract not only the network ID of IP addresses, but also the subnet
    ID. This told them which internal physical network should get the datagram.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统寻址中添加子网并没有真正改变互联网主要路由器的情况，因为子网是组织内部的。处理互联网上大量流量的主要路由器根本不查看子网。子网所代表的额外层次结构仅存在于选择使用子网的组织内部的路由器中。这些路由器在决定如何处理组织网络内的数据报时，需要提取不仅包括IP地址的网络ID，还包括子网ID。这告诉它们哪个内部物理网络应该接收数据报。
- en: Classless addressing is formally called *Classless Inter-Domain Routing (CIDR)*.
    The fact that the name includes *routing* but not *addressing* is evidence that
    CIDR was introduced in large part to improve the efficiency of routing. This improvement
    occurs because classless networks use a multiple-level hierarchy. Each network
    can be broken down into subnetworks, sub-subnetworks, and so on. This means that
    when we are deciding how to route in a CIDR environment, we can also describe
    routes in a hierarchical manner. Many smaller networks can be described using
    a single, higher-level network description that represents them all to routers
    in the rest of the internetwork. This technique, sometimes called *route aggregation*,
    reduces routing table size.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 无类别寻址正式称为*无类别域间路由（CIDR）*。名字中包含*路由*但不包含*寻址*的事实表明，CIDR在很大程度上是为了提高路由效率而引入的。这种改进发生是因为无类别网络使用多级层次结构。每个网络都可以分解成子网络、次子网络等等。这意味着当我们决定在CIDR环境中如何路由时，我们也可以以层次化的方式描述路由。许多较小的网络可以使用单个高级网络描述来描述，该描述代表它们在互联网其他路由器中的所有信息。这种技术有时被称为*路由聚合*，可以减少路由表的大小。
- en: Let's refer back to the detailed example I presented in [Chapter 20](ch20.html
    "Chapter 20. IP CLASSLESS ADDRESSING—CLASSLESS INTER-DOMAIN ROUTING (CIDR)/SUPERNETTING").
    An ISP started with the block 71.94.0.0/15 and subdivided it multiple times to
    create smaller blocks for itself and its customers. To the customers and users
    of this block, these smaller blocks must be differentiated; the ISP obviously
    needs to know how to route traffic to the correct customer. To everyone else on
    the Internet, however, these details are unimportant in deciding how to route
    datagrams to anyone in that ISP's block.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我在[第20章](ch20.html "第20章。IP无类别寻址—无类别域间路由（CIDR）/超网")中提供的详细示例。一个ISP从71.94.0.0/15块开始，多次细分以为自己和客户创建更小的块。对于这个块的客户和用户来说，这些较小的块必须区分开来；ISP显然需要知道如何将流量路由到正确的客户。然而，对于互联网上的其他人来说，这些细节在决定如何将数据报路由到该ISP块中的任何人的时候并不重要。
- en: For example, suppose I am using a host with IP address 211.42.113.5 and I need
    to send a message to 71.94.1.43\. My local router and the main routers on the
    Internet don't know where in the 71.94.0.0/15 block that address is, and they
    don't need to know. They just know that anything with the first 15 bits containing
    the binary equivalent of 71.94 goes to the router that handles 71.94.0.0/15, which
    is the aggregated address of the entire block. They let the ISP's routers figure
    out which of its constituent subnetworks contains 71.94.1.43.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我正在使用一个IP地址为211.42.113.5的主机，我需要向71.94.1.43发送消息。我的本地路由器和互联网上的主要路由器不知道该地址在71.94.0.0/15块中的哪个位置，而且它们不需要知道。它们只知道任何前15位包含71.94的二进制等效值的地址都发送到处理71.94.0.0/15的聚合地址的路由器。他们是整个块的聚合地址。他们让ISP的路由器确定其构成子网络中包含71.94.1.43的是哪一个。
- en: Contrast this with a classful environment. Here, each of the customers of this
    ISP would probably have one or more Class C address blocks, each of which would
    require a separate routing entry, and these blocks would need to be known by *all*
    routers on the Internet. Thus, instead of just one 71.94.0.0/15 entry, there would
    be dozens or even hundreds of entries for each customer network. In the classless
    scheme, only one entry exists, for the parent ISP.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与类别环境进行对比。在这里，这个ISP的每个客户可能都有一个或多个C类地址块，每个块都需要一个单独的路由条目，并且这些块需要为互联网上的所有路由器所知。因此，而不是只有一个71.94.0.0/15条目，每个客户网络都会有数十个甚至数百个条目。在无类别方案中，只有一个条目存在，即为父ISP。
- en: CIDR provides benefits to routing but also increases its complexity. Under CIDR,
    we cannot determine which bits are the network ID and which are the host ID just
    from the IP address. To make matters worse, we can have networks, subnetworks,
    sub-subnetworks, and so on that all have the same base address!
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: CIDR为路由提供了好处，但也增加了其复杂性。在CIDR下，我们不能仅从IP地址中确定哪些位是网络ID，哪些位是主机ID。更糟糕的是，我们可以有网络、子网络、次子网络等等，它们都具有相同的基址！
- en: In our example, 71.94.0.0/15 is the complete network, and subnetwork 0 is 71.94.0.0/16\.
    They have a different prefix length (the number of network ID bits) but the same
    base address. If a router has more than one match for a network ID in this manner,
    it must use the match with the longest network identifier first, since it represents
    a more specific network description.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，71.94.0.0/15是完整网络，子网络0是71.94.0.0/16。它们有不同的前缀长度（网络ID位的数量），但相同的基址。如果一个路由器以这种方式对网络ID有多个匹配项，它必须首先使用具有最长网络标识符的匹配项，因为它代表了一个更具体的网络描述。
- en: IP Multicasting
  id: totrans-1219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP多播
- en: The great bulk of TCP/IP communications uses IP to send messages from one source
    device to one recipient device, in a process called *unicast* communication. This
    is the type of messaging we normally use TCP/IP for, so when you use the Internet,
    you are using unicast for pretty much everything.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP通信的大部分都使用IP将消息从一台源设备发送到一台接收设备，这个过程被称为*单播*通信。这是我们通常使用TCP/IP进行消息传递的类型，因此当你使用互联网时，你实际上几乎在所有情况下都在使用单播。
- en: IP does, however, also support the ability to have one device send a message
    to a set of recipients. This is called *multicasting*. IP multicasting has been
    officially supported since IPv4 was first defined, but has not seen widespread
    use over the years, due largely to lack of support for multicasting in many hardware
    devices. Interest in multicasting has increased in recent years, and support for
    multicasting was made a standard part of the next-generation IP version 6 (IPv6)
    protocol. Here, we will take a brief look at multicasting, which is a large and
    complex subject.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IP也支持一个设备向一组接收者发送消息的能力。这被称为*多播*。IP多播自IPv4首次定义以来就已经得到官方支持，但多年来并没有得到广泛的应用，这主要归因于许多硬件设备对多播的支持不足。近年来，对多播的兴趣有所增加，并且多播支持已成为下一代IP版本6（IPv6）协议的标准部分。在这里，我们将简要地看看多播，这是一个庞大而复杂的话题。
- en: The idea behind IP multicasting is to allow a device on an IP internetwork to
    send datagrams not to just one recipient, but to an arbitrary collection of other
    devices. IP multicasting is modeled after the similar function used in the data
    link layer to allow a single hardware device to send to various members of a group.
    Multicasting is relatively easy at the data link layer, however, because all the
    devices can communicate directly. In contrast, at the network layer, we are connecting
    together devices that may be quite far away from each other and must route datagrams
    between these different networks. This necessarily complicates multicasting when
    done using IP (except in the special case where we use IP multicasting only between
    devices on the same data link layer network).
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: IP多播背后的想法是允许IP互联网上的一个设备向任意集合的其他设备发送数据报，而不仅仅是向一个接收者发送。IP多播是模仿在数据链路层使用类似功能，允许单个硬件设备向组内的多个成员发送数据。在数据链路层，多播相对容易，因为所有设备都可以直接通信。相比之下，在网络层，我们正在连接可能相隔甚远的设备，必须在不同的网络之间路由数据报。这必然会使使用IP进行的多播变得复杂（除非在特殊情况下，我们只在同一数据链路层网络上的设备之间使用IP多播）。
- en: 'There are three primary functions that must be performed to implement IP multicasting:
    addressing, group management, and datagram processing/routing.'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 实现IP多播必须执行三个主要功能：寻址、组管理和数据报处理/路由。
- en: Multicast Addressing
  id: totrans-1224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播寻址
- en: 'Special addressing must be used for multicasting. A *multicast address* identifies
    not a single device, but a *multicast group* of devices that listen for certain
    datagrams sent to them. In IPv4, one-sixteenth of the entire address space was
    set aside for multicast addresses: the Class D block of the original classful
    addressing scheme. Various techniques are used to define the meaning of addresses
    within this block and to define a mapping between IP multicast and data link layer
    multicast addresses. (See the discussion of IP multicast addressing in [Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING"); mapping of IP multicast addresses
    to hardware layer multicast addresses is discussed in [Chapter 13](ch13.html "Chapter 13. ADDRESS
    RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)").)'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 多播必须使用特殊的寻址方式。一个*多播地址*标识的不是单个设备，而是一个*多播组*的设备，这些设备会监听发送给它们的特定数据报。在IPv4中，整个地址空间中有一六分之一被留给了多播地址：原始的类地址方案中的D类块。使用各种技术来定义该块中地址的含义，以及定义IP多播地址与数据链路层多播地址之间的映射。（参见第17章关于IP多播地址的讨论[Chapter 17](ch17.html
    "Chapter 17. CLASSFUL (CONVENTIONAL) ADDRESSING")；第13章讨论了IP多播地址到硬件层多播地址的映射[Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)")。）
- en: Multicast Group Management
  id: totrans-1226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播组管理
- en: Group management encompasses all of the activities required to set up groups
    of devices. Devices must be able to dynamically join groups and leave groups,
    and information about groups must be propagated around the IP internetwork. To
    support these activities, additional techniques are required. The *Internet Group
    Management Protocol (IGMP)* is the chief tool used for this purpose. It defines
    a message format to allow information about groups and group membership to be
    sent between devices and routers on the Internet.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 组管理包括设置设备组所需的所有活动。设备必须能够动态地加入和离开组，并且关于组的信息必须在IP互联网中传播。为了支持这些活动，需要额外的技术。*互联网组管理协议（IGMP）*是用于此目的的主要工具。它定义了一种消息格式，允许在互联网上的设备和路由器之间发送有关组和组成员的信息。
- en: Multicast Datagram Processing and Routing
  id: totrans-1228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多播数据报处理和路由
- en: 'Handling and routing datagrams in a multicast environment is probably the most
    complicated function. There are several issues here:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 在多播环境中处理和路由数据报可能是最复杂的函数。这里有几个问题：
- en: Since we are sending from one device to many, we need to actually create multiple
    copies of the datagram for delivery, in contrast to the single datagram used in
    the unicast case. Routers must be able to tell when they need to create these
    copies.
  id: totrans-1230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们是将数据从一台设备发送到多台，因此实际上需要为交付创建多个数据报副本，这与单播情况中使用的单个数据报不同。路由器必须能够判断何时需要创建这些副本。
- en: Routers must use special algorithms to determine how to forward multicast datagrams.
    Since each one can lead to many copies being sent to various places, efficiency
    is important to avoid creating unnecessary volumes of traffic.
  id: totrans-1231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器必须使用特殊的算法来确定如何转发多播数据报。由于每个数据报都可能导致发送到各个地方的多份副本，因此效率很重要，以避免产生不必要的流量。
- en: Routers must be able to handle datagrams sent to a multicast group, even if
    the source is not a group member.
  id: totrans-1232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使源不是组成员，路由器也必须能够处理发送到多播组的数据报。
- en: Routing in a multicast environment requires significantly more intelligence
    on the part of router hardware. Several special protocols, such as the Distance
    Vector Multicast Routing Protocol (DVMRP) and the multicast version of Open Shortest
    Past First (OSPF), are used to enable routers to forward multicast traffic effectively.
    These algorithms must balance the need to ensure that every device in a group
    receives a copy of all datagrams intended for that group with the need to prevent
    unnecessary traffic from moving across the internetwork.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 在多播环境中进行路由需要路由硬件具备显著更多的智能。一些特殊的协议，例如距离矢量多播路由协议（DVMRP）和开放最短路径优先（OSPF）的多播版本，被用来使路由器能够有效地转发多播流量。这些算法必须在确保组内每个设备都能接收到为该组设计的所有数据报的同时，防止不必要的流量在互联网中传输。
- en: Tip
  id: totrans-1234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IP multicasting allows special applications to be developed
    where one device sends information to multiple devices, across a private internetwork
    or the global Internet. It is more complex than conventional unicast IP and requires
    special attention, particularly in the areas of addressing and routing.'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IP多播允许开发特殊的应用程序，其中一个设备可以向多个设备发送信息，这些设备位于私有互联网或全球互联网中。与传统的单播IP相比，它更为复杂，需要特别注意，尤其是在地址和路由方面。'
- en: 'This overview has only scratched the surface of IP multicasting. The complexity
    involved in handling groups and forwarding messages to multicast groups is one
    reason why support for the feature has been quite uneven and, as a consequence,
    it is not used widely. Another issue is the demanding nature of multicasting:
    It uses a great deal of network bandwidth for copies of messages, and it also
    requires more work of already-busy routers.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 本概述只是对IP多播的表面进行了探讨。处理组和将消息转发到多播组所涉及到的复杂性是支持该功能相当不均匀的一个原因，因此，它并没有被广泛使用。另一个问题是多播的苛刻性：它需要大量的网络带宽来复制消息，同时也要求已经忙碌的路由器做更多的工作。
