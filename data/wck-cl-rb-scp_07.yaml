- en: Chapter 7. SERVERS AND SCRAPERS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。SERVERS AND SCRAPERS
- en: '![SERVERS AND SCRAPERS](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![SERVERS AND SCRAPERS](../Images/00001.jpg)'
- en: A powerful aspect of Ruby is that you can use it to develop ways to automate
    interactions with resources on the Web. This chapter gives a brief overview of
    how to play with web pages and concludes with a set of client/server scripts that
    can securely pass and execute commands. Interacting with and extracting data from
    the Web is important because there is a wealth of information available—this is
    known as *data mining*. Instead of mining for gold, we will look at different
    ways to mine for significant data and turn it into meaningful information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的一个强大之处在于，你可以用它来开发与网络资源交互自动化的方法。本章简要概述了如何处理网页，并以一组客户端/服务器脚本结束，这些脚本可以安全地传递和执行命令。与网络交互并从网络中提取数据很重要，因为这里有大量的信息——这被称为
    *数据挖掘*。我们不会像淘金一样，而是会探讨不同的方法来挖掘重要数据并将其转化为有意义的信息。
- en: Define
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义
- en: Define
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义
- en: define.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: define.rb
- en: This script will query the Web to retrieve the first definition of any user-specified
    word. The website being queried is [http://www.dictionary.com/](http://www.dictionary.com/),
    and like any script that interacts with the Web, there is risk of this script
    breaking if the web designers make any changes. The purpose of the script is to
    retrieve the data you specifically want. Using Dictionary.com is just a means
    to demonstrate that skill, although this is a slick example.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将查询网络以检索任何用户指定的单词的第一个定义。查询的网站是 [http://www.dictionary.com/](http://www.dictionary.com/)，像任何与网络交互的脚本一样，如果网站设计者做出任何更改，此脚本可能会中断。脚本的目的就是检索你想要的数据。使用Dictionary.com只是演示这项技能的一种方式，尽管这是一个很好的例子。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require "open-uri"   unless ARGV[0]      puts "You
    must supply a word to define."      puts "USAGE: ruby define.rb <word to define>"
         exit  end  ![](../Images/00003.jpg) word = ARGV[0].strip  ![](../Images/00004.jpg) url
    = "http://dictionary.reference.com/search?q=#{word}"   begin ![](../Images/00005.jpg)  
      open(url) do |source|      source.each_line do |x| ![](../Images/00006.jpg)  
          if x =~ /No results found/          puts "\nPlease check spelling, no definition
    was found."          exit      end ![](../Images/00007.jpg)         if x =~ /(1\.)<\/td><td
    valign="top">(.*)<\/td/          puts "\n#{$1} #{$2}"          exit      end  end
    ![](../Images/00008.jpg)     puts "Sorry, unable to find a definition."  end  rescue
    => e      puts "An error occurred, please try again."      puts e  end`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require "open-uri"   unless ARGV[0]      puts "您必须提供一个要定义的单词。"
         puts "用法：ruby define.rb <要定义的单词>"      exit  end  ![](../Images/00003.jpg) word
    = ARGV[0].strip  ![](../Images/00004.jpg) url = "http://dictionary.reference.com/search?q=#{word}"   begin
    ![](../Images/00005.jpg)     open(url) do |source|      source.each_line do |x|
    ![](../Images/00006.jpg)         if x =~ /No results found/          puts "\n请检查拼写，没有找到定义。"
             exit      end ![](../Images/00007.jpg)         if x =~ /(1\.)<\/td><td
    valign="top">(.*)<\/td/          puts "\n#{$1} #{$2}"          exit      end  end
    ![](../Images/00008.jpg)     puts "抱歉，无法找到定义。"  end  rescue => e      puts "发生错误，请重试。"
         puts e  end`'
- en: Running the Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行此脚本：
- en: '``**`ruby define.rb`** *`word to define`*``'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby define.rb`** *`要定义的单词`*``'
- en: I chose to define the word *Ruby* in this example. Unfortunately, *the most
    wicked programming language* was not the first result returned!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我选择定义单词 *Ruby*。不幸的是，*最邪恶的编程语言* 并不是第一个返回的结果！
- en: The Results
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script will display the definition of any word supplied. If the definition
    can't be found, the user will be asked to check the spelling—perhaps the word
    doesn't exist.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将显示任何提供的单词的定义。如果找不到定义，用户将被要求检查拼写——也许这个单词不存在。
- en: '`1.a red variety of corundum, used as a gem.`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.红宝石的一种，用作宝石。`'
- en: How It Works
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Once again, we encounter the fantastic library open-uri ![](../Images/00002.jpg).
    Whenever a script deals with web interaction, there are a handful of useful libraries;
    I prefer open-uri because it abstracts even more of the network connection details
    than other libraries. After the required library is identified, some error checking
    is performed. I hope you're used to this code block by now. The first variable
    is called `word` and will hold the word that the user wants to define ![](../Images/00003.jpg).
    Next, the Dictionary.com URL is hardcoded into the variable `url` with the addition
    of the user-supplied word ![](../Images/00004.jpg). Thanks to the webmasters at
    Dictionary.com, appending a word to the URL will automatically return the definition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 再次遇到神奇的库open-uri！[](../Images/00002.jpg)。每当脚本处理网络交互时，总有一些有用的库；我更喜欢open-uri，因为它比其他库抽象了更多的网络连接细节。在确定所需的库之后，进行一些错误检查。我希望你现在已经习惯了这段代码。第一个变量被称为`word`，将保存用户想要定义的单词！[](../Images/00003.jpg)。接下来，Dictionary.com的URL被硬编码到变量`url`中，并添加了用户提供的单词！[](../Images/00004.jpg)。感谢Dictionary.com的网站管理员，将单词附加到URL上会自动返回定义。
- en: Next, we start a `begin/rescue` statement due to the volatile nature of web
    requests. HTTP requests are often answered with various error messages; dealing
    with those messages appropriately is the key to success in this script. Now that
    we've deployed our `begin/rescue` safety net, we are ready to ask Dictionary.com
    for the definition. open-uri lets us simply type `open()`, pass the URL to the
    method, and retrieve a web page ![](../Images/00005.jpg). I smile every time I
    use the `open` method because getting a web page is so easy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们由于网络请求的不稳定性开始一个`begin/rescue`语句。HTTP请求通常以各种错误消息作为回答；适当地处理这些消息是脚本成功的关键。现在我们已经部署了`begin/rescue`安全网，我们就可以向Dictionary.com请求定义了。`open-uri`允许我们简单地输入`open()`，将URL传递给方法，并检索一个网页！[](../Images/00005.jpg)。每次使用`open`方法，我都会微笑，因为获取网页是如此简单。
- en: The `open` method is followed by a block that manipulates the source code returned
    by the web server. Because we are looking for a particular line (the word's definition),
    we start another block of code that breaks the source code down line by line.
    Dictionary.com will display the message *No results found* if a word cannot be
    defined. If the script finds these words (but no definition) while analyzing the
    source code, it reminds the user to check the spelling of the word as a helpful
    hint, and then exits ![](../Images/00006.jpg). However, if the definition is found,
    the script will begin isolating exactly where the definition resides in the source
    code. A regular expression is used to pinpoint the exact text.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`方法后面跟着一个处理由网络服务器返回的源代码的块。因为我们正在寻找特定的行（单词的定义），所以我们开始另一个代码块，逐行分解源代码。如果单词无法定义，Dictionary.com将显示消息*没有找到结果*。如果脚本在分析源代码时找到这些单词（但没有定义），它会提醒用户检查单词的拼写作为一个有用的提示，然后退出！[](../Images/00006.jpg)。然而，如果找到定义，脚本将开始隔离定义在源代码中的确切位置。使用正则表达式来精确定位文本。'
- en: The important part of the regular expression is the `1`. Dictionary.com uses
    this as an annotation for the first definition, which is what we are interested
    in. Using parentheses in the regular expression allows the script to group certain
    areas of any line that match the expression ![](../Images/00007.jpg). The groups
    are stored in the variables `[$1]` through `[$n]`. The line after the regular
    expression outputs the definition. If neither the definition nor *No results found*
    are located in the source code, a different message is displayed, letting the
    user know the definition could not be found ![](../Images/00008.jpg). If any error(s)
    occurred during the definition process, our `rescue` block kicks off and specifies
    what error(s) occurred.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中重要的部分是`1`。Dictionary.com使用这个作为第一个定义的注释，这是我们感兴趣的。在正则表达式中使用括号允许脚本将任何匹配表达式的行的特定区域分组！[](../Images/00007.jpg)。这些组存储在变量`[$1]`到`[$n]`中。正则表达式之后的行输出定义。如果源代码中既没有找到定义也没有找到*没有找到结果*，则会显示不同的消息，告知用户定义无法找到！[](../Images/00008.jpg)。如果在定义过程中发生任何错误，我们的`rescue`块就会启动并指定发生了哪些错误。
- en: Hacking the Script
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞挖掘脚本
- en: One way to hack this script is by adding a proxy between the user and the request
    to the web server. If you are using a proxy, you must do this. If you are curious
    about the web traffic from Ruby, the proxy will give you a little insight. See
    the documentation for open-uri; the syntax will look something like `open(url,
    :proxy => "http://127.0.0.1:8080")`. I don't normally have a proxy in place when
    I'm surfing the Web, but when doing web development, I find it helpful to watch
    the traffic in case any errors are encountered.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要破解此脚本的一种方法是在用户和Web服务器请求之间添加一个代理。如果您正在使用代理，您必须这样做。如果您对Ruby的Web流量感到好奇，代理会为您提供一些洞察。请参阅open-uri的文档；语法看起来像`open(url,
    :proxy => "http://127.0.0.1:8080")`。我通常在上网时不会设置代理，但在进行Web开发时，我发现观察流量以防止出现错误是有帮助的。
- en: In this instance, I use the free web proxy Paros ([http://www.parosproxy.org/](http://www.parosproxy.org/)).
    Paros is installed locally on my machine, and I can watch as my web requests are
    made and subsequent responses are received. I have saved many hours of debugging
    by having Paros involved in my development. I am very partial to Paros, but there
    are many other proxies from which to choose, so take a look around.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用的是免费的Web代理Paros ([http://www.parosproxy.org/](http://www.parosproxy.org/))。Paros安装在我的机器上，我可以观察我的Web请求以及随后收到的响应。由于Paros参与了我的开发，我节省了许多调试时间。我对Paros非常偏爱，但还有许多其他代理可供选择，所以请四处看看。
- en: Automated SMS
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化短信
- en: Automated SMS
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化短信
- en: sms.rb
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sms.rb
- en: This script sends an SMS message to whatever mobile phone number you choose.
    I caution you not to abuse the functionality, but you do have to try it. The premise
    is to automate the use of a site that sends SMS messages to people for you. Instead
    of grabbing static web content, this script will actually automate filling out
    and submitting a web form.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本会将短信消息发送到您选择的任何手机号码。我警告您不要滥用此功能，但您确实需要尝试一下。前提是自动化使用一个为您发送短信的网站。此脚本实际上会自动化填写和提交Web表单，而不是抓取静态Web内容。
- en: The Code
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''win32ole''  ![](../Images/00002.jpg) ie = WIN32OLE.new(''InternetExplorer.Application'')
    ![](../Images/00003.jpg) ie.navigate("http://toolbar.google.com/send/sms/index.php")   ie.visible
    = true ![](../Images/00004.jpg) sleep 1 until ie.readyState() == 4  ![](../Images/00005.jpg) ie.document.all["mobile_user_id"].value
    ="5712013623"  ie.document.all["carrier"].value ="TMOBILE"  ie.document.all["subject"].value
    ="***Ruby Rulez***" ![](../Images/00006.jpg) ie.document.all.tags("textarea").each
    do |i|      i.value = "Thanks for the hard work, Matz!"  end  ![](../Images/00007.jpg) ie.document.all.send_button.click`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''win32ole''  ![](../Images/00002.jpg) ie = WIN32OLE.new(''InternetExplorer.Application'')
    ![](../Images/00003.jpg) ie.navigate("http://toolbar.google.com/send/sms/index.php")   ie.visible
    = true ![](../Images/00004.jpg) sleep 1 until ie.readyState() == 4  ![](../Images/00005.jpg) ie.document.all["mobile_user_id"].value
    ="5712013623"  ie.document.all["carrier"].value ="TMOBILE"  ie.document.all["subject"].value
    ="***Ruby Rulez***" ![](../Images/00006.jpg) ie.document.all.tags("textarea").each
    do |i|      i.value = "Thanks for the hard work, Matz!"  end  ![](../Images/00007.jpg) ie.document.all.send_button.click`'
- en: Running the Code
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行此脚本：
- en: '``**`ruby googleS2P.rb`**``'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby googleS2P.rb`**``'
- en: The Results
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script doesn't output anything, but if successful, the phone attached to
    the phone number supplied should notify you of an incoming message. I've used
    fictitious data, but feel free to edit it for your amusement.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本不会输出任何内容，但如果成功，与提供的电话号码相连的手机应该会通知您有新消息。我使用了虚构的数据，但您可以根据自己的兴趣进行编辑。
- en: How It Works
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: If you own a computer with Windows and have never played with the library win32ole,
    you need to make time for it, because Windows automation is interesting and fun.
    Not only can you manipulate Internet Explorer (IE), as demonstrated in this script,
    but you can also manipulate any of the Microsoft Office products, as well as other
    Windows applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拥有Windows电脑并且从未玩过win32ole库，您需要抽出时间来尝试，因为Windows自动化既有趣又好玩。不仅如脚本中所示，您可以操作Internet
    Explorer（IE），还可以操作任何Microsoft Office产品以及其他Windows应用程序。
- en: '* * *'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There are several other libraries available for website automation that are
    extremely helpful for regression and quality assurance testing of web applications.
    One of the more popular examples is Watir (pronounced* Water *). Details for Watir
    can be found at* [http://wtr.rubyforge.org/](http://wtr.rubyforge.org/).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*还有许多其他用于网站自动化的库，这些库对于Web应用的回归和质量保证测试非常有帮助。一个更受欢迎的例子是Watir（发音为Water）。有关Watir的详细信息，请参阅[http://wtr.rubyforge.org/](http://wtr.rubyforge.org/)。'
- en: '* * *'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: A new `win32ole` object is created with the IE handle passed as an argument
    ![](../Images/00002.jpg). This lets win32ole know what application will be under
    its control. Using the built-in methods associated with IE, `navigate` obviously
    goes to the specified URL, which is [http://toolbar.google.com/send/sms/index.php/](http://toolbar.google.com/send/sms/index.php/)
    ![](../Images/00003.jpg). The next line specifies an attribute of the IE window.
    If you chose not to watch the script work its magic, you can change this line
    to `false`, and the IE window will disappear into the background. Then you'd only
    be able to see its presence in the task list. Because I like to see the script
    executing, I've set this value to `true`. The Internet Explorer application pops
    up fast, so you have to be ready.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IE句柄作为参数创建了一个新的`win32ole`对象 ![图片](../Images/00002.jpg)。这使win32ole知道将受其控制的应用程序。使用与IE关联的内置方法，`navigate`显然会转到指定的URL，即[http://toolbar.google.com/send/sms/index.php/](http://toolbar.google.com/send/sms/index.php/)
    ![图片](../Images/00003.jpg)。下一行指定了IE窗口的属性。如果你选择不观看脚本施展魔法，你可以将此行更改为`false`，然后IE窗口将消失到后台。然后你只能在任务列表中看到它的存在。因为我喜欢看到脚本执行，所以我将此值设置为`true`。Internet
    Explorer应用程序快速弹出，所以你必须做好准备。
- en: Next is the page load conditional loop. As you know, websites do not load their
    content instantaneously. To prevent the script from submitting its information
    prematurely, this line tells the script to go to sleep for one second and then
    to check back for the correct `readyState` code, which is `4` ![](../Images/00004.jpg).
    Being premature is never a good thing, and it would break the script in this instance.
    Once the IE document has been fully loaded, the script is ready to fill in the
    appropriate fields.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是页面加载条件循环。正如你所知，网站不会立即加载其内容。为了防止脚本提前提交信息，这一行告诉脚本暂停一秒钟，然后检查正确的`readyState`代码，即`4`
    ![图片](../Images/00004.jpg)。提前行动从来都不是好事，这会破坏脚本。一旦IE文档完全加载，脚本就准备好填写适当的字段。
- en: The script knows which fields to look for by the attribute names. If you were
    to look at the source code of the website, you'd see objects called `mobile_user_id`,
    `carrier`, `subject`, and so on. We use this information to specify what input
    goes where ![](../Images/00005.jpg). Most of the HTML used in the website fits
    the standards, but for some reason, the name field of the text area is not put
    in quotation marks. That means we can't use the previous method to access the
    area. Since we saw there was only one text area in the source code, we search
    for it and input our data once it's found. Nothing too fancy, but a little different
    than the norm ![](../Images/00006.jpg).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过属性名称知道要查找哪些字段。如果你查看网站的源代码，你会看到名为`mobile_user_id`、`carrier`、`subject`等对象。我们使用这些信息来指定输入应该放在哪里
    ![图片](../Images/00005.jpg)。网站中使用的HTML大多数符合标准，但不知何故，文本区域的名称字段没有加上引号。这意味着我们无法使用之前的方法来访问区域。由于我们看到源代码中只有一个文本区域，我们搜索它，一旦找到就输入数据。没有什么太花哨的，但与常规有点不同
    ![图片](../Images/00006.jpg)。
- en: All that's left to do after the information is in place is to virtually click
    the send button. Google is great for properly naming buttons, so we just grab
    the button name and tell it to use the `click` method. ![](../Images/00007.jpg).
    That's all there is to it—Ruby is so cool!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息就绪后，剩下的只是虚拟地点击发送按钮。Google在为按钮正确命名方面做得很好，所以我们只需获取按钮名称并告诉它使用`click`方法。 ![图片](../Images/00007.jpg)。就是这样——Ruby真是太酷了！
- en: Link Scrape
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接抓取
- en: Link Scrape
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接抓取
- en: linkScrape.rb
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: linkScrape.rb
- en: Scraping links off of web pages has many uses. As with any problem, there are
    many ways to solve it. In [Chapter 2](../Text/dummy_split_073.html#filepos190170)
    we wrote a script to validate links on a website. Because of the need to validate
    the links, the script required far more lines of code than if it had needed to
    simply scrape all of the links. We aren't going to be building a web spider, but
    I'll cover some of the basic components—the first of which is a link scraper.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从网页上抓取链接有许多用途。就像任何问题一样，解决它的方法有很多。在[第2章](../Text/dummy_split_073.html#filepos190170)中，我们编写了一个脚本来验证网站上的链接。由于需要验证链接，脚本需要比仅仅抓取所有链接时更多的代码行。我们不会构建一个网络蜘蛛，但我将介绍一些基本组件——首先是链接抓取器。
- en: The Code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''mechanize''   unless ARGV[0]      puts
    "You must supply a website."      puts "USAGE: ruby linkScrape.rb <url to scrape>"
         exit  end  ![](../Images/00003.jpg) agent = WWW::Mechanize.new  agent.set_proxy(''localhost'',8080)   begin
    ![](../Images/00004.jpg)     page = agent.get(ARGV[0].strip)       page.links.each
    do |l|          if l.href.split("")[0] ==''/'' ![](../Images/00005.jpg)      
          puts "#{ARGV[0]}#{l.href}"          else              puts l.href       
      end      end  rescue => e      puts "An error occurred."      puts e      retry
     end`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''mechanize''   unless ARGV[0]      puts
    "您必须提供网站。"      puts "用法：ruby linkScrape.rb <要抓取的url>"      exit  end  ![](../Images/00003.jpg) agent
    = WWW::Mechanize.new  agent.set_proxy(''localhost'',8080)   begin ![](../Images/00004.jpg)  
      page = agent.get(ARGV[0].strip)       page.links.each do |l|          if l.href.split("")[0]
    ==''/'' ![](../Images/00005.jpg)             puts "#{ARGV[0]}#{l.href}"       
      else              puts l.href          end      end  rescue => e      puts "发生了一个错误。"
         puts e      retry  end`'
- en: Running the Code
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令执行此脚本：
- en: '``**`ruby linkScrape.rb`** *`http://url_to_scrape.com/`*``'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby linkScrape.rb`** *`http://url_to_scrape.com/`*``'
- en: The Results
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script will output a list of all the links found on the page with the specified
    URL. I've scraped [http://www.nostarch.com/main_menu.htm/](http://www.nostarch.com/main_menu.htm/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将输出指定URL页面上找到的所有链接列表。我已经抓取了[http://www.nostarch.com/main_menu.htm/](http://www.nostarch.com/main_menu.htm/)。
- en: '| index.htm | interactive.htm |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| index.htm | interactive.htm |'
- en: '| catalog.htm | gimp.htm |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| catalog.htm | gimp.htm |'
- en: '| wheretobuy.htm | inkscape.htm |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| wheretobuy.htm | inkscape.htm |'
- en: '| about.htm | js2.htm |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| about.htm | js2.htm |'
- en: '| jobs.htm | eblender.htm |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| jobs.htm | eblender.htm |'
- en: '| media.htm | oophp.htm |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| media.htm | oophp.htm |'
- en: '| [http://www.nostarch.com/blog/](http://www.nostarch.com/blog/) | wpdr.htm
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.nostarch.com/blog/](http://www.nostarch.com/blog/) | wpdr.htm
    |'
- en: '| [http://ww6.aitsafe.com/cf/review/](http://ww6.aitsafe.com/cf/review/) |
    webbots.htm |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| [http://ww6.aitsafe.com/cf/review/](http://ww6.aitsafe.com/cf/review/) |
    webbots.htm |'
- en: '| .cfm?userid=8948354 | google.htm |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| .cfm?userid=8948354 | google.htm |'
- en: '| abs_bsd2.htm | growingsoftware.htm |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| abs_bsd2.htm | growingsoftware.htm |'
- en: '| openbsd.htm | rootkits.htm |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| openbsd.htm | rootkits.htm |'
- en: '| freebsdserver.htm | hacking2.htm |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| freebsdserver.htm | hacking2.htm |'
- en: '| debian.htm | voip.htm |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| debian.htm | voip.htm |'
- en: '| howlinuxworks.htm | firewalls.htm |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| howlinuxworks.htm | firewalls.htm |'
- en: '| appliance.htm | securityvisualization.htm |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| appliance.htm | securityvisualization.htm |'
- en: '| lcbk2.htm | silence.htm |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| lcbk2.htm | silence.htm |'
- en: '| lme.htm | stcb4.htm |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| lme.htm | stcb4.htm |'
- en: '| nongeeks.htm | scsi2.htm |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| nongeeks.htm | scsi2.htm |'
- en: '| lps.htm | cisco.htm |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| lps.htm | cisco.htm |'
- en: '| mug.htm | cablemodem.htm |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| mug.htm | cablemodem.htm |'
- en: '| ubuntu_3.htm | xbox.htm |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| ubuntu_3.htm | xbox.htm |'
- en: '| imap.htm | insidemachine.htm |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| imap.htm | insidemachine.htm |'
- en: '| pf.htm | nero7.htm |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| pf.htm | nero7.htm |'
- en: '| postfix.htm | wireless.htm |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| postfix.htm | wireless.htm |'
- en: '| webmin.htm | creative.htm |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| webmin.htm | creative.htm |'
- en: '| endingspam.htm | ebaypg.htm |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| endingspam.htm | ebaypg.htm |'
- en: '| cluster.htm | ebapsg.htm |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| cluster.htm | ebapsg.htm |'
- en: '| nagios.htm | geekgoddess.htm |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| nagios.htm | geekgoddess.htm |'
- en: '| nagios_2e.htm | wikipedia.htm |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| nagios_2e.htm | wikipedia.htm |'
- en: '| pgp.htm | indtb.htm |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| pgp.htm | indtb.htm |'
- en: '| packet.htm | sayno.htm |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| packet.htm | sayno.htm |'
- en: '| tcpip.htm | networkknowhow.htm |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| tcpip.htm | networkknowhow.htm |'
- en: '| assembly.htm | sharing.htm |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| assembly.htm | sharing.htm |'
- en: '| debugging.htm | apple2.htm |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| debugging.htm | apple2.htm |'
- en: '| qt4.htm | newmac.htm |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| qt4.htm | newmac.htm |'
- en: '| vb2005.htm | cult_mac.htm |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| vb2005.htm | cult_mac.htm |'
- en: '| vsdotnet.htm | ipod.htm |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| vsdotnet.htm | ipod.htm |'
- en: '| codecraft.htm | art_of_raw.htm |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| codecraft.htm | art_of_raw.htm |'
- en: '| hownotc.htm | firstlego.htm |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| hownotc.htm | firstlego.htm |'
- en: '| idapro.htm | flego.htm |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| idapro.htm | flego.htm |'
- en: '| mugperl.htm | legotrains.htm |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| mugperl.htm | legotrains.htm |'
- en: '| gnome.htm | sato.htm |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| gnome.htm | sato.htm |'
- en: '| plg.htm | nxt.htm |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| plg.htm | nxt.htm |'
- en: '| ruby.htm | nxtonekit.htm |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| ruby.htm | nxtonekit.htm |'
- en: '| vbexpress.htm | zoo.htm |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| vbexpress.htm | zoo.htm |'
- en: '| wcj.htm | legobuilder.htm |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| wcj.htm | legobuilder.htm |'
- en: '| wcps.htm | nxtig.htm |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| wcps.htm | nxtig.htm |'
- en: '| wcphp.htm | vlego.htm |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| wcphp.htm | vlego.htm |'
- en: '| wcruby.htm | mg_databases.htm |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| wcruby.htm | mg_databases.htm |'
- en: '| wcss.htm | mg_statistics.htm |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| wcss.htm | mg_statistics.htm |'
- en: '| greatcode.htm | eli.htm |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| greatcode.htm | eli.htm |'
- en: '| greatcode2.htm | index.htm |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| greatcode2.htm | index.htm |'
- en: '| wpc.htm |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| wpc.htm |  |'
- en: How It Works
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Compare the code above with "#10 Web Page Link Validator" on [The Code](../Text/dummy_split_076.html#filepos194055)—quite
    a difference, right? Always think through a problem and remember to solve the
    problem in the simplest way possible. Some of the most elegant solutions are amazingly
    simple. This is a basic website link scraper without regard for validity or anything
    else. The mechanize library is another one commonly used when interacting with
    the Internet ![](../Images/00002.jpg). Aside from the usual error-handling statement,
    a new mechanize object is created which is called `agent` ![](../Images/00003.jpg).
    The object is then customized for future use, so the proxy is set to my local
    Paros proxy. If you don't want to use a proxy, then simply remove this line. Next,
    `agent` uses the method `get` to retrieve the web content ![](../Images/00004.jpg).
    The cool part about mechanize is the way web content is automatically categorized.
    Finding specific elements in the web content using mechanize makes the Ruby coder's
    life that much better.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将上面的代码与 "[第10个网页链接验证器](../Text/dummy_split_076.html#filepos194055)" 进行比较——差异很大，对吧？总是要深思熟虑一个问题，并记住以最简单的方式解决问题。一些最优雅的解决方案竟然是如此简单。这是一个基本的网站链接抓取器，不考虑有效性或其他任何事情。mechanize
    库是在与互联网交互时常用的另一个库 ![图片](../Images/00002.jpg)。除了常规的错误处理语句外，还创建了一个名为 `agent` 的新
    mechanize 对象 ![图片](../Images/00003.jpg)。然后，该对象被定制以供将来使用，因此代理设置为我的本地 Paros 代理。如果你不想使用代理，只需删除这一行即可。接下来，`agent`
    使用 `get` 方法检索网页内容 ![图片](../Images/00004.jpg)。mechanize 的酷之处在于它自动对网页内容进行分类。使用 mechanize
    在网页内容中查找特定元素使得 Ruby 开发者的生活变得更加容易。
- en: Within `page`, the array `links` is found. Thanks to mechanize, the links have
    already been parsed. As with any array, we can use the `each` method and iterate
    through each of its elements. Don't forget that `link` not only contains the URL
    of each link but also other attributes defined in the original source code. We
    are only interested in the `href` attribute, so that is what is output to the
    console ![](../Images/00005.jpg). If you are going to be scraping a large website,
    I'd encourage you to save the output to a file, but that's your call. After the
    links have been printed, the script exits cleanly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `page` 中，找到了数组 `links`。多亏了 mechanize，链接已经被解析。和任何数组一样，我们可以使用 `each` 方法遍历它的每个元素。别忘了
    `link` 不仅包含每个链接的 URL，还包含在原始源代码中定义的其他属性。我们只对 `href` 属性感兴趣，所以这就是输出到控制台的内容 ![图片](../Images/00005.jpg)。如果你打算抓取大型网站，我建议你保存输出到文件，但这取决于你。在打印完链接后，脚本干净地退出。
- en: Hacking the Script
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: There are several other wicked cool web tools, such as Hpricot ([http://code.whytheluckystiff.net/hpricot/](http://code.whytheluckystiff.net/hpricot/))
    and Rubyful Soup ([http://www.crummy.com/software/RubyfulSoup/](http://www.crummy.com/software/RubyfulSoup/)),
    that can accomplish this parsing in a similar fashion. I encourage you to experiment
    with each one to find the tool that suits your needs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个其他非常酷的网页工具，例如 Hpricot ([http://code.whytheluckystiff.net/hpricot/](http://code.whytheluckystiff.net/hpricot/))
    和 Rubyful Soup ([http://www.crummy.com/software/RubyfulSoup/](http://www.crummy.com/software/RubyfulSoup/))），它们可以以类似的方式完成这种解析。我鼓励你尝试每个工具，找到适合你需求的工具。
- en: Image Scrape
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片抓取
- en: Image Scrape
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片抓取
- en: imageScrape.rb
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: imageScrape.rb
- en: This script will scrape every image from the page at a user-supplied URL. The
    image files will include data residing on the host machine in addition to images
    linked from other web servers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将从用户提供的 URL 的页面抓取每个图片。图片文件将包括主机机器上的数据以及从其他网络服务器链接的图片。
- en: The Code
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require "open-uri"  require "pathname"   unless ARGV[0]      puts "You must
    supply a URL to scrape images."      puts "USAGE: ruby imageScrape.rb <url to
    scrape>"      exit  end   url = ARGV[0].strip  begin ![](../Images/00002.jpg)
         open(url, "User-Agent" => "Mozilla/4.0 (compatible; MSIE 5.5; Windows 98)")
     do |source|          source.each_line do |x| ![](../Images/00003.jpg)        
        if x =~ /<img src="(.+.[jpeg|gif])"\s+/                  name = $1.split(''"'').first  ![](../Images/00004.jpg)  
                  name = url + name if Pathname.new(name).absolute? ![](../Images/00005.jpg)  
                  copy = name.split(''/'').last  ![](../Images/00006.jpg)        
            File.open(copy, ''wb'') do |f|                      f.write(open(name).read)
                     end              end          end      end  rescue => e     
    puts "An error occurred, please try again."      puts e`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Running the Code
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行此脚本：
- en: '``**`ruby imageScrape.rb`** *`http://url_to_scrape.com/`*``'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The Results
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script will download all the links found within the specified URL. I've
    scraped [http://www.ruby-lang.org/](http://www.ruby-lang.org/), and it grabbed
    two images, *logo.gif* (a Ruby logo) and *download.gif* (an image that links to
    a download of Ruby).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将下载指定URL中找到的所有链接。我已经抓取了[http://www.ruby-lang.org/](http://www.ruby-lang.org/)，并抓取了两张图片，*logo.gif*（一个Ruby标志）和*download.gif*（一个链接到Ruby下载的图片）。
- en: How It Works
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: For the task of extracting images from a website, the first step is to retrieve
    the website where the images are located. Using the open-uri method `open`, the
    web page source code is conveniently saved into our variable `source` ![](../Images/00002.jpg).
    As you recall from your HTML coding days, images are embedded into web documents
    using `<img src=`*`foo.jpg`*`>` tags. In the script, we've used a regular expression
    that analyzes each line of the source code and finds this specific tag ![](../Images/00003.jpg).
    From the results of the regular expression, the script can identify the location
    of any images found.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从网站提取图片的任务，第一步是检索图片所在的网站。使用open-uri方法`open`，网页源代码方便地保存到我们的变量`source`中！[](../Images/00002.jpg)。如您从HTML编码时代回忆的那样，图片是通过使用`<img
    src="foo.jpg">`标签嵌入到网页文档中的。在脚本中，我们使用了一个正则表达式，它分析源代码的每一行并找到这个特定的标签！[](../Images/00003.jpg)。从正则表达式的结果中，脚本可以识别到找到的任何图片的位置。
- en: Once we have the location of an image, we need to determine if the image was
    linked from another site or if it is located on the host site. Most HTML is coded
    with a slash in front of any images that are on the local web server; this is
    also known as an *absolute path*. The `name` variable holds the image path. If
    the image path is absolute, the script prepends the original URL to the image
    name in order to make the image's complete address. The absolute check happens
    when I create a new `Pathname` object and use the `absolute?` method ![](../Images/00004.jpg).
    Even though the path to the image may have changed, the image's local name will
    be the same stored in `copy` ![](../Images/00005.jpg).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了图片的位置，我们需要确定图片是从另一个网站链接过来的，还是位于主机网站上。大多数HTML代码在本地Web服务器上的图片前都有一个斜杠；这也被称为*绝对路径*。`name`变量持有图片路径。如果图片路径是绝对的，脚本会在图片名称前添加原始URL，以便生成图片的完整地址。当创建一个新的`Pathname`对象并使用`absolute?`方法时，会进行绝对性检查！[](../Images/00004.jpg)。即使图片的路径可能已经改变，图片的本地名称将与存储在`copy`中的相同！[](../Images/00005.jpg)。
- en: After an appropriate address for the image is created, the script leverages
    the open-uri virtual file handling to read in the contents of the image and output
    it to a file with the name stored in `copy` ![](../Images/00006.jpg). This process
    is repeated for every image found in a web document. The results are stored in
    the same directory from which the script is run.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建适当的图片地址后，脚本利用open-uri虚拟文件处理来读取图片的内容并将其输出到`copy`中存储的名称的文件。这个过程会重复应用于网页文档中找到的每一张图片。结果存储在运行脚本的同一目录中。
- en: Hacking the Script
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本破解
- en: You could use a pre-built HTML parser like mechanize, Hpricot, or Rubyful Soup.
    These may be even more accurate than the regular expression used above. You could
    also save the images in the same type of directory structure as they were found
    of the web server. There are lots of possibilities, but this script will get you
    started.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用预构建的HTML解析器，如mechanize、Hpricot或Rubyful Soup。这些可能比上面使用的正则表达式更准确。您还可以将图片保存为与在Web服务器上找到的相同类型的目录结构。有很多可能性，但这个脚本将帮助您开始。
- en: Scraper
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬虫
- en: Scraper
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爬虫
- en: scrape.rb
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: scrape.rb
- en: Scraping, in its most basic form, is the action of pulling data from another
    website through normal HTTP queries. The scraper script is a culmination of the
    previous scripts. It combines the prior techniques discussed in previous scripts
    into one large script with a few more features. This script allows for a one-stop
    shop in basic website scraping. This script is not a bot, because it requires
    user interaction for each scrape; but with a few minor tweaks, this script could
    be completely automated.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 爬取，在其最基本的形式中，是通过正常的HTTP查询从另一个网站拉取数据的行为。爬虫脚本是之前脚本的总结。它将之前脚本中讨论的先前技术结合到一个大型脚本中，并增加了几个更多功能。这个脚本为基本的网站爬取提供了一个一站式服务。这个脚本不是一个机器人，因为它需要用户对每个抓取进行交互；但通过一些小的调整，这个脚本可以完全自动化。
- en: The Code
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''rio''  require ''open-uri''  require ''uri''   unless ARGV[0] and
    ARGV[1]      puts "You must specify an operation and URL."      puts "USAGE: scrape.rb
    [page|images|links] <url to scrape>"      exit  end   ![](../Images/00002.jpg) case
    ARGV[0]   when "page" ![](../Images/00003.jpg)     rio(ARGV[1]) > rio("#{URI.parse(ARGV[1].strip).host}.html")
         exit ![](../Images/00004.jpg) when "images"      begin          open(url,
    "User-Agent" => "Mozilla/4.0 (compatible; MSIE 5.5; Windows  98)") do |source|
             source.each_line do |x|              if x =~ /<img src="(.+.[jpeg|gif])"\s+/
                     name = $1.split(''"'').first                   name = url + name
    if Pathname.new(name).absolute?                      copy = name.split(''/'').last
                                      File.open(copy, ''wb'') do |f|             
            f.write(open(name).read)                  end              end       
      end      end      rescue => e          puts "An error occurred, please try again."
             puts e      end      exit  when "links"      links = File.open("links.txt","w+b")
         begin ![](../Images/00005.jpg)         open(ARGV[1], "User-Agent" => "Mozilla/4.0
    (compatible; MSIE 5.5; Windows  98)") do |source| ![](../Images/00006.jpg)    
            links.puts URI.extract(source, [''http'', ''https''])         end     
    rescue => e          puts "An error occurred, please try again."          puts
    e      end      links.close      exit  else      puts "You entered an invalid
    instruction, please try again."      puts "USAGE: scrape.rb [page|images|links]
    <url to scrape>"      exit  end`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''rio''  require ''open-uri''  require ''uri''   unless ARGV[0] and
    ARGV[1]      puts "您必须指定一个操作和URL。"      puts "用法: scrape.rb [page|images|links]
    <要抓取的URL>"      exit  end   ![](../Images/00002.jpg) case ARGV[0]   when "page"
    ![](../Images/00003.jpg)     rio(ARGV[1]) > rio("#{URI.parse(ARGV[1].strip).host}.html")
         exit ![](../Images/00004.jpg) when "images"      begin          open(url,
    "User-Agent" => "Mozilla/4.0 (compatible; MSIE 5.5; Windows  98)") do |source|
             source.each_line do |x|              if x =~ /<img src="(.+.[jpeg|gif])"\s+/
                     name = $1.split(''"'').first                   name = url + name
    if Pathname.new(name).absolute?                      name = url + name.split(''/'').last
    if Pathname.new(name).absolute?                                   File.open(copy,
    ''wb'') do |f|                      f.write(open(name).read)                 
    end              end          end      end      rescue => e          puts "发生错误，请重试。"
             puts e      end      exit  when "links"      links = File.open("links.txt","w+b")
         begin ![](../Images/00005.jpg)         open(ARGV[1], "User-Agent" => "Mozilla/4.0
    (compatible; MSIE 5.5; Windows  98)") do |source| ![](../Images/00006.jpg)    
            links.puts URI.extract(source, [''http'', ''https''])         end     
    rescue => e          puts "发生错误，请重试。"          puts e      end      links.close
         exit  else      puts "您输入了无效的指令，请重试。"      puts "用法: scrape.rb [page|images|links]
    <要抓取的URL>"      exit  end`'
- en: Running the Code
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行此脚本：
- en: '``**`ruby scrape.rb [`***`page|images|links`***`]`** *`http://url_to_scrape.com/`*``'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby scrape.rb [`***`page|images|links`***`]`** *`http://url_to_scrape.com/`*``'
- en: The Results
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script's output will be different for each method chosen. You can see an
    example from the previous script.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据选择的方法，脚本的输出将不同。您可以从之前的脚本中看到一个示例。
- en: How It Works
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script has three options. You can scrape `links`, `images`, or an entire
    web `page`. A `case` statement is used to handle the different options ![](../Images/00002.jpg).
    You could have used an `if/else` statement, but the `case` statement is cleaner.
    If the page is selected, the `rio` command is used to copy the web page source
    code and save it to an HTML file on the local machine ![](../Images/00003.jpg).
    `rio` handles so many of the dirty details that this task can be accomplished
    in just one line!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本有三个选项。你可以抓取 `links`、`images` 或整个网页。使用 `case` 语句来处理不同的选项 ![图片](../Images/00002.jpg)。你也可以使用
    `if/else` 语句，但 `case` 语句更简洁。如果选择了页面，使用 `rio` 命令来复制网页源代码并将其保存到本地机器上的 HTML 文件中 ![图片](../Images/00003.jpg)。`rio`
    处理了许多脏活累活，使得这项任务可以只用一行代码完成！
- en: Next is the image scrape ![](../Images/00004.jpg). This section of the code
    is a copy of "#45 Image Scrape" on [How It Works](../Text/dummy_split_310.html#filepos605751),
    so I won't review the details. If you have any questions, you can refer to the
    previous script.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是图像抓取 ![图片](../Images/00004.jpg)。这段代码是 [工作原理](../Text/dummy_split_310.html#filepos605751)
    中的 "#45 图像抓取" 的副本，所以这里不会详细说明。如果你有任何问题，可以参考之前的脚本。
- en: The final `case` statement is to grab the links. Unlike other methods used,
    I've reinvented the wheel to show another method for extracting URLs. This link-scraping
    method uses the `open` method from open-uri to retrieve the source code ![](../Images/00005.jpg)
    and follows up with the `URI.extract` method, which hunts down HTTP or HTTPS links
    ![](../Images/00006.jpg). The results are saved into a text file called *links.txt*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 `case` 语句是用来获取链接的。与其他方法不同，我重新发明了轮子，展示了另一种提取 URL 的方法。这种链接抓取方法使用 `open-uri`
    的 `open` 方法来检索源代码 ![图片](../Images/00005.jpg) 并随后使用 `URI.extract` 方法，来追踪 HTTP 或
    HTTPS 链接 ![图片](../Images/00006.jpg)。结果被保存到一个名为 *links.txt* 的文本文件中。
- en: Encrypted Client
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密客户端
- en: Encrypted Client
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密客户端
- en: RSA_client.rb
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA_client.rb
- en: Three principles are commonly used when describing information technology and
    security. The three principles are confidentiality, integrity, and availability.
    Each of these security components affects how a user interacts with data. The
    following two scripts will integrate RSA encryption for confidentiality and a
    SHA1 hash for integrity. The data will then be transmitted over a network using
    a TCP connection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 描述信息技术和安全时，通常使用三个原则。这三个原则是保密性、完整性和可用性。这些安全组件中的每一个都会影响用户与数据交互的方式。以下两个脚本将集成 RSA
    加密以实现保密性，并使用 SHA1 哈希以实现完整性。然后，通过 TCP 连接在网络中传输数据。
- en: The Code
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''socket''  require ''digest/sha1''   begin      print "Starting
    client..." ![](../Images/00002.jpg)     client = TCPSocket.new(''localhost'',
    8887)       puts "connected!\n\n"  ![](../Images/00003.jpg)     temp = nil   
      5.times do          temp << client.gets      end      puts "Received public
    1024 RSA key!\n\n" ![](../Images/00004.jpg)     public_key = OpenSSL::PKey::RSA.new(temp)    
      msg = ''mpg123*"C:\Program Files\Windows Media Player\mplayer2.exe"*ruby.mp3''
    ![](../Images/00005.jpg)     sha1 = Digest::SHA1.hexdigest(msg)  ![](../Images/00006.jpg)  
      command = public_key.public_encrypt("#{sha1}*#{msg}")      print "Sending the
    command...."  ![](../Images/00007.jpg)     client.send(command,0)       puts "sent!"
     rescue => e      puts "Something terrible happened...."      puts e      retry
     end   client.close`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''socket''  require ''digest/sha1''   begin      print "Starting
    client..." ![图片](../Images/00002.jpg)     client = TCPSocket.new(''localhost'',
    8887)       puts "connected!\n\n" ![图片](../Images/00003.jpg)     temp = nil   
      5.times do          temp << client.gets      end      puts "Received public
    1024 RSA key!\n\n" ![图片](../Images/00004.jpg)     public_key = OpenSSL::PKey::RSA.new(temp)    
      msg = ''mpg123*"C:\Program Files\Windows Media Player\mplayer2.exe"*ruby.mp3''
    ![图片](../Images/00005.jpg)     sha1 = Digest::SHA1.hexdigest(msg) ![图片](../Images/00006.jpg)  
      command = public_key.public_encrypt("#{sha1}*#{msg}")      print "Sending the
    command...." ![图片](../Images/00007.jpg)     client.send(command,0)       puts
    "sent!"  rescue => e      puts "Something terrible happened...."      puts e   
      retry  end   client.close`'
- en: Running the Code
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令来执行此脚本：
- en: '``**`ruby RSA_client.rb`**``'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby RSA_client.rb`**``'
- en: The Results
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Below is the output from a successful connection and command issue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是成功连接和命令发送的输出。
- en: '`Starting client...connected!  Received public 1024 RSA key!  Sending the command...sent!`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Starting client...connected!  Received public 1024 RSA key!  Sending the command...sent!`'
- en: How It Works
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The client begins by opening a TCP connection to a specified IP address and
    port number ![](../Images/00002.jpg). If the connection is successful, *connected*
    is output to `$stdout`. Next, the client expects to receive a 1024-bit RSA public
    encryption key from the server. The key is stored in a variable called `temp`
    because it is really only a cryptic string object until it is converted into an
    OpenSSL RSA key object ![](../Images/00003.jpg). Once `public_key` is initialized
    and contains the public RSA key, the script confirms the key was received and
    is ready to encrypt data ![](../Images/00004.jpg).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端首先打开到指定 IP 地址和端口号的 TCP 连接 ![图片](../Images/00002.jpg)。如果连接成功，*connected* 将输出到
    `$stdout`。接下来，客户端期望从服务器接收一个 1024 位 RSA 公共加密密钥。这个密钥存储在一个名为 `temp` 的变量中，因为它实际上只是一个直到转换为
    OpenSSL RSA 密钥对象的神秘字符串对象 ![图片](../Images/00003.jpg)。一旦 `public_key` 初始化并包含公钥 RSA，脚本确认已收到密钥并准备加密数据
    ![图片](../Images/00004.jpg)。
- en: The script will send data that contains a music program, either mpg123 for Linux
    or mplayer2.exe, which is the classic Windows media player. In addition to the
    music program, a music file, *ruby.mp3*, is also sent. The file is already located
    on the server, so this will simply tell the server to play the song. Each portion
    of the command string is delimited by an asterisk (*). You can get as creative
    as you want with this command, or even the data in general, as it will all be
    encrypted and sent to the server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将发送包含音乐程序的数据，无论是 Linux 的 mpg123 还是经典的 Windows 媒体播放器 mplayer2.exe。除了音乐程序外，还会发送一个音乐文件
    *ruby.mp3*。该文件已经位于服务器上，所以这只会告诉服务器播放这首歌。每个命令字符串的部分由一个星号 (*) 分隔。你可以对这个命令，甚至是一般的数据，发挥无限的创意，因为所有这些都会被加密并发送到服务器。
- en: Data encryption is the next step. The command string described above is stored
    in a variable called `msg` and will be encrypted with the server's public RSA
    key. Before we encrypt the data, the script will run the message through a SHA1
    hash and store the resulting hash in `sha1` ![](../Images/00005.jpg). This hash
    will be used after transmission on the server side. Remember that hash functions
    are one way, so if the data is tampered with during transmission, the before and
    after hash values won't be the same.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密是下一步。上述命令字符串存储在一个名为 `msg` 的变量中，并将使用服务器的公钥 RSA 进行加密。在我们加密数据之前，脚本将消息通过 SHA1
    哈希处理，并将生成的哈希存储在 `sha1` ![图片](../Images/00005.jpg)。这个哈希将在服务器端传输后使用。记住，哈希函数是单向的，所以如果数据在传输过程中被篡改，前后哈希值将不会相同。
- en: Next, the value in `sha1` and `msg` are concatenated with a splat in between.
    The result is encrypted using the RSA key method `public_encrypt` ![](../Images/00006.jpg).
    As you might have guessed, the method encrypts the data using a public RSA key.
    Only the corresponding private RSA key can be used to decrypt the message.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `sha1` 和 `msg` 中的值通过一个星号连接起来。结果使用 RSA 密钥的 `public_encrypt` 方法加密 ![图片](../Images/00006.jpg)。正如你可能猜到的，该方法使用公钥
    RSA 加密数据。只有相应的私钥 RSA 可以用来解密消息。
- en: Finally, the encrypted message is sent to the server, and the connection is
    closed ![](../Images/00007.jpg). If anything goes wrong during the encryption
    or transmission phases of the script, our trusty `begin/rescue` block is there
    to save the day. If all goes well, the server will pop open an awesome tune about
    Ruby! Can life get any better than listening to songs about Ruby?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加密后的消息被发送到服务器，并且连接被关闭 ![图片](../Images/00007.jpg)。如果在脚本加密或传输阶段出现任何问题，我们可靠的
    `begin/rescue` 块将拯救这一天。如果一切顺利，服务器将播放一首关于 Ruby 的精彩曲目！生活还能比听关于 Ruby 的歌曲更美好吗？
- en: Encrypted Server
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密服务器
- en: Encrypted Server
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密服务器
- en: RSA_server.rb
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RSA_server.rb
- en: Now that you have seen the client and all of its magic, it's time to analyze
    the server. The server receives the data, checks that the SHA1 hash is valid,
    decrypts the data, and, finally, executes the command string based on the payload
    transmitted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了客户端及其所有魔法，是时候分析服务器了。服务器接收数据，检查 SHA1 哈希是否有效，解密数据，并根据传输的负载执行命令字符串。
- en: The Code
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`` require ''socket''  require ''digest/sha1''  ![](../Images/00002.jpg) priv_key
    = OpenSSL::PKey::RSA.new(1024)  pub_key = priv_key.public_key   host = ARGV[0]
    || ''localhost''  port = (ARGV[1] || 8887).to_i  ![](../Images/00003.jpg) server
    = TCPServer.new(host, port)  ![](../Images/00004.jpg) while session = server.accept
         begin          puts "Connection made...sending public key.\n\n"         
    puts pub_key ![](../Images/00005.jpg)         session.print pub_key          puts
    "Public key sent, waiting on data...\n\n"  ![](../Images/00006.jpg)         temp
    = session.recv(10000)          puts "Received data..."  ![](../Images/00007.jpg)  
          msg = priv_key.private_decrypt(temp)      rescue => e          puts "Something
    terrible happened while receiving and decrypting."          puts e      end  ![](../Images/00008.jpg)  
      command = msg.split("*")       serv_hash = command[0]      nix_app = command[1]
         win_app = command[2]      file = command[3]  ![](../Images/00009.jpg)   
      if Digest::SHA1.hexdigest("#{nix_app}*#{win_app}*#{file}")==serv_hash       
      puts "Message integrity confirmed..." ![](../Images/00011.jpg)         if RUBY_PLATFORM.include?(''mswin32'')
                 puts "Executing windows command: #{win_app} #{file}"             
    `#{win_app} #{file}`              exit ![](../Images/00012.jpg)         else   
              puts "Executing Linux command: #{nix_app} #{file}"              `#{nix_app}
    #{file}`              exit          end      else          puts "The message could
    not be validated!"      end      exit  end``'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`` require ''socket''  require ''digest/sha1''  ![图片](../Images/00002.jpg) priv_key
    = OpenSSL::PKey::RSA.new(1024)  pub_key = priv_key.public_key   host = ARGV[0]
    || ''localhost''  port = (ARGV[1] || 8887).to_i  ![图片](../Images/00003.jpg) server
    = TCPServer.new(host, port)  ![图片](../Images/00004.jpg) while session = server.accept
         begin          puts "建立连接...发送公钥。\n\n"          puts pub_key ![图片](../Images/00005.jpg)  
          session.print pub_key          puts "公钥已发送，等待数据...\n\n"  ![图片](../Images/00006.jpg)  
          temp = session.recv(10000)          puts "接收数据..."  ![图片](../Images/00007.jpg)  
          msg = priv_key.private_decrypt(temp)      rescue => e          puts "在接收和解密过程中发生了可怕的事情。"
             puts e      end  ![图片](../Images/00008.jpg)     command = msg.split("*")      
    serv_hash = command[0]       nix_app = command[1]       win_app = command[2]      
    file = command[3]  ![图片](../Images/00009.jpg)     if Digest::SHA1.hexdigest("#{nix_app}*#{win_app}*#{file}")
    == serv_hash       puts "消息完整性已确认..." ![图片](../Images/00011.jpg)         if RUBY_PLATFORM.include?(''mswin32'')        
    puts "执行Windows命令: #{win_app} #{file}"         `#{win_app} #{file}`         exit
    ![图片](../Images/00012.jpg)         else         puts "执行Linux命令: #{nix_app} #{file}"        
    `#{nix_app} #{file}`         exit       end       else         puts "消息无法验证！"      
    end       exit   end``'
- en: Running the Code
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键入以下命令执行此脚本：
- en: '``**`ruby RSA_server.rb`**``'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby RSA_server.rb`**``'
- en: The Results
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Below is the output from a successful connection and command issue.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是成功连接和命令执行的输出。
- en: '`Connection made...sending public key.  -----BEGIN RSA PUBLIC KEY----- MIGJAoGBAMe12IJIyVULS/OLlHeekhZNyh2YhuGfJSwEozw2Z6GfaRjZg7s0cwqb
    B/Z+MMUPIjCmiH38pkKzh5GhA8zcRSWEFtssa8HcyIowA5ftZM27/6diYz9kNueI NO2kvlkqwU5KUOKnLISJnrZAlTbJMqio24dn3PNm27kgae8+KdrHAgMBAAE=
    -----END RSA PUBLIC KEY----- Public key sent, waiting on data...  Received data...
    Message integrity confirmed... Executing windows command: "C:\Program Files\Windows
    Media Player\mplayer2.exe" ruby.mp3`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`建立连接...发送公钥。  -----BEGIN RSA PUBLIC KEY----- MIGJAoGBAMe12IJIyVULS/OLlHeekhZNyh2YhuGfJSwEozw2Z6GfaRjZg7s0cwqb
    B/Z+MMUPIjCmiH38pkKzh5GhA8zcRSWEFtssa8HcyIowA5ftZM27/6diYz9kNueI NO2kvlkqwU5KUOKnLISJnrZAlTbJMqio24dn3PNm27kgae8+KdrHAgMBAAE=
    -----END RSA PUBLIC KEY----- 公钥已发送，等待数据...  接收数据... 消息完整性已确认... 执行Windows命令: "C:\Program
    Files\Windows Media Player\mplayer2.exe" ruby.mp3`'
- en: How It Works
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The script first generates a unique, private RSA key ![](../Images/00002.jpg).
    From the private key, a public RSA key is also generated using the RSA key method
    `public_key`. Every time this script is run, a new key pair is created. If someone
    sends data encrypted with an old public key, the script won't be able to decrypt
    the message.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先生成一个唯一的、私有的RSA密钥 ![图片](../Images/00002.jpg)。从私钥中，使用RSA密钥方法 `public_key`
    生成一个公钥RSA密钥。每次运行此脚本时，都会创建一个新的密钥对。如果有人使用旧的公钥加密数据发送，脚本将无法解密消息。
- en: After the RSA keys have been created, a TCP server is initialized ![](../Images/00003.jpg).
    The server can be run with command-line arguments for the host and port, or it
    can use the default values provided. After the server is created, it begins listening
    for incoming connections. A `while` loop is used to regulate the various sessions
    in the script ![](../Images/00004.jpg). Because the script is not multithreaded,
    only one connection at a time is allowed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建RSA密钥之后，初始化TCP服务器 ![图片](../Images/00003.jpg)。服务器可以通过命令行参数运行主机和端口，或者它可以使用提供的默认值。服务器创建后，它开始监听传入的连接。脚本中使用`while`循环来管理各种会话
    ![图片](../Images/00004.jpg)。由于脚本不是多线程的，一次只允许一个连接。
- en: When the client is executed, it connects to the server. This connection starts
    a new session, and the first action is to respond with the server's public RSA
    key ![](../Images/00005.jpg). The RSA key is small, so it happens quickly. The
    script then waits for data to be sent by the client. While it waits, the client
    receives the public RSA key and encrypts the message to be sent. The `temp` variable
    captures any data received by the server's TCP connection, up to 10,000 bytes
    ![](../Images/00006.jpg). Only after data is received will the script proceed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端执行时，它会连接到服务器。这种连接启动了一个新的会话，第一个动作是响应服务器的公共RSA密钥！[](../Images/00005.jpg)。RSA密钥很小，所以这个过程很快。脚本随后等待客户端发送数据。在等待期间，客户端接收公共RSA密钥并加密要发送的消息。`temp`变量捕获服务器TCP连接接收到的任何数据，最多10,000字节！[](../Images/00006.jpg)。只有接收到数据后，脚本才会继续执行。
- en: Using the RSA `private_decrypt` method, the value located in `temp` is decrypted
    and stored in `msg` ![](../Images/00007.jpg). If any errors occur during the receipt
    and decryption of the command string, our `rescue` clause will catch the error
    and output some useful information that will help us troubleshoot the issue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA `private_decrypt`方法，位于`temp`中的值被解密并存储在`msg`中！[](../Images/00007.jpg)。如果在接收和解密命令字符串的过程中发生任何错误，我们的`rescue`子句将捕获错误并输出一些有用的信息，这将帮助我们调试问题。
- en: If you recall from "#47 Encrypted Client" on [How It Works](../Text/dummy_split_324.html#filepos624901),
    the command string was delimited by asterisks (*). So, to get the command string
    into the pieces we need, the `split` method is used with a splat as the break
    point in the string `msg` ![](../Images/00008.jpg). The results are saved to `command`,
    which is an array of strings. Since we built the string in the client script,
    we know what the order will be. First is the SHA1 hash; next, the Linux application,
    followed by the windows application; and, finally, the file to be used.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得从[如何工作](../Text/dummy_split_324.html#filepos624901)中的“#47 加密客户端”，命令字符串是以星号
    (*) 为分隔符的。因此，为了将命令字符串分割成我们需要的部分，我们使用`split`方法，并在字符串`msg`中以展开符作为分隔点！[](../Images/00008.jpg)。结果被保存到`command`中，它是一个字符串数组。由于我们在客户端脚本中构建了字符串，我们知道顺序将会是什么。首先是SHA1哈希值；接下来是Linux应用程序，然后是Windows应用程序；最后是将要使用的文件。
- en: A SHA1 hash is created using the Linux application string, Windows application
    string, and filename ![](../Images/00009.jpg). Asterisks are added in between
    each of the strings to recreate the original hashed string. The results of this
    hash are then compared against `serv_hash`, which contains the SHA1 hash sent
    by the client. If the values are not equal, then something must have happened
    to the data during transmission. The data can no longer be trusted, so the program
    exits. Hopefully, the values will match up so the script can continue.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux应用程序字符串、Windows应用程序字符串和文件名创建SHA1哈希！[](../Images/00009.jpg)。在每个字符串之间添加星号以重新创建原始的哈希字符串。然后，将这个哈希的结果与包含客户端发送的SHA1哈希的`serv_hash`进行比较。如果值不相等，那么在传输过程中数据可能发生了某些变化。数据不再可信，程序将退出。希望这些值会匹配，这样脚本就可以继续执行。
- en: If the message integrity has been confirmed, then the last decision is to pick
    which application to run. Ruby provides an easy way of determining the platform
    being used. You simply ask it using `RUBY_PLATFORM`. The result for a Windows
    machine is `i386-mswin32`. Using the handy `include?` method, the script checks
    to see if the string returned by `RUBY_PLATFORM` contains `mswin32` ![](../Images/00011.jpg).
    If this statement is `true`, the Windows command is executed. If not, then the
    Linux application is executed ![](../Images/00012.jpg). Either way, if everything
    else works out, the music application should launch and begin playing *ruby.mp3*.
    The script exits after the music application has been terminated. So, that's how
    to covertly communicate while maintaining your data integrity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确认了消息的完整性，那么最后的决定就是选择运行哪个应用程序。Ruby提供了一个简单的方法来确定正在使用的平台。您只需使用`RUBY_PLATFORM`来询问它。对于Windows机器的结果是`i386-mswin32`。使用方便的`include?`方法，脚本检查`RUBY_PLATFORM`返回的字符串是否包含`mswin32`！[](../Images/00011.jpg)。如果这个语句是`true`，则执行Windows命令。如果不是，则执行Linux应用程序！[](../Images/00012.jpg)。无论如何，如果其他一切都正常，音乐应用程序应该启动并开始播放*ruby.mp3*。脚本在音乐应用程序终止后退出。所以，这就是在保持数据完整性的同时秘密通信的方法。
