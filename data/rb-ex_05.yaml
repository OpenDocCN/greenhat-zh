- en: Chapter 5. Number Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章. 数字工具
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: 'Numbers are fundamental for all computers and programming languages, and Ruby
    is no exception. In this chapter’s scripts, we’ll deal with useful data that is
    primarily numeric but is otherwise quite diverse. We’ll explore some pure math,
    following up with recursion, which I introduced in [Chapter 4](ch04.html "Chapter 4. Text
    Manipulation"). We’ll also do some type conversion, whereby numbers will be represented
    in different ways that are convenient for human users. We’ll also do some unit
    conversion, specifically monetary units.^([[12](#ftn.CHP-5-FNOTE-1)]) While doing
    all of this, we’ll also delve further into metaprogramming, Hashes, using external
    libraries, and two distinct formats for data storage in external files: XML (eXtensible
    Markup Language) and YAML (YAML Ain’t Markup Language). That’s a lot of ground
    to cover, so let’s get started.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数字对于所有计算机和编程语言都是基本的，Ruby 也不例外。在本章的脚本中，我们将处理主要是数字但其他方面相当多样化的有用数据。我们将探索一些纯数学，接着是我在第四章中介绍的递归。我们还将进行一些类型转换，其中数字将以对人类用户方便的不同方式表示。我们还将进行一些单位转换，特别是货币单位.^([[12](#ftn.CHP-5-FNOTE-1)])
    在做所有这些的同时，我们还将进一步深入研究元编程、哈希、使用外部库以及在外部文件中存储数据的两种不同格式：XML（可扩展标记语言）和 YAML（YAML 不是标记语言）。这需要覆盖很多内容，所以让我们开始吧。
- en: '#15 Computing Powers (power_of.rb)'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#15 计算幂次（power_of.rb）'
- en: 'This is the most purely mathematical of this chapter’s scripts, and it deals
    with exponentiation. Before we get too far into the script itself, let’s use irb
    to explore how Ruby handles exponentiation:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章脚本中最纯粹数学的一个，它处理幂次运算。在我们深入脚本本身之前，让我们使用 irb 来探索 Ruby 如何处理幂次运算：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the way to express “to the power of” in Ruby is with the double
    asterisk. Since both the number raised to some power and the power itself are
    expressions, they can also be more complex, like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在 Ruby 中表达“的幂”的方式是使用双星号。由于被提升到某个幂次的数和幂本身都是表达式，它们也可以更复杂，如下所示：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can raise a number (called the *base*) to a given exponent easily with the
    `**` operator. As you can see in line four in the above code, when you want to
    reverse a traditional exponentiation, you can use a reciprocal power.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `**` 操作符轻松地将一个数（称为*基数*）提升到给定的指数。如您在上面的代码第四行所见，当您想要反转传统的幂次运算时，您可以使用倒数幂。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We use floating-point numbers for the exponent in ❶, because we don’t want
    our expression to be rounded down to zero*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在指数中使用浮点数，因为我们不希望我们的表达式被四舍五入到零*。'
- en: If you have the base and the exponent, you can find the missing result. If you
    have the result of the exponentiation and the exponent, you can undo your operation
    to find the base by using the reciprocal of the exponent. What if you know the
    base and the result, and want to find the exponent? That’s what this script is
    for. Let’s take a look.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有基数和指数，您可以找到缺失的结果。如果您有幂次运算的结果和指数，您可以通过使用指数的倒数来撤销您的操作以找到基数。如果您知道基数和结果，但想找到指数呢？这正是这个脚本的目的。让我们看看。
- en: The Code
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How It Works
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We want this operation to be a method that can be called on any Integer, so
    we take advantage of Ruby’s open classes and simply add a new method. We have
    the standard boilerplate and RDoc up to the method definition at ❶, which shows
    that it takes an argument called `base`. The lines up to and including ❷ cause
    our `power_of` method to exit early under conditions that are not appropriate
    for it to do its job. We return the `nil` value when asked to find a power in
    relation to a `base` that isn’t even an Integer, because that question is meaningless.
    We also return `nil` when the `base` is zero and the result is neither zero nor
    one, because zero raised to any power will always be either zero or one, making
    that question also meaningless.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个操作是一个可以被任何整数调用的方法，所以我们利用 Ruby 的开放类，简单地添加了一个新方法。我们有了标准模板和 RDoc，直到方法定义的
    ❶，它显示该方法接受一个名为 `base` 的参数。直到包括 ❷ 的行导致我们的 `power_of` 方法在不适合作业的情况下提前退出。当我们被要求在一个甚至不是整数的
    `base` 上找到幂时，我们返回 `nil` 值，因为这个问题是没有意义的。当 `base` 为零且结果既不是零也不是一时，我们也返回 `nil`，因为零的任何幂次都将始终是零或一，使这个问题同样没有意义。
- en: There will certainly be other situations where our response is meaningful. We
    return `1` at ❸ if the `base` and the result of the exponentiation (`self`) are
    the same value, because any number to the power of one will be itself. We return
    `0` at ❹ if `self` is one, because any number raised to the zero power will equal
    one. This is confusing for many people. How can something multiplied by itself
    zero times be anything?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然会有其他情况下我们的响应是有意义的。当底数和指数的运算结果（`self`）相同值时，我们在❸处返回`1`，因为任何数的幂为一是它本身。如果`self`是`1`，我们在❹处返回`0`，因为任何数的零次幂等于一。这对许多人来说很困惑。为什么一个自身乘零次的数可以是任何东西呢？
- en: 'The answer lies in what’s called the *multiplicative identity*, which is how
    mathematicians describe the fact that any number times one equals one times that
    number as well as that number itself. You can always assume with any standard
    multiplication that there could be any number of “times one” additions to your
    multiplication, and it won’t matter. We can also see this in irb:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于所谓的**乘法恒等性**，这是数学家描述任何数乘以一等于一乘以那个数以及那个数本身的实际情况。在任何标准的乘法中，你都可以假设你的乘法中可以有任意数量的“乘以一”的加法，而且这不会产生影响。我们也可以在irb中看到这一点：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since you can always assume a “times one” for anything multiplied by itself
    twice, or by itself once, you can similarly assume it for something multiplied
    by itself zero times, which is all raising something to the zero power means.
    Therefore, raising something to the zero power will result in a value of one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可以假设任何东西乘以自身两次或一次的“乘以一”，你可以类似地假设乘以自身零次的情况，这就是所有提升到零次幂的含义。因此，提升到零次幂将得到一个值为`1`的结果。
- en: At ❺, we return `false` if the base is one. This is because one can never be
    raised to a power that will result in a value other than one. How do we know that
    our result isn’t one? Because we would have already returned a zero at ❹ if `self`
    was one. At ❻, we also return `false` if the absolute value of the `base` (acquired
    through calling `base.abs`) is greater than the absolute value of `self`. We do
    this because you can’t raise a `base` to an Integer power and get a result with
    a smaller absolute value than your original `base`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在❺处，如果底数是`1`，我们返回`false`。这是因为`1`永远不能被提升到产生除了`1`之外值的幂。我们如何知道我们的结果不是`1`呢？因为如果`self`是`1`，我们已经在❹处返回了一个零。在❻处，如果底数的绝对值（通过调用`base.abs`获得）大于`self`的绝对值，我们也返回`false`。我们这样做是因为你不能将一个`base`提升到整数幂并得到一个绝对值小于原始`base`的结果。
- en: Everything from ❶ to ❻ deals with the odd cases—either meaningless situations
    or situations that let us know we’re finished, otherwise known as *exit conditions*.
    What happens next? If a given number is a power of a given `base`, it means that
    that number divided by the `base` is also a power of the `base`, but the exponent
    will be one lower. Let’s demonstrate in irb.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从❶到❻的所有内容都处理了奇数情况——要么是无意义的情境，要么是让我们知道我们已经完成的情况，通常称为**退出条件**。接下来会发生什么？如果一个给定的数是给定`base`的幂，这意味着这个数除以`base`也是`base`的幂，但指数会低一个。让我们在irb中演示。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Three to the third power is 27, three to the second power is nine, and 27 is
    equal to nine times three. If we’re trying to find an exponent and none of our
    base cases apply, we can simply divide `self` by the `base`, try to get the power
    of the new divided value relative to the same `base`, and remember to add one
    to our new result if it turns out to be an Integer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`3`的`3`次幂是`27`，`3`的`2`次幂是`9`，而`27`等于`9`乘以`3`。如果我们试图找到一个指数，并且我们的基本情况都不适用，我们可以简单地除以`self`和`base`，尝试得到新的除法值相对于相同`base`的幂，如果结果是整数，记得将我们的新结果加一。'
- en: That’s exactly what we do at ❼ and ❽. We define a new variable called `exponent`,
    which is the result of calling the `power_of` method on `self` divided by `base`.
    The `exponent` variable will either be `nil, false`, or an Integer. How do we
    know this? Because we return either `nil` up to ❷, `false` at ❺ or ❻, or an Integer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在❷和❽处所做的事情。我们定义了一个新的变量，称为`exponent`，它是`self`除以`base`调用`power_of`方法的结果。`exponent`变量将是`nil`、`false`或一个整数。我们如何知道这一点？因为我们返回了`nil`直到❷，❺或❻处的`false`，或者一个整数。
- en: 'All Integers have true Boolean values, so we can test with our standard ternary
    operator, as we do at ❽. If `exponent` evaluates to `true`, it’s an Integer (because
    both `nil` and `false` would evaluate to `false` in the Boolean ternary operation).
    We therefore `return` it, remembering to add one, because we’ve already divided
    by the `base` once. If `exponent` evaluates to `false`, we want to simply `return`
    that value: either `false` or `nil`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有整数都有真实的布尔值，因此我们可以使用我们的标准三元运算符进行测试，就像我们在❽中做的那样。如果`exponent`评估为`true`，则它是一个整数（因为`nil`和`false`在布尔三元运算中都会评估为`false`）。因此，我们`return`它，并记住加一，因为我们已经除以了`base`一次。如果`exponent`评估为`false`，我们只想简单地`return`那个值：要么是`false`，要么是`nil`。
- en: What happens in our new call to `power_of` on `self` divided by the `base` at
    ❼? It goes through all the same tests from ❶ to ❻, and if none of those apply,
    it divides the new value of `self` by the `base` again, remembering to add yet
    another one to the eventual result. All of this happens inside each iteration
    of the `power_of` method—the first version of it up at the top level doesn’t need
    to know or care about how many other iterations of `power_of` end up being called.
    This is what recursion is all about.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 ❽ 调用`power_of`方法时，对`self`除以`base`发生了什么？它通过了从❶到❻的所有相同测试，如果没有一个适用，它将再次将新的`self`值除以`base`，并记住将另一个加到最终结果中。所有这些都在`power_of`方法的每个迭代中发生——最顶层的第一个版本不需要知道或关心有多少其他`power_of`迭代最终被调用。这正是递归的全部意义。
- en: Running the Script
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: You can try out this script in irb by requiring it at the command line with
    `irb -r power_of.rb` or by entering `require ‘power_of.rb’` once you’re in irb.
    Remember that this script can only handle Integers, so `2.power_of(4)` will return
    `false`, rather than `0.5`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 irb 中尝试这个脚本，通过在命令行中使用`irb -r power_of.rb`或进入 irb 后输入`require 'power_of.rb'`。记住，这个脚本只能处理整数，所以`2.power_of(4)`将返回`false`，而不是`0.5`。
- en: The Results
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Here is a sample irb session with some output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个带有一些输出的示例 irb 会话。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '* * *'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[12](#CHP-5-FNOTE-1)]) We’ll make a temperature converter in [Chapter 7](ch07.html
    "Chapter 7. Using, Optimizing, and Testing Functional Techniques"), since it depends
    on concepts we haven’t covered yet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[12](#CHP-5-FNOTE-1)]) 我们将在第 7 章（[第 7 章. 使用、优化和测试函数技术](ch07.html "第 7 章.
    使用、优化和测试函数技术")）中创建一个温度转换器，因为它依赖于我们尚未涉及的概念。
- en: '#16 Adding Commas to Numbers (commify.rb)'
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#16 向数字添加逗号（commify.rb）'
- en: A standard way of formatting numbers is to present them with commas (or some
    other delimiter) separating each group of thousands. Our next script does that
    by adding a method called `commify` to all numbers. You might think that we could
    do this by opening the Integer class and adding a new method to it, as we did
    in `power_of.rb`. This is certainly a reasonable approach, except that we may
    want to use `commify` on floating-point numbers as well. What’s the solution?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种标准的数字格式化方式是将它们以逗号（或某些其他分隔符）分隔成每组千位。我们的下一个脚本通过向所有数字添加一个名为`commify`的方法来实现这一点。你可能会认为我们可以通过打开
    Integer 类并添加一个新方法来实现这一点，就像我们在`power_of.rb`中做的那样。这当然是一个合理的做法，但我们可能还想在浮点数上使用`commify`。解决方案是什么？
- en: Inheritance
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: The answer deals with an object-oriented concept called *inheritance*. We discussed
    this earlier in [Chapter 3](ch03.html "Chapter 3. Programmer Utilities") when
    we added methods to the Object class. Inheritance is what allows all other classes
    to use methods of the Object class, because these other classes *inherit* from
    Object. Inheritance is a factor in our `commify` script as well. Let’s examine
    the inheritance hierarchy of some number classes in irb.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 答案涉及到一个面向对象的概念，称为*继承*。我们之前在第 3 章（[第 3 章. 程序员工具](ch03.html "第 3 章. 程序员工具")）中讨论过这个概念，当时我们向
    Object 类添加了方法。继承允许所有其他类使用 Object 类的方法，因为这些其他类*继承*自 Object。继承也是我们`commify`脚本中的一个因素。让我们在
    irb 中检查一些数字类的继承层次结构。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve used a method called `ancestors` that can be called not on an instance
    of a class, but on the class itself. It returns an Array of all of the ancestors
    of the class on which it is called (by *ancestors* I simply mean the classes from
    which it inherits). You may find it useful to consider inheritance through a biological
    metaphor, in which each class is a species and the ancestor classes are that species’
    ancestor species. We can see that both the Integer class and the Float class inherit
    directly from something called *Precision*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个名为`ancestors`的方法，它不仅可以在类的实例上调用，还可以在类本身上调用。它返回一个数组，包含调用该方法的类的所有祖先（在这里，我简单地说祖先是指从它们那里继承的类）。你可能发现将继承比作生物学隐喻很有用，其中每个类都是一个物种，祖先类是该物种的祖先物种。我们可以看到Integer类和Float类都直接继承自称为*Precision*的东西。
- en: Precision must be a class—some kind of number, right? Not exactly. Let’s continue
    in irb.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Precision必须是一个类——某种类型的数字，对吗？并不完全是这样。让我们在irb中继续。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We see that Integer is a *class*, something that can be instantiated. So is
    Float. That’s no surprise. 5 is an Integer, and 3.14 is a Float. But Precision
    is something called a Module, not a Class at all. What are Modules for?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Integer是一个*类*，可以被实例化。Float也是如此。这并不奇怪。5是一个Integer，3.14是一个Float。但Precision是一种称为Module的东西，根本不是类。模块是用来做什么的？
- en: Modules
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Let’s continue with our biological metaphor. Both humans and bats are mammals,
    so if we called `Human.ancestors` and `Bat.ancestors`, we would have significant
    overlap—humans and bats have shared ancestors, specifically earlier mammals. If
    we called `Bird.ancestors`, there would be less overlap with either of the others,
    because birds are not mammals. However, bats and most birds can fly, which you
    could think of as a method, in object-oriented terms. We could define `Bat.fly`
    and `Bird.fly` separately, but there is another option available to us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用生物学隐喻。人类和蝙蝠都是哺乳动物，所以如果我们调用`Human.ancestors`和`Bat.ancestors`，我们会发现有很大的重叠——人类和蝙蝠有共同的祖先，特别是早期的哺乳动物。如果我们调用`Bird.ancestors`，与另外两个的重叠就会少一些，因为鸟类不是哺乳动物。然而，蝙蝠和大多数鸟类都能飞，这在面向对象术语中可以被视为一种方法。我们可以分别定义`Bat.fly`和`Bird.fly`，但还有一种可供我们选择的方法。
- en: We can thus define the ability to fly (along with related characteristics and
    behaviors) and add that ability to existing classes. That process is called *mixing
    in*, and it’s how Ruby deals with the problem of assigning the same methods to
    different classes with distinct ancestor classes, like our Bat and Bird example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义飞行的能力（以及相关的特性和行为），并将其添加到现有的类中。这个过程被称为*混合进*，这也是Ruby处理将相同的方法分配给具有不同祖先类的不同类的问题（如我们的蝙蝠和鸟类示例）的方式。
- en: We do this by defining the ability to fly as a module, perhaps called Flyable.
    Modules are similar to classes, except that they don’t get instantiated. We’ll
    write our own modules later in [Chapter 10](ch10.html "Chapter 10. More Complex
    Utilities and Tricks, Part II"). For now, keep in mind that the Precision module
    adds behavior to both Integer and Float, just like our hypothetical Flyable. Flyable
    grants the ability to fly to those organisms it’s mixed into, and Precision grants
    the ability to do precise calculations to those numbers it’s mixed into.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将飞行的能力定义为模块，可能称为Flyable，来实现这一点。模块类似于类，但它们不会被实例化。我们将在[第10章](ch10.html "第10章。更复杂的工具和技巧，第二部分")中稍后编写自己的模块。现在，请记住，Precision模块为Integer和Float添加了行为，就像我们的假设Flyable一样。Flyable赋予混合进来的生物以飞行的能力，而Precision赋予混合进来的数字以精确计算的能力。
- en: Modules are open, just like classes, so we can add new behavior to the Precision
    module, just as we did earlier to the Object class. Let’s take a look at the `commify.rb`
    script.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是开放的，就像类一样，因此我们可以向Precision模块添加新的行为，就像我们之前向Object类添加行为一样。让我们看看`commify.rb`脚本。
- en: The Code
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How It Works
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Starting at ❶, we define some useful constants, just like we do for a class.
    Each definition is preceded by some comments explaining what the constant is for.
    I mentioned that the `commify` method will insert commas at every grouping of
    a thousand. This is customary in the United States, but many other countries use
    a period in place of a comma and use a comma to separate units from floating-point
    portions (for which the United States uses a period). These constants are preset
    for the US notation that is useful for me, since I live here, but you can easily
    customize them to match what’s appropriate for your home country.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从❶开始，我们定义了一些有用的常量，就像我们为类做的那样。每个定义都由一些注释说明常量的用途。我提到 `commify` 方法将在每千位分组处插入逗号。这在美国是惯例，但许多其他国家使用句点代替逗号，并使用逗号来分隔整数部分和小数部分（美国使用句点）。这些常量预设为对我有用的美国表示法，因为我住在这里，但你可以轻松地自定义它们以匹配你家乡国家的适当表示法。
- en: After some RDoc that explains the input parameters in the form of a single Hash,
    at ❷ we get to the definition of the `commify` method, our only public method.
    It accepts a Hash argument called `args` to override the default configuration
    constants, as shown at ❸. Note that the `||=` operation means that if `args` asks
    for an override (meaning it has a value in itself for the appropriate Symbol,
    such as `:delimiter` for the delimiter), we use what’s in `args`. Otherwise, we
    fall back to the Module’s appropriate constant. At ❹, we split the Integer and
    Float portions of `self`, although keep in mind that they are both instances of
    the String class, despite the fact that they represent numbers. Ruby allows us
    to assign into two different variable names at a time, as we do here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在❷处，在以单个哈希表形式解释输入参数的 RDoc 之后，我们得到了 `commify` 方法的定义，这是我们的唯一公共方法。它接受一个名为 `args`
    的哈希表参数来覆盖默认配置常量，如❸所示。请注意，`||=` 操作符意味着如果 `args` 请求覆盖（意味着它本身具有适当符号的值，例如 `:delimiter`
    用于分隔符），我们将使用 `args` 中的内容。否则，我们将回退到模块的适当常量。在❹处，我们拆分了 `self` 的整数和浮点部分，尽管要注意它们都是字符串类的实例，尽管它们代表数字。Ruby
    允许我们同时将值赋给两个不同的变量名，就像我们在这里做的那样。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Symbols make great Hash keys, and that’s a convention you’ll see a great deal
    in both my scripts and in the whole Ruby community. You’d have a terrible time
    trying to do anything in Rails without respecting this convention. Symbols work
    particularly well for this job because they can be used as names or labels for
    things, and they take up an extremely small amount of memory*.^([[13](#ftn.CHP-5-FNOTE-2)])'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号是出色的哈希键，这是你将在我的脚本和整个 Ruby 社区中看到的一个约定。如果你不尊重这个约定，在 Rails 中做任何事情都会很困难。符号非常适合这项工作，因为它们可以用作事物的名称或标签，并且它们占用极小的内存*^([[13](#ftn.CHP-5-FNOTE-2)]）'
- en: We then define a variable called `int_out` and give it the value of a method
    called `format_int`. We do the same for `float_out`, and finally `return` the
    concatenation of those two Strings at ❺. You can see that the real work occurs
    within the formatting methods (`format_int` and `format_float`), both of which
    are `private`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个名为 `int_out` 的变量，并给它赋值为名为 `format_int` 的方法。我们对 `float_out` 也做了同样的事情，最后在❺处返回这两个字符串的连接。你可以看到实际的工作发生在格式化方法（`format_int`
    和 `format_float`）中，这两个方法都是私有的。
- en: The format_int Method
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化整数方法
- en: The `format_int` method at ❻ is the more conceptually complicated of the two
    methods. Let’s open irb again and step through this method’s operations. First,
    let’s define some variables representing the inputs to the method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在❻处的 `format_int` 方法是两个方法中概念上更复杂的一个。让我们再次打开 irb 并逐步执行这个方法的操作。首先，让我们定义一些代表方法输入的变量。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, let’s split our String at the appropriate breakpoints, using a regular
    expression representing any group of digits that is the appropriate length. The
    notation `{x}` within a regular expression means *X instances of whatever is to
    the left*, so `a{3}` means *Three instances of the letter* a. We also use string
    interpolation so that we can use our `breakpoint` argument for the number of digits
    to break on. We want to go from right to left, so we’ll use the `reverse` method
    prior to breaking up the String into an Array.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用表示适当长度的数字组的正则表达式在适当的断点处拆分我们的字符串。正则表达式中的 `{x}` 表示“左边的任何内容重复 X 次”，所以
    `a{3}` 表示“字母 a 的三个实例”。我们还使用字符串插值，以便可以使用我们的 `breakpoint` 参数来指定要拆分的数字数量。我们希望从右向左进行，因此我们将在将字符串拆分成数组之前使用
    `reverse` 方法。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then we want to extract only those Array members that are genuine number groups,
    which we can do easily enough with another regular expression `/\d+/` (meaning
    *Consisting of one or more digits and nothing else*) and the `grep` method, which
    finds all members of an Array that match the regex argument that `grep` takes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要提取那些真正的数字组 Array 成员，这可以通过另一个正则表达式 `/\d+/`（意味着*由一个或多个数字组成，没有其他内容*）和 `grep`
    方法轻松完成，`grep` 方法找到与 `grep` 传入的 regex 参数匹配的 Array 的所有成员。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What else is wrong with our content at this point? Not only are the number groups
    in the wrong order, but the numbers within each group are also reversed. This
    is because we reversed the entire String before doing our `split`. Now we want
    to get everything in the right order. We can just `reverse` our Array, right?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的内容还有什么问题？不仅数字组顺序错误，而且每个组内的数字也是颠倒的。这是因为我们在 `split` 之前反转了整个 String。现在我们想要把一切都按正确的顺序排列。我们只需
    `reverse` 我们的 Array，对吧？
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This won’t work. It puts the groups in the right order, but the digits within
    each group are still reversed. We can use the `map` method to reverse each member
    of the Array instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会起作用。它将组按正确的顺序排列，但每个组内的数字仍然是颠倒的。我们可以使用 `map` 方法来反转 Array 的每个成员。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Oops. Now the digits within each set of three numbers are in the right order,
    but the groups are in the wrong order. We could define yet another variable like
    `reversed_digits` in a two-step operation, but why not take advantage of Ruby’s
    ability to chain methods?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。现在每组三个数字内的数字顺序是正确的，但组顺序是错误的。我们可以在两步操作中定义另一个变量，比如 `reversed_digits`，但为什么不用
    Ruby 的链式方法能力呢？
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now our digits groups are in the right order and have the correct internal ordering,
    as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的数字组已经按正确的顺序排列，并且内部顺序也正确。
- en: Note that the two different calls to the `reverse` method in the irb example
    are completely different. One is a call to the Array method `reverse` on `reversed_digits`
    and the other is a call to the String method `reverse` on each digit group that
    we call `unit` within the `map` operation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 irb 示例中对 `reverse` 方法的两次不同调用是完全不同的。一次是对 `reversed_digits` 的 Array 方法 `reverse`
    的调用，另一次是对我们称为 `unit` 的每个数字组的 String 方法 `reverse` 的调用。
- en: We still have an Array, and we want a String. This calls for a `join`, using
    the delimiter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个 Array，我们想要一个 String。这需要使用分隔符进行 `join`。
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `format_int` method now returns a String that is an altered version of our
    `int_as_string` argument. We break up `int_as_string` at the right point (`breakpoint`),
    insert the `delimiter` between our groups of digits, and make sure that everything
    stays in the right order. That’s it for the integer component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的 `format_int` 方法返回一个 String，它是我们的 `int_as_string` 参数的修改版本。我们在正确的位置（`breakpoint`）将
    `int_as_string` 分割，在数字组之间插入 `delimiter`，并确保一切保持正确的顺序。这就是整数部分的全部内容。
- en: The format_float Method
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式化浮点数的方法
- en: We also want to be able to format floating-point portions of numbers, which
    we do with the `format_float` method at ❼. If there is no floating-point portion,
    it returns an empty String right away. Otherwise, it creates a new variable called
    `output` consisting of the `decimal_pt` argument concatenated with the `float_as_string`
    argument—remember that they’re both Strings, so the plus sign means concatenation.
    If the configuration options are such that the hundredths place is not mandatory
    (you can tell from the `show_hundredths` argument), we can simply `return` the
    `output` variable at ❽. If we need to show the hundredths place and the floating-point
    portion is only a single character wide, we need to concatenate the String `‘0’`
    onto the end of the output at ❾. Otherwise, we can simply `return` the `output`
    variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够格式化数字的小数部分，这可以通过在 ❼ 处的 `format_float` 方法来完成。如果没有小数部分，它立即返回一个空 String。否则，它创建一个新的变量
    `output`，由 `decimal_pt` 参数与 `float_as_string` 参数连接而成——记住它们都是 String，所以加号表示连接。如果配置选项使得百分位不是强制性的（你可以从
    `show_hundredths` 参数中看出），我们可以在 ❽ 处简单地 `return` `output` 变量。如果我们需要显示百分位，并且小数部分只有一个字符宽，我们需要在输出的末尾连接
    String `‘0’` 在 ❾ 处。否则，我们只需简单地 `return` `output` 变量。
- en: Type Testing
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型测试
- en: You’ll remember that in `power.rb`, we had an early exit condition based on
    whether or not the `base` argument was an Integer at all. You’ll also notice that
    in this script we don’t test any of the numbers to find out whether or not they’re
    real numbers. Why is that? The reason is that our new methods will be included
    in the Precision module, which is only mixed in to classes that represent some
    sort of number, like Integer and Float. Therefore, checks for numeric type are
    not necessary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得在 `power.rb` 中，我们有一个基于 `base` 参数是否为整数的早期退出条件。你也会注意到在这个脚本中，我们没有测试任何数字来确定它们是否为实数。为什么是这样？原因是我们的新方法将被包含在
    Precision 模块中，该模块只混合到表示某种数字的类中，如 Integer 和 Float。因此，检查数字类型是不必要的。
- en: Running the Script
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s try this out with a test script. Here are the contents of `tests/test_commify.rb`,
    which we’ll run in the same directory as `commify.rb` with the command `ruby -w
    tests/test_commify.rb 186282.437` at the shell.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个测试脚本来试试。以下是 `tests/test_commify.rb` 的内容，我们将在与 `commify.rb` 相同的目录下运行它，使用命令
    `ruby -w tests/test_commify.rb 186282.437` 在 shell 中运行。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We call the `commify` method on the first argument after the script name, which
    in our case is the floating-point number `186282.437`. First, we call it with
    the default parameters with regard to the delimeter character, breakpoint size,
    and so on. Then we call it with some modified configuration parameters, just to
    see how they work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本名称之后的第一个参数上调用 `commify` 方法，在我们的例子中是浮点数 `186282.437`。首先，我们使用默认参数（关于分隔符字符、断点大小等）调用它。然后我们使用一些修改后的配置参数调用它，只是为了看看它们是如何工作的。
- en: The Results
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s the output I got:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的输出结果：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Yours should look the same. That’s it for this script.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应该看起来一样。这就是这个脚本的全部内容。
- en: '* * *'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[13](#CHP-5-FNOTE-2)]) My technical reviewer, Pat Eyler, wisely asked me
    to stress that the *reason* Symbols take up so little space is because each Symbol
    only takes up space once, and all subsequent instances merely refer to that same
    memory space again, instead of duplicating it, as would happen with a String or
    other type of object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[13](#CHP-5-FNOTE-2)]) 我的技术审稿人 Pat Eyler 聪明地要求我强调，符号占用这么少的空间的原因是每个符号只占用一次空间，所有后续实例只是再次引用相同的内存空间，而不是像字符串或其他类型的对象那样重复它。
- en: '#17 Roman Numerals (roman_numeral.rb)'
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#17 罗马数字 (roman_numeral.rb)'
- en: In the previous script, you learned how to change the representation of a number
    as a String so that it had commas (or some other desired delimiting character)
    in appropriate places for easier readability. One of the most traditional ways
    to represent a number as a String is as a Roman numeral. This script adds a new
    method to all Integers called `to_roman`. Let’s see it in action in irb.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的脚本中，你学习了如何将数字表示为字符串，以便在适当的位置添加逗号（或某些其他所需的分隔字符），以便更容易阅读。将数字表示为字符串的最传统方式之一是作为罗马数字。这个脚本为所有整数添加了一个名为
    `to_roman` 的新方法。让我们在 irb 中看看它的实际效果。
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you remember your Roman numerals, you will see that `to_roman` follows your
    expectations. It returns the empty string for zero and uses the *subtractive*
    approach of reporting four as *IV*, using a lower-value letter to the left of
    a higher-value letter to indicate subtraction. Let’s look at the source code to
    see how it works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得罗马数字，你会看到 `to_roman` 符合你的预期。它对零返回空字符串，并使用 *减法* 方法报告四为 *IV*，使用比左侧字母值低的字母来表示减法。让我们看看源代码，看看它是如何工作的。
- en: The Code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How It Works
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Since we only need to give Integers the ability to report their Roman numeral
    representation, we’ll open up the Integer class and give it this new method. After
    defining some constants at ❶, let’s skip down to ❷, where we define the public
    method `to_roman` that we’ve seen used in irb. In it, we define something called
    `@@roman_of`, and use the `||=` operator to set its value to that of the output
    of a method called `create_roman_of`, unless `@@roman_of` already evaluates to
    `true`. Why does it have two `@` signs at the front? We’ve already seen instance
    variables with a single `@` sign and constants that must begin with an uppercase
    letter (and traditionally are entirely uppercase), but this is something new called
    a *class variable*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要让整数有报告其罗马数字表示的能力，我们将打开整数类并给它这个新方法。在定义了一些常量❶之后，让我们跳到❷，在那里我们定义了公共方法`to_roman`，我们已经在irb中看到过它的使用。在其中，我们定义了一个叫做`@@roman_of`的东西，并使用`||=`运算符将其值设置为名为`create_roman_of`的方法的输出值，除非`@@roman_of`已经评估为`true`。为什么它前面有两个`@`符号？我们已经看到了带有单个`@`符号的实例变量和必须以大写字母开头（并且传统上全部大写）的常量，但这是新的一种叫做*类变量*的东西。
- en: Class Variables
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类变量
- en: Class variables are shared among every instance of a class but are able to change
    value. Let’s verify in irb that several different instances of any given class
    variable have the same value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量在类的每个实例之间共享，但能够改变值。让我们在irb中验证任何给定类变量的几个不同实例具有相同的值。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define a new class variable called `@@class_var` for all Strings and also
    give all strings a new method called `cv` that returns `@@class_var`. We find
    that it has the same value for all Strings, including Strings that did not yet
    exist when we defined `@@class_var`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有字符串定义了一个新的类变量`@@class_var`，并为所有字符串提供了一个名为`cv`的新方法，该方法返回`@@class_var`。我们发现它的值对所有字符串都相同，包括在我们定义`@@class_var`时还不存在的字符串。
- en: We have a class variable called `@@roman_of`. What is it? To answer that, we
    need to look inside the private method `create_roman_of` at ❽. It returns a constant
    called `ARABIC_TO_ROMAN`, unless some other constant called `SUBTRACTIVE` is true.
    We can see from our constant definition section (❶) that we have set `SUBTRACTIVE`
    to true, so `create_roman_of` will not return `ARABIC_TO_ROMAN` with our current
    configuration settings. Instead, it will return the result of calling the method
    `merge` on `ARABIC_TO_ROMAN`, with `SUBTRACTIVE_TO_ROMAN` as its single argument.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`@@roman_of`的类变量。它是什么？为了回答这个问题，我们需要查看私有的`create_roman_of`方法❽。它返回一个名为`ARABIC_TO_ROMAN`的常量，除非另一个名为`SUBTRACTIVE`的常量是`true`。我们可以从我们的常量定义部分❶中看到，我们已经将`SUBTRACTIVE`设置为`true`，所以`create_roman_of`不会返回`ARABIC_TO_ROMAN`，使用我们当前的配置设置。相反，它将返回调用`merge`方法的结果，其中`SUBTRACTIVE_TO_ROMAN`是其单个参数。
- en: Hash.merge
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hash.merge
- en: At this point we need to learn what `ARABIC_TO_ROMAN` is so we know what happens
    when `merge` is called on it. We can see from ❶ that both `ARABIC_TO_ROMAN` and
    `SUBTRACTIVE_TO_ROMAN` are Hashes. Their keys are Arabic numerals, and each key’s
    value is the representation of the key as a Roman numeral. This script can only
    represent Roman numerals up to 4,999, so we could simply define a single Hash
    of `ALL_ARABICS_TO_ROMAN` with a key for every value from one to 4,999 and be
    done with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要了解`ARABIC_TO_ROMAN`是什么，这样我们才知道当`merge`被调用时会发生什么。我们可以从❶中看到，`ARABIC_TO_ROMAN`和`SUBTRACTIVE_TO_ROMAN`都是Hash。它们的键是阿拉伯数字，每个键的值是键的罗马数字表示。这个脚本只能表示到4,999的罗马数字，所以我们可以简单地定义一个包含从一到4,999每个值的`ALL_ARABICS_TO_ROMAN`的单一Hash，然后完成它。
- en: That would work, but it would be terribly inelegant. What we’ve done instead
    is define base cases from which we will extrapolate all cases between zero and
    4,999\. We also separate out cases of subtractive representation (such as IV for
    four) into a separate Hash, allowing us to easily turn that feature on or off,
    as we do with the `SUBTRACTIVE` constant and the `create_roman_of` method, which
    uses the `merge` method of Hashes. This `merge` method allows a Hash to incorporate
    the information from a second Hash into itself. Let’s explore that in irb.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那会起作用，但会很糟糕。我们实际上做的是定义了一些基础情况，我们将从中推断出0到4,999之间的所有情况。我们还把减法表示的情况（如IV表示四）分离到一个单独的Hash中，这样我们就可以轻松地打开或关闭这个功能，就像我们使用`SUBTRACTIVE`常量和使用`merge`方法的`create_roman_of`方法一样。这个`merge`方法允许一个Hash将其信息合并到另一个Hash中。让我们在irb中探索一下。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see not only that `merge` combines key/value pairs, but also that the
    incoming information (meaning the Hash argument to the `merge` method) overrides
    pre-existing pairs in the calling Hash. That’s why the `“key1”=>nil` pair from
    `hash3` overrides the `”key1“=>“value1”` pair from `hash1`. You’ll also note that
    the returned value of the `merge` method is itself just another Hash, so we can
    call any Hash method on it, including `merge` again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`merge`不仅结合了键值对，而且传入的信息（即`merge`方法的哈希参数）覆盖了调用哈希表中的现有对。这就是为什么`hash3`中的`“key1”=>nil`对覆盖了`hash1`中的`”key1“=>“value1”`对。你还会注意到`merge`方法的返回值本身也是一个哈希表，因此我们可以对其调用任何哈希方法，包括再次调用`merge`。
- en: So the first time we call the `to_roman` method (❷), we create a class variable
    called `@@roman_of` that contains base cases for transliteration into Roman numerals.
    It either uses the subtractive approach or it doesn’t, depending on our configuration
    options. It includes subtractive representation by default. After all that, we
    `return` an empty String at ❸ unless the Integer (`self`) is greater than zero.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们第一次调用`to_roman`方法（❷）时，我们创建了一个名为`@@roman_of`的类变量，它包含将数字转换为罗马数字的基本情况。它要么使用减法方法，要么不使用，这取决于我们的配置选项。默认情况下，它包括减法表示。在所有这些之后，我们在❸处返回一个空字符串，除非整数（`self`）大于零。
- en: You may remember that I said this script can handle Roman numerals for Integers
    up to 4,999\. That’s where line ❹ and the `maximum_representable` method (defined
    at ❾) come in. The largest value that Roman numerals can represent (without introducing
    vertical bars above letters that are not strictly part of the standard Roman alphabet)
    is 4,999, so I decided to stop there. If the Integer in question (`self`) is greater
    than the maximum value that can be shown, we simply return the result of the `to_s`
    method (❹). Let’s see this in action in irb.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得我说过这个脚本可以处理整数到4,999的罗马数字。这就是第❹行和`maximum_representable`方法（定义在第❾行）的作用所在。罗马数字可以表示的最大值（不引入不在标准罗马字母严格部分之上的竖线）是4,999，所以我决定在那里停止。如果问题中的整数（`self`）大于可以显示的最大值，我们只需返回`to_s`方法的结果（❹）。让我们在irb中看看这个动作。
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we hit the upper limit, we still return a String representing a numeric
    value (which is all a Roman numeral is), we just use the familiar Arabic numeral
    symbols within our String.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到上限，我们仍然返回一个表示数值的字符串（罗马数字就是这样），我们只是在字符串中使用熟悉的阿拉伯数字符号。
- en: More Recursion
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多递归
- en: If the lines from ❷ through ❹ remind you of the exit conditions in `power_of.rb`
    that prepared for a recursive call to the same method, you’ve been paying attention.
    That’s exactly what we’re about to do here. At ❺ we create a variable called `base`
    that is the value of a long chain of method calls starting on the `@@roman_of`
    class variable. The purpose of these method calls is to find the largest key of
    the `@@roman_of` Hash that is less than or equal to the `self` Integer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第❷行到❹行的代码让你想起了`power_of.rb`中的退出条件，你一直在注意。这正是我们接下来要做的。在❺处，我们创建了一个名为`base`的变量，它是从`@@roman_of`类变量开始的一系列方法调用的值。这些方法调用的目的是找到小于或等于`self`整数的`@@roman_of`哈希表中的最大键。
- en: We get the keys out with the `keys` method, which returns an Array of the Hash’s
    keys. We then `sort` that Array in `reverse` order, meaning that we start from
    highest to lowest. We then call a new Array method called `detect` with the conditions
    of being less than or equal to `self`. I think a great alias for detect would
    be *find first*. Let’s see it in irb.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`keys`方法来获取哈希表的键，该方法返回一个包含哈希表键的数组。然后我们以`reverse`顺序对数组进行`sort`，这意味着我们从最高到最低开始。然后我们调用一个新的数组方法`detect`，并使用小于或等于`self`的条件。我认为`detect`的一个很好的别名是*find
    first*。让我们在irb中看看它。
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `detect` method cycles through each member of the Array and returns the
    first Array element that matches the conditions in the block. This is what allows
    us to find the highest value representable in terms of the `@@roman_of` Hash,
    which we put into the `base` variable at ❺. At ❻ we `return` the empty String,
    unless we both found a `base` and that `base` is greater than zero; without a
    `base` greater than zero, we can’t return anything useful.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`detect`方法遍历数组的每个成员，并返回第一个符合块中条件的数组元素。这使我们能够找到以`@@roman_of`哈希表表示的最高值，我们将它放入`base`变量中，位置❺。在❻处，我们`return`一个空字符串，除非我们找到了一个大于零的`base`；如果没有大于零的`base`，我们无法返回任何有用的信息。'
- en: Multiples of Our Base
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基数的倍数
- en: We now have a `base` that’s an Integer greater than zero. If we’re calling something
    like `1066.to_roman`, we have no problem, because our `base` value (1,000) is
    the entire thousands place portion of our Integer. But what if we want something
    like `2112.to_roman` instead? We need to be able to keep track of how many multiples
    of `base` can go into our Integer. That’s what we do at ❼.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个大于零的整数`base`。如果我们调用像`1066.to_roman`这样的方法，我们没有任何问题，因为我们的`base`值（1,000）是整数中的整个千位部分。但如果我们想调用像`2112.to_roman`这样的方法呢？我们需要能够跟踪`base`的多少倍可以进入我们的整数。这就是我们在❶处所做的工作。
- en: We use the method `round_to_base` (defined at ❿) to determine the number of
    multiples of `base` we need to deal with. Our call to `round_to_base` tells us
    how many multiples of `base` we need to handle. Calling `@@roman_of[base]` also
    finds the single letter used to represent the base.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`round_to_base`方法（在❺处定义）来确定我们需要处理多少个`base`的倍数。我们对`round_to_base`的调用告诉我们需要处理多少个`base`的倍数。调用`@@roman_of[base]`也会找到表示基数的单个字母。
- en: Multiplying Strings by Integers
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将字符串乘以整数
- en: 'Multiplying a String by an Integer results in that String concatenated with
    itself as many times as the Integer. Let’s see that in irb:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串乘以一个整数会导致该字符串根据整数重复连接自身。让我们在irb中看看这个例子：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is taken directly from our `2112.to_roman` example. The output of `“MM”`
    takes care of representing the 2,000 portion of 2,112, and at line ❼ we also make
    a recursive call to `to_roman`; this time, however, we call it on a smaller number,
    specifically 112\. Because the number on which we call the `to_roman` method keeps
    getting smaller as we pull off multiples of `base`, we will eventually reach a
    point where we’ll exit with the empty String at ❸, marking the end of all of our
    recursive calls to `to_roman`. That’s when we get our final output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接来自我们的`2112.to_roman`示例。`“MM”`的输出负责表示2112中的2,000部分，并且在❶行我们也对`to_roman`进行了递归调用；然而，这次我们调用的是一个更小的数字，具体来说是112。因为我们在移除`base`的倍数时，调用`to_roman`方法的数字会不断减小，我们最终会达到一个点，在❸处退出，标记所有递归调用`to_roman`的结束。那时我们将得到最终输出。
- en: Running the Script
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: This is easily demonstrated within irb.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这在irb中很容易演示。
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Results
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here is the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Hacking the Script
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: There are other options you could take with this script. Instead of making `SUBTRACTIVE`
    a class constant, we could have made the `to_roman` method take an argument. If
    you do that, you would need to keep track of two separate `[SOMETHING]_TO_ROMAN`
    Hashes, one using the subtractive display method, and one not using it. I decided
    to assume that the subtractive approach would be used because it does seem to
    be very common for Roman numerals. However, I thought I would mention how you
    could customize this script to make it slightly more complicated—but also more
    flexible.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，你还可以选择其他选项。我们不必将`SUBTRACTIVE`作为类常量，我们也可以让`to_roman`方法接受一个参数。如果你这样做，你需要跟踪两个不同的`[SOMETHING]_TO_ROMAN`哈希表，一个使用减法显示方法，另一个不使用。我决定假设将使用减法方法，因为这确实似乎在罗马数字中非常常见。然而，我想提到如何自定义这个脚本使其稍微复杂一些——但也更灵活。
- en: We’ll revisit the idea of representing Integers as different sorts of Strings
    later when we create the `to_lang` method. For now, let’s continue on to our first
    currency converter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`to_lang`方法时，我们将重新审视将整数表示为不同类型的字符串的想法。现在，让我们继续到我们的第一个货币转换器。
- en: '#18 Currency Conversion, Basic (currency_converter1.rb)'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#18 货币转换，基础（currency_converter1.rb）'
- en: I mentioned earlier that the `commify` method needs to vary based on how each
    country treats the notation of numbers. The area where this issue comes up most
    often is with currency, of course. The actual conversion process consists of relatively
    straightforward math, but we’ll use this script as a vehicle to set the stage
    for two important concepts introduced in our next script—notably the representation
    of data with either *XML* (eXtensible Markup Language, [http://www.w3c.org/xml](http://www.w3c.org/xml))
    or *YAML* (YAML Ain’t Markup Language, [http://www.yaml.org](http://www.yaml.org)).
    We’ll explore both XML and YAML further in the next script, but for now, let’s
    try out our current script in irb with `irb -r currency_converter.rb`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，`commify` 方法需要根据每个国家如何处理数字的表示方式而有所不同。这个问题最常出现的地方当然是货币。实际的转换过程包括相对直接的数学运算，但我们将使用这个脚本作为介绍我们下一脚本中引入的两个重要概念的载体——特别是使用
    *XML*（可扩展标记语言，[http://www.w3c.org/xml](http://www.w3c.org/xml)）或 *YAML*（YAML Ain’t
    Markup Language，[http://www.yaml.org](http://www.yaml.org)）来表示数据。我们将在下一脚本中进一步探索
    XML 和 YAML，但现在，让我们尝试使用 `irb -r currency_converter.rb` 在 irb 中运行我们的当前脚本。
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can see on our irb session’s first response that our `cc` instance seems
    to have some fondness for the US dollar—but if you’re in some other country, don’t
    worry, you’ll learn how to use different currencies in the improved version of
    the script. In ❶ you can see that our `cc` instance’s `output_rates` method takes
    an argument and seems to output the equivalent of that many US dollars in a few
    other currencies. You can see in ❷ that the values shift as expected with a different
    number of US dollars. Let’s see how this works by examining the source code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 irb 会话的第一个响应中，我们可以看到我们的 `cc` 实例似乎对美元情有独钟——但如果你在其他国家，请不要担心，你将在脚本的改进版本中学习如何使用不同的货币。在❶中，你可以看到我们的
    `cc` 实例的 `output_rates` 方法接受一个参数，并似乎以几种其他货币输出相当于那么多美元的金额。在❷中，你可以看到随着美元数量的不同，值按预期发生变化。让我们通过检查源代码来看看这是如何工作的。
- en: The Code
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How It Works
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: At ❶, we define the “home” currency of the class, and immediately following,
    we define some handy codes for various other currencies via the `FULLNAME_OF`
    and `EXCHANGE_RATES` Hashes. The `EXCHANGE_RATES` Hash contains our preset exchange
    rate values. These were current at the time I created this object, but I’m sure
    they’ll be at least slightly different by the time you read this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们定义了类的“家庭”货币，紧接着，我们通过 `FULLNAME_OF` 和 `EXCHANGE_RATES` 哈希表定义了一些其他货币的便捷代码。`EXCHANGE_RATES`
    哈希表包含我们的预设汇率值。这些值在我创建此对象时是有效的，但我相信在你阅读时至少会有所不同。
- en: The `initialize` method at ❷ gives us some handy instance variables related
    to the home currency, and our only public method `output_rates` (❸) is simply
    a wrapper for the private `get_value` method (❺) with a newline.^([[14](#ftn.CHP-5-FNOTE-3)])
    The `get_value` method also uses another private method called `get_rates`, the
    definition of which (❹) should be fairly clear to you at this point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在❷处的 `initialize` 方法为我们提供了一些与家庭货币相关的便捷实例变量，而我们唯一的公共方法 `output_rates`（❸）只是私有
    `get_value` 方法（❺）的一个包装器，并在其中添加了一个换行符.^([[14](#ftn.CHP-5-FNOTE-3)]) `get_value`
    方法还使用了一个名为 `get_rates` 的另一个私有方法，其定义（❹）在此点应该对你来说相当清晰。
- en: The `get_value` method also uses another private method called `pluralize` (❿),
    which returns a String in which the term for the currency is plural when appropriate.
    I’ve implemented this very simply, because English only requires an s at the end
    of a term to pluralize it. With a few changes, this method could handle other
    languages or terms with more complex pluralization needs, most likely a Hash with
    currency terms as keys and plural endings as values. For now, we just need to
    add an `s` to the end of currency amounts greater than one.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_value` 方法还使用了一个名为 `pluralize` 的另一个私有方法（❿），该方法在适当的情况下返回一个字符串，其中货币的术语是复数形式。我非常简单地实现了这个方法，因为英语只需要在术语的末尾加上一个
    s 来表示复数。通过一些修改，这个方法可以处理其他语言或具有更复杂复数需求术语，最有可能是一个以货币术语为键、复数结尾为值的哈希表。目前，我们只需要在大于一个的货币金额末尾添加一个
    `s`。'
- en: The `get_value` method returns (❻) a pluralized form of the base currency with
    an equals sign, followed by information about each of the currencies the class
    knows about. Starting at ❼, it maps an operation onto each currency type (represented
    by the keys of the `rates` Hash). The mapped operation (❽) is the outputting of
    a tab character, followed by properly pluralized output for that currency based
    on its relative value, full name, and abbreviation. Each currency’s String output
    is then joined together with newline characters at ❾, concluding the `return`
    statement begun back at ❻.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_value` 方法返回（❻）一个带有等号的复数形式的基准货币，后面跟着该类所知的每种货币的信息。从 ❼ 开始，它将一个操作映射到每种货币类型（由
    `rates` Hash 的键表示）。映射的操作（❽）是输出一个制表符，然后根据其相对价值、全名和缩写，输出该货币的正确复数形式。然后，每种货币的字符串输出在
    ❾ 处通过换行符连接起来，从而完成从 ❻ 处开始的 `return` 语句。'
- en: Running the Script
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: This is also easily demonstrated in irb with `irb -r currency_converter1.rb`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在 irb 中通过 `irb -r currency_converter1.rb` 来轻松演示。
- en: The Results
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how the prettier output comes from using `puts` and that the returned
    value from `output_rates` is `nil`, largely because it’s intended to print results
    instead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到更美观的输出是通过使用 `puts` 实现的，而且 `output_rates` 返回的值是 `nil`，这主要是因为它旨在打印结果。
- en: Hacking the Script
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: This is all fine when exchange rates are constant and can be stored in a constant
    Hash, as in this script. However, the main impetus of having a currency converter
    stems from the fact that exchange rates constantly change. We need a converter
    that can update itself with new information when that information becomes available
    and yet continue to work when such information is inaccessible, for whatever reason.
    That’s our next script.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当汇率保持恒定并可以存储在恒定的 Hash 中时，比如在这个脚本中，这一切都很正常。然而，货币转换器的主要动力来自于汇率不断变化的事实。我们需要一个转换器，当新信息可用时能够更新自己，同时在信息不可用的情况下（无论什么原因）仍然可以工作。这就是我们的下一个脚本。
- en: '* * *'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[14](#CHP-5-FNOTE-3)]) We defined `initialize` before the `private` keyword,
    but `initialize` is always a private method, so `output_rates` is the only public
    method of CurrencyConverter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[14](#CHP-5-FNOTE-3)]) 我们在 `private` 关键字之前定义了 `initialize`，但 `initialize`
    总是私有的方法，所以 `output_rates` 是 CurrencyConverter 的唯一公共方法。
- en: '#19 Currency Conversion, Advanced (currency_converter2.rb)'
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#19 货币转换，高级（currency_converter2.rb）'
- en: This script builds on what we already know from the previous one and uses a
    similar approach for the actual conversion process. What we’ve added is the ability
    to store and retrieve external data in both YAML and XML formats. YAML is so readable
    that I will simply tell you what you need to know for this script, and I’m sure
    that you’ll be inspired to learn more about how it works. XML is a bit more complicated,
    and it’s beyond the scope of this book to teach it to you if you’re not familiar
    with it, but you won’t need to be an expert to follow along. I’ll describe the
    relevant bits of XML for this script’s operation, just as I’ll do with YAML. If
    you find that the XML-related content of this chapter is going a bit too fast,
    please refer to the excellent online XML Tutorial at [http://www.w3schools.com/xml](http://www.w3schools.com/xml).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本基于我们从之前的脚本中学到的知识，并使用类似的方法进行实际的转换过程。我们增加的功能是能够以 YAML 和 XML 格式存储和检索外部数据。YAML
    的可读性如此之高，以至于我只需简单告诉你这个脚本你需要知道的内容，我相信你一定会被激发去了解更多关于它是如何工作的信息。XML 要复杂一些，如果你不熟悉它，本书的范围不包括教你
    XML，但你不需要成为专家就能理解。我会描述这个脚本操作中相关的 XML 部分，就像我会做 YAML 一样。如果你觉得这一章中关于 XML 的内容有点快，请参考优秀的在线
    XML 教程 [http://www.w3schools.com/xml](http://www.w3schools.com/xml)。
- en: This script differs from the previous in several ways. Let’s see how.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与之前的脚本在几个方面有所不同。让我们看看它是如何做到的。
- en: The Code
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How It Works
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'How does this file differ from the previous one? The class definition of CurrencyConverter
    is delayed until ❸, due to some more comments and `require` statements at ❶. I
    also open the Hash class and give it a subtraction method, identified by the minus
    sign at ❷. This new method takes another Hash and returns the original Hash without
    any pairs found in the argument Hash. Think of it this way: If `merge` is addition
    of Hashes, this method is the subtraction of Hashes. I suppose a good alternative
    name would be either `demerge` or `unmerge` .'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件与之前的文件有何不同？由于在❶处有一些额外的注释和`require`语句，CurrencyConverter类的定义被延迟到❸。我还打开了Hash类，并给它一个减法方法，由❷处的减号标识。这个新方法接受另一个Hash，并返回原始Hash，其中不包含在参数Hash中找到的任何配对。可以这样想：如果`merge`是Hash的加法，那么这个方法就是Hash的减法。我想一个更好的替代名称可能是`demerge`或`unmerge`。
- en: 'Inside our CurrencyConverter class (❸), we have two new constants: `BASE_URL`,
    which is used for downloading completely new exchange rates, and `RATES_DIRECTORY`,
    which is used to store exchange rates once they have been downloaded. The class’s
    `initialize` method accepts a currency `code`, so folks from other countries can
    define their own native converters more easily. (It assumes US dollars with no
    argument.) If it gets a currency `code` that it doesn’t understand, it shouldn’t
    proceed, so we make it break out of the entire program with the command `fail`,
    which causes the program to stop running. The `output_rates` method (❹) also tries
    to get new rates when told to, saves rates in a local file, and performs the operations
    we already know about from the last script.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CurrencyConverter类（❸）中，我们有两个新的常量：`BASE_URL`，用于下载全新的汇率，以及`RATES_DIRECTORY`，用于存储下载后的汇率。类的`initialize`方法接受一个货币`code`，这样来自其他国家的用户可以更容易地定义他们自己的本地转换器。（它假设没有参数时使用美元。）如果它收到一个它不理解的货币`code`，它不应该继续，所以我们使用`fail`命令使其跳出整个程序，这会导致程序停止运行。`output_rates`方法（❹）在需要时也会尝试获取新汇率，将汇率保存在本地文件中，并执行我们已从上一个脚本中了解到的操作。
- en: How does it get new rates? The `get_rates` method (❻) shows us that it either
    loads old rates or downloads new rates. If it tries to `download_new_rates` (❺)
    but fails to do so, it will fall back to its old rates again. It defaults to downloading
    new rates, so let’s look at `download_new_rates`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何获取新利率的？`get_rates` 方法（❻）显示它要么加载旧利率，要么下载新利率。如果它尝试`download_new_rates`（❺）但失败，它将再次回退到其旧利率。默认情况下，它会下载新利率，所以让我们看看`download_new_rates`。
- en: After some explanatory printing, we get a `begin` statement, which starts a
    block of code that means *Try something, and fall back to some other code if the
    attempt fails*. What we’re trying to do is call the `get_xml_lines` method. If
    that fails, we’ll explain to the user via `puts` that the download failed and
    return `nil`. The `end` statement tells us that the block of code pertaining to
    the `begin` has ended. The `return nil` is what allows us to fall back to old
    exchanges rates within `get_rates` if the `get_xml_lines` method failed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些解释性打印之后，我们得到一个`begin`语句，它启动一个代码块，表示*尝试做一些事情，如果尝试失败，则回退到其他代码*。我们试图调用`get_xml_lines`方法。如果失败，我们将通过`puts`向用户解释下载失败并返回`nil`。`end`语句告诉我们与`begin`相关的代码块已经结束。`return
    nil`允许我们在`get_xml_lines`方法失败时在`get_rates`中回退到旧汇率。
- en: So what does `get_xml_lines` do? It’s defined at ❼, and it finds all lines from
    a given XML file in which one unit of the base currency appears with an equals
    sign. These lines tell us our exchange rates. Let’s take a look at what one of
    those XML files looks like. Here are a few lines from a file I downloaded from
    [http://www.currencysource.com/RSS/USD.xml](http://www.currencysource.com/RSS/USD.xml).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`get_xml_lines`方法做什么？它在❷处定义，并找到所有在给定XML文件中，基本货币单位以等号出现的一行。这些行告诉我们我们的汇率。让我们看看这些XML文件中的一个样子。以下是我从[http://www.currencysource.com/RSS/USD.xml](http://www.currencysource.com/RSS/USD.xml)下载的文件中的几行。
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you’re not already familiar with XML, you can see here that it consists of
    text in which various content is enclosed by *tags*, which are those bits of text
    within the `<` and `>` characters. Newlines are not meaningful. We have two definitions
    of a type of thing called `item`, each of which has a title, a link, a description,
    and a pubDate. This is the content we’re searching through. You’ll notice that
    the `<title>` lines contain direct statements about exchange rates between the
    base currency and some other currency—in my example, the Argentinian peso and
    the Australian dollar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉 XML，你在这里可以看到它由文本组成，其中各种内容被 *标签* 包围，这些标签是 `<` 和 `>` 字符内的文本片段。换行符没有意义。我们有
    `item` 类型的两种定义，每种都有一个标题、一个链接、一个描述和一个 pubDate。这是我们正在搜索的内容。你会注意到 `<title>` 行包含关于基准货币与其他货币之间汇率直接陈述——在我的例子中，是阿根廷比索和澳大利亚元。
- en: The reason this operation might fail is that the file we’re trying to open and
    call `readlines` on is not a local file, but a file retrieved from the Internet
    via a URL. The `open-uri` library that we required at ❶ modifies the `open` command
    to allow us to open URLs as well as local files. Without a functioning Internet
    connection, the `open` will fail, meaning that there will be no file on which
    to call the `readlines` method within `get_xml_lines`. However, if our download
    operation worked, we’ll be able to assign content into the `raw_rate_lines` variable
    within `download_new_rates`. The rest of the `download_new_rates` method extracts
    the exchange rate content out of the raw lines.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作可能失败的原因是我们试图打开并对其调用 `readlines` 的文件不是一个本地文件，而是通过 URL 从互联网上检索的文件。我们在❶中要求的
    `open-uri` 库修改了 `open` 命令，使我们能够打开 URL 以及本地文件。如果没有正常工作的互联网连接，`open` 将会失败，这意味着在
    `get_xml_lines` 中将没有文件可以调用 `readlines` 方法。然而，如果我们的下载操作成功，我们将在 `download_new_rates`
    中将内容赋值给 `raw_rate_lines` 变量。`download_new_rates` 方法的其余部分从原始行中提取汇率内容。
- en: Downloading Rates Information
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载汇率信息
- en: The `download_new_rates` method extracts the exchange rate by first defining
    a variable for the `rates`, which is a Hash. We give `Hash.new` an argument halfway
    through `download_new_rates` so that when a given key is not found in the Hash,
    the returned value is no longer `nil`, but instead the argument that was passed
    to `Hash.new` (the empty String in our example). For our purposes, we want to
    find `comparison_codes`, which are all the pairs pertaining to currencies and
    their codes, without the `@base_currency`.^([[15](#ftn.CHP-5-FNOTE-4)]) We then
    cycle through each key, which is the abbreviation or code associated with the
    matching currency, and call the `get_rate_for_abbr_from_raw_rate_lines` method,
    which gets the exchange rate for a given abbreviation from the `raw_rate_lines`
    variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_new_rates` 方法首先定义一个名为 `rates` 的变量，它是一个哈希表。我们在 `download_new_rates`
    方法中给 `Hash.new` 传递一个参数，这样当在哈希表中找不到给定键时，返回的值就不再是 `nil`，而是传递给 `Hash.new` 的参数（在我们的例子中是空字符串）。就我们的目的而言，我们想要找到
    `comparison_codes`，这是所有与货币及其代码相关的成对信息，但不包括 `@base_currency`。^([[15](#ftn.CHP-5-FNOTE-4)])
    然后，我们遍历每个键，即与匹配货币相关的缩写或代码，并调用 `get_rate_for_abbr_from_raw_rate_lines` 方法，该方法从
    `raw_rate_lines` 变量中获取给定缩写的汇率。'
- en: The `get_rate_for_abbr_from_raw_rate_lines` method is defined immediately after
    the definition of `get_rates` at ❻. The `regex` variable is a Hash that stores
    some regular expressions that signify the opening and closing of the content we
    care about (the actual exchange rate value). We detect the first line containing
    the interpolated `abbr` value and then strip off the opening and closing `regex`
    values by substituting each of them with the empty string. We then `return` the
    floating-point version (via the `to_f` method) of what we have left. That’s the
    exchange rate for the currency matching the `abbr` argument.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_rate_for_abbr_from_raw_rate_lines` 方法定义在 `get_rates` 定义之后，即❻。`regex` 变量是一个哈希表，它存储了一些表示我们关心的内容（实际汇率值）的开头和结尾的正则表达式。我们检测包含插值
    `abbr` 值的第一行，然后通过将每个正则表达式替换为空字符串来去除开头和结尾的 `regex` 值。然后，我们通过 `to_f` 方法返回我们剩下的浮点版本。这就是与
    `abbr` 参数匹配的货币的汇率。'
- en: We’ve gotten our rates via downloading, which means that we’re ready to save
    them into a local file within `initialize`. We immediately exit `save_rates_in_local_file!`
    (❿) and do nothing if we have no rates. The reason for this is that if there is
    some problem with getting rates, we don’t want to overwrite our good stored data
    from a previous use of this script. Assuming that all is well, we open a new file
    for writing with the name `rates_filename`, which looks like a variable. It’s
    actually a method, defined at ❾. It returns something like `“extras/currency_exchange_rates/USD.yaml”`
    or `“extras/currency_exchange_rates/CAD.yaml”`, depending on what your base currency
    is. It’s a method because it’s entirely dependent on the value of `@base_currency`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过下载获得了我们的费率，这意味着我们可以在`initialize`函数中将它们保存到本地文件中。如果没有费率，我们立即退出`save_rates_in_local_file!`（❿）并且不进行任何操作。这样做的原因是，如果获取费率时出现问题，我们不希望覆盖我们之前使用此脚本时存储的良好数据。假设一切顺利，我们以`rates_filename`为名打开一个新文件进行写入，它看起来像是一个变量。实际上，它是一个方法，定义在❾处。它返回类似`“extras/currency_exchange_rates/USD.yaml”`或`“extras/currency_exchange_rates/CAD.yaml”`的内容，具体取决于你的基础货币。它是一个方法，因为它完全依赖于`@base_currency`的值。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Some schools of programming would have defined an instance variable *`@rates_filename`*
    within the *`initialize`* method, just as we did with *`@base_currency`* and *`@name`*.
    Conversely, we could have treated *`@name`* the same way we do *`rates_filename`*,
    defining a method called *`name`* that simply returns the value of *`CURRENCY_CODES[@base_currency]`*.
    Either approach is useful. Using an instance variable (the “eager” approach) is
    faster, but the different variables with a close relationship to each other could
    get out of sync, especially in a more complex program. Using a method (the “lazy”
    approach) is slower, because it has to recalculate its return value every time—but
    it also means that your variables won’t get out of agreement with each other,
    at least in this case*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些编程学校可能会在`initialize`方法中定义一个实例变量*`@rates_filename`*，就像我们为`@base_currency`和`@name`所做的那样。相反，我们也可以像对待`rates_filename`一样对待`@name`，定义一个名为`name`的方法，它简单地返回`CURRENCY_CODES[@base_currency]`的值。任何一种方法都是有用的。使用实例变量（“急切”方法）更快，但与彼此关系密切的不同变量可能会失去同步，尤其是在更复杂的程序中。使用方法（“懒惰”方法）较慢，因为它每次都必须重新计算其返回值——但这也意味着你的变量不会在这个案例中失去一致性*。'
- en: Whether it’s an instance variable or a method, our main concern regarding `rates_filename`
    is that it is a name of a file that can be written into. We do the writing using
    `YAML.dump`, which takes two arguments; the first is a data structure that will
    be converted into YAML and written into the second argument, which is a File object.
    Let’s open `extras/currency_exchange_rates/USD.yaml` and see what we’ve written.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是一个实例变量还是一个方法，我们对`rates_filename`的主要关注点是它是一个可以写入的文件名。我们使用`YAML.dump`进行写入，它接受两个参数；第一个是一个将被转换为YAML并写入第二个参数的数据结构，第二个参数是一个文件对象。让我们打开`extras/currency_exchange_rates/USD.yaml`并查看我们写了什么。
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That’s the entire content of `USD.yaml`. It represents a single Hash whose keys
    are currency codes and whose values are floating-point numbers. You’ll notice
    that newlines are significant, and while this example doesn’t show it, so is indentation.
    There’s a lot about YAML that you can learn at [http://www.yaml.org](http://www.yaml.org),
    but I find that `YAML.dump` is a great way to learn how things are represented
    in YAML. If you pass a data structure that you understand into `YAML.dump`, you
    can read the resulting. yaml file to see what the proper representation is. You
    can then change the data structure in some specific way, rewrite using `YAML.dump`,
    and compare the results. It’s very useful.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`USD.yaml`的全部内容。它代表一个单一的哈希表，其键是货币代码，值是浮点数。你会注意到换行符很重要，尽管这个例子没有显示，缩进也是如此。你可以在[http://www.yaml.org](http://www.yaml.org)上学习很多关于YAML的知识，但我发现`YAML.dump`是学习如何在YAML中表示事物的一个很好的方法。如果你将一个你理解的数据结构传递给`YAML.dump`，你可以阅读生成的.yaml文件以查看正确的表示形式。然后你可以以某种特定的方式更改数据结构，使用`YAML.dump`重新写入，并比较结果。这非常有用。
- en: In any case, we have now stored our exchange rate data as YAML in an external
    file, using `save_rates_in_local_file!`. We still have the `rates` variable available,
    so we use it, calling the `get_value` method, which uses the same approach as
    in the previous script.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们现在已经使用`save_rates_in_local_file!`将汇率数据以YAML格式存储在外部文件中。我们仍然可以使用`rates`变量，因此我们调用`get_value`方法，该方法与上一个脚本中的方法相同。
- en: What If You Can’t Download New Rates?
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果你无法下载新的费率怎么办？
- en: In a later call to the script, we might not be able to download new rates, as
    previously noted. Therefore, let’s look at the `get_rates` method again and assume
    that we either told the script not to download new rates (using a `false` value
    for the `try_new_rates` argument) or that the download attempt failed. Either
    way, we’ll need to get our rates from the stored YAML file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续对脚本的调用中，我们可能无法下载新的汇率，正如之前提到的。因此，让我们再次查看`get_rates`方法，并假设我们告诉脚本不要下载新的汇率（使用`try_new_rates`参数的`false`值）或者下载尝试失败。无论哪种情况，我们都需要从存储的YAML文件中获取汇率。
- en: 'The `load_old_rates` method is at ❽. It informs the user that there will be
    an attempt to read from the local file. Getting the real data out of a YAML file
    could hardly be easier: You just call `YAML.load`, and give it a File argument,
    which, in our case is the result of calling `File.open` on `rates_filename`. The
    result of `YAML.load` is whichever data structure was stored in the external file,
    so we simply assign it into a variable called `rates`. We then ensure that we
    were able to read data into `rates` before proceeding, and finally return `rates`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_old_rates`方法位于❽。它通知用户将尝试从本地文件读取。从YAML文件中获取实际数据几乎不可能更简单：你只需调用`YAML.load`，并给它一个文件参数，在我们的例子中是调用`File.open`在`rates_filename`上的结果。`YAML.load`的结果是存储在外部文件中的任何数据结构，所以我们将其分配给一个名为`rates`的变量。然后我们确保在继续之前能够将数据读入`rates`，最后返回`rates`。'
- en: Running the Script
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: After all this explanation, it’s finally time to see the script in action in
    irb with `irb -r currency_converter2.rb`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些解释之后，我们终于可以看到脚本在irb中的实际运行情况，使用`irb -r currency_converter2.rb`。
- en: The Results
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that we can easily define converters for specific currencies; then
    we can tell the `output_rates` method to try to download new rates or not to download
    them, depending on whether or not the optional second argument evaluates to `false`.
    In line ❶, you see that I’ve passed in `(not true)` just to make that point. You’ll
    also notice that the return values with special characters like newlines and tabs
    represent those characters the same way we do when we insert them, while printing
    those return values causes them to be interpreted, making the printing output
    prettier, or at least more easily readable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们可以轻松地为特定货币定义转换器；然后我们可以告诉`output_rates`方法尝试下载新汇率或不下载，这取决于可选的第二个参数是否评估为`false`。在❶行，你可以看到我传递了`(not
    true)`只是为了说明这一点。你也会注意到，带有特殊字符（如换行符和制表符）的返回值以与我们插入它们时相同的方式表示这些字符，而打印这些返回值会导致它们被解释，使得打印输出更美观，或者至少更容易阅读。
- en: Hacking the Script
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: This script depends on the directory hierarchy at `BASE_URL` staying the same.
    If it ever changes, you will need to update `get_xml_lines()` at ❼ accordingly.
    We’re also about to get deeper into some functional programming topics. Once you’re
    comfortable with `lambda` (introduced in the next chapter), you could replace
    the `rates_filename` method with a lambda that accepts `RATES_DIRECTORY` and `@base_currency`
    as arguments.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本依赖于`BASE_URL`目录层次结构的保持不变。如果它发生变化，你需要相应地更新❽处的`get_xml_lines()`。我们还将更深入地探讨一些函数式编程主题。一旦你熟悉了下一章中介绍的`lambda`，你可以用接受`RATES_DIRECTORY`和`@base_currency`作为参数的lambda替换`rates_filename`方法。
- en: '* * *'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[15](#CHP-5-FNOTE-4)]) We remove the `@base_currency` since it’s not useful
    to give the exchange rate between a given currency and itself—the rate would always
    be exactly one.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[15](#CHP-5-FNOTE-4)]) 我们移除了`@base_currency`，因为它在给出特定货币与其自身之间的汇率时没有用——汇率总是正好是一。
- en: Chapter Recap
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: What was new in this chapter?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有什么新内容？
- en: Exponentiation in Ruby
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby中的指数运算
- en: Returning `nil` when a method’s operation is not possible
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当方法操作不可行时返回`nil`
- en: More recursion and exit conditions
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多递归和退出条件
- en: Modules and Inheritance
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和继承
- en: '`Hash.merge`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hash.merge`'
- en: Class Variables
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类变量
- en: '`Array.detect` (“find first”)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.detect`（“找到第一个”）'
- en: Subtracting Hashes
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法哈希
- en: Exiting the entire script with `fail`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fail`退出整个脚本
- en: '`begin—rescue—end`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin—rescue—end`'
- en: Downloading with `open-uri`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`open-uri`下载
- en: Parsing XML files with regular expressions
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析XML文件
- en: Writing to YAML files with `YAML.dump`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`YAML.dump`写入YAML文件
- en: Reading from YAML files with `YAML.load`
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`YAML.load`从YAML文件中读取
- en: It’s almost as if this chapter weren’t really about numbers—we covered a large
    amount of generically useful information, especially Modules, Class Variables,
    and external data storage and retrieval using either XML or YAML (or both). We’ve
    done a bit of functional programming already in the last two chapters, but we’ll
    get into the deep lambda magic in [Chapter 6](ch06.html "Chapter 6. Functionalism
    with Blocks and Procs").
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就像是这一章根本不是关于数字的——我们涵盖了大量通用的有用信息，特别是模块、类变量以及使用XML或YAML（或两者兼用）进行的外部数据存储和检索。在前两章中，我们已经做了一些函数式编程，但我们将深入探讨第6章（[第6章](ch06.html
    "第6章。使用块和进程的函数式编程")）中的深度lambda魔法。
