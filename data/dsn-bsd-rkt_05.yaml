- en: Chapter 5. RUN-TIME KERNEL MEMORY PATCHING
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。运行时内核内存修补
- en: 'In the previous chapters we looked at the classic method of introducing code
    into a running kernel: through a loadable kernel module. In this chapter we''ll
    look at how to patch and augment a running kernel with userland code. This is
    accomplished by interacting with the /dev/kmem device, which allows us to read
    from and write to kernel virtual memory. In other words, /dev/kmem allows us to
    patch the various code bytes (loaded in executable memory space) that control
    the logic of the kernel. This is commonly referred to as *run-time kernel memory
    patching*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了将代码引入运行中内核的经典方法：通过可加载内核模块。在本章中，我们将探讨如何使用用户空间代码修补和增强运行中的内核。这是通过与 /dev/kmem
    设备交互来实现的，它允许我们从内核虚拟内存中读取和写入。换句话说，/dev/kmem 允许我们修补控制内核逻辑的各种代码字节（加载在可执行内存空间中）。这通常被称为
    *运行时内核内存修补*。
- en: Kernel Data Access Library
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核数据访问库
- en: The Kernel Data Access Library (libkvm) provides a uniform interface for accessing
    kernel virtual memory through the /dev/kmem device. The following six functions
    from libkvm form the basis of run-time kernel memory patching.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 内核数据访问库（libkvm）通过 /dev/kmem 设备提供了一个统一的接口，用于访问内核虚拟内存。以下来自 libkvm 的六个函数构成了运行时内核内存修补的基础。
- en: The kvm_openfiles Function
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_openfiles 函数
- en: Access to kernel virtual memory is initialized by calling the `kvm_openfiles`
    function. If `kvm_openfiles` is successful, a descriptor is returned to be used
    in all subsequent libkvm calls. If an error is encountered, `NULL` is returned
    instead.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `kvm_openfiles` 函数初始化对内核虚拟内存的访问。如果 `kvm_openfiles` 成功，则返回一个描述符，用于所有后续的
    libkvm 调用。如果遇到错误，则返回 `NULL`。
- en: 'Here is the function prototype for `kvm_openfiles`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `kvm_openfiles` 函数的原型：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following is a brief description of each parameter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对每个参数的简要描述。
- en: '**`execfile`**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**`execfile`**'
- en: This specifies the kernel image to be examined, which must contain a symbol
    table. If this parameter is set to `NULL`, the currently running kernel image
    is examined.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了要检查的内核映像，它必须包含符号表。如果此参数设置为 `NULL`，则检查当前运行的内核映像。
- en: '**`corefile`**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**`corefile`**'
- en: This is the kernel memory device file; it must be set to either /dev/mem or
    a crash dump core generated by `savecore(8)`. If this parameter is set to `NULL`,
    /dev/mem is used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核内存设备文件；它必须设置为 /dev/mem 或由 `savecore(8)` 生成的崩溃转储核心。如果此参数设置为 `NULL`，则使用 /dev/mem。
- en: '**`swapfile`**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**`swapfile`**'
- en: This parameter is currently unused; thus, it's always set to `NULL`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数目前未使用；因此，它始终设置为 `NULL`。
- en: '**`flags`**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**`flags`**'
- en: 'This parameter indicates the read/write access permissions for the core file.
    It must be set to one of the following constants:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数指示核心文件的读写访问权限。它必须设置为以下常量之一：
- en: '**`O_RDONLY`**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**`O_RDONLY`**'
- en: Open for reading only.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仅开放读权限。
- en: '**`O_WRONLY`**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**`O_WRONLY`**'
- en: Open for writing only.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅开放写权限。
- en: '**`O_RDWR`**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**`O_RDWR`**'
- en: Open for reading and writing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仅开放读写权限。
- en: '**`errbuf`**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**`errbuf`**'
- en: If `kvm_openfiles` encounters an error, an error message is written into this
    parameter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `kvm_openfiles` 遇到错误，则将错误消息写入此参数。
- en: The kvm_nlist Function
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_nlist 函数
- en: The `kvm_nlist` function retrieves the symbol table entries from a kernel image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`kvm_nlist` 函数从内核映像检索符号表条目。'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `nl` is a null-terminated array of `nlist` structures. To make proper
    use of `kvm_nlist`, you'll need to know two fields in `struct nlist`, specifically
    `n_name`, which is the name of a symbol loaded in memory, and `n_value`, which
    is the address of the symbol.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nl` 是 `nlist` 结构的空终止数组。为了正确使用 `kvm_nlist`，你需要了解 `struct nlist` 中的两个字段，特别是
    `n_name`，它是加载到内存中的符号的名称，以及 `n_value`，它是符号的地址。
- en: The `kvm_nlist` function iterates through `nl`, looking up each symbol in turn
    through the `n_name` field; if found, `n_value` is filled out appropriately. Otherwise,
    it is set to `0`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`kvm_nlist` 函数遍历 `nl`，通过 `n_name` 字段依次查找每个符号；如果找到，则适当地填充 `n_value`。否则，将其设置为
    `0`。'
- en: The kvm_geterr Function
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_geterr 函数
- en: The `kvm_geterr` function returns a string describing the most recent error
    condition on a kernel virtual memory descriptor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`kvm_geterr` 函数返回一个字符串，描述了内核虚拟内存描述符上最近发生的错误条件。'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The results are undefined if the most recent libkvm call did not produce an
    error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最近的 libkvm 调用没有产生错误，则结果未定义。
- en: The kvm_read Function
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_read 函数
- en: Data is read from kernel virtual memory with the `kvm_read` function. If the
    read is successful, the number of bytes transferred is returned. Otherwise, `−1`
    is returned.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kvm_read`函数从内核虚拟内存中读取数据。如果读取成功，则返回传输的字节数。否则，返回`−1`。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `nbytes` indicates the number of bytes to be read from the kernel space
    address `addr` to the buffer `buf`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nbytes`表示要从内核空间地址`addr`读取到缓冲区`buf`的字节数。
- en: The kvm_write Function
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_write 函数
- en: Data is written to kernel virtual memory with the `kvm_write` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kvm_write`函数将数据写入内核虚拟内存。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The return value is usually equal to the `nbytes` argument, unless an error
    has occurred, in which case `−1` is returned instead. In this definition, `nbytes`
    indicates the number of bytes to be written to `addr` from `buf`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值通常等于`nbytes`参数，除非发生错误，在这种情况下，将返回`−1`。在这个定义中，`nbytes`表示要从`buf`写入到`addr`的字节数。
- en: The kvm_close Function
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kvm_close 函数
- en: An open kernel virtual memory descriptor is closed by calling the `kvm_close`
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`kvm_close`函数关闭一个打开的内核虚拟内存描述符。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If `kvm_close` is successful, `0` is returned. Otherwise, `−1` is returned.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`kvm_close`成功，则返回`0`。否则，返回`−1`。
- en: Patching Code Bytes
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修补代码字节
- en: Now, equipped with the functions from the previous section, let's patch some
    kernel virtual memory. I'll start with a very basic example. Listing 5-1 is a
    system call module that acts like an over-caffeinated "Hello, world!" function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了上一节中的函数，让我们修补一些内核虚拟内存。我会从一个非常基础的例子开始。列表5-1是一个系统调用模块，它像一个过度咖啡因的“Hello,
    world!”函数。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-1: hello.c*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：hello.c*'
- en: As you can see, if we execute this system call, we'll get some very annoying
    output. To make this system call less annoying, we can patch out ❶ the `for` loop,
    which will remove the nine additional calls to `printf`. However, before we can
    do that, we'll need to know what this system call looks like when it's loaded
    in main memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，如果我们执行这个系统调用，我们会得到一些非常令人烦恼的输出。为了使这个系统调用不那么令人烦恼，我们可以移除❶`for`循环，这将移除对`printf`的九次额外调用。然而，在我们能够做到这一点之前，我们需要知道这个系统调用在主内存中的样子。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The binary *`hello.ko`* was compiled explicitly without the *`-funroll-loops`*
    option.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件*`hello.ko`*是明确编译的，没有使用*`-funroll-loops`*选项。
- en: Notice the instruction at address 49d, which causes the instruction pointer
    to jump back to address 490 if the sign flag is not set. This instruction is,
    more or less, the `for` loop in hello.c. Therefore, if we `nop` it out, we can
    make the `hello` system call somewhat bearable. The program in Listing 5-2 does
    just that.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意地址49d处的指令，如果符号标志未设置，则将指令指针跳转回地址490。这个指令大致上是hello.c中的`for`循环。因此，如果我们将其`nop`掉，可以使`hello`系统调用变得稍微可以忍受。列表5-2中的程序就是这样做的。
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-2: fix_hello.c*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：fix_hello.c*'
- en: Notice how ❶ I search through the first 48 bytes of `hello`, looking for the
    `jns` instruction, instead of using a hard-coded offset. Depending on your compiler
    version, compiler flags, base system, and so on, it is entirely possible for hello.c
    to compile differently. Therefore, it's useless to determine the location of `jns`
    ahead of time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何搜索`hello`的前48字节，寻找`jns`指令，而不是使用硬编码的偏移量。根据你的编译器版本、编译器标志、基础系统等，hello.c编译出来的结果可能会有所不同。因此，提前确定`jns`的位置是没有用的。
- en: In fact, it's possible that when compiled, hello.c will not even include a `jns`
    instruction, as there are multiple ways to represent a `for` loop in machine code.
    Furthermore, recall that the disassembly of `hello.ko` identified two instructions
    that require dynamic relocation. This means that the first 0×79 byte encountered
    may be part of those instructions, and not the actual `jns` instruction. That's
    why this is an example and not a real program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当编译时，hello.c甚至可能不包含一个`jns`指令，因为在机器码中存在多种表示`for`循环的方式。此外，回忆一下`hello.ko`的反汇编中识别出的两个需要动态重定位的指令。这意味着遇到的第一个0×79字节可能是这些指令的一部分，而不是实际的`jns`指令。这就是为什么这是一个例子而不是一个真实程序的原因。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get around these problems, use longer and/or more search signatures. You
    could also use hard-coded offsets, but your code would break on some systems.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这些问题，使用更长和/或更多的搜索签名。你也可以使用硬编码的偏移量，但你的代码在某些系统上会崩溃。
- en: Another interesting detail worth mentioning is that when I patch `hello` with
    `kvm_write`, I ❷ pass `sizeof(nop_code) - 1`, not `sizeof(nop_code)`, as the `nbytes`
    argument. In C, character arrays are null terminated; therefore, `sizeof(nop_code)`
    returns three. However, I only want to write two `nop`s, not two `nop`s and a
    `NULL`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的细节是，当我使用 `kvm_write` 修补 `hello` 时，我 ❷ 传递 `sizeof(nop_code) - 1`，而不是
    `sizeof(nop_code)` 作为 `nbytes` 参数。在 C 语言中，字符数组是空终止的；因此，`sizeof(nop_code)` 返回三个。然而，我只想要写两个
    `nop`，而不是两个 `nop` 和一个 `NULL`。
- en: 'The following output shows the results of executing `hello` before and after
    running `fix_hello` on ttyv0 (i.e., the system console):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了在 ttyv0 上运行 `fix_hello` 之前和之后执行 `hello` 的结果（即系统控制台）：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Success! Now let's try something a little more advanced.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！现在让我们尝试一些更高级的东西。
- en: Understanding *x*86 Call Statements
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 *x86* `call` 语句
- en: 'In *x*86 assembly the `call` statement is a control transfer instruction used
    to call a function or procedure. There are two types of `call` statements: `near`
    and `far`. For our purposes, we only need to understand `near call` statements.
    The following (contrived) code segment illustrates the details of a `near call`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *x86* 汇编中，`call` 语句是一个控制转移指令，用于调用函数或过程。有两种类型的 `call` 语句：`near` 和 `far`。就我们的目的而言，我们只需要了解
    `near call` 语句。以下（虚构的）代码段说明了 `near call` 的细节。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above code snippet, when the instruction pointer reaches address 205—the
    `call` statement—it will jump to address 300\. The hexadecimal representation
    for a `call` statement is `e8`. However, `f6 00 00 00` is obviously not `300`.
    At first glance, it appears that the machine code and assembly code don't match,
    but in fact, they do. In a `near call`, the address of the instruction after the
    `call` statement is saved on the stack, so that the called procedure knows where
    to return to. Thus, the machine code operand for a `call` statement is the address
    of the called procedure, minus the address of the instruction following the `call`
    statement (`0×300` – `0×20a` = `0xf6`). This explains why the machine code operand
    for `call` is `f6 00 00 00` in this example, not `00 03 00 00`. This is an important
    point that will come into play shortly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，当指令指针到达地址 205——`call` 语句时，它将跳转到地址 300。`call` 语句的十六进制表示为 `e8`。然而，`f6
    00 00 00` 显然不是 `300`。乍一看，似乎机器代码和汇编代码不匹配，但实际上它们是匹配的。在 `near call` 中，`call` 语句之后的指令地址被保存在栈上，这样被调用的过程就知道返回的位置。因此，`call`
    语句的机器代码操作数是被调用过程的地址减去 `call` 语句之后的指令地址（`0x300` - `0x20a` = `0xf6`）。这解释了为什么在这个例子中
    `call` 的机器代码操作数是 `f6 00 00 00`，而不是 `00 03 00 00`。这是一个重要的观点，稍后将会发挥作用。
- en: Patching Call Statements
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修补 `call` 语句
- en: Going back to Listing 5-1, let's say that when we `nop` out the `for` loop,
    we also want `hello` to call `uprintf` instead of `printf`. The program in Listing
    5-3 patches `hello` to do just that.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回到列表 5-1，假设当我们 `nop` 出 `for` 循环时，我们还想让 `hello` 调用 `uprintf` 而不是 `printf`。列表
    5-3 中的程序修补 `hello` 来实现这一点。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 5-3: fix_hello_improved.c*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：fix_hello_improved.c*'
- en: Notice how `hello` is patched to invoke `uprintf` instead of `printf`. First,
    the addresses of `hello` and `uprintf` are ❶ stored in `nl[0].n_value` and `nl[1].n_value`,
    respectively. Next, the relative address of `call` within `hello` is ❷ stored
    in `call_offset`. Then, a new `call` statement operand is calculated by subtracting
    ❹ the address of the instruction following `call` from ❸ the address of `uprintf`.
    This value is stored in `call_operand[]`. Finally, the old `call` statement operand
    is ❺ overwritten with `call_operand[]`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `hello` 是如何被修补来调用 `uprintf` 而不是 `printf` 的。首先，`hello` 和 `uprintf` 的地址分别存储在
    `nl[0].n_value` 和 `nl[1].n_value` 中。接下来，`hello` 中 `call` 的相对地址存储在 `call_offset`
    中。然后，通过从 `uprintf` 的地址中减去 `call` 之后的指令地址来计算一个新的 `call` 语句操作数，这个值存储在 `call_operand[]`
    中。最后，旧的 `call` 语句操作数被 ❺ 用 `call_operand[]` 覆盖。
- en: 'The following output shows the results of executing `hello`, before and after
    running `fix_hello_improved` on ttyv1:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了在 ttyv1 上运行 `fix_hello_improved` 之前和之后执行 `hello` 的结果：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Success! At this point, you should have no trouble patching any kernel code
    byte. However, what happens when the patch you want to apply is too big and will
    overwrite nearby instructions that you require? The answer is . . .
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！在这个阶段，你应该没有困难地修补任何内核代码字节。然而，当你想要应用的补丁太大，会覆盖你需要的附近指令时，会发生什么呢？答案是……
- en: Allocating Kernel Memory
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配内核内存
- en: In this section I'll describe a set of core functions and macros used to allocate
    and deallocate kernel memory. We'll put these functions to use later on, when
    we explicitly solve the problem outlined above.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述一组用于分配和释放内核内存的核心函数和宏。我们将在稍后使用这些函数，当我们明确解决上述问题时。
- en: The malloc Function
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: malloc 函数
- en: The `malloc` function allocates a specified number of bytes of memory in kernel
    space. If successful, a kernel virtual address (that is suitably aligned for storage
    of any data object) is returned. If an error is encountered, `NULL` is returned
    instead.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`函数在内核空间中分配指定数量的内存字节。如果成功，则返回一个内核虚拟地址（适用于存储任何数据对象的适当对齐）。如果遇到错误，则返回`NULL`。'
- en: 'Here is the function prototype for `malloc`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`malloc`函数的原型：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following is a brief description of each parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个参数的简要说明。
- en: '`size`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`'
- en: This specifies the amount of uninitialized kernel memory to allocate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了要分配的未初始化内核内存的数量。
- en: '`type`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`'
- en: This parameter is used to perform statistics on memory usage and for basic sanity
    checks. (Memory statistics can be viewed by running the command `vmstat -m`.)
    Typically, I'll set this parameter to `M_TEMP`, which is the `malloc_type` for
    miscellaneous temporary data buffers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数用于对内存使用进行统计和进行基本健全性检查。（可以通过运行命令`vmstat -m`来查看内存统计信息。）通常，我会将此参数设置为`M_TEMP`，这是用于各种临时数据缓冲区的`malloc_type`。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more on *`struct malloc_type`*, see the malloc(9) manual page.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`struct malloc_type`的更多信息，请参阅malloc(9)手册页。
- en: '**`flags`**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**`flags`**'
- en: 'This parameter further qualifies `malloc`''s operational characteristics. It
    can be set to any of the following values:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数进一步限定`malloc`的操作特性。它可以设置为以下任何值之一：
- en: '**`M_ZERO`**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**`M_ZERO`**'
- en: This causes the allocated memory to be set to zero.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致分配的内存被设置为0。
- en: '**`M_NOWAIT`**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**`M_NOWAIT`**'
- en: This causes `malloc` to return `NULL` if the allocation request cannot be fulfilled
    immediately. This flag should be set when calling `malloc` in an interrupt context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配请求不能立即得到满足，这将导致`malloc`返回`NULL`。在调用`malloc`的中断上下文中应设置此标志。
- en: '**`M_WAITOK`**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**`M_WAITOK`**'
- en: This causes `malloc` to sleep and wait for resources if the allocation request
    cannot be fulfilled immediately. If this flag is set, `malloc` cannot return `NULL`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分配请求不能立即得到满足，这将导致`malloc`休眠并等待资源。如果设置了此标志，`malloc`不能返回`NULL`。
- en: Either `M_NOWAIT` or `M_WAITOK` must be specified.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定`M_NOWAIT`或`M_WAITOK`。
- en: The MALLOC Macro
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MALLOC 宏
- en: 'For compatibility with legacy code, the `malloc` function is called with the
    `MALLOC` macro, which is defined as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与旧代码兼容，`malloc`函数使用`MALLOC`宏调用，该宏定义如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This macro is functionally equivalent to:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏在功能上等同于：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The free Function
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: free 函数
- en: To deallocate kernel memory that was previously allocated by `malloc`, call
    the `free` function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了释放先前由`malloc`分配的内核内存，请调用`free`函数。
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `addr` is the memory address returned by a previous `malloc` call, and
    `type` is its associated `malloc_type`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addr`是先前`malloc`调用返回的内存地址，而`type`是其关联的`malloc_type`。
- en: The FREE Macro
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FREE 宏
- en: 'For compatibility with legacy code, the `free` function is called with the
    `FREE` macro, which is defined as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与旧代码兼容，`free`函数使用`FREE`宏调用，该宏定义如下：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This macro is functionally equivalent to:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏在功能上等同于：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At some point in 4BSD's history, part of its *`malloc`* algorithm was inline
    in a macro, which is why there is a *`MALLOC`* macro in addition to a function
    call.^([[1](#ftn.CHP-5-FN-1)]) However, FreeBSD's *`malloc`* algorithm is just
    a function call. Thus, unless you are writing legacy-compatible code, the use
    of the *`MALLOC`* and *`FREE`* macros is discouraged.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在4BSD的历史某个时刻，其`malloc`算法的一部分是内联在宏中的，这就是为什么除了函数调用外，还有一个`MALLOC`宏。然而，FreeBSD的`malloc`算法只是一个函数调用。因此，除非你正在编写与旧代码兼容的代码，否则不建议使用`MALLOC`和`FREE`宏。
- en: Example
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Listing 5-4 shows a system call module designed to allocate kernel memory.
    The system call is invoked with two arguments: a long integer containing the amount
    of memory to allocate and a long integer pointer to store the returned address.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4 显示了一个设计用于分配内核内存的系统调用模块。该系统调用使用两个参数调用：一个包含要分配的内存数量的长整数和一个指向返回地址的长整数指针。
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-4: kmalloc.c*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：kmalloc.c*'
- en: As you can see, this code simply ❶ calls the `MALLOC` macro to allocate `uap->size`
    amount of kernel memory, and then ❷ copies out the returned address to user space.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码只是❶调用`MALLOC`宏来分配`uap->size`数量的内核内存，然后❷将返回的地址复制到用户空间。
- en: Listing 5-5 is the user space program designed to execute the system call above.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-5是设计用来执行上述系统调用的用户空间程序。
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-5: interface.c*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-5：interface.c*'
- en: This program uses the `modstat`/`modfind` approach (described in [Chapter 1](ch01.html
    "Chapter 1. LOADABLE KERNEL MODULES")) to pass the first command-line argument
    to `kmalloc`; this argument should contain the amount of kernel memory to allocate.
    It then outputs the kernel virtual address where the recently allocated memory
    is located.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用`modstat`/`modfind`方法（在[第1章](ch01.html "第1章. 可加载内核模块")中描述）将第一个命令行参数传递给`kmalloc`；这个参数应包含要分配的内核内存量。然后输出最近分配的内存所在的内核虚拟地址。
- en: '* * *'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[1](#CHP-5-FN-1)]) ¹ John Baldwin, personal communication, 2006–2007.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[1](#CHP-5-FN-1)]) ¹ 约翰·鲍德温，个人通信，2006–2007。
- en: Allocating Kernel Memory from User Space
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户空间分配内核内存
- en: 'Now that you''ve seen how to "properly" allocate kernel memory using module
    code, let''s do it using run-time kernel memory patching. Here is the algorithm
    (Cesare, 1998, as cited in sd and devik, 2001) we''ll be using:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何使用模块代码“正确”地分配内核内存，让我们使用运行时内核内存修补来做到这一点。以下是我们将使用的算法（Cesare，1998，如sd和devik，2001所引用）：
- en: Retrieve the in-memory address of the `mkdir` system call.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`mkdir`系统调用的内存地址。
- en: Save `sizeof(kmalloc)` bytes of `mkdir`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`sizeof(kmalloc)`个字节的`mkdir`。
- en: Overwrite `mkdir` with `kmalloc`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`kmalloc`覆盖`mkdir`。
- en: Call `mkdir`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`mkdir`。
- en: Restore `mkdir`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复`mkdir`。
- en: With this algorithm, you are basically patching a system call with your own
    code, issuing the system call (which will execute your code instead), and then
    restoring the system call. This algorithm can be used to execute any piece of
    code in kernel space without a KLD.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个算法，你基本上是用自己的代码修补系统调用，发出系统调用（这将执行你的代码），然后恢复系统调用。这个算法可以用来在内核空间执行任何代码片段，而不需要KLD。
- en: However, keep in mind that when you overwrite a system call, any process that
    issues or is currently executing the system call will break, resulting in a kernel
    panic. In other words, inherent to this algorithm is a race condition or concurrency
    issue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，当你覆盖系统调用时，任何发出或当前正在执行系统调用的进程都会中断，导致内核恐慌。换句话说，这种算法固有的就是竞争条件或并发问题。
- en: Example
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Listing 5-6 shows a user space program designed to allocate kernel memory.
    This program is invoked with one command-line argument: an integer containing
    the number of bytes to allocate.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-6显示了设计用来分配内核内存的用户空间程序。这个程序用一个命令行参数调用：一个包含要分配的字节数的整数。
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-6: kmalloc_reloaded.c*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-6：kmalloc_reloaded.c*'
- en: 'In the preceding code, the ❶ `kmalloc` function code was generated by disassembling
    the `kmalloc` system call from Listing 5-4:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，❶`kmalloc`函数代码是通过反汇编列表5-4中的`kmalloc`系统调用生成的：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how `objdump(1)` reports three instructions that require dynamic relocation.
    The first, at offset 10, is ❶ for the address of `M_TEMP`. The second, at offset
    34, is ❷ for the `malloc` call statement operand. And the third, at offset 64,
    is ❸ for the `copyout` call statement operand.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`objdump(1)`如何报告三个需要动态重定位的指令。第一个，在偏移量10处，是❶指向`M_TEMP`地址的。第二个，在偏移量34处，是❷指向`malloc`调用语句操作数的。第三个，在偏移量64处，是❸指向`copyout`调用语句操作数的。
- en: 'In kmalloc_reloaded.c, we account for this in our `kmalloc` function code with
    the following five lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kmalloc_reloaded.c`中，我们在`kmalloc`函数代码中用以下五行来考虑这一点：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how `kmalloc` is patched at offset 10 with ❶ the address of `M_TEMP`.
    It is also patched at offsets 34 and 64 with ❷ the address of `malloc` minus ❸
    the address of the instruction following the `malloc` call, and ❹ the address
    of `copyout` minus ❺ the address of the instruction following the `copyout` call,
    respectively.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`kmalloc`是如何在偏移量10处修补的❶，指向`M_TEMP`的地址。它还在偏移量34和64处修补，分别使用❷`malloc`地址减去❸`malloc`调用后的指令地址，以及❹`copyout`地址减去❺`copyout`调用后的指令地址。
- en: 'The following output shows `kmalloc_reloaded` in action:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了`kmalloc_reloaded`的作用：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To verify the kernel memory allocation, you can use a kernel-mode debugger
    like `ddb(4)`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证内核内存分配，您可以使用像`ddb(4)`这样的内核模式调试器：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Inline Function Hooking
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数挂钩
- en: 'Recall the problem posed at the end of [Patching Call Statements](ch05s03.html#patching_call_statements
    "Patching Call Statements"): What do you do when you want to patch some kernel
    code, but your patch is too big and will overwrite nearby instructions that you
    require? The answer is: You use an inline function hook.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [修补调用语句](ch05s03.html#patching_call_statements "修补调用语句") 结尾处提出的问题：当你想修补一些内核代码，但你的修补太大，会覆盖你需要的附近指令时，你会怎么做？答案是：你使用内联函数钩子。
- en: In general, an inline function hook places an unconditional jump within the
    body of a function to a region of memory under your control. This memory will
    contain the "new" code you want the function to execute, the code bytes that were
    overwritten by the unconditional jump, and an unconditional jump back to the original
    function. This will extend functionality while preserving original behavior. Of
    course, you don't have to preserve the original behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，内联函数钩子在函数体内部放置一个无条件跳转到你控制的内存区域。这个内存将包含你想要函数执行的 "新" 代码，被无条件跳转覆盖的代码字节，以及一个跳回到原始函数的无条件跳转。这将扩展功能同时保留原始行为。当然，你不必保留原始行为。
- en: Example
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: In this section we'll patch the `mkdir` system call with an inline function
    hook so that it will output the phrase "Hello, world!\n" each time it creates
    a directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用内联函数钩子修补 `mkdir` 系统调用，以便每次创建目录时都会输出短语 "Hello, world!\n"。
- en: Now, let's take a look at the disassembly of `mkdir` to see where we should
    place the jump, which bytes we need to preserve, and where we should jump back
    to.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `mkdir` 的反汇编代码，以确定我们应该放置跳转的位置，我们需要保留哪些字节，以及我们应该跳转回哪里。
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because I want to extend the functionality of `mkdir`, rather than change it,
    the best place for the unconditional jump is at the beginning. An unconditional
    jump requires seven bytes. If you overwrite the first seven bytes of `mkdir`,
    the first three instructions will be eliminated, and the fourth instruction (which
    starts at offset six) will be mangled. Therefore, we'll need to save the first
    four instructions (i.e., the first nine bytes) in order to preserve `mkdir`'s
    functionality; this also means that you should jump back to offset nine to resume
    execution from the fifth instruction.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我想扩展 `mkdir` 的功能，而不是更改它，因此无条件跳转的最佳位置是在开始处。无条件跳转需要七个字节。如果你覆盖了 `mkdir` 的前七个字节，前三条指令将被消除，第四条指令（从偏移量六开始）将被破坏。因此，我们需要保存前四条指令（即前九个字节），以保留
    `mkdir` 的功能；这也意味着你应该跳回到偏移量九，从第五条指令恢复执行。
- en: Before committing to this plan, however, let's look at the disassembly of `mkdir`
    on a different machine.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺这个计划之前，让我们看看不同机器上 `mkdir` 的反汇编代码。
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how the two disassemblies are quite different. In fact, this time around
    the fifth instruction starts at offset eight, not nine. If the code were to jump
    back to offset nine, it would most definitely crash this system. What this boils
    down to is that when writing an inline function hook, in general, you'll have
    to avoid using hard-coded offsets if you want to apply the hook to a wide range
    of systems.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这两个反汇编代码有多么不同。事实上，这次第五条指令从偏移量八开始，而不是九。如果代码跳回到偏移量九，系统肯定会崩溃。这归结为，在编写内联函数钩子时，通常，如果你想将钩子应用于广泛的系统，你将不得不避免使用硬编码的偏移量。
- en: Looking back at the two disassemblies, notice how `mkdir` calls `kern_mkdir`
    every time. Therefore, we can jump back to that (i.e., 0xe8). In order to preserve
    `mkdir`'s functionality, we'll now have to save every byte up to, but not including,
    0xe8.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下两个反汇编代码，注意到 `mkdir` 每次都会调用 `kern_mkdir`。因此，我们可以跳回到那里（即，0xe8）。为了保留 `mkdir`
    的功能，我们现在必须保存到但不包括 0xe8 的每个字节。
- en: Listing 5-7 shows my `mkdir` inline function hook.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-7 显示了我的 `mkdir` 内联函数钩子。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To save space, the `kmalloc` function code is omitted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，省略了 `kmalloc` 函数代码。
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 5-7: mkdir_patch.c*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：mkdir_patch.c*'
- en: As you can see, employing an inline function hook is relatively straightforward
    (although it's somewhat lengthy). In fact, the only piece of code you haven't
    seen before is ❶ the `"Hello, world!\n"` function code. It is rather simplistic,
    but there are two important points about it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用内联函数钩子相对简单（尽管它有些冗长）。实际上，你之前没有见过的唯一代码片段是❶ "Hello, world!\n" 函数代码。它相当简单，但有两个重要的要点。
- en: First, notice how the first 15 bytes of `hello` are actually data; to be exact,
    these bytes make up the string `Hello, world!\n`. The actual assembly language
    instructions don't start until offset 15\. This is why the unconditional jump
    code, which overwrites `mkdir`, is ❷ set to `addr + 0x0f`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`hello`的前15个字节实际上是数据；更确切地说，这些字节组成了字符串`Hello, world!\n`。实际的汇编语言指令从偏移量15开始。这就是为什么无条件跳转代码，它覆盖了`mkdir`，被设置为`addr
    + 0x0f`。
- en: Second, note `hello`'s final three instructions. The first zeros out the `%eax`
    register, the second cleans up the stack, and the last restores the `%ebp` register.
    This is done so that when `mkdir` actually begins executing, it's as if the hook
    never happened.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，注意`hello`的最后三条指令。第一条清零了`%eax`寄存器，第二条清理了堆栈，最后一条恢复了`%ebp`寄存器。这样做是为了当`mkdir`实际开始执行时，它就像挂钩从未发生一样。
- en: 'The following output shows `mkdir_patch` in action:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了`mkdir_patch`的作用：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Gotchas
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱
- en: Because mkdir_patch.c is a simple example, it fails to reveal some typical gotchas
    associated with inline function hooking.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`mkdir_patch.c`是一个简单的例子，它未能揭示与内联函数挂钩相关的某些典型陷阱。
- en: First, by placing an unconditional jump within the body of a function, whose
    behavior you intend to preserve, there is a good chance that you'll cause a kernel
    panic. This is because the unconditional jump code requires the use of a general-purpose
    register; however, it is likely that within the body of a function, all the general-purpose
    registers will already be in use. To get around this, push the register you are
    going to use onto the stack before jumping, and then pop it off after.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在你要保留行为的功能体内部放置一个无条件跳转，你很可能会引起内核恐慌。这是因为无条件跳转代码需要使用通用寄存器；然而，在函数体内部，所有通用寄存器可能已经被使用。为了解决这个问题，在跳转之前将你要使用的寄存器推入堆栈，然后在跳转之后将其弹出。
- en: Second, if you copy a `call` or jump statement and place it into a different
    region of memory, you can't execute it as is; you have to adjust its operand first.
    This is because a `call` or jump statement's machine code operand is a relative
    address.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果你复制了一个`call`或跳转语句并将其放置到内存的不同区域，你不能直接执行它；你必须首先调整它的操作数。这是因为`call`或跳转语句的机器码操作数是一个相对地址。
- en: Finally, it's possible for your code to be preempted while patching, and during
    that time, your target function may execute in its incomplete state. Therefore,
    if possible, you should avoid patching with multiple writes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在打补丁的过程中，你的代码可能会被抢占，在这段时间内，你的目标函数可能会以不完整的状态执行。因此，如果可能的话，你应该避免使用多次写入来打补丁。
- en: Cloaking System Call Hooks
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏系统调用挂钩
- en: 'Before concluding this chapter, let''s take a brief look at a nontrivial application
    for run-time kernel memory patching: cloaking system call hooks. That is, implementing
    a system call hook without patching the system call table or any system call function.
    This is achieved by patching the system call dispatcher with an inline function
    hook so it references a Trojan system call table instead of the original. This
    renders the original table functionless, but maintains its integrity, enabling
    the Trojan table to direct system call requests to any handler you like.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，让我们简要地看看运行时内核内存打补丁的非平凡应用：隐藏系统调用挂钩。也就是说，在不修改系统调用表或任何系统调用函数的情况下实现系统调用挂钩。这是通过用内联函数挂钩修补系统调用调度器来实现的，使其引用一个特洛伊木马系统调用表而不是原始表。这使得原始表变得无功能，但保持了其完整性，使得特洛伊木马表可以将系统调用请求定向到任何你喜欢的处理程序。
- en: Because the code to do this is rather lengthy (it's longer than mkdir_patch.c),
    I'll simply explain how it's done and leave the actual code to you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行此操作的代码相当长（比`mkdir_patch.c`长），我将简单地解释如何执行，并将实际的代码留给你。
- en: The system call dispatcher in FreeBSD is `syscall`, which is implemented in
    the file /sys/i386/i386/trap.c as follows.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的系统调用调度器是`syscall`，它在文件`/sys/i386/i386/trap.c`中实现，如下所示。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the interest of saving space, any code irrelevant to this discussion is omitted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，任何与这次讨论无关的代码都被省略了。
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `syscall`, line ❶ references the system call table and stores the address
    of the system call to be dispatched into `callp`. Here is what this line looks
    like disassembled:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`syscall`中，行❶引用了系统调用表并将要调度的系统调用地址存储到`callp`中。以下是反汇编后的这一行代码：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first instruction loads `curthread`, the currently running thread (i.e.,
    the `%fs` segment register), into `%eax`. The first field in a `thread` structure
    is a pointer to its associated `proc` structure; hence, the second instruction
    loads the current process into `%eax`. The next instruction loads `p_sysent` into
    `%eax`. This can be verified, as the `p_sysent` field (which is a `sysentvec`
    pointer) is located at an offset of 0x1a0 within a `proc` structure. The last
    instruction loads the system call table into `%eax`. This can be verified, as
    the `sv_table` field is located at an offset of 0x4 within a `sysentvec` structure.
    This last line is the one you'll need to scan for and patch. However, be aware
    that, depending on the system, the system call table can be loaded into a different
    general-purpose register.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令将当前运行的线程`curthread`（即`%fs`段寄存器）加载到`%eax`。`thread`结构体中的第一个字段是指向其相关`proc`结构体的指针；因此，第二条指令将当前进程加载到`%eax`。下一条指令将`p_sysent`加载到`%eax`。这可以通过验证，因为`p_sysent`字段（即`sysentvec`指针）位于`proc`结构体中的0x1a0偏移量处。最后一条指令将系统调用表加载到`%eax`。这也可以通过验证，因为`sv_table`字段位于`sysentvec`结构体中的0x4偏移量处。这一行是你需要扫描和修补的。然而，请注意，根据系统不同，系统调用表可能被加载到不同的通用寄存器中。
- en: Also, after Trojaning the system call table, any system call modules that are
    loaded won't work. However, since you now control the system calls responsible
    for loading a module, this can be fixed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在篡改系统调用表后，加载的任何系统调用模块都将无法工作。然而，由于你现在控制着负责加载模块的系统调用，这可以修复。
- en: That's about it! All you really need to do is patch one spot. Of course, the
    devil is in the details. (In fact, all the gotchas I listed in [Gotchas](ch05s06.html#gotchas
    "Gotchas") are a direct result of trying to patch that one spot.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！你真正需要做的只是修补一个地方。当然，魔鬼在于细节。（事实上，我在[注意事项](ch05s06.html#gotchas "注意事项")中列出的一切都是试图修补那个地方的直接结果。）
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you Trojan your own system call table, you'll null the effects of traditional
    system call hooking. In other words, this technique of cloaking system calls can
    be applied defensively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你篡改了自己的系统调用表，将使传统系统调用钩子的效果失效。换句话说，这种隐藏系统调用的技术可以用于防御性应用。
- en: Concluding Remarks
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Run-time kernel memory patching is one of the strongest techniques for modifying
    software logic. Theoretically, you can use it to rewrite the entire operating
    system on the fly. Furthermore, it's somewhat difficult to detect, depending on
    where you place your patches and whether or not you use inline function hooks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时内核内存修补是修改软件逻辑的最强大技术之一。理论上，你可以用它即时重写整个操作系统。此外，它检测起来有些困难，这取决于你放置修补的位置以及你是否使用了内联函数钩子。
- en: At the time of this writing, a technique to cloak run-time kernel memory patching
    has been published. See "Raising The Bar For Windows Rootkit Detection" by Jamie
    Butler and Sherri Sparks, published in *Phrack* magazine, issue 63\. Although
    this article is written from a Windows perspective, the theory can be applied
    to any *x*86 operating system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，一种用于隐藏运行时内核内存修补的技术已被公布。请参阅Jamie Butler和Sherri Sparks在*Phrack*杂志第63期发表的“提高Windows
    Rootkit检测的门槛”。尽管这篇文章是从Windows的角度写的，但该理论可以应用于任何*x*86操作系统。
- en: Finally, like most rootkit techniques, run-time kernel memory patching has legitimate
    uses. For example, Microsoft calls it *hot patching* and uses it to patch systems
    without requiring a reboot.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像大多数rootkit技术一样，运行时内核内存修补有合法用途。例如，微软将其称为*热修补*，并用于修补系统而无需重启。
