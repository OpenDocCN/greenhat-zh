- en: '![](../images/221-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/221-1.jpg)'
- en: '[**INFRARED REMOTE CONTROL**](toc.html#chapter12)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**红外遥控器**](toc.html#chapter12)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/as.jpg)'
- en: 'Remotes have become our most natural means of controlling certain appliances,
    and if you’re like us, you’ll occasionally spend several minutes trying to locate
    a remote control rather than trying to engage some device’s obscure front panel.
    In the future, we expect to see more appliances forfeiting the front panel altogether
    in favor of the keypad of a simple remote. Here’s a rule of thumb: If you are
    building an appliance that might be enjoyed by people while they are sitting on
    a couch, include a remote control.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器已成为我们控制某些电器最自然的方式，如果你和我们一样，你偶尔会花几分钟时间试图找到遥控器，而不是试图操作某个设备的神秘前面板。在未来，我们预计将看到更多电器完全放弃前面板，转而使用简单遥控器的键盘。这里有一个经验法则：如果你正在制造一个人们坐在沙发上可能会享受的电器，请包括一个遥控器。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Communicating with infrared light
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用红外光进行通信
- en: Hardware for remote control receivers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遥控器接收器的硬件
- en: Installing and configuring LIRC for the Laddie appliance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Laddie设备安装和配置LIRC
- en: '[**Communicating with Infrared Light**](toc.html#chapter12.1)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[**使用红外光进行通信**](toc.html#chapter12.1)'
- en: The infrared (IR) light used by remote controls has a wavelength close to, but
    greater than, visible light. Because it’s close to visible light, it travels in
    straight lines and reflects off of surfaces, but it doesn’t go through opaque
    objects. This limits the applications for which IR is useful. It’s good for controlling
    a set-top box, but not so good for opening a garage door, if there’s a solid wall
    between the transmitter and the receiver.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器使用的红外（IR）光波长接近但大于可见光。因为它接近可见光，所以它沿直线传播并从表面上反射，但它不会穿透不透明物体。这限制了红外的应用范围。它适用于控制机顶盒，但不适用于打开车库门，如果发射器和接收器之间有一堵实墙。
- en: For the most part, the fact that IR is invisible is a good thing. It may be
    harder to debug something that’s invisible, but when you’re watching the late-night
    movie on your new Linux-based DVR, it’s nice to know you can turn down the volume
    without shining visible light onto the screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，红外线不可见是一个好事。调试不可见的东西可能更困难，但当你晚上在基于Linux的DVR上观看电影时，知道你可以降低音量而不在屏幕上发出可见光是很不错的。
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you wish you could see the light from a remote control, perhaps to verify
    that a unit isn’t broken, you can look at it using a cell phone camera. These
    cameras are sensitive to infrared, and on cameras we’ve experimented with, they
    display this “color” as bright white.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你希望看到遥控器的光线，也许是为了验证设备没有损坏，你可以用手机摄像头查看它。这些摄像头对红外线敏感，在我们实验过的相机上，它们将这种“颜色”显示为明亮的白色。*'
- en: '[***Protocols for Encoding Remote Control Commands***](toc.html#chapter12.2)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[***编码遥控器命令的协议***](toc.html#chapter12.2)'
- en: 'In order to transfer information, a remote control transmitter and its receiver
    must use the same standard or *protocol* for encoding commands. A remote control
    protocol specifies the following three things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传输信息，遥控器发射器和接收器必须使用相同的标准或*协议*来编码命令。遥控器协议指定以下三个事项：
- en: How it represents ones and zeros
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示一和零
- en: How these ones and zeros are combined or *framed* to form messages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将这些一和零组合或*封装*成消息
- en: How these different messages are to be interpreted
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解释这些不同的消息
- en: 'Companies that build remote-controlled devices don’t generally publish their
    protocols, but it’s not hard to reverse engineer the basic commands, and the Internet
    has plenty of information from people who have done just that. As an example,
    we’ll consider a protocol Sony has used for some of its televisions. If you do
    some research on the Internet, you might see this protocol referred to as the
    Sony Integrated Remote Control System (SIRCS) protocol. We chose to use this protocol
    for the Laddie appliance because the protocol is easy to understand. It is also
    easy to produce: We purchased a universal remote (RCA RCU410) and programmed it
    to “Sony TV” (Code 002).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 建造遥控设备的公司通常不会公开它们的协议，但逆向工程基本命令并不困难，互联网上有大量这方面的信息。作为一个例子，我们将考虑索尼为其一些电视使用的协议。如果你在互联网上做一些研究，你可能会看到这个协议被称为索尼集成遥控系统（SIRCS）协议。我们选择使用这个协议为Laddie设备，因为这个协议易于理解。它也易于生成：我们购买了一个通用遥控器（RCA
    RCU410）并将其编程为“索尼电视”（代码002）。
- en: This Sony TV protocol uses pulse-coded data encoding. With this encoding, a
    bit is represented as a variable-width *pulse,* or presence of light, followed
    by a constant-width *space,* or absence of light. Based on our own timing measurements
    with our handheld remote, a zero has a 650-microsecond pulse, a one has a 1,300-microsecond
    pulse, and each is followed by a 500-microsecond space. These encodings are illustrated
    in Figure 12-1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此索尼电视协议使用脉冲编码数据编码。使用这种编码，一个比特由一个可变宽度的*脉冲*或光的存在表示，随后是一个恒定宽度的*空间*或光的不存在。根据我们使用手持遥控器进行的自身时间测量，零有一个650微秒的脉冲，一有一个1,300微秒的脉冲，每个脉冲后都跟一个500微秒的空间。这些编码在图12-1中展示。
- en: '![](../images/223-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/223-1.jpg)'
- en: '*Figure 12-1: Zeros and ones in the Sony TV protocol*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-1：索尼电视协议中的零和一*'
- en: A frame in the Sony TV protocol (again, as measured for our particular remote)
    begins with a header consisting of a single 2,500-microsecond pulse followed by
    a 500-microsecond space. A seven-bit command immediately follows the header, and
    a five-bit address follows the command. Both the command and the address are transmitted
    with the least-significant bit (lsb) first. Figure 12-2 shows the waveform for
    the TV/Volume– command.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 索尼电视协议中的一个帧（再次强调，这是针对我们特定的遥控器测量的）以一个由单个2,500微秒脉冲和一个500微秒空间组成的头部开始。紧接着头部的是一个七位命令，然后是一个五位地址。命令和地址都使用最低有效位（lsb）首先传输。图12-2显示了TV/Volume-命令的波形。
- en: '![](../images/223-2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/223-2.jpg)'
- en: '*Figure 12-2: The TV/Volume– command in the Sony TV protocol*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：索尼电视协议中的TV/Volume-命令*'
- en: The address specifies a device (in our case, always 0x01 for TV), and the command
    specifies the input to that device. Table 12-1 lists some of the command codes
    for the Sony TV protocol.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 地址指定了一个设备（在我们的案例中，总是0x01用于电视），命令指定了该设备的输入。表12-1列出了索尼电视协议的一些命令代码。
- en: '**Table 12-1:** Device Addresses and Command Codes in the Sony TV Protocol'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-1：索尼电视协议中的设备地址和命令代码**'
- en: '![](../images/223-3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/223-3.jpg)'
- en: For the Laddie appliance, we use the commands Channel+, Channel–, Volume+, Volume–,
    and Power. Of course, the Laddie appliance doesn’t really have channels or volume
    levels; we have simply chosen these as convenient inputs for the framebuffer menu
    navigation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Laddie设备，我们使用Channel+、Channel-、Volume+、Volume-和Power命令。当然，Laddie设备实际上并没有频道或音量级别；我们只是简单地选择了这些作为framebuffer菜单导航的方便输入。
- en: There are many other remote control protocols, and each represents a set of
    engineering trade-offs. For example, Panasonic’s REC-80 protocol uses constant-width
    pulses and encodes zeros and ones by the length of the space between pulses. This
    approach can lead to longer battery life because it minimizes the amount of time
    the remote control spends emitting light. Other protocols save battery life by
    transmitting a short “Repeat” command when a button is held down, rather than
    repeatedly transmitting the entire command, as the Sony TV protocol does.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他的遥控器协议，每个都代表了一套工程权衡。例如，松下（Panasonic）的REC-80协议使用恒定宽度的脉冲，通过脉冲之间的空间长度来编码零和一。这种方法可以通过最小化遥控器发射光的时间来延长电池寿命。其他协议通过在按钮按下时发送一个短的“重复”命令来节省电池寿命，而不是像索尼电视协议那样重复发送整个命令。
- en: '**NOTE**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn about some of these other protocols, visit* [*http://sbprojects.com/knowledge/ir/ir.htm.*](http://sbprojects.com/knowledge/ir/)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解这些其他协议，请访问* [*http://sbprojects.com/knowledge/ir/ir.htm.*](http://sbprojects.com/knowledge/ir/)'
- en: '[***Reducing Interference by Modulating the Infrared Signal***](toc.html#chapter12.3)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[***通过调制红外信号减少干扰***](toc.html#chapter12.3)'
- en: So far, we’ve treated infrared pulses as if they corresponded to steady beams
    of light. But consider Figure 12-2, and suppose that some flickering light bulb
    were to generate pulses of IR that overlapped some of the spaces in a message.
    Clearly, such interference could make it impossible for a receiver to correctly
    interpret the message. The solution is to modulate the pulses of IR light. In
    a modulated pulse, the IR light is actually turning on and off at a fixed frequency,
    typically between 30 and 60 kHz (kilohertz). Like picking out a voice in a crowded
    room, the receiver can use this frequency as a signature to discriminate the intended
    signal from the background noise. Because of this modulation, the pulse-coded
    zeros and ones of the Sony TV protocol are more accurately depicted as in Figure
    12-3.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将红外脉冲视为与稳定的激光束相对应。但考虑图12-2，假设一个闪烁的灯泡生成一些红外脉冲，这些脉冲与消息中的某些空间重叠。显然，这种干扰可能会使接收器无法正确解释消息。解决方案是对红外脉冲进行调制。在调制的脉冲中，红外光实际上以固定的频率打开和关闭，通常在30到60千赫兹（千赫）之间。就像在拥挤的房间里辨认出一个声音一样，接收器可以使用这个频率作为签名来区分预期的信号和背景噪声。正因为这种调制，索尼电视协议的脉冲编码的零和一更准确地表示如图12-3所示。
- en: '![](../images/224-1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/224-1.jpg)'
- en: '*Figure 12-3: Modulated pulses in the Sony TV protocol*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：索尼电视协议中的调制脉冲*'
- en: We measured the modulation frequency for our remote as roughly 40 kHz. Thus,
    for our remote, the zero “pulse” in Figure 12-3 actually consists of 40,000 *
    0.000650 = 26 much shorter pulses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测量了我们的遥控器的调制频率大约为40千赫兹。因此，对于我们的遥控器，图12-3中的零“脉冲”实际上由40,000 * 0.000650 = 26个更短的脉冲组成。
- en: '[***Controlling an Appliance with Infrared Light***](toc.html#chapter12.4)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用红外光控制电器***](toc.html#chapter12.4)'
- en: Now that we’ve seen how infrared light can convey information, we can design
    a system for implementing remote control of an application. Figure 12-4 illustrates
    such a system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到红外光如何传递信息，我们可以设计一个系统来实现应用程序的遥控。图12-4展示了这样一个系统。
- en: '![](../images/224-2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/224-2.jpg)'
- en: '*Figure 12-4: A complete remote control system*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：一个完整的遥控系统*'
- en: 'On the transmitting side, a typical handheld remote control performs the following
    steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在发射端，典型的手持遥控器执行以下步骤：
- en: It scans a *keypad*.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它扫描一个*键盘*。
- en: It *encodes* the input as a waveform according to some protocol.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它根据某种协议将输入编码为波形。
- en: It *modulates* this encoding with a frequency between 30 and 60 kHz.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用30到60千赫兹的频率对这个编码进行调制。
- en: It *emits* a corresponding pattern of infrared light.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它*发射*一个相应的红外光模式。
- en: 'On the receiving side, a typical IR receiver performs the following stages:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接收端，典型的红外接收器执行以下阶段：
- en: An infrared *detector* converts the input signal to a voltage waveform.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个红外*检测器*将输入信号转换为电压波形。
- en: A *demodulator* removes the 30 to 60 kHz modulation.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*解调器*移除30到60千赫兹的调制。
- en: A *decoder* analyzes this waveform and determines the corresponding command.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*解码器*分析这个波形并确定相应的命令。
- en: An *application* responds appropriately to this input.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个*应用程序*会相应地响应这个输入。
- en: '[**Hardware for Remote Control Receivers**](toc.html#chapter12.5)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[**遥控接收器的硬件**](toc.html#chapter12.5)'
- en: 'In this section we’ll focus on IR receiver hardware. Designing remote control
    transmitters is beyond the scope of this chapter, but our recommendation is to
    take the same approach we took with the Laddie appliance: Use an off-the-shelf,
    universal remote.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注红外接收器硬件。设计遥控发射器超出了本章的范围，但我们的建议是采用与Laddie设备相同的方法：使用现成的通用遥控器。
- en: '[***Detecting and Demodulating the IR Signal***](toc.html#chapter12.6)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[***检测和调谐红外信号***](toc.html#chapter12.6)'
- en: The two stages of detecting and demodulating an IR input can be handled by a
    single, commercial, off-the-shelf component. Figure 12-5 shows three examples
    of this part, all produced by Sharp Microelectronics.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 检测和调谐红外输入的两个阶段可以由一个单一的、商业的现成组件处理。图12-5显示了该组件的三个示例，均由夏普微电子公司生产。
- en: '![](../images/225-1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/225-1.jpg)'
- en: '*Figure 12-5: Infrared detector/demodulators*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：红外检测/解调器*'
- en: For the Laddie appliance, we chose the 40 kHz unit from Sharp’s GP1UV70QS series
    (pictured on the right in Figure 12-5). Also popular is the TSOP17XX series from
    Vishay. Each of these parts is easy to use with perfboard or solderless breadboard
    prototyping materials. Each requires a 5V power supply and provides an output
    corresponding to the demodulated IR waveform (see step 6 in Figure 12-4). When
    evaluating a particular device, make sure the demodulation frequency is appropriate
    for your chosen protocol. For low-power applications, you’ll also want to compare
    the power requirements for different devices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Laddie设备，我们选择了Sharp的GP1UV70QS系列中的40 kHz单元（如图12-5右侧所示）。Vishay的TSOP17XX系列也很受欢迎。这些部件都很容易与穿孔板或无焊面包板原型材料一起使用。每个都需要5V电源，并提供与解调红外波形相对应的输出（见图12-4的第6步）。在评估特定设备时，请确保解调频率适合你选择的协议。对于低功耗应用，你还需要比较不同设备的功耗要求。
- en: There isn’t a standard nomenclature for these devices. When you’re searching
    for information, expect to see names like “IR Remote Receiver,” “Photo Module
    for Remote Control,” or “Infrared Detecting Unit for Remote Control.” In the remainder
    of this chapter, we’ll refer to them as *infrared detector/demodulators* to emphasize
    the two functions they provide.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备没有标准的命名法。当你搜索信息时，可能会看到像“红外遥控接收器”、“遥控器用光电模块”或“遥控器用红外检测单元”这样的名称。在本章的剩余部分，我们将把它们称为*红外检测/解调器*，以强调它们提供的两个功能。
- en: '**BUILDING A SIM PLE IR DETECTOR**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建一个简单的红外检测器**'
- en: If you have access to an oscilloscope and would like to see a remote control
    signal *before* it is demodulated, you can build the simple IR detector circuit
    depicted in Figure 12-6\. All you need is a power supply (a 9V battery is fine),
    an appropriately valued resistor, and a phototransistor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个示波器并且想看到解调之前的遥控信号，你可以构建图12-6所示的简单红外检测电路。你需要的只是一个电源（9V电池就足够了）、一个适当值的电阻和一个光电晶体管。
- en: '![](../images/226-1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/226-1.jpg)'
- en: '*Figure 12-6: A simple IR detector*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：一个简单的红外检测器*'
- en: You’ll want to choose the resistor so that the output voltage is about half
    of the supply voltage when the remote control is off. When we tried this, we used
    a 100K resistor, and we held the remote control very close to the detector. We
    had good results both with a Radio Shack infrared phototransistor (catalog number
    276-142) and when using another, unidentified, phototransistor we happened to
    have lying around. The output will be weak, but it should be adequate for an oscilloscope.
    By the way, this experiment is also useful if you need to determine the modulation
    frequency for an unfamiliar protocol.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要选择一个电阻，使得当遥控器关闭时输出电压大约是电源电压的一半。当我们尝试这样做时，我们使用了一个100K的电阻，并将遥控器紧紧地靠近探测器。我们使用Radio
    Shack红外光电晶体管（目录号276-142）和另一个我们偶然拥有的未标识的光电晶体管都取得了良好的结果。输出将很弱，但对于示波器来说应该是足够的。顺便说一句，这个实验如果你需要确定一个不熟悉的协议的调制频率也是很有用的。
- en: '[***Decoding Remote Control Waveforms***](toc.html#chapter12.7)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[***解码遥控波形***](toc.html#chapter12.7)'
- en: 'In the previous section we introduced off-the-shelf devices that will respond
    to a remote control IR signal and produce a demodulated voltage waveform. Before
    designing a circuit to take advantage of these devices, we need to decide how
    we will decode that waveform. Decoding can be broken into two steps: *measuring*
    the timing of the pulses and spaces that comprise a waveform and *interpreting*
    this sequence of timings to identify the intended message. We have three options
    for designing a decoder, depending on which of these two tasks we assign to external
    hardware and which we assign to the appliance’s processor. We’ll briefly discuss
    these three options before describing the approach we took for the Laddie appliance.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了那些会对遥控红外信号做出响应并产生解调电压波形的现成设备。在设计利用这些设备的电路之前，我们需要决定如何解码该波形。解码可以分为两个步骤：*测量*组成波形的脉冲和间隔的时间以及*解释*这些时间序列以识别预期的信息。根据我们将哪些任务分配给外部硬件以及哪些任务分配给设备的处理器，我们有三种设计解码器的方法。在描述我们对Laddie设备所采取的方法之前，我们将简要讨论这三种方法。
- en: '**Measuring and Interpreting in External Hardware**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**在外部硬件中进行测量和解释**'
- en: 'It’s possible to build receiver hardware that performs all of the decoding
    tasks: measuring the waveform, determining the corresponding command, and then
    transmitting that command as one or more serial bytes to the appliance’s processor.
    Figure 12-7 illustrates this approach. Here, the receiver has recognized the waveform
    for the Volume– command and has produced the single ASCII character *D* for *down*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以构建执行所有解码任务的接收器硬件：测量波形、确定相应的命令，然后将该命令作为一个或多个串行字节传输到设备处理器。图12-7说明了这种方法。在这里，接收器已经识别出Volume-命令的波形，并生成了表示*下*的单个ASCII字符*D*。
- en: '![](../images/227-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/227-1.jpg)'
- en: '*Figure 12-7: Decoding waveforms in external hardware*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：在外部硬件中解码波形*'
- en: The website [http://linuxtoys.org/xirrc/xirrc.html](http://linuxtoys.org/xirrc/xirrc.html)
    describes an example of this approach in which a preprogrammed Microchip PIC microcontroller
    is used to decode Sony remote control commands and transmit command characters
    to a serial port.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 网站http://linuxtoys.org/xirrc/xirrc.html描述了这种方法的一个例子，其中使用预先编程的Microchip PIC微控制器来解码索尼遥控命令并将命令字符传输到串行端口。
- en: A limitation of this approach is that the receiver supports only one remote
    control protocol. On the positive side, this approach makes it incredibly easy
    to add remote control to your appliance. Just plug in the receiver and listen
    for commands on the serial port.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的局限性在于接收器只支持一种遥控协议。从积极的一面来看，这种方法使得向您的设备添加遥控变得极其简单。只需插入接收器，并在串行端口上监听命令即可。
- en: '**Measuring in Hardware and Interpreting on the Appliance**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**在硬件中测量并在设备上解释**'
- en: In order to accommodate any remote control protocol, we can build receiver hardware
    that measures waveforms but passes the timing information to the appliance’s processor
    for interpretation. Figure 12-8 illustrates an approach in which the timing of
    the pulses and spaces is encoded as a series of bytes, each representing time
    in 50-microsecond increments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应任何遥控协议，我们可以构建测量波形但将时序信息传递给设备处理器的接收器硬件。图12-8说明了这种方法，其中脉冲和空间的时序被编码为一系列字节，每个字节代表50微秒的时间增量。
- en: '![](../images/227-2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/227-2.jpg)'
- en: '*Figure 12-8: Measuring waveform timing in external hardware*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：在外部硬件中测量波形时序*'
- en: Since the appliance is given a complete representation of the input waveform,
    it can, in theory, decode waveforms for any protocol. The LIRC website provides
    a link for a protocol called Universal Infrared Remote Transceiver, second version
    (UIRT2), which works out the details of this approach. It is described at [http://users.skynet.be/sky50985](http://users.skynet.be/sky50985).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备得到了输入波形的完整表示，理论上它可以解码任何协议的波形。LIRC网站提供了一个名为通用红外遥控收发器第二版(UIRT2)的协议链接，该协议详细说明了这种方法。它可在[http://users.skynet.be/sky50985](http://users.skynet.be/sky50985)找到。
- en: As a related example, the Irman remote control receiver, available at [http://www.evation.com/irman/index.html](http://www.evation.com/irman/index.html),
    takes an innovative approach and encodes any remote control command waveform by
    creating “pseudorandom” signatures of six bytes. Irman works on the assumption
    that different waveforms from a given remote will almost invariably have different
    signatures. Because this technique applies to any waveform, this type of receiver
    can work with any of the common remote control protocols, but the user has to
    train it to interpret the signatures it derives.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为相关的一个例子，Irman遥控接收器，可在[http://www.evation.com/irman/index.html](http://www.evation.com/irman/index.html)找到，采用了一种创新的方法，通过创建六个字节的“伪随机”签名来编码任何遥控命令波形。Irman基于这样的假设：来自给定遥控器的不同波形几乎总是具有不同的签名。因为这种技术适用于任何波形，这种类型的接收器可以与任何常见的遥控协议一起工作，但用户必须训练它来解释它推导出的签名。
- en: As a third example, the LIRC website refers to the USB-IR-Boy project. This
    project uses the inexpensive Freescale MC68HC908JB8 microcontroller with built-in
    USB support to provide IR waveform timing values. It also includes a Linux device
    driver to make these timing values available via the /dev/usbirboy device file.
    Information is available at [http://usbirboy.sourceforge.net](http://usbirboy.sourceforge.net).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第三个例子，LIRC网站提到了USB-IR-Boy项目。该项目使用带有内置USB支持的廉价Freescale MC68HC908JB8微控制器来提供红外波形时序值。它还包括一个Linux设备驱动程序，通过/dev/usbirboy设备文件使这些时序值可用。信息可在[http://usbirboy.sourceforge.net](http://usbirboy.sourceforge.net)找到。
- en: '**Measuring and Interpreting on the Appliance**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**在设备上测量和解释**'
- en: The third approach to decoding waveforms is appealing because of its simple
    hardware requirements. All the hardware has to do is power an infrared detector/demodulator
    and provide the signal as an input to the appliance’s processor. On the negative
    side, this method does place extra demands on the processor. Specifically, the
    processor must respond to an interrupt every time the input signal transitions
    high or low in order to measure timing information. Nevertheless, because of the
    simple hardware requirements, we have chosen this third approach for the Laddie
    appliance. In the next section we will work through the details of building this
    kind of receiver.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解码波形的三种方法中，第三种因其简单的硬件要求而颇具吸引力。所有硬件需要做的只是为红外检测器/解调器供电，并将信号作为输入提供给设备的处理器。然而，这种方法确实对处理器提出了额外的要求。具体来说，处理器必须对输入信号每次从高到低或从低到高的转换做出响应，以便测量时间信息。尽管如此，由于硬件要求简单，我们还是选择了这种第三种方法用于Laddie设备。在下一节中，我们将详细讨论构建这种接收器的细节。
- en: '[***Infrared Remote Control Hardware for the Laddie Appliance***](toc.html#chapter12.8)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Laddie设备的红外遥控硬件***](toc.html#chapter12.8)'
- en: If you’re not comfortable with building hardware, you might seek out a friend
    who is, or—this is our recommendation—jump in and build it yourself anyway. It’s
    a good first project and a satisfying one because of the new mode of control it
    gives you for your Linux projects. You will certainly find the remainder of this
    chapter more educational if you have hardware to experiment with.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不擅长构建硬件，您可能需要寻找一个擅长的人，或者——这是我们的建议——不管怎样都自己动手做。这是一个很好的入门项目，因为它为您提供了对Linux项目的新控制方式。如果您有硬件可以实验，您会发现本章的其余部分更具教育意义。
- en: 'To integrate our simple IR receiver with an appliance, we need two things:
    a power source for the IR detector/demodulator and an input that generates interrupts.
    The good news is that a typical serial port satisfies both requirements. The output
    pins on a serial port provide adequate power, and its Data Carrier Detect (DCD)
    input pin generates interrupts. The bad news is that the serial port output voltages
    range from 3.7V to 12V on the positive side and from -3.7V to -12V on the negative
    side. Moreover, the serial port inputs require a swing between these same positive
    and negative ranges. An IR detector, however, expects a clean 5V power supply
    (for some parts, 3.3V); it outputs a 0V to 5V signal (for some parts, 0V to 3.3V).
    Thus, if you want to use a serial port input, you will need additional circuitry
    to provide the required voltage for the detector and to shift the detector output
    to valid serial port levels. Figure 12-9 illustrates this kind of circuit.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的简单红外接收器集成到设备中，我们需要两样东西：为红外检测器/解调器供电的电源以及生成中断的输入。好消息是，典型的串行端口满足这两个要求。串行端口的输出引脚提供足够的电源，并且其数据载波检测（DCD）输入引脚生成中断。坏消息是，串行端口的输出电压在正侧从3.7V到12V不等，在负侧从-3.7V到-12V不等。此外，串行端口输入需要在这些相同的正负范围内摆动。然而，红外检测器期望一个干净的5V电源（对于某些部件，为3.3V）；它输出0V到5V的信号（对于某些部件，为0V到3.3V）。因此，如果您想使用串行端口输入，您将需要额外的电路来为检测器提供所需的电压，并将检测器输出转换为有效的串行端口电平。图12-9展示了这种类型的电路。
- en: '![](../images/229-1.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/229-1.jpg)'
- en: '*Figure 12-9: A block diagram for a simple IR receiver*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-9：简单红外接收器的框图*'
- en: Here we assume the serial port has been configured to keep the Request to Send
    (RTS) output at a high voltage level and the Transmit Data (TXD) output at a low
    voltage level. The 5V regulator provides the voltage required by the detector.
    The level shifter provides the correct voltage levels to the DCD input.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设串行端口已配置为保持请求发送（RTS）输出在高电压水平，而发送数据（TXD）输出在低电压水平。5V稳压器为检测器提供所需的电压。电平转换器为DCD输入提供正确的电压水平。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you look at IR receiver circuits presented on the Web, you’ll find some
    that take a simpler approach, omitting the level-shifter and providing an output
    that swings between 0V and 5V. This may work for your computer. If not, or if
    you want a more robust solution, take the approach we’ve chosen here.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您在网上查看所提供的红外接收器电路，您会发现一些采用更简单的方法，省略了电平转换器，并提供在0V和5V之间摆动的输出。这可能适用于您的计算机。如果不适用，或者如果您需要一个更稳健的解决方案，请采用我们这里选择的方法。*'
- en: Figure 12-10 shows the schematic we chose for the Laddie IR receiver.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-10显示了我们为Laddie红外接收器选择的原理图。
- en: '![](../images/229-2.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/229-2.jpg)'
- en: '*Figure 12-10: The IR receiver schematic used for the Laddie appliance*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-10：用于Laddie设备的红外接收器原理图*'
- en: Here, U1 is an off-the-shelf IR detector/demodulator, U2 is a linear voltage
    regulator that provides 5V to U1, and the transistor/resistor circuit is the level-shifter
    that provides an output appropriate for the serial port. The diode, D1, protects
    the circuit in case the RTS signal is improperly initialized, which may cause
    it to go negative relative to TXD. Table 12-2 provides the specific parts that
    we’ve used, with their approximate costs. Where we’ve listed multiple parts, you
    can assume they are interchangeable. Between Digi-Key ([http://www.digikey.com](http://www.digikey.com/))
    and Jameco Electronics ([http://www.jameco.com](http://www.jameco.com/)), you
    shouldn’t have any trouble finding these parts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，U1是一个现成的红外检测/解调器，U2是一个线性稳压器，为U1提供5V，而晶体管/电阻电路是电平转换器，为串行端口提供适当的输出。二极管D1在RTS信号不正确初始化时保护电路，这可能导致它与TXD相对于负电压。表12-2提供了我们使用的具体零件及其大约成本。在我们列出多个零件的地方，你可以假设它们可以互换。在Digi-Key
    ([http://www.digikey.com](http://www.digikey.com/)) 和 Jameco Electronics ([http://www.jameco.com](http://www.jameco.com/))，你
    shouldn't have any trouble finding these parts.
- en: '**Table 12-2:** Parts List for the Laddie Appliance’s IR Receiver'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**表12-2：Laddie设备红外接收器的零件清单**'
- en: '![](../images/230-1.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/230-1.jpg)'
- en: Figure 12-11 shows a few of our prototypes. We recommend starting with a solderless
    breadboard and 22 AWG solid (non-stranded) wire, as pictured on the left. You’ll
    also need a wire stripper for the 22 AWG wire and a voltmeter for debugging. The
    one place you’ll want to use a soldering iron is to connect wires to the DB9 serial
    connector. In the left picture, two wires from the DB9 connector provide power
    and ground to the strips along the edges of the breadboard. The third wire provides
    the DCD signal back to the computer via the serial cable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-11展示了我们的几个原型。我们建议从无焊点面包板和22 AWG实心（非绞合）电线开始，如图左侧所示。你还需要一个22 AWG电线的剥线器和示波器进行调试。你想要使用烙铁的地方是将电线连接到DB9串行连接器。在左侧的图片中，DB9连接器的两根电线为面包板边缘的条带提供电源和地。第三根电线通过串行电缆将DCD信号返回到计算机。
- en: '![](../images/230-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/230-2.jpg)'
- en: '*Figure 12-11: Two prototypes for an infrared remote receiver*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-11：红外遥控接收器的两个原型*'
- en: Once you have a working circuit, you can build something more permanent using
    perfboard and a plastic enclosure. In the picture on the right, only one side
    of the enclosure is shown. We drilled a hole at one side for the IR detector/demodulator
    and cut a hole on the other side for the DB9 connector. A piece of cardboard holds
    the detector/demodulator in place.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个工作电路，你可以使用穿孔板和塑料外壳构建更永久的东西。在右侧的图片中，只显示了外壳的一侧。我们在一侧钻了一个孔用于红外检测/解调器，并在另一侧切了一个孔用于DB9连接器。一块纸板将检测/解调器固定在位置。
- en: 'When building your prototype, follow these steps to make sure the circuit is
    operating properly:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建你的原型时，遵循以下步骤以确保电路正常工作：
- en: Build the circuit, but don’t connect the serial port or the IR detector/ demodulator.
    In place of the RTS and TXD pins, use a 9V battery for power. Use the positive
    battery terminal in place of the RTS input and the negative terminal in place
    of the TXD input.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建电路，但不要连接串行端口或红外检测/解调器。在RTS和TXD引脚的位置，使用9V电池供电。用电池的正极代替RTS输入，用负极代替TXD输入。
- en: Verify that the voltage between the regulator output and the negative battery
    terminal is 5V.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证稳压器输出和负电池端之间的电压为5V。
- en: Verify that the voltage between the circuit output and the negative battery
    terminal is at least 8V. (The “circuit output” is the point that you will later
    connect to the DCD pin of the serial port.)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证电路输出和负电池端之间的电压至少为8V。（“电路输出”是你稍后将要连接到串行端口DCD引脚的点。）
- en: Now connect the open end of R1 to the 5V output of the regulator, and verify
    that the voltage between the circuit output and the negative battery terminal
    is zero volts.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将R1的开口端连接到稳压器的5V输出，并验证电路输出和负电池端之间的电压为零伏。
- en: Finally, complete the circuit by adding the IR detector/demodulator and connecting
    your computer’s serial port.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加红外检测/解调器并将计算机的串行端口连接起来，完成电路。
- en: The remaining tests for your IR receiver hardware require the LIRC software.
    In the next section, we’ll introduce the LIRC software package and describe how
    we incorporated it into the Laddie appliance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的红外接收器硬件的剩余测试需要LIRC软件。在下一节中，我们将介绍LIRC软件包，并描述我们如何将其集成到Laddie设备中。
- en: '[**Installing and Configuring LIRC for the Laddie Appliance**](toc.html#chapter12.9)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[**为Laddie设备安装和配置LIRC**](toc.html#chapter12.9)'
- en: The LIRC software package can be downloaded from [http://www.lirc.org](http://www.lirc.org/);
    it includes an extensive collection of device drivers, daemons, and tools for
    controlling user applications with remote control hardware. We don’t have room
    to cover all of these elements here, but we will present the layers that make
    up this software architecture, and we will describe in detail the particular device
    driver and daemon that are appropriate for the Laddie appliance. Once you’ve understood
    this subset, you should find it easy to master any other parts of the architecture
    required for your own appliance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC软件包可以从[http://www.lirc.org](http://www.lirc.org/)下载；它包括大量用于使用遥控器硬件控制用户应用程序的设备驱动程序、守护进程和工具。我们没有足够的空间在这里涵盖所有这些元素，但我们将展示构成此软件架构的层，并将详细描述适用于Laddie设备的特定设备驱动程序和守护进程。一旦你理解了这个子集，你应该会发现掌握你自己的设备所需的任何其他架构部分都很容易。
- en: Figure 12-12 provides a high-level view of the LIRC software architecture as
    it applies to the Laddie appliance. At the right of the diagram, we’ve shown how
    elements of the LIRC architecture correspond to our earlier, more general discussion
    of IR receivers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-12展示了LIRC软件架构在Laddie设备中的应用的高级视图。在图的右侧，我们展示了LIRC架构的元素如何对应我们之前关于红外接收器的更一般性讨论。
- en: '![](../images/232-1.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/232-1.jpg)'
- en: '*Figure 12-12: The LIRC architecture*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-12：LIRC架构*'
- en: In kernel space, a device driver accesses the receiver hardware through an external
    port. For our appliance, this driver is provided by the LIRC package and uses
    interrupts to perform waveform timing on the input waveform.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核空间中，设备驱动程序通过外部端口访问接收器硬件。对于我们的设备，该驱动程序由LIRC软件包提供，并使用中断在输入波形上执行波形定时。
- en: '**NOTE**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As you saw in the section “Decoding Remote Control Waveforms” on page 203,
    there are some IR receivers that perform the waveform timing and possibly even
    the waveform interpretation in external hardware. For these receivers, the kernel
    device driver may be a generic Linux serial driver or a USB driver.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你在第203页“解码遥控波形”部分所看到的，有些红外接收器在外部硬件中执行波形定时，甚至可能执行波形解释。对于这些接收器，内核设备驱动程序可能是一个通用的Linux串行驱动程序或USB驱动程序。*'
- en: In user space, for systems such as ours that don’t perform interpretation in
    external hardware, we use the lircd daemon. This daemon accesses a configuration
    file that characterizes the remote control’s command protocol and analyzes the
    timing information provided by the device driver to generate the corresponding
    commands. In some cases, the user application will access the output of the lircd
    daemon directly. The Laddie appliance takes this approach. For applications that
    were not built with the lircd daemon in mind, several LIRC tools are available
    to process the output of the lircd daemon and provide program input, execute appropriate
    commands, or simulate mouse or keyboard events. We’ll discuss these tools later
    in the section “LIRC Tools for Controlling Applications” on page 218.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间中，对于像我们这样的不在外部硬件中执行解释的系统，我们使用lircd守护进程。该守护进程访问一个配置文件，该文件描述了遥控器的命令协议，并分析设备驱动程序提供的定时信息以生成相应的命令。在某些情况下，用户应用程序将直接访问lircd守护进程的输出。Laddie设备采用这种方法。对于没有考虑lircd守护进程的应用程序，有几个LIRC工具可用于处理lircd守护进程的输出，提供程序输入，执行适当的命令或模拟鼠标或键盘事件。我们将在第218页的“用于控制应用程序的LIRC工具”部分讨论这些工具。
- en: In the remainder of this chapter, we will describe in detail the elements of
    the LIRC architecture and show how we configured LIRC for the Laddie appliance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将详细描述LIRC架构的元素，并展示我们如何为Laddie设备配置LIRC。
- en: '[***Installing the LIRC Software***](toc.html#chapter12.10)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[***安装LIRC软件***](toc.html#chapter12.10)'
- en: The LIRC package is included on this book’s companion CD, and we recommend you
    use the CD when working through the examples in this chapter. However, if you
    need to set up your own system in the future, we will describe the steps we took
    to install the package.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC软件包包含在本书的配套CD中，我们建议您在处理本章中的示例时使用CD。然而，如果您未来需要设置自己的系统，我们将描述我们安装该软件包所采取的步骤。
- en: 'We downloaded version lirc-0.8.1 from [http://www.lirc.org](http://www.lirc.org/)
    and installed it with these commands:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[http://www.lirc.org](http://www.lirc.org/)下载了版本lirc-0.8.1，并使用以下命令安装：
- en: '![](../images/233-1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/233-1.jpg)'
- en: The setup.sh script asked us to make choices about our installation. Under the
    Driver Configuration (driver:serial io:0x3f8 irq:4) menu, we chose the **Home-brew
    (16x50 UART compatible serial port)** driver, selected **COM1 (0x3f8, 4)** for
    the base address and IRQ, and disabled all driver-specific options. Under the
    Software Configuration menu, we disabled all options. Then we selected **Save
    Configuration and exit**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: setup.sh脚本要求我们做出关于安装的选择。在驱动程序配置（驱动程序：串行io：0x3f8 中断：4）菜单下，我们选择了**自制（16x50 UART兼容串行端口）**驱动程序，为基本地址和中断选择了**COM1（0x3f8，4）**，并禁用了所有驱动程序特定的选项。在软件配置菜单下，我们禁用了所有选项。然后我们选择了**保存配置并退出**。
- en: LIRC is a package that allows you to decode and send IR and other signals of
    many (but not all) commonly used remote controls. It includes daemons that decode
    the received signals as well as user space applications that allow controlling
    a computer with a remote control.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC是一个允许你解码和发送许多（但不是所有）常用遥控器红外和其他信号的包。它包括解码接收信号的守护进程以及允许使用遥控器控制计算机的用户空间应用程序。
- en: The ./configure --help command provided a long list of driver choices, as well
    as a dauntingly long list of configuration options. For our appliance, the defaults
    were generally appropriate. We only needed to provide the location of our Linux
    kernel source tree using the --with-kerneldir option and to specify the serial
    driver with the --with-driver option.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ./configure --help命令提供了一个长长的驱动程序选择列表，以及一个令人敬畏的长配置选项列表。对于我们的设备，默认值通常是合适的。我们只需要使用--with-kerneldir选项提供Linux内核源树的位置，并使用--with-driver选项指定串行驱动程序。
- en: Figure 12-13 shows how representative components installed by the LIRC package
    fit into the LIRC software architecture. Although the LIRC package includes utilities
    that support the X Window System, we don’t show them here, since the Laddie appliance
    doesn’t use X.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-13显示了LIRC包安装的代表组件如何适应LIRC软件架构。尽管LIRC包包括支持X窗口系统的实用程序，但我们在这里没有展示它们，因为Laddie设备不使用X。
- en: '![](../images/233-2.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/233-2.jpg)'
- en: '*Figure 12-13: Components of the LIRC package*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-13：LIRC包的组件*'
- en: Before we dive into the details, let’s start with a quick, bottom-to-top tour
    and explain how the LIRC receiver controls the Laddie appliance’s frame-buffer
    UI, which is described in Chapter 11\. The IR receiver external hardware provides
    the remote control waveform to the DCD pin of a serial port. In kernel space,
    the lirc_serial device driver (one of many included in the LIRC package) monitors
    this pin and produces a binary stream of timing data via the device file /dev/lirc.
    In user space, the lircd daemon analyzes the timing data from the /dev/lirc device
    file to provide a sequence of command strings on the Unix socket /dev/lircd. The
    framebuffer UI connects directly to this socket in order to respond to user input.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们先进行一次快速的上至下的浏览，并解释LIRC接收器是如何控制Laddie设备框架缓冲区UI的，这部分内容在第11章中有详细描述。外部红外接收器硬件将遥控波形提供给串口的DCD引脚。在内核空间中，lirc_serial设备驱动程序（LIRC包中包含的许多驱动程序之一）监控这个引脚，并通过设备文件/dev/lirc产生一个二进制的时间数据流。在用户空间中，lircd守护进程分析来自/dev/lirc设备文件的时间数据，以便在Unix套接字/dev/lircd上提供一系列命令字符串。帧缓冲区UI直接连接到这个套接字，以便响应用户输入。
- en: Now for all the details we left out. In the remainder of this section, we will
    look more carefully at each of the layers of the LIRC software architecture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来详细说明我们之前省略的部分。在本节的剩余部分，我们将更仔细地查看LIRC软件架构的每一层。
- en: '[***Configuring the lirc_serial Kernel Device Driver***](toc.html#chapter12.11)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[***配置lirc_serial内核设备驱动程序***](toc.html#chapter12.11)'
- en: 'The lirc_serial device driver is actually implemented by two kernel modules,
    lirc_serial.ko and lirc_dev.ko, which were placed in the directory /lib/ modules/2.6.10/misc/
    when we installed the software. In order to use these modules, we had to perform
    three additional steps: free up a serial port, create a device file, and load
    the modules into the kernel. We created a startup script, lircd, to perform these
    steps. We will review the steps here; you can see the complete code on the CD
    in the /etc/rc.d/init.d directory.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: lirc_serial设备驱动程序实际上由两个内核模块实现，即lirc_serial.ko和lirc_dev.ko，我们在安装软件时将它们放置在目录/lib/modules/2.6.10/misc/中。为了使用这些模块，我们必须执行三个额外的步骤：释放一个串行端口、创建一个设备文件，并将模块加载到内核中。我们创建了一个启动脚本lircd来执行这些步骤。我们在这里将回顾这些步骤；你可以在CD的/etc/rc.d/init.d目录中看到完整的代码。
- en: '**Freeing Up a Serial Port**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**释放串行端口**'
- en: 'For the Laddie appliance’s IR receiver input port, we chose COM1 (/dev/ ttyS0).
    The Linux kernel typically enables COM1 through COM4 as serial ports at startup;
    thus, we needed to free up COM1 for LIRC. To do this, we used the setserial command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Laddie设备的IR接收器输入端口，我们选择了COM1(/dev/ttyS0)。Linux内核通常在启动时将COM1至COM4作为串行端口启用；因此，我们需要为LIRC释放COM1。为此，我们使用了setserial命令：
- en: setserial /dev/ttyS0 uart none
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: setserial /dev/ttyS0 uart none
- en: By setting the type of the hardware (the UART) to *none,* this command disabled
    the specified port.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将硬件类型（UART）设置为*none*，此命令禁用了指定的端口。
- en: '**NOTE**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*UART stands for Universal Asynchronous Receiver Transmitter. A UART handles
    the low-level implementation of a serial link so that the CPU need only be concerned
    with providing bytes to transmit and processing bytes that are received.*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*UART代表通用异步接收发送器。UART处理串行链路的底层实现，这样CPU只需关注提供要发送的字节和处理接收的字节即可。*'
- en: 'For the remainder of this chapter, we recommend that you boot the Laddie appliance
    using the Laddie CD and follow along with the exercises. After booting the CD,
    exit the framebuffer UI (press ESC), and log in as root with an empty password.
    Verify that port COM1 was configured properly by executing the following command
    at the laddie:~# prompt:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们建议您使用Laddie CD启动Laddie设备，并跟随练习进行。启动CD后，退出framebuffer UI（按ESC键），以空密码作为root用户登录。在laddie:~#提示符下执行以下命令以验证COM1端口是否已正确配置：
- en: '**laddie:~#** setserial /dev/ttyS0'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** setserial /dev/ttyS0'
- en: 'You should see the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '/dev/ttyS0, UART: unknown, Port: 0x03f8, IRQ: 4'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '/dev/ttyS0, UART: 未知，端口：0x03f8，中断：4'
- en: The UART type is unknown, which means the port is available.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: UART类型未知，这意味着端口可用。
- en: '**Creating a Device File**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建设备文件**'
- en: You may recall from the previous chapter that we used a device file /dev/fb0
    to expose the framebuffer functionality. Similarly, we had to provide a device
    file to expose the lirc_serial functionality. The following code created the character
    device file /dev/lirc with major number 61 and minor number 0, as required for
    the lirc driver.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，在前一章中我们使用了设备文件/dev/fb0来公开framebuffer功能。同样，我们必须提供一个设备文件来公开lirc_serial功能。以下代码创建了一个字符设备文件/dev/lirc，主设备号为61，次设备号为0，这是lirc驱动程序所需的。
- en: This indicates that the file represents a character device that is ![](../images/1.jpg)
    readable and writable by root, ![](../images/2.jpg) with major number 61, and
    ![](../images/3.jpg) with minor number 0.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明该文件表示一个字符设备，该设备由root可读写，![图片](../images/2.jpg)主设备号为61，![图片](../images/3.jpg)次设备号为0。
- en: '**Loading the lirc_ serial Modules into the Kernel**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**将lirc_serial模块加载到内核中**'
- en: 'With the serial port available and the device file in place, we were able to
    load the lirc_serial device driver using the modprobe command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在串行端口可用且设备文件就绪的情况下，我们能够使用modprobe命令加载lirc_serial设备驱动程序：
- en: modprobe lirc_serial
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: modprobe lirc_serial
- en: 'To verify that the lirc_serial device driver is loaded, execute the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证lirc_serial设备驱动程序是否已加载，请执行以下操作：
- en: '**laddie:~#** lsmod | grep lirc'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** lsmod | grep lirc'
- en: 'You should see output like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下输出：
- en: '![](../images/235-2.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/235-2.jpg)'
- en: The first column shows the loaded modules; the fourth column shows dependencies.
    Here we see that ![](../images/1.jpg) the lirc_serial module depends on ![](../images/2.jpg)
    the lirc_dev module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列显示已加载的模块；第四列显示依赖关系。在这里我们看到lirc_serial模块依赖于![图片](../images/1.jpg)lirc_dev模块。
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If we had wanted to use a different port than COM1 for our IR receiver, we
    would have provided additional arguments to the lirc_serial driver with the* modprobe
    *command. To specify COM2, we would have used the command* modprobe lirc_serial
    irq=3 io=0x2f8*. The default irq and io values for COM3 and COM4 are (4, 0x3e8)
    and (3, 0x2e8), respectively.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们想为IR接收器使用不同于COM1的端口，我们将在modprobe命令中为lirc_serial驱动程序提供额外的参数。要指定COM2，我们将使用命令*
    modprobe lirc_serial irq=3 io=0x2f8*。COM3和COM4的默认irq和io值分别为(4, 0x3e8)和(3, 0x2e8)。*'
- en: '[***Testing the lirc_serial Driver***](toc.html#chapter12.12)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[***测试lirc_serial驱动程序***](toc.html#chapter12.12)'
- en: Now that we’ve verified that the lirc_serial driver is loaded properly, we can
    use the Laddie CD to test the IR receiver hardware we built earlier. We’ll begin
    by reviewing what we want to test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了lirc_serial驱动程序已正确加载，我们可以使用Laddie CD来测试我们之前构建的IR接收器硬件。我们将首先回顾我们想要测试的内容。
- en: Recall that the signal provided by our LIRC receiver looks something like Figure
    12-14 (at least in the case of a Sony TV Volume– command).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们 LIRC 接收器提供的信号看起来类似于图 12-14（至少在索尼电视音量- 命令的情况下）。
- en: '![](../images/236-1.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/236-1.jpg)'
- en: '*Figure 12-14: Waveform for the Sony TV Volume- command*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-14：索尼电视音量- 命令的波形*'
- en: The job of the lirc_serial kernel device driver is to measure the timing of
    spaces and pulses in this signal and provide that information via a device file.
    The particular waveform shown here complies with the Sony TV protocol, but the
    lirc_serial driver is designed to work with any protocol. The driver includes
    an interrupt handler that is invoked every time the DCD pin changes state. The
    handler uses a system timer to measure the pulses and spaces in microseconds,
    and then it emits this timing information via the /dev/lirc device file as a sequence
    of 32-bit words. In each word, bits 0 through 23 specify the length of the space
    or pulse in microseconds (with a maximum value of 0xFF FFFF). Bit 24 is zero for
    a space and one for a pulse. Bits 25 through 31 are always zero. To test the lirc_serial
    device driver, we’d like to verify that these values are generated when we press
    a remote control button.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: lirc_serial 内核设备驱动程序的任务是测量该信号中的空间和脉冲的时间，并通过设备文件提供这些信息。这里显示的特定波形符合索尼电视协议，但 lirc_serial
    驱动程序旨在与任何协议一起工作。驱动程序包括一个中断处理程序，每次 DCD 引脚状态改变时都会调用该处理程序。处理程序使用系统定时器测量脉冲和空间，然后通过
    /dev/lirc 设备文件以 32 位字序列的形式发出此时间信息。在每个字中，位 0 到 23 指定空间或脉冲的长度（最大值为 0xFFFF FFFF）。位
    24 对于空间为零，对于脉冲为一。位 25 到 31 总是零。为了测试 lirc_serial 设备驱动程序，我们希望验证在按下遥控器按钮时是否生成这些值。
- en: Before we can access the /dev/lirc device file, we need to make sure it’s not
    already in use by some other process. When the Laddie CD boots, it launches the
    lircd daemon in order to support the framebuffer UI. Since the lircd daemon accesses
    /dev/lirc, we prepare for our test by killing that process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以访问 /dev/lirc 设备文件之前，我们需要确保它没有被其他进程使用。当 Laddie CD 启动时，它会启动 lircd 守护进程以支持帧缓冲
    UI。由于 lircd 守护进程访问 /dev/lirc，我们通过终止该进程来为我们的测试做准备。
- en: 'Execute the following commands at the Laddie appliance command prompt:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laddie 设备的命令提示符下执行以下命令：
- en: '**laddie:~#** laddie stop'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** laddie stop'
- en: '**laddie:~#** kill $(pidof lircd)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** kill $(pidof lircd)'
- en: After the first command, you will need to wait a few moments for the Laddie
    application to stop. In the second command, the pidof function outputs the process
    ID of the lircd process. The $(...) construct provides this output as a parameter
    to the kill command, which terminates the specified process. We can now access
    the /dev/lirc device file for our own purposes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行第一个命令后，您需要等待几秒钟，让 Laddie 应用程序停止。在第二个命令中，pidof 函数输出 lircd 进程的进程 ID。$(...)
    构造提供此输出作为 kill 命令的参数，从而终止指定的进程。现在我们可以访问 /dev/lirc 设备文件以供我们自己的用途。
- en: As we saw in the previous chapter, we can use the cat command to access output
    that is provided via device files. Now we don’t want to simply cat the output
    of /dev/lirc to the console, because some of the output data might be interpreted
    as control characters and the console could end up in an unusable state. One thing
    we can do is pipe that output through the hexdump utility, which translates binary
    data into printable ASCII hexadecimal characters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，我们可以使用 cat 命令通过设备文件访问提供的输出。现在我们不想简单地将 /dev/lirc 的输出猫到控制台，因为一些输出数据可能会被解释为控制字符，导致控制台最终处于不可用状态。我们可以做的一件事是将该输出通过
    hexdump 工具进行管道传输，该工具将二进制数据转换为可打印的 ASCII 十六进制字符。
- en: 'Enter the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '**laddie:~#** cat /dev/lirc | hexdump'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** cat /dev/lirc | hexdump'
- en: 'Now, any pulses that arrive on the DCD pin of serial port COM1 will be measured
    by the lirc_serial device driver, read by the cat command via the /dev/lirc device
    file, and displayed in ASCII hex by hexdump. To generate such pulses, connect
    your IR receiver to the COM1 port, point your remote control at the IR detector/demodulator,
    and press a button. (At this point, the particular kind of remote doesn’t matter.)
    If everything is working properly, you should see output like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何到达串行端口 COM1 的 DCD 引脚的脉冲将由 lirc_serial 设备驱动程序测量，通过 cat 命令通过 /dev/lirc 设备文件读取，并由
    hexdump 以 ASCII 十六进制形式显示。要生成此类脉冲，将您的红外接收器连接到 COM1 端口，将遥控器对准红外检测器/解调器，并按下一个按钮。（在此阶段，遥控器的具体类型并不重要。）如果一切正常，您应该看到以下输出：
- en: '![](../images/237-1.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/237-1.jpg)'
- en: This is the output we generated by briefly tapping the Volume- button on the
    universal remote that we programmed for Sony TV.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在编程用于索尼电视的通用遥控器上轻触音量-按钮时生成的输出。
- en: If you’re not sure your IR receiver hardware is working (or if you don’t have
    an IR receiver at this point), you can still test the lirc_serial device driver
    by creating random pulses on the DCD pin of the serial port. One way to do this
    is to intermittently connect pin 1 (DCD) to pin 7 (RTS) of the serial port. If
    this doesn’t produce a result, try intermittently connecting pin 1 to pin 3 (TXD).
    If your computer’s serial port is built to standard specifications, it won’t be
    a problem if you connect the wrong pins by mistake. Still, if you’ve just purchased
    a fancy, new laptop, you might want to try this experiment on a friend’s Linux
    box first.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的红外接收器硬件是否工作正常（或者目前还没有红外接收器），你仍然可以通过在串口的DCD引脚上创建随机脉冲来测试lirc_serial设备驱动程序。一种方法是间歇性地将串口的1号引脚（DCD）连接到7号引脚（RTS）。如果这样做没有产生结果，尝试间歇性地将1号引脚连接到3号引脚（TXD）。如果你的计算机串口按照标准规格构建，即使错误地连接了引脚也不会有问题。然而，如果你刚刚购买了一台新潮的笔记本电脑，你可能想在朋友的Linux机器上先进行这个实验。
- en: Using the cat /dev/lirc | hexdump command is a good exercise because it demonstrates
    that the output of /dev/lirc is simply binary data that can be read like a file.
    Neither cat nor hexdump know anything about infrared, yet they display the data
    just fine. But the output of hexdump isn’t easy to read. Fortunately, the LIRC
    package includes a utility, mode2, that does understand the output of the lirc_serial
    driver and can display it as pulse and space timing data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cat /dev/lirc | hexdump命令是一个很好的练习，因为它表明/dev/lirc的输出仅仅是像文件一样可以读取的二进制数据。cat和hexdump都不了解红外，但它们可以很好地显示数据。但是，hexdump的输出不易阅读。幸运的是，LIRC软件包包括一个实用程序，mode2，它理解lirc_serial驱动程序的输出，并且可以将其显示为脉冲和空间时序数据。
- en: 'Press ctrl-C to terminate the previous command, and execute the following one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按下ctrl-C终止之前的命令，并执行以下命令：
- en: '**laddie:~#** mode2'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** mode2'
- en: Now point an IR remote control at the receiver while pressing buttons. The command
    mode2 reads the output of /dev/lirc, parses the 23-bit timing data and the one-bit
    pulse or space indicator, and produces a stream of pulse and space timing information.
    As an example, we observed the following train of space and pulse timings from
    mode2 when we stimulated our IR receiver with a single Sony TV Volume- command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在按按钮的同时，将红外遥控器对准接收器。mode2命令读取/dev/lirc的输出，解析23位时序数据和单比特脉冲或空间指示器，并生成一系列脉冲和空间时序信息。例如，当我们用一个索尼电视音量-命令刺激我们的红外接收器时，我们从mode2观察到了以下空间和脉冲时序序列。
- en: '![](../images/238-1.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/238-1.jpg)'
- en: If you refer to “Protocols for Encoding Remote Control Commands” on page 198,
    you will notice that these timing values are noisier than the idealized waveform
    would suggest. The first pulse is roughly 2,500 milliseconds and corresponds to
    the header. The other pulses are roughly 1,300 or 650 milliseconds, corresponding
    to ones and zeros, respectively. The spaces are roughly 500 milliseconds, but
    note the large initial space value corresponding to the time between button presses.
    It is the job of the lircd daemon to reject the pulse trains that do not correspond
    to valid waveforms and to correctly interpret the ones that do. When you are finished
    experimenting with mode2, press ctrl-C to terminate the utility.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考第198页的“编码遥控器命令协议”，你会注意到这些时序值比理想化的波形所暗示的要嘈杂。第一个脉冲大约是2,500毫秒，对应于头部。其他脉冲大约是1,300或650毫秒，分别对应于1和0。空间大约是500毫秒，但请注意对应于按键之间时间的较大初始空间值。拒绝与有效波形不对应的脉冲序列，并正确解释那些对应的脉冲序列是lircd守护进程的任务。当你完成mode2的实验后，按下ctrl-C终止实用程序。
- en: At this point, we have established that the lirc_serial device driver is working.
    In the next section we will provide instructions on configuring the lircd daemon,
    which will use the output of this device driver.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确认lirc_serial设备驱动程序正在工作。在下一节中，我们将提供配置lircd守护进程的说明，该守护进程将使用此设备驱动程序输出。
- en: '**NOTE**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you would like to write a program that uses the output of the lirc_serial
    device driver directly, the source code for the mode2 utility provides an example
    of how to access the /dev/lirc device file. This source is available from* [*http://www.lirc.org*](http://www.lirc.org/)
    *and is also provided in the lirc-0.8.1.tar.bz2 tarball in the /usr/src/packages/
    directory of this book’s companion CD.*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您想编写一个直接使用 lirc_serial 设备驱动程序输出的程序，mode2 工具的源代码提供了一个如何访问 /dev/lirc 设备文件的示例。此源代码可在
    [*http://www.lirc.org*](http://www.lirc.org/) 上找到，并且也包含在此书配套 CD 的 /usr/src/packages/
    目录中的 lirc-0.8.1.tar.bz2 压缩包中。*'
- en: '[***Configuring the lircd Daemon***](toc.html#chapter12.13)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[***配置 lircd 守护进程***](toc.html#chapter12.13)'
- en: The cleverest part of the LIRC package is the lircd daemon. This is the part
    that analyzes the noisy timing values coming from the /dev/lirc device file and
    produces a sequence of commands that are easily parsed by downstream LIRC tools
    or user applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC 软件包中最聪明的一部分是 lircd 守护进程。这是分析来自 /dev/lirc 设备文件中的嘈杂时间值并生成一系列易于下游 LIRC 工具或用户应用程序解析的命令的部分。
- en: In order for the lircd daemon to interpret the timing data from /dev/ lirc,
    it has to understand the remote control protocol. The configuration file /etc/lircd.conf
    captures this protocol information. The following is the lircd.conf file used
    by the Laddie appliance with comments and a few of the button entries removed
    to save space.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 lircd 守护进程能够解释来自 /dev/lirc 的定时数据，它必须理解遥控器协议。配置文件 /etc/lircd.conf 捕获此协议信息。以下是在
    Laddie 设备上使用的 lircd.conf 文件，其中包含注释和删除了一些按钮条目以节省空间。
- en: '![](../images/239-1.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/239-1.jpg)'
- en: You don’t need to understand the entries in this file to use LIRC, but we’ll
    make a few comments here in case you want to edit the file manually. The *name*
    can be any string you like that describes the remote. The *bits* field is the
    total number of data bits (in our case, command-code bits plus address bits).
    The *eps* and *aeps* fields represent relative and absolute error tolerances (in
    our case, 30 percent and 100 microseconds). The *header*, *one*, and *zero* fields
    represent the pulse and space timings (in microseconds) for the header and data
    bits. There is a *gap* of about 26,000 microseconds between repeated commands,
    and there is no toggle bit that changes for repeated commands. Note that these
    fields reflect actual timings measured by the device driver and can vary from
    the protocol standard. The *codes* are the actual data bit sequences for the various
    commands. For the additional fields that may apply for other remotes, you can
    see the details at the WinLIRC web page, winlirc.sourceforge.net/technicaldetails.html.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要理解此文件中的条目即可使用 LIRC，但如果我们想手动编辑文件，我们在这里会做一些注释。*名称*可以是您喜欢的任何字符串，用于描述遥控器。*位*字段是数据位总数（在我们的情况下，是命令码位加上地址位）。*eps*
    和 *aeps* 字段表示相对和绝对误差容限（在我们的情况下，是 30% 和 100 微秒）。*header*、*one* 和 *zero* 字段表示头部和数据位的脉冲和空间时间（以微秒为单位）。重复命令之间有一个大约
    26,000 微秒的间隔，并且没有用于重复命令的切换位。请注意，这些字段反映了设备驱动程序实际测量的时间，可能不同于协议标准。*codes* 是各种命令的实际数据位序列。对于可能适用于其他遥控器的附加字段，您可以在
    WinLIRC 网页上查看详细信息，网址为 winlirc.sourceforge.net/technicaldetails.html。
- en: If you have a remote that uses the same protocol as ours, you should be able
    to control the Laddie appliance without updating the /etc/lircd.conf file. (Again,
    we are using an RCA RCU410 universal remote, programmed as a Sony TV, code 002.)
    The LIRC website also provides configuration files for many remotes, but using
    the LIRC irrecord utility, it’s easy enough to generate these files from scratch.
    The irrecord utility creates configuration files by monitoring the output of /dev/lirc
    while prompting the user for remote control input.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的遥控器使用与我们的相同的协议，您应该能够在不更新 /etc/lircd.conf 文件的情况下控制 Laddie 设备。 （再次强调，我们使用的是
    RCA RCU410 通用遥控器，编程为索尼电视，代码 002。）LIRC 网站还提供了许多遥控器的配置文件，但使用 LIRC irrecord 工具，从头开始生成这些文件也很容易。irrecord
    工具通过监控 /dev/lirc 的输出并提示用户输入遥控器控制信号来创建配置文件。
- en: 'Now let’s create a configuration file for your remote. As we mentioned when
    we were testing the lirc_serial device driver, we need to kill the lircd daemon
    before we access /dev/lirc. If you didn’t kill lircd earlier, do so now:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来为您的遥控器创建一个配置文件。正如我们在测试 lirc_serial 设备驱动程序时提到的，在访问 /dev/lirc 之前，我们需要杀死 lircd
    守护进程。如果您之前没有杀死 lircd，现在就做吧：
- en: '**laddie:~#** kill $(pidof lircd)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** 杀死 $(pidof lircd)'
- en: 'To create a new lircd configuration file, rename or delete the old one, then
    run the irrecord command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的lircd配置文件，重命名或删除旧文件，然后运行irrecord命令：
- en: '**laddie:~#** mv /etc/lircd.conf /etc/lircd.conf.bak'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** mv /etc/lircd.conf /etc/lircd.conf.bak'
- en: '**laddie:~#** irrecord /etc/lircd.conf'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** irrecord /etc/lircd.conf'
- en: 'Read the instructions printed by the irrecord utility carefully. The utility
    will prompt you to press remote control buttons in a particular sequence, and
    it will also ask you to assign names for the buttons you choose to program. Since
    you will be using the remote to control the Laddie framebuffer UI, you will need
    to provide the button names that the Laddie appliance expects. It doesn’t matter
    how you assign the actual buttons, but you will need to use the following names
    in uppercase letters: POWER, VOL+, VOL-, CH+, and CH-. If you restart the irrecord
    utility, be sure to rename or delete the previous /etc/lircd.conf file first.
    Once you’re satisfied with the configuration file, you are ready to test the lircd
    daemon.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读irrecord实用程序打印的说明。该实用程序将提示您按特定的顺序按下遥控器按钮，并且它还会要求您为要编程的按钮分配名称。由于您将使用遥控器来控制Laddie帧缓冲UI，您需要提供Laddie设备所期望的按钮名称。您分配实际按钮的方式无关紧要，但您需要使用以下名称的大写字母：POWER、VOL+、VOL-、CH+和CH-。如果您重新启动irrecord实用程序，请确保首先重命名或删除先前的/etc/lircd.conf文件。一旦您对配置文件满意，您就可以测试lircd守护进程了。
- en: '**NOTE**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you choose to download a configuration file for your remote from* [*http://www.lirc.org*](http://www.lirc.org/)*,
    you will need to edit it to make sure the button names are the ones the Laddie
    appliance expects. Keep in mind that any updated configuration files will be replaced
    with the original files when you reboot the Laddie CD.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您选择从[*http://www.lirc.org*](http://www.lirc.org/)下载适用于您遥控器的配置文件，您需要编辑它以确保按钮名称是Laddie设备所期望的。请记住，在您重新启动Laddie
    CD时，任何更新的配置文件都将被原始文件替换。*'
- en: '[***Testing the lircd Daemon***](toc.html#chapter12.14)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[***测试lircd守护进程***](toc.html#chapter12.14)'
- en: 'To use your new lircd configuration file, start the lircd daemon with the command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用您的新lircd配置文件，请使用以下命令启动lircd守护进程：
- en: '**laddie:~#** lircd'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** lircd'
- en: 'This command will complete immediately without printing anything. To verify
    that the daemon is running, execute the command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将立即完成而不会打印任何内容。要验证守护进程正在运行，请执行以下命令：
- en: '**laddie:~#** pidof lircd'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** pidof lircd'
- en: and verify that it returns an integer. The lircd daemon will read timing data
    from the /dev/lirc device file and, using the configuration specified in /etc/
    lircd.conf, provide button-press information at the Unix socket /dev/lircd in
    the form of newline-delimited ASCII strings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 并验证它返回一个整数。lircd守护进程将从/dev/lirc设备文件读取时序数据，并使用在/etc/lircd.conf中指定的配置，以换行符分隔的ASCII字符串的形式在Unix套接字/dev/lircd中提供按钮按下信息。
- en: Unix sockets are different from regular files or device files. In particular,
    you can’t use the system call open() to access them; you have to use connect()
    instead. This means that we can’t simply use cat to examine the output of /dev/lircd
    the way we did with /dev/lirc. Let’s write a simple program, socket_cat, that
    does allow us to view this output.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字与常规文件或设备文件不同。特别是，您不能使用open()系统调用来访问它们；您必须使用connect()。这意味着我们不能简单地使用cat来检查/dev/lircd的输出，就像我们检查/dev/lirc时那样。让我们编写一个简单的程序，socket_cat，它允许我们查看此输出。
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you are eager to test the lircd daemon and would rather skip this exercise,
    you can use the LIRC utility irw, with no arguments, to display the output of
    /dev/lircd. However, the program socket_cat will help you understand how the Laddie
    appliance works, since it uses the same approach as socket_cat to access remote
    control button presses.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果您急于测试lircd守护进程并希望跳过此练习，您可以使用LIRC工具irw，不带任何参数，以显示/dev/lircd的输出。然而，程序socket_cat将帮助您了解Laddie设备的工作原理，因为它使用与socket_cat相同的方法来访问遥控器按钮的按下。*'
- en: If you’ve programmed with sockets before, the following program will look familiar.
    We use the function ![](../images/1.jpg) socket to create an unnamed, Unix internal
    socket. We use the function ![](../images/2.jpg) connect to connect to the named
    socket /dev/lircd. Then we ![](../images/3.jpg) loop forever, copying all received
    data to the standard output.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过套接字编程，以下程序将看起来很熟悉。我们使用函数![](../images/1.jpg) socket创建一个未命名的、Unix内部套接字。我们使用函数![](../images/2.jpg)
    connect连接到命名套接字/dev/lircd。然后我们![](../images/3.jpg)无限循环，将所有接收到的数据复制到标准输出。
- en: '![](../images/241-1.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/241-1.jpg)'
- en: 'This program is on the CD at /Code/src/examples/socket_cat.c. Build and run
    the program, using the following commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序位于CD上的/Code/src/examples/socket_cat.c。使用以下命令构建并运行程序：
- en: '**laddie:~#** cd /Code/src/examples/socketcat'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** cd /Code/src/examples/socketcat'
- en: '**laddie:~#** make'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** make'
- en: '**laddie:~#** ./socketcat /dev/lircd'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** ./socketcat /dev/lircd'
- en: Then press a few buttons on your remote. You should see output like the following.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按一下遥控器上的几个按钮。你应该会看到以下类似的输出。
- en: 0000000000000c90 00 VOL- /etc/lircd.conf
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000c90 00 VOL- /etc/lircd.conf
- en: 0000000000000490 00 VOL+ /etc/lircd.conf
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000490 00 VOL+ /etc/lircd.conf
- en: 0000000000000890 00 CH- /etc/lircd.conf
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000890 00 CH- /etc/lircd.conf
- en: 0000000000000090 00 CH+ /etc/lircd.conf
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000090 00 CH+ /etc/lircd.conf
- en: 0000000000000a90 00 POWER /etc/lircd.conf
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000a90 00 POWER /etc/lircd.conf
- en: 0000000000000a90 01 POWER /etc/lircd.conf
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000a90 01 POWER /etc/lircd.conf
- en: 0000000000000a90 02 POWER /etc/lircd.conf
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 0000000000000a90 02 POWER /etc/lircd.conf
- en: Each string includes a 16-character hexadecimal command code, a hexadecimal
    repetition count, a command string, and a name for the remote (which defaults
    to the name of the lircd config file). Note how, at the end of this sequence,
    the repetition count increases when the POWER button is held down continually.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符串包含一个16字符的十六进制命令代码、一个十六进制重复计数、一个命令字符串以及遥控器的名称（默认为lircd配置文件的名称）。注意，在这个序列的末尾，当持续按下电源按钮时，重复计数会增加。
- en: The 16-character command codes are generally not useful, since all relevant
    information is captured by the names of the commands and the remote. However,
    it is interesting to see how the command code corresponds to the input waveform.
    Note, for example, that *0xc90* is the hexadecimal representation for the 12 bits
    (left to right) in the command waveform for the Sony TV Volume- command that we
    saw in “Protocols for Encoding Remote Control Commands” on page 198\. When you
    are done with socket_cat, press ctrl-C to terminate the program.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 16字符的命令代码通常没有太大用处，因为所有相关信息都已被命令和遥控器的名称所捕获。然而，看到命令代码如何对应于输入波形是有趣的。例如，*0xc90*是我们在第198页的“编码遥控器命令的协议”中看到的索尼电视音量-命令的命令波形12位（从左到右）的十六进制表示。完成socket_cat后，按ctrl-C终止程序。
- en: '**NOTE**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When a remote control button is pushed, depending on the button and the protocol,
    the commands can repeat pretty quickly. For the Laddie framebuffer UI, we took
    advantage of the repetition count associated with the lircd output to ignore all
    but the first command associated with each button press.*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*当按下遥控器按钮时，根据按钮和协议的不同，命令可以非常快地重复。对于Laddie帧缓冲区UI，我们利用了与lircd输出相关的重复计数来忽略每个按钮按下关联的所有命令，除了第一个命令。*'
- en: '[***LIRC Tools for Controlling Applications***](toc.html#chapter12.15)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[***LIRC应用程序控制工具***](toc.html#chapter12.15)'
- en: As you saw in the previous section, it is simple to write a program that responds
    to remote control commands via the /dev/lircd socket. But what if you want to
    use a remote to control a program that already exists, but was designed, say,
    for keyboard input rather than remote control input? In fact, the LIRC package
    addresses this need with tools that connect to the /dev/ lircd socket and produce
    the kinds of output that many programs do expect.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所示，编写一个通过/dev/lircd套接字响应遥控器命令的程序很简单。但如果你想要使用遥控器来控制一个已经存在但设计时是为键盘输入而不是遥控器输入的程序，该怎么办呢？实际上，LIRC软件包通过连接到/dev/lircd套接字并产生许多程序预期的输出类型来解决这个问题。
- en: The ircat tool is a good example because it is the simplest; it prints user-specifiable,
    newline-delimited strings to the standard output when remote control buttons are
    pressed. If you have a program that takes commands from standard input, you can
    control it with LIRC by piping the output of ircat to your program. To map remote
    control buttons to appropriate output, configure the file /etc/lircrc. The HTML
    documentation provided with the LIRC package provides details on the format of
    this file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ircat工具是一个很好的例子，因为它是最简单的；当按下遥控器按钮时，它会将用户指定的、以换行符分隔的字符串打印到标准输出。如果你有一个从标准输入接收命令的程序，你可以通过将ircat的输出管道到你的程序来使用LIRC来控制它。要将遥控器按钮映射到适当的输出，配置文件/etc/lircrc。LIRC软件包提供的HTML文档提供了关于此文件格式的详细信息。
- en: Similarly, the LIRC package provides an irpty utility for simulating keyboard
    input, an irexec utility for invoking system calls, and an irxevent utility that
    generates X events (for systems running X). Again, these actions are mapped to
    remote control buttons according to the /etc/lircrc file. All of these utilities
    use an API called the lirc_client library to access the /dev/ lircd socket. The
    source code for the ircat tool provides a simple example of how to use this library.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，LIRC软件包提供了一个用于模拟键盘输入的irpty实用程序，一个用于调用系统调用的irexec实用程序，以及一个生成X事件的irxevent实用程序（适用于运行X的系统）。同样，这些操作根据/etc/lircrc文件映射到遥控器按钮。所有这些实用程序都使用名为lirc_client库的API来访问/dev/lircd套接字。ircat工具的源代码提供了一个如何使用此库的简单示例。
- en: Finally, the LIRC package contains a daemon lircmd that uses remote control
    input to emulate a mouse. This daemon connects to the /dev/lircd socket and produces
    mouse events on the pipe /dev/lircm. The configuration file /etc/lircmd.conf selects
    the protocol for X mouse events (e.g., IntelliMouse) and specifies how remote
    commands map to mouse movements and button presses. The XF86Config file must be
    updated to include /dev/lircm as an input device. Again, the LIRC HTML documentation
    provides details.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，LIRC软件包包含一个名为lircmd的守护进程，它使用遥控输入来模拟鼠标。该守护进程连接到/dev/lircd套接字，并在管道/dev/lircm上产生鼠标事件。配置文件/etc/lircmd.conf选择X鼠标事件（例如，IntelliMouse）的协议，并指定远程命令如何映射到鼠标移动和按钮按下。必须更新XF86Config文件以包括/dev/lircm作为输入设备。同样，LIRC
    HTML文档提供了详细信息。
- en: '[***Controlling the Laddie Appliance***](toc.html#chapter12.16)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[***控制Laddie设备***](toc.html#chapter12.16)'
- en: For the Laddie appliance, we installed the LIRC package and configured the lirc_serial
    driver and lircd daemon as described in the previous sections. Since we built
    the Laddie appliance from scratch, we did not need to use LIRC tools like ircat
    or irpty; instead, we wrote code similar to the socket_cat example, which accessed
    the /dev/lircd socket directly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Laddie设备，我们安装了LIRC软件包，并按照前几节所述配置了lirc_serial驱动程序和lircd守护进程。由于我们是从头开始构建Laddie设备的，所以我们不需要使用LIRC工具如ircat或irpty；相反，我们编写了类似于socket_cat示例的代码，该代码直接访问/dev/lircd套接字。
- en: As discussed in the previous chapter, Laddie’s framebuffer user interface is
    built on the Simple DirectMedia Layer (SDL) library. Since SDL includes its own
    event handler which, in particular, handles keyboard presses, it was a simple
    matter to incorporate remote control events. We created a separate lircHandler()
    thread to read commands from the /dev/lircd socket, parse these commands, and
    then push appropriate keyboard events onto the SDL event queue. Specifically,
    we responded to the Channel+/– and Volume+/– remote control commands by simulating
    the SDL keypress events for the Up, Down, Right, and Left arrow keys, respectively.
    We responded to the remote control Power command with the SDL Enter keypress event.
    In Laddie’s SDL event handler, we responded to these keypress events by calling
    navigation commands in Laddie’s menu object. This use of the /dev/lircd output
    to control Laddie’s framebuffer menu is illustrated in Figure 12-15.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Laddie的帧缓冲区用户界面是基于Simple DirectMedia Layer (SDL)库构建的。由于SDL包含它自己的事件处理器，特别是处理键盘按键，因此将远程控制事件集成进去是一件简单的事情。我们创建了一个单独的lircHandler()线程来从/dev/lircd套接字读取命令，解析这些命令，然后将适当的键盘事件推送到SDL事件队列。具体来说，我们通过模拟SDL按键事件来响应Channel+/–和Volume+/–遥控命令，分别对应向上、向下、向右和向左箭头键。我们通过模拟SDL
    Enter按键事件来响应遥控器的Power命令。在Laddie的SDL事件处理器中，我们通过调用Laddie菜单对象的导航命令来响应这些按键事件。这种使用/dev/lircd输出控制Laddie帧缓冲区菜单的方法如图12-15所示。
- en: '![](../images/243-1.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/243-1.jpg)'
- en: '*Figure 12-15: Controlling the Laddie framebuffer UI*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-15：控制Laddie帧缓冲区用户界面*'
- en: If you would like to see the details of the lircHandler() thread, you can take
    a look at the /Code/src/fbmenu/lirc_if.cc file on the CD.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看lircHandler()线程的详细信息，你可以查看CD上的/Code/src/fbmenu/lirc_if.cc文件。
- en: 'If you have built the IR receiver we described in this chapter and successfully
    worked through the exercises, you should be able to use it to control the Laddie
    framebuffer UI. We had stopped the Laddie appliance daemons in order to do the
    exercises; you will need to restart them now. Do this with the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经构建了本章中描述的IR接收器并且成功完成了练习，你应该能够使用它来控制Laddie帧缓冲区用户界面。我们为了做练习而停止了Laddie设备守护进程；你现在需要重新启动它们。使用以下命令执行此操作：
- en: '**laddie:~#** laddie start'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**laddie:~#** laddie start'
- en: This will take a few moments, after which you should see the frame-buffer UI.
    Now experiment with the buttons you programmed when you used irrecord to create
    the lircd.conf file. You should be able to navigate through the menu buttons and
    switch menu pages.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要几分钟时间，之后你应该能看到帧缓冲区用户界面。现在，当你使用irrecord创建lircd.conf文件时，尝试使用你编程的按钮。你应该能够浏览菜单按钮并切换菜单页面。
- en: '[**Summary**](toc.html#chapter12.17)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter12.17)'
- en: Infrared light is a useful means for controlling an appliance when the appliance
    is in the line of sight. To be effective, infrared light must be modulated by
    the transmitter with a signature frequency, and this modulation must be removed
    by the receiver. Fortunately, there are commercial devices that make it easy to
    meet these requirements. For IR receivers, we introduced infrared detector/demodulators
    and showed how to use them in simple IR receiver circuits. For IR transmitters,
    we recommended using universal remotes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 红外线是一种在设备处于视线范围内时控制设备的有用手段。为了有效，红外线必须由发射器以特征频率调制，并且这种调制必须由接收器去除。幸运的是，有商业设备可以轻松满足这些要求。对于红外接收器，我们介绍了红外检测/解调器，并展示了如何在简单的红外接收器电路中使用它们。对于红外发射器，我们推荐使用通用遥控器。
- en: We also described the Linux Infrared Remote Control (LIRC) package as a useful
    tool for controlling appliances. This package provides device drivers and daemons
    for measuring and interpreting infrared waveforms, as well as utilities for controlling
    appliances. Although we didn’t discuss the entire LIRC package, we did describe
    those elements of the package that we used for the Laddie appliance. We hope this
    overview of infrared communications and this example application of the LIRC software
    package will be a useful starting point if you decide to use infrared remote control
    for your own appliance.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还描述了Linux红外遥控（LIRC）软件包作为一个控制设备的实用工具。此软件包提供用于测量和解释红外波形的设备驱动程序和守护进程，以及用于控制设备的实用程序。尽管我们没有讨论整个LIRC软件包，但我们确实描述了用于Laddie设备的软件包元素。我们希望这个红外通信概述以及LIRC软件包的示例应用将是你决定为自己的设备使用红外遥控的有用起点。
- en: '![](../images/245-1.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/245-1.jpg)'
