- en: Part II. Lisp is Symmetry
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。Lisp 的对称性
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782344.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782344.png.jpg)'
- en: Chapter 4. Making Decisions with Conditions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。使用条件做出决策
- en: In the previous chapters, you learned some basic Lisp commands, as well as some
    of the philosophy behind Lisp. In this chapter, we’ll be looking in detail at
    commands for handling conditions. The elegance of these commands shows that the
    unusual philosophy and design of Lisp has real practical benefits.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了某些基本的 Lisp 命令，以及 Lisp 背后的某些哲学。在本章中，我们将详细探讨处理条件的命令。这些命令的优雅性表明，Lisp
    不寻常的哲学和设计确实具有实际的好处。
- en: The Symmetry of nil and ()
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nil 和 () 的对称性
- en: 'One thing is particularly striking when we look at how Lisp commands and data
    structures work: They are imbued with symmetry in every conceivable way. This
    symmetry can give your Lisp code a certain elegance that other languages cannot
    have, and Lisp’s simple syntax is an important factor in making this symmetry
    possible.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们观察 Lisp 命令和数据结构的工作方式时，有一件事特别引人注目：它们以每一种可能的方式都充满了对称性。这种对称性可以为你的 Lisp 代码带来一种其他语言无法拥有的优雅，而
    Lisp 的简单语法是实现这种对称性的一个重要因素。
- en: Empty Equals False
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空等于假
- en: 'Since the Lisp philosophy strongly emphasizes the use of lists to store and
    manipulate information, it will come as no surprise that the design of Common
    Lisp favors behaviors that make it easy to slice and dice such lists. The most
    profound design decision made in Common Lisp, with regard to lists, is that it
    automatically treats an empty list as a false value when evaluating a condition:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Lisp 哲学强烈强调使用列表来存储和处理信息，因此 Common Lisp 的设计倾向于使切片和切块此类列表变得容易的行为，这并不会让人感到惊讶。在
    Common Lisp 中，关于列表的最深刻的设计决策是，它在评估条件时自动将空列表视为假值：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example shows that when we pass the empty list `()` into an `if` form,
    it evaluates as a false value, whereas a list that contains an item evaluates
    as true.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，当我们把空列表 `()` 传递给 `if` 形式时，它评估为假值，而包含项目的列表评估为真。
- en: Because we can easily detect an empty list, we can process lists using *recursion*.
    With this technique, we can take items from the front of a list and send the rest
    of the list back to the same function until the list is empty. (It’s a good thing
    that detecting empty lists is so easy, because so many functions in Lisp end up
    being list-eaters.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以轻松地检测空列表，我们可以使用 *递归* 来处理列表。使用这种技术，我们可以从列表的前端取项目，并将列表的其余部分发送回同一个函数，直到列表为空。（检测空列表如此容易是一件好事，因为
    Lisp 中有如此多的函数最终都会成为列表消耗者。）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782394.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782394.png)'
- en: Let’s look at a common list-eating function, which calculates the length of
    a list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个常见的列表消耗函数，它计算列表的长度。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is written in classic Lisp style. It calls itself recursively
    as it chomps items off the front of the list. Calling yourself in this way is
    not only allowed in Lisp, but is often strongly encouraged. Lists in Lisp are
    recursive (conses of conses of conses . . .), so the act of consuming a list maps
    naturally onto functions that are recursive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是用经典 Lisp 风格编写的。它在从列表前端移除项目的同时递归地调用自己。以这种方式调用自己不仅在 Lisp 中是允许的，而且通常被强烈推荐。Lisp
    中的列表是递归的（cons 的 cons 的 cons ...），因此消耗列表的行为自然映射到递归函数。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Calling yourself recursively can sometimes make for slow code. In [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming"), we’ll rewrite
    the `my-length` function using a special, potentially faster, type of recursion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用自己有时会导致代码运行缓慢。在 [第 14 章](ch16.html "第 14 章。使用函数式编程提升 Lisp 的水平") 中，我们将使用一种特殊且可能更快的递归类型重写
    `my-length` 函数。
- en: The Four Disguises of ()
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空列表的四种伪装
- en: 'Not only does the empty list evaluate to false, but it is the *only* false
    value in Common Lisp. *Any value not equivalent to an empty list will be considered
    a true* value. This explains why the expression `''(1)` in the earlier example
    was treated as true. However, there are some other expressions in Lisp that are
    disguises for the one and only empty list:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅空列表评估为假，而且在 Common Lisp 中，它还是唯一的假值。*任何与空列表不等价的价值都将被视为真值*。这解释了为什么在先前的例子中，表达式
    `'(1)` 被视为真。然而，Lisp 中还有一些其他表达式是唯一的空列表的伪装：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782038.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782038.png)'
- en: 'We can see that the expressions in this table are equivalent by comparing them
    with one another:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过相互比较这些表中的表达式来看到它们是等价的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the only value in the table that seems normal is the quoted list
    on the left side of the comparisons. The other three all seem to break the rules
    of Lisp forms that we talked about in the previous chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表中唯一看起来正常的值是左侧比较中的引号列表。其他三个似乎都违反了我们之前章节中讨论的 Lisp 形式的规则。
- en: The first two examples are particularly puzzling. They are missing the quotation
    mark that tells the Lisp environment, “Hey, this item is a piece of data, not
    code!” In the case of `nil`, you would expect that this would actually be the
    name of a variable that could have some kind of arbitrary value. In the case of
    the unquoted `()`, there’s no way you could tell what would happen. The parentheses
    look like a form of code that needs to be evaluated, but a Lisp form always has
    a symbol at the beginning, telling it what to do. What do we do when there’s nothing
    inside the form at all?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子尤其令人困惑。它们缺少了告诉 Lisp 环境的引号，“嘿，这个项目是一份数据，而不是代码！”在 `nil` 的情况下，你可能会期望这实际上是一个可能具有某种任意值的变量的名称。在未引用的
    `()` 的情况下，你根本无法知道会发生什么。括号看起来像是一种需要评估的代码形式，但 Lisp 形式始终有一个符号在开头，告诉它要做什么。当形式内部没有任何内容时，我们该怎么办？
- en: The bottom line is that Common Lisp is architected behind the scenes to make
    sure all four of these values look like an empty list when you use them in your
    program, allowing most Lisp conditionals to be written with an elegant brevity.
    For instance, there is a constant named `nil` that evaluates to itself and allows
    you to omit the quotation mark in the first case ![](httpatomoreillycomsourcenostarchimages783564.png).
    The second case ![](httpatomoreillycomsourcenostarchimages783562.png) is a natural
    by-product of how Common Lisp parses an empty form. The third case ![](httpatomoreillycomsourcenostarchimages783560.png)
    is due to a requirement in the Common Lisp spec that says that `()` and `nil`
    should be treated the same.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Common Lisp 在幕后被设计成确保当你将这些值用于程序时，它们看起来都像空列表，这使得大多数 Lisp 条件语句可以以优雅的简洁性编写。例如，有一个名为
    `nil` 的常量，它评估为自身，并允许你在第一种情况下省略引号！[](httpatomoreillycomsourcenostarchimages783564.png)。第二种情况！[](httpatomoreillycomsourcenostarchimages783562.png)是
    Common Lisp 解析空形式时的自然结果。第三种情况！[](httpatomoreillycomsourcenostarchimages783560.png)是由于
    Common Lisp 规范中的一个要求，即 `()` 和 `nil` 应该被同等对待。
- en: Although there’s a certain beauty to having all of these values be the same,
    not every Lisper agrees with this sentiment. After all, are false and empty list
    really the same kind of thing? The creators of the other popular dialect of Lisp,
    Scheme, felt differently about this issue, and preferred to keep the concepts
    of falsity and empty list completely separate, at a slight cost to code brevity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些值都相同具有一定的美感，但并非每个 Lisp 程序员都同意这种观点。毕竟，假和空列表真的是同一种东西吗？其他流行 Lisp 方言（Scheme）的创造者对这个问题有不同的看法，他们更愿意将假和空列表的概念完全分开，尽管这会牺牲代码的简洁性。
- en: 'The Conditionals: if and Beyond'
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句：if 及其之后
- en: Now that you understand how Lisp handles true and false, let’s look at `if`
    and some of the other conditional commands.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了 Lisp 如何处理真和假，那么让我们来看看 `if` 以及其他一些条件命令。
- en: One Thing at a Time with if
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次只做一件事的 if
- en: The `if` command can be used to make different things happen when things are
    true (such as when 1 + 2 = 3) or false (such as when 1 + 2 = 4).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 命令可以在条件为真（例如，1 + 2 = 3）或假（例如，1 + 2 = 4）时执行不同的操作。'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `if` command can also be used to check whether a list is empty:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 命令还可以用来检查列表是否为空：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So far, the only way to branch on a condition that we’ve looked at has been
    the `if` command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的唯一一种基于条件进行分支的命令是 `if` 命令：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we’re doing here is checking whether the number 5 is odd, then, depending
    on the result, evaluating one of the two following expressions in the if form.
    Since 5 is odd, it evaluates the first such expression, and the form as a whole
    returns `odd-number`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是检查数字 5 是否为奇数，然后根据结果，在 `if` 形式中评估以下两个表达式之一。由于 5 是奇数，它评估了第一个这样的表达式，整个形式返回
    `odd-number`。
- en: 'There’s a lot happening in this harmless-looking little command—stuff that’s
    important to understanding Lisp. Here are two important observations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个看似无害的小命令中，有很多事情正在发生——这些事情对于理解 Lisp 至关重要。以下是两个重要的观察：
- en: Only one of the expressions after the `if` is actually evaluated.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 `if` 后面的一个表达式实际上会被评估。
- en: We can only do one thing in an `if` statement.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`if`语句中我们只能做一件事。
- en: 'Usually, when a function is executed in Lisp, all the expressions after the
    function name are evaluated, before the function itself is evaluated. However,
    `if` does not follow these rules. To see this, consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个函数在Lisp中执行时，函数名后的所有表达式都会在函数本身评估之前被评估。然而，`if`并不遵循这些规则。为了看到这一点，考虑以下示例：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any self-respecting, law-abiding Lisp function would kick your butt to the curb
    if you tried to run this code, because you’re dividing by zero.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何自重的、守法的Lisp函数都会在你尝试运行此代码时把你踢到路边，因为你正在除以零。
- en: But `if` is not just a function. It’s a *special form*, which gives it special
    privileges, such as the right to not evaluate all its parameters in the normal
    way. This makes sense, since the whole point of a condition is to run some stuff
    but not other stuff. In this case, it just merrily ignores the division by zero,
    since it’s in the part of the branch that applies only to even numbers. Conditional
    commands in Lisp are typically special forms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但`if`不仅仅是一个函数。它是一个*特殊形式*，这赋予它特殊的权限，例如不按正常方式评估所有参数的权利。这是有意义的，因为条件的目的就是运行某些东西但不运行其他东西。在这种情况下，它只是愉快地忽略了除以零的错误，因为它只适用于偶数部分的分支。Lisp中的条件命令通常是特殊形式。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781852.png.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781852.png.jpg)'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the conditional commands may be macros, which are something like user-created
    special forms. Being a special form usually implies that a command is directly
    “baked in” to the language. In [Chapter 16](ch18.html "Chapter 16. The Magic of
    Lisp Macros"), you’ll learn how to write such macros yourself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些条件命令可能是宏，它们类似于用户创建的特殊形式。作为特殊形式通常意味着一个命令是直接“嵌入”到语言中的。在第16章（[The Magic of Lisp
    Macros](ch18.html "Chapter 16. The Magic of Lisp Macros")）中，你将学习如何自己编写这样的宏。
- en: Since only one expression inside an `if` is ever evaluated, it’s impossible
    to do two or more separate things inside your branch.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`if`语句内部只有一个表达式会被评估，所以在分支内部做两件或更多的事情是不可能的。
- en: There is actually a clever style of programming (called *functional programming*,
    as we’ll discuss in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch
    with Functional Programming")), which considers this a Good Thing. However, for
    cases when you really want to do more than one thing, you can use a special command,
    `progn`, to wedge in extra commands in a single expression. With `progn`, only
    the last evaluation is returned as the value of the full expression. In this next
    example, for instance, we use the command to set a special global variable directly
    inside our conditional branch.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一种巧妙的编程风格（称为*函数式编程*，我们将在第14章中讨论），它认为这是一个好事。然而，对于你真的想做多项操作的情况，你可以使用一个特殊的命令`progn`，在单个表达式中插入额外的命令。使用`progn`，只有最后一个评估被作为整个表达式的值返回。例如，在下一个例子中，我们使用这个命令直接在我们的条件分支中设置一个特殊的全局变量。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782500.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782500.png)'
- en: 'Going Beyond if: The when and unless Alternatives'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越if：when和unless的替代方案
- en: 'Since it’s kind of a pain to use `progn` every time you want to do multiple
    things inside an `if`, Lisp has several other commands that include an *implicit*
    `progn`. The most basic of these are `when` and `unless`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次在`if`语句内想要做多项操作时使用`progn`都有些麻烦，Lisp有其他几个包含隐式`progn`的命令。其中最基本的是`when`和`unless`：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With `when`, all the enclosed expressions are evaluated when the condition is
    true. With `unless`, all the enclosed expressions are evaluated when the condition
    is false. The trade-off is that these commands can’t do anything when the condition
    evaluates in the opposite way; they just return `nil` and do nothing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`when`时，当条件为真时，所有包含的表达式都会被评估。使用`unless`时，当条件为假时，所有包含的表达式都会被评估。这些命令的权衡是，当条件以相反的方式评估时，它们无法做任何事情；它们只是返回`nil`并什么都不做。
- en: 'The Command That Does It All: cond'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做一切命令：cond
- en: But what do you do if you’re the kind of coder who wants it all? Maybe you just
    ain’t in a compromisin’ mood and want a function that will do everything! Well,
    Lisp has you covered.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你是那种想要所有功能的程序员怎么办？也许你根本不想妥协，只想有一个能做所有事情的函数！Lisp已经为你准备好了。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781360.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781360.png)'
- en: The `cond` form is the classic way to do branching in Lisp. Through the liberal
    use of parentheses, it allows for an implicit `progn`, can handle more than one
    branch, and can even evaluate several conditions in succession. Since `cond` has
    been around since the Lisp Stone Age, and it’s comprehensive in its abilities,
    many Lisp programmers consider it to be the one true Lisp conditional.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 形式是 Lisp 中进行分支的经典方式。通过大量使用括号，它允许隐式地使用 `progn`，可以处理多个分支，甚至可以连续评估多个条件。由于
    `cond` 自 Lisp 石器时代以来一直存在，并且功能全面，许多 Lisp 程序员认为它是真正的 Lisp 条件。'
- en: 'Here’s an example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779845.png.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779845.png.jpg)'
- en: 'As you can see, the body of a `cond` uses a layer of parentheses to separate
    the different branches of the condition. Then the first expression of each parenthesized
    part contains the condition for making that branch active. In our example, we
    have different branches for each type of pudding thief: one for Henry ![](httpatomoreillycomsourcenostarchimages783564.png),
    one for Johnny ![](httpatomoreillycomsourcenostarchimages783562.png), and one
    for everyone else ![](httpatomoreillycomsourcenostarchimages783560.png). We use
    `eq` to compare the supplied person’s name with each potential perpetrator.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`cond` 的主体使用括号层来分隔条件的不同分支。然后每个括号部分的第一个表达式包含使该分支激活的条件。在我们的例子中，我们有针对每种布丁小偷的不同分支：一个针对亨利
    ![亨利](httpatomoreillycomsourcenostarchimages783564.png)，一个针对约翰尼 ![约翰尼](httpatomoreillycomsourcenostarchimages783562.png)，还有一个针对其他人
    ![其他人](httpatomoreillycomsourcenostarchimages783560.png)。我们使用 `eq` 来比较提供的名字与每个潜在的肇事者。
- en: The conditions in a `cond` form are always checked from the top down, so the
    first successful match drives the behavior. In this example, the last branch ![](httpatomoreillycomsourcenostarchimages783560.png)
    has a condition of `t` (for true), guaranteeing that at least the last branch
    will always be evaluated. This is a common `cond` idiom.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`cond` 形式中的条件总是从上到下进行检查，因此第一个成功的匹配将驱动行为。在这个例子中，最后一个分支 ![其他人](httpatomoreillycomsourcenostarchimages783560.png)
    的条件为 `t`（表示真），这保证了至少最后一个分支将始终被评估。这是一个常见的 `cond` 习惯用法。'
- en: As with `when` and `unless`, the triggered branch may contain more than one
    command, since there is an implicit `progn`. In this case, the first two branches
    ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)
    set an extra `*arch-enemy*` variable, besides supplying a return variable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `when` 和 `unless` 一样，触发的分支可以包含多个命令，因为存在隐式的 `progn`。在这种情况下，前两个分支 ![亨利](httpatomoreillycomsourcenostarchimages783564.png)![约翰尼](httpatomoreillycomsourcenostarchimages783562.png)
    设置了一个额外的 `*arch-enemy*` 变量，除了提供返回变量。
- en: Branching with case
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 case 进行分支
- en: 'Let’s look at one final Lisp command: the `case` form. It is common to use
    the `eq` function for conditionals, and `case` lets you supply a value to compare
    against. Using `case`, we can rewrite the previous example as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最后一个 Lisp 命令：`case` 形式。通常使用 `eq` 函数作为条件，`case` 允许您提供一个要比较的值。使用 `case`，我们可以将前面的例子重写如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This version of the code is a lot easier on the eyes. The name of the person
    handled by each part of the `case` statement is clearly visible—it’s not hidden
    inside an equality check. Depending on which version of Lisp you use, a `case`
    statement like this may also be more efficient, especially with longer statements,
    where larger numbers of cases are handled.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码对眼睛来说更容易接受。由 `case` 语句的每个部分处理的个人名称清晰可见——它不是隐藏在等式检查中。根据您使用的 Lisp 版本，这种
    `case` 语句可能也更有效，尤其是在处理大量情况的长语句中。
- en: Warning
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: 'Because the `case` command uses `eq` for comparisons, it is usually used only
    for branching on symbol values. It cannot be used to branch on string values,
    among other things. See [Comparing Stuff: eq, equal, and More](ch04s04.html "Comparing
    Stuff: eq, equal, and More") in [Comparing Stuff: eq, equal, and More](ch04s04.html
    "Comparing Stuff: eq, equal, and More") for details.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `case` 命令使用 `eq` 进行比较，它通常仅用于基于符号值的分支。它不能用于基于字符串值的分支，以及其他情况。有关详细信息，请参阅 [比较内容：eq、equal
    和更多](ch04s04.html "比较内容：eq、equal 和更多")。
- en: Cool Tricks with Conditions
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带条件的酷技巧
- en: The fundamental design of Lisp lets you get a lot of mileage out of a few simple
    commands. Specifically, a couple of counterintuitive tricks involving conditions
    in Lisp can help you write cleaner code. The first involves two new conditional
    commands. The second takes advantage of Lisp’s simple conception of true and false.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 的基本设计让你可以用几个简单的命令获得很多好处。具体来说，涉及 Lisp 中条件的两个反直觉技巧可以帮助你编写更干净的代码。第一个涉及到两个新的条件命令。第二个利用了
    Lisp 对真和假的简单理解。
- en: Using the Stealth Conditionals and and or
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Stealth Conditionals 和 and or
- en: The conditionals `and` and `or` are simple mathematical operators, which allow
    you to manipulate Boolean values in the same way you might manipulate numbers
    using addition and subtraction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符 `and` 和 `or` 是简单的数学运算符，允许你以与使用加法和减法操作数字相同的方式操作布尔值。
- en: 'For example, here’s how we could use `and` to see if three numbers are odd:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们可以如何使用 `and` 来检查三个数字是否都是奇数的方法：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because 5, 7, and 9 are odd, the entire expression evaluates as true.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 5、7 和 9 都是奇数，整个表达式评估为真。
- en: 'Similarly, we can use or to see whether at least one of a set of numbers is
    odd:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `or` 来检查一组数字中是否至少有一个是奇数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because 7 is odd, the `or` command still evaluates as true, despite the fact
    that 4 and 8 are even.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 7 是奇数，所以 `or` 命令仍然评估为真，尽管 4 和 8 都是偶数。
- en: But there’s something a bit more interesting about `and` and `or` that you might
    not notice just by looking at these first two examples. So far, these two commands
    look like completely ordinary mathematical operators; they do not look like conditional
    commands, such as `if` or `cond`. However, they can be used for conditional behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `and` 和 `or` 之间还有一些更有趣的东西，你可能只是通过查看这两个例子而不会注意到。到目前为止，这两个命令看起来像是完全普通的数学运算符；它们看起来不像
    `if` 或 `cond` 这样的条件命令。然而，它们可以用于条件行为。
- en: 'For instance, here’s how we could use these conditionals to set a global variable
    to true only when a number is even:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是我们可以如何使用这些条件来设置全局变量，仅在数字是偶数时将其设置为真：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we do the same thing using an odd number, the variable remains unchanged:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个奇数做同样的事情，变量保持不变：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example illustrates that Lisp uses *shortcut Boolean evaluation*. This
    means that once Lisp determines that an earlier statement in a list of or values
    is true, it simply returns true and doesn’t bother evaluating the remaining statements.
    Similarly, once it determines that an earlier statement in a list of `and` values
    is false, it stops without bothering to evaluate the rest of the statements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了 Lisp 使用 *简化的布尔评估*。这意味着一旦 Lisp 确定列表中的一个 `or` 值为真，它就简单地返回真，而不会麻烦地评估剩余的语句。同样，一旦它确定列表中的一个
    `and` 值为假，它就会停止，而不会麻烦地评估其余的语句。
- en: 'While this may seem like a minor esoteric observation, it can actually be very
    useful in many situations. For instance, imagine if you want to save a file to
    disk, but only if the file was modified, and only when the user wants it to be
    saved. The basic structure could be written as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能像是一个微不足道的、深奥的观察，但实际上在许多情况下可能非常有用。例如，想象一下，如果你想将文件保存到磁盘，但只有当文件被修改，并且只有当用户希望保存时才这样做。基本结构可以写成如下：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, the function `ask-user-about-saving` would ask the user about the file,
    and then return true or false based on the user’s wishes. However, since shortcut
    Boolean evaluation is guaranteed to be used for Boolean operations under Common
    Lisp and most other Lisp dialects, we could write this instead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数 `ask-user-about-saving` 会询问用户关于文件的情况，然后根据用户的意愿返回真或假。然而，由于在 Common Lisp
    和大多数其他 Lisp 方言中，短路布尔评估保证用于布尔运算，我们可以这样写：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using this cleaner style for evaluating conditional code is possible only if
    you think beyond the typical use of the Boolean operators as simply mathematical
    operators. This form has an elegant symmetry between the three expressions, which
    some Lispers may like. However, others would argue that a reader of your code
    may easily miss the fact that `(save-file)` does something beyond returning a
    Boolean value. A bit of time is required to wrap your head around this more-general
    conception of what `and` and `or` actually mean.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当你超越布尔运算符作为简单数学运算符的典型用途时，才可能使用这种更简洁的样式来评估条件代码。这种形式在三个表达式之间具有优雅的对称性，这可能是某些 Lisp
    程序员所喜欢的。然而，其他人可能会争辩说，你的代码的读者可能会轻易忽略 `(save-file)` 除了返回布尔值之外还做了其他事情的事实。需要一点时间来理解
    `and` 和 `or` 实际上意味着的更广泛的概念。
- en: 'A third way to write this code, which is a compromise between the previous
    approaches, is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此代码的第三种方法，它是在前两种方法之间的折衷，如下所示：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Many experienced Lispers will consider this version a bit clearer than the previous
    two versions, because only expressions that are expressly designed to return a
    Boolean value are treated as part of the condition.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多经验丰富的Lisper会认为这个版本比前两个版本更清晰，因为只有明确设计为返回布尔值的表达式才被视为条件的一部分。
- en: Using Functions That Return More than Just the Truth
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用返回不仅仅是真值的函数
- en: Now let’s look at another benefit of Lisp’s simple way of thinking about true
    and false. As we’ve already discussed, any value in Common Lisp (except for the
    different variations on `nil`) is true. This means that functions that are commonly
    used in conditions have the option of returning *more than just the truth*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Lisp简单思考真和假方式的另一个好处。正如我们之前讨论的，Common Lisp中的任何值（除了`nil`的不同变体）都是真。这意味着在条件中常用的函数有返回*不仅仅是真值*的选项。
- en: 'For instance, the Lisp command `member` can be used to check for list membership
    for an item:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Lisp命令`member`可以用来检查列表中是否存在某个元素：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This seems pretty straightforward. However, once again, there is something
    happening behind the scenes that you may not expect. Let’s run the `member` command
    in isolation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单。然而，再次强调，幕后发生了一些你可能没有预料到的事情。让我们单独运行`member`命令：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What the heck happened here? Why is it returning `(1 5)`?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里到底发生了什么？为什么它返回`(1 5)`？
- en: Actually, there’s a perfectly rational explanation for this. Whenever a Lisper
    writes a function that returns true and false, she will think to herself, “Is
    there anything else I could return other than just t?” Since all non-nil values
    in Common Lisp evaluate to true, returning some other value is essentially a freebie.
    The implementers of the `member` function decided that some crazy Lisper somewhere
    may see the value in having the tail of the list for some calculation that uses
    this function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对此有一个完全合理的解释。每当Lisper编写一个返回真和假的函数时，她都会想，“除了t之外，我还能返回什么？”由于Common Lisp中所有非nil值都评估为真，返回其他值本质上是一种免费服务。`member`函数的实现者决定，某个疯狂的Lisper可能会看到列表尾部对于使用此函数的某些计算的价值。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember from [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp
    Code") that the list `'(3 4 1 5)` is the same as the nested contraption `(cons
    3 (cons 4 (cons 1 (cons 5 nil))))`. This should make it clear why the value `(cons
    1 (cons 5 nil))` is an easy thing for the `member` function to return.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记住从[第3章](ch03.html "第3章。探索Lisp代码的语法")中提到的，列表`'(3 4 1 5)`与嵌套构造`(cons 3 (cons
    4 (cons 1 (cons 5 nil))))`相同。这应该清楚地说明为什么`(cons 1 (cons 5 nil))`是`member`函数容易返回的值。
- en: 'But why doesn’t it just return the value it found, instead of the tail? In
    fact, this would have been a useful way to define the `member` function, because
    it would allow passing the original value to some other function in such a manner.
    Unfortunately, one edge case in particular would ruin this plan:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么它不直接返回找到的值，而不是尾部？实际上，这本来是一个定义`member`函数的有用方法，因为它允许以这种方式将原始值传递给其他函数。不幸的是，有一个特定的边缘情况会破坏这个计划：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see in this example, the `member` function still gives the correct
    answer, even when we search for `nil` as the member! If the `member` function
    had actually returned `nil` (in other words, the original value we were searching
    for), it would have evaluated as false, and the example would have incorrectly
    stated that nil isn’t in the list. However, since the `member` function returns
    the tail of the list at the point of the found item, it can be guaranteed to always
    be a true value. A successful discovery of the desired value will always return
    a list with at least one value, which we know always evaluates as true.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此示例中看到的，即使我们搜索`nil`作为成员，`member`函数仍然给出正确答案！如果`member`函数实际上返回`nil`（换句话说，我们正在搜索的原始值），它将被评估为假，示例将错误地声明nil不在列表中。然而，由于`member`函数在找到的项目处返回列表的尾部，可以保证它始终是一个真值。成功发现所需值将始终返回至少包含一个值的列表，我们知道它始终评估为真。
- en: 'One function that really benefits from rich return values is `find-if`, as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正受益于丰富返回值的函数是`find-if`，如下所示：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `find-if` function actually takes another function, in this case `oddp`,
    as a parameter. `find-if` will find the first value in the list for which `oddp`
    returns true. In this case, it will find the first number (if any) that is an
    odd number.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`find-if` 函数实际上接受另一个函数作为参数，在这个例子中是 `oddp`。`find-if` 将找到列表中第一个使 `oddp` 返回 true
    的值。在这种情况下，它将找到第一个（如果有）奇数。'
- en: 'You can see clearly how `find-if` can fill dual roles: either as a retriever
    of values matching some constraint or as a true/false value inside a condition.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到 `find-if` 如何扮演双重角色：要么作为匹配某些约束条件的值的检索器，要么作为条件中的真/假值。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry yet about the weird hash mark (`#`) in front of `oddp` in the example.
    We’ll discuss the `find-if` function, and other so-called higher-order functions,
    in greater detail in [Chapter 7](ch08.html "Chapter 7. Going Beyond Basic Lists")
    and [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with Functional
    Programming").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于示例中 `oddp` 前面的奇怪井号 (`#`)，现在不用担心。我们将在第 7 章（[Chapter 7. 超越基本列表](ch08.html "Chapter
    7. Going Beyond Basic Lists")）和第 14 章（[Chapter 14. 使用函数式编程提升 Lisp 的水平](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming")）中更详细地讨论 `find-if`
    函数和其他所谓的更高阶函数。
- en: 'Alas, the elegant symmetry of the `find-if` function has a single, small, ugly
    wart. If we try our edge case again, searching for a `nil` value, we get a rather
    disappointing result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`find-if` 函数优雅的对称性有一个单一、微小、丑陋的瑕疵。如果我们再次尝试我们的边缘情况，搜索 `nil` 值，我们会得到一个相当令人失望的结果：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `null` function, which returns true for any of the `nil` values, correctly
    finds the `nil`. Unfortunately, in this one annoying case, we would not want to
    use `find-if` inside a conditional statement, because a correctly found value
    still returns a result that evaluates as false. The symmetry has been broken.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`null` 函数，对于任何 `nil` 值都返回 true，正确地找到了 `nil`。不幸的是，在这个令人烦恼的案例中，我们不想在条件语句中使用 `find-if`，因为正确找到的值仍然返回一个评估为
    false 的结果。对称性已经被打破。'
- en: These are the kinds of small things that make even grown Lispers shed a tear.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是那些甚至让成熟的 Lispers 流泪的小事情。
- en: 'Comparing Stuff: eq, equal, and More'
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较东西：等式、等于以及其他
- en: There’s a lot of beautiful symmetry in Lisp. One part of Lisp that isn’t so
    beautiful, though, involves the commands for comparing things.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 中有很多美丽的对称性。不过，Lisp 中不那么美丽的一部分涉及比较事物的命令。
- en: If you want to compare two values in Lisp to find out if they are “the same,”
    you will find a bewildering assortment of different functions that purport to
    accomplish this. Of these, `equal`, `eql`, `eq`, `=`, `string-equal`, and `equalp`
    are the most commonly used. A Lisper must understand the subtleties of these functions
    intimately in order to know how to compare values correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Lisp 中比较两个值以确定它们是否“相同”，你会发现一大堆不同的函数，这些函数都声称能完成这个任务。在这些函数中，`equal`、`eql`、`eq`、`=`、`string-equal`
    和 `equalp` 是最常用的。Lisper 必须深入了解这些函数的细微差别，才能正确地比较值。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782684.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782684.png)'
- en: Before we start dissecting this madness, let me give you Conrad’s Rule of Thumb
    for Comparing Stuff. Follow this rule, and though you may not be writing the world’s
    cleanest Lisp code, you will probably be able to post some samples to a newsgroup
    without more seasoned Lispers running you out of town with torches and pitchforks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始剖析这种疯狂之前，让我给你介绍一下康拉德比较东西的经验法则。遵循这个法则，尽管你可能不会写出世界上最干净的 Lisp 代码，但你很可能能够在新sgroup
    上发布一些样本，而不会让更有经验的 Lispers 用火炬和长柄叉把你赶出小镇。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782114.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782114.png)'
- en: 'Symbols should always be compared to other symbols with `eq`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 符号应该始终使用 `eq` 与其他符号进行比较：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `eq` function is the simplest of all the Lisp comparison functions, and
    it’s also very fast. It doesn’t really work for comparing items besides symbols,
    but if you consider the central role symbols play in Lisp, you’ll realize how
    useful this function can be. Experienced Lispers might look down on code if it
    compares two things, known to be symbols, with something other than `eq`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq` 函数是所有 Lisp 比较函数中最简单的，它也非常快。它实际上不适用于比较除符号以外的项，但如果你考虑到符号在 Lisp 中的核心作用，你会意识到这个函数是多么有用。经验丰富的
    Lispers 可能会看不起用除 `eq` 之外的方式比较两个已知是符号的代码。'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`eq` can also be used to compare conses (the links created by the cons command).
    However, it returns true values only when a cons is compared directly to itself,
    created by the same cons call. This means, two unrelated conses that “look” exactly
    the same can fail an eq test. Since `eq` can check a cons cell only against itself,
    using `eq` with conses isn’t really that useful for a beginner. However, an advanced
    Lisper may want to compare conses with `eq` under certain circumstances.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`eq` 也可以用来比较连接（由 cons 命令创建的链接）。然而，它仅在连接直接与其自身比较，且由相同的 cons 调用创建时才返回 true 值。这意味着，两个看似完全相同的无关连接可能会在
    eq 测试中失败。由于 `eq` 只能对 cons 单元进行自比较，因此对于初学者来说，使用 `eq` 与 cons 一起并不是特别有用。然而，对于高级 Lisp
    用户来说，在某些情况下可能会想要使用 `eq` 来比较 cons。'
- en: 'If you’re not dealing with two symbols, just use `equal`. This command will
    tell you when two things are `isomorphic`, meaning they “look the same.” It works
    for the whole suite of basic Lisp datatypes, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在处理两个符号，那么就使用 `equal`。这个命令会告诉你两个东西是否 `isomorphic`，即它们“看起来相同”。它适用于整个基本 Lisp
    数据类型系列，如下所示：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, most items in Lisp can be effectively compared with `equal`,
    including strings and characters (which are discussed in the next chapter).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Lisp 中的大多数项目都可以有效地使用 `equal` 进行比较，包括字符串和字符（将在下一章中讨论）。
- en: Now that you know the bare minimum about Lisp comparisons to fake your way through
    your next cocktail party, let’s look at all the other comparison commands.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Lisp 比较的最基本知识已经足够让你在下一个鸡尾酒会上混个脸熟，让我们来看看所有其他的比较命令。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783512.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783512.png)'
- en: 'The `eql` command is similar to the `eq` command, but unlike `eq`, it also
    handles comparisons of numbers and characters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`eql` 命令与 `eq` 命令类似，但与 `eq` 不同，它还处理数字和字符的比较：'
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `equalp` command is essentially the same as the `equal` command, except
    that it can handle some difficult comparison cases with a bit of extra sophistication.
    For instance, it can compare strings with different capitalizations and can compare
    integers against floating-point numbers:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`equalp` 命令基本上与 `equal` 命令相同，但它可以处理一些带有额外复杂性的困难比较情况。例如，它可以比较不同大小写的字符串，可以比较整数与浮点数：'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The remaining comparison commands are just specializations for specific datatypes.
    Otherwise, they are similar to `equal`. For instance, the = (equal sign) function
    handles numbers, `string-equal` handles strings, and `char-equal` handles characters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的比较命令只是针对特定数据类型的特殊化。否则，它们与 `equal` 类似。例如，等号（equal sign）函数处理数字，`string-equal`
    处理字符串，`char-equal` 处理字符。
- en: I hope that you can now appreciate just how seriously Lispers take comparisons.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在可以真正理解 Lisp 用户对比较的重视程度。
- en: What You've Learned
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到的内容
- en: 'In this chapter, we discussed how conditions work in Lisp. Along the way, you
    learned the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Lisp 中条件的工作方式。在这个过程中，你学习了以下内容：
- en: The values `nil`, `'nil`, `()`, and `'()` are all basically the same thing in
    Common Lisp.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nil`、`''nil`、`()` 和 `''()` 在 Common Lisp 中基本上是同一件事。'
- en: Lisp makes it easy to check for empty lists. This makes it simple to write list-eaters.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp 使得检查空列表变得容易。这使得编写列表消耗者变得简单。
- en: Lisp conditionals, such as the `if` command, cause Lisp code to be evaluated
    only under the right conditions.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp 条件，如 `if` 命令，仅在正确条件下才会评估 Lisp 代码。
- en: If you need a conditional command that does everything, then you want to use
    `cond`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个能够做所有事情的条件命令，那么你应该使用 `cond`。
- en: Comparing stuff in Lisp is complicated, but you can get by if you just use `eq`
    for comparing symbols and `equal` for comparing everything else.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Lisp 中比较东西很复杂，但如果你只是用 `eq` 来比较符号，用 `equal` 来比较其他所有东西，你就可以应付了。
- en: Chapter 5. Building a Text Game Engine
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：构建文本游戏引擎
- en: When you write a program, no matter which programming language you’re using
    or what your program does, it will probably need to work with text. Sure, one
    day we may all have Ethernet ports at the base of our skulls (100Mbps Ethernet
    will have been fully adopted by then, of course). But until the day arrives when
    you can just exchange thoughts with your MacBook using a direct hookup, you’ll
    be stuck using alphabetic text for input and output in your software.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写程序时，无论你使用哪种编程语言或你的程序做什么，它可能都需要处理文本。当然，总有一天我们可能都会在我们的头骨底部有以太网端口（到那时，100Mbps
    以太网将完全被采用）。但在你能够直接通过连接与 MacBook 交换思想的那一天到来之前，你将不得不在软件中使用字母文本进行输入和输出。
- en: Computers have always had a bit of a tenuous relationship with text. Although
    we tend to think of text processing as a central task for computer hardware and
    software (indeed, the 8-bit byte is the standard design element in modern computers,
    in large part, due to how well suited it is for encoding Western character sets),
    the truth of the matter is that the human concept of *text* is really alien to
    a computer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机始终与文本保持一种脆弱的关系。尽管我们倾向于认为文本处理是计算机硬件和软件的中心任务（确实，8位字节是现代计算机的标准设计元素，在很大程度上，这是由于它非常适合编码西文字符集），但事实的真相是，人类对*文本*的概念对计算机来说实际上是陌生的。
- en: 'In this chapter, you’ll learn how to use Lisp to manipulate text. You’ll see,
    once again, that the Lispy approach to solving problems allows you to create code
    that is full of elegance and symmetry. To demonstrate this approach, we will do
    something that would seem to make thinking with text unavoidable: build the engine
    for a simple text adventure game. However, we’ll do this in a way that avoids
    constraining our code by artificially forcing the human notion of text into its
    design. This will allow us to write code that focuses on the strengths of a computer.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用Lisp来操纵文本。你将再次看到，Lispy解决问题的方法允许你创建充满优雅和对称性的代码。为了展示这种方法，我们将做一些似乎不可避免地需要用文本思考的事情：构建一个简单的文本冒险游戏的引擎。然而，我们将以避免通过人为地将人类的文本概念强加于其设计来约束我们的代码的方式来做这件事。这将使我们能够编写专注于计算机优势的代码。
- en: As you read this chapter, remember that handling text is not a computer’s strength.
    It is a necessary evil best kept to a minimum.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章时，请记住，处理文本并不是计算机的长处。这是一个必要的恶，最好将其保持在最低限度。
- en: The Wizard's Adventure Game
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巫师的冒险游戏
- en: In this game, you are a wizard’s apprentice. You’ll explore the wizard’s house.
    When we complete the game (in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages")), you’ll be able to solve puzzles and win a magical donut.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，你是一名巫师的学徒。你将探索巫师的房子。当我们完成游戏（在第17章[Chapter 17](ch19.html "Chapter 17.
    Domain-Specific Languages")中）时，你将能够解决谜题并赢得一个魔法甜甜圈。
- en: Our Game World
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的游戏世界
- en: 'Here is a picture of our game world:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们游戏世界的一张图片：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780116.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780116.png)'
- en: 'As you can see, we can visit three different locations: a living room, an attic,
    and a garden. Players can move between places using the door and the ladder to
    the attic.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以访问三个不同的地点：客厅、阁楼和花园。玩家可以通过门和阁楼的梯子来在地方之间移动。
- en: 'Think of this game world as a simple directed graph with three nodes (represented
    as ellipses) and four edges (represented as arrows):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个游戏世界想象成一个简单的有向图，有三个节点（用椭圆表示）和四条边（用箭头表示）：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782728.png.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782728.png.jpg)'
- en: Players move between nodes by traveling along the edges in either direction.
    Wherever the players are, they can interact with various objects around them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过沿着边在两个方向上移动节点之间。无论玩家在哪里，他们都可以与他们周围的各种物体互动。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782136.png.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782136.png.jpg)'
- en: Basic Requirements
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本要求
- en: 'Our game code will need to handle a few basic things:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏代码需要处理一些基本的事情：
- en: Looking around
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环顾四周
- en: Walking to different locations
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走向不同的地点
- en: Picking up objects
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾起物体
- en: Performing actions on the objects picked up
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对拾起的物体执行操作
- en: In this chapter, we’ll address the first three of these requirements. To perform
    more complex actions on objects, we’ll use the more advanced Lisp techniques covered
    in later chapters. Because of this, our game engine will be somewhat limited in
    its abilities until we finish it in [Chapter 17](ch19.html "Chapter 17. Domain-Specific
    Languages").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决这些要求中的前三个。为了在物体上执行更复杂的行为，我们将使用后面章节中介绍的更高级的Lisp技术。因此，我们的游戏引擎在完成[第17章](ch19.html
    "Chapter 17. Domain-Specific Languages")之前将具有一定的局限性。
- en: 'When looking around in our game world, you will be able to “see” three kinds
    of things from any location:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当在游戏世界中环顾四周时，你将能够从任何位置“看到”三种类型的事物：
- en: Basic scenery
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本风景
- en: One or more paths to other locations
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到其他地点的一条或多条路径
- en: Objects that you can pick up and manipulate
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以捡起并操纵的物体
- en: Let’s add features for these one at a time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次添加一个这些功能。
- en: Describing the Scenery with an Association List
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关联列表描述风景
- en: 'The world inside our adventure game is very simple, containing only three locations.
    Let’s first create a top-level variable, `*nodes*`, to contain descriptions of
    the locations that exist in our game:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们冒险游戏中的世界非常简单，只包含三个位置。让我们首先创建一个顶层变量 `*nodes*`，以包含我们游戏中存在的位置的描述：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This variable contains a list and description of our three locations. In essence,
    the `*nodes*` variable basically gives us a way to find a piece of data associated
    with a lookup key. In this case, the key is the name of the place (`living-room`,
    `garden`, or `attic`), and the data is a text description of the scenery at that
    place. This type of structure is called an *association list*, or *alist* for
    short (alists are covered in greater detail in [Chapter 7](ch08.html "Chapter 7. Going
    Beyond Basic Lists")).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量包含了一个列表和三个位置的描述。本质上，`*nodes*` 变量基本上给我们提供了一种查找与查找键相关联的数据的方法。在这种情况下，键是地点的名称（`living-room`、`garden`
    或 `attic`），而数据是那个地点的文本描述。这种结构被称为 *关联列表*，或简称为 *alist*（alist 在第 7 章[超越基本列表](ch08.html
    "第 7 章。超越基本列表")中有更详细的介绍））。
- en: 'One thing is rather unusual about the definition of this `*nodes*` variable:
    Even though it contains descriptions of the various locations in our game world,
    it does not actually contain any text strings. Since Common Lisp has a string
    datatype, we could have written descriptions using quotes. For instance, we could
    have written `"You are in a beautiful garden. There is a well in front of you."`
    Instead, we use more fundamental datatypes—symbols and lists—to encode this information.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个 `*nodes*` 变量的定义有一件相当不寻常的事情：尽管它包含了我们游戏世界中各种位置的描述，但它实际上并不包含任何文本字符串。由于 Common
    Lisp 有字符串数据类型，我们本可以使用引号来编写描述。例如，我们可以写成 `"你在一个美丽的花园里。你面前有一个井。"` 而不是这样，我们使用更基本的数据类型——符号和列表——来编码这些信息。
- en: Why wouldn’t we just use strings? As I mentioned at the beginning of this chapter,
    the manipulation of text is not really a fundamental computing concept. In this
    game, we’ll manipulate the messages displayed to players based on their interaction
    with the game world in complicated ways. For most real-world programs, the information
    you’ll generate as output (such as HTML, PDFs, or even richer graphical formats)
    will probably be far more complicated than just simple text.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么不直接使用字符串呢？正如我在本章开头提到的，文本操作并不是真正的计算基本概念。在这个游戏中，我们将以复杂的方式操作玩家与游戏世界交互时显示的消息。对于大多数现实世界的程序，你将生成的输出信息（如
    HTML、PDF 或甚至更丰富的图形格式）可能比简单的文本复杂得多。
- en: By keeping your source data structures free from assumptions regarding the output
    format from the start, your coding can take full advantage of your programming
    language. Since the easiest things to manipulate in Lisp are symbols and lists,
    most experienced Lispers will try to focus on these datatypes in the design of
    their software whenever possible. So, we will stay away from strings in our design.
    (In the next chapter, we will translate these lists and symbols into properly
    formatted text.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从一开始就确保你的源数据结构不受输出格式的假设影响，你的编码可以充分利用你的编程语言。由于在 Lisp 中最易操作的是符号和列表，大多数经验丰富的
    Lisp 程序员在可能的情况下都会尝试在软件设计中专注于这些数据类型。因此，在我们的设计中我们将避免使用字符串。（在下一章中，我们将把这些列表和符号转换成正确格式的文本。）
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Common Lisp doesn’t force you to represent strings with lists and symbols in
    this way. If it’s more convenient, you can work with strings directly. (You’ll
    see examples of working with strings later in the book, especially in [Chapter 11](ch12.html
    "Chapter 11. Printing Text with the format Function").) Using lists and symbols
    as an intermediary for manipulating text is definitely an old-school Lisp technique.
    However, it can often lead to very elegant code, since list operations are so
    fundamental to Lisp.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 并不强制你以这种方式使用列表和符号来表示字符串。如果更方便，你可以直接处理字符串。（你将在本书后面的例子中看到如何处理字符串，特别是在第
    11 章[打印文本的 format 函数](ch12.html "第 11 章。使用 format 函数打印文本")中。）使用列表和符号作为操作文本的中间件无疑是传统的
    Lisp 技术。然而，它往往能产生非常优雅的代码，因为列表操作对于 Lisp 来说是如此基础。
- en: Describing the Location
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述位置
- en: 'Now that we’ve created an alist of our game world, we need to create a command
    to describe a location. To accomplish this, we’ll use the `assoc` function to
    find the correct item in the list using a key:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们游戏世界的 alist，我们需要创建一个命令来描述一个位置。为了完成这个任务，我们将使用 `assoc` 函数通过一个键来在列表中找到正确项：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using `assoc`, we can easily create the `describe-location` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `assoc`，我们可以轻松地创建 `describe-location` 函数：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use this function, we pass in a location and the `*nodes*` list:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，我们需要传递一个位置和`*nodes*`列表：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Why don’t we just reference the `*nodes*` variable directly from the `describe-location`
    function? Because this function is written in the *functional programming* style.
    In this style, a function will reference only parameters or variables declared
    in the function itself, and it will do nothing besides return a value, which is
    the description of the location in this case.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不直接从`describe-location`函数中引用`*nodes*`变量呢？因为这个函数是用*函数式编程*风格编写的。在这种风格中，一个函数将只引用函数本身中声明的参数或变量，并且除了返回一个值（在这种情况下是位置的描述）之外，不会做任何事情。
- en: By writing functions that don’t reference variables in the “outside world” directly
    and that don’t perform any actions other than returning a value, you can write
    code that can easily be tested in isolation. You should try to write your Lisp
    functions in this style whenever possible. (We will discuss the functional programming
    style in greater detail in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up
    a Notch with Functional Programming").)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写不直接引用“外部世界”中的变量且不执行任何除了返回值之外的操作的函数，你可以编写可以轻松隔离测试的代码。你应该尽可能以这种方式编写你的Lisp函数。（我们将在第14章[第14章](ch16.html
    "第14章。使用函数式编程提升Lisp水平")中更详细地讨论函数式编程风格。）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782164.png.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782164.png.jpg)'
- en: Describing the Paths
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述路径
- en: Now that we have basic descriptions of each location, we need descriptions of
    paths to other locations as well. We’ll create a second variable, `*edges*`, that
    contains the paths that players can take to move between places on our map. (We
    use the term *edges* because that’s the proper math term for the lines connecting
    nodes in a graph.)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了每个位置的基本描述，我们还需要其他位置的路径描述。我们将创建第二个变量`*edges*`，它包含玩家可以在地图上移动到其他地点的路径。
    （我们使用术语*edges*，因为这是连接图中节点的线的正确数学术语。）
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using this structure, we create the `describe-path` function, which builds a
    textual description of a given edge using our symbols system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们创建了一个`describe-path`函数，它使用我们的符号系统构建给定边的文本描述。
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This `describe-path` function looks pretty strange—almost like a piece of data
    more than a function. Let’s try it, and then figure out how it works.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`describe-path`函数看起来相当奇怪——几乎更像是一段数据而不是一个函数。让我们试一试，然后弄清楚它是如何工作的。
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function basically returns a piece of data with small bits of calculated
    information inserted into it. This feature of Lisp, called *quasiquoting*, allows
    us to create chunks of data that have small pieces of Lisp code embedded in them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数基本上返回一个包含少量计算信息的片段数据。Lisp的这个特性称为*准引用*，它允许我们创建包含少量Lisp代码嵌入的数据块。
- en: How Quasiquoting Works
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用准引用
- en: To enable quasiquoting, you must use a backquote [`` ` ``] not a single quote
    [`'`] when switching from code to data mode. The `describe-path` function has
    just such a backquote in it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用准引用，你必须使用反引号[`` ` ``]而不是单引号[`'`]在从代码模式切换到数据模式时。`describe-path`函数中就有这样一个反引号。
- en: Both the single quote and backquote in Lisp “flip” a piece of code into data
    mode, but only a backquote can also be *unquoted* using the comma character, to
    flip back into code mode.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp中的单引号和反引号都将一段代码“翻转”成数据模式，但只有反引号可以使用逗号字符进行*取消引用*，从而翻转回代码模式。
- en: 'With a little imagination, this should make sense to you. After all, a comma
    does look just like an upside-down backquote, doesn’t it? Here’s how the flip-flop
    in the `describe-path` function works (the parts in code mode are shaded):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 用一点想象力，这应该对你来说是有意义的。毕竟，逗号看起来就像一个倒置的反引号，不是吗？下面是如何在`describe-path`函数中实现翻转的（代码模式的部分被阴影覆盖）：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779865.png.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779865.png.jpg)'
- en: Lisp attempts to make list manipulation as easy as possible. Here, you can see
    how our program, which uses lists of symbols to store our text, can now leverage
    the quasiquoting feature to construct sentences in a very concise and clear way.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp试图使列表操作尽可能简单。在这里，你可以看到我们的程序，它使用符号列表来存储我们的文本，现在可以利用准引用功能以非常简洁和清晰的方式构建句子。
- en: Describing Multiple Paths at Once
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述多个路径
- en: 'Now let’s use our `describe-path` function to create a more advanced function.
    Since a location may have any number of paths exiting from it, we need a function
    that can generate descriptions for all edges from a given location by looking
    up the location from our data structure of edges:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的 `describe-path` 函数来创建一个更高级的函数。由于一个位置可能从它那里有任意数量的路径退出，我们需要一个函数，可以通过查找我们的边数据结构来生成从给定位置的所有边的描述：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function uses a bunch of commands that may seem very exotic to a person
    not accustomed to the world of Lisp. Many programming languages would use some
    kind of for-next loop to run through the edges, and then cram the descriptions
    of each path together using a temporary variable. Lisp uses a much more elegant
    approach. Let’s see it in action:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了一些可能对不熟悉 Lisp 世界的人来说非常陌生的命令。许多编程语言会使用某种形式的 for-next 循环来遍历边，然后使用临时变量将每条路径的描述组合在一起。Lisp
    使用一种更优雅的方法。让我们看看它是如何工作的：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `describe-paths` function takes the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe-paths` 函数执行以下步骤：'
- en: Find the relevant edges.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到相关边。
- en: Convert the edges to descriptions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边转换为描述。
- en: Join the descriptions.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并描述。
- en: Let’s see how it performs each of these steps.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何执行这些步骤的。
- en: Finding the Relevant Edges
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找相关边。
- en: 'The first, inner part of the `describe-paths` function is pretty straightforward.
    To find the relevant paths and edges leading from the living room, we use `assoc`
    again to look up the location in our list of edges:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe-paths` 函数的第一部分相当直接。为了找到从客厅出发的相关路径和边，我们再次使用 `assoc` 在边的列表中查找位置：'
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Converting the Edges to Descriptions
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将边转换为描述。
- en: 'Next, the edges are converted to descriptions. Here is just the code to accomplish
    this, shown in isolation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将边转换为描述。以下只是完成此任务的代码，单独展示：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `mapcar` function is used frequently by Lispers. This function takes another
    function and a list, and then applies this function to every member of a list.
    Here’s an example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 程序员经常使用 `mapcar` 函数。这个函数接受另一个函数和一个列表，然后将这个函数应用到列表的每一个成员上。以下是一个例子：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This example passes the `sqrt` (square root) function, along with the `(1 2
    3 4 5)` list, into `mapcar`. As a result, the function generates a list of the
    square roots of the original numbers by applying `sqrt` to every member of the
    list and creating a new list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将 `sqrt`（平方根）函数和 `(1 2 3 4 5)` 列表传递给 `mapcar`。结果，该函数通过将 `sqrt` 应用到列表的每个成员并创建一个新列表，生成原始数字的平方根列表。
- en: Functions that take other functions as parameters, such as `mapcar`, are very
    useful and a distinguishing feature of Lisp. Such functions are called *higher-order
    functions*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为参数的函数，如 `mapcar`，非常有用，并且是 Lisp 的一个显著特征。这些函数被称为 *高阶函数*。
- en: 'Here is another example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, our source list contains two smaller lists. The `car` function, which
    grabs the first item in a list, causes `mapcar` to return the first items from
    each smaller list, `foo` and `baz`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的源列表包含两个较小的列表。`car` 函数，它获取列表中的第一个项目，导致 `mapcar` 返回每个较小列表 `foo` 和 `baz`
    的第一个项目。
- en: 'You may be wondering why the function names we pass into `mapcar` have the
    `#''` symbols in front of them. This symbol sequence is a shorthand for the `function`
    operator. The Lisp reader (the part of your Lisp environment that reads the code
    you type) will convert the previous example into the following longer version:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们传递给 `mapcar` 的函数名前为什么有 `#'` 符号。这个符号序列是 `function` 操作符的缩写。Lisp 读取器（你的
    Lisp 环境中读取你输入代码的部分）会将前面的例子转换为以下更长的版本：
- en: '[PRE40]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Common Lisp requires you to use the `function` operator when referring to a
    function as a value directly like this, because the name of a function may conflict
    with other named items in a program, causing unpredictable errors. For instance,
    imagine if we added more stuff to the previous example, like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 要求你在直接将函数作为值引用时使用 `function` 操作符，因为函数的名称可能与程序中的其他命名项冲突，导致不可预测的错误。例如，想象如果我们向前面的例子添加更多内容，如下所示：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this version, the `car` symbol could have two different meanings. The first
    meaning of car is that it is a standard function built into Lisp (introduced in
    [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp Code")). However,
    we’re also creating a local variable named `car` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Because we prepended the word `car` with `#'` in our call to `mapcar` ![](httpatomoreillycomsourcenostarchimages783562.png),
    there is no confusion about which `car` we are talking about.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，`car` 符号可能有两种不同的含义。`car` 的第一种含义是它是 Lisp 中内置的标准函数（在第 3 章[第 3 章。探索 Lisp
    代码的语法](ch03.html "第 3 章。探索 Lisp 代码的语法")中介绍）。然而，我们也在创建一个名为 `car` 的局部变量 ![http://atomoreilly.com/source/no_starch/images/783564.png](http://atomoreilly.com/source/no_starch/images/783564.png)。由于我们在调用
    `mapcar` 时在 `car` 前面加上了 `#'` ![http://atomoreilly.com/source/no_starch/images/783562.png](http://atomoreilly.com/source/no_starch/images/783562.png)，所以我们不会混淆我们正在谈论的是哪个
    `car`。
- en: 'Now let’s look at the `describe-paths` function again:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看看 `describe-paths` 函数：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice how the `append` and `describe-path` functions are passed in as values
    to the `apply` and `mapcar` functions, which are designed to receive and use the
    functions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `append` 和 `describe-path` 函数是如何作为值传递给 `apply` 和 `mapcar` 函数的，这些函数被设计用来接收和使用函数。
- en: Common Lisp tracks function names differently from variable names. It has multiple
    *namespaces*, including one for variables and one for functions. (We’ll learn
    more about namespaces later, especially in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").) Scheme, the other popular Lisp dialect, doesn’t force
    you to mark functions with a function operator when using them as values.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 对函数名和变量名的跟踪方式不同。它有多个 *命名空间*，包括一个用于变量和一个用于函数的。（我们将在第 16 章[第 16 章。Lisp
    宏的魔法](ch18.html "第 16 章。Lisp 宏的魔法")中了解更多关于命名空间的内容。）另一种流行的 Lisp 方言 Scheme，在将函数用作值时，并不强制要求你用函数操作符标记函数。
- en: In other words, Scheme has only one namespace for both functions and variables.
    For instance, in Scheme, you can just write `(map sqrt '(1 2 3 4 5))` to generate
    the square roots of the numbers 1 through 5 without generating an error (`map`
    is the Scheme version of `mapcar`). As a result of this design, in Scheme, a variable
    and a separate function can’t be available in the same block of code. That design
    decision is one of the great benefits (or curses) of Scheme, depending on your
    point of view. Because of this difference in the number of namespaces, Scheme
    is sometimes called a *Lisp-1*, whereas Common Lisp is sometimes referred to as
    a *Lisp-2*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Scheme 只有一个命名空间用于函数和变量。例如，在 Scheme 中，你可以直接编写 `(map sqrt '(1 2 3 4 5))`
    来生成从 1 到 5 的数字的平方根，而不会产生错误（`map` 是 `mapcar` 的 Scheme 版本）。由于这种设计，在 Scheme 中，一个变量和单独的函数不能在相同的代码块中可用。这个设计决策是
    Scheme 的巨大好处（或诅咒）之一，这取决于你的观点。由于命名空间数量的这种差异，Scheme 有时被称为 *Lisp-1*，而 Common Lisp
    有时被称为 *Lisp-2*。
- en: Joining the Descriptions
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入描述
- en: 'Once we’ve used `mapcar` to generate a list of descriptions for all the paths
    and edges, we need to combine them into a single description. We accomplish this
    with the `append` function, which joins several lists into one big list:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `mapcar` 生成所有路径和边的描述列表，我们需要将它们合并成一个单一的描述。我们通过 `append` 函数完成这个任务，它将几个列表合并成一个大的列表：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We use the `append` function to cram the list of path descriptions into one
    list that describes the whole enchilada, in one swoop. The problem is that `append`
    needs all of the lists handed to it as separate parameters. In `describe-paths`,
    we have our lists in one big list, not as separate objects we can pass as parameters.
    Heck, we don’t even know how many paths there may be from any given spot.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `append` 函数将路径描述的列表合并成一个描述整个事物的列表，一次完成。问题是 `append` 需要所有传递给它的列表作为单独的参数。在
    `describe-paths` 中，我们的列表是一个大列表，而不是可以作为参数传递的单独对象。实际上，我们甚至不知道从任何给定位置可能有多少条路径。
- en: 'The `apply` function solves this problem. You pass it a function and a list
    of objects, and it pretends that the items in the list are separate objects and
    passes them to the given function as such. For example, if we have the nested
    list `''((mary had) (a) (little lamb))`, the `apply` function will add in that
    little bit of duct tape needed to make the `append` function work with a single
    big list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数解决了这个问题。你传递给它一个函数和一个对象列表，它假装列表中的项是单独的对象，并将它们作为这样的对象传递给指定的函数。例如，如果我们有一个嵌套列表
    `''((mary had) (a) (little lamb))`，`apply` 函数将添加一小块胶带，使 `append` 函数能够与单个大列表一起工作：'
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Warning
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Since the `apply` function passes each item in a list as an argument to the
    `target` function, you can run into problems when calling it on very large lists
    that have thousands of items or more. You can check the value of the `call-arguments-limit`
    variable in the REPL to see the maximum number of allowed arguments to a function.
    (More recent dialects of Lisp are typically designed to allow argument lists of
    any size, without an artificial limit.)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`apply`函数将列表中的每个项目作为参数传递给`target`函数，当在包含数千项或更多项的非常大的列表上调用它时，你可能会遇到问题。你可以在REPL中检查`call-arguments-limit`变量的值，以查看函数允许的最大参数数量。（较新的Lisp方言通常设计为允许任何大小的参数列表，而没有人工限制。）
- en: 'You can see how `apply` enables the `describe-paths` function to build one
    long list describing all paths leading from a single location. Let’s use this
    same approach on the path description lists we constructed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`apply`如何使`describe-paths`函数能够构建一个长列表，描述从单个位置出发的所有路径。让我们使用这种方法来处理我们构建的路径描述列表：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we’ve looked at each part of the `describe-paths` function, let’s
    review how it works:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看完`describe-paths`函数的每个部分，让我们回顾一下它是如何工作的：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function takes two parameters: the current player’s location, as well as
    an alist of edges/paths for the game map. First, it uses `assoc` to look up the
    correct location from the edge alist. Since `assoc` returns both the key and the
    value from the alist, we call `cdr` to retrieve only the value. Next, we use `mapcar`
    to map the `describe-path` function against each edge that we found. Finally,
    we concatenate the lists for describing all the paths into one long list by applying
    `append` against the list.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个参数：当前玩家的位置以及游戏地图的边/路径的关联列表。首先，它使用`assoc`从边列表中查找正确的位置。由于`assoc`从关联列表中返回键和值，我们调用`cdr`来检索仅值。接下来，我们使用`mapcar`将`describe-path`函数映射到我们找到的每个边上。最后，通过应用`append`将描述所有路径的列表连接成一个长列表。
- en: The programming style used by `describe-path` is very typical for Lisp code.
    It involves passing along a complicated chunk of data and manipulating it in several
    steps, often using higher-order functions. To become a proficient Lisp programmer,
    you should try to get comfortable reading code written in this way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe-path`使用的编程风格对于Lisp代码来说非常典型。它涉及传递一个复杂的数据块并在几个步骤中对其进行操作，通常使用高阶函数。要成为一名熟练的Lisp程序员，你应该尝试习惯阅读以这种方式编写的代码。'
- en: Describing Objects at a Specific Location
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述特定位置的对象
- en: To create the final piece of code to help us visualize our game world, we need
    to describe the objects on the floor at a given location, which a player can pick
    up and use.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建帮助我们可视化游戏世界的最终代码片段，我们需要描述给定位置地板上的对象，玩家可以捡起并使用它们。
- en: Listing Visible Objects
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出可见对象
- en: 'To do so, we first create a list of the objects:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先创建一个对象列表：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780738.png.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages780738.png.jpg)'
- en: 'We can also create a second variable, `*object-locations*`, to track the location
    of each object in the form of an alist:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建第二个变量`*object-locations*`，以关联列表的形式跟踪每个对象的位置：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we write a function that lists the objects visible from a given location:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写一个函数来列出从给定位置可见的对象：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This `objects-at` function declares a new function named `at-loc-p` using the
    `labels` command ![](httpatomoreillycomsourcenostarchimages783564.png). (Remember
    that the `labels` function allows you to define functions locally.) Since the
    `at-loc-p` function won’t be used elsewhere, we can just declare it directly within
    `objects-at`, hiding it from the rest of the code in our program.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`objects-at`函数使用`labels`命令声明了一个名为`at-loc-p`的新函数！[](httpatomoreillycomsourcenostarchimages783564.png)。
    (记住，`labels`函数允许你在局部定义函数。) 由于`at-loc-p`函数不会在其他地方使用，我们可以在`objects-at`函数内部直接声明它，从而将其隐藏在程序中其他代码之外。'
- en: The `at-loc-p` function takes the symbol for an object and returns `t` or `nil`,
    depending on whether that object exists at the location `loc`. It does this by
    looking up the object in the `obj-locs` alist. Then, it uses `eq` to see whether
    the location it finds matches the location in question ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`at-loc-p`函数接受一个对象的符号，并根据该对象是否存在于位置`loc`返回`t`或`nil`。它是通过在`obj-locs`关联列表中查找对象来做到这一点的。然后，它使用`eq`来查看找到的位置是否与所讨论的位置匹配！[](httpatomoreillycomsourcenostarchimages783562.png)。'
- en: Why did we name this function `at-loc-p`? When a function returns `nil` or a
    truth value, it’s a Common Lisp convention to append a `p` to the end of that
    function’s name. For instance, you can check that the number 5 is odd by calling
    `(oddp 5)`. Such true/false functions are called *predicates*, which is why we
    use the letter `p`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们把这个函数命名为 `at-loc-p`？当一个函数返回 `nil` 或一个真值时，这是 Common Lisp 的一个约定，在函数名称的末尾附加一个
    `p`。例如，你可以通过调用 `(oddp 5)` 来检查数字 5 是否为奇数。这样的真/假函数被称为 *predicates*，这就是为什么我们使用字母
    `p`。
- en: The `remove-if-not` function in the last line of the listing ![](httpatomoreillycomsourcenostarchimages783560.png),
    as you might expect, removes all things from a list for which a passed-in function
    (in this case, `at-loc-p`) doesn’t return true. Essentially, it returns a filtered
    list of objects consisting of those items for which `at-loc-p` is true.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表最后一行的 `remove-if-not` 函数，正如你所预期的那样，会从列表中移除所有那些传入的函数（在这种情况下，`at-loc-p`）不返回
    true 的项目。本质上，它返回一个过滤后的对象列表，包含那些 `at-loc-p` 返回 true 的项目。
- en: 'Here’s what `object-at` looks like in action:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `object-at` 函数的实际应用：
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Describing Visible Objects
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述可见对象
- en: 'Now we can write a function to describe the objects visible at a given location:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个函数来描述给定位置可见的对象：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this listing, `describe-objects` first creates the `describe-obj` function
    ![](httpatomoreillycomsourcenostarchimages783564.png). This function generates
    a pretty sentence stating that a given object is on the floor, using quasiquoting
    ![](httpatomoreillycomsourcenostarchimages783562.png). The main part of the function
    consists of calling `objects-at` to find the objects at the current location,
    mapping `describe-obj` across this list of objects, and finally appending the
    descriptions into a single list ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，`describe-objects` 首先创建了一个 `describe-obj` 函数！[](httpatomoreillycomsourcenostarchimages783564.png)。这个函数生成一个漂亮的句子，说明一个给定的对象在地板上，使用伪引用！[](httpatomoreillycomsourcenostarchimages783562.png)。函数的主要部分是调用
    `objects-at` 来找到当前位置的对象，将 `describe-obj` 映射到这个对象列表上，并最终将这些描述追加到一个单独的列表中！[](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Let’s try running `describe-objects`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行 `describe-objects`：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Perfect!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783048.png.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages783048.png.jpg)'
- en: Describing It All
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述一切
- en: 'Now we’ll tie all of these description functions into one easy command called
    `look`. Because this will be the actual command players can enter to look around
    them in the game, `look` will need to know a player’s current location. So, we
    need a variable to track the player’s current position. Let’s call it `*location*`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将所有这些描述函数整合到一个简单的命令 `look` 中。因为这个命令将是玩家在游戏中四处张望时可以输入的实际命令，所以 `look` 需要知道玩家的当前位置。因此，我们需要一个变量来跟踪玩家的当前位置。让我们称它为
    `*location*`：
- en: '[PRE53]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Because the `*location*` value is initialized to the `living-room` symbol,
    which occurs at the very start of the game, players will find themselves in the
    living room of the wizard’s house. At this point, we can write a `look` function
    to describe everything we need by having it call all of our descriptor functions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `*location*` 的值初始化为 `living-room` 符号，它在游戏开始时出现，玩家将发现自己身处巫师的房子客厅里。在这个时候，我们可以编写一个
    `look` 函数来描述我们所需要的一切，通过调用所有的描述函数来实现：
- en: '[PRE54]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since the `look` function uses global variable names (such as `*location*`,
    `*nodes*`, and so on), the player won’t need to pass in any funky values in order
    to look out at the world. However, this also means that the `look` function is
    not in the functional programming style, because functions in the functional programming
    style reference only parameters or variables declared in the function itself.
    `*location*` and its ilk are global variables, so the `look` function doesn’t
    hold up muster.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `look` 函数使用全局变量名（如 `*location*`、`*nodes*` 等），玩家在查看世界时不需要传递任何奇怪的值。然而，这也意味着
    `look` 函数不是函数式编程风格，因为在函数式编程风格中，函数只引用函数本身声明的参数或变量。`*location*` 及其类似物是全局变量，所以 `look`
    函数不符合标准。
- en: Since the player’s location changes as the game progresses, `look` will do *different
    things at different times* in the game. In other words, the things you see when
    looking around will change depending on your location. In contrast, a function
    in the functional programming style always returns the same result, as long as
    the same values are given as parameters. The earlier functions we created, such
    as `describe-location`, `describe-paths`, and `describe-objects`, always return
    the same thing, no matter when they are called, *as long as their parameters are
    kept the same*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于玩家的位置在游戏过程中会发生变化，`look` 在游戏中的不同时间会做**不同的事情**。换句话说，当你环顾四周时看到的物品会根据你的位置而变化。相比之下，函数式编程风格中的函数只要参数相同，总是返回相同的结果。我们之前创建的函数，如
    `describe-location`、`describe-paths` 和 `describe-objects`，无论何时调用，只要它们的参数保持不变，总是返回相同的内容。
- en: 'Now here’s what we see when we use `look`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看使用 `look` 时我们看到的内容：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781300.png.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781300.png.jpg)'
- en: Walking Around in Our World
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的世界中四处走动
- en: 'Now that we can see things in our world, let’s write some code so that we can
    walk around. The `walk` function (not in the functional style) takes a direction
    and lets us walk there:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们世界中的事物了，让我们编写一些代码，以便我们可以四处走动。`walk` 函数（不是函数式风格）接受一个方向，并允许我们走到那里：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: First, this function looks up the available walking paths in the `*edges*` table,
    using the current location ![](httpatomoreillycomsourcenostarchimages783562.png).
    This is used by the `find` function to locate the path marked with the appropriate
    direction ![](httpatomoreillycomsourcenostarchimages783564.png). (`find` searches
    a list for an item, then returns that found item.) The `direction` (such as `west`,
    `upstairs`, and so on) will be in the `cadr` of each path, so we need to tell
    `find` to match the `direction` against the `cadr` of all the paths in the list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数会在 `*edges*` 表中查找可用的行走路径，使用当前的位置 ![httpatomoreillycomsourcenostarchimages783562.png]。这是由
    `find` 函数用来定位带有适当方向的路径 ![httpatomoreillycomsourcenostarchimages783564.png]。(`find`
    在列表中搜索一个项目，然后返回找到的项目。)方向（如 `west`、`upstairs` 等）将位于每个路径的 `cadr` 中，因此我们需要告诉 `find`
    将 `direction` 与列表中所有路径的 `cadr` 进行匹配。
- en: 'We can do this by passing `find` a *keyword parameter* ![](httpatomoreillycomsourcenostarchimages783560.png).
    In Common Lisp, many functions (such as `find`) have built-in features that can
    be accessed by passing in special parameters at the end of the function call.
    For instance, the following code finds the first item in a list that has the symbol
    `y` in the `cadr` location:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向 `find` 传递一个 **关键字参数** ![httpatomoreillycomsourcenostarchimages783560.png]
    来做到这一点。在 Common Lisp 中，许多函数（如 `find`）具有内置功能，可以通过在函数调用末尾传递特殊参数来访问。例如，以下代码在列表中找到第一个在
    `cadr` 位置有符号 `y` 的项目：
- en: '[PRE57]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A keyword parameter has two parts:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数有两个部分：
- en: The first is the name (in this case `:key`), which begins with a colon. (We’ll
    discuss the meaning of this colon in more detail in [Chapter 7](ch08.html "Chapter 7. Going
    Beyond Basic Lists").)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分是名称（在这个例子中是 `:key`），它以冒号开头。（我们将在 [第 7 章](ch08.html "第 7 章。超越基本列表") 中更详细地讨论这个冒号的意义。）
- en: The second is the value, which in this case is `#'cadr`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是值，在这个例子中是 `#'cadr`。
- en: We use keyword parameters the same way in our `walk` function to find the proper
    path based on the given direction.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `walk` 函数中，我们以相同的方式使用关键字参数来根据给定的方向找到合适的路径。
- en: Once we have the correct path, we store the result in the variable `next` ![](httpatomoreillycomsourcenostarchimages783564.png).
    The `if` expression then checks whether `next` has a value ![](httpatomoreillycomsourcenostarchimages783554.png)
    (the `next` variable isn’t `nil`). If `next` has a value, `if` adjusts the player’s
    position because this is a valid direction ![](httpatomoreillycomsourcenostarchimages783510.png).
    The call to `look` ![](httpatomoreillycomsourcenostarchimages783544.png) retrieves
    the description for the new location and returns it as a value. If the player
    chooses an invalid direction, `look` will generate an admonishment instead of
    a new description ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到正确的路径，我们就将结果存储在变量 `next` 中！。然后 `if` 表达式检查 `next` 是否有值！（`next` 变量不是 `nil`）。如果
    `next` 有值，`if` 就会调整玩家的位置，因为这是一个有效方向！。调用 `look` 函数！检索新位置的描述并将其作为值返回。如果玩家选择了一个无效方向，`look`
    将生成一个警告而不是新描述！。
- en: 'Here’s what our `walk` function looks like now:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们 `walk` 函数的样子如下：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There’s a quote in front of the direction, since the direction name needs to
    be written in data mode. It’s kind of awkward to force a player to put a quote
    in a game command, but the interface we are creating now is intended for easy
    debugging and development. Heck, it’s almost not even worth calling an “interface,”
    since we just enter the game commands directly into the REPL. In the next chapter,
    we’ll create a much nicer interface using a custom REPL designed for playing text
    games that will take care of this wart.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 方向前有一个引号，因为方向名需要以数据模式书写。强迫玩家在游戏命令中放置引号有点尴尬，但我们现在创建的界面是为了方便调试和开发。实际上，这几乎都不值得称为“界面”，因为我们只是直接将游戏命令输入到
    REPL 中。在下一章中，我们将创建一个更漂亮的界面，使用定制的 REPL，它专为玩文本游戏而设计，将处理这个瑕疵。
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You could use Lisp *macros* to create a command in a vanilla Lisp REPL that
    doesn’t require the quote in front of the direction, so that you could just write
    `(walk west)`, for instance. You’ll learn more about macros in [Chapter 16](ch18.html
    "Chapter 16. The Magic of Lisp Macros").
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Lisp *宏* 在不需要在方向前加引号的 vanilla Lisp REPL 中创建命令，这样你就可以直接写 `(walk west)`，例如。你将在第
    16 章（[第 16 章。Lisp 宏的魔力](ch18.html "第 16 章。Lisp 宏的魔力")）中了解更多关于宏的内容。
- en: Picking Up Objects
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取物体
- en: 'Next, let’s create a command to pick up objects in our world. To do so, we
    modify the variable `*object-locations*` that we’re using to track the location
    of objects:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个命令来拾取我们世界中的物体。为此，我们修改了用于跟踪物体位置的变量 `*object-locations*`：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `pickup` function uses the `member` ![](httpatomoreillycomsourcenostarchimages783564.png)
    function to see if the `object` is indeed on the floor of the current location.
    (The `member` function checks to see if a particular item is found in a list of
    items.) We use the `objects-at` command ![](httpatomoreillycomsourcenostarchimages783562.png)
    to generate the lists of objects at the current location.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickup` 函数使用 `member` 函数来检查 `object` 是否确实位于当前位置的地板上。（`member` 函数检查特定项目是否在项目列表中。）我们使用
    `objects-at` 命令来生成当前位置的物体列表。'
- en: If the object is at the current location, we use the push command ![](httpatomoreillycomsourcenostarchimages783560.png)
    to push a new item onto the `*object-locations*` list, consisting of the item
    and its new location. The new location will just be `body`, for the player’s body.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体位于当前位置，我们使用 `push` 命令！将一个新项目推入 `*object-locations*` 列表中，包括项目和它的新位置。新位置将是
    `body`，即玩家的身体。
- en: 'The `push` command ![](httpatomoreillycomsourcenostarchimages783560.png) simply
    adds a new item to the front of a list variable’s list. For example, the following
    example adds the number `7` to the list `1 2 3`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 命令！简单地将一个新项目添加到列表变量的列表前面。例如，以下示例将数字 `7` 添加到列表 `1 2 3` 中：'
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This `push` command is basically a convenience function built on top of `setf`.
    For example, we could have replaced the preceding `push` command with `(setf *foo*
    (cons 7 *foo*))` and obtained the same result. It’s just easier to use `push`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `push` 命令基本上是在 `setf` 之上构建的一个便利函数。例如，我们可以用 `(setf *foo* (cons 7 *foo*))`
    来替换前面的 `push` 命令，并得到相同的结果。只是使用 `push` 更简单。
- en: Pushing a new location for an object onto our `*object-locations*` alist does
    seem a bit odd. Since we’re never removing old locations for objects, just pushing
    new ones, it means that `*object-locations*` may contain multiple entries for
    a single object, and that this list now has two stored locations for the object
    in question. Fortunately, the `assoc` command, which we use to find objects in
    a given location (within the `objects-at` command), always returns the first item
    it finds in a list. Therefore, using the `push` command makes the `assoc` command
    behave as if the value in the list for a given key has been replaced altogether.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新位置推送到我们的 `*object-locations*` 列表确实看起来有点奇怪。因为我们从未删除过对象的老位置，只是推送新的位置，这意味着
    `*object-locations*` 可能会包含单个对象的多个条目，而这个列表现在为该对象存储了两个位置。幸运的是，我们用来在给定位置（在 `objects-at`
    命令中）查找对象的 `assoc` 命令总是返回列表中找到的第一个项目。因此，使用 `push` 命令使得 `assoc` 命令表现得好像列表中给定键的值已经被完全替换。
- en: Using the `push` and `assoc` commands together in this way allows us to pretend
    that values in an alist are changing, while still preserving old values. Old values
    are simply suppressed by newer values, thus preserving a history of all old values.
    The `push`/`assoc` idiom is a common technique used by Lispers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `push` 和 `assoc` 命令以这种方式一起使用，我们可以假装alist中的值在变化，同时仍然保留旧值。旧值只是被新值压制，从而保留所有旧值的历史。`push`/`assoc`
    习语是Lisper常用的技术。
- en: 'Now let’s walk back to the living room and try to pick up an object:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到客厅并尝试拿起一个物品：
- en: '[PRE61]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It worked. We’re carrying the whiskey, which means that we can now pick up things
    in our world!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了。我们现在携带了威士忌，这意味着我们现在可以在我们的世界中拿起东西了！
- en: Checking Our Inventory
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们的库存
- en: 'Finally, let’s create a function that lets players see an inventory of objects
    they are carrying:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个允许玩家查看他们携带的物品清单的函数：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This inventory function uses the `objects-at` function to retrieve a list of
    objects at a requested location. What location does it search for? If you remember,
    when an object was picked up by the player, we changed its location to `''body`:
    This is the location we now use to query.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库存函数使用 `objects-at` 函数检索请求位置上的对象列表。它搜索什么位置？如果你还记得，当一个对象被玩家拿起时，我们将其位置更改为 `'body'`：这是我们现在用来查询的位置。
- en: 'Let’s try out this `inventory` function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下这个 `inventory` 函数：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, we are carrying only one item right now: the whiskey bottle
    we just picked up.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在只携带一个物品：我们刚刚捡起的威士忌瓶子。
- en: There you have it! We now have a basic engine for a text adventure game. We
    can look around the world with `look`; walk between places with `walk`; pick up
    objects with `pickup`; and check our inventory with `inventory`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们现在有一个基本的文字冒险游戏引擎。我们可以用 `look` 来环顾四周；用 `walk` 在地方之间行走；用 `pickup` 拿起物品；用
    `inventory` 检查我们的库存。
- en: Of course, we don’t really have much of a game, since we can’t *do* anything
    with the objects we find. We’ll add a mechanism for actually manipulating objects
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages"). In the next
    chapter, we’ll focus on improving our game’s user interface. Even though the REPL
    is perfect for prototyping our game, adding a custom text game interface will
    make the game play more seamless for the player.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们实际上并没有一个真正的游戏，因为我们无法对找到的对象进行任何操作。我们将在第17章（[第17章](ch19.html "第17章。特定领域的语言")）中添加一个实际操作对象的机制。在下一章中，我们将专注于改进我们游戏的用户界面。尽管REPL非常适合我们的游戏原型设计，但添加一个定制的文本游戏界面将使游戏对玩家来说玩起来更加流畅。
- en: What You've Learned
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we put together a simple engine for a text adventure game.
    Along the way, you learned the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为文字冒险游戏构建了一个简单的引擎。在这个过程中，你学习了以下内容：
- en: A game world can be represented by a mathematical graph, consisting of *nodes*
    for the places the player can visit and *edges* for the paths between these places.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏世界可以用一个数学图来表示，其中包括玩家可以访问的 `*nodes*`（节点）和这些地方之间的 `*edges*`（边）。
- en: You can store these nodes in an *association list* (*alist*) called `*nodes*`.
    This *alist* allows you to look up properties of a node/place by using its name.
    In the case of our game, the property we’re storing is a description of each node/place.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将这些节点存储在一个名为 `*nodes*` 的 `*association list*`（关联列表）中。这个列表允许你通过节点的名称来查找节点/位置的性质。在我们的游戏中，我们存储的性质是每个节点/位置的描述。
- en: You use the assoc function to look up a key (location name in our example) in
    an alist.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 `assoc` 函数在一个alist中查找一个键（在我们的例子中是位置名称）。
- en: '*Quasiquoting* is a technique that allows you to insert small bits of computer
    code into larger pieces of data.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪引号**是一种技术，允许你将小块计算机代码插入到更大的数据块中。'
- en: Some Lisp functions accept other functions as arguments. These are called *higher-order
    functions*. The `mapcar` function is the most popular higher-order function in
    Common Lisp.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 Lisp 函数接受其他函数作为参数。这些被称为**高阶函数**。`mapcar` 函数是 Common Lisp 中最受欢迎的高阶函数。
- en: To replace a value from an alist, you `push` new items onto the list. Only the
    most recent value will be reported by the `assoc` function.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要替换 alist 中的值，你需要将新项目“push”到列表中。`assoc` 函数只会报告最新的值。
- en: 'Chapter 6. Interacting with the World: Reading and Printing in Lisp'
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 与世界交互：Lisp 中的读取和打印
- en: So far, we haven’t written any code that directly interacts with the outside
    world. Instead, all the results generated by commands are just returned as values,
    which we can see by calling functions from our Lisp REPL.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有编写任何直接与外界交互的代码。相反，所有由命令生成的结果都只是作为值返回，我们可以通过调用我们的 Lisp REPL 中的函数来看到这些值。
- en: However, code can’t just spend its whole life sitting in a black box. At some
    point, it’s going to need to interact with the world, so it will need a user interface.
    Luckily, Lisp has much to offer to help you create user interfaces. There are
    many graphical user interface libraries for different flavors of Common Lisp,
    as well as libraries for building web interfaces. In fact, we’ll be building our
    own toy web interface in [Chapter 13](ch14.html "Chapter 13. Let's Create a Web
    Server!").
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码不能整日坐在黑盒子里。在某个时候，它将需要与世界交互，因此它需要一个用户界面。幸运的是，Lisp 提供了许多帮助创建用户界面的工具。有针对不同
    Common Lisp 版本的各种图形用户界面库，以及用于构建 Web 界面的库。实际上，我们将在第 13 章[构建 Web 服务器！](ch14.html
    "第 13 章. 让我们创建一个 Web 服务器！")中构建自己的玩具 Web 界面。
- en: In this chapter, we’ll focus on the most basic of all user interfaces, the *command-line
    interface*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注所有用户界面中最基本的，即**命令行界面**。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783418.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783418.png)'
- en: Printing and Reading Text
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印和读取文本
- en: For a command-line interface, we need commands that can directly print text
    from the screen and read in text entered by the user. The two commands that do
    this are, appropriately enough, `print` and `read`. As you might expect by now,
    there is a lot of symmetry between these two commands.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令行界面，我们需要能够直接从屏幕打印文本并读取用户输入的文本的命令。执行此操作的两个命令恰当地是 `print` 和 `read`。正如你所期望的，这两个命令之间有很多对称性。
- en: Printing to the Screen
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印到屏幕
- en: 'The `print` function simply lets you print stuff to the console:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数简单地允许你将内容打印到控制台：'
- en: '[PRE64]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Don’t get confused by the fact that calling the `print` function caused `"foo"`
    to be printed twice. The first `"foo"` ![](httpatomoreillycomsourcenostarchimages783564.png)
    is what the `print` function *actually printed*. The second `"foo"` ![](httpatomoreillycomsourcenostarchimages783562.png)
    is there because, as you know, the REPL always prints the value of any expression
    that is entered. It so happens that the value of `(print "foo")` is `"foo"`, causing
    the word to be shown twice. In the examples that follow in this chapter, I’ll
    typically omit this extra final value printed by the REPL, just to avoid confusion.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被调用 `print` 函数导致 `"foo"` 被打印两次的事实所困惑。第一个 `"foo"` ![](httpatomoreillycomsourcenostarchimages783564.png)
    是 `print` 函数**实际上打印的内容**。第二个 `"foo"` ![](httpatomoreillycomsourcenostarchimages783562.png)
    存在是因为，正如你所知，REPL 总是打印输入的任何表达式的值。恰好 `(print "foo")` 的值是 `"foo"`，导致单词被显示两次。在本章接下来的示例中，我通常会省略
    REPL 打印的额外最终值，以避免混淆。
- en: 'The `print` function is an easy way to print a Lisp value to the screen. However,
    advanced Lispers often favor a related function called `prin1`. To understand
    the difference, let’s try both of these functions out in the REPL:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数是一种将 Lisp 值打印到屏幕的简单方法。然而，高级 Lisp 程序员通常更喜欢一个相关的函数，称为 `prin1`。为了理解两者之间的区别，让我们在
    REPL 中尝试这两个函数：'
- en: '[PRE65]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `print` function causes each item to be printed on a separate line. Now,
    let’s try `prin1`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数会导致每个项目单独打印在一行上。现在，让我们尝试 `prin1`：'
- en: '[PRE66]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As you can see, `prin1` does not put the printed items on separate lines. To
    be precise, the `print` and `prin1` commands are the same in every way, except
    that `print` will start a new line before printing a value. Additionally, print
    places a space character at the end of the printed value.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`prin1` 不会将打印的项放在单独的行上。更准确地说，`print` 和 `prin1` 命令在各个方面都是相同的，除了 `print`
    在打印值之前会开始新的一行。此外，`print` 还会在打印值的末尾放置一个空格字符。
- en: Because `prin1` does less, it is really a simpler, more fundamental function.
    It is more flexible and, therefore, is commonly used in more serious Lisp code.
    We’ll use the `print` function more frequently in this book, but you should be
    aware of the `prin1` command, as well.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `prin1` 做得较少，它实际上是一个更简单、更基本的函数。它更灵活，因此通常在更严肃的 Lisp 代码中使用。在这本书中，我们将更频繁地使用
    `print` 函数，但您应该了解 `prin1` 命令。
- en: Saying Hello to the User
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向用户问好
- en: The following example is a simple function, `say-hello`, that you can call from
    your Lisp prompt. It asks users for their name and responds with a greeting. *When
    you run the program, be sure to type quotes around your name, even if this may
    seem odd*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的函数示例，名为 `say-hello`，您可以从 Lisp 提示符中调用它。它会询问用户的姓名，并以问候语作为回应。*当您运行程序时，请务必在您的姓名周围输入引号，即使这看起来可能有些奇怪*。
- en: '[PRE67]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the first line of the `say-hello` function, we print a message asking users
    for their name ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we
    define a local variable called `name`, which is set to the value returned by the
    `read` function ![](httpatomoreillycomsourcenostarchimages783562.png). The `read`
    function will cause Lisp to wait for the user to type in something at the REPL.
    Only after the user has typed something in at the prompt and pressed enter will
    the variable `name` be set to the result. Once we know the user’s name, a personalized
    message is printed, greeting the user ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `say-hello` 函数的第一行中，我们打印了一条消息，询问用户输入他们的姓名 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。然后，我们定义了一个名为
    `name` 的局部变量，并将其设置为 `read` 函数返回的值 ![图片](httpatomoreillycomsourcenostarchimages783562.png)。`read`
    函数将使 Lisp 等待用户在 REPL 中输入某些内容。只有当用户在提示符中输入了一些内容并按下回车键后，变量 `name` 才会被设置为结果。一旦我们知道用户的姓名，就会打印一条个性化的消息，问候用户
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)![图片](httpatomoreillycomsourcenostarchimages783554.png)。
- en: 'As you can see from this simple function, the `print` and `read` functions
    do (almost) exactly what you would expect. The `print` function prints something
    on the screen. The `read` function lets the user enter something into the program.
    However, there is one glaring idiosyncrasy in these functions: Every value displayed
    and entered is surrounded by quotation marks.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这个简单的函数中可以看到，`print` 和 `read` 函数（几乎）完全符合您的预期。`print` 函数会在屏幕上打印一些内容。`read`
    函数允许用户将一些内容输入到程序中。然而，这些函数中有一个明显的特性：显示和输入的每个值都被引号包围。
- en: Starting with print and read
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 print 和 read 开始
- en: When you need to print something on the screen, you should first think of the
    `print` command. If you need to read something in, you should first think of the
    `read` command. Other printing commands let you create the previous example without
    having superfluous quotes, but whenever you have an input or output task in Lisp,
    you should ask yourself, “Can `print` or `read` do the job?” You will save yourself
    a lot of trouble if you always use these two functions as your starting point.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在屏幕上打印某些内容时，您应该首先考虑使用 `print` 命令。如果您需要读取某些内容，您应该首先考虑使用 `read` 命令。其他打印命令可以让您创建之前的示例，而不需要多余的引号，但每当您在
    Lisp 中进行输入或输出任务时，您都应该问自己，“`print` 或 `read` 能完成这项工作吗？”如果您始终以这两个函数作为起点，您将节省很多麻烦。
- en: Warning
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: The `read` command can be dangerous if used in the wrong way. See [The Dangers
    of read and eval](ch06s05.html "The Dangers of read and eval") in [The Dangers
    of read and eval](ch06s05.html "The Dangers of read and eval") for details.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用不当，`read` 命令可能会很危险。有关详细信息，请参阅[《read 和 eval 的危险》](ch06s05.html "The Dangers
    of read and eval")。
- en: The `print` and `read` functions think about values with the mind of a computer,
    not the mind of a human. A computer loves having strings of text surrounded by
    quotes. It doesn’t have a human brain, and consequently, it can’t understand what
    we mean when we feed it raw textual information. However, if a text fragment is
    surrounded by quotes, even a dumb old computer can figure out that the value we’re
    handing it is probably a string of text.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 和 `read` 函数是用计算机的思维来考虑值的，而不是人类的思维。计算机喜欢被引号包围的文本字符串。它没有人类的头脑，因此当我们给它提供原始文本信息时，它无法理解我们的意图。然而，如果一个文本片段被引号包围，即使是愚蠢的老式计算机也能推断出我们传递给它的值可能是一串文本。'
- en: The `print` and `read` commands actually take this philosophy to the extreme.
    Almost any conceivable type of data in Lisp (with the exception of actual functions
    and some advanced data structures) can be printed and read using these commands,
    without the slightest bit of loss along the way. You can probably already imagine
    some scenarios where this feature would be immensely valuable, such as writing
    some hairy and huge piece of data to a file, and loading it in again at a later
    date.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 和 `read` 命令实际上将这种哲学推向了极致。在 Lisp 中几乎任何可想象的数据类型（除了实际函数和一些高级数据结构）都可以使用这些命令打印和读取，而不会有一点损失。你可能已经能够想象出一些这个特性会非常有价值的场景，比如将一些复杂和庞大的数据写入文件，然后在以后再次加载它。'
- en: As a simple example, the following code has *exactly* the same design as the
    previous function, but amazingly, it can read and print a number instead of a
    string. Notice how the program prints and reads numbers without the use of quotes,
    since Lisp knows when something is a number just by seeing the number in its raw
    form.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，以下代码与前面的函数有*完全相同*的设计，但令人惊讶的是，它可以读取和打印一个数字而不是字符串。注意程序如何在不使用引号的情况下打印和读取数字，因为
    Lisp 只需看到其原始形式中的数字就能知道它是什么。
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Let’s look at some more examples of what happens when we use `print` to write
    out values.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用 `print` 来输出值时会发生什么的一些更多例子。
- en: '[PRE69]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: These examples are all really boring, since `print` pretty much just prints
    out exactly what we put in. Note that we put an explicit quote on the front of
    each value. It could be omitted and would be implicit in all cases but the symbol
    name, since a symbol can also refer to functions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子都非常无聊，因为 `print` 几乎只是打印出我们放入的内容。请注意，我们在每个值的前面都明确地放置了引号。它可以省略，在所有情况下都是隐式的，除了符号名称，因为符号也可以指代函数。
- en: The last example shows how literal characters are entered in Lisp. To create
    a Lisp character, just place the `#\` symbols in front of the actual character.
    Lisp also has special literals defined for nonvisible characters. The most important
    for everyday use are `#\newline`, `#\tab`, and `#\space`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子展示了如何在 Lisp 中输入字面字符。要创建一个 Lisp 字符，只需在实际字符前放置 `#\` 符号。Lisp 还为不可见字符定义了特殊的字面量。对于日常使用来说，最重要的是
    `#\newline`、`#\tab` 和 `#\space`。
- en: A table of output from the `read` function would look just as boring as this
    table for `print`, in the same symmetrical way.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 函数的输出表将和 `print` 函数的这张表一样无聊，以同样的对称方式。'
- en: Note
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the examples above I stated that Common Lisp symbols are blind to letter
    case. While this is true for most strings, it is in fact possible to create case-sensitive
    symbols by surrounding the symbol with the vertical pipe `|`. So the symbol `|CaseSensitiveSymbol|`
    will retain its case. Symbols surrounded by vertical pipes can even contain punctuation.
    Hence `|even this is a legal Lisp symbol!|`
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我提到 Common Lisp 符号对字母大小写是盲目的。虽然这对于大多数字符串来说是正确的，但实际上可以通过用垂直管道 `|` 包围符号来创建大小写敏感的符号。因此，符号
    `|CaseSensitiveSymbol|` 将保留其大小写。被垂直管道包围的符号甚至可以包含标点符号。因此 `|even this is a legal
    Lisp symbol!|` 也是一个合法的 Lisp 符号！
- en: Reading and Printing Stuff the Way Humans Like It
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以人类喜欢的方式读取和打印内容
- en: 'Of course, our initial little `say-hello` function does a pretty awful job
    of greeting people, even if it has some interesting properties. It would be much
    better if we had more functions that could make it friendlier for humans. Actually,
    we can create a (very symmetrical) little table that summarizes what we would
    like:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们最初的 `say-hello` 函数在问候人们方面做得相当糟糕，即使它有一些有趣的特性。如果我们有更多可以使它对人类更友好的函数会更好。实际上，我们可以创建一个（非常对称的）小表格，总结我们想要的内容：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782488.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782488.png)'
- en: 'As you can see, Lisp has a command that can print pieces of data in a way that
    is appealing to humans. The princ function can take any piece of Lisp data, and
    it tries to print that data in a way humans would prefer. It will do the basic
    things you might expect: leave off the quotes on a string, print characters in
    their raw form, and so on. Here are some examples:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Lisp有一个命令可以以对人类有吸引力的方式打印数据片段。`princ`函数可以接受任何Lisp数据，并尝试以人类更喜欢的形式打印这些数据。它会做你可能会期望的基本事情：省略字符串上的引号，以原始形式打印字符等等。以下是一些示例：
- en: '[PRE70]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here’s an example of `princ`ing a character that has a special meaning:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示如何`princ`一个具有特殊意义的字符：
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: By its nature, `princ` could be used to print any arbitrary output of characters
    you want. This is fundamentally different from `print`. As we’ve discussed, the
    cool thing about the `print` command is that it prints objects in such a way that
    they can always be “read” back into their internal representation. However, this
    means `print` can’t be used to generate any arbitrary bit of text. On the other
    hand, `princ` can be used to print anything you want.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`princ`可以用来打印任何你想要的字符输出。这与`print`有根本的不同。正如我们讨论过的，`print`命令的酷之处在于它以某种方式打印对象，使得它们总能被“读取”回它们的内部表示。然而，这意味着`print`不能用来生成任何任意的文本。另一方面，`princ`可以用来打印任何你想要的东西。
- en: Therefore, although `princ` can print stuff in a way that humans prefer, it’s
    a one-way street. Once we’ve printed things with `princ`, only a humanlike intelligence
    could decipher how to change things back into a meaningful, appropriate Lisp data
    structure. Since computers are too stupid to do this right now, it means our beloved
    symmetry has been broken.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管`princ`可以以人类更喜欢的形式打印内容，但它是一条单行道。一旦我们用`princ`打印了东西，只有类似人类的智能才能解读如何将这些内容转换回有意义的、适当的Lisp数据结构。由于计算机目前还无法做到这一点，这意味着我们心爱的对称性已经被打破。
- en: Of course, we could always cheat and come up with some arbitrary rules for how
    the computer should interpret what the human enters. An obvious way to do this
    would be to say to the computer, “Just let the users type in whatever they want
    until they hit the enter key, then treat the whole thing as a string.” The function
    that does this in Common Lisp is called `read-line`. However, it has none of the
    sophistication of the `read`, `print`, and `princ` functions, since it knows about
    nothing beyond characters and strings.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们总是可以作弊并制定一些任意的规则来让计算机解释人类输入的内容。一种明显的方法是告诉计算机，“让用户输入他们想要的任何内容，直到他们按下回车键，然后将整个内容视为一个字符串。”在Common
    Lisp中执行此操作的功能称为`read-line`。然而，它没有`read`、`print`和`princ`函数的任何复杂性，因为它只知道字符和字符串。
- en: 'With this new knowledge, we can finally go full circle and create a proper
    function for greeting someone, without ugly quotes or other oddities:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些新知识，我们终于可以完整地创建一个用于问候某人的函数，而不需要丑陋的引号或其他奇怪的东西：
- en: '[PRE72]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This version of the `say-hello` function is similar to our first version. However,
    when the computer asks users for their name ![](httpatomoreillycomsourcenostarchimages783564.png),
    it now does so without printing quotes around the text string. The same holds
    true to when we print the greeting ![](httpatomoreillycomsourcenostarchimages783560.png)![](httpatomoreillycomsourcenostarchimages783554.png).
    Also, users can now enter in *any* name (including a name with spaces and quotes),
    since the `read-line` command ![](httpatomoreillycomsourcenostarchimages783562.png)
    captures and returns all the text entered until the enter key is pressed, without
    any fuss.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`say-hello`函数与我们的第一个版本类似。然而，当计算机请求用户输入他们的名字 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)，现在它不再在文本字符串周围打印引号。同样的情况也适用于打印问候语
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。此外，用户现在可以输入任何名字（包括包含空格和引号的名字），因为`read-line`命令
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png) 会捕获并返回直到按回车键之前输入的所有文本，而不会出现任何麻烦。
- en: The Symmetry Between Code and Data in Lisp
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp中代码与数据之间的对称性
- en: You have seen that Lisp has very elegant and symmetrical facilities for translating
    raw string data from the outside world and converting it to and from Lisp syntax
    expressions. But Lisp has an even deeper symmetry. It can treat program code and
    data interchangeably. A programming language that uses the same data structures
    to store data and program code is called *homoiconic*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 Lisp 有非常优雅和对称的工具，可以将原始字符串数据从外部世界转换成 Lisp 语法表达式，反之亦然。但 Lisp 有更深层次的对称性。它可以将程序代码和数据互换使用。使用相同的数据结构来存储数据和程序代码的编程语言被称为
    *同构的*。
- en: 'You saw an example of homoiconicity in [Chapter 3](ch03.html "Chapter 3. Exploring
    the Syntax of Lisp Code"), when we discussed code mode and data mode. In that
    example, we used the quote to change between the two modes:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html "第 3 章。探索 Lisp 代码的语法")中，我们讨论了代码模式和数据模式时，你看到了同构性的一个例子。在那个例子中，我们使用引号在两种模式之间切换：
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the previous chapter, we took this concept one step further by using a quasiquote
    when defining the `describe-path` function.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过在定义 `describe-path` 函数时使用伪引号，将这个概念又推进了一步。
- en: 'But the quoting and quasiquoting facilities in Lisp are somewhat limited in
    their abilities. What if we generate a piece of Lisp code from scratch somehow
    and wish to execute it as if it were a piece of code? For example, let’s store
    a raw chunk of code inside a variable:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Lisp 中的引号和伪引号功能在能力上有些有限。如果我们以某种方式从头生成一段 Lisp 代码并希望像代码一样执行它怎么办？例如，让我们将一段原始代码存储在一个变量中：
- en: '[PRE74]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'How could we execute the code that’s in the `*foo*` variable? We need an even
    more powerful command to make this possible. This is the `eval` command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何执行 `*foo*` 变量中的代码？我们需要一个更强大的命令来实现这一点。这就是 `eval` 命令：
- en: '[PRE75]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Because the `eval` command is so powerful and yet so simple, it is extremely
    enticing to beginning Lispers. You want to write a program with self-modifying
    code? Then `eval` will be your best friend. In fact, this is probably the main
    reason why the artificial intelligence (AI) freaks back in the day loved Lisp
    so much. Go ahead and try writing some programs that use the `eval` command. You’ll
    find that it’s a lot of fun.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `eval` 命令既强大又简单，对初学者来说极具吸引力。你想编写一个具有自我修改代码的程序？那么 `eval` 将是你的最佳选择。实际上，这可能是过去人工智能（AI）爱好者如此热爱
    Lisp 的主要原因。尝试编写一些使用 `eval` 命令的程序。你会发现这非常有趣。
- en: However, an experienced Lisper will only rarely use `eval`. Until you have a
    few thousand lines of Lisp code under your belt, you really won’t know when it
    is appropriate to use this extremely powerful command. Often, a beginning Lisper
    will use the `eval` command instead of defining a Lisp macro. We will discuss
    macros in [Chapter 16](ch18.html "Chapter 16. The Magic of Lisp Macros").
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有经验的 Lisp 程序员很少使用 `eval`。在你积累了几千行 Lisp 代码之前，你真的不知道何时适当地使用这个极其强大的命令。通常，初学者会用
    `eval` 命令代替定义 Lisp 宏。我们将在[第 16 章](ch18.html "第 16 章。Lisp 宏的魔力")中讨论宏。
- en: The bottom line is that the symmetry of data and code in Lisp pretty much makes
    Lisp the poster child of homoiconicity. Quoting, quasiquoting, the `eval` command,
    and macros allow you to take advantage of this property in your code.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Lisp 中数据和代码的对称性几乎使 Lisp 成为同构性的典范。引号、伪引号、`eval` 命令和宏允许你在代码中利用这一特性。
- en: Warning
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Inexperienced use of `eval` can pose a security risk. See [The Dangers of read
    and eval](ch06s05.html "The Dangers of read and eval") in [The Dangers of read
    and eval](ch06s05.html "The Dangers of read and eval") for more information.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 不当使用 `eval` 可能会带来安全风险。更多信息请参阅[读取和评估的危险](ch06s05.html "读取和评估的危险")。
- en: Adding a Custom Interface to Our Game Engine
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的游戏引擎添加自定义界面
- en: So far, we’ve been using the Lisp REPL to enter our game commands. It’s amazing
    how well this works for prototyping our game. But now that you’ve gained an understanding
    of the basic Common Lisp input and output commands, we can begin to put in place
    our own custom text game interface, which will be better suited for interacting
    with the player.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Lisp REPL 来输入我们的游戏命令。这对于我们的游戏原型设计来说效果非常好。但现在你已经了解了基本的 Common Lisp
    输入和输出命令，我们可以开始构建我们自己的自定义文本游戏界面，这将更适合与玩家交互。
- en: Setting Up a Custom REPL
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置自定义 REPL
- en: 'Creating your own REPL in Lisp is almost laughably easy. Here’s a simple custom
    REPL for our game, which lets us call the `look` command in exactly the same way
    as the standard REPL did:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在Lisp中创建自己的REPL几乎可以说是轻而易举的。以下是我们游戏的一个简单自定义REPL，它允许我们以与标准REPL完全相同的方式调用`look`命令：
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Stop me if this explanation of `game-repl` is confusing: First it `read`s a
    command, then `eval`s it, and finally `print`s it. The only command you haven’t
    seen before is `loop` (covered in detail in [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")), which as you might expect, simply loops forever. (In
    CLISP, you’ll need to hit ctrl-C and type `:a` to get out of the infinite loop.)
    As you can see, it’s easy to build your own REPL by simply calling `read`, `eval`,
    `print`, and `loop`.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个关于`game-repl`的解释让你感到困惑，请打断我：首先它`read`s一个命令，然后`eval`s它，最后`print`s它。你之前没有见过的唯一命令是`loop`（在[第10章](ch11.html
    "第10章。使用loop命令循环")中详细介绍），正如你所期望的，它只是无限循环。在CLISP中，你需要按ctrl-C并输入`:a`才能退出无限循环。正如你所见，通过简单地调用`read`、`eval`、`print`和`loop`，很容易构建自己的REPL。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779964.png.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/779964.png.jpg)'
- en: 'Of course, to customize the behavior of our REPL, we’ll want to call our own
    versions of these functions. Also, we’ll want a way to exit from our game in a
    more graceful manner. So, let’s redefine `game-repl` as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了自定义我们REPL的行为，我们希望调用这些函数的自己的版本。此外，我们希望有一种更优雅的方式退出游戏。因此，让我们按照以下方式重新定义`game-repl`：
- en: '[PRE77]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this version, we first capture the command the player types using a local
    variable, `cmd` ![](httpatomoreillycomsourcenostarchimages783564.png). This way,
    we can intercept any attempt to call `quit` and use it to exit our `game-repl`.
    In other words, we want to continue running our REPL unless the user typed `quit`
    ![](httpatomoreillycomsourcenostarchimages783562.png). Otherwise, the function
    `eval`s and `print`s ![](httpatomoreillycomsourcenostarchimages783560.png), but
    using our custom versions of these functions, which we’ll write shortly. Finally,
    the `game-repl` function calls itself recursively ![](httpatomoreillycomsourcenostarchimages783554.png),
    causing it to loop back, as long as we had not decided to quit earlier.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们首先使用局部变量`cmd`![image](http://atomoreilly.com/source/nostarch/images/783564.png)捕获玩家输入的命令。这样，我们可以拦截任何尝试调用`quit`并使用它来退出我们的`game-repl`。换句话说，我们希望REPL继续运行，除非用户输入了`quit`![image](http://atomoreilly.com/source/nostarch/images/783562.png)。否则，函数`eval`s和`print`s![image](http://atomoreilly.com/source/nostarch/images/783560.png)，但使用我们即将编写的自定义版本。最后，`game-repl`函数递归地调用自身![image](http://atomoreilly.com/source/nostarch/images/783554.png)，只要我们没有在之前决定退出，它就会循环回。
- en: Writing a Custom read Function
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写自定义的`read`函数
- en: 'The purpose of our `game-read` function is to fix the two annoyances that make
    the standard Lisp `read` function wrong for playing our game:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`game-read`函数的目的是修复使标准Lisp `read`函数不适合玩游戏的两个烦恼：
- en: The standard Lisp `read` forces us to put parentheses around our commands. As
    any old-school text adventure player knows, we should be able to just type `look`
    without any parentheses. To accomplish this, we can just call `read-line` and
    stick in our own parentheses.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的Lisp `read`强制我们在命令周围加上括号。正如任何老式文字冒险游戏玩家所知，我们应该能够只输入`look`而不加任何括号。为了实现这一点，我们可以简单地调用`read-line`并插入我们自己的括号。
- en: With `read`, we must put a quote in front of any function commands. We should
    be able to type `walk east` without a quote in front of `east`. To do this, we’ll
    stick a quote in front of the parameters after the fact.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`read`时，我们必须在所有函数命令前加上引号。我们应该能够输入`walk east`而无需在`east`前加引号。为此，我们将在事后在参数前加上引号。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780882.png.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/780882.png.jpg)'
- en: 'Here’s a definition of `game-read` that does both of these things:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`game-read`的一个定义，它同时做了这两件事：
- en: '[PRE78]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `read-from-string` command ![](httpatomoreillycomsourcenostarchimages783564.png)
    works just like the `read` command, but lets us read a syntax expression (or any
    other basic Lisp datatype) from a string instead of directly from the console.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`read-from-string`命令![image](http://atomoreilly.com/source/nostarch/images/783564.png)的工作方式与`read`命令类似，但它允许我们从字符串中读取语法表达式（或任何其他基本Lisp数据类型），而不是直接从控制台读取。'
- en: The string we use for this is a tweaked version of a string we get from `read-line`
    ![](httpatomoreillycomsourcenostarchimages783562.png). We tweak it by adding quotes
    around it using the `concatenate` command, which can be used for concatenating
    strings together, as well as some parentheses. The result is that the `cmd` variable
    will be set to the player’s requested command and converted into a Lisp syntax
    expression. For example, if the player types in `walk east`, the `cmd` variable
    will be set to the expression `(walk east)`, which is a list containing two symbols.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的字符串是 `read-line` ![httpatomoreillycomsourcenostarchimages783562.png] 获取的字符串的一个修改版本。我们通过使用
    `concatenate` 命令在其周围添加引号来修改它，该命令可以用于连接字符串，以及一些括号。结果是 `cmd` 变量将被设置为玩家请求的命令，并转换为
    Lisp 语法表达式。例如，如果玩家输入 `walk east`，则 `cmd` 变量将被设置为表达式 `(walk east)`，它是一个包含两个符号的列表。
- en: Next, we define a local function called `quote-it` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which we can use to quote any arguments the player has in a command. How exactly
    does it manage to quote a parameter? Well, it turns out that the single quote
    is just shorthand for a Lisp command called `quote`. This means that `'foo` and
    `(quote foo)` are the same. We can quote a raw parameter by simply putting the
    parameter in a list with the `quote` command in front.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为 `quote-it` 的局部函数 ![httpatomoreillycomsourcenostarchimages783560.png]，我们可以使用它来引用玩家在命令中的任何参数。它究竟是如何引用参数的呢？好吧，结果是单引号只是
    Lisp 命令 `quote` 的简写。这意味着 `'foo` 和 `(quote foo)` 是相同的。我们可以通过将参数放入一个带有 `quote` 命令的列表中来引用原始参数。
- en: Remember that local functions can be defined with `labels` or `flet`. Since
    we are not using any recursion in the `quote-it` function ![](httpatomoreillycomsourcenostarchimages783560.png),
    we can use the simpler `flet` command. The final line in the `game-read` function
    applies `quote-it` to every argument in the player’s command. It does this by
    mapping `quote-it` across the `cdr` of the `cmd` variable ![](httpatomoreillycomsourcenostarchimages783554.png)
    (and then attaching the first word in the command back on front with `car`).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，局部函数可以用 `labels` 或 `flet` 定义。由于我们在 `quote-it` 函数 ![httpatomoreillycomsourcenostarchimages783560.png]
    中没有使用任何递归，我们可以使用更简单的 `flet` 命令。`game-read` 函数中的最后一行将 `quote-it` 应用到玩家命令中的每个参数。它是通过将
    `quote-it` 映射到 `cmd` 变量的 `cdr` ![httpatomoreillycomsourcenostarchimages783554.png]（然后使用
    `car` 将命令中的第一个单词重新附加到前面）来做到这一点的。
- en: 'Let’s try our new function:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的新函数：
- en: '[PRE79]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As you can see, the `game-read` function is able to add parentheses and quotes—just
    what our game needs!
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`game-read` 函数能够添加括号和引号——这正是我们游戏所需要的！
- en: Note
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our custom reader has some limitations that a sufficiently boneheaded game player
    could conceivably bring to the surface. The player could enter a weird string
    like `"(look"`, with mismatched parentheses, and it would cause a Lisp exception
    in the `game-read` command. There’s nothing wrong with this, per se, since the
    standard `read` command will also act strangely when given garbled input. (In
    this case, it will let you enter another line of input in the hopes that you will
    eventually supply it with the missing parenthesis.) However, our `game-repl` doesn’t
    handle this situation properly, causing the actual `game-repl` to crash. This
    would be as if you were playing Zork and typed in a command so vile that it took
    down the Zork game itself. This rare situation could be addressed by having additional
    exception handling, as discussed in [Chapter 13](ch14.html "Chapter 13. Let's
    Create a Web Server!").
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制读取器有一些限制，一个足够愚蠢的游戏玩家可能会将其暴露出来。玩家可以输入一个奇怪的字符串，如 `"(look"`，括号不匹配，这会在 `game-read`
    命令中引发 Lisp 异常。就其本身而言，这并没有什么问题，因为标准的 `read` 命令在接收到混乱的输入时也会表现得奇怪。（在这种情况下，它会让你输入另一行输入，希望你会最终提供缺失的括号。）然而，我们的
    `game-repl` 并没有正确处理这种情况，导致实际的 `game-repl` 崩溃。这就像你在玩 Zork，输入了一个如此恶心的命令，以至于它本身就把
    Zork 游戏搞崩溃了。这种情况可以通过额外的异常处理来解决，如第 13 章所述 [Chapter 13](ch14.html "第 13 章。让我们创建一个
    Web 服务器！")。
- en: Writing a game-eval Function
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写游戏评估函数
- en: 'Now that we’ve created a nigh-perfect Lisp reader, let’s think about how we
    could improve the `eval` command. The main problem with using `eval` in a game
    is it allows you to call any Lisp command, even if that command has nothing to
    do with playing the game. To help protect our program from hackers, we’ll create
    a `game-eval` function that allows only certain commands to be called, as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个几乎完美的Lisp读取器，让我们思考一下我们如何可以改进`eval`命令。在游戏中使用`eval`的主要问题在于它允许你调用任何Lisp命令，即使这个命令与玩游戏无关。为了帮助保护我们的程序免受黑客攻击，我们将创建一个`game-eval`函数，它只允许调用某些命令，如下所示：
- en: '[PRE80]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `game-eval` function checks if the first word in the entered command is
    in the list of allowed commands, using the `member` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    If it is, we then use the standard `eval` to execute the player’s command ![](httpatomoreillycomsourcenostarchimages783562.png).
    By checking that the command called by the player is in the official list, we
    protect ourselves against any attempts to call malicious commands.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-eval`函数使用`member`函数检查输入命令中的第一个单词是否在允许的命令列表中 ![member函数](httpatomoreillycomsourcenostarchimages783564.png)。如果是，我们就使用标准的`eval`来执行玩家的命令
    ![eval函数](httpatomoreillycomsourcenostarchimages783562.png)。通过检查玩家调用的命令是否在官方列表中，我们保护自己免受调用恶意命令的任何尝试。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780092.png.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780092.png.jpg)'
- en: Warning
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Our `game-eval` function does not offer 100 percent protection against hacking.
    See [The Dangers of read and eval](ch06s05.html "The Dangers of read and eval")
    in [The Dangers of read and eval](ch06s05.html "The Dangers of read and eval")
    for details.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`game-eval`函数并不能提供100%的防黑客保护。有关详细信息，请参阅[《read和eval的危险》](ch06s05.html "《read和eval的危险》")中的[《read和eval的危险》](ch06s05.html
    "《read和eval的危险》")。
- en: Writing a game-print Function
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`game-print`函数
- en: 'The final missing piece in our `game-repl` system is the `game-print` function.
    Of all the limitations in the Lisp REPL version of our game, one was the most
    obvious: All the text descriptions printed in the game were in uppercase.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`game-repl`系统中的最后一块缺失的拼图是`game-print`函数。在我们游戏的Lisp REPL版本的所有限制中，有一个是最明显的：游戏中打印的所有文本描述都是大写的。
- en: Last I checked, throughout the current millennium, computers have been able
    to display both uppercase *and* lowercase characters. By writing our own `game-print`
    function, we can solve this problem.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我检查的时候，在整个当前千年里，计算机已经能够显示大写和**小写**字符。通过编写我们自己的`game-print`函数，我们可以解决这个问题。
- en: 'Before we step through the `game-print` function’s code, let’s look at an example
    of its output:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐步分析`game-print`函数的代码之前，让我们看看它的输出示例：
- en: '[PRE81]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As you can see, the `game-print` function converts our symbol-based writing
    into properly capitalized text. By having this function available, we can store
    the text in our game engine in the most comfortable format possible: lists of
    symbols. This format makes it easier to manipulate the text. Then, at the point
    of presentation, we can decorate these symbol lists with presentation details.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`game-print`函数将我们的基于符号的写作转换为正确的大写文本。通过拥有这个函数，我们可以在最舒适的格式下将文本存储在我们的游戏引擎中：符号列表。这种格式使得操作文本更加容易。然后，在展示点，我们可以用展示细节装饰这些符号列表。
- en: Of course, in this example, the decorations are very simple. All we do is adjust
    the case. But you can already see some small benefits of separating the presentation
    details from the data model. For instance, suppose we changed the `describe-path`
    function to write sentences like “Left of here lies a door.” No further changes
    would be needed; the program would automatically know to capitalize the *Left*
    at the beginning of the sentence.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个例子中，装饰非常简单。我们只是调整了大小写。但您已经可以看到将展示细节与数据模型分离的一些小好处。例如，如果我们把`describe-path`函数改为写出像“这里左边有一扇门。”这样的句子，就不需要做任何进一步的更改；程序会自动知道在句首大写*Left*。
- en: However, the real benefits come into play when you want to use more sophisticated
    methods of presentation, such as generating HTML code. You might want to incorporate
    custom semantics for your text game to enhance the appearance of the text, such
    as changing colors, fonts, and so on. For instance, you could allow your game
    descriptions to contain phrases such as “You are being attacked by a (red evil
    demon).” Then you could just catch the keyword `red` in the `game-print` function
    to write the enclosed text in red. We will be creating an HTML presentation system
    similar to this in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages").
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，真正的益处在于当你想要使用更复杂的演示方法时，例如生成HTML代码。你可能想要为你的文本游戏添加自定义语义，以增强文本的外观，例如改变颜色、字体等。例如，你可以允许你的游戏描述包含诸如“你正被一个（红色邪恶恶魔）攻击”之类的短语。然后你只需在`game-print`函数中捕捉到关键词`red`，就可以将包含的文本以红色显示。我们将在[第17章](ch19.html
    "第17章。领域特定语言")中创建一个类似的HTML演示系统。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783352.png.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783352.png.jpg)'
- en: 'Now we’re ready to look at the `game-print` function’s code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备查看`game-print`函数的代码：
- en: '[PRE82]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `game-print` function and its helper function are a bit more complicated
    than the other functions we’ve looked at so far. The first important part of the
    code that is executed is in `game-print`, where it converts the symbol list (containing
    the text whose layout we want to fix) into a string with `prin1-to-string` ![](httpatomoreillycomsourcenostarchimages783566.png),
    one of Lisp’s many `print` variants. The `to-string` part means this function
    doesn’t dump the result to the screen, but just returns it as a string. The `1`
    means it will stay on a single line. The standard `print` command precedes its
    output with a newline character and also follows it with a space. The functions
    `prin1` and `prin1-to-string` variants don’t add these extra characters.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-print`函数及其辅助函数比我们之前看到的函数要复杂一些。代码执行的第一部分是在`game-print`中，它将包含我们想要调整布局的文本的符号列表转换为字符串，使用的是Lisp的许多`print`变体之一的`prin1-to-string`
    ![图片](httpatomoreillycomsourcenostarchimages783566.png)。`to-string`部分意味着这个函数不会将结果输出到屏幕上，而是仅将其作为字符串返回。`1`表示它将保持在单行上。标准的`print`命令在其输出前添加换行符，并在其后添加空格。`prin1`和`prin1-to-string`变体不会添加这些额外的字符。'
- en: Next, `game-print` converts the string to a list of characters with the `coerce`
    function ![](httpatomoreillycomsourcenostarchimages783556.png). By coercing our
    string into a list, we can reduce the bigger goal of the function into a list-processing
    problem. This is smack-dab in the Lisp comfort zone. In this case, we’re creating
    a list of the characters making up the text we want to fix.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`game-print`使用`coerce`函数将字符串转换为字符列表 ![图片](httpatomoreillycomsourcenostarchimages783556.png)。通过将我们的字符串强制转换为列表，我们可以将函数的更大目标简化为列表处理问题。这正是Lisp的舒适区。在这种情况下，我们正在创建一个由我们想要修复的文本组成的字符列表。
- en: We can now send the data to the list-eater function `tweak-text` ![](httpatomoreillycomsourcenostarchimages783556.png).
    Notice that some of the arguments used in the code of the `game-print` function
    are printed on their own line for clarity. You can easily see which arguments
    are meant for which commands by looking at the indentation. For instance, the
    `t` and `nil` arguments ![](httpatomoreillycomsourcenostarchimages783498.png)
    belong to `tweak-text`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将数据发送到`list-eater`函数`tweak-text` ![图片](httpatomoreillycomsourcenostarchimages783556.png)。注意，在`game-print`函数的代码中使用的某些参数单独打印在一行上，以便于清晰。你可以通过查看缩进来轻松地看到哪些参数对应于哪个命令。例如，`t`和`nil`参数
    ![图片](httpatomoreillycomsourcenostarchimages783498.png) 属于`tweak-text`。
- en: The `tweak-text` function looks at each character in the list and modifies it
    as needed. At the top of this function, we define two local variables, `item`
    and `rest`, which we get by chewing off an item from the front of the sentence
    we’re tweaking ![](httpatomoreillycomsourcenostarchimages783564.png). Then, the
    `tweak-text` function uses a `cond` to check the character at the top of the list
    for different conditions ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`tweak-text`函数会检查列表中的每个字符并根据需要修改它。在这个函数的顶部，我们定义了两个局部变量`item`和`rest`，我们通过从我们要调整的句子前端咬掉一个项目来获取它们
    ![图片](httpatomoreillycomsourcenostarchimages783564.png)。然后，`tweak-text`函数使用`cond`来检查列表顶部的字符以不同的条件
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)。'
- en: The first condition it checks for is whether the character is a space character
    ![](httpatomoreillycomsourcenostarchimages783562.png). If so, it just leaves the
    space unchanged and processes the next character in the list. If the character
    is a period, question mark, or exclamation point ![](httpatomoreillycomsourcenostarchimages783560.png),
    we turn on the `cap` parameter for the rest of the string (by using the value
    `t` as an argument in the recursive call) to indicate that the next symbol is
    at the beginning of a sentence and needs a capital letter.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查的条件是字符是否为空格字符![http://atomoreilly.com/source/no_starch_images/783562.png](http://atomoreilly.com/source/no_starch_images/783562.png)。如果是，它就保持空格不变并处理列表中的下一个字符。如果字符是句号、问号或感叹号![http://atomoreilly.com/source/no_starch_images/783560.png](http://atomoreilly.com/source/no_starch_images/783560.png)，我们就为字符串的其余部分开启`cap`参数（通过在递归调用中使用值`t`作为参数），以指示下一个符号是句子的开头，需要大写字母。
- en: 'We also track whether we’ve encountered a quotation mark ![](httpatomoreillycomsourcenostarchimages783554.png).
    We do this because, infrequently, a symbol list is not adequate for encoding English
    text. Examples include having a comma (commas are not allowed in standard Common
    Lisp symbols) or product names with nonstandard capitalization. In these cases,
    we can just fall back on using text strings. Here’s an example:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还跟踪是否遇到了引号![http://atomoreilly.com/source/no_starch_images/783554.png](http://atomoreilly.com/source/no_starch_images/783554.png)。我们这样做是因为，不经常，符号列表不足以编码英文文本。例如，有一个逗号（逗号不允许在标准的Common
    Lisp符号中）或具有非标准大写的产品名称。在这些情况下，我们只需回退到使用文本字符串。以下是一个例子：
- en: '[PRE83]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Our sample game doesn’t actually need the fallback facility. Nonetheless, this
    feature allows the `game-print` function to handle many basic exceptional text
    situations that you may encounter if you try to expand the game on your own. We
    tell the function to treat the capitalization as shown literally by turning on
    the `lit` variable in the recursive call. As long as this value is set, the `tweak-text`
    function prevents the capitalization rules (which start at ![](httpatomoreillycomsourcenostarchimages783510.png))
    from being reached.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例游戏实际上不需要回退功能。尽管如此，这个特性允许`game-print`函数处理许多基本的异常文本情况，这些情况可能在你尝试自己扩展游戏时遇到。我们告诉函数通过在递归调用中开启`lit`变量来将大写字母按字面意思处理。只要这个值被设置，`tweak-text`函数就会阻止大写字母规则（从![http://atomoreilly.com/source/no_starch_images/783510.png](http://atomoreilly.com/source/no_starch_images/783510.png)开始）被触发。
- en: The next thing the `tweak-text` function checks is whether the next character
    is supposed to be capitalized. If it is, we use the `char-upcase` function to
    change the current character to uppercase (if it isn’t already) before processing
    the next item in the list ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`tweak-text`函数接下来检查下一个字符是否应该大写。如果是，我们在处理列表中的下一个项目之前，使用`char-upcase`函数将当前字符转换为大写（如果它还不是的话）![http://atomoreilly.com/source/no_starch_images/783510.png](http://atomoreilly.com/source/no_starch_images/783510.png)。'
- en: If none of the other conditions were met, we know that the current character
    should be lowercase ![](httpatomoreillycomsourcenostarchimages783544.png), and
    we can convert it using the `char-downcase` function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有满足其他条件，我们知道当前字符应该是小写的![http://atomoreilly.com/source/no_starch_images/783544.png](http://atomoreilly.com/source/no_starch_images/783544.png)，我们可以使用`char-downcase`函数将其转换。
- en: After `tweak-text` is finished correcting the text in the character list, the
    `game-print` function coerces it back into a proper string and `princ`s it ![](httpatomoreillycomsourcenostarchimages783556.png).
    The `fresh-line` function at the end of `game-print` makes sure that the next
    item appearing on the screen will start on a fresh line.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tweak-text`完成对字符列表中的文本进行纠正后，`game-print`函数将其强制转换成一个合适的字符串并`princ`它![http://atomoreilly.com/source/no_starch_images/783556.png](http://atomoreilly.com/source/no_starch_images/783556.png)。`game-print`末尾的`fresh-line`函数确保屏幕上出现的下一个项目将从新的一行开始。
- en: We have now completed the task of printing the original list of symbols to the
    screen, using a set of decorations appropriate for the needs of an adventure game
    engine.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了将原始符号列表打印到屏幕上的任务，使用了一套适合冒险游戏引擎需求的装饰。
- en: Trying Out Our Fancy New Game Interface
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试我们的新游戏界面
- en: We have now completed all the pieces needed for a custom REPL for our game engine.
    Simply call the `game-repl` function and explore our new game world. Remember
    that we will be expanding this engine into a full game, with additional commands,
    in [Chapter 17](ch19.html "Chapter 17. Domain-Specific Languages").
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了为我们的游戏引擎定制REPL所需的所有组件。只需调用`game-repl`函数，就可以探索我们的新游戏世界。记住，我们将在第17章[Chapter
    17](ch19.html "Chapter 17. Domain-Specific Languages")中扩展这个引擎，使其成为一个完整的游戏，并添加额外的命令。
- en: '[PRE84]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Success! We now have an extremely flexible text game engine. It can be expanded
    and debugged within the Lisp REPL. It also has a fully customizable interface
    to offer the player a seamless text adventure experience. As we put it together,
    you saw some mind-bending Lisp techniques that let us construct this engine with
    a minimum of filler code or other overhead.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们现在拥有了一个极其灵活的文本游戏引擎。它可以在 Lisp REPL 中进行扩展和调试。它还提供了一个完全可定制的界面，为玩家提供无缝的文字冒险体验。在我们将其组装起来的过程中，你看到了一些令人费解的
    Lisp 技术，这些技术使我们能够用最少的填充代码或其他开销构建这个引擎。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779944.png.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779944.png.jpg)'
- en: The Dangers of read and eval
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`read` 和 `eval` 的危险'
- en: We’ve used both the `eval` and the `read` commands in creating a custom Lisp
    REPL. These commands are very powerful, but also very dangerous. Using them without
    taking the proper precautions might allow a hacker to attack your software by
    running malicious commands.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建定制的 Lisp REPL 时使用了 `eval` 和 `read` 命令。这些命令非常强大，但也非常危险。在不采取适当预防措施的情况下使用它们可能会允许黑客通过运行恶意命令来攻击你的软件。
- en: For example, suppose our program needed a function called `format-harddrive`.
    This is *not* a function we would want just any person to have access to, and
    it could be very dangerous if a hacker somehow tricked our game REPL into calling
    it.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的程序需要一个名为 `format-harddrive` 的函数。这不是我们希望任何人都能够访问的函数，如果黑客设法诱骗我们的游戏 REPL
    调用它，可能会非常危险。
- en: 'The `game-eval` function we created earlier in this chapter has some crude
    safeguards to prevent a player from entering `format-harddrive` as a game command.
    Here’s what happens if we try to run this command in our new game REPL:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们创建的 `game-eval` 函数有一些粗略的安全措施，以防止玩家将 `format-harddrive` 作为游戏命令输入。如果我们尝试在我们的新游戏
    REPL 中运行此命令，会发生以下情况：
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Our `game-eval` function will run only commands that are in an approved list.
    This gives our game a sort of firewall, which lets us access the powers of Lisp
    to evaluate commands while still preventing the player from hacking the game.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `game-eval` 函数只会运行批准列表中的命令。这为我们游戏提供了一种防火墙，使我们能够利用 Lisp 的功能来评估命令，同时防止玩家破解游戏。
- en: However, there are also more sophisticated exploits players could try. For instance,
    they could enter `walk (format-harddrive)`. Fortunately, our `game-read` function
    forces all function parameters into data mode by using `quote-it`. By using `quote-it`
    in `game-read`, the actual code that is executed is `(walk '(format-`harddrive)).
    The quote in front of (`format-hardrive`) puts the malicious command into data
    mode, so nothing bad can happen.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，玩家还可以尝试更复杂的攻击手段。例如，他们可以输入 `walk (format-harddrive)`。幸运的是，我们的 `game-read`
    函数通过使用 `quote-it` 将所有函数参数强制转换为数据模式。在 `game-read` 中使用 `quote-it`，实际执行的代码是 `(walk
    '(format-`harddrive))`。在 (`format-hardrive`) 前面的引号将恶意命令转换为数据模式，因此不会发生任何坏事。
- en: 'One attack method that *will* break our program is to use *reader macros*.
    These are an advanced set of features, built into the Common Lisp `read` command,
    that open another avenue for executing malicious computer code. (Remember that
    before we use `eval` on game commands, they first pass through `read`.) An example
    of a game command that will successfully execute evil code is `walk #.{format-harddrive}`.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '一种会破坏我们程序的方法是使用 *reader macros*。这是一组高级功能，内置在 Common Lisp 的 `read` 命令中，为执行恶意计算机代码开辟了另一条途径。（记住在我们对游戏命令使用
    `eval` 之前，它们首先会通过 `read`。）一个能够成功执行恶意代码的游戏命令示例是 `walk #.{format-harddrive}`。'
- en: The bottom line is that you can never be sure that a Lisp program using `eval`
    or `read` is completely safe from a hacker. When writing production Lisp code,
    you should try to avoid these two commands when possible.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，你永远不能确定使用 `eval` 或 `read` 的 Lisp 程序完全安全，免受黑客攻击。在编写生产级 Lisp 代码时，你应该尽可能避免使用这两个命令。
- en: What You've Learned
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we created a custom REPL to supercharge our text adventure
    game. Along the way, you learned the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个定制的 REPL 来增强我们的文本冒险游戏。在这个过程中，你学习了以下内容：
- en: The `print` and `read` functions let you directly communicate with the user
    through the console. These two functions work in a computer-friendly way.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print` 和 `read` 函数允许你通过控制台直接与用户进行通信。这两个函数以计算机友好的方式工作。'
- en: Other input/output functions are not as elegant as `read` and `print`, but are
    friendlier for interacting with humans. Examples include `princ` and `read-line`.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他输入/输出函数不如 `read` 和 `print` 那么优雅，但更适合与人类交互。例如包括 `princ` 和 `read-line`。
- en: A *homoiconic* programming language stores its program code and program data
    in a similar format. Lisp’s quoting, quasiquoting, `eval`, and macro features
    make it extremely homoiconic.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种*同构*编程语言以类似格式存储其程序代码和程序数据。Lisp 的引用、准引用、`eval` 和宏功能使其非常同构。
- en: It’s easy to write your own custom REPL.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的自定义 REPL 很简单。
- en: It’s simple to transform your internal Lisp data into the format most suitable
    for your program’s interface. This makes it easy to separate presentation details
    from your program’s internal data structures.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的内部 Lisp 数据转换为最适合你程序接口的格式很简单。这使得将表示细节与程序内部数据结构分开变得容易。
- en: 'Chapter 6.5. lambda: A Function So Important It Deserves Its Own Chapter'
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6.5 章。lambda：一个值得拥有自己章节的重要函数
- en: It’s impossible to overstate the importance of the `lambda` command in Lisp.
    In fact, this command is pretty much the entire reason that Lisp exists in the
    first place.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lisp 中，`lambda` 命令的重要性怎么强调都不过分。事实上，这个命令几乎就是 Lisp 存在的全部原因。
- en: What lambda Does
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lambda 的作用
- en: 'In short, `lambda` lets you create a function without giving it a name. For
    example, let’s say we create a `half` function that takes a number and divides
    it in half. Until now, we’ve written such a function this way:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`lambda` 允许你创建一个没有命名的函数。例如，假设我们创建一个 `half` 函数，它接受一个数字并将其减半。到目前为止，我们是这样编写这样的函数的：
- en: '[PRE86]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781778.png.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781778.png.jpg)'
- en: 'It turns out that, in Lisp, functions are actually values that we can view
    and pass around just as if they were numbers or lists. An experienced Lisp programmer
    would say that functions are *first-class values* in Lisp. As you saw in [Chapter 5](ch05.html
    "Chapter 5. Building a Text Game Engine"), you can actually get at the function
    represented by the word `half` by using the function operator:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，在 Lisp 中，函数实际上是我们可以查看和传递的值，就像它们是数字或列表一样。有经验的 Lisp 程序员会说，在 Lisp 中函数是*一等值*。正如你在[第
    5 章](ch05.html "第 5 章。构建文本游戏引擎")中看到的，你可以通过使用函数操作符来获取由单词 `half` 表示的函数：
- en: '[PRE87]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `lambda` command just lets you do these same two things in a single step.
    You can define a function and then get it, without giving your function a name:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 命令只是让你在一步中完成这两件事。你可以定义一个函数然后获取它，而不必给你的函数命名：'
- en: '[PRE88]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The first parameter to the `lambda` command is a parameter list, no different
    from the parameter list used in `defun`. The rest of the parameters are just the
    commands for the body of the unnamed function.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 命令的第一个参数是一个参数列表，这与 `defun` 中使用的参数列表没有区别。其余的参数只是未命名函数体中的命令。'
- en: 'Once you have a value representing your unnamed halving function, you can pass
    it directly to other Common Lisp commands, such as the `mapcar` or `apply` commands.
    For instance, we could do the following to elegantly halve all the values in a
    list:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个代表你的未命名除半函数的值，你可以直接将其传递给其他 Common Lisp 命令，例如 `mapcar` 或 `apply` 命令。例如，我们可以这样做，优雅地将列表中的所有值除以二：
- en: '[PRE89]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Because not all parameters of the `lambda` command are evaluated, `lambda` itself
    is not actually a true function. It is something called a *macro*. Remember from
    [Chapter 2](ch02.html "Chapter 2. Creating Your First Lisp Program") that all
    parameters to a Lisp function are evaluated before the function itself is evaluated.
    Macros, on the other hand, have special powers and are allowed to break those
    rules. You’ll learn more about macros in [Chapter 16](ch18.html "Chapter 16. The
    Magic of Lisp Macros").
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `lambda` 命令的并非所有参数都会被评估，因此 `lambda` 本身实际上不是一个真正的函数。它是一种称为*宏*的东西。记得从[第 2 章](ch02.html
    "第 2 章。创建你的第一个 Lisp 程序")中提到的，在 Lisp 函数本身被评估之前，所有传递给 Lisp 函数的参数都会被评估。另一方面，宏具有特殊的功能，并允许打破这些规则。你将在[第
    16 章](ch18.html "第 16 章。Lisp 宏的魔力")中了解更多关于宏的内容。
- en: Also, to confuse matters a bit, the actual value that `lambda` returns is a
    regular Lisp function—in this case, a function that cuts a number in half. When
    Lispers talk about lambda functions—which they pretty much do for breakfast, lunch,
    and dinner—they’re talking about functions created using `lambda`. They’re not
    talking about the `lambda` macro itself, which is not a function. Got that?
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使事情更加复杂，`lambda` 实际返回的值是一个普通的 Lisp 函数——在这种情况下，是一个将数字减半的函数。当 Lisp 程序员谈论
    lambda 函数——他们几乎从早餐、午餐和晚餐都在谈论——他们谈论的是使用 `lambda` 创建的函数。他们不是在谈论 `lambda` 宏本身，它不是一个函数。明白了吗？
- en: '`lambda` lets your programs do very complicated things.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 让你的程序能够做非常复杂的事情。'
- en: The `lambda` form allows your programming code to take a conceptual leap.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 形式允许你的编程代码实现概念上的飞跃。'
- en: While most programming languages try to keep the worlds of functions and values
    separate, Lisp lets you bridge these worlds as desired. For instance, if you want
    to package up a little ad hoc function and pass it off to another part of your
    program, `lambda` does exactly what you need.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数编程语言试图保持函数和值的世界分开，但 Lisp 允许你根据需要连接这两个世界。例如，如果你想打包一个小型的临时函数并将其传递给程序的另一部分，`lambda`
    就能完全满足你的需求。
- en: You will see that most Lisp programs use this command very heavily. The same
    holds true for the remaining examples in this book.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现大多数 Lisp 程序都非常重视这个命令。这本书中的剩余示例也是如此。
- en: Why lambda Is So Important
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 `lambda` 如此重要
- en: The ability to pass around functions as if they were just plain old pieces of
    data is incredibly valuable. Once you get used to doing this, you open up all
    kinds of conceptual possibilities in the design of your programs. Eventually,
    your programs will start looking very different from programs in more (dare I
    say) pedestrian languages, such as Java or C. The name for the style of programming
    that relies heavily on passing functions as values is called higher-order *functional
    programming*. We will look at this style in more detail in [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming").
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 能够像传递普通数据一样传递函数的能力非常宝贵。一旦你习惯了这样做，你就可以在程序设计中打开各种概念上的可能性。最终，你的程序将开始看起来与更多（我敢说）更平凡的编程语言（如
    Java 或 C）的程序大不相同。这种依赖于传递函数作为值的编程风格被称为高阶 *函数式编程*。我们将在第 14 章（[Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming")）中更详细地探讨这种风格。
- en: An even more important reason why Lispers go gaga over `lambda` is that, as
    it turns out, in a purely mathematical sense, `lambda` is actually the only Lisp
    command there is!
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 程序员对 `lambda` 如此着迷的另一个更重要的原因是，实际上，在纯粹数学的意义上，`lambda` 实际上是唯一的 Lisp 命令！
- en: 'Recall that Lisp is unusual among programming languages in that it was derived
    directly from a mathematical concept called the *lambda calculus*. In short, the
    lambda calculus is a theoretical programming language that contains only one command:
    the `lambda` command. By having only this single command and using special code
    transformations, it’s possible to create a fully functioning (though perhaps not
    practical) programming language.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Lisp 在编程语言中很独特，因为它直接源于一个称为 *lambda 演算* 的数学概念。简而言之，lambda 演算是一种仅包含一个命令的理论编程语言：`lambda`
    命令。通过只有一个这样的命令并使用特殊的代码转换，可以创建一个完全功能（尽管可能不实用）的编程语言。
- en: The take-home point is that the `lambda` special form is the most fundamental
    command in a Lisp system, and the central concept from which other functions in
    Lisp derive. In fact, it is the central concept from which the very idea of Lisp
    itself originated.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，`lambda` 特殊形式是 Lisp 系统中最基本的命令，也是 Lisp 中其他函数的核心概念。事实上，它甚至是从 Lisp 本身的概念中起源的核心概念。
- en: Now that you have a basic understanding of `lambda`, you’re ready to tackle
    some more complicated programming examples that would be hard to write without
    the anonymous functions this command permits.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 `lambda` 有了一个基本的理解，你就可以处理一些更复杂的编程示例了，没有这个命令允许的匿名函数，这些示例将很难编写。
- en: What You've Learned
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你所学到的东西
- en: 'This short chapter discussed how to create anonymous functions. Here are the
    main points:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这本简短章节讨论了如何创建匿名函数。以下是主要要点：
- en: By using `lambda`, you can create a function without needing to give it a name.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `lambda`，你可以创建一个不需要命名的函数。
- en: Many functions in Lisp accept functions as parameters. If you use these functions,
    you are using a technique called *higher-order functional programming*.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多 Lisp 函数接受函数作为参数。如果你使用这些函数，你就是在使用一种称为 *高阶函数式编程* 的技术。
- en: Chapter 7. Going Beyond Basic Lists
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。超越基本列表
- en: In this chapter, we’ll go beyond basic list concepts. We’ll talk about special
    kinds of lists, and we’ll write a game that will take list manipulation to a new
    level.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将超越基本列表概念。我们将讨论特殊类型的列表，并编写一个将列表操作提升到新水平的游戏。
- en: Exotic Lists
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常列表
- en: As you learned in [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of
    Lisp Code"), lists in Lisp are built out of cons cells—small data structures that
    allow you to link together two pieces of data. The right slot in the last cons
    cell in a list should contain a `nil`.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[第 3 章](ch03.html "第 3 章。探索 Lisp 代码的语法")中学习的那样，Lisp 中的列表是由 cons 单元构成的——这些小的数据结构允许您将两块数据链接在一起。列表中最后一个
    cons 单元的右槽应该包含一个 `nil`。
- en: 'By stringing together several cons cells, you can create a list of any length.
    For instance, this is how we would use cons cells to create a list of the numbers
    1, 2, and 3:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接几个 cons 单元，您可以创建任何长度的列表。例如，这就是我们如何使用 cons 单元创建包含数字 1、2 和 3 的列表：
- en: '[PRE90]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782574.png.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782574.png.jpg)'
- en: 'Since it’s so cumbersome for humans to think of a chain of cons cells as a
    list, Lisp has a special, simplified syntax for printing out such lists. You can
    see this for yourself by evaluating a chain of cons cells in the REPL:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 由于人类将一系列 cons 单元视为列表非常繁琐，Lisp 为打印此类列表提供了一种特殊、简化的语法。您可以通过在 REPL 中评估一系列 cons 单元来亲自查看这一点：
- en: '[PRE91]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Lisp uses the simpler list syntax when it parrots our chain back to us in the
    REPL. It shows our string of cons cells as a list of three items. The important
    point to remember is that *this difference in appearance is entirely superficial*.
    No matter how a Lisp list is displayed, fundamentally, it always remains a chain
    of cons cells.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Lisp 在 REPL 中将我们的链式 cons 单元回显给我们时，它使用更简单的列表语法。重要的是要记住，*这种外观上的差异完全是表面的*。无论
    Lisp 列表如何显示，本质上，它始终是一个 cons 单元的链。
- en: Dotted Lists
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点划线列表
- en: So, what happens if we deviate from the classic “string of conses” formula?
    How will a Lisp environment deal with this when printing lists?
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们偏离经典的“cons 链”公式会发生什么？当打印列表时，Lisp 环境将如何处理这种情况？
- en: 'Suppose we try to create a list of the numbers 1, 2, and 3, like this:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试创建一个包含数字 1、2 和 3 的列表，如下所示：
- en: '[PRE92]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, instead of creating a third cons cell for the third number of our list,
    we stuff it into the right slot of the previous cell. What would the printed response
    look like if we were to enter this structure into a Lisp REPL? Let’s try it out:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是为列表中的第三个数字创建第三个 cons 单元，而是将其塞入前一个单元的右槽。如果我们将这个结构输入到 Lisp REPL 中，打印出来的响应会是什么样子呢？让我们试试：
- en: '[PRE93]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: To indicate that the final item in the list wasn’t found in the proper location
    for a `nil`-terminated list, Lisp places a dot in front of this final item. This
    dot is basically Lisp’s way of saying, “I tried to print this structure you entered
    using list notation, but the last item in the list didn’t contain the usual `nil`
    I expected; instead, it contained `3`.”
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示列表中的最后一个项目没有在 `nil` 结尾的列表的正确位置找到，Lisp 在这个最后一个项目前放置一个点。这个点基本上是 Lisp 的说法：“我尝试使用列表符号打印你输入的这个结构，但列表中的最后一个项目没有包含我预期的通常的
    `nil`；相反，它包含了 `3`。”
- en: A list in Lisp that ends in something other than a `nil` is referred to as a
    *dotted list*. Dotted lists are kind of an oddity in the Land of Lisp. In and
    of themselves, they are not that useful a tool for Lisp programming. It would
    be quite unusual for a Lisp programmer to store data in dotted lists as a regular
    practice. However, given the pervasiveness of cons cells in Lisp, you will frequently
    encounter a non-`nil` value at the end of a chain of cons cells. That’s why you
    should become familiar with dotted lists, even if you may never use them directly.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 以非 `nil` 结尾的 Lisp 列表被称为*点划线列表*。在 Lisp 的领域中，点划线列表有点奇怪。就其本身而言，它们并不是 Lisp 编程中非常有用的工具。Lisp
    程序员将数据存储在点划线列表中作为常规做法是非常不寻常的。然而，鉴于 cons 单元在 Lisp 中的普遍性，您将经常在一系列 cons 单元的末尾遇到非
    `nil` 值。这就是为什么您应该熟悉点划线列表，即使您可能永远不会直接使用它们。
- en: 'Another way of thinking about this dot notation is to consider it as simply
    an alternate syntax for the `cons` command, used in data mode. In fact, if we
    wanted to make life hard for ourselves, we could even create regular, proper lists
    using the dot notation, like this:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考这种点符号的方法是将其视为 `cons` 命令的替代语法，用于数据模式。实际上，如果我们想让自己生活得更艰难，我们甚至可以使用点符号创建常规的、正确的列表，如下所示：
- en: '[PRE94]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Using this line of thinking, the dot appears in a dotted list simply because
    Lisp is forced to show the final cons cell in order to maintain the consistency
    of its list-printing mechanism.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种思维方式，点出现在点划线列表中，仅仅是因为 Lisp 被迫显示最终的 cons 单元，以保持其列表打印机制的连贯性。
- en: Pairs
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对
- en: 'One common and practical use for dotted lists in Lisp programs is to elegantly
    represent pairs. For instance, suppose we wanted to represent a pair of the numbers
    2 and 3\. One way to do this would be to cons together these two numbers:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lisp 程序中，点划线列表的一个常见且实用的用途是优雅地表示对。例如，假设我们想要表示数字 2 和 3 的对。一种方法是将这两个数字连接起来：
- en: '[PRE95]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Essentially, all we’re doing here is creating a dotted list of length two. As
    expected, Lisp uses dot notation to display this pair.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们在这里所做的只是创建一个长度为二的点划线列表。正如预期的那样，Lisp 使用点符号来显示这个对。
- en: Creating pairs in this manner in Lisp is very convenient and efficient. It’s
    convenient because we can extract members from the pair using the standard `car`
    and `cdr` commands. It’s relatively efficient because the Lisp environment needs
    to allocate only a single cons cell to connect the two items.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式在 Lisp 中创建对非常方便且高效。它方便，因为我们可以使用标准的 `car` 和 `cdr` 命令从对中提取成员。它相对高效，因为 Lisp
    环境只需要分配一个 cons 单元来连接两个项目。
- en: These types of pairs are commonly used in Lisp programs. For instance, you could
    use them to store the x- and y-coordinates of a point or a key/value pair in a
    complex data structure. You will see this latter use for pairs when we discuss
    association lists.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的对在 Lisp 程序中常用。例如，你可以使用它们来存储点或复杂数据结构中的键/值对。当我们讨论关联列表时，你将看到对的后一种用途。
- en: Circular Lists
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环列表
- en: 'Here is the picture we used in [Chapter 3](ch03.html "Chapter 3. Exploring
    the Syntax of Lisp Code") to illustrate the cons cells that make up the list `''(1
    2 3)`:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们用于[第 3 章](ch03.html "第 3 章。探索 Lisp 代码的语法")中说明构成列表 `'(1 2 3)` 的 cons 单元的图片：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782916.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782916.png)'
- en: 'Now suppose that we created a weird mutant of this list. Let’s have the `cdr`
    of the third cons cell point back to the first cons cell, rather than to `nil`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们创建了这个列表的一个奇怪变异体。让我们让第三个 cons 单元的 `cdr` 指向第一个 cons 单元，而不是 `nil`：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781690.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781690.png)'
- en: Every cons cell in a list theoretically exists as a separate object in memory.
    Since the `car` and `cdr` slots in a cell can point to any other object in memory,
    a cons cell can point to an upstream cons cell of a list. We call this a *circular
    list*.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个 cons 单元在理论上都存在于内存中的独立对象。由于单元格中的 `car` 和 `cdr` 插槽可以指向内存中的任何其他对象，因此 cons
    单元可以指向列表的上游 cons 单元。我们称这种列表为 *循环列表*。
- en: 'But before you experiment with circular lists in any Common Lisp environment,
    you should run this command:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 但在你尝试在任何 Common Lisp 环境中实验循环列表之前，你应该运行此命令：
- en: '[PRE96]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Setting `*print-circle*` to true warns Lisp that you plan on playing shenanigans
    with self-referential data structures, and that it needs to be extra careful when
    printing on the screen any of the monstrosities you may create. If you were to
    print a circular list without this variable set, there’s no telling what would
    happen, but whatever the outcome, it wouldn’t be pretty (unless you find some
    beauty in stack overflows and infinite loop printing).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `*print-circle*` 设置为 true 警告 Lisp，你计划在自引用数据结构上玩一些小把戏，并且它在打印屏幕上创建的任何怪物时需要格外小心。如果你不设置这个变量就打印循环列表，你无法预测会发生什么，但无论结果如何，都不会很美观（除非你在堆栈溢出和无限循环打印中找到了某种美）。
- en: When you have `*print-circle*` set to true, Common Lisp will use more complex
    printing routines for printing data structures. These routines (which are disabled
    by default to improve performance) will check to see if you’ve run into a previously
    seen cons cell, so that printing doesn’t end up putting you into an infinite loop.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `*print-circle*` 设置为 true 时，Common Lisp 将使用更复杂的打印例程来打印数据结构。这些例程（默认情况下被禁用以提高性能）将检查你是否遇到了之前见过的
    cons 单元，这样打印就不会导致无限循环。
- en: 'So how would you go about creating a circular list? The most straightforward
    way is to use the `setf` command to put extra stuff in the first parameter, like
    so:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你将如何创建一个循环列表？最直接的方法是使用 `setf` 命令在第一个参数中放入额外的内容，如下所示：
- en: '[PRE97]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this example, we’ve created an infinite list of `'(1 2 3 1 2 3 1 2 3 ...)`
    by replacing the `nil` at the end of a simple list with a reference to the list
    itself.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过将简单列表末尾的 `nil` 替换为对列表本身的引用，创建了一个无限列表 `'(1 2 3 1 2 3 1 2 3 ...)`。
- en: The ability to place complex expressions in the first parameter of a `setf`
    command, as in this example, is very cool, and we’ll explore it in greater detail
    in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic Programming").
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setf`命令的第一个参数中放置复杂表达式的能力，如本例所示，非常酷，我们将在第9章[“第9章. 高级数据类型和泛型编程”](ch10.html "第9章.
    高级数据类型和泛型编程")中更详细地探讨它。
- en: Note
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CLISP (and other Common Lisps) can deal with the printing of circular lists
    very sensibly. Somehow, it must address the fact that one part of the list refers
    to another part. As you can see, it uses an esoteric, but quite clever, notation
    to link the self-referential parts of the expression. However, I’m sure you can
    also appreciate that, as the complexity of any self-referential data increases,
    the printed results offered by a Lisp printer for this type of data can become
    hard for a programmer to grok.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: CLISP（以及其他通用Lisp）可以非常合理地处理循环列表的打印。某种方式，它必须解决列表的一部分引用另一部分的事实。正如你所见，它使用一种晦涩但相当巧妙的记法来链接表达式的自引用部分。然而，我相信你也能欣赏到，随着任何自引用数据的复杂性增加，Lisp打印机为这类数据提供的打印结果可能对程序员来说难以理解。
- en: Association Lists
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联列表
- en: One particularly useful data structure that can be created out of cons cells
    is an *association list*, or *alist* for short. An alist consists of key/value
    pairs stored in a list.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从cons单元创建的一个特别有用的数据结构是关联列表，或简称为*alist*。alist由存储在列表中的键/值对组成。
- en: 'By convention, if a key appears multiple times in the list, it is assumed that
    the first appearance of the key contains the desired value. For instance, here
    is an alist representing an order for coffee drinks placed by Bill, Lisa, and
    John:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，如果一个键在列表中多次出现，则假定该键的第一个出现包含所需值。例如，以下是一个由比尔、丽莎和约翰订购的咖啡饮料的alist示例：
- en: '[PRE98]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To look up the order for a given person, use the function `assoc`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找给定人员的订单，请使用`assoc`函数：
- en: '[PRE99]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This function searches the list from the beginning for the desired key, and
    then returns the key/value pair. Now suppose that, before picking up the drink
    order, Lisa flags you down and opts to change her order to something slightly
    more decadent. You can change her order using the `push` function:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从列表开头搜索所需键，然后返回键/值对。现在假设在取饮料订单之前，丽莎叫住你并选择将她的订单改为稍微奢侈一些的东西。你可以使用`push`函数更改她的订单：
- en: '[PRE100]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function simply adds a new item to the front of an existing list.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只是将新项目添加到现有列表的前面。
- en: 'Because, by default, the first reference to a key in an association list takes
    precedence over later references to the same key, the order Lisa placed for a
    small drip coffee is superseded by her more recent order:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认情况下，关联列表中键的第一个引用优先于对该键的后续引用，因此丽莎订购的小滴咖啡的订单被她最近的订单所取代：
- en: '[PRE101]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: As you can see, alists are a great way to keep track of any changeable collection
    of key/value pairs. Alists are easy to understand, to manipulate with Lisp functions,
    and to comprehend when printed out (they’re just lists of pairs, after all).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，alist是跟踪任何可变键/值对集合的绝佳方式。alist易于理解，易于使用Lisp函数操作，并且在打印出来时易于理解（毕竟，它们只是成对的列表）。
- en: Furthermore, once a value is stored in an alist, it remains there forever, making
    it easy to audit the history of any data. For instance, in our coffee example,
    the order Lisa placed for her drip coffee is still available even after it has
    been replaced.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦值存储在alist中，它将永远保留在那里，这使得审计任何数据的历史变得容易。例如，在我们的咖啡示例中，丽莎订购的滴咖啡订单即使在被替换后仍然可用。
- en: 'However, alists do have one serious limitation: They are not a very efficient
    way to store and retrieve data, unless you’re dealing with very short lists (under
    a dozen items). Because of this inefficiency, although alists are often one of
    the first tools in the Lisp programmer’s toolbox, they may be replaced by other
    types of data structures as a program matures. (In [Chapter 9](ch10.html "Chapter 9. Advanced
    Datatypes and Generic Programming"), we’ll discuss the performance limitations
    of list-based data structures, such as alists, in greater detail.)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，alist确实有一个严重的限制：除非你处理的是非常短的列表（不到十项），否则它们不是存储和检索数据的高效方式。由于这种低效性，尽管alist通常是Lisp程序员工具箱中的第一个工具之一，但随着程序的成熟，它们可能被其他类型的数据结构所取代。（在第9章[“第9章.
    高级数据类型和泛型编程”](ch10.html "第9章. 高级数据类型和泛型编程")中，我们将更详细地讨论基于列表的数据结构，如alist的性能限制。）
- en: Coping with Complicated Data
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应对复杂数据
- en: Cons cells are a great tool for representing a wide variety of list-like structures.
    In fact, most Lisp programmers, when faced with a programming task that is not
    bound by performance constraints, will rely on them almost exclusively. Because
    the manipulation and visualization of structures made of cons cells are central
    to the design of Lisp, these structures are extremely convenient to use and debug.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: Cons单元是表示各种类似列表结构的一个很好的工具。事实上，大多数Lisp程序员在面临不受性能限制的编程任务时，几乎都会完全依赖它们。因为由cons单元构成的结构的操作和可视化是Lisp设计的关键，这些结构使用起来非常方便，调试起来也很容易。
- en: In fact, even if you do have performance constraints, structures made of cons
    cells can often be a great choice. A Lisp compiler can often reduce a change to
    a cons cell down to a single assembly instruction!
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使你有性能限制，由cons单元构成的结构通常也是一个很好的选择。Lisp编译器通常可以将对cons单元的更改减少到单个汇编指令！
- en: Visualizing Tree-like Data
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化树状数据
- en: As discussed in [Chapter 3](ch03.html "Chapter 3. Exploring the Syntax of Lisp
    Code"), the data (and code) in a Lisp program is represented with syntax expressions.
    In this format, data is represented using nested lists, often with Lisp symbols
    at the front of each list explaining the structure of the data.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](ch03.html "第3章。探索Lisp代码的语法")中所述，Lisp程序中的数据（和代码）是用语法表达式表示的。在这个格式中，数据使用嵌套列表表示，通常在每个列表的前面使用Lisp符号来解释数据的结构。
- en: 'For example, suppose we wanted to represent the component parts of a house
    in Lisp:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在Lisp中表示房屋的组成部分：
- en: '[PRE102]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This data structure very elegantly captures the hierarchical nature of the parts
    that make up a house. Since it is structured as a Lisp syntax expression, we can
    see the lists that make up the levels of the hierarchy. Also, it follows the convention
    of a syntax expression by putting a symbol at the front of each list. For instance,
    we can see how the list describing the windows first contains the Lisp symbol
    `windows` ![](httpatomoreillycomsourcenostarchimages783564.png), which is then
    followed by three items, representing the glass, frame, and finally the curtains
    ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据结构非常优雅地捕捉了构成房屋的部件的层次性质。由于它是以Lisp语法表达式结构化的，我们可以看到构成层次级别的列表。此外，它遵循语法表达式的惯例，在每个列表的前面放置一个符号。例如，我们可以看到描述窗户的列表首先包含Lisp符号`windows`
    ![http://atomoreilly.com/source/nostarch/images/783564.png]，然后是三个项目，代表玻璃、框架，最后是窗帘
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。
- en: As you can see, data that is hierarchical and tree-like in nature can be very
    naturally expressed in this way. In fact, many Lispers consider XML (a popular
    format for representing hierarchical data) somewhat of a reinvention of the syntax
    expression format that Lisp pioneered.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，具有层次结构和树状性质的数据可以非常自然地以这种方式表达。事实上，许多Lisper认为XML（一种流行的表示层次数据的格式）某种程度上是对Lisp开创的语法表达式格式的重新发明。
- en: If, however, we move beyond tree-like structures, data stored in a syntax expression
    can start becoming hard to visualize, even if it’s relatively easy to store the
    data in cons cells. For instance, suppose we have a mathematical graph stored
    in a syntax expression. These types of graphs, where any arbitrary node of the
    graph may be connected to another by an edge, are notoriously hard to visualize
    in a computer program. Even Lisp’s elegant system for representing cons cells
    can’t help much for such data. Next, we’ll look at our options for visualizing
    such graphs.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们超越树状结构，存储在语法表达式中的数据可能会变得难以可视化，即使存储数据在cons单元中相对容易。例如，假设我们有一个存储在语法表达式中的数学图。这类图，其中任何任意节点都可能通过边连接到另一个节点，在计算机程序中通常难以可视化。即使是Lisp表示cons单元的优雅系统对于这类数据也帮助不大。接下来，我们将探讨可视化这类图的选项。
- en: Visualizing Graphs
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化图
- en: In mathematics, a *graph* consists of a bunch of nodes connected by edges. These
    nodes or edges might have additional data associated with them.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，一个*图*由一些通过边连接的节点组成。这些节点或边可能还与额外的数据相关联。
- en: 'Such graphs can be stored in cons cells, but they are difficult to visualize.
    We saw this in [Chapter 5](ch05.html "Chapter 5. Building a Text Game Engine"),
    when we stored the map of the wizard’s house (which consisted of a directed graph)
    in two alists: one containing the node information and one containing the edge
    information. I’ve renamed them `*wizard-nodes*` and `*wizard-edges*` for this
    chapter, as shown here:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的图表可以存储在cons单元格中，但它们很难可视化。我们在[第5章](ch05.html "第5章. 构建文本游戏引擎")中看到了这一点，当时我们将巫师之家的地图（由一个定向图组成）存储在两个alists中：一个包含节点信息，另一个包含边信息。为了本章，我将它们重命名为`*wizard-nodes*`和`*wizard-edges*`，如下所示：
- en: '[PRE103]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, it is hard to get a decent understanding of the structure of
    this game world from these raw data tables. Unfortunately, data that has the shape
    of a graph or contains other properties that go beyond simple tree structures
    are very common. Wouldn’t it be great if we had a tool that could optimally arrange
    this data to create a pretty drawing of a graph? Luckily, there is a fantastic
    open source tool that performs exactly this task, which you’ll try out next.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从这些原始数据表中很难理解这个游戏世界的结构。不幸的是，具有图形状或包含超出简单树结构的其他属性的数据非常常见。如果有一个工具能够最优地安排这些数据以创建一个漂亮的图表，那岂不是很好？幸运的是，有一个出色的开源工具可以执行这项任务，你将在下一节尝试它。
- en: Creating a Graph
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图表
- en: 'Graphviz generates graphs from your data. Indeed, you saw a simple Graphviz
    representation of the wizard’s house in [Chapter 5](ch05.html "Chapter 5. Building
    a Text Game Engine"):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz可以从你的数据生成图表。确实，你在[第5章](ch05.html "第5章. 构建文本游戏引擎")中看到了一个简单的Graphviz表示的巫师之家的示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781548.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781548.png)'
- en: 'Graphviz is open source and available from the Graphviz website ([http://www.graphviz.org/](http://www.graphviz.org/)).
    After you’ve downloaded and installed it, creating a graph is easy. First, you’ll
    create a DOT file that describes the shape of your graph. For example, in Graphviz,
    create a file named *test.dot* on your computer and enter the following information:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz是开源的，可以从Graphviz网站获取([http://www.graphviz.org/](http://www.graphviz.org/))。下载并安装后，创建图表很容易。首先，你将在你的电脑上创建一个名为*test.dot*的DOT文件，并输入以下信息：
- en: '[PRE104]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This defines a directed graph with nodes A and B connected by an arrow. (There
    are numerous syntax options available in the DOT file format, as documented at
    the Graphviz website.)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个由节点A和B通过箭头连接的定向图。（DOT文件格式中有许多语法选项可用，如Graphviz网站上的文档所述。）
- en: 'Now, to generate a graphical bitmap from the DOT file, run `neato` (one of
    the Graphviz utilities) from the command line, as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要从DOT文件生成图形位图，请在命令行中运行`neato`（Graphviz工具之一），如下所示：
- en: '[PRE105]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This should create a picture in the file *test.dot.png* that looks like this:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在文件*test.dot.png*中创建一个看起来像这样的图片：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782744.png.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782744.png.jpg)'
- en: As you can see, Graphviz is simple to use. It can even generate large, complicated
    graphs quickly, with only minor graphical glitches. (Since perfect graph layouts
    are still an unsolved problem in computer science, Graphviz layouts aren’t perfect.
    They are, however, closer to perfect than you might expect.)
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Graphviz使用简单。它甚至可以快速生成大型、复杂的图表，只有轻微的图形错误。（由于完美的图布局仍然是计算机科学中的一个未解问题，因此Graphviz的布局并不完美。然而，它们比你想象的要接近完美。）
- en: Now that you have Graphviz up and running, let’s create a library of commands
    that will let us conveniently draw graphs with Lisp. We can use this to draw some
    graphs of our adventure game world.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经让Graphviz运行起来了，让我们创建一个命令库，这样我们就可以方便地用Lisp绘制图表。我们可以用这个来绘制我们冒险游戏世界的图表。
- en: Note
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The graph utilities used in the examples in this chapter perform certain system
    calls in a way that is not part of the Common Lisp standard. They are available
    only in the CLISP environment. The code would require some modifications to run
    within other Lisp systems.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例中使用的图工具以不包含在Common Lisp标准中的方式进行某些系统调用。它们仅在CLISP环境中可用。代码需要一些修改才能在其他Lisp系统中运行。
- en: Generating the DOT Information
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成DOT信息
- en: In order to create a graph drawing library, we want to generate a Graphviz DOT
    file that captures all the details of a graph. To do this, we will need to convert
    the identifiers of the nodes the player can visit, convert the edges connecting
    these nodes, and generate labels for every node and edge. We will test our library
    using the nodes representing the map of the wizard’s world.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个图形绘制库，我们希望生成一个捕获图形所有细节的 Graphviz DOT 文件。为此，我们需要转换玩家可以访问的节点标识符，转换连接这些节点的边，并为每个节点和边生成标签。我们将使用代表巫师世界地图的节点来测试我们的库。
- en: Converting Node Identifiers
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换节点标识符
- en: 'When converting nodes into DOT format, the first thing we need to do is to
    convert the node identifiers into valid DOT identifiers. We do this by writing
    a `dot-name` function:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在将节点转换为 DOT 格式时，我们首先需要做的是将节点标识符转换为有效的 DOT 标识符。我们通过编写一个 `dot-name` 函数来完成此操作：
- en: '[PRE106]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'A node in DOT format can contain only letters, digits, and the underscore character.
    To make sure the node identifier we’re using is legal, we’ll change any forbidden
    characters to underscores. Here are examples of the `dot-name` function in use:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: DOT 格式的节点只能包含字母、数字和下划线字符。为了确保我们使用的节点标识符是合法的，我们将任何禁止的字符更改为下划线。以下是 `dot-name`
    函数的使用示例：
- en: '[PRE107]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This function accepts any basic Lisp type, which we can then convert to a string
    using the `prin1-to-string` function. We can process the resulting string and
    substitute underscores as needed.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受任何基本 Lisp 类型，然后我们可以使用 `prin1-to-string` 函数将其转换为字符串。我们可以处理生成的字符串并根据需要替换下划线。
- en: Note
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, our `dot-name` function assumes that no node identifiers
    differ only in their nonalphanumeric components. For instance, if we had one node
    called `foo?` and another node called `foo*`, the `dot-name` function would convert
    them both to `foo`, causing the names to clash.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们的 `dot-name` 函数假设没有节点标识符仅在它们的非字母数字组件上有所不同。例如，如果我们有一个名为 `foo?` 的节点和另一个名为
    `foo*` 的节点，`dot-name` 函数会将它们都转换为 `foo`，导致名称冲突。
- en: 'The `substitute-if` function substitutes values based on the result of a test
    function:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`substitute-if` 函数根据测试函数的结果替换值：'
- en: '[PRE108]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The test function in this example, `digit-char-p`, tells us if a character in
    a string is a numerical digit. Test functions like this, which accept a value
    and determine truth based on that value, are often referred to as *predicates*.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的测试函数 `digit-char-p` 告诉我们字符串中的字符是否是数字。像这样的测试函数，它接受一个值并根据该值确定真值，通常被称为 *谓词*。
- en: 'Another interesting property of the `substitute-if` function is that we can
    use it on lists as well:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`substitute-if` 函数的另一个有趣特性是我们可以将其用于列表：'
- en: '[PRE109]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here, all odd numbers in a list have been replaced by the number 0\. The `substitute-if`
    function is one example of a *generic function*—a function that can accept multiple
    datatypes as parameters and handle them appropriately. (Generic programming is
    discussed in [Chapter 9](ch10.html "Chapter 9. Advanced Datatypes and Generic
    Programming").)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，列表中的所有奇数都被替换为数字 0。`substitute-if` 函数是 *泛型函数* 的一个例子——一个可以接受多个数据类型作为参数并相应处理的函数。（泛型编程在
    [第 9 章](ch10.html "第 9 章。高级数据类型和泛型编程") 中讨论。）
- en: 'When we use `substitute-if` in our `dot-name` function, we substitute only
    those characters that aren’t alphanumeric. While no predicate that tests for exactly
    this is available for us in Common Lisp, it is easy to create this predicate on
    the fly. The following fragment in the `dot-name` function creates a predicate
    function for us with exactly the right behavior:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `dot-name` 函数中使用 `substitute-if` 时，我们只替换那些非字母数字的字符。虽然 Common Lisp 中没有为我们提供测试这一点的谓词，但我们可以轻松地动态创建这个谓词。以下
    `dot-name` 函数中的片段为我们创建了一个具有正确行为的谓词函数：
- en: '[PRE110]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Lisp already has a predicate function that tells us if a character is alphanumeric,
    called `alphanumericp`. However, we want to substitute only characters that are
    *not* alphanumeric. We can create this opposite (or *complement*) function to
    `alphanumericp` by passing it to a higher-order function named `complement`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 已经有一个谓词函数，可以告诉我们一个字符是否是字母数字，称为 `alphanumericp`。然而，我们只想替换那些 *不是* 字母数字的字符。我们可以通过将其传递给名为
    `complement` 的高阶函数来创建 `alphanumericp` 的这个相反（或 *补集*）函数。
- en: By passing this function into `substitute-if`, we get the behavior we want,
    without needing to use `defun` to pollute the top level with a new function just
    to feed to `substitute-if`.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此函数传递给 `substitute-if`，我们得到我们想要的行为，而无需使用 `defun` 将新函数污染顶层，仅为了将其提供给 `substitute-if`。
- en: Note
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Common Lisp has a function called `substitute-if-not` that could have been used
    in the `dot-name` function in lieu of `substitute-if` to allow us to leave the
    `not` out of the `lambda` function. However, Lisp functions that end in `not`
    are better avoided. They may be removed from future versions in the ANSI Common
    Lisp standard, which means they are considered deprecated.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 有一个名为 `substitute-if-not` 的函数，本可以在 `dot-name` 函数中使用它来代替 `substitute-if`，从而让我们在
    `lambda` 函数中省略 `not`。然而，以 `not` 结尾的 Lisp 函数最好避免使用。它们可能会在未来版本的 ANSI Common Lisp
    标准中被移除，这意味着它们被认为是过时的。
- en: Adding Labels to Graph Nodes
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为图节点添加标签
- en: 'Now that we can tweak our node identifiers to make them appropriate for DOT,
    let’s write another function that will generate the label that should appear in
    the node when it is drawn. The label will consist of the node name and the data
    linked to the node in the node alist. But we also need to make sure that we are
    not trying to put too much text in the label. Here is the code that generates
    the label:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以调整节点标识符以使其适合 DOT，让我们编写另一个函数来生成节点绘制时应显示的标签。标签将包括节点名称和与节点链接的数据。但我们也需要确保我们不会在标签中放入过多的文本。以下是生成标签的代码：
- en: '[PRE111]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`*max-label-length*` ![](httpatomoreillycomsourcenostarchimages783564.png)
    is a global variable that determines the maximum number of characters for the
    label. If a node label is larger than the limit ![](httpatomoreillycomsourcenostarchimages783560.png),
    it gets cropped, and an ellipsis is added to indicate that fact ![](httpatomoreillycomsourcenostarchimages783554.png).
    The `write-to-string` function ![](httpatomoreillycomsourcenostarchimages783562.png)
    is similar to the `prin1-to-string` function we used earlier—it writes an expression
    to a string.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`*max-label-length*` ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)
    是一个全局变量，它决定了标签的最大字符数。如果一个节点标签大于限制 ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)，它会被裁剪，并添加省略号来表示这一点
    ![图片链接](http://atomoreilly.com/source/nostarch/images/783554.png)。`write-to-string`
    函数 ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png) 与我们之前使用的
    `prin1-to-string` 函数类似——它将表达式写入字符串。'
- en: The `:pretty` parameter is an example of a *keyword parameter*, which is used
    by certain Lisp functions to let you choose which parameters you want to pass
    in. In the case of `write-to-string`, it tells Lisp not to alter the string to
    make it pretty. Without this, Lisp would place new lines or tabs into our converted
    string to make it look more pleasing to the eye. By setting the `:pretty` keyword
    parameter to `nil`, we are telling Lisp to output the expression without any decorations.
    (Having new lines in a label can confuse Graphviz, so we don’t want to give Lisp
    any ideas.)
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`:pretty` 参数是一个 *关键字参数* 的例子，某些 Lisp 函数使用它来让你选择你想要传递的参数。在 `write-to-string`
    的情况下，它告诉 Lisp 不要改变字符串以使其更美观。如果没有这个参数，Lisp 会将新行或制表符放入转换后的字符串中，使其看起来更悦目。通过将 `:pretty`
    关键字参数设置为 `nil`，我们告诉 Lisp 输出表达式而不添加任何装饰。（标签中包含新行可能会让 Graphviz 产生混淆，所以我们不想给 Lisp
    任何提示。）'
- en: Generating the DOT Information for the Nodes
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成节点的 DOT 信息
- en: 'Now that we can generate both a name and label for each node, we can write
    a function that takes an alist of nodes and generates the DOT information that
    encodes them, like so:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为每个节点生成名称和标签，我们可以编写一个函数来接受节点 alst 并生成编码它们的 DOT 信息，如下所示：
- en: '[PRE112]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This function uses `mapc` to go through every node in the list of nodes ![](httpatomoreillycomsourcenostarchimages783564.png),
    and `princ` prints each node in the DOT format directly to the screen. `mapc`
    is a slightly more efficient variant of `mapcar;` the difference is that it does
    not return the transformed list. The `nodes->dot` function uses the `dot-name`
    ![](httpatomoreillycomsourcenostarchimages783562.png) and `dot-label` ![](httpatomoreillycomsourcenostarchimages783560.png)
    functions we created to convert the data.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用 `mapc` 遍历节点列表中的每个节点 ![图片链接](http://atomoreilly.com/source/nostarch/images/783564.png)，然后
    `princ` 将每个节点以 DOT 格式直接打印到屏幕上。`mapc` 是 `mapcar` 的一个稍微更高效的变体；区别在于它不返回转换后的列表。`nodes->dot`
    函数使用我们创建的 `dot-name` ![图片链接](http://atomoreilly.com/source/nostarch/images/783562.png)
    和 `dot-label` ![图片链接](http://atomoreilly.com/source/nostarch/images/783560.png)
    函数来转换数据。
- en: Later, when we want to generate a file that contains this information, we’ll
    write a function that takes this data from the console.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们想要生成包含这些信息的文件时，我们将编写一个函数来从控制台获取这些数据。
- en: It may seem a bit odd to use the console as an intermediary for generating a
    file, instead of just writing directly into a file, but this is actually a common
    paradigm in Lisp. One immediate benefit of this approach is that we can easily
    debug the code in the REPL, where the printed lines are easy to see.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台作为生成文件的中间件，而不是直接写入文件，这似乎有点奇怪，但实际上这是 Lisp 中的一种常见范式。这种方法的直接好处是我们可以在 REPL
    中轻松调试代码，打印的行很容易看到。
- en: 'Now let’s try using the `nodes->dot` function to generate the DOT information
    for the nodes in the wizard’s house:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用 `nodes->dot` 函数来生成巫师房子中节点的 DOT 信息：
- en: '[PRE113]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Here, you can see the nodes of the wizard’s house and an abbreviated version
    of the information attached to each node, shown in DOT format. Notice that we
    are not interested in the value returned from the `nodes->dot` function—only in
    the information it prints in the REPL. Lispers would say that we are only interested
    in the *side effects* of this function. Although `mapc` does not return the list,
    it still causes the code to iterate through the list and generate the same printed
    output that using `mapcar` would have, so it generates the same side effects as
    `mapcar`, a bit more quickly.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到巫师房子的节点以及每个节点附加的简略信息，以 DOT 格式显示。请注意，我们对 `nodes->dot` 函数返回的值不感兴趣——只对它在
    REPL 中打印的信息感兴趣。Lispers 会说我们只对函数的 *副作用* 感兴趣。尽管 `mapc` 不返回列表，但它仍然导致代码遍历列表并生成与使用
    `mapcar` 相同的打印输出，因此它生成与 `mapcar` 相同的副作用，但速度更快。
- en: Converting Edges into DOT Format
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将边转换为 DOT 格式
- en: The next step is to generate the DOT information for the edges that link our
    nodes. These will become the arrows in our visual graph. The function `edges->dot`
    generates the necessary data, again by printing it directly to the console.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成连接我们的节点的边的 DOT 信息。这些将成为我们视觉图中的箭头。`edges->dot` 函数通过直接打印到控制台生成必要的数据。
- en: '[PRE114]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let’s use this function to generate the DOT information for the edges of the
    wizard’s house:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个函数来生成巫师房子的边界的 DOT 信息：
- en: '[PRE115]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here, we can clearly see the relationships between the nodes in the wizard’s
    house, in the DOT format. For instance, the first line ![](httpatomoreillycomsourcenostarchimages783564.png)
    indicates that the player can walk from the `LIVING_ROOM` node to the `GARDEN`
    node by using an edge labeled `(WEST DOOR)`.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以清楚地看到巫师房子中节点之间的关系，以 DOT 格式显示。例如，第一行 ![](httpatomoreillycomsourcenostarchimages783564.png)
    指出，玩家可以通过使用标签为 `(WEST DOOR)` 的边从 `LIVING_ROOM` 节点走到 `GARDEN` 节点。
- en: Generating All the DOT Data
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成所有 DOT 数据
- en: 'To complete our generation of the DOT data, we call both `nodes->dot` and `edges->dot`,
    and wrap it up with some extra decoration, as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的 DOT 数据生成，我们调用 `nodes->dot` 和 `edges->dot`，并用一些额外的装饰来结束，如下所示：
- en: '[PRE116]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This function ties everything together by defining our graph as a directional
    graph ![](httpatomoreillycomsourcenostarchimages783564.png), and then calling
    our `nodes->dot` ![](httpatomoreillycomsourcenostarchimages783562.png) and `edges->dot`
    ![](httpatomoreillycomsourcenostarchimages783560.png) functions.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过将我们的图定义为有向图 ![](httpatomoreillycomsourcenostarchimages783564.png)，然后调用我们的
    `nodes->dot` ![](httpatomoreillycomsourcenostarchimages783562.png) 和 `edges->dot`
    ![](httpatomoreillycomsourcenostarchimages783560.png) 函数来整合一切。
- en: 'Here’s what the final DOT information for our wizard game looks like, as created
    by our new library:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们新库创建的最终 DOT 信息，用于我们的巫师游戏：
- en: '[PRE117]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We can now generate a proper Graphviz DOT file that captures all the details
    of our wizard map that we need to generate a pretty picture. These include the
    nodes the player can visit, the edges connecting these nodes, and labels for every
    node and edge.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成一个合适的 Graphviz DOT 文件，它捕捉了我们生成漂亮图片所需的巫师地图的所有细节。这包括玩家可以访问的节点、连接这些节点的边以及每个节点和边的标签。
- en: Turning the DOT File into a Picture
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DOT 文件转换为图片
- en: 'To turn the DOT file into an actual bitmap, we capture the DOT file data, put
    it into a file, and then execute the `dot` command directly from the system command
    line, like this:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 DOT 文件转换为实际的位图，我们捕获 DOT 文件数据，将其放入文件中，然后直接从系统命令行执行 `dot` 命令，如下所示：
- en: '[PRE118]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This function performs the most critical actions in our graph drawing library,
    using some advanced Lisp techniques.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在我们的图形绘制库中执行最关键的操作，使用了一些高级 Lisp 技术。
- en: First, to keep this `dot->png` function as reusable as possible, the `graph->dot`
    function isn’t called directly. Instead, we write `dot->png` to accept a thunk
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使这个 `dot->png` 函数尽可能可重用，我们不直接调用 `graph->dot` 函数。相反，我们编写 `dot->png` 以接受一个
    Thunk ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)。
- en: Using Thunks
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Thunks
- en: It is common in Lisp to create small functions that have zero arguments. These
    functions are officially called *nullary functions*. However, Lispers will often
    create such functions in order to describe a computation that they don’t want
    to run until later. In this scenario, a function without arguments is commonly
    called a *thunk* or a *suspension*. In this case, the thunk our `dot->png` function
    needs would be a function that, when called, prints a DOT file to the console.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Lisp 中，创建没有参数的小函数是很常见的。这些函数官方上被称为 *nullary functions*。然而，Lispers 经常创建这样的函数来描述他们不想立即运行的计算。在这种情况下，没有参数的函数通常被称为
    *thunk* 或 *suspension*。在这种情况下，`dot->png` 函数需要的 Thunk 将是一个函数，当调用时，将 DOT 文件打印到控制台。
- en: Why is a thunk useful in our `dot->png` function? Remember that the easiest
    way for us to write and debug `graph->dot` and other DOT file functions is to
    have them print their results directly to the console. When we call `graph->dot`,
    it doesn’t return its results as a value, but, instead, prints them at the console
    as a side effect. Therefore, we can’t just pass the value of `graph->dot` to `dot->png`.
    Instead, we pass in `graph->dot` as a thunk. Then `dot->png` is responsible for
    calling `graph->dot`, capturing the results, and sending them to a file.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Thunk 在我们的 `dot->png` 函数中很有用？记住，对我们来说，最容易的方法是将 `graph->dot` 和其他 DOT 文件函数的结果直接打印到控制台进行编写和调试。当我们调用
    `graph->dot` 时，它不会返回一个值，而是作为副作用在控制台打印出来。因此，我们不能直接将 `graph->dot` 的值传递给 `dot->png`。相反，我们传递
    `graph->dot` 作为 Thunk。然后 `dot->png` 负责调用 `graph->dot`，捕获结果并将它们发送到文件。
- en: 'Since it is so common to generate textual data with a computer program, this
    particular technique is used a lot in Lisp code: First, we print stuff right to
    the console; next, we wrap it in a thunk; finally, we redirect the results to
    some other location.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用计算机程序生成文本数据非常常见，这种特定的技术在 Lisp 代码中得到了广泛使用：首先，我们将内容直接打印到控制台；然后，我们将它包装在 Thunk
    中；最后，我们将结果重定向到其他位置。
- en: As you’ll see in [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch
    with Functional Programming"), Lispers who follow the functional programming style
    eschew this technique, because side effects are required when printing to the
    console.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [第 14 章](ch16.html "第 14 章。使用函数式编程提升 Lisp 的能力") 中所看到的，遵循函数式编程风格的 Lisp 程序员避免使用这种技术，因为在打印到控制台时需要副作用。
- en: Writing to a File
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'The function `with-open-file` enables `dot->png` to write information to a
    file ![](httpatomoreillycomsourcenostarchimages783562.png). To give you a feel
    for how this function works, here’s an example that creates a new file named *testfile.txt*
    and writes the text “Hello File!” to it:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `with-open-file` 允许 `dot->png` 将信息写入文件 ![图片链接](httpatomoreillycomsourcenostarchimages783562.png)。为了让你了解这个函数的工作方式，这里有一个示例，它创建了一个名为
    *testfile.txt* 的新文件，并将文本 “Hello File!” 写入其中：
- en: '[PRE119]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In this example, you can see that the first item ![](httpatomoreillycomsourcenostarchimages783564.png)
    passed into `with-open-file` becomes the name of a special Common Lisp datatype
    called a *stream*, which is created for us by `with-open-file`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以看到传递给 `with-open-file` 的第一个项目 ![图片链接](httpatomoreillycomsourcenostarchimages783564.png)
    成为了一个特殊 Common Lisp 数据类型 *流* 的名称，它是通过 `with-open-file` 为我们创建的。
- en: Creating a Stream
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建流
- en: Printing functions, such as `princ`, can accept a stream as an optional parameter.
    In this case, these printing functions won’t print anything to the console, but
    instead will print to the stream object.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 打印函数，如 `princ`，可以接受流作为可选参数。在这种情况下，这些打印函数不会打印任何内容到控制台，而是打印到流对象。
- en: 'It is important to understand that `with-open-file` creates a stream variable
    from a stream variable name, in the same way that `let` creates a variable from
    a variable name:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 `with-open-file` 从流变量名创建一个流变量，就像 `let` 从变量名创建变量一样：
- en: '[PRE120]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: So if we pass the name `my-stream` in at the front of the first list to `with-open-file`
    ![](httpatomoreillycomsourcenostarchimages783564.png), this is analogous to defining
    `my-variable` at the start of a `let` ![](httpatomoreillycomsourcenostarchimages783560.png).
    A variable named `my-stream` will be available to us in the body of `with-open-file`
    ![](httpatomoreillycomsourcenostarchimages783562.png), in the same way that `my-variable`
    will be available to us in the body of the `let` ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们把 `my-stream` 这个名字放在 `with-open-file` ![](httpatomoreillycomsourcenostarchimages783564.png)
    的第一个列表前面，这就像在 `let` ![](httpatomoreillycomsourcenostarchimages783560.png) 的开始定义
    `my-variable`。在 `with-open-file` ![](httpatomoreillycomsourcenostarchimages783562.png)
    的主体中，我们将有一个名为 `my-stream` 的变量可用，就像在 `let` ![](httpatomoreillycomsourcenostarchimages783554.png)
    的主体中 `my-variable` 可用一样。
- en: But don’t worry too much about exactly what a stream is just yet. We’ll be looking
    at them more closely in [Chapter 12](ch13.html "Chapter 12. Working with Streams").
    For now, you just need to know that a stream is an object that can be connected
    to a file, and we can pass it to functions (such as `princ`) to write stuff to
    the connected file.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在不必太担心流的确切含义。我们将在 [第 12 章](ch13.html "第 12 章。处理流") 中更详细地探讨它们。现在，你只需要知道流是可以连接到文件的对象，我们可以将其传递给函数（如
    `princ`）以写入连接的文件。
- en: Understanding Keyword Parameters
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解关键字参数
- en: 'The `with-open-file` command also makes heavy use of keyword parameters. Let’s
    look at our previous example of this command again:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-open-file` 命令也大量使用了关键字参数。让我们再次看看这个命令的先前的例子：'
- en: '[PRE121]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A keyword parameter has two parts: the name of the parameter and the value
    of the parameter. The name of the parameter is always a symbol beginning with
    a colon. This example has two keyword parameters: `:direction` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which is set to `:output` (we’re only writing to the file and not reading it),
    and `:if-exists` ![](httpatomoreillycomsourcenostarchimages783562.png), which
    is set to `:superseded` (if a file by that name already exists, just toss out
    the old version).'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数有两个部分：参数的名称和参数的值。参数的名称始终是一个以冒号开头的符号。这个例子中有两个关键字参数：`:direction` ![](httpatomoreillycomsourcenostarchimages783564.png)，设置为
    `:output`（我们只写入文件而不读取它），以及 `:if-exists` ![](httpatomoreillycomsourcenostarchimages783562.png)，设置为
    `:superseded`（如果已存在同名文件，则丢弃旧版本）。
- en: '`with-open-file` has keyword parameters because opening a file is a complex
    operation, and many esoteric options are available. If `with-open-file` just gave
    you regular parameters to set all this, every call to `with-open-file` would be
    long and cumbersome due to all the parameters. Also, humans have a hard time looking
    at a long list of parameters and remembering which one does what.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`with-open-file` 有关键字参数，因为打开文件是一个复杂的操作，有许多神秘的选项可用。如果 `with-open-file` 只提供了常规参数来设置所有这些，那么每次调用
    `with-open-file` 都会因为所有参数而变得长而繁琐。此外，人类很难查看长长的参数列表并记住每个参数的作用。'
- en: 'As you’ve probably noticed, symbols in Common Lisp sometimes begin with a colon.
    This includes keyword parameters, which always start with a colon. This is because
    a regular symbol in Lisp can refer to something else. For instance, we could set
    a variable `cigar` equal to `5` and then return it:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了，Common Lisp 中的符号有时以冒号开头。这包括关键字参数，它们总是以冒号开头。这是因为 Lisp 中的常规符号可以指向其他东西。例如，我们可以将变量
    `cigar` 设置为 `5` 然后返回它：
- en: '[PRE122]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'However, sometimes we don’t want a symbol to refer to something else. We want
    to use the symbol outright, and we want it to have its own meaning. A colon-prepended
    symbol in Common Lisp (not surprisingly, called a *keyword symbol*) always means
    itself:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们不想让一个符号指向其他东西。我们希望直接使用这个符号，并希望它有自己的含义。在 Common Lisp 中，以冒号开头的符号（不出所料，被称为
    *关键字符号*）总是指代它自己：
- en: '[PRE123]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: As you can see, the keyword symbol `:cigar` can be evaluated right at the REPL
    and already has a value ![](httpatomoreillycomsourcenostarchimages783564.png).
    Its value is, conveniently, `:cigar`. If we try to redefine `:cigar` to something
    else, Common Lisp won’t let us ![](httpatomoreillycomsourcenostarchimages783562.png).
    The fact that it is constant is useful, because a Lisp compiler can potentially
    optimize this simple type of symbol more than it can optimize other types. Also,
    we can reduce errors in our code by using keyword symbols in places where we know
    a symbol just has a meaning in its own right. Sometimes a cigar is just a cigar.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，关键字符号`:cigar`可以直接在REPL中评估，并且已经有一个值！。它的值是方便的`:cigar`。如果我们尝试将`:cigar`重新定义为其他内容，Common
    Lisp不会允许我们这样做！。它是一个常量的事实是有用的，因为Lisp编译器可以潜在地对这种简单类型的符号进行比其他类型更多的优化。此外，我们可以在我们知道符号仅仅具有其自身意义的地方使用关键字符号来减少代码中的错误。有时一支雪茄就是一支雪茄。
- en: Capturing the Console Output
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获控制台输出
- en: 'Our `dot->png` sends our data to the file in a slightly different way than
    is shown in this example: by declaring the name of the stream to be `*standard-output*`
    (a special global variable in Common Lisp that controls the default location to
    which printing functions send their output). As a result, any printing done inside
    the thunk will be redirected to our DOT file.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`dot->png`以与示例中所示略有不同的方式将数据发送到文件：通过声明流的名字为`*standard-output*`（Common Lisp中的一个特殊全局变量，它控制打印函数将输出发送到的默认位置）。因此，在thunk内部进行的任何打印都将被重定向到我们的DOT文件。
- en: 'Let’s look at our `dot->png` function again to see this:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看我们的`dot->png`函数，以了解这一点：
- en: '[PRE124]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So how exactly does the `dot->png` function cause our DOT data to get saved
    to a file instead of just going to the console? To answer this, you’ll need to
    exercise your brain a bit. Also, you’ll need to recall our discussion of local
    and dynamic variables in [Chapter 2](ch02.html "Chapter 2. Creating Your First
    Lisp Program").
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`dot->png`函数究竟是如何导致我们的DOT数据被保存到文件而不是仅仅发送到控制台的呢？为了回答这个问题，你需要稍微锻炼一下你的大脑。同时，你还需要回忆我们在[第2章](ch02.html
    "第2章。创建你的第一个Lisp程序")中关于局部和动态变量的讨论。
- en: Remember that the let command usually creates a *lexical*, or local, variable.
    As we’ve discussed, the stream variable created by `with-open-file` is analogous
    to using `let` to create a variable. Hence, it usually leads to the creation of
    a lexical stream variable for us.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，let命令通常创建一个*词法*，或局部，变量。正如我们讨论过的，`with-open-file`创建的流变量类似于使用`let`创建变量。因此，它通常会导致为我们创建一个词法流变量。
- en: However, if a dynamic variable already exists with the same name, `let` will
    instead, temporarily, override the value of the dynamic variable to the new value.
    `*standard-output*` is such a dynamic variable. This means that we can temporarily
    override the value of `*standard-output*` to a new value by passing it into our
    `with-open-file` command ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果已经存在具有相同名称的动态变量，`let`将暂时覆盖动态变量的值到新值。`*standard-output*`就是这样一种动态变量。这意味着我们可以通过将其传递到`with-open-file`命令中来暂时覆盖`*standard-output*`的值！
- en: In the body of the `with-open-file`, where we call our thunk ![](httpatomoreillycomsourcenostarchimages783562.png),
    any values printed to the console will now be automagically routed to our file,
    instead. The surprising thing (enabled by the design of lexical and dynamic variables
    in Common Lisp) is that this is also true for the `princ` statements in our `graph->dot`
    function, even though they are called indirectly from `dot->png`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with-open-file`的主体中，我们调用我们的thunk，任何打印到控制台中的值现在将自动路由到我们的文件中，而不是控制台。令人惊讶的是（这是由Common
    Lisp中词法和动态变量的设计所实现的），这一点也适用于我们的`graph->dot`函数中的`princ`语句，尽管它们是从`dot->png`间接调用的。
- en: Creating a Picture of Our Graph
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们图的图像
- en: 'Lastly, we need a function that ties together all the pieces to let us easily
    create a graph from some nodes and edges:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个函数来将这些部分连接起来，使我们能够轻松地从一些节点和边创建一个图：
- en: '[PRE125]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This function takes the name of a DOT file (as the variable `fname`), as well
    as the graph’s nodes and edges ![](httpatomoreillycomsourcenostarchimages783564.png),
    and uses them to generate the graph. To do this, it calls `dot->png` ![](httpatomoreillycomsourcenostarchimages783562.png)
    and creates the appropriate thunk—a `lambda` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    As is usual for a thunk, it takes no parameters.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个 DOT 文件名（作为变量 `fname`），以及图的节点和边 ![图片](httpatomoreillycomsourcenostarchimages783564.png)，并使用它们来生成图。为此，它调用
    `dot->png` ![图片](httpatomoreillycomsourcenostarchimages783562.png) 并创建适当的 thunk——一个
    `lambda` 函数 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。对于 thunk 来说，这是惯例，它不接受任何参数。
- en: The `graph->dot` function is called inside the thunk ![](httpatomoreillycomsourcenostarchimages783554.png)
    as a *delayed computation*. Specifically, if we had called `graph->dot` directly,
    its output would just show up in the console. However, when inside the thunk,
    it will be called at the leisure of the `dot->png` function, and the output will
    be used to generate the DOT file with the filename passed in as the first parameter
    to `graph->png`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`graph->dot` 函数在 thunk 内部 ![图片](httpatomoreillycomsourcenostarchimages783554.png)
    作为 *延迟计算* 被调用。具体来说，如果我们直接调用 `graph->dot`，其输出将直接显示在控制台上。然而，在 thunk 内部，它将在 `dot->png`
    函数的空闲时被调用，并且输出将被用来生成带有文件名的 DOT 文件，该文件名作为 `graph->png` 的第一个参数传入。'
- en: Let’s try out our new function to draw a graph of the wizard’s house!
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的新函数绘制巫师房子的图表！
- en: '[PRE126]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'After calling this function, you should now see a file named *wizard.dot.png*,
    a picture of the map of the wizard’s house:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数后，你现在应该看到一个名为 *wizard.dot.png* 的文件，这是巫师房子的地图图片：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783218.png)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783218.png)'
- en: This may not be the prettiest graph on the planet, but it’s packed with information
    and is very easy to understand. Also, the code is extremely flexible, and places
    few dependencies on our node and edge data.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是世界上最漂亮的图，但它信息量很大，并且非常容易理解。此外，代码非常灵活，对节点和边数据的依赖性很少。
- en: With these utilities in our arsenal, we can now easily create graphs from any
    interconnected data in our Lisp programs. You’ll find this technique to be a valuable
    debugging tool when you need to deal with complicated data.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具库中有了这些工具后，我们现在可以轻松地从Lisp程序中的任何互连数据创建图表。当你需要处理复杂数据时，你会发现这项技术是一个非常有价值的调试工具。
- en: Creating Undirected Graphs
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建无向图
- en: 'A graph that has arrows on its edges is called a *directed graph*:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在边上带有箭头的图称为 *有向图*：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781434.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781434.png)'
- en: 'But sometimes we have data that is undirected, allowing us to travel in both
    directions along an edge. Such a graph is less busy than a directed graph, and
    can be easier to understand:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们拥有无向数据，允许我们沿着边在两个方向上旅行。这种图比有向图更不繁忙，并且可能更容易理解：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781500.png.jpg)'
  id: totrans-691
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781500.png.jpg)'
- en: 'The following code expands our graph utilities with new functions that let
    us draw undirected graphs:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码通过新的函数扩展了我们的图表工具，使我们能够绘制无向图：
- en: '[PRE127]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This code is very similar to the code for creating our directed graphs. Let’s
    look at some of the differences.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与创建我们有向图的代码非常相似。让我们看看一些不同之处。
- en: The `uedges->dot` function is very similar to the `edges->dot` function ![](httpatomoreillycomsourcenostarchimages783564.png).
    However, the graph we’re drawing may have multiple directed edges between the
    same nodes that we want to replace with a single, undirected edge. For instance,
    on our wizard map, we can walk from the garden to the living room by going *east*
    through the door. Of course, we can also walk from the living room to the garden
    by going *west* through the exact same door. In our undirected graph, we’ll want
    to collapse this; in essence, we just want to say, “There’s a door between the
    garden and living room.”
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`uedges->dot` 函数与 `edges->dot` 函数非常相似 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。然而，我们绘制的图可能包含多个节点之间的有向边，我们希望用一条单条无向边来替换。例如，在我们的巫师地图上，我们可以通过门向东走从花园到客厅。当然，我们也可以通过门向西走从客厅到花园。在我们的无向图中，我们希望合并这一点；本质上，我们只想说，“花园和客厅之间有一扇门。”'
- en: 'The `uedges->dot` function erases such duplicate edges by running through the
    list of edges using the `maplist` function. This is like the `mapcar` function,
    except that the function inside it receives the entire remainder of the list,
    not just the current item in the list:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`uedges->dot` 函数通过使用 `maplist` 函数遍历边列表来擦除这样的重复边。这类似于 `mapcar` 函数，但函数内部接收的是整个列表的剩余部分，而不仅仅是列表中的当前项：'
- en: '[PRE128]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `maplist` function sends the `print` function everything in the list from
    the current item until the end. `uedges->dot` ![](httpatomoreillycomsourcenostarchimages783564.png)
    then uses the information about future nodes it gets from `maplist` to check whether
    the destination of the node appears later in the edge list. The actual checking
    is done with the `assoc` function, looking for the current edge in the list of
    remaining edges, calculated as `(cdr lst)` ![](httpatomoreillycomsourcenostarchimages783562.png).
    In this case, it skips the edge so that only one of any pair of edges will be
    printed.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`maplist` 函数将列表中从当前项到末尾的所有内容发送给 `print` 函数。`uedges->dot` ![](httpatomoreillycomsourcenostarchimages783564.png)
    然后使用从 `maplist` 获得的未来节点信息来检查节点目标是否出现在边列表中。实际的检查是通过 `assoc` 函数完成的，在剩余边列表中寻找当前边，计算为
    `(cdr lst)` ![](httpatomoreillycomsourcenostarchimages783562.png)。在这种情况下，它跳过该边，因此任何一对边中只打印一个。'
- en: The `ugraph->dot` ![](httpatomoreillycomsourcenostarchimages783560.png) function
    is similar to the `graph->dot` function, except that it describes the graph as
    just a graph ![](httpatomoreillycomsourcenostarchimages783554.png) when generating
    the DOT data, instead of a digraph. The `ugraph->png` function ![](httpatomoreillycomsourcenostarchimages783510.png)
    is essentially identical to the `graph->png` function, except that it calls `ugraph->dot`
    instead of `graph->dot`.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`ugraph->dot` ![](httpatomoreillycomsourcenostarchimages783560.png) 函数与 `graph->dot`
    函数类似，但在生成 DOT 数据时，它将图描述为只是一个图 ![](httpatomoreillycomsourcenostarchimages783554.png)，而不是有向图。`ugraph->png`
    函数 ![](httpatomoreillycomsourcenostarchimages783510.png) 与 `graph->png` 函数基本相同，只是它调用
    `ugraph->dot` 而不是 `graph->dot`。'
- en: 'We designed the `dot->png` function to accept different thunks so it could
    work with different DOT data generators. Now we’ve used this flexibility to generate
    these functions that output pictures for undirected graphs. For example, let’s
    try generating an undirected graph for the wizard’s house:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了 `dot->png` 函数以接受不同的 thunks，以便它能与不同的 DOT 数据生成器一起工作。现在我们已经利用这种灵活性来生成这些函数，它们为无向图输出图片。例如，让我们尝试为巫师的房子生成一个无向图：
- en: '[PRE129]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Here, `"uwizard.dot"` is the name of the DOT file we want to create. The `*wizard-nodes*`
    and `*wizard-edges*` variables contain the data describing the nodes and edges
    of the map of the wizard’s world. This code generates the *uwizard.dot.png* file,
    which looks like this:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`"uwizard.dot"` 是我们想要创建的 DOT 文件名。`*wizard-nodes*` 和 `*wizard-edges*` 变量包含描述巫师世界地图的节点和边的数据。此代码生成
    *uwizard.dot.png* 文件，其外观如下：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781832.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781832.png)'
- en: Now that you have a full suite of utilities for both directed and undirected
    graphs, write these functions to a file named *graph-util.lisp*, so you can access
    them from other programs.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了针对有向和无向图的完整工具集，将这些函数写入名为 *graph-util.lisp* 的文件中，这样你就可以从其他程序中访问它们。
- en: What You've Learned
  id: totrans-705
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we discussed exotic types of lists and created a drawing library
    for mathematical graphs. Along the way, you learned the following:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了列表的奇特类型，并为数学图创建了一个绘图库。在这个过程中，你学习了以下内容：
- en: You can create lists in Lisp that end in a value other than nil. Such lists
    are displayed with an extra dot before the last item and are called *dotted lists*.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 Lisp 中创建以非 nil 值结尾的列表。这些列表在最后一个项目前有一个额外的点，被称为 *点列表*。
- en: '*Pairs* are what you get when you cons together two items that are not lists
    themselves. They can also be thought of as dotted lists that contain only two
    items.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对* 是当你将两个不是列表的项 cons 到一起时得到的结果。它们也可以被视为只包含两个项目的点列表。'
- en: '*Circular lists* are lists where the last cons cell points to an earlier cons
    cell in the same list.'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*循环列表* 是指最后一个 cons 单元指向同一列表中较早的 cons 单元的列表。'
- en: '*Association lists (alists)* are lists of pairs. They can be used to store
    data that is in the form of keys associated with values.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关联列表（alists）* 是对列表示。它们可以用来存储以键值对形式存在的数据。'
- en: Lisp syntax expressions are great for storing and visualizing list-like and
    hierarchical data. Extra tools may be helpful for visualizing more complex data.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lisp语法表达式非常适合存储和可视化类似列表和层次结构的数据。额外的工具可能有助于可视化更复杂的数据。
- en: If your data is in the form of a mathematical graph, it’s helpful to be able
    to generate pictures of your data using Graphviz.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据是以数学图的形式，使用Graphviz生成你的数据图片是有帮助的。
- en: A common technique for generating textual data in a Lisp program is to write
    functions that print the text to the console for easy debugging and wrap these
    functions in thunks. Then you can send these thunks to other functions, which
    capture the console output and route the text to the appropriate destination,
    such as writing it to a file.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Lisp程序中生成文本数据的一个常见技术是编写将文本打印到控制台以方便调试的函数，并将这些函数包装在thunks中。然后你可以将这些thunks发送到其他函数，这些函数捕获控制台输出并将文本路由到适当的目的地，例如写入文件。
- en: Chapter 8. This Ain't Your Daddy's Wumpus
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 这不是你爸爸的Wumpus
- en: In the previous chapter, we worked with mathematical graphs in a simple game.
    However, as an old-school geek, the first thing I think of when I see these graphs
    is the old game Hunt the Wumpus. When I was nine, I could think of nothing more
    fun than sitting in front of my TI-99/4A and playing this excellent game.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在一个简单的游戏中使用了数学图。然而，作为一个老派的极客，当我看到这些图时，我首先想到的是老游戏“猎杀Wumpus”。当我九岁的时候，我想不出比坐在我的TI-99/4A前玩这个优秀游戏更有趣的事情了。
- en: 'Here is the original title screen:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是原始标题屏幕：
- en: In Hunt the Wumpus, you are a hunter searching through a network of caves to
    find a mysterious monster—the fabled Wumpus. Along the way, you also deal with
    bats and tar pits. Ah, those were the days!
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在“猎杀Wumpus”游戏中，你是一名猎人，在洞穴网络中寻找一个神秘的怪物——传说中的Wumpus。在这个过程中，你还要应对蝙蝠和沥青坑。啊，那些日子真是美好！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779776.png.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779776.png.jpg)'
- en: But, unfortunately, those days are long gone. We’re in a new millennium now,
    and no one would be impressed by these crude graphics anymore. And the story line,
    well, let’s just say it sounds a bit corny by modern standards. I think we can
    all agree that Hunt the Wumpus is in serious need of a makeover. That’s quite
    a challenge, but one I think we can handle.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 但，不幸的是，那些日子已经一去不复返了。我们现在已经进入了一个新的千年，没有人会对这些粗糙的图形感到印象深刻。至于剧情，让我们说它按照现代标准听起来有点老套。我想我们都可以同意，猎杀Wumpus迫切需要一次翻新。这是一个相当大的挑战，但我认为我们可以应对。
- en: Therefore, I present to you . . .
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我向您展示……
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783024.png.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783024.png.jpg)'
- en: The Grand Theft Wumpus Game
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大盗Wumpus游戏
- en: In this new version of Hunt the Wumpus, you are the Lisp alien. You and the
    Wumpus have just robbed a liquor store and made off with the loot. However, during
    the escape, the Wumpus decides to double-cross you and run off with the money
    and your car. But before he drives off, you manage to cap him a couple of times
    in the kidney.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的“猎杀Wumpus”版本中，你是Lisp外星人。你和Wumpus刚刚抢劫了一家酒馆，并带着赃物逃跑了。然而，在逃跑过程中，Wumpus决定背叛你，带着钱和你的车跑了。但在他开车离开之前，你设法在他肾脏上打了几枪。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781862.png.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781862.png.jpg)'
- en: Now you’re in a pretty tough situation. You don’t have a car or any money, and
    no way to track down your former partner in crime. But you also have no choice.
    You have your principles, so you’re going to *hunt the Wumpus*. You know he won’t
    be able to get very far with his injuries. He will most likely need to lie low
    for a few days to recover, which means he will still be somewhere in Congestion
    City. The problem is that the roads in this town are impossibly convoluted, and
    no one can find their way around, especially an out-of-towner like yourself. How
    are you ever going to find the Wumpus in this impossible maze?
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你处于一个非常艰难的情况。你没有车，也没有钱，而且无法追踪你以前的犯罪伙伴。但你也没有选择。你有你的原则，所以你将去*猎杀Wumpus*。你知道他受伤后不会走得太远。他很可能需要躲起来几天来恢复，这意味着他仍然会在拥堵城市中某个地方。问题是这个城镇的道路极其复杂，没有人能找到出路，尤其是像你这样的外地人。你如何在这个不可能的迷宫中找到Wumpus呢？
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781264.png.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781264.png.jpg)'
- en: Luckily, being the Lisp alien, you always carry your trusty pocket computer.
    Using Lisp and your graph utilities, you’re fully equipped to analyze complicated
    data such as the Congestion City roadways and intersections. Surely, you have
    the tools to conquer this impenetrable road system.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，作为Lisp外星人，你总是带着你可靠的口袋电脑。使用Lisp和你的图工具，你完全装备好了来分析复杂的数据，比如拥堵城的道路和交叉口。当然，你有征服这个难以渗透的道路系统的工具。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780646.png.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780646.png.jpg)'
- en: 'The Wumpus has been your partner in crime for a while now, so you know his
    MO quite well. He will always carefully scout out any new hiding place before
    he uses it. And since he is injured, any location one or two blocks away (that
    is, one or two graph edges away) from his hiding place should be marked with some
    telltale signs: his blood stains.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 独角兽已经是你犯罪的伙伴一段时间了，所以你非常了解他的行事风格。他总是在使用任何新的藏身之处之前，会仔细地侦察。而且由于他受伤了，任何距离他的藏身之处一两个街区（即一两个图边）的地方都应该有一些明显的迹象：他的血迹。
- en: A problem is that he still has his trusty AK-47, while you have only a handgun
    with a single bullet. If you’re going to take him out, you’ll need to be absolutely
    sure you’ve tracked him down. You’ll need to charge into his hideout and shoot
    him down immediately, and you’ll have only one chance to pull this off.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是他仍然有他可靠的AK-47，而你只有一把手枪和一颗子弹。如果你想除掉他，你必须绝对确定你已经追踪到了他。你需要冲进他的藏身之处并立即射击他，而你只有一次机会来完成这个任务。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780468.png.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780468.png.jpg)'
- en: Unfortunately, you and the Wumpus aren’t the only criminals in this town. The
    most feared outlaw group in Congestion City is the Gruesome Glowworm Gang. These
    guys are a band of ruthless kidnappers. If you run into them, they will kidnap
    you, beat you up, rob you, blindfold you, and then kick you out of their car and
    leave you in some random part of town.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，你和独角兽并不是这个镇上唯一的罪犯。在拥堵城中最令人畏惧的匪帮是恐怖的萤火虫团伙。这些人是一群无情的绑架犯。如果你遇到他们，他们会绑架你，打你，抢你的东西，蒙上你的眼睛，然后把你从他们的车里踢出来，把你留在这个城镇的某个随机地方。
- en: Luckily, they can be avoided if you know to keep an eye out for their glowing
    thoraxes (hence their name). If you see some blinking lights, you know that these
    guys are one street away from your current location. Also, you know the gang has
    exactly three separate teams that work the city from three separate locations.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，如果你知道留意他们发光的胸甲（因此得名），就可以避免他们。如果你看到一些闪烁的灯光，你就知道这些人离你现在的位置只有一条街的距离。此外，你知道这个团伙有
    exactly three 个独立的团队，分别从三个不同的地点管理这个城市。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779895.png.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779895.png.jpg)'
- en: Finally, you still need to contend with the cops. You know they’ve probably
    set up some roadblocks in town to try to catch you and the Wumpus. You should
    still be able to visit any location in Congestion City, but you need to be careful
    which streets you travel. (In other words, the cops will catch you if you travel
    along the wrong edge.) Unfortunately, you don’t know how many of these roadblocks
    there may be.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还需要应对警察。你知道他们可能已经在镇上设置了路障试图抓住你和独角兽。你应该仍然可以访问拥堵城的任何地方，但你需要小心你走的街道。（换句话说，如果你沿着错误的边走，警察就会抓住你。）不幸的是，你不知道可能有多少这样的路障。
- en: As you can see, finding the Wumpus and getting back your money and car will
    be tough. If you think you’re Lisp alien enough to take on the Wumpus, then let’s
    write this game and hunt him down!
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，找到独角兽并找回你的钱和车将会很困难。如果你认为自己足够像Lisp外星人，可以挑战独角兽，那么让我们编写这个游戏并追踪他吧！
- en: Defining the Edges of Congestion City
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义拥堵城的边界
- en: The map of Congestion City will be an undirected graph with data associated
    with each node stored in the variable `*congestion-city-nodes*`. The possible
    data at each node will include the presence of the Wumpus, a Glowworm team, and
    various danger signs.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 拥堵城的地图将是一个无向图，每个节点存储在变量 `*congestion-city-nodes*` 中的数据。每个节点可能的数据包括独角兽的存在、萤火虫团队和各种危险标志。
- en: 'A set of edges stored in `*congestion-city-edges*` will connect the nodes,
    and data linked to these edges will alert us to the presence of any police roadblocks.
    We declare these and other global variables at the top of our program using `defparameter`:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `*congestion-city-edges*` 中的边集将连接节点，与这些边相关联的数据将提醒我们任何警察路障的存在。我们使用 `defparameter`
    在程序顶部声明这些和其他全局变量：
- en: '[PRE130]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We first load our graph utilities with the `load` command ![](httpatomoreillycomsourcenostarchimages783564.png),
    which evaluates all the code in *graph-util.lisp* (which we created in the previous
    chapter) so the graph utility functions will be available. Notice that Congestion
    City will have 30 locations ![](httpatomoreillycomsourcenostarchimages783562.png)
    (nodes, defined with `*node-num*`), 45 edges ![](httpatomoreillycomsourcenostarchimages783560.png)
    (roads, defined with `*edge-num*`), and 3 worm teams ![](httpatomoreillycomsourcenostarchimages783554.png)
    (defined with `*worm-num*`). Each street will have a 1-in-15 chance ![](httpatomoreillycomsourcenostarchimages783510.png)
    of containing a roadblock (defined with `*cop-odds*`).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `load` 命令加载我们的图工具！[](httpatomoreillycomsourcenostarchimages783564.png)，这将评估
    *graph-util.lisp*（我们在上一章中创建的）中的所有代码，因此图工具函数将可用。注意，拥堵城市将有 30 个位置！[](httpatomoreillycomsourcenostarchimages783562.png)（节点，使用
    `*node-num*` 定义），45 条边！[](httpatomoreillycomsourcenostarchimages783560.png)（道路，使用
    `*edge-num*` 定义），以及 3 个蠕虫团队！[](httpatomoreillycomsourcenostarchimages783554.png)（使用
    `*worm-num*` 定义）。每条街道将有 1/15 的机会！[](httpatomoreillycomsourcenostarchimages783510.png)包含一个路障（使用
    `*cop-odds*` 定义）。
- en: Generating Random Edges
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机边
- en: 'Next, we create a random list of edges to connect all the nodes:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个随机边列表来连接所有节点：
- en: '[PRE131]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: First, we declare the `random-node` function ![](httpatomoreillycomsourcenostarchimages783564.png),
    which returns a random node identifier. It uses the `random` function, which returns
    a random natural number less than the integer you pass to it. Since we’re going
    to be showing the node identifiers in our user interface, we use the `1+` function
    to number our nodes 1 through 30 (the upper limit because the `*node-num*` variable
    is set to `30`), instead of 0 through 29.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明 `random-node` 函数！[](httpatomoreillycomsourcenostarchimages783564.png)，它返回一个随机节点标识符。它使用
    `random` 函数，该函数返回小于您传递给它的整数的随机自然数。由于我们将在用户界面中显示节点标识符，我们使用 `1+` 函数将节点编号编号为 1 到
    30（上限，因为 `*node-num*` 变量设置为 `30`），而不是 0 到 29。
- en: The `make-edge-list` function ![](httpatomoreillycomsourcenostarchimages783560.png)
    generates the actual list of random edges. It uses the `loop` command to loop
    `*edge-num*` times ![](httpatomoreillycomsourcenostarchimages783554.png), and
    then collects the requisite number of edges ![](httpatomoreillycomsourcenostarchimages783510.png).
    We’ll take a closer look at the `loop` command in the next section. The graph
    of the city is undirected, so this function uses a helper function, `edge-pair`
    ![](httpatomoreillycomsourcenostarchimages783562.png), to create *two* directed
    edges between the randomly selected nodes. This extra step makes sense once you
    remember that an undirected graph is the same as a directed graph, with two opposing
    directed edges mirroring each undirected edge. (When we build our edges into an
    alist later in this chapter, this step will ensure that the list is properly formed.)
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-edge-list` 函数！[](httpatomoreillycomsourcenostarchimages783560.png)生成实际的随机边列表。它使用
    `loop` 命令循环 `*edge-num*` 次！[](httpatomoreillycomsourcenostarchimages783554.png)，然后收集所需的边数！[](httpatomoreillycomsourcenostarchimages783510.png)。我们将在下一节中更详细地了解
    `loop` 命令。城市的图是无向的，因此这个函数使用辅助函数 `edge-pair`！[](httpatomoreillycomsourcenostarchimages783562.png)在随机选择的节点之间创建
    *两个* 有向边。这一额外步骤一旦记住无向图与有向图相同，就像两个相反的有向边镜像每一条无向边一样，就很有意义了。（当我们在本章的后面将边构建到 alist
    中时，这一步骤将确保列表正确形成。）'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781068.png.jpg)'
  id: totrans-747
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781068.png.jpg)'
- en: 'Let’s try the `make-edge-list` function in the CLISP REPL:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 CLISP REPL 中尝试使用 `make-edge-list` 函数：
- en: '[PRE132]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You see the pairs of node numbers that make up the edges. This list of edge
    pairs will form the skeleton of the Congestion City road system.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到构成边的节点编号对。这个边对列表将形成拥堵城市道路系统的骨架。
- en: Looping with the loop Command
  id: totrans-751
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用循环命令进行循环
- en: Our `make-edge-list` function employs the powerful `loop` command, which can
    be used to loop over various types of data. We’ll be looking at `loop` in detail
    in [Chapter 10](ch11.html "Chapter 10. Looping with the loop Command"). However,
    our game uses `loop` a few times, so let’s consider some simple examples to clarify
    how it works.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`make-edge-list`函数使用了强大的`loop`命令，它可以用来遍历各种类型的数据。我们将在[第10章](ch11.html "第10章。使用loop命令循环")中详细讨论`loop`。然而，我们的游戏使用了`loop`几次，所以让我们考虑一些简单的例子来阐明它是如何工作的。
- en: 'One handy thing you can do with `loop` is create a list of numbers. For instance,
    the following command will create a list of 10 ones:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`loop`可以做的方便事情之一是创建一个数字列表。例如，以下命令将创建一个包含10个1的列表：
- en: '[PRE133]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Within the `loop` command, we specify how many times to `repeat`, and then specify
    an object to `collect` with every loop (in this case, the number 1).
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loop`命令中，我们指定要重复的次数，然后指定每次循环要收集的对象（在这种情况下，是数字1）。
- en: 'Sometimes, we want to keep a running count as we’re looping. We can do this
    with the following syntax:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望在循环过程中保持一个运行计数。我们可以使用以下语法来完成：
- en: '[PRE134]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this example, we are saying that `n` should loop from 1 to 10\. Then we `collect`
    each `n` and return it as a list.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们说`n`应该从1循环到10。然后我们`collect`每个`n`并将其作为列表返回。
- en: 'Actually, we can put any Lisp code in the `collect` part of the loop. In the
    following example, we add 100 as we do our collecting:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以在循环的`collect`部分放置任何Lisp代码。在以下示例中，我们在收集时添加了100：
- en: '[PRE135]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Preventing Islands
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止岛屿
- en: We now can generate random edges. Of course, if we just connect random nodes
    with random edges, there’s no guarantee that all of Congestion City will be connected
    because of all that randomness. For example, some parts of the city might form
    an island, with no connections to the main road system.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成随机边。当然，如果我们只是用随机边连接随机节点，由于随机性，我们无法保证整个拥堵城市的所有节点都连接在一起。例如，城市的某些部分可能形成一个岛屿，没有连接到主道路系统。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782588.png.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/782588.png.jpg)'
- en: 'To prevent this, we’ll take our list of edges, find unconnected nodes, and
    connect these islands to the rest of the city network using this code:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我们将我们的边列表，找到未连接的节点，并使用以下代码将这些岛屿连接到城市网络的其他部分：
- en: '[PRE136]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: First, we declare a utility function called `direct-edges` ![](httpatomoreillycomsourcenostarchimages783564.png),
    which finds all the edges in an edge list that start from a given node. It does
    this by creating a new list with all edges removed (using `remove-if-not` ![](httpatomoreillycomsourcenostarchimages783562.png))
    that don’t have the current node in the `car` position.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一个名为`direct-edges`的实用函数 ![http://atomoreilly.com/source/nostarch/images/783564.png]，它找到边列表中所有从给定节点开始的边。它是通过创建一个新的列表，使用`remove-if-not`
    ![http://atomoreilly.com/source/nostarch/images/783562.png] 删除所有不在`car`位置包含当前节点的边来做到这一点的。
- en: To find islands, we write the `get-connected` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    This function takes an edge list and a source node and builds a list of all nodes
    connected to that node, even if it requires walking across multiple edges.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到岛屿，我们编写了`get-connected`函数 ![http://atomoreilly.com/source/nostarch/images/783560.png]。这个函数接受一个边列表和一个源节点，并构建一个列表，其中包含与该节点连接的所有节点，即使需要跨越多个边。
- en: The usual way to find connected nodes is to start a `visited` list ![](httpatomoreillycomsourcenostarchimages783554.png),
    and then perform a search along connected nodes, starting with the source node.
    Newly found nodes are added to the visited list with the `push` command ![](httpatomoreillycomsourcenostarchimages783510.png).
    We also traverse all the children of this found node, using `mapc` ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 找到连接节点的常用方法是启动一个`visited`列表 ![http://atomoreilly.com/source/nostarch/images/783554.png]，然后从源节点开始沿着连接节点进行搜索。新找到的节点使用`push`命令
    ![http://atomoreilly.com/source/nostarch/images/783510.png] 添加到已访问列表中。我们还会遍历这个找到节点的所有子节点，使用`mapc`
    ![http://atomoreilly.com/source/nostarch/images/783544.png]。
- en: If, on the other hand, we encounter a node that has already been visited, we
    know we can ignore it. Once the search is complete, the `visited` list will consist
    of all connected nodes.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到一个已经被访问过的节点，我们知道我们可以忽略它。一旦搜索完成，`visited`列表将包含所有连接的节点。
- en: Now that we have a function for finding nodes that are connected, we can use
    it to create a function that will find all the islands in our graph. The `find-islands`
    function first defines a local function, called `find-island` ![](httpatomoreillycomsourcenostarchimages783556.png).
    This function checks which nodes are connected to the first node in our list of
    nodes using the `connected` function. It then subtracts these nodes from the full
    list of nodes using the `set-difference` function. (`set-difference` takes two
    lists, and returns all items that are in the first list but not the second.)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个用于查找连接节点的函数，我们可以使用它来创建一个函数，该函数将找到我们图中的所有岛屿。`find-islands`函数首先定义一个局部函数，称为`find-island`
    ![http://atomoreilly.com/source/nostarch/images/783556.png]。这个函数使用`connected`函数检查哪些节点连接到我们节点列表中的第一个节点。然后它使用`set-difference`函数从完整节点列表中减去这些节点。（`set-difference`接受两个列表，并返回第一个列表中但不在第二个列表中的所有项。）
- en: Any remaining nodes are deemed unconnected. If any unconnected node exists ![](httpatomoreillycomsourcenostarchimages783566.png),
    we call the `find-islands` function again recursively to find additional islands.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 任何剩余的节点都被认为是未连接的。如果存在任何未连接的节点 ![http://atomoreilly.com/source/nostarch/images/783566.png]，我们再次递归地调用`find-islands`函数以找到额外的岛屿。
- en: Once we’ve found all the islands, we need a way of bridging them together. This
    is the job of the `connect-with-bridges` function. It returns a list of additional
    edges that join all the islands together. To do this, it takes the list of islands
    and checks if there is a `cdr` in this list ![](httpatomoreillycomsourcenostarchimages783498.png).
    If there is, it means there are at least two land masses, which can be connected
    with a bridge. It uses the `edge-pair` function to create this bridge, and then
    calls itself recursively on the tail of the island list, in case additional bridges
    are needed.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了所有岛屿，我们需要一种方法将它们连接起来。这是`connect-with-bridges`函数的工作。它返回一个额外的边列表，将这些岛屿连接起来。为此，它检查岛屿列表中是否存在`cdr`
    ![http://atomoreilly.com/source/nostarch/images/783498.png]。如果存在，这意味着至少有两个陆地，可以用桥梁连接。它使用`edge-pair`函数创建这个桥梁，然后对岛屿列表的尾部递归地调用自身，以防需要额外的桥梁。
- en: Finally, we tie all of our island prevention functions together using the function
    `connect-all-islands` ![](httpatomoreillycomsourcenostarchimages783062.png). It
    uses `find-islands` to find all the land masses, and then calls `connect-with-bridges`
    to build appropriate bridges. It then appends these bridges to the initial list
    of edges to produce a final, fully connected land mass.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用函数`connect-all-islands` ![http://atomoreilly.com/source/nostarch/images/783062.png]
    将所有岛屿预防函数连接起来。它使用`find-islands`来找到所有陆地，然后调用`connect-with-bridges`来构建适当的桥梁。然后它将这些桥梁附加到初始边列表中，以产生一个最终、完全连接的陆地。
- en: Building the Final Edges for Congestion City
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为拥堵城市构建最终边
- en: 'To complete our edges for Congestion City, we need to convert the edges from
    an edge list into an alist. We also will add the police roadblocks, which will
    appear randomly on some of the edges. For these tasks, we will create the `make-city-edges`,
    `edges-to-alist`, and `add-cops` functions:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成拥堵城市的边，我们需要将边从边列表转换为alist。我们还将添加警察路障，这些路障将随机出现在一些边上。对于这些任务，我们将创建`make-city-edges`、`edges-to-alist`和`add-cops`函数：
- en: '[PRE137]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: These are the most cumbersome functions in Grand Theft Wumpus. Let’s take a
    closer look at them.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是《大盗乌普苏斯》中最繁琐的函数。让我们更仔细地看看它们。
- en: The make-city-edges Function
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`make-city-edges`函数'
- en: First, the `make-city-edges` function creates a list of nodes, using a `loop`
    ![](httpatomoreillycomsourcenostarchimages783564.png). (This is simply a list
    of numbers from 1 to `*node-num*`.) Next, it creates a random (but fully connected)
    edge list by calling the `make-edge-list` and `connect-edge-list` functions ![](httpatomoreillycomsourcenostarchimages783562.png).
    This result is stored in the `edge-list` variable. It then creates a random list
    of edges that contains `cops` ![](httpatomoreillycomsourcenostarchimages783560.png).
    We define these variables with the `let*` command, which allows us to reference
    previously defined variables.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`make-city-edges`函数创建一个节点列表，使用一个`loop` ![http://atomoreilly.com/source/nostarch/images/783564.png]。（这只是一个从1到`*node-num*`的数字列表。）接下来，它通过调用`make-edge-list`和`connect-edge-list`函数
    ![http://atomoreilly.com/source/nostarch/images/783562.png] 创建一个随机（但完全连接）的边列表。这个结果存储在`edge-list`变量中。然后它创建一个包含`cops`
    ![http://atomoreilly.com/source/nostarch/images/783560.png] 的随机边列表。我们使用`let*`命令定义这些变量，这使得我们可以引用先前定义的变量。
- en: 'The following example shows the difference between defining variables with
    `let` and `let*`:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了使用 `let` 和 `let*` 定义变量之间的区别：
- en: '[PRE138]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: As you can see, `let` won’t allow you to refer to other defined variables (the
    variable `b` can’t reference the value of `a`). When defining variables with `let*`,
    on the other hand, this kind of reference is allowed. For our purposes, using
    `let*` allows our definition of `cops` ![](httpatomoreillycomsourcenostarchimages783560.png)
    to contain a reference to `edge-list`.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`let` 不允许您引用其他已定义的变量（变量 `b` 不能引用 `a` 的值）。另一方面，当使用 `let*` 定义变量时，这种引用是允许的。对于我们的目的，使用
    `let*` 允许我们的 `cops` ![图片](httpatomoreillycomsourcenostarchimages783560.png) 定义包含对
    `edge-list` 的引用。
- en: Once we’ve created the edge list and determined where the cops are, we need
    to convert our edge list into an alist and add the cops to it ![](httpatomoreillycomsourcenostarchimages783554.png).
    The edges are converted to an alist with the `edges-to-alist` function, and the
    cops are added with the `add-cops` function.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了边列表并确定了警察的位置，我们需要将我们的边列表转换为 alist 并向其中添加警察 ![图片](httpatomoreillycomsourcenostarchimages783554.png)。边通过
    `edges-to-alist` 函数转换为 alist，警察通过 `add-cops` 函数添加。
- en: The edges-to-alist Function
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边到 alist 函数
- en: 'The `edges-to-alist` function converts a list of edges into an alist of edges.
    For example, assume we have the following city, with only three locations and
    two edges connecting those locations:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`edges-to-alist` 函数将边列表转换为边 alist。例如，假设我们有一个以下城市，只有三个位置和两条连接这些位置的边：'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780974.png.jpg)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780974.png.jpg)'
- en: We would describe this using an edge list as `'((1 . 2) (2 . 1) (2 . 3) (3 .
    2))`. Remember that each of the edges is repeated, since the edges are undirected
    and can be used in both directions. If we described this same city as an alist,
    what would that look like?
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会用边列表 `'((1 . 2) (2 . 1) (2 . 3) (3 . 2))' 来描述这一点。记住，每条边都是重复的，因为边是无向的，可以在两个方向上使用。如果我们用
    alist 来描述同一个城市，那会是什么样子？
- en: Remember that an alist is a list that lets us look up a key (in this example,
    one of the three nodes in our city) and find the information associated with that
    key (in this case, a list of the roads connected to it). For this small city,
    the alist would be `'((1 (2)) (2 (1) (3)) (3 (2)))`.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，alist 是一个列表，它允许我们查找一个键（在这个例子中，是我们城市中的三个节点之一）并找到与该键关联的信息（在这种情况下，是与它相连的道路列表）。对于这个小型城市，alist
    将是 `'((1 (2)) (2 (1) (3)) (3 (2)))'。
- en: To build this alist, the `edges-to-list` function first `mapcar`s ![](httpatomoreillycomsourcenostarchimages783510.png)
    over the nodes found in the edge list. To build the list of nodes, we use the
    `remove-duplicates` function, which removes duplicate items from a list. By default,
    `remove-duplicates` uses the `eql` function to check for equality, though it also
    allows you to choose a different test function using the :test keyword parameter.
    Since we’re checking for equality of cons pairs in our `make-city-edges` function,
    we set `:test` to `#'equal` ![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个 alist，`edges-to-list` 函数首先使用 `mapcar` ![图片](httpatomoreillycomsourcenostarchimages783510.png)
    对边列表中找到的节点进行映射。为了构建节点列表，我们使用 `remove-duplicates` 函数，该函数从列表中删除重复项。默认情况下，`remove-duplicates`
    使用 `eql` 函数来检查相等性，尽管它还允许你使用 `:test` 关键字参数选择不同的测试函数。由于我们在 `make-city-edges` 函数中检查的是
    cons 对的相等性，我们将 `:test` 设置为 `#'equal` ![图片](httpatomoreillycomsourcenostarchimages783556.png)。
- en: Within this outer `mapcar` ![](httpatomoreillycomsourcenostarchimages783510.png),
    we use another `mapcar` ![](httpatomoreillycomsourcenostarchimages783544.png)
    to map across all the `direct-edges` to this node. Together, these nested `mapcar`
    functions allow `edges-to-alist` to convert the edges of a city into an alist.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个外部的 `mapcar` ![图片](httpatomoreillycomsourcenostarchimages783510.png) 中，我们使用另一个
    `mapcar` ![图片](httpatomoreillycomsourcenostarchimages783544.png) 来映射所有指向该节点的 `direct-edges`。这些嵌套的
    `mapcar` 函数共同允许 `edges-to-alist` 将城市的边转换为 alist。
- en: The add-cops Function
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加警察函数
- en: When we wrote the `make-city-edges` function, we randomly marked some of the
    edges to show that they have cops on them ![](httpatomoreillycomsourcenostarchimages783554.png).
    We are now going to use this list of cop edges to mark the edges in our alist
    that contain cops. This is the job of the `add-cops` function.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 `make-city-edges` 函数时，我们随机标记了一些边以显示它们上面有警察！![图片](httpatomoreillycomsourcenostarchimages783554.png)。我们现在将使用这个警察边的列表来标记我们
    alist 中的包含警察的边。这是 `add-cops` 函数的工作。
- en: To do this, we use nested `mapcar` commands to map across the edges within each
    node ![](httpatomoreillycomsourcenostarchimages783566.png)![](httpatomoreillycomsourcenostarchimages783498.png).
    We then check whether there are any cops on a given edge, using the `intersection`
    function ![](httpatomoreillycomsourcenostarchimages783062.png). (The `intersection`
    function tells us which items are shared between two lists.)
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用嵌套的`mapcar`命令映射每个节点内的边 ![httpatomoreillycomsourcenostarchimages783566.png]![httpatomoreillycomsourcenostarchimages783498.png]。然后我们使用`intersection`函数
    ![httpatomoreillycomsourcenostarchimages783062.png]检查给定边是否有警察。（`intersection`函数告诉我们两个列表之间共享哪些项目。）
- en: 'To understand exactly what the `add-cops` function is doing, it will help to
    once again imagine our city with only three locations and two streets. In this
    example, one of the streets has cops on it:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 要确切了解`add-cops`函数正在做什么，再次想象我们的城市只有三个位置和两条街道将有所帮助。在这个例子中，其中一条街道上有警察：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783078.png.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783078.png.jpg)'
- en: 'The generated alist for this city, created by `add-cops`, would look like this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 由`add-cops`创建的此城市的生成alist将看起来像这样：
- en: '[PRE139]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This is actually a *nested* alist. The outer alist is organized based on the
    first node, and the inner alists are organized based on the second node.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个*嵌套*的alist。外层alist是根据第一个节点组织的，内层alist是根据第二个节点组织的。
- en: With the edges in this format, we can easily find all edges connected to a given
    node by calling `(cdr (assoc node1 edges))`. To see if a given edge contains cops,
    we can call `(cdr (assoc node2 (cdr (assoc node1 edges))))`, which goes down two
    levels to grab the actual data linked to a specific edge between two nodes. (One
    additional benefit of using this nested alist format is that it is fully compatible
    with our graph libraries—a feature that we’ll take advantage of shortly.)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种格式的边，我们可以通过调用`(cdr (assoc node1 edges))`轻松找到与给定节点相连的所有边。要检查给定边是否包含警察，我们可以调用`(cdr
    (assoc node2 (cdr (assoc node1 edges))))`，这将向下两级以获取与两个节点之间特定边链接的实际数据。（使用这种嵌套alist格式的另一个额外好处是它与我们的图库完全兼容——这是一个我们将很快利用的特性。）
- en: Building the Nodes for Congestion City
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建拥堵城市的节点
- en: Now we’ll build an alist for the nodes in our city. These nodes may contain
    the Wumpus or the Glowworms, or they might contain various clues, such as blood,
    lights, or sirens.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的城市中的节点构建一个alist。这些节点可能包含Wumpus或萤火虫，或者它们可能包含各种线索，如血液、灯光或警报声。
- en: Most of the clues in our game are based on proximity to another node, so we
    need to write some functions that tell us if two nodes are one node apart in the
    city graph. The `neighbors` function looks up the node’s neighbors using the alist
    of edges. If the second node is in that list, we know we’re one away.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的大多数线索都是基于另一个节点的邻近性，因此我们需要编写一些函数来告诉我们两个节点在图中的城市中是否相隔一个节点。`neighbors`函数通过边表的alist查找节点的邻居。如果第二个节点在该列表中，我们知道我们相隔一个节点。
- en: '[PRE140]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: First, this function looks up the first node (`a`) in the alist of edges with
    `neighbors`. Then it uses `member` to see if the other node (`b`) is among these
    nodes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数在边的alist中通过`neighbors`查找第一个节点（`a`）。然后它使用`member`来查看另一个节点（`b`）是否在这些节点中。
- en: 'The blood stain clues for the Wumpus can also be seen from two nodes away.
    We can write a second function for checking two nodes like this:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个节点距离处也可以看到Wumpus的血迹线索。我们可以为这样的两个节点编写第二个检查函数：
- en: '[PRE141]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: First, we check if we are within one node of our goal ![](httpatomoreillycomsourcenostarchimages783564.png),
    since if we’re within one, we’re also within two. Next, we extract all the nodes
    that are one away ![](httpatomoreillycomsourcenostarchimages783560.png) (similar
    to what we did in the `within-one` function). Finally, we check if any of *these*
    new nodes are within one ![](httpatomoreillycomsourcenostarchimages783562.png),
    which would make them within two of the original node.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查我们是否在我们的目标节点内一个节点范围内 ![httpatomoreillycomsourcenostarchimages783564.png]，因为如果我们在一个节点内，我们也在两个节点内。接下来，我们提取所有一个节点范围内的节点
    ![httpatomoreillycomsourcenostarchimages783560.png]（类似于我们在`within-one`函数中做的）。最后，我们检查这些新节点中是否有任何节点在一个节点范围内
    ![httpatomoreillycomsourcenostarchimages783562.png]，这将使它们在原始节点两个节点范围内。
- en: 'Now that we have those utility functions, let’s write the function that builds
    the final node alist (basically, the final map of our city.) Here’s the listing:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些实用函数，让我们编写构建最终节点alist的函数（基本上，这是我们城市的最终地图。）以下是代码列表：
- en: '[PRE142]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `make-city-nodes` function first picks random nodes for the Wumpus ![](httpatomoreillycomsourcenostarchimages783564.png)
    and the Glowworms ![](httpatomoreillycomsourcenostarchimages783562.png), and then
    it uses `loop` ![](httpatomoreillycomsourcenostarchimages783560.png) to run through
    the node numbers. As it runs through the nodes, it builds a list describing each
    node in the city, `appended` together from various sources ![](httpatomoreillycomsourcenostarchimages783554.png).
    By using `append`, each part of the code that describes these nodes (and is within
    the body of the `append`) can choose to add zero, one, or multiple items to the
    description, creating its own child lists with zero, one, or multiple items.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`make-city-nodes` 函数首先为乌普斯 ![图片](httpatomoreillycomsourcenostarchimages783564.png)
    和萤火虫 ![图片](httpatomoreillycomsourcenostarchimages783562.png) 随机选择节点，然后使用 `loop`
    ![图片](httpatomoreillycomsourcenostarchimages783560.png) 运行节点编号。在运行节点时，它构建一个描述城市中每个节点的列表，`appended`
    从各种来源 ![图片](httpatomoreillycomsourcenostarchimages783554.png)。通过使用 `append`，描述这些节点（且在
    `append` 的主体内）的代码部分可以选择添加零、一个或多个项目到描述中，创建自己的子列表，包含零、一个或多个项目。'
- en: At the front of the list, we put the node name, `n` ![](httpatomoreillycomsourcenostarchimages783554.png).
    If the Wumpus is at the current node, we add the word *Wumpus* ![](httpatomoreillycomsourcenostarchimages783510.png)
    (but wrapped in a list, as we just described). If we’re within two nodes of the
    Wumpus, we show its blood ![](httpatomoreillycomsourcenostarchimages783544.png).
    If the node has a Glowworm gang, we show it next ![](httpatomoreillycomsourcenostarchimages783556.png),
    and if the Glowworm gang is one node away, we show its lights ![](httpatomoreillycomsourcenostarchimages783566.png).
    Finally, if an edge from the node contains cops, we indicate that sirens can be
    heard ![](httpatomoreillycomsourcenostarchimages783498.png).
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的开头，我们放置节点名称，`n` ![图片](httpatomoreillycomsourcenostarchimages783554.png)。如果乌普斯位于当前节点，我们添加单词
    *乌普斯* ![图片](httpatomoreillycomsourcenostarchimages783510.png)（但用列表包裹，正如我们刚才描述的那样）。如果我们距离乌普斯两个节点以内，我们显示它的血迹
    ![图片](httpatomoreillycomsourcenostarchimages783544.png)。如果节点有一个萤火虫团伙，我们显示它 ![图片](httpatomoreillycomsourcenostarchimages783556.png)，如果萤火虫团伙在一个节点之外，我们显示它的灯光
    ![图片](httpatomoreillycomsourcenostarchimages783566.png)。最后，如果从节点的边包含警察，我们表明可以听到警笛声
    ![图片](httpatomoreillycomsourcenostarchimages783498.png)。
- en: 'To check for the sirens clue, we simply grab the edges with `(cdr (assoc n
    edges))` and see if some of these nodes have a value in the cdr. The `''cops`
    symbol would be attached to the edges at the `cdr`. Since we have only one data
    point for edges in this game, looking for the presence of a `cdr` is an adequate
    check for the presence of cops. For example, if we use our earlier example of
    an alist with cops on it:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查警笛线索，我们只需获取 `(cdr (assoc n edges))` 的边，并查看这些节点中是否有 `cdr` 中的值。`'cops` 符号将附加到边的
    `cdr` 上。由于我们在这个游戏中只有一条关于边的数据点，寻找 `cdr` 的存在是检查警察存在的一个充分的检查。例如，如果我们使用我们之前有警察的 alist
    示例：
- en: '[PRE143]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You can see that if an edge in the list has cops, such as here ![](httpatomoreillycomsourcenostarchimages783562.png),
    the `cdr` will lead to a non-`nil` value. An edge without cops ![](httpatomoreillycomsourcenostarchimages783564.png)
    will have a `cdr` that is `nil`.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果列表中的边有警察，例如这里 ![图片](httpatomoreillycomsourcenostarchimages783562.png)，`cdr`
    将指向一个非 `nil` 的值。没有警察的边 ![图片](httpatomoreillycomsourcenostarchimages783564.png)
    将有一个 `cdr` 是 `nil`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782874.png.jpg)'
  id: totrans-815
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782874.png.jpg)'
- en: Initializing a New Game of Grand Theft Wumpus
  id: totrans-816
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化《大盗乌普斯》新游戏
- en: 'With our graph construction stuff out of the way, we can write a simple function
    that initializes a brand-new game of Grand Theft Wumpus:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完我们的图构建工具之后，我们可以编写一个简单的函数来初始化一个全新的《大盗乌普斯》游戏：
- en: '[PRE144]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'There are two new functions here. One, the `find-empty-node` function ![](httpatomoreillycomsourcenostarchimages783564.png),
    ensures that the player doesn’t end up on top of a bad guy right at the beginning
    of the game. Here’s the code for that function:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个新函数。一个，`find-empty-node` 函数 ![图片](httpatomoreillycomsourcenostarchimages783564.png)，确保玩家在游戏开始时不会直接站在坏蛋身上。以下是该函数的代码：
- en: '[PRE145]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The `find-empty-node` function is pretty simple. First, it picks a random node
    ![](httpatomoreillycomsourcenostarchimages783564.png) to consider as the player’s
    starting position. Then it checks whether it is a completely empty node ![](httpatomoreillycomsourcenostarchimages783562.png).
    If there’s stuff in that node, it simply calls itself again, trying another random
    spot ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '`find-empty-node` 函数相当简单。首先，它随机选择一个节点！[](httpatomoreillycomsourcenostarchimages783564.png)作为玩家的起始位置。然后检查它是否是一个完全空的节点！[](httpatomoreillycomsourcenostarchimages783562.png)。如果节点里有东西，它就简单地再次调用自己，尝试另一个随机位置！[](httpatomoreillycomsourcenostarchimages783560.png)。'
- en: Warning
  id: totrans-822
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: If you ever decide to modify the game and make it more crowded with bad guys,
    you could end up in a situation where no empty nodes exist. In that case, this
    function will search forever and lock up your Lisp REPL, since we didn’t put in
    any checks to detect this situation.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定修改游戏并使其充满坏人，你可能会陷入一个没有空节点的情况。在这种情况下，这个函数将永远搜索并锁定你的 Lisp REPL，因为我们没有添加任何检查来检测这种情况。
- en: The other new function in our `new-game` command is `draw-city`, which we’ll
    write next.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `new-game` 命令中的另一个新函数是 `draw-city`，我们将在下一节中编写。
- en: Drawing a Map of Our City
  id: totrans-825
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制我们城市的地图
- en: 'We’re finally ready to draw a map of our new city. We’re using a standard format
    for our graph data, so writing this function is a breeze:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好绘制我们新城市的地图了。我们使用标准的图形数据格式，因此编写这个函数轻而易举：
- en: '[PRE146]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: We created the `ugraph->png` function in the previous chapter, as part of our
    graph library.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中创建了 `ugraph->png` 函数，作为我们的图形库的一部分。
- en: 'Now call `(new-game)` from the REPL, and open the *city.dot.png* picture in
    your web browser:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从 REPL 中调用 `(new-game)`，并在你的网络浏览器中打开 *city.dot.png* 图片：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783532.png.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages783532.png.jpg)'
- en: Note
  id: totrans-831
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since every city map created by our code is unique, your map will look completely
    different from the one in this picture.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们用代码创建的每个城市地图都是唯一的，所以你的地图将完全不同于这张图片。
- en: Finally, we can marvel at the results of our urban planning!
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以惊叹于我们城市规划的结果！
- en: Drawing a City from Partial Knowledge
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从部分知识绘制城市
- en: Of course, it’s awfully boring to hunt something if you already know where it
    is before the hunt starts. To solve this problem, we want a map of the city that
    shows only the nodes that we’ve visited so far. To that end, we use a global list
    called `*visited-nodes*` that is initially set to the player’s position only,
    but which we’ll update as we walk around the city visiting other nodes. Using
    this `*visited-nodes*` variable, we can calculate a smaller graph that includes
    only those parts of the city that are known to us.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在狩猎开始之前就已经知道猎物在哪里，狩猎起来会非常无聊。为了解决这个问题，我们想要一张只显示我们迄今为止访问过的节点的城市地图。为此，我们使用一个名为
    `*visited-nodes*` 的全局列表，最初只设置为玩家的位置，但随着我们在城市中访问其他节点，我们将更新它。使用这个 `*visited-nodes*`
    变量，我们可以计算一个更小的图，只包括我们已知的城市部分。
- en: Known Nodes
  id: totrans-836
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已知节点
- en: 'First, we can build an alist of just the known nodes:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以构建一个只包含已知节点的 alist：
- en: '[PRE147]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: At the bottom of `known-city-nodes`, we need to figure out which nodes we can
    “see” based on where we’ve been. We’ll be able to see all visited nodes ![](httpatomoreillycomsourcenostarchimages783510.png),
    but we also want to track all nodes within one node of a visited node ![](httpatomoreillycomsourcenostarchimages783544.png).
    (We will discuss the `mapcan` function shortly.) We calculate who is “within one”
    using code similar to the previously discussed `within-one` function.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `known-city-nodes` 的底部，我们需要确定我们可以“看到”哪些节点，基于我们去过的地方。我们将能够看到所有已访问的节点！[](httpatomoreillycomsourcenostarchimages783510.png)，但我们还想要跟踪所有位于已访问节点一个节点范围内的节点！[](httpatomoreillycomsourcenostarchimages783544.png)。（我们将在稍后讨论
    `mapcan` 函数。）我们使用类似于之前讨论的 `within-one` 函数的代码来计算“一个节点范围内”的人。
- en: Next, we `mapcar` over this list of relevant nodes, processing each ![](httpatomoreillycomsourcenostarchimages783564.png).
    If the current node is occupied by the player, we mark it with an asterisk ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the node hasn’t been visited yet ![](httpatomoreillycomsourcenostarchimages783562.png),
    we mark it with a question mark ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对这个相关节点列表使用 `mapcar`，处理每个节点！[](httpatomoreillycomsourcenostarchimages783564.png)。如果当前节点被玩家占据，我们用星号标记它！[](httpatomoreillycomsourcenostarchimages783560.png)。如果节点尚未访问过！[](httpatomoreillycomsourcenostarchimages783562.png)，我们用问号标记它！[](httpatomoreillycomsourcenostarchimages783554.png)。
- en: Known Edges
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已知边
- en: 'Now, we need to create an alist stripped of any cop sirens that we haven’t
    reached yet:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个 alist，其中不包含我们尚未到达的任何警察警报：
- en: '[PRE148]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This function is similar to the `known-city-nodes` function. The noteworthy
    line of code is here ![](httpatomoreillycomsourcenostarchimages783564.png) where
    we strip the `cdr` from the edge list for edges so that cops are indicated on
    the map only if we’ve visited the nodes on both ends of an edge containing cops.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 `known-city-nodes` 函数相似。值得注意的是这里的代码行 ![图片](httpatomoreillycomsourcenostarchimages783564.png)，在这里我们从边缘列表中移除了
    `cdr`，这样只有在包含警察的边缘的两端节点都被访问过时，地图上才会显示警察。
- en: The mapcan Function
  id: totrans-845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mapcan` 函数'
- en: The `mapcan` function we used in `known-city-nodes` is a variant of `mapcar`.
    However, unlike `mapcar`, `mapcan` assumes that the values generated by the mapping
    function are all lists that should be appended together. This is useful when there
    isn’t a one-to-one relationship between the items in a list and the result you
    want to generate.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `known-city-nodes` 中使用的 `mapcan` 函数是 `mapcar` 的一个变体。然而，与 `mapcar` 不同，`mapcan`
    假设映射函数生成的值都是应该一起附加的列表。当列表中的项与您想要生成的结果之间不存在一对一关系时，这很有用。
- en: 'For example, suppose we run a burger shop and sell three types of burgers:
    the single, the double, and the double cheese. To convert a list of burgers into
    a list of patties and cheese slices, we could write the following function:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们经营一家汉堡店，并出售三种类型的汉堡：单层汉堡、双层汉堡和双层芝士汉堡。要将汉堡列表转换为肉饼和芝士片的列表，我们可以编写以下函数：
- en: '[PRE149]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Drawing Only the Known Parts of the City
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅绘制城市的已知部分
- en: 'Because we now have functions that can generate the known information about
    nodes and edges, we can write a function that turns this information into a picture,
    as follows:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有可以生成节点和边已知信息的函数，我们可以编写一个将此信息转换为图片的函数，如下所示：
- en: '[PRE150]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Now let’s redefine our `new-game` function to draw the known city when the
    game starts:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新定义 `new-game` 函数，以便在游戏开始时绘制已知的城市：
- en: '[PRE151]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This function is almost exactly the same as the previous version of `new-game`,
    except that we also create a drawing composed only of the known parts of the city
    ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数几乎与 `new-game` 的上一个版本完全相同，除了我们还创建了一个仅由城市的已知部分组成的绘图 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。
- en: 'Now, if we call the `new-game` function from the REPL, we’ll get a new picture
    named *known-city.dot.png* that we can view in our browser. It will look something
    like this:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从 REPL 调用 `new-game` 函数，我们将得到一个名为 *known-city.dot.png* 的新图片，我们可以在浏览器中查看。它看起来可能像这样：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782216.png.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782216.png.jpg)'
- en: Now we’re ready to walk around our map of Congestion City!
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在拥堵城市的地图上漫步了！
- en: Walking Around Town
  id: totrans-858
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在镇上漫步
- en: 'We’ll need two functions for traveling between the nodes in our city: a regular
    `walk` function and one for when we think we’ve found the Wumpus, and we want
    to `charge` that location with our final bullet. Since these two functions are
    very similar, we’ll have both of them delegate the bulk of the work to a common
    `handle-direction` function:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个函数来在城市节点之间旅行：一个常规的 `walk` 函数和一个当我们认为我们找到了 Wumpus 并且我们想要用最后一颗子弹 `charge`
    该位置时的函数。由于这两个函数非常相似，我们将让它们都将大部分工作委托给一个共同的 `handle-direction` 函数：
- en: '[PRE152]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The only difference between these two functions is the flag they pass to `handle-direction`,
    which is set to either `nil` or `t`, depending on the kind of traveling.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的唯一区别是它们传递给 `handle-direction` 的标志，该标志设置为 `nil` 或 `t`，具体取决于旅行的类型。
- en: 'The `handle-direction` function’s main job is to make sure that a move is legal,
    which it does by checking the edges of the city:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle-direction` 函数的主要任务是确保移动是合法的，它通过检查城市的边缘来实现这一点：'
- en: '[PRE153]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: First, this function looks up the legal directions players can move to from
    their current location ![](httpatomoreillycomsourcenostarchimages783564.png).
    It then uses the `pos` the player wants to move to and looks it up in that list
    of possible directions. Once we’ve determined that a direction is legal (that
    is, a node with that number shares an edge with the player’s current position),
    we need to find out what surprises are waiting as the player travels to this new
    place, using the `handle-new-place` function, which we’ll create next ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, we display a helpful error message ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数查找玩家可以从当前位置移动到的合法方向 ![合法方向](httpatomoreillycomsourcenostarchimages783564.png)。然后它使用玩家想要移动到的`pos`，并在可能的方向列表中查找它。一旦我们确定了一个方向是合法的（也就是说，具有该编号的节点与玩家的当前位置共享边），我们就需要找出玩家在前往这个新地方时等待的惊喜，使用我们接下来要创建的`handle-new-place`函数
    ![handle-new-place函数](httpatomoreillycomsourcenostarchimages783562.png)。否则，我们显示一个有用的错误信息
    ![错误信息](httpatomoreillycomsourcenostarchimages783560.png)。
- en: 'Now let’s create the `handle-new-place` function, which gets called when the
    player has traveled to a new place:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建`handle-new-place`函数，该函数在玩家到达新地方时被调用：
- en: '[PRE154]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: First, we retrieve the node the player is traveling to from the alist of nodes
    ![](httpatomoreillycomsourcenostarchimages783564.png). Next, we figure out if
    the node contains a Glowworm gang ![](httpatomoreillycomsourcenostarchimages783562.png).
    We ignore the gang if they’re in a node already visited, because they’ll only
    attack once.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从节点列表中检索玩家正在前往的节点 ![节点列表](httpatomoreillycomsourcenostarchimages783564.png)。接下来，我们确定该节点是否包含萤火虫团伙
    ![萤火虫团伙](httpatomoreillycomsourcenostarchimages783562.png)。如果他们已经在已访问的节点中，我们忽略这个团伙，因为他们只会攻击一次。
- en: Next, the `handle-new-place` function updates `*visited-nodes*` ![](httpatomoreillycomsourcenostarchimages783560.png)(adding
    the new position to the list) and `*player-pos*` ![](httpatomoreillycomsourcenostarchimages783554.png).
    Then it calls `draw-known-city` ![](httpatomoreillycomsourcenostarchimages783510.png)
    again, since we now have a new place we know about.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`handle-new-place`函数更新`*visited-nodes*` ![已访问节点](httpatomoreillycomsourcenostarchimages783560.png)（将新位置添加到列表中）和`*player-pos*`
    ![玩家位置](httpatomoreillycomsourcenostarchimages783554.png)。然后它再次调用`draw-known-city`
    ![绘制已知城市](httpatomoreillycomsourcenostarchimages783510.png)，因为我们现在有一个我们知道的新地方。
- en: Next, it checks to see if there are any cops on the edge ![](httpatomoreillycomsourcenostarchimages783544.png),
    and then whether the Wumpus is at that location ![](httpatomoreillycomsourcenostarchimages783556.png).
    If the player encounters the Wumpus, our `handle-new-place` function needs to
    know whether we were charging the location. If we are charging at the Wumpus,
    we win the game. Otherwise, the Wumpus kills us and the game is over.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它检查边缘是否有警察 ![警察](httpatomoreillycomsourcenostarchimages783544.png)，然后检查Wumpus是否在那个位置
    ![Wumpus](httpatomoreillycomsourcenostarchimages783556.png)。如果玩家遇到Wumpus，我们的`handle-new-place`函数需要知道我们是否正在向该位置进攻。如果我们正在向Wumpus进攻，我们就赢得了游戏。否则，Wumpus会杀死我们，游戏结束。
- en: If, on the other hand, we charge at a location that does not contain the Wumpus,
    we waste our single bullet and we lose the game as well ![](httpatomoreillycomsourcenostarchimages783566.png).
    Finally, if the location has a previously unencountered Glowworm gang, jump to
    a random new location, calling `handle-new-place` recursively ![](httpatomoreillycomsourcenostarchimages783498.png).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们向一个不包含Wumpus的位置进攻，我们会浪费我们的唯一子弹，并且也会输掉游戏 ![子弹](httpatomoreillycomsourcenostarchimages783566.png)。最后，如果该位置有一个之前未遇到的萤火虫团伙，跳转到随机的新位置，递归调用`handle-new-place`
    ![递归调用](httpatomoreillycomsourcenostarchimages783498.png)。
- en: Our game is now complete!
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在完成了！
- en: Let's Hunt Some Wumpus!
  id: totrans-872
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们狩猎一些Wumpus吧！
- en: To play our game, simply enter the traveling commands we created (`walk` and
    `charge`) at the REPL, then switch to your browser and refresh *known-city.dot.png*
    to plan your next move.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 要玩我们的游戏，只需在REPL中输入我们创建的旅行命令（`walk`和`charge`），然后切换到浏览器并刷新*known-city.dot.png*来规划你的下一步。
- en: 'For example, here’s where we left off in our sample game:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们样本游戏中停止的地方：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782820.png.jpg)'
  id: totrans-875
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782820.png.jpg)'
- en: 'Since we have no clues, we know that any of these nodes will be safe to visit.
    Let’s try `(walk 20)`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有线索，我们知道这些节点中的任何一个都是安全的访问。让我们尝试`(walk 20)`：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782246.png.jpg)'
  id: totrans-877
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782246.png.jpg)'
- en: 'Uh oh! There’s blood here. That means the Wumpus must be two nodes away! It
    should still be safe to (`walk 11`) though, because that’s only one node away:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！这里出血了。这意味着无脑怪必须在两个节点之外！尽管只有一个节点之差，但仍然可以安全地(`walk 11`)：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782044.png.jpg)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages782044.png.jpg)'
- en: 'Oh no! One of these streets has a police roadblock. Let’s backtrack with `(walk
    20) (walk 19)`, and then we can try `(walk 7)`:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！这些街道中的一条有警察路障。让我们用`(walk 20) (walk 19)`回溯，然后我们可以尝试`(walk 7)`：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780754.png.jpg)'
  id: totrans-881
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages780754.png.jpg)'
- en: 'Darn! Now we have the Wumpus and some Glowworms nearby. Let’s take a shot in
    the dark and try `(walk 10)`:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 真糟糕！现在我们附近有無腦怪和一些萤火虫。让我们随机射击并尝试`(walk 10)`：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780248.png.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages780248.png.jpg)'
- en: Well, that didn’t help, since there are cops down this path. However, because
    node 10 has only one other unexplored street, we can say with certainty that the
    street between 1 and 10 has cops on it.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这没有帮助，因为这条路有警察。然而，因为节点10只有一个未探索的街道，我们可以肯定地说，1和10之间的街道上有警察。
- en: You can see that it takes some serious thinking to become a master in Grand
    Theft Wumpus! Remember, you can always start a new game, with a new map, by using
    the `new-game` function. Once you’ve tracked down the Wumpus, use the `charge`
    function to attack him.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，要想成为“大盗无脑怪”大师，需要认真思考！记住，你可以通过使用`new-game`函数来开始一个新游戏，拥有新的地图。一旦你追踪到无脑怪，就可以使用`charge`函数攻击它。
- en: If you master the basic version of this game, try increasing the number of nodes,
    edges, cops, and Glowworms for an even greater challenge!
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你掌握了这个游戏的基本版本，可以尝试增加节点、边、警察和萤火虫的数量，以获得更大的挑战！
- en: What You've Learned
  id: totrans-887
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we’ve used graph utilities with Lisp to make a more sophisticated
    game. Along the way, you learned the following:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Lisp的图形工具制作了一个更复杂的游戏。在这个过程中，你学习了以下内容：
- en: The `loop` function allows us to loop across various types of data. It will
    be discussed in more detail in [Chapter 10](ch11.html "Chapter 10. Looping with
    the loop Command").
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`函数允许我们在各种类型的数据上循环。它将在第10章（[第10章。使用loop命令循环](ch11.html "第10章。使用loop命令循环"））中更详细地讨论。'
- en: The `set-difference` function tells you which items are in one list but not
    in another list.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set-difference`函数告诉你哪些项目在一个列表中但不在另一个列表中。'
- en: The `intersection` function tells you which items are shared by lists.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection`函数告诉你哪些项目被列表共享。'
- en: The `remove-duplicates` function removes duplicate items from a list.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove-duplicates`函数从列表中删除重复的项目。'
- en: Chapter 9. Advanced Datatypes and Generic Programming
  id: totrans-893
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。高级数据类型和泛型编程
- en: As you’ve seen so far, a lot can be accomplished in Lisp by using cons cells,
    symbols, strings, and numeric datatypes. As a very mature language, Common Lisp
    contains many more datatypes that move well beyond these basics. In this chapter,
    we will discuss the most useful of these advanced datatypes, including arrays,
    hash tables, and structures.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在Lisp中，通过使用cons单元、符号、字符串和数值数据类型，可以完成很多事情。作为一个非常成熟的语言，Common Lisp包含许多更多类型的数据，这些数据类型远远超出了这些基础知识。在本章中，我们将讨论这些高级数据类型中最有用的，包括数组、哈希表和结构。
- en: Arrays
  id: totrans-895
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: The *Common Lisp array* is very similar to a list. The main advantage of using
    arrays is that they require only a constant amount of time to access a value at
    any specific location. We’ll be discussing what this means shortly.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '*Common Lisp数组*与列表非常相似。使用数组的主要优势是它们只需要常数时间就可以访问任何特定位置上的值。我们将在稍后讨论这意味着什么。'
- en: Working with Arrays
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: 'To create a new array, use the `make-array` command, specifying the array’s
    size:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的数组，请使用`make-array`命令，指定数组的大小：
- en: '[PRE155]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This creates an array of length 3\. In order to indicate that the value created
    is not just a list, Common Lisp prepends a hash mark (#) in front of the array.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个长度为3的数组。为了表明创建的值不仅仅是一个列表，Common Lisp在数组前面加上了井号(#)。
- en: 'To get and set items in an array, use the `aref` function. For example, here’s
    how we get the item at index 1:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取和设置数组中的项目，请使用`aref`函数。例如，以下是如何获取索引为1的项目：
- en: '[PRE156]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Of course, our array is just filled with `nil`s right now, so there’s not much
    worth getting. To set items in the array to more interesting values, use `aref`
    in conjunction with the `setf` command:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的数组现在只是填充了`nil`，所以没有什么值得获取的。要将数组中的项目设置为更有趣的值，请使用`aref`与`setf`命令结合：
- en: '[PRE157]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Although `aref` is usually a command used to *get* a value out of an array,
    when used in this special way indicated in the example, it lets us *set* a value
    in an array, instead. This ability to use the `setf` and `aref` commands together
    shows off a feature in Common Lisp: its support for generic programming. Let’s
    take a closer look at the `setf` command to learn more about how this feature
    works.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`aref`通常是一个用来从数组中**获取**值的命令，但在这个例子中特别指出这种方式时，它允许我们在数组中**设置**值。这种使用`setf`和`aref`命令结合的能力展示了
    Common Lisp 的一个特性：它对泛型编程的支持。让我们更仔细地看看`setf`命令，以了解更多关于这个特性是如何工作的。
- en: Using a Generic Setter
  id: totrans-906
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型设置器
- en: The Common Lisp language is said to support *generic setters*. This means that
    in most cases, the code for *pulling a value out of* a data structure (whether
    an array, list, string, or something else) is identical to the code for *putting
    data into* that same data structure. The `setf` command can be used in conjunction
    with functions that perform getting operations and can use the same functions
    to perform setting operations, instead.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 据说 Common Lisp 语言支持**泛型设置器**。这意味着在大多数情况下，从数据结构（无论是数组、列表、字符串还是其他）中**提取值**的代码与将数据放入相同数据结构的代码是相同的。`setf`命令可以与执行获取操作的函数一起使用，并且可以使用相同的函数来执行设置操作。
- en: 'We’ve already seen that `aref` can be used to get values out of an array, and
    when used with `setf`, it can be used for setting values in the same array. The
    `setf` command can perform this trick in a general way across most of the commands
    in Common Lisp that get items from a data structure. Take, for instance, the following
    example involving a list:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`aref`可以用来从数组中获取值，当与`setf`一起使用时，它可以用来在同一个数组中设置值。`setf`命令可以在 Common Lisp
    中大多数从数据结构获取项的命令中以通用方式执行这个技巧。以下是一个涉及列表的例子：
- en: '[PRE158]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: As you would expect, the expression `(second foo)` returns `B`. But, when we
    pass `(second foo)` to the `setf` command ![](httpatomoreillycomsourcenostarchimages783564.png),
    it somehow knows where the `B` came from, and it is able to treat the expression
    `(second foo)` as if it were a regular variable. Basically, the `setf` command
    asks itself the question, “Where did the item in my first argument originally
    come from?” In this case, the value came from the second item in the list named
    `foo`. Therefore, if we try to `setf` this location, the source variable, `foo`,
    is modified in response.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，表达式`(second foo)`返回`B`。但是，当我们把`(second foo)`传递给`setf`命令![httpatomoreillycomsourcenostarchimages783564.png]时，它似乎知道`B`的来源，并且能够将表达式`(second
    foo)`当作一个普通变量来处理。基本上，`setf`命令会问自己，“我的第一个参数中的项最初是从哪里来的？”在这种情况下，值来自名为`foo`的列表中的第二个元素。因此，如果我们尝试`setf`这个位置，源变量`foo`将被修改。
- en: 'In fact, the first argument in `setf` is a special sublanguage of Common Lisp,
    called a *generalized reference*. Not every Lisp command is allowed in a generalized
    reference, but you can still put in some pretty complicated stuff:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`setf`的第一个参数是 Common Lisp 的一种特殊子语言，称为**泛型引用**。并不是每个 Lisp 命令都允许在泛型引用中使用，但你仍然可以放入一些相当复杂的内容：
- en: '[PRE159]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: This example demonstrates the true power of `setf` in Common Lisp. In the first
    use, we put the list `(x y z)` into an array as the third item ![](httpatomoreillycomsourcenostarchimages783564.png).
    If we now print `foo`, we can see that it worked ![](httpatomoreillycomsourcenostarchimages783562.png).
    In the second use, we replace the first item in this list inside the `foo` array
    with a hash table ![](httpatomoreillycomsourcenostarchimages783560.png). Hash
    tables are another advanced data type we’ll be learning about shortly, in [Hash
    Tables](ch10s02.html "Hash Tables"). It is surprisingly easy to do this with `setf`,
    because the generalized reference in the first argument to `setf` can be arbitrarily
    complicated.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了 Common Lisp 中`setf`的真正威力。在第一次使用中，我们将列表`(x y z)`作为第三个元素放入数组中![httpatomoreillycomsourcenostarchimages783564.png]。如果我们现在打印`foo`，我们可以看到它已经成功了![httpatomoreillycomsourcenostarchimages783562.png]。在第二次使用中，我们将`foo`数组中的第一个元素替换为一个哈希表![httpatomoreillycomsourcenostarchimages783560.png]。哈希表是我们将在[哈希表](ch10s02.html
    "哈希表")中学习到的另一种高级数据类型。使用`setf`来做这件事非常简单，因为`setf`的第一个参数中的泛型引用可以是任意复杂的。
- en: Finally, we go all out and insert the value `5` into this hash table with the
    key of `zoink` ![](httpatomoreillycomsourcenostarchimages783554.png). The `gethash`
    function lets you get a value out of a hash table, as we’ll see shortly. Here,
    with the help of `setf`, we are putting the number 5 into the hash table instead.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将值 `5` 插入到这个哈希表中，键为 `zoink`！[图片](httpatomoreillycomsourcenostarchimages783554.png)。`gethash`
    函数允许你从哈希表中获取值，正如我们很快就会看到的。在这里，借助 `setf`，我们将数字5放入哈希表中。
- en: I hope you can appreciate from this example how useful `setf` can be when modifying
    complicated data structures in a program.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能从这个例子中体会到 `setf` 在修改程序中的复杂数据结构时是多么有用。
- en: Another cool feature of `setf` is that you can expand the generalized reference
    syntax to support new ways of accessing values. `setf` is a truly generic way
    of modifying values, regardless of the level of nesting or the datatypes being
    used.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`setf` 的另一个酷特性是你可以扩展通用引用语法以支持新的访问值方式。`setf` 是一种真正通用的修改值的方法，无论嵌套级别或使用的数据类型如何。'
- en: Arrays vs. Lists
  id: totrans-917
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组与列表
- en: You’ve now seen some basic examples of working with arrays in Lisp. However,
    to fully understand the benefits of arrays, we need to compare them with lists.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了一些在 Lisp 中使用数组的示例。然而，要完全理解数组的好处，我们需要将它们与列表进行比较。
- en: Almost anything that can be done with a list can also be done with an array.
    However, arrays are usually much faster than lists when accessing specific elements,
    so the difference is in performance.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以用列表完成的所有事情也可以用数组完成。然而，当访问特定元素时，数组通常比列表快得多，所以区别在于性能。
- en: 'For example, the array-handling function `aref` is very similar to a list-handling
    function called `nth`, which allows you access to an item at a specific location
    in a regular list without using an array. Here is an example using `nth` on a
    list:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数组处理函数 `aref` 与列表处理函数 `nth` 非常相似，它允许你访问常规列表中特定位置的元素，而无需使用数组。以下是在列表上使用 `nth`
    的一个示例：
- en: '[PRE160]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: However, it makes sense to use the `nth` function only with very small lists.
    If, for example, list X had thousands of items in it, running the command `(nth
    1000 x)` would be excruciatingly slow, because Lisp lists are made out of chains
    of cons cells. Hence, the only way Lisp can find the thousandth item in a list
    is to churn through the 999 preceding objects first.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有在使用非常小的列表时才使用 `nth` 函数是有意义的。例如，如果列表X中有成千上万个项目，运行命令 `(nth 1000 x)` 会非常慢，因为
    Lisp 列表是由 cons 单元的链构成的。因此，Lisp 找到列表中的第1000个元素的唯一方法是通过先遍历前999个对象。
- en: 'In contrast, running the command `(aref x 1000)` on a large array accesses
    the thousandth item directly, without counting through the previous 999 items.
    This means `aref` will execute much more quickly on a large array than the `nth`
    command would on a large list. In fact, an `aref` call will happen very quickly
    no matter how large the array. Even if you had an array with a billion items,
    retrieving the last item would still happen very quickly. The only real limiting
    factor is your system: the amount of RAM your computer has and how capable your
    Lisp environment is of taking advantage of it.'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在大型数组上运行命令 `(aref x 1000)` 会直接访问第1000个元素，而不需要通过前999个元素进行计数。这意味着在大型数组上 `aref`
    的执行速度会比在大型列表上执行 `nth` 命令要快得多。实际上，无论数组有多大，`aref` 调用都会非常快。即使你有一个包含十亿个元素的数组，检索最后一个元素也会非常快。唯一的真正限制因素是你的系统：你的计算机有多少RAM以及你的
    Lisp 环境如何有效地利用它。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages782996.png.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages782996.png.jpg)'
- en: Not only can we quickly access array values, but we can also change values at
    any specific location, usually faster than we can by performing the same operations
    on a list.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅能够快速访问数组值，还可以在任意特定位置更改值，通常比在列表上执行相同操作要快。
- en: Because setting and getting specific values in a large data structure is so
    important, keep arrays in mind as a tool to help you get the best performance
    possible with your code.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大型数据结构中设置和获取特定值非常重要，请记住数组作为帮助你以最佳性能编写代码的工具。
- en: Hash Tables
  id: totrans-927
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: In the same way that arrays are sort of like lists, *hash tables* are sort of
    like *alists*, except that they also allow you to access arbitrary elements more
    quickly.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数组有点像列表一样，*哈希表* 有点像 *alists*，只不过它们还允许你更快地访问任意元素。
- en: In fact, hash tables are so efficient that they can, at times, seem like magic.
    Think of the Babel fish in the *Hitchhiker’s Guide to the Galaxy* trilogy—something
    so impossibly useful that it really has no business existing in the first place.
    That’s why almost all modern languages now offer the hash table datatype.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，哈希表如此高效，有时甚至感觉像魔法。想想《银河系漫游指南》三部曲中的Babel鱼——某种不可思议的有用之物，它根本不应该存在。这就是为什么现在几乎所有现代语言都提供了哈希表数据类型。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781664.png)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](http://atomoreilly.com/source/nostarch/images/781664.png)'
- en: Working with Hash Tables
  id: totrans-931
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哈希表
- en: 'Create a new hash table with the `make-hash-table` command:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make-hash-table`命令创建一个新的哈希表：
- en: '[PRE161]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Like alists, hash tables store items using a lookup key and a value. We can
    retrieve an item from the hash table using the item’s key with the `gethash` function:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 与alists类似，哈希表使用查找键和值来存储项。我们可以使用`gethash`函数通过项的键从哈希表中检索项：
- en: '[PRE162]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: So far, our hash table remains empty. This means that when we look up any key
    in the hash table, such as `'yup` in this example, we receive `NIL` as an answer
    ![](httpatomoreillycomsourcenostarchimages783564.png). Actually, we receive two
    NILs ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png)—the
    `gethash` command returns multiple values, which you can do in Common Lisp (discussed
    in the next section). The first returned value is the actual value stored in the
    hash table, and the second indicates whether the key was found in the table (in
    this case, it wasn’t).
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的哈希表仍然是空的。这意味着当我们查找哈希表中的任何键时，例如本例中的`'yup`，我们将收到`NIL`作为答案 ![http://atomoreilly.com/source/nostarch/images/783564.png]。实际上，我们收到两个`NIL`
    ![http://atomoreilly.com/source/nostarch/images/783564.png]![http://atomoreilly.com/source/nostarch/images/783562.png]——`gethash`命令返回多个值，这在Common
    Lisp中是可以做到的（将在下一节讨论）。第一个返回值是哈希表中实际存储的值，第二个表示键是否在表中找到（在这种情况下，没有找到）。
- en: 'Just as with arrays, we can once again combine a command used for referencing
    data elements—in this case, `gethash`—with the `setf` command in order to fill
    our table with data:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，我们再次可以将用于引用数据元素的命令（在这种情况下，`gethash`）与`setf`命令结合起来，以便用数据填充我们的表：
- en: '[PRE163]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In this example, we’ve stored the value `25` in the hash table with a lookup
    key of `yup` ![](httpatomoreillycomsourcenostarchimages783564.png). Then, when
    we look up `yup` in the table, we get the answer of 25 ![](httpatomoreillycomsourcenostarchimages783562.png).
    We also get a second value of `t` ![](httpatomoreillycomsourcenostarchimages783560.png),
    which means, “Yes, I found the key in the table.”
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用查找键`yup`将值`25`存储在哈希表中 ![http://atomoreilly.com/source/nostarch/images/783564.png]。然后，当我们查找表中的`yup`时，我们得到答案25
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。我们还得到第二个值`t` ![http://atomoreilly.com/source/nostarch/images/783560.png]，这意味着，“是的，我在表中找到了这个键。”
- en: 'Remember when we discussed alists, we set up a data structure containing an
    order for coffee drinks? Here is that same data, but this time it’s stored using
    a hash table:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们讨论alists时，我们设置了一个包含咖啡饮品顺序的数据结构吗？这里就是那个相同的数据，但这次它是使用哈希表存储的：
- en: '[PRE164]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Accessing the drink order for any person is now simple:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问任何人的饮料订单变得简单：
- en: '[PRE165]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Returning Multiple Values
  id: totrans-944
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'Common Lisp allows you to return more than one value as a result. Some of the
    core Common Lisp core functions do this, including the `gethash` function, as
    you’ve seen. Another commonly used function that does this is the `round` function,
    which rounds off a number:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp允许你返回多个值作为结果。一些核心Common Lisp函数就是这样做的，包括你看到的`gethash`函数。另一个常用的执行此操作的函数是`round`函数，它将数字四舍五入：
- en: '[PRE166]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Calling this function appropriately rounded our number to 2 ![](httpatomoreillycomsourcenostarchimages783564.png),
    but then it also generated a second value, which is the remainder of the rounding
    operation ![](httpatomoreillycomsourcenostarchimages783562.png). Both values are
    returned from this function call.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 正确调用此函数将我们的数字四舍五入到2 ![http://atomoreilly.com/source/nostarch/images/783564.png]，但它还生成了第二个值，这是四舍五入操作的余数
    ![http://atomoreilly.com/source/nostarch/images/783562.png]。这两个值都从这个函数调用中返回。
- en: 'You can also create multiple values in your own code by using the `values`
    function. Here, for instance, we can write a `foo` function that returns two separate
    numbers, 3 and 7:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用`values`函数在自己的代码中创建多个值。例如，我们可以编写一个`foo`函数，它返回两个不同的数字，3和7：
- en: '[PRE167]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Both of these values are printed out at the REPL ![](httpatomoreillycomsourcenostarchimages783564.png)![](httpatomoreillycomsourcenostarchimages783562.png),
    just as with the `round` function. However, Lisp considers the first value to
    be more important, and it will always be used by default during follow-up calculations.
    For instance, we can perform an addition after calling `foo`, like this:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值都在REPL中打印出来![更多](http://atomoreilly.com/source/no_starch_images/783564.png)![更多](http://atomoreilly.com/source/no_starch_images/783562.png)，就像`round`函数一样。然而，Lisp认为第一个值更重要，并且在后续计算中始终默认使用它。例如，我们可以在调用`foo`之后执行加法，如下所示：
- en: '[PRE168]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: In this case, the addition operator just ignores the second value that `foo`
    returns.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，加法运算符只是忽略了`foo`返回的第二个值。
- en: 'However, sometimes you might need to use that additional returned value. You
    can do this by using the `multiple-value-bind` command:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要使用那个额外的返回值。你可以通过使用`multiple-value-bind`命令来实现：
- en: '[PRE169]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: In this example, we’ve bound the variables `a` and `b` to both of the values
    returned by `foo` (`3` and `7`). Calling our function with `multiple-value-bind`
    lets us use the extra values returned from the function, which would otherwise
    be ignored.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将变量`a`和`b`绑定到`foo`返回的两个值（`3`和`7`）。使用`multiple-value-bind`调用我们的函数使我们能够使用函数返回的额外值，否则这些值会被忽略。
- en: You might be wondering whether you could just return a list from your function
    instead of using the multiple-value feature. The answer is, yes, you could. However,
    it’s possible that using the multiple-value feature can lead to more optimized
    and cleaner code.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否可以直接从你的函数中返回一个列表，而不是使用多值特性。答案是，你可以。然而，使用多值特性可能会导致更优化和更简洁的代码。
- en: In this book, we will not be making much use of multiple values. In fact, more
    recent Lisp dialects, such as Arc and Clojure, do not support multiple values
    at all. Instead, they just return a list in the few cases where more than one
    value needs to be returned.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会大量使用多值。事实上，更近期的Lisp方言，如Arc和Clojure，根本不支持多值。相反，它们只在需要返回多个值的情况下返回一个列表。
- en: Hash Table Performance
  id: totrans-958
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希表性能
- en: As with arrays, accessing and modifying a value inside a hash table requires
    only a constant amount of time, no matter how many items your hash table contains.
    For instance, suppose we have a hash table with only 10 items in it. We access
    a value in the table, using a key, and find it takes on average 1 millisecond
    to do so. Now suppose that the hash table has 1,000,000 items in it. Because of
    how hash tables are designed, we could still expect it to take only about 1 millisecond
    to retrieve a value. In other words, no matter how big the table is, we can access
    items at a constant time of 1 millisecond.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，无论你的哈希表包含多少项，访问和修改哈希表中的值只需要恒定的时间。例如，假设我们有一个只包含10个条目的哈希表。我们使用键访问表中的值，平均需要1毫秒。现在假设哈希表中有1,000,000个条目。由于哈希表的设计方式，我们仍然可以期望检索一个值只需要大约1毫秒。换句话说，无论表有多大，我们都可以在1毫秒的恒定时间内访问项。
- en: Think of how incredible that is! Even if your hash table contained 1,000,000
    items, the `gethash` function could take the key you gave it and determine in
    a constant amount of time exactly where your desired item could be found!
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这是多么令人难以置信！即使你的哈希表包含1,000,000个条目，`gethash`函数也能在恒定的时间内确定你想要的项的确切位置，即使你提供了那个键！
- en: In this era of web-based programs backed by enormous amounts of data, the ability
    of hash tables to store large numbers of values with fast retrieval makes them
    indispensable. The efficient storage of key/value pairs is essential for most
    online storage systems. Even the latest tools for storing vast amounts of online
    data, like Google’s BigTable or Amazon’s S3, are built around the quick retrieval
    of values using keys, which makes them similar to hash tables.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基于大量数据的网络程序时代，哈希表能够以快速检索的方式存储大量值，这使得它们变得不可或缺。对于大多数在线存储系统来说，高效地存储键/值对是至关重要的。即使是存储大量在线数据的最新工具，如Google的BigTable或Amazon的S3，也是围绕使用键快速检索值来构建的，这使得它们类似于哈希表。
- en: 'However, you can’t always expect hash tables to provide the best performance.
    Here’s why:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能总是期望哈希表提供最佳性能。原因如下：
- en: '**Virtual memory paging and cache misses:**'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟内存分页和缓存未命中：**'
- en: As with arrays, large hash tables may cause your operating system to start paging
    virtual memory to your hard drive, thus degrading performance. Similarly, they
    can increase the number of cache misses within your CPU.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，大的哈希表可能会导致操作系统开始将虚拟内存分页到硬盘上，从而降低性能。同样，它们可能会增加CPU内的缓存未命中次数。
- en: '**Hash collisions:**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希冲突：**'
- en: Internally, hash tables use a special function called a *hash function*, which
    converts keys into numbers. Such a hash function can cause *hash collisions*.
    Basically, a hash collision happens when, by chance, two keys are converted by
    the hash function into the same number. In this case, the hash table will still
    behave correctly, but at a slightly degraded performance. In rare cases, certain
    types of keys can interact with a hash function to increase the number of collisions
    and impede an application’s ability to perform lookups, degrading performance
    even more.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，哈希表使用一个称为*哈希函数*的特殊函数，该函数将键转换为数字。这样的哈希函数可能导致*哈希冲突*。基本上，当两个键偶然被哈希函数转换为相同的数字时，就会发生哈希冲突。在这种情况下，哈希表仍然可以正确地工作，但性能会略有下降。在罕见的情况下，某些类型的键可能与哈希函数相互作用，增加冲突的数量，阻碍应用程序执行查找的能力，从而进一步降低性能。
- en: '**Inefficiency with small tables:**'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '**小表的不效率：**'
- en: With very small tables, the creation and lookup time required by hash tables
    can make them less inefficient than simpler structures, such as alists. The performance
    benefits of hash tables are noticeable only when they contain larger amounts of
    data in them.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常小的表，哈希表所需的创建和查找时间可能使它们比简单的结构（如alists）效率更低。只有在哈希表中包含大量数据时，哈希表的性能优势才明显。
- en: '**Varying speed for operations:**'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作速度不一：**'
- en: In Common Lisp, if you create a small hash table, and then fill it with values,
    you will find that occasionally, adding a new value will be unusually slow. This
    is because the `make-hash-table` function is designed to minimize the cost for
    creating small hash tables. However, as you start adding values to make the table
    big, Lisp will need to take extra time to allocate more memory so that the table
    can hold more items. These extra allocations will lead to occasional slow insertions
    into the table as it grows.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在Common Lisp中，如果你创建了一个小的哈希表，然后填充它，你会发现偶尔添加新值会特别慢。这是因为`make-hash-table`函数被设计成最小化创建小哈希表的成本。然而，当你开始添加值使表变大时，Lisp需要额外的时间来分配更多的内存，以便表可以容纳更多的项。这些额外的分配会导致表增长时偶尔的慢速插入。
- en: 'There is one final reason why hash tables are not always the best solution:
    They are simply not as Lispy as traditional Lisp structures built from cons cells.
    This means they can be harder to debug than cons cells, since they cannot be read
    and printed as naturally in the Lisp REPL. Therefore, a good rule of thumb is
    to stay away from arrays and hash tables as you conceive a new piece of code.
    Then, if performance ends up becoming an issue, and only then, judiciously modify
    the critical sections of your code to take advantage of arrays and hash tables
    to resolve any performance problems.'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表并非总是最佳解决方案的最后一个原因是：它们并不像由cons单元构建的传统Lisp结构那样Lispy。这意味着它们可能比cons单元更难调试，因为它们不能像在Lisp
    REPL中那样自然地读取和打印。因此，一个很好的经验法则是，在你构思新的代码片段时，尽量避免使用数组和哈希表。然后，如果性能最终成为问题，并且只有在那时，才谨慎地修改代码的关键部分，以利用数组和哈希表来解决任何性能问题。
- en: A Faster Grand Theft Wumpus Using Hash Tables
  id: totrans-972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用哈希表加速《大盗乌姆普斯》
- en: Let’s look at a practical example of what hash tables can do for your code.
    There is a glaring inefficiency in our latest game, Grand Theft Wumpus, that we
    can now correct with hash tables.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看哈希表能为你的代码带来哪些实际例子。在我们的最新游戏《大盗乌姆普斯》中，存在一个明显的低效问题，现在我们可以通过哈希表来纠正这个问题。
- en: 'Recall from the previous chapter that Grand Theft Wumpus uses lists of nodes
    and edges to represent the graph of the city. This means that in order to find
    connections to a given node, we must do a linear search through a list. This isn’t
    a big deal in Grand Theft Wumpus, because Congestion City doesn’t have a lot of
    intersections. But what if our city had a thousand nodes with a thousand edges?
    Let’s time the `get-connected` function and see what kind of numbers we get:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下上一章的内容，我们知道《大盗乌姆普斯》使用节点和边组成的列表来表示城市的图。这意味着为了找到给定节点的连接，我们必须在列表中进行线性搜索。在《大盗乌姆普斯》中这不是什么大问题，因为拥堵城市没有很多交叉口。但如果我们有一个有千个节点和千个边的城市呢？让我们计时`get-connected`函数，看看我们会得到什么样的数字：
- en: '[PRE170]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The `time` command is a Lisp utility that outputs all kinds of useful timing
    information about a chunk of code, and the `dotimes` function lets us run our
    code 100 times, building 100 cities. Using these commands, it took about a minute
    to run this code on my computer. Given how many gazillion instructions a CPU can
    crunch in a minute, this is absolutely horrifyingly bad performance.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`命令是一个Lisp实用程序，它输出有关代码块的各种有用的计时信息，而`dotimes`函数允许我们运行我们的代码100次，构建100个城市。使用这些命令，在我的电脑上运行这段代码大约需要一分钟。考虑到CPU在一分钟内可以处理多少亿条指令，这绝对是一个令人震惊的糟糕性能。'
- en: To fix this problem, we’ll replace our edge list for this code with a hash table
    so that the `get-connected` function will be able to find connections to a node
    in constant time. We’ll also replace our visited list with a visited table, so
    the function can quickly tell whether a node has already been visited.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将用哈希表替换此代码中的边列表，这样`get-connected`函数就能在常数时间内找到节点的连接。我们还将用访问表替换访问列表，这样函数可以快速判断一个节点是否已经被访问。
- en: 'Here is the code that makes this happen, consisting of hashed versions of our
    previous functions:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使这一切发生的代码，它由我们之前函数的哈希版本组成：
- en: '[PRE171]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: First, we need `hash-edges`, a function that converts our edge list into a hash
    table ![](httpatomoreillycomsourcenostarchimages783564.png). At the beginning
    of the function, we create a new hash table and name it `tab` ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then, we iterate through the table with `mapc` ![](httpatomoreillycomsourcenostarchimages783560.png).
    Remember that `mapc` is just like `mapcar`, except that you use it in places where
    you care only about the side effects and don’t care about generating a final list
    as a result.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要`hash-edges`函数，它将我们的边列表转换为哈希表 ![图片](http://atomoreilly.com/source/nostarch/images/783564.png)。在函数开始时，我们创建一个新的哈希表并将其命名为`tab`
    ![图片](http://atomoreilly.com/source/nostarch/images/783562.png)。然后，我们使用`mapc`
    ![图片](http://atomoreilly.com/source/nostarch/images/783560.png)遍历表格。记住，`mapc`就像`mapcar`一样，只不过你会在只关心副作用而不关心生成最终列表的地方使用它。
- en: For every node, we want the table to contain a list of nodes connected to it.
    Therefore, as we iterate through the list, we push a new neighbor onto the current
    list of neighbors for the current starting node ![](httpatomoreillycomsourcenostarchimages783554.png).
    We can use the `push` command on hash table values just as for regular Lisp variable
    values. This, again, makes use of the general variables system built into Common
    Lisp, which we’ll discuss in [Handling Data in a Generic Way](ch10s04.html "Handling
    Data in a Generic Way") in [Handling Data in a Generic Way](ch10s04.html "Handling
    Data in a Generic Way").
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，我们希望表格包含一个与它相连的节点列表。因此，当我们遍历列表时，我们将一个新的邻居推入当前起始节点的当前邻居列表 ![图片](http://atomoreilly.com/source/nostarch/images/783554.png)。我们可以像对常规Lisp变量值一样使用哈希表值的`push`命令。这再次利用了内置在Common
    Lisp中的通用变量系统，我们将在[以通用方式处理数据](ch10s04.html "以通用方式处理数据")中讨论，见[以通用方式处理数据](ch10s04.html
    "以通用方式处理数据")。
- en: You may be wondering why we don’t need to deal with the case where there is
    no value yet for a node in the table. How can we `push` something into a value
    in the table if no value exists? Well, it turns out that because the `gethash`
    function returns `NIL` when a key is not found in the table, this code will simply
    push the new neighbor onto an empty list and stick a new record into the table
    where none was found before. In this way, the `push` command magically does the
    “right thing,” no matter whether the node is new or old.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不需要处理表中某个节点还没有值的情况。如果没有值存在，我们如何将某物推入表中的值？好吧，结果证明，因为`gethash`函数在表中找不到键时返回`NIL`，所以这段代码将简单地在新邻居上推入一个空列表，并在之前没有找到的地方在表中插入一个新的记录。这样，`push`命令神奇地做了“正确的事情”，无论节点是新的还是旧的。
- en: Finally, once our table is populated, we return it as a result ![](httpatomoreillycomsourcenostarchimages783510.png).
    It contains the same data as the original edge list. The difference is that we
    can now find the neighbors of any node in Congestion City at blazing speeds.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们的表格被填充，我们就将其作为结果返回 ![图片](http://atomoreilly.com/source/nostarch/images/783510.png)。它包含与原始边列表相同的数据。不同之处在于，我们现在可以以闪电般的速度找到拥堵城市中任何节点的邻居。
- en: '[PRE172]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Now we’re ready to write `get-connected-hash`, which retrieves all the nodes
    connected to a starting node in Congestion City ![](httpatomoreillycomsourcenostarchimages783564.png).
    It is identical in behavior to `get-connected`, but is optimized through hash
    tables.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写`get-connected-hash`，它检索拥堵城市中与起始节点相连的所有节点！[](httpatomoreillycomsourcenostarchimages783564.png)。它的行为与`get-connected`相同，但通过哈希表进行了优化。
- en: The first thing this function does is create a hash table of visited nodes ![](httpatomoreillycomsourcenostarchimages783562.png).
    Then we travel through the nodes of Congestion City, beginning with the starting
    node. Every time we visit a new node, we ask ourselves if we’ve visited it before.
    We can now answer this question very efficiently by looking up the current node
    in the `visited` table ![](httpatomoreillycomsourcenostarchimages783560.png).
    If the answer is no, we’ll need to mark this node as visited ![](httpatomoreillycomsourcenostarchimages783554.png)
    and check all of its neighbors by `mapc`ing through them—checking our edge table
    ![](httpatomoreillycomsourcenostarchimages783510.png). Finally, we return our
    `visited` table, which in the end will hold all nodes that are connected to the
    starting node ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先做的事情是创建一个已访问节点的哈希表！[](httpatomoreillycomsourcenostarchimages783562.png)。然后我们遍历拥堵城市的节点，从起始节点开始。每次我们访问一个新的节点时，我们会问自己是否以前访问过它。现在我们可以通过在`visited`表中查找当前节点来非常高效地回答这个问题！[](httpatomoreillycomsourcenostarchimages783560.png)。如果答案是未访问过，我们需要将这个节点标记为已访问！[](httpatomoreillycomsourcenostarchimages783554.png)，并通过`mapc`检查它的所有邻居——检查我们的边表！[](httpatomoreillycomsourcenostarchimages783510.png)。最后，我们返回我们的`visited`表，最终将包含与起始节点相连的所有节点！[](httpatomoreillycomsourcenostarchimages783544.png)。
- en: 'Now we can rerun our test with this new logic:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这种新逻辑重新运行我们的测试：
- en: '[PRE173]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: As you can see, instead of taking a minute to calculate the connections in the
    graph, it now takes only one second to do the same thing! This is why you must
    know how to use hash tables.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与计算图中连接需要一分钟相比，现在只需一秒钟就能完成同样的事情！这就是你必须知道如何使用哈希表的原因。
- en: Common Lisp Structures
  id: totrans-990
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Common Lisp结构
- en: A *structure* is an advanced datatype available in Common Lisp. Structures and
    their properties can be a useful way to represent data in your code.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '*结构*是Common Lisp中的一种高级数据类型。结构和它们的属性可以是你代码中表示数据的有用方式。'
- en: Working with Structures
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与结构一起工作
- en: 'Structures can be used to represent objects with properties, as you might find
    in a typical object-oriented programming (OOP) language using the `defstruct`
    command, like so:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以用来表示具有属性的物体，就像你在使用`defstruct`命令的典型面向对象编程（OOP）语言中找到的那样，如下所示：
- en: '[PRE174]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'According to the definition in this structure, a `person` has four properties
    (also called *slots* by Lispers): `name`, `age`, `waist-size`, and `favorite-color`.'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 根据该结构中的定义，一个`person`有四个属性（Lisper们也称之为*slots*）：`name`、`age`、`waist-size`和`favorite-color`。
- en: 'Having defined this structure, we can create instances of a person using the
    `make-person` command, a special function that `defstruct` has automatically created
    for us:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这种结构后，我们可以使用`make-person`命令创建人的实例，这是`defstruct`为我们自动创建的一个特殊函数：
- en: '[PRE175]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Now when we enter `*bob*` into the REPL, we see our new person marked as a
    structure with the `#S` prefix. We also see that the structure is of type `person`,
    and the values of each of its properties (`name`, `age`, `waist size`, and `favorite-color`):'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`*bob*`输入到REPL中，我们看到我们的新人物被标记为具有`#S`前缀的结构。我们还看到该结构是`person`类型，以及它的每个属性（`name`、`age`、`waist
    size`和`favorite-color`）的值：
- en: '[PRE176]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'We can determine Bob’s age by calling another automatically created function,
    `person-age`:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用另一个自动创建的函数`person-age`来确定鲍勃的年龄：
- en: '[PRE177]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: We can also use `setf` with these commands to change Bob’s age. (Happy birthday,
    Bob!)
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`setf`与这些命令一起更改鲍勃的年龄。（生日快乐，鲍勃！）
- en: '[PRE178]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The Lisp reader can also create a person directly from the printed representation
    of the person, another great example of the print/read symmetry in Lisp:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp读取器还可以直接从人的打印表示中创建人，这是Lisp中打印/读取对称性的另一个绝佳例子：
- en: '[PRE179]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Here, we’re creating a new variable called `*that-guy*`, and we set its value
    using only the printed representation of the person ![](httpatomoreillycomsourcenostarchimages783564.png).
    This variable now has a real `person` structure in it, just as if we had used
    the `make-person` function ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`*that-guy*`的新变量，并仅使用该人的打印表示形式来设置其值 ![这里](httpatomoreillycomsourcenostarchimages783564.png)。这个变量现在包含了一个真实的`person`结构，就像我们使用了`make-person`函数
    ![这里](httpatomoreillycomsourcenostarchimages783562.png) 一样。
- en: As you can see, `defstruct` is quite a powerful command that can be used to
    build special functions that make it easy to create instances of a new object
    and access its properties.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`defstruct`是一个非常强大的命令，可以用来构建特殊函数，这些函数可以轻松创建新对象的实例并访问其属性。
- en: When to Use Structures
  id: totrans-1008
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用结构
- en: These days, many mainstream programmers believe that object orientation is a
    necessity when developing large and robust applications. Many Lispers, on the
    other hand, believe that it’s possible to build high-quality software without
    taking a purely OOP approach.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多主流程序员认为，在开发大型和健壮的应用程序时，面向对象是必需的。另一方面，许多Lisper认为，即使不采取纯面向对象的方法，也可以构建高质量的软件。
- en: Beginning with [Chapter 14](ch16.html "Chapter 14. Ramping Lisp Up a Notch with
    Functional Programming"), we’ll examine some of these alternate approaches, including
    higher-order functional programming and domain-specific language programming.
    The design of the Lisp language makes it much easier to take advantage of these
    alternate approaches than is possible with other, more object-oriented languages.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第14章](ch16.html "第14章。使用函数式编程提升Lisp的层次")开始，我们将探讨一些这些替代方法，包括高阶函数式编程和领域特定语言编程。Lisp语言的设计使得利用这些替代方法比其他更面向对象的语言要容易得多。
- en: 'Regardless, even if you’re not writing purely OOP-style software, structures
    and their properties can still prove to be a useful way to represent data in your
    code. For instance, instead of creating a `person` class with `defstruct`, we
    could do the same thing with a standard list and our own `make-person` function.
    After all, why bother with structures if we can just roll our own person using
    lists, like so:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，即使你不是在编写纯面向对象风格的软件，结构和它们的属性仍然可以证明是表示代码中数据的有用方式。例如，我们可以使用标准列表和自己的`make-person`函数来完成与`defstruct`创建`person`类相同的事情。毕竟，如果我们可以用列表自己创建一个像这样的人物，为什么还要麻烦使用结构呢：
- en: '[PRE180]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Although this approach will work, it has several downsides. First, in order
    to check a person’s age or other properties, we would need to write a lot of error-prone
    functions that pull properties out of the list from the correct locations. Also,
    the printed version of our ad hoc object ![](httpatomoreillycomsourcenostarchimages783564.png)
    is very hard to understand. How do we know `BOB` is a person? Is Bob’s age 35
    or 32? Regular lists just don’t lend themselves well to encoding objects with
    multiple properties.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可行，但它有几个缺点。首先，为了检查一个人的年龄或其他属性，我们需要编写许多容易出错的函数，从列表的正确位置提取属性。此外，我们临时对象的打印版本
    ![这里](httpatomoreillycomsourcenostarchimages783564.png) 非常难以理解。我们如何知道`BOB`是一个人？鲍勃的年龄是35岁还是32岁？常规列表并不适合编码具有多个属性的对象。
- en: Another problem with using lists to represent an object in the real world is
    that the properties of an object (like a `person` object) may change over time.
    Lists in Lisp work best when you are dealing with information that never changes
    once the list is created. When Bob turns 36, however, we need to change his age
    property.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表在现实世界中表示一个对象还存在另一个问题，那就是一个对象（如`person`对象）的属性可能会随时间改变。Lisp中的列表在处理一旦创建列表就不再改变的信息时效果最佳。然而，当鲍勃36岁时，我们需要更改他的年龄属性。
- en: Having part of a data structure change over time is called a *mutation* by computer
    scientists. It’s easy to change the value of a specific property (mutate the property)
    in a structure created with `defstruct`, so these structures are very suitable
    for handling data that needs to be mutable. Therefore, it makes sense to store
    a `person` (or any other object that changes over time) in a structure. We will
    be discussing the issue of mutation in greater detail in [Chapter 14](ch16.html
    "Chapter 14. Ramping Lisp Up a Notch with Functional Programming").
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家将数据结构随时间部分变化称为 *变异*。在用 `defstruct` 创建的结构中更改特定属性值（变异属性）很容易，因此这些结构非常适合处理需要可变性的数据。因此，将
    `person`（或任何随时间变化的对象）存储在结构中是有意义的。我们将在[第 14 章](ch16.html "第 14 章。通过函数式编程提升 Lisp
    的层次")中更详细地讨论变异问题。
- en: Note
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `defstruct` facility is not the only tool that can be used to create objects
    in Common Lisp. For example, in the epilogue of the book, you’ll see that Common
    Lisp’s Common Lisp Object System (CLOS) allows you to build very sophisticated
    object-based systems. If you care to code with a strongly object-oriented mindset,
    you will probably find all the OOP language functionality you need in Common Lisp.
    Indeed, CLOS has many advanced object-oriented features that you won’t find in
    many other places. Because of this, CLOS has often been used as a research tool
    for studying OOP ideas.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: '`defstruct` 功能并不是创建 Common Lisp 中对象的唯一工具。例如，在本书的序言中，您将看到 Common Lisp 的 Common
    Lisp 对象系统（CLOS）允许您构建非常复杂基于对象系统。如果您想以强面向对象的方式编码，您可能会在 Common Lisp 中找到所有需要的面向对象语言功能。确实，CLOS
    具有许多其他地方找不到的高级面向对象特性。正因为如此，CLOS 经常被用作研究面向对象思想的研究工具。'
- en: Handling Data in a Generic Way
  id: totrans-1018
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以通用方式处理数据
- en: Common Lisp has many different datatypes available for writing elegant and efficient
    programs. But without some care, having so many datatypes can lead to ugly and
    repetitive code.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 提供了许多不同的数据类型，可用于编写优雅且高效的程序。但如果不加注意，拥有如此多的数据类型可能会导致代码丑陋且重复。
- en: For example, suppose we want to add several groups of numbers, which are stored
    as both lists and arrays. Since lists and arrays behave differently, will we need
    to write two different addition functions—one for lists and the other for arrays?
    It would be great if we could write a single chunk of code to handle both cases
    without caring about how the numbers are stored.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要添加存储为列表和数组的多组数字。由于列表和数组的行为不同，我们是否需要编写两个不同的加法函数——一个用于列表，另一个用于数组？如果能编写一段代码来处理这两种情况，而不关心数字的存储方式，那就太好了。
- en: Common Lisp has all the features we need to write such generic code, including
    generic library functions, type predicates, `defmethod`, and generic accessors.
    We can use these features to write code that works with many types of data—including
    built-in as well as custom types that we might create with `defstruct`—without
    superfluous repetition in our code.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp 拥有我们编写此类通用代码所需的所有功能，包括通用库函数、类型谓词、`defmethod` 和通用访问器。我们可以利用这些功能编写适用于多种类型数据的代码——包括内置类型以及我们可能使用
    `defstruct` 创建的自定义类型——而无需在代码中重复使用多余的内容。
- en: Working with Sequences
  id: totrans-1022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与序列一起工作
- en: 'The easiest way to write code that works with any type of argument is to hand
    the type-checking work to someone else. The Common Lisp libraries are packed with
    functions that can generically handle data of varying types in their arguments,
    the most commonly used of which are the *sequence functions*. The sequence functions
    work generically across the three main ways of sequencing objects in Lisp: lists,
    arrays, and strings.'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 编写适用于任何类型参数的代码的最简单方法是将类型检查的工作交给别人。Common Lisp 库中包含了许多函数，可以通用地处理其参数中不同类型的数据，其中最常用的是
    *序列函数*。序列函数在 Lisp 中对象序列的三个主要方式上通用：列表、数组和字符串。
- en: 'You’ve already seen one of these sequence functions without even realizing
    it: the `length` function. You can use the `length` function to check for the
    length of all three sequence types:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至没有意识到就已经看到了这些序列函数中的一个：`length` 函数。您可以使用 `length` 函数来检查所有三种序列类型的长度：
- en: '[PRE181]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Without the generic `length` function, you would need to use three separate
    functions to determine the length of strings, arrays, and lists.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 没有通用的 `length` 函数，您需要使用三个不同的函数来确定字符串、数组和列表的长度。
- en: Note
  id: totrans-1027
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Common Lisp has a specific function for checking the length of lists, called
    list-length. Because generic functions tend to require extra type-checking to
    determine the correct behavior, they can be slower to execute. The `list-length`
    function is useful for performance-sensitive code, but most Lispers prefer using
    the generic `length` function in regular code.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp有一个用于检查列表长度的特定函数，称为`list-length`。由于通用函数通常需要额外的类型检查来确定正确的行为，因此它们可能执行得较慢。`list-length`函数对于性能敏感的代码很有用，但大多数Lisper更喜欢在常规代码中使用通用的`length`函数。
- en: Sequence Functions for Searching
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列搜索函数
- en: 'Some sequence functions let you search sequences:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 一些序列函数允许你在序列中进行搜索：
- en: '`find-if` finds the first value that satisfies a predicate.'
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find-if`用于找到满足谓词的第一个值。'
- en: '`count` finds out how often a certain object appears in sequence.'
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`用于找出某个对象在序列中出现的频率。'
- en: '`position` tells you where an item is located.'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`告诉你一个项目在哪里。'
- en: '`some` and `every` tell you if some or every value in a sequence obeys a specific
    predicate.'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`some`和`every`告诉你序列中的某些或所有值是否遵循特定的谓词。'
- en: 'Here are some examples:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '[PRE182]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: In these examples, we use `find-if` to find the first number in a sequence,
    which is the number 5 ![](httpatomoreillycomsourcenostarchimages783564.png). We
    use `count` to find out how many times the character `s` appears in `"mississippi"`
    ![](httpatomoreillycomsourcenostarchimages783562.png). We use `position` to find
    at what position the character 4 appears. In this case, it is in the fifth position,
    starting the count from zero ![](httpatomoreillycomsourcenostarchimages783560.png).
    We use `some` to see if any items in a sequence are numbers. Indeed, there is
    a number ![](httpatomoreillycomsourcenostarchimages783554.png). Finally, we use
    `every` to see if every item in the list is a number, which is not the case ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我们使用`find-if`来找到序列中的第一个数字，即数字5 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。我们使用`count`来找出字符`s`在`"mississippi"`中出现的次数
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)。我们使用`position`来找到字符4出现的位置。在这种情况下，它在第五个位置，从零开始计数
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)。我们使用`some`来查看序列中是否有任何项目是数字。确实有一个数字
    ![图片](httpatomoreillycomsourcenostarchimages783554.png)。最后，我们使用`every`来查看列表中的每个项目是否都是数字，这显然不是情况
    ![图片](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Sequence Functions for Iterating Across a Sequence
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历序列的序列函数
- en: 'One particularly useful generic sequence function is `reduce`. The `reduce`
    function allows you to iterate through a sequence and distill it down into a single
    result. Here, we use `reduce` to add together items in a list:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有用的通用序列函数是`reduce`。`reduce`函数允许你遍历一个序列并将其简化为单个结果。在这里，我们使用`reduce`将列表中的项目相加：
- en: '[PRE183]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The sum of those numbers turns out to be 20\. Here is a diagram that shows
    exactly what is happening in this example:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字的总和是20。下面是一个图表，展示了这个例子中发生的具体情况：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781410.png.jpg)'
  id: totrans-1042
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781410.png.jpg)'
- en: On the right side, shown in gray, is our list. On the left side, you can see
    the pairs of numbers that are fed into the plus (`+`) function and the intermediate
    results that are calculated. This shows that the plus function always receives
    a single intermediate result as well as the next number in the list as its arguments.
    The only exception to this is in the very first call to the plus function. Since
    no intermediate result exists when we start, the first time we call the plus function,
    we promote the number 3, which is at the start of the list, into our intermediate
    result column. Therefore, the first time the plus function is called, it actually
    receives *two items* straight off the top of the list.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，用灰色表示的是我们的列表。在左侧，你可以看到输入到加法函数（`+`）中的数字对以及计算出的中间结果。这表明加法函数始终接收一个中间结果以及列表中的下一个数字作为其参数。唯一的例外是在对加法函数的第一次调用中。由于开始时没有中间结果，当我们第一次调用加法函数时，我们将列表开头的数字3提升到我们的中间结果列中。因此，第一次调用加法函数时，它实际上直接接收了列表顶部的*两个项目*。
- en: 'Let’s look at a slightly more complicated example, this time using our own
    reduction function. We’re going to find the largest even number in the list:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个稍微复杂一点的例子，这次我们使用自己的归约函数。我们要找到列表中的最大偶数：
- en: '[PRE184]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Our reduction function, which we pass to `reduce` to distill down our answer
    from the list, has two arguments ![](httpatomoreillycomsourcenostarchimages783564.png).
    The first argument is the best value we’ve found so far—in other words, the largest
    even number we’ve found so far. The second argument is the next number from the
    list.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`reduce`以从列表中提炼出答案的归约函数有两个参数 ![httpatomoreillycomsourcenostarchimages783564.png](httpatomoreillycomsourcenostarchimages783564.png)。第一个参数是我们迄今为止找到的最佳值——换句话说，是我们迄今为止找到的最大偶数。第二个参数是列表中的下一个数字。
- en: Our `reduce` function needs to return as a result the new best number. Therefore,
    if the latest number is better than the previous best ![](httpatomoreillycomsourcenostarchimages783562.png),
    we return it ![](httpatomoreillycomsourcenostarchimages783560.png). Otherwise,
    we return the previous best ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`reduce`函数需要返回新的最佳数字作为结果。因此，如果最新的数字比之前的最佳数字更好 ![httpatomoreillycomsourcenostarchimages783562.png](httpatomoreillycomsourcenostarchimages783562.png)，我们就返回它
    ![httpatomoreillycomsourcenostarchimages783560.png](httpatomoreillycomsourcenostarchimages783560.png)。否则，我们返回之前的最佳数字
    ![httpatomoreillycomsourcenostarchimages783554.png](httpatomoreillycomsourcenostarchimages783554.png)。
- en: Remember that the first number in the list we’re reducing will be used as a
    starting value. If this is a problem, we can instead pass an explicit initial
    value to the `reduce` function by passing in a keyword parameter named `:initial-value`
    ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们正在`reduce`的列表中的第一个数字将被用作起始值。如果这成问题，我们可以通过传递一个名为`:initial-value`的关键字参数来显式地传递一个初始值给`reduce`函数
    ![httpatomoreillycomsourcenostarchimages783510.png](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Specifying an initial value for the `reduce` function is often necessary, or
    a bug can sneak into your code. In our example, it could allow an odd number at
    the front of the list to erroneously be deemed the best large even number. Let’s
    see what happens if we leave out the initial value.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 为`reduce`函数指定一个初始值通常是必要的，否则可能会导致代码中出现bug。在我们的例子中，它可能会错误地将列表前面的奇数视为最佳的大偶数。让我们看看如果我们省略初始值会发生什么。
- en: '[PRE185]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Yes, things go horribly, horribly wrong, as a result of not specifying an initial
    `reduce` value.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，由于没有指定初始的`reduce`值，事情会变得非常糟糕。
- en: Another great benefit of the `reduce` function is that it is generic, as is
    true for all these sequence functions. This means that it can `reduce` lists,
    arrays, or strings in exactly the same way, and you can use `reduce` to write
    functions that are oblivious to the difference between these different sequence
    types.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数的另一个优点是它是通用的，正如所有这些序列函数一样。这意味着它可以以完全相同的方式`reduce`列表、数组或字符串，你可以使用`reduce`来编写对不同的序列类型之间的差异视而不见的函数。'
- en: 'Earlier, I mentioned that it would be convenient to be able to write a single
    function that could sum together numbers in lists or arrays equally well. Now
    we can write such a function:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到，能够编写一个可以同样好地求和列表或数组中的数字的单个函数将非常方便。现在我们可以编写这样的函数：
- en: '[PRE186]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781742.png.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![image with no caption](httpatomoreillycomsourcenostarchimages781742.png.jpg)'
- en: '`sum` is blissfully unaware of the difference between arrays and lists; it
    works on both. However, since addition doesn’t make any sense for characters,
    the `sum` function returns an error when used on a string.'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`对数组和列表之间的区别毫无察觉；它对两者都有效。然而，由于加法对字符没有意义，当在字符串上使用`sum`函数时，它会返回一个错误。'
- en: Another function that is useful for iterating across a sequence is the `map`
    function. This function is identical in behavior to `mapcar`. However, unlike
    `mapcar`, the `map` function works on all sequence types, not just lists. You
    specify the type of sequence to return from the mapping by passing an extra argument
    to the `map` function.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在序列上迭代的函数是`map`函数。这个函数的行为与`mapcar`相同。然而，与`mapcar`不同，`map`函数适用于所有序列类型，而不仅仅是列表。你通过传递一个额外的参数到`map`函数来指定从映射中返回的序列类型。
- en: 'Here is an example of `map`:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`map`的一个例子：
- en: '[PRE187]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: In this example, we’re turning every `s` character in a string to its uppercase
    version. The mapping function we pass into `map` simply checks if the current
    character is an `s` and returns the uppercase `S` if it is ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将字符串中的每个`s`字符转换为其大写版本。我们传递给`map`的映射函数简单地检查当前字符是否为`s`，如果是，则返回大写字母`S`
    ![image with no caption](httpatomoreillycomsourcenostarchimages781742.png.jpg)。
- en: The result of this calculation is a list of characters ![](httpatomoreillycomsourcenostarchimages783560.png).
    This is because we told the `map` function that we wanted a list as a result ![](httpatomoreillycomsourcenostarchimages783564.png).
    Had we asked for a `string` instead, a string would have been our result.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 此计算的结果是一个字符列表 ![http://atomoreilly.com/source/nostarch/images/783560.png]。这是因为我们告诉
    `map` 函数我们想要一个列表作为结果 ![http://atomoreilly.com/source/nostarch/images/783564.png]。如果我们要求一个
    `string`，那么结果将是一个字符串。
- en: Two More Important Sequence Functions
  id: totrans-1062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 两个重要的序列函数
- en: 'The `subseq` function lets you pull a subsequence out of a larger sequence
    by specifying starting and ending points:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '`subseq` 函数允许您通过指定起始和结束点从较大的序列中提取子序列：'
- en: '[PRE188]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: As you can see, the word `america` contains the name `eric`, starting from the
    second character and ending at the sixth character.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，单词 `america` 从第二个字符开始，到第六个字符结束，包含了名字 `eric`。
- en: 'The `sort` function lets you pass it an arbitrary function to use for the sorting.
    In this case, we’re just using the less-than (`<`) function:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 函数允许您传递一个任意函数用于排序。在这种情况下，我们只是使用了小于 (`<`) 函数：'
- en: '[PRE189]'
  id: totrans-1067
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: There are many more sequence functions than we’ve discussed so far, but the
    examples in this chapter will get you off to a good start.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的序列函数比之前还要多，但本章的示例将帮助您迈出良好的一步。
- en: Note
  id: totrans-1069
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a comprehensive list of sequence functions, and indeed all Common Lisp functions,
    visit the *Common Lisp Hyperspec* at [http://www.snipurl.com/rz3h0](http://www.snipurl.com/rz3h0)—an
    exhaustive, but daunting, description of all Common Lisp has to offer.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取序列函数的完整列表，以及所有 Common Lisp 函数，请访问 *Common Lisp Hyperspec* [http://www.snipurl.com/rz3h0](http://www.snipurl.com/rz3h0)——这是对所有
    Common Lisp 提供内容的详尽但令人畏惧的描述。
- en: Creating Your Own Generic Functions with Type Predicates
  id: totrans-1071
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型谓词创建自己的通用函数
- en: Common Lisp, like virtually all other Lisps, is a dynamically typed language.
    This means that parameters or variables in your code can hold any type of data—symbols,
    strings, numbers, functions, or whatever else you want to place in them. In fact,
    the same parameter or variable can even hold different types of data at different
    times in a running program.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: Common Lisp，就像几乎所有其他 Lisp 一样，是一种动态类型语言。这意味着您的代码中的参数或变量可以持有任何类型的数据——符号、字符串、数字、函数或您想要放入其中的任何其他内容。实际上，相同的参数或变量甚至可以在运行程序的不同时间持有不同类型的数据。
- en: 'Therefore, it makes sense to have a bunch of functions that tell you whether
    a variable has a certain type of data in it. For instance, you can check whether
    you have a number with `numberp`:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一系列函数来告诉您变量中是否包含某种类型的数据是有意义的。例如，您可以使用 `numberp` 来检查是否有一个数字：
- en: '[PRE190]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: The type predicates you will probably use most frequently are `arrayp`, `characterp`,
    `consp`, `functionp`, `hash-table-p`, `listp`, `stringp`, and `symbolp`.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会最频繁使用的类型谓词是 `arrayp`、`characterp`、`consp`、`functionp`、`hash-table-p`、`listp`、`stringp`
    和 `symbolp`。
- en: 'You can use type predicates to write functions that handle different types
    of data generically. Suppose we wanted to write a function that lets us add both
    numbers or lists. Here’s one way we could write such a function:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类型谓词来编写处理不同类型数据的通用函数。假设我们想要编写一个函数，允许我们添加数字或列表。这里是我们可能编写此类函数的一种方式：
- en: '[PRE191]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: In this `add` function, we use predicates to see if the arguments passed in
    are numbers or lists, and then we act appropriately. If we aren’t given two numbers
    or two lists, it simply returns `nil`.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `add` 函数中，我们使用谓词来检查传入的参数是否是数字或列表，然后相应地操作。如果没有给出两个数字或两个列表，它将简单地返回 `nil`。
- en: 'Although you can write functions supporting multiple types of data using type
    predicates, most Lispers wouldn’t write an `add` function this way, for the following
    reasons:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用类型谓词编写支持多种类型数据的函数，但大多数 Lisp 程序员不会这样编写 `add` 函数，以下是一些原因：
- en: '**A single, monolithic function for all types:**'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '**适用于所有类型的单一、单一函数：**'
- en: This is fine for just two types, but if we wanted to handle a dozen or more
    types, our function would quickly turn into a giant monstrosity.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于两种类型来说是可以的，但如果我们要处理十种或更多类型，我们的函数会迅速变成一个巨大的怪物。
- en: '**Modifications required to accommodate new cases:**'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '**为适应新情况所需的修改：**'
- en: We would need to change the add function whenever we want to support a new type,
    increasing the chance that we would break existing code. Ideally, we would like
    to handle each new situation by itself without touching already working code.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要支持新的类型时，都需要更改 `add` 函数，这增加了破坏现有代码的可能性。理想情况下，我们希望独立处理每个新情况，而不触及已经工作的代码。
- en: '**Hard to understand:**'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '**难以理解：**'
- en: It is hard to see exactly what the main cond statement is doing and if the types
    are all being routed to the right place.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确切地看到主 `cond` 语句在做什么，以及类型是否都被正确路由到适当的位置。
- en: '**Performance:**'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能：**'
- en: The resulting function might be slow. For instance, a Lisp interpreter/compiler
    might be able to create faster code for appending two lists if it knew for sure
    that both items were lists when the appending happens. However, in our first attempt
    at the add function, the type of the two arguments is never really completely
    obvious. Our compiler would need a bit of smarts to be able to tell from the condition
    `(and (listp a) (listp b))` that both variables are guaranteed to be lists. Life
    would be easier for the compiler if we explicitly stated the types of arguments
    for each type situation.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数可能运行较慢。例如，如果 Lisp 解释器/编译器确定在追加时两个项目都是列表，它可能能够为追加两个列表创建更快的代码。然而，在我们的 `add`
    函数的第一个尝试中，两个参数的类型从未真正完全明显。我们的编译器需要一些智慧才能从条件 `(and (listp a) (listp b))` 中判断出两个变量都保证是列表。如果我们明确地声明每种类型情况的参数类型，编译器的工作会更容易。
- en: Because it is so useful to be able to have a single function that does different
    things when given certain datatypes, the Common Lisp command `defmethod` lets
    us define multiple versions of a function that each supports different types.
    When that function is called, Lisp checks the argument types at the time of the
    call and chooses the correct version of the function automatically. The proper
    term for having a compiler/interpreter choose among different versions of a function
    based on argument types is *type dispatching*.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 因为能够拥有一个在给定特定数据类型时执行不同操作的单一函数非常有用，所以 Common Lisp 命令 `defmethod` 允许我们定义多个版本的函数，每个版本都支持不同的类型。当该函数被调用时，Lisp
    会检查调用时的参数类型，并自动选择正确的函数版本。根据参数类型在编译器/解释器中选择函数不同版本的正确术语是 *类型分派*。
- en: 'Here’s how we would write our `add` function using `defmethod`:'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何使用 `defmethod` 编写我们的 `add` 函数：
- en: '[PRE192]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: As you can see, this version of the `add` function handles every type of situation
    with a separate function, and new cases can be added without modifying existing
    code. Overall, the code is much easier to understand. Also, the compiler can see
    the type of the parameters and may be able to write faster code using this knowledge.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个版本的 `add` 函数使用一个单独的函数处理每种类型的情况，并且可以添加新案例而无需修改现有代码。总体而言，代码更容易理解。此外，编译器可以看到参数的类型，并且可能能够利用这些知识编写更快的代码。
- en: The `defmethod` function is like `defun`, except that it allows us to write
    multiple functions with the same name. When using `defmethod`, we can explicitly
    state the type of each parameter in the function’s argument list so that Lisp
    can use these type declarations to figure out the correct version of `add` for
    each situation.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '`defmethod` 函数类似于 `defun`，但它允许我们编写具有相同名称的多个函数。当使用 `defmethod` 时，我们可以在函数的参数列表中明确声明每个参数的类型，这样
    Lisp 就可以使用这些类型声明来确定每种情况下正确的 `add` 版本。'
- en: If you’re familiar with the world of OOP, the word *method* probably has a special
    meaning to you. Since this new command is called `defmethod`, does it have anything
    to do with OOP? In short, yes. This command can be used not only with Common Lisp’s
    built-in types, but also with structures you’ve created with `defstruct`. The
    combination of `defstruct` and `defmethod` basically constitutes a simple object
    system.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的世界，那么“方法”这个词可能对你有特殊的意义。由于这个新命令叫做 `defmethod`，它是否与面向对象有关？简而言之，是的。这个命令不仅可以与
    Common Lisp 的内置类型一起使用，还可以与使用 `defstruct` 创建的结构一起使用。`defstruct` 和 `defmethod` 的组合基本上构成了一个简单的对象系统。
- en: Now we’ll use this object system to write a game!
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个对象系统来编写一个游戏！
- en: The Orc Battle Game
  id: totrans-1095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《兽人战斗游戏》
- en: In the Orc Battle game, you’re a knight surrounded by 12 monsters, engaged in
    a fight to the death. With your superior wits and your repertoire of sword-fighting
    maneuvers, you must carefully strategize in your battle with orcs, hydras, and
    other nasty enemies. One wrong move and you may be unable to kill them all before
    being worn down by their superior numbers. Using `defmethod` and `defstruct`,
    let’s dispatch some whoop ass on these vermin!
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在《兽人战斗游戏》中，你是一名被12个怪物包围的骑士，正在进行一场生死之战。凭借你卓越的智慧和你的剑术技巧，你必须在与兽人、九头蛇和其他讨厌的敌人战斗中谨慎制定战略。一旦失误，你可能会在数量上处于劣势，无法在耗尽体力之前杀死他们。使用
    `defmethod` 和 `defstruct`，让我们对这些害虫发起猛烈的攻击！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages783116.png.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages783116.png.jpg)'
- en: Global Variables for the Player and Monsters
  id: totrans-1098
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家和怪物的全局变量
- en: 'We’ll want to track three player stats: health, agility, and strength. When
    a player’s health reaches zero, that player will die. Agility will control how
    many attacks a player can perform in a single round of battle, and strength will
    control the ferocity of the attacks. As the game progresses, each of these will
    change and affect gameplay and strategy in subtle ways.'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要跟踪三个玩家统计数据：健康、敏捷和力量。当玩家的健康值达到零时，该玩家将死亡。敏捷将控制玩家在战斗单回合中可以执行多少次攻击，而力量将控制攻击的猛烈程度。随着游戏的进行，这些值都会发生变化，并以微妙的方式影响游戏玩法和策略。
- en: '[PRE193]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: We’ll store our monsters in an array called `*monsters*`. This array will be
    *heterogeneous*, meaning it can contain different types of monsters, be they orcs,
    hydras, or anything else. We’ll create our monster types with `defstruct`. Of
    course, we still need to figure out how to handle each type in the list in a meaningful
    way—that’s where we’ll use Lisp’s generic features.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的怪物存储在一个名为 `*monsters*` 的数组中。这个数组将是异构的，意味着它可以包含不同类型的怪物，无论是兽人、九头蛇还是其他任何东西。我们将使用
    `defstruct` 创建我们的怪物类型。当然，我们仍然需要弄清楚如何以有意义的方式处理列表中的每种类型——这就是我们将使用 Lisp 的泛型功能的地方。
- en: We’ll also define a list of functions for building monsters that we’ll store
    in the variable `*monster-builders*`. As we write the code for each type of monster,
    we’ll create a function that builds a monster of each type. We’ll then push each
    of these monster builders onto this list. Having all the builder functions in
    this list will make it easy for us to create random monsters at will for our game.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个用于构建怪物的函数列表，我们将将其存储在变量 `*monster-builders*` 中。随着我们为每种类型的怪物编写代码，我们将创建一个构建每种类型怪物的函数。然后我们将每个怪物构建器推送到这个列表中。在这个列表中拥有所有构建器函数将使我们能够随意为我们的游戏创建随机怪物。
- en: Finally, we’ll create the variable `*monster-num*` to control how many opponents
    our knight must fight. Change this variable to increase (or decrease) the difficulty
    level of Orc Battle.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个名为 `*monster-num*` 的变量来控制我们的骑士必须与多少个对手战斗。更改此变量可以增加（或减少）奥克之战的难度级别。
- en: '[PRE194]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Main Game Functions
  id: totrans-1105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主游戏函数
- en: Now we’re ready to write our first real code for the game, starting with the
    big picture functions that drive the rest of the system.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写游戏的第一段实际代码，从驱动整个系统的整体函数开始。
- en: 'First, we’ll define a function called `orc-battle`. This function will initialize
    the monsters and start the game loop and, once the battle ends, it will determine
    the victor and print the appropriate ending message for the game. As you can see,
    `orc-battle` calls plenty of helper functions to do the actual work:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为 `orc-battle` 的函数。这个函数将初始化怪物并开始游戏循环，一旦战斗结束，它将确定胜利者并打印出适当的游戏结束消息。正如你所见，`orc-battle`
    调用了许多辅助函数来完成实际工作：
- en: '[PRE195]'
  id: totrans-1108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: At the top, we call the initialization functions for the monsters and the player
    ![](httpatomoreillycomsourcenostarchimages783564.png). Then we start the main
    game loop ![](httpatomoreillycomsourcenostarchimages783562.png). The game loop
    will keep running until either the player or the monsters are dead. We’ll print
    a game-ending message depending on whether the player ![](httpatomoreillycomsourcenostarchimages783560.png)
    or monsters ![](httpatomoreillycomsourcenostarchimages783554.png) died.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们调用怪物和玩家的初始化函数 ![初始化函数](httpatomoreillycomsourcenostarchimages783564.png)。然后我们开始主游戏循环
    ![主游戏循环](httpatomoreillycomsourcenostarchimages783562.png)。游戏循环将一直运行，直到玩家或怪物死亡。根据玩家
    ![玩家](httpatomoreillycomsourcenostarchimages783560.png) 或怪物 ![怪物](httpatomoreillycomsourcenostarchimages783554.png)
    是否死亡，我们将打印出游戏结束的消息。
- en: 'Next, we’ll create the function `game-loop` to handle the game loop. This function
    handles a round of the battle, and then calls itself recursively for the following
    round:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `game-loop` 函数来处理游戏循环。这个函数处理一回合的战斗，然后递归地调用自身进行下一回合：
- en: '[PRE196]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The `game-loop` function handles the repeated cycles of monster and player attacks.
    As long as both parties in the fight are still alive, the function will first
    show some information about the player in the REPL ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '`game-loop` 函数处理怪物和玩家攻击的重复循环。只要战斗中的双方都还活着，该函数将首先在 REPL 中显示一些关于玩家的信息 ![玩家信息](httpatomoreillycomsourcenostarchimages783564.png)。'
- en: Next, we allow the player to attack the monsters. The `game-loop` function uses
    the player’s agility to modulate how many attacks can be launched in a single
    round of battle, using some fudge factors to transform the agility to a small,
    appropriate number ![](httpatomoreillycomsourcenostarchimages783562.png). When
    the game begins, the player will have three attacks per round. Later stages of
    battle could cause this number to drop to a single attack per round.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们允许玩家攻击怪物。`game-loop`函数使用玩家的敏捷性来调节在战斗的单轮中可以发起多少次攻击，使用一些调整因素将敏捷性转换为一个小的、合适的数字
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)。当游戏开始时，玩家每轮将有三次攻击。战斗的后期阶段可能会使这个数字减少到每轮一次攻击。
- en: 'The calculated agility factor for our player attack loop ![](httpatomoreillycomsourcenostarchimages783562.png)
    is passed into the `dotimes` command, which takes a variable name and a number
    *n*, and runs a chunk of code *n* times:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家攻击循环中计算出的敏捷因素 ![图片](httpatomoreillycomsourcenostarchimages783562.png) 被传递到`dotimes`命令中，该命令接受一个变量名和一个数字*n*，并运行代码块*n*次：
- en: '[PRE197]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The `dotimes` function is one of Common Lisp’s looping commands (looping is
    covered in more detail in [Chapter 10](ch11.html "Chapter 10. Looping with the
    loop Command")).
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotimes`函数是Common Lisp的循环命令之一（循环将在第10章中更详细地介绍 [Chapter 10](ch11.html "Chapter 10. Looping
    with the loop Command")）。'
- en: After the player has attacked, we allow the monsters to attack. We do this by
    iterating through our list of monsters with the `map` function ![](httpatomoreillycomsourcenostarchimages783560.png).
    Every type of monster has a special `monster-attack` command, which we’ll call
    as long as the monster is still alive ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家攻击之后，我们允许怪物进行攻击。我们通过使用`map`函数遍历我们的怪物列表来实现这一点 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。每种怪物都有一个特殊的`monster-attack`命令，只要怪物还活着，我们就会调用这个命令
    ![图片](httpatomoreillycomsourcenostarchimages783554.png)。
- en: Finally, the `game-loop` function calls itself recursively, so that the battle
    can continue until one side or the other has been vanquished ![](httpatomoreillycomsourcenostarchimages783510.png).
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`game-loop`函数递归地调用自己，这样战斗就可以继续进行，直到一方或另一方被击败 ![图片](httpatomoreillycomsourcenostarchimages783510.png)。
- en: Player Management Functions
  id: totrans-1119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家管理函数
- en: 'The functions we need for managing the player’s attributes (health, agility,
    and strength) are very simple. Following are the functions we need to initialize
    players, to see if they’ve died, and to output their attributes:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的用于管理玩家属性（健康、敏捷和力量）的函数非常简单。以下是我们需要的初始化玩家、检查他们是否死亡以及输出他们属性的函数：
- en: '[PRE198]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The `player-attack` function lets us manage a player’s attack:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '`player-attack`函数让我们管理玩家的攻击：'
- en: '[PRE199]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'First, this function prints out some different types of attacks from which
    the player can choose ![](httpatomoreillycomsourcenostarchimages783564.png). As
    you can see, the player is offered three possible attacks: a stab, a double swing,
    and a roundhouse swing. We read in the player’s selection, and then handle each
    type of attack in a `case` statement ![](httpatomoreillycomsourcenostarchimages783562.png).'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个函数会打印出一些不同的攻击类型，玩家可以选择 ![图片](httpatomoreillycomsourcenostarchimages783564.png)。正如你所见，玩家有三个可能的攻击选择：刺击、双击和旋风斩。我们读取玩家的选择，然后在`case`语句中处理每种类型的攻击
    ![图片](httpatomoreillycomsourcenostarchimages783562.png)。
- en: The stab attack is the most ferocious attack and can be delivered against a
    single foe. Since a stab is performed against a single enemy, we will first call
    the `pick-monster` function to let the player choose whom to attack ![](httpatomoreillycomsourcenostarchimages783560.png).
    The attack strength is calculated from the `*player-strength*`, using a random
    factor and some other little tweaks to generate a nice, but never too powerful,
    attack strength ![](httpatomoreillycomsourcenostarchimages783554.png). Once the
    player has chosen a monster to attack and the attack strength has been calculated,
    we call the `monster-hit` function to apply the attack ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 刺击攻击是最凶猛的攻击，可以针对单个敌人进行。由于刺击是对单个敌人进行的，我们将首先调用`pick-monster`函数让玩家选择攻击目标 ![图片](httpatomoreillycomsourcenostarchimages783560.png)。攻击强度是从`*player-strength*`计算出来的，使用随机因素和一些其他的小调整来生成一个既好又不过于强大的攻击强度
    ![图片](httpatomoreillycomsourcenostarchimages783554.png)。一旦玩家选择了一个怪物进行攻击并且攻击强度已经计算出来，我们就调用`monster-hit`函数来实施攻击
    ![图片](httpatomoreillycomsourcenostarchimages783560.png)。
- en: Unlike the stab attack, the double swing is weaker, but allows two enemies to
    be attacked at once. An additional benefit of the attack is that the knight can
    tell, as the swing begins, how strong it will be—information that can then be
    used to choose the best enemies to attack midswing. This extra feature of the
    double swing adds strategic depth to the game. Otherwise, the double-swing code
    ![](httpatomoreillycomsourcenostarchimages783510.png) is similar to the stab code,
    printing a message and allowing the player to choose whom to attack. In this case,
    however, two monsters can be chosen ![](httpatomoreillycomsourcenostarchimages783544.png)![](httpatomoreillycomsourcenostarchimages783556.png).
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 与刺击攻击不同，双击攻击较弱，但可以同时攻击两个敌人。攻击的另一个好处是，随着挥击的开始，骑士可以知道它将有多强——然后可以使用这个信息在中挥击时选择最佳攻击目标。双击攻击的这个额外功能为游戏增加了战略深度。否则，双击代码！[](httpatomoreillycomsourcenostarchimages783510.png)与刺击代码类似，打印一条消息并允许玩家选择攻击目标。在这种情况下，可以选择两个怪物！[](httpatomoreillycomsourcenostarchimages783544.png)![](httpatomoreillycomsourcenostarchimages783556.png)。
- en: The final attack, the roundhouse swing, is a wild, chaotic attack that does
    not discriminate among the enemies. We run through a `dotimes` loop based on the
    player’s strength ![](httpatomoreillycomsourcenostarchimages783566.png) and then
    attack random foes multiple times. However, each attack is very weak, with a strength
    of only 1 ![](httpatomoreillycomsourcenostarchimages783498.png).
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的攻击，即旋风式挥击，是一种狂野、混乱的攻击，对敌人没有选择性。我们根据玩家的力量运行一个基于`dotimes`循环！[](httpatomoreillycomsourcenostarchimages783566.png)，然后多次攻击随机敌人。然而，每次攻击都非常弱，力量仅为1！[](httpatomoreillycomsourcenostarchimages783498.png)。
- en: 'These attacks must be used correctly, at the right stages of a battle, in order
    to achieve victory. To add some randomness to the attacks in the `player-attack`
    function, we used the `randval` helper function to generate random numbers. It
    is defined as follows:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些攻击必须正确使用，在战斗的正确阶段使用，才能取得胜利。为了在`player-attack`函数中的攻击中增加一些随机性，我们使用了`randval`辅助函数来生成随机数。它定义如下：
- en: '[PRE200]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The `randval` function returns a random number from one to *n*, while making
    sure that no matter how small *n* is, at least the number 1 will be returned.
    Using `randval` instead of just the `random` function for generating random numbers
    gives a reality check to the randomness of the game, since 0 doesn’t make sense
    for some of the values we use in our calculations. For instance, even the weakest
    player or monster should always have an attack strength of at least 1.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '`randval`函数返回一个从1到*n*的随机数，同时确保无论*n*多小，至少返回数字1。使用`randval`而不是仅使用`random`函数生成随机数，为游戏中的随机性提供了现实检查，因为0对于我们在计算中使用的一些值来说没有意义。例如，即使是力量最弱的玩家或怪物，攻击力量也应至少为1。'
- en: 'The `random` function used by `randval` is the canonical random value function
    in Lisp. It can be used in several different ways, though most frequently it is
    used by passing in an integer *n* and receiving a random integer from 0 to *n*−1:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '`randval`中使用的`random`函数是Lisp中的标准随机值函数。它可以以几种不同的方式使用，尽管最常见的是通过传递一个整数*n*并接收一个从0到*n*−1的随机整数：'
- en: '[PRE201]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Helper Functions for Player Attacks
  id: totrans-1133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家攻击的辅助函数
- en: 'Our `player-attack` function needs two helper functions to do its job. First,
    it needs a `random-monster` function that picks a monster to target for the chaotic
    roundhouse attack, while ensuring that the chosen monster isn’t already dead:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`player-attack`函数需要两个辅助函数来完成其工作。首先，它需要一个`random-monster`函数来选择一个怪物作为混乱旋风攻击的目标，同时确保所选怪物尚未死亡：
- en: '[PRE202]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The `random-monster` function first picks a random monster out of the array
    of monsters and stores it in the variable `m` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Since we want to pick a living monster to attack, we recursively try the function
    again if we inadvertently picked a dead monster ![](httpatomoreillycomsourcenostarchimages783562.png).
    Otherwise, we return the chosen monster ![](httpatomoreillycomsourcenostarchimages783560.png).
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '`random-monster`函数首先从怪物数组中随机选择一个怪物，并将其存储在变量`m`中！[](httpatomoreillycomsourcenostarchimages783564.png)。由于我们希望选择一个活着的怪物进行攻击，如果我们意外选择了一个已死的怪物，我们会递归地再次尝试该函数！[](httpatomoreillycomsourcenostarchimages783562.png)。否则，我们返回所选怪物！[](httpatomoreillycomsourcenostarchimages783560.png)。'
- en: 'The `player-attack` function also needs a function that allows the player to
    pick a monster to target for the nonrandom attacks. This is the job of the `pick-monster`
    function:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '`player-attack`函数还需要一个允许玩家选择攻击目标的非随机攻击函数。这是`pick-monster`函数的工作：'
- en: '[PRE203]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: In order to let the player pick a monster to attack, we first need to display
    a prompt ![](httpatomoreillycomsourcenostarchimages783564.png) and read in the
    player’s choice ![](httpatomoreillycomsourcenostarchimages783562.png). Then we
    need to make sure the player chose an integer that isn’t too big or too small
    ![](httpatomoreillycomsourcenostarchimages783560.png). If this has happened, we
    print a message and call `pick-monster` again to let the player choose again.
    Otherwise, we can safely place the chosen monster in the variable `m` ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让玩家选择一个怪物进行攻击，我们首先需要显示一个提示 ![提示](http://atomoreilly.com/source/nostarch/images/783564.png)
    并读取玩家的选择 ![读取选择](http://atomoreilly.com/source/nostarch/images/783562.png)。然后我们需要确保玩家选择了一个不太大也不太小的整数
    ![整数选择](http://atomoreilly.com/source/nostarch/images/783560.png)。如果发生了这种情况，我们将打印一条消息并再次调用
    `pick-monster` 让玩家重新选择。否则，我们可以安全地将选定的怪物放置在变量 `m` 中 ![变量放置](http://atomoreilly.com/source/nostarch/images/783554.png)。
- en: Another error the player could make is to attack a monster that is already dead.
    We check for this possibility next and, once again, allow the player to make another
    selection ![](httpatomoreillycomsourcenostarchimages783510.png). Otherwise, the
    player has successfully made a choice, and we return the selected monster as a
    result ![](httpatomoreillycomsourcenostarchimages783544.png).
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可能犯的另一个错误是攻击一个已经死亡的怪物。我们接下来检查这种情况，并再次允许玩家进行另一轮选择 ![另一轮选择](http://atomoreilly.com/source/nostarch/images/783510.png)。否则，玩家已经成功做出了选择，我们将返回所选的怪物作为结果
    ![返回结果](http://atomoreilly.com/source/nostarch/images/783544.png)。
- en: Now let’s work on our monsters.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理我们的怪物。
- en: Monster Management Functions
  id: totrans-1142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怪物管理函数
- en: 'We’ll use the `init-monsters` function to initialize all the bad guys stored
    in the `*monsters*` array. This function will randomly pick functions out of the
    `*monster-builders*` list and call them with `funcall` to build the monsters:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `init-monsters` 函数来初始化存储在 `*monsters*` 数组中的所有敌人。这个函数将随机从 `*monster-builders*`
    列表中选择函数，并使用 `funcall` 调用它们来构建怪物：
- en: '[PRE204]'
  id: totrans-1144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: First, the `init-monsters` function builds an empty array to hold the monsters
    ![](httpatomoreillycomsourcenostarchimages783560.png). Then it `maps` across this
    array to fill it up ![](httpatomoreillycomsourcenostarchimages783564.png). In
    the `lambda` function, you can see how random monsters are created by `funcall`ing
    random functions in our list of monster builders ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`init-monsters` 函数构建一个空数组来存储怪物 ![空数组](http://atomoreilly.com/source/nostarch/images/783560.png)。然后它在这个数组上
    `map` 以填充它 ![填充数组](http://atomoreilly.com/source/nostarch/images/783564.png)。在
    `lambda` 函数中，你可以看到如何通过在我们的怪物构建者列表中 `funcall` 随机函数来创建随机怪物 ![随机怪物](http://atomoreilly.com/source/nostarch/images/783562.png)。
- en: Next, we need some simple functions for checking if the monsters are dead. Notice
    how we use the every command on the `*monsters*` array to see if the function
    `monster-dead` is true for every monster. This will tell us whether the entire
    monster population is dead.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一些简单的函数来检查怪物是否死亡。注意我们如何在 `*monsters*` 数组上使用 every 命令来查看 `monster-dead`
    函数对于每个怪物是否为真。这将告诉我们整个怪物种群是否已经死亡。
- en: '[PRE205]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'We’ll use the `show-monsters` function to display a listing of all the monsters.
    This function will, in turn, defer part of the work to another function, so it
    doesn’t actually need to know a lot about the different monster types:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `show-monsters` 函数来显示所有怪物的列表。这个函数将转而将部分工作委托给另一个函数，因此它实际上不需要了解太多关于不同怪物类型的信息：
- en: '[PRE206]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Since our player will need to choose monsters with a number, we will maintain
    a count as we loop through monsters in our list, in the variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Then we `map` through our monster list, calling a `lambda` function on each monster,
    which will print out some pretty text for each monster ![](httpatomoreillycomsourcenostarchimages783562.png).
    We use our `x` variable to print out the number for each monster in our numbered
    list ![](httpatomoreillycomsourcenostarchimages783560.png). As we do this, we
    use the `incf` function, which will increment `x` as we work through the list.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的玩家需要用数字选择怪物，因此我们将在遍历列表中的怪物时维护一个计数，变量为 `x` ![计数变量](http://atomoreilly.com/source/nostarch/images/783564.png)。然后我们通过怪物列表
    `map`，对每个怪物调用一个 `lambda` 函数，这将为每个怪物打印一些漂亮的文本 ![打印文本](http://atomoreilly.com/source/nostarch/images/783562.png)。我们使用
    `x` 变量来打印出我们编号列表中每个怪物的编号 ![编号打印](http://atomoreilly.com/source/nostarch/images/783560.png)。在这个过程中，我们使用
    `incf` 函数，它将在我们遍历列表时增加 `x` 的值。
- en: For dead monsters, we won’t print much about them, just a message showing that
    they are dead ![](httpatomoreillycomsourcenostarchimages783554.png). For living
    monsters, we call generic monster functions, calculating the health ![](httpatomoreillycomsourcenostarchimages783510.png)
    and generating the monster description ![](httpatomoreillycomsourcenostarchimages783544.png)
    in a specialized way for each different type of foe.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于死亡的怪物，我们不会打印太多关于它们的信息，只显示一个表示它们已经死亡的消息 ![http://atomoreilly.com/source/nostarch/images/783554.png]。对于活着的怪物，我们调用通用怪物函数，以针对每种不同类型的敌人以特殊方式计算健康值
    ![http://atomoreilly.com/source/nostarch/images/783510.png] 和生成怪物描述 ![http://atomoreilly.com/source/nostarch/images/783544.png]。
- en: The Monsters
  id: totrans-1152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 怪物们
- en: So far, we haven’t seen any functions that really give life to the monsters.
    Let’s fix that.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有看到任何真正赋予怪物生命的函数。让我们来解决这个问题。
- en: First, we’ll describe a generic monster.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将描述一个通用怪物。
- en: The Generic Monster
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用怪物
- en: 'As you would expect, orcs, hydras, and other bad guys all have one thing in
    common: a health meter that determines how many hits they can take before they
    die. We can capture this behavior in a `monster` structure:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，奥克、九头蛇和其他坏蛋都有一个共同点：一个健康计，它决定了它们在被击败之前可以承受多少次打击。我们可以将这种行为捕捉在 `monster`
    结构体中：
- en: '[PRE207]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'This use of the `defstruct` function takes advantage of a special feature:
    When we declare each slot in the structure (in this case, `health`) we can put
    parentheses around the name and add a default value for that slot. But more important,
    we can declare a form that will be evaluated when a new `monster` is created.
    Since this form calls `randval`, every monster will start the battle with a different,
    random, health.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用 `defstruct` 函数的方法利用了一个特殊功能：当我们声明结构体中的每个槽位（在这种情况下，`health`）时，我们可以在名称周围加上括号，并为该槽位添加一个默认值。但更重要的是，我们可以声明一个在创建新的
    `monster` 时将被评估的表单。由于这个表单调用 `randval`，每个怪物将以不同的、随机的健康值开始战斗。
- en: 'Let’s try creating some monsters:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一些怪物：
- en: '[PRE208]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'We also need a function that takes away a monster’s health when it’s attacked.
    We’ll have this function output a message explaining what happened, including
    a message to be displayed when the monster dies. However, instead of creating
    this function with `defun`, we’ll use the generic `defmethod`, which will let
    us display special messages when the knight beats on particular monsters:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数，当怪物被攻击时，它会减少怪物的健康值。我们将让这个函数输出一个消息，解释发生了什么，包括怪物死亡时显示的消息。然而，我们不会使用 `defun`
    来创建这个函数，而是使用通用的 `defmethod`，这样我们就可以在骑士击败特定怪物时显示特殊消息：
- en: '[PRE209]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The `decf` function ![](httpatomoreillycomsourcenostarchimages783564.png) is
    a variant of `setf` that lets us subtract an amount from a variable. The `type-of`
    function lets `monster-hit` pretend it knows the type of the monster that was
    hit ![](httpatomoreillycomsourcenostarchimages783562.png)![](httpatomoreillycomsourcenostarchimages783560.png).
    This function can be used to find the type of any Lisp value:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '`decf` 函数 ![http://atomoreilly.com/source/nostarch/images/783564.png] 是 `setf`
    的一个变体，它允许我们从变量中减去一个量。`type-of` 函数让 `monster-hit` 假装它知道被击中的怪物的类型 ![http://atomoreilly.com/source/nostarch/images/783562.png]
    ![http://atomoreilly.com/source/nostarch/images/783560.png]。这个函数可以用来找出任何 Lisp
    值的类型：'
- en: '[PRE210]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Currently, the type of a monster will always be `monster`, but soon we’ll have
    this value change for each monster type.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，怪物的类型将始终是 `monster`，但很快我们将为每种怪物类型改变这个值。
- en: 'We can also use two more generic methods to create monsters: `monster-show`
    and `monster-attack`.'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用两种更通用的方法来创建怪物：`monster-show` 和 `monster-attack`。
- en: The `monster-attack` function doesn’t actually do anything. This is because
    all our monster attacks will be so unique that there’s no point in defining a
    generic attack. This function is simply a placeholder.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '`monster-attack` 函数实际上并没有做任何事情。这是因为我们所有的怪物攻击都将非常独特，因此定义一个通用攻击是没有意义的。这个函数只是一个占位符。'
- en: '[PRE211]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Now that we have some generic monster code, we can finally create some actual
    bad guys!
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些通用怪物代码，我们终于可以创建一些真正的坏蛋了！
- en: The Wicked Orc
  id: totrans-1170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶魔兽
- en: The orc is a simple foe. He can deliver a strong attack with his club, but otherwise
    he is pretty harmless. Every orc has a club with a unique attack level. Orcs are
    best ignored, unless there are orcs with an unusually powerful club attack that
    you want to cull from the herd at the beginning of a battle.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 奥克是一个简单的敌人。他可以用他的战锤发动强攻，但除此之外，他几乎无害。每个奥克都有一把具有独特攻击水平的战锤。奥克最好被忽略，除非你想要在战斗开始时从群体中淘汰那些具有异常强大战锤攻击的奥克。
- en: To create the orc, we define an `orc` datatype with `defstruct`. Here, we will
    use another advanced feature of `defstruct` to declare that the `orc` includes
    all the fields of `monster`.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建兽人，我们使用`defstruct`定义一个`orc`数据类型。在这里，我们将使用`defstruct`的另一个高级特性来声明`orc`包含`monster`的所有字段。
- en: By including the fields from our `monster` type in our `orc` type, the `orc`
    will be able to inherit the fields that apply to all monsters, such as the `health`
    field. This is similar to what you can accomplish in popular languages such as
    C++ or Java by defining a generic class and then creating other, more specialized,
    classes that inherit from this generic class.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的`orc`类型中包含`monster`类型的字段，`orc`将能够继承适用于所有怪物的字段，例如`health`字段。这类似于在C++或Java等流行语言中通过定义一个泛型类然后创建其他更专门的类继承这个泛型类所能实现的效果。
- en: 'Once the structure is declared, we push the `make-orc` function (automatically
    generated by the `defstruct`) onto our list of `*monster-builders*`:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了结构，我们就将自动由`defstruct`生成的`make-orc`函数推送到我们的`*monster-builders*`列表中：
- en: '[PRE212]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Note
  id: totrans-1176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how powerful this approach is. We can create as many new monster types
    as we want, yet we’ll never need to change our basic Orc Battle code. This is
    possible only in languages like Lisp, which are dynamically typed and support
    functions as first-class values. In statically typed programming languages, the
    main Orc Battle code would need some hardwired way of calling the constructor
    for each new type of monster. With first-class functions, we don’t need to worry
    about this.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这种方法是多么强大。我们可以创建任意数量的新怪物类型，而永远不会需要更改我们的基本兽人战斗代码。这只有在像Lisp这样的动态类型语言中才可能，这些语言支持函数作为一等值。在静态类型编程语言中，主要的兽人战斗代码需要一种硬编码的方式来调用每种新类型怪物的构造函数。使用一等函数，我们不需要担心这个问题。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779881.png.jpg)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779881.png.jpg)'
- en: 'Now let’s specialize our `monster-show` and `monster-attack` functions for
    orcs. Notice these are defined in the same way as the earlier versions of these
    functions, except that we explicitly declare that these functions are orc-specific
    in the argument lists:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为兽人专门化我们的`monster-show`和`monster-attack`函数。注意，这些函数的定义方式与之前版本相同，只是在参数列表中明确声明这些函数是针对兽人的：
- en: '[PRE213]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The one unique thing about our `orc` type is that each orc has an `orc-club-level`
    field. These orc-specific versions of `monster-show` and `monster-attack` take
    this field into account. In the `monster-show` function, we display this club
    level ![](httpatomoreillycomsourcenostarchimages783564.png), so that the player
    can gauge the danger posed by each orc.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`orc`类型的独特之处在于每个兽人都有一个`orc-club-level`字段。这些针对兽人的`monster-show`和`monster-attack`版本会考虑这个字段。在`monster-show`函数中，我们显示这个俱乐部等级
    ![俱乐部等级](httpatomoreillycomsourcenostarchimages783564.png)，以便玩家可以评估每个兽人带来的危险。
- en: In the `monster-attack` function, we use the level of the club to decide how
    badly the player is hit by the club ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`monster-attack`函数中，我们使用俱乐部等级来决定玩家被俱乐部击中的严重程度 ![俱乐部等级](httpatomoreillycomsourcenostarchimages783562.png)。
- en: The Malicious Hydra
  id: totrans-1183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意九头蛇
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages779984.png.jpg)'
  id: totrans-1184
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages779984.png.jpg)'
- en: The hydra is a very nasty enemy. It will attack you with its many heads, which
    you’ll need to chop off to defeat it. The hydra’s special power is that it can
    grow a new head during each round of battle, which means you want to defeat it
    as early as possible.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 九头蛇是一个非常讨厌的敌人。它会用它的许多头攻击你，你需要砍掉这些头才能击败它。九头蛇的特殊能力是它可以在每一轮战斗中长出一个新的头，这意味着你希望尽早击败它。
- en: '[PRE214]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: The code for handling the hydra is similar to the code for handling the orc.
    The main difference is that a hydra’s health also acts as a stand-in for the number
    of hydra heads. In other words, a hydra with three health points will have three
    heads, as well. Therefore, when we write our hydra-specific `monster-show` function,
    we use the monster’s health to print a pretty message about the number of heads
    on the hydra ![](httpatomoreillycomsourcenostarchimages783564.png).
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 处理九头蛇的代码与处理兽人的代码类似。主要区别在于九头蛇的健康值也充当了九头蛇头数的替代品。换句话说，有三个健康点的九头蛇也会有三个头。因此，当我们编写针对九头蛇的特定`monster-show`函数时，我们使用怪物的健康值来打印关于九头蛇头数的漂亮信息
    ![九头蛇头数](httpatomoreillycomsourcenostarchimages783564.png)。
- en: Another difference between the orc and the hydra is that an orc doesn’t do anything
    particularly interesting when it is hit by the player. Because of this, we didn’t
    need to write a custom `monster-hit` function for the orc; the orc simply used
    the generic `monster-hit` function we created for a generic `monster`.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 与兽人相比，九头蛇的另一个不同之处在于，当玩家攻击兽人时，兽人并没有什么特别有趣的行为。正因为如此，我们不需要为兽人编写一个自定义的`monster-hit`函数；兽人只是简单地使用了我们为通用`monster`创建的通用`monster-hit`函数。
- en: 'A hydra, on the other hand, does something interesting when it is hit: It loses
    heads! We therefore create a hydra-specific `monster-hit` function, where heads
    are removed with every blow, which amounts to lowering the hydra’s health ![](httpatomoreillycomsourcenostarchimages783562.png).
    Also, we can now print a dramatic message about how the knight lopped off said
    heads ![](httpatomoreillycomsourcenostarchimages783560.png).'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当九头蛇被击中时，它会做出有趣的事情：它会失去头！因此，我们创建了一个特定的九头蛇`monster-hit`函数，每次打击都会移除头部，这相当于降低了九头蛇的生命值！![图片](httpatomoreillycomsourcenostarchimages783562.png)。此外，我们现在可以打印一条关于骑士如何砍掉这些头部的戏剧性信息！![图片](httpatomoreillycomsourcenostarchimages783560.png)
- en: The hydra’s `monster-attack` function is again similar to that for the orc.
    The one interesting difference is that we increment the health with every attack,
    so that the hydra grows a new head every turn ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 九头蛇的`monster-attack`函数与兽人的类似。一个有趣的不同之处在于，我们每次攻击都会增加生命值，这样九头蛇就能在每个回合长出新的头！![图片](httpatomoreillycomsourcenostarchimages783554.png)
- en: The Slimy Slime Mold
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 腐朽的粘液菌
- en: The slime mold is a unique monster. When it attacks you, it will wrap itself
    around your legs and immobilize you, letting the other bad guys finish you off.
    It can also squirt goo in your face. You must think quickly in battle to decide
    if it’s better to finish the slime off early in order to maintain your agility,
    or ignore it to focus on more vicious foes first. (Remember that by lowering your
    agility, the slime mold will decrease the number of attacks you can deliver in
    later rounds of battle.)
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 粘液菌是一种独特的怪物。当它攻击你时，它会缠绕在你的腿上并使你失去行动能力，让其他坏蛋完成你的任务。它还可以向你脸上喷射粘液。在战斗中你必须迅速思考，决定是早点结束粘液菌以保持你的敏捷性，还是忽略它先专注于更凶猛的敌人。（记住，通过降低你的敏捷性，粘液菌会减少你在战斗后期回合中可以发动的攻击次数。）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages780752.png.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages780752.png.jpg)'
- en: '[PRE215]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: The `monster-attack` function for the slime mold must do some special things,
    which allow it to immobilize the player. First, it uses the slime mold’s sliminess
    (which is generated when each slime mold is built) to generate a random attack
    against the player, stored in the variable `x` ![](httpatomoreillycomsourcenostarchimages783564.png).
    Unlike most other attacks in the game, this slime mold attack affects the agility
    of players, rather than their health ![](httpatomoreillycomsourcenostarchimages783562.png).
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 粘液菌的`monster-attack`函数必须做一些特殊的事情，这允许它使玩家失去行动能力。首先，它使用粘液菌的粘性（在构建每个粘液菌时生成）来生成一个针对玩家的随机攻击，存储在变量`x`中！![图片](httpatomoreillycomsourcenostarchimages783564.png)。与游戏中的大多数其他攻击不同，这种粘液菌攻击影响玩家的敏捷性，而不是他们的健康！![图片](httpatomoreillycomsourcenostarchimages783562.png)
- en: However, it would be pointless if the slime mold couldn’t attack the player’s
    health at least a little, or the battle could end awkwardly, with the player and
    slime mold frozen in place for all time. Therefore, the slime mold also has a
    superwimpy squirt attack that happens during half of all attacks ![](httpatomoreillycomsourcenostarchimages783560.png),
    but subtracts only a single health point from the player ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果粘液菌不能至少对玩家的健康造成一点伤害，或者战斗可能会尴尬地结束，玩家和粘液菌将永远冻结在原地。因此，粘液菌还有一个超级微弱的喷射攻击，在所有攻击的一半中发生！![图片](httpatomoreillycomsourcenostarchimages783560.png)，但只会从玩家那里减去一个生命值！![图片](httpatomoreillycomsourcenostarchimages783554.png)
- en: The Cunning Brigand
  id: totrans-1197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 狡猾的亡命徒
- en: The brigand is the smartest of all your foes. He can use his whip or slingshot
    and will try to neutralize your best assets. His attacks are not powerful, but
    they are a consistent two points for every round.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 亡命徒是你所有敌人中最聪明的。他可以使用他的鞭子或弹弓，并试图削弱你的最佳资产。他的攻击并不强大，但每轮都会持续造成两个点的伤害。
- en: '[PRE216]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages781748.png.jpg)'
  id: totrans-1200
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages781748.png.jpg)'
- en: The first thing the wily brigand does when performing an attack is to look at
    the player’s health, agility, and strength, and choose the `max` of those three
    as the focus of his attack ![](httpatomoreillycomsourcenostarchimages783564.png).
    If several of the attributes are equally large, the brigand will choose health
    over agility and agility over strength as the focus of attack. If health is the
    largest value, the player is hit with a slingshot ![](httpatomoreillycomsourcenostarchimages783562.png).
    If agility is the largest, the brigand will whip the player’s leg ![](httpatomoreillycomsourcenostarchimages783560.png).
    If strength is the largest, the brigand will whip the player’s arm ![](httpatomoreillycomsourcenostarchimages783554.png).
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 狡猾的强盗在发动攻击时，首先会查看玩家的健康、敏捷和力量，并选择这三个中的最大值作为攻击的重点！![图片](http://atomoreilly.com/source/no_starch_images/783564.png)。如果几个属性的大小相等，强盗会选择健康作为攻击重点，其次是敏捷，然后是力量。如果健康是最大值，玩家会被弓箭射中！![图片](http://atomoreilly.com/source/no_starch_images/783562.png)。如果敏捷是最大值，强盗会鞭打玩家的腿！![图片](http://atomoreilly.com/source/no_starch_images/783560.png)。如果力量是最大值，强盗会鞭打玩家的手臂！![图片](http://atomoreilly.com/source/no_starch_images/783554.png)。
- en: We have now completely defined all of our monsters for our game!
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完全定义了我们游戏中的所有怪物！
- en: To Battle!
  id: totrans-1203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 战斗吧！
- en: 'To start the game, call `orc-battle` from the REPL:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始游戏，请在 REPL 中调用 `orc-battle`：
- en: '[PRE217]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'That hydra with seven heads looks pretty gnarly—let’s finish it off first with
    a stab:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 那个有七个头的九头蛇看起来相当难看——让我们先给它来一刺：
- en: '[PRE218]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'No other bad guy really stands out, so we’ll try a roundhouse to bring down
    some of those health numbers overall:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他坏蛋能真正脱颖而出，所以我们将尝试一个旋风踢来降低一些整体的生命值：
- en: '[PRE219]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Great! That even killed one of the weaker enemies. Now, with full agility,
    we have three attacks per round. This means we should use our last attack to strategically
    take out some of the more powerful bad guys. Let’s use the double swing:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！甚至杀死了其中一个较弱的敌人。现在，我们有了满的敏捷性，每轮可以发动三次攻击。这意味着我们应该用最后的攻击来战略性地消灭一些更强大的坏蛋。让我们使用双击：
- en: '[PRE220]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: They got us pretty good, but we still have plenty of fight left. This battle
    isn’t over yet!
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 他们已经让我们打得很好了，但我们还有很多战斗力。这场战斗还没有结束！
- en: As you can see, careful strategy is needed if you want to survive Orc Battle.
    I hope you enjoy this new game!
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果您想在兽人战斗中生存下来，就需要谨慎的策略。希望您喜欢这款新游戏！
- en: What You've Learned
  id: totrans-1214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: 'In this chapter, we discussed the more advanced data structures in Common Lisp.
    We then used this to create a monster-fighting game. Along the way, you learned
    the following:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Common Lisp 中更高级的数据结构。然后我们用这些来创建一个怪物战斗游戏。在这个过程中，你学到了以下内容：
- en: Arrays are similar to lists, but allow you to access an item at a specific offset
    more efficiently.
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组与列表类似，但允许您更高效地访问特定偏移量的项。
- en: Hash tables are similar to alists, but let you look up the value associated
    with a key more efficiently.
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表与 alists 类似，但允许您更高效地查找与键关联的值。
- en: Using arrays and hash tables in the appropriate places will usually make your
    code much faster.
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的位置使用数组和哈希表通常会使您的代码运行得更快。
- en: The only true way to tell if changing a data structure or algorithm makes your
    program faster is to time your code with the `time` command.
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一真正的方法是使用 `time` 命令来计时，以判断更改数据结构或算法是否使您的程序更快。
- en: Common Lisp has generic functions that can be used against multiple datatypes.
    The most useful of these are sequence functions that can transparently handle
    lists, arrays, and strings.
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Common Lisp 有泛型函数，可以用于多种数据类型。其中最有用的是可以透明处理列表、数组和字符串的序列函数。
- en: You can create objects with properties in list using the `defstruct` command.
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `defstruct` 命令在列表中创建具有属性的对象。
