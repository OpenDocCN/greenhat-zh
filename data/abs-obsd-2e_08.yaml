- en: Chapter 8. Disks and Filesystems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章。磁盘和文件系统
- en: '*Oh, my head hurts bad.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*哦，我的头好痛。*'
- en: '*Rings of ones and zeros, ouch!*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*一串的0和1，真痛苦！*'
- en: '*Filesystems hide them.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件系统隐藏了它们。*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Proper data management
    is perhaps a systems administrator’s most vital duty. You can replace almost every
    computer component, but the data on your disk is irreplaceable. Perhaps that data
    isn’t important or it’s backed up, but losing files will ruin your day. As a sysadmin,
    you must protect important data by carefully managing your disks and filesystems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](httpatomoreillycomsourcenostarchimages1616079.png) 正确的数据管理可能是系统管理员最重要的职责。你可以更换几乎所有的计算机组件，但磁盘上的数据是无法替代的。也许这些数据并不重要或者已经备份，但丢失文件会毁了你的一天。作为系统管理员，你必须通过仔细管理你的磁盘和文件系统来保护重要数据。'
- en: We covered the basics of disklabels and MBR partitions in [Chapter 2](ch02.html
    "Chapter 2. Installation Preparations"), but OpenBSD lets you use and abuse disks
    and filesystems in any number of ways. You’ll learn how in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.html "第2章。安装准备")中介绍了磁盘标签和MBR分区的基础知识，但OpenBSD允许你以任何数量的方式使用和滥用磁盘和文件系统。你将在本章中学习如何做到这一点。
- en: Device Nodes
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备节点
- en: A *device node* is a file that provides a logical interface to a piece of hardware.
    By reading from a device node, sending data to it, or using a command on it, you’re
    telling the operating system to perform an action on a piece of hardware or, in
    some cases, a logical device.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*设备节点*是一个文件，它为硬件提供了一个逻辑接口。通过从设备节点读取、向其发送数据或在其上使用命令，你是在告诉操作系统对硬件或在某些情况下对逻辑设备执行操作。'
- en: Different devices behave differently when data is sent to them. For example,
    writing to the console makes text appear on the screen or terminal, while writing
    to a disk device puts data on that disk. (OpenBSD puts device nodes in */dev*
    and disallows device nodes on other filesystems.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据发送到不同的设备时，它们的行为也会有所不同。例如，向控制台写入会在屏幕或终端上显示文本，而向磁盘设备写入会将数据放在该磁盘上。（OpenBSD将设备节点放在*/dev*中，并禁止在其他文件系统上使用设备节点。）
- en: 'Many disk management programs expect to be given a device name as an argument.
    Unfortunately, device node names are frequently cryptic and vary widely among
    operating systems—even on closely related operating systems that run on the same
    hardware. To simplify your life just a bit, [Table 8-1](ch08.html#common_disk_device_node_names
    "Table 8-1. Table 8-1: Common Disk Device Node Names") lists the device node names
    for common OpenBSD disk devices.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多磁盘管理程序期望被给定一个设备名称作为参数。不幸的是，设备节点名称通常是晦涩的，并且在不同的操作系统之间差异很大——即使在同一硬件上运行的密切相关操作系统之间也是如此。为了稍微简化你的生活，[表8-1](ch08.html#common_disk_device_node_names
    "表8-1. 表8-1：常见的OpenBSD磁盘设备节点名称")列出了常见OpenBSD磁盘设备的设备节点名称。
- en: 'Table 8-1. Table 8-1: Common Disk Device Node Names'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1. 表8-1：常见的磁盘设备节点名称
- en: '| Device Node | Description |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 设备节点 | 描述 |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| */dev/fd** | Floppy disk (block) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| */dev/fd** | 软盘（块设备）|'
- en: '| */dev/rfd** | Floppy disk (raw) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| */dev/rfd** | 软盘（原始设备）|'
- en: '| */dev/wd** | IDE and some SATA disks (block) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| */dev/wd** | IDE和一些SATA磁盘（块设备）|'
- en: '| */dev/rwd** | IDE and some SATA disks (raw) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| */dev/rwd** | IDE和一些SATA磁盘（原始设备）|'
- en: '| */dev/sd** | SCSI/SAS/SATA/USB/RAID/non-IDE disk (block) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| */dev/sd** | SCSI/SAS/SATA/USB/RAID的非IDE磁盘（块设备）|'
- en: '| */dev/rsd** | SCSI/SAS/SATA/USB/RAID/non-IDE disk (raw) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| */dev/rsd** | SCSI/SAS/SATA/USB/RAID的非IDE磁盘（原始设备）|'
- en: '| */dev/cd** | CD/DVD drive (block) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| */dev/cd** | CD/DVD驱动器（块设备）|'
- en: Device names also have a number that tells you which instance of that device
    it refers to. The numbering starts at 0\. The first IDE hard drive is */dev/wd0*,
    */dev/wd1* is the second, and */dev/cd1* is the second CD drive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设备名称还有一个数字，告诉你它指的是该设备的哪个实例。编号从0开始。第一个IDE硬盘是*/dev/wd0*，*/dev/wd1*是第二个，而*/dev/cd1*是第二个CD驱动器。
- en: Every partition is assigned a letter. For example, the root partition is *a*,
    the swap area is *b*, the whole disk is *c*, and so on. Each partition also has
    a separate device node, the result of appending the partition letter to your disk
    device name. For example, if you install to a single IDE drive, your root partition
    is */dev/wd0a*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区都被分配了一个字母。例如，根分区是*a*，交换区是*b*，整个磁盘是*c*，依此类推。每个分区还有一个独立的设备节点，这是通过将分区字母附加到磁盘设备名称上得到的。例如，如果你在一个IDE驱动器上安装，你的根分区是*/dev/wd0a*。
- en: Raw and Block Devices
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始和块设备
- en: 'Notice in [Table 8-1](ch08.html#common_disk_device_node_names "Table 8-1. Table
    8-1: Common Disk Device Node Names") that devices are listed in either block or
    raw (character) mode. This refers to how the devices are accessed.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[表8-1](ch08.html#common_disk_device_node_names "表8-1. 表8-1：常见磁盘设备节点名称")中，设备以块或原始（字符）模式列出。这指的是设备是如何被访问的。
- en: Block Devices
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 块设备
- en: Hard disks are usually accessed using a block device node (sometimes called
    a *cooked* device node). When accessing a device as a block, data transmitted
    to or from the device is *buffered*, or collected until there is sufficient data
    to make accessing the device worth the trouble. Block devices are generally considered
    more efficient than raw devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘通常使用块设备节点（有时称为*熟*设备节点）进行访问。当以块的形式访问设备时，传输到或从设备的数据会被*缓冲*，或者收集到足够的数据，使得访问设备变得值得麻烦。块设备通常被认为比原始设备更高效。
- en: The device nodes for block devices are named after the device driver; for example,
    */dev/wd3*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备的设备节点以设备驱动程序命名；例如，*/dev/wd3*。
- en: Raw Devices
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始设备
- en: Raw devices are sometimes called *character* devices, because they access a
    device one character at a time. If you need to control exactly how data appears
    on a disk (for example, when creating a filesystem) use a raw device. Raw device
    nodes have an *r* in front of their name, as in */dev/rwd3*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设备有时被称为*字符*设备，因为它们一次访问一个字符。如果你需要精确控制数据在磁盘上的显示方式（例如，在创建文件系统时）使用原始设备。原始设备节点名称前有一个*r*，例如*/dev/rwd3*。
- en: Raw devices do no buffering. When you tell your system to write to a raw device,
    the data is transmitted immediately. Raw mode works best with software that provides
    its own buffering or that wants to arrange data in a specific way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原始设备不进行缓冲。当你告诉系统向原始设备写入数据时，数据会立即传输。原始模式最适合提供自身缓冲或希望以特定方式排列数据的软件。
- en: 'Here’s an easy way to remember the difference between block and raw throughput:
    Say you spill a bottle of aspirin. If you pick up each aspirin individually and
    deposit it directly in the bottle, you’re doing an unbuffered, or raw, transfer.
    If you pick up the aspirin with your right hand and collect them in your left,
    then dump a bunch into the bottle at once (along with all of the dirt from your
    floor), you’re doing a buffered transfer.^([[17](#ftn.id483068)])'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住块和原始吞吐量之间的区别有一个简单的方法：假设你洒了一瓶阿司匹林。如果你一个个地捡起阿司匹林并将其直接放入瓶中，你正在进行无缓冲的或原始的传输。如果你用右手拿起阿司匹林，用左手收集它们，然后一次性将一堆阿司匹林（连同地板上的所有灰尘）倒入瓶中，你正在进行缓冲传输.^([[17](#ftn.id483068)])
- en: Choosing Your Mode
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选择您的模式
- en: Address disks (and many other devices) as raw or block by choosing the corresponding
    device node. Some programs expect to access raw devices, while others expect block
    devices. If a program opens */dev/sd1a*, it’s accessing partition *a* on disk
    *sd1* as a block device. If it opens */dev/rsd1a*, it’s accessing the exact same
    partition as a character device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择相应的设备节点，将磁盘（以及许多其他设备）作为原始或块访问。一些程序期望访问原始设备，而另一些程序期望访问块设备。如果一个程序打开*/dev/sd1a*，它是以块设备的形式访问磁盘*sd1*上的分区*a*。如果它打开*/dev/rsd1a*，它是以字符设备的形式访问相同的分区。
- en: Regardless of the mode, the underlying hardware remains the same; the only thing
    that changes is how you exchange information with the device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论模式如何，底层硬件保持不变；唯一改变的是你与设备交换信息的方式。
- en: Device Attachment vs. Device Name
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备附加与设备名称对比
- en: Not long ago, most disks were permanently affixed to a single physical location
    on the system. If your computer had two IDE buses, each with two hard drives,
    the operating system knew exactly where to find them, usually at */wd1* and */wd2*.
    A SCSI disk had a SCSI ID and a logical unit number (LUN), and changing them required
    rebooting the computer. Traditionally, you could use the disk’s location in the
    system to identify the disk. For example, a booting i386 computer would find the
    root partition by looking for the hard drive attached to the first port on the
    first IDE controller, finding the *a* partition on that disk, and reading the
    filesystem table from that disk. You could go into the BIOS to tell the computer
    to look for the root partition on a different disk, but the computer still identified
    the disk by where it was physically attached to the computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，大多数磁盘都永久固定在系统的一个物理位置上。如果你的计算机有两个IDE总线，每个总线有两个硬盘驱动器，操作系统会确切知道它们的位置，通常在*/wd1*和*/wd2*。SCSI磁盘有一个SCSI
    ID和一个逻辑单元号（LUN），更改它们需要重新启动计算机。传统上，你可以使用磁盘在系统中的位置来识别磁盘。例如，启动的i386计算机会通过查找连接到第一个IDE控制器第一个端口的硬盘来查找根分区，找到该磁盘上的*a*分区，并从该磁盘读取文件系统表。你可以进入BIOS告诉计算机在另一个磁盘上查找根分区，但计算机仍然通过它物理连接到计算机的位置来识别磁盘。
- en: Today, disks can appear and disappear from multiple locations on the system.
    For example, you might attach and remove several flash drives as needed, or hot
    swap Serial Attached SCSI (SAS) or Serial ATA (SATA) drives from bus to bus. Physical
    location is no longer a safe way to identify a disk. While */dev/sd0* is the device
    node for the first SCSI disk, you cannot assume that the disk currently attached
    to the first SCSI port is the same disk that was plugged in there the last time
    the system booted. OpenBSD labels actual disks with unique IDs, as discussed in
    the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，磁盘可以在系统的多个位置出现和消失。例如，你可能需要根据需要连接和断开几个闪存驱动器，或者从总线到总线热插拔串行连接SCSI (SAS) 或串行ATA
    (SATA) 驱动器。物理位置不再是识别磁盘的安全方式。虽然 */dev/sd0* 是第一个SCSI磁盘的设备节点，但你不能假设当前连接到第一个SCSI端口的磁盘就是上次系统启动时插入的那个磁盘。OpenBSD使用唯一ID对实际磁盘进行标记，如下一节所述。
- en: DUIDs and /etc/fstab
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DUIDs和/etc/fstab
- en: All OpenBSD platforms use the disklabel to identify partitions and other information
    about a disk. When you label a disk (as we did in [Chapter 3](ch03.html "Chapter 3. Installation
    Walk-Through") and will do by hand later this chapter), `disklabel` adds a *disklabel
    unique identifier*, or DUID, to the disk label. The DUID is a unique hexadecimal
    number that lets OpenBSD identify a specific disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有OpenBSD平台都使用disklabel来识别分区和其他有关磁盘的信息。当你标记一个磁盘（如我们在[第3章](ch03.html "第3章。安装指南")中所述，并在本章稍后手动进行），`disklabel`会将一个*disklabel唯一标识符*，或DUID，添加到磁盘标签中。DUID是一个唯一的十六进制数字，允许OpenBSD识别特定的磁盘。
- en: 'To find a disk’s DUID, pass the device name to `disklabel` and look for the
    `duid` entry:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找磁盘的DUID，将设备名传递给`disklabel`并查找`duid`条目：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The disk currently attached as `sd0` has a DUID of `55128c3700af5491`. Even
    if you physically move the disk so that it becomes `sd9` or `sd18`, OpenBSD can
    use the DUID to uniquely identify this disk.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当前连接为`sd0`的磁盘的DUID为`55128c3700af5491`。即使你物理移动磁盘，使其变为`sd9`或`sd18`，OpenBSD也可以使用DUID来唯一识别此磁盘。
- en: 'OpenBSD uses the filesystem table */etc/fstab* to map filesystems on a disk
    to mount points using either the disk location or the DUID. Each filesystem appears
    on its own line in */etc/fstab*, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD使用文件系统表 */etc/fstab* 来将磁盘上的文件系统映射到挂载点，使用磁盘位置或DUID。每个文件系统都在 */etc/fstab*
    的单独一行上显示，如下所示：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll focus on the first entry to explore what’s going on here. The first field,
    `55128c3700af5491.b` **1**, is the location of the partition. Whereas older systems
    used the disk device name and the partition letter (such as */dev/sd0a*), newer
    systems can use the DUID, a period, and the partition letter (as in `55128c3700af5491.a`).
    By using DUIDs in the filesystem table, OpenBSD can always mount the same disk
    at the same location, no matter how it’s attached.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注第一条目来探索这里发生的事情。第一个字段，`55128c3700af5491.b` **1**，是分区的位置。而较老的系统使用磁盘设备名和分区字母（例如*/dev/sd0a*），较新的系统可以使用DUID、一个点号和分区字母（如`55128c3700af5491.a`）。通过在文件系统表中使用DUID，OpenBSD可以始终在相同的位置挂载相同的磁盘，无论其如何连接。
- en: The second field, `none` **2**, lists the *mount point*, which is the directory
    where the filesystem is attached to the directory tree. Every partition you can
    write files to is attached to a mount point (such as */usr*, */var*, and so on),
    with one partition being the root partition (*/*). Swap space uses a mount point
    of `none`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第二字段，`none` **2**，列出 *挂载点*，即文件系统附加到目录树中的目录。你可以写入文件的每个分区都附加到一个挂载点（例如 */usr*，*/var*
    等），其中一个分区是根分区 (*/*)。交换空间使用 `none` 作为挂载点。
- en: Next, `swap` **3**, is the filesystem type. The standard OpenBSD partition uses
    type `ffs`, the UNIX Fast File System. Other options include, but are not limited
    to, `msdos` (Microsoft-style FAT partitions), `mfs` (Memory File System), and
    `cd9660` (CD).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`swap` **3**，是文件系统类型。标准的 OpenBSD 分区使用类型 `ffs`，UNIX 快速文件系统。其他选项包括但不限于 `msdos`（Microsoft
    风格的 FAT 分区）、`mfs`（内存文件系统）和 `cd9660`（CD）。
- en: 'The fourth field, `sw` **4**, shows the mount options used for this filesystem.
    I’ll cover mount options in more detail in [FFS Mount Options](ch08.html#ffs_mount_options
    "FFS Mount Options"), but here are a few that frequently appear in */etc/fstab*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第四字段，`sw` **4**，显示了用于此文件系统的挂载选项。我将在[FFS 挂载选项](ch08.html#ffs_mount_options "FFS
    挂载选项")中更详细地介绍挂载选项，但这里有一些在 */etc/fstab* 中经常出现的选项：
- en: '****`ro`****. The filesystem is mounted read-only. Not even root can write
    to it.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`ro`****. 文件系统以只读方式挂载。即使是 root 也不能写入它。'
- en: '****`rw`****. The filesystem is mounted read-write.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`rw`****. 文件系统以读写方式挂载。'
- en: '****`nodev`****. Device nodes are not interpreted.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`nodev`****. 设备节点不会被解释。'
- en: '****`nosuid`****. `setuid` files are forbidden.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`nosuid`****. 禁止 `setuid` 文件。'
- en: '****`noauto`****. OpenBSD won’t automatically mount the filesystem at boot
    or when running `mount -a`. This option is useful for removable media drives that
    might not have media in them, such as CD and USB flash drives.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****`noauto`****. OpenBSD 不会在启动时或运行 `mount -a` 时自动挂载文件系统。此选项对于可能没有媒体的可移动媒体驱动器很有用，例如
    CD 和 USB 闪存驱动器。'
- en: The fifth field indicates whether `dump(8)` should back up this filesystem.
    If this field is 0 (or absent), `dump` doesn’t routinely back up the filesystem.
    Otherwise, the number given is the minimum dump level needed to back up the filesystem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第五字段表示 `dump(8)` 是否应该备份此文件系统。如果此字段为 0（或不存在），则 `dump` 不会定期备份文件系统。否则，给出的数字是需要备份文件系统的最小备份级别。
- en: The last field is the *pass number.* It tells `fsck` when to check the filesystem
    during boot. Filesystems with a pass number of 1 are checked first, filesystems
    with a pass number of 2 are checked second, and so on. A pass number of 0 tells
    `fsck` to not check the filesystem during boot. If a filesystem doesn’t have a
    pass number, it’s equivalent to 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字段是 *通过次数*。它告诉 `fsck` 在启动时何时检查文件系统。通过次数为 1 的文件系统首先检查，通过次数为 2 的文件系统其次检查，依此类推。通过次数为
    0 告诉 `fsck` 在启动时不检查文件系统。如果一个文件系统没有通过次数，则相当于 0。
- en: I strongly recommend using DUIDs in */etc/fstab* and anywhere else, rather than
    using device node names. While a device node name might change, a DUID will not.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议在 */etc/fstab* 和其他任何地方使用 DUIDs，而不是使用设备节点名称。虽然设备节点名称可能会改变，但 DUID 不会。
- en: MBR Partitions and fdisk(8)
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MBR 分区和 fdisk(8)
- en: Some hardware platforms have specific ideas about disk partitioning that differ
    from what OpenBSD expects. For example, the i386 and amd64 platforms expect to
    find MBR partitions on hard drives, and OpenBSD accommodates this quirk by putting
    its own disklabel partitions inside MBR partitions. We briefly touched on creating
    partitions during the installation process, but if you add hard drives to an existing
    system, you’ll need to edit the MBR partition table by hand using `fdisk(8)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些硬件平台对磁盘分区有特定的想法，这与 OpenBSD 的期望不同。例如，i386 和 amd64 平台期望在硬盘上找到 MBR 分区，OpenBSD
    通过在其自己的磁盘标签分区中放置自己的磁盘分区来适应这种怪癖。我们简要介绍了安装过程中的分区创建，但如果你在现有系统中添加硬盘，你需要手动使用 `fdisk(8)`
    编辑 MBR 分区表。
- en: 'My particular test system has two hard drives: *wd0* and *wd1*. I think that
    *wd1* is completely blank but before I can use this drive, I need to verify that
    it is empty, and then create MBR partitions. While `fdisk` has all sorts of commands
    to edit disks, I find the simplest way is to use the interactive disk editor.
    Run `fdisk -e` and give it the device node for the new disk.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我的特定测试系统有两个硬盘：*wd0* 和 *wd1*。我认为 *wd1* 完全为空，但在我能使用这个硬盘之前，我需要验证它是否为空，然后创建 MBR
    分区。虽然 `fdisk` 有各种编辑磁盘的命令，但我发现最简单的方法是使用交互式磁盘编辑器。运行 `fdisk -e` 并给出新硬盘的设备节点。
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The editor is minimal, but lets you view, add, remove, and edit MBR partitions.
    If you forget the commands at any time, entering `help` will print out all the
    commands `fdisk` supports.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器很简单，但让你可以查看、添加、删除和编辑MBR分区。如果你在任何时候忘记了命令，输入`help`将打印出`fdisk`支持的 所有命令。
- en: Viewing MBR Partitions
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看MBR分区
- en: 'To see the MBR partitions on the current disk, enter **`print`** or **`p`**.
    Here’s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前磁盘上的MBR分区，输入**`print`**或**`p`**。以下是一个示例：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line shows the disk geometry (as discussed in [Chapter 2](ch02.html
    "Chapter 2. Installation Preparations")). Every value in this disk’s MBR table
    is set to 0, meaning that it has no configured partitions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了磁盘几何形状（如第2章[安装准备](ch02.html "第2章。安装准备")中所述）。这个磁盘的MBR表中的每个值都设置为0，意味着它没有配置任何分区。
- en: Adding and Removing Partitions
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和删除分区
- en: Say we want to create an MBR partition on this disk. I habitually use partition
    0, but the OpenBSD installer usually uses partition 3\. The specific number you
    pick doesn’t matter unless you want multiple MBR partitions on the disk.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在磁盘上创建一个MBR分区。我习惯使用分区0，但OpenBSD安装程序通常使用分区3。你选择的特定数字并不重要，除非你想要在磁盘上有多个MBR分区。
- en: 'To edit a partition, enter **`edit`** or **`e`** followed by the partition
    number. For example, to edit partition 0, enter the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑一个分区，输入**`edit`**或**`e`**后跟分区号。例如，要编辑分区0，输入以下内容：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Conveniently, *`fdisk`* prints the current information on this MBR partition.
    Make sure it’s the partition you think it is before you muck it up.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，`fdisk`打印了当前这个MBR分区的信息。在弄乱它之前，确保它是你认为的那个分区。
- en: First, at **1**, set a partition ID. This is a label indicating what kind of
    filesystem will be on the disk. OpenBSD uses partition ID `a6`, so enter that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**1**处设置分区ID。这是一个标签，表示磁盘上会有什么类型的文件系统。OpenBSD使用分区ID `a6`，所以输入那个。
- en: The offset at **2** is the number of sectors from the beginning of the disk
    to the start of the partition. We want to use this entire disk for OpenBSD, so
    set it to `0`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**2**处的偏移量是从磁盘开始到分区开始的扇区数。我们希望使用整个磁盘来安装OpenBSD，所以将其设置为`0`。'
- en: Finally, the size at **3** is the number of sectors the MBR partition fills.
    There is no need to copy the number of sectors in the disk here; OpenBSD `fdisk`
    uses `*` to mean “all free space.”
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**3**处的尺寸是MBR分区填充的扇区数。在这里不需要复制磁盘中的扇区数；OpenBSD `fdisk`使用`*`表示“所有空闲空间”。
- en: Now print the MBR table again to check your work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次打印MBR表以检查你的工作。
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the entry for partition 0 is type A6 and extends from cylinder 0,
    head 0, sector 1, to cylinder 2088, head 167, sector 63\. It fills 33,554,304
    sectors—the same as the number of sectors in the disk. This MBR partition fills
    the entire disk.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，分区0的条目类型为A6，从磁道0，头0，扇区1开始，到磁道2088，头167，扇区63结束。它填充了33,554,304个扇区——与磁盘中的扇区数相同。这个MBR分区填充了整个磁盘。
- en: If you had recycled this disk from another operating system, it would probably
    have a partition already on it. To remove a partition, edit the partition and
    set its partition ID to 0.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从另一个操作系统回收了这个磁盘，它可能已经有一个分区了。要删除一个分区，编辑分区并将其分区ID设置为0。
- en: Making a Partition Bootable
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使分区可引导
- en: In order to boot from a hard drive, you’ll need to mark a partition as active.
    Use the `flag` command and a partition number to do this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从硬盘启动，你需要将一个分区标记为活动分区。使用`flag`命令和一个分区号来完成此操作。
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Include this hard drive in your BIOS boot order, and the computer should try
    to boot from it. Simply marking a partition as active doesn’t mean that the computer
    *can* boot from it; however, you will still need a kernel, boot loader, and all
    the other things that go into bootstrapping a computer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将这块硬盘包含到你的BIOS启动顺序中，计算机应该会尝试从它启动。仅仅将一个分区标记为活动分区并不意味着计算机*可以*从它启动；然而，你仍然需要一个内核、引导加载程序以及所有启动计算机所需的其他东西。
- en: To mark a partition as no longer active, delete and re-create it. (There is
    no `unflag` command.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个分区标记为不再活动，删除并重新创建它。（没有`unflag`命令。）
- en: Exiting fdisk
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出fdisk
- en: Once you’re satisfied with your work, enter **`quit`** or **`q`**, and `fdisk`
    should write the new MBR table to disk and exit. If you changed your mind, and
    don’t want to make any changes, enter **`abort`** or **`exit`**, and `fdisk` should
    exit without saving changes to the MBR partition table.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对你的工作满意，输入**`quit`**或**`q`**，`fdisk`应该将新的MBR表写入磁盘并退出。如果你改变了主意，不想做任何更改，输入**`abort`**或**`exit`**，`fdisk`应该退出而不保存对MBR分区表的更改。
- en: Labeling Disks
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记磁盘
- en: OpenBSD uses `disklabel` to set up partitions on all hardware platforms. We
    used `disklabel(8)` as part of the installation process, but you need to partition
    new disks before you can use them. (You can also use `disklabel` to back up, restore,
    and duplicate partition tables.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 使用 `disklabel` 在所有硬件平台上设置分区。我们在安装过程中使用了 `disklabel(8)`，但在你可以使用它们之前，你需要为新磁盘分区。（你也可以使用
    `disklabel` 来备份、恢复和复制分区表。）
- en: Viewing Labels
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看标签
- en: 'To view the current disklabel, just give the disk name as an argument. Here’s
    how to see the disklabel of the empty disk from the previous section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前的磁盘标签，只需将磁盘名称作为参数传递。以下是如何查看上一节中空磁盘的磁盘标签：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This looks much like the disklabel we saw in [Chapter 2](ch02.html "Chapter 2. Installation
    Preparations"), with a few critical differences.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在 [第 2 章](ch02.html "第 2 章。安装准备") 中看到的磁盘标签非常相似，但有几个关键的区别。
- en: First, note the device at **1**. The `disklabel` command accesses the raw device,
    but you should use the block device at the command line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意 **1** 处的设备。`disklabel` 命令访问原始设备，但你应该在命令行中使用块设备。
- en: This label at **2** has no DUID. This is the default empty disklabel. We will
    generate a DUID later.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**2** 上的这个标签没有 DUID。这是一个默认的空磁盘标签。我们稍后会生成一个 DUID。'
- en: At **3**, we see that this disk has only one partition, *c*, which represents
    the entire disk. You could create and use a filesystem on partition *c*, but it’s
    not standard practice to do so.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **3** 处，我们看到这个磁盘只有一个分区，*c*，它代表整个磁盘。你可以在分区 *c* 上创建和使用文件系统，但这不是标准做法。
- en: Creating Disklabel Partitions
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建磁盘标签分区
- en: 'The simplest way to create partitions is to use the same interactive disklabel
    editor that we used to install OpenBSD. Give the disklabel editor the `-E` flag
    and the disk name:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分区最简单的方法是使用我们用来安装 OpenBSD 的相同交互式磁盘标签编辑器。给磁盘标签编辑器传递 `-E` 标志和磁盘名称：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now you can add, remove, and edit partitions, just as in [Chapter 3](ch03.html
    "Chapter 3. Installation Walk-Through").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以添加、删除和编辑分区，就像在 [第 3 章](ch03.html "第 3 章。安装过程") 中一样。
- en: Throughout the rest of the book, we’ll edit disklabels as needed to change partition
    and filesystem characteristics.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将根据需要编辑磁盘标签以更改分区和文件系统的特性。
- en: Backing Up and Restoring Disklabels
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份和恢复磁盘标签
- en: 'Before messing with a disk, back up its disklabel so that you can fall back
    to the old label if you screw up. You can back up the disklabel with this command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在对磁盘进行操作之前，备份其磁盘标签，以便在出错时可以回滚到旧标签。你可以使用以下命令备份磁盘标签：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To apply a saved disklabel to a disk, give `disklabel` the `-R` flag, the disk
    device, and the label file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将保存的磁盘标签应用到磁盘上，给 `disklabel` 传递 `-R` 标志、磁盘设备和标签文件：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This writes the saved label to the disk. You can use saved disklabels to duplicate
    partitioning across identical disks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将保存的标签写入磁盘。你可以使用保存的磁盘标签在相同磁盘之间复制分区。
- en: Now that you have partitions, let’s put a filesystem on them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了分区，让我们在这些分区上创建一个文件系统。
- en: The Fast File System
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速文件系统
- en: OpenBSD’s filesystem, FFS, is an improved version of the filesystem shipped
    with BSD 4.4\. FFS is sometimes called UFS (for Unix File System), and many system
    utilities still use UFS.^([[18](#ftn.id416360)])
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 的文件系统，FFS，是 BSD 4.4 随附文件系统的改进版本。FFS 有时被称为 UFS（Unix 文件系统），许多系统实用程序仍然使用
    UFS.^([[18](#ftn.id416360)])
- en: FFS is designed to be fast, reliable, and able to handle the most common situations
    effectively while still supporting weird configurations. By default, OpenBSD tunes
    FFS for general use, but you can optimize it to fit your needs—whether you need
    to hold trillions of tiny files or a half dozen 30GB files. You don’t need to
    know much about FFS internals, but you should at least understand blocks, fragments,
    and inodes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: FFS 设计得既快又可靠，能够有效地处理最常见的场景，同时仍然支持奇怪的配置。默认情况下，OpenBSD 为通用用途调整了 FFS，但你可以根据需要优化它——无论是需要存储数十亿个微小的文件，还是存储六个
    30GB 的文件。你不需要了解太多关于 FFS 内部结构的知识，但至少你应该理解块、碎片和inode。
- en: FFS Versions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FFS 版本
- en: The original FFS was written in the 1980s and included hard-coded limits that
    were ample for the day. Filesystems could have up to 231-1 blocks, or just under
    a terabyte (TB). In 1983, a 1TB filesystem was unthinkable. In 2013, 1TB drives
    are cheap.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 FFS 是在 1980 年代编写的，并包含了当时足够的硬编码限制。文件系统可以有高达 2^31-1 个块，或者说接近一个太字节（TB）。在 1983
    年，一个 1TB 的文件系统是无法想象的。在 2013 年，1TB 的硬盘很便宜。
- en: For larger file systems, we have FFS version 2\. FFS2 can support filesystems
    up to 8 zettabytes—unthinkable by 2013 standards. (FFS2 is likely to reach other
    limits before hitting the filesystem size limit, mind you.) OpenBSD supports both
    FFS and FFS2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的文件系统，我们有FFS版本2。FFS2可以支持高达8泽字节（按照2013年的标准是无法想象的）的文件系统。（请注意，FFS2可能在达到文件系统大小限制之前就达到其他限制。）OpenBSD支持FFS和FFS2。
- en: The i386 and amd64 boot floppies support only FFS, not FFS2\. The installation
    CD, however, supports both. Most machines that need to boot from floppy don’t
    need FFS2, and probably don’t have a BIOS that can support 2TB drives anyway.
    The filesystem creation program `newfs(1)` is smart enough to use FFS2 on filesystems
    large enough to need it, so for most installations, you don’t need to worry about
    the difference between FFS and FFS2.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: i386和amd64引导软盘只支持FFS，不支持FFS2。然而，安装CD支持两者。大多数需要从软盘启动的机器不需要FFS2，而且可能没有可以支持2TB驱动器的BIOS。文件系统创建程序`newfs(1)`足够智能，可以在需要的情况下使用FFS2，所以对于大多数安装，你不需要担心FFS和FFS2之间的区别。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the exceedingly unlikely event that you actually require FFS2 on a machine
    that must be installed via floppy, be sure to format the critical system partitions
    of root (`/`), `/var`, and `/usr` as FFS, not FFS2\. Use FFS2 only for partitions
    that are not critical to the system. Otherwise, you won’t be able to use the installation
    disk for upgrades or emergency repairs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在极其不可能的情况下，如果你需要在必须通过软盘安装的机器上使用FFS2，请确保将根（`/`）、`/var`和`/usr`等关键系统分区格式化为FFS，而不是FFS2。仅对非关键系统分区使用FFS2。否则，你将无法使用安装盘进行升级或紧急修复。
- en: Blocks, Fragments, and Inodes
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区块、片段和inode
- en: Both FFS and FFS2 are managed through blocks, fragments, and inodes. This arrangement
    isn’t unique to FFS and FFS2; filesystems such as NTFS use data blocks and index
    nodes, too. The indexing system used by each filesystem is largely unique, however.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FFS和FFS2都通过区块、片段和inode进行管理。这种安排并不仅限于FFS和FFS2；例如，NTFS这样的文件系统也使用数据块和索引节点。然而，每个文件系统使用的索引系统在很大程度上是独特的。
- en: Blocks
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 区块
- en: '*Blocks* are sections of disk that contain data. Files are placed in one or
    more blocks. OpenBSD’s FFS uses a default block size of 16KB, or eight times the
    fragment size, whichever is smaller. Not all files are even multiples of 16KB,
    so leftover bits go in *fragments*. A fragment is one-eighth of the block size,
    or 2KB by default. A 20KB file fills one block and two fragments.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*区块*是包含数据的磁盘部分。文件放置在一个或多个区块中。OpenBSD的FFS使用默认的16KB区块大小，或八倍于片段大小，取较小者。并非所有文件都是16KB的倍数，所以剩余的位会放在*片段*中。一个片段是区块大小的八分之一，默认为2KB。一个20KB的文件会填满一个区块和两个片段。'
- en: Inodes
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Inode
- en: '*Inodes*, or index nodes, contain basic data about files, such as the file’s
    size, permissions, and the list of blocks that contain the file. Collectively,
    the data in an inode is known as *metadata*, or data about data.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*inode*，或索引节点，包含关于文件的基本数据，例如文件的大小、权限以及包含文件的块列表。inode中的数据统称为*元数据*，或关于数据的数据。'
- en: Superblocks
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 超级块
- en: You’ll also see references to *superblocks*, which are blocks that contain vital
    information about the filesystem’s size and specifications. Superblocks are so
    important that FFS makes many backup copies of them. If you need to meddle with
    superblocks, you’ve probably done something wrong or your filesystem is FUBAR.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到关于*超级块*的引用，这些块包含关于文件系统大小和规格的重要信息。超级块非常重要，因此FFS会为它们创建许多备份副本。如果你需要与超级块打交道，你可能做错了什么，或者你的文件系统出了问题。
- en: Creating FFS Filesystems
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建FFS文件系统
- en: 'Use `newfs(8)` to create FFS and FFS2 filesystems and make sure that the disk
    has a disklabel. The `newfs` command takes one argument: the partition device
    node.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`newfs(8)`创建FFS和FFS2文件系统，并确保磁盘有一个磁盘标签。`newfs`命令接受一个参数：分区设备节点。
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll see details about the filesystem size, how many blocks it includes, and
    so on. The location of each superblock backup is printed as `newfs` proceeds.
    (When computers and disks were much slower, this told the operator that the computer
    was actually doing something and hadn’t seized up.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到关于文件系统大小、包含多少区块等详细信息。随着`newfs`的进行，每个超级块备份的位置会被打印出来。（当计算机和磁盘速度较慢时，这会告诉操作员计算机实际上正在做事情，并没有卡住。）
- en: The partition size determines which filesystem `newfs` uses. Partitions smaller
    than 1TB are formatted with FFS; larger partitions with FFS2\. If you want to
    specify a particular filesystem format (yes, you can even specify the old-fashioned
    4.3BSD format if you like), use the `-O` flag. It makes no sense to demand an
    FFS filesystem on a large partition, but you might have a reason to use FFS2 on
    a small partition.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 分区大小决定了`newfs`使用的文件系统。小于1TB的分区使用FFS格式化；大于1TB的分区使用FFS2。如果你想指定特定的文件系统格式（是的，如果你喜欢，甚至可以指定老式的4.3BSD格式），请使用`-O`标志。在大型分区上要求使用FFS文件系统是没有意义的，但你可能有小分区使用FFS2的原因。
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you think you need to specify which filesystem format to use on a new filesystem,
    you’re probably wrong.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你需要指定在新的文件系统上使用哪种文件系统格式，你可能错了。
- en: FFS Mount Options
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FFS挂载选项
- en: OpenBSD can handle FFS partitions in several special ways, controlling what
    sorts of changes the filesystem supports and what sorts of files may exist. These
    are called *mount options*. You can specify mount options either when you mount
    partitions on the command line, as we’ll discuss in [Mounting and Unmounting Partitions](ch08.html#mounting_and_unmounting_partitions
    "Mounting and Unmounting Partitions"), or in */etc/fstab*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD可以以几种特殊方式处理FFS分区，控制文件系统支持哪些类型的更改以及可能存在哪些类型的文件。这些被称为**挂载选项**。你可以在命令行上挂载分区时指定挂载选项，正如我们将在[挂载和卸载分区](ch08.html#mounting_and_unmounting_partitions
    "挂载和卸载分区")中讨论的那样，或者在`/etc/fstab`中指定。
- en: Mount Options and /etc/fstab
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挂载选项和`/etc/fstab`
- en: 'Specify a filesystem’s mount options in a comma-separated list in the fourth
    field of the filesystem’s */etc/fstab* entry. For example, here’s an */etc/fstab*
    entry for the partition that contains my */home* directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统的`/etc/fstab`条目的第四字段中，以逗号分隔的列表形式指定文件系统的挂载选项。例如，以下是我`/etc/fstab`条目中包含我的`/home`目录的分区：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I’ve specified the options `rw` (read-write), `nodev` (device nodes forbidden),
    `nosuid` (`setuid` programs forbidden), and `softdep` (soft updates). I’ll cover
    these and other common mount options, and explain why you might want to use them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经指定了`rw`（读-写）、`nodev`（禁止设备节点）、`nosuid`（禁止`setuid`程序）和`softdep`（软更新）选项。我将介绍这些以及其他常见的挂载选项，并解释为什么你可能想要使用它们。
- en: Read-Only Mounts
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只读挂载
- en: If you only want to read the contents of a partition, and never write to it,
    you can mount the partition as *read-only*. In most cases, this is the safest
    way to mount a disk because you cannot alter the data on the disk or write any
    new data. If a filesystem should never change, mounting it read-only might make
    sense.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想读取分区的内容，而永远不会写入它，你可以将分区挂载为**只读**。在大多数情况下，这是挂载磁盘最安全的方式，因为你不能更改磁盘上的数据或写入任何新数据。如果一个文件系统永远不会改变，将其挂载为只读可能是有意义的。
- en: Read-only mounts are especially valuable when a particular filesystem is damaged.
    While OpenBSD won’t let you perform a standard read-write mount on a damaged or
    dirty filesystem, it can often mount those filesystems read-only. This gives you
    a chance to recover some data from the partition. (Not a large chance, but a chance.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定的文件系统损坏时，只读挂载特别有价值。虽然OpenBSD不允许你在损坏或脏文件系统上执行标准的读-写挂载，但它通常可以以只读方式挂载这些文件系统。这给你提供了一个从分区中恢复一些数据的机会。（机会不大，但总是一个机会。）
- en: To mount a filesystem read-only, use the option `rdonly` or `ro`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件系统挂载为只读，请使用选项`rdonly`或`ro`。
- en: Read-Write Mounts
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读-写挂载
- en: If you want to both read from and write to the disk, you’ll want to mount the
    partition as *read-write*. By default, OpenBSD mounts all partitions as read-write.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你既想从磁盘读取又想写入磁盘，你需要将分区挂载为**读-写**模式。默认情况下，OpenBSD会将所有分区挂载为读-写模式。
- en: Use the option `rw` to explicitly configure read-write mounts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选项`rw`来明确配置读-写挂载。
- en: On modern hardware, I recommend using soft updates in conjunction with read-write
    mounts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代硬件上，我建议结合使用软更新和读-写挂载。
- en: Synchronous Mounts
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 同步挂载
- en: Using a synchronous mount is the safest way to mount a filesystem. OpenBSD can
    read data from a synchronous-mounted partition as fast as the hardware permits.
    Whenever you write to the disk, however, the kernel feeds a chunk of data to the
    disk, waits to receive confirmation that the disk has accepted the data and written
    it to disk, and then tells the program that requested the write that the data
    is now on disk.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步挂载是挂载文件系统的最安全方式。OpenBSD可以从同步挂载的分区以硬件允许的速度读取数据。然而，每次你向磁盘写入数据时，内核都会向磁盘发送一块数据，等待接收磁盘已接受数据并将其写入磁盘的确认，然后告诉请求写入的程序数据现在已在磁盘上。
- en: 'You should know that even if you’re using a synchronous mount, most hard drives
    lie about whether they have actually written the data to disk. These drives perform
    *write caching*, where writes are cached in a small flash or RAM buffer on the
    disk itself before the drive actually writes the data. This raises the question:
    Is a synchronous mount really synchronous? Hard drive vendors usually claim that
    in the event of a power failure, these disks retain just enough power to write
    the cache to disk.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，即使您使用的是同步挂载，大多数硬盘都会谎称它们实际上是否已将数据写入磁盘。这些硬盘执行 *写入缓存*，在驱动器实际写入数据之前，将写入缓存到磁盘本身的小型闪存或
    RAM 缓冲区中。这提出了一个问题：同步挂载真的是同步的吗？硬盘供应商通常声称，在断电的情况下，这些磁盘保留足够的电力将缓存写入磁盘。
- en: Although they provide the greatest data integrity in the case of a crash, synchronous
    mounts are slow. You might use synchronous mounts when data integrity is crucial,
    but in most cases, it’s overkill and you have little ability to verify that the
    mount is truly synchronous.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们在崩溃情况下提供最大的数据完整性，但同步挂载较慢。当数据完整性至关重要时，您可能会使用同步挂载，但在大多数情况下，这是过度杀鸡用牛刀，并且您几乎没有能力验证挂载是否真正同步。
- en: Activate synchronous mounts with the `sync` keyword.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sync` 关键字激活同步挂载。
- en: Asynchronous Mounts
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步挂载
- en: To write data quickly, but with a higher risk of data loss, mount partitions
    asynchronously. When using asynchronous mounts, the kernel informs software that
    all disk writes are successful before the disk confirms that the data was written.
    This is fast, but a system failure can leave inconsistent data on your disk.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速写入数据，但风险更高的数据丢失，异步挂载分区。当使用异步挂载时，内核在磁盘确认数据已写入之前，会通知软件所有磁盘写入均成功。这很快，但系统故障可能会在您的磁盘上留下不一致的数据。
- en: Asynchronous mounts are useful when restoring a filesystem from backup, because
    if you get a power failure halfway through the restore procedure, you’ll need
    to start over anyway. Don’t use asynchronous mounts in production if you care
    about your data or would object to re-creating the filesystem.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在从备份恢复文件系统时，异步挂载很有用，因为如果在恢复过程中中途断电，您无论如何都需要重新开始。如果您关心数据或反对重新创建文件系统，请不要在生产环境中使用异步挂载。
- en: Activate asynchronous mounts with the `async` keyword.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 关键字激活异步挂载。
- en: Soft Update Mounts
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 软更新挂载
- en: Soft update mounts organize and arrange disk writes so that filesystem metadata
    remains consistent at all times. This gives performance similar to that of an
    asynchronous mount with the reliability of a synchronous mount. While that doesn’t
    mean that all data will be written to disk—a power failure at the wrong moment
    will result in lost data—using soft updates prevents a lot of filesystem integrity
    problems caused by that lost data. It’s not the default because some older, smaller
    hardware doesn’t have enough memory to support it, but if you’re using modern
    i386 and amd64 hardware, I recommend enabling soft updates for all FFS partitions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 软更新挂载组织并安排磁盘写入，以确保文件系统元数据始终保持一致性。这提供了与异步挂载相似的性能，同时具有同步挂载的可靠性。虽然这并不意味着所有数据都会写入磁盘——在错误的时间断电会导致数据丢失——但使用软更新可以防止由丢失数据引起的大量文件系统完整性问题。这不是默认设置，因为一些较旧、较小的硬件没有足够的内存来支持它，但如果您使用现代
    i386 和 amd64 硬件，我建议为所有 FFS 分区启用软更新。
- en: To mount a filesystem with soft updates, use the `softdep` option.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要以软更新方式挂载文件系统，请使用 `softdep` 选项。
- en: “Don’t Track Access Time” Mounts
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: “不跟踪访问时间”挂载
- en: FFS records the last time a file was read, executed, or otherwise viewed. Updating
    these access times consumes a small but measurable amount of disk I/O and performance.
    You can use the `noatime` mount option to tell OpenBSD to not update the access
    time on any file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: FFS 记录文件最后被读取、执行或以其他方式查看的时间。更新这些访问时间会消耗一小部分但可测量的磁盘 I/O 和性能。您可以使用 `noatime` 挂载选项来告诉
    OpenBSD 不要更新任何文件的访问时间。
- en: Using `noatime` makes sense on laptops, where minimizing power usage is critical.
    If you’re tempted to use this option on your server to squeeze out a little extra
    performance, you should buy a faster disk instead. Some software, such as the
    Mutt mail client, will break if run on filesystems mounted `noatime`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在笔记本电脑上使用 `noatime` 有意义，因为最小化功耗至关重要。如果您想在自己的服务器上使用此选项以获得一点额外的性能，您应该购买更快的磁盘。一些软件，如
    Mutt 邮件客户端，如果在挂载 `noatime` 的文件系统上运行，将会损坏。
- en: No Device Nodes Permitted Mount
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无设备节点允许挂载
- en: By using the `nodev` mount option, you can tell OpenBSD to not interpret any
    device nodes on any given filesystem. Intruders can try to create “rogue” device
    nodes and use them to write files or attack the network, but if the kernel won’t
    recognize those device nodes, it cuts off this whole category of attacks.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `nodev` 挂载选项，你可以告诉 OpenBSD 不要解释任何给定文件系统上的任何设备节点。入侵者可能会尝试创建“恶意”的设备节点并使用它们来写入文件或攻击网络，但如果内核不会识别这些设备节点，那么它就会切断这一类攻击。
- en: This type of mount is also useful if you have hard drives from multiple operating
    systems on your computer. For example, if you dual-boot OpenBSD and Linux on your
    computer, but you don’t want to accidentally access a Linux device node when using
    OpenBSD, the `nodev` option will prevent you from doing so. (You might think you
    would notice that you had typed */linux/dev/hda* rather than */dev/wd1*, but never
    underestimate your ability to screw up.) In most cases, the partition containing
    */dev* is the only one that should contain device nodes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的计算机上有来自多个操作系统的硬盘，这种挂载类型也非常有用。例如，如果你的计算机上双启动了 OpenBSD 和 Linux，但你不想在使用 OpenBSD
    时意外访问 Linux 设备节点，`nodev` 选项将阻止你这样做。（你可能认为你会注意到你输入了 */linux/dev/hda* 而不是 */dev/wd1*，但永远不要低估你出错的能力。）在大多数情况下，包含
    */dev* 的分区应该是唯一包含设备节点的分区。
- en: Execution Forbidden Mounts
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行禁止挂载
- en: The `noexec` mount option prevents any binaries on the partition from being
    executed. Mounting */home* with the `noexec` option helps prevent users from installing
    and running their own programs, but for it to be effective, you’ll need to make
    sure users can’t install binaries in any shared areas, such as */tmp* and */var/tmp*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexec` 挂载选项阻止分区上的任何二进制文件被执行。使用 `noexec` 选项挂载 */home* 可以帮助防止用户安装和运行他们自己的程序，但要使其有效，你需要确保用户不能在任何共享区域（如
    */tmp* 和 */var/tmp*）中安装二进制文件。'
- en: Note that forbidding execution of binaries doesn’t prevent users from running
    interpreted scripts from that partition. Maybe the users can’t run a compiled
    C program, but if they can run `perl $HOME/rootkit.pl`, then `noexec` won’t slow
    them down very much.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，禁止执行二进制文件不会阻止用户从该分区运行解释脚本。也许用户不能运行编译的 C 程序，但如果他们可以运行 `perl $HOME/rootkit.pl`，那么
    `noexec` 不会对他们造成太大的影响。
- en: setuid Forbidden
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: setuid 禁止
- en: The `nosuid` option disallows `setuid` behavior from programs on this filesystem.
    Many partitions should not have `setuid` files, and setting this is an easy way
    to disrupt them. OpenBSD sets this on partitions such as */home* and */tmp* by
    default. You must carefully place this option on all user-writable filesystems
    for it to prevent undesired behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`nosuid` 选项禁止在此文件系统上的程序执行 `setuid` 行为。许多分区不应该有 `setuid` 文件，设置这个选项是一个很好的方法来破坏它们。OpenBSD
    默认在 */home* 和 */tmp* 等分区上设置此选项。你必须仔细地将此选项放置在所有用户可写文件系统上，以便它防止不希望的行为。'
- en: Do Not Automatically Mount This Filesystem
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要自动挂载此文件系统
- en: '`noauto` isn’t actually a mount option, but rather a way of telling OpenBSD
    to not mount a given partition listed in */etc/fstab* at boot. I frequently make
    */etc/fstab* entries for removable media drives, but the system should not try
    to mount these at boot. The boot will hang if a partition required by */etc/fstab*
    is not available, and I don’t want my computer to refuse to boot just because
    I unplugged a flash drive.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`noauto` 实际上不是一个挂载选项，而是一种告诉 OpenBSD 在引导时不挂载 */etc/fstab* 中列出的给定分区的办法。我经常为可移动媒体驱动器创建
    */etc/fstab* 条目，但系统不应该在引导时尝试挂载这些分区。如果 */etc/fstab* 所需的分区不可用，引导将会挂起，我不想因为拔掉了闪存驱动器而导致我的计算机无法启动。'
- en: Filesystem Integrity
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统完整性
- en: Both versions of FFS go to a great deal of trouble to ensure that the data on
    disk is correct and intact. The blocks that contain a file should be recorded
    in an inode, the inodes should all be referenced by directory entries, and so
    on. When you remove a file, all references to that file should be removed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 两种版本的 FFS 都非常努力地确保磁盘上的数据是正确且完整的。包含文件的块应该记录在inode中，inode应该由目录条目引用，等等。当你删除一个文件时，应该删除对该文件的全部引用。
- en: After a system failure, however, data might not be consistent. Metadata might
    reference blocks that were previously erased; a file might be in a different location
    than the inode record specifies; and the filesystem might have all kinds of references
    pointing to things that have moved, changed, or disappeared. These inconsistent,
    or *dirty*, filesystems cannot be trusted and must be rationalized, or *cleaned*,
    before you can mount them read-write. If you mount a dirty filesystem read-only,
    it might only panic your system, but if you force OpenBSD to mount a dirty filesystem
    read-write, you will damage the dirty filesystem even more.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，系统故障后，数据可能不一致。元数据可能引用之前已擦除的块；文件可能位于inode记录指定的不同位置；文件系统可能包含各种指向已移动、更改或消失的项目的引用。这些不一致的，或*脏的*文件系统不可信，在您将其挂载为读写之前必须进行合理化，或*清理*。如果您以只读方式挂载脏文件系统，它可能会使您的系统恐慌，但如果您强制OpenBSD以读写方式挂载脏文件系统，您将使脏文件系统受到更多损害。
- en: At boot, OpenBSD performs a minimal inspection and cleaning, or *preening*,
    of the filesystems and will automatically correct any minor problems found. If
    preening cannot fully clean the filesystem, the boot will hang until you intervene.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，OpenBSD会对文件系统执行最小检查和清理，或*梳理*，并将自动纠正发现的任何小问题。如果梳理无法完全清理文件系统，则启动将挂起，直到您干预。
- en: 'When confronted with a dirty filesystem, you have a few options: use the filesystem
    checking tool `fsck(8)`, debug the filesystem with `fsdb(8)` and `clri(8)`, or
    throw the filesystem away and run `newfs(8)`. Most of the time, you’ll attempt
    to repair the filesystem with `fsck`. Using `fsdb` successfully requires more
    knowledge about FFS innards than I possess, so I recommend it to only those who
    really want to develop an in-depth knowledge of FFS and have a whole bunch of
    time to devote to it. Rebuilding the filesystem with `newfs` destroys everything
    on the filesystem, but it’s a decent choice for partitions that contain only ephemeral
    data, such as */usr/obj*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 面对脏文件系统时，您有几个选择：使用文件系统检查工具 `fsck(8)`，使用 `fsdb(8)` 和 `clri(8)` 调试文件系统，或者丢弃文件系统并运行
    `newfs(8)`。大多数时候，您会尝试使用 `fsck` 修复文件系统。成功使用 `fsdb` 需要更多关于FFS内部结构的知识，所以我只推荐给那些真正想要深入了解FFS并且有大量时间投入的人。使用
    `newfs` 重建文件系统会破坏文件系统上的所有内容，但它对于只包含临时数据的分区来说是一个不错的选择，例如 */usr/obj*。
- en: You can use `dump(8)` to copy the damaged filesystem before trying any of the
    repairs. This gives you the option to fall back to the current state if attempts
    at repairing the disk fail. (If you have to do this, though, you should probably
    reevaluate your backup strategy.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何修复之前，您可以使用 `dump(8)` 来复制损坏的文件系统。这为您提供了在修复磁盘失败时回退到当前状态的选择。（如果您不得不这样做，那么您可能需要重新评估您的备份策略。）
- en: Running fsck
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行 fsck
- en: 'If you try to mount a dirty filesystem either at boot time or during routine
    operation, you’ll see a message that looks like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在启动时或常规操作期间挂载脏文件系统，您将看到一条类似以下的消息：
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `fsck(8)` program is a frontend for several filesystem-specific integrity-checking
    programs. When you run it, `fsck` identifies the type of filesystem and calls
    the correct integrity checker for you. Run `fsck` by giving it the device name
    of the filesystem you want to check:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsck(8)` 程序是几个文件系统特定完整性检查程序的界面。当您运行它时，`fsck` 识别文件系统的类型，并为您调用正确的完整性检查器。通过提供您要检查的文件系统的设备名称来运行
    `fsck`：'
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can use either the raw or cooked device name; `fsck` is smart enough to
    use the raw node even if you give the cooked device name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用原始或烹饪设备名称；`fsck` 足够智能，即使您提供了烹饪设备名称，也会使用原始节点。
- en: Examining the filesystem can take quite a while, so be patient.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件系统可能需要相当长的时间，所以请耐心等待。
- en: 'When run on a dirty filesystem, `fsck` will probably find a number of problems:
    blocks that have become disassociated from their inodes, inodes that reference
    empty blocks, and so on. It can often make a good guess as to how everything fits
    together.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当在脏文件系统上运行时，`fsck` 可能会发现许多问题：与inode失去关联的块、引用空块的inode等。它通常可以很好地猜测一切是如何组合在一起的。
- en: When `fsck` finds a problem that it isn’t absolutely sure about, it will suggest
    a fix and ask if you want to make the change. If you answer `y`, `fsck` makes
    the change. If you answer `n`, `fsck` leaves the filesystem unchanged. If you
    tell `fsck` not to make the change it suggests, the filesystem will still be dirty,
    and you’ll need to fire up `fsdb` or `clri` and make the change you think more
    appropriate.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fsck` 发现它并不完全确定的问题时，它会建议一个修复方案并询问你是否想要进行更改。如果你回答 `y`，`fsck` 会进行更改。如果你回答 `n`，`fsck`
    将保持文件系统不变。如果你告诉 `fsck` 不要执行它建议的更改，文件系统仍然会是脏的，你需要启动 `fsdb` 或 `clri` 并进行你认为更合适的更改。
- en: Sometimes, `fsck` can’t identify the name or directory of a file recovered from
    a damaged filesystem. These files go into the partition’s *lost+found* directory
    (for example, */usr/lost+found*). You’ll need to use programs such as `grep` and
    `strings` to try to identify these files by their contents.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`fsck` 无法识别从损坏的文件系统中恢复的文件的名字或目录。这些文件会进入分区的 *lost+found* 目录（例如，*/usr/lost+found*）。你需要使用
    `grep` 和 `strings` 等程序尝试通过其内容来识别这些文件。
- en: Blindly Trusting fsck
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 盲目信任 fsck
- en: Those of us who lack the skills to debug a filesystem find ourselves in a difficult
    situation, where we can either accept that `fsck(8)` knows what’s best or just
    restore from backup. If your filesystem was performing a lot of disk I/O just
    before system failure, `fsck` might need to make dozens or hundreds of changes.
    You could spend an hour sitting at the console pressing `y` repeatedly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中那些缺乏调试文件系统技能的人发现自己处于一个困难的情况，我们只能接受 `fsck(8)` 知道最好的，或者只是从备份中恢复。如果你的文件系统在系统故障前进行了大量的磁盘
    I/O，`fsck` 可能需要做出数十或数百次更改。你可能会花一个小时坐在控制台重复按 `y`。
- en: If you decide to trust `fsck` and hope it’s right, run `fsck -y`. This means
    “answer `y` to every question.” You might wind up with the entire contents of
    the filesystem in the *lost+found* directory, or you might lose every file on
    the filesystem. But unless you’re intimately familiar with the innards of FFS,
    you would need to restore from backup anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定信任 `fsck` 并希望它是正确的，运行 `fsck -y`。这意味着“对每个问题回答 `y`”。你可能会在 *lost+found* 目录中找到文件系统的全部内容，或者你可能会丢失文件系统上的所有文件。但除非你非常熟悉
    FFS 的内部结构，否则你仍然需要从备份中恢复。
- en: If you run `fsck` and realize partway through that you would like to answer
    `y` to all the questions that follow, enter `F`. That tells `fsck` to answer `y`
    to all remaining questions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `fsck` 并在途中意识到你希望回答 `y` 给所有后续的问题，请输入 `F`。这告诉 `fsck` 对所有剩余的问题回答 `y`。
- en: At the end of the procedure, you’ve either recovered your system or need to
    restore from backup.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序结束时，你已经恢复了系统或需要从备份中恢复。
- en: What’s Currently Mounted?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前已挂载的内容是什么？
- en: 'While performing routine work, inevitably you’ll need to check which disks
    are currently mounted and which are not. To see a list of all mounted filesystems
    and their mount options, run `mount(8)` without any options:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行常规工作时，不可避免地你需要检查哪些磁盘当前已挂载，哪些未挂载。要查看所有挂载的文件系统和它们的挂载选项，请在没有任何选项的情况下运行 `mount(8)`：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Both FFS and FFS2 partitions show up as `type ffs`. The word `local` means that
    the partition is on a physical drive attached to this machine. We covered the
    various mount options (`nodev`, `nosuid`, and so on) earlier in this chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: FFS 和 FFS2 分区都显示为 `type ffs`。单词 `local` 表示分区位于连接到此机器的物理驱动器上。我们已经在本章前面介绍了各种挂载选项（如
    `nodev`、`nosuid` 等）。
- en: Note that `mount` displays the device node mounted at each partition, not the
    DUID. If you want to see the DUID of a disk, check the disklabel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`mount` 显示的是每个分区挂载的设备节点，而不是 DUID。如果你想查看磁盘的 DUID，请检查磁盘标签。
- en: Mounting and Unmounting Partitions
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载和卸载分区
- en: To attach filesystems to your directory tree, or *mount* them, use `mount(8)`.
    If you’ve never manually mounted filesystems before, boot your OpenBSD machine
    into single-user mode (see [Chapter 5](ch05.html "Chapter 5. The Boot Process"))
    and follow along.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件系统附加到你的目录树或 *mount* 它们，请使用 `mount(8)`。如果你以前从未手动挂载过文件系统，请将 OpenBSD 机器引导到单用户模式（参见
    [第五章](ch05.html "第五章。引导过程")) 并按照说明操作。
- en: 'In single-user mode, OpenBSD mounts only one partition: the root partition,
    which it mounts read-only. The root partition contains just enough of the system
    to perform basic setup, establish core services, and find the other filesystems.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下，OpenBSD 只挂载一个分区：根分区，它将其挂载为只读。根分区包含足够的系统来执行基本设置、建立核心服务和找到其他文件系统。
- en: Because filesystems other than the root are not mounted, their content is not
    accessible. Look in, say, */usr* on a system in single-user mode, and you’ll find
    that it’s empty. OpenBSD hasn’t lost the files; it just hasn’t mounted the partition
    containing those files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为除了根文件系统之外的其他文件系统没有被挂载，所以它们的内容是不可访问的。在单用户模式下查看系统中的 */usr*，你会发现它是空的。OpenBSD
    并没有丢失这些文件；它只是还没有挂载包含这些文件的分区。
- en: To get any real work done in single-user mode, you probably need to mount other
    filesystems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在单用户模式下完成任何实际工作，你可能需要挂载其他文件系统。
- en: Mounting Standard Filesystems
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载标准文件系统
- en: 'To manually mount a single filesystem listed in */etc/fstab*, give `mount(8)`
    the name of the filesystem you want to mount. Here, we’ll mount our */usr* partition:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动挂载 */etc/fstab* 中列出的单个文件系统，给 `mount(8)` 提供你想要挂载的文件系统的名称。在这里，我们将挂载我们的 */usr*
    分区：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This mounts the partition exactly as described in */etc/fstab*, with all the
    options specified therein.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以 */etc/fstab* 中描述的精确方式挂载分区，其中包含所有指定的选项。
- en: 'To mount all of the partitions listed in */etc/fstab*, give `mount` the `-a`
    flag:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载 */etc/fstab* 中列出的所有分区，给 `mount` 提供 `-a` 标志：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All of your filesystems (except those not listed in */etc/fstab* and those with
    the `noauto` option) should now be mounted.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该挂载所有你的文件系统（除了那些在 */etc/fstab* 中未列出的和那些带有 `noauto` 选项的文件系统）。
- en: Mounting at Nonstandard Locations
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在非标准位置挂载
- en: Perhaps you must mount a filesystem at a location not specified in */etc/fstab*.
    I do this most commonly when adding a disk to a machine. To mount a partition
    at a location other than that specified in */etc/fstab*, or to mount a partition
    without an */etc/fstab* entry, give the partition device name and the mount point.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你必须在 */etc/fstab* 中未指定的位置挂载一个文件系统。我通常在向机器添加磁盘时这样做。要在 */etc/fstab* 中指定的位置之外挂载分区，或者要挂载没有
    */etc/fstab* 条目的分区，给出分区设备名称和挂载点。
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You must use the full path for the device node, not just the brief device node
    name.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用设备节点的完整路径，而不仅仅是简短的设备节点名称。
- en: Instead of the path to the device node, you could use the DUID, a period, and
    the partition letter, but on the command line, that’s more painful than using
    the path to the device node.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 DUID、一个点和分区字母代替设备节点的路径，但在命令行上，这比使用设备节点的路径更痛苦。
- en: Unmounting Partitions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卸载分区
- en: 'To disconnect a filesystem from the directory tree, use `umount(8)` on a mount
    point. (Note that there is only one `n` in this command.) Here, we’ll use `umount`
    to unmount our */usr* partition:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要从目录树中断开文件系统，在挂载点上使用 `umount(8)`。注意这个命令中只有一个 `n`。在这里，我们将使用 `umount` 来卸载我们的 */usr*
    分区：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You cannot unmount filesystems that are in use by any program. Even a command
    prompt in the mounted directory will prevent you from unmounting the partition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能卸载被任何程序使用的文件系统。即使在挂载目录中的命令提示符也会阻止你卸载分区。
- en: 'To unmount all partitions except the root partition, pass `umount` the `-a`
    flag:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载除了根分区之外的所有分区，给 `umount` 提供 `-a` 标志：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As programs almost certainly have files open on every partition, this probably
    works only in single-user mode. Note that you don’t need to unmount all partitions
    to leave single-user mode.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序几乎肯定在每个分区上都有文件打开，这可能在单用户模式下才能工作。请注意，你不需要卸载所有分区就可以离开单用户模式。
- en: Mounting with Options
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用选项挂载
- en: Suppose you pull a disk from a decommissioned OpenBSD machine and you need to
    retrieve some files from it. You want to mount the disk read-only so that you
    don’t change any of the files on the disk. To manually mount a partition with
    options not specified in */etc/fstab*, use the `-o` flag.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从一个退役的 OpenBSD 机器中取出一个磁盘，并且你需要从它那里检索一些文件。你想要以只读方式挂载磁盘，这样你就不改变磁盘上的任何文件。要手动挂载一个在
    */etc/fstab* 中未指定选项的分区，使用 `-o` 标志。
- en: 'For example, if the disk shows up as */dev/sd0* and you want to mount partition
    *a*, run this command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果磁盘显示为 */dev/sd0* 并且你想挂载分区 *a*，运行以下命令：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To prevent old software from running on your newer system, it might be a good
    idea to use some of the options we covered earlier, such as `noexec`, `nodev`,
    and `nosuid`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止旧软件在你的新系统上运行，使用我们之前提到的某些选项可能是个好主意，例如 `noexec`、`nodev` 和 `nosuid`。
- en: How Full Is That Partition?
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区有多少空间？
- en: To get an idea how much free space remains on your partitions, use `df(1)`.
    This program displays the total number of filesystem blocks on each partition,
    how many blocks are in use, and how many blocks are free. It also gives you the
    percent in use.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解你的分区中剩余多少可用空间，请使用`df(1)`。这个程序显示每个分区上的总文件系统块数，已使用的块数，以及空闲的块数。它还提供了使用百分比。
- en: 'One annoying thing about `df` is that it offers this information in 512-byte
    blocks by default. This was fine when disks were much smaller, but today, it’s
    like measuring the distance of an airplane flight in yards. Some people have done
    this for so long that they automatically perform block transformations in the
    back of their mind.^([[19](#ftn.id425288)]) For the rest of us, the `-h` flag
    tells `df` to provide human-readable output, such as megabytes or gigabytes, giving
    us something like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`df`的一个令人烦恼的事情是它默认以512字节块提供这些信息。当磁盘很小的时候，这没问题，但今天，这就像用码尺测量飞机航程的距离。有些人已经这样做了很长时间，以至于他们在潜意识里自动执行块转换。^([[19](#ftn.id425288)])
    对于我们其他人来说，`-h`标志告诉`df`提供人类可读的输出，如兆字节或千兆字节，给我们这样的信息：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might wonder why the */home* partition in this example has negative free
    space. How is that possible? By default, FFS reserves 5 percent of each partition
    for moving files and reducing fragmentation. When you exceed 100 percent disk
    utilization, you begin tapping into this reserved space.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么这个例子中的*/home*分区有负的空闲空间。这是怎么可能的？默认情况下，FFS为移动文件和减少碎片保留了每个分区的5%。当你超过100%的磁盘利用率时，你开始使用这部分保留空间。
- en: FFS performance degrades quickly when the partition is overfull. It’s best to
    keep some free space on your disk so that FFS can defragment itself.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当分区过满时，FFS的性能会迅速下降。最好在磁盘上保留一些空闲空间，以便FFS可以自我碎片化。
- en: You can reduce the amount of space FFS reserves, but doing so will impact performance.
    See `tunefs(8)` for instructions on how to shoot yourself in the foot.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以减少FFS保留的空间量，但这样做会影响性能。有关如何“自毁”的说明，请参阅`tunefs(8)`。
- en: What’s All That Stuff?
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有这些是什么东西？
- en: When you see a partition is full, the obvious question is “What’s filling up
    my disk?” Every hard drive I’ve ever owned has gradually filled up for no apparent
    reason. You can identify individual large files with `ls -l`, but recursively
    examining every directory in the filesystem is impractical and tedious (not to
    mention annoying).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到分区已满时，一个明显的问题就是“是什么占满了我的磁盘？”我拥有的每一块硬盘都是逐渐满的，没有明显的原因。你可以使用`ls -l`来识别单个大文件，但递归检查文件系统中的每个目录既不实际又繁琐（更不用说令人烦恼了）。
- en: To check the number of filesystem blocks used within each directory below the
    current directory, use `du(1)`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前目录以下每个目录中使用的文件系统块数，请使用`du(1)`。
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When I run `du` in my home directory, I get 700 entries; of those, 563 are related
    to some Mozilla tool. This kind of list intimidates the new sysadmin and makes
    the experienced sysadmin work too hard. Rather than cull through this list manually,
    tell `du` to show only the total for directories in the current directory, and
    then sort the output so that the largest directories appear first.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在我的家目录中运行`du`时，我得到700个条目；其中563个与某些Mozilla工具有关。这样的列表会吓到新系统管理员，并让有经验的系统管理员工作过于辛苦。与其手动筛选这个列表，不如告诉`du`只显示当前目录中目录的总计，然后对输出进行排序，以便最大的目录首先出现。
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I now know why my */home* partition is full.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在知道为什么我的*/home*分区满了。
- en: You can tell `du` to display human-readable values with the `-h` flag, but doing
    so will show values in a mix of gigabytes, megabytes, and kilobytes, making `sort`
    far less useful.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-h`标志告诉`du`显示人类可读的值，但这样做会在千兆字节、兆字节和千字节之间混合显示值，使得`sort`变得不那么有用。
- en: Setting $BLOCKSIZE
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置$BLOCKSIZE
- en: Many disk tools—including, but not limited to, `du(1)` and `df(1)`—display information
    in 512-byte blocks. If you’re accustomed to working in blocks, you probably won’t
    mind seeing them. If you’re not used to working in blocks, however, they’ll probably
    make you want to tear out your hair.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 许多磁盘工具包括但不限于`du(1)`和`df(1)`，都是以512字节块为单位显示信息的。如果你习惯于以块为单位工作，你可能不会介意看到它们。然而，如果你不习惯以块为单位工作，它们可能会让你想拔掉自己的头发。
- en: The environment variable `BLOCKSIZE` tells these programs to display information
    using blocks of a different size. If you set `BLOCKSIZE` to `K`, `df` and `du`
    will display totals in kilobytes. If you set it to `M`, these tools will show
    megabytes instead. Check your shell manual page or the dotfiles in your home directory
    for examples of setting environment variables.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量 `BLOCKSIZE` 告诉这些程序使用不同大小的块来显示信息。如果您将 `BLOCKSIZE` 设置为 `K`，`df` 和 `du` 将以千字节显示总数。如果您将其设置为
    `M`，这些工具将显示兆字节。检查您的 shell 手册页或您家目录中的 dotfiles 以获取设置环境变量的示例。
- en: Adding New Hard Disks
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新硬盘
- en: The OpenBSD installer walks you through formatting and partitioning your initial
    hard disks. If you need to add a disk to an existing system, however, you must
    run these commands yourself. The good news is that if you can install OpenBSD,
    you already know how to use the commands, and the only hard part is learning which
    commands to run.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 安装程序会引导您格式化和分区初始硬盘。如果您需要向现有系统添加磁盘，则必须自行运行这些命令。好消息是，如果您能安装 OpenBSD，您就已经知道如何使用这些命令了，唯一困难的部分是学习要运行哪些命令。
- en: I’ll show you how to move */home* to a new disk as an example. You could create
    a new partition on your existing disk if you have some empty space, but that would
    eliminate the need for this example, so I’m going to pretend I never gave you
    that advice. (Also, moving partitions to a separate disk controller channel will
    improve performance.)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以将 */home* 移动到新磁盘为例向您展示。如果您现有磁盘上有一些空闲空间，您可以在磁盘上创建一个新的分区，但那样就会消除这个示例的需要，所以我将假装我从未给你那个建议。（此外，将分区移动到单独的磁盘控制器通道可以提高性能。）
- en: Warning
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: Before touching anything involving disk partitioning or filesystems, back up
    your system. Verify that backup before starting. You have been warned.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸任何涉及磁盘分区或文件系统的内容之前，请备份您的系统。在开始之前验证备份。您已经被警告了。
- en: Creating an MBR Partition
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 MBR 分区
- en: 'The i386 and amd64 platforms require disks to have MBR partitions as well as
    OpenBSD partitions. A standard new disk needs a single OpenBSD MBR partition covering
    the entire disk. Passing the `-i` argument to `fdisk` does exactly this. Let’s
    create a new MBR partition on `wd1`, our new disk:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: i386 和 amd64 平台要求磁盘既有 MBR 分区也有 OpenBSD 分区。一个标准的新磁盘需要一个覆盖整个磁盘的单一 OpenBSD MBR
    分区。将 `-i` 参数传递给 `fdisk` 正好做到这一点。让我们在 `wd1`，我们的新磁盘上创建一个新的 MBR 分区：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once you have an MBR partition on your disk, you can create disklabel partitions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的磁盘上有了 MBR 分区，您就可以创建 disklabel 分区。
- en: Creating a Disklabel
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Disklabel
- en: 'All OpenBSD platforms use disklabel partitions. To activate the same disklabel
    editor we used during the install process, give `disklabel` the `-E` flag and
    the disk name:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 OpenBSD 平台都使用 disklabel 分区。要激活安装过程中使用的相同 disklabel 编辑器，给 `disklabel` 添加 `-E`
    标志和磁盘名称：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should look familiar from earlier in this chapter. Use the interactive
    disklabel editor to create your new partitions. For a single */home* directory,
    we’ll use one large partition, *wd1a*. The new label should look like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与本章前面的内容相似。使用交互式 disklabel 编辑器创建您的新分区。对于单个 */home* 目录，我们将使用一个大的分区，*wd1a*。新的标签应该看起来像这样：
- en: '[PRE28]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you’ve finished editing partitions, check your work by printing the disklabel.
    This should also give you the DUID of the new disk.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成编辑分区后，通过打印 disklabel 检查您的工作。这也应该给出新磁盘的 DUID。
- en: 'When you’re satisfied with the partitioning, use `newfs` to create a filesystem
    on the new partition:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对分区满意时，使用 `newfs` 在新分区上创建一个文件系统：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You’re now ready to add the filesystem to your computer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始向您的计算机添加文件系统。
- en: Moving Partitions
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动分区
- en: Moving data from one disk to another is slightly more complex than adding new
    partitions. You must first mount the new drive in a temporary location, copy files
    to that location, remove them from the old location, and mount the new drive in
    its previous home.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从一个磁盘移动到另一个磁盘比添加新的分区稍微复杂一些。您必须首先在临时位置挂载新驱动器，将文件复制到该位置，然后从旧位置删除它们，并将新驱动器挂载到其原来的位置。
- en: Our new */home* filesystem is on disk partition *wd1a*. The default “temporary
    mount” location is */mnt*, so mount it there. This is strictly temporary, so there’s
    no need to mount it via the DUID or make an */etc/fstab* entry for this.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 */home* 文件系统位于磁盘分区 *wd1a* 上。默认的“临时挂载”位置是 */mnt*，所以将其挂载在那里。这是严格临时的，因此没有必要通过
    DUID 挂载它或为它创建一个 */etc/fstab* 条目。
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can then use `tar(1)`, `cpio(1)`, or `dump(8)` and `restore(8)` to copy
    the files to the temporary location. Here, we copy everything in */home* to */mnt*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用 `tar(1)`、`cpio(1)` 或 `dump(8)` 和 `restore(8)` 将文件复制到临时位置。在这里，我们将 */home*
    中的所有内容复制到 */mnt*。
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You could also use `cp(1)` or `mv(1)` for this, but these commands don’t guarantee
    that file permissions and ownership will copy intact. OpenBSD’s versions of these
    programs have never given me errors when I copy or move files, but I’ve learned
    from other Unix-like operating systems that `tar` and `cpio` are both more reliable
    when moving entire file hierarchies. If you’re using file flags for security (see
    [Chapter 10](ch10.html "Chapter 10. Securing Your System")), you must use `dump(8)`
    and `restore(8)` to retain those flags.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `cp(1)` 或 `mv(1)` 来做这件事，但这些命令不能保证文件权限和所有权会完整复制。OpenBSD 的这些程序版本在复制或移动文件时从未给我出错，但我从其他类
    Unix 操作系统中了解到，在移动整个文件层次结构时，`tar` 和 `cpio` 都更可靠。如果您使用文件标志进行安全设置（见第 10 章），您必须使用
    `dump(8)` 和 `restore(8)` 来保留这些标志。
- en: Using `tar` or `cpio` does not delete files from their original location. This
    means that if a user changes files in his home directory after you copy them but
    before you change the mount point, he will lose his changes as you shuffle disks
    around.^([[20](#ftn.id369420)])
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tar` 或 `cpio` 不会从原始位置删除文件。这意味着，如果您在复制文件之后但在更改挂载点之前更改了用户的主目录中的文件，那么当您在移动磁盘时，他将丢失他的更改。^([[20](#ftn.id369420)])
- en: Now update */etc/fstab* to reflect your new disk.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新 */etc/fstab* 以反映您的新硬盘。
- en: Adding New Filesystems
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新的文件系统
- en: Look at the disklabel for the new disk and get the disk’s DUID. This new disk
    has a DUID of `fea9194ee78362d8`. Use the DUID and the partition letter to make
    an */etc/fstab* entry for your new partitions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 查看新硬盘的磁盘标签并获取硬盘的 DUID。这个新硬盘的 DUID 是 `fea9194ee78362d8`。使用 DUID 和分区字母为您的新的分区创建一个
    */etc/fstab* 条目。
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You might want to keep the old partition available at a new location, such as
    */oldhome*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在新位置保留旧分区，例如 */oldhome*。
- en: If you’re not sure about the mount options to use for your new partitions, the
    options `nodev`, `nosuid`, and `softdep` are generally safe. You probably want
    the partition mounted read-write (`rw`) as well.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定为您的新的分区使用哪些挂载选项，`nodev`、`nosuid` 和 `softdep` 选项通常是安全的。您可能还想将分区设置为可读写（`rw`）。
- en: Now unmount the old and mount the new.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在卸载旧分区并挂载新分区。
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When you unmount a partition, `umount` doesn’t check */etc/fstab*. You tell
    it to unmount a partition, and it unmounts that partition.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当您卸载一个分区时，`umount` 不会检查 */etc/fstab*。您告诉它卸载一个分区，然后它就卸载了那个分区。
- en: Stackable Mounts
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可堆叠挂载
- en: OpenBSD filesystems are *stackable*, which means that you can mount one partition
    over another. The partition on top hides any files in the filesystem below.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 文件系统是可堆叠的，这意味着您可以在另一个分区之上挂载一个分区。顶部的分区会隐藏下面文件系统中的任何文件。
- en: Look at your system in single-user mode. By default, only the root partition
    is mounted. You can go look in the */home* directory, and it will be empty. There’s
    no reason you can’t put files in the */home* directory, even when */home* isn’t
    mounted. Suppose you copy a couple of core files into */home* while in single-user
    mode, and then go into multiuser mode. All the usual partitions are mounted. If
    you then look in */home*, you won’t find your core files.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以单用户模式查看您的系统。默认情况下，只有根分区被挂载。您可以查看 */home* 目录，它将是空的。没有理由您不能在 */home* 目录中放置文件，即使
    */home* 没有挂载。假设您在单用户模式下将几个核心文件复制到 */home*，然后进入多用户模式。所有常规分区都已挂载。如果您此时查看 */home*，您将找不到您的核心文件。
- en: What happened? Where did those files go?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？那些文件去哪里了？
- en: The files are in the directory */home*, but on the root partition. The */home*
    partition is mounted above that directory, so the */home* partition obscures the
    files in the */home* directory on the root partition. To access those hidden files,
    you must unmount the */home* partition. Those hidden files continue to take up
    space on the root partition, however.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在 */home* 目录中，但在根分区上。*/home* 分区挂载在目录之上，因此 */home* 分区掩盖了根分区上 */home* 目录中的文件。要访问这些隐藏的文件，您必须卸载
    */home* 分区。然而，这些隐藏文件仍然占用根分区的空间。
- en: This happens more commonly when splitting a partition. For example, if you find
    that your */var* partition is too small, you might move */var/www* into its own
    partition on a separate disk. To free up space on the original */var*, delete
    the files you copied to */var/www*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在分区分割时更为常见。例如，如果你发现你的 */var* 分区太小，你可能会将 */var/www* 移动到单独磁盘上的自己的分区中。为了在原始的
    */var* 上释放空间，删除你复制到 */var/www* 的文件。
- en: With the basics of filesystem management under your belt, you’re now ready to
    look at some of OpenBSD’s more interesting filesystem tricks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握文件系统管理的基本知识后，你现在可以开始了解一些 OpenBSD 更有趣的文件系统技巧。
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#id483068)]) If it’s buffered aspirin, then you’re doing buffered buffered
    aspirin transfers. But let’s not go there.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#id483068)]) 如果是缓释型阿司匹林，那么你正在进行缓释型缓释阿司匹林转移。但让我们不要深入那个话题。
- en: ^([[18](#id416360)]) OpenBSD is not the only operating system that still uses
    the BSD 4.4 filesystem or a descendant thereof. If a Unix vendor doesn’t specifically
    tout its “improved and advanced” filesystem, it’s almost certainly running a derivative
    of FFS.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#id416360)]) OpenBSD 并不是唯一仍然使用 BSD 4.4 文件系统或其衍生版本的操作系统。如果一个 Unix 供应商没有特别吹嘘其“改进和先进的”文件系统，那么它几乎肯定运行的是
    FFS 的衍生版本。
- en: ^([[19](#id425288)]) Hi, Henning!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#id425288)]) 嗨，Henning！
- en: ^([[20](#id369420)]) Presumably you warn your users before doing maintenance.
    Or at least *during* maintenance. Or … maybe afterward.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#id369420)]) 假设你在进行维护之前会警告你的用户。或者至少在维护期间。或者……也许是在之后。
