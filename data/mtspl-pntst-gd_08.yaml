- en: Chapter 8. Exploitation Using Client-Side Attacks
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章 客户端攻击的利用
- en: Years of focus on defensive network perimeters have drastically shrunk the traditional
    attack surfaces. When one avenue of attack becomes too difficult to penetrate,
    attackers can find new and easier methods for attacking their targets. Client-side
    attacks were the next evolution of attacks after network defenses became more
    prominent. These attacks target software commonly installed on computers in such
    programs as web browsers, PDF readers, and Microsoft Office applications. Because
    these programs are commonly installed on computers out of the box, they are obvious
    attack vectors for hackers. It’s also common for these applications to be out
    of date on users’ machines because of irregular patching cycles. Metasploit includes
    a number of built-in client-side exploits, which we’ll cover in depth in this
    chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，对防御性网络边界的关注极大地缩小了传统的攻击面。当攻击某一路径变得难以渗透时，攻击者可以找到新的、更容易的方法来攻击他们的目标。客户端攻击是网络防御变得更加突出之后的攻击的下一个发展阶段。这些攻击针对安装在计算机上的常见软件，如网络浏览器、PDF阅读器和Microsoft
    Office应用程序。因为这些程序通常在出厂时就已经安装在计算机上，所以它们是黑客明显的攻击向量。此外，由于补丁周期不规则，这些应用程序在用户机器上通常过时。Metasploit包括许多内置的客户端漏洞利用，我们将在本章中深入探讨。
- en: If you can bypass all the protective countermeasures a company has in place
    and infiltrate a network by tricking a user into clicking a malicious link, you
    have a much better chance of achieving a compromise. Suppose, for example, that
    you are performing a covert penetration test against a corporate target using
    social engineering. You decide that sending a phishing email to targeted users
    will present your best chance of success. You harvest email accounts, names, and
    phone numbers; browse social-networking sites; and create a list of known employees.
    Your malicious email instructs the email recipients that payroll information needs
    to be updated; they need to click a link (a malicious link) in the email to do
    this. However, as soon as the user clicks the link, the machine is compromised,
    and you can access the organization’s internal network.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够绕过公司设置的所有的保护措施，并通过欺骗用户点击恶意链接来渗透网络，你就有更大的机会实现入侵。例如，假设你正在对一个企业目标进行隐蔽的渗透测试，使用社会工程学。你决定向目标用户发送钓鱼电子邮件将给你提供最佳的成功机会。你收集电子邮件账户、姓名和电话号码；浏览社交网络网站；并创建已知员工的名单。你的恶意电子邮件指示电子邮件收件人需要更新工资信息；他们需要点击电子邮件中的链接（一个恶意链接）来完成此操作。然而，一旦用户点击链接，计算机就会被入侵，你就可以访问组织的内部网络。
- en: This scenario is a common technique regularly leveraged in both penetration
    tests and actual malicious attacks. It is often easier to attack via users than
    it is to exploit Internet-facing resources. Most organizations spend a significant
    amount of money protecting their Internet-facing systems with tools such as intrusion
    prevention systems (IPSs) and web application firewalls, while not investing nearly
    as much in educating their users about social-engineering attacks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景是一种常见的技巧，在渗透测试和实际恶意攻击中经常被利用。通过攻击用户比利用面向互联网的资源更容易。大多数组织在保护其面向互联网的系统方面投入了大量的资金，使用工具如入侵预防系统（IPS）和Web应用程序防火墙，而在教育用户关于社会工程学攻击方面投入的资金却少得多。
- en: In March 2011, RSA, a well-known security company, was compromised by an attacker
    leveraging this same process. A malicious attacker sent an extremely targeted
    (spear-phishing) email that was crafted specifically for an Adobe Flash zero-day
    vulnerability. (*Spear-phishing* is an attack whereby users are heavily researched
    and targeted rather than randomly chosen from a company address book.) In RSA’s
    case, the email targeted a small group of users and was able to compromise RSA’s
    internally connected systems and further penetrate its network.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年3月，一家知名的安全公司RSA被一个利用相同过程的攻击者入侵。一个恶意攻击者发送了一封针对Adobe Flash零日漏洞的极其针对性的（鱼叉式网络钓鱼）电子邮件。(*鱼叉式网络钓鱼*是一种攻击方式，其中用户被深入研究并针对，而不是从公司地址簿中随机选择。)在RSA的案例中，电子邮件针对一小群用户，能够入侵RSA的内部连接系统并进一步渗透其网络。
- en: Browser-Based Exploits
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于浏览器的漏洞利用
- en: We’ll focus on browser-based exploits within Metasploit in this chapter. *Browser-based
    exploits* are important techniques, because in many organizations, users spend
    more time using their web browsers than using any other applications on their
    computers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Metasploit中的基于浏览器的漏洞利用。*基于浏览器的漏洞利用*是重要的技术，因为在许多组织中，用户在他们的计算机上使用网页浏览器的时间比使用其他任何应用程序的时间都要多。
- en: 'Consider another scenario: We send an email to a small group at an organization
    with a link that each user will click. The users click the link, and their browsers
    open to our website, which has been specially crafted to exploit a vulnerability
    in a certain version of Internet Explorer. The users’ browser application is susceptible
    to this exploit and is now compromised simply by users visiting our malicious
    website. On our end, access would be gained via a payload (Meterpreter, for example)
    running within the context of the user who visited the site.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一个场景：我们向一个组织的少数人发送一封包含链接的电子邮件，每个用户都会点击该链接。用户点击链接后，他们的浏览器会打开我们的网站，该网站已被特别设计来利用某个版本的Internet
    Explorer中的漏洞。用户的浏览器应用程序容易受到这种漏洞利用的影响，并且现在仅通过用户访问我们的恶意网站就被破坏了。在我们的这一端，通过在访问网站的用户的上下文中运行的负载（例如Meterpreter）来获取访问权限。
- en: 'Note one important element in this example: If the target user were running
    as an administrator, the attacker (we) would do the same. Client-side exploits
    traditionally run with the same permissions and rights as the target they exploit.
    Often this is a regular user without administrative privileges, so we would need
    to perform a *privilege-escalation attack* to obtain additional access, and an
    additional exploit would be necessary to elevate privileges. We could also potentially
    attack other systems on the network in hopes of gaining administrative-level access.
    In other cases, however, the current user’s permission levels are enough to achieve
    the infiltration. Consider your network situation: Is your important data accessible
    via user accounts? Or is it accessible only to the administrator account?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个例子中的一个重要元素：如果目标用户以管理员身份运行，攻击者（我们）也会这样做。客户端漏洞利用传统上以与它们利用的目标相同的权限和权利运行。通常这是一个没有管理员权限的普通用户，因此我们需要执行*提权攻击*以获得额外的访问权限，并且还需要一个额外的漏洞利用来提升权限。我们还可以潜在地攻击网络上的其他系统，以期获得管理员级别的访问权限。然而，在某些情况下，当前用户的权限级别足以实现渗透。考虑你的网络情况：你的重要数据是否可以通过用户账户访问？或者是否只能通过管理员账户访问？
- en: How Browser-Based Exploits Work
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于浏览器的漏洞是如何工作的
- en: 'Browser exploits are similar to any traditional exploit but with one major
    difference: the method used for shellcode delivery. In a traditional exploit,
    the attacker’s entire goal is to gain remote code execution and deliver a malicious
    payload. In browser exploits, the most traditional way to gain remote code execution
    is through an exploitation technique called *heap spraying*. But before examining
    heap spraying in detail, let’s talk about what the *heap* is and how it’s used.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器漏洞类似于任何传统的漏洞利用，但有一个主要区别：用于shellcode交付的方法。在传统的漏洞利用中，攻击者的整个目标是获得远程代码执行并交付恶意负载。在浏览器漏洞利用中，获得远程代码执行的最传统方式是通过一种称为*堆喷射*的漏洞利用技术。但在详细检查堆喷射之前，让我们先谈谈什么是*堆*以及它是如何被使用的。
- en: The heap is memory that is unallocated and used by the application as needed
    for the duration of the program’s runtime. The application will allocate whatever
    memory is necessary to complete whatever task is at hand. The heap is based on
    how much memory your computer has available and has used through the entire application’s
    life cycle. The location of memory allocated at runtime is not known in advance,
    so as attackers, we would not know where to place our shellcode. Hackers can’t
    simply call a memory address and hope to land at the payload — the randomness
    of memory allocated by the heap prevents this, and this randomness was a major
    challenge before heap spraying was discovered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是程序运行期间未分配且由应用程序根据需要使用的内存。应用程序将分配完成当前任务所需的任何内存。堆基于计算机可用的内存量以及在整个应用程序生命周期中使用的内存量。在运行时分配的内存位置是事先未知的，因此作为攻击者，我们不知道在哪里放置我们的shellcode。黑客不能简单地调用一个内存地址并希望到达负载——堆分配内存的随机性阻止了这一点，这种随机性在堆喷射被发现之前是一个主要挑战。
- en: Before moving on, you also need to understand the concept of a *no-operation
    instruction (NOP)* and *NOP slide*. NOPs are covered in detail in [Chapter 15](part0019.html#porting_exploits_to_the_metasploit_frame),
    but we’ll cover the basics here because they are important to understanding how
    heap spraying works. A NOP is an assembly instruction that says, “Do nothing and
    move to the next instruction.” A NOP slide comprises multiple NOPs adjacent to
    each other in memory, basically taking up space. If a program’s execution flow
    encounters a series of NOP instructions, it will linearly “slide” down to the
    end of them to the next instruction. A NOP, in the Intel x86 architecture, has
    an opcode of 90, commonly seen in exploit code as `\x90`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你还需要理解*无操作指令（NOP）*和*NOP滑动*的概念。NOPs在[第15章](part0019.html#porting_exploits_to_the_metasploit_frame)中有详细的介绍，但在这里我们会介绍基础知识，因为它们对于理解堆喷射的工作原理非常重要。NOP是一种汇编指令，意思是“什么都不做，移动到下一条指令。”NOP滑动由内存中相邻的多个NOP组成，基本上是占用空间。如果一个程序的执行流程遇到一系列NOP指令，它将线性地“滑动”到它们的末尾到下一条指令。在Intel
    x86架构中，NOP的指令码是90，在利用代码中通常以`\x90`的形式出现。
- en: The heap spraying technique involves filling the heap with a known repeating
    pattern of NOP slides and your shellcode until you fill the entire memory space
    with this known value. You’ll recall that memory in the heap is dynamically allocated
    at program runtime. This is usually done via JavaScript, which causes the browser’s
    allocated memory to grow significantly. The attacker fills large blocks of memory
    with NOP slides and shellcode directly after them. When program execution flow
    is altered and randomly jumps somewhere into memory, there is a good chance of
    hitting a NOP slide and eventually hitting the shellcode. Instead of looking for
    a needle in a haystack — that is, the shellcode in memory — heap spraying offers
    an 85 to 90 percent chance of the exploit being successful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 堆喷射技术涉及用已知的重复模式NOP滑动和你的shellcode填充堆，直到整个内存空间被这个已知值填满。你可能会记得，堆中的内存是在程序运行时动态分配的。这通常是通过JavaScript完成的，这导致浏览器分配的内存显著增长。攻击者用NOP滑动和紧随其后的shellcode填充大块内存。当程序执行流程被改变并且随机跳转到内存中的某个地方时，有很大几率会击中NOP滑动，并最终击中shellcode。与在干草堆中寻找一根针——即在内存中的shellcode——相比，堆喷射提供了85%到90%的成功几率。
- en: This technique changed the game in browser exploitation and in the reliability
    of exploiting browser bugs. We will not be covering the actual code behind heap
    spraying, because it’s an advanced exploitation topic, but you should know the
    basics so that you can understand how these browser-based exploits work. Before
    we begin launching our first browser exploit, let’s look at what actually happens
    behind the scenes when an exploit is launched.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术改变了浏览器利用和浏览器漏洞利用的可靠性。我们不会涵盖堆喷射背后的实际代码，因为这是一个高级利用话题，但你应该了解基础知识，以便理解这些基于浏览器的利用是如何工作的。在我们开始启动我们的第一个浏览器利用之前，让我们看看当启动利用时幕后实际发生了什么。
- en: Looking at NOPs
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看NOP
- en: Now that you understand the basics of a heap spray and a NOP, let’s take a look
    at a generic NOP slide in an actual exploit. In the following listing, notice
    the hexadecimal representation of `\x90`, the Intel x86 architecture opcode. A
    *90* in Intel x86 assembly is a NOP. Here you see a series of `\x90`s that create
    our NOP-slide effect. The rest of the code is the payload, such as a reverse shell
    or a Meterpreter shell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了堆喷射和NOP的基础，让我们看看实际攻击中一个通用的NOP滑动效果。在下面的列表中，注意`\x90`的十六进制表示，这是Intel x86架构的指令码。在Intel
    x86汇编中，*90*是一个NOP。这里你可以看到一系列的`\x90`，它们创建了我们所说的NOP滑动效果。其余的代码是有效载荷，例如反向shell或Meterpreter
    shell。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using Immunity Debugger to Decipher NOP Shellcode
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Immunity Debugger来解码NOP Shellcode
- en: '*Debuggers* offer a window into the running state of a program, including assembly
    instruction flow, memory contents, and exception details. Penetration testers
    leverage debuggers on a regular basis to identify zero-day vulnerabilities and
    to understand how an application works and how to attack it. A number of debuggers
    are out there, but our personal preference going forward (and used in later chapters)
    is Immunity Debugger. We recommend that you take a look at the basics of Immunity
    Debugger before proceeding.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试器*为程序的运行状态提供了一个窗口，包括汇编指令流、内存内容和异常细节。渗透测试人员经常利用调试器来识别零日漏洞，以及了解应用程序的工作方式和攻击方式。现在有许多调试器，但我们将来的个人偏好（并在后面的章节中使用）是Immunity
    Debugger。我们建议你在继续之前先看看Immunity Debugger的基础知识。'
- en: To understand what a NOP slide does, let’s use a debugger to look at how the
    NOP shellcode in the preceding example works. On your Windows XP target, download
    and install Immunity Debugger from [http://www.immunityinc.com/](http://www.immunityinc.com/).
    We’ll use the `msfpayload` command to generate sample shellcode for a simple TCP
    bind shell, listening on port 443\. As you learned in previous chapters, a bind
    shell simply listens on a port on a target machine to which we can connect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解NOP滑块的作用，让我们使用调试器查看前面示例中的NOP shellcode是如何工作的。在你的Windows XP目标上，从[http://www.immunityinc.com/](http://www.immunityinc.com/)下载并安装Immunity
    Debugger。我们将使用`msfpayload`命令生成一个简单的TCP bind shell的示例shellcode，监听端口443。正如你在前面的章节中学到的，bind
    shell只是在一个目标机器上的端口上监听，我们可以连接到它。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When these commands are executed, “stage 1” and “stage 2” shellcodes are created
    in the output. We are concerned only with the stage 1 shellcode, because Metasploit
    will handle sending the second stage for us when we connect to it. Copy and paste
    the shellcode from stage 1 into a text editor of your choice. You’ll need to do
    some minor editing before proceeding.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些命令执行时，将在输出中创建“阶段1”和“阶段2”的shellcode。我们只关心阶段1的shellcode，因为当我们连接到Metasploit时，它将为我们处理发送第二阶段。将阶段1的shellcode复制并粘贴到你选择的文本编辑器中。在继续之前，你需要做一些小的编辑。
- en: 'Now that you have your basic shellcode, add as many NOPs as you want to the
    beginning of it (such as `\x90\x90\x90\x90\x90`). Then remove all `\x` occurrences
    so it looks similar to the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了基本的shellcode，可以在它的开头添加任意多的NOP指令（例如`\x90\x90\x90\x90\x90`）。然后删除所有的`\x`出现，使其看起来类似于以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All this is necessary because you need to use a particular format so that Immunity
    Debugger will accept your copy-and-paste of assembly instructions. Now you have
    a bind shell with some NOPs in front of it for testing. Next, open up any executable
    — let’s use *iexplore.exe* for this example. Open Immunity Debugger, choose **File**
    ▸ **Open**, and point to an executable. You should see a number of assembly instructions
    in the main window (the largest one). Left-click the first instruction on the
    screen, and hold down shift while left-clicking to highlight about 300 instructions
    below it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是必要的，因为你需要使用特定的格式，这样Immunity Debugger才能接受你复制粘贴的汇编指令。现在你有一个带有前面一些NOP指令的bind
    shell用于测试。接下来，打开任何可执行文件——让我们用*iexplore.exe*作为这个例子。打开Immunity Debugger，选择**文件**
    ▸ **打开**，并指向一个可执行文件。你应该在主窗口（最大的一个）中看到许多汇编指令。左键单击屏幕上的第一条指令，然后按住shift键同时左键单击，以突出显示其下约300条指令。
- en: Copy the shellcode to the clipboard, and right-click in the Immunity Debugger
    window and choose **Binary** ▸ **Binary paste**. This will paste the assembly
    instructions from the example into the Immunity Debugger window. (Remember that
    we are doing this to identify how NOPs work and how assembly instructions are
    executed.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将shellcode复制到剪贴板，然后在Immunity Debugger窗口中右键单击并选择**二进制** ▸ **二进制粘贴**。这将把示例中的汇编指令粘贴到Immunity
    Debugger窗口中。（记住，我们这样做是为了识别NOP的工作方式和汇编指令的执行方式。）
- en: You can see in [Figure 8-1](part0012.html#examples_of_multiple_nops_that_create_th)
    that a number of NOPs are inserted; if you were to scroll down, you would see
    your shellcode.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图8-1](part0012.html#examples_of_multiple_nops_that_create_th)中看到插入了多个NOP；如果你向下滚动，你会看到你的shellcode。
- en: When we first exported our shellcode in a `bind_tcp` format, the last instruction
    through stage 1 ended with `ecc3`. Locate the last set of memory instructions
    we added ending in `ecc3`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次以`bind_tcp`格式导出shellcode时，阶段1的最后一条指令以`ecc3`结束。定位我们添加的最后一条以`ecc3`结尾的内存指令集。
- en: Right after the `ecc3`, press F2 to create a breakpoint. When you add a breakpoint,
    once execution flow encounters it, program execution will pause and will not continue.
    This is important here, because the code still has a lot of the old remnants of
    the application we opened, and continuing would cause the application to crash,
    because we already inserted our own code into it. We want to stop and investigate
    what happened before the application crashes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ecc3`之后，按F2键创建一个断点。当你添加一个断点时，一旦执行流程遇到它，程序执行将暂停，不会继续。这里很重要，因为代码中仍然有很多我们打开的应用程序的老旧残留部分，继续执行会导致应用程序崩溃，因为我们已经向其中插入了我们自己的代码。我们想要停止并调查应用程序崩溃之前发生了什么。
- en: '![Examples of multiple NOPs that create the NOP slide](../images/00036.jpeg)Figure 8-1. Examples
    of multiple NOPs that create the NOP slide'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建NOP滑块的多个NOP示例](../images/00036.jpeg)图8-1. 创建NOP滑块的多个NOP示例'
- en: In the example in [Figure 8-2](part0012.html#the_last_part_of_our_instruction_set_tha),
    notice the last instruction set, which is a `C3`. That is the last instruction
    set in our bind shell that we need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8-2](part0012.html#the_last_part_of_our_instruction_set_tha)的例子中，注意最后的指令集，它是一个`C3`。这是我们需要的bind
    shell中的最后一个指令集。
- en: After that `C3`, press F2, which sets up another breakpoint. Now we’re ready
    to roll and see what happens. Go back to the very top, where you added your NOPs,
    and press F7, which tells the debugger to execute the next assembly command, stepping
    into your next assembly instruction. Notice that the highlight moves down one
    line. Nothing happened because you added a NOP.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`C3`之后，按下F2，这将设置另一个断点。现在我们准备好了，看看会发生什么。回到你添加NOPs的顶部，按下F7，这将告诉调试器执行下一个汇编命令，进入下一个汇编指令。注意高亮向下移动了一行。没有发生任何事情，因为你添加了一个NOP。
- en: Next, press F7 a few times to walk down the NOP slide. When you first arrive
    at the memory instructions, open up a command prompt and type **`netstat -an`**.
    Nothing should be listening on 443, and this is a good sign that your payload
    hasn’t executed yet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，多次按下F7来向下走NOP滑块。当你第一次到达内存指令时，打开一个命令提示符并输入**`netstat -an`**。443端口上不应该有任何监听，这是一个好迹象，表明你的有效载荷还没有执行。
- en: Press F5 to continue running the rest of the application until it reaches the
    breakpoint that you set. You should see the breakpoint indicated in the lower-left
    corner of the Immunity Debugger window. At this point, you have executed your
    payload within the debugger, and you should now be able to check `netstat -an`
    and notice port 443 listening.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按下F5继续运行应用程序的其余部分，直到达到你设置的断点。你应该能在Immunity Debugger窗口的左下角看到断点指示。在这个时候，你已经在调试器中执行了你的有效载荷，你现在应该能够检查`netstat
    -an`并注意到443端口正在监听。
- en: On a remote machine, try to telnet to the target machine on port 443\. You’ll
    notice that nothing happens; this is because the listener hasn’t received the
    second stage from Metasploit yet. On your Back|Track VM, go into Metasploit and
    set up a multi-handler. This will tell Metasploit that a first-stage listener
    is on port 443 on the target machine.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程机器上，尝试在443端口上telnet到目标机器。你会注意到没有任何反应；这是因为监听器还没有从Metasploit接收到第二阶段。在你的Back|Track
    VM上，进入Metasploit并设置一个多处理器。这将告诉Metasploit目标机器上的443端口有一个第一阶段监听器。
- en: '![The last part of our instruction set that we need](../images/00037.jpeg)Figure 8-2. The
    last part of our instruction set that we need'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![我们需要的指令集的最后部分](../images/00037.jpeg)图8-2. 我们需要的指令集的最后部分'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You have reached a basic command shell! As a good practicing technique, try
    a stage 1 Meterpreter reverse and see if you can get a connection. When you are
    finished, simply close the Immunity Debugger window and you’re all done. It’s
    important that you get familiar with Immunity Debugger now, because we will be
    leveraging it in later chapters. Now let’s launch our first browser exploit that
    uses a heap spray.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经到达了一个基本的命令行shell！作为一个良好的练习技巧，尝试一个阶段的Meterpreter反向连接，看看你是否能建立连接。完成之后，只需简单地关闭Immunity
    Debugger窗口，你就完成了。现在熟悉Immunity Debugger非常重要，因为我们在后面的章节中会利用它。现在让我们启动第一个使用堆喷射的浏览器漏洞利用。
- en: Exploring the Internet Explorer Aurora Exploit
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Internet Explorer Aurora漏洞利用
- en: You know the basics of how heap sprays work and how you can dynamically allocate
    memory and fill the heap up with NOPs and shellcode. We’ll be leveraging an exploit
    that uses this technique and something found in nearly every client-side exploit.
    The browser exploit of choice here is the Aurora exploit (Microsoft Security Bulletin
    MS10-002). Aurora was most notoriously used in the attacks against Google and
    more than 20 other large technology companies. Although this exploit was released
    in early 2010, it particularly resonates with us because it took down some major
    players in the technology industry.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道堆喷射的基本工作原理以及如何动态分配内存并将堆填满NOP和shellcode。我们将利用一个使用这种技术的漏洞，以及几乎每个客户端漏洞中都能找到的东西。这里选择的浏览器漏洞是Aurora漏洞（Microsoft安全公告MS10-002）。Aurora最臭名昭著的是在针对Google和20多家其他大型科技公司攻击中使用。尽管这个漏洞在2010年初发布，但它特别与我们产生共鸣，因为它使科技行业的一些主要玩家陷入了困境。
- en: We’ll start by using the Aurora Metasploit module and then set our payload.
    The following commands should be familiar, because we have used them in previous
    chapters. You’ll also see a couple of new options that we’ll discuss in a bit.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Aurora Metasploit模块，然后设置我们的有效载荷。以下命令应该很熟悉，因为我们已经在前面的章节中使用过它们。你还会看到一些我们将稍后讨论的新选项。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, notice that the default setting for `SRVHOST` ![](../images/00002.gif)
    is 0.0.0.0: This means that the web server will bind to all interfaces. The `SRVPORT`
    at ![](../images/00004.gif), 8080, is the port to which the targeted user needs
    to connect for the exploit to trigger. We will be using port 80 instead of 8080,
    however. We could also set up the server for SSL, but for this example, we’ll
    stick with standard HTTP. `URIPATH` ![](../images/00005.gif) is the URL the user
    will need to enter to trigger the vulnerability, and we set this to a slash (`/`)
    at ![](../images/00006.gif).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意`SRVHOST`的默认设置是0.0.0.0 ![../images/00002.gif]，这意味着Web服务器将绑定到所有接口。`SRVPORT`在![../images/00004.gif]，8080，是目标用户需要连接以触发漏洞的端口。然而，我们将使用80而不是8080。我们也可以设置SSL服务器，但在这个例子中，我们将坚持使用标准HTTP。`URIPATH`
    ![../images/00005.gif]是用户需要输入以触发漏洞的URL，我们将它设置为斜杠(`/`) ![../images/00006.gif]。
- en: With our settings defined, use your Windows XP virtual machine and connect to
    the attacker using *http://*<*attacker’s IP address*>. You’ll notice the machine
    becomes a bit sluggish. After a little waiting, you should see a Meterpreter shell.
    In the background, the heap spray was performed and the jump into the dynamic
    memory was executed, to hit your shellcode eventually. If you open Task Manager
    in Windows before you run this exploit, you can actually see the memory for *iexplore.exe*
    growing significantly based on the contact growth of the heap.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了设置后，使用你的Windows XP虚拟机并通过*http://*<攻击者的IP地址>连接到攻击者。你会注意到机器变得有点卡顿。稍等片刻，你应该会看到一个Meterpreter外壳。在后台，执行了堆喷射并跳入动态内存，最终触发了你的shellcode。如果你在运行这个漏洞利用之前在Windows中打开任务管理器，你实际上可以看到*iexplore.exe*的内存根据堆的增长而显著增加。
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You now have a Meterpreter shell, but there’s a slight problem. What if the
    targeted user closes the browser based on the sluggishness of her computer? You
    would effectively lose your session to the target, and although the exploit is
    successful, it would be cut off prematurely. Fortunately, there is a way around
    this: Simply type **`run migrate`** as soon as the connection is established,
    and hope that you make it in time. This Meterpreter script automatically migrates
    to the memory space of a separate process, usually *lsass.exe*, to improve the
    chances of keeping your shell open if the targeted user closes the originally
    exploited process.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了Meterpreter外壳，但有一个小问题。如果目标用户根据她电脑的卡顿关闭浏览器怎么办？你将有效地失去与目标机器的会话，尽管漏洞利用是成功的，但它会被提前切断。幸运的是，有一个解决办法：一旦建立连接，立即输入**`run
    migrate`**，并希望你能及时完成。这个Meterpreter脚本会自动迁移到另一个进程的内存空间，通常是*lsass.exe*，以提高在目标用户关闭最初被利用的进程时保持外壳打开的机会。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a pretty manual process. You can automate this whole process using
    some advanced options to migrate to a process automatically upon a successful
    shell. Type **`show advanced`** to list the advanced features of the Aurora module:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当手动的过程。你可以使用一些高级选项来自动化整个过程，在成功获得外壳后自动迁移到进程。输入**`show advanced`**来列出Aurora模块的高级功能：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By setting these options, you can fine-tune a lot of the payload and exploit
    details. Now suppose you wanted to change the amount of tries a reverse connection
    would do. The default is 5, but you might be concerned with timeouts and want
    to increase the connection retries. Here, we set it to 10:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置这些选项，你可以微调许多有效载荷和漏洞利用的细节。现在假设你想要改变反向连接尝试的次数。默认值是5，但你可能担心超时，并希望增加连接重试次数。在这里，我们将它设置为10：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, you want to migrate automatically to a new process in case the
    targeted user closes the browser right away. Under the `AutoRunScript`, simply
    let Metasploit know to autorun a script as soon as a Meterpreter console is created.
    Using the `migrate` command with the `-f` switch tells Meterpreter to launch a
    new process automatically and migrate to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你希望如果目标用户立即关闭浏览器，则自动迁移到新的进程。在`AutoRunScript`下，只需让Metasploit知道在创建Meterpreter控制台时立即自动运行脚本。使用带有`-f`选项的`migrate`命令告诉Meterpreter自动启动一个新进程并迁移到它：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now attempt to run the exploit and see what happens. Try closing the connection
    and see if your Meterpreter session still stays active.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行漏洞利用并观察会发生什么。尝试关闭连接，看看你的Meterpreter会话是否仍然保持活跃。
- en: Since this is a browser-based exploit, you will most likely be running as a
    limited user account. Remember to issue the `use priv` and `getsystem` commands
    to attempt privilege escalation on the target machine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个基于浏览器的漏洞利用，你很可能会以受限用户账户运行。请记住，要发出`use priv`和`getsystem`命令，尝试在目标机器上进行权限提升。
- en: That’s it! You just successfully executed your first client-side attack using
    a pretty famous exploit. Note that new exploits are frequently being released,
    so be sure to search for all the browser exploits and find which one best suits
    your needs for a particular target.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！你刚刚成功执行了第一个客户端攻击，使用的是一个相当著名的漏洞利用。请注意，新的漏洞利用频繁发布，所以请确保搜索所有浏览器漏洞，并找到最适合特定目标的那个。
- en: File Format Exploits
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件格式漏洞利用
- en: '*File format bugs* are exploitable vulnerabilities found within a given application,
    such as an Adobe PDF document. This class of exploit relies on a user actually
    opening a malicious file in a vulnerable application. Malicious files can be hosted
    remotely or sent via email. We briefly mentioned leveraging file format bugs as
    a spear-phishing attack in the beginning of this chapter, and we’ll offer more
    about spear-phishing in [Chapter 10](part0014.html#the_social-engineer_toolkit).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件格式漏洞*是在特定应用程序中发现的可利用漏洞，例如Adobe PDF文档。这类漏洞利用依赖于用户在易受攻击的应用程序中打开恶意文件。恶意文件可以远程托管或通过电子邮件发送。我们在本章开头简要提到了利用文件格式漏洞作为鱼叉式网络钓鱼攻击，我们将在[第10章](part0014.html#the_social_engineer_toolkit)中提供更多关于鱼叉式网络钓鱼的信息。'
- en: In traditional file format exploits, you could leverage anything to which you
    think your target will be susceptible. This could be a Microsoft Word document,
    a PDF, an image, or anything else that might be applicable. In this example, we’ll
    be leveraging MS11-006, known as the Microsoft Windows CreateSizedDIBSECTION Stack
    Buffer Overflow.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的文件格式漏洞利用中，你可以利用你认为目标可能会易受其影响的一切。这可能是一个Microsoft Word文档、一个PDF文件、一张图片或其他任何可能适用的东西。在这个例子中，我们将利用MS11-006，也称为Microsoft
    Windows CreateSizedDIBSECTION堆栈缓冲区溢出。
- en: 'Within Metasploit, perform a search for `ms11_006`. Our first step is to get
    into our exploit through *msfconsole*, and type **`info`** to see what options
    are available. In the next example, you can see that the file format is exported
    as a document:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Metasploit中搜索`ms11_006`。我们的第一步是通过*msfconsole*进入漏洞利用，并输入**`info`**来查看可用的选项。在下一个示例中，你可以看到文件格式被导出为一个文档：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, you can see that we have a few targets available to use, but we’ll make
    it automatic and leave everything at the default settings:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到我们有几个可用的目标可供选择，但我们将使其自动化，并保留所有默认设置：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ll need to set a payload as usual. In this case, we will select our first
    choice, a reverse Meterpreter shell:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要像往常一样设置一个有效载荷。在这种情况下，我们将选择我们的第一个选择，一个反向Meterpreter shell：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Sending the Payload
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送有效载荷
- en: Our file was exported as *msf.doc* ![](../images/00002.gif) and sent to the
    */opt/* ![](../images/00004.gif) directory within Metasploit. Now that we have
    our malicious document, we can craft up an email to our target and hope the user
    opens it. At this point, we should already have an idea of the target’s patch
    levels and vulnerabilities. Before we actually open the document, we need to set
    up a multi-handler listener. This will ensure that when the exploit is triggered,
    the attacker machine can receive the connection back from the target machine (reverse
    payload).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件导出为*msf.doc* ![图片](../images/00002.gif) 并将其发送到Metasploit中的*/opt/* ![图片](../images/00004.gif)
    目录。现在我们有了恶意文档，我们可以为我们的目标制作一封电子邮件，并希望用户打开它。在这个阶段，我们应该已经对目标的补丁级别和漏洞有了概念。在我们实际打开文档之前，我们需要设置一个多处理器监听器。这将确保当漏洞利用被触发时，攻击者机器可以接收来自目标机器的连接（反向有效载荷）。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We open the document on a Windows XP virtual machine, and we should be presented
    with a shell (provided our VM is Windows XP SP3):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Windows XP虚拟机上打开文档，应该会得到一个shell（假设我们的虚拟机是Windows XP SP3）：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have successfully exploited a file format vulnerability by creating a malicious
    document through Metasploit and then sending it to our targeted user. Looking
    back at this exploit, if we had performed proper reconnaissance on our target
    user, we could have crafted a pretty convincing email. This exploit is one example
    of a number of file format exploits available in Metasploit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Metasploit创建了一个恶意文档，并将其发送给我们的目标用户，成功地利用了一个文件格式漏洞。回顾这次攻击，如果我们对目标用户进行了适当的侦察，我们就能制作出一个相当令人信服的电子邮件。这个漏洞利用是Metasploit中众多文件格式漏洞的一个例子。
- en: Wrapping Up
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We covered how client-side exploits generally work by manipulating the heap
    to work in the attacker’s favor. We covered how NOP instructions work within an
    attack and how to use the basics of a debugger. You’ll learn more about leveraging
    a debugger in [Chapter 14](part0018.html#creating_your_own_exploits) and [Chapter 15](part0019.html#porting_exploits_to_the_metasploit_frame).
    MS11-006 was a stack-based overflow, which we will cover in depth in later chapters.
    Note that your success rate with these types of attacks resides in how much information
    you gain about the target before you attempt to perform the attacks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了客户端漏洞通常是如何通过操纵堆来为攻击者谋利的。我们还介绍了攻击中NOP指令的工作原理以及如何使用调试器的基础知识。你将在第14章[创建自己的漏洞](part0018.html#creating_your_own_exploits)和第15章[将漏洞移植到Metasploit框架](part0019.html#porting_exploits_to_the_metasploit_frame)中了解更多关于利用调试器的知识。MS11-006是一个基于堆的溢出，我们将在后面的章节中深入探讨。请注意，你使用这类攻击的成功率取决于你在尝试攻击之前对目标获取了多少信息。
- en: As a penetration tester, every bit of information can be used to craft an even
    better attack. In the case of spear-phishing, if you can talk the language of
    the company and target your attacks against smaller business units within the
    company that probably aren’t technical in nature, your chances of success greatly
    increase. Browser exploits and file format exploits are typically very effective,
    granted you do your homework. We’ll cover this topic in more detail in [Chapter 8](part0012.html#exploitation_using_client-side_attacks)
    and [Chapter 10](part0014.html#the_social-engineer_toolkit).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试员，每一点信息都可以用来构建一个更有效的攻击。在鱼叉式网络钓鱼的情况下，如果你能说公司的语言，并将攻击目标对准公司内部可能不是技术性质的小业务单元，你的成功率将大大提高。浏览器漏洞和文件格式漏洞通常非常有效，前提是你做了充分的准备。我们将在第8章[使用客户端攻击进行利用](part0012.html#exploitation_using_client-side_attacks)和第10章[社会工程学工具包](part0014.html#the_social_engineer_toolkit)中更详细地介绍这个话题。
