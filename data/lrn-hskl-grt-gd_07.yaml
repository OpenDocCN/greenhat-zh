- en: Chapter 7. Making Our Own Types and Type Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 创建我们自己的类型和类型类
- en: 'So far, we’ve run into a lot of data types: `Bool`, `Int`, `Char`, `Maybe`,
    and so on. But how do we make our own? In this chapter, you’ll learn how to create
    custom types and put them to work!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了很多数据类型：`Bool`、`Int`、`Char`、`Maybe`等等。但我们如何创建自己的呢？在本章中，你将学习如何创建自定义类型并将它们投入使用！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802592.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802592.png.jpg)'
- en: Defining a New Data Type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义新的数据类型
- en: One way to make our own type is to use the `data` keyword. Let’s see how the
    `Bool` type is defined in the standard library.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们自己的类型，可以使用`data`关键字。让我们看看标准库中`Bool`类型是如何定义的。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the `data` keyword like this means that a new data type is being defined.
    The part before the equal sign denotes the type, which in this case is `Bool`.
    The parts after the equal sign are value constructors. They specify the different
    values that this type can have. The `|` is read as *or*. So we can read this as
    saying that the `Bool` type can have a value of `True` or `False`. Note that both
    the type name and the value constructors must start with an uppercase letter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式使用`data`关键字意味着正在定义一个新的数据类型。等号之前的部分表示类型，在这种情况下是`Bool`。等号之后的部分是值构造函数。它们指定了该类型可以具有的不同值。`|`读作“或”。因此，我们可以这样理解：`Bool`类型可以有`True`或`False`的值。请注意，类型名和值构造函数都必须以大写字母开头。
- en: 'In a similar fashion, we can think of the `Int` type as being defined like
    this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以将`Int`类型视为如下定义：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first and last value constructors are the minimum and maximum possible values
    of `Int`. It’s not actually defined like this—you can see I’ve omitted a bunch
    of numbers—but this is useful for illustrative purposes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和最后一个值构造函数是`Int`可能的最小和最大值。实际上并不是这样定义的——你可以看到我省略了一堆数字，但这对于说明目的很有用。
- en: Now let’s think about how we would represent a shape in Haskell. One way would
    be to use tuples. A circle could be denoted as `(43.1, 55.0, 10.4)`, where the
    first and second fields are the coordinates of the circle’s center and the third
    field is the radius. The problem is that those could also represent a 3D vector
    or anything else that could be identified by three numbers. A better solution
    would be to make our own type to represent a shape.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们思考一下如何在Haskell中表示形状。一种方法就是使用元组。一个圆可以表示为`(43.1, 55.0, 10.4)`，其中前两个字段是圆心的坐标，第三个字段是半径。问题是这些也可以代表一个3D向量或任何可以用三个数字识别的东西。一个更好的解决方案是创建我们自己的类型来表示形状。
- en: Shaping Up
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形状塑造
- en: 'Let’s say that a shape can be a circle or a rectangle. Here’s one possible
    definition:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个形状可以是圆形或矩形。这里有一个可能的定义：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What does it mean? Think of it like this: The `Circle` value constructor has
    three fields, which take floats. So when we write a value constructor, we can
    optionally add some types after it, and those types define the types of values
    it will contain. Here, the first two fields are the coordinates of its center,
    and the third one is its radius. The `Rectangle` value constructor has four fields
    that accept floats. The first two act as the coordinates to its upper-left corner,
    and the second two act as coordinates to its lower-right corner.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思呢？可以这样想：`Circle`值构造函数有三个字段，它们接受浮点数。因此，当我们编写值构造函数时，我们可以选择性地在其后添加一些类型，这些类型定义了它将包含的值的类型。在这里，前两个字段是它的中心的坐标，第三个字段是它的半径。`Rectangle`值构造函数有四个字段，接受浮点数。前两个字段作为其左上角的坐标，后两个字段作为其右下角的坐标。
- en: Value constructors are actually functions that ultimately return a value of
    a data type. Let’s take a look at the type signatures for these two value constructors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 值构造函数实际上是最终返回数据类型值的函数。让我们看看这两个值构造函数的类型签名。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So value constructors are functions like everything else. Who would have thought?
    The fields that are in the data type act as parameters to its value constructors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以值构造函数就像其他一切一样是函数。谁能想到呢？数据类型中的字段作为其值构造函数的参数。
- en: Now let’s make a function that takes a `Shape` and returns its area.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个函数，它接受一个`Shape`并返回其面积。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First, note the type declaration. It says that the function takes a `Shape`
    and returns a `Float`. We couldn’t write a type declaration of `Circle -> Float`,
    because `Circle` is not a type, while `Shape` is (just as we can’t write a function
    with a type declaration of `True -> Int`, for example).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意类型声明。它表示该函数接受一个 `Shape` 并返回一个 `Float`。我们无法编写 `Circle -> Float` 的类型声明，因为
    `Circle` 不是一个类型，而 `Shape` 是（就像我们无法编写类型声明为 `True -> Int` 的函数一样）。
- en: Next, notice that we can pattern match against constructors. We’ve already done
    this against values like `[]`, `False`, and `5`, but those values didn’t have
    any fields. In this case, we just write a constructor and then bind its fields
    to names. Because we’re interested in only the radius, we don’t actually care
    about the first two fields, which tell us where the circle is.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意我们可以对构造函数进行模式匹配。我们已经在 `[]`、`False` 和 `5` 等值上这样做过了，但那些值没有任何字段。在这种情况下，我们只需写一个构造函数，然后将它的字段绑定到名称上。因为我们只对半径感兴趣，所以我们实际上不关心前两个字段，它们告诉我们圆在哪里。
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yay, it works! But if we try to just print out `Circle 10 20 5` from the prompt,
    we’ll get an error. That’s because Haskell doesn’t know how to display our data
    type as a string (yet). Remember that when we try to print a value out from the
    prompt, Haskell first applies the `show` function to it to get the string representation
    of our value, and then it prints that to the terminal.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈，它工作了！但如果我们尝试从提示符中直接打印出`Circle 10 20 5`，我们会得到一个错误。这是因为 Haskell 还不知道如何将我们的数据类型显示为字符串（目前还不行）。记住，当我们尝试从提示符中打印一个值时，Haskell
    首先应用 `show` 函数来获取我们值的字符串表示，然后将其打印到终端。
- en: 'To make our `Shape` type part of the `Show` type class, we modify it like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的 `Shape` 类型成为 `Show` 类型类的一部分，我们修改它如下：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We won’t concern ourselves with `deriving` too much for now. Let’s just say
    that if we add `deriving (Show)` at the end of a data declaration (it can go on
    the same line or the next one—it doesn’t matter), Haskell automatically makes
    that type part of the `Show` type class. We’ll be taking a closer look at `deriving`
    in [Derived Instances](ch07s05.html "Derived Instances") in [Derived Instances](ch07s05.html
    "Derived Instances").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会过多关注 `deriving`。让我们这样说，如果我们在一个数据声明的末尾添加 `deriving (Show)`（它可以在同一行或下一行——这无关紧要），Haskell
    会自动使该类型成为 `Show` 类型类的一部分。我们将在 [派生实例](ch07s05.html "派生实例") 中更详细地了解 `deriving`。
- en: 'So now we can do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们可以这样做：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Value constructors are functions, so we can map them, partially apply them,
    and so on. If we want a list of concentric circles with different radii, we can
    do this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 值构造函数是函数，因此我们可以将它们映射、部分应用等等。如果我们想要一个具有不同半径的同心圆列表，我们可以这样做：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Improving Shape with the Point Data Type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用点数据类型改进形状
- en: Our data type is good, but it could be better. Let’s make an intermediate data
    type that defines a point in two-dimensional space. Then we can use that to make
    our shapes more understandable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据类型很好，但可以更好。让我们定义一个中间数据类型，它定义了二维空间中的一个点。然后我们可以使用它来使我们的形状更容易理解。
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that when defining a point, we used the same name for the data type
    and the value constructor. This has no special meaning, although it’s common if
    there’s only one value constructor. So now the `Circle` has two fields: One is
    of type `Point` and the other of type `Float`. This makes it easier to understand
    what’s what. The same goes for `Rectangle`. Now we need to adjust our `area` function
    to reflect these changes.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们定义一个点时，我们使用了相同名称的数据类型和值构造函数。这没有特殊含义，尽管如果只有一个值构造函数，这是常见的。所以现在 `Circle`
    有两个字段：一个是 `Point` 类型，另一个是 `Float` 类型。这使得理解什么是什么是容易的。同样适用于 `Rectangle`。现在我们需要调整我们的
    `area` 函数来反映这些变化。
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only thing we needed to change were the patterns. We disregarded the whole
    point in the `Circle` pattern. In the `Rectangle` pattern, we just used nested
    pattern matching to get the fields of the points. If we wanted to reference the
    points themselves for some reason, we could have used as-patterns.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要改变的是模式。我们在 `Circle` 模式中忽略了整个点。在 `Rectangle` 模式中，我们只是使用嵌套模式匹配来获取点的字段。如果我们出于某种原因需要引用点本身，我们可以使用
    as-patterns。
- en: 'Now we can test our improved version:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的改进版本：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How about a function that nudges a shape? It takes a shape, the amount to move
    it on the x axis, and the amount to move it on the y axis. It returns a new shape
    that has the same dimensions but is located somewhere else.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个推动形状的函数怎么样？它接受一个形状，它在 x 轴上移动的量，以及它在 y 轴上移动的量。它返回一个新的形状，具有相同的尺寸，但位于其他位置。
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is pretty straightforward. We add the nudge amounts to the points that
    denote the position of the shape. Let’s test it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。我们将推力量加到表示形状位置的点上。让我们测试一下：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we don’t want to deal with points directly, we can make some auxiliary functions
    that create shapes of some size at the zero coordinates and then nudge those.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望直接处理点，我们可以创建一些辅助函数，这些函数在零坐标处创建一些形状，然后推动它们。
- en: 'First, let’s make a function that takes a radius and makes a circle that is
    located at the origin of the coordinate system, with the radius we supplied:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个函数，它接受一个半径并创建一个位于坐标系原点的圆，半径为我们提供的半径：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now let’s make a function that takes a width and a height and makes a rectangle
    with those dimensions and its bottom-left corner located at the origin:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个函数，它接受宽度和高度，并使用这些尺寸创建一个矩形，其左下角位于原点：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can use these functions to make shapes that are located at the origin
    of the coordinate system and then nudge them to where we want them to be, which
    makes it easier to create shapes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这些函数来创建位于坐标系原点的形状，然后将它们推动到我们想要的位置，这使得创建形状变得更容易：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Exporting Our Shapes in a Module
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在模块中导出我们的形状
- en: You can also export your data types in your custom modules. To do that, just
    write your type along with the functions you are exporting, and then add some
    parentheses that specify the value constructors that you want to export, separated
    by commas. If you want to export all the value constructors for a given type,
    just write two dots (`..`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在自定义模块中导出您的数据类型。为此，只需写出您要导出的类型以及您要导出的函数，然后添加一些括号，指定您想要导出的值构造函数，并用逗号分隔。如果您想导出给定类型的所有值构造函数，只需写两个点（`..`）。
- en: 'Suppose we want to export our shape functions and types in a module. We start
    off like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在模块中导出我们的形状函数和类型。我们开始是这样的：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By using `Shape(..)`, we export all the value constructors for `Shape`. This
    means that people who import our module can make shapes by using the `Rectangle`
    and `Circle` value constructors. It’s the same as writing `Shape (Rectangle, Circle)`,
    but shorter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Shape(..)`，我们导出了`Shape`的所有值构造函数。这意味着导入我们模块的人可以使用`Rectangle`和`Circle`值构造函数来创建形状。这与写`Shape
    (Rectangle, Circle)`相同，但更简洁。
- en: Also, if we decide to add some value constructors to our type later on, we don’t
    need to modify the exports. That’s because using `..` automatically exports all
    value constructors for a given type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们决定稍后向我们的类型添加一些值构造函数，我们不需要修改导出。这是因为使用`..`会自动导出给定类型的所有值构造函数。
- en: Alternatively, we could opt to not export any value constructors for `Shape`
    by just writing `Shape` in the export statement, without the parentheses. That
    way, people who import our module could make shapes only by using the auxiliary
    functions `baseCircle` and `baseRect`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以选择不通过在导出语句中只写`Shape`而不带括号来导出`Shape`的任何值构造函数。这样，导入我们模块的人只能通过使用我们在模块中提供的辅助函数`baseCircle`和`baseRect`来创建形状。
- en: Remember that value constructors are just functions that take the fields as
    parameters and return a value of some type (like `Shape`). So when we choose not
    to export them, we prevent the person importing our module from using those value
    constructors directly. Not exporting the value constructors of our data types
    makes them more abstract, since we’re hiding their implementation. Also, whoever
    uses our module can’t pattern match against the value constructors. This is good
    if we want people who import our module to be able to interact with our type only
    via the auxiliary functions that we supply in our module. That way, they don’t
    need to know about the internal details of our module, and we can change those
    details whenever we want, as long as the functions that we export act the same.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，值构造函数只是接受字段作为参数并返回某种类型（如`Shape`）值的函数。因此，当我们选择不导出它们时，我们阻止导入我们模块的人直接使用这些值构造函数。不导出我们数据类型的值构造函数使它们更加抽象，因为我们隐藏了它们的实现。此外，使用我们模块的人不能对值构造函数进行模式匹配。如果我们希望导入我们模块的人只能通过我们在模块中提供的辅助函数与我们类型交互，这是好的。这样，他们就不需要了解我们模块的内部细节，只要我们导出的函数行为相同，我们就可以随时更改这些细节。
- en: '`Data.Map` uses this approach. You can’t create a map by directly using its
    value constructor, whatever it may be, because it’s not exported. However, you
    can make a map by using one of the auxiliary functions like `Map.fromList`. The
    people in charge of `Data.Map` can change the way that maps are internally represented
    without breaking existing programs.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map` 使用这种方法。你不能直接使用其值构造函数来创建映射，无论它是什么，因为它没有被导出。然而，你可以通过使用辅助函数（如 `Map.fromList`）之一来创建映射。负责
    `Data.Map` 的人可以在不破坏现有程序的情况下更改映射的内部表示方式。'
- en: But for simpler data types, exporting the value constructors is perfectly fine,
    too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于更简单的数据类型，导出值构造函数也是完全可以接受的。
- en: Record Syntax
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录语法
- en: Now let’s look at how we can create another kind of data type. Say we’ve been
    tasked with creating a data type that describes a person. The information that
    we want to store about that person is first name, last name, age, height, phone
    number, and favorite ice cream flavor. (I don’t know about you, but that’s all
    I ever want to know about a person.) Let’s give it a go!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何创建另一种类型的数据类型。假设我们被要求创建一个描述人的数据类型。我们想要存储关于这个人的信息包括名字、姓氏、年龄、身高、电话号码和最喜欢的冰淇淋口味。（我不知道你，但这是我想要了解的所有关于一个人的信息。）让我们试试看！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802594.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802594.png.jpg)'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first field is the first name, the second is the last name, the third is
    the age, and so on. Now let’s make a person.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是名字，第二个是姓氏，第三个是年龄，以此类推。现在让我们创建一个人。
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s kind of cool, although slightly unreadable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点酷，尽管稍微有点难以阅读。
- en: 'Now what if we want to create functions to get specific pieces of information
    about a person? We need a function that gets some person’s first name, a function
    that gets some person’s last name, and so on. Well, we would need to define them
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们想创建函数来获取关于一个人的特定信息呢？我们需要一个函数来获取某个人的名字，一个函数来获取某个人的姓氏，等等。好吧，我们需要像这样定义它们：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Whew! I certainly did not enjoy writing that! But despite being very cumbersome
    and *boring* to write, this method works.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 呼呼！我确实不喜欢写这个！但尽管写起来非常繁琐且 *无聊*，这种方法是有效的。
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: “Still, there must be a better way!” you say. Well, no, there isn’t, sorry.
    Just kidding—there is. Hahaha!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “然而，肯定还有更好的方法！”你说。好吧，不，没有，抱歉。开个玩笑——确实有。哈哈哈！
- en: 'Haskell gives us an alternative way to write data types. Here’s how we could
    achieve the same functionality with *record syntax*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 给我们提供了另一种编写数据类型的方法。以下是使用 *记录语法* 实现相同功能的方法：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So instead of just naming the field types one after another and separating
    them with spaces, we use curly brackets. First, we write the name of the field
    (for instance, `firstName`), followed by a double colon (`::`), and then the type.
    The resulting data type is exactly the same. The main benefit of using this syntax
    is that it creates functions that look up fields in the data type. By using record
    syntax to create this data type, Haskell automatically makes these functions:
    `firstName`, `lastName`, `age`, `height`, `phoneNumber`, and `flavor`. Take a
    look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们不是简单地一个接一个地命名字段类型，并用空格分隔它们，而是使用花括号。首先，我们写字段名（例如，`firstName`），然后是双冒号（`::`），接着是类型。结果的数据类型完全相同。使用这种语法的最大好处是它创建了一些查找数据类型中字段的函数。通过使用记录语法来创建这种数据类型，Haskell
    自动创建了这些函数：`firstName`、`lastName`、`age`、`height`、`phoneNumber` 和 `flavor`。看看这个例子：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There’s another benefit to using record syntax. When we derive `Show` for the
    type, it displays it differently if we use record syntax to define and instantiate
    the type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录语法还有一个好处。当我们为类型推导 `Show` 时，如果我们使用记录语法来定义和实例化类型，它将以不同的方式显示。
- en: 'Say we have a type that represents a car. We want to keep track of the company
    that made it, the model name, and its year of production. We can define this type
    without using record syntax, like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示汽车的类型。我们想要跟踪制造它的公司、型号名称以及它的生产年份。我们可以不使用记录语法来定义这个类型，如下所示：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A car is displayed like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车是这样显示的：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let’s see what happens when we define it using record syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用记录语法定义会发生什么：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can make a car like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样创建一辆汽车：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When making a new car, we don’t need to put the fields in the proper order,
    as long as we list all of them. But if we don’t use record syntax, we must specify
    them in order.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当制造一辆新车时，我们不需要将字段按正确的顺序放置，只要我们列出所有字段即可。但是，如果我们不使用记录语法，我们必须按顺序指定它们。
- en: Use record syntax when a constructor has several fields and it’s not obvious
    which field is which. If we make a 3D vector data type by doing `data Vector =
    Vector Int Int Int`, it’s pretty obvious that the fields are the components of
    a vector. However, in our `Person` and `Car` types, the fields are not so obvious,
    and we greatly benefit from using record syntax.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数有几个字段且不清楚哪个字段是哪个时，使用记录语法。如果我们通过 `data Vector = Vector Int Int Int` 来创建一个三维向量数据类型，那么字段就是向量的分量，这很显然。然而，在我们的
    `Person` 和 `Car` 类型中，字段并不那么明显，我们极大地受益于使用记录语法。
- en: Type Parameters
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数
- en: A value constructor can take some parameters and then produce a new value. For
    instance, the `Car` constructor takes three values and produces a `car` value.
    In a similar manner, type constructors can take types as parameters to produce
    new types. This might sound a bit too meta at first, but it’s not that complicated.
    (If you’re familiar with templates in C++, you’ll see some parallels.) To get
    a clear picture of how type parameters work in action, let’s take a look at how
    a type we’ve already met is implemented.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 值构造函数可以接受一些参数并生成一个新的值。例如，`Car` 构造函数接受三个值并生成一个 `car` 值。以类似的方式，类型构造函数可以接受类型作为参数来生成新的类型。一开始这可能会听起来有些过于抽象，但实际上并不复杂。（如果你熟悉
    C++ 中的模板，你会看到一些相似之处。）为了清楚地了解类型参数在实际中的应用，让我们看看我们之前遇到的一个类型是如何实现的。
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802596.png.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802596.png.jpg)'
- en: The `a` here is the type parameter. And because there’s a type parameter involved,
    we call `Maybe` a *type constructor*. Depending on what we want this data type
    to hold when it’s not `Nothing`, this type constructor can end up producing a
    type of `Maybe Int`, `Maybe Car`, `Maybe String`, and so on. No value can have
    a type of just `Maybe`, because that’s not a type—it’s a type constructor. In
    order for this to be a real type that a value can be part of, it must have all
    its type parameters filled up.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `a` 是类型参数。由于涉及到类型参数，我们称 `Maybe` 为 *类型构造函数*。根据我们想要这个数据类型在非 `Nothing` 时持有的内容，这个类型构造函数最终可以生成
    `Maybe Int`、`Maybe Car`、`Maybe String` 等类型。没有任何值可以有 `Maybe` 的类型，因为那不是一个类型——它是一个类型构造函数。为了使这成为一个真正的类型，一个值可以成为其一部分，它必须填充所有类型参数。
- en: So if we pass `Char` as the type parameter to `Maybe`, we get a type of `Maybe
    Char`. The value `Just 'a'` has a type of `Maybe Char`, for example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们把 `Char` 作为类型参数传递给 `Maybe`，我们得到一个 `Maybe Char` 类型。例如，值 `Just 'a'` 的类型是
    `Maybe Char`。
- en: Most of the time, we don’t pass types as parameters to type constructors explicitly.
    That’s because Haskell has type inference. So when we make a value `Just 'a'`,
    for example, Haskell figures out that it’s a `Maybe Char`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们不会显式地将类型作为参数传递给类型构造函数。这是因为 Haskell 有类型推断。所以当我们创建一个值 `Just 'a'` 时，例如，Haskell
    会推断出它是一个 `Maybe Char`。
- en: 'If we want to explicitly pass a type as a type parameter, we must do it in
    the type part of Haskell, which is usually after the `::` symbol. This can come
    in handy if, for example, we want a value of `Just 3` to have the type `Maybe
    Int`. By default, Haskell will infer the type `(Num a) => Maybe a` for that value.
    We can use an explicit type annotation to restrict the type a bit:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想显式地传递一个类型作为类型参数，我们必须在 Haskell 的类型部分中这样做，这通常是在 `::` 符号之后。例如，如果我们想让 `Just
    3` 的类型是 `Maybe Int`，这会很有用。默认情况下，Haskell 会推断出该值的类型为 `(Num a) => Maybe a`。我们可以使用显式的类型注解来稍微限制一下类型：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You might not know it, but we used a type that has a type parameter before
    we used `Maybe`: the list type. Although there’s some syntactic sugar in play,
    the list type takes a parameter to produce a concrete type. Values can have an
    `[Int]` type, a `[Char]` type, or a `[[String]]` type, but you can’t have a value
    that just has a type of `[]`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不知道，在我们使用 `Maybe` 之前，我们已经使用了一个具有类型参数的类型：列表类型。尽管有一些语法糖，但列表类型接受一个参数来生成一个具体类型。值可以有
    `[Int]` 类型、`[Char]` 类型或 `[[String]]` 类型，但你不能有一个只有 `[]` 类型的值。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We say that a type is *concrete* if it doesn’t take any type parameters at all
    (like `Int` or `Bool`), or if it takes type parameters and they’re all filled
    up (like `Maybe Char`). If you have some value, its type is always a concrete
    type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个类型是 *具体的*，如果它根本不接受任何类型参数（比如 `Int` 或 `Bool`），或者如果它接受类型参数并且它们都被填充了（比如 `Maybe
    Char`）。如果你有一个值，它的类型始终是一个具体类型。
- en: 'Let’s play around with the `Maybe` type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一玩 `Maybe` 类型：
- en: '[PRE30]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Type parameters are useful because they allow us to make data types that can
    hold different things. For instance, we could make a separate `Maybe`-like data
    type for every type that it could contain, like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数是有用的，因为它们允许我们创建可以持有不同类型的数据类型。例如，我们可以为它可能包含的每个类型创建一个单独的类似 `Maybe` 的数据类型，如下所示：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: But even better, we could use type parameters to make a generic `Maybe` that
    can contain values of any type at all!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但更好的是，我们可以使用类型参数来创建一个通用的 `Maybe`，它可以包含任何类型的值！
- en: Notice that the type of `Nothing` is `Maybe a`. Its type is *polymorphic*, which
    means that it features type variables, namely the `a` in `Maybe a`. If some function
    requires a `Maybe Int` as a parameter, we can give it a `Nothing`, because a `Nothing`
    doesn’t contain a value anyway, so it doesn’t matter. The `Maybe a` type can act
    like a `Maybe Int` if it must, just as `5` can act like an `Int` or a `Double`.
    Similarly, the type of the empty list is `[a]`. An empty list can act like a list
    of anything. That’s why we can do `[1,2,3] ++ []` and `["ha","ha","ha"] ++ []`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Nothing` 的类型是 `Maybe a`。它的类型是 *多态的*，这意味着它具有类型变量，即 `Maybe a` 中的 `a`。如果某个函数需要一个
    `Maybe Int` 作为参数，我们可以给它一个 `Nothing`，因为 `Nothing` 本身不包含任何值，所以这无关紧要。`Maybe a` 类型可以在必要时充当
    `Maybe Int`，就像 `5` 可以充当 `Int` 或 `Double` 一样。同样，空列表的类型是 `[a]`。空列表可以充当任何类型的列表。这就是为什么我们可以这样做
    `[1,2,3] ++ []` 和 `["ha","ha","ha"] ++ []`。
- en: Should We Parameterize Our Car?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们是否应该对 `Car` 进行参数化？
- en: When does using type parameters make sense? Usually, we use them when our data
    type would work regardless of the type of the value it then holds, as with our
    `Maybe a` type. If our type acts as some kind of box, it’s good to use parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在什么情况下使用类型参数是有意义的？通常，当我们的数据类型无论其持有的值的类型如何都能正常工作时，我们会使用它们，就像我们的 `Maybe a` 类型一样。如果我们的类型充当某种类型的盒子，那么使用参数是好的。
- en: 'Consider our `Car` data type:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的 `Car` 数据类型：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We could change it to this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其修改为如下：
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: But would we really benefit? Probably not, because we would just end up defining
    functions that work on only the `Car String String Int` type. For instance, given
    our first definition of `Car`, we could make a function that displays the car’s
    properties in an easy-to-read format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真的会从中受益吗？可能不会，因为我们只会定义出只对 `Car String String Int` 类型起作用的函数。例如，根据我们对 `Car`
    的第一个定义，我们可以创建一个函数，以易于阅读的格式显示汽车属性。
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We could test it like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样测试它：
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s a good little function! The type declaration is cute, and it works nicely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的小函数！类型声明很可爱，而且它工作得很好。
- en: Now what if `Car` was `Car a b c`?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 `Car` 是 `Car a b c` 呢？
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We would need to force this function to take a `Car` type of `(Show a) => Car
    String String a`. You can see that the type signature is more complicated, and
    the only actual benefit would be that we could use any type that’s an instance
    of the `Show` type class as the type for `c`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要强制这个函数接受一个 `(Show a) => Car String String a` 类型的 `Car`。你可以看到类型签名更复杂，唯一的实际好处是我们可以使用任何
    `Show` 类型类的实例作为 `c` 的类型：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In real life though, we would end up using `Car String String Int` most of the
    time. So, parameterizing the `Car` type isn’t worth it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实生活中，我们大多数时候会使用 `Car String String Int`。所以，对 `Car` 类型进行参数化并不值得。
- en: We usually use type parameters when the type that’s contained inside the data
    type’s various value constructors isn’t really that important for the type to
    work. A list of stuff is a list of stuff, and it doesn’t matter what the type
    of that stuff is. If we need to sum a list of numbers, we can specify later in
    the summing function that we specifically want a list of numbers. The same goes
    for `Maybe`, which represents an option of either having nothing or having one
    of something. It doesn’t matter what the type of that something is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在数据类型内部的各种值构造函数所包含的类型对类型本身的工作并不重要时使用类型参数。一堆东西是一堆东西，而这堆东西的类型并不重要。如果我们需要求和一堆数字，我们可以在求和函数中指定我们具体想要一个数字列表。对于
    `Maybe` 也是如此，它表示要么什么都没有，要么有一个东西。那个东西的类型并不重要。
- en: 'Another example of a parameterized type that you’ve already met is `Map k v`
    from `Data.Map`. The `k` is the type of the keys in a map, and `v` is the type
    of the values. This is a good example of where type parameters are very useful.
    Having maps parameterized enables us to have mappings from any type to any other
    type, as long as the type of the key is part of the `Ord` type class. If we were
    defining a mapping type, we could add a type class constraint in the data declaration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经遇到的一个参数化类型的例子是 `Data.Map` 中的 `Map k v`。`k` 是映射中键的类型，而 `v` 是值的类型。这是一个类型参数非常有用的好例子。对映射进行参数化使我们能够将任何类型映射到任何其他类型，只要键的类型是
    `Ord` 类型类的一部分。如果我们正在定义一个映射类型，我们可以在数据声明中添加一个类型类约束：
- en: '[PRE38]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, it’s a very strong convention in Haskell to never add type class constraints
    in data declarations. Why? Well, because it doesn’t provide much benefit, and
    we end up writing more class constraints, even when we don’t need them. If we
    put the `Ord k` constraint in the data declaration for `Map k v`, we still need
    to put the constraint into functions that assume the keys in a map can be ordered.
    If we don’t put the constraint in the data declaration, then we don’t need to
    put `(Ord k) =>` in the type declarations of functions that don’t care whether
    the keys can be ordered. An example of such a function is `toList`, which just
    takes a mapping and converts it to an associative list. Its type signature is
    `toList :: Map k a -> [(k, a)]`. If `Map k v` had a type constraint in its data
    declaration, the type for `toList` would need to be `toList :: (Ord k) => Map
    k a -> [(k, a)]`, even though the function doesn’t compare keys by order.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，在 Haskell 中，永远不在数据声明中添加类型类约束是一个非常强的约定。为什么？好吧，因为它提供的好处不多，我们最终会写出更多的类约束，即使我们不需要它们。如果我们将
    `Ord k` 约束放入 `Map k v` 的数据声明中，我们仍然需要在假设映射中的键可以排序的函数中放入约束。如果我们不在数据声明中放入约束，那么我们就不需要在那些不关心键是否可以排序的函数的类型声明中放入
    `(Ord k) =>`。这样一个函数的例子是 `toList`，它只是将映射转换为一个关联列表。它的类型签名是 `toList :: Map k a ->
    [(k, a)]`。如果 `Map k v` 在其数据声明中有一个类型约束，`toList` 的类型就需要是 `toList :: (Ord k) => Map
    k a -> [(k, a)]`，即使这个函数并不按顺序比较键。'
- en: So don’t put type constraints into data declarations, even if it seems to make
    sense. You’ll need to put them into the function type declarations either way.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所以不要在数据声明中放入类型约束，即使看起来似乎有道理。无论如何，你都需要将它们放入函数类型声明中。
- en: Vector von Doom
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vector von Doom
- en: Let’s implement a 3D vector type and add some operations for it. We’ll make
    it a parameterized type, because even though it will usually contain numeric types,
    it will still support several of them, like `Int`, `Integer`, and `Double`, to
    name a few.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个三维向量类型，并为它添加一些操作。我们将使其成为一个参数化类型，因为尽管它通常将包含数值类型，但它仍然支持多种类型，例如 `Int`、`Integer`
    和 `Double`，仅举几个例子。
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Imagine a vector as an arrow in space—a line that points somewhere. The vector
    `Vector 3 4 5` would be a line that starts at the coordinates (0,0,0) in 3D space
    and ends at (and points to) the coordinates (3,4,5).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个向量在空间中就像一个箭头——一条指向某处的线。向量 `Vector 3 4 5` 将是一条从三维空间中的坐标 (0,0,0) 开始并指向坐标 (3,4,5)
    的线。
- en: 'The vector functions work as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 向量函数的工作方式如下：
- en: The `vplus` function adds two vectors together. This is done just by adding
    their corresponding components. When you add two vectors, you get a vector that’s
    the same as putting the second vector at the end of the first one and then drawing
    a vector from the beginning of the first one to the end of the second one. So
    adding two vectors together results in a third vector.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vplus` 函数将两个向量相加。这是通过将它们的对应分量相加来完成的。当你将两个向量相加时，你会得到一个与将第二个向量放在第一个向量的末尾然后从第一个向量的开始到第二个向量的末尾画一条向量相同的向量。所以将两个向量相加的结果是第三个向量。'
- en: The `dotProd` function gets the dot product of two vectors. The result of a
    dot product is a number, and we get it by multiplying the components of a vector
    pairwise and then adding all that together. The dot product of two vectors is
    useful when we want to figure out the angle between two vectors.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotProd` 函数获取两个向量的点积。点积的结果是一个数字，我们通过成对乘以向量的分量并将它们全部相加来得到它。当我们想要找出两个向量之间的角度时，两个向量的点积非常有用。'
- en: The `vmult` function multiplies a vector with a number. If we multiply a vector
    with a number, we multiply every component of the vector with that number, effectively
    elongating (or shortening it), but it keeps on pointing in the same general direction.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmult` 函数将一个向量与一个数字相乘。如果我们用一个数字乘以一个向量，我们将向量的每个分量与该数字相乘，实际上会延长（或缩短）它，但仍然指向大致相同的方向。'
- en: These functions can operate on any type in the form of `Vector a`, as long as
    the `a` is an instance of the `Num` type class. For instance, they can operate
    on values of type `Vector Int`, `Vector Integer`, `Vector Float`, and so on, because
    `Int`, `Integer`, and `Float` are all instances of the `Num` type class. However,
    they won’t work on values of type `Vector Char` or `Vector Bool`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以作用于任何形式为 `Vector a` 的类型，只要 `a` 是 `Num` 类型类的实例。例如，它们可以作用于 `Vector Int`、`Vector
    Integer`、`Vector Float` 等类型的值，因为 `Int`、`Integer` 和 `Float` 都是 `Num` 类型类的实例。然而，它们不能作用于
    `Vector Char` 或 `Vector Bool` 类型的值。
- en: Also, if you examine the type declaration for these functions, you’ll see that
    they can operate only on vectors of the same type, and the numbers involved must
    also be of the type that is contained in the vectors. We can’t add together a
    `Vector Int` and a `Vector Double`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你检查这些函数的类型声明，你会发现它们只能作用于相同类型的向量，并且涉及的数字也必须是向量中包含的类型。我们不能将 `Vector Int`
    和 `Vector Double` 相加。
- en: Notice that we didn’t put a `Num` class constraint in the data declaration.
    As explained in the previous section, even if we put it there, we would still
    need to repeat it in the functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在数据声明中放置 `Num` 类约束。正如前一小节所解释的，即使我们放置了它，我们仍然需要在函数中重复它。
- en: 'Once again, it’s very important to distinguish between the type constructor
    and the value constructor. When declaring a data type, the part before the `=`
    is the type constructor, and the constructors after it (possibly separated by
    `|` characters) are value constructors. For instance, giving a function the following
    type would be wrong:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，区分类型构造器和值构造器非常重要。在声明数据类型时，`=` 前的部分是类型构造器，而其后的构造器（可能由 `|` 字符分隔）是值构造器。例如，给一个函数以下类型是错误的：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This doesn’t work because the type of our vector is `Vector a`, and not `Vector
    a a a`. It takes only one type parameter, even though its value constructor has
    three fields.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这不工作是因为我们向量的类型是 `Vector a`，而不是 `Vector a a a`。它只接受一个类型参数，尽管它的值构造器有三个字段。
- en: Now, let’s play around with our vectors.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来玩一下我们的向量。
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Derived Instances
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生实例
- en: In [Type Classes 101](ch02s04.html "Type Classes 101") in [Type Classes 101](ch02s04.html
    "Type Classes 101"), you learned that a type class is a sort of an interface that
    defines some behavior, and that a type can be made an instance of a type class
    if it supports that behavior. For example, the `Int` type is an instance of the
    `Eq` type class because the `Eq` type class defines behavior for stuff that can
    be equated. And because integers can be equated, `Int` was made a part of the
    `Eq` type class. The real usefulness comes with the functions that act as the
    interface for `Eq`, namely `==` and `/=`. If a type is a part of the `Eq` type
    class, we can use the `==` functions with values of that type. That’s why expressions
    like `4 == 4` and `"foo" == "bar"` type check.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Type Classes 101](ch02s04.html "Type Classes 101") 中，你了解到类型类是一种接口，它定义了一些行为，并且如果一个类型支持这种行为，它可以成为类型类的一个实例。例如，`Int`
    类型是 `Eq` 类型类的一个实例，因为 `Eq` 类型类定义了可以相等的行为。由于整数可以相等，`Int` 成为了 `Eq` 类型类的一部分。真正的实用性来自于作为
    `Eq` 接口的函数，即 `==` 和 `/=`。如果一个类型是 `Eq` 类型类的一部分，我们就可以使用该类型的值来使用 `==` 函数。这就是为什么 `4
    == 4` 和 `"foo" == "bar"` 这样的表达式可以类型检查的原因。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802598.png.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802598.png.jpg)'
- en: Haskell type classes are often confused with classes in languages like Java,
    Python, C++ and the like, which trips up a lot of programmers. In those languages,
    classes are a blueprint from which we create objects that can do some actions.
    But we don’t make data from Haskell type classes. Instead, we first make our data
    type, and then we think about how it can act. If it can act like something that
    can be equated, we make it an instance of the `Eq` type class. If it can act like
    something that can be ordered, we make it an instance of the `Ord` type class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell类型类经常与Java、Python、C++等语言中的类混淆，这让很多程序员感到困惑。在这些语言中，类是从中创建可以执行某些操作的对象的蓝图。但我们在Haskell类型类中并不创建数据。相反，我们首先创建我们的数据类型，然后考虑它如何行动。如果它可以像可以等同的东西一样行动，我们就让它成为`Eq`类型类的实例。如果它可以像可以排序的东西一样行动，我们就让它成为`Ord`类型类的实例。
- en: 'Let’s see how Haskell can automatically make our type an instance of any of
    the following type classes: `Eq`, `Ord`, `Enum`, `Bounded`, `Show`, and `Read`.
    Haskell can derive the behavior of our types in these contexts if we use the `deriving`
    keyword when making our data type.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Haskell如何自动使我们的类型成为以下类型类的实例：`Eq`、`Ord`、`Enum`、`Bounded`、`Show`和`Read`。如果我们使用`deriving`关键字来创建我们的数据类型，Haskell可以推导出这些上下文中我们类型的行怍。
- en: Equating People
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等同人物
- en: 'Consider this data type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个数据类型：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It describes a person. Let’s assume that no two people have the same combination
    of first name, last name, and age. If we have records for two people, does it
    make sense to see if they represent the same person? Sure it does. We can try
    to equate them to see if they are equal. That’s why it would make sense for this
    type to be part of the `Eq` type class. We’ll derive the instance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了一个人物。让我们假设没有两个人的名字、姓氏和年龄组合是相同的。如果我们有两个人的记录，查看他们是否代表同一个人是否有意义？当然有意义。我们可以尝试将它们等同起来，看看它们是否相等。这就是为什么这种类型成为`Eq`类型类的一部分是有意义的。我们将推导出实例。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we derive the `Eq` instance for a type and then try to compare two values
    of that type with `==` or `/=`, Haskell will see if the value constructors match
    (there’s only one value constructor here though), and then it will check if all
    the data contained inside matches by testing each pair of fields with `==`. However,
    there’s a catch: The types of all the fields also must be part of the `Eq` type
    class. But since that’s the case with both `String` and `Int`, we’re okay.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为一个类型推导出`Eq`实例，然后尝试使用`==`或`/=`比较该类型的两个值时，Haskell会检查值构造函数是否匹配（这里只有一个值构造函数），然后它会通过使用`==`测试每一对字段来检查包含在其中的所有数据是否匹配。然而，有一个问题：所有字段的类型也必须是`Eq`类型类的一部分。但由于`String`和`Int`都是这种情况，所以我们没问题。
- en: 'First, let’s make a few people. Put the following in a script:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些人。将以下内容放入脚本中：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now let’s test our `Eq` instance:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试我们的`Eq`实例：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Of course, since `Person` is now in `Eq`, we can use it as the `a` for all functions
    that have a class constraint of `Eq a` in their type signature, such as `elem`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于`Person`现在在`Eq`中，我们可以将其用作所有在类型签名中有`Eq a`类约束的函数的`a`，例如`elem`。
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Show Me How to Read
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示如何读取
- en: The `Show` and `Read` type classes are for things that can be converted to or
    from strings, respectively. As with `Eq`, if a type’s constructors have fields,
    their type must be a part of `Show` or `Read` if we want to make our type an instance
    of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Show`和`Read`类型类是为了可以转换为或从字符串转换的事物。与`Eq`一样，如果类型的构造函数有字段，它们的类型必须是`Show`或`Read`的一部分，如果我们想使我们的类型成为它们的实例。'
- en: Let’s make our `Person` data type a part of `Show` and `Read` as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`Person`数据类型也变成`Show`和`Read`的一部分。
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we can print a person out to the terminal.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将一个人打印到终端。
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we had tried to print a person on the terminal before making the `Person`
    data type part of `Show`, Haskell would have complained, claiming it didn’t know
    how to represent a person as a string. But since we first derived a `Show` instance
    for the data type, we didn’t get any complaints.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在将`Person`数据类型变成`Show`的一部分之前在终端上打印一个人，Haskell会抱怨，声称它不知道如何将一个人表示为字符串。但由于我们首先为数据类型推导出一个`Show`实例，所以我们没有收到任何抱怨。
- en: '`Read` is pretty much the inverse type class of `Show`. It’s for converting
    strings to values of our type. Remember though, that when we use the `read` function,
    we might need to use an explicit type annotation to tell Haskell which type we
    want to get as a result. To demonstrate this, let’s put a string that represents
    a person in a script and then load that script in GHCi:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 几乎是 `Show` 的逆类型类。它是用于将字符串转换为我们的类型的值。但请记住，当我们使用 `read` 函数时，我们可能需要使用显式的类型注解来告诉
    Haskell 我们想要得到的结果类型。为了演示这一点，让我们将表示一个人的字符串放入脚本中，然后在 GHCi 中加载该脚本：'
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We wrote our string across several lines like this for increased readability.
    If we want to `read` that string, we need to tell Haskell which type we expect
    in return:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样将字符串跨越多行，以提高可读性。如果我们想 `read` 那个字符串，我们需要告诉 Haskell 我们期望返回哪种类型：
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we use the result of our `read` later in a way that Haskell can infer that
    it should read it as a person, we don’t need to use type annotation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍后以 Haskell 可以推断出它应该将其视为人的方式使用我们的 `read` 结果，我们就不需要使用类型注解。
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also read parameterized types, but we must give Haskell enough information
    so that it can figure out which type we want. If we try the following, we’ll get
    an error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以读取参数化类型，但我们必须给 Haskell 足够的信息，以便它可以确定我们想要哪种类型。如果我们尝试以下操作，我们会得到一个错误：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this case, Haskell doesn’t know which type to use for the type parameter
    `a`. But if we tell it that we want it to be an `Int`, it works just fine:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Haskell 不知道应该为类型参数 `a` 使用哪种类型。但如果我们告诉它我们想要它是一个 `Int`，它就可以正常工作：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Order in the Court!
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 法庭秩序！
- en: 'We can derive instances for the `Ord` type class, which is for types that have
    values that can be ordered. If we compare two values of the same type that were
    made using different constructors, the value that was defined first is considered
    smaller. For instance, consider the `Bool` type, which can have a value of either
    `False` or `True`. For the purpose of seeing how it behaves when compared, we
    can think of it as being implemented like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 `Ord` 类型类推导实例，它是用于具有可排序值的类型的。如果我们比较使用不同构造函数制作的同一类型的两个值，则首先定义的值被认为是较小的。例如，考虑
    `Bool` 类型，它可以具有 `False` 或 `True` 的值。为了了解它在比较时的行为，我们可以将其视为如下实现：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because the `False` value constructor is specified first and the `True` value
    constructor is specified after it, we can consider `True` as greater than `False`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `False` 值构造函数先指定，而 `True` 值构造函数在其后指定，我们可以认为 `True` 大于 `False`。
- en: '[PRE55]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If two values were made using the same constructor, they are considered to be
    equal, unless they have fields. If they have fields, the fields are compared to
    see which is greater. (Note that in this case, the types of the fields also must
    be part of the `Ord` type class.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个值使用相同的构造函数创建，它们被认为是相等的，除非它们有字段。如果有字段，则比较字段以确定哪个更大。（注意，在这种情况下，字段的类型也必须是 `Ord`
    类型类的成员。）
- en: In the `Maybe a` data type, the `Nothing` value constructor is specified before
    the `Just` value constructor, so the value of `Nothing` is always smaller than
    the value of `Just something`, even if that something is minus one billion trillion.
    But if we specify two `Just` values, then it will compare what’s inside them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Maybe a` 数据类型中，`Nothing` 值构造函数在 `Just` 值构造函数之前指定，因此 `Nothing` 的值始终小于 `Just
    something` 的值，即使那个“something”是一万亿。但如果我们指定两个 `Just` 值，那么它将比较它们内部的内容。
- en: '[PRE56]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: However, we can’t do something like `Just (*3) > Just (*2)`, because `(*3)`
    and `(*2)` are functions, which are not instances of `Ord`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能做类似 `Just (*3) > Just (*2)` 的事情，因为 `(*3)` 和 `(*2)` 是函数，它们不是 `Ord` 的实例。
- en: Any Day of the Week
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何一周的日子
- en: 'We can easily use algebraic data types to make enumerations, and the `Enum`
    and `Bounded` type classes help us with that. Consider the following data type:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地使用代数数据类型来制作枚举，`Enum` 和 `Bounded` 类型类帮助我们做到这一点。考虑以下数据类型：
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because all the type’s value constructors are nullary (that is, they don’t have
    any fields), we can make it part of the `Enum` type class. The `Enum` type class
    is for things that have predecessors and successors. We can also make it part
    of the `Bounded` type class, which is for things that have a lowest possible value
    and highest possible value. And while we’re at it, let’s also make it an instance
    of all the other derivable type classes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有类型的值构造函数都是零元（即它们没有任何字段），我们可以将其作为 `Enum` 类型类的一部分。`Enum` 类型类是用于有前驱和后继的事物。我们还可以将其作为
    `Bounded` 类型类的一部分，它是用于有最低可能值和最高可能值的事物。而且，既然我们提到了这一点，让我们也使其成为所有其他可推导类型类的实例。
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now let’s see what we can do with our new `Day` type. Because it’s part of the
    `Show` and `Read` type classes, we can convert values of this type to and from
    strings.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用我们新的`Day`类型。因为它属于`Show`和`Read`类型类，我们可以将此类型的值转换为字符串，反之亦然。
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Because it’s part of the `Eq` and `Ord` type classes, we can compare or equate
    days.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是`Eq`和`Ord`类型类的一部分，我们可以比较或等同日期。
- en: '[PRE60]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It’s also part of `Bounded`, so we can get the lowest and highest day.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它也是`Bounded`的一部分，因此我们可以获取最低和最高的日期。
- en: '[PRE61]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As it’s an instance of `Enum`, we can get predecessors and successors of days
    and make list ranges from them!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是`Enum`的一个实例，我们可以获取日期的前驱和后继，并从它们中创建列表范围！
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Type Synonyms
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: As mentioned earlier, when writing types, the `[Char]` and `String` types are
    equivalent and interchangeable. That’s implemented with *type synonyms*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在编写类型时，`[Char]`和`String`类型是等效的，可以互换。这是通过*类型别名*实现的。
- en: 'Type synonyms don’t really do anything per se—they’re just about giving some
    types different names so that they make more sense to someone reading our code
    and documentation. Here’s how the standard library defines `String` as a synonym
    for `[Char]`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名本身并不真正做任何事情——它们只是给一些类型赋予不同的名称，以便让阅读我们的代码和文档的人更容易理解。以下是标准库如何将`String`定义为`[Char]`的别名的示例：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802600.png.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802600.png.jpg)'
- en: '[PRE63]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `type` keyword here might be misleading, because a new type is not being
    created (that’s done with the `data` keyword). Rather, this defines a synonym
    for an existing type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`type`关键字可能具有误导性，因为并没有创建一个新的类型（这是通过`data`关键字完成的）。相反，这定义了一个现有类型的别名。
- en: 'If we make a function that converts a string to uppercase and call it `toUpperString`,
    we can give it a type declaration of this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个将字符串转换为大写的函数并命名为`toUpperString`，我们可以给它以下类型声明：
- en: '[PRE64]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Alternatively, we can use this type declaration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用以下类型声明：
- en: '[PRE65]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The two are essentially the same, but the latter is nicer to read.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者本质上相同，但后者更易于阅读。
- en: Making Our Phonebook Prettier
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使我们的电话簿更美观
- en: 'When we were dealing with the `Data.Map` module, we first represented a phonebook
    with an association list (a list of key/value pairs) before converting it into
    a map. Here’s that version:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理`Data.Map`模块时，我们首先用一个关联列表（键/值对的列表）来表示电话簿，然后再将其转换为映射。以下是那个版本：
- en: '[PRE66]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The type of `phoneBook` is `[(String, String)]`. That tells us that it’s an
    association list that maps from strings to strings, but not much else. Let’s make
    a type synonym to convey some more information in the type declaration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`phoneBook`的类型是`[(String, String)]`。这告诉我们它是一个将字符串映射到字符串的关联列表，但除此之外没有其他信息。让我们创建一个类型别名来在类型声明中传达更多信息。'
- en: '[PRE67]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now the type declaration for our phonebook can be `phoneBook :: PhoneBook`.
    Let’s make a type synonym for `String` as well.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '现在电话簿的类型声明可以是`phoneBook :: PhoneBook`。让我们也为`String`创建一个类型别名。'
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Haskell programmers give type synonyms to the `String` type when they want to
    convey more information about the strings in their functions—what they actually
    represent.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell程序员在想要在函数中传达更多关于字符串信息时——即它们实际代表什么信息时，会给`String`类型赋予类型别名。
- en: So now, when we implement a function that takes a name and a number and checks
    if that name and number combination is in our phonebook, we can give it a very
    pretty and descriptive type declaration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，当我们实现一个接受一个名称和一个号码并检查该名称和号码组合是否在我们的电话簿中的函数时，我们可以给它一个非常漂亮且描述性的类型声明。
- en: '[PRE69]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we decided not to use type synonyms, our function would have this type:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定不使用类型别名，我们的函数将具有以下类型：
- en: '[PRE70]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this case, the type declaration that takes advantage of type synonyms is
    easier to understand. However, you shouldn’t go overboard with these synonyms.
    We introduce type synonyms either to describe what some existing type represents
    in our functions (and thus our type declarations become better documentation)
    or when something has a longish type that’s repeated a lot (like `[(String, String)]`)
    but represents something more specific in the context of our functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，利用类型别名的好处使得类型声明更容易理解。然而，你不应该过度使用这些别名。我们引入类型别名是为了描述某些现有类型在我们函数中的表示（因此我们的类型声明成为更好的文档）或者当某个类型很长且重复很多（如`[(String,
    String)]`）但在我们函数的上下文中表示更具体的内容时。
- en: Parameterizing Type Synonyms
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化类型别名
- en: 'Type synonyms can also be parameterized. If we want a type that represents
    an association list type, but still want it to be general so it can use any type
    as the keys and values, we can do this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类型同义词也可以是参数化的。如果我们想要一个表示关联列表类型的类型，但仍然希望它是通用的，以便可以使用任何类型作为键和值，我们可以这样做：
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now a function that gets the value by a key in an association list can have
    a type of `(Eq k) => k -> AssocList k v -> Maybe v`. `AssocList` is a type constructor
    that takes two types and produces a concrete type—for instance, `AssocList Int
    String`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个通过键在关联列表中获取值的函数，其类型可以是 `(Eq k) => k -> AssocList k v -> Maybe v`。`AssocList`
    是一个类型构造器，它接受两种类型并产生一个具体类型——例如，`AssocList Int String`。
- en: 'Just as we can partially apply functions to get new functions, we can partially
    apply type parameters and get new type constructors from them. When we call a
    function with too few parameters, we get back a new function. In the same way,
    we can specify a type constructor with too few type parameters and get back a
    partially applied type constructor. If we wanted a type that represents a map
    (from `Data.Map`) from integers to something, we could do this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以部分应用函数以获取新函数一样，我们也可以部分应用类型参数并从中获取新的类型构造器。当我们用太少的参数调用函数时，我们得到一个新的函数。同样，我们可以指定一个类型构造器，它具有太少的类型参数，并得到一个部分应用类型构造器。如果我们想要一个表示从整数到某种类型的映射（来自
    `Data.Map`）的类型，我们可以这样做：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or we could do it like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以这样做：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Either way, the `IntMap` type constructor takes one parameter, and that is the
    type of what the integers will point to.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，`IntMap` 类型构造器都接受一个参数，即整数所指向的类型。
- en: If you’re going to try to implement this, you probably will want to do a qualified
    import of `Data.Map`. When you do a qualified import, type constructors also need
    to be preceded with a module name.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算尝试实现这个，你可能想要做 `Data.Map` 的有条件导入。当你进行有条件导入时，类型构造器也需要在模块名称之前。
- en: '[PRE74]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Make sure that you really understand the distinction between type constructors
    and value constructors. Just because we made a type synonym called `IntMap` or
    `AssocList` doesn’t mean that we can do stuff like `AssocList [(1,2), (4,5),(7,9)]`.
    All it means is that we can refer to its type by using different names. We can
    do `[(1,2),(3,5),(8,9)] :: AssocList Int Int`, which will make the numbers inside
    assume a type of `Int`. However, we can still use that list in the same way that
    we would use any normal list that has pairs of integers.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你真正理解了类型构造器和值构造器之间的区别。仅仅因为我们创建了一个名为 `IntMap` 或 `AssocList` 的类型同义词，并不意味着我们可以做像
    `AssocList [(1,2), (4,5),(7,9)]` 这样的事情。它仅仅意味着我们可以使用不同的名称来引用其类型。我们可以做 `[(1,2),(3,5),(8,9)]
    :: AssocList Int Int`，这将使列表内部的数字假设为 `Int` 类型。然而，我们仍然可以用与任何正常整数对列表相同的方式使用该列表。'
- en: Type synonyms (and types generally) can be used only in the type portion of
    Haskell. Haskell’s type portion includes data and type declarations, as well as
    after a `::` in type declarations or type annotations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 类型同义词（以及类型一般）只能在 Haskell 的类型部分中使用。Haskell 的类型部分包括数据声明和类型声明，以及在类型声明或类型注解中的 `::`
    之后。
- en: Go Left, Then Right
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向左走，然后向右走
- en: 'Another cool data type that takes two types as its parameters is the `Either
    a b` type. This is roughly how it’s defined:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个酷炫的数据类型，它接受两个类型作为其参数，是 `Either a b` 类型。这大致是如何定义的：
- en: '[PRE75]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: It has two value constructors. If `Left` is used, then its contents are of type
    `a`; if `Right` is used, its contents are of type `b`. So we can use this type
    to encapsulate a value of one type or another. Then when we get a value of type
    `Either a b`, we usually pattern match on both `Left` and `Right`, and we do different
    stuff based on which one matches.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个值构造器。如果使用 `Left`，则其内容类型为 `a`；如果使用 `Right`，则其内容类型为 `b`。因此，我们可以使用此类型来封装一个或另一个类型的值。当我们得到类型为
    `Either a b` 的值时，我们通常会在 `Left` 和 `Right` 上进行模式匹配，并根据哪个匹配执行不同的操作。
- en: '[PRE76]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this code, when we examine the type of `Left True`, we see that the type
    is `Either Bool b`. The first type parameter is `Bool`, because we made our value
    with the `Left` value constructor, whereas the second type parameter remains polymorphic.
    This is similar to how a `Nothing` value has the type `Maybe a`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，当我们检查 `Left True` 的类型时，我们看到类型是 `Either Bool b`。第一个类型参数是 `Bool`，因为我们用 `Left`
    值构造器创建了我们的值，而第二个类型参数保持多态。这与 `Nothing` 值具有类型 `Maybe a` 的方式类似。
- en: So far, you’ve seen `Maybe a` mostly used to represent the results of computations
    that could have failed. But sometimes, `Maybe a` isn’t good enough, because `Nothing`
    doesn’t convey much information other than that something has failed. That’s fine
    for functions that can fail in only one way, or if we’re not interested in how
    or why they failed. For instance, a `Data.Map` lookup fails only if the key wasn’t
    in the map, so we know exactly what happened.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要看到`Maybe a`被用来表示可能失败的计算的结果。但有时，`Maybe a`还不够好，因为`Nothing`除了表明有失败之外，没有传达太多信息。对于只能以一种方式失败的功能，或者如果我们对它们如何或为什么失败不感兴趣，这是可以接受的。例如，`Data.Map`查找只有在键不在映射中时才会失败，所以我们确切地知道发生了什么。
- en: However, when we’re interested in how or why some function failed, we usually
    use the result type of `Either a b`, where `a` is a type that can tell us something
    about the possible failure, and `b` is the type of a successful computation. Hence,
    errors use the `Left` value constructor, and results use `Right`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们对某个函数如何或为什么失败感兴趣时，我们通常使用`Either a b`的结果类型，其中`a`是一个可以告诉我们有关可能失败的信息的类型，而`b`是成功计算的类型。因此，错误使用`Left`值构造函数，结果使用`Right`。
- en: As an example, suppose that a high school has lockers so that students have
    some place to put their Guns N’ Roses posters. Each locker has a code combination.
    When students need to be assigned a locker, they tell the locker supervisor which
    locker number they want, and he gives them the code. However, if someone is already
    using that locker, the student needs to pick a different one. We’ll use a map
    from `Data.Map` to represent the lockers. It will map from locker numbers to a
    pair that indicates whether the locker is in use and the locker code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一所高中有储物柜，以便学生有地方存放他们的Guns N’ Roses海报。每个储物柜都有一个密码组合。当学生需要分配一个储物柜时，他们会告诉储物柜管理员他们想要的储物柜号码，然后管理员会给他们密码。然而，如果有人已经在使用那个储物柜，学生就需要选择一个不同的储物柜。我们将使用`Data.Map`中的映射来表示储物柜。它将把储物柜号码映射到一个表示储物柜是否在使用以及储物柜密码的元组。
- en: '[PRE77]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We introduce a new data type to represent whether a locker is taken or free,
    and we make a type synonym for the locker code. We also make a type synonym for
    the type that maps from integers to pairs of locker state and code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入一个新的数据类型来表示储物柜是被占用还是空闲的，并为储物柜密码创建了一个类型同义词。我们还为从整数到储物柜状态和密码的映射类型创建了一个类型同义词。
- en: 'Next, we’ll make a function that searches for the code in a locker map. We’ll
    use an `Either String Code` type to represent our result, because our lookup can
    fail in two ways: The locker can be taken, in which case we can’t tell the code,
    or the locker number might not exist. If the lookup fails, we’re just going to
    use a `String` to indicate what happened.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个在储物柜映射中搜索密码的函数。我们将使用`Either String Code`类型来表示我们的结果，因为我们的查找可能以两种方式失败：储物柜可能已被占用，在这种情况下我们无法得知密码，或者储物柜号码可能不存在。如果查找失败，我们只需使用一个`String`来指示发生了什么。
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We do a normal lookup in the map. If we get a `Nothing`, we return a value of
    type `Left String`, saying that the locker doesn’t exist. If we do find it, then
    we do an additional check to see if the locker is in use. If it is, we return
    a `Left` saying that it’s already taken. If it isn’t, we return a value of type
    `Right Code`, in which we give the student the correct code for the locker. It’s
    actually a `Right String` (which is a `Right [Char])`, but we added that type
    synonym to introduce some additional documentation into the type declaration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在映射中进行正常的查找。如果我们得到`Nothing`，我们返回一个类型为`Left String`的值，表示储物柜不存在。如果我们找到了它，然后我们进行额外的检查以查看储物柜是否在使用中。如果是，我们返回一个`Left`，表示它已经被占用。如果不是，我们返回一个类型为`Right
    Code`的值，在其中我们给学生提供正确的储物柜密码。实际上是一个`Right String`（它是一个`Right [Char]`），但我们添加了这个类型同义词来在类型声明中引入一些额外的文档。
- en: 'Here’s an example map:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例映射：
- en: '[PRE79]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now let’s try looking up some locker codes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试查找一些储物柜密码。
- en: '[PRE80]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We could have used a `Maybe a` to represent the result, but then we wouldn’t
    know why we couldn’t get the code. But now we have information about the failure
    in our result type.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用`Maybe a`来表示结果，但那样我们就不知道为什么无法获取密码。但现在我们的结果类型中包含了关于失败的信息。
- en: Recursive Data Structures
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归数据结构
- en: As you’ve seen, a constructor in an algebraic data type can have several fields
    (or none at all), and each field must be of some concrete type. So we can make
    types that have themselves as types in their fields! And that means we can create
    recursive data types, where one value of some type contains values of that type,
    which in turn contain more values of the same type, and so on.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，代数数据类型中的构造函数可以有多个字段（或者根本没有任何字段），并且每个字段都必须是某种具体类型。因此，我们可以在字段的类型中创建自身作为类型的类型！这意味着我们可以创建递归数据类型，其中某个类型的某个值包含该类型的值，而这些值又包含更多相同类型的值，以此类推。
- en: 'Think about this list: `[5]`. That’s just syntactic sugar for `5:[]`. On the
    left side of the `:`, there’s a value; on the right side, there’s a list. In this
    case, it’s an empty list. Now how about the list `[4,5]`? Well, that desugars
    to `4:(5:[])`. Looking at the first `:`, we see that it also has an element on
    its left side and a list, `(5:[])`, on its right side. The same goes for a list
    like `3:(4:(5:6:[]))`, which could be written either like that or like `3:4:5:6:[]`
    (because `:` is right-associative) or `[3,4,5,6]`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个列表：`[5]`。这仅仅是`5:[]`的语法糖。在`:`的左边有一个值；在右边有一个列表。在这种情况下，它是一个空列表。那么，关于列表`[4,5]`呢？嗯，它解糖后变成`4:(5:[])`。看看第一个`:`，我们可以看到它左边也有一个元素，右边是一个列表`(5:[])`。同样的规则也适用于像`3:(4:(5:6:[]))`这样的列表，它可以写成这样，也可以写成`3:4:5:6:[]`（因为`:`是右结合的）或者`[3,4,5,6]`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802602.png.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802602.png.jpg)'
- en: A list can be an empty list, or it can be an element joined together with a
    `:` with another list (that might be an empty list).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以是一个空列表，或者它可以通过`:`与另一个列表（可能是一个空列表）连接在一起。
- en: Let’s use algebraic data types to implement our own list!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用代数数据类型来实现我们自己的列表！
- en: '[PRE81]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This follows our definition of lists. It’s either an empty list or a combination
    of a head with some value and a list. If you’re confused about this, you might
    find it easier to understand in record syntax.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合我们列表的定义。它要么是一个空列表，要么是一个头部和一些值的组合，以及一个列表。如果你对此感到困惑，你可能发现用记录语法理解它更容易。
- en: '[PRE82]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You might also be confused about the `Cons` constructor here. Informally speaking,
    `Cons` is another word for `:`. In lists, `:` is actually a constructor that takes
    a value and another list and returns a list. In other words, it has two fields:
    One field is of the type of `a`, and the other is of the type `List a`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也对这里的`Cons`构造函数感到困惑。非正式地说，`Cons`是`:`的另一个名字。在列表中，`:`实际上是一个构造函数，它接受一个值和另一个列表，并返回一个列表。换句话说，它有两个字段：一个字段是`a`的类型，另一个字段是`List
    a`的类型。
- en: '[PRE83]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We called our `Cons` constructor in an infix manner so you can see how it’s
    just like `:`. `Empty` is like `[]`, and ``4 `Cons` (5 `Cons` Empty)`` is like
    `4:(5:[])`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以中缀方式调用了我们的`Cons`构造函数，这样你可以看到它就像`:`一样。`Empty`就像`[]`，而`4 `Cons` (5 `Cons` Empty)`就像`4:(5:[])`。
- en: Improving Our List
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进我们的列表
- en: 'We can define functions to be automatically infix by naming them using only
    special characters. We can also do the same with constructors, since they’re just
    functions that return a data type. There is one restriction however: Infix constructors
    must begin with a colon. So check this out:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义使用仅使用特殊字符命名的函数，使其自动成为中缀函数。我们也可以用构造函数做同样的事情，因为它们只是返回数据类型的函数。然而，有一个限制：中缀构造函数必须以冒号开头。所以看看这个：
- en: '[PRE84]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'First, notice a new syntactic construct: the fixity declaration, which is the
    line above our data declaration. When we define functions as operators, we can
    use that to give them a *fixity* (but we don’t have to). A fixity states how tightly
    the operator binds and whether it’s left-associative or right-associative. For
    instance, the `*` operator’s fixity is `infixl 7 *`, and the `+` operator’s fixity
    is `infixl 6`. That means that they’re both left-associative (in other words,
    `4 * 3 * 2` is the same as `(4 * 3) * 2`), but `*` binds tighter than `+`, because
    it has a greater fixity. So `5 * 4 + 3` is equivalent to `(5 * 4) + 3`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意一个新的语法结构：固定性声明，它位于我们的数据声明上方。当我们定义函数作为操作符时，我们可以使用它来给它们一个*固定性*（但我们不必这样做）。固定性说明了操作符的绑定紧密程度以及它是左结合还是右结合。例如，`*`操作符的固定性是`infixl
    7 *`，而`+`操作符的固定性是`infixl 6`。这意味着它们都是左结合的（换句话说，`4 * 3 * 2`与`(4 * 3) * 2`相同），但`*`的绑定比`+`更紧密，因为它的固定性更高。所以`5
    * 4 + 3`等价于`(5 * 4) + 3`。
- en: 'Otherwise, we just wrote `a :-: (List a)` instead of `Cons a (List a)`. Now,
    we can write out lists in our list type like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '否则，我们只是写了`a :-: (List a)`而不是`Cons a (List a)`。现在，我们可以在我们的列表类型中这样写出列表：'
- en: '[PRE85]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let’s make a function that adds two of our lists together. This is how `++`
    is defined for normal lists:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，将两个我们的列表相加。这就是 `++` 在普通列表中的定义方式：
- en: '[PRE86]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We’ll just steal that for our own list. We’ll name the function `^++`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接将其纳入我们的列表。我们将该函数命名为 `^++`。
- en: '[PRE87]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now let’s see try it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来试试看：
- en: '[PRE88]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If we wanted, we could implement all of the functions that operate on lists
    on our own list type.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以为我们自己的列表类型实现所有操作列表的函数。
- en: 'Notice how we pattern matched on `(x :-: xs)`. That works because pattern matching
    is actually about matching constructors. We can match on `:-:` because it is a
    constructor for our own list type, and we can also match on `:` because it is
    a constructor for the built-in list type. The same goes for `[]`. Because pattern
    matching works (only) on constructors, we can match for normal prefix constructors
    or stuff like `8` or `''a''`, which are basically constructors for the numeric
    and character types, respectively.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '注意我们是如何在 `(x :-: xs)` 上进行模式匹配的。这之所以有效，是因为模式匹配实际上是关于匹配构造函数的。我们可以匹配 `:-:`，因为它是我们自己的列表类型的构造函数，我们也可以匹配
    `:`，因为它是我们内置列表类型的构造函数。同样适用于 `[]`。因为模式匹配（只）在构造函数上工作，我们可以匹配正常的前缀构造函数或类似 `8` 或 `''a''`
    的东西，它们基本上是数值和字符类型的构造函数。'
- en: Let's Plant a Tree
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们种一棵树
- en: To get a better feel for recursive data structures in Haskell, we’re going to
    implement a binary search tree.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解 Haskell 中的递归数据结构，我们将实现一个二叉搜索树。
- en: In a binary search tree, an element points to two elements—one on its left and
    one on its right. The element to the left is smaller; the element to the right
    is bigger. Each of those elements can also point to two elements (or one or none).
    In effect, each element has up to two subtrees.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树中，一个元素指向两个元素——一个在其左侧，一个在其右侧。左侧的元素较小；右侧的元素较大。这些元素中的每一个也可以指向两个元素（或一个或没有）。实际上，每个元素最多有两个子树。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802604.png.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802604.png.jpg)'
- en: A cool thing about binary search trees is that we know that all the elements
    at the left subtree of, say, 5, will be smaller than 5\. Elements in the right
    subtree will be bigger. So if we need to find if 8 is in our tree, we start at
    5, and then because 8 is greater than 5, we go right. We’re now at 7, and because
    8 is greater than 7, we go right again. And we’ve found our element in three hops!
    If this were a normal list (or a tree, but really unbalanced), it would take us
    seven hops to see if 8 is in there.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树的一个有趣之处在于，我们知道，例如，5 的左子树中的所有元素都将小于 5。右子树中的元素将更大。所以如果我们需要查找 8 是否在我们的树中，我们从
    5 开始，然后因为 8 大于 5，我们向右走。我们现在在 7，因为 8 大于 7，我们再次向右走。我们已经在三步之内找到了我们的元素！如果这是一个普通的列表（或者一棵树，但实际是不平衡的），我们需要走七步才能看到
    8 是否在其中。
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sets and maps from `Data.Set` and `Data.Map` are implemented using trees, but
    instead of normal binary search trees, they use *balanced* binary search trees.
    A tree is balanced if its left and right subtrees are of approximately the same
    height. This makes searching through the tree faster. But for our examples, we’ll
    just be implementing normal binary search trees.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Set` 和 `Data.Map` 中的集合和映射是通过树实现的，但它们使用的是 *平衡* 二叉搜索树，而不是普通的二叉搜索树。一棵树是平衡的，如果它的左右子树的高度大致相同。这使得通过树进行搜索更快。但在我们的例子中，我们只实现普通的二叉搜索树。'
- en: 'Here’s what we’re going to say: A tree is either an empty tree or it’s an element
    that contains some value and two trees. Sounds like a perfect fit for an algebraic
    data type!'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们要说的是：一棵树要么是一个空树，要么是一个包含一些值和两个树的元素。这似乎非常适合代数数据类型！
- en: '[PRE89]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Instead of manually building a tree, we’ll make a function that takes a tree
    and an element and inserts an element. We do this by comparing the new value to
    the tree’s root node. If it’s smaller than the root, we go left; if it’s larger,
    we go right. We then do the same for every subsequent node until we reach an empty
    tree. Once we’ve reached an empty tree, we insert a node with our new value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是手动构建一棵树，而是创建一个函数，它接受一棵树和一个元素，并将元素插入其中。我们通过比较新值与树的根节点来完成此操作。如果它小于根，我们向左走；如果它大于根，我们向右走。然后我们对每个后续节点做同样的操作，直到我们到达一个空树。一旦我们到达一个空树，我们就插入一个带有我们新值的节点。
- en: In languages like C, we would do this by modifying the pointers and values inside
    the tree. In Haskell, we can’t modify our tree directly, so we need to make a
    new subtree each time we decide to go left or right. In the end, the insertion
    function returns a completely new tree, because Haskell doesn’t have a concept
    of pointers, just values. Hence, the type for our insertion function will be something
    like `a -> Tree a - > Tree a`. It takes an element and a tree and returns a new
    tree that has that element inside. This might seem like it’s inefficient, but
    Haskell makes it possible to share most of the subtrees between the old tree and
    the new tree.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C 这样的语言中，我们会通过修改树内部的指针和值来完成这个操作。在 Haskell 中，我们不能直接修改我们的树，所以每次我们决定向左或向右移动时，都需要创建一个新的子树。最终，插入函数会返回一个全新的树，因为
    Haskell 没有指针的概念，只有值。因此，我们的插入函数的类型将类似于 `a -> Tree a -> Tree a`。它接受一个元素和一个树，并返回一个包含该元素的新树。这看起来可能不太高效，但
    Haskell 使得在旧树和新树之间共享大多数子树成为可能。
- en: 'Here are two functions for building the tree:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个用于构建树的函数：
- en: '[PRE90]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`singleton` is a utility function for making a singleton tree (a tree with
    just one node). It’s just a shortcut for creating a node that has something set
    as its root, and two empty subtrees.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleton` 是一个用于创建单节点树的实用函数（一个只有一个节点的树）。它只是一个创建一个将其根设置为某个值，并且有两个空子树的节点的快捷方式。'
- en: The `treeInsert` function is to insert an element into a tree. Here, we first
    have the base case as a pattern. If we’ve reached an empty subtree, that means
    we’re where we want to go, and we insert a singleton tree with our element. If
    we’re not inserting into an empty tree, then we need to do some checking. First,
    if the element we’re inserting is equal to the root element, we just return a
    tree that’s the same. If it’s smaller, we return a tree that has the same root
    value and the same right subtree, but instead of its left subtree, we put a tree
    that has our value inserted into it. We do the same if our value is bigger than
    the root element, but the other way around.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`treeInsert` 函数用于将一个元素插入到树中。在这里，我们首先有一个模式作为基本情况。如果我们到达了一个空子树，这意味着我们到达了想要去的地方，我们插入一个包含我们的元素的单一节点树。如果我们不是在空树中插入，那么我们需要做一些检查。首先，如果我们正在插入的元素等于根元素，我们只返回一个相同的树。如果它更小，我们返回一个具有相同根值和相同右子树的树，但用我们的值插入的树替换其左子树。如果我们值大于根元素，我们以相反的方式做同样的操作。'
- en: 'Next up, we’re going to make a function that checks if some element is in the
    tree:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来检查某个元素是否在树中：
- en: '[PRE91]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: First, we define the base case. If we’re looking for an element in an empty
    tree, then it’s certainly not there. Notice how this is the same as the base case
    when searching for elements in lists. If we’re not looking for an element in an
    empty tree, then we check some things. If the element in the root node is what
    we’re looking for, great! If it’s not, what then? Well, we can take advantage
    of knowing that all the left elements are smaller than the root node. If the element
    we’re looking for is smaller than the root node, we check to see if it’s in the
    left subtree. If it’s bigger, we check to see if it’s in the right subtree.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义基本的情况。如果我们在一个空树中寻找一个元素，那么它肯定不在那里。注意这与在列表中搜索元素时的基本情况是相同的。如果我们不在空树中寻找元素，那么我们需要检查一些事情。如果根节点中的元素是我们正在寻找的，那就太好了！如果不是，那会怎样？嗯，我们可以利用知道所有左边的元素都比根节点小的知识。如果我们正在寻找的元素小于根节点，我们检查它是否在左子树中。如果它更大，我们检查它是否在右子树中。
- en: Now let’s have some fun with our trees! Instead of manually creating one (although
    we could), we’ll use a fold to build a tree from a list. Remember that pretty
    much everything that traverses a list one item at a time and returns a value can
    be implemented with a fold! We’re going to start with the empty tree and then
    approach a list from the right and insert element after element into our accumulator
    tree.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用我们的树来玩点有趣的东西！我们不会手动创建一个（尽管我们可以），我们将使用折叠从列表中构建一个树。记住，几乎可以使用折叠来实现遍历列表一次并返回值的任何操作！我们将从一个空树开始，然后从右向左遍历列表，并将元素逐个插入到我们的累加树中。
- en: '[PRE92]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you run this in GHCi, the result from `numsTree` will be printed in one long
    line. Here, it’s broken up into many lines; otherwise, it would run off the page!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个 GHCi 中运行它，`numsTree` 的结果将会打印成一行长字符串。在这里，它被拆分成多行；否则，它就会超出页面！
- en: In this `foldr`, `treeInsert` is the folding binary function (it takes a tree
    and a list element and produces a new tree), and `EmptyTree` is the starting accumulator.
    `nums`, of course, is the list we’re folding over.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `foldr` 中，`treeInsert` 是折叠二进制函数（它接受一个树和一个列表元素，并产生一个新的树），而 `EmptyTree` 是起始累加器。`nums`
    当然是我们正在折叠的列表。
- en: 'When we print our tree to the console, it’s not very readable, but we can still
    make out its structure. We see that the root node is `5` and that it has two subtrees:
    one with a root node of `3` and the other with a root node of `7`.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将树打印到控制台时，它不是很易读，但我们仍然可以辨认出它的结构。我们看到根节点是 `5`，并且它有两个子树：一个根节点为 `3`，另一个根节点为
    `7`。
- en: 'We can also check if certain values are contained in the tree, like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查某些值是否包含在树中，如下所示：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: As you can see, algebraic data structures are a really cool and powerful concept
    in Haskell. We can use them to make anything from Boolean values and weekday enumerations
    to binary search trees, and more!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代数数据结构在 Haskell 中是一个非常酷且强大的概念。我们可以使用它们来创建从布尔值和星期几枚举到二叉搜索树等任何东西！
- en: Type Classes 102
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类 102
- en: So far, you’ve learned about some of the standard Haskell type classes and seen
    which types they contain. You’ve also learned how to automatically make your own
    type instances of the standard type classes by asking Haskell to derive the instances.
    This section explains how to make your own type classes and how to make type instances
    of them by hand.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了一些标准的 Haskell 类型类，并看到了它们包含哪些类型。你还学习了如何通过请求 Haskell 推导实例来自动创建自己的标准类型类的类型实例。本节解释了如何创建自己的类型类以及如何手动创建它们的类型实例。
- en: 'A quick type class recap: Type classes are sort of like interfaces. A type
    class defines some behavior (such as comparing for equality, comparing for ordering,
    and enumeration). Types that can behave in that way are made instances of that
    type class. The behavior of type classes is achieved by defining functions or
    just type declarations that we then implement. So when we say that a type is an
    instance of a type class, we mean that we can use the functions that the type
    class defines with that type.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 快速类型类回顾：类型类有点像接口。类型类定义了一些行为（例如比较相等、比较排序和枚举）。可以以这种方式表现的类型是该类型类的实例。类型类的行为是通过定义函数或只是类型声明来实现的，然后我们实现它们。所以当我们说一个类型是类型类的实例时，我们的意思是我们可以使用类型类定义的函数与该类型一起使用。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802606.png.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802606.png.jpg)'
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that type classes have nothing to do with classes in languages like
    Java or Python. This confuses many people, so I want you to forget everything
    you know about classes in imperative languages right now!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，类型类与 Java 或 Python 等语言中的类没有任何关系。这会让很多人感到困惑，所以我想你现在忘记所有关于命令式语言中类的知识！
- en: Inside the Eq Type Class
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eq 类型类内部
- en: As an example, let’s look at the `Eq` type class. Remember that `Eq` is for
    values that can be equated. It defines the functions `==` and `/=`. If we have
    the type `Car` and comparing two cars with the equality function `==` makes sense,
    then it makes sense for `Car` to be an instance of `Eq`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 `Eq` 类型类。记住，`Eq` 是用于可以相等比较的值。它定义了函数 `==` 和 `/=`。如果我们有 `Car` 类型，并且使用相等函数
    `==` 比较两个汽车是有意义的，那么 `Car` 成为 `Eq` 的实例也是有意义的。
- en: 'This is how the `Eq` class is defined in the standard library:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准库中定义 `Eq` 类的示例：
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Whoa! Some strange syntax and keywords here!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这里有一些奇怪的语法和关键字！
- en: '`class Eq a where` means a new type class called `Eq` is being defined. The
    `a` is the type variable, so `a` will play the role of the type that will soon
    be made an instance of `Eq`. (It doesn’t need to be called `a`, and it doesn’t
    even need to be one letter—it just must be in all lowercase.)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Eq a where` 表示正在定义一个新的类型类 `Eq`。`a` 是类型变量，因此 `a` 将扮演即将成为 `Eq` 实例的类型角色。（它不需要被称为
    `a`，甚至不需要是一个字母——它只需要全部小写即可。）'
- en: Next, several functions are defined. Note that it’s not mandatory to implement
    the function bodies themselves; just their type declarations are required. Here,
    the function bodies for the functions that `Eq` defines are implemented—defined
    in terms of mutual recursion. It says that two values whose types are instances
    of `Eq` are equal if they are not different, and they are different if they are
    not equal. You’ll see how this helps us soon.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义了几个函数。请注意，实现函数体本身不是强制性的；只需要它们的类型声明。在这里，实现了`Eq`定义的函数的函数体——通过相互递归定义。它表示，如果两个值的类型是`Eq`的实例，并且它们不相等，则它们相等；如果它们不相等，则它们不同。你很快就会看到这如何帮助我们。
- en: 'The final type of the functions that we define in a type class is also worth
    noting. If we have, say, `class Eq a where`, and then define a type declaration
    within that class like `(==) :: a -> a -> Bool`, when we examine the type of that
    function later, it will have the type of `(Eq a) => a -> a -> Bool`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '在类型类中定义的函数的最终类型也值得注意。如果我们有，比如说，`class Eq a where`，然后在那个类中定义一个类型声明，比如`(==) ::
    a -> a -> Bool`，当我们稍后检查那个函数的类型时，它将具有`(Eq a) => a -> a -> Bool`的类型。'
- en: A Traffic Light Data Type
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交通灯数据类型
- en: 'So once we have a class, what can we do with it? We can make type instances
    of that class and get some nice functionality. Check out this type, for instance:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们有一个类，我们能用它做什么呢？我们可以创建该类的类型实例，并获得一些很好的功能。以这个类型为例：
- en: '[PRE95]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'It defines the states of a traffic light. Notice how we didn’t derive any class
    instances for it. That’s because we’re going to write some instances by hand.
    Here’s how we make it an instance of `Eq`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 它定义了交通灯的状态。注意我们并没有为它推导任何类实例。那是因为我们打算手动编写一些实例。下面是如何将其制作成`Eq`的实例：
- en: '[PRE96]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We did it by using the `instance` keyword. So `class` is for defining new type
    classes, and `instance` is for making our types instances of type classes. When
    we were defining `Eq`, we wrote `class Eq a where`, and we said that `a` plays
    the role of whichever type will be made an instance later. We can see that clearly
    here, because when we’re making an instance, we write `instance Eq TrafficLight
    where`. We replace the `a` with the actual type.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是通过使用`instance`关键字做到这一点的。所以`class`是用来定义新的类型类，而`instance`是用来使我们的类型成为类型类的实例。当我们定义`Eq`时，我们写了`class
    Eq a where`，并且我们说`a`扮演着后来将被制作成实例的任何类型的角色。我们可以清楚地看到这一点，因为当我们制作实例时，我们写`instance
    Eq TrafficLight where`。我们将`a`替换为实际类型。
- en: 'Because `==` was defined in terms of `/=` and vice versa in the class declaration,
    we needed to overwrite only one of them in the instance declaration. That’s called
    the *minimal complete definition* for the type class—the minimum of functions
    that we must implement so that our type can behave as the class advertises. To
    fulfill the minimal complete definition for `Eq`, we need to overwrite either
    `==` or `/=`. If `Eq` were defined simply like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在类声明中`==`是通过`/=`定义的，反之亦然，因此我们只需要在实例声明中重写其中一个。这被称为类型类的*最小完整定义*——我们必须实现的函数的最小集合，以便我们的类型可以按照类所宣传的方式行为。为了满足`Eq`的最小完整定义，我们需要重写`==`或`/=`之一。如果`Eq`简单地定义如下：
- en: '[PRE97]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: we would need to implement both of these functions when making a type an instance
    of `Eq`, because Haskell wouldn’t know how these two functions are related. The
    minimal complete definition would then be both `==` and `/=`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在将类型制作成`Eq`的实例时，我们需要实现这两个函数，因为Haskell不知道这两个函数是如何相关的。那么，最小完整定义将是`==`和`/=`。
- en: You can see that we implemented `==` simply by doing pattern matching. Since
    there are many more cases where two lights aren’t equal, we specified the ones
    that *are* equal, and then just did a catchall pattern saying that if it’s none
    of the previous combinations, then two lights aren’t equal.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们通过模式匹配简单地实现了`==`。由于有许多更多的情况是两个灯不相等，我们指定了那些相等的，然后只是做了一个通配符模式，说如果它不是前面的任何组合，那么两个灯不相等。
- en: 'Let’s make this an instance of `Show` by hand, too. To satisfy the minimal
    complete definition for `Show`, we just need to implement its `show` function,
    which takes a value and turns it into a string:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动将这个实例化为`Show`。为了满足`Show`的最小完整定义，我们只需要实现它的`show`函数，该函数接收一个值并将其转换为字符串：
- en: '[PRE98]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Once again, we used pattern matching to achieve our goals. Let’s see how it
    works in action:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用了模式匹配来实现我们的目标。让我们看看它是如何实际工作的：
- en: '[PRE99]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We could have just derived `Eq`, and it would have had the same effect (but
    we didn’t for educational purposes). However, deriving `Show` would have just
    directly translated the value constructors to strings. If we want our lights to
    appear as `Red light`, we need to make the instance declaration by hand.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以直接推导 `Eq`，它会产生相同的效果（但我们没有这样做是为了教育目的）。然而，推导 `Show` 会直接将值构造函数转换为字符串。如果我们想让灯光显示为
    `Red light`，我们需要手动进行实例声明。
- en: Subclassing
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子类化
- en: 'You can also make type classes that are subclasses of other type classes. The
    class declaration for `Num` is a bit long, but here’s the first part:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建其他类型类的子类类型类。`Num` 类的声明有点长，但这里是第一部分：
- en: '[PRE100]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: As mentioned previously, there are a lot of places where we can cram in class
    constraints. So this is just like writing `class Num a where`, but we state that
    our type `a` must be an instance of `Eq`. We’re essentially saying that we need
    to make a type an instance of `Eq` before we can make it an instance of `Num`.
    Before some type can be considered a number, it makes sense that we can determine
    whether values of that type can be equated.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有很多地方可以塞入类约束。所以这就像写 `class Num a where` 一样，但我们声明我们的类型 `a` 必须是 `Eq` 的一个实例。我们实际上是在说，在我们将其作为
    `Num` 的实例之前，我们需要将类型作为 `Eq` 的实例。在某个类型被视为数字之前，能够确定该类型的值是否可以相等是有意义的。
- en: That’s all there is to subclassing—it’s just a class constraint on a class declaration!
    When defining function bodies in the class declaration or in instance declarations,
    we can assume that `a` is a part of `Eq`, so we can use `==` on values of that
    type.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化的内容就这么多——它只是对类声明的类约束！在类声明或实例声明中定义函数体时，我们可以假设 `a` 是 `Eq` 的一部分，因此我们可以使用 `==`
    操作符来比较该类型的值。
- en: Parameterized Types As Instances of Type Classes
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化类型作为类型类的实例
- en: 'But how are the `Maybe` or list types made as instances of type classes? What
    makes `Maybe` different from, say, `TrafficLight` is that `Maybe` in itself isn’t
    a concrete type—it’s a type constructor that takes one type parameter (like `Char`)
    to produce a concrete type (like `Maybe Char`). Let’s take a look at the `Eq`
    type class again:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `Maybe` 或列表类型是如何成为类型类实例的呢？`Maybe` 与例如 `TrafficLight` 的不同之处在于，`Maybe` 本身不是一个具体类型——它是一个接受一个类型参数（如
    `Char`）以产生一个具体类型（如 `Maybe Char`）的类型构造器。让我们再次看看 `Eq` 类型类：
- en: '[PRE101]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'From the type declarations, we see that `a` is used as a concrete type because
    all the types in functions must be concrete. Remember that you can’t have a function
    of the type `a -> Maybe`, but you *can* have a function of the type `a -> Maybe
    a` or `Maybe Int -> Maybe String`. That’s why we can’t do something like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型声明中，我们看到 `a` 被用作一个具体类型，因为函数中的所有类型都必须是具体的。记住，你不能有一个类型为 `a -> Maybe` 的函数，但你
    *可以* 有一个类型为 `a -> Maybe a` 或 `Maybe Int -> Maybe String` 的函数。这就是为什么我们不能这样做：
- en: '[PRE102]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `a` must be a concrete type, and `Maybe` is not; it’s a type constructor
    that takes one parameter and then *produces* a concrete type.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 必须是一个具体类型，而 `Maybe` 不是；它是一个接受一个参数并然后 *产生* 一个具体类型的类型构造器。'
- en: 'It would also be tedious if we needed to make a separate instance for every
    possible type that `Maybe`’s type parameter could take on. If we needed to write
    `instance Eq (Maybe Int) where`, `instance Eq (Maybe Char) where`, and so on for
    every type, we would get nowhere. That’s why we can just leave the parameter as
    a type variable, like so:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为 `Maybe` 的类型参数可能采取的每个可能的类型都创建一个单独的实例，那将会很繁琐。如果我们需要编写 `instance Eq (Maybe
    Int) where`、`instance Eq (Maybe Char) where` 以及为每个类型进行类似的操作，我们将一事无成。这就是为什么我们可以将参数留为一个类型变量，如下所示：
- en: '[PRE103]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is like saying that we want to make all types of the form `Maybe something`
    an instance of `Eq`. We actually could have written `(Maybe something)`, but using
    single letters conforms to the Haskell style.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像说，我们希望将所有形式为 `Maybe something` 的类型都成为 `Eq` 的实例。我们实际上可以写成 `(Maybe something)`，但使用单个字母符合
    Haskell 风格。
- en: The `(Maybe m)` here plays the role of the `a` from `class Eq a where`. While
    `Maybe` isn’t a concrete type, `Maybe m` is. By specifying a type parameter as
    a type variable (`m`, which is in lowercase), we said that we want all types that
    are in the form of `Maybe m`, where `m` is any type, to be an instance of `Eq`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `(Maybe m)` 的作用类似于 `class Eq a where` 中的 `a`。虽然 `Maybe` 不是一个具体类型，但 `Maybe
    m` 是。通过指定一个类型参数作为类型变量（`m`，它以小写形式出现），我们表示我们希望所有形式为 `Maybe m` 的类型，其中 `m` 是任何类型，都是
    `Eq` 的一个实例。
- en: 'There’s one problem with this though. Can you spot it? We use `==` on the contents
    of the `Maybe`, but we have no assurance that what the `Maybe` contains can be
    used with `Eq`! That’s why we modify our instance declaration like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个问题。你能发现吗？我们在 `Maybe` 的内容上使用了 `==`，但我们没有保证 `Maybe` 包含的内容可以用 `Eq` 使用！这就是我们修改实例声明的原因：
- en: '[PRE104]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We needed to add a class constraint! With this instance declaration, we say
    that we want all types of the form `Maybe m` to be part of the `Eq` type class,
    but only those types where the `m` (what’s contained inside the `Maybe`) is also
    a part of `Eq`. This is actually how Haskell would derive the instance.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个类约束！通过这个实例声明，我们表示我们希望所有形式为 `Maybe m` 的类型都属于 `Eq` 类型类，但只有那些 `m`（`Maybe`
    内部包含的内容）也是 `Eq` 类型一部分的类型。这正是 Haskell 会推导出实例的方式。
- en: Most of the time, class constraints in class declarations are used for making
    a type class a subclass of another type class, and class constraints in instance
    declarations are used to express requirements about the contents of some type.
    For instance, here we required the contents of the `Maybe` to also be part of
    the `Eq` type class.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，类声明中的类约束用于将一个类型类作为另一个类型类的子类，而实例声明中的类约束用于表达对某些类型内容的约束。例如，在这里我们要求 `Maybe`
    的内容也属于 `Eq` 类型类。
- en: When making instances, if you see that a type is used as a concrete type in
    the type declarations (like the `a` in `a -> a -> Bool`), you need to supply type
    parameters and add parentheses so that you end up with a concrete type.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例时，如果你看到类型在类型声明中用作具体类型（如 `a -> a -> Bool` 中的 `a`），你需要提供类型参数并添加括号，以便最终得到一个具体类型。
- en: 'Take into account that the type you’re trying to make an instance of will replace
    the parameter in the class declaration. The `a` from `class Eq a where` will be
    replaced with a real type when you make an instance, so try to mentally put your
    type into the function type declarations as well. The following type declaration
    really doesn’t make much sense:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你试图使其成为实例的类型将替换类声明中的参数。当你创建实例时，`class Eq a where` 中的 `a` 将被替换为一个实际类型，所以试着在函数类型声明中也将你的类型放入心中。以下类型声明实际上并没有太多意义：
- en: '[PRE105]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'But this does:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会这样做：
- en: '[PRE106]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This is just something to think about, because `==` will always have a type
    of `(==) :: (Eq a) => a -> a -> Bool`, no matter what instances we make.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是想让你思考一下，因为 `==` 总是具有 `(==) :: (Eq a) => a -> a -> Bool` 的类型，无论我们创建什么实例。'
- en: 'Oh, and one more thing: If you want to see what the instances of a type class
    are, just type `:info YourTypeClass` in GHCi. For instance, typing `:info Num`
    will show which functions the type class defines, and it will give you a list
    of the types in the type class. `:info` works for types and type constructors,
    too. If you do `:info Maybe`, it will show you all the type classes that `Maybe`
    is an instance of. Here’s an example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，还有一件事：如果你想查看一个类型类的实例，只需在 GHCi 中输入 `:info YourTypeClass`。例如，输入 `:info Num`
    将会显示类型类定义了哪些函数，并且会给你一个类型类中类型的列表。`:info` 对类型和类型构造器也有效。如果你输入 `:info Maybe`，它将显示
    `Maybe` 是哪些类型类的实例。以下是一个例子：
- en: '[PRE107]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: A Yes-No Type Class
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个是/否类型类
- en: 'In JavaScript and some other weakly typed languages, you can put almost anything
    inside an `if` expression. For example, in JavaScript, you can do something like
    this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 和一些其他弱类型语言中，你可以在 `if` 表达式中放置几乎任何东西。例如，在 JavaScript 中，你可以这样做：
- en: '[PRE108]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Or like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样：
- en: '[PRE109]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Or like this:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样：
- en: '[PRE110]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: All of these will throw an alert of `NO!`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都会抛出一个 `NO!` 的警报。
- en: 'However, the following code will give an alert of `YEAH!`, since JavaScript
    considers any nonempty string to be a true value:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下代码将给出一个 `YEAH!` 的警报，因为 JavaScript 将任何非空字符串视为真值：
- en: '[PRE111]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Even though strictly using `Bool` for Boolean semantics works better in Haskell,
    let’s try to implement this JavaScript-like behavior, just for fun! We’ll start
    out with a class declaration:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Haskell 中严格使用 `Bool` 进行布尔语义处理效果更好，但让我们为了好玩尝试实现这种类似 JavaScript 的行为！我们将从一个类声明开始：
- en: '[PRE112]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This is pretty simple. The `YesNo` type class defines one function. That function
    takes one value of a type that can be considered to hold some concept of trueness
    and tells us for sure if it’s true or not. Notice that from the way we use `a`
    in the function that `a` must be a concrete type.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。`YesNo` 类型类定义了一个函数。这个函数接受一个可以被认为是包含某些真值概念的类型的值，并肯定地告诉我们它是真是假。注意，从我们在函数中使用
    `a` 的方式来看，`a` 必须是一个具体类型。
- en: Next up, let’s define some instances. For numbers, we’ll assume that (as in
    JavaScript) any number that isn’t `0` is true in a Boolean context and `0` is
    false.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一些实例。对于数字，我们将假设（就像在 JavaScript 中一样）任何不是 `0` 的数字在布尔上下文中都是真的，而 `0` 是假的。
- en: '[PRE113]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Empty lists (and by extension, strings) are a no-ish value, while nonempty lists
    are a yes-ish value.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表（以及由此扩展的字符串）是一个否定的值，而非空列表是一个肯定的值。
- en: '[PRE114]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Notice how we just put a type parameter `a` in there to make the list a concrete
    type, even though we don’t make any assumptions about the type that’s contained
    in the list.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只是在那里放了一个类型参数 `a`，使列表成为一个具体类型，尽管我们没有对列表中包含的类型做出任何假设。
- en: '`Bool` itself also holds trueness and falseness, and it’s pretty obvious which
    is which:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bool` 本身也包含真值和假值，哪个是真哪个是假非常明显：'
- en: '[PRE115]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: But what’s `id`? It’s just a standard library function that takes a parameter
    and returns the same thing, which is what we would be writing here anyway.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `id` 是什么呢？它只是一个标准库函数，接受一个参数并返回相同的东西，这正是我们在这里要写的。
- en: 'Let’s make `Maybe a` an instance, too:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把 `Maybe a` 也变成一个实例：
- en: '[PRE116]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802608.png.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802608.png.jpg)'
- en: We didn’t need a class constraint, because we made no assumptions about the
    contents of the `Maybe`. We just said that it’s true-ish if it’s a `Just` value
    and false-ish if it’s a `Nothing`. We still need to write out `(Maybe a)` instead
    of just `Maybe`. If you think about it, a `Maybe -> Bool` function can’t exist
    (because `Maybe` isn’t a concrete type), whereas a `Maybe a -> Bool` is fine and
    dandy. Still, this is really cool, because now any type of the form `Maybe something`
    is part of `YesNo`, and it doesn’t matter what that something is.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要类约束，因为我们没有对 `Maybe` 的内容做出任何假设。我们只是说，如果它是 `Just` 值，那么它就是有点真；如果它是 `Nothing`，那么它就是有点假。我们仍然需要写出
    `(Maybe a)` 而不是仅仅 `Maybe`。如果你这么想，一个 `Maybe -> Bool` 函数是不存在的（因为 `Maybe` 不是一个具体类型），而一个
    `Maybe a -> Bool` 是很好用的。尽管如此，这真的很酷，因为现在任何形式的 `Maybe something` 类型都是 `YesNo` 的一部分，而那“something”是什么并不重要。
- en: 'Previously, we defined a `Tree a` type that represented a binary search tree.
    We can say an empty tree is false-ish, and anything that’s not an empty tree is
    true-ish:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们定义了一个 `Tree a` 类型，它表示一个二叉搜索树。我们可以这样说，空树是有点假的，而任何不是空树的都是有点真的：
- en: '[PRE117]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Can a traffic light be a yes or no value? Sure. If it’s red, you stop. If it’s
    green, you go. (If it’s yellow? Eh, I usually run the yellows because I live for
    adrenaline.)
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 交通灯可以是肯定或否定的值吗？当然可以。如果是红灯，你就停下。如果是绿灯，你就走。（如果是黄灯呢？嗯，我通常闯黄灯，因为我喜欢肾上腺素。）
- en: '[PRE118]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Now that we have some instances, let’s go play!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一些实例，让我们去玩玩吧！
- en: '[PRE119]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: It works!
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作得很好！
- en: Now let’s make a function that mimics the `if` statement, but that works with
    `YesNo` values.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个模拟 `if` 语句的功能，但这个功能使用 `YesNo` 值。
- en: '[PRE120]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'This takes a `YesNo` value and two values of any type. If the yes-no--ish value
    is more of a yes, it returns the first of the two values; otherwise, it returns
    the second of them. Let’s try it:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个 `YesNo` 值和任何类型的两个值。如果 yes-no-ish 值更像是 yes，它就返回两个值中的第一个；否则，它就返回第二个。让我们试试：
- en: '[PRE121]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The Functor Type Class
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式类型类
- en: So far, we’ve encountered a lot of the type classes in the standard library.
    We’ve played with `Ord`, which is for stuff that can be ordered. We’ve palled
    around with `Eq`, which is for things that can be equated. We’ve seen `Show`,
    which presents an interface for types whose values can be displayed as strings.
    Our good friend `Read` is there whenever we need to convert a string to a value
    of some type. And now, we’re going to take a look at the `Functor` type class,
    which is for things that can be mapped over.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遇到了标准库中的许多类型类。我们玩过 `Ord`，它是用于可排序的东西。我们与 `Eq` 一起玩耍，它是用于可以相等的东西。我们看到了
    `Show`，它为可以以字符串形式显示值的类型提供了一个接口。我们的好朋友 `Read` 在我们需要将字符串转换为某些类型的值时总是存在。现在，我们将要看看
    `Functor` 类型类，它是用于可以映射的东西。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802610.png.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802610.png.jpg)'
- en: You’re probably thinking about lists now, since mapping over lists is such a
    dominant idiom in Haskell. And you’re right, the list type is part of the `Functor`
    type class.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能正在想列表，因为映射列表在 Haskell 中是一个如此占主导地位的习语。而且你是对的，列表类型是 `Functor` 类型类的一部分。
- en: What better way to get to know the `Functor` type class than to see how it’s
    implemented? Let’s take a peek.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `Functor` 类型类，还有什么比看到它是如何实现的更好的方法呢？让我们看看。
- en: '[PRE122]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We see that it defines one function, `fmap`, and doesn’t provide any default
    implementation for that function. The type of `fmap` is interesting. In the definitions
    of type classes so far, the type variable that played the role of the type in
    the type class was a concrete type, like the `a` in `(==) :: (Eq a) => a -> a
    -> Bool`. But now, the `f` is not a concrete type (a type that a value can hold,
    like `Int`, `Bool`, or `Maybe String`), but a type constructor that takes one
    type parameter. (A quick refresher example: `Maybe Int` is a concrete type, but
    `Maybe` is a type constructor that takes one type as the parameter.)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以看到它定义了一个函数`fmap`，并且没有为该函数提供任何默认实现。`fmap`的类型很有趣。到目前为止的类型类定义中，扮演类型类中类型角色的类型变量是一个具体类型，比如`(==)
    :: (Eq a) => a -> a -> Bool`中的`a`。但现在，`f`不是一个具体类型（一个值可以持有的类型，如`Int`、`Bool`或`Maybe
    String`），而是一个类型构造函数，它接受一个类型参数。（快速复习示例：`Maybe Int`是一个具体类型，但`Maybe`是一个接受一个类型作为参数的类型构造函数。）'
- en: We see that `fmap` takes a function from one type to another and a functor value
    applied with one type and returns a functor value applied with another type. If
    this sounds a bit confusing, don’t worry—all will be revealed soon when we check
    out a few examples.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`fmap`接受一个从一种类型到另一种类型的函数，以及一个应用了一种类型的函子值，并返回一个应用了另一种类型的函子值。如果这听起来有点令人困惑，不要担心——所有的一切都会在我们检查一些示例时很快揭晓。
- en: 'Hmm . . . the type declaration for `fmap` reminds me of something. Let’s look
    at the type signature of the `map` function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……`fmap`的类型声明让我想起了某件事。让我们看看`map`函数的类型签名：
- en: '[PRE123]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Ah, interesting! It takes a function from one type to another and a list of
    one type and returns a list of another type. My friends, I think we have ourselves
    a functor! In fact, `map` is just a `fmap` that works only on lists. Here’s how
    the list is an instance of the `Functor` type class:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，有趣！它接受一个从一种类型到另一种类型的函数和一个同一类型的列表，并返回另一个类型的列表。我的朋友们，我想我们找到了一个函子！实际上，`map`只是一个只在列表上工作的`fmap`。以下是列表如何成为`Functor`类型类的一个实例：
- en: '[PRE124]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'That’s it! Notice how we didn’t write `instance Functor [a] where`. This is
    because `f` must be a type constructor that takes one type, which we can see in
    the following type declaration:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！注意我们并没有写`instance Functor [a] where`。这是因为`f`必须是一个类型构造函数，它接受一个类型，我们可以在以下类型声明中看到这一点：
- en: '[PRE125]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`[a]` is already a concrete type (of a list with any type inside it), while
    `[]` is a type constructor that takes one type and can produce types such as `[Int]`,
    `[String]`, or even `[[String]]`.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`[a]`已经是一个具体类型（包含任何类型的列表），而`[]`是一个类型构造函数，它接受一个类型并可以产生如`[Int]`、`[String]`或甚至`[[String]]`这样的类型。'
- en: 'Since for lists, `fmap` is just `map`, we get the same results when using these
    functions on lists:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对于列表来说，`fmap`就是`map`，因此当我们使用这些函数对列表进行操作时，我们会得到相同的结果：
- en: '[PRE126]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: What happens when we `map` or `fmap` over an empty list? Well, of course, we
    get an empty list. It turns an empty list of type `[a]` into an empty list of
    type `[b]`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对空列表进行`map`或`fmap`操作时会发生什么？当然，我们会得到一个空列表。它将类型为`[a]`的空列表转换为类型为`[b]`的空列表。
- en: Maybe As a Functor
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也许作为一个函子
- en: Types that can act like a box can be functors. You can think of a list as a
    box that can be empty or have something inside it, including another box. That
    box can also be empty or contain something and another box, and so on. So, what
    else has the properties of being like a box? For one, the `Maybe a` type. In a
    way, it’s like a box that can hold nothing (in which case it has the value of
    `Nothing`), or it can contain one item (like `"HAHA"`, in which case it has a
    value of `Just "HAHA"`).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像盒子一样行动的类型可以是函子。你可以把列表想象成一个可以是空的或者里面可以包含某些东西的盒子，包括另一个盒子。那个盒子也可以是空的或者包含某些东西和另一个盒子，以此类推。那么，还有什么具有类似盒子的属性？首先，`Maybe
    a`类型。在某种程度上，它像一个可以容纳无物的盒子（在这种情况下，它具有`Nothing`的值），或者它可以包含一个项目（比如`"HAHA"`，在这种情况下，它具有`Just
    "HAHA"`的值）。
- en: 'Here’s how `Maybe` is a functor:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Maybe`如何成为函子的例子：
- en: '[PRE127]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Again, notice how we wrote `instance Functor Maybe where` instead of `instance
    Functor (Maybe m) where`, as we did when we were dealing with `YesNo`. `Functor`
    wants a type constructor that takes one type, and not a concrete type. If you
    mentally replace the `f`s with `Maybe`s, `fmap` acts like a `(a -> b) -> Maybe
    a -> Maybe b` for this particular type, which looks okay. But if you replace `f`
    with `(Maybe m)`, then it would seem to act like a `(a -> b) -> Maybe m a -> Maybe
    m b`, which doesn’t make sense, because `Maybe` takes just one type parameter.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，我们是如何写`instance Functor Maybe where`而不是`instance Functor (Maybe m) where`，就像我们在处理`YesNo`时做的那样。`Functor`需要一个只接受一个类型的类型构造函数，而不是一个具体类型。如果你在心理上用`Maybe`替换`f`，`fmap`在这个特定类型上就像一个`(a
    -> b) -> Maybe a -> Maybe b`，这看起来是合理的。但是如果你用`(Maybe m)`替换`f`，那么它看起来就像一个`(a ->
    b) -> Maybe m a -> Maybe m b`，这是没有意义的，因为`Maybe`只接受一个类型参数。
- en: 'The `fmap` implementation is pretty simple. If it’s an empty value of `Nothing`,
    then just return a `Nothing`. If we map over an empty box, we get an empty box.
    If we map over an empty list, we get an empty list. If it’s not an empty value,
    but rather a single value packed in a `Just`, then we apply the function on the
    contents of the `Just`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmap`的实现相当简单。如果它是一个空的`Nothing`值，那么就简单地返回一个`Nothing`。如果我们映射一个空的盒子，我们得到一个空的盒子。如果我们映射一个空的列表，我们得到一个空的列表。如果不是空的值，而是一个包含在`Just`中的单个值，那么我们就在`Just`的内容上应用函数：'
- en: '[PRE128]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Trees Are Functors, Too
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树也是函子
- en: 'Another thing that can be mapped over and made an instance of `Functor` is
    our `Tree a` type. It can be thought of as a box (it holds several or no values),
    and the `Tree` type constructor takes exactly one type parameter. If you look
    at `fmap` as if it were a function made only for `Tree`, its type signature would
    look like this: `(a -> b) -> Tree a -> Tree b`.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以被映射并成为`Functor`实例的是我们的`Tree a`类型。它可以被看作是一个盒子（它包含几个或没有值），而`Tree`类型构造函数恰好接受一个类型参数。如果你把`fmap`看作是专门为`Tree`设计的函数，它的类型签名将看起来像这样：`(a
    -> b) -> Tree a -> Tree b`。
- en: 'We’re going to use recursion on this one. Mapping over an empty tree will produce
    an empty tree. Mapping over a nonempty tree will produce a tree consisting of
    our function applied to the root value, and its left and right subtrees will be
    the previous subtrees, but with our function mapped over them. Here’s the code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个问题上使用递归。映射一个空的树将产生一个空的树。映射一个非空树将产生一个树，其根值被我们的函数应用，其左右子树将是之前的子树，但它们被映射了我们的函数。以下是代码：
- en: '[PRE129]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now let’s test it:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试一下：
- en: '[PRE130]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Be careful though! If you use the `Tree a` type to represent a binary search
    tree, there is no guarantee that it will remain a binary search tree after mapping
    a function over it. For something to be considered a binary search tree, all the
    elements to the left of some node must be smaller than the element in the node,
    and all the elements to the right must be greater. But if you map a function like
    `negate` over a binary search tree, the elements to the left of the node suddenly
    become greater than its element, and your binary search tree becomes just a normal
    binary tree.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要小心！如果你使用`Tree a`类型来表示二叉搜索树，在映射函数之后，无法保证它仍然是二叉搜索树。要被认为是二叉搜索树，某个节点左侧的所有元素必须小于该节点的元素，而右侧的所有元素必须大于。但是如果你在二叉搜索树上映射一个像`negate`这样的函数，节点左侧的元素突然变得大于其元素，你的二叉搜索树就变成了一个普通的二叉树。
- en: Either a As a Functor
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Either a`作为函子'
- en: How about `Either a b`? Can this be made a functor? The `Functor` type class
    wants a type constructor that takes only one type parameter, but `Either` takes
    two. Hmmm . . . I know, we’ll partially apply `Either` by feeding it only one
    parameter, so that it has one free parameter.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`Either a b`呢？它能成为一个函子吗？`Functor`类型类需要一个只接受一个类型参数的类型构造函数，但`Either`接受两个。嗯嗯……我知道，我们可以通过只提供参数来部分应用`Either`，这样它就有一个自由参数。
- en: 'Here’s how `Either a` is a functor in the standard libraries, more specifically
    in the `Control.Monad.Instances` module:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在标准库中，更具体地说在`Control.Monad.Instances`模块中，将`Either a`定义为函子：
- en: '[PRE131]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Well well, what do we have here? You can see how `Either a` was made an instance
    instead of just `Either`. That’s because `Either a` is a type constructor that
    takes one parameter, whereas `Either` takes two. If `fmap` were specifically for
    `Either a`, the type signature would be this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧好吧，这里有什么？你可以看到`Either a`是如何被定义为实例而不是仅仅`Either`。这是因为`Either a`是一个类型构造函数，它接受一个参数，而`Either`接受两个。如果`fmap`专门为`Either
    a`设计，其类型签名将是这样的：
- en: '[PRE132]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Because that’s the same as the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这与以下内容相同：
- en: '[PRE133]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The function is mapped in the case of a `Right` value constructor, but it isn’t
    mapped in the case of a `Left`. Why is that? Well, looking back at how the `Either
    a b` type is defined, we see this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当值构造函数为`Right`时，函数会被映射，但在`Left`的情况下则不会映射。为什么是这样呢？好吧，回顾一下`Either a b`类型的定义，我们看到：
- en: '[PRE134]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'If we wanted to map one function over both of them, `a` and `b` would need
    to be the same type. Think about it: If we try to map a function that takes a
    string and returns a string, and `b` is a string but `a` is a number, it won’t
    really work out. Also, considering what `fmap`’s type would be if it operated
    only on `Either a b` values, we can see that the first parameter must remain the
    same, while the second one can change, and the first parameter is actualized by
    the `Left` value constructor.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将一个函数映射到这两个上，`a`和`b`需要是同一类型。想想看：如果我们尝试映射一个接受字符串并返回字符串的函数，而`b`是字符串但`a`是数字，这实际上是不会奏效的。此外，考虑到如果`fmap`只操作`Either
    a b`值，它的类型会是什么，我们可以看到第一个参数必须保持不变，而第二个参数可以改变，第一个参数由`Left`值构造函数实现。
- en: This also goes nicely with our box analogy if we think of the `Left` part as
    sort of an empty box with an error message written on the side telling us why
    it’s empty.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Left`部分视为一个带有错误信息的空盒子，旁边写着为什么它是空的，这也很好地与我们的盒子类比相吻合。
- en: Maps from `Data.Map` can also be made into functor values, because they hold
    values (or not!). In the case of `Map k v`, `fmap` will map a function `v -> v'`
    over a map of type `Map k v` and return a map of type `Map k v'`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map`中的映射也可以被制作成函子值，因为它们持有值（或没有！）在`Map k v`的情况下，`fmap`将函数`v -> v''`映射到类型为`Map
    k v`的映射上，并返回类型为`Map k v''`的映射。'
- en: Note
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `'` character has no special meaning in types, just as it has no special
    meaning when naming values. It’s just used to denote things that are similar,
    but slightly changed.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号`'`在类型中没有任何特殊含义，就像它在命名值时没有特殊含义一样。它只是用来表示相似但略有不同的事物。
- en: As an exercise, you can try to figure out how `Map k` is made an instance of
    `Functor` by yourself!
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试自己弄清楚如何将`Map k`制作成`Functor`的实例！
- en: As you’ve seen from the examples, with `Functor`, type classes can represent
    pretty cool higher-order concepts. You’ve also had some more practice with partially
    applying types and making instances. In [Chapter 11](ch11.html "Chapter 11. Applicative
    Functors"), we’ll take a look at some laws that apply for functors.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从例子中，`Functor`类型类可以表示相当酷的高阶概念。你也在部分应用类型和制作实例方面有了更多的实践。在第11章（[Chapter 11](ch11.html
    "Chapter 11. Applicative Functors")）中，我们将查看适用于函子的某些定律。
- en: Kinds and Some Type-Foo
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 种类与一些类型相关概念
- en: Type constructors take other types as parameters to eventually produce concrete
    types. This behavior is similar to that of functions, which take values as parameters
    to produce values. Also like functions, type constructors can be partially applied.
    For example, `Either String` is a type constructor that takes one type and produces
    a concrete type, like `Either String Int`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 类型构造函数接受其他类型作为参数，最终产生具体类型。这种行为与函数类似，函数接受值作为参数以产生值。同样，类型构造函数也可以部分应用。例如，`Either
    String`是一个类型构造函数，它接受一个类型并产生一个具体类型，如`Either String Int`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802612.png.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802612.png.jpg)'
- en: In this section, we’ll take a look at formally defining how types are applied
    to type constructors. You don’t really need to read this section to continue on
    your magical Haskell quest, but it may help you to see how Haskell’s type system
    works. And if you don’t quite understand everything right now, that’s okay, too.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将正式定义类型如何应用于类型构造函数。你实际上不需要阅读本节就可以继续你的神奇Haskell之旅，但它可能有助于你了解Haskell的类型系统是如何工作的。而且，如果你现在还没有完全理解，那也没关系。
- en: Values like `3`, `"YEAH"`, or `takeWhile` (functions are also values—we can
    pass them around and such) each has their own types. Types are little labels that
    values carry so that we can reason about the values. But types have their own
    little labels called *kinds*. A kind is more or less the type of a type. This
    may sound a bit weird and confusing, but it’s actually a really cool concept.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的值`3`、`"YEAH"`或`takeWhile`（函数也是值——我们可以传递它们等）各自有自己的类型。类型是值携带的小标签，这样我们就可以对值进行推理。但是类型有自己的小标签，称为*种类*。种类基本上是类型的类型。这听起来可能有点奇怪和令人困惑，但实际上这是一个非常酷的概念。
- en: 'What are kinds, and what are they good for? Well, let’s examine the kind of
    a type by using the `:k` command in GHCi:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，种类是什么，它们有什么用？好吧，让我们通过在GHCi中使用`:k`命令来检查类型的种类：
- en: '[PRE135]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: What does that `*` mean? It indicates that the type is a concrete type. A concrete
    type is a type that doesn’t take any type parameters. Values can have only types
    that are concrete types. If I had to read `*` out loud (I haven’t had to do that
    yet), I would say “star,” or just “type.”
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `*` 符号是什么意思？它表示类型是一个具体类型。具体类型是指不包含任何类型参数的类型。值只能具有具体类型的类型。如果我要大声读出 `*`（我还没有这样做过），我会说“星号”，或者简单地说是“类型”。
- en: 'Okay, now let’s see what the kind of `Maybe` is:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们看看 `Maybe` 的种类是什么：
- en: '[PRE136]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'This kind tells us that the `Maybe` type constructor takes one concrete type
    (like `Int`) and returns a concrete type (like `Maybe Int`). Just as `Int -> Int`
    means that a function takes an `Int` and returns an `Int`, `* -> *` means that
    the type constructor takes one concrete type and returns a concrete type. Let’s
    apply the type parameter to `Maybe` and see what the kind of that type is:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型告诉我们 `Maybe` 类型构造函数接受一个具体类型（比如 `Int`）并返回一个具体类型（比如 `Maybe Int`）。就像 `Int ->
    Int` 表示一个函数接受一个 `Int` 并返回一个 `Int` 一样，`* -> *` 表示类型构造函数接受一个具体类型并返回一个具体类型。让我们将类型参数应用到
    `Maybe` 上，看看那个类型的种类是什么：
- en: '[PRE137]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Just as you might have expected, we applied the type parameter to `Maybe` and
    got back a concrete type (that’s what `* -> *` means). A parallel (although not
    equivalent—types and kinds are two different things) to this is if we call `:t
    isUpper` and `:t isUpper 'A'`. The `isUpper` function has a type of `Char -> Bool`,
    and `isUpper 'A'` has a type of `Bool`, because its value is basically `False`.
    Both those types, however, have a kind of `*`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预期的，我们将类型参数应用到 `Maybe` 上，得到了一个具体类型（这就是 `* -> *` 的意思）。与此类似（尽管并不等价——类型和种类是两回事）的是，如果我们调用
    `:t isUpper` 和 `:t isUpper 'A'`。`isUpper` 函数的类型是 `Char -> Bool`，而 `isUpper 'A'`
    的类型是 `Bool`，因为它的值基本上是 `False`。然而，这两个类型都有一个种类 `*`。
- en: We used `:k` on a type to get its kind, in the same way as we can use `:t` on
    a value to get its type. Again, types are the labels of values, and kinds are
    the labels of types, and there are parallels between the two.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `:k` 在类型上获取其种类，就像我们可以使用 `:t` 在值上获取其类型一样。再次强调，类型是值的标签，种类是类型的标签，两者之间有相似之处。
- en: 'Now let’s look at the kind of `Either`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Either` 的种类：
- en: '[PRE138]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This tells us that `Either` takes two concrete types as type parameters to
    produce a concrete type. It also looks somewhat like the type declaration of a
    function that takes two values and returns something. Type constructors are curried
    (just like functions), so we can partially apply them, as you can see here:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 `Either` 接受两个具体类型作为类型参数来产生一个具体类型。它看起来也有些像函数类型声明，该函数接受两个值并返回某个东西。类型构造函数是柯里化的（就像函数一样），因此我们可以部分应用它们，就像你在这里看到的那样：
- en: '[PRE139]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: When we wanted to make `Either a` part of the `Functor` type class, we needed
    to partially apply it, because `Functor` wants types that take only one parameter,
    while `Either` takes two. In other words, `Functor` wants types of kind `* ->
    *`, so we needed to partially apply `Either` to get this instead of its original
    kind, `* -> * -> *`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将 `Either a` 纳入 `Functor` 类型类时，我们需要部分应用它，因为 `Functor` 希望的是只接受一个参数的类型，而
    `Either` 接受两个。换句话说，`Functor` 希望的是种类为 `* -> *` 的类型，因此我们需要部分应用 `Either` 来得到这个种类，而不是它原始的种类
    `* -> * -> *`。
- en: 'Looking at the definition of `Functor` again, we can see that the `f` type
    variable is used as a type that takes one concrete type to produce a concrete
    type:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 `Functor` 的定义，我们可以看到 `f` 类型变量被用作一个接受一个具体类型并产生一个具体类型的类型：
- en: '[PRE140]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: We know it must produce a concrete type, because it’s used as the type of a
    value in a function. And from that, we can deduce that types that want to be friends
    with `Functor` must be of kind `* -> *`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道它必须产生一个具体类型，因为它被用作函数中值的类型。由此，我们可以推断出想要与 `Functor` 成为朋友的类型必须是种类为 `* -> *`
    的类型。
