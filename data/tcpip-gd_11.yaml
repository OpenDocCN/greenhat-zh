- en: Part II-8. TCP/IP TRANSPORT LAYER PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分-8. TCP/IP传输层协议
- en: '[Chapter 42](ch42.html "Chapter 42. OVERVIEW AND COMPARISON OF TCP AND UDP")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第42章](ch42.html "第42章。TCP和UDP概述与比较")'
- en: '[Chapter 43](ch43.html "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第43章](ch43.html "第43章。TCP和UDP寻址：端口和套接字")'
- en: '[Chapter 44](ch44.html "Chapter 44. TCP/IP USER DATAGRAM PROTOCOL (UDP)")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第44章](ch44.html "第44章。TCP/IP用户数据报协议(UDP)")'
- en: '[Chapter 45](ch45.html "Chapter 45. TCP OVERVIEW, FUNCTIONS, AND CHARACTERISTICS")'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第45章](ch45.html "第45章。TCP概述、功能和特性")'
- en: '[Chapter 46](ch46.html "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS
    AND GENERAL OPERATION")'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第46章](ch46.html "第46章。传输控制协议(TCP)基础和一般操作")'
- en: '[Chapter 47](ch47.html "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT,
    MANAGEMENT, AND TERMINATION")'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第47章](ch47.html "第47章。TCP基本操作：连接建立、管理和终止")'
- en: '[Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER")'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第48章](ch48.html "第48章。TCP消息格式和数据传输")'
- en: '[Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES")'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第49章](ch49.html "第49章。TCP可靠性和流量控制特性")'
- en: The first three layers of the OSI Reference Model—the physical layer, data link
    layer, and network layer—are very important layers for understanding how networks
    function. The physical layer moves bits over wires; the data link layer moves
    frames on a network; and the network layer moves datagrams on an internetwork.
    Taken as a whole, they are the parts of a protocol stack that are responsible
    for the actual nuts and bolts of getting data from one place to another.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OSI参考模型的前三层——物理层、数据链路层和网络层——对于理解网络如何工作非常重要。物理层在电线上移动比特；数据链路层在网络中移动帧；网络层在互联网中移动数据报。作为一个整体，它们是协议堆栈的组成部分，负责将数据从一地传输到另一地。
- en: 'Immediately above these three layers is the fourth layer of the OSI Reference
    Model: the transport layer, called the host-to-host transport layer in the TCP/IP
    model. This layer is interesting in that it resides in the very architectural
    center of the model. Accordingly, it represents an important transition point
    between the hardware-associated layers below it that do the grunt work and the
    layers above that are more software-oriented and abstract.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三层之上立即是OSI参考模型的第四层：传输层，在TCP/IP模型中称为主机到主机的传输层。这一层很有趣，因为它位于模型的非常核心的架构中。因此，它代表了在下面的硬件相关层（执行基础工作）和上面的更软件导向和抽象的层之间的重要过渡点。
- en: Protocols running at the transport layer are charged with providing several
    important services to enable software applications in higher layers to work over
    an internetwork. They are typically responsible for allowing connections to be
    established and maintained between software services on possibly distant machines.
    Many higher-layer applications need to send data in a reliable way, without needing
    to worry about error correction, lost data, or flow management. However, network
    layer protocols are typically unreliable and unacknowledged. Transport layer protocols
    are often very tightly tied to the network layer protocols directly below them
    and designed specifically to take care of functions that are not dealt with by
    those protocols.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输层运行的协议负责提供几个重要的服务，以使高层软件应用能够在互联网上工作。它们通常负责在可能位于远程机器上的软件服务之间建立和维护连接。许多高层应用需要以可靠的方式发送数据，而无需担心错误纠正、丢失数据或流量管理。然而，网络层协议通常是不可靠的且未确认的。传输层协议通常与直接位于其下的网络层协议非常紧密地绑定，并专门设计来处理那些协议未处理的功能。
- en: 'This part describes transport layer protocols and related technologies used
    in the TCP/IP protocol suite. There are two main protocols at this layer: the
    Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP). UDP
    is the simpler of the two and doesn''t take a great deal of time to explain. In
    contrast, TCP is a rather complex protocol that is also a very important part
    of the TCP/IP protocol suite, and thus it requires considerably more explanation.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分描述了TCP/IP协议集中使用的传输层协议和相关技术。在这一层有两个主要的协议：传输控制协议(TCP)和用户数据报协议(UDP)。UDP比TCP简单，解释起来也不需要花费太多时间。相比之下，TCP是一个相当复杂的协议，也是TCP/IP协议集中的非常重要的部分，因此需要更多的解释。
- en: The first chapter in this part provides a quick overview of the roles of these
    two protocols in the TCP/IP protocol suite, a discussion of why they are both
    important, and a summary that compares their key attributes. The second chapter
    describes the method that both protocols employ for addressing, using transport
    layer ports and sockets. The third chapter contains a discussion of UDP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分的第一章简要概述了这两个协议在TCP/IP协议族中的作用，讨论了它们为何都如此重要，并总结了它们的关键属性。第二章描述了这两个协议用于寻址的方法，即使用传输层端口和套接字。第三章讨论了UDP。
- en: The remaining five chapters encompass a comprehensive description of the concepts,
    characteristics, and functions of TCP. The fourth chapter in this part provides
    an overview of TCP, describing its history, what it does, and how it works. The
    fifth chapter covers some important background information that is necessary to
    understanding how TCP operates, explaining key concepts such as streams and segments,
    sliding windows, and TCP ports and connections. The sixth chapter describes the
    process used by TCP to establish, maintain, and terminate sessions. The seventh
    chapter describes TCP messages and how they are formatted and transferred. Finally,
    the last chapter in this part shows how TCP provides reliability and other important
    transport layer functions, such as flow control, retransmission of lost data,
    and congestion avoidance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的五章涵盖了TCP的概念、特性和功能的全面描述。本部分第四章概述了TCP，描述了其历史、功能以及工作原理。第五章涵盖了理解TCP操作所需的一些重要背景信息，解释了诸如流和段、滑动窗口以及TCP端口和连接等关键概念。第六章描述了TCP建立、维持和终止会话的过程。第七章描述了TCP消息及其格式化和传输方式。最后，本部分最后一章展示了TCP如何提供可靠性以及其他重要的传输层功能，如流量控制、丢失数据的重传和拥塞避免。
- en: Since TCP is built on top of the Internet Protocol (IP), in describing TCP,
    I assume that you have at least a basic familiarity with IP (covered in [Part II-3](pt06.html
    "Part II-3. INTERNET PROTOCOL VERSION 4 (IP/IPV4)"); specifically, see Chapters
    [Chapter 15](ch15.html "Chapter 15. INTERNET PROTOCOL VERSIONS, CONCEPTS, AND
    OVERVIEW") and [Chapter 16](ch16.html "Chapter 16. IPV4 ADDRESSING CONCEPTS AND
    ISSUES") for descriptions of basic IP concepts).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP建立在互联网协议（IP）之上，在描述TCP时，我假设您至少对IP有基本的了解（在[第二部分-3](pt06.html "第二部分-3. 互联网协议版本4
    (IP/IPV4)"); 特别是，参见第15章(ch15.html "第15章. 互联网协议版本、概念和概述")和第16章(ch16.html "第16章.
    IPv4寻址概念和问题")，其中描述了基本IP概念)）。
- en: Chapter 42. OVERVIEW AND COMPARISON OF TCP AND UDP
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第42章：TCP和UDP的概述与比较
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: TCP/IP is the most important internetworking protocol suite in the world. It
    is the basis for the Internet and the "language" spoken by the vast majority of
    the world's networked computers. TCP/IP includes a large set of protocols that
    operate at the network layer and the layers above it. The suite as a whole is
    anchored at layer 3 by the Internet Protocol (IP), which many people consider
    the single most important protocol in the world of networking.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP是世界上最重要的互联网协议族。它是互联网的基础，也是世界上绝大多数联网计算机所使用的“语言”。TCP/IP包括一组在网络层及其以上层运行的协议。整个套件以互联网协议（IP）为基础，许多人都认为这是网络世界中最重要的单一协议。
- en: Of course, there's a bit of *architectural distance* between the network layer
    and the applications that run at the layers well above that layer. IP is the protocol
    that performs the bulk of the functions needed to make an internetwork work, but
    it does not include some capabilities that many applications need. In TCP/IP,
    a pair of protocols that operate at the transport layer performs these tasks.
    The protocols are the *Transmission Control Protocol (TCP)* and the *User Datagram
    Protocol (UDP)*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络层和在其之上运行的层中的应用程序之间存在一定的*架构距离*。IP是执行使互联网工作所需的大部分功能的协议，但它不包括许多应用程序需要的某些功能。在TCP/IP中，运行在传输层的两个协议执行这些任务。这些协议是*传输控制协议（TCP）*和*用户数据报协议（UDP）*。
- en: Of these two, TCP gets the most attention. It is the transport layer protocol
    that is most often associated with TCP/IP. It is also the transport protocol that
    many of the Internet's most popular applications use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个协议中，TCP受到了最多的关注。它是与TCP/IP最常相关联的传输层协议。它也是许多互联网上最受欢迎的应用程序使用的传输协议。
- en: UDP, on the other hand, gets second billing. However, UDP and TCP are really
    peers that play the same role in TCP/IP. They function very differently and provide
    different benefits for and drawbacks to the applications that use them. Yet they
    are both important to the protocol suite as a whole. This chapter introduces what
    TCP and UDP do and highlights the similarities and differences between them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，UDP排在第二位。然而，UDP和TCP实际上是同等级别的，在TCP/IP中扮演着相同的作用。它们功能非常不同，为使用它们的应用程序提供不同的优势和劣势。但它们对整个协议套件来说都很重要。本章介绍了TCP和UDP的功能，并突出了它们之间的相似之处和不同之处。
- en: Two Protocols for TCP/IP Transport Layer Requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP传输层需求的两项协议
- en: The transport layer in a protocol suite is responsible for a specific set of
    functions. For this reason, you might expect that the TCP/IP suite would have
    a single main transport protocol that performs those functions, just as it has
    IP as its core protocol at the network layer. But there are *two* different widely
    used TCP/IP transport layer protocols, an arrangement that is probably one of
    the best examples of the power of protocol layering (showing that it was worth
    all the time you spent learning to understand that pesky OSI Reference Model back
    in Chapters [Chapter 5](ch05.html "Chapter 5. GENERAL OSI REFERENCE MODEL ISSUES
    AND CONCEPTS") through [Chapter 7](ch07.html "Chapter 7. OSI REFERENCE MODEL SUMMARY")).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议套件中，传输层负责一组特定的功能。因此，你可能期望TCP/IP套件会有一个单一的、主要的传输协议来执行这些功能，就像它在网络层有IP作为核心协议一样。但有两个不同的广泛使用的TCP/IP传输层协议，这种安排可能是协议分层力量的最佳例子之一（表明学习理解第5章到第7章中令人烦恼的OSI参考模型所花费的所有时间是值得的）。
- en: Let's start with a look back at layer 3\. In my overview of the key operating
    characteristics of IP in [Chapter 15](ch15.html "Chapter 15. INTERNET PROTOCOL
    VERSIONS, CONCEPTS, AND OVERVIEW"), I described several limitations of IP. The
    most important limitations are that IP is *connectionless*, *unreliable*, and
    *unacknowledged*. Using a best-effort paradigm, data is sent over an IP internetwork
    without first establishing a connection. Messages *usually* get where they need
    to go, but there are no guarantees, and the sender usually doesn't even know if
    the data arrived at its destination.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾第3层开始。在我的[第15章](ch15.html "第15章。互联网协议版本、概念和概述")中关于IP的关键操作特性的概述中，我描述了IP的几个限制。最重要的限制是IP是**无连接的**、**不可靠的**和**无确认的**。使用尽力而为的范式，数据在没有首先建立连接的情况下被发送到IP互联网。消息**通常**会到达它们需要去的地方，但没有保证，发送者通常甚至不知道数据是否到达了目的地。
- en: These characteristics present serious problems for software. Many, if not most,
    applications need to be able to count on the fact that the data they send will
    get to its destination without loss or error. Applications also want the connection
    between two devices to be automatically managed, with problems such as congestion
    and flow control taken care of as needed. Unless some mechanism is provided for
    this at lower layers, every application would need to perform these jobs, and
    that would be a massive duplication of effort.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性给软件带来了严重的问题。许多，如果不是大多数，应用程序都需要能够依赖它们发送的数据能够无损失或无错误地到达目的地。应用程序还希望两个设备之间的连接能够自动管理，如拥塞和流量控制等问题能够按需解决。除非在较低层提供某种机制，否则每个应用程序都需要执行这些任务，这将造成巨大的重复劳动。
- en: 'In fact, you might argue that establishing connections, providing reliability,
    and handling retransmissions, buffering, and data flow are sufficiently important
    that it might have been best to simply build these abilities directly into IP.
    Interestingly, that was exactly the case in the early days of TCP/IP. In the beginning
    there was just a single protocol called TCP. It combined the tasks of IP with
    the reliability and session management features that I just mentioned. There''s
    a big problem with this, however: Establishing connections, providing a mechanism
    for reliability, managing flow control, managing acknowledgments, and managing
    retransmissions all come at a cost of time and bandwidth. Building all of these
    capabilities into a single protocol that spanned layers 3 and 4 would mean that
    all applications would receive the benefits of reliability, but would also take
    on the costs. While this approach would be fine for many applications, there are
    others that either don''t need the reliability or can''t afford the overhead required
    to provide it.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你可能会争辩说，建立连接、提供可靠性、处理重传、缓冲和数据流都是足够重要的，可能最好直接将这些能力构建到 IP 中。有趣的是，TCP/IP 的早期阶段正是如此。最初只有一个名为
    TCP 的协议。它结合了 IP 的任务以及我刚才提到的可靠性和会话管理功能。然而，这有一个大问题：建立连接、提供可靠性机制、管理流量控制、管理确认和管理重传都会带来时间和带宽的开销。将这些能力构建到一个跨越层
    3 和 4 的单一协议中意味着所有应用程序都会获得可靠性的好处，但也会承担相应的成本。虽然这种方法对许多应用程序来说都是可行的，但还有一些应用程序要么不需要可靠性，要么无法承担提供可靠性所需的开销。
- en: 'The solution was simple: Let the network layer (IP) take care of basic data
    movement on the internetwork, and define two protocols at the transport layer.
    One protocol would provide a rich set of services for applications that need that
    functionality, and the understanding would be that some overhead would be required
    when using this protocol. The other protocol would be simpler, providing little
    in the way of classic layer 4 functions, but it would be fast and easy to use.
    Thus, the result was two TCP/IP transport layer protocols:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单：让网络层（IP）负责在互联网上处理基本的数据移动，并在传输层定义两个协议。一个协议将为需要该功能的应用程序提供丰富的服务集，并且在使用此协议时，理解到需要一些开销。另一个协议会更简单，在经典层
    4 功能方面提供很少的服务，但它会更快、更易于使用。因此，结果是两个 TCP/IP 传输层协议：
- en: '**Transmission Control Protocol (TCP)** TCP is a full-featured, connection-oriented,
    reliable transport protocol for TCP/IP applications. It provides transport layer
    addressing that allows multiple software applications to simultaneously use a
    single IP address, and it allows a pair of devices to establish a virtual connection
    and then pass data bidirectionally. Transmissions are managed using a special
    *sliding window* system, with unacknowledged transmissions detected and automatically
    retransmitted. Additional functionality allows the flow of data between devices
    to be managed, and special circumstances to be addressed.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议 (TCP)** TCP 是一个功能齐全、面向连接、可靠的 TCP/IP 应用传输协议。它提供了传输层寻址，允许多个软件应用程序同时使用单个
    IP 地址，并允许一对设备建立虚拟连接，然后双向传递数据。传输使用特殊的 *滑动窗口* 系统进行管理，未确认的传输会被检测到并自动重传。额外的功能允许管理设备间的数据流，并解决特殊情况。'
- en: '**User Datagram Protocol (UDP)** In contrast, UDP is a very simple transport
    protocol that provides transport layer addressing like TCP, but little else. UDP
    is barely more than a wrapper protocol that provides a way for applications to
    access IP. No connection is established, transmissions are unreliable, and data
    can be lost.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议 (UDP)** 相比之下，UDP 是一个非常简单的传输协议，它提供了类似于 TCP 的传输层寻址，但除此之外几乎没有其他功能。UDP
    仅仅是一个包装协议，为应用程序提供访问 IP 的方式。没有建立连接，传输不可靠，数据可能会丢失。'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Many TCP/IP applications require different transport requirements,
    thus two TCP/IP transport layer protocols are necessary. The *Transmission Control
    Protocol (TCP)* is a full-featured, connection-oriented protocol that provides
    the acknowledged delivery of data while managing traffic flow and handling issues
    such as congestion and transmission loss. The *User Datagram Protocol (UDP)*,
    in contrast, is a much simpler protocol that concentrates only on delivering data
    in order to maximize the speed of communication when the features of TCP are not
    required.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 许多TCP/IP应用需要不同的传输需求，因此需要两个TCP/IP传输层协议。*传输控制协议（TCP）*是一个功能齐全、面向连接的协议，在管理流量和处理诸如拥塞和传输丢失等问题时，提供数据的确认交付。相比之下，*用户数据报协议（UDP）*是一个更简单的协议，它只专注于交付数据，以便在不需要TCP的功能时最大化通信速度。 '
- en: Applications of TCP and UDP
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP和UDP的应用
- en: To use an analogy, TCP is a fully loaded luxury performance sedan with a chauffeur
    and a satellite tracking/navigation system. It provides a lot of frills, comfort,
    and performance. It virtually guarantees that you will get where you need to go
    without any problems, and any concerns that do arise can be corrected. In contrast,
    UDP is a stripped-down race car. Its goal is simplicity and speed; everything
    else is secondary. You will probably get where you need to go, but you can have
    trouble keeping race cars up and running.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个类比来说，TCP就像一辆配备司机和卫星跟踪/导航系统的全负荷豪华性能轿车。它提供了很多奢华、舒适和性能。它几乎保证你能够无任何问题地到达目的地，并且任何出现的问题都可以得到纠正。相比之下，UDP就像一辆简化的赛车。它的目标是简单和速度；其他一切都是次要的。你可能能够到达目的地，但可能会遇到赛车难以保持运行的问题。
- en: Having two transport layer protocols with such complementary strengths and weaknesses
    provides considerable flexibility to the creators of networking software.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有如此互补的优缺点两个传输层协议，为网络软件的创造者提供了相当大的灵活性。
- en: TCP Applications
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP应用
- en: Most typical applications need the reliability and other services provided by
    TCP, and most applications don't care about the loss of a small amount of performance
    due to TCP's overhead requirements. For example, most applications that transfer
    files or important data between machines use TCP, because the loss of any portion
    of the file renders the data useless. Examples include such well-known applications
    as the Hypertext Transfer Protocol (HTTP), which is used by the World Wide Web
    (WWW), the File Transfer Protocol (FTP), and the Simple Mail Transfer Protocol
    (SMTP). I describe TCP applications in more detail in Section III.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数典型应用都需要TCP提供的可靠性和其他服务，而大多数应用并不介意因为TCP的开销要求而损失一小部分性能。例如，大多数在机器之间传输文件或重要数据的应用都使用TCP，因为文件任何部分的丢失都会使数据变得无用。例如，包括以下知名应用在内的例子：超文本传输协议（HTTP），它是万维网（WWW）使用的；文件传输协议（FTP）；以及简单邮件传输协议（SMTP）。我在第三章中更详细地描述了TCP应用。
- en: UDP Applications
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP应用
- en: What sort of application doesn't care if its data gets there, and why would
    anyone want to use such an unreliable application? You might be surprised. A lot
    of TCP/IP protocols use UDP. It is a good match when the application doesn't really
    care if some of the data gets lost, such as if you are streaming video or multimedia.
    The application won't notice one lost byte of data. UDP is also a good match when
    the application itself chooses to provide some other mechanism to make up for
    the lack of functionality in UDP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么样的应用不关心其数据是否到达，为什么有人会想使用这种不可靠的应用？你可能感到惊讶。许多TCP/IP协议使用UDP。当应用本身不介意一些数据丢失时，它是一个很好的匹配，例如在流式传输视频或多媒体时。应用不会注意到丢失的一个字节的数据。当应用本身选择提供其他机制来弥补UDP功能不足时，UDP也是一个很好的匹配。
- en: Applications that send very small amounts of data often use UDP and assume that
    the client will just send a new request later on if a request is sent and a reply
    is not received. This provides enough reliability without the overhead of a TCP
    connection. I discuss some common UDP applications in [Chapter 44](ch44.html "Chapter 44. TCP/IP
    USER DATAGRAM PROTOCOL (UDP)").
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 发送非常少量数据的应用通常使用UDP，并假设如果发送请求但没有收到回复，客户端稍后会发送新的请求。这提供了足够的可靠性，而没有TCP连接的开销。我在[第44章](ch44.html
    "第44章。TCP/IP用户数据报协议(UDP)")中讨论了一些常见的UDP应用。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Most typical applications, especially ones that send files
    or messages, require that data be delivered reliably, and therefore use TCP for
    transport. The loss of a small amount of data usually is not a concern to applications
    that use UDP or that use their own application-specific procedures for dealing
    with potential delivery problems.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 大多数典型应用程序，尤其是发送文件或消息的应用程序，都需要数据可靠传输，因此使用TCP进行传输。对于使用UDP或使用自己特定的应用程序程序处理潜在交付问题的应用程序来说，少量数据的丢失通常不是问题。'
- en: Note that even though TCP is often described as being *slower* than UDP, this
    is a *relative* measurement. TCP is a very well-written protocol that is capable
    of highly efficient data transfers. It is slow only compared to UDP because of
    the overhead of establishing and managing connections. The difference can be significant,
    but it is not enormous.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管TCP通常被描述为比UDP慢，但这是一种相对测量。TCP是一个非常优秀的协议，能够进行高度有效的数据传输。它之所以慢，只是因为建立和管理连接的开销。这种差异可能是显著的，但不是巨大的。
- en: Incidentally, if you want a good real-world illustration of why it's valuable
    to have both UDP and TCP, consider message transport under the Domain Name System
    (DNS). As described in [Chapter 57](ch57.html "Chapter 57. DNS MESSAGING AND MESSAGE,
    RESOURCE RECORD, AND MASTER FILE FORMATS"), DNS actually uses UDP for certain
    types of communication and TCP for others.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您想了解为什么同时拥有UDP和TCP有价值，可以考虑域名系统（DNS）中的消息传输。如[第57章](ch57.html "第57章. 域名系统消息、消息、资源记录和主文件格式")所述，DNS实际上使用UDP进行某些类型的通信，而使用TCP进行其他类型的通信。
- en: Summary Comparison of UDP and TCP
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP和TCP的总结比较
- en: In the next few chapters, we will explore both UDP and TCP in further detail.
    I will help you to understand much better the strengths and drawbacks of both
    protocols. While informative, these chapters are time-consuming to read. Thus,
    for your convenience, I have included [Table 42-1](ch42s03.html#summary_comparison_of_udp_and_tcp-id001
    "Table 42-1. Summary Comparison of UDP and TCP"), which describes the most important
    attributes of both protocols and how they contrast with each other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将更详细地探讨UDP和TCP。我将帮助你更好地理解这两种协议的优缺点。虽然这些章节信息丰富，但阅读起来耗时较长。因此，为了您的方便，我包括了[表42-1](ch42s03.html#summary_comparison_of_udp_and_tcp-id001
    "表42-1. UDP和TCP的总结比较")，它描述了这两种协议最重要的属性以及它们之间的对比。
- en: Table 42-1. Summary Comparison of UDP and TCP
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表42-1. UDP和TCP的总结比较
- en: '| Characteristic/Description | UDP | TCP |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 特征/描述 | UDP | TCP |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| General Description | Simple, high-speed, low-functionality wrapper that
    interfaces applications to the network layer and does little else | Full-featured
    protocol that allows applications to send data reliably without worrying about
    network layer issues |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 一般描述 | 简单、高速、功能低下的包装器，将应用程序与网络层接口，但做不了其他事情 | 功能齐全的协议，允许应用程序可靠地发送数据，无需担心网络层问题
    |'
- en: '| Protocol Connection Setup | Connectionless; data is sent without setup |
    Connection-oriented; connection must be established prior to transmission |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 协议连接设置 | 无连接；数据发送无需设置 | 有连接；传输前必须建立连接 |'
- en: '| Data Interface to Application | Message-based; the application sends data
    in discrete packages | Stream-based; the application sends data with no particular
    structure |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 数据与应用程序的接口 | 基于消息；应用程序以离散的数据包发送数据 | 基于流；应用程序发送无特定结构的数据 |'
- en: '| Reliability and Acknowledgments | Unreliable, best-effort delivery without
    acknowledgments | Reliable delivery of messages; all data is acknowledged |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 可靠性和确认 | 不可靠，尽力交付，不进行确认 | 消息可靠交付；所有数据都得到确认 |'
- en: '| Retransmissions | Not performed; application must detect lost data and retransmit
    if needed | Delivery of all data is managed, and lost data is retransmitted automatically
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 重传 | 不执行；应用程序必须检测丢失的数据并在需要时重新传输 | 所有数据的交付都得到管理，丢失的数据会自动重传 |'
- en: '| Features Provided to Manage Flow of Data | None | Flow control using sliding
    windows; window size adjustment heuristics; congestion-avoidance algorithms |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 管理数据流的功能 | 无 | 使用滑动窗口进行流量控制；窗口大小调整启发式算法；拥塞避免算法 |'
- en: '| Overhead | Very low | Low, but higher than UDP |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 开销 | 非常低 | 低，但高于UDP |'
- en: '| Transmission Speed | Very high | High, but not as high as UDP |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 传输速度 | 非常高 | 高，但不如UDP |'
- en: '| Data Quantity Suitability | Small to moderate amounts of data (up to a few
    hundred bytes) | Small to very large amounts of data (up to a few gigabytes) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 数据量适用性 | 小到中等的数据量（多达几百字节） | 小到非常大的数据量（多达几个吉字节） |'
- en: '| Types of Applications That Use the Protocol | Applications where data delivery
    speed matters more than completeness, where small amounts of data are sent, or
    where multicast/broadcast are used | Most protocols and applications sending data
    that must be received reliably, including most file and message transfer protocols
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 使用该协议的应用类型 | 数据传输速度比完整性更重要，发送数据量较小，或使用组播/广播的应用 | 必须可靠接收的数据传输协议，包括大多数文件和消息传输协议
    |'
- en: '| Well-Known Applications and Protocols | Multimedia applications, DNS, BOOTP,
    DHCP, TFTP, SNMP, RIP, NFS (early versions) | FTP, Telnet, SMTP, DNS, HTTP, POP,
    NNTP, IMAP, BGP, IRC, NFS (later versions) |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 已知应用和协议 | 多媒体应用、DNS、BOOTP、DHCP、TFTP、SNMP、RIP、NFS（早期版本） | FTP、Telnet、SMTP、DNS、HTTP、POP、NNTP、IMAP、BGP、IRC、NFS（后期版本）
    |'
- en: 'Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第43章：TCP和UDP寻址：端口和套接字
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Internet Protocol (IP) addresses are the main form of addressing used on a TCP/IP
    network. These network layer addresses uniquely identify each network interface,
    and as such, they serve as the mechanism by which data is routed to the correct
    network on the internetwork and then to the correct device on that network.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）地址是TCP/IP网络中使用的最主要寻址形式。这些网络层地址唯一标识每个网络接口，因此，它们作为数据在互联网上正确路由到特定网络，然后到达该网络正确设备的机制。
- en: But there is an additional level of addressing that occurs at the transport
    layer in TCP/IP, above that of the IP address. Both of the TCP/IP transport protocols—the
    Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP)—use the
    concepts of *ports* and *sockets* for virtual software addressing. Ports and sockets
    enable many applications to function simultaneously on an IP device.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但在TCP/IP协议栈的传输层，存在一个额外的寻址层级，这位于IP地址之上。TCP/IP传输协议中的两个协议——传输控制协议（TCP）和用户数据报协议（UDP）——都使用*端口*和*套接字*的概念来进行虚拟软件寻址。端口和套接字使得许多应用程序能够在IP设备上同时运行。
- en: In this chapter, I describe the special mechanism used for addressing in both
    TCP and UDP. I begin with a discussion of TCP/IP application processes, including
    the client/server nature of communication, which provides a background for explaining
    how ports and sockets are used. I then give an overview of the concept of ports
    and how they enable the multiplexing of data over an IP address. I describe the
    way that port numbers are categorized in ranges and assigned to server processes
    for common applications. I explain the concept of ephemeral port numbers used
    for clients. I then discuss sockets and their use for connection identification,
    including the means by which multiple devices can talk to a single port on another
    device. I then provide a summary table of the most common registered port numbers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了TCP和UDP寻址的特殊机制。我首先讨论TCP/IP应用程序进程，包括通信的客户端/服务器特性，这为解释端口和套接字的使用提供了背景。然后，我概述了端口的概念以及它们如何使数据在IP地址上复用。我描述了端口号码如何按范围分类并分配给常见应用程序的服务器进程。我解释了用于客户端的短暂端口号码的概念。然后，我讨论了套接字及其在连接识别方面的使用，包括多个设备如何与另一设备上的单个端口通信的手段。接着，我提供了最常见的已注册端口号码的总结表。
- en: TCP/IP Processes, Multiplexing, and Client/Server Application Roles
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP进程、复用和客户端/服务器应用角色
- en: The most sensible place to start learning about how the TCP/IP protocol suite
    works is by examining IP itself, as well as the support protocols that function
    in tandem with it at the network layer. IP is the foundation upon which most of
    the rest of TCP/IP is built. It is the mechanism by which data is packaged and
    routed throughout a TCP/IP internetwork.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 了解TCP/IP协议套件如何工作的最合理起点是检查IP本身，以及在网络层与之协同工作的支持协议。IP是TCP/IP其余部分的基础。它是数据在TCP/IP互联网中打包和路由的机制。
- en: It makes sense, then, that when we examine the operation of TCP/IP from the
    perspective of IP, we talk very generically about sending and receiving datagrams.
    To the IP layer software that sends and receives IP datagrams, the higher-level
    application that datagrams come from and go to is really unimportant. To IP, a
    datagram is a datagram. All datagrams are packaged and routed in the same way,
    and IP is mainly concerned with lower-level aspects of moving them between devices
    in an efficient manner. It's important to remember, however, that this is really
    an abstraction for the convenience of describing a layer 3 operation. It doesn't
    consider how datagrams are really generated and used above layer 3.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从IP的角度检查TCP/IP的操作时，我们非常笼统地谈论发送和接收数据报。对于发送和接收IP数据报的IP层软件来说，数据报来自哪个高级应用程序以及数据报去向哪个高级应用程序实际上并不重要。对IP来说，一个数据报就是一个数据报。所有数据报都以相同的方式打包和路由，IP主要关注以高效方式在设备之间移动它们的基础层面。然而，重要的是要记住，这实际上是为了描述第三层操作而进行的抽象。它没有考虑数据报在第三层以上是如何真正生成和使用的。
- en: Layer 4 represents a transition point between the OSI model hardware-related
    layers (1, 2, and 3) and the software-related layers (5 to 7). This means that
    the TCP/IP transport layer protocols, TCP and UDP, need to pay attention to the
    way that software uses TCP/IP, even if IP really does not.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第四层代表了OSI模型中硬件相关层（1、2和3）与软件相关层（5到7）之间的一个过渡点。这意味着TCP/IP传输层协议，TCP和UDP，需要关注软件使用TCP/IP的方式，即使IP实际上并不需要这样做。
- en: Ultimately, the entire point of having networks, internetworks, and protocol
    suites like TCP/IP is to enable networking *applications*. Most Internet users
    employ these applications on a daily basis. In fact, most of us run many different
    applications simultaneously. For example, you might use a web browser to check
    the news, a File Transfer Program (FTP) client to upload some pictures to share
    with family, and an Internet Relay Chat (IRC) program to discuss something with
    a friend or colleague. In fact, it is common to have multiple instances of a single
    application. The most common example is having multiple web browser windows open
    (I sometimes find myself with as many as 30 going at one time!).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，拥有网络、互联网和像TCP/IP这样的协议套件的全部目的，是为了使网络*应用程序*能够运行。大多数互联网用户每天都在使用这些应用程序。事实上，我们中的大多数人同时运行许多不同的应用程序。例如，你可能使用网页浏览器来查看新闻，使用文件传输程序（FTP）客户端上传一些图片与家人分享，或者使用互联网中继聊天（IRC）程序与朋友或同事讨论某事。实际上，拥有多个单个应用程序的实例是很常见的。最常见的例子是同时打开多个网页浏览器窗口（我有时发现自己一次有30个窗口在运行！）。
- en: Multiplexing and Demultiplexing
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多路复用和解复用
- en: Most communication in TCP/IP takes the form of exchanges of information between
    a program running on one device and a matching program running on another device.
    Each instance of an application represents a copy of that application's software
    that needs to send and receive information. These application instances are commonly
    called *processes*. A TCP/IP application process is any piece of networking software
    that sends and receives information using the TCP/IP protocol suite. This includes
    classic end-user applications such as the ones described earlier, and support
    protocols that behave like applications when they send messages. Examples of the
    latter would include a network management protocol like the Simple Network Management
    Protocol (SNMP; see Chapters [Chapter 65](ch65.html "Chapter 65. TCP/IP INTERNET
    STANDARD MANAGEMENT FRAMEWORK OVERVIEW") through [Chapter 69](ch69.html "Chapter 69. TCP/IP
    REMOTE NETWORK MONITORING (RMON)")), or even the routing protocol Border Gateway
    Protocol (BGP; see [Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL
    (BGP/BGP-4)")), which sends messages using TCP the way an application does.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP中的大多数通信都是以一个设备上运行的程序与另一个设备上运行的匹配程序之间交换信息的形式进行的。每个应用程序实例代表该应用程序软件的一个副本，需要发送和接收信息。这些应用程序实例通常被称为*进程*。TCP/IP应用程序进程是指使用TCP/IP协议套件发送和接收信息的任何网络软件。这包括前面描述的经典终端用户应用程序，以及当它们发送消息时表现得像应用程序的支持协议。后者的例子包括像简单网络管理协议（SNMP；见第[第65章](ch65.html
    "第65章。TCP/IP互联网标准管理框架概述")至[第69章](ch69.html "第69章。TCP/IP远程网络监控（RMON)"))这样的网络管理协议，甚至发送消息的方式与应用程序相同的路由协议边界网关协议（BGP；见[第40章](ch40.html
    "第40章。边界网关协议（BGP/BGP-4)"))。
- en: So, a typical TCP/IP host has multiple processes, and each one needs to send
    and receive datagrams. All of these datagrams, however, must be sent using the
    same interface to the internetwork, using the IP layer. This means that the data
    from all applications (with some possible exceptions) is initially funneled down
    to the transport layer, where TCP or UDP handles it. From there, messages pass
    to the device's IP layer, where they are packaged in IP datagrams and sent out
    over the internetwork to different destinations. The technical term for this is
    *multiplexing*. This term simply means combining, and its use here is a software
    analog to the way multiplexing is done with signals (such as how individual telephone
    calls are packaged).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个典型的 TCP/IP 主机有多个进程，每个进程都需要发送和接收数据报。然而，所有这些数据报都必须使用相同的接口发送到互联网，使用 IP 层。这意味着所有应用的数据（可能有一些例外）最初都会被引导到传输层，在那里
    TCP 或 UDP 处理它们。从那里，消息传递到设备的 IP 层，在那里它们被封装成 IP 数据报并发送到互联网上的不同目的地。这个技术的术语是**复用**。这个术语简单意味着组合，这里的用法是软件上的复用方式（例如，如何将单个电话通话封装）的类比。
- en: A complementary mechanism is responsible for the receipt of datagrams. At the
    same time that the IP layer multiplexes datagrams to send from many application
    processes, it receives many datagrams that are intended for different processes.
    The IP layer must take this stream of unrelated datagrams and pass them to the
    correct process (through the transport layer protocol above it). This is *demultiplexing*,
    the opposite of multiplexing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一种互补机制负责接收数据报。在 IP 层将数据报复用到多个应用进程以发送的同时，它也接收许多旨在发送到不同进程的数据报。IP 层必须处理这一系列无关的数据报，并将它们传递给正确的进程（通过其上的传输层协议）。这是**分解复用**，与复用相反。
- en: You can see an illustration of the concept behind TCP/IP process multiplexing
    and demultiplexing in [Figure 43-1](ch43.html#process_multiplexing_and_demultiplexing_
    "Figure 43-1. Process multiplexing and demultiplexing in TCP/IP In a typical machine
    that is running TCP/IP, there are many different protocols and applications running
    simultaneously. This example shows four different applications communicating between
    a client and server machine. All four are multiplexed for transmission using the
    same IP software and physical connection; received data is demultiplexed and passed
    to the appropriate application. IP, TCP, and UDP provide a way of keeping the
    data from each application distinct.").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图 43-1](ch43.html#process_multiplexing_and_demultiplexing_ "图 43-1. TCP/IP
    中的进程复用和分解复用。在一个典型的运行 TCP/IP 的机器上，同时运行着许多不同的协议和应用。本例展示了四个不同的应用在客户端和服务器机器之间进行通信。所有四个应用都使用相同的
    IP 软件和物理连接进行复用传输；接收到的数据被分解复用并传递给相应的应用。IP、TCP 和 UDP 提供了一种方法，使得每个应用的数据保持独立。")中看到
    TCP/IP 进程复用和分解复用概念的解释。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP/IP is designed to allow many different applications to
    send and receive data simultaneously using the same IP software on a given device.
    To accomplish this, it is necessary to *multiplex* transmitted data from many
    sources as it is passed down to the IP layer. As a stream of IP datagrams is received,
    it is *demultiplexed* and the appropriate data passed to each application software
    instance on the receiving host.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP 被设计成允许许多不同的应用在同一台设备上使用相同的 IP 软件同时发送和接收数据。为了实现这一点，必须将来自许多源的数据在传递到
    IP 层时进行**复用**。在接收到一系列 IP 数据报的同时，它们会被**分解复用**，并将适当的数据传递给接收主机上的每个应用软件实例。'
- en: TCP/IP Client Processes and Server Processes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP 客户端进程和服务器进程
- en: TCP/IP software is generally *asymmetric*. This means that when a TCP/IP application
    process on one computer tries to talk to an application process on another computer,
    the two processes are usually not exactly the same. They are instead *complements*
    of each other, designed to function together as a team.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 软件通常是**非对称的**。这意味着当一个计算机上的 TCP/IP 应用进程试图与另一台计算机上的应用进程通信时，这两个进程通常并不完全相同。相反，它们是彼此的**补充**，设计成一起作为一个团队工作。
- en: As I explained in the overview description of TCP/IP in [Chapter 8](ch08.html
    "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE"), most networking applications
    use a *client/server* model of operation. This term can be used to refer to the
    roles of computers, where a *server* is a relatively powerful machine that provides
    services to a large number of user-operated *clients*. It also applies to software.
    In a software context, a *client process* usually runs on a client machine and
    initiates contact to perform some sort of function. A *server process* usually
    runs on a hardware server, listens for requests from clients, and responds to
    them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第8章](ch08.html "第8章。TCP/IP协议套件和架构概述")中对TCP/IP的概述描述中解释的那样，大多数网络应用都使用*客户端/服务器*模型进行操作。这个术语可以用来指代计算机的角色，其中*服务器*是一个相对强大的机器，为大量由用户操作*客户端*提供服务。它也适用于软件。在软件环境中，*客户端进程*通常运行在客户端机器上，并启动联系以执行某种功能。*服务器进程*通常运行在硬件服务器上，监听来自客户端的请求，并对它们进行响应。
- en: The classic example of this client/server operation is the World Wide Web (WWW).
    The Web uses the Hypertext Transfer Protocol (HTTP; see [Chapter 80](ch80.html
    "Chapter 80. HTTP GENERAL OPERATION AND CONNECTIONS")), which is a good example
    of an application protocol. A web browser is an HTTP client that normally runs
    on an end-user client machine. It initiates an exchange of HTTP (web) data by
    sending a request to a web (HTTP) server. A server process on that web server
    hears the request and replies either with the requested item(s)—a web page or
    other data—or an error message. The server is usually specifically designed to
    handle many incoming client requests, and in many cases, has no other use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种客户端/服务器操作的典型例子是万维网（WWW）。网络使用超文本传输协议（HTTP；见[第80章](ch80.html "第80章。HTTP一般操作和连接"))，这是一个应用协议的好例子。网络浏览器是HTTP客户端，通常运行在最终用户客户端机器上。它通过向网络（HTTP）服务器发送请求来启动HTTP（网络）数据的交换。该网络服务器上的服务器进程听到请求后，要么回复请求的项目（网页或其他数据），要么回复错误信息。服务器通常专门设计来处理大量的客户端请求，在许多情况下，没有其他用途。
- en: Why am I telling you all of this in a section that is supposed to explain TCP
    and UDP ports? I started here because many application processes run simultaneously
    and have their data multiplexed for transmission. The simultaneity of application
    processes and the multiplexing of data are the impetus for why higher-level addressing
    is a necessity in TCP/IP. The client/server arrangement used by TCP/IP has an
    important impact on the way that ports are used and the mechanisms for how they
    are assigned. The next two sections explore these concepts more completely.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要在本来应该解释TCP和UDP端口的章节中讲述这些内容？我之所以从这里开始，是因为许多应用进程是同时运行的，并且它们的数据被复用进行传输。应用进程的并发性和数据的复用是为什么在TCP/IP中高级寻址成为必要性的推动力。TCP/IP使用的客户端/服务器配置对端口的使用方式和端口分配的机制有重要影响。接下来的两个章节将更全面地探讨这些概念。
- en: '![Process multiplexing and demultiplexing in TCP/IP In a typical machine that
    is running TCP/IP, there are many different protocols and applications running
    simultaneously. This example shows four different applications communicating between
    a client and server machine. All four are multiplexed for transmission using the
    same IP software and physical connection; received data is demultiplexed and passed
    to the appropriate application. IP, TCP, and UDP provide a way of keeping the
    data from each application distinct.](httpatomoreillycomsourcenostarchimages288079.png.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP中的进程复用和解复用过程](httpatomoreillycomsourcenostarchimages288079.png.jpg)在一个典型的运行TCP/IP的机器中，同时运行着许多不同的协议和应用。这个例子展示了四个不同的应用在客户端和服务器机器之间进行通信。所有四个应用都使用相同的IP软件和物理连接进行复用传输；接收到的数据被解复用并传递到相应的应用。IP、TCP和UDP提供了一种方法，以确保每个应用的数据都是独立的。'
- en: Figure 43-1. Process multiplexing and demultiplexing in TCP/IP In a typical
    machine that is running TCP/IP, there are many different protocols and applications
    running simultaneously. This example shows four different applications communicating
    between a client and server machine. All four are multiplexed for transmission
    using the same IP software and physical connection; received data is demultiplexed
    and passed to the appropriate application. IP, TCP, and UDP provide a way of keeping
    the data from each application distinct.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图43-1. TCP/IP中的进程复用和解复用在一个典型的运行TCP/IP的机器上，同时运行着许多不同的协议和应用。此示例显示了四个不同的应用在客户端和服务器机器之间进行通信。所有四个都使用相同的IP软件和物理连接进行复用传输；接收到的数据被解复用并传递到适当的应用。IP、TCP和UDP提供了一种方法，以保持每个应用的数据独立。
- en: 'TCP/IP Ports: TCP/UDP Addressing'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP端口：TCP/UDP寻址
- en: A typical host on a TCP/IP internetwork has many different software application
    processes running concurrently. Each process generates data that it sends to either
    TCP or UDP, which then passes it to IP for transmission. The IP layer sends out
    this multiplexed stream of datagrams to various destinations. Simultaneously,
    each device's IP layer is receiving datagrams that originated in numerous application
    processes on other hosts. These datagrams need to be demultiplexed so that they
    end up at the correct process on the device that receives them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP/IP互联网中，一个典型主机上同时运行着许多不同的软件应用进程。每个进程生成数据，并将其发送到TCP或UDP，然后由IP层进行传输。IP层将这个复用数据报流发送到不同的目的地。同时，每个设备的IP层正在接收来自其他主机上多个应用进程的数据报。这些数据报需要被解复用，以便它们最终到达接收它们的设备上的正确进程。
- en: Multiplexing and Demultiplexing Using Ports
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用端口进行复用和解复用
- en: The question is how do we demultiplex a sequence of IP datagrams that need to
    go to many different application processes? Let's consider a particular host with
    a single network interface bearing the IP address 24.156.79.20\. Normally, every
    datagram received by the IP layer will have this value in the IP Destination Address
    field. The consecutive datagrams that IP receives may contain a piece of a file
    you are downloading with your web browser, an email your brother sent to you,
    and a line of text a buddy wrote in an IRC chat channel. How does the IP layer
    know which datagrams go where if they all have the same IP address?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们如何解复用一系列需要发送到许多不同应用进程的IP数据报？让我们考虑一个具有单个网络接口并带有IP地址24.156.79.20的主机。通常，IP层接收到的每个数据报都将在此IP目标地址字段中包含此值。IP层接收到的连续数据报可能包含您使用网络浏览器下载的文件的一部分，您兄弟发给您的电子邮件，以及一个在IRC聊天频道中写下的朋友的一行文本。如果它们都具有相同的IP地址，IP层如何知道哪些数据报该去哪里？
- en: The first part of the answer lies in the Protocol field included in the header
    of each IP datagram. This field carries a code that identifies the protocol that
    sent the data in the datagram to IP. Since most end-user applications use TCP
    or UDP at the transport layer, the Protocol field in a received datagram tells
    IP to pass data to either TCP or UDP as appropriate. Of course, this just defers
    the problem to the transport layer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 答案的第一部分在于每个IP数据报头部中包含的协议字段。该字段携带一个代码，用于标识将数据报中的数据发送到IP的协议。由于大多数最终用户应用在传输层使用TCP或UDP，因此接收到的数据报中的协议字段告诉IP根据需要将数据传递给TCP或UDP。当然，这仅仅是将问题推迟到了传输层。
- en: Many applications use both TCP and UDP at once. This means that TCP or UDP must
    figure out which process to send the data to. To make this possible, an additional
    addressing element is necessary. This address allows a more specific location—a
    software process—to be identified within a particular IP address. In TCP/IP, this
    transport layer address is called a *port*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用同时使用TCP和UDP。这意味着TCP或UDP必须确定将数据发送到哪个进程。为了实现这一点，需要额外的寻址元素。此地址允许在特定的IP地址内识别一个更具体的地址——一个软件进程。在TCP/IP中，这个传输层地址被称为*端口*。
- en: Source Port and Destination Port Numbers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源端口和目标端口号码
- en: 'In UDP and TCP messages two addressing fields appear: a *source port* and a
    *destination port*. These are analogous to the source address and destination
    address fields at the IP level, but at a higher level of detail. They identify
    the originating process on the source machine and the destination process on the
    destination machine. The TCP or UDP software fills them in before transmission,
    and they direct the data to the correct process on the destination device.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在UDP和TCP消息中，出现了两个地址字段：一个*源端口*和一个*目的端口*。这些字段与IP层上的源地址和目的地址字段类似，但更详细。它们标识了源机器上的发起进程和目标机器上的目标进程。TCP或UDP软件在传输之前填充这些字段，并将数据引导到目标设备上的正确进程。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The term* port *has many meanings aside from this one in TCP/IP. For example,
    a physical outlet in a network device is often called a* port. *Usually, you can
    discern whether the port in question refers to a hardware port or a software port
    from the context*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*“端口”这个词除了在TCP/IP中的这个含义之外，还有许多其他含义。例如，网络设备中的物理出口通常被称为端口。* 通常，你可以从上下文中判断所讨论的端口是指硬件端口还是软件端口。'
- en: TCP and UDP port numbers are 16 bits in length. Valid port numbers can theoretically
    take on values from 0 to 65,535\. As you will see in the next section, these values
    are divided into ranges for different purposes, with certain ports reserved for
    particular uses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP端口号的长度为16位。有效的端口号理论上可以取从0到65,535的值。你将在下一节中看到，这些值被划分为不同的范围，用于不同的目的，某些端口被保留用于特定的用途。
- en: One fact that is sometimes a bit confusing is that both UDP and TCP use the
    same range of port numbers, but they are independent. In theory, it is possible
    for UDP port number 77 to refer to one application process and TCP port number
    77 to refer to an entirely different one. There is no ambiguity, at least to the
    computers, because as mentioned earlier, each IP datagram contains a Protocol
    field that specifies whether it is carrying a TCP message or a UDP message. IP
    passes the datagram to either TCP or UDP, which sends the message on to the right
    process using the port number in the TCP or UDP header. This mechanism is illustrated
    in [Figure 43-2](ch43s02.html#tcpip_process_multiplexingdemultiplexing "Figure 43-2. TCP/IP
    process multiplexing/demultiplexing using TCP/UDP ports A more concrete version
    of Figure 43-1, this figure shows how TCP and UDP ports accomplish software multiplexing
    and demultiplexing. Again there are four different TCP/IP applications communicating,
    but this time I am showing only the traffic going from the client to the server.
    Two of the applications use TCP, and two use UDP. Each application on the client
    sends messages using a specific TCP or UDP port number. The server's UDP or TCP
    software uses these port numbers to pass the datagrams to the appropriate application
    process.").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候可能会有些令人困惑的一个事实是，UDP和TCP都使用相同的端口号范围，但它们是独立的。从理论上讲，UDP端口号77可以指代一个应用程序进程，而TCP端口号77可以指代一个完全不同的进程。至少对于计算机来说，这没有歧义，因为如前所述，每个IP数据报都包含一个协议字段，用于指定它携带的是TCP消息还是UDP消息。IP将数据报传递给TCP或UDP，然后使用TCP或UDP头中的端口号将消息发送到正确的进程。这一机制在[图43-2](ch43s02.html#tcpip_process_multiplexingdemultiplexing
    "图43-2. 使用TCP/UDP端口的TCP/IP进程复用/解复用，这是图43-1的一个更具体的版本，展示了TCP和UDP端口如何实现软件复用和解复用。再次有四个不同的TCP/IP应用程序在进行通信，但这次我只展示了从客户端到服务器的流量。其中两个应用程序使用TCP，另外两个使用UDP。客户端上的每个应用程序都使用特定的TCP或UDP端口号发送消息。服务器上的UDP或TCP软件使用这些端口号将数据报传递给适当的应用程序进程。")中得到了说明。
- en: '![TCP/IP process multiplexing/demultiplexing using TCP/UDP ports A more concrete
    version of , this figure shows how TCP and UDP ports accomplish software multiplexing
    and demultiplexing. Again there are four different TCP/IP applications communicating,
    but this time I am showing only the traffic going from the client to the server.
    Two of the applications use TCP, and two use UDP. Each application on the client
    sends messages using a specific TCP or UDP port number. The server''s UDP or TCP
    software uses these port numbers to pass the datagrams to the appropriate application
    process.](httpatomoreillycomsourcenostarchimages288081.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP进程复用/解复用使用TCP/UDP端口，这是图43-1的一个更具体的版本，展示了TCP和UDP端口如何实现软件复用和解复用。再次有四个不同的TCP/IP应用程序在进行通信，但这次我只展示了从客户端到服务器的流量。其中两个应用程序使用TCP，另外两个使用UDP。客户端上的每个应用程序都使用特定的TCP或UDP端口号发送消息。服务器上的UDP或TCP软件使用这些端口号将数据报传递给适当的应用程序进程。](httpatomoreillycomsourcenostarchimages288081.png.jpg)'
- en: Figure 43-2. TCP/IP process multiplexing/demultiplexing using TCP/UDP ports
    A more concrete version of [Figure 43-1](ch43.html#process_multiplexing_and_demultiplexing_
    "Figure 43-1. Process multiplexing and demultiplexing in TCP/IP In a typical machine
    that is running TCP/IP, there are many different protocols and applications running
    simultaneously. This example shows four different applications communicating between
    a client and server machine. All four are multiplexed for transmission using the
    same IP software and physical connection; received data is demultiplexed and passed
    to the appropriate application. IP, TCP, and UDP provide a way of keeping the
    data from each application distinct."), this figure shows how TCP and UDP ports
    accomplish software multiplexing and demultiplexing. Again there are four different
    TCP/IP applications communicating, but this time I am showing only the traffic
    going from the client to the server. Two of the applications use TCP, and two
    use UDP. Each application on the client sends messages using a specific TCP or
    UDP port number. The server's UDP or TCP software uses these port numbers to pass
    the datagrams to the appropriate application process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图43-2. 使用TCP/UDP端口的TCP/IP进程多路复用/解复用 本图是[图43-1](ch43.html#process_multiplexing_and_demultiplexing_
    "图43-1. TCP/IP中的进程多路复用和解复用 在一个典型的运行TCP/IP的机器上，同时运行着许多不同的协议和应用。本例展示了四个不同的应用程序在客户端和服务器机器之间进行通信。所有四个都使用相同的IP软件和物理连接进行多路复用传输；接收到的数据被解复用并传递给相应的应用程序。IP、TCP和UDP提供了一种方法，以保持每个应用程序的数据独立。")的一个更具体版本，展示了TCP和UDP端口如何实现软件多路复用和解复用。再次，有四个不同的TCP/IP应用程序在进行通信，但这次我只展示了从客户端到服务器的流量。其中两个应用程序使用TCP，另外两个使用UDP。客户端上的每个应用程序都使用特定的TCP或UDP端口号发送消息。服务器上的UDP或TCP软件使用这些端口号将数据报传递给适当的应用程序进程。
- en: In practice, having TCP and UDP use different port numbers is confusing, especially
    for the reserved port numbers that common applications use. To avoid confusion,
    by convention, most reserved port numbers are reserved for both TCP and UDP. For
    example, port 80 is reserved for HTTP for both TCP and UDP, even though HTTP only
    uses TCP. We'll examine this in greater detail in the following section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，TCP和UDP使用不同的端口号可能会造成混淆，尤其是对于常用应用程序使用的保留端口号。为了避免混淆，按照惯例，大多数保留端口号都为TCP和UDP保留。例如，端口80为HTTP保留，用于TCP和UDP，尽管HTTP只使用TCP。我们将在下一节中更详细地探讨这一点。
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP/IP transport layer addressing is accomplished by using
    TCP and UDP *ports*. Each port number within a particular IP device identifies
    a particular software process.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP传输层地址是通过使用TCP和UDP *端口* 来实现的。特定IP设备内的每个端口号标识一个特定的软件进程。'
- en: Summary of Port Use for Datagram Transmission and Reception
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据报传输和接收端口使用总结
- en: 'Here''s how transport layer addressing (port addressing) works in TCP and UDP:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在TCP和UDP中实现传输层地址（端口地址）的：
- en: '**Sending Datagrams** An application specifies the source and destination port
    it wishes to use for the communication. The port numbers are encoded into the
    TCP or UDP header, depending on which transport layer protocol the application
    is using. When TCP or UDP passes data to IP, IP indicates the protocol type that''s
    appropriate for TCP or UDP in the Protocol field of the IP datagram. The source
    and destination port numbers are encapsulated as part of the TCP or UDP message,
    within the IP datagram''s data area.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送数据报** 应用程序指定它希望用于通信的源端口和目标端口。端口号被编码到TCP或UDP头部，具体取决于应用程序使用的传输层协议。当TCP或UDP将数据传递给IP时，IP在IP数据报的协议字段中指示适用于TCP或UDP的协议类型。源端口和目标端口作为TCP或UDP消息的一部分封装在IP数据报的数据区域中。'
- en: '**Receiving Datagrams** The IP software receives the datagram, inspects the
    Protocol field, and decides which protocol the datagram belongs to (in this case,
    TCP or UDP). TCP or UDP receives the datagram and passes its contents to the appropriate
    process based on the destination port number.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收数据报** IP软件接收数据报，检查协议字段，并决定数据报属于哪个协议（在这种情况下，是TCP或UDP）。TCP或UDP接收数据报，并根据目标端口号将其内容传递给适当的过程。'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Application process multiplexing and demultiplexing in TCP/IP
    is implemented using the IP Protocol field and the UDP/TCP Source Port and Destination
    Port fields. Upon transmission, the Protocol field is given a number to indicate
    whether TCP or UDP was used, and the port numbers are filled in to indicate the
    sending and receiving software process. The device receiving the datagram uses
    the Protocol field to determine whether TCP or UDP was used and then passes the
    data to the software process that the destination port number indicates.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP中应用程序进程的多路复用和解复用是通过IP协议字段以及UDP/TCP源端口和目标端口字段实现的。在传输过程中，协议字段被赋予一个数字来指示是否使用了TCP或UDP，端口数字被填充以指示发送和接收的软件进程。接收数据报的设备使用协议字段来确定是否使用了TCP或UDP，然后将数据传递给目标端口号指示的软件进程。'
- en: TCP/IP Application Assignments and Server Port Number Ranges
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP应用程序分配和服务器端口号范围
- en: The port numbers I just discussed provide a method of transport layer addressing
    that allows many applications to use TCP and UDP simultaneously. By specifying
    the appropriate destination port number, an application sending data can be sure
    that the right process on the destination device will receive the message. Unfortunately,
    there's still a problem to be solved.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才讨论的端口号提供了一种传输层寻址方法，允许许多应用程序同时使用TCP和UDP。通过指定适当的目标端口号，发送数据的程序可以确保目标设备上的正确进程将接收消息。不幸的是，仍然有一个问题需要解决。
- en: Let's go back to using the World Wide Web. You fire up a web browser, which
    is client software that sends requests using HTTP. You need to know the IP address
    of the website you want to access, or you may have the Domain Name System (DNS)
    supply the IP address to you automatically. Once you have the address, the web
    browser can generate an HTTP message and send it to the website's IP address.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到使用万维网。你打开一个网页浏览器，这是一个客户端软件，它使用HTTP发送请求。你需要知道你想要访问的网站的IP地址，或者你可能让域名系统（DNS）自动为你提供IP地址。一旦你有了地址，网页浏览器就可以生成一个HTTP消息并将其发送到网站的IP地址。
- en: This HTTP message is intended for the web server process on the site you are
    trying to reach. The problem is how does the web browser (client process) know
    which port number has been assigned to the server process on the website? Port
    numbers can range from 0 to 65535, which means a lot of choices. And, in theory,
    every website could assign a different port number to its web server process.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTTP消息是为了发送到你试图访问的网站上的Web服务器进程。问题是网页浏览器（客户端进程）如何知道分配给网站服务器进程的端口号？端口号的范围从0到65535，这意味着有很多选择。而且，从理论上讲，每个网站都可以为其Web服务器进程分配不同的端口号。
- en: 'There are a couple of different ways to resolve this problem. TCP/IP takes
    what is probably the simplest possible approach: It *reserves* certain port numbers
    for particular applications.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的方法可以解决这个问题。TCP/IP采取了可能是最简单的方法：它为特定应用程序*保留*了某些端口号。
- en: Reserved Port Numbers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留端口号
- en: Server processes, which listen for requests for that application and then respond
    to them, assign each common application a specific port number. To avoid chaos,
    the software that implements a particular server process normally uses the same
    reserved port number on every IP device so that clients can find it easily.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 监听该应用程序请求并对其做出响应的服务器进程为每个常见应用程序分配一个特定的端口号。为了避免混乱，实现特定服务器进程的软件通常在每台IP设备上使用相同的保留端口号，以便客户端可以轻松找到它。
- en: In the example of accessing a website with a web browser, the reserved port
    number for HTTP is 80\. Every web browser knows that web designers design websites
    to listen for requests sent to port 80\. The web browser will thus use this value
    in requests to ensure that the IP and TCP software on the web browser directs
    these HTTP messages to the web server software. It is possible for a particular
    web server to use a different port number, but in this case, the web server must
    inform the user of this number somehow, and must explicitly tell the web browser
    to use it instead of the default port number (80).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用网页浏览器访问网站的例子中，HTTP保留的端口号是80。每个网页浏览器都知道，网页设计者设计网站是为了监听发送到端口80的请求。因此，网页浏览器将使用这个值在请求中，以确保网页浏览器的IP和TCP软件将HTTP消息直接导向Web服务器软件。虽然特定的Web服务器可以使用不同的端口号，但在此情况下，Web服务器必须以某种方式通知用户这个数字，并且必须明确告诉网页浏览器使用它而不是默认端口号（80）。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To allow client devices to establish connections to TCP/IP
    servers more easily, server processes for common applications use universal server
    port numbers. Clients are preprogrammed to know to use the port numbers by default.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了使客户端设备更容易建立到 TCP/IP 服务器的连接，常见应用程序的服务器进程使用通用服务器端口号。客户端预先编程，默认使用这些端口号。'
- en: 'In order for this system to work well, universal agreement on port assignments
    is essential. Thus, this becomes another situation where a central authority is
    needed to manage a list of port assignments that everyone uses. For TCP/IP, it
    is the same authority responsible for the assignment and coordination of other
    centrally managed numbers, including IP addresses, IP protocol numbers, and so
    forth: the Internet Assigned Numbers Authority (IANA; see [Chapter 3](ch03.html
    "Chapter 3. NETWORK STANDARDS AND STANDARDS ORGANIZATIONS")).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个系统运行良好，对端口号分配的普遍同意是必不可少的。因此，这又是一个需要中央权威机构来管理大家使用的端口号分配列表的情况。对于 TCP/IP 来说，负责分配和协调其他集中管理数字的同一权威机构负责这项工作，包括
    IP 地址、IP 协议号等：互联网数字分配机构（IANA；见[第 3 章](ch03.html "第 3 章. 网络标准和标准组织")）。
- en: TCP/UDP Port Number Ranges
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/UDP 端口号范围
- en: 'As you have seen, there are 65,536 port numbers that can be used for processes.
    But there are also a fairly large number of TCP/IP applications, and the list
    grows every year. IANA needs to carefully manage the port number address space
    in order to ensure that port numbers are not wasted on protocols that won''t be
    widely used. IANA also needs to provide flexibility for organizations that must
    make use of obscure applications. To this end, the full spectrum of TCP and UDP
    port numbers is divided into three ranges:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有 65,536 个端口号可用于进程。但也有相当多的 TCP/IP 应用程序，并且这个列表每年都在增长。IANA 需要仔细管理端口号地址空间，以确保端口号不会被浪费在不会广泛使用的协议上。同时，IANA
    还需要为必须使用不为人知的组织提供灵活性。为此，TCP 和 UDP 的全部端口号范围被划分为三个范围：
- en: '**Well-Known (Privileged) Port Numbers (0 to 1023)** IANA manages these port
    numbers and reserves them for only the most universal TCP/IP applications. The
    IANA assigns these port numbers only to protocols that have been standardized
    using the TCP/IP RFC process, protocols that are in the process of being standardized,
    or protocols that are likely to be standardized in the future. On most computers,
    only server processes run by system administrators or privileged users use these
    port numbers. These processes generally correspond to processes that implement
    key IP applications, such as web servers, FTP servers, and the like. For this
    reason, these processes are sometimes called *system port numbers*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**已知（特权）端口号（0 到 1023）** IANA 管理这些端口号，并将它们仅保留给最通用的 TCP/IP 应用程序。IANA 只将这些端口号分配给使用
    TCP/IP RFC 流程标准化的协议，正在标准化过程中的协议，或预计未来可能标准化的协议。在大多数计算机上，只有由系统管理员或特权用户运行的服务器进程使用这些端口号。这些进程通常对应于实现关键
    IP 应用程序的进程，例如 Web 服务器、FTP 服务器等。因此，这些进程有时被称为 *系统端口号*。'
- en: '**Registered (User) Port Numbers (1024 to 49151)** There are many applications
    that need to use TCP/IP, but are not specified in RFCs or are not as universally
    used as other applications, so they do not warrant a worldwide well-known port
    number. To ensure that these various applications do not conflict with each other,
    IANA uses the bulk of the overall port number range for registered port numbers.
    Anyone who creates a viable TCP/IP server application can request to reserve one
    of these port numbers, and if the request is approved, the IANA will register
    that port number and assign it to the application. Any user on a system can generally
    access registered port numbers; thus they are sometimes called *user port numbers*.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**已注册（用户）端口号（1024 到 49151）** 许多需要使用 TCP/IP 的应用程序没有在 RFC 中指定，或者不像其他应用程序那样被普遍使用，因此它们不配拥有全球知名的端口号。为了确保这些不同的应用程序之间不会相互冲突，IANA
    使用了大部分端口号范围作为已注册端口号。任何创建可行的 TCP/IP 服务器应用程序的人都可以请求预留这些端口号之一，如果请求得到批准，IANA 将注册该端口号并将其分配给该应用程序。系统上的任何用户通常都可以访问已注册端口号；因此，它们有时被称为
    *用户端口号*。'
- en: '**Private/Dynamic Port Numbers (49152 to 65535)** IANA neither reserves nor
    maintains these ports. Anyone can use them for any purpose without registration,
    so they are appropriate for a private protocol that only a particular organization
    uses.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有/动态端口号（49152到65535）** IANA既不保留也不维护这些端口。任何人都可以在不注册的情况下用于任何目的，因此它们适用于仅由特定组织使用的私有协议。'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IANA manages port-number assignments to ensure universal compatibility
    around the global Internet. The numbers are divided into three ranges: well-known
    port numbers used for the most common applications, registered port numbers for
    other applications, and private/dynamic port numbers that can be used without
    IANA registration.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IANA管理端口号分配以确保全球互联网的通用兼容性。这些数字分为三个范围：用于最常见应用的知名端口号，用于其他应用的注册端口号，以及无需IANA注册即可使用的私有/动态端口号。'
- en: Use of these ranges ensures that there will be universal agreement on how to
    access a server process for the most common TCP/IP protocols. They also allow
    flexibility for special applications. Most of the TCP/IP applications and application
    protocols use numbers in the well-known port number range for their servers. These
    port numbers are not generally used for client processes, but there are some exceptions.
    For example, port 68 is reserved for a client using the Bootstrap Protocol (BOOTP)
    or Dynamic Host Configuration Protocol (DHCP).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些范围确保了在如何访问最常见TCP/IP协议的服务器进程方面将达成全球共识。它们还允许特殊应用有灵活性。大多数TCP/IP应用和应用协议使用知名端口号范围中的数字作为其服务器的端口号。这些端口号通常不用于客户端进程，但也有一些例外。例如，端口号68保留用于使用引导协议（BOOTP）或动态主机配置协议（DHCP）的客户端。
- en: TCP/IP Client (Ephemeral) Ports and Client/Server Application Port Use
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP客户端（短暂）端口和客户端/服务器应用端口使用
- en: The significance of the asymmetry between clients and servers in TCP/IP becomes
    evident when you examine in detail how port numbers are used. Since clients initiate
    application data transfers using TCP and UDP, they need to know the port number
    of the server process. Consequently, servers are required to use universally known
    port numbers. Thus, well-known and registered port numbers identify server processes.
    Clients that send requests use the well-known or registered port number as the
    destination port number.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细检查端口号的使用时，TCP/IP中客户端和服务器之间的不对称性变得明显。由于客户端使用TCP和UDP来初始化应用数据传输，因此它们需要知道服务器进程的端口号。因此，服务器需要使用普遍知晓的端口号。因此，知名和注册的端口号用于标识服务器进程。发送请求的客户端使用知名或注册的端口号作为目标端口号。
- en: In contrast, servers respond to clients; they do not initiate contact with them.
    Thus, the client doesn't need to use a reserved port number. In fact, this is
    really an understatement. A server shouldn't use a well-known or registered port
    number to send responses back to clients because it is possible for a particular
    device to have client and server software from the same protocol running on the
    same machine. If a server received an HTTP request on port 80 of its machine and
    sent the reply back to port 80 on the client machine, the server would be sending
    the reply to the client machine's HTTP server process (if present), rather than
    the client process that sent the initial request.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，服务器响应客户端；它们不会主动与他们接触。因此，客户端不需要使用保留端口号。实际上，这真的是一种低估。服务器不应该使用知名或注册的端口号来向客户端发送响应，因为有可能同一台机器上运行着同一协议的客户端和服务器软件。如果服务器在其机器的80端口上收到HTTP请求，并将回复发送回客户端机器的80端口，那么服务器就会将回复发送到客户端机器上的HTTP服务器进程（如果存在），而不是发送给发送初始请求的客户端进程。
- en: To know where to send the reply, the server must know the port number the client
    is using. The client supplies the port number as the *source port* in the request,
    and then the server uses the source port as the destination port to send the reply.
    Client processes don't use well-known or registered ports. Instead, each client
    process is assigned a temporary port number for its use. This is commonly called
    an *ephemeral port number*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道将回复发送到哪里，服务器必须知道客户端正在使用的端口号。客户端在请求中将端口号作为*源端口号*提供，然后服务器使用源端口号作为目标端口号来发送回复。客户端进程不使用知名或注册端口。相反，每个客户端进程都会为其分配一个临时端口号供其使用。这通常被称为*短暂端口号*。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Your $10 word for the day:* ephemeral: *"short-lived; existing or continuing
    for a short time only." — Webster''s Revised Unabridged Dictionary*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*今日10词:* 临时：*"短暂存在的；仅存在或持续很短的时间。" ——韦伯斯特修订版无删节词典*。'
- en: Ephemeral Port Number Assignment
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时端口号分配
- en: The TCP/IP software assigns ephemeral port numbers as needed to processes. Obviously,
    each client process that's running concurrently needs to use a unique ephemeral
    port number, so the TCP and UDP layers must keep track of which ones are in use.
    The TCP/IP software generally assigns these port numbers in a *pseudo-random*
    manner from a reserved pool of numbers. I say pseudo-random because there is no
    specific meaning to an ephemeral port number that is assigned to a process, so
    the TCP/IP software could select a random one for each client process. However,
    since it is necessary to reuse the port numbers in this pool over time, many implementations
    use a set of rules to minimize the chance of confusion due to reuse.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP软件根据需要将临时端口号分配给进程。显然，每个同时运行的客户端进程都需要使用一个唯一的临时端口号，因此TCP和UDP层必须跟踪哪些端口号正在使用中。TCP/IP软件通常以伪随机方式从预留的数字池中分配这些端口号。我之所以说伪随机，是因为分配给进程的临时端口号没有特定的意义，因此TCP/IP软件可以为每个客户端进程选择一个随机的端口号。然而，由于需要随着时间的推移重复使用这个池中的端口号，许多实现使用一套规则来最小化由于重复使用而造成的混淆。
- en: Consider a client process that used only ephemeral port number 4121 to send
    a request. The client process received a reply and then terminated. Suppose you
    immediately reallocate 4121 to some other process. However, the prior user of
    port 4121 accesses the server, which for some reason sends an extra reply. The
    reply would go to the new process, thereby creating confusion. To avoid this,
    it is wise to wait as long as possible before reusing port number 4121 for another
    client process. Some implementations will therefore cycle through the port numbers
    in order to ensure that the maximum amount of time elapses between consecutive
    uses of the same ephemeral port number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个仅使用临时端口号4121发送请求的客户端进程。客户端进程收到回复后终止。假设你立即将4121重新分配给其他进程。然而，先前使用端口号4121的用户访问服务器，由于某种原因，服务器发送了额外的回复。这个回复将发送到新的进程，从而造成混淆。为了避免这种情况，最好尽可能等待一段时间后再将端口号4121重新用于另一个客户端进程。因此，一些实现会循环使用端口号，以确保在连续使用相同的临时端口号之间有尽可能长的时间间隔。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Well-known and registered port numbers are needed for server
    processes since a client must know the server''s port number to initiate contact.
    On the other hand, client processes can use any port number. Each time a client
    process initiates a UDP or TCP communication, the TCP/IP software assigns it a
    temporary, or *ephemeral*, port number to use for that conversation. The TCP/IP
    software assigns these port numbers in a pseudo-random way because the exact number
    that the software uses is not important as long as each process has a different
    number.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 对于服务器进程来说，需要已知的和注册的端口号，因为客户端必须知道服务器的端口号才能发起联系。另一方面，客户端进程可以使用任何端口号。每次客户端进程发起UDP或TCP通信时，TCP/IP软件都会为其分配一个临时或*临时*端口号，用于那次对话。TCP/IP软件以伪随机方式分配这些端口号，因为软件使用的确切数字并不重要，只要每个进程有不同的数字即可。'
- en: Ephemeral Port Number Ranges
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时端口号范围
- en: The range of port numbers that TCP/IP software uses for ephemeral ports on a
    device also depends on the implementation. The TCP/IP implementation in Berkeley
    Standard Distribution (BSD) UNIX established the classic ephemeral port range.
    BSD UNIX defined it as 1024 to 4999, thereby providing 3,976 ephemeral ports.
    This seems like a very large number, and it is indeed usually more than enough
    for a typical client. However, the size of this number can be deceiving. Many
    applications use more than one process, and it is theoretically possible to run
    out of ephemeral port numbers on a very busy IP device. For this reason, most
    of the time, the ephemeral port number range can be changed. The default range
    may be different for other operating systems.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP软件在设备上用于临时端口号的端口号范围也取决于实现。伯克利标准分布（BSD）UNIX中的TCP/IP实现确立了经典的临时端口号范围。BSD
    UNIX将其定义为1024到4999，从而提供了3,976个临时端口号。这似乎是一个非常大的数字，实际上通常对于典型的客户端来说已经足够了。然而，这个数字的大小可能会误导。许多应用程序使用多个进程，理论上在非常繁忙的IP设备上可能会耗尽临时端口号。因此，大多数情况下，临时端口号的范围可以更改。默认范围可能因其他操作系统而异。
- en: Just as well-known and registered port numbers are used for server processes,
    ephemeral port numbers are for client processes only. This means that the use
    of a range of addresses from 1024 to 4999 does not conflict with the use of that
    same range for registered port numbers. I discussed this in the previous section,
    "Ephemeral Port Number Assignment."
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像众所周知并注册的端口号用于服务器进程一样，临时端口号仅用于客户端进程。这意味着从1024到4999的地址范围的使用不会与该范围用于注册端口号的使用发生冲突。我在上一节“临时端口号分配”中讨论了这一点。
- en: Port Number Use During a Client/Server Exchange
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器交换期间的端口号使用
- en: Now let's return to the matter of client/server application message exchange.
    Once a client is assigned an ephemeral port number, that port number is used as
    the source port in the client's request TCP/UDP message. The server receives the
    request and then generates a reply. In forming this response message, the server
    *swaps* the source and destination port numbers, just as it does the source and
    destination IP addresses. So the server's reply is sent from the well-known or
    registered port number on the server process back to the ephemeral port number
    on the client machine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到客户端/服务器应用程序消息交换的问题。一旦客户端分配了一个临时端口号，该端口号就用作客户端请求TCP/UDP消息中的源端口。服务器接收请求并生成一个回复。在形成这个响应消息时，服务器*交换*源端口号和目标端口号，就像它交换源和目标IP地址一样。因此，服务器的回复是从服务器进程的已知或注册端口号发送回客户端机器上的临时端口号。
- en: Now back to the web browser example. The web browser, with IP address 177.41.72.6,
    wants to send an HTTP request to a particular website at IP address 41.199.222.3\.
    The TCP/IP software sends the HTTP request with a *destination port* number of
    80 (the one reserved for HTTP servers). The TCP/IP software allocates the *source
    port* number from a pool of ephemeral ports; let's say it's port 3022\. When the
    HTTP request arrives at the web server, it is conveyed to port 80 where the HTTP
    server receives it. That process generates a reply and sends it back to 177.41.72.6,
    using *destination port* 3022 and *source port* 80\. The two processes can exchange
    information back and forth each time the TCP/IP software swaps the source port
    number and destination port number along with the source and destination IP addresses.
    This example is illustrated in [Figure 43-3](ch43s04.html#tcpip_clientserver_application_port_mech
    "Figure 43-3. TCP/IP client/server application port mechanics This highly simplified
    example shows how clients and servers use port numbers for a request.reply exchange.
    The client is making an HTTP request and sends it to the server at HTTP's well-known
    port number, 80\. Its port number for this exchange is the pseudo-randomly selected
    port 3022\. The server sends its reply back to that port number, which it reads
    from the request.").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到网页浏览器的例子。具有IP地址177.41.72.6的网页浏览器想要向IP地址为41.199.222.3的特定网站发送HTTP请求。TCP/IP软件使用*目标端口*号80（为HTTP服务器保留的端口）发送HTTP请求。TCP/IP软件从临时端口池中分配*源端口*号；假设它是端口3022。当HTTP请求到达Web服务器时，它被传递到端口80，HTTP服务器接收它。这个过程生成一个回复并发送回IP地址177.41.72.6，使用*目标端口*3022和*源端口*80。每当TCP/IP软件交换源端口号和目标端口号以及源和目标IP地址时，这两个进程就可以来回交换信息。这个例子在[图43-3](ch43s04.html#tcpip_clientserver_application_port_mech
    "图43-3. TCP/IP客户端/服务器应用程序端口机制 这个高度简化的例子展示了客户端和服务器如何使用端口号进行请求/回复交换。客户端正在发送HTTP请求，并将其发送到HTTP的已知端口80。它的这个交换的端口号是伪随机选择的端口3022。服务器将其回复发送回该端口号，它从请求中读取该端口号。")中有说明。
- en: '![TCP/IP client/server application port mechanics This highly simplified example
    shows how clients and servers use port numbers for a request.reply exchange. The
    client is making an HTTP request and sends it to the server at HTTP''s well-known
    port number, 80\. Its port number for this exchange is the pseudo-randomly selected
    port 3022\. The server sends its reply back to that port number, which it reads
    from the request.](httpatomoreillycomsourcenostarchimages288083.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![TCP/IP客户端/服务器应用程序端口机制 这个高度简化的例子展示了客户端和服务器如何使用端口号进行请求/回复交换。客户端正在发送HTTP请求，并将其发送到HTTP的已知端口80。它的这个交换的端口号是伪随机选择的端口3022。服务器将其回复发送回该端口号，它从请求中读取该端口号。](httpatomoreillycomsourcenostarchimages288083.png.jpg)'
- en: Figure 43-3. TCP/IP client/server application port mechanics This highly simplified
    example shows how clients and servers use port numbers for a request.reply exchange.
    The client is making an HTTP request and sends it to the server at HTTP's well-known
    port number, 80\. Its port number for this exchange is the pseudo-randomly selected
    port 3022\. The server sends its reply back to that port number, which it reads
    from the request.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图43-3. TCP/IP客户端/服务器应用程序端口机制 这个高度简化的例子展示了客户端和服务器如何使用端口号进行请求/回复交换。客户端正在发送一个HTTP请求，并将其发送到HTTP的已知端口号80。此交换的端口号是伪随机选择的3022。服务器将其回复发送回该端口号，该端口号是从请求中读取的。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** In most TCP/IP client/server communications, the client uses
    a random ephemeral port number and sends a request to the appropriate reserved
    port number at the server''s IP address. The server sends its reply back to whatever
    port number it finds in the Source Port field of the request.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在大多数TCP/IP客户端/服务器通信中，客户端使用一个随机的临时端口号，并向服务器IP地址上的适当保留端口号发送请求。服务器将其回复发送回请求源端口号字段中找到的任何端口号。'
- en: 'TCP/IP Sockets and Socket Pairs: Process and Connection Identification'
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP套接字和套接字对：进程和连接标识
- en: In this chapter, I have discussed the key difference between addressing at the
    level of IP and addressing with regard to application processes. To summarize,
    at layer 3 an IP address is all that is really important for properly transmitting
    data between IP devices. In contrast, application protocols must be concerned
    with the port assigned to each instance of the application so that the protocols
    can properly use TCP or UDP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了在IP层和应用进程层面地址之间的关键区别。总结来说，在第3层，IP地址对于在IP设备之间正确传输数据来说至关重要。相比之下，应用协议必须关注分配给每个应用程序实例的端口号，以便协议可以正确使用TCP或UDP。
- en: So, the overall identification of an application process actually uses the combination
    of the IP address of the host it runs on—or the network interface over which it
    is talking, to be more precise—and the port number that has been assigned to it.
    This combined address is called a *socket*. Sockets are specified using the notation
    <*IP Address*>:<*Port Number*>. For example, if you have a website running on
    IP address 41.199.222.3, the socket corresponding to the HTTP server for that
    site would be *41.199.222.3:80*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个应用程序过程的整体标识实际上使用的是它在运行的宿主机的IP地址——或者更精确地说，是它所使用的网络接口——以及分配给它的端口号的组合。这个组合地址被称为*套接字*。套接字使用<
    *IP地址*>:< *端口号*>的表示法指定。例如，如果你有一个运行在IP地址41.199.222.3上的网站，该网站对应的HTTP服务器套接字将是*41.199.222.3:80*。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The overall identifier of a TCP/IP application process on a
    device is the combination of its IP address and port number, which is called a
    *socket*.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 设备上TCP/IP应用程序过程的整体标识符是其IP地址和端口号的组合，这被称为*套接字*。'
- en: 'You will also sometimes see a socket specified using a host name instead of
    an IP address, like this: <*Host Name*>:<*Port Number*>. To use this descriptor,
    the web browser must first resolve the name to an IP address using DNS. For example,
    you might find a website URL such as [http://www.thisisagreatsite.com:8080](http://www.thisisagreatsite.com:8080).
    This tells the web browser to *resolve* the name [www.thisisagreatsite.com](http://www.thisisagreatsite.com)
    first to an IP address using DNS. Then it tells the browser to send a request
    to that address using the nonstandard server port 8080, which the browser occasionally
    uses instead of port 80\. (See [Chapter 70](ch70.html "Chapter 70. TCP/IP APPLICATION
    LAYER ADDRESSING: UNIFORM RESOURCE IDENTIFIERS, LOCATORS, AND NAMES (URIS, URLS,
    AND URNS)")''s discussion of application layer addressing using URLs for more
    information.)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时也会看到使用主机名而不是IP地址来指定套接字，如下所示：< *主机名*>:< *端口号*>。要使用此描述符，网络浏览器必须首先使用DNS将名称解析为IP地址。例如，你可能找到一个网站URL，如[http://www.thisisagreatsite.com:8080](http://www.thisisagreatsite.com:8080)。这告诉网络浏览器首先使用DNS将名称[www.thisisagreatsite.com](http://www.thisisagreatsite.com)解析为IP地址。然后它告诉浏览器使用非标准服务器端口号8080向该地址发送请求，浏览器偶尔会使用端口号8080而不是端口号80。（有关更多信息，请参阅[第70章](ch70.html
    "第70章。TCP/IP应用层地址：统一资源标识符、定位器和名称（URIs、URLs和URNs）")中关于使用URL进行应用层地址讨论的内容。）
- en: 'The *socket* is a fundamental concept to the operation of TCP/IP application
    software. In fact, it is the basis for an important TCP/IP application program
    interface (API) with the same name: *sockets*. A version of this API for Windows
    is called *Windows Sockets* or *Winsock*, which you may have heard of before.
    These APIs allow application programs to easily use TCP/IP to communicate.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是TCP/IP应用程序操作的基本概念。实际上，它是与同名的TCP/IP应用程序程序接口（API）的基础：套接字。Windows上的这个API版本被称为*Windows套接字*或*Winsock*，您可能之前听说过。这些API允许应用程序程序轻松地使用TCP/IP进行通信。
- en: So the exchange of data between a pair of devices consists of a series of messages
    sent from a socket on one device to a socket on the other. Each device will normally
    have multiple simultaneous conversations going on. In the case of TCP, a connection
    is established for each pair of devices for the duration of the communication
    session. These connections must be managed, and this requires that they be uniquely
    identified. This is done using the socket identifiers for each of the two devices
    that are connected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一对设备之间的数据交换由从一台设备的套接字发送到另一台设备的套接字的一系列消息组成。每个设备通常会有多个同时进行的对话。在TCP的情况下，每个设备对在通信会话期间都会建立一个连接。这些连接必须被管理，并且需要它们具有唯一标识。这是通过连接的两个设备的套接字标识来完成的。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each device may have multiple TCP connections active at any
    given time. Each connection is uniquely identified using the combination of the
    client socket and server socket, which in turn contains four elements: the client
    IP address and port, and the server IP address and port.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个设备在任何给定时间都可能有多条TCP连接处于活动状态。每个连接都通过客户端套接字和服务器套接字的组合唯一标识，这些套接字又包含四个元素：客户端IP地址和端口号，以及服务器IP地址和端口号。'
- en: 'Let''s return to the example in [Figure 43-3](ch43s04.html#tcpip_clientserver_application_port_mech
    "Figure 43-3. TCP/IP client/server application port mechanics This highly simplified
    example shows how clients and servers use port numbers for a request.reply exchange.
    The client is making an HTTP request and sends it to the server at HTTP''s well-known
    port number, 80\. Its port number for this exchange is the pseudo-randomly selected
    port 3022\. The server sends its reply back to that port number, which it reads
    from the request."). You are sending an HTTP request from your client at 177.41.72.6
    to the website at 41.199.222.3\. The server for that website will use well-known
    port number 80, so its socket is 41.199.222.3:80, as you saw before. You have
    been ephemeral port number 3022 for the web browser, so the client socket is 177.41.72.6:3022\.
    The overall connection between these devices can be described using this socket
    pair: (41.199.222.3:80, 177.41.72.6:3022).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[图43-3](ch43s04.html#tcpip_clientserver_application_port_mech "图43-3. TCP/IP客户端/服务器应用程序端口号机制
    这个高度简化的例子展示了客户端和服务器如何使用端口号进行请求/响应交换。客户端正在发送一个HTTP请求，并将其发送到HTTP的已知端口号80。它的这个交换的端口号是随机选择的3022。服务器将它的回复发送回该端口号，该端口号是从请求中读取的。")中的例子。您正在从客户端177.41.72.6向网站41.199.222.3发送HTTP请求。该网站的服务器将使用已知的端口号80，因此它的套接字是41.199.222.3:80，正如您之前所看到的。您为网络浏览器分配了临时的端口号3022，因此客户端套接字是177.41.72.6:3022。这些设备之间的整体连接可以使用这个套接字对来描述：(41.199.222.3:80,
    177.41.72.6:3022)。
- en: For much more on how TCP identifies connections, see the topic on TCP ports
    and connection identification in [Chapter 46](ch46.html "Chapter 46. TRANSMISSION
    CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于TCP如何识别连接的信息，请参阅[第46章](ch46.html "第46章. 传输控制协议（TCP）基础和一般操作")中关于TCP端口和连接识别的主题。
- en: Unlike TCP, UDP is a connectionless protocol, so it obviously doesn't use connections.
    The pair of sockets on the sending and receiving devices can still be used to
    identify the two processes that are exchanging data, but because there are no
    connections, the socket pair doesn't have the significance that it does in TCP.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP不同，UDP是一种无连接协议，因此它显然不使用连接。发送和接收设备上的套接字对仍然可以用来识别正在交换数据的两个进程，但由于没有连接，套接字对在TCP中的重要性并不相同。
- en: Common TCP/IP Applications and Well-Known and Registered Port Numbers
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的TCP/IP应用程序和已知及注册的端口号
- en: The great popularity of the TCP/IP protocol suite has led to the development
    of literally thousands of different applications and protocols. Most of these
    use the client/server model of operation that I discussed earlier in this chapter.
    Server processes for a particular application are designed to use a particular
    reserved port number, and clients use an ephemeral (temporary) port number to
    initiate a connection to the server. To ensure that everyone agrees on which port
    numbers each server application should use for each application, port numbers
    are centrally managed by the IANA.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议套件的巨大普及导致了成千上万种不同应用程序和协议的发展。其中大多数都使用了我在本章前面讨论过的客户端/服务器操作模型。特定应用程序的服务器进程被设计为使用特定的保留端口号，而客户端使用一个短暂的（临时）端口号来与服务器建立连接。为了确保每个人都同意每个服务器应用程序应该为每个应用程序使用哪个端口号，端口号由IANA集中管理。
- en: Originally, IANA kept the list of well-known and registered port numbers in
    a lengthy text document along with all the many other parameters for which IANA
    was centrally responsible (such as IP Protocol field numbers, Type and Code field
    values for ICMP, and so on). These port numbers were published on a periodic basis
    in Internet (RFC) standards documents titled "Assigned Numbers." This system worked
    fine in the early days of the Internet, but by the mid-1990s, these values were
    changing so rapidly that using the RFC process was not feasible. It was too much
    work to keep publishing them, and the RFC was practically out of date the day
    after it was published.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，IANA将已知和注册的端口号列表保存在一个冗长的文本文档中，其中还包含了IANA负责的许多其他参数（如IP协议字段编号、ICMP的类型和代码字段值等）。这些端口号定期在名为“分配号码”的互联网（RFC）标准文档中发布。这种系统在互联网的早期阶段运行良好，但到了20世纪90年代中期，这些值变化得太快，使用RFC流程已不可行。发布它们的工作量太大，而且RFC发布后实际上就过时了。
- en: The last "Assigned Numbers" standard was RFC 1700, which was published in October
    1994\. After that time, IANA moved to a set of World Wide Web documents that contained
    the parameters they manage. This allowed IANA to keep the lists constantly up-to-date,
    and enabled TCP/IP users to get more current information. RFC 1700 was officially
    obsoleted in 2002.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的“分配号码”标准是RFC 1700，该标准于1994年10月发布。在那之后，IANA转向使用一组包含他们管理的参数的万维网文档。这使得IANA能够不断更新列表，并使TCP/IP用户能够获取更准确的信息。RFC
    1700于2002年被正式废除。
- en: You can find complete information on all the parameters that IANA maintains
    at [http://www.iana.org/numbers.html](http://www.iana.org/numbers.html). The URL
    of the file that contains TCP/UDP port assignments is [http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.iana.org/numbers.html](http://www.iana.org/numbers.html)找到IANA维护的所有参数的完整信息。包含TCP/UDP端口分配的文件的URL是[http://www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers)。
- en: This document is the definitive list of all well-known and registered TCP and
    UDP port assignments. Each port number is assigned a short *keyword* with a brief
    description of the protocol that uses it. There are two problems with this document.
    First, it is incredibly long; it contains over 10,000 lines of text. Most of the
    protocols mentioned in those thousands of lines are for obscure applications that
    you have probably never heard of before (I certainly have never heard of most
    of them!). This makes it hard to easily see the port assignments for the protocols
    that are most commonly used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档是所有已知和注册的TCP和UDP端口分配的最终列表。每个端口号都分配了一个简短的*关键字*，以及使用该协议的简要描述。这份文档有两个问题。首先，它非常长；包含超过10,000行文本。其中提到的绝大多数协议都是用于晦涩的应用程序，你可能以前从未听说过（我肯定大多数都没听说过！）。这使得很难轻松地看到最常用协议的端口分配。
- en: 'The other problem with this document is that it shows the same port number
    as reserved for both TCP and UDP for an application. As I mentioned earlier, TCP
    and UDP port numbers are actually independent, so, in theory, one port number
    could assign TCP port 80 to one server application type and UDP port 80 to another.
    It was believed that this would lead to confusion, so with very few exceptions,
    the same port number is shown in the list for the same application for both TCP
    and UDP. Nevertheless, showing this in the list has a drawback: You can''t tell
    which protocol the application actually uses, and which has just been reserved
    for consistency.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档的另一个问题是，它显示同一个端口号既为TCP又为UDP的应用程序所保留。正如我之前提到的，TCP和UDP端口号实际上是独立的，因此，从理论上讲，一个端口号可以分配TCP端口80给一种服务器应用程序类型，而将UDP端口80分配给另一种。人们认为这会导致混淆，因此，除了极少数例外，同一应用程序的TCP和UDP列表中显示的端口号是相同的。尽管如此，在列表中显示这一点也有一个缺点：您无法知道应用程序实际使用的是哪种协议，以及哪种只是为了保持一致性而保留的。
- en: Given all that, I have decided to include a couple of summary tables that show
    the well-known and registered port numbers for the most common TCP/IP applications.
    I have indicated whether or not the protocol uses TCP, UDP, or both. [Table 43-1](ch43s06.html#common_tcpip_well-known_port_numbers_and
    "Table 43-1. Common TCP/IP Well-Known Port Numbers and Applications") lists the
    well-known port numbers for the most common TCP/IP application protocols.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，我决定包括几个总结表格，显示最常见TCP/IP应用程序的已知和注册端口号。我指出了协议是否使用TCP、UDP或两者都使用。[表43-1](ch43s06.html#common_tcpip_well-known_port_numbers_and
    "表43-1. 常见TCP/IP已知端口号和应用")列出了最常见TCP/IP应用协议的已知端口号。
- en: Table 43-1. Common TCP/IP Well-Known Port Numbers and Applications
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表43-1. 常见TCP/IP已知端口号和应用
- en: '| Port # | TCP/UDP | Keyword | Protocol Abbreviation | Application or Protocol
    Name/Comments |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 端口号 | TCP/UDP | 关键词 | 协议缩写 | 应用或协议名称/注释|'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 7 | TCP + UDP | echo | — | Echo Protocol |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 7 | TCP + UDP | echo | — | 回声协议|'
- en: '| 9 | TCP + UDP | discard | — | Discard Protocol |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 9 | TCP + UDP | discard | — | 丢弃协议|'
- en: '| 11 | TCP + UDP | systat | — | Active Users Protocol |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 11 | TCP + UDP | systat | — | 活跃用户协议|'
- en: '| 13 | TCP + UDP | daytime | — | Daytime Protocol |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 13 | TCP + UDP | daytime | — | 白天协议|'
- en: '| 17 | TCP + UDP | qotd | QOTD | Quote of the Day Protocol |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 17 | TCP + UDP | qotd | QOTD | 每日名言协议|'
- en: '| 19 | TCP + UDP | chargen | — | Character Generator Protocol |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 19 | TCP + UDP | chargen | — | 字符发生器协议|'
- en: '| 20 | TCP | ftp-data | FTP (data) | File Transfer Protocol (default data port)
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 20 | TCP | ftp-data | FTP（数据）| 文件传输协议（默认数据端口）|'
- en: '| 21 | TCP | ftp | FTP (control) | File Transfer Protocol (control/commands)
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 21 | TCP | ftp | FTP（控制）| 文件传输协议（控制/命令）|'
- en: '| 23 | TCP | telnet | — | Telnet Protocol |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 23 | TCP | telnet | — | Telnet协议|'
- en: '| 25 | TCP | smtp | SMTP | Simple Mail Transfer Protocol |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 25 | TCP | smtp | SMTP | 简单邮件传输协议|'
- en: '| 37 | TCP + UDP | time | — | Time Protocol |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 37 | TCP + UDP | time | — | 时间协议|'
- en: '| 43 | TCP | nicname | — | Whois Protocol (also called Nicname) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 43 | TCP | nicname | — | Whois协议（也称为Nicname）|'
- en: '| 53 | TCP + UDP | domain | DNS | Domain Name Server (Domain Name System) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 53 | TCP + UDP | domain | DNS | 域名服务器（域名系统）|'
- en: '| 67 | UDP | bootps | BOOTP/DHCP | Bootstrap Protocol/Dynamic Host Configuration
    Protocol (server) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 67 | UDP | bootps | BOOTP/DHCP | 引导协议/动态主机配置协议（服务器）|'
- en: '| 68 | UDP | bootpc | BOOTP/DHCP | Bootstrap Protocol/Dynamic Host Configuration
    Protocol (client) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 68 | UDP | bootpc | BOOTP/DHCP | 引导协议/动态主机配置协议（客户端）|'
- en: '| 69 | UDP | tftp | TFTP | Trivial File Transfer Protocol |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 69 | UDP | tftp | TFTP | 简单文件传输协议|'
- en: '| 70 | TCP | gopher | — | Gopher Protocol |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 70 | TCP | gopher | — | Gopher协议|'
- en: '| 79 | TCP | finger | — | Finger User Information Protocol |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 79 | TCP | finger | — | Finger用户信息协议|'
- en: '| 80 | TCP | http | HTTP | Hypertext Transfer Protocol (World Wide Web) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 80 | TCP | http | HTTP | 超文本传输协议（万维网）|'
- en: '| 110 | TCP | pop3 | POP | Post Office Protocol (version 3) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 110 | TCP | pop3 | POP | 邮政协议（第3版）|'
- en: '| 119 | TCP | nntp | NNTP | Network News Transfer Protocol |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 119 | TCP | nntp | NNTP | 网络新闻传输协议|'
- en: '| 123 | UDP | ntp | NTP | Network Time Protocol |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 123 | UDP | ntp | NTP | 网络时间协议|'
- en: '| 137 | TCP + UDP | netbios-ns | — | NetBIOS (Name Service) |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 137 | TCP + UDP | netbios-ns | — | NetBIOS（名称服务）|'
- en: '| 138 | UDP | netbios-dgm | — | NetBIOS (Datagram Service) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 138 | UDP | netbios-dgm | — | NetBIOS（数据报服务）|'
- en: '| 139 | TCP | netbios-ssn | — | NetBIOS (Session Service) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 139 | TCP | netbios-ssn | — | NetBIOS（会话服务）|'
- en: '| 143 | TCP | imap | IMAP | Internet Message Access Protocol |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 143 | TCP | imap | IMAP | 互联网消息访问协议|'
- en: '| 161 | UDP | snmp | SNMP | Simple Network Management Protocol |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 161 | UDP | snmp | SNMP | 简单网络管理协议 |'
- en: '| 162 | UDP | snmptrap | SNMP | Simple Network Management Protocol (Trap) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 162 | UDP | snmptrap | SNMP | 简单网络管理协议（陷阱）|'
- en: '| 179 | TCP | bgp | BGP | Border Gateway Protocol |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 179 | TCP | bgp | BGP | 边界网关协议 |'
- en: '| 194 | TCP | irc | IRC | Internet Relay Chat |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 194 | TCP | irc | IRC | 互联网中继聊天 |'
- en: '| 443 | TCP | https | HTTP over SSL | Hypertext Transfer Protocol over Secure
    Sockets Layer |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 443 | TCP | https | HTTP over SSL | 超文本传输协议安全套接字层 |'
- en: '| 500 | UDP | isakmp | IKE | IPsec Internet Key Exchange |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 500 | UDP | isakmp | IKE | IPsec互联网密钥交换 |'
- en: '| 520 | UDP | router | RIP | Routing Information Protocol (RIP-1 and RIP-2)
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 520 | UDP | router | RIP | 路由信息协议（RIP-1和RIP-2）|'
- en: '| 521 | UDP | ripng | RIPng | Routing Information Protocol - Next Generation
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 521 | UDP | ripng | RIPng | 路由信息协议 - 新一代 |'
- en: The registered port numbers are by definition for protocols that are not standardized
    using the RFC process, so they are mostly esoteric applications, and I don't think
    it's necessary to list all of them. [Table 43-2](ch43s06.html#common_tcpip_registered_port_numbers_and
    "Table 43-2. Common TCP/IP Registered Port Numbers and Applications") shows a
    few that I feel are of particular interest.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注册端口号按照定义是用于未使用RFC过程标准化的协议，因此它们大多是神秘的应用程序，我认为没有必要列出所有这些。[表43-2](ch43s06.html#common_tcpip_registered_port_numbers_and
    "表43-2. 常见TCP/IP注册端口号和应用")展示了其中一些我认为特别有趣的应用。
- en: Table 43-2. Common TCP/IP Registered Port Numbers and Applications
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表43-2. 常见TCP/IP注册端口号和应用
- en: '| Port # | TCP/UDP | Keyword | Protocol Abbreviation | Application or Protocol
    Name/Comments |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 端口号 | TCP/UDP | 关键词 | 协议缩写 | 应用或协议名称/注释 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1512 | TCP + UDP | wins | WINS | Microsoft Windows Internet Naming Service
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 1512 | TCP + UDP | wins | WINS | 微软Windows互联网命名服务 |'
- en: '| 1701 | UDP | l2tp | L2TP | Layer 2 Tunneling Protocol |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 1701 | UDP | l2tp | L2TP | 层2隧道协议 |'
- en: '| 1723 | TCP | pptp | PPTP | Point-to-Point Tunneling Protocol |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 1723 | TCP | pptp | PPTP | 点对点隧道协议 |'
- en: '| 2049 | TCP + UDP | nfs | NFS | Network File System |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 2049 | TCP + UDP | nfs | NFS | 网络文件系统 |'
- en: '| 6000–6063 | TCP | x11 | X11 | X Window System |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 6000–6063 | TCP | x11 | X11 | X窗口系统 |'
- en: Chapter 44. TCP/IP USER DATAGRAM PROTOCOL (UDP)
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第44章：TCP/IP用户数据报协议（UDP）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The very fact that the TCP/IP protocol suite bears the name of the Internet
    Protocol (IP) and the Transmission Control Protocol (TCP) suggests that these
    are the two key protocols in the suite. IP resides at the network layer, and TCP
    is at the transport layer. It's no wonder that many people don't even realize
    that there is a second transport layer protocol in TCP/IP.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议套件以互联网协议（IP）和传输控制协议（TCP）的名字命名，这本身就暗示了这两个是套件中的两个关键协议。IP位于网络层，而TCP位于传输层。难怪很多人甚至没有意识到TCP/IP中还有一个第二层传输层协议。
- en: Like a shy younger brother, the *User Datagram Protocol (UDP)* sits in the shadows
    while TCP gets the glory. The fancier sibling deserves much of this limelight,
    since TCP is arguably the more important of the two. However, UDP fills a critical
    niche in the TCP/IP protocol suite, because it allows many applications to work
    at their best when using TCP would be less than ideal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像害羞的小弟弟一样，*用户数据报协议（UDP）*在阴影中坐着，而TCP却得到了荣耀。这个更花哨的兄弟确实应该得到很多这样的关注，因为TCP可以说是两者中更重要的一方。然而，UDP在TCP/IP协议套件中填补了一个关键的角色，因为它允许许多应用程序在使用TCP时达到最佳状态。
- en: In this chapter, I discuss UDP, the simpler and less-known TCP/IP transport
    protocol. I begin with an overview of the protocol and describe its history and
    standards. I outline how UDP operates, and explain the format used for UDP messages.
    I conclude with a discussion of what kinds of applications use UDP and the well-known
    or registered ports that are assigned to them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我讨论了UDP，这是一种更简单、不太为人所知的TCP/IP传输协议。我首先概述了该协议，并描述了其历史和标准。我概述了UDP的工作方式，并解释了UDP消息使用的格式。最后，我讨论了使用UDP的应用类型以及分配给它们的知名或注册端口号。
- en: UDP Overview, History, and Standards
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP概述、历史和标准
- en: I suppose the sibling rivalry analogy I mentioned in the introduction to this
    section may be a bit silly. I highly doubt that protocols lie awake at night worrying
    about how much we use them. However, it's interesting to discover just how important
    UDP really is, given how little attention it gets compared to TCP. In fact, in
    true older-sibling, spotlight-stealing fashion, you can't even really understand
    the history of UDP without first discussing TCP.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我想，我在本节引言中提到的兄弟姐妹竞争的比喻可能有点愚蠢。我高度怀疑协议会在夜晚醒来担心我们使用它们的程度。然而，考虑到与TCP相比得到的关注如此之少，发现UDP实际上有多么重要是非常有趣的。事实上，在真正的哥哥，抢风头的风格中，你甚至无法真正理解UDP的历史，除非首先讨论TCP。
- en: In [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE"),
    where I described the history of TCP/IP, I explained that very early on in the
    development of the protocol suite, there was only one protocol that handled the
    functions IP and TCP perform. This protocol, called TCP, provided network layer
    connectivity like IP, and also established connections, offered reliability, and
    took care of the typical transport layer quality requirements that you associate
    with modern TCP, such as flow control and retransmission handling.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。TCP/IP协议套件和架构")中，我描述了TCP/IP的历史，我解释说，在协议套件的早期开发阶段，只有一个协议处理IP和TCP执行的功能。这个协议被称为TCP，它提供了类似于IP的网络层连接性，并建立了连接，提供了可靠性，并处理了与现代TCP相关联的典型传输层质量要求，例如流量控制和重传处理。
- en: It didn't take long before the developers of the fledgling combined TCP protocol
    quickly realized that mixing these functions together was a mistake. While most
    conventional applications needed the classic transport layer reliability functions,
    some did not. These features introduced overhead, which was added whether or not
    applications actually needed the reliability features. Worse, there were some
    applications for which the features not only were of no value, but also were a
    detriment, since even a small amount of lost performance due to the overhead would
    be a problem.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发初期的联合TCP协议的开发者很快意识到，将这些功能混合在一起是一个错误。虽然大多数传统应用需要经典的传输层可靠性功能，但有些则不需要。这些特性引入了开销，无论应用是否真的需要可靠性功能，都会增加这种开销。更糟糕的是，对于某些应用来说，这些特性不仅没有价值，反而有害，因为即使是由于开销导致的微小性能损失也会成为一个问题。
- en: The solution was to separate the original protocol into IP and TCP. IP would
    do basic internetworking, and TCP would do the reliability features. This paved
    the way for the creation of an alternative transport layer protocol—UDP—for applications
    that didn't want or need the features that TCP provided.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将原始协议分离成IP和TCP。IP将执行基本互连，而TCP将执行可靠性功能。这为创建一个替代传输层协议——UDP——铺平了道路，该协议适用于不需要或不需要TCP提供的功能的应用。
- en: 'There are two main attributes that are always associated with UDP: simple and
    fast. UDP is a simple protocol that uses a very straightforward messaging structure
    that is similar to the message format that many other TCP/IP protocols use (in
    contrast to the more complex data structures—streams and segments—that TCP uses).
    In fact, when you boil it down, UDP''s only real goal is to serve as an interface
    between networking application processes that are running at the higher layers,
    and the internetworking capabilities of IP.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与UDP相关联的两个主要属性始终是简单和快速。UDP是一个简单的协议，它使用一个非常直接的消息结构，这与许多其他TCP/IP协议使用的消息格式相似（与TCP使用的更复杂的数据结构——流和段相对比）。实际上，当你把它简化到极致，UDP的唯一真正目标是作为在更高层运行的网络应用进程之间的接口，以及IP的互连能力。
- en: Like TCP, UDP layers a method of transport layer addressing (and hence, process
    identification) on top of IP through the use of UDP port numbers. UDP includes
    an optional checksum capability for error detection, but adds virtually no other
    functionality.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP类似，UDP通过使用UDP端口号在IP之上叠加了一种传输层寻址方法（因此，进程标识）。UDP包括一个可选的校验和功能用于错误检测，但几乎不添加其他功能。
- en: The best way to see the simplicity of UDP is to look at the standards that define
    it. Or rather, I should say *standard* in the singular, because there is only
    one. UDP was defined in RFC 768, "User Datagram Protocol," in 1980\. This document
    is three pages in length, and no one has ever needed to revise it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到UDP的简单性，最好的办法是查看定义它的标准。或者，我应该说*标准*（单数形式），因为只有一个。UDP在1980年的RFC 768，“用户数据报协议”中被定义。这份文件长度为三页，而且没有人需要修订它。
- en: UDP is a fast protocol specifically because it doesn't have all the bells and
    whistles of TCP. This makes it unsuitable for use by many, if not most, typical
    networking applications. But for some applications, this speed is exactly what
    the applications want from a transport layer protocol, namely something that takes
    the applications' data and quickly shuffles it down to the IP layer with minimal
    fuss. In choosing to use UDP, the application writer takes it upon himself to
    take care of issues such as reliability and retransmissions, if necessary. This
    can be a recipe for success or failure, depending on the application and how carefully
    the writer uses UDP.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是一种快速协议，这正是因为它没有TCP的所有花哨功能。这使得它对于许多，如果不是大多数典型的网络应用来说，都不适合使用。但对于某些应用来说，这种速度正是它们从传输层协议中想要的，即一种能够快速将应用数据打乱并迅速将其下放到IP层，而无需太多麻烦的东西。选择使用UDP，应用程序编写者自己承担起处理诸如可靠性、重传等问题，如果需要的话。这可能是成功或失败的因素，取决于应用以及编写者如何仔细使用UDP。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *The User Datagram Protocol (UDP)* was developed for use by
    application protocols that do not require reliability, acknowledgment, or flow
    control features at the transport layer. It is designed to be simple and fast.
    It provides only transport layer addressing (in the form of UDP ports), an optional
    checksum capability, and little else.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *用户数据报协议（UDP）*是为那些在传输层不需要可靠性、确认或流量控制功能的应用协议而开发的。它被设计成简单快捷。它只提供传输层寻址（以UDP端口号的形式），可选的校验和功能，以及很少的其他功能。'
- en: UDP Operation
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP操作
- en: UDP is so simple that I can't say a great deal about how it works. It is designed
    to do as little as possible.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: UDP非常简单，以至于我无法详细说明它是如何工作的。它被设计成尽可能少地做事情。
- en: What UDP Does
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP做什么
- en: 'UDP''s only real task is to take data from higher-layer protocols and place
    it in UDP messages, which are then passed down to IP for transmission. The basic
    steps for transmission using UDP are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的唯一真正任务是接收来自高层协议的数据并将其放置在UDP消息中，然后将其传递给IP进行传输。使用UDP进行传输的基本步骤如下：
- en: '**Higher-Layer Data Transfer** An application sends a message to the UDP software.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**高层数据传输** 应用程序向UDP软件发送消息。'
- en: '**UDP Message Encapsulation** The higher-layer message is encapsulated into
    the Data field of a UDP message. The headers of the UDP message are filled in,
    including the Source Port field of the application that sent the data to UDP and
    the Destination Port field of the intended recipient. The checksum value may also
    be calculated.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**UDP消息封装** 高层消息被封装在UDP消息的数据字段中。UDP消息的头部被填写，包括发送数据的源端口号和目标端口号。校验和值也可能被计算。'
- en: '**Transfer Message to IP** The UDP message is passed to IP for transmission.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将消息传递给IP** UDP消息被传递给IP进行传输。'
- en: And that's about it. Of course, when the destination device receives the message,
    this short procedure is reversed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。当然，当目标设备接收到消息时，这个简短的过程会被反转。
- en: What UDP Does Not Do
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP不做什么
- en: 'UDP is so simple that its operation is often described in terms of what it
    does not do, instead of what it does. As a transport protocol, UDP does not do
    the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: UDP非常简单，其操作通常用它不做什么来描述，而不是它做什么。作为一个传输协议，UDP不执行以下操作：
- en: Establish connections before sending data. It just packages the data and sends
    it off.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发送数据之前建立连接。它只是打包数据并发送。
- en: Provide acknowledgments to show that data was received.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供确认以显示数据已被接收。
- en: Provide any guarantees that its messages will arrive.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供任何保证其消息将到达。
- en: Detect lost messages and retransmit them.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测丢失的消息并重新传输它们。
- en: Ensure that data is received in the same order that it was sent.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据以发送的相同顺序接收。
- en: Provide any mechanism to handle congestion or manage the flow of data between
    devices.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供任何机制来处理拥塞或管理设备之间的数据流。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** UDP is probably the simplest protocol in all of TCP/IP. It
    takes application layer data that has been passed to it, packages it in a simplified
    message format, and sends it to IP for transmission.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** UDP可能是TCP/IP中所有协议中最简单的一个。它接收传递给它的应用层数据，将其封装在简化的消息格式中，然后将其发送给IP进行传输。'
- en: If these limitations sound similar the ones for IP, then you're paying attention.
    UDP is basically IP with transport layer port addressing. (For this reason, UDP
    is sometimes called a *wrapper protocol*, since all it does is wrap application
    data in its simple message format and send it to IP.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些限制听起来与IP的限制相似，那么你注意到了。UDP基本上是带有传输层端口地址的IP。（因此，UDP有时被称为*包装协议*，因为它所做的只是将应用数据包装在其简单的消息格式中，并将其发送到IP。）
- en: However, despite the previous list, there are a couple of limited feedback and
    error-checking mechanisms that do exist within UDP. One is the optional checksum
    capability, which can allow for the detection of an error in transmission or the
    situation in which a UDP message is delivered to the wrong place (see the next
    section, "UDP Message Format" for details). The other is Internet Control Message
    Protocol (ICMP) error reporting (see [Chapter 31](ch31.html "Chapter 31. ICMP
    CONCEPTS AND GENERAL OPERATION")). For example, if a UDP message is sent that
    contains a destination port number that the destination device does not recognize,
    the destination host will send an ICMP Destination Unreachable message back to
    the original source. Of course, ICMP exists for all IP errors of this sort, so
    I'm stretching a bit here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管有前面的列表，UDP中确实存在一些有限的反馈和错误检查机制。一个是可选的校验和功能，它可以允许检测传输中的错误或UDP消息被错误地发送到错误位置的情况（参见下一节“UDP消息格式”的详细信息）。另一个是互联网控制消息协议（ICMP）错误报告（参见[第31章](ch31.html
    "第31章. ICMP概念和一般操作"））。例如，如果发送了一个包含目标设备不识别的目标端口号的UDP消息，目标主机将向原始源发送一个ICMP目标不可达消息。当然，ICMP存在于所有此类IP错误中，所以我在这里有点夸大了。
- en: UDP Message Format
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP消息格式
- en: What's the magic word when it comes to UDP? It's *simple*. This is true of the
    operation of the protocol, and it is also true of the format used for UDP messages.
    Interestingly, however, there is one aspect of UDP that is not simple.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到UDP时，神奇的词是什么？它是*简单*。这不仅适用于协议的操作，也适用于UDP消息使用的格式。然而，有趣的是，UDP有一个方面并不简单。
- en: In keeping with the goal of efficiency, the UDP header is only 8 bytes in length.
    You can contrast this with the TCP header size of 20 bytes or more. [Table 44-1](ch44s03.html#udp_message_format-id002
    "Table 44-1. UDP Message Format") and [Figure 44-1](ch44s03.html#udp_message_format-id001
    "Figure 44-1. UDP message format") show the format of UDP messages.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持效率的目标，UDP头部只有8字节长。你可以将其与20字节或更长的TCP头部大小进行对比。[表44-1](ch44s03.html#udp_message_format-id002
    "表44-1. UDP消息格式")和[图44-1](ch44s03.html#udp_message_format-id001 "图44-1. UDP消息格式")显示了UDP消息的格式。
- en: 'The UDP Checksum field is the one area where the protocol is a bit confusing.
    The concept of a checksum itself is nothing new; checksums are used widely in
    networking protocols to provide protection against errors. What''s a bit odd is
    this notion of computing the checksum over the regular datagram as well as a pseudo
    header. So instead of calculating the checksum over only the fields in the UDP
    datagram, the UDP software first constructs a fake additional header that contains
    the following fields:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: UDP校验和字段是协议中有点令人困惑的一个区域。校验和的概念本身并不新颖；校验和在网络协议中被广泛使用，以提供对错误的保护。有点奇怪的是，这个计算校验和的概念不仅适用于常规数据报，还适用于伪头部。因此，UDP软件不是只计算UDP数据报中的字段校验和，而是首先构建一个包含以下字段的假附加头部：
- en: IP Source Address field
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP源地址字段
- en: IP Destination Address field
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP目标地址字段
- en: IP Protocol field
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP协议字段
- en: UDP Length field
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP长度字段
- en: '![UDP message format](httpatomoreillycomsourcenostarchimages288085.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![UDP消息格式](httpatomoreillycomsourcenostarchimages288085.png)'
- en: Figure 44-1. UDP message format
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图44-1. UDP消息格式
- en: Table 44-1. UDP Message Format
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表44-1. UDP消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Source Port | 2 | The 16-bit port number of the process that originated the
    UDP message on the source device. This will normally be an ephemeral (client)
    port number for a request that a client sends to a server or a well-known/registered
    (server) port number for a reply that a server sends to a client. (See [Chapter 43](ch43.html
    "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS") for details.) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 源端口 | 2 | 在源设备上发起UDP消息的进程的16位端口号。这通常是一个客户端（临时）端口号，客户端向服务器发送请求，或者是一个已知/已注册（服务器）端口号，服务器向客户端发送回复。（有关详细信息，请参见[第43章](ch43.html
    "第43章. TCP和UDP寻址：端口和套接字"）。）|'
- en: '| Destination Port | 2 | The 16-bit port number of the process that is the
    ultimate intended recipient of the message on the destination device. This will
    usually be a well-known/registered (server) port number for a client request or
    an ephemeral (client) port number for a server reply. (See [Chapter 43](ch43.html
    "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS") for details.) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 目标端口 | 2 | 目标设备上消息最终预期接收者的进程的16位端口号。这通常是一个客户端请求的知名/已注册（服务器）端口号或服务器回复的短暂（客户端）端口号。（有关详细信息，请参阅[第43章](ch43.html
    "第43章. TCP和UDP寻址：端口和套接字")）。|'
- en: '| Length | 2 | The length of the entire UDP datagram, including both header
    and Data fields. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 2 | 整个UDP数据报的长度，包括头部和数据字段。|'
- en: '| Checksum | 2 | An optional 16-bit checksum computed over the entire UDP datagram
    plus a special pseudo header of fields. See below for more information. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 可选的16位校验和，计算整个UDP数据报加上特殊字段伪头部。有关更多信息，请参阅下文。|'
- en: '| Data | Variable | The encapsulated higher-layer message that will be sent.
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 可变 | 将要发送的封装的高层消息。|'
- en: The UDP pseudo header format is illustrated in [Figure 44-2](ch44s03.html#udp_pseudo_header_format
    "Figure 44-2. UDP pseudo header format").
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: UDP伪头部格式在[图44-2](ch44s03.html#udp_pseudo_header_format "图44-2. UDP伪头部格式")中展示。
- en: '![UDP pseudo header format](httpatomoreillycomsourcenostarchimages288087.png.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![UDP伪头部格式](httpatomoreillycomsourcenostarchimages288087.png.jpg)'
- en: Figure 44-2. UDP pseudo header format
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图44-2. UDP伪头部格式
- en: The total length of this pseudo header is 11 bytes. It is padded to 12 bytes
    with a byte of zeros and then prepended to the real UDP message. The checksum
    is then computed over the combination of the pseudo header and the real UDP message,
    and the value is placed into the Checksum field. The pseudo header is used only
    for this calculation and is then discarded; it is not actually transmitted. The
    UDP software in the destination device creates the same pseudo header when calculating
    its checksum in order to compare it to the one transmitted in the UDP header.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪头部的总长度是11字节。它通过一个字节的零填充到12字节，然后附加到真实的UDP消息前。然后计算伪头部和真实UDP消息的组合校验和，并将值放入校验和字段。伪头部仅用于此计算，然后被丢弃；它实际上并不传输。目标设备中的UDP软件在计算其校验和时创建相同的伪头部，以便与UDP头部中传输的进行比较。
- en: Computing the checksum over the regular UDP fields protects the UDP message
    against bit errors. Adding the pseudo header allows the checksum to also protect
    the UDP message against other types of problems as well, most notably the accidental
    delivery of a message to the wrong destination. The checksum calculation in UDP,
    including the use of the pseudo header, is exactly the same as the method used
    in TCP (except that the Length field is different in TCP). See [Chapter 48](ch48.html
    "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER") for a full description
    of why the pseudo header is important, as well as some of the interesting implications
    of using IP fields in transport layer datagram calculations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规UDP字段上计算校验和可以保护UDP消息免受位错误的影响。添加伪头部允许校验和也保护UDP消息免受其他类型的问题，最值得注意的是意外将消息发送到错误的目的地。UDP中的校验和计算，包括使用伪头部，与TCP中使用的方法完全相同（除了TCP中的长度字段不同）。有关伪头部为什么重要的完整描述以及使用IP字段在传输层数据报计算中的有趣影响的详细信息，请参阅[第48章](ch48.html
    "第48章. TCP消息格式和数据传输")。
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** UDP packages application layer data into a very simple message
    format that includes only four header fields. One of these is an optional Checksum
    field. When the Checksum field is used, the checksum is computed over both the
    real header and a pseudo header of fields from the UDP and IP headers, in a manner
    that''s very similar to the way the TCP checksum is calculated.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** UDP将应用层数据打包成一个非常简单的消息格式，该格式仅包含四个头部字段。其中一个是可选的校验和字段。当使用校验和字段时，校验和是在真实头部和来自UDP和IP头部的字段的一个特殊伪头部上计算的，其方式与TCP校验和计算非常相似。'
- en: Note that the use of the Checksum field is optional in UDP. If UDP doesn't use
    the Checksum field, UDP sets it to a value of all zeros. This could potentially
    create confusion, however, since when UDP uses the checksum, the calculation can
    sometimes result in a value of zero. To avoid having the destination think that
    UDP didn't use the checksum in this case, UDP instead represents this zero value
    as a value of all ones (65,535 decimal).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在UDP中，使用校验和字段是可选的。如果UDP不使用校验和字段，它将将其设置为全零的值。然而，这可能会引起混淆，因为当UDP使用校验和时，计算有时会导致零值。为了避免让目的地认为在这种情况下UDP没有使用校验和，UDP将这个零值表示为全一的值（十进制的65,535）。
- en: UDP Common Applications and Server Port Assignments
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP常见应用程序和服务器端口分配
- en: As you have seen, UDP contains very little functionality. With the exception
    of the important addressing capability that UDP ports represent, using UDP is
    very much like using IP. This means that UDP has most of the same disadvantages
    that IP has. It doesn't establish a lasting connection between devices; it doesn't
    acknowledge received data or retransmit lost messages; and it certainly isn't
    concerned with obscurities such as flow control and congestion management.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，UDP包含的功能非常少。除了UDP端口代表的重要寻址能力之外，使用UDP在很大程度上类似于使用IP。这意味着UDP具有与IP相同的许多缺点。它不会在设备之间建立持久的连接；它不会确认接收到的数据或重传丢失的消息；并且它当然不关心诸如流量控制和拥塞管理之类的奥秘。
- en: The absence of those features makes UDP simply unsuitable for the majority of
    classic networking applications. These applications usually need to establish
    a connection so that the two devices can exchange data. Many applications also
    must have the ability to occasionally, or even regularly, send very large amounts
    of data that must be received intact for it to be of value. For example, consider
    a message transfer protocol like the Hypertext Transfer Protocol (HTTP). If only
    part of a web page gets from a server back to a web browser, it's useless. HTTP
    and other file and message transfer protocols like it need the capabilities of
    TCP.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能的缺失使得UDP对于大多数经典网络应用来说根本不适用。这些应用程序通常需要建立连接，以便两个设备可以交换数据。许多应用程序还必须具备偶尔或定期发送大量数据的能力，这些数据必须完整接收才有价值。例如，考虑一个像超文本传输协议（HTTP）这样的消息传输协议。如果只有网页的一部分从服务器传回网页浏览器，那么它是无用的。HTTP和其他类似的文件和消息传输协议需要TCP的功能。
- en: Why Some TCP/IP Applications Use UDP
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么一些TCP/IP应用程序使用UDP
- en: So what applications use UDP then? UDP's classic limitation is that because
    it doesn't provide reliability features, an application that uses UDP is responsible
    for those functions. In reality, if an application needs the features that TCP
    provides but not the ones that UDP provides, it's inefficient to allow the application
    to implement those features, except in special cases. If the application needs
    what TCP provides, it should just use TCP! However, applications that only need
    some of what TCP implements are sometimes better off using UDP and implementing
    that limited set of functionality at the application level.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪些应用程序使用UDP呢？UDP的经典限制是，因为它不提供可靠性功能，所以使用UDP的应用程序需要负责这些功能。实际上，如果一个应用程序需要TCP提供的功能，但不包括UDP提供的功能，那么允许应用程序实现这些功能是不高效的，除非在特殊情况下。如果应用程序需要TCP提供的东西，它应该直接使用TCP！然而，仅需要TCP实现部分功能的应用程序有时使用UDP并在应用层实现这一有限功能集会更好。
- en: 'So, the applications that run over UDP are normally the ones that do not require
    all or even most of the features that TCP has. These applications can benefit
    from the increased efficiency that comes about from avoiding the setup and overhead
    associated with TCP. Applications usually (but not always) meet this description
    because the data they send falls into one of two categories:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在UDP上运行的应用程序通常是那些不需要TCP所具有的所有或大多数功能的应用程序。这些应用程序可以从避免与TCP相关的设置和开销带来的效率提升中受益。通常（但不总是）这些应用程序符合这一描述，因为它们发送的数据属于以下两个类别之一：
- en: '**Data Where Performance Is More Important Than Completeness** The classic
    example of this category is a multimedia application. For streaming a video clip
    over the Internet, the most important feature is that the stream starts flowing
    quickly and keeps flowing. Human beings notice only significant disruptions in
    the flow of this type of information, so a few bytes of data missing due to a
    lost datagram is not a big problem. Furthermore, even if someone used TCP for
    something like this and noticed and retransmitted a lost datagram, it would be
    useless, because the lost datagram would belong to a part of the clip that is
    long past—and the time spent in that retransmission might make the current part
    of the clip arrive late. Clearly, UDP is best for this situation.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能比完整性更重要的数据** 这个类别的经典例子是多媒体应用程序。对于在互联网上流式传输视频片段，最重要的功能是流开始快速流动并保持流动。人类只注意到这类信息流动中的重大中断，因此由于丢失的数据报而丢失的几个字节并不是大问题。此外，即使有人使用TCP进行类似操作并注意到并重传丢失的数据报，这将是无用的，因为丢失的数据报将属于剪辑中很久以前的部分——在该重传中花费的时间可能会使当前部分的视频片段迟到。显然，UDP最适合这种情况。'
- en: '**Data Exchanges That Are "Short and Sweet"** There are many TCP/IP applications
    in which the underlying protocol consists of only a very simple request/reply
    exchange. A client sends a short request message to a server, and a short reply
    message goes back from the server to the client. In this situation, there is no
    real need to set up a connection the way that TCP does. Also, if a client sends
    only one short message, a single IP datagram can carry the message. This means
    that there is no need to worry about data arriving out of order, flow control
    between the devices, and so forth. How about the loss of the request or the reply?
    These can be handled simply at the application level using timers. If a client
    sends a request and the server doesn''t get it, the server won''t reply, and the
    client will eventually send a replacement request. The same logic applies if the
    server sends a response that never arrives.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**“简短而甜蜜”的数据交换** 在许多TCP/IP应用程序中，底层协议仅由非常简单的请求/回复交换组成。客户端向服务器发送简短请求消息，然后服务器将简短回复消息发送回客户端。在这种情况下，实际上没有必要像TCP那样建立连接。此外，如果客户端只发送一条简短消息，单个IP数据报就可以携带该消息。这意味着没有必要担心数据到达顺序、设备间的流量控制等问题。那么请求或回复的丢失怎么办？这些可以在应用层使用计时器简单地处理。如果客户端发送请求而服务器没有收到，服务器将不会回复，客户端最终会发送替换请求。如果服务器发送的响应从未到达，同样的逻辑也适用。'
- en: These are the most common cases where UDP is used, but there are other reasons.
    For example, if an application needs to multicast or broadcast data, it must use
    UDP, because TCP is supported only for unicast communication between two devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最常见的UDP使用情况，但还有其他原因。例如，如果一个应用程序需要多播或广播数据，它必须使用UDP，因为TCP仅支持两个设备之间的单播通信。
- en: Tip
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A protocol uses UDP instead of TCP in two situations. The first
    is when an application values timely delivery over reliable delivery, and when
    TCP''s retransmission of lost data would be of limited or even no value. The second
    is when a simple protocol can handle the potential loss of an IP datagram itself
    at the application layer using a timer/retransmit strategy, and when the other
    features of TCP are not required. Applications that require multicast or broadcast
    transmissions also use UDP, because TCP does not support those transmissions.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 协议在两种情况下使用UDP而不是TCP。第一种情况是当应用程序更重视及时交付而非可靠交付，并且当TCP重传丢失的数据价值有限或甚至没有价值时。第二种情况是当简单的协议可以在应用层使用计时器/重传策略来处理IP数据报本身的潜在丢失，并且当TCP的其他特性不是必需时。需要多播或广播传输的应用程序也使用UDP，因为TCP仅支持两个设备之间的单播通信。'
- en: Incidentally, I have read about problems that have occurred in the past in applications
    using UDP. Sometimes, programmers don't realize how little UDP does, how it leaves
    the application responsible for handling all the potential vagaries of an internetworking
    environment. Someone writing a UDP-based application must always keep in mind
    that no one can make assumptions about how or even whether a destination will
    receive any message. Insufficient testing can lead to disaster in worst-case scenarios
    on a larger internetwork, especially the Internet.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，我阅读过关于过去在 UDP 应用程序中发生的问题。有时，程序员没有意识到 UDP 做得有多少，它如何让应用程序负责处理互联网环境中的所有潜在的不确定性。编写基于
    UDP 的应用程序的人必须始终牢记，没有人可以假设目标是否会接收任何消息。测试不足可能导致在更大互联网环境中的最坏情况下的灾难，尤其是互联网。
- en: Common UDP Applications and Server Port Use
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见 UDP 应用程序和服务器端口使用
- en: '[Table 44-2](ch44s04.html#common_udp_applications_and_server-id001 "Table 44-2. Common
    UDP Applications and Server Port Assignments") shows some of the more interesting
    protocols that use UDP and the well-known and registered port numbers used for
    each one''s server processes. It also provides a very brief description of why
    these protocols use UDP instead of TCP.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 44-2](ch44s04.html#common_udp_applications_and_server-id001 "表 44-2. 常见
    UDP 应用程序和服务器端口分配") 展示了一些使用 UDP 的更有趣的协议以及每个协议用于其服务器进程的知名和注册端口号。它还简要说明了为什么这些协议使用
    UDP 而不是 TCP。'
- en: Applications That Use Both UDP and TCP
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时使用 UDP 和 TCP 的应用程序
- en: There are some protocols that use both of the TCP/IP transport layer protocols.
    This is often the case either for utility protocols that are designed to accept
    connections using both transport layer protocols, or for applications that need
    the benefits of TCP in some cases but not others.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有些协议同时使用 TCP/IP 传输层协议。这通常发生在设计为接受两种传输层协议连接的实用协议中，或者在某些情况下需要 TCP 的好处，而在其他情况下则不需要。
- en: 'The classic example of the latter is the TCP/IP Domain Name System (DNS), which
    normally uses UDP port 53 for simple requests and replies, which are usually short.
    Larger messages requiring reliable delivery, such as zone transfers, use TCP port
    53 instead. Note that in [Table 44-2](ch44s04.html#common_udp_applications_and_server-id001
    "Table 44-2. Common UDP Applications and Server Port Assignments"), I have omitted
    some of the less-significant protocols such as the ones used for diagnostic purposes
    (Echo, Discard, CharGen, and so on). For a full list of all common applications,
    see [Chapter 43](ch43.html "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS").'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的经典例子是 TCP/IP 域名系统 (DNS)，它通常使用 UDP 端口 53 进行简单的请求和回复，这些请求通常较短。需要可靠交付的较大消息，如区域传输，则使用
    TCP 端口 53。请注意，在 [表 44-2](ch44s04.html#common_udp_applications_and_server-id001
    "表 44-2. 常见 UDP 应用程序和服务器端口分配") 中，我省略了一些不太重要的协议，例如用于诊断目的的协议（回声、丢弃、字符生成等）。有关所有常见应用程序的完整列表，请参阅
    [第 43 章](ch43.html "第 43 章。TCP 和 UDP 地址：端口和套接字")。
- en: Table 44-2. Common UDP Applications and Server Port Assignments
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 表 44-2. 常见 UDP 应用程序和服务器端口分配
- en: '| Port # | Keyword | Protocol | Comments |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 端口号 | 关键词 | 协议 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 53 | domain | Domain Name Server (DNS) | Uses a simple request/reply messaging
    system for most exchanges (but also uses TCP for longer ones). |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 53 | 域名 | 域名系统 (DNS) | 使用简单的请求/回复消息系统进行大多数交换（但也会使用 TCP 进行较长的交换）。|'
- en: '| 67 and 68 | bootps/bootpc | Bootstrap Protocol (BOOTP) and Dynamic Host Configuration
    Protocol (DHCP) | Host configuration protocols that consist of short request and
    reply exchanges. |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 67 和 68 | bootps/bootpc | 引导协议 (BOOTP) 和动态主机配置协议 (DHCP) | 由简短的请求和回复交换组成的宿主配置协议。|'
- en: '| 69 | tftp | Trivial File Transfer Protocol (TFTP) | TFTP is a great example
    of a protocol that was specifically designed for UDP, especially when you compare
    it to regular FTP. The latter protocol uses TCP to establish a session between
    two devices and then makes use of its own large command set and TCP''s features
    in order to ensure the reliable transfer of possibly very large files. In contrast,
    TFTP is designed for the quick and easy transfer of small files. To avoid file
    corruption, TFTP includes simple versions of some of TCP''s features, such as
    acknowledgments. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 69 | tftp | 简单文件传输协议 (TFTP) | TFTP 是一个专门为 UDP 设计的协议的绝佳例子，尤其是与常规 FTP 相比。后者使用
    TCP 在两个设备之间建立会话，然后利用其庞大的命令集和 TCP 的特性，以确保可能非常大的文件的可靠传输。相比之下，TFTP 是为快速轻松地传输小文件而设计的。为了避免文件损坏，TFTP
    包含了 TCP 的一些简单版本的功能，例如确认。|'
- en: '| 161 and 162 | snmp | Simple Network Management Protocol | An administrative
    protocol that uses relatively short messages. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 161 和 162 | snmp | 简单网络管理协议 | 一种使用相对较短消息的行政协议。|'
- en: '| 520 and 521 | router/ripng | Routing Information Protocol (RIP-1, RIP-2,
    RIPng) | Unlike more complex routing protocols like BGP, RIP uses a simple request/reply
    messaging system, doesn''t require connections, and does require multicasts/broadcasts.
    This makes it a natural choice for UDP. If a routing update is sent due to a request
    and is lost, it can be replaced by sending a new request. Routine (unsolicited)
    updates that are lost are replaced in the next cycle. |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 520 和 521 | router/ripng | 路由信息协议 (RIP-1, RIP-2, RIPng) | 与像 BGP 这样更复杂的路由协议不同，RIP
    使用简单的请求/回复消息系统，不需要连接，并且确实需要多播/广播。这使得它成为 UDP 的一个自然选择。如果由于请求而发送的路由更新丢失，可以通过发送新的请求来替换。在下一个周期中，丢失的常规（非请求）更新将被替换。|'
- en: '| 2049 | nfs | Network File System | NFS is an interesting case. Since it is
    a file-sharing protocol, you would think that it would use TCP instead of UDP,
    but it was originally designed to use UDP for performance reasons. There were
    many people who felt that this was not the best design decision, and later versions
    moved to the use of TCP. The latest version of NFS uses only TCP. |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 2049 | nfs | 网络文件系统 | NFS 是一个有趣的案例。由于它是一个文件共享协议，您可能会认为它应该使用 TCP 而不是 UDP，但最初它是为了性能原因而设计为使用
    UDP。许多人认为这不是最佳的设计决策，后来的版本转向使用 TCP。最新的 NFS 版本仅使用 TCP。|'
- en: Chapter 45. TCP OVERVIEW, FUNCTIONS, AND CHARACTERISTICS
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 45 章。TCP 概述、功能和特性
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: As I mentioned in [Chapter 42](ch42.html "Chapter 42. OVERVIEW AND COMPARISON
    OF TCP AND UDP"), the Transmission Control Protocol (TCP) is a critically important
    part of the TCP/IP protocol suite. It's also a fairly complicated protocol, with
    a lot of important concepts and mechanisms that you need to understand. The old
    joke says the "best way to eat an elephant is one bite at a time." Similarly here,
    you can best comprehend the operation of this complicated protocol by going slowly,
    starting with a high-level look at it, where it came from, and what it does.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 42 章](ch42.html "第 42 章。TCP 和 UDP 的概述和比较")中提到的，传输控制协议（TCP）是 TCP/IP 协议套件中的一个关键部分。它也是一个相当复杂的协议，包含许多重要的概念和机制，您需要理解。老笑话说“吃象最好的方法是每次咬一口。”同样，在这里，您可以通过逐步理解这个复杂的协议，从对其高层次的观察开始，了解其来源和作用，来最好地理解其操作。
- en: In this chapter, I begin by introducing you to TCP. I first provide an overview
    and history of TCP and then describe the standards that define it. Then I illustrate
    what TCP actually does by listing its functions and explaining how TCP works by
    describing its most important characteristics. This will give you a feel for what
    TCP is all about, and it will set the stage for the more complex technical discussions
    in subsequent chapters.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我首先向您介绍 TCP。我首先提供 TCP 的概述和历史，然后描述定义它的标准。然后，通过列出其功能和解释 TCP 的工作原理，即描述其最重要的特性，来展示
    TCP 实际上做什么。这将让您对 TCP 有一个大致的了解，并为后续章节中更复杂的技术讨论奠定基础。
- en: TCP Overview, History, and Standards
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 概述、历史和标准
- en: Between them, layers 3 and 4 of the OSI Reference Model represent the interface
    between networking software (the applications that need to move data across networks)
    and networking hardware (the devices that carry the data over networks). Any protocol
    suite must have a protocol or set of protocols that handles these layer 3 and
    layer 4 functions.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI参考模型中，第3层和第4层代表网络软件（需要通过网络移动数据的应用程序）和网络硬件（在网络中传输数据的设备）之间的接口。任何协议套件都必须有一个或一组协议来处理这些第3层和第4层功能。
- en: The TCP/IP protocol suite is named for the two main protocols that provide these
    capabilities. Both TCP and the Internet Protocol (IP) allow software to run on
    an internetwork. IP deals with internetwork datagram delivery and routing, while
    TCP handles connections and provides reliability. What's interesting, however,
    is that in the early days of the protocol suite, there was, in fact, no TCP/IP
    at all.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP协议套件是以提供这些功能的两个主要协议命名的。TCP和互联网协议（IP）都允许软件在互连网络上运行。IP处理互连网络数据报的交付和路由，而TCP处理连接并提供可靠性。然而，有趣的是，在协议套件的早期阶段，实际上根本不存在TCP/IP。
- en: TCP History
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP历史
- en: Due to its prominent role in the history of networking, TCP is impossible to
    describe without going back to the early days of the protocol suite. In the early
    1970s, what we know today as the global Internet was a small research internetwork
    called the *ARPAnet*, an acronym that came from the United States Defense Advanced
    Research Projects Agency (DARPA or ARPA). This network used a technology called
    the *Network Control Protocol (NCP)*, which allowed hosts to connect to each other.
    NCP did approximately the same job that TCP and IP do together today.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP在网络历史中扮演着突出的角色，不回顾协议套件的早期阶段就无法描述TCP。在20世纪70年代初，我们今天所知道的全球互联网是一个名为*ARPAnet*的小型研究型互连网络，这个名字来源于美国国防高级研究计划局（DARPA或ARPA）。这个网络使用了一种名为*网络控制协议（NCP）*的技术，它允许主机相互连接。NCP大致完成了今天TCP和IP一起完成的相同工作。
- en: Due to limitations in NCP, development began on a new protocol that would be
    better suited to a growing internetwork. This new protocol, first formalized in
    RFC 675, was called the Internet *Transmission Control Program (TCP)*. Like its
    predecessor NCP, TCP was responsible for basically everything that was needed
    to allow applications to run on an internetwork. Thus, TCP was at first both TCP
    and IP.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NCP的限制，开始开发一个新的协议，该协议更适合不断增长的互连网络。这个新协议首次在RFC 675中正式化，被称为互联网*传输控制程序（TCP）*。像其前身NCP一样，TCP负责实现应用程序在互连网络上运行所需的所有基本功能。因此，最初TCP既是TCP也是IP。
- en: As I explain in detail in the description of the history of TCP/IP as a whole
    in [Chapter 8](ch08.html "Chapter 8. TCP/IP PROTOCOL SUITE AND ARCHITECTURE"),
    several years were spent adjusting and revising TCP, with version 2 of the protocol
    documented in 1977\. While the functionality of TCP was steadily improved, there
    was a problem with the basic concept behind the protocol. Having TCP handle datagram
    transmissions, routing (layer 3 functions), and connections, reliability, and
    data-flow management (layer 4 functions) meant that TCP violated key concepts
    of protocol layering and modularity. TCP forced all applications to use the layer
    4 functions in order to use the layer 3 functions. This made TCP inflexible and
    poorly suited to the needs of applications that required only the lower-level
    functions and not the higher-level ones.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第8章](ch08.html "第8章。TCP/IP协议套件和架构")中详细解释的那样，在调整和修订TCP的过程中花费了几年时间，该协议的第二个版本于1977年进行了记录。虽然TCP的功能稳步提升，但协议背后的基本概念存在问题。让TCP处理数据报传输、路由（第3层功能）、连接、可靠性和数据流管理（第4层功能）意味着TCP违反了协议分层和模块化的关键概念。TCP迫使所有应用程序使用第4层功能才能使用第3层功能。这使得TCP缺乏灵活性，不适合仅需要低层功能而不需要高层功能的应用程序的需求。
- en: 'As a result, the decision was made to split TCP into two: the layer 4 functions
    were retained, with TCP renamed the *Transmission Control Protocol* (as opposed
    to Transmission Control Program). The layer 3 functions became the Internet Protocol.
    This split was finalized in version 4 of TCP, and so the first IP was given "version
    4" as well, for consistency. RFC 793, "Transmission Control Protocol," published
    in September 1981, defined TCP version 4, and it is still the current version
    of the standard.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定将TCP分为两部分：保留了第4层的功能，将TCP更名为**传输控制协议**（与传输控制程序相对）。第3层的功能变成了互联网协议。这种分割在TCP的第4个版本中得到最终确定，因此第一个IP也被赋予了“版本4”的名称，以保持一致性。1981年9月发布的RFC
    793，“传输控制协议”，定义了TCP版本4，并且至今仍然是标准的当前版本。
- en: Even though it is more than 20 years old and is the first version most people
    have ever used, version 4 was the result of several years' work and many earlier
    TCP versions tested on the early Internet. It is therefore a very mature protocol
    for its age. A precocious protocol, you might say. (To be fair, other standards
    have described many additional features and modifications to TCP, rather than
    upgrading the main document.)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它已经超过20年历史，并且是大多数人首次使用的第一个版本，但版本4是经过多年工作和在早期互联网上测试的许多早期TCP版本的结果。因此，对于其年龄来说，这是一个非常成熟的协议。可以说是一个早熟的协议。（为了公平起见，其他标准已经描述了许多对TCP的附加功能和修改，而不是升级主要文档。）
- en: Overview of TCP Operation
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP操作概述
- en: TCP is a full-featured transport layer protocol that provides all the functions
    that a typical application needs for the reliable transportation of data across
    an arbitrary internetwork. It provides transport layer addressing for application
    processes in the form of TCP ports and allows machines to use these ports in order
    to establishing connections between them. Once the devices have connected to each
    other, they can pass data bidirectionally between them. Applications can send
    data to TCP as a simple stream of bytes, and TCP takes care of packaging and sending
    the data as segments that TCP packages into IP datagrams. The receiving device's
    TCP implementation reverses the process, passing up to the application the stream
    of data that the device originally sent.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是一个功能齐全的传输层协议，它提供了典型应用程序在任意互联网上可靠传输数据所需的所有功能。它以TCP端口的形式为应用程序进程提供传输层寻址，允许机器使用这些端口来建立它们之间的连接。一旦设备相互连接，它们就可以在它们之间双向传递数据。应用程序可以将数据作为简单的字节流发送到TCP，而TCP负责将数据打包并发送为TCP打包成IP数据报的段。接收设备的TCP实现会逆转这个过程，将设备最初发送的数据流传递给应用程序。
- en: TCP includes an extensive set of mechanisms. These mechanisms ensure that data
    gets from source to destination reliably, consistently, and in a timely fashion.
    The key to its operation in this regard is the *sliding window acknowledgment
    system*, which allows each device to keep track of the bytes of data it has sent
    and to confirm the receipt of data received from the other device in the connection.
    Unacknowledged data is eventually retransmitted automatically, and the parameters
    of the system can be adjusted to the needs of the devices and the connection.
    This same system also provides buffering and flow control capabilities between
    devices. These capabilities handle uneven data delivery rates and other problems.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: TCP包含了一套广泛的机制。这些机制确保数据能够可靠、一致且及时地从源传输到目的地。其操作的关键在于**滑动窗口确认系统**，它允许每个设备跟踪其已发送的字节数据，并确认从连接的另一台设备接收到的数据。未确认的数据最终会自动重传，并且系统的参数可以根据设备和连接的需求进行调整。这个相同的系统还提供了设备之间的缓冲和流量控制能力。这些能力处理不均匀的数据传输速率和其他问题。
- en: Tip
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The primary transport layer protocol in the TCP/IP protocol
    suite is the *Transmission Control Protocol (TCP)*. TCP is a connection-oriented,
    acknowledged, reliable, full-featured protocol designed to provide applications
    with a reliable way to send data using the unreliable Internet Protocol (IP).
    It allows applications to send bytes of data as a stream of bytes and automatically
    packages them into appropriately sized segments for transmission. It uses a special
    sliding *window acknowledgment system* to ensure that its recipient receives all
    data, handles necessary retransmissions, and provides flow control so that each
    device in a connection can manage the rate at which other devices send data to
    it.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP/IP 协议套件中的主要传输层协议是 *传输控制协议 (TCP)*。TCP 是一种面向连接、确认、可靠的、功能齐全的协议，旨在为应用程序提供一种可靠的方式来使用不可靠的互联网协议
    (IP) 发送数据。它允许应用程序以字节流的形式发送数据字节，并自动将它们打包成适当大小的段进行传输。它使用特殊的滑动 *窗口确认系统* 来确保其接收者收到所有数据，处理必要的重传，并提供流量控制，以便连接中的每个设备可以管理其他设备向其发送数据的速率。'
- en: Because of TCP's many capabilities, it's likely that the protocol will satisfy
    just about any application that requires reliable, connection-oriented data delivery.
    A primary goal of TCP, reliable data delivery means that higher-layer applications
    don't need to provide TCP's common functions. Because the majority of conventional
    message-passing applications employ it, the TCP/IP transport protocol is the most
    widely used transport protocol.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TCP 具有许多功能，因此该协议很可能满足几乎所有需要可靠、面向连接的数据传输的应用程序。TCP 的一个主要目标是可靠的数据传输，这意味着高层应用程序不需要提供
    TCP 的常见功能。因为大多数传统的消息传递应用程序都使用它，所以 TCP/IP 传输协议是最广泛使用的传输协议。
- en: TCP Standards
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 标准
- en: RFC 793 is the defining standard for TCP, but it doesn't include all the details
    about how modern TCP operates. Several other standards include additional information
    about how the protocol works and describe enhancements to the basic TCP mechanisms
    that were developed over the years. Some of these are fairly esoteric, but they
    are useful for gaining a more complete understanding of TCP. I have listed some
    of them in [Table 45-1](ch45.html#supplementary_tcp_standards "Table 45-1. Supplementary
    TCP Standards").
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 793 是 TCP 的定义性标准，但它并没有包括现代 TCP 运行的所有细节。其他几个标准包括关于协议如何工作的附加信息，并描述了多年来开发的基本
    TCP 机制的一些增强。其中一些相当晦涩，但它们对于获得对 TCP 的更完整理解是有用的。我在[表 45-1](ch45.html#supplementary_tcp_standards
    "表 45-1. 补充 TCP 标准")中列出了一些。
- en: Table 45-1. Supplementary TCP Standards
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 表 45-1. 补充 TCP 标准
- en: '| RFC # | Name | Description |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| RFC # | Name | Description |'
- en: '| --- | --- | --- |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 813 | Window and Acknowledgment Strategy in TCP | Discusses the TCP sliding
    window acknowledgment system, describes certain problems that can occur with it,
    and offers methods to correct them. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 813 | TCP 中的窗口和确认策略 | 讨论了 TCP 滑动窗口确认系统，描述了可能与之相关的问题，并提供了纠正这些问题的方法。|'
- en: '| 879 | The TCP Maximum Segment Size and Related Topics | Discusses the important
    maximum segment size (MSS) parameter that controls the size of TCP messages, and
    then relates this parameter to IP datagram size. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 879 | TCP 最大段大小及相关主题 | 讨论了控制 TCP 消息大小的关键最大段大小 (MSS) 参数，并将其与 IP 数据报大小相关联。|'
- en: '| 896 | Congestion Control in IP/TCP Internetworks | Talks about congestion
    problems and how you can use TCP to handle them. Note the interesting inversion
    of the normal protocol suite name: IP/TCP. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 896 | IP/TCP 互连网络中的拥塞控制 | 讨论了拥塞问题以及如何使用 TCP 来处理这些问题。注意正常的协议套件名称的有趣反转：IP/TCP。|'
- en: '| 1122 | Requirements for Internet Hosts — Communication Layers | Describes
    important details of how TCP should be implemented on hosts. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 1122 | 互联网主机要求 — 通信层 | 描述了 TCP 应在主机上实现的重要细节。|'
- en: '| 1146 | TCP Alternate Checksum Options | Specifies a mechanism for having
    TCP devices use an alternative method of checksum generation. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 1146 | TCP 替代校验和选项 | 指定了一种机制，允许 TCP 设备使用替代的校验和生成方法。|'
- en: '| 1323 | TCP Extensions for High Performance | Defines extensions to TCP for
    high-speed links and new TCP options. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 1323 | TCP 高性能扩展 | 定义了用于高速链路和新 TCP 选项的 TCP 扩展。|'
- en: '| 2018 | TCP Selective Acknowledgment Options | An enhancement to basic TCP
    functionality that allows TCP devices to selectively specify specific segments
    for retransmission. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 2018 | TCP 选择性确认选项 | 一种增强基本 TCP 功能的方法，允许 TCP 设备选择性地指定特定段进行重传。|'
- en: '| 2581 | TCP Congestion Control | Describes four algorithms used for congestion
    control in TCP networks: slow start, congestion avoidance, fast retransmit, and
    fast recovery. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 2581 | TCP 阻塞控制 | 描述了在 TCP 网络中用于阻塞控制的四种算法：慢启动、拥塞避免、快速重传和快速恢复。|'
- en: '| 2988 | Computing TCP''s Retransmission Timer | Discusses issues related to
    setting the TCP retransmission timer, which controls how long a device waits for
    acknowledgment of sent data before retransmitting it. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 2988 | 计算TCP的重传计时器 | 讨论了与设置 TCP 重传计时器相关的问题，该计时器控制设备在重传发送的数据之前等待确认的时间长度。|'
- en: There are hundreds of higher-layer application protocols that use TCP and whose
    defining standards therefore make at least glancing reference to it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百种高层应用协议使用 TCP，因此它们的定义标准至少对它有简要的提及。
- en: TCP is designed to use IP, since they were developed together and as you have
    seen, were even once part of the same specification. They were later split up
    in order to respect the principles of architectural layering. For this reason,
    TCP tries to make as few assumptions as possible regarding the underlying protocol
    over which it runs. It is not as strictly tied to the use of IP as you might imagine,
    and you can even adapt it for use over other network layer protocols. For our
    purposes, however, this should be considered mainly an interesting aside.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是设计用来使用 IP 的，因为它们是共同开发的，正如您所看到的，它们甚至曾经是同一规范的一部分。后来，为了尊重架构分层原则，它们被拆分了。因此，TCP
    尽量对其运行的底层协议做出尽可能少的假设。它并不像您想象的那么严格地绑定到 IP 的使用，您甚至可以将其适应用于其他网络层协议。然而，就我们的目的而言，这应该主要被视为一个有趣的旁白。
- en: TCP Functions
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 功能
- en: You have now seen where TCP comes from and the standards that describe it. As
    I said in the introduction to this chapter, TCP is a complicated protocol, so
    it will take some time to explain how it works. Here, I'll describe what TCP does
    and what it doesn't do.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了 TCP 的来源以及描述它的标准。正如我在本章引言中所说，TCP 是一个复杂的协议，因此解释它是如何工作的需要一些时间。在这里，我将描述
    TCP 做了什么以及它没有做什么。
- en: Functions That TCP Performs
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 执行的功能
- en: 'Despite the TCP''s complexity, I can simplify its basic operation by describing
    its primary functions. The following are what I believe to be the five main tasks
    that TCP performs:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TCP很复杂，但我可以通过描述其主要功能来简化其基本操作。以下是我认为 TCP 执行的五个主要任务：
- en: '**Addressing/Multiplexing** Many different applications use TCP for a transport
    protocol. Therefore, like its simpler sibling, the User Datagram Protocol (UDP),
    multiplexing the data that TCP receives from these different processes so that
    the data can be sent out using the underlying network layer protocol is an important
    job for TCP. At the same time, these higher-layer application processes are identified
    using TCP ports. [Chapter 43](ch43.html "Chapter 43. TCP AND UDP ADDRESSING: PORTS
    AND SOCKETS") contains a great deal of detail about how this addressing works.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻址/多路复用** 许多不同的应用使用 TCP 作为传输协议。因此，就像它的简单兄弟用户数据报协议（UDP）一样，将 TCP 从这些不同进程接收到的数据多路复用，以便可以使用底层网络层协议发送数据，对于
    TCP 来说是一项重要的工作。同时，这些高层应用进程使用 TCP 端口进行标识。[第 43 章](ch43.html "第 43 章。TCP 和 UDP 寻址：端口和套接字")
    包含了大量关于这种寻址如何工作的详细信息。'
- en: '**Establishing, Managing, and Terminating Connections** TCP provides a set
    of procedures that devices can follow in order to negotiate and establish a TCP
    connection over which data can travel. Once a connection is opened, TCP includes
    logic for managing the connection and handling problems that may result with the
    connection. When a device is finished with a TCP connection, a special process
    is followed to terminate it.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**建立、管理和终止连接** TCP 提供了一套设备可以遵循的流程，以便在数据可以传输的 TCP 连接上进行协商和建立。一旦连接打开，TCP 包括管理连接和处理可能由此产生的连接问题的逻辑。当设备完成
    TCP 连接时，会遵循一个特殊的过程来终止它。'
- en: '**Handling and Packaging Data** TCP defines a mechanism by which applications
    are able to send data to TCP from higher layers. This data is then packaged into
    messages that will be sent to the destination TCP software. The destination software
    unpackages the data and gives it to the application on the destination machine.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理和打包数据** TCP 定义了一种机制，使得应用能够从高层向 TCP 发送数据。然后，这些数据被打包成消息，这些消息将被发送到目标 TCP 软件。目标软件解包数据并将其交给目标机器上的应用。'
- en: '**Transferring Data** Conceptually, the TCP implementation on a transmitting
    device is responsible for the transfer of packaged data to the TCP process on
    the other device. Following the principle of layering, this transfer is done by
    having the TCP software on the sending machine pass the data packets to the underlying
    network layer protocol, which again normally means IP.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输数据** 从概念上讲，发送设备上的 TCP 实现负责将打包的数据传输到另一设备上的 TCP 进程。遵循分层原则，这种传输是通过发送机器上的 TCP
    软件将数据包传递给底层网络层协议来完成的，这通常意味着 IP。'
- en: '**Providing Reliability and Transmission Quality Services** TCP includes a
    set of services and features that allows an application to consider the protocol
    a reliable means of sending of data. This means that normally a TCP application
    doesn''t need to worry about data being sent and never showing up or arriving
    in the wrong order. It also means that other common problems that might arise
    if IP were used directly are avoided.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供可靠性和传输质量服务** TCP 包含一系列服务和功能，允许应用程序将协议视为发送数据的可靠手段。这意味着通常 TCP 应用程序不需要担心数据发送后从未出现或以错误顺序到达。这也意味着如果直接使用
    IP，可能会出现的其他常见问题得到了避免。'
- en: '**Providing Flow Control and Congestion Avoidance Features** TCP allows the
    flow of data between two devices to be controlled and managed. It also includes
    features that deal with congestion that devices may experience during communication
    between each other.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供流量控制和拥塞避免功能** TCP 允许控制和管理两个设备之间的数据流。它还包括处理设备在相互通信过程中可能遇到的拥塞问题的功能。'
- en: Functions That TCP Doesn't Perform
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 不执行的功能
- en: Clearly, TCP is responsible for a fairly significant number of key functions.
    The items listed in the preceding section may not seem that impressive, but this
    is just a high-level look at the protocol. When you look at these functions in
    detail, you will see that each one actually involves a rather significant amount
    of work for TCP to do.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，TCP 负责了相当数量的关键功能。前一部分列出的项目可能看起来并不那么令人印象深刻，但这只是对协议的高层次概述。当你详细查看这些功能时，你会发现每个功能实际上都涉及到
    TCP 需要完成的大量工作。
- en: 'Conversely, sometimes TCP is described as doing everything an application needs
    in order to use an internetwork. However, the protocol doesn''t do everything.
    It has limitations and certain areas that its designers specifically did not address.
    The following are some of the notable functions that TCP does not perform:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有时 TCP 被描述为执行应用程序使用互联网所需的所有操作。然而，该协议并不是万能的。它有局限性，并且某些领域是其设计者明确没有涉及的。以下是一些
    TCP 不执行的重要功能：
- en: '**Specifying Application Use** TCP defines the transport protocol. It does
    not specifically describe how applications should use TCP. That is up to the application
    protocol.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定应用程序使用** TCP 定义了传输协议。它并不具体说明应用程序应该如何使用 TCP。这取决于应用程序协议。'
- en: '**Providing Security** TCP does not provide any mechanism for ensuring the
    authenticity or privacy of data that it transmits. If authenticity and privacy
    are important to applications, they must accomplish them using some other means,
    such as IPsec, for example.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供安全性** TCP 不提供任何确保它传输的数据的真实性或隐私性的机制。如果应用程序认为真实性和隐私性很重要，它们必须使用其他方式来实现，例如使用
    IPsec。'
- en: '**Maintaining Message Boundaries** TCP sends data as a continuous stream rather
    than discrete messages. It is up to the application to specify where one message
    ends and the next begins.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护消息边界** TCP 以连续流的形式发送数据，而不是离散的消息。指定一个消息在哪里结束，下一个消息在哪里开始的责任在于应用程序。'
- en: '**Guaranteeing Communication** Wait a minute; isn''t TCP supposed to guarantee
    that data will get to its destination? Well, yes and no. TCP will detect unacknowledged
    transmissions and resend them if needed. However, if some sort of problem prevents
    reliable communication, all TCP can do is keep trying. It can''t make any guarantees,
    because there are too many things out of its control. Similarly, it can attempt
    to manage the flow of data, but it cannot resolve every problem.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**保证通信** 等一下；TCP 不是应该保证数据能够到达目的地吗？嗯，是的，也不是。TCP 会检测未确认的传输，并在需要时重新发送。然而，如果某种问题阻止了可靠的通信，TCP
    唯一能做的就是不断尝试。它不能做出任何保证，因为有许多事情超出了它的控制范围。同样，它可以尝试管理数据流，但不能解决每个问题。'
- en: This last point might seem a bit pedantic, but it is important to keep in mind,
    especially since many people tend to think of TCP as bulletproof. The overall
    success of communication depends entirely on the underlying internetwork and the
    networks that constitute it. A chain is as strong as its weakest link, and if
    there is a problem at the lower layers, nothing TCP can do will guarantee successful
    data transfer.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后一点可能听起来有点繁琐，但这一点很重要，尤其是许多人倾向于认为TCP是坚不可摧的。通信的整体成功完全取决于底层互联网及其构成的各个网络。链条的强度取决于最薄弱的环节，如果底层存在问题，TCP能做的任何事都无法保证数据传输的成功。
- en: Tip
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** TCP provides reliable communication only by detecting failed
    transmissions and resending them. It cannot guarantee any particular transmission,
    because it relies on IP, which is unreliable. All it can do is keep trying if
    an initial delivery attempt fails.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP通过检测失败的传输并重新发送它们来提供可靠的通信。它不能保证任何特定的传输，因为它依赖于不可靠的IP。它所能做的就是如果初始交付尝试失败，就不断尝试。'
- en: TCP Characteristics
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP特性
- en: In many ways, it is more interesting to look at how TCP does its job than the
    functions of the job. By examining the most important attributes of TCP and its
    operation, you can get a better handle on the way TCP works. You can also see
    the many ways that it contrasts with its simpler transport layer sibling, UDP.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，研究TCP如何完成其工作比研究其功能更有趣。通过检查TCP及其操作的最重要属性，你可以更好地了解TCP的工作方式。你还可以看到它与其更简单的传输层兄弟UDP相比的许多不同之处。
- en: 'TCP has the following characteristics, which allow it to perform its functions:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: TCP具有以下特性，使其能够执行其功能：
- en: '**Connection-Oriented** TCP requires that devices first establish a connection
    with each other before they send data. The connection creates the equivalent of
    a circuit between the units; it is analogous to a telephone call. A process of
    negotiation occurs, and that process establishes the connection, thereby ensuring
    that both devices agree on how they will exchange data.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向连接**的TCP要求设备在发送数据之前首先相互建立连接。这种连接在单元之间创建了一个相当于电路的连接；它类似于电话通话。发生一个协商过程，这个过程建立了连接，从而确保两个设备都同意他们如何交换数据。'
- en: '**Bidirectional** Once a connection is established, TCP devices send data bidirectionally.
    Both devices on the connection can send and receive, regardless of which one initiated
    the connection.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**双向** 一旦建立了连接，TCP设备就双向发送数据。连接上的两个设备都可以发送和接收，无论哪个设备启动了连接。'
- en: '**Multiply Connected and Endpoint Identified** The pair of sockets used by
    the two devices in the connection identifies the endpoints of the TCP connection.
    This identification method allows each device to have multiple connections opened,
    either to the same IP device or different IP devices, and to handle each connection
    independently without conflicts.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**多连接和端点识别** 用于连接的两个设备使用的套接字对标识了TCP连接的端点。这种识别方法允许每个设备打开多个连接，无论是到同一个IP设备还是不同的IP设备，并且可以独立处理每个连接，而不会发生冲突。'
- en: '**Reliable** Communication using TCP is said to be reliable because TCP keeps
    track of data that has been sent and received to ensure that all the data gets
    to its destination. As you saw in the previous section earlier, TCP can''t really
    guarantee that data will always be received. However, it can guarantee that all
    data sent will be checked for reception, checked for data integrity, and then
    retransmitted when needed.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠** 使用TCP的通信被认为是可靠的，因为TCP跟踪已发送和接收的数据，以确保所有数据都到达目的地。正如你在前面的部分中看到的，TCP实际上不能保证数据总是会被接收。然而，它可以保证所有发送的数据都会被检查接收情况，检查数据完整性，并在需要时重新传输。'
- en: '**Acknowledged** A key to providing reliability is that TCP acknowledges all
    transmissions at the TCP layer. Furthermore, TCP cannot guarantee that the remote
    application will receive all such transmissions. The recipient must tell the sender,
    "Yes, I got that" for each piece of data transferred. This is in stark contrast
    to typical messaging protocols in which the sender never knows what happened to
    its transmission. As you will see, this acknowledgment is fundamental to the operation
    of TCP as a whole.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**确认** 提供可靠性的关键是TCP层确认所有传输。此外，TCP不能保证远程应用程序会接收到所有这些传输。接收方必须告诉发送方，“是的，我收到了”每份数据传输。这与典型的消息协议形成鲜明对比，在典型的消息协议中，发送者永远不知道其传输发生了什么。正如你将看到的，这种确认是TCP整体操作的基础。'
- en: '**Stream-Oriented** Most lower-layer protocols are designed so that higher-layer
    protocols must send them data in blocks in order to use them. IP is the best example
    of this; you send it a message to be formatted and IP puts that message into a
    datagram. UDP works the same way. In contrast, TCP allows applications to send
    it a continuous stream of data for transmission. Applications don''t need to worry
    about dividing this stream into chunks for transmission; TCP does it.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向流** 大多数底层协议被设计成，为了使用它们，高层协议必须以块的形式发送数据。IP是这方面的最佳例子；你发送一个要格式化的消息给IP，IP将其放入数据报。UDP也是这样工作的。相比之下，TCP允许应用程序发送连续的数据流进行传输。应用程序不需要担心将这个流分成块进行传输；TCP会处理这一点。'
- en: '**Unstructured Data** An important consequence of TCP''s stream orientation
    is that there are no natural divisions between data elements in the application''s
    data stream. When multiple messages are sent over TCP, applications must provide
    a way of differentiating one message (data element, record, and so on) from the
    next.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**无结构数据** TCP的流导向特性的重要后果是，在应用程序的数据流中，数据元素之间没有自然的分隔。当通过TCP发送多个消息时，应用程序必须提供一种方法来区分一条消息（数据元素、记录等）与下一条消息。'
- en: '**Managed Data Flow** TCP does more than just package data and send it as fast
    as possible. A TCP connection is managed to ensure that data flows evenly and
    smoothly and that connection includes the ability to deal with problems that arise
    along the way.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理数据流** TCP不仅仅是将数据打包并发送得尽可能快。TCP连接被管理以确保数据均匀、平滑地流动，并且该连接包括处理沿途出现问题的能力。'
- en: You'll notice that I have not listed "slow" as one of TCP's characteristics.
    It is true that applications use UDP for performance reasons when they don't want
    to deal with the overhead that TCP incorporates for connections and reliability.
    That, however, should not lead you to conclude that TCP is glacially slow. It
    is in fact quite efficient—were it not, it's unlikely that it would have ever
    achieved such widespread use.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我没有把“慢”列为TCP的特性之一。确实，当应用程序出于性能原因不想处理TCP为连接和可靠性所包含的额外开销时，它们会使用UDP。然而，这并不意味着TCP非常慢。实际上，它非常高效——如果不是这样，它可能永远不会得到如此广泛的应用。
- en: Tip
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To summarize TCP''s key characteristics, we can say that it
    is connection-oriented, bidirectional, multiply connected, reliable, acknowledged,
    stream-oriented, and flow-managed.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了总结TCP的关键特性，我们可以这样说：它是面向连接的、双向的、多连接的、可靠的、确认的、面向流的，并且管理流量。'
- en: The Robustness Principle
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**鲁棒性原则**'
- en: 'The TCP standard says that TCP follows the *robustness principle*, which is
    described in this way: "Be conservative in what you do; be liberal in what you
    accept from others." This rule means that every TCP implementation tries to avoid
    doing anything that would cause a problem for another device''s TCP layer. At
    the same time, every TCP implementation is also trying to anticipate problems
    that another TCP may cause and attempting to deal with those problems gracefully.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: TCP标准指出，TCP遵循*鲁棒性原则*，其描述如下：“在做什么方面要保守；在从别人那里接受什么方面要宽容。”这条规则意味着每个TCP实现都试图避免做任何可能给其他设备的TCP层造成问题的任何事情。同时，每个TCP实现也在尝试预测其他TCP可能引起的问题，并试图优雅地处理这些问题。
- en: This principle represents a "belt and suspenders" approach that helps provide
    extra protection against unusual conditions in TCP operation. In fact, this general
    principle is applied to many other protocols in the TCP/IP protocol suite, which
    is part of the reason why it has proven to be so capable over the years. The principle
    allows TCP and other protocols to deal with unanticipated problems that might
    show up in the difficult environment of a large internetwork such as the Internet.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则代表了一种“双重保险”的方法，有助于在TCP操作中提供额外的保护，以应对异常情况。实际上，这个一般原则被应用于TCP/IP协议套件中的许多其他协议，这也是它多年来证明如此强大的部分原因。这个原则允许TCP和其他协议处理在大规模互联网（如互联网）的困难环境中可能出现的不预期问题。
- en: Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第46章. 传输控制协议（TCP）基础和一般操作
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Many people have a difficult time understanding how the Transmission Control
    Protocol (TCP) works. After spending dozens of hours writing almost 100 pages
    on the protocol, I am quite sympathetic! I think a main reason for the difficulty
    is that many descriptions of the protocol leap too quickly from a brief introduction
    straight into the mind-boggling details of TCP's operation. The problem is that
    TCP works in a very particular way. Its operation is built around a few very important
    fundamentals that you absolutely must understand before the details of TCP operation
    will make much sense.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人很难理解传输控制协议（TCP）的工作原理。在花费了数十个小时撰写了近100页关于该协议的文档后，我深感同情！我认为困难的主要原因在于，许多关于该协议的描述过于迅速地从简短的介绍跳到了TCP操作的令人困惑的细节。问题是TCP以一种非常特殊的方式工作。其操作建立在几个非常重要的基本原理之上，你绝对必须理解这些原理，否则TCP操作细节将难以理解。
- en: In this chapter, I describe some of the key operating fundamentals of TCP. I
    begin with a discussion of how TCP handles data and introduce the concepts of
    streams, segments, and sequences. I then describe the very important TCP sliding
    window system, which is used for acknowledgment, reliability, and data flow control.
    I discuss how TCP uses ports and how it identifies connections. I also describe
    the most important applications that use TCP and what ports they use for server
    applications.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了TCP的一些关键操作原理。我首先讨论了TCP如何处理数据，并介绍了流、段和序列的概念。然后，我描述了非常重要的TCP滑动窗口系统，该系统用于确认、可靠性和数据流控制。我还讨论了TCP如何使用端口以及如何识别连接。我还描述了使用TCP的最重要应用以及它们用于服务器应用所使用的端口。
- en: TCP Data Handling and Processing
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP数据处理和处理
- en: One of the givens in the operation of most of the protocols you'll find at upper
    layers in the OSI Reference Model is that the protocols are oriented around the
    use of messages. These messages are analogous to a written letter in an envelope
    that contains a specific piece of information. They are passed from higher layers
    down to lower ones, where they are encapsulated in the lower layers' headers (like
    putting them in another envelope), and then passed down further until they are
    actually sent out at the physical layer.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI参考模型上层中大多数协议的操作中，一个既定的事实是，这些协议是围绕消息的使用而构建的。这些消息类似于一个包含特定信息的信件，放在一个信封里。它们从高层传递到低层，在那里它们被封装在低层头部（就像放入另一个信封一样），然后继续向下传递，直到它们在物理层实际发送出去。
- en: You can see a good example of this by looking at the User Datagram Protocol
    (UDP), TCP's transport layer peer. To use UDP, an application passes it a distinct
    block of data that is usually fairly short. The block is packaged into a UDP message,
    then sent to the Internet Protocol (IP). IP packs the message into an IP datagram
    and eventually passes it to a layer 2 protocol such as Ethernet. There, IP places
    it into a frame and sends it to layer 1 for transmission.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看用户数据报协议（UDP），TCP的传输层对等协议，来看到一个很好的例子。要使用UDP，应用程序将其一个独特的、通常相当短的数据块传递给它。该块被封装成一个UDP消息，然后发送到互联网协议（IP）。IP将消息打包成一个IP数据报，最终将其传递给第二层协议，如以太网。在那里，IP将其放入一个帧中，然后发送到第一层进行传输。
- en: 'Increasing the Flexibility of Application Data Handling: TCP''s Stream Orientation'
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高应用程序数据处理灵活性：TCP的流导向
- en: The use of discrete messaging is pretty simple, and it obviously works well
    enough since most protocols make use of it. However, it is inherently limiting
    because it forces applications to create discrete blocks of data in order to communicate.
    There are many applications that need to send information continuously in a manner
    that doesn't lend itself well to creating "chunks" of data. Others need to send
    data in chunks that are so large that applications could never send them as a
    single message at the lower layers.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用离散消息的使用相当简单，并且显然工作得很好，因为大多数协议都使用了它。然而，它本质上是有局限性的，因为它迫使应用程序创建离散的数据块以进行通信。有许多应用程序需要连续发送信息，这种方式不适合创建“数据块”。其他应用程序需要发送的数据块如此之大，以至于应用程序根本无法在较低层作为单个消息发送它们。
- en: To use a protocol like UDP, many applications would be forced to artificially
    divide their data into messages of a size that has no inherent meaning to them.
    This would immediately introduce new problems that would require more work for
    the application. The application would have to keep track of what data is in what
    message, and replace any data that was lost. It would need to ensure that the
    messages could be reassembled in the correct order, since IP might deliver them
    out of order.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用像UDP这样的协议，许多应用程序将被迫人为地将它们的数据分成没有固有意义的消息大小。这会立即引入新的问题，需要应用程序做更多的工作。应用程序必须跟踪哪些数据在哪个消息中，并替换任何丢失的数据。它需要确保消息可以被正确顺序地重新组装，因为IP可能会以错误的顺序交付它们。
- en: Of course, you could program applications to do this, but it would make little
    sense, because these functions are already ones that TCP is charged with handling.
    Instead, the TCP designers took the very smart approach of generalizing TCP so
    that it could accept application data of any size and structure without requiring
    the data to be in discrete pieces. More specifically, TCP treats data coming from
    an application as a *stream*—thus, the description of TCP as *stream-oriented*.
    Each application sends the data it wishes to transmit as a steady stream of octets
    (bytes). The application doesn't need to carve the data into blocks or worry about
    how lengthy streams will get across the internetwork. It just "pumps bytes" to
    TCP.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以编写应用程序来执行此操作，但这几乎没有意义，因为这些功能已经是TCP负责处理的功能。相反，TCP的设计者采取了非常聪明的通用化TCP的方法，使其能够接受任何大小和结构的应用程序数据，而无需要求数据是离散的部分。更具体地说，TCP将来自应用程序的数据视为**流**——因此，TCP被描述为**面向流的**。每个应用程序将希望传输的数据作为稳定的字节流（字节）发送。应用程序不需要将数据分割成块或担心如何将长流传输到互联网。它只需“向TCP泵字节”。
- en: 'TCP Data Packaging: Segments'
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP数据打包：段
- en: TCP must take the bytes it gets from an application and send them using a network
    layer protocol, which is IP in this case. IP is a message-oriented protocol; it
    is not stream-oriented. Thus, we have simply "passed the buck" to TCP, which must
    take the stream from the application and divide it into discrete messages for
    IP. These messages are called *TCP segments*.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: TCP必须从应用程序接收字节，并使用网络层协议发送它们，在这种情况下是IP。IP是一个面向消息的协议；它不是面向流的。因此，我们只是“推卸责任”给了TCP，它必须从应用程序接收流并将其分割成离散的消息供IP使用。这些消息被称为**TCP段**。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Segment *is one of the most confusing data structure names in the world of networking.
    From a dictionary definition standpoint, referring to a piece of a stream as a*
    segment *is sensible, but most people working with networks don't think of a message
    as being a segment. In the industry, the term also refers to a length of cable
    or a part of a local area network (LAN), among other things, so watch out for
    that*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 段**是网络世界中最为混乱的数据结构名称之一。从词典定义的角度来看，将流的一部分称为**段**是有意义的，但大多数与网络打交道的人并不认为消息是一个段。在行业中，该术语还指代电缆的长度或局域网（LAN）的一部分，等等，所以要注意这一点**。
- en: 'IP treats TCP segments like all other discrete messages for transmission. IP
    places them into IP datagrams and transmits them to the destination device. The
    recipient unpackages the segments and passes them to TCP, which converts them
    back to a byte stream in order to send them to the application. This process is
    illustrated in [Figure 46-1](ch46.html#tcp_data_stream_processing_and_segment_p
    "Figure 46-1. TCP data stream processing and segment packaging TCP is different
    from most protocols because it does not require applications that use it to send
    data to it in messages. Once a TCP connection is set up, an application protocol
    can send TCP a steady stream of bytes that does not need to conform to any particular
    structure. TCP packages these bytes into segments that are sized based on a number
    of different parameters. These segments are passed to IP, where they are encapsulated
    into IP datagrams and transmitted. The receiving device reverses the process:
    Segments are removed from IP datagrams, and then the bytes are taken from the
    segments and passed up to the appropriate recipient application protocol as a
    byte stream.").'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: IP将TCP段视为所有其他离散消息进行传输。IP将它们放入IP数据报中，并将它们传输到目标设备。接收方解包段并将它们传递给TCP，TCP将它们转换回字节流以便发送到应用程序。这个过程在[图46-1](ch46.html#tcp_data_stream_processing_and_segment_p
    "图46-1. TCP数据流处理和段封装 TCP与大多数协议不同，因为它不要求使用它的应用程序以消息的形式向它发送数据。一旦建立TCP连接，应用程序协议就可以向TCP发送一个稳定的字节流，这个字节流不需要遵循任何特定的结构。TCP将这些字节打包成基于多个不同参数大小的段。这些段被传递给IP，在那里它们被封装成IP数据报并传输。接收设备执行相反的过程：从IP数据报中移除段，然后从段中取出字节，并将它们作为字节流传递给适当的接收应用程序协议。")中说明。
- en: Tip
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** TCP is designed to have applications send data to it as a stream
    of bytes, rather than requiring fixed-size messages to be used. This provides
    maximum flexibility for a wide variety of uses, because applications don''t need
    to worry about data packaging and can send files or messages of any size. TCP
    takes care of packaging these bytes into messages called *segments*.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP被设计为让应用程序以字节流的形式向它发送数据，而不是要求使用固定大小的消息。这为各种用途提供了最大的灵活性，因为应用程序不需要担心数据打包，可以发送任何大小的文件或消息。TCP负责将这些字节打包成称为**段**的消息。'
- en: The TCP layer on a device accumulates data that it receives from the application
    process stream. On regular intervals, the TCP layer forms segments that it will
    transmit using IP. Two primary factors control the size of the segment. First,
    there is an overall limit to the size of a segment, chosen to prevent unnecessary
    fragmentation at the IP layer. A parameter called the *maximum segment size (MSS)*
    governs this size limit. The MSS is determined during connection establishment.
    Second, TCP is designed so that once a connection is set up, each of the devices
    tells the other how much data it is ready to accept at any given time. If the
    data is lower than the MSS value, the device must send a smaller segment. This
    is part of the sliding window system described a little later in this chapter.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 设备上的TCP层会累积从应用程序进程流接收到的数据。在常规间隔内，TCP层会形成它将通过IP传输的段。有两个主要因素控制段的大小。首先，有一个段大小的整体限制，这是为了防止在IP层发生不必要的分段。一个称为**最大段大小（MSS）**的参数控制这个大小限制。MSS在连接建立期间确定。其次，TCP被设计成一旦建立连接，每个设备都会告诉对方它随时准备接受多少数据。如果数据量低于MSS值，设备必须发送更小的段。这是本章稍后描述的滑动窗口系统的一部分。
- en: 'TCP Data Identification: Sequence Numbers'
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP数据标识：序列号
- en: The fact that TCP treats data coming from an application as a stream of octets
    has a couple of very significant implications for the operation of the protocol.
    The first is related to data identification. Since TCP is reliable, it needs to
    keep track of all the data it receives from an application so it can make sure
    that the destination receives all the data. Furthermore, TCP must make sure that
    the destination receives the data in the order that the application sent it, and
    the destination must retransmit any lost data.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: TCP将来自应用程序的数据视为字节流的事实，对协议的操作有几个非常重大的影响。第一个与数据标识相关。由于TCP是可靠的，它需要跟踪从应用程序接收到的所有数据，以确保目标接收所有数据。此外，TCP必须确保目标以应用程序发送数据的顺序接收数据，并且目标必须重新传输任何丢失的数据。
- en: If a device conveyed data to TCP in block-like messages, it would be fairly
    simple to keep track of the data by adding an identifier to each message. Because
    TCP is stream-oriented, however, that identification must be done for each byte
    of data! This may seem surprising, but it is actually what TCP does through the
    use of sequence numbers. Each byte of data is assigned a sequence number that
    is used to keep track of it through the process of transmission, reception, and
    acknowledgment (though in practice, blocks of many bytes are managed using the
    sequence numbers of bytes at the start and end of the block). These sequence numbers
    are used to ensure that the sending application transmits and reassembles the
    segmented data into the original stream of data. The sequence numbers are required
    to implement the sliding window system, which enables TCP to provide reliability
    and data flow control.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个设备以块状消息的形式将数据传递给 TCP，那么通过给每个消息添加一个标识符来跟踪数据将相对简单。然而，由于 TCP 是面向流的，这种标识必须对每个数据字节进行！这可能会让人感到惊讶，但实际上这正是
    TCP 通过使用序列号来实现的。每个数据字节都被分配一个序列号，用于在传输、接收和确认过程中跟踪它（尽管在实践中，使用块的开头和结尾的字节序列号来管理多个字节的块）。这些序列号用于确保发送应用程序传输并重新组装分段数据成为原始数据流。序列号是实施滑动窗口系统所必需的，这使
    TCP 能够提供可靠性和数据流控制。
- en: '![TCP data stream processing and segment packaging TCP is different from most
    protocols because it does not require applications that use it to send data to
    it in messages. Once a TCP connection is set up, an application protocol can send
    TCP a steady stream of bytes that does not need to conform to any particular structure.
    TCP packages these bytes into segments that are sized based on a number of different
    parameters. These segments are passed to IP, where they are encapsulated into
    IP datagrams and transmitted. The receiving device reverses the process: Segments
    are removed from IP datagrams, and then the bytes are taken from the segments
    and passed up to the appropriate recipient application protocol as a byte stream.](httpatomoreillycomsourcenostarchimages288089.png.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![TCP 数据流处理和分段封装 TCP 与大多数协议不同，因为它不需要使用它的应用程序以消息的形式向它发送数据。一旦建立 TCP 连接，应用程序协议就可以向
    TCP 发送一个稳定的字节流，这些字节不需要遵循任何特定的结构。TCP 将这些字节打包成基于多个不同参数大小的段。这些段被传递给 IP，在那里它们被封装成
    IP 数据报并传输。接收设备会逆转这个过程：从 IP 数据报中移除段，然后从段中取出字节，并将它们作为字节流传递到适当的接收应用程序协议。](http://atomoreilly.com/source/nostarch/images/288089.png.jpg)'
- en: 'Figure 46-1. TCP data stream processing and segment packaging TCP is different
    from most protocols because it does not require applications that use it to send
    data to it in messages. Once a TCP connection is set up, an application protocol
    can send TCP a steady stream of bytes that does not need to conform to any particular
    structure. TCP packages these bytes into segments that are sized based on a number
    of different parameters. These segments are passed to IP, where they are encapsulated
    into IP datagrams and transmitted. The receiving device reverses the process:
    Segments are removed from IP datagrams, and then the bytes are taken from the
    segments and passed up to the appropriate recipient application protocol as a
    byte stream.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 46-1. TCP 数据流处理和分段封装 TCP 与大多数协议不同，因为它不需要使用它的应用程序以消息的形式向它发送数据。一旦建立 TCP 连接，应用程序协议就可以向
    TCP 发送一个稳定的字节流，这些字节不需要遵循任何特定的结构。TCP 将这些字节打包成基于多个不同参数大小的段。这些段被传递给 IP，在那里它们被封装成
    IP 数据报并传输。接收设备会逆转这个过程：从 IP 数据报中移除段，然后从段中取出字节，并将它们作为字节流传递到适当的接收应用程序协议。
- en: Tip
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Since TCP works with individual bytes of data rather than discrete
    messages, it must use an identification scheme that works at the byte level to
    implement its data transmission and tracking system. This is accomplished by assigning
    a sequence number to each byte that TCP processes.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于 TCP 与单个数据字节而不是离散消息一起工作，它必须使用在字节级别上工作的标识方案来实现其数据传输和跟踪系统。这是通过为 TCP
    处理的每个字节分配一个序列号来实现的。'
- en: The Need for Application Data Delimiting
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用数据定界的需求
- en: When TCP treats incoming data as a stream, the data the application using TCP
    receives is called *unstructured*. For transmission, a stream of data goes into
    TCP on the sending device, and on reception, a stream of data goes back to the
    application on the receiving device. Even though TCP breaks the stream into segments
    for transmission, these segments are TCP-level details that remain hidden from
    the application. When a device wants to send multiple pieces of data, TCP provides
    no mechanism for indicating where the dividing line is between the pieces, since
    TCP doesn't examine the meaning of the data. The application must provide a means
    for doing this.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当TCP将传入数据视为流时，使用TCP的应用程序接收到的数据被称为**非结构化**。在传输过程中，数据流进入发送设备上的TCP，在接收过程中，数据流返回接收设备上的应用程序。尽管TCP将流分解成段进行传输，但这些段是TCP级别的细节，对应用程序来说是隐藏的。当设备想要发送多个数据块时，TCP不提供指示这些数据块之间分隔线的机制，因为TCP不检查数据的含义。应用程序必须提供一种方法来做这件事。
- en: Consider, for example, an application that is sending database records. It needs
    to transmit record 579 from the Employees database table, followed by record 581
    and record 611\. It sends these records to TCP, which treats them all collectively
    as a stream of bytes. TCP will package these bytes into segments, but in a way
    that the application cannot predict. It is possible that each byte will end up
    in a different segment, but more likely that they will all be in one segment,
    or that part of each will end up in different segments, depending on their length.
    The records must have some sort of explicit markers so that the receiving device
    can tell where one record ends and the next starts.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个发送数据库记录的应用程序为例。它需要传输来自Employees数据库表的记录579，然后是记录581和记录611。它将这些记录发送给TCP，TCP将它们作为一个字节流整体处理。TCP会将这些字节打包成段，但以应用程序无法预测的方式。每个字节最终可能出现在不同的段中，但更有可能它们都在一个段中，或者每个记录的一部分最终出现在不同的段中，这取决于它们的长度。记录必须有一些明确的标记，以便接收设备可以知道一个记录在哪里结束，下一个在哪里开始。
- en: Tip
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since applications send data to TCP as a stream of bytes as
    opposed to prepackaged messages, each application must use its own scheme to determine
    where one application data element ends and the next begins.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于应用程序将数据作为字节流而不是预包装的消息发送给TCP，因此每个应用程序都必须使用自己的方案来确定一个应用程序数据元素在哪里结束，下一个在哪里开始。'
- en: TCP Sliding Window Acknowledgment System
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP滑动窗口确认系统
- en: 'What differentiates TCP from simpler transport protocols like UDP is the quality
    of the manner in which it sends data between devices. Rather than just sticking
    data in a message and saying, "off you go," TCP carefully keeps track of the data
    it sends. This management of data is required to facilitate the following two
    key requirements of the protocol:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与像UDP这样的简单传输协议相比，TCP与设备之间发送数据的方式的质量不同。TCP不会只是将数据放入消息中，然后说“出发”，而是仔细跟踪它发送的数据。这种数据管理对于满足协议的两个关键要求是必要的：
- en: '**Reliability** Ensuring that data that is sent actually arrives at its destination,
    and if it doesn''t arrive, detecting this and resending it.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**可靠性** 确保发送的数据实际上到达了目的地，如果没有到达，检测到这一点并重新发送。'
- en: '**Data Flow Control** Managing the rate at which data is sent so that it does
    not overwhelm the device that is receiving it.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据流控制** 管理发送数据的速率，以确保它不会使接收设备超载。'
- en: To accomplish these tasks, the entire operation of the protocol is oriented
    around something called the *sliding window acknowledgment system*. It is no exaggeration
    to say that comprehending how sliding windows work is critical to understanding
    just about everything else in TCP. It is also, unfortunately, a bit hard to follow
    if you try to grasp it all at once. I wanted to make sure that I explained the
    mechanism thoroughly without assuming that you already understood it. For this
    reason, I am going to start by explaining the concepts behind sliding windows,
    particularly how the technique works and why it is so powerful.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这些任务，整个协议的操作都是围绕所谓的**滑动窗口确认系统**进行的。说理解滑动窗口的工作方式对于理解TCP中的几乎所有其他内容至关重要，这并不夸张。不幸的是，如果你试图一次性掌握它，这可能会有些难以理解。我想确保我详细解释了机制，而不假设你已经理解了它。因此，我将从解释滑动窗口背后的概念开始，特别是这项技术是如何工作的以及为什么它如此强大。
- en: 'The Problem with Unreliable Protocols: Lack of Feedback'
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可靠协议的问题：缺乏反馈
- en: 'A simple "send and forget" protocol like IP is unreliable and includes no flow
    control for one main reason: It is an open-loop system in which the transmitter
    receives no feedback from the recipient. (I am ignoring error reports using ICMP
    and the like for the purpose of this discussion.) A datagram is sent, and it may
    or may not get there, but the transmitter will never have any way of knowing because
    there is no mechanism for feedback. This concept is illustrated in [Figure 46-2](ch46s02.html#operation_of_an_unreliable_protocol_in_a
    "Figure 46-2. Operation of an unreliable protocol In a system such as the one
    that IP uses, if a message gets to its destination, that''s great; otherwise,
    nobody will have a clue. Some external mechanism is needed to take care of the
    lost message, unless the protocol doesn''t really care whether a few bits and
    pieces are missing from its message stream.").'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的“发送后即忘”协议，如 IP，是不可靠的，并且没有流量控制，主要原因在于它是一个开环系统，其中发送者无法从接收者那里获得反馈。（在此讨论中，我忽略了使用
    ICMP 等方式发送的错误报告。）发送了一个数据报，它可能到达也可能不到达，但发送者将永远无法知道，因为没有反馈机制。这一概念在[图 46-2](ch46s02.html#operation_of_an_unreliable_protocol_in_a
    "图 46-2. 不可靠协议的运行图 46-2. 在一个像 IP 所使用的系统，如果一条消息成功到达目的地，那当然很好；否则，没有人会知道发生了什么。需要某种外部机制来处理丢失的消息，除非协议根本不在乎其消息流中是否缺少一些比特和片段。")中得到了说明。
- en: '![Operation of an unreliable protocol In a system such as the one that IP uses,
    if a message gets to its destination, that''s great; otherwise, nobody will have
    a clue. Some external mechanism is needed to take care of the lost message, unless
    the protocol doesn''t really care whether a few bits and pieces are missing from
    its message stream.](httpatomoreillycomsourcenostarchimages288091.png.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![不可靠协议的运行图 46-2. 在一个像 IP 所使用的系统，如果一条消息成功到达目的地，那当然很好；否则，没有人会知道发生了什么。需要某种外部机制来处理丢失的消息，除非协议根本不在乎其消息流中是否缺少一些比特和片段。](httpatomoreillycomsourcenostarchimages288091.png.jpg)'
- en: Figure 46-2. Operation of an unreliable protocol In a system such as the one
    that IP uses, if a message gets to its destination, that's great; otherwise, nobody
    will have a clue. Some external mechanism is needed to take care of the lost message,
    unless the protocol doesn't really care whether a few bits and pieces are missing
    from its message stream.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图 46-2. 不可靠协议的运行在一个像 IP 所使用的系统，如果一条消息成功到达目的地，那当然很好；否则，没有人会知道发生了什么。需要某种外部机制来处理丢失的消息，除非协议根本不在乎其消息流中是否缺少一些比特和片段。
- en: Providing Basic Reliability Using Positive Acknowledgment with Retransmission
    (PAR)
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用带有重传的正确认认（PAR）提供基本可靠性
- en: Basic reliability in a protocol running over an unreliable protocol like IP
    can be implemented by closing the loop so the recipient provides feedback to the
    sender. This is most easily done with a simple acknowledgment system. Device A
    sends a piece of data to Device B, which receives the data and sends back an acknowledgment
    saying, "Device A, I received your message." Device A then knows its transmission
    was successful.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 IP 这样的不可靠协议上运行的协议中的基本可靠性可以通过关闭循环来实现，使接收者向发送者提供反馈。这最简单的方法是使用一个简单的确认系统。设备 A
    向设备 B 发送数据，设备 B 接收数据并发送一个确认信息说：“设备 A，我已收到你的消息。”然后设备 A 就知道它的传输是成功的。
- en: But since IP is unreliable, that message may in fact never get to where it is
    going. Device A will sit and wait for the acknowledgment and never receive it.
    Conversely, it is also possible that Device B gets the message from Device A,
    but the acknowledgment itself vanishes somehow. In either case, we don't want
    Device A to sit forever waiting for an acknowledgment that is never going to arrive.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于 IP 是不可靠的，那条消息实际上可能永远无法到达目的地。设备 A 会坐等确认，但永远不会收到。相反，也有可能设备 B 从设备 A 那里收到了消息，但确认信息本身却神秘消失了。在两种情况下，我们都不希望设备
    A 永远等待一个永远不会到达的确认。
- en: 'To prevent this from happening, Device A starts a timer when it first sends
    the message to Device B, which allows sufficient time for the message to get to
    Device B and for the acknowledgment to travel back, plus some reasonable time
    to allow for possible delays. If the timer expires before the acknowledgment is
    received, Device A assumes that there was a problem and retransmits its original
    message. Since this method involves positive acknowledgments ("Yes, I got your
    message") and a facility for retransmission when needed, it is commonly called
    *positive acknowledgment with retransmission (PAR)*, as shown in [Figure 46-3](ch46s02.html#basic_reliability_positive_acknowledgmen
    "Figure 46-3. Basic reliability: positive acknowledgment with retransmission (PAR)
    This diagram shows one of the most common and simple techniques for ensuring reliability.
    Each time Device A sends a message, it starts a timer. Device B sends an acknowledgment
    back to Device A when it receives a message, so that Device A knows that it successfully
    transmitted the message. If a message is lost, the timer goes off, and Device
    A retransmits the data. Note that only one message can be outstanding at any time,
    making this system rather slow.").'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，设备A在首次向设备B发送消息时启动一个计时器，这允许足够的时间让消息到达设备B，确认消息返回，以及一些合理的时间来应对可能的延迟。如果在收到确认消息之前计时器已经到期，设备A会假设存在问题并重新传输其原始消息。由于这种方法涉及肯定确认（“是的，我收到了你的消息”）以及在需要时进行重传的功能，它通常被称为*带重传的肯定确认（PAR）*，如[图46-3](ch46s02.html#basic_reliability_positive_acknowledgmen
    "图46-3. 基本可靠性：带重传的肯定确认（PAR）此图展示了确保可靠性最常见和简单的方法之一。每次设备A发送消息时，它都会启动一个计时器。设备B在接收到消息后，会向设备A发送一个确认消息，这样设备A就知道消息已成功传输。如果消息丢失，计时器会超时，设备A会重新传输数据。请注意，任何时候只能有一个消息处于待处理状态，这使得该系统相当慢。")所示。
- en: '![Basic reliability: positive acknowledgment with retransmission (PAR) This
    diagram shows one of the most common and simple techniques for ensuring reliability.
    Each time Device A sends a message, it starts a timer. Device B sends an acknowledgment
    back to Device A when it receives a message, so that Device A knows that it successfully
    transmitted the message. If a message is lost, the timer goes off, and Device
    A retransmits the data. Note that only one message can be outstanding at any time,
    making this system rather slow.](httpatomoreillycomsourcenostarchimages288093.png.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![基本可靠性：带重传的肯定确认（PAR）此图展示了确保可靠性最常见和简单的方法之一。每次设备A发送消息时，它都会启动一个计时器。设备B在接收到消息后，会向设备A发送一个确认消息，这样设备A就知道消息已成功传输。如果消息丢失，计时器会超时，设备A会重新传输数据。请注意，任何时候只能有一个消息处于待处理状态，这使得该系统相当慢。](httpatomoreillycomsourcenostarchimages288093.png.jpg)'
- en: 'Figure 46-3. Basic reliability: positive acknowledgment with retransmission
    (PAR) This diagram shows one of the most common and simple techniques for ensuring
    reliability. Each time Device A sends a message, it starts a timer. Device B sends
    an acknowledgment back to Device A when it receives a message, so that Device
    A knows that it successfully transmitted the message. If a message is lost, the
    timer goes off, and Device A retransmits the data. Note that only one message
    can be outstanding at any time, making this system rather slow.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图46-3. 基本可靠性：带重传的肯定确认（PAR）此图展示了确保可靠性最常见和简单的方法之一。每次设备A发送消息时，它都会启动一个计时器。设备B在接收到消息后，会向设备A发送一个确认消息，这样设备A就知道消息已成功传输。如果消息丢失，计时器会超时，设备A会重新传输数据。请注意，任何时候只能有一个消息处于待处理状态，这使得该系统相当慢。
- en: Tip
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A basic technique for ensuring reliability in communications
    uses a rule that requires a device to send back an acknowledgment each time it
    successfully receives a transmission. If a device doesn''t acknowledge the transmission
    after a period of time, its sender retransmits the acknowledgment. This system
    is called *positive acknowledgment with retransmission (PAR)*. One drawback with
    this basic scheme is that the transmitter cannot send a second message until after
    the first device has acknowledged the first.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 确保通信可靠性的基本技术使用一条规则，要求设备在每次成功接收传输后发送一个确认。如果设备在一段时间后没有确认传输，其发送者会重新传输确认。这种系统被称为*带重传的肯定确认（PAR）*。这种基本方案的一个缺点是，在第一个设备确认第一个消息之前，发送者不能发送第二个消息。'
- en: PAR is a technique that is used widely in networking and communications for
    protocols that exchange relatively small amounts of data, or protocols that exchange
    data infrequently. The basic method is functional, but it is not well suited to
    a protocol like TCP. One main reason is that it is *inefficient*. Device A sends
    a message, and then waits for the acknowledgment. Device A cannot send another
    message to Device B until it hears that Device B received its original message,
    which is very wasteful and would make the protocol extremely slow.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: PAR是一种在计算机网络和通信中广泛使用的协议技术，用于交换相对较小的数据量或交换数据频率较低的协议。基本方法是功能性的，但并不适合像TCP这样的协议。一个主要原因是它*效率低下*。设备A发送一条消息，然后等待确认。设备A在收到设备B确认它已收到原始消息之前不能向设备B发送另一条消息，这是非常浪费的，会使协议变得极其缓慢。
- en: Improving PAR
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进PAR
- en: The first improvement we can make to the PAR system is to provide some means
    of identification to the messages that were sent, as well as the acknowledgments.
    For example, we could put a message ID field in the message header. The device
    sending the message would uniquely identify it, and the recipient would use this
    identifier in the acknowledgment. For example, Device A might send a piece of
    data in a message with the message ID 1\. Device B would receive the message and
    then send its own message back to Device A, saying "Device A, I received your
    message 1." The advantage of this system is that Device A can send multiple messages
    at once. It must keep track of each one that it sends, and whether or not Device
    B sent an acknowledgment. Each device also requires a separate timer, but that's
    not a big problem.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对PAR系统进行的第一个改进是为发送的消息以及确认提供一些识别手段。例如，我们可以在消息头中添加一个消息ID字段。发送消息的设备将唯一标识它，接收方将使用这个标识符在确认中。例如，设备A可能通过消息ID
    1发送一块数据。设备B将接收这条消息，然后向设备A发送自己的消息，说：“设备A，我已收到你的消息1。”这个系统的优点是设备A可以一次发送多条消息。它必须跟踪它发送的每一条消息，以及设备B是否发送了确认。每个设备还需要一个单独的计时器，但这不是什么大问题。
- en: Of course, we also need to consider this exchange from the standpoint of Device
    B. Before, Device B had to deal with only one message at a time from Device A.
    Now it may have several show up all at once. What if it is already busy with transmis-sions
    from another device (or ten)? We need some mechanism that lets Device B say, "I
    am only willing to handle the following number of messages from you at a time."
    We could do that by having the acknowledgment message contain a field, such as
    send limit, which specifies the maximum number of unacknowledged messages Device
    A was allowed to have in transit to Device B at one time.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要从设备B的角度考虑这种交换。以前，设备B一次只能处理来自设备A的一条消息。现在，它可能一次会有几条消息同时出现。如果设备B已经忙于处理来自其他设备（或十个设备）的传输怎么办？我们需要一种机制让设备B能够说：“我一次只能处理你发来的以下数量消息。”我们可以通过让确认消息包含一个字段，例如发送限制，来指定设备A一次允许发送给设备B的最大未确认消息数量。
- en: Device A would use this send limit field to restrict the rate at which it sent
    messages to Device B. Device B could adjust this field depending on its current
    load and other factors to maximize performance in its discussions with Device
    A. This enhanced system would thus provide reliability, efficiency, and basic
    data flow control, as illustrated in [Figure 46-4](ch46s02.html#enhanced_par_this_diagram_shows_two_enha
    "Figure 46-4. Enhanced PAR This diagram shows two enhancements to the basic PAR
    scheme from Figure 46-3\. First, each message now has an identification number;
    each can be acknowledged individually, so more than one message can be in transit
    at a given time. Second, Device B regularly communicates to Device A a send limit
    parameter, which restricts the number of messages Device A can have outstanding
    at once. Device B can adjust this parameter to control the flow of data from Device
    A.").
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 设备A将使用这个发送限制字段来限制它向设备B发送消息的速率。设备B可以根据其当前负载和其他因素调整这个字段，以最大化与设备A的通信性能。因此，这个增强的系统将提供可靠性、效率和基本的数据流控制，如图[图46-4](ch46s02.html#enhanced_par_this_diagram_shows_two_enha
    "图46-4. 增强的PAR 此图显示了图46-3中的基本PAR方案的两个增强。首先，每条消息现在都有一个识别号；每条消息都可以单独确认，因此一次可以有多个消息在传输。其次，设备B定期向设备A发送一个发送限制参数，该参数限制了设备A一次可以有多少未处理的消息。设备B可以调整这个参数来控制来自设备A的数据流。")所示。
- en: Tip
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The basic PAR reliability scheme can be enhanced by identifying
    each message to be sent, so multiple messages can be in transit at once. The use
    of a send limit allows the mechanism to also provide flow control capabilities,
    by allowing each device to control the rate at which other devices send data to
    it.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 通过标识要发送的每个消息，可以增强基本的PAR可靠性方案，这样一次可以有多个消息在传输中。发送限制的使用允许机制提供流量控制能力，通过允许每个设备控制其他设备向其发送数据的速率。'
- en: TCP's Stream-Oriented Sliding Window Acknowledgment System
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP的面向流的滑动窗口确认系统
- en: 'So does TCP use this variation on PAR? Of course not! That would be too simple.
    Conceptually, the TCP sliding window system is very similar to this method, which
    is why it is important that you understand it. However, it requires some adjustment.
    The main reason has to do with the way TCP handles data: the matter of stream
    orientation compared to message orientation discussed earlier in this chapter.
    The technique I have outlined involves explicit acknowledgments and (if necessary)
    retransmissions for messages. Thus, it would work well for a protocol that exchanged
    reasonably large messages on a fairly infrequent basis.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 那么TCP是否使用这种PAR的变体呢？当然不是！那会太简单了。从概念上讲，TCP滑动窗口系统与这种方法非常相似，这就是为什么理解它很重要。然而，它需要进行一些调整。主要原因与TCP处理数据的方式有关：与本章前面讨论的消息导向相比，这是流导向的问题。我概述的技术涉及对消息的显式确认和（如果需要）重传。因此，它非常适合交换相对较大消息且频率较低的协议。
- en: TCP, on the other hand, deals with individual bytes of data as a stream. Transmitting
    each byte one at a time and acknowledging each one at a time would quite obviously
    be absurd. It would require too much work, and even with overlapped transmissions
    (that is, not waiting for an acknowledgment before sending the next piece of data),
    the result would be horribly slow.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，TCP将数据字节视为一个流来处理。逐个字节发送并逐个确认显然是荒谬的。这将需要太多的工作，即使是在重叠传输的情况下（即，在发送下一份数据之前不等待确认），结果也会非常慢。
- en: '![Enhanced PAR This diagram shows two enhancements to the basic PAR scheme
    from . First, each message now has an identification number; each can be acknowledged
    individually, so more than one message can be in transit at a given time. Second,
    Device B regularly communicates to Device A a send limit parameter, which restricts
    the number of messages Device A can have outstanding at once. Device B can adjust
    this parameter to control the flow of data from Device A.](httpatomoreillycomsourcenostarchimages288095.png.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![增强的PAR 此图显示了从...的基本PAR方案的两个增强。首先，现在每个消息都有一个标识号；每个消息都可以单独确认，因此可以在给定时间内有多个消息在传输中。其次，设备B定期向设备A发送一个发送限制参数，该参数限制设备A一次可以有多少个待处理消息。设备B可以调整此参数以控制从设备A流向的数据流。](httpatomoreillycomsourcenostarchimages288095.png.jpg)'
- en: 'Figure 46-4. Enhanced PAR This diagram shows two enhancements to the basic
    PAR scheme from [Figure 46-3](ch46s02.html#basic_reliability_positive_acknowledgmen
    "Figure 46-3. Basic reliability: positive acknowledgment with retransmission (PAR)
    This diagram shows one of the most common and simple techniques for ensuring reliability.
    Each time Device A sends a message, it starts a timer. Device B sends an acknowledgment
    back to Device A when it receives a message, so that Device A knows that it successfully
    transmitted the message. If a message is lost, the timer goes off, and Device
    A retransmits the data. Note that only one message can be outstanding at any time,
    making this system rather slow."). First, each message now has an identification
    number; each can be acknowledged individually, so more than one message can be
    in transit at a given time. Second, Device B regularly communicates to Device
    A a send limit parameter, which restricts the number of messages Device A can
    have outstanding at once. Device B can adjust this parameter to control the flow
    of data from Device A.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图46-4. 增强的PAR 此图显示了从[图46-3](ch46s02.html#basic_reliability_positive_acknowledgmen
    "图46-3. 基本可靠性：带有重传的正确认认(PAR) 此图显示了确保可靠性最常见和简单的方法之一。每次设备A发送消息时，它都会启动一个计时器。设备B在接收到消息后向设备A发送确认，这样设备A就知道它成功传输了消息。如果消息丢失，计时器就会响起，设备A会重新传输数据。请注意，任何时候只能有一个消息处于待处理状态，这使得该系统相当慢。")的基本PAR方案的两个增强。首先，现在每个消息都有一个标识号；每个消息都可以单独确认，因此可以在给定时间内有多个消息在传输中。其次，设备B定期向设备A发送一个发送限制参数，该参数限制设备A一次可以有多少个待处理消息。设备B可以调整此参数以控制从设备A流向的数据流。
- en: This slowness is why TCP does not send bytes individually but divides them into
    segments. All of the bytes in a segment are sent together and received together,
    and thus acknowledged together. TCP uses a variation on the method I described
    earlier, in which the sequence numbers I discussed earlier identify the data sent
    and acknowledged. Instead of acknowledging the use of something like a message
    ID field, we acknowledge data using the sequence number of the last byte of data
    in the segment. Thus, we are dealing with a range of bytes in each case, and the
    range represents the sequence numbers of all the bytes in the segment.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这种延迟是为什么TCP不会单独发送字节，而是将它们分成段的原因。一个段中的所有字节都是一起发送和接收的，并且因此一起被确认。TCP使用了我之前描述的方法的变体，其中我之前讨论的序列号用于标识发送和确认的数据。我们不是通过使用类似消息ID字段的东西来确认使用，而是使用段中最后一个数据字节的序列号来确认数据。因此，我们正在处理每个情况下的字节范围，而这个范围代表了段中所有字节的序列号。
- en: Conceptual Division of TCP Transmission Stream into Categories
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TCP传输流分类的概念性划分
- en: Imagine a newly established TCP connection between Device A and Device B. Device
    A has a long stream of bytes that it will transmit, but Device B can't accept
    them all at once, so it limits Device A to sending a particular number of bytes
    at once in segments, until the bytes in the segments already sent have been acknowledged.
    Then Device A is allowed to send more bytes. Each device keeps track of which
    bytes have been sent and which have not, and which have been acknowledged.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下设备A和设备B之间新建立的TCP连接。设备A有一个长的字节流要传输，但设备B不能一次接受所有这些字节，因此它限制设备A一次只能发送特定数量的字节，直到已发送的段中的字节被确认。然后设备A被允许发送更多字节。每个设备都跟踪哪些字节已被发送和哪些尚未发送，以及哪些已被确认。
- en: 'At any point in time, we can take a "snapshot" of the process. If we do, we
    can conceptually divide the bytes that the sending TCP has in its buffer into
    the following four categories, and view them as a timeline (see [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories")):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，我们都可以对这个过程进行“快照”。如果我们这样做，我们可以从以下四个类别概念性地划分发送TCP缓冲区中的字节，并将它们视为时间线（参见[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流分类的概念性划分"))：
- en: '**Bytes Sent and Acknowledged** The earliest bytes in the stream will have
    been sent and acknowledged. These bytes are basically viewed from the standpoint
    of the device sending data. In the example in [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    31 bytes of data have already been sent and acknowledged. These would fall into
    category 1.'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**已发送并确认的字节** 流中最早的字节已经发送并被确认。这些字节基本上是从发送数据设备的视角来看待的。在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流分类的概念性划分")的例子中，已有31个字节数据被发送并确认。这些将属于类别1。'
- en: '**Bytes Sent but Not Yet Acknowledged** These are the bytes that the device
    has sent but for which it has not yet received an acknowledgment. The sender cannot
    consider these handled until they are acknowledged. In [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    there are 14 bytes here, in category 2.'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**已发送但尚未确认的字节** 这些是设备已发送但尚未收到确认的字节。发送方在收到确认之前不能认为这些字节已被处理。在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流分类的概念性划分")中，这里有14个字节，属于类别2。'
- en: '**Bytes Not Yet Sent for Which Recipient Is Ready** These are bytes that the
    device has not sent, but which the recipient has room for based on its most recent
    communication to the sender regarding how many bytes it is willing to handle at
    once. The sender will try to send these immediately (subject to certain algorithmic
    restrictions that you''ll explore later). In [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    there are 6 bytes in category 3.'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**尚未发送但接收方已准备好的字节** 这些是设备尚未发送，但根据其最近与发送方的通信（关于它一次愿意处理多少字节）而留有空间的字节。发送方将尝试立即发送这些字节（受某些算法限制，你将在后面探索）。在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流分类的概念性划分")中，类别3中有6个字节。'
- en: '**Bytes Not Yet Sent for Which Recipient Is Not Ready** These are the bytes
    further down the stream, which the sender is not yet allowed to send because the
    receiver is not ready. In [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    there are 44 bytes in category 4.'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**尚未发送且接收方尚未准备好的字节** 这些是流中更下面的字节，发送方尚未被允许发送，因为接收方尚未准备好。在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流的概念划分")中，类别4中有44个字节。'
- en: '![Conceptual division of TCP transmission stream into categories](httpatomoreillycomsourcenostarchimages288097.png.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![TCP传输流的概念划分](httpatomoreillycomsourcenostarchimages288097.png.jpg)'
- en: Figure 46-5. Conceptual division of TCP transmission stream into categories
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 图46-5. TCP传输流的概念划分
- en: Note
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I am using very small numbers here to keep the example simple and to make
    the diagrams a bit easier to construct! TCP does not normally send tiny numbers
    of bytes around for efficiency reasons*.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里使用非常小的数字来简化示例，并使图表更容易构建！出于效率原因，TCP通常不会发送大量字节*。'
- en: The receiving device uses a similar system in order to differentiate between
    data received and acknowledged, data not yet received but ready to receive, and
    data not yet received and not yet ready to be received. In fact, both devices
    maintain a separate set of variables to keep track of the categories into which
    bytes fall in the stream they are sending, as well as the stream they are receiving.
    This is explored further in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING
    AND DATA TRANSFER")'s section named "TCP Sliding Window Data Transfer and Acknowledgment
    Mechanics," which describes the detailed sliding window data transfer procedure.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 接收设备使用类似的系统来区分已接收并被确认的数据、尚未接收但准备接收的数据，以及尚未接收且尚未准备好接收的数据。实际上，两个设备都维护一组独立的变量来跟踪它们发送的流中字节所属的类别，以及它们接收的流。这将在第48章（ch48.html
    "第48章. TCP消息格式和数据传输"）的“TCP滑动窗口数据传输和确认机制”部分中进一步探讨，该部分描述了详细的滑动窗口数据传输过程。
- en: Tip
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The TCP *sliding* window system is a variation on the enhanced
    PAR system, with changes made to support TCP''s stream orientation. Each device
    keeps track of the status of the byte stream that it needs to transmit. The device
    keeps track by dividing the byte streams into four conceptual categories: bytes
    sent and acknowledged, bytes sent but not yet acknowledged, bytes not yet sent
    but that can be sent immediately, and bytes not yet sent that cannot be sent until
    the recipient signals that it is ready for them.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP *滑动窗口*系统是对增强型PAR系统的一种变体，对系统进行了修改以支持TCP的流方向。每个设备都会跟踪它需要发送的字节流的状态。设备通过将字节流划分为四个概念类别来跟踪状态：已发送并被确认的字节、已发送但尚未被确认的字节、尚未发送但可以立即发送的字节，以及尚未发送且在接收方表示准备好接收之前不能发送的字节。'
- en: Sequence Number Assignment and Synchronization
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列号分配和同步
- en: 'The sender and receiver must agree on the sequence numbers that they will assign
    to the bytes in the stream. This is called *synchronization* and is done when
    the TCP connection is established. For simplicity, let''s assume that the first
    byte was sent with sequence number 1 (this is not normally the case). Thus, in
    the example shown in [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    the byte ranges for the four categories are as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方和接收方必须就它们将分配给流中字节的序列号达成一致。这被称为*同步*，并在TCP连接建立时完成。为了简单起见，让我们假设第一个字节是用序列号1发送的（这通常不是情况）。因此，在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流的概念划分")中显示的示例中，四个类别的字节范围如下：
- en: The bytes sent and acknowledged are bytes 1 to 31.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送并被确认的字节是第1到第31字节。
- en: The bytes sent but not yet acknowledged are bytes 32 to 45.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已发送但尚未被确认的字节是第32到第45字节。
- en: The bytes not yet sent for which the recipient is ready are bytes 46 to 51.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收方已准备好接收但尚未发送的字节是第46到第51字节。
- en: The bytes not yet sent for which the recipient is not ready are bytes 52 to
    95.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收方尚未准备好接收的字节是第52到第95字节。
- en: The Send Window and Usable Window
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送窗口和可用窗口
- en: The key to the operation of the entire process is the number of bytes that the
    recipient is allowing the transmitter to have unacknowledged at one time. This
    is called the *send window*, or often, just the *window*. The window is what determines
    how many bytes the sender is allowed to transmit, and is equal to the sum of the
    number of bytes in category 2 and category 3\. Thus, the dividing line between
    the last two categories (bytes not sent that the recipient is ready for and bytes
    the recipient is not ready for) is determined by adding the window to the byte
    number of the first unacknowledged byte in the stream. In the example shown in
    [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001 "Figure 46-5. Conceptual
    division of TCP transmission stream into categories"), the first unacknowledged
    byte is 32\. The total window size is 20.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程操作的关键是接收者允许发送者在一次时间内未确认的字节数。这被称为*发送窗口*，或者通常简称为*窗口*。窗口决定了发送者允许传输的字节数，等于类别2和类别3中字节数的总和。因此，最后两个类别（接收者已准备好接收的字节和接收者尚未准备好的字节）之间的分界线是由将窗口加到流中第一个未确认字节的字节数来确定的。在[图46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图46-5. TCP传输流的概念性分类")所示的示例中，第一个未确认的字节是32。总窗口大小为20。
- en: The term *usable window* is defined as the amount of data the transmitter is
    still allowed to send given the amount of data that is outstanding. It is thus
    exactly equal to the size of category 3\. You may also commonly hear the *edges*
    of the window mentioned. The left edge marks the first byte in the window (byte
    32). The right edge marks the last byte in the window (byte 51). See [Figure 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "Figure 46-6. TCP transmission stream categories and send window terminology This
    diagram shows the same categories as the ones in Figure 46-5, except that it shows
    the send window as well. The black box is the overall send window (categories
    2 and 3 combined); the light gray box represents the bytes already sent (category
    2), and the dark gray box is the usable window (category 3).") for an illustration
    of these concepts.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*可用窗口*定义为在给定未确认数据量的情况下，发送器仍允许发送的数据量。因此，它正好等于类别3的大小。你也许还会经常听到窗口的*边缘*被提及。左侧边缘标记窗口中的第一个字节（字节32）。右侧边缘标记窗口中的最后一个字节（字节51）。参见[图46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "图46-6. TCP传输流类别和发送窗口术语 此图显示了与图46-5中的相同类别，但同时也显示了发送窗口。黑色框表示整体发送窗口（类别2和3的组合）；浅灰色框表示已发送的字节（类别2），深灰色框表示可用窗口（类别3）")以了解这些概念。
- en: Tip
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The send *window* is the key to the entire TCP sliding window
    system. It represents the maximum number of unacknowledged bytes that a device
    is allowed to have outstanding at one time. The *usable window* is the amount
    of the send window that the sender is still allowed to send at any point in time;
    it is equal to the size of the send window less the number of unacknowledged bytes
    already transmitted.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 发送*窗口*是整个TCP滑动窗口系统的关键。它表示设备一次允许未确认的字节数的最大值。*可用窗口*是发送窗口中发送者仍允许在任何时间点发送的数据量；它等于发送窗口的大小减去已传输的未确认字节数。'
- en: '![TCP transmission stream categories and send window terminology This diagram
    shows the same categories as the ones in , except that it shows the send window
    as well. The black box is the overall send window (categories 2 and 3 combined);
    the light gray box represents the bytes already sent (category 2), and the dark
    gray box is the usable window (category 3).](httpatomoreillycomsourcenostarchimages288099.png.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![TCP传输流类别和发送窗口术语 此图显示了与图中的相同类别，但同时也显示了发送窗口。黑色框表示整体发送窗口（类别2和3的组合）；浅灰色框表示已发送的字节（类别2），深灰色框表示可用窗口（类别3）](httpatomoreillycomsourcenostarchimages288099.png.jpg)'
- en: Figure 46-6. TCP transmission stream categories and send window terminology
    This diagram shows the same categories as the ones in [Figure 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "Figure 46-5. Conceptual division of TCP transmission stream into categories"),
    except that it shows the send window as well. The black box is the overall send
    window (categories 2 and 3 combined); the light gray box represents the bytes
    already sent (category 2), and the dark gray box is the usable window (category
    3).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图 46-6. TCP 传输流类别和发送窗口术语 此图显示了与 [图 46-5](ch46s02.html#conceptual_division_of_tcp_transmi-id001
    "图 46-5. TCP 传输流的概念性分类") 中相同的类别，但同时也显示了发送窗口。黑色方框代表整体发送窗口（类别 2 和 3 合并）；浅灰色方框表示已发送的字节（类别
    2），深灰色方框是可用窗口（类别 3）。
- en: Changes to TCP Categories and Window Sizes After Sending Bytes in the Usable
    Window
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送可用窗口字节后的 TCP 类别和窗口大小更改
- en: 'Now let''s suppose that in the example shown in [Figure 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "Figure 46-6. TCP transmission stream categories and send window terminology This
    diagram shows the same categories as the ones in Figure 46-5, except that it shows
    the send window as well. The black box is the overall send window (categories
    2 and 3 combined); the light gray box represents the bytes already sent (category
    2), and the dark gray box is the usable window (category 3).") there is nothing
    stopping the sender from immediately transmitting the 6 bytes in category 3 (the
    usable window). When the sender transmits them, the 6 bytes will shift from category
    3 to category 2\. The byte ranges will now be as follows (see [Figure 46-7](ch46s02.html#tcp_stream_categories_and_window_after_s
    "Figure 46-7. TCP stream categories and window after sending usable window bytes
    This diagram shows the result of the device sending all the bytes that it is allowed
    to transmit in its usable window. It is the same as Figure 46-6, except that all
    the bytes in category 3 have moved to category 2\. The usable window is now zero
    and will remain so until it receives an acknowledgment for bytes in category 2.")):'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设在 [图 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s "图 46-6.
    TCP 传输流类别和发送窗口术语 此图显示了与图 46-5 中相同的类别，但同时也显示了发送窗口。黑色方框是整体发送窗口（类别 2 和 3 合并）；浅灰色方框表示已发送的字节（类别
    2），深灰色方框是可用窗口（类别 3）。") 所示的示例中，没有任何阻止发送者立即传输类别 3（可用窗口）中的 6 个字节。当发送者传输这些字节时，这 6
    个字节将从类别 3 移动到类别 2。字节范围现在如下（参见 [图 46-7](ch46s02.html#tcp_stream_categories_and_window_after_s
    "图 46-7. 发送可用窗口字节后的 TCP 流类别和窗口 此图显示了设备发送其可用窗口允许发送的所有字节的结果。它与图 46-6 相同，除了所有类别 3
    中的字节都移动到类别 2。可用窗口现在为零，并将保持如此，直到它收到类别 2 中字节的确认。"））：
- en: The bytes sent and acknowledged are bytes 1 to 31.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已发送并确认的字节是 1 到 31。
- en: The bytes sent but not yet acknowledged are bytes 32 to 51.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已发送但尚未确认的字节是 32 到 51。
- en: The bytes not yet sent for which the recipient is ready are none.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于接收者已准备接收但尚未发送的字节没有。
- en: The bytes not yet sent for which the recipient is not ready are bytes 52 to
    95.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于接收者尚未准备接收的字节是 52 到 95。
- en: '![TCP stream categories and window after sending usable window bytes This diagram
    shows the result of the device sending all the bytes that it is allowed to transmit
    in its usable window. It is the same as , except that all the bytes in category
    3 have moved to category 2\. The usable window is now zero and will remain so
    until it receives an acknowledgment for bytes in category 2.](httpatomoreillycomsourcenostarchimages288101.png.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![发送可用窗口字节后的 TCP 流类别和窗口 此图显示了设备发送其可用窗口允许发送的所有字节的结果。它与相同，除了所有类别 3 中的字节都移动到类别
    2。可用窗口现在为零，并将保持如此，直到它收到类别 2 中字节的确认。](httpatomoreillycomsourcenostarchimages288101.png.jpg)'
- en: Figure 46-7. TCP stream categories and window after sending usable window bytes
    This diagram shows the result of the device sending all the bytes that it is allowed
    to transmit in its usable window. It is the same as [Figure 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "Figure 46-6. TCP transmission stream categories and send window terminology This
    diagram shows the same categories as the ones in Figure 46-5, except that it shows
    the send window as well. The black box is the overall send window (categories
    2 and 3 combined); the light gray box represents the bytes already sent (category
    2), and the dark gray box is the usable window (category 3)."), except that all
    the bytes in category 3 have moved to category 2\. The usable window is now zero
    and will remain so until it receives an acknowledgment for bytes in category 2.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图 46-7. 发送可用窗口字节数后的 TCP 流类别和窗口 此图显示了设备发送其可用窗口内允许传输的所有字节的后果。它与[图 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "图 46-6. TCP 传输流类别和发送窗口术语 此图显示了与图 46-5 中相同的类别，但同时也显示了发送窗口。黑色方框是整体发送窗口（类别 2 和 3
    合并）；浅灰色方框表示已发送的字节（类别 2），深灰色方框是可用窗口（类别 3）") 相同，除了类别 3 中的所有字节都移动到了类别 2 中。现在可用窗口为零，并且将保持如此，直到它收到类别
    2 中字节的确认。
- en: Processing Acknowledgments and Sliding the Send Window
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理确认和滑动发送窗口
- en: Some time later, the destination device sends back a message to the sender and
    provides an acknowledgment. The destination device will not specifically list
    out the bytes that it has acknowledged, because as I said earlier, listing the
    bytes would be inefficient. Instead, the destination device will acknowledge a
    range of bytes that represents the longest contiguous sequence of bytes it has
    received since the ones it had previously acknowledged.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间之后，目标设备向发送方发送一条消息并提供确认。目标设备不会具体列出它已确认的字节，因为正如我之前所说的，列出字节将是不高效的。相反，目标设备将确认一个字节范围，这代表了它自上次确认的字节以来接收到的最长连续字节序列。
- en: For example, let's suppose that the bytes already sent but not yet acknowledged
    at the start of the example (bytes 32 to 45) were transmitted in four different
    segments. These segments carried bytes 32 to 34, 35 to 36, 37 to 41, and 42 to
    45, respectively. The first, second, and fourth segments arrived, but the third
    did not. The receiver will send back an acknowledgment only for bytes 32 to 36
    (32 to 34 and 35 to 36). The receiver will hold bytes 42 to 45 but won't acknowledge
    them, because this would imply that the receiver has received bytes 37 to 41,
    which have not shown up yet. This is necessary because TCP is a cumulative acknowledgment
    system that can use only a single number to acknowledge data. That number is the
    number of the last contiguous byte in the stream that was successfully received.
    Let's also say that the destination keeps the window size the same at 20 bytes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设示例开始时已发送但尚未确认的字节（32 到 45）被传输在四个不同的段中。这些段分别携带字节 32 到 34、35 到 36、37 到 41
    和 42 到 45。第一、第二和第四个段到达了，但第三个没有到达。接收方只会对字节 32 到 36（32 到 34 和 35 到 36）发送确认。接收方将保留字节
    42 到 45 但不会确认它们，因为这会意味着接收方已经接收了字节 37 到 41，而这些字节尚未出现。这是必要的，因为 TCP 是一个累积确认系统，它只能使用一个数字来确认数据。这个数字是流中成功接收到的最后一个连续字节的编号。让我们也假设目标设备保持窗口大小不变，为
    20 字节。
- en: Note
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*An optional feature called* selective acknowledgments *does allow noncontiguous
    blocks of data to be acknowledged. This is explained in [Chapter 49](ch49.html
    "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES")''s section named "TCP
    Noncontiguous Acknowledgment Handling and Selective Acknowledgment (SACK)"; we''ll
    ignore this complication for now*.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个名为选择性确认的可选功能允许确认非连续的数据块。这将在[第 49 章](ch49.html "第 49 章. TCP 可靠性和流量控制功能")的“TCP
    非连续确认处理和选择性确认（SACK）”部分中解释；我们现在将忽略这个复杂性*。'
- en: 'When the sending device receives this acknowledgment, it will be able to transfer
    some of the bytes from category 2 to category 1, because they have now been acknowledged.
    When it does so, something interesting will happen. Since 5 bytes have been acknowledged,
    and the window size didn''t change, the sender is allowed to send 5 more bytes.
    In effect, the window shifts or slides over to the right in the timeline. At the
    same time 5 bytes move from category 2 to category 1, 5 bytes move from category
    4 to category 3, creating a new usable window for subsequent transmission. So,
    after the groups receive the acknowledgment, they will look like what you see
    in [Figure 46-8](ch46s02.html#sliding_the_tcp_send_window_after_receiv "Figure 46-8. Sliding
    the TCP send window After receiving acknowledgment for bytes 32 to 36, the bytes
    move from category 2 to 1 (shown in dark shading). The send window shown in Figure 46-7
    slides right by 5 bytes; shifting 5 bytes from category 4 to 3, and opening a
    new usable window."). The byte ranges will be as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当发送设备收到此确认时，它将能够将一些类别 2 中的字节转移到类别 1，因为它们现在已被确认。当它这样做时，会发生一些有趣的事情。由于已确认 5 个字节，而窗口大小没有变化，发送方被允许发送
    5 个额外的字节。实际上，窗口在时间轴上向右移动或滑动。同时，5 个字节从类别 2 移动到类别 1，5 个字节从类别 4 移动到类别 3，为后续传输创建了一个新的可用窗口。因此，在组收到确认后，它们将看起来像你在[图
    46-8](ch46s02.html#sliding_the_tcp_send_window_after_rece "图 46-8. 滑动 TCP 发送窗口
    在收到字节 32 到 36 的确认后，字节从类别 2 移动到类别 1（以深色阴影显示）。图 46-7 中显示的发送窗口向右滑动 5 个字节；将 5 个字节从类别
    4 移动到类别 3，并打开一个新的可用窗口。") 中看到的那样。字节范围如下：
- en: The bytes sent and acknowledged are bytes 1 to 36.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已发送并确认的字节是 1 到 36。
- en: The bytes sent but not yet acknowledged are bytes 37 to 51.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尚未发送且尚未确认的字节是 37 到 51。
- en: The bytes not yet sent for which the recipient is ready are bytes 52 to 56.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已准备好发送但尚未发送的字节是 52 到 56。
- en: The bytes not yet sent for which the recipient is not ready are bytes 57 to
    95.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尚未发送且接收方尚未准备好的字节是 57 到 95。
- en: '![Sliding the TCP send window After receiving acknowledgment for bytes 32 to
    36, the bytes move from category 2 to 1 (shown in dark shading). The send window
    shown in slides right by 5 bytes; shifting 5 bytes from category 4 to 3, and opening
    a new usable window.](httpatomoreillycomsourcenostarchimages288103.png.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![滑动 TCP 发送窗口 在收到字节 32 到 36 的确认后，字节从类别 2 移动到类别 1（以深色阴影显示）。图 46-7 中显示的发送窗口向右滑动
    5 个字节；将 5 个字节从类别 4 移动到类别 3，并打开一个新的可用窗口。](httpatomoreillycomsourcenostarchimages288103.png.jpg)'
- en: Figure 46-8. Sliding the TCP send window After receiving acknowledgment for
    bytes 32 to 36, the bytes move from category 2 to 1 (shown in dark shading). The
    send window shown in [Figure 46-7](ch46s02.html#tcp_stream_categories_and_window_after_s
    "Figure 46-7. TCP stream categories and window after sending usable window bytes
    This diagram shows the result of the device sending all the bytes that it is allowed
    to transmit in its usable window. It is the same as Figure 46-6, except that all
    the bytes in category 3 have moved to category 2\. The usable window is now zero
    and will remain so until it receives an acknowledgment for bytes in category 2.")
    slides right by 5 bytes; shifting 5 bytes from category 4 to 3, and opening a
    new usable window.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 图 46-8. 滑动 TCP 发送窗口 在收到字节 32 到 36 的确认后，字节从类别 2 移动到类别 1（以深色阴影显示）。[图 46-7](ch46s02.html#tcp_stream_categories_and_window_after_s
    "图 46-7. TCP 流类别和发送可用窗口字节后的窗口 此图显示了设备在其可用窗口内发送所有允许发送的字节的结果。它与图 46-6 相同，除了类别 3
    中的所有字节都移动到类别 2。现在可用窗口为零，并且将保持如此，直到它收到类别 2 中字节的确认。") 中显示的发送窗口向右滑动 5 个字节；将 5 个字节从类别
    4 移动到类别 3，并打开一个新的可用窗口。
- en: This process will occur each time an acknowledgment is received, thereby causing
    the window to slide across the entire stream in order to be transmitted. And thus,
    ladies and gentlemen, you have the TCP sliding window acknowledgment system!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收到确认时，都会发生此过程，从而使得窗口在整个流中滑动以进行传输。因此，女士们先生们，你们有了 TCP 滑动窗口确认系统！
- en: It is a very powerful technique that allows TCP to easily acknowledge an arbitrary
    number of bytes using a single acknowledgment number. It provides reliability
    to the byte-oriented protocol without spending time on an excessive number of
    acknowledgments. For simplicity, the example I've used here leaves the window
    size constant, but in reality, it can be adjusted to allow a recipient to control
    the rate at which data is sent, thereby enabling flow control and congestion handling.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常强大的技术，允许TCP使用单个确认号轻松地确认任意数量的字节。它为面向字节的协议提供了可靠性，而不需要在过多的确认上浪费时间。为了简单起见，我这里使用的示例保留了窗口大小不变，但在现实中，它可以调整以允许接收者控制数据发送的速度，从而实现流量控制和拥塞处理。
- en: Tip
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** When a device gets an acknowledgment for a range of bytes,
    it knows the destination has successfully received them. It moves them from the
    "sent but unacknowledged" to the "sent and acknowledged" category. This causes
    the send window to slide to the right, allowing the device to send more data.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当设备收到一个字节范围的确认时，它知道目标设备已成功接收了它们。它将它们从“已发送但未确认”类别移动到“已发送且已确认”类别。这导致发送窗口向右滑动，允许设备发送更多数据。'
- en: Dealing with Missing Acknowledgments
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理丢失的确认
- en: But what about bytes 42 through 45 in the example shown in [Figure 46-8](ch46s02.html#sliding_the_tcp_send_window_after_receiv
    "Figure 46-8. Sliding the TCP send window After receiving acknowledgment for bytes
    32 to 36, the bytes move from category 2 to 1 (shown in dark shading). The send
    window shown in Figure 46-7 slides right by 5 bytes; shifting 5 bytes from category
    4 to 3, and opening a new usable window.")? Until segment 3 (containing bytes
    37 to 41) shows up, the receiving device will not send an acknowledgment for those
    bytes, and it won't send any others that show up after it. The sending device
    will be able to send the new bytes that were added to category 3, namely, bytes
    52 to 56\. The sending device will then stop, and the window will be stuck on
    bytes 37 to 41.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 但在[图46-8](ch46s02.html#sliding_the_tcp_send_window_after_receiv "图46-8. 接收字节32到36的确认后，字节从类别2移动到1（以深色阴影显示）。图46-7中显示的发送窗口向右滑动5个字节；将5个字节从类别4移动到3，并打开一个新的可用窗口。")中给出的示例中，字节42到45又是怎么回事呢？直到包含字节37到41的段3出现，接收设备才不会为这些字节发送确认，也不会为之后出现的任何其他字节发送确认。发送设备将能够发送添加到类别3的新字节，即字节52到56。然后发送设备将停止，窗口将停留在字节37到41上。
- en: Tip
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP acknowledgments are cumulative and tell a transmitter that
    the receiving device successfully received all the bytes up to the sequence number
    indicated in the acknowledgment. Thus, if the receiving device receives bytes
    out of order, the device cannot acknowledge them until all the preceding bytes
    are received.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP确认是累积的，并告知发送器接收设备已成功接收了确认中指示的序列号所表示的所有字节。因此，如果接收设备接收到顺序错误的字节，设备必须等到所有前面的字节都接收完毕后才能确认它们。'
- en: Like the PAR system, TCP includes a system for timing transmissions and retransmitting.
    Eventually, the TCP device will resend the lost segment. Unfortunately, one drawback
    of TCP is that since it does not separately acknowledge segments, it may have
    to retransmit other segments that the recipient actually received (such as the
    segment with bytes 42 to 45). This starts to get very complex, as I discussed
    in the topic on TCP retransmissions in [Chapter 49](ch49.html "Chapter 49. TCP
    RELIABILITY AND FLOW CONTROL FEATURES").
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 与PAR系统一样，TCP包括一个用于定时传输和重传的系统。最终，TCP设备将重新发送丢失的段。不幸的是，TCP的一个缺点是，由于它不单独确认段，它可能需要重新传输接收者实际上已接收的其他段（例如字节42到45的段）。正如我在[第49章](ch49.html
    "第49章. TCP可靠性和流量控制功能")中讨论TCP重传主题时所说的，这开始变得非常复杂。
- en: More Information on TCP Sliding Windows
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于TCP滑动窗口的更多信息
- en: Despite the length of this explanation, the preceding is just a summary description
    of the overall operation of sliding windows. This chapter does not include all
    of the modifications used in modern TCP! As you can see, the sliding window mechanism
    is at the heart of the operation of TCP as a whole. In the chapter that describes
    segments and discusses data transfer, you will see in more detail how TCP transmitters
    decide how and when to create segments for transmission. [Chapter 49](ch49.html
    "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES") provides much more information
    about how sliding windows enable a device to manage the flow of data to it on
    a TCP connection. It also discusses special problems that can arise if window
    size is not carefully managed and how you can avoid problems such as congestion
    in TCP implementations through key changes to the basic sliding window mechanism
    described in this section.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个解释的篇幅较长，但前面的内容只是滑动窗口整体操作的简要描述。本章并未包括现代TCP中使用的所有修改！正如你所见，滑动窗口机制是TCP整体操作的核心。在描述分段和讨论数据传输的章节中，你将更详细地了解TCP发送者如何决定何时以及如何创建用于传输的分段。[第49章](ch49.html
    "第49章。TCP可靠性及流量控制特性")提供了更多关于滑动窗口如何使设备在TCP连接上管理数据流的信息。它还讨论了如果窗口大小没有仔细管理可能会出现的特殊问题，以及如何通过对本节中描述的基本滑动窗口机制进行关键更改来避免TCP实现中的拥塞等问题。
- en: TCP Ports, Connections, and Connection Identification
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP端口、连接和连接识别
- en: 'The two TCP/IP transport layer protocols, TCP and UDP, play the same architectural
    role in the protocol suite, but do it in very different ways. In fact, one of
    the few functions that the two have in common is that they both provide a method
    of transport layer addressing and multiplexing. Through the use of *ports*, both
    protocols allow the data from many different application processes to be aggregated
    and sent through the IP layer, and then returned up the stack to the proper application
    process on the destination device. I explain TCP ports in detail in [Chapter 43](ch43.html
    "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS").'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 两个TCP/IP传输层协议，TCP和UDP，在协议套件中扮演相同的架构角色，但实现方式却大相径庭。实际上，这两个协议共同拥有的少数功能之一是它们都提供了一种传输层寻址和复用方法。通过使用*端口*，这两个协议都允许来自许多不同应用进程的数据被聚合并通过IP层发送，然后返回到目标设备上的正确应用进程。我在[第43章](ch43.html
    "第43章。TCP和UDP寻址：端口和套接字")中详细解释了TCP端口。
- en: Despite this commonality, TCP and UDP diverge somewhat even in how they deal
    with processes. UDP is a connectionless protocol, which means that devices do
    not set up a formal connection before sending data. UDP does not have to use sliding
    windows or keep track of how long it has been since UDP sent a transmission and
    so forth. When the UDP layer on a device receives data, it just sends it to the
    process that the destination port indicates, and that's that. UDP can seamlessly
    handle any number of processes that are sending it messages because UDP handles
    them all identically.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这种共性，TCP和UDP在处理进程方面还是有所区别。UDP是一种无连接协议，这意味着在发送数据之前，设备不需要建立正式的连接。UDP不需要使用滑动窗口或跟踪UDP发送传输的时间长短等。当设备上的UDP层接收到数据时，它只需将其发送到目标端口指示的进程，然后任务完成。UDP可以无缝地处理发送给它消息的任何数量的进程，因为UDP以相同的方式处理它们。
- en: In contrast, since TCP is connection-oriented, it has many more responsibilities.
    Each TCP software layer needs to be able to support connections to several other
    TCPs simultaneously. The operation of each connection is separate from of each
    other connection, and the TCP software must manage each operation independently.
    TCP must be sure that it not only routes data to the right process, but that it
    also manages transmitted data on each connection without any overlap or confusion.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，由于TCP是面向连接的，它承担着更多的责任。每个TCP软件层都需要能够同时支持与其他多个TCP的连接。每个连接的操作都是独立的，TCP软件必须独立管理每个操作。TCP必须确保它不仅将数据路由到正确的进程，而且还要在每个连接上管理传输的数据，确保没有重叠或混淆。
- en: 'The first consequence of this is that TCP must uniquely identify each connection.
    It does this by using the pair of socket identifiers that correspond to the two
    endpoints of the connection, where a socket is simply the combination of the IP
    address and the port number of each process. This means a socket pair contains
    four pieces of information: source address, source port, destination address,
    and destination port. Thus, TCP connections are sometimes said to be described
    by this addressing quadruple.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的第一后果是TCP必须唯一标识每个连接。它是通过使用对应于连接两端端点的套接字标识符对来实现的，其中套接字简单地是每个进程的IP地址和端口号的组合。这意味着套接字对包含四条信息：源地址、源端口、目的地址和目的端口。因此，TCP连接有时被称为由这个地址四元组来描述。
- en: 'I introduced this concept in [Chapter 43](ch43.html "Chapter 43. TCP AND UDP
    ADDRESSING: PORTS AND SOCKETS"), where I gave the example of a Hypertext Transfer
    Protocol (HTTP) request that a client sends at 177.41.72.6 to a website at 41.199.222.3\.
    The server for that website will use well-known port number 80, so the server''s
    socket is 41.199.222.3:80\. If the server assigns a client ephemeral port number
    3022 for the web browser, the client socket is 177.41.72.6:3022\. The overall
    connection between these devices can be described using this socket pair: (41.199.222.3:80,
    177.41.72.6:3022).'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第43章](ch43.html "第43章。TCP和UDP寻址：端口和套接字")中介绍了这个概念，其中我给出了一个客户端向位于177.41.72.6的网站发送的HTTP请求的例子，该网站位于41.199.222.3。该网站的服务器将使用众所周知的端口号80，因此服务器的套接字是41.199.222.3:80。如果服务器为网络浏览器分配一个临时端口号3022，则客户端套接字是177.41.72.6:3022。这些设备之间的整体连接可以使用这个套接字对来描述：(41.199.222.3:80,
    177.41.72.6:3022)。
- en: 'This identification of connections using both client and server sockets is
    what provides the flexibility in allowing multiple connections between devices
    that we probably take for granted on the Internet. For example, busy application
    server processes (such as web servers) must be able to handle connections from
    more than one client; otherwise, the Web would be pretty much unusable. Since
    the client and server''s socket identify the connection, this is no problem. At
    the same time that the web server maintains the connection, it can easily have
    another connection to say, port 2199 at IP address 219.31.0.44\. The connection
    identifier that represents this as follows: (41.199.222.3:80, 219.31.0.44:2199).'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端和服务器套接字来标识连接，这为我们提供了在互联网上可能视为理所当然的设备之间进行多个连接的灵活性。例如，繁忙的应用程序服务器进程（如Web服务器）必须能够处理来自多个客户端的连接；否则，网络几乎无法使用。由于客户端和服务器套接字标识连接，因此这不成问题。在Web服务器维护连接的同时，它可以轻松地与另一个连接，比如IP地址219.31.0.44的端口号2199，建立连接。表示这个连接的标识符如下：(41.199.222.3:80,
    219.31.0.44:2199)。
- en: In fact, you can have multiple connections from the same client to the same
    server. Each client process will be assigned a different ephemeral port number,
    so even if they all try to access the same server process (such as the web server
    process at 41.199.222.3:80), they will all have a different client socket and
    represent unique connections. This difference is what lets you make several simultaneous
    requests to the same website from your computer.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以从同一个客户端到同一个服务器建立多个连接。每个客户端进程将被分配一个不同的临时端口号，所以即使它们都试图访问同一个服务器进程（如位于41.199.222.3:80的Web服务器进程），它们也将拥有不同的客户端套接字，并代表唯一的连接。这种差异使得你能够从你的计算机向同一个网站发出多个并发请求。
- en: Again, TCP keeps track of each of these connections independently, so each connection
    is unaware of the others. TCP can handle hundreds or even thousands of simultaneous
    connections. The only limit is the capacity of the computer running TCP, and the
    bandwidth of the physical connections to it—the more connections running at once,
    the more each one has to share limited resources.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，TCP独立跟踪每个这些连接，所以每个连接都不了解其他连接。TCP可以处理数百甚至数千个并发连接。唯一的限制是运行TCP的计算机的容量以及连接到它的物理连接的带宽——同时运行的连接越多，每个连接就必须共享的资源就越有限。
- en: Tip
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each device can handle simultaneous TCP connections to many
    different processes on one or more devices. The socket numbers of the devices
    in the connection, called the connection''s *endpoints*, identify each connection.
    Each endpoint consists of the device''s IP address and port number, so the four-way
    communication between client IP address and port number, and server IP address
    and port number identifies each connection.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个设备可以处理到一台或多台设备上多个不同进程的TCP连接。连接中设备的套接字编号，称为连接的*端点*，标识每个连接。每个端点由设备的IP地址和端口号组成，因此客户端IP地址和端口号与服务器IP地址和端口号之间的四次通信标识了每个连接。'
- en: TCP Common Applications and Server Port Assignments
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP常见应用和服务器端口分配
- en: In the overview of TCP in [Chapter 45](ch45.html "Chapter 45. TCP OVERVIEW,
    FUNCTIONS, AND CHARACTERISTICS"), you saw that the protocol originally included
    the functions of both modern TCP and IP. TCP was split into TCP and IP in order
    to allow applications that didn't need TCP's complexity to bypass it, using the
    much simpler UDP as a transport layer protocol instead. This bypass was an important
    step in the development of the TCP/IP protocol suite, since there are several
    important protocols for which UDP is ideally suited, and even some for which TCP
    is more of a nuisance than a benefit.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第45章](ch45.html "第45章。TCP概述、功能和特性")中TCP的概述中，你看到该协议最初包括了现代TCP和IP的功能。TCP被分割成TCP和IP，以便不需要TCP复杂性的应用程序可以绕过它，使用更简单的UDP作为传输层协议。这个绕过是TCP/IP协议套件发展中的一个重要步骤，因为有几个重要的协议UDP非常适合，甚至有些对于TCP来说更多的是麻烦而不是好处。
- en: 'Most commonly, however, UDP is used only in special cases. I describe the two
    types of applications that may be better suited to UDP than TCP in [Chapter 44](ch44.html
    "Chapter 44. TCP/IP USER DATAGRAM PROTOCOL (UDP)"): applications where speed is
    more important than reliability, and applications that send only short messages
    infrequently. The majority of TCP/IP applications do not fall into these categories.
    Thus, even though the layering of TCP and IP means that most protocols aren''t
    required to use TCP, most of them do anyway. The majority of the protocols that
    use TCP employ all, or at least most, of the features that it provides. The establishment
    of a persistent connection is necessary for many interactive protocols, such as
    Telnet, as well as for ones that send commands and status replies, like HTTP.
    Reliability and flow control are essential for protocols like the File Transfer
    Protocol (FTP) or the email protocols, which send large files.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，UDP通常仅在特殊情况下使用。我在[第44章](ch44.html "第44章。TCP/IP用户数据报协议(UDP)")中描述了两种可能比TCP更适合UDP的应用类型：那些速度比可靠性更重要，以及那些不经常发送短消息的应用。大多数TCP/IP应用都不属于这些类别。因此，尽管TCP和IP的分层意味着大多数协议不需要使用TCP，但它们大多数仍然这样做。使用TCP的大多数协议都使用其提供的所有或至少大多数功能。对于许多交互式协议，如Telnet，以及发送命令和状态回复的协议，如HTTP，建立持久连接是必要的。对于像文件传输协议(FTP)或电子邮件协议这样的协议，它们发送大文件，可靠性和流量控制是必不可少的。
- en: '[Table 46-1](ch46s04.html#common_tcp_applications_and_server_port_ "Table 46-1. Common
    TCP Applications and Server Port Assignments") shows some of the more significant
    application protocols that run on TCP. For each protocol, I have shown the well-known
    or registered port number that''s reserved for that protocol''s server process
    (clients use ephemeral ports, not the port numbers in the table). I have also
    shown the special keyword shortcut for each port assignment and provided brief
    comments on why the protocol is well matched to TCP.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[表46-1](ch46s04.html#common_tcp_applications_and_server_port_ "表46-1。常见的TCP应用和服务器端口分配")显示了在TCP上运行的一些更重要的应用协议。对于每个协议，我都显示了为该协议的服务器进程保留的已知或注册的端口号（客户端使用临时端口，而不是表中的端口号）。我还为每个端口分配显示了特殊的关键字快捷方式，并提供了关于为什么该协议非常适合TCP的简要说明。'
- en: Table 46-1. Common TCP Applications and Server Port Assignments
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 表46-1。常见的TCP应用和服务器端口分配
- en: '| Port # | Keyword | Protocol | Comments |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 端口号 | 关键字 | 协议 | 备注 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 20 and 21 | ftp-data/ftp | File Transfer Protocol (FTP, data and control)
    | Used to send large files, so it is ideally suited for TCP. |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 20和21 | ftp-data/ftp | 文件传输协议(FTP，数据和控制) | 用于发送大文件，因此非常适合TCP。|'
- en: '| 23 | telnet | Telnet Protocol | Interactive session-based protocol. Requires
    the connection-based nature of TCP. |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 23 | telnet | Telnet协议 | 基于交互式会话的协议。需要TCP的连接特性。|'
- en: '| 25 | smtp | Simple Mail Transfer Protocol (SMTP) | Uses an exchange of commands,
    and sends possibly large files between devices. |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 25 | smtp | 简单邮件传输协议（SMTP）| 使用命令交换，并在设备之间发送可能很大的文件。|'
- en: '| 53 | domain | Domain Name Server (DNS) | An example of a protocol that uses
    both UDP and TCP. For simple requests and replies, DNS uses UDP. For larger messages,
    especially zone transfers, DNS uses TCP. |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| 53 | domain | 域名服务器（DNS）| 使用 UDP 和 TCP 的协议的示例。对于简单的请求和回复，DNS 使用 UDP。对于较大的消息，特别是区域传输，DNS
    使用 TCP。|'
- en: '| 70 | gopher | Gopher Protocol | A messaging protocol that has been largely
    replaced by the WWW. |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 70 | gopher | Gopher 协议 | 一种已被万维网 largely 取代的消息协议。|'
- en: '| 80 | http | Hypertext Transfer Protocol (HTTP/World Wide Web) | The classic
    example of a TCP-based messaging protocol. |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 80 | http | 超文本传输协议（HTTP/万维网）| TCP 基于消息协议的经典示例。|'
- en: '| 110 | pop3 | Post Office Protocol (POP version 3) | Email message retrieval
    protocols that use TCP to exchange commands and data. |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 110 | pop3 | 邮局协议（POP 版本 3）| 使用 TCP 交换命令和数据来检索电子邮件消息的协议。|'
- en: '| 119 | nntp | Network News Transfer Protocol (NNTP) | Used for transferring
    NetNews (Usenet) messages, which can be lengthy. |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 119 | nntp | 网络新闻传输协议（NNTP）| 用于传输 NetNews（Usenet）消息，这些消息可能很长。|'
- en: '| 139 | netbios-ssn | NetBIOS Session Service | A session protocol, clearly
    better suited to TCP than UDP. |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 139 | netbios-ssn | NetBIOS 会话服务 | 一种会话协议，显然比 UDP 更适合 TCP。|'
- en: '| 143 | imap | Internet Message Access Protocol (IMAP) | Another email message
    retrieval protocol. |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 143 | imap | 互联网消息访问协议（IMAP）| 另一种电子邮件消息检索协议。|'
- en: '| 179 | bgp | Border Gateway Protocol (BGP) | While interior routing protocols
    like RIP and OSPF use either UDP or IP directly, BGP runs over TCP. This allows
    BGP to assume reliable communication even as it sends data over potentially long
    distances. |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 179 | bgp | 边界网关协议（BGP）| 虽然内部路由协议如 RIP 和 OSPF 使用 UDP 或 IP 直接，但 BGP 在 TCP
    上运行。这允许 BGP 在发送数据时即使是在可能的长距离上也能假设可靠的通信。|'
- en: '| 194 | irc | Internet Relay Chat (IRC) | IRC is like Telnet in that it is
    an interactive protocol that is strongly based on the notion of a persistent connection
    between a client and server. |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 194 | irc | 互联网中继聊天（IRC）| IRC 与 Telnet 类似，它是一种基于客户端和服务器之间持久连接的交互式协议。|'
- en: '| 2049 | nfs | Network File System (NFS) | NFS was originally implemented using
    UDP for performance reasons. Given that it is responsible for large transfers
    of files and given UDP''s unreliability, NFS was probably not the best idea, so
    developers created TCP versions. The latest version of NFS uses TCP exclusively.
    |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 2049 | nfs | 网络文件系统（NFS）| 由于性能原因，NFS 最初使用 UDP 实现。鉴于它负责大量文件传输，以及 UDP 的不可靠性，NFS
    可能不是最佳选择，因此开发人员创建了 TCP 版本。NFS 的最新版本仅使用 TCP。|'
- en: '| 6000–6063 | TCP | x11 | Used for the X Window graphical system. Multiple
    ports are dedicated to allow many sessions. |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 6000–6063 | TCP | x11 | 用于 X Window 图形系统。多个端口被分配以允许多个会话。|'
- en: A couple of the protocols in [Table 46-1](ch46s04.html#common_tcp_applications_and_server_port_
    "Table 46-1. Common TCP Applications and Server Port Assignments") use both TCP
    and UDP in order to get the best of both worlds. UDP can send short, simple messages,
    while TCP moves larger files. Many of the protocols that use both TCP and UDP
    are actually utility/diagnostic protocols (such as Echo, Discard, and the Time
    Protocol). These are special cases, because they developers designed them to use
    both UDP and TCP specifically to allow their use for diagnostics on both protocols.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 46-1](ch46s04.html#common_tcp_applications_and_server_port_ "表 46-1. 常见
    TCP 应用和服务器端口分配") 中的某些协议同时使用 TCP 和 UDP，以便兼得两者之长。UDP 可以发送简短、简单的消息，而 TCP 可以传输较大的文件。实际上，许多同时使用
    TCP 和 UDP 的协议实际上是实用程序/诊断协议（如回声、丢弃和时间协议）。这些是特殊情况，因为开发人员特别设计了它们以使用 UDP 和 TCP，以便在两种协议上都可以用于诊断。|'
- en: I have not included an exhaustive list of TCP applications in [Table 46-1](ch46s04.html#common_tcp_applications_and_server_port_
    "Table 46-1. Common TCP Applications and Server Port Assignments"). See [Chapter 42](ch42.html
    "Chapter 42. OVERVIEW AND COMPARISON OF TCP AND UDP") for common TCP/IP applications
    and port numbers, and also a reference to the full (massive) list of well-known
    and registered TCP server ports.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在 [表 46-1](ch46s04.html#common_tcp_applications_and_server_port_ "表 46-1.
    常见 TCP 应用和服务器端口分配") 中包含 TCP 应用程序的详尽列表。请参阅 [第 42 章](ch42.html "第 42 章. TCP 和 UDP
    的概述和比较") 了解常见的 TCP/IP 应用程序和端口号，以及已知和注册的 TCP 服务器端口的完整（庞大的）列表。
- en: 'Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND
    TERMINATION'
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 47 章。TCP 基本操作：连接建立、管理和终止
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: While I have described the Transmission Control Protocol (TCP) as *connection-oriented*,
    this term isn't just any old characteristic of TCP. The overall operation of the
    entire protocol can be described in terms of how TCP software prepares, negotiates,
    establishes, manages, and terminates connections. TCP implementations certainly
    do more than handle connections, but the other major tasks they perform, such
    as data handling and providing reliability and flow control, can occur only over
    a stable connection. This stability makes connections the logical place to begin
    exploring the details of how TCP works.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我已经将传输控制协议 (TCP) 描述为**面向连接的**，但这个术语不仅仅是 TCP 的某个老特性。整个协议的整体操作可以用 TCP 软件如何准备、协商、建立、管理和终止连接来描述。TCP
    实现确实不仅仅是处理连接，但它们执行的另一个主要任务，如数据处理和提供可靠性和流量控制，只能在稳定的连接上发生。这种稳定性使得连接成为探索 TCP 工作细节的逻辑起点。
- en: In this chapter, I describe TCP connections from start to finish. I begin with
    an overview of TCP's operation by providing a summary of the *finite state machine*
    that formally defines the stages of a connection. State machines can be a bit
    mind-boggling when you read about them in standards, but a simplified, explained
    version provides an excellent high-level view of the life of a connection, so
    it is a good place to start.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将从始至终描述 TCP 连接。我首先通过提供正式定义连接阶段的**有限状态机**的摘要来概述 TCP 的操作。当你在标准中阅读它们时，状态机可能会让你感到有些令人困惑，但一个简化的、解释过的版本提供了对连接生命周期的优秀高级视图，因此这是一个很好的起点。
- en: From there, I move on to provide details about TCP's handling of connections.
    I describe how you prepare and set up connections and *transmission control blocks
    (TCBs)*, and explain the difference between a passive and an active socket Open.
    I explain the three-way handshake that you can use to create a connection and
    the method by which parameters are exchanged and sequence numbers synchronized.
    I talk about how an established connection is managed, including the method by
    which TCP handles problem conditions and resets the connection when necessary.
    Finally, I describe how a connection can be terminated when it is no longer needed.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我将继续提供有关 TCP 处理连接的详细信息。我描述了如何准备和设置连接以及**传输控制块 (TCBs**)，并解释了被动套接字打开和主动套接字打开之间的区别。我解释了你可以用来创建连接的三次握手，以及参数交换和序列号同步的方法。我讨论了如何管理已建立的连接，包括
    TCP 处理问题条件和在必要时重置连接的方法。最后，我描述了当不再需要连接时如何终止连接。
- en: Tip
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *The following detailed sections assume that you''re
    familiar with the concepts in the previous chapter, especially the notion of sequence
    numbers*.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *以下详细章节假设你已经熟悉上一章中的概念，特别是序列数的概念*。'
- en: TCP Operational Overview and the TCP Finite State Machine (FSM)
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 操作概述和 TCP 有限状态机 (FSM)
- en: It is essential that all devices that implement a networking protocol do so
    in a consistent manner. Otherwise, one device might behave in a manner that the
    other would not expect. Naturally, this inconsistency is why there are standards
    that describe the operation of each protocol. The problem with a protocol like
    TCP is that it performs so many tasks that it is difficult to specify the exact
    operation of all aspects of the protocol succinctly.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 所有实现网络协议的设备都必须以一致的方式进行。否则，一个设备可能会以其他设备无法预期的行为运行。自然，这种不一致性正是存在描述每个协议操作标准的原因。像
    TCP 这样的协议问题在于它执行了如此多的任务，以至于很难简洁地指定协议所有方面的确切操作。
- en: One way that computer scientists describe how a complex protocol works is through
    a theoretical tool called a *finite state machine (FSM)*. An FSM attempts to describe
    a protocol or algorithm by considering it like a virtual machine that progresses
    through a series of stages of operation in response to various occurrences.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家描述复杂协议工作方式的一种方法是使用一种称为**有限状态机 (FSM**) 的理论工具。有限状态机试图通过将其视为一个虚拟机来描述协议或算法，该虚拟机根据各种事件响应，依次通过一系列操作阶段。
- en: Basic FSM Concepts
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本有限状态机概念
- en: 'You need to understand the following four essential concepts to comprehend
    the workings of an FSM:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解有限状态机的工作原理，你需要了解以下四个基本概念：
- en: '**State** The particular circumstance or status that describes the protocol
    software on a machine at a given time.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态** 描述机器在特定时间点上协议软件的特定情况或状态。'
- en: '**Transition** The act of moving from one state to another.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换** 从一个状态移动到另一个状态的行为。'
- en: '**Event** Something that causes a transition to occur between states.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件** 导致状态之间发生转换的事情。'
- en: '**Action** Something a device does in response to an event before it transitions
    to another state.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作** 在设备转换到另一个状态之前对事件做出的响应。'
- en: An FSM describes the protocol by explaining all the different states the protocol
    can be in, the events that can occur in each state, what actions are taken in
    response to the events, and what transitions happen as a result. The protocol
    usually starts in a particular *beginning state* when it is first run. It then
    follows a sequence of steps that get it into a regular operating state, and moves
    to other states in response to particular types of input or other circumstances.
    The state machine is called *finite* because there are a limited number of states.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机通过解释协议可以处于的所有不同状态、每个状态中可能发生的事件、对事件采取的动作以及由此产生的转换来描述协议。协议通常在首次运行时从特定的 *初始状态*
    开始。然后它遵循一系列步骤进入常规操作状态，并响应特定类型的输入或其他情况移动到其他状态。状态机被称为 *有限* 的，因为状态的数量是有限的。
- en: The Simplified TCP FSM
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化的 TCP FSM
- en: In the case of TCP, the FSM describes the life stages of a connection. Each
    connection between one TCP device and another begins in a null state where there
    is no connection and then proceeds through a series of states until a connection
    is established. The connection remains in that state until something occurs to
    cause the connection to be closed again, at which point it proceeds through another
    sequence of transitional states and returns to the closed state.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TCP 的情况下，有限状态机（FSM）描述了连接的生命周期。每个 TCP 设备之间的连接都是从无连接的空状态开始的，然后通过一系列状态直到建立连接。连接保持在该状态，直到发生某些事情导致连接再次关闭，此时它将通过另一系列转换状态并返回到关闭状态。
- en: Tip
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Many computer scientists use the *finite state machine (FSM)*
    to describe the operation of a protocol or algorithm. The FSM describes the different
    actions that a piece of software takes over time by defining a finite number of
    operating *states*, *events* that can cause *transitions* between states, and
    *actions* taken in response to events.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 许多计算机科学家使用 *有限状态机（FSM）* 来描述协议或算法的操作。有限状态机通过定义有限数量的操作 *状态*、可以导致状态之间
    *转换* 的 *事件* 以及对事件采取的 *动作* 来描述软件随时间采取的不同动作。'
- en: The full description of the states, events, and transitions in a TCP connection
    is lengthy and complicated. This is not surprising, because those three elements
    would cover much of the entire TCP standard. That level of detail would be a good
    cure for insomnia, but not much else. However, a simplified look at the TCP FSM
    will help give you a nice overall feel for how TCP establishes connections and
    then functions when a connection has been created.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接中状态、事件和转换的完整描述既冗长又复杂。这并不奇怪，因为这三个元素将涵盖整个 TCP 标准的大部分内容。这样的细节可能会很好地治疗失眠，但不会带来太多其他好处。然而，对
    TCP FSM 的简化观察将有助于您对 TCP 建立连接以及连接创建后的功能有一个良好的整体感觉。
- en: '[Table 47-1](ch47.html#tcp_finite_state_machine_fsm_states_even "Table 47-1. TCP
    Finite State Machine (FSM) States, Events, and Transitions") briefly explains
    each of the TCP states in a TCP connection, the main events that occur in each
    state, and what actions and transitions occur as a result. For brevity, three
    abbreviations are used for the three types of messages that control transitions
    between states, which correspond to the TCP header flags that are set to indicate
    that a message is serving that function. These are as follows:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 47-1](ch47.html#tcp_finite_state_machine_fsm_states_even "表 47-1. TCP 有限状态机
    (FSM) 状态、事件和转换") 简要解释了 TCP 连接中的每个 TCP 状态、每个状态中发生的主要事件以及由此产生的动作和转换。为了简洁起见，使用了三个缩写来表示控制状态之间转换的三种类型的信息，这些缩写对应于设置为指示消息执行该功能的
    TCP 报头标志。具体如下：'
- en: '**SYN** A *Synchronize* message; initiates and establishes a connection. It
    is so named since one of its functions is to synchronize sequence numbers between
    devices.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**SYN** 一个 *同步* 消息；用于发起和建立连接。之所以这样命名，是因为它的一个功能是在设备之间同步序列号。'
- en: '**FIN** A *Finish* message, which is a TCP segment with the FIN bit set; it
    indicates that a device wants to terminate the connection.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIN** 一个*结束*消息，这是一个设置了FIN位的TCP段；它表示设备想要终止连接。'
- en: '**ACK** An *Acknowledgment message*; indicates receipt of a message such as
    a SYN or a FIN.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACK** 一个*确认消息*；表示已收到像SYN或FIN这样的消息。'
- en: Again, I have not shown every possible transition, just the ones normally followed
    in the life of a connection. Error conditions also cause transitions, but including
    these would move us well beyond a simplified state machine. The FSM, including
    how state transitions occur, is illustrated in [Figure 47-1](ch47.html#the_tcp_finite_state_machine_fsm_this_di
    "Figure 47-1. The TCP finite state machine (FSM) This diagram illustrates the
    simplified TCP FSM. The shadings are not an official part of the definition of
    the FSM; I have added them to show more clearly the sequences the two devices
    took to open and close a link. For establishment and termination, there is a regular
    sequence, in which the initiating and responding devices go through different
    states, and a simultaneous sequence, in which each uses the same sequence.").
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我没有展示所有可能的转换，只是展示了在连接生命周期中通常遵循的转换。错误条件也会引起转换，但包括这些转换会使我们远远超出简化的状态机。FSM（包括状态转换如何发生）在[图47-1](ch47.html#the_tcp_finite_state_machine_fsm_this_di
    "图47-1. TCP有限状态机（FSM）此图说明了简化的TCP FSM。阴影部分不是FSM定义的官方部分；我添加它们是为了更清楚地显示两个设备打开和关闭连接所采取的序列。对于建立和终止，有一个常规序列，其中发起设备和响应设备会经过不同的状态，还有一个同时序列，其中每个设备都使用相同的序列。")中进行了说明。
- en: It's important to remember that this state machine is followed for each connection.
    This means that, at any given time, TCP may be in one state for one connection
    to socket *X*, and in another for its connection to socket *Y*. Also, the typical
    movement between states for the two processes in a particular connection is not
    symmetric, because the roles of the devices are not symmetric. For example, one
    device initiates a connection, and the other responds; one device starts termination,
    and the other replies. There is also an alternate path taken for connection establishment
    and termination if both devices initiate simultaneously (which is unusual, but
    can happen). This is shown by the shading in [Figure 47-1](ch47.html#the_tcp_finite_state_machine_fsm_this_di
    "Figure 47-1. The TCP finite state machine (FSM) This diagram illustrates the
    simplified TCP FSM. The shadings are not an official part of the definition of
    the FSM; I have added them to show more clearly the sequences the two devices
    took to open and close a link. For establishment and termination, there is a regular
    sequence, in which the initiating and responding devices go through different
    states, and a simultaneous sequence, in which each uses the same sequence.").
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这个状态机适用于每个连接。这意味着，在任何给定时间，TCP可能在一个连接到套接字*X*时处于一个状态，而在另一个连接到套接字*Y*时处于另一个状态。此外，特定连接中两个进程之间在状态之间的典型移动不是对称的，因为设备的作用不是对称的。例如，一个设备发起连接，另一个设备响应；一个设备开始终止，另一个设备回复。如果两个设备同时发起连接和终止（这不太常见，但可能发生），也会采取替代路径。这通过[图47-1](ch47.html#the_tcp_finite_state_machine_fsm_this_di
    "图47-1. TCP有限状态机（FSM）此图说明了简化的TCP FSM。阴影部分不是FSM定义的官方部分；我添加它们是为了更清楚地显示两个设备打开和关闭连接所采取的序列。对于建立和终止，有一个常规序列，其中发起设备和响应设备会经过不同的状态，还有一个同时序列，其中每个设备都使用相同的序列。")中的阴影部分来表示。
- en: Table 47-1. TCP Finite State Machine (FSM) States, Events, and Transitions
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 表47-1. TCP有限状态机（FSM）状态、事件和转换
- en: '| State | State Description | Event and Transition |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 状态描述 | 事件和转换 |'
- en: '| --- | --- | --- |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CLOSED | The default state that each connection starts in before the process
    of establishing it begins. The state is called "fictional" in the standard because
    this state represents the situation in which there is no connection between devices.
    It either hasn''t been created yet or has just been destroyed (if that makes sense).
    | Passive Open: A server begins the process of connection setup by doing a passive
    open on a TCP port. At the same time, it sets up the data structure (transmission
    control block, or TCB) that it needs in order to manage the connection. It then
    transitions to the LISTEN state. |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| CLOSED | 每个连接在建立过程开始之前都处于的默认状态。在标准中，该状态被称为“虚构的”，因为此状态表示设备之间没有连接的情况。它要么尚未创建，要么刚刚被销毁（如果这样有意义）。|
    被动打开：服务器通过在 TCP 端口上进行被动打开开始连接设置过程。同时，它设置它需要以管理连接所需的数据结构（传输控制块，或 TCB）。然后它过渡到 LISTEN
    状态。|'
- en: '|   |   | Active Open, Send SYN: A client begins the connection setup by sending
    a SYN message, and it sets up a TCB for this connection. It then transitions to
    the SYN-SENT state. |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 激活打开，发送 SYN：客户端通过发送一个 SYN 消息开始连接设置，并为该连接设置一个 TCB。然后它过渡到 SYN-SENT
    状态。|'
- en: '| LISTEN | A device (normally a server) is waiting to receive a SYN message
    from a client. It has not yet sent its own SYN message. | Receive Client SYN,
    Send SYN+ACK: The server device receives a SYN from a client. It sends back a
    message that contains its own SYN and acknowledges the one it received. The server
    moves to the SYN-RECEIVED state. |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| LISTEN | 设备（通常是服务器）正在等待从客户端接收一个 SYN 消息。它尚未发送自己的 SYN 消息。| 接收客户端 SYN，发送 SYN+ACK：服务器设备收到来自客户端的
    SYN。它发送一个包含自己的 SYN 并确认它收到的消息。服务器移动到 SYN-RECEIVED 状态。|'
- en: '| SYN-SENT | The device (normally a client) has sent a SYN message and is waiting
    for a matching SYN from the other device (usually a server). | Receive SYN, Send
    ACK: If the device that has sent its SYN message receives a SYN from the other
    device but not an ACK for its own SYN, it acknowledges the SYN it receives and
    then transitions to SYN-RECEIVED in order to wait for the acknowledgment to its
    own SYN. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| SYN-SENT | 设备（通常是客户端）已发送一个 SYN 消息并正在等待来自另一设备的匹配 SYN（通常来自服务器）。| 接收 SYN，发送
    ACK：如果发送了 SYN 消息的设备收到了来自另一设备的 SYN 但没有对其自己的 SYN 的 ACK，它将确认收到的 SYN，然后过渡到 SYN-RECEIVED
    状态以等待对其自己的 SYN 的确认。|'
- en: '|   |   | Receive SYN+ACK, Send ACK: If the device that sent the SYN receives
    both an acknowledgment to its SYN and a SYN from the other device, it acknowledges
    the SYN received and then moves straight to the ESTABLISHED state. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 接收 SYN+ACK，发送 ACK：如果发送了 SYN 的设备收到了对其 SYN 的确认和来自另一设备的 SYN，它将确认收到的
    SYN，然后直接移动到 ESTABLISHED 状态。|'
- en: '| SYN-RECEIVED | The device has received a SYN (connection request) from its
    partner and sent its own SYN. It is now waiting for an ACK to its SYN in order
    to finish the connection setup. | Receive ACK: When the device receives the ACK
    to the SYN that it sent, it transitions to the ESTABLISHED state. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| SYN-RECEIVED | 设备已从其伙伴那里收到一个 SYN（连接请求）并发送了自己的 SYN。现在它正在等待对它的 SYN 的 ACK 以完成连接设置。|
    接收 ACK：当设备收到它发送的 SYN 的 ACK 时，它过渡到 ESTABLISHED 状态。|'
- en: '| ESTABLISHED | The steady state of an open TCP connection. Both devices can
    exchange data freely once both devices in the connection enter this state. This
    will continue until they close the connection. | Close, Send FIN: A device can
    close the connection by sending a message with the FIN bit sent, and then it can
    transition to the FIN-WAIT-1 state. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| ESTABLISHED | 开放 TCP 连接的稳定状态。一旦连接中的两个设备都进入此状态，它们就可以自由交换数据。这将继续，直到它们关闭连接。|
    关闭，发送 FIN：设备可以通过发送带有 FIN 位设置的消息来关闭连接，然后它可以过渡到 FIN-WAIT-1 状态。|'
- en: '|   |   | Receive FIN: A device may receive a FIN message from its connection
    partner asking that the connection be closed. It will acknowledge this message
    and transition to the CLOSE-WAIT state. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 接收 FIN：设备可能从其连接伙伴那里收到一个请求关闭连接的 FIN 消息。它将确认此消息并过渡到 CLOSE-WAIT 状态。|'
- en: '| CLOSE-WAIT | The device has received a close request (FIN) from the other
    device. It must now wait for the application on the local device to acknowledge
    this request and generate a matching request. | Close, Send FIN: The application
    using TCP, having been informed that the other process wants to shut down, sends
    a close request to the TCP layer on the machine on which it is running. TCP then
    sends a FIN to the remote device that already asked to terminate the connection.
    This device now transitions to LAST-ACK. |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| CLOSE-WAIT | 设备已从另一设备收到一个关闭请求（FIN）。它现在必须等待本地设备上的应用程序确认此请求并生成一个匹配的请求。 | 关闭，发送FIN：使用TCP的应用程序在被告知另一进程想要关闭后，向其运行的机器上的TCP层发送一个关闭请求。然后TCP向已请求终止连接的远程设备发送一个FIN。此设备现在过渡到LAST-ACK。
    |'
- en: '| LAST-ACK | A device that has already received a close request and acknowledged
    has sent its own FIN and is waiting for an ACK to this request. | Receive ACK
    for FIN: The device receives an acknowledgment for its close request. We have
    now sent our FIN and had it acknowledged, and received the other device''s FIN
    and acknowledged it, so we go straight to the CLOSED state. |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| LAST-ACK | 已经收到关闭请求并确认的设备已发送自己的FIN并正在等待对此请求的ACK。 | 接收FIN的ACK：设备收到了其关闭请求的确认。我们现在已发送我们的FIN并得到了确认，收到了另一设备的FIN并对其进行了确认，所以我们直接过渡到CLOSED状态。
    |'
- en: '| FIN-WAIT-1 | A device in this state is waiting for an ACK for a FIN it has
    sent, or is waiting for a connection termination request from the other device.
    | Receive ACK for FIN: The device receives an acknowledgment for its close request.
    It transitions to the FIN-WAIT-2 state. |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-1 | 处于此状态的设备正在等待对它发送的FIN的ACK，或者正在等待来自另一设备的连接终止请求。 | 接收FIN的ACK：设备收到了其关闭请求的确认。它过渡到FIN-WAIT-2状态。
    |'
- en: '|   |   | Receive FIN, Send ACK: The device does not receive an ACK for its
    own FIN, but receives a FIN from the other device. It acknowledges it and then
    moves to the CLOSING state. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 接收FIN，发送ACK：设备没有收到自己FIN的ACK，但收到了来自另一设备的FIN。它确认了它，然后移动到CLOSING状态。
    |'
- en: '| FIN-WAIT-2 | A device in this state has received an ACK for its request to
    terminate the connection and is now waiting for a matching FIN from the other
    device. | Receive FIN, Send ACK: The device receives a FIN from the other device.
    It acknowledges it and then moves to the TIME-WAIT state. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-2 | 处于此状态的设备已收到其终止连接请求的ACK，并现在正在等待来自另一设备的匹配FIN。 | 接收FIN，发送ACK：设备收到来自另一设备的FIN。它确认了它，然后移动到TIME-WAIT状态。
    |'
- en: '| CLOSING | The device has received a FIN from the other device and has sent
    an ACK for it, but has not yet received an ACK for its own FIN message. | Receive
    ACK for FIN: The device receives an acknowledgment for its close request. It transitions
    to the TIME-WAIT state. |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| CLOSING | 设备已从另一设备收到一个FIN并对其发送了ACK，但尚未收到对自己FIN消息的ACK。 | 接收FIN的ACK：设备收到了其关闭请求的确认。它过渡到TIME-WAIT状态。
    |'
- en: '| TIME-WAIT | The device has now received a FIN from the other device and acknowledged
    it, and sent its own FIN and received an ACK for it. We are finished, except for
    waiting to ensure the ACK is received and preventing potential overlap with new
    connections. (See the "TCP Connection Termination" section later in this chapter
    for more details on this state.) | Timer Expiration: After a designated wait period,
    the device transitions to the CLOSED state. |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| TIME-WAIT | 设备已从另一设备收到一个FIN并确认了它，并发送了自己的FIN并收到了对其的ACK。我们已经完成，除了等待确保收到ACK以及防止与新的连接发生潜在的重叠。（有关此状态的更多详细信息，请参阅本章后面的“TCP连接终止”部分。）
    | 计时器超时：在指定等待期后，设备过渡到CLOSED状态。 |'
- en: Thus, for example, at the start of connection establishment, the two devices
    will take different routes to get to the ESTABLISHED state. One device (the server
    usually) will pass through the LISTEN state, while the other (the client) will
    go through SYN-SENT state. Similarly, one device will initiate connection termination
    and take the path through the FIN-WAIT-1 state in order to get back to the CLOSED
    state; the other will go through the CLOSE-WAIT and LAST-ACK states. However,
    if both try to open at once, they each proceed through SYN-SENT and SYN-RECEIVED
    states, and if both try to close at once, they go through FIN-WAIT-1, CLOSING,
    and TIME-WAIT states roughly simultaneously.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，在连接建立的开始，两个设备将采取不同的路径到达ESTABLISHED状态。一个设备（通常是服务器）将通过LISTEN状态，而另一个（客户端）将通过SYN-SENT状态。同样，一个设备将发起连接终止，并通过FIN-WAIT-1状态路径返回CLOSED状态；另一个将经过CLOSE-WAIT和LAST-ACK状态。然而，如果两者同时尝试打开，它们将分别通过SYN-SENT和SYN-RECEIVED状态，如果两者同时尝试关闭，它们将大致同时通过FIN-WAIT-1、CLOSING和TIME-WAIT状态。
- en: Although FSM may seem a bit intimidating at first, if you spend a few minutes
    with it, you can get a good handle on how TCP works. The FSM will be of great
    use in making sense of the connection establishment and termination processes
    discussed later in this chapter, and reading those sections will help you make
    sense of the FSM.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FSM一开始可能有些令人畏惧，但如果你花几分钟时间了解它，你就可以很好地掌握TCP的工作原理。FSM将在理解本章后面讨论的连接建立和终止过程中非常有用，阅读这些部分将帮助你理解FSM。
- en: Tip
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The TCP finite state machine (FSM) describes the sequence of
    steps that both devices take in a TCP session as they establish, manage, and close
    the connection. Each device may take a different path through the states, because
    under normal circumstances, the operation of the protocol is not symmetric—one
    device initiates connection establishment or termination, and the other responds.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP有限状态机（FSM）描述了在TCP会话中，两个设备在建立、管理和关闭连接时采取的步骤序列。每个设备可能通过不同的状态路径，因为在正常情况下，协议的操作不是对称的——一个设备发起连接建立或终止，另一个设备响应。'
- en: '![The TCP finite state machine (FSM) This diagram illustrates the simplified
    TCP FSM. The shadings are not an official part of the definition of the FSM; I
    have added them to show more clearly the sequences the two devices took to open
    and close a link. For establishment and termination, there is a regular sequence,
    in which the initiating and responding devices go through different states, and
    a simultaneous sequence, in which each uses the same sequence.](httpatomoreillycomsourcenostarchimages288105.png.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![TCP有限状态机（FSM）此图说明了简化的TCP FSM。阴影部分不是FSM定义的官方部分；我添加它们是为了更清楚地显示两个设备打开和关闭连接的序列。对于建立和终止，有一个常规序列，其中发起和响应设备通过不同的状态，以及一个同时序列，其中每个设备使用相同的序列。](httpatomoreillycomsourcenostarchimages288105.png.jpg)'
- en: Figure 47-1. The TCP finite state machine (FSM) This diagram illustrates the
    simplified TCP FSM. The shadings are not an official part of the definition of
    the FSM; I have added them to show more clearly the sequences the two devices
    took to open and close a link. For establishment and termination, there is a regular
    sequence, in which the initiating and responding devices go through different
    states, and a simultaneous sequence, in which each uses the same sequence.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 图47-1. TCP有限状态机（FSM）此图说明了简化的TCP FSM。阴影部分不是FSM定义的官方部分；我添加它们是为了更清楚地显示两个设备打开和关闭连接的序列。对于建立和终止，有一个常规序列，其中发起和响应设备通过不同的状态，以及一个同时序列，其中每个设备使用相同的序列。
- en: TCP Connection Preparation
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接准备
- en: 'In [Chapter 43](ch43.html "Chapter 43. TCP AND UDP ADDRESSING: PORTS AND SOCKETS"),
    I raised an important point about TCP operation, particularly that it must be
    capable of handling many connections simultaneously. For this reason, we must
    uniquely identify each connection using the *quadruple* of the socket identifiers
    (IP address and port number) for each of the two devices on the connection. The
    process of setting up, managing, and terminating a connection is performed independently
    for each connection.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第43章](ch43.html "第43章。TCP和UDP寻址：端口和套接字")中，我提出了一个关于TCP操作的重要观点，特别是它必须能够同时处理多个连接。因此，我们必须使用每个连接上两个设备的套接字标识符（IP地址和端口号）的四元组来唯一标识每个连接。为每个连接设置、管理和终止连接的过程是独立进行的。
- en: 'Storing Connection Data: The Transmission Control Block (TCB)'
  id: totrans-581
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储连接数据：传输控制块 (TCB)
- en: Since each connection is distinct, we must maintain data about each connection
    separately. TCP uses a special data structure for this purpose, called a *transmission
    control block (TCB)*. The TCB contains all the important information about the
    connection, such as the two socket numbers that identify it and pointers to buffers
    that hold incoming and outgoing data. The TCB also implements the sliding window
    mechanism. It holds variables that keep track of the number of bytes received
    and acknowledged, bytes received and not yet acknowledged, current window size,
    and so forth. Each device maintains its own TCB for the connection.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个连接都是独特的，我们必须分别维护每个连接的数据。TCP 使用一个特殊的数据结构来此目的，称为 *传输控制块 (TCB)*。TCB 包含有关连接的所有重要信息，例如标识它的两个套接字编号以及指向包含传入和传出数据的缓冲区的指针。TCB
    还实现了滑动窗口机制。它包含跟踪接收和确认的字节数、接收但尚未确认的字节数、当前窗口大小等变量的变量。每个设备都维护自己的连接 TCB。
- en: Before the process of setting up a TCP connection can begin, the devices on
    each end must perform some "prep work." One of the tasks required in order to
    prepare for the connection is to set up the TCB that will be used to hold information
    about it. This is done right at the very start of the connection establishment
    process, when each device transitions out of the CLOSED state.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 TCP 连接的过程开始之前，每个端点的设备必须执行一些“准备工作”。为了准备连接，所需的任务之一是设置将用于存储有关连接信息的 TCB。这是在连接建立过程的开始时进行的，当时每个设备从关闭状态过渡出来。
- en: Active and Passive Opens
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主动和被动打开
- en: 'TCP/IP is based on the client/server model of operation, and TCP connection
    setup is based on the existence of these roles as well. The client and server
    each prepare for the connection by performing an *Open* operation. However, there
    are two different kinds of Open operations:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 基于客户端/服务器模型进行操作，TCP 连接设置也是基于这些角色的存在。客户端和服务器各自通过执行一个 *打开* 操作来准备连接。然而，存在两种不同的打开操作：
- en: '**Active Open** A client process using TCP takes the active role and initiates
    the connection by sending a TCP message to start the connection (a SYN message).'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '**主动打开** 使用 TCP 的客户端进程扮演主动角色，通过发送一个 TCP 消息来启动连接（一个 SYN 消息）来初始化连接。'
- en: '**Passive Open** A server process designed to use TCP takes a more "laid-back"
    approach. It performs a *passive Open* by contacting TCP and saying, "I''m here,
    and I''m waiting for clients that may wish to talk to me to send me a message
    on the following port number." The Open is called *passive* because, aside from
    indicating that the process is listening, the server process does nothing. A passive
    Open can specify that the server is waiting for an active Open from a specific
    client, though not all TCP/IP APIs support this capability. More commonly, a server
    process is willing to accept connections from all comers. Such a passive Open
    is said to be *unspecified*.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**被动打开** 设计用于使用 TCP 的服务器进程采取了一种更“放松”的方法。它通过联系 TCP 并说，“我在这里，我在等待可能想和我交谈的客户端通过以下端口号发送给我消息”来执行一个
    *被动打开*。这个打开被称为 *被动*，因为除了表明进程正在监听外，服务器进程不做任何事情。被动打开可以指定服务器正在等待来自特定客户端的主动打开，尽管并非所有
    TCP/IP API 都支持这种功能。更常见的是，服务器进程愿意接受所有来者的连接。这种被动打开被称为 *未指定*。'
- en: Tip
  id: totrans-588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** A client process initiates a TCP connection by performing an
    active *Open*, sending a SYN message to a server. A server process using TCP prepares
    for an incoming connection request by performing a *passive Open*. For each TCP
    session, both devices create a data structure, called a *transmission control
    block (TCB)*, that is used to hold important data related to the connection.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 客户端进程通过执行一个主动的 *打开* 操作，向服务器发送一个 SYN 消息来初始化一个 TCP 连接。使用 TCP 的服务器进程通过执行一个
    *被动打开* 操作来准备接收进入的连接请求。对于每个 TCP 会话，两个设备都会创建一个数据结构，称为 *传输控制块 (TCB)*，用于存储与连接相关的重要数据。'
- en: Preparation for Connection
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接准备
- en: Both the client and the server create the TCB for the connection at the time
    that they perform the Open. The client already knows the IP addresses and port
    numbers for both the client process and the server process it is trying to reach,
    so it can use these to uniquely identify the connection and the TCB that goes
    with it.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器在执行打开操作时都会为连接创建 TCB。客户端已经知道它试图连接的客户端进程和服务器进程的 IP 地址和端口号，因此可以使用这些信息来唯一标识连接及其相关的
    TCB。
- en: For the server, the concept of a TCB at this stage of the game is a bit more
    complex. If the server is waiting for a particular client, it can identify the
    connection using its own socket and the socket of the client for which it is waiting.
    Normally, however, the server doesn't know which client is trying to reach it.
    In fact, more than one client could contact it at nearly the same time.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器来说，在这个游戏阶段，TCB的概念要复杂一些。如果服务器正在等待特定的客户端，它可以使用自己的套接字和它正在等待的客户端的套接字来识别连接。然而，通常情况下，服务器不知道哪个客户端正在尝试连接它。实际上，可能有多个客户端几乎同时联系它。
- en: In this case, the server creates a TCB with an unspecified (zero) client socket
    number and waits to receive an active Open. It then *binds* the socket number
    of the client to the TCB for the passive Open as part of the connection process.
    To allow the server to handle multiple incoming connections, the server process
    may perform several unspecified passive Opens simultaneously.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器创建了一个具有未指定（零）客户端套接字号的TCB，并等待接收一个活跃的Open。然后，它将客户端的套接字号绑定到TCB，作为连接过程的一部分进行被动打开。为了允许服务器处理多个传入连接，服务器进程可能同时执行多个未指定的被动打开。
- en: The TCB for a connection is maintained throughout the connection and destroyed
    when the connection is completely terminated, and the device returns to the CLOSED
    state. TCP does include a procedure that handles the situation in which both devices
    perform an active Open simultaneously, as I discuss the next section.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的TCB在整个连接过程中保持，并在连接完全终止时销毁，设备返回到CLOSED状态。TCP确实包括处理两个设备同时执行主动打开的情况的进程，正如我在下一节讨论的那样。
- en: 'TCP Connection Establishment Process: The Three-Way Handshake'
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接建立过程：三次握手
- en: Before TCP can be employed for any actually useful purpose—that is, sending
    data—a connection must be set up between the two devices that wish to communicate.
    This process, usually called *connection establishment*, involves an exchange
    of messages that transitions both devices from their initial connection state
    (CLOSED) to the normal operating state (ESTABLISHED).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP可以用于任何实际有用的目的——即发送数据之前——必须在希望通信的两个设备之间建立连接。这个过程通常称为*连接建立*，涉及交换消息，将两个设备从它们的初始连接状态（CLOSED）转换到正常操作状态（ESTABLISHED）。
- en: Connection Establishment Functions
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接建立功能
- en: 'The connection establishment process actually accomplishes the following tasks
    as it creates a connection suitable for data exchange:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立过程实际上在创建一个适合数据交换的连接时完成了以下任务：
- en: '**Contact and Communication** The client and server make contact with each
    other and establish communication by sending each other messages. The server usually
    doesn''t even know which client it will be talking to before this point, so it
    discovers this during connection establishment.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**联系和通信** 客户端和服务器通过相互发送消息来建立联系并建立通信。在此点之前，服务器通常甚至不知道它将和哪个客户端交谈，因此它会在连接建立过程中发现这一点。'
- en: '**Sequence Number Synchronization** Each device lets the other know what initial
    sequence number it wants to use for its first transmission.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列号同步** 每个设备让对方知道它希望用于第一次传输的初始序列号。'
- en: '**Parameter Exchange** The two devices exchange certain parameters that control
    the operation of the TCP connection.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数交换** 两个设备交换控制TCP连接操作的某些参数。'
- en: I'll discuss the sequence number synchronization and parameter exchange tasks
    in the "TCP Connection Establishment Sequence Number Synchronization and Parameter
    Exchange" section later in this chapter.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章后面的“TCP连接建立序列号同步和参数交换”部分讨论序列号同步和参数交换任务。
- en: 'Control Messages Used for Connection Establishment: SYN and ACK'
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于连接建立的控制消息：SYN和ACK
- en: 'TCP uses control messages to manage the process of contact and communication.
    There aren''t, however, any special TCP control message types; all TCP messages
    use the same segment format. A set of control flags in the TCP header indicates
    whether a segment is being used for control purposes or just to carry data. As
    I introduced in the discussion of the TCP FSM earlier in the chapter, two control
    message types are used in connection setup, which are specified by setting the
    following two flags:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: TCP使用控制消息来管理联系和通信的过程。然而，并没有任何特殊的TCP控制消息类型；所有TCP消息都使用相同的段格式。TCP头部的一组控制标志指示一个段是否用于控制目的还是仅用于携带数据。正如我在本章前面关于TCP
    FSM的讨论中提到的，在连接设置中使用了两种控制消息类型，这些类型通过设置以下两个标志来指定：
- en: '**SYN** Indicates that the segment is being used to initialize a connection.
    SYN stands for *synchronize*, in reference to the sequence number synchronization
    task in the connection establishment process.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '**SYN** 表示该段用于初始化连接。SYN代表*同步*，指的是连接建立过程中的序列号同步任务。'
- en: '**ACK** Indicates that the device sending the segment is conveying an *acknowledgment*
    for a message it has received (such as a SYN).'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '**ACK** 表示发送段落的设备正在传达对已接收消息（如SYN）的确认。'
- en: There are also other control bits (*FIN*, *RST*, *PSH*, and *URG*) that aren't
    important to connection establishment, so I will discuss them in other topics.
    In common TCP parlance, a message with a control bit set is often named for that
    bit. For example, if the SYN control bit is set, the segment is often called a
    SYN message. Similarly, a segment with the ACK bit set is an ACK message, or even
    just an ACK.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他控制位（*FIN*、*RST*、*PSH*和*URG*），它们对于连接建立并不重要，因此我将在其他主题中讨论它们。在常见的TCP术语中，设置控制位的消息通常以该位命名。例如，如果设置了SYN控制位，该段通常被称为SYN消息。同样，设置了ACK位的段是ACK消息，甚至只是ACK。
- en: 'Normal Connection Establishment: The Three-Way Handshake'
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正常连接建立：三次握手
- en: To establish a connection, each device must send a SYN message and receive an
    ACK message for it from the other device. Thus, conceptually, we need to have
    four control messages pass between the devices. However, it's inefficient to send
    a SYN and an ACK in separate messages when one could communicate both simultaneously.
    Thus, in the normal sequence of events in connection establishment, one of the
    SYNs and one of the ACKs are sent together by setting both of the relevant bits
    (a message sometimes called a *SYN+ACK*). This makes a total of three messages,
    and for this reason the connection procedure is called a *three-way handshake*.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立连接，每个设备都必须发送一个SYN消息并从另一个设备接收对该消息的ACK消息。因此，从概念上讲，我们需要在设备之间传递四个控制消息。然而，当可以同时通信时，将SYN和ACK分别发送在单独的消息中是不高效的。因此，在连接建立过程中的正常事件顺序中，其中一个SYN和一个ACK通过设置相关位（有时称为*SYN+ACK*的消息）一起发送。这使得总共只有三条消息，因此连接过程被称为*三次握手*。
- en: Tip
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The normal process of establishing a connection between a TCP
    client and server involves the following three steps: The client sends a *SYN*
    message. The server sends a message that combines an *ACK* for the client''s *SYN*
    and contains the server''s SYN. And the client sends an ACK for the server''s
    SYN. This is called the *TCP three-way handshake*.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP客户端和服务器之间建立连接的正常过程涉及以下三个步骤：客户端发送一个*SYN*消息。服务器发送一个消息，该消息包含对客户端*SYN*的*ACK*以及服务器的SYN。然后客户端对服务器的SYN发送ACK。这被称为*TCP三次握手*。'
- en: '[Table 47-2](ch47s03.html#tcp_three-way_handshake_connection_estab "Table 47-2. TCP
    Three-Way Handshake Connection Establishment Procedure") describes in detail how
    the three-way handshake works (including a summary of the preparation discussed
    in the previous section). It is adapted from the table describing the TCP FSM
    ([Table 47-1](ch47.html#tcp_finite_state_machine_fsm_states_even "Table 47-1. TCP
    Finite State Machine (FSM) States, Events, and Transitions")), but shows what
    happens for both the server and the client over time. Each row shows the state
    the device begins in, what action it takes in that state, and the state to which
    it transitions. The transmit and receive parts of each of the three steps of the
    handshake process are shown as well. The same process is also illustrated in 47-2.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[表47-2](ch47s03.html#tcp_three-way_handshake_connection_estab "表47-2. TCP三次握手连接建立过程")详细描述了三次握手是如何工作的（包括对上一节中讨论的准备的总结）。它改编自描述TCP有限状态机（FSM）的表格（[表47-1](ch47.html#tcp_finite_state_machine_fsm_states_even
    "表47-1. TCP有限状态机 (FSM) 状态、事件和转换"）），但显示了服务器和客户端随时间发生的情况。每一行显示了设备开始时的状态，在该状态下采取的动作，以及转换到的状态。握手过程的三个步骤中的发送和接收部分也显示了出来。同样的过程也在47-2中进行了说明。'
- en: Table 47-2. TCP Three-Way Handshake Connection Establishment Procedure
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 表47-2. TCP三次握手连接建立过程
- en: '| Client | Server |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 服务器 |'
- en: '| --- | --- |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Start State | Action | Move to State | Start State | Action | Move to State
    |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| 开始状态 | 动作 | 转换到状态 | 开始状态 | 动作 | 转换到状态 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| CLOSED | The client cannot do anything until the server has performed a passive
    Open and is ready to accept a connection. | — | CLOSED | The server performs a
    passive Open, creating a TCB for the connection and readying itself for the receipt
    of a connection request (SYN) from a client. | LISTEN |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| CLOSED | The client cannot do anything until the server has performed a passive
    Open and is ready to accept a connection. | — | CLOSED | The server performs a
    passive Open, creating a TCB for the connection and readying itself for the receipt
    of a connection request (SYN) from a client. | LISTEN |'
- en: '| CLOSED | Step 1 Transmit: The client performs an active Open, creating a
    TCB) for the connection and sending a SYN message to the server. | SYN-SENT |
    LISTEN | The server waits for contact from a client. | — |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| CLOSED | Step 1 Transmit: The client performs an active Open, creating a
    TCB) for the connection and sending a SYN message to the server. | SYN-SENT |
    LISTEN | The server waits for contact from a client. | — |'
- en: '| SYN-SENT | The client waits to receive an ACK to the SYN that it has sent,
    as well as the server''s SYN. | — | LISTEN | Step 1 Receive, Step 2 Transmit:
    The server receives the SYN from the client. It sends a single SYN+ACK message
    back to the client that contains an ACK for the client''s SYN, as well as the
    server''s own SYN. | SYN-RECEIVED |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| SYN-SENT | The client waits to receive an ACK to the SYN that it has sent,
    as well as the server''s SYN. | — | LISTEN | Step 1 Receive, Step 2 Transmit:
    The server receives the SYN from the client. It sends a single SYN+ACK message
    back to the client that contains an ACK for the client''s SYN, as well as the
    server''s own SYN. | SYN-RECEIVED |'
- en: '| SYN-SENT | Step 2 Receive, Step 3 Transmit: The client receives from the
    server the SYN+ACK containing the ACK to the client''s SYN, and the SYN from the
    server. It sends the server an ACK for the server''s SYN. The client is now finished
    with the connection establishment. | ESTABLISHED | SYN-RECEIVED | The server waits
    for an ACK to the SYN it sent previously. | — |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| SYN-SENT | Step 2 Receive, Step 3 Transmit: The client receives from the
    server the SYN+ACK containing the ACK to the client''s SYN, and the SYN from the
    server. It sends the server an ACK for the server''s SYN. The client is now finished
    with the connection establishment. | ESTABLISHED | SYN-RECEIVED | The server waits
    for an ACK to the SYN it sent previously. | — |'
- en: '| ESTABLISHED | The client is waiting for the server to finish connection establishment
    so they can operate normally. |   | SYN-RECEIVED | Step 3 Receive: The server
    receives the ACK to its SYN and is now finished with connection establishment.
    | ESTABLISHED |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| ESTABLISHED | The client is waiting for the server to finish connection establishment
    so they can operate normally. |   | SYN-RECEIVED | Step 3 Receive: The server
    receives the ACK to its SYN and is now finished with connection establishment.
    | ESTABLISHED |'
- en: '| ESTABLISHED | The client is ready for normal data transfer operations. |
      | ESTABLISHED | The server is ready for normal data transfer operations. |  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| ESTABLISHED | The client is ready for normal data transfer operations. |
      | ESTABLISHED | The server is ready for normal data transfer operations. |  |'
- en: '![TCP three-way handshake connection establishment procedure This diagram illustrates
    how a client and server establish a conventional connection. It shows how the
    three messages sent during the process and how each device transitions from the
    CLOSED state through intermediate states until the session is in the ESTABLISHED
    state.](httpatomoreillycomsourcenostarchimages288107.png.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![TCP 三次握手连接建立过程 此图展示了客户端和服务器如何建立传统连接。它显示了在过程中发送的三个消息以及每个设备如何从关闭状态通过中间状态过渡到已建立的会话状态。](httpatomoreillycomsourcenostarchimages288107.png.jpg)'
- en: Figure 47-2. TCP three-way handshake connection establishment procedure This
    diagram illustrates how a client and server establish a conventional connection.
    It shows how the three messages sent during the process and how each device transitions
    from the CLOSED state through intermediate states until the session is in the
    ESTABLISHED state.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 图 47-2. TCP 三次握手连接建立过程 此图展示了客户端和服务器如何建立传统连接。它显示了在过程中发送的三个消息以及每个设备如何从关闭状态通过中间状态过渡到已建立的会话状态。
- en: Simultaneous Open Connection Establishment
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步打开连接建立
- en: TCP is also set up to handle the situation in which both devices perform an
    active Open instead of one doing a passive Open. This may occur if two clients
    are trying to reach each other instead of a client and a server. It is uncommon,
    however, and only happens under certain circumstances. Simultaneous connection
    establishment can also happen only if one of the devices uses a well-known port
    as its source port.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 也被设置为处理两种设备都执行主动打开而不是一个执行被动打开的情况。这种情况可能发生在两个客户端试图互相连接而不是客户端和服务器之间。然而，这种情况并不常见，并且仅在特定情况下发生。同时建立连接也仅当其中一个设备使用一个知名端口作为其源端口时才会发生。
- en: In the case of simultaneous open connection establishment, the steps are different
    for both devices. Each client will perform an active Open and will then proceed
    through both the SYN-SENT and SYN-RECEIVED states until the clients acknowledge
    each other's SYNs. This means that there is no three-way handshake; instead, there
    is something like two simultaneous two-way handshakes. Each client sends a SYN,
    receives the other's SYN, acknowledges the SYN with an ACK it, and then waits
    for its own ACK.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 在同时打开连接建立的情况下，对于两个设备，步骤是不同的。每个客户端将执行主动打开，然后通过 SYN-SENT 和 SYN-RECEIVED 状态，直到客户端相互确认对方的
    SYN。这意味着没有三次握手；相反，有类似两个同时双向握手的操作。每个客户端发送一个 SYN，接收对方的 SYN，通过发送一个 ACK 来确认对方的 SYN，然后等待自身的
    ACK。
- en: I have described the transaction for establishing open connections simultaneously,
    in a simplified way, in [Table 47-3](ch47s03.html#tcp_simultaneous_open_connection_establi
    "Table 47-3. TCP Simultaneous Open Connection Establishment Procedure") and illustrated
    it in [Figure 47-3](ch47s03.html#tcp_simultaneous_open_connection_e-id001 "Figure 47-3. TCP
    simultaneous open connection establishment procedure This diagram shows what happens
    when two devices try to open a connection to each other at the same time. In this
    case, instead of a three-way handshake, each sends a SYN and receives an ACK.
    They each follow the same sequence of states, which differs from both sequences
    in the normal three-way handshake."). To limit the table size, I have shown the
    activities performed by the two devices occurring simultaneously (in the same
    row). In reality, the actions don't need to occur at exactly the same time and
    probably won't. All that must happen for the simultaneous procedure to be followed
    is that each device receives a SYN before getting an ACK for its own SYN, as [Figure 47-3](ch47s03.html#tcp_simultaneous_open_connection_e-id001
    "Figure 47-3. TCP simultaneous open connection establishment procedure This diagram
    shows what happens when two devices try to open a connection to each other at
    the same time. In this case, instead of a three-way handshake, each sends a SYN
    and receives an ACK. They each follow the same sequence of states, which differs
    from both sequences in the normal three-way handshake.") shows.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我以简化的方式描述了同时建立打开连接的交易，并在[表 47-3](ch47s03.html#tcp_simultaneous_open_connection_establi
    "表 47-3. TCP 同时打开连接建立过程")中进行了说明，并在[图 47-3](ch47s03.html#tcp_simultaneous_open_connection_e-id001
    "图 47-3. TCP 同时打开连接建立过程 此图显示了当两个设备同时尝试相互打开连接时会发生什么。在这种情况下，代替三次握手，每个设备都发送一个 SYN
    并接收一个 ACK。它们各自遵循相同的序列状态，这与正常的三次握手的两个序列都不同。")中进行了说明。为了限制表格大小，我显示了两个设备同时进行的操作（在同一行）。实际上，这些动作不需要在完全相同的时间发生，可能也不会。为了遵循同时过程，必须发生的事情是每个设备在收到对自身
    SYN 的 ACK 之前都收到一个 SYN，如图 47-3 所示。
- en: Table 47-3. TCP Simultaneous Open Connection Establishment Procedure
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 表 47-3. TCP 同时打开连接建立过程
- en: '| Client A | Client B |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 A | 客户端 B |'
- en: '| --- | --- |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Start State | Action | Move to State | Start State | Action | Move to State
    |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| 开始状态 | 动作 | 转变到状态 | 开始状态 | 动作 | 转变到状态 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| CLOSED | Client A Step 1 Transmit: Client A performs an active Open, creating
    a TCB and sending a SYN to the server. | SYN-SENT | CLOSED | Client B Step 1 Transmit:
    Client B performs an active Open, creating a TCB and sending a SYN to the server.
    | SYN-SENT |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | 客户端 A 第一步发送：客户端 A 执行主动打开，创建一个 TCB 并向服务器发送一个 SYN。 | SYN-SENT | 关闭 | 客户端
    B 第一步发送：客户端 B 执行主动打开，创建一个 TCB 并向服务器发送一个 SYN。 | SYN-SENT |'
- en: '| SYN-SENT | Client B Step 1 Receive and Step 2 Transmit: Client A receives
    Client B''s SYN and sends it an ACK. It is still waiting for an ACK to its own
    SYN. | SYN-RECEIVED | SYN-SENT | Client A Step 1 Receive and Step 2 Transmit:
    Client B receives Client A''s SYN and sends it an ACK. It is still waiting for
    an ACK to its own SYN. | SYN-RECEIVED |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| SYN-SENT | 客户端 B 第一步接收并第二步发送：客户端 A 接收到客户端 B 的 SYN 并向其发送一个 ACK。它仍在等待对自身 SYN
    的 ACK。 | SYN-RECEIVED | SYN-SENT | 客户端 A 第一步接收并第二步发送：客户端 B 接收到客户端 A 的 SYN 并向其发送一个
    ACK。它仍在等待对自身 SYN 的 ACK。 | SYN-RECEIVED |'
- en: '| SYN-RECEIVED | Client A Step 2 Receive: Client A receives the ACK from Client
    B for its SYN and finishes connection establishment. | ESTABLISHED | SYN-RECEIVED
    | Client B Step 2 Receive: Client B receives the ACK from Client A for its SYN
    and finishes connection establishment. | ESTABLISHED |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| SYN-RECEIVED | 客户端A第二步接收：客户端A收到客户端B对其SYN的ACK，完成连接建立。 | ESTABLISHED | SYN-RECEIVED
    | 客户端B第二步接收：客户端B收到客户端A对其SYN的ACK，完成连接建立。 | ESTABLISHED |'
- en: '![TCP simultaneous open connection establishment procedure This diagram shows
    what happens when two devices try to open a connection to each other at the same
    time. In this case, instead of a three-way handshake, each sends a SYN and receives
    an ACK. They each follow the same sequence of states, which differs from both
    sequences in the normal three-way handshake.](httpatomoreillycomsourcenostarchimages288109.png.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![TCP同时打开连接建立过程 此图显示了当两个设备同时尝试相互打开连接时会发生什么。在这种情况下，而不是三次握手，每个设备都发送一个SYN并接收一个ACK。它们遵循相同的序列状态，这与正常的三次握手的两个序列都不同。](httpatomoreillycomsourcenostarchimages288109.png.jpg)'
- en: Figure 47-3. TCP simultaneous open connection establishment procedure This diagram
    shows what happens when two devices try to open a connection to each other at
    the same time. In this case, instead of a three-way handshake, each sends a SYN
    and receives an ACK. They each follow the same sequence of states, which differs
    from both sequences in the normal three-way handshake.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 图47-3. TCP同时打开连接建立过程 此图显示了当两个设备同时尝试相互打开连接时会发生什么。在这种情况下，而不是三次握手，每个设备都发送一个SYN并接收一个ACK。它们遵循相同的序列状态，这与正常的三次握手的两个序列都不同。
- en: Tip
  id: totrans-640
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** If one device setting up a TCP connection sends a SYN and then
    receives a SYN from the another device before it acknowledges its SYN, the two
    devices perform a *simultaneous OPEN*, which consists of the exchange of two independent
    SYN and ACK message sets. The end result is the same as the conventional three-way
    handshake, but the process of getting to the ESTABLISHED state is different.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 如果一个设备在确认其SYN之前向另一个设备发送了一个SYN，并且收到了来自另一个设备的SYN，那么这两个设备将执行一个*同时打开*操作，这包括交换两个独立的SYN和ACK消息集。最终结果是与传统的三次握手相同，但达到ESTABLISHED状态的过程是不同的。'
- en: TCP Connection Establishment Sequence Number Synchronization and Parameter Exchange
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接建立序列号同步和参数交换
- en: The TCP three-way handshake describes the mechanism of message exchange that
    allows a pair of TCP devices to move from a closed state to one that is a ready-to-use,
    established connection. Connection establishment is about more than just passing
    messages between devices in order to establish communication. The TCP layers on
    the devices must also exchange information about the sequence numbers each device
    wants to use for its first data transmission. The layers must also exchange information
    about the parameters that will control how the connection operates. The sequence
    numbers exchange is usually called *sequence number synchronization*, and it is
    such an important part of connection establishment that the messages that each
    device sends to start the connection are called *SYN (synchronization)* messages.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: TCP三次握手描述了消息交换机制，允许一对TCP设备从关闭状态移动到就绪状态，即已建立的连接。连接建立不仅仅是设备之间传递消息以建立通信，设备上的TCP层还必须交换每个设备想要用于其第一次数据传输的序列号信息。层还必须交换关于将控制连接操作参数的信息。序列号交换通常称为*序列号同步*，它是连接建立如此重要的部分，以至于每个设备发送以启动连接的消息被称为*SYN（同步）*消息。
- en: You may recall from the TCP fundamentals discussion in [Chapter 46](ch46.html
    "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION")
    that TCP refers to each byte of data individually and uses sequence numbers to
    keep track of which bytes have been sent and received. Since each byte has a sequence
    number, we can acknowledge each byte, or more efficiently, use a single number
    to acknowledge a range of bytes received.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，从[第46章](ch46.html "第46章。传输控制协议（TCP）基础和一般操作")中的TCP基础知识讨论中，TCP对每个数据字节进行单独引用，并使用序列号来跟踪哪些字节已被发送和接收。由于每个字节都有一个序列号，我们可以确认每个字节，或者更有效地，使用一个单一的数字来确认接收到的字节范围。
- en: In the example I gave in [Chapter 46](ch46.html "Chapter 46. TRANSMISSION CONTROL
    PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION"), I assumed that each device
    would start a connection by giving the first byte of data sent between them sequence
    number 1\. A valid question is why wouldn't we *always* just start off each TCP
    connection by sending the first byte of data with a sequence number of 1? The
    sequence numbers are arbitrary, after all, and this is the simplest method. In
    an ideal world, this would probably work, but we don't live in an ideal world.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在我在[第46章](ch46.html "第46章。传输控制协议（TCP）基础和一般操作")中给出的例子中，我假设每个设备都会通过给它们之间发送的第一个数据字节分配序列号1来启动一个连接。一个合理的问题是，为什么我们不会*总是*通过发送序列号为1的第一个数据字节来启动每个TCP连接？毕竟，序列号是任意的，这是最简单的方法。在一个理想的世界里，这可能会起作用，但我们并不生活在一个理想的世界里。
- en: The problem with starting off each connection with a sequence number of 1 is
    that it introduces the possibility of segments from different connections getting
    mixed up. Suppose we established a TCP connection and sent a segment containing
    bytes 1 through 30\. However, a problem with the internetwork caused a delay with
    this segment, and eventually, the TCP connection itself was terminated. We then
    started up a new connection and again used a starting sequence number of 1\. As
    soon as this new connection was started, however, the old segment with bytes labeled
    1 to 30 showed up. The other device would erroneously think those bytes were part
    of the *new* connection.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 以序列号1开始每个连接的问题在于，它引入了不同连接的段可能混淆的可能性。假设我们建立了一个TCP连接并发送了一个包含字节1到30的段。然而，由于互联网的问题，这个段出现了延迟，最终TCP连接本身被终止。然后我们启动了一个新的连接，并再次使用了起始序列号1。然而，当这个新连接开始时，旧的包含字节1到30的段出现了。其他设备会错误地认为这些字节是*新*连接的一部分。
- en: This is but one of several similar problems that could occur. To avoid them,
    each TCP device, at the time a connection is initiated, chooses a 32-bit *initial
    sequence number (ISN)* for the connection. Each device has its own ISN, and those
    ISNs normally won't be the same.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是可能出现的几个类似问题之一。为了避免这些问题，每个TCP设备在建立连接时，都会为该连接选择一个32位的*初始序列号（ISN）*。每个设备都有自己的ISN，而且这些ISN通常不会相同。
- en: Initial Sequence Number Selection
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始序列号选择
- en: Traditionally, each device chose the ISN by making use of a timed counter, like
    a clock of sorts, that was incremented every 4 microseconds. TCP initialized the
    counter when it started up, and then the counter's value increased by one every
    4 microseconds until it reached the largest 32-bit value possible (4,294,967,295),
    at which point it wrapped around to 0 and resumed incrementing. Any time a new
    connection was set up, the ISN was taken from the current value of this timer.
    Since it takes over 4 hours to count from 0 to 4,294,967,295 at 4 microseconds
    per increment, this virtually ensured that each connection would not conflict
    with any previous ones.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，每个设备通过使用一个定时计数器来选择ISN，就像某种时钟，每4微秒增加一次。TCP在启动时初始化计数器，然后计数器的值每4微秒增加1，直到达到可能的32位最大值（4,294,967,295），此时它回绕到0并继续增加。每次建立新的连接时，ISN都是从计时器的当前值中取出的。由于以每增加4微秒计数，从0到4,294,967,295需要超过4小时，这几乎确保了每个连接都不会与之前的任何连接冲突。
- en: One issue with this method is that it made ISNs predictable. A malicious person
    could write code to analyze ISNs and then predict the ISN of a subsequent TCP
    connection based on the ISNs used in earlier ones. Malicious hackers have exploited
    this security risk in the past (such as in the case of the famous Mitnick attack).
    To defeat the malicious hackers, implementations now use a random number in their
    ISN selection process.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是它使得ISN可预测。恶意的人可以编写代码来分析ISN，然后根据之前使用的ISN预测后续TCP连接的ISN。恶意黑客过去已经利用了这种安全风险（例如著名的米特尼克攻击）。为了击败恶意黑客，现在的实现现在在ISN选择过程中使用随机数。
- en: TCP Sequence Number Synchronization
  id: totrans-651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP序列号同步
- en: Once each device chooses its ISN, it sends the ISN value to the other device
    in the Sequence Number field in the device's initial SYN message. The device receiving
    the SYN responds with an ACK message that acknowledges the SYN (which may also
    contain its own SYN, as in step 2 of the three-way handshake). In the ACK message,
    the Acknowledgment Number field is set to the value of the ISN that is received
    from the other device *plus one*. This represents the next sequence number the
    device expects to receive from its peer; the ISN actually represents the sequence
    number of the last byte received (fictitious in this case, since the connection
    is new and nothing yet has been received).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个设备选择其ISN，它就会在设备的初始SYN消息的序列号字段中将ISN值发送给另一个设备。接收SYN的设备会以一个确认ACK消息响应，确认SYN（该消息可能还包含其自己的SYN，如三次握手的第二步）。在ACK消息中，确认号字段设置为从另一个设备接收到的ISN的值*加一*。这代表设备期望从其对等方接收的下一个序列号；ISN实际上代表已接收的最后字节的序列号（在这种情况下是虚构的，因为连接是新的，还没有收到任何东西）。
- en: Tip
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** As part of the process of connection establishment, each of
    the two devices in a TCP connection informs the other of the sequence number it
    plans to use for its first data transmission. Each device informs the other by
    putting the preceding sequence number in the Sequence Number field of its SYN
    message. The other device confirms this by incrementing that value and putting
    it into the Acknowledgment Number field of its ACK message, telling the other
    device that it is the sequence number it is expecting for the first data transmission.
    This process is called *sequence number synchronization*.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 作为连接建立过程的一部分，TCP连接中的两个设备中的每一个都会告知对方它计划用于其第一次数据传输的序列号。每个设备通过在其SYN消息的序列号字段中放置前一个序列号来告知对方。对方通过增加该值并将其放入其ACK消息的确认号字段中来确认这一点，告诉对方这是它期望用于第一次数据传输的序列号。这个过程被称为*序列号同步*。'
- en: Here's a simplified example of the three-way handshake steps (see [Figure 47-4](ch47s04.html#tcp_sequence_number_synchronization_this
    "Figure 47-4. TCP sequence number synchronization This diagram illustrates the
    same three-way handshake connection establishment procedure that I introduced
    in Figure 47-2, except this time I have shown the Sequence Number and Acknowledgment
    Number fields in each message, so that you can see how each of the two devices
    use them to establish initial sequence numbers for data exchange.")). I chose
    small ISNs for readability, but remember that ISNs can be any 32-bit number.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简化了的三次握手步骤的例子（见[图47-4](ch47s04.html#tcp_sequence_number_synchronization_this
    "图47-4. TCP序列号同步此图说明了我在图47-2中介绍的三次握手连接建立过程，但这次我展示了每个消息中的序列号和确认号字段，以便你可以看到两个设备如何使用它们来为数据交换建立初始序列号。")).
    我选择了小的ISN以提高可读性，但请记住，ISN可以是任何32位数字。
- en: '**Connection Request by Client** The client chooses an ISN for its transmissions
    of 4,567\. It sends a SYN with the Sequence Number field set to 4,567.'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端的连接请求** 客户端为其传输选择了一个ISN为4,567。它发送一个SYN，其序列号字段设置为4,567。'
- en: '**Acknowledgment and Connection Request by Server** The server chooses an ISN
    for its transmissions of 12,998\. It receives the client''s SYN. It sends a SYN+ACK
    with an Acknowledgment Number field value of 4,568 (one more than the client''s
    ISN). This message has a Sequence Number field value of 12,998.'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**服务器的确认和连接请求** 服务器为其传输选择了一个ISN为12,998。它接收到了客户端的SYN。它发送一个SYN+ACK，其确认号字段值为4,568（比客户端的ISN多一个）。此消息的序列号字段值为12,998。'
- en: '**Acknowledgment by Client** The client sends an ACK with the Acknowledgment
    Number field set to 12,999.'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**客户端的确认** 客户端发送一个ACK，其确认号字段设置为12,999。'
- en: With the connection now established, the client will send data whose first byte
    will be given sequence number 4,568\. The server's first byte of data will be
    numbered 12,999.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 连接现在建立后，客户端将发送数据，其第一个字节的序列号将为4,568。服务器的第一个数据字节的序列号将为12,999。
- en: '![TCP sequence number synchronization This diagram illustrates the same three-way
    handshake connection establishment procedure that I introduced in , except this
    time I have shown the Sequence Number and Acknowledgment Number fields in each
    message, so that you can see how each of the two devices use them to establish
    initial sequence numbers for data exchange.](httpatomoreillycomsourcenostarchimages288111.png.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_IMG
  zh: '![TCP序列号同步 此图说明了我在[图47-2](ch47s03.html#tcp_three-way_handshake_connection-id001
    "图47-2. TCP三次握手连接建立过程 此图说明了客户端和服务器如何建立传统连接。它显示了在过程中发送的三个消息以及每个设备如何从CLOSED状态通过中间状态过渡到ESTABLISHED状态。")中介绍的相同的三次握手连接建立过程，但这次我展示了每个消息中的序列号和确认号字段，以便你可以看到两个设备如何使用它们来为数据交换建立初始序列号。](httpatomoreillycomsourcenostarchimages288111.png.jpg)'
- en: Figure 47-4. TCP sequence number synchronization This diagram illustrates the
    same three-way handshake connection establishment procedure that I introduced
    in [Figure 47-2](ch47s03.html#tcp_three-way_handshake_connection-id001 "Figure 47-2. TCP
    three-way handshake connection establishment procedure This diagram illustrates
    how a client and server establish a conventional connection. It shows how the
    three messages sent during the process and how each device transitions from the
    CLOSED state through intermediate states until the session is in the ESTABLISHED
    state."), except this time I have shown the Sequence Number and Acknowledgment
    Number fields in each message, so that you can see how each of the two devices
    use them to establish initial sequence numbers for data exchange.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 图47-4. TCP序列号同步 此图说明了我在[图47-2](ch47s03.html#tcp_three-way_handshake_connection-id001
    "图47-2. TCP三次握手连接建立过程 此图说明了客户端和服务器如何建立传统连接。它显示了在过程中发送的三个消息以及每个设备如何从CLOSED状态通过中间状态过渡到ESTABLISHED状态。")中介绍的相同的三次握手连接建立过程，但这次我展示了每个消息中的序列号和确认号字段，以便你可以看到两个设备如何使用它们来为数据交换建立初始序列号。
- en: TCP Parameter Exchange
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP参数交换
- en: 'In addition to the initial sequence numbers, SYN messages also are designed
    to convey important parameters about how the connection should operate. TCP includes
    a flexible scheme for carrying these parameters, in the form of a variable-length
    *Options* field in the TCP segment format, which can be expanded to carry multiple
    parameters. In RFC 793, only a single parameter is defined to be exchanged during
    connection setup: *maximum segment size (MSS)*. I explain the significance of
    this parameter in the TCP data transfer discussion in [Chapter 48](ch48.html "Chapter 48. TCP
    MESSAGE FORMATTING AND DATA TRANSFER").'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 除了初始序列号之外，SYN消息还旨在传达有关连接应如何操作的重要参数。TCP包括一种灵活的方案来携带这些参数，以TCP段格式中的可变长度 *选项* 字段的形式，该字段可以扩展以携带多个参数。在RFC
    793中，仅定义了一个参数在连接设置期间进行交换：*最大分段大小（MSS）*。我在[第48章](ch48.html "第48章。TCP消息格式和数据传输")中讨论TCP数据传输时解释了此参数的重要性。
- en: Each device sends the other the MSS that it wants to use for the connection;
    that is, if the device wishes to use a nondefault value. When receiving the SYN,
    the server records the MSS value that the client sent, and it will never send
    a segment larger than that value to the client. The client does the same for the
    server. The client and server MSS values are independent, so they can establish
    a connection where the client can receive larger segments than the server or vice
    versa.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都会发送它想要用于连接的MSS；也就是说，如果设备希望使用非默认值。当收到SYN时，服务器记录客户端发送的MSS值，并且它永远不会向客户端发送大于该值的段。客户端也会对服务器做同样的事情。客户端和服务器MSS值是独立的，因此它们可以建立一种连接，其中客户端可以接收比服务器更大的段，反之亦然。
- en: 'Later RFCs have defined additional parameters that may be exchanged during
    connection setup. Some of these include the following:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的RFCs定义了在连接设置期间可能交换的附加参数。以下是一些包括的内容：
- en: '**Window Scale Factor** Allows a pair of devices to specify larger window sizes
    than would normally be possible given the 16-bit size of the TCP *Window* field.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口缩放因子** 允许一对设备指定比通常情况下由TCP *窗口*字段的16位大小所允许的更大的窗口大小。'
- en: '**Selective Acknowledgment Permitted** Allows a pair of devices to use the
    optional selective acknowledgment feature to allow only certain lost segments
    to be retransmitted.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许选择确认** 允许一对设备使用可选的选择确认功能，仅允许某些丢失的数据段被重传。'
- en: '**Alternate Checksum Method** Lets devices specify an alternative method of
    performing checksums than the standard TCP checksum mechanism.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '**交替校验和法** 允许设备指定一种不同于标准TCP校验和机制的校验和计算方法。'
- en: TCP Connection Management and Problem Handling
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接管理及问题处理
- en: Once both of the devices in a TCP connection have completed connection setup
    and have entered the ESTABLISHED state, the TCP software is in its normal operating
    mode. The TCP software will package bytes of data into segments for transmission
    using the mechanisms described in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE
    FORMATTING AND DATA TRANSFER"). TCP will use the sliding windows scheme to control
    segment size and to provide flow control, congestion handling, and retransmissions
    as needed.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦TCP连接中的两个设备完成连接设置并进入ESTABLISHED状态，TCP软件就处于其正常操作模式。TCP软件将使用[第48章](ch48.html
    "第48章。TCP消息格式和数据传输")中描述的机制将数据字节打包成段进行传输。TCP将使用滑动窗口方案来控制段大小，并提供流量控制、拥塞处理和必要的重传。
- en: 'Once in the sliding windows mode, both devices can remain there indefinitely.
    Some TCP connections can be very long-lived—in fact, some users maintain certain
    connections like Telnet sessions for hours or even days at a time. The following
    two circumstances can cause a connection to move out of the ESTABLISHED state:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入滑动窗口模式，两个设备可以无限期地保持在该模式。一些TCP连接可以非常持久——实际上，一些用户可能会连续数小时甚至数天保持某些连接，如Telnet会话。以下两种情况可能导致连接从ESTABLISHED状态移出：
- en: '**Connection Termination** Either of the devices decides to terminate the connection.
    This involves a specific procedure that I cover in the "TCP Connection Termination"
    section later in this chapter.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接终止** 任何一个设备都可以决定终止连接。这涉及到一个特定的程序，我将在本章后面的“TCP连接终止”部分进行介绍。'
- en: '**Connection Disruption** A problem of some sort occurs and interrupts the
    connection.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接中断** 发生某种问题并中断了连接。'
- en: The TCP Reset Function
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP重置功能
- en: In order for it to live up to its job of being a reliable and robust protocol,
    TCP includes intelligence that allows it to detect and respond to various problems
    that can occur during an established connection. One of the most common is the
    *half-open connection*. This situation occurs when, due to some sort of problem,
    one device closes or aborts the connection without the other one knowing about
    it. This means one device is in the ESTABLISHED state, while the other may be
    in the CLOSED state (no connection) or some other transient state. This could
    happen if, for example, one device had a software crash and someone restarted
    it in the middle of a connection, or if some sort of glitch caused the states
    of the two devices to become unsynchronized.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其能够胜任作为一个可靠和健壮协议的职责，TCP包括智能功能，使其能够检测和响应在建立连接期间可能发生的各种问题。其中最常见的是*半开连接*。这种情况发生在由于某种问题，一个设备关闭或终止连接，而另一个设备并不知道这一点。这意味着一个设备处于ESTABLISHED状态，而另一个可能处于CLOSED状态（无连接）或某种其他短暂状态。例如，如果一个设备发生软件崩溃，有人在连接中间重新启动它，或者某种类型的故障导致两个设备的状态变得不同步，就可能出现这种情况。
- en: 'To handle half-open connections and other problem situations, TCP includes
    a special *reset function*. A *reset* is a TCP segment that TCP sends with the
    *RST* flag set to 1 in its header. Generally speaking, the TCP software generates
    a reset whenever something unexpected happens. The following are some of the most
    common cases in which the TCP software generates a reset:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理半开连接和其他问题情况，TCP包括一个特殊的*重置功能*。*重置*是TCP发送的带有*RST*标志设置为1的TCP段。一般来说，TCP软件在发生意外情况时生成重置。以下是一些TCP软件生成重置的最常见情况：
- en: Receipt of any TCP segment from any device with which the device receiving the
    segment does not currently have a connection (other than a SYN requesting a new
    connection)
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到来自任何设备的TCP段，而接收该段的设备目前没有与该设备建立连接（除了请求新连接的SYN）
- en: Receipt of a message with an invalid or incorrect Sequence Number or Acknowledgment
    Number field, indicating that the message may belong to a prior connection or
    is spurious in some other way
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到一个包含无效或错误的序列号或确认号字段的报文，表明该报文可能属于先前的连接或以某种方式是虚假的
- en: Receipt of a SYN message on a port where there is no process listening for connections
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有进程监听连接的端口上接收到SYN消息
- en: Handling Reset Segments
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理重置段
- en: 'When a device receives a segment with the RST bit, it tells the other device
    to reset the connection so that the device can reestablish the connection. Like
    all segments, the reset itself must be checked to ensure that it is valid (by
    looking at the value of its Sequence Number field). This check prevents a spurious
    reset from shutting down a connection. Assuming the reset is valid, the handling
    of the message depends on the state of the device that receives it, as follows:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备收到带有 RST 位的段时，它会告诉另一个设备重置连接，以便设备可以重新建立连接。像所有段一样，重置本身必须进行检查以确保它是有效的（通过查看其序列号字段值）。这项检查防止了虚假的重置关闭连接。假设重置是有效的，消息的处理取决于接收该消息的设备状态，如下所示：
- en: If the device is in the LISTEN state, it ignores the reset and remains in that
    state.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备处于 LISTEN 状态，它会忽略重置并保持在该状态。
- en: If the device is in the SYN-RECEIVED state but was previously in the LISTEN
    state (which is the normal course of events for a server setting up a new connection),
    it returns to the LISTEN state.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备处于 SYN-RECEIVED 状态但之前处于 LISTEN 状态（这是服务器建立新连接的正常事件流程），它会返回到 LISTEN 状态。
- en: In any other situation, the reset causes the device to abort the connection
    and the device returns to the CLOSED state for that connection. The device will
    advise the higher-layer process that is using TCP that it has closed the connection.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何其他情况下，重置会导致设备终止连接，并返回到该连接的 CLOSED 状态。设备将通知使用 TCP 的高层进程它已关闭连接。
- en: Tip
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP includes a special *connection reset feature* that allows
    devices to deal with problem situations, such as *half-open connections* or the
    receipt of unexpected message types. To use the feature, the device detecting
    the problem sends a TCP segment with the RST (reset) flag set to 1\. The receiving
    device either returns to the LISTEN state, if it was in the process of connection
    establishment, or closes the connection and returns to the CLOSED state pending
    a new session negotiation.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP 包含一个特殊的 *连接重置功能*，允许设备处理问题情况，例如 *半开连接* 或接收到的意外消息类型。要使用此功能，检测到问题的设备会发送一个带有
    RST（重置）标志设置为 1 的 TCP 段。接收设备要么在连接建立过程中返回 LISTEN 状态，要么关闭连接并返回 CLOSED 状态，等待新的会话协商。'
- en: Idle Connection Management and Keepalive Messages
  id: totrans-687
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空闲连接管理及保活消息
- en: One final connection management issue in TCP is how to handle an idle connection;
    that is, a TCP session that is active but that has no data being transmitted by
    either device for a prolonged period of time. The TCP standard specifies that
    the appropriate action to take in this situation is nothing. The reason is that,
    strictly speaking, there is no need to do anything to maintain an idle connection
    in TCP. The protocol is perfectly happy to allow both devices to stop transmitting
    for a very long period of time. Then it simply allows both devices to resume transmissions
    of data and acknowledgment segments when each one has data to send.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 中最后一个连接管理问题是如何处理空闲连接；也就是说，一个活跃但长时间没有设备传输数据的 TCP 会话。TCP 标准规定在这种情况下应采取的适当行动是不采取任何行动。原因是，严格来说，在
    TCP 中没有必要做任何事情来维护空闲连接。该协议完全愿意允许两个设备长时间停止传输。然后它简单地允许每个设备在它们有数据要发送时恢复数据段和确认段的传输。
- en: However, in the same way that people become antsy when they are on a telephone
    call and don't hear anything for a long time, some TCP implementors were concerned
    that an idle TCP connection might mean that something had broken the connection.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像人们在电话通话中长时间听不到任何声音时会变得焦躁不安一样，一些 TCP 实现者担心空闲的 TCP 连接可能意味着连接出了问题。
- en: Thus, TCP software often includes an unofficial feature that allows a device
    with a TCP link to periodically send a null segment, which contains no data, to
    its peer on the connection. If the connection is still valid, the other device
    responds with a segment that contains an acknowledgment; if it is not, the other
    device will reply with a connection reset segment as I described earlier. These
    segments are sometimes called TCP *keepalive messages*, or just *keepalives*.
    They are analogous to Border Gateway Protocol (BGP) Keepalive messages (described
    in [Chapter 40](ch40.html "Chapter 40. BORDER GATEWAY PROTOCOL (BGP/BGP-4)")).
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，TCP软件通常包括一个非官方功能，允许具有TCP链接的设备定期向连接上的对等设备发送一个空段，该段不包含数据。如果连接仍然有效，另一台设备会以包含确认的段进行响应；如果它无效，另一台设备将像前面描述的那样以连接重置段进行回复。这些段有时被称为TCP
    *心跳消息*，或简称为*心跳*。它们类似于边界网关协议（BGP）的心跳消息（在[第40章](ch40.html "第40章。边界网关协议（BGP/BGP-4）")中描述）。
- en: The use of these messages is quite controversial, and therefore, not universal.
    Those who oppose using them argue that they are not really necessary, and that
    sending them represents a waste of internetwork bandwidth and a possible additional
    cost on metered links (those that charge for each datagram sent). Their key point
    is that if the connection is not presently being used, it doesn't matter if it
    is still valid or not; as soon as the connection is used again, if it has broken,
    in the meantime, TCP can handle that using the reset function mentioned earlier.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些消息的使用相当有争议，因此并不普遍。那些反对使用它们的人认为它们并不是真正必要的，发送它们代表了互联网带宽的浪费，以及在计费链路上的可能额外成本（那些按每个数据报计费的网络）。他们的关键点是，如果连接目前没有被使用，那么它是否仍然有效并不重要；一旦连接再次被使用，如果它在同时已经中断，TCP可以使用前面提到的重置功能来处理。
- en: Sending a keepalive message can, in theory, break a good TCP session unnecessarily.
    This may happen if the keepalive is sent during a time when there is an intermittent
    failure between the client and server. The failure might otherwise have corrected
    itself by the time the next piece of real data must be sent. In addition, some
    TCP implementations may not properly deal with the receipt of these segments.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，发送一个心跳消息可能会不必要地中断一个良好的TCP会话。这可能会发生在客户端和服务器之间存在间歇性故障的时候。否则，在发送下一块实际数据之前，故障可能会自行纠正。此外，一些TCP实现可能无法正确处理这些段落的接收。
- en: Those in favor of using keepalives point out that each TCP connection consumes
    a certain amount of resources, and this can be an issue, especially for busy servers.
    If many clients connect to such a server and don't terminate the TCP connection
    properly, the server may sit for a long time with an idle connection, using system
    memory and other resources that it could apply elsewhere.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 赞成使用心跳的人指出，每个TCP连接都会消耗一定量的资源，这可能会成为一个问题，尤其是对于繁忙的服务器。如果许多客户端连接到这样的服务器并且没有正确地终止TCP连接，服务器可能会长时间保持空闲连接，使用系统内存和其他它本可以用于其他地方的资源。
- en: Since there is no wide acceptance on the use of this feature, devices implementing
    it include a way to disable it if necessary. Devices are also programmed so that
    they will not terminate a connection simply because they did not receive a response
    to a single keepalive message. They may terminate the connection if they do not
    receive a reply after several such messages have been sent over a period of time.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对使用此功能没有广泛接受，实现此功能的设备包括一种在必要时禁用它的方法。设备也被编程，以便它们不会仅仅因为没有收到单个心跳消息的响应就终止连接。如果它们在一段时间内发送了多次此类消息后仍未收到回复，它们可能会终止连接。
- en: TCP Connection Termination
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接终止
- en: As the saying goes, all good things must come to an end, and so it is with TCP
    connections. The link between a pair of devices can remain open for a considerable
    period of time, assuming that a problem doesn't force the device to abort the
    connection. Eventually, however, one or both of the processes in the connection
    will run out of data to send and will shut down the TCP session, or the user will
    instruct the device to shut down.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗话所说，所有美好的事物都有结束的时候，TCP连接也不例外。在没有任何问题迫使设备终止连接的情况下，一对设备之间的连接可以保持开启状态一段时间。然而，最终，连接中的一方或双方将没有数据可以发送，并将关闭TCP会话，或者用户将指示设备关闭。
- en: Requirements and Issues In Connection Termination
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接终止的要求和问题
- en: Just as TCP follows an ordered sequence of operations in order to establish
    a connection, it also includes a specific procedure for terminating a connection.
    As with connection establishment, each of the devices moves from one state to
    the next in order to terminate the connection. This process is more complicated
    than you might imagine. In fact, an examination of the TCP FSM shows that there
    are more distinct states involved in shutting down a connection than in setting
    one up.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 正如TCP遵循一系列有序的操作来建立连接一样，它也包括一个特定的连接终止程序。与连接建立一样，每个设备都从一个状态移动到下一个状态以终止连接。这个过程比你想象的要复杂。实际上，对TCP状态机（FSM）的检查表明，在关闭连接中涉及的不同状态比在设置连接时更多。
- en: The reason that connection termination is complex is that during normal operation,
    both devices are sending and receiving data simultaneously. Usually, connection
    termination begins with one device indicating to TCP that it wants to close the
    connection. The matching process on the other device may not be aware that its
    peer wants to end the connection at all. Several steps are required to ensure
    that both devices shut down the connection gracefully and that no data is lost
    in the process.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 连接终止之所以复杂，是因为在正常操作期间，两个设备同时发送和接收数据。通常，连接终止从一个设备向TCP指示它想要关闭连接开始。另一设备上的匹配过程可能根本不知道其对等方想要结束连接。需要几个步骤来确保两个设备都能优雅地关闭连接，并且在过程中不会丢失任何数据。
- en: Ultimately, shutting down a TCP connection requires the application processes
    on both ends of the connection to recognize that "the end is nigh" for the connection
    and that they should stop sending data. For this reason, connection termination
    is implemented so that each device terminates its end of the connection separately.
    The act of closing the connection by one device means that device will no longer
    send data, but can continue to receive it until the other device has decided to
    stop sending. This allows all data that is pending to be sent by both sides of
    the communication to be flushed before the connection is ended.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，关闭TCP连接需要连接两端的进程都认识到“连接的终结即将到来”，并且它们应该停止发送数据。因此，连接终止的实现是让每个设备分别终止其连接的末端。一个设备关闭连接的行为意味着该设备将不再发送数据，但可以继续接收数据，直到另一设备决定停止发送。这允许在连接结束之前，双方通信中所有待发送的数据都被刷新。
- en: Normal Connection Termination
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正常连接终止
- en: In the normal case, each side terminates its end of the connection by sending
    a special message with the FIN (finish) bit set. The FIN message serves as a connection
    termination request to the other device, while also possibly carrying data like
    a regular segment. The device receiving the FIN responds with an acknowledgment
    to the FIN that indicates that it received the acknowledgment. Neither side considers
    the connection terminated until they both have sent a FIN and received an ACK,
    thereby finishing the shutdown procedure.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，每一端通过发送一个设置了FIN（完成）位的特殊消息来终止其连接的末端。FIN消息作为连接终止请求发送给另一设备，同时可能携带像常规段一样的数据。接收FIN消息的设备会以一个确认响应，表明它已收到确认。直到双方都发送了FIN并收到了ACK，双方才认为连接已终止，从而完成关闭过程。
- en: Thus, termination isn't a three-way handshake as with establishment. It is a
    pair of two-way handshakes. The states that the two devices in the connection
    move through during a normal connection shutdown are different because the device
    initiating the shutdown must behave differently than the one that receives the
    termination request. In particular, the TCP on the device receiving the initial
    termination request must inform its application process and wait for a signal
    that the process is ready to proceed. The initiating device doesn't need to do
    this, since the application started the ball rolling in the first place.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，终止过程不是像建立连接那样的三次握手。它是一对双向握手。在正常连接关闭过程中，连接中的两个设备所经历的状态不同，因为启动关闭的设备必须与接收终止请求的设备有不同的行为。特别是，接收初始终止请求的设备上的TCP必须通知其应用进程，并等待一个信号，表明进程已准备好继续进行。启动设备不需要这样做，因为应用进程首先开始了这个过程。
- en: Tip
  id: totrans-704
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A TCP connection is terminating using a special procedure by
    which each side independently closes its end of the link. The connection normally
    begins with one of the application processes signaling to its TCP layer that the
    session is no longer needed. That device sends a FIN message to tell the other
    device that it wants to end the connection, which the other device acknowledges.
    When the responding device is ready, it too sends a FIN that the other device
    acknowledges; after waiting a period of time for the device to receive the ACK,
    the device closes the session.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP连接通过一种特殊的过程终止，该过程允许每一方独立关闭其连接的端点。连接通常从应用程序进程向其TCP层发出信号开始，表示会话不再需要。该设备发送一个FIN消息告诉另一设备它想要结束连接，另一设备会进行确认。当响应设备准备好时，它也会发送一个FIN，另一设备会进行确认；在等待一段时间以接收设备的ACK后，设备关闭会话。'
- en: '[Table 47-4](ch47s06.html#tcp_connection_termination_procedure "Table 47-4. TCP
    Connection Termination Procedure") describes in detail how the connection termination
    process works. You can also see the progression of states and messages exchanged
    in [Figure 47-5](ch47s06.html#tcp_connection_termination_procedure_thi "Figure 47-5. TCP
    connection termination procedure This diagram shows the conventional termination
    procedure for a TCP session, with one device initiating termination and the other
    responding. In this case, the client initiates; it sends a FIN, which the server
    acknowledges. The server waits for the server process to be ready to close and
    then sends its FIN, which the client acknowledges. The client waits for a period
    of time in order to ensure that the device receives its ACK, before proceeding
    to the CLOSED state."). The table is adapted from [Table 47-1](ch47.html#tcp_finite_state_machine_fsm_states_even
    "Table 47-1. TCP Finite State Machine (FSM) States, Events, and Transitions"),
    which describes the TCP FSM, but shows what happens for both the server and the
    client over time during connection shutdown. Either device can initiate connection
    termination; in this example, I am assuming the client does it. Each row shows
    the state each device begins in, what action it takes in that state, and what
    state it transitions to. I have also shown the send and receive stages of both
    of the steps for each of the client and server''s close operations.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[表47-4](ch47s06.html#tcp_connection_termination_procedure "表47-4. TCP连接终止过程")详细描述了连接终止过程是如何工作的。您还可以在[图47-5](ch47s06.html#tcp_connection_termination_procedure_thi
    "图47-5. TCP连接终止过程 此图显示了TCP会话的传统终止过程，其中一个设备启动终止，另一个响应。在这种情况下，客户端启动；它发送一个FIN，服务器进行确认。服务器等待服务器进程准备好关闭，然后发送其FIN，客户端进行确认。客户端等待一段时间以确保设备收到其ACK，然后进入CLOSED状态。")中看到状态和交换的消息的进展。表格是从[表47-1](ch47.html#tcp_finite_state_machine_fsm_states_even
    "表47-1. TCP有限状态机(FSM)状态、事件和转换")改编的，它描述了TCP FSM，但显示了在连接关闭期间服务器和客户端随时间发生的情况。任何设备都可以启动连接终止；在这个例子中，我假设客户端这样做。每一行显示了每个设备开始的状态，它在该状态下采取的动作，以及它转变到的状态。我还展示了客户端和服务器关闭操作的每一步的发送和接收阶段。'
- en: Table 47-4. TCP Connection Termination Procedure
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 表47-4. TCP连接终止过程
- en: '| Client | Server |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 服务器 |'
- en: '| --- | --- |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Start State | Action | Transitions to State | Start State | Action | Transitions
    to State |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| 起始状态 | 动作 | 转变到状态 | 起始状态 | 动作 | 转变到状态 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| ESTABLISHED | Client Close Step 1 Transmit: The application using TCP signals
    that the connection is no longer needed. The client TCP sends a segment with the
    FIN bit set to request that the connection be closed. | FIN-WAIT-1 | ESTABLISHED
    | At this stage the server is still in normal operating mode. | — |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| ESTABLISHED | 客户端关闭步骤1：传输：使用TCP的应用程序表示连接不再需要。客户端TCP发送一个设置了FIN位的段，请求关闭连接。
    | FIN-WAIT-1 | ESTABLISHED | 在这个阶段，服务器仍然处于正常操作模式。 | — |'
- en: '| FIN-WAIT-1 | The client, having sent a FIN, is waiting for a device to acknowledge
    it and for the server to send its own FIN. In this state, the client can still
    receive data from the server but will no longer accept data from its local application
    to be sent to the server. | — | ESTABLISHED | Client Close Step 1 Receive and
    Step 2 Transmit: The server receives the client''s FIN. It sends an ACK to acknowledge
    the FIN. The server must wait for the application using it to be told that the
    other end is closing, so the application here can finish what it is doing. | CLOSE-WAIT
    |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-1 | 客户端发送了FIN后，正在等待设备确认，并等待服务器发送其自己的FIN。在此状态下，客户端仍然可以接收来自服务器的数据，但将不再接受来自其本地应用程序的数据发送到服务器。
    | — | ESTABLISHED | 客户端关闭步骤1接收和步骤2发送：服务器接收客户端的FIN。它发送一个ACK来确认FIN。服务器必须等待使用它的应用程序被告知另一端正在关闭，因此这里的应用程序可以完成它正在做的事情。
    | CLOSE-WAIT |'
- en: '| FIN-WAIT-1 | Client Close Step 2 Receive: The client receives the ACK for
    its FIN. It must now wait for the server to close. | FIN-WAIT-2 | CLOSE-WAIT |
    The server waits for the application process on its end to signal that it is ready
    to close. | — |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-1 | 客户端关闭步骤2接收：客户端接收其FIN的ACK。它现在必须等待服务器关闭。 | FIN-WAIT-2 | CLOSE-WAIT
    | 服务器等待其端的应用程序进程发出准备关闭的信号。 | — |'
- en: '| FIN-WAIT-2 | The client is waiting for the server''s FIN. | — | CLOSE-WAIT
    | Server Close Step 1 Transmit: The server''s TCP receives a notice from the local
    application that it is done. The server sends its FIN to the client. | LAST-ACK
    |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-2 | 客户端正在等待服务器的FIN。 | — | CLOSE-WAIT | 服务器关闭步骤1发送：服务器的TCP从本地应用程序收到通知，表示它已完成。服务器向客户端发送其FIN。
    | LAST-ACK |'
- en: '| FIN-WAIT-2 | Server Close Step 1 Receive and Step 2 Transmit: The client
    receives the server''s FIN and sends back an ACK. | TIME-WAIT | LAST-ACK | The
    server is waiting for an ACK for the FIN that it sent. | — |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-2 | 服务器关闭步骤1接收和步骤2发送：客户端接收服务器的FIN并发送回ACK。 | TIME-WAIT | LAST-ACK
    | 服务器正在等待它发送的FIN的ACK。 | — |'
- en: '| TIME-WAIT | The client waits for a period of time equal to double the maximum
    segment life (MSL) time; this wait ensures that the ACK it sent was received.
    | — | LAST-ACK | Server Close Step 2 Receive: The server receives the ACK to its
    FIN and closes the connection. | CLOSED |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| TIME-WAIT | 客户端等待一个等于最大段生存时间（MSL）双倍的时间段；这个等待确保它发送的ACK已被接收。 | — | LAST-ACK
    | 服务器关闭步骤2接收：服务器接收其FIN的ACK并关闭连接。 | CLOSED |'
- en: '| TIME-WAIT | The timer expires after double the MSL time. | CLOSED | CLOSED
    | The connection is closed on the server''s end. |   |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| TIME-WAIT | 定时器在双倍的最大段生存时间（MSL）时间后到期。 | CLOSED | CLOSED | 服务器端关闭连接。 |   |'
- en: '| CLOSED | The connection is closed. |   | CLOSED | The connection is closed.
    |   |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| CLOSED | 连接已关闭。 |   | CLOSED | 连接已关闭。 |   |'
- en: '![TCP connection termination procedure This diagram shows the conventional
    termination procedure for a TCP session, with one device initiating termination
    and the other responding. In this case, the client initiates; it sends a FIN,
    which the server acknowledges. The server waits for the server process to be ready
    to close and then sends its FIN, which the client acknowledges. The client waits
    for a period of time in order to ensure that the device receives its ACK, before
    proceeding to the CLOSED state.](httpatomoreillycomsourcenostarchimages288113.png.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![TCP连接终止过程 此图展示了TCP会话的传统终止过程，其中一个设备发起终止，另一个设备响应。在这种情况下，客户端发起；它发送一个FIN，服务器进行确认。服务器等待服务器进程准备好关闭，然后发送其FIN，客户端进行确认。客户端等待一段时间以确保设备收到其ACK，然后进入CLOSED状态。](httpatomoreillycomsourcenostarchimages288113.png.jpg)'
- en: Figure 47-5. TCP connection termination procedure This diagram shows the conventional
    termination procedure for a TCP session, with one device initiating termination
    and the other responding. In this case, the client initiates; it sends a FIN,
    which the server acknowledges. The server waits for the server process to be ready
    to close and then sends its FIN, which the client acknowledges. The client waits
    for a period of time in order to ensure that the device receives its ACK, before
    proceeding to the CLOSED state.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 图47-5. TCP连接终止过程 此图展示了TCP会话的传统终止过程，其中一个设备发起终止，另一个设备响应。在这种情况下，客户端发起；它发送一个FIN，服务器进行确认。服务器等待服务器进程准备好关闭，然后发送其FIN，客户端进行确认。客户端等待一段时间以确保设备收到其ACK，然后进入CLOSED状态。
- en: The device receiving the initial FIN may have to wait a fairly long time (in
    networking terms) in the CLOSE-WAIT state for the application it is serving to
    indicate that it is ready to shut down. TCP cannot make any assumptions about
    how long this will take. During this period of time, the server in the previous
    example may continue sending data, and the client will receive it. However, the
    client will not send data to the server.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 接收初始FIN的设备可能需要在CLOSE-WAIT状态中等待相当长的时间（从网络术语来说），以便为其所服务的应用程序指示它已准备好关闭。TCP无法对这需要多长时间做出任何假设。在这段时间内，前一个示例中的服务器可能会继续发送数据，客户端将接收这些数据。然而，客户端不会向服务器发送数据。
- en: Eventually, the second device (the server in the example) will send a FIN to
    close its end of the connection. The device that originally initiated the close
    (the client) will send an ACK for this FIN. However, the client cannot immediately
    go to the CLOSED state right after sending that ACK because it must allow time
    for the ACK to travel to the server. Normally, this will be quick, but delays
    might slow it down somewhat.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，第二个设备（例如示例中的服务器）将发送一个FIN来关闭其连接的一端。最初发起关闭的设备（客户端）将为这个FIN发送一个ACK。然而，客户端在发送ACK后不能立即进入CLOSED状态，因为它必须允许ACK到达服务器的时间。通常情况下，这会很快，但延迟可能会稍微减慢这个过程。
- en: The TIME-WAIT State
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TIME-WAIT状态
- en: 'The TIME-WAIT state is required for two main reasons:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: TIME-WAIT状态需要两个主要原因：
- en: To provide enough time to ensure that the other device receives the ACK, and
    to retransmit it if it is lost
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保另一设备收到ACK，并在它丢失时重新传输
- en: To provide a buffering period between the end of this connection and any subsequent
    ones. If not for this period, it is possible that packets from different connections
    could be mixed, thereby creating confusion.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在这条连接的结束和任何后续连接之间提供一个缓冲期。如果没有这个时间段，不同连接的包可能会混合，从而造成混乱。
- en: The standard specifies that the client should wait double a particular length
    of time, called the *maximum segment lifetime (MSL)*, before closing the connection.
    The TCP standard defines MSL as being a value of 120 seconds (2 minutes). In modern
    networks, this is an eternity, so TCP allows implementations to choose a lower
    value if it believes that will lead to better operation.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 该标准规定，客户端应在关闭连接之前等待两倍于特定时间长度的时段，这个时长被称为*最大分段生存时间（MSL）*。TCP标准将MSL定义为120秒（2分钟）。在现代网络中，这几乎是一个永恒的时间，因此TCP允许实现选择一个更低的值，如果它认为这将导致更好的操作。
- en: Simultaneous Connection Termination
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时连接终止
- en: Just as it is possible to change the normal connection establishment process
    if two devices decide to actively open a connection to each other, it is also
    possible for two devices to try to terminate a connection simultaneously. This
    term *simultaneously* does not mean that they both decide to shut down at exactly
    the same time—variances in network delays mean nothing can be simultaneous on
    an internetwork anyway. It simply means that, in the previous example, the client
    decides to shut down and sends a FIN, but the server sends its own FIN before
    the client's FIN shows up at the server. In that case, a different procedure is
    followed, as described in [Table 47-5](ch47s06.html#tcp_simultaneous_connection_termin-id001
    "Table 47-5. TCP Simultaneous Connection Termination Procedure") and illustrated
    in [Figure 47-6](ch47s06.html#tcp_simultaneous_connection_termination_ "Figure 47-6. TCP
    simultaneous connection termination procedure Under certain circumstances, both
    devices may decide to terminate a connection simultaneously, or nearly simultaneously.
    In this case, each sends a FIN and, before getting an ACK for it, receives the
    other device's FIN. Each acknowledges the other's FIN and waits for a period of
    time before closing the connection. Note the transition through the CLOSING state,
    which is used only as part of simultaneous termination.").
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 正如如果两个设备决定相互主动打开连接，可以改变正常的连接建立过程一样，两个设备也可以尝试同时终止一个连接。这个术语“同时”并不意味着它们会同时决定关闭——网络延迟的差异意味着在任何互联网环境中都不可能真正同时发生。这仅仅意味着，在前面的例子中，客户端决定关闭并发送一个FIN，但服务器在客户端的FIN出现在服务器之前就发送了自己的FIN。在这种情况下，会遵循不同的程序，如[表47-5](ch47s06.html#tcp_simultaneous_connection_termin-id001
    "表47-5. TCP同时连接终止过程")中所述，并在[图47-6](ch47s06.html#tcp_simultaneous_connection_termination_
    "图47-6. 在某些情况下，两个设备可能会同时决定终止一个连接，或者几乎是同时。在这种情况下，每个设备都会发送一个FIN，在收到对该FIN的ACK之前，会接收到另一个设备的FIN。每个设备都会确认对方的FIN，并在关闭连接之前等待一段时间。注意通过CLOSING状态的转换，该状态仅作为同时终止的一部分使用。")中所示。
- en: '![TCP simultaneous connection termination procedure Under certain circumstances,
    both devices may decide to terminate a connection simultaneously, or nearly simultaneously.
    In this case, each sends a FIN and, before getting an ACK for it, receives the
    other device''s FIN. Each acknowledges the other''s FIN and waits for a period
    of time before closing the connection. Note the transition through the CLOSING
    state, which is used only as part of simultaneous termination.](httpatomoreillycomsourcenostarchimages288115.png.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![在某些情况下，两个设备可能会同时决定终止一个连接，或者几乎是同时。在这种情况下，每个设备都会发送一个FIN，在收到对该FIN的ACK之前，会接收到另一个设备的FIN。每个设备都会确认对方的FIN，并在关闭连接之前等待一段时间。注意通过CLOSING状态的转换，该状态仅作为同时终止的一部分使用。](httpatomoreillycomsourcenostarchimages288115.png.jpg)'
- en: Figure 47-6. TCP simultaneous connection termination procedure Under certain
    circumstances, both devices may decide to terminate a connection simultaneously,
    or nearly simultaneously. In this case, each sends a FIN and, before getting an
    ACK for it, receives the other device's FIN. Each acknowledges the other's FIN
    and waits for a period of time before closing the connection. Note the transition
    through the CLOSING state, which is used only as part of simultaneous termination.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 图47-6. TCP同时连接终止过程在某些情况下，两个设备可能会同时决定终止一个连接，或者几乎是同时。在这种情况下，每个设备都会发送一个FIN，在收到对该FIN的ACK之前，会接收到另一个设备的FIN。每个设备都会确认对方的FIN，并在关闭连接之前等待一段时间。注意通过CLOSING状态的转换，该状态仅作为同时终止的一部分使用。
- en: Table 47-5. TCP Simultaneous Connection Termination Procedure
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 表47-5. TCP同时连接终止过程
- en: '| Client | Server |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 服务器 |'
- en: '| --- | --- |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Start State | Action | Transitions to State | Start State | Action | Transitions
    to State |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| 起始状态 | 动作 | 转换到状态 | 起始状态 | 动作 | 转换到状态 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| ESTABLISHED | Client Close Step 1 Transmit: The application using TCP signals
    that the connection is no longer needed. The TCP on the client sends the next
    segment with the FIN bit set, indicating a request to close the connection. |
    FIN-WAIT-1 | ESTABLISHED | Server Close Step 1 Transmit: Before the server can
    receive the FIN that the client sent, the application on the server also signals
    a close. The server also sends a FIN. | FIN-WAIT-1 |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| 建立连接 | 客户端关闭步骤 1 传输：使用 TCP 的应用程序表示连接不再需要。客户端的 TCP 发送下一个段，并将 FIN 位设置为 1，表示请求关闭连接。
    | FIN-WAIT-1 | 建立连接 | 服务器关闭步骤 1 传输：在服务器能够接收客户端发送的 FIN 之前，服务器上的应用程序也发出关闭信号。服务器也发送一个
    FIN。 | FIN-WAIT-1 |'
- en: '| FIN-WAIT-1 | Server Close Step 1 Receive and Step 2 Transmit: The client
    has sent a FIN and is waiting for it to be acknowledged. Instead, it receives
    the FIN that the server sends. It acknowledges the server''s close request with
    an ACK and continues to wait for its own ACK. | CLOSING | FIN-WAIT-1 | Client
    Close Step 1 Receive and Step 2 Transmit: The server has sent a FIN and is waiting
    for it to be acknowledged. Instead, it receives the FIN that the client sends.
    It acknowledges the client''s close request with an ACK and continues to wait
    for its own ACK. | CLOSING |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| FIN-WAIT-1 | 服务器关闭步骤 1 接收和步骤 2 传输：客户端已发送一个 FIN 并正在等待其被确认。相反，它接收到了服务器发送的 FIN。它用
    ACK 确认服务器的关闭请求，并继续等待自己的 ACK。 | 关闭中 | FIN-WAIT-1 | 客户端关闭步骤 1 接收和步骤 2 传输：服务器已发送一个
    FIN 并正在等待其被确认。相反，它接收到了客户端发送的 FIN。它用 ACK 确认客户端的关闭请求，并继续等待自己的 ACK。 | 关闭中 |'
- en: '| CLOSING | Client Close Step 2 Receive: The client receives the ACK for its
    FIN. | TIME-WAIT | CLOSING | Server Close Step 2 Receive: The server receives
    the ACK for its FIN. | TIME-WAIT |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| 关闭中 | 客户端关闭步骤 2 接收：客户端接收其 FIN 的 ACK。 | TIME-WAIT | 关闭中 | 服务器关闭步骤 2 接收：服务器接收其
    FIN 的 ACK。 | TIME-WAIT |'
- en: '| TIME-WAIT | The client waits for a period of time equal to double the MSL
    time. This gives enough time to ensure that the ACK it sent to the server was
    received. | — | TIME-WAIT | The server waits for a period of time equal to double
    the MSL time. This gives enough time to ensure the ACK it sent to the client was
    received. | — |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| TIME-WAIT | 客户端等待的时间是两倍的 MSL 时间。这为确保它发送给服务器的 ACK 被接收提供了足够的时间。 | — | TIME-WAIT
    | 服务器等待的时间是两倍的 MSL 时间。这为确保它发送给客户端的 ACK 被接收提供了足够的时间。 | — |'
- en: '| TIME-WAIT | The timer expires after double the MSL time. | CLOSED | TIME-WAIT
    | The timer expires after double the MSL time. | CLOSED |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| TIME-WAIT | 定时器在两倍的 MSL 时间后到期。 | 关闭 | TIME-WAIT | 定时器在两倍的 MSL 时间后到期。 | 关闭
    |'
- en: '| CLOSED | The connection is closed. | — | CLOSED | The connection is closed.
    | — |'
  id: totrans-743
  prefs: []
  type: TYPE_TB
  zh: '| 关闭 | 连接已关闭。 | — | 关闭 | 连接已关闭。 | — |'
- en: As you can see, the process is much more symmetric in this case, with both devices
    transitioning through the same states. In either case the end result is the same,
    with the connection in the CLOSED state—meaning no connection. Each TCP will make
    sure all outstanding data is sent to the application, sometimes referred to as
    an implied *push* (see the description of the push function in [Chapter 48](ch48.html
    "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER") for an explanation of
    this term). The TCBs established for the connection in both devices are destroyed
    when the connection is closed down.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，过程具有更高的对称性，两个设备都通过相同的状态进行转换。在任何情况下，最终结果都是相同的，即连接处于关闭状态——意味着没有连接。每个
    TCP 都会确保所有未发送的数据被发送到应用程序，有时这被称为隐含的 *推送*（有关此术语的解释，请参阅[第 48 章](ch48.html "第 48 章。TCP
    消息格式和数据传输")中的推送功能描述）。当连接关闭时，两个设备上建立的 TCB 被销毁。
- en: Tip
  id: totrans-745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Just as two devices can simultaneously open a TCP session,
    they can terminate it simultaneously as well. In this case, a different state
    sequence is followed, with each device responding to the other''s FIN with an
    ACK, then waiting for receipt of its own ACK, and pausing for a period of time
    to ensure that the other device received its ACK before ending the connection.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 正如两个设备可以同时打开一个 TCP 会话一样，它们也可以同时终止它。在这种情况下，遵循不同的状态序列，每个设备对其接收到的对方的
    FIN 响应以 ACK，然后等待接收自己的 ACK，并暂停一段时间以确保对方在结束连接之前收到了它的 ACK。'
- en: Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER
  id: totrans-747
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 48 章。TCP 消息格式和数据传输
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-748
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'The previous chapter described how two devices using the Transmission Control
    Protocol (TCP) establish a TCP connection, as well as how that connection is managed
    and eventually terminated. While connections are a key part of how TCP works,
    they are really just a means to the ultimate end of the protocol: sending data.
    By employing the TCP sliding window mechanism, a special segment format, and several
    features, TCP devices are able to package and send data over the connection, enabling
    applications to communicate.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章描述了使用传输控制协议（TCP）的两个设备如何建立TCP连接，以及如何管理和最终终止该连接。虽然连接是TCP工作方式的关键部分，但它们实际上只是协议最终目标的手段：发送数据。通过使用TCP滑动窗口机制、特殊的段格式和几个功能，TCP设备能够打包并发送数据，从而使得应用程序能够进行通信。
- en: 'This chapter describes the actual mechanism by which TCP messages are formatted
    and data is transferred between devices. I begin with a look at the important
    *TCP segment format*, which describes the fields in each TCP message and how they
    are used. Next, I provide a description of the method used to calculate the checksum
    in TCP (as well as UDP) messages, and explain the reason why a special pseudo
    header is used. Then I discuss the maximum segment size (MSS) parameter and its
    significance. Following that, I talk about exactly how the sliding window mechanism
    is used to transfer and acknowledge data. I conclude with a description of two
    special data transfer features: the push feature, for immediate data transfer,
    and the urgent feature for priority data transfer.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了TCP消息格式化的实际机制以及设备之间数据传输的过程。我首先查看重要的*TCP段格式*，它描述了每个TCP消息中的字段以及它们的使用方式。接下来，我提供了计算TCP（以及UDP）消息校验和的方法的描述，并解释了为什么使用特殊的伪头部。然后，我讨论了最大段大小（MSS）参数及其重要性。随后，我详细说明了滑动窗口机制是如何用于传输和确认数据的。最后，我描述了两种特殊的数据传输特性：用于立即数据传输的推送功能，以及用于优先数据传输的紧急功能。
- en: '**BACKGROUND INFORMATION** This chapter assumes that you are already familiar
    with TCP concepts such as sequence numbers, segments, and the basics of the TCP
    sliding window mechanism. If you are not, read [Chapter 46](ch46.html "Chapter 46. TRANSMISSION
    CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION") before proceeding
    with this one.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息**本章假设你已经熟悉TCP概念，如序列号、段和TCP滑动窗口机制的基本原理。如果你不熟悉，请在继续阅读本章之前先阅读[第46章](ch46.html
    "第46章。传输控制协议（TCP）基础和一般操作")。'
- en: TCP Message (Segment) Format
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP消息（段）格式
- en: 'In the TCP overview in [Chapter 45](ch45.html "Chapter 45. TCP OVERVIEW, FUNCTIONS,
    AND CHARACTERISTICS"), I described one of the most interesting jobs that TCP performs:
    It allows an application to send data as an unstructured sequence of bytes, transparently
    packaging that data in distinct messages as required by the underlying protocol
    that TCP uses (normally IP, of course). TCP messages are called *segments*, the
    name referring to the fact that each is a portion of the overall data stream passing
    between the devices.'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第45章](ch45.html "第45章。TCP概述、功能和特性")的TCP概述中，我描述了TCP执行的最有趣的任务之一：它允许应用程序以无结构的字节序列发送数据，透明地将这些数据打包成由TCP使用的底层协议（通常是IP）所需的不同消息。TCP消息被称为*段*，这个名字指的是每个段都是设备之间整体数据流的一部分。
- en: TCP segments are very much jack-of-all-trade messages—they are flexible and
    serve a variety of purposes. A single field format is used for all segments, with
    a number of header fields that implement the many functions and features for which
    TCP is responsible. One of the most notable characteristics of TCP segments is
    that they are designed to carry both control information and data simultaneously.
    This reduces the number of segments sent, since a segment can perform more than
    one function.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: TCP段非常类似于“万能的”信息——它们灵活且服务于多种目的。所有段都使用单一的字段格式，其中包含多个头部字段，以实现TCP所负责的众多功能和特性。TCP段最显著的特点之一是它们被设计为可以同时携带控制信息和数据。这减少了发送的段的数量，因为一个段可以执行多个功能。
- en: For example, there is no need to send separate acknowledgments in TCP, because
    each TCP message includes a field for an acknowledgment byte number. Similarly,
    one can request that a connection be closed while sending data in the same message.
    The nature of each TCP segment is indicated through the use of several special
    control bits. More than one bit can be sent to allow a segment to perform multiple
    functions, such as when a bit is used to specify an initial sequence number (ISN)
    and acknowledge receipt of another such segment at the same time.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在TCP中不需要发送单独的确认，因为每个TCP消息都包含一个确认字节号的字段。同样，可以在发送数据的同时请求关闭连接。每个TCP段的特点通过使用几个特殊控制位来指示。可以发送多个位以允许一个段执行多个功能，例如，当一位用于指定初始序列号（ISN）并确认接收了另一个这样的段时。
- en: 'The price we pay for this flexibility is that the TCP header is large: 20 bytes
    for regular segments and more for those carrying options. This is one of the reasons
    why some protocols prefer to use the User Datagram Protocol (UDP) if they don''t
    need TCP''s features. The TCP header fields are used for the following general
    purposes:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这种灵活性，我们付出的代价是TCP头很大：常规段为20字节，携带选项的段则更多。这也是为什么一些协议在不需要TCP功能时更倾向于使用用户数据报协议（UDP）的原因之一。TCP头字段用于以下一般目的：
- en: '**Process Addressing** The processes on the source and destination devices
    are identified using port numbers.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程寻址** 源设备和目标设备上的进程使用端口号进行标识。'
- en: '**Implementing the Sliding Window System** Sequence Number, Acknowledgment
    Number, and Window Size fields implement the TCP sliding window system (discussed
    in the "TCP Sliding Window Data Transfer and Acknowledgment Mechanics" section
    later in this chapter).'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现滑动窗口系统** 序列号、确认号和窗口大小字段实现了TCP滑动窗口系统（在本章后面的“TCP滑动窗口数据传输和确认机制”部分中讨论）。'
- en: '**Setting Control Bits and Fields** These are special bits that implement various
    control functions and fields that carry pointers and other data needed for them.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置控制位和字段** 这些是执行各种控制功能以及携带指针和其他所需数据的特殊位。'
- en: '**Carrying Data** The Data field carries the actual bytes of data being sent
    between devices.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '**携带数据** 数据字段携带设备之间发送的实际数据字节。'
- en: '**Performing Miscellaneous Functions** These include a checksum for data protection
    and options for connection setup.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行其他功能** 这包括数据保护用的校验和以及用于连接设置的选项。'
- en: The format for TCP messages (segments) is described fully in Tables [Table 48-1](ch48.html#tcp_segment_format
    "Table 48-1. TCP Segment Format") through [Table 48-3](ch48.html#tcp_segment_option_subfields
    "Table 48-3. TCP Segment Option Subfields") and illustrated in [Figure 48-1](ch48.html#tcp_segment_format-id001
    "Figure 48-1. TCP segment format").
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: TCP消息（段）的格式在表 [表 48-1](ch48.html#tcp_segment_format "表 48-1. TCP段格式") 到 [表 48-3](ch48.html#tcp_segment_option_subfields
    "表 48-3. TCP段选项子字段") 中进行了详细描述，并在 [图 48-1](ch48.html#tcp_segment_format-id001 "图 48-1. TCP段格式")
    中进行了说明。
- en: Table 48-1. TCP Segment Format
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 表 48-1. TCP段格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Source Port | 2 | This is the 16-bit port number of the process that originated
    the TCP segment on the source device. This will normally be an ephemeral (client)
    port number for a request sent by a client to a server, or a well-known/registered
    (server) port number for a reply from a server to a client. |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| 源端口 | 2 | 这是源设备上发起TCP段的进程的16位端口号。这通常是一个客户端的临时（客户端）端口号，用于客户端向服务器发送请求，或者是一个已知/已注册（服务器）端口号，用于服务器向客户端发送回复。|'
- en: '| Destination Port | 2 | This is the 16-bit port number of the process that
    is the ultimate intended recipient of the message on the destination device. This
    will usually be a well-known/registered (server) port number for a client request,
    or an ephemeral (client) port number for a server reply. |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| 目标端口 | 2 | 这是目标设备上消息最终预期接收者的16位端口号。这通常是一个客户端请求的已知/已注册（服务器）端口号，或者是一个服务器回复的临时（客户端）端口号。|'
- en: '| Sequence Number | 4 | For normal transmissions, this is the sequence number
    of the first byte of data in this segment. In a connection request (SYN) message,
    this carries the ISN of the source TCP. The first byte of data will be given the
    next sequence number after the contents of this field, as described in [Chapter 47](ch47.html
    "Chapter 47. TCP BASIC OPERATION: CONNECTION ESTABLISHMENT, MANAGEMENT, AND TERMINATION").
    |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 4 | 对于正常传输，这是此段中数据第一个字节的序列号。在连接请求（SYN）消息中，此字段携带源TCP的ISN。数据的第一字节将赋予此字段内容之后的下一个序列号，如[第47章](ch47.html
    "第47章. TCP基本操作：连接建立、管理和终止")中所述。'
- en: '| Acknowledgment Number | 4 | When the ACK bit is set, this segment is serving
    as an acknowledgment (in addition to other possible duties), and this field contains
    the sequence number the source is next expecting the destination to send. See
    the "TCP Sliding Window Data Transfer and Acknowledgment Mechanics" section later
    in this chapter for details. |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| 确认号 | 4 | 当ACK位被设置时，此段作为确认（除其他可能的职责外），并且此字段包含源端期望目的地发送的下一个序列号。有关详细信息，请参阅本章后面的“TCP滑动窗口数据传输和确认机制”部分。'
- en: '| Data Offset | 1/2 (4 bits) | This specifies the number of 32-bit words of
    data in the TCP header. In other words, this value times four equals the number
    of bytes in the header, which must always be a multiple of four. It is called
    a data offset since it indicates by how many 32-bit words the start of the data
    is offset from the beginning of the TCP segment. |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| 数据偏移 | 1/2 (4 bits) | 这指定了TCP头部中的32位字节数。换句话说，此值乘以四等于头部的字节数，这必须始终是4的倍数。它被称为数据偏移，因为它指示数据开始相对于TCP段开始的32位字数。'
- en: '| Reserved | 3/4 (6 bits) | This field is 6 bits reserved for future use; sent
    as zero. |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 3/4 (6 bits) | 此字段为6位保留，供将来使用；发送时作为零。'
- en: '| Control Bits | 3/4 (6 bits) | TCP does not use a separate format for control
    messages. Instead, certain bits are set to indicate the communication of control
    information. The 6 bits are described in [Table 48-2](ch48.html#tcp_segment_control_bits
    "Table 48-2. TCP Segment Control Bits"). |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '| 控制位 | 3/4 (6 bits) | TCP不使用单独的控制消息格式。相反，某些位被设置为指示控制信息的通信。这6位在[表48-2](ch48.html#tcp_segment_control_bits
    "表48-2. TCP段控制位")中描述。'
- en: '| Window | 2 | This indicates the number of octets of data the sender of this
    segment is willing to accept from the receiver at one time. This normally corresponds
    to the current size of the buffer allocated to accept data for this connection.
    In other words, this field is the current receive window size for the device sending
    this segment, which is also the send window for the recipient of the segment.
    See the "TCP Sliding Window Data Transfer and Acknowledgment Mechanics" section
    later in this chapter for details. |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| 窗口 | 2 | 这表示发送此段的发送者愿意一次从接收者那里接受多少个八位字节的数据。这通常对应于为接受此连接分配的当前缓冲区大小。换句话说，此字段是发送此段的设备的当前接收窗口大小，也是段接收者的发送窗口。有关详细信息，请参阅本章后面的“TCP滑动窗口数据传输和确认机制”部分。'
- en: '| Checksum | 2 | This is a 16-bit checksum for data integrity protection, computed
    over the entire TCP datagram, plus a special pseudo header of fields. It is used
    to protect the entire TCP segment against errors in transmission as well as errors
    in delivery. Optional alternate checksum methods are also supported. |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| 校验和 | 2 | 这是一个用于数据完整性保护的16位校验和，计算整个TCP数据报，以及一个特殊的伪头部字段。它用于保护整个TCP段免受传输错误和交付错误的侵害。也支持可选的替代校验和方法。'
- en: '| Urgent Pointer | 2 | This is used in conjunction with the URG control bit
    for priority data transfer (see [Table 48-2](ch48.html#tcp_segment_control_bits
    "Table 48-2. TCP Segment Control Bits")). This field contains the sequence number
    of the last byte of urgent data. See the "TCP Priority Data Transfer: Urgent Function"
    section later in this chapter for details. |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '| 紧急指针 | 2 | 此字段与URG控制位一起用于优先数据传输（见[表48-2](ch48.html#tcp_segment_control_bits
    "表48-2. TCP段控制位")）。此字段包含紧急数据的最后一个字节的序列号。有关详细信息，请参阅本章后面的“TCP优先数据传输：紧急功能”部分。'
- en: '| Options | Variable | TCP includes a generic mechanism for including one or
    more sets of optional data in a TCP segment. Each of the options can be either
    one byte in length or variable in length. The first byte is the Option-Kind subfield,
    and its value specifies the type of option, which in turn indicates whether the
    option is just a single byte or multiple bytes. Options that are many bytes consist
    of three fields, which are described in [Table 48-3](ch48.html#tcp_segment_option_subfields
    "Table 48-3. TCP Segment Option Subfields"). |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 可变 | TCP包含一个通用机制，用于在TCP段中包含一个或多个可选数据集。每个选项可以是1个字节长或可变长。第一个字节是选项-类型子字段，其值指定了选项类型，进而指示选项是单个字节还是多个字节。多个字节的选项由三个字段组成，这些字段在[表48-3](ch48.html#tcp_segment_option_subfields
    "表48-3. TCP段选项子字段"）中描述。|'
- en: '| Padding | Variable | If the Options field is not a multiple of 32 bits in
    length, enough zeros are added to pad the header so it is a multiple of 32 bits.
    |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| 填充 | 可变 | 如果选项字段长度不是32位的倍数，则添加足够的零以填充头部，使其成为32位的倍数。|'
- en: '| Data | Variable | This is the bytes of data being sent in the segment. |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | 可变 | 这是段中发送的数据字节。|'
- en: Table 48-2. TCP Segment Control Bits
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 表48-2. TCP段控制位
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| URG | 1/8 (1 bit) | Urgent bit: When set to 1, indicates that the priority
    data transfer feature has been invoked for this segment, and that the Urgent Pointer
    field is valid. |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| URG | 1/8 (1位) | 紧急位：当设置为1时，表示已调用此段的优先级数据传输功能，并且紧急指针字段是有效的。|'
- en: '| ACK | 1/8 (1 bit) | Acknowledgment bit: When set to 1, indicates that this
    segment is carrying an acknowledgment, and the value of the Acknowledgment Number
    field is valid and carrying the next sequence expected from the destination of
    this segment. |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| ACK | 1/8 (1位) | 确认位：当设置为1时，表示此段携带确认信息，确认号字段的有效值表示从该段的接收方期望的下一个序列号。|'
- en: '| PSH | 1/8 (1 bit) | Push bit: The sender of this segment is using the TCP
    push feature, requesting that the data in this segment be immediately pushed to
    the application on the receiving device. |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '| PSH | 1/8 (1位) | 推送位：此段发送方正在使用TCP推送功能，请求将此段中的数据立即推送到接收设备上的应用程序。|'
- en: '| RST | 1/8 (1 bit) | Reset bit: The sender has encountered a problem and wants
    to reset the connection. |'
  id: totrans-785
  prefs: []
  type: TYPE_TB
  zh: '| RST | 1/8 (1位) | 重置位：发送方遇到问题并希望重置连接。|'
- en: '| SYN | 1/8 (1 bit) | Synchronize bit: This segment is a request to synchronize
    sequence numbers and establish a connection; the Sequence Number field (see [Table 48-1](ch48.html#tcp_segment_format
    "Table 48-1. TCP Segment Format")) contains the ISN of the sender of the segment.
    |'
  id: totrans-786
  prefs: []
  type: TYPE_TB
  zh: '| SYN | 1/8 (1位) | 同步位：此段是请求同步序列号并建立连接的请求；序列号字段（见[表48-1](ch48.html#tcp_segment_format
    "表48-1. TCP段格式"））包含段的发送方的ISN。|'
- en: '| FIN | 1/8 (1 bit) | Finish bit: The sender of the segment is requesting that
    the connection be closed. |'
  id: totrans-787
  prefs: []
  type: TYPE_TB
  zh: '| FIN | 1/8 (1位) | 结束位：段发送方请求关闭连接。|'
- en: '![TCP segment format](httpatomoreillycomsourcenostarchimages288117.png.jpg)'
  id: totrans-788
  prefs: []
  type: TYPE_IMG
  zh: '![TCP段格式](httpatomoreillycomsourcenostarchimages288117.png.jpg)'
- en: Figure 48-1. TCP segment format
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-1. TCP段格式
- en: Table 48-3. TCP Segment Option Subfields
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 表48-3. TCP段选项子字段
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-792
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Option-Kind | 1 | This specifies the option type. |'
  id: totrans-793
  prefs: []
  type: TYPE_TB
  zh: '| 选项-类型 | 1 | 这指定了选项类型。|'
- en: '| Option-Length | 1 | This is the length of the entire option in bytes, including
    the Option-Kind and Option-Length fields. |'
  id: totrans-794
  prefs: []
  type: TYPE_TB
  zh: '| 选项-长度 | 1 | 这是整个选项的长度（以字节为单位），包括选项-类型和选项-长度字段。|'
- en: '| Option-Data | Variable | This field contains the option data itself. In at
    least one oddball case, this field is omitted (making Option-Length equal to 2).
    |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '| 选项-数据 | 可变 | 此字段包含选项数据本身。在至少一个异常情况下，此字段被省略（使选项长度等于2）。|'
- en: '[Table 48-4](ch48.html#some_tcp_options "Table 48-4. Some TCP Options") shows
    the main options currently defined for TCP'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '[表48-4](ch48.html#some_tcp_options "表48-4. 一些TCP选项")显示了当前为TCP定义的主要选项'
- en: Table 48-4. Some TCP Options
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 表48-4. 一些TCP选项
- en: '| Option-Kind | Option-Length | Option-Data | Description |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 选项-类型 | 选项-长度 | 选项-数据 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | — | — | End of Option List: A single-byte option that marks the end of
    all options included in this segment. This needs to be included only when the
    end of the options doesn''t coincide with the end of the TCP header. |'
  id: totrans-800
  prefs: []
  type: TYPE_TB
  zh: '| 0 | — | — | 选项列表结束：一个单字节选项，用于标记包含在此分段中的所有选项的结束。仅在选项的结束与TCP头部结束不一致时需要包含。|'
- en: '| 1 | — | — | No-Operation: A "spacer" that can be included between options
    to align a subsequent option on a 32-bit boundary if needed. |'
  id: totrans-801
  prefs: []
  type: TYPE_TB
  zh: '| 1 | — | — | 无操作：一个“填充符”，可以在选项之间包含，以便在需要时将后续选项对齐到32位边界。|'
- en: '| 2 | 4 | Maximum Segment Size Value | Maximum Segment Size: Conveys the size
    of the largest segment the sender of the segment wishes to receive. Used only
    in connection request (SYN) messages. |'
  id: totrans-802
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 最大分段大小值 | 最大分段大小：传达发送方希望接收的最大分段大小。仅在连接请求（SYN）消息中使用。|'
- en: '| 3 | 3 | Window Size Shift Bits | Window Scale: Implements the optional window
    scale feature, which allows devices to specify much larger window sizes than would
    be possible with the normal Window field. The value in Option-Data specifies the
    power of 2 that the Window field should be multiplied by to get the true window
    size the sender of the option is using. For example, if the value of Option-Data
    is 3, this means values in the Window field should be multiplied by 8, assuming
    both devices agree to use this feature. This allows very large windows to be advertised
    when needed on high-performance links. See the "TCP Sliding Window Data Transfer
    and Acknowledgment Mechanics" section later in this chapter for details. |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | 窗口大小位移位 | 窗口缩放：实现了可选窗口缩放功能，允许设备指定比正常窗口字段可能的大得多的窗口大小。Option-Data中的值指定了窗口字段应该乘以的2的幂，以获得选项发送方实际使用的真实窗口大小。例如，如果Option-Data的值为3，这意味着窗口字段中的值应该乘以8，前提是两个设备都同意使用此功能。这允许在高性能链路上在需要时宣布非常大的窗口。有关详细信息，请参阅本章后面的“TCP滑动窗口数据传输和确认机制”部分。|'
- en: '| 4 | 2 | — | Selective Acknowledgment Permitted: Specifies that this device
    supports the selective acknowledgment (SACK) feature. This was implemented as
    a 2-byte option with no Option-Data field, instead of a single-byte option like
    End of Option List or No-Operation. This was necessary because it was defined
    after the original TCP specification, so an explicit option length needed to be
    indicated for backward compatibility. |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | — | 允许选择性确认：指定此设备支持选择性确认（SACK）功能。这作为一个2字节选项实现，没有Option-Data字段，而不是像选项列表结束或无操作那样的单字节选项。这是必要的，因为它是在原始TCP规范之后定义的，因此需要一个显式的选项长度来指示向后兼容性。|'
- en: '| 5 | Variable | Blocks of Data Selectively Acknowledged | Selective Acknowledgment:
    Allows devices supporting the optional selective acknowledgment feature to specify
    noncontiguous blocks of data that have been received so they are not retransmitted
    if intervening segments do not show up and need to be retransmitted. |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 可变 | 选择性确认数据块 | 选择性确认：允许支持可选选择性确认功能的设备指定已接收的非连续数据块，这样在中间分段未出现且需要重传时，它们不会被重传。|'
- en: '| 14 | 3 | Alternate Checksum Algorithm | Alternate Checksum Request: Lets
    a device request that a checksum-generation algorithm other than the standard
    TCP algorithm be used for this connection. Both devices must agree to the algorithm
    for it to be used. |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 3 | 交替校验算法 | 交替校验请求：允许设备请求使用除标准TCP算法之外的校验生成算法来处理此连接。两个设备必须同意使用该算法。|'
- en: '| 15 | Variable | Alternate Checksum | Alternate Checksum: If the checksum
    value needed to implement an alternate checksum is too large to fit in the standard
    16-bit Checksum field, it is placed in this option. |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 可变 | 交替校验 | 交替校验：如果实现交替校验所需的校验值太大，无法放入标准的16位校验字段中，则将其放置在此选项中。|'
- en: The table does not include every TCP option; it just shows the basic ones defined
    in RFC 793 and a few others that are interesting and correspond to features described
    elsewhere in this book. Note that most options are sent only in connection request
    (SYN) segments. This includes the Maximum Segment Size, Window Scale, Selective
    Acknowledgment Permitted, and Alternate Checksum Request options. In contrast,
    the Selective Acknowledgment and Alternate Checksum options appear in regular
    data segments when they are used.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 表格并未包含每个 TCP 选项；它只显示了在 RFC 793 中定义的基本选项以及一些有趣的其他选项，这些选项与本书其他部分描述的功能相对应。请注意，大多数选项仅在连接请求（SYN）段中发送。这包括最大段大小、窗口缩放、选择性确认允许和备用校验和请求选项。相比之下，选择性确认和备用校验和选项在它们被使用时出现在常规数据段中。
- en: TCP Checksum Calculation and the TCP Pseudo Header
  id: totrans-809
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 校验和计算与 TCP 伪头部
- en: 'TCP is designed to provide reliable data transfer between a pair of devices
    on an IP internetwork. Much of the effort required to ensure reliable delivery
    of data segments is focused on the problem of ensuring that data is not lost in
    transit. But there''s another important critical impediment to the safe transmission
    of data: the risk of *errors* being introduced into a TCP segment during its travel
    across the internetwork.'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 是设计用来在 IP 网络中一对设备之间提供可靠的数据传输。确保数据段可靠传输所需的大部分努力都集中在确保数据在传输过程中不会丢失的问题上。但还有另一个重要的关键障碍，即数据在穿越互联网过程中被引入
    *错误* 的风险。
- en: Detecting Transmission Errors Using Checksums
  id: totrans-811
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用校验和检测传输错误
- en: 'If the data gets where it needs to go but is corrupted, and we do not detect
    the corruption, this is in some ways worse than it never showing up at all. To
    provide basic protection against errors in transmission, TCP includes a 16-bit
    Checksum field in its header. The idea behind a checksum is very straightforward:
    Take a string of data bytes and add them all together, then send this sum with
    the data stream and have the receiver check the sum. In TCP, the device sending
    the segment uses a special algorithm to calculate this checksum. The recipient
    then employs the same algorithm to check the data it received and ensure that
    there were no errors.'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据到达了它需要去的地方，但被破坏了，而我们没有检测到这种破坏，这在某些方面比它根本没出现还要糟糕。为了提供对传输错误的基本保护，TCP 在其头部包含一个
    16 位的校验和字段。校验和背后的思想非常简单：将数据字节串相加，然后将这个总和与数据流一起发送，并让接收方检查这个总和。在 TCP 中，发送段的设备使用一个特殊的算法来计算这个校验和。然后，接收方使用相同的算法来检查它接收到的数据，并确保没有错误。
- en: The checksum calculation used by TCP is a bit different than a regular checksum
    algorithm. A conventional checksum is performed over all the bytes that the checksum
    is intended to protect, and it can detect most bit errors in any of those fields.
    The designers of TCP wanted this bit-error protection, but they also wanted protection
    against other types of problems. To this end, a change was made in how the TCP
    checksum is computed. This special TCP checksum algorithm was eventually also
    adopted for use by UDP; see [Chapter 44](ch44.html "Chapter 44. TCP/IP USER DATAGRAM
    PROTOCOL (UDP)").
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 使用的校验和计算与常规校验和算法略有不同。常规校验和是在校验和旨在保护的所有字节上执行的，并且它可以检测到这些字段中的大多数位错误。TCP 的设计者想要这种位错误保护，但他们还想要对其他类型的问题进行保护。为此，对
    TCP 校验和的计算方式进行了修改。这个特殊的 TCP 校验和算法最终也被用于 UDP；参见[第 44 章](ch44.html "第 44 章。TCP/IP
    用户数据报协议 (UDP)")。
- en: 'Increasing the Scope of Detected Errors: The TCP Pseudo Header'
  id: totrans-814
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加检测错误范围：TCP 伪头部
- en: Instead of computing the checksum over only the actual data fields of the TCP
    segment, a 12-byte TCP *pseudo header* is created prior to checksum calculation.
    This header contains important information taken from fields in both the TCP header
    and the Internet Protocol (IP) datagram into which the TCP segment will be encapsulated
    (see [Chapter 21](ch21.html "Chapter 21. INTERNET PROTOCOL DATAGRAM ENCAPSULATION
    AND FORMATTING") for a description of the IP datagram format). The TCP pseudo
    header has the format described in [Table 48-5](ch48s02.html#tcp_pseudo_header_for_checksum_calculati
    "Table 48-5. TCP Pseudo Header for Checksum Calculations") and illustrated in
    [Figure 48-2](ch48s02.html#tcp_pseudo_header_for_checksum_cal-id001 "Figure 48-2. TCP
    pseudo header for checksum calculation").
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算TCP段的实际数据字段校验和之前，创建了一个12字节的TCP *伪头*。这个头包含了从TCP头和将要封装TCP段在内的互联网协议（IP）数据报中的字段中提取的重要信息（有关IP数据报格式的描述，请参阅[第21章](ch21.html
    "第21章。互联网协议数据报封装和格式")）。TCP伪头的格式在[表48-5](ch48s02.html#tcp_pseudo_header_for_checksum_cal
    "表48-5。用于校验和计算的TCP伪头")中描述，并在[图48-2](ch48s02.html#tcp_pseudo_header_for_checksum_cal-id001
    "图48-2。用于校验和计算的TCP伪头")中展示。
- en: Table 48-5. TCP Pseudo Header for Checksum Calculations
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 表48-5。用于校验和计算的TCP伪头
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-817
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-818
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Source Address | 4 | This is the 32-bit IP address of the originator of the
    datagram, taken from the IP header. |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '| 源地址 | 4 | 这是数据报发起者的32位IP地址，来自IP头。|'
- en: '| Destination Address | 4 | This is the 32-bit IP address of the intended recipient
    of the datagram, also from the IP header. |'
  id: totrans-820
  prefs: []
  type: TYPE_TB
  zh: '| 目标地址 | 4 | 这是数据报预期接收者的32位IP地址，也来自IP头。|'
- en: '| Reserved | 1 | This consists of 8 bits of zeros. |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 1 | 这由8个零位组成。|'
- en: '| Protocol | 1 | This is the Protocol field from the IP header. This indicates
    the higher-layer protocol that is carried in the IP datagram. Of course, we already
    know that this protocol is TCP. So, this field will normally have the value 6.
    |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 1 | 这是来自IP头的协议字段。这表示IP数据报中携带的更高层协议。当然，我们已经知道这个协议是TCP。因此，这个字段通常具有值6。|'
- en: '| TCP Length | 2 | This is the length of the TCP segment, including both header
    and data. Note that this is not a specific field in the TCP header; it is computed.
    |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '| TCP长度 | 2 | 这是TCP段的大小，包括头部和数据。请注意，这并不是TCP头中的一个特定字段；它是计算得出的。|'
- en: '![TCP pseudo header for checksum calculation](httpatomoreillycomsourcenostarchimages288119.png.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![用于校验和计算的TCP伪头](httpatomoreillycomsourcenostarchimages288119.png.jpg)'
- en: Figure 48-2. TCP pseudo header for checksum calculation
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-2。用于校验和计算的TCP伪头
- en: Once this 96-bit header has been formed, it is placed in a buffer, followed
    by the TCP segment itself. Then the checksum is computed over the entire set of
    data (pseudo header plus TCP segment). The value of the checksum is placed in
    the Checksum field of the TCP header, and the pseudo header is discarded; it is
    *not* an actual part of the TCP segment and is not transmitted. This process is
    illustrated in [Figure 48-3](ch48s02.html#tcp_header_checksum_calculation_to_calcu
    "Figure 48-3. TCP header checksum calculation To calculate the TCP segment header's
    Checksum field, the TCP pseudo header is first constructed and placed, logically,
    before the TCP segment. The checksum is then calculated over both the pseudo header
    and the TCP segment. The pseudo header is then discarded.").
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦形成这个96位的头，它就被放置在缓冲区中，然后是TCP段本身。然后计算整个数据集（伪头加TCP段）的校验和。校验和的值放置在TCP头的校验和字段中，伪头被丢弃；它不是TCP段的实际部分，也不会被传输。这个过程在[图48-3](ch48s02.html#tcp_header_checksum_calculation_to_calcu
    "图48-3。TCP头校验和计算。为了计算TCP段头的校验和字段，首先构建TCP伪头并将其逻辑上放置在TCP段之前。然后计算伪头和TCP段的校验和。然后丢弃伪头。")中展示。
- en: Note
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Checksum field is itself part of the TCP header and thus one of the fields
    over which the checksum is calculated, creating a "chicken-and-egg" situation
    of sorts. This field is assumed to be all zeros during calculation of the checksum.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和字段本身也是TCP头的一部分，因此是计算校验和的字段之一，造成了一种“鸡生蛋，蛋生鸡”的情况。在计算校验和时，假设这个字段全部为零。
- en: When the TCP segment arrives at its destination, the receiving TCP software
    performs the same calculation. It forms the pseudo header, prepends it to the
    actual TCP segment, and then performs the checksum (setting the Checksum field
    to zero for the calculation as before). If there is a mismatch between its calculation
    and the value the source device put in the Checksum field, this indicates that
    an error of some sort occurred, and the segment is normally discarded.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 当TCP段到达其目的地时，接收TCP软件执行相同的计算。它形成伪头部，将其附加到实际的TCP段上，然后进行校验和（计算时将校验和字段设置为零，如之前所述）。如果其计算值与源设备放入校验和字段的值不匹配，这表明发生了某种错误，并且通常将段丢弃。
- en: '![TCP header checksum calculation To calculate the TCP segment header''s Checksum
    field, the TCP pseudo header is first constructed and placed, logically, before
    the TCP segment. The checksum is then calculated over both the pseudo header and
    the TCP segment. The pseudo header is then discarded.](httpatomoreillycomsourcenostarchimages288121.png.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![TCP头部校验和计算 为了计算TCP段头部的校验和字段，首先构建TCP伪头部并将其逻辑上放置在TCP段之前。然后，对伪头部和TCP段进行校验和计算。伪头部随后被丢弃。](httpatomoreillycomsourcenostarchimages288121.png.jpg)'
- en: Figure 48-3. TCP header checksum calculation To calculate the TCP segment header's
    Checksum field, the TCP pseudo header is first constructed and placed, logically,
    before the TCP segment. The checksum is then calculated over both the pseudo header
    and the TCP segment. The pseudo header is then discarded.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-3. TCP头部校验和计算 为了计算TCP段头部的校验和字段，首先构建TCP伪头部并将其逻辑上放置在TCP段之前。然后，对伪头部和TCP段进行校验和计算。伪头部随后被丢弃。
- en: Advantages of the Pseudo Header Method
  id: totrans-832
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪头部方法的优势
- en: 'So, why bother with this pseudo header? The source and destination devices
    both compute the checksum using the fields in this pseudo header. This means that
    if, for any reason, the two devices don''t use the same values for the pseudo
    header, the checksum will fail. When we consider what''s in the header, we find
    that this means the checksum now protects against not just errors in the TCP segment
    fields, but also against the following problems:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么还要使用这个伪头部呢？源设备和目标设备都使用这个伪头部中的字段来计算校验和。这意味着，如果由于任何原因，两个设备在伪头部中使用的值不同，校验和将失败。当我们考虑头部中的内容时，我们发现这意味着校验和现在不仅保护TCP段字段中的错误，还保护以下问题：
- en: '**Incorrect Segment Delivery** If there is a mismatch in the Destination Address
    between what the source specified and what the destination that received the segment
    used, the checksum will fail. The same will happen if the Source Address does
    not match.'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '**分段交付错误** 如果源指定的目标地址与接收段的目标地址不匹配，校验和将失败。如果源地址不匹配，也会发生相同的情况。'
- en: '**Incorrect Protocol** If a datagram is routed to TCP that actually belongs
    to a different protocol for whatever reason, this can be immediately detected.'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议错误** 如果由于某种原因，数据报被路由到TCP，而实际上它属于不同的协议，这可以立即检测到。'
- en: '**Incorrect Segment Length** If part of the TCP segment has been omitted by
    accident, the lengths the source and destination used won''t match, and the checksum
    will fail.'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '**分段长度错误** 如果TCP段的一部分被意外省略，源设备和目标设备使用的长度将不匹配，校验和将失败。'
- en: What's clever about the pseudo header is that by using it for the checksum calculation,
    we can provide this protection without actually needing to send the fields in
    the pseudo header itself. This eliminates duplicating the IP fields used in the
    pseudo header within the TCP header, which would be redundant and wasteful of
    bandwidth. The drawback of the pseudo header method is that it makes checksum
    calculation take more time and effort (though this is not much of an issue today).
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 伪头部聪明的地方在于，通过使用它进行校验和计算，我们可以提供这种保护，而实际上并不需要发送伪头部本身中的字段。这消除了在TCP头部中重复使用伪头部中使用的IP字段，这将是不必要的且浪费带宽。伪头部方法的缺点是它使得校验和计算需要更多的时间和精力（尽管这在今天并不是一个大问题）。
- en: Tip
  id: totrans-838
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** TCP checksums are computed over not just the TCP segment, but
    also over a TCP *pseudo header* that contains the length of the TCP segment as
    well as the IP Source Address, Destination Address, and Protocol fields. Since
    these fields are part of the checksum, if the segment is received by the wrong
    device or has the incorrect Protocol field or segment length, it will be rejected.
    The technique is clever because the checksum can provide this protection, even
    though the pseudo header itself is not actually transmitted.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP校验和不仅计算TCP分段，还包括包含TCP分段长度以及IP源地址、目的地址和协议字段的TCP伪头部。由于这些字段是校验和的一部分，如果分段被错误设备接收或协议字段或分段长度不正确，它将被拒绝。这种技术很巧妙，因为即使伪头部本身实际上并没有传输，校验和也能提供这种保护。'
- en: In the context of today's modern, high-speed, highly reliable networks, the
    use of the pseudo header sometimes seems archaic. How likely is it that a datagram
    will be delivered to the wrong address? Not very. At the time TCP was created,
    however, there was significant concern that there might not be proper end-to-end
    checking of the delivery of datagrams at the IP level. Including IP information
    in the TCP checksum was seen as a useful additional level of protection.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今现代、高速、高度可靠的网络的背景下，使用伪头部有时似乎有些过时。数据报被错误地址交付的可能性有多大？不太可能。然而，在TCP创建的时候，人们却对IP层上数据报的端到端交付检查可能不正确表示了极大的担忧。将IP信息包含在TCP校验和中被视为一种有用的额外保护层。
- en: Note
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is one interesting implication of the TCP pseudo header: It violates
    the architectural layering principles that the designers of TCP sought to respect
    in splitting up TCP and IP. For the checksum, TCP must know IP information that
    technically it shouldn''t know. TCP checksum calculation requires, for example,
    that the protocol number from the IP header be given to the TCP layer on the receiving
    device from the IP datagram that carried the segment. The TCP pseudo header is
    a good example of a case where strict layering was eschewed in favor of practicality.'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: TCP伪头部有一个有趣的含义：它违反了TCP设计者在将TCP和IP分割开来时试图尊重的架构分层原则。对于校验和，TCP必须知道它技术上不应该知道的网络信息。例如，TCP校验和计算需要将IP头部的协议号从携带该分段的IP数据报中提供给接收设备的TCP层。TCP伪头部是严格分层被实用性所取代的一个很好的例子。
- en: TCP also supports an optional method of having two devices agree on an alternative
    checksum algorithm. This must be negotiated during connection establishment.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: TCP还支持一种可选的方法，让两个设备就一个替代校验和算法达成一致。这必须在建立连接期间协商。
- en: TCP Maximum Segment Size (MSS)
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP最大分段大小（MSS）
- en: 'TCP *segments* are the messages that carry data between TCP devices. The Data
    field is where the actual data being transmitted is carried, and since the length
    of the Data field in TCP is variable, this raises an interesting question: How
    much data should we put into each segment? TCP accepts data as a constant stream
    from the applications that use it, which means that it must decide how many bytes
    to put into each message that it sends.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: TCP分段是携带TCP设备之间数据的消息。数据字段是实际传输数据被携带的地方，由于TCP中数据字段的长度是可变的，这引发了一个有趣的问题：我们应该在每个分段中放入多少数据？TCP从使用它的应用程序接受一个恒定的数据流，这意味着它必须决定在每个发送的消息中放入多少字节。
- en: A primary determinant of how much data to send in a segment is the current status
    of the sliding window mechanism on the part of the receiver. When Device A receives
    a TCP segment from Device B, it examines the value of the Window field to know
    the limit on how much data Device B is allowing Device A to send in its next segment.
    (This process is described in the "TCP Sliding Window Data Transfer and Acknowledgment
    Mechanics" section later in this chapter.) There are also important issues in
    the selection and adjustment of window size that impact the operation of the TCP
    system as a whole, which are discussed in [Chapter 46](ch46.html "Chapter 46. TRANSMISSION
    CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION").
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 决定在分段中发送多少数据的一个主要因素是接收方滑动窗口机制当前的状态。当设备A从设备B接收TCP分段时，它会检查窗口字段的值，以了解设备B允许设备A在其下一个分段中发送的数据量限制。（这个过程在本章后面的“TCP滑动窗口数据传输和确认机制”部分中描述。）在选择和调整窗口大小方面也存在一些重要问题，这些问题会影响整个TCP系统的操作，这些问题将在[第46章](ch46.html
    "第46章。传输控制协议（TCP）基础和一般操作")中讨论。
- en: In addition to the dictates of the current window size, each TCP device also
    has associated with it a *ceiling* on TCP size—a segment size that will never
    be exceeded, regardless of how large the current window is. This is called the
    *maximum segment size (MSS)*. When deciding how much data to put into a segment,
    each device in the TCP connection will choose the amount based on the current
    window size, in conjunction with the various algorithms described in [Chapter 46](ch46.html
    "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION"),
    but it will never be so large that the amount of data exceeds the MSS of the device
    to which it is sending.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 除了当前窗口大小的规定之外，每个 TCP 设备还与其关联一个 TCP 大小的上限——一个永远不会超过的段大小。这被称为**最大段大小（MSS）**。在决定将多少数据放入一个段时，TCP
    连接中的每个设备都会根据当前窗口大小，结合[第 46 章](ch46.html "第 46 章。传输控制协议（TCP）基础和一般操作")中描述的各种算法来选择数据量，但它永远不会大到超过它发送的设备
    MSS。
- en: Note
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name maximum segment size is misleading. The value actually refers to the
    maximum amount of data that a segment can hold. It does not include the TCP headers.
    So if the MSS is 100, the actual maximum segment size could be 120 (for a regular
    TCP header) or larger (if the segment includes TCP options).
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 最大段大小的名称具有误导性。该值实际上指的是一个段可以容纳的最大数据量。它不包括 TCP 头部。因此，如果 MSS 是 100，实际的最高段大小可能是
    120（对于常规 TCP 头部）或更大（如果段包含 TCP 选项）。
- en: MSS Selection
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MSS 选择
- en: The selection of the MSS is based on the need to balance various competing performance
    and implementation issues in the transmission of data on TCP/IP networks. The
    main TCP standard, RFC 793, doesn't say much about MSS, so there was potential
    for confusion about how the parameter should be used. RFC 879 was published a
    couple of years after the TCP standard to clarify this parameter and the issues
    surrounding it.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: MSS 的选择基于在 TCP/IP 网络上传输数据时需要平衡各种相互竞争的性能和实现问题。主要的 TCP 标准，RFC 793，对 MSS 没有太多说明，因此可能会对如何使用该参数产生混淆。RFC
    879 在 TCP 标准发布后几年发布，以阐明该参数及其相关问题。
- en: 'Some issues with the MSS are fairly mundane; for example, certain devices are
    limited in the amount of space they have for buffers to hold TCP segments, and
    therefore may wish to limit segment size to a relatively small value. In general,
    though, the MSS must be chosen by balancing two competing performance issues:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: MSS 的一些问题相当平凡；例如，某些设备在缓冲区中用于存储 TCP 段的空间有限，因此可能希望将段大小限制在一个相对较小的值。然而，总的来说，MSS
    必须在两个相互竞争的性能问题之间进行权衡：
- en: '**Overhead Management** The TCP header takes up 20 bytes of data (or more if
    options are used); the IP header also uses 20 or more bytes. This means that between
    them, a minimum of 40 bytes is needed for headers, and all of that is nondata
    overhead. If we set the MSS too low, this results in very inefficient use of bandwidth.
    For example, if we set it to 40 bytes, a *maximum* of 50 percent of each segment
    could actually be data; the rest would just be headers. Many segment datagrams
    would be even worse in terms of efficiency.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**开销管理** TCP 头部占用 20 字节的数据（或使用选项时更多）；IP 头部也使用 20 或更多字节。这意味着它们之间，至少需要 40 字节用于头部，而这全部是非数据开销。如果我们设置
    MSS 太低，这将导致带宽使用非常低效。例如，如果我们将其设置为 40 字节，每个段的**最大**50% 实际上是数据；其余的只是头部。许多段数据报在效率方面会更差。'
- en: '**IP Fragmentation** TCP segments will be packaged into IP datagrams. As you
    saw in [Chapter 22](ch22.html "Chapter 22. IP DATAGRAM SIZE, FRAGMENTATION, AND
    REASSEMBLY"), datagrams have their own size limit issues: the matter of the maximum
    transmission unit (MTU) of an underlying network. If a TCP segment is too large,
    it will lead to an IP datagram that is too large to be sent without fragmentation.
    Fragmentation reduces efficiency and increases the chances of part of a TCP segment
    being lost, resulting in the entire segment needing to be retransmitted.'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP 分片** TCP 段将被封装成 IP 数据报。正如你在[第 22 章](ch22.html "第 22 章。IP 数据报大小、分片和重组")中看到的，数据报有自己的大小限制问题：底层网络的最大的传输单元（MTU）问题。如果一个
    TCP 段太大，它将导致一个无法不进行分片发送的过大的 IP 数据报。分片降低了效率，并增加了 TCP 段的一部分丢失的可能性，导致整个段需要重新传输。'
- en: TCP Default MSS
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 默认 MSS
- en: The solution to the two competing issues of overhead management and IP fragmentation
    was to establish a default MSS for TCP that was as large as possible, while avoiding
    fragmentation for most transmitted segments. This was computed by starting with
    the minimum MTU for IP networks of 576 bytes. All networks are required to be
    able to handle an IP datagram of this size without fragmenting. From this number,
    we subtract 20 bytes for the TCP header and 20 bytes for the IP header, leaving
    536 bytes. This is the standard MSS for TCP.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 解决开销管理和IP分段这两个相互竞争的问题的方案是，为TCP建立一个尽可能大的默认MSS，同时避免大多数传输段发生分段。这是通过从IP网络的最低MTU
    576字节开始计算的。所有网络都必须能够处理这个大小的IP数据报而不会分段。从这个数字中，我们减去20字节用于TCP头部和20字节用于IP头部，剩下536字节。这是TCP的标准MSS。
- en: Tip
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT**TCP is designed to restrict the size of the segments it sends
    to a certain maximum limit, to reduce the likelihood that segments will need to
    be fragmented for transmission at the IP level. The TCP *maximum segment size
    (MSS)* specifies the maximum number of bytes in the TCP segment''s Data field,
    regardless of any other factors that influence segment size. The default MSS for
    TCP is 536 bytes, which is calculated by starting with the minimum IP MTU of 576
    bytes and subtracting 20 bytes each for the IP and TCP headers.'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念**TCP被设计为限制它发送的段的大小，以一定的最大限制，以减少在IP层传输时需要分段的可能性。TCP *最大分段大小（MSS）* 指定了TCP段数据字段中的最大字节数，无论其他影响段大小的因素如何。TCP的默认MSS是536字节，这是通过从最低IP
    MTU 576字节开始，并为IP和TCP头部各减去20字节计算得出的。'
- en: The selection of this MSS value was a compromise of sorts. It means that most
    TCP segments will be sent unfragmented across an IP internetwork. However, if
    any TCP or IP options are used, the minimum MTU of 576 bytes will be exceeded,
    and fragmentation will occur. Still, it makes more sense to allow some segments
    to be fragmented, rather than use a much smaller MSS to ensure that none are ever
    fragmented. If we chose, say, an MSS of 400 bytes, we would probably never have
    fragmentation, but we would lower the data/header ratio from 536:40 (93 percent
    data) to 400:40 (91 percent data) for all segments.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这个MSS值是一种折衷。这意味着大多数TCP段将无分段地跨越IP互联网发送。然而，如果使用了任何TCP或IP选项，最小MTU为576字节将被超过，并且会发生分段。尽管如此，允许一些段进行分段比使用一个远小于MSS的值以确保它们永远不会分段更有意义。如果我们选择，比如说，400字节的MSS，我们可能永远不会发生分段，但我们会降低所有段的数据/头部比率从536:40（93%数据）到400:40（91%数据）。
- en: Nondefault MSS Value Specification
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非默认MSS值指定
- en: Naturally, there will be cases where the default MSS is not ideal. TCP provides
    a means for a device to specify that the MSS it wants to use is either smaller
    or larger than the default value of 536 bytes. A device can inform the other device
    of the MSS it wants to use through parameter exchange during the connection establishment
    process. A device that chooses to do so includes in its SYN message the TCP option
    called, appropriately, Maximum Segment Size. The other device receives this option
    and records the MSS for the connection. Each device can specify the MSS it wants
    for the segments it receives independently.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，会有一些情况，默认MSS值并不理想。TCP提供了一种机制，允许设备指定它想要使用的MSS值要么小于或大于536字节的默认值。设备可以通过在建立连接过程中交换参数来通知其他设备它想要使用的MSS值。选择这样做的设备会在其SYN消息中包含一个称为最大分段大小的TCP选项。其他设备接收到这个选项并记录连接的MSS。每个设备都可以独立指定它希望接收的段所使用的MSS。
- en: Note
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The exchange of MSS values during setup is sometimes called MSS negotiation.
    This is actually a misleading term, because it implies that the two devices must
    agree on a common MSS value, which is not the case. The MSS value used by each
    may be different, and there is no negotiation at all.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置过程中交换MSS值有时被称为MSS协商。这实际上是一个误导性的术语，因为它暗示两个设备必须就一个共同MSS值达成一致，而这并不是事实。每个设备使用的MSS值可能不同，并且根本不存在协商。
- en: Devices may wish to use a larger MSS if they know that the MTUs of the networks
    the segments will pass over are larger than the IP minimum of 576 bytes. This
    is most commonly the case when large amounts of data are sent on a local network.
    The process of MTU path discovery, as described in [Chapter 22](ch22.html "Chapter 22. IP
    DATAGRAM SIZE, FRAGMENTATION, AND REASSEMBLY"), is used to determine the appropriate
    MSS. Devices might use a smaller MSS if they know that TCP segments use a particular
    optional feature that would consistently increase the size of the IP header, such
    as when the segments employ IPsec for security (see [Chapter 29](ch29.html "Chapter 29. IP
    SECURITY (IPSEC) PROTOCOLS")).
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备知道将要传输的段将通过的网络MTU大于IP的最小值576字节，它们可能会希望使用更大的MSS。这种情况在大量数据在本地网络中发送时最为常见。正如[第22章](ch22.html
    "第22章. IP数据报大小、分片和重组")中所述的MTU路径发现过程，用于确定适当的大小。如果设备知道TCP段使用某个特定的可选功能，该功能会持续增加IP头的大小，例如当段使用IPsec进行安全时（参见[第29章](ch29.html
    "第29章. IP安全（IPSEC）协议")），它们可能会使用较小的MSS。
- en: Tip
  id: totrans-865
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Devices can indicate that they wish to use a different MSS
    value from the default by including a Maximum Segment Size option in the SYN message
    they use to establish a connection. Each device in the connection may use a different
    MSS value.'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 设备可以通过在它们用于建立连接的SYN消息中包含最大段大小选项来指示它们希望使用与默认值不同的MSS值。连接中的每个设备都可能使用不同的MSS值。'
- en: TCP Sliding Window Data Transfer and Acknowledgment Mechanics
  id: totrans-867
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP滑动窗口数据传输和确认机制
- en: The TCP connection establishment process is employed by a pair of devices to
    create a TCP connection between them. Once all the setup is done—transmission
    control blocks (TCBs) have been set up, parameters have been exchanged, and so
    forth—the devices are ready to get down to the business of transferring data.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接建立过程是由一对设备使用的，用于在它们之间创建TCP连接。一旦所有设置完成——传输控制块（TCBs）已设置，参数已交换，等等——设备就准备好开始传输数据了。
- en: The sending of data between TCP devices on a connection is accomplished using
    the sliding window system we explored in [Chapter 46](ch46.html "Chapter 46. TRANSMISSION
    CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION"). Here, we will take
    a more detailed look at exactly how sliding windows are implemented to allow data
    to be sent and received. For ease of explanation, we'll assume that our connection
    is between a client and a server—this is easier than the whole "Device A/Device
    B" business.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接中，TCP设备之间数据的发送是通过我们在[第46章](ch46.html "第46章. 传输控制协议（TCP）基础和一般操作")中探讨的滑动窗口系统完成的。在这里，我们将更详细地探讨滑动窗口是如何实现的，以便发送和接收数据。为了便于解释，我们假设我们的连接是在客户端和服务器之间——这比整个“设备A/设备B”的业务要简单。
- en: Sliding Window Transmit and Receive Categories
  id: totrans-870
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动窗口发送和接收类别
- en: 'Each of the two devices on a connection must keep track of the data it is sending,
    as well as the data it is receiving from the other device. This is done by conceptually
    dividing the bytes into *categories*. For data being transmitted, there are four
    transmit categories:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 连接上的两个设备都必须跟踪它们发送的数据以及从另一设备接收的数据。这是通过概念上将字节划分为*类别*来完成的。对于正在传输的数据，有四个发送类别：
- en: '**Transmit Category 1** Bytes sent and acknowledged'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送类别1** 已发送并确认的字节'
- en: '**Transmit Category 2** Bytes sent but not yet acknowledged'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送类别2** 已发送但尚未确认的字节'
- en: '**Transmit Category 3** Bytes not yet sent for which recipient is ready'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送类别3** 已发送但尚未准备好接收的字节'
- en: '**Transmit Category 4** Bytes not yet sent for which recipient is not ready'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送类别4** 已发送但尚未准备好接收的字节'
- en: 'For data being received, there is no need to separate into "received and acknowledged"
    and "received and unacknowledged," the way the transmitter separates its first
    two categories into "sent and acknowledged" and "sent but not yet acknowledged."
    The reason is that the transmitter must wait for acknowledgment of each transmission,
    but the receiver doesn''t need acknowledgment that it received something. Thus,
    one receive category corresponds to Transmit Categories 1 and 2, while the other
    two correspond to Transmit Category 3 and Transmit Category 4, respectively, for
    a total of three receive categories. To help make more clear how the categories
    relate, I number them as follows:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正在接收的数据，没有必要像发送方将其前两个类别分为“已发送并确认”和“已发送但尚未确认”那样，将其分为“已接收并确认”和“已接收但尚未确认”。原因是发送方必须等待每次传输的确认，但接收方不需要确认它已收到某些内容。因此，一个接收类别对应于传输类别1和2，而另外两个分别对应于传输类别3和传输类别4，总共三个接收类别。为了帮助更清楚地说明类别之间的关系，我按如下方式编号：
- en: '**Receive Category 1+2** Bytes received and acknowledged. This is the receiver''s
    complement to Transmit Categories 1 and 2.'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收类别1+2** 已接收并确认的字节。这是接收方对传输类别1和2的补充。'
- en: '**Receive Category 3** Bytes not yet received for which recipient is ready.
    This is the receiver''s complement to Transmit Category 3.'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收类别3** 尚未接收但接收方已准备好的字节。这是接收方对传输类别3的补充。'
- en: '**Receive Category 4** Bytes not yet received for which recipient is not ready.
    This is the receiver''s complement to Transmit Category 4.'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收类别4** 尚未接收但接收方尚未准备好的字节。这是接收方对传输类别4的补充。'
- en: Send (SND) and Receive (RCV) Pointers
  id: totrans-880
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送（SND）和接收（RCV）指针
- en: Both the client and server must keep track of both streams being sent over the
    connection. This is done using a set of special variables called *pointers*, which
    carve the byte stream into the categories described in the previous section.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都必须跟踪通过连接发送的两个流。这是通过一组称为指针的特殊变量来完成的，这些指针将字节流划分为上一节中描述的类别。
- en: 'The four transmit categories are divided using three send (SND) pointers. Two
    of the pointers are absolute (refer to a specific sequence number), and one is
    an offset that is added to one of the absolute pointers, as follows:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 四个传输类别是通过三个发送（SND）指针来划分的。其中两个指针是绝对的（参考特定的序列号），另一个是添加到绝对指针之一上的偏移量，如下所示：
- en: '**Send Unacknowledged (SND.UNA)** The sequence number of the first byte of
    data that has been sent but not yet acknowledged. This marks the first byte of
    Transmit Category 2; all previous sequence numbers refer to bytes in Transmit
    Category 1.'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送未确认（SND.UNA）** 已发送但尚未确认的数据的第一个字节的序列号。这标志着传输类别2的第一个字节；所有之前的序列号都指的是传输类别1中的字节。'
- en: '**Send Next (SND.NXT)** The sequence number of the next byte of data to be
    sent to the other device (the server, in this case). This marks the first byte
    of Transmit Category 3.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送下一个字节（SND.NXT）** 下一个要发送到另一设备（在这种情况下是服务器）的数据字节的序列号。这标志着传输类别3的第一个字节。'
- en: '**Send Window (SND.WND)** The size of the send window. Recall that the window
    specifies the total number of bytes that any device may have outstanding *(unacknowledged)*
    at any one time. Thus, adding the sequence number of the first unacknowledged
    byte (SND.UNA) and the send window (SND.WND) marks the first byte of Transmit
    Category 4.'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送窗口（SND.WND）** 发送窗口的大小。回想一下，窗口指定任何设备在任何时刻可能有的未确认的字节数量。因此，将第一个未确认字节的序列号（SND.UNA）和发送窗口（SND.WND）相加，标志着传输类别4的第一个字节。'
- en: 'Another way of looking at these pointers is how they indicate the number of
    bytes a transmitting device can send at any point in time—that is, the number
    of bytes in Transmit Category 3\. The start of Transmit Category 3 is marked by
    SND.NXT. The end is marked by the first byte of Transmit Category 4, given by
    SND.UNA+SND.WND. Thus, the number of bytes in Transmit Category 3 is given by
    the following formula:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这些指针的方法是它们如何指示在任何时刻传输设备可以发送的字节数——即传输类别3中的字节数。传输类别3的开始由SND.NXT标记，结束由传输类别4的第一个字节标记，该字节由SND.UNA+SND.WND给出。因此，传输类别3中的字节数由以下公式给出：
- en: SND.UNA + SND.WND - SND.NXT
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: SND.UNA + SND.WND - SND.NXT
- en: This is called the *usable window*, since it indicates how many bytes the transmitter
    can use at any point in time. When data is acknowledged, this causes bytes to
    move from Transmit Category 2 to Transmit Category 1, by increasing the value
    of SND.UNA. Assuming that the send window size doesn't change, this causes the
    window to *slide* to the right, permitting more data to be sent. [Figure 48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "Figure 48-4. TCP transmission categories, send window, and pointers This diagram
    is the same as Figure 46-6 (in Chapter 46), but shows the TCP send pointers. SND.UNA
    points to the start of Transmit Category 2, SND.NXT points to the start of Transmit
    Category 3, and SND.WND is the size of the send window. The size of the usable
    window (the hatched rectangle) can be calculated as shown from those three pointers.")
    illustrates the SND pointers.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*可用窗口*，因为它表示发送器在任何时刻可以使用的字节数。当数据被确认时，这会导致字节从传输类别2移动到传输类别1，通过增加SND.UNA的值。假设发送窗口大小不变，这将导致窗口向右*滑动*，允许发送更多数据。[图48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "图48-4. TCP传输类别、发送窗口和指针 此图与第46章中的图46-6相同，但显示了TCP发送指针。SND.UNA指向传输类别2的开始，SND.NXT指向传输类别3的开始，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以通过这三个指针计算得出。")说明了SND指针。
- en: Tip
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The TCP sliding windows scheme uses three pointers that keep
    track of which bytes are in each of the four transmit categories. SND.UNA points
    to the first unacknowledged byte and indicates the start of Transmit Category
    2; SND.NXT points to the next byte of data to be sent and marks the start of Transmit
    Category 3\. SND.WND contains the size of the send window; it is added to SND.NXT
    to mark the start of Transmit Category 4\. Adding SND.WND to SND.UNA and then
    subtracting SND.NXT yields the current size of the usable transmit window.'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP滑动窗口方案使用三个指针来跟踪四个传输类别中的每个字节的传输情况。SND.UNA指向第一个未确认的字节，并指示传输类别2的开始；SND.NXT指向下一个要发送的数据字节，并标记传输类别3的开始。SND.WND包含发送窗口的大小；它被添加到SND.NXT上，以标记传输类别4的开始。将SND.WND添加到SND.UNA，然后减去SND.NXT，得到当前可用的传输窗口大小。'
- en: '![TCP transmission categories, send window, and pointers This diagram is the
    same as (in ), but shows the TCP send pointers. SND.UNA points to the start of
    Transmit Category 2, SND.NXT points to the start of Transmit Category 3, and SND.WND
    is the size of the send window. The size of the usable window (the hatched rectangle)
    can be calculated as shown from those three pointers.](httpatomoreillycomsourcenostarchimages288123.png.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
  zh: '![TCP传输类别、发送窗口和指针 此图与()相同，但显示了TCP发送指针。SND.UNA指向传输类别2的开始，SND.NXT指向传输类别3的开始，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以通过这三个指针计算得出。](httpatomoreillycomsourcenostarchimages288123.png.jpg)'
- en: Figure 48-4. TCP transmission categories, send window, and pointers This diagram
    is the same as [Figure 46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "Figure 46-6. TCP transmission stream categories and send window terminology This
    diagram shows the same categories as the ones in Figure 46-5, except that it shows
    the send window as well. The black box is the overall send window (categories
    2 and 3 combined); the light gray box represents the bytes already sent (category
    2), and the dark gray box is the usable window (category 3).") (in [Chapter 46](ch46.html
    "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION")),
    but shows the TCP send pointers. SND.UNA points to the start of Transmit Category
    2, SND.NXT points to the start of Transmit Category 3, and SND.WND is the size
    of the send window. The size of the usable window (the hatched rectangle) can
    be calculated as shown from those three pointers.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-4. TCP传输类别、发送窗口和指针 此图与[图46-6](ch46s02.html#tcp_transmission_stream_categories_and_s
    "图46-6. TCP传输流类别和发送窗口术语 此图显示了与图46-5相同的类别，但还显示了发送窗口。黑色方框是整体发送窗口（类别2和3的组合）；浅灰色方框表示已发送的字节（类别2），深灰色方框是可用窗口（类别3)。"）(在[第46章](ch46.html
    "第46章. 传输控制协议（TCP）基础和一般操作"))相同，但显示了TCP发送指针。SND.UNA指向传输类别2的开始，SND.NXT指向传输类别3的开始，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以通过这三个指针计算得出。
- en: 'The three receive categories are divided using two pointers:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 三种接收类别是通过两个指针来划分的：
- en: '**Receive Next (RCV.NXT)** The sequence number of the next byte of data that
    is expected from the other device. This marks the first byte in Receive Category
    3\. All previous sequence numbers refer to bytes already received and acknowledged,
    in Receive Categories 1 and 2.'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收下一个字节（RCV.NXT）** 从其他设备期望接收的下一个字节的序列号。这标志着接收类别3中的第一个字节。所有之前的序列号都指的是已接收并确认的字节，在接收类别1和2中。'
- en: '**Receive Window (RCV.WND)** The size of the receive window advertised to the
    other device. This refers to the number of bytes the device is willing to accept
    at one time from its peer, which is usually the size of the buffer allocated for
    receiving data for this connection. When added to the RCV.NXT pointer, this pointer
    marks the first byte of Receive Category 4.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收窗口（RCV.WND）** 向其他设备广告的接收窗口大小。这指的是设备一次愿意从其对等方接受的字节数，这通常是为接收此连接的数据分配的缓冲区大小。当与RCV.NXT指针相加时，此指针标记接收类别4的第一个字节。'
- en: The receive categories and pointers are illustrated in [Figure 48-5](ch48s04.html#tcp_receive_categories_and_pointers_this
    "Figure 48-5. TCP receive categories and pointers This diagram is the complement
    of Figure 48-4, showing how the categories are set up for the receiving device.
    Categories 1 and 2 have been combined since there is no differentiation between
    "received and unacknowledged" and "received and acknowledged." This example shows
    the state of the receiving device prior to receipt of the 14 bytes that in Figure 48-4
    have already been sent.").
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 接收类别和指针在[图48-5](ch48s04.html#tcp_receive_categories_and_pointers_this "图48-5.
    TCP接收类别和指针 此图是Figure 48-4的补充，展示了接收设备如何设置类别。类别1和2已合并，因为“已接收未确认”和“已接收已确认”之间没有区别。此示例显示了接收设备在收到14个字节之前的状态，这些字节已在Figure
    48-4中发送。")中说明。
- en: 'The SND and RCV pointers are complementary, just as the categories are, with
    each device managing both the sending of its data and receiving of data from its
    peer. Assuming we have a client and a server, the relationship between these pointers
    is as follows:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: SND和RCV指针是互补的，就像类别一样，每个设备都管理自己的数据发送和从对等方接收数据。假设我们有一个客户端和一个服务器，这些指针之间的关系如下：
- en: '**Client** The SND pointers keep track of the client''s outgoing data stream;
    the RCV pointers refer to the data coming in from the server. The client''s SND
    categories correspond to the server''s RCV categories.'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端** SND指针跟踪客户端的输出数据流；RCV指针指向从服务器传入的数据。客户端的SND类别对应于服务器的RCV类别。'
- en: '**Server** The SND pointers keep track of the server''s outgoing data stream;
    the RCV pointers refer to the data being received from the client. The server''s
    SND categories correspond to the client''s RCV categories.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器** SND指针跟踪服务器的输出数据流；RCV指针指向从客户端接收的数据。服务器的SND类别对应于客户端的RCV类别。'
- en: '![TCP receive categories and pointers This diagram is the complement of , showing
    how the categories are set up for the receiving device. Categories 1 and 2 have
    been combined since there is no differentiation between "received and unacknowledged"
    and "received and acknowledged." This example shows the state of the receiving
    device prior to receipt of the 14 bytes that in have already been sent.](httpatomoreillycomsourcenostarchimages288125.png.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![TCP接收类别和指针 此图是Figure 48-4的补充，展示了接收设备如何设置类别。类别1和2已合并，因为“已接收未确认”和“已接收已确认”之间没有区别。此示例显示了接收设备在收到14个字节之前的状态，这些字节已在Figure
    48-4中发送。](httpatomoreillycomsourcenostarchimages288125.png.jpg)'
- en: Figure 48-5. TCP receive categories and pointers This diagram is the complement
    of [Figure 48-4](ch48s04.html#tcp_transmission_categories_send_window_ "Figure 48-4. TCP
    transmission categories, send window, and pointers This diagram is the same as
    Figure 46-6 (in Chapter 46), but shows the TCP send pointers. SND.UNA points to
    the start of Transmit Category 2, SND.NXT points to the start of Transmit Category
    3, and SND.WND is the size of the send window. The size of the usable window (the
    hatched rectangle) can be calculated as shown from those three pointers."), showing
    how the categories are set up for the receiving device. Categories 1 and 2 have
    been combined since there is no differentiation between "received and unacknowledged"
    and "received and acknowledged." This example shows the state of the receiving
    device prior to receipt of the 14 bytes that in [Figure 48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "Figure 48-4. TCP transmission categories, send window, and pointers This diagram
    is the same as Figure 46-6 (in Chapter 46), but shows the TCP send pointers. SND.UNA
    points to the start of Transmit Category 2, SND.NXT points to the start of Transmit
    Category 3, and SND.WND is the size of the send window. The size of the usable
    window (the hatched rectangle) can be calculated as shown from those three pointers.")
    have already been sent.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-5. TCP接收类别和指针 此图是[图48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "图48-4. TCP传输类别、发送窗口和指针 此图与第46章的图46-6相同，但显示了TCP发送指针。SND.UNA指向传输类别2的起始位置，SND.NXT指向传输类别3的起始位置，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以通过这三个指针计算得出。"),展示了接收设备如何设置类别。由于“已接收未确认”和“已接收已确认”之间没有区别，因此类别1和2已经被合并。此示例显示了接收设备在收到[图48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "图48-4. TCP传输类别、发送窗口和指针 此图与第46章的图46-6相同，但显示了TCP发送指针。SND.UNA指向传输类别2的起始位置，SND.NXT指向传输类别3的起始位置，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以通过这三个指针计算得出。")中已发送的14个字节之前的状态。
- en: Tip
  id: totrans-902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A set of *receive (RCV) pointers* is maintained by each device.
    These receive pointers are the complement of the *send (SND) pointers*. A device''s
    send pointers keep track of its outgoing data, and its receive pointers keep track
    of the incoming data. The two receive pointers are RCV.NXT, which indicates the
    number of the next byte of data expected from the other device, and RCV.WND, which
    is the size of the receive window for that device. The RCV.WND of one device equals
    the SND.WND of the other device on the connection.'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个设备都维护一组*接收（RCV）指针*。这些接收指针是*发送（SND）指针*的补充。设备的发送指针跟踪其发出的数据，而接收指针跟踪接收到的数据。两个接收指针是RCV.NXT，它指示从另一设备期望的下一个字节的编号，以及RCV.WND，它是该设备的接收窗口大小。一个设备的RCV.WND等于连接的另一设备的SND.WND。'
- en: Since the SND and RCV values are complementary, the send window of one device
    is the receive window of the other, and vice versa. Note, however, that the values
    of the pointers do not always match exactly on the two devices, because at any
    given time, some bytes may be in transit between the two. [Figure 48-5](ch48s04.html#tcp_receive_categories_and_pointers_this
    "Figure 48-5. TCP receive categories and pointers This diagram is the complement
    of Figure 48-4, showing how the categories are set up for the receiving device.
    Categories 1 and 2 have been combined since there is no differentiation between
    "received and unacknowledged" and "received and acknowledged." This example shows
    the state of the receiving device prior to receipt of the 14 bytes that in Figure 48-4
    have already been sent."), for example, shows the receive pointers of the recipient
    *prior* to receiving bytes 32 to 45, which are shown in transit in [Figure 48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "Figure 48-4. TCP transmission categories, send window, and pointers This diagram
    is the same as Figure 46-6 (in Chapter 46), but shows the TCP send pointers. SND.UNA
    points to the start of Transmit Category 2, SND.NXT points to the start of Transmit
    Category 3, and SND.WND is the size of the send window. The size of the usable
    window (the hatched rectangle) can be calculated as shown from those three pointers.").
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SND和RCV值是互补的，一个设备的发送窗口是另一个设备的接收窗口，反之亦然。然而，需要注意的是，两个设备上的指针值并不总是完全匹配，因为在任何给定时间，一些字节可能正在两个设备之间传输。[图48-5](ch48s04.html#tcp_receive_categories_and_pointers_this
    "图48-5. TCP接收类别和指针 此图是图48-4的补充，显示了接收设备如何设置类别。类别1和2已合并，因为“已接收未确认”和“已接收已确认”之间没有区别。此示例显示了接收设备在接收到图48-4中已发送的14个字节之前的状态。"),例如，显示了接收者在接收到字节32到45之前的接收指针，这些字节在[图48-4](ch48s04.html#tcp_transmission_categories_send_window_
    "图48-4. TCP传输类别、发送窗口和指针 此图与第46章中的图46-6相同，但显示了TCP发送指针。SND.UNA指向传输类别2的开始，SND.NXT指向传输类别3的开始，SND.WND是发送窗口的大小。可用窗口的大小（阴影矩形）可以像从这三个指针中那样计算出来。"）中显示为正在传输。
- en: TCP Segment Fields Used to Exchange Pointer Information
  id: totrans-905
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于交换指针信息的TCP段字段
- en: 'Both SND and RCV pointers are maintained in the TCB for the connection held
    by each device. As data is exchanged, the pointers are updated, and information
    about the state of the send and receive streams is exchanged using control fields
    in the TCP segment format. The following are the three most important TCP segment
    fields used to exchange pointer information:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: SND和RCV指针都保存在每个设备持有的连接的TCB中。随着数据的交换，指针被更新，并且使用TCP段格式中的控制字段交换发送和接收流的状态信息。以下是最重要的三个用于交换指针信息的TCP段字段：
- en: '**Sequence Number** Identifies the sequence number of the first byte of data
    in the segment being transmitted. This will normally be equal to the value of
    the SND.UNA pointer at the time that data is sent.'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列号** 识别正在传输的段中数据第一个字节的序列号。这通常等于发送数据时SND.UNA指针的值。'
- en: '**Acknowledgment Number** Acknowledges the receipt of data by specifying the
    sequence number that the sender of the segment expects in the segment recipient''s
    next transmission. This field will normally be equal to the RCV.NXT pointer of
    the device that sends it.'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '**确认号** 通过指定发送方期望在段接收方的下一次传输中接收到的序列号来确认数据的接收。此字段通常等于发送该字段的设备的RCV.NXT指针。'
- en: '**Window** The size of the receive window of the device sending the segment
    (and thus, the send window of the device receiving the segment).'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口** 发送段设备的接收窗口大小（因此，接收段设备的发送窗口）。'
- en: The Acknowledgment Number field is critical because a device uses this field
    to tell its peer which segments it has received. The system is *cumulative*. The
    Acknowledgment Number field says, "I have received all data bytes with sequence
    numbers less than this value." This means if a client receives many segments of
    data from a server in rapid succession, it can acknowledge all of them using a
    single number, as long as they are contiguous. If they are not contiguous, then
    things get more complicated; see "TCP Noncontiguous Acknowledgment Handling and
    Selective Acknowledgment (SACK)" in [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY
    AND FLOW CONTROL FEATURES").
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 确认号字段至关重要，因为设备使用此字段来告知其对等方它已接收哪些段。系统是**累积的**。确认号字段表示，“我已经接收了所有序列号小于此值的字节数据。”这意味着如果客户端从服务器快速连续接收多个数据段，只要它们是连续的，它就可以使用一个单一的数字来确认所有这些段。如果它们不是连续的，那么事情会变得更加复杂；请参阅“第49章：TCP可靠性和流量控制特性”中的“TCP非连续确认处理和选择确认（SACK）”。
- en: Tip
  id: totrans-911
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Three essential fields in the TCP segment format are used to
    implement the sliding windows system. The Sequence Number field indicates the
    number of the first byte of data being transmitted. The Acknowledgment Number
    is used to acknowledge data received by the device sending this segment. The Window
    field tells the recipient of the segment the size to which it should set its send
    window.'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP段格式中的三个基本字段用于实现滑动窗口系统。序列号字段指示正在传输的数据的第一个字节的编号。确认号用于确认发送此段的设备接收到的数据。窗口字段告诉段接收方它应该将其发送窗口设置的大小。'
- en: An Example of TCP Sliding Window Mechanics
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP滑动窗口机制的示例
- en: To see how all of this works, let's consider an example of a client and server
    using a mythical file-retrieval protocol. This protocol specifies that the client
    sends a request and receives an immediate response from the server. The server
    then sends the file requested when it is ready.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这一切是如何工作的，让我们考虑一个客户端和服务器使用一个神话般的文件检索协议的示例。该协议指定客户端发送请求并立即从服务器接收响应。服务器在准备好后发送请求的文件。
- en: The two devices will first establish a connection and synchronize sequence numbers.
    For simplicity, let's say the client uses an ISN of 0, and the server uses an
    ISN of 240\. The server will send the client an ACK with an Acknowledgment Number
    of 1, indicating it is the sequence number it expects to receive next. Let's say
    the server's receive window size is set to 350, so this is the client's send window
    size. The client will send its ACK with an Acknowledgment Number of 241\. Let's
    say its receive window size is 200 (and the server's client window size is thus
    200). Let's assume that both devices maintain the same window size throughout
    the transaction. This won't normally happen, especially if the devices are busy,
    but the example is complicated enough. Let's also say the MSS is 536 bytes in
    both directions. This means that the MSS won't affect the size of actual segments
    in this example (since the MSS is larger than the send window sizes for both devices).
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 两个设备首先将建立连接并同步序列号。为了简化，让我们假设客户端使用ISN为0，而服务器使用ISN为240。服务器将向客户端发送一个带有确认号1的ACK，表示这是它期望接收的下一个序列号。假设服务器的接收窗口大小设置为350，因此这是客户端的发送窗口大小。客户端将发送其带有确认号241的ACK。假设其接收窗口大小为200（因此服务器的客户端窗口大小也是200）。假设在事务过程中，两个设备保持相同的窗口大小。这通常不会发生，尤其是如果设备很忙时，但示例已经足够复杂。假设在两个方向上MSS都是536字节。这意味着在这个示例中，MSS不会影响实际段的大小（因为MSS大于两个设备的发送窗口大小）。
- en: We'll follow a sample transaction to show how the send and receive pointers
    are created and changed as messages are exchanged between client and server. [Table 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "Table 48-6. TCP Transaction Example with Send and Receive Pointers") describes
    the process in detail, showing for each step what the send and receive pointers
    are for both devices. It is rather large, so beware. The transaction is also graphically
    illustrated in Figures [Figure 48-6](ch48s04.html#tcp_transaction_example_showing_the_serv
    "Figure 48-6. TCP transaction example showing the server's send pointers The transaction
    of Table 48-6 from the perspective of the server. See Figure 48-7 for the client's
    pointers.") and [Figure 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "Figure 48-7. TCP transaction example showing client's send pointers The transaction
    of Table 48-6 from the perspective of the client. See Figure 48-6 for the server's
    pointers."). Both illustrate the same exchange of messages, using the step numbers
    of [Table 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re "Table 48-6. TCP
    Transaction Example with Send and Receive Pointers"), but from the perspective
    of one of the devices. [Figure 48-6](ch48s04.html#tcp_transaction_example_showing_the_serv
    "Figure 48-6. TCP transaction example showing the server's send pointers The transaction
    of Table 48-6 from the perspective of the server. See Figure 48-7 for the client's
    pointers.") shows the server's send pointers and client's receive pointers. [Figure 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "Figure 48-7. TCP transaction example showing client's send pointers The transaction
    of Table 48-6 from the perspective of the client. See Figure 48-6 for the server's
    pointers.") shows the client's send pointers and server's receive pointers. (I
    would have put them all in one diagram, but they wouldn't fit!)
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个示例交易来展示客户端和服务器之间交换消息时，发送和接收指针是如何创建和变化的。[表 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "表 48-6. 带有发送和接收指针的 TCP 交易示例") 详细描述了该过程，展示了每一步中两个设备的发送和接收指针。它相当大，所以请注意。交易也以图形方式展示在图
    [图 48-6](ch48s04.html#tcp_transaction_example_showing_the_serv "图 48-6. 从服务器视角看带有发送指针的
    TCP 交易示例。图 48-7 展示客户端的指针。") 和 [图 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "图 48-7. 从客户端视角看带有发送指针的 TCP 交易示例。图 48-6 展示服务器的指针。") 中。两者都展示了相同的信息交换，使用 [表 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "表 48-6. 带有发送和接收指针的 TCP 交易示例") 的步骤编号，但从一个设备的视角来看。[图 48-6](ch48s04.html#tcp_transaction_example_showing_the_serv
    "图 48-6. 从服务器视角看带有发送指针的 TCP 交易示例。图 48-7 展示客户端的指针。") 展示了服务器的发送指针和客户端的接收指针。[图 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "图 48-7. 从客户端视角看带有发送指针的 TCP 交易示例。图 48-6 展示服务器的指针。") 展示了客户端的发送指针和服务器的接收指针。（我本想将它们全部放在一个图中，但它们放不下！）
- en: Table 48-6. TCP Transaction Example with Send and Receive Pointers
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 表 48-6. 带有发送和接收指针的 TCP 交易示例
- en: '|   |   |   |   |   |   |   |   |   |   | Client | Server |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端 | 服务器 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Process Step | SND.UNA | SND.NXT | SND.WND | RCV.NXT | RCV.WND | Process
    Step | SND.UNA | SND.NXT | SND.WND | RCV.NXT | RCV.WND |   |   |   |   |   |  
    |   |   |   |   |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| 处理步骤 | SND.UNA | SND.NXT | SND.WND | RCV.NXT | RCV.WND | 处理步骤 | SND.UNA |
    SND.NXT | SND.WND | RCV.NXT | RCV.WND |   |   |   |   |   |   |   |   |   |  
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '|   |   |   |   |   |   |   |   |   |   | Description | Description |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 描述 | 描述 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **(setup)** | 1 | 1 | 360 | 241 | 200 | **(setup)** | 241 | 241 | 200 | 1
    | 360 |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| **(设置)** | 1 | 1 | 360 | 241 | 200 | **(设置)** | 241 | 241 | 200 | 1 | 360
    |'
- en: '|   |   |   |   |   |   |   |   |   |   | During connection establishment,
    the client sets up its pointers based on the parameters exchanged during setup.
    Notice that the SND.UNA and SND.NXT values are the same. No data has been sent
    yet, so nothing is unacknowledged. RCV.NXT is the value of the first byte of data
    expected from the server. | The server sets up its pointers just as the client
    does. Notice how its values are the complement of the client''s. |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 在建立连接过程中，客户端根据设置期间交换的参数设置其指针。注意，SND.UNA和SND.NXT的值相同。尚未发送任何数据，因此没有未确认的数据。RCV.NXT是服务器期望接收的第一个字节的值。
    | 服务器像客户端一样设置其指针。注意，其值是客户端值的补数。|'
- en: '| **1\. Send Request** | 1 | 141 | 360 | 241 | 200 | **(wait)** | 241 | 241
    | 200 | 1 | 360 |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| **1. 发送请求** | 1 | 141 | 360 | 241 | 200 | **(等待)** | 241 | 241 | 200 | 1
    | 360 |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client transmits a request to
    the server. Let''s say the request is 140 bytes in length. It will form a segment
    with a data field of this length and transmit it with the Sequence Number set
    to 1, the sequence number of the first byte. Once this data has been sent, the
    client''s SND.NXT pointer will be incremented to the value 141 to indicate this
    is the next data to be sent to the server. | The server does nothing, waiting
    for a request. |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端向服务器发送一个请求。假设请求长度为140字节。它将形成一个具有该长度数据字段的数据段，并将序列号设置为1（第一个字节的序列号）来传输它。一旦发送了这些数据，客户端的SND.NXT指针将增加到141，以指示这是要发送给服务器的下一个数据。
    | 服务器不采取任何行动，等待请求。|'
- en: '| **(wait)** | 1 | 141 | 360 | 241 | 200 | **2\. Receive Request, Send Ack
    & Reply** | 241 | 321 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |
      |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| **(等待)** | 1 | 141 | 360 | 241 | 200 | **2. 接收请求，发送确认和回复** | 241 | 321 |
    200 | 141 | 360 |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | At this point, the client hasn''t
    received an acknowledgment for its request. At present, SND.UNA+SND.WND is 361,
    while SND.NXT is 141\. This means the current usable window is 220 bytes. The
    client could send up to 220 more bytes of data before getting back an acknowledgment.
    For now, let''s say it has nothing more to transmit. | The server receives the
    140-byte request from the client. The server sends back an 80-byte response that
    also acknowledges the client''s TCP segment. The Sequence Number field will be
    241, the first sequence number of the server''s 80 bytes of data. The Acknowledgment
    Number will be 141, telling the client that is the next sequence number the server
    expects to hear, and thereby implicitly acknowledging receipt of bytes 1 through
    140.The server increases its RCV.NXT pointer to 141 to reflect the 140 bytes of
    data received. It increases its SND.NXT pointer by 80. |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 此时，客户端尚未收到对其请求的确认。目前，SND.UNA+SND.WND的值为361，而SND.NXT的值为141。这意味着当前可用的窗口为220字节。客户端在收到确认之前可以发送多达220字节的更多数据。现在，假设它没有更多要传输的数据。
    | 服务器从客户端接收140字节的请求。服务器发送一个80字节的响应，该响应也确认了客户端的TCP段。序列号字段将为241，这是服务器80字节数据的第一个序列号。确认号将为141，告诉客户端这是服务器期望听到的下一个序列号，从而隐式确认接收了从第1个字节到第140个字节的数据。服务器将其RCV.NXT指针增加到141，以反映接收到的140字节的数据。它将其SND.NXT指针增加80。|'
- en: '| **3\. Receive Ack & Reply, Send Ack** | 141 | 141 | 360 | 321 | 200 | **4\.
    Send Part 1 of File** | 241 | 441 | 200 | 141 | 360 |   |   |   |   |   |   |
      |   |   |   |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| **3. 接收确认和回复，发送确认** | 141 | 141 | 360 | 321 | 200 | **4. 发送文件的第一部分** | 241
    | 441 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client receives the server''s
    response. It sees the Acknowledgment Number of 141 and knows bytes 1 to 140 were
    successfully received. It increases its SND.UNA to 141, effectively "sliding the
    send window" by 140.The client also accepts the 80 bytes of data the server sent,
    increasing its RCV.NXT pointer by 80\. Assuming it has no more data to send, it
    sends back a TCP segment that is a pure acknowledgment of the server''s response.
    This segment has no data and an Acknowledgment Number value of 321. | While the
    client was receiving its response, the server''s TCP was supplied with a 280-byte
    file to be sent to the client. It cannot send all this in one segment, however.
    The current value of SND.UNA+SND.WND is 441, while SND.NXT is 321\. Thus, the
    server''s usable window contains 120 bytes of data. It creates a TCP segment with
    this much data and a Sequence Number of 321\. It increases the SND.NXT pointer
    to 441\. The server has now filled the send window.Note that the server does not
    need to wait for an acknowledgment to the reply it sent in step 2\. This is a
    key factor in TCP''s ability to ensure high throughput. |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端接收到了服务器的响应。它看到确认号为141，知道字节1到140已被成功接收。它将SND.UNA增加到141，实际上是通过滑动发送窗口140个字节。客户端还接受了服务器发送的80字节数据，将RCV.NXT指针增加80。假设它没有更多数据要发送，它发送了一个纯确认的TCP段，以确认服务器的响应。这个段没有数据，确认号值为321。
    | 当客户端接收其响应时，服务器的TCP被提供了一个280字节的文件要发送给客户端。然而，它不能在一个段中发送所有这些。当前SND.UNA+SND.WND的值为441，而SND.NXT为321。因此，服务器的可用窗口包含120字节数据。它创建了一个包含这么多数据和序列号321的TCP段。它将SND.NXT指针增加到441。现在服务器已经填满了发送窗口。请注意，服务器不需要等待对步骤2中发送的回复的确认。这是TCP确保高吞吐量的关键因素之一。
    |'
- en: '| **5\. Receive Part 1 of File, Send Ack** | 141 | 141 | 360 | 441 | 200 |
    **6\. Receive Ack for Reply** | 321 | 441 | 200 | 141 | 360 |   |   |   |   |
      |   |   |   |   |   |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| **5. 接收文件第一部分，发送确认** | 141 | 141 | 360 | 441 | 200 | **6. 接收回复的确认** | 321
    | 441 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client receives the first 120-byte
    part of the file the server was sending. It increases the RCV.NXT pointer to 441
    and sends an acknowledgment back with an Acknowledgment Number of 441\. Again,
    if it had another request to make of the server, it could include it here, but
    we''ll assume it does not. | The server receives the client''s acknowledgment
    of its earlier 80-byte response (sent in step 2). It increases its SND.UNA to
    321\. Since it just received acknowledgment of 80 bytes (and the client''s window
    didn''t change), the server''s usable window is now 80 bytes. However, as we will
    see in [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES"),
    sending small segments like this can lead to performance issues. Let''s say the
    server has been programmed to not send segments under 100 bytes when it has a
    lot of data to transmit. It decides to wait. |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端接收到了服务器发送的文件的前120字节部分。它将RCV.NXT指针增加到441，并带着确认号441发送了一个确认。再次，如果它有其他对服务器的请求，它也可以在这里包含，但我们假设它没有。
    | 服务器接收到了客户端对其先前80字节响应的确认（在步骤2中发送）。它将SND.UNA增加到321。由于它刚刚收到了80字节的确认（并且客户端的窗口没有改变），服务器的可用窗口现在是80字节。然而，正如我们将在[第49章](ch49.html
    "第49章。TCP可靠性及流量控制特性")中看到的，发送这样小的段可能会引起性能问题。假设服务器被编程为在有很多数据要传输时不会发送小于100字节的段。它决定等待。
    |'
- en: '| **(wait)** | 141 | 141 | 360 | 441 | 200 | **7\. Receive Ack for Part 1 of
    File** | 441 | 441 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: '| **(等待**) | 141 | 141 | 360 | 441 | 200 | **7. 接收文件第一部分的确认** | 441 | 441 |
    200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client waits for the rest of
    the file. | The server receives the acknowledgment for the first part of the file.
    It increases SND.UNA to 441\. This now restores the full 200-byte window. |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端等待文件的其余部分。 | 服务器接收到了文件第一部分的确认。它将SND.UNA增加到441。这现在恢复了完整的200字节窗口。
    |'
- en: '| **(still waiting?)** | 141 | 141 | 360 | 441 | 200 | **8\. Send Part 2 of
    File** | 441 | 601 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: '| **(仍在等待？**) | 141 | 141 | 360 | 441 | 200 | **8. 发送文件第二部分** | 441 | 601 |
    200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client continues to wait for
    the rest of the file. | The server sends the remaining 160 bytes of data in the
    file in one segment. It increases SND.NXT by 160, and sends the data with a Sequence
    Number value of 441. |'
  id: totrans-937
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端继续等待文件的其余部分。 | 服务器将文件中剩余的160字节数据在一个段中发送。它将SND.NXT增加160，并使用序列号值为441的数据发送。
    |'
- en: '| **9\. Receive Part 2 of File, Send Ack** | 141 | 141 | 360 | 601 | 200 |
    **(wait)** | 441 | 601 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |
      |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| **9. 接收文件第二部分，发送确认** | 141 | 141 | 360 | 601 | 200 | **(等待)** | 441 | 601
    | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client receives the rest of the
    file and acknowledges it. It increases RCV.NXT to 601 and sends back a segment
    with an Acknowledgment Number of 601. | The server is done for now. It waits for
    the acknowledgment of the second part of the file. |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端收到文件的其余部分并确认它。它将RCV.NXT增加到601，并发送一个确认号为601的段。
    | 服务器目前完成。它等待文件第二部分的确认。 |'
- en: '| **(done)** | 141 | 141 | 360 | 601 | 200 | **10\. Receive Ack for Part 2
    of File** | 601 | 601 | 200 | 141 | 360 |   |   |   |   |   |   |   |   |   |
      |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| **(完成)** | 141 | 141 | 360 | 601 | 200 | **10. 接收文件第二部分确认** | 601 | 601 |
    200 | 141 | 360 |   |   |   |   |   |   |   |   |   |   |'
- en: '|   |   |   |   |   |   |   |   |   |   | The client is done with this exchange.
    | The server receives the second acknowledgment and slides its send window forward
    by 160 bytes. The transaction is now completed. |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |   |   |   |   |   |   |   | 客户端完成这次交换。 | 服务器收到第二个确认，并将发送窗口向前滑动160字节。事务现在完成。
    |'
- en: '![TCP transaction example showing the server''s send pointers The transaction
    of from the perspective of the server. See for the client''s pointers.](httpatomoreillycomsourcenostarchimages288127.png.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![TCP事务示例，展示服务器的发送指针。从服务器的视角看事务。查看客户端的指针。](httpatomoreillycomsourcenostarchimages288127.png.jpg)'
- en: Figure 48-6. TCP transaction example showing the server's send pointers The
    transaction of [Table 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "Table 48-6. TCP Transaction Example with Send and Receive Pointers") from the
    perspective of the server. See [Figure 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "Figure 48-7. TCP transaction example showing client's send pointers The transaction
    of Table 48-6 from the perspective of the client. See Figure 48-6 for the server's
    pointers.") for the client's pointers.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-6. TCP事务示例，展示服务器的发送指针。从服务器的视角看[表48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "表48-6. TCP事务示例，包含发送和接收指针")的事务。查看[图48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "图48-7. TCP事务示例，展示客户端的发送指针。从客户端的视角看表48-6的事务。查看图48-6以查看服务器的指针")以查看客户端的指针。
- en: '![TCP transaction example showing client''s send pointers The transaction of
    from the perspective of the client. See for the server''s pointers.](httpatomoreillycomsourcenostarchimages288129.png.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![TCP事务示例，展示客户端的发送指针。从客户端的视角看事务。查看服务器的指针。](httpatomoreillycomsourcenostarchimages288129.png.jpg)'
- en: Figure 48-7. TCP transaction example showing client's send pointers The transaction
    of [Table 48-6](ch48s04.html#tcp_transaction_example_with_send_and_re "Table 48-6. TCP
    Transaction Example with Send and Receive Pointers") from the perspective of the
    client. See [Figure 48-6](ch48s04.html#tcp_transaction_example_showing_the_serv
    "Figure 48-6. TCP transaction example showing the server's send pointers The transaction
    of Table 48-6 from the perspective of the server. See Figure 48-7 for the client's
    pointers.") for the server's pointers.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 图48-7. TCP事务示例，展示客户端的发送指针。从客户端的视角看[表48-6](ch48s04.html#tcp_transaction_example_with_send_and_re
    "表48-6. TCP事务示例，包含发送和接收指针")的事务。查看[图48-6](ch48s04.html#tcp_transaction_example_showing_the_serv
    "图48-6. TCP事务示例，展示服务器的发送指针。从服务器的视角看表48-6的事务。查看图48-7以查看客户端的指针")以查看服务器的指针。
- en: Real-World Complications of the Sliding Window Mechanism
  id: totrans-946
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动窗口机制的实际情况复杂性
- en: 'I''m sure the process outlined in the previous section seems rather complicated,
    but in fact, the example is highly *simplified*, to show you how the basic data
    transfer mechanism works without too much going on. Scary, isn''t it? A real-world
    connection would include several complications:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信前一部分概述的过程看起来相当复杂，但实际上，示例被高度**简化**，以向您展示基本数据传输机制是如何在没有太多干扰的情况下工作的。可怕，不是吗？现实世界的连接将包括几个复杂性：
- en: '**Overlapping Transmissions** I intentionally showed only one request from
    the client and the response from the server. In reality, the client and server
    could be pumping many requests and responses at each other in rapid-fire succession.
    The client would be acknowledging segments received from the server with segments
    that themselves contained new requests, and so on.'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**重叠传输** 我故意只展示了客户端的一个请求和服务器的一个响应。在现实中，客户端和服务器可能会以快速连续的方式互相发送许多请求和响应。客户端会通过包含新请求的段来确认从服务器接收到的段，依此类推。'
- en: '**Acknowledgment of Multiple Segments** I also didn''t show a case where two
    segments are received by a device and acknowledged with a single acknowledgment,
    although this can certainly happen. Suppose that, in the example, the two parts
    of the 280-byte file were sent at once and received by the client at the same
    time. The client would acknowledge both by sending a single segment with an Acknowledgment
    Number of 601\. Remember that this field is a *cumulative* acknowledgment of all
    segments containing data through the number preceding it, so this would acknowledge
    all data up to byte 600.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个段的确认** 我也没有展示一个案例，其中两个段被设备接收并使用单个确认进行确认，尽管这确实可能发生。假设在示例中，280字节的文件的两个部分同时发送并被客户端同时接收。客户端将通过发送一个带有确认号601的单个段来确认这两个部分。请记住，这个字段是所有包含数据的段的*累积*确认，通过它前面的数字来表示，因此这将确认所有数据直到字节600。'
- en: '**Fluctuating Window Sizes for Flow Control** The window sizes in the example
    remained constant, but in a real connection, this will not always be the case.
    A very busy server may not be able to process and remove data from its buffer
    as fast as it acknowledges it. It may need to shrink its receive window to reduce
    the amount of data the client sends it, and then increase the window when more
    space becomes available. This is how TCP implements flow control, as you will
    see in the next chapter.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '**流量控制中的波动窗口大小** 示例中的窗口大小保持不变，但在实际连接中，情况并不总是如此。一个非常繁忙的服务器可能无法像确认那样快速处理和从其缓冲区中移除数据。它可能需要缩小接收窗口以减少发送给客户端的数据量，然后在有更多空间可用时增加窗口。这就是TCP实现流量控制的方式，您将在下一章中看到。'
- en: '**Lost Transmissions** In a real connection, some transmitted segments will
    be lost and need to be retransmitted. This is handled by TCP''s retransmission
    scheme (described in [Chapter 49](ch49.html "Chapter 49. TCP RELIABILITY AND FLOW
    CONTROL FEATURES")).'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '**丢失的传输** 在实际连接中，一些传输的段会丢失并需要重传。这由TCP的重传方案（在[第49章](ch49.html "第49章。TCP可靠性和流量控制特性")中描述）处理。'
- en: '**Avoiding Small Window Problems** I hinted in the description of the example
    that we don''t necessarily always want to send data as fast as we can, to avoid
    sending a very small segment. The reason is that this can lead to performance
    degradation, including a phenomenon called *silly window syndrome*. This will
    also be explored in the next chapter, where we will see how handling it requires
    that we change the simple sliding windows scheme we examined so far.'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免小窗口问题** 在示例的描述中，我暗示我们并不总是想尽可能快地发送数据，以避免发送一个非常小的段。原因是这可能导致性能下降，包括称为*愚蠢窗口综合征*的现象。这将在下一章中探讨，我们将看到如何处理它需要我们改变迄今为止所检查的简单滑动窗口方案。'
- en: '**Congestion Handling and Avoidance** The basic sliding window mechanism has
    been changed over the years to avoid having TCP connections cause internetwork
    congestion and to have them handle congestion when it is detected. Congestion
    issues are discussed, as you may have guessed, in the next chapter.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '**拥塞处理和避免** 基本的滑动窗口机制在多年中已经改变，以避免TCP连接引起互联网拥塞，并在检测到拥塞时处理拥塞。正如您可能猜到的，拥塞问题将在下一章中讨论。'
- en: 'TCP Immediate Data Transfer: Push Function'
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP立即数据传输：推送功能
- en: The fact that TCP takes incoming data from a process as an unstructured stream
    of bytes gives it great flexibility in meeting the needs of most applications.
    There is no need for an application to create blocks or messages; it just sends
    the data to TCP when it is ready for transmission. For its part, TCP has no knowledge
    or interest in the meaning of the bytes of data in this stream. They are just
    bytes, and TCP sends them without any real concern for their structure or purpose.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: TCP将来自进程的传入数据视为一个无结构的字节流，这使得它在满足大多数应用程序的需求方面具有很大的灵活性。应用程序不需要创建块或消息；它只需在准备传输时将数据发送到TCP。至于TCP，它对数据流中字节的含义没有任何了解或兴趣。它们只是字节，TCP发送它们时并不真正关心它们的结构或目的。
- en: This has a couple of interesting effects on how applications work. One is that
    TCP does not provide any natural indication of the dividing point between pieces
    of data, such as database records or files. The application must take care of
    this. Another result of TCP's byte orientation is that TCP cannot decide when
    to form a segment and send bytes between devices based on the contents of the
    data. TCP will generally accumulate data sent to it by an application process
    in a buffer. It chooses when and how to send data based solely on the sliding
    window system discussed in the previous section, in combination with logic that
    helps to ensure efficient operation of the protocol.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应用程序的工作方式有几个有趣的影响。一个是TCP不提供任何关于数据分界点的自然指示，例如数据库记录或文件。应用程序必须负责这一点。TCP字节导向的另一个结果是，TCP不能根据数据的内文来决定何时形成段并将在设备之间发送的字节。TCP通常会在缓冲区中累积应用程序进程发送给它的数据。它选择何时以及如何发送数据，完全基于前一小节讨论的滑动窗口系统，并结合帮助确保协议高效运行的逻辑。
- en: This means that while an application can control the rate and timing with which
    it sends data to TCP, it cannot inherently control the timing with which TCP itself
    sends the data over the internetwork. Now, if we are sending a large file, for
    example, this isn't a big problem. As long as we keep sending data, TCP will keep
    forwarding it over the internetwork. It's generally fine in such a case to let
    TCP fill its internal transmit buffer with data and form a segment to be sent
    when TCP feels it is appropriate.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然应用程序可以控制向TCP发送数据的速率和时机，但它不能本质上控制TCP本身在互联网上发送数据的时机。现在，如果我们发送一个大型文件，例如，这并不是一个大问题。只要我们继续发送数据，TCP就会继续在互联网上转发它。在这种情况下，让TCP用数据填满其内部传输缓冲区并形成发送的段通常是没问题的。
- en: However, there are situations where letting TCP accumulate data before transmitting
    it can cause serious application problems. The classic example of this is an interactive
    application such as the Telnet protocol (see [Chapter 87](ch87.html "Chapter 87. TCP/IP
    INTERACTIVE AND REMOTE APPLICATION PROTOCOLS")). When you are using such a program,
    you want each keystroke to be sent immediately to the other application; you don't
    want TCP to accumulate hundreds of keystrokes and then send them all at once.
    The latter may be more efficient, but it makes the application unusable, which
    is really putting the cart before the horse.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，让TCP在传输之前累积数据可能会引起严重的问题。这个经典的例子是交互式应用程序，如Telnet协议（见[第87章](ch87.html
    "第87章。TCP/IP交互式和远程应用程序协议"））。当你使用这样的程序时，你希望每个按键立即发送到另一个应用程序；你不想让TCP累积数百个按键然后一次性发送。后者可能更有效率，但它使得应用程序无法使用，这实际上是本末倒置。
- en: Even with a more mundane protocol that transfers files, there are many situations
    in which we need to say, "Send the data *now*." For example, many protocols begin
    with a client sending a request to a server—like the hypothetical one in the preceding
    example or a request for a web page sent by a web browser. In that case, we want
    the client's request sent immediately; we don't want to wait until enough requests
    have been accumulated by TCP to fill an optimal-sized segment.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是传输文件的更平凡的协议，也有许多情况下我们需要说，“现在就发送数据*。”例如，许多协议以客户端向服务器发送请求开始——就像前面例子中的假设请求或网络浏览器发送的网页请求。在这种情况下，我们希望客户端的请求立即发送；我们不想等到TCP累积了足够多的请求来填充一个最优大小的段。
- en: Naturally, the designers of TCP realized that we needed a way to handle these
    situations. When an application has data that it needs to have sent across the
    internetwork immediately, it sends the data to TCP, and then uses the TCP *push*
    function. This tells the sending TCP to immediately "push" all the data it has
    to the recipient's TCP as soon as it is able to do so, without waiting for more
    data.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，TCP的设计者意识到我们需要一种方法来处理这些情况。当一个应用程序需要立即将数据发送到互联网中时，它会将数据发送到TCP，然后使用TCP *push*
    功能。这告诉发送端的TCP立即“push”所有它有的数据到接收端的TCP，而无需等待更多数据。
- en: When this function is invoked, TCP will create a segment (or segments) that
    contains all the data it has outstanding and then transmit it with the PSH control
    bit set to 1\. The destination device's TCP software, seeing this bit sent, will
    know that it should not just take the data in the segment it received and buffer
    it, but rather push it through directly to the application.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个功能被调用时，TCP将创建一个（或多个）包含所有未发送数据的段，并设置PSH控制位为1来传输它。目标设备的TCP软件看到这个位被发送，将知道它不应该只是接收段中的数据并将其缓冲，而应该直接将其推送到应用程序。
- en: Tip
  id: totrans-962
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP includes a special *push* function to handle cases where
    data given to TCP needs to be sent immediately. An application can send data to
    its TCP software and indicate that it should be pushed. The segment will be sent
    right away rather than being buffered. The pushed segment''s PSH control bit will
    be set to 1 to tell the receiving TCP that it should immediately pass the data
    up to the receiving application.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP包含一个特殊的 *push* 功能来处理数据需要立即发送给TCP的情况。应用程序可以将数据发送到其TCP软件，并指示它应该被推送。该段将立即发送，而不是被缓冲。推送段的PSH控制位将被设置为1，以告知接收端的TCP它应该立即将数据传递给接收应用程序。'
- en: It's important to realize that the push function only forces immediate delivery
    of data. It does not change the fact that TCP provides no boundaries between data
    elements. It may seem that an application could send one record of data and then
    push it to the recipient, then send the second record and push that, and so on.
    However, the application cannot assume that because it sets the PSH bit for each
    piece of data it gives to TCP, each piece of data will be in a single segment.
    It is possible that the first push may contain data given to TCP earlier that
    wasn't yet transmitted, and it's also possible that two records pushed in this
    manner may end up in the same segment anyway.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，push功能只强制立即交付数据。它并没有改变TCP提供的数据元素之间没有边界的事实。看起来应用程序可以发送一条数据记录并将其推送到接收者，然后发送第二条记录并推送，依此类推。然而，应用程序不能假设因为它为给TCP的每一份数据设置了PSH位，每一份数据都会在单个段中。可能第一次推送可能包含之前给TCP但尚未传输的数据，而且也有可能以这种方式推送的两条记录最终会出现在同一个段中。
- en: 'TCP Priority Data Transfer: Urgent Function'
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP优先级数据传输：紧急功能
- en: As noted earlier, the fact that TCP treats data to be transmitted as just an
    unstructured stream of bytes has some important implications on how it used. One
    aspect of this characteristic is that since TCP doesn't understand the content
    of the data it sends, it normally treats all the data bytes in a stream as *equals*.
    The data is sent to TCP in a particular sequence, and it is transmitted in that
    same order. This makes TCP, in this regard, like those annoying voice mail systems
    that tell you not to hang up because they will answer calls in the order received.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TCP将待传输的数据视为无结构的字节流，这对其使用有一些重要的含义。这一特性的一个方面是，由于TCP不了解它发送的数据内容，它通常将流中的所有数据字节视为
    *相等*。数据以特定的顺序发送到TCP，并以相同的顺序传输。这使得TCP在这方面类似于那些烦人的语音邮件系统，它们告诉你不要挂断电话，因为它们会按照接收的顺序回电。
- en: Of course, while waiting on hold is irritating, this *first-in, first-out* behavior
    is usually how we want TCP to operate. If we are transmitting a message or a file,
    we want to be able to give TCP the bytes that compose that file and have TCP transmit
    that data in the order we gave it. However, just as special circumstances can
    require the use of the push function described in the previous section, there
    are cases where we may not want to always send all data in the exact sequence
    it was given to TCP.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，等待时感到烦躁是正常的，但这种**先进先出**的行为通常是我们要TCP操作的方式。如果我们正在传输消息或文件，我们希望能够给TCP提供组成该文件的字节，并让TCP按我们给出的顺序传输这些数据。然而，就像特殊情况下可能需要使用上一节中描述的推送功能一样，也有可能我们不想总是按给TCP的数据顺序发送所有数据。
- en: The most common example of this is when it is necessary to interrupt an application's
    data transfer. Suppose we have an application that sends large files in both directions
    between two devices. The user of the application realizes that the wrong file
    is being transferred. When she tells the application to stop the file being sent,
    she wants this to be communicated to the other end of the TCP connection immediately.
    She doesn't want the abort command to just be placed at the end of the line after
    the file she is trying to send!
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子是在需要中断应用程序的数据传输时。假设我们有一个在两个设备之间双向发送大文件的应用程序。应用程序的用户意识到正在传输错误的文件。当她告诉应用程序停止发送文件时，她希望这个信息能立即传达给TCP连接的另一端。她不希望中止命令只是放在她试图发送的文件之后的行尾！
- en: TCP provides a means for a process to prioritize the sending of data in the
    form of its *urgent* function. To use it, the process that needs to send urgent
    data enables the function and sends the urgent data to its TCP layer. TCP then
    creates a special TCP segment that has the URG control bit set to 1\. It also
    sets the Urgent Pointer field to an offset value that points to the last byte
    of urgent data in the segment. So, for example, if the segment contained 400 bytes
    of urgent data followed by 200 bytes of regular data, the URG bit would be set,
    and the Urgent Pointer field would have a value of 400.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: TCP提供了一种方式，允许进程以其**紧急**功能的形式优先发送数据。要使用它，需要发送紧急数据的进程启用该功能，并将紧急数据发送到其TCP层。然后，TCP创建一个特殊的TCP段，将URG控制位设置为1。它还将紧急指针字段设置为指向段中紧急数据最后一个字节的偏移量。例如，如果段包含400字节紧急数据，然后是200字节常规数据，URG位将被设置，紧急指针字段的值将是400。
- en: Upon receipt of a segment with the URG flag set to 1, the receiving device looks
    at the Urgent Pointer and from its value determines which data in the segment
    is urgent. It then forwards the urgent data to the process with an indication
    that the data is marked as urgent by the sender. The rest of the data in the segment
    is processed normally.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到一个URG标志设置为1的段时，接收设备会查看紧急指针，并从其值确定段中哪些数据是紧急的。然后，它会将紧急数据转发给进程，并指示发送者已将数据标记为紧急。段中的其余数据将按正常方式处理。
- en: Tip
  id: totrans-971
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To deal with situations where a certain part of a data stream
    needs to be sent with a higher priority than the rest, TCP incorporates an *urgent*
    function. When critical data needs to be sent, the application signals this to
    its TCP layer, which transmits it with the URG bit set in the TCP segment, bypassing
    any lower-priority data that may have already been queued for transmission.'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了处理需要以比其余部分更高的优先级发送数据流中某个部分的情况，TCP集成了**紧急**功能。当需要发送关键数据时，应用程序将其信号发送到其TCP层，该层将其以URG位设置为1的TCP段的形式传输，绕过可能已经排队等待传输的任何低优先级数据。'
- en: Since we typically want to send urgent data, well, urgently, it makes sense
    that when such data is given to TCP, the push function is usually also invoked.
    This ensures that the urgent data is sent as soon as possible by the transmitting
    TCP and also forwarded up the protocol stack right away by the receiving TCP.
    Again, we need to remember that this does not guarantee the contents of the urgent
    segment. Using the push function may mean the segment contains only urgent data
    with no regular data following, but again, an application cannot assume that this
    will always be the case.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通常希望紧急数据能够尽快发送，因此当这种数据被提供给TCP时，通常也会调用推送功能。这确保了发送TCP能够尽快发送紧急数据，并且接收TCP也会立即将其向上转发到协议栈。再次提醒，这并不保证紧急段的内容。使用推送功能可能意味着段只包含紧急数据而没有后续的常规数据，但应用程序也不能假设这总是这种情况。
- en: Chapter 49. TCP RELIABILITY AND FLOW CONTROL FEATURES
  id: totrans-974
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第49章。TCP可靠性和流量控制功能
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'The main task of the Transmission Control Protocol (TCP) is simple: packaging
    and sending data. Of course, almost every protocol packages and sends data! What
    distinguishes TCP from these protocols is the sliding window mechanism we explored
    in the previous chapter, which controls the flow of data between devices. This
    system not only manages the basic data transfer process, but it also ensures that
    data is sent reliably and manages the flow of data between devices to transfer
    data efficiently, without either device sending data faster than the other can
    receive it.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 传输控制协议（TCP）的主要任务很简单：打包和发送数据。当然，几乎每个协议都会打包和发送数据！区分TCP与其他协议的是我们在上一章中探讨的滑动窗口机制，该机制控制设备之间的数据流。这个系统不仅管理基本的数据传输过程，而且还确保数据可靠地发送，并管理设备之间的数据流，以有效地传输数据，避免任何设备发送数据速度超过另一个设备接收速度的情况。
- en: To enable TCP to provide the features and quality of data transfer that applications
    require, the protocol needed to be enhanced beyond the simplified data transfer
    mechanism we saw in preceding chapters. The developers needed to give extra "smarts"
    to the protocol to handle potential problems and make changes to the basic way
    that devices send data, to avoid inefficiencies that might otherwise have resulted.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使TCP能够提供应用程序所需的功能和数据传输质量，该协议需要在前面章节中看到的简化数据传输机制之外进行增强。开发者需要给协议添加额外的“智能”来处理潜在的问题，并改变设备发送数据的基本方式，以避免可能产生的低效。
- en: In this chapter, I describe how TCP ensures that devices on a TCP connection
    communicate in a reliable and efficient manner. I begin with an explanation of
    the basic method by which TCP detects lost segments and retransmits them. I discuss
    some of the issues associated with TCP's acknowledgment scheme and an optional
    feature for improving its efficiency. I then describe the system by which TCP
    adjusts how long it will wait before deciding that a segment is lost. I discuss
    how the window size can be adjusted to implement flow control and some of the
    issues involved in window size management. This includes a look at the infamous
    "silly window syndrome" problem and special heuristics for addressing issues related
    to small window size that modify the basic sliding windows scheme. I conclude
    with a discussion of TCP's mechanisms for handling and avoiding congestion.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了TCP如何确保TCP连接上的设备以可靠和高效的方式进行通信。我首先解释了TCP检测丢失段并重新传输它们的基本方法。我讨论了与TCP确认方案相关的一些问题以及一个可选功能，以提高其效率。然后，我描述了TCP通过调整它决定一个段丢失之前将等待多长时间的系统。我讨论了如何调整窗口大小以实现流量控制以及窗口大小管理中的一些问题。这包括对臭名昭著的“愚蠢窗口综合症”问题的分析，以及针对与窗口大小相关的问题的特殊启发式方法，这些方法修改了基本的滑动窗口方案。最后，我讨论了TCP处理和避免拥塞的机制。
- en: Tip
  id: totrans-979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** This section assumes that you are already familiar
    with TCP sequence numbers and segments, and the basics of the TCP sliding window
    mechanism. It also assumes you have already read the section on TCP message formatting
    and data transfer. If not, you may want to review at least the section about TCP
    data transfer mechanics in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING
    AND DATA TRANSFER"). Several of the sections in this chapter extend that simplified
    discussion of TCP data transfer to show what happens in nonideal conditions.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** 本节假设您已经熟悉TCP序列号和段，以及TCP滑动窗口机制的基本知识。它还假设您已经阅读了关于TCP消息格式和数据传输的章节。如果没有，您可能需要至少回顾[第48章](ch48.html
    "第48章。TCP消息格式和数据传输")中关于TCP数据传输机制的章节。本章中的几个部分将扩展对TCP数据传输的简化讨论，以展示在非理想条件下的情况。'
- en: TCP Segment Retransmission Timers and the Retransmission Queue
  id: totrans-981
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP段重传计时器和重传队列
- en: TCP's basic data transfer and acknowledgment mechanism uses a set of variables
    maintained by each device to implement the sliding window system. These pointers
    keep track of the bytes of data sent and received by each device, as well as differentiating
    between acknowledged and unacknowledged transmissions. In the preceding chapter,
    I described this mechanism and gave a simplified example showing how a client
    and server use it for basic data transfer.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的基本数据传输和确认机制使用每个设备维护的一组变量来实现滑动窗口系统。这些指针跟踪每个设备发送和接收的字节数据，以及区分已确认和未确认的传输。在前一章中，我描述了这种机制，并给出了一个简化的示例，展示了客户端和服务器如何使用它进行基本数据传输。
- en: One of the reasons why that example is simplified is that every segment that
    was transmitted by the server was received by the client and vice versa. It would
    be nice if we could always count on this happening, but as we know, in an Internet
    environment, this is not realistic. Due to any number of conditions—such as hardware
    failure, corruption of an Internet Protocol (IP) datagram, or router congestion—a
    TCP segment may be sent but never received. To qualify as a reliable transport
    protocol, TCP must be able detect lost segments and *retransmit* them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 那个示例之所以简化，是因为服务器发送的每个数据段都被客户端接收，反之亦然。如果我们可以始终依赖这种情况发生，那将是很好的，但正如我们所知，在互联网环境中，这是不现实的。由于各种条件——如硬件故障、互联网协议（IP）数据报损坏或路由器拥塞——TCP数据段可能被发送但从未被接收。为了成为可靠的传输协议，TCP必须能够检测丢失的数据段并*重新传输*它们。
- en: Managing Retransmissions Using the Retransmission Queue
  id: totrans-984
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重传队列管理重传
- en: The method for detecting lost segments and retransmitting them is conceptually
    simple. Each time we send a segment, we start a *retransmission timer*. This timer
    starts at a predetermined value and counts down over time. If the timer expires
    before an acknowledgment is received for the segment, we retransmit the segment.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 检测丢失的数据段并重新传输的方法在概念上是简单的。每次发送数据段时，我们都会启动一个*重传计时器*。这个计时器从预定的值开始，随着时间的推移而递减。如果在收到数据段的确认之前计时器到期，我们将重新传输该数据段。
- en: TCP uses this basic technique, but implements it in a slightly different way.
    The reason for this is the need to efficiently deal with many segments that may
    be unacknowledged at once, to ensure that they are each retransmitted at the appropriate
    time if needed. The TCP system works according to the following specific sequence.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: TCP使用这种基本技术，但以略微不同的方式实现。这样做的原因是需要有效地处理可能同时未确认的多个数据段，以确保在需要时它们各自在适当的时间重新传输。TCP系统按照以下特定顺序工作。
- en: '**Placement on Retransmission Queue, Timer Start** As soon as a segment containing
    data is transmitted, a copy of the segment is placed in a data structure called
    the *retransmission queue*. A retransmission timer is started for the segment
    when it is placed on the queue. Thus, at some point, *every* segment is placed
    in this queue. The queue is kept sorted by the time remaining in the retransmission
    timer, so the TCP software can keep track of which timers have the least time
    remaining before they expire.'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**放置在重传队列中，计时器启动** 一旦传输包含数据的数据段，该数据段的副本就被放置在一个称为*重传队列*的数据结构中。当数据段被放置在队列中时，为该数据段启动一个重传计时器。因此，在某个时刻，*每个*数据段都会被放置在这个队列中。队列按照重传计时器剩余时间排序，这样TCP软件可以跟踪哪些计时器在到期前剩余时间最少。'
- en: '**Acknowledgment Processing** If an acknowledgment is received for a segment
    before its timer expires, the segment is removed from the retransmission queue.'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '**确认处理** 如果在计时器到期之前收到数据段的确认，则从重传队列中删除该数据段。'
- en: '**Retransmission Timeout** If an acknowledgment is *not* received before the
    timer for a segment expires, a *retransmission timeout* occurs, and the segment
    is automatically retransmitted.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**重传超时** 如果在数据段的计时器到期之前没有收到确认，将发生*重传超时*，该数据段将自动重新传输。'
- en: Of course, we have no more guarantee that a retransmitted segment will be received
    than we had for the original segment. For this reason, after retransmitting a
    segment, it remains in the retransmission queue. The retransmission timer is reset,
    and the countdown begins again. If an acknowledgment is not received for the retransmission,
    the segment will be retransmitted again and the process repeated.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们对于重新传输的数据段能否被接收的保证并不比原始数据段更多。因此，在重新传输数据段后，它将保留在重传队列中。重传计时器被重置，并重新开始倒计时。如果未收到重传的确认，数据段将再次重新传输，并重复此过程。
- en: Certain conditions may cause even repeated retransmissions of a segment to fail.
    We don't want TCP to just keep retransmitting forever, so TCP will retransmit
    a lost segment only a certain number of times before concluding that there is
    a problem and terminating the connection.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 某些条件可能导致即使重复重传数据段也会失败。我们不希望 TCP 无限期地重传，因此 TCP 只会在确定存在问题并终止连接之前重传丢失的数据段一定次数。
- en: Tip
  id: totrans-992
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** To provide basic reliability for sent data, each device''s
    TCP implementation uses a *retransmission queue*. Each sent segment is placed
    in the queue and a *retransmission timer* started for it. When an acknowledgment
    is received for the data in the segment, it is removed from the retransmission
    queue. If the timer goes off before an acknowledgment is received, the segment
    is retransmitted and the timer restarted.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为了提供发送数据的基本可靠性，每个设备的 TCP 实现都使用一个 *重传队列*。每个发送的数据段都会放入队列中，并为它启动一个 *重传定时器*。当接收到数据段中数据的确认时，它将从重传队列中移除。如果在收到确认之前定时器已经超时，该段将被重传，定时器也会重新启动。'
- en: Recognizing When a Segment Is Fully Acknowledged
  id: totrans-994
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别数据段是否完全确认
- en: But how do we know when a segment has been fully acknowledged? Retransmissions
    are handled on a segment basis, but TCP acknowledgments, as we have seen, are
    done on a cumulative basis using sequence numbers. Each time a segment is sent
    by Device A to Device B, Device B looks at the value of the Acknowledgment Number
    field in the segment. All bytes with sequence numbers lower than the value of
    this field have been received by Device A. Thus, a segment sent by Device B to
    Device A is considered acknowledged when all of the bytes that were sent in the
    segment have a lower sequence number than the latest Acknowledgment Number sent
    by Device B to Device A. This is determined by calculating the last sequence number
    of the segment using its first byte number (in the Sequence Number field) and
    length of the segment's Data field.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道一个数据段是否已被完全确认呢？重传是在数据段的基础上处理的，但正如我们所见，TCP 确认是基于累积的，使用序列号。每当设备 A 向设备 B
    发送数据段时，设备 B 会查看数据段中确认号字段的值。所有序列号低于该值的字节数据都已由设备 A 接收。因此，当设备 B 向设备 A 发送的数据段中所有发送的字节序列号都低于设备
    B 向设备 A 发送的最后一个确认号时，该数据段被认为是已确认的。这是通过计算数据段最后一个序列号（使用其序列号字段中的第一个字节编号和数据段数据字段的长度）来确定的。
- en: Tip
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP uses a *cumulative acknowledgment* system. The Acknowledgment
    Number field in a segment received by a device indicates that all bytes of data
    with sequence numbers less than that value have been successfully received by
    the other device. A segment is considered acknowledged when all of its bytes have
    been acknowledged; in other words, when an Acknowledgment Number containing a
    value larger than the sequence number of its last byte is received.'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP 使用一个 *累积确认* 系统。设备接收到的数据段中的确认号字段表示，所有序列号小于该值的字节数据都已成功被另一设备接收。当一个数据段的全部字节都被确认时，该段被认为是已确认的；换句话说，当接收到一个包含比其最后一个字节的序列号更大的值的确认号时。'
- en: 'Let''s use the example illustrated in [Figure 49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server''s send pointers and client''s receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged.") to
    clarify how acknowledgments and retransmissions work in TCP. Suppose the server
    in a connection sends out four contiguous segments (numbered starting with 1 for
    clarity):'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[图49-1](ch49.html#tcp_transaction_example_with_retransmiss "图49-1. TCP事务重传示例。此图说明了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器快速连续地向客户端发送三个段，并为每个段设置重传计时器。部分1和2被接收，客户端为它们发送确认。在收到此ACK后，部分1和2从重传队列中移除。然而，部分3在传输过程中丢失。当接收到部分4时，客户端无法确认它；这会意味着接收了丢失的部分3。最终，部分3的重传计时器到期，它被重传，此时部分3和部分4都被确认。")中的示例来说明确认和重传在TCP中是如何工作的。假设连接中的服务器发送出四个连续的段（为了清晰起见，从1开始编号）：
- en: '**Segment 1** Sequence Number field is 1 and segment length is 80\. So the
    last sequence number in Segment 1 is 80.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '**段1** 序列号字段为1，段长度为80。因此，段1中的最后一个序列号是80。'
- en: '**Segment 2** Sequence Number field is 81 and segment length is 120\. The last
    sequence number in Segment 2 is 200.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '**段2** 序列号字段为81，段长度为120。段2中的最后一个序列号是200。'
- en: '**Segment 3** Sequence Number field is 201 and segment length is 160\. The
    last sequence number in Segment 3 is 360.'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '**段3** 序列号字段为201，段长度为160。段3中的最后一个序列号是360。'
- en: '**Segment 4** Sequence Number field is 361 and segment length is 140\. The
    last sequence number in Segment 4 is 500.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '**段4** 序列号字段为361，段长度为140。段4中的最后一个序列号是500。'
- en: Again, these segments can be sent one after the other, without needing to wait
    for each preceding transmission to be acknowledged. This is a major benefit of
    TCP's sliding window mechanism.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些段可以依次发送，无需等待每个前一个传输被确认。这是TCP滑动窗口机制的主要优势。
- en: Now let's say the client receives the first two transmissions. It will send
    back an acknowledgment with an Acknowledgment Number field value of 201\. This
    tells the server that the first two segments have been successfully received by
    the client; they will be removed from the retransmission queue (and the server's
    send window will slide 200 bytes to the right). Segment 3 will remain on the retransmission
    queue until a segment with an Acknowledgment Number field value of 361 or higher
    is received; Segment 4 requires an acknowledgment value of 501 or greater.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设客户端接收了前两个传输。它将发送一个确认，其中确认号字段值为201。这告诉服务器，前两个段已经被客户端成功接收；它们将从重传队列中移除（并且服务器的发送窗口将向右滑动200字节）。段3将保留在重传队列中，直到接收到一个确认号字段值为361或更高的段；段4需要一个确认值至少为501。
- en: Now, let's further suppose in this example that Segment 3 gets lost in transit,
    but Segment 4 is received. The client will store Segment 4 in its receive buffer,
    but will not be able to acknowledge it, because of TCP's cumulative acknowledgment
    system—acknowledging Segment 4 would imply receipt of Segment 3 as well, which
    never showed up. So, the client will need to wait for Segment 3\. Eventually,
    the retransmission timer that the server started for Segment 3 will expire. The
    server will then retransmit Segment 3\. It will be received by the client, which
    will then be able to acknowledge both Segments 3 and 4 to the server.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步假设在这个例子中，段3在传输过程中丢失，但段4被接收。客户端将段4存储在其接收缓冲区中，但无法确认它，因为TCP的累积确认系统——确认段4意味着也接收了段3，而这从未出现。因此，客户端需要等待段3。最终，服务器为段3启动的重传计时器将到期。服务器然后将重传段3。客户端将接收它，然后能够向服务器确认段3和段4。
- en: 'There''s another important issue here, however: How exactly should the server
    handle Segment 4? While the client is waiting for the missing Segment 3, the server
    is receiving no feedback, so it doesn''t know that Segment 3 is lost, and it also
    doesn''t know what happened to Segment 4 (or any subsequent transmissions). It
    is possible that the client has already received Segment 4 but just couldn''t
    acknowledge it. Then again, maybe Segment 4 got lost as well. Some implementations
    may choose to resend only Segment 3, while some may choose to resend both Segments
    3 and 4\. This is an important issue that we will discuss next.'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里还有一个重要的问题：服务器应该如何处理第4个段？当客户端等待缺失的第3个段时，服务器没有收到任何反馈，因此它不知道第3个段已经丢失，也不知道第4个段（或任何后续传输）发生了什么。可能的情况是客户端已经收到了第4个段，但无法确认它。另一方面，第4个段也可能丢失了。一些实现可能选择只重发第3个段，而另一些可能选择重发第3个和第4个段。这是我们接下来要讨论的重要问题。
- en: '![TCP transaction example with retransmission This diagram illustrates a simple
    transaction and shows the server''s send pointers and client''s receive pointers.
    The server sends three segments to the client in rapid succession, setting a retransmission
    timer for each. Parts 1 and 2 are received, and the client sends an acknowledgment
    for them. Upon receipt of this ACK, Parts 1 and 2 are taken off the retransmission
    queue. However, Part 3 is lost in transit. When Part 4 is received, the client
    cannot acknowledge it; this would imply receipt of the missing Part 3\. Eventually,
    the retransmission timer for Part 3 expires and it is retransmitted, at which
    time both Part 3 and Part 4 are acknowledged.](httpatomoreillycomsourcenostarchimages288131.png.jpg)'
  id: totrans-1007
  prefs: []
  type: TYPE_IMG
  zh: '![带重传的TCP事务示例 此图说明了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器连续向客户端发送三个段，并为每个段设置重传定时器。第1部分和第2部分被接收，客户端为它们发送确认。收到此确认后，第1部分和第2部分从重传队列中移除。然而，第3部分在传输过程中丢失。当收到第4部分时，客户端无法确认它；这会暗示收到了缺失的第3部分。最终，第3部分的重传定时器到期，它被重新传输，此时第3部分和第4部分都被确认。](http://atomoreilly.com/source/nostarch/images/288131.png.jpg)'
- en: Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server's send pointers and client's receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-1. 带重传的TCP事务示例 此图说明了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器连续向客户端发送三个段，并为每个段设置重传定时器。第1部分和第2部分被接收，客户端为它们发送确认。收到此确认后，第1部分和第2部分从重传队列中移除。然而，第3部分在传输过程中丢失。当收到第4部分时，客户端无法确认它；这会暗示收到了缺失的第3部分。最终，第3部分的重传定时器到期，它被重新传输，此时第3部分和第4部分都被确认。
- en: A final issue is what value we should use for the retransmission timer when
    we put a segment on the retransmission queue. If it is set too low, excessive
    retransmissions occur; if set too high, performance is reduced due to extraneous
    delays in resending lost segments. In fact, TCP cannot use a single number for
    this value. It must determine the value dynamically using a process called adaptive
    retransmission, which we will examine later in the chapter.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是在将段放入重传队列时，我们应该使用什么值作为重传定时器。如果设置得太低，会发生过多的重传；如果设置得太高，由于重发丢失段的外部延迟，性能会降低。实际上，TCP不能使用单个数字来表示这个值。它必须使用称为自适应重传的过程动态确定这个值，我们将在本章后面讨论这个问题。
- en: TCP Noncontiguous Acknowledgment Handling and Selective Acknowledgment (SACK)
  id: totrans-1010
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP非连续确认处理和选择性确认（SACK）
- en: Computer science people sometimes use the term *elegant* to describe a simple
    but effective solution to a problem or need. I think the term applies fairly well
    to the cumulative acknowledgment method that is part of the TCP sliding window
    system. With a single number, returned in the Acknowledgment Number field of a
    TCP segment, the device sending the segment can acknowledge not just a single
    segment it has received from its connection peer, but possibly several of them.
    We saw how this works in the discussion of the fundamentals of sliding windows
    in [Chapter 46](ch46.html "Chapter 46. TRANSMISSION CONTROL PROTOCOL (TCP) FUNDAMENTALS
    AND GENERAL OPERATION"), and again in the previous discussion of retransmissions.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学人员有时使用*优雅*这个词来描述一个简单但有效的解决方案。我认为这个术语相当适用于TCP滑动窗口系统的一部分累积确认方法。通过一个单一的数字，在TCP段的确认号字段中返回，发送段的设备不仅可以确认它从连接对等方接收到的单个段，而且可能还有几个段。我们在[第46章](ch46.html
    "第46章。传输控制协议（TCP）基础和一般操作")中讨论滑动窗口的基本原理时看到了这一点，也在之前的重传讨论中再次看到了这一点。
- en: Even the most elegant technique has certain weaknesses, however. In the case
    of the TCP acknowledgment system, it is the inability to effectively deal with
    the receipt of *noncontiguous* TCP segments. The Acknowledgment Number specifies
    that *all* sequence numbers lower than its value have been received by the device
    sending that number. If we receive bytes with sequence numbers in two noncontiguous
    ranges, there is no way to specify this with a single number.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最优雅的技术也有一定的弱点。在TCP确认系统的案例中，它无法有效地处理接收到的*非连续*TCP段。确认号指定了发送该数字的设备已经接收了所有低于其值的序列号。如果我们收到两个非连续范围内的序列号的字节，就没有办法用一个单一的数字来指定这一点。
- en: This can lead to potentially serious performance problems, especially on internetworks
    that operate at high speed or over inherently unreliable physical networks. To
    see what the problem is, let's go back to the example illustrated in [Figure 49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server's send pointers and client's receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged."). There,
    the server sent four segments and received back an acknowledgment with an Acknowledgment
    Number value of 201\. Segment 1 and Segment 2 were thus considered acknowledged.
    They would be removed from the retransmission queue, and this would also allow
    the server's send window to slide 80+120 bytes to the right, allowing 200 more
    bytes of data to be sent.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致潜在的严重性能问题，尤其是在高速运行或在本质上不可靠的物理网络上运行的互联网中。为了了解问题所在，让我们回到[图49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "图49-1. 带重传的TCP事务示例。此图展示了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器快速连续地向客户端发送三个段，并为每个段设置重传定时器。第1部分和第2部分被接收，客户端为它们发送确认。在收到此ACK后，第1部分和第2部分从重传队列中移除。然而，第3部分在传输过程中丢失。当收到第4部分时，客户端无法确认它；这会暗示收到了缺失的第3部分。最终，第3部分的重传定时器到期，它被重新传输，此时第3部分和第4部分都被确认。")中展示的例子。在那里，服务器发送了四个段，并收到了一个确认，其确认号值为201。因此，段1和段2被认为是已确认的。它们将被从重传队列中移除，这也允许服务器的发送窗口向右滑动80+120字节，从而允许发送200更多字节的数据。
- en: However, let's again imagine that Segment 3, starting with sequence number 201,
    is somehow lost in transit. Since the client never receives this segment, it can
    never send back an acknowledgment with an Acknowledgment Number higher than 201\.
    This causes the sliding window system to get stuck. The server can continue to
    send additional segments until it fills up the client's receive window, but until
    the client sends another acknowledgment, the server's send window will not slide.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们再次想象，从序列号201开始的第3个段在传输过程中丢失了。由于客户端从未收到这个段，它永远无法发送一个确认号高于201的确认。这导致滑动窗口系统卡住。服务器可以继续发送额外的段，直到填满客户端的接收窗口，但直到客户端发送另一个确认，服务器的发送窗口不会滑动。
- en: The other problem we saw is that if Segment 3 gets lost, the client has no way
    to tell the server that it has received any *subsequent* segments. It's entirely
    possible that the client has received the server's Segment 4 and later segments,
    until the window filled up. But the client can't send an acknowledgment with a
    value of 501 to indicate receipt of Segment 4, *because this implies receipt of
    Segment 3 as well*.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的另一个问题是，如果第3个段丢失了，客户端没有方法告诉服务器它已经收到了任何*后续*的段。客户端完全可能已经收到了服务器的第4个段和后续段，直到窗口填满。但是，客户端不能发送一个值为501的确认来表示已收到第4个段，*因为这暗示了已收到第3个段*。
- en: Note
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases, the client may still send an acknowledgment upon receipt of Segment
    4, but containing only a repeated acknowledgment of the bytes up to the end of
    Segment 2\. See the coverage of congestion avoidance later in this chapter for
    an explanation.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，客户端在收到第4个段后仍然可能会发送一个确认，但只包含对到第2个段末尾的字节的重复确认。请参阅本章后面的拥塞避免部分以获取解释。
- en: And here we see the drawback of the single-number, cumulative acknowledgment
    system of TCP. We could imagine a worst-case scenario, in which the server is
    told it has a window of 10,000 bytes, and sends 20 segments of 500 bytes each.
    The first segment is lost, and the other 19 are received. But since it is the
    first segment that never showed up, none of the other 19 segments can be acknowledged!
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到TCP的单数值累积确认系统的缺点。我们可以想象一个最坏的情况，即服务器被告知它有一个10,000字节的窗口，并发送了20个每个500字节的段。第一个段丢失了，其他19个段被接收。但是，由于第一个段从未出现，所以其他19个段都无法被确认！
- en: Tip
  id: totrans-1019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP''s acknowledgment system is *cumulative*. This means that
    if a segment is lost in transit, no subsequent segments can be acknowledged until
    the missing one is retransmitted and successfully received.'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP的确认系统是累积的。这意味着如果传输过程中丢失了一个段，那么在丢失的段被重传并成功接收之前，不能确认后续的段。'
- en: Policies for Dealing with Outstanding Unacknowledged Segments
  id: totrans-1021
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理未确认段落的策略
- en: How do we handle retransmissions when there are subsequent segments outstanding
    beyond the lost segment? In our example, when the server experiences a retransmission
    timeout on Segment 3, it must decide what to do about Segment 4, when it simply
    doesn't know whether or not the client received it. In our worst-case scenario,
    we have 19 segments that may or may not have shown up at the client after the
    first one that was lost.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在超出丢失段的后续段时，我们如何处理重传？在我们的例子中，当服务器在第3个段上遇到重传超时时，它必须决定对第4个段做什么，因为它根本不知道客户端是否收到了它。在我们的最坏情况下，我们可能有19个段，这些段可能在丢失的第一个段之后出现在客户端，也可能没有。
- en: 'We have two possible ways to handle this situation:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理这种情况的可能方法：
- en: '**Retransmit Only Timed-Out Segments** This is the more conservative, or if
    you prefer, optimistic approach. We retransmit only the segment that timed out,
    hoping that the other segments beyond it were successfully received. This method
    is best if the segments after the timed-out segment actually showed up. It doesn''t
    work so well if they did not. In the latter case, each segment would need to time
    out individually and be retransmitted. Imagine that in our worst-case scenario,
    all twenty 500-byte segments were lost. We would need to wait for Segment 1 to
    time out and be retransmitted. This retransmission would be acknowledged (we hope),
    but then we would get stuck waiting for Segment 2 to time out and be resent. We
    would need to do this many times.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅重传超时段** 这是一种更为保守，或者如果你愿意，更为乐观的方法。我们只重传超时的那个段，希望其他超出它的段已经成功接收。如果超时段之后的段实际上已经出现，这种方法效果最好。如果它们没有出现，效果就不那么好了。在后一种情况下，每个段都需要单独超时并重传。想象一下，在我们最坏的情况下，所有的二十个500字节的段都丢失了。我们需要等待第1个段超时并重传。这个重传会被确认（我们希望），然后我们会陷入等待第2个段超时并被重传的困境。我们需要这样做很多次。'
- en: '**Retransmit All Outstanding Segments** This is the more aggressive, or pessimistic,
    method. Whenever a segment times out, we resend not only that segment, but all
    other segments that are still unacknowledged. This method ensures that any time
    there is a holdup with acknowledgments, we refresh all outstanding segments to
    give the other device an extra chance at receiving them, in case they, too, were
    lost. In the case where all 20 segments were lost, this saves substantial amounts
    of time over the alternative, optimistic approach. The problem here is that these
    retransmissions may not be necessary. If the first of 20 segments was lost and
    the other 19 were actually received, we would be resending 9500 bytes of data
    (plus headers) for no reason.'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**重传所有未确认的段** 这是一种更为激进，或者说是悲观的方法。每当一个段超时时，我们不仅重传那个段，而且重传所有其他尚未确认的段。这种方法确保了，在任何确认出现延误的情况下，我们都会刷新所有未确认的段，给另一个设备一个额外的机会接收它们，以防它们也丢失了。在所有20个段都丢失的情况下，这种方法比乐观的方法节省了大量时间。问题是，这些重传可能并不必要。如果前20个段中的第一个丢失，而其他19个实际上已经接收到了，我们就会无端地重传9500字节的数据（包括头部）。'
- en: 'Since TCP doesn''t know whether these other segments showed up, it cannot know
    which method is better. It must simply make an executive decision to use one approach
    or the other and hope for the best. In the example shown in [Figure 49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server''s send pointers and client''s receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged."), I
    demonstrated the conservative, optimistic approach: Only the lost segment of the
    file was retransmitted. [Figure 49-2](ch49s02.html#tcp_aggressive_retransmission_example_th
    "Figure 49-2. TCP aggressive retransmission example This example is the same as
    that shown in Figure 49-1, except that here the server is taking an "aggressive"
    approach to retransmitting lost segments. When Segment 3 times out, both Segments
    3 and 4 are retransmitted, and their retransmission timers restarted. (In this
    case, Segment 4 already arrived, so this extra transmission was not useful.)")
    illustrates the alternative aggressive, pessimistic approach to retransmission.'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP不知道这些其他段是否出现，它无法知道哪种方法更好。它必须简单地做出决策，选择一种方法或另一种方法，并寄希望于最好的结果。在[图49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "图49-1. TCP事务示例及重传此图展示了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器快速连续地向客户端发送三个段，并为每个段设置重传定时器。第1部分和第2部分被接收，客户端为它们发送确认。收到此确认后，第1部分和第2部分从重传队列中移除。然而，第3部分在传输过程中丢失。当收到第4部分时，客户端无法确认它；这会暗示收到了缺失的第3部分。最终，第3部分的重传定时器到期，它被重新传输，此时第3部分和第4部分都被确认。")中所示的情况下，我演示了保守、乐观的方法：只有文件丢失的段被重新传输。[图49-2](ch49s02.html#tcp_aggressive_retransmission_example_th
    "图49-2. TCP积极重传示例此示例与图49-1所示相同，只是在这里服务器正在采取积极的方法来重新传输丢失的段。当段3超时时，段3和段4都被重新传输，并且它们的重传定时器被重新启动。（在这种情况下，段4已经到达，所以这次额外的传输没有用。）")展示了另一种积极、悲观的重传方法。
- en: '![TCP aggressive retransmission example This example is the same as that shown
    in , except that here the server is taking an "aggressive" approach to retransmitting
    lost segments. When Segment 3 times out, both Segments 3 and 4 are retransmitted,
    and their retransmission timers restarted. (In this case, Segment 4 already arrived,
    so this extra transmission was not useful.)](httpatomoreillycomsourcenostarchimages288133.png.jpg)'
  id: totrans-1027
  prefs: []
  type: TYPE_IMG
  zh: '![TCP积极重传示例此示例与图49-1所示相同，只是在这里服务器正在采取积极的方法来重新传输丢失的段。当段3超时时，段3和段4都被重新传输，并且它们的重传定时器被重新启动。（在这种情况下，段4已经到达，所以这次额外的传输没有用。）](httpatomoreillycomsourcenostarchimages288133.png.jpg)'
- en: Figure 49-2. TCP aggressive retransmission example This example is the same
    as that shown in [Figure 49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server's send pointers and client's receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged."), except
    that here the server is taking an "aggressive" approach to retransmitting lost
    segments. When Segment 3 times out, both Segments 3 and 4 are retransmitted, and
    their retransmission timers restarted. (In this case, Segment 4 already arrived,
    so this extra transmission was not useful.)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-2. TCP积极重传示例 此示例与[图49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "图49-1. 带重传的TCP事务示例 此图展示了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器快速连续地向客户端发送三个段，并为每个段设置重传定时器。第1部分和第2部分被接收，客户端为它们发送确认。在收到此ACK后，第1部分和第2部分从重传队列中移除。然而，第3部分在传输过程中丢失。当收到第4部分时，客户端无法确认它；这会暗示收到了缺失的第3部分。最终，第3部分的重传定时器到期，它被重新传输，此时第3部分和第4部分都被确认。")中的示例相同，只是在这里，服务器正在采取一种“积极”的方法来重传丢失的段。当第3个段超时时，第3个段和第4个段都被重新传输，并且它们的重传定时器被重新启动。（在这种情况下，第4个段已经到达，所以这次额外的传输并没有用。）
- en: Tip
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** There are two approaches to handling retransmission in TCP.
    In the more conservative approach, only the segments whose timers expire are retransmitted.
    This saves bandwidth, but it may cause performance degradation if many segments
    in a row are lost. The alternative is that when a segment''s retransmission timer
    expires, both it and all subsequent unacknowledged segments are retransmitted.
    This provides better performance if many segments are lost, but it may waste bandwidth
    on unnecessary retransmissions.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在TCP中处理重传有两种方法。在更保守的方法中，只有定时器到期的段被重新传输。这可以节省带宽，但如果连续丢失多个段，可能会导致性能下降。另一种方法是，当一个段的重传定时器到期时，它和所有后续未确认的段都被重新传输。如果丢失多个段，这可以提供更好的性能，但可能会在不必要的情况下浪费带宽。'
- en: This lack of knowledge about noncontiguous segments is the core of the problem.
    The solution is to extend the basic TCP sliding window algorithm with an optional
    feature that allows a device to acknowledge noncontiguous segments individually.
    This feature, introduced in RFC 1072 and refined in RFC 2018, is called TCP *selective
    acknowledgment*, abbreviated *SACK*.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 对非连续段缺乏了解是问题的核心。解决方案是在基本的TCP滑动窗口算法中增加一个可选功能，允许设备单独确认非连续段。这个功能在RFC 1072中引入，并在RFC
    2018中完善，被称为TCP *选择性确认*，简称 *SACK*。
- en: 'A Better Solution: Selective Acknowledgment (SACK)'
  id: totrans-1032
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的解决方案：选择性确认（SACK）
- en: To use SACK, the two devices on the connection must both support the feature,
    and must enable it by negotiating the Selective Acknowledge Permitted (SACK-Permitted)
    option in the SYN segment they use to establish the connection. Assuming this
    is done, either device is then permitted to include in a regular TCP segment a
    Selective Acknowledgment (SACK) option. This option contains a list of sequence
    number ranges of segments of data that have been received but have not been acknowledged,
    since they are noncontiguous.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SACK，连接上的两个设备都必须支持该功能，并且必须通过在它们用来建立连接的SYN段中协商选择性确认允许（SACK-Permitted）选项来启用它。假设这样做，任何设备都可以在常规TCP段中包含一个选择性确认（SACK）选项。此选项包含一个已接收但尚未确认的数据段序列号范围列表，因为这些段是非连续的。
- en: Each device modifies its retransmission queue so that each segment includes
    a flag that is set to 1 if the segment has been selectively acknowledged—the SACK
    bit. The device then uses a modified version of the aggressive method illustrated
    in [Figure 49-2](ch49s02.html#tcp_aggressive_retransmission_example_th "Figure 49-2. TCP
    aggressive retransmission example This example is the same as that shown in Figure 49-1,
    except that here the server is taking an "aggressive" approach to retransmitting
    lost segments. When Segment 3 times out, both Segments 3 and 4 are retransmitted,
    and their retransmission timers restarted. (In this case, Segment 4 already arrived,
    so this extra transmission was not useful.)"), where upon retransmission of a
    segment, all later segments are also retransmitted *unless* their SACK bits are
    set to 1.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备都会修改其重传队列，以便每个段包含一个标志，如果该段已被选择性确认——即SACK位，则该标志被设置为1。设备随后使用[图49-2](ch49s02.html#tcp_aggressive_retransmission_example_th
    "图49-2. TCP积极重传示例 此示例与图49-1所示相同，只是这里服务器正在采取“积极”的方法重传丢失的段。当段3超时时，段3和段4都会被重传，并且它们的重传计时器重新启动。（在这种情况下，段4已经到达，所以这次额外传输没有用。）"中展示的积极方法的修改版本，在重传段时，除非它们的SACK位被设置为1，否则所有后续段也会被重传。
- en: Tip
  id: totrans-1035
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The optional TCP *selective acknowledgment* feature provides
    a more elegant way of handling subsequent segments when a retransmission timer
    expires. When a device receives a noncontiguous segment, it includes a special
    *Selective Acknowledgment* (SACK) option in its regular acknowledgment that identifies
    noncontiguous segments that have already been received, even if they are not yet
    acknowledged. This saves the original sender from needing to retransmit them.'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 可选的TCP *选择性确认* 功能提供了一种更优雅的方式来处理重传计时器到期后的后续段。当一个设备接收到一个非连续段时，它会在其常规确认中包含一个特殊的
    *选择性确认* (SACK) 选项，以标识已接收但尚未确认的非连续段。这可以节省原始发送者重新传输它们的需求。'
- en: For example, in our four-segment case, if the client receives Segment 4 but
    not Segment 3, when it sends back a segment with an Acknowledgment Number field
    value of 201 (for Segments 1 and 2), it can include a SACK option that specifies,
    "I have received bytes 361 through 500, but they are not yet acknowledged." This
    can also be done in a second acknowledgment segment if Segment 4 arrives well
    after Segments 1 and 2\. The server recognizes this as the range of bytes for
    Segment 4, and turns on the SACK bit for Segment 4\. When Segment 3 is retransmitted,
    the server sees that the SACK bit for Segment 4 is on and does not retransmit
    it. This is illustrated in [Figure 49-3](ch49s02.html#tcp_retransmission_with_selective_acknow
    "Figure 49-3. TCP retransmission with selective acknowledgment (SACK) This is
    the example from Figures Figure 49-1 and Figure 49-2, changed to use the optional
    selective acknowledge feature. After receiving Parts 1, 2, and 4 of the file,
    the client sends an acknowledgment for 1 and 2 that includes a SACK for Part 4\.
    This tells the server not to resend Part 4 when Part 3's timer expires.").
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的四个段的情况下，如果客户端收到了段4但没有收到段3，当它发送一个带有确认号字段值为201（用于段1和段2）的段时，它可以包含一个SACK选项，指定“我已经收到了字节361到500，但它们尚未被确认。”如果段4在段1和段2之后到达得很好，这也可以在第二个确认段中完成。服务器会识别这作为段4的字节范围，并打开段4的SACK位。当段3被重传时，服务器看到段4的SACK位已打开，因此不会重传它。这可以在[图49-3](ch49s02.html#tcp_retransmission_with_selective_acknow
    "图49-3. 带有选择性确认（SACK）的TCP重传 此示例来自图49-1和图49-2，改为使用可选的选择性确认功能。在收到文件的第1、2和4部分后，客户端发送一个确认1和2，其中包含对第4部分的SACK。这告诉服务器在段3的计时器到期时不要重发第4部分。")中看到。
- en: After Segment 3 is retransmitted, the SACK bit for Segment 4 is cleared. This
    is done for robustness, to handle cases where, for whatever reason, the client
    changes its mind about having received Segment 4\. The client *should* send an
    acknowledgment with an Acknowledgment Number of 501 or higher, officially indicating
    receipt of Segments 3 and 4\. If this does not happen, the server must receive
    another selective acknowledgment for Segment 4 to turn its SACK bit back on. Otherwise,
    it will be automatically resent when its timer expires or when Segment 3 is retransmitted.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 在段3重传后，段4的SACK位被清除。这是为了稳健性，以处理由于任何原因，客户端改变主意认为已收到段4的情况。客户端*应该*发送一个确认，其确认号为501或更高，正式表示已收到段3和段4。如果这种情况没有发生，服务器必须接收到另一个针对段4的选择性确认，以将其SACK位重新打开。否则，它将在其定时器到期或段3被重新传输时自动重新发送。
- en: '![TCP retransmission with selective acknowledgment (SACK) This is the example
    from Figures and , changed to use the optional selective acknowledge feature.
    After receiving Parts 1, 2, and 4 of the file, the client sends an acknowledgment
    for 1 and 2 that includes a SACK for Part 4\. This tells the server not to resend
    Part 4 when Part 3''s timer expires.](httpatomoreillycomsourcenostarchimages288135.png.jpg)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
  zh: '![使用选择性确认（SACK）的TCP重传 这是来自图和 的示例，改为使用可选的选择性确认功能。在收到文件的1、2和4部分后，客户端为1和2发送确认，其中包含对部分4的SACK。这告诉服务器在部分3的定时器到期时不要重新发送部分4。](httpatomoreillycomsourcenostarchimages288135.png.jpg)'
- en: Figure 49-3. TCP retransmission with selective acknowledgment (SACK) This is
    the example from Figures [Figure 49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "Figure 49-1. TCP transaction example with retransmission This diagram illustrates
    a simple transaction and shows the server's send pointers and client's receive
    pointers. The server sends three segments to the client in rapid succession, setting
    a retransmission timer for each. Parts 1 and 2 are received, and the client sends
    an acknowledgment for them. Upon receipt of this ACK, Parts 1 and 2 are taken
    off the retransmission queue. However, Part 3 is lost in transit. When Part 4
    is received, the client cannot acknowledge it; this would imply receipt of the
    missing Part 3\. Eventually, the retransmission timer for Part 3 expires and it
    is retransmitted, at which time both Part 3 and Part 4 are acknowledged.") and
    [Figure 49-2](ch49s02.html#tcp_aggressive_retransmission_example_th "Figure 49-2. TCP
    aggressive retransmission example This example is the same as that shown in Figure 49-1,
    except that here the server is taking an "aggressive" approach to retransmitting
    lost segments. When Segment 3 times out, both Segments 3 and 4 are retransmitted,
    and their retransmission timers restarted. (In this case, Segment 4 already arrived,
    so this extra transmission was not useful.)"), changed to use the optional selective
    acknowledge feature. After receiving Parts 1, 2, and 4 of the file, the client
    sends an acknowledgment for 1 and 2 that includes a SACK for Part 4\. This tells
    the server not to resend Part 4 when Part 3's timer expires.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-3. 使用选择性确认（SACK）的TCP重传 这是来自图[图49-1](ch49.html#tcp_transaction_example_with_retransmiss
    "图49-1. 带重传的TCP事务示例 此图展示了简单的事务，并显示了服务器的发送指针和客户端的接收指针。服务器快速连续地向客户端发送三个段，并为每个段设置重传定时器。部分1和2被接收，客户端为它们发送确认。在收到此ACK后，部分1和2从重传队列中移除。然而，部分3在传输过程中丢失。当收到部分4时，客户端无法确认它；这会暗示收到了缺失的部分3。最终，部分3的重传定时器到期，它被重新传输，此时部分3和部分4都被确认。")和[图49-2](ch49s02.html#tcp_aggressive_retransmission_example_th
    "图49-2. TCP激进重传示例 此示例与图49-1所示相同，只是这里服务器在重传丢失段时采取了一种“激进”的方法。当段3超时时，段3和段4都被重新传输，并且它们的重传定时器被重新启动。（在这种情况下，段4已经到达，所以这次额外传输没有用。）")的示例，改为使用可选的选择性确认功能。在收到文件的1、2和4部分后，客户端为1和2发送确认，其中包含对部分4的SACK。这告诉服务器在部分3的定时器到期时不要重新发送部分4。
- en: TCP Adaptive Retransmission and Retransmission Timer Calculations
  id: totrans-1041
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP自适应重传和重传定时器计算
- en: Whenever a TCP segment is transmitted, a copy of it is also placed on the retransmission
    queue. When the segment is placed on the queue, a retransmission timer is started
    for the segment, which starts from a particular value and counts down to zero.
    This timer controls how long a segment can remain unacknowledged before the sender
    gives up, concludes that the segment is lost, and sends it again.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发送一个TCP段时，它的一个副本也会放在重传队列中。当段被放入队列时，就会为该段启动一个重传计时器，它从一个特定的值开始并倒数到零。这个计时器控制了在发送者放弃、得出段已丢失的结论并再次发送它之前，一个段可以保持未确认的最长时间。
- en: The length of time we use for retransmission timer is thus very important. If
    it is set too low, we might start retransmitting a segment that was actually received,
    because we didn't wait long enough for the acknowledgment of that segment to arrive.
    Conversely, if we set the timer too long, we waste time waiting for an acknowledgment
    that will never arrive, reducing overall performance.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们用于重传计时器的时长非常重要。如果设置得太低，我们可能会开始重传一个实际上已经接收到的段，因为我们没有等待足够长的时间来等待该段的确认到达。相反，如果我们设置计时器太长，我们会浪费时间等待永远不会到达的确认，从而降低整体性能。
- en: 'Ideally, we would like to set the retransmission timer to a value just slightly
    larger than the *round-trip time (RTT)* between the two TCP devices; that is,
    the typical time it takes to send a segment from a client to a server and the
    server to send an acknowledgment back to the client (or the other way around,
    of course). The problem is that there *is* no such typical RTT. There are two
    main reasons for this:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望将重传计时器设置为略大于两个TCP设备之间**往返时间（RTT）**的值；也就是说，从客户端发送一个段到服务器，以及服务器将确认发送回客户端（或者当然相反）的典型时间。问题是，**并没有**这样一个典型的RTT。有两个主要原因：
- en: '**Differences in Connection Distance** Suppose you are at work in the United
    States, and during your lunch hour, you transfer a large file between your workstation
    and a local server connection using 100 Mbps Fast Ethernet. At the same time,
    you are downloading a picture of your nephew from your sister''s personal website,
    which is connected to the Internet using an analog modem to an ISP in a small
    town near Lima, Peru. Would you want both of these TCP connections to use the
    same retransmission timer value? I certainly hope not!'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接距离的差异** 假设你在美国工作，在午餐时间，你使用100 Mbps快速以太网在你的工作站和本地服务器之间传输一个大型文件。同时，你从你姐姐的个人网站上下载你侄子的照片，该网站通过连接到秘鲁利马附近一个小镇的ISP的模拟调制解调器连接到互联网。你希望这两个TCP连接使用相同的重传计时器值吗？我当然希望不是！'
- en: '**Transient Delays and Variability** The amount of time it takes to send data
    between any two devices will vary over time due to various happenings on the internetwork:
    fluctuations in traffic, router loads, and so on. To see an example of this for
    yourself, try typing `ping www.tcpipguide.com` from the command line of an Internet-connected
    PC, and you''ll see how the reported times can vary.'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '**瞬态延迟和可变性** 由于互联网中的各种事件，任何两个设备之间发送数据所需的时间会随时间变化：流量波动、路由器负载等等。为了亲自看看这个例子，尝试从连接到互联网的PC的命令行中输入`ping
    www.tcpipguide.com`，你会看到报告的时间如何变化。'
- en: It is for these reasons that TCP does not attempt to use a static, single number
    for its retransmission timers. Instead, TCP uses a dynamic, or *adaptive*retransmission
    scheme.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这些原因，TCP不会尝试使用一个静态的单一数字作为其重传计时器的值。相反，TCP使用一个动态的，或称**自适应**的重传方案。
- en: Adaptive Retransmission Based on RTT Calculations
  id: totrans-1048
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于RTT计算的自适应重传
- en: TCP attempts to determine the approximate RTT between the devices and adjusts
    it over time to compensate for increases or decreases in the average delay. The
    practical issues of how this is done are important, but they are not covered in
    much detail in the main TCP standard. However, RFC 2988, "Computing TCP's Retransmission
    Timer," discusses the issue extensively.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: TCP试图确定设备之间的近似RTT，并随着时间的推移进行调整，以补偿平均延迟的增加或减少。如何做到这一点的问题很重要，但在TCP的主要标准中并没有详细说明。然而，RFC
    2988，“计算TCP的重传计时器”对此问题进行了广泛讨论。
- en: 'RTTs can bounce up and down, so we want to aim for an *average* RTT value for
    the connection. This average should respond to consistent movement up or down
    in the RTT, without overreacting to a few very slow or fast acknowledgments. To
    allow this to happen, the RTT calculation uses a *smoothing* formula:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: RTT可能会上下波动，因此我们希望为连接找到一个*平均*的RTT值。这个平均值应该对RTT的上下波动做出响应，而不会对几个非常慢或非常快的确认过度反应。为了实现这一点，RTT的计算使用了一个*平滑*公式：
- en: New RTT = (α * Old RTT) + ( (1-α) * Newest RTT Measurement)
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 新RTT = (α * 旧RTT) + ((1-α) * 最新RTT测量值)
- en: where α (alpha) is a *smoothing factor* between 0 and 1\. Higher values of α
    (closer to 1) provide better smoothing and avoiding sudden changes as a result
    of one very fast or very slow RTT measurement. Conversely, this also slows down
    how quickly TCP reacts to more sustained changes in RTT. Lower values of alpha
    (closer to 0) make the RTT change more quickly in reaction to changes in measured
    RTT, but can cause overreaction when RTTs fluctuate wildly.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 其中α（alpha）是介于0和1之间的*平滑因子*。α的值越高（越接近1），平滑效果越好，可以避免由于一个非常快或非常慢的RTT测量结果而导致的突然变化。相反，这也减慢了TCP对RTT更持续变化的反应速度。α的值越低（越接近0），RTT对测量RTT的变化反应越快，但RTT波动剧烈时可能会引起过度反应。
- en: Acknowledgment Ambiguity
  id: totrans-1053
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确认模糊性
- en: 'Measuring the RTT between two devices is simple in concept: Note the time that
    a segment is sent, note the time that an acknowledgment is received, and subtract
    the two. The measurement is more tricky in actual implementation, however.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 测量两个设备之间的RTT在概念上很简单：注意发送段的时刻，注意收到确认的时刻，然后相减。然而，在实际实现中，这个测量更为复杂。
- en: One of the main potential "gotchas" occurs when a segment is assumed lost and
    is retransmitted. The retransmitted segment carries nothing that distinguishes
    it from the original. When an acknowledgment is received for this segment, it's
    unclear whether this corresponds to the retransmission or the original segment.
    Even though we decided the segment was lost and retransmitted it, it's possible
    the segment eventually got there, after taking a long time, or that the segment
    got their quickly but the *acknowledgment* took a long time!
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的潜在“陷阱”之一发生在假设一个段丢失并重新传输时。重传的段没有任何可以将其与原始段区分开来的东西。当收到这个段的确认时，不清楚这是否对应于重传或原始段。尽管我们决定该段已丢失并重新传输，但该段最终可能经过很长时间才到达，或者该段快速到达但*确认*花费了很长时间！
- en: This is called *acknowledgment ambiguity*, and it is not trivial to resolve.
    We can't just decide to assume that an acknowledgment always goes with the oldest
    copy of the segment sent, because this makes the RTT appear too high. We also
    don't want to just assume an acknowledgment always goes with the latest sending
    of the segment, as that may artificially lower the average RTT.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*确认模糊性*，解决它并不简单。我们不能简单地决定假设一个确认总是与发送的段的最旧副本一起，因为这会使往返时间（RTT）看起来太高。我们也不想仅仅假设确认总是与段的最新发送一起，因为这可能会人为地降低平均RTT。
- en: Refinements to RTT Calculation and Karn's Algorithm
  id: totrans-1057
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RTT计算和卡尔算法的改进
- en: TCP's solution is based on the use of a technique called *Karn's algorithm*,
    after its inventor, Phil Karn. The main change this algorithm makes is the separation
    of the calculation of average RTT from the calculation of the value to use for
    timers on retransmitted segments.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的解决方案基于使用一种称为*卡尔算法*的技术，以发明者菲尔·卡尔的名字命名。这个算法的主要变化是将平均RTT的计算与用于重传段计时器的值的计算分开。
- en: The first change made under Karn's algorithm is to not use measured RTT for
    any segments that are retransmitted in the calculation of the overall average
    RTT for the connection. This completely eliminates the problem of acknowledgment
    ambiguity.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 在卡尔算法下进行的第一个改变是不在计算连接的整体平均RTT时使用任何重传段的测量RTT。这完全消除了确认模糊性问题。
- en: 'However, this by itself, would not allow increased delays due to retransmissions
    to affect the average RTT. For this, we need the second change: incorporation
    of a *timer backoff* scheme for retransmitted segments. We start by setting the
    retransmission timer for each newly transmitted segment based on the current average
    RTT. When a segment is retransmitted, the timer is not reset to the same value
    it was set for the initial transmission. It is "backed off," or increased, using
    a multiplier (typically 2) to give the retransmission more time to be received.
    The timer continues to be increased until a retransmission is successful, up to
    a certain maximum value. This prevents retransmissions from being sent too quickly
    and further adding to network congestion.'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅此并不能允许由于重传而增加的延迟影响平均RTT。为此，我们需要第二个变化：为重传段引入*计时器退避*方案。我们首先根据当前的平均RTT为每个新传输的段设置重传计时器。当一个段被重传时，计时器不会被重置为最初传输时设置的相同值。它通过乘数（通常是2）进行“退避”，或增加，以给重传更多的时间被接收。计时器会继续增加，直到重传成功，达到一定的最大值。这防止了重传发送得太快，从而进一步增加网络拥塞。
- en: Once the retransmission succeeds, the RTT is kept at the longer (backed-off)
    value until a valid RTT can be measured on a segment that is sent and acknowledged
    without retransmission. This permits a device to respond with longer timers to
    occasional circumstances that cause delays to persist for a period of time on
    a connection, while eventually having the RTT settle back to a long-term average
    when normal conditions resume.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦重传成功，往返时间（RTT）将保持在较长的（退避的）值，直到可以在没有重传的情况下发送并确认的段上测量到一个有效的RTT。这允许设备对偶尔导致连接上延迟持续一段时间的情况使用较长的计时器进行响应，而当正常条件恢复时，最终将RTT调整回长期平均值。
- en: Tip
  id: totrans-1062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP uses an *adaptive* retransmission scheme that automatically
    adjusts the amount of time to which retransmission timers are set, based on the
    average amount of time it takes to send segments between devices. This helps avoid
    retransmitting potentially lost segments too quickly or too slowly.'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP使用一种*自适应*的重传方案，该方案根据设备之间发送段所需平均时间自动调整重传计时器的设置时间。这有助于避免太早或太晚重传可能丢失的段。'
- en: TCP Window Size Adjustment and Flow Control
  id: totrans-1064
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP窗口大小调整和流量控制
- en: We have seen the importance of the concept of *window size* to TCP's sliding
    window mechanism. In a connection between a client and a server, the client tells
    the server the number of bytes it is willing to receive at one time from the server;
    this is the client's *receive window*, which becomes the server's *send window*.
    Likewise, the server tells the client how many bytes of data it is willing to
    take from the client at one time; this is the server's *receive window* and the
    client's *send window*.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了*窗口大小*的概念对TCP滑动窗口机制的重要性。在客户端和服务器之间的连接中，客户端告诉服务器它愿意一次从服务器接收多少字节的数据；这是客户端的*接收窗口*，它成为服务器的*发送窗口*。同样，服务器告诉客户端它愿意一次从客户端接收多少字节的数据；这是服务器的*接收窗口*和客户端的*发送窗口*。
- en: 'The use of these windows is demonstrated in [Chapter 48](ch48.html "Chapter 48. TCP
    MESSAGE FORMATTING AND DATA TRANSFER"), where we discussed TCP''s basic data transfer
    and acknowledgment mechanism. However, just as the example in that chapter was
    simplified because I didn''t show what happens with lost segments, there''s another
    way that it doesn''t reflect the real-world conditions of an actual Internet:
    the send and receive window sizes never changed during the course of communication.'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这些窗口的使用在[第48章](ch48.html "第48章。TCP消息格式和数据传输")中得到了演示，我们讨论了TCP的基本数据传输和确认机制。然而，正如该章节中的示例简化了因为我没有展示丢失段的情况，还有另一种方式它并不反映实际互联网的真实情况：在通信过程中，发送和接收窗口的大小从未改变。
- en: To understand why the window size may fluctuate, we need to understand what
    it represents. The simplest way of considering the window size is that it indicates
    the size of the device's receive buffer for the particular connection. That is,
    window size represents how much data a device can handle from its peer at one
    time before it is passed to the application process. Let's consider the example
    in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER").
    I said that the server's window size was 360\. This means the server is willing
    to take no more than 360 bytes at a time from the client.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解窗口大小可能波动的原因，我们需要了解它代表什么。考虑窗口大小的最简单方式是，它表示设备特定连接的接收缓冲区的大小。也就是说，窗口大小表示设备在将数据传递给应用程序进程之前，一次可以从其对等方处理多少数据。让我们考虑[第48章](ch48.html
    "第48章。TCP消息格式和数据传输")中的例子。我说服务器的窗口大小是360。这意味着服务器一次愿意从客户端接收不超过360字节。
- en: 'When the server receives data from the client, it places it into this buffer.
    The server must then do two distinct things with this data:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器从客户端接收数据时，它将其放入此缓冲区。然后服务器必须对这份数据执行两个不同的操作：
- en: '**Acknowledgment** The server must send an acknowledgment back to the client
    to indicate that the data was received.'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**致谢** 服务器必须向客户端发送一个确认，以表明数据已被接收。'
- en: '**Transfer** The server must process the data, transferring it to the destination
    application process.'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输** 服务器必须处理数据，将其传输到目标应用程序进程。'
- en: It is critically important that we differentiate between these two activities.
    Unfortunately, the TCP standards don't do a great job in this regard, which makes
    them very difficult to understand. The key point is that in the basic sliding
    window system, data is acknowledged when received, but *not necessarily* immediately
    transferred out of the buffer. This means that is possible for the buffer to fill
    up with received data faster than the receiving TCP can empty it. When this occurs,
    the receiving device may need to adjust the window size to prevent the buffer
    from being overloaded.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 区分这两种活动至关重要。不幸的是，TCP标准在这方面做得并不出色，这使得它们很难理解。关键点是，在基本的滑动窗口系统中，数据在接收时会被确认，但*不一定*立即从缓冲区中传输出来。这意味着缓冲区可能会以接收TCP无法清空的速度更快地填满接收到的数据。当这种情况发生时，接收设备可能需要调整窗口大小以防止缓冲区过载。
- en: Since the window size can be used in this manner to manage the rate at which
    data flows between the devices at the ends of the connection, it is the method
    by which TCP implements *flow control*, one of the classic jobs of the transport
    layer. Flow control is vitally important to TCP, as it is the method by which
    devices communicate their status to each other. By reducing or increasing window
    size, the server and client each ensure that the other device sends data just
    as fast as the recipient can deal with it.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 由于窗口大小可以用来以这种方式管理连接两端设备之间数据流动的速率，因此它是TCP实现*流量控制*的方法之一，这是传输层的经典任务。流量控制对TCP至关重要，因为它是设备相互通信状态的方法。通过减小或增加窗口大小，服务器和客户端都确保对方设备发送数据的速度与接收方处理数据的速度相匹配。
- en: Reducing Send Window Size to Reduce the Rate Data Is Sent
  id: totrans-1073
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过减小发送窗口大小来降低发送数据速率
- en: 'To understand window size adjustment, let''s go back to our earlier example
    in [Chapter 48](ch48.html "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER"),
    but with a few changes. First, to keep things simple, let''s just look at the
    transmissions made from the client to the server, not the server''s replies (other
    than acknowledgments)—this is illustrated in [Figure 48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "Figure 48-7. TCP transaction example showing client''s send pointers The transaction
    of Table 48-6 from the perspective of the client. See Figure 48-6 for the server''s
    pointers."). As before, the client sends 140 bytes to the server. After sending
    the 140 bytes, the client has 220 bytes remaining in its usable window: 360 bytes
    in the send window less the 140 bytes it just sent.'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解窗口大小调整，让我们回到我们之前的例子[第48章](ch48.html "第48章。TCP消息格式和数据传输")，但做一些修改。首先，为了使事情简单，我们只需查看客户端向服务器发送的传输，而不是服务器的回复（除了确认）——这如图[图48-7](ch48s04.html#tcp_transaction_example_showing_clients_
    "图48-7。TCP事务示例显示客户端的发送指针。从客户端的角度看表48-6的事务。参见图48-6以了解服务器的指针。")所示。与之前一样，客户端向服务器发送140字节。发送140字节后，客户端在其可用窗口中剩余220字节：发送窗口中的360字节减去它刚刚发送的140字节。
- en: Sometime later, the server receives the 140 bytes and puts them in the buffer.
    Now, in an ideal world, the 140 bytes go into the buffer, and they are acknowledged
    and immediately removed from the buffer. Another way of thinking of this is that
    the buffer is of infinite size and can hold as much as the client can send. The
    buffer's free space remains 360 bytes in size, so the same window size can be
    advertised back to the client. This was the simplification in the previous example.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候之后，服务器接收到了140字节并将它们放入缓冲区。现在，在一个理想的世界里，140字节进入缓冲区，它们被确认并立即从缓冲区中移除。另一种思考方式是，缓冲区是无限大小的，可以容纳客户端发送的所有数据。缓冲区的空闲空间保持360字节大小，因此可以再次向客户端宣传相同的窗口大小。这就是前一个示例中的简化。
- en: As long as the server can process the data as fast as it comes in, it will keep
    the window size at 360 bytes. The client, upon receipt of the acknowledgment of
    140 bytes and the same window size it had before, slides the full 360-byte window
    140 bytes to the right. Since there are now 0 unacknowledged bytes, the client
    can now once again send 360 bytes of data. These correspond to the 220 bytes that
    were formerly in the usable window, plus 140 new bytes for the ones that were
    just acknowledged.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 只要服务器能够以与数据到达速度相同的速度处理数据，它就会保持窗口大小为360字节。客户端在收到140字节的确认和之前相同的窗口大小时，将整个360字节的窗口向右滑动140字节。由于现在没有未确认的字节，客户端现在可以再次发送360字节的数据。这些对应于之前在可用窗口中的220字节，加上刚刚确认的140个新字节。
- en: In the real world, however, that server might be dealing with dozens, hundreds,
    or even thousands of TCP connections. TCP might not be able to process the data
    immediately. Alternatively, it is possible the application itself might not be
    ready for the 140 bytes for whatever reason. In either case, the server's TCP
    may not be able to immediately remove all 140 bytes from the buffer. If so, upon
    sending an acknowledgment back to the client, the server will want to change the
    window size that it advertises to the client, to reflect the fact that the buffer
    is partially filled.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界中，该服务器可能正在处理数十、数百甚至数千个TCP连接。TCP可能无法立即处理数据。或者，可能由于某种原因，应用程序本身可能还没有准备好处理140字节的数据。在任何情况下，服务器的TCP可能无法立即从缓冲区中移除所有140字节。如果是这样，当向客户端发送确认时，服务器将希望更改它向客户端宣传的窗口大小，以反映缓冲区部分已满的事实。
- en: Suppose that we receive 140 bytes, but are able to send only 40 bytes to the
    application, leaving 100 bytes in the buffer. When we send back the acknowledgment
    for the 140 bytes, the server can reduce its send window by 100 bytes, to 260
    bytes. When the client receives this segment from the server, it will see the
    acknowledgment of the 140 bytes sent and slide its window 140 bytes to the right.
    However, as it slides this window, it reduces its size to only 260 bytes. We can
    consider this as sliding the *left edge* of the window 140 bytes, but the *right
    edge* only 40 bytes. The new, smaller window ensures that the server receives
    a maximum of 260 bytes from the client, which will fit in the 260 bytes remaining
    in its receive buffer. This is illustrated in the first exchange of messages (steps
    1 through 3) at the top of [Figure 49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "Figure 49-4. TCP window size adjustments and flow control This diagram shows
    three message cycles, each of which results in the server reducing its receive
    window. In the first cycle, the server reduces it from 360 to 260 bytes, so the
    client's usable window can increase by only 40 bytes when it gets the server's
    acknowledgment. In the second and third cycles, the server reduces the window
    size by the amount of data it receives, which temporarily freezes the client's
    send window size, halting it from sending new data.").
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们收到了140字节，但只能向应用程序发送40字节，留下100字节在缓冲区中。当我们发送140字节的确认时，服务器可以将发送窗口减少100字节，变为260字节。当客户端从服务器接收到这个段时，它将看到发送的140字节的确认，并将窗口向右滑动140字节。然而，在滑动这个窗口时，它将窗口大小减少到只有260字节。我们可以将这视为将窗口的*左边缘*向右滑动140字节，但*右边缘*只向右滑动40字节。新的、更小的窗口确保服务器从客户端接收的最大字节数为260字节，这将适合其接收缓冲区中剩余的260字节。这在上面的[图49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "图49-4. TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期中，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二和第三个周期中，服务器根据接收到的数据量减少窗口大小，这暂时冻结了客户端的发送窗口大小，使其停止发送新数据。")的第一次消息交换（步骤1至3）中得到了说明。
- en: '![TCP window size adjustments and flow control This diagram shows three message
    cycles, each of which results in the server reducing its receive window. In the
    first cycle, the server reduces it from 360 to 260 bytes, so the client''s usable
    window can increase by only 40 bytes when it gets the server''s acknowledgment.
    In the second and third cycles, the server reduces the window size by the amount
    of data it receives, which temporarily freezes the client''s send window size,
    halting it from sending new data.](httpatomoreillycomsourcenostarchimages288137.png.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二个和第三个周期，服务器通过接收到的数据量来减少窗口大小，这暂时冻结了客户端的发送窗口大小，阻止其发送新数据。](httpatomoreillycomsourcenostarchimages288137.png.jpg)'
- en: Figure 49-4. TCP window size adjustments and flow control This diagram shows
    three message cycles, each of which results in the server reducing its receive
    window. In the first cycle, the server reduces it from 360 to 260 bytes, so the
    client's usable window can increase by only 40 bytes when it gets the server's
    acknowledgment. In the second and third cycles, the server reduces the window
    size by the amount of data it receives, which temporarily freezes the client's
    send window size, halting it from sending new data.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-4. TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期中，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二个和第三个周期中，服务器通过接收到的数据量来减少窗口大小，这暂时冻结了客户端的发送窗口大小，阻止其发送新数据。
- en: Reducing Send Window Size to Stop the Sending of New Data
  id: totrans-1081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少发送窗口大小以停止发送新数据
- en: What if the server is so bogged down that it cannot process *any* of the bytes
    received? Let's suppose that the next transmission from the client is 180 bytes
    in size, but the server is so busy it cannot remove any of them.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器如此繁忙以至于无法处理接收到的任何字节怎么办？假设客户端的下一个传输大小为180字节，但服务器如此繁忙以至于无法移除任何字节。
- en: 'In this case, the server could buffer the 180 bytes and, in the acknowledgment
    it sends for those bytes, reduce the window size by the same amount: from 260
    to 80 bytes. When the client received the acknowledgment for 180 bytes, it would
    see the window size had reduced by 180 bytes as well. It would slide its window
    by the same amount as the window size was reduced! This is effectively like the
    server saying, "I acknowledge receipt of 180 bytes, but I am not allowing you
    to send any new bytes to replace them." Another way of looking at this is that
    the left edge of the window slides 180 bytes, while the right edge remains fixed.
    And as long as the right edge of the window doesn''t move, the client cannot send
    any more data than it could before receipt of the acknowledgment. This is the
    middle exchange (steps 4 to 6) in [Figure 49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "Figure 49-4. TCP window size adjustments and flow control This diagram shows
    three message cycles, each of which results in the server reducing its receive
    window. In the first cycle, the server reduces it from 360 to 260 bytes, so the
    client''s usable window can increase by only 40 bytes when it gets the server''s
    acknowledgment. In the second and third cycles, the server reduces the window
    size by the amount of data it receives, which temporarily freezes the client''s
    send window size, halting it from sending new data.").'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器可以缓冲180字节，并在它发送的这些字节的确认中，将窗口大小减少相同的量：从260字节减少到80字节。当客户端收到180字节的确认时，它会看到窗口大小也减少了180字节。它会将窗口滑动相同的量，就像窗口大小减少一样！这实际上就像服务器说：“我确认收到了180字节，但不允许你发送任何新字节来替换它们。”另一种看待方式是，窗口的左边缘滑动180字节，而右边缘保持固定。只要窗口的右边缘不移动，客户端就不能发送比确认接收之前更多的数据。这是图49-4中的中间交换（步骤4到6）[图49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "图49-4. TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二个和第三个周期，服务器通过接收到的数据量来减少窗口大小，这暂时冻结了客户端的发送窗口大小，阻止其发送新数据。")。
- en: Closing the Send Window
  id: totrans-1084
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭发送窗口
- en: This process of window adjustment can continue, and, of course, can be done
    by both devices, even though we are considering only the client-sends-to-server
    side of the equation here. If the server continues to receive data from the client
    faster than it can pump it out to the application, it will continue to reduce
    the size of its receive window.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口调整的过程可以继续，当然，这可以通过两个设备来完成，尽管我们在这里只考虑等式中的客户端发送到服务器的一侧。如果服务器从客户端接收数据的速度超过了它可以将数据泵送到应用程序的速度，它将继续减少其接收窗口的大小。
- en: To continue our example, suppose that after the send window is reduced to 80
    bytes, the client sends a third request, this one 80 bytes in length, but the
    server is still busy. The server then reduces its window all the way down to 0,
    which is called *closing* the window. This tells the client the server is very
    overloaded, and it should stop routine sending of data entirely, as shown in the
    bottom third of [Figure 49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "Figure 49-4. TCP window size adjustments and flow control This diagram shows
    three message cycles, each of which results in the server reducing its receive
    window. In the first cycle, the server reduces it from 360 to 260 bytes, so the
    client's usable window can increase by only 40 bytes when it gets the server's
    acknowledgment. In the second and third cycles, the server reduces the window
    size by the amount of data it receives, which temporarily freezes the client's
    send window size, halting it from sending new data."). Later on, when the server
    is less loaded down, it can increase the window size for this connection again,
    permitting more data to be transferred.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的例子，假设在发送窗口减少到80字节后，客户端发送了第三个请求，这次请求长度也是80字节，但服务器仍然很忙。然后服务器将窗口大小降低到0，这被称为*关闭*窗口。这告诉客户端服务器非常繁忙，它应该完全停止常规的数据发送，如[图49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "图49-4. TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期中，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二和第三个周期中，服务器根据接收到的数据量减少窗口大小，这暂时冻结了客户端的发送窗口大小，阻止它发送新数据。")底部三分之一所示。稍后，当服务器负载减轻时，它可以再次增加此连接的窗口大小，允许传输更多数据。
- en: Tip
  id: totrans-1087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The TCP sliding window system is used not just for ensuring
    reliability through acknowledgments and retransmissions, but it is also the basis
    for TCP''s flow control mechanism. By increasing or reducing the size of its receive
    window, a device can raise or lower the rate at which its connection partner sends
    it data. In the case where a device becomes extremely busy, it can even reduce
    the receive window to zero. This will close the window and halt any further transmissions
    of data until the window is reopened.'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP滑动窗口系统不仅用于通过确认和重传确保可靠性，它也是TCP流量控制机制的基础。通过增加或减少其接收窗口的大小，一个设备可以提高或降低其连接伙伴向其发送数据的速率。在设备变得极其繁忙的情况下，它甚至可以将接收窗口减少到零。这将关闭窗口并停止任何进一步的数据传输，直到窗口重新打开。'
- en: While conceptually simple, flow control using window size adjustment can be
    very tricky. If we aren't careful about how we make changes to window size, we
    can introduce serious problems in the operation of TCP. There are also special
    situations that can occur, especially in cases where the window size is made small
    in response to a device becoming busy. The next two sections explore window management
    issues and changes that need to be made to the basic sliding window system to
    address them.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从概念上讲很简单，但使用窗口大小调整进行流量控制可能会非常复杂。如果我们不仔细考虑如何更改窗口大小，我们可能会在TCP的操作中引入严重问题。还有一些特殊情况可能会发生，尤其是在窗口大小因设备变得繁忙而减小的情况下。接下来的两个部分将探讨窗口管理问题以及需要对这些基本滑动窗口系统进行哪些更改来解决这些问题。
- en: TCP Window Management Issues
  id: totrans-1090
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP窗口管理问题
- en: Each of the two devices on a TCP connection can adjust the window size it advertises
    to the other, to control the flow of data over the connection. Reducing the size
    of the window forces the other device to send less data; increasing the window
    size lets more data flow. In theory, we should be able to just let the TCP software
    on each of the devices change the window size as needed to match the speed at
    which data both enters the buffer and is removed from it to be sent to the receiving
    application.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接上的两个设备中的每一个都可以调整它向另一个设备广告的窗口大小，以控制通过连接的数据流。减小窗口大小迫使另一个设备发送更少的数据；增加窗口大小允许更多数据流动。在理论上，我们应该能够让每个设备上的TCP软件根据数据进入缓冲区和从缓冲区移除以发送到接收应用程序的速度来按需更改窗口大小。
- en: Unfortunately, certain changes in window size can lead to undesirable consequences.
    These can occur both when the size of the window is reduced and when it is increased.
    For this reason, there are a few issues related to *window size management* that
    we need to consider. As in previous sections, we'll use for illustration a modification
    of the same client/server example introduced in [Chapter 48](ch48.html "Chapter 48. TCP
    MESSAGE FORMATTING AND DATA TRANSFER").
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，窗口大小的某些变化可能会导致不希望的结果。这些情况不仅发生在窗口大小减小的时候，也发生在窗口大小增加的时候。因此，我们需要考虑与*窗口大小管理*相关的一些问题。正如前几节所做的那样，我们将使用之前在[第48章](ch48.html
    "第48章。TCP消息格式和数据传输")中引入的相同的客户端/服务器示例进行说明。
- en: Problems Associated with Shrinking the TCP Window
  id: totrans-1093
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩小TCP窗口相关的问题
- en: One window size management matter is related to just how quickly a device reduces
    the size of its receive window when it gets busy. Let's say the server starts
    with a 360-byte receive window, as in the aforementioned example, and receives
    140 bytes of data that it acknowledges but cannot remove from the buffer immediately.
    The server can respond by reducing the size of the window it advertises back to
    the client. In the case where no bytes can be removed from the buffer at all,
    the window size is reduced by the same 140 bytes that were added to the buffer.
    This freezes the right edge of the client's send window, so it cannot send any
    additional data when it gets an acknowledgment.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与窗口大小管理相关的问题是与设备在变得繁忙时如何快速减小其接收窗口大小。假设服务器从360字节的接收窗口开始，正如上述示例中所述，并接收了140字节的数据，它确认了这些数据，但无法立即从缓冲区中移除。服务器可以通过减小它向客户端广告的窗口大小来响应。在无法从缓冲区中移除任何字节的情况下，窗口大小会减少140字节，这是添加到缓冲区中的相同字节。这冻结了客户端发送窗口的右边缘，因此当它收到确认时，无法发送任何额外的数据。
- en: What if the server were so overloaded that we actually needed to reduce the
    size of the *buffer* itself? Say memory was short and the operating system said,
    "I know you have 360 bytes allocated for the receive buffer for this connection,
    but I need to free up memory, so now you only have 240." The server still cannot
    immediately process the 140 bytes it received, so it would need to drop the window
    size it sent back to the client all the way from 360 bytes down to 100 bytes (240
    in the total buffer less the 140 already received).
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器超载到实际上需要减小*缓冲区*本身的大小怎么办？比如说内存不足，操作系统说：“我知道你为这个连接分配了360字节的接收缓冲区，但我需要释放内存，所以现在你只有240字节。”服务器仍然不能立即处理它接收到的140字节，因此它需要将发送给客户端的窗口大小从360字节减少到100字节（总缓冲区240字节减去已接收的140字节）。
- en: In effect, doing this actually moves the right edge of the client's send window
    *back to the left*. It says, "Not only can't you send more data when you receive
    this acknowledgment, but you now can send *less*when you do send data." In TCP
    parlance, this is called *shrinking the window*.
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这样做实际上是将客户端发送窗口的右边缘*向左移动*。它说：“当你收到这个确认时，不仅不能发送更多数据，而且你现在发送的数据*更少*。”在TCP术语中，这被称为*缩小窗口*。
- en: 'There''s a very serious problem with doing this, however: While the original
    140 bytes were in transit from the client to the server, the client still thought
    it had 360 bytes of total window, of which 220 bytes were *usable* (360 less 140).
    The client may well have already sent some of those 220 bytes of data to the server
    before it got the notification that the server had shrunk the window! If so, and
    the server reduced its buffer to 240 bytes with 140 used, when those 220 bytes
    showed up at the server, only 100 would fit, and any additional ones would need
    to be discarded. This would force the client to need to retransmit that data,
    which is inefficient. [Figure 49-5](ch49s05.html#the_problem_with_shrinking_the_tcp_windo
    "Figure 49-5. The problem with shrinking the TCP window In this modification of
    the example of Figure 49-4, the client begins with a usable window size of 360
    bytes. It sends a 140-byte segment and then a short time thereafter sends one
    of 180 bytes. The server is busy, however, and when it receives the first transmission,
    it decides to reduce its buffer to 240 bytes. It holds the 140 bytes just received
    and reduces its receive window all the way down to 100 bytes. When the client''s
    180-byte segment arrives, there is room for only 100 of the 180 bytes in the server''s
    buffer. When the client gets the new window size advertisement of 100, it will
    have a problem, because it already has 180 bytes sent but not acknowledged.")
    illustrates graphically how this situation would play out.'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做有一个非常严重的问题：当原始的140字节从客户端传输到服务器时，客户端仍然认为它有360字节的窗口大小，其中220字节是*可用的*（360减去140）。客户端很可能已经向服务器发送了那220字节数据中的一些，在它收到服务器缩小窗口的通知之前！如果是这样，并且服务器将缓冲区减少到140字节使用后240字节，当那220字节到达服务器时，只有100字节可以容纳，任何额外的字节都需要被丢弃。这将迫使客户端需要重新传输那些数据，这是低效的。[图49-5](ch49s05.html#the_problem_with_shrinking_the_tcp_windo
    "图49-5. 缩小TCP窗口的问题 在这个对图49-4例子的修改中，客户端开始时有一个360字节的可用窗口大小。它发送了一个140字节的段，然后不久之后发送了一个180字节的段。然而，服务器很忙，当它接收到第一次传输时，它决定将缓冲区减少到240字节。它保留了刚刚接收到的140字节，并将接收窗口减少到100字节。当客户端的180字节段到达时，服务器缓冲区中只有100字节的空间。当客户端收到新的窗口大小广告100时，它将遇到问题，因为它已经发送了180字节但尚未得到确认。")直观地说明了这种情况会如何发展。
- en: '![The problem with shrinking the TCP window In this modification of the example
    of , the client begins with a usable window size of 360 bytes. It sends a 140-byte
    segment and then a short time thereafter sends one of 180 bytes. The server is
    busy, however, and when it receives the first transmission, it decides to reduce
    its buffer to 240 bytes. It holds the 140 bytes just received and reduces its
    receive window all the way down to 100 bytes. When the client''s 180-byte segment
    arrives, there is room for only 100 of the 180 bytes in the server''s buffer.
    When the client gets the new window size advertisement of 100, it will have a
    problem, because it already has 180 bytes sent but not acknowledged.](httpatomoreillycomsourcenostarchimages288139.png.jpg)'
  id: totrans-1098
  prefs: []
  type: TYPE_IMG
  zh: '![缩小TCP窗口的问题 在这个对图49-4例子的修改中，客户端开始时有一个360字节的可用窗口大小。它发送了一个140字节的段，然后不久之后发送了一个180字节的段。然而，服务器很忙，当它接收到第一次传输时，它决定将缓冲区减少到240字节。它保留了刚刚接收到的140字节，并将接收窗口减少到100字节。当客户端的180字节段到达时，服务器缓冲区中只有100字节的空间。当客户端收到新的窗口大小广告100时，它将遇到问题，因为它已经发送了180字节但尚未得到确认。](httpatomoreillycomsourcenostarchimages288139.png.jpg)'
- en: Figure 49-5. The problem with shrinking the TCP window In this modification
    of the example of [Figure 49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "Figure 49-4. TCP window size adjustments and flow control This diagram shows
    three message cycles, each of which results in the server reducing its receive
    window. In the first cycle, the server reduces it from 360 to 260 bytes, so the
    client's usable window can increase by only 40 bytes when it gets the server's
    acknowledgment. In the second and third cycles, the server reduces the window
    size by the amount of data it receives, which temporarily freezes the client's
    send window size, halting it from sending new data."), the client begins with
    a usable window size of 360 bytes. It sends a 140-byte segment and then a short
    time thereafter sends one of 180 bytes. The server is busy, however, and when
    it receives the first transmission, it decides to reduce its buffer to 240 bytes.
    It holds the 140 bytes just received and reduces its receive window all the way
    down to 100 bytes. When the client's 180-byte segment arrives, there is room for
    only 100 of the 180 bytes in the server's buffer. When the client gets the new
    window size advertisement of 100, it will have a problem, because it already has
    180 bytes sent but not acknowledged.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-5. 缩小TCP窗口的问题 在对[图49-4](ch49s04.html#tcp_window_size_adjustments_and_flow_con
    "图49-4. TCP窗口大小调整和流量控制 此图显示了三个消息周期，每个周期都会导致服务器减少其接收窗口。在第一个周期，服务器将其从360字节减少到260字节，因此当客户端收到服务器的确认时，其可用窗口只能增加40字节。在第二和第三个周期，服务器根据接收到的数据量减少窗口大小，这暂时冻结了客户端的发送窗口大小，使其停止发送新数据。"),客户端的可用窗口大小从360字节开始。它发送了一个140字节的段，然后不久之后发送了一个180字节的段。然而，服务器很忙，当它收到第一次传输时，它决定将缓冲区减少到240字节。它保留了刚刚接收到的140字节，并将接收窗口一直减少到100字节。当客户端的180字节段到达时，服务器缓冲区中只有100字节的空间。当客户端收到新的窗口大小广告为100时，它将遇到问题，因为它已经发送了180字节但尚未得到确认。
- en: Reducing Buffer Size Without Shrinking the Window
  id: totrans-1100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少缓冲区大小而不缩小窗口
- en: 'To prevent the problems associated with shrinking windows from occurring, TCP
    adds a simple rule to the basic sliding window mechanism: A device is not allowed
    to shrink the window.'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止与窗口缩小相关的问题发生，TCP向基本的滑动窗口机制添加了一条简单规则：不允许设备缩小窗口。
- en: Note that there is a potential terminology ambiguity here. The words *shrinking*
    and *reducing* are sometimes used synonymously in colloquial discussions. As we've
    seen, there's nothing wrong with *reducing* the size of the window. The problem
    of *shrinking* the window refers only to the case where we reduce the window size
    so much that we contradict a prior window advertisement by *taking back* permission
    to send a certain number of bytes.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里存在一个潜在的术语模糊性。在日常讨论中，*缩小*和*减少*这两个词有时被同义使用。正如我们所见，*减少*窗口大小并没有什么问题。*缩小*窗口的问题仅指我们减少窗口大小到与先前的窗口广告相矛盾，通过*收回*发送一定数量字节的权限。
- en: Another way of looking at this is that *shrinking* occurs whenever the server
    sends back a window size advertisement smaller than what the client considers
    its usable window size to be at that time. In this case, the server shrunk the
    window, because at the time it was acknowledging the 140 bytes, it sent back a
    window size of 100, which is less than the 220-byte usable window the client had
    then.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，*缩小*发生在服务器发送回的窗口大小广告小于客户端认为其当时可用窗口大小的时候。在这种情况下，服务器缩小了窗口，因为在它确认140字节的时候，它发送回的窗口大小为100，这小于客户端当时的220字节可用窗口。
- en: Of course, there may be cases where we *do* need to reduce a buffer, so how
    should this be handled? Instead of shrinking the window, the server must be more
    patient. In the example in the previous section, where the buffer needs to be
    reduced to 240 bytes, the server must send back a window size of 220, freezing
    the right edge of the client's send window. The client can still fill the 360-byte
    buffer, but it cannot send more than that. As soon as 120 bytes are removed from
    the server's receive buffer, the buffer can then be reduced in size to 240 bytes
    with no data loss. Then the server can resume normal operation, increasing the
    window size as bytes are taken from the receive buffer.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能会有需要减少缓冲区的情况，那么应该如何处理呢？与缩小窗口不同，服务器必须更加耐心。在上一节中的例子中，当缓冲区需要减少到240字节时，服务器必须发送一个窗口大小为220的字节，从而冻结客户端发送窗口的右边缘。客户端仍然可以填满360字节的缓冲区，但不能发送超过这个量。一旦从服务器的接收缓冲区中移除120字节，缓冲区就可以在不丢失数据的情况下减小到240字节。然后服务器可以恢复正常操作，随着从接收缓冲区中取走字节，增加窗口大小。
- en: Tip
  id: totrans-1105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A phenomenon called *shrinking* the *window* occurs when a
    device reduces its receive window so much that its partner device''s usable transmit
    window shrinks in size (meaning that the right edge of its send window moves to
    the left). Since this can result in data already in transit needing to be discarded,
    devices must instead reduce their receive window size more gradually.'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 当一个设备将其接收窗口减小到足以使对方设备的可用发送窗口缩小（意味着其发送窗口的右边缘向左移动）的程度时，就会发生称为 *窗口缩小*
    的现象。由于这可能导致正在传输的数据需要被丢弃，因此设备必须更逐渐地减小其接收窗口的大小。'
- en: Handling a Closed Window and Sending Probe Segments
  id: totrans-1107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理关闭的窗口和发送探测段
- en: Another special window management problem is how to deal with the case where
    a device must reduce the send window size all the way down to zero. As noted earlier,
    this is called *closing the receive window*. Since the server's receive window
    is the client's send window, reducing its size to zero means the client cannot
    send any more data. This situation continues until the client receives from the
    server a new acknowledgment with a nonzero Window field, which reopens the window.
    Then the client is able to send again.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊的窗口管理问题是如何处理一个设备必须将发送窗口大小减小到零的情况。如前所述，这被称为 *关闭接收窗口*。由于服务器的接收窗口是客户端的发送窗口，将其大小减小到零意味着客户端无法发送任何数据。这种情况将持续到客户端从服务器接收到一个包含非零窗口字段的新的确认段，从而重新打开窗口。然后客户端能够再次发送数据。
- en: The problem with this situation is that the client must depend on receipt of
    the "window opening" segment from the server. Like all TCP segments, this segment
    is carried over IP, which is unreliable. Remember that TCP is reliable only because
    it acknowledges sent data and retransmits lost data if necessary, but it can never
    *guarantee* that any particular segment gets to its destination. This means that
    when the server tries to reopen the window with an acknowledgment segment containing
    a larger Window field, it's possible that the client will never get the message.
    The client might conclude that a problem had occurred and terminate the connection.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的问题在于客户端必须依赖于从服务器接收“窗口打开”段。像所有TCP段一样，这个段是通过IP传输的，这是不可靠的。记住，TCP之所以可靠，是因为它会确认发送的数据，并在必要时重新传输丢失的数据，但它永远不能
    *保证* 任何特定的段能够到达目的地。这意味着当服务器尝试通过包含较大窗口字段的确认段重新打开窗口时，客户端可能永远不会收到这条消息。客户端可能会得出结论，发生了问题，并终止连接。
- en: To prevent this from happening, the client can regularly send special *probe*
    segments to the server. The purpose of these probes is to prompt the server to
    send back a segment containing the current window size. The probe segment can
    contain either zero or one byte of data, even when the window is closed. The probes
    will continue to be sent periodically until the window reopens, with the particular
    implementation determining the rate at which the probes are generated.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，客户端可以定期向服务器发送特殊的 *探测* 段。这些探测的目的在于促使服务器发送包含当前窗口大小的段。探测段可以包含零个或一个字节的数据，即使窗口关闭时也是如此。探测将定期发送，直到窗口重新打开，具体的实现决定了探测生成的速率。
- en: Tip
  id: totrans-1111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A device that reduces its receive window to zero is said to
    have *closed* the window. The other device''s send window is thus closed; it may
    not send regular data segments. It may, however, send probe segments to check
    the status of the window, thus making sure it does not miss notification when
    the window reopens.'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 将接收窗口减少到零的设备被称为*关闭*了窗口。另一个设备的发送窗口因此关闭；它可能不会发送常规数据段。然而，它可以发送探测段来检查窗口的状态，从而确保在窗口重新打开时不会错过通知。'
- en: 'When the server decides to reopen the closed window, there is another potential
    pitfall: opening the window to too small a value. In general, when the receive
    window is too small, this leads to the generation of many small segments, greatly
    reducing the overall efficiency of TCP. The next section explores this well-known
    problem and how it is resolved through changes to the basic sliding window mechanism.'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器决定重新打开关闭的窗口时，还有一个潜在的风险：将窗口打开得太小。一般来说，当接收窗口太小时，这会导致生成许多小段，大大降低TCP的整体效率。下一节将探讨这个众所周知的问题以及它是如何通过改变基本的滑动窗口机制来解决的。
- en: TCP Silly Window Syndrome
  id: totrans-1114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP愚蠢窗口综合征
- en: In the description of TCP's maximum segment size (MSS) parameter in [Chapter 48](ch48.html
    "Chapter 48. TCP MESSAGE FORMATTING AND DATA TRANSFER"), I explained the trade-off
    in determining the optimal size of TCP segments. If segments are too large, we
    risk having them become fragmented at the IP level. If they're too small, we get
    greatly reduced performance, because we are sending a small amount of data in
    a segment with at least 40 bytes of header overhead. We also use up valuable processing
    time that is required to handle each of these small segments.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第48章](ch48.html "第48章。TCP消息格式和数据传输")中描述TCP的最大段大小（MSS）参数时，我解释了确定TCP段最佳大小的权衡。如果段太大，我们可能会在IP层上使它们碎片化。如果它们太小，我们会因为在一个至少有40字节头开销的段中发送少量数据而大大降低性能。我们还消耗了处理这些小段所需的有价值的处理时间。
- en: The MSS parameter ensures that we don't send segments that are too large; TCP
    is not allowed to create a segment larger than the MSS. Unfortunately, the basic
    sliding windows mechanism doesn't provide any *minimum* size of segment that can
    be transmitted. In fact, not only is it *possible* for a device to send very small,
    inefficient segments, the simplest implementation of flow control using unrestricted
    window size adjustments *ensures* that under conditions of heavy load, window
    size will become small, leading to significant performance reduction!
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: MSS参数确保我们不会发送过大的段；TCP不允许创建大于MSS的段。不幸的是，基本的滑动窗口机制并没有提供任何*最小*的段大小，可以传输。实际上，设备发送非常小、效率低下的段是*可能*的，而使用不受限制的窗口大小调整的最简单流量控制实现*确保*在重负载条件下，窗口大小会变得很小，从而导致性能显著下降！
- en: How Silly Window Syndrome Occurs
  id: totrans-1117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 愚蠢窗口综合征是如何发生的
- en: To see how the *silly window syndrome (SWS)* can happen, let's consider an example
    that is a variation on the one we've been using so far in this section. We'll
    assume the MSS is 360 bytes and a client/server pair where the server's initial
    receive window is set to this same value, 360\. This means the client can send
    a full-sized segment to the server. As long as the server can keep removing the
    data from the buffer as fast as the client sends it, we should have no problem.
    (In reality, the buffer size would normally be larger than the MSS.)
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解*愚蠢窗口综合征（SWS）*是如何发生的，让我们考虑一个例子，这个例子是对本节中我们一直在使用的例子的一个变体。我们假设MSS是360字节，一个客户端/服务器对，其中服务器的初始接收窗口设置为这个相同的值，360。这意味着客户端可以向服务器发送一个完整大小的段。只要服务器能够以与客户端发送的速度一样快地从缓冲区中移除数据，我们就应该没有问题。（实际上，缓冲区的大小通常会比MSS大。）
- en: 'Now, imagine that instead, the server is bogged down for whatever reason while
    the client needs to send it a great deal of data. For simplicity, let''s say that
    the server is able to remove only 1 byte of data from the buffer for every 3 bytes
    it receives. Let''s say it also removes 40 additional bytes from the buffer during
    the time it takes for the next client''s segment to arrive. Here''s what will
    happen:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果服务器因为某种原因而变得繁忙，而客户端需要向它发送大量数据。为了简单起见，让我们假设服务器只能从缓冲区中移除每个接收到的3字节中的1字节数据。让我们还说，在下一个客户端段到达的时间内，它还从缓冲区中移除了额外的40字节。以下是会发生的事情：
- en: The client's send window is 360 bytes, and it has a lot of data to send. It
    immediately sends a 360-byte segment to the server. This uses up its entire send
    window.
  id: totrans-1120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端的发送窗口是360字节，并且它有很多数据要发送。它立即向服务器发送一个360字节的段。这用完了它的整个发送窗口。
- en: When the server gets this segment, it acknowledges it. However, it can remove
    only 120 bytes, so the server reduces the window size from 360 to 120 bytes. It
    sends this in the Window field of the acknowledgment.
  id: totrans-1121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当服务器收到这个段时，它会进行确认。然而，它只能删除120字节，因此服务器将窗口大小从360字节减少到120字节。它在确认的窗口字段中发送这个信息。
- en: The client receives an acknowledgment of 360 bytes and sees that the window
    size has been reduced to 120\. It wants to send its data as soon as possible,
    so it sends off a 120-byte segment.
  id: totrans-1122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端收到360字节的确认，并看到窗口大小已减少到120字节。它想尽快发送数据，因此发送了一个120字节的段。
- en: The server has removed 40 more bytes from the buffer by the time the 120-byte
    segment arrives. The buffer thus contains 200 bytes (240 from the first segment,
    less the 40 removed). The server is able to immediately process one-third of those
    120 bytes, or 40 bytes. This means 80 bytes are added to the 200 that already
    remain in the buffer, so 280 bytes are used up. The server must reduce the window
    size to 80 bytes.
  id: totrans-1123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当120字节的段到达时，服务器已经从缓冲区中删除了40更多字节。因此，缓冲区包含200字节（第一个段中的240字节减去删除的40字节）。服务器能够立即处理这120字节中的三分之一，即40字节。这意味着向已经留在缓冲区中的200字节中添加了80字节，所以用掉了280字节。服务器必须将窗口大小减少到80字节。
- en: The client will see this reduced window size and send an 80-byte segment.
  id: totrans-1124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将看到这个减少的窗口大小，并发送一个80字节的段。
- en: The server started with 280 bytes and removed 40, so 240 bytes remain. It receives
    80 bytes from the client and removes one-third, so 53 are added to the buffer,
    which becomes 293 bytes. It reduces the window size to 67 bytes (360 minus 293).
  id: totrans-1125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器最初有280字节，删除了40字节，所以剩下240字节。它从客户端接收80字节，并删除三分之一，因此向缓冲区中添加了53字节，缓冲区变为293字节。它将窗口大小减少到67字节（360减去293）。
- en: This process, which is illustrated in [Figure 49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr
    "Figure 49-6. TCP silly window syndrome (SWS) This diagram shows one example of
    how the phenomenon known as TCP silly window syndrome can arise. The client is
    trying to send data as fast as possible to the server, which is very busy and
    cannot clear its buffers promptly. Each time the client sends data, the server
    reduces its receive window. The size of the messages the client sends shrinks
    until it is sending only very small, inefficient segments. Note that in this diagram,
    I have shown the server's buffer fixed in position, rather than sliding to the
    right, as in the other diagrams in this chapter. This way, you can see the receive
    window decreasing in size more easily."), will continue for many rounds, with
    the window size getting smaller and smaller, especially if the server gets even
    more overloaded. Its rate of clearing the buffer may decrease even more, and the
    window may close entirely.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程，如图[图49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr "图49-6.
    TCP愚蠢窗口综合征（SWS）此图展示了TCP愚蠢窗口综合征这一现象的一个例子。客户端试图尽可能快地向服务器发送数据，而服务器非常繁忙，无法及时清空其缓冲区。每次客户端发送数据时，服务器都会减少其接收窗口。客户端发送的消息大小会缩小，直到它只发送非常小、效率低下的段。请注意，在此图中，我将服务器的缓冲区固定在位置，而不是像本章其他图那样向右滑动。这样，你可以更容易地看到接收窗口大小的减少。"),将会进行多轮，窗口大小会越来越小，尤其是如果服务器负载进一步增加。它清空缓冲区的速度可能会进一步降低，窗口甚至可能完全关闭。
- en: Let's suppose this happens. Now, eventually, the server will remove some of
    the data from this buffer. Let's say it removes 40 bytes by the time the first
    closed-window probe from the client arrives. The server then reopens the window
    to a size of 40 bytes. The client is still desperate to send data as fast as possible,
    so it generates a 40-byte segment. And so it goes, with likely all the remaining
    data passing from the client to the server in tiny segments, until either the
    client runs out of data or the server clears the buffer more quickly.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这种情况发生。最终，服务器将从该缓冲区中删除一些数据。比如说，当客户端的第一个关闭窗口探测到达时，服务器已经删除了40字节。然后服务器将窗口重新打开到40字节的大小。客户端仍然急于尽可能快地发送数据，因此它生成一个40字节的段。就这样，很可能所有剩余的数据都以极小的段从客户端传递到服务器，直到客户端数据耗尽或服务器更快地清空缓冲区。
- en: Now imagine the worst-case scenario. This time, it is the application process
    on the server that is overloaded. It is drawing data from the buffer one byte
    at a time. Every time it removes a byte from the server's buffer, the server's
    TCP opens the window with a window size of exactly 1 and puts this in the Window
    field in an acknowledgment to the client. The client then sends a segment with
    exactly one byte, refilling the buffer until the application draws off the next
    byte.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下最坏的情况。这次，是服务器上的应用程序过程过载。它一次从缓冲区中提取一个字节的数据。每次它从服务器的缓冲区中移除一个字节，服务器的TCP就会打开一个窗口大小正好为1的窗口，并在对客户端的确认中将这个值放入窗口字段。然后客户端发送一个正好包含一个字节的数据段，直到应用程序提取出下一个字节，缓冲区再次被填满。
- en: None of this represents a *failure* per se of the sliding window mechanism.
    It is working properly to keep the server's receive buffer filled and to manage
    the flow of data. The problem is that the sliding window mechanism is concerned
    only with managing the buffer. It doesn't take into account the inefficiency of
    the small segments that result when the window size is micromanaged in this way.
    In essence, by sending small window size advertisements, we are winning the battle
    but losing the war.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切并不代表滑动窗口机制的**失败**本身。它正在正常工作，以保持服务器的接收缓冲区充满并管理数据流。问题是滑动窗口机制只关注管理缓冲区。它没有考虑到当窗口大小以这种方式微管理时，产生的较小数据段的低效性。本质上，通过发送小窗口大小的广告，我们赢得了战斗但输掉了战争。
- en: Early TCP/IP researchers who discovered this phenomenon called it *silly window
    syndrome (SWS)*, a play on the phrase *sliding window system*, which expresses
    their opinion on how it behaves when it gets into this state.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 早期发现这一现象的TCP/IP研究人员将其称为**愚蠢窗口综合征（SWS**），这是对“滑动窗口系统”这一短语的戏谑，表达了他们对系统进入这种状态时行为的看法。
- en: '![TCP silly window syndrome (SWS) This diagram shows one example of how the
    phenomenon known as TCP silly window syndrome can arise. The client is trying
    to send data as fast as possible to the server, which is very busy and cannot
    clear its buffers promptly. Each time the client sends data, the server reduces
    its receive window. The size of the messages the client sends shrinks until it
    is sending only very small, inefficient segments. Note that in this diagram, I
    have shown the server''s buffer fixed in position, rather than sliding to the
    right, as in the other diagrams in this chapter. This way, you can see the receive
    window decreasing in size more easily.](httpatomoreillycomsourcenostarchimages288141.png.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![TCP愚蠢窗口综合征（SWS）此图展示了TCP愚蠢窗口综合征这一现象的一个例子。客户端试图尽可能快地将数据发送到服务器，而服务器非常繁忙，无法及时清除其缓冲区。每当客户端发送数据时，服务器都会减小其接收窗口。客户端发送的消息大小会缩小，直到它只发送非常小、低效的数据段。注意，在此图中，我将服务器的缓冲区固定在位置，而不是像本章其他图中的那样向右滑动。这样，你可以更容易地看到接收窗口大小的减小。](http://atomoreilly.com/source/nostarch/images/288141.png.jpg)'
- en: Figure 49-6. TCP silly window syndrome (SWS) This diagram shows one example
    of how the phenomenon known as TCP silly window syndrome can arise. The client
    is trying to send data as fast as possible to the server, which is very busy and
    cannot clear its buffers promptly. Each time the client sends data, the server
    reduces its receive window. The size of the messages the client sends shrinks
    until it is sending only very small, inefficient segments. Note that in this diagram,
    I have shown the server's buffer fixed in position, rather than sliding to the
    right, as in the other diagrams in this chapter. This way, you can see the receive
    window decreasing in size more easily.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 图49-6. TCP愚蠢窗口综合征（SWS）此图展示了TCP愚蠢窗口综合征这一现象的一个例子。客户端试图尽可能快地将数据发送到服务器，而服务器非常繁忙，无法及时清除其缓冲区。每当客户端发送数据时，服务器都会减小其接收窗口。客户端发送的消息大小会缩小，直到它只发送非常小、低效的数据段。注意，在此图中，我将服务器的缓冲区固定在位置，而不是像本章其他图中的那样向右滑动。这样，你可以更容易地看到接收窗口大小的减小。
- en: The examples discussed show how SWS can be caused by the advertisement of small
    window sizes by a receiving device. It is also possible for SWS to happen if the
    sending device isn't careful about how it generates segments for transmission,
    regardless of the state of the receiver's buffers. For example, suppose the client
    TCP in the example shown in [Figure 49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr
    "Figure 49-6. TCP silly window syndrome (SWS) This diagram shows one example of
    how the phenomenon known as TCP silly window syndrome can arise. The client is
    trying to send data as fast as possible to the server, which is very busy and
    cannot clear its buffers promptly. Each time the client sends data, the server
    reduces its receive window. The size of the messages the client sends shrinks
    until it is sending only very small, inefficient segments. Note that in this diagram,
    I have shown the server's buffer fixed in position, rather than sliding to the
    right, as in the other diagrams in this chapter. This way, you can see the receive
    window decreasing in size more easily.") was receiving data from the sending application
    in blocks of 10 bytes at a time. However, the sending TCP was so impatient to
    get the data to the client that it took each 10-byte block and immediately packaged
    it into a segment, even though the next 10-byte block was coming shortly thereafter.
    This would result in a needless swarm of inefficient 10-byte segments.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论中的示例展示了SWS是如何由接收设备广告的小窗口大小引起的。如果发送设备在生成传输段时不够小心，即使接收方的缓冲区状态如何，也可能发生SWS。例如，假设示例中的客户端TCP以每次10字节的数据块从发送应用程序接收数据。[图49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr
    "图49-6. TCP silly window syndrome (SWS) 此图展示了TCP silly window syndrome这一现象的一个例子。客户端试图尽可能快地将数据发送到服务器，服务器非常繁忙，无法及时清除其缓冲区。每次客户端发送数据时，服务器都会减小其接收窗口。客户端发送的消息大小会缩小，直到它只发送非常小、效率低下的段。注意，在此图中，我将服务器的缓冲区固定在位置，而不是像本章其他图那样向右滑动。这样，你可以更容易地看到接收窗口大小的减小。")，然而，发送TCP如此急切地想要将数据发送到客户端，以至于它将每个10字节的数据块立即打包成一个段，即使下一个10字节的数据块很快就会到来。这会导致不必要的、效率低下的10字节段的蜂拥而至。
- en: Tip
  id: totrans-1134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tip
- en: '**KEY CONCEPT** The basic TCP sliding window system sets no minimum size on
    transmitted segments. Under certain circumstances, this can result in a situation
    where many small, inefficient segments are sent, rather than a smaller number
    of large ones. Affectionately termed silly *window syndrome* (SWS), this phenomenon
    can occur either as a result of a recipient advertising window sizes that are
    too small or a transmitter being too aggressive in immediately sending out very
    small amounts of data.'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 基本的TCP滑动窗口系统不对传输段设置最小大小。在特定情况下，这可能导致发送许多小、效率低下的段，而不是少量大段。亲切地称为silly
    *window syndrome* (SWS)，这一现象可能是由于接收方广告的窗口大小太小或发送方过于积极立即发送非常小的数据量而引起的。'
- en: Silly Window Syndrome Avoidance Algorithms
  id: totrans-1136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Silly Window Syndrome Avoidance Algorithms
- en: 'Since SWS is caused by the basic sliding window system not paying attention
    to the result of decisions that create small segments, dealing with SWS is conceptually
    simple: Change the system so that we avoid small window size advertisements, and
    at the same time, also avoid sending small segments. Since both the sender and
    recipient of data contribute to SWS, changes are made to the behavior of both
    to avoid SWS. These changes are collectively termed *SWS avoidance algorithms*.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SWS是由基本的滑动窗口系统没有关注创建小段的决定的结果引起的，因此处理SWS在概念上是简单的：改变系统，使我们避免广告小窗口大小，同时，也避免发送小段。由于数据发送方和接收方都参与了SWS，因此对两者的行为都进行了修改以避免SWS。这些更改统称为*SWS避免算法*。
- en: Receiver SWS Avoidance
  id: totrans-1138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Receiver SWS Avoidance
- en: Let's start with SWS avoidance by the receiver. As we saw in the previous example,
    the receiver contributed to SWS by reducing the size of its receive window to
    smaller and smaller values. This caused the right edge of the sender's send window
    to move by ever-smaller increments, leading to smaller and smaller segments. To
    avoid SWS, we simply make the rule that the receiver may not update its advertised
    receive window in such a way that this leaves too little usable window space on
    the part of the sender. In other words, we restrict the receiver from moving the
    right edge of the window by too small an amount. The usual minimum that the edge
    may be moved is either the value of the MSS parameter or one-half the buffer size,
    whichever is less.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从接收方的SWS避免开始。正如我们在前面的例子中所看到的，接收方通过减小其接收窗口的大小到更小的值来对SWS做出了贡献。这导致发送方发送窗口的右边缘以越来越小的增量移动，从而产生越来越小的数据段。为了避免SWS，我们简单地制定了一条规则，即接收方不得以这种方式更新其广告的接收窗口，以至于在发送方部分留下太少可用的窗口空间。换句话说，我们限制接收方通过过小的量移动窗口的右边缘。边缘可能移动的通常最小值是MSS参数的值或缓冲区大小的一半，取较小者。
- en: Let's see how we might use this in the example shown in [Figure 49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr
    "Figure 49-6. TCP silly window syndrome (SWS) This diagram shows one example of
    how the phenomenon known as TCP silly window syndrome can arise. The client is
    trying to send data as fast as possible to the server, which is very busy and
    cannot clear its buffers promptly. Each time the client sends data, the server
    reduces its receive window. The size of the messages the client sends shrinks
    until it is sending only very small, inefficient segments. Note that in this diagram,
    I have shown the server's buffer fixed in position, rather than sliding to the
    right, as in the other diagrams in this chapter. This way, you can see the receive
    window decreasing in size more easily."). When the server receives the initial
    360-byte segment from the client and can process only 120 bytes, it does not reduce
    the window size to 120\. It reduces it all the way to zero, closing the window.
    It sends this back to the client, which will then stop and not send a small segment.
    Once the server has removed 60 more bytes from the buffer, it will now have 180
    bytes free, half the size of the buffer. It now opens the window up to 180 bytes
    in size and sends the new window size to the client.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在[图49-6](ch49s06.html#tcp_silly_window_syndrome_sws_this_diagr "图49-6.
    TCP愚蠢窗口综合征（SWS）此图展示了TCP愚蠢窗口综合征这一现象的一个例子。客户端试图尽可能快地向服务器发送数据，而服务器非常繁忙，无法及时清除其缓冲区。每当客户端发送数据时，服务器都会减小其接收窗口。客户端发送的消息大小会缩小，直到它只发送非常小、效率低下的数据段。请注意，在此图中，我将服务器的缓冲区固定在位置，而不是像本章其他图中的那样向右滑动。这样，你可以更容易地看到接收窗口大小的减小。")中展示的例子中使用它。当服务器从客户端接收初始360字节的段并且只能处理120字节时，它不会将窗口大小减小到120。它将窗口大小一直减小到零，关闭窗口。然后它将这个信息发送回客户端，客户端将停止发送小段。一旦服务器从缓冲区中移除60个字节，现在将有180个字节空闲，是缓冲区大小的一半。现在它将窗口大小增加到180字节，并将新的窗口大小发送给客户端。
- en: It will continue to advertise only either 0 bytes or 180 or more bytes, not
    smaller values in between. This seems to slow down the operation of TCP, but it
    really doesn't. Because the server is overloaded, the limiting factor in overall
    performance of the connection is the rate at which the server can clear the buffer.
    We are just exchanging many small segments for a few larger ones.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续只宣传0字节或180字节或更多字节，而不是介于两者之间的较小值。这似乎会减慢TCP的操作，但实际上并没有。因为服务器过载，连接整体性能的限制因素是服务器清除缓冲区的速率。我们只是在交换许多小段为几个大段。
- en: Sender SWS Avoidance and Nagle's Algorithm
  id: totrans-1142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送方SWS避免和Nagle算法
- en: 'SWS avoidance by the sender is accomplished generally by imposing "restraint"
    on the part of the transmitting TCP. Instead of trying to immediately send data
    as soon as we can, we wait to send it until we have a segment of a reasonable
    size. The specific method for doing this is called *Nagle''s algorithm*, named
    for its inventor, John Smith. (Just kidding, it was John Nagle.) Simplified, this
    algorithm works as follows:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方通过在传输TCP部分施加“限制”来避免SWS。我们不是尽可能快地发送数据，而是等待直到我们有一个合理大小的数据段。完成此操作的具体方法被称为*Nagle算法*，以发明者约翰·史密斯的名字命名。（开个玩笑，其实是约翰·Nagle。）简化地说，这个算法的工作原理如下：
- en: As long as there is no unacknowledged data outstanding on the connection, as
    soon as the application wants, data can be immediately sent. For example, in the
    case of an interactive application like Telnet, a single keystroke can be pushed
    in a segment.
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要连接上没有未确认的数据，一旦应用程序想要发送数据，就可以立即发送。例如，在像Telnet这样的交互式应用程序的情况下，单个按键可以推送到一个段中。
- en: While there *is* unacknowledged data, all subsequent data to be sent is held
    in the transmit buffer and not transmitted until either all the unacknowledged
    data is acknowledged or we have accumulated enough data to send a full-sized (MSS-sized)
    segment. This applies even if a push is requested by the user.
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管存在未确认的数据，但所有后续要发送的数据都保留在传输缓冲区中，直到所有未确认的数据被确认，或者我们积累了足够的数据来发送一个完整大小的（MSS大小的）段。即使用户请求了推送，这也适用。
- en: This might seem strange, especially the part about buffering data despite a
    push request! You might think this would cause applications like Telnet to break.
    In fact, Nagle's algorithm is a very clever method that suits the needs of both
    low-data-rate interactive applications like Telnet and high-bandwidth file-transfer
    applications.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很奇怪，尤其是关于即使有推送请求也要缓冲数据的那部分！你可能会认为这会导致像Telnet这样的应用程序崩溃。实际上，Nagle算法是一种非常聪明的解决方案，它适合像Telnet这样的低数据速率交互式应用程序和高带宽文件传输应用程序的需求。
- en: If you are using something like Telnet where the data is arriving very slowly
    (humans are very slow compared to computers), the initial data (first keystroke)
    can be pushed right away. The next keystroke must wait for an acknowledgment,
    but this will probably come reasonably soon relative to how long it takes to hit
    the next key. In contrast, more conventional applications that generate data in
    large amounts will automatically have the data accumulated into larger segments
    for efficiency.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是像Telnet这样的东西，其中数据到达非常缓慢（与计算机相比，人类非常慢），初始数据（第一个按键）可以立即推送。下一个按键必须等待确认，但相对于按下下一个键所需的时间，这可能会相对较快。相比之下，生成大量数据的更传统应用程序将自动将数据积累成更大的段以提高效率。
- en: Nagle's algorithm is actually far more complex than this description, but this
    section is already getting too long. RFC 896 discusses it in (much) more detail.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: Nagle算法实际上比这个描述要复杂得多，但这一部分已经太长了。RFC 896在（更多）细节中讨论了它。
- en: Tip
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Modern TCP implementations incorporate a set of *SWS avoidance
    algorithms*. When receiving, devices are programmed not to advertise very small
    windows, waiting instead until there is enough room in the buffer for one of a
    reasonable size. Transmitters use *Nagle''s algorithm* to ensure that small segments
    are not generated when there are unacknowledged bytes outstanding.'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 现代TCP实现包含一套*SWS避免算法*。在接收时，设备被编程为不宣传非常小的窗口，而是等待直到缓冲区中有足够的空间容纳一个合理大小的窗口。发送者使用*Nagle算法*来确保在存在未确认的字节时不会生成小的段。'
- en: TCP Congestion Handling and Congestion Avoidance Algorithms
  id: totrans-1151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP拥塞处理和拥塞避免算法
- en: By changing the window size that a device advertises to a peer on a TCP connection,
    the device can increase or decrease the rate at which its peer sends it data.
    This is how the TCP sliding window system implements flow control between the
    two connected devices. We've seen how this works in this chapter, including the
    changes required to the basic mechanism to ensure performance remains high by
    reducing the number of small segments sent.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变设备向TCP连接上的对等方宣传的窗口大小，设备可以增加或减少其对等方发送给它的数据速率。这就是TCP滑动窗口系统如何在两个连接设备之间实现流量控制。我们已经在本章中看到了它是如何工作的，包括对基本机制所做的更改，以确保通过减少发送的小段数量来保持性能。
- en: 'Flow control is a very important part of regulating the transmission of data
    between devices, but it is limited in the following respect: It considers only
    what is going on within each of the devices on the connection, and *not* what
    is happening in devices between them. In fact, this "self-centeredness" is symptomatic
    of architectural layering. Since we are dealing with how TCP works between a typical
    server and client at layer 4, we don''t worry about how data gets between them;
    that''s the job of IP at layer 3.'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制是调节设备间数据传输的重要部分，但在以下方面有限制：它只考虑连接中每个设备内部发生的事情，*而不是*它们之间设备发生的事情。实际上，这种“自我中心”是分层架构的典型症状。由于我们处理的是第4层中典型服务器和客户端之间TCP的工作方式，所以我们不担心数据如何在它们之间传输；这是第3层IP的工作。
- en: Congestion Considerations
  id: totrans-1154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥塞考虑
- en: In practice, what is going on at layer 3 can be quite important. Considered
    from an abstract point of view, our server and client may be connected directly
    using TCP, but all the segments we transmit are carried across an internetwork
    of networks and routers between them. These networks and routers are also carrying
    data from many other connections and higher-layer protocols. If the internetwork
    becomes very busy, the speed at which segments are carried between the endpoints
    of our connection will be reduced, and they could even be dropped. This is called
    *congestion*.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，第三层发生的事情可能非常重要。从抽象的角度来看，我们的服务器和客户端可能直接使用TCP连接，但我们发送的所有段都通过它们之间的互联网和路由器传输。这些网络和路由器也在携带来自许多其他连接和高层协议的数据。如果互联网变得非常繁忙，我们连接端点之间传输段的速率将会降低，甚至可能会被丢弃。这被称为*拥塞*。
- en: Again, at the TCP level, there is no way to directly comprehend what is causing
    congestion or why. It is perceived simply as inefficiencies in moving data from
    one device to another, through the need for some segments to be retransmitted.
    However, even though TCP is mostly oblivious to what is happening on the internetwork,
    it *must* be smart enough to understand how to deal with congestion and not exacerbate
    it.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在TCP层面，没有直接理解导致拥塞的原因或原因的方法。它只是被视为从一台设备向另一台设备传输数据时的低效，这需要某些段需要重传。然而，尽管TCP对互联网上发生的事情大多视而不见，但它*必须*足够聪明，以了解如何处理拥塞，而不是加剧它。
- en: Recall that each segment that is transmitted is placed in the retransmission
    queue with a retransmission timer. Now, suppose congestion dramatically increased
    on the internetwork, and there were no mechanisms in place to handle congestion.
    Segments would be delayed or dropped, which would cause them to time out and be
    retransmitted. This would increase the amount of traffic on the internetwork between
    our client and server. Furthermore, there might be thousands of other TCP connections
    behaving similarly. Each would keep retransmitting more and more segments, increasing
    congestion further, leading to a vicious circle. Performance of the entire internetwork
    would decrease dramatically, resulting in a condition called *congestion collapse*.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，每个传输的段都会放入重传队列，并设置一个重传定时器。现在，假设互联网上的拥塞急剧增加，并且没有机制来处理拥塞。段将被延迟或丢弃，这会导致它们超时并被重传。这将增加我们客户端和服务器之间互联网上的流量。此外，可能有数千个其他TCP连接以类似的方式行为。每个都会不断重传越来越多的段，进一步增加拥塞，形成一个恶性循环。整个互联网的性能将急剧下降，导致一种称为*拥塞崩溃*的状态。
- en: 'The message is clear: TCP cannot just ignore what is happening on the internetwork
    between its connection endpoints. To this end, TCP includes several specific algorithms
    that are designed to respond to congestion or avoid it in the first place. Many
    of these techniques can be considered, in a way, to be methods by which a TCP
    connection is made less selfish; that is, it tries to take into account the existence
    of other users of the internetwork over which it operates. While no single connection
    by itself can solve congestion of an entire internetwork, having all devices implement
    these measures collectively reduces congestion due to TCP.'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 消息很明确：TCP不能仅仅忽略其连接端点之间互联网上发生的事情。为此，TCP包含了几种特定的算法，这些算法旨在响应拥塞或从一开始就避免它。从某种意义上说，许多这些技术可以被认为是使TCP连接不那么自私的方法；也就是说，它试图考虑到它所操作的互联网上其他用户的存在。虽然单个连接本身无法解决整个互联网的拥塞，但所有设备共同实施这些措施可以减少由TCP引起的拥塞。
- en: The first issue is that we need to know when congestion is taking place. By
    definition, congestion means intermediate devices—routers—are overloaded. Routers
    respond to overloading by dropping datagrams. When these datagrams contain TCP
    segments, the segments don't reach their destination, and they are therefore left
    unacknowledged and will eventually expire and be retransmitted. This means that
    when a device sends TCP segments and does not receive acknowledgments for them,
    it can be assumed that, in most cases, they have been dropped by intermediate
    devices due to congestion. By detecting the rate at which segments are sent and
    not acknowledged, a TCP device can infer the level of congestion on the network
    between itself and its TCP connection peer.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我们需要知道何时发生拥塞。根据定义，拥塞意味着中间设备——路由器——过载。路由器通过丢弃数据报来响应过载。当这些数据报包含TCP段时，这些段无法到达目的地，因此它们未被确认，最终会过期并被重传。这意味着当一个设备发送TCP段而没有收到它们的确认时，可以假设在大多数情况下，它们已被中间设备由于拥塞而丢弃。通过检测未确认发送的段的数量，TCP设备可以推断出自身与TCP连接对端之间的网络拥塞程度。
- en: TCP Congestion-Handling Mechanisms
  id: totrans-1160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP拥塞处理机制
- en: After getting information about congestion, we must then decide what to do with
    that information. The main TCP standard, RFC 793, includes very little information
    about TCP congestion-handling issues. That is because early versions of TCP based
    solely on this standard didn't include congestion-handling measures. Problems
    with these early implementations led to the discovery that congestion was an important
    issue. The measures used in modern devices were developed over the years, and
    eventually documented in RFC 2001, "TCP Slow Start, Congestion Avoidance, Fast
    Retransmit, and Fast Recovery Algorithms."
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取有关拥塞的信息之后，我们必须决定如何处理这些信息。主要的TCP标准RFC 793包含很少关于TCP拥塞处理问题的信息。这是因为基于这个标准的TCP早期版本没有包括拥塞处理措施。这些早期实现的问题导致发现拥塞是一个重要的问题。现代设备使用的措施是在多年中开发的，并最终在RFC
    2001中记录下来，“TCP慢启动、拥塞避免、快速重传和快速恢复算法”。
- en: Tip
  id: totrans-1162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** TCP flow control is an essential part of regulating the traffic
    flow between TCP devices, but takes into account only how busy the two TCP endpoints
    are. It is also important to take into account the possibility of *congestion*
    of the networks over which any TCP session is established, which can lead to inefficiency
    through dropped segments. To deal with congestion and avoid contributing to it
    unnecessarily, modern TCP implementations include a set of Congestion Avoidance
    algorithms that alter the normal operation of the sliding window system to ensure
    more efficient overall operation.'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** TCP流量控制是调节TCP设备之间流量流的一个基本部分，但它只考虑两个TCP端点的繁忙程度。同样重要的是要考虑任何TCP会话建立的网络的拥塞可能性，这可能导致通过丢弃段的不效率。为了处理拥塞并避免不必要地贡献拥塞，现代TCP实现包括一系列拥塞避免算法，这些算法改变了滑动窗口系统的正常操作，以确保更有效的整体操作。'
- en: 'RFC 2001 refers to four algorithms: Slow Start, Congestion Avoidance, Fast
    Retransmit, and Fast Recovery. In practice, these features are all related to
    each other. Slow Start and Congestion Avoidance are distinct algorithms but are
    implemented using a single mechanism, involving the definition of a *congestion
    window* that limits the size of transmissions and whose size is increased or decreased
    depending on congestion levels. Fast Retransmit and Fast Recovery are implemented
    as changes to the mechanism that implements Slow Start and Congestion Avoidance.'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2001提到了四种算法：慢启动、拥塞避免、快速重传和快速恢复。在实践中，这些特性都是相互关联的。慢启动和拥塞避免是不同的算法，但它们使用单一机制实现，涉及定义一个*拥塞窗口*，该窗口限制传输的大小，其大小根据拥塞水平增加或减少。快速重传和快速恢复作为对实现慢启动和拥塞避免机制的更改来实现。
- en: The following sections provide simplified summaries of how these algorithms
    work. My goal is simply to help you get a feel for how congestion is handled in
    TCP in general terms.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了这些算法工作原理的简化总结。我的目标仅仅是帮助您大致了解TCP中如何处理拥塞。
- en: Note
  id: totrans-1166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Congestion handling is a rather complex process. If you want to learn more,
    RFC 2001 contains the technical details, showing how each of the algorithms is
    implemented in each device.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 拥塞处理是一个相当复杂的过程。如果您想了解更多，RFC 2001包含了技术细节，展示了每个算法在每个设备中的实现方式。
- en: Slow Start
  id: totrans-1168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 慢启动
- en: In the original implementation of TCP, as soon as a connection was established
    between two devices, they could each go "hog wild," sending segments as fast as
    they liked as long as there was room in the other device's receive window. In
    a busy internetwork, the sudden appearance of a large amount of new traffic could
    exacerbate any existing congestion. To alleviate this, modern TCP devices are
    restrained in the rate at which they initially send segments.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP的原始实现中，一旦两个设备之间建立连接，它们就可以各自“尽情地”发送数据段，只要另一个设备的接收窗口还有空间。在一个繁忙的互联网中，大量新流量的突然出现可能会加剧现有的拥塞。为了缓解这种情况，现代TCP设备在最初发送数据段的速度上受到限制。
- en: Each sender is at first restricted to sending only an amount of data equal to
    one full-sized segment—that is, equal to the MSS value for the connection. Each
    time an acknowledgment is received, the amount of data the device can send is
    increased by the size of another full-sized segment. Thus, the device starts slow
    in terms of how much data it can send, with the amount it sends increasing until
    either the full window size is reached or congestion is detected on the link.
    In the latter case, the Congestion Avoidance feature, described next, is used.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发送者在最初都限制只能发送等于一个完整数据段大小的数据量——即等于连接的MSS值。每次收到确认后，设备可以发送的数据量会增加另一个完整数据段的大小。因此，设备在发送数据量方面开始较慢，发送的数据量逐渐增加，直到达到完整的窗口大小或检测到链路上的拥塞。在后一种情况下，将使用下面描述的拥塞避免功能。
- en: Congestion Avoidance
  id: totrans-1171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免拥塞
- en: When potential congestion is detected on a TCP link, a device responds by throttling
    back the rate at which it sends segments. A special algorithm is used that allows
    the device to drop the rate at which segments are sent quickly when congestion
    occurs. The device then uses the Slow Start algorithm to gradually increase the
    transmission rate back up again to try to maximize throughput without congestion
    occurring again.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 当在TCP链路上检测到潜在的拥塞时，设备会通过降低发送数据段的速度来响应。使用一种特殊的算法，允许设备在发生拥塞时快速降低发送数据段的速度。然后，设备使用慢启动算法逐渐增加传输速率，以尝试在不发生拥塞的情况下最大化吞吐量。
- en: Fast Retransmit
  id: totrans-1173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速重传
- en: We've already seen in our look at TCP segment retransmission that when segments
    are received by a device out of order (noncontiguously), the recipient will acknowledge
    only the ones received contiguously. The Acknowledgment Number field will specify
    the sequence number of the byte it expects to receive next. So, in the example
    given in that section, Segments 1 and 2 were acknowledged, while Segment 4 was
    not because Segment 3 was not received.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查看TCP数据段重传时已经看到，当设备接收到非连续顺序的数据段时（即乱序），接收方只会确认连续接收到的那些。确认号字段将指定它期望接收的下一个字节的序列号。因此，在该节给出的示例中，数据段1和2被确认，而数据段4没有被确认，因为数据段3没有被接收。
- en: It is possible for a TCP device to respond with an acknowledgment when it receives
    an out-of-order segment, simply reiterating that it is stuck waiting for a particular
    byte number. So, when the client in that example receives Segment 4 and not Segment
    3, it could send back an acknowledgment saying, "I am expecting the first byte
    of Segment 3 next."
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 当TCP设备接收到乱序数据段时，它可以简单地通过重复说明它正在等待特定的字节数来响应确认。因此，当示例中的客户端收到数据段4而不是数据段3时，它可以发送一个确认说：“我正在等待数据段3的第一个字节。”
- en: Now, suppose this happens over and over. The server, not realizing that Segment
    3 was lost, sends Segments 5, 6, and so on. Each time a segment is received, the
    client sends back an acknowledgment specifying the first byte number of Segment
    3\. Eventually, the server can reasonably conclude that Segment 3 is lost, even
    if its retransmission timer has not expired.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设这种情况反复发生。服务器没有意识到数据段3已丢失，因此发送了数据段5、6等等。每次接收到数据段时，客户端都会发送一个确认，指定数据段3的第一个字节数。最终，服务器可以合理地得出结论，数据段3已丢失，即使其重传计时器尚未到期。
- en: The Fast Retransmit feature dictates that if three or more of these acknowledgments
    are received, all saying, "I want the segment starting with byte *N*," then it's
    probable that the segment starting with byte *N* has been lost, usually because
    it was dropped due to congestion. In this case, the device will immediately retransmit
    the missing segment, without going through the normal retransmission queue process.
    This improves performance by eliminating delays that would suspend effective data
    flow on the link.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 快速重传功能规定，如果收到三个或更多这样的确认，都表示“我想要从字节 *N* 开始的段”，那么很可能从字节 *N* 开始的段已经丢失，通常是因为它由于拥塞而被丢弃。在这种情况下，设备将立即重传丢失的段，而不经过正常的重传队列过程。这通过消除会暂停链路上有效数据流的延迟来提高性能。
- en: Fast Recovery
  id: totrans-1178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速恢复
- en: When Fast Retransmit is used to resend a lost segment, the device using it performs
    Congestion Avoidance, but does not use Slow Start to increase the transmission
    rate back up again. The rationale for this is that since multiple ACKs were received
    by the sender, all indicating receipt of out-of-order segments, this indicates
    that several segments have already been removed from the flow of segments between
    the two devices. For efficiency reasons, then, the transmission rate can be increased
    more quickly than when congestion occurs in other ways. This improves performance
    compared to using the regular Congestion Avoidance algorithm after Fast Retransmit.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用快速重传来重发丢失的段时，使用该功能的设备执行拥塞避免，但不会使用慢启动来再次增加传输速率。这样做的原因是，由于发送方收到了多个确认，所有这些确认都表示收到了乱序的段，这表明两个设备之间的段流中已经移除了几个段。出于效率的考虑，因此，传输速率可以比其他方式发生拥塞时更快地增加。这比在快速重传后使用常规的拥塞避免算法提高了性能。
