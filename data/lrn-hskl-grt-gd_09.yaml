- en: Chapter 9. More Input and More Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 更多输入和更多输出
- en: Now that you understand the concepts behind Haskell’s I/O, we can start doing
    fun stuff with it. In this chapter, we’ll interact with files, make random numbers,
    deal with command-line arguments, and more. Stay tuned!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了Haskell I/O背后的概念，我们可以开始用它做一些有趣的事情了。在本章中，我们将与文件交互，生成随机数，处理命令行参数等等。敬请期待！
- en: Files and Streams
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和流
- en: Armed with the knowledge about how I/O actions work, we can move on to reading
    and writing files with Haskell. But first, let’s take a look at how we can use
    Haskell to easily process streams of data. A *stream* is a succession of pieces
    of data entering or exiting a program over time. For instance, when you’re inputting
    characters into a program via the keyboard, those characters can be thought of
    as a stream.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了I/O操作的工作原理之后，我们可以继续使用Haskell来读写文件。但首先，让我们看看如何使用Haskell轻松处理数据流。*数据流*是指在一段时间内进入或离开程序的一系列数据。例如，当你通过键盘向程序输入字符时，这些字符可以被视为一个流。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802620.png.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802620.png.jpg)'
- en: Input Redirection
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入重定向
- en: Many interactive programs get the user’s input via the keyboard. However, it’s
    often more convenient to get the input by feeding the contents of a text file
    to the program. To achieve this, we use *input redirection*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多交互式程序通过键盘获取用户的输入。然而，通过将文本文件的内容提供给程序来获取输入通常更方便。为了实现这一点，我们使用*输入重定向*。
- en: 'Input redirection will come in handy with our Haskell programs, so let’s take
    a look at how it works. To begin, create a text file that contains the following
    little haiku, and save it as *haiku.txt*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 输入重定向在我们的Haskell程序中将非常有用，让我们看看它是如何工作的。首先，创建一个包含以下小俳句的文本文件，并将其保存为*haiku.txt*：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yeah, the haiku sucks—what of it? If anyone knows of any good haiku tutorials,
    let me know.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，俳句很糟糕——那又怎样？如果有人知道任何好的俳句教程，请告诉我。
- en: 'Now we’ll write a little program that continuously gets a line from the input
    and then prints it back in all uppercase:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个小程序，它可以从输入中连续获取一行，并将其全部转换为大写输出：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save this program as *capslocker.hs* and compile it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将此程序保存为*capslocker.hs*并编译它。
- en: 'Instead of inputting lines via the keyboard, we’ll have *haiku.txt* be the
    input by redirecting it into our program. To do that, we add a `<` character after
    our program name and then specify the file that we want to act as the input. Check
    it out:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过键盘输入行，而是通过重定向将*haiku.txt*作为输入传递给我们的程序。要做到这一点，我们在程序名称后添加一个`<`字符，然后指定我们想要作为输入的文件。看看这个例子：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we’ve done is pretty much equivalent to running `capslocker`, typing our
    haiku at the terminal, and then issuing an end-of-file character (usually done
    by pressing ctrl-D). It’s like running `capslocker` and saying, “Wait, don’t read
    from the keyboard. Take the contents of this file instead!”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是相当于运行`capslocker`，在终端中输入我们的俳句，然后发送一个文件结束字符（通常通过按ctrl-D完成）。这就像运行`capslocker`并说：“等等，不要从键盘读取。取而代之的是这个文件的内容！”
- en: Getting Strings from Input Streams
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从输入流中获取字符串
- en: 'Let’s take a look at an I/O action that makes processing input streams easier
    by allowing us to treat them as normal strings: `getContents`. `getContents` reads
    everything from the standard input until it encounters an end-of-file character.
    Its type is `getContents :: IO String`. What’s cool about `getContents` is that
    it does lazy I/O. This means that when we do `foo <- getContents`, `getContents`
    doesn’t read all of the input at once, store it in memory, and then bind it to
    `foo`. No, `getContents` is lazy! It will say, “Yeah yeah, I’ll read the input
    from the terminal later as we go along, when you really need it!”'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看一个I/O操作，它通过允许我们将输入流视为普通字符串来简化输入流的处理：`getContents`。`getContents`读取从标准输入直到遇到文件结束字符的所有内容。它的类型是`getContents
    :: IO String`。`getContents`的酷之处在于它执行懒I/O。这意味着当我们执行`foo <- getContents`时，`getContents`不会一次性读取所有输入，将其存储在内存中，然后将其绑定到`foo`。不，`getContents`是懒的！它会说：“是的，是的，我会在需要的时候从终端读取输入！”'
- en: 'In our *capslocker.hs* example, we used `forever` to read the input line by
    line and then print it back in uppercase. If we opt to use `getContents`, it takes
    care of the I/O details for us, such as when to read input and how much of that
    input to read. Because our program is about taking some input and transforming
    it into some output, we can make it shorter by using `getContents`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *capslocker.hs* 示例中，我们使用了 `forever` 来逐行读取输入，然后将其以大写形式打印出来。如果我们选择使用 `getContents`，它会为我们处理
    I/O 细节，例如何时读取输入以及读取多少输入。因为我们的程序是关于接受一些输入并将其转换为一些输出，我们可以通过使用 `getContents` 来使其更短：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We run the `getContents` I/O action and name the string it produces `contents`.
    Then we map `toUpper` over that string and print that result to the terminal.
    Keep in mind that because strings are basically lists, which are lazy, and `getContents`
    is I/O lazy; it won’t try to read all of the content at once and store that into
    memory before printing out the caps-locked version. Rather, it will print out
    the caps-locked version as it reads, because it will read a line from the input
    only when it must.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 `getContents` I/O 操作，并命名它产生的字符串为 `contents`。然后我们对该字符串应用 `toUpper` 并将结果打印到终端。记住，因为字符串基本上是懒加载的列表，而
    `getContents` 是 I/O 懒加载；它不会试图一次性读取所有内容并将其存储到内存中，然后再打印出大写锁定的版本。相反，它会在读取的同时打印出大写锁定的版本，因为它只有在必须时才会从输入中读取一行。
- en: 'Let’s test it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, it works. What if we just run `capslocker` and try to type in the lines
    ourselves? (To exit the program, just press ctrl-D.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，它（程序）是有效的。如果我们只运行 `capslocker` 并尝试自己输入这些行会怎样？（要退出程序，只需按 ctrl-D。）
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pretty nice! As you can see, it prints our caps-locked input line by line.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很不错！正如你所见，它逐行打印出大写锁定输入。
- en: When the result of `getContents` is bound to `contents`, it’s not represented
    in memory as a real string, but more like a promise that the string will be produced
    eventually. When we map `toUpper` over `contents`, that’s also a promise to map
    that function over the eventual contents. Finally, when `putStr` happens, it says
    to the previous promise, “Hey, I need a caps-locked line!” It doesn’t have any
    lines yet, so it says to `contents`, “How about getting a line from the terminal?”
    And that’s when `getContents` actually reads from the terminal and gives a line
    to the code that asked it to produce something tangible. That code then maps `toUpper`
    over that line and gives it to `putStr`, which prints the line. And then `putStr`
    says, “Hey, I need the next line—come on!” This repeats until there’s no more
    input, which is signified by an end-of-file character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `getContents` 的结果绑定到 `contents` 时，它不是以真正的字符串形式在内存中表示，而更像是一个承诺，即字符串最终会被生成。当我们对
    `contents` 应用 `toUpper` 时，这也是一个承诺，即对最终内容应用该函数。最后，当 `putStr` 发生时，它对前面的承诺说，“嘿，我需要一个带大写锁定的行！”它目前还没有任何行，所以它对
    `contents` 说，“从终端获取一行怎么样？”这时 `getContents` 实际上从终端读取并给请求它产生有形内容的代码一行。然后，该代码对这一行应用
    `toUpper` 并将其传递给 `putStr`，打印这一行。然后 `putStr` 说，“嘿，我需要下一行——快点！”这会一直重复，直到没有更多的输入，这由文件结束字符表示。
- en: 'Now let’s make a program that takes some input and prints out only those lines
    that are shorter than 10 characters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写一个程序，它接受一些输入并只打印出那些少于10个字符的行：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ve made the I/O part of our program as short as possible. Because our program
    is supposed to print something based on some input, we can implement it by reading
    the input contents, running a function on them, and then printing out what that
    function gives back.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将程序的 I/O 部分尽可能地简化。因为我们的程序应该根据一些输入打印出某些内容，我们可以通过读取输入内容，对它们运行一个函数，然后打印出该函数返回的内容来实现它。
- en: 'The `shortLinesOnly` function takes a string, like `"short\nlooooooong\nbort"`.
    In this example, that string has three lines: two of them are short, and the middle
    one is long. It applies the `lines` function to that string, which converts it
    to `["short", "looooooong", "bort"]`. That list of strings is then filtered so
    that only those lines that are shorter than 10 characters remain in the list,
    producing `["short", "bort"]`. Finally, `unlines` joins that list into a single
    newline-delimited string, giving `"short\nbort"`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortLinesOnly` 函数接受一个字符串，例如 `"short\nlooooooong\nbort"`。在这个例子中，该字符串有三行：其中两行较短，中间的一行较长。它将该字符串应用到
    `lines` 函数上，将其转换为 `["short", "looooooong", "bort"]`。这个字符串列表随后被过滤，只保留那些少于10个字符的行，生成
    `["short", "bort"]`。最后，`unlines` 将该列表连接成一个单独的换行分隔字符串，得到 `"short\nbort"`。'
- en: Let’s give it a go. Save the following text as *shortlines.txt*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。将以下文本保存为 *shortlines.txt*。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And now we’ll compile our program, which we saved as *shortlinesonly.hs*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编译我们的程序，我们将其保存为 *shortlinesonly.hs*：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To test it, we’re going to redirect the contents of *shortlines.txt* into our
    program, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，我们将 *shortlines.txt* 的内容重定向到我们的程序中，如下所示：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that only the short lines were printed to the terminal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到只有短行被打印到终端。
- en: Transforming Input
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换输入
- en: 'The pattern of getting some string from the input, transforming it with a function,
    and outputting the result is so common that there is a function that makes that
    job even easier, called `interact`. `interact` takes a function of type `String
    -> String` as a parameter and returns an I/O action that will take some input,
    run that function on it, and then print out the function’s result. Let’s modify
    our program to use `interact`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入中获取一些字符串，使用一个函数对其进行转换，然后输出结果的模式非常常见，以至于有一个使这项工作更加容易的函数，称为 `interact`。`interact`
    接受一个类型为 `String -> String` 的函数作为参数，并返回一个 I/O 操作，该操作将获取一些输入，在该输入上运行该函数，然后打印出函数的结果。让我们修改我们的程序以使用
    `interact`：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can use this program either by redirecting a file into it or by running it
    and then giving it input from the keyboard, line by line. Its output is the same
    in both cases, but when we’re doing input via the keyboard, the output is interspersed
    with what we typed in, just as when we manually typed in our input to our `capslocker`
    program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将文件重定向到程序中或运行程序然后逐行从键盘输入来使用这个程序。两种情况下的输出都是相同的，但当我们通过键盘进行输入时，输出会与我们所输入的内容交织在一起，就像我们手动将输入输入到我们的
    `capslocker` 程序中一样。
- en: Let’s make a program that continuously reads a line and then outputs whether
    or not that line is a palindrome. We could just use `getLine` to read a line,
    tell the user if it’s a palindrome, and then run `main` all over again. But it’s
    simpler if we use `interact`. When using `interact`, think about what you need
    to do to transform some input into the desired output. In our case, we want to
    replace each line of the input with either `"palindrome"` or `"not a palindrome"`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，该程序持续读取一行，然后输出该行是否是回文。我们可以使用 `getLine` 读取一行，告诉用户它是否是回文，然后再次运行 `main`。但如果我们使用
    `interact` 会更简单。在使用 `interact` 时，考虑你需要做什么来将一些输入转换为所需的输出。在我们的情况下，我们想要将输入的每一行替换为
    `"palindrome"` 或 `"not a palindrome"`。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This program is pretty straightforward. First, it turns a string like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序相当简单。首先，它将像这样的字符串：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'into an array like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为一个如下所示的数组：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then it maps the lambda over it, giving the results:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它对 lambda 进行映射，得到以下结果：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, `unlines` joins that list into a single, newline-delimited string. Now
    we just make a main I/O action:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`unlines` 将该列表连接成一个单独的、以换行符分隔的字符串。现在我们只需创建一个主要的 I/O 操作：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s test it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试它：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Even though we created a program that transforms one big string of input into
    another, it acts as if we made a program that does it line by line. That’s because
    Haskell is lazy, and it wants to print the first line of the result string, but
    it can’t because it doesn’t have the first line of the input yet. So as soon as
    we give it the first line of input, it prints the first line of the output. We
    get out of the program by issuing an end-of-line character.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们创建了一个将一个大的输入字符串转换成另一个字符串的程序，但它表现得就像我们创建了一个逐行进行转换的程序。这是因为 Haskell 是惰性的，它想要打印结果字符串的第一行，但它不能，因为它还没有输入的第一行。所以，一旦我们给它输入的第一行，它就会打印输出的第一行。我们通过发出行结束字符来退出程序。
- en: We can also use this program by just redirecting a file into it. Create the
    following file and save it as *words.txt*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将文件重定向到程序中来使用这个程序。创建以下文件并将其保存为 *words.txt*。
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is what we get by redirecting it into our program:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其重定向到我们的程序，我们得到以下结果：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we get the same output as if we had run our program and put in the words
    ourselves at the standard input. We just don’t see the input that our program
    gets because that input came from the file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们得到了与如果我们运行程序并将单词直接输入到标准输入中相同的输出。我们只是看不到程序获取的输入，因为那个输入来自文件。
- en: So now you see how lazy I/O works and how we can use it to our advantage. You
    can just think in terms of what the output is supposed to be for some given input
    and write a function to do that transformation. In lazy I/O, nothing is eaten
    from the input until it absolutely must be, because what we want to print right
    now depends on that input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在你看到了惰性 I/O 的工作原理以及我们如何利用它。你只需考虑对于某个给定的输入，输出应该是什么，然后编写一个函数来完成这个转换。在惰性 I/O
    中，直到绝对必须时，才从输入中取出任何内容，因为我们想要立即打印的内容取决于那个输入。
- en: Reading and Writing Files
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: So far, we’ve worked with I/O by printing stuff to the terminal and reading
    from it. But what about reading and writing files? Well, in a way, we’ve already
    been doing that.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过向终端打印内容并从中读取来处理I/O。但是，关于读取和写入文件呢？嗯，在某种程度上，我们已经在做了。
- en: One way to think about reading from the terminal is that it’s like reading from
    a (somewhat special) file. The same goes for writing to the terminal— it’s kind
    of like writing to a file. We can call these two files *stdout* and *stdin*, meaning
    standard output and standard input, respectively. Writing to and reading from
    files is very much like writing to the standard output and reading from the standard
    input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一种从终端读取的想法是，它就像从（某种程度上特殊的）文件中读取一样。对于将内容写入终端也是如此——它有点像写入文件。我们可以称这两个文件为`stdout`和`stdin`，分别表示标准输出和标准输入。向文件写入和从文件读取与向标准输出写入和从标准输入读取非常相似。
- en: 'We’ll start off with a really simple program that opens a file called *girlfriend.txt*,
    which contains a verse from Avril Lavigne’s hit song “Girlfriend,” and just prints
    out to the terminal. Here’s *girlfriend.txt*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个非常简单的程序开始，这个程序打开一个名为`girlfriend.txt`的文件，其中包含Avril Lavigne热门歌曲“Girlfriend”中的一段歌词，并将其打印到终端。以下是`girlfriend.txt`的内容：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And here’s our program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的程序：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we compile and run it, we get the expected result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行它，我们会得到预期的结果：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s go over this line by line. The first line is just four exclamations, to
    get our attention. In the second line, Avril tells us that she doesn’t like our
    current partner of the female persuasion. The third line serves to emphasize that
    disapproval, and the fourth line suggests we should go about finding a suitable
    replacement.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析这一行。第一行只是四个感叹号，以引起我们的注意。在第二行，Avril告诉我们她不喜欢我们目前的女性伴侣。第三行用来强调这种不满，第四行建议我们应该去找一个合适的替代者。
- en: 'Let’s also go over the program line by line. Our program is several I/O actions
    glued together with a `do` block. In the first line of the `do` block is a new
    function called `openFile`. It has the following type signature:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也逐行分析程序。我们的程序是由`do`块粘合在一起的几个I/O操作。在`do`块的第一行有一个新函数`openFile`。它有以下类型签名：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`openFile` takes a file path and an `IOMode` and returns an I/O action that
    will open a file and yield the file’s associated handle as its result. `FilePath`
    is just a type synonym for `String`, defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`openFile`函数接受一个文件路径和一个`IOMode`，并返回一个I/O操作，该操作将打开一个文件并返回文件关联的句柄作为其结果。`FilePath`只是`String`的一个类型同义词，定义如下：'
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`IOMode` is a type that’s defined like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`IOMode`是一个定义如下类型的类型：'
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just like our type that represents the seven possible values for the days of
    the week, this type is an enumeration that represents what we want to do with
    our opened file. Notice that this type is `IOMode` and not `IO Mode`. `IO Mode`
    would be the type of I/O action that yields a value of some type `Mode` as its
    result. `IOMode` is just a simple enumeration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代表一周七天可能值的类型一样，这个类型是一个枚举，表示我们想要对我们打开的文件做什么。注意，这个类型是`IOMode`而不是`IO Mode`。`IO
    Mode`将是产生某种类型`Mode`值的I/O操作的类型。`IOMode`只是一个简单的枚举。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802622.png.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802622.png.jpg)'
- en: Finally, `openFile` returns an I/O action that will open the specified file
    in the specified mode. If we bind that action’s result to something, we get a
    `Handle`, which represents where our file is. We’ll use that handle so we know
    which file to read from.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`openFile`返回一个I/O操作，该操作将以指定的模式打开指定的文件。如果我们将该操作的结果绑定到某个东西上，我们就会得到一个`Handle`，它表示我们的文件在哪里。我们将使用这个句柄，以便我们知道从哪个文件读取。
- en: In the next line, we have a function called `hGetContents`. It takes a `Handle`,
    so it knows which file to get the contents from, and returns an `IO String`—an
    I/O action that holds contents of the file as its result. This function is pretty
    much like `getContents`. The only difference is that `getContents` will automatically
    read from the standard input (that is, from the terminal), whereas `hGetContents`
    takes a file handle that tells it which file to read from. In all other respects,
    they work the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们有一个名为`hGetContents`的函数。它接受一个`Handle`，这样它就知道从哪个文件获取内容，并返回一个`IO String`——一个包含文件内容的I/O操作作为其结果。这个函数基本上与`getContents`相同。唯一的区别是`getContents`会自动从标准输入（即终端）读取，而`hGetContents`接受一个文件句柄，告诉它从哪个文件读取。在其他所有方面，它们的工作方式相同。
- en: Just like `getContents`, `hGetContents` won’t attempt to read all the file at
    once and store it in memory but will read the content only as needed. This is
    really cool because we can treat `contents` as the whole content of the file,
    but it’s not really loaded in memory. So if this were a really huge file, doing
    `hGetContents` wouldn’t choke up our memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `getContents` 一样，`hGetContents` 不会试图一次性读取整个文件并存储在内存中，而是按需读取内容。这真的很酷，因为我们可以将
    `contents` 视为整个文件的内容，但实际上并没有加载到内存中。所以如果这是一个非常大的文件，使用 `hGetContents` 不会耗尽我们的内存。
- en: Note the difference between a handle and the actual contents of the file. A
    handle just points to our current position in the file. The contents are what’s
    actually in the file. If you imagine your whole filesystem as a really big book,
    the handle is like a bookmark that shows where you’re currently reading (or writing).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件句柄和文件实际内容之间的区别。文件句柄只是指向文件中的当前位置。内容是文件中实际的内容。如果你想象你的整个文件系统就像一本非常大的书，那么文件句柄就像一个书签，显示你当前正在阅读（或写入）的位置。
- en: With `putStr contents`, we print the contents out to the standard output, and
    then we do `hClose`, which takes a handle and returns an I/O action that closes
    the file. You need to close the file yourself after opening it with `openFile`!
    Your program may terminate if you try to open a file whose handle hasn’t been
    closed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `putStr contents`，我们将内容打印到标准输出，然后执行 `hClose`，它接受一个句柄并返回一个关闭文件的 I/O 操作。你需要在用
    `openFile` 打开文件后自己关闭文件！如果你尝试打开一个尚未关闭句柄的文件，你的程序可能会终止。
- en: Using the withFile Function
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 withFile 函数
- en: 'Another way of working with the contents of a file as we just did is to use
    the `withFile` function, which has the following type signature:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种像我们刚才那样处理文件内容的方法是使用 `withFile` 函数，它具有以下类型签名：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It takes a path to a file, an `IOMode`, and a function that takes a handle and
    returns some I/O action. Then it returns an I/O action that will open that file,
    do something with the file, and close it. Furthermore, if anything goes wrong
    while we’re operating on our file, `withFile` makes sure that the file handle
    gets closed. This might sound a bit complicated, but it’s really simple, especially
    if we use lambdas.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要一个文件的路径、一个 `IOMode` 以及一个接受句柄并返回一些 I/O 操作的函数。然后它返回一个 I/O 操作，该操作将打开该文件，对文件进行一些操作，然后关闭它。此外，如果我们操作文件时出了问题，`withFile`
    确保文件句柄被关闭。这听起来可能有点复杂，但实际上很简单，特别是如果我们使用 lambda。
- en: 'Here’s our previous example rewritten to use `withFile`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将我们之前的示例重写为使用 `withFile` 的样子：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`(\handle -> ...)` is the function that takes a handle and returns an I/O action,
    and it’s usually done like this, with a lambda. It needs to take a function that
    returns an I/O action, rather than just taking an I/O action to do and then closing
    the file, because the I/O action that we would pass to it wouldn’t know on which
    file to operate. This way, `withFile` opens the file and then passes the handle
    to the function we gave it. It gets an I/O action back from that function and
    then makes an I/O action that’s just like the original action, but it also makes
    sure that the file handle gets closed, even if something goes awry.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`(\handle -> ...)` 是一个函数，它接受一个句柄并返回一个 I/O 操作，通常是这样做的，使用 lambda。它需要一个返回 I/O
    操作的函数，而不是仅仅接受一个要执行的操作并关闭文件，因为我们要传递给它的 I/O 操作不知道在哪个文件上操作。这样，`withFile` 打开文件，然后将句柄传递给它提供的函数。它从这个函数返回一个
    I/O 操作，然后创建一个与原始操作相同的 I/O 操作，但它还确保文件句柄被关闭，即使出了问题。'
- en: It's Bracket Time
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到括号时间了
- en: Usually, if a piece of code calls `error` (such as when we try to apply `head`
    to an empty list) or if something goes very wrong when doing input and output,
    our program terminates, and we see some sort of error message. In such circumstances,
    we say that an *exception* gets raised. The `withFile` function makes sure that
    despite an exception being raised, the file handle is closed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果一段代码调用 `error`（例如当我们尝试将 `head` 应用到一个空列表上时）或者在进行输入输出时出了大问题，我们的程序会终止，并显示某种错误信息。在这种情况下，我们说发生了
    *异常*。`withFile` 函数确保即使发生异常，文件句柄也会被关闭。
- en: 'This sort of scenario comes up often. We acquire some resource (like a file
    handle), and we want to do something with it, but we also want to make sure that
    the resource gets released (for example, the file handle is closed). Just for
    such cases, the `Control.Exception` module offers the `bracket` function. It has
    the following type signature:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景经常出现。我们获取一些资源（如文件句柄），并想对其进行操作，但同时也想确保资源被释放（例如，关闭文件句柄）。正是为了这种情况，`Control.Exception`
    模块提供了 `bracket` 函数。它具有以下类型签名：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802624.png.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802624.png.jpg)'
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Its first parameter is an I/O action that acquires a resource, such as a file
    handle. Its second parameter is a function that releases that resource. This function
    gets called even if an exception has been raised. The third parameter is a function
    that also takes that resource and does something with it. The third parameter
    is where the main stuff happens, like reading from a file or writing to it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个参数是一个获取资源的 I/O 操作，例如文件句柄。第二个参数是一个释放该资源的函数。即使发生异常，该函数也会被调用。第三个参数是一个也接受该资源并对其进行操作的函数。第三个参数是主要操作发生的地方，比如从文件中读取或写入文件。
- en: 'Because `bracket` is all about acquiring a resource, doing something with it,
    and making sure it gets released, implementing `withFile` is really easy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `bracket` 是关于获取资源、对其进行操作并确保其被释放的，所以实现 `withFile` 非常简单：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first parameter that we pass to `bracket` opens the file, and its result
    is a file handle. The second parameter takes that handle and closes it. `bracket`
    makes sure that this happens even if an exception is raised. Finally, the third
    parameter to `bracket` takes a handle and applies the function `f` to it, which
    takes a file handle and does stuff with that handle, like reading from or writing
    to the corresponding file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `bracket` 的第一个参数打开文件，其结果是文件句柄。第二个参数接收该句柄并关闭它。`bracket` 确保即使发生异常也会执行此操作。最后，`bracket`
    的第三个参数接收一个句柄并对其应用函数 `f`，该函数接收一个文件句柄并对其进行操作，例如从相应文件中读取或写入。
- en: Grab the Handles!
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抓取句柄！
- en: Just as `hGetContents` works like `getContents` but for a specific file, functions
    like `hGetLine`, `hPutStr`, `hPutStrLn`, `hGetChar`, and so on work just like
    their counterparts without the `h` but take only a handle as a parameter and operate
    on that specific file instead of on standard input or standard output. For example,
    `putStrLn` takes a string and returns an I/O action that will print out that string
    to the terminal and a newline after it. `hPutStrLn` takes a handle and a string
    and returns an I/O action that will write that string to the file associated with
    the handle and then put a newline after it. In the same vein, `hGetLine` takes
    a handle and returns an I/O action that reads a line from its file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `hGetContents` 的工作方式类似于 `getContents` 但针对特定文件一样，像 `hGetLine`、`hPutStr`、`hPutStrLn`、`hGetChar`
    等函数的工作方式也类似于没有 `h` 的对应函数，但它们只接受一个句柄作为参数并在该特定文件上操作，而不是在标准输入或标准输出上操作。例如，`putStrLn`
    接收一个字符串并返回一个 I/O 操作，该操作将打印出该字符串到终端并在其后添加一个换行符。`hPutStrLn` 接收一个句柄和一个字符串并返回一个 I/O
    操作，该操作将字符串写入与句柄关联的文件，并在其后添加一个换行符。同样地，`hGetLine` 接收一个句柄并返回一个 I/O 操作，该操作从其文件中读取一行。
- en: 'Loading files and then treating their contents as strings is so common that
    we have three nice little functions to make our work even easier: `readFile`,
    `writeFile`, and `appendFile.`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载文件然后将内容作为字符串处理是如此常见，以至于我们有三个小巧的函数来使我们的工作更加容易：`readFile`、`writeFile` 和 `appendFile`。
- en: 'The `readFile` function has a type signature of `readFile :: FilePath -> IO
    String`. (Remember that `FilePath` is just a fancy name for `String`.) `readFile`
    takes a path to a file and returns an I/O action that will read that file (lazily,
    of course) and bind its contents to something as a string. It’s usually more handy
    than calling `openFile` and then calling `hGetContents` with the resulting handle.
    Here’s how we could have written our previous example with `readFile`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile` 函数的类型签名为 `readFile :: FilePath -> IO String`。（记住，`FilePath` 只是 `String`
    的一个花哨名称。）`readFile` 函数接收一个文件的路径，并返回一个 I/O 操作，该操作将（当然，是惰性地）读取该文件并将内容绑定为一个字符串。通常比调用
    `openFile` 然后使用结果句柄调用 `hGetContents` 更方便。以下是我们可以如何使用 `readFile` 重写之前的示例：'
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because we don’t get a handle with which to identify our file, we can’t close
    it manually, so Haskell does that for us when we use `readFile`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有句柄来识别我们的文件，所以我们不能手动关闭它，所以当使用 `readFile` 时，Haskell 会为我们做这件事。
- en: 'The `writeFile` function has a type of `writeFile :: FilePath -> String ->
    IO ()`. It takes a path to a file and a string to write to that file and returns
    an I/O action that will do the writing. If such a file already exists, it will
    be stomped down to zero length before being written to. Here’s how to turn *girlfriend.txt*
    into a caps-locked version and write it to *girlfriendcaps.txt*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeFile` 函数的类型为 `writeFile :: FilePath -> String -> IO ()`。它接受一个文件的路径和一个要写入该文件的字符串，并返回一个将执行写入的
    I/O 操作。如果这样的文件已存在，它将在写入之前被截断为零长度。以下是如何将 *girlfriend.txt* 转换为大写版本并将其写入 *girlfriendcaps.txt*：'
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `appendFile` function has the same type signature as `writeFile` and acts
    almost the same way. The only difference is that `appendFile` doesn’t truncate
    the file to zero length if it already exists. Instead, it appends stuff to the
    end of that file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendFile` 函数与 `writeFile` 函数具有相同的类型签名，并且几乎以相同的方式工作。唯一的区别是，如果文件已存在，`appendFile`
    不会将其截断为零长度。相反，它将内容追加到该文件的末尾。'
- en: To-Do Lists
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表
- en: 'Let’s put the `appendFile` function to use by making a program that adds a
    task to a text file that lists stuff that we have to do. We’ll assume that the
    file is named *todo.txt* and that it contains one task per line. Our program will
    take a line from the standard input and add it to our to-do list:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个程序来使用 `appendFile` 函数，该程序将任务添加到列出我们必须做的事情的文本文件中。我们假设该文件名为 *todo.txt*，并且它包含每行一个任务。我们的程序将从标准输入读取一行并将其添加到我们的待办事项列表中：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we added the `"\n"` to the end of each line, because `getLine` doesn’t
    give us a newline character at the end.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在每行的末尾添加了 `"\n"`，因为 `getLine` 不会给我们一个换行符。
- en: Save the file as *appendtodo.hs*, compile it, and then run it a few times and
    give it some to-do items.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为 *appendtodo.hs*，编译它，然后运行几次，并给它一些待办事项。
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`cat` is a program on Unix-type systems that can be used to print text files
    to the terminal. On Windows systems, you can use your favorite text editor to
    see what’s inside *todo.txt* at any given time.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat` 是 Unix 类型的系统上的一个程序，可以用来将文本文件打印到终端。在 Windows 系统上，您可以使用您喜欢的文本编辑器查看任何给定时间
    *todo.txt* 中的内容。'
- en: Deleting Items
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除项目
- en: We already made a program to add a new item to our to-do list in *todo.txt*.
    Now let’s make a program to remove an item. We’ll use a few new functions from
    `System.Directory` and one new function from `System.IO`, which will all be explained
    after the code listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个程序来向我们的待办事项列表 *todo.txt* 中添加新项目。现在让我们编写一个程序来删除项目。我们将使用 `System.Directory`
    的一些新函数和 `System.IO` 中的一个新函数，所有这些函数将在代码列表之后进行解释。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, we read *todo.txt* and bind its contents to `contents`. Then we split
    the contents into a list of strings, with one line for each string. So `todoTasks`
    is now something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们读取 *todo.txt* 并将其内容绑定到 `contents`。然后我们将内容拆分为一个字符串列表，每行一个字符串。所以 `todoTasks`
    现在看起来像这样：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We zip the numbers from `0` onward and that list with a function that takes
    a number (like `3`) and a string (like `"hey"`) and returns a new string (like
    `"3 - hey"`). Now `numberedTasks` looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `0` 及其以上的数字与一个函数进行压缩，该函数接受一个数字（如 `3`）和一个字符串（如 `"hey"`），并返回一个新的字符串（如 `"3
    - hey"`）。现在 `numberedTasks` 看起来像这样：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We then use `mapM_ putStrLn numberedTasks` to print each task on a separate
    line, ask the user which one to delete, and wait for the user to enter a number.
    Let’s say we want to delete number `1` (`Dust the dog`), so we punch in `1`. `numberString`
    is now `"1"`, and because we want a number rather than a string, we apply `read`
    to that to get `1` and use a `let` to bind that to `number`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `mapM_ putStrLn numberedTasks` 来逐行打印每个任务，询问用户要删除哪个，并等待用户输入一个数字。假设我们想要删除编号
    `1` (`Dust the dog`)，所以我们输入 `1`。`numberString` 现在是 `"1"`，因为我们想要一个数字而不是一个字符串，所以我们应用
    `read` 来获取 `1` 并使用 `let` 将其绑定到 `number`。
- en: Remember the `delete` and `!!` functions from `Data.List`? `!!` returns an element
    from a list with some index. `delete` deletes the first occurrence of an element
    in a list and returns a new list without that occurrence. `(todoTasks !! number)`
    results in `"Dust the dog"`. We delete the the first occurrence of `"Dust the
    dog"` from `todoTasks` and then join that into a single line with `unlines` and
    name that `newTodoItems`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 `delete` 和 `!!` 函数吗？`!!` 从列表中返回一个具有某些索引的元素。`delete` 从列表中删除元素的第一种出现，并返回一个不包含该出现的新列表。`(todoTasks
    !! number)` 结果为 `"Dust the dog"`。我们从 `todoTasks` 中删除 `"Dust the dog"` 的第一次出现，然后使用
    `unlines` 将其合并成一行，并将其命名为 `newTodoItems`。
- en: 'Then we use a function that we haven’t met before, from `System.IO`: `openTempFile`.
    Its name is pretty self-explanatory. It takes a path to a temporary directory
    and a template name for a file and opens a temporary file. We used `"."` for the
    temporary directory, because `.` denotes the current directory on just about any
    operating system. We used `"temp"` as the template name for the temporary file,
    which means that the temporary file will be named *temp* plus some random characters.
    It returns an I/O action that makes the temporary file, and the result in that
    I/O action is a pair of values: the name of the temporary file and a handle. We
    could just open a normal file called *todo2.txt* or something like that, but it’s
    better practice to use `openTempFile` so you know you’re probably not overwriting
    anything.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用一个之前未曾遇到的函数，来自 `System.IO` 的 `openTempFile`。它的名字相当直观。它接受一个指向临时目录的路径和一个文件模板名称，并打开一个临时文件。我们使用
    `"."` 作为临时目录，因为在几乎任何操作系统上，`.` 都表示当前目录。我们使用 `"temp"` 作为临时文件的模板名称，这意味着临时文件将被命名为
    *temp* 加上一些随机字符。它返回一个创建临时文件的 I/O 操作，在该 I/O 操作的结果中是一个值对：临时文件名称和处理句柄。我们本可以直接打开一个名为
    *todo2.txt* 或类似的普通文件，但使用 `openTempFile` 是更好的实践，这样你知道你不太可能覆盖任何东西。
- en: Now that we have a temporary file opened, we write `newTodoItems` to it. The
    old file is unchanged, and the temporary file contains all the lines that the
    old one does, except the one we deleted.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打开了临时文件，我们将 `newTodoItems` 写入其中。旧文件保持不变，临时文件包含旧文件的所有行，除了我们删除的那一行。
- en: After that, we close both the original and the temporary files, and remove the
    original one with `removeFile`, which takes a path to a file and deletes it. After
    deleting the old *todo.txt*, we use `renameFile` to rename the temporary file
    to *todo.txt*. `removeFile` and `renameFile` (which are both in `System.Directory`)
    take file paths, not handles, as their parameters.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们关闭原始和临时文件，并使用 `removeFile` 删除原始文件，该函数接受一个文件路径并删除它。在删除旧的 *todo.txt* 之后，我们使用
    `renameFile` 将临时文件重命名为 *todo.txt*。`removeFile` 和 `renameFile`（都在 `System.Directory`
    中）接受文件路径而不是句柄作为它们的参数。
- en: 'Save this as *deletetodo.hs*, compile it, and try it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为 *deletetodo.hs*，编译并尝试运行：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let’s see which items remain:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看哪些条目仍然存在：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Ah, cool! Let’s delete one more item:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，酷！让我们再删除一个条目：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And examining the file, we see that only one item remains:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件后，我们看到只有一个条目剩下：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, everything is working. However, there’s one thing that about this program
    that’s kind of off. If something goes wrong after we open our temporary file,
    the program terminates, but the temporary file doesn’t get cleaned up. Let’s remedy
    that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一切正常。然而，关于这个程序有一件事有点不对劲。如果我们打开临时文件后出现问题，程序会终止，但临时文件不会得到清理。让我们解决这个问题。
- en: Cleaning Up
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: 'To make sure our temporary file is cleaned up in case of a problem, we’re going
    to use the `bracketOnError` function from `Control.Exception`. It’s very similar
    to `bracket`, but whereas the `bracket` will acquire a resource and then make
    sure that some cleanup always gets done after we’ve used it, `bracketOnError`
    performs the cleanup only if an exception has been raised. Here’s the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在出现问题时清理我们的临时文件，我们将使用来自 `Control.Exception` 的 `bracketOnError` 函数。它与 `bracket`
    非常相似，但 `bracket` 会获取资源并在我们使用后确保总是执行一些清理，而 `bracketOnError` 仅在抛出异常时执行清理。以下是代码：
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Instead of just using `openTempFile` normally, we use it with `bracketOnError`.
    Next, we write what we want to happen if an error occurs; that is, we want to
    close the temporary handle and remove the temporary file. Finally, we write what
    we want to do with the temporary file while things are going well, and these lines
    are the same as they were before. We write the new items, close the temporary
    handle, remove our current file, and rename the temporary file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是正常使用 `openTempFile`，而是用 `bracketOnError` 来使用它。接下来，我们编写当发生错误时我们希望发生的事情；也就是说，我们希望关闭临时句柄并删除临时文件。最后，我们编写当一切顺利时我们希望对临时文件做什么，这些行与之前相同。我们写入新项目，关闭临时句柄，删除我们的当前文件，并将临时文件重命名。
- en: Command-Line Arguments
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行参数
- en: Dealing with command-line arguments is pretty much a necessity if you want to
    make a script or application that runs on a terminal. Luckily, Haskell’s standard
    library has a nice way of getting command-line arguments for a program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 处理命令行参数如果你想要制作一个在终端上运行的脚本或应用程序几乎是必需的。幸运的是，Haskell 的标准库提供了一个很好的方法来获取程序的命令行参数。
- en: In the previous section, we made one program for adding an item to our to-do
    list and one program for removing an item. A problem with them is that we just
    hardcoded the name of our to-do file. We decided that the file will be named *todo.txt*
    and that users will never have a need for managing several to-do lists.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们制作了一个用于向我们的待办事项列表添加项目的程序和一个用于删除项目的程序。它们的问题是我们只是硬编码了我们的待办文件名。我们决定文件将命名为*todo.txt*，并且用户永远不会需要管理多个待办事项列表。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802626.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802626.png.jpg)'
- en: One solution is to always ask the users which file they want to use as their
    to-do list. We used that approach when we wanted to know which item to delete.
    It works, but it’s not the ideal solution because it requires the users to run
    the program, wait for the program to ask them something, and then give the program
    some input. That’s called an *interactive* program.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是始终询问用户他们想要使用哪个文件作为他们的待办事项列表。我们在想要知道要删除哪个项目时使用了这种方法。它有效，但不是最佳解决方案，因为它要求用户运行程序，等待程序询问他们，然后向程序提供一些输入。这被称为*交互式*程序。
- en: 'The difficult bit with interactive command-line programs is this: What if you
    want to automate the execution of that program, as with a script? It’s harder
    to make a script that interacts with a program than a script that just calls one
    or more programs. That’s why we sometimes want users to tell a program what they
    want when they run the program, instead of having the program ask the user once
    it’s running. And what better way to have the users tell the program what they
    want it to do when they run it than via command-line arguments?'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与交互式命令行程序相关的难题是：如果你想要自动化程序的执行，就像脚本一样，制作一个与程序交互的脚本比只调用一个或多个程序的脚本要难。这就是为什么我们有时希望用户在运行程序时告诉程序他们想要什么，而不是让程序在运行时询问用户。那么，还有什么更好的方法让用户在运行程序时告诉程序他们想要它做什么，比通过命令行参数更合适呢？
- en: 'The `System.Environment` module has two cool I/O actions that are useful for
    getting command-line arguments: `getArgs` and `getProgName`. `getArgs` has a type
    of `getArgs :: IO [String]` and is an I/O action that will get the arguments that
    the program was run with and yield a list of those arguments. `getProgName` has
    a type of `getProgName :: IO String` and is an I/O action that yields the program
    name. Here’s a small program that demonstrates how these two work:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Environment`模块有两个酷炫的I/O操作，用于获取命令行参数：`getArgs`和`getProgName`。`getArgs`的类型为`getArgs
    :: IO [String]`，它是一个I/O操作，将获取程序运行时使用的参数，并返回这些参数的列表。`getProgName`的类型为`getProgName
    :: IO String`，它是一个I/O操作，返回程序名称。以下是一个小型程序，演示了这两个操作的工作原理：'
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, we bind the command-line arguments to `args` and program name to `progName`.
    Next, we use `putStrLn` to print all the program’s arguments and then the name
    of the program itself. Let’s compile this as `arg-test` and try it out:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将命令行参数绑定到`args`，将程序名称绑定到`progName`。然后，我们使用`putStrLn`打印出所有程序参数以及程序本身的名称。让我们将其编译为`arg-test`并尝试运行它：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: More Fun with To-Do Lists
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与待办事项列表的更多乐趣
- en: In the previous examples, we made one program for adding tasks and an entirely
    separate program for deleting them. Now we’re going to join that into a single
    program, and whether it adds or deletes items will depend on the command-line
    arguments we pass to it. We’ll also make it able to operate on different files,
    not just *todo.txt*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们制作了一个用于添加任务的程序和一个完全独立的用于删除它们的程序。现在我们将它们合并成一个程序，它是否添加或删除项目将取决于我们传递给它的命令行参数。我们还将使其能够操作不同的文件，而不仅仅是*todo.txt*。
- en: 'We’ll call our program `todo`, and it will be able to do three different things:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的程序命名为`todo`，它将能够执行三种不同的操作：
- en: View tasks
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看任务
- en: Add tasks
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加任务
- en: Delete tasks
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除任务
- en: 'To add a task to the *todo.txt* file, we enter it at the terminal:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任务添加到*todo.txt*文件中，我们在终端输入它：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To view the tasks, we enter the `view` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看任务，我们输入`view`命令：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To remove a task, we use its index:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除任务，我们使用其索引：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A Multitasking Task List
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多任务待办事项列表
- en: 'We’ll start by making a function that takes a command in the form of a string,
    like `"add"` or `"view"`, and returns a function that takes a list of arguments
    and returns an I/O action that does what we want:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个函数，该函数接受一个字符串形式的命令，如`"add"`或`"view"`，并返回一个函数，该函数接受一个参数列表并返回一个执行我们想要的I/O操作的动作：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We’ll define `main` like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义`main`如下：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we get the arguments and bind them to `(command:argList)`. This means
    that the first argument will be bound to `command`, and the rest of the arguments
    will be bound to `argList`. In the next line of our `main` block, we apply the
    `dispatch` function to the command, which results in the `add`, `view`, or `remove`
    function. We then apply that function to `argList`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取参数并将它们绑定到 `(command:argList)`。这意味着第一个参数将被绑定到 `command`，其余的参数将被绑定到 `argList`。在
    `main` 块的下一行，我们将 `dispatch` 函数应用于命令，这会导致 `add`、`view` 或 `remove` 函数。然后我们将该函数应用于
    `argList`。
- en: 'Suppose we call our program like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们这样调用我们的程序：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`command` is `"add"`, and `argList` is `["todo.txt", "Find the magic sword
    of power"]`. That way, the second pattern match of the `dispatch` function will
    succeed, and it will return the `add` function. Finally, we apply that to `argList`,
    which results in an I/O action that adds the item to our to-do list.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`command` 是 `"add"`，而 `argList` 是 `["todo.txt", "Find the magic sword of power"]`。这样，`dispatch`
    函数的第二个模式匹配就会成功，它将返回 `add` 函数。最后，我们将该函数应用于 `argList`，这将导致一个 I/O 动作，将项目添加到我们的待办事项列表中。'
- en: 'Now let’s implement the `add`, `view`, and `remove` functions. Let’s start
    with `add`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现 `add`、`view` 和 `remove` 函数。让我们从 `add` 开始：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We might call our program like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能这样调用我们的程序：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `"add"` will be bound to `command` in the first pattern match in the `main`
    block, whereas `["todo.txt", "Find the magic sword of power"]` will be passed
    to the function that we get from the `dispatch` function. So, because we’re not
    dealing with bad input right now, we just pattern match against a list with those
    two elements immediately and return an I/O action that appends that line to the
    end of the file, along with a newline character.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 块的第一个模式匹配中，`"add"` 将被绑定到 `command`，而 `["todo.txt", "Find the magic
    sword of power"]` 将传递给从 `dispatch` 函数获得的函数。因此，因为我们现在没有处理错误输入，所以我们立即对包含这两个元素的列表进行模式匹配，并返回一个
    I/O 动作，将这一行追加到文件的末尾，并附带一个换行符。
- en: 'Next, let’s implement the list-viewing functionality. If we want to view the
    items in a file, we do `./todo view todo.txt`. So in the first pattern match,
    `command` will be `"view"`, and `argList` will be `["todo.txt"]`. Here’s the function
    in full:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现列表查看功能。如果我们想查看文件中的项目，我们执行 `./todo view todo.txt`。所以在第一个模式匹配中，`command`
    将是 `"view"`，而 `argList` 将是 `["todo.txt"]`。下面是完整的函数：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When we made our `deletetodo` program, which could only delete items from a
    to-do list, it had the ability to display the items in a to-do list, so this code
    is very similar to that part of the previous program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `deletetodo` 程序，该程序只能从待办事项列表中删除项目时，它具有显示待办事项列表中项目的能力，所以这段代码与上一个程序的那部分非常相似。
- en: Finally, we’re going to implement `remove`. It’s very similar to the program
    that only deleted the tasks, so if you don’t understand how deleting an item here
    works, review [Deleting Items](ch09s03.html#deleting_items "Deleting Items") in
    [Deleting Items](ch09s03.html#deleting_items "Deleting Items"). The main difference
    is that we’re not hardcoding the filename as *todo.txt* but instead getting it
    as an argument. We’re also getting the target task number as an argument, rather
    than prompting the user for it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现 `remove`。它与只删除任务的程序非常相似，所以如果你不明白这里删除项的工作原理，请回顾 [删除项](ch09s03.html#deleting_items
    "删除项") 在 [删除项](ch09s03.html#deleting_items "删除项")。
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We opened the file based on `fileName` and opened a temporary file, deleted
    the line with the index that the user wants to delete, wrote that to the temporary
    file, removed the original file, and renamed the temporary file back to `fileName`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据 `fileName` 打开了文件，并打开了一个临时文件，删除了用户想要删除的行，将其写入临时文件，删除了原始文件，并将临时文件重命名为 `fileName`。
- en: 'Here’s the whole program in all its glory:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是整个程序的全貌：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To summarize our solution, we made a `dispatch` function that maps from commands
    to functions that take some command-line arguments in the form of a list and return
    an I/O action. We see what the `command` is, and based on that, we get the appropriate
    function from the `dispatch` function. We call that function with the rest of
    the command-line arguments to get back an I/O action that will do the appropriate
    thing, and then just perform that action. Using higher-order functions allows
    us to just tell the `dispatch` function to give us the appropriate function, and
    then tell that function to give us an I/O action for some command-line arguments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们的解决方案，我们创建了一个`dispatch`函数，它将命令映射到以列表形式接受一些命令行参数的函数，并返回一个I/O操作。我们看到`command`是什么，然后根据这个，从`dispatch`函数中获取适当的函数。我们用剩余的命令行参数调用该函数，以获取一个将执行适当操作的I/O操作，然后只需执行该操作即可。使用高阶函数允许我们只需告诉`dispatch`函数给我们适当的函数，然后告诉该函数给我们一些命令行参数的I/O操作。
- en: Let’s try our app!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行我们的应用程序！
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Another cool thing about using the `dispatch` function is that it’s easy to
    add functionality. Just add an extra pattern to `dispatch` and implement the corresponding
    function, and you’re laughing! As an exercise, you can try implementing a `bump`
    function that will take a file and a task number and return an I/O action that
    bumps that task to the top of the to-do list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dispatch`函数的另一个酷特点是添加功能很容易。只需向`dispatch`添加一个额外的模式并实现相应的函数，然后你就可以笑出来了！作为一个练习，你可以尝试实现一个`bump`函数，该函数将接受一个文件和一个任务编号，并返回一个将任务提升到待办列表顶部的I/O操作。
- en: Dealing with Bad Input
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误输入
- en: 'We could extend this program to make it fail a bit more gracefully in the case
    of bad input, instead of printing out an ugly error message from Haskell. We can
    start by adding a catchall pattern at the end the `dispatch` function and making
    it return a function that ignores the argument list and tells us that such a command
    doesn’t exist:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个程序扩展，使其在遇到错误输入时更加优雅地失败，而不是从Haskell中打印出丑陋的错误信息。我们可以通过在`dispatch`函数的末尾添加一个通配符模式，并使其返回一个忽略参数列表并告诉我们该命令不存在的函数来开始：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We might also add catchall patterns to the `add`, `view`, and `remove` functions,
    so that the program tells users if they have supplied the wrong number of arguments
    to a given command. Here’s an example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向`add`、`view`和`remove`函数添加通配符模式，这样程序就能告诉用户他们是否给某个命令提供了错误的参数数量。以下是一个例子：
- en: '[PRE56]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If `add` is applied to a list that doesn’t have exactly two elements, the first
    pattern match will fail, but the second one will succeed, helpfully informing
    users of their erronous ways. We can add a catchall pattern like this to `view`
    and `remove` as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`add`应用于不恰好包含两个元素的列表，第一个模式匹配将失败，但第二个模式匹配将成功，并有助于用户了解他们的错误方式。我们也可以将类似的通配符模式添加到`view`和`remove`中。
- en: 'Note that we haven’t covered all of the cases where our input is bad. For instance,
    suppose we run our program like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还没有涵盖所有输入错误的情况。例如，假设我们像这样运行我们的程序：
- en: '[PRE57]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this case, it will crash, because we use the `(command:argList)` pattern
    in our `do` block, but that doesn’t consider the possibility that there are no
    arguments at all! We also don’t check to see if the file we’re operating on exists
    before trying to open it. Adding these precautions isn’t hard, but it is a bit
    tedious, so making this program completely idiot-proof is left as an exercise
    to the reader.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，程序将会崩溃，因为我们使用了`do`块中的`(command:argList)`模式，但没有考虑到没有任何参数的情况！我们也没有在尝试打开文件之前检查我们正在操作的文件是否存在。添加这些预防措施并不难，但有点繁琐，因此将这个程序完全做成傻瓜式留给了读者作为练习。
- en: Randomness
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机性
- en: Many times while programming, you need to get some random data (well, *pseudo*-random
    data, since we all know that the only true source of randomness is a monkey on
    a unicycle with cheese in one hand and its butt in the other). For example, you
    may be making a game where a die needs to be thrown, or you need to generate some
    data to test your program. In this section, we’ll take a look at how to make Haskell
    generate seemingly random data and why we need external input to generate values
    that are random enough.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程过程中，很多时候你需要获取一些随机数据（好吧，*伪随机*数据，因为我们都知道唯一真正的随机源是一个骑独轮车、一手拿着奶酪、另一手拿着屁股的猴子）。例如，你可能正在制作一个需要掷骰子的游戏，或者你需要生成一些数据来测试你的程序。在本节中，我们将探讨如何让Haskell生成看似随机的数据，以及为什么我们需要外部输入来生成足够随机的值。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802628.png.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802628.png.jpg)'
- en: Most programming languages have functions that give you back some random number.
    Each time you call that function, you retrieve a different random number. How
    about Haskell? Well, remember that Haskell is a purely functional language. That
    means it has referential transparency. And *that* means a function, if given the
    same parameters twice, must produce the same result twice. That’s really cool,
    because it allows us to reason about programs, and it enables us to defer evaluation
    until we really need it. However, this makes it a bit tricky for getting random
    numbers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有返回随机数的函数。每次调用该函数时，你都会获取一个不同的随机数。Haskell 呢？记住 Haskell 是一种纯函数式语言。这意味着它具有引用透明性。而这意味着一个函数，如果给定了相同的参数两次，必须产生两次相同的结果。这真的很酷，因为它允许我们推理程序，并使我们能够延迟求值直到真正需要它。然而，这也使得获取随机数变得有些棘手。
- en: 'Suppose we have a function like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个这样的函数：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It’s not very useful as a random number function, because it will always return
    `4`. (Even though I can assure you that the `4` is completely random, because
    I used a die to determine it.)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为随机数函数来说，它并不太有用，因为它总是会返回 `4`。（尽管我可以向你保证这个 `4` 是完全随机的，因为我使用骰子来决定它。）
- en: How do other languages make seemingly random numbers? Well, they take some initial
    data, like the current time, and based on that, generate numbers that are seemingly
    random. In Haskell, we can generate random numbers by making a function that takes
    as its parameter some initial data, or randomness, and produces a random number.
    We use I/O to bring randomness into our program from outside.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言是如何生成看似随机的数的呢？嗯，它们会取一些初始数据，比如当前时间，然后基于这些数据生成看似随机的数。在 Haskell 中，我们可以通过创建一个函数来生成随机数，这个函数接受一些初始数据或随机性作为参数，并产生一个随机数。我们使用
    I/O 将随机性从外部引入我们的程序。
- en: 'Enter the `System.Random` module. It has all the functions that satisfy our
    need for randomness. Let’s just dive into one of the functions it exports: `random`.
    Here is its type signature:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `System.Random` 模块。它包含了所有满足我们随机需求的功能。让我们直接深入到它导出的一个函数：`random`。这是它的类型签名：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Whoa! We have some new type classes in this type declaration! The `RandomGen`
    type class is for types that can act as sources of randomness. The `Random` type
    class is for types whose values can be random. We can generate random Boolean
    values by randomly producing either `True` or `False`. We can also generate numbers
    that are random. Can a function take on a random value? I don’t think so! If we
    try to translate the type declaration of `random` to English, we get something
    like this: It takes a random generator (that’s our source of randomness) and returns
    a random value and a new random generator. Why does it also return a new generator
    as well as a random value? Well, you’ll see in a moment.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！在这个类型声明中我们有一些新的类型类！`RandomGen` 类型类是为可以作为随机性来源的类型。`Random` 类型类是为其值可以是随机的类型。我们可以通过随机产生
    `True` 或 `False` 来生成随机的布尔值。我们也可以生成随机的数字。一个函数能取一个随机值吗？我不这么认为！如果我们尝试将 `random` 的类型声明翻译成英文，我们得到的东西类似于这样：它接受一个随机生成器（这是我们随机性的来源）并返回一个随机值和一个新的随机生成器。为什么它还要返回一个新的生成器以及一个随机值呢？好吧，你很快就会看到。
- en: To use our `random` function, we need to get our hands on one of those random
    generators. The `System.Random` module exports a cool type, namely `StdGen`, which
    is an instance of the `RandomGen` type class. We can make a `StdGen` manually,
    or we can tell the system to give us one based on a multitude of (sort of) random
    stuff.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的 `random` 函数，我们需要获取那些随机生成器中的一个。`System.Random` 模块导出了一个酷炫的类型，即 `StdGen`，它是
    `RandomGen` 类型类的一个实例。我们可以手动创建一个 `StdGen`，或者我们可以告诉系统根据多种（某种程度上的）随机因素给我们提供一个。
- en: 'To manually make a random generator, use the `mkStdGen` function. It has a
    type of `mkStdGen :: Int -> StdGen`. It takes an integer, and based on that, gives
    us a random generator. Okay then, let’s try using `random` and `mkStdGen` in tandem
    to get a (hardly) random number.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '要手动创建一个随机生成器，请使用 `mkStdGen` 函数。它的类型是 `mkStdGen :: Int -> StdGen`。它接受一个整数，并根据这个整数给我们提供一个随机生成器。那么，让我们尝试一起使用
    `random` 和 `mkStdGen` 来获取一个（几乎）随机的数。'
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What’s this? Ah, right, the `random` function can return a value of any type
    that’s part of the `Random` type class, so we need to inform Haskell which type
    we want. Also let’s not forget that it returns a random value and a random generator
    in a pair.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？啊，对了，`random` 函数可以返回 `Random` 类型类中任何类型的值，所以我们需要通知 Haskell 我们想要哪种类型。另外，别忘了它以一对的形式返回一个随机值和一个随机生成器。
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, a number that looks kind of random! The first component of the tuple
    is our number, and the second component is a textual representation of our new
    random generator. What happens if we call random with the same random generator
    again?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个看起来有点随机的数字！元组的第一个组件是我们的数字，第二个组件是我们新随机生成器的文本表示。如果我们再次用相同的随机生成器调用 `random`
    会发生什么？
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Of course, we get the same result for the same parameters. So let’s try giving
    it a different random generator as a parameter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于相同的参数，我们得到相同的结果。所以让我们尝试给它一个不同的随机生成器作为参数：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Great, a different number! We can use the type annotation to get different types
    back from that function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，一个不同的数字！我们可以使用类型注解从该函数获取不同的类型。
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Tossing a Coin
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掷硬币
- en: Let’s make a function that simulates tossing a coin three times. If `random`
    didn’t return a new generator along with a random value, we would need to make
    this function take three random generators as a parameter and return coin tosses
    for each of them. But if one generator can make a random value of type `Int` (which
    can take on a load of different values), it should be able to make three coin
    tosses (which can have only eight different end results). So this is where `random`
    returning a new generator along with a value comes in handy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个模拟掷硬币三次的函数。如果 `random` 没有返回一个随机值和一个新的生成器，我们就需要让这个函数接受三个随机生成器作为参数，并为每个生成器返回硬币投掷结果。但是，如果一个生成器可以生成类型
    `Int` 的随机值（它可以有大量不同的值），它应该能够生成三次硬币投掷（只能有八个不同的最终结果）。所以这就是 `random` 返回一个值和一个新的生成器时非常有用的地方。
- en: 'We’ll represent a coin with a simple `Bool`: `True` is tails, and `False` is
    heads.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个简单的 `Bool` 来表示一枚硬币：`True` 表示反面，`False` 表示正面。
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We call `random` with the generator we got as a parameter to get a coin and
    a new generator. Then we call it again, only this time with our new generator,
    to get the second coin. We do the same for the third coin. Had we called it with
    the same generator every time, all the coins would have had the same value, so
    we would get only `(False, False, False)` or `(True, True, True)` as a result.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用作为参数获取的生成器调用 `random` 来获取一枚硬币和一个新的生成器。然后我们再次调用它，但这次是用我们的新生成器，以获取第二枚硬币。我们对第三枚硬币做同样的操作。如果我们每次都使用相同的生成器，所有硬币的值都会相同，所以我们只会得到
    `(False, False, False)` 或 `(True, True, True)` 作为结果。
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Notice that we didn’t need to call `random gen :: (Bool, StdGen)`. Since we
    already specified that we want Booleans in the type declaration of the function,
    Haskell can infer that we want a Boolean value in this case.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们不需要调用 `random gen :: (Bool, StdGen)`。因为我们已经在函数的类型声明中指定了我们要布尔值，所以 Haskell
    可以推断出在这种情况下我们想要一个布尔值。'
- en: More Random Functions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多随机函数
- en: What if we want to flip more coins? For that, there’s a function called `randoms`,
    which takes a generator and returns an infinite sequence of values based on that
    generator.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要掷更多硬币呢？为此，有一个名为 `randoms` 的函数，它接受一个生成器并返回基于该生成器的无限序列值。
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Why doesn’t `randoms` return a new generator as well as a list? We could implement
    the `randoms` function very easily like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `randoms` 不返回一个新的生成器以及一个列表？我们可以非常容易地实现 `randoms` 函数如下：
- en: '[PRE68]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is a recursive definition. We get a random value and a new generator from
    the current generator, and then make a list that has the value as its head and
    random numbers based on the new generator as its tail. Because we need to be able
    to potentially generate an infinite amount of numbers, we can’t give the new random
    generator back.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归定义。我们从当前生成器中获取一个随机值和一个新的生成器，然后创建一个列表，其头部是值，其尾部是基于新生成器的随机数。因为我们可能需要生成无限数量的数字，所以我们不能将新的随机生成器返回。
- en: 'We could make a function that generates a finite stream of numbers and a new
    generator like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数，生成一个有限流数字和一个新的生成器，如下所示：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Again, this is a recursive definition. We say that if we want zero numbers,
    we just return an empty list and the generator that was given to us. For any other
    number of random values, we first get one random number and a new generator. That
    will be the head. Then we say that the tail will be `n - 1` numbers generated
    with the new generator. Then we return the head and the rest of the list joined
    and the final generator that we got from getting the `n - 1` random numbers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个递归定义。我们说，如果我们想要零个数字，我们只需返回一个空列表和给我们的生成器。对于任何其他数量的随机值，我们首先获取一个随机数和一个新的生成器。这将作为头部。然后我们说尾部将是使用新生成器生成的
    `n - 1` 个数字。然后我们返回头部和列表的其余部分连接，以及我们从获取 `n - 1` 个随机数得到的最终生成器。
- en: 'What if we want a random value in some sort of range? All the random integers
    so far were outrageously big or small. What if we want to throw a die? Well, we
    use `randomR` for that purpose. It has this type:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要某个范围内的随机值怎么办？到目前为止的所有随机整数都太大或太小。如果我们想掷骰子怎么办？嗯，我们用 `randomR` 来实现这个目的。它有这个类型：
- en: '[PRE70]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This means that it’s kind of like `random`, but it takes as its first parameter
    a pair of values that set the lower and upper bounds, and the final value produced
    will be within those bounds.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它有点像 `random`，但它将一对值作为其第一个参数，这些值设置了下限和上限，并且最终生成的值将在这个范围内。
- en: '[PRE71]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'There’s also `randomRs`, which produces a stream of random values within our
    defined ranges. Check this out:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `randomRs`，它可以在我们定义的范围内生成随机值的流。看看这个例子：
- en: '[PRE72]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: It looks like a super secret password, doesn’t it?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像一个非常秘密的密码，不是吗？
- en: Randomness and I/O
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机性和 I/O
- en: You may be wondering what this section has to do with I/O. We haven’t done anything
    concerning I/O so far. We’ve always made our random number generator manually
    by creating it with some arbitrary integer. The problem is that if we do that
    in our real programs, they will always return the same random numbers, which is
    no good for us. That’s why `System.Random` offers the `getStdGen` I/O action,
    which has a type of `IO StdGen`. It asks the system for some initial data and
    uses it to jump-start the *global generator*. `getStdGen` fetches that global
    random generator when you bind it to something.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这一节与 I/O 有什么关系。到目前为止，我们还没有做任何关于 I/O 的事情。我们总是通过创建一些任意的整数来手动制作我们的随机数生成器。问题是，如果我们真的在我们的实际程序中这样做，它们总是会返回相同的随机数，这对我们来说是不好的。这就是为什么
    `System.Random` 提供了 `getStdGen` I/O 操作，它具有 `IO StdGen` 类型。它向系统请求一些初始数据，并使用它来启动
    *全局生成器*。`getStdGen` 在你将其绑定到某个东西时获取那个全局随机生成器。
- en: 'Here’s a simple program that generates a random string:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的程序，它可以生成一个随机字符串：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now let’s test it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试它：
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'But you need to be careful. Just performing `getStdGen` twice will ask the
    system for the same global generator twice. Suppose we do this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但你需要小心。仅仅执行两次 `getStdGen` 就会向系统请求两次相同的全局生成器。假设我们这样做：
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We will get the same string printed out twice!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两次打印出相同的字符串！
- en: The best way to get two different strings is to use the `newStdGen` action,
    which splits our current random generator into two generators. It updates the
    global random generator with one of them and yields the other as its result.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 获取两个不同字符串的最佳方式是使用 `newStdGen` 操作，它将我们的当前随机生成器分成两个生成器。它使用其中一个更新全局随机生成器，并将另一个作为其结果产生。
- en: '[PRE76]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Not only do we get a new random generator when we bind `newStdGen` to something,
    but the global one gets updated as well. This means that if we do `getStdGen`
    again and bind it to something, we’ll get a generator that’s not the same as `gen`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅当我们把 `newStdGen` 绑定到某个东西上时我们会得到一个新的随机生成器，全局生成器也会更新。这意味着如果我们再次执行 `getStdGen`
    并将其绑定到某个东西上，我们会得到一个与 `gen` 不同的生成器。
- en: 'Here’s a little program that will make the user guess which number it’s thinking
    of:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小程序，它会让用户猜测它正在想的是哪个数字：
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802630.png.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802630.png.jpg)'
- en: We make a function `askForNumber`, which takes a random number generator and
    returns an I/O action that will prompt you for a number, and then tell you if
    you guessed it right.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数 `askForNumber`，它接受一个随机数生成器，并返回一个 I/O 操作，该操作会提示你输入一个数字，然后告诉你是否猜对了。
- en: In `askForNumber`, we first generate a random number and a new generator based
    on the generator that we got as a parameter and call them `randNumber` and `newGen`.
    (For this example, let’s say that the number generated was 7.) Then we tell the
    user to guess which number we’re thinking of. We perform `getLine` and bind its
    result to `numberString`. When the user enters `7`, `numberString` becomes `"7"`.
    Next, we use `when` to check if the string the user entered is an empty string.
    If it isn’t, the action consisting of the `do` block that is passed to `when`
    is performed. We use `read` on `numberString` to convert it to a number, so `number`
    is now `7`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `askForNumber` 中，我们首先生成一个随机数和一个基于我们作为参数得到的生成器的新生成器，并将它们命名为 `randNumber` 和
    `newGen`。（在这个例子中，让我们假设生成的数字是 7。）然后我们告诉用户猜测我们在想哪个数字。我们执行 `getLine` 并将其结果绑定到 `numberString`。当用户输入
    `7` 时，`numberString` 变为 `"7"`。接下来，我们使用 `when` 来检查用户输入的字符串是否为空字符串。如果不是，将执行传递给 `when`
    的 `do` 块组成的操作。我们使用 `read` 对 `numberString` 进行操作以将其转换为数字，因此 `number` 现在是 `7`。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the user enters some input that `read` can’t parse (like `"haha"`), our program
    will crash with an ugly error message. If you don’t want your program to crash
    on erronous input, use `reads`, which returns an empty list when it fails to read
    a string. When it succeeds, it returns a singleton list with a tuple that has
    your desired value as one component and a string with what it didn’t consume as
    the other. Try it!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了一些 `read` 无法解析的输入（比如 `"haha"`），我们的程序将因一个丑陋的错误信息而崩溃。如果您不希望程序在错误输入上崩溃，请使用
    `reads`，它在无法读取字符串时返回一个空列表。当它成功时，它返回一个包含元组的单元素列表，其中一个组件是您希望的价值，另一个组件是它没有消费的字符串。试试看！
- en: We check if the number that we entered is equal to the one generated randomly
    and give the user the appropriate message. Then we perform `askForNumber` recursively,
    but this time with the new generator that we got. This gives us an I/O action
    that’s just like the one we performed, except that it depends on a different generator.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查我们输入的数字是否等于随机生成的数字，并给用户相应的信息。然后我们递归地执行 `askForNumber`，但这次使用我们得到的新生成器。这给我们一个
    I/O 操作，就像我们执行的操作一样，只是它依赖于不同的生成器。
- en: '`main` consists of just getting a random generator from the system and calling
    `askForNumber` with it to get the initial action.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 只是从系统中获取一个随机生成器，并用它调用 `askForNumber` 来获取初始操作。'
- en: 'Here’s our program in action:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的程序在运行中的样子：
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here’s another way to make this same program:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是制作相同程序的另一种方法：
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It’s very similar to the previous version, but instead of making a function
    that takes a generator and then calls itself recursively with the new updated
    generator, we do all the work in `main`. After telling the user whether he was
    correct in his guess, we update the global generator and then call `main` again.
    Both approaches are valid, but I like the first one more since it does less stuff
    in `main` and also provides a function I can reuse easily.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上一个版本非常相似，但我们不是创建一个接受生成器并递归调用自身的新更新生成器的函数，而是在 `main` 中完成所有工作。在告诉用户他的猜测是否正确后，我们更新全局生成器，然后再次调用
    `main`。两种方法都是有效的，但我更喜欢第一种，因为它在 `main` 中做的工作更少，并且提供了一个我可以轻松重用的函数。
- en: Bytestrings
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节字符串
- en: Lists are certainly useful. So far, we’ve used them pretty much everywhere.
    There are a multitude of functions that operate on them, and Haskell’s laziness
    allows us to exchange the `for` and `while` loops of other languages for filtering
    and mapping over lists. Since evaluation will happen only when it really needs
    to, things like infinite lists (and even infinite lists of infinite lists!) are
    no problem for us. That’s why lists can also be used to represent streams, either
    when reading from the standard input or when reading from files. We can just open
    a file and read it as a string, even though it will be accessed only when the
    need arises.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表当然很有用。到目前为止，我们几乎在所有地方都使用了它们。有许多函数可以操作它们，而 Haskell 的惰性允许我们用过滤和映射列表来替换其他语言的
    `for` 和 `while` 循环。由于评估只有在真正需要时才会发生，因此像无限列表（甚至无限列表的无限列表！）对我们来说都不是问题。这就是为什么列表也可以用来表示流，无论是从标准输入读取还是从文件读取。我们只需打开一个文件，就可以将其作为字符串读取，即使它只有在需要时才会被访问。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802632.png.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802632.png.jpg)'
- en: 'However, processing files as strings has one drawback: It tends to be slow.
    Lists are really lazy. Remember that a list like `[1,2,3,4]` is syntactic sugar
    for `1:2:3:4:[]`. When the first element of the list is forcibly evaluated (say
    by printing it), the rest of the list `2:3:4:[]` is still just a promise of a
    list, and so on. We call that promise a *thunk*.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将文件作为字符串处理有一个缺点：它通常比较慢。列表真的很懒惰。记住，像`[1,2,3,4]`这样的列表是`1:2:3:4:[]`的语法糖。当列表的第一个元素被强制评估（比如打印它）时，列表的其余部分`2:3:4:[]`仍然只是一个列表的承诺，以此类推。我们称那个承诺为*thunk*。
- en: A thunk is basically a deferred computation. Haskell achieves its laziness by
    using thunks and computing them only when it must, instead of computing everything
    up front. So you can think of lists as promises that the next element will be
    delivered once it really has to be, and along with it, the promise of the element
    after it. It doesn’t take a big mental leap to conclude that processing a simple
    list of numbers as a series of thunks might not be the most efficient technique
    in the world.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Thunk基本上是一个延迟计算。Haskell通过使用thunks并在需要时才计算它们来实现懒惰性，而不是预先计算一切。所以你可以把列表看作是承诺，一旦真正需要，下一个元素就会被交付，以及它后面的元素的承诺。不需要太大的思维跳跃就可以得出结论，将简单的数字列表作为一系列thunks处理可能不是世界上最高效的技术。
- en: That overhead doesn’t bother us most of the time, but it turns out to be a liability
    when reading big files and manipulating them. That’s why Haskell has *bytestrings*.
    Bytestrings are sort of like lists, only each element is one byte (or 8 bits)
    in size. The way they handle laziness is also different.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开销在大多数时候不会困扰我们，但当我们读取大文件并操作它们时，它就变成了一个缺点。这就是为什么Haskell有*字节串*。字节串有点像列表，只是每个元素的大小为1字节（或8位）。它们处理懒惰性的方式也不同。
- en: Strict and Lazy Bytestrings
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格和懒惰字节串
- en: 'Bytestrings come in two flavors: strict and lazy. Strict bytestrings reside
    in `Data.ByteString`, and they do away with the laziness completely. There are
    no thunks involved. A strict bytestring represents a series of bytes in an array.
    You can’t have things like infinite strict bytestrings. If you evaluate the first
    byte of a strict bytestring, you must evaluate the whole thing.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 字节串有两种类型：严格和懒惰。严格字节串位于`Data.ByteString`中，并且完全去除了懒惰性。没有涉及thunks。一个严格字节串代表一个数组中的字节序列。你不能有无限严格的字节串。如果你评估一个严格字节串的第一个字节，你必须评估整个序列。
- en: The other variety of bytestrings resides in `Data.ByteString.Lazy`. They’re
    lazy, but not quite as lazy as lists. Since there are as many thunks in a list
    as there are elements, they are kind of slow for some purposes. Lazy bytestrings
    take a different approach. They are stored in chunks (not to be confused with
    thunks!), and each chunk has a size of 64KB. So if you evaluate a byte in a lazy
    bytestring (by printing it, for example), the first 64KB will be evaluated. After
    that, it’s just a promise for the rest of the chunks. Lazy bytestrings are kind
    of like lists of strict bytestrings, with a size of 64KB. When you process a file
    with lazy bytestrings, it will be read chunk by chunk. This is cool because it
    won’t cause the memory usage to skyrocket, and the 64KB probably fits neatly into
    your CPU’s L2 cache.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的字节串位于`Data.ByteString.Lazy`中。它们是懒惰的，但并不像列表那样懒惰。由于列表中的thunks数量与元素数量相同，因此对于某些目的来说，它们有点慢。懒惰字节串采用不同的方法。它们存储在块中（不要与thunks混淆！），每个块的大小为64KB。所以如果你评估一个懒惰字节串中的字节（例如通过打印它），前64KB将被评估。之后，它只是对剩余块的一个承诺。懒惰字节串有点像大小为64KB的严格字节串列表。当你用懒惰字节串处理文件时，它将逐块读取。这很酷，因为它不会导致内存使用量激增，而且64KB很可能整齐地适合你的CPU的L2缓存。
- en: 'If you look through the documentation for `Data.ByteString.Lazy`, you will
    see that it has a lot of functions with the same names as the ones from `Data.List`,
    but the type signatures have `ByteString` instead of `[a]` and `Word8` instead
    of `a`. These functions are similar to the ones that work on lists. Because the
    names are the same, we’re going to do a qualified import in a script and then
    load that script into GHCi to play with bytestrings:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`Data.ByteString.Lazy`的文档，你会看到它有很多与`Data.List`中相同名称的函数，但类型签名中用`ByteString`代替了`[a]`，用`Word8`代替了`a`。这些函数与在列表上工作的函数类似。因为名称相同，我们将在脚本中进行限定导入，然后将该脚本加载到GHCi中，通过字节串进行实验：
- en: '[PRE80]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`B` has lazy bytestring types and functions, whereas `S` has strict ones. We’ll
    mostly be using the lazy versions.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`B`有懒惰的字节串类型和函数，而`S`有严格的。我们将主要使用懒惰版本。'
- en: 'The `pack` function has the type signature `pack :: [Word8] -> ByteString`.
    This means that it takes a list of bytes of type `Word8` and returns a `ByteString`.
    You can think of it as taking a list, which is lazy, and making it less lazy,
    so that it’s lazy only at 64KB intervals.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack`函数的类型签名是`pack :: [Word8] -> ByteString`。这意味着它接受一个类型为`Word8`的字节数组并返回一个`ByteString`。您可以将其视为接受一个懒列表，并将其转换为不那么懒的列表，这样它只在64KB间隔处是懒的。'
- en: The `Word8` type is like `Int`, but it represents an unsigned 8-bit number.
    This means that it has a much smaller range of only 0 to 255\. And just like `Int`,
    it’s in the `Num` type class. For instance, we know that the value `5` is polymorphic
    in that it can act like any numeric type, including `Word8`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Word8`类型类似于`Int`，但它表示一个无符号8位数字。这意味着它具有更小的范围，仅为0到255。而且就像`Int`一样，它属于`Num`类型类。例如，我们知道值`5`是多态的，它可以像任何数值类型一样行动，包括`Word8`。'
- en: 'Here’s how we pack lists of numbers into bytestrings:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将数字列表打包到字节字符串中的方法：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We packed only a handful of values into a bytestring, so they fit inside one
    chunk. `Empty` is like `[]` for lists—they both represent an empty sequence.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将少量值打包到字节字符串中，因此它们适合在一个块中。`Empty`类似于列表中的`[]`——它们都表示一个空序列。
- en: As you can see, you don’t need to specify that your numbers are of type `Word8`,
    because the type system can make numbers choose that type. If you try to use a
    big number like `336` as a `Word8`, it will just wrap around to `80`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您不需要指定您的数字类型为`Word8`，因为类型系统可以使数字选择该类型。如果您尝试使用像`336`这样的大数字作为`Word8`，它将简单地回绕到`80`。
- en: When we need to examine a bytestring byte by byte, we need to unpack it. The
    `unpack` function is the inverse of `pack`. It takes a bytestring and turns it
    into a list of bytes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要逐字节检查字节字符串时，我们需要将其解包。`unpack`函数是`pack`的逆函数。它接受一个字节字符串并将其转换为字节数组。
- en: 'Here’s an example:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can also go back and forth between strict and lazy bytestrings. The `toChunks`
    function takes a lazy bytestring and converts it to a list of strict ones. The
    `fromChunks` function takes a list of strict bytestrings and converts it to a
    lazy bytestring:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在严格和懒字节字符串之间来回转换。`toChunks`函数接受一个懒字节字符串并将其转换为一系列严格的字节字符串。`fromChunks`函数接受一系列严格的字节字符串并将其转换为懒字节字符串：
- en: '[PRE83]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This is good if you have a lot of small strict bytestrings and you want to process
    them efficiently without joining them into one big strict bytestring in memory
    first.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有很多小的严格字节字符串并且想要高效地处理它们，而不需要在内存中将它们合并成一个大的严格字节字符串，这是一个好方法。
- en: The bytestring version of `:` is called `cons`. It takes a byte and a bytestring
    and puts the byte at the beginning.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串版本的`:`称为`cons`。它接受一个字节和一个字节字符串，并将字节放在开头。
- en: '[PRE84]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The bytestring modules have a load of functions that are analogous to those
    in `Data.List`, including, but not limited to, `head`, `tail`, `init`, `null`,
    `length`, `map`, `reverse`, `foldl`, `foldr`, `concat`, `takeWhile`, `filter`,
    and so on. For a complete listing of bytestring functions, check out the documentation
    for the bytestring package at [http://hackage.haskell.org/package/bytestring/](http://hackage.haskell.org/package/bytestring/).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串模块包含许多与`Data.List`中函数类似的功能，包括但不限于`head`、`tail`、`init`、`null`、`length`、`map`、`reverse`、`foldl`、`foldr`、`concat`、`takeWhile`、`filter`等。有关字节字符串函数的完整列表，请查看字节字符串包的文档，链接为[http://hackage.haskell.org/package/bytestring/](http://hackage.haskell.org/package/bytestring/)。
- en: 'The bytestring modules also have functions that have the same name and behave
    the same as some functions found in `System.IO`, but `Strings` are replaced with
    `ByteStrings`. For instance, the `readFile` function in `System.IO` has this type:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串模块也包含一些与`System.IO`中某些函数同名且行为相同的函数，但将`Strings`替换为`ByteStrings`。例如，`System.IO`中的`readFile`函数具有以下类型：
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `readFile` function from the bytestring modules has the following type:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串模块中的`readFile`函数具有以下类型：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using strict bytestrings and you attempt to read a file, all of that
    file will be read into memory at once! With lazy bytestrings, the file will be
    read in neat chunks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用严格的字节字符串并且尝试读取文件，整个文件将一次性被读入内存！使用懒字节字符串，文件将分块读取。
- en: Copying Files with Bytestrings
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用字节字符串复制文件
- en: 'Let’s make a program that takes two filenames as command-line arguments and
    copies the first file into the second file. Note that `System.Directory` already
    has a function called `copyFile`, but we’re going to implement our own file-copying
    function and program anyway. Here’s the code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，它接受两个文件名作为命令行参数并将第一个文件复制到第二个文件。请注意，`System.Directory`已经有一个名为`copyFile`的函数，但无论如何，我们都要实现自己的文件复制函数和程序。以下是代码：
- en: '[PRE87]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To begin, in `main`, we just get the command-line arguments and call our `copy`
    function, which is where the magic happens. One way to do this would be to just
    read from one file and write to another. But if something goes wrong (such as
    we don’t have enough disk space to copy the file), we’ll be left with a messed-up
    file. So we’ll write to a temporary file first. Then if something goes wrong,
    we can just delete that file.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`main`函数中，我们只获取命令行参数并调用我们的`copy`函数，那里发生了魔法。一种做法是直接从一个文件读取并写入到另一个文件。但如果出了问题（比如我们没有足够的磁盘空间来复制文件），我们就会得到一个混乱的文件。所以我们会先写入到一个临时文件。然后如果出了问题，我们就可以简单地删除那个文件。
- en: First, we use `B.readFile` to read the contents of our source file. Then we
    use `bracketOnError` to set up our error handling. We acquire the resource with
    `openTempFile "." "temp"`, which yields a tuple that consists of a temporary filename
    and a handle. Next, we say what we want to happen if an error occurs. If something
    goes wrong, we close the handle and remove the temporary file. Finally, we do
    the copying itself. We use `B.hPutStr` to write the contents to our temporary
    file. We close the temporary file and rename it to what we want it to be in the
    end.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`B.readFile`读取源文件的正文。然后我们使用`bracketOnError`来设置错误处理。我们使用`openTempFile
    "." "temp"`获取资源，它返回一个包含临时文件名和处理器的元组。接下来，我们说明如果发生错误会发生什么。如果出了问题，我们关闭处理器并删除临时文件。最后，我们进行复制。我们使用`B.hPutStr`将内容写入临时文件。我们关闭临时文件并将其重命名为我们想要的最终名称。
- en: Notice that we just used `B.readFile` and `B.hPutStr` instead of their regular
    variants. We didn’t need to use special bytestring functions for opening, closing,
    and renaming files. We just need to use the bytestring functions when reading
    and writing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是使用了`B.readFile`和`B.hPutStr`而不是它们的常规变体。我们不需要使用特殊的bytestring函数来打开、关闭和重命名文件。我们只需要在读取和写入时使用bytestring函数。
- en: 'Let’s test it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE88]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: A program that doesn’t use bytestrings could look just like this. The only difference
    is that we used `B.readFile` and `B.writeFile` instead of `readFile` and `writeFile`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不使用bytestrings的程序可能看起来就像这样。唯一的区别是我们使用了`B.readFile`和`B.writeFile`而不是`readFile`和`writeFile`。
- en: Many times, you can convert a program that uses normal strings to a program
    that uses bytestrings just by doing the necessary imports and then putting the
    qualified module names in front of some functions. Sometimes, you need to convert
    functions that you wrote to work on strings so that they work on bytestrings,
    but that’s not hard.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，你只需进行必要的导入，然后在一些函数前加上有资格的模块名称，就可以将使用普通字符串的程序转换为使用bytestrings的程序。有时，你需要转换你编写的用于处理字符串的函数，以便它们可以处理bytestrings，但这并不难。
- en: Whenever you need better performance in a program that reads a lot of data into
    strings, give bytestrings a try. Chances are you’ll get some good performance
    boosts with very little effort on your part. I usually write programs using normal
    strings and then convert them to use bytestrings if the performance is not satisfactory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要在一个大量读取数据到字符串的程序中提高性能，都尝试使用bytestrings。很可能你只需付出很少的努力就能获得一些性能提升。我通常使用普通字符串编写程序，如果性能不令人满意，我会将它们转换为使用bytestrings。
