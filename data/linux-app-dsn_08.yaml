- en: '![](../images/129-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/129-1.jpg)'
- en: '[**DESIGNING A WEB INTERFACE**](toc.html#chapter8)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设计网页界面**](toc.html#chapter8)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: The web browser has become the user interface of choice for configuring networked
    appliances, particularly home-based routers from companies like Linksys and Netgear.
    The driving force behind the popularity of web interfaces is that they are easy
    to use and don’t require specialized client software. Customers now expect to
    be able to access web interfaces for their devices, and so it is no surprise that
    leading manufacturers of home-based networked appliances provide them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器已成为配置网络设备的首选用户界面，尤其是来自Linksys和Netgear等公司的家庭路由器。推动网络界面普及的动力在于它们易于使用且不需要专门的客户端软件。客户现在期望能够访问其设备的网络界面，因此，领先的家用网络设备制造商提供这些界面并不令人惊讶。
- en: 'This is the first of several chapters devoted to user interface (UI) design.
    This chapter covers web UIs in general, and the development of Laddie’s web UI
    in particular. In the chapters that follow, we’ll look at Laddie’s other UIs:
    the CLI interface in Chapter 9, the front panel LCD interface in Chapter 10, the
    framebuffer interface in Chapter 11, and the infrared remote control interface
    in Chapter 12\. All of these UIs communicate with the back-end daemons via the
    PostgreSQL protocol.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于用户界面（UI）设计的几章中的第一章。本章涵盖一般性的网络UI，特别是Laddie网络UI的开发。在随后的章节中，我们将探讨Laddie的其他UI：第9章的CLI界面，第10章的前面板LCD界面，第11章的framebuffer界面，以及第12章的红外遥控器界面。所有这些UI都通过PostgreSQL协议与后端守护进程进行通信。
- en: 'This chapter covers the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: An overview of web technology
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络技术概述
- en: Establishing requirements for your appliance’s web interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的设备网页界面建立需求
- en: Choosing a webserver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择web服务器
- en: Designing the look and feel of the web interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计网页界面的外观和感觉
- en: Highlights of our implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现的重点
- en: Lessons learned and future improvements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经验总结和未来改进
- en: '[**Web Basics**](toc.html#chapter8.1)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[**网络基础**](toc.html#chapter8.1)'
- en: Web browsers communicate with webservers using the *HyperText Transfer Protocol
    (HTTP),* a client-server protocol. The communication is initiated from the web
    browser (the client) when it requests a web page via a particular Uniform Resource
    Locator (URL), for example, [http://www.google.com](http://www.google.com/). When
    the webserver receives this request, it checks that the requested page is available,
    and if it is, it sends the page to the web browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器使用*超文本传输协议（HTTP）*与web服务器通信，这是一个客户端-服务器协议。当网络浏览器（客户端）通过特定的统一资源定位符（URL）请求网页时，例如[http://www.google.com](http://www.google.com/)，通信便从浏览器（客户端）发起。当web服务器接收到这个请求后，它会检查请求的页面是否可用，如果可用，它就会将页面发送到浏览器。
- en: 'Because the HTTP protocol is text based, you can use telnet to imitate the
    browser request as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTTP协议是基于文本的，你可以使用telnet来模拟浏览器请求，如下所示：
- en: telnet [www.google.com](http://www.google.com/) 80
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: telnet [www.google.com](http://www.google.com/) 80
- en: 'Once the telnet session has connected, enter the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦telnet会话连接成功，输入以下内容：
- en: GET / HTTP/1.0
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GET / HTTP/1.0
- en: Then press enter twice (the empty line created by the second enter causes the
    webserver to respond to the GET request). The page returned is formatted using
    HTML; an example page appears below. (Obviously, this page would look different
    if you opened it in a browser, because the browser would interpret the HTML markup
    and present it in a human-readable way.) Note that the middle portion of the page
    has been replaced by ellipses (. . .) to reduce its size.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按两次回车（第二次回车产生的空行会导致web服务器响应GET请求）。返回的页面使用HTML格式化；下面是一个示例页面。（显然，如果你在浏览器中打开它，页面看起来会不同，因为浏览器会解释HTML标记并以人类可读的方式呈现。）请注意，页面的中间部分已被省略号（...）替换，以减小其大小。
- en: '![](../images/130-1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/130-1.jpg)'
- en: '[***DNS and TCP***](toc.html#chapter8.2)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[***DNS和TCP***](toc.html#chapter8.2)'
- en: The network protocols DNS (Domain Name System) and TCP (Transmission Control
    Protocol) make this client-server exchange possible. Given the URL (e.g., [http://www.google.com](http://www.google.com/)),
    the client uses DNS to determine the IP address of the server. HTTP uses TCP for
    error-free data transmission between client and server.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络协议DNS（域名系统）和TCP（传输控制协议）使得这种客户端-服务器交换成为可能。给定URL（例如，[http://www.google.com](http://www.google.com/)），客户端使用DNS来确定服务器的IP地址。HTTP使用TCP在客户端和服务器之间进行无错误的数据传输。
- en: These protocols are defined by the Internet Engineering Task Force (IETF), the
    authoritative Internet standards body. (For more information on IETF standards,
    see [http://www.ietf.org](http://www.ietf.org/); for more information on TCP/IP,
    see *The TCP/IP Guide* by Charles M. Kozierok, No Starch Press, 2005.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议由互联网工程任务组（IETF）定义，它是权威的互联网标准机构。（有关IETF标准的更多信息，请参阅[http://www.ietf.org](http://www.ietf.org/);
    有关TCP/IP的更多信息，请参阅查尔斯·M·科齐罗克的《TCP/IP指南》，No Starch Press，2005年。）
- en: '[***The Webserver***](toc.html#chapter8.3)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Web服务器***](toc.html#chapter8.3)'
- en: The webserver finds and returns the web page for the given URL. This page may
    reside in the server’s filesystem or in memory, or it may be generated dynamically
    at the time of the request.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器查找并返回给定URL的网页。这个页面可能位于服务器的文件系统中，或在内存中，或者它可能在请求时动态生成。
- en: '[***CGI***](toc.html#chapter8.4)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[***CGI***](toc.html#chapter8.4)'
- en: The *Common Gateway Interface (CGI)* emerged as a way for a webserver to communicate
    with a purpose-built program, which would in turn generate the web page on behalf
    of the webserver. In the Unix world, the early CGI programs were written in languages
    like bash, Perl, and C. Today, web-specific scripting languages like PHP are more
    common. Furthermore, modern webservers like Apache can be configured to run PHP
    scripts within the same process as the Apache webserver, thereby avoiding the
    CGI communication mechanism.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用网关接口（CGI）*作为一种方式出现，允许Web服务器与专门设计的程序通信，该程序随后代表Web服务器生成网页。在Unix世界中，早期的CGI程序是用bash、Perl和C等语言编写的。今天，更常见的Web特定脚本语言如PHP。此外，现代Web服务器如Apache可以配置为在Apache
    Web服务器相同的进程中运行PHP脚本，从而避免CGI通信机制。'
- en: '[***JavaScript***](toc.html#chapter8.5)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[***JavaScript***](toc.html#chapter8.5)'
- en: JavaScript has become accepted as the client-side programming language for web
    pages. JavaScript code is embedded in the HTML page, and tags in the web page
    tell the web browser when to execute the JavaScript functions. One of JavaScript’s
    main advantages is that it provides a more responsive user experience. One of
    JavaScript’s main disadvantages is that not all browsers support it, and those
    that do don’t necessarily support it in a standard way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已成为网页客户端编程语言的公认标准。JavaScript代码嵌入在HTML页面中，网页中的标签告诉网页浏览器何时执行JavaScript函数。JavaScript的主要优点之一是它提供了更响应的用户体验。JavaScript的主要缺点之一是并非所有浏览器都支持它，而且那些支持它的也不一定按照标准方式支持。
- en: '[***Evolving Technologies***](toc.html#chapter8.6)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[***技术演变***](toc.html#chapter8.6)'
- en: Coupled with developments on the client side and server side, the HTML protocol
    has undergone many revisions and has expanded to include XHTML, CSS, XSL, and
    XPath.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端和服务器端的发展相结合，HTML协议已经经历了许多修订，并扩展到包括XHTML、CSS、XSL和XPath。
- en: The bottom line is that web technology is still evolving. This evolution introduces
    challenges for developers striving for interoperability and longevity for their
    web pages. Therefore, as a web developer, it is prudent to plan ahead for changes
    in web technology.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，网络技术仍在不断发展。这种发展给努力实现网页互操作性和持久性的开发者带来了挑战。因此，作为一名网络开发者，提前规划网络技术的变化是明智的。
- en: '[**Establishing Requirements**](toc.html#chapter8.7)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[**建立需求**](toc.html#chapter8.7)'
- en: 'Before developing a web UI for the Laddie alarm appliance, we established the
    following requirements to guide us with its design:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Laddie警报设备开发Web用户界面之前，我们确立了以下要求来指导其设计：
- en: The web interface should be easy to use.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web界面应易于使用。
- en: The web interface should support a wide variety of browsers, including text-based
    ones.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web界面应支持广泛的浏览器，包括基于文本的浏览器。
- en: The web pages should update automatically as the state on the appliance changes.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页应随着设备状态的改变自动更新。
- en: The web pages should adhere to Internet standards, avoiding proprietary features.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页应遵守互联网标准，避免使用专有功能。
- en: The implementation should work with various webservers so that the appliance
    webserver can be replaced should a better one become available.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应与各种Web服务器兼容，以便在更好的Web服务器可用时可以替换设备Web服务器。
- en: The implementation should be simple so that it can be easily maintained.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应该是简单的，以便可以轻松维护。
- en: '[**Choosing a Webserver**](toc.html#chapter8.8)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[**选择Web服务器**](toc.html#chapter8.8)'
- en: Which webserver should you use when building your appliance? In this section
    we’ll review several webservers suitable for Linux appliances.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建您的设备时，您应该使用哪个Web服务器？在本节中，我们将回顾几个适合Linux设备的Web服务器。
- en: '[***Choices***](toc.html#chapter8.9)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[***选择***](toc.html#chapter8.9)'
- en: Webservers come in several different flavors. Many support the CGI interface,
    which allows the webserver to spawn an arbitrary process to generate the web page
    content on behalf of the webserver.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器有多种不同的类型。许多支持 CGI 接口，这使得网络服务器能够启动一个任意进程来代表网络服务器生成网页内容。
- en: The Apache webserver can be compiled with a PHP interpreter so that PHP scripts
    are interpreted within the Apache process. This approach reduces inter-process
    communication and improves response time.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache 网络服务器可以与 PHP 解释器一起编译，这样 PHP 脚本就可以在 Apache 进程中解释。这种方法减少了进程间通信，并提高了响应时间。
- en: The lighttpd webserver supports the FastCGI interface. The FastCGI mechanism
    spawns multiple PHP interpreters and load balances requests for PHP web pages
    between them. For more information, see [http://www.fastcgi.com](http://www.fastcgi.com/).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lighttpd 网络服务器支持 FastCGI 接口。FastCGI 机制会启动多个 PHP 解释器，并在它们之间负载均衡 PHP 网页的请求。更多信息，请参阅
    [http://www.fastcgi.com](http://www.fastcgi.com/).
- en: The GoAhead webserver allows the webserver and all web pages to be packaged
    into a single executable, which allows the webserver to run without a filesystem.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoAhead 网络服务器允许将网络服务器和所有网页打包成一个单一的可执行文件，这使得网络服务器可以在没有文件系统的情况下运行。
- en: The webserver in the Linksys WRT54G wireless router is written entirely in C
    and includes handcrafted functions for each web page.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linksys WRT54G 无线路由器中的网络服务器完全用 C 语言编写，并为每个网页包含手工编写的函数。
- en: The TUX webserver runs in the Linux kernel.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TUX 网络服务器在 Linux 内核中运行。
- en: Perhaps the first thing to consider when choosing a webserver is the license.
    If you don’t want to release your source code modifications, then you should avoid
    webservers with GPL and Apache licenses. On the other hand, if you do select a
    mature webserver like Apache, it is unlikely that you will have to modify it,
    and consequently, you won’t have to worry about having to release source code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择网络服务器时首先要考虑的可能就是许可证。如果你不想发布你的源代码修改，那么你应该避免使用带有 GPL 和 Apache 许可证的网络服务器。另一方面，如果你选择了一个成熟的网络服务器，如
    Apache，那么你很可能不需要对其进行修改，因此你也不必担心需要发布源代码。
- en: We suggest that you resist developing your own webserver. It is cheaper to select
    an existing one and to develop the web pages in a server-agnostic way. The advantage
    to this approach is that you don’t have to spend your development resources maintaining
    a webserver, and you can replace the webserver should a better one become available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你抵制开发自己的网络服务器。选择现有的网络服务器并以服务器无关的方式开发网页更经济。这种方法的优点是，你不必花费开发资源来维护网络服务器，并且如果出现更好的网络服务器，你可以替换它。
- en: '[***Use PHP***](toc.html#chapter8.10)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用 PHP***](toc.html#chapter8.10)'
- en: We suggest using PHP as the language to generate dynamic web pages. Though you
    can write smaller CGI programs in C, if you use a compiled language and need to
    modify a web page once the appliance has been deployed, you will need a compile
    environment, which would typically not be available on the deployed appliance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用 PHP 作为生成动态网页的语言。虽然你可以用 C 语言编写较小的 CGI 程序，但如果使用编译型语言并且需要在设备部署后修改网页，你需要一个编译环境，这通常在部署的设备上不可用。
- en: When you use an interpreted language like PHP, you can easily modify and test
    the web pages on the deployed appliance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用像PHP这样的解释型语言时，你可以轻松地修改和测试部署在设备上的网页。
- en: PHP is a good language for generating web content because it is popular, mature,
    has an active developer community, and is well integrated into open source webservers
    such as Apache, thttpd, and lighttpd. Even for webservers that don’t support PHP,
    you can still write CGI programs *using PHP.* Thus, you can use PHP with just
    about any webserver. It is for these reasons that we selected PHP to develop the
    Laddie web UI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 是生成网页内容的良好语言，因为它受欢迎、成熟、拥有活跃的开发者社区，并且与 Apache、thttpd 和 lighttpd 等开源网络服务器很好地集成。即使对于不支持
    PHP 的网络服务器，你仍然可以编写使用 PHP 的 CGI 程序。因此，你可以使用 PHP 与几乎任何网络服务器一起使用。正是出于这些原因，我们选择了 PHP
    来开发 Laddie 网络用户界面。
- en: '[***Case Study: Linksys WRT54G Wireless Router***](toc.html#chapter8.11)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[***案例研究：Linksys WRT54G 无线路由器***](toc.html#chapter8.11)'
- en: Let’s examine the approach taken by the Linksys WRT54G wireless router. The
    webserver in this router is a handcrafted combination of both the micro_httpd
    and mini_httpd webservers, enhanced with specialized C functions that generate
    the dynamic content of the web pages. The code is GPL licensed and is available
    from [http://www.linksys.com](http://www.linksys.com/) under the GPL Code Center.
    (Both micro_httpd and mini_httpd were written by Jef Poskanzer and are available
    at [http://www.acme.com](http://www.acme.com/).)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察Linksys WRT54G无线路由器所采用的方法。这个路由器中的web服务器是micro_httpd和mini_httpd web服务器的手工组合，并增强了生成网页动态内容的专用C函数。代码是GPL许可的，可以在GPL代码中心[http://www.linksys.com](http://www.linksys.com/)下获取。（micro_httpd和mini_httpd都是由Jef
    Poskanzer编写的，可在[http://www.acme.com](http://www.acme.com/)获取。）
- en: The specialized C functions are responsible for generating dynamic content for
    the web pages. Because these functions are compiled into the webserver, there
    is no need for a script interpreter like PHP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 专用C函数负责生成网页的动态内容。因为这些函数被编译到web服务器中，所以不需要像PHP这样的脚本解释器。
- en: 'For example, the C function dump_route_table() is invoked from a web page by
    placing the function name between a matching pair of tags, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C函数dump_route_table()通过在匹配的标签对之间放置函数名，从网页中调用，如下所示：
- en: <% dump_route_table(""); %>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <% dump_route_table(""); %>
- en: This tag mechanism is similar to the approach taken by PHP, except that here,
    the function is implemented in C and compiled into the webserver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种标签机制类似于PHP所采用的方法，但在这里，该功能是用C语言实现的，并编译到web服务器中。
- en: The advantage of this approach is that it has smaller memory requirements. However,
    as mentioned earlier, the problem with this approach is that the development cycle
    is extended because any change to a specialized C function requires a recompile.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是内存需求较小。然而，如前所述，这种方法的问题在于开发周期被延长，因为对专用C函数的任何更改都需要重新编译。
- en: '[***Case Study: The TUX Webserver***](toc.html#chapter8.12)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[***案例研究：TUX Web服务器***](toc.html#chapter8.12)'
- en: Unlike most other webservers, which run in user space, the TUX webserver runs
    in the Linux kernel. Running in kernel space allows TUX to avoid communication
    between kernel space and user space; therefore, TUX offers better server response
    time than other webservers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他在用户空间运行的web服务器不同，TUX web服务器在Linux内核中运行。在内核空间运行允许TUX避免内核空间与用户空间之间的通信；因此，TUX提供的服务器响应时间比其他web服务器更好。
- en: TUX supports both static and dynamic web page content, but for it to support
    dynamic content, another webserver must be running in user space. TUX operates
    by responding to requests for static web pages itself and forwarding requests
    for dynamic content to a user space webserver like Apache. As you might imagine,
    TUX doesn’t offer speed advantages when it comes to support for dynamic web pages.
    Thus, for websites that have mostly dynamically generated content, the extra TUX
    configuration might not be worth the trouble.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TUX支持静态和动态网页内容，但要支持动态内容，必须在用户空间运行另一个web服务器。TUX通过自己响应静态网页请求并转发动态内容请求到Apache等用户空间web服务器来操作。正如你可能想象的那样，TUX在支持动态网页方面并不提供速度优势。因此，对于主要动态生成内容的网站，额外的TUX配置可能不值得麻烦。
- en: '[***Comparison of Webservers***](toc.html#chapter8.13)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Web服务器的比较***](toc.html#chapter8.13)'
- en: In the previous section, we listed a range of webservers from Apache to TUX.
    In this section, we’ll narrow our focus to comparing only webservers that support
    PHP as the scripting language. For space reasons, we’ve limited the set of webservers
    to Apache, Boa, BusyBox’s httpd, Cherokee, GoAhead, lighttpd, and thttpd. These
    webservers have been selected because they are either used in commercial products
    or they are tailored for embedded applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们列出了从Apache到TUX的一系列web服务器。在本节中，我们将我们的重点缩小到仅比较支持PHP作为脚本语言的web服务器。由于空间原因，我们将web服务器集合限制为Apache、Boa、BusyBox的httpd、Cherokee、GoAhead、lighttpd和thttpd。这些web服务器被选中是因为它们要么用于商业产品，要么是为嵌入式应用量身定制的。
- en: 'Possible criteria for comparing webservers include:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 比较web服务器的可能标准包括：
- en: Memory footprint
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存占用
- en: Size of executable file
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件大小
- en: Performance
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Security support
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全支持
- en: Ongoing maintenance and development
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续维护和开发
- en: Debugging support
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试支持
- en: Documentation
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Cost
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本
- en: Regardless of how you weigh the different criteria, choosing a webserver will
    require a compromise. For example, the memory footprint may be critical for some
    appliances, but not for others.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您如何权衡不同的标准，选择网络服务器都将需要妥协。例如，对于某些设备，内存占用量可能是关键的，但对于其他设备则不然。
- en: Rather than advocating one webserver for your appliance, we’ve compiled Table
    8-1, which shows how the various webservers in our limited set compare in each
    area. You can use this table as a starting point when selecting a webserver.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为您的设备推荐一个特定的网络服务器，我们已经编制了表8-1，该表显示了在我们有限的集合中，各种网络服务器在每个领域的比较情况。在选择网络服务器时，您可以将此表作为起点。
- en: You can use different webservers for different stages of development. For example,
    you could use one webserver that has good debugging support in the development
    phase, and then switch to another one with a small memory footprint during testing
    and deployment. If you choose to use different webservers, plan ahead to ensure
    that you use features supported by all of them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用不同的网络服务器来处理开发的各个阶段。例如，您可以在开发阶段使用一个具有良好调试支持的网络服务器，然后在测试和部署期间切换到具有较小内存占用量的另一个网络服务器。如果您选择使用不同的网络服务器，请提前规划以确保您使用的是所有网络服务器都支持的功能。
- en: '**Table 8-1:** Comparison of Various Webservers'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**表8-1：各种网络服务器的比较**'
- en: '![](../images/135-1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/135-1.jpg)'
- en: '**About the Tabular Data**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于表格数据**'
- en: Let’s look at Table 8-1 in more detail.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看表8-1。
- en: '**Version tested** This is the software version of the webserver that we tested.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试版本** 这是测试的网络服务器的软件版本。'
- en: '**Virtual memory** This is the virtual memory (in kilobytes) that the running
    webserver consumed. The virtual memory was measured using the Unix top command,
    which displays virtual memory under the SIZE column. For webservers that spawn
    multiple processes, we recorded the maximum value. In each case, the virtual memory
    was recorded during the performance test. (See *Response time* on the next page.)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟内存** 这是运行中的网络服务器消耗的虚拟内存（以千字节为单位）。虚拟内存是通过Unix top命令测量的，该命令在SIZE列下显示虚拟内存。对于产生多个进程的网络服务器，我们记录了最大值。在每个案例中，虚拟内存都是在性能测试期间记录的。（参见下一页上的“响应时间”。）'
- en: '**Executable size** This is the size (in kilobytes) of the executable file
    after compiling it with mostly default options and then manually stripping it
    with the strip command. This metric is not as good of an indication of required
    memory as virtual memory is because libraries are sometimes linked dynamically
    and sometimes linked statically.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**可执行文件大小** 这是在使用大多数默认选项编译后，通过strip命令手动剥离的可执行文件的大小（以千字节为单位）。由于库有时是动态链接的，有时是静态链接的，因此这个指标并不像虚拟内存那样能很好地指示所需的内存量。'
- en: When programs are linked dynamically, much of the code can be in dynamically
    linked libraries. When you view the size of the executable, the code in these
    libraries will not be factored in. So the size of a dynamically linked executable
    is not a good indication of how much memory will be required when the executable
    is run (when all the libraries are linked-in at load-time). Typically, what’s
    important is how much memory a program requires to run, because memory is the
    precious resource.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序是动态链接时，大部分代码可以在动态链接库中。当您查看可执行文件大小时，这些库中的代码将不会被考虑在内。因此，动态链接的可执行文件大小并不能很好地表明在可执行文件运行时（当所有库在加载时链接）所需的内存量。通常，重要的是程序运行所需的内存量，因为内存是宝贵的资源。
- en: '**Response time** This is the average response time (in milliseconds) to access
    Laddie’s status.php page, as recorded by the httperf utility (available at [http://www.hpl.hp.com/research/linux/httperf](http://www.hpl.hp.com/research/linux/httperf)).
    The motivation for this performance test is to measure how quickly the webserver
    responds to requests for the status web page. The following steps were taken for
    each webserver:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应时间** 这是指通过httperf工具（可在[http://www.hpl.hp.com/research/linux/httperf](http://www.hpl.hp.com/research/linux/httperf)获取）记录的访问Laddie的status.php页面的平均响应时间（以毫秒为单位）。进行此性能测试的动机是测量网络服务器对状态网页请求的响应速度。对于每个网络服务器，采取了以下步骤：'
- en: a. The webserver’s software was compiled with default options, except for those
    options necessary to make it work correctly. Detailed instructions on how each
    webserver was configured is available in /Code/src/web/INSTALL_WEB_SERVER.txt
    on this book’s companion CD. We used PHP version 5.0.3.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: a. 网络服务器的软件是使用默认选项编译的，除了那些使它正确工作的选项之外。关于每个网络服务器如何配置的详细说明，可在本书配套CD上的/Code/src/web/INSTALL_WEB_SERVER.txt中找到。我们使用了PHP版本5.0.3。
- en: b. The resulting webserver executable was stripped with the strip command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: b. 使用strip命令去除了生成的网络服务器可执行文件。
- en: c. The back-end Laddie process, ladd, was run.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: c. 运行了后端Laddie进程，ladd。
- en: 'd. The following command was used to measure the response time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以下命令被用来测量响应时间：
- en: httperf --hog --server 192.168.1.11 --uri=/cgi-bin/status.php --num-conn 200
    --rate 1
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: httperf --hog --server 192.168.1.11 --uri=/cgi-bin/status.php --num-conn 200
    --rate 1
- en: The resultant dynamically generated status.php page was 4546 bytes. The server
    we used for testing consisted of an Intel Celeron 2.4 GHz processor running Linux
    Red Hat 9 with otherwise idle processes. The client consisted of an AMD Duron
    1 GHz processor running Linux Red Hat 9\. The server and client had 10 MHz NICs
    with a Linksys switch/ router between them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的动态状态页status.php的大小为4546字节。我们用于测试的服务器由一个运行Linux Red Hat 9的2.4 GHz英特尔赛扬处理器组成，其他进程处于空闲状态。客户端由一个运行Linux
    Red Hat 9的1 GHz AMD Duron处理器组成。服务器和客户端之间有10 MHz的NIC，并通过Linksys交换机/路由器连接。
- en: '**Supports CGI** This denotes whether or not the webserver supports the Common
    Gateway Interface (CGI).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持CGI** 这表示网络服务器是否支持通用网关接口（CGI）。'
- en: '**Supports FastCGI** This denotes whether or not the webserver supports FastCGI,
    a performance enhancement to CGI. Documentation about FastCGI may be found at
    [http://www.fastcgi.com](http://www.fastcgi.com/).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持FastCGI** 这表示网络服务器是否支持FastCGI，这是CGI的性能增强。有关FastCGI的文档可以在[http://www.fastcgi.com](http://www.fastcgi.com/)找到。'
- en: '**Supports in-process scripting** This denotes whether the webserver supports
    a built-in PHP interpreter (or some other script interpreter). This functionality
    provides faster performance because it avoids interprocess-communication in the
    CGI interface.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持进程内脚本** 这表示网络服务器是否支持内置的PHP解释器（或某些其他脚本解释器）。这种功能提供了更快的性能，因为它避免了CGI接口中的进程间通信。'
- en: '**Server API used** This is the Server API interface used during the response
    time performance test. The Server API is the communication mechanism between the
    webserver and the scripts, for example, Apache, CGI, and FastCGI. As you can see
    from the table, some webservers support only one Server API, while others support
    more than one.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用的服务器API** 这是在响应时间性能测试期间使用的服务器API接口。服务器API是网络服务器和脚本之间的通信机制，例如Apache、CGI和FastCGI。从表中可以看出，一些网络服务器只支持一个服务器API，而其他网络服务器则支持多个。'
- en: '**Last release** This is the last time the software was released at the time
    of writing. This value is an indication of whether the software is actively maintained.
    In most cases, the version we tested was the last version released. However, there
    is one exception—the last version of thttpd released as of this writing was 2.25b,
    but we tested version 2.21b, because 2.21b was the last version that supported
    in-process scripting.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后发布版本** 这是在撰写本文时软件最后一次发布的日期。这个值是软件是否积极维护的一个指标。在大多数情况下，我们测试的版本是最后一个发布的版本。然而，有一个例外——截至本文撰写时，thttpd的最后一个版本是2.25b，但我们测试的是2.21b版本，因为2.21b是最后一个支持进程内脚本的版本。'
- en: '**Debugging** This denotes whether or not you can debug scripts with the webserver.
    In the case of Apache and PHP, there is a commercial development environment called
    Zend Studio that allows you to debug PHP scripts using Internet Explorer. Using
    Zend, you can step though PHP scripts one line at a time and view PHP variables.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 这表示是否可以使用网络服务器调试脚本。在Apache和PHP的情况下，有一个名为Zend Studio的商业开发环境，允许您使用Internet
    Explorer调试PHP脚本。使用Zend，您可以逐行执行PHP脚本并查看PHP变量。'
- en: '**Documentation** This is a rough measure of whether or not the documentation
    specifies clearly which features the webserver supports and whether it provides
    instructions on how to use each feature.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**文档** 这是对文档是否明确指定网络服务器支持哪些功能和是否提供如何使用每个功能的说明的粗略衡量。'
- en: '**Cost** This is the monetary cost of distributing the webserver in an appliance.
    Note that we have not included any webservers for which there is a monetary cost.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**成本** 这是将网络服务器分发给设备的货币成本。请注意，我们没有包括任何有货币成本的网络服务器。'
- en: '**Security** These are the security features that prevent users from accessing
    files that they shouldn’t be able to access. The most secure webservers are those
    that enforce access through a configuration file.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性** 这些是防止用户访问他们不应能够访问的文件的安全功能。最安全的网络服务器是那些强制通过配置文件进行访问的网络服务器。'
- en: '**License** This is the type of software license the webserver has. The Apache,
    BSD, and GPL licenses are well known. The GoAhead license requires that you notify
    GoAhead prior to shipping your product and that you display a GoAhead logo on
    your initial web page.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**许可证** 这是网络服务器所拥有的软件许可证类型。Apache、BSD 和 GPL 许可证是众所周知的。GoAhead 许可证要求你在产品发货前通知
    GoAhead，并在你的初始网页上显示 GoAhead 标志。'
- en: '**Considering Memory Requirements**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑内存需求**'
- en: If memory is not a factor in your appliance, the Apache webserver would be a
    good choice. The advantage of Apache is its mature feature set, good development
    tools (like Zend Studio), and an active development community.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备中内存不是问题，Apache 网络服务器将是一个不错的选择。Apache 的优点是它成熟的功能集、良好的开发工具（如 Zend Studio）和活跃的开发社区。
- en: If memory is at a premium, then the BusyBox webserver might be a good choice;
    it has the smallest virtual memory requirements of the webservers we tested. The
    GoAhead webserver has the next smallest memory requirements; however, the disadvantage
    of GoAhead is that it uses Active Server Pages, a Microsoft technology, rather
    than PHP, an open source technology. (You can still run PHP scripts in GoAhead
    using the CGI mechanism, but it isn’t as seamless as using a webserver with a
    built-in PHP interpreter.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存很紧张，那么 BusyBox 网络服务器可能是一个不错的选择；它是我们在测试的网络服务器中虚拟内存需求最小的。GoAhead 网络服务器的内存需求次之；然而，GoAhead
    的缺点是它使用 Active Server Pages，这是一种微软技术，而不是 PHP，这是一种开源技术。（你仍然可以使用 CGI 机制在 GoAhead
    中运行 PHP 脚本，但这不如使用内置 PHP 解释器的网络服务器那样无缝。）
- en: '**Considering Response Time**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑响应时间**'
- en: The top three webservers in terms of response time are thttpd, Apache, and lighttpd.
    Both thttpd and Apache get their speed from running PHP scripts in the same process
    as the webserver itself, which avoids the inter-process communication used by
    the other webservers. The thttpd webserver has the disadvantage that it only services
    one request at a time, so it will block subsequent requests until previous requests
    have been completed. This behavior may be fine for some web pages, but it will
    be a problem if the web page is written to block requests for a certain length
    of time, or to block until a state change. One of the Laddie web pages does block
    for a state change, and so this web page behavior rules out using thttpd webserver
    for the Laddie appliance. (We’ll discuss this particular web page in the section
    “Asynchronous Updates Using Ajax” on page 125.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应时间方面，排名前三的网络服务器是 thttpd、Apache 和 lighttpd。thttpd 和 Apache 都通过在同一个进程中运行 PHP
    脚本来获得速度，这避免了其他网络服务器使用的进程间通信。thttpd 网络服务器的缺点是它一次只能服务一个请求，因此它将在之前的请求完成之前阻塞后续请求。这种行为对于某些网页来说可能没问题，但如果网页被编写为在一定时间内阻塞请求，或者直到状态改变才解除阻塞，那么这将成为一个问题。Laddie
    中的一个网页就会因为状态改变而阻塞，因此这种网页行为排除了在 Laddie 设备中使用 thttpd 网络服务器。（我们将在第 125 页的“使用 Ajax
    进行异步更新”部分讨论这个特定的网页。）
- en: '**Our Choice**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们的选择**'
- en: When we were developing Laddie, we used the Apache webserver because of its
    debugging support, while for the production appliance, we selected lighttpd because
    of its smaller memory requirement and its speed. We chose which webserver to use
    in the production appliance rather late in the development cycle. We were able
    to make this decision later because we had written our PHP scripts to work under
    Apache, CGI, and FastCGI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发 Laddie 的过程中，我们使用了 Apache 网络服务器，因为它提供了调试支持；而对于生产设备，我们选择了 lighttpd，因为它对内存的要求较小且速度快。我们在开发周期的后期才决定使用哪个网络服务器。我们之所以能够晚些时候做出这个决定，是因为我们已经将
    PHP 脚本编写为可以在 Apache、CGI 和 FastCGI 下运行。
- en: In his book about embedded Linux, Yaghmour advises against using Apache because
    it is difficult to cross-compile (*Building Embedded Linux Systems*, by Karim
    Yaghmour, O’Reilly, 2003). There was no need to cross-compile for our appliance,
    but if your appliance’s CPU differs from your development machine’s CPU, you should
    keep this in mind.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的关于嵌入式 Linux 的书中，Yaghmour 建议不要使用 Apache，因为它难以交叉编译（《嵌入式 Linux 系统构建》，Karim Yaghmour
    著，O’Reilly，2003）。对于我们的设备来说，没有必要进行交叉编译，但如果你设备的 CPU 与开发机的 CPU 不同，你应该记住这一点。
- en: '[**UI Design**](toc.html#chapter8.14)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[**UI 设计**](toc.html#chapter8.14)'
- en: In this section, we’ll review various approaches to designing the UI look and
    feel, and the trade-offs they require. We will weigh these trade-offs when making
    implementation decisions in the “Implementation” section on page 118.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾设计 UI 外观和感觉的各种方法，以及它们所需的权衡。在“实现”部分的第 118 页，我们将权衡这些权衡以做出实现决策。
- en: '[***Menu System***](toc.html#chapter8.15)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[***菜单系统***](toc.html#chapter8.15)'
- en: One of the most important functions of a menu system is that it allows users
    to quickly grasp the system’s capabilities. A menu with lots of top-level options
    can make it difficult for the user to choose an action, because there are so many
    choices. On the other hand, a menu with lots of nesting, though reducing the crowding
    on the top-level menu, tends to increase the time it takes to find an action.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单系统最重要的功能之一是它允许用户快速了解系统的功能。拥有许多顶层选项的菜单可能会让用户难以选择操作，因为选择太多。另一方面，拥有许多嵌套的菜单，虽然减少了顶层菜单的拥挤，但往往会增加找到操作所需的时间。
- en: Menu systems can be divided into those in which the top-level menu runs vertically
    down the left side of the window (see Figure 8-1), and those in which the top-level
    menu runs horizontally, near the top of the window (see Figure 8-2). While the
    vertical menu can be useful, it can quickly become difficult to navigate as the
    number of menu items increases (note the scrollbars in Figure 8-1). The horizontal
    menu is usually superior because it can be more compact because the second-level
    menus share the same real estate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单系统可以分为那些顶层菜单沿着窗口左侧垂直运行的（见图 8-1），以及那些顶层菜单在窗口顶部附近水平运行的（见图 8-2）。虽然垂直菜单可能很有用，但随着菜单项数量的增加，它可能很快变得难以导航（注意图
    8-1 中的滚动条）。水平菜单通常更优越，因为它可以更紧凑，因为二级菜单共享相同的区域。
- en: '![](../images/138-1.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/138-1.jpg)'
- en: '*Figure 8-1: A vertical menu*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-1：垂直菜单*'
- en: '![](../images/139-1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/139-1.jpg)'
- en: '*Figure 8-2: A horizontal menu*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：水平菜单*'
- en: One disadvantage to the vertical MyFaces menu in Figure 8-2 is that it is not
    visually clear that the second-level menus (e.g., *Tomahawk*, *Documentation*,
    and *Components*) are not selectable; they look like the third-level menus, but
    they behave differently. The MyFaces menu could be improved by making the non-selectable
    menu items more distinct. For example, see the menus shown in Figure 8-3.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-2 中垂直 MyFaces 菜单的一个缺点是，第二级菜单（例如，*Tomahawk*、*Documentation* 和 *Components*）不可选的事实在视觉上并不明显；它们看起来像第三级菜单，但行为不同。MyFaces
    菜单可以通过使不可选择菜单项更明显来得到改进。例如，参见图 8-3 中显示的菜单。
- en: '![](../images/139-2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/139-2.jpg)'
- en: '*Figure 8-3: A menu with distinct non-selectable items*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-3：具有明显不可选择项的菜单*'
- en: '[***Dialog Boxes***](toc.html#chapter8.16)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[***对话框***](toc.html#chapter8.16)'
- en: 'Our advice on dialog boxes is simple: Avoid them. Dialog boxes halt proceedings
    because the user cannot continue until he or she clicks a button to close the
    box. Alan Cooper argues against dialog boxes because they break the flow of the
    user experience and don’t move users closer to their goal *(About Face 2.0: The
    Essentials of User Interaction Design* by Alan Cooper and Robert Reimann, Wiley,
    2003).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于对话框的建议很简单：避免使用它们。对话框会中断进程，因为用户必须点击按钮关闭对话框才能继续操作。艾伦·库珀反对使用对话框，因为它们会打断用户体验的流程，并且不会让用户更接近他们的目标（艾伦·库珀和罗伯特·莱曼著，《About
    Face 2.0：用户交互设计要素》， Wiley，2003年）。
- en: An alternative to dialog boxes is to place informational messages into the web
    page itself. We’ll demonstrate this in the next section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的替代方案是将信息性消息放入网页本身。我们将在下一节中演示这一点。
- en: '[***Error Messages***](toc.html#chapter8.17)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[***错误信息***](toc.html#chapter8.17)'
- en: 'Good error messages can greatly improve the usability of your web UI. Experts
    generally agree on the following guidelines:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的错误信息可以极大地提高您网页用户界面的可用性。专家们普遍同意以下指导原则：
- en: If possible, make the program smarter to either avoid the particular error condition
    or recover from it.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，使程序更智能，以避免特定的错误条件或从中恢复。
- en: If an unrecoverable error has been detected, provide an explicit error message—that
    is, don’t suppress the error.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到不可恢复的错误，应提供明确的错误信息——也就是说，不要抑制错误。
- en: The error message should be human readable.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息应该是人类可读的。
- en: The error message should be detailed.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息应该详细。
- en: The error message should advise how to fix the problem.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息应该建议如何解决问题。
- en: The error message should be close to the field with the error.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息应该接近有错误的字段。
- en: The fields with errors should be clearly identified.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有错误的字段应清楚地标识。
- en: Some error conditions are caused by the user (when the user enters a bad value
    in a web form), while others are caused by external events (when the appliance
    disk becomes full). When designing your appliance’s web pages, think about how
    these different errors will be handled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误条件是由用户引起的（当用户在网页表单中输入错误值时），而另一些是由外部事件引起的（当设备磁盘变满时）。在设计你的设备网页时，考虑这些不同错误将如何被处理。
- en: One way to present error messages is to use dialog boxes (see Figure 8-4), but
    as we mentioned before, we discourage this approach. A second approach is to insert
    the error message into the refreshed web page (see Figure 8-5). The salient feature
    with this approach is that the error message is displayed in the form field, so
    that users can immediately re-enter their data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 展示错误信息的一种方式是使用对话框（见图8-4），但正如我们之前提到的，我们不建议这种方法。第二种方法是将在刷新的网页中插入错误信息（见图8-5）。这种方法的一个显著特点是错误信息以表单字段的形式显示，这样用户可以立即重新输入他们的数据。
- en: '![](../images/140-1.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/140-1.jpg)'
- en: '*Figure 8-4: An error dialog box*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-4：错误对话框*'
- en: '![](../images/140-2.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/140-2.jpg)'
- en: '*Figure 8-5: An in-line error message*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-5：行内错误信息*'
- en: A third approach is to annotate the labels where an error has occurred, as shown
    in Figure 8-6\. In this example, errors are shown by displaying the labels in
    another color. In this figure, all of the field labels are in black, except for
    *Lan IP* and *Control IP*, which are in red (they’re circled here because they
    appear gray); this tells you that there is a problem with those fields. One problem
    with this approach is that it fails to provide a detailed message. While some
    systems provide a tooltip with a message, such a mechanism is usually not explicit
    enough, and the user must mouse over the label to see more detail, which makes
    the user do unnecessary work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是在发生错误的地方注释标签，如图8-6所示。在这个例子中，通过显示标签为另一种颜色来显示错误。在这个图中，所有的字段标签都是黑色，除了*Lan
    IP*和*Control IP*，它们是红色的（它们在这里被圈出，因为它们看起来是灰色的）；这告诉你这些字段有问题。这种方法的一个问题是它未能提供详细的错误信息。虽然一些系统提供了带有信息的工具提示，但这样的机制通常不够明确，用户必须将鼠标悬停在标签上才能看到更多细节，这会让用户做不必要的操作。
- en: '![](../images/141-1.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/141-1.jpg)'
- en: '*Figure 8-6: An annotated error message*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-6：带注释的错误信息*'
- en: '[***Improving Responsiveness with Ajax***](toc.html#chapter8.18)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[**使用Ajax提高响应性**](toc.html#chapter8.18)'
- en: '*Ajax (Asynchronous JavaScript and XML)* is a set of technologies that enables
    partial updates of web pages. Because only parts of a web page are refreshed,
    the update occurs more quickly than it would if the entire web page was refreshed.
    Furthermore, the partial update may be triggered by user events like mouse clicks
    and key presses. This behavior makes the UI more responsive than that of a traditional
    web page.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ajax (异步JavaScript和XML)* 是一套技术，它使得网页的部分更新成为可能。由于只有网页的一部分被刷新，更新速度比整个网页刷新要快得多。此外，部分更新可能由用户事件（如鼠标点击和按键）触发。这种行为使得用户界面比传统网页更加响应。'
- en: For example, Gmail, Google’s email service, uses Ajax. When you compose an email
    and start typing the name of a contact, the browser responds to every key, reducing
    the list of matches as you type. The responsiveness is impressive.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Gmail，谷歌的电子邮件服务，使用了Ajax。当你撰写电子邮件并开始输入联系人的名字时，浏览器会对每个按键做出响应，随着你输入，匹配的列表会减少。这种响应性令人印象深刻。
- en: Figure 8-7 shows an example of how the Ajax communication mechanism works. The
    exchange in this figure is initiated when the user mouses over an active element
    on the web page at event ![](../images/1a.jpg). An onmouseover action is triggered
    and JavaScript code is executed in the web browser at event ![](../images/2a.jpg).
    The JavaScript code creates an XMLHttpRequest object with the URL of the server-side
    script and a JavaScript callback function, and the web browser then sends the
    XMLHttpRequest object to the server at event ![](../images/3a.jpg). On the server
    side, the particular script identified by the URL responds with XML data at event
    ![](../images/4a.jpg).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-7展示了Ajax通信机制的工作示例。图中的交换是在用户在网页上的活动元素上鼠标悬停时（事件![图片](../images/1a.jpg)）开始的。当事件![图片](../images/2a.jpg)发生时，会触发onmouseover动作，并在浏览器中执行JavaScript代码。JavaScript代码创建了一个带有服务器端脚本URL和JavaScript回调函数的XMLHttpRequest对象，然后浏览器在事件![图片](../images/3a.jpg)中将XMLHttpRequest对象发送到服务器。在服务器端，由URL指定的特定脚本在事件![图片](../images/4a.jpg)中以XML数据的形式做出响应。
- en: '![](../images/142-1.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/142-1.jpg)'
- en: '*Figure 8-7: Typical Ajax sequence.*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-7：典型的Ajax序列。*'
- en: '**NOTE**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The format of the XML is known by the client and the server, so that when
    the server sends the XML data, the client understands its format. Typically, the
    XML data will contain the updated information to be displayed on some portion
    of the web page in the browser.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*XML的格式由客户端和服务器所熟知，因此当服务器发送XML数据时，客户端能够理解其格式。通常，XML数据将包含要在浏览器网页的某些部分显示的更新信息。*'
- en: Back on the client side, the web browser receives the XML data and invokes the
    JavaScript callback function. This callback function extracts the data from the
    XML message and modifies some portion of the web page using the XML Document Object
    Model (DOM) API at event ![](../images/5a.jpg).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，网页浏览器接收XML数据并调用JavaScript回调函数。此回调函数从XML消息中提取数据，并使用XML文档对象模型（DOM）API在事件![../images/5a.jpg](../images/5a.jpg)中修改网页的某些部分。
- en: Mouse movements are not the only events that are supported by Ajax, but they
    are the most popular, along with mouse button clicks, key presses, text selections,
    and keyboard focuses on editable fields—and more events are made available with
    each browser upgrade.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标移动并不是Ajax所支持的唯一事件，但它们是最受欢迎的，包括鼠标按钮点击、按键、文本选择和可编辑字段上的键盘焦点——并且随着每个浏览器的升级，还有更多事件被提供。
- en: '[**Implementation**](toc.html#chapter8.19)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[**实现**](toc.html#chapter8.19)'
- en: In this section, we’ll discuss the implementation of Laddie’s web UI. We’ll
    show some screenshots of the web UI and discuss how it works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Laddie网页用户界面的实现。我们将展示一些网页用户界面的截图并讨论其工作原理。
- en: 'The web UI supports at least the following web browsers: Internet Explorer
    (version 5.0 and later), Netscape Navigator (version 4.72 and later), Firefox
    (version 1.0 and later), Safari (version 1.0 and later), Opera (version 5.0 and
    later), and Lynx (version 2.8.2 and later). These versions were determined through
    direct testing with archived browsers available from [http://browsers.evolt.org](http://browsers.evolt.org/).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 网页用户界面至少支持以下网页浏览器：Internet Explorer（版本5.0及以上）、Netscape Navigator（版本4.72及以上）、Firefox（版本1.0及以上）、Safari（版本1.0及以上）、Opera（版本5.0及以上）和Lynx（版本2.8.2及以上）。这些版本是通过与从[http://browsers.evolt.org](http://browsers.evolt.org/)获取的存档浏览器直接测试确定的。
- en: '**NOTE**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Unlike the other graphical browsers, the Lynx browser is text-based.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*与其他图形浏览器不同，Lynx浏览器是基于文本的。*'
- en: '[***Interfacing with the Daemons***](toc.html#chapter8.20)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[***与守护进程接口***](toc.html#chapter8.20)'
- en: The Laddie web UI presents information from several running daemons. As you
    know, each of these daemons communicates using the PostgreSQL protocol. In this
    section, we’ll discuss how the web UI interacts with ladd, the Laddie alarm daemon.
    Once you understand this interaction, you’ll understand how the web UI interacts
    with the other daemons as well. Figure 8-8 shows a typical sequence where a user
    requests a web page and the web page is generated dynamically, based on the state
    of a daemon.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie网页用户界面展示了几个运行中的守护进程的信息。正如你所知，这些守护进程使用PostgreSQL协议进行通信。在本节中，我们将讨论网页用户界面如何与Laddie警报守护进程ladd交互。一旦你理解了这种交互，你也会明白网页用户界面如何与其他守护进程交互。图8-8展示了用户请求网页并基于守护进程的状态动态生成网页的典型序列。
- en: The figure shows the Linux appliance with the webserver and the ladd alarm daemon
    running on it. For simplicity, we’ve shown the PHP interpreter running in the
    same process as the webserver, as in the case of Apache, but it could be running
    as a different process if you’re using CGI scripts.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了运行在Linux设备上的带有web服务器和ladd警报守护进程的Linux设备。为了简单起见，我们展示了与Apache相同的方式，PHP解释器在同一个进程中运行，但如果你使用CGI脚本，它可能作为不同的进程运行。
- en: As mentioned, the figure shows a typical request-response sequence for a web
    page. First, the user requests a particular page at event ![](../images/1a.jpg).
    The webserver locates the web page from the filesystem, and because the webserver
    finds PHP tags in the page, it invokes the PHP interpreter, which interprets the
    PHP code. In our case, the particular PHP code includes PHP functions pg_connect()
    and pg_exec(), which are invoked by the PHP interpreter at events ![](../images/2a.jpg)
    and ![](../images/3a.jpg). The PHP code generates the web page at event ![](../images/4a.jpg),
    and this new page is then sent back to the browser at event ![](../images/5a.jpg).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，该图显示了网页的典型请求-响应序列。首先，用户在事件 ![](../images/1a.jpg) 中请求特定的页面。web 服务器从文件系统中定位网页，因为
    web 服务器在页面中发现了 PHP 标签，所以它调用了 PHP 解释器，该解释器解释 PHP 代码。在我们的例子中，特定的 PHP 代码包括 PHP 函数
    pg_connect() 和 pg_exec()，这些函数在事件 ![](../images/2a.jpg) 和 ![](../images/3a.jpg)
    中由 PHP 解释器调用。PHP 代码在事件 ![](../images/4a.jpg) 中生成网页，然后在新的事件 ![](../images/5a.jpg)
    中将此新页面发送回浏览器。
- en: '![](../images/143-1.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/143-1.jpg)'
- en: '*Figure 8-8: Interfacing with a daemon*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-8：与守护进程接口*'
- en: '**Connecting to the Daemon**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到守护进程**'
- en: As you can see in the illustration, before you can read and write to the ladd
    daemon, you must establish a connection using the pg_connect() function, which
    is built into the PHP interpreter when you configure PHP with the --with-pgsql
    option. The pg_connect() function takes a string argument that specifies the hostname
    (or IP address) of the server and the port. In our case, the server is on the
    same machine as the webserver, and the ladd daemon is listening on port 8888\.
    More information on pg_connect() can be found by searching for *PostgreSQL Functions*
    in the PHP manual at http://us2.php.net/pgsql.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如插图所示，在您能够读取和写入 ladd 守护进程之前，您必须使用 pg_connect() 函数建立连接，该函数在您使用 --with-pgsql 选项配置
    PHP 时内置到 PHP 解释器中。pg_connect() 函数接受一个字符串参数，指定服务器的主机名（或 IP 地址）和端口号。在我们的例子中，服务器位于与
    web 服务器相同的机器上，ladd 守护进程监听端口 8888。有关 pg_connect() 的更多信息，可以在 http://us2.php.net/pgsql
    的 PHP 手册中通过搜索 *PostgreSQL Functions* 获取。
- en: 'The following code fragment shows how to open a connection to the daemon:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何打开到守护进程的连接：
- en: '![](../images/144-1.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/144-1.jpg)'
- en: '**Reading from the Daemon**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**从守护进程读取**'
- en: Once a connection has been established, you can read from and write to the ladd
    daemon. We use the pg_exec() function to do this. This function requests that
    a given statement be executed, in our case a SELECT statement. For more details
    on pg_exec(), see the PostgreSQL Functions at [http://us2.php.net/pgsql](http://us2.php.net/pgsql).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了连接，您就可以从 ladd 守护进程读取和写入。我们使用 pg_exec() 函数来完成这项操作。此函数请求执行给定的语句，在我们的例子中是一个
    SELECT 语句。有关 pg_exec() 的更多详细信息，请参阅 PostgreSQL 函数文档 [http://us2.php.net/pgsql](http://us2.php.net/pgsql)。
- en: 'The following PHP code fragment shows how to read the alarm status:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 PHP 代码片段显示了如何读取警报状态：
- en: '![](../images/144-2.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/144-2.jpg)'
- en: In this example, the names id, name, enabled, and alarm in the SELECT command
    are the column names in the Zone RTA table in the ladd daemon. Generally, the
    SELECT command will have the same form for different daemons, but the number of
    columns and their names may differ. The value returned by the pg_exec() function
    is an object handle, which is then used to extract the number of rows with pg_NumRows()
    and each row’s contents with pg_result().
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，SELECT 命令中的名称 id、name、enabled 和 alarm 是 ladd 守护进程中的 Zone RTA 表的列名。通常，不同的守护进程的
    SELECT 命令将具有相同的形式，但列数和名称可能不同。pg_exec() 函数返回的对象句柄，然后用于使用 pg_NumRows() 提取行数和 pg_result()
    提取每行的内容。
- en: '**NOTE**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the functions with names that start with pg are part of the PostgreSQL
    PHP library and are not unique to our daemon.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有以 pg 开头的函数名都是 PostgreSQL PHP 库的一部分，并不特定于我们的守护进程。*'
- en: Once the information has been read from the daemon, you can use this information
    to generate an HTML page. For example, we would use the results in $id, $name,
    $enabled, and $alarm to generate an HTML table.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从守护进程读取了信息，您就可以使用这些信息生成一个 HTML 页面。例如，我们会使用 $id、$name、$enabled 和 $alarm 的结果来生成一个
    HTML 表格。
- en: '**Writing to the Daemon**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**写入守护进程**'
- en: 'To write to the ladd daemon and set alarm zone 3 into the alarm state, you
    could use the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入 ladd 守护进程并将警报区域 3 设置为警报状态，可以使用以下代码：
- en: '![](../images/145-1.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/145-1.jpg)'
- en: Note that you use the same pg_exec() function call as when reading information
    from the daemon; the difference is that the SQL command is UPDATE rather than
    SELECT. The SQL command in the preceding code snippet specifies to update the
    alarm column in the Zone table to the value $value, but only in the case where
    the id column matches $id.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用与从守护进程读取信息时相同的 pg_exec() 函数调用；区别在于 SQL 命令是 UPDATE 而不是 SELECT。前面的代码片段中的
    SQL 命令指定更新 Zone 表中的报警列到 $value 值，但仅当 id 列与 $id 匹配时。
- en: In the preceding code snippet we’ve set the $value and $id variables to arbitrary
    values, but typically the $id and $value variables would be extracted from an
    HTML form.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们已将 $value 和 $id 变量设置为任意值，但通常 $id 和 $value 变量会从 HTML 表单中提取。
- en: The interaction between the web UI and the ladd daemon is straightforward enough.
    The web UI can read information from the ladd daemon and it can write information
    to the ladd daemon. The web UI interacts with the other daemons in the same way,
    so there is nothing new to learn about those interactions. (The interaction is
    straightforward because we are using an established protocol, PostgreSQL, and
    the function bindings to this protocol are readily available to PHP programs.)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 网页用户界面和 ladd 守护进程之间的交互足够简单。网页用户界面可以从 ladd 守护进程读取信息，也可以向 ladd 守护进程写入信息。网页用户界面以相同的方式与其他守护进程交互，因此关于这些交互没有新的东西需要学习。（交互之所以简单，是因为我们使用了一个已建立的协议
    PostgreSQL，并且该协议的函数绑定对 PHP 程序来说是现成的。）
- en: '[***Alarm Status Page***](toc.html#chapter8.21)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[***报警状态页面***](toc.html#chapter8.21)'
- en: Figure 8-9 shows Laddie’s alarm status page. This page allows you to view the
    status of each alarm zone, clear alarm conditions, and set an alarm condition
    (for testing purposes).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8-9 显示了 Laddie 的报警状态页面。此页面允许你查看每个报警区域的状态，清除报警状态，以及设置报警状态（用于测试目的）。
- en: '![](../images/145-2.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/145-2.jpg)'
- en: '*Figure 8-9: Laddie status page*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-9：Laddie 状态页面*'
- en: An alarm condition can be shown either as a gray horizontal bar or with the
    label *Alarm* under the *Status* column. If you were to actually use this interface,
    you would probably find that the horizontal bar is much easier to read than the
    label because it offers a quick visual cue. When designing your web interface,
    think about how you might augment your interface with similar visual cues to convey
    information quickly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 报警状态可以显示为一个灰色水平条，或者在“状态”列下带有标签 *报警*。如果你实际使用这个界面，你可能会发现水平条比标签更容易阅读，因为它提供了一个快速的可视提示。在设计你的网页界面时，考虑一下你如何通过类似的视觉提示来快速传达信息。
- en: Unlike traditional web pages, which require a user to refresh the page to update
    status, this status page automatically updates when an alarm condition changes.
    To observe this automatic update behavior, start two browsers and point them to
    the alarm status page. In one browser, modify the alarm condition by clicking
    the Clear and Set buttons. If JavaScript is enabled in your two browsers, you
    should see a page update on both browsers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与需要用户刷新页面来更新状态的传统网页不同，此状态页面在报警状态改变时自动更新。要观察这种自动更新行为，请启动两个浏览器并将它们指向报警状态页面。在一个浏览器中，通过点击清除和设置按钮来修改报警状态。如果你的两个浏览器都启用了
    JavaScript，你应该在两个浏览器上看到页面更新。
- en: You can find the PHP code that generates this web page on this book’s companion
    CD in the file /opt/laddie/htdocs/web/cgi-bin/status.php.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的配套 CD 中的文件 /opt/laddie/htdocs/web/cgi-bin/status.php 中找到生成此网页的 PHP 代码。
- en: '[***Alarm Setup Page***](toc.html#chapter8.22)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[***报警设置页面***](toc.html#chapter8.22)'
- en: 'The alarm setup page, shown in Figure 8-10, allows you to configure the names
    of the alarm zones. When designing this page, we considered two UI design approaches:
    an Update button for each zone and a single Update button for all zones. We chose
    the single button because it reduces the navigation required to configure all
    the zones; you simply modify the parameters of several zones and click Update.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 报警设置页面，如图 8-10 所示，允许你配置报警区域的名字。在设计这个页面时，我们考虑了两种用户界面设计方法：每个区域一个更新按钮和所有区域一个更新按钮。我们选择了单个按钮，因为它减少了配置所有区域所需的导航；你只需修改几个区域的参数并点击更新。
- en: '![](../images/146-1.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/146-1.jpg)'
- en: '*Figure 8-10: Laddie alarm setup page*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-10：Laddie 报警设置页面*'
- en: 'This web page allows the user to enter the names of each alarm zone. We’ll
    now describe how the web page works and in particular how to work with the tabular
    data shown there. On the browser side, the web page includes an HTML form, which
    is a mechanism for accepting input from a user and sending it to the webserver
    when the user presses a Submit button. If you take a look at the web page’s HTML
    source, you will see the following line:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此网页允许用户输入每个警报区域的名称。现在我们将描述网页的工作原理，特别是如何处理显示的表格数据。在浏览器端，网页包含一个 HTML 表单，这是一种从用户那里接受输入并在用户按下提交按钮时将其发送到
    web 服务器的机制。如果您查看网页的 HTML 源代码，您将看到以下行：
- en: <td> <input type=text name=Name_1 value="Garage Door" /> </td>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`<td> <input type=text name=Name_1 value="Garage Door" /> </td>`'
- en: The input tag tells the browser to display a field for textual input. The name
    tag tells the browser how to name the field, and the value tag tells the browser
    how to populate the initial value for the field. When the user hits the Submit
    button, the names and values of all form fields are sent to the server. When the
    server receives this request, our PHP code will extract the zone names from the
    request and update the Laddie daemon.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 输入标签告诉浏览器显示一个用于文本输入的字段。名称标签告诉浏览器如何命名该字段，而值标签告诉浏览器如何为该字段填充初始值。当用户点击提交按钮时，所有表单字段的名称和值都会发送到服务器。当服务器接收到此请求时，我们的
    PHP 代码将提取区域名称并更新 Laddie 守护进程。
- en: 'PHP provides a simple mechanism to extract the field values. For example, to
    extract the value for the field with name *Name_1,* you would use the following
    PHP code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了一种简单的机制来提取字段值。例如，要提取名为 *Name_1* 的字段的值，您将使用以下 PHP 代码：
- en: $name = $_REQUEST["Name_1"];
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`$name = $_REQUEST["Name_1"];`'
- en: The _REQUEST variable is a global variable that is populated by the PHP interpreter,
    while the *Name_1* string corresponds to the name of the field in the HMTL form.
    Once this statement is executed on the server, the $name variable will contain
    the text that the user entered in the browser.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`_REQUEST` 变量是一个由 PHP 解释器填充的全局变量，而 `*Name_1*` 字符串对应于 HTML 表单中字段的名称。一旦在服务器上执行此语句，$name
    变量将包含用户在浏览器中输入的文本。'
- en: For tabular forms we need to be careful about field naming because the HTML
    specification requires that all fields in a form must have a unique name. One
    common approach to naming such form fields in HTML is to append a row number to
    the column name. For example, we append the row number *1* to *Name* (using underscore
    as a separation character) to get *Name_1* for the Name column for Zone 1.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表格表单，我们需要注意字段命名，因为 HTML 规范要求表单中的所有字段都必须具有唯一的名称。在 HTML 中命名此类表单字段的一种常见方法是在列名称后附加行号。例如，我们将行号
    *1* 附加到 *Name*（使用下划线作为分隔符）以获得区域 1 的名称列的 *Name_1*。
- en: The PHP code to generate this web page can be found on this book’s companion
    CD in the file /opt/laddie/htdocs/web/cgi-bin/setup_alarm.php. Take a look at
    the function displayZoneForm. The PHP code that handles the web form updates is
    in the same file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此网页的 PHP 代码可在本书配套 CD 上的文件 /opt/laddie/htdocs/web/cgi-bin/setup_alarm.php 中找到。查看
    displayZoneForm 函数。处理表单更新的 PHP 代码位于同一文件中。
- en: '[***Page Layout and Menu System***](toc.html#chapter8.23)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[***页面布局和菜单系统***](toc.html#chapter8.23)'
- en: In this section, we’ll describe Laddie’s web page layout and menu system. This
    simple scheme is handled by two PHP files. The first file, layout.php, defines
    Laddie’s two-level menu system as a two-dimensional array (see the global variable
    $menu_system on this book’s companion CD in /opt/laddie/ htdocs/web/cgi-bin/layout.php)
    and it defines the function display_page(). This function refreshes the page whenever
    the user navigates the menu. The second file, alarmstyle.css, controls color,
    fonts, and indentation (see /opt/laddie/htdocs/web/alarmstyle.css on the CD).
    Figure 8-11 shows an example web page; the PHP code that generated this web page
    follows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述 Laddie 的网页布局和菜单系统。这个简单的方案由两个 PHP 文件处理。第一个文件，layout.php，将 Laddie 的两层菜单系统定义为二维数组（请参阅本书配套
    CD 上的全局变量 $menu_system，位于 /opt/laddie/htdocs/web/cgi-bin/layout.php），并定义了 display_page()
    函数。此函数在用户导航菜单时刷新页面。第二个文件，alarmstyle.css，控制颜色、字体和缩进（请参阅 CD 上的 /opt/laddie/htdocs/web/alarmstyle.css）。图
    8-11 显示了一个示例网页；生成此网页的 PHP 代码如下。
- en: '![](../images/147-1.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/147-1.jpg)'
- en: '*Figure 8-11: Laddie’s “Hello, world!” example*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-11：Laddie 的 “Hello, world!” 示例*'
- en: '![](../images/148-1.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/148-1.jpg)'
- en: The first two parameters in the call to display_page() are indices into the
    menu structure (defined by the global variable $menu_system in layout.php). The
    first parameter, "Setup" in this example, is the top-level index, while the second
    parameter is the second-level index. The third parameter is an HTML-formatted
    string, which is displayed in the main window. In this example, the main window
    consists of the heading Hello, world! and two lines. It is the main window that
    is different for each web page, and typically this content is generated dynamically,
    depending on the state of the system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用display_page()时，前两个参数是菜单结构（由layout.php中的全局变量$menu_system定义）中的索引。在这个例子中，第一个参数"Setup"是顶级索引，而第二个参数是二级索引。第三个参数是一个HTML格式化的字符串，它将在主窗口中显示。在这个例子中，主窗口由标题Hello,
    world!和两行组成。它是每个网页都不同的主窗口，通常这个内容是动态生成的，取决于系统的状态。
- en: In summary, the presentation logic for page layout is encapsulated by the function
    display_page(). For another example of how to use display_page(), see /opt/laddie/htdocs/web/cgi-bin/help_contact_us.php
    on the CD.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，页面布局的展示逻辑被封装在函数display_page()中。关于如何使用display_page()的另一个示例，请参阅CD上的/opt/laddie/htdocs/web/cgi-bin/help_contact_us.php。
- en: '[***Webserver Independence***](toc.html#chapter8.24)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[***Webserver Independence***](toc.html#chapter8.24)'
- en: PHP works with many different webservers, each having a slightly different way
    of interacting with the PHP interpreter. The API with which PHP interacts with
    the webserver is called the Server API. The Server API used by PHP is determined
    when compiling PHP, so as a developer you probably know this before writing the
    PHP scripts. But what if you decided to use another webserver? If you didn’t plan
    ahead, you would have to modify a lot of code to get it to work with the new webserver.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PHP与许多不同的web服务器协同工作，每个服务器与PHP解释器的交互方式略有不同。PHP与web服务器交互的API称为Server API。PHP使用的Server
    API是在编译PHP时确定的，因此作为开发者，你可能在编写PHP脚本之前就已经知道了这一点。但如果你决定使用另一个web服务器呢？如果你没有提前规划，你可能需要修改大量代码才能使其与新web服务器兼容。
- en: As an aside, PHP provides the function php_sapi_name() to programmati-cally
    determine which API is currently in use. This function returns one of many possible
    strings, three of which are *apache, cgi,* and *cgi-fcgi,* corresponding to Apache,
    CGI, and FastCGI. There’s not too much documentation on the Server API, but try
    searching for it on Google.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，PHP提供了php_sapi_name()函数，可以编程地确定当前正在使用哪个API。此函数返回许多可能的字符串之一，其中三个是*apache,
    cgi,* 和 *cgi-fcgi,* 分别对应Apache、CGI和FastCGI。关于Server API的文档并不多，但尝试在Google上搜索它。
- en: 'Early in the design phase, we decided to write our PHP scripts so that they
    would work with these three Server APIs, because the webservers that we investigated
    supported at least one of them. This would mean that our PHP scripts would work
    without modification under any webserver that supported one of these APIs. This
    server-independent approach offers two advantages: It avoids locking you in with
    a particular webserver (should a better one become available) and it allows you
    to develop scripts using a different webserver than the one deployed in your appliance.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计阶段初期，我们决定编写我们的PHP脚本，以便它们可以与这三个Server API一起工作，因为我们调查的web服务器至少支持其中一个。这意味着我们的PHP脚本可以在支持这些API的任何web服务器上无需修改即可运行。这种服务器无关的方法提供了两个优点：它避免了将你锁定在特定的web服务器上（如果出现更好的服务器），并且允许你使用与你的设备中部署的web服务器不同的web服务器来开发脚本。
- en: 'Script input parameters are defined by name-value strings. For example, an
    input parameter might have the name *disp_id* and a value of 51\. The script’s
    input parameters are provided by the HTTP request that invokes the script; for
    example, the following request will set the input parameter *disp_id* for the
    script wait_for_status.php:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输入参数由名称-值字符串定义。例如，一个输入参数可能具有名称*disp_id*和值为51。脚本输入参数由调用脚本的HTTP请求提供；例如，以下请求将为脚本wait_for_status.php设置输入参数*disp_id*：
- en: '[http://127.0.0.1/wait_for_status.php?disp_id=51](http://127.0.0.1/wait_for_status.php?disp_id=51)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://127.0.0.1/wait_for_status.php?disp_id=51](http://127.0.0.1/wait_for_status.php?disp_id=51)'
- en: The trick to supporting Apache, CGI, and FastCGI lies in handling the script’s
    input parameters the same way, regardless of which environment the script is running
    in. (There is no problem with the output because these three Server APIs handle
    output the same way.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Apache、CGI和FastCGI的技巧在于，无论脚本在哪个环境中运行，都以相同的方式处理脚本输入参数。（输出没有问题，因为这三个Server API以相同的方式处理输出。）
- en: For CGI scripts, the script’s input parameters are extracted from STDIN, whereas
    for Apache and FastCGI scripts, they are extracted from PHP global variables.
    Actually, the Apache and FastCGI cases are identical, so there are only two cases,
    CGI and Apache. We chose to abstract these two cases with a function called read_params().
    The implementation of read_params() handles the details of both cases, but from
    the caller’s perspective, it provides a uniform way to extract the input parameters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CGI脚本，脚本输入参数是从STDIN中提取的，而对于Apache和FastCGI脚本，则是从PHP全局变量中提取的。实际上，Apache和FastCGI的情况是相同的，所以只有两种情况，CGI和Apache。我们选择使用名为read_params()的函数来抽象这两种情况。read_params()函数的实现处理了这两种情况的细节，但从调用者的角度来看，它提供了一种统一的方式来提取输入参数。
- en: 'The PHP code fragment below shows how the function is used:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的PHP代码片段显示了如何使用该函数：
- en: '![](../images/149-1.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/149-1.jpg)'
- en: The read_params() function returns an array containing all the script’s input
    parameters. The calling script can then retrieve a particular parameter value
    using the parameter’s name (which is known at design time). Note that the function
    array_key_exists is a PHP built-in function that determines whether or not a given
    index exists in a given array.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: read_params()函数返回一个包含所有脚本输入参数的数组。调用脚本然后可以使用参数的名称（在设计时已知）检索特定的参数值。请注意，函数array_key_exists是PHP的一个内置函数，用于确定给定的索引是否存在于给定的数组中。
- en: The implementation of the read_params() function can be found in the file /opt/laddie/htdocs/web/cgi-bin/php_params.php
    on the CD. You’ll find another example of its use in /opt/laddie/htdocs/web/cgi-bin/
    setup_snmp.php.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: read_params()函数的实现可以在CD上的文件/opt/laddie/htdocs/web/cgi-bin/php_params.php中找到。你还可以在/opt/laddie/htdocs/web/cgi-bin/setup_snmp.php中找到其使用的另一个示例。
- en: '[***Asynchronous Updates Using Ajax***](toc.html#chapter8.25)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[***使用Ajax进行异步更新***](toc.html#chapter8.25)'
- en: Consider the status web page shown in Figure 8-9\. How should the web page react
    to changes in the state of an alarm?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到图8-9所示的网页状态。网页应该如何响应警报状态的变化？
- en: 'Preferably, the web page should be updated automatically, rather than requiring
    the user to repeatedly click the browser’s Refresh button. One approach is to
    poll the server at a fixed frequency, for example, using the Refresh HTML meta
    tag as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最好，网页应该自动更新，而不是要求用户反复点击浏览器的刷新按钮。一种方法是在固定频率下轮询服务器，例如，使用以下Refresh HTML元标签：
- en: <META HTTP-EQUIV="Refresh" CONTENT="5;URL=refreshed-page.html">
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`<META HTTP-EQUIV="Refresh" CONTENT="5;URL=refreshed-page.html">`'
- en: Another approach is to use Ajax so that the web page updates only when there
    is a state change on the server. The disadvantage with Ajax is that it requires
    JavaScript to be enabled in the web browser; if the user disables JavaScript,
    the update mechanism breaks. On the other hand, when Ajax is used, the web page
    updates quickly in response to state changes on the server.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用Ajax，这样网页只会在服务器状态发生变化时更新。Ajax的缺点是它需要在网络浏览器中启用JavaScript；如果用户禁用了JavaScript，更新机制就会失效。另一方面，当使用Ajax时，网页会快速响应服务器状态的变化。
- en: In the section “Improving Responsiveness with Ajax” on page 117, we described
    how a typical Ajax exchange works. However, note that this typical exchange is
    initiated by the client, rather than the server. We need a way to modify Ajax
    so that the browser responds to state changes on the server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第117页的“使用Ajax提高响应性”部分，我们描述了典型的Ajax交换是如何工作的。然而，请注意，这种典型的交换是由客户端发起的，而不是服务器。我们需要一种方法来修改Ajax，以便浏览器能够响应服务器上的状态变化。
- en: It turns out that we can modify the Ajax exchange so that the system behaves
    as if the webserver initiates the exchange. The trick is twofold. First, replace
    the onmouseover event with the onload event, so that the XMLHttpRequest is sent
    as soon as the web page is loaded. Second, write the webserver script so that
    it blocks while waiting for an event. By implementing this modified Ajax exchange,
    the web page will update whenever the particular event occurs on the server. The
    experienced Ajax programmer will note that there is another mechanism that achieves
    a similar result, notably the *HTTP Streaming pattern* documented at [http://www.ajaxpatterns.org](http://www.ajaxpatterns.org/)
    (and in the associated book, *Ajax Design Patterns*, by Michael Mahemoff, O’Reilly,
    2006). Both our approach and the HTTP Streaming pattern have the disadvantage
    of using a long-lived TCP connection, which may be a problem for webservers that
    allow only a finite number of concurrent connections. However, for our approach
    we can control how long the request waits for a server event, thereby limiting
    the number of concurrent connections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们可以修改Ajax交换，使系统表现得就像是由web服务器发起交换。这个技巧有两个方面。首先，将onmouseover事件替换为onload事件，这样一旦网页加载，就会立即发送XMLHttpRequest。其次，编写web服务器脚本，使其在等待事件时阻塞。通过实现这种修改后的Ajax交换，每当服务器上发生特定事件时，网页都会更新。有经验的Ajax程序员会注意到还有另一种机制可以达到类似的效果，那就是在[http://www.ajaxpatterns.org](http://www.ajaxpatterns.org/)（以及相关的书籍《Ajax设计模式》，作者Michael
    Mahemoff，O'Reilly，2006）中记录的*HTTP流模式*。我们的方法和HTTP流模式都有使用长连接的缺点，这可能会成为只允许有限并发连接的web服务器的难题。然而，对于我们的方法，我们可以控制请求等待服务器事件的时间，从而限制并发连接的数量。
- en: Before we describe the details of this modified Ajax exchange, let’s review
    the big picture. Figure 8-12 shows the sequence for a user requesting a new web
    page, with the first full page update and subsequent partial page updates. In
    terms of timing, events ![](../images/1a.jpg) through ![](../images/10a.jpg) occur
    in quick succession after the user requests the particular web page. At this point,
    the web page is loaded with the latest alarm state. When some alarm state changes
    at event ![](../images/11a.jpg), it triggers events ![](../images/12a.jpg) through
    ![](../images/19a.jpg) in quick succession, at which point the web page is refreshed
    with the new alarm state. This latter sequence repeats until the user navigates
    away from the web page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述这个修改后的Ajax交换的细节之前，让我们先回顾一下整体情况。图8-12显示了用户请求新网页的序列，包括第一次完整页面更新和随后的部分页面更新。从时间上看，事件![](../images/1a.jpg)到![](../images/10a.jpg)在用户请求特定网页后迅速连续发生。此时，网页加载了最新的警报状态。当在事件![](../images/11a.jpg)发生警报状态变化时，会迅速触发事件![](../images/12a.jpg)到![](../images/19a.jpg)，此时网页会刷新为新的警报状态。这个后续序列会一直重复，直到用户离开网页。
- en: '**Browser Sends First HTTP Request**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器发送第一个HTTP请求**'
- en: The sequence from events ![](../images/1a.jpg) through ![](../images/7a.jpg)
    is the standard HTML request response exchange. In step ![](../images/1a.jpg),
    the user requests a web page, the server responds by sending the web page and,
    in step ![](../images/7a.jpg), the browser displays the page. These steps are
    performed for all web requests regardless of whether the web page includes JavaScript.
    The remaining sequence from event ![](../images/8a.jpg) through ![](../images/19a.jpg)
    is more interesting, and it is this sequence that we’ll describe in more detail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件![](../images/1a.jpg)到![](../images/7a.jpg)的序列是标准的HTML请求响应交换。在步骤![](../images/1a.jpg)中，用户请求一个网页，服务器通过发送网页进行响应，在步骤![](../images/7a.jpg)中，浏览器显示页面。这些步骤对所有网页请求都会执行，无论网页是否包含JavaScript。从事件![](../images/8a.jpg)到![](../images/19a.jpg)的剩余序列更有趣，我们将更详细地描述这个序列。
- en: '![](../images/151-1.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/151-1.jpg)'
- en: '*Figure 8-12: The Ajax sequence for an external event*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-12：外部事件的Ajax序列*'
- en: '**Browser Sends Second HTTP Request**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器发送第二个HTTP请求**'
- en: On the client side, event ![](../images/8a.jpg) is triggered as soon as the
    web page is loaded for the first time at event ![](../images/7a.jpg). In particular,
    the function GetCurrentStatus() is invoked. Take a look at the HTML source for
    the Zone Status web page by booting up this book’s companion CD and using a browser
    to visit 192.168.1.11.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，当网页首次在事件![](../images/7a.jpg)加载时，会触发事件![](../images/8a.jpg)。特别是，会调用GetCurrentStatus()函数。请通过启动本书的配套CD并使用浏览器访问192.168.1.11来查看Zone
    Status网页的HTML源代码。
- en: The default IP address of the Laddie alarm appliance is 192.168.1.11 (and the
    default netmask is 255.255.0.0). When you insert this book’s CD into your computer
    and reboot it, you will then be able to connect to the web UI by typing the URL
    [http://192.168.1.11](http://192.168.1.11/) in any web browser on another computer.
    If the default IP address conflicts with an existing node on your network, you
    can change the IP address for Laddie with the following steps. Quit the framebuffer
    interface (press Q for quit), then at the shell prompt, enter **root** for the
    user and press ENTER for the password (there is no password). Then enter **lynx**
    at the command prompt. From lynx you can navigate to the Network Setup page and
    modify the IP address of the network interfaces. Once you have changed the IP
    address with lynx, you can re-type the URL (with your new IP address) in a browser
    on another computer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Laddie警报设备的默认IP地址是192.168.1.11（默认子网掩码是255.255.0.0）。当您将本书的CD插入计算机并重新启动时，您就可以通过在另一台计算机上的任何Web浏览器中键入URL
    [http://192.168.1.11](http://192.168.1.11/) 来连接到Web UI。如果默认IP地址与您的网络上的现有节点冲突，您可以使用以下步骤更改Laddie的IP地址。退出帧缓冲区界面（按Q退出），然后在shell提示符下，输入**root**作为用户并按ENTER键输入密码（没有密码）。然后输入**lynx**到命令提示符。在lynx中，您可以导航到网络设置页面并修改网络接口的IP地址。一旦您使用lynx更改了IP地址，您就可以在另一台计算机上的浏览器中重新输入URL（使用您的新IP地址）。
- en: 'If you view the source for this web page, you will see the following line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看此网页的源代码，您将看到以下行：
- en: <body onload="GetCurrentStatus()">
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <body onload="GetCurrentStatus()">
- en: 'The GetCurrentStatus() function then makes an XMLHttpRequest with the URL wait_for_status.php
    (at event ![](../images/9a.jpg)). You’ll see the following code in the file /opt/laddie/web/cgi-bin/status.php
    on this book’s companion CD:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: GetCurrentStatus()函数随后使用URL wait_for_status.php 发起一个XMLHttpRequest（在事件 ![](../images/9a.jpg)
    上）。您将在本书配套CD上的文件/opt/laddie/web/cgi-bin/status.php中看到以下代码：
- en: '![](../images/152-1.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/152-1.jpg)'
- en: This code snippet instructs the browser to send a HTTP GET request with the
    URL wait_for_status.php. It also instructs the browser to invoke the callback
    function GotStatus() when a response is received from the server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码指示浏览器发送一个带有URL wait_for_status.php 的HTTP GET请求。它还指示浏览器在收到来自服务器的响应时调用回调函数GotStatus()。
- en: '**Server Blocks Waiting for Alarm State Change**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器阻塞等待警报状态变化**'
- en: On the server side, the script wait_for_status.php is invoked. This script does
    a blocking read on port 4444 at event ![](../images/10a.jpg). Whenever there is
    a change in alarm state in the ladd daemon at event ![](../images/11a.jpg), the
    logmuxd daemon writes a message to port 4444 at event ![](../images/13a.jpg).
    The contents of what is written to the port are unimportant; what is important
    is that the message unblocks the PHP thread at event ![](../images/14a.jpg).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，脚本wait_for_status.php被调用。此脚本在事件 ![](../images/10a.jpg) 上对端口4444进行阻塞读取。每当在事件
    ![](../images/11a.jpg) 上的ladd守护进程中的警报状态发生变化时，logmuxd守护进程会将一条消息写入端口4444，在事件 ![](../images/13a.jpg)
    上。写入端口的实际内容并不重要；重要的是，这条消息会在事件 ![](../images/14a.jpg) 上解除PHP线程的阻塞。
- en: Notice in the code above that curr_id is sent with the URL. This variable prevents
    the browser from losing log events when the events come too quickly. This variable
    is passed like a token between the server and the browser, and it increases in
    lock-step with the number of log events. If the curr_id value from the browser
    does not match the number of log events on the server, the PHP thread skips blocking
    on port 4444\. This way, if there are new log events during the time interval
    that the PHP thread is not blocking on port 4444, the PHP thread will continue.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中注意，curr_id与URL一起发送。这个变量防止浏览器在事件来得太快时丢失日志事件。这个变量像令牌一样在服务器和浏览器之间传递，并且它与日志事件的数量同步增加。如果浏览器中的curr_id值与服务器上的日志事件数量不匹配，PHP线程将跳过在端口4444上的阻塞。这样，如果在PHP线程不在端口4444上阻塞的时间间隔内有新的日志事件，PHP线程将继续执行。
- en: '**Server Sends Alarm State as XML**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器以XML格式发送警报状态**'
- en: 'Once the blocking read returns, the PHP script reads the alarm status from
    the ladd alarm daemon (at event ![](../images/15a.jpg)), and combines the data
    into an XML document (at event ![](../images/16a.jpg)). The webserver then passes
    this XML document to the browser (at event ![](../images/17a.jpg)). An example
    XML document looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦阻塞读取返回，PHP脚本从ladd警报守护进程（在事件 ![](../images/15a.jpg) 上）读取警报状态，并将数据组合成一个XML文档（在事件
    ![](../images/16a.jpg) 上）。然后，web服务器将此XML文档传递给浏览器（在事件 ![](../images/17a.jpg) 上）。一个示例XML文档如下所示：
- en: '![](../images/153-1.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/153-1.jpg)'
- en: '**Browser Updates Portion of Web Page**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器更新网页部分**'
- en: Back on the client side, the browser receives the XML document, and generates
    an HTML fragment from it; it uses this fragment to update the web page (event
    ![](../images/18a.jpg)). The function GotStatus() in status.php has the following
    code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，浏览器接收XML文档，并从中生成一个HTML片段；它使用这个片段来更新网页（事件![图片](../images/18a.jpg)）。`status.php`中的`GotStatus()`函数有以下代码。
- en: '![](../images/154-1.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/154-1.jpg)'
- en: The first line extracts the zone data from the XML response, the second line
    generates an HTML fragment specifically for the Laddie status page, and the last
    line inserts the HTML fragment into the displayed page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行从XML响应中提取区域数据，第二行生成专门用于Laddie状态页面的HTML片段，最后一行将HTML片段插入到显示的页面中。
- en: '**Browser Repeats by Sending Another HTTP Request**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器通过发送另一个HTTP请求重复操作**'
- en: 'The browser then invokes another XMLHttpRequest and the process repeats (at
    event ![](../images/19a.jpg)). After a small delay, the GotStatus() function invokes
    GetCurrentStatus() with the following line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，浏览器调用另一个XMLHttpRequest，过程重复（在事件![图片](../images/19a.jpg)）。经过一小段时间延迟后，`GotStatus()`函数通过以下行调用`GetCurrentStatus()`：
- en: setTimeout("GetCurrentStatus()", 2000);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: setTimeout("GetCurrentStatus()", 2000);
- en: You can see how this behavior works by opening two web browsers to the status
    page at [http://192.168.1.11](http://192.168.1.11/). If you change the state of
    an alarm zone in one of the browsers, you should see this state change on the
    other web browser, as well.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开两个网络浏览器到状态页[http://192.168.1.11](http://192.168.1.11/)来查看这种行为是如何工作的。如果你在一个浏览器中改变一个报警区域的状态，你应该在另一个网络浏览器上看到这个状态的变化。
- en: To summarize, we have shown a technique for using Ajax to update web pages where
    the update is triggered by events on the server rather than by events on the client.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们展示了一种使用Ajax更新网页的技术，这里的更新是由服务器上的事件触发的，而不是客户端的事件。
- en: '**Graceful Degradation Without JavaScript**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有JavaScript的优雅降级**'
- en: When designing a web-based appliance, you must decide which web browsers you
    will support. Do you support non-graphical browsers like Lynx, or do you only
    support fully featured browsers? By reducing the level of required browser functionality,
    you can support a wide variety of browsers, but it will be at the expense of an
    increased effort in development. At the other extreme, you could dictate that
    a specific browser be used, with the advantage of using proprietary features,
    but with the risk of some customers disliking your browser selection. Customer
    input would be invaluable in helping you to make this decision.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计一个基于Web的设备时，你必须决定你将支持哪些网络浏览器。你是否支持像Lynx这样的非图形浏览器，还是你只支持功能齐全的浏览器？通过降低所需浏览器功能级别，你可以支持各种浏览器，但这是以增加开发工作量为代价的。在另一个极端，你可以规定使用特定的浏览器，这有利于使用专有功能，但存在一些客户可能不喜欢你的浏览器选择的风险。客户的反馈将非常有价值，可以帮助你做出这个决定。
- en: We chose to support a wide variety of browsers, then sought to reduce the developmental
    effort by avoiding browser-specific code. That is, we avoided code that didn’t
    work the same way on all major browsers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择支持广泛的浏览器，然后通过避免浏览器特定的代码来减少开发工作量。也就是说，我们避免了在所有主要浏览器上工作方式不同的代码。
- en: Of particular concern was the ability to support browsers without JavaScript.
    One of the difficulties with JavaScript is that it can be disabled by the user,
    and even worse, the user may not know that it is disabled.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得关注的是支持没有JavaScript的浏览器的能力。JavaScript的一个困难之处在于它可以被用户禁用，更糟糕的是，用户可能不知道它已经被禁用了。
- en: One approach for supporting browsers with and without JavaScript is to structure
    the website as two “universes”—one universe in which JavaScript is used and another
    in which it isn’t. The home page is written to detect whether JavaScript is enabled
    on the browser and to then redirect the browser to the appropriate universe. Unfortunately,
    this solution does not work if the user disables JavaScript and then reloads a
    particular page. The work-around is for the user to turn on JavaScript and then
    revisit the home page.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 支持有和没有JavaScript的浏览器的一种方法是将网站结构为两个“宇宙”——一个使用JavaScript的宇宙，另一个不使用。主页被编写成检测浏览器上是否启用了JavaScript，然后重定向浏览器到相应的宇宙。不幸的是，如果用户禁用了JavaScript然后重新加载特定的页面，这个解决方案就不起作用了。解决方案是用户打开JavaScript然后重新访问主页。
- en: We took another approach, one which allows the user to enable or disable JavaScript
    and then simply reload the particular page. This means that each web page must
    support a JavaScript version and a non-JavaScript version. In the past, this problem
    might have been tricky to solve because browsers that didn’t support JavaScript
    were confused by JavaScript code. But this problem is easily solved today, because
    the majority of browsers (even those like Lynx that don’t support JavaScript)
    understand the HTML <SCRIPT> tag. When a modern browser has JavaScript disabled,
    it ignores all HTML code between the pair of tags <SCRIPT> and </SCRIPT>.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取了另一种方法，这种方法允许用户启用或禁用JavaScript，然后简单地重新加载特定页面。这意味着每个网页都必须支持JavaScript版本和非JavaScript版本。在过去，这个问题可能很难解决，因为不支持JavaScript的浏览器会被JavaScript代码弄糊涂。但今天这个问题很容易解决，因为大多数浏览器（甚至那些不支持JavaScript的浏览器，如Lynx）都理解HTML
    <SCRIPT>标签。当一个现代浏览器禁用JavaScript时，它会忽略<SCRIPT>和</SCRIPT>标签之间的所有HTML代码。
- en: '**Hiding JavaScript**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏JavaScript**'
- en: The following pattern for hiding JavaScript content from browsers is known to
    work for Internet Explorer (version 5.0 and later), Netscape Navigator (version
    4.72 and later), Firefox (version 1.0 and later), Safari (version 1.0 and later),
    Opera (version 5.0 and later), and Lynx (version 2.8.2 and later).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏JavaScript内容从浏览器中已知的工作模式适用于Internet Explorer（版本5.0及以后）、Netscape Navigator（版本4.72及以后）、Firefox（版本1.0及以后）、Safari（版本1.0及以后）、Opera（版本5.0及以后）和Lynx（版本2.8.2及以后）。
- en: '![](../images/155-1.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](../images/155-1.jpg)'
- en: The HTML comments <!-- and --> are included as a fail-safe mechanism for those
    old browsers that don’t understand the <SCRIPT> tags. Similarly, you can use <NOSCRIPT>
    and </NOSCRIPT> tags to provide alternate content when JavaScript is not enabled.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: HTML注释<!-- 和 -->被包括作为一个针对那些不理解<SCRIPT>标签的老旧浏览器的安全机制。同样，您可以使用<NOSCRIPT>和</NOSCRIPT>标签在JavaScript未启用时提供替代内容。
- en: Using these patterns, each web page can support both JavaScript and non-JavaScript
    versions, and consequently, the user can change the browser’s JavaScript setting
    and reload the page. Because the user doesn’t have to find and reload some site-wide
    redirection page, the user’s experience is greatly simplified.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些模式，每个网页都可以支持JavaScript和非JavaScript版本，因此用户可以更改浏览器的JavaScript设置并重新加载页面。因为用户不必找到并重新加载一些全局重定向页面，用户的体验大大简化。
- en: '[**Improving Our Design**](toc.html#chapter8.26)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[**改进我们的设计**](toc.html#chapter8.26)'
- en: Having implemented the web UI, we are in a better position to review and improve
    our design. What are some areas that could use improvement?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了Web UI之后，我们更有能力审查和改进我们的设计。有哪些领域可能需要改进？
- en: One problem with the current design is that the logic for configuring network
    interfaces is contained in setup_network.php, and unfortunately, this logic is
    not available to other UIs, like the command line interface (CLI). When we first
    implemented the network setup page, we did not foresee how complex this configuration
    logic would be, and so we decided that all UIs would duplicate this “simple” logic.
    In hindsight, we feel that the design would be improved by subsuming the network
    configuration logic into a single manager, notably the networkd daemon. That way,
    the CLI user interface could provide the same functionality as the network setup
    web page, without duplicating much of the logic in setup_network.php.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当前设计的一个问题是，配置网络接口的逻辑包含在setup_network.php中，不幸的是，这个逻辑对其他UI（如命令行界面CLI）不可用。当我们最初实现网络设置页面时，我们没有预见这个配置逻辑会如此复杂，因此我们决定所有UI都会复制这个“简单”逻辑。事后看来，我们认为将网络配置逻辑纳入一个单一的管理器（特别是networkd守护进程）会改进设计。这样，CLI用户界面就可以提供与网络设置网页相同的功能，而不必在setup_network.php中复制大量逻辑。
- en: We could improve the web UI’s usability by clarifying the relationship between
    the second-level and top-level menus. This might be done using different colors
    for the top-level and second-level menus, as shown in Figure 8-2\. Note in this
    figure that it is easy to see that the second-level item *Components* falls under
    the first-level menu *Tomahawk*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过明确二级菜单和顶级菜单之间的关系来提高Web UI的可用性。这可以通过为顶级和二级菜单使用不同的颜色来实现，如图8-2所示。注意在这个图中，很容易看出二级项目*组件*属于一级菜单*Tomahawk*。
- en: Another improvement would be to add error-checking functionality on the client
    side. This improvement would be achieved by adding JavaScript functions to check
    the validity of form fields, resulting in a more responsive UI.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个改进是添加客户端的错误检查功能。通过添加JavaScript函数来检查表单字段的合法性，可以实现更响应式的用户界面。
- en: We could enhance functionality by adding a web page that would provide diagnostics
    functions for network connectivity and hardware health, such as temperature and
    fan speed. This functionality would allow management software to remotely monitor
    the appliance for degrading performance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个提供网络连接和硬件健康诊断功能（如温度和风扇速度）的网页来增强功能。这种功能将允许管理软件远程监控设备以检测性能下降。
- en: '[**Resources**](toc.html#chapter8.27)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[**资源**](toc.html#chapter8.27)'
- en: The following resources will be useful for further study of web page design,
    Ajax, debugging, and testing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源将有助于进一步学习网页设计、Ajax、调试和测试。
- en: '**UI design** The book *About Face 2.0: The Essentials of User Interaction
    Design* by Alan Cooper and Robert Reimann (Wiley, 2003) is a good book about UI
    design.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI设计** Alan Cooper和Robert Reimann合著的《About Face 2.0：用户交互设计要素》（Wiley，2003年）是一本关于UI设计的优秀书籍。'
- en: '**JavaScript** A good reference book on JavaScript is the *JavaScript Bible,
    5th Edition* by Danny Goodman and Michael Morrison (Wiley, 2004).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript** 一本关于JavaScript的好参考书是Danny Goodman和Michael Morrison合著的《JavaScript圣经，第5版》（Wiley，2004年）。'
- en: '**Ajax** The Wikipedia web page on Ajax programming is a starting point for
    learning about the technique and includes the history of Ajax. See [http://en.wikipedia.org/wiki/Ajax_(programming](http://en.wikipedia.org/wiki/Ajax_(programming)).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax** 关于Ajax编程的维基百科页面是学习这种技术的起点，并包括Ajax的历史。见[http://en.wikipedia.org/wiki/Ajax_(programming](http://en.wikipedia.org/wiki/Ajax_(programming))。'
- en: '**HTML validation** The World Wide Web Consortium (W3C) provides a free HTML
    validation service at [http://validator.w3.org](http://validator.w3.org/). A CSS
    validation service is also available.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML验证** 互联网联盟（W3C）提供了一个免费的HTML验证服务，网址为[http://validator.w3.org](http://validator.w3.org/)。同时，也提供CSS验证服务。'
- en: '**Web browsers** Older web browsers, useful for testing your web pages, are
    archived at [http://browsers.evolt.org](http://browsers.evolt.org/).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web浏览器** 对于测试你的网页，较老的Web浏览器存档在[http://browsers.evolt.org](http://browsers.evolt.org/)。'
- en: '**Debuggers** The Zend Studio debugger allows you to debug PHP code using Microsoft’s
    Internet Explorer and the Apache webserver. Using this browser, you can step through
    PHP code that is executing under Apache. It is a commercial software package,
    available at [http://www.zend.com](http://www.zend.com/).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试器** Zend Studio调试器允许你使用微软的Internet Explorer和Apache网络服务器来调试PHP代码。使用这个浏览器，你可以逐步执行在Apache下运行的PHP代码。这是一个商业软件包，可在[http://www.zend.com](http://www.zend.com/)获取。'
- en: '[**Summary**](toc.html#chapter8.28)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter8.28)'
- en: In this chapter, we have discussed the development of web UIs for Linux-based
    appliances, in particular, the web UI for Laddie. It has not been our goal to
    discuss all of web technology—you will find entire books on that subject.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了基于Linux的设备的网页用户界面开发，特别是Laddie的网页用户界面。我们的目标并不是讨论所有的网络技术——关于这个主题，你将找到整本书。
- en: 'This chapter highlighted the pertinent features of Laddie’s web UI:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了Laddie网页用户界面的相关特性：
- en: The web UI degrades gracefully for browsers that don’t support JavaScript so
    that the web UI functionality is accessible to a wide variety of browsers.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不支持JavaScript的浏览器，网页用户界面能够优雅地降级，以便广泛的浏览器都能访问网页用户界面的功能。
- en: 'The alarm status page updates automatically whenever there is a change in the
    alarm state on the appliance:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设备上的警报状态发生变化时，警报状态页面会自动更新：
- en: When an alarm is triggered, each browser viewing the status web page is refreshed
    automatically.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当警报被触发时，查看状态网页的每个浏览器都会自动刷新。
- en: When any browser is used to clear an alarm, the change is reflected on all other
    browsers.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何浏览器用于清除警报时，这种变化会在所有其他浏览器上反映出来。
- en: After implementing the web UI, we looked back at our design and suggested some
    future improvements. In particular, we suggested that the logic for configuring
    network interfaces should be moved from PHP into the network daemon, networkd.
    This restructuring would have the advantage that other UIs, for example the CLI,
    could configure network interfaces without duplicating the complex logic in PHP.
    Other improvements include restructuring the menu system and adding JavaScript
    error-checking functions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现网页用户界面后，我们回顾了我们的设计并提出了一些未来的改进建议。特别是，我们建议将配置网络接口的逻辑从PHP移动到网络守护进程networkd中。这种重构的优势在于，其他用户界面，例如命令行界面CLI，可以配置网络接口而无需在PHP中重复复杂的逻辑。其他改进包括重构菜单系统并添加JavaScript错误检查函数。
