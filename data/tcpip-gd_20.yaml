- en: Part III-9. OTHER FILE AND MESSAGE TRANSFER APPLICATIONS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分-9. 其他文件和消息传输应用
- en: '[Chapter 85](ch85.html "Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK
    NEWS TRANSFER PROTOCOL (NNTP)")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第85章](ch85.html "第85章. USENET（网络新闻）和TCP/IP网络新闻传输协议（NNTP）")'
- en: '[Chapter 86](ch86.html "Chapter 86. GOPHER PROTOCOL (GOPHER)")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第86章](ch86.html "第86章. GOPHER 协议")'
- en: 'The previous three parts of this book have examined several of the most widely
    used TCP/IP file and message transfer protocols: the File Transfer Protocol (FTP),
    the Trivial File Transfer Protocol (TFTP), electronic mail (email), and the World
    Wide Web. Of course, hundreds of other applications are in use on the Internet
    today, and we couldn''t possibly examine them all here. However, there are a couple
    of other protocols that are considered part of the group of classic applications
    of TCP/IP like FTP, email, and the Web that I feel are worth discussing.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前三部分已经探讨了几个最广泛使用的TCP/IP文件和消息传输协议：文件传输协议（FTP）、简单文件传输协议（TFTP）、电子邮件（email）和万维网。当然，今天互联网上使用的其他应用有成百上千，我们不可能在这里全部考察。然而，还有一些其他协议被认为是TCP/IP经典应用组的一部分，如FTP、电子邮件和万维网，我认为它们值得讨论。
- en: This part contains two chapters that cover these other file and message transfer
    applications. The first chapter describes Usenet (network news), which is one
    of the original methods of group communication on the Internet. The second chapter
    describes the Gopher protocol, which while no longer widely used today is worth
    a brief discussion, especially due to its role as a historical precursor of the
    Web.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含两章，涵盖了这些其他文件和消息传输应用。第一章描述了Usenet（网络新闻），这是互联网上最早的群组通信方法之一。第二章描述了Gopher协议，尽管今天不再广泛使用，但仍有简要讨论的价值，尤其是由于其作为万维网历史先导的角色。
- en: Chapter 85. USENET (NETWORK NEWS) AND THE TCP/IP NETWORK NEWS TRANSFER PROTOCOL
    (NNTP)
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第85章. USENET（网络新闻）和TCP/IP网络新闻传输协议（NNTP）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: Electronic mail (email) is one of the stalwarts of message transfer on the modern
    Internet, but it is really designed only for communication within a relatively
    small group of specific users. There are many situations in which email is not
    ideally suited, such as when information needs to be shared among a large number
    of participants, not all of whom may necessarily even know each other. One classic
    example of this is sharing *news*. In this case, the person providing news often
    wants to make it generally available to anyone who is interested, rather than
    specifying a particular set of recipients.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件（email）是现代互联网上消息传输的支柱之一，但它实际上仅设计用于相对较小的一组特定用户之间的通信。有许多情况下电子邮件并不理想，例如当需要在大批参与者之间共享信息时，其中并非所有参与者都必然相互认识。一个典型的例子是共享*新闻*。在这种情况下，提供新闻的人通常希望让任何感兴趣的人都能获得，而不是指定一组特定的收件人。
- en: For distributing news and other types of general information over internetworks,
    a messaging system called both *Usenet* and *network news* was created. Like email,
    this application allows messages to be written and read by large numbers of users.
    However, it is designed using a very different model than email—one that is focused
    on public sharing and feedback. In Usenet, anyone can write a message that can
    be read by any number of recipients, and anyone can respond to messages written
    by others. Usenet was one of the first widely deployed internetwork-based group
    communication applications, and it has grown into one of the largest online communities
    in the world, used by millions of people for sharing information, asking questions,
    and discussing thousands of different topics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在互联网上分发新闻和其他类型的通用信息，创建了一个名为*Usenet*和*网络新闻*的消息系统。像电子邮件一样，这个应用允许大量用户编写和阅读消息。然而，它使用了一个与电子邮件非常不同的模型——一个专注于公共共享和反馈的模型。在Usenet中，任何人都可以编写可以被任何数量收件人阅读的消息，任何人都可以对其他人编写的消息做出回应。Usenet是第一个广泛部署的基于互联网的群组通信应用之一，它已经发展成为世界上最大的在线社区之一，被数百万人们用于分享信息、提问和讨论数千个不同的话题。
- en: 'In this chapter, I describe Usenet and network news in detail, discussing how
    they are used and how they work. I provide an overview and history of Usenet,
    a high-level look at its model of communication and how messages are created and
    manipulated, an explanation of Usenet newsgroups, and a description of the Usenet
    message format and headers. Then I provide a detailed description of the operation
    of the Network News Transfer Protocol (NNTP), the means used for transferring
    messages on modern Usenet. Starting as usual with an overview of the protocol,
    I then explain the two fundamentals ways that NNTP is used: for the propagation
    of news articles between servers and for client article posting and access. From
    there, I move on to the technical details of NNTP commands, command extensions,
    responses, and response codes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我详细介绍了 Usenet 和网络新闻，讨论了它们的使用方式和工作原理。我提供了 Usenet 的概述和历史，对其通信模型以及消息的创建和操作进行了高级概述，解释了
    Usenet 新闻组，并描述了 Usenet 消息格式和标题。然后，我详细描述了网络新闻传输协议（NNTP）的操作，这是现代 Usenet 上传输消息的手段。通常从协议概述开始，然后解释
    NNTP 的两种基本使用方式：在服务器之间传播新闻文章以及客户端文章的发布和访问。从那里，我继续介绍 NNTP 命令、命令扩展、响应和响应代码的技术细节。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *Several aspects of how Usenet works are closely
    related to the standards and techniques used for email. If you have not read [Part III-7](pt18.html
    "Part III-7. TCP/IP ELECTRONIC MAIL SYSTEM: CONCEPTS AND PROTOCOLS"), which covers
    email, I suggest that you at least review the overview of the email system in
    [Chapter 74](ch74.html "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND
    CONCEPTS") and the discussion of the email message format in [Chapter 76](ch76.html
    "Chapter 76. TCP/IP ELECTRONIC MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC
    822 AND MIME"), since Usenet messages are based on the RFC 822 email message standard.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *Usenet的工作方式在许多方面与电子邮件所使用的标准和技巧密切相关。如果你还没有阅读[第三部分-7](pt18.html "第三部分-7.
    TCP/IP 电子邮件系统：概念和协议")，该部分涵盖了电子邮件，我建议你至少回顾一下[第74章](ch74.html "第74章. TCP/IP 电子邮件系统概述和概念")中的电子邮件系统概览以及[第76章](ch76.html
    "第76章. TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME")中关于电子邮件消息格式的讨论，因为 Usenet 消息是基于 RFC
    822 电子邮件消息标准的。*'
- en: Usenet Overview, History, and Operation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Usenet 概述、历史和操作
- en: Where email is the modern equivalent of the handwritten letter or the interoffice
    memo, *Usenet* is the updated version of the company newsletter, the cafeteria
    bulletin board, the coffee break chat, and the watercooler gossip session, all
    rolled into one. Spread worldwide over the Internet, Usenet newsgroup messages
    provide a means for people with common interests to form online communities to
    discuss happenings, solve problems, and provide support to each other, as well
    as to engage in plain old socializing and entertainment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子邮件是现代手写信件或办公室备忘录的等价物时，*Usenet* 则是公司通讯、食堂公告板、咖啡休息时间聊天以及饮水机旁闲聊的更新版，所有这些都被整合在一起。通过互联网在全球范围内传播，Usenet
    新闻组消息为具有共同兴趣的人们提供了一个形成在线社区的手段，以讨论事件、解决问题、相互提供支持，以及进行普通的社交和娱乐活动。
- en: We are by nature both highly social and creative animals, and as a result, we
    are always finding new ways to communicate. It did not take long after computers
    were first connected together for it to be recognized that those interconnections
    provided the means to link together people as well. The desire to use computers
    to create an *online community* led to the creation of Usenet more than two decades
    ago.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们天生就是高度社交和富有创造力的动物，因此我们总是在寻找新的沟通方式。计算机首次连接起来后不久，人们就认识到这些互连提供了将人们联系起来的手段。使用计算机创建一个
    *在线社区* 的愿望导致了 Usenet 在二十多年前被创造出来。
- en: History of Usenet
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet 历史
- en: Like almost everything associated with networking, Usenet had very humble beginnings.
    In 1979, Tom Truscott was a student at Duke University in North Carolina, and
    he spent the summer as an intern at Bell Laboratories, the place where the UNIX
    operating system was born. He enjoyed the experience so much that when he returned
    to school that autumn, he missed the intensive UNIX environment at Bell Labs.
    He used the *Unix-to-Unix Copy Protocol (UUCP)* to send information from his local
    machine to other machines and vice versa, including establishing electronic connectivity
    back to Bell Labs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有与网络相关的事物一样，Usenet 的起点非常简陋。1979 年，Tom Truscott 是北卡罗来纳州杜克大学的学生，那个夏天他在贝尔实验室实习，UNIX
    操作系统就是在这里诞生的。他非常喜欢这段经历，以至于当他秋天回到学校时，他怀念贝尔实验室密集的 UNIX 环境。他使用 *Unix-to-Unix Copy
    Protocol (UUCP)* 将信息从他的本地机器发送到其他机器，反之亦然，包括建立回贝尔实验室的电子连接。
- en: Building on this idea, Truscott and a fellow Duke student, Jim Ellis, teamed
    up with other UNIX enthusiasts at Duke and the nearby University of North Carolina
    (UNC) at Chapel Hill, to develop the idea of an online community. The goal was
    to create a system where students could use UNIX to write and read messages, to
    allow them to obtain both technical help and maintain social contacts. They designed
    the system based on an analogy to an online newsletter that was open to all users
    of a connected system. To share information, messages were posted to *newsgroups*,
    where any user could access the messages to read them and respond to them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在这样一个想法的基础上，Truscott 和他的杜克同学 Jim Ellis 与杜克大学和附近的北卡罗来纳大学教堂山分校（UNC）的 UNIX 热衷者合作，共同发展在线社区的想法。目标是创建一个系统，让学生可以使用
    UNIX 编写和阅读消息，以便他们能够获得技术帮助并保持社交联系。他们根据一个类比于对所有连接系统用户开放的在线新闻简报来设计这个系统。为了共享信息，消息被发布到
    *新闻组* 中，任何用户都可以访问这些消息来阅读和回复。
- en: The early work at Duke and UNC resulted in the development of both the initial
    message format and the software for the earliest versions of this system, which
    became known both as *network news (net news)* and *Usenet* (a contraction of
    *User's network*). At first, the system had just two computers, sharing messages
    posted in a pair of different newsgroups. The value of the system was immediately
    recognized, however, and soon many new sites were added to the system. These sites
    were arranged in a structure to allow messages to be efficiently passed using
    direct UUCP connections. The software used for passing news articles also continued
    to evolve and become more capable, as did the software for reading and writing
    articles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 杜克大学和 UNC 的早期工作导致了最初的消息格式和该系统最早版本软件的开发，这些软件既被称为 *网络新闻（net news）*，也被称为 *Usenet*（*User's
    network* 的缩写）。最初，该系统只有两台计算机，共享一对不同新闻组中发布的消息。然而，系统的价值立即得到了认可，很快就有许多新的站点被添加到系统中。这些站点被组织成一个结构，以便使用直接的
    UUCP 连接有效地传递消息。用于传递新闻文章的软件也继续发展，变得更加功能强大，阅读和编写文章的软件也是如此。
- en: 'The newsgroups themselves also changed over time. Many new newsgroups were
    created, and a hierarchical structure was defined to help keep the newsgroups
    organized in a meaningful way. As more sites and users joined Usenet, more areas
    of interest were identified. Today, there are a staggering number of Usenet newsgroups:
    more than 100,000\. While many of these groups are not used, many thousands of
    active ones discuss nearly every topic imaginable—from space exploration, to cooking,
    to biochemistry, to PC troubleshooting, to raising horses. There are also regional
    newsgroups devoted to particular areas; for example, there is a set of newsgroups
    for discussing events in Canada and another for discussing happenings in the New
    York area, and so on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻组本身也随着时间的推移而发生了变化。许多新的新闻组被创建，并定义了一个分层结构来帮助以有意义的方式组织新闻组。随着更多站点和用户加入 Usenet，识别出了更多兴趣领域。如今，Usenet
    新闻组数量惊人：超过 100,000 个。虽然其中许多组未被使用，但成千上万的活跃组讨论了几乎所有可以想象的主题——从太空探索到烹饪，从生物化学到 PC 故障排除，再到养马。还有一些针对特定地区的区域新闻组；例如，有一组新闻组用于讨论加拿大的事件，另一组用于讨论纽约地区的事件，等等。
- en: Usenet Operation and Characteristics
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet 运作和特点
- en: Usenet begins with a user writing a message to be distributed. After the message
    is *posted* to say, the group on TCP/IP networking, it is stored on that user's
    local news server, and special software sends copies of it to other connected
    news servers. The message eventually propagates around the world, where anyone
    who chooses to read the TCP/IP networking newsgroup can see the message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet始于一个用户编写要分发的消息。在消息被“发布”到TCP/IP网络组之后，它被存储在该用户的本地新闻服务器上，并且特殊的软件会将它的副本发送到其他连接的新闻服务器。消息最终在世界范围内传播，任何选择阅读TCP/IP网络新闻组的任何人都可以看到这条消息。
- en: The real power of Usenet is that after reading a message, any user can respond
    to it on the same newsgroup. Like the original message, the reply will propagate
    to each connected system, including the one used by the author of the original
    message. This makes Usenet very useful for sharing information about recent happenings,
    for social discussions, and especially for receiving assistance with problems,
    such as resolving technical glitches or getting help with a diet program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet真正的力量在于，在阅读一条消息后，任何用户都可以在同一新闻组中对此做出回应。就像原始消息一样，回复会传播到每个连接的系统，包括原始消息作者的使用的系统。这使得Usenet在分享关于最近发生的事情的信息、进行社交讨论以及特别是在解决技术故障或寻求饮食计划帮助等问题上非常有用。
- en: 'What is particularly interesting about Usenet is that it is not a formalized
    system in any way, and it is not based on any formally defined standards. It is
    a classic example of the development of a system in an entirely ad hoc manner:
    The software was created, people started using it, the software was refined, and
    things just took off from there. Certain standards have been written to codify
    how Usenet works—such as RFC 1036, which describes the Usenet message format—but
    these serve more as historical documents than as prescriptive standards.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet特别有趣的地方在于，它根本不是一种形式化的系统，也不基于任何正式定义的标准。它是系统完全按即兴方式发展的一个经典例子：软件被创建，人们开始使用它，软件被改进，然后事情就从这个基础上发展起来。已经编写了一些标准来规范Usenet的工作方式——例如RFC
    1036，它描述了Usenet的消息格式——但这些更多地作为历史文件，而不是规范性标准。
- en: There is likewise no central authority that is responsible for Usenet's operation,
    even though new users often think there is one. Unlike a dial-up bulletin board
    system or Web-based forum, Usenet works simply by virtue of cooperation between
    sites; there is no manager in charge. For this reason, Usenet is sometimes called
    an anarchy, but this is not accurate. It isn't the case that there are no rules.
    It is up to the managers of participating systems to make policy decisions such
    as which newsgroups to support. There are also certain dictatorial aspects of
    the system, in that only certain people (usually system administrators) can decide
    whether to create some kinds of new newsgroups. The system also has socialistic
    elements in that machine owners are expected to share messages with each other.
    So, the simplified political labels really don't apply to Usenet.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，没有中央权威机构负责Usenet的运作，尽管新用户常常认为有一个。与拨号公告板系统或基于网络的论坛不同，Usenet仅仅是通过站点之间的合作来运作的；没有负责人。因此，Usenet有时被称为无政府状态，但这并不准确。并不是说没有规则。参与系统的管理者负责做出政策决定，例如支持哪些新闻组。系统也有一定的独裁性质，只有某些人（通常是系统管理员）可以决定是否创建某些类型的新闻组。系统还有社会主义元素，即机器所有者被期望相互分享消息。因此，简化的政治标签实际上并不适用于Usenet。
- en: Every community has a *culture*, and the same is true of online communities,
    including Usenet. There is an overall culture that prescribes acceptable behavior
    on Usenet, and also thousands of newsgroup-specific cultures in Usenet, each of
    which has evolved through the writings of thousands of participants over the years.
    There are even newsgroups devoted to explaining how Usenet itself operates, where
    you can learn about *newbies* (new users), *netiquette* (rules of etiquette for
    posting messages), and related subjects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个社区都有一种*文化*，在线社区也是如此，包括Usenet。有一个整体文化规定了在Usenet上可接受的行为，还有成千上万的新闻组特定文化，这些文化在多年的参与者写作中逐渐发展起来。甚至还有专门解释Usenet本身如何运作的新闻组，在那里你可以了解*新手*（新用户）、*网络礼仪*（发布消息的礼仪规则）和相关主题。
- en: Usenet Transport Methods
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet传输方法
- en: As I said earlier, Usenet messages were originally transported using UUCP, which
    was created to let UNIX systems communicate directly, usually using telephone
    lines. For many years, all Usenet messages were simply sent from machine to machine
    using computerized telephone calls (just as email once was). Each computer joining
    the network would connect to one already on Usenet and receive a *feed* of messages
    from it periodically. The owner of that computer had to agree to provide messages
    to other computers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说的，Usenet消息最初是通过UUCP传输的，UUCP是为了让UNIX系统直接通信而创建的，通常使用电话线。多年来，所有Usenet消息都是通过计算机化的电话从一台机器发送到另一台机器（就像电子邮件曾经一样）。每个加入网络的计算机都会连接到已加入Usenet的计算机，并定期接收来自它的消息流。该计算机的所有者必须同意向其他计算机提供消息。
- en: Once TCP/IP was developed in the 1980s and the Internet grew to a substantial
    size and scope, it made sense to start using it to carry Usenet messages rather
    than UUCP. The *Network News Transfer Protocol (NNTP)* was developed specifically
    to describe the mechanism for communicating Usenet messages over the Transmission
    Control Protocol (TCP). It was formally defined in RFC 977, published in 1986,
    with NNTP extensions described in RFC 2980, published in October 2000.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪80年代开发TCP/IP以及互联网发展到一定规模和范围后，开始使用它来传递Usenet消息而不是UUCP是有意义的。*网络新闻传输协议（NNTP）*专门开发出来，用于描述在传输控制协议（TCP）上传递Usenet消息的机制。它于1986年正式定义在RFC
    977中发布，NNTP扩展在2000年10月发布的RFC 2980中描述。
- en: For many years, Usenet was carried using both NNTP and UUCP, but NNTP is now
    the mechanism used for the vast majority of Usenet traffic, and for this reason
    is the primary focus of my Usenet discussion. NNTP is employed not only to distribute
    Usenet articles to various servers, but also for other client actions, such as
    posting and reading messages. It is thus used for most of the steps in Usenet
    message communication.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Usenet使用NNTP和UUCP两种方式传递信息，但现在NNTP是用于绝大多数Usenet流量的机制，因此也是我讨论Usenet时的主要焦点。NNTP不仅用于将Usenet文章分发到各个服务器，还用于其他客户端操作，如发布和阅读消息。因此，它在Usenet消息通信的大部分步骤中都被使用。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Many people often equate the Usenet system as a whole with the NNTP protocol
    that is used to carry Usenet messages on the Internet. They are not the same however;
    Usenet predates NNTP, which is simply a protocol for conveying Usenet messages.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多人常常将整个Usenet系统等同于用于在互联网上传递Usenet消息的NNTP协议。然而，它们并不相同；Usenet早于NNTP，NNTP仅仅是一个用于传递Usenet消息的协议。*'
- en: It is because of the critical role of NNTP and the Internet in carrying messages
    in today's Usenet that the concepts are often confused. It's essential to remember,
    however, that Usenet does not refer to any type of physical network or internetworking
    technology; rather, it is a logical network of users. That logical network has
    evolved from UUCP data transfers to NNTP and TCP/IP, but Usenet itself is the
    same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为NNTP和互联网在当今Usenet中传递信息中的关键作用，这些概念常常被混淆。然而，记住这一点是至关重要的：Usenet并不指代任何类型的物理网络或互连技术；相反，它是一个用户的逻辑网络。这个逻辑网络已经从UUCP数据传输演变为NNTP和TCP/IP，但Usenet本身并没有改变。
- en: Today, Usenet faces competition from many other group messaging applications
    and protocols, including Web-based bulletin board systems and chat rooms. After
    a quarter of a century, however, Usenet has established itself and is used by
    millions of people every day. While to some, the primarily text-based medium seems
    archaic, it is a mainstay of global group communication and likely to continue
    to be so for many years to come.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Usenet面临着来自许多其他群组消息应用和协议的竞争，包括基于Web的公告板系统和聊天室。然而，经过25年的时间，Usenet已经确立了自己，并且每天都有数百万人在使用它。虽然对一些人来说，主要基于文本的媒介看起来过时，但它仍然是全球群组通信的主要支柱，并且在未来许多年里可能会继续如此。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** One of the very first online electronic communities was set
    up in 1979 by university students who wanted to keep in touch and share news and
    other information. Today, *Usenet (for User''s network)*, also called *network
    news*, has grown into a logical network that spans the globe. By posting messages
    to a Usenet newsgroup, people can share information on a variety of subjects of
    interest. Usenet was originally implemented in the form of direct connections
    established between participating hosts. Today, the Internet is the vehicle for
    message transport.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 最早的在线电子社区之一是在 1979 年由希望保持联系并分享新闻和其他信息的大学学生建立的。今天，*Usenet（用户网络）*，也称为
    *网络新闻*，已经发展成为一个覆盖全球的逻辑网络。通过在 Usenet 新闻组中发布消息，人们可以在各种感兴趣的主题上共享信息。Usenet 最初是以在参与主机之间建立直接连接的形式实现的。今天，互联网是消息传输的工具。'
- en: Usenet Communication Model
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Usenet 通信模型
- en: When the students at Duke University decided to create their online community,
    email was already in wide use, and there were many mailing lists in operation
    as well. Email was usually transported using UUCP—the same method that Usenet
    was designed to employ—during these pre-Internet days. Then why not simply use
    email to communicate between sites?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当杜克大学的学生决定创建他们的在线社区时，电子邮件已经被广泛使用，并且有许多邮件列表在运行。在这些互联网之前的年代，电子邮件通常使用 UUCP 传输——这是
    Usenet 设计要采用的方法。那么为什么不简单地使用电子邮件在站点之间进行通信呢？
- en: The main reason is that email is not designed to facilitate the creation of
    an online community where information can be easily shared in a group. The main
    issue with email in this respect is that only the individuals who are specified
    as recipients of a message can read it. There is no facility whereby someone can
    write a message and put it in an open place where anyone who wants to can read
    it, analogous to posting a newsletter in a public place.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是电子邮件并未设计用于促进创建一个可以轻松在群组中共享信息的在线社区。在这方面，电子邮件的主要问题是只有被指定为消息接收者的个人才能阅读它。没有一种设施可以让某人撰写消息并将其放置在公开的地方供任何人阅读，类似于在公共场所张贴通讯稿。
- en: Another problem with email in large groups is related to efficiency. Consider
    that if you put 1,000 people on a mailing list, each message sent to that list
    must be duplicated and delivered 1,000 times. Early networks were limited in bandwidth
    and resources, so using email for wide-scale group communication was possible,
    but far from ideal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型群组中，电子邮件的另一个问题与效率相关。考虑一下，如果你将 1,000 人列入邮件列表，发送给该列表的每条消息都必须复制并交付 1,000 次。早期的网络在带宽和资源方面有限，因此使用电子邮件进行大规模的群组通信是可能的，但远非理想。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** While email can be used for group communications, it has two
    important limitations. First, a message must be specifically addressed to each
    recipient, making public messaging impossible. Second, each recipient requires
    delivery of a separate copy of the message, so sending a message to many recipients
    requires the use of a large number of resources.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 虽然电子邮件可以用于群组通信，但它有两个重要的限制。首先，必须将消息专门发送给每个接收者，这使得公共消息传递变得不可能。其次，每个接收者都需要接收消息的单独副本，因此向多个接收者发送消息需要使用大量的资源。'
- en: Usenet's Public Distribution Orientation
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet 的公共分发导向
- en: 'To avoid the problems of using email for group messaging, Usenet was designed
    using a rather different communication and message-handling model than email.
    The defining difference between the Usenet communication model and that used for
    email is that Usenet message handling is oriented around the concept of *public
    distribution*, rather than private delivery to an individual user. This affects
    every aspect of how Usenet communication works, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用电子邮件进行群组消息传递的问题，Usenet 采用了一种与电子邮件截然不同的通信和消息处理模型。Usenet 通信模型与电子邮件模型之间的主要区别在于，Usenet
    的消息处理是以 *公共分发* 的概念为中心，而不是向单个用户进行私人投递。这影响了 Usenet 通信的各个方面，如下所述：
- en: '**Addressing** Messages are not addressed from a sender to any particular recipient
    or set of recipients, but rather to a *group*, which is identified with a newsgroup
    name.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址** 消息不是从发送者指向任何特定的接收者或接收者组，而是指向一个 *群组*，该群组与新闻组名称相对应。'
- en: '**Storage** Messages are not stored in individual mailboxes, but rather in
    a central location on a server, where any user of the server can access them.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储** 消息不是存储在个人邮箱中，而是在服务器上的一个中央位置，任何服务器用户都可以访问它们。'
- en: '**Delivery** Messages are not conveyed from the sender''s system to the recipient''s
    system, but rather are spread over the Internet to all connected systems so anyone
    can read them.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**交付** 消息并非从发送者的系统传递到接收者的系统，而是通过互联网传播到所有连接的系统，因此任何人都可以阅读它们。'
- en: Usenet Communication Process
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet 通信过程
- en: 'To help illustrate in more detail how Usenet communication works, let''s take
    a look at the steps involved in writing, transmitting, and reading a typical Usenet
    message (also called an *article*—the terms are used interchangeably). Let''s
    suppose the process begins with a user, Ellen, posting a request for help with
    a sick horse to the newsgroup misc.rural. Since she is posting the message, she
    would be known as the message *poster*. Simplified, the steps in the process (illustrated
    in [Figure 85-1](ch85s02.html#usenet_network_news_communication_model_ "Figure 85-1. Usenet
    (network news) communication model This figure illustrates the method by which
    messages are created, propagated, and read using NNTP on modern Usenet; it is
    similar in some respects to the email model diagram (Figure 74-1 in Chapter 74).
    In this example, a message is created by the poster, Ellen, and read by a reader,
    Jane. The process begins with Ellen creating a message in an editor and posting
    it. Her NNTP client sends it to her local NNTP server. It is then propagated from
    that local server to adjacent servers, usually including its upstream server,
    which is used to send the message around the Internet. Other NNTP servers receive
    the message, including the one upstream from Jane''s local server. It passes the
    message to Jane''s local server, and Jane accesses and reads the message using
    an NNTP client. Jane could respond to the message; in which case, the same process
    would repeat, but going in the opposite direction, back to Ellen (and also back
    to thousands of other readers, not shown here).")) are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更详细地说明 Usenet 通信的工作原理，让我们看看撰写、传输和阅读典型 Usenet 消息（也称为 *文章*——这两个术语可以互换使用）所涉及的步骤。假设这个过程从用户
    Ellen 在 newsgroup misc.rural 上发布一个关于生病的马匹求助请求开始。由于她是发布消息的人，因此她会被认为是消息的 *发布者*。简化地说，这个过程（如图
    [85-1](ch85s02.html#usenet_network_news_communication_model_ "图 85-1. Usenet (网络新闻)
    通信模型 此图说明了在现代 Usenet 上使用 NNTP 创建、传播和阅读消息的方法；在某些方面与第 74 章中的电子邮件模型图（图 74-1）相似。在这个例子中，消息由发布者
    Ellen 创建，并由读者 Jane 阅读。这个过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，该消息从本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他
    NNTP 服务器接收该消息，包括来自 Jane 本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并阅读该消息。Jane
    可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及成千上万的其他读者，此处未显示）") 的步骤如下：
- en: '**Article Composition** Ellen begins by creating a Usenet article, which is
    structured according to the special message format required by Usenet. This message
    is similar to an email message in that it has a *header* and a *body*. The body
    contains the actual message to be sent, while the header contains header lines
    that describe the message and control how it is delivered. For example, one important
    header line specifies for which newsgroup(s) the article is intended.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文章撰写** Ellen 首先创建一个 Usenet 文章，该文章的结构符合 Usenet 所需的特殊消息格式。这条消息与电子邮件消息类似，因为它有一个
    *标题* 和一个 *正文*。正文包含要发送的实际消息，而标题包含描述消息并控制其传递方式的标题行。例如，一条重要的标题行指定了文章针对哪个新闻组。'
- en: '**Article Posting and Local Storage** After completing her article, Ellen submits
    the article to Usenet, a process called *posting*. A client software program on
    Ellen''s computer transmits Ellen''s message to her local Usenet server. The message
    is stored in an appropriate file storage area on that server. It is now immediately
    available to all other users of that server who decide to read misc.rural.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文章发布和本地存储** 在完成她的文章后，Ellen 将文章提交到 Usenet，这个过程称为 *发布*。Ellen 电脑上的客户端软件程序将 Ellen
    的消息传输到她的本地 Usenet 服务器。该消息存储在该服务器上适当文件存储区域。现在，所有决定阅读 misc.rural 的该服务器用户都可以立即访问它。'
- en: '**Article Propagation** At this point, Ellen''s local server is the only one
    that has a copy of her message. The article must be sent to other sites, a process
    called *distribution*, or more commonly, *propagation*. Ellen''s message travels
    from her local Usenet server to other servers to which her server directly connects.
    It then propagates from those servers to others *they* connect to, and so on,
    until all Usenet servers that want it have a copy of the message.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文章传播** 到目前为止，Ellen 的本地服务器是唯一拥有她消息副本的服务器。文章必须发送到其他网站，这个过程称为 *分发*，或者更常见的是，*传播*。Ellen
    的消息从她的本地 Usenet 服务器传播到她直接连接的其他服务器。然后，这些服务器将其传播到它们连接的其他服务器，依此类推，直到所有想要该消息的 Usenet
    服务器都有其副本。'
- en: '**Article Access and Retrieval** Since Usenet articles are stored on central
    servers, in order to read them, they must be accessed on the server. This is done
    using a Usenet *newsreader* program. For example, some other reader of misc.rural
    named Jane might access that group and find Ellen''s message. If Jane were able
    to help Ellen, she could reply to Ellen by posting an article of her own. This
    would then propagate back to Ellen''s server, where she could read it and reply.
    All other readers of *misc.rural* could jump into the conversation at any time
    as well, which is what makes Usenet so useful for group communication.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文章访问和检索** 由于 Usenet 文章存储在中央服务器上，为了阅读它们，必须在服务器上访问。这通过使用 Usenet *新闻阅读器* 程序来完成。例如，名为
    Jane 的其他 misc.rural 阅读者可能会访问该组并找到 Ellen 的消息。如果 Jane 能够帮助 Ellen，她可以通过发布自己的文章来回复
    Ellen。这样，文章就会传播回 Ellen 的服务器，在那里她可以阅读并回复。所有其他 *misc.rural* 的读者也可以随时加入对话，这也是 Usenet
    对群体沟通非常有用的原因。'
- en: '![Usenet (network news) communication model This figure illustrates the method
    by which messages are created, propagated, and read using NNTP on modern Usenet;
    it is similar in some respects to the email model diagram ( in ). In this example,
    a message is created by the poster, Ellen, and read by a reader, Jane. The process
    begins with Ellen creating a message in an editor and posting it. Her NNTP client
    sends it to her local NNTP server. It is then propagated from that local server
    to adjacent servers, usually including its upstream server, which is used to send
    the message around the Internet. Other NNTP servers receive the message, including
    the one upstream from Jane''s local server. It passes the message to Jane''s local
    server, and Jane accesses and reads the message using an NNTP client. Jane could
    respond to the message; in which case, the same process would repeat, but going
    in the opposite direction, back to Ellen (and also back to thousands of other
    readers, not shown here).](httpatomoreillycomsourcenostarchimages288317.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Usenet (网络新闻) 通信模型 此图说明了使用现代 Usenet 上的 NNTP 创建、传播和读取消息的方法；在某些方面与电子邮件模型图（见
    ）相似。在这个例子中，消息是由发布者 Ellen 创建并由阅读者 Jane 读取的。这个过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地
    NNTP 服务器。然后，从该本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他 NNTP 服务器接收消息，包括 Jane
    本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并读取消息。Jane 可以回复消息；在这种情况下，相同的流程会重复，但方向相反，回到
    Ellen（以及也回到成千上万的其他读者，此处未显示）](http://atomoreilly.com/source/nostarch/images/288317.png.jpg)'
- en: 'Figure 85-1. Usenet (network news) communication model This figure illustrates
    the method by which messages are created, propagated, and read using NNTP on modern
    Usenet; it is similar in some respects to the email model diagram ([Figure 74-1](ch74s03.html#email_communication_model_this_diagram_s
    "Figure 74-1. Email communication model This diagram shows the four devices that
    are involved in a typical email communication between two users. Each device consists
    of a number of different elements, which communicate as indicated by the black
    arrows. Note the inherent asymmetry, because the method used to send an email
    from a user is not the same as that used to retrieve it from the server. The large,
    shaded arrows show a typical transaction: the sender composes mail and it goes
    to her local email spool. It is sent to the sender''s local SMTP server using
    SMTP, and then to the recipient''s SMTP server, where it goes into that user''s
    inbox. It is then retrieved, usually using a protocol such as POP or IMAP.") in
    [Chapter 74](ch74.html "Chapter 74. TCP/IP ELECTRONIC MAIL SYSTEM OVERVIEW AND
    CONCEPTS")). In this example, a message is created by the poster, Ellen, and read
    by a reader, Jane. The process begins with Ellen creating a message in an editor
    and posting it. Her NNTP client sends it to her local NNTP server. It is then
    propagated from that local server to adjacent servers, usually including its upstream
    server, which is used to send the message around the Internet. Other NNTP servers
    receive the message, including the one upstream from Jane''s local server. It
    passes the message to Jane''s local server, and Jane accesses and reads the message
    using an NNTP client. Jane could respond to the message; in which case, the same
    process would repeat, but going in the opposite direction, back to Ellen (and
    also back to thousands of other readers, not shown here).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图85-1. Usenet（网络新闻）通信模型 此图说明了在现代Usenet上使用NNTP创建、传播和读取消息的方法；在某些方面与第74章中的电子邮件模型图（[图74-1](ch74s03.html#email_communication_model_this_diagram_s
    "图74-1. 电子邮件通信模型 此图显示了两个用户之间典型电子邮件通信中涉及的四个设备。每个设备由多个不同元素组成，它们通过黑色箭头所示的方式进行通信。注意固有的不对称性，因为用户发送电子邮件的方法与从服务器检索它的方法不同。大阴影箭头显示了一个典型的交易：发送者编写邮件并将其发送到她的本地电子邮件队列。它使用SMTP发送到发送者的本地SMTP服务器，然后发送到接收者的SMTP服务器，进入该用户的收件箱。然后通过通常使用POP或IMAP等协议检索。")相似（[第74章](ch74.html
    "第74章. TCP/IP 电子邮件系统概述和概念"))。在这个例子中，消息是由发帖者Ellen创建并由读者Jane阅读的。这个过程从Ellen在编辑器中创建消息并发布开始。她的NNTP客户端将其发送到她的本地NNTP服务器。然后，该本地服务器将其传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到整个互联网。其他NNTP服务器接收该消息，包括来自Jane本地服务器的上游服务器。它将消息传递给Jane的本地服务器，Jane使用NNTP客户端访问并阅读该消息。Jane可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到Ellen（以及成千上万的其他读者，此处未显示）。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Usenet communication consists of four basic steps. A message
    is first composed and then posted to the originator''s local server. The third
    step is propagation, where the message is transmitted from its original server
    to others on the Usenet system. The last step in the process is article retrieval,
    where other members of the newsgroup access and read the article. The Network
    News Transfer Protocol (NNTP) is the technology used for moving Usenet articles
    from one host to the next.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Usenet通信包括四个基本步骤。首先，消息被编写并发布到发件人的本地服务器。第三步是传播，其中消息从原始服务器传输到Usenet系统上的其他服务器。过程的最后一步是文章检索，其中新闻组的其他成员访问并阅读该文章。网络新闻传输协议（NNTP）是用于将Usenet文章从一个主机移动到下一个主机的技术。'
- en: Message Propagation and Server Organization
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息传播与服务器组织
- en: Propagation is definitely the most complex part of the Usenet communication
    process. In the past, UUCP was used for propagation. Each Usenet server would
    be programmed to regularly dial up another server and give it all new articles
    it had received since the last connection. Articles would *flood* across Usenet
    from one server to another. This was time-consuming and inefficient, and it worked
    only because the volume of articles was relatively small.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 传播无疑是Usenet通信过程中最复杂的一部分。在过去，使用UUCP进行传播。每个Usenet服务器都会被编程为定期拨号连接到另一个服务器，并将自上次连接以来收到的所有新文章发送给它。文章会从一台服务器“泛滥”到另一台服务器。这既耗时又低效，而且之所以能工作，仅仅是因为文章的数量相对较少。
- en: As I noted in the previous section, in modern Usenet, NNTP is used for all stages
    of transporting messages between devices. Articles are posted using an NNTP connection
    between a client machine and a local server, which then uses the same protocol
    to propagate the articles to other adjacent NNTP servers. The client newsreader
    software also uses NNTP to retrieve messages from a server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一节中提到的，在现代Usenet中，NNTP用于设备之间传输消息的所有阶段。文章是通过客户端机器和本地服务器之间的NNTP连接发布的，然后本地服务器使用相同的协议将文章传播到其他相邻的NNTP服务器。客户端新闻阅读软件也使用NNTP从服务器检索消息。
- en: NNTP servers are usually arranged in a hierarchy of sorts, with the largest
    and fastest servers providing service to smaller servers downstream from them.
    Depending on how the connections are arranged, an NNTP server may establish a
    connection to immediately send a newly posted article to an upstream server for
    distribution to the rest of Usenet, or the server may passively wait for a connection
    from the upstream server to ask if there are any new articles to be sent. With
    the speed of the modern Internet, it typically takes only a few minutes (or seconds)
    for articles to propagate from one server to another, even across continents.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP服务器通常按照某种等级结构排列，最大的和最快的服务器为下游的较小服务器提供服务。根据连接的安排方式，一个NNTP服务器可能会立即与上游服务器建立连接，以便发送新发布的文章到其他Usenet服务器进行分发，或者服务器可能会被动等待上游服务器的连接来询问是否有新文章需要发送。在现代互联网的速度下，文章从一个服务器传播到另一个服务器通常只需要几分钟（或几秒钟），即使是在跨越大陆的情况下。
- en: It is also possible to restrict the propagation of a Usenet message, a technique
    often used for discussions that are of relevance only in certain regions or on
    certain systems. Discussing rural issues such as horses is of general interest,
    and Ellen might find help anywhere around the world, so global propagation of
    her message makes sense. However, if Ellen lived in the Boston area and was interested
    in knowing the location of a good local restaurant, posting a query to *ne.food*
    (New England food discussions) with only local distribution would make more sense.
    There are also companies that use Usenet to provide "in-house" newsgroups that
    are not propagated off the local server at all. However, because so many news
    providers are now national or international, limiting the distribution of messages
    has largely fallen out of practice.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以限制Usenet消息的传播，这是一种常用于仅在特定地区或系统上相关的讨论的技术。讨论农村问题，如马匹，具有普遍兴趣，Ellen可能在世界上任何地方都能找到帮助，因此她的消息的全球传播是有意义的。然而，如果Ellen住在波士顿地区，并且对了解一家好当地餐厅的位置感兴趣，那么只在本地区域发布查询到*ne.food*（新英格兰食品讨论）将更有意义。还有一些公司使用Usenet提供“内部”新闻组，这些新闻组根本不会从本地服务器传播出去。然而，由于现在许多新闻提供商都是全国性或国际性的，限制消息的传播在很大程度上已经不再流行。
- en: 'Usenet Addressing: Newsgroups'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet寻址：新闻组
- en: A key concept in Usenet communication is the *newsgroup*. Newsgroups are the
    addressing mechanism for Usenet, and sending a Usenet article to a newsgroup is
    equivalent to sending email to an email address. Newsgroups are analogous to other
    group communication venues such as mailing lists, chat rooms, Internet Relay Chat
    (IRC) channels, or bulletin board system (BBS) forums (though calling a newsgroup
    a *list*, *room*, *channel*, or *BBS* is likely to elicit a negative reaction
    from Usenet old-timers!).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet通信中的一个关键概念是*新闻组*。新闻组是Usenet的寻址机制，将Usenet文章发送到新闻组相当于将电子邮件发送到电子邮件地址。新闻组类似于其他群组通信场所，如邮件列表、聊天室、互联网中继聊天（IRC）频道或公告板系统（BBS）论坛（尽管将新闻组称为*列表*、*房间*、*频道*或*BBS*可能会引起Usenet老用户的负面反应！）。
- en: Like any addressing mechanism, newsgroups must be uniquely identifiable. Each
    newsgroup has a *newsgroup name* that describes the topic of the newsgroup and
    differentiates it from other newsgroups. Since there are many thousands of different
    newsgroups, they are arranged into sets called *hierarchies*. Each hierarchy contains
    a tree structure of related newsgroups.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何寻址机制一样，新闻组必须是唯一可识别的。每个新闻组都有一个*新闻组名称*，它描述了新闻组的话题并将其与其他新闻组区分开来。由于有数以千计的不同新闻组，它们被组织成称为*等级结构*的集合。每个等级结构包含一个相关新闻组的树状结构。
- en: The Usenet Newsgroup Hierarchies
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Usenet新闻组等级结构
- en: The total collection of newsgroup hierarchies is in many ways similar to the
    domain name tree structure used in the Domain Name System (DNS). Each Usenet hierarchy
    is like a collection of all the domain names within a DNS top-level domain. Just
    as a domain name like [www.pcguide.com](http://www.pcguide.com/) is formed by
    appending the label of the top-level domain *.com* to the second-level domain
    name *pcguide* and the subdomain *www*, newsgroup names are created in the same
    way. They are created from a top-level newsgroup hierarchy name, to which are
    attached a set of descriptive labels that describes the newsgroup's place in the
    hierarchy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 新sggroup 层级的总体集合在许多方面类似于域名系统（DNS）中使用的域名树结构。每个Usenet 层级就像DNS顶级域名内的所有域名的集合。就像域名
    [www.pcguide.com](http://www.pcguide.com/) 是通过将顶级域名标签 *.com* 添加到二级域名 *pcguide*
    和子域名 *www* 来形成的，新sggroup 名称也是以同样的方式创建的。它们是从顶级新sggroup 层级名称创建的，然后附加一组描述性标签，这些标签描述了新sggroup
    在层级中的位置。
- en: One difference between DNS and Usenet hierarchies is that while DNS names are
    created from right to left as you go down the tree, Usenet newsgroup names are
    formed in the more natural (for English speakers) left-to-right order. For example,
    one of the main Usenet hierarchies is the *comp* hierarchy, devoted to computer
    topics. Within comp is a subhierarchy on data communications called *dcom*, and
    within that is a group that discusses data cabling. This group is called comp.dcom.cabling.
    Almost all newsgroups are structured in this manner.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 和 Usenet 层级之间的一个区别是，虽然DNS 名称是从右到左创建的，但 Usenet 新sggroup 名称是以更自然的（对于英语使用者来说）从左到右的顺序创建的。例如，主要的
    Usenet 层级之一是 *comp* 层级，致力于计算机主题。在 comp 中有一个关于数据通信的子层级称为 *dcom*，在其中有一个讨论数据布线的组。这个组被称为
    comp.dcom.cabling。几乎所有的新sggroup 都是按照这种方式组织的。
- en: The "Big Eight" Newsgroup Hierarchies
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “八大”新sgroup 层级
- en: One problem with the decentralized nature of Usenet is ensuring coordination
    in certain areas where we want everyone to be on the same page, and one of these
    is newsgroup naming. If we let just anyone create a newsgroup, we might end up
    with many groups that all discuss the same topic. Imagine that someone had a question
    on data cabling and didn't realize that comp.dcom.cabling existed, so he created
    a new group called comp.datacomm.cabling. The two groups could coexist, but this
    would lead to both confusion and fragmenting of the pool of people interested
    in this topic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet 分散性质的一个问题是确保在某些我们希望每个人都处于同一页面的领域中的协调，其中之一就是新sgroup 命名。如果我们让任何人都可以创建新sgroup，我们可能会得到许多讨论相同主题的组。想象一下，如果有人对数据布线有疑问，但没有意识到
    comp.dcom.cabling 存在，所以他创建了一个名为 comp.datacomm.cabling 的新组。这两个组可以共存，但这会导致对这个主题感兴趣的人群的混淆和碎片化。
- en: To avoid problems with newsgroup creation, administrators of large Usenet systems
    collaborated on a system for organizing many of the more commonly used Usenet
    groups into eight hierarchies, and devised a specific procedure for creating new
    newsgroups within them. Today, these are called the *Big Eight* Usenet hierarchies,
    which are summarized in [Table 85-1](ch85s02.html#usenet_big_eight_newsgroup_hierarchies
    "Table 85-1. Usenet Big Eight Newsgroup Hierarchies").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免新sggroup 创建的问题，大型Usenet 系统的管理员合作制定了一个系统，将许多常用的Usenet 组组织成八个层级，并制定了一个在它们内部创建新新sggroup
    的特定程序。今天，这些被称为 *Big Eight* Usenet 层级，总结在 [表85-1](ch85s02.html#usenet_big_eight_newsgroup_hierarchies
    "表85-1. Usenet 八大新sgroup 层级") 中。
- en: Table 85-1. Usenet Big Eight Newsgroup Hierarchies
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 表85-1. Usenet 八大新sgroup 层级
- en: '| Hierarchy | Description |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Hierarchy | 描述 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| comp.* | Newsgroups discussing computer-related topics, including hardware,
    software, operating systems, and techniques |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| comp.* | 讨论与计算机相关主题的新sggroup，包括硬件、软件、操作系统和技术 |'
- en: '| humanities.* | Newsgroups discussing the humanities, such as literature and
    art |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| humanities.* | 讨论人文学科的新sgroup，例如文学和艺术 |'
- en: '| misc.* | Newsgroups discussing miscellaneous topics that don''t fit into
    other Big Eight hierarchies |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| misc.* | 讨论不适合其他八大类别的杂项主题的新sgroup |'
- en: '| news.* | Newsgroups discussing Usenet itself and its administration |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| news.* | 讨论Usenet 本身及其管理的新sgroup |'
- en: '| rec.* | Newsgroups discussing recreation topics, such as games, sports, and
    activities |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| rec.* | 讨论休闲主题的新sgroup，例如游戏、体育和活动 |'
- en: '| sci.* | Science newsgroups, covering specific areas such as physics and chemistry,
    research topics, and so forth |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| sci.* | 科学新sgroup，涵盖特定领域，如物理学和化学，研究主题等 |'
- en: '| soc.* | Society and social discussions, including groups on specific cultures
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| soc.* | 社会和社会讨论，包括特定文化的组 |'
- en: '| talk.* | Newsgroups primarily oriented around discussion and debate of current
    events and happenings |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| talk.* | 主要围绕当前事件和事件讨论和辩论的新闻组 |'
- en: These eight hierarchies contain many of the most widely used groups on Usenet
    today. For example, professional baseball is discussed in rec.sport.baseball,
    Intel computers in comp.sys.intel, and Middle East politics in talk.politics.mideast.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这八个层级包含了 Usenet 上今天使用最广泛的许多组。例如，职业棒球在 rec.sport.baseball 中讨论，英特尔电脑在 comp.sys.intel
    中讨论，中东政治在 talk.politics.mideast 中讨论。
- en: The Big Eight hierarchies are rather tightly controlled in terms of their structure
    and the newsgroups they contain. The process to create a new Big Eight newsgroup
    is democratic and open. Anyone can propose a new group, and if there is enough
    support, it will be created by the cooperating system administrators who agree
    to follow the Big Eight system. However, this creation process is rather complex
    and time-consuming. Some people find this unacceptable and even object to the
    entire concept of this restricted process. Others consider the system advantageous,
    as it keeps the Big Eight hierarchies relatively orderly by slowing the rate of
    change to existing newsgroups and the number of new groups added.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大八层级在结构和包含的新闻组方面控制得相当严格。创建一个新的大八新闻组的过程是民主和开放的。任何人都可以提议一个新的组，如果有足够的支持，它将由同意遵循大八系统的合作系统管理员创建。然而，这个过程相当复杂且耗时。有些人认为这是不可接受的，甚至反对整个限制性过程的观念。其他人认为这个系统有利，因为它通过减缓现有新闻组和新增组数量的变化速度，使大八层级相对有序。
- en: Alt and Other Newsgroup Hierarchies
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alt 和其他新闻组层级
- en: For those who prefer a more freewheeling environment and do not want to submit
    to the Big Eight procedures, there is an alternative Usenet hierarchy, which begins
    with the hierarchy name *alt*. This hierarchy includes many thousands of groups.
    Some are quite popular, but many are not used at all; this is a side effect of
    the relative ease with which an alt group can be created.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些更喜欢更自由的环境，并且不想服从大八程序的人来说，有一个替代的 Usenet 层级，它以层级名称 *alt* 开头。这个层级包括成千上万的组。其中一些相当受欢迎，但许多根本未被使用；这是
    alt 组创建相对容易的副作用。
- en: In addition to these nine hierarchies, there are dozens of additional, smaller
    hierarchies. Many of these are regional or even company-specific. For example,
    the *ne.* hierarchy contains a set of newsgroups discussing issues of relevance
    to New England; *fr.** covers France, and *de.** pertains to Germany. Microsoft
    has its own set of public newsgroups in the *microsoft.** hierarchy. [Figure 85-2](ch85s02.html#usenet_newsgroup_hierarchies_usenet_news
    "Figure 85-2. Usenet newsgroup hierarchies Usenet newsgroups are arranged into
    tree-like structures called hierarchies. Eight of these are centralized, widely
    used, general-purpose hierarchies, which are today called the Big Eight. The alternate
    (alt) hierarchy is a very loosely structured set of thousands of groups covering
    every topic imaginable. In addition to these, there are many hundreds of regional,
    private, and special-purpose hierarchies.") shows the Big Eight hierarchies and
    some of the other hierarchies that exist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这九个层级之外，还有数十个额外的、较小的层级。其中许多是地区性的，甚至是公司特定的。例如，*ne.* 层级包含了一组讨论与新英格兰相关问题的新闻组；*fr.*
    覆盖法国，而 *de.* 则与德国相关。微软在其 *microsoft.** 层级下有自己的公共新闻组。[图 85-2](ch85s02.html#usenet_newsgroup_hierarchies_usenet_news
    "图 85-2. Usenet 新闻组层级 Usenet 新闻组被组织成称为层级的树状结构。其中八个是集中式、广泛使用的通用层级，今天被称为大八。Alt 层级是一个结构非常松散的数千个组集合，覆盖了所有可想象的主题。除此之外，还有许多地区性、私人性和特殊用途的层级。")
    展示了大八层级和一些其他存在的层级。
- en: '![Usenet newsgroup hierarchies Usenet newsgroups are arranged into tree-like
    structures called hierarchies. Eight of these are centralized, widely used, general-purpose
    hierarchies, which are today called the Big Eight. The alternate (alt) hierarchy
    is a very loosely structured set of thousands of groups covering every topic imaginable.
    In addition to these, there are many hundreds of regional, private, and special-purpose
    hierarchies.](httpatomoreillycomsourcenostarchimages288319.png.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Usenet 新闻组层次结构 Usenet 新闻组被组织成称为层次结构的树状结构。其中八个是集中式、广泛使用的通用层次结构，今天被称为“八大”。替代（alt）层次结构是一组非常松散的结构，包含数千个覆盖所有可想象话题的组。除此之外，还有许多地区性、私人性和特殊用途的层次结构。](httpatomoreillycomsourcenostarchimages288319.png.jpg)'
- en: Figure 85-2. Usenet newsgroup hierarchies Usenet newsgroups are arranged into
    tree-like structures called hierarchies. Eight of these are centralized, widely
    used, general-purpose hierarchies, which are today called the Big Eight. The alternate
    (alt) hierarchy is a very loosely structured set of thousands of groups covering
    every topic imaginable. In addition to these, there are many hundreds of regional,
    private, and special-purpose hierarchies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 85-2. Usenet 新闻组层次结构 Usenet 新闻组被组织成称为层次结构的树状结构。其中八个是集中式、广泛使用的通用层次结构，今天被称为“八大”。替代（alt）层次结构是一组非常松散的结构，包含数千个覆盖所有可想象话题的组。除此之外，还有许多地区性、私人性和特殊用途的层次结构。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Usenet messages are not addressed to individual users; rather,
    they are posted to newsgroups. Each newsgroup represents a topic. Those with an
    interest in the subject of a group can read messages in it and reply to them as
    well. Usenet newsgroups are arranged into tree-like hierarchies that are similar
    in structure to DNS domains. Many of the most widely used newsgroups are found
    in a collection of general-interest hierarchies called the Big Eight. An alternate
    (alt) hierarchy offers an alternative to the Big Eight. There are also many regional
    and special-purpose hierarchies.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Usenet 消息不是针对单个用户的；相反，它们被发布到新闻组。每个新闻组代表一个主题。对组中主题感兴趣的人可以阅读其中的消息并回复它们。Usenet
    新闻组被组织成类似 DNS 域结构的树状层次结构。许多最广泛使用的新闻组都位于一个名为“八大”的通用兴趣层次结构集合中。替代（alt）层次结构为“八大”提供了一个替代方案。还有许多地区性和特殊用途的层次结构。'
- en: Unmoderated and Moderated Newsgroups
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未监管和监管新闻组
- en: Most newsgroups are open to all to use and are called *unmoderated* because
    a message sent to them goes directly out to the whole Usenet server internetwork.
    In contrast, a small percentage of newsgroups is *moderated*, which means that
    all messages sent to the group are screened and only the ones that are approved
    by a moderator (or moderator team) are really posted.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新闻组对所有用户开放，被称为 *未监管*，因为发送给它们的消息会直接发送到整个 Usenet 服务器互联网。相比之下，只有一小部分新闻组是 *监管*
    的，这意味着发送给组的所有消息都会被筛选，只有经过版主（或版主团队）批准的消息才会真正发布。
- en: The purpose of moderated groups is to ensure that discussions in a particular
    group remain on-topic. They are often created to handle topics that are controversial,
    to ensure that debates remain constructive and disruption is avoided. For example,
    rec.guns is moderated to ensure that discussions focus on the use of guns and
    not on endless political arguments related to gun control and the like (which
    has a place, in talk.politics.guns). Moderated groups are also sometimes used
    for specialty groups intended only for announcements, or for groups where the
    content is restricted. For example, rec.food.recipes is moderated so that it contains
    only recipes and recipe requests, which helps people find recipes easily without
    needing to wade through a lot of discussion. Finally, moderated versions of unmoderated
    groups are sometimes created when a few disruptive elements choose to post large
    volumes in the unmoderated groups, making normal discussion difficult.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 监管组的目的是确保特定组内的讨论保持主题相关。它们通常被创建来处理有争议的话题，以确保辩论保持建设性，避免破坏。例如，rec.guns 是监管的，以确保讨论集中在枪支的使用上，而不是无休止地围绕枪支控制等政治争论（这在
    talk.politics.guns 中有位置）。监管组有时也用于仅用于公告的专业组，或内容受限的组。例如，rec.food.recipes 是监管的，这样它就只包含食谱和食谱请求，这有助于人们轻松找到食谱，而无需浏览大量讨论。最后，当一些破坏性元素选择在未监管的新闻组中发布大量内容，使得正常讨论变得困难时，有时会创建未监管组的监管版本。
- en: Cross-Posting to Multiple Newsgroups
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个新闻组中交叉发布
- en: It is possible for a single article to be posted to multiple newsgroups. This
    process, called *cross-posting*, is used when a message pertains to two topics,
    or to allow a sender to reach a wider audience. For example, if you live in the
    Seattle area and have a problem with your house, you might legitimately cross-post
    to *seattle.general* and *misc.consumers.house*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇文章可以发布到多个新闻组。这个过程称为*跨发帖*，当一条消息涉及两个主题或允许发送者触及更广泛的受众时使用。例如，如果你住在西雅图地区，并且你的房子有问题，你可能会合法地跨发帖到*seattle.general*和*misc.consumers.house*。
- en: 'Cross-posting is more efficient than posting the same message to each group
    independently for two reasons:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 跨发帖比独立向每个组发送相同消息更有效率，原因有两个：
- en: Only one copy of the message will be stored on each Usenet server rather than
    two.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Usenet服务器上只会存储消息的一个副本，而不是两个。
- en: Usenet participants who happen to read both groups won't see the message twice.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时阅读这两个组的Usenet参与者不会看到消息两次。
- en: However, cross-posting to very large numbers of newsgroups is usually considered
    disruptive and a breach of Usenet etiquette.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，向大量新闻组进行跨发帖通常被认为是有破坏性的，并且违反了Usenet礼仪。
- en: Usenet Message Format and Special Headers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Usenet消息格式和特殊标题
- en: Usenet is designed to permit users to exchange information in the form of messages
    that are sent from one computer to another. As is necessary with any message-based
    networking application, all Usenet client software and server software agree to
    use a common *message format*. This ensures that all devices and programs are
    able to interpret all Usenet articles in a consistent manner.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet被设计成允许用户以消息的形式交换信息，这些消息是从一台计算机发送到另一台计算机的。与任何基于消息的网络应用程序一样，所有Usenet客户端软件和服务器软件都同意使用一个共同的*消息格式*。这确保了所有设备和程序都能以一致的方式解释所有Usenet文章。
- en: 'While Usenet was created as an alternative to email, and there are obviously
    differences in how each treats messages, there are also many similarities. Both
    are text-oriented messaging systems with similar needs for communicating content
    and control information. The creators of Usenet realized that there would be many
    advantages to basing the Usenet message format on the one used for email, rather
    than creating a new format from scratch. The email message format was already
    widely used, and adopting it for Usenet would save implementation time and effort.
    It would also enhance compatibility between email and Usenet messages, allowing
    software designed to process or display email to also work with Usenet articles.
    For this reason, the Usenet message format was defined based on the RFC 822 standard
    for email messages (introduced in [Chapter 76](ch76.html "Chapter 76. TCP/IP ELECTRONIC
    MAIL MESSAGE FORMATS AND MESSAGE PROCESSING: RFC 822 AND MIME")).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Usenet最初被创建为电子邮件的替代品，并且显然在处理消息的方式上存在差异，但也有许多相似之处。两者都是面向文本的消息系统，具有类似的内容和控件信息沟通需求。Usenet的创建者意识到，基于电子邮件格式而不是从头开始创建新格式，将Usenet消息格式建立在电子邮件格式上会有许多优势。电子邮件消息格式已经被广泛使用，为Usenet采用它将节省实施时间和精力。它还将增强电子邮件和Usenet消息之间的兼容性，使得设计用于处理或显示电子邮件的软件也能与Usenet文章一起工作。因此，Usenet消息格式是基于电子邮件消息的RFC
    822标准定义的（在[第76章](ch76.html "第76章。TCP/IP 电子邮件消息格式和消息处理：RFC 822 和 MIME")中介绍）。
- en: RFC 822 messages begin with a set of *headers* that contain control and descriptive
    information about the message, followed by a blank line and then the message *body*,
    which contains the actual content.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 822消息以一组*标题*开始，包含有关消息的控制和描述性信息，然后是一个空行，接着是消息的*主体*，其中包含实际内容。
- en: One important attribute of the RFC 822 standard is the ability to define custom
    headers that add to the regular set of headers defined in the standard itself.
    Usenet articles require some types of information not needed by email, and these
    can be included in specially defined headers while still adhering to the basic
    RFC 822 format. At the same time, headers specific to email that are not needed
    for Usenet can be omitted. Thus, there is no structural difference at all between
    a Usenet article and an email message. They differ only in the kinds of headers
    they contain and the values for those headers. For example, a Usenet message will
    always contain a header specifying the newsgroup(s) to which the article is being
    posted, but will not carry a "To:" line as an email message would.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 822 标准的一个重要属性是能够定义自定义标题，这些标题补充了标准本身定义的常规标题集。Usenet 文章需要一些电子邮件不需要的信息，这些信息可以通过特别定义的标题包含在内，同时仍然遵循基本的
    RFC 822 格式。同时，对于 Usenet 不需要的特定于电子邮件的标题可以省略。因此，Usenet 文章和电子邮件消息之间没有任何结构上的差异。它们之间的区别仅在于包含的标题类型和这些标题的值。例如，Usenet
    消息将始终包含一个指定文章要发布的新闻组的标题，但不会像电子邮件消息那样带有“收件人：”行。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Usenet articles use the same RFC 822 message format as email
    messages. The only difference between a Usenet article and an email message is
    in the header types and values used in each.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Usenet 文章使用与电子邮件消息相同的 RFC 822 消息格式。Usenet 文章和电子邮件消息之间的唯一区别在于每个中使用的标题类型和值。'
- en: Usenet Header Categories and Common Headers
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet 标题分类和常见标题
- en: 'All Usenet headers are defined according to the standard header format specified
    in RFC 822: <*header name*>: <*header value*>. As with email messages, headers
    may extend onto multiple lines, following the indenting procedure described in
    the RFC 822 standard.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '所有 Usenet 标题都是根据 RFC 822 标准中指定的标准标题格式定义的：<*标题名称*>: <*标题值*>。与电子邮件消息一样，标题可以扩展到多行，按照
    RFC 822 标准中描述的缩进程序进行。'
- en: 'The current standard for Usenet messages, RFC 1036, describes the header types
    for Usenet messages. The headers are divided into two categories: *mandatory*
    headers (see [Table 85-2](ch85s03.html#usenet_mandatory_headers "Table 85-2. Usenet
    Mandatory Headers")) and *optional* headers (see [Table 85-3](ch85s03.html#usenet_optional_headers
    "Table 85-3. Usenet Optional Headers")). Some are the same as headers of the equivalent
    name used for email, some are similar to email headers but used in a slightly
    different way, and others are unique to Usenet.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当前 Usenet 消息标准，RFC 1036，描述了 Usenet 消息的标题类型。标题分为两类：*强制性标题*（见[表 85-2](ch85s03.html#usenet_mandatory_headers
    "表 85-2. Usenet 强制性标题"））和*可选性标题*（见[表 85-3](ch85s03.html#usenet_optional_headers
    "表 85-3. Usenet 可选性标题"））。一些与用于电子邮件的等效名称的标题相同，一些与电子邮件标题类似但使用方式略有不同，还有一些是 Usenet
    独有的。
- en: Table 85-2. Usenet Mandatory Headers
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-2. Usenet 强制性标题
- en: '| Header Name | Description |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 标题名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| From: | The email address of the user sending the message, as for email.
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| From: | 发送消息的用户电子邮件地址，类似于电子邮件。|'
- en: '| Date: | The date and time that the message was originally posted to Usenet.
    This is usually the date/time that the user submitted the article to his or her
    local NNTP server. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| Date: | 消息最初发布到 Usenet 的日期和时间。这通常是用户将其文章提交到其本地 NNTP 服务器的日期和时间。|'
- en: '| Newsgroups: | Indicates the newsgroup or set of newsgroups to which the message
    is being posted. Multiple newsgroups are specified by separating them with a comma;
    for example: Newsgroups: news.onegroup,rec.secondgroup. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| Newsgroups: | 指示消息要发布的新闻组或新闻组集合。通过逗号分隔多个新闻组；例如：Newsgroups: news.onegroup,rec.secondgroup。|'
- en: '| Subject: | Describes the subject or topic of the message. Note that this
    header is mandatory on Usenet despite being optional for email; it is important
    because it is used by readers to decide what messages to open. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Subject: | 描述消息的主题或话题。请注意，尽管在电子邮件中此标题是可选的，但在 Usenet 中却是强制性的；它很重要，因为读者会根据它来决定打开哪些消息。|'
- en: '| Message-ID: | Provides a unique code for identifying a message; normally
    generated when a message is sent. The message ID is very important in Usenet,
    arguably more so than in email. The reason is that delivery of email is performed
    based on recipient email addresses, while the propagation of Usenet messages is
    controlled using the message ID header. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Message-ID: | 为识别消息提供唯一代码；通常在发送消息时生成。在 Usenet 中，消息 ID 非常重要，可以说比电子邮件更重要。原因是电子邮件的投递是基于收件人电子邮件地址进行的，而
    Usenet 消息的传播则是通过使用消息 ID 标头来控制的。|'
- en: '| Path: | An informational field that shows the path of servers that a particular
    copy of a message followed to get to the server where it is being read. Each time
    a server forwards a Usenet article, it adds its own name to the list in the Path
    header. The entries are usually separated by exclamation points. For example,
    if a user on Usenet Server A posts a message, and it is transported from Server
    A to Server G, then Server X, then Server F, and finally to Server Q, where a
    second user reads it, the person on Server Q would see something like this in
    the Path header: "Q!F!X!G!A." |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 路径: | 这是一个信息字段，显示特定消息副本到达正在阅读的服务器所经过的服务器路径。每次服务器转发 Usenet 文章时，都会将其自己的名称添加到路径标题中的列表中。条目通常由感叹号分隔。例如，如果
    Usenet 服务器 A 上的用户发布一条消息，并且它从服务器 A 传输到服务器 G，然后是服务器 X，然后是服务器 F，最后到达服务器 Q，在那里第二个用户阅读它，服务器
    Q 上的用户会在路径标题中看到类似以下内容："Q!F!X!G!A。" |'
- en: Table 85-3. Usenet Optional Headers
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-3. Usenet 可选标题
- en: '| Header Name | Description |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 标题名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Reply-To: | It is possible to reply back to a Usenet article author using
    email, which by default, goes to the address in the From: line. If this header
    is present, the address it contains is used instead of the default From: address.
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 回复至: | 可以使用电子邮件回复 Usenet 文章作者，默认情况下，回复会发送到“发件人:”行中的地址。如果存在此标题，则使用其中包含的地址代替默认的“发件人:”地址。
    |'
- en: '| Sender: | Indicates the email address of the user who is sending the message,
    if different from the message originator. This is functionally the same as the
    Sender: header in email messages, but is used in a slightly different way. Normally,
    when a Usenet message is posted, the sender''s email address is automatically
    filled in to the From: line. If the user manually specifies a different From:
    line, the address from which the message was actually sent is usually included
    in the Sender: line. This is used to track the true originating point of articles.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 发件人: | 如果与消息发起者不同，则表示发送消息的用户的电子邮件地址。这在功能上与电子邮件消息中的“发件人:”标题相同，但使用方式略有不同。通常，当在
    Usenet 上发布消息时，发送者的电子邮件地址会自动填写到“发件人:”行。如果用户手动指定不同的“发件人:”行，则通常会在“发件人:”行中包含实际发送消息的地址。这用于跟踪文章的真实起始点。
    |'
- en: '| Followup-To: | A reply to a Usenet message is usually made back to Usenet
    itself and is called a follow-up. By default, a follow-up goes to the newsgroup(s)
    specified in the original message''s Newsgroups: header. However, if the Followup-To:
    header is included, follow-ups to that message go to the newsgroups specified
    in the Followup-To: header instead. This header is sometimes used to route replies
    to a message to a particular group. Note, however, that when a user replies to
    a message, this field controls only what appears in the new message''s Newsgroups:
    line by default. The user can override the Newsgroups: header manually. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 跟进至: | 对 Usenet 消息的回复通常发送回 Usenet 本身，这被称为跟进。默认情况下，跟进会发送到原始消息中指定的新闻组“Newsgroups:”标题中。然而，如果包含“跟进至:”标题，则该消息的跟进会发送到“跟进至:”标题中指定的新闻组。有时使用此标题将回复路由到特定的组。请注意，当用户回复消息时，此字段默认控制新消息的“Newsgroups:”行中显示的内容。用户可以手动覆盖“Newsgroups:”标题。
    |'
- en: '| Expires: | All Usenet messages are maintained on each server for only a certain
    period of time, due to storage limitations. The expiration interval for each newsgroup
    is controlled by the administrator of each site. If present, this line requests
    a different expiration for a particular message; it is usually used only for special
    articles. For example, if a weekly announcement is posted every Monday morning,
    each article might be set to expire the following Monday morning, to make sure
    that people see the most current version. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 过期时间: | 由于存储限制，所有 Usenet 消息在每个服务器上仅保留一定时间。每个新闻组的过期间隔由每个站点的管理员控制。如果存在，此行请求对特定消息的不同过期时间；通常仅用于特殊文章。例如，如果每周公告每周一早上发布，则每篇文章可能被设置为在下一个周一早上过期，以确保人们看到最新版本。
    |'
- en: '| References: | Lists the message IDs of prior messages in a conversation.
    For example, if someone posts a question to a newsgroup with message ID AA207,
    and a reply to that message is made, the software will automatically insert the
    line "References: AA207" into the reply. This is used by software to group together
    articles into conversations (called *threads*) to make it easier to follow discussions
    on busy newsgroups. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 参考： | 列出对话中先前消息的消息ID。例如，如果有人向新闻组发布了一个消息ID为AA207的问题，并对该消息进行了回复，软件将自动在回复中插入“参考：AA207”这一行。这被软件用来将文章分组到对话中（称为
    *线程*），以便更容易地跟踪繁忙新闻组上的讨论。 |'
- en: '| Control: | Indicates that the article is a control message and specifies
    a control action to be performed, such as creating a new newsgroup. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 控制： | 表示文章是一个控制消息，并指定要执行的控制操作，例如创建一个新的新闻组。 |'
- en: '| Distribution: | By default, most messages are propagated on Usenet worldwide.
    If specified, this line restricts the distribution of a message to a smaller area,
    either geographical or organizational. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 分发： | 默认情况下，大多数消息在全球Usenet上传播。如果指定，此行将限制消息的传播范围到一个较小的区域，无论是地理上的还是组织上的。 |'
- en: '| Organization: | Describes the organization to which the article sender belongs.
    Often filled in automatically with the name of the user''s Internet service provider
    (ISP). |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 组织： | 描述文章发送者所属的组织。通常自动填充为用户的互联网服务提供商（ISP）的名称。 |'
- en: '| Keywords: | Contains a list of comma-separated keywords that may be of use
    to the readers of the message. Keywords can be useful when searching for messages
    on a particular subject matter. This header is not often used. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 关键词： | 包含一个逗号分隔的关键词列表，这些关键词可能对消息的读者有用。关键词在搜索特定主题的消息时可能很有用。这个标题不常用。 |'
- en: '| Summary: | A short summary of the message. This is rarely used in practice.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 摘要： | 消息的简要总结。在实际应用中很少使用。 |'
- en: '| Approved: | Added by the moderator of a moderated newsgroup to tell the Usenet
    software that the message has been approved for posting. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 批准： | 由受管理的新闻组的版主添加，以告知Usenet软件该消息已被批准发布。 |'
- en: '| Lines: | A count of the number of lines in the message. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 行数： | 消息中的行数统计。 |'
- en: '| Xref: | While Usenet articles are identified by message ID, they are also
    given a number by each Usenet server as they are received. These article numbers,
    which differ from one system to the next, are usually listed in this cross-reference
    header. This information is used when a message is cross-posted to multiple groups.
    In that case, as soon as a user reads the message in one group, it is marked as
    having been read in all the others where it was posted. This way, if the user
    later reads one of those other groups, that user will not see the message again.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Xref： | 虽然Usenet文章通过消息ID进行标识，但每个Usenet服务器在接收时也会给它们分配一个编号。这些文章编号因系统而异，通常列在这个交叉引用标题中。当消息被跨发到多个组时，将使用这些信息。在这种情况下，一旦用户在一个组中阅读了消息，它就会在所有其他已发布的组中被标记为已读。这样，如果用户稍后阅读了这些其他组中的一个，该用户将不会再次看到该消息。
    |'
- en: Additional Usenet Headers
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加Usenet标题
- en: Usenet messages may also contain additional headers, just as is the case with
    email messages. Some of these are custom headers included by individual users
    to provide extra information about an article. Others are used in many current
    Usenet articles and have become almost de facto standard headers through common
    use. Many of these custom headers are preceded by *X-*, indicating that they are
    experimental or extra headers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet消息也可能包含额外的标题，就像电子邮件消息一样。其中一些是个人用户添加的定制标题，以提供有关文章的额外信息。其他一些在许多当前的Usenet文章中使用，并且由于普遍使用而成为事实上的标准标题。许多这些定制标题都以前缀
    *X-* 开头，表明它们是实验性的或额外的标题。
- en: Some of the more frequently encountered additional Usenet headers are shown
    in [Table 85-4](ch85s03.html#common_additional_usenet_headers "Table 85-4. Common
    Additional Usenet Headers").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更常见的附加Usenet标题显示在[表 85-4](ch85s03.html#common_additional_usenet_headers "表 85-4. 常见的附加Usenet标题")中。
- en: Table 85-4. Common Additional Usenet Headers
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-4. 常见的附加Usenet标题
- en: '| Header Name | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 标题名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| NNTP-Posting-Host: | Specifies the IP address or the DNS domain name of the
    host used to originally post the message. This is usually either the address of
    the client that the author used for posting the message or the sender''s local
    NNTP server. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| NNTP-Posting-Host: | 指定最初发布消息的主机的IP地址或DNS域名。这通常是作者用于发布消息的客户端地址或发送者的本地NNTP服务器。|'
- en: '| User-Agent: (or) X-Newsreader: | The name and version number of the software
    used to post the message. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| User-Agent: (或) X-Newsreader: | 用于发布消息的软件的名称和版本号。|'
- en: '| X-Trace: | Provides additional information that can be used to trace the
    message. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| X-Trace: | 提供可用于跟踪消息的附加信息。|'
- en: '| X-Complaints-To: | An email address to use to report abusive messages. This
    header is now included automatically by many ISPs. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| X-Complaints-To: | 用于报告滥用信息的电子邮件地址。此标题现在由许多ISP自动包含。|'
- en: Usenet MIME Messages
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet MIME消息
- en: Since Usenet follows the RFC 822 standard, Multipurpose Internet Mail Extensions
    (MIME) can be used to format Usenet messages. When this is done, you will see
    the usual MIME headers (such as MIME-Version, Content-Type, and so forth) in the
    message.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Usenet遵循RFC 822标准，多用途互联网邮件扩展（MIME）可以用于格式化Usenet消息。当这样做时，您将在消息中看到通常的MIME标题（如MIME-Version、Content-Type等）。
- en: Note that the use of MIME in Usenet messages is somewhat controversial. Some
    newsreaders are not MIME-compliant and make a mess when trying to display some
    of these messages, and many Usenet veterans object to the use of anything but
    plain text in Usenet messages. Despite this, MIME messages are becoming more common,
    for better or worse.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Usenet消息中使用MIME存在一些争议。一些新闻阅读器不遵守MIME规范，在尝试显示这些消息时会变得混乱，许多Usenet老手反对在Usenet消息中使用除纯文本之外的内容。尽管如此，MIME消息正在变得越来越普遍，无论是好是坏。
- en: NNTP Overview and General Operation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NNTP概述和一般操作
- en: As I explained earlier in this chapter, Usenet started out as an informal network
    of UNIX computers using dial-up UUCP connections to transmit messages between
    servers. This arrangement arose out of necessity, and it worked fairly well, though
    it had a number of problems. Once the Internet became widely used in the 1980s,
    it provided the ideal opportunity for a more efficient means of distributing Usenet
    articles. NNTP was developed as a special TCP/IP protocol for sending these messages.
    Now NNTP carries billions of copies of Usenet messages from computer to computer
    every day.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章前面解释的那样，Usenet最初是一个非正式的UNIX计算机网络，使用拨号UUCP连接在服务器之间传输消息。这种安排是出于必要性，并且工作相当不错，尽管它存在一些问题。20世纪80年代，随着互联网的广泛使用，它为更有效地分发Usenet文章提供了理想的机会。NNTP被开发为一种特殊的TCP/IP协议，用于发送这些消息。现在，NNTP每天从一台计算机传输数十亿份Usenet消息到另一台计算机。
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**BACKGROUND INFORMATION** *NNTP is similar to the Simple Mail Transfer Protocol
    (SMTP) in many ways, including its basic operation and command set and reply format.
    You may find the information about NNTP easier to understand if you are familiar
    with SMTP, covered in [Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC MAIL
    DELIVERY PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)").*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *NNTP在许多方面与简单邮件传输协议（SMTP）相似，包括其基本操作、命令集和回复格式。如果您熟悉SMTP，可能会发现NNTP的信息更容易理解，SMTP在[第77章](ch77.html
    "第77章。TCP/IP 电子邮件投递协议：简单邮件传输协议 (SMTP)")中有介绍。*'
- en: Usenet began as a *logical* internetwork of cooperating hosts that contacted
    each other directly. In the early Usenet, a user would post a message to her local
    server, where it would stay until that server either contacted or was contacted
    by another server. The message would then be transferred to the new server, where
    it would stay until the second server contacted a third one, and so on. This transport
    mechanism was functional, but seriously flawed in a number of ways.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet最初是一个*逻辑*的互连主机网络，它们直接相互联系。在早期的Usenet中，用户会将消息发布到她的本地服务器，消息将保留在那里，直到该服务器被另一个服务器联系或联系另一个服务器。然后，消息将被转移到新服务器，在那里它将保留，直到第二个服务器联系第三个服务器，依此类推。这种传输机制是有效的，但在许多方面存在严重缺陷。
- en: Servers were not continually connected to each other; they could communicate
    only by making a telephone call using an analog modem. Thus, messages would often
    sit for hours before they could be propagated. Modems in those days were also
    very slow by today's standards—2400 bits per second or even less—so it took a
    long time to copy a message from one server to another. Worst of all, unless two
    sites were in the same city, these phone calls were long distance, making them
    quite expensive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器并不是持续连接在一起的；它们只能通过使用模拟调制解调器打电话来相互通信。因此，消息往往需要几个小时才能传播。那时的调制解调器按照今天的标准也非常慢——每秒2400比特或更少——所以从一个服务器复制消息到另一个服务器需要很长时间。最糟糕的是，除非两个站点在同一座城市，否则这些电话是长途电话，使得它们相当昂贵。
- en: Why was this system used despite all of these problems? The answer is simply
    because there was no alternative. In the late 1970s and early 1980s, there was
    no Internet as we know it, and no other physical infrastructure existed to link
    Usenet sites together. It was either use UUCP over telephone lines or nothing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在所有这些问题，为什么还要使用这个系统？答案是简单，因为没有替代方案。在20世纪70年代末和80年代初，没有我们现在所知道的互联网，也没有其他物理基础设施存在来连接Usenet站点。要么通过电话线使用UUCP，要么什么也不做。
- en: That all changed as the fledgling ARPAnet grew into the modern Internet. As
    the Internet expanded, more and more sites connected to it, including many sites
    that were participating in Usenet. Once both sites in an exchange were on the
    Internet, it was an easy decision to use the Internet to send Usenet articles,
    rather than relying on slow, expensive phone calls. Over time, more and more Usenet
    sites joined the Internet, and it became clear that just as email had moved from
    UUCP to the TCP/IP Internet, the future of Usenet was on the Internet as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新兴的ARPAnet成长为现代互联网，这一切都发生了变化。随着互联网的扩展，越来越多的站点连接到它，包括许多参与Usenet的站点。一旦交换中的两个站点都连接到互联网，使用互联网发送Usenet文章而不是依赖缓慢、昂贵的电话通话就变得很容易了。随着时间的推移，越来越多的Usenet站点加入了互联网，很明显，正如电子邮件从UUCP迁移到TCP/IP互联网一样，Usenet的未来也在互联网上。
- en: 'The shifting of Usenet from UUCP connections to TCP/IP internetworking meant
    that some rethinking was required as to how Usenet articles were moved from server
    to server. On the Internet, Usenet was just one of many applications, and the
    transfer of messages had to be structured using TCP or the User Datagram Protocol
    (UDP). Thus, like other applications, Usenet required an application-level protocol
    to describe how to carry Usenet traffic over TCP/IP. Just as Usenet had borrowed
    its message format from email''s RFC 822, it made sense to model its message delivery
    protocol on the one used by email: SMTP. The result was the creation of NNTP,
    published as RFC 977 in February 1986.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet从UUCP连接转移到TCP/IP互联网意味着需要重新思考如何将Usenet文章从服务器移动到服务器。在互联网上，Usenet只是众多应用之一，消息的传输必须使用TCP或用户数据报协议（UDP）进行结构化。因此，就像其他应用一样，Usenet需要一个应用层协议来描述如何在TCP/IP上传输Usenet流量。正如Usenet从电子邮件的RFC
    822借用其消息格式一样，将其消息交付协议建模在电子邮件使用的协议（SMTP）上是有意义的。结果是1986年2月发布的RFC 977中NNTP的创建。
- en: The general operation of NNTP is indeed very similar to that of SMTP. NNTP uses
    TCP, with servers listening on well-known TCP port 119 for incoming connections,
    either from client hosts or other NNTP servers. As in SMTP, when two servers communicate
    using NNTP, the one that initiates the connection plays the role of client for
    that exchange.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP的一般操作确实与SMTP非常相似。NNTP使用TCP，服务器在众所周知的TCP端口119上监听传入的连接，无论是来自客户端主机还是其他NNTP服务器。在SMTP中，当两个服务器使用NNTP进行通信时，发起连接的那个服务器在该交换中扮演客户端的角色。
- en: After a connection is established, communication takes the form of commands
    sent by the client to the server and replies returned from the server to the client
    device. NNTP commands are sent as plain ASCII text, just like those used by SMTP,
    the File Transfer Protocol (FTP), the Hypertext Transfer Protocol (HTTP), and
    other protocols. NNTP responses take the form of three-digit reply codes as well
    as descriptive text, again just like SMTP (which, in turn, borrowed this concept
    from FTP).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 连接建立后，通信以客户端发送给服务器的命令和从服务器返回给客户端设备的回复的形式进行。NNTP命令以纯ASCII文本的形式发送，就像SMTP、文件传输协议（FTP）、超文本传输协议（HTTP）和其他协议使用的文本一样。NNTP响应以三位回复代码以及描述性文本的形式，同样就像SMTP（它反过来又从FTP借用了这个概念）。
- en: NNTP was designed to be a comprehensive vehicle for transporting Usenet messages.
    It is most often considered as a delivery protocol for moving Usenet articles
    from one server to another, but it is also used for connections from client hosts
    to Usenet servers for posting and reading messages. Thus, the NNTP command set
    is quite extensive and includes commands to handle communications between servers
    and between clients and servers. For message propagation, a set of commands allows
    a server to request new articles from another server or to send new articles to
    another server. For message posting and access, commands allow a client to request
    lists of new newsgroups and messages, and to retrieve messages for display to
    a user.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP被设计成一种用于传输Usenet消息的全面工具。它通常被视为一种将Usenet文章从一个服务器传输到另一个服务器的交付协议，但它也被用于客户端主机到Usenet服务器的连接，用于发布和阅读消息。因此，NNTP命令集相当广泛，包括处理服务器之间以及客户端和服务器之间通信的命令。对于消息传播，一组命令允许服务器从一个服务器请求新文章或将新文章发送到另一个服务器。对于消息发布和访问，命令允许客户端请求新新闻组和消息的列表，并检索消息以供用户显示。
- en: The commands defined in RFC 977 were the only official ones for over a decade.
    However, even as early as the late 1980s, implementers of NNTP server and client
    software were adding new commands and features to make NNTP both more efficient
    and useful to users. These *NNTP extensions* were eventually documented in RFC
    2980, published in 2000\. I describe them in more detail later in this chapter,
    in the "NNTP Commands and Command Extensions" section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 977中定义的命令在十多年内是唯一的官方命令。然而，甚至在20世纪80年代末，NNTP服务器和客户端软件的实现者就已经开始添加新的命令和功能，使NNTP更加高效，对用户更有用。这些*NNTP扩展*最终在2000年发布的RFC
    2980中被记录下来。我将在本章后面的“NNTP命令和命令扩展”部分更详细地描述它们。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Network News Transfer Protocol (NNTP) is the protocol used
    to implement message communication in modern Usenet. It is used for two primary
    purposes: to propagate messages between NNTP servers and to permit NNTP clients
    to post and read articles. It is a stand-alone protocol, but shares many characteristics
    with email''s Simple Mail Transfer Protocol (SMTP).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 网络新闻传输协议（NNTP）是现代Usenet中实现消息通信的协议。它用于两个主要目的：在NNTP服务器之间传播消息，并允许NNTP客户端发布和阅读文章。它是一个独立的协议，但与电子邮件的简单邮件传输协议（SMTP）有许多相似之处。'
- en: 'NNTP is used for all of the transfer steps in the modern Usenet communication
    process. However, NNTP is most often associated with the process of Usenet article
    *propagation*. This is arguably the most important function of NNTP: providing
    an efficient means of moving large volumes of Usenet articles from one server
    to another. It is thus a sensible place to start looking at the protocol.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP在现代Usenet通信过程中的所有传输步骤中都被使用。然而，NNTP最常与Usenet文章的*传播*过程相关联。这可以说是NNTP最重要的功能：提供一种高效的方式，将大量Usenet文章从一个服务器传输到另一个服务器。因此，从协议的角度来看，这是一个合理的起点。
- en: 'NNTP Interserver Communication Process: News Article Propagation'
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NNTP服务器间通信过程：新闻文章传播
- en: To understand how NNTP propagation works, we must begin with a look at the way
    that the modern Usenet network itself is organized. Usenet sites are now all on
    the Internet, and theoretically, any NNTP server can contact any other to send
    and receive Usenet articles. However, it would be ridiculous to have a new article
    submitted to a particular server need to be sent via separate NNTP connections
    to each and every other NNTP server. For this reason, the Usenet logical network
    continues to be very important, even in the Internet era.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解NNTP传播是如何工作的，我们必须首先看看现代Usenet网络本身的组织方式。现在，所有的Usenet站点都在互联网上，理论上，任何NNTP服务器都可以联系任何其他服务器来发送和接收Usenet文章。然而，如果要将一篇文章提交给特定的服务器，需要通过单独的NNTP连接发送到每个其他NNTP服务器，这将是荒谬的。因此，即使在互联网时代，Usenet的逻辑网络仍然非常重要。
- en: The Usenet Server Structure
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Usenet服务器结构
- en: In theory, all that is required of the Usenet structure is that each site be
    connected to at least one other site in some form. The logical network could be
    amorphous and without any formal structure at all, as long as every site could
    form a path through some sequence of intermediate servers to each other one. However,
    the modern Usenet is very large, with thousands of servers and gigabytes of articles
    being posted every day. This calls for a more organized structure for distributing
    news.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，对 Usenet 结构的要求只是每个站点以某种形式至少连接到另一个站点。逻辑网络可以是无形的，甚至没有任何正式的结构，只要每个站点都能通过一系列中间服务器形成一条路径，相互连接。然而，现代
    Usenet 非常庞大，每天都有成千上万的服务器和数以千计的文章被发布。这需要一种更组织化的结构来分发新闻。
- en: For this reason, the modern Usenet logical network is structured loosely in
    a hierarchy. A few large Internet service providers (ISPs) and big companies with
    high-speed Internet connections and large servers are considered to be at the
    top of the hierarchy, in what is sometimes called the Usenet *backbone*. Smaller
    organizations connect to the servers run by these large organizations; these organizations
    are considered to be *downstream* from the backbone groups. In turn, still smaller
    organizations may connect further downstream from the ones connected to the large
    organizations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代 Usenet 逻辑网络在结构上松散地分层。一些大型互联网服务提供商（ISP）和拥有高速互联网连接和大容量服务器的公司被认为是分层结构的顶层，有时被称为
    Usenet 的*骨干网*。较小的组织连接到这些大型组织运行的服务器；这些组织被认为是骨干组的*下游*。反过来，更小的组织可能从连接到大型组织的那些组织进一步下游连接。
- en: This hierarchical structure means that most Usenet servers maintain a direct
    connection only to their upstream neighbor and to any downstream sites to which
    they provide service. A server is said to receive a *news feed* from its upstream
    connection, since that is the place from which it will receive most of its news
    articles. It then provides a news feed to all the servers downstream from it.
    I illustrated this structure earlier in [Figure 85-1](ch85s02.html#usenet_network_news_communication_model_
    "Figure 85-1. Usenet (network news) communication model This figure illustrates
    the method by which messages are created, propagated, and read using NNTP on modern
    Usenet; it is similar in some respects to the email model diagram (Figure 74-1
    in Chapter 74). In this example, a message is created by the poster, Ellen, and
    read by a reader, Jane. The process begins with Ellen creating a message in an
    editor and posting it. Her NNTP client sends it to her local NNTP server. It is
    then propagated from that local server to adjacent servers, usually including
    its upstream server, which is used to send the message around the Internet. Other
    NNTP servers receive the message, including the one upstream from Jane's local
    server. It passes the message to Jane's local server, and Jane accesses and reads
    the message using an NNTP client. Jane could respond to the message; in which
    case, the same process would repeat, but going in the opposite direction, back
    to Ellen (and also back to thousands of other readers, not shown here).").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层结构意味着大多数 Usenet 服务器只与其上游邻居以及它们提供服务的任何下游站点保持直接连接。服务器从其上游连接接收所谓的*新闻源*，因为那里是它将接收大部分新闻文章的地方。然后，它将其新闻源提供给其下游的所有服务器。我在[图
    85-1](ch85s02.html#usenet_network_news_communication_model_ "图 85-1. Usenet (网络新闻)
    通信模型 此图说明了在现代 Usenet 上使用 NNTP 创建、传播和读取消息的方法；在某些方面与第 74 章中的电子邮件模型图（图 74-1）相似。在这个例子中，消息由发件人
    Ellen 创建并由读者 Jane 读取。过程从 Ellen 在编辑器中创建消息并发布开始。她的 NNTP 客户端将其发送到她的本地 NNTP 服务器。然后，从该本地服务器传播到相邻的服务器，通常包括其上游服务器，用于将消息发送到互联网。其他
    NNTP 服务器接收该消息，包括 Jane 的本地服务器上游的服务器。它将消息传递给 Jane 的本地服务器，Jane 使用 NNTP 客户端访问并读取该消息。Jane
    可以回复该消息；在这种情况下，相同的流程会重复，但方向相反，回到 Ellen（以及也回到成千上万的其他读者，此处未显示）")中展示了这种结构。
- en: As an example, suppose Company A runs a large Usenet server called Largenews
    that is connected to the backbone. Downstream from this server is the NNTP server
    Mediumnews. That server provides service to the server named Smallnews. If a user
    posts an article to Mediumnews, it will be placed on that server immediately.
    That server will send the article downstream, to Smallnews, so that it can be
    read by that server's users. Mediumnews will also, at some point, send the article
    to Largenews. From Largenews, the message will be distributed to other backbone
    sites, which will pass the message down to their own downstream sites. In this
    way, all sites eventually get a copy of the message, even though Mediumnews needs
    to connect directly to only two other servers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设公司 A 运行了一个名为 Largenews 的大型 Usenet 服务器，该服务器连接到主干网。从该服务器下游是 Mediumnews NNTP
    服务器。该服务器为名为 Smallnews 的服务器提供服务。如果一个用户向 Mediumnews 发布文章，它将立即被放置在该服务器上。该服务器将文章向下发送到
    Smallnews，以便该服务器的用户可以阅读。Mediumnews 还会在某个时候将文章发送到 Largenews。从 Largenews 出发，消息将被分发到其他主干站点，然后这些站点将消息传递到它们自己的下游站点。这样，所有站点最终都会收到消息的副本，尽管
    Mediumnews 只需要直接连接到两个其他服务器。
- en: The term used to describe how news is propagated with NNTP is *flooding*. This
    is because of the way that a message begins in one server and floods outward from
    it, eventually reaching the backbone sites, and then going down all the downstream
    "rivers" to reach every site on Usenet.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 用以描述使用 NNTP 传播新闻的术语是 *洪水传播*。这是因为消息从一个服务器开始，并从该服务器向外传播，最终到达主干站点，然后沿着所有下游的“河流”传播到
    Usenet 上的每个站点。
- en: Even though I described the logical Usenet network as a hierarchy, it is not
    a strict hierarchy. For redundancy, many NNTP servers maintain connections to
    multiple other servers to ensure that news propagates quickly. The transmission
    of articles can be controlled by looking at message IDs to avoid duplication of
    messages that may be received simultaneously by one server from more than one
    neighbor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我把 Usenet 网络的逻辑结构描述为层次结构，但它并不是一个严格的层次结构。为了冗余，许多 NNTP 服务器维护与多个其他服务器的连接，以确保新闻能够快速传播。可以通过查看消息
    ID 来控制文章的传输，以避免一个服务器从多个邻居那里同时接收到的消息重复。
- en: Basic NNTP Propagation Methods
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本NNTP传播方法
- en: 'Now let''s look at how messages are actually propagated between servers using
    NNTP. There are two techniques by which this can be done:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用 NNTP 在服务器之间实际传播消息的方式。有两种技术可以实现这一点：
- en: In the *push model*, as soon as a server receives a new message, it immediately
    tells its upstream and downstream neighbors about the message and asks them if
    they want a copy of it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *推送模型* 中，一旦服务器收到新消息，它立即通知其上游和下游邻居关于该消息的信息，并询问他们是否想要一份副本。
- en: In the *pull model*, servers do not offer new articles to their neighbors. The
    neighboring servers must ask for a list of new messages if they want to see what
    has arrived since the last connection was established, and then request that the
    new messages be sent to them.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *拉模型* 中，服务器不会向其邻居提供新文章。如果邻居服务器想要查看自上次连接建立以来到达了什么内容，它们必须请求新消息列表，然后请求将新消息发送给它们。
- en: Both techniques have advantages and disadvantages, but pushing is the model
    most commonly used today.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术都有优点和缺点，但推送是目前最常用的模型。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** One important role that NNTP plays is its propagation of articles
    between Usenet servers, which is what makes the entire system possible. Two models
    are used for article propagation: the push model, in which a server that receives
    a new message offers it to connected servers immediately, and the pull model,
    where servers that receive new messages hold them until they are requested by
    other servers. The push model is usually preferred since it allows for quicker
    communication of messages around the system.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** NNTP 扮演的一个重要角色是在 Usenet 服务器之间传播文章，这使得整个系统成为可能。用于文章传播有两种模型：推送模型，其中接收新消息的服务器立即将其提供给连接的服务器，以及拉模型，其中接收新消息的服务器在收到其他服务器的请求之前保留它们。推送模型通常更受欢迎，因为它允许系统内更快地传递消息。'
- en: Article Propagation Using the Push Model
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用推送模型进行文章传播
- en: Using the push model, when the administrators of an NNTP server establish a
    service relationship with an upstream Usenet service provider, they furnish the
    provider with a list of newsgroups that the downstream server wants to carry.
    Whenever a new article arrives at the upstream server within that list of groups,
    it is automatically sent to the downstream site. This saves the downstream server
    from constantly having to ask whether anything has arrived.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用推送模型，当NNTP服务器的管理员与上游Usenet服务提供商建立服务关系时，他们向提供商提供一份下游服务器希望携带的新组列表。每当该列表中的某个组上游服务器收到新文章时，它会自动发送到下游站点。这使下游服务器不必不断询问是否有新内容到达。
- en: In the classic NNTP protocol as defined in RFC 977, the exchange of articles
    is based on the push model and performed using the IHAVE command. Returning to
    the example in the previous section, suppose three new messages arrive at the
    Largenews server. It would establish an NNTP connection to the Mediumnews server
    and use IHAVE to provide the message IDs of each of the three new messages, one
    at a time. (NNTP commands are described later in this chapter.) The Mediumnews
    server would respond to each one, indicating whether or not it already had that
    message. If not, Largenews would send it the message. An example of an article
    transaction using the push model of propagation is illustrated in [Figure 85-3](ch85s05.html#nntp_article_propagation_using_the_push_
    "Figure 85-3. NNTP article propagation using the push model This example shows
    how Usenet articles are moved between servers using the conventional push model
    of propagation. Here, the device acting as an NNTP client (which may, in fact,
    be an NNTP server) has two messages available to offer to the server. It sends
    the IHAVE command specifying the message ID of the first message, but the server
    already has that message, so it sends a 435 (Do Not Send) reply. The client then
    issues an IHAVE with the second message ID. The server wants this one, so it sends
    a 335 reply. The client sends the Usenet message, ending with a single period
    on a line by itself. The server indicates that it received the message, and the
    client, finished with its transactions, quits the session.").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 977中定义的经典NNTP协议中，文章的交换基于推送模型，并使用IHAVE命令执行。回到上一节中的例子，假设有三条新消息到达Largenews服务器。它将建立一个到Mediumnews服务器的NNTP连接，并使用IHAVE命令逐个提供三条新消息的消息ID。（NNTP命令将在本章后面描述。）Mediumnews服务器将对每一条消息做出回应，表明它是否已经拥有该消息。如果没有，Largenews将发送该消息。使用推送模型传播文章的事务示例在[图85-3](ch85s05.html#nntp_article_propagation_using_the_push_
    "图85-3. 使用推送模型传播NNTP文章。本例展示了Usenet文章是如何在服务器之间使用传统的推送模型进行移动的。在这里，作为NNTP客户端（实际上可能是NNTP服务器）的设备有两个消息可供服务器使用。它发送IHAVE命令指定第一条消息的消息ID，但服务器已经有了这条消息，因此发送了一个435（不要发送）回复。客户端随后发出一个带有第二条消息ID的IHAVE命令。服务器想要这条消息，因此发送了一个335回复。客户端发送Usenet消息，以单独一行上的单个句号结束。服务器表明它已收到消息，客户端完成其事务后，退出会话。")中展示。
- en: '![NNTP article propagation using the push model This example shows how Usenet
    articles are moved between servers using the conventional push model of propagation.
    Here, the device acting as an NNTP client (which may, in fact, be an NNTP server)
    has two messages available to offer to the server. It sends the IHAVE command
    specifying the message ID of the first message, but the server already has that
    message, so it sends a 435 (Do Not Send) reply. The client then issues an IHAVE
    with the second message ID. The server wants this one, so it sends a 335 reply.
    The client sends the Usenet message, ending with a single period on a line by
    itself. The server indicates that it received the message, and the client, finished
    with its transactions, quits the session.](httpatomoreillycomsourcenostarchimages288321.png.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用推送模型传播NNTP文章 本例展示了Usenet文章是如何在服务器之间使用传统的推送模型进行移动的。在这里，作为NNTP客户端（实际上可能是NNTP服务器）的设备有两个消息可供服务器使用。它发送IHAVE命令指定第一条消息的消息ID，但服务器已经有了这条消息，因此发送了一个435（不要发送）回复。客户端随后发出一个带有第二条消息ID的IHAVE命令。服务器想要这条消息，因此发送了一个335回复。客户端发送Usenet消息，以单独一行上的单个句号结束。服务器表明它已收到消息，客户端完成其事务后，退出会话。](httpatomoreillycomsourcenostarchimages288321.png.jpg)'
- en: Figure 85-3. NNTP article propagation using the push model This example shows
    how Usenet articles are moved between servers using the conventional push model
    of propagation. Here, the device acting as an NNTP client (which may, in fact,
    be an NNTP server) has two messages available to offer to the server. It sends
    the IHAVE command specifying the message ID of the first message, but the server
    already has that message, so it sends a 435 (Do Not Send) reply. The client then
    issues an IHAVE with the second message ID. The server wants this one, so it sends
    a 335 reply. The client sends the Usenet message, ending with a single period
    on a line by itself. The server indicates that it received the message, and the
    client, finished with its transactions, quits the session.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图85-3. 使用推送模型进行NNTP文章传播 此示例展示了Usenet文章是如何在服务器之间使用传统的推送模型进行传播的。在这里，作为NNTP客户端的设备（实际上可能是NNTP服务器）有两个消息可供服务器使用。它发送IHAVE命令，指定第一条消息的消息ID，但服务器已经有了这条消息，因此发送了一个435（不要发送）回复。然后客户端发出一个带有第二条消息ID的IHAVE命令。服务器希望接收这条消息，因此发送了一个335回复。客户端发送Usenet消息，以单独一行上的单个句号结束。服务器表明它已收到消息，客户端完成交易后退出会话。
- en: The main advantage of this technique is that it ensures that a server is not
    sent a duplicate copy of a message that it already has. The problem with it in
    modern Usenet is that it is slow, because the server must respond to the IHAVE
    command before the message or the next command can be sent by the client.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优点是确保服务器不会收到它已经拥有的消息的重复副本。在现代Usenet中，它的缺点是速度慢，因为服务器必须在客户端发送消息或下一个命令之前响应IHAVE命令。
- en: Improving Propagation Efficiency with Streaming Mode
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用流模式提高传播效率
- en: One of the more important NNTP extensions is *streaming mode*, which changes
    how news pushing is done. (NNTP command extensions are described later in this
    chapter.) When this mode is enabled, the client machine uses the CHECK command
    instead of IHAVE to ask the server if it wants a particular message. The server
    responds to indicate if it wants the message; if it does, the client sends the
    message with the TAKETHIS command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的NNTP扩展之一是*流模式*，它改变了新闻推送的方式。（NNTP命令扩展将在本章后面描述。）当此模式启用时，客户端机器使用CHECK命令而不是IHAVE来询问服务器是否希望接收特定的消息。服务器响应以表明是否希望接收消息；如果希望，客户端使用TAKETHIS命令发送消息。
- en: The benefit of CHECK/TAKETHIS is that the client does not need to wait for a
    reply to CHECK before sending the next command. While the client is waiting for
    a reply to the first CHECK command, it can do something else, like sending the
    next CHECK command, allowing commands to be streamed for greater efficiency. So,
    the client could send a CHECK command for the first new message, then a CHECK
    for the second, while waiting for a reply from the server to the first one. Many
    CHECK commands could be sent in a stream, and then TAKETHIS commands sent for
    each reply received to CHECK commands sent earlier indicating that the message
    was wanted by the server.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: CHECK/TAKETHIS的好处是客户端在发送下一个命令之前不需要等待CHECK命令的回复。当客户端等待第一个CHECK命令的回复时，它可以做其他事情，比如发送下一个CHECK命令，允许命令以流的形式发送以提高效率。因此，客户端可以先发送一个CHECK命令用于第一条新消息，然后发送一个CHECK命令用于第二条，同时等待服务器对第一条消息的回复。可以发送多个CHECK命令流，然后为之前发送的每个CHECK命令发送TAKETHIS命令，以表明服务器希望接收该消息。
- en: Article Propagation Using the Pull Model
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用拉模型进行文章传播
- en: The pull model is implemented using the NEWNEWS and ARTICLE commands. The client
    connects to the server and sends the NEWNEWS command with a date specifying the
    date and time that it last checked for new messages. The server responds with
    a set of message IDs for new articles that have arrived since that date. The client
    then requests each new message using the ARTICLE command.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 拉模型是通过使用NEWNEWS和ARTICLE命令实现的。客户端连接到服务器并发送NEWNEWS命令，其中包含一个日期，指定客户端上次检查新消息的日期和时间。服务器响应，返回自该日期以来到达的新文章的消息ID集合。然后客户端使用ARTICLE命令请求每条新消息。
- en: Note that the push and pull models can be combined in a single session. A client
    can connect to a server, use NEWNEWS to check for new messages on that server,
    and then IHAVE or CHECK inform the server about new messages the client wants
    to send. In practice, it is more common for only one or the other of the models
    to be used between a pair of servers for any given exchange.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，推送和拉取模型可以在单个会话中结合使用。客户端可以连接到服务器，使用NEWNEWS检查该服务器上的新消息，然后通过IHAVE或CHECK通知服务器客户端想要发送的新消息。在实践中，一对服务器之间在特定交换中通常只使用这两种模型中的一种。
- en: In addition to propagating new messages, NNTP is also used to allow servers
    to communicate information about new newsgroups that have been created. This is
    done using the NEWGROUPS command, which is specified with a date and time like
    NEWNEWS. In response, the server sends to the client a list of new newsgroups
    that have been created since the specified date and time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传播新消息外，NNTP还用于允许服务器之间交流有关新创建的新闻组的信息。这是通过使用NEWGROUPS命令来完成的，该命令与NEWNEWS一样，指定了日期和时间。作为回应，服务器向客户端发送自指定日期和时间以来创建的新新闻组的列表。
- en: 'NNTP Client-Server Communication Process: News Posting and Access'
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NNTP客户端-服务器通信过程：新闻发布和访问
- en: One critical area where NNTP differs from its progenitor, SMTP, is that NNTP
    is not just used for interserver communication. It is also used for the initial
    posting of Usenet messages, as well as reading the messages. In fact, the majority
    of NNTP commands deals with the interaction between user client machines and NNTP
    servers, not communication between servers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP与其前身SMTP的一个关键区别在于，NNTP不仅用于服务器之间的通信。它还用于Usenet消息的初始发布以及阅读消息。实际上，NNTP的大多数命令都涉及用户客户端机器与NNTP服务器之间的交互，而不是服务器之间的通信。
- en: 'An NNTP client is any software program that knows the NNTP protocol and is
    designed to provide user access to Usenet. NNTP clients are usually called *newsreaders*,
    and they provide two main capabilities to a user: *posting* and *reading* Usenet
    messages. Usenet newsreaders exist for virtually all hardware and software platforms,
    and they range greatly in terms of capabilities, user interface, and other characteristics.
    Most people today use a Usenet newsreader on a client computer that must make
    NNTP connections to a separate NNTP server to read and post news. These programs
    are analogous to email clients, and, in fact, many email clients also function
    as NNTP clients.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP客户端是指任何了解NNTP协议并设计为提供用户访问Usenet的软件程序。NNTP客户端通常被称为*新闻阅读器*，它们为用户提供两个主要功能：*发布*和*阅读*Usenet消息。Usenet新闻阅读器几乎存在于所有硬件和软件平台上，它们在功能、用户界面和其他特性方面差异很大。如今，大多数人都在客户端计算机上使用Usenet新闻阅读器，这些计算机必须连接到单独的NNTP服务器来阅读和发布新闻。这些程序类似于电子邮件客户端，实际上，许多电子邮件客户端也充当NNTP客户端。
- en: News Posting, Access, and Reading
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新闻发布、访问和阅读
- en: Posting a Usenet message is the first step in the overall Usenet communication
    process (although many Usenet articles are actually replies to other articles,
    so it's a bit of a chicken-and-egg situation). Article posting is quite straightforward
    with NNTP. The client establishes a connection to the server and issues the POST
    command. If the server is willing to accept new articles, it replies with a prompt
    for the client to send it the article. The article is then transmitted by the
    client to the server. Some newsreaders may batch new articles, so they can be
    sent in a single NNTP session, rather than submitting them one at a time.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 发布Usenet消息是整个Usenet通信过程中的第一步（尽管许多Usenet文章实际上是其他文章的回复，所以这有点像鸡生蛋的问题）。使用NNTP发布文章非常直接。客户端建立与服务器的连接并发出POST命令。如果服务器愿意接受新文章，它会回复提示客户端发送文章。然后客户端将文章传输到服务器。一些新闻阅读器可能会批量处理新文章，以便在单个NNTP会话中发送，而不是逐个提交。
- en: Newsreaders also establish an NNTP connection to a server to read Usenet articles.
    NNTP provides a large number of commands to support a variety of different article
    access and retrieval actions that may be taken by a user. The first step in reading
    is sometimes to examine the list of available newsgroups. Using the LIST command,
    the client requests from the server a list of the newsgroups available for reading
    and posting. RFC 977 defines the basic LIST command, which returns a list of all
    groups to the client. RFC 2980 defines numerous extensions to the command to allow
    a client to retrieve only certain types of information about groups on the server.
    Since the number of Usenet newsgroups is so large today, this listing of newsgroups
    is usually skipped unless the user specifically requests it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻阅读器也会建立一个NNTP连接到服务器来阅读Usenet文章。NNTP提供大量命令来支持用户可能采取的各种不同的文章访问和检索操作。阅读的第一步有时是检查可用的新闻组列表。使用LIST命令，客户端从服务器请求可阅读和发布的新闻组列表。RFC
    977定义了基本的LIST命令，它将所有组列表返回给客户端。RFC 2980定义了命令的多个扩展，允许客户端仅检索服务器上组的信息。由于今天Usenet新闻组的数量如此之大，通常情况下，除非用户明确请求，否则会跳过新闻组列表。
- en: The next step in Usenet message access is typically to select a newsgroup to
    read from the list of groups available. Again, since there are so many groups
    today, most newsreaders allow a user to search for a group name using a pattern
    or partial name string. The GROUP command is then sent to the server with the
    name of the selected group. The server returns the first and last current article
    numbers for the group to the client.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Usenet消息访问的下一步通常是选择一个新闻组从可用的组列表中阅读。同样，由于今天有如此多的组，大多数新闻阅读器允许用户使用模式或部分名称字符串来搜索组名。然后，将带有所选组名的GROUP命令发送到服务器。服务器将组的第一和最后当前文章编号返回给客户端。
- en: 'Messages are identified in two ways: one absolute and the other site-specific.
    The article''s message ID is a fixed identifier that can be used to uniquely represent
    it across Usenet; this is what is used in interserver communication to determine
    whether each site has a copy of a given message. In contrast, *article numbers*
    are server-specific; they represent the numbers assigned to those articles as
    they arrived at that server and are used as a shorthand to more easily refer to
    articles in a newsgroup. Thus, the same message will have a different article
    number on each NNTP server. Article numbers are used for convenience, since they
    are much shorter than message IDs. During a session, the NNTP server also maintains
    a current article pointer, which can be used for stepping sequentially through
    a newsgroup.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以通过两种方式来识别：一种是绝对方式，另一种是站点特定方式。文章的消息ID是一个固定的标识符，可以在整个Usenet中唯一地表示它；这是在服务器间通信中用来确定每个站点是否有一个给定消息副本的方法。相比之下，*文章编号*是服务器特定的；它们代表那些文章到达服务器时分配的编号，并用作在新组中引用文章的简写。因此，同一消息在每个NNTP服务器上会有不同的文章编号。文章编号用于方便，因为它们比消息ID短得多。在会话期间，NNTP服务器还维护一个当前文章指针，可以用来按顺序遍历新闻组。
- en: News Access Methods
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新闻访问方法
- en: 'There are several different ways that the newsreader can access messages in
    a group, depending on how it is programmed and what the user of the software wants.
    The news access methods include the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻阅读器可以以多种不同的方式访问组中的消息，这取决于其编程方式和软件用户的需求。新闻访问方法包括以下内容：
- en: '**Full Newsgroup Retrieval** The brute-force technique is for the client to
    simply request that the server send it all the messages in the group. The client
    issues the ARTICLE command to select the first current message in the group, using
    the first article number returned by the GROUP command. This sets the server''s
    internal pointer for the session to point to the first article, so it can be retrieved.
    The NEXT command is then used to advance the pointer to the next message, and
    the ARTICLE command is used to retrieve it. This continues until the entire group
    has been read. [Figure 85-4](ch85s06.html#nntp_full_newsgroup_retrieval_process_th
    "Figure 85-4. NNTP full newsgroup retrieval process There are many ways that an
    NNTP client can access and read Usenet messages on a server. One common method
    is to retrieve the entire contents of a newsgroup. In this example, the client
    uses the GROUP command to select the newsgroup comp.protocols.tcp-ip for reading;
    the server responds with a 211 (Group Selected) reply, which includes important
    statistics about the group. The client uses the ARTICLE command with the number
    of the first article in the group, 177, to read it from the server. The server
    then sends the message line by line, ending it with a single period on a line.
    The client uses the NEXT command to tell the server to advance its internal article
    pointer to the next message, which often will not be the next consecutive number
    after the one just read; here it is 179\. The client can then read that message
    by sending the ARTICLE command by itself. Since no parameters are given, the server
    returns the current message (179).") illustrates the process. The retrieved messages
    are stored by the newsreader and available for instant access by the user. This
    method is most suitable for relatively small newsgroups and/or users with fast
    Internet connections.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整新闻组检索** 强制检索技术是客户端请求服务器发送该组中的所有消息。客户端发出ARTICLE命令以选择组中的第一条当前消息，使用GROUP命令返回的第一个文章编号。这会将服务器的内部会话指针设置为指向第一条文章，以便可以检索它。然后使用NEXT命令将指针前进到下一条消息，并使用ARTICLE命令检索它。这个过程一直持续到整个组都被读取。图85-4（ch85s06.html#nntp_full_newsgroup_retrieval_process_th
    "图85-4. NNTP完整新闻组检索过程有许多方法可以让NNTP客户端访问和读取服务器上的Usenet消息。一种常见的方法是检索整个新闻组的全部内容。在这个例子中，客户端使用GROUP命令选择读取comp.protocols.tcp-ip新闻组；服务器响应211（Group
    Selected）回复，其中包含有关该组的重要统计数据。客户端使用ARTICLE命令和组中第一条文章的编号177，从服务器读取它。然后服务器逐行发送消息，以单行上的一个句号结束。客户端使用NEXT命令告诉服务器将其内部文章指针前进到下一条消息，这通常不会是刚刚读取的下一个连续编号；这里它是179。然后客户端可以通过单独发送ARTICLE命令来读取那条消息。由于没有给出参数，服务器返回当前消息（179）。"）说明了这个过程。检索到的消息由新闻阅读器存储，并可供用户即时访问。这种方法最适合相对较小的新闻组以及/或拥有快速互联网连接的用户。'
- en: '**Newsgroup Header Retrieval** Since downloading an entire newsgroup is time-consuming,
    many newsreaders compromise by downloading the headers of all messages instead
    of the full message. The process is the same as for full newsgroup retrieval,
    but the HEAD command is used to retrieve just an article''s headers. This takes
    less time than retrieving each message in its entirety using the ARTICLE command.
    The XHDR command extension can also be used, if the server supports it, to more
    efficiently retrieve only a subset of the headers for the messages, such as the
    subject line and author.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**新闻组标题检索** 由于下载整个新闻组耗时较长，许多新闻阅读器通过下载所有消息的标题而不是完整消息来妥协。这个过程与完整新闻组检索相同，但使用HEAD命令来检索仅包含文章标题。这比使用ARTICLE命令检索每条消息的全部内容要快。如果服务器支持，还可以使用XHDR命令扩展来更有效地检索消息标题的子集，例如主题行和作者。'
- en: '**Individual Article Retrieval** It is also possible to retrieve a single message
    from a group, using the ARTICLE command and specifying the article''s message
    identifier.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**单篇文章检索** 还可以使用ARTICLE命令从新闻组中检索单个消息，并指定文章的消息标识符。'
- en: Tip
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** While NNTP is best known for its role in interserver propagation,
    it is also used by Usenet clients to write and read articles. Different commands
    provide flexibility in how articles can be read by a client device. A client can
    retrieve an entire newsgroup, only a set of newsgroup headers, or individual articles.
    Other commands also support various administrative functions.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 虽然 NNTP 最为人所知的是其在服务器间传播中的作用，但它也被 Usenet 客户端用于撰写和阅读文章。不同的命令提供了客户端设备阅读文章的灵活性。客户端可以检索整个新闻组，仅检索一组新闻组标题，或单个文章。其他命令也支持各种管理功能。'
- en: Other Client/Server Functions
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他客户端/服务器功能
- en: In addition to reading and posting, NNTP includes commands to support other
    miscellaneous tasks that a Usenet user may wish to perform. The client can ask
    the server for help information by using the HELP command or get a list of new
    newsgroups by using the NEWGROUPS command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阅读和发布，NNTP 还包括支持用户可能希望执行的其他各种杂项任务的命令。客户端可以通过使用 HELP 命令来请求服务器的帮助信息，或者使用 NEWGROUPS
    命令来获取新新闻组的列表。
- en: Most modern newsreaders include capabilities that go far beyond the basic posting
    and reading functions previously described. Most maintain their own sets of configuration
    files that allow a user to maintain a set of favorite subscribed newsgroups, rather
    than needing to choose a group to read from the master list each time Usenet is
    accessed. Newsreaders also keep track of which articles have been read by a user
    in each subscribed newsgroup, so users do not need to wade through a whole newsgroup
    to see new messages that have been posted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代新闻阅读器包括的功能远远超出了之前描述的基本发布和阅读功能。大多数维护自己的配置文件集，允许用户维护一组喜欢的已订阅新闻组，而不是每次访问 Usenet
    时都需要从主列表中选择一个组来阅读。新闻阅读器还会跟踪用户在每个已订阅新闻组中已阅读的文章，因此用户不需要浏览整个新闻组来查看已发布的新消息。
- en: '![NNTP full newsgroup retrieval process There are many ways that an NNTP client
    can access and read Usenet messages on a server. One common method is to retrieve
    the entire contents of a newsgroup. In this example, the client uses the GROUP
    command to select the newsgroup comp.protocols.tcp-ip for reading; the server
    responds with a 211 (Group Selected) reply, which includes important statistics
    about the group. The client uses the ARTICLE command with the number of the first
    article in the group, 177, to read it from the server. The server then sends the
    message line by line, ending it with a single period on a line. The client uses
    the NEXT command to tell the server to advance its internal article pointer to
    the next message, which often will not be the next consecutive number after the
    one just read; here it is 179\. The client can then read that message by sending
    the ARTICLE command by itself. Since no parameters are given, the server returns
    the current message (179).](httpatomoreillycomsourcenostarchimages288323.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![NNTP 完整新闻组检索过程](http://atomoreilly.com/source/nostarch/images/288323.png.jpg)
    有许多方法可以让 NNTP 客户端访问和读取服务器上的 Usenet 消息。一种常见的方法是检索整个新闻组的内容。在这个例子中，客户端使用 GROUP 命令选择用于阅读的新闻组
    comp.protocols.tcp-ip；服务器响应 211（Group Selected）回复，其中包含有关该组的重要统计数据。客户端使用带有组中第一篇文章编号
    177 的 ARTICLE 命令从服务器读取它。然后服务器逐行发送消息，以单行上的单个句号结束。客户端使用 NEXT 命令告诉服务器将其内部文章指针向前移动到下一篇文章，这通常不会是刚刚读取的下一个连续编号；这里它是
    179。然后客户端可以通过单独发送 ARTICLE 命令来读取该消息。由于没有给出参数，服务器返回当前消息（179）。'
- en: Figure 85-4. NNTP full newsgroup retrieval process There are many ways that
    an NNTP client can access and read Usenet messages on a server. One common method
    is to retrieve the entire contents of a newsgroup. In this example, the client
    uses the GROUP command to select the newsgroup comp.protocols.tcp-ip for reading;
    the server responds with a 211 (Group Selected) reply, which includes important
    statistics about the group. The client uses the ARTICLE command with the number
    of the first article in the group, 177, to read it from the server. The server
    then sends the message line by line, ending it with a single period on a line.
    The client uses the NEXT command to tell the server to advance its internal article
    pointer to the next message, which often will not be the next consecutive number
    after the one just read; here it is 179\. The client can then read that message
    by sending the ARTICLE command by itself. Since no parameters are given, the server
    returns the current message (179).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图85-4. NNTP完整新闻组检索过程 有许多方式可以让NNTP客户端访问和读取服务器上的Usenet消息。一种常见的方法是检索整个新闻组的全部内容。在这个例子中，客户端使用GROUP命令选择用于阅读的新闻组comp.protocols.tcp-ip；服务器响应以211（Group
    Selected）回复，其中包含有关该组的重要统计数据。客户端使用带有组中第一篇文章编号的ARTICLE命令，即177，从服务器读取它。然后服务器逐行发送消息，以一行上的单个句号结束。客户端使用NEXT命令告诉服务器将其内部文章指针向前移动到下一篇文章，这通常不会是刚刚读取的下一个连续编号；这里它是179。然后客户端可以通过发送仅包含ARTICLE命令的命令来读取该消息。由于没有给出参数，服务器返回当前消息（179）。
- en: Article Threading
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章线程
- en: One particularly useful enhancement to basic Usenet article reading is *threading*.
    This feature allows a newsreader to display articles not strictly in either alphabetical
    or chronological order, but rather grouped into conversations using the information
    in the articles' References headers. Threading is especially useful in busy newsgroups,
    as it allows users to see all the articles in a particular discussion at once,
    rather than trying to juggle messages from many conversations simultaneously.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 基本Usenet文章阅读的一个特别有用的增强功能是*线程化*。这个特性允许新闻阅读器以非严格的字母顺序或时间顺序显示文章，而是根据文章的引用头信息将文章分组到对话中。在繁忙的新闻组中，线程化特别有用，因为它允许用户一次性查看特定讨论中的所有文章，而不是同时尝试处理多个对话的消息。
- en: A problem with threading is that it takes a long time for a newsreader to sift
    through all those References lines and construct the article threads. To speed
    up this process, many servers now cache extra threading or overview information
    for newsgroups, which can be retrieved by the client to save time when a newsgroup
    is opened. This is done using the XTHREAD or XOVER NNTP command extensions.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 线程化的问题之一是新闻阅读器需要花费很长时间来筛选所有这些引用行并构建文章线程。为了加快这一过程，许多服务器现在为新新闻组缓存额外的线程或概述信息，客户端可以在打开新闻组时检索这些信息以节省时间。这是通过使用XTHREAD或XOVER
    NNTP命令扩展来完成的。
- en: NNTP Commands and Command Extensions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NNTP命令和命令扩展
- en: 'One of the great strengths of the open, cooperative process used to develop
    Internet standards is that new protocols are usually designed by building on older
    ones. This saves development time and effort, and promotes compatibility between
    technologies. As I explained earlier in the chapter, NNTP was based in many ways
    on principles from SMTP; SMTP, in turn, borrowed ideas from earlier protocols:
    Telnet and FTP. This legacy can be seen in the similarities between NNTP commands
    and those of these earlier protocols.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 开放、协作的过程在开发互联网标准中的巨大优势之一是，通常新的协议是通过在旧协议的基础上进行设计。这节省了开发时间和精力，并促进了技术之间的兼容性。正如我在本章前面所解释的，NNTP在许多方面基于SMTP的原则；SMTP反过来又借鉴了早期协议（如Telnet和FTP）的思想。这种传统可以在NNTP命令与这些早期协议的相似性中看到。
- en: Command Syntax
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令语法
- en: As in SMTP, all NNTP commands are ASCII text that are sent over the NNTP TCP
    connection to an NNTP server, from the device acting as the client (which may
    be a newsreader client or an NNTP server itself). These are standard text strings
    adhering to the Telnet Network Virtual Terminal (NVT) format, terminated by the
    two-character carriage return/line feed (CRLF) sequence. As is the case with SMTP
    and FTP, you can conduct an interactive session with an NNTP server by using Telnet
    to connect to it on port 119.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SMTP 类似，所有 NNTP 命令都是 ASCII 文本，通过 NNTP TCP 连接发送到 NNTP 服务器，由充当客户端的设备（可能是新闻阅读器客户端或
    NNTP 服务器本身）发送。这些是遵循 Telnet 网络虚拟终端 (NVT) 格式的标准文本字符串，以两个字符的回车/换行 (CRLF) 序列结束。与 SMTP
    和 FTP 一样，您可以通过使用 Telnet 在端口 119 上连接到 NNTP 服务器来与 NNTP 服务器进行交互式会话。
- en: The basic syntax of an NNTP command is <*command-code*> <*parameters*>. Unlike
    SMTP, NNTP commands are not restricted to a length of four characters. The parameters
    that follow the command are separated by one or more space characters, and are
    used to provide necessary information to allow the server to execute the command.
    NNTP commands are not case-sensitive.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP 命令的基本语法是 <*command-code*> <*parameters*>。与 SMTP 不同，NNTP 命令不受四个字符长度的限制。命令后面的参数由一个或多个空格字符分隔，并用于提供必要的信息，以便服务器执行命令。NNTP
    命令不区分大小写。
- en: Base Command Set
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础命令集
- en: The main NNTP specification, RFC 977, describes the base set of commands supported
    by NNTP clients and servers. They are not broken into categories, but rather listed
    alphabetically, as I have done in [Table 85-5](ch85s07.html#nntp_base_commands
    "Table 85-5. NNTP Base Commands"). (The details on how many of these commands
    are used for news article propagation and news posting/access were provided earlier
    in this chapter.)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 NNTP 规范，RFC 977，描述了 NNTP 客户端和服务器支持的命令基础集。它们没有被分成类别，而是按字母顺序列出，正如我在 [表 85-5](ch85s07.html#nntp_base_commands
    "表 85-5. NNTP 基础命令") 中所做的那样。（关于这些命令中哪些用于新闻文章传播和新闻发布/访问的详细信息，在本章前面已提供。）
- en: Table 85-5. NNTP Base Commands
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-5. NNTP 基础命令
- en: '| Command Code | Command | Parameters | Description |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 参数 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ARTICLE | Retrieve Article | Message ID or server article number | Tells
    the server to send the client a particular Usenet article. The article to be retrieved
    may be specified using either its absolute, universal message ID or its locally
    assigned article number. When the command is issued with an article number, this
    causes the server''s internal message pointer to be set to the specified article.
    If the message pointer is already set to a particular article, the ARTICLE command
    can be issued without an article number, and the current message will be retrieved.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| ARTICLE | 获取文章 | 消息 ID 或服务器文章编号 | 告诉服务器向客户端发送特定的 Usenet 文章。要检索的文章可以使用其绝对、通用消息
    ID 或其本地分配的文章编号来指定。当命令与文章编号一起发出时，这将导致服务器的内部消息指针设置为指定的文章。如果消息指针已经设置为特定的文章，则无需文章编号即可发出
    ARTICLE 命令，并将检索当前消息。|'
- en: '| HEAD | Retrieve Article Headers | Message ID or server article number | Same
    as the ARTICLE command, but retrieves only the article''s headers. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| HEAD | 获取文章标题 | 消息 ID 或服务器文章编号 | 与 ARTICLE 命令相同，但只检索文章的标题。|'
- en: '| BODY | Retrieve Article Body | Message ID or server article number | Same
    as the ARTICLE command, but returns only the body of the article. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| BODY | 获取文章正文 | 消息 ID 或服务器文章编号 | 与 ARTICLE 命令相同，但只返回文章的正文。|'
- en: '| STAT | Retrieve Article Statistics | Server article number | Conceptually
    the same as the ARTICLE command, but does not return any message text, only the
    message ID of the article. This command is usually used for setting the server''s
    internal message pointer, so STAT is normally invoked only with an article number
    (and not a message ID). |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| STAT | 获取文章统计信息 | 服务器文章编号 | 概念上与 ARTICLE 命令相同，但不返回任何消息文本，只返回文章的消息 ID。此命令通常用于设置服务器的内部消息指针，因此
    STAT 通常只与文章编号（而不是消息 ID）一起调用。|'
- en: '| GROUP | Select Newsgroup | Newsgroup name | Tells the server the name of
    the newsgroup that the client wants to access. Assuming the group specified exists,
    the server returns to the client the numbers of the first and last articles currently
    in the group, along with an estimate of the number of messages in the group. The
    server''s internal article pointer is also set to the first message in the group.
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| GROUP | 选择新闻组 | 新闻组名称 | 告知服务器客户端想要访问的新闻组名称。假设指定的组存在，服务器将返回客户端该组中第一条和最后一条文章的编号，以及该组消息数量的估计。服务器的内部文章指针也将设置为组中的第一条消息。
    |'
- en: '| HELP | Get Help Information | None | Prompts the server to send the client
    help information, which usually takes the form of a list of valid commands that
    the server supports. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| HELP | 获取帮助信息 | 无 | 请求服务器向客户端发送帮助信息，这通常以服务器支持的合法命令列表的形式出现。 |'
- en: '| IHAVE | Offer Article to Server | Message ID | Used by the client in an NNTP
    session to tell the server that it has a new article that the server may want.
    The server will check the message ID provided and respond to the client, indicating
    whether or not it wants the client to send the article. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| IHAVE | 向服务器提供文章 | 消息ID | 客户端在NNTP会话中使用，告知服务器它有一个服务器可能感兴趣的新文章。服务器将检查提供的消息ID，并响应客户端，指示是否希望客户端发送文章。
    |'
- en: '| LAST | Go to Last Message | None | Tells the server to set its current article
    pointer to the last message in the newsgroup. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| LAST | 跳转到最后一条消息 | 无 | 告知服务器将其当前文章指针设置为新闻组中的最后一条消息。 |'
- en: '| LIST | List Newsgroups | None | Asks the server to send a list of the newsgroups
    that it supports, along with the first and last article number in each group.
    The command as described in RFC 977 is simple, supporting no parameters and causing
    the full list of newsgroups to be sent to the client. NNTP command extensions
    significantly expand the syntax of this command, as described in the following
    section of this chapter. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| LIST | 列出新闻组 | 无 | 请求服务器发送它支持的新闻组列表，以及每个组中的第一条和最后一条文章编号。如RFC 977中描述的命令很简单，不支持参数，导致将新闻组的完整列表发送到客户端。NNTP命令扩展显著扩展了此命令的语法，如本章下一节所述。
    |'
- en: '| NEWGROUPS | List New Newsgroups | Date and time, and optional distribution
    specification | Prompts the server to send a list of new newsgroups created since
    the date and time specified. The client may also restrict the command to return
    only new newsgroups within a particular regional distribution. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| NEWGROUPS | 列出新新闻组 | 日期和时间，以及可选的分布规范 | 请求服务器发送自指定日期和时间以来创建的新新闻组的列表。客户端还可以限制命令只返回特定区域分布内的新闻组。
    |'
- en: '| NEWNEWS | List New News Articles | Date and time, and optional distribution
    specification | Requests a list from the server of all new articles that have
    arrived since a particular date and time. Like the NEWGROUPS command, this may
    be restricted in distribution. The server responds with a list of message IDs
    of new articles. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| NEWNEWS | 列出新新闻文章 | 日期和时间，以及可选的分布规范 | 从服务器请求自特定日期和时间以来到达的所有新文章的列表。与NEWGROUPS命令类似，这可能受到分布的限制。服务器会响应新文章的消息ID列表。
    |'
- en: '| NEXT | Go to Next Message | None | Advances the server''s current article
    pointer to the next message in the newsgroup. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| NEXT | 跳转到下一条消息 | 无 | 将服务器的当前文章指针移动到新闻组中的下一条消息。 |'
- en: '| POST | Post Article | None | Tells the server that the client would like
    to post a new article. The server responds with either a positive or negative
    acknowledgment. Assuming that posting is allowed, the client then sends the full
    text of the message to the server, which stores it and begins the process of propagating
    it to other servers. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| POST | 发布文章 | 无 | 告知服务器客户端想要发布新文章。服务器会响应一个肯定或否定的确认。假设发布是允许的，客户端随后将消息的全文发送到服务器，服务器将其存储并开始将其传播到其他服务器的过程。
    |'
- en: '| QUIT | End Session | None | Terminates the NNTP session. To be "polite,"
    the client should issue this command prior to closing the TCP connection. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| QUIT | 结束会话 | 无 | 终止NNTP会话。为了“礼貌”，客户端应在关闭TCP连接之前发出此命令。 |'
- en: '| SLAVE | Set Slave Status | None | Intended for use in special configurations
    where one NNTP server acts as a subsidiary to others. It is not often used in
    practice. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| SLAVE | 设置从属状态 | 无 | 适用于特殊配置，其中一个NNTP服务器作为其他服务器的辅助。在实际应用中不常用。 |'
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** The main NNTP standard defines a number of base NNTP commands
    that are used by the device initiating an NNTP connection to accomplish article
    propagation, posting, and reading functions. NNTP commands consist of a command
    code and, optionally, parameters that specify how the command is to be carried
    out.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 主要 NNTP 标准定义了一系列基础 NNTP 命令，这些命令由发起 NNTP 连接的设备使用，以完成文章传播、发布和阅读功能。NNTP
    命令由一个命令代码和可选的参数组成，这些参数指定了如何执行该命令。'
- en: NNTP Command Extensions
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NNTP 命令扩展
- en: The base command set described in RFC 977 was sufficient to enable client-server
    and interserver functionality, but in many ways, it was quite basic and limited
    in efficiency and usefulness. As Usenet grew larger and more popular in the late
    1980s, NNTP needed changes to improve its usability. In 1991, work began on a
    formal revision to the NNTP standard, but was never completed. Despite this, many
    of the concepts from that effort were adopted informally in NNTP implementations
    in subsequent years. In addition, some Usenet software authors created their own
    nonstandard features to improve the protocol, and some of these features also
    became de facto standards through widespread adoption.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 977 中描述的基本命令集足以支持客户端-服务器和服务器间功能，但在许多方面，它相当基础且在效率和实用性方面有限。随着 Usenet 在 1980
    年代末变得更大、更受欢迎，NNTP 需要改变以提高其可用性。1991 年，开始对 NNTP 标准进行正式修订的工作，但从未完成。尽管如此，该努力中的许多概念在随后的年份中非正式地被
    NNTP 实现所采用。此外，一些 Usenet 软件作者创建了他们自己的非标准功能来改进协议，其中一些功能也通过广泛采用而成为事实标准。
- en: As a result, by the late 1990s, most Usenet software actually implemented variations
    of NNTP with capabilities far exceeding what was documented in the standard. Naturally,
    not all NNTP software supported the same extra features, leading to potential
    compatibility difficulties between servers and clients. RFC 2980, "Common NNTP
    Extensions," was published in October 2000 to formalize many of these extensions
    to the base NNTP standard as defined in RFC 977.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到 1990 年代末，大多数 Usenet 软件实际上实现了 NNTP 的变体，其功能远超标准文档中记录的内容。自然地，并非所有 NNTP 软件都支持相同的额外功能，这可能导致服务器和客户端之间潜在的兼容性问题。RFC
    2980，“常见 NNTP 扩展”，于 2000 年 10 月发布，旨在正式化许多这些对基于 RFC 977 的基础 NNTP 标准的扩展。
- en: 'The NNTP extensions primarily consist of new NNTP commands that are added to
    the basic NNTP command set, as well as some minor changes to how other commands
    and functions of NNTP work. The extensions generally fall into three categories:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP 扩展主要包含新增的 NNTP 命令，这些命令被添加到基本的 NNTP 命令集中，以及一些对其他命令和 NNTP 功能的细微调整。这些扩展通常分为三类：
- en: Extensions that improve the efficiency of NNTP message transport between servers
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高服务器间 NNTP 消息传输效率的扩展
- en: Extensions that make NNTP more effective for client message access
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 NNTP 更有效地用于客户端消息访问的扩展
- en: Miscellaneous extensions, which don't fall into either of the preceding groups
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下不属于前述任一组的杂项扩展
- en: NNTP Transport Extensions
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NNTP 传输扩展
- en: The first group is called the NNTP *transport extensions* and consists of a
    small group of related commands that are designed to improve interserver message
    propagation. Most of these implement NNTP's *stream mode*, which provides a more
    effective way of moving large numbers of articles from one server to another,
    as described in the discussion of interserver communication earlier in this chapter.
    [Table 85-6](ch85s07.html#nntp_transport_extensions-id001 "Table 85-6. NNTP Transport
    Extensions") describes the new transport commands.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组被称为 NNTP *传输扩展*，它由一组相关的命令组成，旨在改善服务器之间的消息传播。其中大部分实现了 NNTP 的 *流模式*，这提供了一种更有效的方法，将大量文章从一个服务器移动到另一个服务器，正如本章前面关于服务器间通信的讨论中所述。[表
    85-6](ch85s07.html#nntp_transport_extensions-id001 "表 85-6. NNTP 传输扩展") 描述了新的传输命令。
- en: Table 85-6. NNTP Transport Extensions
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-6. NNTP 传输扩展
- en: '| Command Code | Command | Parameters | Description |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 参数 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| MODE STREAM | Set Stream Mode | None | Used to tell the server that the client
    wants to operate in stream mode, using the CHECK and TAKETHIS commands. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 流模式 | 无 | 用于告知服务器客户端希望以流模式操作，使用 CHECK 和 TAKETHIS 命令。 |'
- en: '| CHECK | Check If Article Exists | Message ID | Used in stream mode by a server
    acting as a client to ask another server if it has a copy of a particular article.
    The server responds back indicating whether or not it wishes to be sent a copy
    of the article. This command is similar to IHAVE, except that the client does
    not need to wait for a reply before sending the next command. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 检查 | 检查文章是否存在 | 消息 ID | 在流模式下，由作为客户端的服务器使用，以询问另一个服务器是否拥有特定文章的副本。服务器会回复表示是否希望收到该文章的副本。此命令类似于
    IHAVE，但客户端在发送下一个命令之前不需要等待回复。|'
- en: '| TAKETHIS | Send Article to Server | Message ID | When a server responds to
    a CHECK command indicating that it wants a copy of a particular message, the client
    sends it using this command. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| TAKETHIS | 将文章发送到服务器 | 消息 ID | 当服务器对 CHECK 命令做出响应，表示希望获得特定消息的副本时，客户端使用此命令发送它。|'
- en: '| XREPLIC | Replicate Articles | List of newsgroups and article numbers | Created
    for the special purpose of copying large numbers of articles from one server to
    another. It is not widely used. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| XREPLIC | 复制文章 | 新闻组和文章编号列表 | 为从一台服务器复制大量文章到另一台服务器的特殊目的而创建。它并不广泛使用。|'
- en: NNTP Newsreader Extensions
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NNTP 新闻阅读器扩展
- en: 'The second group of extensions defined by RFC 2980 consists of *newsreader
    extensions*, which focus primarily on commands used by newsreader clients in interactions
    with NNTP servers. These extensions consist of several new commands, as well as
    significant enhancements to one important command that was very limited in its
    functionality in RFC 977: LIST.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2980 定义的第二组扩展是 *新闻阅读器扩展*，这些扩展主要关注新闻阅读器客户端与 NNTP 服务器交互时使用的命令。这些扩展包括几个新命令，以及一个在
    RFC 977 中功能非常有限的重要命令 LIST 的重大增强。
- en: The original LIST command has no parameters and only allows a client to retrieve
    the entire list of newsgroups a server carries. This may have been sufficient
    when there were only a few hundred Usenet newsgroups, but there are now tens of
    thousands. RFC 2980 defines a number of new variations of the LIST command to
    allow the client much more flexibility in the types of information the server
    returns. [Table 85-7](ch85s07.html#nntp_list_command_extensions "Table 85-7. NNTP
    LIST Command Extensions") shows the new LIST command variations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 LIST 命令没有参数，只允许客户端检索服务器携带的所有新闻组的完整列表。当只有几百个 Usenet 新闻组时，这可能已经足够了，但现在有成千上万个。RFC
    2980 定义了 LIST 命令的多种新变体，以允许客户端在服务器返回的信息类型上有更大的灵活性。[表 85-7](ch85s07.html#nntp_list_command_extensions
    "表 85-7. NNTP LIST 命令扩展") 显示了新的 LIST 命令变体。
- en: Table 85-7. NNTP LIST Command Extensions
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-7. NNTP LIST 命令扩展
- en: '| Command Code | Command | Parameters | Description |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 参数 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| LIST ACTIVE | List Active Newsgroups | Newsgroup name or pattern | Provides
    a list of active newsgroups on the server. This is semantically the same as the
    original LIST command, but the client may provide a newsgroup name or a pattern
    to restrict the number of newsgroups returned. For example, the client can ask
    for a list of only the newsgroups that contain "football" in them. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 列出活跃组 | 列出活跃新闻组 | 新闻组名称或模式 | 提供服务器上活跃新闻组的列表。这在语义上与原始的 LIST 命令相同，但客户端可以提供一个新闻组名称或模式来限制返回的新闻组数量。例如，客户端可以请求只包含“football”的新闻组列表。|'
- en: '| LIST ACTIVE.TIMES | List Active Newsgroup Creation Times | None | Prompts
    the server to send the client its *active.times* file, which contains information
    about when the newsgroups carried by the server were created. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 列出活跃新闻组创建时间 | 列出活跃新闻组创建时间 | 无 | 促使服务器向客户端发送其 *active.times* 文件，该文件包含有关服务器携带的新闻组创建时间的信息。|'
- en: '| LIST DISTRIBUTIONS | List Distributions | None | Causes the server to sent
    the client the contents of the *distributions* file, which shows what regional
    distribution strings the server recognizes (for use in the Distribution header
    of a message). |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 列出分发 | 列出分发 | 无 | 使服务器向客户端发送 *distributions* 文件的内容，该文件显示了服务器识别的区域分发字符串（用于消息的分发标题）。|'
- en: '| LIST DISTRIB.PATS | List Distribution Patterns | None | Asks the server for
    its *distribution.pats* file, which is like the distributions file but uses patterns
    to summarize distribution information for different newsgroups. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 列出分发模式 | 列出分发模式 | 无 | 向服务器请求其 *distribution.pats* 文件，该文件类似于分发文件，但使用模式来总结不同新闻组的分发信息。|'
- en: '| LIST NEWSGROUPS | List Newsgroups | Newsgroup name or pattern | Provides
    a list of newsgroup names and descriptions. This differs from LIST ACTIVE in that
    only the newsgroup name and description are returned, not the article numbers
    for each newsgroup. It is functionally the same as XGTITLE (see [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "Table 85-8. NNTP Newsreader Extensions")) and is usually employed by a user to
    locate a newsgroup to be added to his or her subscribed list. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| LIST NEWSGROUPS | 列出新闻组 | 新闻组名称或模式 | 提供新闻组名称和描述的列表。与 LIST ACTIVE 不同，它只返回新闻组名称和描述，而不返回每个新闻组的文章编号。在功能上与
    XGTITLE 相同（参见[表 85-8](ch85s07.html#nntp_newsreader_extensions-id001 "表 85-8. NNTP
    新闻阅读器扩展")），通常由用户用来定位要添加到其订阅列表中的新闻组。|'
- en: '| LIST OVERVIEW.FMT | Display Overview Format | None | Prompts the server to
    display information about the format of its *overview* file. See the XOVER command
    description in [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001 "Table 85-8. NNTP
    Newsreader Extensions") for more information. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| LIST OVERVIEW.FMT | 显示概要格式 | 无 | 促使服务器显示其 *概要* 文件的格式信息。有关更多信息，请参见[表 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "表 85-8. NNTP 新闻阅读器扩展")中的 XOVER 命令描述。|'
- en: '| LIST SUBSCRIPTIONS | Retrieve Default Subscription List | None | Asks the
    server to send the client a default list of subscribed newsgroups. This is used
    to set up a new user with a suggested list of newsgroups. For example, if an organization
    has an internal support newsgroup, it could put this group on the default subscription
    list so all new users learn about it immediately when they first start up their
    newsreader. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| LIST SUBSCRIPTIONS | 获取默认订阅列表 | 无 | 请求服务器向客户端发送默认的新闻组订阅列表。这用于为新用户设置一个建议的新闻组列表。例如，如果一个组织有一个内部支持新闻组，它可以将这个组放在默认订阅列表中，这样所有新用户在第一次启动新闻阅读器时就能立即了解它。|'
- en: In addition to these changes to the LIST command, many new newsreader-related
    command extensions are defined, which are described in [Table 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "Table 85-8. NNTP Newsreader Extensions").
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对 LIST 命令的这些更改外，还定义了许多与新闻阅读器相关的命令扩展，这些扩展在[表 85-8](ch85s07.html#nntp_newsreader_extensions-id001
    "表 85-8. NNTP 新闻阅读器扩展")中进行了描述。
- en: Table 85-8. NNTP Newsreader Extensions
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 表 85-8. NNTP 新闻阅读器扩展
- en: '| Command Code | Command | Parameters | Description |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 命令代码 | 命令 | 参数 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| LISTGROUP | List Article Numbers In Newsgroup | Newsgroup name | Causes the
    server to return a list of local article numbers for the current messages in the
    newsgroup. The server''s current article pointer is also set to the first message
    in the group. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| LISTGROUP | 列出新闻组中的文章编号 | 新闻组名称 | 使服务器返回当前新闻组中当前消息的本地文章编号列表。服务器当前的文章指针也设置为组中的第一条消息。|'
- en: '| MODE READER | Set Newsreader Mode | None | Tells the server that the device
    acting as a client is a client newsreader and not another NNTP server. While technically
    not required—all commands can be sent by any device acting as client—some servers
    may be optimized to respond to newsreader-oriented commands if given this command.
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| MODE READER | 设置新闻阅读器模式 | 无 | 告知服务器，作为客户端的设备是一个客户端新闻阅读器，而不是另一个 NNTP 服务器。虽然技术上不是必需的——所有命令都可以由任何充当客户端的设备发送——一些服务器可能被优化以响应新闻阅读器相关的命令，如果给出此命令。|'
- en: '| XGTITLE | Retrieve Newsgroup Descriptions | Newsgroup name or pattern | Used
    to list the descriptions for a newsgroup or a set of newsgroups matching a particular
    text pattern. This command is functionally the same as the LIST NEWSGROUP command
    extension (see [Table 85-7](ch85s07.html#nntp_list_command_extensions "Table 85-7. NNTP
    LIST Command Extensions")). It is therefore recommended that XGTITLE no longer
    be used. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| XGTITLE | 获取新闻组描述 | 新闻组名称或模式 | 用于列出与特定文本模式匹配的新闻组或一组新闻组的描述。此命令在功能上与 LIST NEWSGROUP
    命令扩展相同（参见[表 85-7](ch85s07.html#nntp_list_command_extensions "表 85-7. NNTP LIST
    命令扩展")）。因此，建议不再使用 XGTITLE。|'
- en: '| XHDR | Retrieve Article Headers | Header name and optionally, either a message
    ID or a range of article numbers | Allows a client to ask for only a particular
    header from a set of messages. If only the header name is provided, the header
    is returned for all messages in the current group. Otherwise, the header is provided
    for the selected messages. This extension provides a newsreader client with a
    more efficient way of retrieving and displaying important headers in a newsgroup
    to a user. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| XHDR | 获取文章标题 | 标题名称以及可选的消息ID或文章编号范围 | 允许客户端请求从一组消息中只获取特定的标题。如果只提供了标题名称，则返回当前组中所有消息的标题。否则，为所选消息提供标题。此扩展为新闻阅读器客户端提供了一种更高效的方式，用于检索和向用户显示新闻组中的重要标题。
    |'
- en: '| XINDEX | Retrieve Index Information | Newsgroup name | Retrieves an *index*
    file, used by the newsreader called *TIN* to improve the efficiency of newsgroup
    perusal. TIN now supports the more common overview format, so the XOVER command
    is preferred to this one. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| XINDEX | 获取索引信息 | 新闻组名称 | 获取索引文件，该文件由名为*TIN*的新闻阅读器使用，以提高浏览新闻组的效率。TIN现在支持更常见的概览格式，因此XOVER命令比这个命令更受欢迎。
    |'
- en: '| XOVER | Retrieve Overview Information | Article number or range of article
    numbers in a newsgroup | Retrieves the *overview* for an article or set of articles.
    Servers supporting this feature maintain a special database for their newsgroups
    that contains information about current articles in a format that can be used
    by a variety of newsreaders. Retrieving the overview information allows features
    like message threading to be performed more quickly than if the client had to
    retrieve the headers of each message and analyze them manually. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| XOVER | 获取概览信息 | 新闻组中的文章编号或文章编号范围 | 获取文章或一系列文章的概览。支持此功能的服务器维护一个特殊数据库，其中包含关于新闻组中当前文章的信息，该信息可以由各种新闻阅读器使用。检索概览信息允许像消息线程这样的功能比客户端必须检索每条消息的标题并手动分析它们更快地执行。
    |'
- en: '| XPAT | Retrieve Article Headers Matching a Pattern | Header name, pattern,
    and either a message ID or a range of article numbers | Similar to XHDR in that
    it allows a particular header to be retrieved for a set of messages. The difference
    is that the client can specify a pattern that must be matched for the header to
    be retrieved. This allows the client to have the server search for and return
    certain messages, such as those with a subject line indicating a particular type
    of discussion, rather than requiring the client to download all the headers and
    search through them. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| XPAT | 获取匹配模式的文章标题 | 标题名称、模式以及消息ID或文章编号范围 | 与XHDR类似，它允许为消息集检索特定的标题。区别在于客户端可以指定一个必须匹配的图案，以便检索标题。这允许客户端让服务器搜索并返回某些消息，例如那些主题行表明特定类型讨论的消息，而不是要求客户端下载所有标题并搜索它们。
    |'
- en: '| XPATH | Retrieve File Name Information | Message ID | Allows a client to
    ask for the name of the actual file in which a particular message is stored on
    the server. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| XPATH | 获取文件名信息 | 消息ID | 允许客户端请求在服务器上存储特定消息的实际文件名。 |'
- en: '| XROVER | Retrieve Overview Reference Information | Article number or range
    of article numbers in a newsgroup | Like the XOVER command, but specifically retrieves
    information in the References header for the indicated articles. This is the header
    containing the data needed to create threaded conversations. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| XROVER | 获取概览引用信息 | 新闻组中的文章编号或文章编号范围 | 与XOVER命令类似，但专门检索指定文章的引用标题中的信息。这是包含创建线程对话所需数据的标题。
    |'
- en: '| XTHREAD | Retrieve Threading Information | Optional DBINIT parameter | Similar
    to XINDEX, but retrieves a special threading information file in the format used
    by the newsreader named *TRN*. Like TIN, TRN now supports the common overview
    format, so XOVER is preferred to this command. The DBINIT parameter can be used
    to check for the existence of a thread database. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| XTHREAD | 获取线程信息 | 可选的DBINIT参数 | 与XINDEX类似，但检索由名为*TRN*的新闻阅读器使用的特殊线程信息文件。像TIN一样，TRN现在支持常见的概览格式，因此XOVER比此命令更受欢迎。DBINIT参数可用于检查线程数据库的存在。
    |'
- en: Other NNTP Extensions
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他NNTP扩展 |
- en: 'The last extension group contains the miscellaneous extensions not strictly
    related to either interserver or client-server NNTP interaction. There are two
    commands in this group: AUTHINFO and DATE. The latter is a simple command that
    causes the server to tell the client its current date and time. AUTHINFO is more
    interesting. It is used by a client to provide authentication data to a server.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个扩展组包含与服务器间或客户端-服务器NNTP交互不严格相关的杂项扩展。该组中有两个命令：AUTHINFO和DATE。后者是一个简单的命令，会导致服务器告诉客户端其当前的日期和时间。AUTHINFO则更有趣。它被客户端用来向服务器提供身份验证数据。
- en: You may have noticed that there are no commands related to security described
    in the RFC 977 protocol. That's because the original NNTP had no security features
    whatsoever. Like many protocols written before the modern Internet era, security
    was not considered a big issue back in the early 1980s. Most news servers were
    used only by people within the organization owning the server, and simple security
    measures were used, such as restricting access to servers by IP address or through
    the use of access lists.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在RFC 977协议中没有描述与安全相关的命令。这是因为原始NNTP根本没有任何安全功能。像许多在互联网时代之前编写的协议一样，在20世纪80年代初，安全性并没有被视为一个大问题。大多数新闻服务器仅由拥有该服务器的组织内部人员使用，并使用了简单的安全措施，例如通过IP地址或使用访问列表来限制对服务器的访问。
- en: One of the more important changes made by many NNTP software implementations
    as soon as Usenet grew in size was to require authentication. Modern clients will
    usually issue AUTHINFO as one of their first commands on establishing a connection
    to a server, because the server will refuse to accept most other commands before
    this is done. A special reply code is also added to NNTP for a server to use if
    it rejects a command due to improper authentication.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在Usenet规模扩大的早期，许多NNTP软件实现所做的更重要改变之一是要求进行身份验证。现代客户端通常会在建立与服务器连接时，将AUTHINFO作为它们的第一条命令之一发出，因为服务器在完成此操作之前将拒绝接受大多数其他命令。如果服务器因身份验证不正确而拒绝命令，还会添加一个特殊的回复代码到NNTP中。
- en: The AUTHINFO command can be invoked in several different ways. The original
    version of the command required the client to issue an AUTHINFO USER command with
    a user name, followed by AUTHINFO PASS with a password. This is simple user/password
    login authentication. A variation of this is the AUTHINFO SIMPLE command, where
    the client needs to send just a password.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: AUTHINFO命令可以通过几种不同的方式调用。命令的原始版本要求客户端发出一个带有用户名的AUTHINFO USER命令，然后是带有密码的AUTHINFO
    PASS。这是一种简单的用户/密码登录身份验证。这种变体的AUTHINFO SIMPLE命令，客户端只需要发送一个密码。
- en: A client and server can also agree to use more sophisticated authentication
    methods by employing the AUTHINFO GENERIC command. The client provides to the
    server the name of the authentication method it wants to use, along with any arguments
    required for authentication. The client and server then exchange messages and
    authentication information as required by the particular authenticator they are
    using.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器还可以通过使用AUTHINFO GENERIC命令来同意使用更复杂的身份验证方法。客户端向服务器提供它想要使用的身份验证方法的名称，以及身份验证所需的任何参数。然后，客户端和服务器根据他们使用的特定身份验证器交换消息和身份验证信息。
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A number of limitations in its base command set led to a proliferation
    of nonstandard enhancements to NNTP during the 1980s and 1990s. These were eventually
    documented in a set of NNTP command extensions that formally supplement the original
    RFC 977 commands. The extensions are conceptually divided into three groups: transport
    extensions that refine how NNTP propagates messages, newsreader extensions that
    improve client article access, and miscellaneous extensions. The most important
    miscellaneous extension is AUTHINFO, which adds security to NNTP.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 基本命令集的许多限制导致了20世纪80年代和90年代NNTP的非标准增强的激增。这些最终被记录在一系列NNTP命令扩展中，这些扩展正式补充了原始RFC
    977命令。这些扩展在概念上分为三组：传输扩展，它细化了NNTP传播消息的方式；新闻阅读器扩展，它改善了客户端文章访问；以及杂项扩展。最重要的杂项扩展是AUTHINFO，它为NNTP增加了安全性。'
- en: NNTP Status Responses and Response Codes
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NNTP状态响应和响应代码
- en: 'Each time the device acting as a client in an NNTP connection sends a command,
    the server sends back a *response*. The response serves to acknowledge receipt
    of the command, to inform the client of the results of processing the command,
    and possibly to prompt for additional information. Since NNTP commands are structured
    and formatted in a way very similar to that of SMTP commands, I''m sure it will
    come as no great surprise that NNTP responses are very similar to those of SMTP
    (described in [Chapter 77](ch77.html "Chapter 77. TCP/IP ELECTRONIC MAIL DELIVERY
    PROTOCOL: THE SIMPLE MAIL TRANSFER PROTOCOL (SMTP)")). In turn, SMTP responses
    are based on the system designed for replies in FTP.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 每次作为NNTP连接中客户端角色的设备发送命令时，服务器都会发送一个*响应*。响应用于确认收到命令，通知客户端命令处理的结果，并可能提示提供更多信息。由于NNTP命令的结构和格式与SMTP命令非常相似，我相信NNTP响应与SMTP（在第77章中描述）非常相似，这不会让人感到惊讶。反过来，SMTP响应基于FTP中设计的回复系统。
- en: The first line of an NNTP response consists of a three-digit numerical *response
    code*, as well as a line of descriptive text that summarizes the response. These
    response codes are structured so that each digit has a particular significance,
    which allows the client to quickly determine the status of the command to which
    the reply was sent. After the initial response line, depending on the reply, a
    number of additional response lines may follow. For example, a successful LIST
    command results in a 215 response code, followed by a list of newsgroups.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: NNTP响应的第一行包含一个三位数的数值*响应代码*，以及一行描述性文本，总结响应内容。这些响应代码的结构使得每个数字都有特定的意义，允许客户端快速确定回复所针对的命令的状态。在初始响应行之后，根据回复的不同，可能会跟随着多个附加的响应行。例如，成功的LIST命令会产生一个215响应代码，随后是新闻组的列表。
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *The discussion of FTP reply codes in [Chapter 72](ch72.html
    "Chapter 72. FILE TRANSFER PROTOCOL (FTP)") explains the reasons why numeric reply
    codes are used in addition to descriptive text*.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *[第72章](ch72.html "第72章. 文件传输协议 (FTP)")中关于FTP响应代码的讨论解释了为什么除了描述性文本外还使用数值响应代码*。'
- en: 'As with SMTP and FTP, NNTP reply codes can be considered to be of the form
    *xyz*, where *x* is the first digit, *y* the second, and *z* the third. The first
    reply code digit (*x*) indicates the success, failure, or progress of the command
    in general terms; whether a successful command is complete or incomplete; and
    the general reason why an unsuccessful command did not work. The values of this
    digit are defined slightly differently than they are in SMTP and FTP. In some
    cases, the terminology is just simplified; for example, the second category is
    Command OK, instead of the more cryptic Positive Completion Reply. [Table 85-9](ch85s08.html#nntp_reply_code_format_first_digit_inter
    "Table 85-9. NNTP Reply Code Format: First Digit Interpretation") shows the specific
    meaning of the possible values of this digit.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与SMTP和FTP一样，NNTP响应代码可以认为是*xyz*的形式，其中*x*是第一位数字，*y*是第二位，*z*是第三位。第一个响应代码数字(*x*)表示命令在一般意义上的成功、失败或进度；一个成功的命令是否完成或未完成；以及一个未成功的命令未能工作的主要原因。这个数字的值与SMTP和FTP中定义的略有不同。在某些情况下，术语被简化了；例如，第二类是命令已确认，而不是更晦涩的Positive
    Completion Reply。[表85-9](ch85s08.html#nntp_reply_code_format_first_digit_inter
    "表85-9. NNTP响应代码格式：第一位数字解释")显示了该数字可能值的特定含义。
- en: 'Table 85-9. NNTP Reply Code Format: First Digit Interpretation'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 表85-9. NNTP响应代码格式：第一位数字解释
- en: '| Reply Code Format | Meaning | Description |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 响应代码格式 | 含义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1yz | Informative Message | General information; used for help information
    and debugging. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 1yz | 信息性消息 | 通用信息；用于帮助信息和调试。|'
- en: '| 2yz | Command OK | The command was completed successfully. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 2yz | 命令已确认 | 命令已成功完成。|'
- en: '| 3yz | Command OK So Far; Send the Rest | An intermediate reply, sent to prompt
    the client to send more information. Typically used for replies to commands such
    as IHAVE or POST, where the server acknowledges the command, and then requests
    that an article be transmitted by the client. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 3yz | 命令已确认，请发送剩余部分 | 这是一个中间回复，用于提示客户端发送更多信息。通常用于对IHAVE或POST等命令的回复，服务器确认命令后，请求客户端传输文章。|'
- en: '| 4yz | Command Was Correct, but Couldn''t Be Performed | The command was valid
    but could not be performed. This type of error usually occurs due to bad parameters,
    a transient problem with the server, a bad command sequence, or similar situations.
    |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 4yz | 命令正确，但无法执行 | 命令有效但无法执行。此类错误通常由于参数错误、服务器暂时性问题、错误的命令序列或类似情况引起。|'
- en: '| 5yz | Command Unimplemented or Incorrect, or Serious Program Error | The
    command was invalid or a significant program error prevented it from being performed.
    |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 5yz | 命令未实现或错误，或严重程序错误 | 命令无效或严重的程序错误阻止了其执行。|'
- en: 'The second reply code digit (*y*) is used to categorize messages into functional
    groups. This digit is used in the same general way as in SMTP and FTP, but the
    functional groups are different, as described in [Table 85-10](ch85s08.html#nntp_reply_code_format_second_digit_inte
    "Table 85-10. NNTP Reply Code Format: Second Digit Interpretation").'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回复代码数字（*y*）用于将消息分类到功能组。这个数字与SMTP和FTP中的使用方式相同，但功能组不同，如[表85-10](ch85s08.html#nntp_reply_code_format_second_digit_inte
    "表85-10. NNTP回复代码格式：第二个数字解释")中所述。
- en: 'Table 85-10. NNTP Reply Code Format: Second Digit Interpretation'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 表85-10. NNTP回复代码格式：第二个数字解释
- en: '| Reply Code Format | Meaning | Description |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 回复代码格式 | 含义 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| x0z | Connection, Setup, and Miscellaneous | Generic and miscellaneous replies.
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| x0z | 连接、设置和杂项 | 通用和杂项回复。|'
- en: '| x1z | Newsgroup Selection | Messages related to commands used to select a
    newsgroup. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| x1z | 新闻组选择 | 与用于选择新闻组的命令相关的消息。|'
- en: '| x2z | Article Selection | Messages related to commands used to select an
    article. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| x2z | 文章选择 | 与用于选择文章的命令相关的消息。|'
- en: '| x3z | Distribution Functions | Messages related to the transfer of messages.
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| x3z | 分布函数 | 与消息传输相关的消息。|'
- en: '| x4z | Posting | Messages related to posting messages. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| x4z | 发布 | 与发布消息相关的消息。|'
- en: '| x5z | Authentication | Messages related to authentication and the AUTHINFO
    command extension. (This category is not officially listed in the standard, but
    these responses have a middle digit of 5.) |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| x5z | 认证 | 与认证和AUTHINFO命令扩展相关的消息。（此类别在标准中未正式列出，但这些响应的中间数字为5。）|'
- en: '| x8z | Nonstandard Extensions | Reserved for private, nonstandard implementation
    use. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| x8z | 非标准扩展 | 保留用于私有、非标准实现使用。|'
- en: '| x9z | Debugging | Debugging output messages. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| x9z | 调试 | 调试输出消息。|'
- en: The third reply code digit (*z*) indicates a specific type of message within
    each of the functional groups described by the second digit. The third digit allows
    each functional group to have ten different reply codes for each reply type given
    by the first code digit.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个回复代码数字（*z*）表示第二个数字描述的功能组中的特定消息类型。第三个数字允许每个功能组对于第一个代码数字给出的每个回复类型有十个不同的回复代码。
- en: As in FTP and SMTP, these *x*, *y*, and *z* digit meanings are combined to make
    specific reply codes. For example, the reply code 435 is sent by the server if
    a client issues the IHAVE command but the server doesn't want the article being
    offered. The command was correct but the reply is negative, thus it starts with
    4, and the message is related to message distribution, so the middle digit is
    3.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 与FTP和SMTP一样，这些*x*、*y*和*z*数字的含义组合起来形成特定的回复代码。例如，如果客户端发出IHAVE命令但服务器不希望提供文章，服务器会发送回复代码435。命令是正确的，但回复是负面的，因此以4开头，并且消息与消息分发相关，因此中间数字为3。
- en: '[Table 85-11](ch85s08.html#nntp_reply_codes "Table 85-11. NNTP Reply Codes")
    contains a list of some of the more common NNTP reply codes in numerical order,
    along with typical reply text from the standard and additional descriptive information.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[表85-11](ch85s08.html#nntp_reply_codes "表85-11. NNTP回复代码")包含了一些更常见的NNTP回复代码列表，按数字顺序排列，以及来自标准的典型回复文本和额外的描述信息。'
- en: Table 85-11. NNTP Reply Codes
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 表85-11. NNTP回复代码
- en: '| Reply Code | Reply Text | Description |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 回复代码 | 回复文本 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 100 | help text follows | Precedes response to HELP command. |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 接下来是帮助文本 | 在对HELP命令的响应之前发送。|'
- en: '| 111 | (date and time) | Response to DATE command extension. |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| 111 | （日期和时间）| 对DATE命令扩展的响应。|'
- en: '| 199 | (debugging output) | Debugging information. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 199 | （调试输出）| 调试信息。|'
- en: '| 200 | server ready - posting allowed | Sent by the server on initiation of
    the session, if the client is allowed to post messages. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 200 | 服务器就绪 - 允许发布 | 在会话初始化时由服务器发送，如果客户端被允许发布消息。|'
- en: '| 201 | server ready - no posting allowed | Sent by the server on initiation
    of the session, if the client is not allowed to post messages. |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 201 | 服务器就绪 - 不允许发布 | 在会话初始化时由服务器发送，如果客户端不允许发布消息。|'
- en: '| 202 | slave status noted | Response to the SLAVE command. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 202 | 已记录从属状态 | 对 SLAVE 命令的响应。|'
- en: '| 203 | streaming is ok | Successful response to MODE STREAM command. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 203 | 流式传输正常 | 对 MODE STREAM 命令的成功响应。|'
- en: '| 205 | closing connection - goodbye! | Goodbye message sent in response to
    a QUIT message. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 205 | 关闭连接 - 再见！ | 在收到 QUIT 消息后发送的再见信息。|'
- en: '| 211 | n f l s group selected | Successful response to the GROUP command,
    indicating the estimated number of messages in the group (*n*), first and last
    article numbers (*f* and *l*) and group name (*s*). |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 211 | n f l s 已选择组 | 对 GROUP 命令的成功响应，指示组中估计的消息数量 (*n*)、第一和最后文章编号 (*f* 和 *l*)
    以及组名 (*s*)。|'
- en: '| 215 | list of newsgroups follows (OR) information follows | Successful response
    to LIST command. The second form is for variations of LIST defined as NNTP command
    extensions. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 215 | 随后跟有新闻组列表 (或) 随后跟有信息 | 对 LIST 命令的成功响应。第二种形式是针对作为 NNTP 命令扩展定义的 LIST
    变体。|'
- en: '| 218 | tin-style index follows | Successful response to XINDEX command extension.
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 218 | 随后跟有 tin 风格索引 | 对 XINDEX 命令扩展的成功响应。|'
- en: '| 220 | n <a> article retrieved - head and body follow | Successful response
    to the ARTICLE command, indicating the article number and message ID of the article.
    |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 220 | n <a> 文章已检索 - 头部和正文随后 | 对 ARTICLE 命令的成功响应，指示文章编号和消息ID。|'
- en: '| 221 | n <a> article retrieved - head follows | Successful response to the
    HEAD command, indicating the article number and message ID of the article. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 221 | n <a> 文章已检索 - 头部信息随后 | 对 HEAD 命令的成功响应，指示文章编号和消息ID。|'
- en: '| 222 | n <a> article retrieved - body follows | Successful response to the
    BODY command, indicating the article number and message ID of the article. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 222 | n <a> 文章已检索 - 正文信息随后 | 对 BODY 命令的成功响应，指示文章编号和消息ID。|'
- en: '| 223 | n <a> article retrieved - request text separately | Successful response
    to the STAT command, indicating the article number and message ID of the article.
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 223 | n <a> 文章已检索 - 请求单独发送文本 | 对 STAT 命令的成功响应，指示文章编号和消息ID。|'
- en: '| 224 | overview information follows | Successful response to the XOVER command
    extension. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 224 | 随后跟有概要信息 | 对 XOVER 命令扩展的成功响应。|'
- en: '| 230 | list of new articles by message-id follows | Successful response to
    the NEWNEWS command. |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 230 | 按消息ID列出新文章 | 对 NEWNEWS 命令的成功响应。|'
- en: '| 235 | article transferred ok | Successful response to the IHAVE command,
    after the article has been sent. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 235 | 文章已成功传输 | 在文章发送后对 IHAVE 命令的成功响应。|'
- en: '| 239 | article transferred ok | Successful response to the TAKETHIS command.
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 239 | 文章已成功传输 | 对 TAKETHIS 命令的成功响应。|'
- en: '| 240 | article posted ok | Successful response to the POST command, after
    the article has been posted. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 240 | 文章已成功发布 | 在文章发布后对 POST 命令的成功响应。|'
- en: '| 250 or 281 | authentication accepted | Successful authentication using the
    AUTHINFO command extension. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 250 或 281 | 认证接受 | 使用 AUTHINFO 命令扩展成功认证。|'
- en: '| 282 | list of groups and descriptions follows | Positive response to the
    XGTITLE command extension. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 282 | 随后跟有组和描述列表 | 对 XGTITLE 命令扩展的积极响应。|'
- en: '| 288 | binary data to follow | Successful response to the XTHREAD command
    extension. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 288 | 随后跟有二进制数据 | 对 XTHREAD 命令扩展的成功响应。|'
- en: '| 335 | send article to be transferred | Preliminary response to the IHAVE
    command. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 335 | 将文章发送以供传输 | 对 IHAVE 命令的初步响应。|'
- en: '| 340 | send article to be posted | Preliminary response to the POST command.
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 340 | 将文章发送以供发布 | 对 POST 命令的初步响应。|'
- en: '| 381 | more authentication information required | Preliminary response to
    the AUTHINFO command extension. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 381 | 需要更多认证信息 | 对 AUTHINFO 命令扩展的初步响应。|'
- en: '| 400 | service discontinued | Session is being terminated, perhaps due to
    user request. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 400 | 服务已中断 | 会话正在终止，可能是由于用户请求。|'
- en: '| 411 | no such newsgroup | Invalid newsgroup name specified. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 411 | 没有这样的新闻组 | 指定的新闻组名称无效。|'
- en: '| 412 | no newsgroup has been selected | Attempt to issue a command that refers
    to the current newsgroup before one has been selected using GROUP. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 412 | 没有选择新闻组 | 在使用 GROUP 命令选择新闻组之前尝试发出引用当前新闻组的命令。|'
- en: '| 420 | no current article has been selected | Attempt to issue a command that
    refers to the current article using the server''s current article pointer, before
    the pointer has been set through article selection. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 420 | 没有当前文章被选中 | 在通过文章选择设置指针之前，尝试使用服务器的当前文章指针发布涉及当前文章的命令。|'
- en: '| 421 | no next article in this group | Response to NEXT command when at the
    last article of a newsgroup. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 421 | 本组中没有下一篇文章 | 在新闻组的最后一篇文章时对NEXT命令的响应。|'
- en: '| 422 | no previous article in this group | Possible response to LAST (I have
    no idea why the word "previous" is in there). |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 422 | 本组中没有上一篇文章 | 可能是LAST的响应（我不知道为什么“previous”这个词在那里）。|'
- en: '| 423 | no such article number in this group | Command with invalid article
    number. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 423 | 本组中没有这样的文章编号 | 无效文章编号的命令。|'
- en: '| 430 | no such article found | Article not found; it may have been deleted.
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 430 | 找不到这样的文章 | 文章未找到；它可能已被删除。|'
- en: '| 435 | article not wanted - do not send it | Negative response to IHAVE if
    server doesn''t need the article. |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 435 | 文章不受欢迎 - 不要发送 | 如果服务器不需要文章，则对IHAVE的负面响应。|'
- en: '| 436 | transfer failed - try again later | Temporary failure of article transfer;
    retry. |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 436 | 转移失败 - 尝试稍后重试 | 文章传输暂时失败；重试。|'
- en: '| 437 | article rejected - do not try again | Article refused for whatever
    reason. |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 437 | 文章被拒绝 - 不要再尝试 | 由于任何原因拒绝文章。|'
- en: '| 438 | already have it, please don''t send it to me | Same as reply code 435,
    but for the CHECK command extension. |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 438 | 我已经有了，请不要发给我 | 与回复代码435相同，但针对CHECK命令扩展。|'
- en: '| 440 | posting not allowed | POST command issued when posting is not allowed.
    |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 440 | 发布不允许 | 在不允许发布时发布POST命令。|'
- en: '| 441 | posting failed | POST command failed. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 441 | 发布失败 | POST命令失败。|'
- en: '| 450 | authorization required for this command | Response sent when server
    requires authentication but client has not yet authenticated. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 450 | 此命令需要授权 | 当服务器需要认证但客户端尚未认证时发送的响应。|'
- en: '| 452 | authorization rejected | Failed authentication. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 452 | 授权被拒绝 | 认证失败。|'
- en: '| 480 | transfer permission denied | Response to CHECK if transfer is not allowed.
    |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 480 | 转移权限被拒绝 | 如果不允许转移，则对CHECK的响应。|'
- en: '| 500 | command not recognized | Bad command. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 命令未识别 | 坏命令。|'
- en: '| 501 | command syntax error | Bad syntax in command. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 501 | 命令语法错误 | 命令中的语法错误。|'
- en: '| 502 | access restriction or permission denied | Permission denied; sent if
    the client has not properly authentication but the server requires it. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 502 | 访问限制或权限被拒绝 | 权限被拒绝；如果客户端没有正确认证但服务器需要它，则发送。|'
- en: '| 503 | program fault - command not performed | General fatal error message.
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 503 | 程序故障 - 命令未执行 | 通用致命错误消息。|'
- en: Tip
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Each command sent by the device acting as the client in an
    NNTP connection results in the server returning a reply. NNTP replies consist
    of a three-digit reply code and a string of descriptive text. These codes are
    modeled after those of SMTP, and in turn, FTP.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 每个作为NNTP连接中客户端的设备发送的命令都会导致服务器返回一个回复。NNTP回复由三位数的回复代码和一系列描述性文本组成。这些代码是模仿SMTP的，进而模仿FTP。'
- en: Chapter 86. GOPHER PROTOCOL (GOPHER)
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第86章。GOPHER协议（GOPHER）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: 'Let''s suppose that I told you I was going to describe a TCP/IP application
    layer protocol designed for the specific purpose of distributed document search
    and retrieval. This protocol uses a client/server model of operation, where servers
    provide links to related resources such as files or programs that users access
    with client software that displays options for the user to select. You might think
    that I was talking about the World Wide Web, and for good reason. However, in
    this case, I am actually talking about one of the Web''s predecessors: the *Gopher
    Protocol*.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我告诉你我将要描述一个专为分布式文档搜索和检索而设计的TCP/IP应用层协议。此协议使用客户端/服务器模型进行操作，其中服务器提供指向相关资源的链接，例如文件或程序，用户通过显示用户选择选项的客户端软件访问这些资源。你可能认为我在谈论万维网，而且有很好的理由。然而，在这种情况下，我实际上在谈论网络的先驱之一：*Gopher协议*。
- en: In this chapter, I briefly describe Gopher's history, operation, differences
    from the World Wide Web, and role in the modern Internet.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要描述了Gopher的历史、操作、与万维网的差异以及在现代互联网中的作用。
- en: Gopher Overview and General Operation
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopher概述和一般操作
- en: A good place to start our discussion of this protocol is with its name, which
    is well chosen for a number of reasons. The Gopher Protocol was developed at the
    University of Minnesota, whose sports teams are called the Golden Gophers (Minnesota
    is known as the Gopher State). This is the direct origin of the name, but it is
    also appropriate because the rodent that shares it is known for burrowing, just
    as the protocol is designed to "burrow" through the Internet. And of course, the
    term *gopher* also applies to a person who performs errands, such as retrieving
    documents (they "go fer" this and "go fer" that).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论此协议的一个好地方是从其名称开始，这个名字选择得很好，有多个原因。Gopher 协议是在明尼苏达大学开发的，该校的体育队伍被称为金戈菲尔（明尼苏达州被称为戈菲州）。这是名称的直接来源，但这也很合适，因为共享这个名字的啮齿动物以挖掘而闻名，就像协议被设计成“挖掘”通过互联网一样。当然，术语
    *gopher* 也适用于执行差事的人，例如检索文档（他们“go fer”这个，“go fer”那个）。
- en: The Gopher Protocol was developed in the late 1980s to provide a mechanism for
    organizing documents for easy access by students and faculty at the university.
    The core principle that guided the development of the system was *simplicity*.
    Gopher is designed on the basis of a small number of core principles, and it uses
    a very straightforward mechanism for passing information between client and server
    devices. It is described in RFC 1436, published in March 1993.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Gopher 协议是在 20 世纪 80 年代末期开发的，旨在为大学的学生和教师提供一个组织文档的机制，以便他们可以轻松访问。指导系统开发的核心理念是
    *简单性*。Gopher 是基于少数核心原则设计的，并且它使用一种非常直接的机制在客户端和服务器设备之间传递信息。它被描述在 1993 年 3 月发布的 RFC
    1436 中。
- en: Information Storage on Gopher Servers
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gopher 服务器上的信息存储
- en: Information accessible by Gopher is stored as files on *Gopher servers*. It
    is organized in a hierarchical manner similar to the file system tree of a computer
    such as a Windows PC or UNIX workstation.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Gopher 可访问的信息存储在 *Gopher 服务器* 上的文件中。它以类似于 Windows PC 或 UNIX 工作站文件系统树的方式组织。
- en: Just as a file system consists of a top-level directory (or folder) that contains
    files and subdirectories (subfolders), Gopher servers present information as a
    top-level directory that contains resources such as files, and/or subdirectories
    containing additional resources. Resources on different servers can be linked
    together by having them mentioned in each others' resource hierarchies. It is
    also possible for virtual resources to be created that act as if they were files,
    such as programs that allow Gopher servers to be searched.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文件系统由包含文件和子目录（子文件夹）的顶层目录（或文件夹）组成一样，Gopher 服务器将信息呈现为一个顶层目录，其中包含文件等资源以及/或包含更多资源的子目录。不同服务器上的资源可以通过在彼此的资源层次结构中提及它们来相互链接。还可以创建虚拟资源，它们的行为就像文件一样，例如允许
    Gopher 服务器进行搜索的程序。
- en: Gopher Client/Server Operation
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gopher 客户端/服务器操作
- en: Typical use of Gopher begins with a user on a client machine creating a TCP
    connection to a Gopher server using well-known TCP port number 70\. After the
    connection is established, the server waits for the client to request a particular
    resource by sending the server a piece of text called a *selector string*. Often,
    when a user first accesses a server, he does not know what resource to request,
    so a null (empty) selector string is sent. This causes the server to send back
    to the client a list of the resources available at the top (root) directory of
    the server's file system tree.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Gopher 的典型使用是从客户端用户在客户端机器上创建一个 TCP 连接到 Gopher 服务器开始，使用众所周知的 TCP 端口号 70。连接建立后，服务器等待客户端通过发送一个称为选择字符串的文本来请求特定的资源。通常，当用户首次访问服务器时，他们不知道要请求什么资源，因此会发送一个空（空）的选择字符串。这会导致服务器向客户端发送一个列表，列出服务器文件系统树顶层（根）目录中可用的资源。
- en: 'A directory list sent by the server consists of a set of lines, each of which
    describes one available resource in that directory. Each line contains the following
    elements, each separated by a tab character:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送的目录列表由一系列行组成，每行描述该目录中的一个可用资源。每行包含以下元素，每个元素由制表符分隔：
- en: '**Type Character and Resource Name** The first character of the line tells
    the client software what sort of resource the line represents. The most common
    type characters are 0 (zero) for a file, 1 for a subdirectory, and 7 for a search
    service. The rest of the characters up to the first tab character contain the
    name of the resource to be presented to the user.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型字符和资源名称** 行的第一个字符告诉客户端软件该行代表的是哪种资源。最常见的类型字符是0（零）表示文件，1表示子目录，7表示搜索服务。直到第一个制表符字符之前的其余字符包含要向用户展示的资源名称。'
- en: '**Selector String** The string of text to be sent to the server to retrieve
    this resource.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择字符串** 发送到服务器以检索此资源的文本字符串。'
- en: '**Server Name** The name of the server where the resource is located.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器名称** 资源所在的服务器名称。'
- en: '**Server Port Number** The port number to be used for accessing this resource''s
    server; normally 70.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器端口号** 用于访问此资源服务器的端口号；通常是70。'
- en: Each line ends with a carriage return/line feed (CRLF) character sequence consistent
    with the Telnet Network Virtual Terminal (NVT) specification. Upon sending the
    directory listing (or any other response) the connection between the client and
    server is closed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 每行都以符合Telnet网络虚拟终端（NVT）规范的回车/换行（CRLF）字符序列结束。在发送目录列表（或任何其他响应）后，客户端和服务器之间的连接将关闭。
- en: After receiving this sort of directory list, the Gopher client software will
    display a menu to the user containing all the resource names the server provided.
    The user then selects his desired item from the menu, and the client retrieves
    it by making a connection to the appropriate server and port number, and sending
    the selector string of that resource. If this itself represents a subdirectory,
    the server will send a new directory listing for that subdirectory; if it represents
    some other type of resource, it will be accessed according to the requirements
    of the resource type.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到此类目录列表后，Gopher客户端软件将向用户显示一个菜单，其中包含服务器提供的所有资源名称。然后用户从菜单中选择他想要的项，客户端通过连接到适当的服务器和端口号，并发送该资源的选择字符串来检索它。如果这本身代表一个子目录，服务器将发送该子目录的新目录列表；如果它代表其他类型的资源，它将根据资源类型的要求进行访问。
- en: 'For example, suppose this line were sent from the server to the client:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设这一行是从服务器发送到客户端的：
- en: '[PRE0]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This would be presented to the user as the file called Gopher Introduction in
    a menu containing other options. If the user chose it, the client would initiate
    a connection to the Gopher server gopher.someserver.org at port 70, and then send
    the selector string intro to that server to retrieve the document.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在包含其他选项的菜单中以名为Gopher Introduction的文件形式展示给用户。如果用户选择它，客户端将启动与Gopher服务器gopher.someserver.org在端口70的连接，并向该服务器发送选择字符串intro以检索文档。
- en: Important Differences Between Gopher and the Web
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopher和Web之间的重要差异
- en: 'As I hinted at the start of this discussion, both Gopher and the Web are intended
    for the same basic purpose: providing access to repositories of information, with
    links between related documents and resources. However, they take a very different
    approach to how that information is accessed, especially in two key areas: user
    interface and resource linking.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本讨论开始时暗示的那样，Gopher和Web都旨在实现相同的基本目的：提供对信息库的访问，并在相关文档和资源之间建立链接。然而，它们在如何访问信息方面采取了非常不同的方法，特别是在两个关键领域：用户界面和资源链接。
- en: Gopher's presentation to the user is entirely oriented around its hierarchical
    file system. As a result, Gopher is inherently menu-based, and the user interface
    is usually based on a simple text presentation of those menus. In contrast, information
    on web servers can be organized in any manner and presented to the user in whatever
    form or fashion the owner of the server desires. The Web is much more free-form,
    and there is no need to use a directory structure unless that is advantageous
    in some way.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Gopher向用户展示的内容完全围绕其分层文件系统。因此，Gopher本质上是基于菜单的，用户界面通常基于这些菜单的简单文本展示。相比之下，网络服务器上的信息可以以任何方式组织，并以服务器所有者希望的形式或风格展示给用户。网络更加自由形式，除非以某种方式有利，否则不需要使用目录结构。
- en: Linking in the Web is done directly between documents, most often using Hypertext
    Markup Language (HTML) tags. When someone writing Document A mentions something
    relevant to Document B, she puts a link to Document B directly in Document A.
    Gopher, on the other hand, is not designed to use links in this way. Instead,
    linking is intended to be done using the directory tree I described earlier.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在万维网中，链接是在文档之间直接进行的，通常使用超文本标记语言（HTML）标签。当某人撰写文档A时提到与文档B相关的内容，她会在文档A中直接放置指向文档B的链接。另一方面，Gopher并没有设计成以这种方式使用链接。相反，链接的目的是使用我之前描述的目录树进行链接。
- en: Gopher's Role in the Modern Internet
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gopher在现代互联网中的作用
- en: There are some people who believe that Gopher is technically superior to the
    Web in a number of respects. They consider it cleaner to have servers do the linking,
    rather than having links embedded in documents. An argument can also be made that
    the text orientation of Gopher is efficient, better able to ensure compatibility
    between platforms, and also more suited to special needs situations such as low-bandwidth
    links and access by those with visual impairments. Some Gopher enthusiasts thus
    consider it to be a purer hypertext system than the Web.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，在许多方面，Gopher在技术上优于万维网。他们认为，让服务器进行链接比在文档中嵌入链接更干净。也可以提出这样的论点：Gopher的文本导向效率更高，更能确保平台之间的兼容性，并且更适合像低带宽链接和视力障碍者访问这样的特殊需求情况。因此，一些Gopher爱好者认为，它比万维网是一个更纯粹的超文本系统。
- en: However, history shows us that despite Gopher predating the Web, the Web overtook
    it in popularity in only a few short years. Today, the Web is the 900-pound gorilla
    of the Internet, while most people have never even heard of Gopher. What happened?
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，历史告诉我们，尽管Gopher比万维网出现得早，但万维网在短短几年内就超过了它的人气。如今，万维网是互联网上的900磅巨猩，而大多数人甚至从未听说过Gopher。发生了什么？
- en: I believe the main reason why Gopher lost out to the Web is that the Web is
    far more flexible. Gopher's use of text hyperlinks and server directory structures
    may be efficient, but it is limiting. In contrast, the Web allows information
    to be presented in a wide variety of ways. The open, unstructured nature of the
    Web makes it an ideal vehicle for the creativity of information providers and
    application developers. In the mid-1990s, the Web was also perfectly poised to
    support the transition of computing from text to graphics, and Gopher was not.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为Gopher输给万维网的主要原因在于万维网具有更大的灵活性。Gopher使用文本超链接和服务器目录结构可能很高效，但它是有限的。相比之下，万维网允许以多种方式展示信息。万维网的开放和非结构化特性使其成为信息提供者和应用开发者创造力的理想载体。在20世纪90年代中期，万维网也恰好处于支持从文本到图形计算过渡的最佳位置，而Gopher则没有。
- en: Simply put, you can do more with the Web than you can with Gopher, and most
    people care more about functionality and breadth of options than straight efficiency.
    Once the Web started to gain momentum, it very quickly snowballed. It took only
    a couple of years before Web use was well entrenched, and Gopher was unable to
    compete.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你可以用万维网做更多的事情，而大多数人更关心功能性和选项的广度，而不是直接的效率。一旦万维网开始获得动力，它很快就滚雪球般地发展起来。仅仅几年时间，万维网的使用就根深蒂固，而Gopher无法与之竞争。
- en: For its part, the University of Minnesota likely hastened Gopher's demise with
    its controversial decision to charge licensing fees to companies that wanted to
    use Gopher for commercial purposes. I do not believe there was anything nefarious
    about this. The university was on a limited budget and wanted companies that could
    afford it to pay a small fee to support development of Gopher software. However,
    computing history has shown time and time again that there is no faster way to
    kill a protocol or standard than to try to charge licensing or royalty fees for
    it, no matter what the reason.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其本身，明尼苏达大学可能因为其有争议的决定——向希望将Gopher用于商业目的的公司收取许可费——加速了Gopher的消亡。我不认为这有什么恶意。大学预算有限，希望能够负担得起的公司支付一小笔费用来支持Gopher软件的开发。然而，计算历史一次又一次地表明，没有比试图对协议或标准收取许可费或版税更快的方式来杀死它，无论理由是什么。
- en: By the late 1990s, Gopher was well on its way to obsolescence. As use of the
    protocol dwindled, many organizations could no longer justify the cost of continuing
    to run Gopher servers. Even the University of Minnesota itself eventually shut
    down its own Gopher servers due to low utilization. The final nail in the coffin
    for Gopher occurred in 2002, when a security vulnerability related to Gopher was
    discovered in Internet Explorer, and Microsoft chose to simply remove Gopher support
    from the product rather than fix the problem. Today, Gopher is still around, but
    it is a niche protocol used only by a relatively small group of enthusiasts and
    a handful of organizations that have a past history of using it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 到20世纪90年代末，Gopher 已经走向了淘汰的道路。随着该协议的使用量减少，许多组织再也无法证明继续运行 Gopher 服务器是有必要的。甚至明尼苏达大学本身也因利用率低而最终关闭了自己的
    Gopher 服务器。2002年，一个与 Gopher 相关的安全漏洞在 Internet Explorer 中被发现，微软选择简单地从产品中移除 Gopher
    支持，而不是修复这个问题。如今，Gopher 仍然存在，但它只是一种由相对较少的爱好者以及一些有使用 Gopher 历史的组织所使用的利基协议。
- en: Tip
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The Gopher Protocol is a distributed document search and retrieval
    protocol that was developed at the University of Minnesota in the late 1980s.
    Resources are stored on Gopher servers, which organize information using a hierarchical
    directory structure. Gopher clients access servers to retrieve directory listings
    of available resources, which are presented to the user as a menu from which an
    item may be selected for retrieval. Gopher''s chief advantage is simplicity and
    ease of use, but it lacks flexibility in presentation and the ability to effectively
    present graphics and multimedia. For this reason, despite Gopher predating the
    World Wide Web, the Web has almost entirely replaced it, and Gopher is now a niche
    protocol.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** Gopher 协议是一种分布式文档搜索和检索协议，它于20世纪80年代末在明尼苏达大学开发。资源存储在 Gopher 服务器上，这些服务器使用分层目录结构来组织信息。Gopher
    客户端访问服务器以检索可用资源的目录列表，这些列表以菜单的形式呈现给用户，用户可以从菜单中选择一个项目进行检索。Gopher 的主要优势在于简单易用，但它缺乏在展示方面的灵活性以及有效展示图形和多媒体的能力。因此，尽管
    Gopher 诞生早于万维网，但万维网几乎完全取代了它，现在 Gopher 只是一种利基协议。'
