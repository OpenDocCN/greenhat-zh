- en: '![](../images/25-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/25-1.jpg)'
- en: '[**APPLIANCE ARCHITECTURE**](toc.html#chapter1)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**设备架构**](toc.html#chapter1)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: We’ll begin our adventure with a high-level look at the architecture of a Linux
    appliance. We’ll then drop a little lower in altitude and look at a Linux appliance
    from the perspective of processes. As you’ll soon see, the view from this lower
    altitude matches the organization and chapters used throughout this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对 Linux 设备架构的高层次概述开始我们的冒险。然后，我们将降低视角，从进程的角度来看待 Linux 设备。正如你很快就会看到的，从这个较低的角度来看，与本书中使用的组织和章节相匹配。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: • UIs and daemons
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: • UI 和守护进程
- en: • The architecture of the Laddie appliance
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: • Laddie 设备的架构
- en: We have worked on Linux appliances that range from small, handheld devices to
    large, multi-gigabyte, multi-processor network servers. Most of these appliances
    have a strikingly similar software architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究过从小型手持设备到大型、多吉字节、多处理器的网络服务器的各种 Linux 设备。这些设备中的大多数都具有非常相似的软件架构。
- en: Figure 1-1 shows the software stack we typically see in a Linux appliance. At
    the bottom of this stack is an embedded Linux kernel. Above the kernel are the
    various user interfaces and common services such as network management and logging,
    and at the top is the particular function that defines the appliance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1 显示了我们在 Linux 设备中通常看到的软件堆栈。在这个堆栈的底部是嵌入式 Linux 内核。在内核之上是各种用户界面和常见服务，如网络管理和日志记录，而在顶部是定义设备的特定功能。
- en: Where appliances are concerned, the term *user interface (UI)* refers to an
    interface through which the user manages the appliance configuration and views
    its status and statistics. The lack of a screen and keyboard are hallmarks of
    an appliance, but do not let that fool you—all appliances have UIs. To be sure,
    the more invisible the UI the better the appliance, but the UI is always there
    nonetheless. Also, network appliances often have web, SNMP, and command line interfaces,
    while consumer appliances have framebuffers and small, alphanumeric LCD interfaces.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备方面，术语*用户界面（UI）*指的是用户通过它管理设备配置并查看其状态和统计信息的界面。没有屏幕和键盘是设备的标志，但不要被这蒙蔽了——所有设备都有
    UI。当然，UI 越不明显，设备越好，但 UI 总是存在的。此外，网络设备通常具有 Web、SNMP 和命令行界面，而消费设备具有帧缓冲区和小型、字母数字
    LCD 界面。
- en: '![](../images/26-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/26-1.jpg)'
- en: '*Figure 1-1: Linux appliance software stack*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：Linux 设备软件堆栈*'
- en: '[**UIs and Daemons**](toc.html#chapter1.1)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[**UI 和守护进程**](toc.html#chapter1.1)'
- en: Assuming that our Linux appliance will have multiple, simultaneous UIs, when
    we look at the appliance from the point of view of running processes we get an
    architecture something like that shown in Figure 1-2\. The UI programs interact
    with the users to accept commands and configuration and to display status and
    statistics. Daemons, on the other hand, interact with the hardware, other daemons,
    and the UIs to provide the appliance’s defining service as well as status and
    statistics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 Linux 设备将拥有多个、同时运行的 UI，当我们从运行进程的角度来看这个设备时，我们得到的架构类似于图 1-2 所示。UI 程序与用户交互，接受命令和配置，并显示状态和统计信息。另一方面，守护进程与硬件、其他守护进程和
    UI 交互，以提供设备的定义服务以及状态和统计信息。
- en: '![](../images/26-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/26-2.jpg)'
- en: '*Figure 1-2: A common appliance architecture*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：常见的设备架构*'
- en: '[***Daemons***](toc.html#chapter1.2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[***守护进程***](toc.html#chapter1.2)'
- en: Daemons are background programs that are most often started just after booting
    Linux. Daemons distinguish themselves in that they don’t have a controlling terminal
    like programs started from the bash command line. Let’s look at the kinds of daemons
    found on a typical appliance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是启动 Linux 后通常立即启动的后台程序。守护进程的特点是它们没有像从 bash 命令行启动的程序那样的控制终端。让我们看看在典型设备上发现的守护进程类型。
- en: '**Defining Application**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义应用程序**'
- en: The *defining application* in the diagram refers to the daemon that provides
    the unique function offered by the appliance. For example, the defining application
    for an advanced telephone answering machine is the daemon that actually answers
    the phone and records the call.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的*定义应用程序*指的是提供设备独特功能的守护进程。例如，高级电话答录机的定义应用程序是实际接听电话并记录通话的守护进程。
- en: '**Logging Daemon**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志守护进程**'
- en: The *logging daemon* shown in Figure 1-2 collects log messages and either saves
    them to disk or routes them to another host on the network. The syslog daemon
    is the default logging daemon on most Linux systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2中显示的*日志守护程序*收集日志消息，要么将它们保存到磁盘，要么将它们路由到网络上的另一个主机。syslog守护程序是大多数Linux系统上的默认日志守护程序。
- en: '**Event Handler**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件处理器**'
- en: The *event handler* provides a local, active response to events. Often the logging
    daemon and the event-handling daemon are one in the same, as they are in the logmuxd
    daemon that runs on our sample appliance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件处理器*提供对事件的本地、主动响应。通常，日志守护程序和事件处理守护程序是同一个，就像在我们的示例设备上运行的logmuxd守护程序一样。'
- en: '**Security Monitor**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全监控器**'
- en: The *security monitor* controls access to critical configuration or resources,
    such as identification and authentication credentials. The security monitor should
    also respond to Mandatory Access Control (MAC) violations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全监控器*控制对关键配置或资源的访问，例如身份验证凭证。安全监控器还应响应强制访问控制（MAC）违规。'
- en: '**Hardware Monitor**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬件监控器**'
- en: The *hardware monitor* watches for temperature alarms and disk drive problems.
    Most PC-based Linux appliances will use the lm_sensors package to monitor CPU
    and motherboard sensors and the smartd daemon to monitor the temperature and error
    statistics on hard disks. A hardware monitor might combine the information from
    these and other sources into a comprehensive report of the health of the appliance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬件监控器*监视温度警报和磁盘驱动器问题。大多数基于PC的Linux设备将使用lm_sensors包来监控CPU和主板传感器，以及smartd守护程序来监控硬盘的温度和错误统计。硬件监控器可能将来自这些和其他来源的信息组合成一个关于设备健康状况的综合报告。'
- en: '[***User Interfaces***](toc.html#chapter1.3)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[***用户界面***](toc.html#chapter1.3)'
- en: When we first started building Linux appliances we thought that the nature of
    the appliance defined the type of UI it would have. Boy, were we wrong. Customers
    always ask for more than one way to manage the device. Smart-phones need a framebuffer
    interface *and* a web interface over Bluetooth. Network appliances need a web
    interface *and* an SNMP interface. When you look at Figure 1-2, don’t think “Which
    one?” Think “How many?”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们最初开始构建Linux设备时，我们认为设备的性质决定了它将拥有的UI类型。哎呀，我们错了。客户总是要求有多种管理设备的方式。智能手机需要帧缓冲区接口*和*通过蓝牙的Web接口。网络设备需要Web接口*和*SNMP接口。当你查看图1-2时，不要想“哪一个？”而要思考“有多少？”
- en: The UIs depicted in Figure 1-2 are not the only possible choices. For example,
    you might want an interface that runs natively on a Windows PC, or if you’re building
    a network appliance, you may want to add interfaces to an LDAP or RADIUS authentication
    server or to the network’s billing system and database. Figure 1-2 shows the most
    common UIs and the ones described in the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2中展示的UI（用户界面）并不是唯一可能的选择。例如，你可能需要一个在Windows PC上原生运行的界面，或者如果你正在构建网络设备，你可能想要将接口添加到LDAP或RADIUS认证服务器，或者网络的计费系统和数据库。图1-2展示了最常见的UI以及书中描述的UI。
- en: '**Web Interface**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web接口**'
- en: 'A *web interface* is mandatory if your appliance has a network interface. You’ll
    have a lot to decide here: Do you use JavaScript or not? Is the back end written
    in Perl, PHP, C, or Java? Which do you use? Do you presume that all browsers support
    cascading style sheets? Chapter 8 on web UIs will help you evaluate the trade-offs
    for all these issues.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备有网络接口，则必须要有*Web接口*。你在这里有很多决定要做：你是否使用JavaScript？后端是用Perl、PHP、C还是Java编写的？你使用哪个？你是否假设所有浏览器都支持层叠样式表？第8章关于Web
    UI的内容将帮助你评估所有这些问题的权衡。
- en: '**Framebuffer Interface**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧缓冲区接口**'
- en: '*Framebuffer interfaces* are popular for television set-top boxes, such as
    TiVo or a PVR, stand-alone kiosks, and some handheld devices. The hardware in
    a framebuffer gives you direct control over each pixel on the screen. This gives
    you great flexibility in what your interface looks like, but at the cost of burdening
    you with *managing* every pixel on the screen. Some libraries and graphics toolsets,
    such as the Simple DirectMedia Layer (SDL) can help. The art in building a framebuffer
    interface is in choosing the right toolset.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*帧缓冲区接口*在电视机顶盒、如TiVo或PVR、独立式自助终端和一些手持设备中很受欢迎。帧缓冲区硬件让你能够直接控制屏幕上的每个像素。这为你提供了很大的灵活性，但代价是必须管理屏幕上的每个像素。一些库和图形工具集，如Simple
    DirectMedia Layer (SDL)，可以提供帮助。构建帧缓冲区接口的艺术在于选择正确的工具集。'
- en: '**Front Panel**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**前面板**'
- en: '*Front panel interfaces*, whether simple or complex, appear on almost all Linux
    appliances. A simple front panel might have only a few lights and buttons, while
    a more complex one might have an alphanumeric liquid crystal display (LCD) or
    a vacuum florescent display. Even a simple front panel may require a deep understanding
    of the underlying hardware.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*前面板接口*，无论是简单还是复杂，几乎出现在所有Linux设备上。一个简单的前面板可能只有几个灯和按钮，而一个更复杂的可能有一个字母数字液晶显示器（LCD）或真空荧光显示器。即使是简单的前面板也可能需要深入了解底层硬件。'
- en: '**SNMP Interface**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**SNMP接口**'
- en: We have heard it said that an *SNMP interface* makes the difference between
    a commercially viable network appliance and a hobby. From our experience we’d
    have to agree. SNMP is not too difficult if you break it into pieces. First, you
    need to familiarize yourself with the concepts used in SNMP and with the SNMP
    commands available in Linux. Then, you need to design a Management Information
    Base (MIB), or schema, for the data made visible by your SNMP interface. Finally,
    you need to write the software that makes the MIB available to the SNMP commands.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们听说，一个*SNMP接口*是商业上可行的网络设备和爱好之间的区别。根据我们的经验，我们必须同意。如果你将其分解成小块，SNMP并不太难。首先，你需要熟悉SNMP中使用的概念以及Linux中可用的SNMP命令。然后，你需要为你的SNMP接口可见的数据设计一个管理信息库（MIB），或称为模式。最后，你需要编写使MIB可供SNMP命令使用的软件。
- en: '**Command Line Interfaces**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面**'
- en: '*Command line interfaces* (CLIs) are often used as the control interface of
    last resort for network appliances. A CLI on a serial port remains available even
    when the entire network is down. CLIs also find use as an appliance-specific scripting
    language.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令行界面*（CLIs）通常被用作网络设备的最后手段的控制接口。即使在整个网络断开的情况下，串行端口上的CLI仍然可用。CLI还用作设备特定的脚本语言。'
- en: '[***Interprocess Communication***](toc.html#chapter1.4)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[***进程间通信***](toc.html#chapter1.4)'
- en: Finally, you may have noticed the full-mesh interconnect of lines in Figure
    1-2\. Don’t let it intimidate you. Our point is that any UI should be able to
    connect to any daemon. This requirement dictates a lot of the features to look
    for in the interprocess communication (IPC) mechanism used between the UIs and
    the daemons. (We’ll have more to say about this in Chapter 2.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能已经注意到了图1-2中线的全网状互连。不要让它吓到你。我们的观点是，任何UI都应该能够连接到任何守护进程。这个要求决定了在UI和守护进程之间使用的进程间通信（IPC）机制中要查找的许多功能。（我们将在第2章中对此有更多讨论。）
- en: '[**The Architecture of the Laddie Appliance**](toc.html#chapter1.5)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Laddie设备的架构**](toc.html#chapter1.5)'
- en: This book’s sample appliance is an alarm system that uses the input pins on
    a parallel port for input from the alarm sensors. The UIs include web, command
    line, LCD with a keypad, framebuffer with IR remote control, and SNMP.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例设备是一个使用并行端口上的输入引脚从警报传感器接收输入的警报系统。用户界面包括网页、命令行、带键盘的LCD、带红外遥控的帧缓冲区以及SNMP。
- en: The daemons on our appliance include the alarm system daemon and one to respond
    to appliance events. We chose not to implement all of the daemons shown in Figure
    1-2 so that we could focus on describing how to build and secure daemons in general.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设备上的守护进程包括警报系统守护进程和一个响应设备事件的守护进程。我们选择不实现图1-2中显示的所有守护进程，以便我们可以专注于描述如何构建和确保守护进程的一般方法。
- en: Of course, our sample appliance includes ladd (the defining application), an
    event handler, and a utility to make common Linux configuration files visible
    using a protocol common to all the UIs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的示例设备包括ladd（定义性应用程序）、事件处理程序以及一个实用程序，它使用所有UI通用的协议使常见的Linux配置文件可见。
- en: Figure 1-3 shows the architecture of the Laddie appliance and maps the UI, feature,
    or daemon to a chapter number or appendix so that you can see how things will
    come together throughout the book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3显示了Laddie设备的架构，并将UI、功能或守护进程映射到章节编号或附录，以便您可以看到全书如何将事物组合在一起。
- en: '![](../images/29-1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/29-1.jpg)'
- en: '*Figure 1-3: A chapter map of the Laddie appliance*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：Laddie设备的章节图*'
- en: We’ve limited the functionality of our UIs to make them more useful as tutorials.
    Only the web interface is full featured and representative of what a real appliance
    might have.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们限制了UI的功能，使它们作为教程更有用。只有网页界面是全功能的，并且代表了真实设备可能拥有的功能。
- en: '[**Summary**](toc.html#chapter1.6)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[**摘要**](toc.html#chapter1.6)'
- en: 'Most Linux appliances have a common architecture: Linux on the bottom, the
    defining application on top, and common services and UIs in the middle. We discussed
    some of the reasons to include various daemons and UIs and mapped this book’s
    chapters into an architecture diagram.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux设备都拥有一个共同的架构：底层是Linux操作系统，顶层是定义性的应用程序，中间是常见的服务和UI。我们讨论了包含各种守护进程和UI的一些原因，并将本书的章节映射到一个架构图中。
- en: The next chapter looks at the API between the UIs and daemons, since the chosen
    API impacts both UIs and daemons.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨UI和守护进程之间的API，因为所选的API会影响UI和守护进程。
