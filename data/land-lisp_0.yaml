- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: So, you’ve decided to pick up a book on Lisp and read the introduction. Perhaps
    you were surprised to see something that looks like a comic book mixed in with
    the other computer programming books on the shelf. Who would bother writing a
    comic book about a weird academic programming language like Lisp? Or maybe you’ve
    heard other people raving about the Lisp language and thought, “Boy, Lisp sure
    sounds different from other languages people talk about. Maybe I should pick up
    a Lisp book sometime.” Either way, you’re now holding a book about a programming
    language that is very cool but also very unusual.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你决定拿起一本关于 Lisp 的书并阅读前言。也许你惊讶地看到一本看起来像漫画书的东西夹杂在书架上的其他计算机编程书籍中。谁会费心写一本关于像 Lisp
    这样奇怪的学术编程语言的漫画书呢？或者也许你听到其他人狂热地谈论 Lisp 语言，心想，“哇，Lisp 真的听起来和其他人谈论的语言很不一样。也许我应该什么时候找一本
    Lisp 书。”无论如何，你现在手里拿着一本关于一种非常酷但也很不寻常的编程语言的书籍。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703101.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703101.png)'
- en: What Makes Lisp So Cool and Unusual?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是使 Lisp 如此酷且不寻常的原因？
- en: Lisp is a very *expressive* language. Lisp is designed to let you take the most
    complicated programming ideas and express them in a clear and appropriate way.
    Lispers have the freedom to write a program in exactly the way that is most helpful
    for solving any problem at hand.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 是一种非常*表达性*的语言。Lisp 被设计成让你以最清晰和适当的方式表达最复杂的编程思想。Lispers 有自由以最有助于解决任何手头问题的方式编写程序。
- en: The power at your fingertips when writing Lisp code is what makes it so different.
    Once you “get” Lisp, you’ll be forever changed as a programmer. Even if you end
    up never writing Lisp code again for the rest of your life, learning Lisp will
    fundamentally change you as a coder.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 Lisp 代码时，指尖上的力量正是使其与众不同的原因。一旦你“理解”了 Lisp，你作为一个程序员的身份将永远改变。即使你余生再也没有写过 Lisp
    代码，学习 Lisp 也会从根本上改变你作为一个程序员的状态。
- en: In a way, learning a typical programming language is similar to learning a foreign
    language as an adult. Suppose you go out tomorrow and decide you’re going to learn
    French. You may take every course on French that you can find, read materials
    that are only in French, and even move to France. But no matter what you do, your
    understanding of French will always remain a little imperfect. And no matter how
    good of a French speaker you eventually become, in your dreams you probably will
    still be speaking in your native language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，学习一种典型的编程语言类似于成年人学习外语。假设你明天出去决定你要学习法语。你可能会上你找到的所有法语课程，阅读只有法语的资料，甚至搬到法国去。但无论你做什么，你对法语的理解总是会有些不完美。无论你最终成为多好的法语说话者，在你的梦中，你可能仍然会说着你的母语。
- en: Lisp is different. It’s not just like learning any foreign language. Once you’ve
    learned Lisp, you’ll even dream in Lisp. Lisp is such a powerful idea that it
    will crowd out your previous programming experience and become your new mother
    tongue! Whenever you encounter a new programming idea in any language, you’ll
    always say to yourself, “That’s kind of how I’d do it in Lisp, except . . . .”
    That’s the kind of power only Lisp will give you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 是不同的。它不仅仅是学习任何外语。一旦你学会了 Lisp，你甚至会在梦中用 Lisp 思考。Lisp 是一个如此强大的理念，它将取代你之前的编程经验，并成为你的新母语！无论你在任何语言中遇到新的编程思想，你总会对自己说，“那有点像我在
    Lisp 中会怎么做，除了……”。这就是只有 Lisp 才能给你的那种力量。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703103.png.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703103.png.jpg)'
- en: At this point, all you may know about Lisp is that at least one person (me)
    is extremely excited about it. But your time is valuable, and learning something
    new is bound to require some effort.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能对 Lisp 的了解仅限于至少有一个人（就是我）对此非常兴奋。但你的时间是宝贵的，学习新事物必然需要一些努力。
- en: 'The good news is Lisp isn’t really as difficult as it may seem at first glance.
    For instance, the following is a valid Lisp expression:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 Lisp 并没有表面上看起来那么困难。例如，以下是一个有效的 Lisp 表达式：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Can you guess what the value of this expression is? If you answered 11, then
    you’ve already figured out how to read basic Lisp code. It is written just like
    math, except that the functions—in this case, addition and multiplication—come
    before the numbers, and everything is in parentheses.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个表达式的值是多少吗？如果你回答是 11，那么你已经弄懂了如何阅读基本的 Lisp 代码。它写起来就像数学一样，只不过函数——在这个例子中，是加法和乘法——在数字之前，而且所有内容都在括号内。
- en: If Lisp Is So Great, Why Don't More People Use It?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果Lisp如此出色，为什么更多的人不使用它？
- en: Actually, a fair number of large companies *do* use Lisp for some serious work
    (you’ll find a long list of industrial Lisp projects at [http://snipurl.com/e3lv9/](http://snipurl.com/e3lv9/)).
    Other programming languages are constantly “borrowing” features of Lisp and presenting
    them as the latest and greatest ideas. Also, the Semantic Web, which many believe
    will play a big role in the future of the Web, uses many tools written in Lisp.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，相当多的大型公司确实使用Lisp进行一些严肃的工作（你可以在[http://snipurl.com/e3lv9/](http://snipurl.com/e3lv9/)找到长长的工业Lisp项目列表）。其他编程语言不断“借用”Lisp的特性，并将它们作为最新的最伟大的想法展示出来。此外，许多人认为将在Web的未来发挥重要作用的语义网，使用了大量用Lisp编写的工具。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The idea behind the Semantic Web is to create a set of protocols for websites
    to follow so that a computer can determine the “meaning” of information on a web
    page. This is done by annotating web pages with special metadata (usually in a
    format called Resource Description Framework, or RDF) that links to common vocabularies,
    which different websites may share. Many of the tools used for working with description
    logics and RDF data are written in Lisp (for example, RacerPro and AllegroGraph).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 语义网背后的理念是为网站创建一套协议，以便计算机能够确定网页上信息的“含义”。这是通过使用特殊元数据（通常称为资源描述框架，或RDF）来注释网页，这些元数据链接到常见的词汇表，不同网站可能共享。许多用于处理描述逻辑和RDF数据的工具是用Lisp编写的（例如，RacerPro和AllegroGraph）。
- en: So, Lisp certainly has a promising future. But some may think that learning
    Lisp is not worth the effort.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Lisp肯定有一个光明的未来。但有些人可能会认为学习Lisp不值得付出努力。
- en: How did Lisp get this undeserved reputation?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp如何获得这种不应得的声誉？
- en: 'I think that people use a rule of thumb when deciding what things in life are
    worth learning. Most people seek knowledge in one of the following three categories:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为人们在决定生活中哪些事物值得学习时，会遵循一种经验法则。大多数人会在以下三个类别中寻求知识：
- en: What many other people learn (calculus, C++, and so on)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多人学习的内容（例如微积分、C++等）
- en: What is easy to learn (hula-hooping, Ruby, and so on)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易学习的东西（例如呼啦圈、Ruby等）
- en: What has value that is easy to appreciate (thermonuclear physics, for example,
    or that ridiculously loud whistle where you stick your fingers in your mouth)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有价值且容易欣赏的东西（例如热核物理，或者那种你把手指放在嘴里吹得非常响的哨子）
- en: Lisp doesn’t fall into any of these categories. It’s not as popular as calculus,
    particularly easy to learn, or as obviously valuable as that loud whistle. If
    we were to follow these (usually very sensible) rules of thumb, we would conclude
    that a reasonable person should stay away from Lisp. However, in the case of Lisp,
    we’re going to throw out these rules. As you’ll see from reading this book, Lisp
    gives you insights into computer programming that are so profound that every serious
    programmer should have some experience with this unusual language, even if it
    requires a little effort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp不属于这些类别。它不像微积分那样受欢迎，也不像学习那样容易，也不像那个响亮的哨子那样明显有价值。如果我们遵循这些（通常非常合理的）经验法则，我们就会得出结论，一个理智的人应该远离Lisp。然而，在Lisp的情况下，我们将摒弃这些规则。正如你从阅读这本书中看到的那样，Lisp给你提供了对计算机编程的深刻见解，每个严肃的程序员都应该有一些使用这种不寻常语言的经验，即使这需要一点努力。
- en: If you’re still not convinced, you might want to take a peek at the comic book
    epilogue way at the end of the book. You might not be able to understand everything
    in there right now, but it will give you a feel for the advanced features available
    within Lisp and what makes Lisp programming different from other types of programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不确信，你可能想看看书末尾的漫画书尾声。你现在可能无法完全理解那里的所有内容，但它会给你一个关于Lisp中可用的高级功能和Lisp编程与其他类型编程不同的感觉。
- en: Where Did Lisp Come From?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp是从哪里来的？
- en: The Lisp family of languages is truly ancient, with a history that differs from
    other languages. We’ll need to travel far back in time to get to the beginning
    of it all.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp语言家族的历史非常悠久，与其他语言的历史不同。我们需要追溯到很久以前才能找到它的起点。
- en: A long time ago (way back in the 1940s), the Earth was covered by a giant ocean
    called the Panthalassic Ocean, along with a single barren land mass named Pangaea.
    In this unforgiving environment, the first computer programs evolved, written
    in pure machine language (or “ones and zeros,” as they say).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前（在20世纪40年代），地球被一个名为泛古洋的巨大海洋覆盖，以及一个名为泛大陆的单个贫瘠陆地。在这个残酷的环境中，第一台计算机程序进化了，是用纯机器语言编写的（或者说“一和零”，就像他们说的）。
- en: These protolanguages were tightly bound to specific computer systems, such as
    the ENIAC, the Zuse Z3, and other early vacuum-tube contraptions. Often, these
    early computers were so primitive that “programming” them involved simply flipping
    switches or patching cables to physically encode each operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原型语言与特定的计算机系统紧密相连，如ENIAC、Zuse Z3和其他早期的真空管装置。通常，这些早期的计算机非常原始，编程它们只是简单地翻转开关或修补电缆来物理编码每个操作。
- en: The dark days of these protolanguages saw a lot of experimentation with different
    computer architectures and an explosion of different computer instruction sets.
    Competition was fierce. While most of these primitive language experiments ultimately
    disappeared—victims of ancient battles for survival—others thrived.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原型语言的黑暗时期见证了不同计算机架构的大量实验和不同计算机指令集的爆炸式增长。竞争激烈。虽然这些原始语言实验中的大多数最终消失了——成为古代生存斗争的牺牲品——但其中一些却繁荣起来。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703105.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703105.png.jpg)'
- en: At a certain point, computers acquired their own in memory to store programs,
    along with primitive *assemblers* that allowed programs to be written in text,
    instead of with just pure numbers. These *assembly* languages included Short Code,
    ARC assembly, and EDSAC Initial Orders.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，计算机获得了自己的内存来存储程序，以及允许用文本编写程序而不是只用纯数字的原始*汇编器*。这些*汇编语言*包括Short Code、ARC汇编和EDSAC初始指令。
- en: Assembly languages made software development much more efficient, enabling ancient
    assemblers to evade the many predators in this primordial ocean. But assembly
    languages still had significant limitations. They were always designed around
    the instruction set of a specific processor and so they were not portable across
    different machine architectures. Programming languages needed to evolve to survive
    beyond the confines of a specific machine instruction set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言使软件开发变得更加高效，使得古代汇编器能够避开这个原始海洋中的众多捕食者。但汇编语言仍然存在显著的局限性。它们总是围绕特定处理器的指令集进行设计，因此它们不能在不同的机器架构之间移植。编程语言需要进化以超越特定机器指令集的局限。
- en: The 1950s saw the arrival of the first machine-independent programming languages.
    Languages like Autocode and Information Processing Language accomplished this
    independence not only through lungs and legs, but also through new types of software,
    such as compilers and interpreters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪50年代见证了第一个机器无关的编程语言的诞生。像Autocode和信息处理语言这样的语言通过肺和腿实现了这种独立性，同时也通过新的软件类型，如编译器和解释器。
- en: With compilers and interpreters, computer programs could now be written in a
    human-friendly syntax. A *compiler* can take a human-written computer program
    and convert it automatically into a machine-friendly binary format that the computer
    can execute. An *interpreter*, on the other hand, performs the actions described
    in a human-written program directly, without converting them all the way down
    to a machine-friendly binary format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编译器和解释器的出现，计算机程序现在可以使用人类友好的语法编写。*编译器*可以将人类编写的计算机程序自动转换为计算机可执行的机器友好二进制格式。另一方面，*解释器*直接执行人类编写的程序中描述的操作，而不需要将它们全部转换为机器友好的二进制格式。
- en: For the first time, programmers could use languages that were designed to make
    computer programming a pleasant activity, without needing to operate at the primitive
    level of the computer hardware. These interpreted and compiled programming languages
    are what we now think of as the first “true” programming languages. One of the
    most imposing of these early languages, FORTRAN (developed in 1957), was widely
    supported on different architectures and is still used heavily to this day.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首次，程序员可以使用旨在使计算机编程成为一种愉快活动的语言，而无需在计算机硬件的原始级别上进行操作。这些解释和编译的编程语言就是我们今天所认为的第一种“真正”的编程语言。这些早期语言中最令人印象深刻的一种，FORTRAN（于1957年开发），在多种架构上得到了广泛支持，并且至今仍在被大量使用。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703107.png.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703107.png.jpg)'
- en: 'Up until this point, the most successful languages had been designed around
    one central idea: to offer a general design and syntax that would make programming
    as easy as possible for novices. However, designing a good programming language
    turns out to be very difficult. Hence, most of these languages, like FORTRAN,
    BASIC, and C, were really just a mishmash of older ideas, copied from one another
    and thrown together in a way that lacked any real beauty. They were usually easy
    to use in only superficial ways. Nonetheless, these fierce languages roamed the
    jungles for decades in search of easy prey.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最成功的语言都是围绕一个中心思想设计的：提供一个通用设计和语法，使编程尽可能容易。然而，设计一个好的编程语言证明是非常困难的。因此，这些语言中的大多数，如
    FORTRAN、BASIC 和 C，实际上只是旧想法的大杂烩，相互抄袭，拼凑在一起，缺乏真正的美感。它们通常只在表面上容易使用。尽管如此，这些凶猛的语言在丛林中漫游了数十年，寻找容易捕获的猎物。
- en: In the shadows of these fearsome beasts lurked a small, humble, and entirely
    different sort of creature—mostly hidden from view, but present almost since the
    very first machine-independent languages crawled onto land. These were languages
    that used mathematical syntax, such as the lambda calculus, developed by mathematicians
    in the 1930s.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些可怕的巨兽阴影中，潜伏着一种小而谦逊、完全不同的生物——大多数时候隐藏在视线之外，但几乎从第一台机器无关语言爬上陆地以来就存在。这些语言使用数学语法，如20世纪30年代数学家开发的
    lambda 演算。
- en: Not the least bit concerned with being pragmatic or easy for novices to learn,
    these languages were highly intelligent and wanted to push the limits of language
    design. They posed questions about program notation, language semantics, and the
    simplest possible language syntax.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言并不关心是否实用或易于新手学习，它们非常智能，并希望推动语言设计的极限。它们提出了关于程序符号、语言语义和最简单可能的语言语法的疑问。
- en: 'From these highly intelligent mathematical syntaxes evolved one most notable
    creature: the original Lisp programming language. Unlike most other programming
    languages, it did not evolve from FORTRAN or other languages that were concerned
    with pragmatism or ease of use. Its lineage is a completely separate one, drawn
    straight from mathematics. But where did Lisp come from?'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些高度智能的数学语法中演变出了最引人注目的生物：最初的 Lisp 编程语言。与大多数其他编程语言不同，它并非源自 FORTRAN 或其他关注实用主义或易用性的语言。它的血统是完全独立的，直接源自数学。但
    Lisp 是从哪里来的呢？
- en: Some people claim that the story behind Lisp’s origins has been forever lost
    in the fog of time. Others (who are probably more correct) say Lisp’s creation
    was the work of John McCarthy in 1959\. One day, it is said, he gathered together
    his tribe at MIT and presented an ingenious idea. McCarthy envisioned a completely
    theoretical programming language, which would have minimal syntax and semantics
    but, at the same time, create incredibly elegant programs. These programs were
    so elegant that even writing an interpreter for Lisp in Lisp itself would take
    only around 50 lines of computer code!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人声称 Lisp 的起源背后的故事已经永远迷失在时间的迷雾中。其他人（可能更正确）说 Lisp 的创造是约翰·麦卡锡在 1959 年的工作。据说，有一天，他在麻省理工学院召集了他的部落，并提出了一个巧妙的主意。麦卡锡设想了一种完全理论化的编程语言，它将具有最少的语法和语义，但同时又能够创造出极其优雅的程序。这些程序如此优雅，以至于用
    Lisp 本身编写 Lisp 的解释器只需要大约 50 行计算机代码！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703109.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703109.png.jpg)'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'John McCarthy published the paper “Recursive Functions of Symbolic Expressions
    and Their Computation by Machine, [Part I](pt01.html "Part I. Lisp is Power"),”
    Communications of the ACM (April 1960): 184-195\. You can read it at [http://www-formal.stanford.edu/jmc/recursive.pdf](http://www-formal.stanford.edu/jmc/recursive.pdf).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·麦卡锡发表了论文“符号表达式的递归函数及其通过机器的计算，[第一部分](pt01.html "第一部分。Lisp 是力量")”，ACM 通讯（1960年4月）：184-195。您可以在[http://www-formal.stanford.edu/jmc/recursive.pdf](http://www-formal.stanford.edu/jmc/recursive.pdf)上阅读它。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703111.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703111.png)'
- en: When McCarthy first published his idea, it was intended only as an intellectual
    exploration of mathematical syntax. But soon, the Lisp language evolved and could
    work with compilers and interpreters. It now ran on real computers, just like
    FORTRAN and the other programming languages! But unlike these other languages,
    Lisp retained a beauty derived from its mathematical ancestry.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当麦卡锡首次发表他的想法时，这只是一个对数学语法的智力探索。但很快，Lisp 语言就发展起来，可以与编译器和解释器一起工作。它现在运行在真正的计算机上，就像
    FORTRAN 和其他编程语言一样！但与这些其他语言不同，Lisp 保留了一种从其数学血统中继承的美。
- en: Soon after the first Lisps appeared, the first Lisp programmers appeared, capturing
    these docile creatures and transforming them into ever-more-refined programming
    languages. Over time, these programmers turned the primal Lisps into dialects
    such as MACLISP and Interlisp.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 Lisp 出现不久之后，第一个 Lisp 程序员也出现了，他们捕捉了这些温顺的生物，并将它们转化为更加精细的编程语言。随着时间的推移，这些程序员将原始的
    Lisp 转变为 MACLISP 和 Interlisp 等方言。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703113.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703113.png)'
- en: 'Although the hunting of early Lisps was a successful avocation for early Lisp
    programmers, it soon became clear that these hunters had a competitor: Cro-Magnon
    man. The Cro-Magnons were more aggressive than the peaceful Lisp programmers,
    attacking ever-bigger software development projects using fearsome languages such
    as COBOL. Developed for business applications, COBOL was an ugly and vile behemoth
    that nonetheless made lucrative prey for the Cro-Magnons. Lisp programmers, on
    the other hand, were more content contemplating elegant programming and hunting
    the occasional Lisp.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然早期 Lisp 的狩猎对早期 Lisp 程序员来说是一种成功的业余爱好，但很快，这些猎人就有一个竞争对手：克罗马农人。克罗马农人比和平的 Lisp
    程序员更具侵略性，他们使用 COBOL 等可怕的语言攻击更大的软件开发项目。为商业应用开发的 COBOL 是一个丑陋而卑鄙的巨兽，但这对克罗马农人来说却是有利可图的猎物。另一方面，Lisp
    程序员更愿意沉思优雅的编程和偶尔的 Lisp 猎捕。
- en: Now, while Lisp was an incredibly powerful idea, other programming languages
    already had a head start in mind share and more mature development tools. This
    made it a challenge for Lisps, and the Lisp programmers dependent on them, to
    get the traction they needed for mainstream success. However, the gentle Lispers
    were not concerned with such petty things. Despite their differing dispositions,
    the Lispers and the Cro-Magnons lived side by side in relative harmony.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然 Lisp 是一个极其强大的想法，但其他编程语言已经在市场份额和更成熟的发展工具方面领先。这使得 Lisp 及其程序员面临挑战，难以获得主流成功的牵引力。然而，温和的
    Lisp 程序员并不关心这些琐事。尽管他们的性格各异，但 Lisp 程序员和克罗马农人还是相对和谐地生活在一起。
- en: In their own way, the Lispers were thriving. At that time, they benefited heavily
    from highly academic research in areas such as image recognition, computerized
    data classification, and other problems that fall under the general umbrella of
    *artificial intelligence (AI)*. The highly mathematical nature of these problems
    lent their investigation to a Lispy approach, and Lisp programmers built new dialects
    of Lisp into ever-more-advanced computer systems to attack them. Many consider
    this the Golden Age of Lisp.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以他们自己的方式，Lisp 程序员正在蓬勃发展。当时，他们从图像识别、计算机化数据分类和其他属于“人工智能（AI）”一般范畴的问题中受益匪浅。这些问题的高度数学性质使得他们的研究适合
    Lisp 方法，Lisp 程序员将这些新的 Lisp 方言构建到更加先进的计算机系统中以应对这些问题。许多人认为这是 Lisp 的黄金时代。
- en: Unfortunately, after this brief golden period, the winds unexpectedly turned
    on the poor Lispers. In the mid-1980s, a sudden tilt in the axis of the Earth
    altered the climate, causing shortages in the food sources that the Lisp languages
    needed to survive. Disappointments in the progress of AI research caused many
    grants for academic research to dry up, and much of the hardware favored by the
    Lisps (such as Lisp machines from Symbolics, Lisp Machine, Inc., and Texas Instruments)
    fell behind the capabilities of more traditional complex instruction set computer
    (CISC) and reduced instruction set computer (RISC) hardware architectures. The
    world had become an unwelcoming place for Lisps and the Lisp programmers that
    depended on them for survival. The “AI winter” had arrived, and Lisp was doomed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这段短暂的黄金时期之后，风向突然对可怜的 Lisp 程序员们不利。在 20 世纪 80 年代中期，地球轴线的突然倾斜改变了气候，导致 Lisp
    语言所需的生存食物来源短缺。人工智能研究进展的失望导致许多学术研究资助枯竭，而且许多 Lisp 所青睐的硬件（如 Symbolics、Lisp Machine,
    Inc. 和德州仪器的 Lisp 计算机）在复杂指令集计算机（CISC）和精简指令集计算机（RISC）硬件架构的能力方面落后。世界对 Lisp 和依赖它们的
    Lisp 程序员来说变得不再友好。“人工智能寒冬”已经到来，Lisp 命运难逃。
- en: This finally gave the Cro-Magnons the definite advantage in the language race.
    The new craze of megalithic, FORTRAN-derived, object-oriented languages—such as
    C++, developed in 1983—had slowly conquered commercial software development. This
    gave the Cro-Magnons complete immunity from the AI winter, which was afflicting
    the Lispers. Furthermore, the wily Cro-Magnons borrowed some of the ideas pioneered
    by the Lispers to patch up the problems of mainstream languages. Thus, garbage
    collection and parametric polymorphism, originally found in the Lisps, became
    common in the languages used by mainstream programmers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终给了克罗马农人在语言竞赛中的绝对优势。1983 年发展起来的新热潮，巨石阵、FORTRAN 衍生的面向对象语言——如 C++——逐渐征服了商业软件开发。这使克罗马农人免受困扰
    Lisp 程序员的“人工智能寒冬”的影响。此外，狡猾的克罗马农人借鉴了 Lisp 程序员开创的一些想法来解决主流语言的问题。因此，垃圾回收和参数多态性，最初在
    Lisp 中发现，成为主流程序员使用的语言中的常见特性。
- en: Eventually, through immense effort, the language behemoths of olden days had
    been tamed by the Cro-Magnons into C#, Java, and similar languages. The belief
    arose that these languages were more pleasant to use as tools than anything available
    in the past, with the Golden Age of Lisp long forgotten. More recently, languages
    such as Python and Ruby have further refined these Cro-Magnon languages into more
    modern directions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，通过巨大的努力，古老的编程语言巨兽被克罗马农人驯服成了 C#、Java 和类似的语言。人们产生了这样的信念，即这些语言比过去任何可用的工具都更容易使用，而
    Lisp 的黄金时代早已被遗忘。最近，像 Python 和 Ruby 这样的语言进一步将这些克罗马农语言精炼成更现代的方向。
- en: But what has happened to the Lisp programmers during all this time? Have they
    completely succumbed to the AI winter? Are they once again lurking in the shadows,
    waiting for another day in the sun? No one knows for sure. But if you look hard
    enough, maybe in the highest mountains, in the deepest jungles, or on the lowest
    basement levels of MIT, you may catch a glimpse of an odd sort of creature. Some
    call it the Windigo; others refer to it as a yeti, Sasquatch, or rms. But those
    who really know think it just might be—that it could only be—a Lisp programmer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这段时间里 Lisp 程序员们发生了什么？他们是否完全屈服于人工智能寒冬？他们是否再次潜伏在阴影中，等待阳光再次照耀的一天？没有人能确切知道。但如果你足够努力地寻找，也许在最高的山脉，最深的丛林，或者在麻省理工学院最底层的地下室里，你可能会瞥见一种奇怪的生物。有些人称之为
    Windigo；其他人称之为 Yeti、Sasquatch 或 rms。但真正了解的人认为，它可能真的存在——它可能只能是——一个 Lisp 程序员。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703115.png.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703115.png.jpg)'
- en: Where Does Lisp Get Its Power?
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lisp 的力量从何而来？
- en: I’ve said that Lisp is a particularly powerful language. So what were the key
    insights that John McCarthy (and the other, later innovators of Lisp) had that
    made this power possible?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经说过 Lisp 是一种特别强大的语言。那么约翰·麦卡锡（以及后来的 Lisp 创新者）有哪些关键洞察力使得这种力量成为可能？
- en: To make a programming language powerful, you need to make it expressive. Having
    an expressive language means that you can do a lot of stuff with very little actual
    code. But what traits does a language need to make this possible? I think there
    are two that are most important.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使编程语言强大，你需要让它具有表现力。拥有表现力强的语言意味着你可以用很少的实际代码做很多事情。但语言需要哪些特性才能实现这一点？我认为有两个特性是最重要的。
- en: One trait is a lot of features built into the language. That way, for most things
    you need to get done, someone has already performed some of the work for you,
    and you can leverage that work to make your own code look pithy. Many modern languages
    have this trait. The Java language, for instance, is renowned for powerful libraries
    that, for example, let you acquire data from another PC over a socket with ease.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种特性是语言中内置了许多功能。这样，对于大多数你需要完成的事情，已经有其他人为你完成了一些工作，你可以利用这些工作来使你的代码看起来简洁。许多现代语言都有这种特性。例如，Java语言以其强大的库而闻名，例如，它让你能够轻松地从另一台PC通过套接字获取数据。
- en: The second trait that gives a language power is letting you muck around inside
    it as deeply as possible to make it do your bidding. That way, even if the designers
    of the language never conceived of what you’re trying to do, you can make your
    own changes to the language until it does exactly what you need to solve your
    problems elegantly. This trait is much more difficult to provide in a language.
    Suppose you wanted to add something like nested function definition support to
    Java. If you know Java well, thinking about how to add such support is in the
    realm of nightmares.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种赋予语言力量的特性是让你尽可能深入地玩弄它，使其按照你的意愿行事。这样，即使语言的设计者从未想过你要做什么，你仍然可以修改语言，直到它能够优雅地解决你的问题。这种特性在语言中提供起来要困难得多。假设你想在Java中添加类似嵌套函数定义支持的功能。如果你对Java非常了解，思考如何添加这样的支持就像是噩梦。
- en: The reason most languages aren’t good at supporting both of these traits simultaneously
    is that they conflict with each other. The richer a language is at the start,
    the more complicated it is. And the more complicated the language, the more painful
    it is to muck with that language. That’s why making your own changes to the most
    mature programming languages is close to impossible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言难以同时支持这两种特性，原因在于它们彼此冲突。语言越丰富，其复杂性就越高。而语言越复杂，对其进行修改就越痛苦。这就是为什么对最成熟的编程语言进行自我修改几乎是不可能的。
- en: Of course, if you try hard enough, you can always make fundamental changes to
    any language. For instance, when C++ was developed, it originally took the form
    of a C preprocessor. A special C program was written that could take code written
    in the new C++ dialect and convert it into plain-old C, which you could then just
    run through a standard C compiler. This is how Bjarne Stroustrup, the inventor
    of C++, was able to tweak the C language and add features to turn it into his
    own. However, writing a translator such as this is an extremely difficult and
    tedious process that you would consider only as a last resort.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只要你足够努力，你总是可以对任何语言进行根本性的改变。例如，在C++被开发出来时，它最初是以C预处理器形式出现的。编写了一个特殊的C程序，可以将用新的C++方言编写的代码转换为普通的C代码，然后你可以通过标准的C编译器来运行它。这就是Bjarne
    Stroustrup，C++的发明者，能够调整C语言并添加特性以使其成为自己的语言的原因。然而，编写这样的转换器是一个极其困难且繁琐的过程，你只会将其视为最后的手段。
- en: In contrast, Lisp languages make it extremely easy for an experienced Lisper
    to alter the compiler/interpreter that runs a program, while still supporting
    rich language features with extensive libraries. In fact, messing around with
    the language within Lisp is easier than in any other language ever created!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Lisp语言使得经验丰富的Lisper能够非常容易地修改运行程序的编译器/解释器，同时仍然支持丰富的语言特性和广泛的库。实际上，在Lisp中玩弄语言比在创建的任何其他语言中都更容易！
- en: For example, writing a function in Lisp to calculate the distance between two
    points would be simple, as in most other languages. But an experienced Lisper
    would find it equally easy to invent a new way to nest function definitions or
    devise a funky if-then command. Even writing your own object-oriented programming
    support inside Lisp is not complicated (and most Lispers have probably done so
    at some point). In Lisp, everyone gets to be a mini-Stroustrup!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Lisp中编写一个函数来计算两点之间的距离会很简单，就像在大多数其他语言中一样。但经验丰富的Lisper会发现，发明一种新的函数定义嵌套方式或设计一个有趣的if-then命令同样容易。甚至在你自己的Lisp中编写面向对象的编程支持也不复杂（而且大多数Lisper可能都曾在某个时刻这样做过）。在Lisp中，每个人都可以成为迷你版的Stroustrup！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages703117.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages703117.png.jpg)'
- en: How does Lisp make this neat feat possible? One of Lisp’s core characteristics
    is that writing a Lisp directly in Lisp is, itself, unbelievably simple. It turns
    out that *this is the key property* that allows Lisp to break the paradox of the
    two traits. By starting out as a language that could perform a cool mathematical
    trick of elegantly writing itself, it ended up possessing the very property needed
    to be both feature-rich *and* tweakable. That, in turn, makes it the perfect tool
    for actually writing just about any kind of program at all!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Lisp 是如何实现这一巧妙功能的？Lisp 的一个核心特性是，直接用 Lisp 编写 Lisp 本身，其简单程度令人难以置信。结果是，*这一点正是关键属性*，使得
    Lisp 能够打破两个特性的悖论。它最初作为一种能够执行优雅地编写自身的酷炫数学技巧的语言，最终拥有了既功能丰富又可调整的属性。这反过来又使其成为编写几乎所有类型程序的完美工具！
- en: 'Think of it this way: Give a programmer a `fish` command in his programming
    language, and he will eat Chinese takeout and drink Jolt for a day. Give a programmer
    a programming language that allows him to write his own `fish` command, and he’ll
    eat Chinese takeout and drink Jolt for a lifetime (which, admittedly, would probably
    be cut short by nutritional deficiencies, and let’s not even discuss the probable
    heart arrhythmias).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：给一个程序员他的编程语言中的 `fish` 命令，他可能会吃上一天的中国外卖，喝上 Jolt。给一个程序员一种允许他编写自己的 `fish`
    命令的编程语言，他可能会吃上一天的中国外卖，喝上 Jolt，并且这一习惯可能会持续一生（诚然，这可能会因为营养不足而缩短寿命，我们甚至都不想讨论可能的心律失常）。
- en: So, now you have an idea of why Lisp is a very cool and very unusual programming
    language. It has a long and atypical history compared with most programming languages.
    Most languages came from the world of engineering, whereas Lisp originated from
    a more mathematical background. It has a lot to offer to those willing to spend
    a little time learning something new.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你现在应该明白为什么 Lisp 是一种非常酷且非常独特的编程语言。与大多数编程语言相比，它有着漫长且不寻常的历史。大多数语言源于工程领域，而 Lisp
    则起源于一个更数学化的背景。对于那些愿意花点时间学习新事物的人来说，它有很多东西可以提供。
