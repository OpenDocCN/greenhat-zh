- en: Chapter 7. Using, Optimizing, and Testing Functional Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用、优化和测试函数式技术
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: This chapter shows some recursive and other functional solutions to simple problems,
    as well as some ways we can test and improve these solutions. Two very common
    programming topics that demonstrate functional programming are the factorial and
    Fibonacci mathematical series—largely because they’re so easily described using
    recursive means.^([[20](#ftn.CHP-7-FNOTE-1)])
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了简单问题的递归和其他功能性解决方案，以及我们可以测试和改进这些解决方案的一些方法。两个非常常见的编程主题，展示了函数式编程，是阶乘和斐波那契数学序列——很大程度上是因为它们很容易用递归方式来描述.^([[20](#ftn.CHP-7-FNOTE-1)])
- en: 'The *factorial* of a given positive number is the product of all the integers
    from 1 to that number, so factorial(3) = 3 x 2 x 1, factorial(5) = 5 x 4 x 3 x
    2 x 1, and so on. This can be expressed generally as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定正数的阶乘是该数从1到该数的所有整数的乘积，因此factorial(3) = 3 x 2 x 1，factorial(5) = 5 x 4 x
    3 x 2 x 1，依此类推。这可以一般地表示为：
- en: factorial(*x*) = *x* x (*x* – 1) x (*x* – 2) … 1
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: factorial(*x*) = *x* x (*x* – 1) x (*x* – 2) … 1
- en: 'The Fibonacci series is infinite, but you can look at a slice of it. The *Fibonacci*
    value for 0 is 0, and the value for 1 is 1\. Subsequent values are calculated,
    rather than preset. The number in the Fibonacci series at a given index is the
    sum of the previous two numbers. Therefore, the Fibonacci series starts like this:
    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, and so on. The formula for Fibonacci values for
    numbers greater than one can be expressed generally as Fibonacci(*x*) = Fibonacci(*x*-1)
    + Fibonacci(*x*-2).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列是无限的，但你可以查看其中的一段。斐波那契序列中0的值是0，1的值是1。后续的值是计算出来的，而不是预设的。斐波那契序列中给定索引的数是前两个数的和。因此，斐波那契序列开始如下：0,
    1, 1, 2, 3, 5, 8, 13, 21, 34，依此类推。对于大于1的数的斐波那契值的一般公式可以表示为Fibonacci(*x*) = Fibonacci(*x*-1)
    + Fibonacci(*x*-2)。
- en: If you think that the general definitions of both factorials and Fibonaccis
    look recursive, you’re right. We’ll look at Ruby code that generates both types
    of numbers using recursion.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为阶乘和斐波那契的一般定义看起来是递归的，你是正确的。我们将查看生成这两种类型的数字的Ruby代码，使用递归。
- en: '#26 Basic Factorials and Fibonaccis (factorial1.rb through fibonacci5.rb)'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#26 基本阶乘和斐波那契数（factorial1.rb至fibonacci5.rb）'
- en: 'The most common criticism of recursion and other functional techniques is that
    they are resource intensive. Each new version of these factorial or Fibonacci
    scripts adds some feature intended to *optimize* the code, or produce a speed
    improvement. In some cases, these features result in a very dramatic improvement,
    but in other cases, they either fail to improve the code or sometimes even make
    it worse. The places where these attempts fail to improve speed are often as interesting
    as where they succeed. There’s an old adage among programmers: *Premature optimization
    is the root of all evil*.^([[21](#ftn.CHP-7-FNOTE-2)]) Keep that in mind while
    reading these examples.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对递归和其他函数式技术的最常见的批评是它们资源密集。这些阶乘或斐波那契脚本的每个新版本都添加了一些旨在*优化*代码或提高速度的功能。在某些情况下，这些功能导致了非常显著的性能提升，但在其他情况下，它们要么未能提高代码性能，有时甚至使代码变得更差。这些尝试未能提高速度的地方往往与它们成功的地方一样有趣。程序员中有一个古老的谚语：*过早优化是万恶之源*.^([[21](#ftn.CHP-7-FNOTE-2)])
    在阅读这些示例时请记住这一点。
- en: The Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: 'For this chapter, we’ll be looking at some short scripts in pairs. Here’s `factorial1.rb`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将查看一些成对的简短脚本。这是`factorial1.rb`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And here’s `fibonacci1.rb`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fibonacci1.rb`：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How It Works
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'For `factorial1.rb` and `fibonacci1.rb`, we add a new method to all Integers:
    either `fact` or `fib`, respectively. In both cases, we have our exit conditions
    that `return` either zero or one. For factorials, we `return 1` when `self` is
    either `0` or `1`, testing for `0` with the predicate `zero?` (❶). For the Fibonacci
    series, we `return` either zero or one at ❸. At either ❷ or ❹, we `return` the
    appropriate calculated value: `self` times the factorial of one lower than `self`
    (❷), or the sum of the previous two Fibonaccis (❹), matching the definitions I
    gave for factorials and Fibonaccis, respectively. Both of these scripts are simple,
    accurate ways to produce the mathematical procedures we want. Let’s look at the
    results using irb. Note that we can require more than one library file with multiple
    `-r` flags.^([[22](#ftn.CHP-7-FNOTE-3)])'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `factorial1.rb` 和 `fibonacci1.rb`，我们为所有整数添加了一个新方法：分别是 `fact` 或 `fib`。在两种情况下，我们都有退出条件，即返回零或一。对于阶乘，当
    `self` 是零或一时，我们返回 `1`，使用谓词 `zero?`（❶）来测试零。对于斐波那契数列，我们在 ❸ 处返回零或一。在 ❷ 或 ❹ 处，我们返回适当的计算值：`self`
    乘以比 `self` 小一的阶乘（❷），或者前两个斐波那契数的和（❹），分别符合我给出的阶乘和斐波那契数的定义。这两个脚本都是简单、准确产生我们想要的数学过程的简单方法。让我们使用
    irb 来查看结果。注意，我们可以使用多个 `-r` 标志来 require 多个库文件.^([[22](#ftn.CHP-7-FNOTE-3)])
- en: The Results
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The factorial of 3 is 3 x 2 x 1, which is 6, so that’s fine. 6 x 4 is 24, and
    24 x 5 is 120\. So our fact method seems to work well. On to the fibonacci series.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3 的阶乘是 3 x 2 x 1，即 6，所以这是可以的。6 x 4 是 24，24 x 5 是 120。所以我们的 `fact` 方法似乎工作得很好。接下来是斐波那契数列。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first seven values in the Fibonacci series are 0, 1, 1, 2, 3, 5, and 8\.
    The *zeroth* number (the number at the 0 index) is 0, the first is 1, the second
    is also 1, the third is 2, the fourth is 3, and the fifth is 5\. Our `fib` method
    also seems to work well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列的前七个值是 0, 1, 1, 2, 3, 5, 和 8。*第零个*数字（位于 0 索引的数字）是 0，第一个是 1，第二个也是 1，第三个是
    2，第四个是 3，第五个是 5。我们的 `fib` 方法似乎也工作得很好。
- en: Hacking the Script
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗中修改脚本
- en: How could we improve the speed of this script? We have several options. I’ll
    outline each of them in turn and discuss the possible motivations for each change,
    but we’ll wait to test them (and therefore, to see the results of our assumptions)
    until the end.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何提高这个脚本的效率？我们有几个选择。我将依次概述每个选择，并讨论每个更改的可能动机，但我们将等到测试它们（因此，看到我们假设的结果）时再进行。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注记
- en: '*Modifying a computer program to improve it without changing its external behavior
    is called* refactoring. *That’s what we’re doing with these scripts, because we’re
    not changing the factorial or Fibonacci values for a given input—we’re just changing
    how (and possibly how quickly) we return the same value. Refactoring is a fascinating
    topic; you can read more about it at [http://refactoring.com](http://refactoring.com)
    or in Martin Fowler’s* Refactoring: Improving the Design of Existing Code *(Addison-Wesley
    Professional, 1999). Unit testing, which we’ll describe later in this chapter,
    is a critical tool to use when refactoring, as I’ll explain in that section*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*修改计算机程序以改进它而不改变其外部行为称为重构。这正是我们在这些脚本中所做的，因为我们没有改变给定输入的阶乘或斐波那契值——我们只是改变了返回相同值的方式（以及可能的速度）。重构是一个迷人的话题；你可以在
    [http://refactoring.com](http://refactoring.com) 或马丁·福勒的《重构：改善现有代码的设计》（Addison-Wesley
    Professional, 1999）中了解更多信息。单元测试是我们将在本章后面描述的，当重构时是一个关键的工具，我将在那一节中解释*。'
- en: Using include? (factorial2.rb and fibonacci2.rb)
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 include?（factorial2.rb 和 fibonacci2.rb）
- en: Here’s a variant that decides what to `return` via the `include?` method, which
    eliminates the need to run two separate tests to find out whether `self` is either
    zero or one. The motivation is that it could be faster to do a single test instead
    of two separate tests. Again, I’ll show the alterations for both the factorial
    and Fibonacci scripts. Notice how both ❺ lines differ from either ❶ or ❸ in the
    initial scripts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个变体，它通过 `include?` 方法来决定返回什么，从而消除了运行两个单独的测试来找出 `self` 是否为零或一的需求。动机是，进行单个测试可能比进行两个单独的测试要快。同样，我将展示阶乘和斐波那契脚本的修改。注意，❺
    行与初始脚本中的 ❶ 或 ❸ 有何不同。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s the Fibonacci script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是斐波那契脚本：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Passing the returns1 or returns_self Array as an Argument (factorial3.rb and
    fibonacci3.rb)
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将返回值或返回 self 数组作为参数传递（factorial3.rb 和 fibonacci3.rb）
- en: In these variants we have an Array called either `returns1` or `returns_self`
    that defines the return values for either a factorial or Fibonacci test. The Array
    is `[0, 1]` in both cases, because zero and one are the values we use in our rules
    to calculate other values in both tests. The motivation for this variant is the
    thought that it might be faster to create a data structure (such as `returns1`)
    once and pass it around, rather than re-creating our `[0, 1]` Array every time
    we make a new recursive call to either `fact()` or `fib()`. Notice how we define
    `returns1` or `returns_self` as an argument to each of our methods at ❻ in each
    script and then use it subsequently for both our exit conditions testing and as
    an explicit argument to the recursive calls (❼).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些变体中，我们有一个名为 `returns1` 或 `returns_self` 的数组，它定义了阶乘或斐波那契测试的返回值。在两种情况下，数组都是
    `[0, 1]`，因为零和一是我们用来在两种测试中计算其他值的规则中的值。这种变体的动机是认为，一次性创建一个数据结构（如 `returns1`）并传递它可能比每次对
    `fact()` 或 `fib()` 进行新的递归调用时重新创建我们的 `[0, 1]` 数组要快。注意我们如何在每个脚本中的❻处将 `returns1`
    或 `returns_self` 定义为每个方法的参数，然后随后用于我们的退出条件测试以及递归调用的显式参数（❷）。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the Fibonacci version:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是斐波那契版本：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Making RETURNS1 or RETURNS_SELF a Class Constant (factorial4.rb and fibonacci4.rb)
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 RETURNS1 或 RETURNS_SELF 设为类常量（factorial4.rb 和 fibonacci4.rb）
- en: 'Making `returns1` or `returns_self` an argument seems silly for one reason:
    It’s always the same value, `[0, 1]`. Things that don’t change are ideal constants,
    so let’s try that for both scripts. We’ll define a constant with an appropriate
    name at ❽ in each script and then use it in our method’s tests. Note that there
    is no longer any need to pass the constant as an argument to the recursive method
    calls, as we did in the previous variant at ❼.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `returns1` 或 `returns_self` 作为参数似乎有些荒谬，原因之一是它总是相同的值，`[0, 1]`。不变的事物是理想的常量，所以让我们在两个脚本中都尝试一下。我们将在每个脚本中的❽处定义一个具有适当名称的常量，并在我们的方法测试中使用它。请注意，不再需要将常量作为参数传递给递归方法调用，就像我们在上一个变体中的❷所做的那样。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the Fibonacci version:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是斐波那契版本：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Memoization of Results (factorial5.rb and fibonacci5.rb)
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果的缓存（factorial5.rb 和 fibonacci5.rb）
- en: One unexamined flaw in our scripts so far is that they’re stupid. It sounds
    harsh, but it’s fair.^([[23](#ftn.CHP-7-FNOTE-4)]) They keep repeating the same
    calculations over and over again. For the sake of example, let’s assume that we’ve
    called the `fib()` method on the Integer `5`, and `fib()` is as defined in `fibonacci4.rb`,
    our most recent Fibonacci script variant. What happens?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中的一个未检查到的缺陷是它们很愚蠢。听起来很严厉，但这是公平的.^([[23](#ftn.CHP-7-FNOTE-4)]) 它们不断地重复相同的计算。为了举例，让我们假设我们已经调用了整数
    `5` 的 `fib()` 方法，并且 `fib()` 如 `fibonacci4.rb` 中定义，这是我们最新的斐波那契脚本变体。会发生什么？
- en: 'The first thing of interest is that whenever our `5` is instantiated, it has
    a class constant called `RETURNS_SELF`, defined as an Array: `[0, 1]`. Next we
    call `fib()` on our `5\. RETURNS_SELF` does not `include? 5`, so we then call
    `fib()` on the expression `(5-1)`, which is of course the Integer `4`, and add
    its returned value to the result of calling `fib()` on the value `(5-2)`, also
    known as the Integer `3`. We then find that `RETURNS_SELF` does not `include?
    4`, either, so we then call `fib()` on the expressions `(4-1)`, which is the Integer
    `3`, and add its returned value to the result of calling `fib()` on the value
    `(4-2)`, also known as the Integer `2`. We keep doing this recursively until we
    get a value of `self` that is found within the `RETURNS_SELF` Array.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的第一件事是，每当我们的 `5` 被实例化时，它都有一个名为 `RETURNS_SELF` 的类常量，定义为数组：`[0, 1]`。接下来我们调用
    `fib()` 在我们的 `5.RETURNS_SELF` 上，它不包含 `5`，所以我们接着在表达式 `(5-1)` 上调用 `fib()`，这当然是整数
    `4`，并将它的返回值添加到调用 `fib()` 在值 `(5-2)` 上的结果，也称为整数 `3`。然后我们发现 `RETURNS_SELF` 也不包含
    `4`，所以我们接着在表达式 `(4-1)` 上调用 `fib()`，这是整数 `3`，并将它的返回值添加到调用 `fib()` 在值 `(4-2)` 上的结果，也称为整数
    `2`。我们继续递归地这样做，直到我们得到一个在 `RETURNS_SELF` 数组中找到的 `self` 值。
- en: The main problem with doing this is that we keep re-calculating methods like
    `3.fib()`. We had to calculate it in the guise of `(self-2).fib()` in our initial
    call to `5.fib()`, and we had to calculate it in the guise of `(self-1).fib()`
    when our value for `self` was `4`. The reason all this recalculation is a problem
    is that `3.fib()` gives the same result, whether it is called as `(5-2).fib()`
    or as `(4-1).fib()`—it’s the same thing under the hood. Wouldn’t it be great if
    there were a way to call something like `3.fib()` once and then remember its value
    for subsequent calls?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的主要问题是，我们不断重新计算像`3.fib()`这样的方法。在最初的`5.fib()`调用中，我们不得不以`(self-2).fib()`的形式计算它，当我们的`self`值为`4`时，我们不得不以`(self-1).fib()`的形式计算它。所有这些重复计算之所以成为问题，是因为无论`3.fib()`是以`(5-2).fib()`还是`(4-1).fib()`的形式被调用，它都给出相同的结果——在底层它是同一件事。如果有一种方法可以调用一次像`3.fib()`这样的东西，然后记住其值以供后续调用，那岂不是很好？
- en: There is such a technique. It’s called *memoization*, and it’s a critical way
    to make recursive programs use processor time more efficiently. Take a look at
    our new script variants, which take advantage of memoization. In both variants,
    we define an appropriately named Array at ❾ that holds the memoized results so
    far. We already have starting results for both `0` and `1`, which we defined in
    the `returns1` Array in our earlier examples. We then use that memoized results
    Array (either `@@factorial_results` or `@@fibonacci_results`) at ❿, using the
    `||=` operator to set a value for the `self` index within the Array, if there
    isn’t a value already. Since Ruby methods always return the last evaluated expression,
    we don’t need separate setting and returning operations. Now, whenever we need
    the `fact` or `fib` value for a lower `self`, we can just read it out. The `||=`
    operator at ❿ evaluates the element from the Array as `true` and simply returns
    it without making a new assignment.^([[24](#ftn.CHP-7-FNOTE-5)])
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 确实存在这样的技术。它被称为*memoization*，这是使递归程序更有效地使用处理器时间的关键方法之一。看看我们新的脚本变体，它们利用了memoization的优势。在这两种变体中，我们在❾处定义了一个适当命名的数组，用于存储迄今为止的memoized结果。我们已经在`returns1`数组中定义了`0`和`1`的起始结果，这是我们在早期示例中做的。然后我们在❿处使用这个memoized结果数组（无论是`@@factorial_results`还是`@@fibonacci_results`），使用`||=`运算符设置数组中`self`索引的值，如果还没有值的话。由于Ruby方法总是返回最后一个评估的表达式，我们不需要单独的设置和返回操作。现在，无论何时我们需要较低`self`的`fact`或`fib`值，我们都可以直接读取它。❿处的`||=`运算符将数组中的元素评估为`true`并简单地返回它，而不进行新的赋值.^([[24](#ftn.CHP-7-FNOTE-5)])
- en: A complement to memoization is lazy evaluation. Few languages implement this
    by default, Haskell being the most widely known exception. Most languages use
    *eager evaluation*, in which expressions are evaluated as early as possible, certainly
    on entry into a method or function. *Lazy evaluation* lets expressions be passed
    around unevaluated until their value is needed. The benefit for factorial and
    Fibonacci operations is that the operations on higher numbers can wait until the
    operations on lower numbers are already done, which speeds up the whole process.
    There’s a library for lazy evaluation in Ruby at [http://moonbase.rydia.net/software/lazy.rb](http://moonbase.rydia.net/software/lazy.rb).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: memoization的补充是lazy evaluation。很少有语言默认实现这一功能，Haskell是其中最广为人知的例外。大多数语言使用*eager
    evaluation*，即表达式尽可能早地被评估，至少在进入方法或函数时是这样。*Lazy evaluation*允许表达式在需要其值之前不进行评估。对于阶乘和斐波那契操作的好处是，对较大数字的操作可以等到对较小数字的操作完成后再进行，这可以加快整个过程。Ruby中有一个用于lazy
    evaluation的库，位于[http://moonbase.rydia.net/software/lazy.rb](http://moonbase.rydia.net/software/lazy.rb)。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Fibonacci version is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契版本是：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That should be enough variants to test. Note that this last factorial script
    also includes a method called `show_mems` that you can use to inspect the state
    of the memoization. If you’d like, you can add your own equivalent to `fibonacci5.rb`.
    On to the testing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够进行测试了。请注意，这个最后的阶乘脚本还包括一个名为`show_mems`的方法，您可以使用它来检查memoization的状态。如果您愿意，您可以为`fibonacci5.rb`添加自己的等效方法。接下来是测试。
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[20](#CHP-7-FNOTE-1)]) This is as good a place as any to mention tail recursion.
    A function or method is *tail recursive* if it can be easily converted from recursion
    (which is friendly to human readers at a high level of abstraction) to iteration
    (which is friendlier to computer hardware). The Ruby interpreter does not currently
    do such conversion. I mention this because we’ll be doing a lot of recursing in
    this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#CHP-7-FNOTE-1)]) 这是个很好的地方来提及尾递归。如果一个函数或方法可以轻松地从递归（在高级抽象层次上对人类读者友好）转换为迭代（对计算机硬件更友好），那么它就是*尾递归*。Ruby
    解释器目前不会进行这种转换。我提到这一点是因为我们将在本章中进行大量的递归操作。
- en: ^([[21](#CHP-7-FNOTE-2)]) Commonly attributed to Donald Knuth, a computer programming
    genius if there ever was one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-7-FNOTE-2)]) 通常归功于唐纳德·克努特，如果有的话，他是一位计算机编程天才。
- en: ^([[22](#CHP-7-FNOTE-3)]) The integers resulting from factorial and Fibonacci
    operations can become rather large. Luckily, Ruby allows you to just treat them
    all as Integers, transparently doing whatever operations are needed with Bignums
    and Fixnums without making you worry about such things.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-7-FNOTE-3)]) 由阶乘和斐波那契操作产生的整数可能会变得相当大。幸运的是，Ruby 允许你将它们都当作整数来处理，透明地执行所需的任何操作，无论是使用大数（Bignums）还是固定数（Fixnums），而无需你担心这些问题。
- en: ^([[23](#CHP-7-FNOTE-4)]) Maybe the criticism is more fair when directed at
    the author than the scripts. After all, the scripts only do what I tell them to.
    In fairness to me, I wrote them to demonstrate failed optimization attempts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-7-FNOTE-4)]) 可能当批评针对作者而不是脚本时，批评会更加公正。毕竟，脚本只是按照我的指示行事。为了公平起见，我编写它们是为了展示失败的优化尝试。
- en: ^([[24](#CHP-7-FNOTE-5)]) Our Perl friends do something similar to our use of
    `||=` here that they call the *Orcish Maneuver*. Look it up at [http://perl.plover.com/TPC/1998/Hardware-notes.html](http://perl.plover.com/TPC/1998/Hardware-notes.html)
    if you’re curious. The name comes from both a pun and the prevalence of *The Lord
    of the Rings* fandom in the Perl community.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-7-FNOTE-5)]) 我们的 Perl 朋友在这里使用 `||=` 的做法，他们称之为 *Orcish Maneuver*。如果你好奇，可以在
    [http://perl.plover.com/TPC/1998/Hardware-notes.html](http://perl.plover.com/TPC/1998/Hardware-notes.html)
    上查找。这个名字既是一个双关语，也反映了 Perl 社区中《指环王》粉丝的普遍性。
- en: '#27 Benchmarking and Profiling (tests/test_opts.rb)'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#27 基准测试和性能分析（tests/test_opts.rb）'
- en: Here we’ll talk about two distinct ways to test the execution speed of code.
    *Benchmarking* measures the overall speed of the code, while *profiling* gives
    more detailed information about how long different parts of the code take to execute,
    relative to each other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论两种测试代码执行速度的不同方法。*基准测试*衡量代码的整体速度，而*性能分析*则提供了更多关于代码不同部分执行时间相对关系的详细信息。
- en: Benchmarking
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: The previous variants all showed ways to modify the base code in the hopes of
    making it faster. Here’s where we test our assumptions and find out what really
    makes a difference. I store it in a directory called `tests`, meaning that I run
    it with `ruby -w tests/test_opts.rb`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的变体都展示了修改基础代码的方法，希望使其更快。这里我们将测试我们的假设，找出真正起作用的是什么。我将它们存储在一个名为 `tests` 的目录中，这意味着我使用
    `ruby -w tests/test_opts.rb` 来运行它们。
- en: The Code
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How It Works
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: First, I `require` a file called `‘benchmark’` (❶); the `include` command that
    immediately follows it mixes in a Module called Benchmark. This is the workhorse
    of our script. It provides a facility for testing how long specific operations
    take within a program. In order to do those tests, we need to set up a few Constants,
    which we do at ❷. The `FUNC_OF_FILE` constant contains the name of the method
    (or function) we want to call in each file, and `UPPER_OF_FILE` determines the
    largest Integer on which to call that function (the upper limit, in other words).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我 `require` 一个名为 `‘benchmark’` 的文件（❶）；紧接着的 `include` 命令将一个名为 Benchmark 的模块混合进来。这是我们脚本的功臣。它提供了一个测试程序中特定操作所需时间的功能。为了进行这些测试，我们需要设置一些常量，我们在❷处这样做。`FUNC_OF_FILE`
    常量包含我们想要在每文件中调用的方法（或函数）的名称，而 `UPPER_OF_FILE` 确定了调用该函数的最大整数（即上限）。
- en: At ❸, we loop through each `file`, and at ❹, we loop through each `num`, which
    is the filename suffix. Then we require a specific, dynamically generated filename
    at ❺. Note that this will override any previous definitions of methods with the
    same name. (This is why we will run this script without warnings, as the RDoc
    at the beginning of the file indicates.) We then set the value of the `upper`
    local variable. At ❻, we call the method `bm`, provided by the Benchmark module.
    It takes a block whose local variable is the `test` to be run. That `test` has
    a method called `report`, which (as the name suggests) generates a report of the
    test’s findings. The `report` method also takes a block that contains the code
    comprising the test. That block consists of only one line at ❽. We haven’t seen
    the `send` method yet, but calling `some_object.send( some_func_name, some_arg
    )` is the same as calling `some_object.some_func_name( some_arg )`. I’ll describe
    `send` in greater detail in the `to_lang.rb` script in [Chapter 10](ch10.html
    "Chapter 10. More Complex Utilities and Tricks, Part II"). For now, just understand
    that it calls the desired method (either `fact` or `fib`) for each file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在❸处，我们遍历每个`file`，在❹处，我们遍历每个`num`，即文件名后缀。然后我们在❺处需要特定的、动态生成的文件名。请注意，这将覆盖任何之前具有相同名称的方法定义。（这就是为什么我们将不带警告运行此脚本，因为文件开头的RDoc表明。）然后我们设置局部变量`upper`的值。在❻处，我们调用Benchmark模块提供的`bm`方法。它接受一个包含要运行的`test`的块的块。那个`test`有一个名为`report`的方法，正如其名所示，它会生成测试结果的报告。`report`方法还接受一个包含测试代码的块。那个块只包含一行❽。我们还没有看到`send`方法，但调用`some_object.send(some_func_name,
    some_arg)`与调用`some_object.some_func_name(some_arg)`相同。我将在第10章的`to_lang.rb`脚本中更详细地描述`send`。现在，只需理解它为每个文件调用所需的方法（无论是`fact`还是`fib`）即可。
- en: Running the Script
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: You’ll want to run this with the command `ruby tests/test_opts.rb`. Notice that
    we eschew the `-w` flag in this particular case. The reason is that we are redefining
    methods, which triggers a warning. Since we are doing this intentionally and are
    aware of the situation, the warning is merely an annoyance in this particular
    case.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用命令 `ruby tests/test_opts.rb` 来运行这个程序。注意，在这个特定情况下，我们避免了使用 `-w` 标志。原因是我们在重新定义方法，这会触发一个警告。由于我们是故意这样做并且清楚情况，所以在这个特定情况下，警告只是一个烦恼。
- en: The Results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Here are my results. Your results may vary considerably, depending on how fast
    your machine is.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的结果。你的结果可能会因机器的速度而有所不同。
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The benchmarking output shows seconds used from the perspective of the user,
    system, total, and real labels. You can read more about the specific meanings
    of these labels via the command `man time` on a Unix-like system. For now, keep
    in mind that they are useful for measuring the time one process takes, relative
    to another process. I’ll be referring to the `real` time in my discussion. You
    can see that there is very little variation among the factorial scripts. The main
    reason for this is that the factorial operation is comparatively simple, since
    it is a single, recursive multiplication. We see more striking data for the Fibonacci
    scripts because each recursive Fibonacci operation spawns two additional Fibonacci
    operations, unless it uses memoization. This double spawning is why I set the
    upper limit of Fibonacci operations at the much lower value of 30, compared with
    the factorial’s upper limit of 200.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试输出显示了用户、系统、总时间和实际标签视角下使用的秒数。你可以在类Unix系统上通过命令 `man time` 了解这些标签的具体含义。现在，请记住，它们对于测量一个进程相对于另一个进程所花费的时间是有用的。在我的讨论中，我会提到
    `real` 时间。你可以看到，在阶乘脚本之间几乎没有变化。这主要是因为阶乘操作相对简单，因为它是一个单一的递归乘法。对于斐波那契脚本，我们看到了更引人注目的数据，因为每个递归斐波那契操作会生成两个额外的斐波那契操作，除非它使用了记忆化。这种双重生成是为什么我将斐波那契操作的上限设置为比阶乘上限200要低得多的30。
- en: Our tests showed that the simple `fibonacci1.rb` took about 6.20 seconds to
    run 30 consecutive operations of calling `fib` on the numbers from one to five.
    Things actually get worse when we try the `include?` optimization in `fibonacci2.rb`
    (it takes about 8.56 seconds), and improve only slightly for the argument optimization
    in `fibonacci3.rb` (which takes about 6.81 seconds). The run time doesn’t significantly
    change until we introduce memoization in `fibonacci5.rb`, where the time spent
    drops so much that it’s no longer significant.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试显示，简单的`fibonacci1.rb`运行30次连续操作调用`fib`从一到五的数字大约需要6.20秒。当我们尝试在`fibonacci2.rb`中应用`include?`优化时（它需要大约8.56秒），情况实际上变得更糟，而在`fibonacci3.rb`中的参数优化（大约需要6.81秒）仅略有改善。直到我们在`fibonacci5.rb`中引入记忆化，运行时间才没有显著变化，花费的时间减少到不再显著。
- en: The moral of the story is twofold. First, we’ve learned that it’s better to
    base code optimization for speed on tests, rather than intuitions. By trying to
    squeeze some faster performance out of a piece of code, you can waste time in
    an area that isn’t even your speed bottleneck, and it will only make your code
    harder to read. The second moral is that memoization (as used in `factorial5.rb`
    and `fibonacci5.rb`) is a crucial addition to any recursive operations that are
    likely to be repeated.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事有两个寓意。首先，我们学到的是，基于测试而不是直觉来优化代码以提高速度会更好。试图从一段代码中挤出一些更快的性能可能会让你在一个甚至不是你的速度瓶颈的领域浪费时间，这只会让你的代码更难阅读。第二个寓意是，记忆化（如在`factorial5.rb`和`fibonacci5.rb`中使用）是任何可能重复的递归操作的关键补充。
- en: Profiling
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件
- en: Of course, benchmarking is only part of the story. If you’re worried about the
    speed of your code, knowing only the total time it takes to run is not especially
    useful. What’s more useful is the information provided by *profiling*, which breaks
    down the parts of your code and gives speed reports at a finer level of detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，基准测试只是故事的一部分。如果你担心代码的速度，只知道它运行所需的总时间并不是特别有用。更有用的是*配置文件*提供的信息，它将你的代码分解成部分，并在更细致的细节级别提供速度报告。
- en: 'Ruby has a profiling library called `profile`. It can be `require` d, just
    like benchmark, but it doesn’t demand specific testing code like the `bm` method
    and its block. The library can be automatically applied to an execution of code
    simply by including `profile` via the `-r` flag. Let’s do so with a command-line
    execution of the first script we wrote:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby有一个名为`profile`的配置文件库。它可以像基准测试一样`require`，但它不要求像`bm`方法及其块那样的特定测试代码。只需通过`-r`标志包含`profile`，就可以自动将库应用于代码的执行。让我们用命令行执行我们编写的第一个脚本：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice how all we have to do is require `profile` with the `-r` flag; our `-e`
    flag contains code to be executed that works just like the irb session we used
    with `99bottles.rb` when we wrote it in [Chapter 2](ch02.html "Chapter 2. Amusements
    and Simple Utilities"). Here is an extremely truncated version of its results:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需使用`-r`标志来`require``profile`；我们的`-e`标志包含要执行的代码，这与我们在[第2章](ch02.html "第2章。娱乐和简单工具")中编写`99bottles.rb`时使用的irb会话类似。以下是其结果的极度简化版本：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This report provides a great deal of interesting information, including the
    percentage of total time that a given method takes, the raw seconds used by that
    method call, the number of calls to each method, and the number of milliseconds
    taken per call. This data gives you something to use when you’re trying to improve
    execution speed. If the number of calls to a given method is high, perhaps the
    method is being called multiple times in a loop. You can increase speed by pre-running
    that method only once and passing its value into the loop for use. You can also
    try different ways of implementing the same operation to see which way runs faster,
    and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这份报告提供了大量有趣的信息，包括给定方法占用的总时间的百分比，该方法调用使用的原始秒数，每个方法的调用次数，以及每次调用所花费的毫秒数。这些数据在你试图提高执行速度时可以为你提供一些有用的信息。如果给定方法的调用次数很高，那么这个方法可能在循环中被多次调用。你可以通过仅预先运行该方法一次并将它的值传递到循环中以供使用来提高速度。你还可以尝试以不同的方式实现相同的操作，看看哪种方式运行得更快，等等。
- en: Hacking the Script
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: There are several variations you could try with these scripts. The simplest
    code modifications involve changing the upper limit values in `upper_of_file`
    for each `file`. You can also try operations other than factorial or Fibonacci
    ones. You can also run any of the scripts in this book with `-r profile`. When
    writing them, I focused on pedagogy rather than speed, so you can probably make
    some speed improvements to these stock scripts. Now let’s move on to a practical
    application of functional programming that should remind you of some earlier scripts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这些脚本尝试几种不同的变体。最简单的代码修改涉及更改每个`file`的`upper_of_file`中的上限值。你也可以尝试除了阶乘或斐波那契之外的运算。你还可以使用`-r
    profile`选项运行本书中的任何脚本。在编写它们时，我更注重教学法而不是速度，所以你可能会对这些标准脚本进行一些速度改进。现在让我们继续到功能性编程的实际应用，这应该会让你想起一些早期的脚本。
- en: '#28 Converting Temperatures (temperature_converter.rb)'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#28 温度转换（temperature_converter.rb）'
- en: For this example, we’ll write a converter script. This time, instead of converting
    currencies, we’ll convert units for other real-world factors like length, mass,
    temperature, and so on. The version that I show here only handles temperatures,
    but you can download `units_converter.rb` at this book’s companion website; it
    is a more comprehensive script that also handles length, volume, and mass. We’ll
    concentrate on converting to and from English and metric units, but we’ll also
    support kelvins. Let’s take a look.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将编写一个转换脚本。这次，我们不会转换货币，而是将其他现实世界因素（如长度、质量、温度等）的单位进行转换。这里展示的版本只处理温度，但你可以从本书的配套网站上下载`units_converter.rb`；这是一个更全面的脚本，也处理长度、体积和质量。我们将专注于转换到和从英制和公制单位，但也会支持开尔文。让我们看看。
- en: The Code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How It Works
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'This script uses a few functional techniques that we haven’t covered yet. Let’s
    step through the code. At ❶, we define a `BASE_UNIT_OF` Hash that holds the base
    unit. Note that *temperature* and *temp* are both acceptable, and that the script
    uses kelvins, the scientific unit of absolute temperature, as its internal temperature
    unit. Next, we define some helpful conversion constants. I’ve broken these up
    into paragraphs: The first paragraph of definitions (❷) holds simple addition
    and multiplication constants, while the second paragraph (❸) uses `lambda` to
    define Procs that will use the values from the first paragraph. Temperature conversion
    is a bit more complicated than conversion of length or mass.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本使用了一些我们还没有介绍的功能性技巧。让我们逐步查看代码。在❶处，我们定义了一个包含基本单位的`BASE_UNIT_OF`哈希表。请注意，*温度*和*temp*都是可接受的，并且脚本使用开尔文，作为绝对温度的科学单位，作为其内部温度单位。接下来，我们定义了一些有用的转换常数。我将它们分成了几个段落：定义的第一段（❷）包含简单的加法和乘法常数，而第二段（❸）使用`lambda`定义了将使用第一段中值的进程。温度转换比长度或质量的转换要复杂一些。
- en: Most unit conversions consist of a simple multiplication operation. If you have
    100 pounds and you want to know how many kilograms that is, you simply multiply
    100 by 0.45\. But to convert temperature between Fahrenheit and Celsius, you must
    multiply *and* add. The general formula is F = ( C x 9/5 ) + 32\. Conversely,
    C = ( F – 32 ) x 5/9\. Note also that one degree Celsius and one kelvin are the
    same size (meaning there is no multiplication needed to convert between them),
    but they are offset by 273.15, so 0 degrees Celsius = 273.15 kelvins, and 0 kelvins
    (absolute zero) = -273.15 degrees Celsius. That’s cold.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数单位转换都包含一个简单的乘法操作。如果你有100磅，想知道这是多少千克，你只需将100乘以0.45。但是，要将华氏度和摄氏度之间的温度进行转换，你必须乘以并加上。通用公式是
    F = ( C x 9/5 ) + 32。相反，C = ( F – 32 ) x 5/9。请注意，一度摄氏度和一度开尔文的大小相同（这意味着在它们之间转换不需要乘法），但它们相差273.15，所以0摄氏度
    = 273.15开尔文，0开尔文（绝对零度）= -273.15摄氏度。这很冷。
- en: At ❸, we define constants with three-character names that suggest the type of
    temperature conversion they do; for example, the `K2C` conversion Proc accepts
    kelvins and returns the Celsius equivalent. Most of these are pretty straightforward
    and implement the temperature relationships I described in the paragraph of declarations
    (❷).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在❸处，我们使用三个字符的名称定义了常数，这些名称暗示了它们所进行的温度转换类型；例如，`K2C`转换进程接受开尔文并返回相应的摄氏度。大多数这些都很直接，并实现了我在声明段落（❷）中描述的温度关系。
- en: 'However, the `F2K` and `K2F` Procs are more interesting. They use previously
    defined Procs inside themselves and then use the `call` method successively to
    perform two-stage conversions. `F2K` accepts some Fahrenheit value `f`, converts
    that to Celsius via `F2C.call(f)`, and then uses that Celsius value as the argument
    to `C2F.call()`. This general operation of performing successive function calls
    is called *composition*. `F2K` composes `C2K` and `F2C`, and `K2F` composes `C2F`
    and `K2C`. This has the same benefits as breaking operations up into functions
    or methods: You only need to have a single, definitive place where any given operation
    is defined, and you can just call that operation as you build more complicated
    operations that depend on earlier definitions.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`F2K`和`K2F` Proc更引人注目。它们在自身内部使用先前定义的Proc，然后使用`call`方法连续执行两阶段转换。`F2K`接受一些华氏值`f`，通过`F2C.call(f)`将其转换为摄氏度，然后使用这个摄氏值作为`C2F.call()`的参数。这种连续执行函数调用的通用操作称为*组合*。`F2K`组合了`C2K`和`F2C`，而`K2F`组合了`C2F`和`K2C`。这具有将操作分解成函数或方法相同的优点：你只需要有一个单一、明确的定义位置，就可以在构建更复杂的、依赖于早期定义的操作时调用该操作。
- en: We have some useful constants, including temperature-related Procs. Next is
    our `CONVERSIONS` Hash at ❹. This is a doubly nested Hash, and the outermost keys
    are the units we have. Each of those keys points to yet another Hash, with a key
    representing the units we want to convert to and a value that is the necessary
    conversion Proc. If we have degrees Celsius and we want kelvins, our conversion
    operation is `CONVERSIONS[‘C’][‘K’]`, which is the `C2K` Proc constant.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些有用的常量，包括与温度相关的Proc。接下来是❹处的`CONVERSIONS`哈希。这是一个双层嵌套的哈希，最外层的键是我们拥有的单位。每个键都指向另一个哈希，其键表示我们想要转换到的单位，其值是必要的转换Proc。如果我们有摄氏度，我们想要开尔文，我们的转换操作是`CONVERSIONS[‘C’][‘K’]`，这是`C2K`
    Proc常量。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The purpose of the *`CONVERSIONS`* Hash is to pass in some identifier(s) and
    get something useful out, specifically the Proc needed to do the requested unit
    conversion. This is very similar to a* Factory *in object orientation, which is
    an object that creates other objects based on the parameters it receives. Our
    *`CONVERSIONS`* Hash is an example of the same concept applied to Procs*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*`CONVERSIONS`哈希的目的在于传入一些标识符并得到一些有用的输出，具体来说是执行所需单位转换所需的Proc。这与面向对象中的*工厂*非常相似，这是一个根据接收到的参数创建其他对象的对象。我们的`CONVERSIONS`哈希是应用了相同概念到Proc的例子*。'
- en: The first paragraph of data in `CONVERSIONS` converts to our base unit for each
    factor—kelvins, in our case. But what if someone asks for a final output that
    isn’t our base unit? We need to be able to convert from the base unit to all the
    other units, which is what the next paragraph of code at ❺ is for. It’s still
    part of the `CONVERSIONS` Hash, and it still follows the same structure of `{
    have => { want => some_conversion_proc } }`, but it has two conversion targets
    instead of one. We close the constants with `OUTPUT_FORMAT`, which restricts our
    reported values to two decimal places.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONVERSIONS`中的数据的第一段将每个因子的基单位转换为我们的基单位——在我们的例子中是开尔文。但是，如果有人要求一个最终输出不是我们的基单位呢？我们需要能够将基单位转换为所有其他单位，这正是❺处代码的下一部分的目的。它仍然是`CONVERSIONS`哈希的一部分，并且仍然遵循相同的结构`{
    have => { want => some_conversion_proc } }`，但它有两个转换目标而不是一个。我们使用`OUTPUT_FORMAT`关闭常量，这限制了我们的报告值只保留两位小数。'
- en: 'At ❻ we define our main method, called `convert`. It takes a mandatory argument
    called `params` and defines a local variable called `conversion_proc` that has
    the value of either `CONVERSIONS[params[:have_unit]][params[:want_unit]]` or,
    failing that, the output of `get_proc_via_base_unit(params)`. We already know
    that the value of `CONVERSIONS[‘C’][‘K’]` is the Celsius-to-kelvins Proc. Let’s
    verify that in irb:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在❻处，我们定义了我们的主要方法，称为`convert`。它接受一个名为`params`的必选参数，并定义了一个名为`conversion_proc`的局部变量，其值为`CONVERSIONS[params[:have_unit]][params[:want_unit]]`或，如果失败，则为`get_proc_via_base_unit(params)`的输出。我们已经知道`CONVERSIONS[‘C’][‘K’]`的值是摄氏度到开尔文的Proc。让我们在irb中验证这一点：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is another key to `params` here other than `:have_units` and `:want_units`,
    but it should be fairly clear. We also need to tell the converter how many units
    we have, which is what `:have_num` does. These results look good; they are examples
    in which there is a value available for `CONVERSIONS[params[:have_unit]][params[:want_unit]]`
    inside the `convert` method, meaning that it doesn’t need to use `get_proc_via_base_unit(params)`.
    After it’s got the `conversion_proc`, it returns the output you already saw in
    irb, which shows the number and unit already known, and what it converts into.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`:have_units`和`:want_units`之外，`params`中还有一个键，但应该相当明显。我们还需要告诉转换器我们有多少个单位，这正是`:have_num`的作用。这些结果看起来不错；它们是`convert`方法内部`CONVERSIONS[params[:have_unit]][params[:want_unit]]`有值的例子，这意味着它不需要使用`get_proc_via_base_unit(params)`。在获取到`conversion_proc`后，它返回你在irb中已经看到的输出，显示了已知数量和单位以及它转换成什么。
- en: This is straightforward enough. But what happens when there isn’t a value for
    `CONVERSIONS[params[:have_unit]][params[:want_unit]]` available? This would be
    true in cases such as converting degrees Celsius to degrees Fahrenheit. There
    is no Proc at `CONVERIONS[‘C’][‘F’]`. Does this mean that our base unit needs
    to be either the known or desired value? Yes and no. Yes in only the most pedantic
    sense. No in any practical sense, because we can use the `get_proc_via_base_unit`
    method to create our own `conversion_proc` by composing two other known `conversion_procs`,
    just like the ones we hard-coded into the temperature converters.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。但是当`CONVERSIONS[params[:have_unit]][params[:want_unit]]`没有可用值时会发生什么？这在将摄氏度转换为华氏度的例子中是正确的。在`CONVERIONS['C']['F']`中没有Proc。这意味着我们的基本单位需要是已知的或期望的值吗？是的，但仅从最字面意义上的角度来说。不，从任何实际意义上来说，因为我们可以使用`get_proc_via_base_unit`方法通过组合两个已知的`conversion_procs`来创建自己的`conversion_proc`，就像我们在温度转换器中硬编码的那样。
- en: If the unit our `params` asks for doesn’t have a built-in conversion Proc, we
    can use `get_proc_via_base_unit`, as noted. Inside `get_proc_via_base_unit`, we
    first get the `base_unit` (❼). We then create the `have_to_base_proc` by getting
    the Proc out of `CONVERIONS` that would be used to convert from the known unit
    to the `base_unit` (❽). Then we get the `base_to_want_proc` by getting the Proc
    out of `CONVERIONS` that would be used to convert from the `base_unit` to the
    unit we want (❾). Then at ❿, we compose `base_to_want_proc` and `have_to_base_proc`,
    just as we did in the ❸ section for `F2K` and `K2F`. We could have called our
    new Proc `have_to_want_proc`, but we just `return` it, and it becomes `conversion_proc`
    inside the `convert` method at ❻.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`params`请求的单元没有内置的转换Proc，我们可以使用`get_proc_via_base_unit`，如前所述。在`get_proc_via_base_unit`内部，我们首先获取`base_unit`（❼）。然后我们通过从`CONVERIONS`中获取Proc来创建`have_to_base_proc`，该Proc将用于将已知单位转换为`base_unit`（❽）。然后我们通过从`CONVERIONS`中获取Proc来创建`base_to_want_proc`，该Proc将用于将`base_unit`转换为我们要的单位（❾）。然后在❿处，我们将`base_to_want_proc`和`have_to_base_proc`组合起来，就像我们在❸部分为`F2K`和`K2F`所做的那样。我们本可以称我们的新Proc为`have_to_want_proc`，但我们只是`return`它，并在❻的`convert`方法中成为`conversion_proc`。
- en: The Results
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s try it out in irb. It was 65 degrees Fahrenheit in Buffalo, New York in
    November today (yes, really), and I was talking with a Canadian coworker about
    this temperature conversion script. Let’s start with that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在irb中试试。今天纽约布法罗的温度是65华氏度（是的，真的），我和一位加拿大同事在谈论这个温度转换脚本。让我们从这里开始。
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These examples should give you an idea of this program’s interface. You can
    also call it with other conversions that are of interest to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子应该能给你这个程序界面的一个概念。你也可以用其他对你有意义的转换来调用它。
- en: Hacking the Script
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操控脚本
- en: As I already noted, there is a more complex version of this script available
    for download at the book’s website. If you find that you want to convert to or
    from units that I don’t have built in, just create a key/value pair in `CONVERSIONS`
    that converts from your new unit to the appropriate base unit and another that
    converts from the base unit to your new unit. That should give you the ability
    to convert to and from any unit relative to your new unit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，这本书的网站上有一个更复杂的脚本版本可供下载。如果你发现你想转换到或从我没有内置的单元，只需在`CONVERSIONS`中创建一个键/值对，将你的新单元转换为适当的基单位，另一个将基单位转换为你的新单元。这应该会给你转换到和从任何相对于你的新单元的能力。
- en: 'We also use implicit composition in `temperature_converter.rb`—at ❸ for definition
    and at ❿ for use. You could modify the script to have an explicit `compose` method
    that takes two Procs and returns a new Proc that performs each operation in order.
    Here’s an example in irb:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `temperature_converter.rb` 中使用了隐式组合——在第❸行进行定义，在第❿行进行使用。你可以修改脚本以包含一个显式的
    `compose` 方法，该方法接受两个 Procs 并返回一个新的 Proc，该 Proc 按顺序执行每个操作。以下是在 irb 中的示例：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Line 8 gives us `2`, because `(1 ** 1) + 1 = 2`. Line 9 gives us `5`, because
    `(2 ** 2) + 1 = 5`. Line 10 gives us `9`, because `(2 + 1) ** 2 = 9`. Once you
    have this `compose` method, you can even use it on Procs that are the returned
    value from a previous call to `compose`, allowing you to stack successive operations
    as much as you like.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行给出了 `2`，因为 `(1 ** 1) + 1 = 2`。第9行给出了 `5`，因为 `(2 ** 2) + 1 = 5`。第10行给出了 `9`，因为
    `(2 + 1) ** 2 = 9`。一旦你有了这个 `compose` 方法，你甚至可以将其用于从之前的 `compose` 调用返回的 Procs，允许你堆叠尽可能多的连续操作。
- en: '#29 Testing temperature_converter.rb (tests/test_temp_converter.rb)'
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#29 测试 temperature_converter.rb (tests/test_temp_converter.rb)'
- en: Up until this point, our testing scripts have been relatively primitive, and
    to a very large degree, we have rolled our own testing solutions. It’s silly to
    do that repeatedly, especially in computer programs, because good programming
    languages allow you to express abstract concepts abstractly, as well as to adapt
    general-purpose tools in code libraries to your specific needs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的测试脚本相对原始，并且在很大程度上，我们一直在自己编写测试解决方案。这样做是愚蠢的，尤其是在计算机程序中，因为好的编程语言允许你以抽象的方式表达抽象概念，以及将代码库中的通用工具适应你的特定需求。
- en: Ruby has a general-purpose testing library called `Test::Unit`. Here is code
    that allows you to use its power to test the script `temperature_converter.rb`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有一个名为 `Test::Unit` 的通用测试库。以下代码允许你使用其功能来测试 `temperature_converter.rb` 脚本。
- en: The Code
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Results
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: Let’s run it and see what happens.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它看看会发生什么。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All four of our assertions passed with no failures or errors. That’s wonderful
    news. Now let’s look at what it means.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有断言都通过了，没有失败或错误。这是个好消息。现在让我们看看这意味着什么。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*One term you may hear in reference to testing is* code coverage, *which is
    the degree to which the tests adequately examine the pertinent code. This can
    be defined in terms of the percentage of total code lines that are tested, the
    percentage of Boolean evaluations that are tested, and other similar metrics*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能听到的与测试相关的术语之一是* 代码覆盖率，*这是测试充分检查相关代码的程度。这可以用测试的总代码行数的百分比、测试的布尔评估的百分比和其他类似指标来定义*。'
- en: Earlier in this chapter, I mentioned refactoring, the practice of cleaning up
    code implementation while leaving its behavior unchanged. Unit testing is very
    useful when refactoring, especially if you use tests that have high *entry/exit
    coverage*, meaning they try to ensure that all outputs from functions stay the
    same as long as those functions get the same inputs. This type of testing keeps
    your refactoring honest.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我提到了重构，这是一种在保持行为不变的同时清理代码实现的做法。单元测试在重构时非常有用，尤其是如果你使用具有高 *入口/出口覆盖率* 的测试，这意味着它们试图确保只要函数得到相同的输入，函数的所有输出都保持不变。这种类型的测试能让你保持重构的诚实性。
- en: How It Works
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: First, we need access to the code that we’ll be testing. Luckily, we’ve followed
    good design practice and defined our code in a library called `temperature_converter.rb`,
    so we `require` both it and the `test/unit` library at ❶. Then we define a new
    class called `Tester;` as you can see at ❷, this class is a child of `Test::Unit::TestCase`,
    meaning that it inherits all of the methods and characteristics of `Test::Unit::TestCase`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要访问我们将要测试的代码。幸运的是，我们已经遵循了良好的设计实践，并在名为 `temperature_converter.rb` 的库中定义了我们的代码，所以我们
    `require` 了它和 `test/unit` 库，在第❶行。然后我们定义了一个新的类 `Tester;`，如你所见在第❷行，这个类是 `Test::Unit::TestCase`
    的子类，这意味着它继承了 `Test::Unit::TestCase` 的所有方法和特性。
- en: We then define a testing method called `test_temps`. It’s just a wrapper for
    a multi-level Hash called `tests`, defined at ❸ inside `test_temps`. You’ll notice
    that each key of `tests` is a String that looks like the output of `Units_Converter.convert`;
    that key’s value is a Hash that you use as the argument into `Units_Converter.convert`
    in order to get output that matches that key. Inside `test_temps`, we then pass
    `tests` as an argument into a private method called `general_tester`, which we
    define at ❹.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了一个名为 `test_temps` 的测试方法。它只是一个多级哈希 `tests` 的包装器，该哈希在 `test_temps` 中的❸处定义。你会注意到
    `tests` 的每个键都是一个看起来像 `Units_Converter.convert` 输出的字符串；该键的值是一个哈希，你将其用作 `Units_Converter.convert`
    的参数，以获取与该键匹配的输出。在 `test_temps` 中，我们随后将 `tests` 作为参数传递给一个名为 `general_tester` 的私有方法，我们在❹处定义了它。
- en: The `general_tester` method loops through `each_pair` in the `tests` Hash at
    ❺, calling the expected result `result` and the argument Hash needed to produce
    that `result, test_args`. For each of those pairs, we assert that `result` and
    `@converter.convert( test_args )` are equal, using the appropriately named `assert_equal`
    method (❻). That’s all there is to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`general_tester` 方法在 `tests` 哈希中的 `each_pair` 上循环，在❺处调用预期的结果 `result` 和生成该
    `result` 所需的参数哈希 `test_args`。对于这些成对中的每一个，我们断言 `result` 和 `@converter.convert(test_args)`
    是相等的，使用名为 `assert_equal` 的适当方法（❻）。这就是全部内容。'
- en: Hacking the Script
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: Try making a change in one of the `tests` Hashes. If you either change only
    the key (which becomes `result` in `general_tester`) or only the value (which
    becomes `test_args` in `general_tester`), the call to `assert_equal` will fail,
    because the two items passed as arguments to be compared will no longer be equal.
    You can also add entirely new elements to the `tests` Hash, with new values you
    want to verify.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `tests` 哈希中的一个更改。如果你只更改了键（在 `general_tester` 中变为 `result`），或者只更改了值（在 `general_tester`
    中变为 `test_args`），则 `assert_equal` 的调用将失败，因为作为比较参数传递的两个项目将不再相等。你还可以向 `tests` 哈希中添加全新的元素，并使用你想要验证的新值。
- en: This script only scratches the surface of how to use `Test::Unit`. Type `ri
    Test::Unit` at the command line for more information. You can also browse to [http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc](http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc)
    within the Ruby Standard Library Documentation site. Note that the HTML generated
    for that documentation came from RDoc.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本只是展示了如何使用 `Test::Unit` 的一小部分。在命令行中输入 `ri Test::Unit` 以获取更多信息。您还可以浏览到 Ruby
    标准库文档网站中的 [http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc](http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc)。请注意，该文档的
    HTML 是由 RDoc 生成的。
- en: I already mentioned that testing can be useful during refactoring. A good place
    to start with testing is what I’ve done here, pre-figuring expected values from
    a method based on a set of known input parameters. The `assert_equal` method is
    very useful for such testing. There are other methods available, which you can
    read about by typing `ri Test::Unit::Assertions` at the command line. Notables
    include `assert_instance_of`, which checks whether its argument belongs to a specified
    class; `assert_nil`, which checks whether its argument is `nil`; `assert_raise`,
    which you can use to intentionally raise an Exception (i.e., break something);
    and `assert_respond_to`, which checks whether a given argument knows how to respond
    to a given specified method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到，测试在重构过程中非常有用。测试的一个好起点是我在这里所做的工作，基于一组已知的输入参数预先推断出方法的结果。`assert_equal` 方法对于此类测试非常有用。还有其他一些方法可用，你可以在命令行中输入
    `ri Test::Unit::Assertions` 来了解它们。值得注意的是 `assert_instance_of`，它检查其参数是否属于指定的类；`assert_nil`，它检查其参数是否为
    `nil`；`assert_raise`，你可以用它来故意抛出异常（即破坏某些东西）；以及 `assert_respond_to`，它检查给定的参数是否知道如何响应给定的指定方法。
- en: Chapter Recap
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: What was new in this chapter?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有哪些新内容？
- en: Recursive factorials and Fibonaccis as good profiling candidates
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归阶乘和斐波那契数列作为良好的性能分析候选者
- en: Refactoring
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: Memoization
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Testing with Benchmark
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Benchmark 进行测试
- en: Profiling
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Converting temperatures
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换温度
- en: Hashes with Proc values as Proc Factories
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 Proc 值的哈希作为 Proc 工厂
- en: Composition of Procs
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程的组成
- en: Testing with `Test::Unit`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Test::Unit` 进行测试
- en: Again, that’s a lot to take in. This list is deceptively short, because some
    of these concepts require more contemplation than those we’ve considered in previous
    chapters. Let’s move on to the next chapter, in which we’ll write some tools for
    processing HTML and XML.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这需要很多理解。这个列表看起来很短，因为其中一些概念需要比我们在前几章中考虑的概念更多的思考。让我们继续到下一章，我们将编写一些处理 HTML
    和 XML 的工具。
