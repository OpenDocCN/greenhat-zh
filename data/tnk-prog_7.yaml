- en: Chapter 7. Solving Problems with Code Reuse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用代码复用来解决问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: 'This chapter is very different from those that came before. In previous chapters,
    I stressed the importance of finding your own solution to problems. That’s what
    the book is about, after all: writing original solutions to programming problems.
    Even in previous chapters, though, we talked about how you are always learning
    from what you’ve written before, and that’s why you should retain all the code
    that you write for future reference. In this chapter, we’ll go one step further
    and discuss how to use code and ideas from other programmers to solve our problems.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与之前的内容有很大不同。在之前的章节中，我强调了找到自己解决问题的方法的重要性。毕竟，这本书的主题就是：编写原创的编程问题解决方案。即使在之前的章节中，我们也讨论了如何从你之前写过的内容中学习，这就是为什么你应该保留你写的所有代码以供将来参考。在本章中，我们将更进一步，讨论如何使用其他程序员的代码和想法来解决我们的问题。
- en: If you remember how this book started, this topic may seem like an odd inclusion.
    At the beginning, I talked about what a mistake it was to try to solve complex
    problems by modifying someone else’s code. Not only does this have a low chance
    of success, but even when it succeeds, it provides no learning experience for
    you. And if this is all you ever do, you never actually become a programmer and
    are of limited use in software development. That said, once any programming problem
    reaches a respectable size, it’s not reasonable to expect a programmer to develop
    a solution entirely from scratch. That’s an inefficient use of the programmer’s
    time, and it relies too heavily on the programmer being an expert in all things.
    Plus, it’s more likely to lead to a buggy or difficult-to-maintain program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得这本书是如何开始的，这个话题可能看起来有些奇怪。一开始，我谈到了试图通过修改别人的代码来解决复杂问题是一个错误。这不仅成功的可能性很低，即使成功了，也不会给你提供任何学习经验。而且，如果你一直这样做，你实际上永远不会成为一个程序员，在软件开发中作用有限。话虽如此，一旦任何编程问题达到一个可尊敬的大小，期望程序员完全从头开始开发解决方案是不合理的。这是对程序员时间的低效利用，并且过于依赖程序员对所有事物的精通。此外，它更有可能导致一个有缺陷的或难以维护的程序。
- en: Good Reuse and Bad Reuse
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优秀复用与糟糕复用
- en: We must therefore distinguish between good reuse, which allows us to write better
    programs and write them more quickly, and bad reuse, which may allow us to impersonate
    a programmer for a while but ultimately leads to poor development, of both the
    code and the programmer. [Table 7-1](ch07.html#good_and_bad_code_reuse "Table 7-1. Good
    and Bad Code Reuse") summarizes the differences. The left column shows the properties
    of good reuse and the right column shows the properties of bad reuse. When considering
    whether or not to attempt a reuse of code, ask yourself whether you are more likely
    to produce the properties in the left column or the right column.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须区分优秀复用和糟糕复用，优秀复用使我们能够编写更好的程序，更快地编写它们，而糟糕复用可能使我们能够模仿程序员一段时间，但最终会导致代码和程序开发质量低下。[表7-1](ch07.html#good_and_bad_code_reuse
    "表7-1. 优秀与糟糕的代码复用")总结了这些差异。左列显示了优秀复用的特性，右列显示了糟糕复用的特性。在考虑是否尝试代码复用时，问问自己你更有可能产生左列还是右列的特性。
- en: Table 7-1. Good and Bad Code Reuse
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. 优秀与糟糕的代码复用
- en: '| Good Reuse | Bad Reuse |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 优秀复用 | 糟糕复用 |'
- en: '| --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Following a blueprint | Copying someone else’s work |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 按照蓝图进行 | 复制别人的工作 |'
- en: '| Magnifies and extends your capabilities | Falsifies your capabilities |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 放大并扩展你的能力 | 伪造你的能力 |'
- en: '| Helps you learn | Helps you avoid learning |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 帮助你学习 | 帮助你避免学习 |'
- en: '| Saves time in the short term and the long term | May save time in the short
    term but may lengthen time in the long term |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 在短期和长期内节省时间 | 可能短期节省时间但可能延长长期时间 |'
- en: '| Results in a working program | May result in a program that doesn’t work
    anyway |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 导致一个可工作的程序 | 可能导致一个无论如何都不工作的程序 |'
- en: It’s important to note that the difference between good reuse and bad reuse
    doesn’t reside in what code you reuse or how you reuse it but in your relationship
    to the code and concepts that you are borrowing. Once, in writing a term paper
    in a literature class, I discovered that something I had learned in a previous
    course was relevant to my paper’s topic, so I included it. When I submitted a
    draft of my paper to the professor, she told me I needed a citation for that information.
    Frustrated, I asked my professor at what point I could simply state my knowledge
    in a paper without providing a reference. Her answer was that I could stop referencing
    others for what was in my head when I became such an expert that others were referencing
    me.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，良好重用和不良重用的区别不在于你重用什么样的代码或你如何重用代码，而在于你对所借代码和概念的关系。有一次，在文学课上写学期论文时，我发现我在之前的一门课程中学到的东西与我的论文主题相关，所以我将其包括在内。当我将论文草稿提交给教授时，她告诉我需要为那条信息提供引用。感到沮丧的我问我的教授在什么时候我可以在论文中简单地陈述我的知识而不需要提供参考文献。她的回答是，当我成为别人引用的对象时，我就可以停止为头脑中的东西引用他人。
- en: In programming terms, good reuse occurs when you write code yourself based on
    reading someone’s description of a general concept or when you make use of code
    that you could have written yourself. Throughout this chapter, we’re going to
    talk about how you can take ownership of coding concepts so that you can be sure
    that your reuse is helping you become a better programmer, not a lazier one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，当你自己根据阅读某人描述的一般概念编写代码或使用你自己可以编写的代码时，发生良好的重用。在本章中，我们将讨论如何拥有编码概念，以确保你的重用能帮助你成为一个更好的程序员，而不是一个更懒惰的程序员。
- en: 'Let me also draw attention to the last row in [Table 7-1](ch07.html#good_and_bad_code_reuse
    "Table 7-1. Good and Bad Code Reuse"). Attempts at bad reuse often fail altogether.
    This is not surprising, because it involves a programmer using code that he or
    she doesn’t actually understand. In some situations, the borrowed code will work
    initially, but when the programmer attempts to modify or expand the borrowed code
    base, the lack of deep comprehension removes the possibility of an organized approach.
    The programmer then resorts to flailing about and trial and error, thus violating
    the first and most important of our general problem-solving rules: Always have
    a plan.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我也提醒大家注意[表7-1](ch07.html#good_and_bad_code_reuse "表7-1. 好的和坏的重用代码")中的最后一行。尝试进行不良重用往往完全失败。这并不令人惊讶，因为它涉及到一个程序员使用他或她实际上并不理解的代码。在某些情况下，借来的代码最初可能能工作，但当程序员试图修改或扩展借来的代码库时，缺乏深入理解排除了有组织方法的可能性。然后程序员只能求助于乱试和试错，从而违反了我们最基本和最重要的通用问题解决规则：始终要有计划。
- en: Review of Component Fundamentals
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件基础回顾
- en: Now that we know the kind of reuse we are aiming for, let’s categorize the different
    ways in which code can be reused. In this book, I’m going to use the term *component*
    to refer to anything created by one programmer that can be reused by another to
    help solve a programming problem. Components can exist anywhere on the continuum
    from abstract to concrete, from an idea to fully implemented code. If we think
    of solving a programming problem as analogous to tackling a handyman project,
    the techniques we’ve learned for solving problems are like tools, and components
    are like specialty parts. Each of the following components is a different way
    of reusing prior work of programmers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了我们追求的重用类型，让我们来分类代码可以重用的不同方式。在这本书中，我将使用术语*组件*来指代任何可以被另一个程序员重用来帮助解决编程问题的由一个程序员创建的东西。组件可以存在于从抽象到具体、从想法到完全实现的代码的连续体上的任何地方。如果我们把解决编程问题比作处理一个手艺人项目，我们解决问题的技术就像工具，组件就像专用零件。以下每个组件都是重用程序员先前工作的不同方式。
- en: Code Block
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码块
- en: 'A *code block* is just that: a block of code that has been copied from one
    program listing to another. More colloquially, we would call this a *copy-and-paste
    job*. This is the lowest form of component use and is often bad reuse, with all
    of the problems that implies. Of course, if the code you are copying is your own,
    there’s no real harm done, except that you might consider packaging the existing
    code as a class library or other structure to allow it to be reused in a cleaner
    and more easily maintained way.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码块*就是那样：从程序列表中复制到另一个程序列表的代码块。更通俗地说，我们会称这为*复制粘贴工作*。这是组件使用的最低形式，通常是不良的重用，并带来所有这些问题。当然，如果你复制的代码是你自己的，实际上并没有造成真正的伤害，除了你可能考虑将现有代码打包成类库或其他结构，以便以更干净、更易于维护的方式重用。'
- en: Algorithms
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法
- en: An *algorithm* is a programming recipe; it’s a particular method of accomplishing
    a goal and is expressed either in plain language or pictorially as in a flowchart.
    For example, back in [Chapter 3](ch03.html "Chapter 3. Solving Problems with Arrays"),
    we discussed the *sort* operation for arrays and different ways this sort could
    be accomplished. One method of sorting an array is the insertion-sort algorithm,
    and I showed a sample implementation of the algorithm. It’s important to note
    that the given code was one implementation of the insertion sort, but insertion
    sort is the algorithm itself—that way of sorting an array—and not the particular
    code. Insertion sort works by repeatedly taking the next unsorted value in the
    array and shifting the sorted values “up” one position until we’ve made a hole
    in the correct position for the value we’re currently inserting. Any code that
    uses this method to sort an array is an insertion sort.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法*是一种编程配方；它是一种实现目标的具体方法，可以用普通语言或如图形流程图那样直观地表达。例如，在[第3章](ch03.html "第3章。使用数组解决问题")中，我们讨论了数组的*排序*操作和实现这种排序的不同方法。排序数组的一种方法是插入排序算法，我展示了算法的一个示例实现。需要注意的是，给出的代码是插入排序的一个实现，但插入排序本身是算法——即排序数组的方式——而不是特定的代码。插入排序通过重复取数组中下一个未排序的值，并将排序好的值“向上”移动一个位置，直到我们在正确位置为当前插入的值腾出空间。任何使用这种方法对数组进行排序的代码都是插入排序。'
- en: Algorithms are a high-level form of reuse and generally lead to good reuse properties.
    Algorithms are essentially just ideas, and you, the programmer, must implement
    the ideas, calling upon your programming skills and your deep understanding of
    the algorithm itself. The algorithms you will commonly use are well studied and
    have predictable performance in various situations. With an algorithm as a blueprint,
    you can have confidence in the correctness of your code and in its performance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是高级形式的重用，通常导致良好的重用特性。算法本质上只是想法，而你，作为程序员，必须实现这些想法，调用你的编程技能和对算法本身的深入理解。你将常用到的算法已经被充分研究，在各种情况下都有可预测的性能。有了算法作为蓝图，你可以对代码的正确性和性能有信心。
- en: There are some potential downsides to basing code on an algorithm, though. When
    you use an algorithm, you are starting at the conceptual level. Therefore, you
    have a long road ahead to the finished code for that section of the program. The
    algorithm certainly saves time, because the problem-solving aspect is essentially
    complete, but depending on the algorithm and its particular application in your
    programming, the implementation of the algorithm can be nontrivial.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于算法编写代码有一些潜在缺点。当你使用算法时，你从概念层面开始。因此，你需要一段很长的路程才能完成该程序部分的代码。算法确实可以节省时间，因为问题解决方面基本上已经完成，但根据算法及其在编程中的特定应用，算法的实现可能并不简单。
- en: Patterns
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式
- en: 'In programming, a *pattern* (or *design pattern*) is a template for a particular
    programming technique. The concept is related to an algorithm but distinguishable.
    Algorithms are like recipes for solving particular problems, while patterns are
    general techniques used in particular programming situations. The problems that
    patterns solve are typically within the structure of the code itself. For example,
    in [Chapter 6](ch06.html "Chapter 6. Solving Problems with Recursion") we discussed
    the problem presented by a recursive function in a linked-list class: The recursive
    function needed the “head” pointer to the first node in the list as a parameter,
    but that data needed to remain private. The solution was to create a *wrapper*,
    a function that would adapt one parameter list to another. The wrapper technique
    is a design pattern. We can use this pattern to solve the problem of a recursive
    function in a class, but it can be used in other ways as well. For example, suppose
    we had a `linkedList` class that allowed items to be inserted or removed at any
    point in the list, but what we needed was a stack class—that is, a list that allowed
    insertion and removal only at one end. We could create a new class stack that
    had public methods for the typical stack operations, such as `push` and `pop`.
    These methods would just call member functions on the `linkedList` object that
    was a private data member of our `stack` class. In this way, we would reuse the
    functionality of a linked-list class while providing the interface of a stack
    class.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*模式*（或*设计模式*）是特定编程技术的模板。这个概念与算法相关，但可以区分。算法像是解决特定问题的食谱，而模式是在特定编程场景中使用的通用技术。模式解决的问题通常在代码的结构内部。例如，在第6章[第6章](ch06.html
    "第6章. 使用递归解决问题")中，我们讨论了在链表类中递归函数提出的问题：递归函数需要一个指向列表第一个节点的“头”指针作为参数，但该数据需要保持私有。解决方案是创建一个*包装器*，一个将一个参数列表适配到另一个的函数。包装器技术是一种设计模式。我们可以使用这个模式来解决类中递归函数的问题，但它也可以以其他方式使用。例如，假设我们有一个`linkedList`类，它允许在任何位置插入或删除项目，但我们需要的只是一个栈类——即只允许在一边插入和删除的列表。我们可以创建一个新的`stack`类，它有公共方法用于典型的栈操作，如`push`和`pop`。这些方法将只调用我们的`stack`类的私有数据成员`linkedList`对象的成员函数。这样，我们就可以重用链表类的功能，同时提供栈类的接口。
- en: Like algorithms, patterns are a high-level form of component use, and learning
    patterns is a great way to build up your programming tool chest. Patterns share
    some of the potential problems of algorithms, though. Knowing that a pattern exists
    is not the same as knowing how to implement a pattern in the particular language
    you have chosen for a programming solution, and patterns are often tricky to implement
    correctly or with maximum performance. For example, there is a pattern known as
    a *singleton*, which is a class that allows only one object of the class to be
    created. Creating a singleton class is straightforward, but creating a singleton
    class that does not create the one allowed instance object until it is actually
    needed can be surprisingly difficult, and the best technique may vary from language
    to language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与算法一样，模式是组件使用的高级形式，学习模式是构建你的编程工具箱的绝佳方式。然而，模式也共享一些算法的潜在问题。知道存在一个模式并不意味着你知道如何在为编程解决方案选择的特定语言中实现该模式，并且模式通常很难正确实现或以最佳性能实现。例如，有一个称为*单例*的模式，这是一个只允许创建一个类对象的类。创建一个单例类很简单，但创建一个直到实际需要时才创建一个允许的实例对象的单例类可能会出人意料地困难，而且最佳技术可能因语言而异。
- en: Abstract Data Types
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: An *abstract data type*, as we discussed in [Chapter 5](ch05.html "Chapter 5. Solving
    Problems with Classes"), is a type defined by its operations, not by how those
    operations are implemented. The stack type, which we have used several times in
    this book, is a good example. Abstract data types are like patterns in that they
    define the effects of operations, but they do not specifically define how those
    operations are implemented. As with algorithms, however, there are well-known
    implementation techniques for these operations. For example, a stack can be implemented
    using any number of underlying data structures, such as a linked list or an array.
    Once we make the decision to use a particular data structure, though, the implementation
    decisions are sometimes already made. Suppose we implemented a stack using a linked
    list and are unable to wrap around an existing linked list, but we must write
    our own list code. Because the stack is a last-in-first-out structure, it only
    makes sense for us to insert and remove items at one end of the linked list. Furthermore,
    it only makes sense to insert and remove at the front of the list. Theoretically,
    you could insert and remove at the end, but this would result in an inefficient
    traversal of the entire list for every insertion or removal. To avoid those traversals
    would require a doubly linked list with a separate pointer to the last node in
    the list. Inserting and removing at the beginning of the list allows the simplest,
    most efficient implementation, so linked-list implementations of stacks are almost
    all implemented the same way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 5 章](ch05.html "第 5 章。使用类解决问题") 中讨论的，*抽象数据类型* 是通过其操作定义的类型，而不是通过这些操作是如何实现的。我们在本书中多次使用的栈类型就是一个很好的例子。抽象数据类型就像模式一样，它们定义了操作的效果，但并不具体定义这些操作是如何实现的。然而，与算法一样，这些操作有众所周知的实现技术。例如，栈可以使用任何数量的底层数据结构来实现，如链表或数组。一旦我们决定使用特定的数据结构，实现决策有时已经确定。假设我们使用链表实现了栈，但无法绕过现有的链表，我们必须编写自己的列表代码。由于栈是后进先出结构，我们只在链表的一端插入和删除项是有意义的。此外，只在列表的前端插入和删除是有意义的。理论上，你可以在末端插入和删除，但这会导致每次插入或删除时对整个列表的低效遍历。为了避免这些遍历，需要一个双链表，并有一个指向列表最后一个节点的单独指针。在列表的开始处插入和删除允许最简单、最有效的实现，因此链表实现的栈几乎都是按照相同的方式进行。
- en: Thus, even though the *abstract* in *abstract data type* means the type is conceptual
    and without implementation detail, in practice, when you choose to implement an
    abstract data type in your code, you won’t be figuring out the implementation
    from scratch. Rather, you will have existing implementations of the type as guides.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管 *抽象数据类型* 中的 *abstract* 意味着类型是概念性的且没有实现细节，但在实践中，当你选择在代码中实现一个抽象数据类型时，你不会从头开始考虑实现。相反，你将会有该类型的现有实现作为指导。
- en: Libraries
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库
- en: In programming, a *library* is a collection of related pieces of code. A library
    typically includes the code in compiled form, along with needed source code declarations.
    Libraries can include stand-alone functions, classes, type declarations, or anything
    else that can appear in code. In C++, the most obvious examples are the standard
    libraries. The `strcmp` function we used in previous chapters comes from the old
    C library *cstring*, the container classes such as `vector` come from the C++
    Standard Template Library, and even the `NULL` we have used in all of our pointer-based
    code is not part of the C++ language itself but defined in a library header file,
    *stdlib.h*. Because so much core functionality is contained within libraries,
    library use is inevitable in modern programming.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，*库* 是一系列相关代码的集合。库通常包括编译后的代码以及所需的源代码声明。库可以包括独立的函数、类、类型声明或代码中可以出现的任何其他内容。在
    C++ 中，最明显的例子是标准库。我们在前几章中使用的 `strcmp` 函数来自旧的 C 库 *cstring*，容器类如 `vector` 来自 C++
    标准模板库，甚至我们所有基于指针的代码中使用的 `NULL` 也不是 C++ 语言本身的一部分，而是在库头文件 *stdlib.h* 中定义的。由于库中包含了许多核心功能，因此在现代编程中，库的使用是不可避免的。
- en: Generally, library use is good code reuse. Code is included in a library because
    it provides functionality that is commonly needed in a variety of programs—library
    code helps programmers avoid “reinventing the wheel.” Nevertheless, as developing
    programmers, when we use library code, we must strive to learn from the experience
    and not merely take a shortcut. We’ll see an example of this later in the chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，库的使用是良好的代码重用。代码被包含在库中，因为它提供了在多种程序中普遍需要的功能——库代码帮助程序员避免“重新发明轮子”。然而，作为正在发展的程序员，当我们使用库代码时，我们必须努力从经验中学习，而不仅仅是走捷径。我们将在本章后面看到这个例子。
- en: Note that while many libraries are general purpose, others are designed as *application
    programming interfaces (APIs)* providing the high-level language programmer with
    a simplified or more coherent view of an underlying platform. For example, the
    Java language includes an API called JDBC, which provides classes that allow programs
    to interact with relational databases in a standard way. Another example is DirectX,
    which provides Microsoft Windows game programmers extensive functionality with
    sound and graphics. In both cases, the library provides a connection between the
    high-level program and foundation-level hardware and software—the database engine
    in the case of JDBC and the graphics and sound hardware in the case of DirectX.
    Moreover, in both cases, the code reuse is not just good—it is, for all practical
    purposes, required. A database programmer in Java or a graphics programmer writing
    C++ code for Windows is going to make use of an API—if not these APIs, then something
    else, but the programmer isn’t going to cook up a new connection to the platform
    from scratch.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然许多库是通用目的的，但其他库被设计为*应用程序编程接口（API）*，为高级语言程序员提供了一个简化或更连贯的底层平台视图。例如，Java语言包括一个名为JDBC的API，它提供了允许程序以标准方式与关系数据库交互的类。另一个例子是DirectX，它为Microsoft
    Windows游戏程序员提供了丰富的声音和图形功能。在这两种情况下，库在高级程序和基础级硬件和软件之间提供了一个连接——在JDBC的情况下是数据库引擎，在DirectX的情况下是图形和声音硬件。此外，在这两种情况下，代码重用不仅很好——在所有实际意义上，它是必需的。Java数据库程序员或为Windows编写C++代码的图形程序员将使用API——如果不是这些API，那么就是其他东西，但程序员不会从头开始构建一个新的平台连接。
- en: Building Component Knowledge
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建组件知识
- en: 'Components are so helpful that programmers make use of them whenever possible.
    In order to use a component to aid in solving a problem, though, a programmer
    must know of its existence. Depending on how finely you define them, available
    components might number into the hundreds or even thousands, and a beginning programmer
    is going to be exposed to only a few of them. A good programmer must therefore
    always be adding component knowledge to his or her toolkit. Such knowledge gathering
    occurs in two different ways: A programmer may explicitly allot time for learning
    new components as a general task, or the programmer may search for a component
    to solve a specific problem. We’ll call the first approach *exploratory learning*
    and the second approach *as-needed learning*. To develop as a programmer, you
    will need to employ both approaches. Once you have mastered the syntax of your
    chosen programming language, discovering new components is one of the primary
    ways for you to better yourself as a programmer.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 组件非常有用，程序员尽可能地在可能的情况下使用它们。然而，为了使用组件来帮助解决问题，程序员必须知道它的存在。根据你如何精细地定义它们，可用的组件可能多达数百甚至数千，而初学者程序员将只接触到其中的一小部分。因此，优秀的程序员必须始终不断地将组件知识添加到他们的工具箱中。这种知识积累以两种不同的方式发生：程序员可以明确为学习新组件分配时间，将其作为一个一般任务，或者程序员可以寻找组件来解决特定问题。我们将第一种方法称为*探索性学习*，第二种方法称为*按需学习*。要成为一名程序员，你需要采用这两种方法。一旦你掌握了所选编程语言的语法，发现新的组件就是你作为程序员自我提升的主要方式之一。
- en: Exploratory Learning
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索性学习
- en: Let’s start with an exploratory learning example. Suppose we wanted to learn
    more about design patterns. Fortunately, there is general agreement about which
    design patterns are the most useful or frequently used, so we could begin with
    any number of resources on this topic and be fairly sure that we aren’t missing
    anything important. We would benefit by simply finding a list of design patterns
    and studying it, but we would gain more insight if we implemented some of the
    patterns.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索性学习的例子开始。假设我们想要了解更多关于设计模式的知识。幸运的是，关于哪些设计模式最有用或最常使用，人们普遍达成共识，因此我们可以从任何数量的关于这个主题的资源开始，并且可以相当确信我们没有错过任何重要的内容。通过简单地找到设计模式列表并研究它，我们会受益匪浅，但如果我们实现了其中的一些模式，我们会获得更多的洞察力。
- en: One pattern we’ll find in a typical list is called *strategy* or *policy*. This
    is the idea of allowing an algorithm, or part of an algorithm, to be chosen at
    run-time. In the purest form, the strategy form, this pattern allows changing
    how a function or method operates but does not alter the result. For example,
    a method of a class that sorts its data, or involves sorting data, might allow
    the sort methodology (quicksort or insertion sort, for example) to be chosen.
    The result is the same in any case—sorted data—but allowing the client to choose
    the sort methodology could offer performance benefits. For example, the client
    could avoid using quicksort for data with a high rate of duplicates. In the policy
    form, the client’s choice affects the outcome. For example, suppose a class represents
    a hand of playing cards. The sorting policy could determine whether aces are considered
    high (above a king) or low (less than a 2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的列表中，我们会发现一种称为 *策略* 或 *策略模式* 的模式。这是允许算法或算法的一部分在运行时被选择的想法。在最纯粹的形式，即策略形式，这种模式允许改变函数或方法的工作方式，但不会改变结果。例如，一个类的方法，它对其数据进行排序，或者涉及排序数据，可能允许选择排序方法（例如快速排序或插入排序）。在任何情况下结果都是相同的——排序后的数据——但允许客户端选择排序方法可能会提供性能优势。例如，客户端可以避免在具有高重复率的数据上使用快速排序。在策略形式中，客户端的选择会影响结果。例如，假设一个类代表一副扑克牌。排序策略可以确定是否将A视为高牌（高于国王）或低牌（低于2）。
- en: Putting Learning into Practice
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将学习付诸实践
- en: Reading that paragraph, you now know what the strategy/policy pattern is, but
    you haven’t made it your own. It’s the difference between browsing tools at the
    hardware store and actually buying one and using it. So let’s take this design
    pattern down from the shelf and put it to use. The fastest way to try out a new
    technique is to incorporate it into code you’ve already written. Let’s create
    a problem that can be solved using this pattern and that is built upon code we’ve
    already written.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读那一段，你现在知道策略/策略模式是什么，但你还没有将其内化为自己的知识。这就像是浏览五金店的工具和真正购买并使用一个工具之间的区别。所以，让我们把这个设计模式从架子上拿下来，并付诸实践。尝试新技术的最快方式是将它融入到你已经写过的代码中。让我们创建一个问题，这个问题可以用这个模式来解决，并且是基于我们已经写过的代码构建的。
- en: 'Problem: The First Student'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：第一位学生
- en: At a particular school, each class has a designated “first student” who is responsible
    for maintaining order in the classroom if the teacher has to leave the room. Originally,
    this title was bestowed upon the student with the highest grade, but now some
    teachers think the first student should be the student with the greatest seniority,
    which means the lowest student ID number, as they are assigned sequentially. Another
    faction of teachers thinks the first student tradition is silly and intends to
    protest by simply choosing the student whose name appears first in the alphabetical
    class roll. Our task is to modify the student collection class, adding a method
    to retrieve the first student from the collection, while accommodating the selection
    criteria of the various teacher groups.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在某所学校，每个班级都有一个指定的“第一位学生”，如果老师必须离开教室，这位学生负责维持课堂秩序。最初，这个头衔是授予成绩最高的学生，但现在一些老师认为第一位学生应该是资历最老的学生，这意味着学生ID号码最低，因为它们是按顺序分配的。另一部分老师认为第一位学生的传统很愚蠢，并打算通过简单地选择在字母顺序班级名单中名字排在第一位的学生来抗议。我们的任务是修改学生集合类，添加一个方法来从集合中检索第一位学生，同时满足各个教师群体的选择标准。
- en: As you can see, this problem is going to employ the policy form of the pattern.
    We want our method that returns the first student to return a different student
    based on a chosen criterion. In order to make this happen in C++, we’re going
    to use function pointers. We’ve briefly seen this concept in action in [Chapter 3](ch03.html
    "Chapter 3. Solving Problems with Arrays") with the `qsort` function, which takes
    a pointer to a function that compares two items in the array to be sorted. We’ll
    do something similar here; we’ll have a set of comparison functions that takes
    two of our `studentRecord` objects and determines whether the first student is
    “better” than the second by looking at the grades, ID numbers, or names of the
    students.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个问题将采用策略模式的格式。我们希望返回第一个学生的方法能够根据选定的标准返回不同的学生。为了在C++中实现这一点，我们将使用函数指针。我们曾在[第3章](ch03.html
    "第3章. 使用数组解决问题")中简要地看到这个概念在`qsort`函数中的应用，该函数接受一个指向比较要排序的数组中两个元素的函数的指针。我们在这里将做类似的事情；我们将有一组比较函数，这些函数接受我们的`studentRecord`对象中的两个，并通过对学生的成绩、ID号码或姓名进行比较来确定第一个学生是否比第二个学生“更好”。
- en: 'To get started, we need to define a type for our comparison functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要为我们的比较函数定义一个类型：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This declaration creates a type named `firstStudentPolicy` as a pointer to
    a function that returns a `bool` and takes two parameters of type `studentRecord`.
    The parentheses around `* firstStudentPolicy` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    are necessary to prevent the declaration from being interpreted as a function
    that returns a pointer to a `bool`. With this declaration in place, we can create
    our three policy functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明创建了一个名为`firstStudentPolicy`的类型，它是一个返回`bool`并接受两个`studentRecord`类型参数的函数指针。`*
    firstStudentPolicy` ![](httpatomoreillycomsourcenostarchimages1273182.png)周围的括号是必要的，以防止声明被解释为返回`bool`指针的函数。有了这个声明，我们可以创建我们的三个策略函数：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first two functions are very simple: `higherGrade` returns `true` when
    the first record has the higher grade, and `lowerStudent` number returns `true`
    when the first record has the lower student number. The third function, `nameComesFirst`,
    is essentially the same, but it requires the `strcmp` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    library function, which expects two “C-style” strings—that is, null-terminated
    character arrays instead of `string` objects. So we have to invoke the `c_str()`![](httpatomoreillycomsourcenostarchimages1273191.png)
    method on the `name` strings in both student records. The `strcmp` function returns
    a negative number when the first string comes before the second alphabetically,
    so we check the return value to see whether it’s less than zero ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Now we are ready to modify the `studentCollection` class itself:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数非常简单：`higherGrade`在第一个记录的成绩更高时返回`true`，而`lowerStudent` number在第一个记录的学生号码更小时返回`true`。第三个函数`nameComesFirst`基本上是相同的，但它需要`strcmp`
    ![](httpatomoreillycomsourcenostarchimages1273182.png)库函数，该函数期望两个“C风格”字符串——即空终止的字符数组而不是`string`对象。因此，我们必须在两个学生记录的`name`字符串上调用`c_str()`![](httpatomoreillycomsourcenostarchimages1273191.png)方法。`strcmp`函数在第一个字符串在字母顺序上位于第二个字符串之前时返回一个负数，因此我们检查返回值是否小于零
    ![](httpatomoreillycomsourcenostarchimages1273193.png)。现在我们准备好修改`studentCollection`类本身：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the class declaration we saw back in [Chapter 5](ch05.html "Chapter 5. Solving
    Problems with Classes") with three new members: a private data member, `_currentPolicy`
    ![](httpatomoreillycomsourcenostarchimages1273193.png), to store a pointer to
    one of our policy functions; a `setFirstStudentPolicy` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    method to change this policy; and the `firstStudent` method itself ![](httpatomoreillycomsourcenostarchimages1273191.png),
    which will return the first student according to the current policy. The code
    for `setFirstStudentPolicy` is simple:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在[第5章](ch05.html "第5章. 使用类解决问题")中看到的类声明，新增了三个成员：一个私有数据成员`_currentPolicy`
    ![](httpatomoreillycomsourcenostarchimages1273193.png)，用于存储指向我们的策略函数之一；一个`setFirstStudentPolicy`
    ![](httpatomoreillycomsourcenostarchimages1273182.png)方法来更改此策略；以及`firstStudent`方法本身
    ![](httpatomoreillycomsourcenostarchimages1273191.png)，该方法将根据当前策略返回第一个学生。`setFirstStudentPolicy`的代码很简单：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also need to modify the default constructor to initialize the current policy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改默认构造函数以初始化当前策略：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we are ready to write `firstStudent`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好编写`firstStudent`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The method begins by checking for special cases. If there is no list to review
    or no policy in place ![](httpatomoreillycomsourcenostarchimages1273182.png),
    we return a dummy record. Otherwise, we traverse the list to find the student
    who best meets the current policy, using the basic searching techniques we’ve
    been using throughout this book. We assign the record at the beginning of the
    list to `first` ![](httpatomoreillycomsourcenostarchimages1273191.png), start
    our loop variable at the second record in the list ![](httpatomoreillycomsourcenostarchimages1273193.png),
    and begin the traversal. Inside the traversal loop, a call to the current policy
    function ![](httpatomoreillycomsourcenostarchimages1273195.png) tells us whether
    the student we’re currently looking at is “better” than the best student we’ve
    found so far, based on the current criterion. When the loop is over, we return
    the “first student” ![](httpatomoreillycomsourcenostarchimages1273197.png).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查特殊情况。如果没有要审查的列表或没有实施的政策 ![http://atomoreilly.com/source/no_starch_images/1273182.png]，我们返回一个虚拟记录。否则，我们遍历列表以找到最符合当前政策的学生的记录，使用我们在本书中一直使用的基本搜索技术。我们将列表开头的记录分配给
    `first` ![http://atomoreilly.com/source/no_starch_images/1273191.png]，将循环变量从列表中的第二个记录开始
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]，并开始遍历。在遍历循环内部，对当前政策函数的调用
    ![http://atomoreilly.com/source/no_starch_images/1273195.png] 告诉我们，我们目前正在查看的学生是否根据当前标准“优于”我们迄今为止找到的最佳学生。当循环结束时，我们返回“第一个学生”
    ![http://atomoreilly.com/source/no_starch_images/1273197.png]。
- en: Analysis of First Student Solution
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 首个学生解决方案分析
- en: Having solved a problem using the strategy/policy pattern, we’re much more likely
    to recognize situations in which the technique can be employed than if we had
    just read about the technique once and never used it. We can also analyze our
    sample problem to start forming our own opinion about the worth of the technique,
    when it can be properly employed, and when it might be a mistake, or at least
    more trouble than it’s worth. One thought that may have occurred to you about
    this particular pattern is that it weakens encapsulation and information hiding.
    For example, if the client code is providing the policy functions, it requires
    access to types that would normally remain internal to the class, in this case,
    the `studentRecord` type. (We’ll consider a way around this problem in the exercises.)
    This means the client code could break if we ever modify that type, and we must
    weigh this concern against the benefits of the pattern before applying it in other
    projects. In previous chapters, we discussed how knowing when to use a technique—or
    when not to use it—is as important as knowing how to use it. By examining your
    own code, you gain insight into this critical question.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用策略/政策模式解决问题后，我们更有可能识别出可以使用该技术的情况，而不是如果我们只是阅读过一次该技术却从未使用过。我们还可以分析我们的样本问题，开始形成自己对技术价值的看法，包括何时可以正确使用，何时可能是一个错误，或者至少比它值得的麻烦更多。你可能对这个特定模式的一个想法是，它削弱了封装和信息隐藏。例如，如果客户端代码提供政策函数，它需要访问通常保留在类内部的数据类型，在这种情况下，是
    `studentRecord` 类型。（我们将在练习中考虑解决这个问题。）这意味着如果修改该类型，客户端代码可能会出错，我们必须在应用该模式到其他项目之前权衡这种担忧与模式的好处。在前面的章节中，我们讨论了知道何时使用一种技术——或者何时不使用它——与知道如何使用它一样重要。通过检查自己的代码，你可以深入了解这个关键问题。
- en: For further practice, you can review your library of completed projects in search
    of code that could be refactored using this technique. Remember that much “real
    world” programming involves supplementing or modifying an existing code base,
    so this is excellent practice for such modifications, in addition to developing
    your skill with the particular component. Moreover, one of the benefits of good
    code reuse is that we learn from it, and this practice maximizes learning.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步练习，你可以回顾你完成的项目的库，寻找可以使用此技术重构的代码。记住，许多“现实世界”的编程涉及补充或修改现有的代码库，因此这除了提高你对特定组件的技能外，也是这种修改的极好实践。此外，良好的代码重用的一个好处是我们从中学习，这种实践最大化了学习。
- en: As-Needed Learning
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求驱动学习
- en: 'The previous section described what we might call “learning through wandering.”
    While such journeys are valuable to programmers, there are other times where we
    must move toward a particular goal. If you’re working on a particular problem,
    especially if you’re working against any kind of deadline, and you suspect that
    a component could be of great help to you, you don’t want to wander randomly through
    the world of programming and hope that you stumble upon what you need. Instead,
    you want to find the component or components that directly apply to your situation
    as quickly as possible. That sounds very tricky, though—how do you find what you
    need when you don’t know exactly what you’re looking for? Consider the following
    sample problem:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节描述了我们可能称之为“漫步式学习”的内容。虽然这样的旅程对程序员来说很有价值，但还有其他时候我们必须朝着特定的目标前进。如果你正在解决某个特定的问题，尤其是如果你面临任何形式的截止日期，并且你认为某个组件可能对你非常有帮助，你不想在编程的世界中随机漫步并希望偶然发现你需要的东西。相反，你希望尽快找到直接适用于你情况的组件或组件。这听起来非常棘手——当你不知道你具体在找什么时，你怎么能找到你需要的东西呢？考虑以下示例问题：
- en: 'Problem: Efficient Traversal'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：高效遍历
- en: A programming project will use your `studentCollection` class. The client code
    needs the ability to traverse all of the students in the collection. Obviously,
    to maintain information hiding, the client code cannot be given direct access
    to the list, but it’s a requirement that the traversals are efficient.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个编程项目将使用你的 `studentCollection` 类。客户端代码需要能够遍历集合中的所有学生。显然，为了保持信息隐藏，客户端代码不能直接访问列表，但有一个要求，遍历必须是高效的。
- en: Because the key word in this description is *efficient*, let’s be precise about
    what that means in this case. Let’s suppose that a particular object of our `stu``dentCollection`
    class has 100 students. If we had direct access to the linked list, we could write
    a loop to traverse the list that would loop 100 times. That’s the most efficient
    any list traversal can be. Any solution that requires us to loop more than 100
    times to determine the result would be inefficient.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因为描述中的关键词是 *高效*，让我们来精确地说明这个案例中这意味着什么。假设我们的 `studentCollection` 类的一个特定对象有100名学生。如果我们能直接访问链表，我们可以编写一个循环来遍历列表，循环100次。这是任何列表遍历可能达到的最高效率。任何需要我们循环超过100次来确定结果的解决方案都是低效的。
- en: 'Without the requirement for efficiency, we might try to solve the problem by
    adding a simple `recordAt` method to our class that would return the student record
    at a particular position in the collection, numbering the first record as 1:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有对效率的要求，我们可能会通过在我们的类中添加一个简单的 `recordAt` 方法来尝试解决这个问题，该方法将返回集合中特定位置的学生记录，第一个记录编号为1：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this method, we use a loop ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to traverse the list until we reach the desired position or we reach the end of
    the list. At the end of the loop, if the end of the list has been reached, we
    create and return a dummy record ![](httpatomoreillycomsourcenostarchimages1273191.png),
    or we return the record at the specified position ![](httpatomoreillycomsourcenostarchimages1273193.png).
    The problem is that we are performing a traversal merely to find one student record.
    This is not necessarily a full traversal, because we will stop when we reach the
    desired position, but it is a traversal nonetheless. Suppose the client code is
    attempting to average student grades:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们使用循环 ![循环图](http://atomoreilly.com/source/nostarch/images/1273182.png)
    遍历列表，直到我们达到期望的位置或达到列表的末尾。在循环结束时，如果达到列表的末尾，我们创建并返回一个虚拟记录 ![虚拟记录图](http://atomoreilly.com/source/nostarch/images/1273191.png)，或者返回指定位置的记录
    ![指定位置记录图](http://atomoreilly.com/source/nostarch/images/1273193.png)。问题是，我们仅仅为了找到一条学生记录而进行遍历。这并不一定是一个完整的遍历，因为我们会在达到期望位置时停止，但无论如何它仍然是一个遍历。假设客户端代码正在尝试计算学生成绩的平均值：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For this code segment, assume that `sc` is a previously declared and populated
    `studentCollection` and `recNum` is an `int` storing the number of records. Suppose
    `recNum` is 100\. If you just glance at this code, it might appear that computing
    the average takes just 100 trips through the loop, but since each call to `recordAt`
    is itself a partial list traversal, this code involves 100 traversals, each of
    which will involve looping about 50 times for the average case. So instead of
    100 steps, which would be efficient, this could require about 5,000 steps, which
    is very inefficient.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码，假设`sc`是一个先前声明并填充的`studentCollection`，`recNum`是一个存储记录数的`int`。假设`recNum`是100。如果你只是浏览这段代码，可能会觉得计算平均值只需要通过循环100次，但由于每次调用`recordAt`本身就是一个部分列表遍历，这段代码涉及100次遍历，每次遍历在平均情况下都会循环大约50次。所以，而不是100步，这将很高效，这可能会需要大约5,000步，这非常低效。
- en: When to Search for a Component
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时寻找组件
- en: 'We have now arrived at the real problem. Providing client access to collection
    members for traversals is easy; providing such access efficiently is not. We could,
    of course, try to solve this problem using only our own problem-solving ability,
    but we would reach the solution much faster if we could use a component. The first
    step in finding a previously unknown component that can aid our solution is assuming
    that such a component actually exists. Put another way, you won’t find a component
    unless you start searching for one. Therefore, to maximize the benefit of components,
    you need to be on the lookout for situations where they can help. When you find
    yourself stuck on some aspect of the problem, try the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了真正的问题。提供客户端对集合成员的访问以进行遍历是容易的；提供这种高效访问则不是。当然，我们可以尝试仅使用我们自己的问题解决能力来解决这个问题，但如果我们能使用组件，我们会更快地找到解决方案。找到可以协助我们解决方案的先前未知的组件的第一步是假设这样的组件确实存在。换句话说，除非你开始寻找，否则你不会找到组件。因此，为了最大限度地发挥组件的益处，你需要留意它们可能有所帮助的情况。当你发现自己卡在问题的某个方面时，尝试以下方法：
- en: Restate the problem generically.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通用方式重新表述问题。
- en: 'Ask yourself: Is this likely to be a common problem?'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问问自己：这可能是常见问题吗？
- en: The first step is important because if we state our problem as “Allow client
    code to efficiently compute the average student grade in a linked list of records
    encapsulated in a class,” it sounds like it’s specific to our situation. If, however,
    we state the problem as “Allow client code to efficiently traverse a linked list
    without providing direct access to the list’s pointers,” then we begin to understand
    that this might be a common problem. Surely, we might ask ourselves, as often
    as programs store linked lists and other sequentially accessed structures within
    classes, other programmers must have figured out ways to allow efficient access
    to every item in the structure?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步很重要，因为如果我们把问题表述为“允许客户端代码高效地计算封装在类中的记录链表的平均学生成绩”，它听起来像是特定于我们的情况。然而，如果我们把问题表述为“允许客户端代码高效地遍历链表而不提供对列表指针的直接访问”，那么我们开始理解这可能是常见问题。当然，我们可能会问自己，既然程序经常在类中存储链表和其他顺序访问的结构，其他程序员肯定已经找到了允许高效访问结构中每个元素的方法？
- en: Finding a Component
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找组件
- en: 'Now that we’ve agreed to look, it’s time to find our component. To make things
    clear, let’s restate the original programming problem as a research problem: “Find
    a component we can use to modify our `studentCollection` class to allow client
    code to efficiently traverse the internal list.” How do we solve *this* problem?
    We could start by looking at any of our component types: patterns, algorithms,
    abstract data types, or libraries.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经同意寻找组件，现在是时候找到我们的组件了。为了使事情更清晰，让我们将原始的编程问题重新表述为一个研究问题：“找到一个我们可以使用的组件，以修改我们的`studentCollection`类，允许客户端代码高效地遍历内部列表。”我们如何解决这个问题？我们可以从查看任何我们的组件类型开始：模式、算法、抽象数据类型或库。
- en: 'Suppose we started by looking at the standard C++ libraries. We would not necessarily
    be looking for a class to “plug in” to our solution, but we instead could mine
    a library class that was similar to our `studentCollection` class for ideas. This
    employs the analogy strategy we used to solve programming problems. If we find
    a class that has an analogous problem, we can borrow its analogous solution. Our
    previous exposure to the C++ library has brought us into contact with its container
    classes, such as `vector`, and we should look for the container class that’s most
    like our student collection class. If we go to a favorite C++ reference, be that
    a book or a site on the Web, and review the C++ container classes, we see there
    is a “sequence container” called `list` that fits the bill. Does the `list` class
    allow efficient traversal by client code? It does, using an object known as an
    *iterator*. We see that the list class provides methods `begin` and `end` that
    produce iterators, which are objects that can reference a particular item in the
    list and be incremented to make the iterator reference the next object in the
    list. If `integerList` is a `list<int>`, populated with integers, and `iter` is
    a `list<int>::iterator`, then we could display all of the integers in the list
    with the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从查看标准 C++ 库开始。我们不一定是在寻找一个可以“插入”到我们的解决方案中的类，而是我们可以挖掘一个类似于我们的 `studentCollection`
    类的库类，从中获取灵感。这采用了我们用来解决编程问题的类比策略。如果我们找到一个具有类似问题的类，我们可以借鉴其类似解决方案。我们之前对 C++ 库的了解使我们接触到了其容器类，例如
    `vector`，我们应该寻找最像我们的学生集合类的容器类。如果我们去查阅一个喜欢的 C++ 参考书，无论是书籍还是网络上的网站，并回顾 C++ 容器类，我们会看到有一个名为“序列容器”的
    `list` 类符合要求。`list` 类是否允许客户端代码高效遍历？是的，它使用一个称为 *迭代器* 的对象来实现。我们看到列表类提供了 `begin`
    和 `end` 方法，这些方法生成迭代器，这些迭代器可以引用列表中的特定项，并通过递增来使迭代器引用列表中的下一个对象。如果 `integerList` 是一个
    `list<int>`，其中填充了整数，并且 `iter` 是一个 `list<int>::iterator`，那么我们可以使用以下方式显示列表中的所有整数：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Through the use of the iterator, the `list` class has solved the problem of
    providing a mechanism to the client for efficiently traversing the list. At this
    point, we might think to drop the `list` class itself into our `studentCollection`
    class, replacing our home-built linked list. We could then create `begin` and
    `end` methods for our class that would wrap the same methods from the embedded
    list object, and the problem would be solved. This, however, runs straight into
    the issue of good versus bad reuse. Once we fully understand the iterator concept
    and can reproduce it on our own in our own code, plugging an existing class from
    the Standard Template Library into our code will be a good option—perhaps the
    best option. If we’re not able to do that, using the `list` class becomes a shortcut
    that doesn’t help us grow as programmers. Sometimes, of course, we must avail
    ourselves of components that we couldn’t reproduce, but if we fall into the habit
    of depending on other programmers to solve our problems, we risk never becoming
    problem solvers ourselves.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用迭代器，`list` 类解决了为客户端提供一个机制以高效遍历列表的问题。在这个时候，我们可能会想到将 `list` 类本身放入我们的 `studentCollection`
    类中，以替换我们自建的链表。然后我们可以为我们的类创建 `begin` 和 `end` 方法，这些方法将包装嵌入列表对象中的相同方法，问题就会得到解决。然而，这直接遇到了好与坏的重用问题。一旦我们完全理解了迭代器概念，并且能够在自己的代码中自行实现它，将标准模板库中的现有类插入到我们的代码中将成为一个好的选择——也许是最好的选择。如果我们做不到这一点，使用
    `list` 类就变成了一种捷径，这并不能帮助我们作为程序员成长。当然，有时我们必须利用我们无法复制的组件，但如果我们养成依赖其他程序员解决问题的习惯，我们就有可能永远无法成为问题解决者。
- en: So let’s implement the iterator ourselves. Before we do that, though, let’s
    briefly look at other ways we could have arrived at the same place. We began the
    search in the standard template libraries, but we could have begun elsewhere.
    For example, we could have searched through a list of common design patterns.
    Under the heading of “behavioral patterns,” we would find the *iterator* pattern,
    in which the client is allowed sequential access to a collection of items without
    exposing the underlying structure of the collection. This is exactly what we need,
    but we could have found it only by searching through a list of patterns or remembering
    it from previous investigations of patterns. We could have started our search
    with abstract data types because *list* in general, and *linked list* in particular,
    are common abstract data types. However, many discussions and implementations
    of the list abstract data type do not consider client list traversal to be a basic
    operation, so the iterator concept never comes up. Finally, if we begin our search
    in the algorithms area, we would be unlikely to find anything helpful. Algorithms
    tend to describe tricky code, and the code to create an iterator is fairly simple,
    as we will soon see. In this case, then, the class library was the quickest route
    to our destination, followed by patterns. As a general rule, however, you must
    consider all component types when searching for a helpful component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们自己实现迭代器。不过，在我们这样做之前，让我们简要地看看我们可能到达同一位置的其他方法。我们开始是在标准模板库中搜索，但我们也可以从其他地方开始。例如，我们可以搜索常见设计模式列表。在“行为模式”标题下，我们会找到*迭代器*模式，其中客户端可以按顺序访问一组项目，而不暴露集合的底层结构。这正是我们所需要的，但我们只能通过搜索模式列表或从之前对模式的调查中记住它才能找到。我们本可以从抽象数据类型开始搜索，因为通常的*列表*，尤其是*链表*，是常见的抽象数据类型。然而，许多关于列表抽象数据类型的讨论和实现都没有将客户端列表遍历视为基本操作，因此迭代器概念从未出现。最后，如果我们从算法领域开始搜索，我们不太可能找到任何有用的东西。算法通常描述的是棘手的代码，而创建迭代器的代码相当简单，正如我们很快就会看到的。在这种情况下，那么，类库是我们到达目的地的最快途径，其次是模式。然而，作为一个一般规则，在搜索有用的组件时，你必须考虑所有组件类型。
- en: Applying the Component
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用组件
- en: 'We now know we’re going to make an iterator for our `studentCollection` class,
    but all the `list` standard library class has shown us is how the iterator methods
    work externally. If we got stuck on implementation, we might consider reviewing
    the source code `list` and its ancestor classes, but given the difficulty of reading
    large swaths of unfamiliar code, that’s a measure of last resort. Instead, let’s
    just think our way through this. Using the previous code example as a guide, we
    can say that an iterator is defined by four central operations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道我们将为我们的`studentCollection`类制作一个迭代器，但所有`list`标准库类向我们展示的只是迭代器方法的外部工作方式。如果我们卡在实现上，我们可能会考虑回顾`list`及其祖先类的源代码，但鉴于阅读大量不熟悉的代码的难度，这是一个最后的手段。相反，让我们只通过思考来解决这个问题。使用之前的代码示例作为指南，我们可以这样说，迭代器由四个核心操作定义：
- en: A method in the collection class that provides an iterator that references the
    first item in the collection. In the `list` class, this was `begin`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合类中的一个方法，它提供了一个引用集合中第一个项目的迭代器。在`list`类中，这个方法是`begin`。
- en: A mechanism to test whether the iterator has advanced past the last item in
    the collection. In the previous example, this was a method called `end` in the
    `list` class that produced a special iterator object to test against.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种测试迭代器是否已前进到集合中最后一个项目的机制。在上一个示例中，这是`list`类中一个名为`end`的方法，它产生一个特殊的迭代器对象进行测试。
- en: A method in the iterator class that moves the iterator so that it references
    the next item in the collection. In the previous example, this was the overloaded
    `++` operator.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器类中的一个方法，它将迭代器移动到引用集合中的下一个项目。在上一个示例中，这是重载的`++`运算符。
- en: A method in the iterator class that returns the currently referenced item in
    the collection. In the previous example, this was the overloaded `*` (prefixed)
    operator.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代器类中的一个方法，它返回集合中当前引用的项目。在上一个示例中，这是`list`类中重载的`*`（前缀）运算符。
- en: 'In terms of writing the code, nothing here looks difficult. It’s just a question
    of putting everything in the right place. So let’s get started. From the descriptions
    above, our iterator, which we’ll call `scIterator`, needs to store a reference
    to an item in the `studentCollection` and needs to be able to advance to the next
    item. Thus, our iterator should store a pointer to a `studentNode`. That will
    allow it to return the `studentRecord` contained within, as well as advance to
    the next `studentNode`. Therefore, the private section of iterator class will
    have this data member:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码方面，这里看起来没有什么困难。这只是把所有东西放在正确的位置的问题。所以，让我们开始吧。根据上面的描述，我们的迭代器，我们将称之为`scIterator`，需要存储对`studentCollection`中一个项目的引用，并且需要能够前进到下一个项目。因此，我们的迭代器应该存储一个指向`studentNode`的指针。这将允许它返回包含在内的`studentRecord`，以及前进到下一个`studentNode`。因此，迭代器类的私有部分将包含以下数据成员：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Right away, we’ve got a problem. The `studentNode` type is declared within
    a private section of `studentCollection`, and therefore the line above won’t work.
    Our first thought is that perhaps `studentNode` shouldn’t have been declared privately,
    but that’s not the right answer. The node type is inherently private because we
    don’t want random client code to depend upon a particular implementation of the
    node type, thus creating code that could break if we modify our class. Nevertheless,
    we need to allow `scIterator` access to our -private type. We do that with a `friend`
    declaration. In the public section of `studentCollection`, we add:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻，我们遇到了一个问题。`studentNode`类型是在`studentCollection`的私有部分声明的，因此上面的行不会工作。我们的第一个想法可能是`studentNode`不应该被声明为私有，但这不是正确的答案。节点类型本质上是私有的，因为我们不希望随机的客户端代码依赖于节点类型的特定实现，从而创建在修改我们的类时可能会损坏的代码。尽管如此，我们仍然需要允许`scIterator`访问我们的私有类型。我们通过`friend`声明来实现这一点。在`studentCollection`的公共部分，我们添加：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now `scIterator` can access the private declarations within `studentCollection`,
    including the declaration for `studentNode`. We can also declare some constructors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`scIterator`可以访问`studentCollection`中的私有声明，包括`studentNode`的声明。我们还可以声明一些构造函数：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s hop over to the `studentCollection` for a second and write our *begin*
    method—a method that returns an iterator that references the first item in our
    collection. Following the naming scheme I have used in this book, this method
    should have a noun for a name, such as `firstItemIterator`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时跳转到`studentCollection`，并编写我们的`*begin*`方法——一个返回引用我们集合中第一个项目的迭代器的`begin`方法。按照我在本书中使用的命名方案，这个方法应该有一个名词作为名称，例如`firstItemIterator`：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, all we need to do here is stuff the head pointer of the linked
    list into a `scIterator` object and return it. If you’re anything like me, seeing
    the pointers flying around here may make you a little nervous, but note that `scIterator`
    is just going to hold onto a reference to an item in the `studentCollection` list.
    It’s not going to allocate any memory of its own, and therefore we don’t need
    to worry about deep copy and overloaded assignment operators.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里需要做的只是将链表的头指针放入一个`scIterator`对象中，并返回它。如果您像我一样，看到指针在这里飞来飞去可能会让您有些紧张，但请注意，`scIterator`只是会保留对`studentCollection`列表中一个项目的引用。它不会分配任何自己的内存，因此我们不需要担心深度复制和重载赋值运算符。
- en: 'Let’s return to `scIterator` and write our other methods. We need a method
    to advance the iterator to the next item, as well as a method to determine whether
    we are past the end of the collection. We should think about both of these at
    the same time. In advancing the iterator, we need to know what value the iterator
    should have when it passes beyond the last node in the list. If we do nothing
    special, the iterator would naturally get the value of `NULL`, so that would be
    the easiest value to use. Note that we have initialized our iterator to `NULL`
    in the default constructor, so when we use `NULL` to indicate past-the-end we
    lose any distinction between these two states, but for this current problem that’s
    not an issue. The code for the methods is:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`scIterator`并编写我们的其他方法。我们需要一个方法来将迭代器前进到下一个项目，以及一个方法来确定我们是否已经超过了集合的末尾。我们应该同时考虑这两个问题。在前进迭代器时，我们需要知道迭代器在通过列表中的最后一个节点时应该具有什么值。如果我们不进行特殊处理，迭代器会自然地得到`NULL`的值，所以这将是
    easiest value to use。请注意，我们在默认构造函数中已经初始化了我们的迭代器为`NULL`，所以当我们使用`NULL`来表示超出末尾时，我们失去了这两种状态之间的任何区别，但就当前问题而言，这不是问题。方法的代码如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Remember that we are just using the iterator concept to solve the original problem.
    We are not trying to duplicate the exact specification of a C++ Standard Template
    Library iterator, so we don’t have to use the same interface. In this case, rather
    than overloading the `++` operator, I have a method called `advance` ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which checks to see that the `current` pointer isn’t `NULL` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    before advancing it to the next node ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Similarly, I find having to create a special “end” iterator to compare against
    cumbersome, so I just have a `bool` method called `pastEnd` ![](httpatomoreillycomsourcenostarchimages1273195.png)
    that determines whether we’ve run out of nodes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们只是使用迭代器概念来解决原始问题。我们并不是试图复制C++标准模板库迭代器的确切规范，因此我们不需要使用相同的接口。在这种情况下，我并没有重载`++`运算符，而是有一个名为`advance`的方法
    ![重载`++`运算符](http://atomoreilly.com/source/nostarch/images/1273182.png)，它在将指针向前移动到下一个节点之前会检查`current`指针是否为`NULL`
    ![检查`NULL`指针](http://atomoreilly.com/source/nostarch/images/1273191.png)。同样，我发现需要创建一个特殊的“结束”迭代器来进行比较很麻烦，所以我只提供了一个名为`pastEnd`的`bool`方法
    ![`pastEnd`方法](http://atomoreilly.com/source/nostarch/images/1273195.png)，它用来确定我们是否已经用完了节点。
- en: 'Lastly, we need a way to get the currently referenced `studentRecord` object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一种方法来获取当前引用的`studentRecord`对象：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we’ve done previously, for safety, if our pointer is `NULL`, we create and
    return a dummy record ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Otherwise, we return the currently referenced record ![](httpatomoreillycomsourcenostarchimages1273191.png).
    This completes the implementation of the iterator concept with our `studentCollection`
    class. For clarity, here’s the complete declaration of the `scIterator` class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，为了安全起见，如果我们的指针是`NULL`，我们将创建并返回一个虚拟记录 ![虚拟记录](http://atomoreilly.com/source/nostarch/images/1273182.png)。否则，我们返回当前引用的记录
    ![当前记录](http://atomoreilly.com/source/nostarch/images/1273191.png)。这样，我们就完成了`studentCollection`类中迭代器概念的实现。为了清晰起见，以下是`scIterator`类的完整声明：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the code all in place, we can test our code with a sample traversal. Let’s
    implement that average grade computation for comparison:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码全部就绪后，我们可以通过一个样本遍历来测试我们的代码。让我们实现平均成绩计算以供比较：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This listing makes use of all of our iterator-related methods, so it’s a good
    test of our code. We call `firstItemIterator` to initialize our `scIterator` object
    ![](httpatomoreillycomsourcenostarchimages1273182.png). We call `pastEnd` as our
    loop termination test ![](httpatomoreillycomsourcenostarchimages1273191.png).
    We call the `student` method of the iterator object to get the current `studentRecord`
    so that we can extract the grade ![](httpatomoreillycomsourcenostarchimages1273193.png).
    Finally, to move the iterator to the next record, we call the `advance` method
    ![](httpatomoreillycomsourcenostarchimages1273195.png). When this code works,
    we can be reasonably confident that we have implemented the various methods correctly,
    and more than that, that we have a firm understanding of the iterator concept.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表使用了我们所有的迭代器相关方法，因此它是我们代码的一个很好的测试。我们调用`firstItemIterator`来初始化我们的`scIterator`对象
    ![初始化对象](http://atomoreilly.com/source/nostarch/images/1273182.png)。我们调用`pastEnd`作为我们的循环终止测试
    ![循环终止测试](http://atomoreilly.com/source/nostarch/images/1273191.png)。我们调用迭代器对象的`student`方法来获取当前的`studentRecord`，以便我们可以提取成绩
    ![提取成绩](http://atomoreilly.com/source/nostarch/images/1273193.png)。最后，为了将迭代器移动到下一个记录，我们调用`advance`方法
    ![移动迭代器](http://atomoreilly.com/source/nostarch/images/1273195.png)。当这段代码正常工作时，我们可以合理地确信我们已经正确实现了各种方法，而且不仅如此，我们对迭代器概念有了深入的理解。
- en: Analysis of Efficient Traversal Solution
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高效遍历解决方案分析
- en: As before, just because the code works doesn’t mean the potential for learning
    from this event is over. We should carefully consider what we have done, its positive
    effects and negative effects, and contemplate expansions of the basic idea we
    have just implemented. In this case, we can say that the iterator concept definitely
    solves the original problem of inefficient client traversal of our collection,
    and once implemented, the use of the iterator is elegant and highly readable.
    On the downside, there’s no denying that the inefficient approach based on the
    `recordAt` method was much easier to write. In deciding whether or not the implementation
    of an iterator is valuable for a particular situation, we have to ask ourselves
    how often traversals would occur, how many items would typically be in our list,
    and so on. If traversals are infrequent and the list is small, the inefficiency
    is probably not important, but if we expect the list to grow large or cannot guarantee
    that it will not, the iterator may be required.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，仅仅因为代码能工作并不意味着从这次事件中学习的潜力已经结束。我们应该仔细考虑我们所做的事情，它的积极和消极影响，并思考我们对刚刚实施的基本想法的扩展。在这种情况下，我们可以这样说，迭代器概念确实解决了我们集合客户端遍历效率低下的原始问题，一旦实现，迭代器的使用既优雅又易于阅读。然而，不可否认的是，基于`recordAt`方法的低效方法写起来要容易得多。在决定迭代器的实现是否对特定情况有价值时，我们必须问自己遍历会发生的频率，列表中通常有多少项，等等。如果遍历不频繁且列表较小，低效可能并不重要，但如果我们预计列表会变得很大或者不能保证它不会变大，那么迭代器可能就是必需的。
- en: Of course, if we had decided to use a `list` object from the Standard Template
    Library, we would no longer worry about the difficulty of implementing the iterator
    because we would not be implementing it ourselves. The next time a situation like
    this arises, we can make use of the `list` class without feeling we are shortchanging
    ourselves or setting ourselves up for later difficulties, because we have investigated
    both lists and iterators to the point where we understand what must be going on
    behind the scenes, even if we never reviewed the actual source code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们决定使用标准模板库中的`list`对象，我们就不再需要担心实现迭代器的难度，因为我们自己不再需要去实现它。下次遇到类似的情况，我们可以使用`list`类，而不用担心自己占了便宜或者给自己以后带来困难，因为我们已经对列表和迭代器进行了深入的研究，以至于我们理解了幕后必须发生的事情，即使我们从未审查过实际的源代码。
- en: Going further, we can think about broader applications of iterators and their
    possible limitations. Suppose, for example, we needed an iterator that could efficiently
    move not just to the next item in our `studentCollection` but also to the previous
    item. Now that we know how the iterator works, we can see that there is really
    no way to do this with our current `studentCollection` implementation. If the
    iterator maintains a link to a particular node in the list, advancing to the next
    node requires merely following the link in the node. Retreating to the previous
    node, however, requires traversing the list again up to that point. Instead, we
    would need a doubly linked list, where the nodes have pointers in both directions,
    to both the next node and the previous one. We can generalize this thought and
    start to consider different data structures and what kinds of traversals or data
    access can be efficiently offered to clients. For example, in the previous chapter
    on recursion, we briefly encountered the binary tree structure. Is there some
    way to allow an efficient client traversal of this structure in its standard form?
    If not, how would we have to modify it to allow efficient reversals? What is even
    the right order for the nodes in a binary tree to be traversed? Thinking through
    questions like these helps us to become better programmers. Not only will we teach
    ourselves new skills, but we’ll also learn more about the strengths and weaknesses
    of different components. Knowing the pros and cons of a component will allow us
    to use it wisely. Failing to consider the limitations of a particular approach
    can lead to dead ends, and the more we know about the components we use, the less
    likely this will happen to us.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步思考，我们可以考虑迭代器的更广泛应用及其可能的局限性。例如，假设我们需要一个迭代器，它不仅能够高效地移动到`studentCollection`中的下一个项目，还能移动到上一个项目。现在我们知道了迭代器的工作原理，我们可以看到，使用我们当前的`studentCollection`实现，实际上根本无法做到这一点。如果迭代器维护到列表中特定节点的链接，那么移动到下一个节点只需跟随节点中的链接。然而，退回到前一个节点则需要再次遍历列表到那个点。相反，我们需要一个双向链表，其中节点在两个方向上都有指针，指向下一个节点和前一个节点。我们可以将这种想法推广，并开始考虑不同的数据结构以及可以高效提供给客户端的遍历或数据访问类型。例如，在前一章关于递归的章节中，我们简要遇到了二叉树结构。是否有某种方法允许以标准形式高效地遍历这种结构？如果没有，我们该如何修改它以允许高效的反转？二叉树中节点的遍历顺序是什么？思考这些问题有助于我们成为更好的程序员。我们不仅会教授自己新技能，还会更多地了解不同组件的优缺点。了解组件的优缺点将使我们能够明智地使用它们。未能考虑特定方法的局限性可能导致死胡同，而我们了解的组件越多，这种情况发生的可能性就越小。
- en: Choosing a Component Type
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择组件类型
- en: As we’ve seen in these examples, the same problem can be solved using different
    types of components. A pattern may express the idea of a solution, an algorithm
    may outline an implementation of that idea or another idea that will solve the
    same problem, an abstract data type may encapsulate the concept, and a class in
    a library may contain a fully tested implementation of the abstract data type.
    If each of these is an expression of the same concept that we need to solve our
    problem, how do we know which component type to pull out of our toolbox?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这些例子中所看到的，同一个问题可以使用不同类型的组件来解决。一个模式可能表达了解决方案的想法，一个算法可能概述了这个想法或另一个将解决相同问题的实现，一个抽象数据类型可能封装了这个概念，而库中的一个类可能包含了这个抽象数据类型的完全测试过的实现。如果这些每个都是我们需要解决我们问题的相同概念的表述，我们如何知道从我们的工具箱中拉出哪种组件类型？
- en: One primary consideration is how much work may be required to integrate the
    component into our solution. Linking a class library into our code is often a
    fast way to solve a problem, whereas implementing an algorithm from a pseudocode
    description may take a lot of time. Another important consideration is how much
    flexibility the proposed component offers. Often, a component will come in a nice,
    prepackaged form, but when it is integrated into the project, the programmer discovers
    that while the component does most of what he or she needs, it doesn’t do everything.
    Perhaps the return value of one method is in the wrong format and requires additional
    processing, for example. If the component is used anyway, more trouble may be
    discovered down the road before the component is eventually discarded altogether
    and new code for that part of the problem is developed from scratch. If the programmer
    had chosen a component at a higher conceptual level, such as a pattern, the resulting
    code implementation would fit the problem perfectly because it was created specifically
    for that problem.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的考虑因素是整合组件到我们的解决方案可能需要多少工作量。将类库链接到我们的代码通常是一个快速解决问题的方法，而将伪代码描述的算法实现可能需要花费大量时间。另一个重要的考虑因素是提议的组件提供的灵活性有多大。通常，组件会以一个很好的、预先包装的形式出现，但当它集成到项目中时，程序员会发现，尽管组件已经完成了他或她需要的多数功能，但它并没有做到一切。例如，可能某个方法的返回值格式不正确，需要额外的处理。如果仍然使用该组件，可能会在组件最终被完全丢弃并从头开始开发该部分问题的代码之前，发现更多的问题。如果程序员选择了一个更高概念层次的组件，比如一个模式，那么生成的代码实现将完美地适应问题，因为它是为了那个特定问题而创建的。
- en: '[Figure 7-1](ch07.html#flexibility_versus_work_required_for_com "Figure 7-1. Flexibility
    versus work required for component types") summarizes the interplay of these two
    factors. Generally, code from a library comes ready to use, but it cannot be directly
    modified. It can only be indirectly modified either through the use of C++ templates
    or if the code in question implements something like the *strategy* pattern we
    saw earlier in this chapter. At the other end of the scale, a pattern may be presented
    as nothing more than an idea (“a class that can have only one instance”), offering
    maximum implementation flexibility but requiring a lot of work from the programmer.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](ch07.html#flexibility_versus_work_required_for_com "图7-1. 组件类型的工作需求与灵活性对比")
    总结了这两个因素之间的相互作用。一般来说，库中的代码可以直接使用，但不能直接修改。它只能通过使用C++模板或如果相关代码实现了我们本章前面看到的类似*策略*模式的方式进行间接修改。在另一端，一个模式可能仅仅是一个想法（“只能有一个实例的类”），提供最大的实现灵活性，但需要程序员做大量的工作。'
- en: Of course, this is just a general guideline, and individual cases will differ.
    Perhaps the class we’re using from the library is at such a low level in our program
    that flexibility won’t suffer. For example, we might wrap a collection class of
    our own design around a basic container class like `list`, which is broad enough
    in capabilities that even if we have to expand the functionality of our container
    class, we can expect the `list` class to handle it. Before using a pattern, perhaps
    we’ve already implemented a particular pattern before, so we’re not so much creating
    new code as adapting previously written code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个一般性指南，具体情况会有所不同。也许我们从库中使用的类在我们的程序中处于一个非常低级的层次，这样灵活性就不会受到影响。例如，我们可能在我们自己设计的集合类周围包装一个基本的容器类，如`list`，它具有足够的能力，即使我们必须扩展容器类功能，我们也可以期待`list`类能够处理它。在使用模式之前，也许我们之前已经实现了一个特定的模式，所以我们不是在创建新的代码，而是在适应之前编写的代码。
- en: '![Flexibility versus work required for component types](httpatomoreillycomsourcenostarchimages1273267.png.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![组件类型的工作需求与灵活性对比](httpatomoreillycomsourcenostarchimages1273267.png.jpg)'
- en: Figure 7-1. Flexibility versus work required for component types
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1. 组件类型的工作需求与灵活性对比
- en: 'The more experience you have in using components, the more confident you can
    be that you are starting in the right place. Until you develop that experience,
    you can use the trade-off between flexibility and work required as a rough guide.
    For each specific situation, ask yourself questions such as the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用组件的经验越多，你就越有信心认为你从正确的起点开始。在你积累经验之前，你可以将灵活性与工作需求之间的权衡作为一个粗略的指南。对于每种具体情况，你可以问自己以下问题：
- en: Can I use the component as is, or does it require additional code to bolt it
    into my project?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以直接使用这个组件，还是需要额外的代码将其集成到我的项目中？
- en: Am I confident that I understand the full extent of the problem, or the part
    that relates to this component, and that it will not change in the future?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否确信我理解了问题的全部范围，或者与这个组件相关的那部分，并且它将来不会改变？
- en: Will I increase my programming knowledge by choosing this component?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择这个组件是否会增加我的编程知识？
- en: Your answers to these questions will help you estimate how much work will be
    involved and how much benefit you receive from each possible approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这些问题的回答将帮助你估计涉及的工作量以及从每个可能的方法中获得的收益。
- en: Component Choice in Action
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件选择在行动
- en: Now that we understand the general idea, let’s run through a quick example to
    demonstrate the specifics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了总体思路，让我们快速通过一个例子来展示具体细节。
- en: 'Problem: Sorting Some, Leaving Others Alone'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：部分排序，部分保持原样
- en: A project requires you to sort an array of `studentRecord` objects by grade,
    but there’s a catch. Another part of the program is using a special grade value
    of −1 to indicate a student whose record cannot be moved. So while all the other
    records must be moved around, those with −1 grades should be left exactly where
    they are, resulting in an array that is sorted except for −1 grades interspersed
    throughout.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目要求你根据成绩对`studentRecord`对象数组进行排序，但有一个特殊情况。程序的其他部分正在使用特殊的成绩值-1来表示无法移动的学生记录。因此，尽管所有其他记录都必须移动，但带有-1成绩的记录应该保持原位，结果是一个除了-1成绩穿插其中的数组。
- en: 'This is a tricky problem, and there are lots of ways we could attempt to solve
    it. To keep things simple, let’s reduce our choices to two: Either we choose an
    algorithm—that is, a sorting routine like insertion sort—and modify it to ignore
    the `studentRecord` objects with −1 grades, or we figure out a way to use the
    `qsort` library routine to solve this problem. Both of these options are possible.
    Because we’re comfortable with the insertion-sort code, it shouldn’t be too difficult
    to throw in some `if` statements to explicitly check and skip over records with
    −1 grades. Making `qsort` do the work for us will take a bit of a workaround.
    We could copy the student records with the real grades into a separate array,
    sort them using `qsort`, and then copy them back, making sure we don’t copy over
    any of the −1 grade records.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的问题，我们有很多方法可以尝试解决它。为了简化问题，让我们将选择减少到两种：要么我们选择一个算法——即像插入排序这样的排序例程——并修改它以忽略带有-1成绩的`studentRecord`对象，要么我们找出一种方法来使用`qsort`库例程解决这个问题。这两种选择都是可能的。因为我们熟悉插入排序的代码，所以加入一些`if`语句来显式检查并跳过带有-1成绩的记录应该不会太难。让`qsort`为我们做这项工作需要一些变通。我们可以将带有真实成绩的学生记录复制到一个单独的数组中，使用`qsort`对其进行排序，然后再复制回来，确保不复制任何带有-1成绩的记录。
- en: 'Let’s follow through with both options to see how the choice of component type
    affects the resulting code. We’ll start with the algorithm component, writing
    our own modified insertion sort to solve the problem. As usual, we’ll approach
    this problem in stages. First, let’s reduce the problem by removing the whole
    −1 grade issue and just sorting an array of `studentRecord` objects without any
    special rules. If `sra` is an array containing `arraysize` objects of type `studentRecord`,
    the resulting code looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这两种选项来了解组件类型的选择如何影响生成的代码。我们将从算法组件开始，编写我们自己的修改过的插入排序来解决该问题。像往常一样，我们将分阶段解决这个问题。首先，让我们通过移除整个-1成绩问题来简化问题，只对没有任何特殊规则的`studentRecord`对象数组进行排序。如果`sra`是一个包含`arraysize`个`studentRecord`类型对象的数组，生成的代码如下：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code is very similar to the insertion sort for integers. The only differences
    are that the comparison requires calls to the `grade` method ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and our temporary object used for swap space has changed type ![](httpatomoreillycomsourcenostarchimages1273191.png).
    This code works fine, but there is one caveat for testing this and other code
    blocks that follow in this section: Our `studentRecord` class validates data,
    and as previously written, it will not accept a −1 grade, so make sure you make
    the necessary changes. Now we’re ready to complete this version of the solution.
    We need the insertion sort to ignore records with −1 grades. This is not as simple
    as it sounds. In the basic insertion-sort algorithm, we are always swapping adjacent
    locations in the array, `j` and `j - 1` in the code above. If we are leaving records
    with −1 grades in place, though, the locations of the next records to be swapped
    could be an arbitrary distance apart.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与整数插入排序非常相似。唯一的区别是，比较需要调用 `grade` 方法 ![grade方法](httpatomoreillycomsourcenostarchimages1273182.png)，而我们用于交换空间的临时对象类型已经改变
    ![交换空间类型](httpatomoreillycomsourcenostarchimages1273191.png)。这段代码运行良好，但有一个需要注意的地方：在测试本节中接下来的代码块时：我们的
    `studentRecord` 类验证数据，并且如前所述，它不会接受 `-1` 分数，所以请确保进行必要的更改。现在我们准备完成这个解决方案的版本。我们需要插入排序忽略带有
    `-1` 分数的记录。这不像听起来那么简单。在基本的插入排序算法中，我们总是在数组中交换相邻的位置，如上面的代码中的 `j` 和 `j - 1`。如果我们保留带有
    `-1` 分数的记录不变，那么下一个要交换的记录的位置可能相隔任意距离。
- en: '[Figure 7-2](ch07.html#arbitrary_distance_between_records_to_be "Figure 7-2. Arbitrary
    distance between records to be swapped in modified insertion sort") illustrates
    this problem with an example. If this shows the array in its original configuration,
    then the arrows indicate the locations of the first records to be swapped, and
    they are not adjacent. Furthermore, eventually the last record (for Art) will
    have to be swapped from location `[5]` to `[3]` and then from `[3]` to `[0]`,
    so all the swaps required to sort this array (as much as we are sorting it) involve
    nonadjacent records.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](ch07.html#arbitrary_distance_between_records_to_be "图7-2. 修改后的插入排序中要交换的记录之间的任意距离")
    通过一个示例说明了这个问题。如果这显示了数组的原始配置，那么箭头指示了第一个要交换的记录的位置，它们不是相邻的。此外，最终最后一个记录（对于Art）将不得不从位置
    `[5]` 交换到 `[3]`，然后从 `[3]` 交换到 `[0]`，所以对排序这个数组（就像我们正在排序它一样）所需的所有交换都涉及非相邻的记录。'
- en: '![Arbitrary distance between records to be swapped in modified insertion sort](httpatomoreillycomsourcenostarchimages1273269.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![修改后的插入排序中要交换的记录之间的任意距离](httpatomoreillycomsourcenostarchimages1273269.png)'
- en: Figure 7-2. Arbitrary distance between records to be swapped in modified insertion
    sort
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-2. 修改后的插入排序中要交换的记录之间的任意距离
- en: 'In considering how to solve this problem, I looked out for an analogy and found
    one in the processing of linked lists. In many linked-list algorithms, we have
    to maintain a pointer not only to the current node in our list traversal but also
    to the previous node. So at the end of loop bodies, we often assign the current
    pointer to the previous pointer before advancing the current pointer. Something
    similar needs to go on here. We need to keep track of the last “real” student
    record as we progress linearly through the array to find the next “real” record.
    Putting this idea into practice results in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何解决这个问题时，我寻找了一个类比，并在链表的处理中找到了一个。在许多链表算法中，我们不仅要维护我们列表遍历中的当前节点指针，还要维护前一个节点的指针。因此，在循环体结束时，我们通常在前进当前指针之前将当前指针赋值给前一个指针。这里也需要做类似的事情。我们需要在通过数组线性前进以找到下一个“真实”记录的过程中跟踪最后一个“真实”学生记录。将这个想法付诸实践，结果如下代码：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the basic insertion-sort algorithm, we repeatedly insert unsorted items into
    an ever-growing sorted area within the array. The outer loop selects the next
    unsorted item to be placed in sorted order. In this version of the code, we start
    by checking that the grade in location `i` is not −1 ![](httpatomoreillycomsourcenostarchimages1273182.png)
    inside the outer loop body. If it is, we will just skip to the next record, leaving
    this record in place. Once we have established that the student record at location
    `i` can be moved, we initialize `rightswap` to this location ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Then we begin the inner loop. In the basic insertion-sort algorithm, each iteration
    of the inner loop swaps an item with its neighbor. In our version, though, because
    we are leaving records with −1 grades in place, we perform a swap only when location
    `j` does not contain a grade of −1 ![](httpatomoreillycomsourcenostarchimages1273195.png).
    We then swap between locations `leftswap` and `rightswap` and assign `leftswap`
    to `rightswap` ![](httpatomoreillycomsourcenostarchimages1273197.png), setting
    up the next swap in the inner loop if there is one. Finally, we have to modify
    our inner loop condition. Normally the inner loop in an insertion sort stops when
    we reach the front end of the array or when we find a value that is less than
    the value we are inserting. Here, we have to make a compound condition using logical
    *or* so that the loop continues past −1 grades ![](httpatomoreillycomsourcenostarchimages1273193.png)
    (because −1 will be less than any legitimate grade, thus stopping the loop prematurely).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的插入排序算法中，我们反复将未排序的项目插入到数组中不断增长的已排序区域。外循环选择下一个要按顺序放置的未排序项目。在这个版本的代码中，我们首先检查外循环体内位置`i`的等级是否不是-1
    ![http://atomoreilly.com/source/no_starch_images/1273182.png](http://atomoreilly.com/source/no_starch_images/1273182.png)。如果是，我们将直接跳到下一个记录，保留这个记录的位置。一旦我们确定位置`i`的学生记录可以移动，我们就将`rightswap`初始化为这个位置
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]。然后我们开始内循环。在基本的插入排序算法中，内循环的每次迭代都会将一个项目与其邻居交换。在我们的版本中，由于我们保留带有-1等级的记录，我们只有在位置`j`不包含-1等级时才进行交换
    ![http://atomoreilly.com/source/no_starch_images/1273195.png]。然后我们在`leftswap`和`rightswap`之间进行交换，并将`leftswap`赋值给`rightswap`
    ![http://atomoreilly.com/source/no_starch_images/1273197.png]，为内循环中的下一次交换设置条件。最后，我们必须修改我们的内循环条件。通常，插入排序的内循环会在我们到达数组的开头或找到小于我们要插入的值的值时停止。在这里，我们必须使用逻辑*或*来创建一个复合条件，以便循环可以越过-1等级
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]（因为-1将小于任何合法等级，从而提前停止循环）。
- en: This code solves our problem, but it’s possible that it may be giving off some
    “bad smells.” The standard insertion-sort code is easy to read, especially if
    you understand the gist of what it’s doing, but this modified version is hard
    on the eyes and probably needs some comment lines if we want to be able to understand
    it later. Perhaps a refactoring is in order, but let’s try the other approach
    for solving this problem and see how that reads.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码解决了我们的问题，但它可能散发出一些“坏味道”。标准的插入排序代码易于阅读，特别是如果你理解它所做的大致内容，但这个修改版本对眼睛来说很累，如果我们想以后理解它，可能需要一些注释行。也许需要进行重构，但让我们尝试解决这个问题的另一种方法，看看它读起来如何。
- en: 'The first thing we’ll need is a comparison function for use with `qsort`. In
    this case, we’ll be comparing two `studentRecord` objects, and our function will
    subtract one grade from the other:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要为`qsort`使用一个比较函数。在这种情况下，我们将比较两个`studentRecord`对象，我们的函数将从一个等级中减去另一个等级：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we’re ready to sort the records. We’ll do this in three phases. First,
    we will copy all of the records that don’t have a −1 grade to a secondary array,
    leaving no gaps. Then, we’ll call `qsort` to sort the secondary array. Finally,
    we will copy the records from the secondary array back to the original array,
    skipping over the records with the −1 grades. The resulting code looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好对记录进行排序。我们将分三个阶段来完成这项工作。首先，我们将所有没有-1等级的记录复制到一个二级数组中，不留任何空隙。然后，我们将调用`qsort`来对二级数组进行排序。最后，我们将从二级数组中复制记录回原始数组，跳过带有-1等级的记录。生成的代码如下：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Although this code is about the same length as the other solution, it’s more
    straightforward and easier to read. We begin by declaring our secondary array,
    `sortArray` ![](httpatomoreillycomsourcenostarchimages1273182.png), of the same
    size as the original array. The variable `sortArrayCount` is initialized to zero
    ![](httpatomoreillycomsourcenostarchimages1273191.png); in the first loop, we’ll
    use this to track how many records we have copied into the secondary array. Inside
    that loop, each time we encounter a record without a −1 grade ![](httpatomoreillycomsourcenostarchimages1273193.png),
    we assign it to the next available slot in `sortArray` and increment `sortArrayCount`.
    When the loop is over, we sort the secondary array ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The variable `sortArrayCount` is reset to 0 ![](httpatomoreillycomsourcenostarchimages1273197.png);
    we’ll use it in the second loop to track how many records we have copied from
    the secondary array back to the original array. Note that the second loop traverses
    the *original* array ![](httpatomoreillycomsourcenostarchimages1273199.png), looking
    for slots that need to be filled ![](httpatomoreillycomsourcenostarchimages1273203.png).
    If we approach this the other way, trying to loop through the secondary array
    and pushing the records over to the original array, we would need a double loop,
    with the inner loop searching for the next real-grade slot in the original array.
    This is another example of how the problem can be made easy or difficult based
    on our conceptualization of it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码的长度与其他解决方案大致相同，但它更直接，更容易阅读。我们首先声明一个与原始数组大小相同的辅助数组`sortArray` ![http://atomoreilly.com/source/no_starch_images/1273182.png]，变量`sortArrayCount`初始化为0
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]；在第一个循环中，我们将使用它来跟踪我们复制到辅助数组中的记录数量。在循环内部，每次我们遇到没有-1成绩的记录
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]，我们就将它分配给`sortArray`中的下一个可用槽位，并增加`sortArrayCount`。当循环结束时，我们排序辅助数组
    ![http://atomoreilly.com/source/no_starch_images/1273195.png]。变量`sortArrayCount`重置为0
    ![http://atomoreilly.com/source/no_starch_images/1273197.png]；我们将在第二个循环中使用它来跟踪我们从辅助数组复制回原始数组的记录数量。请注意，第二个循环遍历的是*原始*数组
    ![http://atomoreilly.com/source/no_starch_images/1273199.png]，寻找需要填充的槽位 ![http://atomoreilly.com/source/no_starch_images/1273203.png]。如果我们以另一种方式来做，尝试遍历辅助数组并将记录推送到原始数组，我们就需要一个双重循环，内循环在原始数组中搜索下一个真实成绩的槽位。这是另一个例子，说明了问题可以根据我们对它的概念化变得简单或困难。
- en: Comparing the Results
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较结果
- en: Both solutions work and are reasonable approaches. For most programmers, the
    first solution, in which we modified insertion sort to leave some records in place
    as we sorted around them, is harder to write and harder to read. The second solution,
    though, appears to introduce some inefficiency because it requires copying the
    data to the secondary array and back again. Here’s where a little knowledge of
    algorithm analysis comes in handy. Suppose we were sorting 10,000 records—if we
    were sorting much fewer, we wouldn’t really care about the efficiency. We can’t
    know for sure what algorithm underlies the `qsort` call, but the worst case for
    a general-purpose sort would require 100 million record swaps, and the best case
    would be around 130,000\. Regardless of where along the range we end up, copying
    10,000 records back and forth isn’t going to be a major performance drain compared
    to the sorting. Also, we have to consider that whatever algorithm is used by `qsort`
    may be more efficient than our simple insertion sort, wiping out any benefit we
    may have gained from avoiding copying the data to and from the secondary array.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两种解决方案都可行，并且是合理的途径。对于大多数程序员来说，第一种解决方案，即我们在排序时修改插入排序以保留一些记录在原位，更难编写和阅读。然而，第二种解决方案似乎引入了一些低效性，因为它需要将数据复制到辅助数组并再次复制回来。这就是一点算法分析知识派上用场的地方。假设我们正在排序10,000条记录——如果我们排序的记录很少，我们实际上不会关心效率。我们无法确定`qsort`调用背后的算法是什么，但通用排序的最坏情况可能需要10亿条记录交换，而最佳情况大约是130,000条。无论我们最终落在哪个范围内，与排序相比，复制10,000条记录来来回回不会是一个主要的性能瓶颈。此外，我们必须考虑`qsort`使用的算法可能比我们简单的插入排序更高效，从而抵消了我们可能从避免将数据复制到辅助数组中获得的任何好处。
- en: So in this scenario, the second approach, using `qsort`, appears to be the winner.
    It’s simpler to implement, simpler to read and therefore more easily maintained,
    and we can expect its performance to be as good as, or possibly better than, the
    first solution. The best thing we can say about the first approach is that we
    may have learned skills that we can apply to other problems, whereas the second
    approach, by virtue of its simplicity, offers no such insights. As a general rule,
    when you are at the stage of programming where you are trying to maximize your
    learning, you should favor higher-level components such as algorithms and patterns.
    When you are at the stage of trying to maximize your efficiency as a programmer
    (or are under a hard deadline), you should favor lower-level components, choosing
    prebuilt code when possible. Of course, if time permits, trying several different
    approaches, as we have done here, provides the best of all worlds.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，第二种方法，使用`qsort`，似乎更胜一筹。它更容易实现，更容易阅读，因此更容易维护，我们预计其性能将与第一种解决方案相当，甚至可能更好。我们可以说第一种方法最好的地方可能就是我们可能已经学到了可以应用于其他问题的技能，而第二种方法，由于其简单性，没有提供这样的见解。一般来说，当你处于试图最大化学习效果的编程阶段时，你应该优先考虑高级组件，如算法和模式。当你处于试图最大化编程效率的阶段（或面临硬性截止日期）时，你应该优先考虑低级组件，并在可能的情况下选择预构建的代码。当然，如果时间允许，尝试几种不同的方法，就像我们在这里所做的那样，可以提供最好的结果。
- en: Exercises
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Try out as many components as you can. Once you get a handle on how to learn
    new components, your abilities as a programmer will start to grow quickly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地尝试不同的组件。一旦你掌握了如何学习新的组件，你的编程能力将开始迅速增长。
- en: A complaint offered against the *policy/strategy* pattern is that it requires
    exposing some internals of the class, such as types. Modify the “first student”
    program from earlier in this chapter so that the policy functions are all stored
    within the class and are chosen by passing a code value (of a new, enumerated
    type, for example), instead of passing the policy function itself.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对*策略/策略*模式的一个常见批评是它要求暴露类的某些内部信息，例如类型。修改本章前面提到的“第一个学生”程序，使得策略函数都存储在类中，并且通过传递一个代码值（例如，一个新枚举类型的值）来选择，而不是传递策略函数本身。
- en: Rewrite our `studentCollection` functions from [Chapter 4](ch04.html "Chapter 4. Solving
    Problems with Pointers and Dynamic Memory") (`addRecord` and `averageRecord`)
    so that instead of directly implementing a linked list, you use a class from the
    C++ library.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第4章（[第4章](ch04.html "第4章. 使用指针和动态内存解决问题"）中的`studentCollection`函数（`addRecord`和`averageRecord`）重写，使其不再直接实现链表，而是使用C++库中的一个类。
- en: Consider a collection of `studentRecord` objects. We want to be able to quickly
    find a particular record based on student number. Store the student records in
    an array, sort the array by student number, and investigate and implement the
    *interpolation search* algorithm.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个`studentRecord`对象集合。我们希望能够根据学生编号快速找到特定的记录。将学生记录存储在数组中，按学生编号对数组进行排序，并调查和实现*插值搜索*算法。
- en: For the problem in 7-3, implement a solution by implementing an abstract data
    type that allows an arbitrary number of items to be stored and individual records
    to be retrieved based on a key value. A generic term for a structure that can
    efficiently store and retrieve items based on a key value is a *symbol table*,
    and common implementations of the symbol table idea are *hash tables* and *binary
    search trees*.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于7-3号问题，通过实现一个抽象数据类型来存储任意数量的项目并基于键值检索单个记录来实现解决方案。一个可以高效地基于键值存储和检索项目的结构的通用术语是*符号表*，符号表思想的常见实现包括*哈希表*和*二叉搜索树*。
- en: For the problem in 7-3, implement a solution using a class from the C++ library.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于7-3号问题，使用C++库中的一个类来实现解决方案。
- en: 'Suppose you are working on a project in which a particular `studentRecord`
    may need to be augmented with one of the following pieces of data: term paper
    title, year of enrollment, or a `bool` indicating whether the student is auditing
    the class. You don’t want to include all of these data fields in the base `studentRecord`
    class, knowing that in most cases they won’t be used. Your first thought is to
    create three subclasses, each having one of the data fields, with names such as
    `studentRecordTitle`, `studentRecordYear` and `studentRecordAudit`. Then you are
    informed that some student records will contain two of these additional data fields
    or perhaps all three. Creating subclasses for each possible variation is impractical.
    Find a design pattern that addresses this conundrum, and implement a solution.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你正在参与一个项目，其中某个特定的`studentRecord`可能需要添加以下数据之一：学期论文标题、入学年份或一个表示学生是否旁听的`bool`类型字段。由于知道在大多数情况下这些数据字段不会被使用，你不想将它们包含在基类`studentRecord`中。你的第一个想法是创建三个子类，每个子类有一个数据字段，例如`studentRecordTitle`、`studentRecordYear`和`studentRecordAudit`。然后你被告知，某些学生记录将包含这些附加数据字段中的两个或所有三个。为每种可能的变体创建子类是不切实际的。找到一个解决这个难题的设计模式，并实现解决方案。
- en: 'Develop a solution to the problem described in 7-6 that does not make use of
    the pattern you discovered but instead solves the problem using C++ library classes.
    Rather than focusing on the three particular data fields described in the previous
    question, try to make a general solution: a version of the `studentRecord` class
    that allows arbitrary extra fields of data to be added to particular objects.
    So, for example, if `sr1` is a `studentRecord`, you might want client code to
    make the call `sr1.addExtraField("Title", "Problems of Unconditiona`l Branching"),
    and then later `sr1.retrieveField("Title")` would return “Problems of Unconditional
    Branching.”'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针对第7-6节中描述的问题，开发一个解决方案，该方案不使用你发现的模式，而是使用C++库类来解决问题。与其关注前一个问题中描述的三个特定数据字段，不如尝试制定一个通用解决方案：一个`studentRecord`类的版本，允许为特定对象添加任意额外的数据字段。例如，如果`sr1`是一个`studentRecord`，你可能希望客户端代码调用`sr1.addExtraField("Title",
    "Problems of Unconditional Branching")`，然后稍后`sr1.retrieveField("Title")`将返回“Problems
    of Unconditional Branching。”
- en: 'Design your own: Take a problem you have already solved, and solve it again
    using a different component. Remember to analyze the results in comparison to
    your original solution.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计自己的：选择一个你已经解决的问题，并使用不同的组件再次解决它。记住，将结果与你的原始解决方案进行比较分析。
