- en: Chapter 1. GENERAL PURPOSE UTILITIES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。通用工具
- en: '![GENERAL PURPOSE UTILITIES](../Images/00001.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![通用工具](../Images/00001.jpg)'
- en: In any programming language, scripting is the solution to frequently performed
    tasks. If you find yourself asking *Couldn't a robot or well-trained monkey do
    this job?*, then scripting with Ruby just might be the next best solution. Writing
    scripts for frequently performed tasks makes your job and computing experience
    as efficient as it can be. Who wouldn't want to get the job done in less time
    with less effort? As you work through these examples, I encourage you to write
    down ideas for your own scripts. Once you've finished this book, you will probably
    have a list of scripts you want to write, or at the very least, some useful revisions
    of mine. Are you ready? Let's get started!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，脚本都是解决频繁执行任务的解决方案。如果你发现自己在想：“难道不能让一个机器人或训练有素的猴子来做这项工作吗？”那么使用Ruby进行脚本编写可能就是下一个最佳选择。为频繁执行的任务编写脚本可以使你的工作和计算体验尽可能高效。谁不想用更少的时间和精力完成工作呢？当你浏览这些示例时，我鼓励你写下自己脚本的想法。一旦你完成这本书，你可能会有一份想要编写的脚本清单，或者至少是一些对我脚本的有用修订。你准备好了吗？让我们开始吧！
- en: Check for Changed Files
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查已更改的文件
- en: Check for Changed Files
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查已更改的文件
- en: changedFiles.rb
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: changedFiles.rb
- en: 'The purpose of this script is to validate a file''s integrity. While it sounds
    like a humble end use, its applications are broad: If you can''t trust the contents
    of files on your computer, you can''t trust your computer. Would you know if a
    malicious worm or virus modified a file on your system? If you think your antivirus
    has you covered, think again—most only go as far as checking for known viruses
    and their signatures. File integrity validation is used every day for real-world
    tasks such as digital forensics and tracking the behavior of malicious logic.
    One method of tracking file integrity is shown below.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的目的是验证文件完整性。虽然听起来用途很普通，但其应用范围很广：如果你无法信任你电脑上的文件内容，那么你也无法信任你的电脑。你能知道是否有恶意蠕虫或病毒修改了你的系统中的文件吗？如果你认为你的杀毒软件已经为你提供了保护，那么再想想——大多数杀毒软件只检查已知的病毒及其签名。文件完整性验证在日常的实际任务中得到了广泛应用，例如数字取证和追踪恶意逻辑的行为。下面展示了一种跟踪文件完整性的方法。
- en: The Code
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '``require ''find'' require ''digest/md5''   unless ARGV[0] and File.directory?(ARGV[0])
        puts "\n\n\nYou need to specify a root directory:  changedFiles.rb <directory>\n\n\n"
        exit end  ![](../Images/00002.jpg) root = ARGV[0]  oldfile_hash = Hash.new
     newfile_hash = Hash.new  file_report = "#{root}/analysis_report.txt"  file_output
    = "#{root}/file_list.txt"  oldfile_output = "#{root}/file_list.old"  ![](../Images/00003.jpg) if
    File.exists?(file_output)    File.rename(file_output, oldfile_output)    File.open(oldfile_output,
    ''rb'') do |infile|      while (temp = infile.gets)        line = /(.+)\s{5,5}(\w{32,32})/.match(temp)
           puts "#{line[1]}  --->  #{line[2]}"        oldfile_hash[line[1]] = line[2]
         end    end end  ![](../Images/00004.jpg) Find.find(root) do |file|      next
    if /^\./.match(file)      next unless File.file?(file)      begin          newfile_hash[file]
    = Digest::MD5.hexdigest(File.read(file))      rescue          puts "Error reading
    #{file} --- MD5 hash not computed."      end  end   report = File.new(file_report,
    ''wb'')  changed_files = File.new(file_output, ''wb'')   newfile_hash.each do
    |file, md5|    changed_files.puts "#{file}     #{md5}"  end  ![](../Images/00005.jpg)
     newfile_hash.keys.select { |file| newfile_hash[file] == oldfile_hash[file]  }.each
    do |file|     newfile_hash.delete(file)     oldfile_hash.delete(file)  end  ![](../Images/00006.jpg) newfile_hash.each
    do |file, md5| **`    report.puts "#{oldfile_hash[file] ? "Changed" : "Added"}
    file: #{file}`** **`#{md5}"`**     oldfile_hash.delete(file)  end  ![](../Images/00007.jpg) oldfile_hash.each
    do |file, md5|     report.puts "Deleted/Moved file: #{file}     #{md5}"  end   report.close
     changed_files.close``'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '``require ''find'' require ''digest/md5''   unless ARGV[0] and File.directory?(ARGV[0])
        puts "\n\n\n您需要指定一个根目录：  changedFiles.rb <directory>\n\n\n"     exit end  ![](../Images/00002.jpg) root
    = ARGV[0]  oldfile_hash = Hash.new  newfile_hash = Hash.new  file_report = "#{root}/analysis_report.txt"
     file_output = "#{root}/file_list.txt"  oldfile_output = "#{root}/file_list.old"  ![](../Images/00003.jpg) if
    File.exists?(file_output)    File.rename(file_output, oldfile_output)    File.open(oldfile_output,
    ''rb'') do |infile|      while (temp = infile.gets)        line = /(.+)\s{5,5}(\w{32,32})/.match(temp)
           puts "#{line[1]}  --->  #{line[2]}"        oldfile_hash[line[1]] = line[2]
         end    end end  ![](../Images/00004.jpg) Find.find(root) do |file|      next
    if /^\./.match(file)      next unless File.file?(file)      begin          newfile_hash[file]
    = Digest::MD5.hexdigest(File.read(file))      rescue          puts "Error reading
    #{file} --- MD5 hash not computed."      end  end   report = File.new(file_report,
    ''wb'')  changed_files = File.new(file_output, ''wb'')   newfile_hash.each do
    |file, md5|    changed_files.puts "#{file}     #{md5}"  end  ![](../Images/00005.jpg)
     newfile_hash.keys.select { |file| newfile_hash[file] == oldfile_hash[file]  }.each
    do |file|     newfile_hash.delete(file)     oldfile_hash.delete(file)  end  ![](../Images/00006.jpg) newfile_hash.each
    do |file, md5| **`    report.puts "#{oldfile_hash[file] ? "Changed" : "Added"}
    file: #{file}`** **`#{md5}"`**     oldfile_hash.delete(file)  end  ![](../Images/00007.jpg) oldfile_hash.each
    do |file, md5|     report.puts "Deleted/Moved file: #{file}     #{md5}"  end   report.close
     changed_files.close``'
- en: Running the Code
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Execute this script by typing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令执行此脚本：
- en: '``**`ruby changedFiles.rb`** *`/path/to/check/`*``'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby changedFiles.rb`** *`/path/to/check/`*``'
- en: You can add more than one directory to crawl, but subdirectories will automatically
    be verified. The script will automatically determine if a directory exists and
    then add it to the crawler's queue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加多个目录进行爬取，但子目录将自动进行验证。脚本将自动确定目录是否存在，并将其添加到爬虫的队列中。
- en: The Results
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The script will initially produce two separate files (*changed.files and file_report.txt*).
    Both will contain a list of the names and MD5 hashes for all of the files scanned
    by the script:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本最初将生成两个独立的文件（*changed.files 和 file_report.txt*）。这两个文件都将包含脚本扫描的所有文件的名称和 MD5
    哈希：
- en: '`Added file: fileSplit.rb d79c592af618266188a9a49f91fe0453 Added file: fileJoin.rb
    5aedfe682e300dcc164ebbdebdcd8875 Added file: win32RegCheck.rb c0d26b249709cd91a0c8c14b65304aa7
    Added file: changedFiles.rb c2760bfe406a6d88e04f8969b4287b4c Added file: encrypt.rb
    08caf04913b4a6d1f8a671ea28b86ed2 Added file: decrypt.rb 90f68b4f65bb9e9a279cd78b182949d4
    Added file: file_report.txt d41d8cd98f00b204e9800998ecf8427e Added file: changed.files
    d41d8cd98f00b204e9800998ecf8427e Added file: test.txt a0cbe4bbf691bbb2a943f8d898c1b242
    Added file: test.txt.rsplit1 35d5b2e522160ce3b3b98d2d4ad2a86e Added file: test.txt.rsplit2
    a65dde64f16a4441ff1619e734207528 Added file: test.txt.rsplit3 264b40b40103a4a3d82a40f82201a186
    Added file: test.txt.rsplit4 943600762a52864780b9b9f0614a470a Added file: test.txt.rsplit5
    131c8aa7155483e7d7a999bf6e2e21c0 Added file: test.txt.rsplit6 1ce31f6fbeb01cbed6c579be2608e56c`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`添加文件: fileSplit.rb d79c592af618266188a9a49f91fe0453 添加文件: fileJoin.rb 5aedfe682e300dcc164ebbdebdcd8875
    添加文件: win32RegCheck.rb c0d26b249709cd91a0c8c14b65304aa7 添加文件: changedFiles.rb
    c2760bfe406a6d88e04f8969b4287b4c 添加文件: encrypt.rb 08caf04913b4a6d1f8a671ea28b86ed2
    添加文件: decrypt.rb 90f68b4f65bb9e9a279cd78b182949d4 添加文件: file_report.txt d41d8cd98f00b204e9800998ecf8427e
    添加文件: changed.files d41d8cd98f00b204e9800998ecf8427e 添加文件: test.txt a0cbe4bbf691bbb2a943f8d898c1b242
    添加文件: test.txt.rsplit1 35d5b2e522160ce3b3b98d2d4ad2a86e 添加文件: test.txt.rsplit2
    a65dde64f16a4441ff1619e734207528 添加文件: test.txt.rsplit3 264b40b40103a4a3d82a40f82201a186
    添加文件: test.txt.rsplit4 943600762a52864780b9b9f0614a470a 添加文件: test.txt.rsplit5
    131c8aa7155483e7d7a999bf6e2e21c0 添加文件: test.txt.rsplit6 1ce31f6fbeb01cbed6c579be2608e56c`'
- en: 'After the script is run a second time, three files will appear in the root
    directory. Two of the files, *changed.files* and *old_changed.files*, are where
    the MD5 hashes are stored; the third, *file_report.txt*, is a text file showing
    the results. The script will compare the MD5 hashes for all of the files listed
    in *changed.files* with those in *old_changed.files* and return any differences
    found. Here is an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本运行第二次之后，根目录下将出现三个文件。其中两个文件，*changed.files* 和 *old_changed.files*，是存储 MD5
    哈希的地方；第三个文件，*file_report.txt*，是一个显示结果的文本文件。脚本将比较 *changed.files* 中列出的所有文件的 MD5
    哈希与 *old_changed.files* 中的哈希值，并返回任何找到的差异。以下是一个示例：
- en: '`Changed file: old_changed.files 45de547aef9366eeaeb1b565dff1e1a3 Deleted/Moved
    file: test.txt.rsplit4 943600762a52864780b9b9f0614a470a Deleted/Moved file: test.txt.rsplit5
    131c8aa7155483e7d7a999bf6e2e21c0 Deleted/Moved file: test.txt.rsplit6 1ce31f6fbeb01cbed6c579be2608e56c
    Deleted/Moved file: test.txt.rsplit1 35d5b2e522160ce3b3b98d2d4ad2a86e Deleted/Moved
    file: test.txt.rsplit2 a65dde64f16a4441ff1619e734207528 Deleted/Moved file: test.txt.rsplit3
    264b40b40103a4a3d82a40f82201a186`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`已更改文件: old_changed.files 45de547aef9366eeaeb1b565dff1e1a3 删除/移动文件: test.txt.rsplit4
    943600762a52864780b9b9f0614a470a 删除/移动文件: test.txt.rsplit5 131c8aa7155483e7d7a999bf6e2e21c0
    删除/移动文件: test.txt.rsplit6 1ce31f6fbeb01cbed6c579be2608e56c 删除/移动文件: test.txt.rsplit1
    35d5b2e522160ce3b3b98d2d4ad2a86e 删除/移动文件: test.txt.rsplit2 a65dde64f16a4441ff1619e734207528
    删除/移动文件: test.txt.rsplit3 264b40b40103a4a3d82a40f82201a186`'
- en: How It Works
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This script is great for verifying the contents of your hard drive and ensuring
    they haven't been manipulated. The script starts by confirming that the user-supplied
    arguments were included and that a valid directory was given. Next is the initialization
    of variables used in the script. The `root` variable contains the root directory
    to scan, two hashes are created that will be used for comparing the files and
    their MD5 hashes, and, finally, the names of the files to be used are specified
    ![](../Images/00002.jpg). The script output is saved in two or three files, depending
    on whether the script has been run before. The main file, *file_report.txt*, is
    used for reading the output, and the other two files are used to store the list
    of MD5 hashes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本非常适合验证您硬盘驱动器的内容，并确保它们没有被篡改。脚本首先确认用户提供的参数是否包含在内，并且提供了一个有效的目录。接下来是初始化脚本中使用的变量。`root`
    变量包含要扫描的根目录，创建了两个哈希值，将用于比较文件及其 MD5 哈希，最后指定了要使用的文件名 ![图片](../Images/00002.jpg)。根据脚本是否之前已经运行过，脚本输出将保存在两个或三个文件中。主文件
    *file_report.txt* 用于读取输出，其他两个文件用于存储 MD5 哈希列表。
- en: Next, the script checks to see if it's been run before by looking for *file_list.txt*![](../Images/00003.jpg).
    If the file is not found, the script moves on. If it finds *file_list.txt*, the
    script immediately renames the file. The renamed file is then opened and the contents
    are read. For every line in the file, the script reads a filename and MD5 hash
    and stores these in the `oldfile_hash` for later comparison. Once the `oldfile_hash`
    has been populated, the script is ready to begin computing new MD5 hashes and
    comparing results.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本会检查是否之前已经运行过，通过查找*file_list.txt* ![图片](../Images/00003.jpg)。如果找不到文件，脚本将继续执行。如果找到*file_list.txt*，脚本会立即重命名该文件。重命名的文件随后被打开，并读取其内容。对于文件中的每一行，脚本都会读取一个文件名和MD5哈希值，并将这些存储在`oldfile_hash`中以供后续比较。一旦`oldfile_hash`被填充，脚本就准备好开始计算新的MD5哈希值并比较结果。
- en: As the script works its way through the directory tree, it will iterate through
    each object ![](../Images/00004.jpg). The `Find.find` method is a powerful recursive
    way to retrieve files in a directory and subdirectories. The code block will be
    run on every file found. The first statement is looking for the "." and ".."—which
    are skipped for obvious reasons. If the object is a directory, the script will
    give it the skip treatment and press on. If the item is a file, the hash is generated
    and stored for later use. The hashing process is surrounded by a `begin`/`rescue`
    block to save us if something goes terribly wrong.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本遍历目录树时，它将遍历每个对象 ![图片](../Images/00004.jpg)。`Find.find`方法是一种强大的递归方式，用于检索目录及其子目录中的文件。代码块将在找到的每个文件上运行。第一条语句是查找"."和".."，出于明显的原因，这些将被跳过。如果对象是目录，脚本将对其进行跳过处理并继续。如果项目是文件，则生成哈希值并存储以供后续使用。哈希过程被包围在一个`begin`/`rescue`块中，以防出现严重错误。
- en: The bulk of the information gathering is now complete. All that is left is to
    determine the status of each file. If a file has the same name and MD5 hash, it
    is unchanged and the script will remove the filename from the output hash. There
    are three categories that a file can fit into aside from *Unchanged*. The first
    is *Deleted or Moved*, which is determined by a file's presence in the past scan
    but not the current one ![](../Images/00005.jpg). Next is the *Changed* category.
    If the filename exists and the MD5 hash is not the same as in the previous scans,
    the file has been changed ![](../Images/00006.jpg). At this point, for the sake
    of readability in the code, I used the *ternary operator*, which is an abbreviation
    of the `if`/`then`/`else` statement. So, this says if the file exists in `oldfile_hash`,
    *then* label it *Changed, else* label it *Added;* since the filename doesn't exist
    previously, it has been added since the last scan ![](../Images/00007.jpg). All
    of the data is saved, and a report is generated so the user is aware of each file's
    status. If anything is out of the ordinary, further analysis is required.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 信息收集的大部分工作现在已经完成。剩下要做的就是确定每个文件的状态。如果一个文件具有相同的名称和MD5哈希值，则表示文件未更改，脚本将移除输出哈希中的文件名。除了*未更改*之外，文件还可以归入以下三个类别之一。第一个是*已删除或移动*，这是通过检查文件在过去的扫描中存在但当前扫描中不存在来确定的
    ![图片](../Images/00005.jpg)。接下来是*已更改*类别。如果文件名存在，但MD5哈希值与之前的扫描不同，则表示文件已被更改 ![图片](../Images/00006.jpg)。在这个阶段，为了代码的可读性，我使用了*三元运算符*，它是`if`/`then`/`else`语句的缩写。所以，这表示如果文件存在于`oldfile_hash`中，*则*将其标记为*已更改，否则*标记为*新增；*因为文件之前不存在，所以自上次扫描以来已添加
    ![图片](../Images/00007.jpg)。所有数据都已保存，并生成报告，以便用户了解每个文件的状态。如果出现任何异常情况，则需要进一步分析。
- en: There are several software packages that perform similar computations for security
    purposes, but the method above is a nice alternative, and the price is right,
    too. For enhanced security, you can store the output files on a separate medium,
    but I generally leave them in the top-level directory for simplicity's sake.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个软件包执行类似的计算以用于安全目的，但上述方法是很好的替代方案，而且价格也合适。为了增强安全性，可以将输出文件存储在单独的介质上，但出于简单起见，我通常将它们留在顶级目录中。
- en: Hacking the Script
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: This script can be modified to use any number of hashing algorithms. I chose
    MD5 because it is the most popular for checking a file's integrity (even though
    its hashes are vulnerable to a collision attack). This script works on both Microsoft
    Windows and Unix-like systems. Cross platform scripts are always a plus!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可以被修改以使用任何数量的哈希算法。我选择了MD5，因为它在检查文件完整性方面最为流行（尽管其哈希值容易受到碰撞攻击）。此脚本在Microsoft
    Windows和类Unix系统上都能运行。跨平台脚本始终是一个加分项！
- en: Other potential changes to the script include encrypting the hashed files for
    added protection or interfacing the results into a database. The script has many
    potential uses, and I'll leave it to you to investigate further. If you are curious
    about encryption, check out the next script.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对脚本的潜在更改包括对哈希文件进行加密以增加保护或将其结果接口到数据库中。该脚本有许多潜在用途，我将留给你们去进一步调查。如果你对加密感兴趣，请查看下一脚本。
- en: Encrypt a File
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密文件
- en: Encrypt a File
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密文件
- en: encrypt.rb
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: encrypt.rb
- en: How often have you heard about people selling their computers on an auction
    site, only to later discover that their sensitive information had been exposed
    on the Internet? And what about corporate espionage, or all those missing government
    laptops? If you talk to security experts, one of the first recommendations they
    make is to encrypt sensitive information. You could always buy a program that
    does this for you, but that's no fun. Let's write our own encryption script! There
    are many encryption algorithms from which to choose, all with varying levels of
    strength. In this example, I will be using Blowfish, a very fast, symmetric block
    cipher.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次听说有人在拍卖网站上出售他们的电脑，结果后来发现他们的敏感信息已经在互联网上泄露了？还有企业间谍活动，或者所有那些丢失的政府笔记本电脑呢？如果你和网络安全专家交谈，他们给出的第一个建议之一就是加密敏感信息。你总是可以购买一个为你做这件事的程序，但这没有乐趣。让我们编写自己的加密脚本！有许多加密算法可供选择，它们具有不同的强度级别。在这个例子中，我将使用Blowfish，这是一种非常快、对称的分组密码。
- en: The Code
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''crypt/blowfish''   unless ARGV[0]     
    puts "Usage: ruby encrypt.rb <filename.ext>"      puts "Example: ruby encrypt.rb
    secret.stuff"      exit  end   #take in the file name to encrypt as an argument
     filename = ARGV[0].chomp  puts filename ![](../Images/00003.jpg) c = "Encrypted_#{filename}"
    ![](../Images/00004.jpg) if File.exists?(c)      puts "File already exists."   
      exit  end ![](../Images/00005.jpg) print ''Enter your encryption key (1-56 bytes):
    ''  kee = gets.chomp ![](../Images/00006.jpg) begin ![](../Images/00007.jpg)  
      blowfish = Crypt::Blowfish.new(kee) ![](../Images/00008.jpg)     blowfish.encrypt_file(filename.to_str,
    c)      puts ''Encryption SUCCESS!'' ![](../Images/00009.jpg) rescue Exception
    => e      puts "An error occurred during encryption: \n #{e}"  end`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) require ''crypt/blowfish''   unless ARGV[0]     
    puts "用法：ruby encrypt.rb <文件名.ext>"      puts "示例：ruby encrypt.rb secret.stuff"
         exit  end   #接收要加密的文件名作为参数  filename = ARGV[0].chomp  puts filename ![](../Images/00003.jpg) c
    = "Encrypted_#{filename}" ![](../Images/00004.jpg) if File.exists?(c)      puts
    "文件已存在。"      exit  end ![](../Images/00005.jpg) print ''请输入您的加密密钥（1-56字节）：''
     kee = gets.chomp ![](../Images/00006.jpg) begin ![](../Images/00007.jpg)    
    blowfish = Crypt::Blowfish.new(kee) ![](../Images/00008.jpg)     blowfish.encrypt_file(filename.to_str,
    c)      puts ''加密成功！'' ![](../Images/00009.jpg) rescue Exception => e      puts
    "加密过程中发生错误：\n #{e}"  end`'
- en: Running the Code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'You must have the Ruby gem *crypt* installed on your system—use the command
    `gem install crypt` at the console to install the crypt library. This encryption
    script is accessed through a command prompt. To run, type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在你的系统上安装Ruby gem *crypt*——在控制台使用命令`gem install crypt`来安装加密库。此加密脚本通过命令提示符访问。要运行，请输入：
- en: '``**`ruby encryption.rb`** *`/path/of/file/to/encrypt`*``'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby encryption.rb`** *`/path/of/file/to/encrypt`*``'
- en: 'You will be prompted for a password:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入密码：
- en: '`Enter your encryption key (1-56 characters):`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`请输入您的加密密钥（1-56个字符）：`'
- en: '* * *'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Warning
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 警告
- en: '*Remember your password, or you won''t be able to decrypt your file!*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住你的密码，否则你将无法解密你的文件！*'
- en: '* * *'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'Now press enter and, if the encryption was successful, you will see this message:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按回车键，如果加密成功，你将看到这条消息：
- en: '`Encryption SUCCESS!`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`加密成功！`'
- en: Look in the folder where this script resides; you will see the new, encrypted
    file, named *Encrypted_<filename>*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查看此脚本所在的文件夹；你会看到新的加密文件，命名为*Encrypted_<filename>*。
- en: The Results
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'For the example above, I used a plaintext file with the following contents:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上面的示例，我使用了一个包含以下内容的纯文本文件：
- en: '`Wicked Cool Ruby Scripts`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wicked Cool Ruby Scripts`'
- en: 'After the script has finished encrypting the file, it will output a success
    message. You can then attempt to view the file. Good luck deciphering it if you
    forgot your password:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本完成文件加密后，它将输出一条成功消息。然后你可以尝试查看文件。如果你忘记了密码，祝你好运解密：
- en: '`qo".1[>°<|šã_8tÃhÞí}"f-%◦1ð»=ðrþ¡.,`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`qo".1[>°<|šã_8tÃhÞí}"f-%◦1ð»=ðrþ¡.,`'
- en: As you can see, the results don't resemble the original plaintext at all.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，结果与原始明文完全不相似。
- en: How It Works
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In the first line, I include the library used for encryption: crypt/blowfish
    ![](../Images/00002.jpg). Note that you could change this to use another algorithm,
    such as Rijndael or GOST. Line ![](../Images/00003.jpg) starts the creation of
    our encrypted file. Creating files in Ruby is very simple. As you can see, I used
    a shortcut to name the file by including the variable (`filename`) *in line* with
    my string, `Encrypted_#{filename}`. I enjoy having the option of including variables
    in line with a text string, so you will see I use them throughout this book.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我包含了用于加密的库：crypt/blowfish ![图片](../Images/00002.jpg)。请注意，您可以将此更改为使用其他算法，例如Rijndael或GOST。![图片](../Images/00003.jpg)
    行开始创建我们的加密文件。在Ruby中创建文件非常简单。如您所见，我使用了一个快捷方式来命名文件，通过在字符串中包含变量（`filename`）*在同一行*中，命名为
    `Encrypted_#{filename}`。我喜欢有在文本字符串中包含变量的选项，所以您会看到我在整本书中都会使用它们。
- en: Next, we check to see if the encrypted filename already exists. We don't want
    the script overwriting files arbitrarily—data gets lost very easily that way.
    If there is no conflict, the script continues on ![](../Images/00004.jpg). Now
    that the script knows the encrypted file hasn't already been created, an *encryption
    key*, or password, needs to be provided by the user. The script asks for a key
    that is between 1 and 56 characters ![](../Images/00005.jpg). Once all the ncessary
    information has been collected, the script starts a `begin`/`rescue` error-handling
    block ![](../Images/00006.jpg). The last and most important piece of the script
    is the actual encryption of the data. A new encryption object is created with
    the encryption key passed as an argument ![](../Images/00007.jpg). Then the file
    is passed to the `encrypt_file` method, and *poof*—the file is encrypted ![](../Images/00008.jpg).
    If any errors were encountered during the encryption phase, the rescue block is
    there to catch them and exit the script gracefully, reporting the specific error
    ![](../Images/00009.jpg).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查加密的文件名是否已经存在。我们不希望脚本随意覆盖文件——这样很容易丢失数据。如果没有冲突，脚本将继续 ![图片](../Images/00004.jpg)。现在脚本知道加密文件尚未创建，需要用户提供一个*加密密钥*或密码。脚本要求提供一个1到56个字符的密钥
    ![图片](../Images/00005.jpg)。一旦收集到所有必要的信息，脚本开始一个 `begin`/`rescue` 错误处理块 ![图片](../Images/00006.jpg)。脚本最后也是最重要的部分是实际的数据加密。使用传递给参数的加密密钥创建一个新的加密对象
    ![图片](../Images/00007.jpg)。然后文件被传递到 `encrypt_file` 方法，*嗖*——文件被加密 ![图片](../Images/00008.jpg)。如果在加密阶段遇到任何错误，rescue块会捕获它们并优雅地退出脚本，报告具体的错误
    ![图片](../Images/00009.jpg)。
- en: Hacking the Script
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: You can modify this script in many different ways. For example, you can make
    it a modular part of another program, change the encryption algorithm, layer the
    encryption, automatically delete the plaintext file after encryption, or encrypt
    entire directories.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式修改此脚本。例如，您可以将其作为另一个程序的模块化部分，更改加密算法，分层加密，在加密后自动删除明文文件，或加密整个目录。
- en: Next, we will look at how to reverse the process and get our information back.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何逆向这个过程并恢复我们的信息。
- en: Decrypt a File
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密文件
- en: Decrypt a File
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密文件
- en: decrypt.rb
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: decrypt.rb
- en: This code is structured much like the encryption algorithm, so I will focus
    on the differences between the two. I am using the same algorithm for decryption
    as used during encryption. As mentioned earlier, you can use any number of encryption
    algorithms—just be sure to use the corresponding decryption algorithm. Don't forget
    your password, or else you will have to write your own brute force script if you
    ever want to see your data again!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的结构与加密算法非常相似，所以我将重点放在两者之间的区别上。我使用与加密时相同的算法进行解密。如前所述，您可以使用任意数量的加密算法——只需确保使用相应的解密算法。不要忘记您的密码，否则如果您想再次看到您的数据，您将不得不编写自己的暴力破解脚本！
- en: The Code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''crypt/blowfish''   unless ARGV[0]      puts "Usage: ruby decrypt.rb
    <Encrypted_filename.ext>"      puts "Example: ruby decrypt.rb Encrypted_secret.stuff"
           exit  end  ![](../Images/00002.jpg) filename = ARGV[0].chomp  puts "Decrypting
    #{filename}."  p = "Decrypted_#{filename}" ![](../Images/00003.jpg) if File.exists?(p)
         puts "File already exists."      exit  end ![](../Images/00004.jpg) print
    ''Enter your encryption key: ''  kee = gets.chomp   begin ![](../Images/00005.jpg)  
      blowfish = Crypt::Blowfish.new(kee)      blowfish.decrypt_file(filename.to_str,
    p)      puts ''Decryption SUCCESS!'' ![](../Images/00006.jpg) rescue Exception
    => e      puts "An error occurred during decryption: \n #{e}"  end`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''crypt/blowfish''   unless ARGV[0]   puts "用法：ruby decrypt.rb <加密文件名.ext>"   puts
    "示例：ruby decrypt.rb Encrypted_secret.stuff"   exit   end   ![](../Images/00002.jpg) filename
    = ARGV[0].chomp   puts "正在解密 #{filename}。"   p = "Decrypted_#{filename}"   ![](../Images/00003.jpg) if
    File.exists?(p)   puts "文件已存在。"   exit   end   ![](../Images/00004.jpg) print
    ''输入你的加密密钥：''   kee = gets.chomp   begin   ![](../Images/00005.jpg)     blowfish
    = Crypt::Blowfish.new(kee)       blowfish.decrypt_file(filename.to_str, p)       puts
    ''解密成功！''   ![](../Images/00006.jpg)     rescue Exception => e       puts "解密过程中发生错误：\n
    #{e}"   end`'
- en: Running the Code
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The code is simple to execute; just type the name of decryption script followed
    by the file you wish to decrypt:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行简单；只需输入解密脚本的名称，然后输入你希望解密的文件名：
- en: '``**`ruby decrypt.rb`** *`encrypted_filename.ext`*``'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby decrypt.rb`** *`encrypted_filename.ext`*``'
- en: The Ruby script will prompt you for the encryption key. Remember that you must
    have the key used to encrypt the file in order to decrypt it. If you don't, then
    there is no way to recover the file other than brute force, which can take much
    longer than you probably want to spend.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 脚本将提示你输入加密密钥。记住，你必须有用于加密文件的密钥才能解密它。如果没有，那么除了暴力破解之外，没有其他方法可以恢复文件，而这可能比你愿意花费的时间要长得多。
- en: The Results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`File Content Before: qo".1[>°<|šã_8tÃhÞí}"f-%◦1ð»=ðrþ¡., File Content After:
    Wicked Cool Ruby Scripts`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`文件内容之前：qo".1[>°<|šã_8tÃhÞí}"f-%◦1ð»=ðrþ¡., 文件内容之后：Wicked Cool Ruby Scripts`'
- en: As expected, the decryption script took the cipher text and cleanly translated
    it back into plaintext. If you have time, try using the wrong key and examine
    the output. It will look as cryptic as the cipher text.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，解密脚本将密文干净地转换回明文。如果你有时间，尝试使用错误的密钥并检查输出。它看起来会像密文一样晦涩难懂。
- en: How It Works
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script starts by grabbing the filename from the command-line argument and
    initializing the variables that will be used ![](../Images/00002.jpg). Whenever
    a file is created, you should always check to see if there is already a file with
    the same name ![](../Images/00003.jpg). After the algorithms have been initialized,
    the script will ask for a key ![](../Images/00004.jpg).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先从命令行参数中获取文件名，并初始化将要使用的变量！[](../Images/00002.jpg)。每当创建一个文件时，你应该检查是否已经存在同名文件！[](../Images/00003.jpg)。在初始化算法之后，脚本将要求输入一个密钥！[](../Images/00004.jpg)。
- en: Up to this point in the script, everything looks as it did for the encryption
    script. Even if you type the wrong encryption key, the script will decrypt the
    file based on that incorrect key, with results as cryptic as they were before.
    If all goes well, you'll be able use the file that was previously encrypted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，脚本中的所有内容看起来都与加密脚本相同。即使你输入了错误的加密密钥，脚本也会根据该错误的密钥解密文件，结果与之前一样晦涩难懂。如果一切顺利，你将能够使用之前加密的文件。
- en: The actual decryption happens using the `decrypt` method from the crypt library
    ![](../Images/00005.jpg), which is just the reverse of the encryption.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的解密是通过使用 crypt 库中的 `decrypt` 方法！[](../Images/00005.jpg)来完成的，这仅仅是加密的逆过程。
- en: If there are no errors or exceptions, the output will display `Decryption SUCCESS!`
    and the program will exit. If there is an issue, our `begin`/`rescue` block will
    catch the error and enter our `rescue` case. The `rescue` case displays an error
    message and notifies the user that the file has not yet been decrypted ![](../Images/00006.jpg).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或异常，输出将显示`解密成功！`然后程序将退出。如果有问题，我们的`begin`/`rescue`块将捕获错误并进入我们的`rescue`情况。`rescue`情况将显示错误消息并通知用户文件尚未被解密！[](../Images/00006.jpg)。
- en: Any modifications you make to the encryption script must also be made to the
    decryption script. If you do a task in the encryption script and forget to undo
    it in the decryption script, your data will be history.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对加密脚本所做的任何修改都必须对解密脚本进行相同的修改。如果你在加密脚本中执行了一个任务，却忘记在解密脚本中撤销它，你的数据将不复存在。
- en: File Splitting
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件分割
- en: File Splitting
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件分割
- en: fileSplit.rb
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fileSplit.rb
- en: A cool use of Ruby scripting is to split a large file into several smaller,
    symmetric files. I wrote this script for a friend who was having trouble sending
    files into and out of his corporate network since the network administrators wouldn't
    allow files over a certain size to be transferred—presumably for bandwidth reasons.
    This script worked like a charm.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 脚本的一个酷用是将大文件分割成几个较小的、对称的文件。我写这个脚本是为了一个朋友，他因为网络管理员不允许传输超过一定大小的文件（可能是出于带宽原因）而无法将文件发送到他的公司网络内部。这个脚本效果非常好。
- en: The Code
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) if ARGV.size != 2      puts "Usage: ruby fileSplit.rb
    <filename.ext> <size_of_pieces_in_bytes>"      puts "Example: ruby fileSplit.rb
    myfile.txt 10"      exit  end   filename = ARGV[0]  size_of_split = ARGV[1]  ![](../Images/00003.jpg) if
    File.exists?(filename)      file = File.open(filename, "r")      size = size_of_split.to_i    
      puts "The file is #{File.size(filename)} bytes."  ![](../Images/00004.jpg)  
      temp = File.size(filename).divmod(size)      pieces = temp[0]      extra = temp[1]    
      puts "\nSplitting the file into #{pieces} (#{size} byte) pieces and 1  (#{extra}
    byte) piece"  ![](../Images/00005.jpg)     pieces.times do |n|          f = File.open("#{filename}.rsplit#{n}",
    "w")          f.puts file.read(size)      end ![](../Images/00006.jpg)     e =
    File.open("#{filename}.rsplit#{pieces}", "w")      e.puts file.read(extra)  else
         puts "\n\nFile does NOT exist, please check filename."  end`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`![](../Images/00002.jpg) if ARGV.size != 2      puts "Usage: ruby fileSplit.rb
    <filename.ext> <size_of_pieces_in_bytes>"      puts "Example: ruby fileSplit.rb
    myfile.txt 10"      exit  end   filename = ARGV[0]  size_of_split = ARGV[1]  ![](../Images/00003.jpg) if
    File.exists?(filename)      file = File.open(filename, "r")      size = size_of_split.to_i    
      puts "The file is #{File.size(filename)} bytes."  ![](../Images/00004.jpg)  
      temp = File.size(filename).divmod(size)      pieces = temp[0]      extra = temp[1]    
      puts "\nSplitting the file into #{pieces} (#{size} byte) pieces and 1  (#{extra}
    byte) piece"  ![](../Images/00005.jpg)     pieces.times do |n|          f = File.open("#{filename}.rsplit#{n}",
    "w")          f.puts file.read(size)      end ![](../Images/00006.jpg)     e =
    File.open("#{filename}.rsplit#{pieces}", "w")      e.puts file.read(extra)  else
         puts "\n\nFile does NOT exist, please check filename."  end`'
- en: Running the Code
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'It''s easiest to run this script in a fresh directory with the file you want
    to split. Like the previous scripts, start by typing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个全新的目录中运行此脚本，并包含你想要分割的文件，是最简单的方法。像之前的脚本一样，首先输入：
- en: '``**`ruby fileSplit.rb`** *`path/to/file size_of_pieces_in_bytes`*``'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby fileSplit.rb`** *`path/to/file size_of_pieces_in_bytes`*``'
- en: 'If you want to split up a 10KB file into 1,000-byte (or 1KB) pieces, the script
    will make 10 separate files labeled *<filename>.rsplit<#1-10>*. To do this, type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将一个10KB的文件分割成1,000字节（或1KB）的片段，脚本将会创建10个单独的文件，分别标记为*<filename>.rsplit<#1-10>*。为此，请输入以下命令：
- en: '``**`ruby fileSplit.rb test.txt 1000`**``'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby fileSplit.rb test.txt 1000`**``'
- en: The Results
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'The initial file used in this example is called *test.txt*, and the results
    are shown below:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的初始文件名为 *test.txt*，结果如下所示：
- en: '`test.txt.rsplit0 test.txt.rsplit1 test.txt.rsplit2 test.txt.rsplit3 test.txt.rsplit4
    test.txt.rsplit5 test.txt.rsplit6 test.txt.rsplit7 test.txt.rsplit8 test.txt.rsplit9`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`test.txt.rsplit0 test.txt.rsplit1 test.txt.rsplit2 test.txt.rsplit3 test.txt.rsplit4
    test.txt.rsplit5 test.txt.rsplit6 test.txt.rsplit7 test.txt.rsplit8 test.txt.rsplit9`'
- en: How It Works
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: If you are faced with a pesky corporate network policy that has limited the
    size of files allowed to be transferred, or if you are looking for a more reliable
    way to transfer large files, this utility will save the day. I was faced with
    the corporate scenario, and I knew the file size limit, so I was able to hard
    code the file sizes. However, you can use whatever size you need or make it an
    option in the script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你面临着一个棘手的公司网络策略，限制了允许传输的文件大小，或者如果你正在寻找一种更可靠的传输大文件的方法，这个实用程序将能帮上大忙。我遇到了公司环境中的这种情况，我知道文件大小的限制，因此我能够硬编码文件大小。然而，你可以使用你需要的任何大小，或者将其作为脚本中的一个选项。
- en: 'The script starts by reading the first two items out of the ARGV array: the
    name of the file to split and the size of each section. If the two variables,
    `filename` and `size`, aren''t specified, the script will display `correct usage`![](../Images/00002.jpg).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先从 ARGV 数组中读取前两个项目：要分割的文件名和每个部分的尺寸。如果这两个变量，`filename` 和 `size`，没有指定，脚本将显示
    `正确用法`![](../Images/00002.jpg)。
- en: Next, the script ensures that you are trying to split a real file ![](../Images/00003.jpg).
    It's tough to divide by zero and even more difficult to split a file that doesn't
    exist. If the file cannot be found, the script exits and displays an error message
    letting the user know something is wrong with the filename. Hopefully, the file
    is found, and the script begins to set up for the splits.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本确保你正在尝试分割一个真实文件 ![图片](../Images/00003.jpg)。除以零很困难，分割一个不存在的文件则更加困难。如果找不到文件，脚本将退出并显示错误信息，告知用户文件名有问题。希望文件能被找到，脚本开始为分割做准备。
- en: As you know, files can be any size, and rarely are they perfectly divisible
    by whatever number of bytes you chose. In order to deal with dynamic file sizes,
    the script uses `divmod`—`divmod` will divide two numbers, passing back an array
    containing the quotient and modulus. In this script, `pieces` is the quotient
    and the `extra` is the modulus ![](../Images/00004.jpg).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，文件可以是任何大小，而且很少能被你选择的字节数完美分割。为了处理动态文件大小，脚本使用`divmod`——`divmod`将两个数字相除，返回一个包含商和余数的数组。在这个脚本中，`pieces`是商，而`extra`是余数
    ![图片](../Images/00004.jpg)。
- en: To maintain the file's integrity, the split pieces are created by reading in
    one byte at a time and writing binary to the output. This section is where the
    magic happens ![](../Images/00005.jpg). The whole pieces are written first, and
    then the extra piece ![](../Images/00006.jpg).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持文件的完整性，分割片段是通过一次读取一个字节并将二进制写入输出创建的。这一部分是魔法发生的地方 ![图片](../Images/00005.jpg)。首先写入整个片段，然后写入额外的片段
    ![图片](../Images/00006.jpg)。
- en: Hacking the Script
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: If you want to extend the code, a perfect addition would be to add a compression
    routine before the file is split. I'll talk more about compression later. Another
    spin on this script, giving it more flexibility, is to add an option for splitting
    the file into a specific number of pieces, regardless of the size. You could also
    modify this script to create file pieces sized to the media format of your choice,
    whether it's 700MB CDs or 2.88MB floppies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要扩展代码，一个完美的补充就是在分割文件之前添加一个压缩程序。我稍后会更多地讨论压缩。另一个使脚本更具灵活性的方法是为分割文件到特定数量的片段添加一个选项，无论大小如何。你也可以修改这个脚本以创建符合你选择的媒体格式的文件片段，无论是700MB的光盘还是2.88MB的软盘。
- en: File Joining
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件连接
- en: File Joining
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件连接
- en: fileJoin.rb
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fileJoin.rb
- en: This script was also written for my friend, knowing he would be pretty upset
    if he didn't have a way to reconstruct his files. This is a companion script for
    the file-splitting one, and both scripts can be put together in a wrapper if you
    prefer. (A *wrapper* is code that brings both scripts together in one utility.)
    I separated them here for instructional purposes. This file-joining script will
    only work for files that were previously split (see "#4 File Splitting" on [File
    Splitting](../Text/dummy_split_033.html#filepos127646)); however, you can adjust
    it to suit your needs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本也是为了我的朋友而写的，知道如果他无法重建文件，他会非常沮丧。这是文件分割脚本的配套脚本，如果你愿意，可以将这两个脚本放在一个包装器中。（包装器是将两个脚本结合在一起的一个工具。）我这里将它们分开是为了教学目的。这个文件连接脚本只适用于之前分割过的文件（参见[文件分割](../Text/dummy_split_033.html#filepos127646)中的“#4
    文件分割”）；然而，你可以调整它以满足你的需求。
- en: The Code
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) if ARGV.size != 1      puts "Usage: ruby fileJoin.rb
    <filename.ext>"      puts "Example: ruby fileJoin.rb myfile.txt"      exit  end   file
    = ARGV[0]  piece = 0  orig_file = "New.#{file}"  ![](../Images/00003.jpg) if File.exists?("#{file}.rsplit#{piece}")
    ![](../Images/00004.jpg)     ofile = File.open(orig_file, "w") ![](../Images/00005.jpg)  
      while File.exists?("#{file}.rsplit#{piece}")          puts "Reading File: #{file}.rsplit#{piece}"
    ![](../Images/00006.jpg)         ofile << File.open("#{file}.rsplit#{piece}","r").read.chomp
             piece+=1      end      ofile.close      puts "\nSUCCESS!  File reconstructed."
     else      puts "\n\nCould not find #{file}.rsplit#{piece}."  end`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`![图片](../Images/00002.jpg) if ARGV.size != 1'
- en: Running the Code
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The script does not support a change in directory, so make sure it is located
    in the same directory as the files you want to join. To run the script, type:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本不支持更改目录，所以请确保它位于你想要连接的文件所在的同一目录中。要运行脚本，请输入：
- en: '``**`ruby fileJoin.rb`** *`filename.ext`*``'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby fileJoin.rb`** *`filename.ext`*``'
- en: The Results
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Using the files output by the file-splitting script, the input should be the
    name of the file to be reassembled as shown below:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件分割脚本输出的文件，输入应该是要重新组装的文件名，如下所示：
- en: '`Reading File: test.txt.rsplit0 Reading File: test.txt.rsplit1 Reading File:
    test.txt.rsplit2 Reading File: test.txt.rsplit3 Reading File: test.txt.rsplit4
    Reading File: test.txt.rsplit5 Reading File: test.txt.rsplit6 Reading File: test.txt.rsplit7
    Reading File: test.txt.rsplit8 Reading File: test.txt.rsplit9 SUCCESS!  File Reconstructed.`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`读取文件：test.txt.rsplit0 读取文件：test.txt.rsplit1 读取文件：test.txt.rsplit2 读取文件：test.txt.rsplit3
    读取文件：test.txt.rsplit4 读取文件：test.txt.rsplit5 读取文件：test.txt.rsplit6 读取文件：test.txt.rsplit7
    读取文件：test.txt.rsplit8 读取文件：test.txt.rsplit9 成功！ 文件已重建。`'
- en: After the script has run, the assembled file will be called *New.test.txt*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，组装的文件将被命名为*New.test.txt*。
- en: The new file that was joined will be found in the same directory as the script.
    Each *.rsplit* piece will still exist, in case there were any errors reconstructing
    the file. Once you locate the file and open it, the contents should be exactly
    as they were before you split the file. You can compare the old and new MD5 hashes
    to see for yourself (see "#1 Check for Changed Files" on [Check for Changed Files](../Text/dummy_split_013.html#filepos92614)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 被连接的新文件将在脚本所在的同一目录中找到。每个*.rsplit*片段仍然存在，以防在重建文件时出现任何错误。一旦找到文件并打开它，内容应该与分割文件之前完全相同。你可以比较旧的和新的MD5散列值来亲自查看（见[检查更改的文件](../Text/dummy_split_013.html#filepos92614)中的“#1
    检查更改的文件”）。
- en: How It Works
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The script starts by getting the original filename of the file that was split.
    If a name was not provided as a command-line argument, the script will complain,
    and you'll have to try again ![](../Images/00002.jpg). If a filename is provided,
    then the script checks to see if there are any pieces that correspond to that
    filename ![](../Images/00003.jpg). If not, it will again complain, saying the
    file couldn't be found.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先获取被分割的文件的原始文件名。如果没有提供命令行参数，脚本将报错，并且你必须再次尝试！ ![](../Images/00002.jpg)。如果提供了文件名，脚本将检查是否有与该文件名对应的片段！
    ![](../Images/00003.jpg)。如果没有，它将再次报错，表示找不到文件。
- en: After the first piece is located, the script creates the output file ![](../Images/00004.jpg).
    Next, a while loop is used to ensure that only the next consecutive piece is appended
    to the main body ![](../Images/00005.jpg). As long as there is a "next piece,"
    the script will continue appending to the output file. Since the data of each
    split piece has a newline at the end, we use the `chomp` method to ensure only
    raw data is being streamed ![](../Images/00006.jpg).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 找到第一块后，脚本创建输出文件 ![](../Images/00004.jpg)。接下来，使用while循环确保只将下一个连续的片段附加到主体 ![](../Images/00005.jpg)。只要存在“下一个片段”，脚本就会继续将数据附加到输出文件。由于每个分割片段的数据末尾都有一个换行符，我们使用`chomp`方法确保只流式传输原始数据
    ![](../Images/00006.jpg)。
- en: The output file is closed after all the pieces have been appended to it. A nice
    success message is displayed and the script exits. Now you can check the new file
    to verify that it is perfectly restored.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有片段附加到输出文件后，输出文件将被关闭。将显示一个成功的消息，并且脚本退出。现在你可以检查新文件以验证它是否完美恢复。
- en: Hacking the Script
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞脚本
- en: If you trust the script, you can tweak it to clean up after itself, erasing
    all of the .*rsplit* pieces. You could also compute the MD5 hash of the file before
    and after the split to verify its authenticity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你信任脚本，你可以对其进行调整以清理自身，删除所有的 .*rsplit* 片段。你还可以在分割前后计算文件的MD5散列值以验证其真实性。
- en: Windows Process Viewer
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows进程查看器
- en: Windows Process Viewer
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows进程查看器
- en: listWin Processes.rb
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: listWin Processes.rb
- en: The process viewer in Windows Task Manager can be extremely frustrating, due
    to a lack of information. If you have ever used the `ps` command on a Unix-like
    system, you know how much more information is available besides the process name,
    CPU/memory usage, and process owner. Some applications make nice, detailed entries
    in the process viewer, and those tasks are easy to identify, but other applications
    have some ambiguous name that doesn't do you any favors. Having an alternative
    way to view the processes is handy because you can customize the script to show
    exactly what is important to you. This script demonstrates how to retrieve every
    available process property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Windows任务管理器中的进程查看器可能会非常令人沮丧，因为信息不足。如果你曾在类Unix系统中使用过 `ps` 命令，你就会知道除了进程名称、CPU/内存使用情况和进程所有者之外，还有多少信息可用。一些应用程序在进程查看器中创建了详细条目，这些任务很容易识别，但其他应用程序有一些模糊的名称，对你没有任何帮助。有另一种方式查看进程很方便，因为你可以根据需要自定义脚本，以显示对你来说真正重要的信息。这个脚本演示了如何检索每个可用的进程属性。
- en: The Code
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '`![](../Images/00002.jpg) require ''win32ole'' ![](../Images/00003.jpg)    
    ps = WIN32OLE.connect("winmgmts:\\\\.") ![](../Images/00004.jpg)     ps.InstancesOf("win32_process").each
    do |p| ![](../Images/00005.jpg)     puts "Process: #{p.name}"      puts "\tID:
    #{p.processid}"      puts "\tPATH:#{p.executablepath}"      puts "\tTHREADS: #{p.threadcount}"
         puts "\tPRIORITY: #{p.priority}"      puts "\tCMD_ARGS: #{p.commandline}"
       end`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`![win32ole库](../Images/00002.jpg) require ''win32ole'' ![Windows内部方法](../Images/00003.jpg)
    ps = WIN32OLE.connect("winmgmts:\\\\.") ![连接到WMI](../Images/00004.jpg) ps.InstancesOf("win32_process").each
    do |p| ![遍历进程](../Images/00005.jpg) puts "进程: #{p.name}" puts "\tID: #{p.processid}"
    puts "\t路径:#{p.executablepath}" puts "\t线程数: #{p.threadcount}" puts "\t优先级: #{p.priority}"
    puts "\t命令行参数: #{p.commandline}" end`'
- en: Running the Code
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: The script is written so that it runs autonomously and displays information
    about each process. Add and remove properties in the script as needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本编写得可以独立运行，并显示每个进程的信息。根据需要添加和删除脚本中的属性。
- en: The Results
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '`Process: winlogon.exe     ID: 1296     PATH:C:\WINDOWS\system32\winlogon.exe
        THREADS: 22     PRIORITY: 13     CMD_ARGS: winlogon.exe Process: services.exe
        ID: 1348     PATH:C:\WINDOWS\system32\services.exe     THREADS: 15     PRIORITY:
    9     CMD_ARGS: C:\WINDOWS\system32\services.exe Process: explorer.exe     ID:
    1240     PATH:C:\WINDOWS\Explorer.EXE     THREADS: 14     PRIORITY: 8     CMD_ARGS:
    C:\WINDOWS\Explorer.EXE Process: svchost.exe     ID: 3836     PATH:C:\WINDOWS\System32\svchost.exe
        THREADS: 8     PRIORITY: 8     CMD_ARGS: C:\WINDOWS\System32\svchost.exe -k
    HTTPFilter Process: firefox.exe     ID: 2140     PATH:C:\Program Files\Mozilla
    Firefox\firefox.exe     THREADS: 7     PRIORITY: 8     CMD_ARGS: "C:\Program Files\Mozilla
    Firefox\firefox.exe" Process: cmd.exe     ID: 1528     PATH:C:\WINDOWS\system32\cmd.exe
        THREADS: 1     PRIORITY: 8     CMD_ARGS: "C:\WINDOWS\system32\cmd.exe" Process:
    ruby.exe     ID: 244     PATH:c:\ruby\bin\ruby.exe     THREADS: 4     PRIORITY:
    8     CMD_ARGS: ruby ListWinProcesses.rb`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`进程: winlogon.exe    ID: 1296    路径:C:\WINDOWS\system32\winlogon.exe    线程数:
    22    优先级: 13    命令行参数: winlogon.exe 进程: services.exe    ID: 1348    路径:C:\WINDOWS\system32\services.exe    线程数:
    15    优先级: 9    命令行参数: C:\WINDOWS\system32\services.exe 进程: explorer.exe    ID:
    1240    路径:C:\WINDOWS\Explorer.EXE    线程数: 14    优先级: 8    命令行参数: C:\WINDOWS\Explorer.EXE
    进程: svchost.exe    ID: 3836    路径:C:\WINDOWS\System32\svchost.exe    线程数: 8    优先级:
    8    命令行参数: C:\WINDOWS\System32\svchost.exe -k HTTPFilter 进程: firefox.exe    ID:
    2140    路径:C:\Program Files\Mozilla Firefox\firefox.exe    线程数: 7    优先级: 8    命令行参数:
    "C:\Program Files\Mozilla Firefox\firefox.exe" 进程: cmd.exe    ID: 1528    路径:C:\WINDOWS\system32\cmd.exe    线程数:
    1    优先级: 8    命令行参数: "C:\WINDOWS\system32\cmd.exe" 进程: ruby.exe    ID: 244    路径:c:\ruby\bin\ruby.exe    线程数:
    4    优先级: 8    命令行参数: ruby ListWinProcesses.rb`'
- en: How It Works
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: For most interactions with the Windows Operating System, I use the win32ole
    library ![](../Images/00002.jpg). This library is very useful, and I'll demonstrate
    more automation with it in later chapters. The first part of the script is the
    initialization of *winmgmts*, which lets the script interact with the Windows
    internal methods ![](../Images/00003.jpg). *Winmgmts* is the *Windows Management
    Interface (WMI)*. WMI has a lot of useful tools that you can explore further if
    you're interested in scripting for Windows. I called my instance of WMI `ps` because
    it reminds me of the `ps` method in Unix-style systems.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与Windows操作系统的大多数交互，我使用win32ole库 ![win32ole库](../Images/00002.jpg)。这个库非常有用，我将在后面的章节中用它演示更多的自动化。脚本的第一个部分是初始化
    *winmgmts*，这使得脚本可以与Windows内部方法交互 ![Windows内部方法](../Images/00003.jpg)。*Winmgmts*
    是 *Windows Management Interface (WMI)*。WMI有很多有用的工具，如果你对Windows脚本编写感兴趣，可以进一步探索。我把我实例化的WMI命名为
    `ps`，因为它让我想起了Unix风格系统中的 `ps` 方法。
- en: Next, the script iterates all instances of `win32_process`. This is where all
    of the processes are found and information can be extracted ![](../Images/00004.jpg).
    The properties I used for the script are `process name, id, path, threads running`,
    `priority`, and `command line arguments`. I find knowing command-line arguments
    useful in case I want to invoke the program from some other script or from the
    command line ![](../Images/00005.jpg).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，脚本迭代所有 `win32_process` 的实例。这是找到所有进程并提取信息的地方 ![](../Images/00004.jpg)。我用于脚本的属性包括
    `进程名称、ID、路径、运行的线程`、`优先级` 和 `命令行参数`。我发现知道命令行参数在我想从其他脚本或命令行调用程序时很有用 ![](../Images/00005.jpg)。
- en: Hacking the Script
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解脚本
- en: If you want to view everything about each process, you can include the properties
    listed below from the WMI properties class. There are a lot of possible configurations
    to suit your needs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看每个进程的所有信息，你可以从WMI属性类中包含以下属性。有很多可能的配置可以满足你的需求。
- en: '| WMI Process Class Properties |  |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| WMI进程类属性 |  |  |'
- en: '| --- | --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Caption` | `OSCreationClassName` | `QuotaPeakPagedPoolUsage` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Caption` | `OSCreationClassName` | `QuotaPeakPagedPoolUsage` |'
- en: '| `CommandLine` | `OSName` | `ReadOperationCount` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `CommandLine` | `OSName` | `ReadOperationCount` |'
- en: '| `CreationClassName` | `OtherOperationCount` | `ReadTransferCount` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `CreationClassName` | `OtherOperationCount` | `ReadTransferCount` |'
- en: '| `CreationDate` | `OtherTransferCount` | `SessionId` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `CreationDate` | `OtherTransferCount` | `SessionId` |'
- en: '| `CSCreationClassName` | `PageFaults` | `Status` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `CSCreationClassName` | `PageFaults` | `Status` |'
- en: '| `CSName` | `PageFileUsage` | `TerminationDate` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `CSName` | `PageFileUsage` | `TerminationDate` |'
- en: '| `Description` | `ParentProcessId` | `ThreadCount` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Description` | `ParentProcessId` | `ThreadCount` |'
- en: '| `ExecutablePath` | `PeakPageFileUsage` | `UserModeTime` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `ExecutablePath` | `PeakPageFileUsage` | `UserModeTime` |'
- en: '| `ExecutionState` | `PeakVirtualSize` | `VirtualSize` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `ExecutionState` | `PeakVirtualSize` | `VirtualSize` |'
- en: '| `Handle` | `PeakWorkingSetSize` | `WindowsVersion` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `Handle` | `PeakWorkingSetSize` | `WindowsVersion` |'
- en: '| `HandleCount` | `Priority` | `WorkingSetSize` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `HandleCount` | `Priority` | `WorkingSetSize` |'
- en: '| `InstallDate` | `PrivatePageCount` | `WriteOperationCount` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `InstallDate` | `PrivatePageCount` | `WriteOperationCount` |'
- en: '| `KernelModeTime` | `ProcessId` | `WriteTransferCount` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `KernelModeTime` | `ProcessId` | `WriteTransferCount` |'
- en: '| `MaximumWorkingSetSize` | `QuotaNonPagedPoolUsage` | `WorkingSetSize` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `MaximumWorkingSetSize` | `QuotaNonPagedPoolUsage` | `WorkingSetSize` |'
- en: '| `MinimumWorkingSetSize` | `QuotaPagedPoolUsage` |  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `MinimumWorkingSetSize` | `QuotaPagedPoolUsage` |  |'
- en: '| `Name` | `QuotaPeakNonPagedPoolUsage` |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | `QuotaPeakNonPagedPoolUsage` |  |'
- en: While the list above contains all the properties for the WMI process class,
    there are several other operating system classes—each with its own properties.
    To use the same script with a different operating system class, replace the `win32_process`
    at ![](../Images/00004.jpg) with another WMI class. For example, `registry` would
    be `win32_registry`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上述列表包含了WMI进程类的所有属性，但还有几个其他的操作系统类——每个类都有其自己的属性。要使用与不同操作系统类相同的脚本，请将 ![](../Images/00004.jpg)
    中的 `win32_process` 替换为另一个WMI类。例如，`registry` 将会是 `win32_registry`。
- en: File Compressor
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件压缩器
- en: File Compressor
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件压缩器
- en: compress.rb
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: compress.rb
- en: Being able to effectively compress a file is a serious asset when you start
    talking about data storage. The more efficient the compression, the more information
    can be stored in the same amount of space. There are two popular Ruby compression
    libraries in use today. The first is ruby-zlib, and the second is rubyzip. Both
    have their advantages and disadvantages, and I'll leave it to you to choose a
    compression algorithm that fits your purpose. I will be using rubyzip in the following
    script.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始谈论数据存储时，能够有效地压缩文件是一个重要的资产。压缩越高效，在相同的空间内可以存储的信息就越多。目前有两个流行的Ruby压缩库正在使用。第一个是ruby-zlib，第二个是rubyzip。它们各有优缺点，我将留给您选择适合您目的的压缩算法。在下面的脚本中，我将使用rubyzip。
- en: The Code
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''zip/zip''  ![](../Images/00002.jpg) unless ARGV[0]      puts "Usage:
    ruby compress.rb <filename.ext>"      puts "Example: ruby compress.rb myfile.exe"
         exit  end   file = ARGV[0].chomp  ![](../Images/00003.jpg) if File.exists?(file)
         print "Enter zip filename:"      zip = "#{gets.chomp}.zip" ![](../Images/00004.jpg)  
      Zip::ZipFile.open(zip, true) do |zipfile| ![](../Images/00005.jpg)        begin
                puts "#{file} is being added to the archive." ![](../Images/00006.jpg)  
         zipfile.add(file,file) ![](../Images/00007.jpg)        rescue Exception =>
    e             puts "Error adding to zipfile: \n #{e}"         end      end  else
         puts "\nFile could not be found."  end`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''zip/zip''  ![图片](../Images/00002.jpg) unless ARGV[0]      puts
    "Usage: ruby compress.rb <filename.ext>"      puts "Example: ruby compress.rb
    myfile.exe"      exit  end   file = ARGV[0].chomp  ![图片](../Images/00003.jpg) if
    File.exists?(file)      print "Enter zip filename:"      zip = "#{gets.chomp}.zip"
    ![图片](../Images/00004.jpg)     Zip::ZipFile.open(zip, true) do |zipfile| ![图片](../Images/00005.jpg)  
         begin             puts "#{file} is being added to the archive." ![图片](../Images/00006.jpg)  
         zipfile.add(file,file) ![图片](../Images/00007.jpg)        rescue Exception
    => e             puts "Error adding to zipfile: \n #{e}"         end      end
     else      puts "\nFile could not be found."  end`'
- en: Running the Code
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'This script allows users to compress different file types, either to save space
    or for easy archiving. Call the script with the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本允许用户压缩不同类型的文件，无论是为了节省空间还是为了便于存档。使用以下命令调用脚本：
- en: '``**`ruby compress.rb`** *`/path/to/file`*``'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby compress.rb`** *`/path/to/file`*``'
- en: The Results
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: The script will create a compressed archive of the file specified on the command
    line using the name the user provides at the prompt. For this example, I compressed
    *chapter1.odt* into *nostarch.zip*. Before compression, *chapter1.odt* was 29.1KB,
    and after the compression, it was 26.3KB. The file will be stored in the same
    directory as the script is executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将使用用户在提示中提供的名称，通过命令行指定的文件创建一个压缩存档。在这个例子中，我将`chapter1.odt`压缩成了`nostarch.zip`。在压缩之前，`chapter1.odt`的大小是29.1KB，压缩后变成了26.3KB。文件将存储在脚本执行的同一目录中。
- en: How It Works
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: When the script is run, the first error handling check is made to ensure the
    user has provided a file to compress ![](../Images/00002.jpg). If a filename has
    been provided, the file is checked for availability. As always, there is no sense
    in continuing if the object we want to manipulate is not available. If the file
    doesn't exist, the script alerts the user and promptly exits ![](../Images/00003.jpg).
    If the file does exist and has been validated, the user is asked to name the Zip
    file. After the user types the filename and presses ENTER, the script continues.
    That press of the ENTER key is added to the character stream and, in turn, sent
    to the script as user input. You'll note that `chomp` is used to remove the `\n`
    (*newline character*) that is added when the user strikes ENTER.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，首先进行错误处理检查以确保用户已提供要压缩的文件 ![图片](../Images/00002.jpg)。如果已提供文件名，则会检查文件是否可用。始终，如果我们想要操作的物体不可用，就没有继续下去的意义。如果文件不存在，脚本会提醒用户并立即退出
    ![图片](../Images/00003.jpg)。如果文件存在且已验证，则会要求用户命名Zip文件。在用户输入文件名并按下ENTER键后，脚本继续执行。请注意，按下ENTER键时，会将`\n`（换行字符）添加到字符流中，并将其作为用户输入发送到脚本。您会注意到使用了`chomp`来移除用户按下ENTER时添加的`\n`。
- en: The code used to compress the file is straightforward. As seen above on line
    ![](../Images/00004.jpg), the section will open an existing Zip file if it is
    available and the second parameter is set to `true`. A new Zip file will be created
    if the file doesn't already exist. These options are similar to the `open` method
    in the File library.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于压缩文件的代码很简单。如上所示，在![图片](../Images/00004.jpg)行，该部分将打开一个现有的Zip文件（如果可用且第二个参数设置为`true`），如果文件不存在，则会创建一个新的Zip文件。这些选项与File库中的`open`方法类似。
- en: Sometimes errors happen. The most vulnerable spot in this script is during the
    compression while adding files to the Zip file. The `begin`/`rescue` block at
    ![](../Images/00005.jpg) is used to handle unforeseen errors and provide information
    to the user about any issues. If an error does occur, the `rescue` block will
    be executed and the script will exit, displaying the error message ![](../Images/00007.jpg).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会发生错误。在这个脚本中，最脆弱的地方是在压缩过程中向Zip文件添加文件时。![图片](../Images/00005.jpg)处的`begin`/`rescue`块用于处理意外错误并向用户提供有关任何问题的信息。如果发生错误，`rescue`块将被执行，脚本将退出，并显示错误信息![图片](../Images/00007.jpg)。
- en: Each file that is being added to the Zip file is saved using the `add` method
    ![](../Images/00006.jpg). You can create directories in the Zip file from this
    section or write entirely new files on the fly. Basically, the Zip filesystem
    can be treated like any normal directory on your computer. The syntax is a little
    different, but the results are the same.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个被添加到Zip文件中的文件都使用`add`方法保存 ![图片6](../Images/00006.jpg)。你可以从这一部分在Zip文件中创建目录，或者即时写入全新的文件。基本上，Zip文件系统可以像你的计算机上的任何正常目录一样处理。语法略有不同，但结果相同。
- en: The rubyzip library is wonderful because you can open the Zip file and manipulate
    the contents without having to decompress the entire archive. Also, instead of
    grouping files and then compressing them, as tar and gz do, rubyzip will do all
    of this with just one command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: rubyzip库非常出色，因为它允许你打开Zip文件并操作内容，而无需解压整个存档。此外，与tar和gz将文件分组然后压缩不同，rubyzip只需一个命令就能完成所有这些操作。
- en: File Decompression
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件解压
- en: File Decompression
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件解压
- en: decompress.rb
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: decompress.rb
- en: This script shows you the basics of decompressing a file. The rubyzip library
    does all of the work for you. On a standard Unix-like system, you would have to
    manually unzip the file, carry out your task, and then re-compress the file. With
    rubyzip, you can work with files in an archive using one seamless library. This
    script completely decompresses an archive into the user-specified directory.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本展示了如何解压文件的基本方法。rubyzip库为你完成所有工作。在标准的类Unix系统中，你将需要手动解压文件，执行任务，然后重新压缩文件。使用rubyzip，你可以使用一个无缝的库来处理存档中的文件。此脚本将存档完全解压到用户指定的目录。
- en: The Code
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` require ''zip/zip''  require ''fileutils''   unless ARGV[0]      puts "Usage:
    ruby decompress.rb <zipfilename.zip>"      puts "Example: ruby decompress.rb myfile.zip"
         exit  end   archive = ARGV[0].chomp  ![](../Images/00002.jpg) if File.exists?(archive)
         print "Enter path to save files to (\''.\'' for same directory): " ![](../Images/00002.jpg)  
      extract_dir = gets.chomp ![](../Images/00004.jpg)     begin ![](../Images/00005.jpg)  
          Zip::ZipFile::open(archive) do |zipfile|              zipfile.each do |f|
    ![](../Images/00006.jpg)                 path = File.join(extract_dir, f.name)
                     FileUtils.mkdir_p(File.dirname(path))                  zipfile.extract(f,
    path)              end          end ![](../Images/00007.jpg)     rescue Exception
    => e          puts e      end  else      puts "An error occurred during decompression:
    \n #{e}"  end`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '` require ''zip/zip''  require ''fileutils''   unless ARGV[0]      puts "用法:
    ruby decompress.rb <zipfilename.zip>"      puts "示例: ruby decompress.rb myfile.zip"
         exit  end   archive = ARGV[0].chomp  ![](../Images/00002.jpg) if File.exists?(archive)
         print "输入保存文件的路径（\''.\''表示同一目录）: " ![](../Images/00002.jpg)     extract_dir
    = gets.chomp ![](../Images/00004.jpg)     begin ![](../Images/00005.jpg)      
      Zip::ZipFile::open(archive) do |zipfile|              zipfile.each do |f| ![](../Images/00006.jpg)  
                  path = File.join(extract_dir, f.name)                  FileUtils.mkdir_p(File.dirname(path))
                     zipfile.extract(f, path)              end          end ![](../Images/00007.jpg)  
      rescue Exception => e          puts e      end  else      puts "解压过程中发生错误：\n
    #{e}"  end`'
- en: Running the Code
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: The decompression script is invoked like the compression script, with the file
    to decompress as the command-line argument.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 解压脚本的使用方式与压缩脚本类似，需要将需要解压的文件作为命令行参数传入。
- en: '``**`ruby decompress.rb`** *`/path/to/compressed/file`*``'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '``**`ruby decompress.rb`** *`/path/to/compressed/file`*``'
- en: The Results
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: All files that were originally put into the Zip file will be decompressed in
    the same structure they had before compression. For this example, I decompressed
    *nostarch.zip* into *chapter1.odt*. The compressed Zip file *chapter1.odt* was
    26.3KB, and after decompression, the file went back to the original 29.1KB.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最初放入Zip文件中的文件都将按照压缩前的结构进行解压。例如，我将*nostarch.zip*解压到*chapter1.odt*。压缩后的Zip文件*chapter1.odt*大小为26.3KB，解压后文件恢复到原始的29.1KB。
- en: How It Works
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Similar to the compression script, this script expects the zipped file to be
    provided as a command-line argument. If the archive file cannot be located, the
    script will present the user with an error message ![](../Images/00002.jpg). The
    major difference between the scripts is that, instead of asking for the name of
    the Zip file to be created, the decompression script requests the target path
    where the unzipped files should go ![](../Images/00003.jpg).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与压缩脚本类似，此脚本期望将压缩文件作为命令行参数提供。如果无法找到存档文件，脚本将向用户显示错误消息 ![图片2](../Images/00002.jpg)。这两个脚本的主要区别在于，解压脚本不是要求输入要创建的Zip文件名，而是要求输入解压文件的目标路径
    ![图片3](../Images/00003.jpg)。
- en: The next step is the start of a `begin`/`rescue` block ![](../Images/00004.jpg).
    As with the compression script, the decompression is a vulnerable section of code.
    The first part of decompression is to open the zipped file ![](../Images/00005.jpg).
    After that, each file is decompressed. The decompression routine recreates the
    directory structure as it was before compression ![](../Images/00006.jpg). So,
    if there were two subfolders before compression, there will also be two folders
    after this script has completed. As long as no errors are encountered, the script
    will output each file into the directory specified by the user. The last part
    of the script is the `rescue` block, which will catch and report any errors that
    occur during decompression ![](../Images/00007.jpg).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是`begin`/`rescue`块的开始 ![图片](../Images/00004.jpg)。与压缩脚本一样，解压缩是代码中的一个脆弱部分。解压缩的第一部分是打开压缩文件
    ![图片](../Images/00005.jpg)。之后，每个文件都会被解压缩。解压缩例程会重新创建与压缩前相同的目录结构 ![图片](../Images/00006.jpg)。因此，如果压缩前有两个子文件夹，那么在脚本完成后也会有两个文件夹。只要没有遇到错误，脚本就会将每个文件输出到用户指定的目录。脚本的最后一部分是`rescue`块，它会捕获并报告解压缩过程中发生的任何错误
    ![图片](../Images/00007.jpg)。
- en: Mortgage Calculator
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抵押贷款计算器
- en: Mortgage Calculator
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抵押贷款计算器
- en: mortgageCalc.rb
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mortgageCalc.rb
- en: I recently began house shopping. Being a first-time home buyer, the task seemed
    daunting, especially when I considered the financing options. So, I decided to
    write a script to help me get a handle on mortgage rates—at least this way, I
    could estimate my monthly payments. Even though Ruby didn't solve all of the issues
    related to buying a home, this script helped me get a handle on my financing options.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近开始看房子。作为一个首次购房者，这项任务似乎很艰巨，尤其是当我考虑融资选项时。所以我决定写一个脚本来帮助我了解抵押贷款利率——至少这样，我可以估算我的月供。尽管Ruby没有解决与购房相关的所有问题，但这个脚本帮助我了解了我的融资选项。
- en: The Code
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '` print "Enter Loan amount: "  loan = gets.chomp.to_i  print "Enter length
    of time in months: "  time = gets.chomp.to_i  print "Enter interest rate: "  rate
    = gets.chomp.to_f/100  ![](../Images/00002.jpg) i = (1+rate/12)**(12/12)-1 ![](../Images/00003.jpg) annuity
    = (1-(1/(1+i))**time)/i  ![](../Images/00004.jpg) payment = loan/annuity  ![](../Images/00005.jpg) puts
    "\n$%.2f per month" % [payment]`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '` print "Enter Loan amount: "  loan = gets.chomp.to_i  print "Enter length
    of time in months: "  time = gets.chomp.to_i  print "Enter interest rate: "  rate
    = gets.chomp.to_f/100  ![](../Images/00002.jpg) i = (1+rate/12)**(12/12)-1 ![](../Images/00003.jpg) annuity
    = (1-(1/(1+i))**time)/i  ![](../Images/00004.jpg) payment = loan/annuity  ![](../Images/00005.jpg) puts
    "\n$%.2f per month" % [payment]`'
- en: Running the Code
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: This script is interactive and therefore runs without any parameters. It walks
    the user through each piece of information needed to come up with the correct
    monthly payment. No command-line arguments are needed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本交互式运行，因此无需任何参数。它会引导用户输入所需的所有信息以得出正确的月供。不需要命令行参数。
- en: The Results
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '``Enter Loan amount: *`250000`* Enter length of time in months: *`360`* Enter
    interest rate: *`6.5`*  $1580.17 per month``'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '``输入贷款金额：*`250000`* 输入月数：*`360`* 输入利率：*`6.5`*  每月$1580.17``'
- en: How It Works
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Mortgage calculations always seemed a bit cryptic to me, and I thought I needed
    a wall of degrees to understand the formulas. Thankfully, calculating a mortgage
    payment isn''t like solving differential equations! It''s quite a bit easier,
    once you understand the basic formulas. The calculations of a mortgage payment
    are broken down into two main formulas (that can be combined into one formula,
    if you are feeling especially daring). The first calculates the *interest rate*
    per month using the following equation ![](../Images/00002.jpg)(don''t forget
    that `**` is the Ruby way of expressing exponentiation):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，抵押贷款计算似乎有点神秘，我以为我需要一堵学位墙来理解这些公式。幸运的是，计算抵押贷款支付并不像解微分方程！一旦你理解了基本公式，它就简单多了。抵押贷款支付的计算分为两个主要公式（如果你特别大胆，可以合并成一个公式）。第一个公式使用以下方程计算每月的*利率*
    ![图片](../Images/00002.jpg）（别忘了`**`是Ruby表示指数的方法）：
- en: '`i = (1+rate/12)**(12/12)-1`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`i = (1+rate/12)**(12/12)-1`'
- en: 'The next piece of information that we need is the annuity factor ![](../Images/00003.jpg).
    Basically, the *annuity factor* is the current value of $1 for each period of
    time. The *time* is received in months. So, the calculations are:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一项信息是年金因子 ![图片](../Images/00003.jpg)。基本上，*年金因子*是每个时间段内1美元的当前价值。*时间*以月份为单位。因此，计算如下：
- en: '`annuity = (1-(1/(1+i))**time)/i`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`annuity = (1-(1/(1+i))**time)/i`'
- en: Now that the annuity factor has been computed, monthly payments are really what
    we are after. A simple division of the loan by the annuity factor will reveal
    the final answer ![](../Images/00004.jpg). All that's left is some formatting
    to make the information easier to read. As with other programming languages, Ruby
    gives programmers the ability to specify how output should be formatted. In this
    case, for monetary values, I am interested in two decimal places for the cents
    in addition to the *integer*, or whole dollar, value ![](../Images/00005.jpg).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在年金因子已经计算出来，我们真正追求的是月付款额。将贷款金额除以年金因子就可以得到最终答案 ![图片](../Images/00004.jpg)。剩下的只是进行一些格式调整，以便更容易阅读信息。与其他编程语言一样，Ruby
    为程序员提供了指定输出格式的能力。在这种情况下，对于货币值，我感兴趣的是除了整数或整美元值之外，还有两位小数的分值 ![图片](../Images/00005.jpg)。
- en: Hacking the Script
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: One way to hack this script would be to give a variance of interest rates or
    loan amounts, so the output could display several possible monthly payments instead
    of just one—maybe +/-0.05 percent. Usually, when you are looking for a mortgage,
    you compare a lot of financial information. The more information you can present
    in one interface, the better the decision you can make.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵这个脚本的一种方法是为利率或贷款金额提供一些变动，这样输出就可以显示几个可能的月付款额，而不仅仅是其中一个——可能是±0.05%。通常，当你寻找抵押贷款时，你会比较大量的财务信息。你能在同一个界面上提供的信息越多，你做出的决定就越好。
