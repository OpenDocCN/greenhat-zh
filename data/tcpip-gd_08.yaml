- en: Part II-5. IP-RELATED FEATURE PROTOCOLS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分第5节。与IP相关的功能协议
- en: '[Chapter 28](ch28.html "Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL")'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第28章](ch28.html "第28章。IP网络地址转换（NAT）协议")'
- en: '[Chapter 29](ch29.html "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS")'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第29章](ch29.html "第29章。IP安全（IPsec）协议")'
- en: '[Chapter 30](ch30.html "Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE
    IP)")'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第30章](ch30.html "第30章。互联网协议移动支持（移动IP）")'
- en: The previous two parts thoroughly explored versions 4 and 6 of the Internet
    Protocol (IP). IP is a very capable protocol that provides the functionality necessary
    to address, package, and deliver information on TCP/IP internetworks. However,
    IP was intentionally designed to be simple, without a lot of bells and whistles.
    To deal with special needs, a number of other protocols have been created to enhance
    or expand on IP's capabilities. I call these *IP-related feature protocols*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前两部分彻底探讨了互联网协议（IP）的第四版和第六版。IP是一个非常强大的协议，它提供了在TCP/IP互联网上寻址、打包和传递信息所需的功能。然而，IP被有意设计得非常简单，没有很多花哨的功能。为了处理特殊需求，已经创建了许多其他协议来增强或扩展IP的功能。我称这些为*与IP相关的功能协议*。
- en: This part contains three chapters that provide complete explanations of three
    of the more important IP-related feature protocols. The first chapter describes
    *IP Network Address Translation (IP NAT or NAT)*, which allows private networks
    to be accessed on the Internet and IP addresses to be shared. The second chapter
    explores *IP Security (IPsec)*, a set of subprotocols that allows IP datagrams
    to be authenticated and/or encrypted. The third chapter covers the *Mobile IP*
    protocol, which corrects some of the problems associated with using TCP/IP with
    mobile hosts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含三个章节，提供了对三个更重要与IP相关的功能协议的完整解释。第一章描述了*IP网络地址转换（IP NAT或NAT）*，它允许私有网络在互联网上访问并共享IP地址。第二章探讨了*IP安全（IPsec）*，这是一组子协议，允许对IP数据报进行认证和/或加密。第三章涵盖了*移动IP*协议，它纠正了使用TCP/IP与移动主机相关的一些问题。
- en: This part assumes that you have a good understanding of the operation of IP,
    discussed in Parts II-3 and II-4.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分假设您已经很好地理解了IP的操作，这在第二部分的第3节和第4节中进行了讨论。
- en: Chapter 28. IP NETWORK ADDRESS TRANSLATION (NAT) PROTOCOL
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第28章。IP网络地址转换（NAT）协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: To help extend the life of the Internet Protocol version 4 (IPv4) addressing
    scheme while the newer IPv6 protocol is developed and deployed, other technologies
    have been developed. One of the most important of these is *IP Network Address
    Translation (NAT)*. This technology allows a small number of public IP addresses
    to be shared by a large number of hosts using private addresses. This essential
    work-around allows the global Internet to actually have far more hosts on it than
    its address space would normally support. At the same time, it provides some security
    benefits by making hosts more difficult to address directly by foreign machines
    on the public Internet.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在开发并部署新的IPv6协议的同时延长IPv4地址方案的寿命，已经开发了一些其他技术。其中最重要的之一是*IP网络地址转换（NAT）*。这项技术允许少量公网IP地址被大量使用私有地址的主机共享。这个基本的工作方案使得全球互联网实际上能够支持比其地址空间通常支持的更多主机。同时，它通过使主机更难以被公网上的外国机器直接寻址，提供了一些安全优势。
- en: In this chapter, I provide a description of the concepts behind IP NAT and an
    explanation of operation of IP NAT types. I begin with an overview of the protocol
    and discussion of its advantages and disadvantages. I describe the address terminology
    that you need to know in order to understand how NAT functions and the differences
    between various translation techniques. I explain the way that address mappings
    are performed and the difference between static and dynamic address mapping.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提供了IP NAT背后的概念描述和对IP NAT类型的操作解释。我首先概述了该协议及其优缺点，然后描述了您需要了解的地址术语，以便理解NAT的功能以及各种转换技术之间的差异。我解释了地址映射的执行方式以及静态和动态地址映射之间的区别。
- en: 'I then explain the operation of the four main types of NAT: unidirectional,
    bidirectional, port-based, and overlapping. I conclude with a bit more information
    on compatibility issues associated with NAT.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我解释了四种主要类型的NAT的操作：单向、双向、基于端口的和重叠的。我最后简要介绍了与NAT相关的兼容性问题。
- en: NAT was developed in large part to deal with the address shortage problem in
    IPv4, so it is associated and used with IPv4\. It is possible to implement an
    IPv6-compatible version of NAT, but address translation isn't nearly as important
    in IPv6, which was designed to give every TCP/IP device its own unique address.
    For this reason, in this chapter, I focus in on the use of NAT with IPv4.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NAT（网络地址转换）主要是为了解决IPv4地址短缺问题而开发的，因此它与IPv4相关联并一起使用。虽然可以实现IPv6兼容版本的NAT，但在IPv6中，地址转换并不像IPv4那样重要，因为IPv6的设计目的是为每个TCP/IP设备分配其唯一的地址。因此，在本章中，我主要关注NAT与IPv4的使用。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Incidentally, most people just call this technology* Network Address Translation
    *without the* IP. *However, this sounds to me rather generic, and since the version
    I''m discussing here is specific to IP, I prefer to make it clear that this is
    an IP feature. That said, for simplicity I often just say "NAT," too, since that''s
    shorter. I should also point out that there are quite a few people who don''t
    consider NAT to be a protocol in the strictest sense of the word*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺便说一下，大多数人只是称这种技术为*网络地址转换*，而不带*IP*。*然而，在我看来这听起来相当通用，而且由于我这里讨论的是特定于IP的版本，我更喜欢明确指出这是一个IP特性。话虽如此，为了简便起见，我也经常只说“NAT”，因为这样更简洁。我还应该指出，相当多的人并不认为NAT在严格意义上是一个协议*。'
- en: IP NAT Overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT概述
- en: 'The decision to make IP addresses only 32 bits long as part of the original
    design of IP led to a serious problem when the Internet exploded in popularity
    beyond anyone''s expectations: the exhaustion of the address space. Classless
    addressing helped make better use of the address space, and IPv6 was created to
    ensure that we will never run out of addresses again. However, classless addressing
    has only slowed the consumption of the IPv4 address space, and IPv6 has taken
    years to develop and will require years more to deploy.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将IP地址长度设置为32位作为IP原始设计的一部分，导致当互联网的普及程度超出任何人的预期时出现了一个严重问题：地址空间的耗尽。无类别寻址有助于更好地利用地址空间，IPv6的创建确保我们永远不会再次耗尽地址。然而，无类别寻址仅减缓了IPv4地址空间的消耗，IPv6的开发需要数年，部署也需要数年。
- en: 'The shortage of IP addresses promised to grow critical by the end of the 1990s
    unless some sort of solution was implemented until the transition to IPv6 was
    completed. Creative engineers on the Internet Engineering Task Force (IETF) were
    up to the challenge. They created a technique that would not only forestall the
    depletion of the address space, but could also be used to address the following
    two other growing issues in the mid- to late 1990s:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不实施某种解决方案直到IPv6过渡完成，IP地址的短缺预计将在20世纪90年代末变得至关重要。互联网工程任务组（IETF）上的创新工程师们接受了这一挑战。他们创造了一种技术，不仅能够延缓地址空间的耗尽，还可以用于解决20世纪90年代中期到后期出现的以下两个其他日益增长的问题：
- en: '**Increasing Cost of IP Addresses** As any resource grows scarce, it becomes
    more expensive. Even when IP addresses were available, it cost more to get a larger
    number from a service provider than a smaller number. It was desirable to conserve
    them not only for the sake of the Internet as a whole, but to save money.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP地址成本增加** 任何资源变得稀缺时，其成本就会增加。即使IP地址可用，从服务提供商那里获取大量地址的成本也比获取少量地址的成本高。不仅为了整个互联网的缘故，而且为了节省金钱，都有必要节约它们。'
- en: '**Growing Concerns over Security** As Internet use increased in the 1990s,
    more bad guys started using the network also. The more machines a company had
    directly connected to the Internet, the greater their potential exposure to security
    risks.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**对安全的担忧日益增加** 20世纪90年代，随着互联网的使用增加，更多的坏人开始使用网络。公司直接连接到互联网的机器越多，它们面临的安全风险就越大。'
- en: 'One solution to these problems was to set up a system whereby a company''s
    network was not connected directly to the Internet, but rather *indirectly*. Setting
    up a network this way is possible due to the following important characteristics
    of how most organizations use the Internet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法之一是建立一个系统，其中公司的网络不是直接连接到互联网，而是*间接连接*。由于以下重要特性，这种方式的网络设置是可能的，即大多数组织如何使用互联网：
- en: '**Most Hosts Are Client Devices** The Internet is client/server based, and
    the majority of hosts are clients. Client devices generally don''t need to be
    made publicly accessible. For example, when using your local PC to access the
    World Wide Web, you issue requests to servers and they respond back, but servers
    don''t have any reason to try to initiate contact with you. Clients, not servers,
    begin most correspondence, by definition.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**大多数主机是客户端设备** 互联网是基于客户端/服务器的，大多数主机是客户端。客户端设备通常不需要公开访问。例如，当使用你的本地PC访问万维网时，你向服务器发出请求，它们会做出回应，但服务器没有理由试图与你建立联系。客户端，而不是服务器，根据定义开始大多数通信。'
- en: '**Few Hosts Access the Internet Simultaneously** When you have a large number
    of hosts that are connected to the Internet on the same network, usually only
    a small number of those hosts are trying to access the Internet at any given time.
    It isn''t necessary to assume they will all need to access servers at once. Even
    while you actively browse the Web, you pause for a number of seconds to read information
    from time to time; you are only accessing the web server for the time it takes
    to perform a transaction.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**很少的主机同时访问互联网** 当你在同一网络上连接了大量的主机时，通常只有少数主机在任何给定时间试图访问互联网。没有必要假设他们都会同时需要访问服务器。即使你在积极浏览网页时，你也会时不时地停下来阅读信息；你只访问网络服务器进行交易所需的时间。'
- en: '**Internet Communications Are Routed** Communications between an organization''s
    network and the Internet go through a router, which acts as a control point for
    traffic flows.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网通信是路由的** 组织的网络与互联网之间的通信通过路由器进行，它充当流量流量的控制点。'
- en: The best way to explain why these attributes matter is to draw an analogy to
    how telephones are used an organization, because many of the same attributes apply
    there. Most of the telephones in a typical organization are used to let employees
    make calls out. Usually there is no need to have any way to call employees directly;
    instead, one system or person can handle all incoming calls. Only a few employees
    are ever making a call to the outside world at any given time. And all calls are
    routed through a central point that manages the telephone system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方式来解释为什么这些属性很重要，是通过类比组织如何使用电话来解释，因为许多相同的属性也适用于那里。在典型的组织中，大多数电话都是用来让员工打电话出去的。通常没有必要有直接调用员工的方式；相反，一个系统或一个人可以处理所有来电。在任何给定时间，只有少数员工会打电话给外部世界。所有电话都通过一个管理电话系统的中心点进行路由。
- en: For these reasons, to save money, organizations don't run separate public telephone
    lines to every employee's desk. Instead, they set up a telephone system whereby
    each employee gets an *extension*, which is basically a local telephone number
    valid only within the organization. A small number of outside lines is made available
    in a pool for employees to share, and the telephone system matches the inside
    extensions to the outside lines as needed. A voice mail system and human receptionist
    handle the routing of calls into the organization. (Yes, of course some companies
    have a direct mapping between extension numbers and real telephone numbers.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，为了节省金钱，组织不会为每个员工的办公桌运行独立的公共电话线路。相反，它们设置了一个电话系统，其中每个员工都得到一个*分机*，这基本上是一个只在组织内部有效的本地电话号码。一小部分外部线路以池的形式提供给员工共享，电话系统根据需要将内部分机与外部线路匹配。语音邮件系统和人工接待员处理来电的组织路由。是的，当然有些公司会在分机号码和真实电话号码之间进行直接映射。)
- en: A very similar technique can be used for connecting an organization's computers
    to the Internet. In TCP/IP networks, this technology was first formalized in RFC
    1631, "The IP Network Address Translator (NAT)," which was adopted in May 1994\.
    The word *translator* refers to the device (router) that implements NAT. More
    commonly, the technology as a whole is called *IP Network Address Translation*
    (*IP NAT* or *NAT*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个非常类似的技术来连接组织的计算机到互联网。在TCP/IP网络中，这项技术最初在1994年5月通过的RFC 1631，“IP网络地址转换器（NAT）”中得到了正式化。单词*转换器*指的是实现NAT的设备（路由器）。更常见的是，这项技术整体被称为*IP网络地址转换*（*IP
    NAT*或*NAT*）。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The document status of RFC 1631 is informational. This means that, technically,
    IP NAT is not an official Internet standard*.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*RFC 1631的文档状态为信息性。这意味着，技术上讲，IP NAT不是一个官方的互联网标准*。'
- en: A basic implementation of NAT involves setting up an organization's internal
    network using one of the private addressing ranges set aside for local IP networks.
    One or more public (Internet) addresses are also assigned to the organization
    as well, and one or more NAT-capable routers are installed between the local network
    and the public Internet. The public IP addresses are like outside lines in the
    telephone system, and the private addresses are like internal extensions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: NAT的基本实现涉及使用为本地IP网络预留的私有地址范围之一来设置组织的内部网络。组织还会分配一个或多个公共（互联网）地址，并在本地网络和公共互联网之间安装一个或多个具有NAT功能的路由器。公共IP地址就像电话系统中的外线，而私有地址就像内部分机。
- en: The NAT router plays the role of telephone system computer and receptionist.
    It maps internal extensions to outside lines as needed, and also handles "incoming
    calls" when required. It does this by not just routing IP datagrams, but also
    by modifying them as needed, thereby translating addresses in datagrams from the
    private network into public addresses for transmission on the Internet, and back
    again.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: NAT路由器扮演着电话系统计算机和接待员的角色。它根据需要将内部分机映射到外线，并在需要时处理“来电”。它通过不仅路由IP数据报，而且在需要时修改它们来实现这一点，从而将数据报中的地址从私有网络转换为用于在互联网上传输的公共地址，然后再转换回来。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *IP Network Address Translation* (*IP NAT* or *NAT*) is a technique
    that allows an organization to set up a network using private addresses, while
    still allowing for communication on the public Internet. A NAT-capable router
    translates private to public addresses and vice versa as needed. This allows a
    small number of public IP addresses to be shared among a large number of devices
    and provides other benefits as well, but it also has some drawbacks.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *IP网络地址转换* (*IP NAT* 或 *NAT*) 是一种技术，允许组织使用私有地址建立网络，同时仍然允许在公共互联网上进行通信。具有NAT功能的路由器根据需要将私有地址转换为公共地址，反之亦然。这允许少量公共IP地址在大量设备之间共享，并提供其他好处，但也存在一些缺点。'
- en: Over time, newer versions of NAT have also been created. They solve other problems
    or provide additional capabilities. *Port-Based NAT* allows for the sharing of
    even more hosts on a limited number of IP addresses by letting two or more devices
    share one IP address at a time. So-called *twice NAT* helps with the implementation
    of virtual private networks (VPNs) by translating both source and destination
    addresses in both incoming and outgoing datagrams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，也创建了NAT的新版本。它们解决了其他问题或提供了额外的功能。*基于端口的NAT* 通过让两个或多个设备每次共享一个IP地址，允许在有限的IP地址上共享更多的主机。所谓的*双重NAT*
    通过在传入和传出数据报中转换源地址和目标地址，有助于虚拟专用网络（VPN）的实施。
- en: Advantages of IP NAT
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP NAT的优点
- en: 'NAT is one of those technologies that has a long list of advantages and disadvantages.
    This means it can be extremely useful in a variety of scenarios, but also problematic
    in others. The main advantages are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NAT是那些具有长串优缺点列表的技术之一。这意味着它在各种场景中可能极其有用，但在其他情况下也可能有问题。主要优点如下：
- en: '**Public IP Address Sharing** A large number of hosts can share a small number
    of public IP addresses. This saves money and also conserves IP address space.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共IP地址共享** 大量主机可以共享少量公共IP地址。这不仅可以节省费用，还可以节约IP地址空间。'
- en: '**Easier Expansion** Since local network devices are privately addressed and
    a public IP address isn''t needed for each one, it is easy to add new clients
    to the local network.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**更容易扩展** 由于本地网络设备使用私有地址，并且不需要为每个设备分配公共IP地址，因此很容易将新客户端添加到本地网络。'
- en: '**Greater Local Control** Administrators get all the benefits of control that
    come with a private network, but can still connect to the Internet.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**更大的本地控制** 管理员可以获得与私有网络相关的所有控制好处，但仍可以连接到互联网。'
- en: '**Greater Flexibility in Internet Service Provider (ISP) Service** Changing
    the organization''s ISP is easier, because only the public addresses change. It
    isn''t necessary to renumber all the client machines on the network.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**在互联网服务提供商（ISP）服务方面的更大灵活性** 更改组织的ISP更容易，因为只有公共地址会改变。不需要重新编号网络上的所有客户端计算机。'
- en: '**Increased Security** The NAT translation represents a level of indirection.
    Thus, it automatically creates a type of firewall between the organization''s
    network and the public Internet. It is more difficult for any client devices to
    be accessed directly by someone malicious because the clients don''t have publicly
    known IP addresses.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强安全性** NAT转换代表了一种间接层次。因此，它自动在组织的网络和公共互联网之间创建了一种防火墙。由于客户端没有公开的IP地址，恶意用户直接访问任何客户端设备变得更加困难。'
- en: '**(Mostly) Transparent** NAT implementation is mostly transparent, because
    the changes take place in one or perhaps a few routers. The dozens or hundreds
    of hosts themselves don''t need to be changed.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**（大部分）透明** NAT实现主要是透明的，因为更改发生在一个或几个路由器上。成百上千的主机本身不需要更改。'
- en: Disadvantages of IP NAT
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP NAT的缺点
- en: 'The previously listed advantages are all good reasons to use NAT, but there
    are drawbacks to the technique as well:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的先前优点都是使用NAT的好理由，但这项技术也有其缺点：
- en: '**Complexity** NAT represents one more complexity in terms of setting up and
    managing the network. It also makes troubleshooting more confusing due to address
    substitutions.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性** NAT在设置和管理网络方面代表了一种额外的复杂性。它还由于地址替换而使得故障排除更加复杂。'
- en: '**Problems Due to Lack of Public Addresses** Certain functions won''t work
    properly due to lack of a real IP address in the client host machines.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**由于缺乏公网地址的问题** 由于客户端主机机器缺乏真实的IP地址，某些功能可能无法正常工作。'
- en: '**Compatibility Problems with Certain Applications** I said earlier that NAT
    was only mostly transparent. There are, in fact, compatibility issues with certain
    applications that arise because NAT tinkers with the IP header fields in datagrams
    but not in the application data. This means tools like the File Transfer Protocol
    (FTP; see [Chapter 72](ch72.html "Chapter 72. FILE TRANSFER PROTOCOL (FTP)")),
    which pass IP addresses and port numbers in commands, must be specially handled,
    and some applications may not work.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**与某些应用的兼容性问题** 我之前提到NAT只是大部分透明。实际上，由于NAT在数据报中的IP头部字段中而不是在应用数据中篡改，某些应用存在兼容性问题。这意味着像文件传输协议（FTP；见[第72章](ch72.html
    "第72章. 文件传输协议 (FTP)"))这样的工具，在命令中传递IP地址和端口号，必须特别处理，并且某些应用可能无法工作。'
- en: '**Problems with Security Protocols** Protocols like IPsec are designed to detect
    modifications to headers and commonly balk at the changes that NAT makes, since
    they cannot differentiate those changes from malicious datagram hacking. It is
    still possible to combine NAT and IPsec, but this becomes more complicated.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**与安全协议的问题** 如IPsec这样的协议旨在检测头部修改，并且通常对NAT所做的更改表示反对，因为它们无法区分这些更改和恶意数据报黑客行为。仍然可以将NAT和IPsec结合起来，但这变得更加复杂。'
- en: '**Poor Support for Client Access** The lack of a public IP address for each
    client is a double-edged sword; it protects against hackers trying to access a
    host, but it also makes it difficult for legitimate access to clients on the local
    network. Peer-to-peer applications are harder to set up, and something like an
    organizational website (accessed from the Internet as a whole) usually needs to
    be set up without NAT.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**对客户端访问的支持不足** 每个客户端缺乏公网IP地址是一把双刃剑；它保护了主机免受黑客尝试访问，但同时也使得对本地网络中客户端的合法访问变得困难。对等应用（P2P）的设置更加困难，而像组织网站（作为整体从互联网访问）通常需要在没有NAT的情况下设置。'
- en: '**Performance Reduction** Each time a datagram transitions between the private
    network and the Internet, an address translation is required. In addition, other
    work must be done as well, such as recalculating header checksums. Each individual
    translation takes little effort, but when you add it up, you are giving up some
    performance.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能降低** 每次数据报在私有网络和互联网之间转换时，都需要进行地址转换。此外，还需要执行其他工作，例如重新计算头部校验和。每次单独的转换需要很少的努力，但当你加起来时，你正在放弃一些性能。'
- en: Some of these cancel out some of the benefits of certain items in the previous
    list. However, many organizations feel that the advantages outweigh the disadvantages,
    especially if they use the Internet in primarily a client/server fashion, as most
    do. For this reason, NAT has become quite popular. However, bear in mind that
    the main problem that led to NAT is lack of address space. IPv6 fixes this problem,
    while NAT merely finds a clever work-around for it. For this reason, many people
    consider NAT a kludge. Once IPv6 is deployed, it will no longer be needed, and
    some folks don't like it even for IPv4\. On the other hand, some feel its other
    benefits make it worthy of consideration even in IPv6.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些可能会抵消前述列表中某些项目的某些好处。然而，许多组织认为其优点超过了缺点，特别是如果他们主要以客户端/服务器模式使用互联网，就像大多数人一样。因此，NAT已经变得非常流行。然而，请记住，导致NAT的主要问题是地址空间不足。IPv6解决了这个问题，而NAT只是找到了一个巧妙的解决方案。因此，许多人认为NAT是一种kludge。一旦部署IPv6，它将不再需要，有些人甚至不喜欢它用于IPv4。另一方面，有些人认为它的其他好处使其即使在IPv6中也有考虑的价值。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A* kludge (*or* kluge) *is something that is used to address a problem in
    an inelegant way, like hammering a nail using the side of an adjustable wrench*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* kludge (*或* kluge) *是一种以不优雅的方式解决问题的方法，就像用可调扳手的侧面敲钉子一样。'
- en: IP NAT Address Terminology
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT地址术语
- en: As its name clearly indicates, IP NAT is all about the *translation* of IP addresses.
    When datagrams pass between the private network of an organization and the public
    Internet, the NAT router changes one or more of the addresses in these datagrams.
    This translation means that every transaction in a NAT environment involves not
    just a source address and a destination address, but also potentially multiple
    addresses for each of the source and destination.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称明显所示，IP NAT完全是关于IP地址的*转换*。当数据报在组织的私有网络和公共互联网之间传递时，NAT路由器会更改这些数据报中的一个或多个地址。这种转换意味着在NAT环境中，每笔交易不仅涉及源地址和目的地址，还可能涉及源和目的地的多个地址。
- en: In order to make clearer the explanation of how NAT operates, several special
    designations have been developed to refer to the different types of addresses
    that can be found in an IP datagram when NAT is used. Unfortunately, the terminology
    used for addressing in NAT can be confusing, because it's hard to visualize what
    the differences are between the (often similar-sounding) names. However, without
    knowing what these addresses mean, a proper understanding of NAT operation is
    impossible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地解释NAT的工作原理，已经开发了一些特殊名称来指代在使用NAT时可以在IP数据报中找到的不同类型的地址。不幸的是，NAT中使用的地址术语可能会令人困惑，因为很难想象（通常听起来相似）名称之间的区别。然而，如果不了解这些地址的含义，就无法正确理解NAT的操作。
- en: 'The first way that addresses are differentiated is based on where the device
    is in the network that the address is referring to, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 地址区分的第一种方式是基于设备在网络中的位置，如下所示：
- en: '**Inside Address** Any device on the organization''s private network that is
    using NAT is said to be on the inside network. Thus, any address that refers to
    a device on the local network in any form is called an *inside address*.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部地址** 组织私有网络中任何使用NAT的设备都被称为内部网络。因此，任何以任何形式指向本地网络设备的地址都称为*内部地址*。'
- en: '**Outside Address** The public Internet—that is, everything outside the local
    network—is considered the outside network. Any address that refers to a public
    Internet device is an *outside address*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部地址** 公共互联网——即本地网络之外的一切——被认为是外部网络。任何指向公共互联网设备的地址都是*外部地址*。'
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**KEY CONCEPT** In NAT, the terms *inside* and *outside* are used to identify
    the location of devices. *Inside addresses* refer to devices on the organization''s
    private network. *Outside addresses* refer to devices on the public Internet.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在NAT中，术语*内部*和*外部*用于识别设备的位置。*内部地址*指的是组织私有网络中的设备。*外部地址*指的是公共互联网上的设备。'
- en: 'An inside device always has an inside address; an outside device always has
    an outside address. However, there are two different ways of addressing either
    an inside or an outside device, depending on the part of the network in which
    the address appears in a datagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 内部设备始终具有内部地址；外部设备始终具有外部地址。然而，根据地址在数据报中出现的网络部分，有两种不同的方式来指定内部或外部设备：
- en: '**Local Address** This term describes an address that appears in a datagram
    on the inside network, *whether it refers to an inside or outside address*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地地址** 这个术语描述的是出现在内部网络数据报上的地址，*无论它是指内部地址还是外部地址*。'
- en: '**Global Address** This term describes an address that appears in a datagram
    on the outside network, again *whether it refers to an inside or outside address*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局地址** 这个术语描述的是出现在外部网络数据报上的地址，再次强调，无论它是指内部地址还是外部地址。'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In NAT, the terms *local* and *global* are used to indicate
    in what network a particular address appears. *Local addresses* are used on the
    organization''s private network (whether to refer to an inside device or an outside
    device). *Global addresses* are used on the public Internet (again, whether referring
    to an inside or outside device).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在NAT中，术语*本地*和*全局*用来指示特定地址出现在哪个网络中。*本地地址*用于组织的私有网络中（无论是引用内部设备还是外部设备）。*全局地址*用于公共互联网上（再次强调，无论是引用内部设备还是外部设备）。'
- en: 'This is a bit confusing, so I will try to explain further. The NAT translating
    router has the job of interfacing the inside network to the outside network (the
    Internet). Inside devices need to be able to talk to outside devices and vice
    versa, but inside devices can use only addressing consistent with the local network-addressing
    scheme. Similarly, outside devices cannot use local addressing. Thus, both inside
    and outside devices can be referred to with local or global address versions.
    This yields four different specific address types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人困惑，所以我将尝试进一步解释。NAT转换路由器负责连接内部网络与外部网络（互联网）。内部设备需要能够与外部设备通信，反之亦然，但内部设备只能使用与本地网络寻址方案一致的地址。同样，外部设备不能使用本地地址。因此，内部和外部设备都可以用本地或全局地址版本来引用。这产生了四种不同的特定地址类型：
- en: '**Inside Local Address** An address of a device on the local network, expressed
    using its normal local device representation. So, for example, if you had a client
    on a network using the 10.0.0.0 private address block and assigned it address
    10.0.0.207, this would be its *inside local* address.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部本地地址** 使用其正常的本地设备表示法表示的本地网络设备地址。例如，如果你有一个使用10.0.0.0私有地址块并分配地址10.0.0.207的客户端，这将是其*内部本地*地址。'
- en: '**Inside Global Address** This is a global, publicly routable IP address that''s
    used to represent an inside device to the outside world. In a NAT configuration,
    *inside global* addresses are those real IP addresses assigned to an organization
    for use by the NAT router. Let''s say that device 10.0.0.207 wants to send an
    HTTP request to an Internet server located at address 204.51.16.12\. It forms
    the datagram using 10.0.0.207 as the source address. However, if this datagram
    is sent out to the Internet as is, the server cannot reply back because 10.0.0.207
    is not a publicly routable IP address. So the NAT router will translate 10.0.0.207
    in the datagram into one of the organization''s registered IP addresses, let''s
    say, 194.54.21.10\. This is the *inside global* address that corresponds to 10.0.0.207\.
    It will be used as the destination when the server sends its HTTP response. Note
    that, in some situations, the inside local address and outside local address may
    be the same.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局地址** 这是一个全局的、可公开路由的IP地址，用于在内部设备与外部世界之间进行表示。在NAT配置中，*内部全局*地址是指分配给组织并由NAT路由器使用的实际IP地址。假设设备10.0.0.207想要向位于地址204.51.16.12的互联网服务器发送一个HTTP请求。它使用10.0.0.207作为源地址来形成数据报。然而，如果这个数据报以原样发送到互联网，服务器无法回复，因为10.0.0.207不是一个公开可路由的IP地址。因此，NAT路由器将数据报中的10.0.0.207转换成组织注册的IP地址之一，比如194.54.21.10。这是与10.0.0.207相对应的*内部全局*地址。当服务器发送其HTTP响应时，它将用作目标地址。请注意，在某些情况下，内部本地地址和外部本地地址可能是相同的。'
- en: '**Outside Global Address** An address of an external (public Internet) device
    as it is referred to on the global Internet. This is basically a regular, publicly
    registered address of a device on the Internet. In the previous example, 204.51.16.12
    is an *outside global* address of a public server.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部全局地址** 这是外部（公共互联网）设备在全局互联网上的引用地址。这基本上是互联网上设备的常规、公开注册的地址。在先前的例子中，204.51.16.12是一个公共服务器的*外部全局*地址。'
- en: '**Outside Local Address** An address of an external device as it is referred
    to by devices on the local network. In some situations, this may be identical
    to the *outside global* address of that outside device.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部本地地址** 外部设备在本地网络设备中引用的地址。在某些情况下，这可能与该外部设备的**外部全局**地址相同。'
- en: 'Phew, it''s still confusing, isn''t it? Let''s try another way of looking at
    this. Of these four addresses, two types are the addresses as they are known natively
    by either an inside or outside device, while the other two are translated addresses.
    Here is a summary:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸一下，这仍然很困惑，不是吗？让我们尝试另一种看待这个问题的方式。在这四个地址中，两种类型是内部或外部设备本地产生的地址，而另外两种是转换地址。以下是一个总结：
- en: '**Inside Device Designations** For an inside device, the *inside local* address
    is its normal, or native, address. The *inside global* address is a translated
    address used to represent the inside device on the outside network, when necessary.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部设备标识** 对于内部设备，其**内部本地**地址是其正常或本地地址。其**内部全局**地址是一个用于在必要时在外部网络上表示内部设备的转换地址。'
- en: '**Outside Device Designations** For an outside device, the *outside global*
    address is its normal, or native, address. The *outside local* address is a translated
    address used to represent the outside device on the inside network, when necessary.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部设备标识** 对于外部设备，其**外部全局**地址是其正常或本地地址。其**外部本地**地址是一个用于在必要时在内部网络上表示外部设备的转换地址。'
- en: So what NAT does then is translate the identity of either inside or outside
    devices from local representations to global representations and vice versa. Which
    addresses are changed and how will depend on the specific type of NAT employed.
    For example, in traditional NAT, inside devices refer to outside devices using
    their proper (global) representation, so the outside global and outside local
    addresses of these outside devices are the same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，NAT所做的是将内部或外部设备的标识从本地表示转换为全局表示，反之亦然。地址如何更改以及具体类型取决于所使用的NAT类型。例如，在传统NAT中，内部设备使用它们的正确（全局）表示来引用外部设备，因此这些外部设备的全局外部和本地外部地址是相同的。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** A NAT router translates *local* addresses to *global* ones
    and vice versa. Thus, an *inside local* address is translated to an *inside global*
    address (and vice versa) and an *outside local* address is translated to an *outside
    global* address (and vice versa).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** NAT路由器将**本地**地址转换为**全局**地址，反之亦然。因此，一个**内部本地**地址被转换为**内部全局**地址（反之亦然），一个**外部本地**地址被转换为**外部全局**地址（反之亦然）。'
- en: 'And after all that, it''s still confusing! One of the big problems is that
    the words *inside* and *local* are somewhat synonymous, as are *outside* and *global*,
    yet they mean different things in NAT. And the typical paradox in trying to explain
    networking concepts rears its ugly head here again: I wanted to define these addresses
    to make describing NAT operation easier, but find myself wanting to use an example
    of NAT operation to clarify how the addresses are used.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些之后，仍然很困惑！一个很大的问题是，“内部”和“本地”这两个词在某种程度上是同义的，同样，“外部”和“全局”也是，但在NAT中它们的意思却不同。在试图解释网络概念时，典型的悖论再次显现：我想定义这些地址来使描述NAT操作更容易，但发现自己需要用NAT操作的例子来澄清地址的使用方式。
- en: Even after writing this material I find these terms confusing, so I created
    [Figure 28-1](ch28s02.html#ip_network_address_translation_nat_termi "Figure 28-1. IP
    Network Address Translation (NAT) terminology Hopefully this diagram will help
    you to better understand the whole "inside/outside/local/global" thing."), which
    shows this same terminology in graphical form and may be of some help. That diagram
    is also used as a template for the illustrations of each of the different types
    of NAT in the rest of this chapter. As you read about NAT operation, look back
    here if you want to double-check the meaning of address types. Don't get discouraged
    if it takes a couple of times to get the addresses straight.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使写完这些材料后，我发现这些术语仍然令人困惑，所以我创建了[图28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "图28-1. IP网络地址转换(NAT)术语。希望这个图表能帮助你更好地理解整个“内部/外部/本地/全局”的概念。")，它以图形形式展示了这些术语，可能有所帮助。该图表也用作本章其余部分不同类型NAT插图模板。在阅读关于NAT操作的内容时，如果你想要再次检查地址类型，请回到这里。如果需要几次才能弄清楚地址，不要气馁。
- en: '![IP Network Address Translation (NAT) terminology Hopefully this diagram will
    help you to better understand the whole "inside/outside/local/global" thing.](httpatomoreillycomsourcenostarchimages287903.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![IP网络地址转换（NAT）术语 希望这个图表能帮助你更好地理解整个“内部/外部/本地/全局”的概念。](httpatomoreillycomsourcenostarchimages287903.png.jpg)'
- en: Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this
    diagram will help you to better understand the whole "inside/outside/local/global"
    thing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-1. IP网络地址转换（NAT）术语。希望这个图表能帮助你更好地理解整个“内部/外部/本地/全局”的概念。
- en: IP NAT Static and Dynamic Address Mappings
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT静态和动态地址映射
- en: NAT allows you to connect a private (inside) network to a public (outside) network
    such as the Internet by using an address translation algorithm implemented in
    a router that connects the two. Each time a NAT router encounters an IP datagram
    that crosses the boundary between the two networks, it must translate addresses
    as appropriate. But how does it know what to translate and what to use for the
    translated address?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NAT允许你通过在连接两个网络的路由器中实现地址转换算法，将私有（内部）网络连接到公共（外部）网络，如互联网。每次NAT路由器遇到跨越两个网络边界的IP数据报时，它都必须适当地转换地址。但它如何知道要转换什么以及使用什么作为转换地址呢？
- en: The NAT software in the router must maintain a *translation table* to tell it
    how to operate. The translation table contains information that maps the *inside
    local* addresses of internal devices (their regular addresses) to *inside global*
    address representations (the special public addresses used for external communication).
    It may also contain mappings between *outside global* addresses and *outside local*
    addresses for inbound transactions, if appropriate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器中的NAT软件必须维护一个*转换表*，以告知其如何操作。转换表包含将内部设备（它们的常规地址）的*内部本地*地址映射到*内部全局*地址表示（用于外部通信的特殊公共地址）的信息。如果适当，它还可能包含*外部全局*地址和*外部本地*地址之间的映射，用于入站交易。
- en: 'There are two basic ways that entries can be added to the NAT translation table:
    statically or dynamically.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 向NAT转换表中添加条目的两种基本方式是：静态或动态。
- en: Static Mappings
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态映射
- en: A static mapping represents a permanent, fixed relationship defined between
    a *global* and a *local* representation of the address of either an *inside* or
    an *outside* device. For example, you can use a static translation if you want
    the internal device with an *inside local* address of 10.0.0.207 to *always* use
    the *inside global* address of 194.54.21.10\. Whenever 10.0.0.027 initiates a
    transaction with the Internet, the NAT router will replace that address with 194.54.21.10.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 静态映射表示在*全局*和*本地*地址表示之间定义的永久、固定关系，无论是*内部*还是*外部*设备的地址。例如，如果你想使具有*内部本地*地址10.0.0.207的内部设备始终使用*内部全局*地址194.54.21.10，你可以使用静态转换。每当10.0.0.027与互联网发起交易时，NAT路由器都会将此地址替换为194.54.21.10。
- en: Dynamic Mappings
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态映射
- en: With dynamic mapping, *global* and *local* address representations are generated
    automatically by the NAT router, which is used as needed and then discarded. The
    most common way that this is employed is in allowing a *pool* of *inside global*
    addresses to be shared by a large number of *inside* devices.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态映射中，*全局*和*本地*地址表示由NAT路由器自动生成，按需使用后即丢弃。这种用法最常见的方式是允许一个*内部全局*地址池被大量*内部*设备共享。
- en: For example, say you were using dynamic mapping with a pool of *inside global*
    addresses available from 194.54.21.1 through 194.54.21.20\. When 10.0.0.207 sent
    a request to the Internet, it would not automatically have its source address
    replaced by 194.54.21.10\. One of the 20 addresses in the pool would be chosen
    by the NAT router. The router would then watch for replies back using that address
    and translate them back to 10.0.0.207\. When the session was completed, it would
    discard the entry to return the *inside global* address to the pool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在使用动态映射，并且有一个从194.54.21.1到194.54.21.20的*内部全局*地址池。当10.0.0.207向互联网发送请求时，它的源地址不会自动被替换为194.54.21.10。NAT路由器会从池中的20个地址中选择一个。然后，路由器会监视使用该地址返回的回复，并将它们转换回10.0.0.207。当会话完成后，它会丢弃条目，将*内部全局*地址返回到池中。
- en: Choosing Between Static and Dynamic Mapping
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在静态和动态映射之间进行选择
- en: The trade-offs between static and dynamic NAT mappings are pretty much the same
    as they always are when the choice is between static and dynamic. For example,
    the same issues arises in Address Resolution Protocol (ARP) caching; see [Chapter 13](ch13.html
    "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS RESOLUTION PROTOCOL (ARP)").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态NAT映射之间的权衡与静态和动态之间的选择时几乎总是相同的。例如，在地址解析协议（ARP）缓存中也会出现相同的问题；参见[第13章](ch13.html
    "第13章。地址解析和TCP/IP地址解析协议（ARP）")。
- en: Static mappings are permanent and therefore ideal for devices that need to be
    always represented with the same public address on the outside network. They may
    also be used to allow inbound traffic to a particular device; that is, they can
    be used for transactions initiated on the public network that send to a special
    server on the inside network. However, they require manual setup and maintenance,
    and they don't allow IP sharing on the internal network.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 静态映射是永久的，因此非常适合需要在外部网络上始终以相同的公共地址表示的设备。它们也可以用来允许特定设备的入站流量；也就是说，它们可以用于在公共网络上发起的交易，这些交易发送到内部网络上的特殊服务器。然而，它们需要手动设置和维护，并且不允许在内部网络上共享IP地址。
- en: Dynamic mapping is normally used for regular clients in order to facilitate
    public IP address sharing—a prime goal of most NAT implementations. It is more
    complicated than static mapping, but once you set it up, it's automatic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 动态映射通常用于常规客户端，以便促进公共IP地址的共享——这是大多数NAT实现的主要目标。它比静态映射更复杂，但一旦设置好，就会自动进行。
- en: It is possible to mix dynamic and static mapping on the same system, of course.
    You can designate certain devices that are statically mapped and let the rest
    use dynamic mapping. You just have to make sure that the static mappings don't
    overlap with the pool used for dynamic assignment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以在同一系统上混合动态和静态映射。你可以指定某些静态映射的设备，其余的则使用动态映射。你只需确保静态映射不会与用于动态分配的池重叠。
- en: Incidentally, another way you can perform dynamic mapping of global and local
    addressing is through domain name resolution using the Domain Name System (DNS;
    see [Chapter 52](ch52.html "Chapter 52. DOMAIN NAME SYSTEM (DNS) OVERVIEW, FUNCTIONS,
    AND CHARACTERISTICS")). This is particularly common when external devices access
    internal hosts using bidirectional NAT (inbound transactions). Since hosts on
    the public Internet know nothing about the organization's private network, they
    issue a request for the DNS name of the device they want to access. This causes
    the generation of a NAT translation entry that maps the inside local public address
    of the host to an inside global address for use by those outside the network.
    See the description of bidirectional NAT later in this chapter for more details
    on how this works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，你还可以通过使用域名系统（DNS；参见[第52章](ch52.html "第52章。域名系统（DNS）概述、功能和特性")）进行域名解析来执行全局和本地地址的动态映射。这在外部设备使用双向NAT（入站事务）访问内部主机时尤其常见。由于公共互联网上的主机对组织的私有网络一无所知，它们会发出请求以获取他们想要访问的设备的DNS名称。这会导致生成一个NAT转换条目，将主机的内部本地公共地址映射到内部全局地址，以便网络外部的用户使用。关于双向NAT的工作原理的更多细节，请参见本章后面的描述。
- en: IP NAT Unidirectional (Traditional/Outbound) Operation
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT单向（传统/出站）操作
- en: Now it's time to get down to the nitty gritty of how it works. There are many
    different flavors of NAT, and four common ones are covered in this chapter. It
    makes sense to start by looking at the original variety of NAT described in RFC
    1631\. This is the simplest NAT method, and therefore the easiest one to explain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解它是如何工作的了。NAT有许多不同的版本，本章涵盖了四种常见的版本。从RFC 1631中描述的原始NAT版本开始看是有意义的。这是最简单的NAT方法，因此也是最容易解释的。
- en: NAT was designed to allow hosts on a private network to share public IP addresses
    in accessing an Internet. Since most hosts are clients that initiate transactions,
    NAT was designed under the assumption that a client/server request/response communication
    would begin with a datagram sent from the *inside* network to the *outside*. For
    this reason, this first type of NAT is sometimes called *unidirectional* or *outbound*
    NAT. Since it is the oldest flavor, it is also now called *traditional* NAT to
    differentiate it from newer varieties.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: NAT被设计为允许私有网络上的主机在访问互联网时共享公网IP地址。由于大多数主机是发起事务的客户端，NAT是在假设客户端/服务器请求/响应通信将以从*内部*网络发送到*外部*的数据报开始的情况下设计的。因此，这种NAT类型有时被称为*单向*或*出站*NAT。由于它是最古老的版本，现在也被称为*传统*NAT，以区分较新的类型。
- en: To show how unidirectional NAT works, I will use an example. Let's assume the
    inside network has 250 hosts that use private (inside local) addresses from the
    10.0.0.0/8 address range (which I selected because it has small numbers!). These
    hosts use dynamic NAT sharing a pool of 20 inside global addresses from 194.54.21.1
    through 194.54.21.20.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示单向NAT的工作原理，我将使用一个例子。假设内部网络有250个主机，它们使用10.0.0.0/8地址范围内的私有（内部本地）地址（我选择这个范围是因为数字较小！）。这些主机使用动态NAT，共享从194.54.21.1到194.54.21.20的20个内部全局地址。
- en: In this example, device 10.0.0.207 wants to access the World Wide Web server
    at public address 204.51.16.12\. [Table 28-1](ch28s04.html#operation_of_unidirectional_traditional_
    "Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT") shows the
    four basic steps that are involved in this (simplified) transaction. I did this
    in table form so I could show you explicitly what happens to the addresses in
    both the request datagram (in steps 1 and 2) and the response datagram (steps
    3 and 4). I have also highlighted the translated address values for clarity, and
    provided [Figure 28-2](ch28s04.html#operation_of_unidirectional_tradit-id001 "Figure 28-2. Operation
    of unidirectional (traditional/outbound) NAT You can see the four steps in this
    process by following the steps in clockwise order. Translated addresses are shown
    in bold. Refer to Table 28-1 and Figure 28-1 for an explanation of the four address
    types."), which shows the process graphically.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，设备10.0.0.207想要访问公网地址204.51.16.12上的万维网服务器。[表28-1](ch28s04.html#operation_of_unidirectional_traditional_
    "表28-1. 单向（传统/出站）NAT的操作")展示了在这个（简化）事务中涉及的四个基本步骤。我将其以表格形式呈现，以便明确展示请求数据报（步骤1和2）和响应数据报（步骤3和4）中的地址发生了什么变化。我还为了清晰起见，突出了翻译后的地址值，并提供了[图28-2](ch28s04.html#operation_of_unidirectional_tradit-id001
    "图28-2. 单向（传统/出站）NAT的操作 通过按照顺时针顺序跟随步骤，你可以看到这个过程中的四个步骤。翻译后的地址以粗体显示。请参阅表28-1和图28-1以了解四种地址类型的解释。")，它以图形方式展示了这个过程。
- en: Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-1. 单向（传统/出站）NAT的操作
- en: '| Step # | Description | Datagram Type | Datagram Source Address | Datagram
    Destination Address |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 步骤编号 | 描述 | 数据报类型 | 数据报源地址 | 数据报目的地址 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | **Inside Client Generates Request and Sends to NAT Router**: Device 10.0.0.207
    generates an HTTP request that is eventually passed down to IP and encapsulated
    in an IP datagram. The source address is itself, 10.0.0.207, and the destination
    is 204.51.16.12\. The datagram is sent to the NAT-capable router that connects
    the organization''s internal network to the Internet. | Request (from inside client
    to outside server) | 10.0.0.207 (inside local) | 204.51.16.12 (outside local)
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **内部客户端生成请求并发送到NAT路由器**：设备10.0.0.207生成一个HTTP请求，最终传递到IP层并封装在IP数据报中。源地址是自身，10.0.0.207，目的地是204.51.16.12。数据报被发送到能够连接组织内部网络到互联网的NAT路由器。
    | 请求（从内部客户端到外部服务器） | 10.0.0.207（内部本地） | 204.51.16.12（外部本地） |'
- en: '| 2 | **NAT Router Translates Source Address and Sends to Outside Server**:
    The NAT router realizes that 10.0.0.207 is an *inside local* address and knows
    it must substitute an *inside global* address in order to let the public Internet
    destination respond. It consults its pool of addresses and sees the next available
    one is 194.54.21.11\. It changes the source address in the datagram from 10.0.0.207
    to 194.54.21.11\. The destination address is not translated in traditional NAT.
    In other words, the *outside local* address and *outside global* address are the
    same.The NAT router puts the mapping from 10.0.0.207 to 194.54.21.11 into its
    translation table. It sends out the modified datagram, which is eventually routed
    to the server at 204.51.16.12. |   | 194.54.21.11 (inside global) | 204.51.16.12
    (outside global) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **NAT 路由器转换源地址并发送到外部服务器**：NAT 路由器意识到 10.0.0.207 是一个 *内部本地* 地址，并且知道它必须替换一个
    *内部全局* 地址，以便让公共互联网目标做出响应。它查阅其地址池并看到下一个可用的地址是 194.54.21.11。它将数据报中的源地址从 10.0.0.207
    更改为 194.54.21.11。在传统 NAT 中，目标地址不会被转换。换句话说，*外部本地* 地址和 *外部全局* 地址是相同的。NAT 路由器将其从
    10.0.0.207 到 194.54.21.11 的映射放入其转换表中。它发送修改后的数据报，该数据报最终被路由到 204.51.16.12 的服务器。
    |   | 194.54.21.11 (内部全局) | 204.51.16.12 (外部全局) |'
- en: '| 3 | **Outside Server Generates Response and Sends Back to NAT Router**: The
    server at 204.51.16.12 generates an HTTP response. It has no idea that NAT was
    involved; it sees 194.54.21.11 in the request sent to it, so that''s where it
    sends back the response. It is then routed back to the original client''s NAT
    router. | Response (from outside server to inside client) | 204.51.16.12 (outside
    global) | 194.54.21.11 (inside global) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **外部服务器生成响应并发送回 NAT 路由器**：204.51.16.12 的服务器生成一个 HTTP 响应。它不知道 NAT 是否被涉及；它看到发送给它的请求中包含
    194.54.21.11，因此它将响应发送到那里。然后它被路由回原始客户端的 NAT 路由器。 | 响应（从外部服务器到内部客户端） | 204.51.16.12
    (外部全局) | 194.54.21.11 (内部全局) |'
- en: '| 4 | **NAT Router Translates Destination Address and Delivers Datagram to
    Inside Client**: The NAT router sees 194.54.21.11 in the response that arrived
    from the Internet. It consults its translation table and knows this datagram is
    intended for 10.0.0.207\. This time, the destination address is changed but not
    the source. It then delivers the datagram back to the originating client. |  
    | 204.51.16.12 (outside local) | 10.0.0.207 (inside local) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **NAT 路由器转换目标地址并将数据报发送到内部客户端**：NAT 路由器看到从互联网到达的响应中包含 194.54.21.11。它查阅其转换表并知道这个数据报是针对
    10.0.0.207 的。这次，目标地址改变了，但源地址没有变。然后它将数据报发送回原始客户端。 |   | 204.51.16.12 (外部本地) | 10.0.0.207
    (内部本地) |'
- en: '![Operation of unidirectional (traditional/outbound) NAT You can see the four
    steps in this process by following the steps in clockwise order. Translated addresses
    are shown in bold. Refer to and for an explanation of the four address types.](httpatomoreillycomsourcenostarchimages287905.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![单向（传统/出站）NAT 操作图。您可以通过按顺时针顺序遵循这些步骤来查看此过程中的四个步骤。已转换的地址以粗体显示。有关四种地址类型的解释，请参阅和。](httpatomoreillycomsourcenostarchimages287905.png.jpg)'
- en: Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can
    see the four steps in this process by following the steps in clockwise order.
    Translated addresses are shown in bold. Refer to [Table 28-1](ch28s04.html#operation_of_unidirectional_traditional_
    "Table 28-1. Operation of Unidirectional (Traditional/Outbound) NAT") and [Figure 28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this
    diagram will help you to better understand the whole "inside/outside/local/global"
    thing.") for an explanation of the four address types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 28-2. 单向（传统/出站）NAT 操作图。您可以通过按顺时针顺序遵循这些步骤来查看此过程中的四个步骤。已转换的地址以粗体显示。有关四种地址类型的解释，请参阅
    [表 28-1](ch28s04.html#operation_of_unidirectional_traditional_ "表 28-1. 单向（传统/出站）NAT
    操作") 和 [图 28-1](ch28s02.html#ip_network_address_translation_nat_termi "图 28-1.
    IP 网络地址转换 (NAT) 术语。希望这个图表能帮助您更好地理解整个“内部/外部/本地/全局”的概念。")。
- en: As you can see, this really isn't rocket science, and it's fairly easy to understand
    what is going on as soon as you get used to the terminology and concepts. In unidirectional
    NAT, the source address is translated on outgoing datagrams and the destination
    address is translated on incoming ones. Traditional NAT supports only this sort
    of outbound transaction, which is started by a device on the inside network. It
    cannot handle a device that sends a request to a private address on the public
    Internet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这其实并不是什么火箭科学，一旦您习惯了术语和概念，理解正在发生的事情就相当容易。在单向NAT中，源地址在出站数据报中被转换，而目的地址在入站数据报中被转换。传统NAT仅支持这种类型的出站事务，这种事务是由内部网络中的设备启动的。它无法处理向公共互联网上的私有地址发送请求的设备。
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In *unidirectional* (traditional) NAT, the NAT router translates
    the source address of an outgoing request from inside local to inside global form.
    It then transforms the destination address of the response from inside global
    to inside local. The outside local and outside global addresses are the same in
    both request and reply.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在*单向*（传统）NAT中，NAT路由器将出站请求的源地址从内部本地转换为内部全局形式。然后它将响应的目的地址从内部全局转换为内部本地。在请求和回复中，外部本地和外部全局地址是相同的。'
- en: Also note that even though I am focusing on the changes that the NAT router
    makes to addresses, it also must make other changes to the datagram. Changing
    any field in the IP header means that the IP Header Checksum field will need to
    be recalculated. User Datagram Protocol (UDP) and Transmission Control Protocol
    (TCP) checksums need to be recalculated, and depending on the nature of the data
    in the datagram, other changes may also be required. I discuss these issues in
    the section on NAT compatibility issues, at the end of this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，尽管我主要关注NAT路由器对地址所做的更改，但它也必须对数据报进行其他更改。更改IP头中的任何字段意味着需要重新计算IP头校验和字段。用户数据报协议（UDP）和传输控制协议（TCP）校验和也需要重新计算，并且根据数据报中数据的特点，可能还需要进行其他更改。我将在本章末尾关于NAT兼容性问题的部分中讨论这些问题。
- en: 'Incidentally, this simplified example assumes the existence of just one router
    between the private and public networks. It is possible to have more than one
    router between these networks. If this configuration is used, however, it is essential
    that they both use the same translation table. Otherwise, if Router R1 processes
    the request, but Router R2 receives the response, Router R2 won''t know how to
    translate back the destination address on the incoming datagram. This makes dynamic
    mapping extremely difficult: Routers would have to coordinate their address mappings.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这个简化的示例假设在私有网络和公共网络之间只有一个路由器。在这些网络之间可能有多个路由器。但是，如果使用这种配置，则它们必须使用相同的转换表。否则，如果路由器R1处理请求，但路由器R2收到响应，路由器R2将不知道如何转换入站数据报上的目的地址。这使得动态映射变得极其困难：路由器必须协调它们的地址映射。
- en: IP NAT Bidirectional (Two-Way/Inbound) Operation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT双向（双向/入站）操作
- en: Traditional NAT is designed to handle only outbound transactions; clients on
    the local network initiate requests and devices on the Internet and send back
    responses. However, in some circumstances, we may want to go in the opposite direction.
    That is, we may want to have a device on the outside network initiate a transaction
    with one on the inside. To permit this, we need a more capable type of NAT than
    the traditional version. This enhancement goes by various names, most commonly
    Bidirectional NAT, Two-Way NAT, and Inbound NAT. All of these convey the concept
    that this kind of NAT allows both the type of transaction you saw in the previous
    topic and also transactions initiated from the outside network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 传统NAT设计用于处理仅出站事务；本地网络上的客户端发起请求，互联网上的设备发送响应。然而，在某些情况下，我们可能希望反方向进行。也就是说，我们可能希望外部网络上的设备与内部网络上的设备发起事务。为了允许这样做，我们需要比传统版本更强大的NAT类型。这种增强有多种名称，最常见的是双向NAT、双向NAT和入站NAT。所有这些名称都传达了这种NAT允许您在前面主题中看到的类型的事务，以及从外部网络发起的事务。
- en: 'Performing NAT on inbound transactions is more difficult than conventional
    outbound NAT. To understand why, remember that the network configuration when
    using NAT is inherently *asymmetric*: The inside network generally knows the IP
    addresses of outside devices, since they are public, but the outside network doesn''t
    know the private addresses of the inside network. Even if they did know them,
    they could never be specified as the target of an IP datagram initiated from outside
    since they are not routable—there would be no way to get them to the private network''s
    local router.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在入站事务上进行NAT比传统的出站NAT更困难。要理解为什么，请记住使用NAT时的网络配置本质上是*不对称的*：内部网络通常知道外部设备的IP地址，因为它们是公开的，但外部网络不知道内部网络的私有地址。即使它们知道这些地址，它们也无法作为从外部发起的IP数据报的目标，因为它们是不可路由的——没有方法将它们发送到私有网络的本地路由器。
- en: Why does this matter? Well, consider the case of outbound NAT from Device A
    on the inside network to Device B on the outside. The local client, A, always
    starts the transaction, so Device A's NAT router is able to create a mapping between
    Device A's inside local and inside global address during the request. Device B
    is the recipient of the already-translated datagram, so the fact that Device A
    is using NAT is hidden. Device B responds back, and the NAT router does the reverse
    translation without Device B ever even knowing NAT was used for Device A.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系呢？好吧，考虑一下内部网络中设备A向外部网络中设备B进行NAT的情况。本地客户端A总是首先开始事务，因此设备A的NAT路由器能够在请求期间创建一个映射，将设备A的内部本地地址和内部全局地址关联起来。设备B是已翻译数据报的接收者，所以设备A使用NAT的事实被隐藏了。设备B进行响应，NAT路由器进行反向翻译，而设备B甚至不知道为设备A使用了NAT。
- en: Now let's look at the inbound case. Here, Device B is trying to send to Device
    A, which is using NAT. Device B can't send to Device A's private (inside local)
    address. It needs Device A's inside global address in order to start the ball
    rolling. However, Device A's NAT router isn't proximate to Device B. In fact,
    Device B probably doesn't even know the identity of Device A's NAT router!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看入站的情况。在这里，设备B试图向使用NAT的设备A发送数据。设备B不能直接发送到设备A的私有（内部本地）地址。它需要设备A的内部全局地址来开始这个过程。然而，设备A的NAT路由器并不在设备B附近。实际上，设备B甚至可能不知道设备A的NAT路由器的身份！
- en: This leaves only two methods. One is to use static mapping for devices like
    servers on the inside network that need to be accessed from the outside. When
    static mapping is employed, the global address of the device that is using the
    static mapping will be publicly known, which solves the "where do I send my request
    to" problem.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就只剩下两种方法。一种是为需要从外部访问的内部网络中的设备（如服务器）使用静态映射。当使用静态映射时，使用静态映射的设备的全局地址将是公开的，这解决了“我该向哪里发送请求”的问题。
- en: The other solution is to make use of DNS. As explained in detail in the section
    on DNS (see [Part III-1](pt12.html "Part III-1. NAME SYSTEMS AND TCP/IP NAME REGISTRATION
    AND NAME RESOLUTION")), this protocol allows requests to be sent as names instead
    of IP addresses. The DNS server translates these names to their corresponding
    addresses. It is possible to integrate DNS and NAT so they work together. This
    process is described in RFC 2694, "DNS Extensions to Network Address Translators
    (DNS_ALG)."
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是利用DNS。正如在DNS部分详细解释的那样（见[第三部分-1](pt12.html "第三部分-1. 命名系统与TCP/IP命名注册及解析"))，该协议允许请求以名称而不是IP地址的形式发送。DNS服务器将这些名称转换为相应的地址。可以将DNS和NAT集成在一起，使它们协同工作。这个过程在RFC
    2694，“DNS对网络地址转换器的扩展（DNS_ALG）”中有描述。
- en: 'In this technique, an outside device can make use of dynamic mapping. The basic
    process (highly simplified) is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，外部设备可以利用动态映射。基本过程（高度简化）如下：
- en: The outside device sends a DNS request using the name of the device on the inside
    network it wishes to reach. For example, it might be [www.ilikenat.com](http://www.ilikenat.com).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部设备使用它想要到达的内部网络设备的名称发送DNS请求。例如，它可能是[www.ilikenat.com](http://www.ilikenat.com)。
- en: The DNS server for the internal network resolves the [www.ilikenat.com](http://www.ilikenat.com)
    name into an *inside local* address for the device that corresponds to this DNS
    entry.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内部网络的DNS服务器将[www.ilikenat.com](http://www.ilikenat.com)名称解析为对应此DNS条目的设备的*内部本地*地址。
- en: The *inside local* address is passed to NAT and used to create a dynamic mapping
    between the *inside local* address of the server being accessed from the outside,
    and an *inside global* address. This mapping is put into the NAT router's translation
    table.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*内部本地* 地址被传递给 NAT，并用于在从外部访问的服务器的 *内部本地* 地址和 *内部全局* 地址之间创建动态映射。此映射被放入 NAT 路由器的转换表中。'
- en: When the DNS server sends back the name resolution, it tells the outside device
    the *inside global* (public) address mapped in the previous step, not the *inside
    local* (private) address of the server being sought.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 DNS 服务器发送回名称解析时，它告诉外部设备之前步骤中映射的 *内部全局*（公共）地址，而不是正在寻找的服务器的 *内部本地*（私有）地址。
- en: Once the inside global address of the device on the inside network is known
    by the outside device, the transaction can begin. Let's use the same example as
    in the previous section, but let's reverse it so that the outside device 204.51.16.12
    is initiating a request (and is thus now the *client* ) to inside device 10.0.0.207
    (which is the *server* ). Let's say that either static mapping or DNS has been
    used so that the outside device knows the inside global address of 10.0.0.207
    is actually 194.54.21.6\. [Table 28-2](ch28s05.html#operation_of_bidirectional_two-way-id001
    "Table 28-2. Operation of Bidirectional (Two-Way/Inbound) NAT") describes the
    transaction in detail, and it is illustrated [Figure 28-3](ch28s05.html#operation_of_bidirectional_two-wayinboun
    "Figure 28-3. Operation of bidirectional (two-way/inbound) NAT This figure is
    very similar to Figure 28-2, except that the transaction is in reverse, so start
    at the upper right and go counterclockwise. Translated addresses are shown in
    bold. Table 28-2 contains a complete explanation of the four steps. Refer to Figure 28-1
    for an explanation of address types.").
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦外部设备知道内部网络中设备的内部全局地址，交易就可以开始了。让我们使用上一节中的相同示例，但这次我们将其反转，以便外部设备 204.51.16.12
    发起请求（因此现在它是 *客户端*），向内部设备 10.0.0.207（它是 *服务器*）发起请求。假设已经使用了静态映射或DNS，以便外部设备知道10.0.0.207的内部全局地址实际上是194.54.21.6。[表
    28-2](ch28s05.html#operation_of_bidirectional_two-way-id001 "表 28-2. 双向（双向/入站）NAT
    的操作") 详细描述了交易过程，并在[图 28-3](ch28s05.html#operation_of_bidirectional_two-wayinboun
    "图 28-3. 双向（双向/入站）NAT 的操作。此图与图 28-2 非常相似，但交易方向相反，因此从右上角开始，逆时针方向。粗体显示的是翻译后的地址。表
    28-2 包含了四个步骤的完整解释。有关地址类型的解释，请参阅图 28-1。") 中进行了说明。
- en: '![Operation of bidirectional (two-way/inbound) NAT This figure is very similar
    to , except that the transaction is in reverse, so start at the upper right and
    go counterclockwise. Translated addresses are shown in bold. contains a complete
    explanation of the four steps. Refer to for an explanation of address types.](httpatomoreillycomsourcenostarchimages287907.png.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![双向（双向/入站）NAT 的操作 此图与  相似，但交易方向相反，因此从右上角开始，逆时针方向。翻译后的地址以粗体显示。 包含了四个步骤的完整解释。有关地址类型的解释，请参阅
    。](httpatomoreillycomsourcenostarchimages287907.png.jpg)'
- en: Figure 28-3. Operation of bidirectional (two-way/inbound) NAT This figure is
    very similar to [Figure 28-2](ch28s04.html#operation_of_unidirectional_tradit-id001
    "Figure 28-2. Operation of unidirectional (traditional/outbound) NAT You can see
    the four steps in this process by following the steps in clockwise order. Translated
    addresses are shown in bold. Refer to Table 28-1 and Figure 28-1 for an explanation
    of the four address types."), except that the transaction is in reverse, so start
    at the upper right and go counterclockwise. Translated addresses are shown in
    bold. [Table 28-2](ch28s05.html#operation_of_bidirectional_two-way-id001 "Table 28-2. Operation
    of Bidirectional (Two-Way/Inbound) NAT") contains a complete explanation of the
    four steps. Refer to [Figure 28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this
    diagram will help you to better understand the whole "inside/outside/local/global"
    thing.") for an explanation of address types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-3. 双向（双向/入站）NAT操作此图与[图28-2](ch28s04.html#operation_of_unidirectional_tradit-id001
    "图28-2. 双向（传统/出站）NAT操作您可以通过按顺时针顺序遵循这些步骤来查看此过程中的四个步骤。已转换的地址以粗体显示。请参阅表28-1和图28-1以了解四种地址类型的解释。")非常相似，除了事务是反向的，因此从右上角开始，逆时针进行。已转换的地址以粗体显示。[表28-2](ch28s05.html#operation_of_bidirectional_two-way-id001
    "表28-2. 双向（双向/入站）NAT操作")包含对四个步骤的完整解释。请参阅[图28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "图28-1. IP网络地址转换（NAT）术语希望这个图表能帮助您更好地理解整个“内部/外部/本地/全局”的概念。")以了解地址类型的解释。
- en: Table 28-2. Operation of Bidirectional (Two-Way/Inbound) NAT
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-2. 双向（双向/入站）NAT操作
- en: '| Step # | Description | Datagram Type | Datagram Source Address | Datagram
    Destination Address |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 # | 描述 | 数据报类型 | 数据报源地址 | 数据报目的地址 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | **Outside Client Generates Request and Sends to NAT Router**: Device
    204.51.16.12 generates a request to the inside server. It uses the *inside global*
    address 194.54.21.6 as the destination. The datagram will be routed to the address''s
    local router, which is the NAT router that services the inside network where the
    server is located. | Request (from outside client to inside server) | 204.51.16.12
    (outside global) | 194.54.21.6 (inside global) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **外部客户端生成请求并发送到NAT路由器**：设备204.51.16.12向内部服务器生成请求。它使用*内部全局*地址194.54.21.6作为目的地址。数据报将被路由到该地址的本地路由器，即服务位于内部网络的NAT路由器。
    | 请求（从外部客户端到内部服务器） | 204.51.16.12（外部全局） | 194.54.21.6（内部全局） |'
- en: '| 2 | **NAT Router Translates Destination Address and Sends to Inside Server**:
    The NAT router already has a mapping from the *inside global* address to the *inside
    local* address of the server. It replaces the 194.54.21.6 destination address
    with 10.0.0.207, and performs checksum recalculations and other work as necessary.
    The source address is not translated. The router then delivers the modified datagram
    to the inside server at 10.0.0.207. |   | 204.51.16.12 (outside local) | 10.0.0.207
    (inside local) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **NAT路由器转换目的地址并发送到内部服务器**：NAT路由器已经从*内部全局*地址映射到服务器的*内部本地*地址。它将194.54.21.6目的地址替换为10.0.0.207，并根据需要执行校验和重新计算和其他工作。源地址不进行转换。然后路由器将修改后的数据报发送到位于10.0.0.207的内部服务器。
    |  | 204.51.16.12（外部本地） | 10.0.0.207（内部本地） |'
- en: '| 3 | **Inside Server Generates Response and Sends Back to NAT Router**: The
    server at 10.0.0.207 generates a response, which it addresses to 204.51.16.12
    since that was the source of the request to it. This is then routed to the server''s
    NAT router. | Response (from inside server to outside client) | 10.0.0.207 (inside
    local) | 204.51.16.12 (outside local) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **内部服务器生成响应并发送回NAT路由器**：位于10.0.0.207的服务器生成响应，将其地址设置为204.51.16.12，因为这是向它发送请求的来源。然后将其路由到服务器的NAT路由器。
    | 响应（从内部服务器到外部客户端） | 10.0.0.207（内部本地） | 204.51.16.12（外部本地） |'
- en: '| 4 | **NAT Router Translates Source Address and Routes Datagram to Outside
    Client**: The NAT router sees the private address 10.0.0.207 in the response and
    replaces it with 194.54.21.6\. It then routes this back to the original client
    on the outside network. |   | 194.54.21.6 (inside global) | 204.51.16.12 (outside
    global) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **NAT路由器转换源地址并将数据报路由到外部客户端**：NAT路由器在响应中看到私有地址10.0.0.207，并将其替换为194.54.21.6。然后它将此路由回外部网络上的原始客户端。
    |  | 194.54.21.6（内部全局） | 204.51.16.12（外部全局） |'
- en: As you can see, once the outside device knows the inside device's *inside global*
    address, you'll find that inbound NAT is very similar to outbound NAT. It just
    does the exact opposite translation. Instead of modifying the source address on
    the outbound request and the destination on the inbound response, the router changes
    the destination on the inbound request and the source on the outbound reply.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一旦外部设备知道内部设备的 *内部全局* 地址，您会发现入站 NAT 与出站 NAT 非常相似。它只是执行相反的转换。而不是修改出站请求的源地址和入站响应的目的地址，路由器更改入站请求的目的地址和出站回复的源地址。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In traditional NAT, a transaction must begin with a request
    from a client on the local network, but in *bidirectional* (two-way/inbound) NAT,
    it is possible for a device on the public Internet to access a local network server.
    This requires the use of either static mapping or DNS to provide to the outside
    client the address of the server on the inside network. Then the NAT transaction
    is pretty much the same as in the unidirectional case, except in reverse: The
    incoming request has its destination address changed from *inside global* to *inside
    local*; the response has its source changed from *inside local* to *inside global*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在传统的 NAT 中，交易必须从本地网络上的客户端请求开始，但在 *双向*（双向/入站）NAT 中，公共互联网上的设备可以访问本地网络服务器。这需要使用静态映射或
    DNS 向外部客户端提供内部网络上服务器的地址。然后，NAT 交易基本上与单向情况相同，只是方向相反：传入请求的目的地址从 *内部全局* 更改为 *内部本地*；响应的源地址从
    *内部本地* 更改为 *内部全局*。'
- en: IP NAT Port-Based (Overloaded) Operation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT 基于端口的操作（过载）
- en: Both traditional NAT and bidirectional NAT work by swapping inside network and
    outside network addresses as needed in order to allow a private network to access
    a public one. For each transaction, there is a one-to-one mapping between the
    *inside local* address of a device on the private network and the *inside global*
    address that represents it on the public network. We can use dynamic address assignment
    to allow a large number of private hosts to share a small number of registered
    public addresses.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 NAT 和双向 NAT 都是通过根据需要交换内部网络和外部网络地址来工作的，以便允许私有网络访问公共网络。对于每次交易，私有网络中设备上的 *内部本地*
    地址与代表它在公共网络上出现的 *内部全局* 地址之间有一个一对一的映射。我们可以使用动态地址分配，允许大量私有主机共享少量已注册的公共地址。
- en: However, there is a potential snag here. Consider the earlier NAT example, where
    250 hosts share 20 inside global (public) addresses. If 20 hosts already have
    transactions in progress, what happens when the 21st tries to access the Internet?
    There aren't any *inside global* addresses available for it to use, so it won't
    be able to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个潜在的陷阱。考虑之前的 NAT 示例，其中 250 个主机共享 20 个内部全局（公共）地址。如果已经有 20 个主机正在进行交易，那么当第
    21 个尝试访问互联网时会发生什么？没有可用的 *内部全局* 地址供其使用，因此它将无法访问。
- en: 'Fortunately, there is a mechanism already built into TCP/IP that can help us
    alleviate this situation. The two TCP/IP transport layer protocols, TCP and UDP,
    both make use of additional addressing components called *ports*. The port number
    in a TCP or UDP message helps identify individual connections between two addresses.
    It is used to allow many different applications on a TCP/IP client and server
    to talk to each simultaneously, without interference. For example, you use this
    capability when you open multiple browser windows to access more than one web
    page on the same site at the same time. This sharing of IP addresses among many
    connections is called *multiplexing*. [Chapter 43](ch43.html "Chapter 43. TCP
    AND UDP ADDRESSING: PORTS AND SOCKETS"), which describes TCP and UDP ports, covers
    all of this in much more detail.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TCP/IP 已经内置了一种机制，可以帮助我们缓解这种情况。TCP/IP 传输层协议中的两个协议，TCP 和 UDP，都使用了额外的寻址组件，称为
    *端口*。TCP 或 UDP 消息中的端口号有助于识别两个地址之间的单个连接。它用于允许 TCP/IP 客户端和服务器上的许多不同应用程序同时进行通信，而不会相互干扰。例如，当你打开多个浏览器窗口以同时访问同一网站上的多个网页时，你使用这种能力。这种在许多连接之间共享
    IP 地址的行为称为 *复用*。[第 43 章](ch43.html "第 43 章。TCP 和 UDP 寻址：端口和套接字")，它描述了 TCP 和 UDP
    端口，对此进行了更详细的说明。
- en: Now let's come back to NAT. We are already translating IP addresses as we send
    datagrams between the public and private portions of the internetwork. What if
    we could also translate port numbers? Well, we can! The combination of an address
    and port uniquely identifies a connection. As a datagram passes from the private
    network to the public one, we can change not just the IP address, but also the
    port number in the TCP or UDP header. The datagram will be sent out with a different
    source address and port. The response will come back to this same address and
    port combination (called a *socket*) and can be translated back again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到NAT（网络地址转换）。在我们发送数据报文在互联网的公共部分和私有部分之间时，我们已经在转换IP地址了。如果我们还能转换端口号呢？嗯，我们可以！地址和端口的组合唯一地标识了一个连接。当数据报文从私有网络传递到公共网络时，我们不仅可以更改IP地址，还可以更改TCP或UDP头中的端口号。数据报文将以不同的源地址和端口号发送出去。响应将返回到这个相同的地址和端口号组合（称为*套接字*）并可以再次进行转换。
- en: This method goes by various names. Since it is a technique that can have multiple
    inside local addresses share a single inside global address, it is called *overloading*
    of an *inside global* address, or alternatively, just *overloaded NAT*. More elegant
    names that better indicate how the technique works include *Port-Based NAT, Network
    Address Port Translation (NAPT)*, and *Port Address Translation (PAT)*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有不同的名称。由于它是一种可以使多个内部本地地址共享单个内部全局地址的技术，因此被称为*内部全局地址的* *过载*，或者简单地称为*过载NAT*。更优雅的名称能更好地说明该技术的工作方式，包括*基于端口的NAT、网络地址端口转换（NAPT）*和*端口地址转换（PAT）*。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *Port-Based* or overloaded NAT is an enhancement of regular
    NAT that allows a large number of devices on a private network to simultaneously
    share a single inside global address by changing the port numbers used in TCP
    and UDP messages.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *基于端口的* 或过载NAT是常规NAT的增强，它允许私有网络上的大量设备通过更改TCP和UDP消息中使用的端口号，同时共享一个单一的内部全局地址。'
- en: Whatever its name, the use of ports in translation has tremendous advantages.
    It can allow all 250 hosts on the private network to use only 20 IP addresses—and
    potentially even fewer than that. In theory, you could even have all 250 share
    a single public IP address at once! You don't want to share so many local hosts
    that you run out of port numbers, but there are thousands of port numbers to choose
    from.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 无论其名称如何，在转换中使用端口号具有巨大的优势。它可以允许私有网络上的所有250台主机只使用20个IP地址——甚至可能更少。理论上，甚至可以一次性让所有250台共享一个单一的公共IP地址！你不希望共享太多的本地主机以至于用完端口号，但可供选择的端口号有数千个。
- en: Port-Based NAT requires a router that is programmed to make the appropriate
    address and port mappings for datagrams as it transfers them between networks.
    The disadvantages of the method include this greater complexity, and also the
    potential for more compatibility issues (such as with applications like FTP),
    since you must now watch for port numbers at higher layers and not just IP addresses.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 基于端口的NAT需要一台被编程来在传输数据报文时在网络上进行适当的地址和端口映射的路由器。这种方法的不利之处包括更大的复杂性，以及更多兼容性问题（例如与FTP等应用程序），因为你现在必须在高层监视端口号，而不仅仅是IP地址。
- en: The operation of NAPT/PAT is very similar to the way regular NAT works, except
    that port numbers are also translated. For a traditional outbound transaction,
    the source port number is changed on the request at the same time that the source
    address is modified; the destination port number is modified on the response with
    the destination address.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: NAPT/PAT的操作与常规NAT的工作方式非常相似，只是端口也会被转换。对于传统的出站事务，源端口号码在修改源地址的同时在请求上更改；响应中的目标端口号码与目标地址一起修改。
- en: Let's consider again the example you looked at in the topic on traditional NAT,
    but this time in a PAT environment. Device 10.0.0.207 was one of 250 hosts on
    a private network accessing the World Wide Web server at 204.51.16.12\. Let's
    say that because PAT is being used, in order to save money, all 250 hosts are
    sharing a single *inside global* address, 194.54.21.7, instead of a pool of 20\.
    The transaction would proceed as described in [Table 28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "Table 28-3. Operation of Port-Based (Overloaded) NAT") and illustrated in [Table 28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "Table 28-3. Operation of Port-Based (Overloaded) NAT").
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑你在传统NAT主题中查看的示例，但这次是在PAT环境中。设备10.0.0.207是私有网络上的250个主机之一，它访问了位于204.51.16.12的万维网服务器。假设由于使用了PAT，为了节省费用，所有250个主机都在共享一个单一的*内部全局*地址，194.54.21.7，而不是一个20个地址的池。事务将按照[表28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "表28-3. 基于端口的（过载）NAT操作")中描述并在[表28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "表28-3. 基于端口的（过载）NAT操作")中展示的方式进行。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** In Port-Based NAT, the NAT router translates the source address
    and port of an outgoing request from inside local to inside global form. It then
    transforms the destination address and port of the response from inside global
    to inside local. The outside local and outside global addresses are the same in
    both request and reply.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在基于端口的NAT中，NAT路由器将内部本地请求的源地址和端口号转换为内部全局形式。然后，它将响应的目的地址和端口号从内部全局转换为内部本地。在外部本地和外部全局地址在请求和回复中是相同的。'
- en: 'One other issue related to NAPT/PAT is worth mentioning: It assumes that all
    traffic uses either UDP or TCP at the transport layer. Although this is generally
    the case, it may not always be true. If there is no port number, port translation
    cannot be done and the method will not work.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与NAPT/PAT相关的一个其他问题也值得提及：它假设所有流量在传输层都使用UDP或TCP。尽管这通常是情况，但它可能并不总是如此。如果没有端口号，则无法进行端口转换，该方法将无法工作。
- en: '![Operation of Port-Based (overloaded) NAT This figure is very similar to ,
    except that the source and destination port numbers have been shown, since they
    are used in this type of NAT. Translated addresses and ports are in bold. contains
    a complete explanation of the four steps in Port-Based NAT. Refer to for an explanation
    of address types.](httpatomoreillycomsourcenostarchimages287909.png.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![基于端口的（过载）NAT操作 此图与非常相似，除了显示了源和目的端口号，因为它们在这种类型的NAT中使用。已翻译的地址和端口以粗体显示。包含基于端口NAT的四个步骤的完整解释。请参考来解释地址类型。](httpatomoreillycomsourcenostarchimages287909.png.jpg)'
- en: Figure 28-4. Operation of Port-Based (overloaded) NAT This figure is very similar
    to [Table 28-3](ch28s06.html#operation_of_port-based_overloaded_nat "Table 28-3. Operation
    of Port-Based (Overloaded) NAT"), except that the source and destination port
    numbers have been shown, since they are used in this type of NAT. Translated addresses
    and ports are in bold. [Table 28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "Table 28-3. Operation of Port-Based (Overloaded) NAT") contains a complete explanation
    of the four steps in Port-Based NAT. Refer to [Figure 28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this
    diagram will help you to better understand the whole "inside/outside/local/global"
    thing.") for an explanation of address types.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-4. 基于端口的（过载）NAT操作 此图与[表28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "表28-3. 基于端口的（过载）NAT操作")非常相似，除了显示了源和目的端口号，因为它们在这种类型的NAT中使用。已翻译的地址和端口以粗体显示。[表28-3](ch28s06.html#operation_of_port-based_overloaded_nat
    "表28-3. 基于端口的（过载）NAT操作")包含了基于端口NAT的四个步骤的完整解释。请参考[图28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "图28-1. IP网络地址转换（NAT）术语图，希望这个图表能帮助你更好地理解整个“内部/外部/本地/全局”的概念。")来解释地址类型。
- en: Table 28-3. Operation of Port-Based (Overloaded) NAT
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-3. 基于端口的（过载）NAT操作
- en: '| Step # | Description | Datagram Type | Datagram Source Address:Port | Datagram
    Destination Address:Port |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 步骤编号 | 描述 | 数据包类型 | 数据包源地址:端口 | 数据包目的地址:端口 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | **Inside Client Generates Request and Sends to NAT Router**: Device 10.0.0.207
    generates an HTTP request to the server at 204.51.16.12\. The standard server
    port for WWW is 80, so the destination port of the request is 80; let''s say the
    source port on the client is 7000\. The datagram is sent to the NAT-capable router
    that connects the organization''s internal network to the Internet. | Request
    (from inside client to outside server) | 10.0.0.207:7000 (inside local) | 204.51.16.12:80
    (outside local) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **内部客户端生成请求并发送至 NAT 路由器**：设备 10.0.0.207 向服务器 204.51.16.12 生成一个 HTTP 请求。WWW
    的标准服务器端口是 80，所以请求的目标端口是 80；假设客户端的源端口是 7000。数据报被发送到连接组织内部网络到互联网的 NAT 兼容路由器。 | 请求（从内部客户端到外部服务器）
    | 10.0.0.207:7000 (内部本地) | 204.51.16.12:80 (外部本地) |'
- en: '| 2 | **NAT Router Translates Source Address and Port and Sends to Outside
    Server**: The NAT router realizes that 10.0.0.207 is an *inside local* address
    and knows it must substitute an *inside global* address. Here though, there are
    multiple hosts sharing the single *inside global* address 194.54.21.7\. Lets say
    that port 7000 is already in use for that address by another private host connection.
    The router substitutes the *inside global* address and also chooses a new source
    port number, say 7224, for this request. The destination address and port are
    not changed.The NAT router puts the address and port mapping into its translation
    table. It sends the modified datagram out, which arrives at the server at 204.51.16.12.
    |   | 194.54.21.7:7224 (inside global) | 204.51.16.12 (outside global) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **NAT 路由器转换源地址和端口并发送到外部服务器**：NAT 路由器意识到 10.0.0.207 是一个 *内部本地* 地址，并且知道它必须替换为一个
    *内部全局* 地址。然而，这里有多个主机共享单个 *内部全局* 地址 194.54.21.7。假设端口 7000 已经被另一个私有主机连接使用。路由器替换了
    *内部全局* 地址，并为这个请求选择了一个新的源端口号，比如 7224。目标地址和端口没有变化。NAT 路由器将地址和端口映射放入其转换表中。它发送修改后的数据报出去，该数据报到达服务器
    204.51.16.12。 |   | 194.54.21.7:7224 (内部全局) | 204.51.16.12 (外部全局) |'
- en: '| 3 | **Outside Server Generates Response and Sends Back to NAT Router**: The
    server at 204.51.16.12 generates an HTTP response. It has no idea that NAT was
    involved; it sees an address of 194.54.21.7 and port of 7224 in the request sent
    to it, so it sends back to that address and port. | Response (from outside server
    to inside client) | 204.51.16.12:80 (outside global) | 194.54.21.7:7224 (inside
    global) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **外部服务器生成响应并发送回 NAT 路由器**：服务器在 204.51.16.12 生成一个 HTTP 响应。它不知道 NAT 是否被涉及；它看到发送给它的请求中有一个地址
    194.54.21.7 和端口 7224，因此它将响应发送回那个地址和端口。 | 响应（从外部服务器到内部客户端） | 204.51.16.12:80 (外部全局)
    | 194.54.21.7:7224 (内部全局) |'
- en: '| 4 | **NAT Router Translates Destination Address and Port and Delivers Datagram
    to Inside Client**: The NAT router sees the address 94.54.21.7 and port 7224 in
    the response that arrived from the Internet. It consults its translation table
    and knows this datagram is intended for 10.0.0.207, port 7000\. This time, the
    destination address and port are changed but not the source. The router then delivers
    the datagram back to the originating client. |   | 204.51.16.12:80 (outside local)
    | 10.0.0.207:7000 (inside local) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **NAT 路由器转换目标地址和端口并将数据报发送到内部客户端**：NAT 路由器看到从互联网到达的响应中包含的地址 94.54.21.7
    和端口 7224。它查阅其转换表并知道这个数据报是针对 10.0.0.207，端口 7000 的。这次，目标地址和端口发生了变化，但源地址没有变。然后路由器将数据报发送回原始客户端。
    |   | 204.51.16.12:80 (外部本地) | 10.0.0.207:7000 (内部本地) |'
- en: IP NAT Overlapping/Twice NAT Operation
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT 重叠/双重 NAT 操作
- en: All three of the versions of NAT discussed so far—traditional, bidirectional,
    and Port-Based—are normally used to connect a network using private, nonroutable
    addresses to the public Internet, which uses unique, registered, routable addresses.
    With these kinds of NAT, there will normally be no overlap between the address
    spaces of the inside and outside network, since the former are private and the
    latter are public. This enables the NAT router to be able to immediately distinguish
    inside addresses from outside addresses just by looking at them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的所有三种 NAT 版本——传统、双向和基于端口的 NAT——通常用于将使用私有、不可路由地址的网络连接到使用唯一、已注册、可路由地址的公共互联网。使用这些类型的
    NAT，内部和外部网络的地址空间通常不会有重叠，因为前者是私有的，后者是公共的。这使得 NAT 路由器能够仅通过查看地址就能立即区分内部地址和外部地址。
- en: In the examples you've seen so far, the inside addresses were all from the RFC
    1918 block 10.0.0.0\. These can't be public Internet addresses, so the NAT router
    knew any address referenced by a request from the inside network within this range
    was a local reference within the inside network. Similarly, any addresses outside
    this range are easy to identify as belonging to the outside world.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在你迄今为止看到的例子中，内部地址都是从RFC 1918块10.0.0.0来的。这些不能是公共互联网地址，所以NAT路由器知道在这个范围内由内部网络内的请求引用的任何地址都是内部网络内的本地引用。同样，任何在这个范围之外的地址都很容易识别为属于外部世界。
- en: 'There are circumstances, however, in which there may indeed be an overlap between
    the addresses used for the inside network, and the addresses used for part of
    the outside network. Consider the following cases:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，内部网络使用的地址和外部网络部分使用的地址之间可能确实存在重叠。考虑以下情况：
- en: '**Private Network–to–Private Network Connections** The example network using
    10.0.0.0 block addresses might want to connect to another network using the same
    method. This situation might occur if two corporations merged and happened to
    be using the same addressing scheme (and there aren''t that many private IP blocks,
    so this isn''t that uncommon).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**私有网络到私有网络连接** 使用10.0.0.0块地址的示例网络可能希望连接到另一个使用相同方法的网络。这种情况可能发生在两家公司合并并恰好使用相同的寻址方案（而且私有IP块并不多，所以这种情况并不罕见）。'
- en: '**Invalid Assignment of Public Address Space to Private Network** Some networks
    might have been set up, not by using a designated private address block, but rather
    by using a block containing valid Internet addresses. For example, suppose an
    administrator decided that the network he was setting up would never be connected
    to the Internet (ha!), and numbered the whole thing using 18.0.0.0 addresses,
    which belong to the Massachusetts Institute of Technology (MIT). Then later, this
    administrator''s shortsightedness would backfire when the network did indeed need
    to be connected to the Internet.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**将公共地址空间无效分配给私有网络** 一些网络可能不是通过使用指定的私有地址块来设置的，而是使用包含有效互联网地址的块。例如，假设一位管理员决定他正在设置的整个网络永远不会连接到互联网（哈哈！），并使用麻省理工学院（MIT）的18.0.0.0地址来编号整个网络，这些地址属于麻省理工学院。然后，当这个网络确实需要连接到互联网时，这位管理员的短视将会适得其反。'
- en: '**Stale Public Address Assignment** Company A might have been using a particular
    address block for years that was reassigned or reallocated for whatever reason
    to Company B. Company A might not want to go through the hassle of renumbering
    its network, and would then keep its addresses, even while Company B started using
    them on the Internet.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**过时的公共地址分配** 公司A可能多年来一直在使用某个特定的地址块，但由于某种原因被重新分配或重新分配给了公司B。公司A可能不想麻烦重新编号其网络，因此会保留其地址，即使公司B开始在互联网上使用它们。'
- en: What these situations all have in common is that the inside addresses used in
    the private network *overlap* with addresses on the public network. When a datagram
    is sent from within the local network, the NAT router can't tell if the intended
    destination is within the inside network or the outside network. For example,
    if you want to connect host 10.0.0.207 in the private network to host 10.0.0.199
    in a different network, and you put 10.0.0.199 in the destination of the datagram
    and send it, how does the router know if you mean 10.0.0.199 on your own local
    network or the remote one? For that matter, you might need to send a request to
    10.0.0.207 in the other private network, your own address! Take the network that
    was numbered with MIT's address block. How does the router know when a datagram
    is actually being sent to MIT as opposed to another device on the private network?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况都有一个共同点，那就是私有网络中使用的内部地址与公共网络上的地址重叠。当从本地网络发送数据报时，NAT路由器无法判断目标是在内部网络还是外部网络。例如，如果你想在私有网络中将主机10.0.0.207连接到另一个网络中的主机10.0.0.199，并将10.0.0.199放在数据报的目标中并发送它，那么路由器如何知道你是想连接到你的本地网络上的10.0.0.199还是远程网络上的10.0.0.199？至于发送到另一个私有网络中的10.0.0.207的请求，你的自己的地址！以使用MIT地址块编号的网络为例。路由器如何知道数据报是实际发送到MIT还是私有网络上的另一个设备？
- en: The solution to this dilemma is to use a more sophisticated form of NAT. The
    other versions you have seen so far always translate either the source address
    *or* the destination address as a datagram passes from the inside network to the
    outside network or vice versa. To cope with overlapping addresses, we must translate
    both the source address *and* the destination address on each transition from
    the inside to the outside or the other direction. This technique is called *overlapping
    NAT* in reference to the problem it solves, or *Twice NAT* due to how it solves
    it. (Incidentally, despite the latter name, regular NAT is *not* called Once NAT.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个困境的方法是使用更复杂的NAT形式。你之前看到的版本总是转换数据包从内部网络到外部网络或相反方向时的源地址或目的地址。为了处理重叠地址，我们必须在每个从内部到外部或相反方向的转换中同时转换源地址和目的地址。这种技术被称为*重叠NAT*，以解决它所解决的问题，或者称为*Twice
    NAT*，因为它解决问题的方法。（顺便说一下，尽管有后者的名称，常规NAT并不被称为Once NAT。）
- en: Twice NAT functions by creating a set of mappings not only for the private network
    the NAT router serves, but also for the overlapping network (or networks) that
    conflict with the inside network's address space. In order for this to function,
    Twice NAT relies on the use of DNS, just as does bidirectional NAT. This lets
    the inside network send requests to the overlapping network in a way that can
    be uniquely identified. Otherwise, the router can't tell what overlapping network
    our inside network is trying to contact.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Twice NAT通过创建一组映射，不仅为NAT路由器服务的私有网络，还包括与内部网络地址空间冲突的重叠网络（或多个网络）。为了实现这一点，Twice
    NAT依赖于DNS的使用，就像双向NAT一样。这使得内部网络能够以唯一标识的方式向重叠网络发送请求。否则，路由器无法确定我们的内部网络试图联系哪个重叠网络。
- en: 'Let''s try a new example. Suppose the network has been improperly numbered
    so that it is not in the 10.0.0.0 private block but in the 18.0.0.0 block used
    by MIT. A client on our private network, 18.0.0.18, wants to send a request to
    the server [www.twicenat.mit.edu](http://www.twicenat.mit.edu), which has the
    address 18.1.2.3 at MIT. The client can''t just make a datagram with 18.1.2.3
    as the destination and send out, as the router will think it''s on the local network
    and not route it. Instead, 18.0.0.18 uses a combination of DNS and NAT to get
    the outside device address, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个新的例子。假设网络被错误地编号，因此它不在10.0.0.0私有块中，而是在MIT使用的18.0.0.0块中。我们私有网络上的一个客户端，18.0.0.18，想要向服务器[www.twicenat.mit.edu](http://www.twicenat.mit.edu)发送请求，该服务器在MIT的地址是18.1.2.3。客户端不能直接使用18.1.2.3作为目的地址并发送数据包，因为路由器会认为它在本地网络中，不会进行路由。相反，18.0.0.18使用DNS和NAT的组合来获取外部设备地址，如下所示：
- en: The client on the local network (18.0.0.18) sends a DNS request to get the address
    of [www.twicenat.mit.edu](http://www.twicenat.mit.edu).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地网络上的客户端（18.0.0.18）发送一个DNS请求以获取[www.twicenat.mit.edu](http://www.twicenat.mit.edu)的地址。
- en: The (Twice-NAT compatible) NAT router serving the local network intercepts this
    DNS request. It then consults its tables to find a special mapping for this outside
    device. Let's say that it is programmed to translate [www.twicenat.mit.edu](http://www.twicenat.mit.edu)
    into the address 172.16.44.55\. This is a private, nonroutable RFC 1918 address.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为本地网络服务的（与Twice-NAT兼容）NAT路由器拦截这个DNS请求。然后它查阅其表格以找到这个外部设备的特殊映射。假设它被编程为将[www.twicenat.mit.edu](http://www.twicenat.mit.edu)转换为地址172.16.44.55。这是一个私有、不可路由的RFC
    1918地址。
- en: The NAT router returns this value, 172.16.44.55, to the source client, which
    uses it for the destination.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NAT路由器将这个值，172.16.44.55，返回给源客户端，客户端使用它作为目的地址。
- en: Once the client has the translated address, it initiates a transaction just
    as before. NAT will now perform translation of the inside devices and the outside
    devices as well. The outside device address must be translated because the inside
    device is using 172.16.44.55, which isn't a valid address for the server it is
    trying to reach. The inside device address must still be translated as in regular
    NAT because 18.0.0.18 is not a valid public address for you. It may refer to a
    real machine in MIT and you aren't supposed to be using it on the Internet!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦客户端获得了转换后的地址，它就像以前一样启动一个事务。现在NAT将执行内部设备和外部设备的转换。外部设备地址必须进行转换，因为内部设备正在使用172.16.44.55，这不是它试图到达的服务器的有效地址。内部设备地址仍然需要像常规NAT那样进行转换，因为18.0.0.18不是有效的公共地址。它可能指向MIT中的一台真实机器，而且你不应该在互联网上使用它！
- en: Let's say that you are still using the pool of 20 inside global addresses from
    194.54.21.1 through 194.54.21.20 for inside addresses, and let's further suppose
    that the NAT router chooses 194.54.21.12 for this particular exchange. The transaction
    sequence would be roughly as described in [Table 28-4](ch28s07.html#operation_of_overlapping_nattwice_nat
    "Table 28-4. Operation of Overlapping NAT/Twice NAT") and illustrated in [Figure 28-5](ch28s08.html#operation_of_overlapping_nattwice_nat_th
    "Figure 28-5. Operation of Overlapping NAT/Twice NAT This figure is very similar
    to Figure 28-2, except that as you can see, the NAT router translates both source
    and destination addresses each time (shown in bold). Table 28-4 contains a complete
    explanation of the four steps in overlapping NAT. Refer to Figure 28-1 for an
    explanation of address types.").
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你仍在使用从194.54.21.1到194.54.21.20的内部全局地址池作为内部地址，并且进一步假设NAT路由器为这次特定的交换选择了194.54.21.12。事务序列大致如[表28-4](ch28s07.html#operation_of_overlapping_nattwice_nat
    "表28-4. Overlapping NAT/Twice NAT的操作")所述，并在[图28-5](ch28s08.html#operation_of_overlapping_nattwice_nat_th
    "图28-5. Overlapping NAT/Twice NAT的操作。此图与图28-2非常相似，但如你所见，NAT路由器每次都翻译源地址和目的地址（以粗体显示）。表28-4包含了重叠NAT中四个步骤的完整解释。有关地址类型的解释，请参阅图28-1。")中所示。
- en: Overlapping NAT is used in situations where both the source and destination
    addresses in a datagram are private addresses or otherwise cannot be used regularly
    on the public Internet. In this case, unlike with the other types of NAT, the
    NAT router translates both the source and destination addresses of incoming and
    outgoing datagrams. On outgoing messages, *inside local* addresses are changed
    to *inside global* and *outside local* to *outside global*; on incoming messages,
    *inside global* addresses are changed to *inside local* and *outside global* addresses
    are changed to *outside local*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠NAT用于源地址和目的地址都是私有地址或无法在公共互联网上常规使用的场合。在这种情况下，与其它类型的NAT不同，NAT路由器将传入和传出数据报的源地址和目的地址都进行翻译。在传出消息中，*内部本地*地址被更改为*内部全局*，*外部本地*地址被更改为*外部全局*；在传入消息中，*内部全局*地址被更改为*内部本地*，*外部全局*地址被更改为*外部本地*。
- en: Table 28-4. Operation of Overlapping NAT/Twice NAT
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表28-4. Overlapping NAT/Twice NAT的操作
- en: '| Step # | Description | Datagram Type | Datagram Source Address | Datagram
    Destination Address |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 步骤编号 | 描述 | 数据报类型 | 数据报源地址 | 数据报目的地址 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | **Inside Client Generates Request and Sends to NAT Router**: Device 18.0.0.18
    generates a request using the destination 172.16.44.55, which it got from the
    (NAT-intercepted) DNS query for [www.twicenat.mit.edu](http://www.twicenat.mit.edu).
    The datagram is sent to the NAT router for the local network. | Request (from
    inside client to outside server) | 18.0.0.18 (inside local) | 172.16.44.55 (outside
    local) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **内部客户端生成请求并发送至NAT路由器**：设备18.0.0.18使用从（NAT拦截的）DNS查询得到的[www.twicenat.mit.edu](http://www.twicenat.mit.edu)的目的地址172.16.44.55生成一个请求。数据报被发送到本地网络的NAT路由器。
    | 请求（从内部客户端到外部服务器） | 18.0.0.18（内部本地） | 172.16.44.55（外部本地） |'
- en: '| 2 | **NAT Router Translates Source Address and Destination Address and Sends
    to Outside Server**: The NAT router makes two translations. First, it substitutes
    the 18.0.0.18 address with a publicly registered address, which is 194.54.21.12
    for this example. It then translates the bogus 172.16.44.55 back to the real MIT
    address for [www.twicenat.mit.edu](http://www.twicenat.mit.edu). It routes the
    datagram to the outside server. |   | 194.54.21.12 (inside global) | 18.1.2.3
    (outside global) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **NAT路由器翻译源地址和目的地址并发送至外部服务器**：NAT路由器进行两次翻译。首先，它将18.0.0.18地址替换为公开注册的地址，在这个例子中是194.54.21.12。然后，它将虚假的172.16.44.55地址翻译回真实的MIT地址[www.twicenat.mit.edu](http://www.twicenat.mit.edu)。它将数据报路由到外部服务器。
    |  | 194.54.21.12（内部全局） | 18.1.2.3（外部全局） |'
- en: '| 3 | **Outside Server Generates Response and Sends Back to NAT Router**: The
    MIT server at 18.1.2.3 generates a response and sends it back to 194.54.21.12,
    which causes it to arrive back at the NAT router. | Response (from outside server
    to inside client) | 18.1.2.3 (outside global) | 194.54.21.12 (inside global) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **外部服务器生成响应并发送回NAT路由器**：位于18.1.2.3的MIT服务器生成一个响应并将其发送回194.54.21.12，这导致它返回到NAT路由器。
    | 响应（从外部服务器到内部客户端） | 18.1.2.3（外部全局） | 194.54.21.12（内部全局） |'
- en: '| 4 | **NAT Router Translates Source Address and Destination Address and Delivers
    Datagram to the Inside Client**: The NAT router translates back the destination
    address to the actual address that''s being used for the inside client, as in
    regular NAT. It also substitutes back in the 172.16.44.55 value it is using as
    a substitute for the real address of [www.twicenat.mit.edu](http://www.twicenat.mit.edu).
    |   | 172.16.44.55 (outside local) | 18.0.0.18 (inside local) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **NAT路由器翻译源地址和目的地址并将数据报传递给内部客户端**：NAT路由器将目的地址翻译回实际用于内部客户端的地址，就像常规NAT一样。它还替换回它用作[www.twicenat.mit.edu](http://www.twicenat.mit.edu)真实地址替代的172.16.44.55值。
    | 172.16.44.55（外部本地） | 18.0.0.18（内部本地） |'
- en: As you can see, in this example, the *outside local* and *outside global* addresses
    are different, unlike in the preceding NAT examples. Twice NAT can also handle
    an inbound transaction by watching for datagrams coming in from the Internet that
    overlap with the addresses used on the local network and doing double substitutions
    as required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个例子中，*外部本地*和*外部全局*的地址是不同的，与前面的NAT例子不同。双NAT也可以通过监视从互联网进入的与本地网络使用的地址重叠的数据报来处理入站事务，并根据需要执行双重替换。
- en: IP NAT Compatibility Issues and Special Handling Requirements
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP NAT兼容性问题及特殊处理要求
- en: In a perfect world NAT could be made transparent to the devices using it. We
    would like to be able to have a NAT router change IP addresses in request datagrams
    as they leave the network and change them back in responses that come back, and
    have none of the hosts be any wiser. Unfortunately, this isn't a perfect world.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界中，NAT可以使其对使用它的设备透明。我们希望NAT路由器能够在数据报离开网络时更改IP地址，并在返回的响应中更改它们，并且没有任何主机会察觉到。不幸的是，这不是一个完美的世界。
- en: '![Operation of Overlapping NAT/Twice NAT This figure is very similar to , except
    that as you can see, the NAT router translates both source and destination addresses
    each time (shown in bold). contains a complete explanation of the four steps in
    overlapping NAT. Refer to for an explanation of address types.](httpatomoreillycomsourcenostarchimages287911.png.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![重叠NAT/双NAT的操作](http://atomoreilly.com/source/nostarch/images/287911.png.jpg)
    此图与非常相似，但如您所见，NAT路由器每次都翻译源地址和目的地址（以粗体显示）。包含重叠NAT四个步骤的完整解释。有关地址类型的解释，请参阅。'
- en: Figure 28-5. Operation of Overlapping NAT/Twice NAT This figure is very similar
    to [Figure 28-2](ch28s04.html#operation_of_unidirectional_tradit-id001 "Figure 28-2. Operation
    of unidirectional (traditional/outbound) NAT You can see the four steps in this
    process by following the steps in clockwise order. Translated addresses are shown
    in bold. Refer to Table 28-1 and Figure 28-1 for an explanation of the four address
    types."), except that as you can see, the NAT router translates both source and
    destination addresses each time (shown in bold). [Table 28-4](ch28s07.html#operation_of_overlapping_nattwice_nat
    "Table 28-4. Operation of Overlapping NAT/Twice NAT") contains a complete explanation
    of the four steps in overlapping NAT. Refer to [Figure 28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "Figure 28-1. IP Network Address Translation (NAT) terminology Hopefully this
    diagram will help you to better understand the whole "inside/outside/local/global"
    thing.") for an explanation of address types.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图28-5. 重叠NAT/双NAT的操作 此图与[图28-2](ch28s04.html#operation_of_unidirectional_tradit-id001
    "图28-2. 单向（传统/出站）NAT 通过按顺时针方向遵循这些步骤，您可以看到此过程中的四个步骤。以粗体显示的翻译地址。请参阅表28-1和图28-1以了解四种地址类型的解释。")非常相似，但如您所见，NAT路由器每次都翻译源地址和目的地址（以粗体显示）。[表28-4](ch28s07.html#operation_of_overlapping_nattwice_nat
    "表28-4. 重叠NAT/双NAT的操作")包含重叠NAT四个步骤的完整解释。有关地址类型的解释，请参阅[图28-1](ch28s02.html#ip_network_address_translation_nat_termi
    "图28-1. IP网络地址转换（NAT）术语 希望此图能帮助您更好地理解整个“内部/外部/本地/全局”的概念。")。
- en: It is not possible for NAT to be completely transparent to the devices that
    use it. There are potential compatibility problems that arise if NAT doesn't perform
    certain functions. These functions go beyond simply swapping IP addresses and
    possibly port numbers in the IP header. The main problem is that even though IP
    addresses are supposedly the domain of IP, they are really used by other protocols
    as well, both at the network layer and in higher layers. When NAT changes the
    IP address in an IP datagram, it must often also change addresses in other places
    to make sure that the addresses in various headers and payloads still match.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: NAT不可能对其使用的设备完全透明。如果NAT不执行某些功能，可能会出现潜在的兼容性问题。这些功能不仅涉及在IP头部中简单地交换IP地址和可能端口号，还涉及更多。主要问题是尽管IP地址被认为是IP的领域，但它们实际上也被其他协议使用，无论是在网络层还是在更高层。当NAT更改IP数据报中的IP地址时，它通常还必须更改其他地方地址，以确保各种头部和负载中的地址仍然匹配。
- en: These compatibility issues require that even though NAT should theoretically
    work only at the level of IP at the network layer, in practical terms, NAT routers
    must be aware of many more protocols and perform special operations as required.
    Some are required for all datagrams that are translated; others only apply to
    certain datagrams and not others. And even when these techniques are added to
    NAT routers, some things still may not work properly in a NAT environment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些兼容性问题要求尽管NAT在理论上应在网络层的IP级别工作，但在实际应用中，NAT路由器必须了解许多更多协议并根据需要执行特殊操作。其中一些是所有转换数据报所需的；其他则仅适用于某些数据报而不适用于其他数据报。即使在NAT路由器中添加了这些技术，某些事情在NAT环境中仍然可能无法正常工作。
- en: 'Let''s take a look at some of the main issues and requirements:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些主要问题和要求：
- en: '**TCP and UDP Checksum Recalculations** Changing the IP addresses in the IP
    header means that the IP header checksum must be calculated. Since both UDP and
    TCP also have checksums, and these checksums are computed over a pseudo header
    that contains the IP source and destination address as well, they too, must be
    recalculated each time a translation is made.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP和UDP校验和重新计算** 在IP头部更改IP地址意味着必须计算IP头部校验和。由于UDP和TCP也有校验和，并且这些校验和是在包含IP源地址和目标地址的伪头部上计算的，因此它们也必须在每次转换时重新计算。'
- en: '**ICMP Manipulations** Since NAT works so intimately with IP headers, and since
    IP is closely related to its "assistant" protocol the Internet Control Management
    Protocol (ICMP; see [Chapter 31](ch31.html "Chapter 31. ICMP CONCEPTS AND GENERAL
    OPERATION")), NAT must also look for certain ICMP messages and make changes to
    addresses contained within them. Many ICMP messages, such as Destination Unreachable
    and Parameter Problem, contain the original IP header of the datagram that lead
    to the ICMP message as data. Since NAT is translating addresses in IP headers,
    it must watch for these messages and translate addresses in included headers as
    required.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**ICMP操作** 由于NAT与IP头部紧密协作，并且由于IP与其“助手”协议互联网控制消息协议（ICMP；见[第31章](ch31.html "第31章.
    ICMP概念和一般操作"））密切相关，因此NAT还必须查找某些ICMP消息并对其中包含的地址进行更改。许多ICMP消息，如目标不可达和参数问题，包含导致ICMP消息的数据报的原始IP头部。由于NAT正在转换IP头部中的地址，它必须监视这些消息并根据需要转换包含的头部中的地址。'
- en: '**Applications That Embed IP Addresses** A number of TCP/IP applications embed
    IP addresses within the actual application data payload. The most notorious example
    of this is FTP, which actually sends address and port assignments as text information
    in datagrams between devices during a connection. In order for NAT to support
    FTP, it must be specifically programmed with algorithms to look for this information
    and make changes as needed. The level of complication can go even beyond this.
    Consider what happens when an FTP message containing these text addresses or port
    numbers is *fragmented*. Part of the address that will be translated may be in
    two different IP datagrams and may be hard to recognize!'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入IP地址的应用程序** 许多TCP/IP应用程序在实际的应用数据负载中嵌入IP地址。最著名的例子是FTP，它实际上在连接期间通过设备之间的数据报发送地址和端口号分配作为文本信息。为了使NAT支持FTP，它必须特别编程以查找这些信息并根据需要做出更改。复杂程度甚至可能超过这一点。考虑一下当包含这些文本地址或端口号的FTP消息被*分段*时会发生什么。将被转换的部分地址可能位于两个不同的IP数据报中，可能难以识别！'
- en: '**Additional Issues with Port Translation** When Port-Based NAT (PAT) is used,
    the previous issues that apply to addresses now apply to ports as well, making
    even more work for the router to perform.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口转换的附加问题** 当使用基于端口的NAT（PAT）时，适用于地址的先前问题现在也适用于端口，这使得路由器需要执行更多的工作。'
- en: '**Cascading Impact of Changes to Address or Port Numbers** Take the example
    of an FTP datagram encoding an IP address that NAT must change. The address being
    substituted might require more characters than the original; in the first example,
    10.0.0.207 (10 ASCII characters) is replaced by 194.54.21.11 (12 ASCII characters).
    Making this substitution changes the size of the payload! This means that TCP
    sequence numbers (see [Chapter 46](ch46.html "Chapter 46. TRANSMISSION CONTROL
    PROTOCOL (TCP) FUNDAMENTALS AND GENERAL OPERATION")) also must be modified. In
    these situations, NAT itself is supposed to take care of any additional work that
    may be required.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址或端口号更改的级联影响** 以FTP数据报为例，该数据报编码的IP地址NAT必须更改。被替换的地址可能需要比原始地址更多的字符；在第一个例子中，10.0.0.207（10个ASCII字符）被替换为194.54.21.11（12个ASCII字符）。这种替换改变了有效载荷的大小！这意味着TCP序列号（见[第46章](ch46.html
    "第46章。传输控制协议（TCP）的基本原理和一般操作"））也必须修改。在这些情况下，NAT本身应该负责可能需要的任何额外工作。'
- en: '**Problems with IPsec** When IPsec is used in transport mode, both the Authentication
    Header (AH) and Encapsulating Security Payload (ESP) protocols use an integrity
    check that is based on the value of the entire payload. When NAT tries to update
    the TCP or UDP checksum in the IP datagram, this changes the value of data that
    the receiving device uses in performing the AH or ESP integrity check. The check
    will fail. Thus, NAT can''t be used in IPsec transport mode. It may still work
    in tunnel mode, but there can be complications here as well.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPsec的问题** 当IPsec在传输模式下使用时，认证头（AH）和封装安全载荷（ESP）协议都使用基于整个有效载荷值的完整性检查。当NAT尝试更新IP数据报中的TCP或UDP校验和时，这会改变接收设备在执行AH或ESP完整性检查时使用的数据值。检查将失败。因此，NAT不能在IPsec传输模式下使用。它可能在隧道模式下仍然工作，但这里也可能存在一些复杂性。'
- en: Most NAT implementations do take at least some of the previous issues into account.
    Certainly, common applications like FTP are widely supported by NAT routers, or
    no one would want to use NAT. That said, there might be some applications that
    will not work over NAT. The fact that NAT really isn't transparent and must do
    these extra sorts of "hacks" to other protocol headers and even payloads is a
    big part of the reason why many people refer to NAT as a kludge; elegant solutions
    don't have so many special cases that need special handling.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数NAT实现确实至少考虑了先前的一些问题。当然，像FTP这样的常见应用程序得到了NAT路由器的广泛支持，否则没有人会想使用NAT。话虽如此，可能有一些应用程序无法通过NAT工作。NAT实际上并不透明，必须对这些额外的“黑客”操作进行其他协议头甚至有效载荷，这是许多人将NAT称为修补品的原因之一；优雅的解决方案不会有这么多需要特殊处理的特殊情况。
- en: Chapter 29. IP SECURITY (IPSEC) PROTOCOLS
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第29章。IP安全（IPSEC）协议
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: One of the weaknesses of the original Internet Protocol (IP) is that it lacks
    any sort of general-purpose mechanism for ensuring the authenticity and privacy
    of data as it is passed over the internetwork. Since IP datagrams must usually
    be routed between two devices over unknown networks, any information in them is
    subject to being intercepted and even possibly changed. With the increased use
    of the Internet for critical applications, security enhancements were needed for
    IP. To this end, a set of protocols called *IP Security* or *IPsec* was developed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 原始互联网协议（IP）的一个弱点是，它在数据通过互联网传输时缺乏任何通用机制来确保数据的真实性和隐私。由于IP数据报通常需要在两个设备之间通过未知网络进行路由，因此其中的任何信息都可能被截获，甚至可能被更改。随着互联网在关键应用中的使用增加，IP需要增强安全性。为此，开发了一套称为*IP安全*或*IPsec*的协议。
- en: 'In this chapter, I provide a brief description of IPsec concepts and protocols.
    I begin with an overview of IPsec, including a discussion of the history of the
    technology and a definition of the standards. I describe the main components and
    protocols of the IPsec suite and its different architectures and methods for implementation.
    I then move to actually discussing how IPsec works, beginning with a description
    of the two IPsec modes (transport and tunnel) and how they differ. I describe
    security associations and related constructs such as the Security Parameter Index
    (SPI). The last three topics cover the three main IPsec protocols: IPsec Authentication
    Header (AH), IPsec Encapsulating Security Payload (ESP), and the IPsec Internet
    Key Exchange (IKE).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要介绍了IPsec的概念和协议。我首先概述了IPsec，包括对这项技术历史的讨论和标准的定义。我描述了IPsec套件的主要组件和协议，以及其实施的不同架构和方法。然后，我转向实际讨论IPsec的工作原理，从对两种IPsec模式（传输和隧道）及其差异的描述开始。我描述了安全关联和相关结构，如安全参数索引（SPI）。最后三个主题涵盖了三个主要的IPsec协议：IPsec认证头（AH）、IPsec封装安全载荷（ESP）和IPsec互联网密钥交换（IKE）。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*IPsec was initially developed with IPv6 in mind, but has been engineered to
    provide security for both IPv4 and IPv6 networks, and operation in both versions
    is similar. There are some differences in the datagram formats used for AH and
    ESP. These differences depend on whether you use IPsec in IPv4 or IPv6, because
    the two versions have different datagram formats and addressing. I highlight these
    differences where appropriate.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPsec最初是为了IPv6而开发的，但已被设计为为IPv4和IPv6网络提供安全，且两种版本的操作相似。AH和ESP使用的数据报格式有所不同。这些差异取决于你在IPv4还是IPv6中使用IPsec，因为两个版本有不同的数据报格式和寻址方式。我在适当的地方突出了这些差异。*'
- en: IPsec Overview, History, and Standards
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec概述、历史和标准
- en: 'The big problem with the original IP version (IPv4) is the pending exhaustion
    of its address space. This situation arose due to the rapid expansion of the Internet
    beyond anyone''s expectations when IPv4 was developed. This same mismatch between
    how the Internet was when IPv4 was created and how it is now has led to another
    major problem with IP: the lack of a definitive means of ensuring security on
    IP internetworks.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 原始IP版本（IPv4）的大问题是其地址空间的即将耗尽。这种情况是由于IPv4开发时，互联网的快速扩张超出了任何人的预期。IPv4创建时互联网的状态与现在的状态之间的这种不匹配，导致了IP的另一个主要问题：缺乏确保IP互联网安全的确切手段。
- en: The security problem arose because 25 years ago, the Internet was tiny and relatively
    private. Today it is enormous and truly public. As the Internet has grown, the
    need for security has grown with it. Consider that TCP/IP and the early Internet
    precursors were developed as very small networks used by government researchers
    at the United States Defense Advanced Research Projects Agency (*DARPA* or *ARPA*).
    People who were well known and would generally have had security clearance controlled
    all the hardware. In such a network, you don't need to build security in to the
    protocols—you build it into the building! It's easier to use locks and guards
    to ensure security than fancy encryption. The easiest way to keep someone from
    snooping or tampering with data on the network is simply to deny them access to
    the hosts that connect to the network.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 安全问题产生的原因是，25年前，互联网很小且相对私密。如今，它变得巨大且真正公开。随着互联网的增长，对安全的需求也随之增长。考虑一下，TCP/IP和早期互联网先驱是在美国国防部高级研究计划局（DARPA或ARPA）的研究人员使用的小型网络中开发的。那些知名人士通常会有安全许可，控制着所有硬件。在这样的网络中，你不需要在协议中构建安全——你将其构建在建筑中！使用锁和守卫来确保安全比使用复杂的加密要容易。防止某人窃听或篡改网络上的数据的最佳方式就是简单地拒绝他们访问连接到网络的宿主。
- en: This worked fine at first when there were only a few dozen machines on the Internet.
    And even when the Internet first started to grow, it was used pretty much only
    to connect together researchers and other networking professionals. New sites
    were added to the network slowly at first, and at least someone knew the identity
    of each new site added to the growing internetwork. However, as the Internet continued
    to increase in size and was eventually opened to the public, maintaining security
    of the network as a whole became impossible. Today, the "great unwashed masses"
    are on the Internet. Many routers—owned by "who knows" and administered by "who
    knows"—stand between you and most other devices you want to connect with. You
    cannot assume that the data you send or receive is secure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初只有几十台机器在互联网上时，这种方法运行良好。即使互联网最初开始增长时，它也主要用于连接研究人员和其他网络专业人士。最初，新网站缓慢地被添加到网络中，而且至少有人知道每个新添加到不断增长的网络中的网站的身份。然而，随着互联网的持续增长并最终向公众开放，维护整个网络的安全性变得不可能。如今，“广大无知的群众”都在互联网上。许多路由器——由“谁知道”拥有并由“谁知道”管理——介于你和其他你想要连接的设备之间。你不能假设你发送或接收的数据是安全的。
- en: A number of methods have evolved over the years to address the need for security.
    Most of these are focused at the higher layers of the OSI protocol stack in order
    to compensate for IP's lack of security. These solutions are valuable for certain
    situations, but they can't be generalized easily because they are particular to
    various applications. For example, we can use Secure Sockets Layer (SSL) for certain
    applications like World Wide Web access or File Transfer Protocol (FTP), but there
    are dozens of applications that this type of security was never intended to work
    with.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，已经发展出多种方法来满足对安全性的需求。其中大多数都集中在OSI协议栈的高层，以弥补IP安全性的不足。这些解决方案在某些情况下很有价值，但它们不能轻易推广，因为它们针对的是各种不同的应用。例如，我们可以使用安全套接字层（SSL）来处理某些应用，如万维网访问或文件传输协议（FTP），但还有数十种应用这种类型的网络安全从未打算与之配合。
- en: What was really needed was a solution to allow security at the IP level so all
    higher-layer protocols in TCP/IP could take advantage of it. When the decision
    was made to develop a new version of IP (IPv6), this was the golden opportunity
    to resolve not just the addressing problems in the older IPv4, but the lack of
    security as well. New security technology was developed with IPv6 in mind, but
    since IPv6 has taken years to develop and roll out, and the need for security
    is now, the solution was designed to be usable for both IPv4 and IPv6.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 真正需要的是一种允许在IP层实现安全性的解决方案，以便TCP/IP的所有高层协议都能从中受益。当决定开发新的IP版本（IPv6）时，这是解决不仅包括旧IPv4的寻址问题，还包括安全不足的黄金机会。针对IPv6开发的新安全技术，但由于IPv6的开发和部署耗时多年，而安全需求现在就存在，因此解决方案被设计成可以用于IPv4和IPv6。
- en: The technology that brings secure communications to the IP is called *IP Security*,
    commonly abbreviated *IPsec.* The capitalization of this abbreviation is variable,
    so you'll see IPSec and IPSEC.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全通信带给IP的技术被称为*IP安全*，通常缩写为*IPsec.* 这个缩写的首字母大小写是可变的，所以你会看到IPSec和IPSEC。
- en: Overview of IPsec Services and Functions
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPsec服务和功能的概述
- en: 'IPsec is not a single protocol, but rather a set of services and protocols
    that provide a complete security solution for an IP network. These services and
    protocols combine to provide various types of protection. Since IPsec works at
    the IP layer, it can provide these protections for any higher-layer TCP/IP application
    or protocol without the need for additional security methods, which is a major
    strength. Some of the kinds of protection services offered by IPsec include the
    following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec不是一个单独的协议，而是一组服务和协议，为IP网络提供完整的解决方案。这些服务和协议结合在一起提供各种类型的保护。由于IPsec在IP层工作，它可以提供这些保护，而无需额外的安全方法，这对于任何高层TCP/IP应用或协议来说是一个主要优势。IPsec提供的一些保护服务包括以下内容：
- en: Encryption of user data for privacy
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密用户数据以保护隐私
- en: Authentication of the integrity of a message to ensure that it is not changed
    en route
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证消息的完整性以确保它在传输过程中未被更改
- en: Protection against certain types of security attacks, such as replay attacks
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止某些类型的网络安全攻击，例如重放攻击
- en: The ability for devices to negotiate the security algorithms and keys required
    to meet their security needs
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备协商满足其安全需求所需的安全算法和密钥的能力
- en: Two security modes, tunnel and transport, to meet different network needs
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种安全模式，隧道和传输，以满足不同的网络需求
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** *IPsec* is a contraction of *IP Security*, and it consists
    of a set of services and protocols that provide security to IP networks. It is
    defined by a sequence of several Internet standards.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *IPsec* 是 *IP安全* 的缩写，它由一系列提供IP网络安全的服务和协议组成。它由一系列互联网标准定义。'
- en: IPsec Standards
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPsec标准
- en: Since IPsec is actually a collection of techniques and protocols, it is not
    defined in a single Internet standard. Instead, a collection of RFCs defines the
    architecture, services, and specific protocols used in IPsec. Some of the most
    important of these are shown in [Table 29-1](ch29.html#important_ip_security_ipsec_standards
    "Table 29-1. Important IP Security (IPsec) Standards"), all of which were published
    in November 1998.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IPsec实际上是一系列技术和协议的集合，它不是由一个单一互联网标准定义的。相反，一系列RFC定义了IPsec的架构、服务和使用的特定协议。其中一些最重要的如下所示[表29-1](ch29.html#important_ip_security_ipsec_standards
    "表29-1. 重要的IP安全（IPsec）标准")，所有这些都是在1998年11月发布的。
- en: Table 29-1. Important IP Security (IPsec) Standards
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 表29-1. 重要的IP安全（IPsec）标准
- en: '| RFC Number | Name | Description |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| RFC编号 | 名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2401 | Security Architecture for the Internet Protocol | The main IPsec document,
    describing the architecture and general operation of the technology, and showing
    how the different components fit together. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 2401 | 互联网协议的安全架构 | 主要的IPsec文档，描述了该技术的架构和通用操作，并展示了不同组件如何相互配合。|'
- en: '| 2402 | IP Authentication Header | Defines the IPsec Authentication Header
    (AH) protocol, which is used for ensuring data integrity and origin verification.
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 2402 | IP认证头 | 定义了IPsec认证头（AH）协议，该协议用于确保数据完整性和来源验证。|'
- en: '| 2403 | The Use of HMAC-MD5-96 within ESP and AH | Describes a particular
    encryption algorithm for use by the AH and Encapsulation Security Payload (ESP)
    protocols called Message Digest 5 (MD5), HMAC variant. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 2403 | HMAC-MD5-96在ESP和AH中的使用 | 描述了用于AH和封装安全载荷（ESP）协议的特定加密算法，称为消息摘要5（MD5），HMAC变体。|'
- en: '| 2404 | The Use of HMAC-SHA-1-96 within ESP and AH | Describes a particular
    encryption algorithm for use by AH and ESP called Secure Hash Algorithm 1 (SHA-1),
    HMAC variant. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 2404 | HMAC-SHA-1-96在ESP和AH中的使用 | 描述了用于AH和ESP的特定加密算法，称为安全哈希算法1（SHA-1），HMAC变体。|'
- en: '| 2406 | IP Encapsulating Security Payload (ESP) | Describes the IPsec ESP
    protocol, which provides data encryption for confidentiality. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 2406 | IP封装安全载荷（ESP） | 描述了IPsec ESP协议，该协议提供数据加密以实现机密性。|'
- en: '| 2408 | Internet Security Association and Key Management Protocol (ISAKMP)
    | Defines methods for exchanging keys and negotiating security associations. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 2408 | 互联网安全关联和密钥管理协议（ISAKMP） | 定义了交换密钥和协商安全关联的方法。|'
- en: '| 2409 | The Internet Key Exchange (IKE) | Describes the IKE protocol that''s
    used to negotiate security associations and exchange keys between devices for
    secure communications. Based on ISAKMP and OAKLEY. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 2409 | 互联网密钥交换（IKE） | 描述了IKE协议，用于在设备之间协商安全关联和交换密钥以实现安全通信。基于ISAKMP和OAKLEY。|'
- en: '| 2412 | The OAKLEY Key Determination Protocol | Describes a generic protocol
    for key exchange. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 2412 | OAKLEY密钥确定协议 | 描述了一种通用的密钥交换协议。|'
- en: Deployment of IPsec has only really started to take off in the last few years.
    A major use of the technology is in implementing virtual private networks (VPNs).
    It appears that the future is bright for IPsec, as more and more individuals and
    companies decide that they need to take advantage of the power of the Internet,
    while also protecting the security of the data they transport over it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec的部署仅在最近几年真正开始起飞。该技术的重大用途在于实现虚拟专用网络（VPN）。似乎IPsec的未来光明，因为越来越多的个人和公司决定他们需要利用互联网的力量，同时保护他们通过它传输的数据的安全性。
- en: IPsec General Operation, Components, and Protocols
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec通用操作、组件和协议
- en: IPsec isn't the only difficult topic in this book, but it is definitely a subject
    that baffles many. Most discussions of it jump straight to describing the mechanisms
    and protocols, without providing a general description of what it does and how
    the pieces fit together. Well, I recognized that IPsec is important, and I don't
    shy away from a challenge. Thus, here's my attempt to provide a framework for
    understanding IPsec's various bits and pieces.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec并不是这本书中唯一困难的主题，但它无疑是令许多人困惑的主题。大多数关于它的讨论都直接跳到描述机制和协议，而没有提供关于它做什么以及各个部分如何组合的一般描述。好吧，我认识到IPsec的重要性，并且我不回避挑战。因此，这是我尝试为理解IPsec的各种片段提供一个框架的尝试。
- en: 'So what exactly does IPsec do, and how does it do it? In general terms, it
    provides security services at the IP layer for other TCP/IP protocols and applications
    to use. What this means is that IPsec provides the tools that devices on a TCP/IP
    network need in order to communicate securely. When two devices (either end-user
    hosts or intermediate devices such as routers or firewalls) want to engage in
    secure communications, they set up a *secure path* between themselves that may
    traverse across many insecure intermediate systems. To accomplish this, they must
    perform (at least) the following tasks:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，IPsec究竟做了什么，又是如何做到的？从一般意义上讲，它为其他TCP/IP协议和应用提供了IP层的安全服务。这意味着IPsec提供了TCP/IP网络上的设备在安全通信时所需的工具。当两个设备（无论是终端用户主机还是中间设备，如路由器或防火墙）想要进行安全通信时，它们需要在彼此之间建立一个*安全路径*，这个路径可能跨越许多不安全的中间系统。为了实现这一点，它们必须执行（至少）以下任务：
- en: They must agree on a set of security protocols to use so that each one sends
    data in a format the other can understand.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须就使用的一组安全协议达成一致，以便每个设备都能以对方能理解的方式发送数据。
- en: They must decide on a specific encryption algorithm to use in encoding data.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须决定在编码数据时使用特定的加密算法。
- en: They must exchange keys that are used to "unlock" data that has been cryptographically
    encoded.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须交换用于“解锁”加密数据的密钥。
- en: Once this background work is completed, each device must use the protocols,
    methods, and keys previously agreed upon to encode data and send it across the
    network.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦完成这项背景工作，每个设备都必须使用之前商定的协议、方法和密钥来编码数据并将其发送到网络上。
- en: IPsec Core Protocols
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPsec核心协议
- en: 'To support these activities, a number of different components make up the total
    package known as IPsec, as shown in [Figure 29-1](ch29s02.html#overview_of_ipsec_protocols_and_componen
    "Figure 29-1. Overview of IPsec protocols and components IPsec consists of two
    core protocols, AH and ESP, and three supporting components."). The two main pieces
    are a pair of technologies sometimes called the *core protocols* of IPsec, which
    actually do the work of encoding information to ensure security:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这些活动，许多不同的组件共同构成了被称为IPsec的总套件，如图[图29-1](ch29s02.html#overview_of_ipsec_protocols_and_componen
    "图29-1. IPsec协议和组件概述 IPsec由两个核心协议AH和ESP以及三个支持组件组成。")所示。其中两个主要部分是一对有时被称为IPsec的*核心协议*的技术，实际上负责将信息编码以确保安全：
- en: '**IPsec Authentication Header (AH)** This protocol provides authentication
    services for IPsec. It allows the recipient of a message to verify that the supposed
    originator of a message was actually fact the one that sent it. It also allows
    the recipient to verify that intermediate devices en route haven''t changed any
    of the data in the datagram. It also provides protection against so-called *replay
    attacks*, whereby a message is captured by an unauthorized user and resent.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPsec认证头（AH）** 此协议为IPsec提供认证服务。它允许消息的接收者验证消息的所谓发送者实际上是发送者本人。它还允许接收者验证途中经过的中间设备没有更改数据报文中的任何数据。它还提供了针对所谓的*重放攻击*的保护，即一个消息被未经授权的用户捕获并重新发送。'
- en: '**Encapsulating Security Payload (ESP)** AH ensures the integrity of the data
    in datagram, but not its privacy. When the information in a datagram is "for your
    eyes only," it can be further protected using ESP, which encrypts the payload
    of the IP datagram.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装安全载荷（ESP）** AH确保数据报文的完整性，但不保证其隐私性。当数据报文中的信息“仅供你一人知晓”时，可以使用ESP进一步保护，ESP会加密IP数据报文的负载。'
- en: '![Overview of IPsec protocols and components IPsec consists of two core protocols,
    AH and ESP, and three supporting components.](httpatomoreillycomsourcenostarchimages287913.png.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec协议和组件概述 IPsec由两个核心协议AH和ESP以及三个支持组件组成。](httpatomoreillycomsourcenostarchimages287913.png.jpg)'
- en: Figure 29-1. Overview of IPsec protocols and components IPsec consists of two
    core protocols, AH and ESP, and three supporting components.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-1. IPsec 协议和组件概述 IPsec 包含两个核心协议，AH 和 ESP，以及三个支持组件。
- en: IPsec Support Components
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPsec 支持组件
- en: 'AH and ESP are commonly called *protocols*, though this is another case where
    the use of this term is debatable. They are not really distinct protocols but
    are implemented as headers that are inserted into IP datagrams, as you will see.
    They thus do the "grunt work" of IPsec, and can be used together to provide both
    authentication and privacy. However, they cannot operate on their own. To function
    properly, they need the support of several other protocols and services (see [Figure 29-1](ch29s02.html#overview_of_ipsec_protocols_and_componen
    "Figure 29-1. Overview of IPsec protocols and components IPsec consists of two
    core protocols, AH and ESP, and three supporting components.")). The most important
    of these include the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: AH 和 ESP 通常被称为 *协议*，尽管这又是一个这个术语使用有争议的例子。它们实际上并不是独立的协议，而是作为插入到 IP 数据报中的头部来实现，正如你将看到的。因此，它们完成了
    IPsec 的“基础工作”，可以一起使用以提供认证和隐私。然而，它们不能独立运行。为了正常工作，它们需要其他几个协议和服务的支持（参见 [图 29-1](ch29s02.html#overview_of_ipsec_protocols_and_componen
    "图 29-1. IPsec 协议和组件概述 IPsec 包含两个核心协议，AH 和 ESP，以及三个支持组件。"））。其中最重要的包括以下内容：
- en: '**Encryption/Hashing Algorithms** AH and ESP are generic and do not specify
    the exact mechanism used for encryption. This gives them the flexibility to work
    with a variety of such algorithms and to negotiate which one to use as needed.
    Two common ones used with IPsec are *Message Digest 5 (MD5)* and *Secure Hash
    Algorithm 1 (SHA-1)*. These are also called *hashing* algorithms because they
    work by computing a formula called a *hash* based on input data and a key.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密/哈希算法** AH 和 ESP 是通用的，并不指定用于加密的确切机制。这使它们能够灵活地与各种算法一起工作，并根据需要协商使用哪种算法。与
    IPsec 一起使用的两种常见算法是 *消息摘要 5 (MD5)* 和 *安全哈希算法 1 (SHA-1)*。这些算法也被称为 *哈希* 算法，因为它们通过基于输入数据和密钥计算一个称为
    *哈希* 的公式来工作。'
- en: '**Security Policies, Security Associations, and Management Methods** Since
    IPsec provides flexibility in letting different devices decide how they want to
    implement security, they require some means to keep track of the security relationships
    between themselves. This is done in IPsec using constructs called *security policies*
    and *security associations*, and by providing ways to exchange security association
    information.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全策略、安全关联和管理方法** 由于 IPsec 允许不同的设备决定如何实现安全策略，因此它们需要一些方法来跟踪它们之间的安全关系。在 IPsec
    中，这是通过称为 *安全策略* 和 *安全关联* 的结构来实现的，并提供交换安全关联信息的方式。'
- en: '**Key Exchange Framework and Mechanism** For two devices to exchange encrypted
    information, they need to be able to share keys for unlocking the encryption.
    They also need a way to exchange security association information. In IPsec, a
    protocol called the *Internet Key Exchange (IKE)* provides these capabilities.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥交换框架和机制** 为了两个设备能够交换加密信息，它们需要能够共享用于解密密钥。它们还需要一种交换安全关联信息的方式。在 IPsec 中，一个名为
    *互联网密钥交换 (IKE)* 的协议提供了这些功能。'
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** IPsec consists of a number of different components that work
    together to provide security services. The two main ones are protocols called
    the *Authentication Header (AH)* and *Encapsulating Security Payload (ESP)*, which
    provide authenticity and privacy to IP data in the form of special headers added
    to IP datagrams.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPsec 包含多个不同的组件，它们协同工作以提供安全服务。其中两个主要组件是名为 *认证头 (AH)* 和 *封装安全载荷 (ESP)*
    的协议，它们通过在 IP 数据报中添加特殊头部的方式，为 IP 数据提供真实性和隐私性。'
- en: Well, that's at least a start at providing a framework for understanding what
    IPsec is all about and how the pieces fit together. You'll examine these components
    and protocols in more detail as you proceed through this chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这至少为理解 IPsec 的概念以及各个部分如何协同工作提供了一个框架。随着你继续阅读本章，你将更详细地研究这些组件和协议。
- en: IPsec Architectures and Implementation Methods
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec 架构与实现方法
- en: The main reason that IPsec is so powerful is that it provides security to IP,
    which is the basis for all other TCP/IP protocols. In protecting IP, you are protecting
    pretty much everything else in TCP/IP as well. An important issue, then, is how
    exactly do you get IPsec into IP? There are several implementation methods for
    deploying IPsec. These represent different ways that IPsec may modify the overall
    layer architecture of TCP/IP.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec之所以如此强大，主要原因是它为IP提供了安全保护，而IP是所有其他TCP/IP协议的基础。在保护IP的同时，你也在保护TCP/IP中的几乎所有其他内容。因此，一个重要的问题是，你如何将IPsec精确地集成到IP中？部署IPsec有几种实现方法。这些方法代表了IPsec可能修改TCP/IP整体层架构的不同方式。
- en: 'Three different implementation architectures are defined for IPsec in RFC 2401\.
    The one you use depends on various factors including the version of IP used (IPv4
    or IPv6), the requirements of the application, and other factors. These, in turn,
    rest on a primary implementation decision: Should IPsec be programmed into all
    hosts on a network, or just into certain routers or other intermediate devices?
    This is a design decision that must be based on the requirements of the network:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 2401中为IPsec定义了三种不同的实现架构。你使用哪一种取决于多种因素，包括使用的IP版本（IPv4或IPv6）、应用的需求以及其他因素。这些因素又基于一个主要实现决策：IPsec应该被编程到网络上的所有主机中，还是仅编程到某些路由器或其他中间设备中？这是一个必须基于网络需求的设计决策：
- en: '**End-Host Implementation** Putting IPsec into all host devices provides the
    most flexibility and security. It enables end-to-end security between any two
    devices on the network. However, there are many hosts on a typical network, so
    this means far more work than just implementing IPsec in routers.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**端点主机实现** 将IPsec集成到所有主机设备中提供了最大的灵活性和安全性。它使得网络中任何两个设备之间都能实现端到端的安全。然而，典型网络上有许多主机，这意味着这比仅在路由器中实现IPsec的工作量要大得多。'
- en: '**Router Implementation** This option is much less work because it means you
    make changes to only a few routers instead of hundreds or thousands of clients.
    It provides protection only between pairs of routers that implement IPsec, but
    this may be sufficient for certain applications such as VPNs. The routers can
    be used to provide protection for just the portion of the route that datagrams
    take outside the organization, thereby leaving connections between routers and
    local hosts unsecured (or possibly, secured by other means).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由器实现** 这个选项工作量要小得多，因为它意味着你只需对少数几个路由器进行更改，而不是数百或数千个客户端。它只提供实现IPsec的路由器对之间的保护，但这可能对于某些应用，如VPN，已经足够了。路由器可以用来仅保护数据报在组织外部路由的部分，从而使得路由器和本地主机之间的连接保持未加密（或者可能通过其他方式加密）。'
- en: 'Three different architectures are defined that describe methods for how to
    get IPsec into the TCP/IP protocol stack: integrated, bump in the stack, and bump
    in the wire.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了三种不同的架构，描述了将IPsec集成到TCP/IP协议栈中的方法：集成架构、栈中凸起（BITS）架构和线中凸起（Bump in the Wire）。
- en: Integrated Architecture
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成架构
- en: Under ideal circumstances, we would integrate IPsec's protocols and capabilities
    directly into IP itself. This is the most elegant solution, because it allows
    all IPsec security modes and capabilities to be provided just as easily as regular
    IP. No extra hardware or architectural layers are needed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，我们会将IPsec的协议和能力直接集成到IP本身中。这是最优雅的解决方案，因为它允许像常规IP一样轻松地提供所有IPsec安全模式和功能。不需要额外的硬件或架构层。
- en: IPv6 was designed to support IPsec. Thus, it's a viable option for hosts or
    routers. With IPv4, integration would require making changes to the IP implementation
    on each device, which is often impractical (to say the least!).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6被设计用来支持IPsec。因此，它对于主机或路由器来说是一个可行的选项。对于IPv4，集成需要修改每个设备上的IP实现，这在很大程度上是不切实际的（至少可以说）。
- en: Bump in the Stack (BITS) Architecture
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈中凸起（BITS）架构
- en: In the bump in the stack (BITS) technique, IPsec is made a separate architectural
    layer between IP and the data link layer. The cute name refers to the fact that
    IPsec is an extra element in the networking protocol stack, as you can see in
    [Figure 29-2](ch29s03.html#ipsec_bump_in_the_stack_bits_architectur "Figure 29-2. IPsec
    bump in the stack (BITS) architecture In this type of IPsec implementation, IPsec
    becomes a separate layer in the TCP/IP stack. It is implemented as software that
    sits below IP and adds security protection to datagrams created by the IP layer.").
    IPsec intercepts IP datagrams as they are passed down the protocol stack, provides
    security, and passes them to the data link layer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈中断（BITS）技术中，IPsec 被作为一个独立的架构层置于 IP 和数据链路层之间。这个可爱的名字指的是 IPsec 是网络协议堆栈中的一个额外元素，正如您可以在[图
    29-2](ch29s03.html#ipsec_bump_in_the_stack_bits_architectur "图 29-2. IPsec 堆栈中断（BITS）架构
    在这种类型的 IPsec 实现中，IPsec 成为了 TCP/IP 堆栈中的一个独立层。它作为位于 IP 之下的软件实现，并为 IP 层创建的数据报提供安全保护。")中看到的那样。IPsec
    在数据报通过协议堆栈传递时拦截它们，提供安全保护，并将它们传递到数据链路层。
- en: '![IPsec bump in the stack (BITS) architecture In this type of IPsec implementation,
    IPsec becomes a separate layer in the TCP/IP stack. It is implemented as software
    that sits below IP and adds security protection to datagrams created by the IP
    layer.](httpatomoreillycomsourcenostarchimages287915.png.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec 堆栈中断（BITS）架构 在这种类型的 IPsec 实现中，IPsec 成为了 TCP/IP 堆栈中的一个独立层。它作为位于 IP 之下的软件实现，并为
    IP 层创建的数据报提供安全保护。](httpatomoreillycomsourcenostarchimages287915.png.jpg)'
- en: Figure 29-2. IPsec bump in the stack (BITS) architecture In this type of IPsec
    implementation, IPsec becomes a separate layer in the TCP/IP stack. It is implemented
    as software that sits below IP and adds security protection to datagrams created
    by the IP layer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-2. IPsec 堆栈中断（BITS）架构 在这种类型的 IPsec 实现中，IPsec 成为了 TCP/IP 堆栈中的一个独立层。它作为位于
    IP 之下的软件实现，并为 IP 层创建的数据报提供安全保护。
- en: The advantage of this technique is that IPsec can be retrofitted to any IP device,
    since the IPsec functionality is separate from IP. The disadvantage is that there
    is a duplication of effort compared to the integrated architecture. BITS is generally
    used for IPv4 hosts.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优点是，由于 IPsec 功能与 IP 分离，因此可以将其回接到任何 IP 设备。缺点是与集成架构相比，存在工作重复的问题。BITS 通常用于
    IPv4 主机。
- en: Bump in the Wire (BITW) Architecture
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线中断（BITW）架构
- en: In the bump in the wire (BITW) method, we add a hardware device that provides
    IPsec services. For example, suppose we have a company with two sites. Each has
    a network that connects to the Internet using a router that is not capable of
    IPsec functions. We can interpose a special IPsec device between the router and
    the Internet at both sites, as shown in [Figure 29-3](ch29s03.html#ipsec_bump_in_the_wire_bitw_architecture
    "Figure 29-3. IPsec bump in the wire (BITW) architecture In this IPsec architecture,
    IPsec is actually implemented in separate devices that sit between the devices
    that wish to communicate securely. These repackage insecure IP datagrams for transport
    over the public Internet."). These devices will then intercept outgoing datagrams,
    add IPsec protection to them, and strip it off incoming datagrams.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在线中断（BITW）方法中，我们添加一个提供 IPsec 服务的硬件设备。例如，假设我们有一家公司有两个站点。每个站点都有一个网络，通过一个不具备 IPsec
    功能的路由器连接到互联网。我们可以在两个站点的路由器和互联网之间插入一个特殊的 IPsec 设备，如图[图 29-3](ch29s03.html#ipsec_bump_in_the_wire_bitw_architecture
    "图 29-3. IPsec 线中断（BITW）架构 在这种 IPsec 架构中，IPsec 实际上是部署在希望安全通信的设备之间的独立设备中。这些设备将不安全的
    IP 数据报重新封装，以便在公共互联网上传输。")所示。这些设备将拦截发出的数据报，为它们添加 IPsec 保护，并从传入的数据报中移除。
- en: '![IPsec bump in the wire (BITW) architecture In this IPsec architecture, IPsec
    is actually implemented in separate devices that sit between the devices that
    wish to communicate securely. These repackage insecure IP datagrams for transport
    over the public Internet.](httpatomoreillycomsourcenostarchimages287917.png.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec 线中断（BITW）架构 在这种 IPsec 架构中，IPsec 实际上是部署在希望安全通信的设备之间的独立设备中。这些设备将不安全的
    IP 数据报重新封装，以便在公共互联网上传输。](httpatomoreillycomsourcenostarchimages287917.png.jpg)'
- en: Figure 29-3. IPsec bump in the wire (BITW) architecture In this IPsec architecture,
    IPsec is actually implemented in separate devices that sit between the devices
    that wish to communicate securely. These repackage insecure IP datagrams for transport
    over the public Internet.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-3. IPsec 线中的凸起（BITW）架构 在此 IPsec 架构中，IPsec 实际上是在位于希望安全通信的设备之间的独立设备中实现的。这些设备重新封装不安全的
    IP 数据报，以便在公共互联网上传输。
- en: Just as BITS lets you add IPsec to legacy hosts, BITW can retrofit non-IPsec
    routers to provide security benefits. The disadvantages are complexity and cost.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 BITS 允许你将 IPsec 添加到旧主机一样，BITW 可以对非 IPsec 路由器进行改造，以提供安全优势。缺点是复杂性和成本。
- en: Tip
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Three different architectures or implementation models are
    defined for IPsec. The best is integrated architecture, in which IPsec is built
    into the IP layer of devices directly. The other two are *bump in the stack (BITS)*
    and *bump in the wire (BITW)*, which are ways of layering IPsec underneath regular
    IP, using software and hardware solutions, respectively.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 为 IPsec 定义了三种不同的架构或实现模型。最好的是集成架构，其中 IPsec 直接构建到设备的 IP 层中。其他两种是 *堆栈中的凸起（BITS）*
    和 *线中的凸起（BITW）*，它们是使用软件和硬件解决方案在常规 IP 下方分层 IPsec 的方法。'
- en: As you will see in the next section, the choice of architecture has an important
    impact on which of the two IPsec modes can be used. Incidentally, even though
    BITS and BITW seem quite different, they are actually do the same thing. In the
    case of BITS, we have an extra software layer that adds security to existing IP
    datagrams; in BITW, distinct hardware devices do this same job. In both cases,
    the result is the same, and the implications on the choice of IPsec mode is likewise
    the same.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一节中看到的，架构的选择对可以使用哪两种 IPsec 模式有重要影响。顺便说一下，尽管 BITS 和 BITW 看起来相当不同，但它们实际上做的是同一件事。在
    BITS 的情况下，我们有一个额外的软件层，它向现有的 IP 数据报添加安全性；在 BITW 中，专门的硬件设备执行这项相同的任务。在这两种情况下，结果都是相同的，并且对
    IPsec 模式选择的影响也是相同的。
- en: 'IPsec Modes: Transport and Tunnel'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec 模式：传输和隧道
- en: You just saw that three different basic implementation architectures could be
    used to provide IPsec facilities to TCP/IP networks. The choice of which implementation
    you use, as well as whether you implement in end hosts or routers, impacts the
    specific way that IPsec functions. Two specific modes of operation that are related
    to these architectures are defined for IPsec. They are called *transport mode*
    and *tunnel mode*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到，可以使用三种不同的基本实现架构来为 TCP/IP 网络提供 IPsec 功能。你使用的实现选择，以及你是否在端主机或路由器中实现，会影响 IPsec
    的具体工作方式。为与这些架构相关的两种特定操作模式定义了 IPsec。它们被称为 *传输模式* 和 *隧道模式*。
- en: IPsec modes are closely related to the function of the two core protocols, AH
    and ESP. Both of these protocols provide protection by adding a header (and possibly
    other fields) containing security information to a datagram. The choice of mode
    does not affect the method by which each generates its header, but rather, changes
    what specific parts of the IP datagram are protected and how the headers are arranged
    to accomplish this. In essence, the mode really describes, not prescribes, how
    AH or ESP do their thing. It is used as the basis for defining other constructs,
    such as security associations (SAs).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec 模式与两个核心协议 AH 和 ESP 的功能密切相关。这两个协议通过向数据报添加包含安全信息的头部（以及可能的其他字段）来提供保护。模式的选择不影响每个协议生成其头部的方法，而是改变
    IP 数据报的哪些特定部分受到保护以及如何安排头部以实现这一点。本质上，模式实际上描述了而不是规定了 AH 或 ESP 如何工作。它被用作定义其他结构，如安全关联（SAs）的基础。
- en: Transport Mode
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输模式
- en: As its name suggests, in transport mode, the protocol protects the message passed
    down to IP from the transport layer. The message is processed by AH and/or ESP,
    and the appropriate header(s) are added in front of the transport (UDP or TCP)
    header. The IP header is then added in front of that by IP.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所暗示的，在传输模式下，协议保护从传输层传递给 IP 的消息。该消息由 AH 和/或 ESP 处理，并在传输（UDP 或 TCP）头部之前添加适当的头部。然后，IP
    头部由 IP 添加到前面。
- en: 'Another way of looking at this is as follows: Normally, the transport layer
    packages data for transmission and sends it to IP. From IP''s perspective, this
    transport layer message is the payload of the IP datagram. When IPsec is used
    in transport mode, the IPsec header is applied only over this IP payload, not
    the IP header. The AH and ESP headers appear between the original, single IP header
    and the IP payload. This is illustrated in [Figure 29-4](ch29s04.html#ipsec_transport_mode_operation_when_ipse
    "Figure 29-4. IPsec transport mode operation When IPsec operates in transport
    mode, it is integrated with IP and used to transport the upper layer (TCP/UDP)
    message directly. After processing, the datagram has just one IP header that contains
    the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in Figure 29-5.").'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式如下：通常，传输层将数据打包以进行传输，并将其发送到IP。从IP的角度来看，这个传输层消息是IP数据报的有效负载。当IPsec在传输模式下使用时，IPsec头部仅应用于这个IP有效负载，而不是IP头部。AH和ESP头部出现在原始的单个IP头部和IP有效负载之间。这如图[图29-4](ch29s04.html#ipsec_transport_mode_operation_when_ipse
    "图29-4. IPsec传输模式操作 当IPsec在传输模式下运行时，它与IP集成并用于直接传输上层（TCP/UDP）消息。处理完毕后，数据报只有一个包含AH和ESP
    IPsec头部的IP头部。与图29-5中的隧道模式相比。")所示。
- en: Tunnel Mode
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隧道模式
- en: In tunnel mode, IPsec is used to protect a completely encapsulated IP datagram
    after the IP header has already been applied to it. The IPsec headers appear in
    front of the original IP header, and then a new IP header is added in front of
    the IPsec header. That is to say, the entire original IP datagram is secured and
    then encapsulated within another IP datagram. This is shown in [Figure 29-5](ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel
    "Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because
    it represents an encapsulation of a complete IP datagram, thereby forming a virtual
    tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where
    a new IP header is created with the AH and ESP IPsec headers added. Contrast this
    to transport mode, shown in Figure 29-4.").
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在隧道模式下，IPsec用于在IP头部已经应用于IP数据报之后，保护一个完全封装的IP数据报。IPsec头部出现在原始IP头部之前，然后在新IP头部之前添加一个新IP头部。也就是说，整个原始IP数据报被加密，然后封装在另一个IP数据报中。这如图[图29-5](ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel
    "图29-5. IPsec隧道模式操作 IPsec隧道模式之所以称为隧道模式，是因为它代表了一个完整IP数据报的封装，从而在IPsec设备之间形成一个虚拟隧道。IP数据报被传递到IPsec，在那里创建一个新的IP头部，并添加AH和ESP
    IPsec头部。与图29-4中的传输模式相比。")所示。
- en: Comparing Transport and Tunnel Modes
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较传输模式和隧道模式
- en: 'The bottom line in understanding the difference between the two IPsec modes
    is this: Tunnel mode protects the original IP datagram as a whole, header and
    all, while transport mode does not. Thus, in general terms, the order of the headers
    is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 理解两种IPsec模式之间差异的底线是：隧道模式保护整个原始IP数据报，包括头部，而传输模式则不保护。因此，总的来说，头部的顺序如下：
- en: '**Transport Mode** IP header, IPsec headers (AH and/or ESP), IP payload (including
    transport header)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输模式** IP头部，IPsec头部（AH和/或ESP），IP有效负载（包括传输头部）'
- en: '**Tunnel Mode** New IP header, IPsec headers (AH and/or ESP), old IP header,
    IP payload'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**隧道模式** 新IP头部，IPsec头部（AH和/或ESP），旧IP头部，IP有效负载'
- en: '![IPsec transport mode operation When IPsec operates in transport mode, it
    is integrated with IP and used to transport the upper layer (TCP/UDP) message
    directly. After processing, the datagram has just one IP header that contains
    the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in .](httpatomoreillycomsourcenostarchimages287919.png.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec传输模式操作 当IPsec在传输模式下运行时，它与IP集成并用于直接传输上层（TCP/UDP）消息。处理完毕后，数据报只有一个包含AH和ESP
    IPsec头部的IP头部。与图29-5中的隧道模式相比。](httpatomoreillycomsourcenostarchimages287919.png.jpg)'
- en: Figure 29-4. IPsec transport mode operation When IPsec operates in transport
    mode, it is integrated with IP and used to transport the upper layer (TCP/UDP)
    message directly. After processing, the datagram has just one IP header that contains
    the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in [Figure 29-5](ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel
    "Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because
    it represents an encapsulation of a complete IP datagram, thereby forming a virtual
    tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where
    a new IP header is created with the AH and ESP IPsec headers added. Contrast this
    to transport mode, shown in Figure 29-4.").
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-4. IPsec传输模式操作 当IPsec在传输模式下运行时，它与IP集成并用于直接传输上层（TCP/UDP）消息。处理后，数据报只有一个包含AH和ESP
    IPsec头部的IP头部。与隧道模式相比，隧道模式在[图29-5](ch29s04.html#ipsec_tunnel_mode_operation_ipsec_tunnel
    "图29-5. IPsec隧道模式操作 IPsec隧道模式之所以得名，是因为它代表了一个完整IP数据报的封装，从而在IPsec设备之间形成一个虚拟隧道。IP数据报传递给IPsec，在那里创建一个新的IP头部，并添加AH和ESP
    IPsec头部。与传输模式相比，请参见图29-4。")中展示。
- en: Again, this is a simplified view of how IPsec datagrams are constructed; the
    reality is significantly more complex. The exact way that the headers are arranged
    in an IPsec datagram in both transport and tunnel modes depends on which version
    of IP is being used. IPv6 uses extension headers that must be arranged in a particular
    way when IPsec is used. The header placement also depends on which IPsec protocol
    is being used, AH or ESP. Note that it is also possible to apply both AH and ESP
    to the same datagram; if so, the AH header always appears before the ESP header.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是对IPsec数据报构建过程的简化视图；实际情况要复杂得多。在传输和隧道模式下，IPsec数据报中头部的排列方式取决于所使用的IP版本。IPv6在使用IPsec时必须以特定方式排列扩展头部。头部放置还取决于所使用的IPsec协议，AH或ESP。请注意，也可以将AH和ESP同时应用于同一个数据报；如果是这样，AH头部总是出现在ESP头部之前。
- en: There are thus three variables and eight basic combinations of mode (tunnel
    or transport), IP version (IPv4 or IPv6) and protocol (AH or ESP). The coming
    discussions of AH and ESP describe the four format combinations of transport/tunnel
    mode and IPv4/IPv6 applicable to each protocol. Note that ESP also includes an
    ESP trailer that goes after the data protected.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有三个变量和八种基本模式组合（隧道或传输）、IP版本（IPv4或IPv6）和协议（AH或ESP）。接下来对AH和ESP的讨论将描述适用于每个协议的传输/隧道模式和IPv4/IPv6的四种格式组合。请注意，ESP还包括一个ESP尾随数据保护后的数据。
- en: You could probably tell by reading these descriptions how the two modes relate
    to the choice of IPsec architecture you looked at earlier. Transport mode requires
    that IPsec be integrated into IP, because AH/ESP must be applied as the original
    IP packaging is performed on the transport layer message. This is often the choice
    for implementations requiring end-to-end security with hosts that run IPsec directly.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读这些描述，您可能已经能够了解这两种模式如何与您之前查看的IPsec架构选择相关联。传输模式要求IPsec集成到IP中，因为AH/ESP必须在传输层消息的原IP封装过程中应用。这对于需要端到端安全且直接运行IPsec的主机实现通常是选择。
- en: '![IPsec tunnel mode operation IPsec tunnel mode is so named because it represents
    an encapsulation of a complete IP datagram, thereby forming a virtual tunnel between
    IPsec-capable devices. The IP datagram is passed to IPsec, where a new IP header
    is created with the AH and ESP IPsec headers added. Contrast this to transport
    mode, shown in .](httpatomoreillycomsourcenostarchimages287921.png.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec隧道模式操作 IPsec隧道模式之所以得名，是因为它代表了一个完整IP数据报的封装，从而在IPsec设备之间形成一个虚拟隧道。IP数据报传递给IPsec，在那里创建一个新的IP头部，并添加AH和ESP
    IPsec头部。与传输模式相比，请参见图29-4。](httpatomoreillycomsourcenostarchimages287921.png.jpg)'
- en: Figure 29-5. IPsec tunnel mode operation IPsec tunnel mode is so named because
    it represents an encapsulation of a complete IP datagram, thereby forming a virtual
    tunnel between IPsec-capable devices. The IP datagram is passed to IPsec, where
    a new IP header is created with the AH and ESP IPsec headers added. Contrast this
    to transport mode, shown in [Figure 29-4](ch29s04.html#ipsec_transport_mode_operation_when_ipse
    "Figure 29-4. IPsec transport mode operation When IPsec operates in transport
    mode, it is integrated with IP and used to transport the upper layer (TCP/UDP)
    message directly. After processing, the datagram has just one IP header that contains
    the AH and ESP IPsec headers. Contrast this to tunnel mode, shown in Figure 29-5.").
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-5. IPsec隧道模式操作 IPsec隧道模式之所以得名，是因为它代表了对完整IP数据报的封装，从而在具有IPsec功能的设备之间形成一个虚拟隧道。IP数据报被传递给IPsec，在那里创建一个新的IP头部，并添加了AH和ESP
    IPsec头部。这与传输模式形成对比，传输模式在[图29-4](ch29s04.html#ipsec_transport_mode_operation_when_ipse
    "图29-4. IPsec传输模式操作 当IPsec在传输模式下运行时，它与IP集成并用于直接传输上层（TCP/UDP）消息。处理完毕后，数据报只有一个包含AH和ESP
    IPsec头部的IP头部。与图29-5所示的隧道模式形成对比。")中展示。
- en: Tunnel mode represents an encapsulation of IP within the combination of IP plus
    IPsec. Thus, it corresponds with the BITS and BITW implementations, where IPsec
    is applied after IP has processed higher-layer messages and has already added
    its header. Tunnel mode is a common choice for VPN implementations, which are
    based on the tunneling of IP datagrams through an unsecured network such as the
    Internet.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 隧道模式代表了IP在IP加上IPsec组合中的封装。因此，它与BITS和BITW实现相对应，在这些实现中，IPsec在IP处理了高层消息并已添加其头部之后应用。隧道模式是VPN实现的一个常见选择，这些实现基于通过不安全的网络（如互联网）隧道传输IP数据报。
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** IPsec has two basic modes of operation. In *transport mode*,
    IPsec AH and ESP headers are added as the original IP datagram is created. Transport
    mode is associated with integrated IPsec architectures. In *tunnel mode*, the
    original IP datagram is created normally, and then the entire datagram is encapsulated
    into a new IP datagram containing the AH/ESP IPsec headers. Tunnel mode is most
    commonly used with *bump in the stack (BITS)* and *bump in the wire (BITW)* implementations.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPsec有两种基本的工作模式。在*传输模式*中，IPsec AH和ESP头部在创建原始IP数据报时添加。传输模式与集成IPsec架构相关联。在*隧道模式*中，原始IP数据报按正常方式创建，然后整个数据报被封装到一个新的IP数据报中，该数据报包含AH/ESP
    IPsec头部。隧道模式最常与*bump in the stack (BITS)*和*bump in the wire (BITW)*实现一起使用。'
- en: IPsec Security Constructs
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec安全构造
- en: Important IPsec security constructs include security associations, the security
    association database, security policies, the security policy database, selectors,
    and the security parameter index. These items are all closely related and essential
    to understand before you begin looking at the core IPsec protocols. These constructs
    are used to guide the operation of IPsec in a general way and particularly to
    guide exchanges between devices. The constructs control how IPsec works and ensure
    that each datagram coming into or leaving an IPsec-capable device is treated properly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 重要IPsec安全构造包括安全关联、安全关联数据库、安全策略、安全策略数据库、选择器和安全参数索引。这些项目都密切相关，并且在开始查看核心IPsec协议之前是必不可少的。这些构造用于以一般方式指导IPsec的操作，特别是指导设备之间的交换。这些构造控制IPsec的工作方式，并确保每个进入或离开具有IPsec功能的设备的数据报都得到适当的处理。
- en: Security Policies, Security Associations, and Associated Databases
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全策略、安全关联和相关数据库
- en: Let's begin by considering the problem of how to apply security in a device
    that may be handling many different exchanges of datagrams with others. There
    is overhead involved in providing security, so you do not want to do it for every
    message that comes in or out. Some types of messages may need more security; others
    may need less. Also, exchanges with certain devices may require different processing
    than others.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑如何在处理许多不同数据报交换的设备上应用安全性的问题。提供安全性涉及开销，因此你不想为每个进出消息都这样做。某些类型的消息可能需要更多的安全性；其他可能需要较少。此外，与某些设备的交换可能需要与其他设备不同的处理。
- en: 'To manage all of this complexity, IPsec is equipped with a flexible, powerful
    way of specifying how different types of datagrams should be handled. To understand
    how this works, you must first define the following two important logical concepts:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理所有这些复杂性，IPsec配备了一种灵活、强大的方式来指定不同类型的数据报应该如何处理。要了解这是如何工作的，你必须首先定义以下两个重要的逻辑概念：
- en: '**Security Policies and the Security Policy Database (SPD)** A *security policy*
    is a rule that is programmed into the IPsec implementation. It tells the implementation
    how to process different datagrams received by the device. For example, security
    policies decide if a particular packet needs to be processed by IPsec or not.
    AH and ESP entirely bypass those that do not need processing. If security is required,
    the security policy provides general guidelines for how it should be provided,
    and if necessary, links to more specific detail. Security policies for a device
    are stored in the device''s *security policy database (SPD)*.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全策略和安全策略数据库（SPD）** 安全策略是编程到IPsec实现中的规则。它告诉实现如何处理设备接收到的不同数据报。例如，安全策略决定特定的数据包是否需要由IPsec处理。AH和ESP完全绕过那些不需要处理的数据包。如果需要安全，安全策略提供了一般性指南，说明如何提供安全，并在必要时提供更具体细节的链接。设备的安全策略存储在设备的*安全策略数据库（SPD）*中。'
- en: '**Security Associations (SAs) and the Security Association Database (SAD)**
    A security association (SA) is a set of security information that describes a
    particular kind of secure connection between one device and another. You can consider
    it a contract, if you will, that specifies the particular security mechanisms
    that are used for secure communications between the two. A device''s security
    associations are contained in its *security association database (SAD)*.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全关联（SA）和安全关联数据库（SAD）** 安全关联（SA）是一组安全信息，描述了设备之间特定类型的安全连接。你可以将其视为一份合同，它指定了用于两个设备之间安全通信的特定安全机制。设备的安全关联包含在其*安全关联数据库（SAD）*中。'
- en: It's often hard to distinguish between the SPD and the SAD, because they are
    similar in concept. The main difference between them is that security policies
    are general, while security associations are more specific. To determine what
    to do with a particular datagram, a device first checks the SPD. The security
    policies in the SPD may reference a particular SA in the SAD. If so, the device
    will look up that SA and use it for processing the datagram.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很难区分SPD和SAD，因为它们在概念上相似。它们之间的主要区别是，安全策略是通用的，而安全关联更具体。为了确定如何处理特定的数据报，设备首先检查SPD。SPD中的安全策略可能引用SAD中的特定SA。如果是这样，设备将查找该SA并使用它来处理数据报。
- en: Selectors
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择器
- en: One issue I haven't covered yet is how a device determines what security policies
    or SAs to use for a specific datagram. Again here, IPsec defines a very flexible
    system that lets each security association define a set of rules for choosing
    datagrams that the SA applies to. Each of these rule sets is called a *selector*.
    For example, you might define a selector that says that a particular range of
    values in the Source Address of a datagram, combined with another value in the
    Destination Address, means that a specific SA must be used for the datagram.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有涉及的一个问题是设备如何确定为特定的数据报使用哪些安全策略或安全关联（SA）。同样在这里，IPsec定义了一个非常灵活的系统，允许每个安全关联定义一组规则，用于选择SA应用到的数据报。这些规则集被称为*选择器*。例如，你可能定义一个选择器，它表示数据报源地址中特定范围的值，结合目标地址中的另一个值，意味着必须为该数据报使用特定的SA。
- en: Security Association Triples and Security Parameter Index (SPI)
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全关联三元组和安全参数索引（SPI）
- en: Each secure communication that a device makes to another requires that an SA
    be established. SAs are unidirectional, so each one only handles either inbound
    or outbound traffic for a particular device. This allows the level of security
    for a flow from Device A to Device B to be different than the level for traffic
    coming from Device B to Device A. In a bidirectional communication of this sort,
    both Device A and Device B would have two SAs; Device A would have SAs that you
    could call SAdeviceBin and SAdeviceBout. Device B would have SAs SAdeviceAin and
    SAdeviceAout.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 设备与另一个设备进行的每次安全通信都需要建立SA。SA是单向的，因此每个SA只处理特定设备的入站或出站流量。这使得从设备A到设备B的流量安全级别可以不同于从设备B到设备A的流量安全级别。在这种双向通信中，设备A和设备B都会有两个SA；设备A会有可以称为SAdeviceBin和SAdeviceBout的SA。设备B会有SAdeviceAin和SAdeviceAout。
- en: 'SAs don''t actually have names, however. They are instead defined by a set
    of three parameters, called a *triple*:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，SA实际上并没有名称。它们由一组三个参数定义，称为*三元组*：
- en: '**Security Parameter Index (SPI)** A 32-bit number that is chosen to uniquely
    identify a particular SA for any connected device. The SPI is placed in AH or
    ESP datagrams and thus links each secure datagram to the security association.
    It is used by the recipient of a transmission so it knows what SA governs the
    datagram.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全参数索引 (SPI)** 一个32位的数字，用于唯一标识任何已连接设备上的特定安全关联 (SA)。SPI被放置在AH或ESP数据报中，从而将每个安全数据报与安全关联链接起来。它被传输的接收者使用，以便知道哪个SA管理该数据报。'
- en: '**IP Destination Address** The address of the device for which the SA is established.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP目标地址** 建立SA的设备的地址。'
- en: '**Security Protocol Identifier** Specifies whether this association is for
    AH or ESP. If both are in use with this device, they have separate SAs.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全协议标识符** 指定此关联是用于AH还是ESP。如果这两种协议都与此设备一起使用，它们有独立的SA。'
- en: As you can see, the two security protocols AH and ESP are dependent on SAs,
    security policies, and the various databases that control the operation of those
    SAs and policies. Management of these databases is important, but it's another
    complex subject entirely. Generally, SAs can either be set up manually (which
    is of course extra work) or you can deploy an automated system using a protocol
    like IKE (discussed near the end of this chapter).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，两个安全协议AH和ESP依赖于SA、安全策略以及控制这些SA和政策操作的各个数据库。管理这些数据库非常重要，但这完全是另一个复杂的话题。通常，SA可以手动设置（这当然需要额外的工作）或者你可以部署一个使用IKE（在本章末尾讨论）等协议的自动化系统。
- en: Confused? I don't blame you, despite my best efforts, and remember that this
    is all highly simplified. Welcome to the wonderful world of networking security.
    If you are ever besieged by insomnia, I highly recommend RFC 2401!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？我不怪你，尽管我尽了最大努力，并且记住，这一切都被高度简化了。欢迎来到网络安全的奇妙世界。如果你曾经被失眠困扰，我强烈推荐阅读RFC 2401！
- en: IPsec Authentication Header (AH)
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec认证头 (AH)
- en: As I mentioned earlier in this chapter, AH is one of the two core security protocols
    in IPsec. This is another protocol whose name has been well chosen. It provides
    *authentication* of either all or part of the contents of a datagram through the
    addition of a *header* that is calculated based on the values in the datagram.
    The parts of the datagram that are used for the calculation, and the placement
    of the header, depend on the mode (tunnel or transport) and the version of IP
    (IPv4 or IPv6).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章前面提到的，AH是IPsec中的两个核心安全协议之一。这是另一个名称选择得很好的协议。它通过添加基于数据报中值的计算出的头部，提供对数据报全部或部分内容的**认证**。用于计算的部分以及头部的放置取决于模式（隧道或传输）和IP版本（IPv4或IPv6）。
- en: The operation of AH is surprisingly simple, especially for any protocol that
    has anything to do with network security. The simplicity is analogous to the algorithms
    used to calculate checksums or perform cyclic redundancy (CRC) checks for error
    detection. In those cases, the sender uses a standard algorithm to compute a checksum
    or CRC code based on the contents of a message. This computed result is transmitted
    along with the original data to the destination, which repeats the calculation
    and discards the message if any discrepancy is found between its calculation and
    the one done by the source.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: AH的操作出奇地简单，尤其是对于任何与网络安全有关的协议来说。这种简单性类似于用于计算校验和或执行循环冗余（CRC）检查以检测错误的算法。在这些情况下，发送者使用标准算法根据消息内容计算校验和或CRC代码。这个计算结果与原始数据一起传输到目的地，目的地重复计算，如果发现其计算与源的计算有任何不一致，则丢弃该消息。
- en: This is the same idea behind AH, except that instead of using a simple algorithm
    known to everyone, it uses a special hashing algorithm and a specific key known
    only to the source and the destination. An SA between two devices specifies these
    particulars, so that the source and destination know how to perform the computation
    but nobody else can. On the source device, AH performs the computation and puts
    the result (called the *integrity check value*, or *ICV*) into a special header
    with other fields for transmission. The destination device does the same calculation
    using the key that the two devices share. This enables the device to see immediately
    if any of the fields in the original datagram were modified (due to either error
    or malice).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 AH 的理念相同，只是它使用的是一种特殊的哈希算法和只有源和目的地知道的特定密钥，而不是众所周知的简单算法。两个设备之间的 SA 指定了这些细节，这样源和目的地就知道如何执行计算，但其他人则无法知道。在源设备上，AH
    执行计算并将结果（称为 *完整性校验值* 或 *ICV*）放入一个带有其他传输字段的特殊头部中。目标设备使用两个设备共享的密钥执行相同的计算。这使得设备能够立即看到原始数据报中的任何字段是否被修改（无论是由于错误还是恶意）。
- en: Just as a checksum doesn't change the original data, neither does the ICV calculation
    change the original data. The presence of the AH header allows us to verify the
    integrity of the message, but doesn't encrypt it. Thus, AH provides *authentication*
    but not *privacy* (that's what ESP is for).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 正如校验和不会改变原始数据一样，ICV 计算也不会改变原始数据。AH 头部的存在使我们能够验证消息的完整性，但它不会加密它。因此，AH 提供了 *认证*
    但不提供 *隐私*（这是 ESP 的作用）。
- en: AH Datagram Placement and Linking
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AH 数据报放置和链接
- en: The calculation of AH is similar for both IPv4 and IPv6\. One difference is
    in the exact mechanism used for placing the header into the datagram and for linking
    the headers together. I'll describe IPv6 first because it is simpler, and because
    AH was really designed to fit into its mechanism for this.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 和 IPv6 的 AH 计算方式相似。一个不同之处在于将头部放入数据报以及将头部链接在一起的确切机制。我将首先描述 IPv6，因为它更简单，而且
    AH 实际上是为了适应其机制而设计的。
- en: IPv6 AH Placement and Linking
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6 AH 放置和链接
- en: In IPv6, the AH is inserted into the IP datagram as an extension header, following
    the normal IPv6 rules for extension header linking. It is linked by the previous
    header (extension or main), which puts the assigned value for the AH header (51)
    into its Next Header field. The AH header then links to the next extension header
    or the transport layer header using its Next Header field.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPv6 中，AH 作为扩展头部插入到 IP 数据报中，遵循正常的 IPv6 扩展头部链接规则。它通过前一个头部（扩展或主）进行链接，将 AH 头部的分配值（51）放入其
    Next Header 字段。然后 AH 头部通过其 Next Header 字段链接到下一个扩展头部或传输层头部。
- en: In transport mode, the AH is placed into the main IP header and appears before
    any Destination Options header that contains options intended for the final destination,
    and before an ESP header if present, but after any other extension headers. In
    tunnel mode, it appears as an extension header of the new IP datagram that encapsulates
    the original one being tunneled. This is shown graphically in [Figure 29-6](ch29s06.html#ipv6_datagram_format_with_ipsec_authenti
    "Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This
    is an example of an IPv6 datagram with two extension headers that are linked using
    the standard IPv6 mechanism (see Figure 26-3 in Chapter 26). When AH is applied
    in transport mode, it is simply added as a new extension header (as shown in dark
    shading) that goes between the Routing extension header and the Destination Options
    header. In tunnel mode, the entire original datagram is encapsulated into a new
    IPv6 datagram that contains the AH header. In both cases, the Next Header fields
    are used to link each header one to the next. Note the use of Next Header value
    41 in tunnel mode, which is the value for the encapsulated IPv6 datagram.").
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输模式下，AH 放入主 IP 头部，出现在任何包含旨在最终目的地的选项的 Destination Options 头部之前，如果存在 ESP 头部，则出现在任何其他扩展头部之后。在隧道模式下，它作为封装原始数据报的新
    IP 数据报的扩展头部出现。这在 [图 29-6](ch29s06.html#ipv6_datagram_format_with_ipsec_authenti
    "图 29-6. IPv6 数据报格式与 IPsec 认证头部 (AH) 这是一个使用标准 IPv6 机制（参见第 26 章中的图 26-3）链接两个扩展头部的
    IPv6 数据报的示例。当在传输模式下应用 AH 时，它简单地作为一个新的扩展头部添加（如深色阴影所示），位于路由扩展头部和目的地选项头部之间。在隧道模式下，整个原始数据报被封装到一个新的
    IPv6 数据报中，该数据报包含 AH 头部。在这两种情况下，Next Header 字段都用于将每个头部链接到下一个。注意隧道模式中使用的 Next Header
    值 41，这是封装的 IPv6 数据报的值。") 中有图形表示。
- en: '![IPv6 datagram format with IPsec Authentication Header (AH) This is an example
    of an IPv6 datagram with two extension headers that are linked using the standard
    IPv6 mechanism (see in ). When AH is applied in transport mode, it is simply added
    as a new extension header (as shown in dark shading) that goes between the Routing
    extension header and the Destination Options header. In tunnel mode, the entire
    original datagram is encapsulated into a new IPv6 datagram that contains the AH
    header. In both cases, the Next Header fields are used to link each header one
    to the next. Note the use of Next Header value 41 in tunnel mode, which is the
    value for the encapsulated IPv6 datagram.](httpatomoreillycomsourcenostarchimages287923.png.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![带有IPsec认证头(AH)的IPv6数据报格式，这是一个IPv6数据报的示例，它包含两个通过标准IPv6机制链接的扩展头（参见）。当AH在传输模式下应用时，它简单地作为一个新的扩展头（如图中深色阴影所示）添加，位于路由扩展头和目标选项头之间。在隧道模式下，整个原始数据报被封装到一个新的IPv6数据报中，该数据报包含AH头。在这两种情况下，Next
    Header字段都用于将每个头链接到下一个头。注意隧道模式中Next Header值的使用，该值为封装的IPv6数据报的值。](httpatomoreillycomsourcenostarchimages287923.png.jpg)'
- en: Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This
    is an example of an IPv6 datagram with two extension headers that are linked using
    the standard IPv6 mechanism (see [Figure 26-3](ch26s03.html#ipv6_extension_header_linking_using_the_
    "Figure 26-3. IPv6 extension header linking using the Next Header field The Next
    Header field allows a device to more easily process the headers in a received
    IPv6 datagram. When a datagram has no extension headers, the "next header" is
    actually the header at the start of the IP Data field, which, in this case, is
    a TCP header with a value of 6\. This is the same way the Protocol field is used
    in IPv4\. When extension headers do appear, the Next Header value of each header
    contains a number indicating the type of the following header in the datagram,
    so they logically chain together the headers.") in [Chapter 26](ch26.html "Chapter 26. IPV6
    DATAGRAM ENCAPSULATION AND FORMATTING")). When AH is applied in transport mode,
    it is simply added as a new extension header (as shown in dark shading) that goes
    between the Routing extension header and the Destination Options header. In tunnel
    mode, the entire original datagram is encapsulated into a new IPv6 datagram that
    contains the AH header. In both cases, the Next Header fields are used to link
    each header one to the next. Note the use of Next Header value 41 in tunnel mode,
    which is the value for the encapsulated IPv6 datagram.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-6. 带有IPsec认证头(AH)的IPv6数据报格式 这是一个IPv6数据报的示例，它包含两个通过标准IPv6机制链接的扩展头（参见[图26-3](ch26s03.html#ipv6_extension_header_linking_using_the_
    "图26-3. 使用Next Header字段链接IPv6扩展头 Next Header字段允许设备更容易地处理接收到的IPv6数据报中的头。当一个数据报没有扩展头时，'下一个头'实际上是IP数据字段开头的头，在这种情况下，是一个值为6的TCP头。这与IPv4中协议字段的使用方式相同。当扩展头出现时，每个头的Next
    Header值包含一个指示数据报中下一个头的类型的数字，因此它们逻辑上链接在一起。")）。当AH在传输模式下应用时，它简单地作为一个新的扩展头（如图中深色阴影所示）添加，位于路由扩展头和目标选项头之间。在隧道模式下，整个原始数据报被封装到一个新的IPv6数据报中，该数据报包含AH头。在这两种情况下，Next
    Header字段都用于将每个头链接到下一个头。注意隧道模式中Next Header值的使用，该值为封装的IPv6数据报的值。
- en: IPv4 AH Placement and Linking
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4 AH放置和链接
- en: In IPv4, a method that is similar to the IPv6 header-linking technique is employed.
    In an IPv4 datagram, the Protocol field indicates the identity of the higher-layer
    protocol (typically TCP or UDP) that's carried in the datagram. As such, this
    field points to the next header, which is at the front of the IP payload. AH takes
    this value and puts it into its Next Header field, and then places the protocol
    value for AH itself (51 in dotted decimal) into the IP Protocol field. This makes
    the IP header point to the AH, which then points to whatever the IP datagram pointed
    to before.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPv4中，采用了一种类似于IPv6头链接技术的方法。在IPv4数据报中，协议字段指示数据报中携带的更高层协议（通常是TCP或UDP）的身份。因此，该字段指向下一个头，即IP有效载荷的前端。AH采用这个值并将其放入其Next
    Header字段，然后将AH本身的协议值（点分十进制中的51）放入IP协议字段。这使得IP头指向AH，然后AH指向IP数据报之前指向的内容。
- en: Again, in transport mode, the AH header is added after the main IP header of
    the original datagram; in tunnel mode it is added after the new IP header that
    encapsulates the original datagram that's being tunneled. This is shown in [Figure 29-7](ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_
    "Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4
    datagram; it may or may not contain IPv4 options (which are not distinct entities
    as they are in IPv6). In transport mode, the AH header is added between the IP
    header and the IP data; the Protocol field of the IP header points to it, while
    its Next Header field contains the IP header's prior protocol value (in this case
    6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4
    datagram that includes the AH header. Note that in tunnel mode, the AH header
    uses the value 4 (which means IPv4) in its Next Header field.").
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在传输模式下，AH 头部添加到原始数据报的主要 IP 头部之后；在隧道模式下，它添加到封装原始数据报的新 IP 头部之后。这如图 [图 29-7](ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_
    "图 29-7. 带有 IPsec AH 的 IPv4 数据报格式 这里是一个 IPv4 数据报的示例；它可能包含或不包含 IPv4 选项（与 IPv6 中的情况不同，它们不是独立的实体）。在传输模式下，AH
    头部添加到 IP 头部和 IP 数据之间；IP 头部的协议字段指向它，而其下一个头部字段包含 IP 头部的前一个协议值（在这种情况下为 6，表示 TCP）。在隧道模式下，IPv4
    数据报封装到一个新的 IPv4 数据报中，该数据报包含 AH 头部。请注意，在隧道模式下，AH 头部在其下一个头部字段中使用值 4（表示 IPv4）") 所示。
- en: '![IPv4 datagram format with IPsec AH Here is an example of an IPv4 datagram;
    it may or may not contain IPv4 options (which are not distinct entities as they
    are in IPv6). In transport mode, the AH header is added between the IP header
    and the IP data; the Protocol field of the IP header points to it, while its Next
    Header field contains the IP header''s prior protocol value (in this case 6, for
    TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4 datagram
    that includes the AH header. Note that in tunnel mode, the AH header uses the
    value 4 (which means IPv4) in its Next Header field.](httpatomoreillycomsourcenostarchimages287925.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![带有 IPsec AH 的 IPv4 数据报格式 这里是一个 IPv4 数据报的示例；它可能包含或不包含 IPv4 选项（与 IPv6 中的情况不同，它们不是独立的实体）。在传输模式下，AH
    头部添加到 IP 头部和 IP 数据之间；IP 头部的协议字段指向它，而其下一个头部字段包含 IP 头部的前一个协议值（在这种情况下为 6，表示 TCP）。在隧道模式下，IPv4
    数据报封装到一个新的 IPv4 数据报中，该数据报包含 AH 头部。请注意，在隧道模式下，AH 头部在其下一个头部字段中使用值 4（表示 IPv4）](httpatomoreillycomsourcenostarchimages287925.png)'
- en: Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4
    datagram; it may or may not contain IPv4 options (which are not distinct entities
    as they are in IPv6). In transport mode, the AH header is added between the IP
    header and the IP data; the Protocol field of the IP header points to it, while
    its Next Header field contains the IP header's prior protocol value (in this case
    6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4
    datagram that includes the AH header. Note that in tunnel mode, the AH header
    uses the value 4 (which means IPv4) in its Next Header field.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-7. 带有 IPsec AH 的 IPv4 数据报格式 这里是一个 IPv4 数据报的示例；它可能包含或不包含 IPv4 选项（与 IPv6
    中的情况不同，它们不是独立的实体）。在传输模式下，AH 头部添加到 IP 头部和 IP 数据之间；IP 头部的协议字段指向它，而其下一个头部字段包含 IP
    头部的前一个协议值（在这种情况下为 6，表示 TCP）。在隧道模式下，IPv4 数据报封装到一个新的 IPv4 数据报中，该数据报包含 AH 头部。请注意，在隧道模式下，AH
    头部在其下一个头部字段中使用值 4（表示 IPv4）。
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The IPsec *Authentication Header (AH)* protocol allows the
    recipient of a datagram to verify its authenticity. It is implemented as a header
    that''s added to an IP datagram that contains an *integrity check value (ICV)*,
    which is computed based on the values of the fields in the datagram. The recipient
    can use this value to ensure that the data has not been changed in transit. AH
    does not encrypt data and thus does not ensure the privacy of transmissions.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPsec *认证头 (AH)* 协议允许接收方验证数据报的真实性。它作为头部添加到包含 *完整性校验值 (ICV)* 的 IP 数据报中，该值基于数据报中字段的值计算得出。接收方可以使用此值来确保数据在传输过程中未被更改。AH
    不加密数据，因此不保证传输的隐私性。'
- en: AH Format
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AH 格式
- en: The format of AH is described in [Table 29-2](ch29s06.html#ipsec_authentication_header_ah_format
    "Table 29-2. IPsec Authentication Header (AH) Format") and illustrated in [Figure 29-8](ch29s06.html#ipsec_authentication_header_ah_for-id001
    "Figure 29-8. IPsec Authentication Header (AH) format").
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: AH 格式在 [表 29-2](ch29s06.html#ipsec_authentication_header_ah_format "表 29-2.
    IPsec 认证头 (AH) 格式") 中描述，并在 [图 29-8](ch29s06.html#ipsec_authentication_header_ah_for-id001
    "图 29-8. IPsec 认证头 (AH) 格式") 中展示。
- en: Table 29-2. IPsec Authentication Header (AH) Format
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 表29-2. IPsec认证头(AH)格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Next Header | 1 | Contains the protocol number of the next header after the
    AH. Used to link headers together. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 下一个头部 | 1 | 包含AH之后的下一个头部的协议号。用于将头部链接在一起。 |'
- en: '| Payload Len | 1 | Despite its name, this field measures the length of the
    authentication header itself, not the payload. (I wonder what the history is behind
    that!) It is measured in 32-bit units, with 2 subtracted for consistency with
    how header lengths are normally calculated in IPv6. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 有效载荷长度 | 1 | 尽管其名称，此字段测量的是认证头本身的长度，而不是有效载荷的长度。（我想知道其背后的历史是什么！）它以32位为单位进行测量，为了与IPv6中通常计算头部长度的方法保持一致，减去2。
    |'
- en: '| Reserved | 2 | Not used; set to zeros. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 2 | 未使用；设置为0。 |'
- en: '| SPI | 4 | A 32-bit value that, when combined with the destination address
    and security protocol type (which is obviously the one for AH here), identifies
    the security association (SA) that will be used for this datagram. (SAs are discussed
    earlier in this chapter.) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| SPI | 4 | 一个32位值，当与目的地址和安全协议类型（在这里显然是AH）结合时，可以识别出将用于此数据报的安全关联（SA）。（SAs在本章前面已有讨论。）
    |'
- en: '| Sequence Number | 4 | A counter field that is initialized to zero when an
    SA is formed between two devices, and then incremented for each datagram sent
    using that SA. This uniquely identifies each datagram on an SA and is used to
    provide protection against replay attacks by preventing the retransmission of
    captured datagrams. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 4 | 当两个设备之间形成SA时，该计数器字段被初始化为0，然后为使用该SA发送的每个数据报递增。这唯一地标识了SA上的每个数据报，并用于通过防止捕获的数据报的重传来提供对重放攻击的保护。
    |'
- en: '| Authentication Data | Variable | Contains the result of the hashing algorithm,
    called the integrity check value (ICV), performed by the AH protocol. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 认证数据 | 可变 | 包含AH协议执行的哈希算法的结果，称为完整性校验值（ICV）。 |'
- en: '![IPsec Authentication Header (AH) format](httpatomoreillycomsourcenostarchimages287927.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec认证头(AH)格式](httpatomoreillycomsourcenostarchimages287927.png)'
- en: Figure 29-8. IPsec Authentication Header (AH) format
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-8. IPsec认证头(AH)格式
- en: The size of the Authentication Data field is variable to support different datagram
    lengths and hashing algorithms. Its total length must be a multiple of 32 bits.
    Also, the entire header must be a multiple of either 32 bits (for IPv4) or 64
    bits (for IPv6), so additional padding may be added to the Authentication Data
    field if necessary.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 认证数据字段的大小是可变的，以支持不同的数据报长度和哈希算法。其总长度必须是32位的倍数。此外，整个头部必须是32位（对于IPv4）或64位（对于IPv6）的倍数，因此如果需要，可以在认证数据字段中添加额外的填充。
- en: You may also notice that no IP addresses appear in the header, which is a prerequisite
    for it being the same for both IPv4 and IPv6.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能注意到，在头部没有出现任何IP地址，这是它对IPv4和IPv6都相同的前提条件。
- en: IPsec Encapsulating Security Payload (ESP)
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec封装安全载荷(ESP)
- en: The IPsec AH provides integrity authentication services to IPsec-capable devices
    so that they can verify that messages are received intact from other devices.
    For many applications, however, this is only one piece of the puzzle. We want
    to not only protect against intermediate devices changing the datagrams, but also
    to protect against them examining their contents as well. For this level of private
    communication, AH is not enough; we need to use the ESP protocol.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec AH为具有IPsec功能的设备提供完整性认证服务，以便它们可以验证从其他设备接收到的消息是否完整。然而，对于许多应用来说，这仅仅是谜题的一部分。我们不仅希望防止中间设备更改数据报，还希望防止它们检查其内容。对于这种级别的私密通信，AH是不够的；我们需要使用ESP协议。
- en: The main job of ESP is to provide the privacy we seek for IP datagrams by encrypting
    them. An encryption algorithm combines the data in the datagram with a key to
    transform it into an encrypted form. This is then repackaged using a special format
    that you will see shortly, and then transmitted to the destination, which decrypts
    it using the same algorithm. ESP also sports its own authentication scheme like
    the one used in AH, or it can be used in conjunction with AH.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ESP的主要任务是通过对数据报进行加密来提供我们所需的IP数据报的隐私。加密算法将数据报中的数据与密钥结合，将其转换为加密形式。然后使用你很快就会看到的特殊格式重新封装，然后传输到目的地，目的地使用相同的算法进行解密。ESP还拥有自己的认证方案，类似于AH中使用的方案，或者它可以与AH一起使用。
- en: ESP Fields
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESP字段
- en: 'ESP has several fields that are the same as those used in AH, but it packages
    its fields in a very different way. Instead of having just a header, it divides
    its fields into three components:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ESP有几个字段与AH中使用的字段相同，但它以非常不同的方式打包其字段。它不仅仅有一个标题，而是将其字段分为三个部分：
- en: '**ESP Header** This contains two fields, SPI and Sequence Number, and comes
    before the encrypted data. Its placement depends on whether ESP is used in transport
    mode or tunnel mode, as explained earlier in this chapter.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESP标题** 这包含两个字段，SPI和序列号，位于加密数据之前。其位置取决于ESP是否在传输模式或隧道模式中使用，如本章前面所述。'
- en: '**ESP Trailer** This section is placed after the encrypted data. It contains
    padding that is used to align the encrypted data through a Padding and Pad Length
    field. Interestingly, it also contains the Next Header field for ESP.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESP尾迹** 此部分放置在加密数据之后。它包含用于通过填充和填充长度字段对齐加密数据的填充。有趣的是，它还包含ESP的Next Header字段。'
- en: '**ESP Authentication Data** This field contains an ICV that''s computed in
    a manner that''s similar to how the AH protocol works. The field is used when
    ESP''s optional authentication feature is employed.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**ESP认证数据** 此字段包含一个ICV，其计算方式类似于AH协议的工作方式。当ESP使用可选的认证功能时，使用此字段。'
- en: There are two reasons why these fields are broken into pieces like this. The
    first is that some encryption algorithms require the data to be encrypted to have
    a certain block size, and so padding must appear after the data and not before
    it. That's why padding appears in the ESP Trailer field. The second is that the
    ESP Authentication Data appears separately because it is used to authenticate
    the rest of the encrypted datagram after encryption. This means that it cannot
    appear in the ESP Header or ESP Trailer.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些字段拆分成这样的原因有两个。第一个原因是某些加密算法要求加密的数据具有特定的块大小，因此必须在数据之后而不是之前添加填充。这就是为什么填充出现在ESP尾迹字段中的原因。第二个原因是ESP认证数据单独出现，因为它用于在加密之后对加密数据报的其余部分进行认证。这意味着它不能出现在ESP标题或ESP尾迹中。
- en: ESP Operations and Field Use
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESP操作和字段使用
- en: 'This is still a bit boggling so I''m going to try to explain this procedurally
    by considering three basic steps performed by ESP: calculating the header, then
    the trailer, and then the Authentication field.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然有点令人困惑，所以我将尝试通过考虑ESP执行的三步基本步骤来按程序解释：计算标题，然后是尾迹，然后是认证字段。
- en: Header Calculation and Placement
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题计算和放置
- en: 'The first thing to consider is how the ESP header is placed. This is similar
    to how AH works and depends on the IP version, as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是ESP标题的放置。这与AH的工作方式类似，并取决于IP版本，如下所示：
- en: '**IPv6** The ESP Header field is inserted into the IP datagram as an extension
    header, following the normal IPv6 rules for extension-header linking. In transport
    mode, it appears before a Destination Options header that contains options intended
    for the final destination, but after any other extension headers, if present.
    In tunnel mode, it appears as an extension header of the new IP datagram that
    encapsulates the original one being tunneled. This is shown in [Figure 29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of
    an IPv6 datagram with two extension headers that you saw in Figure 29-6\. When
    ESP is applied in transport mode, the ESP Header field is added to the existing
    datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are
    placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the
    entire encapsulated IPv6 datagram. Note the encryption and authentication coverage
    in each case, and also how the Next Header field points back into the datagram
    since it appears in the ESP Trailer.").'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv6** ESP标题字段作为扩展标题插入到IP数据报中，遵循正常的IPv6扩展标题链接规则。在传输模式下，它出现在包含最终目的地选项的标题之前，但在任何其他扩展标题之后（如果有）。在隧道模式下，它作为封装原始数据报的新IP数据报的扩展标题出现。这如图[图29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "图29-9. IPv6数据报格式，其中包含IPsec ESP。这是与图29-6中看到的相同的IPv6数据报示例，其中包含两个扩展标题。当ESP在传输模式下应用时，ESP标题字段被添加到现有数据报中，就像AH一样，ESP尾迹和ESP认证数据字段放置在末尾。在隧道模式下，ESP标题和尾迹字段包围整个封装的IPv6数据报。注意每种情况下的加密和认证覆盖范围，以及Next
    Header字段如何指向数据报，因为它出现在ESP尾迹中。")所示。'
- en: '**IPv4** As with AH, the ESP Header field is placed after the normal IPv4 header.
    In transport mode, it appears after the IP header of the original datagram; in
    tunnel mode, it appears after the IP header of the new IP datagram that''s encapsulating
    the original one. You can see this in [Figure 29-10](ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here
    "Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4
    datagram that you saw in Figure 29-7\. When ESP processes this datagram in transport
    mode, the ESP Header field is placed between the IPv4 header and data, with the
    ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the
    entire original IPv4 datagram is surrounded by these ESP components, rather than
    just the IPv4 data. Again, as in Figure 29-9, note the encryption and authentication
    coverage, and how the Next Header field points back to specify the identity of
    the encrypted data or datagram.").'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPv4** 与AH类似，ESP头部字段放置在正常的IPv4头部之后。在传输模式下，它出现在原始数据报的IP头部之后；在隧道模式下，它出现在封装原始数据报的新IP数据报的IP头部之后。您可以在[图29-10](ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here
    "图29-10. IPv4数据报格式，此处包含IPsec ESP。这是您在图29-7中看到的相同IPv4数据报。当ESP在传输模式下处理此数据报时，ESP头部字段位于IPv4头部和数据之间，ESP拖车和ESP认证数据字段随后。在隧道模式下，整个原始IPv4数据报被这些ESP组件包围，而不仅仅是IPv4数据。再次提醒，如图29-9所示，注意加密和认证覆盖范围，以及Next
    Header字段如何回指以指定加密数据或数据报的身份。")中看到这一点。'
- en: Trailer Calculation and Placement
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖车计算和放置
- en: The ESP Trailer field is appended to the data that will be encrypted. ESP then
    performs the encryption. The payload (TCP/UDP message or encapsulated IP datagram)
    and the ESP trailer are both encrypted, but the ESP header is not. Note again
    that any other IP headers that appear between the ESP header and the payload are
    also encrypted. In IPv6, this can include a Destination Options extension header.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ESP拖车字段被附加到将要加密的数据上。ESP随后执行加密操作。有效载荷（TCP/UDP消息或封装的IP数据报）以及ESP拖车都被加密，但ESP头部不被加密。再次提醒，任何出现在ESP头部和有效载荷之间的其他IP头部也会被加密。在IPv6中，这可以包括目标选项扩展头部。
- en: 'Normally, the Next Header field would appear in the ESP Header and would be
    used to link the ESP Header to the header that comes after it. However, the Next
    Header field in ESP appears in the trailer and not the header, which makes the
    linking seem a bit strange in ESP. The method is basically the same as what''s
    used in AH and in IPv6 in general, with the Next Header and Protocol fields being
    used to tie everything together. However, in ESP the Next Header field appears
    *after* the encrypted data, and so it points back to one of the following: a Destination
    Options extension header (if present), a TCP/UDP header (in transport mode), or
    an IPv4/IPv6 header (in tunnel mode). This is also shown in Figures [Figure 29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of
    an IPv6 datagram with two extension headers that you saw in Figure 29-6\. When
    ESP is applied in transport mode, the ESP Header field is added to the existing
    datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are
    placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the
    entire encapsulated IPv6 datagram. Note the encryption and authentication coverage
    in each case, and also how the Next Header field points back into the datagram
    since it appears in the ESP Trailer.") and [Figure 29-10](ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here
    "Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4
    datagram that you saw in Figure 29-7\. When ESP processes this datagram in transport
    mode, the ESP Header field is placed between the IPv4 header and data, with the
    ESP Trailer and ESP Authentication Data fields following. In tunnel mode, the
    entire original IPv4 datagram is surrounded by these ESP components, rather than
    just the IPv4 data. Again, as in Figure 29-9, note the encryption and authentication
    coverage, and how the Next Header field points back to specify the identity of
    the encrypted data or datagram.").'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，下一个头部字段会出现在 ESP 报头中，并用于将 ESP 报头与其后的报头链接起来。然而，ESP 中的下一个头部字段出现在尾部而不是头部，这使得
    ESP 中的链接看起来有点奇怪。该方法基本上与 AH 以及 IPv6 中的方法相同，使用下一个头部和协议字段将一切联系起来。然而，在 ESP 中，下一个头部字段出现在加密数据之后，因此它指向以下之一：一个存在的目标选项扩展报头（如果存在）、TCP/UDP
    报头（在传输模式下），或 IPv4/IPv6 报头（在隧道模式下）。这也在图 [图 29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "图 29-9. IPv6 数据报格式与 IPsec ESP。这是你在图 29-6 中看到的具有两个扩展头部的 IPv6 数据报的相同示例。当 ESP 在传输模式下应用时，ESP
    报头字段被添加到现有的数据报中，就像 AH 一样，ESP 尾部和 ESP 认证数据字段被放置在末尾。在隧道模式下，ESP 报头和尾部字段包围整个封装的 IPv6
    数据报。注意每种情况下的加密和认证覆盖，以及下一个头部字段如何出现在 ESP 尾部中，从而指向数据报中的身份信息。") 和 [图 29-10](ch29s07.html#ipv4_datagram_format_with_ipsec_esp_here
    "图 29-10. IPv4 数据报格式与 IPsec ESP。这是你在图 29-7 中看到的相同样本 IPv4 数据报。当 ESP 在传输模式下处理此数据报时，ESP
    报头字段被放置在 IPv4 报头和数据之间，ESP 尾部和 ESP 认证数据字段随后。在隧道模式下，整个原始 IPv4 数据报被这些 ESP 组件包围，而不仅仅是
    IPv4 数据。再次注意，就像图 29-9 一样，注意加密和认证覆盖，以及下一个头部字段如何指向指定加密数据或数据报的身份信息。") 中展示。
- en: ESP Authentication Field Calculation and Placement
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ESP 认证字段计算和放置
- en: If the optional ESP authentication feature is being used, it is computed over
    the entire ESP datagram (except the Authentication Data field itself, of course).
    This includes the ESP header, payload, and trailer.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用可选的 ESP 认证功能，它是在整个 ESP 数据报上计算的（当然，不包括认证数据字段本身）。这包括 ESP 报头、有效载荷和尾部。
- en: Tip
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The IPsec ESP protocol allows the contents of a datagram to
    be encrypted, which ensures that only the intended recipient is able to see the
    data. ESP is implemented using three components: an *ESP Header* that''s added
    to the front of a protected datagram, an *ESP Trailer* that follows the protected
    data, and an optional *ESP Authentication* Data field that provides authentication
    services similar to those provided by AH.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** IPsec ESP 协议允许对数据报的内容进行加密，从而确保只有预期的接收者才能看到数据。ESP 通过三个组件实现：一个添加到受保护数据报前面的
    *ESP 报头*，一个跟随受保护数据的 *ESP 尾部*，以及一个可选的 *ESP 认证* 数据字段，它提供类似于 AH 提供的认证服务。'
- en: '![IPv6 datagram format with IPsec ESP Here is the same example of an IPv6 datagram
    with two extension headers that you saw in . When ESP is applied in transport
    mode, the ESP Header field is added to the existing datagram as in AH, and the
    ESP Trailer and ESP Authentication Data fields are placed at the end. In tunnel
    mode, the ESP Header and Trailer fields bracket the entire encapsulated IPv6 datagram.
    Note the encryption and authentication coverage in each case, and also how the
    Next Header field points back into the datagram since it appears in the ESP Trailer.](httpatomoreillycomsourcenostarchimages287929.png.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![带IPsec ESP的IPv6数据报格式](httpatomoreillycomsourcenostarchimages287929.png.jpg)这是您在之前看到的相同示例IPv6数据报，具有两个扩展头部。当ESP在传输模式下应用时，ESP头部字段被添加到现有数据报中，就像AH一样，ESP尾部和ESP认证数据字段放置在末尾。在隧道模式下，ESP头部和尾部字段包围整个封装的IPv6数据报。注意每种情况下的加密和认证范围，以及Next
    Header字段如何回指到数据报，因为它出现在ESP尾部。'
- en: Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of
    an IPv6 datagram with two extension headers that you saw in [Figure 29-6](ch29s06.html#ipv6_datagram_format_with_ipsec_authenti
    "Figure 29-6. IPv6 datagram format with IPsec Authentication Header (AH) This
    is an example of an IPv6 datagram with two extension headers that are linked using
    the standard IPv6 mechanism (see Figure 26-3 in Chapter 26). When AH is applied
    in transport mode, it is simply added as a new extension header (as shown in dark
    shading) that goes between the Routing extension header and the Destination Options
    header. In tunnel mode, the entire original datagram is encapsulated into a new
    IPv6 datagram that contains the AH header. In both cases, the Next Header fields
    are used to link each header one to the next. Note the use of Next Header value
    41 in tunnel mode, which is the value for the encapsulated IPv6 datagram."). When
    ESP is applied in transport mode, the ESP Header field is added to the existing
    datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are
    placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the
    entire encapsulated IPv6 datagram. Note the encryption and authentication coverage
    in each case, and also how the Next Header field points back into the datagram
    since it appears in the ESP Trailer.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-9. 带IPsec ESP的IPv6数据报格式这是您在[图29-6](ch29s06.html#ipv6_datagram_format_with_ipsec_authenti
    "图29-6. 带IPsec认证头(AH)的IPv6数据报格式这是一个带有两个扩展头部的IPv6数据报示例，这些扩展头部使用标准的IPv6机制链接（参见第26章的图26-3）。当AH在传输模式下应用时，它简单地作为一个新的扩展头部添加（如深色阴影所示），位于路由扩展头部和目标选项头部之间。在隧道模式下，整个原始数据报封装到一个新的IPv6数据报中，该数据报包含AH头部。在这两种情况下，Next
    Header字段都用于将每个头部链接到下一个。注意隧道模式中使用的Next Header值41，这是封装的IPv6数据报的值。")中看到的相同示例IPv6数据报，具有两个扩展头部。当ESP在传输模式下应用时，ESP头部字段被添加到现有数据报中，就像AH一样，ESP尾部和ESP认证数据字段放置在末尾。在隧道模式下，ESP头部和尾部字段包围整个封装的IPv6数据报。注意每种情况下的加密和认证范围，以及Next
    Header字段如何回指到数据报，因为它出现在ESP尾部。
- en: '![IPv4 datagram format with IPsec ESP Here is the same sample IPv4 datagram
    that you saw in . When ESP processes this datagram in transport mode, the ESP
    Header field is placed between the IPv4 header and data, with the ESP Trailer
    and ESP Authentication Data fields following. In tunnel mode, the entire original
    IPv4 datagram is surrounded by these ESP components, rather than just the IPv4
    data. Again, as in , note the encryption and authentication coverage, and how
    the Next Header field points back to specify the identity of the encrypted data
    or datagram.](httpatomoreillycomsourcenostarchimages287931.png.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![IPv4数据报格式与IPsec ESP](httpatomoreillycomsourcenostarchimages287931.png.jpg)这是您在之前看到的相同样本IPv4数据报。当ESP在传输模式下处理此数据报时，ESP头部字段位于IPv4头部和数据之间，ESP尾部和ESP认证数据字段随后。在隧道模式下，整个原始IPv4数据报被这些ESP组件包围，而不仅仅是IPv4数据。同样，请注意加密和认证范围，以及Next
    Header字段如何回指以指定加密数据或数据报的身份。'
- en: Figure 29-10. IPv4 datagram format with IPsec ESP Here is the same sample IPv4
    datagram that you saw in [Figure 29-7](ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_
    "Figure 29-7. IPv4 datagram format with IPsec AH Here is an example of an IPv4
    datagram; it may or may not contain IPv4 options (which are not distinct entities
    as they are in IPv6). In transport mode, the AH header is added between the IP
    header and the IP data; the Protocol field of the IP header points to it, while
    its Next Header field contains the IP header's prior protocol value (in this case
    6, for TCP). In tunnel mode, the IPv4 datagram is encapsulated into a new IPv4
    datagram that includes the AH header. Note that in tunnel mode, the AH header
    uses the value 4 (which means IPv4) in its Next Header field."). When ESP processes
    this datagram in transport mode, the ESP Header field is placed between the IPv4
    header and data, with the ESP Trailer and ESP Authentication Data fields following.
    In tunnel mode, the entire original IPv4 datagram is surrounded by these ESP components,
    rather than just the IPv4 data. Again, as in [Figure 29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "Figure 29-9. IPv6 datagram format with IPsec ESP Here is the same example of
    an IPv6 datagram with two extension headers that you saw in Figure 29-6\. When
    ESP is applied in transport mode, the ESP Header field is added to the existing
    datagram as in AH, and the ESP Trailer and ESP Authentication Data fields are
    placed at the end. In tunnel mode, the ESP Header and Trailer fields bracket the
    entire encapsulated IPv6 datagram. Note the encryption and authentication coverage
    in each case, and also how the Next Header field points back into the datagram
    since it appears in the ESP Trailer."), note the encryption and authentication
    coverage, and how the Next Header field points back to specify the identity of
    the encrypted data or datagram.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 29-10. 带有 IPsec ESP 的 IPv4 数据报格式 这里是您在 [图 29-7](ch29s06.html#ipv4_datagram_format_with_ipsec_ah_here_
    "图 29-7. 带有 IPsec AH 的 IPv4 数据报格式 这里是一个 IPv4 数据报的示例；它可能包含或不包含 IPv4 选项（它们不是像 IPv6
    中那样的独立实体）。在传输模式下，AH 头部被添加到 IP 头部和 IP 数据之间；IP 头部的协议字段指向它，而其 Next Header 字段包含 IP
    头部的前一个协议值（在这种情况下为 6，表示 TCP）。在隧道模式下，IPv4 数据报被封装到一个新的 IPv4 数据报中，该数据报包含 AH 头部。请注意，在隧道模式下，AH
    头部在其 Next Header 字段中使用值 4（表示 IPv4）)。)。当 ESP 在传输模式下处理此数据报时，ESP 头部字段被放置在 IPv4 头部和数据之间，ESP
    尾部和 ESP 认证数据字段随后。在隧道模式下，整个原始 IPv4 数据报被这些 ESP 组件包围，而不仅仅是 IPv4 数据。再次强调，正如在 [图 29-9](ch29s07.html#ipv6_datagram_format_with_ipsec_esp_here
    "图 29-9. 带有 IPsec ESP 的 IPv6 数据报格式 这里是您在图 29-6 中看到的具有两个扩展头部的相同 IPv6 数据报示例。当 ESP
    在传输模式下应用时，ESP 头部字段被添加到现有的数据报中，就像 AH 一样，ESP 尾部和 ESP 认证数据字段被放置在末尾。在隧道模式下，ESP 头部和尾部字段包围整个封装的
    IPv6 数据报。注意每种情况下的加密和认证覆盖，以及 Next Header 字段如何指向数据报内部以指定加密数据或数据报的身份。"), 注意加密和认证覆盖，以及
    Next Header 字段如何指向数据报内部以指定加密数据或数据报的身份。
- en: ESP Format
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ESP 格式
- en: The format of the ESP sections and fields is described in [Table 29-3](ch29s07.html#ipsec_encapsulating_security_paylo-id001
    "Table 29-3. IPsec Encapsulating Security Payload (ESP) Format") and illustrated
    in [Figure 29-11](ch29s07.html#ipsec_esp_format_note_that_most_of_the_f "Figure 29-11. IPsec
    ESP format Note that most of the fields and sections in this format are variable
    length. The exceptions are the SPI and Sequence Number fields, which are four
    bytes long, and the Pad Length and Next Header fields, which are one byte each.").
    In both the figure and the table, I have shown the encryption and authentication
    coverage of the fields explicitly, to clarify how it all works.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ESP 部分 和 字段的格式在 [表 29-3](ch29s07.html#ipsec_encapsulating_security_paylo-id001
    "表 29-3. IPsec 封装安全载荷 (ESP) 格式") 中描述，并在 [图 29-11](ch29s07.html#ipsec_esp_format_note_that_most_of_the_f
    "图 29-11. IPsec ESP 格式 注意，此格式中的大多数字段和部分都是可变长度的。例外的是 SPI 和序列号字段，它们都是 4 个字节长，以及填充长度和
    Next Header 字段，每个字段都是 1 个字节。") 中展示。在这张图和表中，我都明确显示了字段的加密和认证覆盖，以阐明其工作原理。
- en: Table 29-3. IPsec Encapsulating Security Payload (ESP) Format
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 表 29-3. IPsec 封装安全载荷 (ESP) 格式
- en: '| Section | Field Name | Size (Bytes) | Description | Encryption Coverage |
    Authentication Coverage |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 部分 | 字段名称 | 大小（字节） | 描述 | 加密覆盖 | 认证覆盖 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| ESP Header | SPI | 4 | A 32-bit value that is combined with the destination
    address and security protocol type to identify the SA that will be used for this
    datagram. (SAs are discussed earlier in this chapter.) |   | ![](httpatomoreillycomsourcenostarchimages287933.png.jpg)
    |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| ESP头部 | SPI | 4 | 一个32位值，与目标地址和安全协议类型结合使用，以标识将用于此数据报的安全关联（SAs）。（SAs在本章前面已讨论。）
    |   | ![](httpatomoreillycomsourcenostarchimages287933.png.jpg) |'
- en: '| Sequence Number | 4 | A counter field initialized to zero when an SA is formed
    between two devices, and then incremented for each datagram that''s sent using
    that SA. This is used to provide protection against replay attacks. |   |   |
      |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 4 | 当两个设备之间形成安全关联（SA）时，计数器字段初始化为零，然后为使用该SA发送的每个数据报递增。这用于提供防止重放攻击的保护。
    |   |   |   |'
- en: '| Payload | Payload Data | Variable | The encrypted payload data, which consists
    of a higher-layer message or encapsulated IP datagram. It may also include support
    information such as an initialization vector that''s required by certain encryption
    methods. | ![](httpatomoreillycomsourcenostarchimages287935.png.jpg) |   |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 有效载荷 | 有效载荷数据 | 可变 | 加密的有效载荷数据，由高层消息或封装的IP数据报组成。它还可以包括支持信息，例如某些加密方法所需的初始化向量。
    | ![](httpatomoreillycomsourcenostarchimages287935.png.jpg) |   |'
- en: '| ESP Trailer | Padding | Variable (0 to 255) | Additional padding bytes are
    included as needed for encryption or for alignment. |   |   |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| ESP尾部 | 填充 | 可变（0到255） | 根据需要包含额外的填充字节，用于加密或对齐。 |   |   |'
- en: '|   | Pad Length | 1 | The number of bytes in the preceding Padding field.
    |   |   |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|   | 填充长度 | 1 | 前一个填充字段中的字节数。 |   |   |'
- en: '|   | Next Header | 1 | Contains the protocol number of the next header in
    the datagram. Used to chain together headers. |   |   |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|   | 下一个头部 | 1 | 包含数据报中下一个头部的协议号。用于链接头部。 |   |   |'
- en: '| ESP Authentication Data | Variable | Contains the ICV resulting from the
    application of the optional ESP authentication algorithm. |   |   |   |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| ESP认证数据 | 可变 | 包含由可选的ESP认证算法应用产生的ICV。 |   |   |   |'
- en: '![IPsec ESP format Note that most of the fields and sections in this format
    are variable length. The exceptions are the SPI and Sequence Number fields, which
    are four bytes long, and the Pad Length and Next Header fields, which are one
    byte each.](httpatomoreillycomsourcenostarchimages287937.png.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![IPsec ESP格式 注意，此格式中的大多数字段和部分都是可变长度的。例外的是SPI和序列号字段，它们都是4个字节长，填充长度和下一个头部字段各为1个字节。](httpatomoreillycomsourcenostarchimages287937.png.jpg)'
- en: Figure 29-11. IPsec ESP format Note that most of the fields and sections in
    this format are variable length. The exceptions are the SPI and Sequence Number
    fields, which are four bytes long, and the Pad Length and Next Header fields,
    which are one byte each.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图29-11. IPsec ESP格式 注意，此格式中的大多数字段和部分都是可变长度的。例外的是SPI和序列号字段，它们都是4个字节长，填充长度和下一个头部字段各为1个字节。
- en: The Padding field is used when encryption algorithms require it. Padding is
    also used to make sure that the ESP Trailer field ends on a 32-bit boundary. That
    is, the size of the ESP Header field plus the Payload field, plus the ESP Trailer
    field must be a multiple of 32 bits. The ESP Authentication Data field must also
    be a multiple of 32 bits.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 填充字段在加密算法需要时使用。填充还用于确保ESP尾部字段以32位边界结束。也就是说，ESP头部字段的大小加上有效载荷字段，再加上ESP尾部字段的大小必须是32位的倍数。ESP认证数据字段也必须是32位的倍数。
- en: IPsec Internet Key Exchange (IKE)
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPsec 互联网密钥交换（IKE）
- en: IPsec, like many secure networking protocol sets, is based on the concept of
    a shared secret. Two devices that want to send information securely encode and
    decode it using a piece of information that only the devices know. Anyone who
    isn't in on the secret is able to intercept the information but is prevented either
    from reading it (if ESP is used to encrypt the payload) or from tampering with
    it undetected (if AH is used). Before either AH or ESP can be used, however, it
    is necessary for the two devices to exchange the secret that the security protocols
    themselves will use. The primary support protocol used for this purpose in IPsec
    is called *Internet Key Exchange (IKE)*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: IPsec，就像许多安全网络协议集一样，基于共享密钥的概念。两个想要安全发送信息的设备使用只有它们知道的信息进行编码和解码。任何不知道这个秘密的人都能拦截信息，但被阻止读取它（如果使用ESP加密有效载荷），或者不被察觉地篡改它（如果使用AH）。然而，在AH或ESP可以使用之前，两个设备必须交换安全协议本身将使用的密钥。在IPsec中，用于此目的的主要支持协议被称为*互联网密钥交换（IKE）*。
- en: IKE is defined in RFC 2409, and it is one of the more complicated of the IPsec
    protocols to comprehend. In fact, it is simply impossible to truly understand
    more than a real simplification of its operation without significant background
    in cryptography. I don't have a background in cryptography, and I must assume
    that you, my reader, do not either. So rather than fill this topic with baffling
    acronyms and unexplained concepts, I will just provide a brief outline of IKE
    and how it is used.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: IKE 定义在 RFC 2409 中，它是 IPsec 协议中较难理解的一个。实际上，如果没有在密码学方面的深厚背景，真正理解其操作的真实简化几乎是不可能的。我并没有密码学背景，而且我必须假设我的读者也没有。因此，为了避免在这个主题中充斥着令人困惑的缩写和未解释的概念，我将只提供一个
    IKE 的简要概述以及它是如何被使用的。
- en: IKE Overview
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IKE 概述
- en: The purpose of IKE is to allow devices to exchange information that's required
    for secure communication. As the title suggests, this includes cryptographic keys
    that are used for encoding authentication information and performing payload encryption.
    IKE works by allowing IPsec-capable devices to exchange SAs, which populate their
    SADs. These SADs are then used for the actual exchange of secured datagrams with
    the AH and ESP protocols.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: IKE 的目的是允许设备交换用于安全通信所需的信息。正如标题所暗示的，这包括用于编码认证信息和执行有效载荷加密的加密密钥。IKE 通过允许 IPsec
    兼容设备交换 SA 来工作，这些 SA 填充了它们的 SAD。然后，这些 SAD 被用于使用 AH 和 ESP 协议实际交换受保护的数据报。
- en: IKE is considered a hybrid protocol because it combines (and supplements) the
    functions of three other protocols. The first of these is the *Internet Security
    Association and Key Management Protocol (ISAKMP)*. This protocol provides a framework
    for exchanging encryption keys and security association information. It operates
    by allowing security associations to be negotiated through a series of phases.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: IKE 被认为是混合协议，因为它结合（并补充）了三个其他协议的功能。首先是 *互联网安全关联和密钥管理协议（ISAKMP）*。该协议提供了一个交换加密密钥和安全关联信息的框架。它通过允许通过一系列阶段协商安全关联来运行。
- en: 'ISAKMP is a generic protocol that supports many different key exchange methods.
    In IKE, the ISAKMP framework is used as the basis for a specific key exchange
    method that combines features from two key exchange protocols:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ISAKMP 是一个支持许多不同密钥交换方法的通用协议。在 IKE 中，ISAKMP 框架被用作结合两个密钥交换协议特性的特定密钥交换方法的基础：
- en: '**OAKLEY** Describes a specific mechanism for exchanging keys through the definition
    of various key exchange modes. Most of the IKE key exchange process is based on
    OAKLEY.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAKLEY** 描述了一种通过定义各种密钥交换模式来交换密钥的特定机制。IKE 的密钥交换过程的大部分基于 OAKLEY。'
- en: '**SKEME** Describes a different key exchange mechanism than OAKLEY. IKE uses
    some features from SKEME, including its method of public key encryption and its
    fast rekeying feature.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**SKEME** 描述了一种不同于 OAKLEY 的密钥交换机制。IKE 使用了 SKEME 的某些特性，包括其公钥加密方法和快速重新密钥功能。'
- en: IKE Operation
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IKE 操作
- en: 'IKE doesn''t strictly implement either OAKLEY or SKEME but takes bits of each
    to form its own method of using ISAKMP. Clear as mud, I know. Because IKE functions
    within the framework of ISAKMP, its operation is based on the ISAKMP phased-negotiation
    process. There are two phases, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: IKE 并不严格实现 OAKLEY 或 SKEME，而是从每个协议中取其精华，形成自己使用 ISAKMP 的方法。我知道这听起来很混乱。因为 IKE 在
    ISAKMP 框架内运行，其操作基于 ISAKMP 分阶段协商过程。有两个阶段，如下所示：
- en: '**ISAKMP Phase 1** The first phase is a setup stage where two devices agree
    on how to exchange further information securely. This negotiation between the
    two units creates an SA for ISAKMP itself: an *ISAKMP SA*. This security association
    is then used for securely exchanging more detailed information in Phase 2.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISAKMP Phase 1** 第一阶段是一个设置阶段，其中两个设备就如何安全地交换更多信息达成一致。这两个单元之间的协商创建了一个 ISAKMP
    自身的 SA：一个 *ISAKMP SA*。然后，这个安全关联在第二阶段用于安全地交换更详细的信息。'
- en: '**ISAKMP Phase 2** In this phase, the ISAKMP SA established in Phase 1 is used
    to create SAs for other security protocols. Normally, this is where the parameters
    for the "real" SAs for the AH and ESP protocols would be negotiated.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISAKMP Phase 2** 在这个阶段，第一阶段建立的 ISAKMP SA 用于为其他安全协议创建 SAs。通常，这就是协商 AH 和 ESP
    协议“真实”SA 参数的地方。'
- en: An obvious question is why IKE bothers with this two-phased approach. Why not
    just negotiate the SA for AH or ESP in the first place? Well, even though the
    extra phase adds overhead, multiple Phase 2 negotiations can be conducted after
    one Phase 1, which amortizes the extra cost of the two-phase approach. It is also
    possible to use a simpler exchange method for Phase 2 once the ISAKMP SA has been
    established in Phase 1.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是为什么 IKE 要费心采用这种两阶段方法。为什么不一开始就协商 AH 或 ESP 的安全关联（SA）呢？嗯，尽管额外的阶段增加了开销，但一旦完成第一阶段，就可以进行多个第二阶段的协商，从而分摊两阶段方法的额外成本。一旦在第一阶段建立了
    ISAKMP SA，也可以使用更简单的交换方法进行第二阶段的协商。
- en: 'The ISAKMP SA negotiated during Phase 1 includes the negotiation of the following
    attributes used for subsequent negotiations:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段协商的 ISAKMP SA 包括后续协商中使用的以下属性：
- en: An encryption algorithm, such as the *Data Encryption Standard (DES)*
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种加密算法，例如 *数据加密标准 (DES)*
- en: A hash algorithm (MD5 or SHA, as used by AH or ESP)
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种哈希算法（MD5 或 SHA，如 AH 或 ESP 所用）
- en: An authentication method, such as authentication using previously shared keys
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种认证方法，例如使用先前共享的密钥进行认证
- en: A *Diffie-Hellman* group
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 *Diffie-Hellman* 群组
- en: Note
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Diffie and Hellman were two pioneers in the industry who invented public-key
    cryptography. In this method, instead of encrypting and decrypting with the same
    key, data is encrypted using a public key that anyone can know, and decrypted
    using a private key that is kept secret. A Diffie-Hellman group defines the attributes
    of how to perform this type of cryptography. Four predefined groups derived from
    OAKLEY are specified in IKE, and provision is allowed for defining new groups
    as well*.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*Diffie 和 Hellman 是行业中的两位先驱，他们发明了公钥加密。在这种方法中，不是使用相同的密钥进行加密和解密，而是使用任何人都可以知道的公钥进行加密，并使用保密的私钥进行解密。Diffie-Hellman
    群组定义了执行此类加密的属性。IKE 中指定了从 OAKLEY 衍生的四个预定义群组，并允许定义新的群组*。'
- en: Note that even though SAs in general are unidirectional, the ISAKMP SA is established
    bidirectionally. Once Phase 1 is complete, either device can set up a subsequent
    SA for AH or ESP using the ISAKMP SA.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管安全关联（SA）通常是单向的，但 ISAKMP SA 是双向建立的。一旦第一阶段完成，任何设备都可以使用 ISAKMP SA 设置后续的 AH
    或 ESP 安全关联。
- en: Chapter 30. INTERNET PROTOCOL MOBILITY SUPPORT (MOBILE IP)
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 30 章. 互联网协议移动支持（移动 IP）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages287681.png.jpg)'
- en: The Internet Protocol (IP) is the most successful network layer protocol in
    computing due to its many strengths, but it also has some weaknesses, most of
    which have become more important as networks has evolved over time. Technologies
    like classless addressing and Network Address Translation (NAT) combat the exhaustion
    of the IP version 4 (IPv4) address space, while IPsec provides it with the secure
    communications it lacks. Another weakness of IP is that it was not designed with
    mobile computers in mind.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议（IP）是计算中最成功的网络层协议，因为它具有许多优点，但它也有一些弱点，其中许多随着网络的演变而变得更加重要。无类别寻址和网络地址转换（NAT）等技术对抗了
    IP 版本 4（IPv4）地址空间的耗尽，而 IPsec 为其提供了所缺少的安全通信。IP 的另一个弱点是它没有考虑到移动计算机。
- en: While mobile devices can certainly use IP, the way that devices are addressed
    and datagrams routed causes a problem when they are moved from one network to
    another. At the time IP was developed, computers were large and rarely moved.
    Today, we have millions of notebook computers and smaller devices, some of which
    even use wireless networking to connect to the wired network. The importance of
    providing full IP capabilities for these mobile devices has grown dramatically.
    To support IP in a mobile environment, a new protocol called *IP Mobility Support*,
    or more simply, *Mobile IP*, was developed.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管移动设备当然可以使用 IP，但设备寻址和数据报路由的方式在它们从一个网络移动到另一个网络时会导致问题。在 IP 开发的时候，计算机体积庞大且很少移动。今天，我们有数百万台笔记本电脑和更小的设备，其中一些甚至使用无线网络连接到有线网络。为这些移动设备提供完整的
    IP 功能的重要性已经大幅增长。为了在移动环境中支持 IP，开发了一种新的协议，称为 *IP 移动支持*，或更简单地，*移动 IP*。
- en: In this chapter, I describe the special protocol that was developed to overcome
    the problems with mobile computers attaching to IP internetworks. I begin with
    an overview of Mobile IP and a more detailed description of why it was created.
    I discuss important concepts that define Mobile IP and its general mode of operation.
    I then move on to some of the specifics of how Mobile IP works. This includes
    a description of the special Mobile IP addressing scheme, an explanation of how
    agents are discovered by mobile devices, a discussion of the process of registration
    with the device's home agent, and finally, an explanation of how data is encapsulated
    and routed. I discuss the impact that Mobile IP has on the operation of the TCP/IP
    Address Resolution Protocol (ARP). I end the chapter by examining some of the
    efficiency and security issues that come into play when Mobile IP is used.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我描述了为克服移动计算机连接到IP互联网的问题而开发的特殊协议。我首先概述了移动IP及其创建的原因。我讨论了定义移动IP及其一般操作模式的重要概念。然后，我转向移动IP工作的一些具体细节。这包括对特殊移动IP寻址方案的描述，解释移动设备如何发现代理，讨论与设备的主代理注册的过程，以及最后解释数据是如何封装和路由的。我讨论了移动IP对TCP/IP地址解析协议（ARP）操作的影响。我通过检查使用移动IP时出现的效率和安全性问题来结束本章。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This section specifically describes how IP mobility support is provided for
    IPv4 networks. It does not deal with the more specific details for how mobility
    is implemented in IPv6*.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节专门描述了IPv4网络如何提供IP移动性支持。它不涉及IPv6中移动性实现的更具体细节*。'
- en: Tip
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**BACKGROUND INFORMATION** *If you are not familiar with the basics of IP addressing
    and routing, I strongly suggest reading at least Chapters [Chapter 16](ch16.html
    "Chapter 16. IPV4 ADDRESSING CONCEPTS AND ISSUES") and [Chapter 23](ch23.html
    "Chapter 23. IP ROUTING AND MULTICASTING") before reading about Mobile IP*.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** *如果您不熟悉IP寻址和路由的基础知识，我强烈建议在阅读有关移动IP的内容之前，至少阅读第[第16章](ch16.html "第16章. IPv4寻址概念和问题")和[第23章](ch23.html
    "第23章. IP路由和组播")*。'
- en: Mobile IP Overview, History, and Motivation
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP概述、历史和动机
- en: Mobile computing has greatly increased in popularity over the past several years,
    largely due to advances in miniaturization. Today, we can get the power that once
    required a hulking behemoth of a machine in a notebook PC or even a handheld computer.
    We also have wireless LAN (WLAN) technologies that easily let a device move from
    place to place and retain networking connectivity at the data link layer. Unfortunately,
    IP was developed back in the era of the behemoths, and it isn't designed to deal
    gracefully with computers that move around. To understand why IP doesn't work
    well in a mobile environment, you must take a look back at how IP addressing and
    routing work.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年中，移动计算因其小型化技术的进步而大大增加了其受欢迎程度。如今，我们可以在笔记本电脑或甚至手持计算机中获得曾经需要庞大机器才能提供的强大功能。我们还拥有无线局域网（WLAN）技术，它能够轻松地让设备从一个地方移动到另一个地方，并在数据链路层保持网络连接。不幸的是，IP是在巨无霸时代开发的，它并没有设计成优雅地处理移动的计算机。要了解为什么IP在移动环境中表现不佳，你必须回顾IP寻址和路由是如何工作的。
- en: The Problem with Mobile Nodes in TCP/IP
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP中移动节点的难题
- en: 'If you''ve read any of the materials in this book on IP addressing—and I certainly
    hope that you have—you know that IP addresses are fundamentally divided into two
    portions: a network identifier (network ID) and a host identifier (host ID). The
    network ID specifies which network a host is on, and the host ID uniquely specifies
    hosts within a network. This structure is fundamental to datagram routing, because
    devices use the network ID portion of the destination address of a datagram to
    determine if the recipient is on a local network or a remote one, and routers
    use it to determine how to route the datagram.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读过本书中关于IP寻址的任何材料——我当然希望您已经阅读过——您知道IP地址在本质上分为两部分：网络标识符（网络ID）和主机标识符（主机ID）。网络ID指定主机所在的网络，而主机ID唯一地指定网络内的主机。这种结构是数据报路由的基础，因为设备使用数据报目的地址的网络ID部分来确定接收者是在本地网络还是远程网络，而路由器则使用它来确定如何路由数据报。
- en: 'This is a great system, but it has one critical flaw: The IP address is tied
    tightly to the network where the device is located. Most devices never (or at
    least rarely) change their attachment point to the network, so this is not a problem
    for them, but it is certainly an issue for a mobile device. When the mobile device
    travels away from its home location, the system of routing based on IP address
    breaks. This is illustrated in [Figure 30-1](ch30.html#the_main_problem_with_mobile_devices_on_
    "Figure 30-1. The main problem with mobile devices on IP internetworks In this
    example, a mobile device (the notebook PC) has been moved from its home network
    in London to another network in Tokyo. A remote client (upper left) decides to
    send a datagram to the mobile device. However, it has no idea the device has moved.
    Since it sends by using the mobile node''s home address, 71.13.204.20, its request
    is routed to the router responsible for that network, which is in London. The
    mobile device isn''t there, so the router can''t deliver it. Mobile IP solves
    this problem by giving mobile devices and routers the capability to forward datagrams
    from one location to another.").'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的系统，但它有一个关键的缺陷：IP地址与设备所在网络紧密绑定。大多数设备永远不会（或者至少很少）更改它们的网络连接点，因此这对它们来说不是问题，但对于移动设备来说确实是一个问题。当移动设备离开其本地位置时，基于IP地址的路由系统就会崩溃。这如图[图30-1](ch30.html#the_main_problem_with_mobile_devices_on_
    "图30-1. 移动设备在IP互联网上的主要问题 在这个例子中，一个移动设备（笔记本电脑）已经从其在伦敦的本地网络移动到东京的另一个网络。一个远程客户端（左上角）决定向移动设备发送一个数据包。然而，它并不知道设备已经移动。由于它使用移动节点的本地地址71.13.204.20发送，其请求被路由到负责该网络的路由器，该路由器位于伦敦。移动设备不在那里，所以路由器无法将其交付。移动IP通过赋予移动设备和路由器将数据包从一处转发到另一处的功能来解决此问题。")所示。
- en: 'The tight binding of network ID and host IP address means that there are only
    two real options under conventional IP when a mobile device moves from one network
    to another:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 网络ID和主机IP地址的紧密绑定意味着，当移动设备从一个网络移动到另一个网络时，在传统的IP环境下，只有两种实际的选择：
- en: '**Change IP Address** We can change the IP address of the host to a new address
    that includes the network ID of the network to which it is moving.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改IP地址** 我们可以将主机的IP地址更改为一个新的地址，该地址包含它要移动到的网络的网络ID。'
- en: '**Decouple IP Routing from Address** We can change the way routing is done
    for the device, so that instead of routers sending datagrams to a device based
    on its network ID, they route based on its entire address.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**解耦IP路由与地址** 我们可以改变设备路由的方式，使得路由器不再根据设备的网络ID发送数据包到设备，而是根据其整个地址进行路由。'
- en: '![The main problem with mobile devices on IP internetworks In this example,
    a mobile device (the notebook PC) has been moved from its home network in London
    to another network in Tokyo. A remote client (upper left) decides to send a datagram
    to the mobile device. However, it has no idea the device has moved. Since it sends
    by using the mobile node''s home address, 71.13.204.20, its request is routed
    to the router responsible for that network, which is in London. The mobile device
    isn''t there, so the router can''t deliver it. Mobile IP solves this problem by
    giving mobile devices and routers the capability to forward datagrams from one
    location to another.](httpatomoreillycomsourcenostarchimages287939.png.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![移动设备在IP互联网上的主要问题 在这个例子中，一个移动设备（笔记本电脑）已经从其在伦敦的本地网络移动到东京的另一个网络。一个远程客户端（左上角）决定向移动设备发送一个数据包。然而，它并不知道设备已经移动。由于它使用移动节点的本地地址71.13.204.20发送，其请求被路由到负责该网络的路由器，该路由器位于伦敦。移动设备不在那里，所以路由器无法将其交付。移动IP通过赋予移动设备和路由器将数据包从一处转发到另一处的功能来解决此问题。](http://atomoreilly.com/source/nostarch/images/287939.png.jpg)'
- en: Figure 30-1. The main problem with mobile devices on IP internetworks In this
    example, a mobile device (the notebook PC) has been moved from its home network
    in London to another network in Tokyo. A remote client (upper left) decides to
    send a datagram to the mobile device. However, it has no idea the device has moved.
    Since it sends by using the mobile node's home address, 71.13.204.20, its request
    is routed to the router responsible for that network, which is in London. The
    mobile device isn't there, so the router can't deliver it. Mobile IP solves this
    problem by giving mobile devices and routers the capability to forward datagrams
    from one location to another.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-1. IP互联网中移动设备的主要问题 在这个例子中，一个移动设备（笔记本电脑）已从其在伦敦的本地网络移动到另一个在东京的网络。一个远程客户端（左上角）决定向移动设备发送数据报。然而，它不知道设备已经移动。由于它使用移动节点的本地地址71.13.204.20发送，其请求被路由到负责该网络的路由器，该路由器位于伦敦。移动设备不在那里，因此路由器无法将其传递。移动IP通过使移动设备和路由器能够将数据报从一个位置转发到另一个位置来解决此问题。
- en: 'These both seem like viable options at first glance, and if only a few devices
    tried them, they might work. Unfortunately, they are both inefficient, often impractical,
    and neither is scalable (practical when thousands or millions of devices try them)
    for these reasons:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这些看起来似乎都是可行的选择，如果只有少数设备尝试它们，它们可能有效。不幸的是，它们都效率低下，通常不实用，并且由于以下原因，它们都不具有可扩展性（当数千或数百万个设备尝试时是实用的）：
- en: Changing the IP address each time a device moves is time-consuming and normally
    requires manual intervention. In addition, the entire TCP/IP stack would need
    to be restarted, thereby breaking any existing connections.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次设备移动时更改IP地址既费时又通常需要人工干预。此外，整个TCP/IP堆栈都需要重新启动，从而中断任何现有的连接。
- en: If we change the mobile device's IP address, how do we communicate the change
    of address to other devices on the Internet? These devices will only have the
    mobile node's original home address, which means they won't be able to find it,
    even if we give it a new address matching its new location.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们更改移动设备的IP地址，我们如何将地址更改通知互联网上的其他设备？这些设备将只有移动节点的原始本地地址，这意味着即使我们给它一个与其新位置匹配的新地址，它们也无法找到它。
- en: Routing based on the entire address of a host would mean the entire Internet
    would be flooded with routing information for each and every mobile computer.
    Considering how much trouble has gone into developing technologies like classless
    addressing to reduce routing table entries, it's obvious this is a Pandora's box
    no one wants to touch.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主机完整地址的路由意味着整个互联网将被每个移动计算机的路由信息淹没。考虑到为了减少路由表条目而投入了大量精力开发诸如无类别寻址等技术，显然这是一个潘多拉的盒子，没有人愿意触碰。
- en: Tip
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** The basic problem with supporting mobile devices in IP internetworks
    is that routing is performed using the IP address. This means the IP address of
    a device is tied to the network where that the device is located. If a device
    changes networks, data sent to its old address cannot be delivered by conventional
    means. Traditional work-arounds, such as routing by the full IP address or changing
    IP addresses manually, often create more problems.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在IP互联网中支持移动设备的基本问题是使用IP地址进行路由。这意味着设备的IP地址与其所在网络绑定。如果设备更改网络，发送到其旧地址的数据无法通过常规方式传递。传统的解决方案，如通过完整IP地址进行路由或手动更改IP地址，通常会产生更多问题。'
- en: 'The Solution: Mobile IP'
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案：移动IP
- en: The solution to these difficulties was to define a new protocol especially to
    support mobile devices, which adds to the original IP. This protocol, called *IP
    Mobility Support for IPv4*, was first defined in RFC 2002, was updated in RFC
    3220, and is now described in RFC 3344\. The formal name given in that document
    title is rather long; the technology is more commonly called *Mobile IP*, both
    in the RFC itself and by networking professionals.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些困难的方法是定义一个新的协议，专门用于支持移动设备，该协议增加了原始IP的功能。这个协议被称为*IPv4的IP移动性支持*，最初在RFC 2002中定义，在RFC
    3220中更新，现在在RFC 3344中描述。该文档标题中给出的正式名称相当长；这项技术更常见地被称为*移动IP*，不仅在RFC本身中，而且在网络专业人士中也如此。
- en: 'To ensure its success, Mobile IP''s designers had to meet a number of important
    goals. The resulting protocol has these key attributes and features:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保其成功，移动IP的设计者必须达到一系列重要的目标。由此产生的协议具有以下关键属性和特性：
- en: '**Seamless Device Mobility Using Existing Device Address** Mobile devices can
    change their physical network attachment method and location while continuing
    to use their existing IP address.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用现有设备地址实现无缝设备移动** 移动设备可以在继续使用其现有IP地址的同时更改其物理网络连接方法和位置。'
- en: '**No New Addressing or Routing Requirements** The overall scheme for addressing
    and routing as in regular IP is maintained. IP addresses are still assigned in
    the conventional way by the owner of each device. No new routing requirements
    are placed on the internetwork, such as host-specific routes.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需新的寻址或路由要求** 与常规IP一样，寻址和路由的整体方案得到保持。IP地址仍然按照每个设备所有者的传统方式分配。不对互联网施加新的路由要求，例如主机特定的路由。'
- en: '**Interoperability** Mobile IP devices can still send to and receive from existing
    IP devices that do not know how Mobile IP works, and vice versa.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**互操作性** 移动IP设备仍然可以向不知道如何使用移动IP的现有IP设备发送和接收数据，反之亦然。'
- en: '**Layer Transparency** The changes made by Mobile IP are confined to the network
    layer. Transport layer and higher-layer protocols and applications are able to
    function as in regular IPv4, and existing connections can even be maintained across
    a move.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**层透明性** 移动IP所做的更改仅限于网络层。传输层和更高层的协议和应用程序能够像在常规IPv4中一样运行，并且现有的连接甚至可以在移动过程中保持。'
- en: '**Limited Hardware Changes** Changes are required to the mobile device''s software
    as well as to routers used directly by the mobile device. Other devices, however,
    do not need changes, including routers between the ones on the home and visited
    networks.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限的硬件更改** 需要修改移动设备的软件以及移动设备直接使用的路由器。然而，其他设备不需要更改，包括家庭网络和访问网络之间的路由器。'
- en: '**Scalability** Mobile IP allows a device to change from any network to any
    other, and supports this for an arbitrary number of devices. The scope of the
    connection change can be global; you could detach a notebook from an office in
    London and move it to Australia or Brazil, for example, and it will work the same
    as if you took it to the office next door.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展性** 移动IP允许设备从任何网络更改为任何其他网络，并支持任意数量的设备这样做。连接更改的范围可以是全球性的；例如，您可以从伦敦的办公室断开一台笔记本电脑并将其移动到澳大利亚或巴西，它的工作方式将与您将其带到隔壁办公室时相同。'
- en: '**Security** Mobile IP works by redirecting messages, and includes authentication
    procedures to prevent an unauthorized device from causing problems.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性** 移动IP通过重定向消息来工作，并包括认证程序以防止未经授权的设备引起问题。'
- en: Mobile IP accomplishes these goals by implementing a *forwarding system* for
    mobile devices. When a mobile unit is on its home network, it functions normally.
    When it moves to a different network, datagrams are sent from its home network
    to its new location. This allows normal hosts and routers that don't know about
    Mobile IP to continue to operate as if the mobile device had not moved. Special
    support services are required to implement Mobile IP; these services allow activities
    such as letting a mobile device determine where it is, telling the home network
    where to forward messages, and more.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP通过为移动设备实现一个*转发系统*来实现这些目标。当移动单元在其家庭网络中时，它正常工作。当它移动到不同的网络时，数据报从其家庭网络发送到其新位置。这使得不知道移动IP的正常主机和路由器可以继续像移动设备没有移动一样操作。需要特殊支持服务来实现移动IP；这些服务允许诸如让移动设备确定其位置、告诉家庭网络将消息转发到何处等活动。
- en: Tip
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** *Mobile IP* solves the problems associated with devices that
    change network locations by setting up a system whereby datagrams sent to the
    mobile node''s home location are forwarded to it wherever it may be located. It
    is particularly useful for wireless devices, but can be used for any device that
    moves between networks periodically.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** *移动IP* 通过建立一个系统来解决与设备更改网络位置相关的问题，该系统使得发送到移动节点家庭位置的数据报无论其位于何处都会被转发给它。它特别适用于无线设备，但也可以用于任何定期在网络上移动的设备。'
- en: Mobile IP is often associated with wireless networks, since devices using WLAN
    technology can move so easily from one network to another. However, it wasn't
    designed specifically for wireless. It can be equally useful for moving from an
    Ethernet network in one building to a network in another building, city, or country.
    Mobile IP can be of great benefit in numerous applications for traveling salespeople,
    consultants who visit client sites, administrators who walk around a campus troubleshooting
    problems, and many more.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP通常与无线网络相关联，因为使用WLAN技术的设备可以轻松地从一个网络移动到另一个网络。然而，它并不是专门为无线网络设计的。它同样适用于从一个建筑物的以太网网络移动到另一个建筑、城市或国家的网络。移动IP对于许多旅行销售人员、访问客户场所的顾问、在校园中四处走动解决问题的管理员等众多应用来说，可以带来极大的好处。
- en: Limitations of Mobile IP
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动IP的局限性
- en: It's important to realize that Mobile IP has certain limitations in its usefulness
    in a wireless environment. It was designed to handle the mobility of devices,
    but only relatively infrequent mobility. This is due to the work involved with
    each change. This overhead isn't a big deal when you move a computer once a week,
    once a day, or even once an hour. It can be an issue for "real-time" mobility,
    such as roaming in a wireless network, where handoff functions operating at the
    data link layer may be more suitable. Mobile IP was designed under the specific
    assumption that the attachment point would not change more than once per second.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到，移动IP在无线环境中的有用性存在某些局限性。它被设计来处理设备的移动性，但只有相对较少的移动性。这是由于每次更改所涉及的工作。当你每周、每天甚至每小时移动一次计算机时，这种开销并不是什么大问题。对于“实时”移动性，如无线网络中的漫游，数据链路层的手交功能可能更适合。移动IP是在特定的假设下设计的，即连接点不会每秒更改超过一次。
- en: Mobile IP is intended to be used with devices that maintain a static IP configuration.
    Since the device needs to be able to always know the identity of its home network
    and normal IP address, it is much more difficult to use it with a device that
    obtains an IP address dynamically, using something like the Dynamic Host Configuration
    Protocol (DHCP).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP旨在与保持静态IP配置的设备一起使用。由于设备需要能够始终知道其主网络和正常IP地址的身份，因此在使用动态获取IP地址的设备（如动态主机配置协议DHCP）时，它要困难得多。
- en: Mobile IP Concepts and General Operation
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP概念和通用操作
- en: 'I like analogies because they provide a way of explaining often dry technical
    concepts in terms that you can relate to. The problem of mobile devices in an
    IP internetwork can easily be compared to a real-life mobility and information
    transmission problem: mail delivery for those who travel.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢类比，因为它们提供了一种方式，用你可以理解的语言来解释通常枯燥的技术概念。移动设备在IP互联网中的问题可以很容易地与现实生活中移动和信息传输问题相比较：为那些旅行的人的邮件投递。
- en: Suppose you are a consultant working for a large corporation with many offices.
    Your home office is in London, England, and you spend about half your time there.
    The rest of the time is split between other offices in, say, Rome, Tokyo, New
    York City, and Toronto. You also occasionally visit client sites that can be just
    about anywhere in the world. You may be at these remote locations for weeks at
    a time.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名为大型公司工作的顾问，该公司拥有许多办事处。你的家办公室位于英国伦敦，你大约有一半的时间在那里。其余时间被分配给其他办事处，比如罗马、东京、纽约市和多伦多。你偶尔还会访问客户场所，这些场所可能遍布世界各地。你可能会在这些偏远地点待上几周的时间。
- en: 'The problem is how do you arrange things so that you can receive your mail
    regardless of your location? You have the same problem that regular IP has with
    a mobile device, and without taking special steps, you have the same two unsatisfactory
    options for resolving it: address changing or decoupling routing from your address.
    You can''t change your address each time you move because you would be modifying
    it constantly; by the time you told everyone about your new address, it would
    change again. And you certainly can''t "decouple" the routing of mail from your
    address, unless you want to set up your own postal system!'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是如何安排事情，以便无论你在哪里都能收到你的邮件？你面临的问题与常规IP在移动设备上遇到的问题相同，而且如果不采取特殊措施，你有两种不令人满意的选择来解决它：更改地址或解除地址与路由的耦合。你不能每次搬家时都更改你的地址，因为你需要不断地修改它；等你告诉每个人你的新地址时，它可能又变了。而且你当然不能“解除”邮件路由与你的地址的耦合，除非你想建立自己的邮政系统！
- en: The solution to this dilemma is *mail forwarding*. Let's say that you leave
    London for Tokyo for a couple of months. You tell the London post office (PO)
    that you will be in Tokyo. They intercept mail headed for your normal London address,
    relabel it, and forward it to Tokyo. Depending on where you are staying, this
    mail might be redirected either straight to a new address in Tokyo or to a Tokyo
    PO where you can pick it up. If you leave Tokyo to go to another city, you just
    call the London PO and tell them your new location. When you come home, you cancel
    the forwarding and get your mail as always. (Yes, I'm assuming London and Tokyo
    each have only one PO.)
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个困境的方法是**邮件转寄**。假设你离开伦敦去东京几个月。你告诉伦敦邮局（PO），你将在东京。他们会拦截寄往你正常伦敦地址的邮件，重新标记，并将其转发到东京。根据你停留的地方，这封邮件可能会直接转寄到东京的新地址，或者转寄到东京邮局，你可以在那里取件。如果你离开东京去另一个城市，你只需给伦敦邮局打电话，告诉他们你的新位置。当你回家时，你取消转寄，像往常一样取回你的邮件。（是的，我假设伦敦和东京每个地方只有一个邮局。）
- en: The advantages of this system are many. It is relatively simple to understand
    and implement. It is also transparent to everyone who sends you mail; they still
    send to you in London and it gets wherever it needs to go. And handling of the
    forwarding mechanism is done only by the London PO and possibly the PO where you
    are presently located; the rest of the postal system doesn't even know anything
    out of the ordinary is going on.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的优点很多。它相对简单易懂且易于实施。对于给你发送邮件的每个人来说，它也是透明的；他们仍然会将邮件发送到伦敦，而邮件会到达它需要去的地方。转寄机制的处理仅由伦敦邮局（PO）以及你目前所在地的邮局进行；邮政系统的其他部分甚至不知道有任何异常情况发生。
- en: There are some disadvantages, too. The London PO may allow occasional forwarding
    for free, but would probably charge you if you did this on a regular basis. You
    might also need a special arrangement in the city you travel to. You need to keep
    communicating with your home PO each time you move. And every piece of mail must
    be sent through the system twice—first to London and then to wherever you are
    located—which is inefficient.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点。伦敦邮局可能会免费提供偶尔的转寄服务，但如果你定期这样做，可能会向你收费。你可能在旅行的城市也需要特别的安排。每次搬家时，你都需要与你的家乡邮局保持沟通。而且，每一封信件都必须通过系统发送两次——首先发送到伦敦，然后发送到你所在的地方——这非常低效。
- en: Mobile IP works in a manner very similar to the mail-forwarding system I just
    described. The traveling consultant is the device that goes from network to network.
    Each network can be considered like a different city, and the internetwork of
    routers is like the postal system. The router that connects any network to the
    Internet is like that network's post office, from an IP perspective.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP的工作方式与我刚才描述的邮件转寄系统非常相似。移动顾问是那些在网络之间移动的设备。每个网络可以被视为一个不同的城市，路由器之间的互联网就像邮政系统。连接任何网络到互联网的路由器就像该网络的邮局，从IP的角度来看。
- en: The mobile node is normally resident on its home network, which is the one that
    is indicated by the network ID in its IP address. Devices on the internetwork
    always route using this address, so the pieces of "mail" (datagrams) always arrive
    at a router at the device's "home." When the device travels to another network,
    the home router ("post office") intercepts these datagrams and forwards them to
    the device's current address. It may send them straight to the device using a
    new, temporary address, or it may send them to a router on the device's current
    network (the "other post office" or Tokyo in our analogy) for final delivery.
    You can see an overview of Mobile IP operation in [Figure 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1,
    except that it shows Mobile IP implemented. The mobile node's home router serves
    as home agent, and the router in Tokyo serves as the foreign agent. The mobile
    has been assigned a temporary "care-of" address to use while in Tokyo (which in
    this case is a co-located care-of address, meaning that it is assigned directly
    to the mobile node. Figure 30-3 shows the same example using the other type of
    care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo.").
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 移动节点通常驻留在其本地网络上，这是由其IP地址中的网络ID指示的。互联网上的设备始终使用此地址进行路由，因此“邮件”（数据报）始终到达设备的“家”中的路由器。当设备前往另一个网络时，本地路由器（“邮局”）拦截这些数据报并将它们转发到设备的当前地址。它可以直接使用一个新的临时地址将它们发送到设备，或者将它们发送到设备当前网络上的路由器（在我们的类比中是“另一个邮局”或东京）以进行最终交付。您可以在[图30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "图30-2. 移动IP的通用操作 此图与图30-1类似，但显示了移动IP的实现。移动节点的本地路由器充当本地代理，而东京的路由器充当外地代理。移动节点在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个与本地节点共位的照顾地址，意味着它直接分配给移动节点。图30-3展示了使用另一种类型的照顾地址的相同示例）。在步骤1中，远程客户端使用其本地地址向移动节点发送数据报，就像正常的TCP/IP一样。它像往常一样到达伦敦。在步骤2中，本地代理将那个数据报封装在一个新的数据报中，并将其发送到东京的移动节点。")中查看移动IP操作的概述。
- en: '![General operation of Mobile IP This diagram is similar to , except that it
    shows Mobile IP implemented. The mobile node''s home router serves as home agent,
    and the router in Tokyo serves as the foreign agent. The mobile has been assigned
    a temporary "care-of" address to use while in Tokyo (which in this case is a co-located
    care-of address, meaning that it is assigned directly to the mobile node. shows
    the same example using the other type of care-of address). In step 1, the remote
    client sends a datagram to the mobile using its home address, as in normal TCP/IP.
    It arrives in London as usual. In step 2, the home agent encapsulates that datagram
    in a new one and sends it to the mobile node in Tokyo.](httpatomoreillycomsourcenostarchimages287941.png.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP的通用操作 此图与类似，但显示了移动IP的实现。移动节点的本地路由器充当本地代理，而东京的路由器充当外地代理。移动节点在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个与本地节点共位的照顾地址，意味着它直接分配给移动节点。展示了使用另一种类型的照顾地址的相同示例）。在步骤1中，远程客户端使用其本地地址向移动节点发送数据报，就像正常的TCP/IP一样。它像往常一样到达伦敦。在步骤2中，本地代理将那个数据报封装在一个新的数据报中，并将其发送到东京的移动节点。](httpatomoreillycomsourcenostarchimages287941.png.jpg)'
- en: Figure 30-2. General operation of Mobile IP This diagram is similar to [Figure 30-1](ch30.html#the_main_problem_with_mobile_devices_on_
    "Figure 30-1. The main problem with mobile devices on IP internetworks In this
    example, a mobile device (the notebook PC) has been moved from its home network
    in London to another network in Tokyo. A remote client (upper left) decides to
    send a datagram to the mobile device. However, it has no idea the device has moved.
    Since it sends by using the mobile node's home address, 71.13.204.20, its request
    is routed to the router responsible for that network, which is in London. The
    mobile device isn't there, so the router can't deliver it. Mobile IP solves this
    problem by giving mobile devices and routers the capability to forward datagrams
    from one location to another."), except that it shows Mobile IP implemented. The
    mobile node's home router serves as home agent, and the router in Tokyo serves
    as the foreign agent. The mobile has been assigned a temporary "care-of" address
    to use while in Tokyo (which in this case is a co-located care-of address, meaning
    that it is assigned directly to the mobile node. [Figure 30-3](ch30s03.html#mobile_ip_operation_with_a_foreign_agent
    "Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram
    is similar to Figure 30-2, except that instead of the mobile node having a co-located
    (distinct) IP address, here the mobile node is using a foreign agent care-of address.
    This means that the node's care-of address is actually that of the foreign agent
    itself. Step 1 is the same as in Figure 30-2, but in step 2, the home agent forwards
    not to the mobile node directly, but to the foreign agent (since that router is
    the one whose IP address the mobile is using). In step 3, the foreign agent strips
    off the home agent's packaging and delivers the original datagram to the mobile
    node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects
    the mobile node and foreign agent.") shows the same example using the other type
    of care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30-2. 移动 IP 的一般操作 这个图与 [图 30-1](ch30.html#the_main_problem_with_mobile_devices_on_
    "图 30-1. IP 互联网上移动设备的主要问题 在这个例子中，一个移动设备（笔记本电脑）已经从其在伦敦的本地网络移动到东京的另一个网络。一个远程客户端（左上角）决定向该移动设备发送一个数据报。然而，它并不知道设备已经移动。因为它使用的是移动节点的本地地址，71.13.204.20，所以它的请求被路由到负责该网络的路由器，该路由器位于伦敦。移动设备不在那里，所以路由器无法将其交付。移动
    IP 通过赋予移动设备和路由器将数据报从一处转发到另一处的功能来解决此问题。"), 除了它展示了移动 IP 的实现。移动节点的本地路由器作为本地代理，东京的路由器作为外地代理。移动设备在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个与本地节点共位的照顾地址，这意味着它直接分配给移动节点。[图
    30-3](ch30s03.html#mobile_ip_operation_with_a_foreign_agent "图 30-3. 使用外地代理照顾地址的移动
    IP 操作 这个图与图 30-2 类似，除了移动节点没有共位（不同的）IP 地址，在这里移动节点正在使用外地代理照顾地址。这意味着节点的照顾地址实际上是外地代理本身的地址。步骤
    1 与图 30-2 相同，但在步骤 2 中，本地代理不是直接转发到移动节点，而是转发到外地代理（因为那个路由器是移动节点正在使用的 IP 地址所在的路由器）。在步骤
    3 中，外地代理移除本地代理的包装，并将原始数据报交付给移动节点。这通常使用连接移动节点和外地代理的任何第 2 层（局域网或无线局域网）技术来完成。") 展示了使用另一种类型的照顾地址的相同示例）。在步骤
    1 中，远程客户端使用其本地地址向移动设备发送一个数据报，就像正常的 TCP/IP 一样。它像往常一样到达伦敦。在步骤 2 中，本地代理将那个数据报封装在一个新的数据报中，并将其发送到东京的移动节点。
- en: Mobile IP Device Roles
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动 IP 设备角色
- en: 'As you can see, just as mail forwarding requires support from one or more POs,
    Mobile IP requires the help of two routers. The following special names are given
    to the three main players that implement the protocol (also shown in [Figure 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1,
    except that it shows Mobile IP implemented. The mobile node''s home router serves
    as home agent, and the router in Tokyo serves as the foreign agent. The mobile
    has been assigned a temporary "care-of" address to use while in Tokyo (which in
    this case is a co-located care-of address, meaning that it is assigned directly
    to the mobile node. Figure 30-3 shows the same example using the other type of
    care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo.")):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，正如邮件转发需要来自一个或多个邮局的支持一样，移动IP需要两个路由器的帮助。以下特殊名称被赋予实现该协议的三个主要参与者（也显示在[图30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "图30-2. 移动IP的一般操作。此图类似于图30-1，除了它显示了实现的移动IP。移动节点的本地路由器充当本地代理，而在东京的路由器充当外地代理。移动节点在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个与移动节点共位的照顾地址，意味着它直接分配给移动节点。图30-3显示了使用另一种类型的照顾地址的相同示例）。在步骤1中，远程客户端使用其本地地址向移动节点发送数据报，就像正常的TCP/IP一样。它像往常一样到达伦敦。在步骤2中，本地代理将那个数据报封装在一个新的数据报中，并将其发送到东京的移动节点。”））：
- en: '**Mobile Node** This is the mobile device, the one moving around the internetwork.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动节点** 这是指移动设备，它在互联网中移动。'
- en: '**Home Agent** This is a router on the home network that is responsible for
    catching datagrams intended for the mobile node and forwarding them to it when
    it is traveling. It also implements other support functions that are necessary
    to run the protocol.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地代理** 这是主网络上的一个路由器，负责捕获目的地为移动节点的数据报，并在移动节点旅行时将其转发给它。它还实现了运行协议所需的其它支持功能。'
- en: '**Foreign Agent** This is a router on the network to which the mobile node
    is currently attached. It serves as a "home away from home" for the mobile node,
    and normally acts as its default router and implements Mobile IP functions. Depending
    on the mode of operation, it may receive forwarded datagrams from the home agent
    and forward them to the mobile node. It also supports the sharing of mobility
    information to make Mobile IP operate. The foreign agent may not be required in
    some Mobile IP implementations but is usually considered part of how the protocol
    operates.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**外地代理** 这是移动节点当前连接到的网络上的一个路由器。它作为移动节点的“家以外的家”，通常充当其默认路由器并实现移动IP功能。根据操作模式，它可能从本地代理接收转发数据报并将其转发到移动节点。它还支持共享移动信息，以使移动IP运行。在某些移动IP实现中可能不需要外地代理，但它通常被认为是协议运行的一部分。'
- en: Tip
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Mobile IP operates by setting up the TCP/IP equivalent of a
    mail-forwarding system. A router on a *mobile node*''s home network serves as
    the mobile device''s *home agent*, and one on its current network acts as the
    *foreign agent*. The home agent receives datagrams destined for the mobile''s
    normal IP address and forwards them to the mobile node''s current location, either
    directly or by sending the datagrams to the foreign agent. The home agent and
    foreign agent are also responsible for various communication and setup activities
    that are required for Mobile IP to work.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 移动IP通过设置TCP/IP邮件转发系统的等效系统来运行。在移动节点的主网络上的一个路由器充当移动设备的**本地代理**，而在其当前网络上的一个路由器充当**外地代理**。本地代理接收目的地为移动节点正常IP地址的数据报，并将它们转发到移动节点的当前位置，要么直接转发，要么通过将数据报发送到外地代理来实现。本地代理和外地代理还负责Mobile
    IP运行所需的各项通信和设置活动。'
- en: Mobile IP Functions
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动IP功能
- en: 'An important difference between Mobile IP and this mail-forwarding example
    is one that represents the classic distinction between people and computers: People
    are smart, and computers are not. When the consultant is traveling in Tokyo, he
    always knows he''s in Tokyo and that his mail is being forwarded. He knows that
    he must deal with the Tokyo PO to get his mail. The PO in London knows what forwarding
    is all about and how to do it. The traveler and the POs can communicate easily
    using the telephone.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP与这个邮件转发示例之间的重要区别代表了人们和计算机之间的经典区别：人是聪明的，而计算机则不是。当顾问在东京旅行时，他总是知道自己在东京，并且他的邮件正在转发。他知道他必须处理东京的邮局来取邮件。伦敦的邮局知道转发是怎么回事以及如何操作。旅行者和邮局可以通过电话轻松沟通。
- en: In contrast, in the computer world, when a device travels using Mobile IP, things
    are more complicated. Let's suppose the consultant flies to Tokyo, turns on his
    notebook, and plugs it in to the network. When the notebook is first turned on,
    it has no clue what is going on. The notebook has to figure out that it is in
    Tokyo. It needs to find a foreign agent in Tokyo. It needs to know what address
    to use while in Tokyo. It needs to communicate with its home agent back in London
    to tell it that it is in Tokyo and that the agent should start forwarding datagrams.
    Furthermore, it must accomplish its communication without any telephone.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，在计算机世界中，当设备使用移动IP进行移动时，事情变得更加复杂。假设顾问飞往东京，打开他的笔记本电脑，并将其连接到网络上。当笔记本电脑第一次打开时，它对正在发生的事情一无所知。笔记本电脑必须弄清楚它位于东京。它需要找到东京的外地代理。它需要知道在东京时应该使用什么地址。它需要与位于伦敦的本地代理通信，告诉它自己在东京，并让代理开始转发数据包。此外，它必须在不使用电话的情况下完成其通信。
- en: 'To this end, Mobile IP includes a host of special functions that are used to
    set up and manage datagram forwarding. To see how these support functions work,
    let''s look at the general operation of Mobile IP as a simplified series of steps:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，移动IP包括一系列用于设置和管理数据包转发的特殊功能。为了了解这些支持功能是如何工作的，让我们看看移动IP作为一系列简化步骤的一般操作：
- en: '**Agent Communication** The mobile node finds an agent on its local network
    by engaging in the *Agent Discovery* process. It listens for Agent Advertisement
    messages that are sent out by agents, and from this it can determine where it
    is located. If it doesn''t hear these messages it can ask for one using an Agent
    Solicitation message.'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代理通信** 移动节点通过参与*代理发现*过程在其本地网络上找到一个代理。它监听代理发送的代理广告消息，并据此确定其位置。如果它没有听到这些消息，它可以使用代理请求消息请求一个。'
- en: '**Network Location Determination** The mobile node determines whether it is
    on its home network or on a foreign one by looking at the information in the Agent
    Advertisement message.'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**网络位置确定** 移动节点通过查看代理广告消息中的信息来确定它是在本地网络还是在外地网络。'
- en: 'If it is on its home network, it functions using regular IP. To show how the
    rest of the process works, let''s say the device sees that it just moved to a
    foreign network. The remaining steps are as follows:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在本地网络中，它将使用常规IP进行操作。为了展示其余过程是如何工作的，让我们假设设备看到它刚刚移动到了一个外地网络。接下来的步骤如下：
- en: '**Care-Of Address Acquisition** The device obtains a temporary address called
    a *care-of address*. This either comes from the Agent Advertisement message from
    the foreign agent or through some other means. This address is used only as the
    destination point for forwarding datagrams, and for no other purpose.'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取关照地址** 设备获得一个称为*关照地址*的临时地址。这个地址要么来自外地代理的代理广告消息，要么通过其他方式。这个地址仅用作转发数据包的目的地，而不用于其他目的。'
- en: '**Agent Registration** The mobile node informs the home agent on its home network
    of its presence on the foreign network and enables datagram forwarding by *registering*
    with the home agent. This may be done either directly between the node and the
    home agent or indirectly using the foreign agent as a conduit.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代理注册** 移动节点通过向其本地网络上的本地代理注册其在外地网络上的存在，并通过*注册*启用数据包转发。这可以通过节点和本地代理之间的直接通信或通过使用外地代理作为中继的间接通信来完成。'
- en: '**Datagram Forwarding** The home agent captures datagrams intended for the
    mobile node and forwards them. It may send them either directly to the node or
    indirectly to the foreign agent for delivery, depending on the type of care-of
    address in use.'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据包转发** 本地代理捕获针对移动节点的数据包并将其转发。它可以直接将它们发送到节点，或者根据使用的代理地址类型间接发送到外地代理进行投递。'
- en: Datagram forwarding continues until the current agent registration expires.
    The device can then renew it. If it moves again, it repeats the process to get
    a new care-of address and then registers its new location with the home agent.
    When the mobile node returns to its home network, it *deregisters* to cancel datagram
    forwarding and resumes normal IP operation.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报转发会持续到当前代理注册到期。然后设备可以更新它。如果它再次移动，它会重复此过程以获取新的护理地址，然后向家乡代理注册其新位置。当移动节点返回其家乡网络时，它会*注销*以取消数据报转发并恢复正常的IP操作。
- en: The following sections look in more detail at the functions summarized in each
    of the previous steps.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将更详细地探讨前几步中总结的功能。
- en: 'Mobile IP Addressing: Home and Care-Of Addresses'
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP寻址：家乡地址和护理地址
- en: 'Just as most of us have only a single address used for mail, most IP devices
    have only a single address. Our traveling consultant, however, needs to have two
    addresses; a normal one and one that is used while he is away. Continuing the
    earlier analogy, the Mobile IP–equipped notebook the consultant carries needs
    to have two addresses:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们大多数人只有一个用于邮件的地址一样，大多数IP设备也只有一个地址。然而，我们的旅行顾问需要有两个地址；一个是正常的，另一个是在他外出时使用的。继续之前的类比，顾问携带的配备移动IP的笔记本电脑需要有两个地址：
- en: '**Home Address** The normal, permanent IP address assigned to the mobile node.
    This is the address used by the device on its home network, and the one to which
    datagrams intended for the mobile node are always sent.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**家乡地址**：分配给移动节点的正常、永久IP地址。这是设备在其家乡网络中使用的地址，也是数据报总是发送到的地址。'
- en: '**Care-Of Address** A secondary, temporary address used by a mobile node while
    it is traveling away from its home network. It is a normal 32-bit IP address in
    most respects, but is used only by Mobile IP for forwarding IP datagrams and for
    administrative functions. Higher layers never use it, nor do regular IP devices
    when creating datagrams.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**护理地址**：移动节点在离开其家乡网络旅行时使用的辅助、临时地址。在大多数方面，它是一个正常的32位IP地址，但仅由移动IP用于转发IP数据报和执行管理功能。高层从不使用它，常规IP设备在创建数据报时也不使用它。'
- en: The care-of address is a slightly tricky concept. There are two different types,
    which correspond to two distinctly different methods of forwarding datagrams from
    the home agent router.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 护理地址是一个稍微有些复杂的概念。有两种不同类型，分别对应于从家乡代理路由器转发数据报的两种截然不同的方法。
- en: Foreign Agent Care-Of Address
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外地代理护理地址
- en: The care-of address is provided by a foreign agent in its *Agent Advertisement*
    message. It is, in fact, the IP address of the foreign agent itself. When this
    type of care-of address is used, all datagrams captured by the home agent are
    not relayed directly to the mobile node, but indirectly to the foreign agent,
    which is responsible for final delivery. In this arrangement, the mobile node
    has no distinct IP address valid on the foreign network, so this is typically
    done using a layer 2 technology. This arrangement is illustrated in [Figure 30-3](ch30s03.html#mobile_ip_operation_with_a_foreign_agent
    "Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram
    is similar to Figure 30-2, except that instead of the mobile node having a co-located
    (distinct) IP address, here the mobile node is using a foreign agent care-of address.
    This means that the node's care-of address is actually that of the foreign agent
    itself. Step 1 is the same as in Figure 30-2, but in step 2, the home agent forwards
    not to the mobile node directly, but to the foreign agent (since that router is
    the one whose IP address the mobile is using). In step 3, the foreign agent strips
    off the home agent's packaging and delivers the original datagram to the mobile
    node. This is typically done using whatever layer 2 (LAN or WLAN) technology connects
    the mobile node and foreign agent.").
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 由外国代理在其*代理广告*消息中提供的是关照地址。实际上，这是外国代理自身的IP地址。当使用此类关照地址时，所有由本地代理捕获的数据报不会直接转发到移动节点，而是间接转发到外国代理，由其负责最终交付。在这种安排中，移动节点在外国网络上没有有效的独立IP地址，因此这通常使用第2层技术来完成。这种安排在[图30-3](ch30s03.html#mobile_ip_operation_with_a_foreign_agent
    "图30-3. 使用外国代理关照地址的移动IP操作 此图与图30-2类似，不同之处在于移动节点没有位于同一位置的（独立的）IP地址，而是使用外国代理的关照地址。这意味着节点的关照地址实际上是外国代理的地址。步骤1与图30-2相同，但在步骤2中，本地代理不是直接转发到移动节点，而是转发到外国代理（因为该路由器是移动节点使用的IP地址所在的路由器）。在步骤3中，外国代理移除本地代理的包装，并将原始数据报交付给移动节点。这通常使用连接移动节点和外国代理的任何第2层（局域网或无线局域网）技术来完成。"中进行了说明。
- en: '![Mobile IP operation with a foreign agent care-of address This diagram is
    similar to , except that instead of the mobile node having a co-located (distinct)
    IP address, here the mobile node is using a foreign agent care-of address. This
    means that the node''s care-of address is actually that of the foreign agent itself.
    Step 1 is the same as in , but in step 2, the home agent forwards not to the mobile
    node directly, but to the foreign agent (since that router is the one whose IP
    address the mobile is using). In step 3, the foreign agent strips off the home
    agent''s packaging and delivers the original datagram to the mobile node. This
    is typically done using whatever layer 2 (LAN or WLAN) technology connects the
    mobile node and foreign agent.](httpatomoreillycomsourcenostarchimages287943.png.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![使用外国代理关照地址的移动IP操作 此图与类似，不同之处在于移动节点没有位于同一位置的（独立的）IP地址，而是使用外国代理的关照地址。这意味着节点的关照地址实际上是外国代理的地址。步骤1与相同，但在步骤2中，本地代理不是直接转发到移动节点，而是转发到外国代理（因为该路由器是移动节点使用的IP地址所在的路由器）。在步骤3中，外国代理移除本地代理的包装，并将原始数据报交付给移动节点。这通常使用连接移动节点和外国代理的任何第2层（局域网或无线局域网）技术来完成。](httpatomoreillycomsourcenostarchimages287943.png.jpg)'
- en: Figure 30-3. Mobile IP operation with a foreign agent care-of address This diagram
    is similar to [Figure 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1,
    except that it shows Mobile IP implemented. The mobile node's home router serves
    as home agent, and the router in Tokyo serves as the foreign agent. The mobile
    has been assigned a temporary "care-of" address to use while in Tokyo (which in
    this case is a co-located care-of address, meaning that it is assigned directly
    to the mobile node. Figure 30-3 shows the same example using the other type of
    care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo."), except that instead of the mobile node having a co-located
    (distinct) IP address, here the mobile node is using a foreign agent care-of address.
    This means that the node's care-of address is actually that of the foreign agent
    itself. Step 1 is the same as in [Figure 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1,
    except that it shows Mobile IP implemented. The mobile node's home router serves
    as home agent, and the router in Tokyo serves as the foreign agent. The mobile
    has been assigned a temporary "care-of" address to use while in Tokyo (which in
    this case is a co-located care-of address, meaning that it is assigned directly
    to the mobile node. Figure 30-3 shows the same example using the other type of
    care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo."), but in step 2, the home agent forwards not to the
    mobile node directly, but to the foreign agent (since that router is the one whose
    IP address the mobile is using). In step 3, the foreign agent strips off the home
    agent's packaging and delivers the original datagram to the mobile node. This
    is typically done using whatever layer 2 (LAN or WLAN) technology connects the
    mobile node and foreign agent.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30-3. 使用国外代理的“照顾”地址的移动 IP 操作 此图与 [图 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "图 30-2. 移动 IP 的一般操作 此图与图 30-1 类似，但它显示了实现的移动 IP。移动节点的本地路由器充当本地代理，而东京的路由器充当国外代理。移动节点在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个位于同一地点的照顾地址，意味着它直接分配给移动节点。图
    30-3 使用另一种类型的照顾地址展示了相同的例子）。在步骤 1 中，远程客户端使用其本地地址向移动节点发送数据报，就像正常的 TCP/IP 一样。它像往常一样到达伦敦。在步骤
    2 中，本地代理将那个数据报封装在一个新的数据报中，并发送到东京的移动节点。”) 类似，但不同的是，移动节点没有位于同一地点（不同）的 IP 地址，这里移动节点正在使用国外代理的照顾地址。这意味着节点的照顾地址实际上是国外代理自己的地址。步骤
    1 与 [图 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag "图 30-2. 移动
    IP 的一般操作 此图与图 30-1 类似，但它显示了实现的移动 IP。移动节点的本地路由器充当本地代理，而东京的路由器充当国外代理。移动节点在东京期间被分配了一个临时的“照顾”地址来使用（在这种情况下是一个位于同一地点的照顾地址，意味着它直接分配给移动节点。图
    30-3 使用另一种类型的照顾地址展示了相同的例子）。在步骤 1 中，远程客户端使用其本地地址向移动节点发送数据报，就像正常的 TCP/IP 一样。它像往常一样到达伦敦。在步骤
    2 中，本地代理将那个数据报封装在一个新的数据报中，并发送到东京的移动节点。”) 相同，但在步骤 2 中，本地代理不是直接转发到移动节点，而是转发到国外代理（因为那个路由器是移动节点正在使用的
    IP 地址所属的路由器）。在步骤 3 中，国外代理移除本地代理的包装，并将原始数据报交付给移动节点。这通常使用连接移动节点和国外代理的任何第 2 层（局域网或无线局域网）技术来完成。
- en: In the consultant analogy, this type of care-of address is like forwarding from
    the London PO to the Tokyo PO. The London personnel would take a letter for John
    Smith sent to his London address, and repackage it for delivery to John Smith,
    care of the Tokyo post office. The Tokyo PO (or John Smith himself) would need
    to worry about the last leg of the delivery.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在顾问类比中，此类照顾地址就像从伦敦邮政局转发到东京邮政局。伦敦人员会取走寄给约翰·史密斯的信件，并重新包装以交付给东京的约翰·史密斯，由东京邮政局照顾。东京邮政局（或约翰·史密斯本人）需要担心最后一段的交付。
- en: Co-Located Care-Of Address
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同地照顾地址
- en: The co-located care-of address is assigned directly to the mobile node using
    some means that is external to Mobile IP. For example, it may be assigned on the
    foreign network manually, or it may be assigned automatically using DHCP. In this
    situation, the care-of address is used to forward traffic from the home agent
    directly to the mobile node. This was the type of address shown earlier in [Figure 30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "Figure 30-2. General operation of Mobile IP This diagram is similar to Figure 30-1,
    except that it shows Mobile IP implemented. The mobile node's home router serves
    as home agent, and the router in Tokyo serves as the foreign agent. The mobile
    has been assigned a temporary "care-of" address to use while in Tokyo (which in
    this case is a co-located care-of address, meaning that it is assigned directly
    to the mobile node. Figure 30-3 shows the same example using the other type of
    care-of address). In step 1, the remote client sends a datagram to the mobile
    using its home address, as in normal TCP/IP. It arrives in London as usual. In
    step 2, the home agent encapsulates that datagram in a new one and sends it to
    the mobile node in Tokyo.").
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 本地转交地址是直接使用移动IP之外的手段分配给移动节点的。例如，它可能在外国网络上手动分配，或者可能通过DHCP自动分配。在这种情况下，转交地址用于将来自本地代理的流量直接转发到移动节点。这种类型的地址在前面[图30-2](ch30s02.html#general_operation_of_mobile_ip_this_diag
    "图30-2. 移动IP的一般操作 此图与图30-1类似，不同之处在于它显示了已实现的移动IP。移动节点的本地路由器充当本地代理，东京的路由器充当外国代理。移动节点在东京期间被分配了一个临时的“转交”地址供其使用（在这种情况下是一个本地转交地址，意味着它直接分配给移动节点。图30-3展示了使用另一种类型的转交地址的相同示例）。在步骤1中，远程客户端使用其本地地址向移动节点发送一个数据报文，就像正常的TCP/IP一样。它像往常一样到达伦敦。在步骤2中，本地代理将那个数据报文封装在一个新的数据报文中，并将其发送到东京的移动节点。"）中已经展示过。
- en: In the consultant analogy, this is like John Smith obtaining a temporary address
    for his use while in Tokyo. The London PO would forward directly to his Tokyo
    address. They would not specifically send it to the Tokyo PO (although that PO
    would handle the mail at some point).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在顾问类比中，这就像约翰·史密斯在东京期间获得一个临时地址供其使用。伦敦的邮局会直接将其转发到他在东京的地址。他们不会特别将其发送到东京的邮局（尽管那个邮局会在某个时候处理邮件）。
- en: Tip
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In Mobile IP, each mobile device uses a temporary care-of address
    while on a foreign network. A co-located care-of address is one that is assigned
    directly to the mobile node and enables direct delivery of datagrams to the node.
    The alternative is to use a foreign agent care-of address. In this situation,
    the mobile node actually uses the IP address of the foreign agent. Datagrams are
    sent to the foreign agent, which delivers them to the mobile node.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在移动IP中，每个移动设备在外国网络中使用一个临时转交地址。一个本地转交地址是指直接分配给移动节点的地址，它能够直接将数据报文递送到该节点。另一种选择是使用外国代理转交地址。在这种情况下，移动节点实际上使用外国代理的IP地址。数据报文被发送到外国代理，然后由外国代理将它们递送到移动节点。'
- en: Advantages and Disadvantages of the Care-Of Address Types
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转交地址类型的优缺点
- en: The foreign agent care-of address is considered the type used in classic Mobile
    IP, where there is both a home agent and a foreign agent. While it seems less
    efficient than the co-located address method, it offers some important advantages,
    a key one being that the same foreign agent care-of address can be used for all
    mobile nodes visiting that network. Datagrams for all mobile nodes on that network
    are sent to the foreign agent, which completes the delivery to the individual
    nodes. Since the mobile nodes use the foreign agent's address, no extra addresses
    or extra work is required for each mobile node.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 外国代理转交地址被认为是经典移动IP中使用的类型，其中既有本地代理也有外国代理。虽然它似乎不如本地地址方法高效，但它提供了一些重要的优点，其中之一是，相同的国外代理转交地址可以用于访问该网络的全部移动节点。该网络上所有移动节点的数据报文都发送到外国代理，外国代理完成向各个节点的递送。由于移动节点使用外国代理的地址，因此不需要为每个移动节点额外分配地址或进行额外的工作。
- en: The co-located care-of address has the advantage that traffic can be forwarded
    directly from the home agent to the mobile node. In this type of arrangement,
    it is possible for a Mobile IP device to travel to a foreign network where there
    is no Mobile IP–aware router to act as a foreign agent. This does mean, however,
    that the Mobile IP implementation must include all the functions of communicating
    with the home agent that the foreign agent normally performs.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化照顾地址的优点是流量可以直接从本地代理转发到移动节点。在这种安排中，移动IP设备可以前往没有移动IP感知路由器作为外部代理的外部网络。这确实意味着移动IP实现必须包括外部代理通常执行的所有与本地代理通信的功能。
- en: When co-located care-of addresses are used, an issue is how the temporary address
    is obtained. In many foreign networks, automatic assignment of an IP address using
    something like DHCP may be possible, but if not, a temporary IP address would
    need to be assigned. Either way, some of the foreign network's limited IP address
    space would need to be set aside for mobile nodes, each of which would use an
    address while present on the network. In some cases, this could lead to an address
    depletion issue.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用本地化照顾地址时，一个问题是如何获得临时地址。在许多外部网络中，使用类似DHCP的东西自动分配IP地址可能是可能的，但如果不是这样，就需要分配一个临时IP地址。无论如何，都需要为移动节点预留一些外部网络的有限IP地址空间，每个移动节点在网络上存在时都会使用一个地址。在某些情况下，这可能导致地址耗尽问题。
- en: Foreign agent care-of addressing is usually preferred due to its more automatic
    nature, when a foreign agent is present on the visited network. Considering that
    all datagrams will need to go through some router on the foreign network to reach
    the mobile node anyway, we might as well save the extra IP addresses. Co-located
    care-of addresses would be used when there is no foreign agent, or might be practical
    for long-term connections even when a foreign agent is present.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其更自动化的特性，当访问网络中存在外部代理时，通常更倾向于使用外部代理的照顾地址。考虑到所有数据报无论如何都需要通过外部网络上的某些路由器到达移动节点，我们不妨节省额外的IP地址。在没有外部代理的情况下，或者即使存在外部代理，对于长期连接来说，也可能实用的是本地化照顾地址。
- en: Tip
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In Mobile IP, *co-located care-of addresses* have the advantage
    of flexibility, but require each device to have a unique IP address on the remote
    network. Foreign agent care-of addresses have the chief advantage of allowing
    many mobile devices on a foreign network without each requiring a distinct IP
    address.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在移动IP中，*本地化照顾地址*具有灵活性的优点，但要求每个设备在远程网络中都有一个唯一的IP地址。外部代理照顾地址的主要优点是允许外部网络上有许多移动设备，而无需每个设备都有一个不同的IP地址。'
- en: Remember that the care-of address represents only the destination to which mobile
    node datagrams are forwarded. Foreign agents provide services other than forwarding,
    so it is possible for a mobile node to use a co-located care-of address even when
    a foreign agent is present, while continuing to take advantage of the other foreign
    agent services.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，照顾地址仅代表移动节点数据报被转发的目的地。外部代理提供除转发之外的服务，因此即使存在外部代理，移动节点也可以使用本地化照顾地址，同时继续利用其他外部代理服务。
- en: For more information on how datagrams are forwarded between the home agent and
    the mobile node's care-of address, see the section on Mobile IP encapsulation
    and tunneling, later in this chapter.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据报如何在本地代理和移动节点照顾地址之间转发，更多信息请参阅本章后面的移动IP封装和隧道部分。
- en: Mobile IP Agent Discovery
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP代理发现
- en: When a mobile node is first turned on, it cannot assume that it is still at
    home, the way normal IP devices do. It must first determine where it is, and if
    it is not at home, begin the process of setting up datagram forwarding from its
    home network. This process is accomplished by communicating with a local router
    that's serving as an agent through the process called *Agent Discovery*.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动节点首次开启时，它不能像正常IP设备那样假设它仍然在家。它必须首先确定自己的位置，如果不是在家，就开始从其本地网络设置数据报转发的过程。这个过程是通过与充当代理的本地路由器通信，通过称为*代理发现*的过程来完成的。
- en: Agent Discovery Process
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理发现过程
- en: 'Agent discovery encompasses the first three steps in the simplified five-step
    Mobile IP operational summary I gave earlier in discussing general Mobile IP operation.
    The main goals of Agent Discovery include the following:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 代理发现包括我在之前讨论一般移动IP操作时给出的简化五步移动IP操作总结的前三个步骤。代理发现的主要目标包括以下内容：
- en: '**Agent/Node Communication** Agent Discovery is the method by which a mobile
    node first establishes contact with an agent on the local network to which it
    is attached. Messages containing important information about the agent are sent
    from the agent to the node. A message can also be sent from the node to the agent
    asking for this information to be sent.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理/节点通信** 代理发现是移动节点首先与其附加的本地网络上的代理建立联系的方法。包含有关代理的重要信息的消息从代理发送到节点。节点也可以发送消息给代理，请求发送这些信息。'
- en: '**Orientation** The node uses the Agent Discovery process to determine where
    it is. Specifically, it learns whether it is on its home network or a foreign
    network by identifying the agent that sends it messages.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**定位** 节点通过代理发现过程来确定其位置。具体来说，它通过识别发送消息的代理来学习它是在其本地网络还是外国网络。'
- en: '**Care-Of Address Assignment** The Agent Discovery process is the method used
    to tell a mobile node the care-of address it should use, when foreign agent care-of
    addressing is used.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理地址分配** 当使用外国代理地址分配时，代理发现过程是告知移动节点应使用哪个代理地址的方法。'
- en: Mobile IP agents are routers that have been given additional programming to
    make them Mobile IP-aware. The communication between a mobile node and the agent
    on its local network is basically the same as the normal communication required
    between a device on an IP network and its local router, except more information
    needs to be sent when the router is an agent.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP代理是经过额外编程以使其能够识别移动IP的路由器。移动节点与其本地网络上的代理之间的通信基本上与IP网络上设备与其本地路由器之间的常规通信相同，只是在路由器是代理时需要发送更多信息。
- en: Agent Advertisement and Agent Solicitation Messages
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理广告和代理请求消息
- en: 'Provision already exists for exchanges of data between a router and a node
    in the form of Internet Control Message Protocol (ICMP) messages that are used
    for the regular IP *Router Discovery* process. Two messages are used for this
    purpose: Router Advertisement messages that let routers tell local nodes that
    they exist and describe their capabilities, and Router Solicitation messages that
    let a node prompt a router to send an advertisement. These are described in [Chapter 33](ch33.html
    "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS").'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 已经存在以互联网控制消息协议（ICMP）消息的形式在路由器和节点之间交换数据的方案，这些消息用于常规IP路由器发现过程。为此目的使用了两个消息：路由器广告消息，允许路由器告诉本地节点它们的存在并描述其功能；以及路由器请求消息，允许节点提示路由器发送广告。这些在[第33章](ch33.html
    "第33章。ICMPV4信息性消息类型和格式")中进行了描述。
- en: 'Given the similarity to normal Router Discovery, it made sense to implement
    Agent Discovery as a modification to the existing process rather than set up a
    whole new system. The messages used in the Agent Discovery process are as follows:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与常规路由器发现的相似性，将代理发现作为现有过程的修改而不是建立全新的系统来实现是有意义的。代理发现过程中使用的消息如下：
- en: '**Agent Advertisement** This is a message transmitted regularly by a router
    acting as a Mobile IP agent. It consists of a regular Router Advertisement message
    that has one or more *extensions* added that contain Mobile IP–specific information
    for mobile nodes.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理广告** 这是一个由作为移动IP代理的网关定期传输的消息。它由一个或多个添加了包含移动节点特定信息的扩展的常规路由器广告消息组成。'
- en: '**Agent Solicitation** This message can be sent by a Mobile IP device to nudge
    a local agent to send an Agent Advertisement message.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理请求** 这个消息可以被移动IP设备发送，以促使本地代理发送代理广告消息。'
- en: The use of these messages is described in the Mobile IP standard in detail,
    and unsurprisingly, is very similar to how regular Router Advertisement and Router
    Solicitation messages are employed. Agents are normally configured to send out
    Agent Advertisements on a regular basis, with the rate set to ensure reasonably
    fast contact with mobile nodes without consuming excessive network bandwidth.
    They are required to respond to any Agent Solicitation messages they receive by
    sending an Advertisement. It is possible that some agents may be configured to
    send Advertisements only upon receipt of a Solicitation.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息的使用在移动IP标准中进行了详细描述，并且不出所料，与常规路由器广告和路由器请求消息的使用非常相似。代理通常配置为定期发送代理广告，速率设置为确保与移动节点快速联系而不消耗过多的网络带宽。它们必须通过发送广告来响应它们收到的任何代理请求消息。可能某些代理被配置为仅在收到请求时发送广告。
- en: Mobile nodes are required to accept and process Agent Advertisements. They distinguish
    these from regular Router Advertisements by looking at the size of the message.
    They then parse the extension(s) to learn the capabilities of the local agent.
    They determine whether they are on their home network or a foreign network, and
    in the case of a foreign agent, how the agent should be used. Mobile nodes are
    required to use Agent Advertisements to detect when they have moved, using one
    of two algorithms defined in the standard. Mobile nodes are also required to detect
    when they have returned to their home network after they have been traveling.
    Finally, they are also required to be able to send Agent Solicitation messages
    if they don't receive an Agent Advertisement after a certain period of time. They
    are restricted to sending these only infrequently, however, in order to keep traffic
    manageable.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 移动节点需要接受和处理代理通告。它们通过查看消息的大小来区分这些通告和常规路由器通告。然后它们解析扩展（s）以了解本地代理的能力。它们确定自己是在本地网络还是外国网络，以及在外国代理的情况下，如何使用代理。移动节点需要使用代理通告来检测它们何时移动，使用标准中定义的两个算法之一。移动节点还需要检测在旅行后何时返回到本地网络。最后，如果它们在一段时间后没有收到代理通告，它们还需要能够发送代理请求消息。然而，它们被限制只在不经常发送这些消息，以保持流量可管理。
- en: Now let's look at the formats of the two message types.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看这两种消息类型的格式。
- en: Agent Solicitation Message Format
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理请求消息格式
- en: The Agent Solicitation message is simple. In fact, there is no new message format
    defined for this at all; it is identical to the format of a Router Solicitation
    message (see [Chapter 33](ch33.html "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE
    TYPES AND FORMATS")).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 代理请求消息很简单。实际上，根本为这个消息定义了新的消息格式；它与路由器请求消息的格式完全相同（见[第33章](ch33.html "第33章。ICMPV4信息性消息类型和格式")）。
- en: 'The reason no new message type is required here is that a solicitation is an
    extremely simple message: "Hey, if there are any routers out there, please tell
    me who you are and what you can do." No extra Mobile IP information needs to be
    sent. When a regular IP router receives a Router Solicitation, it will send a
    Router Advertisement, but a Mobile IP router automatically sends the longer Agent
    Advertisement instead when prompted by any solicitation, whether it comes from
    a Mobile IP node or a regular IP device.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里不需要新的消息类型的原因是，请求消息非常简单：“嘿，如果这里有任何路由器，请告诉我你是谁以及你能做什么。”不需要发送额外的移动IP信息。当一个常规IP路由器接收到路由器请求时，它会发送路由器通告，但当一个移动IP路由器在收到任何请求（无论来自移动IP节点还是常规IP设备）时，它会自动发送更长的代理通告。
- en: Agent Advertisement Message Format
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理通告消息格式
- en: The Agent Advertisement begins with the normal fields of an ICMP Router Advertisement
    message (see [Chapter 33](ch33.html "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE
    TYPES AND FORMATS")). The destination of the message is either the "all devices"
    multicast address (224.0.0.1) if multicast is supported on the local network,
    or the broadcast address (255.255.255.255) otherwise. The *Router Address* fields
    are filled in with the address(es) of the agent.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 代理通告以ICMP路由器通告消息的正常字段开始（见[第33章](ch33.html "第33章。ICMPV4信息性消息类型和格式")）。如果本地网络支持多播，则消息的目标是“所有设备”多播地址（224.0.0.1），否则是广播地址（255.255.255.255）。*路由器地址*字段用代理的地址（们）填充。
- en: Note
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*It is possible that a device may wish to advertise its ability to handle Mobile
    IP messages, but not act as a regular router. In this case it changes the normal
    Code field in the header of the Router Advertisement message from 0 to 16*.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个设备可能希望宣传其处理移动IP消息的能力，但又不希望作为常规路由器。在这种情况下，它将路由器通告消息头中的正常代码字段从0更改为16*。'
- en: 'Following the regular fields, one or more extensions are added:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规字段之后，添加了一个或多个扩展：
- en: '**Mobility Agent Advertisement Extension** This is the main extension used
    to convey Mobile IP capabilities of the agent to mobile nodes on the local network.
    This field is described in Tables [Table 30-1](ch30s04.html#mobile_ip_mobility_agent_advertise-id001
    "Table 30-1. Mobile IP Mobility Agent Advertisement Extension Format") and [Table 30-2](ch30s04.html#mobile_ip_mobility_agent_advertise-id002
    "Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags") and illustrated
    in [Figure 30-4](ch30s04.html#mobile_ip_mobility_agent_advertisement_e "Figure 30-4. Mobile
    IP Mobility Agent Advertisement Extension format This extension appears after
    the normal fields of a Router Advertisement message, as shown in Chapter 33.").'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动代理广告扩展** 这是主要用于向本地网络上的移动节点传达代理的移动IP功能的主要扩展。该字段在表[表30-1](ch30s04.html#mobile_ip_mobility_agent_advertise-id001
    "表30-1. 移动IP移动代理广告扩展格式")和[表30-2](ch30s04.html#mobile_ip_mobility_agent_advertise-id002
    "表30-2. 移动IP移动代理广告扩展标志")中描述，并在[图30-4](ch30s04.html#mobile_ip_mobility_agent_advertisement_e
    "图30-4. 移动IP移动代理广告扩展格式 此扩展出现在路由器广告消息的正常字段之后，如图33章中所示。")中说明。'
- en: '**Prefix-Lengths Extension** This is an optional extension that tells a mobile
    node the prefix length(s) of the router address(es) contained in the regular portion
    of the Agent Advertisement message; that is, the Router Address field in the regular
    Router Advertisement part of the message. The prefix length is another term for
    the number of bits of a network ID in an address, so this specifies the network
    ID in the router addresses. This field is described in [Table 30-3](ch30s04.html#mobile_ip_prefix-lengths_extension_forma
    "Table 30-3. Mobile IP Prefix-Lengths Extension Format") and illustrated in [Figure 30-5](ch30s04.html#mobile_ip_prefix-lengths_extension-id001
    "Figure 30-5. Mobile IP Prefix-Lengths Extension format This extension appears
    after the normal fields of a Router Advertisement message, as shown in Chapter 33.").'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**前缀长度扩展** 这是一个可选扩展，它告诉移动节点包含在代理广告消息常规部分中的路由器地址的前缀长度（s）；即消息常规路由器广告部分的路由器地址字段。前缀长度是地址中网络ID位数的另一个术语，因此它指定了路由器地址中的网络ID。该字段在[表30-3](ch30s04.html#mobile_ip_prefix-lengths_extension_forma
    "表30-3. 移动IP前缀长度扩展格式")中描述，并在[图30-5](ch30s04.html#mobile_ip_prefix-lengths_extension-id001
    "图30-5. 移动IP前缀长度扩展格式 此扩展出现在路由器广告消息的正常字段之后，如图33章中所示。")中说明。'
- en: '**One-Byte Padding Extension** Some implementations require ICMP messages to
    be an even number of bytes, so a byte of padding is needed. This field is just
    a single byte of all zeros.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**单字节填充扩展** 一些实现要求ICMP消息的字节数为偶数，因此需要一个填充字节。该字段仅包含一个全零字节。'
- en: Tip
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Mobile IP *Agent Discovery* is the process by which a mobile
    node determines where it is located and establishes contact with a home or foreign
    agent. To indicate their capabilities, routers that can function as agents regularly
    send *Agent Advertisement* messages, which are modified versions of regular *Router
    Advertisements*. To request the sending of an *Advertisement*, a mobile node can
    also send an *Agent Solicitation*, which is the same as a regular *Router Solicitation*.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 移动IP *代理发现* 是移动节点确定其位置并与本地或外地代理建立联系的过程。为了表明其能力，可以作为代理的路由器会定期发送*代理广告*消息，这些消息是常规*路由器广告*的修改版本。为了请求发送*广告*，移动节点也可以发送*代理请求*，它与常规*路由器请求*相同。'
- en: I should point out that Mobile IP does not include any provisions for the authentication
    of *Agent Advertisement* and *Agent Solicitation* messages. They may be authenticated
    using IPsec, if that has been implemented.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，移动IP不包含对*代理广告*和*代理请求*消息进行认证的任何规定。如果已实现，它们可以使用IPsec进行认证。
- en: '![Mobile IP Mobility Agent Advertisement Extension format This extension appears
    after the normal fields of a Router Advertisement message, as shown in .](httpatomoreillycomsourcenostarchimages287945.png.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP移动代理广告扩展格式 此扩展出现在路由器广告消息的正常字段之后，如图所示。](httpatomoreillycomsourcenostarchimages287945.png.jpg)'
- en: Figure 30-4. Mobile IP Mobility Agent Advertisement Extension format This extension
    appears after the normal fields of a Router Advertisement message, as shown in
    [Chapter 33](ch33.html "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS").
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-4. 移动IP移动代理广告扩展格式 此扩展出现在路由器广告消息的正常字段之后，如图[第33章](ch33.html "第33章. ICMPV4
    信息性消息类型和格式")中所示。
- en: Table 30-1. Mobile IP Mobility Agent Advertisement Extension Format
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-1. 移动IP移动代理广告扩展格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the Agent Advertisement extension type. For the Mobility
    Agent Advertisement Extension, it is set to 16. |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别代理广告扩展类型。对于移动性代理广告扩展，它设置为16。 |'
- en: '| Length | 1 | Length of the extension in bytes, excluding the Type and Length
    fields. Thus, it is equal to 6 plus 4 for each care-of address in the message.
    |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 扩展的长度（字节），不包括类型和长度字段。因此，它等于6加上消息中每个代管地址的4个字节。 |'
- en: '| Sequence Number | 2 | A sequential counter is set to zero when the router
    initializes and then incremented for each advertisement sent out. |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 序列号 | 2 | 当路由器初始化时，设置一个顺序计数器为零，然后为发送出的每个广告递增。 |'
- en: '| Registration Lifetime | 2 | The maximum length of time, in seconds, that
    the agent is willing to accept for registration requests. A value of 65,535 (all
    ones) means infinite. Note that this field is for registration only and has no
    relation to the regular Lifetime field in the regular Router Advertisement part
    of the message. |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| 注册生存时间 | 2 | 代理愿意接受注册请求的最大时间长度，以秒为单位。65,535（全为1）表示无限。请注意，此字段仅用于注册，与消息常规路由器广告部分的常规生存时间字段无关。
    |'
- en: '| Flags | 1 | A one-byte field containing several informational flags that
    convey specific information about the agent''s capabilities and status. There
    are seven one-bit flags, which, when set, convey the meanings shown in [Table 30-2](ch30s04.html#mobile_ip_mobility_agent_advertise-id002
    "Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags"). |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 1 | 一个包含多个信息标志的字节字段，这些标志传达有关代理能力和状态的具体信息。有七个单比特标志，当设置时，传达[表30-2](ch30s04.html#mobile_ip_mobility_agent_advertise-id002
    "表30-2. 移动IP移动代理广告扩展标志")中所示的含义。 |'
- en: '| Reserved | 1 | Sent as zero and ignored by recipient. |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| 保留 | 1 | 作为零发送并由接收者忽略。 |'
- en: '| Care-Of Addresses | Variable (4 per address) | Zero or more addresses provided
    by a foreign agent for a mobile node to use as a foreign agent care-of address.
    A foreign agent must always provide at least one address in its advertisement.
    A router that cannot act as a foreign agent will typically omit this field. |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| 代管地址 | 可变（每个地址4个） | 由外国代理提供的零个或多个地址，供移动节点作为外国代理代管地址使用。外国代理必须在它的广告中提供至少一个地址。不能作为外国代理的路由器通常会省略此字段。
    |'
- en: Table 30-2. Mobile IP Mobility Agent Advertisement Extension Flags
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-2. 移动IP移动代理广告扩展标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| R | 1/8 (1 bit) | Registration Required: The mobile node must register through
    the foreign agent, even when using a co-located care-of address. |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| R | 1/8（1位） | 注册要求：即使使用本地代管地址，移动节点也必须通过外国代理进行注册。 |'
- en: '| B | 1/8 (1 bit) | Busy: The agent is currently too busy to accept further
    registrations from mobile nodes. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| B | 1/8（1位） | 忙碌：代理目前太忙，无法接受来自移动节点的进一步注册。 |'
- en: '| H | 1/8 (1 bit) | Home Agent: The agent is willing to function as a home
    agent on this link (it will forward datagrams, and so on). Note that a device
    can offer services as both a home agent and a foreign agent. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| H | 1/8（1位） | 家庭代理：代理愿意在此链路上作为家庭代理运行（它将转发数据报等）。请注意，设备可以作为家庭代理和外国代理同时提供服务。
    |'
- en: '| F | 1/8 (1 bit) | Foreign Agent: The agent is willing to function as a foreign
    agent. Again, a device can act as both a home agent and a foreign agent simultaneously.
    |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| F | 1/8（1位） | 外国代理：代理愿意作为外国代理运行。同样，设备可以同时作为家庭代理和外国代理。 |'
- en: '| M | 1/8 (1 bit) | Minimal Encapsulation: The agent can receive tunneled datagrams
    using minimal encapsulation. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| M | 1/8（1位） | 最小封装：代理可以使用最小封装接收隧道数据报。 |'
- en: '| G | 1/8 (1bit) | GRE Encapsulation: The agent can receive tunneled datagrams
    using GRE encapsulation. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| G | 1/8（1位） | GRE 封装：代理可以使用GRE封装接收隧道数据报。 |'
- en: '| r | 1/8 (1 bit) | Reserved: Not used; sent as zero. |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| r | 1/8（1位） | 保留：未使用；发送为零。 |'
- en: '| T | 1/8 (1 bit) | Reverse Tunneling: The agent supports reverse tunneling.
    |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| T | 1/8（1位） | 反向隧道：代理支持反向隧道。 |'
- en: Table 30-3. Mobile IP Prefix-Lengths Extension Format
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-3. 移动IP前缀长度扩展格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the Agent Advertisement extension type. For the Prefix-Lengths
    Extension, it is set to 19. |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别代理通告扩展类型。对于前缀长度扩展，它设置为19。|'
- en: '| Length | 1 | Length of the extension in bytes, excluding the Type and Length
    fields. Thus, it is equal to the number of prefix lengths (since each takes 1
    byte). |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 1 | 扩展的长度（以字节为单位），不包括类型和长度字段。因此，它等于前缀长度的数量（因为每个长度占用1个字节）。|'
- en: '| Prefix Lengths | Variable (1 per length) | One prefix length number for each
    router address in the regular, Router Advertisement portion of the Agent Advertisement.
    |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 前缀长度 | 可变（每个长度1个） | 每个路由器地址在代理通告的常规路由通告部分中对应一个前缀长度数字。|'
- en: '![Mobile IP Prefix-Lengths Extension format This extension appears after the
    normal fields of a Router Advertisement message, as shown in .](httpatomoreillycomsourcenostarchimages287947.png.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP前缀长度扩展格式 此扩展出现在路由通告消息的正常字段之后，如图所示。](httpatomoreillycomsourcenostarchimages287947.png.jpg)'
- en: Figure 30-5. Mobile IP Prefix-Lengths Extension format This extension appears
    after the normal fields of a Router Advertisement message, as shown in [Chapter 33](ch33.html
    "Chapter 33. ICMPV4 INFORMATIONAL MESSAGE TYPES AND FORMATS").
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-5. 移动IP前缀长度扩展格式 此扩展出现在路由通告消息的正常字段之后，如图[第33章](ch33.html "第33章. ICMPV4 信息性消息类型和格式")所示。
- en: See the section on Mobile IP encapsulation later in this chapter for details
    on minimal and Generic Routing Encapsulation (GRE) encapsulation and reverse tunneling.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的移动IP封装部分中，请参阅有关最小和通用路由封装（GRE）封装以及反向隧道详情。
- en: Mobile IP Home Agent Registration and Registration Messages
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP家园代理注册和注册消息
- en: Once a mobile node has completed Agent Discovery, it knows whether it is on
    its home network or a foreign network. If it's on its home network, it communicates
    as a regular IP device, but if it's on a foreign network, it must activate Mobile
    IP. This requires that it communicate with its home agent so that information
    and instructions can be exchanged between the two. This process is called *home
    agent registration*, or more simply, just *registration*.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦移动节点完成了代理发现，它就知道自己是在家园网络还是外网。如果它在家园网络，它就像一个常规IP设备一样进行通信，但如果它在外网，它必须激活移动IP。这需要它与家园代理通信，以便两者之间可以交换信息和指令。这个过程称为
    *家园代理注册*，或者更简单地说，就是 *注册*。
- en: The main purpose of registration is to actually start Mobile IP working. The
    mobile node must contact the home agent and tell it that it is on a foreign network
    and request that datagram forwarding be turned on. It also must let the home agent
    know its care-of address so the home agent knows where to send the forwarded datagrams.
    The home agent needs to communicate various types of information back to the mobile
    node when registration is performed. Note that the foreign agent is not really
    involved in registration, except perhaps to relay messages.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注册的主要目的是实际上启动移动IP工作。移动节点必须联系家园代理，并告知它已进入外网，并请求开启数据报文转发。它还必须让家园代理知道其处理地址，以便家园代理知道将转发数据报文发送到何处。在执行注册时，家园代理需要将各种类型的信息反馈给移动节点。请注意，外网代理实际上并不参与注册，除非可能用于中继消息。
- en: Mobile Node Registration Events
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动节点注册事件
- en: 'Successful registration establishes what is called in the standard a *mobility
    binding* between a home agent and a mobile node. For the duration of the registration,
    the mobile node''s regular home address is tied to its current care-of address,
    and the home agent will encapsulate and forward datagrams addressed to the home
    address over to the care-of address. The mobile node is supposed to manage its
    registration and handle various events using the following actions:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的注册在标准中建立了一个称为 *移动绑定* 的家园代理和移动节点之间的绑定。在注册期间，移动节点的常规家园地址与其当前的处理地址绑定，家园代理将封装并转发指向家园地址的数据报文到处理地址。移动节点应通过以下操作来管理其注册和处理各种事件：
- en: '**Registration** The mobile node initiates a *registration* when it first detects
    it has moved from its home network to a foreign network.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**注册** 当移动节点首次检测到它已从家园网络移动到外网时，它将启动一个 *注册*。'
- en: '**Deregistration** When the mobile node returns home, it should tell the home
    agent to cancel forwarding—a process called *deregistration*.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**注销** 当移动节点返回家园时，它应该通知家园代理取消转发——这个过程称为 *注销*。'
- en: '**Reregistration** If the mobile node moves from one foreign network to another,
    or if its care-of address changes, it must update its registration with the home
    agent. It also must do so if its current registration is about to expire, even
    if it remains stationary on one foreign network.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新注册** 如果移动节点从一个外国网络移动到另一个网络，或者其care-of地址发生变化，它必须更新其与本地代理的注册。即使它停留在外国网络上的一个位置，如果当前的注册即将到期，它也必须这样做。'
- en: Each registration is established only for a specific length of time, which is
    why regular reregistration is required whether or not the device moves. Registrations
    are time-limited to ensure that they do not become stale. If, for example, a node
    forgets to deregister when it returns home, the datagram forwarding will eventually
    stop when the registration expires.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 每个注册仅针对特定的时间长度，这就是为什么无论设备是否移动，都需要定期重新注册。注册的时间限制确保它们不会过时。例如，如果一个节点忘记在返回时注销，当注册到期时，数据报转发最终会停止。
- en: Registration Request and Registration Reply Messages
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册请求和注册回复消息
- en: 'To perform registration, two new message types have been defined in Mobile
    IP: the *Registration Request* and the *Registration Reply*. Each of these does
    what you would expect from its name. Interestingly, these are not ICMP messages
    like the ones used in Agent Discovery; they are User Datagram Protocol (UDP) messages.
    Thus, technically speaking, registration is performed at a higher layer than the
    rest of Mobile IP communication. Agents listen for Registration Requests on well-known
    UDP port 434, and respond back to mobile nodes using whatever ephemeral port the
    node used to send the message.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行注册，在移动IP中定义了两种新的消息类型：*注册请求*和*注册回复*。每个都按照其名称所暗示的执行操作。有趣的是，这些不是像代理发现中使用的ICMP消息，而是用户数据报协议（UDP）消息。因此，从技术上讲，注册是在比移动IP通信的其他部分更高的层次上执行的。代理在众所周知的UDP端口434上监听注册请求，并使用节点发送消息时使用的任何临时端口回应移动节点。
- en: Registration Process
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册过程
- en: 'There are two different procedures defined for registration, depending on the
    type of care-of address used by the mobile node, and other specifics that I will
    get into shortly. The first is the direct registration method, which has only
    two steps:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 根据移动节点使用的care-of地址类型以及其他我将简要说明的特定情况，定义了两种不同的注册程序。第一种是直接注册方法，它只有两个步骤：
- en: The mobile node sends a Registration Request to the home agent.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动节点向本地代理发送注册请求。
- en: The home agent sends a Registration Reply back to the mobile node.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地代理将注册回复发送回移动节点。
- en: 'In some cases, however, a slightly more complex process is required, whereby
    the foreign agent conveys messages between the home agent and the mobile node.
    In this situation, the process has four steps:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，需要稍微复杂一些的过程，其中外国代理在本地代理和移动节点之间传递消息。在这种情况下，该过程有四个步骤：
- en: The mobile node sends a Registration Request to the foreign agent.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动节点向外国代理发送注册请求。
- en: The foreign agent processes a Registration Request and forwards it to the home
    agent.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外国代理处理注册请求并将其转发给本地代理。
- en: The home agent sends a Registration Reply to a foreign agent.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地代理向外国代理发送注册回复。
- en: The foreign agent processes a Registration Reply and sends back to the mobile
    node.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外国代理处理注册回复并将其发送回移动节点。
- en: The first, simpler method is normally used when a mobile node is using a co-located
    care-of address. In that situation, the node can easily communicate directly with
    the home agent, and the mobile node is also set up to directly receive information
    and datagrams from the home agent. When there is no foreign agent, this is obviously
    the only method available. It is also obviously the only method when a mobile
    node is deregistering with its home agent after it arrives back on the home network.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个移动节点使用本地地址时，通常使用第一种、更简单的方法。在这种情况下，节点可以轻松地直接与本地代理通信，并且移动节点也被设置为直接接收来自本地代理的信息和数据报。当没有外国代理时，这显然是唯一可用的方法。当移动节点返回本地网络后注销其本地代理时，这也是显然的唯一方法。
- en: The second method is required when a mobile node is using a foreign care-of
    address. You'll recall that in this situation, the mobile node doesn't have its
    own unique IP address at all; it is using a shared address that was given to it
    by the foreign agent, which precludes direct communication between the node and
    the home agent. Also, if a mobile node receives an Agent Advertisement with the
    R flag set, it also should go through the foreign agent, even if it has a co-located
    care-of address.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动节点使用外国代理的care-of地址时，需要第二种方法。你会记得在这种情况下，移动节点根本没有任何唯一的IP地址；它正在使用外国代理给它的共享地址，这阻止了节点与本地代理之间的直接通信。此外，如果移动节点收到设置了R标志的代理广告，即使它有一个协同定位的care-of地址，它也应该通过外国代理进行。
- en: Note that the foreign agent really is just a middleman; the exchange is still
    really between the home agent and the mobile node. However, the foreign agent
    can deny registration if the request violates whatever rules are in place for
    using the foreign network. It is for this reason that some foreign agents may
    require that they be the conduits for registrations even if the mobile node has
    a co-located care-of address. Of course, if the foreign agent can't contact the
    home agent the registration will not be able to proceed.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，外国代理实际上只是一个中间人；交换仍然是在本地代理和移动节点之间进行的。然而，如果请求违反了外国网络使用的规则，外国代理可以拒绝注册。这就是为什么一些外国代理可能要求即使移动节点有一个协同定位的care-of地址，它们也必须是注册的渠道。当然，如果外国代理无法联系到本地代理，注册将无法进行。
- en: Tip
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Mobile IP *home agent registration* is the process by which
    a *mobility binding* is created between a home agent and a traveling mobile node
    to enable datagram forwarding to be performed. The mobile node that sends a Registration
    Request message performs registration, and the home agent returns a Registration
    Reply. The foreign agent may be required to act as a middleman in order to facilitate
    the transaction, but is otherwise not involved.'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 移动IP的*本地代理注册*是指创建一个在本地代理和移动节点之间的*移动绑定*的过程，以便执行数据报文的转发。发送注册请求消息的移动节点执行注册，本地代理返回注册回复。外国代理可能需要充当中间人以便促进交易，但除此之外并不参与。'
- en: The previous description is really a highly simplified explanation of the basics
    of registration. The Mobile IP standard specifies many more details on exactly
    how agents and nodes perform registration, including particulars on when requests
    and replies are sent, how to handle various special conditions such as invalid
    requests, rules for how home agents maintain a table of mobility bindings, and
    much more. The standard covers the definition of extensions to the regular registration
    messages that support authentication, which is required for secure communications
    (see the section on security issues later in this chapter for more details). It
    also includes the ability to have a mobile node that maintains more than one concurrent
    binding, when needed.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的描述实际上是对注册基本原理的高度简化解释。移动IP标准详细说明了代理和节点如何执行注册的许多细节，包括请求和回复发送的具体时间、如何处理各种特殊条件（如无效请求）、本地代理维护移动绑定表的规则以及更多内容。该标准涵盖了支持认证的常规注册消息的扩展定义，认证对于安全通信是必需的（有关安全问题的更多详细信息，请参阅本章后面的相关部分）。它还包括在需要时，移动节点可以维护多个并发绑定的能力。
- en: Registration Request Message Format
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册请求消息格式
- en: Registration Request messages have the format shown in Tables [Table 30-4](ch30s05.html#mobile_ip_registration_request_message_f
    "Table 30-4. Mobile IP Registration Request Message Format") and [Table 30-5](ch30s05.html#registration_request_flags
    "Table 30-5. Registration Request Flags") and illustrated in [Figure 30-6](ch30s05.html#mobile_ip_registration_request_mes-id001
    "Figure 30-6. Mobile IP Registration Request message format This message is carried
    in the payload of a User Datagram Protocol (UDP) message, the headers of which
    are not shown."). See the section on Mobile IP encapsulation later in this chapter
    for details on minimal and GRE encapsulation and reverse tunneling.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '注册请求消息的格式如表格[表30-4](ch30s05.html#mobile_ip_registration_request_message_f "表30-4.
    移动IP注册请求消息格式")和[表30-5](ch30s05.html#registration_request_flags "表30-5. 注册请求标志")所示，并在[图30-6](ch30s05.html#mobile_ip_registration_request_mes-id001
    "图30-6. 移动IP注册请求消息格式 此消息承载在用户数据报协议(UDP)消息的有效负载中，其头部未显示")中说明。关于移动IP封装的详细信息，请参阅本章后面的相关部分。 '
- en: Table 30-4. Mobile IP Registration Request Message Format
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-4. 移动IP注册请求消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the registration message type. For a request, this
    field is 1. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| Type | 1 | 识别注册消息类型。对于请求，此字段为1。 |'
- en: '| Flags | 1 | A one-byte field containing several informational flags that
    convey specific requests that are being made by the mobile node to the home agent.
    When set, the flags conveys the meanings shown in [Table 30-5](ch30s05.html#registration_request_flags
    "Table 30-5. Registration Request Flags"). |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| Flags | 1 | 包含多个信息标志的一个字节字段，这些标志传达了移动节点向家庭代理提出的特定请求。当设置时，标志传达的含义如[表30-5](ch30s05.html#registration_request_flags
    "表30-5. 注册请求标志")所示。 |'
- en: '| Lifetime | 2 | Length of time, in seconds, that the mobile node requests
    from the home agent for this registration. |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| Lifetime | 2 | 移动节点从家庭代理请求此注册的时间长度，单位为秒。 |'
- en: '| Home Address | 4 | The home (normal) IP address of the mobile node when on
    its home network. Uniquely identifies the device regardless of how the request
    is conveyed to the home agent. |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| Home Address | 4 | 移动节点在其本地网络上的家庭（正常）IP地址。无论请求如何传达给家庭代理，都能唯一标识设备。 |'
- en: '| Home Agent | 4 | The IP address of the device acting as the mobile node''s
    home agent. |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| Home Agent | 4 | 作为移动节点家庭代理的设备IP地址。 |'
- en: '| Care-Of Address | 4 | The IP address being used by the mobile node as its
    care-of address. |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| Care-Of Address | 4 | 移动节点正在使用的作为其协同地址的IP地址。 |'
- en: '| Identification | 8 | A 64-bit number that uniquely identifies the *Registration
    Request* and is used to match requests to replies. It also provides protection
    against replay attacks; see the section on Mobile IP security issues later in
    this chapter for more information. |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| Identification | 8 | 一个64位数字，唯一标识*注册请求*，并用于将请求与回复匹配。它还提供了防止重放攻击的保护；有关更多信息，请参阅本章后面的移动IP安全问题部分。
    |'
- en: '| Extensions | Variable | Extension fields are included here for authentication
    of the request. Other extensions may also be included. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| Extensions | 可变 | 包括扩展字段以对请求进行身份验证。还可以包括其他扩展。 |'
- en: Table 30-5. Registration Request Flags
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-5. 注册请求标志
- en: '| Subfield Name | Size (Bytes) | Description |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| 子字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| S | 1/8 (1 bit) | Simultaneous Bindings: Mobile node requests that prior
    mobility bindings be retained in addition to the one in the current request. |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| S | 1/8 (1 bit) | 同时绑定：移动节点请求保留先前的移动绑定，除了当前请求中的一个。 |'
- en: '| B | 1/8 (1 bit) | Broadcast Datagrams: Mobile node requests that broadcasts
    on the home network be forwarded to it. |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| B | 1/8 (1 bit) | 广播数据报：移动节点请求将家庭网络上的广播转发给它。 |'
- en: '| D | 1/8 (1 bit) | Decapsulation by Mobile Node: Mobile node is telling the
    home agent that it will itself decapsulate encapsulated datagrams, as opposed
    to a foreign agent. In other words, when this is one, the mobile node is using
    a co-located care-of address; when zero, it is using a foreign agent care-of address.
    |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| D | 1/8 (1 bit) | 移动节点解封装：移动节点告诉家庭代理它将自行解封装封装的数据报，而不是使用外地代理。换句话说，当此字段为1时，移动节点正在使用本地协同地址；当为0时，它正在使用外地代理的协同地址。
    |'
- en: '| M | 1/8 (1 bit) | Minimal Encapsulation: Mobile node requests that home agent
    use minimal encapsulation for forwarded datagrams. |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| M | 1/8 (1 bit) | 最小封装：移动节点请求家庭代理使用最小封装转发数据报。 |'
- en: '| G | 1/8 (1 bit) | GRE Encapsulation: Mobile node requests that home agent
    use GRE encapsulation for forwarded datagrams. |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '| G | 1/8 (1 bit) | GRE封装：移动节点请求家庭代理使用GRE封装转发数据报。 |'
- en: '| r | 1/8 (1bit) | Reserved: Not used; sent as zero. |'
  id: totrans-624
  prefs: []
  type: TYPE_TB
  zh: '| r | 1/8 (1 bit) | 保留：未使用；发送为零。 |'
- en: '| T | 1/8 (1 bit) | Reverse Tunneling: Mobile node requests that reverse tunneling
    be used by the home agent. |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| T | 1/8 (1 bit) | 反向隧道：移动节点请求家庭代理使用反向隧道。 |'
- en: '| x | 1/8 (1 bit) | Reserved: Not used; sent as zero. |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| x | 1/8 (1 bit) | 保留：未使用；发送为零。 |'
- en: '![Mobile IP Registration Request message format This message is carried in
    the payload of a User Datagram Protocol (UDP) message, the headers of which are
    not shown.](httpatomoreillycomsourcenostarchimages287949.png.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP注册请求消息格式 此消息承载在用户数据报协议（UDP）消息的有效负载中，其头部未显示。](httpatomoreillycomsourcenostarchimages287949.png.jpg)'
- en: Figure 30-6. Mobile IP Registration Request message format This message is carried
    in the payload of a User Datagram Protocol (UDP) message, the headers of which
    are not shown.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-6. 移动IP注册请求消息格式 此消息包含在用户数据报协议（UDP）消息的有效负载中，其头部未显示。
- en: Registration Reply Message Format
  id: totrans-629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册回复消息格式
- en: Registration Reply messages are formatted as shown in [Table 30-6](ch30s05.html#mobile_ip_registration_reply_message_for
    "Table 30-6. Mobile IP Registration Reply Message Format") and illustrated in
    [Figure 30-7](ch30s05.html#mobile_ip_registration_reply_messa-id001 "Figure 30-7. Mobile
    IP Registration Reply Message format This message is carried in the payload of
    a UDP message, the headers of which are not shown.").
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 注册回复消息的格式如[表30-6](ch30s05.html#mobile_ip_registration_reply_message_for "表30-6.
    移动IP注册回复消息格式")所示，并在[图30-7](ch30s05.html#mobile_ip_registration_reply_messa-id001
    "图30-7. 移动IP注册回复消息格式 此消息包含在UDP消息的有效负载中，其头部未显示")中说明。
- en: Table 30-6. Mobile IP Registration Reply Message Format
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 表30-6. 移动IP注册回复消息格式
- en: '| Field Name | Size (Bytes) | Description |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 大小（字节） | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Type | 1 | Identifies the registration message type. For a reply, this field
    is 3. |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 1 | 识别注册消息类型。对于回复，此字段为3。 |'
- en: '| Code | 1 | Indicates the result of the registration request. This field is
    set to 0 if the registration was accepted, 1 if it was accepted but simultaneous
    bindings were requested and are not supported. If the registration was denied,
    a different reason code is provided that indicates the reason for the rejection,
    as well as whether it was the home agent or foreign agent that denied it. |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 1 | 表示注册请求的结果。如果注册被接受，则此字段设置为0；如果注册被接受但请求了同时绑定且不支持，则设置为1。如果注册被拒绝，将提供不同的原因代码，以指示拒绝的原因，以及是家庭代理还是外国代理拒绝的。
    |'
- en: '| Lifetime | 2 | If the registration was accepted, this represents the length
    of time in seconds until the registration expires. This may be a different value
    than the mobile node requested. |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| 寿命 | 2 | 如果注册被接受，这表示注册到期前的秒数。这可能与移动节点请求的值不同。 |'
- en: '| Home Address | 4 | The home (normal) IP address of the mobile node when it''s
    on its home network. Uniquely identifies the device regardless of how the request
    is conveyed to the home agent so that the message can be delivered to it if the
    same foreign agent serves multiple mobile nodes. |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 家庭地址 | 4 | 当移动节点处于其家庭网络时，该移动节点的家庭（正常）IP地址。无论请求如何传达给家庭代理，都能唯一标识设备，以便在同一个外国代理为多个移动节点提供服务时，可以将消息发送到它。
    |'
- en: '| Home Agent | 4 | The IP address of the device acting as the mobile node''s
    home agent. |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| 家庭代理 | 4 | 作为移动节点家庭代理的设备的IP地址。 |'
- en: '| Identification | 8 | A 64-bit number that uniquely identifies the *Registration
    Reply* and is matched to the Identification field of the request that precipitated
    it. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| 识别 | 8 | 一个64位数字，唯一标识*注册回复*，并与触发它的请求的识别字段相匹配。 |'
- en: '| Extensions | Variable | Extension fields are included here for the authentication
    of the reply. Other extensions may also be included. |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| 扩展 | 可变 | 包含在此处的扩展字段用于回复的认证。也可能包含其他扩展。 |'
- en: '![Mobile IP Registration Reply Message format This message is carried in the
    payload of a UDP message, the headers of which are not shown.](httpatomoreillycomsourcenostarchimages287951.png)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP注册回复消息格式 此消息包含在UDP消息的有效负载中，其头部未显示](httpatomoreillycomsourcenostarchimages287951.png)'
- en: Figure 30-7. Mobile IP Registration Reply Message format This message is carried
    in the payload of a UDP message, the headers of which are not shown.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-7. 移动IP注册回复消息格式 此消息包含在UDP消息的有效负载中，其头部未显示。
- en: Mobile IP Data Encapsulation and Tunneling
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP数据封装和隧道
- en: Once a mobile node on a foreign network has completed a successful registration
    with its home agent, the Mobile IP datagram forwarding process described earlier
    in this chapter will be fully "activated." The home agent will intercept datagrams
    intended for the mobile node as they are routed to its home network, and forward
    them to the mobile node. Encapsulating the datagrams, and then sending them to
    the node's care-of address, does this.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦外国网络上的移动节点与其家庭代理完成成功的注册，本章前面描述的移动IP数据报转发过程将被完全“激活”。家庭代理将拦截路由到其家庭网络的移动节点意图的数据报，并将它们转发到移动节点。通过封装数据报，然后发送到节点的care-of地址来实现这一点。
- en: Encapsulation is required because each datagram that you intercept and forward
    needs to be resent over the network to the device's care-of address. In theory,
    the designers might conceivably have done this by just having the home agent change
    the destination address and stick it back out on the network, but there are various
    complications that make this unwise. It makes more sense to take the entire datagram
    and wrap it in a new set of headers before retransmitting. In my mail-forwarding
    analogy, this is comparable to taking a letter received for the traveling consultant
    and putting it into a fresh envelope for forwarding, as opposed to just crossing
    off the original address and putting a new one on.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是必需的，因为您拦截并转发的每个数据报文都需要通过网络重新发送到设备的care-of地址。理论上，设计者可能通过仅仅让归属代理更改目标地址并将其重新发送到网络上来实现这一点，但存在各种复杂因素使得这种方法不切实际。在重新传输之前将整个数据报文包裹在一组新的头中更为合理。在我的邮件转发类比中，这相当于将收到的旅行顾问的信件放入一个新的信封中以便转发，而不是仅仅划掉原始地址并写上新地址。
- en: The default encapsulation process used in Mobile IP is called *IP Encapsulation
    within IP*, which is as it's defined in RFC 2003\. It's commonly abbreviated *IP-in-IP*.
    It is a relatively simple method that describes how to take an IP datagram and
    make it the payload of another IP datagram. In Mobile IP, the new headers specify
    how to send the encapsulated datagram to the mobile node's care-of address.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动IP中使用的默认封装过程称为*IP内部封装*，正如它在RFC 2003中定义的那样。它通常简称为*IP-in-IP*。这是一个相对简单的方法，描述了如何将IP数据报文作为另一个IP数据报文的负载。在移动IP中，新的头指定如何将封装数据报文发送到移动节点的care-of地址。
- en: 'In addition to IP-in-IP, the following two encapsulation methods may be optionally
    used: *Minimal Encapsulation within IP*, which is defined in RFC 2004, and *Generic
    Routing Encapsulation (GRE)*, which is defined in RFC 1701\. To use either of
    these, the mobile node must request the appropriate method in its Registration
    Request, and the home agent must agree to use it. If foreign agent care-of addressing
    is used, the foreign agent also must support the method desired.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 除了IP-in-IP之外，还可以选择使用以下两种封装方法：*IP内部最小封装*，它在RFC 2004中定义，以及*通用路由封装（GRE）*，它在RFC
    1701中定义。要使用这些方法之一，移动节点必须在它的注册请求中请求适当的方法，并且归属代理必须同意使用它。如果使用外地代理care-of地址，外地代理也必须支持所需的方法。
- en: Mobile IP Conventional Tunneling
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动IP传统隧道
- en: The encapsulation process creates a logical construct called a *tunnel* between
    the device that encapsulates and the one that decapsulates. This is the same idea
    of a tunnel used in discussions of virtual private networks (VPNs), IPsec tunnel
    mode, or the various other tunneling protocols used for security. The tunnel represents
    a conduit over which datagrams are forwarded across an arbitrary internetwork,
    with the details of the encapsulated datagram (meaning the original IP headers)
    temporarily hidden.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 封装过程在封装设备和解封装设备之间创建了一个名为*tunnel*的逻辑结构。这与在虚拟专用网络（VPNs）、IPsec隧道模式或用于安全性的各种其他隧道协议讨论中使用的隧道概念相同。隧道代表了一个数据报文可以在任意互联网上转发的中继，封装数据报文的细节（即原始IP头）暂时被隐藏。
- en: 'In Mobile IP, the start of the tunnel is the home agent, which does the encapsulation.
    The end of the tunnel depends on which of the two types of care-of address is
    being used:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动IP中，隧道的起始点是归属代理，它负责封装。隧道的终点取决于使用的是两种类型的care-of地址中的哪一种：
- en: '**Foreign Agent Care-Of Address** The foreign agent is the end of the tunnel.
    It receives encapsulated messages from the home agent, strips off the outer IP
    header, and then delivers the datagram to the mobile node. This is generally done
    using layer 2, because the mobile node and foreign agent are on the same local
    network, and the mobile node does not have its own IP address on that network,
    because it is using the foreign agent''s address.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**外地代理care-of地址** 外地代理是隧道的终点。它从归属代理接收封装的消息，移除外部IP头，然后将数据报文递送到移动节点。这通常使用第二层来完成，因为移动节点和外地代理位于同一本地网络中，并且移动节点在该网络上没有自己的IP地址，因为它正在使用外地代理的地址。'
- en: '**Co-Located Care-Of Address** The mobile node itself is the end of the tunnel
    and strips off the outer header.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地化care-of地址** 移动节点本身是隧道的终点，并移除外部头。'
- en: 'Normally, the tunnel described previously is used only for datagrams that have
    been sent to the mobile node and captured by the home agent. When the mobile node
    wants to send a datagram, it doesn''t tunnel it back to the home agent; this would
    be needlessly inefficient. Instead, it just sends out the datagram directly using
    whatever router it can find on its current network, which may or may not be a
    foreign agent. When it does this, it uses its own home address as the source address
    for any requests it sends. As a result, any response to those requests will go
    back to the home network. This sets up a triangle of three transmissions for these
    kinds of transactions (illustrated in [Figure 30-8](ch30s06.html#mobile_ip_encapsulation_and_tunneling_th
    "Figure 30-8. Mobile IP encapsulation and tunneling This example illustrates how
    a typical request/reply message exchange in Mobile IP results in a triangle of
    communication. In step 1, the mobile node sends a request to a remote server somewhere
    on the Internet. It uses its own home address as the source for this request,
    so in step 2, the reply goes back to the home agent. Step 3 consists of the home
    agent tunneling the reply back to the mobile node.")):'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，之前描述的隧道仅用于已发送到移动节点并被本地代理捕获的数据报。当移动节点想要发送数据报时，它不会将其隧道化回本地代理；这将是不必要的低效。相反，它只需直接使用当前网络中可以找到的任何路由器发送数据报，这可能或可能不是外部代理。当它这样做时，它使用自己的本地地址作为发送请求的源地址。因此，对这些请求的任何响应都将返回到本地网络。这为这些类型的交易设置了一个由三个传输组成的三角形（如图[图30-8](ch30s06.html#mobile_ip_encapsulation_and_tunneling_th
    "图30-8. 移动IP封装和隧道化 此示例说明了在移动IP中典型的请求/回复消息交换如何导致通信的三角形。在第1步中，移动节点向互联网上的某个远程服务器发送请求。它使用自己的本地地址作为请求的源地址，因此在第2步中，回复返回到本地代理。第3步包括本地代理将回复隧道化回移动节点。")所示）：
- en: The mobile node sends a request from the foreign network to some third-party
    device somewhere on the internetwork.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动节点从外部网络向互联网上某个第三方设备发送请求。
- en: The third-party device responds back to the mobile node. However, this sends
    the reply back to the model node's home address on its home network.
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三方设备向移动节点回复。然而，这会将回复发送回移动节点在其本地网络上的本地地址。
- en: The home agent intercepts the response on the home network and tunnels it back
    to the mobile node.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地代理在本地网络中拦截响应并将其隧道化回移动节点。
- en: '![Mobile IP encapsulation and tunneling This example illustrates how a typical
    request/reply message exchange in Mobile IP results in a triangle of communication.
    In step 1, the mobile node sends a request to a remote server somewhere on the
    Internet. It uses its own home address as the source for this request, so in step
    2, the reply goes back to the home agent. Step 3 consists of the home agent tunneling
    the reply back to the mobile node.](httpatomoreillycomsourcenostarchimages287953.png.jpg)'
  id: totrans-657
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP封装和隧道化 此示例说明了在移动IP中典型的请求/回复消息交换如何导致通信的三角形。在第1步中，移动节点向互联网上的某个远程服务器发送请求。它使用自己的本地地址作为请求的源地址，因此在第2步中，回复返回到本地代理。第3步包括本地代理将回复隧道化回移动节点。](httpatomoreillycomsourcenostarchimages287953.png.jpg)'
- en: Figure 30-8. Mobile IP encapsulation and tunneling This example illustrates
    how a typical request/reply message exchange in Mobile IP results in a triangle
    of communication. In step 1, the mobile node sends a request to a remote server
    somewhere on the Internet. It uses its own home address as the source for this
    request, so in step 2, the reply goes back to the home agent. Step 3 consists
    of the home agent tunneling the reply back to the mobile node.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-8. 移动IP封装和隧道化 此示例说明了在移动IP中典型的请求/回复消息交换如何导致通信的三角形。在第1步中，移动节点向互联网上的某个远程服务器发送请求。它使用自己的本地地址作为请求的源地址，因此在第2步中，回复返回到本地代理。第3步包括本地代理将回复隧道化回移动节点。
- en: The reverse transaction would be pretty much the same, except in the reverse
    order. In that case, the third-party (Internet) device would send a request to
    mobile node, which would be received and forwarded by the home agent. The mobile
    node would reply back directly to the Internet host.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 反向交易基本上是相同的，只是顺序相反。在这种情况下，第三方（互联网）设备会向移动节点发送请求，该请求会被本地代理接收并转发。移动节点会直接向互联网主机回复。
- en: Tip
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**KEY CONCEPT** Once Mobile IP is set up and operational, it works by having
    the home agent *encapsulate* and *tunnel* received datagrams to the mobile node.
    The mobile device normally sends datagrams directly to Internet hosts, which respond
    back to the mobile''s home agent, which forwards those datagrams to the mobile
    node. This means a request/reply communication takes three transmissions.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 一旦移动IP设置并运行，它通过本地代理*封装*和*隧道*接收到的数据报到移动节点来工作。移动设备通常直接将数据报发送到互联网主机，这些主机响应移动的本地代理，该代理将数据报转发到移动节点。这意味着请求/回复通信需要三次传输。'
- en: Mobile IP Reverse Tunneling
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动IP反向隧道
- en: There may be situations where it is not feasible or desired to have the mobile
    node send datagrams directly to the internetwork using a router on the foreign
    network, as you just saw. In this case, an optional feature called *reverse tunneling*
    may be deployed if it is supported by the mobile node, the home agent, and, if
    relevant, the foreign agent. When this is done, a reverse tunnel that complements
    the normal one is set up between the mobile node and the home agent, or between
    the foreign agent and the home agent, depending on the care-of address type. All
    transmissions from the mobile node are tunneled back to the home network where
    the home agent transmits them over the internetwork, thereby resulting in a more
    symmetric operation as opposed to the triangle just described. This is basically
    what I described earlier as being needlessly inefficient, because it means each
    communication requires four steps. Thus, it is used only when necessary.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在某些情况下，使用外国网络上的路由器直接将数据报发送到互联网是不可行或不受欢迎的，正如你刚才看到的。在这种情况下，如果移动节点、本地代理（如果相关的话，还有外国代理）支持，可以部署一个可选功能，称为*反向隧道*。当这样做时，根据care-of地址类型，在移动节点和本地代理之间，或者在外国代理和本地代理之间设置一个补充正常隧道的反向隧道。所有来自移动节点的传输都会通过隧道返回到本地网络，本地代理在那里通过互联网传输它们，从而实现比刚才描述的三角形更对称的操作。这基本上就是我之前描述的效率低下的原因，因为它意味着每次通信需要四个步骤。因此，它仅在必要时使用。
- en: One situation for which reverse tunneling may be required is if the network
    where the mobile node is located has implemented certain security measures that
    prohibit the node from sending datagrams using its normal IP address. In particular,
    a network may be set up to disallow outgoing datagrams with a source address that
    doesn't match its network prefix. This is often done to prevent *spoofing* (impersonating
    another's IP address).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 需要反向隧道的一种情况是，如果移动节点所在的网络实施了某些安全措施，禁止节点使用其正常的IP地址发送数据报。特别是，网络可能被设置为不允许带有与其网络前缀不匹配的源地址的出站数据报。这通常是为了防止*欺骗*（冒充他人的IP地址）。
- en: Tip
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** An optional feature called *reverse tunneling* may be used
    in certain cases, such as when a network does not allow outgoing datagrams with
    a foreign source IP address. When enabled, rather than sending datagrams directly,
    the mobile node tunnels all transmissions back to the home agent, which sends
    them on the Internet.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在某些情况下，可以使用一个称为*反向隧道*的可选功能，例如当网络不允许带有外国源IP地址的出站数据报时。启用后，而不是直接发送数据报，移动节点将所有传输通过隧道返回到本地代理，该代理将它们发送到互联网。'
- en: Note that everything I've just discussed is applicable to normal—meaning unicast—datagrams
    that are sent to and from the mobile node. Broadcast datagrams on the home network,
    which would normally be intended for the mobile node if it were at home, are not
    forwarded unless the node specifically asks for this service during registration.
    Multicast operation on the foreign network is also supported, but extra work is
    required by the mobile node to set it up.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我刚才讨论的一切都适用于正常——即单播——数据报，这些数据报是发送到和从移动节点发送的。在本地网络上的广播数据报，如果移动节点在本地，通常会被发送到移动节点，除非节点在注册期间明确请求此服务，否则不会转发。在外国网络上的多播操作也得到支持，但移动节点需要做额外的工作来设置它。
- en: Mobile IP and TCP/IP Address Resolution Protocol (ARP) Operation
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP和TCP/IP地址解析协议（ARP）操作
- en: 'Mobile IP is a protocol that does a good job of implementing a difficult function:
    It transparently allows an IP device to travel to a different network. Unfortunately,
    a problem with any protocol that tries to change how IP works is dealing with
    special cases. Having a home agent intercept datagrams and tunnel them to the
    mobile node works well in general terms, but there are some instances in which
    extra work is required. One of these is the use of ARP, which breaks under Mobile
    IP unless we take special steps.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 移动IP是一种协议，它很好地实现了困难的函数：它透明地允许IP设备移动到不同的网络。不幸的是，任何试图改变IP工作方式的协议都会遇到特殊情况的难题。家庭代理拦截数据报并将其隧道传输到移动节点在一般意义上是有效的，但有些情况下需要额外的工作。其中之一是使用ARP，除非我们采取特殊措施，否则它会在移动IP下失效。
- en: Tip
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**BACKGROUND INFORMATION** *Some understanding of how ARP works in general
    terms is assumed in this topic. This includes ARP proxying, which is described
    in [Chapter 13](ch13.html "Chapter 13. ADDRESS RESOLUTION AND THE TCP/IP ADDRESS
    RESOLUTION PROTOCOL (ARP)")*.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景信息** 在本主题中假定对ARP在一般意义上的工作原理有所了解。这包括ARP代理，这在[第13章](ch13.html "第13章。地址解析与TCP/IP地址解析协议（ARP）")中有描述。'
- en: To understand what the problem is with ARP, consider a mobile node that is on
    a foreign network and has successfully registered with its home agent. The home
    agent will intercept all datagrams that come onto the home network, particularly
    the ones intended for the mobile node, and then encapsulate and forward them.
    For this to happen, though, the home agent (home router) must see the datagram.
    This normally occurs only when a datagram comes onto the home network from the
    outside and is processed by the router.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解ARP的问题是什么，考虑一个位于外国网络并已成功注册到其家庭代理的移动节点。家庭代理将拦截进入家庭网络的所有数据报，特别是那些旨在发送给移动节点的数据报，然后封装并转发它们。然而，为了实现这一点，家庭代理（家庭路由器）必须看到数据报。这通常只在数据报从外部进入家庭网络并由路由器处理时才会发生。
- en: What happens when a local device on the home network itself wants to transmit
    to a mobile node that has traveled elsewhere? Remember that this device may not
    be mobile itself and probably knows nothing about Mobile IP. It will follow the
    standard process for deciding what to do with a datagram that it needs to send,
    as explained in [Chapter 23](ch23.html "Chapter 23. IP ROUTING AND MULTICASTING").
    It will compare its network ID to that of the mobile node and realize that it
    doesn't need to route its datagram; it can send it directly to the mobile node.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 当家庭网络上的本地设备本身想要向已经旅行到其他地方的移动节点传输数据时会发生什么？记住，这个设备本身可能不是移动的，并且可能对移动IP一无所知。它将遵循标准流程来决定如何处理它需要发送的数据报，正如[第23章](ch23.html
    "第23章。IP路由和多播")中解释的那样。它将比较其网络ID与移动节点的网络ID，并意识到它不需要路由其数据报；它可以直接将其发送到移动节点。
- en: The local host will attempt to use ARP to find the data link layer address of
    the mobile node so that it can send the datagram to it directly. The host will
    start by looking in its ARP cache, and if it finds the node's data link layer
    address there, it will use it to send at layer 2\. The mobile node is no longer
    on the local network segment, so the message will never be received. If there
    is no ARP cache entry, the host on the home network will attempt to send an ARP
    Request to the mobile node to determine its layer 2 address. Again, the mobile
    node has traveled away, so this request will go unanswered.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 本地主机将尝试使用ARP来查找移动节点的数据链路层地址，以便它能直接向其发送数据报。主机将首先检查其ARP缓存，如果在那里找到节点的数据链路层地址，它将使用它来在第二层发送。移动节点不再位于本地网络段上，因此消息将不会被接收。如果没有ARP缓存条目，家庭网络上的主机将尝试向移动节点发送ARP请求以确定其第二层地址。同样，移动节点已经离开，所以这个请求将无人响应。
- en: 'Solving this problem requires the intervention of, you guessed it, the home
    agent. It must perform two tasks to enable local hosts to send to the mobile node:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题需要，正如你所猜到的，家庭代理的介入。它必须执行两个任务才能使本地主机能够向移动节点发送数据：
- en: '**ARP Proxying** The home agent must listen for any ARP Requests that are sent
    by nodes on the same network as any of the mobile nodes that are currently registered
    to it. When it hears one, it replies in the mobile node''s stead, and specifies
    its own data link layer address as the binding for the mobile node''s IP address.
    This will cause hosts on the home network to send any datagrams that are intended
    for the mobile node to the home agent where they can be forwarded. This process
    is illustrated in [Figure 30-9](ch30s07.html#arp_proxying_by_mobile_ip_home_agent_the
    "Figure 30-9. ARP proxying by Mobile IP home agent The home agent must take special
    steps to deal with transmissions from devices on the local network to the mobile
    node. In this example (using short hardware addresses for simplicity), the hardware
    address of the mobile node is 48 and the home agent is 63\. A local client on
    the home network with hardware address 97 sends an ARP Request to find out the
    hardware address of the mobile node. The home agent responds on the mobile''s
    behalf, specifying not hardware address 48 but rather its own address: 63\. The
    client will thus send to the home agent, which can then forward the data to the
    mobile node on the foreign network.").'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '**ARP代理** 家庭代理必须监听任何由当前注册到它的任何移动节点所在同一网络上的节点发送的ARP请求。当它听到一个请求时，它会代表移动节点进行回复，并指定自己的数据链路层地址作为移动节点IP地址的绑定。这将导致家庭网络上的主机将任何打算发送给移动节点的数据报发送到家庭代理，在那里它们可以被转发。这个过程在[图30-9](ch30s07.html#arp_proxying_by_mobile_ip_home_agent_the
    "图30-9. 移动IP家庭代理的ARP代理 家庭代理必须采取特殊措施来处理来自本地网络设备的传输。在这个例子中（为了简单起见，使用简短的硬件地址），移动节点的硬件地址是48，家庭代理是63。家庭网络上的一个本地客户端，其硬件地址为97，发送一个ARP请求以找出移动节点的硬件地址。家庭代理代表移动节点进行回复，指定不是硬件地址48，而是自己的地址：63。因此，客户端会发送到家庭代理，然后家庭代理可以将数据转发到外国网络上的移动节点。")中进行了说明。'
- en: '**Gratuitous ARP** Proxying helps with ARP Requests, but what about devices
    that already have cache entries for the mobile node? As soon as the mobile node
    leaves the network, these become automatically stale. To correct them, the home
    agent sends what is called a *gratuitous* ARP message, which tells devices on
    the local network to associate the mobile node''s IP address with the home agent''s
    data link layer address. The term *gratuitous* refers to the fact that the device
    isn''t sending the message in order to perform an actual address resolution, but
    merely to cause caches to be updated. It may be sent more than once to ensure
    that every device gets the message.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '**无用的ARP** 代理有助于处理ARP请求，但对于已经为移动节点缓存了条目的设备怎么办？一旦移动节点离开网络，这些条目就会自动过时。为了纠正它们，家庭代理发送所谓的“无用的”ARP消息，告诉本地网络上的设备将移动节点的IP地址与家庭代理的数据链路层地址关联起来。术语“无用的”指的是设备不是发送消息以执行实际的地址解析，而是仅仅为了更新缓存。它可能发送多次，以确保每个设备都能收到消息。'
- en: '![ARP proxying by Mobile IP home agent The home agent must take special steps
    to deal with transmissions from devices on the local network to the mobile node.
    In this example (using short hardware addresses for simplicity), the hardware
    address of the mobile node is 48 and the home agent is 63\. A local client on
    the home network with hardware address 97 sends an ARP Request to find out the
    hardware address of the mobile node. The home agent responds on the mobile''s
    behalf, specifying not hardware address 48 but rather its own address: 63\. The
    client will thus send to the home agent, which can then forward the data to the
    mobile node on the foreign network.](httpatomoreillycomsourcenostarchimages287955.png.jpg)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP家庭代理的ARP代理 家庭代理必须采取特殊措施来处理来自本地网络设备的传输。在这个例子中（为了简单起见，使用简短的硬件地址），移动节点的硬件地址是48，家庭代理是63。家庭网络上的一个本地客户端，其硬件地址为97，发送一个ARP请求以找出移动节点的硬件地址。家庭代理代表移动节点进行回复，指定不是硬件地址48，而是自己的地址：63。因此，客户端会发送到家庭代理，然后家庭代理可以将数据转发到外国网络上的移动节点。](httpatomoreillycomsourcenostarchimages287955.png.jpg)'
- en: 'Figure 30-9. ARP proxying by Mobile IP home agent The home agent must take
    special steps to deal with transmissions from devices on the local network to
    the mobile node. In this example (using short hardware addresses for simplicity),
    the hardware address of the mobile node is 48 and the home agent is 63\. A local
    client on the home network with hardware address 97 sends an ARP Request to find
    out the hardware address of the mobile node. The home agent responds on the mobile''s
    behalf, specifying not hardware address 48 but rather its own address: 63\. The
    client will thus send to the home agent, which can then forward the data to the
    mobile node on the foreign network.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 图 30-9. 移动 IP 本地代理的 ARP 代理。本地代理必须采取特殊步骤来处理来自本地网络设备的传输。在这个例子中（为了简单起见，使用简短的硬件地址），移动节点的硬件地址是
    48，本地代理是 63。本地网络上的一个客户端硬件地址为 97，发送一个 ARP 请求以找出移动节点的硬件地址。本地代理代表移动节点响应，指定不是硬件地址
    48，而是它自己的地址：63。因此，客户端将数据发送到本地代理，然后本地代理可以将数据转发到外国网络上的移动节点。
- en: Tip
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** In theory, problems can occur with hosts on the mobile node''s
    home network that are trying to send datagrams to the host at layer 2\. To address
    these issues, the home agent is required to use proxy ARP to direct such devices
    to send to the home agent so they can be forwarded. It must also use *gratuitous*
    ARP to update any existing ARP caches to that effect.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 在理论上，移动节点本地网络上的主机可能会遇到问题，它们试图在第二层向主机发送数据报。为了解决这些问题，需要本地代理使用代理 ARP
    来指导这些设备向本地代理发送，以便它们可以被转发。它还必须使用 *无用的* ARP 来更新任何现有的 ARP 缓存以实现这一点。'
- en: Once these steps are taken, ARP should function normally on the home link. When
    the mobile device returns back to the home network, the process must be reversed.
    Upon deregistration with the home agent, the mobile device will stop proxying
    for the mobile node. Both the mobile node and the home agent will also send gratuitous
    ARP broadcasts that update local device caches. These will again associate the
    mobile node's IP address with its own layer 2 address, instead of the layer 2
    address of the home agent.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些步骤，ARP 应该在本地链路上正常工作。当移动设备返回本地网络时，必须反转这个过程。在向本地代理注销后，移动设备将停止为移动节点代理。移动节点和本地代理还将发送无用的
    ARP 广播，以更新本地设备缓存。这将再次将移动节点的 IP 地址与其自己的第 2 层地址关联起来，而不是本地代理的第 2 层地址。
- en: Mobile IP Efficiency Issues
  id: totrans-683
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动 IP 效率问题
- en: Having the home agent forward all datagrams to the mobile node wherever it may
    be is a convenient solution to mobility, but it's also a rather inefficient one.
    Since the device must send every datagram first to the home network and then forward
    it to the mobile node, the datagrams are going to travel over some part of the
    internetwork twice. The degree of inefficiency represented by forwarding can be
    significant and may lead to problems with certain applications.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 让本地代理将所有数据报转发到移动节点，无论它在何处，这是一个方便的移动解决方案，但也是一个相当低效的解决方案。由于设备必须首先将每个数据报发送到本地网络，然后再转发到移动节点，因此数据报将不得不在互联网的某个部分上往返两次。转发所表示的不效率程度可能非常显著，并可能导致某些应用程序出现问题。
- en: To see what the problem is, let's consider a traveling mobile Node M and a regular
    device that wants to send to it, Device A. The degree of the inefficiency of Mobile
    IP is a function of the internetwork distance between Device A and Node M's home
    network, compared to the internetwork distance between Device A and Node M's current
    network. By *distance*, I mean the term as it is used in determining routes on
    an internetwork. Two devices are closer when it takes less time and fewer hops
    to communicate between them, and they are farther when more hops are required.
    (I use geography in the following examples to represent this notion of distance,
    but remember that geographical distance is only one factor in internetwork distance.)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解问题所在，让我们考虑一个移动的节点 M 和一个想要向其发送数据的常规设备，设备 A。移动 IP 的不效率程度是设备 A 与节点 M 的本地网络之间的互联网距离与设备
    A 与节点 M 的当前网络之间的互联网距离的函数。这里的“距离”是指用于确定互联网上路由的术语。当两个设备之间通信所需的时间和跳数更少时，它们更接近；当需要更多的跳数时，它们更远。（在以下示例中，我使用地理距离来表示这个概念，但请记住，地理距离只是互联网距离的一个因素。）
- en: 'Let''s consider the case in which mobile Node M is on a foreign network that''s
    quite far from home, and Device A wants to send a datagram using Node M''s home
    IP address. Suppose the home network is in London and the device is again in Tokyo.
    Let''s look at the inefficiency factor of Mobile IP, compared to the alternative
    of having the mobile node just get a new temporary IP address on the foreign network
    and not use Mobile IP. The following examples are arranged in order of increasing
    inefficiency:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑移动节点M在外国网络上，且距离家乡相当远的情况，设备A想使用节点M的本地IP地址发送数据报。假设本地网络在伦敦，设备再次在东京。让我们看看移动IP与移动节点在外国网络上仅获取新的临时IP地址而不使用移动IP的替代方案的效率比较。以下示例按效率递增的顺序排列：
- en: '**Sending Device on Home Network** In this situation, Device A will send a
    datagram that is immediately intercepted by the home agent on the home network
    and forwarded to the mobile node. There is really no inefficiency here at all
    (except for overhead for encapsulation and such), because even if Device A did
    send the datagram directly to the mobile node with a new foreign address, the
    datagram would probably be routed through the home agent router anyway.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本地网络上的发送设备** 在这种情况下，设备A将发送一个数据报，该数据报立即被本地网络上的本地代理截获并转发到移动节点。实际上这里根本不存在任何低效（除了封装等开销），因为即使设备A直接将数据报发送到移动节点并使用新的外国地址，数据报可能仍然会通过本地代理路由器。'
- en: '**Sending Device on Network Close to Home Network** Let''s say a device in
    Paris wants to send to the mobile node. The datagram goes from Paris to London
    and then to Tokyo. That''s not too bad.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '**接近本地网络的网络上的发送设备** 假设巴黎的设备想向移动节点发送数据。数据报从巴黎到伦敦，然后到东京。这还不是太糟糕。'
- en: '**Sending Device on Network Close to Foreign Network** Now suppose the sending
    device is in Taipei, Taiwan. In this situation, Mobile IP becomes quite inefficient.
    The datagram must be sent from Taipei all the way to London, and then all the
    way back to Tokyo.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**接近外国网络的网络上的发送设备** 现在假设发送设备位于台湾台北。在这种情况下，移动IP变得非常低效。数据报必须从台北发送到伦敦，然后再发送回东京。'
- en: '**Sending Device on Foreign Network** The greatest inefficiency occurs when
    the sending device is actually on the foreign network that the mobile node is
    visiting. If Device A is on the mobile node''s current network in Tokyo, it must
    send all the way to London, and then have the result forwarded all the way back
    again to Tokyo. Without Mobile IP, all you would need to do is use ARP and then
    deliver directly at layer 2 without needing routing at all! This scenario is illustrated
    in [Figure 30-10](ch30s08.html#a_mobile_ip_inefficiency_worst-case_scen "Figure 30-10. A
    Mobile IP inefficiency worst-case scenario This diagram shows the worst possible
    case of Mobile IP inefficiency. When a device on the foreign network where the
    mobile is located tries to send data to the mobile device. The sender here, 210.4.79.11,
    uses the mobile node''s home address so that the transmission must be routed all
    the way back to London, and then forwarded back to Tokyo, even though the two
    devices might be sitting on the same desk!").'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**在外国网络上的发送设备** 当发送设备实际上位于移动节点访问的外国网络时，效率最低。如果设备A位于东京的移动节点当前网络，它必须一直发送到伦敦，然后将结果再次转发回东京。如果没有移动IP，你只需要使用ARP，然后在第二层直接交付，而不需要任何路由！这种情况在[图30-10](ch30s08.html#a_mobile_ip_inefficiency_worst-case_scen
    "图30-10. 移动IP效率最差情况示意图 该图显示了移动IP效率最差的情况。当位于移动节点所在的外国网络上的设备试图向移动设备发送数据时。这里的发送者210.4.79.11使用了移动节点的本地地址，因此传输必须路由回伦敦，然后再转发回东京，尽管这两个设备可能就坐在同一张桌子上！")中进行了说明。'
- en: Unfortunately, the worst-case scenario of the sending device on a foreign network
    is one that occurs quite often. It's common for a mobile device to connect with
    a foreign network in order for it to communicate specifically with the hosts on
    that network.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，发送设备在外国网络上的最坏情况是经常发生的情况。移动设备通常连接到外国网络，以便与该网络上的主机进行特定通信。
- en: '![A Mobile IP inefficiency worst-case scenario This diagram shows the worst
    possible case of Mobile IP inefficiency. When a device on the foreign network
    where the mobile is located tries to send data to the mobile device. The sender
    here, 210.4.79.11, uses the mobile node''s home address so that the transmission
    must be routed all the way back to London, and then forwarded back to Tokyo, even
    though the two devices might be sitting on the same desk!](httpatomoreillycomsourcenostarchimages287957.png.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![移动IP效率最坏情况示意图 此图显示了移动IP效率最坏的情况。当位于移动设备所在外国网络上的设备试图向移动设备发送数据时。这里的发送者，210.4.79.11，使用移动节点的本地地址，因此传输必须一路路由回伦敦，然后再转发回东京，尽管这两个设备可能就坐在同一张桌子上！](http://atomoreilly.com/source/nostarch/images/287957.png.jpg)'
- en: Figure 30-10. A Mobile IP inefficiency worst-case scenario This diagram shows
    the worst possible case of Mobile IP inefficiency. When a device on the foreign
    network where the mobile is located tries to send data to the mobile device. The
    sender here, 210.4.79.11, uses the mobile node's home address so that the transmission
    must be routed all the way back to London, and then forwarded back to Tokyo, even
    though the two devices might be sitting on the same desk!
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 图30-10. 移动IP效率最坏情况示意图 此图显示了移动IP效率最坏的情况。当位于移动设备所在外国网络上的设备试图向移动设备发送数据时。这里的发送者，210.4.79.11，使用移动节点的本地地址，因此传输必须一路路由回伦敦，然后再转发回东京，尽管这两个设备可能就坐在同一张桌子上！
- en: To make matters worse, consider what happens if reverse tunneling is used! Here,
    tunneling is done not just for datagrams sent to the mobile node, but for datagrams
    sent from the device as well. In the worst-case example, a request/reply pair
    from the mobile node to another device on the foreign network requires *two* complete
    round-trips from Tokyo to London and back. Clearly, this is far from ideal.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，考虑一下如果使用反向隧道会发生什么！在这里，隧道不仅用于发送到移动节点的数据报，也用于从设备发送的数据报。在最坏的情况示例中，从移动节点到外国网络上另一设备的请求/回复对需要从东京到伦敦并返回的*两个*完整往返。显然，这远非理想。
- en: Tip
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**KEY CONCEPT** Since datagrams are sent to a Mobile IP at its home address,
    each datagram sent to the mobile device must first go back to its home network
    and then be forwarded to its current location. The level of inefficiency that
    results depends on how far the sender is from the mobile''s home network. The
    worst case actually occurs if the sender and mobile are on the same foreign network,
    in which case each transmission must make a round-trip to the mobile''s home network
    and then back again.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键概念** 由于数据报是发送到移动IP的本地地址，因此发送到移动设备的每个数据报必须首先返回其本地网络，然后转发到其当前位置。由此产生的效率低下程度取决于发送者与移动设备本地网络的距离。最坏的情况实际上发生在发送者和移动设备位于同一外国网络时，在这种情况下，每次传输都必须往返于移动设备的本地网络。'
- en: 'There really isn''t any solution to this problem within Mobile IP itself; it''s
    just a natural consequence of how the protocol works. The only way to really improve
    things is to "hack in" a solution that ultimately boils down to one of the two
    options we always have in IP without mobility support: Either give the mobile
    device a temporary real IP address on the foreign network, or use a host-specific
    route for the mobile device while it''s on the foreign network.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动IP内部实际上并没有解决这个问题；这只是协议工作方式的自然结果。真正改善事情的唯一方法是通过“黑客”方式引入一个解决方案，这个解决方案最终归结为我们在IP无移动支持时始终拥有的两种选择之一：要么在外国网络上给移动设备分配一个临时的真实IP地址，要么在移动设备位于外国网络时使用针对主机的特定路由。
- en: You've already seen that these both have problems, which is why Mobile IP was
    created in the first place. There may be situations, however, in which efficiency
    is more important than the transparent portability that Mobile IP provides. For
    a long-term deployment on a foreign network far from the home network, or for
    applications where efficiency is paramount, it may make sense to employ one of
    these techniques. For example, a corporation that has a small number of offices
    in different cities that are connected using the Internet might set up special
    routing. This would let mobile devices visiting from other cities talk directly
    to nodes that are local to the foreign part of the network without being routed
    across the Internet.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，这些方法都有问题，这也是移动IP最初被创建的原因。然而，可能存在效率比移动IP提供的透明可移植性更重要的情况。对于在远离本地网络的国外网络上长期部署，或者对于效率至关重要的应用，采用这些技术之一可能是合理的。例如，一个在多个城市有少量办公室且通过互联网连接的公司可能会设置特殊的路由。这将允许来自其他城市的移动设备直接与网络的外部部分的本地区域节点通信，而无需通过互联网进行路由。
- en: Mobile IP Security Considerations
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动IP安全注意事项
- en: Security is always a concern in any internetworking environment these days,
    but is especially important with Mobile IP. There are a number of reasons for
    this. The reasons are related to both how the protocol is used and the specific
    mechanisms by which it is implemented.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的任何互联网环境中，安全性始终是一个关注点，但在使用移动IP时尤其重要。这有几个原因。这些原因既与协议的使用方式有关，也与实现该协议的具体机制有关。
- en: In terms of use, security was kept in mind during Mobile IP's development because
    mobile devices often use wireless networking technologies. Wireless communication
    is inherently less secure than wired communication, because transmissions are
    sent out in the open, where they can be intercepted. It's also easier for malicious
    users to disrupt the operation of wireless devices.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方面，由于移动设备通常使用无线网络技术，因此在移动IP的开发过程中始终考虑到了安全性。无线通信本质上比有线通信不安全，因为传输是在公开环境中进行的，可以被截获。恶意用户也更容易干扰无线设备的操作。
- en: In terms of operation, Mobile IP has a number of risks due to the fact that
    it uses a registration system and then forwards datagrams across an unsecured
    internetwork. A malicious device could interfere with registration process, thereby
    causing the datagrams intended for a mobile device to be diverted. A bad guy might
    also interfere with the data forwarding process itself by encapsulating a bogus
    datagram to trick a mobile node into thinking it was sent something that it never
    was.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作方面，由于移动IP使用注册系统并在一个未加密的互联网上转发数据报，因此存在许多风险。恶意设备可能会干扰注册过程，从而使得原本打算发送给移动设备的数据报被重定向。一个恶意用户也可能通过封装一个虚假的数据报来干扰数据转发过程，诱使移动节点认为它收到了它从未收到的东西。
- en: 'For these reasons, the Mobile IP standard includes a limited number of explicit
    provisions to safeguard against various security risks. One security measure was
    considered sufficiently important that it was built into the Mobile IP standard
    directly: the authentication of Registration Request and Registration Reply messages.
    This authentication process is accomplished in a manner that''s somewhat similar
    to how the IPsec Authentication Header (AH) operates, as described in [Chapter 29](ch29.html
    "Chapter 29. IP SECURITY (IPSEC) PROTOCOLS"). Its goal is to prevent unauthorized
    devices from intercepting traffic by tricking an agent into setting up, renewing,
    or canceling a registration improperly.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，移动IP标准包括了一些明确的条款，以防范各种安全风险。有一项安全措施被认为非常重要，因此它被直接集成到移动IP标准中：注册请求和注册回复消息的认证。这个过程以一种与IPsec认证头（AH）操作类似的方式进行，如[第29章](ch29.html
    "第29章。IP安全（IPSEC）协议")所述。其目标是防止未经授权的设备通过诱使代理不正确地设置、续订或取消注册来拦截流量。
- en: All Mobile IP devices are required to support authentication. Nodes must use
    it for requests, and agents must use it for replies. Keys must be assigned manually
    because there is no automated system for secure key distribution. The default
    authentication method uses *HMAC-MD5* (specified in RFC 2403), which is one of
    two hashing algorithms used by IPsec.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 所有移动IP设备都必须支持身份验证。节点必须用它来请求，代理必须用它来回复。由于没有自动化的安全密钥分发系统，密钥必须手动分配。默认的身份验证方法使用*HMAC-MD5*（在RFC
    2403中指定），这是IPsec使用的两种哈希算法之一。
- en: Another concern is a security problem called a *replay attack*. In this type
    of attack, a third party intercepts a datagram, holds on to it, and then resends
    it later on. This seems fairly harmless, but consider the importance of timing.
    Imagine a mobile node that registers with its home agent, and then later returns
    home and deregisters. If a malicious device captures a copy of the original Registration
    Request and resends it, the home agent might be fooled into thinking the node
    has traveled away from home when it has not. It could then intercept the forwarded
    datagrams.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关注点是称为重放攻击的安全问题。在这种攻击中，第三方截获一个数据报，保留它，然后稍后重新发送。这似乎相当无害，但考虑一下时间的重要性。想象一个注册了其家乡代理的移动节点，然后后来返回家中并注销。如果一个恶意设备捕获了原始注册请求的副本并重新发送，家乡代理可能会被欺骗，认为节点已经离开了家，而实际上并没有。它随后可能会截获转发的数据报。
- en: The Identification field used in Registration Request and Registration Reply
    messages is designed to prevent replay attacks. Since each request has a different
    Identification number, nodes and agents can match up requests with replies and
    reject any datagrams they receive that are repeats of ones they have seen already.
    The Mobile IP standard also specifies alternative methods for protecting against
    replays.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册请求和注册回复消息中使用的标识字段是为了防止重放攻击设计的。由于每个请求都有一个不同的标识号，节点和代理可以匹配请求和回复，并拒绝他们收到的任何重复的已经见过的数据报。移动IP标准还指定了防止重放攻击的替代方法。
- en: While Mobile IP includes authentication measures for registration messages,
    it does not for other types of messages. It also doesn't specify authentication
    of encapsulated datagrams being forwarded from the home agent to the mobile node.
    Encryption is also not provided to safeguard the privacy of either control messages
    or forwarded datagrams. The obvious solution when stronger assurances of privacy
    or authenticity are required is to make use of the IPsec AH and/or Encapsulating
    Security Payload (ESP) protocols (described in [Chapter 29](ch29.html "Chapter 29. IP
    SECURITY (IPSEC) PROTOCOLS")).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然移动IP包括对注册消息的认证措施，但它不对其他类型的消息进行认证。它也没有指定从家乡代理转发到移动节点的封装数据报的认证。加密也没有提供以保护控制消息或转发数据报的隐私。当需要更强的隐私或真实性保证时，明显的解决方案是使用IPsec
    AH和/或封装安全载荷（ESP）协议（在第29章[第29章。IP安全性（IPSEC）协议](ch29.html "第29章。IP安全性（IPSEC）协议")中描述）。
