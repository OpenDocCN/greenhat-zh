- en: Chapter 13. A Simple Rails Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。一个简单的Rails项目
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: In the previous chapter, you installed Rails and became acquainted with the
    basics of the internal structure of a Rails application. In this chapter, we’ll
    be creating a Rails app that is a bit more complex—it retrieves multiple instances
    of a given data type from a database and iterates over those instances for presentation.
    We’ll also look into some more sophisticated ways of organizing code within Rails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你安装了Rails并熟悉了Rails应用程序内部结构的基本知识。在本章中，我们将创建一个稍微复杂一些的Rails应用程序——它从数据库中检索给定数据类型的多个实例，并对这些实例进行迭代以进行展示。我们还将探讨一些在Rails中组织代码的更复杂方法。
- en: Creating the Application
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: For our purposes, any simple application will suffice. I’ve chosen to create
    a photo album that will display a few photos from my wedding. It will be able
    to display all of the photos in a list as thumbnail images with accompanying descriptive
    text, as well as display each individual image in greater detail. It will also
    provide navigation tools to allow the user to jump around within the list. All
    of this will be accomplished via HTML, the default presentation format for the
    Web. In addition, the application will provide an RSS feed (the XML format we
    used as a data source in `currency_converter2.rb`) that will describe all the
    images.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，任何简单的应用程序都足够了。我选择创建一个相册应用程序，它将展示我婚礼的一些照片。它将能够以缩略图的形式列出所有照片，并附带描述性文字，同时还能以更详细的方式展示每张单独的图片。它还将提供导航工具，使用户能够在列表中跳转。所有这些都将通过HTML完成，这是Web的默认展示格式。此外，该应用程序还将提供一个RSS订阅源（我们在`currency_converter2.rb`中用作数据源的XML格式），用于描述所有图片。
- en: Initial Creation
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始创建
- en: We’ll create our application (called `photo_album`) within an appropriate directory
    with the command `rails photo_album`. Then type `cd photo_album` and `ruby script/server`
    to start the app. We can verify that Rails is running by browsing to http://localhost:3000,
    as we did in [Viewing Your Rails Application](ch12s02.html#viewing_your_rails_application
    "Viewing Your Rails Application") on page 230.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在适当的目录下使用命令`rails photo_album`创建我们的应用程序（称为`photo_album`）。然后输入`cd photo_album`和`ruby
    script/server`来启动应用程序。我们可以通过浏览到http://localhost:3000来验证Rails是否正在运行，就像我们在第230页的[查看你的Rails应用程序](ch12s02.html#viewing_your_rails_application
    "查看你的Rails应用程序")中做的那样。
- en: Preparing the Database
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备数据库
- en: For this application, I’ll be using the MySQL database. I’ll assume that you
    can get MySQL running on your machine and are able to do simple queries. If that’s
    not the case, you may want to brush up on MySQL with a book specifically on that
    topic, such as *Managing and Using MySQL*, by George Reese, Randy Jay Yarger,
    and Tim King (O’Reilly, 2002). If you are using a database other than MySQL, I’ll
    assume you are able to work out the subtle differences in the resulting Rails
    app on your own, with the help of the documentation available from your database
    vendor and at [http://rubyonrails.org](http://rubyonrails.org).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，我将使用MySQL数据库。我将假设你可以在你的机器上运行MySQL，并且能够执行简单的查询。如果不是这样，你可能需要通过一本专门介绍该主题的书籍来复习MySQL，例如乔治·里斯、兰迪·贾伊·亚加尔和蒂姆·金合著的《管理和使用MySQL》（O’Reilly，2002年）。如果你使用的是MySQL以外的数据库，我将假设你能够凭借数据库供应商提供的文档以及[http://rubyonrails.org](http://rubyonrails.org)上的文档，自己解决Rails应用程序中存在的细微差异。
- en: 'One thing you may need to do is alter the config/database.yml file, especially
    if you’re using a database program other than MySQL. I had to edit the value for
    `socket:` to be `/var/run/mysqld/mysqld.sock`. If you get the error `No such file
    or directory - /tmp/mysql.sock`, a mismatch in the socket description is the most
    likely cause. Rails is looking for the MySQL socket file at `/tmp/mysql.sock`,
    and you need to set it to the right file location. You can find the location of
    the socket file with this command (preferably as root) on a Unix-like operating
    system: `find / mysqld.sock | grep mysqld.sock`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要做的一件事是修改`config/database.yml`文件，尤其是如果你使用的是MySQL以外的数据库程序。我不得不编辑`socket:`的值，使其变为`/var/run/mysqld/mysqld.sock`。如果你收到错误`No
    such file or directory - /tmp/mysql.sock`，那么最可能的原因是套接字描述不匹配。Rails正在寻找位于`/tmp/mysql.sock`的MySQL套接字文件，你需要将其设置为正确的文件位置。你可以在类Unix操作系统中使用以下命令（最好是作为root用户）来查找套接字文件的位置：`find
    / mysqld.sock | grep mysqld.sock`。
- en: Adding Data
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据
- en: 'The photo album app differs from the simple structural example in [Chapter 12](ch12.html
    "Chapter 12. RubyGems and Rails Preparation") in that it has real data in a database,
    which we will now assume is handling that data. One of the most convenient ways
    to manage data for Rails (especially for simple test data like ours), is by using
    a migration. A *migration* in Rails is a description of data in Ruby that is created
    and deleted as needed. Let’s take a look at our migration file at `db/migrate/001_create_photos.rb`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 照片应用与第 12 章 [Chapter 12](ch12.html "Chapter 12. RubyGems and Rails Preparation")
    中的简单结构示例不同，因为它在数据库中有真实数据，我们假设现在正在处理这些数据。管理 Rails 数据（尤其是像我们这样的简单测试数据）的最方便方法之一是使用迁移。Rails
    中的 *迁移* 是 Ruby 中数据的描述，根据需要创建和删除。让我们看看我们的迁移文件 `db/migrate/001_create_photos.rb`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At ❶ and ❷, we define Constants for both the `COLUMN_NAMES` and `SAMPLE_PHOTOS`,
    which we use for data insertion. `COLUMN_NAMES` should be obvious, and each element
    of `SAMPLE_PHOTOS` is a Hash representing a database record, in which each key
    is the Symbol representation of a column name and the value is whatever data will
    be in that database field. At ❸, we define the `self.up` method, which contains
    all the code that will run when we perform our migration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❶ 和 ❷，我们为 `COLUMN_NAMES` 和 `SAMPLE_PHOTOS` 定义了常量，我们使用它们进行数据插入。`COLUMN_NAMES`
    应该很明显，`SAMPLE_PHOTOS` 的每个元素都是一个表示数据库记录的哈希，其中每个键是列名称的符号表示，值是数据库字段中的数据。在 ❸，我们定义了
    `self.up` 方法，它包含在我们执行迁移时将运行的代码。
- en: One of the most important tasks within `self.up` is the creation of the table,
    which is done at ❹. The `create_table` method takes a Symbol argument for the
    table name and a block describing what should be done to that table. In our case,
    `create_table` loops through the `COLUMN_NAMES`, creating a column for table `t`,
    named with the current value of `c`, of type text.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.up` 中的最重要的任务之一是创建表，这是在 ❹ 处完成的。`create_table` 方法接受一个用于表名的符号参数和一个描述对该表应执行什么操作的块。在我们的情况下，`create_table`
    遍历 `COLUMN_NAMES`，为表 `t` 创建一个名为当前 `c` 值的列，类型为文本。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*All our database table fields are of type text. If we had more complex data
    with different types, we would probably replace the Array *`COLUMN_NAMES`* with
    a Hash called *`COLUMNS`*, in which each key would be the column’s name and each
    key’s value would be the column’s data type*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们数据库的所有表字段都是文本类型。如果我们有更复杂的数据，具有不同类型，我们可能会用名为 *`COLUMNS`* 的哈希来替换 Array *`COLUMN_NAMES`*，其中每个键将是列的名称，每个键的值将是列的数据类型*。'
- en: At ❺, we create a new Photo instance called `p`; it is based on each member
    of `SAMPLE_PHOTOS`, which we call `sp` in turn. We then `save!` each version of
    `p`, which stores its data into the database table. At ❻, we show that when we’re
    done with this migration, the `:photos` table will be dropped. We execute the
    migration with the command `rake db:migrate`. Let’s examine the results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❺，我们创建了一个名为 `p` 的新 Photo 实例；它基于 `SAMPLE_PHOTOS` 的每个成员，我们将其称为 `sp`。然后我们为每个版本的
    `p` 执行 `save!`，将其数据存储到数据库表中。在 ❻，我们显示当迁移完成后，`:photos` 表将被删除。我们使用命令 `rake db:migrate`
    执行迁移。让我们检查结果。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Note that *`save!`* is named with a bang, because it is destructive (since
    it saves to the database). Also, running *`rake db:migrate`* runs whichever of
    your defined migrations is needed to make your migrations current. We only have
    one, so that’s the only one that runs*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，*`save!`* 带有感叹号，因为它具有破坏性（因为它会保存到数据库）。此外，运行 *`rake db:migrate`* 将运行你定义的任何迁移，以使迁移保持最新。我们只有一个，所以只有一个运行*。'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The migration was successful. We can double check that by querying MySQL (or
    whichever database you’re using).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移成功。我们可以通过查询 MySQL（或你使用的任何数据库）来双重检查。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*At the prompt, I entered the password I have already set up for my specific
    MySQL installation. Yours is whatever you have already chosen, or it may be unset.
    This will depend on the specific way you installed MySQL on your machine*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*在提示符下，我输入了我为特定的 MySQL 安装已经设置的密码。你的密码是你已经选择的，或者可能是未设置的。这取决于你在机器上安装 MySQL 的具体方式*。'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can now see that we have data in the database for use in our Rails app. Let’s
    move on to creating the other portions of the app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，数据库中已经有了我们 Rails 应用程序使用的数据。让我们继续创建应用程序的其他部分。
- en: Creating the Model and Controllers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型和控制器
- en: As you’ve already seen in the previous chapter, Rails makes it very easy to
    create Models, Controllers, and Views. For the photo album application, we’ll
    be creating a Model called *Photo* and Controllers called *Album* and *Feed*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中已经看到的，Rails使得创建模型、控制器和视图变得非常容易。对于照片相册应用程序，我们将创建一个名为*Photo*的模型和名为*Album*和*Feed*的控制器。
- en: Creating the Photo Model
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Photo模型
- en: Within the `photo_album` directory, execute `ruby script/generate model photo`,
    which creates the Model file `app/models/photo.rb`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`photo_album`目录中，执行`ruby script/generate model photo`，这将创建模型文件`app/models/photo.rb`。
- en: Creating the Album and Feed Controllers
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Album和Feed控制器
- en: Next, within `photo_album`, execute `ruby script/generate controller album index
    show` and `ruby script/generate controller feed images`. These create the Album
    Controller with the `index` and `show` Views and the Feed Controller with the
    `images` View, implemented by multiple files within the `app/controllers` and
    `app/views` subdirectories.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`photo_album`目录中，执行`ruby script/generate controller album index show`和`ruby
    script/generate controller feed images`。这些命令创建了带有`index`和`show`视图的Album控制器以及带有`images`视图的Feed控制器，这些视图由`app/controllers`和`app/views`子目录中的多个文件实现。
- en: Dissecting the Application
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析应用程序
- en: Now that we have created the basic skeleton of our application, let’s examine
    how it works. Think of this section as similar to the sections [The Code](ch11s06.html#the_code-id043
    "The Code") or [How It Works](ch11s06.html#how_it_works-id042 "How It Works")
    in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了应用程序的基本框架，让我们来看看它是如何工作的。将这一节视为与之前章节中的[代码](ch11s06.html#the_code-id043
    "代码")或[工作原理](ch11s06.html#how_it_works-id042 "工作原理")类似。
- en: Dissecting the Photo Model
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析Photo模型
- en: 'Our photo album app has one basic piece of data, represented in a Model called
    Photo. Let’s add some code to what’s already there and explore what it does. Edit
    `app/models/photo.rb` to match the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的照片相册应用程序有一个基本的数据块，由名为Photo的模型表示。让我们添加一些代码到现有的内容中，并探索它的功能。编辑`app/models/photo.rb`以匹配以下内容：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At ❶ and ❷, we have the `next_id` and `prev_id` methods, respectively. Within
    them, we make free use of built-in Rails methods. One of these is `minimum`, which
    is available to all Models; it takes a Symbol argument that establishes which
    attribute of that Model the minimum status will be based on. Another method is
    the `find` method, which is a wrapper for SELECT statements in SQL that takes
    specific arguments for filtering. Also available in Rails is the `@attributes`
    instance variable, which is a Hash whose keys are the field names from the database
    table and whose values are that column’s content for that particular instance
    of the Model. The Photo instance representing the database record with the ID
    `2` would have an `@attributes[‘id’]` equal to `2`, for example.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶和❷处，我们有`next_id`和`prev_id`方法，分别。在它们内部，我们自由使用内置的Rails方法。其中之一是`minimum`方法，它对所有模型都可用；它接受一个符号参数，用于确定该模型的最小状态将基于哪个属性。另一个方法是`find`方法，它是SQL中SELECT语句的包装器，它接受用于过滤的特定参数。Rails中还有`@attributes`实例变量，它是一个哈希，其键是数据库表中的字段名，其值是模型特定实例的该列内容。例如，代表数据库记录ID为`2`的Photo实例的`@attributes['id']`将等于`2`。
- en: At ❸ and ❹, we also have two private predicates that inform us if our Photo
    instance is the one with the `last_id?` and `first_id?`, respectively. We accomplish
    this by performing some simple equality testing with the known maximum and minimum
    `id` values. Note that the returned `id` values from `maximum` and `minimum` are
    Integers, while the values stored in `@attributes` are Strings. The `photo.rb`
    Model therefore makes liberal use of the `to_i` and `to_s` methods as needed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在❸和❹处，我们还有两个私有谓词，分别告诉我们我们的Photo实例是否是具有`last_id?`和`first_id?`的那个。我们通过使用已知的最大和最小`id`值进行一些简单的等式测试来实现这一点。请注意，从`maximum`和`minimum`返回的`id`值是整数，而存储在`@attributes`中的值是字符串。因此，`photo.rb`模型根据需要大量使用`to_i`和`to_s`方法。
- en: Dissecting the Controllers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析控制器
- en: Now that we understand our Photo Model, we need to interact with it in some
    way. That’s the job of one or more Controllers. Our photo album app has two Controllers,
    Album and Feed, each of which have their own Views.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了我们的Photo模型，我们需要以某种方式与之交互。这就是一个或多个控制器的工作。我们的照片相册应用程序有两个控制器，Album和Feed，每个控制器都有自己的视图。
- en: Dissecting the Album Controller
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析Album控制器
- en: 'Similar to what we did with the Photo Model, let’s add code to the Album Controller
    and explore what it does. Edit `app/controllers/album_controller.rb` to match
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对照片模型所做的一样，让我们向专辑控制器添加代码并探索它的功能。编辑`app/controllers/album_controller.rb`以匹配以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As is customary in an MVC application, `album_controller.rb` will be responsible
    for manipulating and processing data in ways that pertain to our photo album.
    In this particular case, `album_controller.rb`’s methods generally redirect to
    something defined in another file or simply provide a useful shortcut.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 应用程序中，按照惯例，`album_controller.rb`将负责以与我们照片专辑相关的方式操纵和处理数据。在这种情况下，`album_controller.rb`的方法通常将重定向到另一个文件中定义的内容，或者简单地提供一个有用的快捷方式。
- en: For this demonstration Rails app, I wanted to have an HTML footer that would
    remain consistent across multiple pages within the Album Controller. The question
    is then how to implement that feature and where to place its code. One answer
    would be to duplicate the necessary code in every View that has the footer, but
    that would be bad design. A better option would be to place the footer creation
    code in the appropriate Controller and simply call that code in every View where
    it’s needed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示 Rails 应用程序，我想要一个 HTML 页脚，它能在专辑控制器中的多个页面保持一致性。那么问题来了，如何实现这个功能以及在哪里放置相应的代码。一个答案可能是在每个包含页脚的视图中复制必要的代码，但这不是好的设计。更好的选择是将页脚创建代码放在合适的控制器中，并在需要的地方简单地调用该代码。
- en: However, there are situations in which you’d want the code outside of the base
    Controller. What if you want to implement a common feature across multiple Controllers?
    Each Controller in a Rails app is a child of the next file we’ll look at (`app/controllers/application.rb`),
    so putting the code in that file is an option. Another option is to use what Rails
    calls Helpers. *Helpers* are add-ons to the MVC framework and are similar to the
    mixin concept we used in `to_lang.rb` in [Chapter 10](ch10.html "Chapter 10. More
    Complex Utilities and Tricks, Part II"). At ❶ in `album_controller.rb`, we see
    from the RDoc that our footer-related code is in a distinct file called `app/helpers/footer_helper.rb`,
    and we can make use of that code within `album_controller.rb` by simply including
    the line `helper :footer`. If we had a Helper at `app/helpers/credit_card_authorization_helper.rb`,
    we could make use of its code in a Controller with the line `helper :credit_card_authorization`,
    and so on. In true object-oriented fashion, this allows us to organize code according
    to problem domain or topic in separate files, make use of them where needed, and
    not have to worry about the specific implementations. Of course, we’ll discuss
    the implementation of the footer code when we get to `app/helpers/footer_helper.rb`,
    but it’s very convenient that `album_controller.rb` needn’t concern itself with
    that level of detail.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下你可能希望代码位于基础控制器之外。如果你想在多个控制器中实现一个通用功能怎么办？在 Rails 应用程序中，每个控制器都是下一个文件（我们将要查看的`app/controllers/application.rb`）的子类，所以将代码放在那个文件中是一个选择。另一个选择是使用
    Rails 所称的助手（Helpers）。*助手*是 MVC 框架的附加组件，类似于我们在第 10 章（[第 10 章](ch10.html "第 10 章。更复杂的工具和技巧，第二部分")）中的`to_lang.rb`中使用的混合概念。在`album_controller.rb`的第❶处，我们可以从
    RDoc 中看到我们的页脚相关代码在一个名为`app/helpers/footer_helper.rb`的独立文件中，我们可以在`album_controller.rb`中通过简单地包含行`helper
    :footer`来使用这段代码。如果我们有一个助手在`app/helpers/credit_card_authorization_helper.rb`中，我们可以在控制器中使用`helper
    :credit_card_authorization`的行来使用其代码，依此类推。按照真正的面向对象风格，这允许我们根据问题域或主题在单独的文件中组织代码，在需要的地方使用它们，而不必担心具体的实现。当然，当我们到达`app/helpers/footer_helper.rb`时，我们将讨论页脚代码的实现，但`album_controller.rb`不需要关心那么详细的级别。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Helpers are even defined as Modules, just as traditional mixins are. This
    application has a lot of code in Helper files, which I’ll describe shortly, after
    I talk about the Controllers*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*助手被定义为模块，就像传统的混合一样。这个应用程序在助手文件中有大量的代码，我将在讨论控制器之后简要描述*。'
- en: Along with the Helper inclusion at ❶, we also have definitions of methods corresponding
    to the `index` and `show` Views at ❷ and ❸. The `show` method at ❸ is merely a
    shortcut for the built-in Rails method `find`. In this case, it takes an argument
    of the `id` parameter passed into the web application, which is available to us
    as `params[:id]`. This is how we show the specific requested photo. The `index`
    method at ❷ is (as we know from [Chapter 12](ch12.html "Chapter 12. RubyGems and
    Rails Preparation")) the default method called when none is explicitly provided.
    It merely establishes an instance variable within the Controller called `@photos`.
    To do so, it calls a method named `all_photos`, which is defined in our next file,
    `app/controllers/application.rb`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在❶处包含辅助器之外，我们还在❷和❸处定义了与 `index` 和 `show` 视图对应的方法。❸处的 `show` 方法仅仅是内置 Rails
    方法 `find` 的快捷方式。在这种情况下，它接受一个参数 `id`，这是传递到 Web 应用程序中的参数，我们可以通过 `params[:id]` 获取它。这就是我们展示特定请求的图片的方式。❷处的
    `index` 方法（正如我们从[第12章](ch12.html "第12章。RubyGems 和 Rails 准备")中知道的那样）是当没有明确提供时默认调用的方法。它只是在控制器中创建一个名为
    `@photos` 的实例变量。为此，它调用一个名为 `all_photos` 的方法，该方法定义在我们的下一个文件 `app/controllers/application.rb`
    中。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The *`params`* Hash in a Rails app is equivalent to *`cgi.params`*, which
    we saw in the *`simple_cgi.rb`* script in [Chapter 11](ch11.html "Chapter 11. CGI
    and the Web")*.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rails 应用程序中的 *`params`* 哈希等同于 *`cgi.params`*，我们在[第11章](ch11.html "第11章。CGI
    和 Web")中的 *`simple_cgi.rb`* 脚本中看到过*。'
- en: Dissecting the Application Controller
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析应用程序控制器
- en: The `application.rb` file in any Rails application describes the superclass
    of all Controllers. If there is any behavior or characteristic that you want to
    be truly universal across all Controllers, this is the place to put it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Rails 应用程序中的 `application.rb` 文件描述了所有控制器的超类。如果你想要在所有控制器中实现真正通用的行为或特性，这个位置就是放置它们的地方。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Note that you can modularize your code (i.e., break it down by topic into
    Helpers) and still make it universal. Just organize your code into Helpers, and
    then include all of those Helpers with *`helper`* lines in *`app/controllers/application.rb`*.
    Easy*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，你可以将代码模块化（即，按主题分解为辅助器）并仍然使其通用。只需将代码组织到辅助器中，然后在 `app/controllers/application.rb`
    中通过 `helper` 行包含所有这些辅助器。很简单*。'
- en: 'Edit `app/controllers/application.rb` to match the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/controllers/application.rb` 以匹配以下内容：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we’ve done in this file is define the `all_photos` method at ❶. This is
    arguably silly, in that it only provides a slightly shorter way to call `Photo.find(:all)`.
    However, this is primarily a demonstration app, and it does show that `all_photos`
    is now available to any Controller, anywhere in the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个文件中所做的所有事情就是定义了❶处的 `all_photos` 方法。这在某种程度上可能有点愚蠢，因为它只提供了一种稍微简短的方式来调用 `Photo.find(:all)`。然而，这主要是一个演示应用程序，它确实显示了
    `all_photos` 现在可以在应用程序的任何地方的任何控制器中使用。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The session information is automatic, and it helps Rails disambiguate among
    multiple users that are using the app at the same time. For example, I can browse
    the entire list of photos with the Album’s *`index`* View, while you simultaneously
    look in greater detail at the second photo with Album’s *`show`* View*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话信息是自动的，它帮助 Rails 区分同时使用应用程序的多个用户。例如，我可以使用相册的 *`index`* 视图浏览整个照片列表，而你同时可以更详细地查看相册的第二个照片的
    *`show`* 视图*。'
- en: Dissecting the Feed Controller
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析 Feed 控制器
- en: The Album Controller is not our only Controller. I also want to provide an RSS
    feed of information about these images, and the Feed Controller is our way of
    doing so. Just like `album_controller.rb`, it descends from `app/controllers/application.rb`,
    so it has the `all_photos` method available to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 相册控制器不是我们唯一的控制器。我还想提供有关这些图像信息的 RSS 源，Feed 控制器就是我们实现这一点的途径。就像 `album_controller.rb`
    一样，它从 `app/controllers/application.rb` 继承，所以它可以使用 `all_photos` 方法。
- en: 'Edit `app/controllers/feed_controller.rb` to match the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/controllers/feed_controller.rb` 以匹配以下内容：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At ❶, we define a constant for the `CONTENT_TYPE`, declaring something appropriate
    for an RSS feed. Then at ❷, we declare our only method, `images`. It establishes
    the `@photos` instance variable just as `album_controller.rb` does, and also sets
    `@headers[‘Content-Type’]`. The `@headers` variable is, as you might expect, the
    variable used to define the HTTP headers of the application’s output. Before moving
    on to the Views, let’s see what’s going on in our Helper files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们定义了一个用于 `CONTENT_TYPE` 的常量，声明了适合 RSS 订阅的内容。然后在❷处，我们声明了唯一的方法 `images`。它就像
    `album_controller.rb` 一样设置了 `@photos` 实例变量，并且也设置了 `@headers[‘Content-Type’]`。正如你可能预想的，`@headers`
    变量是用来定义应用程序输出的 HTTP 头的变量。在继续到视图之前，让我们看看我们的 Helper 文件中发生了什么。
- en: Dissecting the Helpers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构 Helper
- en: Models, Controllers, and Views are not the only types of files in a Rails app.
    I touched on the concept of Helpers in our discussion of the Photo Model, but
    now we’ll explore them in depth.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 模型、控制器和视图并不是 Rails 应用中唯一的文件类型。在我们讨论照片模型时，我提到了 Helper 的概念，但现在我们将深入探讨它们。
- en: Dissecting the Album Helper
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构专辑 Helper
- en: 'Edit `app/helpers/album_helper.rb` to match the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/helpers/album_helper.rb` 以匹配以下内容：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At ❶, we start defining some useful Constants, including one of our old friends,
    a Hash with Symbol keys, at ❷. At ❸, we define a method called `row_class_from_index`,
    whose RDoc explains that it merely outputs text representing the appropriate CSS
    class. This allows us to change the CSS style of a row easily, and the modulus
    makes it repeat. At ❹, we have a method called `show_listing_header_columns` that
    simply returns the corresponding Constant. The `show_photo` method at ❺ uses the
    built-in Rails method `image_tag`, which takes the location of the image (the
    `src` attribute of the `img` tag, in other words) as the first argument. The second
    argument is a Hash whose keys will be any additional `img` attributes and whose
    values will be used as the values for the corresponding `img` attributes. The
    location (i.e., `img src`) is the `photo`’s `image_path`, and since all `img`
    tags should have an `alt` attribute, we provide that, with an appropriate identifying
    String based on the `photo`’s `title`. At ❻, we define `show_thumbnail_for_list`,
    which is a Helper method for presentation that is very similar to `show_photo`.
    It only differs by including a `style` attribute for the resulting `img` tag,
    whose value is `IMAGE_STYLE[:thumb]`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们开始定义一些有用的常量，包括我们的一位老朋友，一个具有符号键的哈希表，在❷处。在❸处，我们定义了一个名为 `row_class_from_index`
    的方法，其 RDoc 解释说它仅仅输出表示适当 CSS 类的文本。这允许我们轻松地更改行的 CSS 样式，并且模运算使其重复。在❹处，我们有一个名为 `show_listing_header_columns`
    的方法，它简单地返回相应的常量。在❺处的 `show_photo` 方法使用了内置的 Rails 方法 `image_tag`，它将图像的位置（即 `img`
    标签的 `src` 属性）作为第一个参数。第二个参数是一个哈希表，其键可以是任何额外的 `img` 属性，其值将用作相应 `img` 属性的值。位置（即 `img
    src`）是 `photo` 的 `image_path`，由于所有 `img` 标签都应该有一个 `alt` 属性，我们提供了这个属性，并使用基于 `photo`
    的 `title` 的适当标识字符串。在❻处，我们定义了 `show_thumbnail_for_list`，这是一个用于展示的 Helper 方法，它与
    `show_photo` 非常相似。它唯一的区别是包含了一个 `style` 属性，其值是 `IMAGE_STYLE[:thumb]`。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*One easy way to refactor this code (meaning to change its internal structure
    without changing its overall behavior) would be to combine *`show_photo`* and
    *`show_thumbnail_for_list`* into a single *`show_photo`* method that takes an
    optional third argument, which declares whether or not the photo is a thumbnail.
    You can read more about the process of refactoring in Martin Fowler’s book* Refactoring
    (*Addison-Wesley Professional, 1999*).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构此代码（即在不改变其整体行为的情况下改变其内部结构）的一个简单方法是将 *`show_photo`* 和 *`show_thumbnail_for_list`*
    合并成一个单一的 *`show_photo`* 方法，该方法接受一个可选的第三个参数，该参数声明照片是否是缩略图。你可以在 Martin Fowler 的书籍*
    Refactoring (*Addison-Wesley Professional, 1999*)中了解更多关于重构过程的信息*。'
- en: Next, at ❼, we define `page_title`. If there is a `@photo` present, `page_title`
    will return that `@photo`’s `title`. If there is no `@photo`, it will fall back
    to the `action_name` of the `controller`. What does that mean? The `@photo.title`
    should be straightforward. The `action_name` is essentially the name of the View.
    This means that when we browse using the `index` View (or `action_name`) and have
    not yet selected a specific photo to view in greater detail with the `show` View,
    the `page_title` will simply be `index`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第❼行，我们定义了`page_title`。如果有`@photo`存在，`page_title`将返回那个`@photo`的`title`。如果没有`@photo`，它将回退到`controller`的`action_name`。这意味着什么？`@photo.title`应该是直接的。`action_name`基本上是View的名称。这意味着当我们使用`index`
    View（或`action_name`）浏览，并且还没有使用`show` View选择一个特定的照片进行更详细查看时，`page_title`将简单地是`index`。
- en: Finally, at ❽, we define `title_with_thumbnail`. It uses several other methods
    and Constants. Rails has a built-in method called `h`, which formats its input
    for HTML presentation. For example, `h(&)` returns `&amp;`. This is useful in
    our app because we have a photo whose title is *Liam & Ducks*, but we don’t want
    that ampersand to break the HTML validity of the output. The `title_with_thumbnail`
    method uses our home-brewed `show_thumbnail_for_list` and `join`s it with `page_title`,
    using whatever we’ve defined `HTML_BREAK` to be within the `ApplicationHelper`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第❽行，我们定义了`title_with_thumbnail`。它使用了几个其他方法和常量。Rails有一个内置的方法叫做`h`，它为HTML展示格式化其输入。例如，`h(&)`返回`&amp;`。这在我们的应用中很有用，因为我们有一个标题为*Liam
    & Ducks*的照片，但我们不希望这个和号破坏输出的HTML有效性。`title_with_thumbnail`方法使用了我们自制的`show_thumbnail_for_list`，并用`join`将其与`page_title`连接起来，使用我们在`ApplicationHelper`中定义的`HTML_BREAK`。
- en: 'WHERE TO PUT CODE: CONTROLLER OR HELPER (OR ELSEWHERE)?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'WHERE TO PUT CODE: CONTROLLER OR HELPER (OR ELSEWHERE)?'
- en: As you can see, the Album Helper is noticeably bigger than the Controller it
    aids. When should you put code in the Controller, and when should you put it in
    a Helper? That’s a good question. When there isn’t a clear division by topic,
    such as for the `footer_helper.rb` below, it becomes more difficult to answer.
    When something is truly fundamental to the data, such as the Photo methods that
    directly pertain to ids, it probably belongs in the Model. When something is completely
    presentationspecific, it can probably go in the appropriate View. However, it’s
    considered bad style to have too much dynamic content in a View file. Anything
    more complicated than looping over a set of items should probably be abstracted
    into a method, rather than being in the View itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，专辑助手的大小明显大于它所帮助的控制器。你什么时候应该在控制器中放代码，什么时候应该在助手中放代码？这是一个好问题。当没有明确的主题划分时，例如下面的`footer_helper.rb`，回答就变得更加困难。当某件事真正与数据的基本性相关，例如直接与ids相关的照片方法时，它可能属于模型。当某件事完全是展示特定时，它可能可以放在适当的视图中。然而，在视图中放置过多的动态内容被认为是不良风格。任何比遍历一组项目更复杂的代码都应该抽象成一个方法，而不是放在视图中本身。
- en: That leaves either the Controller or a Helper. As you can see, I like to have
    a fairly sparse, minimalist Controller—critics might say that makes my Helpers
    too busy. Other coders might put many methods directly in the Controller, making
    little use of Helpers at all. Still others might have broken anything related
    to thumbnail images into yet another Helper called `thumbnail_helper.rb`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了控制器或助手的选择。如您所见，我倾向于有一个相当稀疏、极简的控制器——批评者可能会说这使我的助手变得过于繁忙。其他程序员可能会直接在控制器中放置许多方法，几乎不使用助手。还有一些人可能会将任何与缩略图图像相关的内容拆分到另一个名为`thumbnail_helper.rb`的助手中。
- en: There are many options. As long as you don’t put presentation-related methods
    in your Model, and you keep your Views relatively free of code that actually does
    *stuff* (instead including mostly code that *presents stuff*), you’re probably
    doing fine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选择。只要你不把与展示相关的代码放在你的模型中，并且你保持你的视图相对没有实际做*事情*的代码（而主要是包含*展示内容*的代码），你很可能做得很好。
- en: Dissecting the ApplicationHelper
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析`ApplicationHelper`
- en: We’ve already seen that `album_helper.rb` expects a definition for `HTML_BREAK`
    within `ApplicationHelper`. Let’s see how it does it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`album_helper.rb`在`ApplicationHelper`中期望有一个对`HTML_BREAK`的定义。让我们看看它是如何做到的。
- en: 'Edit `app/helpers/application.rb` to match the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`app/helpers/application.rb`以匹配以下内容：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There isn’t much there—it’s basically just the Constant definition we expected.
    Why is it defined here, and not in `AlbumHelper`? Because we’ll also need it in
    `FooterHelper`. Note that while Controllers automatically descend from `ApplicationController`,
    Helpers don’t automatically descend from `ApplicationHelper`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多内容——基本上只是我们预期的常量定义。为什么它在这里定义，而不是在 `AlbumHelper` 中定义？因为我们还需要在 `FooterHelper`
    中使用它。请注意，虽然控制器自动继承自 `ApplicationController`，但助手类并不自动继承自 `ApplicationHelper`。
- en: Dissecting the FeedHelper
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构 FeedHelper
- en: 'Edit `app/helpers/feed_helper.rb` to match the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/helpers/feed_helper.rb` 以匹配以下内容：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At ❶, we start with our usual Constant declarations. These include a declaration
    at ❷ for `LINK_OPTIONS_DEFAULTS`, which stores information common across multiple
    types of links, and one for `LINK_OPTIONS` at ❸, which uses these defaults and
    also adds a pair whose key is `:action` and whose value is either `:index` or
    `:show`, depending on how it’s called. These `:index` and `:show` values represent
    Views within the Album Controller, of course, as the value for `:controller` in
    `LINK_OPTIONS_DEFAULTS` indicates. `FeedHelper` also defines several other Constants
    with values useful for an RSS feed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们开始进行我们通常的常量声明。这包括在❷处对 `LINK_OPTIONS_DEFAULTS` 的声明，它存储了跨多种类型链接的通用信息，以及在❸处对
    `LINK_OPTIONS` 的声明，它使用这些默认值并添加了一对键为 `:action` 的值，可以是 `:index` 或 `:show`，具体取决于如何调用。这些
    `:index` 和 `:show` 值当然代表了专辑控制器中的视图，因为 `LINK_OPTIONS_DEFAULTS` 中 `:controller`
    的值表示。`FeedHelper` 还定义了几个其他常量，这些常量的值对 RSS 流很有用。
- en: At ❹ we have a method called `feed_description`, which simply passes the value
    of the `DESCRIPTION` Constant through the Rails built-in method `h`, which we’ve
    already seen and which formats for HTML presentation. Finally, `rss_url_for_image`
    at ❺ is a wrapper we’ve built around the Rails method `url_for`, which behaves
    as its name suggests. (It is described in greater detail at [http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#M000484](http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#M000484).)
    If an `image` is not passed in, `rss_url_for_image` returns the `url_for` the
    `LINK_OPTIONS` appropriate for an `:index` View. If there is an `image, rss_url_for_image`
    returns the `url_for` the `LINK_OPTIONS` appropriate for a `:show` View and includes
    the `:id` of the image to be shown.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在❹处，有一个名为 `feed_description` 的方法，它只是将 `DESCRIPTION` 常量的值通过 Rails 内置方法 `h` 传递，我们之前已经见过，该方法用于格式化
    HTML 展示。最后，`rss_url_for_image` 在❺处是我们围绕 Rails 方法 `url_for` 构建的包装器，它的工作方式正如其名。（它在
    [http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#M000484](http://api.rubyonrails.org/classes/ActionView/Helpers/UrlHelper.html#M000484)
    中有更详细的描述。）如果没有传递 `image`，`rss_url_for_image` 返回适用于 `:index` 视图的 `url_for` 的 `LINK_OPTIONS`。如果有
    `image`，`rss_url_for_image` 返回适用于 `:show` 视图的 `url_for` 的 `LINK_OPTIONS`，并包含要显示的
    `image` 的 `:id`。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The behavior of *`rss_url_for_image`*, which differs depending on whether
    or not there is an *`image`*, is similar to the potential melding of *`AlbumHelper.show_photo`*
    and *`AlbumHelper.show_thumbnail_for_list`* proposed earlier*.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*`rss_url_for_image` 的行为，根据是否有 `image` 而有所不同，类似于之前提出的将 *`AlbumHelper.show_photo`*
    和 *`AlbumHelper.show_thumbnail_for_list`* 结合起来的潜在融合*。'
- en: Dissecting the FooterHelper
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构 FooterHelper
- en: 'Edit `app/helpers/footer_helper.rb` to match the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/helpers/footer_helper.rb` 以匹配以下内容：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At ❶, we define two Constants, `BAR_SEPARATOR` and `RSS`. The `BAR_SEPARATOR`
    Constant is a simple delimiter for presentation, while `RSS` is another Hash with
    Symbol keys that details information pertinent to `:icons` and `:link_options`,
    respectively. In these definitions, I’ve used `%q[]` instead of single quotes
    to define `BAR_SEPARATOR`, just as a reminder that the option is available.^([[37](#ftn.CHP-13-FNOTE-1)])
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们定义了两个常量，`BAR_SEPARATOR` 和 `RSS`。`BAR_SEPARATOR` 常量是一个简单的分隔符，用于展示，而 `RSS`
    是另一个包含符号键的哈希，分别详细说明了与 `:icons` 和 `:link_options` 相关的信息。在这些定义中，我使用了 `%q[]` 而不是单引号来定义
    `BAR_SEPARATOR`，仅作为一个提醒，选项是可用的.^([[37](#ftn.CHP-13-FNOTE-1)])
- en: At ❷, our main public method, `show_footer`, just returns the outputs of the
    private methods `rails_link_to_top` and `rss_icon_links, join`ed on the `HTML_BREAK`
    Constant that we’ve already seen, and all wrapped in an HTML paragraph tag with
    the id `rails_img_wrapper`. We create our paragraph tag the old-fashioned way—by
    outputting plaintext. You can still do that in Rails, although the availability
    of methods like `url_for` and `image_tag` make the practice uncommon.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第❷行，我们的主要公共方法 `show_footer` 只返回私有方法 `rails_link_to_top` 和 `rss_icon_links`
    的输出，这些输出通过我们之前看到的 `HTML_BREAK` 常量连接，并且全部包裹在一个具有 id `rails_img_wrapper` 的 HTML
    段落标签中。我们以传统的方式创建段落标签——通过输出纯文本。你仍然可以在 Rails 中这样做，尽管 `url_for` 和 `image_tag` 等方法的可用性使得这种做法变得不常见。
- en: 'So what do the private methods do? The `rails_link_to_top` method at ❸ just
    creates a link with the Rails built-in `link_to`, which takes the link argument
    and a Hash describing the `:controller` to be used: `‘album’`, in this case. The
    Hash can also describe the `:action`, if needed. The `rss_icon_links` method at
    ❹ `map`s an operation onto each member of `RSS[:icons]`. That operation is also
    a call to `link_to`, where the linked image is the current element within `RSS[:icons]`
    (called `icon`) and the Hash describing the `:controller` and `:action` is always
    `RSS[:link_options]`. The Array resulting from the `map` is then `join`ed on the
    `BAR_SEPARATOR`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，私有方法都做了些什么呢？第❸行的 `rails_link_to_top` 方法只是使用 Rails 内置的 `link_to` 创建了一个链接，它接受链接参数和一个描述要使用的
    `:controller` 的 Hash：在这个例子中是 `'album'`。如果需要，这个 Hash 也可以描述 `:action`。第❹行的 `rss_icon_links`
    方法将一个操作映射到 `RSS[:icons]` 的每个成员上。这个操作也是一个对 `link_to` 的调用，其中链接的图像是 `RSS[:icons]`
    中的当前元素（称为 `icon`），而描述 `:controller` 和 `:action` 的 Hash 总是 `RSS[:link_options]`。`map`
    操作的结果数组然后通过 `BAR_SEPARATOR` 连接。
- en: Dissecting the Album Controller’s Views
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆解专辑控制器的视图
- en: Now, let’s move on to the Views. Since we’ve already defined so much of the
    application in methods within either the Model, Controller, or various Helpers,
    our Views should be fairly sparse. View files differ from the files we’ve seen
    so far in that they are .rhtml files (similar to `mod_ruby_demo.rhtml`), not pure
    Ruby .rb files. That’s one of the reasons (apart from good application design
    principles) that having too much dynamic Ruby content in your View files is discouraged.
    It’s relatively easy to debug Ruby within Ruby, but it isn’t so easy when you
    have to keep shifting back and forth between Ruby and HTML.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向视图。由于我们已经在模型、控制器或各种助手中的方法中定义了应用的大部分内容，所以我们的视图应该相当稀疏。视图文件与之前看到的文件不同，因为它们是
    .rhtml 文件（类似于 `mod_ruby_demo.rhtml`），而不是纯 Ruby .rb 文件。这也是不建议在视图文件中包含太多动态 Ruby
    内容的原因之一（除了良好的应用设计原则之外）。在 Ruby 中调试 Ruby 相对容易，但当你需要在 Ruby 和 HTML 之间来回切换时，这就不那么容易了。
- en: Dissecting the index View
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆解索引视图
- en: 'Edit `app/views/album/index.rhtml` to match the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `app/views/album/index.rhtml` 以匹配以下内容：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At ❶, we have HTML comments explaining where to find the methods that we put
    to use within this file. The file then continues with ordinary, unsurprising HTML.
    You may wonder why there are no `<html>, <head>`, or `<body>` tags. For that answer,
    you’ll have to wait until we introduce the concept of layouts and describe the
    file `app/views/layouts/album.rhtml` later in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第❶行，我们有 HTML 注释解释了我们在这个文件中使用的函数的位置。然后文件继续使用普通、不出所料的 HTML。你可能想知道为什么没有 `<html>`,
    `<head>` 或 `<body>` 标签。对于这个答案，你将不得不等到我们介绍布局的概念，并在本章后面描述 `app/views/layouts/album.rhtml`
    文件。
- en: The first appearance of Ruby at ❷ is a call to `show_listing_header_columns`,
    which we know (and which our HTML comments remind us) was defined in `app/helpers/album_helper.rb`.
    This allows the View to call a method whose name says what it does, without worrying
    about the implementation. Next, at ❸, we will loop through each `photo` within
    `@photos`, along with its index, which we’ll call `i`. You’ll notice that the
    `each_with_index` line ends its Ruby escape with `-%>`, not just `%>`. This tells
    Rails that there should not be an automatic carriage return in the interpreted
    output. It’s not critical here, but you can imagine this could be very useful
    within a `<pre>` tag, for example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 首次出现在第❷行，是一个对 `show_listing_header_columns` 的调用，我们知道（并且我们的 HTML 注释提醒我们）这个方法定义在
    `app/helpers/album_helper.rb` 中。这允许视图调用一个名字就能说明其功能的函数，而不必担心其实现。接下来，在第❸行，我们将遍历
    `@photos` 中的每个 `photo`，以及它的索引，我们将称之为 `i`。你会注意到 `each_with_index` 行以 `-%>` 结束 Ruby
    转义，而不是仅仅 `%>`。这告诉 Rails 在解释输出中不应该有自动的换行符。这里不是特别关键，但你可以想象这在一个 `<pre>` 标签内可能非常有用。
- en: What do we do with each `photo`? We’ll present it within a table, applying the
    CSS class of `row_class_from_index(i)` to each `<td>` element at ❹. The content
    within that `<td>` element will be the result of a multi-line Ruby call that begins
    at ❺. Its value is the result of a `link_to` call on the `title_with_thumbnail`
    that points to the `‘show’ :action` and displays the photo identified by `photo.id`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个`photo`做什么？我们将在一个表格中展示它，将`row_class_from_index(i)`的CSS类应用于每个❹的`<td>`元素。该`<td>`元素中的内容将是始于❺的多行Ruby调用的结果。它的值是对`title_with_thumbnail`上的`link_to`调用的结果，指向`‘show’
    :action`并显示由`photo.id`标识的照片。
- en: In addition to the thumbnail `<td>` cell, we also want another `<td>` cell that
    contains the photo’s description. That begins at ❻, with another call to `row_class_from_index`.
    Its `<td>` cell contains simply `photo.description` at ❼. We then close the `each_with_index`
    call from ❸ with `end` at ❽. Finally, at ❾ we call `show_footer`, which we’ve
    already discussed in `footer_helper.rb`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缩略图`<td>`单元格之外，我们还想再有一个包含照片描述的`<td>`单元格。这始于❻，通过另一个对`row_class_from_index`的调用。它的`<td>`单元格只包含`photo.description`在❽。然后我们用`end`在❸关闭`each_with_index`调用。最后，在❾我们调用`show_footer`，这已经在`footer_helper.rb`中讨论过。
- en: Dissecting the show View
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析show视图
- en: 'Now let’s look at the `show` View, which displays a particular photo in greater
    detail. Edit `app/views/album/show.rhtml` to match the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`show`视图，它以更详细的方式显示特定的照片。编辑`app/views/album/show.rhtml`以匹配以下内容：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start off again with some HTML reminder comments. The first real Ruby appears
    at ❶—it is a call to `show_photo` from AlbumHelper, passing in `@photo`, which
    is the particular photo instance that matches the `id` parameter used to call
    the `show` View. Then at ❷, we pass `@photo`’s `title` through the `h` formatter
    method, and at ❸, we wrap the `@photo`’s `description` within an appropriately
    classed paragraph tag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从一些HTML提醒注释开始。真正的Ruby代码首次出现在❶——这是一个从AlbumHelper调用`show_photo`的方法，传递了`@photo`，它是与用于调用`show`视图的`id`参数匹配的特定照片实例。然后在❷，我们通过`h`格式化方法传递`@photo`的`title`，在❸，我们将`@photo`的`description`包裹在一个适当类别的段落标签中。
- en: Under a horizontal rule, we have an unordered list, each item of which is a
    call to the `link_to` method. At ❹, we provide a link called `‘First’` that `show`s
    the photo with the `minimum :id`. At ❺, the link destination `show`s the photo
    with the previous `id` via the text `‘Previous’`, and at ❻, the destination `show`s
    the Photo with the `next_id` via the text `‘Next’`. At ❼, it `show`s the `‘Last’`
    photo, defined as the one with the `maximum :id`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在一条水平线下面，我们有一个无序列表，列表中的每一项都是对`link_to`方法的调用。在❹，我们提供了一个名为`‘First’`的链接，它通过`minimum
    :id`显示照片。在❺，链接目的地通过文本`‘Previous’`显示具有前一个`id`的照片，在❻，目的地通过文本`‘Next’`显示具有`next_id`的Photo。在❼，它显示`‘Last’`照片，定义为具有最大`id`的照片。
- en: The links so far have all been formatted in the simple `<a href>` style, but
    there are other options available. For instance, Rails provides many built-in
    methods to perform some common JavaScript operations. One of these is the confirm
    box, which interrupts your browsing with a box asking you to confirm some question.
    I’m sure you’ve seen them while browsing, but [Figure 13-1](ch13s02.html#a_confirm_box_automatically_generated_by
    "Figure 13-1. A confirm box automatically generated by Rails") shows one in the
    Epiphany browser on Ubuntu.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有链接都格式化为简单的`<a href>`样式，但还有其他选项可用。例如，Rails提供了许多内置方法来执行一些常见的JavaScript操作。其中之一是确认框，它会通过一个询问你确认某些问题的框来中断你的浏览。我确信你在浏览时已经见过它们，但[图13-1](ch13s02.html#a_confirm_box_automatically_generated_by
    "图13-1. Rails自动生成的确认框")显示了在Ubuntu的Epiphany浏览器中的一个。
- en: The code at ❽ creates this box for us. Choosing `Cancel` makes it do nothing,
    while choosing `OK` causes it to proceed as if it were a standard link, this time
    to the `‘index’ :action`. The code to describe this also adds a second Hash to
    `link_to`, with the key `:confirm` and with a value taken from the `AlbumHelper::CONFIRM_MESSAGE`
    Constant. Notice that this link provides the otherwise-optional curly brace delimiters
    for the Hashes, to show which pairs go with which Hash. The text for the confirm
    box link is `‘Full List’`, since it brings us back to the `index` View. After
    some more HTML comments, we see a call to `show_footer` at ❾.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在❽处编写的代码为我们创建了这个框。选择`取消`会使它不执行任何操作，而选择`确定`则会使它像标准链接一样继续执行，这次链接到`‘index’ :action`。描述这一功能的代码还向`link_to`添加了第二个Hash，键为`:confirm`，值为从`AlbumHelper::CONFIRM_MESSAGE`常量中获取。请注意，此链接提供了用于Hash的括号分隔符，以显示哪些对与哪个Hash相对应。确认框链接的文本是`‘完整列表’`，因为它带我们回到了`index`视图。在更多的HTML注释之后，我们看到在❾处调用了`show_footer`。
- en: '![A confirm box automatically generated by Rails](httpatomoreillycomsourcenostarchimages686182.png.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![由Rails自动生成的确认框](httpatomoreillycomsourcenostarchimages686182.png.jpg)'
- en: Figure 13-1. A confirm box automatically generated by Rails
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图13-1. 由Rails自动生成的确认框
- en: Dissecting the Feed Controller’s images View
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析Feed控制器中的图像视图
- en: In general, everything I’ve said about the Album Controller’s Views will also
    apply to the Feed Controller’s View. The same basic design principles apply. However,
    there are a few slight differences. The Feed Controller is more lightweight and
    has fewer responsibilities. It also only has one View, which we’re about to explore.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我所说的关于Album控制器视图的内容也适用于Feed控制器视图。相同的基本设计原则适用。然而，有一些细微的差别。Feed控制器更轻量级，责任更少。它也只有一个视图，我们即将探讨。
- en: As already noted, Album is not our only Controller. We also want to use Feed
    to display our images within an RSS Feed. Let’s see how that’s done. Edit `app/views/feed/images.rxml`
    to match the following. Note that the file extension is .rxml instead of .rhtml,
    since we’re creating XML for an RSS Feed instead of regular HTML.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Album不是我们唯一的控制器。我们还想使用Feed在RSS Feed中显示我们的图像。让我们看看这是如何实现的。编辑`app/views/feed/images.rxml`以匹配以下内容。请注意，文件扩展名是.rxml而不是.rhtml，因为我们正在为RSS
    Feed创建XML而不是常规HTML。
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This file uses a project called XML::Builder ([http://rubyforge.org/projects/builder](http://rubyforge.org/projects/builder)),
    an XML generation library that comes built in to Rails. At ❶, we call `xml.instruct!`,
    which starts the XML document. (XML::Builder’s relationship to Rails ensures that
    the `xml` variable is available, and we don’t have to do anything ahead of time.)
    Then at ❷, we set up our RSS Feed by calling `xml.rss` with `FeedHelper::RSS_OPTIONS`.
    Each RSS Feed has a `channel`, which we establish at ❸, and an associated `image`,
    which we define at ❹.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件使用了一个名为XML::Builder的项目([http://rubyforge.org/projects/builder](http://rubyforge.org/projects/builder))，这是一个内置到Rails中的XML生成库。在❶处，我们调用`xml.instruct!`，这开始了XML文档。由于XML::Builder与Rails的关系，`xml`变量是可用的，我们事先不需要做任何事情。然后在❷处，我们通过调用`xml.rss`并使用`FeedHelper::RSS_OPTIONS`来设置我们的RSS
    Feed。每个RSS Feed都有一个`channel`，我们在❸处建立它，还有一个相关的`image`，我们在❹处定义它。
- en: The content (or articles) within our RSS Feed are each a single photo with associated
    descriptive text. At ❺, we use `@photos` from the `FeedController`’s `images`
    method, looping through `each` of them, calling them `image` in turn. Then we
    create an `xml.item`, passing in a block defining each of the appropriate characteristics.
    Notice how many of them are either expressible as a Constant (such as `FeedHelper::TITLE`)
    or as the result of a method call (such as `rss_url_for_image`, with or without
    an `image` argument).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们RSS Feed中的内容（或文章）是每张照片及其相关的描述性文本。在❺处，我们使用`FeedController`的`images`方法中的`@photos`，逐个遍历它们，依次称它们为`image`。然后我们创建一个`xml.item`，传递一个定义每个适当特征的块。请注意，其中许多都可以表示为一个常量（例如`FeedHelper::TITLE`）或方法调用的结果（例如`rss_url_for_image`，带或不带`image`参数）。
- en: Dissecting the Album Controller’s Layout
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析Album控制器布局
- en: Remember when I first talked about `app/views/album/index.rhtml` and mentioned
    that that file lacked certain expected HTML content, such as the `<html>` tag?
    Think about that for a minute. You might expect such content to appear in every
    View’s .rhtml file, but that would produce a great deal of duplicated content.
    Duplication is precisely what programmers try to avoid, so we should find some
    other solution to that problem. One approach would be to define methods in the
    Controller or a Helper like `doctype_tag, html_tag, head_tag`, and so on, similar
    to the `image_tag` method that Rails already provides for us.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我第一次谈到`app/views/album/index.rhtml`并提到该文件缺少某些预期的HTML内容，比如`<html>`标签吗？花点时间思考一下。你可能会期望这样的内容出现在每个视图的.rhtml文件中，但那会产生大量的重复内容。重复正是程序员试图避免的，因此我们应该找到其他解决方案来解决这个问题。一种方法是在控制器或助手中定义方法，如`doctype_tag,
    html_tag, head_tag`等，类似于Rails已经为我们提供的`image_tag`方法。
- en: That would be a reasonable approach, except that invariably what is being created
    is content in a format that is tightly bound to a particular type of View, most
    commonly HTML. We already have .rhtml files for that express purpose. Shouldn’t
    we find a way to have some sort of .rhtml template?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个合理的做法，但不可避免的是，正在创建的内容格式与特定类型的视图紧密绑定，最常见的是HTML。我们已经有.rhtml文件来专门实现这个目的。我们难道不应该找到一种方法来拥有某种.rhtml模板吗？
- en: 'That’s exactly what layouts are. They wrap View output within a template. Edit
    `app/views/layouts/album.rhtml` to match the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是布局的作用。它们将视图输出包裹在模板中。编辑`app/views/layouts/album.rhtml`以匹配以下内容：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At ❶, we use `page_title` from `app/helpers/album_helper.rb` for the `<title>`.
    At ❷ and ❸, we use Rails’ built-in `stylesheet_link_tag` method to include stylesheets.
    We always want the `master.css` stylesheet, and if the Controller has an `action_name`,
    we want that associated stylesheet as well. Finally, at ❹, we see `yield :layout`.
    What does this do?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们使用`app/helpers/album_helper.rb`中的`page_title`来设置`<title>`。在❷和❸处，我们使用Rails内置的`stylesheet_link_tag`方法来包含样式表。我们总是想要`master.css`样式表，如果控制器有`action_name`，我们也想要相关的样式表。最后，在❹处，我们看到`yield
    :layout`。这会做什么？
- en: We already know that `yield` within a method that takes a `block_argument` functions
    the same way as `block_argument.call` does. This is similar, except that the output
    from the requested View takes the place of the block. It’s the equivalent of saying
    *Always wrap whatever is requested inside me, and place whatever was requested
    at this point*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，在接收`block_argument`参数的方法中使用`yield`与`block_argument.call`的作用相同。这与此类似，只是请求的视图的输出取代了块。这相当于说*总是将请求的内容包裹在我里面，并将请求的内容放置在这个位置*。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you already know Rails, you know that there are other options for solving
    this problem, such as using partials, which approach the problem from the bottom
    up, rather than from the top down. Read more at [http://wiki.rubyonrails.org/rails/pages/Partials](http://wiki.rubyonrails.org/rails/pages/Partials)
    if you’re interested*.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你已经了解Rails，你知道还有其他解决这个问题的方法，比如使用部分视图，这种方法是从底部向上解决问题，而不是从顶部向下。如果你感兴趣，可以阅读[http://wiki.rubyonrails.org/rails/pages/Partials](http://wiki.rubyonrails.org/rails/pages/Partials)*。'
- en: Using CSS
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CSS
- en: The `master.css` stylesheet is used throughout the application, and each action
    automatically includes a stylesheet with the same name (see ❷ and ❸ in `app/views/layouts/album.rhtml`
    in [Dissecting the Album Controller’s Layout](ch13s02.html#dissecting_the_album_controllers_layout
    "Dissecting the Album Controller’s Layout") on page 256). When we browse with
    the `show` View, we will make use of the `show.css` stylesheet, for example. If
    you’re curious about CSS, you can learn more at websites like [http://csszengarden.com](http://csszengarden.com).
    The stylesheets `master.css, public.css`, and `index.css` are available for download
    at this book’s website.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`master.css` 样式表在整个应用程序中都被使用，每个动作都会自动包含一个与同名的样式表（参见[Dissecting the Album Controller’s
    Layout](ch13s02.html#dissecting_the_album_controllers_layout "Dissecting the Album
    Controller’s Layout")中`app/views/layouts/album.rhtml`的❷和❸）。当我们使用`show`视图浏览时，我们会使用`show.css`样式表，例如。如果你对CSS感兴趣，你可以在像[http://csszengarden.com](http://csszengarden.com)这样的网站上了解更多。样式表`master.css,
    public.css`和`index.css`可以在本书的网站上下载。'
- en: '* * *'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[37](#CHP-13-FNOTE-1)]) For example, you might want to use `%q[]` instead
    of quotation marks if the String to be defined included quotation marks; some
    programmers might simply prefer using `%q[]`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[37](#CHP-13-FNOTE-1)]) 例如，你可能想使用`%q[]`而不是引号，如果要定义的字符串包含了引号；一些程序员可能只是更喜欢使用`%q[]`。
- en: Using the Application
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用程序
- en: At this point, we have a photo album application, as well as a decent understanding
    of how its component parts are organized and how they work, both individually
    and as part of the whole. Now let’s take a look at this app in action, starting
    by opening it in a web browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一个照片专辑应用程序，以及对其组件部分如何组织以及它们如何单独工作以及作为整体一部分工作的相当不错的理解。现在让我们看看这个应用程序的实际运行情况，首先在网页浏览器中打开它。
- en: '[Figure 13-2](ch13s03.html#browsing_the_album_controller "Figure 13-2. Browsing
    the Album Controller") shows how the default action of the Album Controller looks
    when I view it with the Epiphany web browser. Its appearance should differ only
    trivially in other graphical browsers, like Firefox or Internet Explorer. [Figure 13-3](ch13s03.html#showing_the_first_image_in_the_album_con
    "Figure 13-3. Showing the first image in the Album Controller") shows the appearance
    of the first image, as displayed by the `show` View of the Album Controller.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](ch13s03.html#browsing_the_album_controller "图 13-2. 浏览专辑控制器") 展示了当使用
    Epiphany 网络浏览器查看时，专辑控制器的默认动作的外观。在其他图形浏览器（如 Firefox 或 Internet Explorer）中，其外观应该只有细微的差异。[图
    13-3](ch13s03.html#showing_the_first_image_in_the_album_con "图 13-3. 显示专辑控制器中的第一张图片")
    展示了专辑控制器 `show` 视图显示的第一张图片的外观。'
- en: Figures [Figure 13-4](ch13s03.html#browsing_the_rss_images_in_the_feed_cont
    "Figure 13-4. Browsing the RSS images in the Feed Controller with Epiphany") and
    [Figure 13-5](ch13s03.html#browsing_with_the_akregator_rss_reader "Figure 13-5. Browsing
    with the Akregator RSS reader") show the appearance of the `images` View of the
    Feed Controller. [Figure 13-4](ch13s03.html#browsing_the_rss_images_in_the_feed_cont
    "Figure 13-4. Browsing the RSS images in the Feed Controller with Epiphany") shows
    it (again) in Epiphany, while [Figure 13-5](ch13s03.html#browsing_with_the_akregator_rss_reader
    "Figure 13-5. Browsing with the Akregator RSS reader") shows it in Akregator,
    which is a program designed specifically for viewing RSS feeds.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [图 13-4](ch13s03.html#browsing_the_rss_images_in_the_feed_cont "图 13-4. 使用
    Epiphany 浏览 Feed 控制器中的 RSS 图片") 和 [图 13-5](ch13s03.html#browsing_with_the_akregator_rss_reader
    "图 13-5. 使用 Akregator RSS 阅读器浏览") 展示了 Feed 控制器的 `images` 视图的外观。图 [图 13-4](ch13s03.html#browsing_the_rss_images_in_the_feed_cont
    "图 13-4. 使用 Epiphany 浏览 Feed 控制器中的 RSS 图片") 再次展示了它在 Epiphany 浏览器中的样子，而 [图 13-5](ch13s03.html#browsing_with_the_akregator_rss_reader
    "图 13-5. 使用 Akregator RSS 阅读器浏览") 展示了它在 Akregator 中的样子，Akregator 是一个专门设计用于查看 RSS
    源的程序。
- en: '![Browsing the Album Controller](httpatomoreillycomsourcenostarchimages686160.png.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![浏览专辑控制器](httpatomoreillycomsourcenostarchimages686160.png.jpg)'
- en: Figure 13-2. Browsing the Album Controller
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-2. 浏览专辑控制器
- en: '![Showing the first image in the Album Controller](httpatomoreillycomsourcenostarchimages686146.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![显示专辑控制器中的第一张图片](httpatomoreillycomsourcenostarchimages686146.png.jpg)'
- en: Figure 13-3. Showing the first image in the Album Controller
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-3. 显示专辑控制器中的第一张图片
- en: '![Browsing the RSS images in the Feed Controller with Epiphany](httpatomoreillycomsourcenostarchimages686186.png.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Epiphany 浏览 Feed 控制器中的 RSS 图片](httpatomoreillycomsourcenostarchimages686186.png.jpg)'
- en: Figure 13-4. Browsing the RSS images in the Feed Controller with Epiphany
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-4. 使用 Epiphany 浏览 Feed 控制器中的 RSS 图片
- en: '![Browsing with the Akregator RSS reader](httpatomoreillycomsourcenostarchimages686174.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Akregator RSS 阅读器浏览](httpatomoreillycomsourcenostarchimages686174.png.jpg)'
- en: Figure 13-5. Browsing with the Akregator RSS reader
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13-5. 使用 Akregator RSS 阅读器浏览
- en: Learning More About Rails
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多关于 Rails
- en: This chapter has only scratched the surface of Rails. I’ve barely described
    some of the Helper methods (like `image_tag` and `link_to`), and I haven’t even
    touched on topics like ActiveRecord’s ability to create relationships between
    multiple Models, Unit Testing within Rails, forms within Rails, user creation
    and authentication, session handling, and much more. Even so, this is already
    the longest chapter in a Ruby book that tried very hard to be about Ruby, as distinct
    from Rails—and I even had to describe the basic anatomy of a Rails application
    in the chapter before this one. There’s a lot to learn in Rails, and you can always
    read more at [http://rubyonrails.org](http://rubyonrails.org). Just don’t forget
    that Ruby has a lot to offer apart from Rails, too, as I hope the other chapters
    in this book have shown.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是触及了 Rails 的表面。我仅仅描述了一些 Helper 方法（如 `image_tag` 和 `link_to`），甚至还没有涉及到 ActiveRecord
    在多个模型之间创建关系、Rails 中的单元测试、Rails 中的表单、用户创建和认证、会话处理等话题。即便如此，这已经是试图专注于 Ruby 而非 Rails
    的 Ruby 书籍中最长的章节——而且我甚至不得不在上一章中描述 Rails 应用程序的基本结构。在 Rails 中有很多东西要学习，你可以在 [http://rubyonrails.org](http://rubyonrails.org)
    上阅读更多内容。只是不要忘记，Ruby 除了 Rails 之外还有很多东西可以提供，正如本书的其他章节所展示的那样。
- en: Chapter Recap
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节回顾
- en: What was new in this chapter?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有哪些新内容？
- en: Using Rails with MySQL
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rails 与 MySQL
- en: Adding data with migration files
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迁移文件添加数据
- en: Creating a Model
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型
- en: Creating multi-View Controllers
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多视图控制器
- en: Adding methods to Models and Controllers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型和控制器添加方法
- en: The ApplicationController superclass
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ApplicationController 超类
- en: Using Helpers
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用助手
- en: The ApplicationHelper module
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ApplicationHelper 模块
- en: MVC as it relates to Controllers and Helpers
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 与控制器和助手的关系
- en: Creating Views as .rhtml files
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视图创建为 .rhtml 文件
- en: Doing common JavaScript with Rails’ built-in Helper methods
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Rails 内置的 Helper 方法进行常见的 JavaScript 操作
- en: Using layouts and incorporating the results of [view].rhtml within them
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布局并整合 [view].rhtml 的结果
- en: Using stylesheets modularized by View type
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按视图类型模块化的样式表
- en: 'I hope this book has given you some useful information about coding in Ruby.
    I’ve tried to play to what I see as the language’s greatest strengths: readability,
    a high level of abstraction (and great ease in extending that abstraction even
    higher), internal consistency, and conceptual elegance. All of these characteristics
    of Ruby remain, whether or not you’re working within Rails. If you do find yourself
    using Rails, don’t forget that along with `each`, you can still use `map` and
    `inject`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书已经给你提供了一些关于 Ruby 编程的有用信息。我试图发挥我认为该语言最大的优势：可读性、高度抽象（以及扩展这种抽象到更高层次的极大便利性）、内部一致性，以及概念上的优雅。所有这些
    Ruby 的特性，无论你是否在 Rails 中工作，都依然存在。如果你发现自己正在使用 Rails，不要忘记，除了 `each` 之外，你仍然可以使用 `map`
    和 `inject`。
- en: Thanks for reading.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读。
