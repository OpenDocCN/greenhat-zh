- en: Chapter 3. PROVISIONING DOMUS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。配置DOMU
- en: '*You can suck Linux right out of the air, as it were, by downloading the right
    files and putting them in the right places, but there probably are not more than
    a few hundred people in the world who could create a functioning Linux system
    in that way*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过下载正确的文件并将它们放在正确的位置，就像是从空气中吸取Linux一样，但可能世界上只有几百人能够以这种方式创建一个功能齐全的Linux系统*。'
- en: —Neal Stephenson, *In the Beginning Was the Command Line*![image with no caption](httpatomoreillycomsourcenostarchimages333191.png.jpg)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ——尼尔·斯蒂芬森，《命令行起源》![无标题图片](httpatomoreillycomsourcenostarchimages333191.png.jpg)
- en: Up until now, we've focused on administering the dom0, leaving the specifics
    of domU creation up to the `virt-install` tool. However, you'll probably need
    to build a domU image from scratch on occasion. There are plenty of good reasons
    for this—perhaps you want an absolutely minimal Linux environment to use as a
    base for virtual private server (VPS) hosting setups. Maybe you're deploying some
    custom application—a *server appliance*—using Xen. It might just seem like a good
    way to keep systems patched. Possibly you need to create Xen instances without
    the benefit of a network connection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于管理dom0，将domU创建的具体细节留给`virt-install`工具。然而，你有时可能需要从头开始构建domU镜像。这样做有很多原因——也许你想要一个绝对最小的Linux环境，用作虚拟专用服务器（VPS）托管设置的基准。也许你正在使用Xen部署一些自定义应用程序——一个*服务器设备*。这可能只是保持系统更新的好方法。可能你需要在没有网络连接的情况下创建Xen实例。
- en: Just as there are many reasons to want custom filesystem images, there are many
    ways to make the images. We'll give detailed instructions for some that we use
    frequently, and briefly mention some others, but it would be impossible to provide
    an exhaustive list (and very boring besides). The goal of this chapter is to give
    you an idea of the range of options you have in provisioning domU filesystems,
    a working knowledge of the principles, and just enough step-by-step instruction
    to get familiar with the processes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有许多原因想要定制的文件系统镜像一样，也有许多方法可以制作这些镜像。我们将详细说明我们经常使用的某些方法，并简要提及一些其他方法，但提供详尽的列表是不可能的（而且会很无聊）。本章的目标是给你一个关于配置domU文件系统选项的范围、对原理的熟练掌握，以及足够的逐步指导，以便熟悉这些流程。
- en: A Basic DomU Configuration
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本DomU配置
- en: 'All of the examples that we''re presenting here should work with a basic—in
    fact, downright skeletal—domU config file. Something along the lines of this should
    work:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的所有示例都应该与一个基本的——实际上，可以说是骨架般的——domU配置文件兼容。以下这样的配置应该可以工作：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This specifies a kernel, a network interface, and a disk, and lets Xen use defaults
    for everything else. Tailor the variables, such as volume group and kernel name,
    to your site. As we mention elsewhere, we recommend including other variables,
    such as a MAC and IP address, but we'll omit them during this chapter for clarity
    so we can focus on creating domU images.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了一个内核、一个网络接口和一个磁盘，并允许Xen使用默认值来处理其他所有事情。根据你的站点调整变量，例如卷组和内核名称。正如我们在其他地方提到的，我们建议包括其他变量，例如MAC地址和IP地址，但为了清晰起见，我们将在本章中省略它们，以便我们能够专注于创建domU镜像。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This doesn''t include a ramdisk. Either add a* *`ramdisk=`* *line or include*
    *`xenblk`* *(and* *`xennet`* *if you plan on accessing the network before modules
    are available) in your kernel. When we compile our own kernels, we usually include
    the* *`xenblk`* *and* *`xennet`* *drivers directly in the kernel. We only use
    a ramdisk to satisfy the requirements of the distro kernels*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*这不包括ramdisk。你可以添加一个* *`ramdisk=`* *行，或者包括* *`xenblk`* *(如果你计划在模块可用之前访问网络)和*
    *`xennet`* *。当我们编译自己的内核时，我们通常直接在内核中包含* *`xenblk`* *和* *`xennet`* *驱动程序。我们只使用ramdisk来满足发行版内核的要求*。'
- en: 'If you''re using a modular kernel, which is very likely, you''ll also need
    to ensure that the kernel has a matching set of modules that it can load from
    the domU filesystem. If you''re booting the domU using the same kernel as the
    dom0, you can copy over the modules like this (if the domU image is mounted on
    */mnt*):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是模块化内核，这非常可能，你还需要确保内核有一个与之匹配的模块集，可以从domU文件系统中加载。如果你使用与dom0相同的内核引导domU，你可以像这样复制模块（如果domU镜像挂载在*/mnt*）：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this command only works if the domU kernel is the same as the dom0
    kernel! Some install procedures will install the correct modules automatically;
    others won't. No matter how you create the domU, remember that modules need to
    be accessible from the domU, even if the kernel lives in the dom0\. If you have
    trouble, make sure that the kernel and module versions match, either by booting
    from a different kernel or copying in different modules.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此命令仅在domU内核与dom0内核相同的情况下才有效！某些安装程序会自动安装正确的模块；而其他则不会。无论你如何创建domU，都要记住，模块需要从domU中可访问，即使内核位于dom0中。如果你遇到麻烦，请确保内核和模块版本匹配，可以通过从不同的内核引导或复制不同的模块来实现。
- en: Selecting a Kernel
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择内核
- en: Traditionally, one boots a domU image using a kernel stored in the dom0 filesystem,
    as in the sample config file in the last section. In this case, it's common to
    use the same kernel for domUs and the dom0\. However, this can lead to trouble—one
    distro's kernels may be too specialized to work properly with another distro.
    We recommend either using the proper distro kernel, copying it into the dom0 filesystem
    so the domain builder can find it, or compiling your own generic kernel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，人们使用存储在dom0文件系统中的内核引导domU镜像，就像上一节中的示例配置文件一样。在这种情况下，通常使用与domUs和dom0相同的内核。然而，这可能会导致问题——一个发行版的内核可能过于专业化，无法与另一个发行版正确工作。我们建议使用适当的发行版内核，将其复制到dom0文件系统中，以便域构建者可以找到它，或者编译自己的通用内核。
- en: Another possible choice is to download Xen's binary distribution, which includes
    precompiled domU kernels, and extracting an appropriate domU kernel from that.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的选择是下载Xen的二进制发行版，其中包含预编译的domU内核，并从中提取适当的domU内核。
- en: 'Alternatively (and this is the option that we usually use when dealing with
    distros that ship Xen-aware kernels), you can bypass the entire problem of kernel
    selection and use PyGRUB to boot the distro''s own kernel from within the domU
    filesystem. For more details on PyGRUB, see [Chapter 7](ch07.html "Chapter 7. HOSTING
    UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES"). PyGRUB also makes it more
    intuitive to match modules to kernels by keeping both the domU kernel and its
    corresponding modules in the domU.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（当我们处理带有Xen感知内核的发行版时，我们通常使用这个选项），你可以绕过整个内核选择的问题，并使用PyGRUB在domU文件系统中引导发行版的自身内核。有关PyGRUB的更多详细信息，请参阅[第7章](ch07.html
    "第7章。在XEN下托管不受信任的用户：来自战壕的经验")。PyGRUB还通过在domU中保留domU内核及其相应模块，使得将模块与内核匹配更加直观。
- en: Quick-and-Dirty Install via tar
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过tar快速安装
- en: Let's start by considering the most basic install method possible, just to get
    an idea of the principles involved. We'll generate a root filesystem by copying
    files out of the dom0 (or an entirely separate physical machine) and into the
    domU. This approach copies out a filesystem known to work, requires no special
    tools, and is easy to debug. However, it's also likely to pollute the domU with
    a lot of unnecessary stuff from the source system and is kind of a lot of work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先考虑最基本可能的安装方法，以便了解涉及的原则。我们将通过从dom0（或一个完全独立的物理机器）复制文件到domU来生成一个根文件系统。这种方法复制了一个已知可以工作的文件系统，不需要特殊工具，并且易于调试。然而，这也可能导致domU被来自源系统的大量不必要的东西污染，而且工作量也相当大。
- en: 'A good set of commands for this "cowboy" approach might be:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种“牛仔”方法，可能有一组好的命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Do all this as root*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有这些操作都需要以root身份执行*。'
- en: These commands, in order, map the backing file to a virtual device in the dom0,
    create a filesystem on that device, mount the filesystem, and tar up the dom0
    root directory while omitting */home*, */mnt*, */tmp*, */proc*, */sys*, and */var*.
    The output from this `tar` command then goes to a complementary `tar` used to
    extract the file in */mnt*. Finally, we make some directories that the domU will
    need after it boots. At the end of this process, we have a self-contained domU
    in *duncan.img*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，这些命令将后端文件映射到dom0中的虚拟设备，在该设备上创建一个文件系统，挂载该文件系统，并使用tar将dom0根目录打包，同时排除*/home*、*/mnt*、*/tmp*、*/proc*、*/sys*和*/var*。然后，此`tar`命令的输出将用于辅助`tar`，用于在*/mnt*中提取文件。最后，我们创建一些domU启动后需要的目录。在此过程结束时，我们在*duncan.img*中有一个自包含的domU。
- en: Why This Is Not the Best Idea
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这不是最佳方案
- en: The biggest problem with the cowboy approach, apart from its basic inelegance,
    is that it copies a lot of unnecessary stuff with no easy way to clear it out.
    When the domU is booted, you could use the package manager to remove things or
    just delete files by hand. But that's work, and we are all about avoiding work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其基本的不优雅之外，牛仔式方法的最大问题是它复制了大量的不必要的东西，而且没有简单的方法来清除它们。当domU启动时，您可以使用包管理器来删除东西，或者手动删除文件。但这是一项工作，而我们都在避免工作。
- en: Stuff to Watch Out For
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要留意的事项
- en: 'There are some things to note:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: You *must* `mkdir /sys` and `/proc` or else things will not work properly.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您*必须*创建`mkdir /sys`和`/proc`，否则事情将无法正常工作。
- en: The issue here is that the Linux startup process uses */sys* and */proc* to
    discover and configure hardware—if, say, */proc/mounts* doesn't exist, the boot
    scripts will become extremely annoyed.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的问题是Linux启动过程使用*/sys*和*/proc*来发现和配置硬件——如果，比如说，*/proc/mounts*不存在，引导脚本将变得非常烦恼。
- en: You may need to `mknod /dev/xvda b 220 0`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要`mknod /dev/xvda b 220 0`。
- en: '*/dev/xvd* is the standard name for Xen virtual disks, by analogy with the
    *hd* and *sd* device nodes. The first virtual disk is */dev/xvda*, which can be
    partitioned into */dev/xvda1*, and so on. The command'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*/dev/xvd*是Xen虚拟磁盘的标准名称，类似于*hd*和*sd*设备节点。第一个虚拟磁盘是*/dev/xvda*，它可以分区为*/dev/xvda1*，依此类推。命令'
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: creates the node */dev/xvda* as a block device (b) with major number 220 (the
    number reserved for Xen VBDs) and minor number 0 (because it's *xvda*—the first
    such device in the system).
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建节点*/dev/xvda*作为主设备号为220（为Xen VBDs保留的数字）和次设备号为0（因为它叫做*xvda*——系统中的第一个此类设备）的块设备（b）。
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*On most modern Linux systems, udev makes this unnecessary*.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*在大多数现代Linux系统中，udev使得这一点变得不再必要*。'
- en: You may need to edit */etc/inittab* and */etc/securettys* so that */dev/xvc0*
    works as the console and has a proper `getty`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能需要编辑*/etc/inittab*和*/etc/securettys*，以便*/dev/xvc0*作为控制台工作，并具有适当的`getty`。
- en: 'We''ve noticed this problem only with Red Hat''s kernels: for regular XenSource
    kernels (at least through 3.1) the default `getty` on tty0 should work without
    further action on your part. If it doesn''t, read on!'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们仅在Red Hat的内核中发现了这个问题：对于常规的XenSource内核（至少到3.1版本），tty0上的默认`getty`应该无需您进一步操作即可正常工作。如果它不起作用，请继续阅读！
- en: The term *console* is something of a holdover from the days of giant time-sharing
    machines, when the system operator sat at a dedicated terminal called the *system
    console*. Nowadays, the console is a device that receives system administration
    messages—usually a graphics device, sometimes a serial console.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 术语*控制台*是从大型分时机器时代遗留下来的，当时系统操作员坐在一个称为*系统控制台*的专用终端上。如今，控制台是一个接收系统管理消息的设备——通常是图形设备，有时是串行控制台。
- en: 'In the Xen case, all output goes to the Xen virtual console, `xvc0`. The `xm
    console` command attaches to this device with help from `xenconsoled`. To log
    in to it, Xen''s virtual console must be added to */etc/inittab* so that `init`
    knows to attach a `getty`.^([[17](#ftn.CHP-3-FNOTE-1)]) Do this by adding a line
    like the following:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Xen的情况下，所有输出都发送到Xen虚拟控制台`xvc0`。`xm console`命令通过`xenconsoled`的帮助连接到这个设备。要登录，Xen的虚拟控制台必须添加到*/etc/inittab*中，以便`init`知道连接一个`getty`。^([[17](#ftn.CHP-3-FNOTE-1)])
    通过添加如下类似的行来完成此操作：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (As with all examples in books, don't take this construction too literally!
    If you have a differently named `getty` binary, for example, you will definitely
    want to use that instead.)
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （与书中所有示例一样，不要过于字面地理解这个结构！例如，如果您有一个不同名称的`getty`二进制文件，您肯定希望使用那个而不是这个。）
- en: You might also, depending on your policy regarding root logins, want to add
    */dev/xvc0* to */etc/securetty* so that root will be able to log in on it. Simply
    append a line containing the device name, *xvc0*, to the file.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您对root登录策略的规定，您可能还需要将*/dev/xvc0*添加到*/etc/securetty*中，以便root能够通过它登录。只需在文件中添加一行包含设备名称*xvc0*的行即可。
- en: '* * *'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[17](#CHP-3-FNOTE-1)]) `getty` gives you a login prompt. What, you didn't
    think they showed up by magic, did you?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#CHP-3-FNOTE-1)]) `getty`为您提供一个登录提示。你以为它们是凭空出现的吗，不是吗？
- en: Using the Package Management System with an Alternate Root
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有备用根的包管理系统
- en: Another way to obtain a domU image would be to just run the setup program for
    your distro of choice and instruct it to install to the mounted domU root. The
    disadvantage here is that most setup programs expect to be installed on a real
    machine, and they become surly and uncooperative when forced to deal with paravirtualization.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 获取domU镜像的另一种方法是通过运行您选择的发行版的设置程序，并指示它安装到挂载的domU根目录。这里的缺点是，大多数设置程序都期望在真实机器上安装，并且当被迫处理虚拟化时，它们会变得固执和不可合作。
- en: Nonetheless, this is a viable process for most installers, including both RPM
    and Debian-based distros. We'll describe installation using both Red Hat's and
    Debian's tools.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这对于大多数安装程序来说都是一个可行的过程，包括基于RPM和Debian的发行版。我们将描述使用Red Hat和Debian的工具进行安装。
- en: Red Hat, CentOS, and Other RPM-Based Distros
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红帽、CentOS和其他基于RPM的发行版
- en: On Red Hat–derived systems, we treat this as a *package* installation, rather
    than a *system installation*. Thus, rather than using `anaconda`, the system installer,
    we use `yum`, which has an installation mode suitable for this sort of thing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Red Hat的系统上，我们将此视为*包安装*，而不是*系统安装*。因此，我们不是使用系统安装程序`anaconda`，而是使用`yum`，它具有适合此类操作的安装模式。
- en: First, it's easiest to make sure that SELinux is disabled or nonenforcing because
    its extended permissions and policies don't work well with the installer.^([[18](#ftn.CHP-3-FNOTE-2)])
    The quickest way to do this is to issue `echo 0 >/selinux/enforce`. A more permanent
    solution would be to boot with `selinux=0` on the kernel command line.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的方法是确保SELinux被禁用或非强制执行，因为它的扩展权限和策略与安装程序不兼容。最快的方法是执行`echo 0 >/selinux/enforce`。一个更永久的方法是在内核命令行上使用`selinux=0`来引导。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Specify kernel parameters as a space-separated list on the "module" line that
    loads the Linux kernel—either in* /boot/grub/menu.lst *or by pushing* e *at the
    GRUB menu*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*在加载Linux内核的“模块”行上指定内核参数作为空格分隔的列表——无论是在* /boot/grub/menu.lst *中还是在GRUB菜单中按*
    e *键*。'
- en: 'When that''s done, mount your target domU image somewhere appropriate. Here
    we create the logical volume *malcom* in the volume group *scotland* and mount
    it on */mnt*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将目标domU镜像挂载到适当的位置。在这里，我们在卷组`*scotland*`中创建逻辑卷`*malcom*`，并将其挂载到`*/mnt*`：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create some vital directories, just as in the `tar` example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些重要的目录，就像在`tar`示例中一样：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make a basic `fstab` (you can just copy the one from dom0 and edit the root
    device as appropriate—with the sample config file mentioned earlier, you would
    use */dev/sda*):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基本的`fstab`（您可以直接从dom0复制并适当编辑根设备——使用前面提到的示例配置文件，您将使用*/dev/sda*）：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fix *modprobe.conf*, so that the kernel knows where to find its device drivers.
    (This step isn't technically necessary, but it enables `yum upgrade` to properly
    build a new initrd when the kernel changes—handy if you're using PyGRUB.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 修复*modprobe.conf*，以便内核知道其设备驱动程序的位置。（这一步在技术上不是必需的，但它使得在内核更改时`yum upgrade`能够正确构建新的initrd——如果您使用PyGRUB，这将很有用。）
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point you'll need an RPM that describes the software release version
    and creates the `yum` configuration files—we installed CentOS 5, so we used `centos-release-5.el5.centos.i386.rpm`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你需要一个描述软件发布版本并创建`yum`配置文件的RPM包——我们安装了CentOS 5，所以我们使用了`centos-release-5.el5.centos.i386.rpm`。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Normally, the CentOS release RPM includes the minor version number, but it is
    hard to find old versions. See the *README.prgmr* file in the same directory for
    a full explanation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，CentOS发布RPM包括次要版本号，但很难找到旧版本。请参阅同一目录下的`*README.prgmr*`文件以获取完整说明。
- en: 'Next we install `yum` under the new install tree. If we don''t do this before
    installing other packages, `yum` will complain about transaction errors:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在新的安装树中安装`yum`。如果我们在此安装其他包之前不这样做，`yum`将抱怨事务错误：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that the directory has been appropriately populated, we can use `yum` to
    finish the install.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目录已经适当填充后，我们可以使用`yum`来完成安装。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And that's really all there is to it. Create a domU config file as normal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部内容。像往常一样创建一个domU配置文件。
- en: Debootstrap with Debian and Ubuntu
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Debian和Ubuntu的Debootstrap
- en: 'Debootstrap is quite a bit easier. Create a target for the install (using LVM
    or a flat file), mount it, and then use debootstrap to install a base system into
    that directory. For example, to install Debian Etch on an x68_64 machine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Debootstrap要容易得多。为安装创建一个目标（使用LVM或平面文件），挂载它，然后使用debootstrap在该目录中安装基本系统。例如，在x68_64机器上安装Debian
    Etch：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the `--include=` option. Because Xen's networking requires the hot-plug
    system, the domU must include a working install of udev with its support scripts.
    (We've also included SSH, just for convenience and to demonstrate the syntax for
    multiple items.) If you are on an i386 platform, add libc6-xen to the include
    list. Finally, to ensure that we have a compatible kernel and module set, we add
    a suitable kernel to the `include=` list. We use `linux-image-xen-amd64`. Pick
    an appropriate kernel for your hardware.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--include=` 选项。因为 Xen 的网络需要热插拔系统，domU 必须包含一个带有支持脚本的 udev 的工作安装。（我们还包括了 SSH，只是为了方便并演示多个项目的语法。）如果你在
    i386 平台上，请将 libc6-xen 添加到包含列表中。最后，为了确保我们有兼容的内核和模块集，我们向 `include=` 列表中添加一个合适的内核。我们使用
    `linux-image-xen-amd64`。为你的硬件选择一个合适的内核。
- en: 'If you want to use PyGRUB, create */mnt/etc/modules* before you run `debootstrap`,
    and put in that file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 PyGRUB，在运行 `debootstrap` 之前，创建 */mnt/etc/modules* 文件，并将以下内容放入该文件中：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, create a */mnt/boot/grub/menu.lst* file as for a physical machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建一个 */mnt/boot/grub/menu.lst* 文件，就像在物理机器上做的那样。
- en: If you're not planning to use PyGRUB, make sure that an appropriate Debian kernel
    and ramdisk are accessible from the dom0, or make sure that modules matching your
    planned kernel are available within the domU. In this case, we'll copy the sdom0
    kernel modules into the domU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有计划使用 PyGRUB，请确保从 dom0 可以访问适当的 Debian 内核和 ramdisk，或者确保在 domU 中有与你的计划内核匹配的模块。在这种情况下，我们将把
    sdom0 内核模块复制到 domU。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When that''s done, copy over `/etc/fstab` to the new system, editing it if
    necessary:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切都完成后，将 `/etc/fstab` 复制到新系统，如有必要进行编辑：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Renaming Network Devices
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名网络设备
- en: Debian, like many systems, uses udev to tie `eth0` and `eth1` to consistent
    physical devices. It does this by assigning the device name (`ethX`) based on
    the MAC address of the Ethernet device. It will do this during debootstrap—this
    means that it ties `eth0` to the MAC of the box you are running `debootstrap`
    on. In turn, the domU's Ethernet interface, which presumably has a different MAC
    address, will become `eth1`.^([[19](#ftn.CHP-3-FNOTE-3)]) You can avoid this by
    removing */mnt/etc/udev/rules.d/z25_persistent-net.rules*, which contains the
    stored mappings between MAC addresses and device names. That file will be recreated
    next time you reboot. If you only have one interface, it might make sense to remove
    the file that generates it, */mnt/etc/udev/rules.d/z45_persistent-net-generator.rules*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Debian，像许多系统一样，使用 udev 将 `eth0` 和 `eth1` 绑定到一致的物理设备。它是通过根据以太网设备的 MAC 地址分配设备名称（`ethX`）来实现的。这将在
    debootstrap 过程中完成——这意味着它会将 `eth0` 绑定到你运行 `debootstrap` 的机器的 MAC 地址。反过来，domU 的以太网接口，假设有一个不同的
    MAC 地址，将变成 `eth1`。^([[19](#ftn.CHP-3-FNOTE-3)]) 你可以通过删除 */mnt/etc/udev/rules.d/z25_persistent-net.rules*
    文件来避免这种情况，该文件包含 MAC 地址和设备名称之间的存储映射。下次重启时，该文件将被重新创建。如果你只有一个接口，可能需要删除生成该文件的文件，即
    */mnt/etc/udev/rules.d/z45_persistent-net-generator.rules*。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, unmount the install root. Your system should then essentially work.
    You may want to change the hostname and edit */etc/inittab* within the domU's
    filesystem, but these are purely optional steps.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，卸载安装根。此时，你的系统应该基本上可以工作了。你可能想要更改主机名并编辑 domU 文件系统中的 */etc/inittab*，但这些步骤完全是可选的。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Test the new install by creating a config file as previously described (say,
    */etc/xen/banquo*) and issuing:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个配置文件来测试新的安装，如之前所述（例如，*/etc/xen/banquo*）并执行以下命令：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '* * *'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[18](#CHP-3-FNOTE-2)]) Although we don't really approve of the tendency to
    disable SELinux at the first hint of trouble, we decided to take the path of least
    resistance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#CHP-3-FNOTE-2)]) 虽然我们并不赞同在遇到麻烦的第一时间就禁用 SELinux 的趋势，但我们决定走阻力最小的路线。
- en: ^([[19](#CHP-3-FNOTE-3)]) Or another device, depending on how many Ethernet
    devices the original machine had.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#CHP-3-FNOTE-3)]) 或者另一个设备，具体取决于原始机器有多少个以太网设备。
- en: QEMU Install
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QEMU 安装
- en: Our favorite way to create the domU image—the way that most closely simulates
    a real machine—is probably to install using QEMU and then take the installed filesystem
    and use that as your domU root filesystem. This allows you, the installer, to
    leverage your years of experience installing Linux. Because it's installing in
    a virtual machine as strongly partitioned as Xen's, the install program is very
    unlikely to do anything surprising and even more unlikely to interact badly with
    the existing system. QEMU also works equally well with all distros and even non-Linux
    operating systems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最喜欢的创建 domU 镜像的方法——最接近真实机器的方法——可能是使用 QEMU 安装，然后使用已安装的文件系统作为你的 domU 根文件系统。这允许你，安装者，利用你多年安装
    Linux 的经验。因为它是安装在像 Xen 一样强分区的虚拟机中，所以安装程序不太可能做任何令人惊讶的事情，更不可能与现有系统发生不良交互。QEMU 也与所有发行版以及非
    Linux 操作系统一样工作得很好。
- en: QEMU does have the disadvantage of being slow. Because KQEMU (the kernel acceleration
    module) isn't compatible with Xen, you'll have to fall back to software-only full
    emulation. Of course, you can use this purely for an initial image-creation step
    and then copy the pristine disk images around as needed, in which case the speed
    penalty becomes less important.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU 的确存在速度慢的缺点。因为 KQEMU（内核加速模块）与 Xen 不兼容，你将不得不退回到仅软件的全仿真。当然，你可以仅为此初始镜像创建步骤使用它，然后根据需要复制原始磁盘镜像，在这种情况下，速度惩罚变得不那么重要。
- en: QEMU'S RELATION TO XEN
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU 与 Xen 的关系
- en: 'You may already have noted that QEMU gets mentioned fairly often in connection
    with Xen. There''s a good reason for this: The two projects complement each other.
    Although QEMU is a *pure*, or *classic*, full emulator, there''s some overlap
    in QEMU''s and Xen''s requirements. For example, Xen can use QCOW images for its
    disk emulation, and it uses QEMU fully virtualized drivers when running in hardware
    virtualization mode. QEMU also furnishes some code for the hardware virtualization
    built into the Linux kernel, KVM (kernel virtual machine)^([[20](#ftn.CHP-3-FNOTE-4)])
    and win4lin, on the theory that there''s no benefit in reinventing the wheel.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 QEMU 在与 Xen 相关的内容中经常被提及。这有一个很好的原因：这两个项目是互补的。尽管 QEMU 是一个 *纯* 或 *经典*
    的全仿真器，但 QEMU 和 Xen 的需求有一些重叠。例如，Xen 可以使用 QCOW 图像进行磁盘仿真，并在硬件虚拟化模式下运行时使用 QEMU 的完全虚拟化驱动程序。QEMU
    还为 Linux 内核中内置的硬件虚拟化（KVM，即内核虚拟机）和 win4lin 提供了一些代码，基于没有必要重新发明轮子的理论。
- en: Xen and QEMU aren't the same, but there's a general consensus that they complement
    each other well, with Xen more suited to high-performance production environments,
    and QEMU is aimed more at exact emulation. Xen's and QEMU's developers have begun
    sharing patches and working together. They're distinct projects, but Xen developers
    have acknowledged that QEMU "played a critical role in Xen's success."^([[21](#ftn.CHP-3-FNOTE-5)])
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Xen 和 QEMU 并不相同，但普遍认为它们很好地互补，Xen 更适合高性能的生产环境，而 QEMU 则更专注于精确仿真。Xen 和 QEMU 的开发者已经开始共享补丁并共同工作。它们是不同的项目，但
    Xen 开发者承认 QEMU “在 Xen 的成功中发挥了关键作用。”^([[21](#ftn.CHP-3-FNOTE-5)])
- en: 'This technique works by running QEMU as a pure emulator for the duration of
    the install, using emulated devices. Begin by getting and installing QEMU. Then
    run:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通过在安装期间将 QEMU 作为纯仿真器运行，使用仿真设备来实现。首先获取并安装 QEMU。然后运行：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command runs QEMU with the target device—a logical volume in this case—as
    its hard drive and the install medium as its virtual CD drive. (The Slackware
    ISO here, as always, is just an example—install whatever you like.) The `-boot
    d` option tells QEMU to boot from the emulated CD drive.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以目标设备（在这种情况下为逻辑卷）作为其硬盘驱动器，以安装介质作为其虚拟 CD 驱动器的方式运行 QEMU。（这里的 Slackware ISO
    只是一个例子——安装你喜欢的任何东西。）`-boot d` 选项告诉 QEMU 从仿真 CD 驱动器启动。
- en: Now install to the virtual machine as usual. At the end, you should have a completely
    functional domU image. Of course, you're still going to have to create an appropriate
    domU config file and handle the other necessary configuration from the dom0 side,
    but all of that is reasonably easy to automate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像往常一样将安装到虚拟机中。最后，你应该有一个完全功能的 domU 镜像。当然，你仍然需要创建适当的 domU 配置文件，并从 dom0 端处理其他必要的配置，但所有这些都相对容易自动化。
- en: 'One last caveat that bears repeating because it applies to many of these install
    methods: If the domU kernel isn''t Xen-aware, then you will have to either use
    a kernel from the dom0 or mount the domU and replace its kernel.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要注意的警告需要重复提及，因为它适用于许多这些安装方法：如果 domU 内核不是 Xen 兼容的，那么你将不得不使用 dom0 的内核，或者挂载
    domU 并替换其内核。
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[20](#CHP-3-FNOTE-4)]) Although we don't cover KVM extensively, it's another
    interesting virtualization technology. More information is available at the KVM
    web page, [http://kvm.sf.net/](http://kvm.sf.net/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[20](#CHP-3-FNOTE-4)]) 尽管我们没有广泛介绍 KVM，但它也是一种有趣的虚拟化技术。更多信息可以在 KVM 网页上找到，[http://kvm.sf.net/](http://kvm.sf.net/).
- en: ^([[21](#CHP-3-FNOTE-5)]) Liguori, Anthony, "Merging QEMU-DM upstream," [http://www.xen.org/files/xensummit_4/Liguori_XenSummit_Spring_2007.pdf](http://www.xen.org/files/xensummit_4/Liguori_XenSummit_Spring_2007.pdf).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[21](#CHP-3-FNOTE-5)]) Liguori, Anthony, "Merging QEMU-DM upstream," [http://www.xen.org/files/xensummit_4/Liguori_XenSummit_Spring_2007.pdf](http://www.xen.org/files/xensummit_4/Liguori_XenSummit_Spring_2007.pdf).
- en: virt-install—Red Hat's One-Step DomU Installer
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: virt-install—Red Hat 的单步 DomU 安装程序
- en: 'Red Hat opted to support a generic virtualization *concept* rather than a specific
    *technology*. Their approach is to wrap the virtualization in an abstraction layer,
    libvirt. Red Hat then provides support software that uses this library to take
    the place of the virtualization package-specific control software.^([[22](#ftn.CHP-3-FNOTE-6)])
    (For information on the management end of libvirt, `virt-manager`, see [Chapter 6](ch06.html
    "Chapter 6. DOMU MANAGEMENT: TOOLS AND FRONTENDS").)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat 选择支持通用的虚拟化 *概念* 而不是特定的 *技术*。他们的方法是将虚拟化封装在一个抽象层，libvirt。然后 Red Hat 提供支持软件，该软件使用这个库来替代虚拟化包特定的控制软件.^([[22](#ftn.CHP-3-FNOTE-6)])（有关
    libvirt 管理端的信息，`virt-manager`，请参阅[第 6 章](ch06.html "第 6 章。DOMU 管理：工具和前端")。）
- en: For example, Red Hat includes `virsh`, a command-line interface that controls
    virtual machines. `xm` and `virsh` do much the same thing, using very similar
    commands. The advantage of `virsh` and libvirt, however, is that the `virsh` interface
    will remain consistent if you decide to switch to another virtualization technology.
    Right now, for example, it can control QEMU and KVM in addition to Xen using a
    consistent set of commands.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Red Hat 包括 `virsh`，这是一个控制虚拟机的命令行界面。`xm` 和 `virsh` 做的事情几乎相同，使用非常相似的命令。然而，`virsh`
    和 libvirt 的优势在于，如果你决定切换到另一种虚拟化技术，`virsh` 接口将保持一致。目前，例如，它可以使用一组一致的命令控制 QEMU 和 KVM，以及
    Xen。
- en: 'The installation component of this system is `virt-install`. Like `virsh`,
    it builds on libvirt, which provides a platform-independent wrapper around different
    virtualization packages. No matter which virtualization backend you''re using,
    `virt-install` works by providing an environment for the standard network install
    method: First it asks the user for configuration information, then it writes an
    appropriate config file, makes a virtual machine, loads a kernel from the install
    medium, and finally bootstraps a network install using the standard Red Hat installer,
    `anaconda`. At this point `anaconda` takes over, and installation proceeds as
    normal.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统的安装组件是 `virt-install`。像 `virsh` 一样，它建立在 libvirt 之上，libvirt 为不同的虚拟化包提供了一个平台无关的包装。无论你使用哪种虚拟化后端，`virt-install`
    都是通过提供一个标准网络安装方法的环境来工作的：首先它会询问用户配置信息，然后它会写入适当的配置文件，创建一个虚拟机，从安装介质加载内核，并最终使用标准的
    Red Hat 安装程序 `anaconda` 引导网络安装。此时 `anaconda` 接管，安装按正常流程进行。
- en: Unfortunately, this means that `virt-install` only works with network-accessible
    Red Hat–style directory trees. (Other distros don't have the install layout that
    the installer expects.) If you're planning to standardize on Red Hat, CentOS,
    or Fedora, this is okay. Otherwise, it could be a serious problem.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这意味着 `virt-install` 只能与可网络访问的 Red Hat 风格目录树一起工作。（其他发行版没有安装布局符合安装程序期望。）如果你计划将
    Red Hat、CentOS 或 Fedora 标准化，这没问题。否则，这可能会成为一个严重问题。
- en: Although `virt-install` is usually called from within Red Hat's `virt-manager`
    GUI, it's also an independent executable that you can use manually in an interactive
    or scripted mode. Here's a sample `virt-install` session, with our inputs in bold.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `virt-install` 通常在 Red Hat 的 `virt-manager` 图形用户界面中调用，但它也是一个独立的可执行文件，你可以手动以交互式或脚本模式使用它。以下是一个
    `virt-install` 会话示例，其中我们的输入以粗体显示。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of these inputs are self-explanatory. Note that the install location can
    be *ftp://*, *http://*, *nfs*:, or an SSH-style path (*user@host:/path*). All
    of these can be local if necessary—a local FTP or local HTTP server, for example,
    is a perfectly valid source. *Graphics support* indicates whether to use the virtual
    framebuffer—it tweaks the `vfb=` line in the config file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些输入都是不言自明的。请注意，安装位置可以是*ftp://*、*http://*、*nfs*：或SSH风格的路径(*user@host:/path*)。所有这些在必要时都可以是本地的——例如，本地的FTP或本地HTTP服务器是一个完全有效的来源。*图形支持*表示是否使用虚拟帧缓冲区——它调整配置文件中的`vfb=`行。
- en: 'Here''s the config file generated from that input:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是根据输入生成的配置文件：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are some niceties about `virt-install`'s config file that we'd like to
    mention. First, note that `virt-install` accesses the disk image using the tap
    driver for improved performance. (For more details on the tap driver, see [Chapter 4](ch04.html
    "Chapter 4. STORAGE WITH XEN").)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`virt-install`的配置文件，有一些优点我们想提及。首先，请注意`virt-install`使用tap驱动程序访问磁盘镜像，以提高性能。（有关tap驱动程序的更多详细信息，请参阅[第4章](ch04.html
    "第4章。XEN的存储")。）
- en: It also exports the disk as `xvda` to the guest operating system, rather than
    as a SCSI or IDE device. The generated config file also includes a randomly generated
    MAC for each `vif`, using the `00:16:3e` prefix assigned to Xen. Finally, the
    image boots using PyGRUB, rather than specifying a kernel within the config file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将磁盘作为`xvda`导出到客户操作系统，而不是作为SCSI或IDE设备。生成的配置文件还包括为每个`vif`随机生成的MAC地址，使用分配给Xen的`00:16:3e`前缀。最后，该镜像使用PyGRUB启动，而不是在配置文件中指定内核。
- en: '* * *'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[22](#CHP-3-FNOTE-6)]) There's nothing *inherently* Red Hat–specific about
    libvirt, but Red Hat is currently driving its adoption. See [http://libvirt.org/](http://libvirt.org/)
    for more information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[22](#CHP-3-FNOTE-6)]) libvirt本身并没有什么*固有的*Red Hat特定之处，但Red Hat目前正在推动其采用。更多信息请参见[http://libvirt.org/](http://libvirt.org/)。
- en: Converting VMware Disk Images
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换VMware磁盘镜像
- en: One of the great things about virtualization is that it allows people to distribute
    *virtual appliances*—complete, ready-to-run, preconfigured OS images. VMware has
    been pushing most strongly in that direction, but with a little work, it's possible
    to use VMware's prebuilt virtual machines with Xen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化的一大优点是它允许人们分发*虚拟设备*——完整的、准备好运行、预先配置好的操作系统镜像。VMware在这方面一直推动得最为积极，但只要稍加努力，就可以使用VMware预构建的虚拟机与Xen兼容。
- en: PYGRUB, PYPXEBOOT, AND FRIENDS
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PYGRUB、PYPXEBOOT和朋友们
- en: The principle behind PyGRUB, pypxeboot, and similar programs is that they allow
    Xen's domain builder to load a kernel that isn't directly accessible from the
    dom0 filesystem. This, in turn, improves Xen's simulation of a real machine. For
    example, an automated provisioning tool that uses PXE can provision Xen domains
    without modification. This becomes especially important in the context of domU
    images because it allows the image to be a self-contained package—plop a generic
    config file on top, and it's ready to go.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PyGRUB、pypxeboot和类似程序背后的原理是，它们允许Xen的域构建器加载一个无法直接从dom0文件系统中访问的内核。这反过来又提高了Xen对真实机器的模拟。例如，使用PXE的自动化配置工具可以在不修改的情况下配置Xen域。这在domU镜像的上下文中尤为重要，因为它允许镜像成为一个自包含的包——在顶层放置一个通用的配置文件，就可以立即使用。
- en: 'Both PyGRUB and pypxeboot take the place of an analogous utility for physical
    machines: GRUB and PXEboot, respectively. Both are emulations written in Python,
    specialized to work with Xen. Both acquire the kernel from a place where the ordinary
    loader would be unable to find it. And both can help you, the hapless Xen administrator,
    in your day-to-day life.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PyGRUB和pypxeboot分别取代了物理机的类似实用程序：GRUB和PXEboot。两者都是用Python编写的仿真程序，专门用于与Xen一起工作。两者都能从普通加载器无法找到的地方获取内核。而且两者都可以帮助你在日常工作中，作为不幸的Xen管理员。
- en: 'For more notes on setting up PyGRUB, see [Chapter 7](ch07.html "Chapter 7. HOSTING
    UNTRUSTED USERS UNDER XEN: LESSONS FROM THE TRENCHES"). For more on pypxeboot,
    see [Installing pypxeboot](ch03s08.html#installing_pypxeboot "Installing pypxeboot")
    on [Installing pypxeboot](ch03s08.html#installing_pypxeboot "Installing pypxeboot").'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置PyGRUB的更多说明，请参阅[第7章](ch07.html "第7章。在XEN下托管不受信任的用户：来自战壕的经验教训")。有关pypxeboot的更多信息，请参阅[安装pypxeboot](ch03s08.html#installing_pypxeboot
    "安装pypxeboot")。[安装pypxeboot](ch03s08.html#installing_pypxeboot "安装pypxeboot")。
- en: Other virtualization providers, by and large, use disk formats that do more
    than Xen's—for example, they include configuration or provide snapshots. Xen's
    approach is to leave that sort of feature to standard tools in the dom0\. Because
    Xen uses open formats and standard tools whenever possible, its disk images are
    simply … filesystems.^([[23](#ftn.CHP-3-FNOTE-7)])
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其他虚拟化提供商基本上使用比Xen更复杂的磁盘格式——例如，它们包括配置或提供快照。Xen的方法是将这类功能留给dom0中的标准工具。因为Xen尽可能使用开放格式和标准工具，所以其磁盘镜像仅仅是……文件系统。[^([23](#ftn.CHP-3-FNOTE-7))]
- en: Thus, the biggest part of converting a virtual appliance to work with Xen is
    in converting over the disk image. Fortunately, `qemu-img` supports most of the
    image formats you're likely to encounter, including VMware's *.vmdk*, or Virtual
    Machine Disk format.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将虚拟设备转换为与Xen兼容的最大部分在于转换磁盘镜像。幸运的是，`qemu-img`支持您可能遇到的大多数镜像格式，包括VMware的*.vmdk*或虚拟机磁盘格式。
- en: The conversion process is pretty easy. First, get a VMware image to play with.
    There are some good ones at [http://www.vmware.com/appliances/directory/](http://www.vmware.com/appliances/directory/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 转换过程相当简单。首先，获取一个VMware镜像进行测试。在[http://www.vmware.com/appliances/directory/](http://www.vmware.com/appliances/directory/)有一些不错的选择。
- en: 'Next, take the image and use `qemu-img` to convert it to a QCOW or raw image:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，获取镜像并使用`qemu-img`将其转换为QCOW或原始镜像：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command duplicates the contents of *foo.vmdk* in a QCOW image (hence the
    `-o qcow`, for output format) called *hecate.qcow*. (*QCOW*, by the way, is a
    disk image format that originates with the QEMU emulator. It supports AES encryption
    and transparent decompression. It's also supported by Xen. More details on using
    QCOW images with Xen are in [Chapter 4](ch04.html "Chapter 4. STORAGE WITH XEN").)
    At this point you can boot it as usual, loading the kernel via PyGRUB if it's
    Xen-aware or if you're using HVM, or using a standard domU kernel from within
    the dom0 otherwise.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将*foo.vmdk*的内容复制到名为*hecate.qcow*的QCOW镜像中（因此有`-o qcow`，表示输出格式）。(*QCOW*，顺便说一下，是由QEMU仿真器起源的磁盘镜像格式。它支持AES加密和透明解压缩。它也由Xen支持。有关使用QCOW镜像与Xen的更多详细信息，请参阅[第4章](ch04.html
    "第4章。XEN的存储")。）在此阶段，您可以像通常一样引导它，如果它是Xen感知的或您正在使用HVM，则通过PyGRUB加载内核；否则，在dom0中使用标准domU内核。
- en: 'Unfortunately, this won''t generate a configuration suitable for booting the
    image with Xen. However, it should be easy to create a basic config file that
    uses the QCOW image as its root device. For example, here''s a fairly minimal
    generic config that relies on the default values to the extent possible:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会生成适合用Xen引导镜像的基本配置文件。但是，应该很容易创建一个基本的配置文件，使用QCOW镜像作为其根设备。例如，这里有一个相当简化的通用配置，尽可能依赖默认值：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we're using a kernel from the dom0 filesystem rather than loading
    the kernel from the VMware disk image with PyGRUB, as we ordinarily suggest. This
    is so we don't have to worry about whether or not that kernel works with Xen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用dom0文件系统中的内核，而不是像通常建议的那样通过PyGRUB从VMware磁盘镜像中加载内核。这样做是为了我们不必担心该内核是否与Xen兼容。
- en: 'RPATH''S RBUILDER: A NEW APPROACH'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'RPATH''S RBUILDER: 一种新的方法'
- en: RPath is kind of interesting. It probably doesn't merit extended discussion,
    but their approach to building virtual machines is cool. Neat. Elegant.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: RPath相当有趣。它可能不值得进行深入讨论，但他们在构建虚拟机的方法上很酷。整洁。优雅。
- en: RPath starts by focusing on the application that the machine is meant to run
    and then uses software that determines precisely what the machine needs to run
    it by examining library dependencies, noticing which config files are read, and
    so on. The promise of this approach is that it delivers compact, tuned, refined
    virtual machine images with known characteristics—all while maintaining the high
    degree of automation necessary to manage large systems.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: RPath首先关注机器打算运行的应用程序，然后使用软件来确定机器需要哪些软件来运行它，通过检查库依赖关系、注意哪些配置文件被读取等。这种方法的承诺是提供紧凑、调优、精细的虚拟机镜像，具有已知特性——同时保持管理大型系统所需的高度自动化。
- en: Their website is [http://rpath.org/](http://rpath.org/). They've got a good
    selection of prerolled VMs, aimed at both testing and deployment. (Note that although
    we think their approach is worth mentioning, we are not affiliated with rPath
    in any way. You may want to give them a shot, though.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的网站是[http://rpath.org/](http://rpath.org/)。他们提供了一系列预配置的虚拟机，旨在测试和部署。（注意，尽管我们认为他们的方法值得提及，但我们与rPath没有任何关联。不过，您可能想尝试一下。）
- en: '* * *'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[23](#CHP-3-FNOTE-7)]) Except when they're QCOW images. Let's ignore that
    for now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[23](#CHP-3-FNOTE-7)]) 除了它们是 QCOW 图像时。现在我们先忽略这一点。
- en: Mass Deployment
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大规模部署
- en: Of course, all this is tied up in the broader question of *provisioning infrastructure*
    and higher-level tools like Kickstart, SystemImager, and so on. Xen amplifies
    the problem by increasing the number of servers you own exponentially and making
    it easy and quick to bring another server online. That means you now need the
    ability to automatically deploy lots of hosts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些都与更广泛的 *配置基础设施* 问题以及更高层次的工具（如 Kickstart、SystemImager 等）有关。Xen 通过指数级增加您拥有的服务器数量并使上线另一台服务器变得容易和快速来放大这个问题。这意味着您现在需要能够自动部署大量主机。
- en: Manual Deployment
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动部署
- en: The most basic approach (analogous to *tarring up a filesystem*) is probably
    to build a single tarball using any of the methods we've discussed and then make
    a script that partitions, formats, and mounts each domU file and then extracts
    the tarball.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的方法（类似于*tarring up a filesystem*）可能是使用我们讨论过的任何方法构建一个单一的 tarball，然后编写一个脚本，该脚本分区、格式化和挂载每个
    domU 文件，然后提取 tarball。
- en: 'For example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This script takes a domain name as an argument, provisions storage from a tarball
    at */opt/xen/images/base.tar.gz*, and writes a config file for a basic domain,
    with a gigabyte of disk and 128MB of memory. Further extensions to this script
    are, as always, easy to imagine. We've put this script here mostly to show how
    simple it can be to create a large number of domU images quickly with Xen. Next,
    we'll move on to more elaborate provisioning systems.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本接受一个域名作为参数，从 */opt/xen/images/base.tar.gz* 的 tarball 中配置存储，并为基本域写入一个配置文件，包含
    1GB 的磁盘空间和 128MB 的内存。对此脚本进行进一步扩展，如往常一样，很容易想象。我们在这里放置此脚本主要是为了展示如何使用 Xen 快速创建大量
    domU 图像。接下来，我们将转向更复杂的配置系统。
- en: QEMU and Your Existing Infrastructure
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: QEMU 和您的现有基础设施
- en: Another way to do mass provisioning is with QEMU, extending the QEMU installation
    we previously outlined. Because QEMU simulates a physical machine, you can use
    your existing provisioning tools with QEMU—in effect treating virtual machines
    exactly like physical machines. For example, we've done this using SystemImager
    to perform automatic installs on the emulated machines.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种进行大规模配置的方法是使用 QEMU，扩展我们之前概述的 QEMU 安装。因为 QEMU 模拟物理机器，您可以使用 QEMU 上的现有配置工具——实际上是将虚拟机完全当作物理机来对待。例如，我们已经使用
    SystemImager 在模拟机器上执行自动安装。
- en: This approach is perhaps the most flexible (and most likely integrates best
    with your current provisioning system), but it's slow. Remember, KQEMU and Xen
    are not compatible, so you are running old-school, software-only QEMU. Slow! And
    needlessly slow because when a VM has been created, there's nothing to keep you
    from duplicating it rather than going through the entire process again. But it
    works, and it works the exact same way as your previous provisioning system.^([[24](#ftn.CHP-3-FNOTE-8)])
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能是最灵活的（并且最有可能与您当前的配置系统集成），但它很慢。记住，KQEMU 和 Xen 不兼容，所以您正在运行老式的、仅软件的 QEMU。慢！而且没有必要这么慢，因为一旦创建了一个虚拟机，就没有什么可以阻止您复制它而不是再次通过整个流程。但是它有效，并且与您之前的配置系统完全一样有效.^([[24](#ftn.CHP-3-FNOTE-8)])
- en: We'll describe a basic setup with SystemImager and QEMU, which should be easy
    enough to generalize to whichever other provisioning system you've got in place.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述一个使用 SystemImager 和 QEMU 的基本设置，这应该足以推广到您现有的任何配置系统。
- en: Setting Up SystemImager
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置 SystemImager
- en: 'First, install SystemImager using your method of choice—`yum`, `apt-get`, download
    from [http://wiki.systemimager.org/](http://wiki.systemimager.org/)—whichever.
    We downloaded the RPMs from SystemImager using the sis-install script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用您选择的方法安装 SystemImager——`yum`、`apt-get`、从 [http://wiki.systemimager.org/](http://wiki.systemimager.org/)
    下载——随便哪种。我们使用 sis-install 脚本从 SystemImager 下载了 RPM：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: SystemImager works by taking a system image of a *golden client*, hosting that
    image on a server, and then automatically rolling the image out to targets. In
    the Xen case, these components—golden client, server, and targets—can all exist
    on the same machine. We'll assume that the server is dom0, the client is a domU
    that you've installed by some other method, and the targets are new domUs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: SystemImager 通过获取一个“金光客户”的系统镜像，在服务器上托管该镜像，然后将镜像自动分发到目标。在 Xen 的情况下，这些组件——金光客户、服务器和目标——都可以存在于同一台机器上。我们假设服务器是
    dom0，客户端是通过其他方法安装的 domU，目标是新的 domU。
- en: 'Begin by installing the dependency, `systemconfigurator`, on the server:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在服务器上安装依赖项`systemconfigurator`：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then install the server packages:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装服务器包：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Boot the golden client using `xm create` and install the packages (note that
    we are performing these next steps within the domU rather than the dom0):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`xm create`引导黄金客户端并安装软件包（注意我们是在domU而不是dom0中执行以下步骤）：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'SystemImager''s process for generating an image from the golden client is fairly
    automated. It uses `rsync` to copy files from the client to the image server.
    Make sure the two hosts can communicate over the network. When that''s done, run
    on the client:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SystemImager从黄金客户端生成镜像的过程相当自动化。它使用`rsync`从客户端复制文件到镜像服务器。确保两个主机可以通过网络通信。完成这些后，在客户端运行：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then run on the server:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在服务器上运行：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The server will connect to the client and build the image, using the name *porter*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将连接到客户端并构建镜像，使用名称*porter*。
- en: Now you're ready to configure the server to actually serve out the image. Begin
    by running the `si_mkbootserver` script and answering its questions. It'll configure
    DHCP and TFTP for you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您准备好配置服务器以实际提供镜像了。首先运行`si_mkbootserver`脚本并回答它的问题。它将为您配置DHCP和TFTP。
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then answer some more questions about the clients:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回答有关客户端的更多问题：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, use the provided script to enable netboot for the requisite clients:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用提供的脚本为所需的客户端启用网络引导：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And you''re ready to go. Boot the QEMU machine from the emulated network adapter
    (which we''ve left unspecified on the command line because it''s active by default):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好出发了。从模拟的网络适配器（我们在命令行上未指定，因为它默认是激活的）启动QEMU机器：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Of course, after the clients install, you will need to create domU configurations.
    One way might be to use a simple script (in Perl this time, for variety):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在客户端安装后，您需要创建domU配置。一种方法可能是使用一个简单的脚本（这次使用Perl，以增加多样性）：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '(Further refinements, such as generating an IP based on the name, are of course
    easy to imagine.) In any case, just run this script with the name as argument:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: （例如，根据名称生成IP等进一步优化当然容易想象。）无论如何，只需用名称作为参数运行此脚本即可：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then start your shiny new Xen machine:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动您的新Xen机器：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Installing pypxeboot
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装pypxeboot
- en: Like PyGRUB, pypxeboot is a Python script that acts as a domU bootloader. Just
    as PyGRUB loads a kernel from the domain's virtual disk, pypxeboot loads a kernel
    from the network, after the fashion of PXEboot (for Preboot eXecution Environment)
    on standalone computers. It accomplishes this by calling `udhcpc` (the micro-DHCP
    client) to get a network configuration, and then TFTP to download a kernel, based
    on the MAC address specified in the domain config file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyGRUB类似，pypxeboot是一个充当domU引导加载程序的Python脚本。正如PyGRUB从域的虚拟磁盘加载内核一样，pypxeboot从网络加载内核，类似于独立计算机上PXEboot（预引导执行环境）的方式。它通过调用`udhcpc`（微DHCP客户端）来获取网络配置，然后基于域配置文件中指定的MAC地址使用TFTP下载内核来实现这一点。
- en: pypxeboot isn't terribly hard to get started with. You'll need the pypxeboot
    package itself, udhcp, and tftp. Download the packages and extract them. You can
    get pypxeboot from [http://book.xen.prgmr.com/mediawiki/index.php/pypxeboot](http://book.xen.prgmr.com/mediawiki/index.php/pypxeboot)
    and udhcp from [http://book.xen.prgmr.com/mediawiki/index.php/udhcp](http://book.xen.prgmr.com/mediawiki/index.php/udhcp).
    Your distro will most likely include the tftp client already.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: pypxeboot开始使用并不困难。您需要pypxeboot包本身、udhcp和tftp。您可以从[http://book.xen.prgmr.com/mediawiki/index.php/pypxeboot](http://book.xen.prgmr.com/mediawiki/index.php/pypxeboot)获取pypxeboot，从[http://book.xen.prgmr.com/mediawiki/index.php/udhcp](http://book.xen.prgmr.com/mediawiki/index.php/udhcp)获取udhcp。您的发行版可能已经包含了tftp客户端。
- en: The pypxeboot package includes a patch for udhcp that allows udhcp to take a
    MAC address from the command line. Apply it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: pypxeboot包包含一个udhcp的补丁，允许udhcp从命令行获取MAC地址。应用它。
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Build udhcp. A simple `make` followed by `make install` did the trick for us.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 构建udhcp。简单的`make`后跟`make install`对我们来说就足够了。
- en: 'Copy pypxeboot and *outputpy.udhcp.sh* to appropriate places:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将pypxeboot和*outputpy.udhcp.sh*复制到适当的位置：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next set up the TFTP server for network boot. The boot server can be essentially
    the same as a boot server for physical machines, with the caveat that the kernel
    and initrd need to support Xen paravirtualization. We used the setup generated
    by Cobbler, but any PXE environment should work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来设置TFTP服务器以进行网络引导。引导服务器可以基本上与物理机的引导服务器相同，但需要注意的是内核和initrd需要支持Xen硬件虚拟化。我们使用了Cobbler生成的设置，但任何PXE环境都应该可以工作。
- en: 'Now you should be able to use pypxeboot with a domU configuration similar to
    the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够使用与以下类似的domU配置使用pypxeboot：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The regex that finds the MAC address in pypxeboot is easily confused. If you
    specify other parameters, put spaces between the* *`mac=`* *parameter and the
    surrounding commas, for example*, *`vif = [''vifname=lady , mac=00:16:3E:11:11:11
    , bridge=xenbr0'']`*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*在pypxeboot中找到MAC地址的正则表达式很容易混淆。如果您指定其他参数，请将空格放在`mac=`参数及其周围的逗号之间，例如，*`vif =
    [''vifname=lady , mac=00:16:3E:11:11:11 , bridge=xenbr0'']`*。'
- en: 'Create the domain:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建域：
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Automated Installs the Red Hat Way
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红帽式的自动化安装
- en: Red Hat uses Kickstart to provision standalone systems. A full discussion of
    Kickstart is probably best left to Red Hat's documentation—suffice it to say that
    Kickstart has been designed so that, with some supporting tools, you can install
    Xen domUs with it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat使用Kickstart来配置独立系统。关于Kickstart的全面讨论可能最好留给Red Hat的文档——简单地说，Kickstart已被设计成，通过一些辅助工具，您可以使用它安装Xen
    domUs。
- en: The tools you'll most likely want to use to install virtual machines are Cobbler
    and `koan`. Cobbler is the server software, while `koan` (*Kickstart over a network*)^([[25](#ftn.CHP-3-FNOTE-9)])
    is the client. With the `--virt` option, `koan` supports installing to a virtual
    machine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您最可能想要用于安装虚拟机的工具是Cobbler和`koan`。Cobbler是服务器软件，而`koan`（*通过网络传输Kickstart*）^([[25](#ftn.CHP-3-FNOTE-9)])是客户端。使用`--virt`选项，`koan`支持安装到虚拟机。
- en: This being a Red Hat tool, you can install it with `yum`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个Red Hat工具，您可以使用`yum`进行安装。
- en: 'No, sorry, we lied about that. First you''ll need to add the *Extra Packages
    for Enterprise Linux* repository to your `yum` configuration. Install the package
    describing the additional repo:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不，对不起，我们之前撒谎了。首先，您需要将*企业Linux额外包*仓库添加到您的`yum`配置中。安装描述额外仓库的包：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*Now* you can install Cobbler with `yum`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在*您可以使用`yum`安装Cobbler：'
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then you''ll want to configure it. Run `cobbler check`, which will give you
    a list of issues that may interfere with Cobbler. For example, out of the box,
    Cobbler reported these issues for us:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要对其进行配置。运行`cobbler check`，这将列出可能干扰Cobbler的问题。例如，开箱即用，Cobbler为我们报告了以下问题：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After you've fixed these problems, you're ready to use Cobbler. This involves
    setting up install media and adding profiles.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复这些问题后，您就可以使用Cobbler了。这包括设置安装介质和添加配置文件。
- en: First, find some install media. Kickstart is a Red Hat–specific package, so
    Cobbler works only with Red Hat–like distros (SUSE is also supported, but it's
    experimental). Cobbler supports importing a Red Hat–style install tree via `rsync`,
    a mounted DVD, or NFS. Here we'll use a DVD—for other options, see Cobbler's man
    page.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到一些安装介质。Kickstart是Red Hat特定的包，因此Cobbler仅与类似Red Hat的发行版（SUSE也受支持，但为实验性）一起工作。Cobbler支持通过`rsync`、挂载的DVD或NFS导入Red
    Hat风格的安装树。这里我们将使用DVD——有关其他选项，请参阅Cobbler的手册页。
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you''re using a network install source, this may take a while. A full mirror
    of one architecture is around 5GB of software. When it''s done downloading, you
    can see the mirror status by running `cobbler report`. When you''ve got a directory
    tree, you can use it as an install source by adding a *profile* for each type
    of virtual machine you plan to install. We suggest installing through Cobbler
    rather than *bare* pypxeboot and Kickstart because it has features aimed specifically
    at setting up virtual machines. For example, you can specify the domU image size
    and RAM amount in the machine profile (in GB and MB, respectively):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是网络安装源，这可能需要一段时间。一个架构的完整镜像大约是5GB的软件。下载完成后，您可以通过运行`cobbler report`来查看镜像状态。当您有一个目录树时，您可以通过为计划安装的每种类型的虚拟机添加一个*配置文件*来将其用作安装源。我们建议通过Cobbler而不是*裸机*的pypxeboot和Kickstart进行安装，因为它具有专门针对设置虚拟机的功能。例如，您可以在机器配置文件中指定domU镜像大小和RAM数量（分别以GB和MB为单位）：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you''ve added profiles, the next step is to tell Cobbler to regenerate
    some data, including PXEboot menus:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加了配置文件后，下一步是告诉Cobbler重新生成一些数据，包括PXEboot菜单：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, you can use the client, `koan`, to build the virtual machine. Specify
    the Cobbler server, a profile, and optionally a name for the virtual machine.
    We also used the `--nogfx` option to disable the VNC framebuffer. If you leave
    the framebuffer enabled, you won''t be able to interact with the domU via `xm
    console`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用客户端`koan`来构建虚拟机。指定Cobbler服务器、一个配置文件，以及可选的虚拟机名称。我们还使用了`--nogfx`选项来禁用VNC帧缓冲区。如果您启用帧缓冲区，您将无法通过`xm
    console`与domU交互：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`koan` will then create a virtual machine, install, and automatically create
    a domU config so that you can then start the domU using `xm`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`koan`将创建一个虚拟机，安装，并自动创建一个domU配置，这样你就可以使用`xm`启动domU：'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '* * *'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[24](#CHP-3-FNOTE-8)]) This can be made faster by using an HVM domU for the
    SystemImager install, rather than a QEMU instance. Not *blazing fast*, but an
    improvement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[24](#CHP-3-FNOTE-8)]) 使用HVM domU进行SystemImager安装，而不是QEMU实例，可以使这个过程更快。虽然不是**飞速**，但有所改进。
- en: ^([[25](#CHP-3-FNOTE-9)]) It begs the question of whether there are non-networked
    Kickstart installs, but we'll let that slide.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-3-FNOTE-9)]) 这引发了一个问题，即是否存在非网络化的Kickstart安装，但我们暂时忽略这个问题。
- en: And Then…
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 然后...
- en: In this chapter, we've gone through a bunch of install methods, ranging from
    the generic and brute force to the specialized and distro-specific. Although we
    haven't covered anything in exhaustive detail, we've done our best to outline
    the procedures to emphasize when you might want to, say, use `yum`, and when you
    might want to use QEMU. We've also gestured in the direction of possible pitfalls
    with each method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一系列安装方法，从通用的暴力安装到专门的和特定发行版的安装。尽管我们没有详尽地介绍任何内容，但我们尽力概述了程序，以强调你可能想要使用`yum`的时候，以及你可能想要使用QEMU的时候。我们还对每种方法的潜在陷阱进行了示意。
- en: 'Many of the higher-level domU management tools also include a quick-and-easy
    way to install a domU if none of these more generic methods strike your fancy.
    (See [Chapter 6](ch06.html "Chapter 6. DOMU MANAGEMENT: TOOLS AND FRONTENDS")
    for details.) For example, you''re most likely to encounter `virt-install` in
    the context of Red Hat''s `virt-manager`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高级domU管理工具还包括一种快速简便的方法来安装domU，如果这些更通用的方法中没有一种符合你的口味。（有关详细信息，请参阅[第6章](ch06.html
    "第6章。DOMU管理：工具和前端")。）例如，你很可能会在Red Hat的`virt-manager`环境中遇到`virt-install`。
- en: The important thing, though, is to tailor the install method to your needs.
    Consider how many systems you're going to install, how similar they are to each
    other, and the intended role of the domU, and then pick whatever makes the most
    sense.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要根据你的需求调整安装方法。考虑你将要安装多少系统，它们之间有多相似，以及domU的预期角色，然后选择最合理的方法。
