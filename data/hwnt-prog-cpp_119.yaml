- en: 'Part III: Answers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：答案
- en: '**Answer 1:** The problem is that a large herd contains 10,000 sheep. That''s
    40,000 legs. The maximum number you can fit in a short int is 32,767\. That''s
    smaller than 40,000, so (10,000*4) causes an overflow that results in wrong data
    being output.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 1:** 问题在于一个大型羊群包含 10,000 只羊。那是 40,000 条腿。short int 的最大值是 32,767。这小于 40,000，所以
    (10,000*4) 会导致溢出，结果输出错误的数据。'
- en: '**Answer 2:** The problem is that the statement:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 2:** 问题在于这个语句：'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: does not set the variable bit to 1000 0000 0000 0000(b). Instead, it sets it
    to 1 0000 0000 0000 0000(b). Unfortunately, it can't hold 17 bits, so the result
    is that it's set to zero.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有将变量位设置为 1000 0000 0000 0000(b)，而是设置为 1 0000 0000 0000 0000(b)。不幸的是，它无法容纳
    17 位，所以结果是它被设置为零。
- en: 'Because it is zero, the bit test statement will always fail, giving use the
    result:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是零，位测试语句将始终失败，给出以下结果：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Answer 3:** Global classes are initialized before main. Order is not guaranteed
    by the compiler. In particular, there is nothing to guarantee that first_name
    is initialized before it is used. So if the compiler chooses the wrong order,
    the program will output incorrect data or die.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 3:** 全局类在 main 之前初始化。编译器不保证顺序。特别是，没有任何东西可以保证在它被使用之前 first_name 已经初始化。所以如果编译器选择了错误的顺序，程序将输出错误的数据或崩溃。'
- en: '**Answer 4:** The programmer thought he put two statements inside the if, but
    he forgot the curly braces.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 4:** 程序员以为他在 if 语句中放了两条语句，但他忘记了花括号。'
- en: 'So the statement:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个语句：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'properly indented looks like:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正确缩进看起来像：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What the programmer should have written is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该写的是：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Answer 5:** The problem is that the file type was not specified as binary
    (ios::bin). The Microsoft Windows runtime library edits character output and inserts
    <carriage-return (0xD)> before each <line-feed (0xA)>. This explains the extra
    0D in the file just before the 0A character.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 5:** 问题在于文件类型没有被指定为二进制（ios::bin）。Microsoft Windows 运行时库编辑字符输出，并在每个 <line-feed
    (0xA)> 前插入 <carriage-return (0xD)>。这解释了文件中在 0A 字符之前额外的 0D。'
- en: '**Answer 6:** The problem is the line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 6:** 问题在于这一行：'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The function main is not a void function. It''s an int. The function returns
    an exit code to the operating system. A properly written "[Hello World](LiB0005.html#7)"
    looks like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: main 函数不是一个 void 函数。它是一个 int。该函数返回一个退出代码给操作系统。一个正确编写的 "[Hello World](LiB0005.html#7)"
    看起来像：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When my wife first took programming, this was the first program she was taught
    (the void version). I changed the void to an int and she turned the paper in.
    The teaching assistant counted it wrong and changed it back.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我的妻子第一次学习编程时，这是她被教的第一段程序（void 版本）。我将 void 改为 int，她交了作业。助教判错了，又改了回去。
- en: Needless to say, I was not happy about this and wrote him a very snooty letter
    telling him that main was an int and quoting him chapter and verse of the C++
    standard proving it. He wrote back and was extremely nice about the whole thing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不必说，我对这件事感到非常不高兴，并给他写了一封非常傲慢的信，告诉他 main 是一个 int，并引用了 C++ 标准的章节和段落来证明这一点。他回信时非常和善。
- en: '**Answer 7:** The problem is that *sub.cpp* defines str as a character array
    (char []). The extern statement in *main.cpp* defines str as a character *pointer*
    (char *).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 7:** 问题在于 *sub.cpp* 将 str 定义为一个字符数组（char []）。*main.cpp* 中的 extern 声明将
    str 定义为一个字符指针（char *）。'
- en: Now character arrays and character pointers are interchangeable *almost* everywhere
    in C++. This is one of the few cases they are not. In this case, the program main
    thinks that str is a character pointer, so it goes to that location and reads
    the first four bytes expecting an address. The first four bytes are "Hell," which
    is not an address, and so the program crashes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字符数组和字符指针在 C++ 中的几乎所有地方都是可互换的 *几乎*。这是它们不可互换的少数情况之一。在这种情况下，程序 main 认为str是一个字符指针，所以它去那个位置读取前四个字节，期望得到一个地址。前四个字节是
    "Hell"，这不是一个地址，所以程序崩溃。
- en: '**Avoidance 1:** Always define externs in a header file. This header should
    always be included by the module where the item is defined and every module where
    it''s used.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 1:** 总是在头文件中定义 extern。这个头文件应该总是被定义该项目的模块以及使用它的每个模块包含。'
- en: '**Answer 8:** The problem is that ch can be a signed character. That means
    that if ch is 0xFF when converted to a signed integer for comparison purposes
    you get int(ch)=-1 (0xFFFFFFF). That''s not 0xFF and the comparison fails.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 8:** 问题在于 ch 可以是一个有符号字符。这意味着如果 ch 在比较时转换为有符号整数，你得到 int(ch)=-1 (0xFFFFFFF)。这并不是
    0xFF，比较失败了。'
- en: '**Avoidance 2:** Be careful when you use character variables to hold numbers.
    They may not do what you want them to.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 2**：当使用字符变量来存储数字时要小心。它们可能不会按你的预期工作。'
- en: '**Answer 9:** The problem is that the optimizer looks at the code and sees
    that we read *in_port_ptr three times and then throws away the result. The optimizer
    then figures out that it can optimize the program and produce the same apparent
    results by taking out the lines 20, 21, and 22.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 9**：问题在于优化器查看代码，看到我们读取*in_port_ptr三次然后丢弃结果。优化器随后推断出，通过删除第20、21和22行，它可以优化程序并产生相同的结果。'
- en: The solution is to declare the port pointers volatile. In Program 107 we've
    done this, but something is not quite right.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是声明端口指针为volatile。在程序107中我们已经这样做了，但有些地方不太对劲。
- en: '**Answer 10:** The answer is that the printf format (%d) does not match the
    parameter type (double). The programmer should have written:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 10**：答案是printf格式（%d）与参数类型（double）不匹配。程序员应该这样写：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Answer 11:** A character has 8 bits numbered 0 to 7\. The bits can be represented
    by the constants (1 << 0) to (1 << 7).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 11**：字符有8位，编号为0到7。这些位可以用常数（1 << 0）到（1 << 7）来表示。'
- en: There is no bit number 8, so the expression
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有位号8，所以表达式
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: does nothing because it sets a bit outside the boundary of the character. The
    result is that only the administration privilege is really set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它设置了一个超出字符边界的位，所以什么也不做。结果是，只有管理权限真正被设置。
- en: '**Answer 12:** The operator = function call takes a single parameter of type
    data_holder. This type of parameter is a call by value parameter, so the copy
    constructor is called. The programmer making the copy constructor decided to take
    a shortcut and uses the operator = to implement the copy. So operator = calls
    the copy constructor, which calls operator = which calls the copy constructor
    ... and so on until you run out of stack.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 12**：运算符=函数调用接受一个类型为data_holder的单个参数。这种类型的参数是按值传递参数，因此会调用复制构造函数。创建复制构造函数的程序员决定走捷径，并使用运算符=来实现复制。所以运算符=调用复制构造函数，它又调用运算符=，然后调用复制构造函数……以此类推，直到栈空间耗尽。'
- en: 'The operator = function should take a constant reference as its parameter type:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符=函数应该将其参数类型取为常量引用：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It should also return a reference to a data holder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它也应该返回一个指向数据持有者的引用。
- en: '**Avoidance 3:** Use const references if possible when passing parameters.
    This avoids the extra cost of doing a copy of a call by value parameter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 3**：如果可能，在传递参数时使用const引用。这避免了按值传递参数时的额外开销。'
- en: '**Answer 13:** The problem is with the if statement. In the first one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 13**：问题出在if语句上。在第一个中：'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'the programmer forgot to put in the closing curly brace. That''s OK; he made
    up for it by forgetting to put in an opening brace for the next if statement:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员忘记了添加闭合的花括号。这没关系；他通过忘记为下一个if语句添加开括号来弥补：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we properly indent the code, we can see the problem:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确缩进代码，我们就可以看到问题：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What the programmer should have written is:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该写的是：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Answer 14:** The statement:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 14**：语句：'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: copies a queue of size 30 to a queue of size 20\. In other words, the assignment
    operator (as implemented) allows us to copy different size queue. We should not
    be allowed to do this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将大小为30的队列复制到大小为20的队列中。换句话说，赋值运算符（如实现的那样）允许我们复制不同大小的队列。我们不应该被允许这样做。
- en: 'There are four ways to solve this problem:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的有四种方法：
- en: Use the STL queue class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用STL队列类。
- en: Make the assignment operator private (and not allow any assignments).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将赋值运算符设置为私有（并且不允许任何赋值）。
- en: Change the assignment operator so that it throws an exception if the size of
    the queue is not the same.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将赋值运算符修改为，如果队列的大小不同则抛出异常。
- en: Change the queue class so that you can assign different size queues to each
    other.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将队列类修改为可以相互赋值不同大小的队列。
- en: '**Answer 15:** The constant 02126 is octal because the leading digit is a zero.
    So in C++, 02126 (octal) is 1110 (decimal) and is not the zip code for Boston.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 15**：常数02126是八进制，因为最高位是零。所以在C++中，02126（八进制）等于1110（十进制），并不是波士顿的邮政编码。'
- en: '**Answer 16:** The problem is that the compiler knows what 12 * 34 equals,
    so instead of doing the multiply it optimizes the statement and turns it into:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 16**：问题在于编译器知道12 * 34等于多少，所以它不是直接进行乘法运算，而是优化了语句，将其转换为：'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the multiply is not done, the timing is off. Program 109 is an attempt
    to fix this problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有进行乘法运算，时间计算有误。程序109是尝试解决这个问题。
- en: '**Answer 17:** The problem is that the programmer used bitwise and (&) instead
    of logical and (&&). A bitwise and of the two numbers gives us:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案17**：问题在于程序员使用了位与(&)而不是逻辑与(&&)。两个数字的位与给出了我们：'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So the result is 0, the if clause is skipped, and the else clause is executed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此结果是0，跳过了if子句，执行else子句。
- en: 'Some programmers use the shorthand:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员使用缩写：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: for
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: for
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (I discourage such shorthand.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: （我反对这种缩写。）
- en: 'This is one example of why I don''t like shortcuts. A better way of writing
    the if statement is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我不喜欢捷径的一个例子。编写if语句的更好方法是：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Shortly after discovering this bug I told a colleague about it. I explained
    what happened and said, "I now know the difference between 'and' and 'and and'."
    I'm not sure what amazed me more, the fact that I came up with this sentence or
    the fact the he understood it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现这个错误不久后，我告诉了一个同事。我解释了发生了什么，并说：“我现在知道'and'和'and and'之间的区别了。”我不确定我更惊讶的是我提出了这个句子，还是他理解了这个句子。
- en: '**Answer 18:** The problem is that tmp_name returns a pointer to the local
    variable name. When the function ends, the storage for all nonstatic local variables
    is reclamined. This includes the storage for name. Thus, the pointer returned
    points to a random, unallocated section of memory.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案18**：问题在于tmp_name返回一个指向局部变量name的指针。当函数结束时，所有非静态局部变量的存储空间都会被回收。这包括name的存储空间。因此，返回的指针指向一个随机、未分配的内存区域。'
- en: The next function call that comes along will probably clobber that storage and
    make a_name look really strange.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的函数调用可能会覆盖那个存储空间，使a_name看起来非常奇怪。
- en: A solution to this problem is to declare name **static.**
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将name声明为**静态**。
- en: (See [Program 59](LiB0063.html#69) for a similar problem.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （参见[程序59](LiB0063.html#69)中的类似问题。）
- en: '**Answer 19:** The problem is that the statement'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案19**：问题在于该语句'
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: does not move the bit over to the right one. Instead it does a "signed" shift,
    which copies the sign bit. Thus
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有将位向右移动一位。相反，它执行了一个“有符号”的位移，这会复制符号位。因此
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: is not
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不是
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: as expected but instead
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，但结果是
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because of this problem, the bit testing gives incorrect results.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个问题，位测试给出了错误的结果。
- en: '**Answer 20:** The arguments to memset are:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案20**：memset的参数是：'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the value is sizeof(array) and the number of bytes to fill is
    0\. Since size=0 nothing was done.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，值是sizeof(array)，要填充的字节数是0。由于size=0，没有进行任何操作。
- en: 'The programmer should have written:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该写成：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Answer 21:** The C++ standard states that all pointers must point to the
    array or above. You can''t point below the array.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案21**：C++标准规定所有指针都必须指向数组或其上方。你不能指向数组下方。'
- en: 'In this example, we have an array on an Intel machine. The address of the array,
    in Intel strange pointer parlance, is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个在英特尔机器上的数组。在英特尔怪异指针术语中，数组的地址是：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The data_ptr variable starts out at:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: data_ptr变量最初位于：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It then gets decremented as long as it is greater than data. During its decrementation
    data_ptr goes to
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只要它大于data，它就会递减。在其递减过程中，data_ptr会移动到
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That''s equal to the address of the array data, so it''s decremented again.
    (Remember that in this memory model, only the address part is changed.) The result
    is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这等于数组data的地址，所以它再次递减。（记住在这个内存模型中，只有地址部分被改变。）结果是：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: is evaluated. But data_ptr is now much greater than data, so the program continues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 被评估。但是data_ptr现在比data大得多，所以程序继续执行。
- en: 'The result is that the program writes over random data, which can cause the
    system to crash. But if it doesn''t, data_ptr will go down to:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是程序覆盖了随机数据，这可能导致系统崩溃。但如果不会，data_ptr将下降到：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: wrap, and the process will continue again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: wrap，并且过程将再次继续。
- en: '**Answer 22:** The problem is that the function max returns a reference to
    a parameter. That parameter is 3+4, which is an expression.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案22**：问题在于函数max返回一个参数的引用。该参数是3+4，这是一个表达式。'
- en: 'What C++ actually does when min is called is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用min时，C++实际上做的事情是：
- en: Creates a temporary (tmp1) and assigns it 1+2
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时变量（tmp1）并将其赋值为1+2
- en: Creates a temporary (tmp2) and assigns it 3+4
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个临时变量（tmp2）并将其赋值为3+4
- en: Calls max(tmp1, tmp2)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用max(tmp1, tmp2)
- en: This function returns a reference to tmp2.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数返回对tmp2的引用。
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The variable i is now a reference to nothing.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量i现在是一个对无物的引用。
- en: The problem is caused by returning a reference to a parameter. This creates
    a dangling reference.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是由返回参数的引用引起的。这创建了一个悬空引用。
- en: '**Answer 23:** The programmer did not put spaces in the output text for the
    line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案23**：程序员没有在输出文本的该行中添加空格：'
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: as a result, the output looks like
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，输出看起来像
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What he should have written is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 他应该写成这样：
- en: '![](fig237_01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](fig237_01.jpg)'
- en: '**Answer 24:** This is a classic deadlock problem:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案24：** 这是一个经典的死锁问题：'
- en: 'Process 1 requires resources #1 and #2.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程1需要资源#1和#2。
- en: 'Process 2 requires resources #2 and #1.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程2需要资源#2和#1。
- en: They get the resources in that order. Remember that thread switches can occur
    at any time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 他们以那个顺序获取资源。记住，线程切换可能随时发生。
- en: 'So we have a race condition in which the following can occur:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个可能导致以下情况发生的竞争条件：
- en: 'Process 1 gets resource #1'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程1获取资源#1
- en: Thread switch to process 2
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程切换到进程2
- en: 'Process 2 gets resource #2'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程2获取资源#2
- en: 'Process 2 attempts to get resource #1'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程2试图获取资源#1
- en: 'Resource #1 is unavailable, so the process sleeps until it is freed (keeping
    resource #2 locked while it works)'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源#1不可用，因此进程将休眠直到它被释放（在它工作期间保持资源#2锁定）
- en: Thread switch to process 1
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程切换到进程1
- en: 'Process 1 attempts to get resource #2\. It''s locked, so the process sleeps
    until it is freed. (Resource #1 is kept locked in the meantime.)'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程1试图获取资源#2。由于它被锁定，进程将休眠直到它被释放。（在此期间，资源#1保持锁定。）
- en: 'The result is that process 1 is waiting for resource #2 while holding resource
    #1\. It will not give up resource #1 until it gets resource #2.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是进程1在持有资源#1的同时等待资源#2。它不会放弃资源#1直到它获取到资源#2。
- en: 'Process 2 is waiting for resource #1 while holding resource #2\. It will not
    give up resource #2 until it gets process #1.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进程2在持有资源#2的同时等待资源#1。它不会放弃资源#2直到它获取到资源#1。
- en: '**Avoidance 4:** Define locking order (for example, you must get the locks
    in the order #1, #2). Always use this locking order when getting multiple locks.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免4：** 定义锁定顺序（例如，你必须按照#1、#2的顺序获取锁）。在获取多个锁时始终使用此锁定顺序。'
- en: '**Alternate:** When getting multiple locks, use the following algorithm:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**备选方案：** 在获取多个锁时，使用以下算法：'
- en: Attempt to get all the locks (do not block if they are not available).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试获取所有锁（如果不可用则不阻塞）。
- en: If you've got everything, then go on and do your job.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经拥有了所有东西，那么继续做你的工作。
- en: If you didn't get all the locks, free the ones you didn't get, sleep a while,
    and try again.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有获取到所有锁，释放那些你没有获取到的锁，稍作休眠，然后再次尝试。
- en: '**Answer 25:** The problem is the statement:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案25：** 问题在于这个语句：'
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is an assignment statement inside an if. If we rewrite the code to avoid
    the shortcut, we get the two statements.:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个if语句内的赋值语句。如果我们重写代码以避免快捷方式，我们得到两个语句：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The use of the logical not in this context ( !0 ) gives us a result of 1\. So
    we always assign n2 the value 1, then do the comparison and divide.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用逻辑非（!0）给我们一个结果为1。所以我们总是将n2赋值为1，然后进行比较和除法。
- en: The != was written backwards as =! thus giving us the surprise.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '!=被错误地写成=!，因此产生了意外。'
- en: 'The statement should have read:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句应该读作：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Answer 26:** The problem is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案26：** 问题在于：'
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This tells the compiler to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器：
- en: Increment i
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i
- en: Use it to index array (first occurrence)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来索引数组（首次出现）
- en: Increment i
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i
- en: Use it to index array (second occurrence)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来索引数组（第二次出现）
- en: Compute the difference
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算差值
- en: 'The problem is that steps 1-4 can occur in a different order:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于步骤1-4可能以不同的顺序发生：
- en: Increment i
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i
- en: Increment i
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i
- en: Use it to index array (first occurrence)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来索引数组（首次出现）
- en: Use it to index array (second occurrence)
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它来索引数组（第二次出现）
- en: Statements with many side effects give the C++ compiler latitude to screw things
    up.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 具有许多副作用语句给C++编译器提供了出错的空间。
- en: '**Avoidance 5:** Put side effects like ++ and -- on lines by themselves.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免5：** 将像++和--这样的副作用操作单独放在一行。'
- en: '**Answer 27:** The problem is that "1" is an integer. The number "3" is also
    an integer. So "1/3" is an integer divide.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案27：** 问题在于“1”是一个整数。数字“3”也是一个整数。所以“1/3”是整数除法。'
- en: 'Thus, the statement:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，语句：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: does an integer divide of 1 by 3\. Integer divides truncate the fractional part
    so the result is 0\. The integer "0" is turned into floating-point and assigned
    result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对1除以3进行整数除法。整数除法会截断小数部分，因此结果是0。整数“0”被转换为浮点数并分配给结果。
- en: 'The programmer should have written this as:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该这样写：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Answer 28:** The scanf function is extremely tricky to use. In this program
    the statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案28：** scanf函数非常难以使用。在这个程序中，语句：'
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'gets a character and a integer. The next time scanf is called, it will read
    another character and integer. So what''s the next character? Let''s look at the
    sample run:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个字符和一个整数。下一次调用 scanf 时，它将读取另一个字符和整数。那么下一个字符是什么呢？让我们看看示例运行：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first line we type is:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入的第一行是：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After the first scanf call, the input pointer is position just before the newline
    just after the 5. The next scanf tries to read the operator and gets the newline.
    It keeps reading and sees a + instead of a number. The result is a lot of confusion.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 scanf 后，输入指针位于 5 后的换行符之前。下一次 scanf 尝试读取操作符并获取换行符。它继续读取并看到加号而不是数字。结果是很多困惑。
- en: '**Avoidance 6:** The scanf function is tricky to get right. But I have a simple
    way of dealing with this problem: I never use it. Instead I always use a combination
    of fgets and sscanf instead.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 6**：scanf 函数很难正确使用。但我有一个简单的方法来处理这个问题：我从不使用它。相反，我总是使用 fgets 和 sscanf 的组合。'
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Answer 29:** The preprocessor does not understand C++ syntax. When we define
    TOTAL to be 37 + 33, it is literally 37 + 33 and not 70.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 29**：预处理器不理解 C++ 语法。当我们定义 TOTAL 为 37 + 33 时，它实际上是 37 + 33，而不是 70。'
- en: 'The AREA macro is defined as:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 面积宏定义为：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Operator precedence takes over and gives us the wrong answer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符优先级占上风，给出了错误的答案。
- en: '**Avoidance 7:** Use constants instead of defined macros whenever possible.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 7**：尽可能使用常量而不是定义宏。'
- en: '**Avoidance 8:** Put parenthesis around all #defines that define anything other
    than a simple number.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 8**：将括号放在所有定义非简单数字的 #define 语句周围。'
- en: 'Example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Answer 30:** The problem is that the function is returning a reference to
    a local variable. This is a bad thing because the local variable is destroyed
    by the return; the reference is what is called a *dangling reference.* It''s referring
    to something that is no longer there.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 30**：问题在于函数返回了一个局部变量的引用。这是件坏事，因为局部变量在返回时被销毁；引用被称为 *悬空引用*。它指向不再存在的东西。'
- en: When we try to print the string that is no longer there, we run into trouble.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试打印不再存在的字符串时，我们会遇到麻烦。
- en: '**Avoidance 9:** Do not return references to local variables.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 9**：不要返回局部变量的引用。'
- en: '**Answer 31:** The problem is that the else clause goes with the nearest if.
    The properly indented code looks like:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 31**：问题在于 else 子句与最近的 if 语句配对。正确缩进的代码如下：'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is not what the programmer intented. What he wanted to do was:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是程序员想要的结果。他想要做的是：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Avoidance 10:** Use {} around statements under the control of an if, for,
    while, or other control statement if there is more than one statement conditional
    control.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 10**：如果在一个 if、for、while 或其他控制语句的控制下有多个语句条件控制，请使用 {} 包围这些语句。'
- en: '(That''s a fancy way of saying: Don''t write code like this.)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: (这是一种说法：不要写这样的代码。)
- en: '| **![Start Sidebar](_1.gif)** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **![开始侧边栏](_1.gif)** |'
- en: 'Bonus question: This fixes most of the problems, but there''s still a bug in
    this program. What is it? (Next [Hint 112](LiB0120.html#248). [Answer 38](#ch13p38).)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 奖励问题：这解决了大多数问题，但这个程序中仍然有一个错误。是什么？(下一个 [提示 112](LiB0120.html#248)。 [答案 38](#ch13p38)。)
- en: '| **![End Sidebar](_1.gif)** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **![结束侧边栏](_1.gif)** |'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Answer 32:** The problem is that memory is allocated in the constructor and
    never freed.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 32**：问题在于内存是在构造函数中分配的，但从未被释放。'
- en: '**Avoidance 11:** Always **delete** in the destructor what you **new** in the
    constructor.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 11**：在析构函数中删除在构造函数中创建的。'
- en: This rule was not followed, so every time we created a stack some of the heap
    permanently went away.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则没有被遵循，所以每次我们创建一个栈，一些堆就会永久消失。
- en: '**Answer 33:** The program prints:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 33**：程序打印：'
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The problem is that fgets gets a line including the newline. So when the first
    name is read, it's read as John\n. The same thing happens with Smith, and the
    result is our funny output.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 fgets 会获取包括换行符在内的整行。所以当读取第一个名字时，它读取为 John\n。同样的事情发生在 Smith 上，结果是我们的有趣输出。
- en: '**Answer 34:** There is a extra semicolon at the end of the for statement:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 34**：for 语句的末尾有一个额外的分号：'
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This means that the for controls absolutely nothing. Properly indented the
    program is:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 for 循环根本控制不了什么。正确缩进的程序如下：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'or if we add a little commenting this looks like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果我们添加一些注释，看起来是这样的：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From this we can see that the std::cout line is not inside the for loop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看出，std::cout 行不在 for 循环内部。
- en: '**Answer 35:** The problem is that we declared a local variable named remove.
    There is a standard function named remove as well. Our local variable hid the
    function for the scope of the local variable.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 35**：问题在于我们声明了一个名为 remove 的局部变量。还有一个名为 remove 的标准函数。我们的局部变量隐藏了局部变量作用域内的函数。'
- en: That scope ended at the end of the first if on line 15.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个作用域在第一行 15 的第一个 if 语句结束时结束。
- en: 'The next statement:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个语句：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: checks to see if the address of the function remove is non-zero and executes
    the next statement if it is.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 检查函数 remove 的地址是否非零，如果是，则执行下一个语句。
- en: '[![Click To expand](fig242_01.jpg)](fig242_01_0.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig242_01.jpg)](fig242_01_0.jpg)'
- en: '**Avoidance 12:** Avoid hidden variables.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 12**：避免隐藏变量。'
- en: '**Answer 36:** The problem is that the string we return is defined as:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 36**：问题在于我们返回的字符串被定义为：'
- en: '[PRE54]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is a local variable. The subroutine returns a reference to this string.
    But because it's a local variable, it's destroyed at the end of the function.
    That means when we use the result, the variable holding the result has been destroyed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个局部变量。子程序返回对这个字符串的引用。但由于它是一个局部变量，它在函数结束时被销毁。这意味着当我们使用结果时，持有结果的变量已经被销毁了。
- en: '**Answer 37:** The problem is that the backslash character is used as an escape
    character. So \n is newline. \new is <newline>ew.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 37**：问题在于反斜杠字符被用作转义字符。所以 \n 是换行符。\new 是 <newline>ew。'
- en: So the string \root\new\table decodes as
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以字符串 \root\new\table 解码为
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What the programmer really wanted was:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员真正想要的是：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Ironically, this rule does not apply to #include file names so'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '具有讽刺意味的是，这个规则不适用于 #include 文件名。'
- en: '[PRE57]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: works and is correct.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作正常且正确。
- en: '**Answer 38:** The problem is the statement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 38**：问题在于这个语句：'
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is used to check to see if the customer owes the company something. Thus,
    the customer can see a message like:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于检查客户是否欠公司东西。因此，客户可以看到类似的消息：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|  | Note  | This actually happened to one person. He got a bill for $0.00\.
    He called up the company, they apologized, and the next month he got a bill for
    $0.00\. This continued for many months. Each time he called the company, they
    would apologize and tell him they would fix the problem, but nothing would happen.
    |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | 这实际上发生在一个人的身上。他收到了一张 $0.00 的账单。他打电话给公司，他们道歉了，下个月他又收到了一张 $0.00 的账单。这种情况持续了好几个月。每次他打电话给公司，他们都会道歉并告诉他他们会解决这个问题，但什么也没有发生。
    |'
- en: He even got charged a late fee of 5%. This brought his bill up to $0.00.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 他甚至被收取了 5% 的滞纳金。这使得他的账单达到了 $0.00。
- en: Finally, he sent them a check for $0.00.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，他给他们寄了一张 $0.00 的支票。
- en: That week he got a nasty phone call from his bank. "Why did you write out such
    a check?" they demanded to know.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那周他收到了银行的一个令人不快的电话。“你为什么写出了这样一张支票？”他们质问道。
- en: It seems that the check crashed its computer system. So the check was bounced,
    and the next week he received a bill for $0.00.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来支票使他的电脑系统崩溃了。所以支票被退回，下周他收到了一张 $0.00 的账单。
- en: '**Answer 39:** The problem is that the optimizer is smart. It sees that we
    are computing the result of'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 39**：问题在于优化器很聪明。它看到我们在计算'
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'inside the for loop. The answer won''t change if we move this to outside the
    for loop, but things will go quicker. So the optimized version of this program
    does the multiply only one time:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 循环内。如果我们把这个移动到 for 循环外，答案不会改变，但会更快。所以这个程序的优化版本只乘一次：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To fix this problem we need to declare our factor volatile.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要声明我们的因子为易失性。
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It's things like this that make embedded programming so simple.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这类事情使得嵌入式编程变得如此简单。
- en: '**Answer 40:** The problem is that ostream is passed as "pass by value". You
    can''t copy stream variables. (If you did it would mean that the system would
    have to make a copy of the file.) The parameter should be changed to a "pass by
    reference" parameter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 40**：问题在于 ostream 是按“按值传递”传递的。你不能复制流变量。（如果你这样做，意味着系统必须复制文件。）参数应该改为“按引用传递”参数：'
- en: '[PRE63]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Answer 41:** The problem is the statement:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 41**：问题在于这个语句：'
- en: '[PRE64]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The strcat function takes two strings as arguments. In this example, we've given
    it a string and a character. Because there are no prototypes, C can't do parameter
    checking; the incorrect parameter is passed to strcat, which gets very confused.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: strcat 函数接受两个字符串作为参数。在这个例子中，我们给了它一个字符串和一个字符。因为没有原型，C 语言无法进行参数检查；错误的参数被传递给了 strcat，这使得它非常困惑。
- en: '**Avoidance 13:** All functions should be explicitly declared. Never let C
    declare them implicitly. Make sure you include the headers that define the prototypes
    for all the functions that you use.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 13**：所有函数都应该显式声明。永远不要让C隐式声明它们。确保包含定义你使用的所有函数原型的头文件。'
- en: '**Answer 42:** A signed one-bit number can have one of two values: 0 and -1.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 42**：有符号的一位数可以有两个值：0和-1。'
- en: 'The statement:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'fails because the one-bit-wide field can''t hold the value 1\. (So it overflows
    and assigns the variable the value -1!) The result is that the next statement:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 失败，因为一位宽的字段无法容纳值1。（所以它溢出并将变量赋值为-1！）结果是下一个语句：
- en: '[PRE66]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: fails.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 失败。
- en: '**Avoidance 14:** Single bit fields should be unsigned.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 14**：单比特字段应该是无符号的。'
- en: '**Answer 43:** On MS-DOS you''ll get something like:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 43**：在MS-DOS上，你可能会得到类似以下的结果：'
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'On UNIX you might get something like:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX上，你可能会得到类似以下的结果：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The problem is that the programmer did not add an end of line at the end of
    the std::cout statement. The result is that the program runs, outputs a statement,
    and exists leaving the cursor positioned at the end of a line. The command processor
    then runs and outputs its prompt (C:> for MS-DOS, $ for UNIX) right next to the
    program's output.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于程序员没有在std::cout语句的末尾添加换行符。结果是程序运行，输出一条语句，然后退出，光标定位在行尾。命令处理器随后运行并输出其提示符（MS-DOS为C:>，UNIX为$）紧挨着程序的输出。
- en: 'What the programmer should have written is:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该这样写是：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**Answer 44:** Commas can be used to separate C++ statements. It''s used like:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 44**：逗号可以用来分隔C++语句。它的用法如下：'
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: (Don't program like this, please!)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: （请不要这样编程，谢谢！）
- en: The statment
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句
- en: '[PRE71]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'is the same as:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 等于：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: or
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: From this, we can see why we get 1 as out output.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个中，我们可以看到为什么我们得到1作为输出。
- en: '**Answer 45:** The problem is that the expression ch+1 is an integer (value
    66). C++ detects this and calls the std::cout.operator <<(int) function and outputs
    an integer.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 45**：问题是表达式ch+1是一个整数（值为66）。C++检测到这一点并调用std::cout.operator <<(int)函数，输出一个整数。'
- en: 'What the programer should have written is:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该这样写：
- en: '[PRE74]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '**Answer 46:** The output is:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 46**：输出如下：'
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The reason is that DOUBLE(i+1) expands to:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是DOUBLE(i+1)展开为：
- en: '[PRE76]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When C++ sees this, it multiplies 1 by 2 and adds i. This result is not what
    the programmer intended.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当C++看到这个表达式时，它会将1乘以2，然后加上i。这个结果并不是程序员想要的。
- en: '**Avoidance 15:** Use **inline** functions instead of macros whenever possible.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 15**：尽可能使用内联函数而不是宏。'
- en: '**Avoidance 16:** Always put () around the parameters of macros. Example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 16**：尽可能总是将宏的参数用括号括起来。例如：'
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**Answer 47:** The statement:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 47**：该语句：'
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: assigns 0 to amount, then compares the result to see if it's not zero. It is
    zero, so the else clause is executed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 将0赋值给amount，然后比较结果看它是否不为零。它是零，所以执行else子句。
- en: 'The programmer should have written the statement as:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该这样写这个语句：
- en: '[PRE79]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|  | Note  | One of the most rewarding experiences I had when I was teaching
    programming was when I met a student about two months after the class had finished."Steve,"
    he said. "I have to tell you that during the class I thought you were going a
    bit overboard about this ''='' vs. ''=='' stuff — until yesterday. You see, I
    wrote my first real program and guess what mistake I made?" |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意 | 我在教编程时最令人欣慰的经历之一是在课程结束大约两个月后遇到一个学生。“Steve，”他说。“我必须告诉你，在课堂上我觉得你对这个‘=’与‘==’的东西有点过分——直到昨天。你知道，我写了我的第一个真正的程序，猜猜我犯了什么错误？”|'
- en: '**Answer 48:** Use the statement:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 48**：使用以下语句：'
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|  | Note  | This algorithm was first found lurking in an article as an example
    of how not to do the job. The author''s "ideal" way of doing things was to use
    the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 注意 | 这个算法最初被发现隐藏在一篇文章中，作为如何不完成工作的例子。作者的“理想”做法是使用以下代码：'
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The point the author was trying to make was that you should check for illegal
    values in your code.Sharp-eyed readers may notice that there's a syntax error
    in this code. There was a similar problem in the "ideal" solution in the original
    article. In other words, the code the author presented as "ideal" wouldn't work.
    |
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 作者试图说明的是，你应该检查代码中的非法值。细心的读者可能会注意到这段代码中存在语法错误。原文中“理想”解决方案也存在类似问题。换句话说，作者展示的“理想”代码无法工作。|
- en: '**Answer 49:** The problem is that C++''s operator precedence is not what the
    programmer thought it was. The + operator comes before << so'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 49**：问题是C++的运算符优先级并不是程序员所想的。+运算符在<<之前，所以'
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'gets parsed as:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 被解析为：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The result is 1<<4 or 8.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 1<<4 或 8。
- en: '**Avoidance 17:** Use the simple C++ precedence rules:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 17**：使用简单的 C++ 优先级规则：'
- en: '*, / and % come before + and -.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*, / 和 % 的优先级高于 + 和 -。'
- en: Put () around everything else.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 () 放在其他所有内容周围。
- en: '**Answer 50:** It prints'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 50**：它打印'
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The problem is that when the fork occurs, there is data in the printf buffer.
    The fork creates two copies of the process and two copies of the data in the printf
    buffer. Thus, when the buffer is flushed later (in both processes) we get a Hello
    from each of them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当发生 fork 时，printf 缓冲区中有数据。fork 创建了两个进程副本和 printf 缓冲区中的两个数据副本。因此，当缓冲区稍后（在两个进程中）被刷新时，我们都会收到来自它们的
    Hello。
- en: '**Answer 51:** The programmer never bothered to initialize sum. You can''t
    count on a uninitialized value containing anything. So sum may start out at 0,
    5190, 123, 5, or something else.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 51**：程序员从未费心初始化 sum。你不能指望一个未初始化的值包含任何东西。所以 sum 可能从 0、5190、123、5 或其他值开始。'
- en: 'What the programmer should have written is:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该编写的是：
- en: '[PRE85]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '**Answer 52:** The problem is the line'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 52**：问题是以下行'
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This operation is not protected against thread switches. On a complex instruction
    machine, the assembly code for this looks like:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作无法防止线程切换。在复杂的指令机器上，此操作的汇编代码如下：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Thread switches occur only on an instruction boundary. So this operation cannot
    be interrupted on the 80x86 machine family.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 线程切换仅在指令边界上发生。因此，在 80x86 机器家族上无法中断此操作。
- en: 'But on a RISC machine such as a Sparc, the code looks a little different:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但在像 Sparc 这样的 RISC 机器上，代码看起来略有不同：
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'So now the C++ statement is interruptible. In particular, the following can
    happen:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在 C++ 语句是可中断的。特别是，以下情况可能发生：
- en: The program runs and completes instruction 3\. At this point, the value of flags
    is in register %o2.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序运行并完成指令 3。此时，标志的值在寄存器 %o2 中。
- en: A thread switch occurs.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发生了线程切换。
- en: The other process modifies flags.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个进程修改了标志。
- en: The thread switches back.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程切换回原状态。
- en: The old value of flags is in register %o2.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标志的旧值在寄存器 %o2 中。
- en: The bit is set, and the result is stored. Because this contained the old value
    of flags, any changes made in the other thread are discarded accidently.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该位被设置，并将结果存储。因为这将包含标志的旧值，所以其他线程中进行的任何更改都会意外地被丢弃。
- en: The solution to this problem is to use locks to prevent a task switch from occurring
    during the statement.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是使用锁来防止在语句执行期间发生任务切换。
- en: '**Answer 53:** The statement:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 53**：该语句：'
- en: '[PRE89]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: prints the answer in octal. The programmer made an error and put %o where he
    wanted %d. The result is that the numbers are correct, just in the wrong base.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以八进制形式打印答案。程序员犯了一个错误，本应使用 %d 而使用了 %o。结果是数字是正确的，只是基数错误。
- en: '**Answer 54:** The problem is that you can''t represent 1/3 exactly in floatingpoint.
    Let''s see what happens when we add the numbers in decimal.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 54**：问题是你在浮点数中不能精确表示 1/3。让我们看看当我们以十进制形式添加这些数字时会发生什么。'
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Because of the roundoff error, the result is not 1.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于舍入误差，结果不是 1。
- en: Remember that when using floating-point, the numbers are not exact.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用浮点数时，数字不是精确的。
- en: '**Answer 55:** The problem is that we throw an exception in a destructor.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 55**：问题是我们在析构函数中抛出异常。'
- en: 'When the program reaches the line:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序到达以下行：
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: the exception code takes charge. It destroys all the local variables. That includes
    the variable a_stack.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 异常代码接管。它销毁所有局部变量。这包括变量 a_stack。
- en: 'When a_stack is destroyed, the destructor is called:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当 a_stack 被销毁时，会调用析构函数：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The destructor throws an exception. C++ does not like it when you throw an exception
    in an exception. When that happens the program calls the terminate() function.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数抛出异常。C++ 不喜欢你在异常中抛出异常。当发生这种情况时，程序会调用 terminate() 函数。
- en: If you want to catch the second exception and other similar exception problems,
    use the standard function set_terminate to establish a function to take care of
    unexpected problems.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想捕获第二个异常和其他类似的异常问题，请使用标准函数 set_terminate 来设置一个处理意外问题的函数。
- en: '**Avoidance 18:** Don''t throw exceptions in destructors.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 18**：不要在析构函数中抛出异常。'
- en: '**Answer 56:** The problem is that the redefined new function is implemented
    incorrectly. The programmer assumed that when a person does a'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 56**：问题是重新定义的新函数实现不正确。程序员假设当一个人执行'
- en: '[PRE93]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: the size of the allocated object is sizeof(fast_bit_array). This is not true
    when fast_bit_array is used as a base class. In this case, the size of the allocated
    memory is the size of the derived class safe_bit_array, which is bigger than fast_bit_array,
    thus resulting in memory confusion.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的对象大小是sizeof(fast_bit_array)。当fast_bit_array用作基类时，这并不正确。在这种情况下，分配的内存大小是派生类safe_bit_array的大小，它比fast_bit_array大，从而导致内存混淆。
- en: '**Avoidance 19:** Don''t define your own operator new function unless you''re
    sure what you''re doing. If you are sure you know what you''re doing, make sure
    you''re really really sure. Even then don''t do it unless it''s absolutely necessary.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免19：除非你确定自己在做什么，否则不要定义自己的operator new函数。如果你确定你知道自己在做什么，确保你真的真的确定。即使如此，除非绝对必要，否则也不要这样做。**'
- en: '**Answer 57:** The problem is that there are two variable declarations:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案57：问题是存在两个变量声明：**'
- en: '*File: main.cpp*'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件：main.cpp*'
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '*File: check.cpp*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件：check.cpp*'
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'That means that the value is set to 20 or 30\. But which one? The result is
    compiler-dependent. If you want value to be local to the files in which they are
    declared, you need to declare them static:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着值被设置为20或30。但哪一个？结果是编译器依赖的。如果你想使值在它们声明的文件中局部化，你需要将它们声明为static：
- en: '*File: main.cpp*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件：main.cpp*'
- en: '[PRE96]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '*File: check.cpp*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件：check.cpp*'
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Or better yet, give them two different names.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是，给它们两个不同的名字。
- en: '**Answer 58:** According to the C++ standard, once you define a derived class
    member function with the same name as a base class''s member function, all member
    functions of that name are hidden:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案58：根据C++标准，一旦你定义了一个与基类成员函数同名派生类成员函数，所有同名的成员函数都将被隐藏：**'
- en: 'So der::print_it(float) hides both base: :print_it(float) and base: :print_it(int).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 所以der::print_it(float)隐藏了base::print_it(float)和base::print_it(int)。
- en: When we call print_it(2) C++ looks for aversion of print_it it can use. The
    only visible print_it is der::print_it(float). C++ would rather have a function
    that takes **int** as its argument, but it knows how to turn an **int** into a
    **float,** so it promotes 2 to 2.0 and uses der::print_it(float).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用print_it(2)时，C++会寻找它可以使用的print_it版本。唯一可见的print_it是der::print_it(float)。C++更愿意有一个以**int**作为参数的函数，但它知道如何将**int**转换为**float**，所以它将2提升为2.0并使用der::print_it(float)。
- en: '**Answer 59:** The problem is that we didn''t define a copy constructor. When
    that happens, C++ defines one for you and generally does a bad job of it.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案59：问题是我们没有定义拷贝构造函数。当这种情况发生时，C++会为你定义一个，但通常做得不好。**'
- en: 'The copy constructor is defined as:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝构造函数定义为：
- en: '[PRE98]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The copy constructor is called to create a copy of an_array for the function
    store_it. The pointer to the data is copied.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝构造函数被调用以创建一个用于store_it函数的_an_array_的副本。数据指针被复制。
- en: When var_array::^~var_array is called at the end of pushy, it returns the data
    to the heap.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当在pushy的末尾调用var_array::^~var_array时，它将数据返回到堆中。
- en: When var_array::^~var_array is called at the end of main, it returns the same
    data to heap. Because we delete the same memory twice, the result is a corrupt
    heap.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当在main函数的末尾调用var_array::^~var_array时，它将相同的数据返回到堆中。因为我们删除了相同的内存两次，结果是堆损坏。
- en: '**Avoidance 20:** Always declare a copy constructor in some way or other. The
    three major was are:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免20：以某种方式始终声明一个拷贝构造函数。主要有三种方式：**'
- en: Implicitly declare it.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐式声明它。
- en: 'If you never want anyone to be able to call it, declare it private:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你永远不希望任何人能够调用它，将其声明为private：
- en: '[PRE99]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If the default works, use the comment:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果默认设置有效，使用注释：
- en: '[PRE100]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: in your program. That way you tell people reading your code that you thought
    about it and know that the C++ default will not be a problem.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中。这样，你告诉阅读你代码的人你已经考虑过这个问题，并且知道C++的默认设置不会成问题。
- en: '**Answer 60:** The programmer has a very bad habit of not closing files after
    opening them. Pretty soon the maximum number of files are opened and the system
    won''t let him open any more.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案60：程序员有一个非常不好的习惯，那就是在打开文件后不关闭它们。很快，打开的文件数达到最大，系统不再允许他打开更多的文件。**'
- en: 'Closes needed to be added at key points in the code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在代码的关键点添加关闭语句：
- en: '[PRE101]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Also the programmer uses opendir to open a directory. He never closes it. So
    a closedir is needed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，程序员使用opendir打开一个目录。他从未关闭它。所以需要一个closedir。
- en: '[PRE102]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Answer 61:** The problem is that the statement:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案61：问题是这个语句：'
- en: '[PRE103]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'tells C++ that the *pointer* is volatile. The data being pointed to is not
    volatile. The result is that the optimizer still optimizes us out of existence.
    The solution is to place the volatile where it modifies the data being pointed
    to. We also have added a const to the declaration to make sure that the pointer
    can''t be modified. The resulting declarations are:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉C++，*指针*是易变的。被指向的数据不是易变的。结果是，优化器仍然将我们优化掉。解决方案是将volatile放在它修改的数据处。我们还添加了一个const到声明中，以确保指针不能被修改。结果声明是：
- en: '[PRE104]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This tells C++:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉C++：
- en: in_port_ptr is a const pointer and cannot be modified.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: in_port_ptr是一个const指针，不能被修改。
- en: '*in_port_ptr is a volatile char whose value can be changed outside the normal
    C++ programming rules.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*in_port_ptr是一个易变的char，其值可以在正常的C++编程规则之外被改变。'
- en: '**Answer 62:** The problem is that the comment:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案62：** 问题在于注释：'
- en: '[PRE105]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'does not contain a close comment. So it continues engulfing the statement below
    it:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 不包含一个关闭注释。因此，它继续吞噬下面的语句：
- en: '[PRE106]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: From this it's easy to see why height was not set.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里很容易看出为什么没有设置高度。
- en: '**Answer 63:** The problem is that getchar returns an int. We are assigning
    it to a character. Some systems treat characters as unsigned characters. The result
    is that when we get EOF (-1) the system assigns'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案63：** 问题在于getchar返回一个int。我们将其赋值给一个字符。一些系统将字符视为无符号字符。结果是，当我们得到EOF（-1）时，系统将其分配'
- en: '[PRE107]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: or ch = 0xFF. It then compares the 0xFF to -1 (they are not the same) and does
    not exit the loop.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 或者ch = 0xFF。然后它将0xFF与-1（它们不相同）进行比较，并且不会退出循环。
- en: 'This program is also a stylistic disaster. The goal of every C++ programmer
    should be writing a clear program. This program was written to be compact. A much
    better program is:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序也是一个风格上的灾难。每个C++程序员的目标应该是编写一个清晰的程序。这个程序是为了紧凑而编写的。一个更好的程序是：
- en: '[PRE108]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '**Answer 64:** The output is:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案64：** 输出是：'
- en: '[PRE109]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The reason for this is that although we have two pointers, they both point
    to one variable name. When tmp_name is called the first time:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是，尽管我们有两个指针，但它们都指向一个变量名。当tmp_name第一次被调用时：
- en: '[PRE110]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'After the second call:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用之后：
- en: '[PRE111]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'But a_name also points to name so:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 但a_name也指向name，所以：
- en: '[PRE112]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The second call overwrote storage that was being used to hold the result of
    the first call.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用覆盖了用于存储第一次调用结果的存储空间。
- en: One solution to this is to copy the string after each call or to have the caller
    provide his own character array for name storage.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是在每次调用后复制字符串，或者让调用者提供自己的字符数组来存储名称。
- en: Another solution is to use C++ style strings that handle their own memory allocation.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是使用处理自己的内存分配的C++风格字符串。
- en: '**Answer 65:** Every put is followed by a flush. This means that a system call
    is made for each character output. System calls are expensive and take up a lot
    of CPU time.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案65：** 每个put后面都跟着一个flush。这意味着每个字符输出都会进行系统调用。系统调用很昂贵，并且占用大量的CPU时间。'
- en: In other words, although the I/O library is designed for buffered I/O, the excessive
    flush calls for it to do unbuffered I/O one character at a time.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，尽管I/O库是为缓冲I/O设计的，但过多的flush调用会导致它逐个字符进行无缓冲I/O。
- en: 'We need to flush at the end of each block to make sure that the remote system
    receives a full block. That''s *block,* not *character,* so we can speed up the
    system by moving the flush down to after the block is sent:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每个块的末尾刷新，以确保远程系统接收到一个完整的块。那是*块*，不是*字符*，因此我们可以通过将flush移动到块发送之后来加快系统速度：
- en: '[PRE113]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '**Answer 66:** The setjmp marks a location in the code. The longjmp call jumps
    to it. It jumps directly to it, it does not pass go, it does not collect $200\.
    It also skips all the destructors for all the variables on the stack. In this
    case, because the destructor for std::string returns the memory allocated for
    the string, we have a memory leak.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案66：** setjmp在代码中标记了一个位置。longjmp调用跳转到它。它直接跳转到它，不经过go，不收集$200。它还跳过了堆栈上所有变量的析构函数。在这种情况下，因为std::string的析构函数返回字符串分配的内存，所以我们有一个内存泄漏。'
- en: That's because the setjmp and longjmp functions are C functions that should
    not be used in C++.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 那是因为setjmp和longjmp函数是C函数，不应该在C++中使用。
- en: '**Avoidance 21:** Do not use setjmp and longjmp in a C++ program. Use exceptions
    instead.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免21：** 不要在C++程序中使用setjmp和longjmp。使用异常代替。'
- en: '**Answer 67:** In the default case:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案67：** 在默认情况下：'
- en: '[PRE114]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The "default" keyword is misspelled. The result is that the C++ compiler thinks
    that "defualt" is a goto label.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '"default"关键字拼写错误。结果是，C++编译器认为"defualt"是一个goto标签。'
- en: '**Answer 68:** The printf function buffers its output. It won''t actually write
    anything until the buffer gets full or a newline is sent.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 68：** printf 函数缓冲其输出。它实际上不会写入任何内容，直到缓冲区满或发送换行符。'
- en: So the program hits the printf, the "Starting" message goes into the buffer
    and not to the screen, and the function average is executed and gets a divide
    by zero error.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序遇到 printf，"开始" 消息进入缓冲区而不是屏幕，并且 average 函数执行并得到除以零错误。
- en: The result is that the "Starting" message is lost, making us think that average
    was never called.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，“开始”消息丢失，让我们以为平均函数从未被调用过。
- en: 'The solution to this problem is to flush the buffer explicitly after the starting
    message:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是显式地在开始消息后刷新缓冲区：
- en: '[PRE115]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '|  | Warning  | The rules for when a buffer gets flushed change depending on
    the type of file being written. The rules are:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 警告  | 缓冲区刷新的规则取决于正在写入的文件类型。规则如下：'
- en: '*If* *stdout* *or* *stderr* *are being written to the screen then the output
    is buffered until:*'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如果* *stdout* *或* *stderr* *正在写入屏幕，则输出将被缓冲，直到：*'
- en: '*When a line is written.*'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*当写入一行时。*'
- en: '*When* *stdin* *is read.*'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*当* *stdin* *被读取时。*'
- en: '*When the buffer gets full.*'
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*当缓冲区满时。*'
- en: '*If* *stdout* *or* *stderr* *are being written to a disk then the output is
    buffered until:*'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*如果* *stdout* *或* *stderr* *正在写入磁盘，则输出将被缓冲，直到：*'
- en: '*When the buffer gets full.*'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*当缓冲区满时。*'
- en: '|'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: (These are the rules you'll probably find on your system. The actual rules are
    system-dependent.)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: （这些可能是你系统上的规则。实际的规则是系统相关的。）
- en: '**Answer 69:** The problem is the programmer wrote:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 69：** 问题在于程序员编写了：'
- en: '[PRE116]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'instead of:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE117]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'so the output is literally:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出实际上是：
- en: '[PRE118]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '**Answer 70:** The problem is the statement:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 70：** 问题在于以下语句：'
- en: '[PRE119]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The statement checks the data pointed to by cur_cmd->cmd, then checks to see
    if cur_cmd->cmd is valid. On some systems, dereferencing NULL (which we do if
    we are at the end of the list) causes core dumps.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句检查 cur_cmd->cmd 指向的数据，然后检查 cur_cmd->cmd 是否有效。在某些系统上，解引用 NULL（如果我们处于列表的末尾，我们会这样做）会导致核心转储。
- en: On MS-DOS and other brain-damaged systems, there is no memory protection, so
    dererferencing NULL is allowed, although you get strange results. Microsoft Windows
    fixed this, and dereferencing a NULL pointer will result in a General Protection
    Fault (GPF).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MS-DOS 和其他脑损伤系统上，没有内存保护，因此允许解引用 NULL，尽管你会得到奇怪的结果。微软 Windows 修复了这个问题，解引用 NULL
    指针将导致一般保护故障 (GPF)。
- en: 'The loop should be written:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 循环应该这样编写：
- en: '[PRE120]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'But even this is tricky. The statement depends on the C++ standard being correctly
    implemented. That C++ standard states that for && the first part is evaluated.
    If the first term is false, the second term is skipped. Just to be safe, it''s
    better to write this as:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使这样也很棘手。该语句取决于 C++ 标准是否正确实现。该 C++ 标准指出，对于 &&，第一部分将被评估。如果第一个项为假，则跳过第二个项。为了安全起见，最好写成这样：
- en: '[PRE121]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '**Answer 71:**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 71：**'
- en: '**Alignment**'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对齐**'
- en: Some machines require that long integer values line up on a 2-byte or 4-byte
    boundary. Some do not. C++ will insert padding in the structure to make things
    line up.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器要求长整数值对齐在 2 字节或 4 字节边界上。一些则不需要。C++ 将在结构中插入填充以使对齐。
- en: 'So on one machine, the structure will be:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一台机器上，结构将是：
- en: '[PRE122]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'for a total of 5 bytes. While on another it may be:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 总共 5 个字节。而在另一台机器上可能如下：
- en: '[PRE123]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: for a total of 8 bytes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 总共 8 个字节。
- en: '**Byte order**'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**字节顺序**'
- en: Some machines write out long integers using the byte order ABCD. Others use
    DCBA. This prevents things from being portable.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一些机器使用 ABCD 的字节顺序写入长整数。而另一些使用 DCBA。这阻止了可移植性。
- en: '**Integer size**'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**整数大小**'
- en: The 64-bit machines are coming. That means that on some systems a long int is
    64 bits, not 32.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 64 位机器正在到来。这意味着在某些系统上，长整型是 64 位，而不是 32 位。
- en: '**Answer 72:** We have an array of a derived class called safe stack. In C++,
    you can use a base class pointer (stack*) to point to a derived class (safe_stack).
    The system will see only the base part of the object, but you can still point
    to it.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 72：** 我们有一个名为 safe stack 的派生类数组。在 C++ 中，你可以使用基类指针（stack*）来指向派生类（safe_stack）。系统将只看到对象的基部分，但你仍然可以指向它。'
- en: '[![Click To expand](fig257_01.jpg)](fig257_01_0.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig257_01.jpg)](fig257_01_0.jpg)'
- en: Now a pointer can point to a single instance of a class or an array of objects.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在指针可以指向一个类的单个实例或对象的数组。
- en: '[![Click To expand](fig257_02.jpg)](fig257_02_0.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig257_02.jpg)](fig257_02_0.jpg)'
- en: 'So we have the following two rules:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有以下两个规则：
- en: A base pointer can point to a derived object.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基指针可以指向派生对象。
- en: An object pointer can point to an array of objects.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象指针可以指向对象的数组。
- en: 'From this, we can conclude:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个结论中，我们可以得出：
- en: A base pointer can point to an array of derived objects.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基指针可以指向派生对象的数组。
- en: That's wrong.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的。
- en: The problem is that an array of derived objects is not the same as an array
    of base objects.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于派生对象的数组与基类对象的数组并不相同。
- en: '[![Click To expand](fig257_03.jpg)](fig257_03_0.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig257_03.jpg)](fig257_03_0.jpg)'
- en: So if we take a base pointer and point it a derived array, the memory layout
    will be wrong.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们用一个基指针指向派生数组，内存布局将会错误。
- en: '[![Click To expand](fig258_01.jpg)](fig258_01_0.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig258_01.jpg)](fig258_01_0.jpg)'
- en: '**Avoidance 22:** Use the STL vector template instead of an array. It avoids
    a lot of problems.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免22**：使用STL向量模板而不是数组。它可以避免很多问题。'
- en: '**Avoidance 23:** Do not pass base-class arrays as parameters.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免23**：不要将基类数组作为参数传递。'
- en: '**Answer 73:** The problem is how the compiler generates machine code for program.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案73**：问题在于编译器如何为程序生成机器代码。'
- en: 'The statement:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 语句：
- en: '[PRE124]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'generates something like:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 生成如下：
- en: '[PRE125]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In this example fp_0 and fp_1 are floating-point registers. In floating-point
    coprocessors, the registers have the largest precision available. So in this case,
    while the numbers may be only 32-bit, the floating-point processor does things
    in 80 bits, resulting in a high precision being reported.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，fp_0和fp_1是浮点寄存器。在浮点协处理器中，寄存器具有可用的最大精度。因此，在这种情况下，虽然数字可能只有32位，但浮点处理器以80位进行操作，从而报告出高精度。
- en: This sort of problem occurs on most machines with a floating-point processor.
    On the other hand, if you have an old machine that uses software to do the floating-point,
    you'll probably get the right answer. That's because, in general, software floating-point
    uses only enough bits to do the work.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题在大多数具有浮点处理器的机器上都会发生。另一方面，如果你有一个使用软件进行浮点运算的旧机器，你可能会得到正确答案。这是因为，通常，软件浮点运算只使用足够的位来完成工作。
- en: 'To fix the program, we need to turn the main loop into:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复程序，我们需要将主循环转换为：
- en: '[PRE126]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '**Answer 74:** The problem is that the words are stored in the input file in
    alphabetical order and the tree is unbalanced. Thus, when words are inserted the
    following data structure is built up:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案74**：问题在于单词按字母顺序存储在输入文件中，而树是不平衡的。因此，当插入单词时，会构建以下数据结构：'
- en: '[![Click To expand](fig259_01.jpg)](fig259_01_0.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig259_01.jpg)](fig259_01_0.jpg)'
- en: The result is that we have a linked list, not a tree. Words are added to the
    end of the linked list (expensive), and lookups are done by linear search (also
    expensive).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们得到一个链表，而不是树。单词被添加到链表的末尾（代价高昂），并且通过线性搜索进行查找（同样代价高昂）。
- en: A balanced binary tree would solve this problem.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡二叉树可以解决这个问题。
- en: '**Answer 75:** The problem is that we have in our code the statement:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案75**：问题在于我们的代码中有以下语句：'
- en: '[PRE127]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This is disguised as:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这被伪装成：
- en: '[PRE128]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The operator = function deletes the data of the destination array. That's fine
    except that the source array is the same stack, so its data gets destroyed, too.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符=函数删除目标数组的数据。这很好，除非源数组是同一栈，因此其数据也会被销毁。
- en: 'The answer is to check explicitly for self-assignment in the operator = function:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是显式检查操作符=函数中的自赋值：
- en: '[PRE129]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '**Avoidance 24:** The operator = function should check for self-assignment.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免24**：操作符=函数应检查自赋值。'
- en: '**Answer 76:** The problem is that strcmp returns 0 if the strings are equal
    and non-zero otherwise. That means that if you have the statement:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案76**：问题在于strcmp在字符串相等时返回0，否则返回非零值。这意味着如果你有如下语句：'
- en: '[PRE130]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The if will execute only if the strings are *not* equal.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当字符串**不**相等时，if语句才会执行。
- en: '**Avoidance 25:** Use'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免25**：使用'
- en: '[PRE131]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: to test if two strings are equal. It's clearer than if (strcmp(x,y), and it
    works.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 来测试两个字符串是否相等。这比if (strcmp(x,y))更清晰，并且它有效。
- en: '**Avoidance 26:** Whenever possible, use the C++ string class instead of the
    old C style strings. That way you can use the relational operators (<,>, ==, etc.)
    instead of strcmp.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免26**：尽可能使用C++字符串类而不是旧的C风格字符串。这样，你可以使用关系运算符（<,>, ==等）而不是strcmp。'
- en: '**Answer 77:** The problem is the code:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案77**：问题在于以下代码：'
- en: '[PRE132]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: It deletes data, then uses it. After things are deleted, they really should
    go away.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 它删除了数据，然后又使用了它。在删除之后，它们真的应该消失。
- en: '**Avoidance 27:** Always set a pointer to NULL after delete or free.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免27**：在删除或释放后，始终将指针设置为NULL。'
- en: 'When the code is written with a little bit of added protection, the problem
    is obvious:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码带有一些额外的保护时，问题就很明显了：
- en: '[PRE133]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Also, because of the added protection of setting first to NULL, if we do attempt
    to use the pointer, we will abort in a well-defined manner (on most systems).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Also, because of the added protection of setting first to NULL, if we do attempt
    to use the pointer, we will abort in a well-defined manner (on most systems).
- en: '**Answer 78:** The types of the variables are:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案78**：变量的类型是：'
- en: sam is a character pointer (char *).
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sam是一个字符指针（char *）。
- en: joe is a character (char).
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: joe是一个字符（char）。
- en: 'The declaration, after the preprocessor gets through with it results in:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器处理后的声明结果为：
- en: '[PRE134]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '**Avoidance 28:** Use typedef to define new types, not #define.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免28**：使用typedef定义新类型，而不是使用#define。'
- en: '**Answer 79:** C++ has no ** operator. (At least for integers.) So (12 ** 2)
    is an invalid construct.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案79**：C++没有**运算符。（至少对于整数。）所以(12 ** 2)是一个无效的结构。'
- en: The trouble is that this bad syntax is hidden in a preprocessor macro that's
    not expanded until line 16\. That's why line 16 is the one with the syntax error.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这种糟糕的语法被隐藏在一个直到第16行才展开的预处理器宏中。这就是为什么第16行有语法错误。
- en: '**Avoidance 29:** Use const instead of preprocessor macros whenever possible.
    The statement:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免29**：尽可能使用const代替预处理器宏。以下语句：'
- en: '[PRE135]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: would still generate an error message, but at least the line number would be
    right.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然会生成错误消息，但至少行号是正确的。
- en: '**Answer 80:** The problem is that the result of a comparison is an integer
    1 or 0\. So the expression:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案80**：问题是比较的结果是一个整数1或0。所以表达式：'
- en: '[PRE136]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: becomes
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: becomes
- en: '[PRE137]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Because a is greater than b, the result of a > b is 1, so we now have
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 因为a大于b，所以a > b的结果是1，所以我们现在有
- en: '[PRE138]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: which is false, so the else clause is executed.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这是错误的，所以else子句被执行。
- en: '**Answer 81:** The programmer suspects that something funny is happening when
    data item #500 is read. He wants to put a breakpoint right before this item is
    read.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案81**：程序员怀疑在读取数据项#500时发生了奇怪的事情。他希望在读取这个项目之前设置一个断点。'
- en: The trouble is that if he puts a breakpoint at the top of get_data, he will
    have to do 500 debugger continue commands before he reaches the point he wants.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果他将在get_data的顶部设置断点，他将不得不执行500个调试器继续命令，才能到达他想要的位置。
- en: 'So he puts his breakpoint at the line:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 所以他在这一行设置断点：
- en: '[PRE139]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|  | Note  | The fancier debuggers allow the user to set a skip count to skip
    the first *x* number of breakpoint stops. Our friendly programmer doesn''t have
    such a nice tool. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | 更高级的调试器允许用户设置跳过计数以跳过前*x*个断点停止。我们友好的程序员没有这样的工具。 |'
- en: '**Answer 82:** The programmer used semicolons to end the #define declaration.
    Because the preprocessor is rather literal about things, the semicolon becomes
    part of the text. The result is that USABLE is defined as:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案82**：程序员使用分号来结束#define声明。因为预处理器对事物相当字面，分号变成了文本的一部分。结果是USABLE被定义为：'
- en: '[PRE140]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The initialization of text_width now becomes
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: text_width的初始化现在变为
- en: '[PRE141]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: or, properly indented,
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，正确缩进后，
- en: '[PRE142]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: From this we can see our problem.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看到我们的问题。
- en: '**Avoidance 30:** Use const instead of #define whenever possible.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免30**：尽可能使用const代替#define。'
- en: '**Answer 83:** The problem is the buffer is a local variable. That means that
    it goes away at the end of the function call. Unfortunately, printf doesn''t know
    this, so it will still stuff data into it afterwards.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案83**：问题是缓冲区是一个局部变量。这意味着它在函数调用结束时消失。不幸的是，printf不知道这一点，所以它仍然会在之后填充数据。'
- en: The
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: The
- en: '[PRE143]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: will still try to use the local variable.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然会尝试使用局部变量。
- en: 'To fix this problem declare the buffer as static:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，将缓冲区声明为静态：
- en: '[PRE144]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '**Answer 84:** The problem is the optimizer. The optimizer knows that the variable
    debugging is zero. It''s always zero.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案84**：问题是优化器。优化器知道变量debugging为零。它始终为零。'
- en: 'Now that we know that, let''s take a look at the statement:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这一点，让我们看看这个语句：
- en: '[PRE145]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This is always false, because debugging is always zero. So this block is never
    executed. That means that we can optimize the code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这总是错误的，因为调试始终为零。所以这个块永远不会被执行。这意味着我们可以优化代码：
- en: '[PRE146]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'into the statement:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: into the statement：
- en: '[PRE147]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Now let's look at the number of times debugging is used. It's initialized on
    line 11 and used on line 13\. Line 13 is optimized out, so debugging is never
    used. If a variable is never used, it can be optimized out.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看调试使用的次数。它在第11行初始化，并在第13行使用。第13行被优化掉了，所以调试从未被使用。如果一个变量从未被使用，它可以被优化掉。
- en: 'The result is an optimized program that looks like:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个看起来像这样的优化程序：
- en: '[PRE148]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now our programmer wanted to use the debugging variable to help him debug things.
    The trouble is there is no debugging variable after optimization.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序员想使用调试变量来帮助他调试问题。问题是优化后没有调试变量。
- en: The problem is that C++ didn't know that the programmer was going to use magic
    (a debugger) to change variables behind its back. If you plan on doing something
    like this, you must tell the compiler. This is done by declaring the debugging
    variable volatile.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于C++不知道程序员打算使用魔法（调试器）在背后更改变量。如果你打算这样做，你必须告诉编译器。这是通过声明调试变量volatile来完成的。
- en: '[PRE149]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The "volatile" keyword tells C++, "Something strange such as an interrupt routine,
    a debugger command, or something else may change this variable behind your back.
    You can make no assumptions about its value."
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '"volatile"关键字告诉C++，“某些奇怪的事情，如中断例程、调试器命令或其他事情，可能会在背后更改这个变量。你不能对其值做出任何假设。”'
- en: '**Answer 85:** The printf statement:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案85**：printf语句：'
- en: '[PRE150]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: tells C to print an integer, but fails to supply one. The printf function doesn't
    know this, so it will take the next number off the stack (some random number)
    and print it.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉C打印一个整数，但未能提供。printf函数不知道这一点，所以它会从堆栈中取出下一个数字（某个随机数字）并打印它。
- en: 'What the programmer should have written is:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该写的是：
- en: '[PRE151]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '**Answer 86:** The problem is the use of matrix[1,2]. The comma operator in
    C++ merely returns the result of the second part. So the expression "1,2" tells
    C++ throw the first part (1) away and the value is 2\. So matrix[1,2] is really
    matrix[2]. This is a pointer into an integer array, and C++ will treat it as a
    pointer for printing. That''s why strange values get printed.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案86**：问题是使用了matrix[1,2]。C++中的逗号运算符仅仅返回第二部分的结果。所以表达式"1,2"告诉C++扔掉第一部分（1），值是2。所以matrix[1,2]实际上是matrix[2]。这是一个指向整数数组的指针，C++会将其视为指针进行打印。这就是为什么打印出奇怪值的原因。'
- en: 'What the programmer really wanted is:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员真正想要的是：
- en: '[PRE152]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '**Answer 87:** The prefix version of ++ returns the number after incrementing.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案87**：前缀++的版本返回增加后的数字。'
- en: Thus
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '[PRE153]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: tells C++ increment i, returns the result, then increments the variable i again.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉C++增加i，返回结果，然后再次增加变量i。
- en: The postfix version of ++ (i++) returns a copy of the variable, then increments
    it.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀++（i++）的版本返回变量的副本，然后增加它。
- en: So
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 所以
- en: '[PRE154]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Tells C++ to make a copy of i (call it tmp_1)
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉C++复制i（称为tmp_1）。
- en: Increments i
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i。
- en: Does the rest of the work on tmp_1
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在tmp_1上完成其余的工作。
- en: Makes a copy of tmp_1 (call it tmp_2)
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制tmp_1（称为tmp_2）。
- en: Increments tmp_2
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加tmp_2。
- en: Returns tmp_1 as the value of the expression
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将tmp_1作为表达式的值返回。
- en: '|  | Note  | C++ won''t let you get away with ++++ on integers. Only with some
    added class silliness can you get away with it. |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | C++不会让你在整数上使用++++。只有通过一些额外的类愚蠢行为，你才能逃脱。|'
- en: '**Avoidance 31:** Use ++ and -- singly.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免31**：单独使用++和--。'
- en: '**Answer 88:** The problem is the macro:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案88**：问题是这个宏：'
- en: '[PRE155]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: when called with
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时
- en: '[PRE156]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This expands to
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这展开为
- en: '[PRE157]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This increments number twice, instead of once as the programmer intended. What's
    worse, the compiler can make some decisions as to the order in which the various
    operations are done; therefore, the result of this expression is compiler-dependent.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 这两次增加了数字，而不是程序员想要的增加一次。更糟糕的是，编译器可以就各种操作的顺序做出一些决定；因此，这个表达式的结果是编译器依赖的。
- en: '**Avoidance 32:** Use **inline** functions instead of parameterized macros.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免32**：使用**内联**函数而不是参数化宏。'
- en: '**Avoidance 33:** Put ++ and - on lines by themselves.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免33**：将++和-放在单独的行上。'
- en: '**Answer 89:** The optimizer knows that although the subroutine computes the
    value of result, it does nothing with it. So the program will work the same whether
    or not result is computed. Thus, the optimizer takes a look at the loop:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案89**：优化器知道尽管子程序计算了result的值，但它没有对它做任何事情。所以程序是否计算result都会工作相同。因此，优化器查看循环：'
- en: '[PRE158]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'is optimized down:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 被优化：
- en: '[PRE159]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Of course we don''t need to do nothing 1,863 times, so this is optimized down
    to:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不需要做1,863次无意义的事情，所以这被优化为：
- en: '[PRE160]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This is about as optimized as you can get. The way to keep the optimizer from
    doing this to us is to declare the variable result is volatile. Program 110 shows
    what happens when you add this fix.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最优化的程度。要防止优化器这样做，我们需要声明变量result是volatile。程序110显示了添加此修复后会发生什么。
- en: '**Answer 90:** C++ uses zero-based indexing. So for array [5] the valid elements
    are:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案90**：C++使用零基索引。所以对于数组[5]，有效的元素是：'
- en: '[PRE161]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The programmer, however, uses the elements 1-5\. There is no array [5], so the
    program modifies random memory, causing the memory corruption.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序员使用的是元素 1-5。没有数组 [5]，所以程序修改了随机内存，导致内存损坏。
- en: 'That''s why most C++ programs don''t use statements like:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么大多数 C++ 程序不使用类似以下语句：
- en: '[PRE162]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Instead they count using:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 他们使用以下方式计数：
- en: '[PRE163]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '**Answer 91:** The problem is that with the statement:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 91**：问题是这个语句：'
- en: '[PRE164]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'the first /* (the one in the middle of the statement) starts a comment; it
    does not do a divide. So this statement is:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 /*（位于语句中间的）开始了一个注释；它不会进行除法。因此，这个语句是：
- en: '[PRE165]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '**Avoidance 34:** Put spaces around operators. It not only avoids problems
    but also makes the program easier to read.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 34**：在运算符周围留空格。这不仅避免了问题，还使程序更容易阅读。'
- en: '[PRE166]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '**Answer 92:** The problem is that a thread switch can occur at any time.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 92**：问题是线程切换可以在任何时候发生。'
- en: 'The writer will remove a character from the buffer when count > 0\. The reader
    performs the two steps:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当计数 > 0 时，写者将从缓冲区中删除一个字符。读者执行以下两个步骤：
- en: '[PRE167]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: But a thread switch can occur between these two steps.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 但线程切换可能发生在这两个步骤之间。
- en: 'Therefore, the following can happen:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下情况可能发生：
- en: '[PRE168]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: A solution is to change the sequence of the steps
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是改变步骤的顺序
- en: '[PRE169]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: to
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE170]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Depending on the sequence of instructions to protect shared data is difficult
    and tricky.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 根据保护共享数据的指令序列，很难且复杂。
- en: 'It is much better and simpler is to tell the task manager when you are doing
    a set of statements that can''t be interrupted. In pthreads, this is done with
    a mutex lock:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 更好、更简单的方法是在执行一组无法中断的语句时告诉任务管理器。在 pthreads 中，这是通过互斥锁来实现的：
- en: '[PRE171]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '**Answer 93:** Member variables are initialized in *declaration* order.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 93**：成员变量按声明顺序初始化。'
- en: 'In this case, the statements:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，以下语句：
- en: '[PRE172]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'are executed in declaration order: 1) area, 2) width, 3) height. This means
    that area is initialized with undefined values of width and height, and then width
    and height are initialized.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明顺序中执行：1) 区域，2) 宽度，3) 高度。这意味着区域使用未定义的宽度和高度值进行初始化，然后宽度和高宽度进行初始化。
- en: '**Avoidance 35:** Write constructors so that variables are initialized in the
    order in which they are declared. (If you don''t do this, the compiler will do
    it for you and cause confusion.)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 35**：编写构造函数，使变量按声明的顺序初始化。（如果你不这样做，编译器会为你做，并导致混淆。）'
- en: '**Avoidance 36:** Never use member variables to initialize other member variables.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 36**：永远不要使用成员变量来初始化其他成员变量。'
- en: '**Answer 94:** In K&R style functions, the parameter declarations come immediately
    *before* the first curly brace.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 94**：在 K&R 风格的函数中，参数声明紧接在第一个花括号之前。'
- en: 'That means that the declaration:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下声明：
- en: '[PRE173]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: declares three parameters of default (int) type. Anything after that is declared
    as a local variable.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 声明三个默认（int）类型的参数。之后声明的任何内容都被视为局部变量。
- en: In particular
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是
- en: '[PRE174]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The result is instead of summing three parameters, the program adds three uninitialized
    local variables. No wonder we get a strange result.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，程序不是对三个参数求和，而是对三个未初始化的局部变量求和。难怪我们得到了一个奇怪的结果。
- en: '**Answer 95:** The problem is the statement:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 95**：问题是这个语句：'
- en: '[PRE175]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The sscanf function takes pointers as its arguments. (Remember C doesn''t check
    arguments for the correct type.) In this case, we gave sscanf a character and
    an integer. We should have given it a pointer to a character and a pointer to
    an integer:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: sscanf 函数接受指针作为其参数。（记住 C 语言不会检查参数的正确类型。）在这种情况下，我们给了 sscanf 一个字符和一个整数。我们应该给它一个字符指针和一个整数指针：
- en: '[PRE176]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '**Answer 96:** The program use raw I/O to do its work (using the read and write
    system calls). This program does one raw read and raw write for each character.
    Operating calls are expensive, and this program uses 2 (one read and one write)
    per byte copied.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 96**：程序使用原始 I/O 来完成其工作（使用 read 和 write 系统调用）。这个程序对每个字符进行一次原始读取和一次原始写入。操作调用很昂贵，而这个程序每复制一个字节就使用
    2 次（一次读取和一次写入）。'
- en: 'To speed up the program, cut down on the operating system calls. This can be
    done two ways:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快程序速度，减少操作系统调用。这可以通过两种方式实现：
- en: Use the buffered I/O system by making the input and output fstreams instead
    of file descriptors.
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将输入和输出 fstreams 而不是文件描述符来使用缓冲 I/O 系统。
- en: Read and write more than one character at a time.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次读取和写入多个字符。
- en: '**Answer 97:** The problem is the statement:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 97**：问题在于这个陈述：'
- en: '[PRE177]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: There is no semicolon after the /* do nothing */ statement.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在 /* do nothing */ 语句之后没有分号。
- en: 'The return is part of the for statement. The code should look like this after
    it is indented properly:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 返回是 for 语句的一部分。代码在正确缩进后应该看起来像这样：
- en: '[PRE178]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: From this code section we can see that the first time through, the for loop
    index will be zero and the return taken. That's why all the strings are of zero
    length.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中我们可以看到，第一次循环时，for 循环的索引将是零，并执行返回操作。这就是为什么所有字符串的长度都是零的原因。
- en: 'What the programmer wanted was:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员想要的是：
- en: '[PRE179]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '**Answer 98:** The problem is that class is allocated not by the C++ new operator,
    but instead uses the old style C malloc operator. This creates the space for the
    class without calling the constructor.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 98：** 问题在于类不是由 C++ new 操作符分配的，而是使用旧的 C malloc 操作符。这为类创建了空间，但没有调用构造函数。'
- en: Then just to add insult to injury, memset is called to zero the class.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了更添乱，memset 被调用以将类清零。
- en: '[PRE180]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'What the programmer should have written is:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员应该写的是：
- en: '[PRE181]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '|  | Note  | The author first found this problem in a large library he was
    trying to debug. Because of the large size of the library and the complexity of
    the mess, it took him a week to find the location of the *malloc*. |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | 作者首先在一个他试图调试的大型库中发现了这个问题。由于库的大小很大，混乱很复杂，他花了一个星期才找到 *malloc* 的位置。
    |'
- en: '**Answer 99:** The statement:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 99：** 语句：'
- en: '[PRE182]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: does not send a character to the output. Regardless of its name, the ch variable
    is of type integer. The result is that the integer is printed to the output. That's
    why the output file is full of integers.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 并不会向输出发送字符。无论其名称如何，ch 变量都是整型。结果是整数被打印到输出。这就是为什么输出文件充满了整数。
- en: 'This is the one case in which C++''s automatic type detection of output parameters
    gets in your way. The old C printf statement would handle things correctly like:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C++ 自动输出参数类型检测会阻碍你的一个情况。旧的 C printf 语句会正确处理：
- en: '[PRE183]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'But with C++ you must cast to get the correct results in this case:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 但在使用 C++ 时，你必须进行类型转换才能得到这种情况下的正确结果：
- en: '[PRE184]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '**Answer 100:** The program outputs:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 100：** 程序输出：'
- en: '[PRE185]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The problem is that the readdir returns a pointer to static data. This data
    is owned by readdir and overwritten by subsequent calls.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是 readdir 返回的是指向静态数据的指针。这些数据由 readdir 拥有，并被后续调用覆盖。
- en: 'So what happens is this: We call scan_dir and set first_ptr to point to the
    string first. That''s what we want, but the array containing the name is static
    and when we call readdir again, it uses the same buffer to store the name second.
    So now first_ptr points to second, which is the cause of our trouble.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 所以发生的情况是这样的：我们调用 scan_dir 并将 first_ptr 设置为指向字符串 first。这正是我们想要的，但包含名称的数组是静态的，当我们再次调用
    readdir 时，它使用相同的缓冲区来存储第二个名称。因此，现在 first_ptr 指向 second，这就是我们遇到麻烦的原因。
- en: '[![Click To expand](fig269_01.jpg)](fig269_01_0.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[![点击展开](fig269_01.jpg)](fig269_01_0.jpg)'
- en: '**Answer 101:** In the base class destructor, we call the function clear.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 101：** 在基类析构函数中，我们调用 clear 函数。'
- en: This function calls a pure virtual function, delete_data.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用了一个纯虚函数，delete_data。
- en: During destruction, the derived class gets deleted first. When the derived class
    goes, so does the definition of delete_data. Next, the base class destructor is
    called. In this case, our list class indirectly calls delete_data, which is pure
    virtual. Because there is no derived class, the runtime system causes the program
    to abort.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构过程中，派生类首先被删除。当派生类消失时，delete_data 的定义也随之消失。接下来，调用基类析构函数。在这种情况下，我们的列表类间接调用纯虚函数
    delete_data。因为没有派生类，运行时系统导致程序崩溃。
- en: '**Avoidance 37:** Do not call pure virtual functions from a constructor or
    destructor of an abstract class.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 37：** 不要从抽象类的构造函数或析构函数中调用纯虚函数。'
- en: '**Answer 102:** I expect the results to be:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 102：** 我期望的结果是：'
- en: '[PRE186]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'but the results are:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 但结果是：
- en: '[PRE187]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The problem is the statement:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个语句：
- en: '[PRE188]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Now I *knew* that this added one to i and returned. The problem is that i++
    is the value of i *before the increment.* So what the statement really does is:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我*知道*这个函数将 i 加一并返回。问题是 i++ 是*增量之前*的 i 的值。所以这个语句实际上做的操作是：
- en: Save the value of i.
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 i 的值。
- en: Increment i.
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加i。
- en: Return the saved value.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回保存的值。
- en: 'So the lines:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些行：
- en: '[PRE189]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: cause a 1 to be returned, not a 2 as one might expect.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 导致返回 1，而不是预期的 2。
- en: '**Avoidance 38:** Put ++ and - on lines by themselves.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 38：** 将 ++ 和 - 单独放在一行上。'
- en: '**Answer 103:** The problem is that on some systems, longs must align on a
    four-byte boundary. So let''s take a look at our structure:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 103：** 问题在于在某些系统中，长整型必须对齐在四字节边界上。所以让我们看看我们的结构：'
- en: '[PRE190]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '6 is not divisible by 4, so the compiler adds two padding bytes to make it
    jump to 8\. So what we really have is:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 6 不能被 4 整除，所以编译器添加两个填充字节以跳转到 8。所以实际上我们有：
- en: '[PRE191]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This is not what's indented.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是缩进的样子。
- en: '**Avoidance 39:** Put statements like'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 39**：在你的代码中放置如下语句'
- en: '[PRE192]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: in your code to catch compilers that cause this problem.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 来捕获导致此问题的编译器。
- en: Another avoidance is to make every member of the structure a byte and assemble
    the short and long ints yourself. This is more work, however.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免方法是使结构中的每个成员都是一个字节，并自己组装短整型和长整型。然而，这需要更多的工作。
- en: '**Answer 104:** The zip code 44101 is too large for MS-DOS''s 16-bit integer.
    The largest number a 16-bit integer can hold is 32,767\. The result is that the
    number overflows into the sign bit, and things go wrong.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 104**：邮政编码 44101 对于 MS-DOS 的 16 位整数来说太大。16 位整数可以存储的最大数是 32,767。结果是数字溢出到符号位，导致问题。'
- en: '|  | Note  | Win32 systems use 32-bit integers, so this problem does not occur
    on the current versions of Microsoft Windows. |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | Win32 系统使用 32 位整数，所以这个问题在当前版本的 Microsoft Windows 上不会发生。|'
- en: '**Answer 105:** The ABORT macro is expanded into two statements. So the result
    of the if statement is:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 105**：ABORT 宏展开成两个语句。因此，if 语句的结果是：'
- en: '[PRE193]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'or properly indented:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 或者正确缩进：
- en: '[PRE194]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: From this output it's easy to see why we always exit.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中很容易看出我们为什么总是退出。
- en: '**Avoidance 40:** Use inline functions instead of multistatement macros.'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 40**：使用内联函数而不是多语句宏。'
- en: '[PRE195]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '**Avoidance 41:** If you must use multistatement macros, enclose them in curly
    braces:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 41**：如果你必须使用多语句宏，请用花括号括起来：'
- en: '[PRE196]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '**Answer 106:** The problem is the statement:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 106**：问题是这个语句：'
- en: '[PRE197]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Because prev_ch is an automatic variable, this variable is created and initialized
    at the beginning of each loop. This means for the first if the variable prev_ch
    will always hold '\0' and we'll never match double letters.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 prev_ch 是一个自动变量，所以这个变量在每个循环的开始时创建和初始化。这意味着对于第一个 if，变量 prev_ch 将始终持有 '\0'，我们永远不会匹配双字母。
- en: '**Answer 107:** This program makes the big mistake of using floating-point
    for money. Floating-point numbers may not be exact. When adding up a lot of floating-point
    numbers, some errors may creep in.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 107**：这个程序犯了一个大错误，即使用浮点数表示货币。浮点数可能不是精确的。当累加大量浮点数时，可能会出现一些错误。'
- en: The solution is to change the program to store money not in fractional dollars
    but as an integer number of cents.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将程序中的货币存储方式从分数美元更改为整数美分。
- en: '**Avoidance 42:** Don''t use floating-point for money or anything else you
    want represented exactly.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 42**：不要使用浮点数表示货币或任何其他需要精确表示的东西。'
- en: '**Answer 108:** The printf call prints whatever string you give it. If you
    add 1 to a character string, you get the string minus the first character.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 108**：printf 调用打印你给出的任何字符串。如果你对一个字符字符串加 1，你得到的是去掉第一个字符的字符串。'
- en: 'So:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 因此：
- en: '[PRE198]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The expression ((flags & 0x4) != 0) returns a 0 or 1 depending on whether the
    bit is set.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 ((flags & 0x4) != 0) 根据位是否设置返回 0 或 1。
- en: The programmer is printing -word if the bit is set ("-word" + 0). The output
    is word if it is clear ("-word" + 1).
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位被设置（"-word" + 0），程序员会打印 -word。如果它被清除（"-word" + 1），输出是 word。
- en: '|  | Note  | If you are going to be this clever in your code, comment it to
    tell the maintenance programmers how smart you are. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '|  | 注意  | 如果你在代码中表现得如此聪明，请注释以告诉维护程序员你有多聪明。|'
- en: '**Answer 109:** The problem is the operator = function. It''s defined as:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 109**：问题是操作符 = 函数。它定义为：'
- en: '[PRE199]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The return value of this function is the class trouble. But there's a problem.
    Because the function does not return a reference, a copy of the variable has to
    be made. That means that the copy constructor has to be called. This calls the
    operator = function, which does the return, calling the copy constructor and so
    on.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的返回值是类麻烦。但是有一个问题。因为这个函数没有返回引用，所以必须创建变量的副本。这意味着必须调用复制构造函数。这调用操作符 = 函数，它执行返回，调用复制构造函数，等等。
- en: 'The solution is to have the operator = function return a reference to the class:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是让操作符 = 函数返回类的引用：
- en: '[PRE200]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '**Answer 110:** The initialization of log_file can call new. Of course, our
    new new uses the log_file, so the log_file may be used before it gets constructed,
    confusing the whole mess.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 110**：log_file 的初始化可以调用 new。当然，我们的 new new 使用了 log_file，因此 log_file 可能在使用它构建之前就被使用，这会使整个混乱。'
- en: '**Avoidance 43:** Don''t redefine the global new and delete unless you know
    what you are doing. Really know what you are doing. Even then don''t do it.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 43**：除非你真的知道你在做什么，否则不要重新定义全局的 new 和 delete。真的知道你在做什么。即使如此，也不要这样做。'
- en: '**Answer 111:** The problem is that the initialization order of global variable
    is not guaranteed. In this case, a_var assumes that std::cout is initialized.
    That may not be the case.'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 111**：问题是全局变量的初始化顺序没有保证。在这种情况下，a_var 假设 std::cout 已经初始化。这可能不是事实。'
- en: Let's assume the worse and assume that the initialization order is a_var, std::cout.
    In that case, a_var is created. The constructor is called and output a message
    to std::cout. Because std::cout has not been created yet, things get very confused
    and the program crashes.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设最坏的情况，假设初始化顺序是 a_var，std::cout。在这种情况下，a_var 被创建。构造函数被调用，并向 std::cout 输出一条消息。因为
    std::cout 尚未创建，所以事情变得非常混乱，程序崩溃。
- en: '**Answer 112:** The problem is that MAX is defined to be literally the text
    "=10" That means that'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 112**：问题是 MAX 被定义为 literally 的文本 “=10”。这意味着'
- en: '[PRE201]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: expands to
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 展开为
- en: '[PRE202]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: This does not initialize the counter (it merely compares counter to 10 and throws
    the result). Because the counter is not initialized we get a random number of
    greetings.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有初始化计数器（它只是比较计数器与 10 并抛出结果）。因为计数器没有初始化，所以我们得到一个随机的问候次数。
- en: '|  | Note  | The GNU preprocessor sticks spaces around macro expansions so
    that the GNU version of the expansions:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '|  | 注意  | GNU 预处理器在宏展开周围保留空格，以便 GNU 版本的展开：'
- en: '[PRE203]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: It's unfortunate that the good GNU technology is robbing us of the opportunity
    of debugging strangely failing programs. |
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，好的 GNU 技术正在剥夺我们调试奇怪失败程序的机会。|
- en: '**Answer 113:** The space after the name DOUBLE makes this macro a simple text
    replacement macro. Thus,'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 113**：在名称 DOUBLE 后面的空格使这个宏成为一个简单的文本替换宏。因此，'
- en: '[PRE204]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'causes DOUBLE to be replaced with:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DOUBLE 替换为：
- en: '[PRE205]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Literally!
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 真的！
- en: This means that the line
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这一行
- en: '[PRE206]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'looks like:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像：
- en: '[PRE207]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: (Indentation added.)
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: （增加了缩进。）
- en: 'Solution: Define DOUBLE as'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：将 DOUBLE 定义为
- en: '[PRE208]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '**Avoidance 44:** Use inline functions instead of parameterized macros whenever
    possible. Example:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免 44**：尽可能使用内联函数而不是参数化宏。例如：'
- en: '[PRE209]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '**Answer 114:** The problem is that the optimizer feels free to rewrite the
    code. Some optimizers will stick variables in registers to make the code go faster.
    For example, one optimized version of this program looks like:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 114**：问题是优化器可以自由地重写代码。一些优化器会将变量保留在寄存器中以提高代码速度。例如，这个程序的优化版本看起来像：'
- en: '[PRE210]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: From this, we can see that counter is updated only after the program finishes.
    If we try to examine it at any time in the other thread we die.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看到计数器仅在程序完成后才更新。如果我们试图在其他线程中的任何时间检查它，我们就会崩溃。
- en: 'The solution it to declare the variable volatile:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是声明变量为 volatile：
- en: '[PRE211]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Then the compiler will make no assumptions about what it can do about it regarding
    optimization, and will generate code that keeps counter is kept up-to-date.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器将不会对如何进行优化做出任何假设，并将生成保持计数器更新的代码。
- en: '**Answer 115:** I am trying to always make sure I delete the variable data
    before I overwrite it so I don''t have a memory leak. I even delete it in the
    following code:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案 115**：我试图确保在覆盖变量之前删除变量数据，这样我就不会出现内存泄漏。我甚至在以下代码中删除了它：'
- en: '[PRE212]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'This is the copy constructor. The first thing it does is to see if data has
    anything in it and, if so, delete it. But what could data possibly have in it?
    We just created the class and haven''t initialized it yet. So we are deleting
    a random pointer and as a result, crashing. Properly written our copy constructor
    should be:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拷贝构造函数。它首先检查数据中是否有内容，如果有，则删除它。但数据可能有什么内容呢？我们刚刚创建了类，还没有初始化它。所以我们在删除一个随机指针，结果导致崩溃。正确编写的拷贝构造函数应该是：
- en: '[PRE213]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: List of Sidebars
  id: totrans-760
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏列表
