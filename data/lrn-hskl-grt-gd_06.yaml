- en: Chapter 6. Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 模块
- en: A Haskell *module* is essentially a file that defines some functions, types,
    and type classes. A Has-kell *program* is a collection of modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell的*模块*本质上是一个定义了一些函数、类型和类型类的文件。Haskell的*程序*是一组模块的集合。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802574.png.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802574.png.jpg)'
- en: A module can have many functions and types defined inside it, and it *exports*
    some of them. This means that it makes them available for the outside world to
    see and use.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块可以在其中定义许多函数和类型，并且它*导出*其中的一些。这意味着它使它们对外界可见并可使用。
- en: Having code split up into several modules has many advantages. If a module is
    generic enough, the functions it exports can be used in a multitude of different
    programs. If your own code is separated into self-contained modules that don’t
    rely on each other too much (we also say they are *loosely coupled*), you can
    reuse them later. Your code is more manageable when you split it into several
    parts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分成几个模块有许多优点。如果一个模块足够通用，它导出的函数可以在许多不同的程序中使用。如果你的代码被分成不相互依赖太多的自包含模块（我们也称它们为*松耦合*），你可以在以后重用它们。当你将代码分成几个部分时，代码更易于管理。
- en: The Haskell standard library is split into modules, and each of them contains
    functions and types that are somehow related and serve some common purpose. There
    are modules for manipulating lists, concurrent programming, dealing with complex
    numbers, and so on. All the functions, types, and type classes that we’ve dealt
    with so far are part of the `Prelude` module, which is imported by default.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell标准库被分成模块，每个模块都包含一些相关且服务于某些共同目的的函数和类型。有用于操作列表、并发编程、处理复数等的模块。我们迄今为止处理的所有函数、类型和类型类都是`Prelude`模块的一部分，该模块默认导入。
- en: In this chapter, we’re going to examine a few useful modules and their functions.
    But first, you need to know how to import modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查一些有用的模块及其函数。但首先，你需要知道如何导入模块。
- en: Importing Modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入模块
- en: The syntax for importing modules in a Haskell script is `import ModuleName`.
    This must be done before defining any functions, so imports are usually at the
    top of the file. One script can import several modules—just put each `import`
    statement on a separate line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell脚本中导入模块的语法是`import ModuleName`。这必须在定义任何函数之前完成，因此导入通常位于文件顶部。一个脚本可以导入多个模块——只需将每个`import`语句放在单独的一行上。
- en: An example of a useful module is `Data.List`, which has a bunch of functions
    for working with lists. Let’s import that module and use one of its functions
    to create our own function that tells us how many unique elements a list has.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的模块示例是`Data.List`，它包含了一组用于处理列表的函数。让我们导入这个模块并使用它的一个函数来创建一个自己的函数，该函数告诉我们列表中有多少唯一元素。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you import `Data.List`, all the functions that `Data.List` exports become
    available; you can call them from anywhere in the script. One of those functions
    is `nub`, which takes a list and weeds out duplicate elements. Composing `length`
    and `nub` with `length . nub` produces a function that’s the equivalent of `\xs
    -> length (nub xs)`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入`Data.List`时，`Data.List`导出的所有函数都变得可用；你可以在脚本的任何地方调用它们。其中之一是`nub`函数，它接受一个列表并去除重复元素。将`length`和`nub`组合成`length
    . nub`会产生一个函数，其效果等同于`\xs -> length (nub xs)`。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To search for functions or to find out where they’re located, use Hoogle, which
    can be found at [http://www.haskell.org/hoogle/](http://www.haskell.org/hoogle/).
    It’s a really awesome Haskell search engine that allows you to search by function
    name, module name, or even type signature.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索函数或找出它们的位置，请使用Hoogle，它可以在[http://www.haskell.org/hoogle/](http://www.haskell.org/hoogle/)找到。它是一个真正出色的Haskell搜索引擎，允许你通过函数名、模块名或甚至类型签名进行搜索。
- en: 'You can also get access to functions of modules when using GHCi. If you’re
    in GHCi and you want to be able to call the functions exported by `Data.List`,
    enter this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GHCi时，你也可以访问模块的函数。如果你在GHCi中，并且想要能够调用`Data.List`导出的函数，请输入以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to access several modules from GHCi, you don’t need to enter `:m
    +` several times. You can load several modules at once, as in this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从GHCi访问多个模块，你不需要多次输入`:m +`。你可以一次性加载多个模块，如下例所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, if you’ve loaded a script that already imports a module, you don’t
    need to use `:m +` to access that module. If you need only a couple of functions
    from a module, you can selectively import just those functions. For example, here’s
    how you could import only the `nub` and `sort` functions from `Data.List`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您已经加载了一个已经导入模块的脚本，您不需要使用 `:m +` 来访问该模块。如果您只需要从模块中导入几个函数，您可以仅选择性地导入这些函数。例如，以下是您如何仅从
    `Data.List` 中导入 `nub` 和 `sort` 函数的方法：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also choose to import all of the functions of a module except a few
    select ones. That’s often useful when several modules export functions with the
    same name and you want to get rid of the offending ones. Say you already have
    your own function called `nub` and you want to import all the functions from `Data.List`
    except the `nub` function. Here’s how to do that:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择导入一个模块的所有函数，除了几个选定的函数。当几个模块导出具有相同名称的函数，并且您想去除这些函数时，这通常很有用。比如说，您已经有一个名为
    `nub` 的函数，并且您想导入 `Data.List` 中的所有函数，除了 `nub` 函数。以下是这样做的方法：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another way of dealing with name clashes is to do *qualified imports*. Consider
    the `Data.Map` module, which offers a data structure for looking up values by
    key. This module exports a lot of functions with the same name as `Prelude` functions,
    such as `filter` and `null`. So if we imported `Data.Map` and then called `filter`,
    Haskell wouldn’t know which function to use. Here’s how we solve this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 处理名称冲突的另一种方法是进行 *限定导入*。考虑 `Data.Map` 模块，它提供了一个通过键查找值的数据结构。此模块导出许多与 `Prelude`
    函数具有相同名称的函数，例如 `filter` 和 `null`。所以如果我们导入了 `Data.Map` 并调用 `filter`，Haskell 就不知道要使用哪个函数。以下是解决方法：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now if we want to reference `Data.Map`’s `filter` function, we must use `Data.Map.filter`.
    Entering just `filter` still refers to the normal `filter` we all know and love.
    But typing `Data.Map` in front of every function from that module is kind of tedious.
    That’s why we can rename the qualified import to something shorter:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们想引用 `Data.Map` 的 `filter` 函数，我们必须使用 `Data.Map.filter`。仅输入 `filter` 仍然指的是我们所有人都知道和喜爱的普通
    `filter`。但是，在模块中的每个函数前面都输入 `Data.Map` 有点繁琐。这就是为什么我们可以将限定导入重命名为更短的名字：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now to reference `Data.Map`’s `filter` function, we just use `M.filter`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要引用 `Data.Map` 的 `filter` 函数，我们只需使用 `M.filter`。
- en: As you’ve seen, the `.` symbol is used to reference functions from modules that
    have been imported as qualified, such as `M.filter`. We also use it to perform
    function composition. So how does Haskell know what we mean when we use it? Well,
    if we place it between a qualified module name and a function, without whitespace,
    it’s regarded as just referring to the imported function; otherwise, it’s treated
    as function composition.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`.` 符号用于引用已导入为限定形式的模块中的函数，例如 `M.filter`。我们还用它来进行函数组合。那么，Haskell 是如何知道我们使用它的意思的呢？嗯，如果我们将其放置在限定模块名称和函数之间，没有空格，它就被视为仅引用导入的函数；否则，它被视为函数组合。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A great way to pick up new Haskell knowledge is to just click through the standard
    library documentation and explore the modules and their functions. You can also
    view the Haskell source code for each module. Reading the source code of some
    modules will give you a solid feel for Haskell.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 获取新的 Haskell 知识的一个好方法就是点击标准库文档，探索模块及其函数。您还可以查看每个模块的 Haskell 源代码。阅读一些模块的源代码将让您对
    Haskell 有一个扎实的感受。
- en: Solving Problems with Module Functions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块函数解决问题
- en: The modules in the standard libraries provide many functions that can make our
    lives easier when coding in Haskell. Let’s look at some examples of how to use
    functions from various Haskell modules to solve problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的模块提供了许多函数，可以在使用 Haskell 编码时使我们的生活更轻松。让我们看看如何使用各种 Haskell 模块中的函数来解决一些问题的示例。
- en: Counting Words
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数单词
- en: 'Suppose we have a string that contains a bunch of words, and we want to know
    how many times each word appears in the string. The first module function we’ll
    use is `words` from `Data.List`. The `words` function converts a string into a
    list of strings where each string is one word. Here’s a quick demonstration:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含许多单词的字符串，我们想知道每个单词在字符串中出现的次数。我们将使用的第一个模块函数是来自 `Data.List` 的 `words`
    函数。`words` 函数将一个字符串转换成一个字符串列表，其中每个字符串都是一个单词。以下是一个快速演示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we’ll use the `group` function, which also lives in `Data.List`, to group
    together words that are identical. This function takes a list and groups adjacent
    elements into sublists if they are equal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `group` 函数，它也位于 `Data.List` 中，将相同的单词分组在一起。此函数接受一个列表，如果相邻元素相等，则将它们分组到子列表中：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But what happens if the elements that are equal aren’t adjacent in our list?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果列表中相等的元素不是相邻的，会发生什么呢？
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We get two lists that contain the string `"boom"`, even though we want all
    occurrences of some word to end up in the same list. What are we to do? Well,
    we could sort our list of words beforehand! For that, we’ll use the `sort` function,
    which hangs its hat in `Data.List`. It takes a list of things that can be ordered
    and returns a new list that is like the old one, but ordered from smallest to
    largest:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两个包含字符串`"boom"`的列表，尽管我们希望某个单词的所有出现都最终出现在同一个列表中。我们该怎么办呢？嗯，我们可以在排序单词列表之前进行排序！为此，我们将使用位于`Data.List`中的`sort`函数。它接受可以排序的事物列表，并返回一个新列表，类似于旧列表，但按从小到大的顺序排列：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the strings are put in an alphabetical order.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串是按字母顺序排列的。
- en: We have all the ingredients for our recipe. Now we just need to write it down.
    We’ll take a string, break it down into a list of words, sort those words, and
    then group them. Finally, we’ll use some mapping magic to get tuples like `("boom",
    3)`, meaning that the word `"boom"` occurs three times.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了我们的食谱的所有原料。现在我们只需要把它写下来。我们将取一个字符串，将其分解成一个单词列表，对这些单词进行排序，然后分组。最后，我们将使用一些映射魔法来获取像`("boom",
    3)`这样的元组，这意味着单词`"boom"`出现了三次。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We used function composition to make our final function. It takes a string,
    such as `"wa wa wee wa"`, and then applies `words` to that string, resulting in
    `["wa","wa","wee","wa"]`. Then `sort` is applied to that, and we get `["wa","wa","wa","wee"]`.
    Applying `group` to this result groups adjacent words that are equal, so we get
    a list of lists of strings: `[["wa","wa","wa"],["wee"]]`. Then we map a function
    that takes a list and returns a tuple, where the first component is the head of
    the list and the second component is its length, over the grouped words. Our final
    result is `[("wa",3),("wee",1)]`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用函数组合来制作我们的最终函数。它接受一个字符串，例如`"wa wa wee wa"`，然后对该字符串应用`words`，得到`["wa","wa","wee","wa"]`。然后对结果应用`sort`，我们得到`["wa","wa","wa","wee"]`。将`group`应用于此结果将相邻且相等的单词分组，因此我们得到一个字符串列表的列表：`[["wa","wa","wa"],["wee"]]`。然后我们对分组后的单词应用一个函数，该函数接受一个列表并返回一个元组，其中第一个元素是列表的头部，第二个元素是其长度。我们的最终结果是`[("wa",3),("wee",1)]`。
- en: 'Here’s how we could write this function without function composition:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何不使用函数组合来编写这个函数的方法：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wow, parentheses overload! I think it’s easy to see how function composition
    makes this function more readable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，括号过多！我想很容易看出函数组合是如何使这个函数更易读的。
- en: Needle in the Haystack
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对麦草堆
- en: For our next mission, should we choose to accept it, we will make a function
    that takes two lists and tells us if the first list is wholly contained anywhere
    in the second list. For instance, the list `[3,4]` is contained in `[1,2,3,4,5]`,
    whereas `[2,5]` isn’t. We’ll refer to the list that’s being searched as the *haystack*
    and the list that we’re searching for as the *needle*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个任务，如果我们选择接受，我们将制作一个函数，该函数接受两个列表并告诉我们第一个列表是否完全包含在第二个列表中的任何地方。例如，列表`[3,4]`包含在`[1,2,3,4,5]`中，而`[2,5]`则不包含。我们将被搜索的列表称为*麦草堆*，我们正在搜索的列表称为*针*。
- en: 'For this escapade, we’ll use the `tails` function, which dwells in `Data.List`.
    `tails` takes a list and successively applies the `tail` function to that list.
    Here’s an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次冒险，我们将使用`tails`函数，该函数位于`Data.List`中。`tails`接受一个列表，并连续对该列表应用`tail`函数。以下是一个例子：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, it may not be obvious why we need `tails` at all. Another example
    will clarify this.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能还不明显为什么我们需要`tails`。另一个例子将澄清这一点。
- en: Let’s say that we’re searching for the string `"art"` inside the string `"party"`.
    First, we use `tails` to get all the tails of the list. Then we examine each tail,
    and if any one starts with the string `"art"`, we’ve found the needle in our haystack!
    If we were looking for `"boo"` inside `"party"`, no tail would start with the
    string `"boo"`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在搜索字符串`"art"`在字符串`"party"`中的位置。首先，我们使用`tails`来获取列表的所有尾部。然后我们检查每个尾部，如果任何一个以字符串`"art"`开头，那么我们就找到了麦草堆中的针！如果我们正在搜索`"boo"`在`"party"`中的位置，则没有任何尾部以字符串`"boo"`开头。
- en: To see if one string starts with another, we’ll use the `isPrefixOf` function,
    which is also found in `Data.List`. It takes two lists and tells us if the second
    one starts with the first one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个字符串是否以另一个字符串开头，我们将使用`isPrefixOf`函数，该函数也位于`Data.List`中。它接受两个列表，并告诉我们第二个列表是否以第一个列表开头。
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we just need to check if any tail of our haystack starts with our needle.
    For that, we can use the `any` function from `Data.List`. It takes a predicate
    and a list, and it tells us if any element from the list satisfies the predicate.
    Behold:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要检查我们的稻草堆的任何尾部是否以我们的针开始。为此，我们可以使用`Data.List`中的`any`函数。它接受一个谓词和一个列表，并告诉我们列表中的任何元素是否满足谓词。看这里：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s put these functions together:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这些函数放在一起：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That’s all there is to it! We use `tails` to generate a list of tails of our
    haystack and then see if any of them starts with our needle. Let’s give it a test
    run:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部！我们使用`tails`来生成我们稻草堆的尾部列表，然后看看是否有任何一个以我们的针开始。让我们试运行一下：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Oh, wait a minute! It turns out that the function that we just made is already
    in `Data.List`! Curses! It’s called `isInfixOf`, and it does the same work as
    our `isIn` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，等等！我们刚才制作的函数已经在`Data.List`中！诅咒！它被称为`isInfixOf`，并且它与我们的`isIn`函数做相同的工作。
- en: Caesar Cipher Salad
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 凯撒密码沙拉
- en: Gaius Julius Caesar has entrusted upon us an important task. We must transport
    a top-secret message to Mark Antony in Gaul. Just in case we get captured, we’re
    going to use some functions from `Data.Char` to be a bit sneaky and encode messages
    by using the *Caesar cipher*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 盖乌斯·尤利乌斯·凯撒将一项重要任务托付给了我们。我们必须将一份绝密信息传送到高卢的马克·安东尼。以防我们被俘获，我们将使用`Data.Char`中的某些函数来变得有点狡猾，并通过使用*凯撒密码*来编码信息。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802576.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802576.png.jpg)'
- en: The Caesar cipher is a primitive method of encoding messages by shifting each
    character by a fixed number of positions in the alphabet. We can easily create
    a sort of Caesar cipher of our own, and we won’t constrict ourselves to the alphabet—we’ll
    use the whole range of Unicode characters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一种通过在字母表中按固定位数移动每个字符来编码信息的原始方法。我们可以轻松地创建我们自己的凯撒密码，我们不会限制自己只使用字母表——我们将使用Unicode字符的全范围。
- en: 'To shift characters forward and backward in the alphabet, we’re going to use
    the `Data.Char` module’s `ord` and `chr` functions, which convert characters to
    their corresponding numbers and vice versa:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在字母表中向前和向后移动字符，我们将使用`Data.Char`模块的`ord`和`chr`函数，这些函数将字符转换为相应的数字，反之亦然：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ord ''a''` returns `97` because `''a''` is the ninety-seventh character in
    the Unicode table of characters.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ord ''a''`返回`97`，因为`''a''`是字符Unicode表中的第九十七个字符。'
- en: The difference between the `ord` values of two characters is equal to how far
    apart they are in the Unicode table.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 两个字符的`ord`值之间的差异等于它们在Unicode表中的距离。
- en: Let’s write a function that takes a number of positions to shift and a string,
    and returns that string where every character is shifted forward in the alphabet
    by that many positions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，该函数接受要移动的位置数和字符串，然后返回该字符串，其中每个字符都按该位置数在字母表中向前移动。
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Encoding a string is as simple as taking our message and mapping over it a function
    that takes a character, converts it to its corresponding number, adds an offset,
    and then converts it back to a character. A composition cowboy would write this
    function as `(chr . (+ offset) . ord)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编码一个字符串就像取我们的信息，映射一个函数，该函数接受一个字符，将其转换为相应的数字，添加一个偏移量，然后将其转换回字符。一个组合牛仔会这样写这个函数：（chr
    . (+ offset) . ord）。
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That’s definitely encoded!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这肯定已经编码了！
- en: Decoding a message is basically just shifting it back by the number of places
    it was shifted by in the first place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解码一条信息基本上就是将其按照最初移动的位数反向移动。
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can test it by decoding Caesar’s message:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过解码凯撒的信息来测试它：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On Strict Left Folds
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在严格的左折叠中
- en: 'In the previous chapter, you saw how `foldl` works and how you can use it to
    implement all sorts of cool functions. However, there’s a catch to `foldl` that
    we haven’t yet explored: Using `foldl` can sometimes lead to so-called stack overflow
    errors, which occur when your program uses too much space in a specific part of
    your computer’s memory. To demonstrate, let’s use `foldl` with the `+` function
    to sum a list that consists of a hundred `1`s:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你看到了`foldl`是如何工作的，以及你可以如何使用它来实现各种酷函数。然而，`foldl`有一个我们尚未探索的陷阱：使用`foldl`有时会导致所谓的堆栈溢出错误，这发生在你的程序在计算机内存的特定部分使用太多空间时。为了演示，让我们使用`foldl`和`+`函数来求和由一百个`1`组成的列表：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This seems to work. What if we want to use `foldl` to sum a list that has, as
    Dr. Evil would put it, *one million* `1`s?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有效。如果我们想使用`foldl`来求和，作为Dr. Evil所说，*一百万*个`1`组成的列表，会怎样呢？
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802578.png.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802578.png.jpg)'
- en: Ooh, that is truly evil! Now why does this happen? Haskell is lazy, and so it
    defers actual computation of values for as long as possible. When we use `foldl`,
    Haskell doesn’t compute (that is, evaluate) the actual accumulator on every step.
    Instead, it defers its evaluation. In the next step, it again doesn’t evaluate
    the accumulator, but defers the evaluation. It also keeps the old deferred computation
    in memory, because the new one often refers to its result. So as the fold merrily
    goes along its way, it builds up a bunch of deferred computations, each taking
    a not insignificant amount of memory. Eventually, this can cause a stack overflow
    error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这真是太邪恶了！那么这是为什么发生的呢？Haskell是惰性的，因此它会尽可能推迟实际值的计算。当我们使用`foldl`时，Haskell不会在每一步计算（即评估）实际的累加器。相反，它会推迟评估。在下一步中，它再次不会评估累加器，而是推迟评估。它还会在内存中保留旧的推迟计算，因为新的计算通常引用其结果。所以当折叠愉快地进行时，它会积累一大堆推迟的计算，每个计算都占用相当数量的内存。最终，这可能导致栈溢出错误。
- en: 'Here’s how Haskell evaluates the expression `foldl (+) 0 [1,2,3]`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Haskell如何评估表达式`foldl (+) 0 [1,2,3]`的方式：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you can see, it first builds up a big stack of deferred computations. Then,
    once it reaches the empty list, it goes about actually evaluating those deferred
    computations. This isn’t a problem for small lists, but for large lists that contain
    upward of a million elements, you get a stack overflow, because evaluating all
    these deferred computations is done recursively. Wouldn’t it be nice if there
    was a function named, say, `foldl''`, that didn’t defer computations? It would
    work like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它首先建立一大堆推迟的计算。然后，一旦它达到空列表，它就会开始实际评估这些推迟的计算。这对小列表来说没问题，但对于包含超过一百万个元素的列表，你会得到栈溢出错误，因为评估所有这些推迟的计算是通过递归完成的。如果有一个名为`foldl'`的函数，它不推迟计算，那不是很好吗？它会这样工作：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Computations wouldn’t be deferred between steps of `foldl`, but would get evaluated
    immediately. Well, we’re in luck, because `Data.List` offers this stricter version
    of `foldl`, and it is indeed called `foldl''`. Let’s try to compute the sum of
    a million `1`s with `foldl''`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`foldl`的步骤之间不会推迟计算，而是会立即评估。嗯，我们很幸运，因为`Data.List`提供了这种更严格的`foldl`版本，它确实被称为`foldl'`。让我们尝试使用`foldl'`计算一百万个`1`的和：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Great success! So, if you get stack overflow errors when using `foldl`, try
    switching to `foldl'`. There’s also a stricter version of `foldl1`, named `foldl1'`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大获成功！所以，如果你在使用`foldl`时遇到栈溢出错误，尝试切换到`foldl'`。还有`foldl1`的更严格版本，名为`foldl1'`。
- en: Let's Find Some Cool Numbers
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们寻找一些有趣的数字
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802580.png.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802580.png.jpg)'
- en: You’re walking along the street, and an old lady comes up to you and says, “Excuse
    me, what’s the first natural number such that the sum of its digits equals 40?”
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在街道上行走，一位老妇人走到你面前说：“对不起，第一个数字之和等于40的自然数是什么？”
- en: Well, what now, hotshot? Let’s use some Has-kell magic to find such a number.
    For instance, if we sum the digits of the number 123, we get 6, because 1 + 2
    + 3 equals 6\. So, what is the first number that has such a property that its
    digits add up to 40?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在怎么办，高手？让我们使用一些Haskell魔法来找到这样的数字。例如，如果我们对数字123的数字求和，我们得到6，因为1 + 2 + 3等于6。那么，第一个具有这种性质的数字是什么，它的数字之和等于40？
- en: 'First, let’s make a function that takes a number and tells us the sum of its
    digits. We’re going to use a cool trick here. First, we’ll convert our number
    to a string by using the `show` function. Once we have a string, we’ll turn each
    character in that string into a number and then just sum that list of numbers.
    To turn a character into a number, we’ll use a handy function from `Data.Char`
    called `digitToInt`. It takes a `Char` and returns an `Int`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个函数，它接受一个数字并告诉我们它的数字之和。这里我们将使用一个巧妙的技巧。首先，我们将使用`show`函数将我们的数字转换为字符串。一旦我们有了字符串，我们将把该字符串中的每个字符转换为数字，然后只对这组数字求和。为了将一个字符转换为数字，我们将使用来自`Data.Char`的便捷函数`digitToInt`。它接受一个`Char`并返回一个`Int`：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It works on the characters in the range from `'0'` to `'9'` and from `'A'` to
    `'F'` (they can also be in lowercase).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它作用于范围从`'0'`到`'9'`和从`'A'`到`'F'`（它们也可以是小写）的字符。
- en: 'Here’s our function that takes a number and returns the sum of its digits:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的函数，它接受一个数字并返回其数字之和：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We convert it to a string, map `digitToInt` over that string, and then sum the
    resulting list of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其转换为字符串，对那个字符串应用`digitToInt`，然后对得到的一组数字求和。
- en: 'Now we need to find the first natural number such that when we apply `digitSum`
    to it, we get `40` as the result. To do that, we’ll use the `find` function, which
    resides in `Data.List`. It takes a predicate and a list and returns the first
    element of the list that matches the predicate. However, it has a rather peculiar
    type declaration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到第一个自然数，当我们对其应用`digitSum`时，我们得到的结果是`40`。为了做到这一点，我们将使用位于`Data.List`中的`find`函数。它接受一个谓词和一个列表，并返回列表中第一个满足谓词的元素。然而，它有一个相当特殊的类型声明：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802582.png.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802582.png.jpg)'
- en: 'The first parameter is a predicate, and the second parameter is a list—no big
    deal here. But what about the return value? It says `Maybe a`. That’s a type you
    haven’t met before. A value with a type of `Maybe a` is sort of like a list of
    type `[a]`. Whereas a list can have zero, one, or many elements, a `Maybe a` typed
    value can have either zero elements or just one element. We use it when we want
    to represent possible failure. To make a value that holds nothing, we just use
    `Nothing`. This is analogous to the empty list. To construct a value that holds
    something, say the string `"hey"`, we write `Just "hey"`. Here’s a quick demonstration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个谓词，第二个参数是一个列表——这里没什么大不了的。但是返回值呢？它说`Maybe a`。这是一种你之前没有见过的类型。类型为`Maybe
    a`的值有点像类型为`[a]`的列表。而一个列表可以有零个、一个或多个元素，一个类型为`Maybe a`的值可以有零个元素或只有一个元素。我们使用它来表示可能失败的情况。要创建一个不包含任何内容的值，我们只需使用`Nothing`。这与空列表类似。要构造一个包含内容的值，比如字符串`"hey"`，我们写`Just
    "hey"`。这里有一个快速演示：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, a value of `Just True` has a type of `Maybe Bool`, kind of like
    how a list that holds Booleans would have a type of `[Bool]`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个值为`Just True`的类型是`Maybe Bool`，有点像包含布尔值的列表会有类型`[Bool]`。
- en: 'If `find` finds an element that satisfies the predicate, it will return that
    element wrapped in a `Just`. If it doesn’t, it will return a `Nothing`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`find`找到一个满足谓词的元素，它将返回该元素包裹在`Just`中。如果没有，它将返回`Nothing`：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now let’s get back to making our function. We have our `digitSum` function and
    know how `find` works, so all that’s left to do is put these two together. Remember
    that we want to find the first number whose digits add up to 40.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到编写我们的函数。我们有了`digitSum`函数，也知道`find`是如何工作的，所以剩下的只是将这两个结合起来。记住，我们想要找到第一个数字，其各位数字之和为40。
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We just take the infinite list `[1..]`, and then find the first number whose
    `digitSum` is 40.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是取无限列表`[1..]`，然后找到第一个`digitSum`为40的数字。
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There’s our answer! If we want to make a more general function that is not
    fixed on 40 but takes our desired sum as the parameter, we can change it like
    so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了答案！如果我们想要创建一个更通用的函数，它不是固定在40上，而是接受我们想要的和作为参数，我们可以这样修改：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s a quick test:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速测试：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Mapping Keys to Values
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将键映射到值
- en: When dealing with data in some sort of collection, we often don’t care if it’s
    in some kind of order; we just want to be able to access it by a certain key.
    For example, if we want to know who lives at a certain address, we want to look
    up the name based on the address. When doing such things, we say that we looked
    up our desired value (someone’s name) by some sort of key (that person’s address).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理某种集合中的数据时，我们通常不关心它的顺序；我们只想能够通过某个键来访问它。例如，如果我们想知道谁住在某个地址，我们希望根据地址查找名字。在这样做的时候，我们说我们通过某种键（那个人的地址）查找了我们想要的价值（某人的名字）。
- en: 'Almost As Good: Association Lists'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几乎一样好：关联列表
- en: There are many ways to achieve key/value mappings. One of them is the *association
    list*. Association lists (also called *dictionaries*) are lists that are used
    to store key/value pairs where ordering doesn’t matter. For instance, we might
    use an association list to store phone numbers, where phone numbers would be the
    values and people’s names would be the keys. We don’t care in which order they’re
    stored; we just want to get the right phone number for the right person.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以实现键/值映射。其中之一是*关联列表*。关联列表（也称为*字典*）是用于存储键/值对的列表，其中顺序不重要。例如，我们可能会使用关联列表来存储电话号码，其中电话号码是值，人的名字是键。我们不在乎它们存储的顺序；我们只想为正确的人找到正确的电话号码。
- en: 'The most obvious way to represent association lists in Haskell would be by
    having a list of pairs. The first component in the pair would be the key, and
    the second component would be the value. Here’s an example of an association list
    with phone numbers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中表示关联列表最明显的方式可能是通过一个对列表。对中的第一个组件将是键，第二个组件将是值。以下是一个包含电话号码的关联列表示例：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Despite this seemingly odd indentation, this is just a list of pairs of strings.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个缩进看起来有些奇怪，但这实际上只是一个字符串对的列表。
- en: The most common task when dealing with association lists is looking up some
    value by key. Let’s make a function that looks up some value given a key.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 处理关联列表时最常见的任务是按键查找某个值。让我们创建一个按键查找值的函数。
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is pretty simple. The function takes a key and a list, filters the list
    so that only matching keys remain, gets the first key/value pair that matches,
    and returns the value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。该函数接收一个键和一个列表，过滤列表，只保留匹配的键，获取第一个匹配的键/值对，并返回值。
- en: But what happens if the key we’re looking for isn’t in the association list?
    Hmm. Here, if a key isn’t in the association list, we’ll end up trying to get
    the head of an empty list, which throws a runtime error. We should avoid making
    our programs so easy to crash, so let’s use the `Maybe` data type. If we don’t
    find the key, we’ll return a `Nothing`. If we find it, we’ll return `Just` *`something`*,
    where *`something`* is the value corresponding to that key.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们正在寻找的键不在关联列表中会发生什么呢？嗯。在这里，如果一个键不在关联列表中，我们最终会尝试获取一个空列表的头部，这会抛出一个运行时错误。我们应该避免让我们的程序如此容易崩溃，所以让我们使用
    `Maybe` 数据类型。如果我们找不到键，我们将返回 `Nothing`。如果我们找到了它，我们将返回 `Just` *`something`*，其中 *`something`*
    是与该键对应的值。
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Look at the type declaration. It takes a key that can be equated and an association
    list, and then it maybe produces a value. Sounds about right.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 看看类型声明。它接受一个可以等价的键和一个关联列表，然后可能产生一个值。听起来很合理。
- en: This is a textbook recursive function that operates on a list. Base case, splitting
    a list into a head and a tail, recursive calls—they’re all there. This is the
    classic fold pattern, so let’s see how this would be implemented as a fold.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个教科书级别的递归函数，它作用于一个列表。基本情况，将列表拆分为头部和尾部，递归调用——所有这些都在这里。这是经典的折叠模式，那么让我们看看这会如何作为一个折叠来实现。
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It’s usually better to use folds for this standard list recursion pattern, rather
    than explicitly writing the recursion, because they’re easier to read and identify.
    Everyone knows it’s a fold when they see the `foldr` call, but it takes some more
    thinking to read explicit recursion.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用折叠来处理这种标准的列表递归模式比显式地编写递归更好，因为它们更容易阅读和识别。当看到 `foldr` 调用时，每个人都知道这是一个折叠，但阅读显式递归则需要更多的思考。
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This works like a charm! If we have the girl’s phone number, we `Just` get the
    number; otherwise, we get `Nothing`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这效果非常好！如果我们有女孩的电话号码，我们 `Just` 就能得到这个号码；否则，我们得到 `Nothing`。
- en: Enter Data.Map
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入 Data.Map
- en: We just implemented the `lookup` function from `Data.List`. If we want the value
    that corresponds to a key, we need to traverse all the elements of the list until
    we find it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了 `Data.List` 中的 `lookup` 函数。如果我们想要与键对应的值，我们需要遍历列表的所有元素，直到找到它。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802584.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802584.png.jpg)'
- en: It turns out that the `Data.Map` module offers association lists that are much
    faster, and it also provides a lot of utility functions. From now on, we’ll say
    we’re working with *maps* instead of association lists.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`Data.Map` 模块提供了比关联列表快得多的关联列表，并且它还提供了很多实用函数。从现在开始，我们将说我们在使用 *映射* 而不是关联列表。
- en: Because `Data.Map` exports functions that clash with the `Prelude` and `Data.List`
    ones, we’ll do a qualified import.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Data.Map` 导出的函数与 `Prelude` 和 `Data.List` 中的函数冲突，我们将进行限定导入。
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Put this `import` statement into a script, and then load the script via GHCi.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个 `import` 语句放入脚本中，然后通过 GHCi 加载脚本。
- en: 'We’re going to turn an association list into a map by using the `fromList`
    function from `Data.Map`. `fromList` takes an association list (in the form of
    a list) and returns a map with the same associations. Let’s play around a bit
    with `fromList` first:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 `Data.Map` 中的 `fromList` 函数将关联列表转换为映射。`fromList` 函数接收一个关联列表（以列表的形式）并返回一个具有相同关联的映射。让我们首先对
    `fromList` 进行一些实验：
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When a map from `Data.Map` is displayed on the terminal, it’s shown as `fromList`
    and then an association list that represents the map, even though it’s not a list
    anymore.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Data.Map` 的映射在终端上显示时，它显示为 `fromList`，然后是一个表示映射的关联列表，尽管它不再是列表了。
- en: 'If there are duplicate keys in the original association list, the duplicates
    are just discarded:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始关联列表中有重复的键，这些重复的键将被简单地丢弃：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the type signature of `fromList`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `fromList` 的类型签名：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It says that it takes a list of pairs of type `k` and `v`, and returns a map
    that maps from keys of type `k` to values of type `v`. Notice that when we were
    doing association lists with normal lists, the keys only needed to be equatable
    (their type belonging to the `Eq` type class), but now they must be orderable.
    That’s an essential constraint in the `Data.Map` module. It needs the keys to
    be orderable so it can arrange and access them more efficiently.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示它接受一个类型为 `k` 和 `v` 的键值对列表，并返回一个映射，该映射将类型为 `k` 的键映射到类型为 `v` 的值。请注意，当我们使用正常列表进行关联列表时，键只需要是可等的（它们的类型属于
    `Eq` 类型类），但现在它们必须是可排序的。这是 `Data.Map` 模块中的一个基本约束。它需要键是可排序的，这样它可以更有效地排列和访问它们。
- en: 'Now we can modify our original `phoneBook` association list to be a map. We’ll
    also add a type declaration, just because we can:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改我们的原始 `phoneBook` 关联列表，使其成为一个映射。我们还将添加一个类型声明，只是因为我们可以：
- en: '[PRE46]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Cool! Let’s load this script into GHCi and play around with our `phoneBook`.
    First, we’ll use `lookup` to search for some phone numbers. `lookup` takes a key
    and a map, and tries to find the corresponding value in the map. If it succeeds,
    it returns the value wrapped in a `Just`; otherwise, it returns a `Nothing`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 太酷了！让我们把这个脚本加载到 GHCi 中，并玩一下我们的 `phoneBook`。首先，我们将使用 `lookup` 来搜索一些电话号码。`lookup`
    接受一个键和一个映射，并尝试在映射中找到相应的值。如果成功，它返回一个包裹在 `Just` 中的值；否则，它返回一个 `Nothing`：
- en: '[PRE47]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For our next trick, we’ll make a new map from `phoneBook` by inserting a number.
    `insert` takes a key, a value, and a map, and returns a new map that’s just like
    the old one, but with the key and value inserted:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个技巧，我们将通过插入一个号码来创建一个新的从 `phoneBook` 映射。`insert` 接受一个键、一个值和一个映射，并返回一个新的映射，它与旧映射相同，但键和值被插入：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s check how many numbers we have. We’ll use the `size` function from `Data.Map`,
    which takes a map and returns its size. This is pretty straightforward:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们有多少个数字。我们将使用来自 `Data.Map` 的 `size` 函数，它接受一个映射并返回其大小。这很简单：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802586.png.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802586.png.jpg)'
- en: The numbers in our phone book are represented as strings. Suppose we would rather
    use lists of `Int`s to represent phone numbers. So, instead of having a number
    like `"939-8282"`, we want to have `[9,3,9,8,2,8,2]`. First, we’re going to make
    a function that converts a phone number string to a list of `Int`s. We can try
    to map `digitToInt` from `Data.Char` over our string, but it won’t know what to
    do with the dash! That’s why we need to get rid of anything in that string that
    isn’t a number. To do this, we’ll seek help from the `isDigit` function from `Data.Char`,
    which takes a character and tells us if it represents a digit. Once we’ve filtered
    our string, we’ll just map `digitToInt` over it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们电话簿中的号码以字符串的形式表示。假设我们更愿意使用 `Int` 的列表来表示电话号码。所以，我们不想有一个像 `"939-8282"` 这样的号码，我们想要
    `[9,3,9,8,2,8,2]`。首先，我们将创建一个函数，将电话号码字符串转换为 `Int` 的列表。我们可以尝试将 `digitToInt` 从 `Data.Char`
    映射到我们的字符串，但它不知道如何处理破折号！这就是为什么我们需要从字符串中去除任何不是数字的东西。为此，我们将寻求 `Data.Char` 中的 `isDigit`
    函数的帮助，它接受一个字符并告诉我们它是否代表一个数字。一旦我们过滤了我们的字符串，我们只需将其映射到 `digitToInt` 上即可。
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Oh, be sure to `import Data.Char`, if you haven’t already.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，如果你还没有做的话，请务必 `import Data.Char`。
- en: 'Let’s try this out:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个：
- en: '[PRE51]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Very cool! Now, let’s use the `map` function from `Data.Map` to map `string2digits`
    over our `phoneBook`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 非常酷！现在，让我们使用 `Data.Map` 中的 `map` 函数将 `string2digits` 映射到我们的 `phoneBook` 上：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `map` from `Data.Map` takes a function and a map, and applies that function
    to each value in the map.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Map` 中的 `map` 函数接受一个函数和一个映射，并将该函数应用于映射中的每个值。'
- en: 'Let’s extend our phone book. Say that a person can have several numbers, and
    we have an association list set up like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的电话簿。假设一个人可以有多个号码，并且我们已经设置了一个这样的关联列表：
- en: '[PRE53]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we just use `fromList` to put that into a map, we’ll lose a few numbers!
    Instead, we’ll use another function found in `Data.Map`: `fromListWith`. This
    function acts like `fromList`, but instead of discarding duplicate keys, it uses
    a function supplied to it to decide what to do with them.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是使用`fromList`将它们放入映射中，我们会丢失一些数字！相反，我们将使用`Data.Map`中找到的另一个函数：`fromListWith`。这个函数的作用类似于`fromList`，但它不会丢弃重复的键，而是使用提供给它的函数来决定如何处理它们。
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If `fromListWith` finds that the key is already there, it uses the function
    supplied to it to join those two values into one and replaces the old value with
    the one it got by passing the conflicting values to the function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fromListWith`发现键已经存在，它将使用提供给它的函数将这两个值合并成一个，并用它通过传递冲突的值给函数得到的新值替换旧值：
- en: '[PRE55]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We could also first make all the values in the association list singleton lists
    and then use `++` to combine the numbers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以首先将关联列表中的所有值都变成单元素列表，然后使用`++`来合并数字：
- en: '[PRE56]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s test this in GHCi:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在GHCi中测试这个：
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Pretty neat!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 非常整洁！
- en: 'Now suppose we’re making a map from an association list of numbers, and when
    a duplicate key is found, we want the biggest value for the key to be kept. We
    can do that like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们正在从一个数字的关联列表中创建一个映射，并且当发现重复的键时，我们想要保留键的最大值。我们可以这样做：
- en: '[PRE58]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Or we could choose to add together values that share keys:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们也可以选择将具有相同键的值相加：
- en: '[PRE59]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, you’ve seen that `Data.Map` and the other modules provided by Haskell are
    pretty cool. Next, we’ll look at how to make your own module.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经看到了`Data.Map`和Haskell提供的其他模块相当酷。接下来，我们将看看如何创建自己的模块。
- en: Making Our Own Modules
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的模块
- en: As I said at the beginning of this chapter, when you’re writing programs, it’s
    good practice to take functions and types that work toward a similar purpose and
    put them in a separate module. That way, you can easily reuse those functions
    in other programs by just importing your module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头所说，当你编写程序时，将具有相似目的的功能和类型放入一个单独的模块中是一种良好的实践。这样，你只需导入你的模块，就可以轻松地在其他程序中重用这些函数。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802588.png.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802588.png.jpg)'
- en: We say that a module *exports* functions. When you import a module, you can
    use the functions that it exports. A module can also define functions that it
    uses internally, but we can see and use only the ones that it exports.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个模块*导出*函数。当你导入一个模块时，你可以使用它导出的函数。模块还可以定义它内部使用的函数，但我们只能看到和使用它导出的那些。
- en: A Geometry Module
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何模块
- en: To demonstrate, we’ll create a little module that provides some functions for
    calculating the volume and area of a few geometrical objects. We’ll start by creating
    a file called *Geometry.hs*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将创建一个提供一些用于计算几个几何对象体积和面积的函数的小模块。我们将首先创建一个名为*Geometry.hs*的文件。
- en: 'At the beginning of a module, we specify the module name. If we have a file
    called *Geometry.hs*, then we should name our module `Geometry`. We specify the
    functions that it exports, and then we can add the functions. So we’ll start with
    this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的开头，我们指定模块名称。如果我们有一个名为*Geometry.hs*的文件，那么我们应该将我们的模块命名为`Geometry`。我们指定它导出的函数，然后我们可以添加函数。所以我们将从以下内容开始：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, we’ll be doing areas and volumes for spheres, cubes, and cuboids.
    A sphere is a round thing like a grapefruit, a cube is like a game die, and a
    (rectangular) cuboid is like a box of cigarettes. (Kids, don’t smoke!)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将为球体、立方体和长方体计算面积和体积。球体就像葡萄柚一样是圆形的，立方体就像骰子，而（长方形的）长方体就像一盒香烟。（孩子们，不要吸烟！）
- en: 'Now let’s define our functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的函数：
- en: '[PRE61]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is pretty standard geometry, but there are a few items to note. One is
    that because a cube is only a special case of a cuboid, we define its area and
    volume by treating it as a cuboid whose sides are all of the same length. We also
    define a helper function called `rectArea`, which calculates a rectangle’s area
    based on the lengths of its sides. It’s rather trivial because it’s just multiplication.
    Notice that we used it in our functions in the module (in `cuboidArea` and `cuboidVolume`),
    but we didn’t export it! This is because we want our module to present just functions
    for dealing with three-dimensional objects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当标准的几何，但有几个需要注意的事项。一个是由于立方体只是长方体的特殊情况，我们通过将其视为所有边长都相同的立方体来定义其面积和体积。我们还定义了一个名为`rectArea`的辅助函数，它根据边的长度计算矩形的面积。它相当简单，因为它只是乘法。注意我们在模块中的函数（在`cuboidArea`和`cuboidVolume`中）使用了它，但我们没有导出它！这是因为我们希望我们的模块只提供处理三维对象的函数。
- en: When making a module, we usually export only those functions that act as a sort
    of interface to our module so that the implementation is hidden. People who use
    our `Geometry` module don’t need to concern themselves with functions that we
    don’t export. We can decide to change those functions completely or delete them
    in a newer version (we could delete `rectArea` and just use `*` instead), and
    no one will mind, because we didn’t export them in the first place.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块时，我们通常只导出那些作为我们模块接口的函数，以便隐藏实现细节。使用我们的`Geometry`模块的人不需要关心我们没有导出的函数。我们可以决定完全更改这些函数或在更新的版本中删除它们（我们可以删除`rectArea`并仅使用`*`），因为一开始我们没有导出它们，所以没有人会介意。
- en: 'To use our module, we just do this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的模块，我们只需这样做：
- en: '[PRE62]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: However, *Geometry.hs* must be in the same folder as the module that’s importing
    it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*Geometry.hs*必须放在导入它的模块所在的同一个文件夹中。
- en: Hierarchical Modules
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次化模块
- en: 'Modules can also be given a hierarchical structure. Each module can have a
    number of submodules, which can have submodules of their own. Let’s section our
    geometry functions so that `Geometry` is a module that has three submodules: one
    for each type of object.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模块也可以具有层次结构。每个模块可以包含多个子模块，这些子模块也可以有自己的子模块。让我们将几何函数分类，使`Geometry`成为一个包含三个子模块的模块：每个对象类型一个。
- en: 'First, we’ll make a folder called *Geometry*. In it, we’ll place three files:
    *Sphere.hs*, *Cuboid.hs*, and *Cube.hs*. Let’s look at what each of the files
    contains.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为*Geometry*的文件夹。在其中，我们将放置三个文件：*Sphere.hs*、*Cuboid.hs*和*Cube.hs*。让我们看看每个文件包含什么。
- en: 'Here are the contents of *Sphere.hs*:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*Sphere.hs*的内容：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The *Cuboid.hs* file looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cuboid.hs*文件看起来像这样：'
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And our last file, *Cube.hs*, has these contents:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个文件，*Cube.hs*，包含以下内容：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice how we placed *Sphere.hs* in a folder called *Geometry*, and then defined
    the module name as `Geometry.Sphere`. We did the same for the cube and cuboid
    objects. Also notice how in all three sub-modules, we defined functions with the
    same names. We can do this because they’re in separate modules.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将*Sphere.hs*放在名为*Geometry*的文件夹中，并将模块名称定义为`Geometry.Sphere`。我们对立方体和长方体对象也做了同样的事情。还要注意，在所有三个子模块中，我们定义了具有相同名称的函数。我们可以这样做，因为它们在不同的模块中。
- en: 'So, now we can do this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以这样做：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802590.png.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802590.png.jpg)'
- en: '[PRE66]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And then we can call `area` and `volume`, and they’ll give us the area and volume
    for a sphere.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调用`area`和`volume`，它们会给出球体的面积和体积。
- en: 'If we want to juggle two or more of these modules, we need to do qualified
    imports because they export functions with the same names. Here’s an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要处理两个或更多这样的模块，我们需要进行限定导入，因为它们导出了具有相同名称的函数。以下是一个例子：
- en: '[PRE67]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: And then we can call `Sphere.area`, `Sphere.volume`, `Cuboid.area`, and so on,
    and each will calculate the area or volume for its corresponding object.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调用`Sphere.area`、`Sphere.volume`、`Cuboid.area`等等，每个都会计算相应对象的面积或体积。
- en: The next time you find yourself writing a file that’s really big and has a lot
    of functions, look for functions that serve some common purpose and consider putting
    them in their own module. Then you’ll be able to just import your module the next
    time you’re writing a program that requires some of the same functionality.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当你发现自己正在编写一个非常大且有很多函数的文件时，寻找那些服务于某些共同目的的函数，并考虑将它们放入自己的模块中。这样，当你编写需要一些相同功能性的程序时，你就可以直接导入你的模块了。
