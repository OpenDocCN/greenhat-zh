- en: Chapter 12. Monoids
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章 单例
- en: 'This chapter features another useful and fun type class: `Monoid`. This type
    class is for types whose values can be combined together with a binary operation.
    We’ll cover exactly what monoids are and what their laws state. Then we’ll take
    a look at some monoids in Haskell and how they can be of use.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个有用且有趣的数据类型类：`Monoid`。这个数据类型类是为那些值可以通过二元运算组合在一起的数据类型。我们将详细介绍单例是什么以及它们的定律是什么。然后我们将看看Haskell中的几个单例以及它们如何有用。
- en: First, let’s take a look at the `newtype` keyword, because we’ll be using it
    a lot when we delve into the wonderful world of monoids.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`newtype`关键字，因为当我们深入到单例的奇妙世界时，我们会大量使用它。
- en: Wrapping an Existing Type into a New Type
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现有类型包装到新类型中
- en: So far, you’ve learned how to make your own algebraic data types by using the
    `data` keyword. You’ve also seen how to give existing types synonyms with the
    `type` keyword. In this section, we’ll look at how to make new types out of existing
    data types by using the `newtype` keyword. We’ll also talk about why we would
    want to do that in the first place.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何使用`data`关键字创建自己的代数数据类型。你也看到了如何使用`type`关键字给现有类型赋予同义词。在本节中，我们将探讨如何使用`newtype`关键字从现有数据类型创建新类型。我们还将讨论为什么我们最初想要这样做。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802658.png.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802658.png.jpg)'
- en: 'In [Chapter 11](ch11.html "Chapter 11. Applicative Functors"), you saw a couple
    of ways for the list type to be an applicative functor. One way is to have `<*>`
    take every function out of the list that is its left parameter and apply that
    to every value in the list that is on the right, resulting in every possible combination
    of applying a function from the left list to a value in the right list:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.html "第11章。应用函子")中，你看到了几种使列表类型成为应用函子的方法。一种方法是将`<*>`应用于列表中的每个函数，并将其应用于列表右侧的每个值，从而产生将左侧列表中的函数应用于右侧列表中值的所有可能组合：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second way is to take the first function on the left side of `<*>` and apply
    it to the first value on the right, then take the second function from the list
    on the left side and apply it to the second value on the right, and so on. Ultimately,
    it’s kind of like zipping the two lists together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是取`<*>`左侧的第一个函数并将其应用于右侧的第一个值，然后从左侧的列表中取第二个函数并将其应用于右侧的第二个值，以此类推。最终，这有点像将两个列表一起压缩。
- en: 'But lists are already an instance of `Applicative`, so how do we also make
    lists an instance of `Applicative` in this second way? As you learned, the `ZipList
    a` type was introduced for this reason. This type has one value constructor, `ZipList`,
    which has just one field. We put the list that we’re wrapping in that field. Then
    `ZipList` is made an instance of `Applicative`, so that when we want to use lists
    as applicatives in the zipping manner, we just wrap them with the `ZipList` constructor.
    Once we’re finished, we unwrap them with `getZipList`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但列表已经是`Applicative`的一个实例，那么我们如何以第二种方式也使列表成为`Applicative`的一个实例呢？正如你所学的，`ZipList
    a`类型就是为了这个原因被引入的。这个类型有一个值构造器`ZipList`，它只有一个字段。我们将我们要包装的列表放在这个字段中。然后`ZipList`被制作成一个`Applicative`的实例，这样当我们想要以压缩方式使用列表作为应用函子时，我们只需用`ZipList`构造函数将其包装起来。一旦完成，我们就可以用`getZipList`解包：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, what does this have to do with this `newtype` keyword? Well, think about
    how we might write the data declaration for our `ZipList a` type. Here’s one way:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这与这个`newtype`关键字有什么关系呢？好吧，想想我们如何为我们的`ZipList a`类型编写数据声明。这里有一种方法：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a type that has just one value constructor, and that value constructor
    has just one field that is a list of things. We might also want to use record
    syntax so that we automatically get a function that extracts a list from a `ZipList`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只有一个值构造器的类型，而这个值构造器只有一个字段，是一个事物列表。我们可能还想使用记录语法，这样我们就可以自动得到一个从`ZipList`中提取列表的函数：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This looks fine and would actually work pretty well. We had two ways of making
    an existing type an instance of a type class, so we used the `data` keyword to
    just wrap that type into another type and made the other type an instance in the
    second way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，实际上工作得相当好。我们有两种方法可以使现有类型成为类型类的一个实例，所以我们使用`data`关键字将那个类型包装到另一个类型中，并在第二种方式中使另一个类型成为实例。
- en: 'The `newtype` keyword in Haskell is made exactly for cases when we want to
    just take one type and wrap it in something to present it as another type. In
    the actual libraries, `ZipList a` is defined like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中的 `newtype` 关键字正是为了那些我们只想取一个类型并将其包装起来以呈现为另一种类型的情况。在实际库中，`ZipList a`
    被定义为如下：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of the `data` keyword, the `newtype` keyword is used. Now why is that?
    Well for one, `newtype` is faster. If you use the `data` keyword to wrap a type,
    there’s some overhead to all that wrapping and unwrapping when your program is
    running. But if you use `newtype`, Haskell knows that you’re just using it to
    wrap an existing type into a new type (hence the name), because you want it to
    be the same internally but have a different type. With that in mind, Haskell can
    get rid of the wrapping and unwrapping once it resolves which value is of which
    type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于 `data` 关键字，我们使用 `newtype` 关键字。那么为什么是 `newtype` 呢？首先，`newtype` 更快。如果你使用 `data`
    关键字来包装一个类型，当你的程序运行时，会有一些开销，因为所有的包装和解包。但是如果你使用 `newtype`，Haskell 知道你只是用它来将现有类型包装成新类型（因此得名），因为你希望它在内部相同但类型不同。有了这个想法，Haskell
    会在确定哪个值属于哪种类型后，去除包装和解包。
- en: 'So why not just use `newtype` instead of `data` all the time? When you make
    a new type from an existing type by using the `newtype` keyword, you can have
    only one value constructor, and that value constructor can have only one field.
    But with `data`, you can make data types that have several value constructors,
    and each constructor can have zero or more fields:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那为什么不用 `newtype` 而不是 `data` 始终如一呢？当你使用 `newtype` 关键字从一个现有类型创建新类型时，你只能有一个值构造函数，而这个构造函数只能有一个字段。但是使用
    `data`，你可以创建具有多个值构造函数的数据类型，每个构造函数可以有零个或多个字段：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also use the `deriving` keyword with `newtype` just as we would with
    `data`. We can derive instances for `Eq`, `Ord`, `Enum`, `Bounded`, `Show`, and
    `Read`. If we derive the instance for a type class, the type that we’re wrapping
    must already be in that type class. It makes sense, because `newtype` just wraps
    an existing type. So now if we do the following, we can print and equate values
    of our new type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像使用 `data` 一样使用 `deriving` 关键字与 `newtype`。我们可以为 `Eq`、`Ord`、`Enum`、`Bounded`、`Show`
    和 `Read` 导出实例。如果我们为类型类导出实例，我们包装的类型必须已经在该类型类中。这是有道理的，因为 `newtype` 只是对现有类型的包装。因此，现在如果我们这样做，我们可以打印和比较我们新类型的值：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s give that a go:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this particular `newtype`, the value constructor has the following type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的 `newtype` 中，值构造函数具有以下类型：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It takes a `[Char]` value, such as `"my sharona"` and returns a `CharList`
    value. From the preceding examples where we used the `CharList` value constructor,
    we see that really is the case. Conversely, the `getCharList` function, which
    was generated for us because we used record syntax in our `newtype`, has this
    type:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个 `[Char]` 值，例如 `"my sharona"`，并返回一个 `CharList` 值。从前面的例子中，我们使用了 `CharList`
    值构造函数，我们可以看到这确实是正确的。相反，`getCharList` 函数，由于我们在 `newtype` 中使用了记录语法，因此为我们生成，具有以下类型：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It takes a `CharList` value and converts it to a `[Char]` value. You can think
    of this as wrapping and unwrapping, but you can also think of it as converting
    values from one type to the other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个 `CharList` 值并将其转换为 `[Char]` 值。你可以将其视为包装和解包，但你也可以将其视为将值从一种类型转换为另一种类型。
- en: Using newtype to Make Type Class Instances
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `newtype` 创建类型类实例
- en: 'Many times, we want to make our types instances of certain type classes, but
    the type parameters just don’t match up for what we want to do. It’s easy to make
    `Maybe` an instance of `Functor`, because the `Functor` type class is defined
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，我们希望使我们的类型成为某些类型类的实例，但类型参数并不匹配我们想要做的事情。使 `Maybe` 成为 `Functor` 的实例很容易，因为
    `Functor` 类型类的定义如下：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So we just start out with this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需从以下内容开始：
- en: '[PRE11]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then we implement `fmap`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现 `fmap`。
- en: 'All the type parameters add up because `Maybe` takes the place of `f` in the
    definition of the `Functor` type class. Looking at `fmap` as if it worked on only
    `Maybe`, it ends up behaving like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型参数加起来是因为 `Maybe` 在 `Functor` 类型类的定义中取代了 `f`。如果我们把 `fmap` 看作只作用于 `Maybe`，它最终会表现得像这样：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Isn’t that just peachy? Now what if we wanted to make the tuple an instance
    of `Functor` in such a way that when we `fmap` a function over a tuple, it is
    applied to the first component of the tuple? That way, doing `fmap (+3) (1, 1)`
    would result in `(4, 1)`. It turns out that writing the instance for that is kind
    of hard. With `Maybe`, we just say `instance Functor Maybe where` because only
    type constructors that take exactly one parameter can be made an instance of `Functor`.
    But it seems like there’s no way to do something like that with `(a, b)` so that
    the type parameter `a` ends up being the one that changes when we use `fmap`.
    To get around this, we can `newtype` our tuple in such a way that the second type
    parameter represents the type of the first component in the tuple:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很好吗？现在如果我们想以这种方式使元组成为 `Functor` 的一个实例，即当我们对元组上的 `fmap` 函数进行操作时，它会被应用到元组的第一个组件上？这样，执行
    `fmap (+3) (1, 1)` 将会得到 `(4, 1)`。结果证明，为这个写实例有点困难。对于 `Maybe`，我们只需说 `instance Functor
    Maybe where`，因为只有接受恰好一个参数的类型构造函数才能成为 `Functor` 的一个实例。但似乎没有方法可以对 `(a, b)` 做出类似的事情，这样类型参数
    `a` 就会在我们使用 `fmap` 时改变。为了解决这个问题，我们可以以某种方式 `newtype` 我们的元组，使得第二个类型参数代表元组中第一个组件的类型：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802660.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802660.png.jpg)'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And now we can make it an instance of `Functor` so that the function is mapped
    over the first component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其变成 `Functor` 的一个实例，这样函数就会映射到第一个组件：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we can pattern match on types defined with `newtype`. We pattern
    match to get the underlying tuple, apply the function `f` to the first component
    in the tuple, and then use the `Pair` value constructor to convert the tuple back
    to our `Pair b a`. If we imagine what the type `fmap` would be if it worked only
    on our new pairs, it would look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以对使用 `newtype` 定义的类型进行模式匹配。我们进行模式匹配以获取底层的元组，将函数 `f` 应用到元组的第一个组件上，然后使用
    `Pair` 值构造函数将元组转换回我们的 `Pair b a`。如果我们想象如果 `fmap` 只在新的元组上工作，它的类型会是什么样子，它看起来会是这样：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Again, we said `instance Functor (Pair c) where`, and so `Pair c` took the
    place of the `f` in the type class definition for `Functor`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们说 `instance Functor (Pair c) where`，因此 `Pair c` 替换了 `Functor` 类型类定义中的 `f`：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now if we convert a tuple into a `Pair b a`, we can use `fmap` over it, and
    the function will be mapped over the first component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把一个元组转换成 `Pair b a`，我们就可以在它上面使用 `fmap`，函数会被映射到第一个组件：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On newtype Laziness
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 `newtype` 惰性
- en: The only thing that can be done with `newtype` is turning an existing type into
    a new type, so internally, Haskell can represent the values of types defined with
    `newtype` just like the original ones, while knowing that their types are now
    distinct. This means that not only is `newtype` usually faster than `data`, its
    pattern-matching mechanism is lazier. Let’s take a look at what this means.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`newtype` 可以做的唯一事情是将现有的类型转换成新的类型，因此内部上，Haskell 可以像原始类型一样表示使用 `newtype` 定义的类型的值，同时知道它们的类型现在是不同的。这意味着
    `newtype` 不仅通常比 `data` 快，它的模式匹配机制也更加惰性。让我们看看这意味着什么。'
- en: 'As you know, Haskell is lazy by default, which means that only when we try
    to actually print the results of our functions will any computation take place.
    Furthemore, only those computations that are necessary for our function to tell
    us the result will be carried out. The `undefined` value in Haskell represents
    an erroneous computation. If we try to evaluate it (that is, force Haskell to
    actually compute it) by printing it to the terminal, Haskell will throw a hissy
    fit (technically referred to as an exception):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Haskell 默认是惰性的，这意味着只有当我们尝试实际打印函数的结果时，才会进行任何计算。更进一步，只有那些对我们函数来说必要的计算才会被执行。Haskell
    中的 `undefined` 值代表一个错误的计算。如果我们尝试评估它（即，强制 Haskell 实际计算它）通过将其打印到终端，Haskell 将会抛出一个异常（技术上称为异常）：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, if we make a list that has some `undefined` values in it but request
    only the head of the list, which is not `undefined`, everything will go smoothly.
    This is because Haskell doesn’t need to evaluate any other elements in a list
    if we want to see only the first element. Here’s an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们创建一个包含一些 `undefined` 值的列表，但只请求列表的头部，它不是 `undefined`，一切都会顺利。这是因为如果我们只想看到列表的第一个元素，Haskell
    不需要评估列表中的其他任何元素。以下是一个例子：
- en: '[PRE19]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now consider the following type:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下类型：
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It’s your run-of-the-mill algebraic data type that was defined with the `data`
    keyword. It has one value constructor, which has one field whose type is `Bool`.
    Let’s make a function that pattern matches on a `CoolBool` and returns the value
    `"hello"`, regardless of whether the `Bool` inside the `CoolBool` was `True` or
    `False`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你用 `data` 关键字定义的普通的代数数据类型。它有一个值构造函数，该构造函数有一个字段，其类型为 `Bool`。让我们编写一个函数，该函数对
    `CoolBool` 进行模式匹配，并返回值 `"hello"`，无论 `CoolBool` 内部的 `Bool` 是 `True` 还是 `False`：
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Instead of applying this function to a normal `CoolBool`, let’s throw it a curveball
    and apply it to `undefined`!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将这个函数应用到正常的 `CoolBool` 上，而是给它一个惊喜，将其应用到 `undefined` 上！
- en: '[PRE22]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Yikes! An exception! Why did this exception happen? Types defined with the `data`
    keyword can have multiple value constructors (even though `CoolBool` has only
    one). So in order to see if the value given to our function conforms to the `(CoolBool
    _)` pattern, Haskell must evaluate the value just enough to see which value constructor
    was used when we made the value. And when we try to evaluate an `undefined` value,
    even a little, an exception is thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！一个异常！为什么会出现这个异常？使用 `data` 关键字定义的类型可以有多个值构造函数（尽管 `CoolBool` 只有一个）。所以为了查看传递给我们的函数的值是否符合
    `(CoolBool _)` 模式，Haskell 必须评估值，以便看到我们在创建值时使用了哪个值构造函数。而且当我们尝试评估一个 `undefined`
    值时，即使是稍微评估一下，也会抛出异常。
- en: 'Instead of using the `data` keyword for `CoolBool`, let’s try using `newtype`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `CoolBool`，我们不用 `data` 关键字，而是尝试使用 `newtype`：
- en: '[PRE23]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We don’t need to change our `helloMe` function, because the pattern-matching
    syntax is the same whether you use `newtype` or `data` to define your type. Let’s
    do the same thing here and apply `helloMe` to an `undefined` value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要更改我们的 `helloMe` 函数，因为无论你使用 `newtype` 还是 `data` 来定义你的类型，模式匹配语法都是相同的。让我们在这里做同样的事情，并将
    `helloMe` 应用到一个 `undefined` 值上：
- en: '[PRE24]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It worked! Hmmm, why is that? Well, as you’ve learned, when you use `newtype`,
    Haskell can internally represent the values of the new type in the same way as
    the original values. It doesn’t need to add another box around them; it just must
    be aware of the values being of different types. And because Haskell knows that
    types made with the `newtype` keyword can have only one constructor, it doesn’t
    need to evaluate the value passed to the function to make sure that the value
    conforms to the `(CoolBool _)` pattern, because `newtype` types can have only
    one possible value constructor and one field!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！嗯，为什么是这样呢？好吧，正如你所学的，当你使用 `newtype` 时，Haskell 可以在内部以与原始值相同的方式表示新类型的值。它不需要为它们添加另一个盒子；它只需要知道这些值是不同类型的。而且因为
    Haskell 知道使用 `newtype` 关键字创建的类型只能有一个构造函数，所以它不需要评估传递给函数的值以确保该值符合 `(CoolBool _)`
    模式，因为 `newtype` 类型只能有一个可能的价值构造函数和一个字段！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802662.png.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802662.png.jpg)'
- en: This difference in behavior may seem trivial, but it’s actually pretty important.
    It shows that even though types defined with `data` and `newtype` behave similarly
    from the programmer’s point of view (because they both have value constructors
    and fields), they are actually two different mechanisms. Whereas `data` can be
    used to make your own types from scratch, `newtype` is just for making a completely
    new type out of an existing type. Pattern matching on `newtype` values isn’t like
    taking something out of a box (as it is with `data`), but more about making a
    direct conversion from one type to another.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为上的差异可能看起来微不足道，但实际上非常重要。它表明，尽管使用 `data` 和 `newtype` 定义的类型在程序员看来行为相似（因为它们都有值构造函数和字段），但实际上它们是两种不同的机制。`data`
    可以用来从头开始创建自己的类型，而 `newtype` 只是从一个已存在的类型中创建一个全新的类型。对 `newtype` 值的模式匹配不像从盒子里取出东西（就像
    `data` 那样），而是更像是直接从一种类型转换到另一种类型。
- en: type vs. newtype vs. data
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`type` 与 `newtype` 与 `data`'
- en: At this point, you may be a bit confused about the differences between `type`,
    `data`, and `newtype`, so let’s review their uses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能对 `type`、`data` 和 `newtype` 之间的区别感到有些困惑，所以让我们回顾一下它们的用法。
- en: 'The `type` keyword is for making type synonyms. We just give another name to
    an already existing type so that the type is easier to refer to. Say we did the
    following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 关键字用于创建类型别名。我们只是给一个已存在的类型起另一个名字，以便更容易引用该类型。比如说我们做了以下操作：'
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All this does is allow us to refer to the `[Int]` type as `IntList`. They can
    be used interchangeably. We don’t get an `IntList` value constructor or anything
    like that. Because `[Int]` and `IntList` are only two ways to refer to the same
    type, it doesn’t matter which name we use in our type annotations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是允许我们将 `[Int]` 类型称为 `IntList`。它们可以互换使用。我们不会得到 `IntList` 值构造函数或类似的东西。因为 `[Int]`
    和 `IntList` 只是引用同一类型的两种方式，所以我们在类型注解中使用哪个名称都无关紧要：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use type synonyms when we want to make our type signatures more descriptive.
    We give types names that tell us something about their purpose in the context
    of the functions where they’re being used. For instance, when we used an association
    list of type `[(String, String)]` to represent a phone book in [Chapter 7](ch07.html
    "Chapter 7. Making Our Own Types and Type Classes"), we gave it the type synonym
    of `PhoneBook` so that the type signatures of our functions were easier to read.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要使我们的类型签名更具描述性时，我们会使用类型同义词（type synonyms）。我们给类型命名，以便在它们被使用的函数的上下文中告诉我们它们的作用。例如，当我们使用类型为
    `[(String, String)]` 的关联列表来表示电话簿时，我们在第 7 章（[Chapter 7](ch07.html "Chapter 7. Making
    Our Own Types and Type Classes")）中给它命名为 `PhoneBook`，这样我们的函数的类型签名就更容易阅读了。
- en: 'The `newtype` keyword is for taking existing types and wrapping them in new
    types, mostly so it’s easier to make them instances of certain type classes. When
    we use `newtype` to wrap an existing type, the type that we get is separate from
    the original type. Suppose we make the following `newtype`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`newtype` 关键字用于将现有类型封装在新类型中，这主要是为了让它们更容易成为某些类型类（type class）的实例。当我们使用 `newtype`
    封装现有类型时，得到的类型与原始类型是分开的。假设我们创建以下 `newtype`：'
- en: '[PRE27]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can’t use `++` to put together a `CharList` and a list of type `[Char]`.
    We can’t even use `++` to put together two `CharList` lists, because `++` works
    only on lists, and the `CharList` type isn’t a list, even though it could be said
    that `CharList` contains a list. We can, however, convert two `CharList`s to lists,
    `++` them, and then convert that back to a `CharList`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 `++` 来组合 `CharList` 和类型为 `[Char]` 的列表。我们甚至不能使用 `++` 来组合两个 `CharList`
    列表，因为 `++` 只在列表上工作，而 `CharList` 类型不是列表，尽管可以说 `CharList` 包含一个列表。然而，我们可以将两个 `CharList`
    转换为列表，使用 `++` 组合它们，然后将结果转换回 `CharList`。
- en: When we use record syntax in our `newtype` declarations, we get functions for
    converting between the new type and the original type—namely the value constructor
    of our `newtype` and the function for extracting the value in its field. The new
    type also isn’t automatically made an instance of the type classes that the original
    type belongs to, so we need to derive or manually write it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `newtype` 声明中使用记录语法时，我们会得到在新的类型和原始类型之间进行转换的函数——即我们的 `newtype` 的值构造函数以及从其字段中提取值的函数。新的类型也不会自动成为原始类型所属的类型类的实例，因此我们需要推导或手动编写它。
- en: In practice, you can think of `newtype` declarations as `data` declarations
    that can have only one constructor and one field. If you catch yourself writing
    such a `data` declaration, consider using `newtype`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可以将 `newtype` 声明视为只能有一个构造函数和一个字段的 `data` 声明。如果你发现自己正在编写这样的 `data` 声明，考虑使用
    `newtype`。
- en: The `data` keyword is for making your own data types. You can go hog wild with
    them. They can have as many constructors and fields as you wish and can be used
    to implement any algebraic data type—everything from lists and `Maybe`-like types
    to trees.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 关键字用于创建自己的数据类型。你可以随意使用它们。它们可以有任意多的构造函数和字段，并且可以用来实现任何代数数据类型——从列表和类似 `Maybe`
    的类型到树。'
- en: 'In summary, use the keywords as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，以下是如何使用这些关键字：
- en: If you just want your type signatures to look cleaner and be more descriptive,
    you probably want type synonyms.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是想让你的类型签名看起来更整洁、更具描述性，那么你可能想要使用类型同义词。
- en: If you want to take an existing type and wrap it in a new type in order to make
    it an instance of a type class, chances are you’re looking for a `newtype`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要将现有类型封装成新类型以便使其成为类型类的实例，那么你很可能是在寻找 `newtype`。
- en: If you want to make something completely new, odds are good that you’re looking
    for the `data` keyword.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要创建全新的东西，那么很可能你是在寻找 `data` 关键字。
- en: About Those Monoids
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于那些幺半群
- en: Type classes in Haskell are used to present an interface for types that have
    some behavior in common. We started out with simple type classes like `Eq`, which
    is for types whose values can be equated, and `Ord`, which is for things that
    can be put in an order. Then we moved on to more interesting type classes, like
    `Functor` and `Applicative`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 中的类型类用于表示具有某些共同行为的类型。我们最初从简单的类型类 `Eq` 开始，它是用于可以相等比较的类型的值，以及 `Ord`，它是用于可以排序的事物。然后我们转向更有趣的类型类，如
    `Functor` 和 `Applicative`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802664.png.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802664.png.jpg)'
- en: When we make a type, we think about which behaviors it supports (what it can
    act like) and then decide which type classes to make it an instance of based on
    the behavior we want. If it makes sense for values of our type to be equated,
    we make our type an instance of the `Eq` type class. If we see that our type is
    some kind of functor, we make it an instance of `Functor`, and so on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个类型时，我们会考虑它支持哪些行为（它能像什么一样行动），然后根据我们想要的行为决定将其作为哪个类型类的实例。如果我们的类型值可以相等比较，我们就将我们的类型作为
    `Eq` 类型类的实例。如果我们看到我们的类型是一种类型的函子，我们就将其作为 `Functor` 的实例，等等。
- en: 'Now consider the following: `*` is a function that takes two numbers and multiplies
    them. If we multiply some number with a `1`, the result is always equal to that
    number. It doesn’t matter if we do `1 * x` or `x * 1`— the result is always `x`.
    Similarly, `++` is a function that takes two things and returns a third. But instead
    of multiplying numbers, it takes two lists and concatenates them. And much like
    `*`, it also has a certain value that doesn’t change the other one when used with
    `++`. That value is the empty list: `[]`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下情况：`*` 是一个接受两个数字并将它们相乘的函数。如果我们用一个 `1` 乘以某个数字，结果总是等于那个数字。无论是 `1 * x` 还是
    `x * 1`，结果总是 `x`。同样，`++` 是一个接受两个东西并返回第三个东西的函数。但它不是乘以数字，而是接受两个列表并将它们连接起来。并且与 `*`
    类似，它也有一个不会改变另一个值的特定值，当与 `++` 一起使用时。这个值是空列表：`[]`。
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It seems that `*` together with `1` and `++` along with `[]` share some common
    properties:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 `*` 与 `1` 以及 `++` 与 `[]` 具有一些共同的特性：
- en: The function takes two parameters.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接受两个参数。
- en: The parameters and the returned value have the same type.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数和返回值具有相同的类型。
- en: There exists such a value that doesn’t change other values when used with the
    binary function.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在这样一个值，当与二元函数一起使用时不会改变其他值。
- en: 'There’s another thing that these two operations have in common that may not
    be as obvious as our previous observations: When we have three or more values
    and we want to use the binary function to reduce them to a single result, the
    order in which we apply the binary function to the values doesn’t matter. For
    example, whether we use `(3 * 4) * 5` or `3 * (4 * 5)`, the result is `60`. The
    same goes for `++`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个操作还有另一个共同点，可能不像我们之前的观察那么明显：当我们有三个或更多值，并且我们想要使用二元函数将它们减少到单个结果时，我们应用二元函数到值的顺序并不重要。例如，无论是
    `(3 * 4) * 5` 还是 `3 * (4 * 5)`，结果都是 `60`。对于 `++` 也是如此：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We call this property *associativity*. `*` is associative, and so is `++`. However,
    `-`, for example, is not associative; the expressions `(5 - 3) - 4` and `5 - (3
    - 4)` result in different numbers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个属性为*结合律*。`*` 是结合的，`++` 也是。然而，例如 `-` 并不是结合的；表达式 `(5 - 3) - 4` 和 `5 - (3
    - 4)` 得到的数字是不同的。
- en: By being aware of these properties, we have chanced upon monoids!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解这些属性，我们偶然发现了单子！
- en: The Monoid Type Class
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子类型类
- en: 'A *monoid* is made up of an associative binary function and a value that acts
    as an identity with respect to that function. When something acts as an identity
    with respect to a function, it means that when called with that function and some
    other value, the result is always equal to that other value. `1` is the identity
    with respect to `*`, and `[]` is the identity with respect to `++`. There are
    a lot of other monoids to be found in the world of Haskell, which is why the `Monoid`
    type class exists. It’s for types that can act like monoids. Let’s see how the
    type class is defined:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *单子* 由一个结合的二元函数和一个作为该函数的恒等元的值组成。当某个东西在函数中作为恒等元时，这意味着当与该函数和某个其他值一起调用时，结果总是等于那个其他值。`1`
    是 `*` 的恒等元，`[]` 是 `++` 的恒等元。在 Haskell 的世界中，还有很多其他单子可以找到，这就是为什么存在 `Monoid` 类型类。它是用于可以像单子一样的类型。让我们看看类型类是如何定义的：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Monoid` type class is defined in `import Data.Monoid`. Let’s take some
    time to get properly acquainted with it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monoid`类型类在`import Data.Monoid`中定义。让我们花些时间来正确地熟悉它。'
- en: First, we see that only concrete types can be made instances of `Monoid`, because
    the `m` in the type class definition doesn’t take any type parameters. This is
    different from `Functor` and `Applicative`, which require their instances to be
    type constructors that take one parameter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到只有具体类型可以被制作成`Monoid`的实例，因为类型类定义中的`m`不接受任何类型参数。这与需要其实例是接受一个参数的类型构造函数的`Functor`和`Applicative`不同。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802666.png.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802666.png.jpg)'
- en: The first function is `mempty`. It’s not really a function, since it doesn’t
    take parameters. It’s a polymorphic constant, kind of like `minBound` from `Bounded`.
    `mempty` represents the identity value for a particular monoid.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是`mempty`。它实际上不是一个函数，因为它不接受任何参数。它是一个多态常量，类似于`Bounded`中的`minBound`。`mempty`代表特定单例的恒等值。
- en: Next up, we have `mappend`, which, as you’ve probably guessed, is the binary
    function. It takes two values of the same type and returns another value of that
    same type. The decision to call it `mappend` was kind of unfortunate, because
    it implies that we’re appending two things in some way. While `++` does take two
    lists and append one to the other, `*` doesn’t really do any appending; it just
    multiplies two numbers together. When you meet other instances of `Monoid`, you’ll
    see that most of them don’t append values either. So avoid thinking in terms of
    appending and just think in terms of `mappend` being a binary function that takes
    two monoid values and returns a third.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍`mappend`，正如你可能猜到的，这是一个二元函数。它接受两个相同类型的值，并返回另一个相同类型的值。将其命名为`mappend`的决定多少有些不幸，因为它暗示我们在以某种方式附加两个东西。虽然`++`确实接受两个列表并将一个附加到另一个上，但`*`实际上并没有进行任何附加；它只是将两个数字相乘。当你遇到其他`Monoid`实例时，你会发现它们大多数也不会附加值。所以，避免从附加的角度思考，只需将`mappend`视为一个二元函数，它接受两个单例值并返回第三个值。
- en: The last function in this type class definition is `mconcat`. It takes a list
    of monoid values and reduces them to a single value by using `mappend` between
    the list’s elements. It has a default implementation, which just takes `mempty`
    as a starting value and folds the list from the right with `mappend`. Because
    the default implementation is fine for most instances, we won’t concern ourselves
    with `mconcat` too much. When making a type an instance of `Monoid`, it suffices
    to just implement `mempty` and `mappend`. Although for some instances, there might
    be a more efficient way to implement `mconcat`, the default implementation is
    just fine for most cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类型类定义中的最后一个函数是`mconcat`。它接受一个单例值列表，并通过在列表元素之间使用`mappend`将它们归约为一个单一值。它有一个默认实现，它只是将`mempty`作为起始值，并从右向左折叠列表使用`mappend`。因为默认实现对于大多数实例来说都很好，所以我们不会过多关注`mconcat`。当将一个类型作为`Monoid`的实例时，只需实现`mempty`和`mappend`就足够了。尽管对于某些实例，可能存在更有效的方法来实现`mconcat`，但默认实现对于大多数情况来说已经足够好了。
- en: The Monoid Laws
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例定律
- en: Before moving on to specific instances of `Monoid`, let’s take a brief look
    at the monoid laws.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到`Monoid`的具体实例之前，让我们简要地看一下单例定律。
- en: 'You’ve learned that there must be a value that acts as the identity with respect
    to the binary function and that the binary function must be associative. It’s
    possible to make instances of `Monoid` that don’t follow these rules, but such
    instances are of no use to anyone because when using the `Monoid` type class,
    we rely on its instances acting like monoids. Otherwise, what’s the point? That’s
    why when making monoid instances, we need to make sure they follow these laws:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到必须有一个值作为二元函数的恒等值，并且二元函数必须是结合的。可以创建不遵循这些规则的`Monoid`实例，但这样的实例对任何人都没有用处，因为当我们使用`Monoid`类型类时，我们依赖于其实例像单例一样行动。否则，这有什么意义？这就是为什么在创建单例实例时，我们需要确保它们遵循这些定律：
- en: '``mempty `mappend` x = x``'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``mempty `mappend` x = x``'
- en: '``x `mappend` mempty = x``'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``x `mappend` mempty = x``'
- en: '``(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)``'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)``'
- en: The first two laws state that `mempty` must act as the identity with respect
    to `mappend`, and the third says that `mappend` must be associative (the order
    in which we use `mappend` to reduce several monoid values into one doesn’t matter).
    Haskell doesn’t enforce these laws, so we need to be careful that our instances
    do indeed obey them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前两条定律说明 `mempty` 必须作为 `mappend` 的单位，第三条定律说明 `mappend` 必须是结合的（我们使用 `mappend`
    将几个幺半群值归一化的顺序并不重要）。Haskell 不强制执行这些定律，因此我们需要小心确保我们的实例确实遵守它们。
- en: Meet Some Monoids
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识一些幺半群
- en: Now that you know what monoids are about, let’s look at some Haskell types that
    are monoids, what their `Monoid` instances look like, and their uses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了幺半群的相关知识，让我们看看一些 Haskell 类型是幺半群，它们的 `Monoid` 实例是什么样的，以及它们的用途。
- en: Lists Are Monoids
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表是幺半群
- en: 'Yes, lists are monoids! As you’ve seen, the `++` function and the empty list
    `[]` form a monoid. The instance is very simple:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，列表是幺半群！正如你所看到的，`++` 函数和空列表 `[]` 构成了一个幺半群。实例非常简单：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lists are an instance of the `Monoid` type class, regardless of the type of
    the elements they hold. Notice that we wrote `instance Monoid [a]` and not `instance
    Monoid []`, because `Monoid` requires a concrete type for an instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是 `Monoid` 类型类的一个实例，无论它们包含的元素类型如何。注意，我们写了 `instance Monoid [a]` 而不是 `instance
    Monoid []`，因为 `Monoid` 要求实例有一个具体的类型。
- en: 'Giving this a test run, we encounter no surprises:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 进行测试运行，我们没有遇到任何惊喜：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802668.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages802668.png.jpg)'
- en: Notice that in the last line, we wrote an explicit type annotation. If we just
    wrote `mempty`, GHCi wouldn’t know which instance to use, so we needed to say
    we want the list instance. We were able to use the general type of `[a]` (as opposed
    to specifying `[Int]` or `[String]`) because the empty list can act as if it contains
    any type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一行，我们写了一个显式的类型注解。如果我们只写了 `mempty`，GHCi 就不知道要使用哪个实例，因此我们需要说明我们想要列表实例。我们能够使用
    `[a]` 的通用类型（而不是指定 `[Int]` 或 `[String]`），因为空列表可以充当包含任何类型的容器。
- en: Because `mconcat` has a default implementation, we get it for free when we make
    something an instance of `Monoid`. In the case of the list, `mconcat` turns out
    to be just `concat`. It takes a list of lists and flattens it, because that’s
    the equivalent of doing `++` between all the adjacent lists in a list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `mconcat` 有一个默认实现，当我们使某个东西成为 `Monoid` 的实例时，我们就可以免费获得它。在列表的情况下，`mconcat` 证明就是
    `concat`。它接受一个列表的列表并将其展平，因为这相当于在列表中所有相邻列表之间进行 `++` 操作。
- en: The monoid laws do indeed hold for the list instance. When we have several lists
    and we `mappend` (or `++`) them together, it doesn’t matter which ones we do first,
    because they’re just joined at the ends anyway. Also, the empty list acts as the
    identity, so all is well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群定律确实适用于列表实例。当我们有几个列表并将它们 `mappend`（或 `++`）在一起时，我们首先做哪一个并不重要，因为它们最终只是连接在末尾。此外，空列表充当单位，所以一切顺利。
- en: 'Notice that monoids don’t require that ``a `mappend` b`` be equal to ``b `mappend`
    a``. In the case of the list, they clearly aren’t:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，幺半群不需要 `a `mappend` b` 等于 `b `mappend` a`。在列表的情况下，显然不是这样的：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And that’s okay. The fact that for multiplication `3 * 5` and `5 * 3` are the
    same is just a property of multiplication, but it doesn’t hold for all (and indeed,
    most) monoids.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以接受的。对于乘法来说，`3 * 5` 和 `5 * 3` 是相同的，这只是乘法的一个属性，但并不是所有（实际上，大多数）幺半群都如此。
- en: Product and Sum
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 乘积和和
- en: 'We already examined one way for numbers to be considered monoids: Just let
    the binary function be `*` and the identity value be `1`. Another way for numbers
    to be monoids is to have the binary function be `+` and the identity value be
    `0`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经考察了一种将数字视为幺半群的方法：只需让二元函数为 `*`，单位值为 `1`。另一种将数字视为幺半群的方法是让二元函数为 `+`，单位值为 `0`：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The monoid laws hold, because if you add 0 to any number, the result is that
    number. And addition is also associative, so we have no problems there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群定律成立，因为如果你将 `0` 加到任何数字上，结果就是那个数字。加法也是结合的，所以我们没有问题。
- en: With two equally valid ways for numbers to be monoids, which way do we choose?
    Well, we don’t have to pick. Remember that when there are several ways for some
    type to be an instance of the same type class, we can wrap that type in a `newtype`
    and then make the new type an instance of the type class in a different way. We
    can have our cake and eat it too.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种同样有效的方式让数字成为单子，我们选择哪一种呢？好吧，我们不必选择。记住，当某个类型有几种方式成为相同类型类（type class）的实例时，我们可以将这个类型包裹在一个`newtype`中，然后以不同的方式让这个新类型成为类型类的实例。我们可以既吃蛋糕又吃蛋糕。
- en: 'The `Data.Monoid` module exports two types for this: `Product` and `Sum`. `Product`
    is defined like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Data.Monoid`模块导出两种类型用于此目的：`Product`和`Sum`。`Product`的定义如下：'
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It’s simple—just a `newtype` wrapper with one type parameter along with some
    derived instances. Its instance for `Monoid` goes something like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——只是一个带有单个类型参数的`newtype`包装器，以及一些派生实例。它的`Monoid`实例定义如下：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`mempty` is just `1` wrapped in a `Product` constructor. `mappend` pattern
    matches on the `Product` constructor, multiplies the two numbers, and then wraps
    the resulting number. As you can see, there’s a `Num a` class constraint. This
    means that `Product a` is an instance of `Monoid` for all `a` values that are
    already an instance of `Num`. To use `Product a` as a monoid, we need to do some
    `newtype` wrapping and unwrapping:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`mempty`只是`1`被包裹在`Product`构造函数中。`mappend`在`Product`构造函数上模式匹配，将两个数字相乘，然后将结果数字包裹起来。正如你所看到的，有一个`Num
    a`类约束。这意味着对于所有已经是`Num`实例的`a`值，`Product a`是`Monoid`的实例。为了将`Product a`用作单子，我们需要进行一些`newtype`的包裹和展开：'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`Sum` is defined along the same lines as `Product`, and the instance is similar
    as well. We use it in the same way:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum`的定义与`Product`相同，实例也类似。我们以相同的方式使用它：'
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Any and All
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何和所有
- en: 'Another type that can act like a monoid in two distinct but equally valid ways
    is `Bool`. The first way is to have the function `||`, which represents a logical
    OR, act as the binary function along with `False` as the identity value. With
    the logical OR, if any of the two parameters is `True`, it returns `True`; otherwise,
    it returns `False`. So if we use `False` as the identity value, OR will return
    `False` when used with `False` and `True` when used with `True`. The `Any newtype`
    constructor is an instance of `Monoid` in this fashion. It’s defined like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以以两种不同但同样有效的方式表现得像单子（monoid）的类型是`Bool`。第一种方式是让表示逻辑或（OR）的函数`||`作为二元函数，同时使用`False`作为单位值。使用逻辑或时，如果两个参数中的任何一个为`True`，它就返回`True`；否则返回`False`。因此，如果我们使用`False`作为单位值，那么与`False`结合时返回`False`，与`True`结合时返回`True`。`Any
    newtype`构造函数就是这样成为`Monoid`实例的。它的定义如下：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Its instance looks like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它的实例看起来是这样的：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It’s called `Any` because ``x `mappend` y`` will be `True` if *any* one of
    those two is `True`. Even if three or more `Any` wrapped `Bool` values are `mappend`ed
    together, the result will hold `True` if any of them are `True`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为`Any`是因为`x `mappend` y`如果其中任何一个为`True`，就会返回`True`。即使三个或更多的`Any`包裹的`Bool`值被`mappend`在一起，只要其中任何一个为`True`，结果就会保持`True`：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The other way for `Bool` to be an instance of `Monoid` is to kind of do the
    opposite: Have `&&` be the binary function and then make `True` the identity value.
    Logical AND will return `True` only if both of its parameters are `True`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bool`成为`Monoid`实例的另一种方式是做相反的事情：让`&&`作为二元函数，然后让`True`作为单位值。逻辑与（AND）只有在两个参数都为`True`时才会返回`True`。'
- en: 'This is the `newtype` declaration:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`newtype`声明：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And this is the instance:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实例：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we `mappend` values of the `All` type, the result will be `True` only
    if *all* the values used in the `mappend` operations are `True`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们`mappend``All`类型的值时，结果只有在`mappend`操作中使用的所有值都为`True`时才会是`True`：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Just as with multiplication and addition, we usually explicitly state the binary
    functions instead of wrapping them in `newtype`s and then using `mappend` and
    `mempty`. `mconcat` seems useful for `Any` and `All`, but usually it’s easier
    to use the `or` and `and` functions. `or` takes lists of `Bool` values and returns
    `True` if any of them are `True`. `and` takes the same values and returns `True`
    if all of them are `True`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 就像乘法和加法一样，我们通常明确地声明二元函数，而不是将它们包裹在`newtype`s中，然后使用`mappend`和`mempty`。`mconcat`对于`Any`和`All`来说似乎很有用，但通常使用`or`和`and`函数更容易。`or`接受`Bool`值的列表，如果其中任何一个为`True`，就返回`True`。`and`接受相同的值，如果所有值都为`True`，则返回`True`。
- en: The Ordering Monoid
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序单子
- en: 'Remember the `Ordering` type? It’s used as the result when comparing things,
    and it can have three values: `LT`, `EQ`, and `GT`, which stand for less than,
    equal, and greater than, respectively.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`Ordering`类型吗？它在比较事物时用作结果，并且可以有三种值：`LT`、`EQ`和`GT`，分别代表小于、等于和大于。
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With lists, numbers, and Boolean values, finding monoids was just a matter
    of looking at already existing commonly used functions and seeing if they exhibited
    some sort of monoid behavior. With `Ordering`, we need to look a bit harder to
    recognize a monoid. It turns out that the ordering `Monoid` instance is just as
    intuitive as the ones we’ve met so far, and it’s also quite useful:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表、数字和布尔值，找到幺半群只是查看已经存在的常用函数，看看它们是否表现出某种幺半群行为。对于`Ordering`，我们需要更仔细地观察才能识别出幺半群。结果是，排序`Monoid`实例与我们之前遇到的实例一样直观，而且也非常有用：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The instance is set up like this: When we `mappend` two `Ordering` values,
    the one on the left is kept, unless the value on the left is `EQ`. If the value
    on the left is `EQ`, the right one is the result. The identity is `EQ`. At first,
    this may seem kind of arbitrary, but it actually resembles the way we alphabetically
    compare words. We look at the first two letters, and if they differ, we can already
    decide which word would go first in a dictionary. However, if the first two letters
    are equal, then we move on to comparing the next pair of letters and repeat the
    process.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实例设置如下：当我们对两个`Ordering`值进行`mappend`操作时，左边的值被保留，除非左边的值是`EQ`。如果左边的值是`EQ`，则右边的值是结果。恒等值是`EQ`。起初，这可能会显得有些随意，但实际上它与我们按字母顺序比较单词的方式相似。我们查看前两个字母，如果它们不同，我们就可以决定哪个单词在字典中排在前面。然而，如果前两个字母相同，我们就继续比较下一对字母，并重复这个过程。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802670.png.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802670.png.jpg)'
- en: For instance, when we alphabetically compare the words *ox* and *on*, we see
    that the first letter of each word is equal and then move on to comparing the
    second letter. Since *x* is alphabetically greater than *n*, we know how the words
    compare. To gain some understanding of `EQ` being the identity, note that if we
    were to cram the same letter in the same position in both words, it wouldn’t change
    their alphabetical ordering; for example, *oix* is still alphabetically greater
    than *oin*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们按字母顺序比较单词*ox*和*on*时，我们看到每个单词的第一个字母相同，然后我们继续比较第二个字母。由于*x*在字母表中大于*n*，我们知道这两个单词的比较结果。为了理解`EQ`作为恒等值的含义，请注意，如果我们把相同的字母放在两个单词的相同位置，这不会改变它们的字母顺序；例如，*oix*仍然在字母表中大于*oin*。
- en: 'It’s important to note that in the `Monoid` instance for `Ordering`, ``x `mappend`
    y`` doesn’t equal ``y `mappend` x``. Because the first parameter is kept unless
    it’s `EQ`, ``LT `mappend` GT`` will result in `LT`, whereas ``GT `mappend` LT``
    will result in `GT`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在`Ordering`的`Monoid`实例中，`x `mappend` y`不等于`y `mappend` x`。因为除非第一个参数是`EQ`，否则它会被保留，所以`LT
    `mappend` GT`的结果将是`LT`，而`GT `mappend` LT`的结果将是`GT`：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, so how is this monoid useful? Let’s say we are writing a function that
    takes two strings, compares their lengths, and returns an `Ordering`. But if the
    strings are of the same length, instead of returning `EQ` right away, we want
    to compare them alphabetically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么这个幺半群有什么用呢？假设我们正在编写一个函数，它接受两个字符串，比较它们的长度，并返回一个`Ordering`。但如果字符串长度相同，我们不想立即返回`EQ`，而是想按字母顺序比较它们。
- en: 'Here’s one way to write this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种编写方式：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We name the result of comparing the lengths `a` and the result of the alphabetical
    comparison `b`, and then if the lengths are equal, we return their alphabetical
    ordering.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比较长度的结果命名为`a`，将字母比较的结果命名为`b`，然后如果长度相等，我们返回它们的字母顺序。
- en: 'But by employing our understanding of how `Ordering` is a monoid, we can rewrite
    this function in a much simpler manner:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过运用我们对`Ordering`作为幺半群的理解，我们可以以更简单的方式重写这个函数：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let’s try this out:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Remember that when we use `mappend`, its left parameter is kept unless it’s
    `EQ`; if it’s `EQ`, the right one is kept. That’s why we put the comparison that
    we consider to be the first, more important, criterion as the first parameter.
    Now suppose that we want to expand this function to also compare for the number
    of vowels and set this to be the second most important criterion for comparison.
    We modify it like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们使用`mappend`时，除非它是`EQ`，否则其左参数会被保留；如果是`EQ`，则保留右参数。这就是为什么我们把我们认为的第一、更重要、标准作为第一个参数。现在假设我们想要扩展这个函数，使其也比较元音的数量，并将这个设置为比较的第二重要标准。我们修改它如下：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We made a helper function, which takes a string and tells us how many vowels
    it has by first filtering it for only letters that are in the string `"aeiou"`
    and then applying `length` to that.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个辅助函数，它接受一个字符串，并告诉我们它有多少元音，首先通过过滤字符串中的字母来仅保留在字符串`"aeiou"`中的字母，然后应用`length`。
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the first example, the lengths are found to be different, and so `LT` is
    returned, because the length of `"zen"` is less than the length of `"anna"`. In
    the second example, the lengths are the same, but the second string has more vowels,
    so `LT` is returned again. In the third example, they both have the same length
    and the same number of vowels, so they’re compared alphabetically, and `"zen"`
    wins.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，发现长度不同，因此返回`LT`，因为`"zen"`的长度小于`"anna"`的长度。在第二个例子中，长度相同，但第二个字符串有更多的元音，所以再次返回`LT`。在第三个例子中，它们的长度和元音数量都相同，所以它们按字母顺序比较，`"zen"`获胜。
- en: The `Ordering` monoid is very useful because it allows us to easily compare
    things by many different criteria and put those criteria in an order themselves,
    ranging from the most important to the least important.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ordering`单例非常有用，因为它允许我们通过许多不同的标准轻松比较事物，并将这些标准按顺序排列，从最重要的到最不重要的。'
- en: Maybe the Monoid
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的元音
- en: Let’s take a look at the various ways that `Maybe a` can be made an instance
    of `Monoid` and how those instances are useful.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Maybe a`可以以哪些方式成为`Monoid`的实例，以及这些实例如何有用。
- en: 'One way is to treat `Maybe a` as a monoid only if its type parameter `a` is
    a monoid as well and then implement `mappend` in such a way that it uses the `mappend`
    operation of the values that are wrapped with `Just`. We use `Nothing` as the
    identity, and so if one of the two values that we’re `mappend`ing is `Nothing`,
    we keep the other value. Here’s the instance declaration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将`Maybe a`视为单例，前提是其类型参数`a`也是单例，然后以这种方式实现`mappend`，使其使用被`Just`包裹的值的`mappend`操作。我们使用`Nothing`作为单位元，因此如果我们正在`mappend`的两个值中有一个是`Nothing`，我们保留另一个值。以下是实例声明：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice the class constraint. It says that `Maybe a` is an instance of `Monoid`
    only if `a` is an instance of `Monoid`. If we `mappend` something with a `Nothing`,
    the result is that something. If we `mappend` two `Just` values, the contents
    of the `Just`s are `mappend`ed and then wrapped back in a `Just`. We can do this
    because the class constraint ensures that the type of what’s inside the `Just`
    is an instance of `Monoid`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类约束。它表示只有当`a`是`Monoid`的实例时，`Maybe a`才是`Monoid`的实例。如果我们用`mappend`与`Nothing`结合，结果就是那个值。如果我们`mappend`两个`Just`值，`Just`的内容会被`mappend`然后再次包裹在一个`Just`中。我们可以这样做，因为类约束确保了`Just`内部类型的实例是`Monoid`。
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is useful when we’re dealing with monoids as results of computations that
    may have failed. Because of this instance, we don’t need to check if the computations
    have failed by seeing if they’re a `Nothing` or `Just` value; we can just continue
    to treat them as normal monoids.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理可能失败的计算结果的单例时，这很有用。因为这个实例，我们不需要通过查看它们是`Nothing`还是`Just`值来检查计算是否失败；我们只需继续将它们视为正常的单例。
- en: 'But what if the type of the contents of the `Maybe` is not an instance of `Monoid`?
    Notice that in the previous instance declaration, the only case where we must
    rely on the contents being monoids is when both parameters of `mappend` are `Just`
    values. When we don’t know if the contents are monoids, we can’t use `mappend`
    between them, so what are we to do? Well, one thing we can do is discard the second
    value and keep the first one. For this purpose, the `First a` type exists. Here’s
    its definition:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果`Maybe`内容的类型不是`Monoid`的实例呢？注意，在上一个实例声明中，我们必须依赖内容是单例的唯一情况是当`mappend`的两个参数都是`Just`值。当我们不知道内容是否是单例时，我们无法在它们之间使用`mappend`，那么我们该怎么办？好吧，我们可以做的一件事是丢弃第二个值，保留第一个值。为此，存在`First
    a`类型。这是它的定义：
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We take a `Maybe a` and wrap it with a `newtype`. The `Monoid` instance is
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`Maybe a`用`newtype`包装起来。`Monoid`实例如下：
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`mempty` is just a `Nothing` wrapped with the `First newtype` constructor.
    If `mappend`’s first parameter is a `Just` value, we ignore the second one. If
    the first one is a `Nothing`, then we present the second parameter as a result,
    regardless of whether it’s a `Just` or a `Nothing`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`mempty`只是一个用`First newtype`构造函数包装的`Nothing`。如果`mappend`的第一个参数是一个`Just`值，我们忽略第二个参数。如果第一个参数是`Nothing`，那么无论第二个参数是`Just`还是`Nothing`，我们都将其作为结果呈现：'
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`First` is useful when we have a bunch of `Maybe` values and we just want to
    know if any of them is a `Just`. The `mconcat` function comes in handy:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一堆`Maybe`值，只想知道其中是否有任何一个值是`Just`时，`First`很有用。`mconcat`函数派上了用场：
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If we want a monoid on `Maybe a` such that the second parameter is kept if
    both parameters of `mappend` are `Just` values, `Data.Monoid` provides the `Last
    a` type, which works like `First a`, but the last non-`Nothing` value is kept
    when `mappend`ing and using `mconcat`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`Maybe a`上定义一个monoid，使得当`mappend`的两个参数都是`Just`值时，保留第二个参数，`Data.Monoid`提供了`Last
    a`类型，它就像`First a`，但在`mappend`和`mconcat`时保留最后一个非`Nothing`值：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Folding with Monoids
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monoids进行折叠
- en: One of the more interesting ways to put monoids to work is to have them help
    us define folds over various data structures. So far, we’ve done folds over lists,
    but lists aren’t the only data structure that can be folded over. We can define
    folds over almost any data structure. Trees especially lend themselves well to
    folding.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将monoids用于工作的更有趣的方法之一是让它们帮助我们定义各种数据结构的折叠。到目前为止，我们已经对列表进行了折叠，但列表并不是唯一可以折叠的数据结构。我们可以定义几乎任何数据结构的折叠。特别是树非常适合折叠。
- en: 'Because there are so many data structures that work nicely with folds, the
    `Foldable` type class was introduced. Much like `Functor` is for things that can
    be mapped over, `Foldable` is for things that can be folded up! It can be found
    in `Data.Foldable`, and because it exports functions whose names clash with the
    ones from the `Prelude`, it’s best imported qualified (and served with basil):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有这么多与折叠配合得很好的数据结构，所以引入了`Foldable`类型类。就像`Functor`是用于可以映射的事物一样，`Foldable`是用于可以折叠的事物！它可以在`Data.Foldable`中找到，因为它导出了一些与`Prelude`中的函数名称冲突的函数，所以最好导入时使用限定名（并且配上罗勒）：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: To save ourselves precious keystrokes, we’ve imported it qualified as `F`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省我们宝贵的按键，我们已将其导入为`F`。
- en: 'So what are some of the functions that this type class defines? Well, among
    them are `foldr`, `foldl`, `foldr1`, and `foldl1`. Huh? We already know these
    functions. What’s so new about this? Let’s compare the types of `Foldable`’s `foldr`
    and `foldr` from `Prelude` to see how they differ:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个类型类定义了哪些功能？嗯，其中就包括`foldr`、`foldl`、`foldr1`和`foldl1`。咦？我们已经知道这些函数了。这有什么新意呢？让我们比较一下`Foldable`的`foldr`和`Prelude`中的`foldr`的类型，看看它们有什么不同：
- en: '[PRE61]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Ah! So whereas `foldr` takes a list and folds it up, the `foldr` from `Data.Foldable`
    accepts any type that can be folded up, not just lists! As expected, both `foldr`
    functions do the same for lists:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！所以，`foldr`接受一个列表并将其折叠起来，而`Data.Foldable`中的`foldr`接受任何可以折叠的类型，而不仅仅是列表！正如预期的那样，两个`foldr`函数对列表都做了相同的事情：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Another data structures that support folds is the `Maybe` we all know and love!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个支持折叠的数据结构是我们都熟悉并喜爱的`Maybe`！
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: But folding over a `Maybe` value isn’t terribly interesting. It just acts like
    a list with one element if it’s a `Just` value and like an empty list if it’s
    `Nothing`. Let’s examine a data structure that’s a little more complex.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对`Maybe`值进行折叠并不那么有趣。如果它是一个`Just`值，它就表现得像一个只有一个元素的列表；如果它是`Nothing`，它就像一个空列表。让我们考察一个稍微复杂一点的数据结构。
- en: 'Remember the tree data structure from [Chapter 7](ch07.html "Chapter 7. Making
    Our Own Types and Type Classes")? We defined it like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记得第7章中提到的树数据结构吗？我们是这样定义它的：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You learned that a tree is either an empty tree that doesn’t hold any values
    or it’s a node that holds one value and also two other trees. After defining it,
    we made it an instance of `Functor`, and with that we gained the ability to `fmap`
    functions over it. Now we’re going to make it an instance of `Foldable` so we
    get the ability to fold it up.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到树要么是一个不包含任何值的空树，要么是一个包含一个值并且还有两个其他树的节点。定义它之后，我们使其成为`Functor`的一个实例，这样我们就可以在它上面`fmap`函数了。现在我们将它变成`Foldable`的一个实例，这样我们就可以折叠它了。
- en: 'One way to make a type constructor an instance of `Foldable` is to just directly
    implement `foldr` for it. But another, often much easier way, is to implement
    the `foldMap` function, which is also a part of the `Foldable` type class. The
    `foldMap` function has the following type:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使类型构造函数成为 `Foldable` 实例的一种方法是为它直接实现 `foldr`。但另一种，通常更容易的方法是实现 `foldMap` 函数，这也是
    `Foldable` 类型类的一部分。`foldMap` 函数具有以下类型：
- en: '[PRE65]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Its first parameter is a function that takes a value of the type that our foldable
    structure contains (denoted here with `a`) and returns a monoid value. Its second
    parameter is a foldable structure that contains values of type `a`. It maps that
    function over the foldable structure, thus producing a foldable structure that
    contains monoid values. Then, by doing `mappend` between those monoid values,
    it joins them all into a single monoid value. This function may sound kind of
    odd at the moment, but you’ll see that it’s very easy to implement. And implementing
    this function is all it takes for our type to be made an instance of `Foldable`!
    So if we just implement `foldMap` for some type, we get `foldr` and `foldl` on
    that type for free.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它的第一个参数是一个函数，该函数接受我们的可折叠结构包含的类型（在此用 `a` 表示）的值，并返回一个单例值。它的第二个参数是一个包含类型 `a` 值的可折叠结构。它将该函数映射到可折叠结构上，从而产生一个包含单例值的可折叠结构。然后，通过在这些单例值之间执行
    `mappend` 操作，将它们全部合并成一个单例值。这个函数在目前可能听起来有些奇怪，但你会看到它非常容易实现。实现这个函数就是使我们的类型成为 `Foldable`
    实例的全部所需！所以如果我们只是为某种类型实现 `foldMap`，我们就可以免费获得该类型的 `foldr` 和 `foldl`。
- en: 'This is how we make `Tree` an instance of `Foldable`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将 `Tree` 做为 `Foldable` 实例的方法：
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If we are provided with a function that takes an element of our tree and returns
    a monoid value, how do we reduce our whole tree down to one single monoid value?
    When we were using `fmap` over our tree, we applied the function that we were
    mapping to a node, and then we recursively mapped the function over the left subtree
    as well as the right one. Here, we’re tasked with not only mapping a function,
    but also with joining up the results into a single monoid value by using `mappend`.
    First, we consider the case of the empty tree—a sad, sad, lonely tree that has
    no values or subtrees. It doesn’t hold any value that we can give to our monoid-making
    function, so we just say that if our tree is empty, the monoid value it becomes
    is `mempty`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了一个函数，该函数接受我们树的一个元素并返回一个单例值，我们如何将整个树缩减成一个单例值？当我们使用 `fmap` 在我们的树上进行操作时，我们将映射到的函数应用到节点上，然后递归地将函数映射到左子树和右子树。在这里，我们不仅要映射一个函数，还要使用
    `mappend` 将结果连接成一个单例值。首先，我们考虑空树的情况——一个悲伤的、孤独的树，没有任何值或子树。它不包含任何我们可以提供给我们的单例制作函数的值，所以我们只是说，如果我们的树是空的，它变成的单例值是
    `mempty`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802672.png.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802672.png.jpg)'
- en: The case of a nonempty node is a bit more interesting. It contains two subtrees
    as well as a value. In this case, we recursively `foldMap` the same function `f`
    over the left and right subtrees. Remember that our `foldMap` results in a single
    monoid value. We also apply our function `f` to the value in the node. Now we
    have three monoid values (two from our subtrees and one from applying `f` to the
    value in the node), and we just need to bang them together into a single value.
    For this purpose, we use `mappend`, and naturally the left subtree comes first,
    then the node value, followed by the right subtree.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 非空节点的案例要有趣一些。它包含两个子树以及一个值。在这种情况下，我们递归地对左子树和右子树应用相同的函数 `f`。记住，我们的 `foldMap` 结果是一个单例值。我们还对节点中的值应用了我们的函数
    `f`。现在我们有三个单例值（来自我们的子树以及将 `f` 应用到节点值的结果），我们只需要将它们组合成一个单一的值。为此，我们使用 `mappend`，并且自然地，左子树先来，然后是节点值，最后是右子树。
- en: Notice that we didn’t need to provide the function that takes a value and returns
    a monoid value. We receive that function as a parameter to `foldMap`, and all
    we need to decide is where to apply that function and how to join the resulting
    monoids from it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要提供接受一个值并返回单例值的函数。我们通过 `foldMap` 参数接收该函数，我们只需要决定在哪里应用该函数以及如何连接从它生成的结果单例。
- en: 'Now that we have a `Foldable` instance for our tree type, we get `foldr` and
    `foldl` for free! Consider this tree:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的树类型有了 `Foldable` 实例，我们就可以免费获得 `foldr` 和 `foldl`！考虑这个树：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It has `5` at its root, and then its left node has `3` with `1` on the left
    and `6` on the right. The root’s right node has a `9` and then `8` to its left
    and `10` on the far right side. With a `Foldable` instance, we can do all of the
    folds that we can do on lists:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 它的根节点是 `5`，然后它的左节点有 `3`，左边是 `1`，右边是 `6`。根的右节点有一个 `9`，然后左边是 `8`，最右边是 `10`。有了
    `Foldable` 实例，我们可以执行所有在列表上可以执行的折叠操作：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`foldMap` isn’t useful only for making new instances of `Foldable`. It also
    comes in handy for reducing our structure to a single monoid value. For instance,
    if we want to know if any number in our tree is equal to `3`, we can do this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`foldMap` 不仅对创建新的 `Foldable` 实例有用。它还可以帮助我们简化结构到一个单一的 monoid 值。例如，如果我们想知道我们的树中是否有任何数字等于
    `3`，我们可以这样做：'
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, `\x -> Any $ x == 3` is a function that takes a number and returns a
    monoid value: a `Bool` wrapped in `Any`. `foldMap` applies this function to every
    element in our tree and then reduces the resulting monoids into a single monoid
    with `mappend`. Suppose we do this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`\x -> Any $ x == 3` 是一个函数，它接受一个数字并返回一个 monoid 值：一个被 `Any` 包裹的 `Bool`。`foldMap`
    将此函数应用于我们树中的每个元素，然后使用 `mappend` 将结果 monoids 简化成一个单一的 monoid。假设我们这样做：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: All of the nodes in our tree will hold the value `Any False` after having the
    function in the lambda applied to them. But to end up `True`, `mappend` for `Any`
    must have at least one `True` value as a parameter. That’s why the final result
    is `False`, which makes sense because no value in our tree is greater than `15`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 lambda 函数应用于它们之后，我们树中的所有节点都将持有值 `Any False`。但为了最终得到 `True`，`mappend` 对于 `Any`
    必须至少有一个 `True` 值作为参数。这就是为什么最终结果是 `False`，这在逻辑上是合理的，因为我们的树中没有任何值大于 `15`。
- en: 'We can also easily turn our tree into a list by doing a `foldMap` with the
    `\x -> [x]` function. By first projecting that function onto our tree, each element
    becomes a singleton list. The `mappend` action that takes place between all those
    singleton lists results in a single list that holds all of the elements that are
    in our tree:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 `\x -> [x]` 函数进行 `foldMap` 操作，轻松地将我们的树转换为列表。通过首先将此函数投影到我们的树上，每个元素都变成了单元素列表。所有这些单元素列表之间的
    `mappend` 操作将产生一个包含我们树中所有元素的单一列表：
- en: '[PRE71]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: What’s cool is that all of these tricks aren’t limited to trees. They work on
    any instance of `Foldable`!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷的是，这些技巧不仅限于树。它们适用于任何 `Foldable` 实例！
