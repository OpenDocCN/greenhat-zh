- en: Chapter 8. HTML and XML Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 HTML和XML工具
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: Text runs the Web. This is especially true of text that is encoded within some
    sort of markup, such as HyperText Markup Language (HTML) or eXtensible Markup
    Language (XML).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是网络的运行者。这对于编码在某种标记中的文本尤其如此，例如超文本标记语言（HTML）或可扩展标记语言（XML）。
- en: Even non-programmers know that HTML is the markup generally used by websites,
    even if they’ve never heard the term markup before. XML is becoming increasingly
    important for both data transfer and data storage. As I work on the chapters of
    this book, I save them as a filetype that consists of a compressed collection
    of XML files. I also used a type of XML called DocBook ([http://docbook.org](http://docbook.org))
    for my Doctoral dissertation. The bottom line is, XML-based markup is everywhere.
    Luckily, Ruby can understand, output, and manipulate XML (and HTML).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从未听说过“标记”这个术语，非程序员也知道HTML是网站通常使用的标记语言。XML在数据传输和数据存储方面变得越来越重要。在我编写这本书的章节时，我将它们保存为包含压缩XML文件的文件类型。我还使用了一种名为DocBook的XML类型（[http://docbook.org](http://docbook.org)）来撰写我的博士论文。总之，基于XML的标记无处不在。幸运的是，Ruby可以理解、输出和操作XML（以及HTML）。
- en: '#30 Cleaning Up HTML (html_tidy.rb)'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#30 清理HTML（html_tidy.rb）'
- en: Let’s start with HTML. This markup language has had several numbered releases,
    similar to different versions of software, and it’s come a long way since Tim
    Berners-Lee made the first web page at CERN in the mid ’90s. Recent versions of
    HTML are subsets of XML and are called XHTML as a result. However, the earlier
    versions of HTML were not as disciplined; they allowed very liberal interpretations
    of HTML. Especially when people were first learning how to use HTML, they would
    often throw together pages that were not very well designed, either aesthetically
    or technically. But browser manufacturers didn’t want to take the blame for rendering
    content badly, so they made their browsers very forgiving.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从HTML开始。这种标记语言已经发布了几个编号版本，类似于不同版本的软件，自从蒂姆·伯纳斯-李在20世纪90年代中期在CERN制作了第一个网页以来，它已经走了很长的路。HTML的最近版本是XML的子集，因此被称为XHTML。然而，HTML的早期版本并不那么有纪律性；它们允许对HTML进行非常自由的解释。特别是当人们刚开始学习如何使用HTML时，他们经常会拼凑出既不美观也不技术良好的页面。但是浏览器制造商不想为渲染内容不佳承担责任，因此他们使他们的浏览器非常宽容。
- en: In the short term, the practice of allowing non-compliant HTML was great, because
    it meant that more people could view more content. In the long term, however,
    that liberality had some negative consequences because it allowed web designers
    to continue using some uncorrected bad techniques. There’s a lot of sloppy HTML
    out there, and there’s little reason to add to the mess. We want a tool that helps
    us make sure that our own HTML is up to spec.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在短期内，允许非符合标准的HTML的做法非常好，因为它意味着更多的人可以查看更多内容。但从长远来看，这种自由性带来了一些负面影响，因为它允许网页设计师继续使用一些未经纠正的糟糕技术。现在有很多杂乱的HTML，而且几乎没有理由增加混乱。我们想要一个工具，以确保我们的HTML符合规范。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*I’m assuming that you have a basic familiarity with HTML. If not, there’s
    a good guide at* [http://w3schools.com/html/default.asp](http://w3schools.com/html/default.asp).
    *If you’re curious about the various versions of HTML and its relationship to
    XML, browse to the World Wide Web Consortium (W3C) MarkUp page at* [http://www.w3.org/MarkUp](http://www.w3.org/MarkUp).
    *This page also has a link to the HTML Tidy program that the* *`html_tidy.rb`*
    *script depends on*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*我假设你对HTML有基本的了解。如果没有，可以在[http://w3schools.com/html/default.asp](http://w3schools.com/html/default.asp)找到一份很好的指南。*
    *如果你对HTML的各种版本及其与XML的关系感兴趣，请浏览万维网联盟（W3C）的MarkUp页面[http://www.w3.org/MarkUp](http://www.w3.org/MarkUp)。*
    *该页面还有一个链接到* *`html_tidy.rb`* *脚本所依赖的HTML Tidy程序*。'
- en: There’s an excellent program that does most of this clean-up work already. It’s
    called HTML Tidy, and it was written by Dave Raggett. It’s available at [http://tidy.sourceforge.net](http://tidy.sourceforge.net),
    but it also comes prepackaged within many GNU/Linux distributions. Seeing no need
    to reinvent the wheel, I wrote `html_tidy.rb` to use Raggett’s program and add
    some specific features that I wanted. Let’s take a look at the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有一个非常出色的程序可以完成大部分清理工作。它被称为HTML Tidy，由Dave Raggett编写。它可在[http://tidy.sourceforge.net](http://tidy.sourceforge.net)找到，但它也预包装在许多GNU/Linux发行版中。鉴于没有必要重新发明轮子，我编写了`html_tidy.rb`来使用Raggett的程序并添加一些我想要的功能。让我们看看代码。
- en: The Code
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We start by defining some constants at ❶. `EMPTY_STRING` should be obvious,
    and `SIMPLE_TAG_REPLACEMENTS` is a Hash whose keys are regular expressions and
    whose values are whatever the corresponding key should be replaced with. You’ll
    notice that you need to mark certain characters within a regular expression with
    a backslash (`\`)—that’s because some characters have special meanings within
    regular expressions. You’ve already seen examples of that, where `?` means *Zero
    or one of whatever preceded me* and `*` means *Zero or more of whatever preceded
    me*. Similarly, `\` means *Treat whatever follows me as a literal character, not
    a special regex character*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在❶处定义了一些常量。`EMPTY_STRING`应该是显而易见的，而`SIMPLE_TAG_REPLACEMENTS`是一个哈希表，其键是正则表达式，其值是对应键应该替换成的值。你会注意到，你需要在正则表达式中的某些字符前加上反斜杠（`\`）——这是因为一些字符在正则表达式中具有特殊含义。你已经看到了一些例子，其中`?`表示“零个或一个我之前提到的任何东西”和`*`表示“零个或多个我之前提到的任何东西”。同样，`\`表示“将我之后跟随的任何东西视为一个字面字符，而不是一个特殊的正则表达式字符”。
- en: Why do I make these particular replacements? The `<b>` and `<i>` tags are still
    commonly used, but they are not compliant with the Web Accessibility Initiative
    (WAI). I’ve set up this script to replace them with appropriate tags that accomplish
    the same goal but don’t discriminate against the visually impaired. I also replace
    `/\<td\>\<\strong\>/` with `<th>` because I find that people often make “almost”
    table headers by putting formatting within a table cell, rather than making the
    cell a real header. Finally, I’ve taken out the `<u>` tag because it doesn’t mean
    anything, even if it creates an underline. It’s just a visual formatting tag with
    no semantic meaning, which is a no-no. Formatting is what stylesheets are for—the
    markup itself should just have content. Therefore, I replace `<u>` with a `<div>`
    that has an underline style attached to it. I make all these replacements both
    for the opening tags and the closing tags.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我要进行这些特定的替换？`<b>`和`<i>`标签仍然被广泛使用，但它们不符合Web Accessibility Initiative (WAI)的标准。我已经设置了这个脚本，用适当的标签替换它们，以实现相同的目标，但不会歧视视觉障碍人士。我还将`/<td><\strong>/`替换为`<th>`，因为我发现人们经常通过在表格单元格中添加格式而不是将单元格作为真正的标题来创建“几乎”的表头。最后，我移除了`<u>`标签，因为它没有任何意义，即使它创建了一个下划线。它只是一个没有语义意义的视觉格式化标签，这是不允许的。格式化是样式表的作用——标记本身应该只包含内容。因此，我用带有下划线样式的`<div>`替换了`<u>`。我既对开标签也对应闭标签进行了所有这些替换。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Web accessibility is important: These fixes help people who are visually impaired
    surf the Web. The* *`html_tidy.rb`* *script fixes my mistakes, at least for these
    particular cases. If you’re curious, read more about accessibility and its importance
    at the W3C’s Web Accessibility Commission page (*[http://www.w3c.org/WAI](http://www.w3c.org/WAI)*)*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络可访问性很重要：这些修复帮助视觉障碍人士浏览网络。* *`html_tidy.rb`* *脚本修复了我的错误，至少在这些特定情况下。如果你好奇，可以在W3C的网络可访问性委员会页面上了解更多关于可访问性和其重要性的信息（[http://www.w3c.org/WAI](http://www.w3c.org/WAI)*)*。'
- en: We continue with more constants, including some `TIDY_OPTIONS`. Execute `man
    tidy` at the command line to see what these do. These options reflect my preferences,
    but you can certainly make some changes to the constant once you’re comfortable
    with operating the script. At ❷, we have an Array constant called `UNWANTED_REGEXES`.
    It sounds harsh, but there are some things I just don’t want in my HTML. One of
    these is a `<meta>` tag, which Microsoft’s FrontPage sometimes adds to files.
    I also don’t want either lines with only whitespace (which `/^ *$/` matches) or
    completely empty lines (which `/^\n$/` matches). As the comment suggests, you
    can add to this Hash.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续添加更多的常量，包括一些`TIDY_OPTIONS`。在命令行中执行`man tidy`以查看这些选项的功能。这些选项反映了我的偏好，但一旦你熟悉了脚本的操作，你当然可以对这些常量进行一些修改。在❷处，我们有一个名为`UNWANTED_REGEXES`的数组常量。这个名字听起来很严厉，但有些东西我就是不想出现在我的HTML中。其中之一是一个`<meta>`标签，微软的FrontPage有时会将其添加到文件中。我也不希望只有空白行的行（由`/^
    *$/`匹配）或完全空白的行（由`/^\n$/`匹配）。正如注释所暗示的，你可以向这个哈希表中添加内容。
- en: The first method, `declare_regexes_and_replacements`, is at ❸. It combines `SIMPLE_TAG_REPLACEMENTS`
    with `UNWANTED_REGEXES` by looping through `UNWANTED_REGEXES` and making a Hash
    called `replacement_of`, whose keys are the elements of `UNWANTED_REGEXES` and
    whose values are all the `EMPTY_STRING`. This makes sense—if a regex is unwanted,
    we want to replace it with the empty string. The `declare_regexes_and_replacements`
    method then returns the merged Hash, which is made up of both `SIMPLE_TAG_REPLACEMENTS`,
    which was already a Hash in the first place, and our new `replacement_of` Hash.^([[25](#ftn.CHP-8-FNOTE-1)])
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法，`declare_regexes_and_replacements`，在❸处。它通过遍历`UNWANTED_REGEXES`并将`SIMPLE_TAG_REPLACEMENTS`与`UNWANTED_REGEXES`结合，创建一个名为`replacement_of`的Hash，其键是`UNWANTED_REGEXES`的元素，其值都是空字符串。这很有意义——如果正则表达式不受欢迎，我们希望将其替换为空字符串。然后`declare_regexes_and_replacements`方法返回合并后的Hash，它由`SIMPLE_TAG_REPLACEMENTS`和我们的新`replacement_of`
    Hash组成.^([[25](#ftn.CHP-8-FNOTE-1)])
- en: On to ❹ and the `perform_replacements_on_contents` method. It takes an argument,
    unsurprisingly called `contents`, immediately duplicates it with the `dup` method,
    and calls the result `output`. It then calls `declare_regexes_and_replacements`
    (defined at ❸), getting the return value which we already know is a Hash that
    is called `replacement_of`. For simplicity, we’ll keep the same name for that
    Hash inside `perform_replacements_on_contents`. At ❺, we sort the keys of `replacement_of`
    with the `sort_by` method, which takes a block. Strings know how to compare themselves
    to other Strings for sorting purposes, whereas regular expressions don’t. Therefore,
    we convert each of our regular expression keys into a String for sorting purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是❹和`perform_replacements_on_contents`方法。它接受一个参数，不出所料，这个参数叫做`contents`，然后立即使用`dup`方法对其进行复制，并将结果命名为`output`。接着，它调用`declare_regexes_and_replacements`方法（定义在❸），获取返回值，我们已知这个返回值是一个名为`replacement_of`的Hash。为了简单起见，我们将在`perform_replacements_on_contents`内部保持这个Hash的名称不变。在❺处，我们使用`sort_by`方法对`replacement_of`的键进行排序，该方法接受一个块。字符串知道如何比较自身以进行排序，而正则表达式则不知道。因此，我们将每个正则表达式键转换为字符串以进行排序。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Strings know how to compare themselves to other Strings because* *`String`*
    *has a* *`<=>`* *method, and one of* *`String`**’s ancestors is the Comparable
    module*.^([[26](#ftn.CHP-8-FNOTE-2)]) *Comparable uses the* *`<=>`* *method to
    implement the other comparison operators, such as* *`==, <=, >=`*, *and so on.
    If you create a new class and want it to be sortable, give it a method called*
    *`<=>`*, *figure out how to implement it in a way that makes sense, and then mix
    in Comparable. You’ll get lots of sorting value for a minimal amount of effort,
    and you’ll make your objects more useful*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串知道如何比较自身与其他字符串，因为* *`String`* *有一个* *`<=>`* *方法，并且* *`String`* *的一个祖先模块是Comparable*。^([[26](#ftn.CHP-8-FNOTE-2)])
    *Comparable使用`<=>`方法来实现其他比较操作符，例如* *`==, <=, >=`*，等等。如果你创建了一个新类并希望它可排序，给它一个名为*
    *`<=>`* *的方法，想出如何以有意义的方式实现它，然后混入Comparable。你将获得大量的排序价值，同时付出最小的努力，并使你的对象更有用*。'
- en: In an earlier version of `html_tidy.rb`, I didn’t include the sorting at ❺,
    and I would occasionally miss replacements described in `SIMPLE_TAG_REPLACEMENTS`.
    The reason was that Hash keys do not have a deterministic order, so sometimes
    my program would replace `<b>` with `<strong>` before getting to replacing `</strong></td>`
    with `</th>`, but sometimes it wouldn’t. To make my program more robust, I’d either
    need to add a Hash pair that replaced `</b></td>` with `</th>` or enforce a specific
    order on how I used `replacement_of` at ❺. I chose to enforce order, not just
    because it makes the program more dependable, and not just because I’m a petty
    tyrant at heart, but also because it makes the program simpler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`html_tidy.rb`的早期版本中，我没有在❺处包含排序，我偶尔会错过`SIMPLE_TAG_REPLACEMENTS`中描述的替换。原因是Hash键没有确定性顺序，所以有时我的程序会在替换`</strong></td>`为`</th>`之前将`<b>`替换为`<strong>`，但有时则不会。为了使我的程序更健壮，我需要添加一个替换`</b></td>`为`</th>`的Hash对，或者在对❺处的`replacement_of`使用时强制执行特定的顺序。我选择强制执行顺序，不仅因为它使程序更可靠，不仅因为我内心是个小霸王，还因为它使程序更简单。
- en: We sort the keys of `replacement_of` and loop through `each` of them at ❺, calling
    them `regex` in turn. We also want the replacement value, so we read that out
    of the Hash as `replace`. Then at ❻, we loop through `each` `line` of the eventual
    `output`, destructively `gsub!`ing `regex` with `replace`. The `output` variable
    is now ready to be `return`ed. That’s how we `perform_replacements_on_contents`.
    Where do we get the `contents`?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `replacement_of` 的键进行排序，并在❺处循环遍历它们，依次将它们称为 `regex`。我们还想获取替换值，所以我们从哈希中读取它作为
    `replace`。然后在 ❻ 处，我们循环遍历最终 `output` 的每一行，破坏性地使用 `gsub!` 将 `regex` 替换为 `replace`。现在
    `output` 变量已经准备好返回。这就是我们 `perform_replacements_on_contents` 的方法。我们从哪里得到 `contents`？
- en: The `perform_replacements_on_filename!` method is at ❼. At ❿, we call it on
    `each` element of the `ARGV` Array, which we call `filename` as we pass it into
    `perform_replacements_on_filename!` as the single argument. We first attempt a
    system call of `‘which tidy > /dev/null’` (❽). Without getting too deep into Unix
    black magic, I’ll tell you that when executed, this command determines whether
    there is a version of `tidy` installed on the machine.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`perform_replacements_on_filename!` 方法在 ❽。在 ❿，我们对其 `ARGV` 数组的每个元素调用它，我们将其称为
    `filename`，因为我们将其作为单个参数传递给 `perform_replacements_on_filename!`。我们首先尝试执行 `‘which
    tidy > /dev/null’`（❽）系统调用。不深入探讨 Unix 黑魔法，我会告诉你，当执行时，这个命令确定机器上是否安装了 `tidy` 的版本。'
- en: If the test succeeds, we know we can use `tidy`. First, we define a `new_filename`,
    which is just the old `filename` with the `TIDY_EXTENSION` appended to it. We
    then make a call to `tidy` itself, passing it its own `TIDY_OPTIONS` (as an interpolated
    String) and calling it on `filename`. We pass its output into the `new_filename`,
    discarding any error messages. The `new_filename` file now contains all of the
    tidying done by `tidy` itself but none of our add-on changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试成功，我们知道我们可以使用 `tidy`。首先，我们定义一个 `new_filename`，它只是将 `TIDY_EXTENSION` 追加到旧的
    `filename` 上。然后我们调用 `tidy` 本身，传递给它自己的 `TIDY_OPTIONS`（作为一个插值字符串）并在 `filename` 上调用它。我们将输出传递给
    `new_filename`，并丢弃任何错误消息。现在 `new_filename` 文件包含了 `tidy` 本身所做的所有整理，但没有我们的附加更改。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* *`>`* *character in the Unix shell just means* Send my output into the
    following filename, *so* *`some_command > some_file`* *takes the output of* *`some_command`*
    *and writes it into a file called* *`some_file`*. *Putting a* *`2`* *in front
    of* *`>`* *makes it apply to error messages, instead of regular output. Unix calls
    the output of error messages* Standard Error. *The file called /dev/null just
    means* nowhere, *so* *`some_command > some_file 2> /dev/null`* *means* Send *`some_command`*’s
    output into *`some_file`*, and I don’t care about any error messages.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unix shell 中的 *`>`* *字符仅仅意味着* 将我的输出发送到以下文件名，*所以* *`some_command > some_file`*
    *将 *`some_command`* *的输出写入名为 *`some_file`* 的文件。*在 *`>`* *前面放置一个 *`2`* *使其应用于错误消息，而不是常规输出。Unix
    将错误消息的输出称为* 标准错误。*名为 /dev/null 的文件仅仅意味着* 无处，*所以* *`some_command > some_file 2>
    /dev/null`* *意味着* 将 *`some_command`* 的输出发送到 *`some_file`*，并且我不关心任何错误消息。'
- en: We then read `new_filename`’s `contents` using `File.open` and the `readlines`
    method at ❾. That `contents` variable is ready for `perform_replacements_on_contents`,
    which we call on it, assigning the results into `new_contents`. We then open the
    `new_filename` file again, this time for writing, and replace its contents with
    `new_contents`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 `File.open` 和 `readlines` 方法在❾处读取 `new_filename` 的 `contents`。这个 `contents`
    变量已经准备好用于 `perform_replacements_on_contents`，我们调用它，并将结果赋值给 `new_contents`。然后我们再次打开
    `new_filename` 文件，这次是为了写入，并用 `new_contents` 替换其内容。
- en: If the `which tidy` test fails, we know that our beloved `tidy` is not present,
    so there’s little point in proceeding. We simply ask the user to install `tidy`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `which tidy` 测试失败，我们知道我们心爱的 `tidy` 不存在，所以继续下去没有意义。我们只是要求用户安装 `tidy`。
- en: Running the Script
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'I have a sample file at `extras/eh.html`, so we can call this script with the
    command `ruby -w html_tidy.rb extras/eh.html`. Here’s the original version, `extras/eh.html`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个示例文件在 `extras/eh.html`，所以我们可以使用命令 `ruby -w html_tidy.rb extras/eh.html`
    来调用此脚本。以下是原始版本，`extras/eh.html`：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Results
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'And here’s the new version, `extras/eh.html.tidy`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是新的版本，`extras/eh.html.tidy`：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how `tidy` added a `<meta>` tag for itself and wrapped the style information
    inside `CDATA` markers. It also defined a paragraph class called `c1` for our
    `text-align:center;` style that is attached to the free-floating `<p>` tag. In
    addition to everything that `tidy` does, our script does what I’ve described above.
    It replaced the tags for our “almost” header with a `<th>`, converted the underlining
    from a bad `<u>` tag to a style declaration, and changed the `<i>` tag to an `<em>`
    tag, making this content a little friendlier to an audio browser, such as a blind
    person might use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `tidy` 如何为自己添加了一个 `<meta>` 标签，并将样式信息包裹在 `CDATA` 标记内。它还定义了一个名为 `c1` 的段落类，用于我们的
    `text-align:center;` 样式，该样式附加到自由浮动的 `<p>` 标签上。除了 `tidy` 所做的所有事情外，我们的脚本还做了我上面描述的事情。它将“几乎”标题的标签替换为
    `<th>`，将下划线从不良的 `<u>` 标签转换为样式声明，并将 `<i>` 标签更改为 `<em>` 标签，使内容对音频浏览器（如盲人可能使用的）更友好。
- en: Hacking the Script
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: 'Could we use `inject`, rather than `each`, to modify `declare_regexes_and_replacements`
    at ❸ and make it more functional? Here’s one way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否使用 `inject` 而不是 `each` 来修改 ❸ 中的 `declare_regexes_and_replacements`，使其更具功能性？这里有一个方法：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this variant, `h` takes the place of `replacement_of`, and it is the memoized
    Hash that persists from one iteration of `inject` to the next. Each time, we merge
    it with the new pair (consisting of `discard` as a key pointing to the `EMPTY_STRING`),
    so we end up with a Hash of things to replace, all of whose replacements are the
    `EMPTY_STRING`—just like in the original version. This time, however, our temporary
    variables are confined entirely within the `inject` loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变体中，`h` 替代了 `replacement_of`，它是从一次 `inject` 迭代持续到下一次迭代的缓存哈希。每次迭代时，我们都将其与新的键值对（`discard`
    作为键，指向 `EMPTY_STRING`）合并，因此我们最终得到一个包含要替换内容的哈希，所有替换都是 `EMPTY_STRING`——就像原始版本一样。然而，这次我们的临时变量完全限制在
    `inject` 循环内。
- en: Could we have simply altered `contents` in place with a method called `perform_replacements_on_contents!`?
    Of course. I just wanted to show both a destructive method (`perform_replacements_on_filename!`)
    and a regular method (`perform_replacements_on_contents`) whose output we would
    then use for demonstration purposes. Both could have been either destructive or
    non-destructive. Change the script as you like if you’d prefer these to use the
    same approach.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否简单地通过一个名为 `perform_replacements_on_contents!` 的方法就地修改 `contents`？当然可以。我只是想展示两种方法：一种破坏性方法（`perform_replacements_on_filename!`）和一种常规方法（`perform_replacements_on_contents`），然后我们将使用这些方法的输出进行演示。两者都可以是破坏性的或非破坏性的。如果你希望它们使用相同的方法，请随意修改脚本。
- en: '* * *'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[25](#CHP-8-FNOTE-1)]) I generally find Perl rather sloppy, but one benefit
    of its policy of storing Hashes as even-length Arrays is that you can make Hashes
    out of Arrays very easily. The Perl equivalent of our `UNWANTED_REGEXES.each`
    loop would be something like this: `my %replacement_of = map { $_ => EMPTY_STRING
    } @unwanted_regexes;`. Of course, it’s more trouble to `merge` Hashes in Perl,
    so I still like Ruby better. Don’t worry about any of this if you don’t know Perl.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[25](#CHP-8-FNOTE-1)]) 我通常觉得 Perl 有点马虎，但它的一个好处是存储哈希时使用偶数长度的数组，这使得你可以非常容易地将数组转换为哈希。Perl
    中 `UNWANTED_REGEXES.each` 循环的等价物可能如下所示：`my %replacement_of = map { $_ => EMPTY_STRING
    } @unwanted_regexes;` 当然，在 Perl 中合并哈希会更麻烦，所以我仍然更喜欢 Ruby。如果你不知道 Perl，不必担心这些。
- en: ^([[26](#CHP-8-FNOTE-2)]) Since Comparable is a module, rather than a class,
    it is an ancestor of String via mixing in, rather than straightforward inheritance.
    However, `String.ancestors` includes Comparable, so I’ve referred to it as an
    ancestor here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#CHP-8-FNOTE-2)]) 由于 Comparable 是一个模块，而不是一个类，它是通过混合而不是直接继承成为 String
    的祖先。然而，`String.ancestors` 包含 Comparable，所以我在这里将其称为祖先。
- en: '#31 Counting Tags (xml_tag_counter.rb)'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#31 计数标签 (xml_tag_counter.rb)'
- en: XML is strict about its internal structure. It can only have a single top-level
    element (called the *root element*), but that root element can have any number
    of elements within itself, and each of those elements can have any number of other
    elements within itself, continuing on recursively. We want a script that we can
    run on an XML file that will output how many times each tag (or element) occurs
    within that document, no matter how many layers deep it appears—for example, we
    want to find all `<p>` tags regardless of whether or not those tags are immediately
    within the top-level `<html>` element, or within some other element, such as a
    `<blockquote>` or `<div>`. Let’s take a look.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: XML 对其内部结构非常严格。它只能有一个顶级元素（称为 *根元素*），但这个根元素可以包含任意数量的元素，并且每个元素都可以包含任意数量的其他元素，递归地进行。我们想要一个可以在
    XML 文件上运行的脚本，它会输出每个标签（或元素）在文档中出现的次数，无论它出现在多少层深——例如，我们想要找到所有的 `<p>` 标签，无论这些标签是否直接位于顶级
    `<html>` 元素内，或者位于其他元素内，例如 `<blockquote>` 或 `<div>`。让我们看看。
- en: The Code
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How It Works
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Most of the work in this script comes from adding new methods to the Hash class.
    First, at ❶, we `require` the `rexml/document` library, an XML processing library.
    Then at ❷, we start the RDoc explaining the `sort_by_tag_count` method. The RDoc
    explains the method’s goals, but let’s look at each step. First, `self.sort` converts
    a Hash into an Array of Arrays. Each element of the main Array is another Array
    with the structure *[key, value]*. Let’s show this in irb:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段脚本中的大部分工作来自于向 Hash 类添加新的方法。首先，在❶处，我们 `require` 了 `rexml/document` 库，这是一个 XML
    处理库。然后，在❷处，我们开始使用 RDoc 解释 `sort_by_tag_count` 方法。RDoc 解释了该方法的目标，但让我们看看每个步骤。首先，`self.sort`
    将一个 Hash 转换为一个 Array 的 Array。主 Array 的每个元素都是一个具有结构 *[key, value]* 的 Array。让我们在
    irb 中展示这一点：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since this in the context of a method called `sort`, the Array of Arrays is
    sorted. The `sort` method takes a block, which allows us to specify how we’d like
    it to be sorted. We do this at ❸ with the expression `( (b[1] <=> a[1]) * 2 )
    + (a[0] <=> b[0])`. What does this expression mean?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是在名为 `sort` 的方法上下文中，所以 Array 的 Array 被排序。`sort` 方法接受一个块，这允许我们指定我们希望如何排序。我们在❸处通过表达式
    `( (b[1] <=> a[1]) * 2 ) + (a[0] <=> b[0])` 来做这件事。这个表达式是什么意思？
- en: First, we need to talk a bit about `sort`ing. You see in the line before ❸ that
    we identify the variables within the `sort` loop as `a` and `b`. Those names are
    traditional for `sort`s, although Ruby allows you to pick other names if you like.
    Our expression calls the `<=>` method on whatever `b[1]` is, with `a[1]` as the
    argument. It then multiplies this by two and adds the result of calling `<=>`
    on `a[0]`, with `b[0]` as an argument. That should clear everything up, right?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要谈谈 `sort`。你会在❸之前的行中看到，我们在 `sort` 循环中识别变量为 `a` 和 `b`。这些名称是 `sort` 的传统名称，尽管
    Ruby 允许你选择其他名称。我们的表达式在 `b[1]` 上调用 `<=>` 方法，以 `a[1]` 作为参数。然后它将这个结果乘以二，并加上调用 `<=>`
    在 `a[0]` 上，以 `b[0]` 作为参数的结果。这应该澄清一切，对吧？
- en: The `<=>` method returns `1` when `self` is greater then the argument, however
    it is defined; `-1` when `self` is less than the argument, hopefully according
    to the same criteria; and `0` when they are equal. Keep this in mind when you
    create your own classes that implement the `<=>` method. Our project specifications
    from [#31 Counting Tags (xml_tag_counter.rb)](ch08s02.html "#31 Counting Tags
    (xml_tag_counter.rb)") on page 148 says that the pairs of our Array of Arrays
    from `sort_by_tag_count` will have keys that are the names of XML tags and values
    that are the number of times that the tag appears in the document being analyzed.
    The first part of our expression (the part that is doubled) is just a `sort` on
    the tag count, as the name suggests. We put `b[1]` before `a[1]` because we want
    to `sort` in descending order, so the most common tags come first.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`<=>` 方法在 `self` 大于参数时返回 `1`，无论参数如何定义；在 `self` 小于参数时返回 `-1`，希望根据相同的标准；当它们相等时返回
    `0`。当你创建自己的类并实现 `<=>` 方法时，请记住这一点。我们的项目规范从第 148 页的 [#31 计数标签 (xml_tag_counter.rb)](ch08s02.html
    "#31 Counting Tags (xml_tag_counter.rb)") 中说，我们的 `sort_by_tag_count` 的 Array 的
    Array 的键是 XML 标签的名称，值是该标签在正在分析的文档中出现的次数。我们表达式的第一部分（被加倍的部分）只是一个基于标签计数的 `sort`，正如其名称所暗示的。我们之所以将
    `b[1]` 放在 `a[1]` 之前，是因为我们希望按降序排序，所以最常见的标签排在前面。'
- en: What happens when two different tags occur the same number of times in the document?
    That’s what the second part of the expression is for. When the tag count is tied,
    we want to then `sort` on the name of the tag, which is either `a[0]` or `b[0]`.
    We put these in regular order, where `a` comes before `b`, because we want to
    `sort` in ascending order. Our output is sorted by descending tag count first,
    and ascending tag name within a given tag count. Why do we double the value of
    `<=>` for the tag counts?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档中出现两个不同的标签出现相同次数时会发生什么？这是表达式的第二部分。当标签计数相等时，我们希望然后按标签名称排序，这可能是 `a[0]` 或 `b[0]`。我们将这些放入常规顺序，其中
    `a` 在 `b` 之前，因为我们希望按升序排序。我们的输出首先按降序标签计数排序，然后在给定的标签计数内按升序标签名称排序。为什么我们要对 `<=>` 的值加倍？
- en: Since `<=>` always returns `-1, 0`, or `1`, and this is true for either sorting
    by tag count or tag name, we need to give tag count sorting greater weight somehow.
    Doubling does this very well, because it increases the magnitude of either `1`
    or `-1` for the tag count `sort` relative to the tag name `sort`, but does nothing
    for tag count ties, because zero doubled is still zero. Our tag name `sort` still
    counts for something, just less than the `sort_by_tag_count`.^([[27](#ftn.CHP-8-FNOTE-3)])
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `<=>` 总是返回 `-1, 0` 或 `1`，这对于按标签计数或标签名称排序都是正确的，因此我们需要以某种方式给标签计数排序更大的权重。加倍做得非常好，因为它增加了标签计数
    `sort` 相对于标签名称 `sort` 的幅度，但对于标签计数的平局没有影响，因为零加倍仍然是零。我们的标签名称 `sort` 仍然有作用，只是比 `sort_by_tag_count`
    的作用小。^([[27](#ftn.CHP-8-FNOTE-3)])
- en: We now know how to `sort_by_tag_count`, but we also want to be able to `merge`
    Hashes together, take another Hash as an argument, add their tag counts together,
    and have that new pair be the pair in the result. Hashes already have a method
    called `merge`, which takes a Hash argument. That should take care of everything,
    right? Sadly, no. The preexisting `merge` method *replaces* any existing `key
    => value` pair with whatever is in the hash taken as an argument. We don’t want
    that—we want to keep the key that they share, but add the values together. How
    do we do that?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何 `sort_by_tag_count`，但我们还希望能够 `merge` 哈希，将另一个哈希作为参数，将它们的标签计数相加，并使新的配对成为结果中的配对。哈希已经有一个名为
    `merge` 的方法，它接受一个哈希参数。这应该可以解决一切问题，对吧？遗憾的是，没有。现有的 `merge` 方法会 *替换* 任何现有的 `key =>
    value` 对，以参数哈希中的内容。我们不想这样做——我们想保留它们共有的键，但将值相加。我们如何做到这一点？
- en: 'As is often true in Ruby, the answer is, *Write your own method and add it
    to an existing class*. The RDoc for `merge_totals` starts at ❹ and explains what
    we want to happen. All we do is loop through `each` `key` of the `other_hash`
    (the one taken as an argument) and add its value for that `key` to `self[key]`.
    Simple. There’s a problem, though. What’s the value of `some_hash[some_key]` when
    `some_key` isn’t one of `some_hash`’s keys? The value is `nil`, and `nil` doesn’t
    like to be added. Let’s see what happens in irb:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，答案通常是，*编写自己的方法并将其添加到现有类中*。`merge_totals` 的 RDoc 从 ❹ 开始，解释了我们想要发生的事情。我们只是遍历
    `other_hash`（作为参数传入的哈希）中的每个 `key`，并将该 `key` 的值添加到 `self[key]` 中。很简单。但是有一个问题。当
    `some_key` 不是 `some_hash` 的键之一时，`some_hash[some_key]` 的值是什么？值是 `nil`，而 `nil` 不喜欢被添加。让我们看看在
    irb 中会发生什么：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s not good. We’ll need to find a way around that problem—but we’ll do that
    later in the script. For now, know that `merge_totals` will properly add the counts
    for tags in Hashes that follow the format `{ tag => tag_count }` when that tag
    is present.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很好。我们需要找到一种绕过这个问题的方法——但我们将在脚本中稍后处理。现在，要知道 `merge_totals` 将正确地添加符合 `{ tag
    => tag_count }` 格式的 Hash 对象中标签的计数，当该标签存在时。
- en: We have one more method called `pretty_report` to add to all Hashes (❺). This
    method outputs a String showing each tag and its count within the document. It
    accomplishes that by sorting through `each` `pair` in the Array of Arrays returned
    by `sort_by_tag_count` from ❷, and creating an `output` String to which it adds
    a line with the `tag`, a colon, a space, the tag `count`, and a newline character.
    Then it `return`s that String. That’s it for the new methods in Hash.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `pretty_report` 的方法，可以添加到所有的 Hash 对象中（❺）。这个方法输出一个字符串，显示文档中每个标签及其计数。它是通过遍历由
    `sort_by_tag_count` 从 ❷ 返回的数组数组中的每个 `pair` 来实现的，并创建一个 `output` 字符串，向其中添加一行，包含
    `tag`，一个冒号，一个空格，`tag` 的 `count`，以及一个换行符。然后它 `return`s 这个字符串。这就是 Hash 中新方法的全部内容。
- en: 'This script also has two functions not attached as methods to the Hash: `get_elements_from_filename`
    (❻) and `tag_count` (❼). The `get_elements_from_filename` method takes one argument
    called `filename` and instantiates a new `REXML:: Document`, which takes an instance
    of File as its argument. We provide that File via `File.open(filename)`. Instances
    of `REXML::Document` have a method called `elements`, which does much of our script’s
    work for us, returning all the XML elements from the File.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还有两个没有作为方法附加到 Hash 上的函数：`get_elements_from_filename`（❻）和 `tag_count`（❼）。`get_elements_from_filename`
    方法接受一个名为 `filename` 的参数，并实例化一个新的 `REXML::Document`，它接受一个文件实例作为参数。我们通过 `File.open(filename)`
    提供那个文件实例。`REXML::Document` 实例有一个名为 `elements` 的方法，它为我们脚本的大部分工作做了，返回文件中的所有 XML
    元素。
- en: The `tag_count` method takes those `elements` as an argument, it instantiates
    a new Hash called `count_of` at (❽), and passes `0` into the `new` method. This
    `0` argument sets the default value for this Hash, which is the value returned
    by `count_of` when it lacks the key it is asked for. This default of `0` is how
    we deal with the problem of adding tag counts that don’t yet exist in the `merge_totals`
    method. The `self` Hash has a default of zero, so when a new tag comes in to `merge_totals`
    (which we call at ❾), it is assumed to have a `count_of` `0` for that tag. Unlike
    `nil`, a `0` is happy to have another Integer added to it, so our addition problem
    is solved. We continue recursively, calling `tag_counts` on the `elements` found
    within each `tag`, which then calls `tag_counts` as needed on its own `elements`,
    if there are any. It all continues, aggregating tag counts with `merge_totals`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag_count` 方法接受那些 `elements` 作为参数，它在（❽）处实例化一个新的名为 `count_of` 的哈希，并将 `0` 传递给
    `new` 方法。这个 `0` 参数设置了该哈希的默认值，这是当 `count_of` 缺少请求的键时返回的值。这个 `0` 的默认值是我们处理在 `merge_totals`
    方法中尚未存在的标签计数问题的方法。`self` 哈希的默认值为零，所以当一个新标签进入 `merge_totals`（我们在 ❾ 处调用它）时，它假定该标签的
    `count_of` 为 `0`。与 `nil` 不同，`0` 很高兴有另一个整数添加到它，所以我们的加法问题得到了解决。我们继续递归地调用 `tag_counts`
    在每个 `tag` 内找到的 `elements`，然后它根据需要在自己的 `elements` 上调用 `tag_counts`（如果有的话）。这一切都在继续，使用
    `merge_totals` 聚合标签计数。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Hashes similar to* *`count_of`* *often benefit from having default values
    of either* *`0`* *or the empty string. Hashes serving as* *`histograms`*, *like*
    *`count_of`*, *count occurrences of something, and should have a default of* *`0`*.
    *Other hashes, which accumulate Strings for whatever reason, could have a default
    of the empty string. Since Strings know to concatenate with other objects, the
    script could accumulate Strings with* *`+=`*, *just as in our example, which uses
    Integers as Hash values*.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *`count_of`* 相似的 *`Hashes`* 通常会从具有默认值 `0` 或空字符串中受益。作为 *`histograms`* 的 *`count_of`*，像
    *`count_of`* 一样，计算某物的出现次数，应该有默认值 `0`。其他一些哈希，由于某种原因累积字符串，可以有默认值空字符串。由于字符串知道与其他对象连接，脚本可以用
    `+=` 来累积字符串，就像我们的例子中使用整数作为哈希值一样。
- en: At ❿, we get the output of `tag_count`, which expects `elements`. We get those
    `elements` by calling `get_elements_from_filename` on the first command-line argument.
    Since `tag_count` returns a Hash, that return value has the method `pretty_report`,
    which provides the argument to the `puts` method and provides information to the
    user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ❿ 处，我们得到 `tag_count` 的输出，它期望 `elements`。我们通过在第一个命令行参数上调用 `get_elements_from_filename`
    来获取这些 `elements`。由于 `tag_count` 返回一个哈希，那个返回值有 `pretty_report` 方法，它为 `puts` 方法提供参数，并为用户提供信息。
- en: Running the Script
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'Let’s use the file `extras/eh.html.tidy`, the corrected output provided by
    the `html_tidy.rb` script. Let’s try `ruby -w xml_tag_counter.rb extras/eh.html.tidy`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用文件 `extras/eh.html.tidy`，由 `html_tidy.rb` 脚本提供的修正后的输出。让我们尝试 `ruby -w xml_tag_counter.rb
    extras/eh.html.tidy`：
- en: The Results
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here’s the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Hacking the Script
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: 'What if we wanted `sort_by_tag_count` to return a Hash, rather than an Array?
    We could theoretically make a method like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 `sort_by_tag_count` 返回一个哈希，而不是一个数组，我们可以从理论上创建一个类似的方法：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The problem is all Hash pairs are unordered. Our new `sorted_by_tag_count` goes
    to all the trouble of calling `sort_by_tag_count` but then rehashes it, losing
    the ordering.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于所有的哈希对都是无序的。我们的新 `sorted_by_tag_count` 费尽心机调用 `sort_by_tag_count`，但随后重新哈希它，丢失了顺序。
- en: What if we wanted to implement `pretty_report` with `inject`? Here’s one way
    to do it. Notice how the method becomes a bit shorter, and the `output` variable
    becomes internal to `inject`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想用 `inject` 来实现 `pretty_report`，这里有一个方法。注意方法变得稍微短了一些，而 `output` 变量变成了 `inject`
    的内部变量。
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, instead of calling `get_elements_from_filename` only on the first command-line
    argument, we could have used `ARGV.each` to allow the script to analyze multiple
    files in succession.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不仅可以在第一个命令行参数上调用 `get_elements_from_filename`，还可以使用 `ARGV.each` 允许脚本连续分析多个文件。
- en: '* * *'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[27](#CHP-8-FNOTE-3)]) To paraphrase George Orwell’s *Animal Farm*, “All
    `sort`s are equal, but some are more equal than others.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[27](#CHP-8-FNOTE-3)]) 为了转述乔治·奥威尔的《动物农场》，“所有 `sort`s 都是平等的，但有些比其他 `sort`s
    更平等。”
- en: '#32 Extracting Text from XML (xml_text_extractor.rb)'
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#32 从 XML 中提取文本（xml_text_extractor.rb）'
- en: Counting occurrences of tags is fine, but XML is designed to hold text wrapped
    in tags, providing some organization beyond what’s available simply from the content.
    That said, though, sometimes having just the text content is handy. When I was
    preparing a document using DocBook, I found myself wanting to use a spell checker
    on it. There are spell checkers that are XML-aware, but another approach would
    be to run a text extractor on XML and pass that output into a spell checker that
    expects plain text. This `xml_text_extractor.rb` is just such a script.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 计算标签的出现次数是可以的，但 XML 是设计用来包含被标签包裹的文本的，它提供了一些比仅从内容中可用的组织性。然而，尽管如此，有时只获取文本内容也很方便。当我使用
    DocBook 准备文档时，我发现自己在想使用拼写检查器。有一些拼写检查器是 XML 感知的，但另一种方法是在 XML 上运行文本提取器，并将输出传递给期望纯文本的拼写检查器。这个
    `xml_text_extractor.rb` 正是这样的脚本。
- en: The Code
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How It Works
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This `xml_text_extractor.rb` script is similar to `xml_tag_counter.rb`, although
    it is simpler—ironic, since its output is arguably more complex. It starts out
    at ❶ by defining a Proc Constant called `CHOMP_TAG`, which accepts a single argument
    and returns the chomped version of that argument’s rendition as a String. Following
    that, it requires the `REXML` library at ❷, just as in `xml_tag_counter.rb`. At
    ❸, it defines its own version of `get_elements_by_filename`, identical to the
    one in `xml_tag_counter.rb`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `xml_text_extractor.rb` 脚本与 `xml_tag_counter.rb` 类似，尽管它更简单——具有讽刺意味的是，其输出可能更复杂。它从定义一个名为
    `CHOMP_TAG` 的 Proc 常量开始，该常量接受一个参数并返回该参数表示的字符串的修剪版本。随后，它像 `xml_tag_counter.rb`
    一样在 ❷ 处引入了 `REXML` 库。在 ❸ 处，它定义了自己的 `get_elements_by_filename` 版本，与 `xml_tag_counter.rb`
    中的版本相同。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*These scripts are designed to demonstrate techniques, rather than to function
    as production code. For production code, the definition of a method that will
    be used in multiple places should reside in a single library file that is required
    by any other file that needs access to that method. Please forgive the duplication
    in this case for the sake of simplicity*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些脚本旨在展示技术，而不是作为生产代码。对于生产代码，将在多个地方使用的方法的定义应位于一个单独的库文件中，该文件被任何需要访问该方法的文件所引入。请原谅在这个例子中的重复，为了简单起见*。'
- en: Next, we have `strip_tags` at ❹. Contrast the design of this function with `pretty_report`
    in `xml_tag_counter.rb`. Rather than a more iterative approach of (for example)
    defining an output variable looping through an Array with the `each` method and
    appending results onto the output variable), this uses a more functional approach.
    It maps an action onto each member of `elements` (which it calls `tag`) at ❻.
    That action is itself a mapping of the `CHOMP_TAG` Proc onto each member of `tag.texts`
    (❼). Then it `join`s the resulting Array with an empty String separator between
    each element, and appends the results of a recursive call to `strip_tags` onto
    the `elements` of `tag`. The result of a `map` is an Array, so it `join`s the
    elements of that Array with a space character before returning (❽). It also has
    an exit condition, which `return`s the empty String if there are no `elements`
    (❺).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `strip_tags` 在 ❹ 处。与 `xml_tag_counter.rb` 中的 `pretty_report` 函数的设计进行对比。而不是采用更迭式的方法（例如，通过定义一个输出变量，使用
    `each` 方法遍历一个数组，并将结果附加到输出变量上），它采用了一种更函数式的方法。它将一个操作映射到 `elements`（它称之为 `tag`）的每个成员上
    ❻。这个操作本身是将 `CHOMP_TAG` Proc 映射到 `tag.texts` 的每个成员上 ❼。然后它使用空字符串分隔符将结果数组 `join`
    在一起，并将 `strip_tags` 的递归调用结果附加到 `tag` 的 `elements` 上。`map` 的结果是数组，所以它使用空格字符将数组的元素
    `join` 在一起，在返回之前（❽）。它还有一个退出条件，如果没有 `elements`，则 `return` 空字符串（❺）。
- en: Running the Script
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Since `strip_tags` returns either the elements of a `map` joined on a space
    (which is a String) or the empty String, that String can easily be printed with
    `puts` at ❾. Let’s look at the output returned by `ruby -w xml_text_extracter.rb
    extras/eh.html.tidy`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `strip_tags` 返回的是由空格连接的 `map` 元素（这本身是一个字符串）或者空字符串，因此这个字符串可以很容易地在第❾处用 `puts`
    打印。让我们看看 `ruby -w xml_text_extracter.rb extras/eh.html.tidy` 返回的输出。
- en: The Results
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Hacking the Script
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: 'As I mentioned, one change that could be done on both `xml_text_extractor.rb`
    and `xml_tag_counter.rb` would be to take the common `get_elements_by_filename`
    method and place it in a single library file that both `xml_text_extractor.rb`
    and `xml_tag_counter.rb` access via `require`. This operation has a name in the
    refactoring community: *Pull Up Method*. The `xml_text_extractor.rb` script could
    also massage the output of `strip_tags`, stripping out empty lines and/or lines
    consisting entirely of whitespace, as `html_tidy.rb` does with `UNWANTED_REGEXES`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，可以在 `xml_text_extractor.rb` 和 `xml_tag_counter.rb` 中进行的一个更改是将共同的 `get_elements_by_filename`
    方法放在一个单独的库文件中，这样 `xml_text_extractor.rb` 和 `xml_tag_counter.rb` 都可以通过 `require`
    访问它。这个操作在重构社区中有一个名字：*Pull Up Method*。`xml_text_extractor.rb` 脚本还可以对 `strip_tags`
    的输出进行按摩，去除空行和/或完全由空白字符组成的行，就像 `html_tidy.rb` 使用 `UNWANTED_REGEXES` 所做的那样。
- en: '#33 Validating XML (xml_well_formedness_checker.rb)'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#33 验证 XML（xml_well_formedness_checker.rb）'
- en: All the XML processing in the world won’t do any good if your XML file is not
    well-formed. Since an XML document either is or is not well-formed, a well-formedness
    checker that will `return` either `true` or `false` seems like an ideal predicate
    method. Since XML documents are Files with Strings as their contents, we’ll add
    a `well_formed_xml?` method to both the File class and the String class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 XML 文件没有良好格式，那么世界上所有的 XML 处理都不会有任何好处。由于 XML 文档要么是良好格式的，要么不是，一个会 `return`
    `true` 或 `false` 的良好格式检查器似乎是一个理想的谓词方法。由于 XML 文档是内容为字符串的文件，我们将向 File 类和 String
    类添加 `well_formed_xml?` 方法。
- en: The Code
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How It Works
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: At ❶, we require the `XML::DOM::Builder` library file, which is available as
    part of Ruby’s standard library. DOM stands for *Document Object Model*, and it’s
    a way to express an XML document as a object with methods like `elements`, which
    returns the elements found within whatever `self` is at the time—it could be the
    entire document, or it could be a sub-element within the document. We’ve used
    `elements` already in our previous scripts with the `REXML` library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第❶处，我们要求 `XML::DOM::Builder` 库文件，它是 Ruby 标准库的一部分。DOM 代表 *Document Object Model*，它是一种将
    XML 文档表示为具有 `elements` 等方法的对象的方式，该方法返回在 `self` 时刻找到的元素——它可能是整个文档，也可能是文档中的子元素。我们已经在之前的脚本中使用
    `elements` 与 `REXML` 库一起使用过了。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Programmers that do a lot of Ajax or other JavaScript are intimately familiar
    with the DOM. Because JavaScript’s most common use is as a client-side scripting
    language within web browsers, JavaScript programs often find themselves dealing
    with XML (especially XHTML) data. JavaScript is an excellent language with a terribly
    misleading name and some poor implementations. It shares a similar fused OO/functional
    heritage with Ruby*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*程序员在大量使用 Ajax 或其他 JavaScript 时会非常熟悉 DOM。因为 JavaScript 最常见的用途是作为浏览器中的客户端脚本语言，JavaScript
    程序经常发现自己需要处理 XML（尤其是 XHTML）数据。JavaScript 是一种优秀的语言，但名称非常误导，并且有一些糟糕的实现。它与 Ruby 共享类似的融合的面向对象/函数式遗产*。'
- en: We said that we’d be adding a `well_formed_xml?` predicate to File, which is
    what we do at ❷. The `read` method of a File returns the contents of that File
    as a String. We know that we want to add `well_formed_xml?` to all Strings as
    well as all Files, so we just call `read.well_formed_xml?` within File’s `well_formed_xml?`
    method and assume that String will do its job and provide its own version of `well_formed_xml?`
    for us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说我们将在 File 中添加一个 `well_formed_xml?` 断言，这正是我们在第❷处所做的。File 的 `read` 方法返回该文件的文本内容。我们知道我们希望将
    `well_formed_xml?` 添加到所有字符串以及所有文件中，所以我们只需在 File 的 `well_formed_xml?` 方法中调用 `read.well_formed_xml?`
    并假设字符串会完成它的任务，为我们提供它自己的 `well_formed_xml?` 版本。
- en: We don’t want to make Strings out to be liars, so we provide String with its
    own `well_formed_xml?` predicate at ❸. This delegates some of its work to the
    `XML::DOM::Builder` library, instantiating a `Builder` and setting its base to
    `‘./’`, which stands for the root element of an XML document.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想让字符串成为骗子，因此我们在第❸处为字符串提供了它自己的 `well_formed_xml?` 断言。这委托了一些工作给 `XML::DOM::Builder`
    库，实例化一个 `Builder` 并将其基础设置为 `‘./’`，这代表 XML 文档的根元素。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* *`0`* *argument to* *`XML::DOM::Builder.new`* *tells it to ignore default
    events, which has no impact our script. You can read more about* *`XML::DOM::Builder`*
    *at* [http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML](http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*`XML::DOM::Builder.new`* 的 *`0`* 个参数指示它忽略默认事件，这对我们的脚本没有影响。你可以在 [http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML](http://raa.ruby-lang.org/gonzui/markup/xmlparser/lib/xml/dom/builder.rb?q=moduledef:XML)
    了解更多关于 *`XML::DOM::Builder`* 的信息。'
- en: We then start a block at ❹ with the `begin` keyword, which indicates a block
    that may fail so disastrously to do what’s asked of it that it could exit the
    program entirely. The `begin` keyword allows you to trap that error and deal with
    it in some intelligent way, without causing the program to crash. We ask our `builder`
    instance to `parse` the XML content represented by `self`, which is of course
    a String within a String instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `begin` 关键字在❹处开始一个块，这表示一个可能会以灾难性的方式失败，以至于它可能会完全退出程序。`begin` 关键字允许你捕获该错误并以某种智能方式处理它，而不会导致程序崩溃。我们要求我们的
    `builder` 实例 `parse` 由 `self` 表示的 XML 内容，当然是在一个 String 实例内部。
- en: This parse operation is the one that might fail. The potentially disastrous
    error has a type called `XMLParserError`, so at ❺ we use the `rescue` keyword
    to trap that particular error type and prevent it from killing the entire program.
    Since our predicate tests for XML well-formedness, an `XMLParserError` indicates
    that the document is not well-formed. Therefore, we should `return` `false` in
    the event of an `XMLParserError`. If we get out of the `begin` block without entering
    the `rescue` section, that means there was no error, so we can safely `return`
    `true` at ❻.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解析操作可能会失败。潜在的灾难性错误有一个名为 `XMLParserError` 的类型，因此我们在❺处使用 `rescue` 关键字来捕获该特定错误类型，防止它杀死整个程序。由于我们的谓词测试
    XML 的良好格式，`XMLParserError` 指示文档不是良好格式。因此，在发生 `XMLParserError` 时，我们应该 `return`
    `false`。如果我们从 `begin` 块中退出而没有进入 `rescue` 部分，这意味着没有错误，所以我们可以在❻处安全地 `return` `true`。
- en: We’ll finish the `xml_wellformedness_checker.rb` script with a `well_formed?`
    function that accepts a `filename` argument, created at ❼. It `return`s an implicit
    `nil` for a `nil filename` at ❽. We then `return` a call to `well_formed_xml?`
    on the File instance created by opening `filename` at ❾. Finally, ❿ prints the
    result of calling `well_formed?` to the user via `puts`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个接受 `filename` 参数的 `well_formed?` 函数来完成 `xml_wellformedness_checker.rb`
    脚本，该函数在❺处创建。对于 `nil filename`，它 `return`s 一个隐式的 `nil`。然后我们 `return` 对通过打开 `filename`
    创建的 File 实例调用 `well_formed_xml?`。最后，❿ 通过 `puts` 将 `well_formed?` 的调用结果打印给用户。
- en: Running the Script
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: We know that we have a well-formed XML file in `extras/eh.html.tidy` because
    we ran `html_tidy.rb` on it to fix it. We also know that `extras/eh.html` had
    an unclosed paragraph tag, which would make it not well-formed. Let’s see how
    `xml_wellformedness_checker.rb` performs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `extras/eh.html.tidy` 中有一个良好格式的 XML 文件，因为我们已经运行了 `html_tidy.rb` 来修复它。我们还知道
    `extras/eh.html` 有一个未关闭的段落标签，这将使其不是良好格式。让我们看看 `xml_wellformedness_checker.rb`
    的表现如何。
- en: The Results
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `extras/eh.html.tidy` file is well-formed XML, so it properly reports `true`.
    The `extras/eh.html` and `xml_wellformedness_checker.rb` files are either not
    well-formed XML or not XML at all, so they properly report `false`. If we call
    `xml_wellformedness_checker.rb` with no `filename`, it returns `nil`, as we expect
    from ❽.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`extras/eh.html.tidy` 文件是良好格式的 XML，因此它正确地报告了 `true`。`extras/eh.html` 和 `xml_wellformedness_checker.rb`
    文件要么不是良好格式的 XML，要么根本不是 XML，因此它们正确地报告了 `false`。如果我们不带 `filename` 调用 `xml_wellformedness_checker.rb`，它将返回
    `nil`，正如我们在❽处所期望的那样。'
- en: Hacking the Script
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: Calling a separate function called `well_formed?` on a `filename` argument is
    really just for demonstration purposes. In production code, a more likely use
    for this script would be to add another method to String called `well_formed_xml_filename?`,
    implemented as `well_formed?`, except that it would use `self` in place of `filename`.
    Or, in whatever code opens a given XML file, that file could be checked using
    File’s `well_formed_xml?` method before performing any operations that depend
    on the file’s contents being well-formed XML.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `filename` 参数上调用一个名为 `well_formed?` 的独立函数实际上只是为了演示目的。在生产代码中，这个脚本更可能被用来向 String
    类添加另一个方法 `well_formed_xml_filename?`，实现方式与 `well_formed?` 相同，只是它会使用 `self` 代替
    `filename`。或者，在打开特定 XML 文件的任何代码中，可以在执行依赖于文件内容为良好格式 XML 的任何操作之前，使用 File 的 `well_formed_xml?`
    方法来检查该文件。
- en: Chapter Recap
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: What was new in this chapter?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有什么新内容？
- en: Tidying HTML/XML markup
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整理 HTML/XML 标记
- en: Piping output to standard error with `2>`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `2>` 将输出重定向到标准错误
- en: The Web Accessibility Initiative
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络无障碍性倡议
- en: The `<=>` method and the Comparable module
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=>` 方法与Comparable模块'
- en: Processing XML with `REXML` and `XML::DOM::Builder`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `REXML` 和 `XML::DOM::Builder` 处理XML
- en: Manipulating XML documents with regular expressions
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式操作XML文档
- en: Making Hashes out of Arrays with `inject`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `inject` 从数组中生成哈希
- en: Hashes serving as histograms
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为直方图的哈希
- en: Mapping Procs onto Arrays
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将过程映射到数组上
- en: The Document Object Model
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档对象模型
- en: The `begin` and `rescue` keywords
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`begin` 和 `rescue` 关键字'
- en: That’s it for our XML-processing scripts. I hope these example scripts are not
    only useful in and of themselves but that they also might give you ideas about
    how you could modify or extend them to suit new tasks other than those presented
    here. For now, we’ll proceed to our next chapter, [Chapter 9](ch09.html "Chapter 9. More
    Complex Utilities and Tricks, Part I"). As the name suggests, its scripts are
    more detailed, and they will continue to introduce some new functional techniques,
    as well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关于XML处理的脚本就到这里了。我希望这些示例脚本不仅本身有用，而且还能给你一些想法，关于如何修改或扩展它们以适应这里未展示的新任务。现在，我们将继续到下一章，[第9章](ch09.html
    "第9章。更复杂的工具和技巧，第一部分")。正如其名所示，它的脚本更加详细，并且将继续介绍一些新的功能技术。
