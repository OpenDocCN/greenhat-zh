- en: '![](../images/313-1.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/313-1.jpg)'
- en: '[**RTA REFERENCE**](toc.html#app1)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA参考**](toc.html#app1)'
- en: '![](../images/as.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/as.jpg)'
- en: '*Run Time Access (RTA)* is a library that displays your program’s internal
    structures and arrays as database tables. RTA uses a subset of the PostgreSQL
    protocol and is compatible with the PostgreSQL bindings for C and PHP, as well
    as for the PostgreSQL command-line tool, psql. This appendix contains the definitions,
    data structures, and function prototypes for the RTA package.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行时访问（RTA）* 是一个库，它将程序的内部结构和数组以数据库表的形式显示出来。RTA使用PostgreSQL协议的一个子集，并且与C和PHP的PostgreSQL绑定以及PostgreSQL命令行工具psql兼容。本附录包含了RTA包的定义、数据结构和函数原型。'
- en: The contents of this appendix that are taken from the RTA include excerpts from
    the file rta.h. We use the exact text of rta.h wherever possible. A less technical
    description of the material in this appendix is given in Chapters 2 and 3.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录中摘自RTA的内容包括来自文件rta.h的摘录。我们尽可能使用rta.h的精确文本。本附录中材料的非技术性描述见第2章和第3章。
- en: 'This appendix covers:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖：
- en: Overview of RTA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTA概述
- en: RTA constants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTA常量
- en: Data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: API subroutines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API子例程
- en: SELECT and UPDATE syntax
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELECT和UPDATE语法
- en: Internal RTA tables
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部RTA表
- en: Debug configuration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试配置
- en: Error messages
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息
- en: Callback routines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调例程
- en: Linux appliances lack real-time access to status and statistics, as well as
    the ability to configure a service once it has started. As Linux users, we assume
    that to configure an application we will be able to use SSH or telnet to gain
    access to the service, use an editor to modify the /etc configuration file, and
    use the kill -1 command to terminate the process—so real-time status and statistics
    are features Linux programmers don’t even think to request. The lack of run-time
    access poses a particular challenge for network appliances where SSH is unavailable,
    either because it is not installed or it is not allowed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux家电缺乏对状态和统计信息的实时访问，以及一旦启动就无法配置服务的能力。作为Linux用户，我们假设要配置应用程序，我们将能够使用SSH或telnet访问服务，使用编辑器修改/etc配置文件，并使用kill
    -1命令终止进程——因此，实时状态和统计信息是Linux程序员甚至不会想到要求的功能。缺乏运行时访问对SSH不可用的网络设备提出了特别的挑战，无论是由于未安装还是不允许。
- en: Another challenge for appliance designers is that more than one type of user
    interface may be required. Many appliances have some combination of web, command-line,
    SNMP agent, front panel, and framebuffer interfaces. It is a nontrivial task to
    give the end user a consistent view regardless of the UI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于家电设计师来说，另一个挑战是可能需要多种用户界面。许多家电都集成了网络、命令行、SNMP代理、前面板和帧缓冲区接口的组合。无论UI如何，为最终用户提供一致的视图是一项非同小可的任务。
- en: '[**Overview of RTA**](toc.html#app1.1)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA概述**](toc.html#app1.1)'
- en: The RTA package addresses the challenges described above by giving realtime
    access to the data structures and arrays inside a running program. With minimal
    effort, we can use RTA to make a program’s data structures appear as PostgreSQL
    tables in a PostgreSQL database.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RTA包通过提供对运行程序内部数据结构和数组的实时访问来解决上述挑战。我们只需付出最小的努力，就可以使用RTA将程序的数据结构作为PostgreSQL数据库中的PostgreSQL表来显示。
- en: Using RTA, a structure definition is also the definition for a table row, and
    an array of structures will appear as a table. For example, the code below shows
    a definition of a data structure for TCP connection information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RTA，结构定义也是表格行的定义，结构数组的集合将显示为表格。例如，下面的代码展示了TCP连接信息的数据结构定义。
- en: '![](../images/314-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/314-1.jpg)'
- en: The tcpconn structure describes a single connection. An array of these structures
    is needed if there’s more than one connection. This array might be allocated with
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: tcpconn结构描述了一个单独的连接。如果有多个连接，则需要这些结构的数组。这个数组可能被分配如下
- en: struct tcpconn Conns[10];
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: struct tcpconn Conns[10];
- en: 'The above array of structures could be considered a database table, with each
    structure in the array as a row and each member in the structure as a column.
    RTA allows you to use any programming language with a PostgreSQL binding to query
    this table of TCP connections. Here are two sample SQL statements to manipulate
    the data in the Conns table:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构数组可以被视为数据库表，数组中的每个结构作为一个行，结构中的每个成员作为一个列。RTA允许您使用任何具有PostgreSQL绑定的编程语言查询这个TCP连接表。以下是对Conns表中数据进行操作的两个示例SQL语句：
- en: SELECT lport, dport FROM Conns WHERE fd != -1;
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT lport, dport FROM Conns WHERE fd != -1;
- en: UPDATE Conns SET dport = 0 WHERE fd = -1;
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE Conns SET dport = 0 WHERE fd = -1;
- en: Don’t worry if the above statements do not make sense; there is a short tutorial
    on SQL later in this appendix.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述声明没有意义，请不要担心；在本附录的后面有一个关于SQL的简短教程。
- en: The addition of a database API offers several advantages. For one, debugging
    is made easier because you can use simple PostgreSQL tools to view much of your
    program’s state. The PostgreSQL database API also makes it easier to build UI
    programs, since it includes bindings for PHP, Tcl/Tk, Perl, C, Java, Visual C++,
    and many other programming languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 添加数据库API提供了几个优点。首先，调试变得更加容易，因为你可以使用简单的PostgreSQL工具来查看你程序的大部分状态。PostgreSQL数据库API还包括对PHP、Tcl/Tk、Perl、C、Java、Visual
    C++和许多其他编程语言的绑定，这使得构建UI程序更加容易。
- en: A database API can also help speed up development. When the tables used by the
    UI programs are carefully defined, the core application team can build the application
    while the UI developers work on the web pages, wizards, and MIBs of the various
    UI programs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库API还可以帮助加快开发速度。当UI程序使用的表被仔细定义时，核心应用团队可以在UI开发者处理网页、向导和各个UI程序的MIB时构建应用程序。
- en: In order to make your arrays and structures available to the database API, you
    must tell RTA about the tables (including things like the name, start address,
    number of rows, and length of each row) and columns (including things like the
    associate table name, column name, column’s data type, and whether special functions
    called *callbacks* are to be called when the column is read or written).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的数组和结构对数据库API可用，你必须告诉RTA关于表（包括名称、起始地址、行数以及每行的长度）和列（包括关联表名称、列名称、列的数据类型以及当列被读取或写入时是否调用特殊函数*回调*）的信息。
- en: '[**RTA Constants**](toc.html#app1.2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[**RTA常量**](toc.html#app1.2)'
- en: Here is an excerpt from the rta.h file showing the constants that describe the
    internal size limits for the RTA package. You can change these limits, but if
    you do, be sure to recompile the RTA package using your new settings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从rta.h文件中摘录的，显示了描述RTA包内部大小限制的常量。你可以更改这些限制，但如果你这样做，请确保使用你的新设置重新编译RTA包。
- en: '![](../images/315-1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/315-1.jpg)'
- en: '![](../images/316-1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/316-1.jpg)'
- en: '[**Data Structures**](toc.html#app1.3)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[**数据结构**](toc.html#app1.3)'
- en: Recall that each column in a table corresponds to a structure member, and each
    row in a table corresponds to an array element. In order for RTA to treat your
    arrays of structures as tables, you have the tell RTA about the tables. You describe
    each column by filling in a COLDEF structure, and you describe each table by filling
    in a TBLDEF structure. Here is an excerpt from rta.h that completely defines the
    data structures and constants associated with tables and columns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，表中的每一列对应一个结构成员，表中的每一行对应一个数组元素。为了使RTA将你的结构数组视为表，你必须告诉RTA关于表的信息。你通过填写COLDEF结构来描述每一列，通过填写TBLDEF结构来描述每一表。以下是rta.h的摘录，它完全定义了与表和列相关的数据结构和常量。
- en: '![](../images/316-2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/316-2.jpg)'
- en: '![](../images/317-1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/317-1.jpg)'
- en: '![](../images/317-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/317-2.jpg)'
- en: '![](../images/318-1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/318-1.jpg)'
- en: '![](../images/318-2.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/318-2.jpg)'
- en: '![](../images/319-1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/319-1.jpg)'
- en: '![](../images/319-2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/319-2.jpg)'
- en: '![](../images/320-1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/320-1.jpg)'
- en: '[**API Subroutines**](toc.html#app1.4)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[**API子例程**](toc.html#app1.4)'
- en: There are only six subroutines in the RTA API. Table A-1 summarizes them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: RTA API中只有六个子例程。表A-1总结了它们。
- en: '**Table A-1:** Subroutines for the RTA PostgreSQL API'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**表A-1：RTA PostgreSQL API的子例程**'
- en: '![](../images/320-2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/320-2.jpg)'
- en: The subroutines in the RTA libraries usually return one of the following values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: RTA库中的子例程通常返回以下值之一。
- en: '![](../images/320-3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/320-3.jpg)'
- en: '[***The dbcommand() Subroutine***](toc.html#app1.5)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[***dbcommand()子例程***](toc.html#app1.5)'
- en: The main application in your appliance accepts TCP connections from PostgreSQL
    clients and passes the stream of bytes (encoded SQL requests) from the client
    into RTA via the dbcommand() subroutine. In turn, dbcommand() writes the stream
    of bytes to an input buffer to be parsed for an SQL command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的设备中的主要应用程序接受来自PostgreSQL客户端的TCP连接，并通过dbcommand()子例程将客户端的字节流（编码的SQL请求）传递给RTA。然后，dbcommand()将字节流写入输入缓冲区以解析SQL命令。
- en: If the input buffer contains a complete command, the command will be executed,
    the number-of-characters-in (nin) variable will be decreased by the number of
    bytes consumed, and RTA_SUCCESS will be returned. If there is not a complete command
    in the input buffer, RTA_NOCMD will be returned and no bytes will be removed from
    the input buffer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入缓冲区包含完整的命令，则将执行该命令，字符数变量（nin）将减少所消耗的字节数，并返回RTA_SUCCESS。如果输入缓冲区中没有完整的命令，则返回RTA_NOCMD，且不会从输入缓冲区中移除任何字节。
- en: If a command is executed, the results will be encoded into the PostgreSQL protocol
    and placed in the output buffer (out). When the subroutine is called, the input
    variable, number-of-characters-out (nout), has the number of free bytes available
    in the output buffer. When the subroutine returns, the nout variable will be decremented
    by the size of the response placed in the output buffer. An error message is generated
    if the number of available bytes in the output buffer is too small to hold the
    response from the SQL command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行了命令，结果将被编码到PostgreSQL协议中，并放置在输出缓冲区（out）中。当调用子程序时，输入变量，输出字符数（nout），表示输出缓冲区中可用的空闲字节数。当子程序返回时，nout变量将减少输出缓冲区中放置的响应的大小。如果输出缓冲区中可用的字节数不足以容纳SQL命令的响应，将生成错误消息。
- en: The list below summarizes the input buffers and bytes for the dbcommand() subroutine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表总结了dbcommand() 子程序的输入缓冲区和字节。
- en: '![](../images/321-1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/321-1.jpg)'
- en: The list below summarizes the returns for the dbcommand() subroutine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表总结了dbcommand() 子程序的返回值。
- en: '![](../images/321-2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/321-2.jpg)'
- en: The prototype for the dbcommand() subroutine is shown below.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: dbcommand() 子程序的原型如下所示。
- en: '![](../images/321-3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/321-3.jpg)'
- en: '[***The rta_add_table() Subroutine***](toc.html#app1.6)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_add_table() 子程序***](toc.html#app1.6)'
- en: The rta_add_table() subroutine registers a table for inclusion in the database
    interface, which gives external PostgreSQL clients access to the contents of the
    table. You need to call rta_add_table() for each of your tables.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: rta_add_table() 子程序将表注册为数据库接口的一部分，这为外部PostgreSQL客户端提供了访问表内容的能力。你需要为你的每个表调用rta_add_table()。
- en: Note that the TBLDEF structure must be statically allocated. RTA keeps only
    the pointer to the table and does not copy the information. This means that you
    can change the contents of the table definition by changing the contents of the
    TBLDEF structure, which is useful if you need to allocate more memory for the
    table and change its row count and address.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，TBLDEF结构必须静态分配。RTA仅保留对表的指针，并不复制信息。这意味着你可以通过更改TBLDEF结构的内容来更改表定义的内容，这在需要为表分配更多内存并更改其行数和地址时非常有用。
- en: When you add an RTA table, you will see an error message if another table with
    the same name already exists in the database or if the table is defined without
    any columns.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在数据库中添加RTA表时，如果已存在具有相同名称的其他表或表未定义任何列，你将看到错误消息。
- en: If you specify a savefile, the SQL commands in the savefile will be loaded as
    part of the rta_add_table() call. See “The rta_load() Subroutine” on page 300
    for more details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了保存文件，保存文件中的SQL命令将作为rta_add_table()调用的部分加载。有关更多详细信息，请参阅第300页上的“rta_load()
    子程序”。
- en: This list summarizes the input for the rta_add_table() subroutine.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了rta_add_table() 子程序的输入。
- en: '![](../images/322-1.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/322-1.jpg)'
- en: This list summarizes the returns for the rta_add_table() subroutine.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了rta_add_table() 子程序的返回值。
- en: '![](../images/322-2.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/322-2.jpg)'
- en: The prototype of the rta_add_table() subroutine is shown below.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: rta_add_table() 子程序的原型如下所示。
- en: '![](../images/322-3.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/322-3.jpg)'
- en: '[***The SQL_string() Subroutine***](toc.html#app1.7)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[***SQL_string() 子程序***](toc.html#app1.7)'
- en: The SQL_string() subroutine executes the SQL command placed in the null-terminated
    input string, cmd. The results are encoded into the PostgreSQL protocol and placed
    in the output buffer, out. When the subroutine is called, the input variable,
    nout, has the number of free bytes available in the output buffer, out. When the
    subroutine returns, nout has been decremented by the size of the response placed
    in the output buffer. An error message is generated if the number of available
    bytes in the output buffer is too small to hold the response from the SQL command.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SQL_string() 子程序执行放置在空终止输入字符串 cmd 中的 SQL 命令。结果被编码到 PostgreSQL 协议中，并放置在输出缓冲区
    out 中。当子程序被调用时，输入变量 nout 包含输出缓冲区 out 中可用的空闲字节数。当子程序返回时，nout 已通过放置在输出缓冲区中的响应大小递减。如果输出缓冲区中可用的字节数不足以容纳
    SQL 命令的响应，将生成错误信息。
- en: This subroutine may be most useful when updating a table value in order to invoke
    the write callbacks. (The output buffer has the results encoded in the PostgreSQL
    protocol and might not be too useful directly.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此子程序在更新表值以调用写回调时可能最有用。（输出缓冲区包含使用 PostgreSQL 协议编码的结果，可能不是直接很有用。）
- en: The list below summarizes the input for the SQL_string() subroutine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表总结了 SQL_string() 子程序的输入。
- en: '![](../images/323-1.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/323-1.jpg)'
- en: The SQL_string() subroutine returns nothing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SQL_string() 子程序不返回任何内容。
- en: The prototype for the SQL_string() subroutine is shown below.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SQL_string() 子程序的原型如下所示。
- en: '![](../images/323-2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/323-2.jpg)'
- en: '[***The rta_config_dir() Subroutine***](toc.html#app1.8)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_config_dir() 子程序](toc.html#app1.8)'
- en: The rta_config_dir() subroutine sets the default path to the savefile directory.
    The string that the input parameter, configdir, points to is saved and prepended
    to the savefile names for tables with savefiles.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: rta_config_dir() 子程序设置保存文件目录的默认路径。输入参数 configdir 指向的字符串被保存，并添加到具有保存文件的表的保存文件名称前。
- en: You should call the rta_config_dir() subroutine before you load your application
    tables. This subroutine is intended to simplify applications that let the user
    specify a configuration directory on the command line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载您的应用程序表之前，您应该调用 rta_config_dir() 子程序。此子程序旨在简化允许用户在命令行中指定配置目录的应用程序。
- en: If the savefile uses an absolute path (starting with /), it is not prepended
    with the configuration directory.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保存文件使用绝对路径（以 / 开头），则不会在配置目录前添加。
- en: This list summarizes the input for the rta_config_dir() subroutine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了 rta_config_dir() 子程序的输入。
- en: '![](../images/323-3.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/323-3.jpg)'
- en: This list summarizes the return values for the rta_config_dir() subroutine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了 rta_config_dir() 子程序的返回值。
- en: '![](../images/323-4.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/323-4.jpg)'
- en: The prototype of the rta_config_dir() subroutine is shown below.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了 rta_config_dir() 子程序的原型。
- en: int rta_config_dir(char *configdir);
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: int rta_config_dir(char *configdir);
- en: '[***The rta_save() Subroutine***](toc.html#app1.9)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_save() 子程序***](toc.html#app1.9)'
- en: The rta_save() subroutine saves a table to a file, including all savetodisk
    columns to the path and file specified. Only savetodisk columns are saved. The
    resulting file is a list of UPDATE commands containing the desired data. There
    is one UPDATE command for each row in a table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: rta_save() 子程序将一个表保存到文件中，包括所有 savetodisk 列到指定的路径和文件。只有 savetodisk 列被保存。生成的文件是一个包含所需数据的
    UPDATE 命令列表。表中每一行对应一个 UPDATE 命令。
- en: The rta_save() subroutine tries to prevent corrupted save files by opening a
    temporary (temp) file in the same directory as the target file. The subroutine
    saves the data in the temp file and then automatically calls the rename() subroutine
    to atomically move the temp file to the savefile. The rta_save() subroutine generates
    errors if it cannot open the temp file or if it is unable to rename the temp file
    with rename().
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: rta_save() 子程序通过在目标文件相同的目录中打开一个临时（temp）文件来尝试防止保存文件损坏。子程序在 temp 文件中保存数据，然后自动调用
    rename() 子程序将 temp 文件原子性地移动到保存文件。如果无法打开 temp 文件或无法使用 rename() 重命名 temp 文件，rta_save()
    子程序将生成错误。
- en: '**NOTE**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As a general warning, keep in mind that any disk I/O can cause a program to
    block briefly. Therefore, saving and loading tables can cause your program to
    block for a moment.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*一般警告：请记住，任何磁盘 I/O 都可能导致程序短暂阻塞。因此，保存和加载表可能导致您的程序暂时阻塞。*'
- en: This list summarizes the input for the rta_save() subroutine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了 rta_save() 子程序的输入。
- en: '![](../images/324-1.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/324-1.jpg)'
- en: This list summarizes the return values for the rta_save() subroutine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表总结了 rta_save() 子程序的返回值。
- en: '![](../images/324-2.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/324-2.jpg)'
- en: The prototype of the rta_save() subroutine is shown below.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: rta_save()子程序的原型如下所示。
- en: '![](../images/324-3.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/324-3.jpg)'
- en: '[***The rta_load() Subroutine***](toc.html#app1.10)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_load()子程序***](toc.html#app1.10)'
- en: The rta_load() subroutine loads a table from a file of UPDATE commands. The
    file format is a series of UPDATE commands with one command per line. Any write
    callbacks are executed as each UPDATE occurs. Note that a call to rta_load() occurs
    automatically when you add the table using rta_add_table(). This list summarizes
    the input for the rta_load() subroutine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: rta_load()子程序从UPDATE命令的文件中加载数据表。文件格式是一系列UPDATE命令，每行一个命令。每次UPDATE发生时都会执行任何写回调。请注意，当您使用rta_add_table()添加表时，会自动调用rta_load()。以下总结了rta_load()子程序的输入。
- en: This list summarizes the return values for the rta_load() subroutine.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本列表总结了rta_load()子程序的返回值。
- en: '![](../images/324-4.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/324-4.jpg)'
- en: The prototype of the rta_save() subroutine is shown below.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: rta_save()子程序的原型如下所示。
- en: '![](../images/324-5.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/324-5.jpg)'
- en: The prototype of the rta_save() subroutine is shown below.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: rta_save()子程序的原型如下所示。
- en: '![](../images/325-1.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/325-1.jpg)'
- en: '[**SELECT and UPDATE Syntax**](toc.html#app1.11)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[**SELECT和UPDATE语法**](toc.html#app1.11)'
- en: The next two sections give a brief introduction to the two SQL commands implemented
    by the RTA API. Neither the RTA UPDATE command nor the RTA SELECT command adhere
    strictly to their PostgreSQL equivalents. RTA does not allow JOIN clauses, and
    the WHERE clause supports only the boolean AND operator. There are no locks or
    transactions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下两节简要介绍了RTA API实现的两个SQL命令。RTA UPDATE命令和RTA SELECT命令并不严格遵循它们的PostgreSQL等价物。RTA不允许JOIN子句，WHERE子句仅支持布尔AND运算符。没有锁或事务。
- en: '[***The SELECT Command***](toc.html#app1.12)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[***SELECT命令***](toc.html#app1.12)'
- en: The prototype for the RTA SELECT command is shown below.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: RTA SELECT命令的原型如下所示。
- en: SELECT column_list FROM table [where_clause] [limit_clause]
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT column_list FROM table [where_clause] [limit_clause]
- en: Most NCMDCOLS (defined above) columns can be specified in the column_list or
    in the WHERE clause. The reserved word *LIMIT* restricts the number of rows returned
    to the number specified. The reserved word *OFFSET* skips the number of rows specified
    and begins output with the next row.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数NCMDCOLS（如上定义）列可以在column_list或WHERE子句中指定。保留字*LIMIT*限制了返回的行数，与指定的数字相同。保留字*OFFSET*跳过指定的行数，并从下一行开始输出。
- en: A column_list can contain * (a wild card character that represents all columns),
    a single column name, or a comma-separated list of column names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: column_list可以包含*（代表所有列的通配符），单个列名，或以逗号分隔的列名列表。
- en: 'A sample of the where_clause syntax is shown below:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了where_clause语法的示例：
- en: col_name = value [AND col_name = value ..]
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: col_name = value [AND col_name = value ..]
- en: In this example, all the col_name = value pairs must match for a row to match.
    Note that you can use five other comparison operators in addition to equality.
    The list below shows the six available comparison operators.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，所有col_name = value对必须匹配，才能使行匹配。请注意，除了等于之外，您还可以使用其他五个比较运算符。以下列出了六个可用的比较运算符。
- en: '![](../images/325-2.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/325-2.jpg)'
- en: 'A sample of the limit_clause syntax is shown below:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了limit_clause语法的示例：
- en: LIMIT 5
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT 5
- en: You will find the LIMIT and OFFSET columns to be very useful because they prevent
    a buffer overflow on the output buffer of dbcommand(). They are also useful for
    web-based UIs in which users want to be able to view data one page at a time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现LIMIT和OFFSET列非常有用，因为它们可以防止dbcommand()输出缓冲区的缓冲区溢出。它们对于基于Web的UI也非常有用，用户希望一次查看一页数据。
- en: There are eight reserved words that can not be used as column or table names.
    The reserved words are *AND*, *FROM*, *LIMIT*, *OFFSET*, *SELECT*, *SET*, *UPDATE*,
    and *WHERE*. These are not case sensitive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有八个不能用作列名或表名的保留字。这些保留字是*AND*、*FROM*、*LIMIT*、*OFFSET*、*SELECT*、*SET*、*UPDATE*和*WHERE*。它们不区分大小写。
- en: 'Strings may contain any of the following characters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以包含以下任何字符：
- en: '![](../images/326-1.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/326-1.jpg)'
- en: If a string contains a double quote, use a single quote to wrap it. The string
    below is enclosed in single quotes since the string contains double quotes surrounding
    the *Hi mom!* substring.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串包含双引号，则使用单引号将其括起来。下面的字符串用单引号括起来，因为字符串包含包围*Hi mom!*子串的双引号。
- en: '''The sign says "Hi mom!"'''
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '''标志说"嗨，妈妈！"'''
- en: Use double quotes to wrap strings with embedded single quotes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号将嵌入单引号的字符串括起来。
- en: Examples of the SELECT command are shown below.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了 SELECT 命令的示例。
- en: '![](../images/326-2.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/326-2.jpg)'
- en: '[***The UPDATE Command***](toc.html#app1.13)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[***更新命令***](toc.html#app1.13)'
- en: The UPDATE command writes values into a table. The prototype for the RTA UPDATE
    command is shown below.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 命令将值写入表。RTA UPDATE 命令的原型如下所示。
- en: '![](../images/326-3.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/326-3.jpg)'
- en: An UPDATE invokes write callbacks on the affected columns. All data in the UPDATE_list
    is written before the callbacks are invoked.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 会调用受影响列的写回调。在调用回调之前，UPDATE_list 中的所有数据都被写入。
- en: The LIMIT clause for UPDATE is not standard PostgreSQL, but this clause can
    be useful for stepping through a table one row at a time. To change only the wth
    row of a table, use a limit clause like the one below. Note that *n* is zero indexed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: UPDATE 的 LIMIT 子句不是标准的 PostgreSQL，但此子句可以用于逐行遍历表。要更改表的第 wth 行，请使用如下所示的 LIMIT
    子句。注意，*n* 是零索引。
- en: '![](../images/327-1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/327-1.jpg)'
- en: '[**Internal RTA Tables**](toc.html#app1.14)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[**内部 RTA 表**](toc.html#app1.14)'
- en: When you use the RTA library, your application will include the following four
    RTA tables.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 RTA 库时，您的应用程序将包含以下四个 RTA 表。
- en: '![](../images/327-2.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/327-2.jpg)'
- en: '[***The rta_tables Table***](toc.html#app1.15)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_tables 表***](toc.html#app1.15)'
- en: The rta_tables table gives SQL access to all internal and registered tables.
    The data in the table is exactly the same as the data in the TBLDEF structures
    registered with the rta_add_table() subroutine. This table is the generic table
    editor, which is used for application debugging. The columns in the rta_tables
    table are shown below and correspond to the fields in the RTA_TABLE data structure
    described above.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: rta_tables 表提供了对所有内部和已注册表的 SQL 访问。表中的数据与使用 rta_add_table() 子程序注册的 TBLDEF 结构中的数据完全相同。此表是通用表编辑器，用于应用程序调试。rta_tables
    表中的列如下所示，并对应于上述描述的 RTA_TABLE 数据结构中的字段。
- en: '![](../images/327-3.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/327-3.jpg)'
- en: '![](../images/328-1.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/328-1.jpg)'
- en: '[***The rta_columns Table***](toc.html#app1.16)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[***rta_columns 表***](toc.html#app1.16)'
- en: The rta_columns table lists the column definitions for all the columns in the
    database. The data in the table is exactly the same as the data in the COLDEF
    structures registered with the rta_add_table() subroutine. This table is used
    for the generic table viewer and table editor applications, which are used mostly
    for application debugging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: rta_columns 表列出了数据库中所有列的列定义。表中的数据与使用 rta_add_table() 子程序注册的 COLDEF 结构中的数据完全相同。此表用于通用表查看器和表编辑器应用程序，这些应用程序主要用于应用程序调试。
- en: The columns in the rta_columns table are shown below.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: rta_columns 表中的列如下所示。
- en: '![](../images/328-2.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/328-2.jpg)'
- en: '[**Debug Configuration**](toc.html#app1.17)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[**调试配置**](toc.html#app1.17)'
- en: The RTA package does not generates any user-level log messages, only debug messages.
    The rta_dbgconfig table specifies the handling of these debug log messages. All
    of the fields in this table are volatile. You need to set the values in your main
    program to make them seem persistent. See the sample SQL string subroutine below.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: RTA 包不生成任何用户级日志消息，只有调试消息。rta_dbgconfig 表指定了这些调试日志消息的处理。此表中的所有字段都是易变的。您需要在主程序中设置这些值以使它们看起来持久。请参阅下面的示例
    SQL 字符串子程序。
- en: SQL_string("UPDATE rta_dbgconfig SET target = 3")
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SQL_string("UPDATE rta_dbgconfig SET target = 3")
- en: The columns in the rta_dbgconfig table are shown below.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: rta_dbgconfig 表中的列如下所示。
- en: '![](../images/328-3.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/328-3.jpg)'
- en: '![](../images/329-1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/329-1.jpg)'
- en: '[**Error Messages**](toc.html#app1.18)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[**错误消息**](toc.html#app1.18)'
- en: 'There are two types of error messages available in the RTA package: SQL request
    messages and internal debug messages.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: RTA 包中提供了两种类型的错误消息：SQL 请求消息和内部调试消息。
- en: '[***SQL Request Errors***](toc.html#app1.19)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[***SQL 请求错误***](toc.html#app1.19)'
- en: SQL request messages include the error messages returned as part of an SQL request.
    The six messages of this type are listed below.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 请求消息包括作为 SQL 请求一部分返回的错误消息。以下列出了此类错误消息的六个。
- en: 'ERROR: Relation ''%s'' does not exist'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：关系 '%s' 不存在
- en: This reply indicates that a table requested in a SELECT or UPDATE statement
    does not exist. The %s is replaced by the name of the requested table.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示在 SELECT 或 UPDATE 语句中请求的表不存在。%s 被请求的表名替换。
- en: 'ERROR: Attribute ''%s'' not found'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：属性 '%s' 未找到
- en: This reply indicates that a column requested in a SELECT or UPDATE statement
    does not exist. The %s is replaced by the name of the requested column.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示在SELECT或UPDATE语句中请求的列不存在。%s被请求的列名替换。
- en: 'ERROR: SQL parse error'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：SQL 解析错误
- en: This reply indicates a malformed SQL request or a mismatch in the types of data
    in a where clause or in an UPDATE list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示SQL请求格式不正确或where子句或UPDATE列表中数据类型不匹配。
- en: 'ERROR: Output buffer full'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：输出缓冲区已满
- en: This reply indicates that the size of the response to a request exceeds the
    size of the output buffer. (See dbcommand() and the out and nout parameters.)
    This error can be avoided with a large enough output buffer, or, preferably, with
    the use of LIMIT and OFFSET.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示对请求的响应大小超过了输出缓冲区的大小。（参见dbcommand()和out和nout参数。）可以通过足够大的输出缓冲区或最好使用LIMIT和OFFSET来避免此错误。
- en: 'ERROR: String too long for ''%s'''
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：字符串长度超过 '%s'
- en: This reply indicates that an UPDATE to a column of type string or pointer to
    string would have exceeded the width of the column. The %s is replaced by the
    column name.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示对字符串或字符串指针类型的列的UPDATE将超过列的宽度。%s被列名替换。
- en: 'ERROR: Can not UPDATE read-only column ''%s'''
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：无法更新只读列 '%s'
- en: This reply indicates an attempt to UPDATE a column marked as readonly. The %s
    is replaced by the column name.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此回复表示尝试更新标记为只读的列。%s被列名替换。
- en: '[***Internal Debug Messages***](toc.html#app1.20)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[***内部调试消息***](toc.html#app1.20)'
- en: The RTA program logs internal errors using the standard syslog() facility, which
    is available on all Linux systems. The default syslog() facility is LOG_USER,
    but you can change the default by setting facility in the rta_dbg table.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: RTA程序使用标准的syslog()功能记录内部错误，该功能在所有Linux系统上可用。默认的syslog()功能是LOG_USER，但您可以通过在rta_dbg表中设置功能来更改默认设置。
- en: 'You can modify syslogd in order to do post-processing, such as generating SNMP
    traps from these debug messages. The RTA program sends all internal debug error
    messages to syslog() in this format:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改syslogd以进行后处理，例如从这些调试消息生成SNMP陷阱。RTA程序以以下格式将所有内部调试错误消息发送到syslog()：
- en: 'rta[PID]: FILE LINE#: error_message'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: rta[PID]：文件行号#：错误信息
- en: The RTA program will replace PID, FILE, and LINE# with the process ID, the source
    filename, and the line number where the error was detected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: RTA程序将用进程ID、源文件名和检测到错误的行号替换PID、FILE和LINE#。
- en: Here are the definitions used to generate debug and error messages. The RTA
    program will replace %s %d at the start of each error string with the filename
    and line number where the error was detected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于生成调试和错误消息的定义。RTA程序将在每个错误字符串的开始处替换%s %d，以表示检测到错误的文件名和行号。
- en: '**System Errors**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统错误**'
- en: '![](../images/330-1.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/330-1.jpg)'
- en: '**RTA Errors**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**RTA 错误**'
- en: '![](../images/331-1.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/331-1.jpg)'
- en: '**SQL Errors**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL 错误**'
- en: '![](../images/331-2.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/331-2.jpg)'
- en: '**Trace Messages**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪消息**'
- en: '![](../images/331-3.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/331-3.jpg)'
- en: '[**Callback Routines**](toc.html#app1.21)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[**回调例程**](toc.html#app1.21)'
- en: As mentioned above, read callbacks are executed before a column value is used,
    and write callbacks are called after all columns have been UPDATEd. Both read
    and write callbacks return zero on success and nonzero on error.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，读取回调在列值使用之前执行，写入回调在所有列都已UPDATE之后调用。读取和写入回调在成功时返回零，在错误时返回非零值。
- en: '[***Read Callbacks***](toc.html#app1.22)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[***读取回调***](toc.html#app1.22)'
- en: 'Read callbacks have the following calling parameters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调有以下调用参数：
- en: '![](../images/331-4.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/331-4.jpg)'
- en: Read callbacks are particularly useful for computing values like sums and averages.
    These values are not worth the effort to compute continuously if it’s possible
    to compute them only when the values are required.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 读取回调特别适用于计算总和和平均值等值。如果可能只在需要值时计算它们，则这些值不值得持续计算。
- en: '[***Write Callbacks***](toc.html#app1.23)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[***写入回调***](toc.html#app1.23)'
- en: Write callbacks are most applicable when tied to configuration changes. As such,
    a write callback is also a good place to log configuration changes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 写入回调最适合与配置更改相关联。因此，写入回调也是记录配置更改的好地方。
- en: Write callbacks have the same parameters as read callbacks, with the addition
    of a pointer to a copy of the row before it was modified. Access to a copy of
    the unmodified row is useful to detect changes in the row’s data. This is useful
    since some UIs can generate an UPDATE even if nothing actually changed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 写入回调具有与读取回调相同的参数，额外增加了一个指向修改前行副本的指针。访问未修改行的副本对于检测行数据的更改非常有用。这很有用，因为一些UI可以在实际上没有更改的情况下生成一个更新操作。
- en: The callback returns zero on success and nonzero on failure. On failure, the
    table’s row is restored to its initial values and an SQL error is returned to
    the client. The returned error is TRIGGERED ACTION EXCEPTION.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回调在成功时返回零，在失败时返回非零值。在失败的情况下，表的行将恢复到其初始值，并向客户端返回一个SQL错误。返回的错误是触发动作异常。
- en: 'Write callbacks have the following calling parameters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 写入回调有以下调用参数：
- en: '![](../images/332-1.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/332-1.jpg)'
