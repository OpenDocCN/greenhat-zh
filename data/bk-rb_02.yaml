- en: Chapter 2. Class Hierarchies, Attributes, and Class Variables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：类层次结构、属性和类变量
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: 'We ended the previous chapter by creating two new classes: a Thing and a Treasure.
    Despite the fact that these two classes shared some features (notably both had
    a “name”), there was no connection between them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章结束时创建了两个新的类：一个名为 Thing 和一个名为 Treasure 的类。尽管这两个类有一些共同的特征（特别是它们都有“名称”这一特征），但它们之间并没有任何联系。
- en: These two classes are so trivial that this tiny bit of repetition doesn’t really
    matter much. However, when you start writing real programs of some complexity,
    your classes will frequently contain numerous variables and methods, and you really
    don’t want to keep coding the same things over and over again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类非常简单，这种微小的重复实际上并不重要。然而，当你开始编写一些复杂程度的真实程序时，你的类将经常包含许多变量和方法，你真的不希望一遍又一遍地重复编写相同的内容。
- en: It makes sense to create a class hierarchy in which one class may be a “special
    type” of some other (ancestor) class, in which case it will automatically inherit
    the features of its ancestor. In our simple adventure game, for instance, a Treasure
    is a special type of Thing, so the Treasure class should inherit the features
    of the Thing class.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个类层次结构中，一个类可能是一个其他（祖先）类的“特殊类型”，在这种情况下，它将自动继承其祖先的特征是有意义的。例如，在我们的简单冒险游戏中，Treasure
    是 Thing 的一个特殊类型，因此 Treasure 类应该继承 Thing 类的特征。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, I will often talk about descendant classes inheriting features
    from their ancestor classes. These terms deliberately suggest a kind a family
    relationship between “related” classes. Each class in Ruby has only one parent.
    It may, however, descend from a long and distinguished family tree with many generations
    of parents, grandparents, great-grandparents, and so on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我经常会提到子类从它们的父类继承特征。这些术语故意暗示了“相关”类之间的一种家族关系。在 Ruby 中，每个类只有一个父类。然而，它可能从一条漫长而显赫的家族树中衍生出来，拥有许多代父母、祖父母、曾祖父母等等。
- en: The behavior of Things in general will be coded in the Thing class. The Treasure
    class will automatically “inherit” all the features of the Thing class, so we
    won’t need to code them all over again; it will then add some additional features,
    specific to Treasures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 事物的普遍行为将在 Thing 类中编码。Treasure 类将自动“继承” Thing 类的所有特征，因此我们不需要再次编写它们；然后它将添加一些针对
    Treasure 的特定功能。
- en: As a general rule, when creating a class hierarchy, the classes with the most
    generalized behavior are higher up the hierarchy than classes with more specialist
    behavior. So, a Thing class with just a name and a description would be the ancestor
    of a Treasure class that has a name, a description, and, additionally, a value;
    the Thing class might also be the ancestor of some other specialist class such
    as a Room that has a name, a description, and exits . . . and so on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，在创建类层次结构时，具有最通用行为的类位于层次结构的较高位置，而具有更多专业行为的类位于较低位置。因此，只有一个名称和描述的 Thing
    类将是具有名称、描述和额外价值（value）的 Treasure 类的祖先；Thing 类也可能是具有名称、描述和出口（exits）等特征的某些其他专业类（如
    Room）的祖先。
- en: One Parent, Many Children
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个父类，多个子类
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860142.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860142.png)'
- en: This diagram shows a Thing class that has a *name* and a *description* (in a
    Ruby program, these might be internal variables such as `@name` and `@description`
    plus some methods to access them). The Treasure and Room classes both descend
    from the Thing class, so they automatically “inherit” a *name* and a *description*.
    The Treasure class adds one new item, *value*, so it now has *name*, *description*,
    and *value*. The Room class adds *exits*—so it has *name*, *description*, and
    *exits*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了一个具有 *name* 和 *description*（在 Ruby 程序中，这些可能是内部变量，如 `@name` 和 `@description`，以及一些访问它们的方法）的
    Thing 类。Treasure 和 Room 类都从 Thing 类派生出来，因此它们自动“继承”了 *name* 和 *description*。Treasure
    类添加了一个新项目 *value*，因此现在它具有 *name*、*description* 和 *value*。Room 类添加了 *exits*——因此它具有
    *name*、*description* 和 *exits*。
- en: Let’s see how to create a descendant class in Ruby. Load the *1adventure.rb*
    program. This starts simply enough with the definition of a Thing class, which
    has two instance variables, `@name` and `@description`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 Ruby 中创建一个子类。加载 *1adventure.rb* 程序。它从定义一个具有两个实例变量 `@name` 和 `@description`
    的 Thing 类开始。
- en: '*1adventure.rb*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*1adventure.rb*'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@name` and `@description` variables are assigned values in the `initialize`
    method when a new Thing object is created. Instance variables generally cannot
    (and should not) be directly accessed from the world outside the class itself,
    because of the principle of encapsulation (as explained in the previous chapter).
    To obtain the value of each variable, you need a *get* accessor method such as
    `get_name`; in order to assign a new value, you need a *set* accessor method such
    as `set_name`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的 Thing 对象时，`@name` 和 `@description` 变量在 `initialize` 方法中被赋值。实例变量通常不能（也不应该）从类本身之外直接访问，这是封装原则（如前一章所述）的结果。要获取每个变量的值，你需要一个
    *get* 访问器方法，如 `get_name`；要分配新值，你需要一个 *set* 访问器方法，如 `set_name`。
- en: Superclasses and Subclasses
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超类和子类
- en: 'Now look at the Treasure class, which is also defined in the following program:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看 Treasure 类，它也在下面的程序中定义：
- en: '*1adventure.rb*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*1adventure.rb*'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice how the Treasure class is declared:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Treasure 类是如何声明的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The left angle bracket (`<`) indicates that Treasure is a *subclass*, or descendant,
    of Thing, and therefore it inherits the data (variables) and behavior (methods)
    from the Thing class. Since the methods `get_name`, `set_name`, `get_description`,
    and `set_description` already exist in the ancestor class (Thing), these methods
    don’t need to be recoded in the descendant class (Treasure).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 左尖括号 (`<`) 表示 Treasure 是 Thing 的 *子类* 或后代，因此它继承了数据（变量）和行为（方法）。由于 `get_name`、`set_name`、`get_description`
    和 `set_description` 这些方法已经在祖先类（Thing）中存在，因此这些方法不需要在后代类（Treasure）中重新编码。
- en: 'The Treasure class has one additional piece of data, its value (`@value`),
    and I have written *get* and *set* accessors for this. When a new Treasure object
    is created, its `initialize` method is automatically called. A Treasure has three
    variables to initialize (`@name`, `@description`, and `@value`), so its `initialize`
    method takes three arguments. The first two arguments are passed, using the `super`
    keyword, to the `initialize` method of the superclass (Thing) so that the Thing
    class’s `initialize` method can deal with them:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Treasure 类有一项额外的数据，即它的价值 (`@value`)，我为它编写了 *get* 和 *set* 访问器。当创建一个新的 Treasure
    对象时，它的 `initialize` 方法会自动被调用。Treasure 有三个变量需要初始化 (`@name`，`@description` 和 `@value`)，因此它的
    `initialize` 方法接受三个参数。前两个参数使用 `super` 关键字传递给超类（Thing）的 `initialize` 方法，这样 Thing
    类的 `initialize` 方法就可以处理它们：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When used inside a method, the `super` keyword calls a method with the same
    name as the current method in the ancestor or *super*class. If the `super` keyword
    is used on its own, without any arguments being specified, all the arguments sent
    to the current method are passed to the ancestor method. If, as in the present
    case, a specific list of arguments (here `aName` and `aDescription`) is supplied,
    then only these are passed to the method of the ancestor class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当在方法内部使用时，`super` 关键字调用与当前方法同名的祖先或*超*类中的方法。如果单独使用 `super` 关键字，没有指定任何参数，则将发送到当前方法的全部参数传递给祖先方法。如果在当前情况下，提供了一个特定的参数列表（这里为
    `aName` 和 `aDescription`），则只有这些参数会被传递给祖先类的该方法。
- en: Passing Arguments to the Superclass
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向超类传递参数
- en: 'Parentheses matter when calling the superclass! If the argument list is empty
    and no parentheses are used, *all* arguments are passed to the superclass. But
    if the argument list is empty and parentheses are used, *no* arguments are passed
    to the superclass:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用超类时括号很重要！如果参数列表为空且没有使用括号，*所有*参数都会传递给超类。但如果参数列表为空且使用了括号，则*不会*向超类传递任何参数：
- en: '*super_args.rb*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*super_args.rb*'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To gain a better understanding of the use of `super`, see [Digging Deeper](ch02s06.html#digging_deeper-id1
    "Digging Deeper") in [Digging Deeper](ch02s06.html#digging_deeper-id1 "Digging
    Deeper").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解 `super` 的使用，请参阅 [深入挖掘](ch02s06.html#digging_deeper-id1 "深入挖掘") 中的 [深入挖掘](ch02s06.html#digging_deeper-id1
    "深入挖掘")。
- en: Accessor Methods
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问器方法
- en: Although the classes in this would-be adventure game work well enough, they
    are still fairly verbose because of all those *get* and *set* accessors. Let’s
    see what you can do to remedy this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个假想冒险游戏中的类工作得足够好，但由于所有那些 *get* 和 *set* 访问器，它们仍然相当冗长。让我们看看你能做些什么来解决这个问题。
- en: 'Instead of accessing the value of the `@description` instance variable with
    two different methods, `get_description` and `set_description`, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用两个不同的方法，`get_description` 和 `set_description`，像这样访问 `@description` 实例变量的值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'it would be so much nicer to retrieve and assign values just as you would retrieve
    and assign values to and from a simple variable, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样检索和分配值会方便得多，就像从简单变量中检索和分配值一样，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To be able to do this, you need to modify the Treasure class definition. One
    way of accomplishing this would be to rewrite the accessor methods for `@description`
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够这样做，你需要修改 Treasure 类的定义。实现这一目标的一种方法是将 `@description` 的访问器方法重写如下：
- en: '*accessors1.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*accessors1.rb*'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I have added accessors similar to these in the *accessors1.rb* program. Here,
    the *get* accessor is called `description`, and the *set* accessor is called `description=`
    (that is, it appends an equals sign to the method name used by the corresponding
    *get* accessor). It is now possible to assign a new string like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在 *accessors1.rb* 程序中添加了类似的访问器。在这里，*get* 访问器被命名为 `description`，而 *set* 访问器被命名为
    `description=`（即，在对应 *get* 访问器使用的名称后附加一个等号）。现在可以像这样分配一个新的字符串：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And you can retrieve the value like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样检索值：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that when you write a *set* accessor in this way, you must append the
    `=` character to the method name, not merely place it somewhere between the method
    name and the arguments. In other words, this is correct:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你以这种方式编写 *set* 访问器时，你必须将 `=` 字符附加到方法名上，而不仅仅是将其放在方法名和参数之间。换句话说，这是正确的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'but this results in an error:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会导致错误：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Attribute Readers and Writers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性读取器和写入器
- en: 'In fact, there is a simpler and shorter way of creating a pair of *get* and
    *set* accessors simultaneously. All you have to do is use two special methods,
    `attr_reader` and `attr_writer`, followed by a *symbol* (a name preceded by a
    colon):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有一种更简单、更短的方法可以同时创建一对 *get* 和 *set* 访问器。你只需要使用两个特殊方法，`attr_reader` 和 `attr_writer`，后面跟着一个
    *symbol*（一个以冒号开头的名称）：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should add this code inside your class definition like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该像这样在你的类定义中添加此代码：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling `attr_reader` with a symbol has the effect of creating a *get* accessor
    (here named `description`) for an instance variable (`@description`) with a name
    matching the symbol (`:description`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号调用 `attr_reader` 会创建一个 *get* 访问器（这里命名为 `description`），用于与符号匹配的实例变量（`@description`）。
- en: Calling `attr_writer` similarly creates a *set* accessor for an instance variable.
    Instance variables are considered to be the “attributes” of an object, which is
    why the `attr_reader` and `attr_writer` methods are so named.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地调用 `attr_writer` 会为实例变量创建一个 *set* 访问器。实例变量被认为是对象的“属性”，这就是为什么 `attr_reader`
    和 `attr_writer` 方法被这样命名的原因。
- en: What Is a Symbol?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是符号？
- en: In Ruby, a *symbol* is a name preceded by a colon (for example, `:description`).
    The Symbol class is defined in the Ruby class library to represent names inside
    the Ruby interpreter. When you pass one or more symbols as arguments to `attr_reader`
    (which is a method of the Module class), Ruby creates an instance variable and
    a *get* accessor method. This accessor method returns the value of the corresponding
    variable; both the instance variable and the accessor method will take the name
    that was specified by the symbol. So, `attr_reader( :description )` creates an
    instance variable with the name, `@description`, and an accessor method named
    `description()`. Symbols are discussed in detail in [Chapter 11](ch11.html "Chapter 11. Symbols").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，一个 *symbol* 是一个以冒号开头的名称（例如，`:description`）。Symbol 类在 Ruby 类库中定义，用于在
    Ruby 解释器内部表示名称。当你将一个或多个符号作为参数传递给 `attr_reader`（这是 Module 类的一个方法）时，Ruby 会创建一个实例变量和一个
    *get* 访问器方法。这个访问器方法返回相应变量的值；实例变量和访问器方法都将采用符号指定的名称。符号将在 [第 11 章](ch11.html "第 11
    章。符号") 中详细讨论。
- en: 'The *accessors2.rb* program contains some examples of attribute readers and
    writers in action. This is its version of the Thing class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*accessors2.rb* 程序包含了一些属性读取器和写入器在实际操作中的示例。这是它的 Thing 类版本：'
- en: '*accessors2.rb*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*accessors2.rb*'
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here the Thing class explicitly defines a *get* method accessor for the `@name`
    attribute. The advantage of writing a complete method like this is that it gives
    you the opportunity to do some extra processing rather than simply reading and
    writing an attribute value. The *get* accessor, `name` ![](httpatomoreillycomsourcenostarchimages860154.png),
    uses the `String.capitalize` method to return the string value of `@name` with
    its initial letter in uppercase.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Thing`类明确地为`@name`属性定义了一个*get*方法访问器。编写这样一个完整方法的优点是，它给你提供了做一些额外处理的机会，而不仅仅是读取和写入属性值。*get*访问器`name`
    ![http://atomoreilly.com/source/nostarch/images/860154.png] 使用`String.capitalize`方法将`@name`的字符串值的首字母转换为大写。
- en: When assigning a value to the `@name` attribute, I don’t need to do any special
    processing, so I have given it an attribute writer instead of a `set` accessor
    method ![](httpatomoreillycomsourcenostarchimages860150.png).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当为`@name`属性赋值时，我不需要做任何特殊处理，因此我给它提供了一个属性写入器而不是`set`访问器方法 ![http://atomoreilly.com/source/nostarch/images/860150.png]。
- en: The `@description` attribute needs no special processing at all, so I use `attr_reader`
    and `attr_writer` instead of accessor methods in order to get and set the value
    of the `@description` variable ![](httpatomoreillycomsourcenostarchimages860146.png).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`@description`属性根本不需要任何特殊处理，所以我使用`attr_reader`和`attr_writer`而不是访问器方法来获取和设置`@description`变量的值
    ![http://atomoreilly.com/source/nostarch/images/860146.png]。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Are they attributes or properties? Don’t be confused by the terminology. In
    Ruby, an *attribute* is the equivalent of what many programming languages call
    a *property*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是属性还是属性？不要被术语搞混。在Ruby中，*属性*相当于许多编程语言中称为*属性*的东西。
- en: 'When you want both to read and to write a variable, the `attr_accessor` method
    provides a shorter alternative than using both `attr_reader` and `attr_writer`.
    I have used this to access the value attribute in the Treasure class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想同时读取和写入一个变量时，`attr_accessor`方法比同时使用`attr_reader`和`attr_writer`提供更简短的替代方案。我就是这样在`Treasure`类中访问值属性的：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is equivalent to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于以下内容：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Earlier I said that calling `attr_reader` with a symbol actually creates a variable
    with the same name as the symbol. The `attr_accessor` method also does this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，使用符号调用`attr_reader`实际上创建了一个与符号同名变量。`attr_accessor`方法也这样做。
- en: 'In the code for the Thing class, this behavior is not obvious since the class
    has an `initialize` method that explicitly creates the variables. The Treasure
    class, however, makes no reference to the `@value` variable in its `initialize`
    method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Thing`类的代码中，这种行为并不明显，因为该类有一个`initialize`方法，它明确创建了变量。然而，`Treasure`类在其`initialize`方法中并没有引用`@value`变量：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only indication that `@value` exists at all is this accessor definition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`@value`存在唯一的指示是此访问器定义：'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'My code at the bottom of the *accessors2.rb* source file sets the value of
    each Treasure object as a separate operation, following the creation of the object
    itself, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`accessors2.rb`源文件底部的代码将每个`Treasure`对象的值设置为单独的操作，在创建对象本身之后进行，如下所示：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Even though it has never been formally declared, the `@value` variable really
    does exist, and you are able to retrieve its numerical value using the *get* accessor:
    `t1.value`. To be absolutely certain that the attribute accessor really has created
    `@value`, you can always look inside the object using the `inspect` method. I
    have done so in the final two code lines in this program:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它从未被正式声明，`@value`变量确实存在，你可以使用*get*访问器`t1.value`来检索其数值。为了确保属性访问器确实创建了`@value`，你总是可以使用`inspect`方法查看对象内部。我在这个程序的最后两行代码中就是这样做的：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This displays the data inside the t1 and t2 objects, including the `@value`
    variables:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了`t1`和`t2`对象内部的数据，包括`@value`变量：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Attribute accessors can initialize more than one attribute at a time if you
    send them a list of symbols separated by commas, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向属性访问器发送一个由逗号分隔的符号列表，它可以同时初始化多个属性，如下所示：
- en: '*accessors3.rb*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*accessors3.rb*'
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As always, parentheses around the arguments are optional but, in my view (for
    reasons of clarity), are to be preferred.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，括号内的参数是可选的，但在我看来（出于清晰度的原因），最好是使用括号。
- en: 'Now let’s see how to put attribute readers and writers to use in my adventure
    game. Load the *2adventure.rb* program. You will see that I have created two readable
    attributes in the Thing class: `name` and `description`. I have also made `description`
    writeable; however, because I don’t plan to change the names of any Thing objects,
    the `name` attribute is not writeable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在冒险游戏中使用属性读取器和写入器。加载*2adventure.rb*程序。你会看到我在`Thing`类中创建了两个可读属性：`name`和`description`。我还使`description`可写；然而，因为我没有计划更改任何`Thing`对象的名称，所以`name`属性是不可写的：
- en: '*2adventure.rb*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*2adventure.rb*'
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I have created a method called `to_s`, which returns a string describing the
    Treasure object. Recall that all Ruby classes have a `to_s` method as standard.
    The `Thing.to_s` method overrides (and replaces) the default one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个名为`to_s`的方法，它返回一个描述`Treasure`对象的字符串。回想一下，所有Ruby类都有一个标准`to_s`方法。`Thing.to_s`方法覆盖（并替换）了默认的方法。
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can override existing methods when you want to implement new behavior appropriate
    to the specific class type.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想实现适合特定类类型的新行为时，你可以覆盖现有方法。
- en: Calling Methods of a Superclass
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用超类的方法
- en: 'The game in *2adventure.rb* will have two classes descending from Thing: the
    Treasure class and the Room class. The Treasure class adds a `value` attribute,
    which can be both read and written. Note that its `initialize` method calls its
    superclass in order to initialize the `name` and `description` attributes before
    initializing the new `@value` variable:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在*2adventure.rb*中的游戏将有两个从`Thing`派生的类：`Treasure`类和`Room`类。`Treasure`类添加了一个`value`属性，它可以被读取和写入。注意，它的`initialize`方法在初始化新的`@value`变量之前调用了其超类，以初始化`name`和`description`属性：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, if I had omitted the call to the superclass, the `name` and `description`
    attributes would never be initialized. This is because `Treasure.initialize` overrides
    `Thing.initialize`, so when a Treasure object is created, the code in `Thing.initialize`
    will *not* automatically be executed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我省略了对超类的调用，`name`和`description`属性将永远不会被初始化。这是因为`Treasure.initialize`覆盖了`Thing.initialize`，所以当创建一个`Treasure`对象时，`Thing.initialize`中的代码将*不会*自动执行。
- en: On the other hand, the Room class, which also descends from Thing, currently
    has no `initialize` method, so when a new Room object is created, Ruby goes scrambling
    back up the class hierarchy in search of one. The first `initialize` method it
    finds is in Thing, so a Room object’s `name` and `description` attributes are
    initialized there.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也继承自`Thing`的`Room`类目前没有`initialize`方法，所以当创建一个新的`Room`对象时，Ruby会向上搜索类层次结构以找到它。它找到的第一个`initialize`方法是在`Thing`中，因此`Room`对象的`name`和`description`属性在那里被初始化。
- en: Class Variables
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类变量
- en: 'A few other interesting things are going on in this program. Right at the top
    of the Thing class you will see this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中还有一些其他有趣的事情正在发生。在`Thing`类的最顶部，你会看到这个：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The two `@` characters at the start of this variable name, `@@num_things`, define
    this to be a *class variable*. The variables we’ve used inside classes up to now
    have been instance variables, preceded by a single `@`, like `@name`. Whereas
    each new object (or instance) of a class assigns its own values to its own instance
    variables, all objects derived from a specific class share the same class variables.
    I have assigned 0 to the `@@num_things` variable to ensure that it has a meaningful
    value at the outset.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量名`@@num_things`开头的两个`@`字符定义了这个变量为*类变量*。我们到目前为止在类内部使用的变量都是实例变量，前面有一个`@`，比如`@name`。而每个新对象（或实例）都会为其自己的实例变量分配自己的值，而所有从特定类派生的对象都共享相同的类变量。我已经将`@@num_things`变量赋值为0，以确保它有一个有意义的初始值。
- en: 'Here, the `@@num_things` class variable is used to keep a running total of
    the number of Thing objects in the game. It does this simply by incrementing the
    class variable (by adding 1 to it: `+= 1`) in its `initialize` method every time
    a new object is created:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`@@num_things`类变量被用来跟踪游戏中`Thing`对象的总数。它通过在每次创建新对象时在其`initialize`方法中增加类变量（通过给它加1：`+=
    1`）来实现这一点：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you look later in the code, you will see that I have created a Map class
    to contain an array of rooms. This includes a version of the `to_s` method that
    prints information on each room in the array. Don’t worry about the implementation
    of the Map class right now; we’ll be looking at arrays and their methods in [Chapter 4](ch04.html
    "Chapter 4. Arrays and Hashes").
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你稍后查看代码，你会看到我创建了一个Map类来包含一个房间数组。这包括一个`to_s`方法的版本，它会打印数组中每个房间的信息。现在不必担心Map类的实现；我们将在[第4章](ch04.html
    "第4章。数组和哈希")中查看数组和它们的方法。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Scroll to the code at the bottom of the file, and run the program to see how
    I have created and initialized all the objects and used the class variable, `@@num_things`,
    to keep a tally of all the Thing objects that have been created.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到文件底部的代码，并运行程序以查看我是如何创建和初始化所有对象以及使用类变量`@@num_things`来记录已创建的所有Thing对象的数量。
- en: Class Variables and Instance Variables
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量和实例变量
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860158.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860158.png)'
- en: This diagram shows a Thing class (the rectangle) that contains a class variable,
    `@@num_things`, and an instance variable, `@name`. The three oval shapes represent
    “Thing objects”—that is, instances of the Thing class. When one of these objects
    assigns a value to its instance variable, `@name`, that value affects only the
    `@name` variable in the object itself. So here, each object has a different value
    for `@name`. But when an object assigns a value to the class variable, `@@num_things`,
    that value “lives inside” the Thing class and is shared by all instances of that
    class. Here `@@num_things` equals 3, and that is true for all the Thing objects.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了包含一个类变量`@@num_things`和一个实例变量`@name`的Thing类（矩形）。三个椭圆形代表“Thing对象”——即Thing类的实例。当这些对象中的任何一个将其实例变量`@name`赋值时，该值只会影响对象本身的`@name`变量。所以在这里，每个对象的`@name`值都不同。但是，当一个对象将值赋给类变量`@@num_things`时，该值“存在于”Thing类中，并且被该类的所有实例共享。在这里，`@@num_things`等于3，这对于所有Thing对象都是正确的。
- en: Digging Deeper
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Every class you create will descend from one or more other classes. Here I explain
    the fundamentals of the Ruby class hierarchy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个类都将从一个或多个其他类继承。在这里，我解释了Ruby类层次结构的基本原理。
- en: Superclasses
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 超类
- en: To understand how the `super` keyword works, take a look at the sample program
    *super.rb*. This contains five related classes. The Thing class is the ancestor
    of all the others, and from Thing descends Thing2, from Thing2 descends Thing3,
    from Thing3 descends Thing4, and from Thing4 descends Thing5.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`super`关键字的工作原理，请查看示例程序*super.rb*。这个程序包含五个相关的类。Thing类是所有其他类的祖先，从Thing派生出Thing2，从Thing2派生出Thing3，从Thing3派生出Thing4，从Thing4派生出Thing5。
- en: '*super.rb*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*super.rb*'
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s take a closer look at the first three classes in this hierarchy: The
    Thing class has two instance variables, `@name` and `@description`. Thing2 also
    defines `@fulldescription` (a string that contains `@name` and `@description`);
    Thing3 adds yet another variable, `@value`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个层次结构中的前三个类：Thing类有两个实例变量，`@name`和`@description`。Thing2还定义了`@fulldescription`（一个包含`@name`和`@description`的字符串）；Thing3又添加了一个变量`@value`。
- en: These three classes each contain an `initialize` method that sets the values
    of the variables when a new object is created; they also each have a method named,
    rather inventively, `aMethod`, which changes the value of one or more variables.
    The descendant classes, Thing2 and Thing3, both use the `super` keyword in their
    methods.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类各自包含一个`initialize`方法，用于在创建新对象时设置变量的值；它们各自还有一个名为“aMethod”的方法，该方法会更改一个或多个变量的值。派生类Thing2和Thing3在其方法中都使用了`super`关键字。
- en: 'At the bottom of this code unit I’ve written a “main” loop that executes when
    you run the program. Don’t worry about the syntax of this; you’ll be learning
    about loops in [Chapter 5](ch05.html "Chapter 5. Loops and Iterators"). I’ve added
    this loop so that you can easily run the different bits of code contained in the
    methods, `test1` to `test5`. You can run the program in a command window and enter
    a number, 1 to 5, when prompted, or Q to quit. When you run it for the first time,
    type **`1`** at the prompt and press the enter key. This will run the `test1`
    method containing these two lines of code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码单元的底部，我编写了一个“主循环”，当你运行程序时它会执行。不用担心这个循环的语法；你将在第 [5章](ch05.html "第5章。循环和迭代器")
    中学习关于循环的内容。我添加这个循环是为了让你能够轻松运行方法中包含的不同代码片段，从 `test1` 到 `test5`。你可以在命令窗口中运行程序，当提示时输入一个数字，1
    到 5，或者输入 Q 退出。当你第一次运行时，在提示符下输入 **`1`** 并按回车键。这将运行包含这两行代码的 `test1` 方法：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The first line here creates and initializes a Thing object, and the second
    line calls its `aMethod` method. Because the Thing class doesn’t descend from
    anything special, nothing very new or interesting happens here. In fact, as with
    all Ruby classes, Thing descends from the Object class, which is the ancestor
    of all other classes (with the sole exception of the BasicObject class in Ruby
    1.9, as explained later in this chapter). The output uses the `inspect` method
    to display the internal structure of the object when the `Thing.initialize` and
    `Thing.aMethod` methods are called. This is the result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第一行创建并初始化了一个 Thing 对象，第二行调用它的 `aMethod` 方法。因为 Thing 类没有从特殊的东西继承，所以这里没有发生什么非常新或有趣的事情。事实上，与所有
    Ruby 类一样，Thing 从 Object 类继承，Object 类是所有其他类的祖先（唯一的例外是 Ruby 1.9 中的 BasicObject 类，如本章后面所述）。输出使用
    `inspect` 方法在调用 `Thing.initialize` 和 `Thing.aMethod` 方法时显示对象的内部结构。这是结果：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `inspect` method can be used with all objects and is an invaluable debugging
    aid. Here, it shows a hexadecimal number, which identifies this specific object
    followed by the string values of the `@name` and `@description` variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect` 方法可以与所有对象一起使用，并且是一个非常有价值的调试辅助工具。在这里，它显示一个十六进制数，该数标识了特定的对象，后面跟着 `@name`
    和 `@description` 变量的字符串值。'
- en: 'Now enter **`2`** at the prompt to run `test2`, which contains the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在提示符下输入 **`2`** 来运行 `test2`，它包含以下代码：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This creates a Thing2 object, t2, and calls `t2.aMethod`. Look carefully at
    the output. You will see that even though t2 is a Thing2 object, it is the Thing
    class’s `initialize` method that is called first. And only then is the Thing2
    class’s `initialize` called.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个 Thing2 对象 t2，并调用 `t2.aMethod`。仔细观察输出。你会看到，尽管 t2 是一个 Thing2 对象，但首先调用的是
    Thing 类的 `initialize` 方法。然后才是 Thing2 类的 `initialize` 被调用。
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To understand why this is so, look at the code of the Thing2 class’s `initialize`
    method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么是这样，请查看 Thing2 类的 `initialize` 方法的代码：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This uses the `super` keyword to call the `initialize` method of Thing2’s ancestor,
    or *superclass*. The superclass of Thing2 is Thing, as you can see from its declaration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 `super` 关键字来调用 Thing2 的祖先或超类的 `initialize` 方法。如你所见，Thing2 的超类是 Thing：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In Ruby, when the `super` keyword is used on its own (that is, without any
    arguments), it passes all the arguments from the current method (here `Thing2.initialize`)
    to a method with the same name in its superclass (here `Thing.initialize`). Alternatively,
    you can explicitly specify a list of arguments following `super`. So, in this
    case, the following code would have the same effect:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，当单独使用 `super` 关键字（即不带任何参数）时，它会将当前方法（此处为 `Thing2.initialize`）的所有参数传递给其超类中具有相同名称的方法（此处为
    `Thing.initialize`）。或者，你可以在 `super` 后面显式指定一个参数列表。因此，在这种情况下，以下代码会产生相同的效果：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Although it is permissible to use the `super` keyword all on its own, it is
    often preferable to explicitly specify the list of arguments to be passed to the
    superclass, for the sake of clarity. If you want to pass only a limited number
    of the arguments sent to the current method, an explicit argument list is necessary.
    Thing2’s `aMethod`, for example, passes only the `aName` argument to the `initialize`
    method of its superclass, Thing1:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单独使用 `super` 关键字是允许的，但为了清晰起见，通常最好明确指定传递给超类的参数列表。如果你只想传递当前方法收到的有限数量的参数，则需要一个显式的参数列表。例如，Thing2
    的 `aMethod` 方法只将 `aName` 参数传递给其超类 Thing1 的 `initialize` 方法：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This explains why the `@description` variable is not changed when `Thing2.aMethod`
    is called.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了为什么在调用 `Thing2.aMethod` 时，`@description` 变量不会被改变。
- en: Now if you look at Thing3, you will see that this adds one more variable, `@value`.
    In its implementation of `initialize`, it passes the two arguments, `aName` and
    `aDescription`, to its superclass, Thing2\. In its turn, as you’ve already seen,
    Thing2’s `initialize` method passes these same arguments to the `initialize` method
    of its superclass, Thing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你查看 Thing3，你会看到这增加了一个变量，`@value`。在其 `initialize` 方法的实现中，它将两个参数，`aName` 和
    `aDescription`，传递给其超类 Thing2。然后，正如你已经看到的，Thing2 的 `initialize` 方法将这些相同的参数传递给其超类的
    `initialize` 方法，即 Thing。
- en: 'With the program running, enter **`3`** at the prompt to view the output. The
    following code will execute:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，在提示符处输入 **`3`** 以查看输出。以下代码将被执行：
- en: '[PRE38]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note how the flow of execution goes right up the hierarchy so that code in the
    `initialize` and `aMethod` methods of Thing execute before code in the matching
    methods of Thing2 and Thing3.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意执行流程是如何直接沿着层次结构向上，使得 Thing 的 `initialize` 和 `aMethod` 方法中的代码在 Thing2 和 Thing3
    中匹配的方法之前执行。
- en: It is not obligatory to override a superclass’s methods as I have done in the
    examples so far. This is required only when you want to add some new behavior.
    Thing4 omits the `initialize` method but implements the `aMethod` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要像我在前面的例子中所做的那样覆盖超类的方法。这只有在你想添加一些新行为时才是必需的。Thing4 省略了 `initialize` 方法，但实现了
    `aMethod` 方法。
- en: 'Enter **`4`** at the prompt to execute the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符处输入 **`4`** 以执行以下代码：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When you run it, notice that the first available `initialize` method is called
    when a Thing4 object is created. This happens to be `Thing3.initialize`, which,
    once again, also calls the `initialize` methods of its ancestor classes, Thing2
    and Thing. However, the `aMethod` method implemented by Thing4 contains no call
    to its superclasses, so this executes right away, and the code in any other `aMethod`
    methods in the ancestor classes is ignored:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，请注意，当创建 Thing4 对象时，将调用第一个可用的 `initialize` 方法。这恰好是 `Thing3.initialize`，它再次调用其祖先类
    Thing2 和 Thing 的 `initialize` 方法。然而，Thing4 实现的 `aMethod` 方法没有调用其超类，所以它立即执行，并且忽略祖先类中任何其他
    `aMethod` 方法中的代码：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, Thing5 inherits from Thing4 and doesn’t introduce any new data or
    methods. Enter **`5`** at the prompt to execute the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Thing5 从 Thing4 继承而来，没有引入任何新的数据或方法。在提示符处输入 **`5`** 以执行以下操作：
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This time, you will see that the call to `new` causes Ruby to backtrack through
    the class hierarchy until it finds the first `initialize` method. This happens
    to belong to Thing3 (which also calls the `initialize` methods of Thing2 and Thing).
    The first implementation of `aMethod`, however, occurs in Thing4, and there are
    no calls to `super`, so that’s where the trail ends.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，你会看到对 `new` 的调用导致 Ruby 回溯到类层次结构，直到找到第一个 `initialize` 方法。这个方法恰好属于 Thing3（它也调用了
    Thing2 和 Thing 的 `initialize` 方法）。然而，`aMethod` 的第一个实现发生在 Thing4 中，并且没有调用 `super`，所以追踪就结束了。
- en: The Root of All Classes
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类的根源
- en: As I mentioned earlier, all our Ruby classes will ultimately descend from the
    Object class. You may think of Object as the “root” or “base” class of the Ruby
    hierarchy. In Ruby 1.8 this is literally true—there are no classes from which
    Object itself descends. In Ruby 1.9, however, Object is derived from a new class
    called BasicObject. This new class was created to provide programmers with a very
    lightweight class—one that supplies only the bare minimum of methods for creating
    objects, testing equality, and manipulating special methods called *singletons*.
    (I’ll talk more about singletons in [Chapter 7](ch07.html "Chapter 7. Methods").)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，我们所有的 Ruby 类最终都将从 Object 类派生。你可以把 Object 视为 Ruby 层次结构的“根”或“基础”类。在 Ruby
    1.8 中，这确实是真实的——没有类是从 Object 本身派生的。然而，在 Ruby 1.9 中，Object 是从一个新的类 BasicObject 派生的。这个新类是为了给程序员提供一个非常轻量级的类——它只提供创建对象、测试相等性和操作称为
    *单例* 的特殊方法所需的最基本的方法。（我将在第 7 章[第 7 章](ch07.html "第 7 章。方法")中更多地讨论单例。）
- en: The Ruby 1.9 Object class inherits the methods from BasicObject and adds a number
    of new methods of its own. BasicObject does not exist in Ruby 1.8, and the Object
    class supplies all the methods provided by the combination of BasicObject and
    Object in Ruby 1.9\. Since all normal Ruby classes—both Ruby 1.8 and Ruby 1.9—descend
    from Object, you may generally think of Object as being the “root” of all other
    classes. Just bear in mind that in Ruby 1.9, the ultimate ancestor of all classes
    is BasicObject.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 的 Object 类从 BasicObject 继承方法，并添加了一些自己的新方法。BasicObject 在 Ruby 1.8 中不存在，Object
    类提供了 Ruby 1.9 中 BasicObject 和 Object 组合提供的所有方法。由于所有正常的 Ruby 类（包括 Ruby 1.8 和 Ruby
    1.9）都从 Object 继承，您通常可以将 Object 视为所有其他类的“根”。只需记住，在 Ruby 1.9 中，所有类的最终祖先都是 BasicObject。
- en: The root class itself has no superclass, and any attempt to locate its superclass
    will return `nil`. You can see this for yourself by running *superclasses.rb*.
    This calls the `superclass` method to climb up the class hierarchy from the Three
    class to the Object or BasicObject class. At each turn through the loop, the variable
    `x` is assigned the class of `x`’s immediate parent until `x` equals `nil`. Here
    `class` and `superclass` are methods that return references to Ruby classes rather
    than to objects created from those classes. The `begin..until` block is one of
    Ruby’s looping constructs, which you’ll look at in more detail in [Chapter 5](ch05.html
    "Chapter 5. Loops and Iterators").
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 根类本身没有超类，任何尝试定位其超类的操作都将返回 `nil`。您可以通过运行 *superclasses.rb* 来亲自查看这一点。这个脚本调用 `superclass`
    方法从 Three 类向上遍历到 Object 或 BasicObject 类。在循环的每次迭代中，变量 `x` 被分配给 `x` 的直接父类的类，直到 `x`
    等于 `nil`。在这里，`class` 和 `superclass` 是返回 Ruby 类引用的方法，而不是从这些类创建的对象。`begin..until`
    块是 Ruby 的循环结构之一，您将在第 5 章中更详细地了解它。[第 5 章](ch05.html "第 5 章。循环和迭代器")。
- en: '*superclasses.rb*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*superclasses.rb*'
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The previous code displays the following output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码显示了以下输出：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Constants Inside Classes
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的常量
- en: 'There may be times when you need to access constants (identifiers beginning
    with a capital letter, which are used to store nonchanging values) declared inside
    a class. Let’s assume you have this class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能需要访问在类内部声明的常量（以大写字母开头的标识符，用于存储不变的值）。假设您有这个类：
- en: '*classconsts.rb*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*classconsts.rb*'
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To access the constant `A`, you would need to use the special scope resolution
    operator `::` like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问常量 `A`，您需要使用特殊的范围解析运算符 `::`，如下所示：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Class names are constants, so this same operator gives you access to classes
    inside other classes. This makes it possible to create objects from “nested” classes
    such as class `Y` inside class `X`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类名是常量，因此这个运算符同样可以让你访问其他类内部的类。这使得从“嵌套”类（如类 `Y` 在类 `X` 内部）创建对象成为可能：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Partial Classes
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类
- en: In Ruby it is not obligatory to define a class all in one place. If you want,
    you can define a single class in separate parts of your program. When a class
    descends from a specific superclass, each subsequent partial (or *open*) class
    definition may optionally repeat the superclass in its definition using the `<`
    operator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，定义一个类并不一定要在一个地方完成。如果您愿意，可以在程序的各个部分定义单个类。当一个类从特定的超类继承时，每个后续的部分（或 *开放*）类定义可以可选地使用
    `<` 运算符在其定义中重复超类。
- en: 'Here I create one class, A, and another that descends from it, B:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个类 A，以及从它继承的另一个类 B：
- en: '*partial_classes.rb*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*partial_classes.rb*'
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, if I create a B object, all the methods of both A and B are available
    to it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果创建一个 B 对象，它将可以使用 A 和 B 的所有方法：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can also use partial class definitions to add features to Ruby’s standard
    classes such as Array:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用部分类定义来向 Ruby 的标准类（如 Array）添加功能：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This adds the `gribbit` method to the Array class so that the following code
    can now be executed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `gribbit` 方法添加到 Array 类中，因此现在可以执行以下代码：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
