- en: Chapter 16. Meterpreter Scripting
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章。Meterpreter脚本编程
- en: Metasploit’s powerful scripting environment lets you add features or options
    to Meterpreter. In this chapter, you’ll learn the basics of Meterpreter scripting,
    some useful native calls, and learn how to run these commands from within Meterpreter.
    We’ll cover two ways to leverage Meterpreter scripting. The first method is somewhat
    outdated but still important, because not all scripts have been converted. The
    second method is nearly identical to the one discussed in [Chapter 13](part0017.html#building_your_own_module),
    so we won’t cover it in detail in this chapter. (Special thanks to Carlos Perez
    [darkoperator] for his contributions to this chapter.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Metasploit强大的脚本环境允许你向Meterpreter添加功能或选项。在本章中，你将学习Meterpreter脚本的基础知识，一些有用的本地调用，以及如何在Meterpreter内部运行这些命令。我们将介绍两种利用Meterpreter脚本的方法。第一种方法有些过时，但仍然很重要，因为并非所有脚本都已转换。第二种方法几乎与第13章中讨论的方法相同，因此我们不会在本章中详细说明。（特别感谢Carlos
    Perez [darkoperator]对这一章的贡献。）
- en: Meterpreter Scripting Basics
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meterpreter脚本编程基础
- en: All Meterpreter scripts are located under the Framework root under *scripts/meterpreter/*.
    To show a listing of all scripts, press the tab key in a Meterpreter shell, enter
    **`run`**, and press tab again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Meterpreter脚本都位于Framework根目录下的*scripts/meterpreter/*下。要显示所有脚本的列表，在Meterpreter外壳中按Tab键，输入**`run`**，然后再次按Tab键。
- en: 'Let’s dissect a simple Meterpreter script and then build our own. We’ll explore
    the `multi_meter_inject` script that injects Meterpreter shells into different
    processes. To begin, take a look at this script in Meterpreter to see what flags
    and syntax are included:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析一个简单的Meterpreter脚本，然后构建我们自己的。我们将探索`multi_meter_inject`脚本，该脚本将Meterpreter外壳注入到不同的进程中。首先，查看Meterpreter中的此脚本，以了解包含哪些标志和语法：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first option is the `-m` flag ![](../images/00002.gif), which automatically
    sets up a new handler for us on the return connection. We would not need to set
    this option if we were going to use the same port (for example, 443). Next we
    specify the process IDs (PIDs) ![](../images/00004.gif) that we need and the shells
    into which they will be injected.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是`-m`标志 ![图片](../images/00002.gif)，它将自动为我们设置返回连接上的新处理程序。如果我们打算使用相同的端口（例如，443），则不需要设置此选项。接下来，我们指定所需的进程ID（PIDs）
    ![图片](../images/00004.gif)以及它们将被注入的外壳。
- en: Meterpreter executes in memory only. When we inject into a process, we are injecting
    Meterpreter into the memory space of that process. This allows us to remain stealthy,
    never reading or writing files to disk, while ultimately having multiple shells
    available to us.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter仅在内存中执行。当我们注入进程时，我们实际上是将Meterpreter注入到该进程的内存空间中。这使我们能够保持隐蔽，永远不会读取或写入磁盘上的文件，同时最终为我们提供多个外壳。
- en: We then set the IP address ![](../images/00005.gif) and port number ![](../images/00006.gif)
    on the attacking machine to which we want the new Meterpreter session to connect.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置攻击机器上的IP地址 ![图片](../images/00005.gif) 和端口号 ![图片](../images/00006.gif)，以便新的Meterpreter会话连接到。
- en: 'We issue the `ps` command within Meterpreter to get a list of running processes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Meterpreter中发出`ps`命令以获取正在运行的进程列表：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll inject our new Meterpreter shell into the *iexplorer.exe* ![](../images/00002.gif)
    process. This will spawn a second Meterpreter console completely within memory
    and will never write data to the disk.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的新Meterpreter外壳注入到*iexplorer.exe* ![图片](../images/00002.gif)进程中。这将完全在内存中生成第二个Meterpreter控制台，并且永远不会写入磁盘。
- en: 'Let’s run the `multi_meter_inject` command using some of the switches we reviewed
    earlier to see if it works:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用之前审查的一些开关运行`multi_meter_inject`命令，看看它是否工作：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As this output indicates, our command was successful and a new Meterpreter session
    has been opened, as shown at ![](../images/00002.gif).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如此输出所示，我们的命令已成功执行，并已打开一个新的Meterpreter会话，如图所示 ![图片](../images/00002.gif)。
- en: Now that you understand what this script can do, let’s examine how it works.
    We’ll break the script into chunks to help us parse its commands and overall structure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这个脚本能做什么，让我们来检查它是如何工作的。我们将把脚本分解成块，以帮助我们解析其命令和整体结构。
- en: 'First, variables and definitions are defined and the flags we want to pass
    to Meterpreter are set up:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义变量和定义，并设置我们想要传递给Meterpreter的标志：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the beginning of this section of script, notice that several variables are
    defined for later use. For example, `pid = nil` at ![](../images/00002.gif) creates
    a PID variable but its value is not set. The `@exec_opts = Rex::Parser::Arguments.new(`
    section at ![](../images/00004.gif) defines the additional help commands and flags
    that will be used.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本部分的开始处，请注意定义了几个用于后续使用的变量。例如，`pid = nil` 在 ![](../images/00002.gif) 处创建了一个
    PID 变量，但其值尚未设置。`@exec_opts = Rex::Parser::Arguments.new(` 部分，在 ![](../images/00004.gif)
    处定义了将使用的附加帮助命令和标志。
- en: 'The next section defines functions that we will call later:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分定义了我们将稍后调用的函数：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the function `usage` at ![](../images/00002.gif) will be called
    when the `-h` flag is set. You can call a number of Meterpreter functions directly
    from the Meterpreter API. This functionality simplifies certain tasks, such as
    injecting into a new process with the `def inject` function, as shown at ![](../images/00004.gif).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，当 `-h` 标志被设置时，将调用 `usage` 函数在 ![](../images/00002.gif)。你可以直接从 Meterpreter
    API 调用许多 Meterpreter 函数。这种功能简化了某些任务，例如使用 `def inject` 函数注入到新的进程，如下所示在 ![](../images/00004.gif)。
- en: The next important element is the `host_process.memory.allocate` call at ![](../images/00005.gif),
    which will allow us to allocate memory space for our Meterpreter payload. We then
    write the memory to our process using `host_process.memory.write` at ![](../images/00006.gif)
    and create a new thread using `host_process.thread.create` at ![](../images/00007.gif).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要元素是在 ![](../images/00005.gif) 处的 `host_process.memory.allocate` 调用，这将使我们能够为我们的
    Meterpreter 有效载荷分配内存空间。然后我们使用 `host_process.memory.write` 在 ![](../images/00006.gif)
    处将内存写入我们的进程，并使用 `host_process.thread.create` 在 ![](../images/00007.gif) 处创建一个新的线程。
- en: Next we define the multi-handler that handles the connections based on the selected
    payload, as shown in boldface in the following output. (The default is Meterpreter,
    so the multi-handler will handle Meterpreter sessions unless otherwise specified.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义一个多处理器，它根据所选的有效载荷处理连接，如下所示（粗体）。（默认是 Meterpreter，所以多处理器将处理 Meterpreter
    会话，除非另有说明。）
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `pay = client.framework.payloads.create(payload)` call in the following
    section allows us to create a payload from the Metasploit Framework. Because we
    know this is a Meterpreter payload, Metasploit will automatically generate it
    for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中的 `pay = client.framework.payloads.create(payload)` 调用允许我们从 Metasploit
    框架创建一个有效载荷。因为我们知道这是一个 Meterpreter 有效载荷，Metasploit 将自动为我们生成它。
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next option spawns a process using Notepad by default. If we didn’t specify
    a process, it would have created a Notepad process for us automatically.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项默认使用记事本启动一个进程。如果我们没有指定进程，它将自动为我们创建一个记事本进程。
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The boldfaced call lets us execute any command on the operating system. Notice
    that `Hidden` is set to `true`. This means that the user on the other side (the
    target) will not see anything; if Notepad is opened, it will run without the target
    user’s knowledge.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体调用使我们能够在操作系统上执行任何命令。注意，`Hidden` 被设置为 `true`。这意味着另一边的用户（目标）将看不到任何东西；如果打开记事本，它将在目标用户不知情的情况下运行。
- en: 'Next we call our functions, throw if statements, and start the payload:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们调用我们的函数，抛出 if 语句，并启动有效载荷：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we go through a couple of checks, make sure the syntax is correct,
    and inject our new Meterpreter session into our PID:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行一些检查，确保语法正确，并将我们的新 Meterpreter 会话注入到我们的 PID 中：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Meterpreter API
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meterpreter API
- en: During a penetration test, you might be unable to find an existing script that
    matches what you need in order to perform a required task. If you understand the
    basic concepts of programming, it should be relatively easy for you to pick up
    the Ruby syntax and use it to write additional scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试期间，你可能无法找到与所需任务匹配的现有脚本。如果你理解编程的基本概念，那么你应该能够相对容易地掌握 Ruby 语法，并使用它来编写额外的脚本。
- en: 'Let’s start off with a basic print statement that uses the interactive Ruby
    shell, also known as `irb`. From the Meterpreter console, issue the **`irb`**
    command and begin typing commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用交互式 Ruby 壳（也称为 `irb`）的基本打印语句开始。从 Meterpreter 控制台，输入 **`irb`** 命令并开始输入命令：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After you are inside the interactive shell, you can use it to test the different
    API calls from Meterpreter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进入交互式外壳后，你可以使用它来测试来自 Meterpreter 的不同 API 调用。
- en: Printing Output
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印输出
- en: 'Let’s start with the `print_line()` call, which will print the output and add
    a carriage return at the end:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `print_line()` 调用开始，这将打印输出并在末尾添加换行符：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next call is `print_status()` and is used most often in the scripting language.
    This call will provide a carriage return and print the status of whatever is executing,
    with a `[*]` prefixed at the beginning:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用是`print_status()`，在脚本语言中使用最为频繁。此调用将提供换行符并打印正在执行的内容的状态，前面带有`[*]`前缀：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next call is `print_good()`, which is used to provide the results of an
    action or to indicate that the action was successful:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用是`print_good()`，用于提供操作的结果或指示操作成功：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next call is `print_error()`, which is used to provide an error message
    or to indicate that an action was not possible:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用是`print_error()`，用于提供错误消息或指示操作不可行：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Base API Calls
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础API调用
- en: 'Meterpreter includes many API calls that you can use in your scripts to provide
    additional functionality or customization. You can use several reference points
    for these API calls. The one most often used by scripting newbies looks at how
    the Meterpreter console user interface (UI) uses the calls; these can be used
    as a base to continue writing scripts. To access this code, read the files under
    */opt/framework3/msf3/lib/rex/post/meterpreter/ui/console/command_dispatcher/*
    in Back|Track. If you create a listing of the folder contents, you can see the
    files that contain various commands that you can use:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter包含许多API调用，您可以在脚本中使用它们以提供额外的功能或定制。您可以使用几个参考点来查找这些API调用。脚本新手最常使用的参考点是查看Meterpreter控制台用户界面（UI）如何使用这些调用；这些可以作为编写脚本的起点。要访问此代码，请阅读Back|Track中`/opt/framework3/msf3/lib/rex/post/meterpreter/ui/console/command_dispatcher/`目录下的文件。如果您创建了一个文件夹内容的列表，您可以看到包含您可以使用各种命令的文件：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within these scripts are the various Meterpreter core, desktop interaction,
    privileged operations, and many more commands. Review these scripts to become
    intimately familiar with how Meterpreter operates within a compromised system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些脚本中包含了各种Meterpreter核心、桌面交互、特权操作以及许多其他命令。通过审查这些脚本，您可以深入了解Meterpreter在受侵害系统中的操作方式。
- en: Meterpreter Mixins
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Meterpreter混入
- en: 'The Meterpreter mixins are a series of calls that represent the most common
    tasks undertaken in a Meterpreter script. These calls are not available in `irb`
    and can be used only when creating a script for Meterpreter. Following is a list
    of some of the most notable calls:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Meterpreter混入（mixins）是一系列表示在Meterpreter脚本中执行的最常见任务的调用。这些调用在`irb`中不可用，只能在为Meterpreter创建脚本时使用。以下是其中一些最显著的调用列表：
- en: '| **`cmd_exec(cmd)`** Executes the given command as hidden and channelized.
    The output of the command is provided as a multiline string. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **`cmd_exec(cmd)`** 以隐藏和通道化的方式执行给定的命令。命令的输出以多行字符串的形式提供。|'
- en: '| **`eventlog_clear(evt = "")`** Clears a given event log or all event logs
    if none is given. Returns an array of event logs that were cleared. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **`eventlog_clear(evt = "")`** 清除给定的事件日志或如果没有提供则清除所有事件日志。返回一个包含已清除事件日志的数组。|'
- en: '| **`eventlog_list()`** Enumerates the event logs and returns an array containing
    the names of the event logs. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **`eventlog_list()`** 列出事件日志并返回一个包含事件日志名称的数组。|'
- en: '| **`file_local_digestmd5(file2md5)`** Returns a string with the MD5 checksum
    of a given local file. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **`file_local_digestmd5(file2md5)`** 返回给定本地文件的MD5校验和字符串。|'
- en: '| **`file_local_digestsha1(file2sha1)`** Returns a string with the SHA1 checksum
    of a given local file. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **`file_local_digestsha1(file2sha1)`** 返回给定本地文件的SHA1校验和字符串。|'
- en: '| **`file_local_digestsha2(file2sha2)`** Returns a string with the SHA256 checksum
    of a given local file. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **`file_local_digestsha2(file2sha2)`** 返回给定本地文件的SHA256校验和字符串。|'
- en: '| **`file_local_write(file2wrt, data2wrt)`** Writes a given string to a specified
    file. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **`file_local_write(file2wrt, data2wrt)`** 将给定的字符串写入指定的文件。|'
- en: '| **`is_admin?()`** Identifies whether or not the user is an admin. Returns
    `true` if the user is an admin and `false` if not. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **`is_admin?()`** 识别用户是否为管理员。如果用户是管理员则返回`true`，否则返回`false`。|'
- en: '| **`is_uac_enabled?()`** Determines whether User Account Control (UAC) is
    enabled on the system. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **`is_uac_enabled?()`** 确定系统上是否启用了用户账户控制（UAC）。|'
- en: '| **`registry_createkey(key)`** Creates a given registry key and returns `true`
    if successful. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_createkey(key)`** 创建给定的注册表键，如果成功则返回`true`。|'
- en: '| **`registry_deleteval(key,valname)`** Deletes a registry value given the
    key and value name. Returns `true` if successful. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_deleteval(key,valname)`** 根据键和值名称删除注册表值。如果成功则返回`true`。|'
- en: '| **`registry_delkey(key)`** Deletes a given registry key and returns `true`
    if successful. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_delkey(key)`** 删除给定的注册表键，如果成功则返回`true`。|'
- en: '| **`registry_enumkeys(key)`** Enumerates the subkeys of a given registry key
    and returns an array of subkeys. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_enumkeys(key)`** 列出给定注册表键的子键，并返回子键数组。 |'
- en: '| **`registry_enumvals(key)`** Enumerates the values of a given registry key
    and returns an array of value names. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_enumvals(key)`** 列出给定注册表键的值，并返回值名称数组。 |'
- en: '| **`registry_getvaldata(key,valname)`** Returns the data of a given registry
    key and its value. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_getvaldata(key,valname)`** 返回给定注册表键及其值的值数据。 |'
- en: '| **`registry_getvalinfo(key,valname)`** Returns the data and type of a given
    registry key and its value. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_getvalinfo(key,valname)`** 返回给定注册表键及其值的数据和类型。 |'
- en: '| **`registry_setvaldata(key,valname,data,type)`** Sets the data for a given
    value and type of data on the target registry. Returns `true` if successful. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **`registry_setvaldata(key,valname,data,type)`** 设置目标注册表上给定值的数据和数据类型。如果成功，则返回`true`。
    |'
- en: '| **`service_change_startup(name,mode)`** Changes a given service startup mode.
    The name and the mode must be provided. The mode is a string set with either a
    corresponding auto, manual, or disable setting. The service name is case sensitive.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **`service_change_startup(name,mode)`** 更改指定服务的启动模式。必须提供名称和模式。模式是一个字符串集合，可以是相应的自动、手动或禁用设置。服务名称区分大小写。
    |'
- en: '| **`service_create(name, display_name, executable_on_host,startup=2)`** Function
    for the creation of a service that runs its own process. Its parameters are the
    service name as a string, the display name as a string, the path of the executable
    on the host that will execute at startup as a string, and the startup type as
    an integer: `2` for Auto, `3` for Manual, or `4` for Disable (default is Auto).
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **`service_create(name, display_name, executable_on_host,startup=2)`** 用于创建运行其自身进程的服务。其参数为服务名称（字符串）、显示名称（字符串）、在启动时将在主机上执行的可执行文件路径（字符串）以及启动类型（整数）：`2`为自动，`3`为手动，或`4`为禁用（默认为自动）。
    |'
- en: '| **`service_delete(name)`** Function for deleting a service by deleting the
    key in the registry. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **`service_delete(name)`** 通过删除注册表中的键来删除服务。 |'
- en: '| **`service_info(name)`** Gets Windows service information. The information
    is returned in a hash with display name, startup mode, and command executed by
    the service. The service name is case sensitive. Hash keys are `Name`, `Start`,
    `Command`, and `Credentials`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **`service_info(name)`** 获取Windows服务信息。信息以哈希表形式返回，包含显示名称、启动模式和由服务执行命令。服务名称区分大小写。哈希键为`Name`、`Start`、`Command`和`Credentials`。
    |'
- en: '| **`service_list()`** Lists all Windows services present. Returns an array
    containing the services’ names. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **`service_list()`** 列出所有现有的Windows服务。返回包含服务名称的数组。 |'
- en: '| **`service_start(name)`** Function for service startup. Returns `0` if the
    service is started, `1` if the service is already started, and `2` if service
    is disabled. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **`service_start(name)`** 用于服务启动的函数。如果服务已启动，则返回`0`；如果服务已启动，则返回`1`；如果服务已禁用，则返回`2`。
    |'
- en: '| **`service_stop(name)`** Function for stopping a service. Returns `0` if
    the service is stopped successfully, `1` if the service is already stopped or
    disabled, and `2` if the service cannot be stopped. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **`service_stop(name)`** 用于停止服务的函数。如果成功停止服务，则返回`0`；如果服务已停止或禁用，则返回`1`；如果无法停止服务，则返回`2`。
    |'
- en: You should understand the basics regarding the Meterpreter mixin calls that
    you can use to add functionality to your custom script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解有关你可以用于向自定义脚本添加功能的基础Meterpreter混入调用。
- en: Rules for Writing Meterpreter Scripts
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Meterpreter脚本的规则
- en: 'When creating Meterpreter scripts, you need to understand the following rules
    before you begin your first script and if you want them to be committed to the
    Framework:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Meterpreter脚本之前，你需要了解以下规则，以便开始编写第一个脚本，并且如果要将它们提交到框架：
- en: Use only instance, local, and constant variables; never use global or class
    variables because they might interfere with the Framework variables.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用实例、局部和常量变量；永远不要使用全局或类变量，因为它们可能会与框架变量冲突。
- en: Use hard tabs for indenting; do not use spaces.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用硬制表符进行缩进；不要使用空格。
- en: For code blocks, do not use `{}`. Instead, use `do` and `end`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于代码块，不要使用`{}`。而是使用`do`和`end`。
- en: When declaring functions, always write a comment before the declaration and
    provide a brief description of its purpose.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明函数时，总是在声明之前写一个注释，并简要描述其目的。
- en: Do not use `sleep`; use `"select(nil, nil, nil, <time>)"`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`sleep`；使用`"select(nil, nil, nil, <time>)"`。
- en: Do not use `puts` or any other standard output calls; instead use `print`, `print_line`,
    `print_status`, `print_error`, and `print_good`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`puts`或任何其他标准输出调用；而是使用`print`、`print_line`、`print_status`、`print_error`和`print_good`。
- en: Always include an `-h` option that will print a description and the purpose
    of the script and show the available options.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是包含一个`-h`选项，它会打印出脚本的描述和用途，并显示可用的选项。
- en: If your script is meant for a specific operating system or Meterpreter platform,
    make sure it runs only on those platforms and prints out an error message for
    an unsupported OS or platform.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的脚本针对特定的操作系统或Meterpreter平台，请确保它只在这些平台上运行，并在不支持的操作系统或平台上打印出错误信息。
- en: Creating Your Own Meterpreter Script
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您自己的Meterpreter脚本
- en: 'Open up your favorite editor and create a new file called *execute_upload.rb*,
    located in *scripts/meterpreter/*. We’ll start by adding comments to the top of
    the file to let everyone know the purpose of this script and to define our options
    for the script:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您最喜欢的编辑器，创建一个名为 *execute_upload.rb* 的新文件，位于 *scripts/meterpreter/* 目录下。我们将首先在文件顶部添加注释，让每个人都知道这个脚本的目的，并定义脚本选项：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should look somewhat familiar, because it’s almost exactly the same as
    the example from Carlos Perez that appeared earlier in the chapter. The help message
    is defined with `-h` at ![](../images/00002.gif), and `-r` and `-p` are specified
    for the remote IP address ![](../images/00004.gif) and port number ![](../images/00005.gif)
    we’ll need for our new Meterpreter executable. Note that a `true` statement is
    included; this indicates that these fields are required.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来应该很熟悉，因为它几乎与本章前面出现的Carlos Perez的示例完全相同。帮助信息使用`-h`在 ![](../images/00002.gif)
    定义，`-r`和`-p`指定了我们需要的新Meterpreter可执行文件的远程IP地址 ![](../images/00004.gif) 和端口号 ![](../images/00005.gif)。请注意，包含了一个`true`语句；这表示这些字段是必需的。
- en: Next, we define the variables we want to use throughout the script. We’ll call
    the `Rex::Text.rand_text_alpha` function to create a unique executable name every
    time it’s called. This is efficient, because we don’t want to assign an executable
    name statically, which would “antivirus fingerprint” the attack. We’ll also configure
    each argument so that it either assigns a value or prints information with, for
    example, the `-h`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义在整个脚本中想要使用的变量。我们将调用`Rex::Text.rand_text_alpha`函数，以便每次调用时都创建一个唯一的可执行文件名。这是高效的，因为我们不希望静态分配可执行文件名，这样会“病毒指纹”攻击。我们还将配置每个参数，使其要么分配一个值，要么使用例如`-h`打印信息。
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we broke out each argument and assigned values or print information
    back to the user. The `rhost = val` ![](../images/00002.gif) means “take the value
    presented from the user when `-r` was input.” The `rport = val.to_i` ![](../images/00004.gif)
    simply assigns the value as an integer (it will always need to be an integer for
    a port number).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将每个参数都分离出来，并分配值或向用户打印信息。`rhost = val` ![](../images/00002.gif) 表示“当输入`-r`时，获取用户提供的值。”`rport
    = val.to_i` ![](../images/00004.gif) 简单地将值分配为整数（对于端口号来说，它始终需要是整数）。
- en: 'In the next series, we define everything we need to create our payload:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一系列中，我们定义创建有效载荷所需的所有内容：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We define our payload as a `windows/meterpreter/reverse_tcp` at ![](../images/00002.gif),
    generate the payload calling the `client.framework.payloads.create(payload)` at
    ![](../images/00004.gif), and specify the necessary parameters to create the multi-handler.
    These are all the required fields we need to set our payload using the `LHOST`
    and `LPORT` options and create a listener.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的有效载荷定义为`windows/meterpreter/reverse_tcp`，在 ![](../images/00002.gif) 生成有效载荷，调用`client.framework.payloads.create(payload)`在
    ![](../images/00004.gif) 生成，并指定创建多处理器所需的必要参数。这些都是我们使用`LHOST`和`LPORT`选项设置有效载荷并创建监听器所需的所有字段。
- en: 'Next we create our executable (*win32pe meterpreter*), upload it to our target
    machine, and execute it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的可执行文件（*win32pe meterpreter*），将其上传到目标机器，并执行它：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The variables called `#{`*`something`*`}` have already been defined within the
    script and will be called later. Notice that we already defined `tempdir` and
    `filename`. Moving into the script, we first include an if statement to detect
    whether the platform we are targeting is a Windows-based system ![](../images/00002.gif);
    otherwise, the attack won’t run. We then expand the temp directory ![](../images/00004.gif)
    on the target machine; this would be the equivalent of *%TEMP%*. Next we create
    a new file on the system and write out the new *EXE* we just generated from the
    `::Msf::Util::EXE.to_win32pe` ![](../images/00005.gif) call. Remember that we
    set the `session.sys.process.execute` to `Hidden` so that the target user won’t
    see anything pop up on his side.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`#{`*`something`*`}`的变量已经在脚本中定义，稍后将被调用。注意我们已经定义了`tempdir`和`filename`。进入脚本后，我们首先使用一个if语句来检测我们正在针对的平台是否是基于Windows的系统！[](../images/00002.gif)；否则，攻击不会运行。然后我们在目标机器上扩展临时目录！[](../images/00004.gif)，这相当于`%TEMP%`。接下来我们在系统上创建一个新文件，并写入从`::Msf::Util::EXE.to_win32pe`调用生成的新的*EXE*文件！[](../images/00005.gif)。记住我们设置了`session.sys.process.execute`为`Hidden`，这样目标用户就不会在他的侧看到任何弹出。
- en: 'Putting this all together, our final script should look something like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们的最终脚本应该看起来像这样：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have our newly created Meterpreter script, let’s launch Metasploit,
    get into Meterpreter, and execute the script:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了新的Meterpreter脚本，让我们启动Metasploit，进入Meterpreter，并执行脚本：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Success! We have created a Meterpreter script and successfully executed it to
    spawn a new Meterpreter shell. This is a small example of the power and flexibility
    of the Meterpreter scripting language and Ruby in general.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经创建了一个Meterpreter脚本，并成功执行它以生成一个新的Meterpreter外壳。这是Meterpreter脚本语言和Ruby的一般灵活性和强大功能的一个小例子。
- en: One important element to discuss briefly (as mentioned earlier) is the move
    to convert Meterpreter scripts to a format similar to the Metasploit modules.
    We’ll use a small demo of a module built for bypassing the Windows 7 UAC. Windows
    Vista and later introduced a feature similar to `sudo` in UNIX- and Linux-based
    systems. With this feature, a user is assigned limited account permissions until
    administrative-level permissions are necessary. When the user needs admin rights
    to perform a task, a prompt appears, telling the user that admin rights are required
    and are being used. The ultimate goal of this feature is to protect against a
    compromise or virus infection and to limit exposure only to one user account.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简要讨论一个重要元素（如前所述）是将Meterpreter脚本转换为类似于Metasploit模块的格式。我们将使用一个用于绕过Windows 7 UAC的小型模块演示。Windows
    Vista及以后的版本引入了一个类似于UNIX和Linux系统中的`sudo`的功能。使用这个功能，用户在被赋予管理级别权限之前被分配有限的账户权限。当用户需要管理员权限来执行任务时，会出现一个提示，告知用户需要管理员权限并且正在使用。这个功能的最终目标是防止被入侵或病毒感染，并限制仅对单个用户账户的暴露。
- en: In December 2010, Dave Kennedy and Kevin Mitnick released a new Meterpreter
    module that bypassed the Windows UAC component by injecting a payload into a process
    that had a trusted publisher certificate and was considered “UAC Safe.” When injecting
    into the process, a DLL can be called, running under the context of that UAC Safe
    process, which then executes commands.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在2010年12月，Dave Kennedy和Kevin Mitnick发布了一个新的Meterpreter模块，通过向具有受信任发布者证书并被认为是“UAC安全”的进程注入有效载荷来绕过Windows
    UAC组件。在注入到进程时，可以调用DLL，在UAC安全进程的上下文中运行，然后执行命令。
- en: In this example, we use the post exploitation modules, which can be used to
    bypass UAC. We first start the *multi/handler* module with the `-j` flag, which
    allows us to accept multiple Meterpreter shells. Notice in this example that when
    we try to run the `getsystem` command, it fails because it is being blocked by
    Windows UAC.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用后利用模块，这些模块可以用来绕过UAC。我们首先使用带有`-j`标志的`*multi/handler*`模块，这允许我们接受多个Meterpreter外壳。注意在这个例子中，当我们尝试运行`getsystem`命令时，它失败了，因为它被Windows
    UAC阻止了。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we can’t bridge over to a system-level account, because UAC is blocking
    us. We need to get around UAC to obtain system-level privileges and ultimately
    become an administrator so that we can further compromise the machine. We press
    ctrl-Z to back out, keeping the session active. Then we use the new format to
    run post modules and bypass the Windows UAC functionality.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们无法桥接到系统级账户，因为UAC阻止了我们。我们需要绕过UAC以获得系统级权限，最终成为管理员，这样我们就可以进一步入侵机器。我们按ctrl-Z退回，保持会话活跃。然后我们使用新的格式运行后模块并绕过Windows
    UAC功能。
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could also have executed `run` instead of `use` within the Meterpreter console
    and it would have leveraged the default options and executed without having to
    set up the various options.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Meterpreter控制台中执行`run`而不是`use`，它将利用默认选项并执行，而无需设置各种选项。
- en: Notice in the preceding example that we succeed in gaining system-level rights
    on a target machine with UAC enabled. This small example demonstrates how the
    post exploitation modules will ultimately be set up and converted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在先前的示例中，我们成功在启用了UAC的目标机器上获得了系统级权限。这个小例子演示了后利用模块最终将被设置和转换的方式。
- en: 'This script works simply by uploading a previously compiled executable to the
    target machine and then running it. Take a look at the post exploitation module
    for a better idea of what’s going on behind the scenes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本通过将先前编译的可执行文件上传到目标机器并运行它来工作。查看后利用模块以更好地了解幕后发生的事情：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Wrapping Up
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We won’t cover all the details of the post exploitation module because it is
    nearly identical to the attack shown in [Chapter 13](part0017.html#building_your_own_module).
    Carefully walk through each line, and then try to build and run your own module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖后利用模块的所有细节，因为它几乎与第13章中展示的攻击相同[Chapter 13](part0017.html#building_your_own_module)。仔细查看每一行，然后尝试构建并运行你自己的模块。
- en: Walk through existing Meterpreter scripts and look at the different commands,
    calls, and functions that can be used to create your own script. If you come up
    with a great idea for a new script, submit it to the Metasploit development team
    — who knows; it might be a script that others can use!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历现有的Meterpreter脚本，查看可以用来创建你自己的脚本的不同命令、调用和函数。如果你有一个新脚本的好主意，提交给Metasploit开发团队——谁知道呢；它可能是一个其他人也可以使用的脚本！
