- en: Chapter 1. Strategies for Problem Solving
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 解决问题的策略
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: This book is about problem solving, but what is problem solving, exactly? When
    people use the term in ordinary conversation, they often mean something very different
    from what we mean here. If your 1997 Honda Civic has blue smoke coming from the
    tailpipe, is idling roughly, and has lost fuel efficiency, this is a problem that
    can be solved with automotive knowledge, diagnosis, replacement equipment, and
    common shop tools. If you tell your friends about your problem, though, one of
    them might say, “Hey, you should trade that old Honda in for something new. Problem
    solved.” But your friend’s suggestion wouldn’t really be a *solution* to the problem—it
    would be a way to *avoid* the problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于解决问题的，但究竟什么是解决问题呢？当人们在日常对话中使用这个术语时，他们通常意味着与我们在这里所说的非常不同的事情。如果你的1997年款本田思域从排气管冒出蓝色烟雾，怠速不稳定，并且燃油效率降低，这是一个可以用汽车知识、诊断、更换设备和常见的商店工具解决的问题。然而，如果你向你的朋友们提起你的问题，他们中的一个可能会说，“嘿，你应该把那辆旧的本田换成一辆新的。问题解决了。”但你的朋友的建议并不是真正解决问题的*解决方案*——那是一种避免问题的方法。
- en: Problems include constraints, unbreakable rules about the problem or the way
    in which the problem must be solved. With the broken-down Civic, one of the constraints
    is that you want to fix the current car, not purchase a new car. The constraints
    might also include the overall cost of the repairs, how long the repair will take,
    or a requirement that no new tools can be purchased just for this repair.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 问题包括约束，关于问题或解决问题方式的不可打破的规则。对于损坏的本田车，一个约束是你想修理现有的车，而不是购买一辆新车。约束还可能包括维修的整体成本、维修所需的时间，或者不允许购买仅为此维修的新工具的要求。
- en: 'When solving a problem with a program, you also have constraints. Common constraints
    include the programming language, platform (does it run on a PC, or an iPhone,
    or what?), performance (a game program may require graphics to be updated at least
    30 times a second, a business application might have a maximum time response to
    user input), or memory footprint. Sometimes the constraint involves what other
    code you can reference: Maybe the program can’t include certain open-source code,
    or maybe the opposite—maybe it can use only open source.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当用程序解决问题时，你也有约束。常见的约束包括编程语言、平台（它是否在PC上运行，或在iPhone上运行，或是什么？）、性能（游戏程序可能需要每秒至少更新30次图形，商业应用程序可能对用户输入的最大响应时间有限制），或内存占用。有时约束涉及你可以引用的其他代码：可能程序不能包含某些开源代码，或者相反——可能它只能使用开源代码。
- en: For programmers, then, we can define *problem solving* as writing an original
    program that performs a particular set of tasks and meets all stated constraints.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于程序员来说，我们可以将*解决问题*定义为编写一个执行特定任务集并满足所有声明的约束的原创程序。
- en: 'Beginning programmers are often so eager to accomplish the first part of that
    definition—writing a program to perform a certain task—that they fail on the second
    part of the definition, meeting the stated constraints. I call a program like
    that, one that appears to produce correct results but breaks one or more of the
    stated rules, a *Kobayashi Maru*. If that name is unfamiliar to you, it means
    you are insufficiently familiar with one of the touchstones of geek culture, the
    film *Star Trek II: The Wrath of Khan*. The film contains a subplot about an exercise
    for aspiring officers at Starfleet Academy. The cadets are put aboard a simulated
    starship bridge and made to act as captain on a mission that involves an impossible
    choice. Innocent people will die on a wounded ship, the *Kobayashi Maru*, but
    to reach them requires starting a battle with the Klingons, a battle that can
    only end in the destruction of the captain’s ship. The exercise is intended to
    test a cadet’s courage under fire. There’s no way to win, and all choices lead
    to bad outcomes. Toward the end of the film, we discover that Captain Kirk modified
    the simulation to make it actually winnable. Kirk was clever, but he did not solve
    the dilemma of the *Kobayashi Maru*; he avoided it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者程序员往往急于完成定义中的第一部分——编写一个程序来执行特定任务——以至于他们在定义的第二部分，即满足既定约束方面失败了。我把这样的程序称为“小野马”，它看起来能产生正确的结果，但违反了其中一条或多条规则。如果你对这个名字不熟悉，这意味着你对极客文化的基石之一——电影《星际迷航II：怒火中烧》——不够熟悉。这部电影包含一个关于星舰学院有志成为军官的学员的副故事。学员们被安置在模拟的星舰舰桥上，并被要求在涉及不可能选择的任务中担任船长。无辜的人将在受伤的船上死去，即“小野马”，但要到达那里，就需要与克林贡人开始战斗，而这场战斗只能以船长舰船的毁灭结束。这个练习的目的是测试学员在炮火下的勇气。没有获胜的方法，所有选择都导致不良结果。在电影的结尾，我们发现柯克船长修改了模拟，使其实际上可以赢得胜利。柯克很聪明，但他并没有解决“小野马”的困境；他避免了它。
- en: Fortunately, the problems you will face as a programmer are solvable, but many
    programmers still resort to Kirk’s approach. In some cases, they do so accidentally.
    (“Oh, shoot! My solution only works if there are a hundred data items or fewer.
    It’s supposed to work for an unlimited data set. I’ll have to rethink this.”)
    In other cases, the removal of constraints is deliberate, a ploy to meet a deadline
    imposed by a boss or an instructor. In still other cases, the programmer just
    doesn’t know how to meet all of the constraints. In the worst cases I have seen,
    the programming student has paid someone else to write the program. Regardless
    of the motivations, we must always be diligent to avoid the Kobayashi Maru.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你作为程序员将面临的问题是可以解决的，但许多程序员仍然求助于柯克的方法。在某些情况下，他们这样做是偶然的。（“哦，糟糕！我的解决方案只适用于有一百个或更少数据项的情况。它应该适用于无限的数据集。我必须重新思考这个问题。”）在其他情况下，去除约束是故意的，是为了满足老板或导师强加的最后期限。在其他情况下，程序员不知道如何满足所有约束。在我见过的最糟糕的情况下，编程学生支付了别人来编写程序。无论动机如何，我们都必须始终勤奋地避免“小野马”。
- en: Classic Puzzles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典谜题
- en: As you progress through this book, you will notice that although the particulars
    of the source code change from one problem area to the next, certain patterns
    will emerge in the approaches we take. This is great news because this is what
    eventually allows us to confidently approach any problem, whether we have extensive
    experience in that problem area or not. Expert problem solvers are quick to recognize
    an *analogy*, an exploitable similarity between a solved problem and an unsolved
    problem. If we recognize that a feature of problem A is analogous to a feature
    of problem B and we have already solved problem B, we have a valuable insight
    into solving problem A.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在这本书中的进步，你会注意到，尽管源代码的细节从一个问题领域到另一个问题领域都在变化，但我们的方法中会出现某些模式。这是一个好消息，因为这最终使我们能够自信地面对任何问题，无论我们是否在该问题领域有丰富的经验。专家问题解决者会迅速识别出一种“类比”，即已解决问题与未解决问题之间的可利用相似性。如果我们认识到问题A的特征与问题B的特征类似，并且我们已经解决了问题B，那么我们对解决问题A就有了一个宝贵的洞察。
- en: In this section, we’ll discuss classic problems from outside the world of programming
    that have lessons we can apply to programming problems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论来自编程世界之外的经典问题，这些问题的教训我们可以应用到编程问题中。
- en: The Fox, the Goose, and the Corn
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 狐狸、鹅和玉米
- en: The first classic problem we will discuss is a riddle about a farmer who needs
    to cross a river. You have probably encountered it previously in one form or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个经典问题是关于一个需要过河的农夫的谜题。你可能以前以某种形式遇到过这个问题。
- en: 'Problem: How to Cross the River?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：如何过河？
- en: A farmer with a fox, a goose, and a sack of corn needs to cross a river. The
    farmer has a rowboat, but there is room for only the farmer and one of his three
    items. Unfortunately, both the fox and the goose are hungry. The fox cannot be
    left alone with the goose, or the fox will eat the goose. Likewise, the goose
    cannot be left alone with the sack of corn, or the goose will eat the corn. How
    does the farmer get everything across the river?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个农夫带着一只狐狸、一只鹅和一袋玉米需要过河。农夫有一只小船，但只能容纳他和他的三个物品中的一个。不幸的是，狐狸和鹅都很饿。狐狸不能单独和鹅留在同一岸，否则狐狸会吃掉鹅。同样，鹅也不能单独和玉米袋留在同一岸，否则鹅会吃掉玉米。农夫如何才能把所有东西都运过河？
- en: The setup for this problem is shown in [Figure 1-1](ch01.html#the_fox_comma_the_goose_comma_and_the_sa
    "Figure 1-1. The fox, the goose, and the sack of corn. The boat can carry one
    item at a time. The fox cannot be left on the same shore as the goose, and the
    goose cannot be left on the same shore as the sack of corn."). If you have never
    encountered this problem before, stop here and spend a few minutes trying to solve
    it. If you *have* heard this riddle before, try to remember the solution and whether
    you were able to solve the riddle on your own.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的设置如图[图1-1](ch01.html#the_fox_comma_the_goose_comma_and_the_sa "图1-1. 狐狸、鹅和玉米袋。船一次只能携带一个物品。狐狸不能和鹅留在同一岸，鹅也不能和玉米袋留在同一岸。")所示。如果你以前从未遇到过这个问题，请在这里停下来，花几分钟时间尝试解决它。如果你*曾经*遇到过这个谜题，尝试回忆一下解决方案，以及你是否能独立解决这个谜题。
- en: '![The fox, the goose, and the sack of corn. The boat can carry one item at
    a time. The fox cannot be left on the same shore as the goose, and the goose cannot
    be left on the same shore as the sack of corn.](httpatomoreillycomsourcenostarchimages1273153.png.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![狐狸、鹅和玉米袋。船一次只能携带一个物品。狐狸不能和鹅留在同一岸，鹅也不能和玉米袋留在同一岸。](httpatomoreillycomsourcenostarchimages1273153.png.jpg)'
- en: Figure 1-1. The fox, the goose, and the sack of corn. The boat can carry one
    item at a time. The fox cannot be left on the same shore as the goose, and the
    goose cannot be left on the same shore as the sack of corn.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1. 狐狸、鹅和玉米袋。船一次只能携带一个物品。狐狸不能和鹅留在同一岸，鹅也不能和玉米袋留在同一岸。
- en: Few people are able to solve this riddle, at least without a hint. I know I
    wasn’t. Here’s how the reasoning usually goes. Since the farmer can take only
    one thing at a time, he’ll need multiple trips to take everything to the far shore.
    On the first trip, if the farmer takes the fox, the goose would be left with the
    sack of corn, and the goose would eat the corn. Likewise, if the farmer took the
    sack of corn on the first trip, the fox would be left with the goose, and the
    fox would eat the goose. Therefore, the farmer must take the goose on the first
    trip, resulting in the configuration shown in [Figure 1-2](ch01.html#the_required_first_step_for_solving_the
    "Figure 1-2. The required first step for solving the problem of the fox, the goose,
    and the sack of corn. From this step, however, all further steps appear to end
    in failure.").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有人能够解决这个谜题，至少在没有提示的情况下。我知道我做不到。通常的推理是这样的。由于农夫一次只能携带一个物品，他需要多次往返才能把所有东西带到对岸。在第一次旅行中，如果农夫带狐狸过去，鹅就会和玉米袋留在同一岸，鹅会吃掉玉米。同样，如果农夫第一次带玉米袋过去，狐狸就会和鹅留在同一岸，狐狸会吃掉鹅。因此，农夫第一次必须带鹅过去，结果如[图1-2](ch01.html#the_required_first_step_for_solving_the
    "图1-2. 解决狐狸、鹅和玉米袋问题的第一步。然而，从这个步骤开始，所有后续步骤似乎都以失败告终。")所示。
- en: '![The required first step for solving the problem of the fox, the goose, and
    the sack of corn. From this step, however, all further steps appear to end in
    failure.](httpatomoreillycomsourcenostarchimages1273155.png.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![解决狐狸、鹅和玉米袋问题的第一步。然而，从这个步骤开始，所有后续步骤似乎都以失败告终。](httpatomoreillycomsourcenostarchimages1273155.png.jpg)'
- en: Figure 1-2. The required first step for solving the problem of the fox, the
    goose, and the sack of corn. From this step, however, all further steps appear
    to end in failure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2. 解决狐狸、鹅和玉米袋问题的第一步。然而，从这个步骤开始，所有后续步骤似乎都以失败告终。
- en: So far, so good. But on the second trip, the farmer must take the fox or the
    corn. Whatever the farmer takes, however, must be left on the far shore with the
    goose while the farmer returns to the near shore for the remaining item. This
    means that either the fox and goose will be left together or the goose and corn
    will be left together. Because neither of these situations is acceptable, the
    problem appears unsolvable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但在第二次旅行中，农夫必须带狐狸或玉米。然而，无论农夫拿什么，都必须在鹅和另一件物品留在远岸的同时，农夫返回近岸取剩余的物品。这意味着狐狸和鹅将一起留在远岸，或者鹅和玉米将一起留在远岸。由于这两种情况都不被接受，问题看起来似乎无法解决。
- en: Again, if you have seen this problem before, you probably remember the key element
    of the solution. The farmer has to take the goose on the first trip, as explained
    before. On the second trip, let’s suppose the farmer takes the fox. Instead of
    leaving the fox with the goose, though, the farmer *takes the goose back* to the
    near shore. Then the farmer takes the sack of corn across, leaving the fox and
    the corn on the far shore, while returning for a fourth trip with the goose. The
    complete solution is shown in [Figure 1-3](ch01.html#step-by-step_solution_to_the_fox_comma_g
    "Figure 1-3. Step-by-step solution to the fox, goose, and corn puzzle").
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你之前见过这个问题，你可能记得解决方案的关键要素。正如之前解释的那样，农夫必须第一次带鹅。在第二次旅行中，让我们假设农夫带狐狸。不过，农夫并没有把狐狸留在鹅那里，而是**把鹅带回到近岸**。然后农夫带着玉米袋过河，把狐狸和玉米留在远岸，并在第四次旅行时带着鹅回来。完整的解决方案在[图1-3](ch01.html#step-by-step_solution_to_the_fox_comma_g
    "图1-3. 狐狸、鹅和玉米谜题的逐步解决方案")中展示。
- en: This puzzle is difficult because most people never consider taking one of the
    items back from the far shore to the near shore. Some people will even suggest
    that the problem is unfair, saying something like, “You didn’t say I could take
    something back!” This is true, but it’s also true that nothing in the problem
    description suggests that taking something back is prohibited.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题很难，因为大多数人从未考虑过将其中一件物品从远岸带回近岸。有些人甚至会建议这个问题是不公平的，说些像“你没有说我可以拿回东西！”这样的话。这是真的，但同样，问题描述中没有任何内容表明拿回东西是被禁止的。
- en: '![Step-by-step solution to the fox, goose, and corn puzzle](httpatomoreillycomsourcenostarchimages1273157.png.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![狐狸、鹅和玉米谜题的逐步解决方案](httpatomoreillycomsourcenostarchimages1273157.png.jpg)'
- en: Figure 1-3. Step-by-step solution to the fox, goose, and corn puzzle
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3. 狐狸、鹅和玉米谜题的逐步解决方案
- en: 'Think about how much easier the puzzle would be to solve if the possibility
    of taking one of the items back to the near shore was made explicit: *The farmer
    has a rowboat* that can be used to transfer items in either direction, *but there
    is room only for the farmer and one of his three items*. With that suggestion
    in plain sight, more people would figure out the problem. This illustrates an
    important principle of problem solving: If you are unaware of all possible actions
    you could take, you may be unable to solve the problem. We can refer to these
    actions as operations. By enumerating all the possible operations, we can solve
    many problems by testing every combination of operations until we find one that
    works. More generally, by restating a problem in more formal terms, we can often
    uncover solutions that would have otherwise eluded us.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 想想如果明确指出将其中一件物品带回近岸的可能性，这个谜题会容易解决多少：**农夫有一只小船**，可以用来在两个方向上转移物品，**但船上只能容纳农夫和他的三件物品中的一件**。有了这个建议在眼前，更多的人会想出这个问题。这说明了问题解决的一个重要原则：如果你不知道所有可能采取的行动，你可能无法解决问题。我们可以将这些行动称为操作。通过列举所有可能的操作，我们可以通过测试所有操作的组合来解决问题，直到找到一种可行的方案。更普遍地说，通过用更正式的术语重新表述问题，我们通常可以揭示出我们可能错过的解决方案。
- en: 'Let’s forget that we already know the solution and try stating this particular
    puzzle more formally. First, we’ll list our constraints. The key constraints here
    are:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们忘记我们已经知道解决方案，尝试更正式地表述这个特定的谜题。首先，我们将列出我们的约束条件。这里的关键约束是：
- en: The farmer can take only one item at a time in the boat.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 农夫一次只能从船上拿一件物品。
- en: The fox and goose cannot be left alone on the same shore.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狐狸和鹅不能单独留在同一岸上。
- en: The goose and corn cannot be left alone on the same shore.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鹅和玉米不能单独留在同一岸上。
- en: This problem is a good example of the importance of constraints. If we remove
    any of these constraints, the puzzle is easy. If we remove the first constraint,
    we can simply take all three items across in one trip. Even if we can take only
    two items in the boat, we can take the fox and corn across and then go back for
    the goose. If we remove the second constraint (but leave the other constraints
    in place), we just have to be careful, taking the goose across first, then the
    fox, and finally the corn. Therefore, if we forget or ignore any of the constraints,
    we will end up with a Kobayashi Maru.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题是一个很好的例子，说明了约束的重要性。如果我们移除这些约束中的任何一个，谜题就变得简单了。如果我们移除第一个约束，我们可以简单地一次把所有三个物品带过去。即使我们只能带两个物品上船，我们也可以先带狐狸和玉米过去，然后回来接鹅。如果我们移除第二个约束（但保留其他约束），我们只需要小心，先带鹅过去，然后是狐狸，最后是玉米。因此，如果我们忘记或忽略任何约束，我们最终会陷入一个“无解”的局面。
- en: 'Next, let’s list the operations. There are various ways of stating the operations
    for this puzzle. We could make a specific list of the actions we think we can
    take:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们列出操作。对于这个谜题，有各种表述操作的方式。我们可以列出我们认为可以采取的具体行动列表：
- en: 'Operation: Carry the fox to the far side of the river.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：将狐狸带到河的对岸。
- en: 'Operation: Carry the goose to the far side of the river.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：将鹅带到河的对岸。
- en: 'Operation: Carry the corn to the far side of the river.'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：将玉米带到河的对岸。
- en: Remember, though, that the goal of formally restating the problem is to gain
    insight for a solution. Unless we have already solved the problem and discovered
    the “hidden” possible operation, taking the goose back to the near side of the
    river, we’re not going to discover it in making our list of actions. Instead,
    we should try to make operations generic, or parameterized.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，然而，正式重述问题的目的是为了获得解决方案的洞察力。除非我们已经解决了问题并发现了“隐藏”的可能操作，即把鹅带回到河的近岸，否则我们不会在我们的行动列表中找到它。相反，我们应该尝试使操作通用化或参数化。
- en: 'Operation: Row the boat from one shore to the other.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：划船从一岸到另一岸。
- en: 'Operation: If the boat is empty, load an item from the shore.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：如果船是空的，从岸上取一个物品放到船上。
- en: 'Operation: If the boat is not empty, unload the item to the shore.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作：如果船不是空的，将物品卸到岸上。
- en: By thinking about the problem in the most general terms, this second list of
    operations will allow us to solve the problem without the need for an “ah-hah!”
    moment regarding the trip back to the near shore with the goose. If we generate
    all possible sequences of moves, ending each sequence once it violates one of
    our constraints or reaches a configuration we’ve seen before, we will eventually
    hit upon the sequence of [Figure 1-3](ch01.html#step-by-step_solution_to_the_fox_comma_g
    "Figure 1-3. Step-by-step solution to the fox, goose, and corn puzzle") and solve
    the puzzle. The inherent difficulty of the puzzle will have been sidestepped through
    the formal restatement of constraints and operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以最一般的方式思考问题，这个操作列表将使我们能够在不需要关于鹅返回近岸的“啊哈！”时刻的情况下解决问题。如果我们生成所有可能的移动序列，一旦序列违反了我们的任何一个约束或达到我们之前见过的配置，我们最终会找到[图1-3](ch01.html#step-by-step_solution_to_the_fox_comma_g
    "图1-3. 狐狸、鹅和玉米问题的逐步解决方案")的序列并解决这个谜题。通过正式重述约束和操作，我们将绕过谜题固有的难度。
- en: Lessons Learned
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验教训
- en: What can we learn from the fox, the goose, and the corn?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能从狐狸、鹅和玉米中学到什么？
- en: Restating the problem in a more formal manner is a great technique for gaining
    insight into a problem. Many programmers seek out other programmers to discuss
    a problem, not just because other programmers may have the answer but also because
    articulating the problem out loud often triggers new and useful thoughts. Restating
    a problem is like having that discussion with another programmer, except that
    you are playing both parts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以更正式的方式重述问题是一种深入了解问题的优秀技术。许多程序员寻求与其他程序员讨论问题，不仅因为其他程序员可能有答案，而且还因为大声阐述问题通常会引发新的和有用的想法。重述问题就像与另一个程序员进行讨论一样，只是你扮演了两个角色。
- en: The broader lesson is that thinking about the problem may be as productive,
    or in some cases more productive, than thinking about the solution. In many cases,
    the correct approach to the solution *is* the solution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛的教训是，思考问题可能和思考解决方案一样有效，或者在某些情况下更有效。在许多情况下，解决问题的正确方法本身就是解决方案。
- en: Sliding Tile Puzzles
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动拼图
- en: The sliding tile puzzle comes in different sizes, which, as we’ll see later,
    offers a particular solving mechanism. The following description is for a 3×3
    version of the puzzle.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动拼图有多种尺寸，正如我们稍后将要看到的，它提供了一种特定的解决机制。以下描述适用于3×3版本的拼图。
- en: 'Problem: The Sliding Eight'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：滑动八块
- en: A 3×3 grid is filled with eight tiles, numbered 1 through 8, and one empty space.
    Initially, the grid is in a jumbled configuration. A tile can be slid into an
    adjacent empty space, leaving the tile’s previous location empty. The goal is
    to slide the tiles to place the grid in an ordered configuration, from tile 1
    in the upper left.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个3×3的网格填充了八块拼图，编号为1到8，还有一个空白空间。最初，网格处于混乱的配置。一块拼图可以滑入相邻的空白空间，使其原来的位置变为空白。目标是滑动拼图，将网格放置在有序的配置中，从左上角的拼图1开始。
- en: The goal of this problem is shown in [Figure 1-4](ch01.html#the_goal_configuration_in_the_eight-tile
    "Figure 1-4. The goal configuration in the eight-tile version of the sliding tile
    puzzle. The empty square represents the empty space into which an adjacent tile
    may slide."). If you’ve never tried a puzzle like this before, take the time to
    do so now. Plenty of sliding puzzle simulators can be found on the Web, but for
    our purposes it’s better if you use playing cards or index cards to make your
    own game on a tabletop. A suggested starting configuration is shown in [Figure 1-5](ch01.html#a_particular_starting_configuration_for
    "Figure 1-5. A particular starting configuration for the sliding tile puzzle").
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的目标在[图1-4](ch01.html#the_goal_configuration_in_the_eight-tile "图1-4. 滑动拼图八块版本的目标配置。空白方块代表相邻的拼图可以滑入的空位。")中显示。如果你以前从未尝试过这样的谜题，现在就花点时间试试。网上可以找到许多滑动拼图模拟器，但为了我们的目的，如果你使用扑克牌或索引卡在桌面上自己制作游戏会更好。一个建议的起始配置在[图1-5](ch01.html#a_particular_starting_configuration_for
    "图1-5. 滑动拼图的特定起始配置")中显示。
- en: '![The goal configuration in the eight-tile version of the sliding tile puzzle.
    The empty square represents the empty space into which an adjacent tile may slide.](httpatomoreillycomsourcenostarchimages1273159.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![滑动拼图八块版本的目标配置。空白方块代表相邻的拼图可以滑入的空位。](httpatomoreillycomsourcenostarchimages1273159.png)'
- en: Figure 1-4. The goal configuration in the eight-tile version of the sliding
    tile puzzle. The empty square represents the empty space into which an adjacent
    tile may slide.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4. 滑动拼图八块版本的目标配置。空白方块代表相邻的拼图可以滑入的空位。
- en: '![A particular starting configuration for the sliding tile puzzle](httpatomoreillycomsourcenostarchimages1273161.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![滑动拼图的特定起始配置](httpatomoreillycomsourcenostarchimages1273161.png)'
- en: Figure 1-5. A particular starting configuration for the sliding tile puzzle
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5. 滑动拼图的特定起始配置
- en: This puzzle is quite different from the farmer with his fox, goose, and corn.
    The difficulty in that problem came from overlooking one of the possible operations.
    In this problem, that doesn’t happen. From any given configuration, up to four
    tiles may be adjacent to the empty space, and any of those tiles can be slid into
    the empty space. That fully enumerates all possible operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题与农夫、狐狸、鹅和玉米的问题大不相同。那个问题的难度来自于忽略了一种可能的操作。在这个问题中，这种情况不会发生。从任何给定的配置中，最多有四个拼图可以与空白空间相邻，并且任何这些拼图都可以滑入空白空间。这完全列举了所有可能的操作。
- en: The difficulty in this problem arises instead from the long chain of operations
    required by the solution. A series of sliding operations may move some tiles to
    their correct final positions while moving other tiles out of position, or it
    may move some tiles closer to their correct positions while moving others farther
    away. Because of this, it’s difficult to tell whether any particular operation
    would make progress toward the ultimate goal. Without being able to measure progress,
    it’s difficult to formulate a strategy. Many people who attempt a sliding tile
    puzzle simply move the tiles around randomly, hoping to hit upon a configuration
    from which a path to the goal configuration can be seen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的难度实际上来自于解决所需的长期操作链。一系列滑动操作可能会将一些拼图移动到正确的最终位置，同时将其他拼图移出位置，或者它可能会将一些拼图移动到更接近正确位置，同时将其他拼图移动得更远。正因为如此，很难判断任何特定的操作是否会使我们朝着最终目标迈进。如果不能衡量进度，就很难制定策略。许多尝试滑动拼图的人只是随意移动拼图，希望找到一种可以从其中看到通往目标配置路径的配置。
- en: Nevertheless, there are strategies for sliding tile puzzles. To illustrate one
    approach, let’s consider the puzzle for a smaller grid that is rectangular but
    not square.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，滑动拼图还是有策略的。为了说明一种方法，让我们考虑一个较小的矩形网格的拼图，而不是正方形网格。
- en: 'Problem: The Sliding Five'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：滑动五格
- en: A 2×3 grid is filled with five tiles, numbered 4 through 8, and one empty space.
    Initially, the grid is in a jumbled configuration. A tile can be slid into an
    adjacent empty space, leaving the tile’s previous location empty. The goal is
    to slide the tiles to place the grid in an ordered configuration, from tile 4
    in the upper left.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个2×3的网格中填充了五个编号为4到8的格子，以及一个空格。最初，网格处于混乱的配置。一个格子可以滑入相邻的空格，留下格子原来的位置为空。目标是滑动格子，将网格放置在有序的配置中，从左上角的4号格子开始。
- en: You may have noticed that our five tiles are numbered 4 through 8 instead of
    1 through 5\. The reason for this will become clear shortly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们的五个格子编号为4到8，而不是1到5。这个原因很快就会变得清楚。
- en: Although this is the same basic problem as the sliding eight, it is much easier
    with only five tiles. Try the configuration shown in [Figure 1-6](ch01.html#a_particular_starting_configuration
    "Figure 1-6. A particular starting configuration for a reduced, 2×3 sliding tile
    puzzle").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个问题与滑动八格问题基本相同，但只有五个格子，所以要容易得多。尝试一下[图1-6](ch01.html#a_particular_starting_configuration
    "图1-6. 一个简化的2×3滑动拼图的特殊起始配置")中所示的配置。
- en: If you play around with these tiles for just a few minutes, you will probably
    hit upon a solution. From playing around with small-count tile puzzles, I have
    developed a particular skill. It is this one skill, coupled with an observation
    we will discuss shortly, that I use to solve all sliding tile puzzles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是玩几分钟这些瓷砖，你可能会找到解决方案。通过玩小数量瓷砖拼图，我开发了一种特定的技能。正是这种技能，加上我们很快就会讨论的观察，我用来解决所有的滑动拼图。
- en: '![A particular starting configuration for a reduced, 2×3 sliding tile puzzle](httpatomoreillycomsourcenostarchimages1273163.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![一个简化的2×3滑动拼图的特殊起始配置](httpatomoreillycomsourcenostarchimages1273163.png.jpg)'
- en: Figure 1-6. A particular starting configuration for a reduced, 2×3 sliding tile
    puzzle
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6. 一个简化的2×3滑动拼图的特殊起始配置
- en: I call my technique *the train*. It’s based on the observation that a circuit
    of tile positions that includes the empty space forms a train of tiles that can
    be rotated anywhere along the circuit while preserving the relative ordering of
    the tiles. [Figure 1-7](ch01.html#a_ltrain_comma_r_a_path_of_tiles_that_be "Figure 1-7. A
    “train,” a path of tiles that begins adjacent to the empty square and can slide
    like a train of cars through the puzzle") illustrates the smallest possible train
    of four positions. From the first configuration, the 1 can slide into the empty
    square, the 2 can slide into the space vacated by the 1, and finally the 3 can
    slide into the space vacated by the 2\. This leaves the empty space adjacent to
    the 1, which allows the train to continue and, thus, the tiles to be effectively
    rotated anywhere along the train path.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我把我的技术称为“火车”。这是基于观察，包括空格的瓷砖位置电路形成了一个可以旋转的瓷砖火车，在任何电路上的相对顺序保持不变。[图1-7](ch01.html#a_ltrain_comma_r_a_path_of_tiles_that_be
    "图1-7. 一个“火车”，一个从空格旁边开始的瓷砖路径，可以像火车一样在拼图中滑动")展示了四个位置的最小火车。从第一个配置开始，1号格子可以滑入空格，2号格子可以滑入1号格子留下的空格，最后3号格子可以滑入2号格子留下的空格。这留下了空格紧邻1号格子，这使得火车可以继续，因此，瓷砖可以有效地在火车路径上的任何地方旋转。
- en: '![A “train,” a path of tiles that begins adjacent to the empty square and can
    slide like a train of cars through the puzzle](httpatomoreillycomsourcenostarchimages1273165.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![一个“火车”，一个从空格旁边开始的瓷砖路径，可以像火车一样在拼图中滑动](httpatomoreillycomsourcenostarchimages1273165.png.jpg)'
- en: Figure 1-7. A “train,” a path of tiles that begins adjacent to the empty square
    and can slide like a train of cars through the puzzle
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-7. 一个“火车”，一个从空格旁边开始的瓷砖路径，可以像火车一样在拼图中滑动
- en: Using a train, we can move a series of tiles while maintaining their relative
    relationship. Now let’s return to the previous 2×3 grid configuration. Although
    none of the tiles in this grid is in its correct final position, some tiles are
    adjacent to the tiles they need to border in the final configuration. For example,
    in the final configuration, the 4 will be above the 7, and currently those tiles
    are adjacent. As shown in [Figure 1-8](ch01.html#from_configuration_1_comma_two_rotations
    "Figure 1-8. From configuration 1, two rotations along the outlined “train” bring
    us to configuration 2\. From there, a single tile slide results in the goal, configuration
    3."), we can use a six-position train to bring the 4 and 7 to their correct final
    positions. When we do that, the remaining tiles are nearly correct; we just need
    to slide the 8 over.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列车，我们可以在保持磁砖相对关系的同时移动一系列磁砖。现在让我们回到之前的 2×3 网格配置。尽管这个网格中的磁砖没有一个处于其正确的最终位置，但一些磁砖与它们在最终配置中需要相邻的磁砖相邻。例如，在最终配置中，4
    将位于 7 的上方，而目前这些磁砖是相邻的。如图 [图 1-8](ch01.html#from_configuration_1_comma_two_rotations
    "图 1-8. 从配置 1 开始，沿着轮廓的“列车”旋转两次将我们带到配置 2。从那里，单个磁砖滑动就实现了目标，配置 3") 所示，我们可以使用一个六位置列车将
    4 和 7 移动到它们的正确最终位置。当我们这样做时，剩余的磁砖几乎正确；我们只需要将 8 滑动过去。
- en: '![From configuration 1, two rotations along the outlined “train” bring us to
    configuration 2\. From there, a single tile slide results in the goal, configuration
    3.](httpatomoreillycomsourcenostarchimages1273167.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![从配置 1 开始，沿着轮廓的“列车”旋转两次将我们带到配置 2。从那里，单个磁砖滑动就实现了目标，配置 3。](httpatomoreillycomsourcenostarchimages1273167.png)'
- en: Figure 1-8. From configuration 1, two rotations along the outlined “train” bring
    us to configuration 2\. From there, a single tile slide results in the goal, configuration
    3.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-8. 从配置 1 开始，沿着轮廓的“列车”旋转两次将我们带到配置 2。从那里，单个磁砖滑动就实现了目标，配置 3。
- en: So how does this one technique allow us to solve any sliding tile puzzle? Consider
    our original 3×3 configuration. We can use a six-position train to move the adjacent
    1 and 2 tiles so that the 2 and 3 are adjacent, as shown in [Figure 1-9](ch01.html#from_configuration_1_comma_tiles_are_rot
    "Figure 1-9. From configuration 1, tiles are rotated along the outlined “train”
    to reach configuration 2.").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这种技术是如何让我们解决任何滑动拼图的呢？考虑我们的原始 3×3 配置。我们可以使用一个六位置列车来移动相邻的 1 和 2 磁砖，使 2 和 3 相邻，如图
    [图 1-9](ch01.html#from_configuration_1_comma_tiles_are_rot "图 1-9. 从配置 1 开始，磁砖沿着轮廓的“列车”旋转以到达配置
    2") 所示。
- en: '![From configuration 1, tiles are rotated along the outlined “train” to reach
    configuration 2.](httpatomoreillycomsourcenostarchimages1273169.png.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![从配置 1 开始，磁砖沿着轮廓的“列车”旋转以到达配置 2。](httpatomoreillycomsourcenostarchimages1273169.png.jpg)'
- en: Figure 1-9. From configuration 1, tiles are rotated along the outlined “train”
    to reach configuration 2.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9. 从配置 1 开始，磁砖沿着轮廓的“列车”旋转以到达配置 2。
- en: This puts 1, 2, and 3 in adjacent squares. With an eight-position train, we
    can shift the 1, 2, and 3 tiles to their correct final positions, as shown in
    [Figure 1-10](ch01.html#from_configuration_1_comma_tiles_are "Figure 1-10. From
    configuration 1, tiles are rotated to reach configuration 2, in which tiles 1,
    2, and 3 are in their correct final positions.").
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就将 1、2 和 3 放在了相邻的方格中。使用一个八位置列车，我们可以将 1、2 和 3 磁砖移动到它们的正确最终位置，如图 [图 1-10](ch01.html#from_configuration_1_comma_tiles_are
    "图 1-10. 从配置 1 开始，磁砖旋转以到达配置 2，其中磁砖 1、2 和 3 处于正确的最终位置") 所示。
- en: '![From configuration 1, tiles are rotated to reach configuration 2, in which
    tiles 1, 2, and 3 are in their correct final positions.](httpatomoreillycomsourcenostarchimages1273171.png.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![从配置 1 开始，磁砖旋转以到达配置 2，其中磁砖 1、2 和 3 处于正确的最终位置。](httpatomoreillycomsourcenostarchimages1273171.png.jpg)'
- en: Figure 1-10. From configuration 1, tiles are rotated to reach configuration
    2, in which tiles 1, 2, and 3 are in their correct final positions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10. 从配置 1 开始，磁砖旋转以到达配置 2，其中磁砖 1、2 和 3 处于正确的最终位置。
- en: Notice the positions of tiles 4–8\. The tiles are in the configuration I gave
    for the 2×3 grid. This is the key observation. Having placed tiles 1–3 in their
    correct positions, we can solve the rest of the grid as a separate, smaller, and
    easier puzzle. Note that we have to solve an entire row or column for this method
    to work; if we put tiles 1 and 2 in the correct positions but tile 3 is still
    out of place, there is no way to move something into the upper-right corner without
    moving one or both of the other upper-row tiles out of place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意4-8号拼图的位置。拼图处于我给出的2×3网格的配置中。这是关键观察。在将1-3号拼图放置到正确的位置后，我们可以将剩余的网格作为一个单独的、更小、更简单的拼图来解决。请注意，我们必须解决整个行或列，这种方法才能奏效；如果我们把1号和2号拼图放到正确的位置，但3号拼图仍然不在位，就没有办法在不移动其他上方行的一个或两个拼图的情况下将某物移动到右上角。
- en: This same technique can be used to solve even larger sliding tile puzzles. The
    largest common size is a 15-tile puzzle, a 4×4 grid. This can be solved piecemeal
    by first moving tiles 1–4 to their correct position, leaving a 3×4 grid, and then
    moving the tiles of the leftmost column, leaving a 3×3 grid. At that point, the
    problem has been reduced to an 8-tile puzzle.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相同的技术也可以用来解决更大的滑动拼图。最大的常见尺寸是15块拼图，一个4×4的网格。可以通过首先将1-4号拼图移动到正确的位置，留下一个3×4的网格，然后移动最左边列的拼图，留下一个3×3的网格来逐步解决这个问题。到那时，问题已经简化为一个8块拼图。
- en: Lessons Learned
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验教训
- en: What lessons can we learn from the sliding tile puzzles?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从滑动拼图中学到什么教训？
- en: The number of tile movements is large enough that it is difficult or impossible
    to plan out a complete solution for a sliding tile puzzle from the initial configuration.
    However, our inability to plan a complete solution does not prevent us from making
    strategies or employing techniques to systematically solve the puzzle. In solving
    programming problems, we are sometimes faced with situations where we can’t see
    a clear path to code the solution, but we must never allow this to be an excuse
    to forgo planning and systematic approaches. It’s better to develop a strategy
    than to attack the problem through trial and error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图移动的数量很大，以至于很难或不可能从初始配置中规划出完整的解决方案。然而，我们无法规划出完整的解决方案并不能阻止我们制定策略或采用技术来系统地解决拼图。在解决编程问题时，我们有时会遇到无法看到清晰路径来编写解决方案的情况，但我们绝不能以此为借口放弃规划和系统方法。制定策略比通过试错攻击问题更好。
- en: I developed my “train” technique from fiddling around with a small puzzle. Often,
    I use a similar technique in programming. When faced with an onerous problem,
    I experiment with a reduced version of the problem. These experiments frequently
    produce valuable insights.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我是从摆弄一个小拼图发展出我的“训练”技术的。我经常在编程中使用类似的技术。面对一个艰巨的问题时，我会尝试问题的简化版本。这些实验通常会产生有价值的见解。
- en: The other lesson is that sometimes problems are divisible in ways that are not
    immediately obvious. Because moving a tile affects not only that tile but also
    the possible moves that can be made next, one might think that a sliding tile
    puzzle must be solved all in one step, not in stages. Looking for a way to divide
    a problem is usually time well spent. Even if you are unable to find a clean division,
    you may learn something about the problem that helps you to solve it. When solving
    problems, working with a specific goal in mind is always better than random effort,
    whether you achieve that specific goal or not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个教训是，有时问题可以通过不明显的方式分割。因为移动拼图不仅影响那个拼图，还影响下一步可以进行的移动，有人可能会认为滑动拼图必须一步解决，而不是分阶段解决。寻找分割问题的方法通常是值得花费时间的。即使你无法找到清晰的分割，你也可能学到一些关于问题的知识，这有助于你解决问题。在解决问题时，有具体目标地工作总是比随机努力更好，无论你是否实现了那个具体目标。
- en: Sudoku
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数独
- en: The sudoku game has become enormously popular through appearances in newspapers
    and magazines and also as a web-based and phone-based game. Variations exist,
    but we will briefly discuss the traditional version.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数独游戏通过在报纸和杂志上的出现，以及作为基于网页和手机的游戏而变得极为流行。存在不同的变体，但我们将简要讨论传统版本。
- en: 'Problem: Completing a Sudoku Square'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：完成数独方阵
- en: 'A 9×9 grid is partially filled with single digits (from 1–9), and the player
    must fill in the empty squares while meeting certain constraints: In each row
    and column, each digit must appear exactly once, and further, in each marked 3×3
    area, each digit must appear exactly once.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个9×9的网格部分填充了单个数字（从1到9），玩家必须在满足某些约束的条件下填写空格：在每一行和每一列中，每个数字必须恰好出现一次，而且进一步地，在由粗边框标记的每个3×3区域中，每个数字也必须恰好出现一次。
- en: If you have played this game before, you probably already have a set of strategies
    for completing a square in the minimum time. Let’s focus on the key starting strategy
    by looking at the sample square shown in [Figure 1-11](ch01.html#an_easy_sudoku_square_puzzle
    "Figure 1-11. An easy sudoku square puzzle").
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前玩过这个游戏，你可能已经有一套完成方格的最短时间的策略。让我们通过查看[图1-11](ch01.html#an_easy_sudoku_square_puzzle
    "图1-11. 一个简单的数独方格谜题")中显示的样本方格来关注关键起始策略。
- en: '![An easy sudoku square puzzle](httpatomoreillycomsourcenostarchimages1273174.png.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的数独方格谜题](httpatomoreillycomsourcenostarchimages1273174.png.jpg)'
- en: Figure 1-11. An easy sudoku square puzzle
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-11. 一个简单的数独方格谜题
- en: Sudoku puzzles vary in difficulty, their difficulty determined by the number
    of squares left to be filled. By this measure, this is a very easy puzzle. As
    36 squares are already numbered, there are just 45 that must be filled to complete
    the puzzle. The question is, which squares should we attempt to fill in first?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数独谜题的难度各不相同，其难度由需要填充的方格数量决定。按照这个标准，这是一个非常简单的谜题。由于已经有36个方格被编号，因此只需要填充45个方格来完成谜题。问题是，我们应该尝试先填充哪些方格？
- en: Remember the puzzle constraints. Each of the nine digits must appear once in
    every row, in every column, and in every 3×3 area marked by the heavy borders.
    These rules dictate where we should begin our efforts. The 3×3 area in the middle
    of the puzzle already has numbers in eight of its nine squares. Therefore, the
    square in the very center can have only one possible value, the one value not
    already represented in another square in that 3×3 area. That’s where we should
    start solving this puzzle. The missing number in that area is 7, so we would place
    that in the middle square.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 记住谜题的约束。每个九个数字必须在每个行、每个列以及由粗边框标记的每个3×3区域中各出现一次。这些规则决定了我们应该从哪里开始努力。谜题中间的3×3区域已经有八个方格的数字。因此，位于非常中心的方格只能有一个可能的值，这个值不已经在该3×3区域的另一个方格中出现过。那就是我们应该开始解决这个谜题的地方。该区域缺失的数字是7，所以我们会将其放在中间的方格中。
- en: 'With that value in place, note that the centermost column now has values in
    seven of its nine squares, which leaves only two squares remaining, each of which
    has to have a value not already in the column: The two missing numbers are 3 and
    9\. The constraint on this column would allow us to put either number in either
    place, but notice that 3 is already present in the third row and 9 is already
    present in the seventh row. Therefore, the row constraints dictate that 9 go in
    the third row of the middle column and 3 go in the seventh row of the middle column.
    These steps are summarized in [Figure 1-12](ch01.html#the_first_steps_in_solving_the_sample_su
    "Figure 1-12. The first steps in solving the sample sudoku puzzle").'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个值确定之后，请注意，中间的列现在在其九个方格中有七个方格的值，这留下了两个剩余的方格，每个方格都必须有一个不在该列中的值：两个缺失的数字是3和9。对这个列的限制允许我们将任何一个数字放在任何一个位置，但请注意，3已经存在于第三行，9已经存在于第七行。因此，行限制规定9必须放在中间列的第三行，3必须放在中间列的第七行。这些步骤在[图1-12](ch01.html#the_first_steps_in_solving_the_sample_su
    "图1-12. 解决样本数独谜题的第一步")中进行了总结。
- en: '![The first steps in solving the sample sudoku puzzle](httpatomoreillycomsourcenostarchimages1273176.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![解决样本数独谜题的第一步](httpatomoreillycomsourcenostarchimages1273176.png)'
- en: Figure 1-12. The first steps in solving the sample sudoku puzzle
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-12. 解决样本数独谜题的第一步
- en: We won’t solve the entire puzzle here, but these first steps make the important
    point that we search for squares that have the lowest number of possible values—ideally,
    just one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会解决整个谜题，但这些第一步说明了我们寻找具有可能值数量最少的方格——理想情况下只有一个。
- en: Lessons Learned
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验教训
- en: The main lesson from sudoku is that we should look for the most constrained
    part of the problem. While constraints are often what make a problem difficult
    to begin with (remember the fox, the goose, and the corn), they may also simplify
    our thinking about the solution because they eliminate choices.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数独的主要教训是我们应该寻找问题中最受限制的部分。虽然限制通常是使问题一开始就难以解决的原因（记得那个狐狸、鹅和玉米的故事），但它们也可能简化我们对解决方案的思考，因为它们消除了选择。
- en: Although we will not discuss artificial intelligence specifically in this book,
    there is a rule for solving certain types of problems in artificial intelligence
    called the “most constrained variable.” It means that in a problem where you are
    trying to assign different values to different variables to meet constraints,
    you should start with the variable that has the most constraints, or put another
    way, the variable that has the lowest number of possible values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这本书中不会具体讨论人工智能，但有一种用于解决某些类型问题的规则，称为“最受限变量”。这意味着在试图为不同的变量分配不同的值以满足限制条件的问题中，你应该从具有最多限制条件的变量开始，或者换句话说，从具有可能值数量最少的变量开始。
- en: 'Here’s an example of this sort of thinking. Suppose a group of coworkers wants
    to go to lunch together, and they’ve asked you to find a restaurant that everyone
    will like. The problem is, each of the coworkers imposes some kind of constraint
    on the group decision: Pam is a vegetarian, Todd doesn’t like Chinese food, and
    so on. If your goal is to minimize the amount of time it takes to find a restaurant,
    you should start by talking to the coworker with the most onerous restrictions.
    If Bob has a number of broad food allergies, for example, it would make sense
    to start by finding a list of restaurants where he knows he can eat, rather than
    starting with Todd, whose dislike of Chinese food can be easily mitigated.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这种思考方式的例子。假设一群同事想要一起吃午餐，他们已经让你找到一个大家都喜欢的餐厅。问题是，每个同事都对集体决策施加了一些限制：Pam 是素食主义者，Todd
    不喜欢中餐，等等。如果你的目标是最大限度地减少找到餐厅所需的时间，你应该先与受限制最严重的同事交谈。例如，如果 Bob 有许多广泛的食品过敏，那么从找到他知道可以吃的餐厅列表开始，而不是从Todd开始，Todd对中餐的厌恶很容易得到缓解。
- en: The same technique can often be applied to programming problems. If one part
    of the problem is heavily constrained, that’s a great place to start because you
    can make progress without worrying that you are spending time on work that will
    later be undone. A related corollary is that you should start with the part that’s
    obvious. If you can solve part of the problem, go ahead and do what you can. You
    may learn something from seeing your own code that will stimulate your imagination
    to solve the rest.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的技术通常可以应用于编程问题。如果问题的某个部分受到严重限制，那是一个很好的起点，因为你可以不必担心你正在花费时间在将来会被取消的工作上。一个相关的推论是，你应该从最明显的那部分开始。如果你能解决部分问题，就去做你能做的。从看到你自己的代码中，你可能学到一些东西，这会激发你的想象力来解决剩余的问题。
- en: The Quarrasi Lock
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Quarrasi 锁
- en: You may have seen each of the previous puzzles before, but you should not have
    seen the last one in this chapter unless you have read this book previously, because
    I’ve made this one up myself. Read carefully because the wording of this problem
    is a little complicated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前见过每个之前的谜题，但除非你以前读过这本书，否则你不应该看到本章的最后一个谜题，因为我自己编造了这个谜题。仔细阅读，因为这个问题的措辞有点复杂。
- en: 'Problem: Opening the Alien Lock'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：打开外星锁
- en: A hostile alien race, the Quarrasi, has landed on Earth, and you’ve been captured.
    You’ve managed to overpower your guards, even though they are enormous and tentacled,
    but to escape the (still grounded) spaceship, you have to open the massive door.
    The instructions for opening the door are, oddly enough, printed in English, but
    it’s still no piece of cake. To open the door, you have to slide the three bar-shaped
    Kratzz along tracks that lead from the right receptor to the left receptor, which
    lies at the end of the door, 10 feet away.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个敌对外星种族，Quarrasi，已经登陆地球，你被他们俘虏了。尽管他们巨大且长有触手，但你设法制服了你的守卫。为了逃离（仍然在地面上）的飞船，你必须打开那扇巨大的门。奇怪的是，打开门的说明是用英语打印的，但这仍然不是一件容易的事情。要打开门，你必须将三个条形的
    Kratzz 滑动到从右侧接收器到左侧接收器的轨道上，而左侧接收器位于门的末端，距离10英尺。
- en: 'That’s easy enough, but you have to avoid setting off the alarms, which work
    as follows. On each Kratzz are one or more star-shaped crystal power gems known
    as Quinicrys. Each receptor has four sensors that light up if the number of Quinicrys
    in the column above is even. An alarm goes off if the number of lit sensors is
    ever exactly one. Note that each receptor’s alarm is separate: You can’t ever
    have exactly one sensor lit for the left receptor or for the right receptor. The
    good news is that each alarm is equipped with a suppressor, which keeps the alarm
    from sounding as long as the button is pressed. If you could press both suppressors
    at once, the problem would be easy, but you can’t since you have short human arms
    rather than long Quarassi tentacles.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但你必须避免触发警报，警报的工作原理如下。每个Kratzz上都有一个或多个被称为Quinicrys的星形晶体宝石。每个受体都有四个传感器，如果上方列中的Quinicrys数量为偶数，则传感器会亮起。如果亮起的传感器数量恰好为一个是，则会响起警报。请注意，每个受体的警报是独立的：你不可能让左侧受体或右侧受体的传感器恰好亮起一个。好消息是每个警报都配备了抑制器，只要按下按钮，就可以阻止警报响起。如果你能同时按下两个抑制器，问题就简单了，但你不能，因为你只有短人类手臂，而不是长Quarassi触手。
- en: Given all of this, how do you slide the Kratzz to open the door without activating
    either alarm?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，你该如何滑动Kratzz而不触发任何警报来打开门？
- en: 'The starting configuration is shown in [Figure 1-13](ch01.html#starting_configuration_for_the_quarrasi
    "Figure 1-13. Starting configuration for the Quarrasi lock problem. You must slide
    the three Kratzz bars, currently in the right receptor, to the left receptor without
    setting off either alarm. A sensor is lit when an even number of star-shaped Quinicrys
    appear in the column above, and an alarm sounds if exactly one connected sensor
    lights up. Suppressors can keep an alarm from sounding, but only for the receptor
    where you are standing."), with all three Kratzz in the right receptor. For clarity,
    [Figure 1-14](ch01.html#the_quarrasi_lock_in_an_alarm_state._you "Figure 1-14. The
    Quarrasi lock in an alarm state. You just slid the upper Kratzz to the left receptor,
    so the right receptor is out of reach. The second sensor for the right alarm is
    lit because an even number of Quinicrys appears in the column above, and an alarm
    sounds when exactly one of its sensors is lit.") shows a bad idea: Sliding the
    uppermost Kratzz to the left receptor causes an alarm state in the right receptor.
    You might think that we could avoid the alarm with the suppressor, but remember
    that we just moved the upper Kratzz to the left receptor, so we’re 10 feet away
    from the right receptor’s suppressor.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 起始配置如图[图1-13](ch01.html#starting_configuration_for_the_quarrasi "图1-13. Quarrasi锁问题的起始配置。你必须将当前位于右侧受体的三个Kratzz棒滑到左侧受体，同时不能触发任何警报。当上方列中出现偶数个星形Quinicrys时，传感器会亮起，如果恰好有一个连接的传感器亮起，则会响起警报。抑制器可以阻止警报响起，但仅限于你站立的受体。")所示，三个Kratzz棒都在右侧受体。为了清晰起见，[图1-14](ch01.html#the_quarrasi_lock_in_an_alarm_state._you
    "图1-14. Quarrasi锁处于警报状态。你刚刚将最上面的Kratzz滑到左侧受体，因此右侧受体无法触及。右侧警报的第二传感器亮起，因为上方列中出现偶数个Quinicrys，当恰好有一个传感器亮起时，警报响起。")显示了错误的做法：将最上面的Kratzz滑到左侧受体会导致右侧受体进入警报状态。你可能认为我们可以用抑制器避免警报，但记住我们刚刚将最上面的Kratzz滑到左侧受体，所以我们离右侧受体的抑制器有10英尺远。
- en: '![Starting configuration for the Quarrasi lock problem. You must slide the
    three Kratzz bars, currently in the right receptor, to the left receptor without
    setting off either alarm. A sensor is lit when an even number of star-shaped Quinicrys
    appear in the column above, and an alarm sounds if exactly one connected sensor
    lights up. Suppressors can keep an alarm from sounding, but only for the receptor
    where you are standing.](httpatomoreillycomsourcenostarchimages1273178.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Quarrasi锁问题的起始配置。你必须将当前位于右侧受体的三个Kratzz棒滑到左侧受体，同时不能触发任何警报。当上方列中出现偶数个星形Quinicrys时，传感器会亮起，如果恰好有一个连接的传感器亮起，则会响起警报。抑制器可以阻止警报响起，但仅限于你站立的受体。](httpatomoreillycomsourcenostarchimages1273178.png.jpg)'
- en: Figure 1-13. Starting configuration for the Quarrasi lock problem. You must
    slide the three Kratzz bars, currently in the right receptor, to the left receptor
    without setting off either alarm. A sensor is lit when an even number of star-shaped
    Quinicrys appear in the column above, and an alarm sounds if exactly one connected
    sensor lights up. Suppressors can keep an alarm from sounding, but only for the
    receptor where you are standing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-13. Quarrasi 锁问题的起始配置。你必须将当前位于右侧接收器中的三个 Kratzz 条滑动到左侧接收器，而不触发任何警报。当上方列中出现偶数个星形
    Quinicrys 时，传感器会亮起，如果恰好有一个连接的传感器亮起，则会响起警报。抑制器可以阻止警报响起，但仅限于你站立的接收器。
- en: '![The Quarrasi lock in an alarm state. You just slid the upper Kratzz to the
    left receptor, so the right receptor is out of reach. The second sensor for the
    right alarm is lit because an even number of Quinicrys appears in the column above,
    and an alarm sounds when exactly one of its sensors is lit.](httpatomoreillycomsourcenostarchimages1273180.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Quarrasi 锁处于警报状态。你刚刚将上方的 Kratzz 滑向左侧接收器，因此右侧接收器无法触及。右侧警报的第二传感器亮起，因为上方列中出现了偶数个
    Quinicrys，当其传感器中恰好有一个亮起时，警报响起。](httpatomoreillycomsourcenostarchimages1273180.png.jpg)'
- en: Figure 1-14. The Quarrasi lock in an alarm state. You just slid the upper Kratzz
    to the left receptor, so the right receptor is out of reach. The second sensor
    for the right alarm is lit because an even number of Quinicrys appears in the
    column above, and an alarm sounds when exactly one of its sensors is lit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-14. Quarrasi 锁处于警报状态。你刚刚将上方的 Kratzz 滑向左侧接收器，因此右侧接收器无法触及。右侧警报的第二传感器亮起，因为上方列中出现了偶数个
    Quinicrys，当其传感器中恰好有一个亮起时，警报响起。
- en: Before moving on, take some time to study this problem, and try to develop a
    solution. Depending on your point of view, this problem is not as hard as it looks.
    Seriously, think about it before moving on!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花些时间研究这个问题，并尝试找到一个解决方案。根据你的观点，这个问题并不像看起来那么难。认真想想，然后再继续！
- en: 'Have you thought about it? Were you able to come up with a solution? There
    are two possible paths to an answer here. The first path is trial and error: attempting
    various Kratzz moves in a methodical way and backing up to previous steps when
    you reach an alarm state until you find a series of moves that succeeds.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你想过这个问题吗？你能否提出一个解决方案？这里有两条可能的答案路径。第一条路径是试错法：有系统地尝试各种 Kratzz 移动，并在达到警报状态时退回到之前的步骤，直到找到一系列成功的移动。
- en: 'The second path is realizing that the puzzle is a trick. If you haven’t seen
    the trick yet, here it is: This is just the fox, goose, and corn problem in an
    elaborate disguise. Although the rules for the alarm are written generally, there
    are only so many combinations for this specific lock. With only three Kratzz,
    we just have to know which combinations of Kratzz in a receptor are acceptable.
    If we label the three Kratzz *top*, *middle*, and *bottom*, then the combinations
    that create alarms are “top and middle” and “middle and bottom.” If we rename
    *top* as *fox*, *middle* as *goose*, and *bottom* as *corn*, then the troublesome
    combinations are the same as in the other problem, “fox and goose” and “goose
    and corn.”'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条路径是意识到这个谜题是一个陷阱。如果你还没有看到这个陷阱，这里就是：这其实就是狐狸、鹅和玉米问题的一个复杂伪装。尽管警报的规则写得比较宽泛，但这个特定锁的组合只有这么多。只有三个
    Kratzz，我们只需要知道哪些 Kratzz 组合在接收器中是可接受的。如果我们把三个 Kratzz 标记为 *top*（顶部）、*middle*（中间）和
    *bottom*（底部），那么会触发警报的组合是“top and middle”（顶部和中间）以及“middle and bottom”（中间和底部）。如果我们把
    *top* 重命名为 *fox*（狐狸）、*middle* 重命名为 *goose*（鹅）和 *bottom* 重命名为 *corn*（玉米），那么麻烦的组合与另一个问题相同，“fox
    and goose”（狐狸和鹅）以及“goose and corn”（鹅和玉米）。
- en: This problem is therefore solved in the same way as the fox, goose, and corn
    problem. We slide the middle Kratzz (goose) over to the left receptacle. Then,
    we slide the top (fox) to the left, holding the left alarm’s suppressor as we
    put the top (fox) into place. Next, we start sliding the middle (goose) back to
    the right receptacle. Then, we slide the bottom (corn) to the left, and finally,
    we slide the middle (goose) to the left once again, opening the lock.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个问题是以与狐狸、鹅和玉米问题相同的方式解决的。我们滑动中间的 Kratzz（鹅）到左侧的接收器。然后，我们滑动顶部的（狐狸）到左侧，同时握住左侧警报的抑制器，将顶部的（狐狸）放置到位。接下来，我们开始将中间的（鹅）滑回右侧的接收器。然后，我们滑动底部的（玉米）到左侧，最后，我们再次将中间的（鹅）滑动到左侧，打开锁。
- en: Lessons Learned
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经验教训
- en: The chief lesson here is the importance of recognizing analogies. Here, we can
    see that the Quarrasi lock problem is analogous to the fox, goose, and corn problem.
    If we discover that analogy early enough, we can avoid most of the work of the
    problem by translating our solution from the first problem rather than creating
    a new solution. Most analogies in problem solving won’t be so direct, but they
    will happen with increasing frequency.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要教训是认识到类比的重要性。在这里，我们可以看到Quarrasi锁问题与狐狸、鹅和玉米问题相似。如果我们能够尽早发现这个类比，我们就可以通过将我们的解决方案从第一个问题中转换过来，而不是创建一个新的解决方案，来避免大部分问题的努力。在问题解决中，大多数类比不会如此直接，但它们的发生频率会越来越高。
- en: If you had trouble seeing the connection between this problem and the fox, goose,
    and corn problem, that’s because I deliberately included as much extraneous detail
    as possible. The story that sets up the Quarrasi problem is irrelevant, as are
    the names for all of the alien technology, which serve to heighten the sense of
    unfamiliarity. Furthermore, the odd/even mechanism of the alarm makes the problem
    seem more complicated than it is. If you look at the actual positioning of the
    Quinicrys, you can see that the top Kratzz and the bottom Kratzz are opposites,
    so they don’t interact in the alarm system. The middle Kratzz, however, interacts
    with the other two.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现这个问题与狐狸、鹅和玉米问题之间的联系有困难，那是因为我故意加入了尽可能多的无关细节。建立Quarrasi问题的故事是不相关的，所有外星技术的名称也是如此，它们的作用是增强陌生感。此外，警报器的奇偶机制使得问题看起来比实际上更复杂。如果你看看Quinicrys的实际位置，你可以看到顶部和底部的Kratzz是相反的，所以它们在警报系统中不相互作用。然而，中间的Kratzz与其他两个相互作用。
- en: Again, if you didn’t see the analogy, don’t worry. You’ll start to recognize
    them more after you put yourself on alert for them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果你没有看到类比，不要担心。在你开始警惕它们之后，你会开始更多地认识到它们。
- en: General Problem-Solving Techniques
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用问题解决技术
- en: The examples we have discussed demonstrate many of the key techniques that are
    employed in problem solving. In the rest of this book, we’ll look at specific
    programming problems and figure out ways to solve them, but first we need a general
    set of techniques and principles. Some problem areas have specific techniques,
    as we’ll see, but the rules below apply to almost any situation. If you make these
    a regular part of your problem-solving approach, you’ll always have a method to
    attack a problem.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的例子展示了在问题解决中使用的许多关键技术。在本书的剩余部分，我们将探讨具体的编程问题并找出解决它们的方法，但首先我们需要一套通用的技术和原则。一些问题领域有特定的技术，正如我们将看到的，但以下规则几乎适用于任何情况。如果你将这些规则作为你问题解决方法的常规部分，你将始终有一个解决问题的方法。
- en: Always Have a Plan
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总是有一个计划
- en: This is perhaps the most important rule. You must always have a plan, rather
    than engaging in directionless activity.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最重要的规则。你必须始终有一个计划，而不是进行无目的的活动。
- en: By this point, you should understand that having a plan is always possible.
    It’s true that if you haven’t already solved the problem in your head, then you
    can’t have a plan for implementing a solution in code. That will come later. Even
    at the beginning, though, you should have a plan for how you are going to find
    the solution.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该明白制定计划总是可能的。确实，如果你还没有在脑海中解决这个问题，那么你无法为在代码中实现解决方案制定计划。那将在以后发生。然而，即使在开始时，你也应该有一个计划，说明你将如何找到解决方案。
- en: To be fair, the plan may require alteration somewhere along the journey, or
    you may have to abandon your original plan and concoct another. Why, then, is
    this rule so important? General Dwight D. Eisenhower was famous for saying, “I
    have always found that plans are useless, but planning is indispensable.” He meant
    that battles are so chaotic that it is impossible to predict everything that could
    happen and have a predetermined response for every outcome. In that sense, then,
    plans are useless on the battlefield (another military leader, the Prussian Helmuth
    von Moltke, famously said that “no plan survives first contact with the enemy”).
    But no army can succeed without planning and organization. Through planning, a
    general learns what his army’s capabilities are, how the different parts of the
    army work together, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，计划可能需要在旅途中进行修改，或者你可能不得不放弃你的原始计划，制定另一个。那么，为什么这条规则如此重要呢？德怀特·D·艾森豪威尔将军因说过，“我总是发现计划是没有用的，但规划是必不可少的。”他的意思是战斗如此混乱，不可能预测可能发生的一切并为每一个结果都有预定的反应。从这个意义上说，那么，计划在战场上是没有用的（另一位军事领导人，普鲁士的赫尔穆特·冯·莫尔特克，著名地说过，“没有计划能在与敌人的第一次接触中存活”）。但没有任何军队可以在没有计划和组织的条件下取得成功。通过规划，将军了解他的军队的能力，了解军队的不同部分是如何协同工作的，等等。
- en: In the same way, you must always have a plan for solving a problem. It may not
    survive first contact with the enemy—it may be discarded as soon as you start
    to type code into your source editor—but you must have a plan.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你必须始终有一个解决问题的计划。这个计划可能无法在第一次接触敌人时就存活下来——你可能在你开始将代码输入到源代码编辑器时就会放弃它——但你必须有一个计划。
- en: 'Without a plan, you are simply hoping for a lucky break, the equivalent of
    the randomly typing monkey producing one of the plays of Shakespeare. Lucky breaks
    are uncommon, and those that occur may still require a plan. Many people have
    heard the story of the discovery of penicillin: A researcher named Alexander Fleming
    forgot to close a petri dish one night and in the morning found that mold had
    inhibited the growth of the bacteria in the dish. But Fleming was not sitting
    around waiting for a lucky break; he had been experimenting in a thorough and
    controlled way and thus recognized the importance of what he saw in the petri
    dish. (If I found mold growing on something I left out the night before, this
    would not result in an important contribution to science.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 没有计划，你只是在寄希望于幸运的突破，这相当于随机打字的猴子能创作出莎士比亚的戏剧。幸运的突破并不常见，即使发生了，也可能仍然需要一个计划。许多人听说过青霉素的发现故事：一位名叫亚历山大·弗莱明的研究员那天晚上忘记关闭一个培养皿，第二天早上发现培养皿中的霉菌抑制了细菌的生长。但弗莱明并没有坐等幸运的突破；他一直在以彻底和有序的方式进行实验，因此认识到了他在培养皿中看到的东西的重要性。（如果我发现我前一天晚上留下的东西上长出了霉菌，这并不会导致对科学的重大贡献。）
- en: 'Planning also allows you to set intermediate goals and achieve them. Without
    a plan, you have only one goal: solve the whole problem. Until you have solved
    the problem, you won’t feel you have accomplished anything. As you have probably
    experienced, many programs don’t do anything useful until they are close to completion.
    Therefore, working only toward the primary goal inevitably leads to frustration,
    as there is no positive reinforcement from your efforts until the end. If instead,
    you create a plan with a series of minor goals, even if some seem tangential to
    the main problem, you will make measurable progress toward a solution and feel
    that your time has been spent usefully. At the end of each work session, you’ll
    be able to check off items from your plan, gaining confidence that you will find
    a solution instead of growing increasingly frustrated.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 计划还允许你设定中间目标并实现它们。没有计划，你只有一个目标：解决整个问题。直到你解决了问题，你才觉得自己完成了什么。正如你可能已经体验到的，许多程序直到接近完成时才做些有用的事情。因此，只朝着主要目标工作不可避免地会导致挫折，因为直到最后，你的努力都没有得到积极的反馈。相反，如果你制定了一个包含一系列小目标的计划，即使其中一些似乎与主要问题无关，你也会朝着解决方案取得可衡量的进步，并觉得你的时间被有效地利用了。在每个工作会话结束时，你将能够从你的计划中勾选项目，增强信心，相信你会找到解决方案，而不是越来越沮丧。
- en: Restate the Problem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新陈述问题
- en: As demonstrated especially by the fox, goose, and corn problem, restating a
    problem can produce valuable results. In some cases, a problem that looks very
    difficult may seem easy when stated in a different way or using different terms.
    Restating a problem is like circling the base of a hill that you must climb; before
    starting your climb, why not check out the hill from every angle to see whether
    there’s an easier way up?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是通过狐狸、鹅和玉米问题所展示的，重新表述一个问题可以产生有价值的结果。在某些情况下，一个看似非常困难的问题，如果用不同的方式或不同的术语来表述，可能会显得容易得多。重新表述一个问题就像环绕着你必须攀登的山丘的基础；在你开始攀登之前，为什么不从每个角度检查一下，看看是否有更简单的方法上去呢？
- en: 'Restatement sometimes shows us the goal was not what we thought it was. I once
    read about a grandmother who was watching over her baby granddaughter while knitting.
    In order to get her knitting done, the grandmother put the baby next to her in
    a portable play pen, but the baby didn’t like being in the pen and kept crying.
    The grandmother tried all sorts of toys to make the pen more fun for the baby,
    until she realized that keeping the baby in the pen was just a means to an end.
    The goal was for the grandmother to be able to knit in peace. The solution: Let
    the baby play happily on the carpet, while the grandmother knits inside the pen.
    Restatement can be a powerful technique, but many programmers will skip it because
    it doesn’t directly involve writing code or even designing a solution. This is
    another reason why having a plan is essential. Without a plan, your only goal
    is to have working code, and restatement is taking time away from writing code.
    With a plan, you can put “formally restate the problem” as your first step; therefore,
    completing the restatement officially counts as progress.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重新表述有时会显示我们的目标并非我们想象的那样。我曾读过一篇关于一位祖母在编织的同时照看她的婴儿外孙女的报道。为了完成编织，祖母将婴儿放在她旁边的便携式游戏围栏里，但婴儿不喜欢被关在围栏里，一直在哭。祖母尝试了各种玩具来让围栏对婴儿更有趣，直到她意识到把婴儿关在围栏里只是达到目的的手段。目标是祖母能够平静地编织。解决方案：让婴儿在地板上快乐地玩耍，而祖母则在围栏里编织。重新表述可以是一种强大的技术，但许多程序员会跳过它，因为它并不直接涉及编写代码，甚至设计解决方案。这也是为什么有一个计划是至关重要的另一个原因。没有计划，你的唯一目标就是有可工作的代码，而重新表述是在浪费时间。有了计划，你可以将“正式重新表述问题”作为第一步；因此，完成重新表述正式算作是进步。
- en: Even if a restatement doesn’t lead to any immediate insight, it can help in
    other ways. For example, if a problem has been assigned to you (by a supervisor
    or an instructor), you can take your restatement to the person who assigned the
    problem and confirm your understanding. Also, restating the problem may be a necessary
    prerequisite step to using other common techniques, like reducing or dividing
    the problem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使重新表述没有立即带来任何洞察力，它也可以以其他方式帮助。例如，如果一个问题已经分配给你（由主管或讲师），你可以将你的重新表述带给分配问题的那个人，并确认你的理解。此外，重新表述问题可能是使用其他常见技术（如简化或分解问题）的必要前提步骤。
- en: More broadly, restatement can transform whole problem areas. The technique I
    employ for recursive solutions, which I share in a later chapter, is a method
    to restate recursive problems so that I can treat them the same as iterative problems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 更广泛地说，重新表述可以改变整个问题领域。我在后面的章节中分享的递归解决方案技术，是一种重新表述递归问题的方法，这样我就可以像处理迭代问题一样处理它们。
- en: Divide the Problem
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解问题
- en: Finding a way to divide a problem into steps or phases can make the problem
    much easier. If you can divide a problem into two pieces, you might think that
    each piece would be half as difficult to solve as the original whole, but usually,
    it’s even easier than that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一种方法将问题分解成步骤或阶段可以使问题变得容易得多。如果你能将一个问题分成两部分，你可能认为每部分解决起来会比原来的整体难一半，但通常，这甚至比那还要容易。
- en: 'Here’s an analogy that will be familiar if you have already seen common sorting
    algorithms. Suppose you have 100 files you need to place in a box in alphabetical
    order, and your basic alphabetizing method is effectively what we call an insertion
    sort: You take one of the files at random, put it in the box, then put the next
    file in the box in the correct relationship to the first file, and then continue,
    always putting the new file in its correct position relative to the other files,
    so that at any given time, the files in the box are alphabetized. Suppose someone
    initially separates the files into 4 groups of roughly equal size, A–F, G–M, N–S,
    and T–Z, and tells you to alphabetize the 4 groups individually and then drop
    them one after the other into the box.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如果你已经看过常见的排序算法就会熟悉的类比。假设你有100个文件需要按字母顺序放入一个盒子中，你的基本排序方法是所谓的插入排序：你随机选择一个文件，放入盒子中，然后按正确的顺序将下一个文件放入盒子中，与第一个文件的关系，然后继续，总是将新文件放入相对于其他文件的正确位置，这样在任何给定时间，盒子中的文件都是按字母顺序排列的。假设有人最初将文件分成4组，大小大致相等，A–F，G–M，N–S，和T–Z，并告诉你分别对这4组进行排序，然后依次将它们放入盒子中。
- en: If each of the groups contained about 25 files, then one might think that alphabetizing
    4 groups of 25 is about the same amount of work as alphabetizing a single group
    of 100\. But it’s actually far *less* work because the work involved in inserting
    a single file grows as the number of files already filed grows—you have to look
    at each file in the box to know where the new file should be placed. (If you doubt
    this, think of a more extreme version—compare the thought of ordering 50 groups
    of 2 files, which you could probably do in under a minute, with ordering a single
    group of 100 files.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个组包含大约25个文件，那么人们可能会认为对4组25个文件进行排序的工作量与对单个100个文件的组进行排序的工作量大致相同。但实际上，工作量要少得多，因为插入单个文件所需的工作量会随着已归档文件数量的增加而增长——你必须查看盒子中的每个文件，才能知道新文件应该放在哪里。（如果你对此表示怀疑，想想一个更极端的版本——比较一下对50组每组2个文件进行排序的想法，你可能在一分钟内就能完成，与对单个100个文件的组进行排序相比。）
- en: In the same way, dividing a problem can often lower the difficulty by an order
    of magnitude. Combining programming techniques is much trickier than using techniques
    alone. For example, a section of code that employs a series of `if` statements
    inside a `while` loop that is itself inside a `for` loop will be more difficult
    to write—and to read—than a section of code that employs all those same control
    statements sequentially.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将问题分解通常可以降低一个数量级的难度。组合编程技术比单独使用技术要复杂得多。例如，一个在`for`循环内部嵌套`while`循环的代码段中使用了多个`if`语句的部分，将比一个使用所有相同控制语句按顺序执行的代码段更难编写——也更难阅读。
- en: We’ll discuss specific ways to divide problems in the chapters that follow,
    but you should always be alert to the possibility. Remember that some problems,
    like our sliding tile puzzle, often hide their potential subdivision. Sometimes
    the way to find a problem’s divisions is to reduce the problem, as we’ll discuss
    shortly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论具体的问题分解方法，但你应该始终保持警惕，注意这种可能性。记住，有些问题，比如我们的滑动拼图问题，通常隐藏着它们的潜在分解。有时，找到问题分解的方法是减少问题，正如我们很快将要讨论的。
- en: Start with What You Know
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从你所知开始
- en: First-time novelists are often given the advice “write what you know.” This
    doesn’t mean that novelists should try only to craft works around incidents and
    people they have directly observed in their own lives; if this were the case,
    we could never have fantasy novels, historical fiction, or many other popular
    genres. But it means that the further away a writer gets from his or her own experience,
    the more difficult writing may be.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次写作小说的人经常得到这样的建议：“写你所知。”这并不意味着小说家应该只尝试围绕他们在自己生活中直接观察到的事件和人来创作作品；如果是这样的话，我们就永远不会有幻想小说、历史小说或许多其他流行体裁。但它的意思是，作家离自己的经历越远，写作可能就越困难。
- en: In the same way, when programming, you should try to start with what you already
    know how to do and work outward from there. Once you have divided the problem
    up into pieces, for example, go ahead and complete any pieces you already know
    how to code. Having a working partial solution may spark ideas about the rest
    of the problem. Also, as you may have noticed, a common theme in problem solving
    is making useful progress to build confidence that you will ultimately complete
    the task. By starting with what you know, you build confidence and momentum toward
    the goal.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在编程时，你应该尝试从你已知如何做的事情开始，并从这里向外扩展。一旦你将问题分解成几个部分，例如，你可以先完成你已知如何编码的部分。拥有一个可工作的部分解决方案可能会激发对剩余问题的想法。此外，正如你可能已经注意到的，问题解决中的一个共同主题是通过有用的进展来建立信心，相信你最终会完成任务。通过从你所知开始，你建立信心并积累动力，朝着目标前进。
- en: 'The “start with what you know” maxim also applies in cases where you haven’t
    divided the problem. Imagine someone made a complete list of every skill in programming:
    writing a C++ class, sorting a list of numbers, finding the largest value in a
    linked list, and so on. At every point in your development as a programmer, there
    will be many skills on this list that you can do well, other skills you can use
    with effort, and then the other skills that you don’t yet know. A particular problem
    may be entirely solvable with the skills you already have or it may not, but you
    should fully investigate the problem using the skills already in your head before
    looking elsewhere. If we think of programming skills as tools and a programming
    problem as a home repair project, you should try to make the repair using the
    tools already in your garage before heading to the hardware store.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: “从你所知开始”的原则也适用于你没有分解问题的情形。想象一下，有人列出了编程中所有技能的完整清单：编写C++类、排序数字列表、在链表中找到最大值等等。在你作为程序员的每个发展阶段，你都会有很多你做得好的技能，一些你努力就能使用的技能，以及你还不了解的技能。特定的问题可能完全可以用你已有的技能来解决，也可能不行，但在你四处寻找答案之前，你应该充分利用你头脑中的技能来彻底调查这个问题。如果我们把编程技能看作是工具，把编程问题看作是家庭维修项目，你应该在前往五金店之前，先尝试使用车库里的工具来完成维修。
- en: This technique follows the principles we have already discussed. It follows
    a plan and gives order to our efforts. When we begin our investigation of a problem
    by applying the skills we already have, we may learn more about the problem and
    its ultimate solution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术遵循我们之前讨论的原则。它遵循一个计划，并为我们的努力提供秩序。当我们开始通过应用我们已有的技能来调查问题时，我们可能会对问题及其最终解决方案有更多的了解。
- en: Reduce the Problem
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化问题
- en: With this technique, when faced with a problem you are unable to solve, you
    reduce the scope of the problem, by either adding or removing constraints, to
    produce a problem that you do know how to solve. We’ll see this technique in action
    in later chapters, but here’s a basic example. Suppose you are given a series
    of coordinates in three-dimensional space, and you must find the coordinates that
    are closest to each other. If you don’t immediately know how to solve this, there
    are different ways you could reduce the problem to seek a solution. For example,
    what if the coordinates are in two-dimensional space, instead of three-dimensional
    space? If that doesn’t help, what if the points lie along a single line so that
    the coordinates are just individual numbers (C++ doubles, let’s say)? Now the
    question essentially becomes, in a list of numbers, find the two numbers with
    the minimum absolute difference.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，当你面对一个无法解决的问题时，你可以通过添加或移除约束来缩小问题范围，从而产生一个你知道如何解决的问题。我们将在后面的章节中看到这个技术的实际应用，但这里有一个基本的例子。假设你被给出了一系列三维空间中的坐标，你必须找到彼此最接近的坐标。如果你立刻不知道如何解决这个问题，你可以用不同的方法来简化问题以寻求解决方案。例如，如果这些坐标是在二维空间而不是三维空间中呢？如果这还不行，如果这些点沿一条直线排列，那么坐标就只是单个数字（比如说C++的double类型）呢？现在问题本质上变成了，在数字列表中找到两个绝对差值最小的数字。
- en: Or you could reduce the problem by keeping the coordinates in three-dimensional
    space but have only three values, instead of an arbitrary-sized series. So instead
    of an algorithm to find the smallest distance between any two coordinates, it’s
    just a question of comparing coordinate A to coordinate B, then B to C, and then
    A to C.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过保持坐标在三维空间中，但只有三个值，而不是任意大小的系列来简化问题。所以，不是找到一个坐标对之间最小距离的算法，而只是比较坐标A与坐标B，然后是B与C，最后是A与C。
- en: These reductions simplify the problem in different ways. The first reduction
    eliminates the need to compute the distance between three-dimensional points.
    Maybe we don’t know how to do that yet, but until we figure that out, we can still
    make progress toward a solution. The second reduction, by contrast, focuses almost
    entirely on computing the distance between three-dimensional points but eliminates
    the problem of finding a minimal value in an arbitrary-sized series of values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简化方法以不同的方式简化问题。第一种简化方法消除了计算三维点之间距离的需要。也许我们还没有学会如何做这件事，但直到我们弄清楚这一点，我们仍然可以朝着解决方案取得进展。相比之下，第二种简化方法几乎完全集中在计算三维点之间的距离上，但消除了在任意大小的值序列中找到最小值的问题。
- en: Of course, to solve the original problem, we will eventually need the skills
    involved in both reductions. Even so, reduction allows us to work on a simpler
    problem even when we can’t find a way to divide the problem into steps. In effect,
    it’s like a deliberate, but temporary, Kobayashi Maru. We know we’re not working
    on the full problem, but the reduced problem has enough in common with the full
    problem that we will make progress toward the ultimate solution. Many times, programmers
    discover they have all the individual skills necessary to solve the problem, and
    by writing code to solve each individual aspect of the problem, they see how to
    combine the various pieces of code into a unified whole.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了解决原始问题，我们最终需要两种简化方法中涉及的技能。即便如此，简化方法仍然允许我们在无法找到将问题分解为步骤的方法时，对更简单的问题进行工作。实际上，这就像是一个故意但暂时的Kobayashi
    Maru。我们知道我们并没有在处理完整的问题，但简化问题与完整问题有足够的共同点，这样我们就能朝着最终解决方案取得进展。很多时候，程序员会发现他们拥有解决该问题所需的所有个别技能，通过编写代码来解决问题的每个个别方面，他们可以看到如何将各种代码片段组合成一个统一的整体。
- en: Reducing the problem also allows us to pinpoint exactly where the remaining
    difficulty lies. Beginning programmers often need to seek out experienced programmers
    for assistance, but this can be a frustrating experience for everyone involved
    if the struggling programmer is unable to accurately describe the help that is
    needed. One never wants to be reduced to saying, “Here’s my program, and it doesn’t
    work. Why not?” Using the problem-reduction technique, one can pinpoint the help
    needed, saying something like, “Here’s some code I wrote. As you can see, I know
    how to find the distance between two three-dimensional coordinates, and I know
    how to check whether one distance is less than another. But I can’t seem to find
    a general solution for finding the pair of coordinates with the minimum distance.”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简化问题还允许我们精确地确定剩余困难所在的位置。初学者程序员经常需要寻求经验丰富的程序员的帮助，但如果遇到困难的程序员无法准确描述所需帮助，这可能会对所有人都是一个令人沮丧的经历。没有人愿意降低到说，“这是我的程序，它不起作用。为什么？”使用问题简化技术，一个人可以精确地确定所需帮助，比如说，“这里有一些我写的代码。正如你所看到的，我知道如何找到两个三维坐标之间的距离，也知道如何检查一个距离是否小于另一个。但我似乎找不到一个通用的解决方案来找到具有最小距离的坐标对。”
- en: Look for Analogies
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找类比
- en: An *analogy*, for our purposes, is a similarity between a current problem and
    a problem already solved that can be exploited to help solve the current problem.
    The similarity may take many forms. Sometimes it means the two problems are really
    the same problem. This is the situation we had with the fox, goose, and corn problem
    and the Quarrasi lock problem.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的目的中，**类比**是指当前问题与已经解决的问题之间的相似性，这种相似性可以被利用来帮助解决当前问题。这种相似性可以采取多种形式。有时这意味着两个问题实际上是同一个问题。这就是我们处理狐狸、鹅和玉米问题以及Quarrasi锁问题的情形。
- en: Most analogies are not that direct. Sometimes the similarity concerns only part
    of the problems. For example, two number-processing problems might be different
    in all aspects except that both of them work with numbers requiring more precision
    than that given by built-in floating point data types; you won’t be able to use
    this analogy to solve the whole problem, but if you’ve already figured out a way
    to handle the extra precision issue, you can handle that same issue the same way
    again.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类比并不那么直接。有时相似性只涉及问题的部分。例如，两个数字处理问题可能在所有方面都不同，除了它们都处理需要比内置浮点数据类型提供的精度更高的数字；你将无法使用这个类比来解决整个问题，但如果你已经找到了处理额外精度问题的方法，你可以以相同的方式再次处理相同的问题。
- en: Although recognizing analogies is the most important way you will improve your
    speed and skill at problem solving, it is also the most difficult skill to develop.
    The reason it is so difficult at first is that you can’t look for analogies until
    you have a storehouse of previous solutions to reference.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然识别类比是提高你解决问题速度和技能的最重要方式，但它也是最难培养的技能。之所以一开始这么困难，是因为你必须在参考之前有一个先前解决方案的仓库来寻找类比。
- en: This is where developing programmers often try to take a shortcut, finding code
    that is similar to the needed code and modifying from there. For several reasons,
    though, this is a mistake. First, if you don’t complete a solution yourself, you
    won’t have fully understood and internalized it. Put simply, it’s very difficult
    to correctly modify a program that you don’t fully understand. You don’t need
    to have written code to fully understand, but if you could not have written the
    code, your understanding will be necessarily limited. Second, every successful
    program you write is more than a solution to a current problem; it’s a potential
    source of analogies to solve future problems. The more you rely on other programmers’
    code now, the more you will have to rely on it in the future. We’ll talk in depth
    about “good reuse” and “bad reuse” in [Chapter 7](ch07.html "Chapter 7. Solving
    Problems with Code Reuse").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是开发中的程序员常常试图走捷径的地方，他们寻找与所需代码相似的代码，并从那里进行修改。然而，由于几个原因，这实际上是一个错误。首先，如果你没有自己完成解决方案，你就不会完全理解和内化它。简单来说，很难正确修改一个你不完全理解的程序。你不需要亲自编写代码就能完全理解，但如果你不能编写代码，你的理解必然是有限的。其次，你编写的每一个成功的程序都不仅仅是对当前问题的解决方案；它也是解决未来问题的类比潜在来源。你现在越依赖其他程序员的代码，将来你就越需要依赖它。我们将在第7章（[第7章](ch07.html
    "第7章. 使用代码复用来解决问题"））深入讨论“好的复用”和“坏的复用”。
- en: Experiment
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: Sometimes the best way to make progress is to try things and observe the results.
    Note that experimentation is not the same as guessing. When you guess, you type
    some code and hope that it works, having no strong belief that it will. An experiment
    is a controlled process. You hypothesize what will happen when certain code is
    executed, try it out, and see whether your hypothesis is correct. From these observations,
    you gain information that will help you solve the original problem.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，取得进展的最佳方式是尝试并观察结果。请注意，实验与猜测不同。当你猜测时，你输入一些代码并希望它能够工作，但你并没有强烈的信念认为它会成功。实验是一个受控的过程。你假设当执行某些代码时会发生什么，然后尝试它，看看你的假设是否正确。从这些观察中，你获得的信息将帮助你解决原始问题。
- en: Experimentation may be especially helpful when dealing with application programming
    interfaces or class libraries. Suppose you are writing a program that uses a library
    class representing a vector (in this context, a one-dimensional array that automatically
    grows as more items are added), but you’ve never used this vector class before,
    and you’re not sure what happens when an item is deleted from the vector. Instead
    of forging ahead with solving the original problem while uncertainties swirl inside
    your head, you could create a short, separate program just to play around with
    the vector class and to specifically try out the situations that concern you.
    If you spend a little time on the “vector demonstrator” program, it might become
    a reference for future work with the class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理应用程序编程接口或类库时，实验可能特别有帮助。假设你正在编写一个使用表示向量的库类的程序（在这个上下文中，是一个随着添加更多项目而自动增长的二维数组），但你以前从未使用过这个向量类，你不确定从向量中删除项目会发生什么。与其在心中充满不确定性时继续解决原始问题，不如创建一个简短的、独立的程序来与向量类玩耍，并特别尝试你关心的情况。如果你在“向量演示”程序上花一点时间，它可能会成为未来使用该类的工作的参考。
- en: Other forms of experimentation are similar to debugging. Suppose a certain program
    is producing output that is backward from expectations—for example, if the output
    is numerical, the numbers are as expected, but in the reverse order. If you don’t
    see why this is occurring after reviewing your code, as an experiment, you might
    try modifying the code to deliberately make the output backward (run a loop in
    the reverse direction, perhaps). The resulting change, or lack of change, in the
    output may reveal the problem in your original source code or may reveal a gap
    in your understanding. Either way, you’re closer to a solution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其他形式的实验与调试类似。假设某个程序产生的输出与预期相反——例如，如果输出是数值的，数字是预期的，但顺序相反。如果你在审查你的代码后仍然不明白为什么会这样，作为一个实验，你可能尝试修改代码以故意使输出相反（例如，以相反方向运行循环）。输出结果的变化或变化不足可能会揭示你原始源代码中的问题，或者揭示你理解上的差距。无论如何，你离解决方案更近了。
- en: Don’t Get Frustrated
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要感到沮丧
- en: 'The final technique isn’t so much a technique, but a maxim: Don’t get frustrated.
    When you are frustrated, you won’t think as clearly, you won’t work as efficiently,
    and everything will take longer and seem harder. Even worse, frustration tends
    to feed on itself, so that what begins as mild irritation ends as outright anger.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种技巧与其说是一种技巧，不如说是一条格言：不要感到沮丧。当你感到沮丧时，你不会思考得那么清晰，你不会工作得那么高效，一切都会花费更长的时间，看起来更困难。更糟糕的是，挫败感往往会自我滋养，所以一开始可能是轻微的不满，最终会变成直接的愤怒。
- en: When I give this advice to new programmers, they often retort that while they
    agree with my point in principle, they have no control over their frustrations.
    Isn’t asking a programmer not to get frustrated at lack of success like asking
    a little boy not to yell out if he steps on a tack? The answer is no. When someone
    steps on a tack, a strong signal is immediately sent through the central nervous
    system, where the lower depths of the brain respond. Unless you know you’re about
    to step on the tack, it’s impossible to react in time to countermand the automatic
    response from the brain. So we’ll let the little boy off the hook for yelling
    out.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我向新程序员提出这些建议时，他们经常反驳说，虽然他们在原则上同意我的观点，但他们无法控制自己的挫败感。要求程序员在失败时不要感到沮丧，这不就像要求一个小男孩踩到刺上时不要喊叫一样吗？答案是否定的。当有人踩到刺上时，强烈的信号会立即通过中枢神经系统传递，大脑的底层会做出反应。除非你知道你即将踩到刺上，否则你不可能及时反应来阻止大脑的自动反应。所以，我们让这个小男孩因为喊叫而免受责备。
- en: The programmer is not in the same boat. At the risk of sounding like a self-help
    guru, a frustrated programmer isn’t responding to an external stimulus. The frustrated
    programmer isn’t angry with the source code on the monitor, although the programmer
    may express the frustration in those terms. Instead, the frustrated programmer
    is angry at himself or herself. The source of the frustration is also the destination,
    the programmer’s mind.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员并不处于同样的境地。冒着听起来像自我帮助大师的风险，一个沮丧的程序员并不是对外部刺激做出反应。沮丧的程序员并不是对显示器上的源代码感到愤怒，尽管程序员可能会用这种方式表达挫败感。相反，沮丧的程序员是在生自己的气。挫败感的来源也是目的地，程序员的思维。
- en: When you allow yourself to get frustrated—and I use the word “allow” deliberately—you
    are, in effect, giving yourself an excuse to continue to fail. Suppose you’re
    working on a difficult problem and you feel your frustration rise. Hours later,
    you look back at an afternoon of gritted teeth and pencils snapped in anger and
    tell yourself that you would have made real progress if you had been able to calm
    down. In truth, you may have decided that giving in to your anger was easier than
    facing the difficult problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你让自己感到沮丧——我故意使用“允许”这个词——实际上你是在给自己一个继续失败的理由。假设你正在解决一个难题，你感到自己的挫败感在上升。几个小时后，你回想起一个下午咬紧牙关、愤怒地折断铅笔的画面，告诉自己，如果你能冷静下来，你本可以取得真正的进展。事实上，你可能已经决定，屈服于愤怒比面对难题更容易。
- en: Ultimately, then, avoiding frustration is a decision you must make. However,
    there are some thoughts you can employ that will help. First of all, never forget
    the first rule, that you should always have a plan, and that while writing code
    that solves the original problem is the goal of that plan, it is not the only
    step of that plan. Thus, if you have a plan and you’re following it, then you
    are making progress and you must believe this. If you’ve run through all the steps
    on your original plan and you’re still not ready to start coding, then it’s time
    to make another plan.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，避免挫败感是一个你必须做出的决定。然而，有一些想法你可以采用，这将有助于你。首先，永远不要忘记第一条规则，那就是你应该始终有一个计划，并且虽然编写解决原始问题的代码是这个计划的目标，但这并不是计划的唯一步骤。因此，如果你有一个计划并且正在遵循它，那么你正在取得进步，你必须相信这一点。如果你已经完成了原始计划上的所有步骤，但你仍然没有准备好开始编码，那么是时候制定另一个计划了。
- en: 'Also, when it comes down to getting frustrated or taking a break, you should
    take a break. One trick is to have more than one problem to work on so that if
    this one problem has you stymied, you can turn your efforts elsewhere. Note that
    if you successfully divide the problem, you can use this technique on a single
    problem; just block out the part of the problem that has you stuck, and work on
    something else. If you don’t have another problem you can tackle, get out of your
    chair and do something else, something that keeps your blood flowing but doesn’t
    make your brain hurt: Take a walk, do the laundry, go through your stretching
    routine (if you’re signing up to be a programmer, sitting at a computer all day,
    I highly recommend developing a stretching routine!). Don’t think about the problem
    until your break is over.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当涉及到挫败感或休息时，你应该选择休息。一个技巧是同时处理多个问题，这样如果这个问题让你感到困惑，你就可以把精力转向其他地方。注意，如果你成功地分解了问题，你可以在单个问题上使用这个技巧；只需屏蔽让你卡住的部分，然后做其他事情。如果你没有其他问题可以解决，就离开椅子去做其他事情，做一些能让你的血液流动但不会让你的大脑受伤的事情：散步，洗衣服，进行拉伸练习（如果你打算成为一名程序员，整天坐在电脑前，我强烈建议你发展一个拉伸练习的习惯！）。直到休息结束之前，不要思考问题。
- en: Exercises
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Remember, to truly learn something you have to put it into practice, so work
    as many exercises as you can. In this first chapter, of course, we’re not yet
    discussing programming, but even so, I encourage you to try some exercises out.
    Think of these questions as warm-ups for your fingers before we start playing
    the real music.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，要真正学会某样东西，你必须将其付诸实践，所以尽可能多地做练习。当然，在这一章中，我们还没有讨论编程，但即便如此，我也鼓励你尝试一些练习。想想这些问题是我们开始演奏真正的音乐之前为你的手指做热身。
- en: Try a medium-difficulty sudoku puzzle (you can find these all over the Web and
    probably in your local newspaper), experimenting with different strategies and
    taking note of the results. Can you write a general plan for solving a sudoku?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一个中等难度的数独谜题（你可以在网上找到这些，也许在当地报纸上也能找到），尝试不同的策略并记录结果。你能为解决数独制定一个通用计划吗？
- en: Consider a sliding tile puzzle variant where the tiles are covered with a picture
    instead of numbers. How much does this increase the difficulty, and why?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个滑动拼图变体，其中瓷砖上覆盖的是图片而不是数字。这增加了多少难度，为什么？
- en: Find a strategy for sliding tile puzzles different from mine.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个与我不同的滑动拼图策略。
- en: Search for old-fashioned puzzles of the fox, goose, and corn variety and try
    to solve them. Many of the great puzzles were originated or popularized by Sam
    Loyd, so you might search for his name. Furthermore, once you uncover (or give
    up and read) the solution, think of how you could make an easier version of the
    puzzle. What would you have to change? The constraints or just the wording?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找传统的狐狸、鹅和玉米品种的谜题，并尝试解决它们。许多伟大的谜题都是由萨姆·洛伊德（Sam Loyd）原创或普及的，所以你可能需要搜索他的名字。此外，一旦你发现了（或放弃并阅读）解决方案，想想你如何可以制作一个更容易的谜题版本。你需要改变什么？是限制条件还是只是措辞？
- en: Try to write some explicit strategies for other traditional pencil-and-paper
    games, like crosswords. Where should you start? What should you do when you’re
    stuck? Even simple newspaper games, like “Jumble,” are useful for contemplating
    strategy.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试为其他传统的纸笔游戏编写一些明确的策略，比如填字游戏。你应该从哪里开始？当你卡住时应该做什么？即使是像“Jumble”这样的简单报纸游戏，对于思考策略也是很有用的。
