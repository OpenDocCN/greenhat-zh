- en: Chapter 5. HANDLE MAP EVENTS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：处理地图事件
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Web-based maps are highly interactive. They make users want to drag them, click
    them, and zoom them. That's all part of the fun, but this interactivity also makes
    them more useful. By tapping into this interactivity, you can design those little
    user movements to provide an even better interface; for instance, changing the
    visible markers when users drag the map or changing the search radius along with
    the zoom level.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的地图高度交互。它们使用户想要拖动、点击和缩放地图。这些都是乐趣的一部分，但这种交互性也使它们更有用。通过利用这种交互性，你可以设计那些小小的用户动作，以提供更好的界面；例如，当用户拖动地图时更改可见标记，或者随着缩放级别改变搜索半径。
- en: Events control all the potential ways a user can interact with your map. You
    can run special code any time a user drags the map, zooms in, or clicks. Events
    are also specific to markers, message boxes, and polylines. Read on for a quick
    introduction to the way Mapstraction organizes events and for examples of each.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 事件控制了用户与您的地图交互的所有潜在方式。用户拖动地图、放大或点击时，您都可以运行特殊代码。事件也针对标记、消息框和多段线。继续阅读，了解 Mapstraction
    组织事件的方式以及每个事件的示例。
- en: Mapstraction's Event Model
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mapstraction 的事件模型
- en: Events happen, regardless of whether we're paying attention. To be able to react
    to an event, we need to tell Mapstraction that we care about that particular event.
    We do this by setting a function for Mapstraction to call when an event happens.
    This function is called a *handler*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发生，无论我们是否关注。为了能够对事件做出反应，我们需要告诉 Mapstraction 我们关心那个特定的事件。我们通过为 Mapstraction
    在事件发生时调用的函数设置一个函数来实现这一点。这个函数被称为 *handler*。
- en: 'To create an event handler, we need to know the event type we''re looking for
    and the object from which the event will be originating. We register our interest
    in the event using the following form:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建事件处理器，我们需要知道我们正在寻找的事件类型以及事件将从中起源的对象。我们使用以下形式注册我们对事件的兴趣：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The potential events that can occur for each object are shown in [Table 5-1](ch05.html#objects_and_their_events
    "Table 5-1. Objects and Their Events"). The `addHandler` function accepts one
    argument—a reference to a function that will handle the event. In the case of
    the previous example, and most examples in this chapter, I'm using an anonymous,
    inline function. You can also use named functions, as I do in most examples that
    involve markers. If you are going to call the same function on many objects, you'll
    find it more memory efficient to use a named function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象可能发生的事件潜力在 [表 5-1](ch05.html#objects_and_their_events "表 5-1. 对象及其事件") 中显示。`addHandler`
    函数接受一个参数——一个引用到将处理事件的函数。在前面示例以及本章中的大多数示例中，我使用的是匿名内联函数。您也可以使用命名函数，就像我在涉及标记的大多数示例中所做的那样。如果您要在许多对象上调用相同的函数，使用命名函数将发现更节省内存。
- en: 'Whether you use an anonymous or named function to handle events, however, the
    function accepts three arguments: an event name, an event source, and additional
    event arguments. Those values are passed automatically by Mapstraction. The name
    will always be the same as *event*, whereas the source will always be the *object*.
    Additional data, if it exists, is included in the arguments object.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用匿名函数还是命名函数来处理事件，该函数都接受三个参数：事件名称、事件源和额外的事件参数。这些值由 Mapstraction 自动传递。名称将始终与
    *event* 相同，而源将始终是 *object*。如果存在，附加数据将包含在参数对象中。
- en: Table 5-1. Objects and Their Events
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1. 对象及其事件
- en: '| Object | Event |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 事件 |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Mapstraction` | `click` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `click` |'
- en: '| `Mapstraction` | `endPan` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `endPan` |'
- en: '| `Mapstraction` | `changeZoom` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `changeZoom` |'
- en: '| `Mapstraction` | `markerAdded` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `markerAdded` |'
- en: '| `Mapstraction` | `markerRemoved` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `markerRemoved` |'
- en: '| `Mapstraction` | `polylineAdded` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `polylineAdded` |'
- en: '| `Mapstraction` | `polylineRemoved` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Mapstraction` | `polylineRemoved` |'
- en: '| `Marker` | `click` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `Marker` | `click` |'
- en: '| `Marker` | `openInfoBubble` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `Marker` | `openInfoBubble` |'
- en: Each event is covered in depth in the sections of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各个部分都深入探讨了每个事件。
- en: '#27: The User Clicks the Map'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#27：用户点击地图'
- en: Out-of-the-box interactivity makes mapping APIs pretty special. Using built-in
    controls, users can drag and pan a map, zoom in, and change map types. Users can
    also click, but nothing will happen unless you help them out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用的交互性使地图 API 非常特别。使用内置控件，用户可以拖动和移动地图、放大并更改地图类型。用户也可以点击，但除非您帮助他们，否则不会发生任何事情。
- en: Mapstraction's click event is what reacts to a user's click. Unlike some other
    events shown in this chapter, knowing that your users clicked is not enough. You
    need to know *where* they clicked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction 的点击事件是响应用户点击的。与本章中展示的其他一些事件不同，仅仅知道用户点击了是不够的。你需要知道他们点击了*哪里*。
- en: 'To find out when and where a user clicks, add the following code to your `create_map`
    function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出用户何时何地点击，请将以下代码添加到你的 `create_map` 函数中：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we add a handler for Mapstraction's `click` event. To react to this event,
    I've used an anonymous inline function. If you have more than a couple lines of
    code to run, you'll want to use a standard named function, because long anonymous
    functions are hard to read. I'm pushing the limits here.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 Mapstraction 的 `click` 事件添加了一个处理程序。为了响应这个事件，我使用了一个匿名内联函数。如果你有超过几行代码要运行，你将想要使用一个标准的命名函数，因为长的匿名函数很难阅读。我在这里正在挑战极限。
- en: 'When the user clicks anywhere within the map, Mapstraction calls our function
    with three pieces of data, the last of which contains the event arguments. The
    key piece of information we want is inside those arguments: the click location,
    which is stored as a `LatLonPoint`. The previous example uses that point to create
    a new marker.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在地图的任何地方点击时，Mapstraction 会调用我们的函数，并传递三份数据，其中最后一份数据包含事件参数。我们想要的关键信息就在这些参数中：点击位置，它被存储为
    `LatLonPoint`。上一个例子就是使用这个点来创建一个新的标记。
- en: Each click adds another marker to the map. Do this a few times and your map
    will look something like [Figure 5-1](ch05s03.html#each_click_adds_a_new_marker
    "Figure 5-1. Each click adds a new marker.").
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击都会在地图上添加另一个标记。这样做几次，你的地图看起来就会像[图 5-1](ch05s03.html#each_click_adds_a_new_marker
    "图 5-1. 每次点击都会添加一个新的标记。")那样。
- en: '#28: The User Drags the Map'
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#28: 用户拖动地图'
- en: If you're a developer who likes to be in control, you may not immediately appreciate
    the interactivity of maps. Users can move the viewable portion of a map to wherever
    they want, forgoing your perfectly designed experience. What a drag! In fact,
    literally a drag, as the user drags the map this way and that. You can use an
    event, however, to help you gain back a little of that control.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个喜欢控制的开发者，你可能不会立即欣赏地图的交互性。用户可以将地图的可视部分移动到他们想要的位置，从而放弃你精心设计的体验。多么令人沮丧啊！实际上，字面上来说就是令人沮丧，因为用户会这样拖动地图。然而，你可以使用一个事件来帮助你恢复一点控制。
- en: You can write code to react to a even the smallest movement of the map. You
    can use this to force the map back to where you put it, if that's what you prefer.
    A more friendly reaction is to find a way to recognize the area of the map where
    the user moved. For example, if you are showing search results, try reloading
    them with the new center.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写代码来响应地图的最小移动。你可以使用这个来强制地图回到你放置的位置，如果你喜欢这样做的话。一个更友好的反应是找到一种方法来识别用户移动的地图区域。例如，如果你正在显示搜索结果，尝试用新的中心重新加载它们。
- en: '![Each click adds a new marker.](httpatomoreillycomsourcenostarchimages672037.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![每次点击都会添加一个新的标记。](httpatomoreillycomsourcenostarchimages672037.png.jpg)'
- en: Figure 5-1. Each click adds a new marker.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1. 每次点击都会添加一个新的标记。
- en: 'For this example, we''ll merely create a JavaScript alert whenever we notice
    the map has moved. And how do we know when a map has moved? Add these lines to
    your basic map:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将简单地创建一个 JavaScript 警告，每当我们发现地图已经移动时。那么我们如何知道地图已经移动了呢？请将这些行添加到你的基本地图中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we add a handler for Mapstraction's `endPan` event. To react to this event,
    I've used an anonymous inline function. If you have more than a couple lines of
    code to run, you'll want to use a standard named function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 Mapstraction 的 `endPan` 事件添加了一个处理程序。为了响应这个事件，我使用了一个匿名内联函数。如果你有超过几行代码要运行，你将想要使用一个标准的命名函数。
- en: With this code implemented, any time the user moves the map, this event will
    fire, and the alert box will pop up. Programmatically setting the center will
    also trigger the event because the map has been panned (just not directly by the
    user). The event does not fire when you initially set the center of the map, however,
    only because that code comes before Mapstraction knows to look out for map movement.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这段代码后，每次用户移动地图时，这个事件都会触发，并且会弹出警告框。程序性地设置中心也会触发事件，因为地图已经被平移（尽管不是直接由用户操作）。然而，当你最初设置地图中心时，事件不会触发，这仅仅是因为那段代码在
    Mapstraction 知道要关注地图移动之前就已经执行了。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With some providers, such as Google, the `endPan` event will also be triggered
    when the zoom level changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些提供者，例如 Google，当缩放级别改变时，也会触发 `endPan` 事件。
- en: 'As soon as the `endPan` event fires, you''ll have access to the current map
    data, such as the center, via the Mapstraction object. Here''s an example that
    creates a new marker at the new center whenever the user drags the map:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`endPan`事件触发，你将可以通过Mapstraction对象访问当前地图数据，例如中心点。以下是一个示例，每当用户拖动地图时，都会在新的中心创建一个新的标记：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Enter this into your basic map's `create_map` function, and load it into a browser.
    Try moving the map and each time you'll find a brand new marker at its center.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码输入到你的基本地图的`create_map`函数中，并在浏览器中加载它。尝试移动地图，每次你都会在中心找到一个全新的标记。
- en: '#29: The Zoom Level Changes'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#29：缩放级别变化'
- en: '"Let''s take a closer look," she thinks, clicking the plus-sign button to zoom
    closer into the map. Assuming you provide the interface to do so, your users will
    be doing a lot of zooming in and zooming out. In some maps, reacting to those
    sometimes drastic changes in the map''s bounds is important, which is where Mapstraction''s
    zoom event can be your best friend.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们仔细看看吧,"她心想，点击加号按钮将地图放大。假设你提供了这样的界面，你的用户将会进行大量的放大和缩小操作。在一些地图中，对地图边界有时剧烈变化做出反应是很重要的，这就是Mapstraction的缩放事件能成为你最好朋友的地方。'
- en: You can make your map handle the zoom event and do something useful, such as
    reset your search radius. Or, as shown later in this chapter, determine whether
    the user moves the map outside preset bounds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让你的地图处理缩放事件并执行一些有用的操作，比如重置你的搜索半径。或者，如本章后面所示，确定用户是否将地图移动到预设边界之外。
- en: 'For this example, we''ll create a JavaScript alert whenever the map is zoomed,
    so you can get a feeling for when this event is triggered. Add the following code
    to your basic map''s `create_map` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将在地图缩放时创建一个JavaScript弹窗，这样你可以感受到这个事件何时被触发。将以下代码添加到你的基本地图的`create_map`函数中：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we add a handler for Mapstraction's `changeZoom` event. To react to this
    event, I've used an anonymous inline function. If you have more than a couple
    lines of code to run, you'll want to use a standard named function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为Mapstraction的`changeZoom`事件添加了一个处理程序。为了响应此事件，我使用了一个匿名内联函数。如果你有超过几行代码要运行，你将想要使用一个标准的命名函数。
- en: Try loading your map with this code included. Change the zoom on your map a
    few times, and watch it respond. If your provider interprets a double-click as
    a zoom in (and most do), try that, too. Your users won't be able to zoom in or
    out without you knowing about it!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试加载包含此代码的地图。在地图上改变缩放几次，并观察其响应。如果你的提供商将双击解释为放大（大多数都是这样），也试试这个。你的用户在没有你了解的情况下无法放大或缩小！
- en: 'Do you want to respond with something a little more useful? How about an alert
    displaying the new zoom level? Try the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你想用更有用的事情来响应吗？比如显示新的缩放级别？尝试以下代码：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, each time your users zoom in or out, a message doesn't just say that the
    zoom level changed; it also shows the new zoom level. If your map has large zoom
    controls, try zooming in quickly from your current level to one very close in
    or try zooming extremely far out. An alert will pop up with the new zoom level
    number. If you'd like to make more sense of zoom levels, see [Set Zoom Level](ch01s07.html
    "Set Zoom Level") in [Set Zoom Level](ch01s07.html "Set Zoom Level").
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你的用户放大或缩小，消息不仅会说缩放级别已更改；还会显示新的缩放级别。如果你的地图有大的缩放控件，尝试从当前级别快速放大到一个非常接近的级别，或者尝试极度缩小。一个带有新缩放级别数字的弹窗将会弹出。如果你想更好地理解缩放级别，请参阅[设置缩放级别](ch01s07.html
    "设置缩放级别")。
- en: '#30: A Marker Is Added to or Removed from the Map'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#30：标记被添加到或从地图中移除'
- en: Markers, markers everywhere. Once your mapping application becomes large, you
    might be adding markers from many different areas of your code. The same could
    be true of removing markers. You can take advantage of two events that will call
    a function you specify when a marker is added or removed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 标记无处不在。一旦你的映射应用程序变得庞大，你可能需要从代码的许多不同区域添加标记。移除标记也可能如此。你可以利用两个事件，当标记被添加或移除时，将调用你指定的函数。
- en: 'Add the following code to your basic map''s `create_map` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的基本地图的`create_map`函数中：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Of course, using a JavaScript alert to let the user know a marker has been added
    or removed is probably not that helpful. Instead, you might update your own metadata
    on markers or autocenter the map based on the new or remaining markers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用JavaScript弹窗来通知用户标记已被添加或移除可能并不那么有帮助。相反，你可能更新自己的标记元数据或根据新的或剩余的标记自动居中地图。
- en: You can access the affected marker via the `event_args` object, which contains
    one property called `marker`. You may find it more intuitive to access the marker
    from the `event_source` object. Though these events are related to markers, they
    are initiated by the Mapstraction object, which is passed as the source.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`event_args`对象访问受影响的标记，该对象包含一个名为`marker`的属性。你可能觉得从`event_source`对象访问标记更直观。尽管这些事件与标记相关，但它们是由Mapstraction对象发起的，该对象作为源传递。
- en: Because the only way to add or remove markers is through your code, plenty of
    other non-event-based ways available to perform an action when a marker is added
    or removed. As mentioned, you might only find this useful if you have a large
    application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为添加或删除标记的唯一方式是通过你的代码，所以有大量其他非事件驱动的方法可以在添加或删除标记时执行操作。正如提到的，你可能只有在大型应用程序中才会觉得这很有用。
- en: '#31: A Polyline Is Added to or Removed from the Map'
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#31：向地图添加或从地图移除折线'
- en: Do you use lots of polylines on your maps? You can use an event to run a special
    function every time you add or remove a polyline. This feature is especially useful
    for large mapping applications, where many different places create new lines or
    when you need to nix unnecessary ones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你在地图上使用了很多折线吗？你可以在每次添加或删除折线时运行一个特殊函数。这个特性对于大型地图应用程序特别有用，在这些应用程序中，许多不同的地方创建新的线条，或者当你需要删除不必要的线条时。
- en: 'To create functions for the two Polyline events, add the following code to
    your `create_map` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要为两个折线事件创建函数，请将以下代码添加到你的`create_map`函数中：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I have created a JavaScript alert to show the first point of the polyline that
    has been added or removed. You'll want to include something more useful than JavaScript
    alerts, which users would see as overkill in most situations. You might choose
    to autocenter the map based on the new or removed polyline, for example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经创建了一个JavaScript警告框来显示已添加或删除的折线的第一个点。你可能会想要包含比JavaScript警告框更有用的内容，在大多数情况下，用户可能会认为这是过度杀鸡用牛刀。例如，你可以选择根据新添加或删除的折线自动居中地图。
- en: You can access the affected polyline via the `event_args` object, which contains
    one property called `polyline`. You may find it more intuitive to access the polyline
    from the `event_source` object. Though these events are related to polylines,
    they are initiated by the Mapstraction object, which is passed as the source.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`event_args`对象访问受影响的折线，该对象包含一个名为`polyline`的属性。你可能觉得从`event_source`对象访问折线更直观。尽管这些事件与折线相关，但它们是由Mapstraction对象发起的，该对象作为源传递。
- en: Like adding and removing markers, your code is the only way to add new polylines
    to (or remove unwanted ones from) the map. Due to this fact, other methods are
    available for running code in these events. For large applications, however, you
    may prefer this event-based approach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加和删除标记一样，你的代码是向地图添加新折线（或从地图中删除不需要的折线）的唯一方式。由于这个原因，有其他方法可以在这些事件中运行代码。然而，对于大型应用程序，你可能更喜欢这种基于事件的方法。
- en: '#32: The User Opens or Closes a Message Box'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#32：用户打开或关闭消息框'
- en: Your map's markers can only do so much to communicate a location's meaning.
    The rest happens in a message box, which users can open by clicking a marker.
    If you want to react when a message box is opened or closed, you'll need to write
    event handlers for each marker.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你的地图标记只能做到如此来传达地点的意义。其余的事情发生在消息框中，用户可以通过点击标记来打开它。如果你想对消息框的打开或关闭做出反应，你需要为每个标记编写事件处理器。
- en: A common use case is to update a section of the website outside the map when
    a message box is opened. For example, perhaps you want to highlight the result
    related to that marker in search results. Or you may want to hide each marker
    once its message box has been viewed. Here, we'll stick with our method of showing
    a JavaScript alert.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的用例是在消息框打开时更新地图外的网站部分。例如，你可能想在搜索结果中突出显示与该标记相关的结果。或者你可能想在查看过每个标记的消息框后隐藏每个标记。在这里，我们将坚持使用我们的方法来显示JavaScript警告框。
- en: 'Add the following code to your basic map''s `create_map` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的基本地图的`create_map`函数中：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And include this function within the JavaScript section, but outside of other
    functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将此函数包含在JavaScript部分中，但不在其他函数之外：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, I''ve created a simple marker in the center of the map with a message
    box, similar to what we created in [#3: Show a Message Box When Your Marker Is
    Clicked](ch02s03.html "#3: Show a Message Box When Your Marker Is Clicked") in
    [#3: Show a Message Box When Your Marker Is Clicked](ch02s03.html "#3: Show a
    Message Box When Your Marker Is Clicked"). The events for opening and closing
    message boxes are shown in bold. For this particular marker, we''re waiting to
    react to either of these events.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我在地图中心创建了一个简单的标记，并附带了一个信息框，类似于我们在[第3部分：当您的标记被点击时显示信息框](ch02s03.html "#3:
    Show a Message Box When Your Marker Is Clicked")中创建的。打开和关闭信息框的事件以粗体显示。对于这个特定的标记，我们正在等待对这两个事件之一做出反应。'
- en: When the event fires, we call the named functions, either `myboxopened` or `myboxclosed`.
    You can name these functions anything you want. When the appropriate function
    is called, the marker is passed to the `event_source` variable ❶. At this point,
    we have access to any of this marker's attributes, including the location ❷. We
    can do anything with this marker that we can do with any other marker, including
    hide it, removing it, or setting new attributes (perhaps tracking which message
    boxes have been opened?).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件触发时，我们调用命名函数，无论是`myboxopened`还是`myboxclosed`。您可以命名这些函数为任何您想要的名称。当适当的函数被调用时，标记会被传递到`event_source`变量❶。在这个时候，我们可以访问这个标记的任何属性，包括位置❷。我们可以用这个标记做任何我们可以对其他标记做的事情，包括隐藏它、移除它或设置新的属性（也许跟踪哪些信息框已被打开？）。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike some of the previous examples, we add handlers for these events to the
    marker object, not the Mapstraction object. If you want to run similar code for
    every marker, you need to add an event to each marker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的一些示例不同，我们为这些事件添加了处理程序到标记对象，而不是Mapstraction对象。如果你想要为每个标记运行类似的代码，你需要为每个标记添加一个事件。
- en: As you can see from comparing the code for the two events, reacting to a closed
    message box uses almost identical code. You can see a more advanced example of
    the `closeInfoBubble` event later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从比较两个事件的代码中看到的，对关闭信息框的反应使用了几乎相同的代码。您可以在本章后面的部分看到一个更高级的`closeInfoBubble`事件的示例。
- en: '#33: The User Clicks a Marker'
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#33: 用户点击标记'
- en: Your users see all those markers on the map and many will want to click them
    to learn more about a particular location. That's what the message box is for,
    right? Well, you may want to do a little more. In those cases, you'll need a way
    to tell when a marker has been clicked. As you might have guessed, Mapstraction
    has an event for just this occasion.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您的用户会看到地图上的所有标记，许多人会想要点击它们来了解更多关于特定位置的信息。这就是信息框的作用，对吧？嗯，你可能还想做更多。在这种情况下，你需要一种方法来告诉何时一个标记被点击。正如你可能猜到的，Mapstraction有一个专门为此场合的事件。
- en: The marker click event, like the other marker events, is attached to the marker
    itself. So, if you want to perform the same action for every marker, you'll need
    to add a handler individually.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标记点击事件，就像其他标记事件一样，是附加到标记本身的。所以，如果您想要为每个标记执行相同的操作，您需要单独添加处理程序。
- en: 'For this example, we''ll simply use a single marker and create a JavaScript
    alert to share its location. Add the following code to the `create_map` function
    of your basic map:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将简单地使用一个标记并创建一个JavaScript警告框来共享其位置。将以下代码添加到您的`create_map`函数的基本地图中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And include this function within the JavaScript section but outside of other
    functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在JavaScript部分之外的其他函数之外包含此函数：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When the event fires, the `mymarkerclicked` function is called with three arguments.
    The marker is then passed to the `event_source` variable ❶. At this point, we
    have access to any of this marker's attributes, including the location ❷. We can
    do anything with this marker that we can do with any other marker, but here we've
    just created a JavaScript alert.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件触发时，`mymarkerclicked`函数会带有三个参数被调用。然后标记会被传递到`event_source`变量❶。在这个时候，我们可以访问这个标记的任何属性，包括位置❷。我们可以用这个标记做任何我们可以对其他标记做的事情，但在这里我们只是创建了一个JavaScript警告框。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This event is different than Mapstraction's main click event, which fires whenever
    the map is clicked. In this case, the event is attached to a particular marker,
    and your code only runs when that marker is clicked.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事件与Mapstraction的主要点击事件不同，后者在地图被点击时随时触发。在这种情况下，事件是附加到一个特定的标记上的，并且只有当那个标记被点击时，您的代码才会运行。
- en: 'Here''s the truth: You won''t use this event very often because a message box
    is the best way to show information about a marker. The marker click event is
    a useful tool, however, for the times when you want to do something a bit different.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是：你不会经常使用此事件，因为消息框是显示标记信息的最佳方式。然而，标记点击事件是一个有用的工具，尤其是在你想做一些不同的事情时。
- en: '#34: Return to the Center When the Message Box Is Closed'
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#34：当消息框关闭时返回中心'
- en: Have I sung the praises of message boxes enough yet? They help explain what
    your markers represent. They provide additional information about a location yet
    only at the moment the user wants it. They make your maps more informative and
    more interactive. But they can also get in the way, as shown in [Figure 5-2](ch05s09.html#opening_a_message_box_can_move_your_map
    "Figure 5-2. Opening a message box can move your map.").
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我是否已经充分赞扬了消息框？它们有助于解释你的标记代表什么。它们提供了有关位置的额外信息，但仅在用户需要时提供。它们使你的地图更具信息性和交互性。但它们也可能妨碍，如图
    [图5-2](ch05s09.html#opening_a_message_box_can_move_your_map "图5-2。打开消息框可能会移动你的地图。")
    所示。
- en: Depending on your provider, opening a message box can cause your map to pan
    ungracefully, leaving a messy map when the user has closed the message box. A
    little code and the help of an event already covered in this chapter can improve
    the user's experience. Re-enter the `closeInfoBubble` event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的提供商，打开消息框可能会导致你的地图不优雅地平移，当用户关闭消息框时留下一个混乱的地图。一点代码和本章中已经覆盖的事件的帮助可以改善用户体验。重新进入
    `closeInfoBubble` 事件。
- en: 'Let''s say you''ve laid out your markers so they fit perfectly within the map,
    as shown in [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html
    "#8: Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). If you make that code
    run again whenever the user closes a message box and after each new marker is
    added, your map will always look organized.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经布置了标记，使它们完美地位于地图内，如 [#8：根据标记确定正确的缩放级别](ch02s08.html "#8：根据标记确定正确的缩放级别")
    所示，在 [#7：遍历所有标记](ch02s07.html "#7：遍历所有标记") 中。如果你在用户关闭消息框和添加每个新标记后再次运行此代码，你的地图将始终保持有序。
- en: 'Add this code after creating a marker:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建标记后添加此代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And add the function to handle the event:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加处理事件的函数：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code assumes a marker named `mk`, but you'll want to change that to match
    whatever variable name you choose for your marker. Also remember that the `closeInfoBubble`
    event is set for a single marker. In order for the event to fire for every marker,
    you need to set it for every marker.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设有一个名为 `mk` 的标记，但你需要将其更改为与你的标记所选择的任何变量名匹配。还要记住，`closeInfoBubble` 事件是为单个标记设置的。为了使事件对每个标记都触发，你需要为每个标记设置它。
- en: Preserve the Previous Center
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留先前的中心
- en: Re-autocentering code might be very useful for most situations because users
    can still see every marker. In some cases, however, you might want to give the
    user a little more control, while still maintaining the benefit of reorganizing
    your map when a message box is closed. Here, you want to remember where the map
    was before the user opened the message box.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重新自动居中代码在大多数情况下可能非常有用，因为用户仍然可以看到每个标记。然而，在某些情况下，你可能希望给用户更多的控制权，同时仍然保持当消息框关闭时重新组织地图的好处。在这里，你想要记住用户打开消息框之前地图的位置。
- en: 'To achieve this result, you''ll need to use the two message box events in tandem.
    This method is a simple and effective way to preserve the map''s center. Add the
    following code after creating each marker:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此结果，你需要同时使用两个消息框事件。这种方法是保留地图中心的一个简单而有效的方法。在创建每个标记后添加以下代码：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And then include these handler functions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后包括以下处理函数：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As with the previous example, I'm assuming a marker named `mk`. Additionally,
    I've added a global variable named `mapcenter` to hold the `LatLonPoint` of the
    map's center.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，我假设有一个名为 `mk` 的标记。此外，我添加了一个名为 `mapcenter` 的全局变量来保存地图中心的 `LatLonPoint`。
- en: 'Whenever a message box is opened, the `openInfoBubble` event fires *before*
    the provider moves the map to make room for the message box. This is important:
    Now we have a chance to record the map''s center ❶, which will allow us to reset
    it later.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每当打开消息框时，`openInfoBubble` 事件会在提供商移动地图以腾出消息框的空间之前触发。这很重要：现在我们有记录地图中心 ❶ 的机会，这将允许我们稍后重置它。
- en: When the message box is closed, the `closeInfoBubble` event fires. Instead of
    autocentering, we set the center to the one stored when the message box was opened,
    as shown in [Figure 5-3](ch05s09.html#return_to_the_previous_center_when_the_m
    "Figure 5-3. Return to the previous center when the message box is closed.").
    To be extra kind to the user's eyes, we pan the map ❷ instead of setting the center
    directly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息框关闭时，会触发`closeInfoBubble`事件。而不是自动居中，我们将中心设置为打开消息框时存储的那个位置，如[图5-3](ch05s09.html#return_to_the_previous_center_when_the_m
    "图5-3. 当消息框关闭时返回到上一个中心位置。")所示。为了更加体贴用户的眼睛，我们平移地图❷而不是直接设置中心。
- en: Now you've used events to subtly improve your users' interactions with your
    maps.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用事件微妙地改善了用户与你的地图的交互。
- en: '![Opening a message box can move your map.](httpatomoreillycomsourcenostarchimages672039.png.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![打开消息框可以移动你的地图。](httpatomoreillycomsourcenostarchimages672039.png.jpg)'
- en: Figure 5-2. Opening a message box can move your map.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2. 打开消息框可以移动你的地图。
- en: '![Return to the previous center when the message box is closed.](httpatomoreillycomsourcenostarchimages672041.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![当消息框关闭时返回到上一个中心位置。](httpatomoreillycomsourcenostarchimages672041.png.jpg)'
- en: Figure 5-3. Return to the previous center when the message box is closed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-3. 当消息框关闭时返回到上一个中心位置。
- en: '#35: The User Moves the Map Outside Preset Bounds'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#35: 用户将地图移动到预设边界之外'
- en: Drag that map all you want, users. But don't drag it too far or we won't have
    anything else to show you. Providers have mapped the whole earth, but your map
    may only contain data for a particular neighborhood or city. You can use events
    to let you know when the user has moved outside of a predetermined area.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以随意拖动地图，但不要拖动得太远，否则我们就没有其他东西可以展示了。提供商已经绘制了整个地球的地图，但你的地图可能只包含特定街区或城市的资料。你可以使用事件来通知用户他们是否已经移动到了预设区域之外。
- en: Let's say you're creating a sightseeing map of Yellowstone National Park. You'd
    include Old Faithful geyser and Mammoth Hot Springs because they're both within
    Yellowstone. You wouldn't include the Statue of Liberty because that's thousands
    of miles away. We want to warn users that if they drag the map away from Yellowstone,
    they won't find anything there.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建黄石国家公园的观光地图。你会包括老忠实喷泉和大角温泉，因为它们都在黄石公园内。你不会包括自由女神像，因为它在数千英里之外。我们想提醒用户，如果他们把地图从黄石公园拖开，他们将不会在那里找到任何东西。
- en: 'To start, let''s get a basic map centered on Yellowstone. Add the following
    code to your JavaScript, replacing any other map code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们获取一个以黄石公园为中心的基本地图。将以下代码添加到您的JavaScript中，替换掉任何其他地图代码：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we make a global variable to hold the `BoundingBox` to describe Yellowstone
    ❶. We'll use these bounds in the next step. Within the `create_map` function,
    you'll see a marker for each of the two sights I mentioned. After that, the map
    is automatically centered to show just those locations. I left two lines to indicate
    where we'll soon be adding additional code. One spot ❷ is for event code, and
    the other ❸ is for functions we'll use to determine whether the map is outside
    of Yellowstone.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个全局变量来保存描述黄石的`BoundingBox`。我们将在下一步中使用这些边界。在`create_map`函数中，你会看到我提到的两个景点的标记。之后，地图会自动居中，仅显示这些位置。我留下了两行代码，以指示我们很快将添加的额外代码。一个位置❷是用于事件代码，另一个位置❸是我们将用来确定地图是否在黄石之外的函数。
- en: Save the code and load it into a browser. Your map should look something like
    [Figure 5-4](ch05s10.html#yellowstone_national_park_with_markers_f "Figure 5-4. Yellowstone
    National Park with markers for two sights"). Try dragging the map to show more
    area to the north. Drag far enough and the map will be in Canada, far away from
    Yellowstone. Let's see what we can do to provide users with a warning.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 保存代码并将其加载到浏览器中。你的地图应该看起来像[图5-4](ch05s10.html#yellowstone_national_park_with_markers_f
    "图5-4. 带有两个景点标记的黄石国家公园")。尝试拖动地图以显示更多北部的区域。拖动足够远，地图就会进入加拿大，远离黄石公园。让我们看看我们能做些什么来为用户提供警告。
- en: 'The act of dragging the map is what moves users far from Yellowstone, so we
    need to handle the `endPan` event, as described earlier in this chapter. Add the
    following within the `create_map` function in the section we set aside for event
    code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动地图的行为是将用户从黄石公园带远，因此我们需要处理前面章节中提到的`endPan`事件。在为事件代码预留的部分中，在`create_map`函数内添加以下代码：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Yellowstone National Park with markers for two sights](httpatomoreillycomsourcenostarchimages672043.png.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![带有两个景点标记的黄石国家公园](httpatomoreillycomsourcenostarchimages672043.png.jpg)'
- en: Figure 5-4. Yellowstone National Park with markers for two sights
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4. 黄石国家公园带有两个景点标记的地图
- en: Here we've created code that runs each time the user finishes dragging the map.
    It uses the global `yellowstone` variable, which is the `BoundingBox` that describes
    Yellowstone. The bounds is only data and not visible on the map. [Figure 5-5](ch05s10.html#bounds_of_yellowstone
    "Figure 5-5. Bounds of Yellowstone") shows the area our bounds cover, however.
    You can see I've made the bounds big enough to include a reasonable buffer around
    Yellowstone. We want users to be able to see what's nearby. We only want to warn
    them when they're obviously off course.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一段代码，每次用户完成地图拖动时都会运行。它使用全局变量 `yellowstone`，这是描述黄石的 `BoundingBox`。边界仅是数据，在地图上不可见。[图
    5-5](ch05s10.html#bounds_of_yellowstone "图 5-5. 黄石的边界") 显示了我们的边界覆盖的区域。你可以看到，我已经将边界做得足够大，以便在黄石周围包含一个合理的缓冲区。我们希望用户能够看到附近的东西。我们只想在他们显然偏离路线时警告他们。
- en: To check if our map is still within our Yellowstone bounds, we need to compare
    the new variable to the map's bounds. To do so, we pass each of these to a function
    called `boundsInBounds`, which we still need to write. If that function returns
    false ❹ (the exclamation point in the code is read as "not"), then we create a
    JavaScript alert to warn the user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们的地图是否仍然在黄石边界内，我们需要将新变量与地图的边界进行比较。为此，我们将这些传递给一个名为 `boundsInBounds` 的函数，我们还需要编写这个函数。如果该函数返回
    false ❹（代码中的感叹号读作“不”），则我们创建一个 JavaScript 提示框来警告用户。
- en: '![Bounds of Yellowstone](httpatomoreillycomsourcenostarchimages672045.png.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![黄石的边界](httpatomoreillycomsourcenostarchimages672045.png.jpg)'
- en: Figure 5-5. Bounds of Yellowstone
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5. 黄石的边界
- en: 'Let''s include the new function outside of `create_map`, in the section we
    set aside for function code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `create_map` 之外包含新的函数，在为函数代码预留的部分：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The function accepts two `BoundingBox` variables as arguments. The first is
    the one we *expect* to be smaller, in this case the map's bounds. The second is
    the bounds we're checking, in this case Yellowstone. Because a `BoundingBox` is
    made up of two points (its southwest and northeast corners), we know that one
    `BoundingBox` is inside another only if the larger bounds contains both points.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个 `BoundingBox` 变量作为参数。第一个是我们 *期望* 较小的，在这种情况下是地图的边界。第二个是我们正在检查的边界，在这种情况下是黄石。因为
    `BoundingBox` 由两个点（其西南角和东北角）组成，我们知道只有当较大的边界包含这两个点时，一个 `BoundingBox` 才在另一个内部。
- en: The event code that we wrote previously will only create an alert if this function
    returns false, meaning the user has dragged the map outside of Yellowstone. Try
    it yourself. Drag the map north. Once you leave Yellowstone, you'll receive a
    warning after each drag of the map, as shown in [Figure 5-6](ch05s10.html#javascript_alert_triggered_when_the_user
    "Figure 5-6. JavaScript alert triggered when the user moves outside of Yellowstone
    bounds").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的代码只有在该函数返回 false 时才会创建一个提示框，这意味着用户已经将地图拖出了黄石。试试看。将地图向北拖动。一旦你离开黄石，你将在每次拖动地图后收到警告，如图
    5-6 所示。
- en: '![JavaScript alert triggered when the user moves outside of Yellowstone bounds](httpatomoreillycomsourcenostarchimages672047.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![用户移出黄石边界时触发的 JavaScript 提示框](httpatomoreillycomsourcenostarchimages672047.png.jpg)'
- en: Figure 5-6. JavaScript alert triggered when the user moves outside of Yellowstone
    bounds
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6. 用户移出黄石边界时触发的 JavaScript 提示框
