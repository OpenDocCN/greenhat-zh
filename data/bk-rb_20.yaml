- en: Chapter 20. Dynamic Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章 动态规划
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: In the past 19 chapters, I’ve covered a huge range of features of the Ruby language.
    One thing I haven’t covered in any detail is Ruby’s dynamic programming capability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的19章中，我涵盖了Ruby语言的大量特性。有一件事我还没有详细讲解，那就是Ruby的动态规划能力。
- en: If you have used only a nondynamic language (say one of the languages from the
    C or Pascal family), it is likely that dynamism in programming may take a little
    getting used to. Before going any further, I’ll clarify what I mean by a *dynamic*
    language. The definition is, in fact, a bit vague, and not all languages that
    lay claim to being dynamic share all the same features. In a general sense, however,
    a language that provides some means by which programs may be modified at runtime
    can be considered to be dynamic. Another quality of a dynamic language is its
    ability to change the type of a given variable—something you have done countless
    times in the examples throughout this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用过非动态语言（比如C或Pascal家族中的语言），那么编程中的动态性可能需要一点时间来适应。在继续之前，我将明确说明我所说的*动态语言*的含义。实际上，这个定义有点模糊，并不是所有声称自己是动态语言的语言都共享所有相同的特性。然而，从一般意义上讲，一个提供某种方式在运行时修改程序的语言可以被认为是动态的。动态语言的另一个特点是它能够改变给定变量的类型——你在这本书中的例子中已经无数次这样做过了。
- en: A further distinction may also be made between a *dynamically typed* language
    such as Ruby and a *statically typed* language (one in which the type of a variable
    is predeclared and fixed) such as C, Java, or Pascal. In this chapter, I will
    concentrate on the self-modifying capabilities of Ruby.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在Ruby这样的*动态类型*语言和*静态类型*语言（变量类型在声明时预先声明并固定）之间做出进一步的区分，例如C、Java或Pascal。在本章中，我将专注于Ruby的自我修改能力。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In formal computer science, the term *dynamic programming* is sometimes used
    to describe an analytic approach to solving complex problems. That is not the
    sense in which the term is used in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在形式化的计算机科学中，术语*动态规划*有时被用来描述解决复杂问题的一种分析方法。但这并不是本章中术语所用的含义。
- en: Self-Modifying Programs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自修改程序
- en: 'In most compiled languages and many interpreted languages, writing programs
    and running programs are two completely distinct operations: The code you write
    is fixed, and it is beyond any possibility of further alteration by the time the
    program is run.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编译型语言和许多解释型语言中，编写程序和运行程序是两种完全不同的操作：你编写的代码是固定的，在程序运行时已经不可能进行任何进一步的修改。
- en: That is not the case with Ruby. A program—by which I mean *the Ruby code itself*—can
    be modified while the program is running. It is even possible to enter new Ruby
    code at runtime and execute the new code without restarting the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但Ruby并非如此。一个程序——我指的是*Ruby代码本身*——在程序运行时可以被修改。甚至可以在运行时输入新的Ruby代码并执行新代码，而无需重新启动程序。
- en: The ability to treat data as executable code is called *metaprogramming*. You’ve
    been doing metaprogramming, albeit of a rather simple sort, throughout this book.
    Every time you embed an expression inside a double-quoted string, you are doing
    metaprogramming. After all, the embedded expression is not really program code—it
    is a string—and yet Ruby clearly has to “turn it into” program code in order to
    be able to evaluate it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据视为可执行代码的能力被称为*元编程*。你在这本书中一直在进行元编程，尽管是相当简单的一种。每次你在双引号字符串中嵌入一个表达式时，你就是在进行元编程。毕竟，嵌入的表达式并不是真正的程序代码——它是一个字符串——然而Ruby显然必须“将其转换为”程序代码才能对其进行评估。
- en: 'Most of the time you will probably embed rather simple bits of code between
    the `#{` and `}` delimiters in double-quoted strings. Often you might embed variable
    names, say, or mathematical expressions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能会在双引号字符串中的`#{`和`}`分隔符之间嵌入相当简单的代码片段。你可能会嵌入变量名，比如，或者数学表达式：
- en: '*str_eval.rb*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*str_eval.rb*'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But you aren’t limited to such simple expressions. You could, if you wanted,
    embed just about anything into a double-quoted string. You could, in fact, write
    an entire program in a string. You don’t even need to display the end result using
    `print` or `puts`. Just placing a double-quoted string into your program will
    cause Ruby to evaluate it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但你并不局限于这样的简单表达式。实际上，你可以将几乎所有内容嵌入到双引号字符串中。你甚至可以在字符串中编写整个程序。你甚至不需要使用`print`或`puts`来显示最终结果。只需将双引号字符串放入你的程序中，Ruby就会对其进行评估：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even though the previous code fragment is a string, the Ruby interpreter will
    evaluate its embedded code and display the result, shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使前面的代码片段是一个字符串，Ruby解释器也会评估其嵌入的代码并显示结果，如下所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Interesting as this may be, writing a whole program inside a string would probably
    be a pretty pointless endeavor. However, there are other occasions when this,
    and similar, features can be used much more productively. For example, you might
    use metaprogramming to explore artificial intelligence and “machine learning.”
    In fact, any application that would benefit from having a program’s behavior modified
    in response to user interaction is a prime candidate for metaprogramming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有趣，但在字符串内编写整个程序可能是一个相当无意义的工作。然而，在其他情况下，这种功能和类似的功能可以更加高效地使用。例如，你可能使用元编程来探索人工智能和“机器学习”。实际上，任何需要根据用户交互修改程序行为的程序都是元编程的理想候选。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Dynamic (metaprogramming) features are ubiquitous in Ruby. Consider, for example,
    attribute accessors: Passing a symbol (such as `:aValue`) to the `attr_accessor`
    method causes two methods (`aValue` and `aValue=`) to be created.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 动态（元编程）特性在Ruby中无处不在。例如，考虑属性访问器：将符号（如`:aValue`）传递给`attr_accessor`方法会导致创建两个方法（`aValue`和`aValue=`）。
- en: eval
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eval
- en: 'The `eval` method provides a simple way of evaluating a Ruby expression in
    a string. At first sight, `eval` may appear to do the same job as the `#{ }` delimiters
    in a double-quoted string. These two lines of code produce identical results:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`方法提供了一种简单的方法来评估字符串中的Ruby表达式。乍一看，`eval`可能看起来与双引号字符串中的`#{ }`定界符做的是同样的工作。这两行代码产生相同的结果：'
- en: '*eval.rb*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*eval.rb*'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Sometimes, however, the results may not be what you are expecting. Look at
    the following, for instance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时结果可能并非你所期望的。看看下面的例子：
- en: '*eval_string.rb*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*eval_string.rb*'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s suppose you enter `2 * 4`, and this is assigned to `exp`. When you evaluate
    `exp` with `eval`, the result is 8, but when you evaluate `exp` in a double-quoted
    string, the result is `"2*4"`. This is because anything read in by `gets()` is
    a string and `"#{exp}"` evaluates it *as a string* and not as an expression, whereas
    `eval( exp )` evaluates a string *as an expression*. To force evaluation inside
    a string, you could place `eval` in the string (though that, admittedly, might
    defeat the object of the exercise):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你输入`2 * 4`，并将其分配给`exp`。当你用`eval`评估`exp`时，结果是8，但当你用双引号字符串评估`exp`时，结果是`"2*4"`。这是因为`gets()`读取的任何内容都是一个字符串，`"#{exp}"`将其*作为字符串*评估，而不是作为表达式，而`eval(
    exp )`则将字符串*作为表达式*评估。为了在字符串内强制评估，你可以在字符串中放置`eval`（尽管这确实可能违背了练习的目的）：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is another example. Try it, and follow the instructions when prompted:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子。尝试它，并按照提示操作：
- en: '*eval2.rb*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*eval2.rb*'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `eval` method can evaluate strings spanning many lines, making it possible
    to execute an entire program embedded in a string:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`方法可以评估跨越多行的字符串，使得在字符串中执行整个程序成为可能：'
- en: '*eval3.rb*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*eval3.rb*'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Look carefully at the previous code. It contains just one executable expression,
    which is a call to the `eval()` method. Everything else, which at first sight
    *looks* like code, is in fact a single-quoted string that is passed as an argument
    to `eval()`. The `eval()` method “unpacks” the contents of the string and turns
    it into real Ruby code that is then executed. This is displayed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看前面的代码。它只包含一个可执行的表达式，即对`eval()`方法的调用。其他所有看起来像代码的东西，实际上是一个单引号字符串，作为参数传递给`eval()`。`eval()`方法“解包”字符串的内容，将其转换为真正的Ruby代码，然后执行。这显示为：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With all this `eval` cleverness, let’s now see how easy it is to write a program
    that can itself write programs. Here it is:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些`eval`的巧妙之处，现在让我们看看编写一个可以自己编写程序的程序有多容易。这里就是：
- en: '*eval4.rb*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*eval4.rb*'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This may not look like much, and yet this little program lets you both create
    and execute Ruby code from a prompt. Try it. Run the program, and enter the two
    methods shown here one line at a time (but *don’t hit*q *to quit yet*—you’ll be
    writing some more code in a moment):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，但这个小程序让你可以从提示符创建和执行Ruby代码。试试看。运行程序，一次输入这里显示的两个方法中的一行（但*不要按* *q* *退出*——你很快就会写更多的代码）：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that you have to enter each whole method on a single line since the program
    evaluates every line as it is entered. I’ll explain how to get around that limitation
    later. Thanks to `eval`, each method is turned into real, workable Ruby code.
    You can prove this by entering the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须将每个整个方法输入到单行中，因为程序会逐行评估输入。我稍后会解释如何绕过这个限制。多亏了 `eval`，每个方法都被转换成了真正的、可工作的
    Ruby 代码。你可以通过输入以下内容来证明这一点：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when you press enter after each line in the previous code, the expressions
    are evaluated, and they call the two methods, `x()` and y`()`, which you wrote
    a moment ago, resulting in this output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你按下回车键在上一段代码的每一行之后，表达式将被评估，并调用你刚才编写的两个方法 `x()` 和 `y()`，产生以下输出：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That’s not bad for just five lines of code!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于仅仅五行代码来说，这已经很不错了！
- en: Special Types of eval
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊类型的 eval
- en: 'There are some variations on the `eval` theme in the form of the methods named
    `instance_eval`, `module_eval`, and `class_eval`. The `instance_eval` method can
    be called from a specific object, and it provides access to the instance variables
    of that object. It can be called either with a block or with a string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `eval` 主题上存在一些变体，形式为名为 `instance_eval`、`module_eval` 和 `class_eval` 的方法。`instance_eval`
    方法可以从特定的对象中调用，并提供对该对象实例变量的访问。它可以带一个代码块或一个字符串来调用：
- en: '*instance_eval.rb*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*instance_eval.rb*'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `eval` method, on the other hand, cannot be called from an object in this
    way because it is a private method of Object (whereas `instance_eval` is public):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`eval` 方法不能以这种方式从对象中调用，因为它是对象的私有方法（而 `instance_eval` 是公共的）：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In fact, you could explicitly change the visibility of `eval` by sending its
    name (the symbol `:eval`) to the `public` method. Here I am adding `eval` as a
    public method of the Object class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以通过将 `eval` 的名称（符号 `:eval`）发送到 `public` 方法来显式更改 `eval` 的可见性。在这里，我将 `eval`
    添加为 Object 类的公共方法：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Indeed, bearing in mind that when you write “free-standing” code you are actually
    working within the scope of Object, simply entering the following code (without
    the Object class “wrapper”) would have the same effect:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，考虑到当你编写“独立”代码时，你实际上是在 Object 的作用域内工作，简单地输入以下代码（没有 Object 类的“包装”）会产生相同的效果：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now you can use `eval` as a method of the `ob` variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将 `eval` 作为 `ob` 变量的方法使用：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Strictly speaking, `eval` is a method of the `Kernel` module that is mixed into
    the Object class. In fact, it is the `Kernel` module that provides most of the
    functions available as methods of Object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`eval` 是 `Kernel` 模块的一个方法，它被混合到 Object 类中。实际上，是 `Kernel` 模块提供了大多数作为 Object
    方法可用的函数。
- en: The modification of class definitions at runtime is sometimes called *monkey
    patching*. This may have a part to play in certain highly specialized types of
    programming, but as a general principle, gratuitous messing about with standard
    Ruby classes is definitely *not* recommended. Changing the visibility of methods
    and adding new behavior to base classes are excellent ways of creating inscrutable
    code dependencies (in which, for example, your own programs work because you happen
    to know how you’ve changed a base class, but your colleagues’ programs don’t work
    because they don’t know how the classes have been changed).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时修改类定义有时被称为 *猴子补丁*。这在某些高度专业化的编程类型中可能起到一定的作用，但作为一个一般原则，随意篡改标准 Ruby 类绝对是不推荐的。更改方法的可见性和向基类添加新行为是创建难以理解的代码依赖性的绝佳方式（例如，你的程序之所以能工作，是因为你偶然知道如何更改基类，但你的同事的程序不能工作，因为他们不知道类是如何被更改的）。
- en: 'The `module_eval` and `class_eval` methods operate on modules and classes rather
    than on objects. For example, the code shown next adds the `xyz` method to the
    `X` module (here `xyz` is defined in a block and added as an instance method of
    the receiver by `define_method`, which is a method of the Module class), and it
    adds the `abc` method to the Y class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`module_eval` 和 `class_eval` 方法作用于模块和类，而不是对象。例如，下面的代码向 `X` 模块（在这里 `xyz` 在一个代码块中定义，并通过
    `define_method`（它是 Module 类的一个方法）添加为接收者的实例方法）添加了 `xyz` 方法，并将 `abc` 方法添加到 Y 类：'
- en: '*module_eval.rb*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*module_eval.rb*'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When accessing class and module methods, you can use the scope resolution operator
    `::` or a single dot. The scope resolution operator is obligatory when accessing
    constants and optional when accessing methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问类和模块方法时，你可以使用作用域解析运算符 `::` 或单个点。当访问常量时，作用域解析运算符是强制的，当访问方法时是可选的。
- en: 'So, now an object that is an instance of Y will have access to both the `abc`
    method of the Y class and the `xyz` method of the `X` module that has been mixed
    into the Y class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在一个Y类的实例对象将能够访问Y类的`abc`方法和被混合到Y类中的`X`模块的`xyz`方法：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In spite of their names, `module_eval` and `class_eval` are functionally identical,
    and each can be used with either a module or a class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的名称不同，`module_eval`和`class_eval`在功能上是相同的，并且每个都可以与模块或类一起使用：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also add methods into Ruby’s standard classes in the same way:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以以相同的方式向Ruby的标准类中添加方法：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Adding Variables and Methods
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加变量和方法
- en: 'You can also use the `module_eval` and `class_eval` methods to retrieve the
    values of class variables (but bear in mind that the more you do this, the more
    your code becomes dependent on the implementation details of a class, thereby
    compromising encapsulation):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`module_eval`和`class_eval`方法来检索类变量的值（但请注意，你这样做得越多，你的代码就越依赖于类的实现细节，从而损害封装）：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In fact, `class_eval` can evaluate expressions of arbitrary complexity. You
    could, for example, use it to add new methods to a class by evaluating a string:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`class_eval`可以评估任意复杂性的表达式。例如，你可以用它来通过评估一个字符串向一个类添加新方法：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Returning to the earlier example of adding and retrieving class variables from
    *outside* a class (using `class_eval`), it turns out that there are also methods
    designed to do this from *inside* a class. The methods are called `class_variable_get`
    (this takes a symbol argument representing the variable name, and it returns the
    variable’s value) and `class_variable_set` (this takes a symbol argument representing
    a variable name and a second argument that is the value to be assigned to the
    variable).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到之前关于从*外部*一个类中添加和检索类变量的例子（使用`class_eval`），结果发现也有方法可以从*内部*一个类中做这件事。这些方法被称为`class_variable_get`（这个方法接受一个表示变量名的符号参数，并返回变量的值）和`class_variable_set`（这个方法接受一个表示变量名的符号参数和一个第二个参数，即要分配给变量的值）。
- en: 'Here is an example of these methods in use:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些方法使用的一个例子：
- en: '*classvar_getset.rb*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*classvar_getset.rb*'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To obtain a list of class variable names as an array of strings, use the `class_variables`
    method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个表示类变量名的字符串数组，请使用`class_variables`方法：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also add instance variables to classes and objects after they have
    been created using `instance_variable_set`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在创建类和对象之后使用`instance_variable_set`向类和对象添加实例变量：
- en: '*dynamic.rb*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*dynamic.rb*'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By combining this with the ability to add methods, the bold (or maybe reckless?)
    programmer can completely alter the internals of a class “from the outside.” Here
    I have implemented this in the form of a method called `addMethod` in class X,
    which uses the `send` method to create the new method `m` using `define_method`
    with the method body, defined by `&block`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合添加方法的能力，大胆（或可能鲁莽？）的程序员可以完全从“外部”改变一个类的内部结构。在这里，我在类X中实现了一个名为`addMethod`的方法，它使用`send`方法通过`define_method`和由`&block`定义的方法体来创建新的方法`m`：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `send` method invokes the method identified by the first argument (a symbol),
    passing to it any arguments specified.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`方法调用由第一个参数（一个符号）标识的方法，并将任何指定的参数传递给它。'
- en: 'Now, an X object can call `addMethod` to insert a new method into the X class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个X对象可以调用`addMethod`来向X类中插入一个新的方法：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Although this method is called from a specific instance of the class (here
    `ob`), it affects the class itself, so the newly defined method will also be available
    to any subsequent instances (here `ob2`) created from the X class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法是从类的特定实例（这里`ob`）调用的，但它影响的是类本身，因此新定义的方法也将对从X类创建的任何后续实例（这里`ob2`）可用：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you don’t care about the encapsulation of data in your objects (my definition
    of *encapsulation* assumes the hiding of internal data, though some people have
    less rigorous definitions), you can also retrieve the value of instance variables
    using the `instance_variable_get` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在乎你的对象中数据的封装（我对*封装*的定义假设隐藏内部数据，尽管有些人有更宽松的定义），你也可以使用`instance_variable_get`方法来检索实例变量的值：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can similarly *set* and *get* constants:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以同样地*设置*和*获取*常量：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because `const_get` returns the value of a constant, you could use this method
    to get the value of a class name, which is itself a constant, and then append
    the `new` method to create a new object from that class. This could even give
    you a way of creating objects at runtime by prompting the user to enter class
    names and method names. Try this by running this program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `const_get` 返回常量的值，所以你可以使用此方法获取类名（它本身也是一个常量）的值，然后附加 `new` 方法从这个类创建一个新的对象。这甚至可以为你提供一个在运行时通过提示用户输入类名和方法名来创建对象的方法。通过运行此程序来尝试：
- en: '*dynamic2.rb*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*dynamic2.rb*'
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Creating Classes at Runtime
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时创建类
- en: 'So far, you have modified classes and created new objects from existing classes.
    But how would you go about creating a completely new class at runtime? Well, just
    as you can use `const_get` to access an existing class, you can use `const_set`
    to create a new class. Here’s an example of how to prompt the user for the name
    of a new class before creating that class, adding a method (`myname`) to it, creating
    an instance (`x`) of that class, and calling its `myname` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经修改了类并从现有类创建了新对象。但你是如何创建一个完全新的类呢？嗯，就像你可以使用 `const_get` 访问现有类一样，你也可以使用
    `const_set` 创建新类。以下是一个示例，说明如何在创建类之前提示用户输入新类的名称，向其中添加一个方法（`myname`），创建该类的实例（`x`），并调用其
    `myname` 方法：
- en: '*create_class.rb*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*create_class.rb*'
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you run this program and enter `Xxx` when prompted for the name of a new
    class, the code will use `const_set` to create the constant `Xxx` as a new class;
    then `module_eval` is called on this class, and `define_method` is used to create
    a method whose name matches the symbol `:myname` and whose contents are given
    by the code in the curly brace-delimited block; here this happens to be a single
    `puts` statement that displays the class name.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此程序并在提示输入新类名时输入 `Xxx`，代码将使用 `const_set` 创建一个名为 `Xxx` 的新常量作为类；然后对类调用 `module_eval`，并使用
    `define_method` 创建一个名称与符号 `:myname` 匹配的方法，其内容由花括号分隔的代码块给出；这里恰好是一个显示类名的 `puts`
    语句。
- en: 'Run this code, and enter `Xxx` when prompted. An object, `x`, is created from
    the `Xxx` class; its `myname()` method is called; and, sure enough, it displays
    the class name:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，当提示输入时请输入 `Xxx`。从 `Xxx` 类创建了一个对象 `x`；调用了其 `myname()` 方法；果然，它显示了类名：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Bindings
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'The `eval` method may take an optional “binding” argument that, if provided,
    causes the evaluation to be done within a specific scope or “context.” It probably
    won’t come as any surprise to discover that, in Ruby, a binding is an object that
    is an instance of the Binding class. You can return a binding using the `binding`
    method. The documentation of `eval` in the Ruby class library provides this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval` 方法可能接受一个可选的“绑定”参数，如果提供，则会在特定的作用域或“上下文”内执行评估。在 Ruby 中，一个绑定是 Binding 类的实例。你可以使用
    `binding` 方法返回一个绑定。Ruby 类库中 `eval` 的文档提供了以下示例：'
- en: '*binding.rb*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*binding.rb*'
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Simple as it may look, this example may take a bit of thinking about in order
    to understand what’s going on. Essentially, the first call to `puts` evaluates
    `str` in the current scope where it has a “hello” value. The second call to `puts`
    evaluates `str` in the scope of the `getBinding()` method where it has a “bye”
    value. In this example, `str` happens to be passed as an argument, but this is
    not a requirement. In the rewritten version here, I’ve made `str` a local variable
    inside `getBinding()`. The effect is the same:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来可能很简单，但为了理解这里发生了什么，可能需要一些思考。本质上，第一次调用 `puts` 在当前作用域中评估 `str`，其中它具有“hello”值。第二次调用
    `puts` 在 `getBinding()` 方法的范围内评估 `str`，其中它具有“bye”值。在这个例子中，`str` 偶然被作为参数传递，但这不是必需的。在这个重写的版本中，我已经将
    `str` 作为 `getBinding()` 内部的局部变量。效果是相同的：
- en: '*binding2.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*binding2.rb*'
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that `binding` is a private method of Kernel. The `getBinding` method is
    able to call `binding` within the current context and return the current value
    of `str`. At the time of the first call to `eval`, the context is the *main* object,
    and the value of the local variable, `str`, is used; in the second call, the context
    moves inside the `getBinding` method, and the local value of `str` is now that
    of the `str` argument or variable within that method. The context may also be
    defined by a class. In *binding3.rb*, you can see that the values of the instance
    variable `@mystr` varies according to the class. So, what happens when you `eval`
    those variables with different bindings?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`binding` 是 Kernel 的一个私有方法。`getBinding` 方法能够在当前上下文中调用 `binding` 并返回 `str`
    的当前值。在第一次调用 `eval` 时，上下文是 *主* 对象，局部变量 `str` 的值被使用；在第二次调用中，上下文移动到 `getBinding`
    方法内部，局部值 `str` 现在是方法中的 `str` 参数或变量的值。上下文也可以由一个类定义。在 *binding3.rb* 中，你可以看到实例变量
    `@mystr` 的值根据类而变化。那么，当你使用不同的绑定 `eval` 这些变量时会发生什么？
- en: '*binding3.rb*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*binding3.rb*'
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In Ruby 1.8, you see the following output, showing that the bindings for both
    the instance variable, `@mystr`, and the class variable, `@@x`, are applied:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 中，你会看到以下输出，显示实例变量 `@mystr` 和类变量 `@@x` 的绑定都被应用：
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'But in Ruby 1.9, only the binding of the instance variable is applied; the
    class variable in the current (*main*) context is always used:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Ruby 1.9 中，只有实例变量的绑定被应用；当前（*主*）上下文中的类变量始终被使用：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Does this mean class variables in given bindings are ignored? Let’s try an
    experiment. Just comment out the assignment to `@@x` in the main context:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着给定绑定中的类变量被忽略？让我们做一个实验。只需在主上下文中注释掉对 `@@x` 的赋值：
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now run the program again. This time, Ruby 1.9 displays this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行程序。这次，Ruby 1.9 显示如下：
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Clearly, Ruby 1.9 *does* evaluate class variables within a binding. However,
    it gives preference to class variables, if they exist, in the *current* binding.
    You need to be aware of this difference if you are migrating Ruby 1.8 programs
    to Ruby 1.9 or newer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Ruby 1.9 *确实*在绑定中评估类变量。然而，如果存在类变量，它会优先考虑 *当前* 绑定中的类变量。如果你正在将 Ruby 1.8 程序迁移到
    Ruby 1.9 或更新的版本，你需要注意这个差异。
- en: send
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send
- en: 'You can use the `send` method to call a method with the same name as the specified
    symbol:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `send` 方法调用与指定符号具有相同名称的方法：
- en: '*send1.rb*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*send1.rb*'
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Although the `send` method is documented as requiring a symbol argument, you
    can also use a string argument. Or, for consistency, you could use `to_sym` to
    transform the string to a symbol and then call the method with the same name as
    that symbol:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文档中说明 `send` 方法需要符号参数，但你也可以使用字符串参数。或者，为了保持一致性，你可以使用 `to_sym` 将字符串转换为符号，然后使用与该符号相同的名称调用方法：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is a working example of using `send` to execute a named method entered
    at runtime:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `send` 在运行时执行命名方法的示例：
- en: '*send2.rb*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*send2.rb*'
- en: '[PRE44]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Removing Methods
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除方法
- en: 'Recall you created a new method earlier (*dynamic.rb*) using `send` to call
    `define_method` and passed to it the name, `m`, of the method to be created plus
    a block, `&block`, containing the code of the new method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，你之前（*dynamic.rb*）使用 `send` 调用 `define_method` 并传递给它要创建的方法的名称，`m`，以及包含新方法代码的块，`&block`：
- en: '*dynamic.rb*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*dynamic.rb*'
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In addition to creating new methods, sometimes you may want to remove existing
    methods. You can do this using `remove_method` within the scope of a given class.
    This removes the method specified by a symbol from a specific class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建新方法外，有时你可能想移除现有方法。你可以在给定类的范围内使用 `remove_method` 来做这件事。这将从一个特定的类中移除由符号指定的方法：
- en: '*rem_methods1.rb*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*rem_methods1.rb*'
- en: '[PRE46]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If a method with the same name is defined for an ancestor of that class, the
    ancestor class method is *not* removed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为该类的祖先定义了具有相同名称的方法，则不会移除祖先类的方法：
- en: '*rem_methods2.rb*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*rem_methods2.rb*'
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, `somemethod` is removed from the Z class, so when `zob.somemethod`
    is subsequently called on a Z object, Ruby executes the first method with that
    name in the *ancestor* classes of Z. Here, Y is the ancestor of Z, so its `somemethod`
    method is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`somemethod` 从 Z 类中被移除，因此当在 Z 对象上随后调用 `zob.somemethod` 时，Ruby 会执行 Z 的
    *祖先* 类中第一个具有该名称的方法。在这里，Y 是 Z 的祖先，所以它的 `somemethod` 方法被使用。
- en: 'The `undef_method`, by contrast, prevents the specified class from responding
    to a method call even if a method with the same name is defined in one of its
    ancestors. The following example uses the same Y and Z classes used in the previous
    example. The only difference is that this time `somemethod` is *undefined* using
    `undef_method` rather than merely *removed* from the current class using `remove_method`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`undef_method` 阻止指定的类响应方法调用，即使在其祖先中定义了具有相同名称的方法。以下示例使用了之前示例中使用的相同的 Y 和
    Z 类。唯一的区别是这次使用 `undef_method` 而不是使用 `remove_method` 仅从当前类中移除 `somemethod`：
- en: '*undef_methods.rb*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*undef_methods.rb*'
- en: '[PRE48]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Handling Missing Methods
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失的方法
- en: 'When Ruby tries to execute an undefined method (or, in object-oriented terms,
    when an object is sent a message that it cannot handle), the error causes the
    program to exit. You may prefer your program to recover from such an error. You
    can do this by writing a method named `method_missing`, with an argument to which
    the missing method’s name is assigned. This will execute when a nonexistent method
    is called:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 尝试执行一个未定义的方法（或者，用面向对象的话说，当一个对象收到它无法处理的消息时），错误会导致程序退出。你可能希望你的程序能够从这样的错误中恢复。你可以通过编写一个名为
    `method_missing` 的方法来实现，该方法将未找到的方法名称分配给一个参数。这将在一个不存在的方法被调用时执行：
- en: '*nomethod1.rb*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*nomethod1.rb*'
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `method_missing` method can also take a list of incoming arguments (`*args`)
    after the missing method name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`method_missing` 方法还可以在缺失的方法名称之后接受一个传入参数的列表 (`*args`)：'
- en: '*nomethod2.rb*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*nomethod2.rb*'
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Assuming the previous `method_missing` method were written into a class called
    X, you could now attempt to call any method on an X object, whether or not that
    method exists and whether or not it is passed any arguments. If, for example,
    you were to attempt to call a nonexistent method called `aaa`, first with no arguments
    and then with three integer arguments, the `method_missing` method would respond
    to the invalid method call and display an appropriate error message:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 假设之前的 `method_missing` 方法被写入一个名为 X 的类中，你现在可以尝试在 X 对象上调用任何方法，无论该方法是否存在以及是否传递了任何参数。例如，如果你尝试调用一个不存在的名为
    `aaa` 的方法，首先不带任何参数，然后带三个整数参数，`method_missing` 方法将响应无效的方法调用并显示适当的错误信息：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `method_missing` method could even create an undefined method dynamically
    so that a call to a nonexistent method automatically brings that method into existence:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`method_missing` 方法甚至可以动态地创建一个未定义的方法，以便对不存在的方法的调用自动使其存在：'
- en: '[PRE52]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Remember that the `lambda` method turns a block (here the code between curly
    brackets) into a Proc object. This is explained in [Chapter 10](ch10.html "Chapter 10. Blocks,
    Procs, and Lambdas"). The code is then able to pass this object as an argument
    to `send`, defining a new method with the same name as the `methodname` argument
    passed to `method_missing`. The effect is that when an unknown method is called
    on a Z object, a method with that name is created. Run the *nomethod2.rb* program,
    which contains this code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`lambda` 方法将一个块（这里是大括号之间的代码）转换成一个 Proc 对象。这已在 [第 10 章](ch10.html "第 10 章。块、Proc
    和 Lambda") 中解释。然后代码能够将此对象作为参数传递给 `send`，定义一个与传递给 `method_missing` 的 `methodname`
    参数具有相同名称的新方法。结果是，当在 Z 对象上调用未知方法时，会创建一个具有该名称的方法。运行包含此代码的 *nomethod2.rb* 程序：
- en: '[PRE53]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This gives the following output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下输出：
- en: '[PRE54]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Writing Programs at Runtime
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时编写程序
- en: 'Finally, let’s return to the program you looked at earlier: *eval4.rb*. This,
    you may recall, prompts the user to enter strings to define code at runtime, evaluates
    those strings, and creates new runnable methods from them.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们回到你之前查看的程序：*eval4.rb*。你可能还记得，这个程序提示用户输入字符串以在运行时定义代码，评估这些字符串，并从它们中创建新的可运行方法。
- en: 'One drawback of that program was that it insists that each method be entered
    on a single line. It is, in fact, pretty simple to write a program that allows
    the user to enter methods spanning many lines. Here, for example, is a program
    that evaluates all the code entered up until a blank line is entered:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 那个程序的一个缺点是它坚持要求每个方法都在单行上输入。实际上，编写一个允许用户输入跨越多行的方法的程序相当简单。例如，以下是一个评估直到输入空白行为止的所有输入代码的程序：
- en: '*writeprog.rb*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*writeprog.rb*'
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can try this by entering whole methods followed by blank lines, like this
    (just enter the code, of course, not the comments):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入完整的方法后跟空白行来尝试这个方法（当然，只输入代码，不要输入注释）：
- en: '[PRE56]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After each line entered, a prompt (`?-`) appears except when the program is
    in the process of evaluating code, in which case it displays “Evaluating,” or
    when it shows the result of an evaluation, such as `olleh`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输入每一行后，都会出现一个提示（`?-`），除非程序正在评估代码的过程中，此时会显示“Evaluating”，或者当它显示评估结果时，例如 `olleh`。
- en: 'If you enter the text exactly as indicated earlier, this is what you should
    see:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照之前指示的文本输入，您应该看到以下内容：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This program is still very simple. It doesn’t even have any basic error recovery
    let alone fancy stuff such as file saving and loading. Even so, this small example
    demonstrates just how easy it is to write self-modifying programs in Ruby.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序仍然非常简单。它甚至没有基本的错误恢复功能，更不用说文件保存和加载等花哨的功能。即便如此，这个小例子展示了在 Ruby 中编写自修改程序是多么容易。
- en: Exploring Further
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: Using the techniques outlined in this chapter, you could create anything from
    a natural-language parser that can be taught rules of grammar to an adventure
    game that can learn new puzzles.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章概述的技术，您可以创建从可以教授语法规则的天然语言解析器到可以学习新谜题的冒险游戏等任何东西。
- en: In this book I’ve covered a lot of ground—from “hello world” to dynamic programming.
    You’ve explored most of the important and powerful features of the Ruby language.
    The rest is up to you.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我涵盖了大量的内容——从“hello world”到动态规划。您已经探索了 Ruby 语言的大部分重要和强大的功能。其余的取决于您。
- en: This is where the adventure really begins.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是冒险真正开始的地方。
- en: Digging Deeper
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: There may be times when you want to make sure that your Ruby objects cannot
    be modified in the ways described in this chapter. Here you will learn how to
    do this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能想确保您的 Ruby 对象不能以本章中描述的方式被修改。在这里，您将学习如何做到这一点。
- en: Freezing Objects
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结对象
- en: With all these ways of modifying objects at your disposal, you may be concerned
    that objects are at risk of being modified unintentionally. In fact, you can specifically
    fix the state of an object by “freezing” it using the `freeze` method, which you
    first encountered in [Chapter 12](ch12.html "Chapter 12. Modules and Mixins").
    Once frozen, the data contained by an object cannot be modified, and if an attempt
    is made to do so, a TypeError exception will be raised. Take care when freezing
    an object, however, because, once frozen, it cannot be “unfrozen.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在您拥有所有这些修改对象的方法之后，您可能会担心对象可能会被无意中修改。实际上，您可以使用 `freeze` 方法“冻结”对象来具体固定对象的状态，这是您在[第
    12 章](ch12.html "第 12 章。模块和混入")中首次遇到的。一旦被冻结，对象包含的数据就不能被修改，如果尝试修改，将会引发 TypeError
    异常。然而，在冻结对象时要小心，因为一旦被冻结，它就不能被“解冻”。
- en: '*freeze.rb*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*freeze.rb*'
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can specifically check whether an object is frozen using the `frozen?`
    method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `frozen?` 方法具体检查一个对象是否被冻结：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Be aware that although the data of a frozen object cannot be modified, the
    class from which it is defined can be modified. Let’s suppose you have a class
    X that contains the method `addMethod`, which can create new methods with the
    name given by the symbol `m`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管冻结对象的数据不能被修改，但定义它的类可以被修改。假设您有一个包含 `addMethod` 方法的类 X，该方法可以使用由符号 `m` 给定的名称创建新方法：
- en: '*cant_freeze.rb*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*cant_freeze.rb*'
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, if you have an object, `ob`, created from the M class, then it is perfectly
    legitimate to call `addMethod` to add a new method to class M:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您有一个由 M 类创建的对象，`ob`，那么调用 `addMethod` 向类 M 添加新方法是完全合法的：
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you want to prevent a frozen object from modifying its class, you could,
    of course, test its state using the `frozen?` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想防止冻结对象修改其类，当然可以使用 `frozen?` 方法测试其状态：
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can also freeze the class itself (remember, a class is also an object):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以冻结类本身（记住，类也是一个对象）：
- en: '*freeze_class.rb*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*freeze_class.rb*'
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
