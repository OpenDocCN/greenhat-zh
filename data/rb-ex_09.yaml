- en: Chapter 9. More Complex Utilities and Tricks, Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 更复杂的工具和技巧（第一部分）
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages686190.png.jpg)'
- en: This chapter is the first of two that explore more complex operations in Ruby.
    This one deals extensively with text manipulations and larger-scale searches,
    while the next details an important functional technique that expands your options
    for abstraction in a very powerful way. For now, let’s dive right in to learn
    some text processing techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是两章中第一章，探讨了 Ruby 中更复杂的操作。这一章主要涉及文本操作和更大规模的搜索，而下一章将详细说明一种重要的功能技术，它以非常强大的方式扩展了抽象的选项。现在，让我们直接深入学习一些文本处理技术。
- en: '#34 Finding Codes in the Bible or Moby-Dick (els_parser.rb)'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#34 在《圣经》或《白鲸》中寻找代码（els_parser.rb）'
- en: This script analyzes a phenomenon in large texts called equidistant letter sequences
    (ELSes). These sequences are popularly known as *Bible Codes* or *Torah Codes*,
    largely due to their description in Michael Drosnin’s book *The Bible Code* (Simon
    & Schuster, 1997), in which he examined the Hebrew Bible. An *ELS* is a collection
    of letters (what Ruby would call a String) with a known starting point within
    the source text, a known length, and a known *skip value*, which is the distance
    between the letters comprising that ELS. You could construct an ELS by saying,
    “Start with the 23rd letter in this newspaper article and add every 8th letter
    until you have 11 letters.” That String of 11 letters would be an ELS. Drosnin’s
    work suggests that ELSes of particular significance (generally due to relevance
    to the text they’re drawn from or due to accurate prediction of future events,
    such as assassinations) appear at a rate greater than chance within certain religious
    texts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本分析大型文本中的一种现象，称为等距字母序列（ELSes）。这些序列通常被称为*圣经代码*或*托拉代码*，这主要归因于迈克尔·德罗辛（Michael
    Drosnin）在其著作《圣经代码》（The Bible Code，Simon & Schuster，1997）中对它们的描述，他在书中考察了希伯来圣经。一个*ELS*是一组字母（Ruby
    会称之为 String），在源文本中有一个已知的起始点，一个已知的长度和一个已知的*跳值*，即构成该 ELS 的字母之间的距离。你可以通过说“从这个报纸文章的第
    23 个字母开始，每隔 8 个字母添加一个，直到你有 11 个字母”来构建一个 ELS。这 11 个字母的字符串将是一个 ELS。德罗辛的工作表明，具有特定意义的
    ELSes（通常由于与它们所抽取的文本的相关性或由于对未来事件（如暗杀）的准确预测）在特定宗教文本中的出现频率高于随机频率。
- en: My `els_parser.rb` script also uses the work of Professor Brendan McKay of The
    Australian National University. McKay has done his own research (available at
    [http://cs.anu.edu.au/~bdm/dilugim/torah.html](http://cs.anu.edu.au/~bdm/dilugim/torah.html))
    to find ELSes in texts like *War and Peace* and *Moby-Dick*, thus concluding that
    the ELSes that Drosnin refers to as the Bible Codes do not occur more often in
    the Hebrew Bible than can be expected due to chance. I can’t read Hebrew, so for
    this script I’ve chosen to analyze Herman Melville’s *Moby-Dick* in English instead
    of the Hebrew Bible. I downloaded the text from Project Gutenberg ([http://www.gutenberg.org](http://www.gutenberg.org))
    into `extras/moby_dick.txt`. The `els_parser.rb` script allows you to choose a
    text and a set of input parameters that describe a potential set of ELSes; then
    `els_parser.rb` will report whether any ELSes that match the description exist
    within the source text.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 `els_parser.rb` 脚本也使用了澳大利亚国立大学（The Australian National University）的布伦丹·麦凯（Professor
    Brendan McKay）的研究成果。[http://cs.anu.edu.au/~bdm/dilugim/torah.html](http://cs.anu.edu.au/~bdm/dilugim/torah.html)。麦凯在自己的研究（可在上述链接找到）中寻找文本如《战争与和平》和《白鲸》中的
    ELSes，从而得出结论，德罗辛所指的圣经代码在希伯来圣经中的出现频率并不比由于随机性可预期的频率更高。由于我不会读希伯来语，因此我选择分析赫尔曼·梅尔维尔（Herman
    Melville）的《白鲸》英文版而不是希伯来圣经。我从 Project Gutenberg ([http://www.gutenberg.org](http://www.gutenberg.org))
    下载了文本到 `extras/moby_dick.txt`。`els_parser.rb` 脚本允许你选择一个文本和一组描述潜在 ELSes 的输入参数；然后
    `els_parser.rb` 将报告是否存在与描述匹配的 ELSes。
- en: The Code
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How It Works
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The `els_parser.rb` script only processes letters, ignoring whitespace and punctuation.
    We know that Strings can also have non-letter characters, such a whitespace, numbers,
    punctuation, and so on; therefore, we need a method that strips all non-letters
    out of a String. Fortunately, we already have such a method—`letters_only`, defined
    in `palindrome2.rb`. It is easy to take advantage of `letters_only` with a `require`
    at the top of `els_parser.rb`. However, `palindrome2.rb` defined `letters_only`
    as a `private` method, and (as will become clear), we want it available as a public
    method. What can we do? One approach, which is what `els_parser.rb` does at ❶,
    is to define a new public method, `just_letters`, that exists merely to call the
    pre-existing `private` method `letters_only`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`els_parser.rb` 脚本仅处理字母，忽略空白和标点符号。我们知道字符串也可以包含非字母字符，例如空白、数字、标点符号等；因此，我们需要一个方法来从字符串中移除所有非字母字符。幸运的是，我们已经有这样一个方法——`letters_only`，它在
    `palindrome2.rb` 中定义。通过在 `els_parser.rb` 的顶部使用 `require`，我们可以轻松地利用 `letters_only`。然而，`palindrome2.rb`
    将 `letters_only` 定义为一个 `private` 方法，而（正如将变得清楚的那样），我们希望它作为一个公共方法可用。我们能做什么呢？一种方法，即
    `els_parser.rb` 在❶处所做的方法，是定义一个新的公共方法 `just_letters`，它仅仅是为了调用现有的 `private` 方法 `letters_only`。'
- en: The `just_letters` method is for Strings, but we want a new class called `ELS_Parser`
    to do the overall management of the searching. `ELS_Parser` has a Hash Constant
    called `DEFAULT_SEARCH_PARAMS` at ❷. The values for the `:start_pt` and `:end_pt`
    Symbol keys represent the earliest and latest character index for the search,
    respectively. The value for `:term` is the text to be searched for. Finally, the
    values for `:min_skip` and `:max_skip` are the minimum and maximum number of letters
    to jump past (i.e., skip) during the search. Why these particular default values?
    They could have been any values, but I took a shortcut and started with values
    from McKay’s web page ([http://cs.anu.edu.au/~bdm/dilugim/moby.html](http://cs.anu.edu.au/~bdm/dilugim/moby.html))
    that are known to correspond to a particular match within the text of *Moby-Dick*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`just_letters` 方法用于字符串，但我们需要一个新的类 `ELS_Parser` 来进行整体搜索管理。`ELS_Parser` 有一个名为
    `DEFAULT_SEARCH_PARAMS` 的哈希常量❷。对于 `:start_pt` 和 `:end_pt` 符号键的值分别代表搜索的最早和最晚字符索引。`:term`
    的值是要搜索的文本。最后，`:min_skip` 和 `:max_skip` 的值是在搜索期间跳过的最小和最大字母数（即跳过的字母数）。为什么这些特定的默认值？它们可以是任何值，但我采取了捷径，从麦凯的网页（[http://cs.anu.edu.au/~bdm/dilugim/moby.html](http://cs.anu.edu.au/~bdm/dilugim/moby.html)）中获取值，这些值已知与《白鲸记》文本中的特定匹配相对应。'
- en: Note some subtle differences—my values are 0-based (where a skip of 0 means
    *Go to the next letter*), whereas McKay defines moving to the next letter as a
    skip of 1\. There is a similar difference with regard to starting points. He also
    accomplishes searches for backward terms using a negative skip value, while `els_parser.rb`
    uses a positive skip search on a reversed term.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些细微的差异——我的值是 0 基础的（其中跳过值为 0 表示 *移动到下一个字母*），而麦凯将移动到下一个字母定义为跳过值为 1。在起始点方面也有类似的差异。他还使用负跳过值来完成向后搜索，而
    `els_parser.rb` 在反向术语上使用正跳过搜索。
- en: For example, in the String `‘abcdefgh’`, which we’ll call `contents`, searching
    for an ELS with a `:start_pt` of `0`, a `:term` of `‘abc’`, and a `:min_skip`
    of `0` would find a match, because the String `‘abc’` exists within `contents`
    starting at 0 (right at the beginning) with a skip value of 0\. Similarly, `‘ceg’`
    would be found within `contents` starting at 2 with a skip value of 1, and `‘heb’`
    would be found starting at 1 with a skip value of 2, but as a reversed String.
    If you expand these concepts greatly, use longer search terms, much larger `contents`
    (such as the Bible or *Moby-Dick*), and much larger starting, ending, and skip
    values, you will begin to understand the basics of ELS analysis.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在字符串 `'abcdefgh'`，我们将其称为 `contents`，使用 `:start_pt` 为 `0`、`:term` 为 `'abc'`
    和 `:min_skip` 为 `0` 的 ELS 搜索将找到匹配项，因为字符串 `'abc'` 在 `contents` 中从 0 开始存在（正好在开头）且跳过值为
    0。同样，`‘ceg’` 将在 `contents` 中从 2 开始找到，跳过值为 1，而 `‘heb’` 将从 1 开始找到，跳过值为 2，但作为一个反向字符串。如果你将这些概念大大扩展，使用更长的搜索词，更大的
    `contents`（如圣经或《白鲸记》），以及更大的起始、结束和跳过值，你将开始理解 ELS 分析的基本原理。
- en: After defining `DEFAULT_SEARCH_PARAMS`, our ELS_Parser needs an `initialize`
    method, in which it will define the instance variables `@contents`, to hold the
    text being searched, and `@filename`, to store the name of the file it read `@contents`
    from.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 `DEFAULT_SEARCH_PARAMS` 之后，我们的 `ELS_Parser` 需要一个 `initialize` 方法，在其中它将定义实例变量
    `@contents` 来保存要搜索的文本，以及 `@filename` 来存储它从读取 `@contents` 的文件名。
- en: The `@contents` variable is the result of calling the `prepare` method (defined
    at ❾) on the `filename`. The `prepare` method takes in a mandatory `filename`
    argument and an optional `case_matters` argument. All it does is open a new file,
    extract its `contents` into a String with `readlines.to_s`, and call `just_letters`
    on that String. This ensures that we strip out inappropriate characters from our
    String before storing it in `@contents`. Note that `just_letters` takes an optional
    argument for case sensitivity. If you’re curious about how this works, remember
    that `just_letters` just calls the `letters_only` method defined in `palindrome2.rb`,
    so you can refer to that script for further study.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`@contents` 变量是调用 `filename` 上的 `prepare` 方法（定义在❾）的结果。`prepare` 方法接受一个必填的 `filename`
    参数和一个可选的 `case_matters` 参数。它所做的一切就是打开一个新文件，使用 `readlines.to_s` 将其 `contents` 提取成一个
    String，然后对这个 String 调用 `just_letters` 方法。这确保我们在将字符串存储到 `@contents` 之前，从字符串中移除不适当的字符。请注意，`just_letters`
    方法可以接受一个用于大小写敏感性的可选参数。如果你对这个工作原理感到好奇，请记住 `just_letters` 只调用在 `palindrome2.rb`
    中定义的 `letters_only` 方法，因此你可以参考该脚本进行进一步的学习。'
- en: 'The `initialize` method also calls the `reset_params` method, defined right
    below `initialize`, which simply sets the instance variable `@search_params` to
    the `search_params` argument passed into `initialize`, falling back to the `DEFAULT_SEARCH_PARAMS`.
    It also sets the `:end_pt` value to fall back to the last index of `@contents`
    if the `:end_pt` value would otherwise be `nil`. This gives `ELS_Parser` a handy
    shortcut: leaving out the `:end_pt` automatically means *Search to the end of*
    *`@contents`*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize` 方法还调用了定义在 `initialize` 之下的 `reset_params` 方法，它简单地将实例变量 `@search_params`
    设置为传递给 `initialize` 的 `search_params` 参数，如果 `:end_pt` 值为 `nil`，则回退到 `DEFAULT_SEARCH_PARAMS`。它还将
    `:end_pt` 值设置为回退到 `@contents` 的最后一个索引。这为 `ELS_Parser` 提供了一个方便的快捷方式：省略 `:end_pt`
    自动意味着 *搜索到 `@contents` 的末尾*。'
- en: Next is `search` at ❸. It allows an optional `term` argument, which automatically
    updates `@search_params[:term]` as needed. Since `search` is set up to find reversed
    `term`s as well as normal-order `term`s, we define `reversed_term` right away.
    We also report that the search is starting if `$DEBUG` is true using the method
    `warn`, which writes out to *standard error*, instead of *standard out*. `$DEBUG`
    is generally set as a command-line option to `ruby`, such that `$DEBUG` is true
    when you execute `ruby` with either the `-d` or `--debug` flag. You may remember
    standard error from `html_tidy.rb`. In that script, we sent standard error to
    `/dev/null`, meaning we didn’t care about it. Here, we have a special message
    designed specifically to go to standard error.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是❸处的 `search`。它允许一个可选的 `term` 参数，该参数会根据需要自动更新 `@search_params[:term]`。由于
    `search` 被设置为寻找倒序 `term` 以及正常顺序 `term`，我们立即定义了 `reversed_term`。我们还使用 `warn` 方法报告搜索开始，如果
    `$DEBUG` 为真，该方法将写入 *标准错误*，而不是 *标准输出*。`$DEBUG` 通常作为 `ruby` 的命令行选项设置，这意味着当你使用 `-d`
    或 `--debug` 标志执行 `ruby` 时，`$DEBUG` 为真。你可能还记得 `html_tidy.rb` 中的标准错误。在那个脚本中，我们将标准错误发送到
    `/dev/null`，这意味着我们不在乎它。在这里，我们有一个专门设计用于发送到标准错误的消息。
- en: After the standard error warning, we define `final_start_pt` at ❹. To understand
    what `final_start_pt` is for, let’s go back to our `contents` = `‘abcdefgh’` search
    example. What if we search for `‘hiccup’` with a `:start_pt` of 100? There aren’t
    even 100 letters in our `contents`, so a search with that `:start_pt` value would
    automatically fail. Instead of letting that happen, we want to figure out the
    maximum starting index that could conceivably work, and make sure `:start_pt`
    is not larger than that value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准错误警告之后，我们在❹处定义了 `final_start_pt`。要了解 `final_start_pt` 的用途，让我们回到我们的 `contents`
    = `‘abcdefgh’` 搜索示例。如果我们以 `:start_pt` 为 100 搜索 `‘hiccup’` 会怎样？在我们的 `contents`
    中甚至没有 100 个字母，所以具有该 `:start_pt` 值的搜索会自动失败。我们不想让这种情况发生，我们想要找出可能工作的最大起始索引，并确保 `:start_pt`
    不大于该值。
- en: It’s even more complicated than that. Our search terms will always have letters,
    and those letters take up space. If we start too close to the end of `@contents`,
    we could run out of room even with relatively low skip values. We need to keep
    enough room for the term being searched for, which we store in `@search_params[:term]`,
    so we set `final_start_pt` accordingly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至比那还要复杂。我们的搜索词总是包含字母，而这些字母会占用空间。如果我们从 `@contents` 的末尾开始太近，即使有相对较低的跳过值，我们也可能没有足够的空间。我们需要为正在搜索的术语留出足够的空间，我们将该术语存储在
    `@search_params[:term]` 中，因此我们相应地设置 `final_start_pt`。
- en: After setting `final_start_pt`, we enter two nested loops—one on `index` from
    the lowest to highest starting points and one using `skip` to refer to each number
    from the lowest to highest skip values. The first thing we do within those loops
    is use `index` and `skip` at ❺ to assign the expression returned from `construct_candidate`,
    defined at ❽, into `candidate`. The `construct_candidate` method takes the existing
    `index` and `skip` values and makes a String of the same length as the term being
    searched for. For a `@contents` of `‘abcdefgh’, construct_candidate(2, 1)` produces
    `‘ceg’` where `@search_params[:term]` has three characters in it. The `construct_candidate`
    method returns the empty String if the `new_index` being asked for ever goes beyond
    the `@contents` String. Our `final_start_pt` limits should prevent this from ever
    being needed, but it’s an additional safety check.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `final_start_pt` 之后，我们进入两个嵌套循环——一个是在 `index` 从最低到最高起始点，另一个是使用 `skip` 指向每个从最低到最高的跳过值。在这些循环中我们做的第一件事是在❺处使用
    `index` 和 `skip` 将 `construct_candidate` 返回的表达式分配给 `candidate`，`construct_candidate`
    定义在❽处。`construct_candidate` 方法接受现有的 `index` 和 `skip` 值，并生成一个与正在搜索的术语长度相同的 String。对于
    `@contents` 为 `‘abcdefgh’` 的情况，`construct_candidate(2, 1)` 生成 `‘ceg’`，其中 `@search_params[:term]`
    有三个字符。如果请求的 `new_index` 超过了 `@contents` String，`construct_candidate` 方法返回空 String。我们的
    `final_start_pt` 限制应该防止这种情况发生，但这是一个额外的安全检查。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The *`construct_candidate`* method also uses the *`chr`* method, because extracting
    a single character out of a String gives you that character’s ASCII value*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*`construct_candidate` 方法也使用了 *`chr`* 方法，因为从 String 中提取单个字符会给你该字符的 ASCII 值*。'
- en: 'You can test this in irb:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 irb 中测试这个：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After establishing our `candidate`, we want to see if it is a successful match,
    which we start to do at ❻. If it does match, we `return` the result of calling
    `report_match` with `skip` and `index` as arguments. However, we also want to
    know whether our `candidate` matches the `reversed_term` instead of the term in
    regular order, so we call `report_match`, again with `skip` and `index` as arguments,
    but we also add the String `‘reversed ’`. Finally, at ❼ we return the result of
    calling `report_match` with two explicit `false` arguments if we’ve looped through
    all of the appropriate `skip` and `index` loops without already returning something.
    This just means that we never found a match, either forward or reversed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立我们的 `candidate` 之后，我们想看看它是否是一个成功的匹配，我们从❻开始这样做。如果它匹配，我们 `return` 调用 `report_match`
    的结果，其中 `skip` 和 `index` 作为参数。然而，我们还想知道我们的 `candidate` 是否与 `reversed_term` 匹配，而不是按常规顺序的术语，所以我们再次调用
    `report_match`，同样使用 `skip` 和 `index` 作为参数，但我们也添加了 String `‘reversed ’`。最后，在❼，如果我们已经遍历了所有适当的
    `skip` 和 `index` 循环而没有返回任何内容，我们返回调用 `report_match` 的两个显式 `false` 参数的结果。这仅仅意味着我们从未找到匹配项，无论是正向还是反向。
- en: We need to know how `report_match` works. It’s defined at ❿, and it takes arguments
    for `skip, index`, and an optional `reversed` String, as already shown. If `index`
    is `false, report_match` returns a String informing the user that there was no
    match found. Otherwise, It returns the details of the successful match. Note that
    `reversed` adds the String `‘reversed ’` (including the trailing space) as needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解 `report_match` 的工作原理。它在❿处定义，并接受 `skip`、`index` 和一个可选的 `reversed` String
    参数，如前所述。如果 `index` 是 `false`，`report_match` 返回一个 String，通知用户没有找到匹配项。否则，它返回成功匹配的详细信息。请注意，`reversed`
    根据需要添加 String `‘reversed ’`（包括尾随空格）。
- en: Running the Script
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: 'We can test this with another script called `demo_els_parser.rb`. Here is its
    code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用另一个名为 `demo_els_parser.rb` 的脚本进行测试。以下是它的代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Results
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: 'Here is the result of calling this script:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用此脚本的结果：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Hacking the Script
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改脚本
- en: We could significantly increase the speed of `construct_candidate` by checking
    against the search terms as we go and returning the empty string whenever it fails
    to match—an application of the return guard notion within the construction of
    the candidate. Where we define `final_start_pt`, we could also either limit `:max_skip`
    in a similar way or report an error if impossible search parameters were asked
    for.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在执行过程中检查搜索词并返回空字符串（如果它不匹配）来显著提高 `construct_candidate` 的速度——这是在构建候选词时应用返回保护概念的实例。在我们定义
    `final_start_pt` 的地方，我们也可以以类似的方式限制 `:max_skip`，或者在请求了不可能的搜索参数时报告错误。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*There’s also a better way to include the *`letters_only`* method than the
    way I’ve done it here, using a concept called a mixin. Jump ahead to the *`to_lang.rb`*
    script in [Chapter 10](ch10.html "Chapter 10. More Complex Utilities and Tricks,
    Part II") to see mixins in action*.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*还有比我在这里所做的方法更好的方法来包含 *`letters_only`* 方法，那就是使用一个名为 mixin 的概念。跳转到 *`to_lang.rb`*
    脚本，在 [第 10 章](ch10.html "第 10 章。更复杂的工具和技巧，第二部分") 中查看 mixin 的实际应用*。'
- en: '#35 Mutating Strings into Weasels (methinks.rb)'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#35 将字符串转换为狐狸（methinks.rb）'
- en: This script is based on a program from Richard Dawkins’ *The Blind Watchmaker*
    (W.W. Norton, 1996).The program demonstrates a simplified model of asexual natural
    selection, starting with a String consisting of random characters and successively
    mutating it to produce “children” that differ from the parent. The program then
    selects the “best” child String (meaning the one that most closely matches the
    target String `methinksitislikeaweasel`, a reference from *Hamlet*) to be the
    next generation’s parent. This process continues until the parent String matches
    the target String.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本基于理查德·道金斯 *《盲眼钟表匠》*（W.W. Norton，1996）中的一个程序。该程序演示了一个简化的无性自然选择模型，从一个由随机字符组成的字符串开始，并连续地对其进行突变以产生与父代不同的“子代”。然后程序选择“最佳”子代字符串（意味着最接近目标字符串
    `methinksitislikeaweasel`，这是来自 *《哈姆雷特》* 的引用）作为下一代父代。这个过程一直持续到父代字符串与目标字符串匹配。
- en: Let’s implement Dawkins’ process in Ruby.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Ruby 中实现道金斯的进程。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Dawkins wrote his program to demonstrate a version of cumulative selection
    over time that was intentionally simpler than real-world neo-Darwinian natural
    selection. Critics contend that the program is a suboptimal model, with the most
    prominent criticisms being that it is overly simplified, it is unable to fail,
    and it has a preset target, making it a better model of artificial selection than
    natural selection. See [Hacking the Script](ch09s02.html#hacking_the_script-id023
    "Hacking the Script") on page 175 for general suggestions for modifying this version
    of the program to be a better model of real-world Darwinian selection*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*道金斯编写这个程序是为了展示一种累积选择版本，它故意比现实世界的现实达尔文自然选择更简单。批评者认为这个程序是一个次优模型，最突出的批评是它过于简化，它无法失败，并且有一个预设的目标，这使得它比自然选择更适合作为人工选择的模型。请参阅第
    175 页的 [Hacking the Script](ch09s02.html#hacking_the_script-id023 "Hacking the
    Script")，以获取修改此版本程序以使其成为现实世界达尔文选择更好模型的通用建议*。'
- en: The Code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How It Works
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We start by defining a new class called Children at ❶. You’ll notice the peculiar
    `Children < Array` within the class definition, which suggests a relationship
    between Children and Arrays. That relationship is *inheritance*. Children inherits
    from Array, meaning that it behaves as an Array in every way, while also adding
    whatever new characteristics we give it. In our case, the only new characteristic
    is a new method called `select_fittest`, which uses `inject` to find the fittest
    child within Children, defined by the `fitter_than?` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个名为 Children 的新类 ❶。你会在类定义中注意到独特的 `Children < Array`，这表明了 Children 和
    Arrays 之间的关系。这种关系是 *继承*。Children 继承自 Array，意味着它在所有方面都表现得像 Array，同时添加了我们赋予它的任何新特性。在我们的例子中，唯一的新特性是名为
    `select_fittest` 的新方法，它使用 `inject` 来在 Children 中找到最适应的子代，这是通过 `fitter_than?` 方法定义的。
- en: CHILDREN DON’T LIE
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CHILDREN DON’T LIE
- en: 'There’s one other way in which a child class (or subclass) differs from its
    parent, and that’s the expression returned by the class method. It returns the
    name of the subclass when called on an instance of the subclass:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 子类（或子类）与父类不同的另一个方面是类方法返回的表达式。当在子类的实例上调用时，它返回子类的名称：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some people may think that’s obvious, but it’s worth noting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为这是显而易见的，但值得注意。
- en: 'After defining Children, we open the String class at ❷. We add several Constants,
    including an Array of letters that we’ll call the `ALPHABET`, and `LETTER_OFFSET`.
    The `LETTER_OFFSET` Constant requires some explanation. It represents characters
    as ASCII values to determine how closely certain Strings match each other. Converting
    letters to numerical value is convenient, as it allows us to use basic mathematical
    operations to find the “most fit” child string. Ruby converts characters to numerical
    values by treating a String as an Array and reading values out with indices. Let’s
    demonstrate in irb (the `chr` method converts from ASCII values back to a String):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 Children 之后，我们在 ❷ 处打开字符串类。我们添加了几个常量，包括一个我们将称之为 `ALPHABET` 的字母数组，以及 `LETTER_OFFSET`。`LETTER_OFFSET`
    常量需要一些解释。它表示字符为 ASCII 值，以确定某些字符串之间的匹配程度有多接近。将字母转换为数值值很方便，因为它允许我们使用基本的数学运算来找到“最合适”的子字符串。Ruby
    通过将字符串视为一个数组并通过索引读取值来将字符转换为数值。让我们在 irb 中演示（`chr` 方法将 ASCII 值转换回字符串）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see that the ASCII value for the String `‘a’` (the character at index
    `0` in String `s`) is `97`, that the `chr` method converts that ASCII value back
    to `‘a’`, and that the ASCII value for `‘b’` is `98`. The number `97` is our `LETTER_OFFSET`.
    Astute readers will notice that `LETTER_OFFSET` is the index at which `‘a’` appears
    in our `ALPHABET`, as well. Observe the following in irb:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到字符串 `'a'`（在字符串 `s` 中的索引 `0` 处的字符）的 ASCII 值是 `97`，`chr` 方法将这个 ASCII 值转换回
    `'a'`，而 `'b'` 的 ASCII 值是 `98`。数字 `97` 是我们的 `LETTER_OFFSET`。敏锐的读者会注意到 `LETTER_OFFSET`
    也是 `'a'` 在我们的 `ALPHABET` 中的索引。观察以下在 irb 中的内容：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Calling `[0]` on a character and subtracting `LETTER_OFFSET` (`‘a’[0]`, or `97`)
    gives us the index of that character within our `ALPHABET` Array. This will be
    very handy in the `mutate_char` method at ❿, which we’ll discuss when we get there.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个字符上调用 `[0]` 并减去 `LETTER_OFFSET`（`‘a’[0]` 或 `97`）将给我们这个字符在 `ALPHABET` 数组中的索引。这在
    `mutate_char` 方法（❿）中会非常有用，我们将在到达那里时讨论它。
- en: Our next two Constants are `PARAMS` and `TARGET`. Both of these establish defaults
    for items that might be overridden by optional arguments. `PARAMS` is a now-familiar
    Hash with Symbol keys, each value of which determines the specific behavior of
    our mutations. The value for `:generation_size` is the number of children, `:mutation_rate`’s
    is the percentage chance that a mutation will occur at all, `:display_filter`
    just sets how often our program will give updates while it’s running, and `:mutation_amp`
    determines how strong or divergent a given mutation can be—basically a numeric
    measure of how different children can be from their parents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的两个常量是 `PARAMS` 和 `TARGET`。这两个常量为可能被可选参数覆盖的项目设置了默认值。`PARAMS` 是一个现在大家都很熟悉的带有符号键的哈希，其中每个值都决定了我们突变的具体行为。`:generation_size`
    的值是子代数量，`:mutation_rate` 的值是突变发生的百分比概率，`:display_filter` 只设置程序运行时更新的频率，而 `:mutation_amp`
    决定了给定突变可以有多强或多发散——基本上是一个衡量子代与父代差异的数值度量。
- en: '`TARGET` is our default final goal: `methinksitislikeaweasel`. Finally, after
    the Constants, we have a single class variable called `@mutation_attempts`, which
    is just a counter that increments every time we mutate. We’re ready to start defining
    some methods.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`TARGET` 是我们的默认最终目标：`methinksitislikeaweasel`。最后，在常量之后，我们有一个名为 `@mutation_attempts`
    的单个类变量，它只是一个计数器，每次突变时都会增加。我们现在可以开始定义一些方法了。'
- en: 'Our first new method to add to String is `deviance_from` (❸). It takes a mandatory
    target argument (the default fallback to the `TARGET` Constant occurs in `mutate_until_matches!`
    at ❺, which is later in the code but is called earlier). The `deviance_from` method
    returns an Integer (`deviance`) which is a numeric measure of how different two
    Strings are. Each character of difference at each point within the String increments
    `deviance` by one. Here are some irb examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加到字符串的第一个新方法是 `deviance_from`（❸）。它需要一个强制性的目标参数（默认回退到 `TARGET` 常量发生在 `mutate_until_matches!`（❺）中，这在代码中稍后，但被较早调用）。`deviance_from`
    方法返回一个整数（`deviance`），它是两个字符串差异的数值度量。字符串中每个位置的每个字符差异都会使 `deviance` 增加一。以下是一些 irb
    中的示例：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method is useful for our script, because if we are trying to model the
    survival of the fittest, we need to be able to measure fitness. A low `deviance_from`
    the `target` represents fitness. Just below `deviance_from` is `fitter_than?`,
    a simple predicate that compares the `deviance_from` value for `self` and the
    `deviance_from` value for the `other` String, both relative to the same `target`.
    It only returns `true` when `self`’s `deviance_from` value is lower, making `self`
    fitter. Take a look at [Hacking the Script](ch09s02.html#hacking_the_script-id023
    "Hacking the Script") on page 175 for a way to eliminate this method entirely.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法对我们脚本很有用，因为我们试图模拟适者生存，我们需要能够衡量适应性。低于 `target` 的 `deviance_from` 表示适应性。紧接在
    `deviance_from` 之下是 `fitter_than?`，这是一个简单的谓词，它比较 `self` 和另一个 String 的 `deviance_from`
    值，两者相对于相同的 `target`。只有当 `self` 的 `deviance_from` 值更低时，它才返回 `true`，使 `self` 更适应。请参阅第
    175 页的 [Hacking the Script](ch09s02.html#hacking_the_script-id023 "Hacking the
    Script")，了解如何完全消除此方法。
- en: Next up is `mutate` (❹). It takes a mandatory `params` argument, which falls
    back to the default `PARAMS` Constant in `mutate_until_matches!` (❺) earlier within
    the script’s operation, if necessary. The `mutate` method is remarkably lazy,
    in that it `split`s its calling object into individual characters, and calls `mutate_char`
    (❿) on each of those characters via `map`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `mutate` (❹)。它需要一个必填的 `params` 参数，如果需要，会回退到脚本操作中较早的 `mutate_until_matches!`
    (❺) 中的默认 `PARAMS` 常量。`mutate` 方法非常懒惰，因为它会将调用对象 `split` 成单个字符，并通过 `map` 对每个字符调用
    `mutate_char` (❿)。
- en: The `mutate_char` method is a bit more complicated. It takes mandatory arguments
    for the `original_char` and `params`, and it exits immediately if `params` says
    that it should not mutate, which is determined by a random percentage being higher
    than `params[:mutation_rate]`. Assuming it passed `params`’ test, `mutate_char`
    will mutate the character. First, it declares a `variance`, which is just the
    amount and direction of change based on the `:mutation_amp`. The values for `variance`
    range from `+(:mutation_amp / 2)` to `-(:mutation_amp / 2)`, excluding zero. They
    initially vary from `-(:mutation_amp / 2)` to one less than `+(:mutation_amp /
    2)`, including zero, but the line that executes `variance +=1 if variance.zero?`
    ensures that values of zero or higher are bumped up by one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate_char` 方法稍微复杂一些。它需要 `original_char` 和 `params` 的必填参数，如果 `params` 指示不应变异，则立即退出，这是通过一个随机百分比高于
    `params[:mutation_rate]` 来确定的。假设它通过了 `params` 的测试，`mutate_char` 将会变异字符。首先，它声明一个
    `variance`，这仅仅是基于 `:mutation_amp` 的变化量和方向。`variance` 的值范围从 `+(:mutation_amp /
    2)` 到 `-(:mutation_amp / 2)`，不包括零。它们最初从 `-(:mutation_amp / 2)` 变化到 `+(:mutation_amp
    / 2)` 以下，包括零，但执行 `variance +=1 if variance.zero?` 的那行代码确保了零或更高的值增加一个。'
- en: It then creates an `alphabet_index` variable, which uses `LETTER_OFFSET` as
    previously discussed to find that index within `ALPHABET` for our `original_char`,
    plus any appropriate `variance`. It then limits `alphabet_index` with the `limit_index`
    method (❾), which clips or truncates `alphabet_index` to a maximum of the last
    index within `ALPHABET` and minimum of `0`, which is the first index within `ALPHABET`.
    Since it then has a dependable index to read from `ALPHABET`, it does so, placing
    that value within a variable called `mutated_char`, which it then `return`s.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它创建一个 `alphabet_index` 变量，使用之前讨论的 `LETTER_OFFSET` 来找到 `original_char` 在 `ALPHABET`
    中的索引，加上任何适当的 `variance`。然后，它使用 `limit_index` 方法 (❾) 限制 `alphabet_index`，该方法将 `alphabet_index`
    剪裁或截断到 `ALPHABET` 中最后一个索引的最大值和 `0` 的最小值，即 `ALPHABET` 中的第一个索引。由于它已经有了可靠的索引来从 `ALPHABET`
    中读取，它就这样做了，将那个值放入一个名为 `mutated_char` 的变量中，然后返回它。
- en: Following `mutate` is `mutate_until_matches!` (❺), which is the public-facing
    workhorse of the script. It takes optional arguments for `target` and `params`,
    falling back to String’s `TARGET` and `PARAMS` Constants, as mentioned in earlier
    discussions of other methods. If `self` matches the `target` exactly, we want
    to `report_success`. Failing that, we want to `report_progress`. We can look at
    both of those methods, which start at ❼. The `report_success` method uses `puts`
    to show that it matches exactly after a certain number of attempts, and it returns
    `@mutation_attempts` without incrementing it. (There’s no need to increment it,
    since no new mutation occurred.) The `report_progress` method returns with no
    value unless `@mutation_attempts` is a multiple of (i.e., has a modulus of 0 relative
    to) `params[:display_filter]`. If we set a lower display filter, we have a chattier
    mutation process. Assuming that it should output, it uses `puts` to show what
    `self` is after however many `@mutation_attempts`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutate`之后是`mutate_until_matches!`（❺），这是脚本的公共工作马。它接受可选的`target`和`params`参数，如果没有提供，则回退到之前讨论的其他方法中提到的String的`TARGET`和`PARAMS`常量。如果`self`与`target`完全匹配，我们希望`report_success`。如果没有匹配，我们希望`report_progress`。我们可以查看这两个方法，它们从❼开始。`report_success`方法使用`puts`显示在经过一定次数的尝试后它完全匹配，并且返回`@mutation_attempts`而不增加它。（没有必要增加它，因为没有发生新的变异。）`report_progress`方法在没有值的情况下返回，除非`@mutation_attempts`是`params[:display_filter]`的倍数（即相对于`params[:display_filter]`的余数为0）。如果我们设置一个较低的显示过滤器，我们将有一个更健谈的变异过程。假设它应该输出，它使用`puts`显示在经过多少次`@mutation_attempts`之后`self`的状态。
- en: After reporting its progress, `mutate_until_matches!` should then actually do
    some mutating. It increments `@mutation_attempts` and then creates a new variable
    called `children`, which is the output of `propagate` (❻). The `propagate` method
    takes some `params` and instantiates a new instance of Children (❶), meaning that
    it has access to `select_fittest`, which is not available to Arrays. It appends
    it `self` onto `children`, the effect of which is that if the parent (`self`)
    is fitter than all of the `children`, the parent will again be the source of the
    generation of `children` after this one. The `propagate` method then appends a
    child (a mutated version of it `self`) onto `children`, doing so a number of times
    equal to `params[:generation_size]`. Finally, it returns the `children`, who will
    then try to make their way in the cruel world.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告进度之后，`mutate_until_matches!`应该实际进行一些变异。它增加`@mutation_attempts`，然后创建一个名为`children`的新变量，这是`propagate`（❻）的输出。`propagate`方法接受一些`params`并实例化一个新的`Children`实例（❶），这意味着它能够访问`select_fittest`，这是数组所不具备的。它将`self`添加到`children`中，其效果是如果父母（`self`）比所有`children`都更适应，那么在这次之后，父母将再次成为生成下一批`children`的来源。`propagate`方法接着将一个孩子（它自身的变异版本）添加到`children`中，重复此操作次数等于`params[:generation_size]`。最后，它返回`children`，然后这些`children`将尝试在残酷的世界中找到自己的道路。
- en: The effect of the cruel world is accomplished via Children’s `select_fittest`
    method. The world is cruel indeed, because only one child survives, as discussed
    already. We call the fittest child `fittest`, appropriately, and `replace` the
    parent with this fittest child. Then `mutate_until_matches!` recursively calls
    itself, mutating until it finally matches the `target`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 世界的残酷效应是通过儿童的`select_fittest`方法实现的。世界确实很残酷，因为只有一名儿童能够幸存，正如之前所讨论的。我们恰当地将最适应环境的儿童称为`fittest`，并用这个最适应环境的儿童来`replace`父母。然后`mutate_until_matches!`递归地调用自身，直到最终与`target`匹配。
- en: 'Two methods remain undescribed: `scramble` and `scramble!` (❽). Both of these
    methods take an optional `target` argument that defaults to `TARGET`. Since `scramble!`
    is destructive, it sets `self`’s `@mutation_attempts` to `0` and `replace`s it
    `self` with the value returned by the non-destructive `scramble`. The `scramble`
    method `split`s the `target` at each `char` and creates a new Array via `map`;
    each member of the new Array is a random element from `ALPHABET`. Note that we
    don’t even make any use of `char`—we just use `map` to make sure that the scrambled
    String is the same `size` as the `target`. The `scramble` method then `join`s
    that Array of random characters with the empty String and returns the resulting
    String: a String of the same length as the target, consisting entirely of random
    letters.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种方法尚未描述：`scramble` 和 `scramble!`（❽）。这两种方法都接受一个可选的 `target` 参数，默认为 `TARGET`。由于
    `scramble!` 是破坏性的，它将 `self` 的 `@mutation_attempts` 设置为 `0` 并用非破坏性的 `scramble`
    返回的值替换 `self`。`scramble` 方法将 `target` 在每个 `char` 处分割，并通过 `map` 创建一个新的 Array；新
    Array 的每个成员都是来自 `ALPHABET` 的随机元素。请注意，我们甚至没有使用 `char`——我们只是使用 `map` 确保打乱的字符串与 `target`
    具有相同的 `size`。然后 `scramble` 方法将随机字符的 Array 与空字符串连接起来，并返回结果字符串：一个与目标长度相同的字符串，由完全随机的字母组成。
- en: Running the Script
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: Let’s try it out in irb.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 irb 中试试。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Results
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Try it on your own machine, and notice that the results are random—sometimes
    the script takes more generations, sometimes fewer. If you pass in different values,
    you can get dramatically different results:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在自己的机器上尝试，注意结果可能是随机的——有时脚本需要更多代数，有时则较少。如果你传入不同的值，可以得到截然不同的结果：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll explore this program further in our next script, `methinks_meta.rb`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个脚本 `methinks_meta.rb` 中进一步探索这个程序。
- en: Hacking the Script
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: The `select_fittest` method could be expressed as follows in terms of `sort_by`,
    rather than `inject`. The returned value is exactly the same, whether it’s the
    memoization within `inject` or the member of the sorted `Children` at the zeroth
    index. Using `sort_by` would also allow us to eliminate the `fitter_than?` method
    entirely.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`select_fittest` 方法可以用 `sort_by` 来表达，而不是 `inject`。无论是在 `inject` 中的记忆化还是排序后的
    `Children` 的零索引成员，返回的值都是相同的。使用 `sort_by` 还允许我们完全消除 `fitter_than?` 方法。'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `replace` in `mutate_until_matches!` is what makes it destructive, making
    it appropriate for its name to end with a bang. The `mutate_until_matches!` method
    could easily have been purely functional by replacing the last two lines of the
    method with `return fittest.mutate_until_matches(target, params)`, although the
    name would then have been misleading, even without the bang—perhaps simply `get_match`
    would be a better name in this case. In addition, the `@mutation_attempts` variable
    would not be retained from mutation to mutation. We would have to alter `mutate_until_matches!`
    (or `get_match`, or whatever other new name it would have) to accept `mutation_attempts`
    as an optional argument, defaulting to zero for the first call. Its treatment
    would be very similar to how `els_parser.rb` updates `@search_params[:term]` with
    the optional `term` argument.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate_until_matches!` 中的 `replace` 使其具有破坏性，使其名称以感叹号结尾是合适的。`mutate_until_matches!`
    方法本可以完全通过将方法的最后两行替换为 `return fittest.mutate_until_matches(target, params)` 来实现纯函数式，尽管这样名称可能会误导，即使没有感叹号——在这种情况下，也许简单地命名为
    `get_match` 会更好。此外，`@mutation_attempts` 变量不会在每次变异中保留。我们不得不修改 `mutate_until_matches!`（或
    `get_match` 或它将拥有的任何其他新名称）以接受 `mutation_attempts` 作为可选参数，默认为第一个调用时的零。其处理方式将与 `els_parser.rb`
    使用可选的 `term` 参数更新 `@search_params[:term]` 的方式非常相似。'
- en: What would stop us from implementing the `propagate` method (❻) with something
    like the following code?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码如何阻止我们实现 `propagate` 方法（❻）？
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The main problem is that the returned value from `propagate` would be an `Array`,
    not a `Children`, meaning that it would not have access to the `select_fittest`
    method that we added to `Children`, our subclass of `Array`. We could use our
    new definition of `propagate` by eliminating the subclassing of `Children < Array`
    (❶) and simply adding the `select_fittest` method to all `Array`s.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是 `propagate` 返回的值将是一个 `Array`，而不是 `Children`，这意味着它将无法访问我们添加到 `Children`（我们的
    `Array` 子类）中的 `select_fittest` 方法。我们可以通过消除 `Children < Array`（❶）的子类化来使用我们新的 `propagate`
    定义，并简单地将 `select_fittest` 方法添加到所有 `Array`s 中。
- en: You could also modify this program to be a more accurate model of a more complex
    type of cumulative selection, such as real-world Darwinian selection. Such a program
    would have multiple competing “species” of Strings, something to represent food
    supplies (which would be in finite supply and be consumed by the reproduction
    process), multiple potentially-successful targets not preset by the programmer,
    and so on. The changes would allow some Strings’ descendants to be unable to produce
    competitive children (and thus become extinct), while other Strings’ descendants
    would flourish, just like organisms in the real world.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以修改此程序，使其成为一个更复杂的累积选择的更准确模型，例如现实世界的达尔文选择。这样的程序将会有多个竞争的“物种”字符串，一些表示食物供应（这将有限供应，并被繁殖过程消耗），多个程序员未预设的潜在成功的目标，等等。这些变化将允许一些字符串的后代无法产生具有竞争力的后代（因此灭绝），而其他字符串的后代则会繁荣昌盛，就像现实世界中的生物一样。
- en: '#36 Mutating the Mutation of Strings into Weasels (methinks_meta.rb)'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#36 将字符串的变异变为狐狸（methinks_meta.rb）'
- en: This script uses the previous one, `methinks.rb`, so make sure you understand
    how that one works before trying this one, `methinks_meta.rb`. This script uses
    techniques similar to those used in `methinks.rb` to find the “best” input parameters
    for `methinks.rb`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本使用之前的脚本，即`methinks.rb`，所以在尝试此脚本`methinks_meta.rb`之前，请确保你理解了那个脚本的工作原理。此脚本使用与`methinks.rb`中使用的类似的技术来找到`methinks.rb`的“最佳”输入参数。
- en: 'The previous script’s performance (the number of generations it takes to match
    the target) can vary greatly from one run to the next. Two major factors affect
    that variation in our results: The first factor is the set of arbitrary starting
    parameters. We saw that a target of `hello` was much easier to reach quickly than
    a target of `methinksitislikeaweasel`. Using other values for `:mutation_rate`
    or the other parameters also has an impact. The second factor is the unpredictable
    nature of the random variations while the program runs. Over time, after many
    runs, the laws of probability will cause this second factor to be less and less
    important—and in any case, randomness is part of the given problem. Our arbitrary
    starting parameters are crucial. How do we decide what they should be?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前脚本的性能（匹配目标所需的生成次数）可能会在每次运行之间有很大的差异。影响我们结果变化的主要有两个因素：第一个因素是任意起始参数的集合。我们发现，达到目标`hello`比达到目标`methinksitislikeaweasel`要容易得多。使用其他值对于`:mutation_rate`或其他参数也有影响。第二个因素是程序运行过程中随机变化的不可预测性。随着时间的推移，经过多次运行后，概率定律将导致第二个因素变得越来越不重要——无论如何，随机性是给定问题的一部分。我们的任意起始参数至关重要。我们如何决定它们应该是什么？
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Varying the *`:display_filter`* has no impact on how many generations it takes
    to reach the target, only how often the program reports on its own progress. Also,
    genuine random number generation is possible with computers—often by measuring
    the decay of radioactive elements or listening to noise from a microphone—but
    our “random” number generation is actually only pseudo-random. Pseudo-random numbers
    come from a process that has a pattern, making them unsuitable for use in heavy-duty
    applications like stress testing or cryptography. They’re random enough for our
    script’s purposes, though. This pseudo-random caveat applies to all random numbers
    in this book*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*改变`:display_filter`*对达到目标所需的生成次数没有影响，只会影响程序报告其自身进度有多频繁。此外，计算机上可以实现真正的随机数生成——通常是通过测量放射性元素的衰变或监听麦克风的噪音——但我们的“随机”数生成实际上是伪随机。伪随机数来自一个有模式的过程，这使得它们不适合用于压力测试或密码学等重型应用。尽管如此，对于我们的脚本来说，它们已经足够随机了。此伪随机注意事项适用于本书中所有随机数。'
- en: 'The arbitrary set of input parameters is the major problem facing the efficiency
    of our string’s mutations. Luckily, we’d recognize an ideal set of parameters
    if we saw them, and we can easily rate parameter sets as better or worse in relation
    to each other, because we have an easy way to measure success: A low number of
    generations needed to reach the target String. We already have a way to process
    candidates repeatedly to reach a given target—it’s called `methinks.rb`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随机输入参数的任意集合是我们字符串变异效率面临的主要问题。幸运的是，如果我们看到了理想的参数集合，我们就能识别出来，并且我们可以很容易地根据彼此之间的关系对参数集合进行优劣评估，因为我们有一个简单的方式来衡量成功：达到目标字符串所需的生成次数很少。我们已经有了一种处理候选者以达到给定目标的方法——它被称为`methinks.rb`。
- en: Just as we can create a Proc that returns another Proc (as shown in [#24 Nesting
    lambdas](ch06s05.html "#24 Nesting lambdas") on page 111), we can create a mutator
    that operates at a higher level of mutation—mutating not just Strings, but the
    mutation of those Strings. We can define fitter as *requiring a lower number of
    generations to reach the target*, plug in some parameters, and go. Our new script,
    `methinks_meta.rb`, will (pseudo-)randomly vary arbitrary input parameters and
    filter them by this fitness criterion to find ever-better input parameters for
    us. Let’s see the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在 [第 24 节 嵌套 lambda](ch06s05.html "#24 Nesting lambdas") 中看到的那样（见第 111
    页），我们可以创建一个返回另一个 Proc 的 Proc，我们也可以创建一个在更高层次上操作的 mutator——不仅变异字符串，还变异这些字符串的变异。我们可以定义
    fitter 为 *需要更少的代数才能达到目标*，插入一些参数，然后开始。我们新的脚本 `methinks_meta.rb` 将（伪）随机改变任意输入参数，并通过这个适应性标准进行筛选，以找到更好的输入参数。让我们看看代码。
- en: The Code
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How It Works
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Since we’re performing operations that use `methinks.rb`, we `require` that
    file at ❶. We then immediately open the Hash class, adding a new method called
    `get_child` at ❷. The `get_child` method, which could also have been named mutate
    or reproduce, performs random variations on all of the values for the given Hash.
    It assumes that those values are Integers, and can thereby be varied with the
    `rand` method—in this case, from half the given value to 1.5 times the given value.
    Since the `:display_filter` value has no impact on fitness, we just forcibly set
    that to `5`. We accomplish the mutation through the construction of a `new_hash`
    by iterating over `self` with the `each_pair` method and making the necessary
    changes before writing to `new_hash`, which we then `return`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在执行使用 `methinks.rb` 的操作，我们在 ❶ 处 `require` 那个文件。然后我们立即打开 Hash 类，在 ❷ 处添加一个名为
    `get_child` 的新方法。这个 `get_child` 方法也可以命名为 mutate 或 reproduce，它对给定 Hash 的所有值进行随机变异。它假设这些值是整数，因此可以使用
    `rand` 方法进行变异——在这种情况下，从给定值的一半到给定值的 1.5 倍。由于 `:display_filter` 值对适应性没有影响，我们只需强制将其设置为
    `5`。我们通过迭代 `self` 并在写入 `new_hash` 之前进行必要的更改来构建 `new_hash`，然后返回 `new_hash` 来完成变异。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*We already noted how *`get_child`* makes the assumption that all of its Hash’s
    values are Integers. It also assumes that the Hash has a key called *`:display_filter`*.
    This assumption works fine for our script, but if the *`get_child`* method were
    to become part of a commonly-used library, we would have to make it play nicely
    with other programs. A programmer can avoid this method for inappropriate Hashes,
    but a better solution would be for the programmer to take responsibility for making
    new methods more robust when he or she opens an existing class and adds a new
    method. A production-ready version of *`get_child`* would check that the Hash’s
    values can implement numeric addition and also check for the presence of a *`:display_filter`*
    key before performing the operations laid out in our example*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们已经提到过*`get_child`*方法假设了其所有 Hash 的值都是整数。它还假设 Hash 中有一个名为 *`:display_filter`*
    的键。这个假设在我们的脚本中运行良好，但如果 *`get_child`* 方法要成为常用库的一部分，我们就必须让它与其他程序友好地协作。程序员可以避免对不合适的
    Hash 使用此方法，但更好的解决方案是，当程序员打开现有类并添加新方法时，负责使新方法更加健壮。一个生产就绪版本的 *`get_child`* 将会检查
    Hash 的值是否可以执行数值加法，并在执行我们示例中描述的操作之前检查是否存在 *`:display_filter`* 键*。'
- en: Next, we create our `Meta_Mutator` class at ❸. It has several Constants. The
    `NEW_TARGET` Constant defines a different target String. This was mainly for the
    convenience of having a shorter target, so that runs of the program would take
    a shorter time. The `MAX_ATTEMPTS` Constant defines the maximum number of attempts
    we should make to beat our previously fittest mutation attempt before giving up
    and trying a new set of parameters. `TARGET` is either our `NEW_TARGET` or the
    familiar `String::TARGET` from `methinks.rb`. This definition allows us to override
    the `TARGET` easily while still having a default value, and not having to constantly
    change code later when we want different targets—we just always use `TARGET`.
    The `Meta_Mutator` class also has the expected `initialize` method, which takes
    no arguments and defines an empty Hash for `@params_by_number_of_mutations`. We’ll
    see this instance variable in action later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在❸处创建我们的`Meta_Mutator`类。它有几个常量。`NEW_TARGET`常量定义了一个不同的目标字符串。这主要是为了方便拥有更短的目标字符串，从而使程序的运行时间更短。`MAX_ATTEMPTS`常量定义了我们应该在放弃并尝试新参数集之前尝试打败先前最适应的变异尝试的最大次数。`TARGET`可以是我们的`NEW_TARGET`，也可以是从`methinks.rb`中熟悉的`String::TARGET`。这种定义允许我们轻松覆盖`TARGET`，同时仍然有一个默认值，并且不需要在以后不断更改代码以实现不同的目标——我们只需始终使用`TARGET`。`Meta_Mutator`类还有一个预期的`initialize`方法，它不接受任何参数，并为`@params_by_number_of_mutations`定义一个空的哈希。我们将在稍后看到这个实例变量的实际应用。
- en: 'Next comes the public method `mutate_mutations!` at ❹. Note that it is destructive,
    and it takes two arguments: a required `params` Hash, and an optional Integer
    for the `did_no_better_count`, assumed to be zero, which makes sense for an initial
    run. It has a return guard, which allows it to exit early if the `did_no_better_count`
    is greater than the `MAX_ATTEMPTS` allowed. Assuming it should continue, it calls
    `update_params_by_number_of_mutations!` (defined at ❿), passes in the `params`
    argument, and places its returned value into the local `num` variable.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是位于❹处的公共方法`mutate_mutations!`。请注意，它具有破坏性，并接受两个参数：一个必需的`params`哈希，以及一个可选的整数`did_no_better_count`，默认值为零，这对于初始运行来说是有意义的。它有一个返回守卫，允许在`did_no_better_count`超过允许的`MAX_ATTEMPTS`时提前退出。假设它应该继续，它将调用`update_params_by_number_of_mutations!`（定义在❿），传入`params`参数，并将返回值放入局部变量`num`中。
- en: Let’s jump down to ❿ to see what `update_params_by_number_of_mutations!` does.
    It creates some children, using `get_children`, defined at ❽. Then `get_children`
    creates an Array to be returned by `map` ping the operation of calling `get_child`
    on the `params` Hash onto an Array with as many members as the requested `number_of_children`
    (assumed to be `10`). The `update_params_by_number_of_mutations!` method then
    loops through `each` of those `children`, calling each one `params`. It constructs
    a new `candidate` and determines the `number_of_mutations` needed to reach the
    `TARGET` by calling `mutate_until_matches!` (from `methinks.rb`) on that `candidate`.
    We now have our measure of fitness and the `params` used to achieve that level
    of fitness. We update `@params_by_number_of_mutations`, setting the value at the
    `number_of_mutations` key to be `params`, as the name `@params_by_number_of_mutations`
    suggests. It then returns the `number_of_mutations` required by this pass through
    `mutate_until_matches!`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到❿处，看看`update_params_by_number_of_mutations!`做了什么。它使用`get_children`（定义在❽）创建一些子代。然后`get_children`创建一个数组，通过`map`操作将调用`get_child`在`params`哈希上的操作映射到一个具有与请求的`number_of_children`（假设为`10`）成员数相同的数组。`update_params_by_number_of_mutations!`方法然后遍历这些`children`中的每一个，对每一个调用`params`。它构建一个新的`candidate`，并通过在`candidate`上调用`mutate_until_matches!`（来自`methinks.rb`）来确定达到`TARGET`所需的`number_of_mutations`。我们现在有了衡量适应度的指标和达到该适应度水平的`params`。我们更新`@params_by_number_of_mutations`，将`number_of_mutations`键的值设置为`params`，正如`@params_by_number_of_mutations`的名称所暗示的那样。然后它返回通过`mutate_until_matches!`这次遍历所需的`number_of_mutations`。
- en: Back in `mutate_mutations!` (❹), we recursively call `mutate_mutations!` again,
    this time with the “fittest” result in `@params_by_number_of_mutations` as the
    first argument and the result of calling `get_no_better_count(num, did_no_better_count)`
    as the second argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mutate_mutations!`（❹）中，我们递归地再次调用`mutate_mutations!`，这次将`@params_by_number_of_mutations`中的“最适应”结果作为第一个参数，将调用`get_no_better_count(num,
    did_no_better_count)`的结果作为第二个参数。
- en: The `best_num` method is defined at ❻, and it is straightforward. The keys of
    `@params_by_number_of_mutations` are the number of mutations needed to reach the
    target. Since they’re Integers, the lowest (and therefore “fittest”) value will
    be the first element of the resulting Array when we `sort` them. We can get that
    easily with `[0]`. The `get_no_better_count` method is defined at ❾; it takes
    the existing `num` and `did_no_better_count` as its only arguments. It returns
    `0` if this pass’ `num` is the `best_num`, resetting the `did_no_better_count`.
    Otherwise, it returns `did_no_better_count + 1`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`best_num` 方法在❻处定义，它很简单。`@params_by_number_of_mutations` 的键是需要达到目标所需的突变数。由于它们是整数，最低（因此是“最适应”）的值将是排序后的结果数组的第一个元素。我们可以通过
    `[0]` 轻松地得到它。`get_no_better_count` 方法在❾处定义；它只接受现有的 `num` 和 `did_no_better_count`
    作为其唯一参数。如果这次迭代的 `num` 是 `best_num`，则返回 `0` 并重置 `did_no_better_count`。否则，它返回 `did_no_better_count
    + 1`。'
- en: That’s it for `mutate_mutations!`. There’s one other public method, `report`,
    defined at ❺. It sorts through each pair within `@params_by_number_of_mutations`,
    outputting results via `puts, inspect`, String interpolation, and the `digits_needed`
    method, defined at ❼. It simply takes all the keys of `@params_by_number_of_mutations`,
    finds the `max`, and converts that highest Integer to a String with `to_s`. That
    String’s `size` method returns the number of characters, which is our desired
    number of `digits_needed` for display purposes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate_mutations!` 的内容到此为止。还有一个公开的方法 `report`，它在❺处定义。它遍历 `@params_by_number_of_mutations`
    中的每一对，通过 `puts, inspect`，字符串插值和定义在❷处的 `digits_needed` 方法输出结果。它简单地取 `@params_by_number_of_mutations`
    的所有键，找到最大值，并将该最高整数转换为字符串 `to_s`。该字符串的 `size` 方法返回字符数，这是我们用于显示的 `digits_needed`
    所需的字符数。'
- en: We can compute values as well as report them. We establish default `params`
    near the bottom of `methinks_meta.rb`, instantiate a `Meta_Mutator`, and call
    its `mutate_mutations!` and `report` methods. Let’s see the results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以计算值，还可以报告它们。我们在 `methinks_meta.rb` 的底部建立默认的 `params`，实例化一个 `Meta_Mutator`，并调用其
    `mutate_mutations!` 和 `report` 方法。让我们看看结果。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This script is not meant to demonstrate proper statistical analysis. Your
    results could be highly variable based on initial conditions. To accurately measure
    the improvement (or lack thereof) between variations, you should perform multiple
    runs of each version and verify that the differences you’re seeing are statistically
    significant. That’s beyond the scope of this book though. If this program inspires
    you to write programs that manipulate other programs, it’s done its job*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个脚本并不是为了展示正确的统计分析。你的结果可能会根据初始条件而高度变化。为了准确测量不同版本之间改进（或缺乏改进）的程度，你应该对每个版本进行多次运行，并验证你所看到的不同是否具有统计学意义。但这超出了本书的范围。如果这个程序激发你编写操纵其他程序的程序，那么它已经完成了它的任务*。'
- en: Running the Script
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行脚本
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Results
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our winner is `{:generation_size=>243, :mutation_rate=>25, :mutation_amp=>11,
    :display_filter=>5}`, with a match after only four generations. Again, the `:display_filter`
    doesn’t matter, it’s the other three parameters that really make a difference.
    You can rerun `methinks_meta.rb` as many times as you like, seeing if your winning
    values seem to hover around a given range of values for each important parameter.
    You can then reset the default `params` at the bottom of `methinks_meta.rb` and
    keep going as long as you want.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最佳结果是 `{:generation_size=>243, :mutation_rate=>25, :mutation_amp=>11, :display_filter=>5}`，在仅经过四代后就有匹配。再次强调，`:display_filter`
    并不重要，真正起作用的是其他三个参数。你可以多次运行 `methinks_meta.rb`，看看你的最佳值是否似乎围绕每个重要参数的给定值范围波动。然后你可以重置
    `methinks_meta.rb` 底部的默认 `params`，并继续进行，直到你想要停止。
- en: Hacking the Script
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操纵脚本
- en: 'If we want the results to always show the `params` keys in alphabetical order,
    we could override the built-in `inspect` method of all Hashes with the following
    code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望结果始终按字母顺序显示 `params` 键，我们可以用以下代码覆盖所有哈希的内置 `inspect` 方法：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Chapter Recap
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章摘要
- en: This chapter’s mandate was to use techniques you’ve already learned at some
    broader levels. However, there were still a few new concepts or approaches.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的任务是使用你在更广泛层面上已经学到的技术。然而，仍然有一些新的概念或方法。
- en: Equidistant Letter Sequences and larger-scale text searches
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等距字母序列和更大规模的文本搜索
- en: Extracting single characters from Strings
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中提取单个字符
- en: The `chr` method
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chr` 方法'
- en: Modeling natural selection with `methinks.rb`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `methinks.rb` 模拟自然选择
- en: Subclassing (`Children < Array`) and inheritance
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化（`Children < Array`）和继承
- en: Calculating differences between Strings
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算字符串之间的差异
- en: '`select_fittest` : `inject` versus `sort_by`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select_fittest` : `inject`与`sort_by`的比较'
- en: Genuine random versus pseudo-random
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实随机与伪随机
- en: Meta-mutation with `methinks_meta.rb`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`methinks_meta.rb`进行元变异
- en: Alphabetizing `inspect` through overriding
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重写`inspect`进行字母排序
- en: Our next chapter is the second of two chapters that consider more complex programs.
    While this chapter mainly expanded upon concepts we’ve already learned, the next
    one uses an exciting new type of abstraction, known as a *callback*. Let’s get
    to it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的章节是两章中较为复杂程序的第二章。虽然这一章主要扩展了我们已经学过的概念，但下一章将使用一种令人兴奋的新类型抽象，称为*回调*。让我们开始吧。
