- en: Chapter 6. Solving Problems with Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 使用递归解决问题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: This chapter is about *recursion*, which is when a function directly or indirectly
    calls itself. Recursive programming looks as if it should be simple. Indeed, a
    good recursive solution often has a simple, almost elegant appearance. However,
    very often the route to that solution is anything but simple. This is because
    recursion requires us to think differently than we do with other types of programming.
    When we process data using loops, we’re thinking about processing in a sequential
    manner, but when we process data using recursion, our normal sequential thinking
    process won’t help. Many good, fledgling programmers struggle with recursion because
    they can’t see a way to apply the problem-solving skills they’ve learned to recursive
    problems. In this chapter, we’ll discuss how to attack recursive problems systematically.
    The answer is using what we will call the *Big Recursive Idea*, henceforth referred
    to as the BRI. It’s an idea that’s so straightforward it will seem like a trick,
    but it works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于*递归*的，即函数直接或间接调用自身。递归编程看起来应该很简单。确实，一个好的递归解决方案通常看起来简单、几乎优雅。然而，通往那个解决方案的道路往往并不简单。这是因为递归要求我们以不同于其他类型编程的方式思考。当我们使用循环处理数据时，我们是在考虑按顺序处理，但当我们使用递归处理数据时，我们的正常顺序思维过程不会有所帮助。许多初出茅庐的程序员在递归上挣扎，因为他们看不到将他们学到的解决问题的技能应用到递归问题上的方法。在本章中，我们将讨论如何系统地攻击递归问题。答案是使用我们将称之为*大递归思想*的概念，简称BRI。这是一个如此直截了当的想法，以至于它看起来像是一个技巧，但它确实有效。
- en: Review of Recursion Fundamentals
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归基础回顾
- en: 'There is not much to know about the *syntax* of recursion; the difficulty arises
    when you try to use recursion to solve problems. Recursion occurs any time a function
    calls itself, so the syntax of recursion is just the syntax of a function call.
    The most common form is *direct recursion*, when a call to a function occurs in
    the body of that same function. For example:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于递归的*语法*没有太多要了解的；困难在于你试图使用递归解决问题。递归发生在函数调用自身的时候，所以递归的语法只是函数调用的语法。最常见的形式是*直接递归*，即函数调用发生在同一函数体中。例如：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function, which is a common but highly inefficient demonstration of recursion,
    computes the factorial of *n*. For example, if *n* is 5, then the factorial is
    the product of all the numbers from 5 to 1, or 120\. Note that in some cases no
    recursion occurs. In this function, if the parameter is 1, we simply return a
    value directly without any recursion ![](httpatomoreillycomsourcenostarchimages1273182.png),
    which is known as a *base case*. Otherwise, we make the recursive call ![](httpatomoreillycomsourcenostarchimages1273191.png).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，它是一个常见但效率非常低的递归示例，计算*n*的阶乘。例如，如果*n*是5，那么阶乘就是从5到1的所有数字的乘积，即120。注意，在某些情况下不会发生递归。在这个函数中，如果参数是1，我们直接返回一个值，而不进行任何递归![图片](httpatomoreillycomsourcenostarchimages1273182.png)，这被称为*基准情况*。否则，我们进行递归调用![图片](httpatomoreillycomsourcenostarchimages1273191.png)。
- en: The other form of recursion is *indirect recursion*—for example, if function
    A calls function B, which later calls function A. Indirect recursion is rarely
    used as a problem-solving technique, so we won’t cover it here.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的另一种形式是*间接递归*——例如，如果函数A调用函数B，而函数B后来又调用函数A。间接递归很少用作解决问题的技术，所以我们在这里不会涉及它。
- en: Head and Tail Recursion
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头递归和尾递归
- en: Before we discuss the BRI, we need to understand the difference between head
    recursion and tail recursion. In *head recursion*, the recursive call, when it
    happens, comes before other processing in the function (think of it happening
    at the top, or head, of the function). In *tail recursion*, it’s the opposite—the
    processing occurs before the recursive call. Choosing between the two recursive
    styles may seem arbitrary, but the choice can make all the difference. To illustrate
    this difference, let’s look at two problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论BRI之前，我们需要理解头递归和尾递归之间的区别。在*头递归*中，递归调用，当它发生时，在函数中的其他处理之前（想想它在函数的顶部或头部发生）。在*尾递归*中，情况相反——处理发生在递归调用之前。在两种递归风格之间进行选择可能看起来是随意的，但选择可以产生很大的差异。为了说明这种差异，让我们看看两个问题。
- en: 'Problem: How Many Parrots?'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：有多少只鹦鹉？
- en: Passengers on the Tropical Paradise Railway (TPR) look forward to seeing dozens
    of colorful parrots from the train windows. Because of this, the railway takes
    a keen interest in the health of the local parrot population and decides to take
    a tally of the number of parrots in view of each train platform along the main
    line. Each platform is staffed by a TPR employee (see [Figure 6-1](ch06.html#the_employees_at_the_five_stations_can_c
    "Figure 6-1. The employees at the five stations can communicate only with their
    immediate neighbors.")), who is certainly capable of counting parrots. Unfortunately,
    the job is complicated by the primitive telephone system. Each platform can call
    only its immediate neighbors. How do we get the parrot total at the main line
    terminal?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 热带天堂铁路（TPR）的乘客期待着从火车窗户看到成打的五彩鹦鹉。因此，铁路对当地鹦鹉群体的健康表现出浓厚的兴趣，并决定对主线路沿线每个站台可见的鹦鹉数量进行统计。每个站台都配备了一名TPR员工（见图[图6-1](ch06.html#the_employees_at_the_five_stations_can_c
    "图6-1. 五个站点的员工只能与他们的直接邻居通信。")), 他们当然能够数鹦鹉。不幸的是，这项工作被原始的电话系统复杂化了。每个站台只能与其直接邻居通话。我们如何得到主线路终端的鹦鹉总数？
- en: '![The employees at the five stations can communicate only with their immediate
    neighbors.](httpatomoreillycomsourcenostarchimages1273251.png.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![五个站点的员工只能与他们的直接邻居通信。](httpatomoreillycomsourcenostarchimages1273251.png.jpg)'
- en: Figure 6-1. The employees at the five stations can communicate only with their
    immediate neighbors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1. 五个站点的员工只能与他们的直接邻居通信。
- en: Let’s suppose that there are 7 parrots by Art at the main terminal, 5 parrots
    by Belinda, 3 parrots by Cory, 10 parrots by Debbie, and 2 parrots by Evan at
    the last station. The total number of parrots is thus 27\. The question is, how
    are the employees going to work together to communicate this total to Art? Any
    solution to this problem is going to require a chain of communications all the
    way from the main terminal to the end of the line and back. The staff member at
    each platform will be requested to count parrots and will then report his or her
    observations. Even so, there are two distinct approaches to this communications
    chain, and those approaches correspond to the head recursion and tail recursion
    techniques in programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设艺术在主终端有7只鹦鹉，贝琳达有5只，科尔里有3只，黛比有10只，而在最后一个站点，伊万有2只鹦鹉。因此，鹦鹉的总数是27只。问题是，员工们将如何一起向艺术传达这个总数？解决这个问题的任何方案都将需要从主终端到线路末端的通信链，然后再返回。每个站台的员工将被要求数鹦鹉，然后报告他们的观察结果。即便如此，这里有两种不同的通信链方法，这些方法对应于编程中的头递归和尾递归技术。
- en: Approach 1
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法1
- en: In this approach, we keep a running total of the parrots as we progress through
    the outbound communications. Each employee, when making the request of the next
    employee down the line, passes along the number of parrots seen so far. When we
    get to the end of the line, Evan will be the first to discover the parrot total,
    which he will pass up to Debbie, who will pass it to Cory, and so on (as shown
    in [Figure 6-2](ch06.html#numbering_of_steps_taken_in_approach_1_f "Figure 6-2. Numbering
    of steps taken in Approach 1 for the parrot-counting problem")).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们在进行外发通信的过程中保持鹦鹉的累计总数。每个员工在向线路下方的下一个员工提出请求时，都会传递到目前为止看到的鹦鹉数量。当我们到达线路的末端时，伊万将是第一个发现鹦鹉总数的人，他将把这个总数传递给黛比，黛比再传递给科尔里，依此类推（如图[图6-2](ch06.html#numbering_of_steps_taken_in_approach_1_f
    "图6-2. 在方法1中解决鹦鹉计数问题所采取的步骤编号")所示）。
- en: '![Numbering of steps taken in Approach 1 for the parrot-counting problem](httpatomoreillycomsourcenostarchimages1273253.png.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![方法1中解决鹦鹉计数问题所采取的步骤编号](httpatomoreillycomsourcenostarchimages1273253.png.jpg)'
- en: Figure 6-2. Numbering of steps taken in Approach 1 for the parrot-counting problem
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2. 在方法1中解决鹦鹉计数问题所采取的步骤编号
- en: ART begins by counting the parrots around his platform. He counts 7 parrots.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 艺术首先开始数他平台周围的鹦鹉。他数了7只鹦鹉。
- en: 'ART to BELINDA: “There are 7 parrots here at the main terminal.”'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 艺术对贝琳达说：“主终端这里有7只鹦鹉。”
- en: BELINDA counts 5 parrots around her platform for a running total of 12.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贝琳达在她平台周围数了5只鹦鹉，累计总数为12。
- en: 'BELINDA to CORY: “There are 12 parrots around the first two stations.”'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 贝琳达对科尔里：“前两个站点周围有12只鹦鹉。”
- en: CORY counts 3 parrots.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 科尔里数了3只鹦鹉。
- en: 'CORY to DEBBIE: “There are 15 parrots around the first three stations.”'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 科尔里对黛比说：“前三个站点周围有15只鹦鹉。”
- en: DEBBIE counts 10 parrots.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 黛比数了10只鹦鹉。
- en: 'DEBBIE to EVAN: “There are 25 parrots around the first four stations.”'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBBIE 对 EVAN 说：“前四个站点周围有 25 只鹦鹉。”
- en: EVAN counts 2 parrots and discovers that the total number of parrots is 27.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EVAN 数了 2 只鹦鹉，发现鹦鹉的总数是 27。
- en: 'EVAN to DEBBIE: “The total number of parrots is 27.”'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EVAN 对 DEBBIE 说：“鹦鹉的总数是 27。”
- en: 'DEBBIE to CORY: “The total number of parrots is 27.”'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBBIE 对 CORY 说：“鹦鹉的总数是 27。”
- en: 'CORY to BELINDA: “The total number of parrots is 27.”'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORY 对 BELINDA 说：“鹦鹉的总数是 27。”
- en: 'BELINDA to ART: “The total number of parrots is 27.”'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BELINDA 对 ART 说：“鹦鹉的总数是 27。”
- en: 'This approach is analogous to tail recursion. In tail recursion, the recursive
    call happens after the processing—the recursive call is the last step in the function.
    In the communications chain above, note that the “work” of the employees—the parrot
    counting and summation—happens before they signal the next employee down the line.
    All of the work happens on the outbound communications chain, not the inbound
    chain. Here are the steps each employee follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于尾递归。在尾递归中，递归调用发生在处理之后——递归调用是函数中的最后一步。在上面的通信链中，请注意，员工的“工作”——鹦鹉计数和求和——发生在他们向下一站发出信号之前。所有的工作都发生在出站通信链上，而不是入站链上。以下是每位员工遵循的步骤：
- en: Count the parrots visible from the station platform.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从站台平台上数可见的鹦鹉。
- en: Add this count to the total given by the previous station.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个数量加到上一站给出的总数上。
- en: Call the next station to pass along the running sum of parrot counts.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打电话给下一站，传递鹦鹉数量的累计总和。
- en: Wait for the next station to call with the total parrot count, and then pass
    this total up to the previous station.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待下一站打电话报告总鹦鹉数量，然后将这个总数传递给上一站。
- en: Approach 2
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 2
- en: In this approach, we sum the parrot counts from the other end. Each employee,
    when contacting the next station down the line, requests the total number of parrots
    from that station onward. The employee then adds the number of parrots at his
    or her own station and passes this new total up the line (as shown in [Figure 6-3](ch06.html#numbering_of_steps_taken_in_approach_2_f
    "Figure 6-3. Numbering of steps taken in Approach 2 for the parrot-counting problem")).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们从另一端累加鹦鹉的数量。每位员工在联系下一站时，都会请求从该站开始的总鹦鹉数量。员工然后将自己站点的鹦鹉数量加上，并将这个新的总数向上传递（如图
    [Figure 6-3](ch06.html#numbering_of_steps_taken_in_approach_2_f "Figure 6-3. Numbering
    of steps taken in Approach 2 for the parrot-counting problem") 所示）。
- en: '![Numbering of steps taken in Approach 2 for the parrot-counting problem](httpatomoreillycomsourcenostarchimages1273255.png.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![从方法 2 的步骤数起，用于鹦鹉计数问题](httpatomoreillycomsourcenostarchimages1273255.png.jpg)'
- en: Figure 6-3. Numbering of steps taken in Approach 2 for the parrot-counting problem
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 [Figure 6-3](ch06.html#numbering_of_steps_taken_in_approach_2_f "Figure 6-3. Numbering
    of steps taken in Approach 2 for the parrot-counting problem")
- en: 'ART to BELINDA: “What’s the total number of parrots from your station to the
    end of the line?”'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ART 对 BELINDA 说：“从你的站点到线尾的总鹦鹉数量是多少？”
- en: 'BELINDA to CORY: “What’s the total number of parrots from your station to the
    end of the line?”'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BELINDA 对 CORY 说：“从你的站点到线尾的总鹦鹉数量是多少？”
- en: 'CORY to DEBBIE: “What’s the total number of parrots from your station to the
    end of the line?”'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORY 对 DEBBIE 说：“从你的站点到线尾的总鹦鹉数量是多少？”
- en: 'DEBBIE to EVAN: “What’s the total number of parrots from your station to the
    end of the line?”'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBBIE 对 EVAN 说：“从你的站点到线尾的总鹦鹉数量是多少？”
- en: EVAN is the end of the line. He counts 2 parrots.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EVAN 是线尾。他数了 2 只鹦鹉。
- en: 'EVAN to DEBBIE: “The total number of parrots here at the end is 2.”'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: EVAN 对 DEBBIE 说：“这里末尾的总鹦鹉数量是 2。”
- en: DEBBIE counts 10 parrots at her station, so the total from her station to the
    end is 12.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBBIE 在她的站点数了 10 只鹦鹉，因此从她的站点到末尾的总数是 12。
- en: 'DEBBIE to CORY: “The total number of parrots from here to the end is 12.”'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DEBBIE 对 CORY 说：“从这里到末尾的总鹦鹉数量是 12。”
- en: CORY counts 3 parrots.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORY 数了 3 只鹦鹉。
- en: 'CORY to BELINDA: “The total number of parrots from here to the end is 15.”'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CORY 对 BELINDA 说：“从这里到末尾的总鹦鹉数量是 15。”
- en: BELINDA counts 5 parrots.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BELINDA 数了 5 只鹦鹉。
- en: 'BELINDA to ART: “The total number of parrots from here to the end is 20.”'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BELINDA 对 ART 说：“从这里到末尾的总鹦鹉数量是 20。”
- en: ART counts 7 parrots at the main terminal, making a total of 27.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ART 在主终端数了 7 只鹦鹉，总数达到 27。
- en: 'This approach is analogous to head recursion. In head recursion, the recursive
    call happens before the other processing. Here, the call to the next station happens
    first, before counting the parrots or the summation. The “work” is postponed until
    after the stations down the line have reported their totals. Here are the steps
    each employee follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于头递归。在头递归中，递归调用发生在其他处理之前。在这里，调用下一个车站发生在计数鹦鹉或求和之前。工作被推迟到下游车站报告它们的总数之后。以下是每个员工遵循的步骤：
- en: Call the next station.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 呼叫下一个车站。
- en: Count the parrots visible from the station platform.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算从车站平台可见的鹦鹉数量。
- en: Add this count to the total given by the next station.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个计数添加到下一个车站给出的总数中。
- en: Pass the resulting sum up to the previous station.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将得到的总和传递给上一个车站。
- en: You may have noticed two practical effects of the different approaches. In the
    first approach, eventually all of the station employees will learn the overall
    parrot total. In the second approach, only Art, at the main terminal, learns the
    full total—but note that Art is the only employee who needs the full total.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了不同方法产生的两个实际效果。在第一种方法中，最终所有车站员工都将学会整体鹦鹉总数。在第二种方法中，只有主终端的Art学会了完整总数——但请注意，Art是唯一需要完整总数的员工。
- en: The other practical effect will become more important for our analysis when
    we transition the discussion to actual programming code. In the first approach,
    each employee passes along the “running total” to the next station down the line
    when making the request. In the second approach, the employee simply makes the
    request for information from the next station, without passing any data down the
    line. This effect is typical of the head recursion approach. Because the recursive
    call happens first, before any other processing, there is no new information to
    give the recursive call. In general, the head recursion approach allows the minimum
    set of data to be passed to the recursive call. Now let’s look at another problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将讨论过渡到实际的编程代码时，另一个实际效果将对我们分析变得更加重要。在第一种方法中，每个员工在提出请求时将“累计总数”传递给下一个车站。在第二种方法中，员工只是从下一个车站请求信息，而不在沿线传递任何数据。这种效果是头递归方法的典型特征。因为递归调用首先发生，在所有其他处理之前，没有新的信息可以提供给递归调用。一般来说，头递归方法允许将最小数据集传递给递归调用。现在让我们看看另一个问题。
- en: 'Problem: Who’s Our Best Customer?'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：谁是我们的最佳客户？
- en: 'The manager of DelegateCorp needs to determine which of eight customers produces
    the most revenue for his company. Two factors complicate this otherwise simple
    task. First, determining the total revenue for a customer requires going through
    that customer’s whole file and tallying numbers on dozens of orders and receipts.
    Second, the employees of DelegateCorp, as the name suggests, love to delegate,
    and each employee passes work along to someone at a lower level whenever possible.
    To keep the situation from getting out of hand, the manager enforces a rule: When
    you delegate, you must do some portion of the work yourself, and you have to give
    the delegated employee less work than you were given.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DelegateCorp 的经理需要确定八位客户中哪位为公司创造了最多的收入。两个因素使这个本应简单的工作变得复杂。首先，确定客户的总收入需要查看该客户的整个档案，并统计数十个订单和收据上的数字。其次，正如其名称所暗示的，DelegateCorp
    的员工喜欢委派工作，并且每当可能时，每个员工都会将工作传递给更低级别的员工。为了防止情况失控，经理实施了一项规则：当你委派工作时，你必须自己完成部分工作，并且你必须给委派给员工的任务少于你原本得到的。
- en: '[Table 6-1](ch06.html#delegatecorp_employee_titles_and_rank "Table 6-1. DelegateCorp
    Employee Titles and Rank") and [Table 6-2](ch06.html#delegatecorp_customers "Table 6-2. DelegateCorp
    Customers") identify the employees and customers of DelegateCorp.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6-1](ch06.html#delegatecorp_employee_titles_and_rank "表6-1. DelegateCorp
    员工职位和职级") 和 [表6-2](ch06.html#delegatecorp_customers "表6-2. DelegateCorp 客户") 识别了DelegateCorp
    的员工和客户。'
- en: Table 6-1. DelegateCorp Employee Titles and Rank
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1. DelegateCorp 员工职位和职级
- en: '| Title | Rank |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 职位 | 职级 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Manager | 1 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 经理 | 1 |'
- en: '| Vice manager | 2 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 副经理 | 2 |'
- en: '| Associate manager | 3 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 副经理 | 3 |'
- en: '| Assistant manager | 4 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 助理经理 | 4 |'
- en: '| Junior manager | 5 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 初级经理 | 5 |'
- en: '| Intern | 6 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 实习生 | 6 |'
- en: Table 6-2. DelegateCorp Customers
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-2. DelegateCorp 客户
- en: '| Customer Number | Revenue |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 客户编号 | 收入 |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| #0001 | $172,000 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| #0001 | $172,000 |'
- en: '| #0002 | $68,000 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| #0002 | $68,000 |'
- en: '| #0003 | $193,000 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| #0003 | $193,000 |'
- en: '| #0004 | $13,000 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| #0004 | $13,000 |'
- en: '| #0005 | $256,000 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| #0005 | $256,000 |'
- en: '| #0006 | $99,000 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| #0006 | $99,000 |'
- en: Following the company rule on delegating work, here’s what will happen to the
    six customer files. The manager will take one file and determine how much revenue
    that customer has generated for the company. The manager will delegate the other
    five files to the vice manager. The vice manager will process one file and pass
    the other four to the associate manager. This process continues until we reach
    the sixth employee, the intern, who is handed one file and must simply process
    it, with no further delegation possible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据公司关于委派工作的规定，以下是六个客户文件将发生的情况。经理将取一个文件，并确定该客户为公司创造了多少收入。经理将把其他五个文件委派给副经理。副经理将处理一个文件，并将其他四个文件转交给助理经理。这个过程一直持续到第六个员工，实习生，他将获得一个文件，并必须简单地处理它，没有进一步的委派可能。
- en: '[Figure 6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope "Figure 6-4. The
    numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the highest-revenue
    customer") describes the lines of communication and the division of labor. As
    with the previous example, though, there are two distinct approaches to the communications
    chain.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope "图6-4. 寻找最高收入客户的方法1（a）和方法2（b）中的步骤编号")描述了沟通线路和劳动分工。然而，与前面的例子一样，存在两种不同的沟通链方法。'
- en: '![The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding the
    highest-revenue customer](httpatomoreillycomsourcenostarchimages1273257.png.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![寻找最高收入客户的方法1（a）和方法2（b）中的步骤编号](httpatomoreillycomsourcenostarchimages1273257.png.jpg)'
- en: Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for
    finding the highest-revenue customer
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4. 寻找最高收入客户的方法1（a）和方法2（b）中的步骤编号
- en: Approach 1
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法1
- en: In this approach, when delegating the remaining files, the employee also passes
    along the highest amount of revenue seen so far. This means that the employee
    must tally the revenue in one file and compare this to the previous highest amount
    seen before delegating the remaining files to another employee. Here’s an example
    of how this would proceed in practice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，在委派剩余文件时，员工也会传递迄今为止看到的最高的收入金额。这意味着员工必须统计一个文件的收入，并将其与之前看到的最高的金额进行比较，然后再将剩余的文件委派给另一个员工。以下是如何在实际中进行的例子。
- en: 'MANAGER tallies the revenue for customer #0001, which is $172,000.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经理**统计了客户#0001的收入，为172,000美元。'
- en: 'MANAGER to VICE MANAGER: “The highest revenue we have seen so far is $172,000,
    customer #0001\. Take these five files and determine the overall highest revenue.”'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经理**对**副经理**说：“迄今为止我们看到的最高的收入是172,000美元，客户#0001。请取这五个文件并确定整体最高的收入。”'
- en: 'VICE MANAGER tallies the revenue for customer #0002, which is $68,000\. The
    highest revenue seen so far is still $172,000, customer #0001.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**副经理**统计了客户#0002的收入，为68,000美元。迄今为止看到的最高的收入仍然是172,000美元，客户#0001。'
- en: 'VICE MANAGER to ASSOCIATE MANAGER: “The highest revenue we have seen so far
    is $172,000, customer #0001\. Take these four files and determine the overall
    highest revenue.”'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**副经理**对**助理经理**说：“迄今为止我们看到的最高的收入是172,000美元，客户#0001。请取这四个文件并确定整体最高的收入。”'
- en: 'ASSOCIATE MANAGER tallies the revenue for customer #0003, which is $193,000\.
    The highest revenue seen so far is now $193,000, customer #0003.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**统计了客户#0003的收入，为193,000美元。迄今为止看到的最高的收入现在是193,000美元，客户#0003。'
- en: 'ASSOCIATE MANAGER to ASSISTANT MANAGER: “The highest revenue we have seen so
    far is $193,000, customer #0003\. Take these three files and determine the overall
    highest revenue.”'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**对**助理经理**说：“迄今为止我们看到的最高的收入是193,000美元，客户#0003。请取这三个文件并确定整体最高的收入。”'
- en: 'ASSISTANT MANAGER tallies the revenue for customer #0004, which is $13,000\.
    The highest revenue seen so far is still $193,000, customer #0003.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**统计了客户#0004的收入，为13,000美元。迄今为止看到的最高的收入仍然是193,000美元，客户#0003。'
- en: 'ASSISTANT MANAGER to JUNIOR MANAGER: “The highest revenue we have seen so far
    is $193,000, customer #0003\. Take these two files and determine the overall highest
    revenue.”'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**对**初级经理**说：“迄今为止我们看到的最高的收入是193,000美元，客户#0003。请取这两个文件并确定整体最高的收入。”'
- en: 'JUNIOR MANAGER tallies the revenue for customer #0005, which is $256,000\.
    The highest revenue seen so far is now $256,000, customer #0005.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初级经理**统计了客户#0005的收入，为256,000美元。迄今为止看到的最高的收入现在是256,000美元，客户#0005。'
- en: 'JUNIOR MANAGER to INTERN: “The highest revenue we have seen so far is $256,000,
    customer #0005\. Take this remaining file and determine the overall highest revenue.”'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初级经理**对**实习生**说：“迄今为止我们看到的最高的收入是256,000美元，客户#0005。请取这个剩余的文件并确定整体最高的收入。”'
- en: 'INTERN tallies the revenue for customer #0006, which is $99,000\. The highest
    revenue seen so far is still $256,000, customer #0005.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实习生计算客户编号#0006的收入，为$99,000。迄今为止看到的最高收入仍然是$256,000，客户编号#0005。
- en: 'INTERN to JUNIOR MANAGER: “The highest revenue of all customers is $256,000,
    customer #0005.”'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实习生对初级经理说：“所有客户的最高收入是$256,000，客户编号#0005。”
- en: 'JUNIOR MANAGER to ASSISTANT MANAGER: “The highest revenue of all customers
    is $256,000, customer #0005.”'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初级经理对助理经理说：“所有客户的最高收入是$256,000，客户编号#0005。”
- en: 'ASSISTANT MANAGER to ASSOCIATE MANAGER: “The highest revenue of all customers
    is $256,000, customer #0005.”'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 助理经理对助理经理说：“所有客户的最高收入是$256,000，客户编号#0005。”
- en: 'ASSOCIATE MANAGER to VICE MANAGER: “The highest revenue of all customers is
    $256,000, customer #0005.”'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 助理经理对副经理说：“所有客户的最高收入是$256,000，客户编号#0005。”
- en: 'VICE MANAGER to MANAGER: “The highest revenue of all customers is $256,000,
    customer #0005.”'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 副经理对经理说：“所有客户的最高收入是$256,000，客户编号#0005。”
- en: 'This approach, shown in [Figure 6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope
    "Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding
    the highest-revenue customer") (a), uses the tail recursion technique. Each employee
    processes one customer file and compares the computed revenue for that customer
    against the highest revenue seen so far. Then the employee passes the result of
    that comparison to the subordinate employee. The recursion—the passing off of
    work—happens after the other processing. Each employee’s process runs like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，如图[图6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope "图6-4. 方法1（a）和方法2（b）中寻找最高收入客户步骤的编号")（a）所示，使用了尾递归技术。每位员工处理一份客户文件，并将该客户的计算收入与迄今为止看到的最高收入进行比较。然后员工将比较结果转交给下属员工。递归——工作的转交——在其他处理之后发生。每位员工的过程如下：
- en: Tally the revenue in one customer file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一份客户文件中的收入。
- en: Compare this total with the highest revenue seen by superiors in other customer
    files.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个总额与上级在其他客户文件中看到的最高收入进行比较。
- en: Pass the remaining customer files to a subordinate employee, along with the
    highest revenue amount seen so far.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的客户文件及其迄今为止看到的最高收入金额转交给下属员工。
- en: When the subordinate employee returns the highest revenue of all the customer
    files, pass this back to the superior.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当下属员工返回所有客户文件中的最高收入时，将其转交给上级。
- en: Approach 2
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法2
- en: 'In this approach, each employee begins by setting aside one file and then passing
    the others to the subordinate. In this case, the subordinate isn’t asked to determine
    the highest revenue of all the files, just of the files the subordinate has been
    given. As with the first sample problem, this simplifies the requests. Using the
    same data as the first approach, the conversation would be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，每位员工首先留下一份文件，然后将其他文件转交给下属。在这种情况下，下属不需要确定所有文件的最高收入，只需确定他们所拥有的文件的最高收入。与第一个示例问题一样，这简化了请求。使用与第一种方法相同的数据，对话将如下所示：
- en: 'MANAGER to VICE MANAGER: “Take these five customer files, and tell me the highest
    revenue.”'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经理对副经理说：“拿这五份客户文件，告诉我最高收入。”
- en: 'VICE MANAGER to ASSOCIATE MANAGER: “Take these four customer files, and tell
    me the highest revenue.”'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 副经理对助理经理说：“拿这四份客户文件，告诉我最高收入。”
- en: 'ASSOCIATE MANAGER to ASSISTANT MANAGER: “Take these three customer files, and
    tell me the highest revenue.”'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 助理经理对助理经理说：“拿这三份客户文件，告诉我最高收入。”
- en: 'ASSISTANT MANAGER to JUNIOR MANAGER: “Take these two customer files, and tell
    me the highest revenue.”'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 助理经理对初级经理说：“拿这两份客户文件，告诉我最高收入。”
- en: 'JUNIOR MANAGER to INTERN: “Take this one customer file, and tell me the highest
    revenue.”'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初级经理对实习生说：“拿这份客户文件，告诉我最高收入。”
- en: 'INTERN tallies the revenue for customer #0006, which is $99,000\. This is the
    only file the INTERN has seen, so that’s the highest revenue.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实习生计算客户编号#0006的收入，为$99,000。这是实习生看到的唯一文件，因此这是最高收入。
- en: 'INTERN to JUNIOR MANAGER: “The highest revenue in my files is $99,000, customer
    #0006.”'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实习生对初级经理说：“我文件中的最高收入是$99,000，客户编号#0006。”
- en: 'JUNIOR MANAGER tallies the revenue for customer #0005, which is $256,000\.
    The highest revenue this employee knows about is $256,000, customer #0005.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初级经理计算客户编号#0005的收入，为$256,000。这位员工知道的最高收入是$256,000，客户编号#0005。
- en: 'JUNIOR MANAGER to ASSISTANT MANAGER: “The highest revenue in my files is $256,000,
    customer #0005.”'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从初级经理晋升为助理经理：“我文件中的最高收入是$256,000，客户编号#0005。”
- en: 'ASSISTANT MANAGER tallies the revenue for customer #0004, which is $13,000\.
    The highest revenue this employee knows about is $256,000, customer #0005.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**统计客户#0004的收入，为$13,000。这位员工知道的最高收入是$256,000，客户编号#0005。'
- en: 'ASSISTANT MANAGER to ASSOCIATE MANAGER: “The highest revenue in my files is
    $256,000, customer #0005.”'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**到**副经理**：“我文件中的最高收入是$256,000，客户编号#0005。”'
- en: 'ASSOCIATE MANAGER tallies the revenue for customer #0003, which is $193,000\.
    The highest revenue this employee knows about is $256,000, customer #0005.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**统计客户#0003的收入，为$193,000。这位员工知道的最高收入是$256,000，客户编号#0005。'
- en: 'ASSOCIATE MANAGER to VICE MANAGER: “The highest revenue in my files is $256,000,
    customer #0005.”'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**助理经理**到**副经理**：“我文件中的最高收入是$256,000，客户编号#0005。”'
- en: 'VICE MANAGER tallies the revenue for customer #0002, which is $68,000\. The
    highest revenue this employee knows about is $256,000, customer #0005.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**副经理**统计客户#0002的收入，为$68,000。这位员工知道的最高收入是$256,000，客户编号#0005。'
- en: 'VICE MANAGER to MANAGER: “The highest revenue in my files is $256,000, customer
    #0005.”'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**副经理**到**经理**：“我文件中的最高收入是$256,000，客户编号#0005。”'
- en: 'MANAGER tallies the revenue for customer #0001, which is $172,000\. The highest
    revenue this employee knows about is $256,000, customer #0005.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**经理**统计客户#0001的收入，为$172,000。这位员工知道的最高收入是$256,000，客户编号#0005。'
- en: 'This approach, shown in [Figure 6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope
    "Figure 6-4. The numbering of steps in Approach 1 (a) and Approach 2 (b) for finding
    the highest-revenue customer") (b), uses the head recursion technique. Each employee
    still has to tally the revenue in one customer file, but that action is postponed
    until after the subordinate employee determines the highest revenue among the
    remaining files. The process each employee takes is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，如图[图6-4](ch06.html#the_numbering_of_steps_in_approach_1_ope "图6-4. 方法1（a）和方法2（b）中寻找最高收入客户的步骤编号")（b）所示，使用了头递归技术。每个员工仍然需要统计一个客户文件的收入，但这个动作是在下属员工确定剩余文件中的最高收入之后才进行的。每个员工采取的过程如下：
- en: Pass all customer files except one to a subordinate employee.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有客户文件（除了一个）传递给下属员工。
- en: Get the highest revenue of those files back from the subordinate employee.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下属员工那里获取那些文件中的最高收入。
- en: Tally the revenue in the one customer file.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个客户文件中统计收入。
- en: Pass the larger of those two revenues to the superior.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个收入中较大的一个传递给上级。
- en: As in the “counting parrots” problem, the head recursion technique allows each
    employee to pass the minimum amount of information to the subordinate.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与“数鹦鹉”问题一样，头递归技术允许每个员工向下属传递最小量的信息。
- en: The Big Recursive Idea
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**大递归思想**'
- en: We now arrive at the Big Recursive Idea. In fact, if you’ve read through the
    steps of the sample problems, you have already seen the BRI in action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了**大递归思想**。实际上，如果你已经阅读了示例问题的步骤，你已经在行动中看到了BRI（大递归思想）。
- en: How so? Both of the sample problems follow the form of a recursive solution.
    Each person in the communications chain performs the same steps on a smaller and
    smaller subset of the original data. It’s important to note, however, that *the
    problems involve no recursion at all*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么做到的？这两个示例问题都遵循递归解决方案的形式。通讯链中的每个人都在越来越小的原始数据子集上执行相同的步骤。然而，需要注意的是，*这些问题根本不涉及递归*。
- en: In the first problem, each railway employee makes a request of the next station
    down the line, and in fulfilling that request, the next employee follows the same
    steps as the previous employee. But nothing in the wording of the request requires
    an employee to follow those particular steps. When Art called Belinda using Approach
    2, for example, he asked her to count the total number of parrots from her station
    to the end of the line. He did not dictate a method for discovering this total.
    If he thought about it, he might have realized that Belinda would have to follow
    the same steps that he himself was following, but he doesn’t have to consider
    this. To complete his task, all Art required was for Belinda to provide the correct
    answer to the question he asked.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个问题中，每个铁路员工都会向线路下方的下一个车站提出请求，并在满足该请求时，下一个员工会遵循与上一个员工相同的步骤。但是，请求的文字中没有任何内容要求员工遵循这些特定的步骤。例如，当Art使用方法2给Belinda打电话时，他要求她从她的车站数到线路末端的鹦鹉总数。他没有规定发现这个总数的方法。如果他考虑过这个问题，他可能会意识到Belinda必须遵循与他本人相同的步骤，但他不必考虑这一点。为了完成他的任务，Art需要的只是Belinda提供他问问题的正确答案。
- en: Likewise, in the second problem, each employee in the management chain hands
    off as much work as possible to a subordinate. The assistant manager, for example,
    may know the junior manager well and expect the junior manager to hand all of
    the files but one to the intern. However, the assistant manager has no reason
    to care whether the junior manager processes all of the remaining files or passes
    some of them off to a subordinate. The assistant manager cares only that the junior
    manager returns the right answer. Because the assistant manager is not going to
    repeat the work of the junior manager, the assistant manager simply assumes that
    the result returned by the junior manager is correct and uses that data to solve
    the overall task that the assistant manager received from the associate manager.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在第二个问题中，管理链中的每个员工都将尽可能多的工作转交给下属。例如，助理经理可能很了解初级经理，并期望初级经理将所有文件（除了一个）交给实习生。然而，助理经理没有理由关心初级经理是否处理了所有剩余的文件或将其中一些转交给下属。助理经理只关心初级经理是否给出了正确的答案。因为助理经理不会重复初级经理的工作，助理经理只是假设初级经理返回的结果是正确的，并使用这些数据来解决助理经理从副经理那里接收到的整体任务。
- en: 'In both problems, when employees make requests of other employees, they are
    concerned with *what* but not *how*. A question is handed off; an answer is received.
    This, then, is the Big Recursive Idea: If you follow certain conventions in your
    coding, *you can pretend that no recursion is taking place*. You can even use
    a cheap trick (shown below) to move from an iterative implementation to a recursive
    implementation, without explicitly considering how the recursion is actually solving
    the problem. Over time, you will develop an intuitive understanding of how recursive
    solutions work, but before that intuition develops, you can craft recursive implementations
    and be confident in your code.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个问题中，当员工向其他员工提出请求时，他们关心的是*什么*，而不是*如何*。一个问题被传递；一个答案被接收。这就是大递归思想：如果你在编码中遵循某些约定，*你可以假装没有发生递归*。你甚至可以使用一个简单的技巧（如下所示）从迭代实现转换为递归实现，而不必明确考虑递归实际上是如何解决问题的。随着时间的推移，你将发展出对递归解决方案如何工作的直观理解，但在这种直觉形成之前，你可以编写递归实现并对你的代码有信心。
- en: Let’s put the concept into practice through a code example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来将这个概念付诸实践。
- en: 'Problem: Computing the Sum of an Array of Integers'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：计算整数数组的和
- en: Write a recursive function that is given an array of integers and the size of
    the array as parameters. The function returns the sum of the integers in the array.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个递归函数，该函数接受一个整数数组和数组的大小作为参数。该函数返回数组中整数的和。
- en: 'Your first thought may have been that this problem would be trivial to solve
    iteratively. Indeed, let’s start with an iterative solution to this problem:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先想到这个问题通过迭代方式解决是微不足道的。确实，让我们从这个问题的迭代解决方案开始：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You saw code very similar to this in [Chapter 3](ch03.html "Chapter 3. Solving
    Problems with Arrays"), so the function should be simple to understand. The next
    step is to write code that is halfway between the iterative solution and the final
    desired recursive solution. We will keep the iterative function and add a second
    function we will refer to as a *dispatcher*. The dispatcher will hand off most
    of the work to the previously written iterative function and use this information
    to solve the overall problem. To write a dispatcher, we have to follow two rules:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第3章](ch03.html "第3章. 使用数组解决问题")中看到了非常类似的代码，所以这个函数应该很容易理解。下一步是编写介于迭代解决方案和最终所需的递归解决方案之间的代码。我们将保留迭代函数，并添加一个我们将称之为“调度器”的第二个函数。调度器将大部分工作交给之前编写的迭代函数，并使用这些信息来解决整体问题。要编写调度器，我们必须遵循两个规则：
- en: The dispatcher must completely handle the most trivial case, without calling
    the iterative function.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器必须完全处理最简单的情况，而不调用迭代函数。
- en: The dispatcher, when calling the iterative function, must pass a smaller version
    of the problem.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调度器在调用迭代函数时，必须传递一个更小的问题版本。
- en: In applying the first rule to this problem, we must decide what the most trivial
    case is. If `size` is 0, then the function has conceptually been passed a “null”
    array, with a sum of 0\. One could also make the argument that the most trivial
    case should be when `size` is 1\. In that case, there would be only one number
    in the logical array, and we could return that number as the sum. Either of these
    interpretations will work, but making the first choice allows the function to
    handle a special case. Note that the original iterative function will not fail
    when `size` is zero, so it would be preferable to maintain that flexibility.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在将第一条规则应用于这个问题时，我们必须决定最简单的情况是什么。如果`size`为0，那么函数在概念上已经接收了一个“空”数组，其总和为0。也有人可能会争辩说，最简单的情况应该是`size`为1。在这种情况下，逻辑数组中只有一个数字，我们可以将其作为总和返回。这两种解释都可以工作，但选择第一种允许函数处理一个特殊情况。请注意，原始的迭代函数在`size`为零时不会失败，因此最好保持这种灵活性。
- en: To apply the second rule to this problem, we must figure out a way to pass a
    smaller version of the problem from the dispatcher to the iterative function.
    There is no easy way to pass a smaller array, but we can easily pass a smaller
    value for `size`. If the dispatcher is given the value of 10 for `size`, the function
    is being asked to compute the sum of 10 values in the array. If the dispatcher
    passes 9 as the value of `size` to the iterative function, it is requesting the
    sum of the first 9 values in the array. The dispatcher can then add the value
    of the one remaining value in the array (the 10th) to compute the sum of all 10
    values. Note that reducing size by 1 when calling the iterative function maximizes
    the work of the iterative function and thereby minimizes the work of the dispatcher.
    This is always the desired approach—like the managers of DelegateCorp, the dispatcher
    function avoids as much work as possible.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将第二条规则应用于这个问题，我们必须找出一种方法，将问题的较小版本从调度器传递给迭代函数。没有简单的方法可以传递较小的数组，但我们可以轻松地传递较小的`size`值。如果调度器将`size`的值设为10，那么函数被要求计算数组中10个值的总和。如果调度器将`size`的值传递为9给迭代函数，它请求的是数组中前9个值的总和。调度器然后将数组中剩余的一个值（第10个）的值加起来，以计算所有10个值的总和。请注意，在调用迭代函数时减少1可以最大化迭代函数的工作量，从而最小化调度器的工作量。这始终是期望的方法——就像DelegateCorp的管理者一样，调度器函数避免尽可能多的工作。
- en: 'Putting these ideas together, here’s a dispatcher function for this problem:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些想法结合起来，这里是一个针对这个问题的调度器函数：
- en: '[PRE2]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first statement enforces the first rule of dispatchers: It checks for a
    trivial case and handles it completely, in this case, by returning 0 ![](httpatomoreillycomsourcenostarchimages1273182.png).
    Otherwise, control passes to the remaining code, which enforces the second rule.
    The last number in the array is stored in a local variable called `lastNumber`
    ![](httpatomoreillycomsourcenostarchimages1273191.png), and then the sum of all
    the other values in the array is computed via a call to the iterative function
    ![](httpatomoreillycomsourcenostarchimages1273193.png). This result is stored
    in another local variable, `allButLastSum`, and finally the function returns the
    sum of the two local variables ![](httpatomoreillycomsourcenostarchimages1273195.png).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句强制执行调度器的第一条规则：它检查一个简单的情况并完全处理它，在这种情况下，通过返回0 ![http://atomoreilly.com/source/no_starch_images/1273182.png]。否则，控制权传递到剩余的代码，该代码强制执行第二条规则。数组中的最后一个数字存储在一个名为`lastNumber`的局部变量中
    ![http://atomoreilly.com/source/no_starch_images/1273191.png]，然后通过调用迭代函数计算数组中所有其他值的总和
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]。这个结果存储在另一个局部变量`allButLastSum`中，最后函数返回这两个局部变量的总和
    ![http://atomoreilly.com/source/no_starch_images/1273195.png]。
- en: 'If we have correctly created a dispatcher function, we have already effectively
    created a recursive solution. This is the Big Recursive Idea in action. To convert
    this iterative solution to a recursive solution requires but one further, simple
    step: have the delegate function call itself where it was previously calling the
    iterative function. We can then remove the iterative function altogether.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确地创建了一个调度器函数，那么我们已经有效地创建了一个递归解决方案。这就是大递归思想在起作用。要将这个迭代解决方案转换为递归解决方案，只需要再进行一个简单步骤：让委托函数在之前调用迭代函数的地方调用自己。然后我们可以完全删除迭代函数。
- en: '[PRE3]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only two changes have been made to the previous code. The name of the function
    has been changed to better describe its new form ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and the function now calls itself where it previously called the iterative function
    ![](httpatomoreillycomsourcenostarchimages1273191.png). The logic of the two functions,
    `arraySumDelegate` and `arraySumRecursive`, is identical. Each function checks
    for a trivial case in which the sum is already known—in this case, an array of
    size 0 that has a sum of 0\. Otherwise, each function computes the sum of values
    in the array by making a function call to compute the sum of all of the values,
    save the last one. Finally, each function adds that last value to the returned
    sum for a grand total. The only difference is that the first version of the function
    calls another function, while the recursive version calls itself. The BRI tells
    us that if we follow the rules outlined above for writing the dispatcher, we can
    ignore that distinction.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只做了两项更改。函数的名称已被更改，以更好地描述其新的形式 ![图片链接](http://atomoreilly.com/source/nostarch/images/1273182.png)，并且函数现在在之前调用迭代函数
    ![图片链接](http://atomoreilly.com/source/nostarch/images/1273191.png) 的地方调用自身。两个函数
    `arraySumDelegate` 和 `arraySumRecursive` 的逻辑是相同的。每个函数都会检查一个已知和的简单情况——在这种情况下，大小为
    0 的数组其和为 0。否则，每个函数通过调用一个函数来计算数组中所有值的和（除了最后一个值）。最后，每个函数将最后一个值加到返回的总和中。唯一的区别是，函数的第一个版本调用另一个函数，而递归版本调用自身。BRI
    告诉我们，如果我们遵循上述编写派发器的规则，我们可以忽略这种区别。
- en: You do not need to literally follow all of the steps shown above to follow the
    BRI. In particular, you usually would not implement an iterative solution to the
    problem before implementing a recursive solution. Writing an iterative function
    as a stepping-stone is extra work that will eventually be thrown away. Besides,
    recursion is best applied to situations in which an iterative solution is difficult,
    as explained later. However, you can follow the outline of the BRI without actually
    writing the iterative solution. The key is thinking of a recursive call as a call
    to another function, without regards to the internals of that function. In this
    way, you remove the complexities of recursive logic from the recursive solution.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要字面地遵循上述所有步骤来遵循 BRI。特别是，您通常不会在实现递归解决方案之前实现迭代解决方案。将迭代函数作为垫脚石是额外的工作，最终会被丢弃。此外，递归最适合应用于迭代解决方案困难的情况，如后文所述。然而，您可以在不实际编写迭代解决方案的情况下遵循
    BRI 的提纲。关键是把递归调用看作是对另一个函数的调用，而不考虑该函数的内部细节。这样，您就从递归解决方案中移除了递归逻辑的复杂性。
- en: Common Mistakes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见错误
- en: 'As shown above, with the right approach, recursive solutions can often be very
    easy to write. But it can be just as easy to come up with an incorrect recursive
    implementation or a recursive solution that “works” but is ungainly. Most problems
    with recursive implementations stem from two basic faults: overthinking the problem
    or beginning implementation without a clear plan.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，使用正确的方法，递归解决方案通常很容易编写。但同样容易得出一个错误的递归实现或一个“工作”但笨拙的递归解决方案。递归实现中的大多数问题都源于两个基本错误：对问题思考过度或在没有明确计划的情况下开始实现。
- en: Overthinking recursive problems is common for new programmers because limited
    experience and lack of confidence with recursion lead them to think that the problem
    is more difficult than it really is. Code produced by overthinking can be recognized
    by its too-careful appearance. For example, a recursive function might have several
    special cases where it needs only one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对递归问题思考过度是新手程序员常见的错误，因为有限的经验和对递归的不自信使他们认为问题比实际情况更难。过度思考产生的代码可以通过其过于细致的外观来识别。例如，一个递归函数可能有几个只需要一个的特殊情况。
- en: Beginning implementation too soon can lead to overcomplicated “Rube Goldberg”
    code, where unforeseen interactions lead to fixes that are bolted onto the original
    code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 过早开始实现可能导致过于复杂的“鲁布·戈尔巴乔夫”代码，其中未预见的交互导致了对原始代码的修复。
- en: Let’s look at some specific mistakes and how to avoid them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些具体的错误以及如何避免它们。
- en: Too Many Parameters
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数过多
- en: As described previously, the head recursion technique can reduce the data passed
    to the recursive call, while the tail recursion technique can result in passing
    additional data to recursive calls. Programmers often get stuck in the tail recursion
    mode because they overthink and start implementation too soon.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，头递归技术可以减少传递给递归调用的数据量，而尾递归技术可能会导致向递归调用传递额外的数据。程序员常常陷入尾递归模式，因为他们过度思考并且过早开始实现。
- en: 'Consider our problem of recursively computing the sum of an array of integers.
    Writing an iterative solution to this problem, the programmer knows a “running
    total” variable will be needed (in the iterative solution provided, I called this
    `sum`) and the array will be summed starting from the first element. Considering
    the recursive solution, the programmer naturally imagines an implementation that
    most directly mirrors the iterative solution, with a running total variable and
    the first recursive call handling the first element in the array. This approach,
    however, requires the recursive function to pass the running total and the location
    where the next recursive call should begin processing. Such a solution would look
    like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们递归计算整数数组总和的问题。编写这个问题的迭代解决方案时，程序员知道需要一个“运行总和”变量（在提供的迭代解决方案中，我称这个变量为`sum`），并且数组将从第一个元素开始求和。考虑到递归解决方案，程序员自然会想象一个最直接反映迭代解决方案的实现，有一个运行总和变量，第一个递归调用处理数组的第一个元素。然而，这种方法要求递归函数传递运行总和和下一个递归调用应该开始处理的位置。这样的解决方案看起来像这样：
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code is as short as the other recursive version but considerably more
    semantically complex because of the additional parameters, `sum` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    and `currentIndex` ![](httpatomoreillycomsourcenostarchimages1273191.png). From
    the client code’s point of view, the extra parameters are meaningless and will
    always have to be zeroes in the call, as shown in this example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与其他递归版本一样短，但由于额外的参数`sum` ![](httpatomoreillycomsourcenostarchimages1273182.png)和`currentIndex`
    ![](httpatomoreillycomsourcenostarchimages1273191.png)，语义上要复杂得多。从客户端代码的角度来看，这些额外的参数是没有意义的，并且调用时总是为零，如这个示例所示：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This problem can be avoided with the use of a *wrapper function*, as described
    in the next section, but because we can’t eliminate those parameters altogether,
    that’s not the best solution. The iterative function for this problem and the
    original recursive function answer the question, what is the sum of this array
    with this many elements? In contrast, this second recursive function is being
    asked, what is the sum of this array if it has this many elements, we are starting
    with this particular element, and this is the sum of all the prior elements?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**包装函数**可以避免这个问题，正如下一节所描述的，但由于我们无法完全消除这些参数，这并不是最佳解决方案。这个问题的迭代函数和原始递归函数回答了这样一个问题：具有这么多元素的数组的总和是多少？相比之下，这个第二个递归函数被问到的是，如果数组有这么多元素，我们从这个特定元素开始，这是所有先前元素的总和？
- en: The “too many parameters” problem is avoided by choosing your function parameters
    before thinking about recursion. In other words, force yourself to use the same
    parameter list you would if the solution were iterative. If you use the full BRI
    process and actually write the iterative function first, you will avoid this problem
    automatically. If you skip using the whole process formally, though, you can still
    use the idea conceptually if you write out the parameter list based on what you
    would expect for an iterative function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在选择递归函数参数之前考虑“参数过多”的问题，可以避免这个问题。换句话说，强迫自己使用如果解决方案是迭代的，你将使用的相同参数列表。如果你使用完整的BRI过程并且首先实际编写迭代函数，你将自动避免这个问题。如果你跳过正式使用整个过程，尽管如此，如果你根据你期望的迭代函数编写参数列表，你仍然可以在概念上使用这个想法。
- en: Global Variables
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'Avoiding too many parameters sometimes leads programmers into making a different
    mistake: using global variables to pass data from one recursive call to the other.
    The use of global variables is generally a poor programming practice, although
    it is sometimes permissible for performance reasons. Global variables should always
    be avoided in recursive functions when possible. Let’s look at a specific problem
    to see how programmers talk themselves into this mistake. Suppose we were asked
    to write a recursive function that counted the number of zeros appearing in an
    array of integers. This is a simple problem to solve using iteration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 避免过多的参数有时会让程序员犯另一个错误：使用全局变量从一个递归调用传递数据到另一个递归调用。虽然出于性能原因有时是允许的，但使用全局变量通常是一种糟糕的编程实践。在可能的情况下，递归函数中应始终避免使用全局变量。让我们看看一个具体的问题，看看程序员是如何说服自己犯这个错误的。假设我们被要求编写一个递归函数，用来计算整数数组中出现的零的数量。这是一个简单的问题，可以使用迭代来解决：
- en: '[PRE6]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The logic of this code is straightforward. We’re just running through the array
    from the first location to the last, counting up the zeroes as we go and using
    a local variable, `count` ![](httpatomoreillycomsourcenostarchimages1273182.png),
    as a tracker. If we have a function like this in our minds when we write our recursive
    function, though, we may assume that we need a tracker variable in that version
    as well. We can’t simply declare count as a local variable in the recursive version
    because then it would be a new variable in each recursive call. So we might be
    tempted to declare it as a global variable:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的逻辑很简单。我们只是从数组的第一个位置遍历到最后一个位置，在遍历的过程中计数零的数量，并使用一个局部变量`count` ![](httpatomoreillycomsourcenostarchimages1273182.png)作为跟踪器。如果我们写递归函数时心里有这样一个函数，我们可能会认为在那个版本中也需要一个跟踪变量。但我们不能简单地在递归版本中声明`count`为局部变量，因为那样的话，它就会在每次递归调用中成为一个新的变量。因此，我们可能会倾向于将其声明为全局变量：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code works, but the global variable is entirely unnecessary and causes
    all the problems global variables typically cause, such as poor readability and
    more difficult code maintenance. Some programmers might attempt to mitigate the
    problem by making the variable local, but static:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，但全局变量完全是多余的，并且导致了全局变量通常引起的问题，比如可读性差和代码维护更困难。一些程序员可能会尝试通过将变量设置为局部但静态的方式来减轻这个问题，但这样做：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In C++, a local variable declared as *static* retains its value from one function
    call to the next; thus, the local static variable `count` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    would act the same as the global variable in the previous version. So what’s the
    problem? The initialization of the variable to zero ![](httpatomoreillycomsourcenostarchimages1273191.png)
    happens only the first time the function is called. This is necessary for the
    `static` declaration to be of any use, but it means that the function will return
    a correct answer only the first time it is called. If this function were called
    twice—first with an array that had three zeros, then with an array that had five
    zeros—the function would return an answer of eight for the second array because
    `count` would be starting where it had left off.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，声明为*静态*的局部变量会保留其值，从一次函数调用到下一次；因此，局部静态变量`count` ![](httpatomoreillycomsourcenostarchimages1273182.png)会与上一个版本中的全局变量表现相同。那么问题是什么？变量的初始化为零
    ![](httpatomoreillycomsourcenostarchimages1273191.png)只发生在函数第一次被调用时。这对于`static`声明有任何用途是必要的，但这意味着函数只有在第一次被调用时才会返回正确答案。如果这个函数被调用两次——第一次是一个有三个零的数组，然后是一个有五个零的数组——由于`count`会从上次停止的地方开始，函数会对第二个数组返回八个作为答案。
- en: 'The solution to avoiding the global variable in this case is to use the BRI.
    We can assume that a recursive call with a smaller value for `size` will return
    the correct result and compute the correct value for the overall array from that.
    This will lead to a head-recursive solution:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，避免使用全局变量的解决方案是使用BRI（尾递归改进）。我们可以假设一个`size`值较小的递归调用将返回正确的结果，并从那里计算出整个数组的正确值。这将导致一个头递归解决方案：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this function, we still have a local variable, `count` ![](httpatomoreillycomsourcenostarchimages1273182.png),
    but here no attempt is made to maintain its value from one call to the next. Instead,
    it stores the return value from our recursive call; we optionally increment the
    variable ![](httpatomoreillycomsourcenostarchimages1273191.png) before returning
    it ![](httpatomoreillycomsourcenostarchimages1273193.png).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们仍然有一个局部变量`count` ![count变量](httpatomoreillycomsourcenostarchimages1273182.png)，但在这里没有尝试从一次调用保持其值到下一次调用。相反，它存储了我们的递归调用的返回值；在返回之前，我们可以选择性地增加变量
    ![变量增加](httpatomoreillycomsourcenostarchimages1273191.png) ![返回值](httpatomoreillycomsourcenostarchimages1273193.png)。
- en: Applying Recursion to Dynamic Data Structures
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将递归应用于动态数据结构
- en: Recursion is often applied to dynamic structures such as linked lists, trees,
    and graphs. The more complicated the structure, the more the coding can benefit
    from a recursive solution. Processing complicated structures is often a lot like
    finding one’s way through a maze, and recursion allows us to backtrack to previous
    steps in our processing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 递归通常应用于动态结构，如链表、树和图。结构越复杂，代码从递归解决方案中受益越多。处理复杂结构通常就像在迷宫中找到出路一样，递归允许我们在处理过程中回溯到之前的步骤。
- en: Recursion and Linked Lists
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归与链表
- en: 'Let’s start, though, with the most basic of dynamic structures, a linked list.
    For discussions in this section, let’s assume we have the simplest of node structures
    for our linked list, just a single `int` for data. Here are our type declarations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们从最基本的动态结构开始，即链表。在本节讨论中，让我们假设我们有一个最简单的节点结构用于我们的链表，仅有一个`int`用于数据。以下是我们的类型声明：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Applying the BRI to a singly linked list follows the same general outline regardless
    of the specific task. Recursion requires us to divide the problem, to be able
    to pass a reduced version of the original problem to the recursive call. There
    is only one practical way to divide a singly linked list: the first node in the
    list and the rest of the list.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将BRI应用于单链表遵循相同的一般概述，无论具体任务如何。递归要求我们分解问题，以便能够将原始问题的简化版本传递给递归调用。将单链表分解只有一个实际的方法：列表中的第一个节点和其余的列表。
- en: 'In [Figure 6-5](ch06.html#a_list_divided_into_a_first_node_and_lth "Figure 6-5. A
    list divided into a first node and “the rest of the list”"), we see a sample list
    divided into unequal parts: the first node and all of the other nodes. Conceptually,
    we can view the “rest of” the original list as its own list, starting with the
    second node in the original list. It is this view that allows the recursion to
    work smoothly.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-5](ch06.html#a_list_divided_into_a_first_node_and_lth "图6-5. 将列表分为首节点和“其余列表”")中，我们看到一个示例列表被分为不等的部分：首节点和所有其他节点。从概念上讲，我们可以将“其余的”原始列表视为其自身的列表，从原始列表中的第二个节点开始。正是这种观点使得递归能够顺利工作。
- en: '![A list divided into a first node and “the rest of the list”](httpatomoreillycomsourcenostarchimages1273259.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![将列表分为首节点和“其余列表”](httpatomoreillycomsourcenostarchimages1273259.png)'
- en: Figure 6-5. A list divided into a first node and “the rest of the list”
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5. 将列表分为首节点和“其余列表”
- en: 'Again, though, we are not required to picture all the steps of the recursion
    to make the recursion work. From the point of view of someone writing a recursive
    function to process a linked list, it can be conceptualized as the first node,
    which we have to deal with, and the rest of the list, which we don’t and therefore
    aren’t concerned about. This attitude is shown in [Figure 6-6](ch06.html#the_list_as_a_programmer_using_recursion
    "Figure 6-6. The list as a programmer using recursion should picture it: a first
    node and the rest of the list as a nebulous shape to be passed off to the recursive
    call").'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不需要想象递归的所有步骤来使递归工作。从编写递归函数处理链表的人的角度来看，它可以被概念化为第一个节点，我们必须处理它，以及其余的列表，我们不需要关心，因此不关心。这种态度在[图6-6](ch06.html#the_list_as_a_programmer_using_recursion
    "图6-6. 程序员使用递归应想象出的列表：一个首节点和其余列表作为一个模糊的形状传递给递归调用")中有所体现。
- en: '![The list as a programmer using recursion should picture it: a first node
    and the rest of the list as a nebulous shape to be passed off to the recursive
    call](httpatomoreillycomsourcenostarchimages1273261.png.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![程序员使用递归应想象出的列表：一个首节点和其余列表作为一个模糊的形状传递给递归调用](httpatomoreillycomsourcenostarchimages1273261.png.jpg)'
- en: 'Figure 6-6. The list as a programmer using recursion should picture it: a first
    node and the rest of the list as a nebulous shape to be passed off to the recursive
    call'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6. 程序员使用递归时应该想象链表的样子：一个第一个节点和链表的其余部分作为一个需要传递给递归调用的模糊形状
- en: 'With the division of labor fixed, we can say that recursive processing of singly
    linked lists will proceed according to the following general plan. Given a linked
    list L and a question Q:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作分配固定的情况下，我们可以这样说，单链表的递归处理将按照以下一般计划进行。给定一个链表L和一个问题Q：
- en: If L is minimal, we directly assign a default value. Otherwise . . .
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果L是最小的，我们直接分配一个默认值。否则……
- en: Use a recursive call to produce an answer to Q for the “rest of” list L (the
    list starting with the second node of L).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用递归调用为“剩余”的链表L（从L的第二个节点开始的链表）对Q给出答案。
- en: Inspect the value in the first node of L.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查L的第一个节点的值。
- en: Use the results of the previous two steps to answer Q for the whole of L.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前两个步骤的结果为整个L对Q给出答案。
- en: As you can see, this is just a straightforward application of the BRI given
    the practical restrictions on breaking up a linked list. Now let’s apply this
    blueprint to a specific problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这只是在将链表拆分时的实际限制下对BRI的直接应用。现在让我们将这个蓝图应用到具体的问题上。
- en: 'Problem: Counting Negative Numbers in a Singly Linked List'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：在单链表中计数负数
- en: Write a recursive function that is given a singly linked list where the data
    type is integer. The function returns the count of negative numbers in the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个递归函数，该函数接受一个整数类型的数据的单链表。该函数返回链表中负数的计数。
- en: 'The question, Q, we want to answer is, how many negative numbers are in the
    list? Therefore, our plan can be stated as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要回答的问题是，链表中有多少个负数？因此，我们的计划可以表述为：
- en: If the list has no nodes, the count is 0 by default. Otherwise . . .
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果链表没有节点，则默认计数为0。否则……
- en: Use a recursive call to count how many negative numbers are in the “rest of”
    the list.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用递归调用来计数“剩余”的列表中有多少个负数。
- en: See whether the value in the first node of the list is negative.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查链表第一个节点的值是否为负。
- en: Use the results of the previous two steps to determine how many negative numbers
    are in the whole list.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前两个步骤的结果来确定整个链表中有多少个负数。
- en: 'Here’s a function implementation that follows directly from this plan:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个直接从这个计划中得出的函数实现：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note how this code follows the same principles as previous examples. It will
    count the negative numbers “backward,” from the end of the list to the front.
    Also note that the code employs the head recursion technique; we process the “rest
    of” the list before we process the first node. As before, this allows us to avoid
    passing extra data in the recursive call or using global variables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码遵循与之前示例相同的原理。它将“向后”计数负数，从列表的末尾到前面。此外，注意代码使用了头递归技术；我们在处理“剩余”的列表之前先处理第一个节点。和之前一样，这允许我们避免在递归调用中传递额外的数据或使用全局变量。
- en: Also notice how linked-list rule 1, “if list L is minimal,” is interpreted in
    the specific implementation of this problem as “if the list has no nodes.” That’s
    because it is meaningful to say that a list with no nodes has zero negative values.
    In some cases, though, there is no meaningful answer for our question Q for a
    list with no nodes, and the minimal case is a list with one node. Suppose our
    question was, what’s the largest number in this list? That question cannot be
    answered for a list with no values. If you don’t see why, pretend you are an elementary
    school teacher, and your class happens to be all girls. If your school’s principal
    asked you how many boys in your classroom were members of the boy’s choir, you
    could simply answer zero because you have no boys. If your principal asked you
    to name the tallest boy in your class, you could not give a meaningful answer
    to that question—you would have to have at least one boy to have a tallest boy.
    In the same way, if the question about a data set requires at least one value
    to be meaningfully answered, the minimal data set is one item. You may still want
    to return *something* for the “size zero” case, however, if only for flexibility
    in the use of the function and to guard against a crash.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如何将链表规则1，“如果列表L是最小的”，在特定问题的具体实现中解释为“如果列表没有节点”。这是因为说一个没有节点的列表有零个负值是有意义的。然而，在某些情况下，对于没有节点的列表，我们的问题Q可能没有有意义的答案，最小的情况是只有一个节点的列表。假设我们的问题是，这个列表中最大的数是什么？对于没有值的列表，这个问题是无法回答的。如果你不明白为什么，假设你是一名小学教师，你的班级碰巧都是女生。如果你的校长问你教室里有多少男生是男童合唱团的成员，你可以简单地回答零，因为你没有男生。如果你的校长要求你指出你班上最高的男生是谁，你无法对这个问题给出有意义的答案——你必须至少有一个男生才能有最高的男生。同样，如果一个关于数据集的问题需要至少一个值才能有意义的回答，最小数据集就是一个项目。然而，你可能仍然希望为“大小为零”的情况返回*某些东西*，只是为了函数使用的灵活性，以及防止崩溃。
- en: Recursion and Binary Trees
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归与二叉树
- en: 'All of the examples we have explored so far make no more than one recursive
    call. More complicated structures, however, may require multiple recursive calls.
    For a taste of how that works, let’s consider the structure known as a *binary
    tree*, in which each node contains “left” and “right” links to other nodes. Here
    are the types we’ll use:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所探讨的所有示例都不超过一次递归调用。然而，更复杂的数据结构可能需要多次递归调用。为了了解这是如何工作的，让我们考虑一种称为*二叉树*的结构，其中每个节点包含指向其他节点的“左”和“右”链接。以下是我们将使用的类型：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because each node in the tree points to two other nodes, recursive tree-processing
    functions require two recursive calls. We conceptualized linked lists as having
    two parts: a first node and the rest of the list. For applying recursion, we will
    conceptualize trees as having three parts: the node at the top, known as the *root
    node*; all of the nodes reached from the left link of the root, known as the *left
    subtree*; and all of the nodes reached from the right link of the root, known
    as the *right subtree*. This conceptualization is shown in [Figure 6-7](ch06.html#a_binary_tree_divided_into_a_root_node_a
    "Figure 6-7. A binary tree divided into a root node and left and right subtree").
    As with the linked list and as developers of a recursive solution, we just focus
    on the existence of the left and right subtrees, without considering their contents.
    This is shown in [Figure 6-8](ch06.html#a_binary_tree_as_a_programmer_using_recu
    "Figure 6-8. A binary tree as a programmer using recursion should picture it:
    a root node with left and right subtrees of unknown and unconsidered structure").'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因为树中的每个节点都指向两个其他节点，所以递归树处理函数需要两次递归调用。我们将链表概念化为有两个部分：一个第一个节点和列表的其余部分。为了应用递归，我们将树概念化为有三个部分：顶部的节点，称为*根节点*；从根的左链接到达的所有节点，称为*左子树*；以及从根的右链接到达的所有节点，称为*右子树*。这种概念化在[图6-7](ch06.html#a_binary_tree_divided_into_a_root_node_a
    "图6-7. 一棵被分为根节点和左右子树的二叉树")中显示。与链表一样，作为递归解决方案的开发者，我们只关注左右子树的存在，而不考虑它们的内部结构。这如图[图6-8](ch06.html#a_binary_tree_as_a_programmer_using_recu
    "图6-8. 程序员使用递归看待二叉树时应该想象的样子：一个具有左右子树的根节点，其结构和内容未知且不考虑")所示。
- en: '![A binary tree divided into a root node and left and right subtree](httpatomoreillycomsourcenostarchimages1273263.png.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![一棵被分为根节点和左右子树的二叉树](httpatomoreillycomsourcenostarchimages1273263.png.jpg)'
- en: Figure 6-7. A binary tree divided into a root node and left and right subtree
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7. 一棵被分为根节点和左右子树的二叉树
- en: 'As always, when recursively solving problems involving binary trees, we want
    to employ the BRI. We will make recursive function calls and assume they return
    correct results without worrying about how the recursive process solves the overall
    problem. As with linked lists, we will work with the natural divisions of a binary
    tree. This produces the following general plan. To answer a question Q for tree
    T:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在递归解决涉及二叉树的问题时，我们希望采用BRI。我们将进行递归函数调用，并假设它们返回正确的结果，而不必担心递归过程如何解决整体问题。与链表一样，我们将与二叉树的自然划分一起工作。这产生了以下一般计划。为了回答关于树T的问题Q：
- en: '![A binary tree as a programmer using recursion should picture it: a root node
    with left and right subtrees of unknown and unconsidered structure](httpatomoreillycomsourcenostarchimages1273265.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![程序员使用递归时应该想象二叉树的样子：一个根节点，其左右子树的结构未知且未考虑](http://atomoreilly.com/source/nostarch/images/1273265.png)'
- en: 'Figure 6-8. A binary tree as a programmer using recursion should picture it:
    a root node with left and right subtrees of unknown and unconsidered structure'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8. 程序员使用递归时应该想象二叉树的样子：一个根节点，其左右子树的结构未知且未考虑
- en: If tree T is of minimal size, directly assign a default value. Otherwise . .
    .
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果树T的大小是最小的，则直接分配一个默认值。否则……
- en: Make a recursive call to answer Q for the left subtree of T.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用以回答T的左子树的问题Q。
- en: Make a recursive call to answer Q for the right subtree of T.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用以回答T的右子树的问题Q。
- en: Inspect the value in the root node of T.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查T的根节点中的值。
- en: Use the results of the previous three steps to answer Q for all of T.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前三个步骤的结果来回答T的所有问题Q。
- en: Now let’s apply the general plan to a specific problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将一般计划应用于一个具体问题。
- en: 'Problem: Find the Largest Value in a Binary Tree'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：在二叉树中找到最大值
- en: Write a function that, when given a binary tree where each node holds an integer,
    returns the largest integer in the tree.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，当给定一个每个节点都包含整数的二叉树时，返回树中的最大整数。
- en: 'Applying the general plan to this specific problem results in the following
    steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将一般计划应用于这个具体问题，结果如下步骤：
- en: If the root of the tree has no children, return the value in the root. -Otherwise
    . . .
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果树的根没有子节点，则返回根节点中的值。 -否则……
- en: Make a recursive call to find the largest value in the left subtree.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用以找到左子树中的最大值。
- en: Make a recursive call to find the largest value in the right subtree.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归调用以找到右子树中的最大值。
- en: Inspect the value in the root node.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查根节点中的值。
- en: Return the largest of the values in the previous three steps.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回前三个步骤中值最大的一个。
- en: 'With those steps in mind, we can directly write the code for the solution:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤的指导下，我们可以直接编写解决方案的代码：
- en: '[PRE13]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice how the minimal tree for this problem is a single node ![](httpatomoreillycomsourcenostarchimages1273191.png)
    (although the empty-tree case is covered for safety ![](httpatomoreillycomsourcenostarchimages1273182.png)).
    This is because the question we are asking can only be meaningfully answered with
    at least one data value. Consider the practical problem if we tried to make the
    empty tree the base case. What value could we return? If we return zero, we implicitly
    require some positive values in the tree; if all of the values in the tree are
    negative, zero will be erroneously returned as the largest value in the tree.
    We might solve this problem by returning the lowest (most negative) possible integer,
    but then we would have to be careful adapting the code for other numeric types.
    By making a single node the base case, we avoid this decision altogether.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个问题的最小树是一个单独的节点 ![最小树](http://atomoreilly.com/source/nostarch/images/1273191.png)（尽管为了安全起见也涵盖了空树的情况
    ![空树](http://atomoreilly.com/source/nostarch/images/1273182.png)）。这是因为我们提出的问题只能用至少一个数据值有意义的回答。考虑如果我们尝试将空树作为基本情况的实际问题。我们可以返回什么值？如果我们返回零，则隐含地要求树中有一些正值；如果树中的所有值都是负值，则零将被错误地返回为树中的最大值。我们可能通过返回可能的最小（最负）整数来解决此问题，但那时我们必须小心地调整代码以适应其他数值类型。通过将单个节点作为基本案例，我们完全避免了这一决定。
- en: The rest of the code is straightforward. We use recursion to find the maximum
    values in the left ![](httpatomoreillycomsourcenostarchimages1273193.png) and
    right subtrees ![](httpatomoreillycomsourcenostarchimages1273195.png). Then we
    find the largest of the three values (value at root, largest in left subtree,
    largest in right subtree) using a variant of the “King of the Hill” algorithm
    we’ve been using throughout this book ![](httpatomoreillycomsourcenostarchimages1273197.png).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分很简单。我们使用递归在左 ![图片](http://atomoreilly.com/source/no_starch_images/1273193.png)
    和右子树 ![图片](http://atomoreilly.com/source/no_starch_images/1273195.png) 中找到最大值。然后我们使用本书中一直使用的“山丘之王”算法的变体来找到这三个值中的最大值（根节点值、左子树中的最大值、右子树中的最大值）![图片](http://atomoreilly.com/source/no_starch_images/1273197.png)。
- en: Wrapper Functions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装函数
- en: In the previous examples in this chapter, we have discussed only the recursive
    function itself. In some cases, however, the recursive function needs to be “set
    up” by a second function. Most commonly, this occurs when we write recursive functions
    inside of class structures. This can cause a mismatch between the parameters required
    for the recursive function and the parameters needed for a public method of the
    class. Because classes typically enforce information hiding, the class client
    code may not have access to the data or types the recursive function requires.
    This problem and its solution are shown in the next example.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们只讨论了递归函数本身。然而，在某些情况下，递归函数需要通过第二个函数来“设置”。最常见的情况是我们将递归函数写在类结构内部。这可能导致递归函数所需的参数与类公共方法所需的参数不匹配。由于类通常强制信息隐藏，类客户端代码可能无法访问递归函数所需的数据或类型。这个问题及其解决方案将在下一个示例中展示。
- en: 'Problem: Find the Number of Leaves in a Binary Tree'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：找到二叉树中的叶子数
- en: For a class that implements a binary tree, add a publicly accessible method
    that returns the number of leaves (nodes without children) in the tree. The counting
    of leaves should be performed using recursion.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现二叉树的类，添加一个公开可访问的方法，该方法返回树中的叶子数（没有子节点的节点）。叶子计数应使用递归进行。
- en: Let’s sketch the outline of what this class might look like before we try to
    implement a solution to this problem. For simplicity, we will include only the
    relevant parts of the class, ignoring the constructors, the destructor, and even
    the methods that would allow us to build the tree in order to focus on our recursive
    method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试实现这个问题的解决方案之前，让我们先概述一下这个类可能的样子。为了简单起见，我们将只包括类中的相关部分，忽略构造函数、析构函数，甚至允许我们按顺序构建树的那些方法，以便专注于我们的递归方法。
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that our leaf-counting function takes no parameters ![](httpatomoreillycomsourcenostarchimages1273182.png).
    From an interface point of view, this is exactly correct. Consider a sample call
    for a previously constructed `binaryTree` object `bt`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的叶子计数函数不接收任何参数 ![图片](http://atomoreilly.com/source/no_starch_images/1273182.png)。从接口角度来看，这是完全正确的。考虑一个对先前构建的
    `binaryTree` 对象 `bt` 的示例调用：
- en: '[PRE15]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After all, if we are asking the tree how many leaves it has, what information
    could we possibly provide to the object that it would not already know about itself?
    As correct as this is for the interface, it’s all wrong for the recursive implementation.
    If there is no parameter, what changes from one recursive call to the next? Nothing
    can change in that case, except through global variables, which, as stated earlier,
    are to be avoided. If nothing changes, there’s no way for the recursion to progress
    or terminate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们询问树有多少叶子，我们能为对象提供什么信息，它可能不知道关于自己的信息？尽管这对于接口来说是正确的，但对于递归实现来说却是完全错误的。如果没有参数，从一次递归调用到下一次递归调用会有什么变化？在这种情况下，除了全局变量之外，没有任何东西可以改变，而全局变量，如前所述，应避免使用。如果没有变化，递归就无法进行或终止。
- en: The way around this problem is to write the recursive function first, conceptualizing
    it as a function outside of a class. In other words, we’ll write this function
    to count the leaves in a binary tree in the same style we wrote the function to
    find the largest value in a binary tree. The one parameter we need to pass is
    a pointer to our node structure.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是首先编写递归函数，将其概念化为类外的函数。换句话说，我们将以与编写在二叉树中查找最大值函数相同的方式编写这个函数，来计算二叉树中的叶子数。我们需要传递的一个参数是我们节点结构的指针。
- en: 'This gives us another opportunity to employ the BRI. What is the question Q
    in this case? It is, how many leaves are in the tree? Applying the general plan
    for recursively processing binary trees to this specific problem results in the
    following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了另一个机会来应用 BRI。在这种情况下，问题 Q 是什么？它是，树中有多少个叶子节点？将递归处理二叉树的一般计划应用于这个具体问题，结果如下：
- en: If the root of the tree has no children, then the tree has one node total. That
    node is a leaf by definition, so return 1\. Otherwise . . .
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果树的根节点没有子节点，那么树总共只有一个节点。根据定义，这个节点是一个叶子节点，因此返回 1。否则 ...
- en: Make a recursive call to count the leaves in the left subtree.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对左子树进行递归调用以计数叶子。
- en: Make a recursive call to count the leaves in the right subtree.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对右子树进行递归调用以计数叶子。
- en: In this case, there is no need to inspect the root node because if we get to
    this step, there is no way the root is a leaf. So . . .
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，没有必要检查根节点，因为我们到达这一步时，根节点不可能是叶子节点。所以 ...
- en: Return the sum of steps 2 and 3.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回步骤 2 和 3 的总和。
- en: 'Translating this plan into code results in this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将此计划转换为代码如下：
- en: '[PRE16]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the code is a direct translation of the plan. The question
    is, how do we get from this independent function to something we can use in the
    class? This is where the unwary programmer could easily get into trouble, thinking
    that we need to use a global variable or make the root pointer public. But we
    don’t need to do that; we can keep everything inside the class. The trick is to
    use a *wrapper function*. First, we put the independent function, with the `treePtr`
    parameter, in the private section of our class. Then, we write a public function,
    the wrapper function, which will “wrap” the private function. Because the public
    function has access to the private data member `root`, it can pass this along
    to the recursive function and then return the results back to the client like
    this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码是计划的直接翻译。问题是，我们如何从这个独立函数转换到可以在类中使用的东西？这就是粗心的程序员可能会轻易陷入麻烦的地方，认为我们需要使用全局变量或使根指针公开。但我们需要做的不是这样；我们可以将一切保持在内。诀窍是使用*包装函数*。首先，我们将具有`treePtr`参数的独立函数放在我们类的私有部分。然后，我们编写一个公共函数，即包装函数，它将“包装”私有函数。因为公共函数可以访问私有数据成员`root`，它可以将其传递给递归函数，然后像这样将结果返回给客户端：
- en: '[PRE17]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Although C++ would allow both functions to have the same name, for clarity I’ve
    used different names to distinguish between the public and private “count leaves”
    functions. The code in `privateCountLeaves` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    is exactly the same as our previous, independent function `countLeaves`. The wrapper
    function `publicCountLeaves` ![](httpatomoreillycomsourcenostarchimages1273191.png)
    is simple. It calls `privateCountLeaves`, passing the private data member root,
    and returns the result ![](httpatomoreillycomsourcenostarchimages1273193.png).
    In essence, it “primes the pump” of the recursive process. Wrapper functions are
    very helpful when writing recursive functions inside classes, but they can be
    used anytime a mismatch exists between the parameter list required by a function
    and the desired parameter list of a caller.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++允许两个函数具有相同的名称，但为了清晰起见，我使用了不同的名称来区分公共和私有的“计数叶子”函数。`privateCountLeaves`中的代码![http://atomoreilly.com/source/nostarch/images/1273182.png](http://atomoreilly.com/source/nostarch/images/1273182.png)与我们的上一个独立函数`countLeaves`完全相同。包装函数`publicCountLeaves`![http://atomoreilly.com/source/nostarch/images/1273191.png]很简单。它调用`privateCountLeaves`，传递私有的数据成员`root`，并返回结果![http://atomoreilly.com/source/nostarch/images/1273193.png]。本质上，它“启动”了递归过程。包装函数在编写类内部的递归函数时非常有帮助，但它们可以在任何函数所需的参数列表与调用者期望的参数列表不匹配时使用。
- en: When to Choose Recursion
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时选择递归
- en: New programmers often wonder why anyone has to deal with recursion. They may
    have already learned that any program can be constructed using basic control structures,
    such as selection (if statements) and iteration (`for` and `while` loops). If
    recursion is more difficult to employ than basic control structures and unnecessary,
    perhaps recursion should just be ignored.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 新程序员常常想知道为什么有人要处理递归。他们可能已经了解到任何程序都可以使用基本控制结构构建，例如选择（if语句）和迭代（for和while循环）。如果递归比基本控制结构更难应用且不必要，那么递归可能应该被忽略。
- en: There are several rebuttals to this. First, programming recursively helps programmers
    think recursively, and recursive thinking is employed throughout the world of
    computer science in such areas as compiler design. Second, some languages simply
    require recursion because they lack some basic control structures. Pure versions
    of the Lisp language, for example, require recursion in almost every nontrivial
    function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个反驳。首先，递归编程有助于程序员以递归的方式思考，递归思维在计算机科学的各个领域，如编译器设计中都得到了应用。其次，一些语言由于缺乏一些基本控制结构，因此需要递归。例如，Lisp语言的纯版本几乎在所有非平凡函数中都需要递归。
- en: 'The question remains, though: If a programmer has studied recursion enough
    to “get it” and is using a full-featured language such as C++, Java, or Python,
    should recursion ever be employed? Does recursion have practical use in such languages,
    or is it just a mental exercise?'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题仍然存在：如果一个程序员已经足够了解递归以至于“理解”了它，并且正在使用像C++、Java或Python这样的功能齐全的语言，那么递归是否应该被使用？在这些语言中，递归是否有实际用途，或者它仅仅是一种心智练习？
- en: Arguments Against Recursion
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反对递归的论点
- en: To explore this question, let’s enumerate the bad features of recursion.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探讨这个问题，让我们列举递归的缺点。
- en: '**Conceptual complexity**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念复杂性**'
- en: For most problems, it’s more difficult for the average programmer to solve a
    problem using recursion. Even once you understand the Big Recursive Idea, it’s
    still going to be easier in most cases to write code using loops.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数问题，普通程序员使用递归解决问题更困难。即使你理解了“大递归思想”，在大多数情况下，使用循环编写代码仍然更容易。
- en: '**Performance**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能**'
- en: Function calls incur significant overhead. Recursion involves lots of function
    calls and, therefore, can be slow.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用会产生显著的开销。递归涉及大量的函数调用，因此可能会很慢。
- en: '**Space requirements**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**空间需求**'
- en: Recursion doesn’t simply employ many function calls; it also nests them. That
    is, you can end up with a long chain of function calls waiting for other calls
    to complete. Each function call that has begun but has yet to end takes additional
    space on the system stack.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 递归不仅使用了许多函数调用，而且还嵌套了它们。也就是说，你可能会得到一个等待其他调用完成的函数调用长链。每个已经开始但尚未结束的函数调用都会在系统栈上占用额外的空间。
- en: At a glance, this list of features constitutes a strong indictment against recursion
    as difficult, slow, and wasteful of space. However, these arguments do not hold
    universally. The most basic rule, then, for deciding between recursion and iteration
    is, *choose recursion when these arguments do not apply*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这个功能列表构成了对递归作为困难、缓慢和空间浪费的强烈指控。然而，这些论点并不普遍适用。因此，决定递归和迭代之间的最基本规则是，*在这些论点不适用时选择递归*。
- en: 'Consider our function that counts the number of leaves in a binary tree. How
    would you solve this problem without recursion? It’s possible, but you would need
    an explicit mechanism for maintaining the “breadcrumb trail” of nodes for which
    the left children had already been visited but not the right children. These nodes
    would need to be revisited at some point so we could travel down the right side.
    You might store these nodes in a dynamic structure, such as a stack. For comparison,
    here’s an implementation of the function that uses the stack class from the C++
    standard template library:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们用来计算二叉树中叶子节点数量的函数。你将如何在不使用递归的情况下解决这个问题？这是可能的，但你需要一个显式的机制来维护“面包屑路径”，即那些左子节点已被访问但右子节点尚未访问的节点。这些节点需要在某个时候被重新访问，以便我们可以沿着右侧移动。你可能会将这些节点存储在动态结构中，例如栈。为了比较，这里是一个使用C++标准模板库中的栈类的函数实现：
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code follows the same pattern as the original, but if you’ve never used
    the stack class before, a few comments are in order. The stack class works like
    the system stack we discussed in [Chapter 3](ch03.html "Chapter 3. Solving Problems
    with Arrays"); you can add and remove items only at the top. Note that we could
    perform our leaf count operation using any data structure that doesn’t have a
    fixed size. We could have used a vector, for example, but the use of the stack
    most directly mirrors the original code. When we declare the stack ![](httpatomoreillycomsourcenostarchimages1273182.png),
    we specify the type of items we will store there. In this case, we would store
    pointers to our `binaryTreeNode` structure ![](httpatomoreillycomsourcenostarchimages1273191.png).
    We make use of four stack class methods in this code. The `push` method ![](httpatomoreillycomsourcenostarchimages1273193.png)
    places an item (a node pointer, in this case) on the top of the stack. The `empty`
    method ![](httpatomoreillycomsourcenostarchimages1273195.png) tells us whether
    there are any items left on the stack. The `top` method ![](httpatomoreillycomsourcenostarchimages1273197.png)
    gives us a copy of the item on top of the stack, and the `pop` method ![](httpatomoreillycomsourcenostarchimages1273199.png)
    removes the top item from the stack.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循与原始代码相同的模式，但如果您之前从未使用过栈类，那么一些注释是有序的。栈类的工作方式与我们讨论过的系统栈类似，[第3章](ch03.html
    "第3章. 使用数组解决问题")；您只能在顶部添加和删除项目。请注意，我们可以使用任何没有固定大小的数据结构来执行我们的叶子计数操作。例如，我们可以使用向量，但使用栈最直接地反映了原始代码。当我们声明栈
    ![](httpatomoreillycomsourcenostarchimages1273182.png) 时，我们指定了我们将存储那里的项目类型。在这种情况下，我们将存储指向我们的
    `binaryTreeNode` 结构的指针 ![](httpatomoreillycomsourcenostarchimages1273191.png)。在这段代码中，我们使用了四个栈类方法。`push`
    方法 ![](httpatomoreillycomsourcenostarchimages1273193.png) 将一个项目（在这种情况下是一个节点指针）放置在栈的顶部。`empty`
    方法 ![](httpatomoreillycomsourcenostarchimages1273195.png) 告诉我们栈上是否还有任何项目。`top`
    方法 ![](httpatomoreillycomsourcenostarchimages1273197.png) 给我们栈顶项目的副本，而 `pop` 方法
    ![](httpatomoreillycomsourcenostarchimages1273199.png) 从栈中移除顶部项目。
- en: 'The code solves the problem by placing a pointer to the first node on the stack
    and then repeatedly removing a pointer to a node from the stack, checking whether
    it’s a leaf, incrementing our counter if it is, and placing pointers to child
    nodes, if they exist, on the stack. So the stack keeps track of the nodes we have
    discovered, but have yet to process, in the same way that the chain of recursive
    calls in the recursive version keeps track of nodes we must revisit. In comparing
    this iterative version to the recursive version, we see that none of the standard
    objections to recursion applies with much vigor in this case. First, this code
    is longer and more complicated than the recursive version, so there is no argument
    against the recursive version on the basis of conceptual complexity. Second, look
    how many function calls `stackBasedCountLeaves` makes—for each visit to an interior
    node (i.e., not a leaf), this function makes four function calls: one each to
    `empty` and `top`, and two to `push`. The recursive version makes only the two
    recursive calls for each interior node. (Note that it is possible for us to avoid
    the function calls to the stack object by incorporating the logic of the stack
    within the function. This, however, would increase the complexity of the function
    even further.) Third, while this iterative version doesn’t use additional system
    stack space, it makes explicit use of a private stack. In fairness, this is less
    space than the system stack overhead of the recursive calls, but it’s still an
    expenditure of system memory in proportion to the maximum depth of the binary
    tree we are traversing.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码通过将第一个节点的指针放置在栈上，然后反复从栈中移除节点的指针，检查它是否是叶子节点，如果是，则增加我们的计数器，如果存在子节点，则将指针放置在栈上。因此，栈跟踪我们已发现但尚未处理的节点，就像递归版本中的递归调用链跟踪我们必须重新访问的节点一样。在将这个迭代版本与递归版本进行比较时，我们看到在这种情况下，对递归的标准反对意见并没有多大的作用。首先，这段代码比递归版本更长、更复杂，因此没有理由基于概念复杂性反对递归版本。其次，看看
    `stackBasedCountLeaves` 函数调用了多少次函数——对于每次访问内部节点（即不是叶子节点），这个函数会调用四个函数：每个 `empty`
    和 `top` 各调用一次，以及两次 `push`。递归版本为每个内部节点只进行两次递归调用。（注意，我们可以通过在函数中包含栈的逻辑来避免对栈对象的函数调用。然而，这会进一步增加函数的复杂性。）第三，虽然这个迭代版本没有使用额外的系统栈空间，但它明确使用了私有栈。公平地说，这比递归调用的系统栈开销要少，但它仍然是我们正在遍历的二叉树最大深度的系统内存消耗。
- en: Because the objections against recursion are mitigated or minimized in this
    case, recursion is a good choice for the problem. Put more generally, if a problem
    is simple to solve iteratively, then iteration should be your first choice. Recursion
    should be used when iteration would be complicated. Often this involves the necessity
    of the “breadcrumb trail” mechanism shown here. Traversals of branching structures,
    such as trees and graphs, are inherently recursive. Processing linear structures,
    such as arrays and linked lists, usually does not require recursion, but there
    are exceptions. You will never go wrong making a first stab at a problem using
    iteration and seeing how far you get. As a last set of examples, consider the
    following linked-list problems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下对递归的反对意见得到了缓解或最小化，因此递归是解决该问题的好选择。更普遍地说，如果一个问题简单到可以通过迭代解决，那么迭代应该是你的首选。当迭代会变得复杂时，应该使用递归。通常这涉及到这里显示的“面包屑路径”机制的必要性。遍历分支结构，如树和图，本质上是递归的。处理线性结构，如数组和链表，通常不需要递归，但也有一些例外。使用迭代首次尝试解决问题永远不会出错。作为一个最后的例子，考虑以下链表问题。
- en: 'Problem: Display a Linked List in Order'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：以顺序显示链表
- en: Write a function that is passed the head pointer of a singly linked list where
    the data type of each node is an integer and that displays those integers, one
    per line, in the order they appear in the list.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接收单链表的头指针，其中每个节点的数据类型为整数，并按列表中出现的顺序，每行显示一个整数。
- en: 'Problem: Display a Linked List in Reverse Order'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：以逆序显示链表
- en: Write a function that is passed the head pointer of a singly linked list where
    the data type of each node is an integer and that displays those integers, one
    per line, in the reverse order they appear in the list.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接收单链表的头指针，其中每个节点的数据类型为整数，并按列表中出现的顺序，每行显示一个整数。
- en: 'Because these problems are mirror images of each other, it’s natural to assume
    that their implementations would likewise be mirror images. That is indeed the
    case for recursive implementations. Using the `listNode` and `listPtr` type given
    previously, here are recursive functions to solve both of these problems:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些问题是彼此的镜像，因此自然地假设它们的实现也会是镜像。对于递归实现来说，情况确实如此。使用之前给出的`listNode`和`listPtr`类型，以下是解决这两个问题的递归函数：
- en: '[PRE19]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the code in these functions is identical except for the order
    of the two statements inside the `if` statement. That makes all the difference.
    In the first case, we display the value in the first node ![](httpatomoreillycomsourcenostarchimages1273182.png)
    before making the recursive call to display the rest of the list ![](httpatomoreillycomsourcenostarchimages1273191.png).
    In the second case, we make the call to display the rest of the list ![](httpatomoreillycomsourcenostarchimages1273193.png)
    before we display the value in the first node ![](httpatomoreillycomsourcenostarchimages1273195.png).
    This results in an overall backward display.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些函数中的代码除了`if`语句中两个语句的顺序不同之外，都是相同的。这造成了所有区别。在第一种情况下，我们在递归调用以显示列表的其余部分之前，显示了第一个节点中的值
    ![http://atomoreilly.com/source/no_starch_images/1273182.png](http://atomoreilly.com/source/no_starch_images/1273182.png)。在第二种情况下，我们在显示第一个节点中的值之前，先调用以显示列表的其余部分
    ![http://atomoreilly.com/source/no_starch_images/1273193.png]。这导致整体显示顺序是倒序的。
- en: Because both of these functions are equally succinct, one might assume that
    recursion is properly used to solve both of these problems, but that’s not the
    case. To see that, let’s look at iterative implementations of both of these functions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个函数同样简洁，人们可能会认为递归正确地用于解决这两个问题，但实际上并非如此。为了证明这一点，让我们看看这两个函数的迭代实现。
- en: '[PRE20]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The function to display the list in order is nothing more than a straightforward
    traversal loop ![](httpatomoreillycomsourcenostarchimages1273182.png), such as
    those we saw back in [Chapter 4](ch04.html "Chapter 4. Solving Problems with Pointers
    and Dynamic Memory"). The function to display the list in reverse order, though,
    is more complicated. It suffers from the same requirement for a “breadcrumb trail”
    as our binary tree problems. Displaying the nodes in a linked list in reverse
    order requires returning to prior nodes by definition. In a singly linked list,
    there’s no way to do that using the list itself, so a second structure is required.
    In this case, we need another stack. After declaring the stack ![](httpatomoreillycomsourcenostarchimages1273191.png),
    we push all of the nodes in our linked list onto the stack using a `for` loop
    ![](httpatomoreillycomsourcenostarchimages1273193.png). Because this is a stack,
    where each item is added on top of previous items, the first item in the linked
    list will be on the bottom of the stack, and the last item in the linked list
    will be on the top. We enter a while loop that continues until the stack is empty
    ![](httpatomoreillycomsourcenostarchimages1273195.png), repeatedly grabbing a
    pointer to the top node on the stack ![](httpatomoreillycomsourcenostarchimages1273197.png),
    removing that node pointer from the stack ![](httpatomoreillycomsourcenostarchimages1273199.png),
    and then displaying the data in the referenced node ![](httpatomoreillycomsourcenostarchimages1273203.png).
    Because the data on the top is the last data in the linked list, this has the
    effect of displaying the data in the linked list in reverse order.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序显示列表的函数只是一个简单的遍历循环 ![图片](http://atomoreilly.com/source/no_starch_images/1273182.png)，就像我们在[第4章](ch04.html
    "第4章. 使用指针和动态内存解决问题")中看到的那样。然而，按反向顺序显示列表的函数更复杂。它面临着与我们的二叉树问题相同的“面包屑路径”要求。按定义，在链表中按反向顺序显示节点需要回到先前的节点。在单链表中，没有使用列表本身的方法来实现这一点，因此需要另一个结构。在这种情况下，我们需要另一个栈。在声明栈
    ![图片](http://atomoreilly.com/source/no_starch_images/1273191.png) 之后，我们使用 `for`
    循环 ![图片](http://atomoreilly.com/source/no_starch_images/1273193.png) 将链表中的所有节点推入栈中。因为这是一个栈，每个项目都是添加在先前项目之上，所以链表中的第一个项目将在栈的底部，最后一个项目将在栈的顶部。我们进入一个循环，直到栈为空
    ![图片](http://atomoreilly.com/source/no_starch_images/1273195.png)，重复获取栈顶节点的指针
    ![图片](http://atomoreilly.com/source/no_starch_images/1273197.png)，从栈中移除该节点指针 ![图片](http://atomoreilly.com/source/no_starch_images/1273199.png)，然后显示引用节点中的数据
    ![图片](http://atomoreilly.com/source/no_starch_images/1273203.png)。因为栈顶的数据是链表中的最后一个数据，这会产生按反向顺序显示链表数据的效果。
- en: As with the iterative binary tree function shown earlier, it would be possible
    to write this function without using a stack (by building a second list within
    the function that is a reverse of the original). There is no way, however, to
    make the second function as simple as the first or to avoid effectively traversing
    two structures instead of one. Comparing the recursive and iterative implementations,
    it’s easy to see that the iterative “forward” function is so simple that there
    is no practical advantage in employing recursion, and there are several practical
    disadvantages. In contrast, the recursive “backward” function is simpler than
    the iterative version and should be expected to perform approximately as well
    as the iterative version. Therefore, the “backward” function is a reasonable use
    of recursion, while the “forward” function, though a good recursive programming
    exercise, is not a good practical use of recursion.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面展示的迭代二叉树函数一样，可以不使用栈（在函数内部构建一个与原始列表相反的第二个列表）来编写这个函数。然而，无论如何也无法使第二个函数像第一个那样简单，或者避免实际上遍历两个结构而不是一个。比较递归和迭代实现，很容易看出迭代“正向”函数非常简单，使用递归实际上没有实际优势，而且存在几个实际缺点。相比之下，递归“反向”函数比迭代版本简单，应该期望其性能与迭代版本相当。因此，“反向”函数是递归的合理使用，而“正向”函数，虽然是一个好的递归编程练习，但不是递归的实用应用。
- en: Exercises
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: As always, trying out the ideas presented in the chapter is imperative!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，尝试本章中提出的思想是强制性的！
- en: Write a function to compute the sum of just the positive numbers in an array
    of integers. First, solve the problem using iteration. Then, using the technique
    shown in this chapter, convert your iterative function to a recursive function.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来计算整数数组中正数的总和。首先，使用迭代方法解决这个问题。然后，使用本章中展示的技术，将你的迭代函数转换为递归函数。
- en: 'Consider an array representing a binary string, where every element’s data
    value is 0 or 1\. Write a `bool` function to determine whether the binary string
    has odd parity (an odd number of 1 bits). Hint: Remember that the recursive function
    is going to return true (odd) or false (even), not the count of 1 bits. Solve
    the problem first using iteration, then recursion.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个表示二进制字符串的数组，其中每个元素的数据值是0或1。编写一个`bool`函数来确定二进制字符串是否具有奇校验（奇数个1位）。提示：记住递归函数将返回true（奇数）或false（偶数），而不是1位的计数。首先使用迭代解决问题，然后使用递归。
- en: Write a function that is passed an array of integers and a “target” number and
    that returns the number of occurrences of the target in the array. Solve the problem
    first using iteration, then recursion.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数接收一个整数数组和“目标”数字，并返回目标在数组中的出现次数。首先使用迭代解决问题，然后使用递归。
- en: 'Design your own: Find a problem processing a one-dimension array that you have
    already solved or that is trivial for you at your current skill level, and solve
    the problem (or solve it again) using recursion.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计自己的：找到一个你已经解决过或在你当前技能水平下很容易解决的问题，使用递归来解决该问题（或再次解决）。
- en: Solve exercise 6-1 again, using a linked list instead of an array.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用链表而不是数组解决练习6-1。
- en: Solve exercise 6-2 again, using a linked list instead of an array.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次解决练习6-2，使用链表而不是数组。
- en: Solve exercise 6-3 again, using a linked list instead of an array.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用链表而不是数组解决练习6-3。
- en: 'Design your own: Try to discover a linked-list processing problem that is difficult
    to solve using iteration but can be solved directly using recursion.'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计自己的：尝试发现一个使用迭代难以解决但可以直接使用递归解决的问题，关于链表处理。
- en: Some words in programming have more than one common meaning. In [Chapter 4](ch04.html
    "Chapter 4. Solving Problems with Pointers and Dynamic Memory"), we learned about
    the heap, from which we get memory allocated with `new`. The term *heap* also
    describes a binary tree in which each node value is higher than any in the left
    or right subtree. Write a recursive function to determine whether a binary tree
    is a heap.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程中的某些单词有不止一个常见的含义。在[第4章](ch04.html "第4章。使用指针和动态内存解决问题")中，我们学习了堆，我们从其中使用`new`分配内存。术语*堆*也描述了一种二叉树，其中每个节点的值都高于其左子树或右子树中的任何值。编写一个递归函数来确定一个二叉树是否是堆。
- en: A *binary search tree* is a binary tree in which each node value is greater
    than any value in that node’s left subtree but less than any value in the node’s
    right subtree. Write a recursive function to determine whether a binary tree is
    a binary search tree.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*二叉搜索树* 是一种二叉树，其中每个节点的值都大于该节点左子树中的任何值，但小于该节点右子树中的任何值。编写一个递归函数来确定一个二叉树是否是二叉搜索树。'
- en: 'Write a recursive function that is passed a binary search tree’s root pointer
    and a new value to be inserted and that creates a new node with the new value,
    placing it in the correct location to maintain the binary search tree structure.
    Hint: Consider making the root pointer parameter a reference parameter.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个递归函数，该函数接收一个二叉搜索树的根指针和一个要插入的新值，并创建一个具有新值的新节点，将其放置在正确的位置以保持二叉搜索树的结构。提示：考虑将根指针参数作为引用参数。
- en: 'Design your own: Consider basic statistical questions you can ask of a set
    of numerical values, such as average, median, mode, and so forth. Attempt to write
    recursive functions to compute those statistics for a binary tree of integers.
    Some are easier to write than others. Why?'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计自己的：考虑你可以对一组数值提出的基本统计问题，例如平均值、中位数、众数等。尝试编写递归函数来计算整数的二叉树中的这些统计数据。有些比其他更容易编写。为什么？
