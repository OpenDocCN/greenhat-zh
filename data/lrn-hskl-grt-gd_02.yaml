- en: Chapter 2. Believe the Type
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：相信类型
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802524.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802524.png.jpg)'
- en: One of Haskell’s greatest strengths is its powerful type system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 最强大的优点之一是其强大的类型系统。
- en: In Haskell, every expression’s type is known at compile time, which leads to
    safer code. If you write a program that tries to divide a Boolean type with a
    number, it won’t compile. This is good because it’s better to catch those kinds
    of errors at compile time, rather than having your program crash later on. Everything
    in Haskell has a type, so the compiler can reason quite a lot about your program
    before compiling it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，每个表达式的类型在编译时都是已知的，这导致代码更安全。如果你编写了一个尝试用数字除以布尔类型的程序，它将无法编译。这是好事，因为最好在编译时捕获这些错误，而不是让程序在以后崩溃。Haskell
    中的每样东西都有类型，所以编译器可以在编译程序之前对程序进行大量的推理。
- en: Unlike Java or Pascal, Haskell has type inference. If we write a number, for
    example, we don’t need to tell Haskell it’s a number, because it can infer that
    on its own.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 或 Pascal 不同，Haskell 具有类型推断功能。例如，如果我们写一个数字，我们不需要告诉 Haskell 它是一个数字，因为它可以自己推断出来。
- en: So far, we’ve covered some of the basics of Haskell with only a very superficial
    glance at types, but understanding the type system is a very important part of
    learning Haskell.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只对 Haskell 的类型进行了非常表面的了解，但理解类型系统是学习 Haskell 的一个非常重要的部分。
- en: Explicit Type Declaration
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类型声明
- en: 'We can use GHCi to examine the types of some expressions. We’ll do that by
    using the `:t` command which, followed by any valid expression, tells us its type.
    Let’s give it a whirl:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 GHCi 来检查一些表达式的类型。我们将通过使用 `:t` 命令来实现，该命令后面跟任何有效表达式，会告诉我们它的类型。让我们试一试：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `::` operator here is read as “has type of.” Explicit types are always denoted
    with the first letter in uppercase. `'a'` has a type of `Char`, which stands for
    *character*. `True` is a `Bool`, or a Boolean type. `"HELLO!"`, which is a string,
    shows its type as `[Char]`. The square brackets denote a list, so we read that
    as it being a list of characters. Unlike lists, each tuple length has its own
    type. So the tuple `(True, 'a')` has a type of `(Bool, Char)`, and `('a','b','c')`
    has a type of `(Char, Char, Char)`. `4 == 5` will always return `False`, so its
    type is `Bool`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `::` 操作符读作“类型为”。显式类型总是用首字母大写来表示。`'a'` 的类型是 `Char`，代表*字符*。`True` 是 `Bool`
    类型，或布尔类型。字符串 `"HELLO!"` 显示其类型为 `[Char]`。方括号表示列表，所以我们将其读作字符列表。与列表不同，每个元组的长度都有自己的类型。因此，元组
    `(True, 'a')` 的类型是 `(Bool, Char)`，而 `('a','b','c')` 的类型是 `(Char, Char, Char)`。`4
    == 5` 总是返回 `False`，所以它的类型是 `Bool`。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802526.png.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802526.png.jpg)'
- en: Functions also have types. When writing our own functions, we can choose to
    give them an explicit type declaration. This is generally considered to be good
    practice (except when writing very short functions). From here on, we’ll give
    all the functions that we make type declarations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也有类型。当我们编写自己的函数时，我们可以选择给它们一个显式的类型声明。这通常被认为是一种良好的实践（除非编写非常简短的功能）。从现在开始，我们将对所有我们进行类型声明的函数进行类型声明。
- en: 'Remember the list comprehension we made in [Chapter 1](ch01.html "Chapter 1. Starting
    Out")—the one that filters out a string’s lowercase letters? Here’s how it looks
    with a type declaration:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第一章[“开始”](ch01.html "第一章. 开始")中制作的列表推导？那个过滤掉字符串小写字母的？这是带有类型声明的样子：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `removeNonUppercase` function has a type of `[Char] -> [Char]`, meaning
    that it takes one string as a parameter and returns another as a result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNonUppercase` 函数的类型是 `[Char] -> [Char]`，这意味着它接受一个字符串作为参数并返回另一个字符串。'
- en: 'But how do we specify the type of a function that takes several parameters?
    Here’s a simple function that takes three integers and adds them together:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何指定一个接受多个参数的函数的类型呢？这里有一个简单的函数，它接受三个整数并将它们相加：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parameters and the return type are separated by `->` characters, with the
    return type always coming last in the declaration. (In [Chapter 5](ch05.html "Chapter 5. Higher-Order
    Functions"), you’ll see why they’re all separated with `->`, instead of having
    a more explicit distinction.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和返回类型由 `->` 字符分隔，返回类型总是在声明中最后出现。（在第五章[“高阶函数”](ch05.html "第五章. 高阶函数")中，你会看到为什么它们都用
    `->` 分隔，而不是有更明确的区分。）
- en: If you want to give your function a type declaration, but are unsure as to what
    it should be, you can always just write the function without it, and then check
    it with `:t`. Since functions are expressions, `:t` works on them in the same
    way as you saw at the beginning of this section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想给你的函数一个类型声明，但又不确定应该是什么，你总是可以只写不带声明的函数，然后用 `:t` 来检查它。由于函数是表达式，`:t` 对它们的作用方式与你在本节开头看到的方式相同。
- en: Common Haskell Types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的 Haskell 类型
- en: 'Let’s take a look at some common Haskell types, which are used for representing
    basic things like numbers, characters, and Boolean values. Here’s an overview:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些常见的 Haskell 类型，它们用于表示基本事物，如数字、字符和布尔值。以下是一个概述：
- en: '`Int` stands for integer. It’s used for whole numbers. `7` can be an `Int`,
    but `7.2` cannot. `Int` is *bounded*, which means that it has a minimum value
    and a maximum value.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int` 代表整数。它用于表示整数。`7` 可以是一个 `Int`，但 `7.2` 不能。`Int` 是 *有界* 的，这意味着它有一个最小值和一个最大值。'
- en: Note
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We’re using the GHC compiler, where the range of `Int` is determined by the
    size of a machine word on your computer. So if you have a 64-bit CPU, it’s likely
    that the lowest `Int` on your system is -2^(63), and the highest is 2^(63).
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用的是 GHC 编译器，其中 `Int` 的范围由你电脑上机器字的大小决定。所以如果你有一个 64 位 CPU，你的系统上最低的 `Int` 很可能是
    -2^(63)，最高的是 2^(63)。
- en: '`Integer` is also used to store integers, but it’s not bounded, so it can be
    used to represent really big numbers. (And I mean *really* big!) However, `Int`
    is more efficient. As an example, try saving the following function to a file:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Integer` 也用于存储整数，但它没有界限，因此可以用来表示非常大的数字。（我指的是 *真的* 很大！）然而，`Int` 更高效。例如，尝试将以下函数保存到文件中：'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then load it into GHCi with `:l` and test it:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，使用 `:l` 将其加载到 GHCi 中并测试它：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Float` is a real floating-point number with single precision. Add the following
    function to the file you’ve been working in:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float` 是一个单精度浮点数。将以下函数添加到你正在工作的文件中：'
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then load and test it:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，加载并测试它：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Double` is a real floating-point number with double the precision. Double-precision
    numeric types use twice as many bits to represent numbers. The extra bits increase
    their precision at the cost of hogging more memory. Here’s another function to
    add to your file:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Double` 是一个双精度浮点数，精度是单精度的两倍。双精度数值类型使用两倍的位来表示数字。额外的位增加了它们的精度，但同时也占用更多的内存。这里还有一个可以添加到你的文件中的函数：'
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now load and test it. Pay particular attention to the difference in precision
    between `circumference` and `circumference'`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在加载并测试它。特别注意 `circumference` 和 `circumference'` 之间的精度差异。
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Bool` is a Boolean type. It can have only two values: `True` and `False`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool` 是一个布尔类型。它只能有两个值：`True` 和 `False`。'
- en: '`Char` represents a Unicode character. It’s denoted by single quotes. A list
    of characters is a string.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Char` 表示一个 Unicode 字符。它用单引号表示。字符的列表是一个字符串。'
- en: 'Tuples are types, but their definition depends on their length as well as the
    types of their components. So, theoretically, there is an infinite number of tuple
    types. (In practice, tuples can have at most 62 elements—far more than you’ll
    ever need.) Note that the empty tuple `()` is also a type, which can have only
    a single value: `()`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组是类型，但它们的定义也取决于它们的长度以及组件的类型。因此，从理论上讲，存在无限多的元组类型。（在实践中，元组最多可以有 62 个元素——远远超过你需要的。）注意，空元组
    `()` 也是一个类型，它只能有一个值：`()`。
- en: Type Variables
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型变量
- en: It makes sense for some functions to be able to operate on various types. For
    instance, the `head` function takes a list and returns the head element of that
    list. It doesn’t really matter if the list contains numbers, characters, or even
    more lists! The function should be able to work with lists that contain just about
    anything.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些函数能够在各种类型上操作是有意义的。例如，`head` 函数接受一个列表并返回该列表的头部元素。列表中包含的是数字、字符，甚至是更复杂的列表，这并不重要！该函数应该能够处理包含几乎所有内容的列表。
- en: 'What do you think the type of the `head` function is? Let’s check with the
    `:t` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为 `head` 函数的类型是什么？让我们用 `:t` 函数来检查：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What is this `a`? Remember that type names start with capital letters, so it
    can’t be a type. This is actually an example of a *type variable*, which means
    that `a` can be of any type.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这 `a` 是什么？记住类型名称以大写字母开头，所以它不能是一个类型。这实际上是一个 *类型变量* 的例子，这意味着 `a` 可以是任何类型。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802528.png.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802528.png.jpg)'
- en: Type variables allow functions to operate on values of various types in a type-safe
    manner. This is a lot like *generics* in other programming languages. However,
    Haskell’s version is much more powerful, since it allows us to easily write very
    general functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类型变量允许函数以类型安全的方式在多种类型的值上操作。这与其他编程语言中的*泛型*非常相似。然而，Haskell 的版本要强大得多，因为它允许我们轻松地编写非常通用的函数。
- en: Functions that use type variables are called *polymorphic functions*. The type
    declaration of `head` states that it takes a list of any type and returns one
    element of that type.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型变量的函数被称为*多态函数*。`head` 的类型声明表明它接受任何类型的列表并返回该类型的一个元素。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although type variables can have names that are longer than one character, we
    usually give them names like `a`, `b`, `c`, `d`, and so on.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型变量可以有超过一个字符的名称，但我们通常给它们取名为 `a`、`b`、`c`、`d` 等等。
- en: 'Remember `fst`? It returns the first item in a pair. Let’s examine its type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 `fst` 吗？它返回一个配对中的第一个元素。让我们检查它的类型：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see that `fst` takes a tuple and returns an element that is of the same
    type as its first item. That’s why we can use `fst` on a pair that contains items
    of any two types. Note that even though `a` and `b` are different type variables,
    they don’t necessarily need to be different types. This just means that the first
    item’s type and the return value’s type will be the same.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `fst` 接受一个元组并返回一个与第一个元素相同类型的元素。这就是为什么我们可以在包含任何两种类型元素的配对上使用 `fst`。注意，尽管
    `a` 和 `b` 是不同的类型变量，它们不一定是不同类型。这仅仅意味着第一个元素的类型和返回值的类型将是相同的。
- en: Type Classes 101
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型类 101
- en: A *type class* is an interface that defines some behavior. If a type is an *instance*
    of a type class, then it supports and implements the behavior the type class describes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型类*是一个定义某些行为的接口。如果一个类型是类型类的*实例*，那么它支持并实现了类型类所描述的行为。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802530.png.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802530.png.jpg)'
- en: More specifically, a type class specifies a bunch of functions, and when we
    decide to make a type an instance of a type class, we define what those functions
    mean for that type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，类型类指定了一组函数，当我们决定将一个类型作为类型类的实例时，我们定义了这些函数对该类型的意义。
- en: 'A type class that defines equality is a good example. The values of many types
    can be compared for equality by using the `==` operator. Let’s check the type
    signature of this operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定义相等的类型类是一个很好的例子。许多类型的值可以通过使用 `==` 运算符进行比较。让我们检查这个运算符的类型签名：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the equality operator (`==`) is actually a function. So are `+`, `*`,
    `-`, `/`, and almost every other operator. If a function is composed of only special
    characters, it’s considered an infix function by default. If we want to examine
    its type, pass it to another function, or call it as a prefix function, we need
    to surround it in parentheses, as in the preceding example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，等号运算符（`==`）实际上是一个函数。同样，`+`、`*`、`-`、`/`以及几乎所有的其他运算符也都是函数。如果一个函数仅由特殊字符组成，它默认被视为中缀函数。如果我们想检查其类型、传递给另一个函数或将其作为前缀函数调用，我们需要将其括号包围，就像前面的例子一样。
- en: 'This example shows something new: the `=>` symbol. Everything before this symbol
    is called a *class constraint*. We can read this type declaration like this: The
    equality function takes any two values that are of the same type and returns a
    `Bool`. The type of those two values must be an instance of the `Eq` class.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了新内容：`=>` 符号。这个符号之前的一切被称为*类约束*。我们可以这样阅读这个类型声明：等式函数接受任何两个相同类型的值并返回一个 `Bool`。这两个值的类型必须是
    `Eq` 类的实例。
- en: The `Eq` type class provides an interface for testing for equality. If it makes
    sense for two items of a particular type to be compared for equality, then that
    type can be an instance of the `Eq` type class. All standard Haskell types (except
    for input/output types and functions) are instances of `Eq`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Eq` 类型类提供了一个用于测试相等的接口。如果对特定类型的两个项目进行比较相等是有意义的，那么该类型可以是 `Eq` 类型类的实例。所有标准的 Haskell
    类型（除了输入/输出类型和函数）都是 `Eq` 的实例。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that type classes are *not* the same as classes in object-oriented
    programming languages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，类型类与面向对象编程语言中的类并不相同。
- en: Let’s look at some of the most common Haskell type classes, which enable our
    types to be easily compared for equality and order, printed as strings, and so
    on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些最常见的 Haskell 类型类，它们使我们的类型可以轻松地进行相等性和顺序比较，作为字符串打印等。
- en: The Eq Type Class
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eq 类型类
- en: 'As we’ve discussed, `Eq` is used for types that support equality testing. The
    functions its instances implement are `==` and `/=`. This means that if there’s
    an `Eq` class constraint for a type variable in a function, it uses `==` or `/=`
    somewhere inside its definition. When a type implements a function, that means
    it defines what the function does when used with that particular type. Here are
    some examples of performing these operations on various instances of `Eq`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，`Eq` 用于支持等性测试的类型。它的实例实现的函数是 `==` 和 `/=`。这意味着如果函数中对类型变量有 `Eq` 类约束，它会在定义的某个地方使用
    `==` 或 `/=`。当一个类型实现一个函数时，这意味着它定义了当使用该特定类型时函数的行为。以下是一些在 `Eq` 的各种实例上执行这些操作的例子：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Ord Type Class
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Ord` 类型类'
- en: '`Ord` is a type class for types whose values can be put in some order. For
    example, let’s look at the type of the greater-than (`>`) operator:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ord` 是一个类型类，其值可以按某种顺序排列。例如，让我们看看大于 (`>`) 操作符的类型：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The type of `>` is similar to the type of `==`. It takes two items as parameters
    and returns a `Bool`, which tells us if some relation between those two things
    holds or not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 类型与 `==` 类型的用法相似。它接受两个参数并返回一个 `Bool`，告诉我们这两个事物之间是否存在某种关系。'
- en: All the types we’ve covered so far (again, except for functions) are instances
    of `Ord`. `Ord` covers all the standard comparison functions such as `>`, `<`,
    `>=`, and `<=`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所讨论的所有类型（再次强调，除了函数）都是 `Ord` 类型的实例。`Ord` 包含了所有标准比较函数，如 `>`, `<`, `>=`
    和 `<=`。
- en: The `compare` function takes two values whose type is an `Ord` instance and
    returns an `Ordering`. `Ordering` is a type that can be `GT`, `LT`, or `EQ`, which
    represent greater than, lesser than, or equal, respectively.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare` 函数接受两个类型为 `Ord` 实例的值，并返回一个 `Ordering`。`Ordering` 是一个类型，可以是 `GT`、`LT`
    或 `EQ`，分别代表大于、小于或等于。'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Show Type Class
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Show` 类型类'
- en: 'Values whose types are instances of the `Show` type class can be represented
    as strings. All the types we’ve covered so far (except for functions) are instances
    of `Show`. The most commonly used function that operates on instances of this
    type class is `show`, which prints the given value as a string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 `Show` 类型类实例的值可以表示为字符串。我们到目前为止所讨论的所有类型（除了函数）都是 `Show` 类型的实例。在这个类型类上操作的最常用的函数是
    `show`，它将给定的值打印为字符串：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Read Type Class
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Read` 类型类'
- en: '`Read` can be considered the opposite type class of `Show`. Again, all the
    types we’ve covered so far are instances of this type class. The `read` function
    takes a string and returns a value whose type is an instance of `Read`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read` 可以被认为是 `Show` 类型类的对立面。同样，我们到目前为止所讨论的所有类型都是 `Read` 类型的实例。`read` 函数接受一个字符串并返回一个类型为
    `Read` 实例的值：'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far so good. But what happens if we try entering `read "4"`?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。但如果我们尝试输入 `read "4"` 会发生什么呢？
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'GHCi is telling us that it doesn’t know what we want in return. Notice that
    in the previous uses of `read`, we did something with the result afterward, which
    let GHCi infer the kind of result we wanted. If we used it as a Boolean, for example,
    it knew it had to return a `Bool`. But now it knows we want some type that is
    part of the `Read` class, but it doesn’t know which one. Let’s take a look at
    the type signature of `read`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GHCi 告诉我们它不知道我们想要什么返回值。注意，在之前的 `read` 使用中，我们之后对结果做了些处理，这使得 GHCi 能够推断出我们想要的返回类型。如果我们将其用作布尔值，例如，它知道它必须返回一个
    `Bool`。但现在它知道我们想要的是 `Read` 类型的某个类型，但它不知道具体是哪一个。让我们看看 `read` 的类型签名：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`String` is just another name for `[Char]`. `String` and `[Char]` can be used
    interchangeably, but we’ll mostly be sticking to `String` from now on because
    it’s easier to write and more readable.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 只是 `[Char]` 的另一个名称。`String` 和 `[Char]` 可以互换使用，但我们将主要坚持使用 `String`，因为它更容易编写且更易读。'
- en: We can see that the `read` function returns a value whose type is an instance
    of `Read`, but if we use that result in some way, it has no way of knowing which
    type. To solve this problem, we can use *type annotations*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `read` 函数返回的值的类型是 `Read` 的实例，但如果以某种方式使用这个结果，它没有方法知道具体是哪种类型。为了解决这个问题，我们可以使用
    *类型注解*。
- en: 'Type annotations are a way to explicitly tell Haskell what the type of an expression
    should be. We do this by adding `::` to the end of the expression and then specifying
    a type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解是明确告诉 Haskell 表达式类型的一种方式。我们通过在表达式的末尾添加 `::` 并指定一个类型来实现这一点：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The compiler can infer the type of most expressions by itself. However, sometimes
    the compiler doesn’t know whether to return a value of type `Int` or `Float` for
    an expression like `read "5"`. To see what the type is, Haskell would need to
    actually evaluate `read "5"`. But since Haskell is a statically typed language,
    it needs to know all the types before the code is compiled (or in the case of
    GHCi, evaluated). So we need to tell Haskell, “Hey, this expression should have
    this type, in case you didn’t know!”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以自己推断大多数表达式的类型。然而，有时编译器不知道对于像 `read "5"` 这样的表达式应该返回 `Int` 类型的值还是 `Float`
    类型的值。为了查看类型，Haskell 需要实际评估 `read "5"`。但由于 Haskell 是静态类型语言，它需要在代码编译（或在 GHCi 的情况下评估）之前知道所有类型。因此，我们需要告诉
    Haskell，“嘿，这个表达式应该有这种类型，以防你不知道！”
- en: 'We can give Haskell only the minimum amount of information it needs to figure
    out which type of value `read` should return. For instance, if we’re using `read`
    and then cramming its result into a list, Haskell can use the list to figure out
    which type we want by looking at the other elements of the list:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只给 Haskell 提供它需要的最少信息，以确定 `read` 应该返回哪种类型的值。例如，如果我们使用 `read` 并将其结果塞入列表中，Haskell
    可以通过查看列表中的其他元素来确定我们想要的类型：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Since we used `read "True"` as an element in a list of `Bool` values, Haskell
    sees that the type of `read "True"` must also be `Bool`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 `read "True"` 作为 `Bool` 值列表中的一个元素使用，Haskell 看到这一点，`read "True"` 的类型也必须是
    `Bool`。
- en: The Enum Type Class
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举类型类
- en: '`Enum` instances are sequentially ordered types—their values can be enumerated.
    The main advantage of the `Enum` type class is that we can use its values in list
    ranges. They also have defined successors and predecessors, which we can get with
    the `succ` and `pred` functions. Some examples of types in this class are `()`,
    `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float`, and `Double`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum` 实例是顺序排列的类型——它们的值可以被枚举。`Enum` 类型类的主要优点是我们可以在列表范围内使用它的值。它们还有定义好的后继和前驱，我们可以通过
    `succ` 和 `pred` 函数来获取。这个类中的类型示例包括 `()`、`Bool`、`Char`、`Ordering`、`Int`、`Integer`、`Float`
    和 `Double`。'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Bounded Type Class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有界类型类
- en: 'Instances of the `Bounded` type class have an upper bound and a lower bound,
    which can be checked by using the `minBound` and `maxBound` functions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bounded` 类型类的实例有一个上界和一个下界，可以通过使用 `minBound` 和 `maxBound` 函数来检查：'
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `minBound` and `maxBound` functions are interesting because they have a
    type of `(Bounded a) => a`. In a sense, they are polymorphic constants.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`minBound` 和 `maxBound` 函数很有趣，因为它们有一个类型 `(Bounded a) => a`。在某种意义上，它们是多态常量。'
- en: 'Note that tuples whose components are all instances of `Bounded` are also considered
    to be instances of `Bounded` themselves:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有组件都是 `Bounded` 实例的元组也被认为是 `Bounded` 的实例：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Num Type Class
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型类
- en: '`Num` is a numeric type class. Its instances can act like numbers. Let’s examine
    the type of a number:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Num` 是一个数值类型类。它的实例可以像数字一样行动。让我们检查一个数字的类型：'
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It appears that whole numbers are also polymorphic constants. They can act
    like any type that’s an instance of the `Num` type class (`Int`, `Integer`, `Float`,
    or `Double`):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来整数也是多态常量。它们可以像 `Num` 类型类的任何实例（`Int`、`Integer`、`Float` 或 `Double`）一样行动：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example, we can examine the type of the `*` operator:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以检查 `*` 操作符的类型：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This shows that `*` accepts two numbers and returns a number of the same type.
    Because of this type constraint, `(5 :: Int) * (6 :: Integer)` will result in
    a type error, while `5 * (6 :: Integer)` will work just fine. `5` can act like
    either an `Integer` or an `Int`, but not both at the same time.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '这表明 `*` 接受两个数字并返回相同类型的数字。由于这种类型约束，`(5 :: Int) * (6 :: Integer)` 将导致类型错误，而 `5
    * (6 :: Integer)` 将正常工作。`5` 可以像 `Integer` 或 `Int` 一样行动，但不能同时两者都是。'
- en: To be an instance of `Num`, a type must already be in `Show` and `Eq`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为 `Num` 的实例，一个类型必须已经存在于 `Show` 和 `Eq` 中。
- en: The Floating Type Class
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点类型类
- en: The `Floating` type class includes the `Float` and `Double` types, which are
    used to store floating-point numbers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Floating` 类型类包括 `Float` 和 `Double` 类型，它们用于存储浮点数。'
- en: Functions that take and return values that are instances of the `Floating` type
    class need their results to be represented with floating-point numbers in order
    to do meaningful computations. Some examples are `sin`, `cos`, and `sqrt`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用浮点数来表示结果的 `Floating` 类型类的值实例的函数需要进行有意义的计算。一些例子是 `sin`、`cos` 和 `sqrt`。
- en: The Integral Type Class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数类型类
- en: '`Integral` is another numeric type class. While `Num` includes all numbers,
    including real number integers, the `Integral` class includes *only* integral
    (whole) numbers. This type class includes the `Int` and `Integer` types.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Integral` 是另一个数值类型类。虽然 `Num` 包括所有数字，包括实数整数，但 `Integral` 类只包括*仅*整数（整体数）。这个类型类包括
    `Int` 和 `Integer` 类型。'
- en: 'One particularly useful function for dealing with numbers is `fromIntegral`.
    It has the following type declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数字的一个特别有用的函数是 `fromIntegral`。它有以下类型声明：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that `fromIntegral` has several class constraints in its type signature.
    That’s completely valid—multiple class constraints are separated by commas inside
    the parentheses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `fromIntegral` 在其类型签名中有几个类约束。这是完全有效的——多个类约束在括号内由逗号分隔。
- en: 'From its type signature, we can see that `fromIntegral` takes an integral number
    and turns it into a more general number. This is very useful when you want integral
    and floating-point types to work together nicely. For instance, the `length` function
    has this type declaration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从其类型签名中，我们可以看到 `fromIntegral` 接收一个整数并将其转换为更通用的数字。当你想使整数和浮点数类型很好地协同工作时，这非常有用。例如，`length`
    函数有如下类型声明：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means that if we try to get the length of a list and add it to `3.2`,
    we’ll get an error (because we tried to add an `Int` to a floating-point number).
    To get around this, we can use `fromIntegral`, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们尝试获取列表的长度并将其加到 `3.2` 上，我们会得到一个错误（因为我们尝试将一个 `Int` 加到一个浮点数上）。为了解决这个问题，我们可以使用
    `fromIntegral`，如下所示：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Some Final Notes on Type Classes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于类型类的几点注意事项
- en: Because a type class defines an abstract interface, one type can be an instance
    of many type classes, and one type class can have many types as instances. For
    example, the `Char` type is an instance of many type classes, two of them being
    `Eq` and `Ord`, because we can check if two characters are equal as well as compare
    them in alphabetical order.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为类型类定义了一个抽象接口，一个类型可以成为多个类型类的实例，一个类型类也可以有多个类型作为其实例。例如，`Char` 类型是多个类型类的实例，其中两个是
    `Eq` 和 `Ord`，因为我们可以检查两个字符是否相等，也可以按字母顺序比较它们。
- en: Sometimes a type must first be an instance of one type class to be allowed to
    become an instance of another. For example, to be an instance of `Ord`, a type
    must first be an instance of `Eq`. In other words, being an instance of `Eq` is
    a *prerequisite* for being an instance of `Ord`. This makes sense if you think
    about it, because if you can compare two things for ordering, you should also
    be able to tell if those things are equal.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个类型必须首先成为某个类型类的实例，才能允许它成为另一个类型类的实例。例如，要成为 `Ord` 的实例，一个类型必须首先成为 `Eq` 的实例。换句话说，成为
    `Eq` 的实例是成为 `Ord` 实例的*先决条件*。如果你这样想，这是有道理的，因为如果你可以比较两个事物进行排序，你也应该能够判断这些事物是否相等。
