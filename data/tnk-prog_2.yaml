- en: Chapter 2. Pure Puzzles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 纯粹的谜题
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1273151.png.jpg)'
- en: In this chapter, we’ll start dealing with actual code. While intermediate programming
    knowledge will be needed for later chapters, the programming skills required in
    this chapter are as simple as can be. That doesn’t mean that all of these puzzles
    will be easy, only that you should be able to focus on the problem solving and
    not the programming syntax. This is problem solving at its purest. Once you figure
    out what you want to do, translating your thoughts into C++ code will be straightforward.
    Remember that reading this book, in itself, provides limited benefit. You should
    work through any problem that appears nontrivial to you as we discuss it, trying
    to solve it yourself before reading about my approach. At the end of the chapter,
    try some of the exercises, many of which will be extensions of the problems we
    discuss.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始处理实际的代码。虽然中级编程知识将在后面的章节中需要，但本章所需的编程技能尽可能简单。这并不意味着所有这些谜题都会很容易，只是说你应该能够专注于问题解决，而不是编程语法。这是最纯粹的问题解决。一旦你弄清楚自己想要做什么，将你的想法转化为
    C++ 代码将会很直接。记住，仅仅阅读这本书本身提供的益处是有限的。你应该在我们讨论时，尝试解决任何对你来说非平凡的问题，尝试在阅读我的方法之前自己解决。在本章结束时，尝试一些练习，其中许多将是我们在讨论中讨论的问题的扩展。
- en: Review of C++ Used in This Chapter
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章节中使用的 C++ 代码回顾
- en: This chapter uses the basic C++ with which you should already be familiar, including
    the control statements `if`, `for`, `while` and `do-while`, and `switch`. You
    may not yet be comfortable writing code to solve original problems with these
    statements—that’s what this book is about, after all. You should, however, understand
    the syntax of how these statements are written or have a good C++ reference handy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的是你应已熟悉的 C++ 基础，包括控制语句 `if`、`for`、`while` 和 `do-while`，以及 `switch`。你可能还不习惯用这些语句编写代码来解决原创问题——毕竟，这正是本书的主题。然而，你应该理解这些语句的语法，或者手头有一本好的
    C++ 参考书。
- en: 'You should also know how to write and call functions. To keep things simple,
    we’ll use the standard streams `cin` and `cout` for input and output. To use these
    streams, include the necessary header file, `iostream`, in your code, and add
    `using` statements for the two standard stream objects:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该知道如何编写和调用函数。为了保持简单，我们将使用标准流 `cin` 和 `cout` 进行输入和输出。要使用这些流，在你的代码中包含必要的头文件
    `iostream`，并为两个标准流对象添加 `using` 语句：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For brevity, these statements won’t be shown in the code listings. Their inclusion
    is assumed in any program that uses them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，这些语句将不会在代码列表中展示。它们的存在被假定为任何使用它们的程序中。
- en: Output Patterns
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出模式
- en: In this chapter, we will work through three main problems. Because we’ll be
    making extensive use of the problem division and reduction techniques, each of
    these main problems will spawn several subproblems. In this first section, let’s
    try a series of programs that produce patterned output in a regular shape. Programs
    like these develop loop-writing skills.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决三个主要问题。由于我们将广泛使用问题分解和缩减技术，每个主要问题都将产生几个子问题。在这个第一部分，让我们尝试一系列产生规则形状图案输出的程序。这样的程序可以培养编写循环的技能。
- en: 'Problem: Half of a square'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：正方形的一半
- en: 'Write a program that uses only two output statements, `cout << "#"` and `cout
    << "\n"`, to produce a pattern of hash symbols shaped like half of a perfect 5
    × 5 square (or a right triangle):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，只使用两个输出语句 `cout << "#"` 和 `cout << "\n"`，以产生一个类似完美 5 × 5 正方形（或直角三角形）的哈希符号图案：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here’s another great example of the importance of constraints. If we ignore
    the requirement that we can use only two output statements, one that produces
    a single hash symbol and one that produces an end-of-line, we can write a Kobayashi
    Maru and solve this problem trivially. With that constraint in place, however,
    we’ll have to use loops to solve this problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是约束重要性的一个很好的例子。如果我们忽略只能使用两个输出语句的要求，一个产生单个哈希符号，另一个产生行尾，我们可以写一个 Kobayashi Maru
    并轻易解决这个问题。然而，有了这个约束，我们就必须使用循环来解决这个问题。
- en: You may already see the solution in your head, but let’s assume that you don’t.
    A good first weapon is reduction. How can we reduce this problem to a point where
    it’s easy to solve? What if the pattern was a whole square instead of half of
    a square?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在脑海中看到了解决方案，但让我们假设你没有。一种好的武器是简化。我们如何将这个问题简化到容易解决的程度？如果模式是一个完整的正方形而不是正方形的一半呢？
- en: 'Problem: A square (half of a square reduction)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：一个正方形（正方形的一半简化）
- en: 'Write a program that uses only two output statements, `cout << "#"` and `cout
    << "\n"`, to produce a pattern of hash symbols shaped like a perfect 5x5 square:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用仅两个输出语句 `cout << "#"` 和 `cout << "\n"` 来生成一个形状为完美 5x5 正方形的井号符号图案：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This may be enough to get us going, but suppose we didn’t know how to tackle
    this either. We could reduce the problem further, making a single line of hash
    symbols instead of the square.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能足以让我们开始，但假设我们也不知道如何解决这个问题。我们可以进一步简化问题，只制作一条井号符号的行而不是正方形。
- en: 'Problem: A line (half of a square further reduction)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：一条线（正方形的一半进一步简化）
- en: 'Write a program that uses only two output statements, `cout << "#"` and `cout
    << "\n"`, to produce a line of five hash symbols:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用仅两个输出语句 `cout << "#"` 和 `cout << "\n"` 来生成一行五个井号符号：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have a trivial problem that can be solved with a `for` loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以用 `for` 循环解决的问题：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From here, return to the previous reduction, the full square shape. The full
    square is simply five repetitions of the line of five hash symbols. We know how
    to make repeating code; we just write a loop. So we can turn our single loop into
    a double loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，返回到之前的全平方形状。全平方只是五次重复的五条井号符号的行。我们知道如何编写重复的代码；我们只需写一个循环。因此，我们可以将我们的单循环转换为双循环：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ve placed all of the code from the previous listing in a new loop so that
    it repeats five times, producing five rows, each row a line of five hash symbols.
    We’re getting closer to the ultimate solution. How do we modify the code so that
    it produces the half-square pattern? If we look at the last listing and compare
    it to our desired half-square output, we can see that the problem is in the conditional
    expression `hashNum <= 5`. This conditional produces the same line of five hash
    symbols on each row. What we require is a mechanism to adjust the number of symbols
    produced on each row so that the first row gets five symbols, the second row gets
    four, and so on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前列表中的所有代码放入一个新的循环中，以便它重复五次，产生五行，每行是五条井号符号。我们越来越接近最终解决方案。我们如何修改代码，使其产生半平方图案？如果我们查看最后的列表并将其与我们的所需半平方输出进行比较，我们可以看到问题在于条件表达式
    `hashNum <= 5`。这个条件在每个行上产生相同的五条井号符号的行。我们需要的是一个机制来调整每行产生的符号数量，以便第一行得到五个符号，第二行得到四个，以此类推。
- en: To see how to do this, let’s make another reduced program experiment. Again,
    it’s always easiest to work on the troublesome part of a problem in isolation.
    For a moment, let’s forget about hash symbols and just talk about numbers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何做到这一点，让我们进行另一个简化程序实验。同样，总是最容易单独处理问题的麻烦部分。让我们暂时忘记井号符号，只谈论数字。
- en: 'Problem: Count down by counting up'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：通过计数向上计数向下
- en: Write a line of code that goes in the designated position in the loop in the
    listing below. The program displays the numbers 5 through 1, in that order, with
    each number on a separate line.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，编写一行代码放入循环指定的位置。程序按顺序显示数字 5 到 1，每个数字占一行。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We must find an *`expression`* ![](httpatomoreillycomsourcenostarchimages1273182.png)
    that is 5 when `row` is 1, 4 when `row` is 2, and so on. If we want an expression
    that decreases as `row` increases, our first thought might be to stick a minus
    sign in front of the values of `row` by multiplying `row` by −1\. This produces
    numbers that go down, but not the desired numbers. We may be closer than we think,
    though. What’s the difference between the desired value and the value given by
    multiplying `row` by −1? [Table 2-1](ch02.html#computation_of_desired_value_from_row_va
    "Table 2-1. Computation of Desired Value from Row Variable") summarizes this analysis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须找到一个**`表达式`** ![http://atomoreilly.com/source/no_starch_images/1273182.png]，当
    `row` 为 1 时为 5，当 `row` 为 2 时为 4，以此类推。如果我们想要一个随着 `row` 增加而减少的表达式，我们首先可能会想到在 `row`
    的值前加上一个负号，通过将 `row` 乘以 -1 来实现。这会产生递减的数字，但不是我们想要的数字。尽管如此，我们可能比我们想象的更接近。所需值与将 `row`
    乘以 -1 得到的值之间的差异是什么？[表 2-1](ch02.html#computation_of_desired_value_from_row_va
    "表 2-1. 从行变量计算所需值") 总结了这一分析。
- en: Table 2-1. Computation of Desired Value from Row Variable
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1. 从行变量计算所需值
- en: '| Row | Desired Value | Row * −1 | Difference from Desired Value |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 行 | 所需值 | 行 * −1 | 与所需值的差异 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1 | 5 | −1 | 6 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 5 | −1 | 6 |'
- en: '| 2 | 4 | −2 | 6 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | −2 | 6 |'
- en: '| 3 | 3 | −3 | 6 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 3 | −3 | 6 |'
- en: '| 4 | 2 | −4 | 6 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 | −4 | 6 |'
- en: '| 5 | 1 | −5 | 6 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 1 | −5 | 6 |'
- en: 'The difference is a fixed value, 6\. This means the expression we need is `row
    * −1 + 6`. Using a little algebra, we can simplify this to `6 - row`. Let’s try
    it out:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 差值是一个固定值，6。这意味着我们需要的表达式是 `row * −1 + 6`。通过一点代数，我们可以简化这个表达式到 `6 - row`。让我们试试：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great—it works! If this hadn’t worked, our mistake probably would have been
    minor, because of the careful steps we have taken. Again, it’s very easy to experiment
    with a block of code that is this small and simple. Now let’s take this expression,
    and use it to limit the inner loop:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——它工作了！如果这没有工作，我们的错误可能很小，因为我们已经采取了谨慎的步骤。再次强调，实验一个小而简单的代码块非常容易。现在让我们用这个表达式，并使用它来限制内循环：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the reduction technique requires more steps to get from the description
    to the completed program, but each step is easier. Think of using a series of
    pulleys to lift a heavy object: You have to pull the rope farther to get the same
    amount of lift, but each pull is much easier on your muscles.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缩减技术需要更多步骤从描述到完成程序，但每一步都更容易。想象一下使用一系列滑轮来提升重物：你必须拉绳子更远才能获得相同的提升量，但每次拉动对肌肉的压力都小得多。
- en: Let’s tackle another shape problem before moving on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们解决另一个形状问题。
- en: 'Problem: A sideways triangle'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：侧向三角形
- en: 'Write a program that uses only two output statements, `cout << "#"` and `cout
    << "\n"`, to produce a pattern of hash symbols shaped like a sideways triangle:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，仅使用两个输出语句 `cout << "#"` 和 `cout << "\n"`，来生成一个像侧向三角形形状的井号符号图案：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’re not going to go through all the steps we used on the previous problem,
    because we don’t need to. This “Sideways Triangle” problem is analogous to the
    “Half of a Square” problem, so we can use what we have learned from the latter
    in the former. Remember the “start with what you know” maxim? Let’s start by listing
    skills and techniques from the “Half of a Square” problem that can be applied
    to this problem. We know how to:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会走完之前问题中使用的所有步骤，因为我们不需要。这个“侧向三角形”问题与“一半的方形”问题类似，因此我们可以将后者学到的知识应用到前者中。还记得“从已知开始”的原则吗？让我们先列出可以从“一半的方形”问题应用到这个问题中的技能和技术。我们知道如何：
- en: Display a row of symbols of a particular length using a loop
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环显示特定长度的符号行
- en: Display a series of rows using nested loops
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌套循环显示一系列行
- en: Create a varying number of symbols in each row using an algebraic expression
    instead of a fixed value
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代数表达式而不是固定值来创建每行不同的符号数量
- en: Discover the correct algebraic expression through experimentation and analysis
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实验和分析发现正确代数表达式
- en: '[Figure 2-1](ch02.html#various_components_needed_to_solve_the_s "Figure 2-1. Various
    components needed to solve the shape problems") summarizes our current position.
    The first row shows the previous “Half of a Square” problem. We see the desired
    pattern of hash symbols (a), the line pattern (b), the square pattern (c), and
    the number sequence (d) that will transform the square pattern to the half-a-square
    pattern. The second row shows the current “Sideways Triangle” problem. We again
    see the desired pattern (e), the line (f), a rectangle pattern (g), and a number
    sequence (h).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-1](ch02.html#various_components_needed_to_solve_the_s "图2-1. 解决形状问题所需的各个组件")总结了我们的当前位置。第一行显示了之前的“一半的方形”问题。我们看到所需的井号符号图案（a）、线条图案（b）、方形图案（c）以及将方形图案转换为半方形图案的数字序列（d）。第二行显示了当前的“侧向三角形”问题。我们再次看到所需的图案（e）、线条（f）、矩形图案（g）和数字序列（h）。'
- en: At this point, we will have no problem producing (f) because it is almost the
    same as (b). And we should be able to produce (g) because it is just (c) with
    more rows and one fewer symbol per row. Finally, if someone were to give us the
    algebraic expression that would produce the number sequence (h), we would have
    no difficulty creating the desired pattern (e).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们不会有困难产生（f），因为它几乎和（b）一样。我们也应该能够产生（g），因为它只是（c）增加了行数，每行符号减少一个。最后，如果有人给我们一个会产生数字序列（h）的代数表达式，我们将没有困难创建所需的图案（e）。
- en: 'Thus, most of the mental work required to create a solution for the “Sideways
    Triangle” problem has already been done. Furthermore, we know exactly what mental
    work remains: figuring out an expression to produce the number sequence (h). So
    that’s where we should direct our attention. We could either take the finished
    code for the “Half of a Square” problem and experiment until we can produce the
    desired numbered sequence or take a guess and make a table like [Table 2-1](ch02.html#computation_of_desired_value_from_row_va
    "Table 2-1. Computation of Desired Value from Row Variable") to see whether that
    jogs our creativity.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为“侧向三角形”问题创建解决方案所需的大部分心智工作已经完成。此外，我们确切地知道还剩下哪些心智工作：找出一个表达式来生成数字序列（h）。所以我们应该把注意力集中在这里。我们可以要么使用“一半的平方”问题的完成代码进行实验，直到我们能够生成所需的数字序列，要么猜测并制作一个像[表2-1](ch02.html#computation_of_desired_value_from_row_va
    "表2-1. 从行变量计算所需值")那样的表格，看看是否能够激发我们的创造力。
- en: '![Various components needed to solve the shape problems](httpatomoreillycomsourcenostarchimages1273184.png.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![解决形状问题所需的各个组件](httpatomoreillycomsourcenostarchimages1273184.png.jpg)'
- en: Figure 2-1. Various components needed to solve the shape problems
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1. 解决形状问题所需的各个组件
- en: Let’s try experimenting this time. In the “Half of a Square” problem, subtracting
    the row from a larger number worked well, so let’s see what numbers we get by
    running `row` in a loop from 1 to 7 and subtracting `row` from 8\. The result
    is shown in [Figure 2-2](ch02.html#various_components_needed_to_solve_the_l "Figure 2-2. Various
    components needed to solve the “Sideways Triangle” problem") (b). That’s not what
    we want. Where do we go from here? In the previous problem, we needed a number
    that went down instead of up, so we subtracted our loop variable from a greater
    number. In this problem, we need to go up first and then down. Would it make sense
    to subtract from a number in the middle? If we replace the `8 - row` in the previous
    code with `4 - row`, we get the result in [Figure 2-2](ch02.html#various_components_needed_to_solve_the_l
    "Figure 2-2. Various components needed to solve the “Sideways Triangle” problem")
    (c). That’s not right either, but it looks like it could be a useful pattern if
    we don’t look at the minus signs on the last three numbers. What if we used the
    absolute value function to remove those minus signs? The expression `abs(4 - row)`
    produces the results in [Figure 2-2](ch02.html#various_components_needed_to_solve_the_l
    "Figure 2-2. Various components needed to solve the “Sideways Triangle” problem")
    (d). We’re so close now—I can almost taste it! It’s just that we are going down
    first and then up when we need to go up first and then down. But how do we get
    from the number sequence we have to the number sequence we need?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这次尝试实验。在“一半的平方”问题中，从较大的数字中减去行数效果很好，所以让我们看看通过将`row`在1到7之间循环运行并从8中减去`row`，我们会得到什么数字。结果如图[图2-2](ch02.html#various_components_needed_to_solve_the_l
    "图2-2. 解决“侧向三角形”问题所需的各个组件")（b）所示。这不是我们想要的。接下来怎么办？在前一个问题中，我们需要一个递减的数字而不是递增的，所以我们从较大的数字中减去了循环变量。在这个问题中，我们需要先上升再下降。从中间的数字中减去是否合理？如果我们把之前的代码中的`8
    - row`替换为`4 - row`，我们就会得到[图2-2](ch02.html#various_components_needed_to_solve_the_l
    "图2-2. 解决“侧向三角形”问题所需的各个组件")（c）中的结果。这也不正确，但它看起来可能是一个有用的模式，如果我们不关注最后三个数字上的减号的话。如果我们使用绝对值函数来去除这些减号会怎样？表达式`abs(4
    - row)`产生了[图2-2](ch02.html#various_components_needed_to_solve_the_l "图2-2. 解决“侧向三角形”问题所需的各个组件")（d）中的结果。现在我们非常接近了——我几乎能尝到它了！只是我们现在是在先下降再上升，而我们需要先上升再下降。但我们如何从我们已有的数字序列转换到我们需要的数字序列呢？
- en: Let’s try looking at the numbers in [Figure 2-2](ch02.html#various_components_needed_to_solve_the_l
    "Figure 2-2. Various components needed to solve the “Sideways Triangle” problem")
    (d) in a different way. What if we count the empty spaces instead of the hash
    marks, as shown in [Figure 2-2](ch02.html#various_components_needed_to_solve_the_l
    "Figure 2-2. Various components needed to solve the “Sideways Triangle” problem")
    (e)? Column (d) *is* the right pattern of values if we count the empty spaces.
    To get the right number of hash marks, think of each row as having four boxes,
    and then subtract the number of empty spaces. If each row has four boxes of which
    `abs(4 - row)` are empty spaces, then the number of boxes with hash marks will
    be given by `4 - abs(4 - row)`. That works. Plug it in, and try it out.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以不同的方式查看[图2-2](ch02.html#various_components_needed_to_solve_the_l "图2-2.
    解决“侧向三角形”问题所需的各个组件")（d）中的数字。如果我们像[图2-2](ch02.html#various_components_needed_to_solve_the_l
    "图2-2. 解决“侧向三角形”问题所需的各个组件")（e）所示的那样，计算空格而不是井号，会怎样呢？如果我们计算空格，列（d）*就是*正确的值模式。为了得到正确的井号数量，想象每一行有四个方框，然后减去空格的数量。如果每一行有四个方框，其中`abs(4
    - row)`是空格，那么带有井号的方框数量将由`4 - abs(4 - row)`给出。这行得通。把它代入，试试看。
- en: '![Various components needed to solve the “Sideways Triangle” problem](httpatomoreillycomsourcenostarchimages1273186.png.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![解决“侧向三角形”问题所需的各个组件](httpatomoreillycomsourcenostarchimages1273186.png.jpg)'
- en: Figure 2-2. Various components needed to solve the “Sideways Triangle” problem
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2. 解决“侧向三角形”问题所需的各个组件
- en: We have avoided most of the work for this problem through analogy and have solved
    the rest through experimentation. This one-two punch is a great approach when
    a new problem is very similar to another you can already solve.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过类比避开了这个问题的大部分工作，并通过实验解决了其余部分。当一个新的问题与另一个你可以解决的问题非常相似时，这种一石二鸟的方法是非常好的。
- en: Input Processing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入处理
- en: 'The previous programs only produced output. Let’s change things up and try
    programs that are all about processing the input. Each of these programs shares
    one constraint: The input will be read character by character, and the program
    must process each character before reading the next one. In other words, the programs
    will not store the characters in a data structure for later processing but process
    as they go.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序只产生输出。让我们改变一下，尝试一些主要处理输入的程序。这些程序都有一个共同的限制：输入将逐字符读取，程序必须在读取下一个字符之前处理每个字符。换句话说，程序不会将字符存储在数据结构中以供后续处理，而是边走边处理。
- en: In this first problem, we’ll perform identification number validation. In the
    modern world, almost everything has an identification number, such as an ISBN
    or a customer number. Sometimes these numbers have to be entered by hand, which
    introduces the potential for error. If a mistakenly entered number doesn’t match
    any valid identification number, the system can easily reject it. But what if
    the number is wrong, yet valid? For example, what if a cashier, attempting to
    credit your account for a product return, enters another customer’s account number?
    The other customer would receive your credit. To avoid this situation, systems
    have been developed to detect mistakes in identification numbers. They work by
    running the identification number through a formula that generates one or more
    extra digits, which become part of an extended identification number. If any of
    the digits are changed, the original part of the number and the extra digits will
    no longer match, and the number can be rejected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将执行身份证号码验证。在现代社会，几乎所有东西都有一个身份证号码，比如ISBN或客户号码。有时这些号码需要手动输入，这引入了出错的可能性。如果输入错误且不匹配任何有效的身份证号码，系统可以轻松拒绝它。但如果号码错误，却是有效的呢？例如，如果收银员在尝试为产品退货给您的账户时输入了另一个客户的账户号码，其他客户会收到您的信用。为了避免这种情况，已经开发出检测身份证号码错误的系统。它们通过将身份证号码通过一个公式运行来工作，该公式生成一个或多个额外的数字，这些数字成为扩展身份证号码的一部分。如果任何数字被更改，原始号码部分和额外数字将不再匹配，该号码可以被拒绝。
- en: 'Problem: Luhn checksum validation'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：Luhn校验和验证
- en: The Luhn formula is a widely used system for validating identification numbers.
    Using the original number, double the value of every other digit. Then add the
    values of the individual digits together (if a doubled value now has two digits,
    add the digits individually). The identification number is valid if the sum is
    divisible by 10.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Luhn公式是一个广泛用于验证识别号的系统。使用原始号码，将每隔一个数字的值翻倍。然后将各个数字的值相加（如果一个翻倍的值现在是一个两位数，则单独相加这些数字）。如果总和能被10整除，则识别号有效。
- en: Write a program that takes an identification number of arbitrary length and
    determines whether the number is valid under the Luhn formula. The program must
    process each character before reading the next one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序接受任意长度的识别号并确定该号码是否根据Luhn公式有效。程序必须处理每个字符，然后再读取下一个字符。
- en: 'The process sounds a little complicated, but an example will make everything
    clearer. Our program will only validate an identification number, not create the
    check digit. Let’s walk through both ends of the process: computing a check digit
    and validating the result. This process is demonstrated in [Figure 2-3](ch02.html#the_luhn_checksum_formula
    "Figure 2-3. The Luhn checksum formula"). In part (a), we compute the check digit.
    The original identification number, 176248, is shown in the dashed-line box. Every
    other digit, starting from the rightmost digit of the original number (which,
    after the addition of the check digit, will be the second rightmost), is doubled.
    Then each digit is added together. Note that when doubling a digit results in
    a two-digit number, each of those digits is considered separately. For example,
    when 7 is doubled to produce 14, it’s not *14* that is added to the checksum,
    but *1* and *4* individually. In this case, the checksum is 27, so the check digit
    is 3 because that’s the digit value that would make the overall sum 30\. Remember,
    the checksum of the final number should be divisible by 10; in other words, it
    should end in 0.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程听起来有点复杂，但一个例子会让一切变得清晰。我们的程序将只验证识别号，而不是创建校验位。让我们来梳理一下这个过程的两端：计算校验位和验证结果。这个过程在[图2-3](ch02.html#the_luhn_checksum_formula
    "图2-3. Luhn校验和公式")中展示。在部分(a)中，我们计算校验位。原始识别号176248显示在虚线框中。从原始号码的最右边数字开始（在添加校验位后，它将成为第二右边的数字），每隔一个数字的值翻倍。然后，将每个数字的值相加。注意，当翻倍一个数字得到一个两位数时，这些数字要单独考虑。例如，当7翻倍得到14时，加到校验和中的不是*14*，而是*1*和*4*分别。在这种情况下，校验和是27，所以校验位是3，因为这是使总和为30的数字值。记住，最终号码的校验和应该能被10整除；换句话说，它应该以0结尾。
- en: '![The Luhn checksum formula](httpatomoreillycomsourcenostarchimages1273188.png.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Luhn校验和公式](httpatomoreillycomsourcenostarchimages1273188.png.jpg)'
- en: Figure 2-3. The Luhn checksum formula
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3. Luhn校验和公式
- en: In part (b), we validate the number 1762483, which now includes the check digit.
    This is the process we will be using for this problem. As before, we double every
    second digit, starting with the digit to the right of the check digit, and add
    the values of all digits, including the check digit, to determine the checksum.
    Because the checksum is divisible by 10, this number validates.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分(b)中，我们验证了包含校验位的号码1762483。这是我们将在这个问题中使用的过程。和之前一样，我们从校验位右边的数字开始，每隔一个数字翻倍，并将所有数字的值（包括校验位）相加来确定校验和。因为校验和能被10整除，所以这个号码是有效的。
- en: Breaking Down the Problem
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题分解
- en: The program that will solve this problem has several separate issues we will
    have to handle. One issue is the doubling of digits, which is tricky because doubled
    digits are determined from the right end of the identification number. Remember,
    we’re not going to read and store all of the digits and *then* process. We’re
    going to process as we go. The problem is that we’ll be getting the digits left
    to right, but we really need them right to left in order to know which digits
    to double. We would know which digits to double if we knew how many digits were
    in the identification number, but we don’t because the problem states that the
    identification number is of arbitrary length. Another issue is that doubled numbers
    10 and greater must be treated according to their individual digits. Also, we
    have to determine when we’ve read the whole identification number. Finally, we
    have to figure out how to read the number digit by digit. In other words, the
    user is going to enter one long number, but we want to read it as though the digits
    were entered as separate numbers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将要解决这个问题的程序有几个独立的问题我们需要处理。一个问题就是数字的加倍，这很棘手，因为加倍后的数字是从识别号码的右端确定的。记住，我们不会读取和存储所有的数字，然后才处理。我们将边走边处理。问题是我们将从左到右获取数字，但我们实际上需要从右到左，以便知道哪些数字需要加倍。如果我们知道识别号码中有多少位数字，我们就会知道哪些数字需要加倍，但我们不知道，因为问题说明识别号码的长度是任意的。另一个问题是，10及以上的加倍数字必须根据它们的各个数字来处理。此外，我们必须确定何时已经读取了整个识别号码。最后，我们必须找出如何逐位读取数字。换句话说，用户将输入一个长数字，但我们希望像输入单独的数字一样读取它。
- en: 'Because we always want to have a plan, we should make a list of these issues
    and tackle them one by one:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们总是想要有一个计划，所以我们应该列出这些问题，并逐一解决：
- en: Knowing which digits to double
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道哪些数字需要加倍
- en: Treating doubled numbers 10 and greater according to their individual digits
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据各个数字处理10及以上的加倍数字
- en: Knowing we’ve reached the end of the number
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道我们已经到达数字的末尾
- en: Reading each digit separately
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别读取每个数字
- en: To solve problems, we’ll be working on individual pieces before writing a final
    solution. Thus, there is no need to work on these issues in any particular order.
    Start with the issue that looks the easiest or, if you want a challenge, the one
    that looks the most difficult. Or just start with the one that’s the most interesting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们将在编写最终解决方案之前先处理各个部分。因此，没有必要按任何特定顺序处理这些问题。从看起来最容易的问题开始，或者如果你想要挑战，从看起来最困难的问题开始。或者，你也可以从最有趣的问题开始。
- en: 'Let’s begin by tackling the doubled digits that are 10 and greater. This is
    a situation where problem constraints make things easier rather than more difficult.
    Computing the sum of the digits of an arbitrary integer could be a good amount
    of work by itself. But what is the range of possible values here? If we start
    with individual digits 0–9 and double them, the maximum value is 18\. Therefore,
    there are only two possibilities. If the doubled value is a single digit, then
    there’s nothing more to do. If the doubled value is 10 or greater, then it must
    be in the range 10–18, and therefore the first digit is always 1\. Let’s do a
    quick code experiment to confirm this approach:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决10及以上的加倍数字。这是一个问题约束使事情变得更容易而不是更困难的情况。计算任意整数的数字之和本身可能是一项相当多的工作。但这里的可能值范围是多少？如果我们从单个数字0-9开始加倍，最大值是18。因此，只有两种可能性。如果加倍后的值是一个单独的数字，那么就没有更多的事情要做。如果加倍后的值是10或更大，那么它必须在10-18的范围内，因此第一位数字总是1。让我们做一个快速的代码实验来确认这种方法：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The `%` operator is called the *modulo operator*. For positive integers, it
    returns the remainder of integer division. For example, 12 % 10 would be 2 because
    after dividing 10 into 12, the 2 is left over.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`运算符被称为*模运算符*。对于正整数，它返回整数除法的余数。例如，12 % 10将是2，因为将10除入12后，剩下的2。'
- en: 'This is straightforward code: the program reads the digit, doubles it ![](httpatomoreillycomsourcenostarchimages1273182.png),
    sums the digits of the doubled number ![](httpatomoreillycomsourcenostarchimages1273191.png),
    and outputs the sum ![](httpatomoreillycomsourcenostarchimages1273195.png). The
    heart of the experiment is the calculation of the sum for a doubled number that
    is greater than 10 ![](httpatomoreillycomsourcenostarchimages1273193.png). As
    with the calculation of the number of hash marks needed for a particular row in
    our shapes problems, isolating this calculation to a short program of its own
    makes experimentation easy. Even if we don’t get the correct formula at first,
    we’re sure to find it quickly.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段简单的代码：程序读取数字，将其加倍 ![](httpatomoreillycomsourcenostarchimages1273182.png)，然后计算加倍数字的各位数
    ![](httpatomoreillycomsourcenostarchimages1273191.png)，最后输出总和 ![](httpatomoreillycomsourcenostarchimages1273195.png)。实验的核心是计算大于10的加倍数字的总和
    ![](httpatomoreillycomsourcenostarchimages1273193.png)。就像我们在形状问题中计算特定行所需的井号数量一样，将这个计算单独放在一个简短的程序中使得实验变得容易。即使我们一开始没有得到正确的公式，我们也会很快找到它。
- en: 'Before we scratch this issue off our list, let’s turn this code into a short
    function we can use to simplify future code listings:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从我们的问题列表中划掉这个问题之前，让我们把这个代码转换成一个简短的功能，我们可以用它来简化未来的代码列表：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now let’s work on reading the individual digits of the identification number.
    Again, we could tackle a different issue next if we wanted, but I think this issue
    is a good choice because it will allow us to type the identification number naturally
    when testing the other parts of the problem.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来处理读取识别号的各个数字。同样，如果我们想的话，我们可以解决下一个不同的问题，但我认为这个问题是一个不错的选择，因为它将允许我们在测试问题的其他部分时自然地输入识别号。
- en: If we read the identification number as a numeric type (`int`, for example),
    we’d just get one long number and have a lot of work ahead of us. Plus, there’s
    a limit to how big an integer we can read, and the question says the identification
    number is of arbitrary length. Therefore, we’ll have to read character by character.
    This means that we need to make sure we know how to read a character representing
    a digit and turn it into an integer type we can work with mathematically. To see
    what would happen if we took the character value and used it in an integer expression
    directly, take a look at the following listing, which includes sample output.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将识别号作为数值类型（例如`int`）读取，我们只会得到一个很长的数字，而且我们还有很多工作要做。此外，我们能够读取的整数大小是有限的，而问题说明识别号是任意长度的。因此，我们必须逐个字符地读取。这意味着我们需要确保我们知道如何读取表示数字的字符并将其转换为我们可以进行数学运算的整数类型。为了看看如果我们直接使用字符值并在整数表达式中使用它会发生什么，请看以下列表，其中包含示例输出。
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we use the `get` method ![](httpatomoreillycomsourcenostarchimages1273182.png)
    because the basic extraction operator (as in `cin >> digit`) skips whitespace.
    That’s not a problem here, but as you’ll see, it would cause trouble later. In
    the sample input and output ![](httpatomoreillycomsourcenostarchimages1273191.png),
    you see the problem. All computer data is essentially numeric, so individual characters
    are represented by integer character codes. Different operating systems may use
    different character code systems, but in this text we’ll focus on the common ASCII
    system. In this system, the character 7 is stored as the character code value
    55, so when we treat the value as an integer, 55 is what we get. We need a mechanism
    to turn the *character* 7 into the *integer* 7.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`get`方法 ![](httpatomoreillycomsourcenostarchimages1273182.png)是因为基本的提取操作符（如`cin
    >> digit`）会跳过空白字符。这里没有问题，但正如你将看到的，这会在以后造成麻烦。在示例输入和输出 ![](httpatomoreillycomsourcenostarchimages1273191.png)中，你可以看到这个问题。所有计算机数据本质上都是数字的，所以单个字符由整数字符代码表示。不同的操作系统可能使用不同的字符代码系统，但在这篇文章中，我们将关注常见的ASCII系统。在这个系统中，字符7存储为字符代码值55，因此当我们将其视为整数时，我们得到55。我们需要一种机制将*字符*
    7转换为*整数* 7。
- en: 'Problem: Convert character digit to integer'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：将字符数字转换为整数
- en: Write a program that reads a character from the user representing a digit, 0
    through 9\. Convert the character to the equivalent integer in the range 0–9,
    and then output the integer to demonstrate the result.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，从用户那里读取一个表示数字（0到9）的字符。将字符转换为0到9范围内的等效整数，然后将该整数输出以展示结果。
- en: In the shape problems of the previous section, we had a variable with one range
    of values that we wanted to convert to another range of values. We made a table
    with columns for the original values and desired values and then checked the difference
    between the two. This is an analogous problem, and we can use the table idea again,
    as in [Table 2-2](ch02.html#character_codes_and_desired_integer_valu "Table 2-2. Character
    Codes and Desired Integer Values").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的形状问题中，我们有一个具有一个值域的变量，我们希望将其转换为另一个值域。我们制作了一个表格，包含原始值和目标值的列，然后检查两者之间的差异。这是一个类似的问题，我们可以再次使用表格的想法，如[表2-2](ch02.html#character_codes_and_desired_integer_valu
    "表2-2. 字符代码和目标整数值")。
- en: Table 2-2. Character Codes and Desired Integer Values
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2. 字符代码和目标整数值
- en: '| Character | Character Code | Desired Integer | Difference |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 字符代码 | 目标整数 | 差值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 48 | 0 | 48 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 48 | 0 | 48 |'
- en: '| 1 | 49 | 1 | 48 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 49 | 1 | 48 |'
- en: '| 2 | 50 | 2 | 48 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 50 | 2 | 48 |'
- en: '| 3 | 51 | 3 | 48 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 51 | 3 | 48 |'
- en: '| 4 | 52 | 4 | 48 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 52 | 4 | 48 |'
- en: '| 5 | 53 | 5 | 48 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 53 | 5 | 48 |'
- en: '| 6 | 54 | 6 | 48 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 54 | 6 | 48 |'
- en: '| 7 | 55 | 7 | 48 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 55 | 7 | 48 |'
- en: '| 8 | 56 | 8 | 48 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 56 | 8 | 48 |'
- en: '| 9 | 57 | 9 | 48 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 57 | 9 | 48 |'
- en: 'The difference between the character code and the desired integer is always
    48, so all we have to do is subtract that value. You might have noticed that this
    is the character code value for the zero character, 0\. This will always be true
    because character code systems always store the digit characters in order, starting
    from 0\. We can therefore make a more general, and more readable, solution by
    subtracting the character `0` rather than using a pre-determined value, like 48:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 字符代码与目标整数之间的差值始终为48，所以我们只需要减去这个值。你可能已经注意到，这是零字符的字符代码值，0。这始终是正确的，因为字符代码系统总是按照顺序存储数字字符，从0开始。因此，我们可以通过减去字符`0`而不是使用预定的值（如48）来创建一个更通用、更易读的解决方案：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we can move on to figuring out which digits to double. This part of the
    problem may take several steps to figure out, so let’s try a problem reduction.
    What if we initially limited ourselves to a fixed-length number? That would confirm
    our understanding of the general formula while making progress toward the ultimate
    goal. Let’s try limiting the length to six; this is long enough to be a good representation
    of the overall challenge.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续确定哪些数字需要加倍。这部分问题可能需要几个步骤才能解决，所以让我们尝试一个问题简化。如果我们最初限制自己为一个固定长度的数字，这将确认我们对通用公式的理解，同时朝着最终目标迈进。让我们尝试将长度限制为六位；这足以很好地代表整体挑战。
- en: 'Problem: Luhn checksum validation, fixed length'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：Luhn校验和验证，固定长度
- en: Write a program that takes an identification number (including its check digit)
    of length six and determines whether the number is valid under the Luhn formula.
    The program must process each character before reading the next one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序接受一个长度为六位的识别号（包括其校验位），并确定该号码是否在Luhn公式下有效。程序必须在读取下一个字符之前处理每个字符。
- en: As before, we can reduce even further to make getting started as easy as possible.
    What if we changed the formula so that none of the digits is doubled? Then the
    program only has to read the digits and sum them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以进一步简化，使开始尽可能容易。如果我们改变公式，使得没有任何一个数字被重复，那么程序只需要读取数字并将它们相加。
- en: 'Problem: Simple checksum validation, fixed length'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：简单的校验和验证，固定长度
- en: Write a program that takes an identification number (including its check digit)
    of length six and determines whether the number is valid under a simple formula
    where the values of each digit are summed and the result checked to see whether
    it is divisible by 10\. The program must process each character before reading
    the next one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序接受一个长度为六位的识别号（包括其校验位），并确定该号码是否在简单公式下有效，其中每个数字的值相加，然后检查结果是否能被10整除。程序必须在读取下一个字符之前处理每个字符。
- en: Because we know how to read an individual digit as a character, we can solve
    this fixed-length, simple checksum problem pretty easily. We just need to read
    six digits, sum them, and determine whether the sum is divisible by 10.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道如何将单个数字作为字符读取，所以我们可以轻松解决这个固定长度的简单校验和问题。我们只需要读取六个数字，将它们相加，然后判断和是否能被10整除。
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From here, we need to add the logic for the actual Luhn validation formula,
    which means doubling every other digit starting from the second digit from the
    right. Since we are currently limiting ourselves to six-digit numbers, we need
    to double the digits in positions one, three, and five, counting from the left.
    In other words, we double the digit if the position is odd. We can identify odd
    and even positions using the modulo (`%`) operator because the definition of an
    even number is that it is evenly divisible by two. So if the result of the expression
    `position % 2` is 1, `position` is odd and we should double. It’s important to
    remember that *doubling* here means both doubling the individual digit and also
    summing the digits of the doubled number if the doubling results in a number 10
    or greater. This is where our previous function really helps. When we need to
    double a digit according to the Luhn formula, we just send it to our function
    and use the result. Putting this together, just change the code inside the `for`
    loop from the previous listing:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们需要添加实际 Luhn 验证公式的逻辑，这意味着从最右边第二个数字开始，每隔一个数字进行加倍。由于我们目前限制自己使用六位数，因此我们需要从左边开始对位置一、三和五的数字进行加倍。换句话说，如果位置是奇数，我们就加倍这个数字。我们可以使用取模运算符（`%`）来识别奇数和偶数位置，因为偶数的定义是它能被
    2 整除。所以如果表达式 `position % 2` 的结果是 1，那么 `position` 是奇数，我们应该加倍。重要的是要记住，这里的“加倍”不仅意味着加倍单个数字，如果加倍的结果是
    10 或更大，还要将加倍数字的各位数相加。这正是我们之前函数真正发挥作用的地方。当我们需要根据 Luhn 公式加倍一个数字时，我们只需将其发送到我们的函数并使用结果。将这一切结合起来，只需将之前列表中的
    `for` 循环内的代码进行更改：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ve accomplished a lot on this problem so far, but there are still a -couple
    of steps to go before we can write the code for arbitrary-length identification
    numbers. To ultimately solve this problem, we need to divide and conquer. Suppose
    I asked you to modify the previous code for numbers with 10 or 16 digits. That
    would be trivial—you’d only have to change the 6 used as the upper bound of the
    loop to another value. But suppose I asked you to validate seven-digit numbers.
    That would require a small additional modification because if the number of digits
    is odd and we are doubling every digit starting from the second on the right,
    the first digit *on the left* is no longer doubled. In this case, you need to
    double the even positions: 2, 4, 6, and so on. Putting aside that issue for the
    moment, let’s figure out how to handle any even-length number.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这个问题上已经取得了很大的进展，但在我们可以编写任意长度识别号码的代码之前，还有几个步骤要走。为了最终解决这个问题，我们需要分而治之。假设我要求你修改之前的代码以处理
    10 或 16 位数的数字。那将是微不足道的——你只需将用作循环上界的 6 改成另一个值。但假设我要求你验证七位数的数字。那将需要一些小的额外修改，因为如果数字的位数是奇数，并且我们从最右边第二个数字开始加倍每个数字，那么最左边的第一个数字就不再加倍了。在这种情况下，你需要加倍偶数位置：2、4、6
    等等。暂时把这个问题放在一边，让我们来看看如何处理任何偶数长度的数字。
- en: 'The first issue we face is determining when we have reached the end of the
    number. If the user enters a multidigit number and presses enter and we’re reading
    the input character by character, what character is read after the last digit?
    This actually varies based on the operating system, but we’ll just write an experiment:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的第一问题是确定何时到达数字的末尾。如果用户输入一个多数字并按下回车键，而我们正在逐个字符读取输入，那么在最后一个数字之后读取的是什么字符？这实际上会根据操作系统而变化，但我们将只写一个实验：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This loop runs forever, but it does the job. I typed in the number `1234` and
    pressed enter. The result was `49 50 51 52 10` (based on ASCII; this will vary
    based on the operating system). Thus, 10 is what I’m looking for. With that information
    in hand, we can replace the `for` loop in our previous code with a `while` loop:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环会无限运行，但它完成了工作。我输入了数字 `1234` 并按下了回车键。结果是 `49 50 51 52 10`（基于 ASCII；这会根据操作系统而变化）。因此，10
    是我要找的数字。有了这个信息，我们可以用 `while` 循环替换之前代码中的 `for` 循环：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this code, `position` is no longer the control variable in a `for` loop,
    so we must initialize ![](httpatomoreillycomsourcenostarchimages1273182.png) and
    increment it separately ![](httpatomoreillycomsourcenostarchimages1273199.png).
    The loop is now controlled by the conditional expression ![](httpatomoreillycomsourcenostarchimages1273193.png),
    which checks for the character code value that signals the end-of-line. Because
    we need a value to check the first time we go through the loop, we read the first
    value before the loop begins ![](httpatomoreillycomsourcenostarchimages1273191.png)
    and then read each subsequent value inside the loop ![](httpatomoreillycomsourcenostarchimages1273197.png),
    after the processing code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`position`不再是`for`循环中的控制变量，因此我们必须单独初始化！![图片](http://atomoreilly.com/source/nostarch/images/1273182.png)和递增它！![图片](http://atomoreilly.com/source/nostarch/images/1273199.png)。循环现在由条件表达式！![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)控制，该表达式检查表示行结束的字符代码值。因为我们需要一个值来检查我们第一次进入循环时的情况，所以我们读取循环开始前的第一个值！![图片](http://atomoreilly.com/source/nostarch/images/1273191.png)，然后在处理代码之后读取循环中的每个后续值！![图片](http://atomoreilly.com/source/nostarch/images/1273197.png)。
- en: Again, this code will handle a number of any even length. To handle a number
    of any odd length, we’d need only to modify the processing code, reversing the
    logic of the `if` statement condition ![](httpatomoreillycomsourcenostarchimages1273195.png)
    in order to double the numbers at the even positions, rather than the odd positions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这段代码将处理任何偶数长度的数字。要处理任何奇数长度的数字，我们只需修改处理代码，反转`if`语句条件的逻辑！![图片](http://atomoreilly.com/source/nostarch/images/1273195.png)，以便将偶数位置的数字加倍，而不是奇数位置的数字。
- en: That, at least, exhausts every possibility. The length of the identification
    number must be odd or even. If we knew the length ahead of time, we would know
    whether to double the odd positions or the even positions in the -number. We don’t
    have that information, however, until we have reached the end of the number. Is
    a solution impossible given these constraints? If we know how to solve the problem
    for an odd number of digits and for an even number of digits but don’t know how
    many digits are in the number until we’ve read it completely, how can we solve
    this problem?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，这已经穷尽了所有可能性。身份证号码的长度必须是奇数或偶数。如果我们事先知道长度，我们就会知道在-号码中是加倍奇数位置还是偶数位置。然而，我们并没有这样的信息，直到我们读完整个数。在这些约束条件下，解决方案是不可能的吗？如果我们知道如何解决奇数位数字和偶数位数字的问题，但我们不知道数字中有多少位，直到我们完全读取它，我们如何解决这个问题？
- en: You may already see the answer to this problem. If you don’t, it’s not because
    the answer is difficult but because it is hidden in the details. What we could
    use here is an analogy, but we haven’t seen an analogous situation so far. Instead,
    we’ll make our own analogy. Let’s make a problem that is explicitly about this
    very situation and see whether staring the problem in the face helps us find a
    solution. Clear your mind of preconceptions based on the work so far, and read
    the following problem.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了这个问题的答案。如果你没有，那不是因为答案很难，而是因为它隐藏在细节中。我们在这里可以使用类比，但我们还没有看到类似的情境。相反，我们将自己创造一个与这种情境明确相关的问题，看看直面问题是否有助于我们找到解决方案。清除你基于迄今为止的工作的先入之见，阅读以下问题。
- en: 'Problem: Positive or negative'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：正数或负数
- en: Write a program that reads 10 integers from the user. After all the numbers
    have been entered, the user may ask to display the count of positive numbers or
    the count of negative numbers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，从用户那里读取10个整数。在所有数字都输入完毕后，用户可以要求显示正数的数量或负数的数量。
- en: 'This is a simple problem, one that doesn’t seem to have any complications at
    all. We just need one variable that counts the positive numbers and another variable
    that counts the negative numbers. When the user specifies the request at the end
    of the program, we just need to consult the proper variable for the response:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的问题，一个看起来没有任何复杂性的问题。我们只需要一个变量来计算正数，另一个变量来计算负数。当用户在程序结束时指定请求时，我们只需查询适当的变量以获得响应：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This shows the method we need to use for the Luhn checksum problem: Keep track
    of the running checksum both ways, as if the identification number is an odd length
    and again as if it is an even length. When we get to the end of the number and
    discover the true length, we’ll have the correct check-sum in one variable or
    the other.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们需要用于Luhn校验和问题的方法：同时跟踪两种方式的运行校验和，就像识别号是奇数长度一样，然后再像它是偶数长度一样。当我们到达数字的末尾并发现真正的长度时，我们将在一个变量或另一个变量中拥有正确的校验和。
- en: Putting the Pieces Together
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拼接碎片
- en: 'We’ve now checked off everything on our original “to-do” list. It’s time to
    put everything together and solve this problem. Because we’ve solved all of the
    subproblems separately, we know exactly what we need to do and can use our previous
    programs as reference to produce the final result quickly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了原始“待办”列表上的所有事项。现在是时候将所有东西放在一起并解决这个问题了。因为我们已经单独解决了所有子问题，所以我们确切地知道我们需要做什么，并且可以使用我们之前的程序作为参考，快速产生最终结果：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that when we check to see whether the length of the input number is odd
    or even ![](httpatomoreillycomsourcenostarchimages1273182.png), we subtract 1
    from `position`. We do this because the last character we read in the loop will
    be the terminating end-of-line, not the last digit of the number. We could also
    have written the test expression as `(position % 2 == 1)`, but that’s more confusing
    to read. In other words, it’s better to say “if `position - 1` is even, use the
    even checksum” than “if `position` is odd, use the even checksum” and have to
    remember why that makes sense.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们检查输入数字的长度是奇数还是偶数时 ![http://atomoreilly.com/source/no_starch_images/1273182.png]，我们从`position`中减去1。我们这样做是因为在循环中读取的最后一个字符将是终止的换行符，而不是数字的最后一位。我们也可以将测试表达式写成`(position
    % 2 == 1)`，但这更难以阅读。换句话说，最好说“如果`position - 1`是偶数，则使用偶数校验和”，而不是“如果`position`是奇数，则使用偶数校验和”，并且需要记住为什么这样做是有意义的。
- en: This is the longest code listing we’ve looked at so far, but I don’t need to
    annotate everything in the code and describe how each part works because you’ve
    already seen each part in isolation. This is the power of having a plan. It’s
    important to note, though, that *my* plan is not necessarily *your* plan. The
    issues I saw in the original description of the problem and the steps I took to
    work through those issues are likely to differ from what you would’ve seen and
    done. Your background as a programmer and the problems you have successfully completed
    determine which parts of the problem are trivial or difficult and thus what steps
    you need to take to solve the problem. There may have been a point in the previous
    section where I took what looked like a needless detour to figure out something
    that was already obvious to you. Conversely, there may have been a point where
    I nimbly skipped over something that was tricky for you. Also, if you’d worked
    through this yourself, you might have come up with an equally successful program
    that looked quite different from mine. There is no one “right” solution for a
    problem, as any program that meets all constraints counts as a solution, and for
    any solution, there is no one “right” way of reaching it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们迄今为止看到的代码列表中最长的，但我不需要注释代码中的每一部分并描述每个部分是如何工作的，因为你们已经单独看过每一部分。这正是有计划的好处。不过，需要注意的是，*我的*计划并不一定是*你的*计划。我在原始问题描述中看到的问题以及我解决这些问题的步骤可能与你看到和做的事情不同。你的编程背景以及你成功解决的问题将决定问题的哪些部分是微不足道的或困难的，以及你需要采取哪些步骤来解决问题。在前一节中，我可能已经走过了一个看似不必要的弯路，去弄清楚对你来说已经很明显的某件事。相反，也可能有某个地方我轻巧地跳过了对你来说棘手的部分。此外，如果你自己处理过这个问题，你可能会想出一个同样成功的程序，但看起来与我的完全不同。对于一个问题来说，没有“正确”的解决方案，因为任何满足所有约束条件的程序都可以算作解决方案，而且对于任何解决方案，都没有“正确”的方法来达到它。
- en: Seeing all the steps that we took to reach the solution, along with the -relative
    brevity of the final code, you might be tempted to try to trim steps in your own
    problem-solving process. I would caution against this impulse. It’s always better
    to take more steps than to try to do too much at once, even if some steps seem
    trivial. Remember what the goals are in problem solving. The primary goal is,
    of course, to find a program that solves the stated problem and meets all constraints.
    The secondary goal is to find that program in the minimal amount of time. Minimizing
    the number of steps isn’t a goal, and no one has to know how many steps you took.
    Consider trying to reach the summit of a steep hill that has a shallow but long
    and winding path. Ignoring the path and climbing the hill directly from the base
    to the peak will certainly require fewer steps than following the path—but is
    it faster? The most likely outcome of a direct climb is that you give up and collapse.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们为了达到解决方案所采取的所有步骤，以及最终代码的相对简短，你可能会试图在你自己的问题解决过程中减少步骤。我警告你这种冲动。总是做更多的步骤比试图一次做太多更好，即使有些步骤看起来很
    trivial。记住问题解决的目标。当然，主要目标是找到一个程序来解决所陈述的问题并满足所有约束。次要目标是找到这个程序所需的时间最少。最小化步骤数量不是目标，而且没有人需要知道你采取了多少步骤。考虑尝试到达一个陡峭的山峰，它有一条浅而长且蜿蜒的小径。忽略小径，直接从山脚到山顶攀登，当然会比沿着小径走要少走很多步——但这更快吗？直接攀登最可能的结果是你会放弃并倒下。
- en: 'Also remember the last of my general rules for problem solving: *Avoid frustration*.
    The more work you try to do in each step, the more you invite potential frustration.
    Even if you back off a difficult step and break it up into substeps, the damage
    will have been done because psychologically you’ll feel like you’re going backward
    instead of making progress. When I coach beginning programmers in a step-by-step
    approach, I sometimes have a student complain, “Hey, that step was too easy.”
    To which I reply, “What are you complaining about?” If you’ve taken a problem
    that initially looked tough and broken it down into pieces so small that every
    piece is trivial to accomplish, I say: Congratulations! That’s just what you should
    hope for.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住我关于解决问题的最后一条通用规则：*避免挫败感*。你试图在每一步做的越多，你邀请的潜在挫败感就越多。即使你退回到一个困难的步骤并将其分解成子步骤，伤害也已经造成，因为从心理上讲，你会觉得自己是在后退而不是在进步。当我以逐步的方法指导初学者程序员时，我有时会有学生抱怨，“嘿，那个步骤太简单了。”对此，我会回答，“你在抱怨什么？”如果你已经将一个最初看起来很难的问题分解成非常小的部分，以至于每个部分都很容易完成，我说：恭喜你！这正是你应该希望的。
- en: Tracking State
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪状态
- en: The last problem we’ll work through for this chapter is also the most difficult.
    This problem has a lot of different pieces and a complicated description, which
    will illustrate the importance of breaking down a complex problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中要解决的最后一个问题也是最困难的。这个问题有很多不同的部分和复杂的描述，这将说明分解复杂问题的重要性。
- en: 'Problem: Decode a message'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：解码信息
- en: 'A message has been encoded as a text stream that is to be read character by
    character. The stream contains a series of comma-delimited integers, each a positive
    number capable of being represented by a C++ *`int`*. However, the character represented
    by a particular integer depends on the current *decoding mode*. There are three
    modes: *uppercase*, *lowercase*, and *punctuation*.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一条信息已被编码为一个要逐个字符读取的文本流。该流包含一系列以逗号分隔的整数，每个整数都是可以由C++ *`int`*表示的正数。然而，特定整数所代表的字符取决于当前的*解码模式*。有三种模式：*大写*、*小写*和*标点*。
- en: 'In *uppercase* mode, each integer represents an uppercase letter: The integer
    modulo 27 indicates the letter of the alphabet (where 1 = A and so on). So an
    input value of 143 in uppercase mode would yield the letter *H* because 143 modulo
    27 is 8 and *H* is the eighth letter in the alphabet.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在*大写*模式下，每个整数代表一个大写字母：整数除以27的余数表示字母表中的字母（其中1 = A，以此类推）。因此，在*大写*模式下，输入值143将产生字母*H*，因为143除以27的余数是8，而*H*是字母表中的第八个字母。
- en: The *lowercase* mode works the same but with lowercase letters; the remainder
    of dividing the integer by 27 represents the lowercase letter (1 = a and so on).
    So an input value of 56 in lowercase mode would yield the letter *b* because 57
    modulo 27 is 2 and *b* is the second letter in the alphabet.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*小写*模式的工作方式相同，但使用小写字母；将整数除以27的余数代表小写字母（1 = a，以此类推）。因此，在*小写*模式下，输入值56将产生字母*b*，因为57除以27的余数是2，而*b*是字母表中的第二个字母。'
- en: In *punctuation* mode, the integer is instead considered modulo 9, with the
    interpretation given by [Table 2-3](ch02.html#punctuation_decoding_mode "Table 2-3. Punctuation
    Decoding Mode") below. So 19 would yield an exclamation point because 19 modulo
    9 is 1.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在*标点符号*模式下，整数被视为模9，其解释如下[表2-3](ch02.html#punctuation_decoding_mode "表2-3. 标点符号解码模式")。因此，19会产生一个感叹号，因为19模9等于1。
- en: At the beginning of each message, the decoding mode is uppercase letters. Each
    time the modulo operation (by 27 or 9, depending on mode) results in 0, the decoding
    mode switches. If the current mode is uppercase, the mode switches to lowercase
    letters. If the current mode is lowercase, the mode switches to punctuation, and
    if it is punctuation, it switches back to uppercase.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息的开头，解码模式为大写字母。每次模运算（取决于模式，27或9）的结果为0时，解码模式会切换。如果当前模式是大写，则模式切换为小写字母。如果当前模式是小写，则模式切换为标点符号，如果当前模式是标点符号，则切换回大写。
- en: Table 2-3. Punctuation Decoding Mode
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3. 标点符号解码模式
- en: '| Number | Symbol |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | 符号 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | ! |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 1 | ! |'
- en: '| 2 | ? |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 2 | ? |'
- en: '| 3 | , |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 3 | , |'
- en: '| 4 | . |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 4 | . |'
- en: '| 5 | (space) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 5 | (空格) |'
- en: '| 6 | ; |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ; |'
- en: '| 7 | " |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 7 | " |'
- en: '| 8 | '' |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 8 | '' |'
- en: As with the Luhn validation formula, we’re going to walk through a concrete
    example to make sure we have all the steps straight. [Figure 2-4](ch02.html#sample_processing_for_the_ldecode_a_mess
    "Figure 2-4. Sample processing for the “Decode a Message” problem") demonstrates
    a sample decoding. The original input stream is shown at the top. The processing
    steps proceed from the top down. Column (a) shows the current number in the input.
    Column (b) is the current mode, cycling from uppercase (U) to lowercase (L) to
    punctuation (P). Column (c) shows the divisor for the current mode. Column (d)
    is the remainder of dividing the current divisor in column (c) into the current
    input from column (a). The result is shown in column (e), either a character or,
    if the result in (d) is 0, a switch to the next mode in the cycle.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与Luhn验证公式一样，我们将通过一个具体的例子来确保我们所有的步骤都是正确的。[图2-4](ch02.html#sample_processing_for_the_ldecode_a_mess
    "图2-4. “解码消息”问题的示例处理")演示了一个示例解码。原始输入流显示在顶部。处理步骤从上到下进行。列(a)显示输入中的当前数字。列(b)是当前模式，从大写(U)到小写(L)再到标点(P)循环。列(c)显示当前模式的除数。列(d)是列(c)中当前除数除以列(a)中当前输入的余数。结果显示在列(e)中，要么是一个字符，要么如果列(d)中的结果是0，则切换到循环中的下一个模式。
- en: 'As with the previous problem, we can start by explicitly considering the skills
    we’ll need to craft a solution. We need to read a string of characters until we
    reach an end-of-line. The characters represent a series of integers, so we need
    to read digit characters and convert them to integers for further processing.
    Once we have the integers, we need to convert the integer into a single character
    for output. Finally, we need some way to track the decoding mode so we know whether
    the current integer should be decoded into a lowercase letter, uppercase letter,
    or punctuation. Let’s turn this into a formal list:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个问题一样，我们可以先明确考虑我们需要构建解决方案所需的技能。我们需要读取一串字符，直到达到行尾。这些字符代表一系列整数，因此我们需要读取数字字符并将它们转换为整数以进行进一步处理。一旦我们有了整数，我们需要将整数转换为单个字符以输出。最后，我们需要某种方式来跟踪解码模式，以便我们知道当前整数应该解码为小写字母、大写字母还是标点符号。让我们将其转化为正式列表：
- en: Read character by character until we reach an end-of-line.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐字符读取，直到达到行尾。
- en: Convert a series of characters representing a number to an integer.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表示数字的字符序列转换为整数。
- en: Convert an integer 1–26 into an uppercase letter.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整数1-26转换为大写字母。
- en: Convert an integer 1–26 into a lowercase letter.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将整数1-26转换为小写字母。
- en: Convert an integer 1–8 into a punctuation symbol based on [Table 2-3](ch02.html#punctuation_decoding_mode
    "Table 2-3. Punctuation Decoding Mode").
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表[2-3](ch02.html#punctuation_decoding_mode "表2-3. 标点符号解码模式")将整数1-8转换为标点符号。
- en: Track a decoding mode.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪解码模式。
- en: The first item is something we already know how to do from the previous problem.
    Furthermore, although we only dealt with individual digits in the Luhn validation
    formula, I suspect some of what we did there will also be helpful on the second
    item of our list. The finished code for the Luhn algorithm is probably still fresh
    in your mind, but if you put the book down between that problem and this one,
    you’ll want to go back and review that code. In general, when the description
    of a current problem “rings bells,” you’ll want to dig out any similar code from
    your archives for study.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是我们已经从上一个问题中知道如何做的。此外，尽管我们在Luhn验证公式中只处理了单个数字，但我怀疑我们在那里所做的某些事情也将对我们列表的第二项有所帮助。Luhn算法的完成代码可能仍然在你的脑海中，但如果你在那个问题和这个问题之间放下这本书，你将想要回去复习那段代码。一般来说，当当前问题的描述“引起共鸣”时，你将想要从你的存档中挖掘出任何类似的代码进行研究。
- en: '![Sample processing for the “Decode a Message” problem](httpatomoreillycomsourcenostarchimages1273201.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![“解码信息”问题的示例处理](httpatomoreillycomsourcenostarchimages1273201.png.jpg)'
- en: Figure 2-4. Sample processing for the “Decode a Message” problem
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4. “解码信息”问题的示例处理
- en: Let’s get down to business on the items that remain. You may have noticed that
    I’ve made each of the conversions a separate item. I suspect that converting a
    number into a lowercase letter is going to be very similar to converting a number
    into an uppercase letter, but perhaps converting to a punctuation symbol will
    require something different. In any case, there’s no real downside to chopping
    up the list too finely; it just means you’ll be able to cross things off the list
    more often.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们着手处理剩余的项目。你可能已经注意到，我把每个转换都作为一个单独的项目。我怀疑将数字转换为小写字母将与将数字转换为大写字母非常相似，但将转换为标点符号可能需要不同的方法。无论如何，将列表切得太细并没有真正的缺点；这仅仅意味着你将更频繁地勾掉列表上的项目。
- en: 'Let’s start with those integer-to-character conversions. From the Luhn formula
    program, we know the code required to read a character digit 0–9 and convert it
    to an integer in the range 0–9\. How can we extend this method to deal with multidigit
    numbers? Let’s consider the simplest possibility: two-digit numbers. This looks
    straightforward. In a two-digit number, the first digit is the tens digit, so
    we should multiply this individual digit by 10, and then add the value of the
    second digit. For example, if the number were 35, after reading the individual
    digits as characters 3 and 5, and converting these to the integers 3 and 5, we
    would obtain the overall integer we need by the expression 3 * 10 + 5\. Let’s
    confirm this with code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从整数到字符的转换开始。从Luhn公式程序中，我们知道读取字符数字0–9并将其转换为0–9范围内的整数的代码。我们如何扩展这种方法来处理多位数呢？让我们考虑最简单的情况：两位数。这看起来很简单。在一个两位数中，第一位是十位，所以我们应该将这个单独的数字乘以10，然后加上第二位数字的值。例如，如果数字是35，在将单独的数字3和5作为字符读取，并将它们转换为整数3和5之后，我们就可以通过表达式3
    * 10 + 5得到所需的整体整数。让我们用代码来确认这一点：
- en: STORING CODE FOR LATER REUSE
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 存储代码以供以后重用
- en: The similarities between elements of the current problem and the previous problem
    show the importance of putting source code away in a manner that facilitates later
    review. Software developers talk a lot about code *reuse*, which occurs whenever
    you use pieces of old software to build new software. Often this involves using
    an encapsulated component or reusing source code verbatim. It’s just as important,
    though, to have easy access to prior solutions that you have written. Even if
    you aren’t copying old code outright, this allows you to reuse previously learned
    skills and techniques without having to relearn them. To maximize this benefit,
    strive to keep all the source code you write (mindful of any intellectual property
    agreements you may have with clients or employers, of course).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当前问题的元素与上一个问题的相似性表明了以方便以后审查的方式存储源代码的重要性。软件开发者经常谈论代码*重用*，这发生在你使用旧软件的片段来构建新软件的时候。这通常涉及到使用封装的组件或直接重用源代码。然而，轻松访问你以前编写过的解决方案同样重要。即使你并没有直接复制旧代码，这也允许你重用以前学到的技能和技术，而无需重新学习。为了最大限度地发挥这一优势，努力保持你编写的所有源代码（当然，要考虑到你可能与客户或雇主签订的任何知识产权协议）。
- en: Whether you receive full benefit from previously written programs, though, depends
    largely on the care you take to store them away; code you can't find is code you
    can't use. If you employ a step-by-step approach and write individual programs
    to test ideas separately before integrating them into the whole, make sure you
    save those intermediate programs, too. You may find it very convenient to have
    them available later when the similarity between your current program and the
    old program lies in one of the areas for which you wrote a test program.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你是否能从之前编写的程序中获得全部好处，很大程度上取决于你存储它们的细心程度；找不到的代码就是无法使用的代码。如果你采用逐步方法，并单独编写程序来测试想法，然后再将它们整合到整体中，确保你也保存这些中间程序。你可能会发现，当你的当前程序与旧程序相似之处在于你编写测试程序的一个区域时，这些中间程序将非常方便可用。
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That works—the program outputs same two-digit number that we put in. We encounter
    a problem, however, when we try to extend this method. This program uses two different
    variables to hold the two character inputs, and while that causes no problems
    here, we certainly don’t want to extend that as a general solution. If we did,
    we would need as many variables as we have digits. That would get messy, and it
    would be difficult to modify if the range of possible numbers in the input stream
    varied. We need a more general solution to this subproblem of converting characters
    to integers. The first step to finding that general solution is to reduce the
    previous code to just two variables—one `char` and one `int`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法是有效的——程序输出了我们输入的两个相同数字。然而，当我们尝试扩展这种方法时，我们会遇到问题。这个程序使用两个不同的变量来存储两个字符输入，虽然在这里没有问题，但我们当然不希望将其扩展为一个通用解决方案。如果我们这样做，我们需要与数字数量一样多的变量。这将变得混乱，如果输入流中可能数字的范围发生变化，修改起来也会很困难。我们需要一个更通用的解决方案来解决这个问题，即字符到整数的转换子问题。找到这个通用解决方案的第一步是将之前的代码简化为仅使用两个变量——一个`char`和一个`int`：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We accomplish this by doing all the calculations on the first digit before reading
    the second digit. After reading the first character digit ![](httpatomoreillycomsourcenostarchimages1273182.png)
    in one step, we convert to an integer, multiply by 10, and store the result ![](httpatomoreillycomsourcenostarchimages1273191.png).
    After reading the second digit ![](httpatomoreillycomsourcenostarchimages1273193.png),
    we add its integer value to the running total ![](httpatomoreillycomsourcenostarchimages1273195.png).
    This is equivalent to the previous code while using only two variables, one for
    the last character read and one for the overall value of the integer. The next
    step is to consider extending this method to three-digit numbers. Once we do that,
    we’re likely to see a pattern that will allow us to create a general solution
    for any number of digits.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在读取第二个数字之前先对第一个数字进行所有计算来完成这项任务。在一步中读取第一个字符数字 ![图片](http://atomoreilly.com/source/nostarch/images/1273182.png)，将其转换为整数，乘以10，并存储结果
    ![图片](http://atomoreilly.com/source/nostarch/images/1273191.png)。在读取第二个数字 ![图片](http://atomoreilly.com/source/nostarch/images/1273193.png)
    后，我们将它的整数值加到当前总和中 ![图片](http://atomoreilly.com/source/nostarch/images/1273195.png)。这相当于之前的代码，但只使用了两个变量，一个用于存储最后读取的字符，另一个用于存储整数的整体值。下一步是考虑将这种方法扩展到三位数。一旦我们做到了这一点，我们很可能会看到一种模式，这将使我们能够为任何位数的数字创建一个通用解决方案。
- en: 'When we try this, though, we encounter a problem. With the two-digit number,
    we multiplied the left digit by 10 because the left digit was in the tens position.
    The leftmost digit in a three-digit number would be in the hundreds position,
    so we would need to multiply that digit by 100\. Then we could read in the middle
    digit, multiply it by 10, add it to the running total, and then read in the last
    digit and add it, as well. That should work, but it’s not heading us in the direction
    of a general solution. Do you see the problem? Consider the previous statement:
    *The leftmost digit in a three-digit number would be in the hundreds position*.
    For a general solution, we won’t know how many digits are in each number until
    we reach the next comma. The leftmost digit in a number with an unknown quantity
    of digits can’t be labeled in the hundreds position or any other position. So
    how do we know what multiplier to use for each digit before adding to the running
    total? Or do we need another approach entirely?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，当我们尝试这样做时，我们会遇到一个问题。对于两位数，我们乘以左边的数字10，因为左边的数字在十位上。三位数中最左边的数字会在百位上，所以我们需要将这个数字乘以100。然后我们可以读取中间的数字，乘以10，将其加到运行总和中，然后读取最后一个数字并加到总和中。这应该可以工作，但它并没有引导我们走向一个通用的解决方案。你看到问题了吗？考虑前面的陈述：“三位数中最左边的数字会在百位上”。对于通用的解决方案，我们直到遇到下一个逗号之前都不会知道每个数字有多少位。一个未知数量的数字的最左边的数字不能标记在百位或其他任何位置上。那么我们如何在将数字加到运行总和中之前知道每个数字应该使用什么乘数？或者我们需要完全不同的方法？
- en: As always, when stuck, it’s a good idea to create a simplified problem to work
    on. The issue here is not knowing how many digits the number is going to have.
    The simplest problem that deals with this issue would be one that has just two
    possible digit counts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 总是，当我们陷入困境时，创建一个简化的、可以工作的简单问题是好主意。这里的问题是我们不知道数字将有多少位。处理这个问题的最简单问题就是只有一个可能的数字计数。
- en: 'Problem: Reading a number with three or four digits'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：读取三位或四位数的数字
- en: Write a program to read a number character by character and convert it to an
    integer, using just one `char` variable and one `int` variable. The number will
    have either three or four digits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，逐个读取数字字符并将其转换为整数，只使用一个`char`变量和一个`int`变量。这个数字将有三或四位。
- en: This issue of not knowing the count of characters until the end but needing
    the count right from the beginning is analogous to the issue in the Luhn formula.
    In the Luhn formula, we didn’t know whether the identification number had an odd
    or even length. In that case, our solution was to calculate the results two different
    ways and choose the appropriate one at the end. Could we do something like that
    here? If the number is either three or four digits, there are only two possibilities.
    If the number has three digits, the leftmost digit is the hundreds digit. If the
    number has four digits, the leftmost digit is the thousands digit. We could compute
    as if we had a three-digit number and as if we had a four-digit number and then
    choose the right number at the end, but the problem description allows us to have
    only one numeric variable. Let’s relax that restriction to make some progress.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题，即直到最后才知道字符的数量，但需要从一开始就需要知道数量，与Luhn公式的类似问题。在Luhn公式中，我们不知道识别号是奇数长度还是偶数长度。在这种情况下，我们的解决方案是两种不同的方式计算结果，并在最后选择合适的一种。我们能否在这里做类似的事情？如果数字是三位或四位，只有两种可能性。如果数字是三位，最左边的数字是百位。如果数字是四位，最左边的数字是千位。我们可以假设我们有一个三位数和一个四位数来计算，然后在最后选择正确的数字，但问题描述允许我们只有一个数字变量。让我们放宽这个限制，以便取得一些进展。
- en: 'Problem: Reading a number with three or four digits, further simplified'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：读取三位或四位数的数字，进一步简化
- en: Write a program to read a number character by character and convert it to an
    integer, using just one `char` variable and two `int` variables. The number will
    have either three or four digits.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，逐个读取数字字符并将其转换为整数，只使用一个`char`变量和两个`int`变量。这个数字将有三或四位。
- en: 'Now we can put the “compute it both ways” method to work. We’ll process the
    first three digits two different ways and then see whether there is a fourth digit:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将“两种方式计算”的方法付诸实践。我们将以两种不同的方式处理前三位数字，然后看看是否有一个第四位数字：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After reading the leftmost digit, we multiply its integer value by 100, and
    store it in our three-digit variable ![](httpatomoreillycomsourcenostarchimages1273182.png).
    We also multiply the integer value by 1,000, and store it in our four-digit variable
    ![](httpatomoreillycomsourcenostarchimages1273191.png). This pattern continues
    for the next two digits. The second digit is treated both as a tens digit in a
    three-digit number and as a hundreds digit in a four-digit number. The third digit
    is treated as both a ones and a tens digit. After reading the fourth character,
    we check to see whether it’s an end-of-line by comparing it to the number 10 ![](httpatomoreillycomsourcenostarchimages1273193.png)
    (as in the previous problem, this value may vary per operating system). If it
    is an end-of-line, the input was a three-digit number. If not, we still need to
    add the ones digit to the total ![](httpatomoreillycomsourcenostarchimages1273195.png).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取最左边的数字后，我们将它的整数值乘以100，并将其存储在我们的三位变量中！[](httpatomoreillycomsourcenostarchimages1273182.png)。我们还将整数值乘以1,000，并将其存储在我们的四位变量中！[](httpatomoreillycomsourcenostarchimages1273191.png)。这种模式会延续到下两个数字。第二个数字既被视为三位数中的十位数字，也视为四位数中的百位数字。第三个数字被视为个位和十位数字。在读取第四个字符后，我们通过将其与数字10！[](httpatomoreillycomsourcenostarchimages1273193.png)（如前一个问题中所述，此值可能因操作系统而异）进行比较来检查它是否是行尾。如果是行尾，则输入是一个三位数。如果不是，我们仍然需要将个位数加到总和中！[](httpatomoreillycomsourcenostarchimages1273195.png)。
- en: 'Now we need to figure out how to get rid of one of the integer variables. Suppose
    we removed the variable `fourDigitNumber` entirely. The value of `threeDigitNumber`
    would still be correctly assigned, but when we reached a point where we needed
    `fourDigitNumber`, we wouldn’t have it. Using the value in `threeDigitNumber`,
    is there some way to determine the value that would have been in `fourDigitNumber`?
    Suppose the original input was **`1234`**. After reading the first three digits,
    the value in `threeDigitNumber` would be 123; the value that would have been in
    `fourDigitNumber` is 1230\. In general, since the multipliers for `fourDigitNumber`
    are 10 times those of `threeDigitNumber`, the former would always be 10 times
    the latter. Thus, only one integer variable is needed because the other variable
    can just be multiplied by 10 if necessary:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找出如何去掉一个整数变量。假设我们完全删除了变量`fourDigitNumber`。`threeDigitNumber`的值仍然会被正确分配，但当我们需要`fourDigitNumber`时，我们就没有它了。使用`threeDigitNumber`中的值，我们能否确定`fourDigitNumber`将有的值？假设原始输入是**`1234`**。在读取前三个数字后，`threeDigitNumber`中的值将是123；`fourDigitNumber`将有的值是1230。一般来说，由于`fourDigitNumber`的乘数是`threeDigitNumber`的10倍，前者总是后者的10倍。因此，只需要一个整数变量，因为如果需要，另一个变量可以乘以10：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we have an exploitable pattern. Consider expanding this code to handle
    five-digit numbers. After computing the right value for the first four digits,
    we would repeat the same process we followed for reading the fourth character
    instead of displaying the result immediately: Read a fifth character, check to
    see whether it’s an end-of-line, display the previously computed number if it
    is—otherwise, multiply by 10, and add the digit value of the current character:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可利用的模式。考虑将此代码扩展以处理五位数。在计算前四位数字的正确值后，我们将重复我们用于读取第四个字符而不是立即显示结果的过程：读取第五个字符，检查它是否是行尾，如果是，则显示之前计算出的数字——否则，乘以10，并加上当前字符的数字值：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, we could easily expand the code to handle six-digit numbers
    or numbers with fewer digits. The pattern is clear: If the next character is another
    digit, multiply the running total by 10 before adding the integer digit value
    of the character. With this understanding, we can write a loop to handle a number
    of any length:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以轻松地扩展代码以处理六位数或位数更少的数字。模式很清晰：如果下一个字符是另一个数字，则在将字符的整数值添加到运行总和中之前，将运行总乘以10。有了这个理解，我们可以编写一个循环来处理任何长度的数字：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we read the first character ![](httpatomoreillycomsourcenostarchimages1273182.png),
    and determine its digit value ![](httpatomoreillycomsourcenostarchimages1273191.png).
    Then we read the second character ![](httpatomoreillycomsourcenostarchimages1273193.png)
    and reach the loop, where we check to see whether the most recently read character
    is an end-of-line ![](httpatomoreillycomsourcenostarchimages1273195.png). If not,
    we multiply the running total in the loop by 10, and add the current character’s
    digit value ![](httpatomoreillycomsourcenostarchimages1273197.png) before reading
    the next character ![](httpatomoreillycomsourcenostarchimages1273199.png). Once
    we reach the end-of-line, the running total variable `number` contains the integer
    value for us to output ![](httpatomoreillycomsourcenostarchimages1273203.png).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们读取第一个字符 ![](httpatomoreillycomsourcenostarchimages1273182.png)，并确定其数字值
    ![](httpatomoreillycomsourcenostarchimages1273191.png)。然后我们读取第二个字符 ![](httpatomoreillycomsourcenostarchimages1273193.png)
    并进入循环，检查最近读取的字符是否是行尾 ![](httpatomoreillycomsourcenostarchimages1273195.png)。如果不是，我们在循环中将运行总乘以
    10，并在读取下一个字符之前将当前字符的数字值 ![](httpatomoreillycomsourcenostarchimages1273197.png)
    加上。一旦我们到达行尾，运行总变量 `number` 就包含了我们要输出的整数值 ![](httpatomoreillycomsourcenostarchimages1273203.png)。
- en: 'That handles the conversion of one series of characters to its integer equivalent.
    In the final program, we’ll be reading a series of numbers, separated by commas.
    Each number will have to be separately read and processed. As always, it’s best
    to start by thinking about a simple situation that demonstrates the issue. Let’s
    consider the input **`101,22[EOL]`**, where **`[EOL]`** is explicitly marking
    the end-of-line for clarity. It would be enough to modify the test condition of
    the loop to check for either the end-of-line character or a comma. Then we would
    need to place all the code that processes one number inside a larger loop that
    continues until all the numbers have been read. So the inner loop should stop
    for **`[EOL]`** or a comma, but the outer loop should stop only for **`[EOL]`**:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了将一系列字符转换为它的整数等价的过程。在最终的程序中，我们将读取一系列由逗号分隔的数字。每个数字都必须单独读取和处理。像往常一样，最好先考虑一个简单的情况，以展示这个问题。让我们考虑输入
    **`101,22[EOL]`**，其中 **`[EOL]`** 明确标记行尾以增强清晰度。修改循环的测试条件以检查行尾字符或逗号就足够了。然后我们需要将处理一个数字的所有代码放置在一个更大的循环中，该循环会一直持续到读取所有数字。因此，内循环应该在遇到
    **`[EOL]`** 或逗号时停止，但外循环只应该在遇到 **`[EOL]`** 时停止：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is another great example of the importance of small steps. Although this
    is a short program, the wheels-within-wheels nature of the double loop would have
    made for tricky code if we had tried to write this from scratch. It’s straightforward,
    though, when we arrive at this code by taking a step from the previous program.
    The declaration of `digitChar` ![](httpatomoreillycomsourcenostarchimages1273182.png)
    is moved to a separate line so that the declaration is in scope throughout the
    code. The rest of the code is the same as the previous listing, except that it’s
    placed inside a `do-while` loop that continues until we reach the end-of-line
    ![](httpatomoreillycomsourcenostarchimages1273191.png).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是小步骤重要性的一个绝佳例子。尽管这是一个简短的程序，但如果我们从零开始编写，双循环的嵌套特性会让代码变得复杂。然而，当我们从上一个程序逐步过渡到这个代码时，它就变得简单直接了。`digitChar`
    的声明 ![](httpatomoreillycomsourcenostarchimages1273182.png) 被移动到单独一行，这样声明的范围就覆盖了整个代码。其余的代码与之前的列表相同，只是它被放置在一个
    `do-while` 循环中，该循环会一直持续到我们到达行尾 ![](httpatomoreillycomsourcenostarchimages1273191.png)。
- en: 'With that part of the solution in place, we can focus on processing the individual
    numbers. The next item on our list is converting a number 1–26 to a letter A–Z.
    If you think about it, this is actually a reversal of the process we used to convert
    the individual digit characters to their integer equivalents. If we subtract the
    character code for 0 to translate from the 0–9 character code range to the 0–9
    integer range, we should be able to add a character code to translate from 1–26
    to A–Z. What if we added `''A''`? Here’s an attempt along with a sample input
    and output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案的这一部分就绪后，我们可以专注于处理单个数字。我们列表中的下一个项目是将数字 1–26 转换为字母 A–Z。如果你这么想，这实际上是我们用来将单个数字字符转换为它们整数等价的过程的逆过程。如果我们从
    0 的字符代码中减去，以将 0–9 的字符代码范围转换为 0–9 的整数范围，我们应该能够添加一个字符代码，以将 1–26 转换为 A–Z。如果我们添加 `'A'`
    会怎样？这里有一个尝试，包括一个示例输入和输出：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That’s not quite right. The fifth letter of the alphabet is E, not F. The problem
    occurs because we are adding a number in the range that starts from 1\. When we
    were converting in the other direction, from a character digit to its integer
    equivalent, we were dealing with a range that started from 0\. We can fix this
    problem by changing the computation ![](httpatomoreillycomsourcenostarchimages1273182.png)
    from `number + 'A'` to `number + 'A' - 1`. Note that we could look up the character
    code value for the letter A (it’s 65 in ASCII) and simply use one less than that
    value (for example, `number + 64` in ASCII). I prefer the first version, though,
    because it’s more readable. In other words, if you come back to look at this code
    later, you can more quickly remember what `number + 'A' - 1` does than what `number
    + 64` does because the appearance of `'A'` in the former will remind you of converting
    to uppercase letters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不完全正确。字母表的第五个字母是 E，而不是 F。问题发生是因为我们在从 1 开始的范围内添加一个数字。当我们从字符数字转换为其整数等效值时，我们处理的是一个从
    0 开始的范围。我们可以通过将计算方式从 `number + 'A'` 改为 `number + 'A' - 1` 来解决这个问题。注意，我们可以查找字母
    A 的字符代码值（在 ASCII 中是 65）并简单地使用该值减一（例如，ASCII 中的 `number + 64`）。尽管如此，我更喜欢第一种版本，因为它更易读。换句话说，如果你稍后回来看这段代码，你更容易记住
    `number + 'A' - 1` 做了什么，而不是 `number + 64` 做了什么，因为前者中的 `'A'` 会让你想起转换为大写字母。
- en: 'Having sorted that out, we can easily adapt this idea to convert to lowercase
    letters by changing the computation ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to `number + ''a'' - 1`. The punctuation table conversion is not as concise because
    the punctuation symbols in the table do not appear in that order in ASCII or any
    other character code system. As such, we’re going to have to handle this through
    brute force:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了这个问题后，我们可以轻松地将这个想法适应为转换为小写字母，只需将计算方式从 `number + 'A'` 改为 `number + 'a' - 1`。标点符号表转换并不那么简洁，因为表中的标点符号在
    ASCII 或任何其他字符代码系统中并不按那个顺序出现。因此，我们不得不通过暴力方法来处理这个问题：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we’ve used a switch statement ![](httpatomoreillycomsourcenostarchimages1273182.png)
    to output the correct punctuation character. Note that a backslash has been employed
    as an “escape” in order to display the single quote ![](httpatomoreillycomsourcenostarchimages1273191.png).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个 switch 语句 `![](httpatomoreillycomsourcenostarchimages1273182.png)`
    来输出正确的标点符号字符。注意，已经使用反斜杠作为“转义”来显示单引号 `![](httpatomoreillycomsourcenostarchimages1273191.png)`。
- en: 'We have one last subproblem to tackle before putting everything together: switching
    from mode to mode whenever the most recent value decodes to 0\. Remember that
    the problem description requires us to modulo each integer value by 27 (if we
    are currently in the uppercase mode or lowercase mode) or 9 (if we are in punctuation
    mode). When the result is 0, we switch to the next mode. What we need is a variable
    to store the current mode and logic inside our “read and process the next value”
    loop to switch modes if necessary. The variable tracking the current mode could
    be a simple integer, but it’s more readable to use an enumeration. A good rule
    of thumb: If a variable is only tracking a state and there is no inherent meaning
    to any particular value, an enumeration is a good idea. In this case, we could
    have a variable `int mode` arbitrarily say that the value of 1 means uppercase,
    2 means lowercase, and 3 means punctuation. There’s no inherent reason, however,
    why those values are chosen. When we come back to look at the code later, we’ll
    have to reacquaint ourselves with the system to make sense of a statement such
    as `if (mode == 2)`. If we use an enumeration—as in the statement `(mode == -LOWERCASE)`—there
    is nothing for us to remember because it’s all spelled out. Here’s the code that
    results from this idea, along with a sample interaction:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有内容整合在一起之前，我们还有一个子问题需要解决：当最新的值解码为0时，我们需要在模式之间切换。记住，问题描述要求我们将每个整数值除以27（如果我们目前处于大写模式或小写模式）或9（如果我们处于标点模式）。当结果是0时，我们切换到下一个模式。我们需要一个变量来存储当前模式，并在“读取和处理下一个值”的循环中添加逻辑以在必要时切换模式。跟踪当前模式的变量可以是一个简单的整数，但使用枚举会更易读。一个好的经验法则是：如果一个变量只跟踪一个状态，并且没有任何特定值具有固有的意义，那么使用枚举是一个好主意。在这种情况下，我们可以有一个变量`int
    mode`任意指定值为1表示大写，2表示小写，3表示标点。然而，选择这些值并没有固有的理由。当我们稍后回过头来看代码时，我们需要重新熟悉系统才能理解像`if
    (mode == 2)`这样的语句。如果我们使用枚举——就像在语句`(mode == -LOWERCASE)`中一样——我们不需要记住任何东西，因为所有内容都明确地写出来了。以下是这个想法产生的代码，以及一个示例交互：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have crossed off everything on our list, so now it’s time to integrate these
    individual code listings to make a solution for the overall program. We could
    approach this integration in different ways. We might put just two pieces together
    and build up from there. For example, we could combine the code to read and convert
    the comma-separated numbers with the mode switching from the most recent listing.
    Then we could test that integration and add the code to convert each number to
    the appropriate letter or punctuation symbol. Or we could build up in the other
    direction, taking the number-to-character listing and turning it into a series
    of functions to be called from the main program. At this point, we’ve mostly moved
    beyond problem solving into software engineering, which is a different subject.
    We made a series of blocks—that was the hard part—and now we just have to assemble
    them, as shown in [Figure 2-5](ch02.html#the_assembled_solution_to_the_ldecode_a
    "Figure 2-5. The assembled solution to the “Decode a Message” problem").
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从清单上划掉了所有的事项，现在到了将这些单独的代码列表整合成一个整体程序解决方案的时候了。我们可以用不同的方法来处理这个整合。我们可能只是将两块代码放在一起，然后从那里开始构建。例如，我们可以将读取和转换逗号分隔数字的代码与从最新列表中切换模式的代码结合起来。然后我们可以测试这个整合，并添加将每个数字转换为相应的字母或标点符号的代码。或者我们可以从另一个方向开始构建，将数字到字符的列表转换成一系列从主程序中调用的函数。在这个阶段，我们基本上已经从问题解决过渡到了软件工程，这是一个不同的主题。我们制作了一系列的模块——这是难点所在——现在我们只需要将它们组装起来，如图[图2-5](ch02.html#the_assembled_solution_to_the_ldecode_a
    "图2-5. 对“解码信息”问题的整体解决方案")所示。
- en: Almost every line in this program was extracted from previous code in this section.
    The bulk of the code ![](httpatomoreillycomsourcenostarchimages1273182.png) comes
    from the mode-switching program. The central processing loop ![](httpatomoreillycomsourcenostarchimages1273191.png)
    comes from our code to read a series of comma-delimited numbers character by character.
    Finally, you’ll recognize the code that converts the integers into uppercase letters,
    lowercase letters, and punctuation ![](httpatomoreillycomsourcenostarchimages1273195.png).
    The small amount of new code is marked by ![](httpatomoreillycomsourcenostarchimages1273193.png).
    The `continue` statements skip us to the next iteration of the loop when the last
    input was a mode-switch command, skipping the `cout << outputCharacter` at the
    end of the loop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段程序中的几乎每一行都是从本节之前的代码中提取出来的。大部分代码 ![来自模式切换程序](httpatomoreillycomsourcenostarchimages1273182.png)。核心处理循环
    ![来自读取一系列以逗号分隔的数字的代码](httpatomoreillycomsourcenostarchimages1273191.png)。最后，你会认出将整数转换为大写字母、小写字母和标点符号的代码
    ![来自这里](httpatomoreillycomsourcenostarchimages1273195.png)。少量新代码用 ![标记](httpatomoreillycomsourcenostarchimages1273193.png)。当最后一个输入是模式切换命令时，`continue`
    语句会跳过循环的下一个迭代，跳过循环末尾的 `cout << outputCharacter`。
- en: '![The assembled solution to the “Decode a Message” problem](httpatomoreillycomsourcenostarchimages1273205.png.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![“解码信息”问题的解决方案](httpatomoreillycomsourcenostarchimages1273205.png.jpg)'
- en: Figure 2-5. The assembled solution to the “Decode a Message” problem
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5. “解码信息”问题的解决方案
- en: While this is a cut-and-paste job, this is the *good* kind of cut-and-paste
    job, where you reuse the code you just wrote and therefore completely understand
    it. As before, think about how easy each step was in this process, versus trying
    to write the final listing from scratch. Undoubtedly, a good programmer could
    produce the final listing without going through the intermediate steps, but there
    would be false steps, times when the code looks ugly, and lines of code commented
    out and then put back again. By taking the smaller steps, all the dirty work gets
    done early, and the code never gets too ugly because the code we’re currently
    working with never gets long or complicated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一项剪切和粘贴的工作，但这是一种 *好的* 剪切和粘贴工作，因为你重用了你刚刚编写的代码，因此完全理解它。就像之前一样，想想在这个过程中每一步有多容易，与从头开始编写最终列表相比。毫无疑问，一个优秀的程序员可以在不经过中间步骤的情况下生成最终的列表，但会有错误的步骤，代码看起来很丑陋，以及被注释掉然后又放回的代码行。通过采取较小的步骤，所有脏活都早早完成，代码永远不会太丑陋，因为我们目前正在处理的代码永远不会太长或太复杂。
- en: Conclusion
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter, we looked at three different problems. In one sense, we had
    to take three different paths to solve them. In another sense, we took the same
    route each time because we used the same basic technique of breaking up the problem
    into components; writing code to solve those components individually; and then
    using the knowledge gained from writing the programs, or even directly using lines
    of code from the programs, to solve the original problem. In the chapters that
    follow, we won’t use this method explicitly for each problem, but the fundamental
    idea is always there: to chop up the problem into manageable pieces.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了三个不同的问题。从某种意义上说，我们必须采取三条不同的路径来解决它们。从另一种意义上说，我们每次都采取了相同的路线，因为我们使用了相同的基本技术，即将问题分解成组件；编写代码来解决这些组件；然后利用编写程序获得的知识，甚至直接使用程序中的代码行来解决原始问题。在接下来的章节中，我们不会针对每个问题明确使用这种方法，但基本思想始终存在：将问题分解成可管理的部分。
- en: Depending on your background, these problems may have initially appeared to
    lie anywhere on the difficulty spectrum from fiendish to trivial. Regardless of
    how difficult a problem initially seems, I would recommend using this technique
    on each new problem you face. You don’t want to wait until you reach a frustratingly
    difficult problem before trying out a new technique. Remember that one of the
    goals of this text is for you to develop confidence in your ability to solve problems.
    Practice using the techniques on “easy” problems and you’ll have lots of momentum
    for when you hit the hard ones.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的背景，这些问题最初可能看起来在难度谱上从极其困难到极其简单都有可能。无论一个问题最初看起来有多困难，我都建议你在面对每个新问题时都使用这种技术。你不想等到遇到一个令人沮丧的困难问题之前才尝试新方法。记住，这本书的一个目标就是让你对自己的问题解决能力充满信心。在“简单”问题上练习使用这些技术，当你遇到困难问题时，你会有很多动力。
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: As before, I urge you to try as many exercises as you can stand. Now that we
    are fully into the actual programming, working through exercises is essential
    for you to develop your problem-solving skills.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我强烈建议你尽可能多地尝试练习。现在我们已经完全进入实际的编程阶段，通过练习来发展你的问题解决能力是至关重要的。
- en: 'Using the same rule as the shapes programs from earlier in the chapter (only
    two output statements—one that outputs the hash mark and one that outputs an end-of-line),
    write a program that produces the following shape:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章前面形状程序相同的规则（只有两个输出语句——一个输出井号，另一个输出行尾），编写一个生成以下形状的程序：
- en: '[PRE30]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or how about:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者如何：
- en: '[PRE31]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here’s an especially tricky one:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个特别棘手的问题：
- en: '[PRE32]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Design your own: Think up your own symmetrical pattern of hash marks, and see
    whether you can write a program to produce it that follows the shapes rule.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你自己的：想出一个由井号标记组成的对称图案，然后看看你是否能编写一个遵循形状规则的程序来生成它。
- en: If you like the Luhn formula problem, try writing a program for a different
    check-digit system, like the 13-digit ISBN system. The program could take an identification
    number and verify it or take a number without its check digit and generate the
    check digit.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你喜欢Luhn公式问题，尝试编写一个程序来处理不同的校验位系统，比如13位的ISBN系统。程序可以接受一个识别号并验证它，或者接受一个不带校验位的数字并生成校验位。
- en: If you’ve learned about binary numbers and how to convert from decimal to binary
    and the reverse, try writing programs to do those conversions with unlimited length
    numbers (but you can assume the numbers are small enough to be stored in a standard
    C++ `int`).
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经学过二进制数以及如何将十进制数转换为二进制数和反向转换，尝试编写程序以无限长度数字（但你可以假设数字足够小，可以存储在标准的C++ `int`中）来进行这些转换。
- en: Have you learned about hexadecimal? Try writing a program that lets the user
    specify an input in binary, decimal, or hexadecimal, and output in any of the
    three.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经学过十六进制了吗？尝试编写一个程序，让用户指定输入为二进制、十进制或十六进制，并以任意一种输出。
- en: Want an extra challenge? Generalize the code for the previous exercise to make
    a program that converts from any number base-16 or less to any other number base.
    So, for example, the program could convert from base-9 to base-4.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想要一个额外的挑战？将前面练习的代码泛化，制作一个可以将任何16进制或更小的数制转换为任何其他数制的程序。例如，程序可以将9进制转换为4进制。
- en: Write a program that reads a line of text, counting the number of words, identifying
    the length of the longest word, the greatest number of vowels in a word, and/or
    any other statistics you can think of.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，读取一行文本，计算单词数量，识别最长单词的长度，一个单词中最大的元音数量，以及/或你可以想到的任何其他统计数据。
