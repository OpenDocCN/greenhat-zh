- en: Part III. A Glimpse of Things to Come
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。未来的展望
- en: Following nearly a decade of stagnation, the world of browsers is once more
    a raging battlefield. In a manner all too reminiscent of the First Browser Wars
    in the late 1990s, vendors compete by bringing new features to market monthly.
    The main difference is that security is now seen as a clear selling point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 经过近十年的停滞，浏览器世界再次成为了一场激烈的战场。这让人不禁联想到20世纪90年代末的第一场浏览器大战，厂商们通过每月推出新功能来竞争。主要的不同之处在于，现在安全性被视为一个明显的卖点。
- en: Of course, objectively measuring the robustness of any sufficiently complex
    piece of software is an unsolved problem in computing, doubly so if your codebase
    happens to carry almost two decades worth of bloat. Therefore, much of the competitive
    effort goes into inventing and then rapidly deploying new security-themed additions,
    often with little consideration for how well they actually solve the problem they
    were supposed to address.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，客观地衡量任何足够复杂的软件的健壮性是计算机科学中的一个未解问题，如果你的代码库恰好承载了近二十年的膨胀，那就更是如此。因此，大部分的竞争努力都投入到发明并迅速部署新的以安全为主题的新增功能中，往往很少考虑它们实际上解决他们应该解决的问题的能力。
- en: In the meantime, standards bodies, mindful of their earlier misadventures, have
    ditched much of their academic rigor in favor of just letting a dedicated group
    of contributors tweak the specifications as they see fit. There is talk of making
    HTML5 the last numbered version of the standard and transitioning to a living
    document that changes every day—often radically. The relaxation of the requirement
    has helped keep ongoing much of the work around W3C and WHATWG, but it has also
    undermined some of the benefits of having a central organization to begin with.
    Many recent proposals gravitate toward quick, narrowly scoped hacks that do not
    even try to form a consistent and well-integrated framework. When this happens,
    no robust feedback mechanism is in place to allow external experts to review reasonably
    stable specifications and voice concerns before any implementation work takes
    place. The only way to stay on top of the changes is to immerse oneself in the
    day-to-day dynamics of the working group.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，考虑到他们早期的失误，标准机构已经放弃了大部分学术上的严谨性，转而让一群专门的贡献者根据他们的看法调整规范。有传言称，将HTML5作为标准的最后一个编号版本，并过渡到一个每天都会变化——通常是根本性变化——的活文档。放宽要求有助于保持W3C和WHATWG周围的大部分工作持续进行，但也削弱了拥有一个中心组织的一些好处。许多最近的提案都倾向于快速、范围狭窄的修补，甚至不试图形成一个一致且高度集成的框架。当这种情况发生时，没有稳健的反馈机制来允许外部专家在实施工作开始之前合理地审查稳定规范并表达担忧。跟上变化的唯一方法就是沉浸在工作组的日常动态中。
- en: It is difficult to say if this new approach to standardization is a bad thing.
    In fact, its benefits may easily outweigh any of the speculative risks; for one,
    we now have a chance at a standard that is reasonably close to what browsers actually
    do. Nevertheless, the results of this frantic and largely unsupervised process
    can be unpredictable, and they require the security community to be very alert.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 很难说这种新的标准化方法是否是坏事。事实上，它的好处可能轻易地超过任何推测性的风险；首先，我们现在有机会得到一个与浏览器实际操作相当接近的标准。尽管如此，这个疯狂且很大程度上不受监督的过程的结果可能是不可预测的，这要求安全社区保持高度警惕。
- en: In this spirit, the last part of the book will explore some of the more plausible
    and advanced proposals that may shape the future of the Web . . . or that may
    just as likely end up in the dustbin of history a few years from now.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种精神下，本书的最后一部分将探讨一些更合理和先进的建议，这些建议可能会塑造Web的未来……或者也可能在几年后最终被历史垃圾箱所淘汰。
- en: Chapter 16. New and Upcoming Security Features
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。新和即将推出的安全功能
- en: You will soon find out that there is little rhyme and reason to how all the
    new browser features mesh, but we still need to organize the discussion in some
    way. Perhaps the best approach is to look at their intended purposes and begin
    with all the mechanisms created specifically to tweak the Web’s security model
    for a well-defined gain.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会意识到所有这些新浏览器功能之间的结合几乎没有规律和理由，但我们仍然需要以某种方式组织讨论。也许最好的方法就是看看它们的预期目的，并从专门为调整Web的安全模型以获得明确收益而创建的所有机制开始。
- en: The dream of inventing a brand-new browser security model is strong within the
    community, but it is always followed by the realization that it would require
    rebuilding the entire Web. Therefore, much of the practical work focuses on more
    humble extensions to the existing approach, necessarily increasing the complexity
    of the security-critical sections of the browser codebase. This complexity is
    unwelcome, but its proponents invariably see it as justified, whether because
    they aim to mitigate a class of vulnerabilities, build a stopgap for some other
    hard problem that nobody wants to tackle right now,^([[77](#ftn.CHP-16-FN-1)])
    or simply enable new types of applications to be built in the future. All these
    benefits usually trump the vague risk.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 社区内强烈渴望发明一种全新的浏览器安全模型，但随之而来的是意识到这将需要重建整个网络。因此，大部分实际工作都集中在对现有方法的更谦逊扩展上，这不可避免地增加了浏览器代码库中安全关键部分复杂性。这种复杂性不受欢迎，但它的支持者总是认为这是合理的，无论是为了减轻一类漏洞，还是为了为一些其他难以解决的问题提供一个临时的解决方案，或者简单地为了在未来能够构建新的应用程序类型。所有这些好处通常都超过了模糊的风险。
- en: Security Model Extension Frameworks
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全模型扩展框架
- en: Some of the most successful security enhancements proposed in the past few years
    boil down to adding flexibility to the original constraints imposed by the same-origin
    policy and its friends. For example, one formerly experimental proposal that has
    now crossed into the mainstream is the *postMessage(...)* API for communicating
    across origins, discussed in [Chapter 9](ch09.html "Chapter 9. Content Isolation
    Logic"). Surprisingly, the act of relaxing SOP checks in certain carefully chosen
    scenarios is more intuitive and less likely to cause problems than locking the
    policy down. So, to begin on a lighter note, we’ll focus on this class of frameworks
    first.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，一些最成功的安全增强措施归结为向由同源策略及其相关策略强加的原始约束中增加灵活性。例如，一个曾经是实验性的提议现在已经进入主流，那就是用于跨源通信的
    *postMessage(...)* API，这在[第9章](ch09.html "第9章。内容隔离逻辑")中有讨论。令人惊讶的是，在某些精心选择的场景中放松SOP检查的行为比锁定策略更为直观，也更不容易引起问题。因此，为了轻松开始，我们将首先关注这类框架。
- en: Cross-Domain Requests
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域请求
- en: Under the original constraints of the same-origin policy, scripts associated
    with one origin have no clean and secure way to communicate with client-side scripts
    executing in any other origin and no safe way to retrieve potentially useful data
    from a willing third-party server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在同源策略的原始约束下，与一个源关联的脚本没有干净且安全的方式与在任何其他源中执行的客户端脚本通信，也没有从愿意提供数据的第三方服务器中检索潜在有用数据的安全方式。
- en: Web developers have long complained about these constraints, and in recent years,
    browser vendors have begun to listen to their demands. As you recall, the more
    pressing task of arranging client-side communications between scripts was solved
    with *postMessage(...)*. The client-to-server scenario was found to be less urgent
    and still awaits a canonical solution, but there has been some progress to report.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络开发者长期以来一直抱怨这些约束，近年来，浏览器供应商开始倾听他们的需求。如您所忆，通过 *postMessage(...)* 解决了在脚本之间安排客户端通信的紧迫任务。客户端到服务器的场景被认为不那么紧急，但仍需一个标准化的解决方案，但已有一些进展可以报告。
- en: The most successful attempt to create a method for retrieving documents from
    non-same-origin servers began in 2005\. Under the auspices of W3C, several developers
    working on VoiceXML, an obscure document format for building Interactive Voice
    Response (IVR) systems, drafted a proposal for *Cross-Origin Resource Sharing
    (CORS)*.^([[240](pr03.html#ftn.CHP-16-FT-1)]) Between 2007 and 2009, their awkward,
    XML-based design gradually morphed into a much simpler and more widely useful
    scheme, which relied on HTTP header-level signaling to communicate consent to
    cross-origin content retrieval using a natural extension of the *XMLHttpRequest*
    API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建从非同源服务器检索文档的方法最成功的尝试始于2005年。在W3C的赞助下，几位在开发用于构建交互式语音响应（IVR）系统的神秘文档格式VoiceXML的开发者，起草了一个关于
    *跨源资源共享（CORS）* 的提议。[240](pr03.html#ftn.CHP-16-FT-1)]。在2007年至2009年之间，他们笨拙的基于XML的设计逐渐演变成一个更简单、更广泛有用的方案，该方案依赖于HTTP头部级别的信号来通过
    *XMLHttpRequest* API的自然扩展来传达对跨源内容检索的同意。
- en: CORS Request Types
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CORS 请求类型
- en: As specified today, CORS relies on differentiating between two types of calls
    to the *XMLHttpRequest* API. When the site attempts to load a cross-origin document
    through the API, the browser first needs to distinguish between *simple requests*,
    where the resulting HTTP traffic is deemed close enough to what can be generated
    through other, existing methods of navigation, and *non-simple requests*, which
    encompass everything else. The operation of these two classes of requests vary
    significantly, as we’ll see.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如今天所指定，CORS 依赖于区分对 *XMLHttpRequest* API 的两种调用类型。当网站尝试通过 API 加载跨源文档时，浏览器首先需要区分
    *简单请求*，其中生成的 HTTP 流量被认为足够接近通过其他现有导航方法生成的流量，以及 *非简单请求*，它包括所有其他内容。这两类请求的操作差异很大，正如我们将看到的。
- en: 'The current specification says that simple requests must have a method of GET,
    POST, or HEAD. Additionally, if any custom headers are specified by the caller,
    they must belong to the following set:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当前规范表示，简单请求必须具有 GET、POST 或 HEAD 方法。此外，如果调用者指定了任何自定义标头，它们必须属于以下集合：
- en: '*Cache-Control*'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cache-Control*'
- en: '*Content-Language*'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Content-Language*'
- en: '*Content-Type*'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Content-Type*'
- en: '*Expires*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Expires*'
- en: '*Last-Modified*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Last-Modified*'
- en: '*Pragma*'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pragma*'
- en: Today, browsers that support CORS simply do not allow methods other than GET,
    POST, and HEAD. At the same time, they ignore the recommended whitelist of headers,
    unconditionally demoting any requests with custom header values to non-simple
    status. The implementation in WebKit also considers any payload-bearing requests
    to be non-simple. (It is not clear whether this is an intentional design decision
    or a bug.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，支持 CORS 的浏览器简单地不允许除 GET、POST 和 HEAD 之外的方法。同时，它们忽略了推荐的标头白名单，无条件地将任何具有自定义标头值的请求降级为非简单状态。WebKit
    的实现还将任何携带有效载荷的请求视为非简单请求。（不清楚这是有意的设计决策还是错误。）
- en: Security Checks for Simple Requests
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单请求的安全检查
- en: The CORS specification allows simple requests to be submitted to the destination
    server immediately, without attempting to confirm whether the destination is willing
    to engage in cross-domain communications to begin with. This decision is based
    on the fact that the attacker may initiate fairly similar cookie-authenticated
    traffic by other means (for example, by automatically submitting a form) and,
    therefore, that there is no point in introducing an additional handshake specifically
    for CORS.^([[78](#ftn.CHP-16-FN-2)])
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 规范允许简单请求立即提交给目标服务器，而无需尝试确认目标是否愿意首先进行跨域通信。这个决定基于这样一个事实，攻击者可以通过其他手段（例如，通过自动提交表单）发起相当相似的基于
    cookie 认证的流量，因此引入专门用于 CORS 的额外握手是没有意义的。（^[[78](#ftn.CHP-16-FN-2)]）
- en: 'The crucial security check is carried out only after the response is retrieved
    from the server: The data is revealed to the caller through the *XMLHttpRequest*
    API only if the response includes a suitable, well-formed *Access-Control-Allow-Origin*
    header. To assist the server, the original request will include a mandatory *Origin*
    header, specifying the origin associated with the calling script.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的安全检查仅在从服务器检索到响应后进行：只有当响应包含合适的、格式良好的 *Access-Control-Allow-Origin* 标头时，数据才会通过
    *XMLHttpRequest* API 向调用者揭示。为了协助服务器，原始请求将包括一个强制性的 *Origin* 标头，指定与调用脚本关联的源。
- en: 'To illustrate this behavior, consider the following cross-domain *XMLHttpRequest*
    call performed from [http://www.bunnyoutlet.com/](http://www.bunnyoutlet.com/):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种行为，考虑以下从 [http://www.bunnyoutlet.com/](http://www.bunnyoutlet.com/) 发起的跨域
    *XMLHttpRequest* 调用：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result will be an HTTP request that looks roughly like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个大致如下所示的 HTTP 请求：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To indicate that the response should be readable across domains, the server
    needs to respond with
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指示响应应在跨域中可读，服务器需要响应如下：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is possible to use a wildcard (“*”) in *Access-Control-Allow-Origin*, but
    do so with care. It is certainly unwise to indiscriminately set *Access-Control-Allow-Origin:
    ** on all HTTP responses, because this step largely eliminates any assurances
    of the same-origin policy in CORS-compliant browsers.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '在 *Access-Control-Allow-Origin* 中使用通配符（“*”）是可能的，但请谨慎操作。在所有 HTTP 响应中无差别地设置 *Access-Control-Allow-Origin:
    ** 是不明智的，因为这步在很大程度上消除了 CORS 兼容浏览器中同源策略的任何保证。'
- en: Non-simple Requests and Preflight
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非简单请求和预检
- en: 'In the early drafts of the CORS protocol, almost all requests were meant to
    be submitted without first checking to see if the server was actually willing
    to accept them. Unfortunately, this design undermined an interesting property
    leveraged by some web applications to prevent cross-site request forgery: Prior
    to CORS, attackers could not inject arbitrary HTTP headers into cross-domain requests,
    so the presence of a custom header often served as a proof that the request came
    from the same origin as the destination and was issued through *XMLHttpRequest*.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CORS 协议的早期草案中，几乎所有请求都旨在在没有首先检查服务器是否实际上愿意接受它们的情况下提交。不幸的是，这种设计破坏了某些网络应用利用的一个有趣特性，以防止跨站请求伪造：在
    CORS 之前，攻击者无法将任意 HTTP 头部注入跨域请求中，因此自定义头部的存在通常作为请求来自与目标相同的源并且是通过 *XMLHttpRequest*
    发出的证明。
- en: 'Later CORS revisions corrected this problem by requiring a more complicated
    two-step handshake for requests that did not meet the strict “simple request”
    criteria outlined in [CORS Request Types](ch16.html#cors_request_types "CORS Request
    Types") in [Security Model Extension Frameworks](ch16.html#security_model_extension_frameworks
    "Security Model Extension Frameworks"). The handshake for non-simple requests
    aims to confirm that the destination server is CORS compliant and that it wants
    to receive nonstandard traffic from that particular caller. The handshake is implemented
    by sending a vanilla OPTIONS request (“preflight”) to the target URL containing
    an outline of the parameters of the underlying *XMLHttpRequest* call. The most
    important information is conveyed to the server in three self-explanatory headers:
    *Origin*, *Access-Control-Request-Method*, and *Access-Control-Request-Headers*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的 CORS 修订通过要求一个更复杂的两步握手来纠正这个问题，该握手适用于不符合 [CORS 请求类型](ch16.html#cors_request_types
    "CORS 请求类型") 中概述的严格“简单请求”标准的请求，这些标准在 [安全模型扩展框架](ch16.html#security_model_extension_frameworks
    "安全模型扩展框架") 中。非简单请求的握手旨在确认目标服务器符合 CORS 规范，并且它希望接收来自特定调用者的非标准流量。握手是通过向目标 URL 发送一个包含底层
    *XMLHttpRequest* 调用参数概述的纯 OPTIONS 请求（“预检”）来实现的。最重要的信息通过三个自解释的头部传递给服务器：*Origin*、*Access-Control-Request-Method*
    和 *Access-Control-Request-Headers*。
- en: This handshake is considered successful only if these parameters are properly
    acknowledged in the response through the use of *Access-Control-Allow-Origin*,
    *Access-Control-Allow-Method*, and *Access-Control-Allow-Headers*. Following a
    correct handshake, the actual request is made. For performance reasons, the result
    of the preflight check for a particular URL may be cached by the client for a
    set period of time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种握手只有在响应中通过使用 *Access-Control-Allow-Origin*、*Access-Control-Allow-Method* 和
    *Access-Control-Allow-Headers* 正确认可这些参数时才被认为是成功的。在正确的握手之后，实际请求才会被发送。出于性能考虑，特定
    URL 的预检检查结果可能会被客户端缓存一段时间。
- en: Current Status of CORS
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CORS 的当前状态
- en: As of this writing, CORS is available only in Firefox and WebKit-based browsers
    and is notably absent in Opera or Internet Explorer. The most important factor
    hindering its adoption may be simply that the API is not as critical as *postMessage(...)*,
    its client-side counterpart, because it can be often replaced by a content-fetching
    proxy on the server side. But the scheme is also facing three principal, if weak,
    criticisms, some of which come directly from one of the vendors. Obviously, these
    criticisms don’t help matters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，CORS 仅在 Firefox 和基于 WebKit 的浏览器中可用，并且在 Opera 或 Internet Explorer 中明显缺失。阻碍其采用的最重要因素可能仅仅是
    API 并不像其客户端对应物 *postMessage(...)* 那样关键，因为它通常可以被服务器端的内容获取代理所替代。但是，该方案也面临着三个主要、尽管是轻微的批评，其中一些直接来自一家供应商。显然，这些批评并没有帮助解决问题。
- en: The first complaint, voiced chiefly by Microsoft developers and echoed by some
    academics, is that the scheme needlessly abuses ambient authority. They argue
    that there are very few cases where data shared across domains would need to be
    tailored based on the credentials available for the destination site. The critics
    believe that the risks of accidentally leaking sensitive information far outweigh
    any benefits and that a scheme permitting only nonauthenticated requests to be
    made would be preferable. In their view, any sites that need a form of authentication
    should instead rely on explicitly exchanged authentication tokens.^([[79](#ftn.CHP-16-FN-3)])
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项投诉主要是由微软的开发人员和一些学者提出的，他们认为该方案无谓地滥用环境权限。他们争辩说，在跨域共享数据的情况下，需要根据目标站点的凭证进行定制的情况非常少。批评者认为，意外泄露敏感信息的风险远远超过了任何好处，并且认为只允许进行非认证请求的方案更可取。在他们看来，任何需要某种形式认证的网站都应该依靠明确交换的认证令牌。^([[79](#ftn.CHP-16-FN-3)])
- en: 'The other, more pragmatic criticism of CORS is that the scheme is needlessly
    complicated: It extends an already problematic and error-prone API without clearly
    explaining the benefits of some of the tweaks. In particular, it is not clear
    if the added complexity of preflight requests is worth the peripheral benefit
    of being able to issue cross-domain requests with unorthodox methods or random
    headers.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对CORS的另一种，更实际的批评是，该方案过于复杂：它扩展了一个已经问题重重且容易出错的API，而没有清楚地解释一些调整的好处。特别是，预先请求增加的复杂性是否值得能够以非常规方法或随机头信息发出跨域请求的边缘利益并不清楚。
- en: The last of the weak complaints hinges on the fact that CORS is susceptible
    to header injection. Unlike some other recently proposed browser features, such
    as WebSockets ([Chapter 17](ch17.html "Chapter 17. Other Browser Mechanisms of
    Note")), CORS does not require the server to echo back an unpredictable challenge
    string to complete the handshake. Particularly in conjunction with preflight caching,
    this may worsen the impact of certain header-splitting vulnerabilities in the
    server-side code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点微弱的投诉基于这样一个事实，即CORS容易受到头信息注入的影响。与其他一些最近提出的浏览器功能不同，例如WebSockets ([第17章](ch17.html
    "第17章。其他值得注意的浏览器机制"))，CORS不需要服务器回显一个不可预测的挑战字符串来完成握手。特别是与预检缓存结合使用时，这可能会加剧服务器端代码中某些头信息分割漏洞的影响。
- en: XDomainRequest
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XDomainRequest
- en: Microsoft’s objection to CORS appears to stem from the aforementioned concerns
    over the use of ambient authority, but it also bears subtle overtones of their
    dissatisfaction with interactions with W3C. In 2008, Sunava Dutta, a program manager
    at Microsoft, offered this somewhat cryptic insight:^([[241](pr03.html#ftn.CHP-16-FT-2)])
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微软对CORS的反对似乎源于对使用环境权限的上述担忧，但也隐含着他们对与W3C互动的不满。2008年，微软的程序经理Sunava Dutta提出了这个有些神秘的见解：^([[241](pr03.html#ftn.CHP-16-FT-2)])
- en: During the [Internet Explorer 8] Beta 1 timeframe there were many security based
    concerns raised for cross domain access of third party data using cross site XMLHttpRequest
    and the Access Control framework. Since Beta 1, we had the chance to work with
    other browsers and attendees at a W3C face-to-face meeting to improve the server-side
    experience and security of the W3C’s Access Control framework.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[Internet Explorer 8] Beta 1阶段，针对使用跨站XMLHttpRequest和访问控制框架进行跨域访问第三方数据提出了许多基于安全性的担忧。自Beta
    1以来，我们有幸与其他浏览器和W3C面对面会议的与会者合作，以改善W3C访问控制框架的服务器端体验和安全性。
- en: Instead of embracing the CORS extensions to *XMLHttpRequest*, Microsoft decided
    to implement a counterproposal, dubbed *XDomainRequest*.^([[242](pr03.html#ftn.CHP-16-FT-3)])
    This remarkably simple, new API differs from the variant available in other browsers
    in that the resulting requests are always anonymous (that is, devoid of any browser-managed
    credentials) and that it does not allow for any custom HTTP headers or methods
    to be used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微软没有接受CORS对*XMLHttpRequest*的扩展，而是决定实施一个名为*XDomainRequest*的反提案。这个非常简单的新API与其他浏览器中可用的变体不同，其结果是请求始终是匿名的（即没有任何浏览器管理的凭证），并且它不允许使用任何自定义HTTP头或方法。
- en: 'The use of Microsoft’s API is otherwise very similar to *XMLHttpRequest*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微软的API在其他方面与*XMLHttpRequest*非常相似：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Borrowing from W3C’s proposal, the resulting request will bear an *Origin* header,
    and the response data will be revealed to the caller only if a matching *Access-Control-Allow-Origin*
    header is present in the response.^([[80](#ftn.CHP-16-FN-4)]) Preflight requests
    and permission caching are not a part of the design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 借鉴W3C的提案，生成的请求将包含一个*Origin*头，并且只有在响应中存在匹配的*Access-Control-Allow-Origin*头时，响应数据才会被调用者看到.^([[80](#ftn.CHP-16-FN-4)])
    预检请求和权限缓存不是设计的一部分。
- en: 'For all intents and purposes, Microsoft’s solution is far more reasonable than
    CORS: It is simpler, safer, and probably just as functional in all the plausible
    uses. That said, it is also unpopular. It is supported only in Internet Explorer
    8 and up, and owing to W3C backing CORS, others have no reason to embrace *XDomainRequest*
    anytime soon.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 就目的和用途而言，微软的解决方案比CORS更合理：它更简单、更安全，并且在所有可能的用途中可能同样有效。然而，它并不受欢迎。它仅在Internet Explorer
    8及以上版本中受支持，由于W3C支持CORS，其他人没有理由很快接受*XDomainRequest*。
- en: In the meantime, a separate group of researchers have proposed a third solution,
    again acting under the auspices of W3C. Their design, known as Uniform Messaging
    Policy (complete with a corresponding *UniformRequest* API),^([[243](pr03.html#ftn.CHP-16-FT-4)])
    embraces an approach nearly identical to Microsoft’s. It is not supported in any
    existing browser, but there is some talk of unifying it with CORS.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，另一组研究人员在W3C的赞助下提出了第三个解决方案。他们的设计被称为统一消息策略（包括相应的*UniformRequest* API），^([[243](pr03.html#ftn.CHP-16-FT-4)])
    采用的方法几乎与微软的方案相同。它不被任何现有浏览器支持，但有人谈论将其与CORS统一。
- en: Other Uses of the Origin Header
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Origin头的其他用途
- en: The *Origin* header is an essential part of CORS, *XDomainRequest*, and UMP,
    but it actually evolved somewhat independently with other uses in mind. In their
    2008 paper, Adam Barth, Collin Jackson, and John C. Mitchell^([[244](pr03.html#ftn.CHP-16-FT-5)])
    advocated the introduction of a new HTTP header that would offer a more reliable
    and privacy-conscious alternative to *Referer*. It would also serve as a way to
    prevent cross-site request vulnerabilities by providing the server with the information
    needed to identify the SOP-level origin of a request, without disclosing the potentially
    more sensitive path or query data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Origin*头是CORS、*XDomainRequest*和UMP的重要组成部分，但实际上它是独立于其他用途而演化的。在他们的2008年论文中，Adam
    Barth、Collin Jackson和John C. Mitchell^([[244](pr03.html#ftn.CHP-16-FT-5)]) 倡导引入一个新的HTTP头，该头将提供一种比*Referer*更可靠和更注重隐私的替代方案。它还将通过向服务器提供所需的信息来识别请求的SOP级别源，而无需披露可能更敏感的路径或查询数据。'
- en: Of course, it was unclear whether the subtle improvement between *Referer* and
    its proposed successor would actually make a difference for the small but nonnegligible
    population of users who block that first header on privacy grounds. The proposal
    consequently ended up in a virtual limbo, not being deployed in any existing browsers
    but also discouraging others from pursuing other solutions such as XSRF or XSSI.^([[245](pr03.html#ftn.CHP-16-FT-6)])
    (To be fair, the concept was very recently revived under the new name of *From-Origin*
    and may not be completely dead yet.)^([[246](pr03.html#ftn.CHP-16-FT-7)])
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，是否在*Referer*及其建议的继任者之间存在的细微改进实际上会对那些基于隐私原因阻止第一个头的小部分但不可忽视的用户群体产生影响，这一点尚不清楚。因此，该提案最终陷入了一种虚拟的停滞状态，既没有被任何现有浏览器部署，也阻止了其他人追求其他解决方案，如XSRF或XSSI.^([[245](pr03.html#ftn.CHP-16-FT-6)])（公平地说，这个概念最近以*From-Origin*的新名字被重新启用，可能还没有完全消失。）^([[246](pr03.html#ftn.CHP-16-FT-7)])
- en: 'The fate of the original idea aside, the utility of the *Origin* header in
    specialized cases such as CORS was pretty clear. Around 2009, this led to Barth
    submitting an IETF draft specifying the syntax of the header,^([[247](pr03.html#ftn.CHP-16-FT-8)])
    while shying away from making any statements about when the header should be sent,
    or what specific security problems it might solve:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始想法的命运之外，*Origin*头在CORS等特殊案例中的效用相当明显。大约在2009年，这导致了Barth提交了一份IETF草案，指定了头的语法，^([[247](pr03.html#ftn.CHP-16-FT-8)])
    同时回避了关于何时发送头或它可能解决的具体安全问题的声明：
- en: The user agent MAY include an Origin header in any HTTP request.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户代理可以在任何HTTP请求中包含一个Origin头。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[...]'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[...]'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever a user agent issues an HTTP request from a “privacy-sensitive” context,
    the user agent MUST send the value “null” in the Origin header.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当用户代理从“隐私敏感”的上下文中发起HTTP请求时，用户代理必须在Origin头中发送值“null”。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'NOTE: This document does not define the notion of a privacy-sensitive context.
    Applications that generate HTTP requests can designate contexts as privacy-sensitive
    to impose restrictions on how user agents generate Origin headers.'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：本文件未定义隐私敏感上下文的概念。生成 HTTP 请求的应用程序可以将上下文指定为隐私敏感，以对用户代理生成 Origin 标头的生成方式施加限制。
- en: The bottom line of this specification is that whatever the decision process
    is, once the client chooses to provide the header, the value is required to accurately
    represent the SOP origin from which the request is being made. For example, when
    a particular operation takes place from [http://www.bunnyoutlet.com:1234/bunny_reports.php](http://www.bunnyoutlet.com:1234/bunny_reports.php),
    the transmitted value should be
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范的底线是，无论决策过程如何，一旦客户端选择提供该头，该值必须准确表示发起请求的 SOP 原因。例如，当特定操作从 [http://www.bunnyoutlet.com:1234/bunny_reports.php](http://www.bunnyoutlet.com:1234/bunny_reports.php)
    发生时，传输的值应该是
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For origins that do not meaningfully map to a protocol-host-port tuple, the
    browser must send the value of *null* instead.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法有意义地映射到协议-主机-端口号元组的来源，浏览器必须发送 *null* 的值。
- en: 'Despite all of these plans, as of this writing only one browser includes the
    *Origin* header on non-CORS navigation: WebKit-based implementations send it when
    submitting HTML forms. Firefox seems to be considering a different approach, but
    nothing specific seems to have been implemented yet.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有所有这些计划，但截至本文撰写时，只有一种浏览器在非 CORS 导航中包含 *Origin* 头：基于 WebKit 的实现会在提交 HTML 表单时发送它。Firefox
    似乎正在考虑不同的方法，但似乎还没有实施任何具体措施。
- en: '* * *'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[77](#CHP-16-FN-1)]) Malicious URL blacklists, a feature supported by (and
    usually enabled in) all modern browsers, are a prime example of this trend. The
    blacklist is a lightweight, crude substitute for an antivirus, which is, in turn,
    a poor substitute for up-to-date and well-designed software. Antimalware features
    do not make individual attacks any more difficult; they are simply meant to stop
    the large-scale distribution of unsophisticated malware, based on the assumption
    that most users are not interesting enough to be specifically targeted or attacked
    with something clever.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[77](#CHP-16-FN-1)]) 恶意 URL 黑名单，这是该趋势的一个主要例子。黑名单是防病毒软件的一个轻量级、粗略的替代品，而防病毒软件本身又是不更新且设计不佳的软件的一个糟糕替代品。反恶意软件功能并不会使个别攻击更加困难；它们只是旨在阻止低级恶意软件的大规模传播，基于大多数用户不够有趣，不会成为特定目标或被巧妙攻击的假设。
- en: ^([[78](#CHP-16-FN-2)]) That assumption is not completely correct. For example,
    prior to the introduction of this scheme, attackers would not have been able to
    initiate a cross-domain request completely indistinguishable from the submission
    of a file upload form, but under CORS, such forgery is possible.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[78](#CHP-16-FN-2)]) 该假设并不完全正确。例如，在引入此方案之前，攻击者无法发起一个与文件上传表单提交完全无法区分的跨域请求，但在
    CORS 下，这种伪造是可能的。
- en: ^([[79](#CHP-16-FN-3)]) The same claim can be made about the use of HTTP cookies
    in any other setting and seems equally futile. It is true that ambient credentials
    cause problems more frequently than some other forms of explicit authentication
    would, but they are also a lot more convenient to use and are simply not going
    away.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[79](#CHP-16-FN-3)]) 同样的说法也可以用于任何其他设置中 HTTP cookies 的使用，看起来同样徒劳。确实，环境凭证比其他一些显式认证形式更频繁地引起问题，但它们的使用也更为方便，并且根本不会消失。
- en: ^([[80](#CHP-16-FN-4)]) The reason for this check, even if the response is not
    authenticated, is to prevent the use of the browser as a proxy (for example, to
    crawl internal networks or send out spam).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[80](#CHP-16-FN-4)]) 即使响应未经过认证，进行此检查的原因是为了防止将浏览器用作代理（例如，用于爬取内部网络或发送垃圾邮件）。
- en: Security Model Restriction Frameworks
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全模型限制框架
- en: Designs that extend the bounds of the same-origin policy are fairly simple to
    understand and typically fail securely. If the proposed change is not accounted
    for in one of the possible code paths, or is simply not supported in a particular
    browser, the previously implemented, more restrictive logic will kick in. Compared
    with this, it is far more dangerous to try to erect new boundaries on top of the
    existing browser security model. That’s because every security-sensitive code
    path must be tweaked to recognize the new scheme and every browser must comply
    right away, or unexpected problems will arise.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展同源策略边界的方案相对简单易懂，并且通常安全失败。如果提议的更改没有在可能的代码路径之一中得到考虑，或者在某些特定浏览器中根本不支持，那么之前实施的、更严格的逻辑将启动。与这种方法相比，在现有的浏览器安全模型之上建立新的边界要危险得多。这是因为每个与安全相关的代码路径都必须调整以识别新的方案，并且每个浏览器都必须立即遵守，否则将出现意外问题。
- en: In this section, we will take a quick look at some of the more accomplished
    attempts to take this dangerous but potentially rewarding path—and explore where
    they come apart.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将快速查看一些更成功的尝试，这些尝试试图走这条危险但可能有益的道路——并探讨它们在哪里分道扬镳。
- en: Content Security Policy
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容安全策略
- en: '*Content Security Policy* (*CSP*) is an unusually comprehensive security framework
    first proposed by Brandon Sterne of Mozilla in 2008.^([[248](pr03.html#ftn.CHP-16-FT-9)])
    The framework was originally envisioned as an all-encompassing way to mitigate
    the impact of common web vulnerabilities, from XSRF to XSS, and as a tool for
    website owners to perform a variety of non-security content-policing tasks.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容安全策略*（*CSP*）是一个不寻常的全面安全框架，最初由Mozilla的Brandon Sterne于2008年提出。[^([[248](pr03.html#ftn.CHP-16-FT-9)])
    该框架最初设想为一种全面的方法来减轻常见网络漏洞的影响，从XSRF到XSS，以及作为网站所有者执行各种非安全内容管理任务的工具。'
- en: In the years that followed, CSP evolved rapidly, and on several occasions, its
    scope changed in major ways. (For example, the author quickly abandoned the plan
    to address XSRF vulnerabilities, delegating the job to the yet unrealized extensions
    of the *Origin* header.) In fact, as of this writing, the canonical Mozilla specification
    is being rewritten as a W3C draft,^([[249](pr03.html#ftn.CHP-16-FT-10)]) resulting
    in substantial differences in the implementation shipped in Firefox and the partial
    support implemented in WebKit by Adam Barth. (Internet Explorer and Opera do not
    support CSP and have not announced any specific plans to embrace it.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的几年里，CSP迅速发展，在几次重大事件中，其范围发生了重大变化。（例如，作者迅速放弃了处理XSRF漏洞的计划，将这项工作委托给了尚未实现的*Origin*头部扩展。）事实上，截至本文撰写时，Mozilla的规范正在被重写为W3C草案。[^([[249](pr03.html#ftn.CHP-16-FT-10)])
    这导致了Firefox中发布的实现与Adam Barth在WebKit中实现的有限支持之间存在重大差异。（Internet Explorer和Opera不支持CSP，并且没有宣布任何具体计划来采用它。）
- en: Primary CSP Directives
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要CSP指令
- en: 'At its core, Sterne’s design permits site owners to specify per-document policies
    that constrain the ability of the subject document to perform actions that would
    normally be permitted under the same-origin policy. For example, CSP may prevent
    a page from loading any external subresources except for images and restrict image
    sources to only a set of trusted origins, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Sterne的设计允许网站所有者为每个文档指定策略，以限制受主体文档执行通常在相同源策略下允许的操作的能力。例如，CSP可能阻止页面加载任何外部子资源，除了图像，并限制图像源仅限于一组受信任的来源，如下所示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As should be evident from this example, the policies may be encoded in an HTTP
    header. Under the W3C draft, it is also possible to embed them in the document
    itself (using *<meta>* tags) or host the policy at an external URL and point to
    it with *policy-uri*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，策略可能被编码在HTTP头部中。根据W3C草案，也可以将它们嵌入到文档本身（使用*<meta>*标签）或者在外部URL上托管策略并通过*policy-uri*指向它。
- en: For every content source directive, the author of the policy may specify any
    number of fully qualified origins or wildcard expressions that match multiple
    hosts, protocols, or ports. Three special keywords (*none*, *self*, and *data:*)
    correspond to an empty set, the origin associated with the policy-bearing page,
    or all inline *data:* URLs, in corresponding order.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个内容源指令，策略的作者可以指定任意数量的完全限定起源或匹配多个主机、协议或端口的通配符表达式。三个特殊关键词（*none*、*self*和*data:*）分别对应一个空集、与携带策略的页面关联的起源或所有内联*data:*
    URL，顺序对应。
- en: 'As of today, the following behaviors can be controlled with CSP directives:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，以下行为可以通过CSP指令进行控制：
- en: '**Script execution** A *script-src* directive can be used to specify the protocol,
    host, and port for permissible *<script src=...>* URLs. Normally, the CSP disables
    the ability to embed scripts inline in the document (whether through standalone
    *<script>* blocks or via event handlers) and of existing scripts to carelessly
    pass strings to functions such as *eval(...)*, *setTimeout(...)*, *setInterval(...)*,
    and so on. Because of this, the *script-src* directive is useful for limiting
    the impact of XSS vulnerabilities: Any markup injected by the attacker will be
    limited to loading scripts legitimately hosted in one of the approved origins.^([[81](#ftn.CHP-16-FN-5)])'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本执行** 可以使用 *script-src* 指令来指定允许的 *<script src=...>* URL的协议、主机和端口。通常，CSP会禁用在文档中内嵌脚本的能力（无论是通过独立的
    *<script>* 块还是通过事件处理器），以及现有的脚本不小心将字符串传递给函数，如 *eval(...)*、*setTimeout(...)*、*setInterval(...)*
    等等。正因为如此，*script-src* 指令对于限制XSS漏洞的影响是有用的：攻击者注入的任何标记都将限制在合法托管在批准来源之一的脚本加载。^([[81](#ftn.CHP-16-FN-5)])'
- en: '**Plug-in content** This is controlled through *object-src*. Because plug-ins
    such as Java or Flash may have unconstrained access to the embedding page, the
    directive should be considered largely analogous to *script-src*, and the two
    directives must be restricted in a comparable way to achieve any security benefits.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件内容** 这通过 *object-src* 控制。由于Java或Flash等插件可能对嵌入页面有不受限制的访问权限，该指令应被视为与 *script-src*
    大致相似，并且两个指令必须以类似的方式限制，以实现任何安全效益。'
- en: '**Stylesheets and fonts** This is controlled by *style-src* and *font-src*.
    Unlike its handling of scripts, CSP originally did not prevent inline *<style>*
    blocks or *style=* parameters from appearing on the page. Therefore, any attacker
    exploiting an XSS flaw could dramatically alter the appearance and function of
    the vulnerable page (or worse),^([[82](#ftn.CHP-16-FN-6)]) and these two directives
    only served nonsecurity goals, with the possible exception of limiting mixed-content
    bugs. Only moments before the publication of the book, the specifications have
    been amended to include a more robust approach to CSS.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式表和字体** 这由 *style-src* 和 *font-src* 控制。与处理脚本的方式不同，CSP最初并没有阻止内联 *<style>*
    块或 *style=* 参数出现在页面上。因此，任何利用XSS漏洞的攻击者都可以大幅改变受影响页面的外观和功能（或者更糟），^([[82](#ftn.CHP-16-FN-6)])
    这两个指令仅服务于非安全目标，可能唯一的例外是限制混合内容漏洞。就在本书出版前的一刻，规范已经被修改，以包括对CSS的更稳健的方法。'
- en: '**Passive multimedia** Directives such as *img-src* or *media-src* control
    the ability to embed multimedia content from specific origins. As with the original
    design of CSS controls, this could not have been considered a security feature.
    For example, in the case of an XSS bug, CSP would not have prevented the attacker
    from leveraging stylesheets to draw arbitrary shapes on the vulnerable page or
    even animating them to some extent.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**被动多媒体** 指令如 *img-src* 或 *media-src* 控制从特定来源嵌入多媒体内容的能力。与CSS控制的原设计一样，这不能被认为是一个安全特性。例如，在XSS漏洞的情况下，CSP不会阻止攻击者利用样式表在受影响页面上绘制任意形状，甚至在一定程度上进行动画化。'
- en: '**Subframes** The *frame-src* directive specifies the acceptable destinations
    for any *<iframe>* tags encountered on the page; the policy of the parent page
    is not inherited by the framed document. To preserve the value of other XSS mitigations,
    steps must be taken not to allow *data:* URLs here (see [Chapter 10](ch10.html
    "Chapter 10. Origin Inheritance")).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子框架** *frame-src* 指令指定了在页面上遇到的任何 *<iframe>* 标签的可接受目标；框架文档不会继承父页面的策略。为了保持其他XSS缓解措施的价值，必须采取措施不允许
    *data:* URL出现在这里（参见[第10章](ch10.html "第10章。来源继承")）。'
- en: '**Default policy** Known as *default-src* in the W3C draft, and under a more
    cryptic name (*allow*) in Mozilla documentation, the directive specifies fallback
    behavior for any content not covered by a more specific directive. The directive
    is required, even in cases where it is technically unnecessary.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认策略** 在W3C草案中被称为 *default-src*，在Mozilla文档中有一个更神秘的名称（*allow*），该指令指定了任何未由更具体指令覆盖的内容的回退行为。即使在技术上不必要的情况下，该指令也是必需的。'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'It may be unfortunate that CSP directives are selected to map very closely
    to individual HTML tags, instead of grouping functionally similar behaviors. Because
    of this, it is difficult to appreciate the tricky interactions among settings
    such as *script-src*, *frame-src*, and *object-src*. Also, the approach is simply
    not very future-safe: There already are some peripheral classes of subresources
    (such as “favicons”) that are excluded from CSP altogether, and that list will
    probably unintentionally grow.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CSP 指令被选用来非常紧密地映射到单个 HTML 标签，而不是按功能相似的行为分组，这可能是令人遗憾的。因此，很难理解 *script-src*、*frame-src*
    和 *object-src* 等设置之间的复杂交互。此外，这种方法在未来的安全性方面也并不很高：已经有一些边缘类别的子资源（例如“favicons”）被完全排除在
    CSP 之外，而这个列表可能会无意中增长。
- en: In an unusual departure from the subresource-driven model outlined thus far,
    CSP also features an oddball directive called *frame-ancestors*. This parameter
    is meant to mitigate the impact of clickjacking by specifying the allowed ancestors
    for the current document in a manner similar to the better-established *X-Frame-Options*
    header (outlined in [Chapter 11](ch11.html "Chapter 11. Life Outside Same-Origin
    Rules")). The *frame-ancestors* logic is completely independent of *default-src*
    or any other parts of CSP; its default value is “*”.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与迄今为止概述的子资源驱动模型不同，CSP 还包含一个名为 *frame-ancestors* 的古怪指令。此参数旨在通过以类似于已建立的 *X-Frame-Options*
    标头（在第 11 章[第 11 章。同源规则之外的生活](ch11.html "第 11 章。同源规则之外的生活")中概述）的方式指定当前文档的允许祖先来减轻点击劫持的影响。*frame-ancestors*
    逻辑与 *default-src* 或 CSP 的其他任何部分完全独立；其默认值为 “*”。
- en: Many other possible extensions of the policy are being discussed as of this
    writing. These include a *script-nonce* directive that could be used to more securely
    embed inline scripts (every script block must begin with a policy-specified, unpredictable
    token, often making XSS exploitation harder) and a *sandbox* directive, which
    offers an alternative interface to another security mechanism, discussed in [Sandboxed
    Frames](ch16s02.html#sandboxed_frames "Sandboxed Frames") in [Sandboxed Frames](ch16s02.html#sandboxed_frames
    "Sandboxed Frames").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，正在讨论许多其他可能的策略扩展。这包括一个 *script-nonce* 指令，可以用于更安全地嵌入内联脚本（每个脚本块都必须以策略指定的、不可预测的令牌开始，这通常使得
    XSS 利用更加困难），以及一个 *sandbox* 指令，它提供了一个到另一种安全机制的替代接口，这在 [沙盒框架](ch16s02.html#sandboxed_frames
    "沙盒框架")中进行了讨论。
- en: Policy Violations
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略违规
- en: The policy specified according to these rules constrains the behavior of the
    underlying document. Violations normally result in a failed subresource load,
    the failure to execute an inline script, or the inhibition of page rendering (in
    the special case of *frame-ancestors*).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则指定的策略限制了底层文档的行为。违规通常会导致子资源加载失败、内联脚本执行失败或页面渲染抑制（在特殊情况下为 *frame-ancestors*）。
- en: Because CSP controls a wide range of content behaviors, and because the default
    failure mode is fairly brutal, the authors perceived a need to ease the worries
    of webmasters. To make CSP more user-friendly, and perhaps also in a naïve attempt
    to offer exploit detection, an optional feature of CSP allows the browser to report
    all policy violations immediately back to the owner of the site. This feature
    can be enabled through the *report-uri* keyword in the policy. To further simplify
    deployment, it is also possible to roll out any policy—or part thereof—in a “soft”
    mode, where violations result only in an HTTP notification but do not actually
    break the page. This is achieved by specifying the policy inside a header named
    *X-Content-Security-Policy-Report-Only*.^([[83](#ftn.CHP-16-FN-7)])
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CSP 控制了广泛的内容行为，并且默认的失败模式相当残酷，作者认为有必要减轻网站管理员的不安。为了使 CSP 更易于使用，也许还出于一种天真的尝试提供利用检测，CSP
    的一个可选功能允许浏览器立即将所有策略违规报告给网站的拥有者。此功能可以通过策略中的 *report-uri* 关键字启用。为了进一步简化部署，还可能以“软”模式推出任何策略或其部分，其中违规只会导致
    HTTP 通知，而不会真正破坏页面。这是通过在名为 *X-Content-Security-Policy-Report-Only* 的头中指定策略来实现的。^([[83](#ftn.CHP-16-FN-7)])
- en: Criticisms of CSP
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 CSP 的批评
- en: CSP is a remarkably sensible and consistent design compared to most of the one-off
    security features proposed or deployed in the browser world. Nevertheless, from
    its inception, the proposal has been haunted by recurring design and implementation
    concerns.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器世界中大多数一次性安全功能相比，CSP 是一个非常合理和一致的设计。然而，从其诞生之日起，该提案就一直在设计实现方面的持续担忧中困扰。
- en: 'Perhaps the most prosaic complaint about CSP is a nonsecurity one: In order
    to benefit from the XSS defenses offered by the framework, webmasters have to
    move all inline scripts on the page (often hundreds of individual snippets of
    code) to a separately requested document; in the new drafts of CSP, the same will
    be required for all stylesheets. The complexity of retrofitting existing pages
    to work with CSP and the performance penalty of an additional HTTP request are
    often prohibitive. (It may be possible to resolve this problem with the *script-nonce*
    extension proposed in the most recent drafts.)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CSP的最常见的抱怨可能不是安全问题：为了从框架提供的XSS防御中受益，网站管理员必须将页面上的所有内联脚本（通常是数百个单独的代码片段）移动到一个单独请求的文档中；在CSP的新草案中，所有样式表也需要这样做。将现有页面改造为与CSP兼容的复杂性以及额外HTTP请求的性能惩罚往往是不可行的。（可能可以通过最近草案中提出的*script-nonce*扩展来解决这个问题。）
- en: A more fundamental concern with the design of CSP is that the currently envisioned
    origin-level granularity of the rulesets may not offer a sufficiently robust defense
    against XSS. Consider the fact that any complex, real-life domain may well host
    a dozen largely separate web applications, each consisting of hundreds of possibly
    unrelated static scripts and JavaScript APIs. Attackers exploiting an XSS vulnerability
    in a CSP-protected site are prevented from directly executing a malicious script,
    but they may be able to put the application into an inconsistent and possibly
    dangerous state by loading the existing scripts in the wrong context or in an
    incorrect sequence. The history of vulnerabilities in nonweb software suggests
    that such state corruption conditions are exploitable more often than we may think.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CSP（内容安全策略）的设计，一个更根本的担忧是，目前设想的规则集的原始粒度可能不足以提供足够的防御来抵御XSS攻击。考虑这样一个事实：任何复杂、现实生活中的领域都可能托管数十个相互独立的Web应用程序，每个应用程序可能包含数百个可能无关的静态脚本和JavaScript
    API。攻击者利用CSP保护网站中的XSS漏洞，被阻止直接执行恶意脚本，但他们可能通过在错误上下文或错误顺序中加载现有脚本，将应用程序置于不一致且可能危险的状态。非Web软件中漏洞的历史表明，这种状态破坏条件比我们想象的更容易被利用。
- en: 'An even more troubling prospect is that an attacker can load a subresource
    that is not truly a script but that might be mistaken for one. An extreme example
    of this may be a browser supporting E4X (see [Chapter 6](ch06.html "Chapter 6. Browser-Side
    Scripts")): Any valid XHTML document in which the attacker can place a nominally
    harmless string—say, *{alert("Hi mom!")}*—may result in code execution when loaded
    via *<script src=...>*. Recognizing this problem, the developers decided to require
    whitelisted *Content-Type* values for any scripts loaded under CSP, but even this
    approach is often insufficient.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人担忧的是，攻击者可以加载一个并非真正是脚本的子资源，但可能会被误认为是脚本。一个极端的例子是支持E4X（见[第6章](ch06.html "第6章。浏览器端脚本"））的浏览器：任何攻击者可以放置一个表面上无害的字符串的有效XHTML文档——比如说，*{alert("Hi
    mom!")}*——当通过*<script src=...>*加载时，可能会导致代码执行。认识到这个问题，开发者决定要求为在CSP下加载的任何脚本指定白名单*Content-Type*值，但即使这种方法也往往是不够的。
- en: 'To understand what may go wrong, consider the exceedingly common practice of
    hosting public JSONP APIs in which the client can specify the name of the callback
    function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解可能出错的地方，考虑一个极其常见的做法，即在公共JSONP API中托管，客户端可以指定回调函数的名称：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Such an API anywhere within a CSP-permitted origin may be leveraged by an attacker
    to call arbitrary existing functions in the client-side code, perhaps together
    with attacker-controlled parameters. And if the *callback* string is not constrained
    to alphanumerics (and why should it be?), specifying *callback=alert(1);//* will
    lead to straightforward code injection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP允许的源中的任何地方，这样的API都可能被攻击者用来调用客户端代码中的任意现有函数，可能还伴随着攻击者控制的参数。如果*回调*字符串没有被限制为字母数字（为什么应该限制呢？），指定*callback=alert(1);//*将直接导致代码注入。
- en: Issues with granularity aside, CSP deserves some gentle criticism for its sometimes
    puzzling and detrimental lack of focus. On one hand, through the inclusion of
    directives such as *frame-descendants* or *sandbox*, it seems to be flirting with
    the idea of building a single, unifying browser security framework—only to unexpectedly
    exclude XSRF flaws from its scope without offering a viable alternative beyond
    a vague mention of *Origin*. On the other hand, the proposal often aspires to
    be just a “Content Policy,” with no special attention paid to offering sufficiently
    robust and intuitive security properties. The ease of creating dangerous script
    policies, coupled with the originally ineffective policing of stylesheets and
    images, is a testament to this trend.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除去粒度问题，CSP（内容安全策略）有时因令人困惑且有害的缺乏关注而应受到一些温和的批评。一方面，通过包含诸如 *frame-descendants*
    或 *sandbox* 这样的指令，它似乎在试探性地构建一个单一、统一的浏览器安全框架——然而却意外地将XSRF漏洞排除在其范围之外，而没有提供除对 *Origin*
    的模糊提及之外的任何可行的替代方案。另一方面，该提案往往只希望成为一项“内容策略”，并未特别关注提供足够强大和直观的安全特性。创建危险脚本策略的简便性，加上最初对样式表和图像监管的不力，都是这一趋势的明证。
- en: Sandboxed Frames
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沙盒框架
- en: Sandboxed frames^([[250](pr03.html#ftn.CHP-16-FT-11)]) are an extension of the
    normal *<iframe>* behavior. They allow the owner of the top-level page to place
    certain additional restrictions on the embedded document along with any of that
    document’s subframes. The goal is to make it safer for web applications to embed
    potentially untrusted advertisements, gadgets, or preformatted HTML documents
    on an otherwise sensitive site. The refinement of the design and the initial implementation
    of this feature in WebKit (which is currently the only engine supporting it) was
    driven by Adam Barth.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒框架是正常 *<iframe>* 行为的一种扩展。它们允许顶层页面的所有者对嵌入的文档及其任何子框架施加某些额外的限制。目标是使网络应用程序在敏感网站上嵌入可能不受信任的广告、小工具或预格式化的HTML文档时更加安全。该设计精炼和WebKit（目前唯一支持该功能的引擎）中此功能的初始实现是由Adam
    Barth推动的。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Curiously, sandboxed frames are not exactly a novel idea: Microsoft came up
    with a similar proposal almost a decade earlier. Since version 6, Internet Explorer
    has supported a proprietary *security=restricted* parameter, which forces the
    target frame to be rendered in the Restricted Zone, effectively removing its ability
    to execute scripts, navigate to other locations, and so on. However, no one seemed
    interested in using this feature for anything other than bypassing certain client-side
    JavaScript security mechanisms (most notably, anticlickjacking checks). We will
    soon know whether the HTML5 successor fares any better.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，沙盒框架并不是一个全新的想法：微软几乎十年前就提出了一个类似的提案。自第6版以来，Internet Explorer 支持一个专有的 *security=restricted*
    参数，该参数强制目标框架在受限区域渲染，从而有效地移除了其执行脚本、导航到其他位置等能力。然而，似乎没有人对使用此功能做任何事情感兴趣，除了绕过某些客户端JavaScript安全机制（最著名的是anticlickjacking检查）。我们很快就会知道HTML5的继任者是否表现得更好。
- en: 'The design of sandboxed frames is fairly simple: Any frame embedded in a document
    may be constrained by specifying the *sandbox* parameter on the appropriate *<iframe>*
    tag. By default, the document subject to this restriction is prevented from executing
    scripts and performing certain types of navigations. The permissions may be fine-tuned
    with one or more whitespace-delimited keywords, specified as a value for the *sandbox*
    parameter itself:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒框架的设计相当简单：任何嵌入文档的框架都可以通过在适当的 *<iframe>* 标签上指定 *sandbox* 参数来受到限制。默认情况下，受到此限制的文档将无法执行脚本和执行某些类型的导航。可以通过一个或多个空格分隔的关键字来微调权限，这些关键字作为
    *sandbox* 参数本身的值指定：
- en: Allow-scripts In the absence of this keyword, the document displayed inside
    the frame will be unable to execute JavaScript code. The primary function of this
    feature is to prevent the embedded document from performing DoS attacks, opening
    browser dialogs, or employing any other complex automation of the page.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Allow-scripts 在没有此关键字的情况下，框架内显示的文档将无法执行JavaScript代码。此功能的主要功能是防止嵌入的文档执行DoS攻击、打开浏览器对话框或使用页面上的任何其他复杂自动化。
- en: Allow-forms When this keyword is absent, any HTML forms encountered in the embedded
    document will not work. This mechanism is designed to prevent the framed content
    from exploiting its placement on a trusted website to phish for sensitive information.
    (Note that with *allow-scripts* enabled, there is little or no point in *allow-forms*.
    Scripts may easily construct form-like controls and automatically relay the collected
    information to another site without the need for a functioning *<form>* tag.)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许表单（Allow-forms）当这个关键字不存在时，在嵌入文档中遇到的任何HTML表单将无法工作。这种机制旨在防止框架内容利用其在受信任网站上的位置来钓鱼敏感信息。（注意：如果启用了
    *allow-scripts*，则 *allow-forms* 几乎没有意义。脚本可以轻松构建类似表单的控件，并自动将收集到的信息发送到另一个网站，而无需功能性的
    *<form>* 标签。）
- en: Allow-top-navigation This keyword re-enables the ability of the embedded page
    to navigate the top-level window. This type of navigation is normally permitted
    as one of the exceptions to the same-origin policy (see [Chapter 11](ch11.html
    "Chapter 11. Life Outside Same-Origin Rules")), and it may be abused simply to
    prevent the user from interacting with the embedding site or to carry out phishing
    attacks.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许顶级导航（Allow-top-navigation）这个关键字重新启用嵌入页面导航顶级窗口的能力。这种类型的导航通常作为同源策略（见[第11章](ch11.html
    "第11章。同源规则之外的生活"））的例外之一而被允许，并且可能被滥用，以防止用户与嵌入站点交互或执行钓鱼攻击。
- en: Allow-same-origin Without this flag, the content inside a sandboxed frame is
    assigned a unique, randomly selected, synthetic origin. This prevents the page
    from accessing any origin-bound content that would normally be available to scripts
    executing in the domain it is nominally hosted in. The inclusion of *allow-same-origin*
    removes the synthetic origin and permits same-origin data access.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许同源（Allow-same-origin）如果没有这个标志，沙盒框架内的内容会被分配一个唯一、随机选择的合成来源。这防止了页面访问任何通常对在该域中执行的脚本可用的来源绑定内容。包含
    *allow-same-origin* 将移除合成来源并允许同源数据访问。
- en: Scripting, Forms, and Navigation
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本、表单和导航
- en: The first three restrictions available to sandboxed frames—scripting, forms,
    and navigation—are fairly intuitive and safe to use. Their value is diminished
    only by the need to also disable all plug-ins whenever the *sandbox* attribute
    is used, because frameworks such as Flash or Java do not honor the extension and
    would allow any embedded applets to bypass the newly added browser checks. Unfortunately,
    the three most obvious use cases for sandboxed frames—embedded advertisements,
    videos, and games—rely heavily on Flash, thus rendering this security mechanism
    much less useful than it might otherwise be.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于沙盒框架的前三个限制——脚本、表单和导航——相当直观且安全使用。它们的值只有在需要禁用所有插件时才会降低，因为像Flash或Java这样的框架不遵守扩展，将允许任何嵌入的小程序绕过新添加的浏览器检查。不幸的是，沙盒框架最明显的三个用例——嵌入广告、视频和游戏——严重依赖Flash，这使得这种安全机制比可能的情况要少得多有用。
- en: Synthetic Origins
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合成来源
- en: The last mechanism on the list, synthetic origins, is far more problematic and
    is likely misguided. It is envisioned primarily as a way to make it possible for
    untrusted documents (such as incoming HTML-based emails in a webmail interface)
    to be served as is, along with the rest of the application, while preventing these
    untrusted documents from accessing sensitive data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一个机制，即合成来源，问题更多，可能存在误导。它主要设想为一种使不受信任的文档（如网邮界面中基于HTML的电子邮件）能够像其他应用程序一样被提供服务，同时防止这些不受信任的文档访问敏感数据。
- en: Unfortunately, the concept of synthetic origins creates more problems than it
    solves. For one, unless the URL of the embedded document is unpredictable, the
    attacker may simply navigate to it directly in a new browser window, in which
    case the browser will not see the *sandbox* attribute at all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，合成来源的概念带来的问题比解决的问题多。首先，除非嵌入文档的URL是不可预测的，否则攻击者可以直接在新浏览器窗口中导航到它，在这种情况下，浏览器将根本看不到
    *sandbox* 属性。
- en: As an attempt to work around this problem, the authors of the specification
    eventually proposed the use of a specialized MIME type (*text/html-sandboxed*)
    for content meant to be shown only in a sandboxed frame. Their reasoning is that
    browsers will normally not recognize this MIME type and will not display it inline
    and that a special case may be created in the *<iframe>* handling code. Of course,
    as should be clear from [Chapter 13](ch13.html "Chapter 13. Content Recognition
    Mechanisms"), such a defense is inadequate, because some browsers and plug-ins
    will render *text/html-sandboxed* responses inline or interpret the returned data
    in other troubling ways (say, as *crossdomain.xml*).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解决这个问题的一种尝试，该规范的作者最终提出了使用专门的多媒体类型(*text/html-sandboxed*)来表示仅应在沙盒框架中显示的内容。他们的理由是，浏览器通常不会识别这种MIME类型，并且不会将其内联显示，并且可能在*<iframe>*处理代码中创建一个特殊情况。当然，正如从[第13章](ch13.html
    "第13章。内容识别机制")中可以清楚地看到的，这种防御是不充分的，因为一些浏览器和插件会内联渲染*text/html-sandboxed*响应或以其他令人不安的方式解释返回的数据（例如，作为*crossdomain.xml*）。
- en: The concept of synthetic origins is also highly problematic given the fragmentation
    of origin- or domain-level security mechanisms in a typical browser. For example,
    dangerous interactions are possible with password managers, which must be explicitly
    prevented from autocompleting login forms in the sandboxed documents. Also, special
    logic must be added to security prompts, such as the one associated with the geolocation
    API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于典型浏览器中源或域级别安全机制的碎片化，合成源的概念也存在严重问题。例如，与密码管理器的危险交互是可能的，这些交互必须被明确阻止，以防止在沙盒文档中自动完成登录表单。此外，还必须在安全提示中添加特殊逻辑，例如与地理位置API关联的提示。
- en: After some trial and error, the implementation currently available in WebKit
    resolved many of these issues on a case-by-case basis. That said, future implementations
    are likely to fall for this trap repeatedly, especially since the HTML5 specification
    considers the behavior of these features to be out of scope and does not specify
    the required behavior in any way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些尝试和错误，目前WebKit中可用的实现已经针对这些问题的每一个案例解决了许多问题。然而，未来的实现很可能会反复陷入这个陷阱，特别是HTML5规范认为这些特性的行为超出了范围，并且没有以任何方式指定所需的行为。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Removing synthetic origins leads to trouble, too: If the user clicks on a same-site
    link in a sandboxed advertisement and that link opens in a new window, the browser
    probably should prevent the unrestricted scripts in the new window from traversing
    the *opener* object to perform actions that its parent is prohibited from performing
    on its own.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 移除合成源也会带来麻烦：如果用户在沙盒广告中点击了一个同站链接，并且该链接在新窗口中打开，那么浏览器可能应该阻止新窗口中的无限制脚本通过*打开者*对象执行其父级被禁止执行的操作。
- en: Strict Transport Security
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格传输安全
- en: One of the most significant weaknesses in the design of HTTPS is that users
    often begin navigation by typing in a protocol-less URL in the address bar (such
    as [bankofamerica.com](http://bankofamerica.com) rather than [https://www.bankofamerica.com](https://www.bankofamerica.com)),
    in which case the browser will presume HTTP and send the initial request in plaintext.
    Even if the site immediately redirects this traffic to HTTPS, any active attacker
    on the victim’s network may intercept and modify that initial response, preventing
    the user from ever upgrading to a secure protocol. In such case, the absence of
    a tiny lock icon in the browser UI will be very easy to miss.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS设计中最显著的弱点之一是用户经常通过在地址栏中输入无协议URL（例如[bankofamerica.com](http://bankofamerica.com)而不是[https://www.bankofamerica.com](https://www.bankofamerica.com)）开始导航，在这种情况下，浏览器将假定使用HTTP并以明文发送初始请求。即使网站立即将流量重定向到HTTPS，任何活跃的攻击者都可能在受害者的网络上拦截并修改该初始响应，从而阻止用户升级到安全协议。在这种情况下，浏览器UI中缺少小锁图标将很容易被忽略。
- en: This problem, as well as several peripheral issues related to mixed content
    and cookie scoping, prompted Jeff Hodges and several other researchers to draft
    a proposal for HTTP Strict Transport Security (HSTS, or STS for short).^([[251](pr03.html#ftn.CHP-16-FT-12)])
    Their approach (currently supported in WebKit and Firefox) allows any site on
    the Internet to instruct the browser that all future requests made to a particular
    hostname or domain should always use HTTPS and that any HTTP traffic should be
    automatically upgraded and submitted only over HTTPS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题以及与混合内容和cookie作用域相关的几个外围问题促使Jeff Hodges和几位其他研究人员起草了一个关于HTTP严格传输安全（HSTS，或简称STS）的提案。[^([[251](pr03.html#ftn.CHP-16-FT-12)])
    他们的方法（目前被WebKit和Firefox支持）允许任何网站在互联网上指示浏览器，所有未来针对特定主机名或域名的请求都应该始终使用HTTPS，并且任何HTTP流量都应该自动升级并仅通过HTTPS提交。
- en: The reasoning behind the design of HSTS is that the user’s first interaction
    with a particular domain is unlikely to occur over a connection that is being
    actively tampered with—but that, over time, as the user roams on open wireless
    networks, the chances of encountering an attacker increase rapidly. HSTS is, therefore,
    an imperfect defense, but in practice it is usually good enough.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: HSTS设计背后的推理是，用户与特定域的第一次交互不太可能发生在被积极篡改的连接上——但随着时间的推移，当用户在开放的无线网络上漫游时，遇到攻击者的可能性会迅速增加。因此，HSTS是一种不完美的防御，但在实践中通常足够好。
- en: 'The HSTS opt-in header may appear in HTTPS responses, looking something like
    this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: HSTS的opt-in头可能在HTTPS响应中出现，看起来可能像这样：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For HSTS to offer reasonable protection, *max-age* (the number of seconds that
    the STS record may be stored in the browser) must be set to a value substantially
    higher than the usual worst-case time between visits to the site. Because there
    is no easy way to disable or override HSTS when something goes wrong with the
    HTTPS site, website owners will be tempted to choose a value small enough to minimize
    disruption when they mess something up and have to revert. It is not clear whether
    this conflict of interests will lead web programmers to make optimal choices.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让HSTS提供合理的保护，*max-age*（STS记录可以存储在浏览器中的秒数）必须设置为一个远高于通常最坏情况下的网站访问时间间隔的值。由于没有简单的方法来禁用或覆盖HSTS，当HTTPS网站出现问题时，网站所有者可能会选择一个足够小的值，以最小化当他们搞砸事情并需要回滚时的干扰。不清楚这种利益冲突是否会导致网络程序员做出最佳选择。
- en: 'The negative security consequences of this design are fairly unremarkable:
    There is a slightly elevated risk of DoS attacks, because an attacker could inject
    this response header into a domain that is not fully HTTPS enabled. There is also
    the possibility of using a unique combination of HSTS settings for several decoy
    hostnames to tag a particular instance of a browser, offering yet another alternative
    to cookie-based user tracking. Neither of these concerns is particularly pronounced,
    however.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的安全后果相当不明显：DoS攻击的风险略有增加，因为攻击者可以将此响应头注入尚未完全启用HTTPS的域。还有使用HSTS设置的唯一组合为几个诱饵主机名标记特定浏览器实例的可能性，这为基于cookie的用户跟踪提供了另一种选择。然而，这些担忧并不特别突出。
- en: 'Unfortunately, as with other restriction-adding frameworks discussed in this
    section of the book, the mechanism sounds great in principle, but it’s difficult
    to fully account for how it may interact with other legacy code. In particular,
    unless the *includeSubDomains* flag is used, HSTS offers unexpectedly little protection
    for HTTP cookies: Cookies not marked as *secure* may still be intercepted simply
    by inventing a nonexistent subdomain and intercepting the HTTP request made to
    that destination.^([[84](#ftn.CHP-16-FN-8)]) (Even *secure* cookies could be clobbered
    in a similar fashion, just not read back.)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '不幸的是，正如本书本节讨论的其他添加限制的框架一样，机制在原则上听起来很棒，但很难完全考虑到它可能与其他遗留代码的交互。特别是，除非使用*includeSubDomains*标志，否则HSTS对HTTP
    cookie的保护出人意料地少：未标记为*secure*的cookie仍然可能通过创建一个不存在的子域并拦截发送到该目的地的HTTP请求而被拦截。[^([[84](#ftn.CHP-16-FN-8)])
    （即使是*secure*的cookie也可能以类似的方式被破坏，只是不能读取回。） '
- en: In a similar vein, the enforcement of HSTS on requests originating from plug-in-based
    content is unlikely to work well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，对来自插件内容请求的HSTS强制执行可能不会很好地工作。
- en: Private Browsing Modes
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐私浏览模式
- en: Private browsing, colloquially known as the “porn mode,” is a nonstandardized
    feature available in most up-to-date browsers. It is meant to create a nonpersistent
    browsing sandbox, isolated from the main browser session, which is completely
    discarded as soon as the last private browsing window is closed. In a sense, this
    mechanism can be considered a form of content isolation added on top of the existing
    browser security paradigms, so it seems fitting to briefly mention it now.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 私密浏览，俗称“色情模式”，是大多数最新浏览器中的一项非标准化功能。它的目的是创建一个非持久的浏览沙盒，与主浏览器会话隔离，一旦最后一个私密浏览窗口关闭，就会完全丢弃。从某种意义上说，这种机制可以被视为在现有浏览器安全范式之上添加的一种内容隔离形式，因此现在简要提及它是合适的。
- en: With the exception of Chrome, most browser vendors do not accurately explain
    the security assurances associated with private browsing. Unfortunately, the intuitive
    understanding of the term is quite different from what browsers can actually deliver.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Chrome之外，大多数浏览器厂商并没有准确解释与私密浏览相关的安全保证。不幸的是，对这一术语的直观理解与浏览器实际能提供的内容大相径庭。
- en: Arguably, the most straightforward interpretation of the feature is that a private
    browsing session should be perfectly anonymous and that no data about the user’s
    activity will persist on the system. These two assumptions are already partly
    undermined by the constraints imposed by the networking stacks and the memory
    management practices of modern operating systems. But even within the browser
    itself, the goal of reasonable anonymity is nearly impossible to achieve. Almost
    every stateful browser mechanism, from geolocation or pop-up permissions to Strict
    Transport Security to form autocompletion to plug-in-based persistent data storage,
    must be modified in order to properly account for the distinction between the
    two browsing modes, and for each vendor, achieving that goal is an uphill battle.
    Perhaps more frustratingly, anonymity is also undermined by the ability of scripts
    to uniquely fingerprint any given system simply by examining its characteristics—such
    as the set of installed plug-ins, fonts, screen resolutions, window sizes, clock
    drift, or even the behavior of noncryptographically secure PRNGs.^([[252](pr03.html#ftn.CHP-16-FT-13)])
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，对该功能的直接解释是，私密浏览会话应该是完全匿名的，并且用户的任何活动数据都不会在系统中持久化。这两个假设已经部分被现代操作系统的网络堆栈和内存管理实践所破坏。但即使在浏览器内部，实现合理的匿名性几乎是不可能的。几乎每一种有状态的浏览器机制，从地理位置或弹出权限到严格传输安全到表单自动完成，再到基于插件的持久数据存储，都必须进行修改，以便正确处理两种浏览模式之间的区别，对于每个厂商来说，实现这一目标都是一场艰难的战斗。也许更令人沮丧的是，匿名性还受到脚本通过检查系统的特征（如已安装插件的集合、字体、屏幕分辨率、窗口大小、时钟漂移，甚至非加密安全的PRNG的行为）来唯一标识任何给定系统的能力的影响。[252](pr03.html#ftn.CHP-16-FT-13)]
- en: In the end, despite appearances to the contrary, private browsing mode is suitable
    only for preventing casual data disclosure to other nontechnical users of the
    same machine, and even that goal is sometimes difficult to achieve.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尽管表面上看起来相反，私密浏览模式仅适用于防止向同一台机器上其他非技术用户泄露数据，而且有时甚至难以实现这一目标。
- en: '* * *'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[81](#CHP-16-FN-5)]) CSP offers several ways to shoot yourself in the foot
    here. For one, it is possible to re-enable script execution with settings such
    as *inline-script* (Mozilla’s naming, changed to *disable-xss-protection* in W3C
    draft) or *eval-script*. Perhaps less obviously, it is also possible to make the
    mistake of permitting *data:* or *** as a permissible origin or allowing an HTTP
    origin on an HTTPS site.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[81](#CHP-16-FN-5)]) 内容安全策略（CSP）在这里提供了几种可能导致自我伤害的方法。一方面，可以通过设置如*inline-script*（Mozilla的命名，在W3C草案中改为*disable-xss-protection*）或*eval-script*来重新启用脚本执行。也许不那么明显的是，还可能犯下允许*data:*或***作为允许的源或允许HTTPS站点上的HTTP源的错误。
- en: ^([[82](#CHP-16-FN-6)]) Remember advanced selectors in CSS3? By cleverly leveraging
    them in injected stylesheets, some information about the strings appearing on
    the page may be conveniently relayed to a third-party server without the use of
    JavaScript.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[82](#CHP-16-FN-6)]) 还记得CSS3中的高级选择器吗？通过巧妙地在注入样式中利用它们，可以方便地将页面中出现的字符串信息传递给第三方服务器，而无需使用JavaScript。
- en: ^([[83](#CHP-16-FN-7)]) As a side note, this feature is useful not only for
    short-term experiments but also for detecting noncritical issues on an ongoing
    basis. For example, the owner of a site may leverage it to detect mixed-content
    issues by creating a report-only policy for HTTPS pages that will be violated
    by any HTTP scripts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[83](#CHP-16-FN-7)]) 作为旁注，这个特性不仅对短期实验有用，而且可以持续检测非关键问题。例如，网站所有者可以利用它通过为将被任何HTTP脚本违反的HTTPS页面创建仅报告策略来检测混合内容问题。
- en: ^([[84](#CHP-16-FN-8)]) Recall from [Chapter 9](ch09.html "Chapter 9. Content
    Isolation Logic") that host-scoped cookies are fairly tricky to create in some
    browsers and outright impossible to have in Internet Explorer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[84](#CHP-16-FN-8)]) 从[第9章](ch09.html "第9章. 内容隔离逻辑")回顾，我们知道在某些浏览器中创建主机作用域的cookie相当棘手，而在Internet
    Explorer中则完全不可能拥有。
- en: Other Developments
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他发展
- en: The security features discussed previously in this chapter aim to shift the
    boundaries between web applications and change the way sites interact with each
    other. Another group of proposed mechanisms escapes this simple classification
    yet is important or mature enough to briefly mention here. We’ll review some of
    them now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章之前讨论的安全功能旨在改变Web应用程序之间的边界，以及网站之间交互的方式。另一组提出的机制虽然不属于简单的分类，但仍然重要或足够成熟，值得在此简要提及。我们现在将回顾其中的一些。
- en: In-Browser HTML Sanitizers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器内HTML清理器
- en: XSS vulnerabilities are by far the most common security issue encountered in
    modern web applications. It must be surprising, then, that so few of the proposed
    security frameworks aim to address the problem in a comprehensive way. True, CSP
    is a strong contender, but it requires a radical change in how web applications
    are written, and it can’t be deployed particularly gradually or selectively. Sandboxed
    frames, on the other hand, are probably too resource-intensive and too awkward
    to use for the most common task of displaying hundreds of individual, short snippets
    of user-supplied data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: XSS漏洞是现代Web应用程序中遇到的最常见的安全问题。因此，如此少的提议安全框架旨在全面解决这个问题，这确实令人惊讶。诚然，CSP是一个强有力的竞争者，但它要求对Web应用程序的编写方式进行根本性的改变，并且不能特别逐步或选择性地部署。另一方面，沙盒框架可能过于资源密集且使用不便，不适合显示数百个用户提供的短片段数据的最常见任务。
- en: 'Perhaps the best solution to many XSS woes would be a method for web frameworks
    to provide the browser with a parsed, unambiguous, binary DOM tree. Such a solution
    would eliminate many of the issues associated with template escaping and HTML
    sanitization. A more down-to-earth alternative might be to equip web developers
    with a robust tool to mark the boundaries of an attacker-supplied string and restrict
    the behavior or appearance of the embedded payload without having to escape or
    sanitize it. One might think of syntax such as this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可能解决许多XSS问题的最佳方法之一是让Web框架提供解析的、无歧义的、二进制DOM树给浏览器。这样的解决方案将消除与模板转义和HTML清理相关的大多数问题。一个更实际的选择可能是为Web开发者提供一种强大的工具，以标记攻击者提供的字符串的边界，并限制嵌入有效负载的行为或外观，而无需对其进行转义或清理。可以想象这样的语法：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Were such a tool to be used, the attacker would be unable to escape such a sandbox
    and remove the restriction on scripting without guessing the correct value of
    the randomly generated *token* boundary.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用这样的工具，攻击者将无法逃出这样的沙盒，除非猜出随机生成的*令牌*边界的正确值，否则无法移除对脚本的限制。
- en: Sadly, such a proposal is unlikely to become a part of HTML5 or to ship in any
    browser, because this serialization is fundamentally incompatible with XML, and
    revising XML itself to allow an obscure use case in HTML is a difficult act to
    pull off. Depressingly, XML already offers a similar method of encapsulating arbitrary
    data inside a *<![CDATA[...]]>* block, but absent a token-based guard, this sandbox
    can be escaped easily when exploiting XSS.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这样的提议不太可能成为HTML5的一部分，也不会在任何浏览器中发布，因为这种序列化在本质上与XML不兼容，而修改XML本身以允许HTML中的隐蔽用例是一项难以实现的行动。令人沮丧的是，XML已经提供了一种类似的方法，可以在*<![CDATA[...]]>*块内封装任意数据，但如果没有基于令牌的防护，这个沙盒在利用XSS时可以轻易逃逸。
- en: On the flip side, it is considerably easier to restrict the privileges of any
    HTML generated by scripts on the client side. Beginning with Internet Explorer
    8, Microsoft offers a simple and somewhat inflexible *toStaticHTML(...)* API,^([[253](pr03.html#ftn.CHP-16-FT-14)])
    which promises to remove JavaScript from any fully qualified bit of HTML passed
    to it as a parameter. The output of this method is designed to be safe to assign
    to the *innerHTML* property somewhere in the existing DOM.^([[85](#ftn.CHP-16-FN-9)])
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，限制客户端脚本生成的任何HTML的权限要容易得多。从 Internet Explorer 8 开始，微软提供了一个简单但相对不灵活的 *toStaticHTML(...)*
    API，^([[253](pr03.html#ftn.CHP-16-FT-14)]) 它承诺从传递给它的任何完全限定的HTML片段中移除JavaScript。此方法输出的设计是为了安全地分配给现有DOM中的
    *innerHTML* 属性.^([[85](#ftn.CHP-16-FN-9)])
- en: 'Microsoft’s proposal is fine, but it dances around the most common and problematic
    task of safely displaying server-supplied documents. And its API has a minor but
    entirely unnecessary weakness: It makes it unexpectedly dangerous to trim or concatenate
    the sanitized *toStaticHTML(...)* output after the call but before the *innerHTML*
    assignment, a practice that many web developers will probably attempt. A more
    sensible approach would be to allow content sanitization only upon assignment
    to *innerHTML*. In fact, WebKit engineers briefly discussed a proposal for such
    an API (alternately named *innerStaticHTML* or *safeInnerHTML*), but the effort
    seems to have fizzled out long ago.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的提议是可行的，但它回避了最常见且问题最多的任务，即安全地显示服务器提供的文档。而且它的API有一个微小但完全不必要的弱点：在调用 *toStaticHTML(...)*
    后但在 *innerHTML* 赋值之前修剪或连接清理后的输出是出乎意料的危险，许多网络开发者可能会尝试这种做法。一个更合理的做法是在将内容清理仅限于赋值给
    *innerHTML*。实际上，WebKit 工程师曾短暂讨论过这样一个API的提议（也称为 *innerStaticHTML* 或 *safeInnerHTML*），但这项努力似乎早已无疾而终。
- en: XSS Filtering
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XSS 过滤
- en: Reducing the incidence of cross-site vulnerabilities is difficult, and so is
    limiting their impact. Because of this, some researchers have concluded that detecting
    and stopping the exploitation of such flaws may be a better choice. And so, around
    2008, David Ross of Microsoft announced the inclusion of XSS-detection logic in
    the upcoming release of Internet Explorer 8;^([[254](pr03.html#ftn.CHP-16-FT-15)])
    several months later, Adam Barth implemented a similar feature in WebKit. The
    implementations compare portions of the current URL with any strings appearing
    on the retrieved page or passed to APIs such as *document.write(...)* and *innerHTML*.
    If that comparison reveals that a portion of JavaScript present on the page may
    have originated with an improperly escaped URL parameter, the relevant portion
    of the page may be substituted with a harmless string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 减少跨站漏洞的发生率是困难的，限制其影响也同样困难。正因为如此，一些研究人员得出结论，检测和阻止此类漏洞的利用可能是一个更好的选择。因此，大约在 2008
    年，微软的 David Ross 宣布将在即将发布的 Internet Explorer 8 中包含 XSS 检测逻辑；^([[254](pr03.html#ftn.CHP-16-FT-15)])
    几个月后，Adam Barth 在 WebKit 中实现了类似的功能。这些实现将当前 URL 的部分与检索到的页面上的任何字符串或传递给诸如 *document.write(...)*
    和 *innerHTML* 等API的字符串进行比较。如果比较发现页面上可能存在的JavaScript部分可能源自未正确转义的URL参数，则页面的相关部分可能被替换为无害的字符串。
- en: 'Sadly, this seemingly elegant idea is known to cause serious problems. Accidental
    false positives aside (users of Internet Explorer 8 will have unexpected trouble
    visiting *http://www.google.com/search?q=<script>*), the filter may also be tripped
    for ill purposes by appending a legitimate portion of the page as a nonfunctional
    parameter in the URL. In one extreme and now resolved case, this behavior was
    leveraged to create XSS vectors where none had existed before, simply by tricking
    the browser into haphazardly rearranging the markup.^([[255](pr03.html#ftn.CHP-16-FT-16)])
    But more fundamentally, it’s risky for any complex web application to selectively
    disable attacker-selected script blocks, even if the structure of the page is
    otherwise correctly preserved, and such a tweak may easily put the client-side
    code in an inconsistent or dangerous state. For example, consider an online document
    editor that implements each of the following in a separate *<script>* block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，这个看似优雅的想法已知会导致严重问题。除了偶然的误报（Internet Explorer 8的用户在访问*http://www.google.com/search?q=<script>*时可能会遇到意外麻烦）之外，过滤器还可能被恶意目的触发，通过在URL中附加页面的合法部分作为非功能参数。在一个极端且现已解决的案例中，这种行为被用来创建之前不存在的前端跨站脚本（XSS）攻击向量，仅仅是通过欺骗浏览器随意重新排列标记。^([[255](pr03.html#ftn.CHP-16-FT-16)])
    但更基本的是，对于任何复杂的Web应用来说，选择性地禁用攻击者选择的脚本块都是风险很大的，即使页面的结构在其他方面是正确的，这样的调整也可能轻易地将客户端代码置于不一致或危险的状态。例如，考虑一个在线文档编辑器，它将以下每个功能都实现在一个单独的*<script>*块中：
- en: Initializes the internal state of the editor and creates the UI with an empty
    starting document.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化编辑器的内部状态，并使用空起始文档创建用户界面。
- en: Loads the current version of the document requested by the user in a URL parameter
    with error checking to catch any potential network problems.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过URL参数加载用户请求的文档当前版本，并进行错误检查以捕获任何潜在的网络问题。
- en: If no errors are detected, enters an interactive editing mode and automatically
    saves the current state of the document every 30 seconds under the URL-derived
    ID.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有检测到错误，则进入交互式编辑模式，并自动将文档的当前状态每30秒保存一次，保存的ID基于URL。
- en: In this not entirely unreasonable design, the ability to remove step two can
    be disastrous because the next step could overwrite the existing, server-stored
    document with a blank copy. D’oh.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个并非完全不合理的设计中，移除第二步的能力可能会带来灾难性的后果，因为下一步可能会用空白副本覆盖现有的、服务器存储的文档。哎呀。
- en: 'This problem could have been avoided by using much simpler design whereby any
    suspected XSS attacks would result in the browser simply refusing to render the
    document. Alas, the relatively high incidence of accidental false positives prevented
    the authors from taking this route. Only after some debate did Microsoft decide
    to offer a “strict” blocking mode on an opt-in basis, toggled by a response header
    such as this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用更简单的方案可以避免这个问题，即任何疑似XSS攻击都会导致浏览器简单地拒绝渲染文档。遗憾的是，相对较高的误报率阻止了作者采取这条路线。经过一番辩论后，微软决定提供基于选择的“严格”阻止模式，可以通过如下响应头切换：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to the risk of false positives, XSS filters are also prone to false
    negatives, a situation that probably can’t be improved by much. By design, these
    filters will never be able to detect the arguably more dangerous stored XSS vulnerabilities,
    where incorrectly escaped data comes from a source other than the followed link.
    But even beyond that, the multitude of (often implicit) input escaping schemes
    and the growing use of *location.hash* or *pushState* ([Chapter 17](ch17.html
    "Chapter 17. Other Browser Mechanisms of Note")) as a method to store application
    state make it difficult to formulate an accurate connection between what the browser
    sees in the address bar and what the application makes of the received URL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了误报的风险之外，XSS过滤器还容易产生误报，这种情况可能无法通过多少来改善。按照设计，这些过滤器永远无法检测到更危险的可存储XSS漏洞，即错误转义的数据来自除跟随链接之外的其他来源。但即便如此，众多（通常是隐式的）输入转义方案和*location.hash*或*pushState*（[第17章](ch17.html
    "第17章。其他值得注意的浏览器机制"））作为存储应用程序状态的方法的日益普及，使得很难在浏览器地址栏中看到的内容与应用程序对接收到的URL的处理之间建立准确的联系。
- en: Security Engineering Cheat Sheet
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安全工程速查表
- en: Approach experimental browser security features with care, particularly when
    dealing with mechanisms that create finer-grained security boundaries. Ensure
    that any application leveraging these mechanisms will degrade safely in a noncompliant
    browser.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎对待实验性的浏览器安全功能，尤其是在处理创建更细粒度安全边界的机制时。确保任何利用这些机制的任何应用程序在不合规的浏览器中都能安全降级。
- en: 'Cross-domain XMLHttpRequest (CORS): Fairly safe, but easy to misuse. Avoid
    non-simple requests and do not permit arbitrary headers or methods. If you have
    control over the server-side application framework, consider automatically stripping
    *Cookie* headers on incoming CORS requests with nonwhitelisted *Origin* values
    to minimize the risk of accidentally sharing user-specific data. To minimize the
    incidence of mixed-content bugs, consider rejecting HTTPS *Origin* values on any
    requests received over plain HTTP.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨域XMLHttpRequest (CORS)：相当安全，但容易误用。避免非简单请求，不允许任意头或方法。如果你控制服务器端应用程序框架，考虑自动从带有非白名单*Origin*值的传入CORS请求中删除*Cookie*头，以最大限度地减少意外共享用户特定数据的风险。为了最大限度地减少混合内容错误的发病率，考虑在通过纯HTTP接收到的任何请求上拒绝HTTPS
    *Origin*值。
- en: 'Be wary of *Access-Control-Allow-Origin: **, and if you need to use it, make
    sure it is only returned for the location you intend to share.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '谨慎对待*Access-Control-Allow-Origin: **，如果你需要使用它，请确保它只返回你打算共享的位置。'
- en: 'XDomainRequest: This is safe to use. As with *XMLHttpRequest*, restricting
    access to HTTP APIs from HTTPS origins may be a good way to stamp out mixed-content
    bugs.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XDomainRequest：这可以安全使用。与*XMLHttpRequest*一样，限制从HTTPS源访问HTTP API可能是消除混合内容错误的好方法。
- en: '**Content Security Policy:** This is safe to use as defense in depth. Review
    the caveats related to the interactions among *script-src*, *object-src*, and
    so on, and the dangers of permitting *data:* origins. Do not accidentally allow
    mixed content: Always specify protocols in the rulesets and make sure they match
    the protocol the requesting page is served over.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容安全策略（Content Security Policy）：** 这可以作为深度防御的一种安全措施使用。审查与*script-src*、*object-src*等之间的交互相关的注意事项，以及允许*data:*源的危险性。不要意外地允许混合内容：始终在规则集中指定协议，并确保它们与请求页面上提供的协议相匹配。'
- en: '**Sandboxed frames:** This is safe to use as a way to embed gadgets from other
    origins, but the mechanism will fail dramatically in noncompliant browsers. You
    should not sandbox same-origin documents.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沙盒框架（Sandboxed frames）：** 这可以作为从其他源嵌入小工具的安全方式使用，但在不合规的浏览器中，该机制将失败得很严重。你不应该对同源文档进行沙盒化。'
- en: '**Strict Transport Security:** This is safe to use as defense in depth. Be
    sure to mark all relevant cookies as *secure* and be prepared for the possibility
    of cookie injection via spoofed, non-STS locations in your domain. Use *includeSubDomains*
    where feasible to mitigate this risk.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**严格传输安全（Strict Transport Security）：** 这可以作为深度防御的一种安全措施使用。请确保将所有相关cookie标记为*secure*，并准备好应对通过伪造、非STS位置在您的域中注入cookie的可能性。在可行的情况下使用*includeSubDomains*来减轻这一风险。'
- en: 'toStaticHTML(...): This is safe to use where available, but it is difficult
    to substitute on the client side in noncompliant browsers. Bypass vulnerabilities
    have an above-average chance of recurring in the API due to the design of the
    filter.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'toStaticHTML(...): 在可用的情况下可以安全使用，但在不合规的浏览器客户端替换它很困难。由于过滤器的设计，绕过漏洞在API中有较高的复发概率。'
- en: '**Private browsing:** Do not rely on this mechanism for security purposes.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私密浏览（Private browsing）：** 不要依赖此机制进行安全目的。'
- en: '**XSS filtering:** Do not rely on this mechanism for security purposes. Always
    explicitly specify *XSS-Protection: 1; mode=block* or *XSS-Protection: 0* in HTTP
    responses. The default is fairly unsafe.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站脚本过滤（XSS filtering）：** 不要依赖此机制进行安全目的。始终在HTTP响应中显式指定*XSS-Protection: 1;
    mode=block*或*XSS-Protection: 0*。默认设置相当不安全。'
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[85](#CHP-16-FN-9)]) Amusingly, the HTML parser in Internet Explorer is apparently
    so obtuse that even the authors of *toStaticHTML(...)* had some trouble following
    it. Since its introduction, the API has suffered from a fair number of bypass
    vulnerabilities, most frequently related to the handling of CSS data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[85](#CHP-16-FN-9)]) 有趣的是，Internet Explorer中的HTML解析器似乎非常愚钝，以至于甚至*toStaticHTML(...)*的作者也有些难以理解它。自从其引入以来，该API就遭受了相当多的绕过漏洞，其中大多数与处理CSS数据有关。
- en: Chapter 17. Other Browser Mechanisms of Note
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。其他值得注意的浏览器机制
- en: To conclude the third part of the book, we briefly enumerate some of the recently
    implemented or simply planned APIs that, although not designed for security purposes,
    may substantially change the security landscape in the coming years. For example,
    some change the types of data that web applications have access to or alter the
    way the browser communicates with the outside world.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本书的第三部分，我们简要列举了一些最近实施或计划实施的API，尽管它们并非专为安全目的设计，但可能会在未来的几年内显著改变安全格局。例如，一些API改变了Web应用程序可以访问的数据类型，或者改变了浏览器与外部世界的通信方式。
- en: 'The following list is necessarily incomplete: New, reasonably plausible designs
    are drafted every week, and old approaches are scrapped at a moment’s notice,
    often long before shipping in an actual browser. Still, this chapter should serve
    as an interesting snapshot of what the future may bring.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表必然是不完整的：每周都会起草新的、合理可信的设计，而旧的方法则可能在实际浏览器发货之前被废弃。尽管如此，本章应该可以作为对未来可能带来什么的有趣快照。
- en: URL- and Protocol-Level Proposals
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL和协议级别的提案
- en: These features seek to change the processes surrounding the behavior of links,
    the address bar, and the exchange of data over the wire.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能旨在改变围绕链接行为、地址栏以及通过网络交换数据的过程。
- en: '**Protocol registration**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议注册**'
- en: Web applications commonly assume the handling of URL schemes previously reserved
    for “real” desktop software. One prime example of this may be the *mailto:* protocol,
    which was originally meant to instantiate a stand-alone mail application but which
    is often more sensibly routed to webmail interfaces today. To this end, Mozilla
    proposed and WebKit embraced a simple *navigator.registerProtocolHandler(...)*
    API.^([[256](pr03.html#ftn.CHP-17-FT-1)]) When this API is invoked, the user is
    presented with a simple security prompt, and if the action is approved, a URL-based
    handler is associated with a particular scheme. As of today, the associated prompts
    are vulnerable to the race conditions outlined in [Chapter 14](ch14.html "Chapter 14. Dealing
    with Rogue Scripts"), and they seem to be lacking in other ways, as shown in [Figure 17-1](ch17.html#a_seriously_confusing_prompt_in_firefox
    "Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the
    upper area of the browser window was generated by the browser in response to a
    call to the registerProtocolHandler(...) API, with the protocol name set to “doing
    really awesome stuff” and application name set to “Firefox (mozilla.org)”. This
    particular example is harmless, but more sinister abuse is within reach.").
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序通常假定处理之前为“真实”桌面软件保留的URL方案。一个典型的例子可能是*mailto:*协议，它最初旨在实例化一个独立的邮件应用程序，但如今通常更合理地被路由到网络邮件界面。为此，Mozilla提出了，WebKit接受了简单的*navigator.registerProtocolHandler(...)*
    API。[^256](pr03.html#ftn.CHP-17-FT-1)] 当调用此API时，用户会看到一个简单的安全提示，如果操作得到批准，则将基于URL的处理程序与特定的方案关联。截至今天，相关的提示容易受到第14章中概述的竞争条件的影响，并且它们在其他方面似乎也缺乏，如图17-1所示。
- en: '![A seriously confusing prompt in Firefox. The prompt shown in the upper area
    of the browser window was generated by the browser in response to a call to the
    registerProtocolHandler(...) API, with the protocol name set to “doing really
    awesome stuff” and application name set to “Firefox (mozilla.org)”. This particular
    example is harmless, but more sinister abuse is within reach.](httpatomoreillycomsourcenostarchimages950045.png.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox中的一个严重令人困惑的提示。浏览器窗口上方的提示是由浏览器在调用registerProtocolHandler(...) API时生成的，协议名称设置为“做真正酷炫的事情”，应用程序名称设置为“Firefox
    (mozilla.org)”。这个特定的例子是无害的，但更危险的滥用手段就在眼前。](httpatomoreillycomsourcenostarchimages950045.png.jpg)'
- en: Figure 17-1. A seriously confusing prompt in Firefox. The prompt shown in the
    upper area of the browser window was generated by the browser in response to a
    call to the *registerProtocolHandler(...)* API, with the protocol name set to
    “doing really awesome stuff” and application name set to “Firefox (mozilla.org)”.
    This particular example is harmless, but more sinister abuse is within reach.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-1. Firefox中的一个严重令人困惑的提示。浏览器窗口上方的提示是由浏览器在调用*registerProtocolHandler(...)*
    API时生成的，协议名称设置为“做真正酷炫的事情”，应用程序名称设置为“Firefox (mozilla.org)”。这个特定的例子是无害的，但更危险的滥用手段就在眼前。
- en: '**Address bar manipulation**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址栏操作**'
- en: The newly introduced HTML5 *history.pushState(...)* API,^([[257](pr03.html#ftn.CHP-17-FT-2)])
    supported by Firefox, WebKit, and Opera, permits the currently displayed document
    to change the contents of the address bar to any other same-origin URL, without
    actually triggering a page transition normally associated with this step. The
    API offers a superior alternative to the widespread abuse of *location.hash* to
    store application state. Interestingly, despite its simplicity, it has already
    led to a fair number of interesting security bugs. For example, some implementations
    briefly allowed not only the top-level document but also any dodgy third-party
    frames to change the top-level URL shown in the address bar, and they permitted
    origins such as *about:blank* to put largely unconstrained gibberish in the URL
    field.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 新引入的HTML5 *history.pushState(...)* API，^([[257](pr03.html#ftn.CHP-17-FT-2)])
    由Firefox、WebKit和Opera支持，允许当前显示的文档更改地址栏的内容为任何其他同源URL，而不会实际触发通常与此步骤相关的页面转换。该API提供了比广泛滥用的
    *location.hash* 存储应用程序状态的替代方案。有趣的是，尽管它很简单，但它已经导致了相当数量的有趣的安全漏洞。例如，一些实现不仅允许顶级文档更改地址栏中显示的顶级URL，还允许任何可疑的第三方框架更改地址栏中的顶级URL，并且它们允许诸如
    *about:blank* 这样的源将大量不受约束的乱码放入URL字段。
- en: '**Binary HTTP**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制HTTP**'
- en: SPDY^([[258](pr03.html#ftn.CHP-17-FT-3)]) (“Speedy”) is a simple, encrypted
    drop-in replacement for HTTP that preserves the protocol’s key design principles
    (including the layout and function of most headers). At the same time, it mini-
    mizes the overhead associated with delivering concurrent requests or with the
    parsing of text-based requests and response data. The protocol is currently supported
    only in Chrome, and other than select Google services, it is not commonly encountered
    on the Web. It may be coming to Firefox soon, too, however.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: SPDY^([[258](pr03.html#ftn.CHP-17-FT-3)]) （“快速”）是一个简单的加密HTTP替代品，它保留了协议的关键设计原则（包括大多数头部的布局和功能）。同时，它最小化了与处理并发请求或解析基于文本的请求和响应数据相关的开销。该协议目前仅在Chrome中得到支持，除了选定的Google服务外，在网络上并不常见。然而，它也可能很快就会出现在Firefox中。
- en: '**HTTP-less networking**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**无HTTP网络**'
- en: WebSocket^([[259](pr03.html#ftn.CHP-17-FT-4)]) is a still-evolving API designed
    for negotiating largely unconstrained, bidirectional TCP streams for when the
    transactional nature of TCP gets in the way (e.g., in the case of a low-latency
    chat application). The protocol is bootstrapped using a keyed challenge-response
    handshake, which looks sort of like HTTP and which is (quite remarkably) impossible
    to spoof by merely exploiting a header-splitting flaw in the destination site.
    Following a successful handshake, raw data may be exchanged bidirectionally within
    the resulting long-lived TCP connection, with each message enveloped inside a
    simple protocol frame. The mechanism is supported in WebKit and is probably coming
    soon to Firefox.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket^([[259](pr03.html#ftn.CHP-17-FT-4)]) 是一个仍在发展的API，旨在协商大量不受约束的双向TCP流，用于TCP的事务性特性阻碍时（例如，在低延迟聊天应用的情况下）。该协议通过一个带密钥的挑战-响应握手来启动，看起来有点像HTTP，并且（非常令人惊讶地）仅通过利用目标网站的头部分割漏洞是不可能伪造的。在握手成功后，可以在结果的长连接中双向交换原始数据，每条消息都封装在一个简单的协议帧中。该机制在WebKit中得到支持，并且可能很快就会出现在Firefox中。
- en: '**P2P networking**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**P2P网络**'
- en: WebRTC^([[260](pr03.html#ftn.CHP-17-FT-5)]) is a proposed set of APIs and network
    protocols designed to facilitate the discovery of and communication with other
    browsers without the need for a centralized server infrastructure. The primary
    use case for such a protocol is the implementation of IP telephony and video-conferencing
    features within web apps. No stable browser support is available yet.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC^([[260](pr03.html#ftn.CHP-17-FT-5)]) 是一组提议的API和网络协议，旨在无需集中式服务器基础设施即可促进与其他浏览器的发现和通信。此类协议的主要用例是在Web应用中实现IP电话和视频会议功能。目前还没有稳定的浏览器支持。
- en: '**Offline applications**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**离线应用**'
- en: Cache manifests^([[261](pr03.html#ftn.CHP-17-FT-6)]) are a relatively simple
    way for a web server to instruct the browser that copies of certain documents
    should be stored indefinitely and reused whenever the client appears to have no
    network connectivity. In conjunction with client-side storage mechanisms such
    as *localStorage* ([Chapter 9](ch09.html "Chapter 9. Content Isolation Logic")),
    this allows certain self-sufficient JavaScript applications to be used in offline
    mode. Offline operation is supported in Firefox, the WebKit browser, and Opera.
    As with *localStorage*, the persistent nature of this mechanism could exacerbate
    the long-term consequences of visiting an untrusted network.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存清单^([[261](pr03.html#ftn.CHP-17-FT-6)]) 是一种相对简单的方法，允许Web服务器指示浏览器，某些文档的副本应无限期存储并重复使用，只要客户端似乎没有网络连接。结合客户端存储机制，如*localStorage*
    ([第9章](ch09.html "第9章。内容隔离逻辑"))，这允许某些自给自足的JavaScript应用程序在离线模式下使用。Firefox、WebKit浏览器和Opera支持离线操作。与*localStorage*一样，这种机制的持久性可能会加剧访问不受信任网络的长远后果。
- en: '**Better cookies**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**更好的cookies**'
- en: '*Cake*^([[262](pr03.html#ftn.CHP-17-FT-7)]) is a now-expired proposal drafted
    by Adam Barth that aims to create a more lightweight and secure alternative to
    HTTP cookies: one origin-bound, browser-generated nonce for every destination
    site. A more current but incomplete proposal appears to flirt with normal but
    origin-based cookies as an alternative. Neither approach is available in any browser
    today.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cake*^([[262](pr03.html#ftn.CHP-17-FT-7)]) 是由Adam Barth起草的一个现已失效的提议，旨在创建一个比HTTP
    cookies更轻量级、更安全的替代品：为每个目标网站生成一个与源绑定、浏览器生成的nonce。一个更现代但尚不完整的提议似乎在正常但基于源的cookies作为替代品之间摇摆。这两种方法目前在任何浏览器中都不可用。'
- en: Content-Level Features
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容级功能
- en: The proposals outlined in this section aim to enable new classes of web applications
    to be built on top of HTML and JavaScript.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述的提议旨在使新的Web应用程序类别能够在HTML和JavaScript之上构建。
- en: '**Client-side databases**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端数据库**'
- en: Several APIs for creating and manipulating locally stored databases have been
    proposed over the years, including the notorious *WebSQL* API,^([[263](pr03.html#ftn.CHP-17-FT-8)])
    which would have brought the famously dangerous SQL syntax to client-side JavaScript.
    The WebSQL proposal was ditched in favor of a more sensible *IndexedDB* design,^([[264](pr03.html#ftn.CHP-17-FT-9)])
    which offers a clean API without serialized queries and has a security model comparable
    to that of *localStorage*—but not until WebSQL support had shipped in a couple
    of browsers. Meanwhile, the new API has shipped in Chrome and is expected to appear
    in Firefox.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，已经提出了多个用于创建和操作本地存储数据库的API，包括臭名昭著的*WebSQL* API，^([[263](pr03.html#ftn.CHP-17-FT-8)])它本可以将著名的危险SQL语法带到客户端JavaScript中。WebSQL提议被放弃，转而采用更合理的*IndexedDB*设计，^([[264](pr03.html#ftn.CHP-17-FT-9)])它提供了一个干净的API，没有序列化查询，并且具有与*localStorage*相当的安全模型——但这是在WebSQL支持在几个浏览器中发布之后。与此同时，新的API已经发布在Chrome中，并预计将在Firefox中出现。
- en: '**Background processes**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**后台进程**'
- en: The *Worker* API,^([[265](pr03.html#ftn.CHP-17-FT-10)]) available in Firefox,
    WebKit, and Opera, permits the creation of background JavaScript processes to
    perform computationally expensive tasks without having to worry about blocking
    the browser UI. Each worker runs in an isolated environment that lacks the usual
    *window* or *document* DOM and may communicate with its creator asynchronously
    through the *postMessage(...)* API. *Dedicated workers* are directly reachable
    only by their creator, while *shared workers* may be “attached” to several different
    sites at any given time. (*Persistent workers*, which would run independently
    of any sustained demand for their services, were proposed early on but then dropped.)
    The concept of worker threads raises some peripheral DoS concerns but otherwise
    poses no apparent security risks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox、WebKit和Opera中可用的*Worker* API，^([[265](pr03.html#ftn.CHP-17-FT-10)])
    允许创建后台JavaScript进程来执行计算密集型任务，而无需担心阻塞浏览器UI。每个worker都在一个隔离的环境中运行，缺少通常的*window*或*document*
    DOM，并且可以通过*postMessage(...)* API异步与其创建者通信。*专用worker*只能由其创建者直接访问，而*共享worker*可以在任何给定时间“附加”到几个不同的网站。(*持久worker*，即独立于对其服务的持续需求运行的worker，最初被提出，但后来被放弃。)Worker线程的概念引发了一些外围的DoS担忧，但否则没有明显的安全风险。
- en: '**Geolocation discovery**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**地理位置发现**'
- en: The *navigator.geolocation.getCurrentPosition(...)* API^([[266](pr03.html#ftn.CHP-17-FT-11)])
    permits any website to request information about the physical location of the
    client device, subject to a user’s (largely hijackable) consent. The computed
    geolocation data may be derived from GPS information on a system with a suitable
    hardware module, or it may be looked up based on the names of nearby wireless
    access points, cell towers, and so forth. The API is supported in all major browsers
    except for Internet Explorer.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: The *navigator.geolocation.getCurrentPosition(...)* API^([[266](pr03.html#ftn.CHP-17-FT-11)])
    允许任何网站在用户（很大程度上可被劫持）同意的情况下请求有关客户端设备物理位置的信息。计算出的地理位置数据可能来自具有合适硬件模块的系统的GPS信息，或者根据附近的无线接入点、蜂窝基站等名称进行查询。该API在所有主要浏览器中都有支持，除了Internet
    Explorer。
- en: '**Device orientation**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备方向**'
- en: 'A nonrestricted event-driven *DeviceOrientation* API^([[267](pr03.html#ftn.CHP-17-FT-12)])
    allows websites to read back the orientation of the device, based on accelerometer
    data. This API, which is probably geared toward mobile gaming, is available in
    Firefox, WebKit, and Opera on systems equipped with the appropriate hardware.
    Two researchers at the University of California, Davis have recently demonstrated
    a fatal flaw: On smartphones, minute movements of the device may be used to reliably
    reconstruct on-screen keyboard input, including passwords entered on unrelated
    websites.^([[268](pr03.html#ftn.CHP-17-FT-13)])'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非限制性的事件驱动 *DeviceOrientation* API^([[267](pr03.html#ftn.CHP-17-FT-12)]) 允许网站根据加速度计数据读取设备的方向。这个API可能针对移动游戏，在配备了适当硬件的系统上的Firefox、WebKit和Opera中可用。加州大学戴维斯分校的两名研究人员最近演示了一个致命缺陷：在智能手机上，设备的微小移动可能被用来可靠地重建屏幕上的键盘输入，包括在无关网站上输入的密码^([[268](pr03.html#ftn.CHP-17-FT-13)]）。
- en: '**Page prerendering**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**页面预渲染**'
- en: This experimental feature in Chrome allows pages to be prefetched in anticipation
    of the user following a particular link, and it permits the entire HTML document
    to be prerendered in a hidden tab^([[269](pr03.html#ftn.CHP-17-FT-14)]) and momentarily
    revealed once the predicted navigation action takes place. The mechanism has some
    interesting browser security consequences if the prerendered page turns out to
    be malicious. The implementation in Chrome is careful to defer any disruptive
    actions until the tab is revealed, but mistakes will be very easy to make across
    all browser codebases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome中的这个实验性功能允许在用户点击特定链接之前预先获取页面，并允许整个HTML文档在一个隐藏的标签页中预先渲染^([[269](pr03.html#ftn.CHP-17-FT-14)])，一旦预测的导航操作发生，就暂时显示出来。如果预先渲染的页面被证明是恶意的话，这个机制会有一些有趣的浏览器安全后果。Chrome的实现非常小心，直到标签页被揭示才推迟任何破坏性行为，但跨所有浏览器代码库犯错误将非常容易。
- en: '**Navigation timing**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航时间**'
- en: Several complementary APIs, currently available only in Chrome, permit certain
    types of navigation, including cross-domain page loads, to be very accurately
    benchmarked from client-side JavaScript.^([[270](pr03.html#ftn.CHP-17-FT-15)])
    This interface is designed to allow site owners to identify obvious performance
    bottlenecks, as experienced by a typical visitor. The API allows some privacy-related
    information to be collected by profiling the time needed to load certain third-party
    content, but because the same attack is possible in many other ways (for example
    with *onload* handlers on subresources), that probably does not matter much.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 几个互补的API，目前仅在Chrome中可用，允许某些类型的导航，包括跨域页面加载，能够从客户端JavaScript进行非常精确的基准测试^([[270](pr03.html#ftn.CHP-17-FT-15)])。该接口旨在允许网站所有者识别典型访客所经历的性能瓶颈。API允许通过分析加载某些第三方内容所需的时间来收集一些与隐私相关的信息，但由于同样的攻击可以通过许多其他方式（例如，在子资源上的
    *onload* 处理器）进行，这可能并不重要。
- en: I/O Interfaces
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O接口
- en: The features listed below offer new input and output capabilities to web-based
    scripts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下面列出的功能为基于Web的脚本提供了新的输入和输出能力。
- en: '**UI notifications**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面通知**'
- en: '*Notification* and *window.notifications*^([[271](pr03.html#ftn.CHP-17-FT-16)])
    APIs allow the creation of text-only or HTML-based, always-on-top pop-ups in the
    corner of the screen, allowing select web applications to gently notify users
    of important developments (such as a new mail message). User consent to receiving
    notifications is required on a per-site basis, limiting the risk of abuse. Nevertheless,
    care must be taken to properly communicate the origin of the tiny notification
    window and any dialogs or prompts it subsequently creates, an aspect that took
    some time to refine. The API is available only in WebKit today.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*通知* 和 *window.notifications*^([[271](pr03.html#ftn.CHP-17-FT-16)]) API 允许在屏幕角落创建仅文本或基于
    HTML 的始终显示在顶部的弹出窗口，允许选定的 Web 应用程序温和地通知用户重要事件（如新邮件消息）。用户需要在每个网站上单独同意接收通知，这限制了滥用的风险。尽管如此，仍需注意正确传达微小通知窗口及其随后创建的任何对话框或提示的来源，这一方面花费了一些时间才得以完善。目前该
    API 仅在 WebKit 中可用。'
- en: '**Full-screen mode**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**全屏模式**'
- en: 'Several proposals have been circulated to allow JavaScript to maximize the
    current browser window and hide all the browser chrome. This functionality is
    essential to tasks such as viewing presentations or watching movies, but it is
    obviously very dangerous from the security standpoint: Once in control of the
    entire screen, any malicious page may draw a fake browser window with a fake address
    bar. So far, no specific implementation seems to be available for review. An early-stage
    proposal for mouse cursor locking is being discussed, too.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 已有多个提案流传开来，允许 JavaScript 最大化当前浏览器窗口并隐藏所有浏览器界面。这一功能对于查看演示或观看电影等任务至关重要，但从安全角度来看显然非常危险：一旦控制了整个屏幕，任何恶意页面都可能绘制一个带有虚假地址栏的虚假浏览器窗口。到目前为止，似乎还没有具体的实现可供审查。关于鼠标光标锁定的一个早期提案也在讨论中。
- en: '**Media capture**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**媒体捕获**'
- en: A proposed suite of *navigator.device.capture* APIs^([[272](pr03.html#ftn.CHP-17-FT-17)])
    has been postulated for giving websites access to webcam and microphone data.
    Obvious security and privacy concerns arise around this mechanism, especially
    around the resilience of any associated security prompts with respect to race
    condition attacks. The API has no stable browser support today.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了一套名为 *navigator.device.capture* 的 API 套件^([[272](pr03.html#ftn.CHP-17-FT-17)])，旨在让网站能够访问摄像头和麦克风数据。围绕这一机制，尤其是在处理与竞态条件攻击相关的安全提示的弹性方面，引发了明显的安全和隐私担忧。目前该
    API 没有稳定的浏览器支持。
