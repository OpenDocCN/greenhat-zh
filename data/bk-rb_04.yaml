- en: Chapter 4. Arrays and Hashes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 数组和哈希
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: 'Up to now, you’ve generally been using objects one at a time. In this chapter,
    you’ll find out how to create a list of objects. You’ll start by looking at the
    most common type of list structure: an array.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你通常一次只使用一个对象。在本章中，你将了解如何创建一个对象列表。你将从查看最常见的列表结构类型：数组开始。
- en: Arrays
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'An *array* is a sequential collection of items in which each item can be indexed.
    In Ruby (unlike many other languages), a single array can contain items of mixed
    data types such as strings, integers, and floats or even a method call that returns
    some value. For example, the final element in `a1` shown here calls my method,
    `array_length`, which returns the length of the array, `a0`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*数组*是一个按顺序排列的项目集合，其中每个项目都可以通过索引来访问。在 Ruby（与许多其他语言不同），一个数组可以包含混合数据类型的项目，例如字符串、整数和浮点数，甚至是一个返回某些值的函数调用。例如，这里显示的
    `a1` 的最后一个元素调用了我的方法 `array_length`，它返回数组的长度 `a0`：
- en: '*array0.rb*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*array0.rb*'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first item in an array has the index 0, which means the final item has
    an index equal to the total number of items in the array minus 1\. Given the array
    `a1`, shown previously, this is how to obtain the values of the first and last
    items:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个项目具有索引 0，这意味着最后一个项目的索引等于数组中项目总数减 1。给定前面显示的数组 `a1`，这是获取第一个和最后一个项目值的方法：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You’ve already used arrays a few times—for example, in *2adventure.rb* you
    used an array to store a map of Room objects:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过数组几次——例如，在 *2adventure.rb* 中，你使用数组存储 Room 对象的映射：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating Arrays
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'Like many other programming languages, Ruby uses square brackets to delimit
    an array. You can easily create an array, fill it with some comma-delimited values,
    and assign it to a variable:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言一样，Ruby 使用方括号来界定数组。你可以轻松地创建一个数组，用一些以逗号分隔的值填充它，并将其赋给一个变量：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As with most other things in Ruby, arrays are objects. They are defined, as
    you might guess, by the Array class and, just like strings, they are indexed from
    0\. You can reference an item in an array by placing its index between square
    brackets. If the index is invalid, `nil` is returned:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Ruby 中的大多数其他事物一样，数组是对象。它们由 Array 类定义，就像字符串一样，它们从 0 开始索引。你可以通过放置其索引在方括号中来引用数组中的项目。如果索引无效，则返回
    `nil`：
- en: '*array1.rb*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*array1.rb*'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Displaying nil
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 nil
- en: 'When you attempt to display a `nil` value using `print` or `puts`, Ruby 1.8
    displays “nil,” whereas Ruby 1.9 displays an empty string. If you want to be sure
    that the string representation of `nil` is displayed, use `p` or the `inspect`
    method instead of `print`. You may also display its class (`nil` is an instance
    of `NilClass`) or test whether it is `nil` using the `nil?` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用 `print` 或 `puts` 显示 `nil` 值时，Ruby 1.8 显示 “nil”，而 Ruby 1.9 显示一个空字符串。如果你想确保显示
    `nil` 的字符串表示，请使用 `p` 或 `inspect` 方法而不是 `print`。你也可以显示它的类（`nil` 是 `NilClass` 的实例）或使用
    `nil?` 方法来测试它是否为 `nil`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*array1.rb*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*array1.rb*'
- en: 'An array may include expressions that yield values. Let’s assume you have already
    created this method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数组可能包含产生值的表达式。假设你已经创建了以下方法：
- en: '*array2.rb*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*array2.rb*'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now declare this array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以声明这个数组：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the first element is a mathematical expression that yields the integer
    3, and the second is the string “hello world” (returned by the method `hello`).
    If you run this on Windows, the third array element will be a string containing
    a directory listing. This is because `` `dir` `` is a back-quoted string, which
    is executed by the operating system (see [Chapter 3](ch03.html "Chapter 3. Strings
    and Ranges")). The final “slot” in the array is, therefore, filled with the value
    returned by the `dir` command, which happens to be a string of filenames. If you
    are running on a different operating system, you may need to substitute an appropriate
    command at this point. (For example, if you’re running a Unix-like operating system,
    you could substitute `` `ls` `` to get a similar string of filenames.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个元素是一个产生整数 3 的数学表达式，第二个是字符串 “hello world”（由 `hello` 方法返回）。如果你在 Windows
    上运行它，第三个数组元素将是一个包含目录列表的字符串。这是因为 `` `dir` `` 是一个反引号字符串，它由操作系统执行（见 [第三章](ch03.html
    "第三章 字符串和范围")）。因此，数组的最后一个“槽位”被 `dir` 命令返回的值填充，它恰好是一系列文件名。如果你在不同的操作系统上运行，你可能需要在此处替换一个适当的命令。（例如，如果你在类
    Unix 操作系统上运行，你可以用 `` `ls` `` 替换以获取类似的一串文件名。）
- en: Creating an Array of Filenames
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件名数组
- en: 'A number of Ruby classes have methods that return arrays of values. For example,
    the `Dir` class, which is used to perform operations on disk directories, has
    the `entries` method. Pass a directory name to the method, and it returns a list
    of files in an array:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby的一些类有返回值数组的函数。例如，`Dir`类，用于在磁盘目录上执行操作，有`entries`方法。将目录名传递给该方法，它将返回一个包含文件的数组：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*dir_array.rb*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*dir_array.rb*'
- en: If you want to create an array of single-quoted strings but can’t be bothered
    to type all the quotation marks, a shortcut is to put unquoted text separated
    by spaces between parentheses preceded by `%w` (or use a capital `%W` for double-quoted
    strings, as explained in [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个单引号字符串的数组，但又懒得输入所有的引号，可以使用在`%w`（或使用大写的`%W`来表示双引号字符串，如第3章中解释的）前带有括号的空格分隔的未引用文本的快捷方式。
- en: '*array2.rb*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*array2.rb*'
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code assigns the array shown next to the variable, `y`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将显示在变量`y`旁边的数组分配：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also create arrays using the usual object construction method, `new`.
    Optionally, you can pass an integer to `new` to create an empty array of a specific
    size (with each element set to `nil`), or you can pass two arguments: the first
    to set the size of the array and the second to specify the element to place at
    each index of the array, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用通常的对象构造方法`new`来创建数组。可选地，你可以向`new`传递一个整数来创建一个特定大小的空数组（每个元素设置为`nil`），或者你可以传递两个参数：第一个用于设置数组的大小，第二个用于指定要放置在数组每个索引处的元素，如下所示：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Multidimensional Arrays
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'To create a multidimensional array, you can create one array and then add other
    arrays to each of its “slots.” For example, this creates an array containing two
    elements, each of which is itself an array of two elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个多维数组，你可以创建一个数组，然后将其“槽位”中添加其他数组。例如，这创建了一个包含两个元素的数组，每个元素本身都是一个包含两个元素的数组：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also create an Array object by passing an array as an argument to the
    `new` method. Be careful, though: Ruby considers it a syntax error if you fail
    to leave a space between the `new` method and the opening square bracket. In other
    words, this works: `a = Array.new [1,2,3]`. However, this doesn’t: `a = Array.new[1,2,3]`.
    But using parentheses always works, no matter where you put a space: `a = Array.new([1,2,3])`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过将数组作为参数传递给`new`方法来创建一个数组对象。但请注意：如果你在`new`方法和开方括号之间没有留空格，Ruby会将其视为语法错误。换句话说，这有效：`a
    = Array.new [1,2,3]`。然而，这不行：`a = Array.new[1,2,3]`。但是使用括号总是有效的，无论你放空格的位置在哪里：`a
    = Array.new([1,2,3])`。
- en: 'It is also possible to nest arrays inside one another using square brackets.
    This creates an array of four arrays, each of which contains four integers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用方括号在数组内部嵌套数组。这创建了一个包含四个数组的数组，每个数组都包含四个整数：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, I have placed the four “subarrays” on separate lines.
    This is not obligatory, but it does help clarify the structure of the multidimensional
    array by displaying each subarray as though it were a row, similar to the rows
    in a spreadsheet. When talking about arrays within arrays, it is convenient to
    refer to each nested array as a “row” of the “outer” array.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我将四个“子数组”放在了不同的行上。这不是强制性的，但它确实有助于通过将每个子数组显示为类似电子表格中的行来澄清多维数组的结构。当谈论数组中的数组时，将每个嵌套数组称为“外部”数组的一行是很方便的。
- en: 'For some more examples of using multidimensional arrays, load the *multi_array.rb*
    program. This starts by creating an array, `multiarr`, containing two other arrays.
    The first of these arrays is at index 0 of `multiarr`, and the second is at index
    1:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看使用多维数组的更多示例，请加载*multi_array.rb*程序。该程序首先创建一个包含两个其他数组的数组`multiarr`。这些数组中的第一个位于`multiarr`的索引0处，第二个位于索引1处：
- en: '*multi_array.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*multi_array.rb*'
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next you need to find some way to locate the individual elements within arrays,
    which are themselves contained inside other arrays. You’ll consider this problem
    in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要找到一种方法来定位数组中的单个元素，这些数组本身又包含在其他数组中。你将在下一节中考虑这个问题。
- en: Iterating over Arrays
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'You can access the elements of an array by iterating over them using a `for`
    loop. In many programming languages, a `for` loop counts over a fixed number of
    elements from a starting number (such as 0) to an ending number (such as 10),
    incrementing a counter variable (such as `i`) at each pass through the loop. So,
    in other languages, you might be used to writing a loop something like this: `for
    i = 1 to 10`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`for`循环遍历数组元素来访问数组元素。在许多编程语言中，`for`循环从起始数字（例如0）开始计数，遍历固定数量的元素，直到结束数字（例如10），并在每次循环迭代中递增计数器变量（例如`i`）。因此，在其他语言中，您可能习惯于编写类似这样的循环：`for
    i = 1 to 10`。
- en: 'In Ruby, the normal `for` loop counts over all the items *in* a collection
    and may be referred to as a `for..in` loop. Its counter variable is assigned each
    object in a collection, one by one, at each pass through the loop. The syntax
    may be summarized as `for` *`anObject`* `in` *`aCollection`*, and at each turn
    through the loop, the variable `anObject` is assigned a new item from the collection
    `aCollection` until no more items remain. The loop shown next iterates over two
    elements, namely, the two subarrays at index 0 and 1:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，正常的`for`循环遍历集合中的所有项目，可能被称为`for..in`循环。其计数器变量在每次循环迭代中逐个分配给集合中的每个对象。其语法可以总结为`for`
    *`anObject`* `in` *`aCollection`*，在每次循环迭代中，变量`anObject`从集合`aCollection`中分配一个新的项目，直到没有更多项目为止。下面显示的循环遍历两个元素，即索引0和1的两个子数组：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This displays the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, how do you iterate over the items (the strings and integers) in each of
    the two subarrays? If there is a fixed number of items, you could specify a different
    iterator variable for each, in which case each variable will be assigned the value
    from the matching array index.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何遍历两个子数组中的项目（字符串和整数）？如果有固定数量的项目，您可以为每个指定不同的迭代器变量，在这种情况下，每个变量将分配与匹配数组索引的值。
- en: 'Here you have four subarray slots, so you could use four variables like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您有四个子数组槽位，因此您可以使用四个变量，如下所示：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You could also use a `for` loop to iterate over all the items in each subarray
    individually:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`for`循环逐个遍历每个子数组中的所有项目：
- en: '*multi_array2.rb*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*multi_array2.rb*'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Both of these techniques (multiple iterator variables and multiple `for` loops)
    have two requirements: that you know how many items there are in either the “rows”
    or the “columns” of the grid of arrays and that each subarray contains the same
    number of items as each other.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术（多个迭代器变量和多个`for`循环）有两个要求：您知道网格数组中的“行”或“列”中有多少个项目，并且每个子数组包含的项目数量与其他子数组相同。
- en: 'For a more flexible way of iterating over multidimensional arrays, you could
    use nested `for` loops. An outer loop iterates over each row (subarray), and an
    inner loop iterates over each item in the current row. This technique works even
    when subarrays have varying numbers of items:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更灵活地遍历多维数组，您可以使用嵌套`for`循环。外层循环遍历每一行（子数组），内层循环遍历当前行中的每个项目。这种技术在子数组具有不同数量的项目时也有效：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll be looking at `for` loops and other iterators in more depth in the next
    chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将更深入地了解`for`循环和其他迭代器。
- en: Indexing into Arrays
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组索引
- en: 'As with strings (see [Chapter 3](ch03.html "Chapter 3. Strings and Ranges")),
    you can index from the end of an array using negative numbers, where −1 is the
    index of the last element, −2 is the second-to-last, and so on. You can also use
    ranges, like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串（见[第3章](ch03.html "第3章。字符串和范围"））一样，您可以使用负数从数组的末尾进行索引，其中-1是最后一个元素的索引，-2是倒数第二个，依此类推。您还可以使用范围，如下所示：
- en: '*array_index.rb*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_index.rb*'
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the output displayed by `print` or `puts` may vary depending on your
    version of Ruby. When Ruby 1.8 displays the elements in an array, it shows them
    one after the other so they look like a single string, as in `hello`. Ruby 1.9,
    however, shows the items in array format, as in `["h", "e", "l", "l", "o"]`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`print`或`puts`显示的输出可能因Ruby版本的不同而有所差异。当Ruby 1.8显示数组中的元素时，它们一个接一个地显示，看起来像单个字符串，例如`hello`。然而，Ruby
    1.9却以数组格式显示项目，例如`["h", "e", "l", "l", "o"]`。
- en: 'If you use `p` instead of `print` to inspect the array, both Ruby 1.8 and 1.9
    display the same result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`p`而不是`print`来检查数组，Ruby 1.8和1.9将显示相同的结果：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As with strings, when you provide two integers in order to return a number
    of contiguous items from an array, the first integer is the start index, while
    the second is a *count* of the number of items (*not* an index):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，当你提供两个整数以从数组中返回连续的项目数量时，第一个整数是起始索引，而第二个是项目的 *数量*（*不是* 索引）：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also make assignments by indexing into an array. Here, for example,
    I first create an empty array and then put items into indexes 0, 1, and 3\. The
    “empty” slot at index 2 will be filled with a `nil` value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过索引数组来进行赋值。例如，我首先创建一个空数组，然后将项目放入索引 0、1 和 3。索引 2 的“空”槽位将被 `nil` 值填充：
- en: '*array_assign.rb*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_assign.rb*'
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once again, you can use start-end indexes, ranges, and negative index values:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你可以使用起始-结束索引、范围和负索引值：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Copying Arrays
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制数组
- en: 'Note that when you use the assignment operator (`=`) to assign one array variable
    to another variable, you are actually assigning a *reference* to the array; you
    are not making a copy. For example, if you assign one array called `arr1` to another
    array called `arr2`, any changes made to either variable will also alter the value
    of the other because *both variables refer to the same array*. If you want the
    variables to reference two different arrays, you can use the `clone` method to
    make a new copy:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你使用赋值运算符（`=`）将一个数组变量赋值给另一个变量时，你实际上是在赋值一个 *引用* 到数组；你并没有创建一个副本。例如，如果你将一个名为
    `arr1` 的数组赋值给另一个名为 `arr2` 的数组，对任意一个变量的任何更改也会改变另一个变量的值，因为 *两个变量都引用了同一个数组*。如果你想使变量引用两个不同的数组，你可以使用
    `clone` 方法来创建一个新的副本：
- en: '*array_copy.rb*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_copy.rb*'
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Testing Arrays for Equality
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数组是否相等
- en: 'The comparison operator for arrays is `<=>`. This compares two arrays—let’s
    call them `arr1` and `arr2`. It returns −1 if `arr1` is less than `arr2`, it returns
    0 if `arr1` and `arr2` are equal, and it returns 1 if `arr2` is greater than `arr1`.
    But how does Ruby determine whether one array is “greater than” or “less than”
    another? It compares each item in one array with the corresponding item in the
    other. When two values are not equal, the result of their comparison is returned.
    In other words, if this comparison were made:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的比较运算符是 `<=>`。这比较两个数组——我们可以称它们为 `arr1` 和 `arr2`。如果 `arr1` 小于 `arr2`，则返回 −1；如果
    `arr1` 和 `arr2` 相等，则返回 0；如果 `arr2` 大于 `arr1`，则返回 1。但是 Ruby 如何确定一个数组是否“大于”或“小于”另一个数组呢？它会比较一个数组中的每个项目与另一个数组中相应项目的比较结果。当两个值不相等时，返回它们的比较结果。换句话说，如果进行如下比较：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: the value −1 would be returned. This means the first array is “less than” the
    second, since the integer at index 1 of the first array (10) is less than the
    integer at index 1 in the second array (20).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 会返回值 −1。这意味着第一个数组“小于”第二个数组，因为第一个数组索引 1 的整数（10）小于第二个数组索引 1 的整数（20）。
- en: 'If you want to make a comparison based on the array’s length rather than the
    value of its elements, you can use the `length` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据数组的长度而不是其元素的值进行比较，你可以使用 `length` 方法：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you are comparing arrays of strings, then comparisons are made on the ASCII
    values of the characters that make up those strings. If one array is longer than
    another and the elements in both arrays are equal, then the longer array is deemed
    to be “greater.” However, if two such arrays are compared and one of the elements
    in the shorter array is greater than the corresponding element in the longer array,
    then the *shorter* array is deemed to be greater.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在比较字符串数组，那么比较是基于构成这些字符串的字符的 ASCII 值进行的。如果一个数组比另一个数组长，并且两个数组中的元素都相等，那么较长的数组被认为是“大于”。然而，如果比较了这样的两个数组，并且较短的数组中的一个元素大于较长的数组中相应的元素，那么被认为是“大于”的是
    *较短的* 数组。
- en: '*array_compare.rb*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_compare.rb*'
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sorting Arrays
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组排序
- en: 'The `sort` method compares adjacent array elements using the comparison operator
    `<=>`. This operator is defined for many Ruby classes, including Array, String,
    Float, Date, and Fixnum. The operator is not, however, defined for *all* classes
    (that is to say, it is not defined for the Object class from which all other classes
    are derived). One of the unfortunate consequences of this is that it cannot be
    used to sort arrays containing `nil` values. However, it is possible to get around
    this limitation by defining your own sorting routine. This is done by sending
    a *block* to the `sort` method. You’ll learn about blocks in detail in [Chapter 10](ch10.html
    "Chapter 10. Blocks, Procs, and Lambdas"), but for now it’s enough to know a block
    is a chunk of code delimited either by curly brackets or by the keywords `do`
    and `end`. The following block determines the comparison used by the `sort` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`方法使用比较运算符`<=>`比较相邻的数组元素。这个运算符为许多Ruby类定义，包括Array、String、Float、Date和Fixnum。然而，这个运算符并不是为所有类定义的（也就是说，它不是为所有其他类派生的Object类定义的）。这个不幸的后果之一是，它不能用于包含`nil`值的数组排序。然而，可以通过定义自己的排序例程来克服这种限制。这是通过向`sort`方法发送一个*块*来完成的。你将在[第10章](ch10.html
    "第10章。块、Proc和Lambda")中详细了解块，但就现在而言，你需要知道的是，块是一段由花括号或`do`和`end`关键字分隔的代码块。以下块确定了`sort`方法使用的比较方式：'
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here `arr` is an array object, and the variables `a` and `b` represent two contiguous
    array elements. I’ve converted each variable to a string using the `to_s` method;
    this converts `nil` to an empty string that will be sorted “low.” Note that although
    my sorting block defines the sort order of the array items, it does not change
    the array items themselves. So, `nil` will remain as `nil`, and integers will
    remain as integers. The string conversion is used only to implement the comparison,
    not to change the array items.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`arr`是一个数组对象，变量`a`和`b`代表两个连续的数组元素。我已经使用`to_s`方法将每个变量转换为字符串；这会将`nil`转换为空字符串，这将按“低”排序。请注意，尽管我的排序块定义了数组项的排序顺序，但它并没有改变数组项本身。因此，`nil`将保持为`nil`，整数将保持为整数。字符串转换仅用于实现比较，而不是改变数组项。
- en: '*array_sort.rb*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_sort.rb*'
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the array created and displayed by the previous code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前一段代码创建并显示的数组：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The *array_sort.rb* program supplied in the code archive also contains a method
    to sort in descending order. This is done simply by changing the order of the
    items on either side of the comparison operator:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码存档中提供的*array_sort.rb*程序还包含一个用于降序排序的方法。这是通过改变比较运算符两边的项目顺序来实现的：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Comparing Values
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较值
- en: The comparison “operator” `<=>` (which is, in fact, a method) is defined in
    the Ruby module named `Comparable`. For now, you can think of a module as a sort
    of reusable code library. You’ll be looking more closely at modules in [Chapter 12](ch12.html
    "Chapter 12. Modules and Mixins").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符“操作符”`<=>`（实际上是一个方法）定义在名为`Comparable`的Ruby模块中。目前，你可以将模块视为一种可重用的代码库。你将在[第12章](ch12.html
    "第12章。模块和混入")中更详细地了解模块。
- en: 'You can include the `Comparable` module in your own classes. This lets you
    override the `<=>` method to enable you to define exactly how comparisons will
    be made between specific object types. For example, you may want to subclass Array
    so that comparisons are made based purely on the length of two arrays rather than
    on the value of each item in the array (which is the default, as explained in
    See Testing Arrays for Equality). This is how you might do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在自己的类中包含`Comparable`模块。这让你可以重写`<=>`方法，以便你能够精确地定义特定对象类型之间的比较方式。例如，你可能想创建一个Array的子类，以便比较仅基于两个数组的长度，而不是基于数组中每个项的值（这是默认情况，如See
    Testing Arrays for Equality中所述）。以下是你可以这样做的示例：
- en: '*comparisons.rb*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*comparisons.rb*'
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, you can initialize two MyArray objects like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样初始化两个MyArray对象：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And you can use the `<=>` method defined in MyArray to make comparisons:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用MyArray中定义的`<=>`方法进行比较：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This comparison returns 0, which indicates that the two arrays are equal (since
    our `<=>` method evaluates equality according to length alone). If, on the other
    hand, you were to initialize two standard arrays with exactly the same integer
    values, the Array class’s own `<=>` method would perform the comparison:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个比较返回0，表示两个数组相等（因为我们的`<=>`方法仅根据长度来评估相等性）。另一方面，如果你用完全相同的整数值初始化两个标准数组，数组类的自身`<=>`方法将执行比较：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here the comparison returns −1, which indicates that the first array evaluates
    to “less than” the second array, since the Array class’s `<=>` method compares
    the numerical values of each item in `arr1` and these are less than the values
    of the items at the same indexes in `arr2`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里比较返回 -1，这表示第一个数组评估为“小于”第二个数组，因为 Array 类的 `<=>` 方法比较 `arr1` 中每个项目的数值，这些数值小于
    `arr2` 中相同索引处的项目值。
- en: But what if you want to make “less than,” “equal to,” and “greater than” comparisons
    using the traditional programming notation?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要使用传统的编程符号进行“小于”、“等于”和“大于”的比较呢？
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the MyArray class, you can make comparisons of this sort without writing
    any additional code. This is because the `Comparable` module, which has been included
    in the MyArray class, automatically supplies these three comparison methods; each
    method makes its comparison based on the definition of the `<=>` method. Since
    our `<=>` makes its evaluation based on the number of items in an array, the `<`
    method evaluates to true when the first array is shorter than the second, `==`
    evaluates to true when both arrays are of equal length, and `>` evaluates to true
    when the second array is longer than the first:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MyArray 类中，你可以进行此类比较而无需编写任何额外的代码。这是因为 `Comparable` 模块已被包含在 MyArray 类中，并自动提供这三个比较方法；每个方法都基于
    `<=>` 方法的定义进行比较。由于我们的 `<=>` 方法基于数组中项目的数量进行评估，因此当第一个数组比第二个数组短时，`<` 方法评估为 true，当两个数组长度相等时，`==`
    评估为 true，当第二个数组比第一个数组长时，`>` 评估为 true：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The standard Array class does not include the `Comparable` module. So if you
    try to compare two ordinary arrays using `<`, `==`, or `>`, Ruby will display
    an error message telling you that the method is undefined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Array 类不包含 `Comparable` 模块。所以如果你尝试使用 `<`、`==` 或 `>` 比较两个普通数组，Ruby 将显示一个错误消息，告诉你该方法未定义。
- en: 'However, it’s easy to add these three methods to a subclass of Array. All you
    have to do is include Comparable, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很容易将这些三个方法添加到 Array 的子类中。你只需要包含 Comparable，如下所示：
- en: '[PRE39]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The Array2 class will now perform its comparisons based on the `<=>` method
    of Array—that is, by testing the values of the items stored in the array rather
    than merely testing the length of the array. Assuming that the Array2 objects,
    `arr1` and `arr2`, are initialized with the same arrays that you previously used
    for `myarr1` and `myarr2`, you would now see these results:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Array2 类现在将根据 Array 的 `<=>` 方法进行比较——也就是说，通过测试存储在数组中的项目的值，而不是仅仅测试数组的长度。假设 Array2
    对象 `arr1` 和 `arr2` 使用与之前用于 `myarr1` 和 `myarr2` 相同的数组初始化，你现在会看到以下结果：
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Array Methods
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组方法
- en: Several of the standard array methods modify the array itself rather than returning
    a modified copy of the array. These include the methods marked with a terminating
    exclamation point, such as `sort!`, `reverse!`, `flatten!`, and `compact!`. These
    also include the `<<` method, which modifies the array to its left by adding to
    it the array on its right; `clear`, which removes all the elements from the given
    array; and `delete` and `delete_at`, which remove selected elements. [Table 4-1](ch04.html#commonly_used_array_methods
    "Table 4-1. Commonly Used Array Methods") shows some of the more commonly used
    Array methods.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准数组方法会修改数组本身，而不是返回数组的修改副本。这些包括带有终止感叹号标记的方法，例如 `sort!`、`reverse!`、`flatten!`
    和 `compact!`。这些还包括 `<<` 方法，它通过向其左侧的数组添加右侧的数组来修改左侧的数组；`clear`，它从给定的数组中移除所有元素；以及
    `delete` 和 `delete_at`，它们移除选定的元素。[表 4-1](ch04.html#commonly_used_array_methods
    "表 4-1. 常用数组方法") 展示了一些更常用的数组方法。
- en: Table 4-1. Commonly Used Array Methods
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. 常用数组方法
- en: '| Array | Task |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| Array | 任务 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&` | Returns common elements of two arrays, no duplicates |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 返回两个数组的公共元素，不包含重复项 |'
- en: '| `+` | Returns array concatenating two arrays |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 返回连接两个数组的数组 |'
- en: '| `-` | Returns array with items in second array removed from first |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 返回从第一个数组中移除第二个数组中项目的数组 |'
- en: '| `<<` | Modifies first array by appending items from second array |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 通过从第二个数组中追加项目来修改第一个数组 |'
- en: '| `clear` | Modifies array by removing all elements |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `clear` | 通过移除所有元素来修改数组 |'
- en: '| `compact` | Returns array with `nil` items removed |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `compact` | 返回移除 `nil` 项的数组 |'
- en: '| `compact!` | Modifies array by removing `nil` items |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `compact!` | 通过移除 `nil` 项来修改数组 |'
- en: '| `delete( object )` | Modifies array by deleting object |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `delete( object )` | 通过删除对象来修改数组 |'
- en: '| `delete_at( index )` | Modifies array by deleting item at index |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `delete_at( index )` | 通过删除索引处的项目来修改数组 |'
- en: '| `flatten` | Unpacks nested array items and returns array |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `flatten` | 解包嵌套数组元素并返回数组 |'
- en: '| `flatten!` | Modifies array by unpacking nested array items |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `flatten!` | 通过解包嵌套数组元素修改数组 |'
- en: '| `length` | Returns number of elements in array |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `length` | 返回数组中的元素数量 |'
- en: '| `reverse` | Returns array with elements in reverse order |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `reverse` | 返回元素顺序相反的数组 |'
- en: '| `reverse!` | Modifies array by reversing element order |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `reverse!` | 通过反转元素顺序修改数组 |'
- en: '| `sort` | Returns array sorted using `<=>` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 使用 `<=>` 返回排序后的数组 |'
- en: '| `sort!` | Modifies array sorted using `<=>` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `sort!` | 通过 `<=>` 修改排序后的数组 |'
- en: 'You can try the previous methods in the *array_methods.rb* sample program.
    Here are a few examples:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *array_methods.rb* 示例程序中尝试之前的方法。以下是一些示例：
- en: '*array_methods.rb*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*array_methods.rb*'
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although most of the behavior array methods may be deduced from their names,
    the `flatten` and `compact` methods need some explanation. An array is said to
    be *flattened* when it contains no subarrays. So if you have an array like `[1,[2,3]]`,
    you can call `[1,[2,3]].flatten` to return this array: `[1,2,3]`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数数组方法的行为可以从其名称中推断出来，但 `flatten` 和 `compact` 方法需要一些解释。当数组不包含子数组时，我们说它被 *扁平化*。所以如果你有一个像
    `[1,[2,3]]` 这样的数组，你可以调用 `[1,[2,3]].flatten` 来返回这个数组：`[1,2,3]`。
- en: 'An array is said to be *compacted* when it contains no `nil` items. So if you
    have an array like `[1,2,nil,3]`, you can call `[1,2,nil,3].compact` to return
    this array: `[1,2,3]`. The methods of Array can be chained together by placing
    one method call directly after the other:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组不包含 `nil` 项时，我们说它被 *压缩*。所以如果你有一个像 `[1,2,nil,3]` 这样的数组，你可以调用 `[1,2,nil,3].compact`
    来返回这个数组：`[1,2,3]`。可以通过将一个方法调用直接放在另一个方法调用之后来将 Array 的方法链接在一起：
- en: '*flatten_compact.rb*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*flatten_compact.rb*'
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hashes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: Although arrays provide a good way of indexing a collection of items by number,
    sometimes it would be more convenient to index them in some other way. If, for
    example, you were creating a collection of recipes, it would be more meaningful
    to have each recipe indexed by name, such as “Rich Chocolate Cake” and “Coq au
    Vin,” rather than by numbers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组提供了按数字索引项目集合的好方法，但有时按其他方式索引它们会更方便。例如，如果你正在创建一个食谱集合，按名称索引每个食谱（例如，“丰富的巧克力蛋糕”和“红酒炖牛肉”）比按数字更有意义。
- en: Ruby has a class that lets you do just that, called a *hash*. This is the equivalent
    of what some other languages call a dictionary or associative array. Just like
    a real dictionary, each entry is indexed by a unique *key* (in a real-life dictionary,
    this would be a word) that is associated with a value (in a dictionary, this would
    be the definition of the word).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有一个类允许你这样做，称为 *哈希*。这相当于其他语言中称为字典或关联数组的等效物。就像真正的字典一样，每个条目都通过一个唯一的 *键*（在现实生活中的字典中，这将是一个单词）来索引，该键与一个值（在字典中，这将是一个单词的定义）相关联。
- en: Creating Hashes
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建哈希
- en: 'Just like an array, you can create a hash by creating a new instance of the
    Hash class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，你可以通过创建 Hash 类的新实例来创建一个哈希：
- en: '*hash1.rb*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash1.rb*'
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both the previous examples create an empty Hash object. A Hash object always
    has a default value—that is, a value that is returned when no specific value is
    found at a given index. In these examples, `h2` is initialized with the default
    value `"Some kind of ring"`; `h1` is not initialized with a value, so its default
    value will be `nil`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的两个示例都创建了一个空的 Hash 对象。Hash 对象始终有一个默认值——也就是说，当在给定的索引处找不到特定值时返回的值。在这些示例中，`h2`
    使用默认值 `"Some kind of ring"` 初始化；`h1` 没有初始化值，因此它的默认值将是 `nil`。
- en: 'Having created a Hash object, you can add items to it using an arraylike syntax—that
    is, by placing the index in square brackets and using `=` to assign a value. The
    obvious difference is that, with an array, the index (or *key*) must be an integer;
    with a hash, it can be any unique data item:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 Hash 对象后，你可以使用类似数组的语法向其中添加项——也就是说，通过放置索引在方括号内并使用 `=` 来赋值。明显的区别是，在数组中，索引（或
    *键*）必须是整数；在哈希中，它可以是任何唯一的数据项：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Often, the key may be a number or, as in the previous code, a string. In principle,
    however, a key can be any type of object. For example, given some class X, the
    following assignment is perfectly legal:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，键可能是一个数字，或者在之前的代码中是一个字符串。然而，原则上，键可以是任何类型的对象。例如，给定某个类 X，以下赋值是完全合法的：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unique Keys?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一键？
- en: 'Take care when assigning keys to hashes. If you use the same key twice in a
    hash, you will end up overwriting the original value. This is just like assigning
    a value twice to the same index in an array. Consider this example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在将键分配给哈希时请小心。如果你在哈希中使用相同的键两次，你最终会覆盖原始值。这就像在数组中相同的索引处两次赋值一样。考虑以下示例：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here the key `''treasure1''` has been used twice. As a consequence, the original
    value, `''Silver ring''`, has been replaced by `''Sapphire ring''`, resulting
    in this hash:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了两次键 `'treasure1'`。因此，原始值 `'Silver ring'` 被替换为 `'Sapphire ring'`，导致以下哈希：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is a shorthand way of creating Hashes and initializing them with key-value
    pairs. Just add a key followed by `=>` and its associated value; each key-value
    pair should be separated by a comma and the whole lot placed inside a pair of
    curly brackets:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建哈希并使用键值对初始化它们有一个简写方式。只需添加一个键后跟 `=>` 和其关联的值；每个键值对应该用逗号分隔，并将所有内容放在一对大括号内：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Indexing into a Hash
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希索引
- en: 'To access a value, place its key between square brackets:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问一个值，请将其键放在方括号内：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you specify a key that does not exist, the default value is returned. Recall
    that you have not specified a default value for `h1`, but you have for `h2`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定了一个不存在的键，将返回默认值。回想一下，你没有为 `h1` 指定默认值，但你已经为 `h2` 指定了：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use the `default` method to get the default value and the `default=` method
    to set it (see [Chapter 2](ch02.html "Chapter 2. Class Hierarchies, Attributes,
    and Class Variables") for more information on `get` and `set` accessor methods):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `default` 方法获取默认值，并使用 `default=` 方法设置它（有关 `get` 和 `set` 访问器方法的更多信息，请参阅[第
    2 章](ch02.html "第 2 章。类层次结构、属性和类变量")）：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Copying a Hash
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制哈希
- en: 'As with an array, you can assign one Hash variable to another, in which case
    both variables will refer to the same hash, and a change made using either variable
    will affect that hash:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，你可以将一个哈希变量赋给另一个，在这种情况下，两个变量都将引用同一个哈希，并且使用任一变量进行的更改将影响该哈希：
- en: '*hash2.rb*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash2.rb*'
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you want the two variables to refer to the same items in different Hash
    objects, use the `clone` method to make a new copy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让两个变量在不同的哈希对象中引用相同的项，请使用 `clone` 方法创建一个新的副本：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Hash Order
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希顺序
- en: The ordering of elements in a hash varies according to which version of Ruby
    you are using. In Ruby 1.8, a hash is generally stored in the order defined by
    its key where, for example, key 1 is less than key 2\. When new items are added,
    these are inserted in key order. In Ruby 1.9, the hash is stored in the order
    in which it is defined. When new items are added, these are appended to the end
    of the hash.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希中元素的顺序根据你使用的 Ruby 版本而有所不同。在 Ruby 1.8 中，哈希通常按照其键定义的顺序存储，例如，键 1 小于键 2。当添加新项时，这些项将按键顺序插入。在
    Ruby 1.9 中，哈希按照定义的顺序存储。当添加新项时，这些项将附加到哈希的末尾。
- en: As a general principle, it is best to make no assumptions about the order of
    elements in a hash. Most programming languages treat hashes or dictionaries as
    unordered collections. If you make the assumption that hash order is unpredictable,
    not only will you avoid bugs that may occur when running programs with different
    Ruby implementations, but you will also avoid problems that may arise when keys
    are of different types. Remember, a single hash may contain a mix of integer,
    string, and floating-point keys whose relative orders may not be self-evident.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般原则，最好不要对哈希中元素的顺序做出假设。大多数编程语言将哈希或字典视为无序集合。如果你假设哈希顺序是不可预测的，不仅会避免在运行不同 Ruby
    实现的程序时可能出现的错误，而且还会避免当键的类型不同时可能出现的麻烦。记住，单个哈希可能包含整数、字符串和浮点键的混合，它们的相对顺序可能不明显。
- en: '*hash_order.rb*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash_order.rb*'
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When this code is run, Ruby 1.8 produces this output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，Ruby 1.8 产生以下输出：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But Ruby 1.9 shows this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Ruby 1.9 显示如下：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Sorting a Hash
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对哈希进行排序
- en: 'If you want to ensure that the elements of a hash are in a specific order,
    you may sort them. As with the Array class, you may find a slight problem with
    the `sort` method of Hash. It expects to be dealing with keys of the same data
    type, so if, for example, you merge two arrays, one of which uses integer keys
    and another of which uses strings, you won’t be able to sort the merged hash.
    The solution to this problem is, as with Array, to write some code to perform
    a custom type of comparison and pass this to the `sort` method. You might give
    it a method, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保哈希的元素按特定顺序排列，你可以对它们进行排序。与数组类一样，你可能会发现哈希的 `sort` 方法存在一些问题。它期望处理相同数据类型的键，因此，例如，如果你合并两个数组，其中一个使用整数键，另一个使用字符串键，你将无法对合并后的哈希进行排序。解决这个问题的方法，就像数组一样，是编写一些代码来执行自定义类型的比较，并将其传递给
    `sort` 方法。你可能给它一个方法，如下所示：
- en: '*hash_sort.rb*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash_sort.rb*'
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This performs the sort based on the string representation (`to_s`) of each key
    in the hash. In fact, the Hash `sort` method converts the hash to a nested array
    of *[key, value]* arrays and sorts them using the Array `sort` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对哈希中每个键的字符串表示（`to_s`）进行排序。实际上，哈希的 `sort` 方法将哈希转换为嵌套数组，其中包含 `[key, value]`
    数组，并使用数组 `sort` 方法进行排序。
- en: Hash Methods
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希方法
- en: 'The Hash class has numerous built-in methods. For example, to delete an item
    from a hash using its key, use the `delete` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希类有众多内置方法。例如，要使用其键从哈希中删除项，请使用 `delete` 方法：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To combine two hashes, use the `merge` method: `hash1.merge( hash2 )`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要合并两个哈希，请使用 `merge` 方法：`hash1.merge(hash2)`。
- en: To return a new hash created using the original hash’s values as keys and its
    keys as values, use `aHash.invert`. To return an array populated with the hash’s
    keys or values, use `aHash.keys` and `aHash.values`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用原始哈希的值作为键和键作为值来创建新的哈希，请使用 `aHash.invert`。要返回包含哈希键或值的数组，请使用 `aHash.keys` 和
    `aHash.values`。
- en: 'Here’s an example that uses some of these methods:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用这些方法的一些示例：
- en: '*hash_methods.rb*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash_methods.rb*'
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you want to find the position of an item in a hash, use the `index` method
    with Ruby 1.8 and the `key` method in Ruby 1.9\. The `index` method is still present
    in Ruby 1.9 but is deprecated, so it may be removed in future versions:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在哈希中查找项的位置，请使用 Ruby 1.8 中的 `index` 方法或 Ruby 1.9 中的 `key` 方法。`index` 方法在
    Ruby 1.9 中仍然存在，但已弃用，因此可能在未来的版本中删除：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Digging Deeper
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: In this section you will learn more ways of manipulating arrays and hashes as
    well as the fundamentals of matrices, vectors and sets.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习更多操作数组和方法以及矩阵、向量和集合的基础知识。
- en: Treating Hashes as Arrays
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将哈希视为数组
- en: 'The `keys` and `values` methods of Hash each return an array, so you can use
    various Array methods to manipulate them. Here are a few simple examples (remember
    the order of the keys and value may differ according to the version of Ruby being
    used):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的 `keys` 和 `values` 方法每个都返回一个数组，因此你可以使用各种数组方法来操作它们。以下是一些简单的示例（请记住，键和值的顺序可能会根据使用的
    Ruby 版本而有所不同）：
- en: '*hash_ops.rb*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*hash_ops.rb*'
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Appending vs. Concatenating
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 追加与连接
- en: 'Be careful to note the difference between concatenating using `+` to add the
    *values* from the second array to the first and appending using `<<` to add the
    second *array* itself as the final element of the first:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用 `+` 来添加第二个数组的 *值* 到第一个数组中连接和使用 `<<` 来添加第二个 *数组* 本身作为第一个数组的最后一个元素的差异：
- en: '*append_concat.rb*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*append_concat.rb*'
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In addition, `<<` modifies the first (the *receiver*) array, whereas `+` returns
    a new array but leaves the receiver array unchanged.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`<<` 修改第一个（即 *接收者*）数组，而 `+` 返回一个新数组，但不会更改接收者数组。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In object-oriented terminology, the object to which a method belongs is called
    the *receiver*. The idea is that instead of calling functions as in procedural
    languages, “messages” are sent to objects. For example, the message `+ 1` might
    be sent to an integer object, while the message `reverse` might be sent to a string
    object. The object that “receives” a message tries to find a way (that is, a *method*)
    of responding to the message. A string object, for example, has a `reverse` method
    and so is able to respond to the `reverse` message, whereas an integer object
    has no such method so cannot respond.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象术语中，方法所属的对象称为 *接收者*。其思想是，与过程式语言中调用函数不同，向对象发送“消息”。例如，可以将消息 `+ 1` 发送到整数对象，而消息
    `reverse` 可以发送到字符串对象。接收消息的对象会尝试找到一种方式（即一种 *方法*）来响应该消息。例如，字符串对象有一个 `reverse` 方法，因此能够响应
    `reverse` 消息，而整数对象没有这样的方法，因此不能响应。
- en: 'You can use the `flatten` method to clean up two arrays you’ve combined with
    `<<`, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `flatten` 方法清理使用 `<<` 组合的两个数组，如下所示：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Vectors and Matrices
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 向量和矩阵
- en: For the benefit of mathematicians, Ruby provides a Vector class and a Matrix
    class. A *vector* is an ordered set of elements upon which certain mathematical
    operations may be performed. A *matrix* is a collection of rows and columns, and
    each row is itself a vector. Matrices allow you to perform matrix manipulations,
    which is a subject beyond the scope of this book and is only likely to be of interest
    to mathematical programmers. However, you’ll look at some simple examples here.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了数学家的利益，Ruby 提供了 Vector 类和 Matrix 类。一个 *向量* 是一个有序元素集合，可以对它执行某些数学运算。一个 *矩阵*
    是行和列的集合，每一行本身也是一个向量。矩阵允许你执行矩阵操作，这是本书范围之外的主题，并且可能只对数学程序员感兴趣。然而，你将在这里查看一些简单的示例。
- en: 'First, given two Matrix objects, `m1` and `m2`, you can add the values of each
    corresponding cell in the matrices with the plus sign, like this: `m3 = m1+m2`.
    You must import Matrix using a `require` directive in order to use it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，给定两个矩阵对象，`m1` 和 `m2`，你可以使用加号将矩阵中对应单元格的值相加，如下所示：`m3 = m1+m2`。为了使用它，你必须使用 `require`
    指令导入 Matrix：
- en: '*matrix.rb*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*matrix.rb*'
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This outputs the following matrix:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下矩阵：
- en: '[PRE65]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following example creates a matrix from two vectors. By passing vectors
    to the `Matrix.columns()` method, you construct a matrix whose rows are arrays
    of arrays. Here the matrix has two columns created from the vectors `v` and `v2`,
    with each row containing two items, one from each column:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例从两个向量创建一个矩阵。通过将向量传递给 `Matrix.columns()` 方法，你构建一个矩阵，其行是数组的数组。这里矩阵有两个列，由向量
    `v` 和 `v2` 创建，每行包含两个项目，一个来自每个列：
- en: '[PRE66]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This outputs the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If, on the other hand, you pass the same two vectors to the `Matrix.rows()`
    method, you would end up by creating a matrix that contains two rows, each of
    which is a vector:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你将相同的两个向量传递给 `Matrix.rows()` 方法，你将创建一个包含两行的矩阵，每行都是一个向量：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This outputs the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Sets
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: 'The Set class implements a collection of unordered values with no duplicates.
    You can initialize a Set with an array of values, in which case duplicates are
    ignored:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Set 类实现了一个无序值集合，其中没有重复项。你可以使用值数组初始化一个 Set，在这种情况下，将忽略重复项：
- en: '*sets.rb*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*sets.rb*'
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can add new values using the `add` method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `add` 方法添加新值：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `merge` method combines values of one set with another:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 方法将一个集合的值与另一个集合的值合并：'
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can use `==` to test for equality. Two sets that contain the same values
    (remembering that duplicates will be removed when a set is created) are considered
    to be equal:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `==` 来测试相等性。包含相同值（记住，当创建集合时将删除重复项）的两个集合被认为是相等的：
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you display the contents of a set, the order may differ according to the
    version of Ruby being used. If order is important, you may convert a set to an
    array using the `to_a` method and use a standard or custom sort, as explained
    in [Sorting Arrays](ch04.html#sorting_arrays "Sorting Arrays") in [Sorting Arrays](ch04.html#sorting_arrays
    "Sorting Arrays"):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你显示集合的内容，顺序可能会根据所使用的 Ruby 版本而有所不同。如果顺序很重要，你可以使用 `to_a` 方法将集合转换为数组，并使用标准或自定义排序，如
    [排序数组](ch04.html#sorting_arrays "Sorting Arrays") 中所述：
- en: '[PRE74]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
