- en: Chapter 8. DATA FORMATS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 数据格式
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Working with maps usually means interacting with a lot of geographic data. Along
    with descriptive information, you need to know where a place is so you can plot
    it on your map. Chances are good that most of the time you'll need to get data
    from someone else. You might also need to share your data with someone.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与地图一起工作通常意味着与大量地理数据交互。除了描述性信息外，你还需要知道一个地方的位置，以便你可以在地图上绘制它。很可能大多数时候你都需要从其他人那里获取数据。你也可能需要与他人共享你的数据。
- en: 'Several standard formats have been adopted to make passing around geographic
    data even easier. In this chapter, I''ll go over a few ways to share the basic
    pieces of geography you''d put on a map: points, lines, and shapes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使地理数据的传递更加方便，已经采用了几种标准格式。在本章中，我将介绍几种分享地图上基本地理元素（点、线和形状）的方法。
- en: We'll also go over a couple formats that are popular on the web for exchanging
    information. More and more, your sources will be websites that make their data
    available with an API. In most cases, the format you'll need is covered in this
    chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将介绍一些在网络上用于交换信息的流行格式。越来越多地，你的数据源将是提供API以使其数据可用的网站。在大多数情况下，你需要的格式在本章中都有涵盖。
- en: Let's get started and learn some data formats.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习一些数据格式。
- en: '#52: Use XML'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#52: 使用XML'
- en: The *Extensible Markup Language (XML)* is the building block of much of the
    Web's data and of several other formats discussed in this chapter. It looks a
    lot like HTML, because some HTML actually *is* XML. This section will stay away
    from specific flavors of XML, however, as I'll be covering some in their own sections.
    Here, I'll focus on how to recognize and use generic XML.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展标记语言（XML）是本章讨论的许多Web数据和格式的基础。它看起来很像HTML，因为一些HTML实际上就是XML。然而，本节将避免具体XML变体，因为我会单独在其他章节中介绍它们。在这里，我将专注于如何识别和使用通用XML。
- en: First, what does it look like? XML is made up of tags, which are words inside
    pointed greater-than and less-than brackets, `<` and `>`. Understanding what the
    words inside the brackets stand for is usually easy, but sometimes they are abbreviations
    or acronyms. Tags can contain other tags, as well as *`key`*`=`*`value`* pairs,
    which are called *attributes*. Tags containing other tags or text end with a matching
    closing tag that includes a `/` before the tag name.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它看起来是什么样子？XML由标签组成，这些标签是尖括号`<`和`>`内的单词。理解括号内的单词通常很容易，但有时它们是缩写或首字母缩略词。标签可以包含其他标签，以及*`key`*`=`*`value`*对，这些对被称为*属性*。包含其他标签或文本的标签以匹配的结束标签结束，该结束标签在标签名之前包含一个`/`。
- en: 'Consider this short example XML file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个简短的XML文件示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: XML files usually start off in a similar way, with a processing instruction
    declaring it as XML ❶ and providing version and encoding information. This special
    tag does not have a corresponding end tag. With this header out of the way, we
    get straight to the data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件通常以类似的方式开始，有一个处理指令声明其为XML❶并提供版本和编码信息。这个特殊标签没有对应的结束标签。移除这个头部后，我们就可以直接进入数据部分。
- en: The root element ❷ can be named anything, but you can only have one. For example,
    HTML only has one `<html>` tag. Within the starting and ending root tags comes
    the real XML content. In this case, the XML has two child elements. Again, the
    tags can be named anything, but I've used names that help describe XML terms in
    this example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素❷可以命名为任何名称，但只能有一个。例如，HTML只有一个`<html>`标签。在起始和结束根标签之间是真正的XML内容。在这种情况下，XML有两个子元素。再次强调，标签可以命名为任何名称，但在这个例子中，我使用了有助于描述XML术语的名称。
- en: XML is hierarchical, and accessing the data requires understanding its structure.
    The first child element has a single attribute ❸ and a child element ❹ of its
    own. The second child element also has an attribute, but it contains no children.
    When this is the case, we can abbreviate the closing tag ❺.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: XML是分层的，访问数据需要理解其结构。第一个子元素有一个单一属性❸以及它自己的子元素❹。第二个子元素也有一个属性，但它不包含任何子元素。在这种情况下，我们可以缩写结束标签❺。
- en: Now we want to get at this data inside the XML. Reading in the tags and converting
    them to a structure the computer can understand is called *parsing*. Most languages
    have some built-in way to parse XML. Next I'll show two JavaScript examples and
    one using PHP, a server-side programming language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要获取 XML 中的这些数据。读取标签并将它们转换为计算机可以理解的结构称为 *解析*。大多数语言都有一些内置的解析 XML 的方法。接下来，我将展示两个
    JavaScript 示例和一个使用 PHP 的示例，PHP 是一种服务器端编程语言。
- en: Parse XML with JavaScript
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 解析 XML
- en: Every modern browser comes with a way to read in XML content, which makes sense
    seeing as so much of the Web is built upon the technology. Unfortunately, the
    various browsers have their differences. Also, getting at deeply nested elements
    can be a pain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现代浏览器都提供了一种读取 XML 内容的方法，这在很大程度上是因为网络的大部分内容都是基于这项技术构建的。不幸的是，各种浏览器之间存在差异。此外，获取深层嵌套的元素可能会很麻烦。
- en: Before showing an easier way, we'll give it a go in this section using the XML
    example just described. Rather than loading in an XML file (which I'll get to
    in the next section), we'll use XML that is stored as a string of text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示更简单的方法之前，我们将使用前面描述的 XML 示例在这个部分尝试一下。我们不会加载 XML 文件（我将在下一节中介绍），而是使用存储为文本字符串的
    XML。
- en: 'Because we are using JavaScript, the file needs to live inside a web page.
    Everything we''ll be doing will be in the JavaScript portion, so the web page
    will otherwise be blank. Add these lines into a new file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 JavaScript，文件需要位于网页内部。我们将在 JavaScript 部分进行所有操作，因此网页将保持空白。将这些行添加到新文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bold lines are the ones that get at the data. Everything else is pure setup.
    To be fair, getting the XML text ready ❶ does take seven lines. We could reduce
    this to a single line, but I've expanded it for clarity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体行是获取数据的那一行。其余的都是纯设置。公平地说，准备 XML 文本 ❶ 确实需要七行代码。我们可以将其缩减为单行，但我将其展开以增强可读性。
- en: Parsing the XML requires a multistep approach. First, we need to try the Internet
    Explorer way ❷. This method will fail if we are using another browser. Then, we
    get to the use the more widely adopted method ❸. Hopefully this one works, because
    if it doesn't, we can't parse the XML.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 XML 需要一个多步骤的方法。首先，我们需要尝试 Internet Explorer 的方法 ❷。如果我们使用的是其他浏览器，这种方法将失败。然后，我们将使用更广泛采用的方法
    ❸。希望这种方法能奏效，因为如果它不起作用，我们就无法解析 XML。
- en: The `x` variable should contain an XML object after those two tries. This variable
    is used by the bold section to extract the names of the children. First, we look
    through the XML for all the child tags ❹. Then, we loop through all of those tags
    ❺. We can tell which step we're on by the `i` variable, which starts at zero and
    counts up each step. Each time through the loop, we add the name of the current
    child to the text we will output ❻.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两次尝试之后，`x` 变量应该包含一个 XML 对象。这个变量被粗体部分用来提取子元素的名称。首先，我们遍历 XML 中的所有子标签 ❹。然后，我们循环遍历所有这些标签
    ❺。我们可以通过 `i` 变量来判断我们处于哪个步骤，它从零开始，每次循环增加一步。每次循环中，我们将当前子元素的名称添加到我们将要输出的文本中 ❻。
- en: If you load this file into a web browser, you should see a JavaScript alert
    with the names "first" and "second." You've successfully parsed XML with plain
    ol' JavaScript. Now let's check out how you parse it with the JavaScript library
    jQuery.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此文件加载到网页浏览器中，你应该会看到一个包含 "first" 和 "second" 名称的 JavaScript 提示框。你已经成功使用纯 JavaScript
    解析了 XML。现在让我们看看如何使用 JavaScript 库 jQuery 来解析它。
- en: Parse XML with jQuery JavaScript Library
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 jQuery JavaScript 库解析 XML
- en: The single principle behind jQuery is to write less code. The hard work is left
    to the library, which itself is very small (currently less than 20K). When it
    comes to fetching and parsing XML, jQuery keeps things predictably simple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 的单一原则是编写更少的代码。艰苦的工作留给了库，而库本身非常小（目前小于 20K）。当涉及到获取和解析 XML 时，jQuery 保持简单且可预测。
- en: 'Like the plain JavaScript example, we''ll be parsing the XML in an otherwise
    empty HTML file. However, in this case, we''ll load our XML straight from a file,
    which is a common situation. Make sure you have a file named *example.xml* containing
    the XML from earlier, and then add these lines to a new file in the same directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与纯 JavaScript 示例类似，我们将在一个空白的 HTML 文件中解析 XML。然而，在这种情况下，我们将直接从文件中加载我们的 XML，这是一个常见的情况。确保你有一个名为
    *example.xml* 的文件，其中包含之前提到的 XML，然后将这些行添加到同一目录下的新文件中：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing you'll notice is that we need to load the jQuery JavaScript
    file ❶. You can download it to your own server from [http://jquery.com/](http://jquery.com/)
    or reference a version hosted by Google, as I did in this example. In either case,
    we get access to the library's many features, which include using Ajax to load
    files with JavaScript and parsing XML.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到我们需要加载 jQuery JavaScript 文件 ❶。你可以从 [http://jquery.com/](http://jquery.com/)
    下载到自己的服务器上，或者像我在这个例子中那样引用由 Google 托管的版本。在任一情况下，我们都可以访问库的许多功能，包括使用 JavaScript 通过
    Ajax 加载文件以及解析 XML。
- en: The jQuery library makes use of many techniques to decrease the amount of JavaScript
    you need to write. Among them is the *dollar sign object*, which allows you to
    access much of jQuery's functionality with very simple syntax. For example, loading
    an XML file is accomplished by calling the `$.get` function ❷.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 库利用了许多技术来减少你需要编写的 JavaScript 量。其中之一是 *美元符号对象*，它允许你使用非常简单的语法访问 jQuery
    的许多功能。例如，加载 XML 文件是通过调用 `$.get` 函数 ❷ 来实现的。
- en: To implement an Ajax call without jQuery requires trying different methods depending
    on the browser, much like our XML parsing example in the previous section. Instead,
    jQuery does the work to ensure we can get at the data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要在没有 jQuery 的情况下实现 Ajax 调用，需要根据浏览器尝试不同的方法，就像我们在上一节中的 XML 解析示例一样。相反，jQuery 做了工作，确保我们可以获取数据。
- en: 'Loading the XML also shows an example of another technique for decreasing code:
    inline, *anonymous functions*. These functions are part of the standard JavaScript
    language but become especially useful with the way jQuery simplifies code. When
    performing an Ajax call, such as the one we use to load our XML file, JavaScript
    needs a callback function. Rather than creating a named function just to receive
    the XML results, we can write one inline ❸.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 XML 还展示了另一种减少代码的技术：内联的、*匿名函数*。这些函数是标准 JavaScript 语言的一部分，但与 jQuery 简化代码的方式结合使用时变得特别有用。当执行
    Ajax 调用，例如我们用来加载 XML 文件的调用时，JavaScript 需要一个回调函数。而不是创建一个命名函数仅用于接收 XML 结果，我们可以直接编写一个内联函数
    ❸。
- en: Inside the anonymous function (so named because it doesn't have a name), we
    use another jQuery shorthand to parse the XML. The parsing happens so fast, you
    might not even realize it's happening. The dollar sign function is passed the
    tag name we want, along with the XML variable that holds the content we got back
    from the Ajax call ❹. Then we chain the jQuery `each` function to the result,
    and we can loop through all the child elements ❺. We don't have to use an explicit
    `for` loop, nor do we need to determine the number of children. That happens within
    jQuery.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名函数（之所以这样命名是因为它没有名字）内部，我们使用另一个 jQuery 简写来解析 XML。解析发生得如此之快，你可能甚至都没有意识到它在发生。美元符号函数传递了我们想要的标签名称，以及包含我们从
    Ajax 调用中获取的内容的 XML 变量 ❹。然后我们将 jQuery 的 `each` 函数链接到结果，我们可以遍历所有子元素 ❺。我们不需要使用显式的
    `for` 循环，也不需要确定子元素的数量。这都在 jQuery 内部完成。
- en: What we do each time through the jQuery loop is determined by another anonymous
    function. Again, we just keep everything inline because having a named function
    for one line of code doesn't make sense. Of course, the code is only one line
    because we're using jQuery. The `this` variable holds the current child element,
    and then we use the same `getAttribute` function we used in the non-jQuery example
    to grab the name attribute ❻.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每次通过 jQuery 循环所做的事情由另一个匿名函数决定。同样，我们只是将一切保持内联，因为为了一行代码而创建一个命名函数是没有意义的。当然，代码只有一行，因为我们使用了
    jQuery。`this` 变量持有当前子元素，然后我们使用在非 jQuery 示例中使用的相同的 `getAttribute` 函数来获取名称属性 ❻。
- en: In about half the lines as the previous example, we achieved the same result.
    If you load the file in your web browser, a JavaScript alert will print the names
    of the child tags, "first" and "second." jQuery makes it easy to do the stuff
    you'll do often as you work with APIs and parse data formats, many of which use
    XML.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大约是前一个例子一半的行数中，我们达到了相同的结果。如果你在网页浏览器中加载该文件，JavaScript 警告将打印出子标签的名称，“first” 和
    “second”。jQuery 使得在处理 API 和解析数据格式时，你经常要做的事情变得容易，其中许多使用 XML。
- en: Parse XML with PHP
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PHP 解析 XML
- en: In many cases, you'll want to retrieve XML on your server. To do this, you won't
    use JavaScript, because you usually write JavaScript inside a web browser; you'll
    use PHP. PHP is a popular programming language for coding server-side applications.
    For more about PHP and making sure you have it available on your server, be sure
    to read [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能会想在服务器上检索XML。为此，你不会使用JavaScript，因为你通常在Web浏览器中编写JavaScript；你会使用PHP。PHP是一种流行的编程语言，用于编写服务器端应用程序。有关PHP以及确保你的服务器上有PHP的更多信息，请务必阅读[第9章](ch09.html
    "第9章。GO 服务器端")。
- en: 'Let''s parse the example XML from the previous sections using PHP. Make sure
    you have a file named *example.xml* on your server. Create a new PHP file in the
    same directory and add these lines:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用PHP解析上一节中的示例XML。确保你的服务器上有一个名为*example.xml*的文件。在同一目录下创建一个新的PHP文件，并添加以下行：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first thing we do is load our example XML file into the `$xmltxt` variable
    ❶. In many cases, we'll actually be loading the XML from an API. Either way, the
    XML content ends up in a variable, ready to be parsed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将示例XML文件加载到`$xmltxt`变量中❶。在许多情况下，我们实际上是从API加载XML。无论如何，XML内容最终会存储在一个变量中，以便进行解析。
- en: We pass the work of going through the XML to PHP's `SimpleXML` class, which
    is included automatically in PHP 5\. The `simplexml_load_string` function converts
    the textual XML into a useful object ❷ for accessing the data inside the XML.
    A `simplexml_load_file` function is also available, but again, most of the time
    you'll be converting a string that you retrieved from an API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解析XML的工作交给PHP的`SimpleXML`类，这个类在PHP 5中是自动包含的。`simplexml_load_string`函数将文本XML转换为有用的对象❷，以便访问XML内部的数据。还有一个`simplexml_load_file`函数，但通常情况下，你会将从一个API获取的字符串转换为字符串。
- en: Once the XML is in object form, we can look for the name attribute within the
    child elements. We need to loop through all the child elements ❸, placing the
    current child inside its own object. Then, we get the attributes ❹ and find the
    one called name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦XML以对象形式存在，我们就可以在子元素中查找名称属性。我们需要遍历所有子元素❸，将当前子元素放入它自己的对象中。然后，我们获取属性❹并找到名为name的属性。
- en: 'The code to query the XML will make more sense if you see what the object that
    PHP creates looks like. Use `print_r($xmlobj)` to see a textual representation
    of the hierarchical object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到PHP创建的对象的样子，查询XML的代码将更有意义。使用`print_r($xmlobj)`来查看层次对象的文本表示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: First of all, everything is inside a single `SimpleXMLElement` object, just
    as all the XML is within the root tag. Additional `SimpleXMLElement` objects are
    included as well, which is similar to having tags within tags. The SimpleXML class
    essentially converts XML into a series of arrays.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，所有内容都在一个`SimpleXMLElement`对象内部，就像所有XML都在根标签内一样。还包括额外的`SimpleXMLElement`对象，这类似于标签内有标签。SimpleXML类本质上将XML转换为一系列数组。
- en: To begin, a numerical array of all the child elements ❶ is created. In this
    case, only two child elements are included, numbered 0 and 1, because, as with
    JavaScript, array indexes in PHP start at zero. Each child has an attributes array
    ❷, which is associative, meaning it ctontains key and value pairs. The key is
    the attribute name, in this case `name`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个包含所有子元素的数值数组❶。在这种情况下，只包含两个子元素，编号为0和1，因为，就像JavaScript一样，PHP中的数组索引从零开始。每个子元素都有一个属性数组❷，它是关联数组，意味着它包含键值对。键是属性名，在这种情况下是`name`。
- en: Finally, if tags within the tag exist, they're listed. In this case, the second
    child tag contains a grandchild tag ❸. This tag contains only text, so it's represented
    as a key and value pair, too. If it contained tags or attributes underneath it,
    we'd have yet another `SimpleXMLElement`. Again, the `SimpleXML` class is all
    about finding a way to represent XML inside a PHP object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果标签内部存在标签，它们会被列出。在这种情况下，第二个子标签包含一个孙子标签❸。这个标签只包含文本，所以它也被表示为一个键值对。如果它包含下层的标签或属性，我们就会有另一个`SimpleXMLElement`。再次强调，`SimpleXML`类主要是为了在PHP对象中找到表示XML的方法。
- en: Even Simpler XML with XPath
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更简单的XML与XPath
- en: Traversing the `SimpleXML` object works fine in basic cases where the XML file
    is short and does not include a deep nesting of tags within tags. If you are swamped
    with XML content, you might find querying with XPath simpler.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本情况下，如果XML文件较短且不包含深层嵌套的标签，遍历`SimpleXML`对象是可行的。如果你被大量的XML内容淹没，你可能会发现使用XPath查询更简单。
- en: Like XML, XPath is a web standard. You can use XPath to traverse down through
    the XML to the data you want. All you need to do is call the `xpath` function
    on the `SimpleXML` object and tell it the "path" you want to access.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与 XML 一样，XPath 是一个网络标准。您可以使用 XPath 遍历 XML 到您想要的数据。您需要做的就是调用 `SimpleXML` 对象上的
    `xpath` 函数，并告诉它要访问的“路径”。
- en: All three of the following examples find the same element, the grandchild tag,
    which is nested within two levels of hierarchy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个示例都找到了相同的元素，即孙子标签，它嵌套在两层层次结构中。
- en: 'You can use the full path to the element:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用元素的完整路径：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or prepend a double slash to get every grandchild tag, regardless of what tags
    surround it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在前面加上一个双斜杠以获取所有孙子标签，无论它们周围有什么标签：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or mix and match. Here, we grab any grandchild tag that exists below a child
    tag:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者混合匹配。在这里，我们获取任何位于子标签下的孙子标签：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: XPath can help you quickly access XML in even more ways, such as querying for
    specific values, but I won't cover them here. You can find out more about XPath
    and `SimpleXML`, in general, at [http://php.net/simplexml](http://php.net/simplexml).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: XPath 可以帮助您以更多方式快速访问 XML，例如查询特定值，但这里不会涵盖它们。您可以在 [http://php.net/simplexml](http://php.net/simplexml)
    上了解更多关于 XPath 和 `SimpleXML` 的信息。
- en: 'I''ve shown you several methods for accessing XML: JavaScript, the jQuery library,
    and PHP. What you use depends on where you''re getting your XML, how complicated
    the XML is, and what languages you''re already using.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经向您展示了几个访问 XML 的方法：JavaScript、jQuery 库和 PHP。您使用什么取决于您从哪里获取 XML，XML 的复杂程度以及您已经使用的语言。
- en: 'Alternatively, you may grow weary of parsing XML and porting it to your JavaScript
    maps. Many programmers prefer working directly with a format called JSON that
    is closer to true JavaScript. Read on to learn about that format, and see [#57:
    Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON") in [#57:
    Convert from XML to JSON](ch08s06.html "#57: Convert from XML to JSON") to learn
    about turning XML into the easier-to-use JSON.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '或者，您可能会厌倦解析 XML 并将其移植到您的 JavaScript 地图。许多程序员更喜欢直接使用一种称为 JSON 的格式，这种格式更接近真正的
    JavaScript。继续阅读以了解该格式，并查看在 [#57: 将 XML 转换为 JSON](ch08s06.html "#57: Convert from
    XML to JSON") 中的 [#57: 将 XML 转换为 JSON](ch08s06.html "#57: Convert from XML to
    JSON")，了解如何将 XML 转换为更易于使用的 JSON。'
- en: '#53: Use JSON'
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#53: 使用 JSON'
- en: With JavaScript's ever-increasing popularity on the Web, JSON is quickly becoming
    the preferred data format for developers. That's because JSON stands for *JavaScript
    Object Notation* and almost no parsing is necessary to use it in JavaScript. Plus,
    JSON takes fewer characters than XML to express the same data because it has no
    closing tags
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JavaScript 在网络上的日益流行，JSON 正迅速成为开发者的首选数据格式。这是因为 JSON 代表 *JavaScript Object
    Notation*，在 JavaScript 中使用它几乎不需要解析。此外，JSON 比表示相同数据所需的 XML 字符少，因为它没有闭合标签。
- en: You aren't restricted to any one language. You can parse JSON in many server-side
    programming languages. I'll give an example using PHP later. Most modern languages
    have a data structure that makes converting JSON easy. This, along with JavaScript's
    popularity, have made this format widely used for interchanging data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您不受任何一种语言的限制。您可以在许多服务器端编程语言中解析 JSON。我将在稍后使用 PHP 举一个例子。大多数现代语言都有一种数据结构，使得将 JSON
    转换变得容易。这，加上 JavaScript 的流行，使得这种格式在数据交换中得到了广泛的应用。
- en: 'Enough about JSON''s usefulness: Let''s see an example of what JSON looks like.
    The following shows how the XML in the previous project might be expressed in
    JSON:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON 的有用性就说到这里：让我们看看 JSON 的一个例子。以下显示了上一个项目中 XML 的表示方式：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This basic example is a bit more complex than it needs to be, but it showcases
    many of the ways data can be organized in JSON. The building blocks are a series
    of key and value pairs inside braces, a structure called an object in JavaScript.
    The fun comes with the definition of a value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本示例比它需要的复杂一些，但它展示了数据在 JSON 中可以组织的多种方式。构建块是一系列键值对，位于大括号内，在 JavaScript 中称为对象。乐趣在于值的定义。
- en: In this example, our main object ❶ has only one key, `child`. The value is an
    array, declared by the brackets. An array can itself contain a list of values.
    In this case, the values are yet more objects.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的主要对象 ❶ 只有一个键，`child`。值是一个数组，由括号声明。数组本身可以包含一系列值。在这种情况下，值是更多的对象。
- en: The first object in the array ❷ contains a single key, `attributes`, and yet
    another object within it. Finally, the new object, which is three levels deep
    now, contains a key `name` and value of `first`. The second object in the array
    ❸ has a similar first key-value pair and then a second key, `grandchild`, which
    has a textual value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的第一个对象 ❷ 包含一个单独的键，`attributes`，以及它内部的另一个对象。最终，现在有三个级别的新的对象包含一个键 `name` 和值为
    `first`。数组中的第二个对象 ❸ 有一个类似的第一键值对，然后是一个第二键，`grandchild`，它有一个文本值。
- en: So, a value can be an array, another object, or plain text. It could also be
    a number, a boolean, or a null, though I haven't shown that in this example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个值可以是一个数组、另一个对象或纯文本。它也可以是一个数字、布尔值或 null，尽管我没有在这个例子中展示这一点。
- en: Are you confused by the circular definition of what makes a value? That complication
    is intentional, but it actually ends up being an easy way to express many types
    of data. Because an object can contain arrays, objects, or even arrays of other
    objects, many types of hierarchical data can be expressed with JSON in a very
    small amount of space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否被“值是什么”的循环定义弄糊涂了？这种复杂性是有意为之的，但实际上它实际上是一种表达多种类型数据简单的方法。因为一个对象可以包含数组、对象，甚至是其他对象的数组，所以许多类型分层的数据可以用
    JSON 在非常小的空间内表达。
- en: Now that you have an idea of how JSON looks, let's start using it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 JSON 的样子，让我们开始使用它。
- en: Parse JSON with JavaScript and jQuery
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 和 jQuery 解析 JSON
- en: Remember what JSON stands for? JavaScript Object Notation. This data format
    was not only made *for* JavaScript but also made *from* it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得 JSON 代表什么吗？JavaScript 对象表示法。这种数据格式不仅是为了 JavaScript 而创建的，也是从它那里发展而来的。
- en: 'If you are hard-coding JSON into JavaScript, you don''t need to do anything
    to use the data inside it. It is ready to go as written. Here, we access the first
    child in the example JSON using JavaScript:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 JSON 直接硬编码到 JavaScript 中，你不需要做任何事情来使用它内部的数据。它已经准备好了。在这里，我们使用 JavaScript
    访问示例 JSON 中的第一个子元素：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I added the portion of the code in bold. Otherwise, this code is the exact JSON
    from earlier. All I did was assign it to a variable (`obj`), end the declaration
    with a semicolon (`;`), and then alert a specific value from the object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了粗体的代码部分。否则，这段代码就是之前提到的确切 JSON。我所做的就是将它赋给一个变量（`obj`），用分号（`;`）结束声明，然后从对象中警报一个特定的值。
- en: Of course, JSON is not likely to be written directly into JavaScript. Instead,
    you'll probably receive it as output from an API. In other words, you might have
    JSON in text form.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，JSON 很可能不会直接写入 JavaScript。相反，你可能会从 API 接收它。换句话说，你可能会以文本形式拥有 JSON。
- en: If you trust the data, you can use the JavaScript `eval` function to convert
    JSON from text to object. Ensuring you have good data is a smart idea, however,
    because `eval` will execute any JavaScript text, not just text in the JSON format.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你信任数据，你可以使用 JavaScript 的 `eval` 函数将 JSON 从文本转换为对象。然而，确保你有良好的数据是一个明智的想法，因为
    `eval` 将执行任何 JavaScript 文本，而不仅仅是 JSON 格式的文本。
- en: To avoid potentially large security issues, the `parseJSON` function has been
    added in some browsers. But this function is only really useful if it works in
    every browser. You can use a JavaScript file available at [http://json.org/](http://json.org/)
    to fill the gaps while waiting for every browser to support the latest JavaScript
    version.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免可能的大型安全问题，一些浏览器中添加了 `parseJSON` 函数。但这个函数只有在它在每个浏览器中都有效时才真正有用。你可以在等待每个浏览器都支持最新的
    JavaScript 版本的同时，使用 [http://json.org/](http://json.org/) 上可用的 JavaScript 文件来填补空白。
- en: Another option is use the jQuery JavaScript library, which has an easy way to
    fetch data with Ajax. In fact, you can retrieve and parse JSON within a single
    line of jQuery.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 jQuery JavaScript 库，它有一个简单的方法通过 Ajax 获取数据。实际上，你可以在 jQuery 中单行检索和解析
    JSON。
- en: 'Add these lines to a new HTML file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行添加到一个新的 HTML 文件中：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To access the many useful jQuery functions, we need to include the jQuery JavaScript
    file ❶. Although you can download this file to your server from [http://jquery.com/](http://jquery.com/),
    you can also reference a Google-hosted version, as I've done here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问许多有用的 jQuery 函数，我们需要包含 jQuery JavaScript 文件 ❶。虽然你可以从 [http://jquery.com/](http://jquery.com/)
    下载此文件到你的服务器，但你也可以引用一个由 Google 托管的版本，就像我在这里所做的那样。
- en: jQuery does much of the difficult work for you and makes writing very short
    JavaScript that performs advanced functions possible. One of its more apparent
    ways of reducing code is to introduce the dollar sign object. Much of what happens
    in jQuery goes through `$`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery为你做了很多困难的工作，使得编写执行高级功能的非常短的JavaScript成为可能。它减少代码的一种更明显的方式是引入美元符号对象。jQuery中发生的大部分事情都通过`$`进行。
- en: For example, we use the `$.getJSON` jQuery function to create an Ajax call to
    download and parse a JSON file. The most important information we need to provide
    is the JSON URL ❷. This URL can be a local file or a call to an external API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用jQuery的`$.getJSON`函数来创建一个Ajax调用，下载并解析一个JSON文件。我们需要提供的重要信息是JSON URL ❷。这个URL可以是一个本地文件，或者是对外部API的调用。
- en: Next, jQuery requires a function reference. In this case, we use an inline,
    anonymous function ❸ to describe what we want to do with the JSON result. Again,
    jQuery is about reducing code, but understanding what is happening here is still
    important. Ajax fetches our JSON, which is then parsed into an object. That object
    is returned to the anonymous function, where we can do whatever we want with it.
    In this case, I create an alert ❹ with the first child's name, just as I did when
    the data was hard-coded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，jQuery需要一个函数引用。在这种情况下，我们使用一个内联的匿名函数 ❸ 来描述我们想要对JSON结果做什么。同样，jQuery关于减少代码，但理解这里发生的事情仍然很重要。Ajax获取我们的JSON，然后将其解析为对象。该对象返回给匿名函数，我们可以在其中做任何我们想做的事情。在这种情况下，我创建了一个带有第一个子元素名称的警告
    ❹，就像当数据是硬编码时一样。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are calling an external API that returns JSON, for security reasons,
    that API will need to accept a callback function name. To see an example of this
    in action, check out how I retrieve JSON from Yahoo! Pipes in [#69: Create a Weather
    Map](ch10s02.html "#69: Create a Weather Map") in [#69: Create a Weather Map](ch10s02.html
    "#69: Create a Weather Map").'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你调用返回JSON的外部API，出于安全原因，该API需要接受一个回调函数名称。要查看这个功能的示例，请查看我在[第69节：创建天气地图](ch10s02.html
    "#69: 创建天气地图")中如何从Yahoo! Pipes检索JSON的[#69: 创建天气地图](ch10s02.html "#69: 创建天气地图")。'
- en: Building on top of jQuery can save you time and allow you to focus on higher-level
    issues with your mapping projects. You also get an added layer of complexity because
    you have one more piece of JavaScript to include in your HTML. Hopefully its benefits
    make up for this minor cost in loading time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在jQuery的基础上构建可以节省你的时间，并允许你专注于映射项目的高级问题。你也会得到一个额外的复杂性层，因为你需要在HTML中包含更多的JavaScript。希望它的好处可以弥补这个加载时间上的小成本。
- en: Parse JSON with PHP
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PHP解析JSON
- en: Sometimes you just need the data on the server. If the data is in JSON format,
    you won't be able to use JavaScript because it's almost always written inside
    a web browser. Most languages can easily read JSON though, so you'll find it's
    a reasonable format to use on a server, as well as on a client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你只需要服务器上的数据。如果数据是JSON格式，你将无法使用JavaScript，因为它几乎总是写在网页浏览器中。尽管如此，大多数语言都可以轻松读取JSON，所以你会发现它是一个在服务器上以及客户端上使用都合理的格式。
- en: I'll use PHP again as an example server-side programming language because of
    its availability on most web hosts. If you're new to PHP, I provide an introduction
    to using PHP for geo projects in [Chapter 9](ch09.html "Chapter 9. GO SERVER-SIDE").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将再次使用PHP作为示例服务器端编程语言，因为它在大多数网络主机上都是可用的。如果你是PHP的新手，我在[第9章](ch09.html "第9章。地理项目使用PHP")中提供了PHP用于地理项目的介绍。
- en: At the beginning of this project, I said that most languages have a JSON-like
    data structure. The JavaScript object, with its key-value pairs, is represented
    as an associative array in PHP. Similarly, PHP also has standard arrays, in addition
    to strings of text and numbers. In other words, all the pieces are here to represent
    JSON fully.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的开始阶段，我说过大多数语言都有类似JSON的数据结构。JavaScript对象，通过其键值对，在PHP中表现为关联数组。同样，PHP也有标准数组，除了文本和数字字符串。换句话说，所有这些部分都是为了完全表示JSON。
- en: 'Here is some sample PHP that declares the exact same data I used in the sample
    JSON file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些示例PHP代码，它声明了我在示例JSON文件中使用的数据：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we know representing JSON in PHP is possible, how do we go about parsing
    from text to associative array? Beginning with PHP 5, you can parse JSON with
    a single call.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道在PHP中表示JSON是可能的，我们如何从文本解析到关联数组呢？从PHP 5开始，你可以通过单个调用解析JSON。
- en: 'Here''s an example accessing the name of the first child, with the JSON text
    hard-coded. Yours will likely come from an API, or possibly a file, instead:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，通过硬编码的 JSON 文本来访问第一个子元素的名字。你的可能来自 API，或者可能是一个文件：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Yes, all the work is passed off for the internal PHP function ❶ to perform.
    Instead of using associative arrays, as we did previously, `json_decode` uses
    a PHP object. This object is slightly different but has a similar way of expressing
    data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，所有的工作都交由内部 PHP 函数 ❶ 来执行。与之前我们使用的关联数组不同，`json_decode` 使用 PHP 对象。这个对象略有不同，但表达数据的方式相似。
- en: The keys, such as `child` ❷, are instance variables of the object and are referenced
    with the `->` arrow. All other types of data, including regular arrays, go through
    as-is. Just as with all other examples, the name of the first child can be found
    three levels down.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `child` ❷ 这样的键是对象的实例变量，并且通过 `->` 箭头引用。所有其他类型的数据，包括常规数组，都按原样传递。就像所有其他例子一样，第一个子元素的名字可以在三个级别以下找到。
- en: The curious reader might be wondering if another function exists to create JSON
    text from PHP data structures. Of course! The opposite of `json_decode` is `json_encode`.
    You could pass the `$obj` variable from the first example or the `$jobj` variable
    from the second example, and the result would be identical to the JSON text stored
    in the `$jtxt` variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者可能会想知道是否还有另一个函数可以从 PHP 数据结构中创建 JSON 文本。当然！`json_decode` 的反义词是 `json_encode`。你可以传递第一个示例中的
    `$obj` 变量或第二个示例中的 `$jobj` 变量，结果将与存储在 `$jtxt` 变量中的 JSON 文本相同。
- en: 'You will likely need to decode JSON more often than encode it. That said, you''ll
    be glad that function exists when you need it. For an example of encoding JSON,
    check out [#71: Search Music Events by Location](ch10s04.html "#71: Search Music
    Events by Location") in [#71: Search Music Events by Location](ch10s04.html "#71:
    Search Music Events by Location").'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能需要比编码更频繁地解码 JSON。话虽如此，当你需要它时，你会很高兴这个函数存在。关于编码 JSON 的例子，请查看 [#71: 通过位置搜索音乐活动](ch10s04.html
    "#71: 通过位置搜索音乐活动")。'
- en: 'Though my most recent examples have used PHP, JSON is a rising star of data
    formats because it incorporates so easily with JavaScript—JSON essentially *is*
    JavaScript. Now that you know how to read in JSON data securely, you may find
    yourself on the lookout for APIs that use the format. JSON makes moving on from
    data parsing easy, so you can do what you really want to do: create awesome, data-filled
    web maps.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我最近的例子使用了 PHP，但 JSON 是数据格式中的新星，因为它很容易与 JavaScript 集成——JSON 实质上 *就是* JavaScript。现在你知道如何安全地读取
    JSON 数据，你可能会寻找使用该格式的 API。JSON 使得从数据解析中解脱出来变得容易，这样你就可以做你真正想做的事情：创建充满数据的精彩网络地图。
- en: '#54: Use GeoRSS'
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#54: 使用 GeoRSS'
- en: Location is only one tiny piece of information being pushed around the Web.
    A list of points is much more useful if you include context for what they mean.
    GeoRSS is a way to add location and other geographic information to content feeds,
    creating geo-tagged content.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 位置只是网络中传递的众多信息中的一小部分。如果你包括它们的意义的上下文，一个点的列表就更有用了。GeoRSS 是一种将位置和其他地理信息添加到内容源的方法，从而创建地理标记的内容。
- en: The content itself is commonly blog posts or photos, though it can be anything.
    Blogs are prime candidates for geo-tagging because most are already syndicated
    with an RSS feed, a way to get the latest posts without visiting the website.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 内容本身通常是博客文章或照片，尽管它可以是一切。博客是地理标记的理想候选者，因为大多数博客已经通过 RSS 源进行聚合，这是一种获取最新帖子而不必访问网站的方法。
- en: Although named after RSS, GeoRSS can be used inside formats other than RSS.
    For example, the United States Geological Survey publishes an Atom feed of recent
    earthquakes, including the location and depth of each quake. GeoRSS can be added
    to any XML feed to attach geographic data to other content.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GeoRSS是以RSS命名的，但它可以用于除了RSS之外的其他格式。例如，美国地质调查局发布了一个最近的地震 Atom 源，包括每个地震的位置和深度。GeoRSS
    可以添加到任何 XML 源，以将地理数据附加到其他内容。
- en: 'Let''s see an example of GeoRSS inside an RSS feed:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 RSS 源中 GeoRSS 的一个例子：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '``Most of the text is standard RSS. The bold sections are the GeoRSS hooks
    that add location data to the feed. At the top, you need to include the GeoRSS
    namespace, which allows you to use the `georss:` prefix for tags.``'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '``大部分文本是标准的 RSS。粗体部分是 GeoRSS 插件，它们为源添加位置数据。在顶部，你需要包含 GeoRSS 命名空间，这允许你使用 `georss:`
    前缀为标签。``'
- en: '`In this example, we''ve declared a point, which is a geographic coordinate.
    Inside the tag, we put the latitude first, followed by a space, and then the longitude.
    Sometimes you may see a comma between the numbers. Both are permissible.`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`在这个例子中，我们声明了一个点，这是一个地理坐标。在标签内，我们首先放置纬度，然后是一个空格，接着是经度。有时你可能会看到数字之间有一个逗号。两者都是允许的。`'
- en: '`GeoRSS has several ways to declare shapes, as well. These shapes are made
    up of multiple points and often represent a route, border, or other boundary.
    GeoRSS refers to them as lines, polygons, and boxes.`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`GeoRSS 也有几种声明形状的方式。这些形状由多个点组成，通常代表路线、边界或其他边界。GeoRSS 将它们称为线条、多边形和矩形。`'
- en: '`Lines and polygons are both declared as a sequence of latitude and longitude
    points:`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`线条和多边形都声明为纬度和经度点的序列：`'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`As in this example, a line is at least two coordinates, but it can be many
    more. In this way, a line could describe a route.`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`正如这个例子所示，一条线至少有两个坐标，但可以有更多。这样，一条线可以描述一条路线。`'
- en: '`A polygon is declared similarly, but the final point must be the same as the
    first point. In other words, a polygon is a circular route. It could, for example,
    be used to describe the outside walls of a house or the border of a country.`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`多边形也是以类似的方式声明的，但最后一个点必须与第一个点相同。换句话说，多边形是一个环形路线。例如，它可以用来描述房屋的外墙或国家的边界。`'
- en: '`A box, on the other hand, will always create a rectangular shape and is declared
    with only two coordinates:`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`另一方面，一个矩形将始终创建一个矩形形状，并且只需要两个坐标来声明：`'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '``If you''re confused, that''s okay. A rectangle has four corners, so shouldn''t
    a box have four coordinates? It''s just like Mapstraction''s `BoundingBox`, covered
    in [#19: Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a Rectangle
    to Declare an Area") in [#19: Draw a Rectangle to Declare an Area](ch04s04.html
    "#19: Draw a Rectangle to Declare an Area"). GeoRSS uses only two corners to determine
    the box''s location. The minimum data you need is the southwest and northeast
    corners. From those two points, you can extrapolate the northwest and southeast
    points.``'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '``如果你感到困惑，那没关系。矩形有四个角，所以箱子不应该是四个坐标吗？这就像 Mapstraction 的 `BoundingBox`，在 [#19:
    Draw a Rectangle to Declare an Area](ch04s04.html "#19: Draw a Rectangle to Declare
    an Area") 中有所介绍。GeoRSS 只使用两个角来确定箱子的位置。你需要的最小数据是西南角和东北角。从这两个点，你可以外推西北角和东南角。` ``'
- en: '`Now that you are a little familiar with GeoRSS, let''s use it in a different
    type of feed. Here is an example of GeoRSS inside the Atom format:`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`现在你对 GeoRSS 有了一些了解，让我们在另一种类型的源中使用它。以下是在 Atom 格式中 GeoRSS 的一个示例：`'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`` `Atom is an alternative to RSS and is a widely supported format. As you
    can see, for our purposes, it is very similar to RSS. Again, the GeoRSS portions
    are bold.` ``'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `Atom 是 RSS 的替代品，并且是一个广泛支持的格式。正如你所见，对我们来说，它与 RSS 非常相似。同样，GeoRSS 的部分被加粗。`
    ``'
- en: '`` `You will see GeoRSS most often in RSS and Atom formats. The examples I''ve
    shown, however, are the simple version of GeoRSS. The format sometimes looks a
    bit different, yet it is still GeoRSS. Read on for some examples of alternate
    GeoRSS encodings.` ``'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `你通常会在 RSS 和 Atom 格式中看到 GeoRSS。然而，我展示的却是 GeoRSS 的简单版本。格式有时看起来略有不同，但它仍然是
    GeoRSS。继续阅读以了解一些替代 GeoRSS 编码的示例。` ``'
- en: '`` `Use Alternate GeoRSS Encodings` ``'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `使用替代 GeoRSS 编码` ``'
- en: '`` `The GeoRSS demonstrated in the previous section is sufficient for most
    needs and is likely the most common encoding you''ll run across. Understanding
    its shortcomings and recognizing other ways of representing location data is important,
    however.` ``'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `在上一节中展示的 GeoRSS 对于大多数需求来说是足够的，并且可能是你遇到的最常见的编码方式。然而，了解其不足之处并认识到其他表示位置数据的方式是很重要的。`
    ``'
- en: '`` `*GML* is the *Geography Markup Language* and is a superset of GeoRSS. GML
    was created to express any form of geographic information, including topology
    and coordinate systems other than the latitude/longitude system we''ve been using
    (called WGS84).` ``'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `*GML* 是 *地理标记语言*，并且是 GeoRSS 的超集。GML 是为了表达任何形式的地理信息而创建的，包括拓扑和除我们一直在使用的纬度/经度系统（称为
    WGS84）之外的其他坐标系统。` ``'
- en: '`` `To make your GeoRSS compatible with GML, you need additional tags. For
    example, the single tag required to declare a point becomes three tags:` ``'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `为了让你的 GeoRSS 与 GML 兼容，你需要额外的标签。例如，声明一个点所需的单个标签变成了三个标签：` ``'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`` `Whenever you write XML that includes tags with a colon in the name, you''ll
    need to make sure the word before the colon (the namespace) is declared at the
    top of your XML. Because this example uses both GeoRSS and GML, we need to include
    both namespaces:` ``'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `无论何时你编写包含冒号命名的标签的 XML，你都需要确保冒号前的单词（命名空间）在 XML 的顶部被声明。因为这个例子使用了 GeoRSS 和
    GML，我们需要包含这两个命名空间：` ``'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`` `The two forms of GeoRSS shown so far are the most likely encoding methods
    you''ll run into with new data feeds. An old version is still in somewhat wide
    use, however.` ``'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `到目前为止展示的两种 GeoRSS 格式是你在新数据源中最可能遇到的编码方法。尽管旧版本仍在一定程度上被广泛使用。` ``'
- en: '`` `The Basic Geo Vocabulary is an encoding developed by the Worldwide Web
    Consortium (W3C), an organization that watches over the development of HTML and
    CSS, among other standards. The development of GeoRSS made the W3C''s geo-tags
    obsolete, but you''ll run into them often enough to need to recognize them.` ``'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `基本地理词汇表是由万维网联盟（W3C）开发的编码，该组织负责监督 HTML 和 CSS 等其他标准的发展。GeoRSS 的开发使得 W3C 的地理标签变得过时，但你经常会遇到它们，因此需要能够识别它们。`
    ``'
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`` `Display GeoRSS on a Map` ``'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`` `在地图上显示 GeoRSS` ``'
- en: '`` `Mapstraction makes adding GeoRSS to your map easy. Through a single function,
    you can layer the GeoRSS without having to parse the XML yourself.` ``'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `Mapstraction 使得将 GeoRSS 添加到地图变得简单。通过一个单一的功能，你可以将 GeoRSS 层叠到地图上，而无需自己解析
    XML。` ``'
- en: '`` `To display GeoRSS, all you need is a publicly accessible feed and a map
    on which to display it. Toss these lines into a new HTML file to see GeoRSS in
    action:` ``'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `要显示 GeoRSS，你只需要一个公开可访问的源和一张可以显示它的地图。将这些行放入一个新的 HTML 文件中，以查看 GeoRSS 的实际应用：`
    ``'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`` `Load the previous HTML into your browser, and you should see the GeoRSS
    content on your map. If you''re using my example, you''ll see routes across several
    Portland bridges, plus markers that identify landmarks.` ``'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `将之前的 HTML 文件加载到你的浏览器中，你应该能在地图上看到 GeoRSS 内容。如果你使用的是我的示例，你将看到跨越波特兰几座桥梁的路线，以及标识地标的位置标记。`
    ``'
- en: '`` `Now you''re a little more familiar with the GeoRSS format and its trio
    of encodings. In this section, I''ve shown how they can be used in RSS and Atom,
    the two most popular web feed formats. Also, you''ve learned how, in one line
    of Mapstraction code, to layer your GeoRSS feed on your map. To see an example
    of digging into GeoRSS, read [#70: Display Recent Earthquakes Worldwide](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide") in [#70: Display Recent Earthquakes
    Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide").` ``'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `现在你对 GeoRSS 格式及其三种编码方式有了更多的了解。在本节中，我展示了它们如何在 RSS 和 Atom 这两种最流行的网络订阅格式中使用。此外，你还学会了如何在
    Mapstraction 代码的一行中，将你的 GeoRSS 数据叠加到地图上。要查看 GeoRSS 的一个示例，请阅读 [#70: Display Recent
    Earthquakes Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide")。`
    ``'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
