- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Haskell is fun, and that’s what it’s all about!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 很有趣，这就是它的全部！
- en: This book is aimed at people who have experience programming in imperative languages—such
    as C++, Java, and Python—and now want to try out Haskell. But even if you don’t
    have any significant programming experience, I’ll bet a smart person like you
    will be able to follow along and learn Haskell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标是那些有在命令式语言中编程经验的人——例如 C++、Java 和 Python——现在想尝试 Haskell。但即使你没有太多的编程经验，我敢打赌像你这样的聪明人也能跟上并学习
    Haskell。
- en: My first reaction to Haskell was that the language was just too weird. But after
    getting over that initial hurdle, it was smooth sailing. Even if Haskell seems
    strange to you at first, don’t give up. Learning Haskell is almost like learning
    to program for the first time all over again. It’s fun, and it forces you to think
    differently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 Haskell 的第一反应是这种语言太奇怪了。但过了那个最初的障碍后，一切都很顺利。即使 Haskell 最初对你来说很奇怪，也不要放弃。学习 Haskell
    几乎就像再次从头开始学习编程一样。它很有趣，并迫使你以不同的方式思考。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever get really stuck, the IRC channel *#haskell* on the freenode network
    is a great place to ask questions. The people there tend to be nice, patient,
    and understanding. They’re a great resource for Haskell newbies.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的遇到了难题，freenode 网络上的 *#haskell* IRC 频道是一个询问问题的好地方。那里的人通常很友好、耐心、理解。他们是 Haskell
    新手的极好资源。
- en: So, What's Haskell?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是 Haskell 呢？
- en: Haskell is a *purely functional* programming language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 是一种*纯函数式*编程语言。
- en: In *imperative* programming languages, you give the computer a sequence of tasks,
    which it then executes. While executing them, the computer can change state. For
    instance, you can set the variable `a` to 5 and then do some stuff that might
    change the value of `a`. There are also flow-control structures for executing
    instructions several times, such as `for` and `while` loops.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*命令式*编程语言中，你给计算机一系列任务，然后它执行这些任务。在执行它们的过程中，计算机可以改变状态。例如，你可以将变量 `a` 设置为 5，然后做一些可能会改变
    `a` 值的事情。还有用于执行指令多次的流程控制结构，例如 `for` 和 `while` 循环。
- en: Purely functional programming is different. You don’t tell the computer what
    to do—you tell it *what stuff is*. For instance, you can tell the computer that
    the factorial of a number is the product of every integer from 1 to that number
    or that the sum of a list of numbers is the first number plus the sum of the remaining
    numbers. You can express both of these operations as *functions*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数式编程是不同的。你不是告诉计算机做什么——你是告诉它*什么内容*。例如，你可以告诉计算机一个数的阶乘是从1到该数的每个整数的乘积，或者一个数字列表的总和是第一个数字加上剩余数字的总和。你可以将这两个操作都表达为*函数*。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802500.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802500.png)'
- en: In functional programming, you *can’t* set a variable to one value and then
    set it to something else later on. If you say `a` is 5, you can’t just change
    your mind and say it’s something else. After all, you said it was 5\. (What are
    you, some kind of liar?)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，你不能将一个变量设置为一个值，然后稍后将其设置为另一个值。如果你说 `a` 是 5，你不能只是改变主意说它是其他东西。毕竟，你说过它是
    5。（你是什么，一个骗子？）
- en: In purely functional languages, a function has no *side effects*. The only thing
    a function can do is calculate something and return the result. At first, this
    seems limiting, but it actually has some very nice consequences. If a function
    is called twice with the same parameters, it’s guaranteed to return the same result
    both times. This property is called *referential transparency*. It lets the programmer
    easily deduce (and even prove) that a function is correct. You can then build
    more complex functions by gluing these simple functions together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式语言中，一个函数没有*副作用*。函数唯一能做的就是计算某事并返回结果。起初，这似乎很有限制，但实际上有一些非常好的结果。如果一个函数用相同的参数被调用两次，它保证两次都会返回相同的结果。这个特性被称为*引用透明性*。它让程序员能够轻松地推断（甚至证明）一个函数是正确的。然后你可以通过将这些简单函数粘合在一起来构建更复杂的函数。
- en: Haskell is *lazy*. This means that unless specifically told otherwise, Haskell
    won’t execute functions until it needs to show you a result. This is made possible
    by referential transparency. If you know that the result of a function depends
    only on the parameters that function is given, it doesn’t matter when you actually
    calculate the result of the function. Haskell, being a lazy language, takes advantage
    of this fact and defers actually computing results for as long as possible. Once
    you want your results to be displayed, Haskell will do just the bare minimum computation
    required to display them. Laziness also allows you to make seemingly infinite
    data structures, because only the parts of the data structures that you choose
    to display will actually be computed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 是 *惰性的*。这意味着除非明确告知，否则 Haskell 不会执行函数直到需要向你展示结果。这是通过引用透明性实现的。如果你知道一个函数的结果只取决于该函数接收的参数，那么你实际上计算该函数结果的时间并不重要。作为一个惰性语言，Haskell
    利用这一事实，尽可能推迟实际计算结果。一旦你想看到结果，Haskell 将只进行显示这些结果所需的最小计算。惰性还允许你创建看似无限的数据结构，因为只有你选择显示的数据结构的部分才会实际被计算。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802502.png.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802502.png.jpg)'
- en: 'Let’s look at an example of Haskell’s laziness. Say you have a list of numbers,
    `xs = [1,2,3,4,5,6,7,8]`, and a function called `doubleMe` that doubles every
    element and returns the result as a new list. If you want to multiply your list
    by 8, your code might look something like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Haskell 惰性的一个例子。假设你有一个数字列表，`xs = [1,2,3,4,5,6,7,8]`，以及一个名为 `doubleMe`
    的函数，该函数将每个元素加倍并返回一个新的列表。如果你想将你的列表乘以 8，你的代码可能看起来像这样：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An imperative language would probably pass through the list once, make a copy,
    and then return it. It would then pass through the list another two times, making
    copies each time, and return the result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一种命令式语言可能会遍历列表一次，制作一个副本，然后返回。然后它还会遍历列表另外两次，每次都制作副本，并返回结果。
- en: In a lazy language, calling `doubleMe` on a list without forcing it to show
    you the result just makes the program tell you, “Yeah yeah, I’ll do it later!”
    Once you want to see the result, the first `doubleMe` calls the second one and
    says it wants the result immediately. Then the second one says the same thing
    to the third one, and the third one reluctantly gives back a doubled 1, which
    is 2\. The second `doubleMe` receives that and returns 4 to the first one. The
    first `doubleMe` then doubles this result and tells you that the first element
    in the final resulting list is 8\. Because of Haskell’s laziness, the `doubleMe`
    calls pass through the list just once, and only when you really need that to happen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个惰性语言中，对列表调用 `doubleMe` 而不强制它显示结果，只会让程序告诉你，“是的，是的，我稍后会做！”一旦你想看到结果，第一个 `doubleMe`
    调用第二个，并要求立即得到结果。然后第二个告诉第三个同样的要求，第三个不情愿地返回一个加倍后的 1，即 2。第二个 `doubleMe` 接收到这个结果，并返回
    4 给第一个。第一个 `doubleMe` 然后将这个结果加倍，并告诉你最终结果列表中的第一个元素是 8。由于 Haskell 的惰性，`doubleMe`
    调用只需遍历列表一次，而且只有当你真正需要这样做的时候。
- en: Haskell is *statically typed*. This means that when you compile your program,
    the compiler knows which piece of code is a number, which is a string, and so
    on. Static typing means that a lot of possible errors can be caught at compile
    time. If you try to add together a number and a string, for example, the compiler
    will whine at you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 是 *静态类型* 的。这意味着当你编译程序时，编译器知道哪段代码是数字，哪段是字符串等等。静态类型意味着许多可能的错误可以在编译时捕获。例如，如果你尝试将数字和字符串相加，编译器会向你抱怨。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages802504.png.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages802504.png.jpg)'
- en: Haskell uses a very good type system that has *type inference*. This means that
    you don’t need to explicitly label every piece of code with a type, because Haskell’s
    type system can intelligently figure it out. For example, if you say `a = 5 +
    4`, you don’t need to tell Haskell that `a` is a number—it can figure that out
    by itself. Type inference makes it easier for you to write code that’s more general.
    If you write a function that takes two parameters and adds them together, but
    you don’t explicitly state their type, the function will work on any two parameters
    that act like numbers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 使用一个非常好的类型系统，具有 *类型推断*。这意味着你不需要显式地为每段代码标记类型，因为 Haskell 的类型系统可以智能地推断出来。例如，如果你说
    `a = 5 + 4`，你不需要告诉 Haskell `a` 是一个数字——它自己可以推断出来。类型推断使你更容易编写更通用的代码。如果你编写了一个接受两个参数并将它们相加的函数，但你没有明确声明它们的类型，该函数将适用于任何像数字一样的两个参数。
- en: Haskell is *elegant and concise*. Because it uses a lot of high-level concepts,
    Haskell programs are usually shorter than their imperative equivalents. Shorter
    programs are easier to maintain and have fewer bugs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 语法*优雅且简洁*。因为它使用了大量的高级概念，所以 Haskell 程序通常比它们的命令式等效程序更短。程序越短，维护起来越容易，并且错误也更少。
- en: Haskell was made by some really smart guys (with PhDs). Work on Haskell began
    in 1987 when a committee of researchers got together to design a kick-ass language.
    The Haskell Report, which defines a stable version of the language, was published
    in 1999.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 是一些非常聪明的人（拥有博士学位）创造的。Haskell 的工作始于 1987 年，当时一组研究人员聚集在一起设计一种出色的语言。定义语言稳定版本的
    Haskell 报告于 1999 年发布。
- en: What You Need to Dive In
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要准备什么
- en: In short, to get started with Haskell, you need a text editor and a Haskell
    compiler. You probably already have your favorite text editor installed, so we
    won’t waste time on that. The most popular Haskell compiler is the Glasgow Haskell
    Compiler (GHC), which we will be using throughout this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，要开始学习 Haskell，你需要一个文本编辑器和 Haskell 编译器。你可能已经安装了你的首选文本编辑器，所以我们不会在这方面浪费时间。最受欢迎的
    Haskell 编译器是格拉斯哥 Haskell 编译器（GHC），我们将在这本书中使用它。
- en: The best way to get what you need is to download the *Haskell Platform*. The
    Haskell Platform includes not only the GHC compiler but also a bunch of useful
    Haskell libraries! To get the Haskell Platform for your system, go to [http://hackage.haskell.org/platform/](http://hackage.haskell.org/platform/)
    and follow the instructions for your operating system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所需内容的最佳方式是下载 *Haskell 平台*。Haskell 平台不仅包括 GHC 编译器，还包括许多有用的 Haskell 库！要为您的系统获取
    Haskell 平台，请访问 [http://hackage.haskell.org/platform/](http://hackage.haskell.org/platform/)
    并遵循您操作系统的说明。
- en: GHC can compile Haskell scripts (usually with an *.hs* extension), and it also
    has an interactive mode. From there, you can load functions from scripts and then
    call them directly to see immediate results. Especially when you’re learning,
    it’s much easier to use the interactive mode than it is to compile and run your
    code every time you make a change.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GHC 可以编译 Haskell 脚本（通常带有 *.hs* 扩展名），它还拥有交互式模式。从那里，你可以从脚本中加载函数，然后直接调用它们以查看即时结果。尤其是在学习过程中，使用交互式模式比每次更改后编译和运行代码要容易得多。
- en: Once you’ve installed the Haskell Platform, open a new terminal window, assuming
    you’re on a Linux or Mac OS X system. If your operating system of choice is Windows,
    go to the command prompt. Once there, type **`ghci`** and press enter to start
    the interactive mode. (If your system fails to find the GHCi program, you can
    try rebooting your computer.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Haskell 平台，如果你使用的是 Linux 或 Mac OS X 系统，请打开一个新的终端窗口。如果你的操作系统是 Windows，请转到命令提示符。一旦到达那里，输入
    **`ghci`** 并按回车键以启动交互式模式。（如果你的系统找不到 GHCi 程序，你可以尝试重新启动你的计算机。）
- en: If you’ve defined some functions in a script—for example, *myfunctions.hs*—you
    can load these functions into GHCi by typing `:l myfunctions`. (Make sure that
    *myfunctions.hs* is in the same folder from which you started GHCi.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个脚本中定义了一些函数——例如，*myfunctions.hs*——你可以通过输入 `:l myfunctions` 将这些函数加载到 GHCi
    中。（确保 *myfunctions.hs* 在你启动 GHCi 的同一文件夹中。）
- en: If you change the *.hs* script, run `:l myfunctions` to load the file again
    or run `:r`, which reloads the current script. My usual workflow is to define
    some functions in an *.hs* file, load it into GHCi, mess around with it, change
    the file, and repeat. This is what we’ll be doing in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了 *.hs* 脚本，运行 `:l myfunctions` 以重新加载文件，或者运行 `:r`，这将重新加载当前脚本。我的常规工作流程是在
    *.hs* 文件中定义一些函数，将其加载到 GHCi 中，对其进行操作，更改文件，然后重复。这正是本书将要进行的操作。
- en: Acknowledgments
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 致谢
- en: Thanks to everyone who sent in corrections, suggestions, and words of encouragement.
    Also thanks to Keith, Sam, and Marilyn for making me look like a real writer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢所有提出更正、建议和鼓励话语的人。还要感谢基思、山姆和玛丽莲，因为他们让我看起来像一位真正的作家。
