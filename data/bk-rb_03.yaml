- en: Chapter 3. Strings and Ranges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 字符串和范围
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages860138.png.jpg)'
- en: 'I’ve made use of strings in many of my programs so far. In fact, a string was
    featured in the very first program in the book. Here it is again:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我在许多程序中使用了字符串。事实上，书中第一个程序就展示了字符串。这里再次展示：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although that first program used a string enclosed within single quotes, my
    second program used a string in double quotes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一个程序使用了单引号内的字符串，但我的第二个程序使用了双引号字符串：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Double-quoted strings do more work than single-quoted strings. In particular,
    they have the ability to evaluate bits of themselves as though they were programming
    code. To have something evaluated, you need to place it between a pair of curly
    brackets preceded by a hash mark (`#`).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串比单引号字符串做的工作更多。特别是，它们能够将自身的一部分当作编程代码来评估。要评估某个内容，你需要将其放置在以井号（`#`）开头的一对花括号之间。
- en: 'In the previous example, `#{name}` in a double-quoted string tells Ruby to
    get the value of the `name` variable and insert that value into the string itself.
    The second line of code calls the `gets()` method to get some user input, which
    is then assigned to the variable `name`. If the user entered **`Fred`**, the final
    line of code would evaluate the embedded variable, `#{name}`, and the string “Hello
    Fred” would be displayed. The *1strings.rb* sample program provides a few more
    examples of embedded evaluation in double-quoted strings. For example, here I
    have created an object, ob, from a custom class, MyClass, and used embedded evaluation
    to display the values of its `name` and `number` attributes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，双引号字符串中的 `#{name}` 告诉 Ruby 获取 `name` 变量的值并将其插入到字符串本身中。代码的第二行调用 `gets()`
    方法获取一些用户输入，然后将其分配给变量 `name`。如果用户输入了 **`Fred`**，代码的最后一行将评估嵌入的变量 `#{name}`，并显示字符串“Hello
    Fred”。*1strings.rb* 示例程序提供了双引号字符串中嵌入评估的更多示例。例如，这里我从一个自定义类 MyClass 创建了一个对象 ob，并使用嵌入评估来显示其
    `name` 和 `number` 属性的值：
- en: '*1strings.rb*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*1strings.rb*'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the final line of code executes, this is displayed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码的最后一行执行时，会显示以下内容：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A double-quoted string can also evaluate expressions such as `2*3`, bits of
    code such as the method-call `ob.ten` (where `ten` is a method name), and escape
    characters such as `\n` and `\t` (representing a newline and a tab). A single-quoted
    string does no such evaluation. A single-quoted string can, however, use a backslash
    to indicate that the next character should be used literally. This is useful when
    a single-quoted string contains a single-quote character, like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串还可以评估表达式，如 `2*3`，代码片段，如方法调用 `ob.ten`（其中 `ten` 是方法名），以及转义字符，如 `\n` 和 `\t`（代表换行符和制表符）。单引号字符串不进行此类评估。然而，单引号字符串可以使用反斜杠来指示下一个字符应该被原样使用。当单引号字符串包含单引号字符时，这很有用，如下所示：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Assuming that the method named `ten` returns the value 10, you might write
    the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设名为 `ten` 的方法返回值 10，你可能编写以下代码：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because this is a double-quoted string, the embedded elements are evaluated,
    and the following is displayed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个双引号字符串，所以嵌入的元素会被评估，并显示以下内容：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let’s see what happens when a single-quoted string is used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用单引号字符串会发生什么：
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time, no embedded evaluation is done, so this is what is displayed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有进行嵌入评估，所以显示的内容如下：
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: User-Defined String Delimiters
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的字符串定界符
- en: If, for some reason, single and double quotes aren’t convenient—for example,
    if your strings contain lots of quote characters and you don’t want to have to
    keep putting backslashes in front of them—you can also delimit strings in many
    other ways.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，单引号和双引号不方便——例如，如果你的字符串中包含很多引号字符，你不想在它们前面不断放置反斜杠——你也可以用许多其他方式来定界字符串。
- en: The standard alternative delimiters for double-quoted strings are `%Q` and `/`
    or `%/` and `/`, while for single-quoted strings they are `%q` and `/`. Thus .
    . .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串的标准替代定界符是 `%Q` 和 `/` 或 `%/` 和 `/`，而单引号字符串的定界符是 `%q` 和 `/`。因此，……
- en: '*2strings.rb*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*2strings.rb*'
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can even define your own string delimiters. They must be nonalphanumeric
    characters, and they may include nonprinting characters such as newlines or tabs
    as well as various characters that normally have a special meaning in Ruby such
    as the hash mark (`#`). Your chosen character should be placed after `%q` or `%Q`,
    and you should be sure to terminate the string with the same character. If your
    delimiter is an opening square bracket, the corresponding closing bracket should
    be used at the end of the string, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以定义自己的字符串定界符。它们必须是非字母数字字符，并且可以包括非打印字符，如换行符或制表符，以及通常在 Ruby 中具有特殊意义的各种字符，如井号
    (`#`)。你应该在 `%q` 或 `%Q` 后放置你选择的字符，并且确保用相同的字符终止字符串。如果你的定界符是一个开方括号，那么在字符串末尾应该使用相应的闭方括号，如下所示：
- en: '*3strings.rb*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*3strings.rb*'
- en: '[PRE10]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You will find examples of a broad range of user-selected string delimiters
    in the sample program *3strings.rb*. Here are two examples using an asterisk (`*`)
    after `%Q` instead of a double-quoted string and using an exclamation point (`!`)
    after `%q` instead of a single-quoted string:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在示例程序 *3strings.rb* 中找到各种用户选择的字符串定界符的例子。这里有两个例子，使用 `%Q` 后跟一个星号 (`*`) 而不是双引号字符串，以及使用
    `%q` 后跟一个感叹号 (`!`) 而不是单引号字符串：
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, as in the previous program, ob is a user-defined object whose method
    named `ten` returns the integer, 10\. The previous code produces the following
    output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像上一个程序一样，ob 是一个用户定义的对象，其名为 `ten` 的方法返回整数 10。前面的代码产生了以下输出：
- en: '[PRE12]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although there may be times when it is useful to delimit a string by some esoteric
    character such as a newline or an asterisk, in many cases the disadvantages (not
    least the mental anguish and confusion) resulting from such arcane practices may
    significantly outweigh the advantages.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下，使用一些晦涩的字符（如换行符或星号）来界定字符串可能是有用的，但在许多情况下，这种古怪做法带来的不利（包括心理痛苦和困惑）可能会大大超过其优势。
- en: Backquotes
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反引号
- en: 'One other type of string deserves a special mention: a string enclosed by backquotes—that
    is, the inward-pointing quote character that is usually tucked away up toward
    the top-left corner of the keyboard: `` ` ``.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种值得特别提及的字符串类型是：由反引号包围的字符串——即通常藏在键盘右上角向内指的引号字符：`` ` ``.
- en: 'Ruby considers anything enclosed by back-quotes to be a command that can be
    passed for execution by the operating system using a method such as `print` or
    `puts`. By now, you will probably already have guessed that Ruby provides more
    than one way of doing this. It turns out `%x/some command/` has the same effect
    as `` `somecommand` `` and so does `%x{some command}`. On the Windows operating
    system, for example, each of the three lines shown next would pass the command
    `dir` to the operating system, causing a directory listing to be displayed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 将任何由反引号包围的内容视为可以由操作系统通过 `print` 或 `puts` 等方法执行的命令。到现在为止，你可能已经猜到 Ruby 提供了不止一种方法来做这件事。结果是
    `%x/some command/` 与 `` `somecommand` `` 以及 `%x{some command}` 有相同的效果。例如，在 Windows
    操作系统中，下面显示的三行中的每一行都会将命令 `dir` 传递给操作系统，导致目录列表被显示：
- en: '*4backquotes.rb*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*4backquotes.rb*'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also embed commands inside double-quoted strings like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像这样在双引号字符串中嵌入命令：
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be careful if you do this. The command itself is evaluated first. Your Ruby
    program then waits until the process that starts has terminated. In the present
    case, the calculator will pop up. You are now free to do some calculations, if
    you want. Only when you close the calculator will the string “Goodbye” be displayed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，请小心。命令本身首先会被评估。然后你的 Ruby 程序会等待启动的进程结束。在这个例子中，计算器会弹出。现在你可以自由地进行一些计算，如果你愿意的话。只有当你关闭计算器时，才会显示字符串“再见”。
- en: String Handling
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串处理
- en: Before leaving the subject of strings, you’ll take a quick look at a few common
    string operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开字符串主题之前，你将快速浏览一些常见的字符串操作。
- en: Concatenation
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: 'You can concatenate strings using `<<` or `+` or just by placing a space between
    them. Here are three examples of string concatenation; in each case, `s` is assigned
    the string “Hello world”:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `<<` 或 `+` 或只是通过在它们之间放置空格来连接字符串。以下是三个字符串连接的例子；在每种情况下，`s` 被分配了字符串“Hello
    world”：
- en: '*hello_world_concat.rb*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*hello_world_concat.rb*'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that when you use the `<<` method, you can append Fixnum integers (in
    the range 0 to 255), in which case those integers are converted to the character
    with that character code. Character codes 65 to 90 are converted to the uppercase
    characters *A* to *Z*, 97 to 122 are converted to the lowercase *a* to *z*, and
    other codes are converted to punctuation, special characters, and nonprinting
    characters. However, if you want to print the number itself, you must convert
    it to a string using the `to_s` method. The `to_s` method is obligatory when concatenating
    Fixnums using the `+` method or a space; attempting to concatenate a number without
    using `to_s` is an error. The following program prints out characters and numeric
    codes for values between 0 and 126, which include the standard Western alphanumeric
    and punctuation characters:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你使用 `<<` 方法时，你可以追加范围在 0 到 255 之间的 Fixnum 整数，在这种情况下，这些整数会被转换成具有该字符码的字符。字符码
    65 到 90 被转换成大写字母 *A* 到 *Z*，97 到 122 被转换成小写字母 *a* 到 *z*，其他码被转换成标点符号、特殊字符和非打印字符。然而，如果你想打印数字本身，你必须使用
    `to_s` 方法将其转换为字符串。当使用 `+` 方法或空格连接 Fixnums 时，`to_s` 方法是强制性的；不使用 `to_s` 尝试连接一个数字会导致错误。以下程序打印出介于
    0 到 126 之间的值对应的字符和数字码，这些值包括标准的西方字母数字和标点符号：
- en: '*char_codes.rb*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*char_codes.rb*'
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For examples of concatenating using `<<`, `+`, or a space, see *string_contact.rb*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `<<`、`+` 或空格进行连接的示例，请参阅 *string_contact.rb*：
- en: '*string_contact.rb*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_contact.rb*'
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous program produces this output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序产生了以下输出：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What About Commas?
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于逗号的问题？
- en: 'You may sometimes see Ruby code that uses commas to separate strings and other
    data types. In some circumstances, these commas appear to have the effect of concatenating
    strings. For example, the following code might, at first sight, seem to create
    and display a string from three substrings plus an integer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时可能会看到使用逗号分隔字符串和其他数据类型的 Ruby 代码。在某些情况下，这些逗号似乎具有连接字符串的效果。例如，以下代码乍一看可能似乎创建并显示了一个由三个子字符串和一个整数组成的字符串：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In fact, a list separated by commas creates an array—an ordered list of the
    original strings. The *string_concat.rb* program contains examples that prove
    this to be the case:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由逗号分隔的列表创建了一个数组——原始字符串的有序列表。*string_concat.rb* 程序包含了一些示例，证明了这一点：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous code causes the following to be displayed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码导致以下内容被显示：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first `print` statement here looks as though it is displaying a single string.
    This is because each successive item in the array, `x`, is printed on the same
    line as the preceding item. When you use `puts` instead of `print`, you can see
    that each item is printed on a separate line. This is because `puts` prints each
    item in turn and appends a carriage return after it. The fact that you are dealing
    with an array rather than a string is confirmed when you ask Ruby to print the
    class of the `x` object. It displays `Array`. You’ll learn about arrays in more
    depth in the next chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个 `print` 语句看起来像是在显示一个单独的字符串。这是因为数组 `x` 中的每个后续项都与前一项在同一行上打印。当你使用 `puts`
    而不是 `print` 时，你可以看到每个项都在单独的一行上打印。这是因为 `puts` 会依次打印每个项，并在其后添加一个换行符。当你要求 Ruby 打印
    `x` 对象的类时，可以确认你处理的是一个数组而不是字符串。它显示为 `Array`。你将在下一章中更深入地了解数组。
- en: String Assignment
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串赋值
- en: 'The Ruby String class provides a number of useful string-handling methods.
    Most of these methods create new string objects. So, for example, in the following
    code, the `s` on the left side of the assignment on the second line is not the
    same object as the `s` on the right side:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 字符串类提供了一些有用的字符串处理方法。这些方法中的大多数都会创建新的字符串对象。因此，例如，在以下代码中，第二行赋值左侧的 `s` 与右侧的
    `s` 不是同一个对象：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A few string methods actually alter the string itself without creating a new
    object. These methods generally end with an exclamation mark (for example, the
    `capitalize!` method changes the original string, whereas the `capitalize` method
    does not). In addition, the string itself is also modified—and no new string is
    created—when you assign a character at an index of the string. For example, `s[1]
    = 'A'` would place the character *A* at index 1 (the second character) of the
    string `s`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符串方法实际上会修改字符串本身而不创建新对象。这些方法通常以感叹号结尾（例如，`capitalize!` 方法会改变原始字符串，而 `capitalize`
    方法则不会）。此外，当你将一个字符赋值给字符串的索引时，字符串本身也会被修改——不会创建新的字符串。例如，`s[1] = 'A'` 会将字符 *A* 放置在字符串
    `s` 的索引 1（第二个字符）处。
- en: If in doubt, you can check an object’s identity using the `object_id` method.
    I’ve provided a few examples of operations that do and do not create new strings
    in the *string_assign.rb* program. Run this, and check the `object_id` of `s`
    after each string operation is performed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，你可以使用 `object_id` 方法来检查对象的身份。我在 *string_assign.rb* 程序中提供了一些操作示例，这些操作会创建新的字符串，以及不会创建新的字符串。运行此代码，并在每次字符串操作完成后检查
    `s` 的 `object_id`。
- en: '*string_assign.rb*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_assign.rb*'
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This produces output similar to that shown next. The actual object ID values
    may differ, but the important thing to notice is when consecutive values remain
    the same, showing that the string object, `s`, remains the same and, when they
    change, showing that a new string object, `s`, has been created:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生类似于下面显示的输出。实际的对象 ID 值可能不同，但重要的是要注意，连续的值保持不变，表明字符串对象 `s` 保持不变，而当它们改变时，表明已创建了一个新的字符串对象
    `s`：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Indexing into a String
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串索引
- en: 'In one of the previous examples, I treated a string as an array of characters
    and specified a character index with an integer inside square brackets: `s[1]`.
    Strings and arrays in Ruby are indexed from the first character at index 0\. So,
    for instance, to replace the character *e* with *u* in the string `s` (which currently
    contains “Hello world”), you would assign a new character to index 1:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的某个示例中，我将字符串视为字符数组，并在方括号内指定一个整数作为字符索引：`s[1]`。在 Ruby 中，字符串和数组都是从索引 0 的第一个字符开始计数的。所以，例如，要在字符串
    `s`（当前包含“Hello world”）中将字符 *e* 替换为 *u*，你应该将新字符赋值给索引 1：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you index into a string in order to find a character at a specific location,
    the behavior differs according to which version of Ruby you are using. Ruby 1.8
    returns a numeric ASCII code of the character, whereas Ruby 1.9 returns the character
    itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按索引访问字符串以查找特定位置的字符，其行为会根据你使用的 Ruby 版本而有所不同。Ruby 1.8 返回字符的 ASCII 码的数值，而 Ruby
    1.9 返回字符本身。
- en: '[PRE26]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To obtain the actual character from the numeric value returned by Ruby 1.8,
    you can use a double index to print a single character, starting at index 1:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Ruby 1.8 返回的数值中获取实际的字符，你可以使用双索引来打印单个字符，从索引 1 开始：
- en: '[PRE27]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If, on the other hand, you need the numeric value of the character returned
    by Ruby 1.9, you can use the `ord` method like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你需要 Ruby 1.9 返回的字符的数值，你可以像这样使用 `ord` 方法：
- en: '[PRE28]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `ord` method does not exist in Ruby 1.8, so the previous code causes an
    “undefined method” error. To ensure compatibility between Ruby 1.8 and 1.9, you
    should use the double-index technique, with the first index indicating the starting
    position and the second index indicating the number of characters. For example,
    this returns one character at position 1: `s[1,1]`. You can see some more examples
    in the *char_in_string.rb* program:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.8 中不存在 `ord` 方法，因此之前的代码会导致“未定义方法”错误。为了确保 Ruby 1.8 和 1.9 之间的兼容性，你应该使用双索引技术，其中第一个索引表示起始位置，第二个索引表示字符数。例如，这将返回位置
    1 处的一个字符：`s[1,1]`。你可以在 *char_in_string.rb* 程序中看到更多示例：
- en: '*char_in_string.rb*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*char_in_string.rb*'
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you run this code, Ruby 1.9 displays this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此代码时，Ruby 1.9 显示的是：
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'whereas Ruby 1.8 displays this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而Ruby 1.8 显示的是：
- en: '[PRE31]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also use double-indexes to return more than one character. If you want
    to return three characters starting at position 1, you would enter this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用双索引来返回多个字符。如果你想从位置 1 开始返回三个字符，你应该输入这个：
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This tells Ruby to start at position 1 and return the next three characters.
    Alternatively, you could use the two-dot range notation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Ruby 从位置 1 开始，并返回接下来的三个字符。或者，你也可以使用两个点范围表示法：
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ranges are discussed in more detail later in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 范围将在本章后面更详细地讨论。
- en: 'Strings can also be indexed using negative values, in which case −1 is the
    index of the last character, and, once again, you can specify the number of characters
    to be returned:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以使用负值进行索引，在这种情况下，-1 是最后一个字符的索引，并且，同样，你可以指定要返回的字符数：
- en: '*string_index.rb*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_index.rb*'
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When specifying ranges using a negative index, you must use negative values
    for both the start and end indexes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用负索引指定范围时，必须同时为起始索引和结束索引使用负值：
- en: '*string_methods.rb*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_methods.rb*'
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, you may want to experiment with a few of the standard methods available
    for manipulating strings. These include methods to change the case of a string,
    reverse it, insert substrings, remove repeating characters, and so on. I’ve provided
    a few examples in *string_methods.rb*. The method names are generally descriptive
    of their functions. However, bear in mind that methods such as `reverse` (with
    no `!` at the end) return a new string but do not modify the original string,
    whereas `reverse!` (with the `!`) modifies the original string. You saw similar
    behavior with the `capitalize` end `capitalize!` methods used earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能想尝试一些用于操作字符串的标准方法。这些方法包括改变字符串的大小写、反转字符串、插入子字符串、删除重复字符等。我在 *string_methods.rb*
    中提供了一些示例。方法名通常描述了它们的功能。然而，请注意，像 `reverse`（结尾没有 `!`）这样的方法返回一个新的字符串，但不会修改原始字符串，而
    `reverse!`（结尾有 `!`）则会修改原始字符串。你之前也看到了 `capitalize` 和 `capitalize!` 方法有类似的行为。
- en: 'The `insert` method takes two arguments, an index and a string, and it inserts
    the string argument at the given index of the string, `s`. The `squeeze` method
    returns a string with any repeating character, such as the second adjacent *l*
    in “Hello” removed. The `split` method splits a string into an array. I’ll have
    more to say on `split` when I discuss regular expressions in [Chapter 6](ch06.html
    "Chapter 6. Conditional Statements"). The following examples assume that `s` is
    the string “Hello world” and the output is shown in the `#=>` comments. In the
    program supplied in this book’s code archive, you may also experiment using much
    longer strings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 方法接受两个参数，一个索引和一个字符串，它会在字符串 `s` 的指定索引处插入字符串参数。`squeeze` 方法返回一个移除了任何重复字符的字符串，例如在
    “Hello” 中的第二个相邻 *l*。`split` 方法将字符串分割成一个数组。当我讨论第 6 章（条件语句）中的正则表达式时，我会更多地讨论 `split`。以下示例假设
    `s` 是字符串 “Hello world”，输出显示在 `#=>` 注释中。在本书代码存档提供的程序中，你也可以使用更长的字符串进行实验：'
- en: '[PRE36]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Removing Newline Characters: chop and chomp'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除换行符：`chop` 和 `chomp`
- en: A couple of handy string-processing methods deserve special mention. The `chop`
    and `chomp` methods can be used to remove characters from the end of a string.
    The `chop` method returns a string with the last character removed or with the
    carriage return and newline characters removed (`\r\n`) if these are found at
    the end of the string. The `chomp` method returns a string with the terminating
    carriage return or newline character removed (or both the carriage return *and*
    the newline character if both are found).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 几个实用的字符串处理方法值得特别提及。`chop` 和 `chomp` 方法可以用来从字符串末尾移除字符。`chop` 方法返回一个移除了最后一个字符的字符串，或者如果字符串末尾有回车换行符（`\r\n`），则移除这些字符。`chomp`
    方法返回一个移除了终止的回车换行符（或两者都移除，如果两者都存在）的字符串。
- en: These methods are useful when you need to remove line feeds entered by the user
    or read from a file. For instance, when you use `gets` to read in a line of text,
    this returns the line including the terminating *record separator*, which, by
    default, is the newline character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在你需要移除用户输入的换行符或从文件中读取的换行符时很有用。例如，当你使用 `gets` 读取一行文本时，这会返回包括终止的 *记录分隔符* 的行，默认情况下，这是换行符。
- en: 'The Record Separator: $/'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记录分隔符：$/
- en: 'Ruby predefines a variable, `$/`, as a record separator. This variable is used
    by methods such as `gets` and `chomp`. The `gets` method reads in a string up
    to and including the record separator. The `chomp` method returns a string with
    the record separator removed from the end (if present); otherwise, it returns
    the original string unmodified. You can redefine the record separator if you want,
    like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 预定义了一个变量，`$/`，作为记录分隔符。这个变量被 `gets` 和 `chomp` 等方法使用。`gets` 方法读取一个字符串，直到并包括记录分隔符。`chomp`
    方法返回一个字符串，从末尾移除记录分隔符（如果存在），否则返回未修改的原始字符串。如果你想重新定义记录分隔符，可以这样做：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you redefine the record separator, this new character (or string) will
    now be used by methods such as `gets` and `chomp`. Here’s an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新定义记录分隔符时，这个新的字符（或字符串）现在将被 `gets` 和 `chomp` 等方法使用。以下是一个示例：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*record_separator.rb*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*record_separator.rb*'
- en: 'You can remove the newline character using either `chop` or `chomp`. In most
    cases, `chomp` is preferable because it won’t remove the final character unless
    it is the record separator (usually a newline), whereas `chop` will remove the
    last character no matter what it is. Here are some examples:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`chop`或`chomp`来删除换行符。在大多数情况下，`chomp`更可取，因为它不会删除最后一个字符，除非它是记录分隔符（通常是换行符），而`chop`将删除最后一个字符，无论它是什么。以下是一些示例：
- en: '*chop_chomp.rb*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*chop_chomp.rb*'
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `chomp` method also lets you specify a character or string to use as the
    separator:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`chomp`方法还允许您指定用作分隔符的字符或字符串：'
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Format Strings
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: 'Ruby provides the `printf` method to print “format strings” containing specifiers
    starting with a percent sign (`%`). The format string may be followed by one or
    more data items separated by commas; the list of data items should match the number
    and type of the format specifiers. The actual data items replace the matching
    specifiers in the string, and they are formatted accordingly. These are some common
    formatting specifiers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby提供了`printf`方法来打印包含以百分号（`%`）开头的指定符的“格式化字符串”。格式化字符串后面可以跟一个或多个由逗号分隔的数据项；数据项的列表应与格式指定符的数量和类型相匹配。实际数据项将替换字符串中的匹配指定符，并相应地进行格式化。以下是一些常见的格式指定符：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can control floating-point precision by putting a point-number before the
    floating-point formatting specifier, `%f`. For example, this would display the
    floating-point value to six digits (the default) followed by a carriage return
    (`"\n"`):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在浮点格式指定符`%f`之前放置点数来控制浮点精度。例如，这将显示浮点值到六位数字（默认值）后跟一个回车符（`"\n"`）：
- en: '*string_printf.rb*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*string_printf.rb*'
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And the following would display the floating-point value to two digits (`"%0.02f"`).
    It is purely a matter of stylistic preference whether the floating-point specifier
    includes a preceding 0 or not and `"%0.2f"` is equivalent.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将显示浮点值到两位小数（`"%0.02f"`）。是否在浮点指定符前包含前导0纯粹是风格上的偏好，`"%0.2f"`是等效的。
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are a couple more examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些更多的示例：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That would output `d=10 f=10.000000 o=12 x=a s=10`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出`d=10 f=10.000000 o=12 x=a s=10`。
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That would output `0.04f=10.1295 : 0.02f=10.13`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '这将输出`0.04f=10.1295 : 0.02f=10.13`。'
- en: Ranges
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: In Ruby, a Range is a class that represents a set of values defined by a starting
    value and an ending value. Typically a range is defined using integers, but it
    may also be defined using other ordered values such as floating-point numbers
    or characters. Values can be negative, though you should be careful that your
    starting value is lower than your ending value!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，范围是一个类，它表示由起始值和结束值定义的值集。通常范围使用整数定义，但它也可以使用其他有序值定义，例如浮点数或字符。值可以是负数，但您应该小心，确保您的起始值低于您的结束值！
- en: 'Here are a few examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '*ranges.rb*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*ranges.rb*'
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can also specify ranges using three dots instead of two; this creates a
    range that omits the final value:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用三个点而不是两个点来指定范围；这将创建一个省略最后一个值的范围：
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can create an array of the values defined by a range using the `to_a` method,
    like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`to_a`方法创建由范围定义的值的数组，如下所示：
- en: '[PRE48]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that `to_a` is not defined for floating-point numbers for the simple reason
    that the number of possible values between two floating-point numbers is not finite.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`to_a`方法对于浮点数没有定义，简单的理由是两个浮点数之间可能值的数量不是有限的。
- en: Ranges of Strings
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串范围
- en: 'You can even create ranges of strings—though you would need to take great care
    in so doing because you might end up with more than you bargain for. For example,
    see whether you can figure out which values are specified by this range:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建字符串范围——尽管这样做需要格外小心，因为您可能会得到比预期更多的结果。例如，看看您是否能找出这个范围指定的值：
- en: '*str_range.rb*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*str_range.rb*'
- en: '[PRE49]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At first sight, the range from `''abc''` to `''def''` might not look like much.
    In fact, this defines a range of no less than 2,110 values! They are ordered like
    this: `abc`, `abd`, `abe`, and so on, until the end of the *a*s; then you start
    on the *b*s: `baa`, `bab`, `bac`, and so on. Suffice to say that ranges of this
    sort are probably rather a rare requirement and are best used with extreme caution
    or not at all.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，从`'abc'`到`'def'`的范围可能看起来不多。事实上，这定义了一个不少于2,110个值的范围！它们按以下顺序排列：`abc`，`abd`，`abe`，等等，直到`a`s的末尾；然后您开始于`b`s：`baa`，`bab`，`bac`，等等。简而言之，这种类型的范围可能相当罕见，最好非常谨慎或根本不使用。
- en: Iterating with a Range
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用范围迭代
- en: 'You may use a range to iterate from a start value to an end value. For example,
    here is one way of printing all the numbers from 1 to 10:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用范围从起始值迭代到结束值。例如，以下是一种打印从1到10的所有数字的方法：
- en: '*for_to.rb*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*for_to.rb*'
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Digging Deeper
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: Here you will learn how to create and iterate over ranges, write multiline strings
    with heredocs, and define your own string delimiters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习如何创建和迭代范围，使用heredoc编写多行字符串，以及定义你自己的字符串定界符。
- en: Heredocs
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Heredocs
- en: 'Although you can write long strings spanning multiple lines between single
    or double quotes, many Ruby programmers prefer to use an alternative type of string
    called a *heredoc*. A heredoc is a block of text that starts by specifying an
    end marker, which is simply an identifier of your choice. Here, I specify `EODOC`
    as the end marker:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在单引号或双引号之间写多行字符串，但许多Ruby程序员更喜欢使用一种称为*heredoc*的字符串类型。heredoc是一块文本，它首先指定一个结束标记，这只是一个你选择的标识符。在这里，我指定`EODOC`作为结束标记：
- en: '*heredoc.rb*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*heredoc.rb*'
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This tells Ruby that everything following the previous line is a single string
    that terminates when the end marker is located. The string is assigned to the
    variable, `hdoc1`. Here is an example of a complete heredoc assignment:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Ruby，从上一行之后的任何内容都是一个单独的字符串，直到遇到结束标记时结束。这个字符串被分配给变量`hdoc1`。以下是一个完整的heredoc分配示例：
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By default, heredocs are treated as double-quoted strings, so expressions such
    as `#{"cloud".upcase}` will be evaluated. If you want a heredoc to be treated
    as single-quoted string, specify its end marker between single quotes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，heredoc被视为双引号字符串，所以像`#{"cloud".upcase}`这样的表达式将被评估。如果你想将heredoc视为单引号字符串，请在单引号中指定其结束标记：
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The end marker of a heredoc must, by default, be placed flush with the left
    margin. If you want to indent it, you should use `<<-` rather than `<<` when assigning
    the end marker:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，heredoc的结束标记必须与左边缘对齐。如果你想缩进它，你应该在分配结束标记时使用`<<-`而不是`<<`：
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is up to you to pick an appropriate end marker. It is even legitimate (though,
    perhaps, not particularly sensible!) to use a reserved word:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的结束标记取决于你。甚至使用保留词也是合法的（尽管可能不是特别明智！）：
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A variable to which a heredoc is assigned can be used just like any other string
    variable:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 被分配给heredoc的变量可以像任何其他字符串变量一样使用：
- en: '[PRE56]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: String Literals
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量
- en: As explained earlier in this chapter, you can optionally delimit strings by
    `%q/` and `/` for single-quoted strings and either `%Q/` and `/` or `%/` and `/`
    for double-quoted strings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，你可以选择使用`%q/`和`/`来定界单引号字符串，或者使用`%Q/`和`/`或`%/`和`/`来定界双引号字符串。
- en: 'Ruby provides similar means of delimiting back-quoted strings, regular expressions,
    symbols, and arrays of either single-quoted or double-quoted strings. The ability
    to define arrays of strings in this way is particularly useful since it avoids
    the necessity of entering string delimiters for each item. Here is a reference
    to these string literal delimiters:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby提供了类似的定界方法，用于定界反引号字符串、正则表达式、符号，以及单引号或双引号字符串的数组。以这种方式定义字符串数组的能力特别有用，因为它避免了为每个项目输入字符串定界符的需要。以下是这些字符串字面量定界符的参考：
- en: '[PRE57]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Note that you may choose which delimiters to use. I have used `/` except with
    the regular expression where I have used `|` (since `/` is the “normal” regular
    expression delimiter), but I could equally have used square brackets, asterisks,
    ampersands, or other symbols (for example, `%W*dog cat #{1+2}*` or `%s&dog&`).
    Here is an example of these literals in use:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，你可以选择使用哪些定界符。我除了在正则表达式中使用了`|`（因为`/`是“正常”的正则表达式定界符）之外，还使用了斜杠`/`，星号`*`，和与号`&`，或者其他符号（例如，`%W*dog
    cat #{1+2}*`或`%s&dog&`）。以下是一些这些字面量在使用的示例：'
- en: '*literals.rb*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*literals.rb*'
- en: '[PRE58]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
