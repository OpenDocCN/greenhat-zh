- en: Chapter 4. LAYER IT ON
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：层层叠加
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages671943.png.jpg)'
- en: Mapping is like painting on a geo-referenced canvas. The most common brushes
    are markers and message boxes, which is the bulk of what we've used so far. To
    achieve a different texture, you'll need to switch it up. In this chapter, we'll
    branch out with some specialized layers that will improve the look of your maps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 地图绘制就像在地理参考画布上绘画。最常见的画笔是标记和信息框，这是我们迄今为止使用的大部分内容。为了达到不同的质感，您需要做出改变。在本章中，我们将通过一些专门的图层来扩展，这些图层将改善您地图的外观。
- en: 'To start, we''ll simply draw lines. A lot can be represented simply by connecting
    geographic coordinates together: routes, political boundaries, and even individual
    buildings. This chapter even has a project to color states or countries on a map,
    which could be used to make an election map like the ones that have become popular
    in recent US presidential races.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将简单地绘制线条。通过连接地理坐标，可以简单地表示很多内容：路线、政治边界，甚至单个建筑物。本章甚至有一个项目可以在地图上着色州或国家，这可以用来制作像最近美国总统选举中变得流行的选举地图。
- en: We'll also add images to the map. Didn't we do that with custom markers? Yes,
    but the images we'll be adding will be larger and act like your own map's imagery.
    In fact, we'll also create custom tiles, still utilizing a mapping API but bypassing
    (or augmenting) its own maps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将向地图添加图片。我们不是用自定义标记做过吗？是的，但我们将添加的图片将更大，并像您自己的地图图像一样使用。实际上，我们还将创建自定义瓦片，仍然利用地图API，但绕过（或增强）其自己的地图。
- en: Creating layers on your map is a huge step toward making your maps stand out
    as a masterpiece. Get out those new brushes and let's start mapping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上创建图层是使您的地图脱颖而出成为杰作的一大步。拿出那些新画笔，让我们开始绘图。
- en: '#16: Draw Lines on a Map'
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#16：在地图上绘制线条'
- en: 'What''s the shortest distance from point A to point B? Here''s a hint: After
    reading this section, you''ll be able to represent it on a map.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从点A到点B的最短距离是多少？这里有一个提示：阅读本节后，您将能够在地图上表示它。
- en: Drawing lines, which Mapstraction calls *polylines*, is very useful. With them,
    you can outline a route, such as driving directions or a hiking trail. Like a
    marker, a line uses latitude and longitude points. Of course, you can't have a
    line with a single point, so you'll need at least two pairs of coordinates to
    draw a line.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条，Mapstraction称之为*折线*，非常有用。有了它们，您可以勾勒出路线，例如驾驶方向或徒步旅行路线。就像标记一样，线条使用纬度和经度点。当然，您不能只有一个点的线条，所以您至少需要两对坐标来绘制线条。
- en: 'Mapstraction lets you have an unlimited number of points, but let''s start
    simply. This example will draw a line between the capitals of Georgia (the US
    state) and Georgia (the country). Add the following code to your `create_map`
    function after your map has been initialized:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction允许您拥有无限数量的点，但让我们从简单开始。这个例子将在乔治亚州（美国州）和乔治亚国（国家）的首都之间绘制线条。在初始化地图后，将以下代码添加到您的`create_map`函数中：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing I've done is declare the two points ❶, storing them in an array
    variable. Note the square brackets—`[` and `]`—that create the array and that
    the two `LatLonPoints` inside the array are separated by a comma. Mapstraction
    requires an array with at least two `LatLonPoints` to create a polyline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先声明了两个点❶，将它们存储在一个数组变量中。注意创建数组的方括号——`[`和`]`——以及数组内部两个`LatLonPoints`之间用逗号分隔。Mapstraction需要一个至少包含两个`LatLonPoints`的数组来创建折线。
- en: Next, I actually create the `Polyline` object ❷ using the array. Like a marker
    object, this object is Mapstraction's way of representing the data so it can be
    reproduced with multiple mapping providers, if necessary. Creating a polyline
    is not enough to draw the line, however. I also need to add it to the map ❸.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我实际上使用数组创建了`Polyline`对象❷。就像标记对象一样，这个对象是Mapstraction表示数据的方式，以便在必要时可以与多个地图服务提供商一起重现。然而，创建折线并不足以绘制线条。我还需要将其添加到地图中❸。
- en: 'Finally, I automatically center the map using the same function described in
    [#8: Determine the Correct Zoom Level to Use Based on Markers](ch02s08.html "#8:
    Determine the Correct Zoom Level to Use Based on Markers") in [#7: Loop Through
    All Markers](ch02s07.html "#7: Loop Through All Markers"). In this case, Mapstraction
    uses polylines instead of markers to determine the zoom level.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我使用在[#8：根据标记确定正确的缩放级别](ch02s08.html "#8: Determine the Correct Zoom Level
    to Use Based on Markers")和[#7：遍历所有标记](ch02s07.html "#7: Loop Through All Markers")中描述的相同函数自动将地图居中。在这种情况下，Mapstraction使用折线而不是标记来确定缩放级别。'
- en: The resulting map is shown in [Figure 4-1](ch04.html#a_line_drawn_between_two_georgian_capita
    "Figure 4-1. A line drawn between two Georgian capitals") with a line drawn across
    the Atlantic Ocean, connecting the two Georgias. Let's see if we can make something
    a little more useful by adding more points to our line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结果地图显示在[图4-1](ch04.html#a_line_drawn_between_two_georgian_capita "图4-1. 在两个乔治亚首都之间绘制的线")中，横跨大西洋，连接两个乔治亚。让我们看看通过在在线上添加更多点，我们能否使其变得更有用。
- en: '![A line drawn between two Georgian capitals](httpatomoreillycomsourcenostarchimages671987.png.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![在两个乔治亚首都之间绘制的线](httpatomoreillycomsourcenostarchimages671987.png.jpg)'
- en: Figure 4-1. A line drawn between two Georgian capitals
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1. 在两个乔治亚首都之间绘制的线
- en: Draw Multiple Line Segments
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制多个线段
- en: 'When you think of a line, you probably picture something like what we created
    in the previous section: the connection between two points. Polylines, however,
    can have unlimited segments, which means you can use them to create paths and
    routes.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到线时，你可能想象的是我们在上一节中创建的东西：两点之间的连接。然而，折线可以有无限多的段，这意味着你可以使用它们来创建路径和路线。
- en: In fact, Google uses a polyline to display its driving directions. Using polylines
    makes sense because very few streets are perfectly straight. Most have at least
    slight meanderings from side to side. In San Francisco, a couple of streets are
    even known for their crookedness, most notably a short section of Lombard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，谷歌使用折线来显示其驾驶方向。使用折线是有意义的，因为很少有街道是完全直的。大多数街道至少在两侧有轻微的蜿蜒。在旧金山，有几条街道甚至以其弯曲而闻名，最著名的是洛马街的一段短距离。
- en: 'Here''s some code to create a polyline that very roughly follows the curves
    of Lombard Street, from the top to the bottom:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码，用于创建一个大致沿着洛马街曲线的折线，从上到下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from [Figure 4-2](ch04.html#a_polyline_with_several_points_to_trace
    "Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street"), those 11 latitude and longitude points create a polyline that traces
    along Lombard's eight turns. As with the Georgia example, the points are stored
    within brackets to create the JavaScript array that Mapstraction needs to make
    a polyline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4-2](ch04.html#a_polyline_with_several_points_to_trace "图4-2. 使用多个点追踪旧金山著名的洛马街的折线")所示，这11个纬度和经度点创建了一个沿着洛马街八个转弯的折线。与乔治亚的例子一样，这些点存储在括号内，以创建Mapstraction制作折线所需的JavaScript数组。
- en: '![A polyline with several points to trace San Francisco''s famous Lombard Street](httpatomoreillycomsourcenostarchimages671989.png.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![使用多个点追踪旧金山著名的洛马街的折线](httpatomoreillycomsourcenostarchimages671989.png.jpg)'
- en: Figure 4-2. A polyline with several points to trace San Francisco's famous Lombard
    Street
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2. 使用多个点追踪旧金山著名的洛马街的折线
- en: Lombard Street is still a fairly simple example. We've covered less than a quarter
    mile—and that includes the twists and turns. You could use polylines to trace
    entire highways, rivers that flow for hundreds of miles, or even the Great Wall
    of China.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 洛马街仍然是一个相当简单的例子。我们覆盖的还不到四分之一英里——这包括转弯。你可以使用折线来追踪整个高速公路、数百英里流淌的河流，甚至中国的长城。
- en: Set the Color and Thickness
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置颜色和粗细
- en: Like markers and other aspects of a map, polylines come with a standard look
    you may want to change. For example, you can alter the color and thickness of
    the lines you draw.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就像标记和其他地图方面一样，折线也带有你可能会想要更改的标准外观。例如，你可以改变你绘制的线的颜色和粗细。
- en: Mapstraction has individual functions to set the criteria you want. Each can
    be applied after you have created a polyline, but before you have added it to
    the map. This process is similar to the order in which Marker options have to
    be added.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction有单独的函数来设置你想要的标准。每个函数都可以在你创建折线后、将其添加到地图之前应用。这个过程与添加标记选项的顺序相似。
- en: 'Here is an example that makes a purple polyline that is five pixels thick (it
    assumes your polyline is stored in the `poly` variable):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它创建了一个五像素粗的紫色折线（它假设你的折线存储在`poly`变量中）：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the color is set as a hexadecimal value ❶, similar to how colors are
    declared in HTML. Either a six- or three-character value works, and you can even
    precede it with a hash mark, `#`, if you prefer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，颜色设置为十六进制值❶，类似于在HTML中声明颜色的方式。可以是六位或三位值，如果你愿意，甚至可以在其前面加上一个井号`#`。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some browsers, especially older ones, have trouble with colored polylines. Be
    sure to check thoroughly across all browsers your user base commonly employs,
    especially if the color of the polyline is integral to your application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器，尤其是较旧的浏览器，在处理彩色多边形时可能会遇到问题。请确保彻底检查你的用户群通常使用的所有浏览器，特别是如果多边形的颜色对你的应用程序至关重要的话。
- en: 'Because you''ll often want to set several attributes at once, Mapstraction
    has a function that accepts many options, storing their values in a JavaScript
    object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你通常会同时设置多个属性，Mapstraction 有一个接受许多选项并存储它们值的 JavaScript 对象的函数：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The curly brackets `{` and `}` are important, as they declare the JavaScript
    object. Then an attribute is set with the name of the option, a colon, and the
    value. You'll see more examples of adding styling options to polylines in the
    next project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 `{` 和 `}` 很重要，因为它们声明了 JavaScript 对象。然后使用选项的名称、冒号和值设置一个属性。你将在下一个项目中看到更多添加样式选项到多边形的示例。
- en: '#17: Draw Shapes on a Map'
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#17: 在地图上绘制形状'
- en: 'Are you ready for a little philosophy? I hope so, because I have a philosophical
    question for you: What is a shape?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好一点哲学了吗？我希望如此，因为我有一个哲学问题要问你：什么是形状？
- en: Before you answer that, let's list some names of shapes. Shapes include circles
    and triangles. Squares are popular, as are their relative the rectangles. If we
    continue to increase the number of sides, the names may sound familiar—pentagon,
    hexagon, heptagon, octagon—and then the names get a little strange.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在你回答之前，让我们列出一些形状的名称。形状包括圆形和三角形。正方形很受欢迎，以及它们的相对矩形。如果我们继续增加边的数量，名称可能会听起来很熟悉——五边形、六边形、七边形、八边形——然后名称会变得有点奇怪。
- en: Your philosophical answer may be different, but for our purposes, we'll create
    a shape with some number of sides. This shape is called a *polygon*. A polygon
    is made up of line segments that start and end at the same point. If you have
    mastered the previous project, you probably have a pretty good idea of how you
    could create a polygon using Mapstraction.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你的哲学答案可能不同，但为了我们的目的，我们将创建一个具有一些边的形状。这个形状被称为 *多边形*。多边形由起点和终点相同的线段组成。如果你已经掌握了前面的项目，你很可能对如何使用
    Mapstraction 创建多边形有一个相当好的想法。
- en: 'Surprisingly, creating shapes on a map is essentially the same process as drawing
    polylines. Take a look at this code, which draws an outline around the US Department
    of Defense headquarters ("The Pentagon"—get it?):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 意想不到的是，在地图上创建形状的过程基本上与绘制多边形相同。看看这段代码，它绘制了美国国防部总部（“五角大楼”——明白了吗？）的轮廓：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As with standard polylines, we need to declare an array of `LatLonPoint`s using
    square brackets `[` and `]` to show a JavaScript array. The big difference is
    that the first and last points (both shown in bold) are identical, signaling to
    Mapstraction that you are creating a polygon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准多边形一样，我们需要使用方括号 `[` 和 `]` 声明一个 `LatLonPoint` 数组，以显示 JavaScript 数组。最大的不同是第一个和最后一个点（两者都加粗）是相同的，这向
    Mapstraction 信号你正在创建一个多边形。
- en: The outcome, as shown in [Figure 4-3](ch04s02.html#the_pentagon_building_outlined_with_a_po
    "Figure 4-3. The Pentagon building outlined with a polygon"), is that the polyline
    is filled in to show that it's more than just a line—it's a shape. Shapes bring
    up a few more styling issues than normal lines, so Mapstraction provides some
    additional options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 4-3](ch04s02.html#the_pentagon_building_outlined_with_a_po "图 4-3. 使用多边形勾勒的五角大楼")所示，结果是多边形被填充以显示它不仅仅是一条线——它是一个形状。与普通线条相比，形状会引发更多样式问题，因此
    Mapstraction 提供了一些额外的选项。
- en: '![The Pentagon building outlined with a polygon](httpatomoreillycomsourcenostarchimages671991.png.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用多边形勾勒的五角大楼](httpatomoreillycomsourcenostarchimages671991.png.jpg)'
- en: Figure 4-3. The Pentagon building outlined with a polygon
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3. 使用多边形勾勒的五角大楼
- en: Set the Fill Color and Opacity
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置填充颜色和透明度
- en: Now that your polyline has turned into a polygon, let's declare the color that
    fills its center. Also, with the fill covering such a large area, you may want
    to leave bits of the map under the polygon visible. That's where opacity comes
    in—it determines the opaqueness of the fill color.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然你的多边形已经变成了多边形，让我们声明填充其中心的颜色。此外，由于填充覆盖了如此大的区域，你可能希望让多边形下的地图部分可见。这就是透明度发挥作用的地方——它决定了填充颜色的不透明度。
- en: If you are familiar with graphics programs, you'll likely be comfortable with
    opacity. You declare it with a percentage from 0 to 100, where 0 is invisible
    and 100 is not transparent at all.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉图形程序，你可能会对透明度感到舒适。你用从 0 到 100 的百分比来声明它，其中 0 是不可见的，100 完全不透明。
- en: 'Let''s use a single function in Mapstraction to set all the options for the
    pentagon we made earlier:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Mapstraction中的一个单一函数来设置我们之前制作的五边形的所有选项：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we have declared an opacity of 90 percent ❶, so we can barely see through
    it. Notice that we use a decimal between 0 and 1 to show the percentage. Though
    mathematically correct, you may find this a little confusing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了90%的不透明度❶，所以我们几乎看不到它。请注意，我们使用0到1之间的十进制数来表示百分比。虽然从数学上是正确的，但你可能会觉得有点困惑。
- en: The fill color is declared with a CSS-like hexadecimal value ❷. This value is
    separate from the color of the polyline, which can be the same or different. In
    this example, the fill color is a bright green, whereas the border is a slightly
    darker green.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 填充颜色使用类似CSS的十六进制值声明❷。此值与折线颜色分开，可以是相同的也可以是不同的。在这个例子中，填充颜色是一种明亮的绿色，而边框则是一种略深的绿色。
- en: '#18: Add Circles to Show Search Radius'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#18：添加圆以显示搜索半径'
- en: Drawing lines and polygons is fairly easy. They are made up of a series of connected
    points. A circle is a little more difficult to express. A circle has no points
    that make up its border. Instead, it's declared by a center point and a radius.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线和多边形相对简单。它们由一系列连接的点组成。圆稍微有点难以表达。圆没有组成其边界的点。相反，它通过一个中心点和半径来声明。
- en: Circles are useful in mapping, because you can use them to show an area you
    are searching. For example, if you are looking for places within five miles of
    a point, your circle would be ten miles wide (and tall—a circle is perfectly round),
    with the search point right at the center.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 圆在地图上很有用，因为你可以用它们来显示你正在搜索的区域。例如，如果你正在寻找距离一个点五英里内的地点，你的圆将宽十英里（并且高——圆是完美圆形的），搜索点正好位于中心。
- en: Mapstraction offers two ways to create a circle. First, we can approximate with
    a many-sided polygon. Second, we could use a graphic and layer it on top of the
    map. In this section, I'll show you how to do both.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction提供了两种创建圆的方法。首先，我们可以用多边形进行近似。其次，我们可以使用图形并将其叠加在地图上。在本节中，我将向你展示如何做这两件事。
- en: Approximate with a Polygon
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用多边形进行近似
- en: Creating a fake circle by connecting points along the circle looks better than
    you might imagine it would. Of course, the more points you use, the better the
    circle looks. Mapstraction has a built-in function to perform the computations,
    and you can set the quality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接圆上的点来创建一个假圆看起来比你想象的要好。当然，你使用的点越多，圆看起来就越好。Mapstraction有一个内置函数来执行计算，你可以设置质量。
- en: 'Remember, a circle requires two pieces of information: a center and a radius.
    In this example, we''ll show just how big the state of Texas is by drawing a circle
    500 miles in diameter starting from its capital near the center of the state.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个圆需要两个信息：一个中心和半径。在这个例子中，我们将通过画一个直径为500英里的圆来展示德克萨斯州的大小，这个圆从州的首府开始，位于州中心的附近。
- en: 'Add these lines to your map initialization function, which I''ve called `create_map`
    throughout this book:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行添加到你的地图初始化函数中，我在整本书中将其称为`create_map`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code is all that''s necessary to add a circle-ish polygon to your map.
    First, you need to create a `Radius` object ❶, which is part of the Mapstraction
    library. This object does some important calculations to determine the circle''s
    edges. Then you pass the object two values: the center point (downtown Austin,
    Texas) and a quality number ❷.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是添加类似圆形的多边形到地图上所必需的。首先，你需要创建一个`Radius`对象❶，它是Mapstraction库的一部分。这个对象进行一些重要的计算来确定圆的边缘。然后你传递给这个对象两个值：中心点（德克萨斯州奥斯汀市中心）和一个质量数字❷。
- en: The lower the quality number, the more your polygon will look like a circle.
    The number represents the degrees between each point in the polygon. You can use
    this to determine the number of sides your "circle" will have. A circle is 360
    degrees total, so if you divide by 10, that's 36 points, which means you're creating
    a 36-sided polygon in this instance. Using this method, you've done a pretty good
    job of approximating a circle, as you can see in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon"). The more sides you have,
    the longer it takes to create the circle, so you have to make a trade-off.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 质量数字越低，你的多边形看起来就越像圆形。这个数字代表多边形中每两点之间的度数。你可以用这个来确定你的“圆形”将有多少边。一个圆总共是360度，所以如果你除以10，那就是36个点，这意味着你在这个例子中创建了一个36边形。使用这种方法，你做得相当不错，可以近似一个圆，就像你在[图4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "图4-4. 用36边形近似的圆")中看到的那样。边数越多，创建圆所需的时间就越长，所以你必须做出权衡。
- en: '![Circle approximated by 36-sided polygon](httpatomoreillycomsourcenostarchimages671993.png.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![用36边形近似的圆](httpatomoreillycomsourcenostarchimages671993.png.jpg)'
- en: Figure 4-4. Circle approximated by 36-sided polygon
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4. 用36边形近似的圆
- en: Now that you have a `Radius` object, you can create the polygon, which is a
    `Polyline` object. You use a Mapstraction function to convert miles to kilometers
    ❸. Here, I've passed it the number of miles of the radius, which is half of the
    diameter of the eventual circle. Also, I've passed a hexadecimal value for the
    color ❹ of the circle, in this case, a shade of purple.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了半径对象，你可以创建多边形，这是一个多段线对象。你使用Mapstraction函数将英里转换为公里❸。在这里，我传递了半径的英里数，这是最终圆直径的一半。此外，我还传递了一个用于圆的颜色十六进制值❹，在这种情况下，是一种紫罗兰色调。
- en: You can create as many circles as you want from the radius object, so you could
    show several levels of distance from Austin. If you want to move the center (or
    change the quality of the circle), however, you'll need to re-create the radius
    object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从半径对象创建任意多的圆形，所以你可以显示从奥斯汀出发的几个不同级别的距离。然而，如果你想移动中心（或改变圆的质量），你需要重新创建半径对象。
- en: Overlay a Circle Image
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在图像上叠加圆形
- en: The polygonized circle may still be too jagged for you, or perhaps you want
    more control over how the circle looks. In that case, overlaying an image on your
    map is your best choice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形化的圆可能对你来说仍然太粗糙，或者你可能想要对圆形的外观有更多的控制。在这种情况下，在你的地图上叠加图像是你的最佳选择。
- en: First, you'll need a circle image, likely saved as a transparent PNG file. Transparency
    is important because graphics are stored as rectangles, so you definitely don't
    want the area outside of the circle to be visible. Also, since you'll be referencing
    this on the map as a rectangle, your circle should be up against the four edges
    of the graphic. I've included several sample circle graphics for download on the
    book's website at [http://mapscripting.com/circle-overlays](http://mapscripting.com/circle-overlays).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个圆形图像，可能是一个保存为透明PNG文件的图像。透明度很重要，因为图形是以矩形存储的，所以你绝对不希望圆外的区域可见。此外，由于你将在这个地图上作为矩形引用它，你的圆形应该紧靠图形的四边。我在书的网站上包含了几个示例圆形图形供下载，网址为[http://mapscripting.com/circle-overlays](http://mapscripting.com/circle-overlays)。
- en: Once you have your circle graphic, you can figure out where to place it on the
    map. A graphic is referenced by the four sides of its rectangle, so you need to
    determine the north, south, east, and west points. Usually, a circle is determined
    by its center and radius. You can calculate the side values by measuring in four
    directions from the center.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了圆形图像，你就可以确定它在地图上的位置。一个图形是通过其矩形的四边来引用的，所以你需要确定北、南、东和西的点。通常，一个圆是由其中心和半径确定的。你可以通过从中心测量四个方向来计算边值。
- en: 'Add these lines to your map code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到你的地图代码中：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To be able to determine the geographic borders of your circle image, you need
    to calculate how many degrees of latitude and longitude make up the radius, which
    is 250 miles. The latitude distance ❶ is easier, because latitude is nearly constant
    throughout the world at 69.2 miles per degree.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够确定你的圆形图像的地理边界，你需要计算纬度和经度有多少度组成半径，这是250英里。纬度距离❶更容易计算，因为纬度在世界上几乎是一致的，每度69.2英里。
- en: Longitude depends on where you are on earth because the degrees are closer to
    each other as you near a pole. Mapstraction has a handy function ❷ for converting
    meters to longitude based on a latitude. In order to pass the function 250 miles
    in meters, you must first convert to kilometers ❸ and then multiply by 1000.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 经度取决于你在地球上的位置，因为当你接近极点时，度数彼此更接近。Mapstraction 有一个方便的函数 ❷ 用于根据纬度将米转换为经度。为了将函数
    250 英里转换为米，你必须首先将其转换为千米 ❸ 然后乘以 1000。
- en: At this point, you have your distances, so now you just need to calculate the
    four sides. For example, the northern border ❹ of the graphic will be at the center
    point latitude plus the number of degrees latitude we determined are in 250 miles.
    South will also use that latitude distance (only this distance is subtracted from
    the center's latitude. East and west borders will use the longitude distance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有了距离，所以现在你只需要计算四条边。例如，图形的北部边界 ❹ 将在中心点纬度加上我们确定的 250 英里中的纬度数。南部也将使用那个纬度距离（只是从这个距离中减去中心点的纬度。东部和西部边界将使用经度距离。
- en: Armed with your four geographic borders, you can apply your image overlay. Mapstraction
    needs a lot of information, including an identifier for the image ❺ and an opacity
    level ❻ (for this example, I've chosen 75 percent). The results are shown in [Figure 4-5](ch04s03.html#transparent_circle_image_overlay
    "Figure 4-5. Transparent circle image overlay"), where you can see a perfect circle
    atop Texas. The area it covers, you'll notice, is identical to the area covered
    by the polygon circle in [Figure 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "Figure 4-4. Circle approximated by 36-sided polygon").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有你的四个地理边界后，你可以应用你的图像叠加。Mapstraction 需要很多信息，包括图像的标识符 ❺ 和不透明度级别 ❻（在这个例子中，我选择了
    75%）。结果如图 [图 4-5](ch04s03.html#transparent_circle_image_overlay "图 4-5. 透明圆形图像叠加")
    所示，你可以看到在德克萨斯州上方的完美圆形。你会发现，它覆盖的区域与 [图 4-4](ch04s03.html#circle_approximated_by_36-sided_polygon
    "图 4-4. 由 36 边形近似的圆") 中多边形圆覆盖的区域相同。
- en: '![Transparent circle image overlay](httpatomoreillycomsourcenostarchimages671995.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![透明圆形图像叠加](httpatomoreillycomsourcenostarchimages671995.png.jpg)'
- en: Figure 4-5. Transparent circle image overlay
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5. 透明圆形图像叠加
- en: No matter which type of circle you choose to use, Texas is a big state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择使用哪种类型的圆，德克萨斯州都是一个很大的州。
- en: '#19: Draw a Rectangle to Declare an Area'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#19: 画一个矩形来声明一个区域'
- en: In [Chapter 2](ch02.html "Chapter 2. PLOTTING MARKERS AND MESSAGE BOXES"), I
    discussed the bounding box, a set of coordinates that roughly describes a geographic
    area. I write *roughly* because bounds are visually rectangular, so they can only
    be used to declare the simplest of areas. Of course, with every map we have been
    indirectly creating bounds. The visible portion of the map is a rectangular portion
    of the greater map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。绘制标记和信息框") 中，我讨论了边界框，一组大致描述地理区域的坐标。我写 *大致* 是因为边界在视觉上是矩形的，所以它们只能用来声明最简单的区域。当然，我们已经间接地为每个地图创建了边界。地图的可见部分是更大地图的一个矩形部分。
- en: Mapstraction uses the `BoundingBox` class to describe an area. As a data structure,
    this class is made up of two `LatLonPoint`s. One declares the southwest corner
    (the lower left) and the other the northeast corner (the upper left). From those
    two values, we can figure out the remaining two corners. And we'll do just that
    in this project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction 使用 `BoundingBox` 类来描述一个区域。作为一个数据结构，这个类由两个 `LatLonPoint` 组成。一个声明西南角（左下角）和另一个声明东北角（右上角）。从这两个值中，我们可以推断出剩余的两个角。我们将在本项目中进行这样的操作。
- en: 'You may find yourself wanting to declare an area of the map visually. Because
    a `BoundingBox` is simply a data representation of an area, we need to convert
    to a `Polyline`. Add this function to your JavaScript (outside the `create_map`
    function) to perform the conversion:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望从视觉上声明地图上的一个区域。因为 `BoundingBox` 只是一个区域的简单数据表示，我们需要将其转换为 `Polyline`。将此函数添加到你的
    JavaScript 中（在 `create_map` 函数外部）以执行转换：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Drawing a rectangle on a map requires five points. At first, this requirement
    may seem a bit strange—doesn't a rectangle have four corners? Of course. We aren't
    violating basic rules of geometry. We need to declare the start and the finish
    points separately, however. And because these are the same point (or, as you'll
    see, nearly the same), we include it twice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上绘制一个矩形需要五个点。起初，这个要求可能看起来有点奇怪——矩形不是有四个角吗？当然。我们并没有违反基本的几何规则。然而，我们需要分别声明起点和终点。而且因为这两个点是相同的（或者，正如你将看到的，几乎相同），所以我们将其包含两次。
- en: The array of points begins, simply enough, with the southwest point ❶. Then
    we want to draw a line directly north, which means we need to keep the same longitude
    while increasing the latitude. We only have two points to work with, so we create
    a new point ❷ using the southwest's longitude and the northeast's latitude.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 点数数组简单地从西南点开始 ❶。然后我们想要直接向北绘制一条线，这意味着我们需要保持相同的经度同时增加纬度。我们只有两个点可以操作，因此我们使用西南点的经度和东北点的纬度创建一个新的点
    ❷。
- en: The third point is the northeast point itself. Then we can use a similar process
    to determine the fourth point. Finally, we need to draw the final side of the
    rectangle back to the southwest point. But this is where things get strange. If
    we use exactly the southwest point, Mapstraction will fill in the area. To get
    an unfilled box, we create a final point with a longitude almost imperceptibly
    off ❸ from the starting point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个点是东北点本身。然后我们可以使用类似的过程来确定第四个点。最后，我们需要将矩形的最后一侧画回到西南点。但这里事情变得奇怪。如果我们使用确切的西南点，Mapstraction
    将填充该区域。为了得到一个空心的框，我们创建一个最终点，其经度几乎无法察觉地偏离 ❸ 起始点。
- en: 'Now that we''ve written our new function, we need to call it. From within your
    `create_map` function, add the following lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了我们的新函数，我们需要调用它。在你的 `create_map` 函数内部，添加以下行：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We could create new bounds if we wanted, but instead we are taking them from
    the map itself ❹. Then we use those bounds to call our function to convert to
    a `Polyline` ❺. As you saw earlier, creating the object is just the first step.
    We also need to add it to the map. The final line zooms out so we can see the
    rectangle, as shown in [Figure 4-6](ch04s04.html#bounding_box_converted_to_a_polyline
    "Figure 4-6. Bounding box converted to a polyline"). Without zooming, the rectangle
    would be right at the edges of our map.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建新的边界，我们可以这样做，但相反，我们是从地图本身获取它们 ❹。然后我们使用这些边界来调用我们的函数将其转换为 `Polyline` ❺。正如你之前看到的，创建对象只是第一步。我们还需要将其添加到地图上。最终的线会放大，这样我们就可以看到矩形，如图
    [图4-6](ch04s04.html#bounding_box_converted_to_a_polyline "图4-6. 将边界框转换为折线") 所示。如果不放大，矩形就会位于我们地图的边缘。
- en: '![Bounding box converted to a polyline](httpatomoreillycomsourcenostarchimages671997.png.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![将边界框转换为折线](httpatomoreillycomsourcenostarchimages671997.png.jpg)'
- en: Figure 4-6. Bounding box converted to a polyline
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6. 将边界框转换为折线
- en: 'Use this snippet of code to clearly show bounds. For an example of this project
    in action, see [#7: Loop Through All Markers](ch02s07.html "#7: Loop Through All
    Markers") in [Other Useful Parameters](ch06s07.html#other_useful_parameters "Other
    Useful Parameters").'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '使用此代码片段清楚地显示边界。有关此项目的实际示例，请参阅 [其他有用参数](ch06s07.html#other_useful_parameters
    "其他有用参数") 中的 [#7: 遍历所有标记](ch02s07.html "#7: 遍历所有标记")。'
- en: '#20: Draw Lines Along Clicks'
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#20: 沿点击绘制线条'
- en: The biggest stumbling block to creating your own lines on a map is finding the
    latitude and longitude points. With this project, you (or your users) will be
    able to draw lines simply by clicking the map. Gmap Pedometer ([http://gmap-pedometer.com/](http://gmap-pedometer.com/))
    popularized this technique in the earliest days of mapping APIs, and now you can
    use it, too.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上创建自己的线路的最大障碍是找到经纬度点。通过这个项目，你（或你的用户）将能够通过点击地图来简单地绘制线路。Gmap Pedometer ([http://gmap-pedometer.com/](http://gmap-pedometer.com/))
    在地图API的早期阶段推广了这项技术，现在你也可以使用它了。
- en: 'Reacting to a click event is at the center of this method. You will find events
    covered in detail in [Chapter 5](ch05.html "Chapter 5. HANDLE MAP EVENTS"). We
    want to store all the click points in an array. Because we''ll be accessing this
    from an event, the variable we create needs to be public, meaning it is declared
    outside of any function. Include this line at the beginning of your JavaScript:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对点击事件的响应是这个方法的中心。你将在 [第5章](ch05.html "第5章. 处理地图事件") 中详细了解到事件。我们想要将所有点击的点存储在一个数组中。因为我们将从事件中访问它，所以我们创建的变量需要是公共的，这意味着它是在任何函数外部声明的。在你的JavaScript开头包含以下行：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This variable will hold every point that is clicked. Right now it is an empty
    array (there's nothing between those square brackets). With every click, however,
    we'll add a new `LatLonPoint` to the array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将保存每个点击的点。目前它是一个空数组（方括号之间没有内容）。然而，每次点击，我们都会向数组中添加一个新的 `LatLonPoint`。
- en: 'From within your map initialization code, add these lines to react to clicks:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的地图初始化代码中，添加以下行以响应点击：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, I have included the code that runs when the user clicks the map in an
    anonymous, inline function. This is about as long as I would make a function without
    explicitly naming it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我包括了当用户点击地图时运行的匿名内联函数中的代码。这几乎是我会编写的没有明确命名的函数的长度。
- en: The very first thing that happens is we "push" the new point into the array
    ❶. The `push` function is built into JavaScript for every array variable and always
    adds it on to the end of the array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在第一件事是我们将新点“推入”数组❶。`push`函数是JavaScript中每个数组变量的内置函数，并且始终将其添加到数组的末尾。
- en: The minimum number of points before we can draw a line is two. This requirement
    causes a bit of an issue because we need the user to know we have recorded the
    first click. To deal with this, we added a marker ❷ to the map only if the length
    of the array is one. In other words, a marker is added only on the first click.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够画线之前的最小点数是两个。这个要求引起了一些问题，因为我们需要让用户知道我们已经记录了第一次点击。为了解决这个问题，我们只在数组长度为1时在地图上添加一个标记❷。换句话说，只有在第一次点击时才会添加标记。
- en: On subsequent clicks, we create a new polyline ❸ with the two most recent points.
    To do this, we connect the last point in the array ❹ to the next-to-last point
    in the array (because arrays in JavaScript begin counting at zero, the last element
    is always one less than the length). Also, remember that a polyline is created
    with an array itself, so we need to surround those two numbers with brackets.
    The code starts to look a little messy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的点击中，我们使用最近两个点创建一个新的折线❸。为此，我们将数组中的最后一个点❹连接到倒数第二个点（因为在JavaScript中数组从零开始计数，最后一个元素总是比长度少一个）。此外，请记住，折线是通过数组本身创建的，因此我们需要用括号包围这两个数字。代码开始看起来有点杂乱。
- en: After several clicks, the map will look something like [Figure 4-7](ch04s05.html#connecting_clicks_with_polyline_segments
    "Figure 4-7. Connecting clicks with polyline segments"). Internally, we'll have
    all the points stored in our array. Mapstraction, however, is treating each line
    segment as its own polyline. From a visual perspective, it still looks like one
    big line.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次点击之后，地图看起来可能像[图4-7](ch04s05.html#connecting_clicks_with_polyline_segments
    "图4-7. 通过折线段连接点击")。从内部来看，我们将所有点都存储在我们的数组中。然而，Mapstraction将每个线段视为自己的折线。从视觉角度来看，它仍然看起来像一条大线。
- en: '![Connecting clicks with polyline segments](httpatomoreillycomsourcenostarchimages671999.png.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![通过折线段连接点击](httpatomoreillycomsourcenostarchimages671999.png.jpg)'
- en: Figure 4-7. Connecting clicks with polyline segments
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-7. 通过折线段连接点击
- en: '#21: Color States/Countries on a Map'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#21: 在地图上显示颜色状态/国家'
- en: If you've paid attention to recent US politics, you've likely seen red and blue
    state maps. During the 2004 and 2008 presidential campaigns, these became common
    across the Web. And believe it or not, if you've read this far in the chapter,
    you already know how to make a colored map of your own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了最近的美国政治，你很可能看到了红色和蓝色州地图。在2004年和2008年的总统竞选期间，这些地图在互联网上变得很常见。而且信不信由你，如果你读到本章的这一部分，你已经知道如何制作自己的彩色地图了。
- en: All you need are the points that make up the outline of each state. Then, you
    create a polygon for each state, giving it the proper fill color. Before you can
    start coloring states, you'll need the points that make up the outline of each
    state. You can get this data in a number of ways. For example, you could create
    it on your own using code similar to that in the previous project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的只是构成每个州轮廓的点。然后，为每个州创建一个多边形，并给它适当的填充颜色。在你开始着色州之前，你需要构成每个州轮廓的点。你可以通过多种方式获取这些数据。例如，你可以使用与上一个项目类似的方法自己创建它。
- en: You could also take it directly from the government, but you'd likely need to
    convert it to a format that's easy for Mapstraction to use. I have data sources
    available at the book's website at [http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接从政府那里获取，但你可能需要将其转换为Mapstraction容易使用的格式。我在书的网站上提供了数据源[http://mapscripting.com/state-boundaries](http://mapscripting.com/state-boundaries)。
- en: 'If you want to try it out, start with just a few states. In this example, I''ll
    use the four-corner states of Utah, Colorado, Arizona, and New Mexico. They have
    relatively few points, and they all come together neatly. The first step is declaring
    the points that make up each state boundary as a JavaScript array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下，先从几个州开始。在这个例子中，我将使用犹他州、科罗拉多州、亚利桑那州和新墨西哥州的四个角落州。它们有相对较少的点，并且它们都整齐地聚集在一起。第一步是声明构成每个州边界的点作为JavaScript数组：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Arizona is just a little too complex to show all of its points in the book,
    but the others are complete. Like declaring other shapes using points, we include
    a list of `LatLonPoint`s within square brackets to designate an array. To create
    a complete shape (and, therefore, include a fill color), the first and last points
    in the array must be identical. The identical points tell Mapstraction that the
    polyline begins and ends at the same place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 亚利桑那州过于复杂，无法在书中展示其所有点，但其他州的信息是完整的。就像使用点声明其他形状一样，我们使用方括号包含一个`LatLonPoint`列表来指定一个数组。为了创建一个完整的形状（因此包括填充颜色），数组中的第一个和最后一个点必须相同。相同的点告诉Mapstraction多边形开始和结束在同一个地方。
- en: 'Because we are going to be performing the same actions multiple times, this
    is an appropriate occasion to create our own function. Here is the code to color
    in a state:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将多次执行相同的操作，这是一个创建我们自己的函数的合适时机。以下是填充状态的代码：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll call this function four times—once for each state. Or, if you're doing
    the whole United States, you'd call the function fifty times. This function's
    three lines mean our code will only take up one-third of the space. If you're
    going to run the same code many times, you'll want to avoid duplication and create
    your own function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用这个函数四次——一次针对每个州。或者，如果你要绘制整个美国，你需要调用这个函数五十次。这个函数的三行意味着我们的代码只需占用三分之一的篇幅。如果你打算多次运行相同的代码，你将想要避免重复并创建自己的函数。
- en: We'll need to pass the function two arguments. First, we pass it a list of points
    ❶—a state boundary array. Then, because we're filling in the map with different
    colored states, we'll need to let the function know what color ❷ to make the current
    state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将函数传递两个参数。首先，我们传递给它一个点的列表❶——一个状态边界数组。然后，因为我们将在地图上用不同颜色的状态填充，我们需要让函数知道当前状态应该使用什么颜色❷。
- en: The function then goes to work creating a `Polyline` and adding data to it.
    We've set the opacity to 90 percent ❸, which means the filled state shape will
    be slightly transparent, just enough to see the state name underneath. The color
    is set ❹ to the argument that we received. We made the width zero ❺, meaning the
    state will not have a border. You may prefer to have a border, so try out a few
    different values. This argument takes integers, which refer to thickness in number
    of pixels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后开始创建一个`Polyline`并添加数据到它。我们已将不透明度设置为90%，这意味着填充的状态形状将略微透明，足以看到下面的州名。颜色设置为❹为我们接收到的参数。我们将宽度设置为零❺，这意味着州将没有边界。你可能更喜欢有边界，所以尝试几个不同的值。这个参数接受整数，表示像素厚度。
- en: 'Nothing we''ve done so far will actually do anything yet. For that, we need
    to call this function, passing a state boundary array and color. Add this code
    to your map initialization section:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的一切实际上还没有做任何事情。为了做到这一点，我们需要调用这个函数，传递一个状态边界数组和颜色。将以下代码添加到你的地图初始化部分：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you see, this calls the `color_state` function four times, using a different
    point array variable and color each time. To keep this example apolitical, I've
    used shades of green. Feel free to insert your own red (`'ff0000'`) or blue (`'0000ff'`)
    values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这调用了`color_state`函数四次，每次使用不同的点数组变量和颜色。为了保持这个例子不涉及政治，我使用了绿色的不同色调。你可以自由地插入你自己的红色（`'ff0000'`）或蓝色（`'0000ff'`）值。
- en: To be sure every state is within view, I autocentered the map after adding the
    four states. As you can see from [Figure 4-8](ch04s07.html#polygons_of_four_us_states
    "Figure 4-8. Polygons of four US states"), our map looks pretty snazzy. But if
    you zoom in, the borders of each state might not completely touch. That's a precision
    issue, which you may not care about. Its importance depends on how closely you
    expect users to view your borders. For the case of a colored election map, which
    is viewed at country-level, we don't need perfection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每个州都在视野中，我在添加了四个州之后自动居中了地图。正如你在[图4-8](ch04s07.html#polygons_of_four_us_states
    "图4-8. 四个美国州的多边形")中看到的那样，我们的地图看起来相当漂亮。但如果你放大查看，每个州的边界可能不会完全接触。这是一个精度问题，你可能并不关心。它的重要性取决于你期望用户多接近地查看边界。对于查看国家级别的彩色选举地图的情况，我们不需要完美。
- en: Another issue you may notice with creating a state map is that not all states
    are one perfect shape. Hawaii is a series of islands, and Michigan's two pieces
    are separated by a Great Lake. Again, how you handle this depends on how big of
    a deal it is to you. You may be fine connecting the portions so they can be one
    state. Or, you may use multiple polygons to represent these complex states.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会注意到创建州地图时的问题，并不是所有州都是完美的形状。夏威夷是一系列岛屿，密歇根的两个部分被一个大湖分隔。再次强调，您如何处理这取决于这对您有多重要。您可能觉得将部分连接起来以形成一个州是可以接受的。或者，您可能使用多个多边形来表示这些复杂的州。
- en: '#22: Add Custom Controls'
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#22: 添加自定义控制'
- en: Everything we have layered on the map so far has been geo-referenced. In other
    words, when the user drags the map to the side, the thing we've layered also moves.
    In this section, we'll create some interface elements that don't move, but instead
    are anchored to a specific spot in the map window.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在地图上叠加的所有内容都进行了地理参照。换句话说，当用户将地图拖到一边时，我们叠加的内容也会移动。在本节中，我们将创建一些不移动，而是锚定在地图窗口特定位置的用户界面元素。
- en: The controls we'll be creating are similar to map type controls, which are in
    the upper-right corner of the map. In [Add Zoom and Other Controls](ch01s06.html
    "Add Zoom and Other Controls") in [Add Zoom and Other Controls](ch01s06.html "Add
    Zoom and Other Controls"), I showed how to include these (and other) controls.
    Now, we'll be making our own buttons that live in the same spot.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的控制类似于地图类型控制，它们位于地图的右上角。在[添加缩放和其他控制](ch01s06.html "添加缩放和其他控制")中，我展示了如何包含这些（以及其他）控制。现在，我们将制作自己的按钮，它们将位于相同的位置。
- en: For this example, we'll make a button that gives users the option to center
    the map automatically so all the markers and lines are visible. Better yet, we'll
    write the code so you can create any number of these custom controls with a simple
    function call.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将创建一个按钮，用户可以通过它自动将地图居中，以便所有标记和线条都可见。更好的是，我们将编写代码，让您可以通过简单的函数调用创建任意数量的这些自定义控制。
- en: '![Polygons of four US states](httpatomoreillycomsourcenostarchimages672001.png.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![四个美国州的区域](httpatomoreillycomsourcenostarchimages672001.png.jpg)'
- en: Figure 4-8. Polygons of four US states
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-8. 四个美国州的区域
- en: 'Here''s the code for creating a control:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建控制的代码：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function needs two pieces of data in order to create the control and add
    it to the map: It needs the text ❶ that will be written inside the button, and
    it needs the function ❷ that it will call when the button is clicked.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建控制并将其添加到地图中，此函数需要两份数据：它需要写入按钮内的文本❶，以及当按钮被点击时它将调用的函数❷。
- en: With those pieces of information, we can go about creating this control. In
    terms of how the browser interprets it, we are creating a simple `<a>` tag programmatically
    ❸. We give it a class name ❹ so we can style it with CSS. Then we add the label
    to it ❺.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以着手创建这个控制。从浏览器如何解释的角度来看，我们正在程序化地创建一个简单的`<a>`标签❸。我们给它一个类名❹，以便我们可以用CSS来样式化它。然后我们向它添加标签❺。
- en: At this point, the control has been created, but it isn't on the map, nor does
    it do anything. To fix these two issues, we set the function ❻ that will be called
    when the user clicks and then append the object as a child of the map object ❼.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，控制已经创建，但它还没有在地图上，也没有执行任何操作。为了解决这两个问题，我们设置了当用户点击时将被调用的函数❻，然后将对象作为地图对象的子对象❼添加。
- en: 'Now we can style the control. Add these CSS lines to your style sheet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为控制添加样式。将这些CSS行添加到您的样式表中：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This CSS is designed to make our controls look similar to Google's map type
    controls. Only the first two lines (in bold) are necessary to position it in the
    upper-right corner. Everything else is styling.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段CSS旨在使我们的控制看起来与谷歌地图类型控制相似。只有前两行（加粗）是必要的，用于将其定位在右上角。其余的都是样式。
- en: 'All of the hard work is now done, and we''re ready to use our custom control.
    From within the initialization code for our map, add these lines to create an
    autocentering control:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有艰苦的工作现在都完成了，我们准备好使用我们的自定义控制。在我们的地图初始化代码中，添加以下行以创建一个自动居中控制：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code passes the label for our new control (autocenter) and an anonymous,
    inline function reference, which decides what to do when the user clicks the new
    control button. In this case, it fires off the Mapstraction code to show all the
    markers and lines on the map automatically. See [Figure 4-9](ch04s07.html#a_custom_control_looks_like_a_google_con
    "Figure 4-9. A custom control looks like a Google control") for a before and after
    example of clicking the button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码传递了新控制（自动居中）的标签和一个匿名内联函数引用，该函数引用决定了当用户点击新控制按钮时应该执行的操作。在这种情况下，它会自动触发 Mapstraction
    代码以显示地图上的所有标记和线条。请参见[图4-9](ch04s07.html#a_custom_control_looks_like_a_google_con
    "图4-9. 一个自定义控制看起来像Google控制")，了解点击按钮前后的示例。
- en: 'You could do anything you want when the user clicks your custom control button.
    One common choice might be showing only markers of a particular type. I demonstrate
    how to do this in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter Out
    Certain Markers") in [#9: Filter Out Certain Markers](ch02s09.html "#9: Filter
    Out Certain Markers"). With a marker-filled map, you might also create specific
    areas to zoom into, as I do in [#70: Display Recent Earthquakes Worldwide](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide") in [#70: Display Recent Earthquakes
    Worldwide](ch10s03.html "#70: Display Recent Earthquakes Worldwide").'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '当用户点击你的自定义控制按钮时，你可以做任何你想做的事情。一个常见的选择可能是只显示特定类型的标记。我在[第9节：过滤掉某些标记](ch02s09.html
    "#9: Filter Out Certain Markers")中演示了如何做到这一点，[第9节：过滤掉某些标记](ch02s09.html "#9: Filter
    Out Certain Markers")。使用标记填充的地图，你还可以创建特定的区域进行缩放，就像我在[第70节：显示全球最近的地震](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide")中做的那样，[第70节：显示全球最近的地震](ch10s03.html
    "#70: Display Recent Earthquakes Worldwide")。'
- en: '![A custom control looks like a Google control](httpatomoreillycomsourcenostarchimages672003.png.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![一个自定义控制看起来像Google控制](httpatomoreillycomsourcenostarchimages672003.png.jpg)'
- en: Figure 4-9. A custom control looks like a Google control
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-9. 一个自定义控制看起来像Google控制
- en: '#23: Create Your Own Zoom Interface'
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#23: 创建你自己的缩放界面'
- en: When you choose a mapping provider, certain elements of how the map looks cannot
    be easily changed. The zoom interface may be one of these things you've accepted
    as being unchangeable. In this project, I'll show how you can include your own
    zoom in/out buttons to give you even more control over the look of your map.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个地图服务提供商时，地图的外观某些元素无法轻易更改。缩放界面可能是你接受为不可更改的这些元素之一。在这个项目中，我将展示如何包含你自己的缩放按钮，以提供对你地图外观的更多控制。
- en: The approach is similar to the previous project. We'll make a function that
    adds a new object to the page, and we'll position and style it using CSS. Instead
    of a text button, we'll make an image button. And, as before, each new object
    will react to a click.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与上一个项目类似。我们将创建一个函数，它将向页面添加一个新对象，并使用CSS对其进行定位和样式设计。我们将使用图像按钮而不是文本按钮。而且，就像之前一样，每个新对象都会对点击做出反应。
- en: 'First, you need two images: one will be your zooming-in button and the other
    the zooming-out button. You can see the two unassuming graphics I chose in [Figure 4-10](ch04s08.html#two_zoom_graphics_to_be_used_as_custom_c
    "Figure 4-10. Two zoom graphics to be used as custom controls").'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要两个图像：一个将用作放大按钮，另一个将用作缩小按钮。你可以在[图4-10](ch04s08.html#two_zoom_graphics_to_be_used_as_custom_c
    "图4-10. 两个用作自定义控制的缩放图形")中看到我选择的两个不起眼的图形。
- en: '![Two zoom graphics to be used as custom controls](httpatomoreillycomsourcenostarchimages672005.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![两个用作自定义控制的缩放图形](httpatomoreillycomsourcenostarchimages672005.png)'
- en: Figure 4-10. Two zoom graphics to be used as custom controls
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-10. 两个用作自定义控制的缩放图形
- en: 'Here is the generic code for creating an image control:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建图像控制的通用代码：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function needs two pieces of data in order to create the control and add
    it to the map. It needs the image source ❶, which is a path to the image file
    we'll be using for this control. It also needs the function ❷ that it will call
    when the image is clicked.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数需要两份数据才能创建控制并将其添加到地图中。它需要一个图像源❶，这是一个指向我们将用于此控制的图像文件的路径。它还需要一个函数❷，当图像被点击时，它会调用这个函数。
- en: Now we're ready to create this control. We create an image element programmatically
    ❸, just as we did with the `<a>` tag when making a custom control. Then we give
    the image a class name ❹ so we can style it with CSS. Finally we add the image
    URL ❺. This URL can be full or relative to the current page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建这个控制了。我们以编程方式创建一个图像元素❸，就像我们在创建自定义控制时使用`<a>`标签一样。然后我们给图像一个类名❹，这样我们就可以使用CSS对其进行样式设计。最后我们添加图像URL❺。这个URL可以是完整的，也可以相对于当前页面。
- en: At this point, the image is created, but it's neither on the map, nor does it
    do anything. To fix those two issues, we set the function ❻ to be called when
    the user clicks and then append the image object as a child of the map object
    ❼.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，图像已经创建，但它既不在地图上，也没有做任何事情。为了解决这两个问题，我们设置了一个函数 ❻ 在用户点击时被调用，然后将图像对象作为地图对象的子对象
    ❼ 添加。
- en: 'Let''s make sure our new image controls are positioned correctly. Add these
    CSS lines to your style sheet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保我们的新图像控制位置正确。将这些CSS行添加到您的样式表中：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can add our custom zoom controls to the map. From within the initialization
    code for your map, add these lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的自定义缩放控件添加到地图上。在您的地图初始化代码内部，添加以下行：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, I've created two image controls, as shown in [Figure 4-11](ch04s08.html#custom_zoom_images_on_a_map
    "Figure 4-11. Custom zoom images on a map"). The first is for zooming in. The
    CSS will place the control furthest to the right. I send it the name of my image
    ❶, which assumes it is stored in the same directory as the HTML page. Then I pass
    it an anonymous, inline function. Here, I set the zoom level ❷ using Mapstraction,
    passing a number one greater than the current zoom level.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了两个图像控制，如图[图4-11](ch04s08.html#custom_zoom_images_on_a_map "图4-11. 地图上的自定义缩放图像")所示。第一个用于放大。CSS将控制放置在最右边。我发送了我的图像名称
    ❶，这假设它存储在与HTML页面相同的目录中。然后我传递给它一个匿名内联函数。在这里，我使用Mapstraction设置了缩放级别 ❷，传递一个比当前缩放级别大一的数字。
- en: '![Custom zoom images on a map](httpatomoreillycomsourcenostarchimages672007.png.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![地图上的自定义缩放图像](httpatomoreillycomsourcenostarchimages672007.png.jpg)'
- en: Figure 4-11. Custom zoom images on a map
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-11. 地图上的自定义缩放图像
- en: The second image control is similar. It is given a different image, and when
    clicked, it sets the zoom to one *less* than the current zoom level.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图像控制类似。它被赋予了一个不同的图像，当点击时，它将缩放级别设置为当前缩放级别减一 *less*。
- en: '#24: Plot Image Thumbnails on a Map'
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#24: 在地图上绘制图像缩略图'
- en: A picture may not be quite worth a thousand geographic points, but it's close.
    A map is a great way to show photos that have been *geo-tagged*. Geo-tagging is
    associating latitude and longitude coordinates with images. Full-size photos may
    not be ideal, however, as they would take up too much space. Instead, a popular
    method is to display much smaller versions—thumbnails—that the viewer can expand.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一张图片可能不一定值一千个地理点，但它很接近。地图是展示被 *地理标记* 的照片的好方法。地理标记是将纬度和经度坐标与图像关联起来。然而，全尺寸照片可能不是理想的，因为它们会占用太多空间。相反，一种流行的方法是显示更小的版本——缩略图——供观众放大。
- en: Of course, you'll need photos. You can use some that you have as a test or search
    the photo sharing site Flickr. I was able to find some good shots, already geo-tagged,
    by searching for Orlando, Florida. I looked specifically for photos that are licensed
    as Creative Commons, meaning they have less rigid copyright restrictions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要照片。你可以使用一些你有的作为测试，或者搜索照片分享网站Flickr。我通过搜索奥兰多，佛罗里达找到了一些好的照片，它们已经地理标记。我特别寻找那些被许可为Creative
    Commons的照片，这意味着它们有较少的版权限制。
- en: Though we will link to larger versions of each picture, we'll need separate
    files to store the smaller versions. Another plus to using Flickr is that it creates
    these thumbnails and a midsize image, too, automatically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们将链接到每张图片的大版本，但我们还需要单独的文件来存储较小的版本。使用Flickr的另一个优点是它还自动创建这些缩略图和中等尺寸的图像。
- en: 'For each Orlando photo we plot, we''re going to need the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们绘制的每个奥兰多照片，我们需要以下内容：
- en: Photo thumbnail
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片缩略图
- en: Latitude and longitude
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纬度和经度
- en: Medium-sized photo
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等尺寸的相片
- en: Dimensions of medium photo
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等相片的尺寸
- en: Link to full photo
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整照片的链接
- en: At the very least you need the first two items, though you'll create a better
    user experience the more items from this list you can include. If, like me, you're
    using Flickr, then you'll need that link to avoid violating Creative Commons.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 至少你需要前两项，尽管你可以包含列表中的更多项来创建更好的用户体验。如果你像我一样使用Flickr，那么你需要那个链接来避免违反Creative Commons。
- en: 'My three plotted thumbnails are shown on a map in [Figure 4-12](ch04s09.html#thumbnails_overlaid_as_custom_markers_op
    "Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)"). As in other situations where we may be doing one action
    many times, creating a function is best. Add this to your JavaScript code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我的三个缩略图在[图4-12](ch04s09.html#thumbnails_overlaid_as_custom_markers_op "图4-12.
    缩略图作为自定义标记覆盖")中显示在地图上。正如在其他我们可能需要多次执行一个动作的情况中，创建一个函数是最好的。将以下代码添加到您的JavaScript代码中：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As arguments to the function, we need to pass all the items I mentioned in the
    list. Then we create a custom marker using the thumbnail image ❶. Notice that
    I set the dimensions of the marker to be 50×50\. You can use whatever size you
    want, but make sure the image itself is close to that size. Flickr's are 75 pixels
    square, so a little downsizing is okay.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为函数的参数，我们需要传递列表中提到的所有项目。然后我们使用缩略图创建一个自定义标记❶。注意，我将标记的尺寸设置为50×50。你可以使用任何大小，但确保图像本身接近那个大小。Flickr的是75像素的方形，所以稍微缩小是可以的。
- en: Next, we want to set a shadow ❷ or else the default will be used (in Google
    Maps the default is a reverse teardrop, which would look funny underneath a square
    photo). I've created an outline graphic that gives a slight border to the image.
    I set the size to be slightly bigger than the thumbnail itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要设置一个阴影❷，否则将使用默认设置（在Google Maps中，默认是倒泪滴形状，放在方形照片下面看起来会很奇怪）。我创建了一个轮廓图形，给图像添加了一点点边框。我将大小设置为略大于缩略图本身。
- en: Finally, we add a message box. Remember, you can include any HTML inside, so
    we'll link to the full image ❸, as well as display the medium image ❹. To help
    the mapping provider determine how big to make the message box, we include the
    width ❺ and height ❻ of the midsized image.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个消息框。记住，你可以在其中包含任何HTML，所以我们将链接到完整图像❸，并显示中等大小的图像❹。为了帮助地图提供商确定消息框的大小，我们包括中等大小图像的宽度❺和高度❻。
- en: 'Now we''re ready to call the function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好调用该函数：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok Leng Yeo,
    and LancerE)](httpatomoreillycomsourcenostarchimages672009.png.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok Leng Yeo,
    and LancerE)](httpatomoreillycomsourcenostarchimages672009.png.jpg)'
- en: Figure 4-12. Thumbnails overlaid as custom markers (Photos by Ron Miguel, Kok
    Leng Yeo, and LancerE)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-12. 以自定义标记覆盖缩略图（照片由Ron Miguel、Kok Leng Yeo和LancerE拍摄）
- en: This function plots a single photo thumbnail on the map. Click the tiny version
    and it opens a message box showing the midsized version. Then, when you click
    the image, the Flickr link opens.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在地图上绘制单个照片缩略图。点击小版本，它会打开一个显示中等版本的消息框。然后，当你点击图像时，Flickr链接会打开。
- en: 'Now simply call that function two more times—or twenty. You can use the Flickr
    shots from my map as examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需调用该函数两次——或者二十次。你可以使用我的地图中的Flickr照片作为示例：
- en: '[http://www.flickr.com/photos/kamoteus/2421383748/](http://www.flickr.com/photos/kamoteus/2421383748/)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.flickr.com/photos/kamoteus/2421383748/](http://www.flickr.com/photos/kamoteus/2421383748/)'
- en: '[http://www.flickr.com/photos/yeowatzup/461692550/](http://www.flickr.com/photos/yeowatzup/461692550/)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.flickr.com/photos/yeowatzup/461692550/](http://www.flickr.com/photos/yeowatzup/461692550/)'
- en: For a more advanced project, you could automate the process of finding images
    by tapping into the Flickr API to search near a geographic point. The API then
    responds back with XML or JSON, both of which you can parse using the techniques
    shown in [Chapter 8](ch08.html "Chapter 8. DATA FORMATS").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更高级的项目，你可以通过调用Flickr API在地理点附近搜索图像来自动化查找图像的过程。API随后会以XML或JSON格式响应，这两种格式你都可以使用第8章中展示的技术进行解析。
- en: '#25: Overlay an Image on a Map'
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#25：在地图上覆盖图像'
- en: 'You can add an image to a map in a number of ways. In [#5: Create a Custom
    Icon Marker](ch02s05.html "#5: Create a Custom Icon Marker") in [#4: Show and
    Hide Message Boxes Without Clicking the Marker](ch02s04.html "#4: Show and Hide
    Message Boxes Without Clicking the Marker"), you used an image as the icon for
    a Placemark. In this section, we''ll do something a bit different—overlaying an
    image over a larger area of the map, where it will replace or augment the existing
    map.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以用多种方式将图像添加到地图上。在“#5：创建自定义图标标记”（见第2章第5节，[ch02s05.html](ch02s05.html "#5:
    Create a Custom Icon Marker")）和“#4：不点击标记显示和隐藏消息框”（见第2章第4节，[ch02s04.html](ch02s04.html
    "#4: Show and Hide Message Boxes Without Clicking the Marker")）中，你使用图像作为Placemark的图标。在本节中，我们将做一些不同的事情——在地图的更大区域上覆盖图像，它将替换或增强现有地图。'
- en: 'You''re actually familiar with this process, as we used it earlier in this
    chapter, in [#18: Add Circles to Show Search Radius](ch04s03.html "#18: Add Circles
    to Show Search Radius") in [Set the Fill Color and Opacity](ch04s02.html#set_the_fill_color_and_opacity
    "Set the Fill Color and Opacity"). There, we used a circle image and geo-referenced
    it so the image was centered on a point and covered a specific area. That example
    was easier than what we want to do now because a circle is the same distance in
    every direction and it doesn''t matter where it''s pointing.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '你实际上已经熟悉这个过程，因为我们在本章前面已经使用过它，在[第18节：添加圆圈以显示搜索半径](ch04s03.html "#18: 添加圆圈以显示搜索半径")和[设置填充颜色和透明度](ch04s02.html#set_the_fill_color_and_opacity
    "设置填充颜色和透明度")中。在那里，我们使用了一个圆形图像并将其地理参照，使图像以一个点为中心并覆盖特定区域。那个例子比我们现在想要做的要简单，因为圆在各个方向上的距离相同，而且它指向哪里并不重要。'
- en: Consider, for example, the map of New York's Central Park in [Figure 4-13](ch04s10.html#central_park_source_graphic
    "Figure 4-13. Central Park source graphic"). It contains some buildings and landmarks
    that may not be on your standard web map. This map has the park perfectly oriented
    to be running north and south. In reality, the streets that border the long side
    of the park are slightly east of north (and west of south).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下[图4-13](ch04s10.html#central_park_source_graphic "图4-13. 中央公园源图形")中纽约中央公园的地图。它包含了一些可能不在你标准网络地图上的建筑和地标。这张地图将公园完美地定位，使其南北方向延伸。实际上，环绕公园长边街道的位置稍微偏东（相对于北边，相对于南边）。
- en: '![Central Park source graphic](httpatomoreillycomsourcenostarchimages672011.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![中央公园源图形](httpatomoreillycomsourcenostarchimages672011.png.jpg)'
- en: Figure 4-13. Central Park source graphic
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-13. 中央公园源图形
- en: Mapstraction is only able to overlay a graphic if the top of its rectangle is
    at north exactly. To get the Central Park map to match the rest of New York, we
    need to geo-reference it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Mapstraction只能在其矩形顶部正好位于北边时覆盖图形。为了使中央公园地图与纽约的其他部分匹配，我们需要对其进行地理参照。
- en: Geo-Reference Your Map
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地理参照您的地图
- en: At the heart of the geo-referencing technique is the ability to determine the
    latitude and longitude of points on the graphic. Then, using those points, you
    can bend and warp the map so the top and bottom borders of the graphic are static
    latitudes (and the other two static longitudes).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 地理参照技术的核心是确定图形上点的纬度和经度。然后，使用这些点，你可以弯曲和扭曲地图，使图形的顶部和底部边界成为静态纬度（以及另外两个静态经度）。
- en: This process is often called *rubbersheeting*, because you are taking a two-dimensional
    reference, stretching it across a spherical earth, and then unfolding it so it's
    flat again. The result is a warped image, as if it were made of rubber.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程通常被称为*橡皮膜法*，因为你正在将二维参照拉伸到球形地球上，然后将其展开使其再次变平。结果是扭曲的图像，就像它是由橡皮制成的。
- en: You can geo-reference a graphic to a map in a number of ways. Microsoft has
    a program called MapCruncher that works well. In this case, you'll need a Windows
    machine and the resulting graphic can only be used for noncommercial purposes.
    MetaCarta also has a web tool called Map Rectifier.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式将图形与地图进行地理参照。微软有一个名为MapCruncher的程序，效果很好。在这种情况下，你需要一台Windows机器，并且生成的图形只能用于非商业用途。MetaCarta还有一个名为Map
    Rectifier的Web工具。
- en: For this project, I'll be using a web application called Map Warper, which can
    be found at [http://warper.geothings.net/](http://warper.geothings.net/). Map
    Warper was built by Tim Waters and is open source and meant to free you from worries
    over how you can use the end result. You will need to create a free account to
    store your map images. Once you do, click the **Add Map** link to start a new
    map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我将使用一个名为Map Warper的Web应用程序，可以在[http://warper.geothings.net/](http://warper.geothings.net/)找到。Map
    Warper是由Tim Waters开发的，是开源的，旨在让你摆脱对如何使用最终结果的担忧。你需要创建一个免费账户来存储你的地图图像。一旦你创建了账户，点击**添加地图**链接开始创建新地图。
- en: After you provide the name and other metadata to the map, you include a graphic.
    Browse your hard drive for the image you want to use. You can find the Central
    Park graphic that I'm using in this example at [http://mapscripting.com/image-overlay/](http://mapscripting.com/image-overlay/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为地图提供名称和其他元数据后，你可以包含一个图形。浏览你的硬盘以找到你想要使用的图像。你可以在本例中使用的中央公园图形在[http://mapscripting.com/image-overlay/](http://mapscripting.com/image-overlay/)找到。
- en: Click the **Rectify** tab and you'll see your image on the left and a map on
    the right (see [Figure 4-14](ch04s10.html#map_warper_interface "Figure 4-14. Map
    Warper interface")). Move and zoom the map provided until you can see Central
    Park or the area you are geo-referencing. Now you want to add *control points*
    wherever you can identify a spot in the left graphic whose coordinates you can
    determine in the map on the right.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**校正**标签，你会在左边看到你的图像和右边的地图（见[图4-14](ch04s10.html#map_warper_interface "图4-14.
    Map Warper界面"））。移动和缩放提供的地图，直到你可以看到中央公园或你正在地理参考的区域。现在你想要在左边的图形中可以识别出在右边的地图上可以确定坐标的任何位置添加**控制点**。
- en: '![Map Warper interface](httpatomoreillycomsourcenostarchimages672013.png.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Map Warper界面](httpatomoreillycomsourcenostarchimages672013.png.jpg)'
- en: Figure 4-14. Map Warper interface
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-14. Map Warper界面
- en: For example, I chose my first point at Columbus Circle in the lower left of
    the Central Park graphic. Once I can see Columbus Circle on both screens, I click
    the marker button (see the circle in [Figure 4-14](ch04s10.html#map_warper_interface
    "Figure 4-14. Map Warper interface")) and the spot on the left. Then I click the
    same spot on the right side. Finally, I click the **Add Control Point** button
    and the marker changes so the number 1 appears inside it, as shown in [Figure 4-15](ch04s10.html#first_control_point_for_geo-referencing
    "Figure 4-15. First control point for geo-referencing").
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在中央公园图形的左下角选择了我的第一个点，在哥伦布圆环处。一旦我能在两个屏幕上看到哥伦布圆环，我就点击标记按钮（见[图4-14](ch04s10.html#map_warper_interface
    "图4-14. Map Warper界面"）中的圆圈）和左边的点。然后我在右边点击相同的点。最后，我点击**添加控制点**按钮，标记改变，数字1出现在其中，如图[图4-15](ch04s10.html#first_control_point_for_geo-referencing
    "图4-15. 地理参考的第一个控制点")所示。
- en: '![First control point for geo-referencing](httpatomoreillycomsourcenostarchimages672015.png.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![地理参考的第一个控制点](httpatomoreillycomsourcenostarchimages672015.png.jpg)'
- en: Figure 4-15. First control point for geo-referencing
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-15. 地理参考的第一个控制点
- en: To find additional points that are off the screen, remember to switch from the
    marker to the hand, which will allow you to move the image again. You'll need
    to do the same thing with the map on the right. Continue this process until you
    have a handful of points. Map Warper suggests at least three points, but I've
    found it often takes more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到屏幕外的额外点，请记住从标记器切换到手，这样你就可以再次移动图像。你还需要用右边的地图做同样的事情。继续这个过程，直到你有一把点的数量。Map Warper建议至少三个点，但我发现通常需要更多。
- en: The Central Park example is easier than some, as New York City has a nice set
    of grid streets to use as references. [Figure 4-16](ch04s10.html#more_control_points_produces_a_better_re
    "Figure 4-16. More control points produces a better rectified map") shows the
    seven points I chose for this example. When you are finished adding control points,
    scroll to the bottom and click **Warp Image**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 中央公园的例子比一些例子更容易，因为纽约市有一套很好的网格街道可以作为参考。[图4-16](ch04s10.html#more_control_points_produces_a_better_re
    "图4-16. 更多控制点产生更好的校正地图")显示了我在这个例子中选择的七个点。当你完成添加控制点后，滚动到底部并点击**扭曲图像**。
- en: '![More control points produces a better rectified map](httpatomoreillycomsourcenostarchimages672017.png.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![更多控制点产生更好的校正地图](httpatomoreillycomsourcenostarchimages672017.png.jpg)'
- en: Figure 4-16. More control points produces a better rectified map
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-16. 更多控制点产生更好的校正地图
- en: The system will whirl and whiz for a bit. When it responds that the map has
    been rectified, you can scroll back to the top and click the **Preview Rectified**
    tab. A map with your image warped and overlaid on top will appear, as shown in
    [Figure 4-17](ch04s10.html#preview_of_geo-referenced_central_park_m "Figure 4-17. Preview
    of geo-referenced Central Park map"). You can move the slider at the bottom to
    change your image's opacity. Moving the marker all the way to the right makes
    the image completely opaque, meaning it completely covers the original map.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会旋转和嗡嗡作响一段时间。当它响应地图已经被校正时，你可以滚动到顶部并点击**预览校正**标签。一个带有你的图像扭曲并叠加在上面的地图将出现，如图[图4-17](ch04s10.html#preview_of_geo-referenced_central_park_m
    "图4-17. 地理参考的中央公园地图预览")所示。你可以移动底部的滑块来改变图像的不透明度。将标记完全移到右边会使图像完全不透明，这意味着它完全覆盖了原始地图。
- en: '![Preview of geo-referenced Central Park map](httpatomoreillycomsourcenostarchimages672019.png.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![地理参考的中央公园地图预览](httpatomoreillycomsourcenostarchimages672019.png.jpg)'
- en: Figure 4-17. Preview of geo-referenced Central Park map
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-17. 地理参考的中央公园地图预览
- en: Move the slider back and forth to determine how well your image matches the
    source map. If you aren't satisfied with the results, click the **Rectify** tab
    and add a few more points.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动滑块来确定你的图像与源地图的匹配程度。如果你对结果不满意，点击**Rectify**标签并添加几个更多点。
- en: Apply Warped Map
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用扭曲地图
- en: When you're happy with the result of your warped image, click the **Export**
    link to download the image to use it in your own project. You'll want to get the
    PNG-formatted version. [Figure 4-18](ch04s10.html#central_park_image_comma_warped_from_geo
    "Figure 4-18. Central Park image, warped from geo-referencing") shows how different
    my Central Park graphic is now that it has been geo-referenced.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对扭曲图像的结果满意时，点击**Export**链接下载图像以用于你自己的项目。你想要的是PNG格式的版本。[图4-18](ch04s10.html#central_park_image_comma_warped_from_geo
    "图4-18. 从地理参考扭曲的中央公园图像")显示了经过地理参考后我的中央公园图形现在看起来有多不同。
- en: '![Central Park image, warped from geo-referencing](httpatomoreillycomsourcenostarchimages672021.png.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![从地理参考扭曲的中央公园图像](httpatomoreillycomsourcenostarchimages672021.png.jpg)'
- en: Figure 4-18. Central Park image, warped from geo-referencing
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-18. 从地理参考扭曲的中央公园图像
- en: 'In order to overlay the warped image on your map using Mapstraction, you need
    to know the boundaries of the image rectangle. To find this information within
    Map Warper, click the **Activity** tab, where you''ll see a table showing the
    timeline of your geo-referencing session. The topmost item is likely Map Successfully
    Rectified. Click the **Further Details** link for that row and you''ll see more
    details, including a box with a list of four decimal numbers. Highlight and copy
    these, which should already be in order: west, north, east, and south.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Mapstraction在地图上叠加扭曲的图像，你需要知道图像矩形的边界。要在Map Warper中找到这些信息，请点击**Activity**标签，在那里你会看到一个显示地理参考会话时间线的表格。最上面的条目可能是Map
    Successfully Rectified。点击该行的**Further Details**链接，你会看到更多详细信息，包括一个包含四个十进制数字的框。突出显示并复制这些数字，它们应该已经按顺序排列：西、北、东、南。
- en: 'Now you can add the overlay code to your Mapstraction map:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将叠加代码添加到你的Mapstraction地图中：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In order to add our warped image to the map, we need to give it an identifier
    ❶. We let Mapstraction know the path to the warped image ❷ (here, I've assumed
    the image is in the same directory as the HTML file). Then, we give an opacity
    percentage ❸ between 0 (invisible) and 100 (hidden—no map can be seen under the
    image). Finally, we add the four numbers from Map Warper ❹ that describe the geographic
    box where the image will reside.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的扭曲图像添加到地图中，我们需要给它一个标识符 ❶。我们让Mapstraction知道扭曲图像的路径 ❷（这里，我假设图像与HTML文件在同一个目录中）。然后，我们给出一个介于0（不可见）和100（隐藏——图像下无法看到地图）之间的不透明度百分比
    ❸。最后，我们添加Map Warper ❹中的四个数字，这些数字描述了图像将驻留的地理框。
- en: '[Figure 4-19](ch04s10.html#central_park_geo-referenced_image_overla "Figure 4-19. Central
    Park geo-referenced image overlay on a Google Map") shows the finished map, with
    the Central Park graphic completely obscuring the Google Map under it.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-19](ch04s10.html#central_park_geo-referenced_image_overla "图4-19. 在谷歌地图上叠加的中央公园地理参考图像")显示了完成的地图，中央公园的图形完全遮挡了其下的谷歌地图。'
- en: '![Central Park geo-referenced image overlay on a Google Map](httpatomoreillycomsourcenostarchimages672023.png.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![在谷歌地图上叠加的中央公园地理参考图像](httpatomoreillycomsourcenostarchimages672023.png.jpg)'
- en: Figure 4-19. Central Park geo-referenced image overlay on a Google Map
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-19. 在谷歌地图上叠加的中央公园地理参考图像
- en: You can use your own map imagery over larger areas as well. Storing an entire
    city or more of data in a single image won't work very well, however. Instead,
    see the next project, which shows how to create your own imagery to display a
    little bit at a time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在更大的区域内使用你自己的地图图像。然而，将整个城市或更多的数据存储在单个图像中效果不会很好。相反，请看下一个项目，它展示了如何一次显示一点来创建自己的图像。
- en: '#26: Use Custom Tiles'
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '#26: 使用自定义瓦片'
- en: Most providers allow you to choose from a handful of imagery types for your
    maps. You can show satellite view, road maps, or a hybrid version. You're not
    the cookie-cutter type though, are you? You like the glitz and glamour of choosing
    your own shade of green for parks or your own thickness for roads. To do this,
    you'll need custom tiles. And what better place for your glitz and glamour than
    the Las Vegas strip?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供商允许你为你的地图选择几种图像类型。你可以显示卫星视图、道路地图或混合版本。但你不是那种千篇一律的类型，对吧？你喜欢选择自己公园的绿色或自己道路的厚度。为此，你需要自定义瓦片。而且，哪里比拉斯维加斯大道更适合你的光彩和华丽呢？
- en: To create Vegas tiles, we'll need the data about streets and other features.
    Although mapping providers are liberal in what they allow you to do with their
    APIs, most hold the underlying data like a poker player does his or her cards.
    One that makes its data widely available is OpenStreetMap, the free editable map
    of the world. Of course, distributing the details of every street on earth means
    the file is pretty big, so region-specific downloads are also available. In this
    project, for example, we'll just use the data for Nevada, the state where Las
    Vegas is located.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建拉斯维加斯的瓦片，我们需要有关街道和其他特性的数据。尽管地图提供者在他们的 API 中允许你做的事情很宽松，但大多数像扑克玩家对待他们的牌一样对待底层数据。一个使其数据广泛可用的例子是
    OpenStreetMap，这是世界上免费的可编辑地图。当然，分发地球上每条街道的详细信息意味着文件相当大，因此也提供了特定区域的下载。在这个项目中，例如，我们只需使用内华达州的数据，拉斯维加斯就位于这个州。
- en: To create the tiles, we'll plug the data into an open source program called
    Mapnik. Because Mapnik can be a bit complicated to install and configure, we'll
    take advantage of another project called Tile Drawer, which provides an Amazon
    EC2 machine image to do much of the technical work. First, let's get a feel for
    how tiles are used by mapping providers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建瓦片，我们将数据输入到一个名为 Mapnik 的开源程序中。由于 Mapnik 的安装和配置可能有点复杂，我们将利用另一个名为 Tile Drawer
    的项目，它提供了一个 Amazon EC2 机器镜像来执行大部分技术工作。首先，让我们了解一下地图提供者如何使用瓦片。
- en: How Many Pixels Wide Is the Earth?
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地球有多宽的像素？
- en: As described in [Chapter 1](ch01.html "Chapter 1. MAPPING BASICS"), a map is
    made up of tiles arranged to appear as one large image. Each tile is 256 pixels
    square and organized as a grid. Most providers reference the grid left to right
    and north to south, beginning in the Arctic Ocean above Alaska. Tiles are referenced
    by their number in the grid, such as `(14, 34)`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](ch01.html "第 1 章. 地图基础") 所述，地图由排列成一个大图像的瓦片组成。每个瓦片是 256 像素的正方形，并组织成网格。大多数提供者从左到右和从北到南参考网格，从阿拉斯加上面的北极洋开始。瓦片通过其在网格中的编号进行引用，例如
    `(14, 34)`。
- en: The number of tiles required to display the entire earth depends on the zoom
    level. For example, at its most zoomed out, which is zoom level 0 in Mapstraction,
    the earth can be shown on a single tile. Each time you zoom in, it takes four
    tiles to show the detail that was previously displayed on one tile. You can find
    the number of tiles used in each direction by determining 2 to the *zoom level*
    power (2*zoom level*). [Table 4-1](ch04s11.html#tiles_and_pixels_at_each_zoom_level
    "Table 4-1. Tiles and Pixels at Each Zoom Level") shows tile and pixel information
    at each zoom level.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 显示整个地球所需的瓦片数量取决于缩放级别。例如，在 Mapstraction 中的最缩放级别 0，地球可以显示在一个单独的瓦片上。每次放大，需要四个瓦片来显示之前在一个瓦片上显示的细节。你可以通过确定
    2 的 *缩放级别* 次方（2^缩放级别）来找到每个方向上使用的瓦片数量。[表 4-1](ch04s11.html#tiles_and_pixels_at_each_zoom_level
    "表 4-1. 每个缩放级别的瓦片和像素")显示了每个缩放级别的瓦片和像素信息。
- en: 'When a mapping provider loads map tiles, it uses three numbers: the zoom level,
    the number of tiles from the left, and the number of tiles from the top. All of
    these numbers begin at zero, so the upper left of the map at every zoom level
    is `(0, 0)`. The upper right at level 6, for example, is `(16383, 0)`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当地图提供者加载地图瓦片时，它使用三个数字：缩放级别、从左侧的瓦片数量和从顶部的瓦片数量。所有这些数字都是从零开始的，因此每个缩放级别地图的左上角是 `(0,
    0)`。例如，在级别 6 的右上角是 `(16383, 0)`。
- en: Table 4-1. Tiles and Pixels at Each Zoom Level
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. 每个缩放级别的瓦片和像素
- en: '| Zoom level | Tiles wide/tall | Pixels wide/tall |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 缩放级别 | 宽/高瓦片 | 宽/高像素 |'
- en: '| --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 1 | 256 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 256 |'
- en: '| 1 | 2 | 512 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 512 |'
- en: '| 2 | 4 | 1,024 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 4 | 1,024 |'
- en: '| 3 | 8 | 2,048 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 8 | 2,048 |'
- en: '| 4 | 16 | 4,096 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 | 4,096 |'
- en: '| 5 | 32 | 8,192 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32 | 8,192 |'
- en: '| 6 | 64 | 16,384 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 64 | 16,384 |'
- en: '| 7 | 128 | 32,768 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 128 | 32,768 |'
- en: '| 8 | 256 | 65,536 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 | 65,536 |'
- en: '| 9 | 512 | 131,072 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 512 | 131,072 |'
- en: '| 10 | 1,024 | 262,144 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1,024 | 262,144 |'
- en: '| 11 | 2,048 | 524,288 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 2,048 | 524,288 |'
- en: '| 12 | 4,096 | 1,048,576 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 | 1,048,576 |'
- en: '| 13 | 8,192 | 2,097,152 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 8,192 | 2,097,152 |'
- en: '| 14 | 16,384 | 4,194,304 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 16,384 | 4,194,304 |'
- en: '| 15 | 32,768 | 8,388,608 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 32,768 | 8,388,608 |'
- en: '| 16 | 65,536 | 16,777,216 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 | 16,777,216 |'
- en: '| 17 | 131,072 | 33,554,432 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 131,072 | 33,554,432 |'
- en: '| 18 | 262,144 | 67,108,864 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 262,144 | 67,108,864 |'
- en: Thankfully, you don't need to reference the tiles by their grid location. The
    mapping provider does all this for you. Understanding how it works is important
    because you'll need to use this knowledge to create custom tile URLs later in
    this project.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不需要通过瓦片的网格位置来引用它们。映射提供商为您完成所有这些。了解它是如何工作的重要，因为您需要使用这些知识在项目后期创建自定义瓦片URL。
- en: As for the question at the top of this section—how many pixels wide is the earth?
    It depends on the zoom level, but for most providers, the earth is between 256
    and 67,108,864 pixels wide.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本节顶部的疑问——地球的宽度是多少像素？这取决于缩放级别，但对于大多数提供商来说，地球的宽度在256到67,108,864像素之间。
- en: Start a Tile Drawer EC2 Instance
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Tile Drawer EC2实例
- en: Tile Drawer helps you create your own custom map tiles and runs a tile server
    in the cloud. It runs on top of Amazon EC2, which is an *elastic compute cloud*,
    that is, an expandable web server. Another feature of EC2 is the ability to save
    preconfigured servers, Amazon Machine Images (AMIs), and make them available to
    others. That's what the creators of Tile Drawer have done. Handy!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Tile Drawer可以帮助您创建自己的自定义地图瓦片，并在云中运行瓦片服务器。它运行在Amazon EC2之上，即一个**弹性计算云**，也就是说，一个可扩展的Web服务器。EC2的另一个特点是能够保存预配置的服务器、亚马逊机器镜像（AMIs），并使它们可供他人使用。这就是Tile
    Drawer的创造者所做的事情。方便！
- en: 'You will need an Amazon account (be prepared to provide your email address
    and a few other bits of information) and then sign up for EC2\. Amazon charges
    for this service, but does so for cents per hour, so you''ll be able to try this
    project for less than a dollar. This page will walk you through the signup process:
    [http://aws.amazon.com/ec2/](http://aws.amazon.com/ec2/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个亚马逊账户（准备好提供您的电子邮件地址和一些其他信息），然后注册EC2。亚马逊为此服务收费，但按每小时几分钱收费，所以您可以用不到一美元的价格尝试这个项目。此页面将指导您完成注册过程：[http://aws.amazon.com/ec2/](http://aws.amazon.com/ec2/)。
- en: Log in to the AWS Management Console from this page. Click the **Launch Instance**
    button. Then search the Community AMIs for the Tile Drawer machine image. Look
    for *tiledrawer*, or find the ID, such as `ami-e1ea0a88`, listed on [http://tiledrawer.com/](http://tiledrawer.com/).
    When you find the Tile Drawer AMI, click the **Select** button.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从此页面登录AWS管理控制台。点击**启动实例**按钮。然后在社区AMIs中搜索Tile Drawer机器镜像。寻找*tiledrawer*，或者找到在[http://tiledrawer.com/](http://tiledrawer.com/)上列出的ID，例如`ami-e1ea0a88`。当您找到Tile
    Drawer AMI时，点击**选择**按钮。
- en: On the Instance Details screen, only create one instance, as shown in [Figure 4-20](ch04s11.html#create_a_single_amazon_ec2_tile_drawer_i
    "Figure 4-20. Create a single Amazon EC2 Tile Drawer instance"). Because you'll
    be using a very small area to start, you can get away with a small instance type.
    Click the **Continue** button, and then on the next screen, you mostly leave the
    default settings in place. You'll need to add some user data, however.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例详细信息屏幕上，只创建一个实例，如图[图4-20](ch04s11.html#create_a_single_amazon_ec2_tile_drawer_i
    "图4-20. 创建单个Amazon EC2 Tile Drawer实例")所示。因为您将使用一个非常小的区域开始，所以可以使用小型实例类型。点击**继续**按钮，然后在下一屏幕上，您大部分保持默认设置不变。但是，您需要添加一些用户数据。
- en: '![Create a single Amazon EC2 Tile Drawer instance](httpatomoreillycomsourcenostarchimages672025.png.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![创建单个Amazon EC2 Tile Drawer实例](httpatomoreillycomsourcenostarchimages672025.png.jpg)'
- en: Figure 4-20. Create a single Amazon EC2 Tile Drawer instance
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-20. 创建单个Amazon EC2 Tile Drawer实例
- en: Declare User Data for Your Instance
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的实例声明用户数据
- en: The Tile Drawer server is fairly plug and play. Just a few settings are necessary
    to make it run. As you'll see later, these settings also allow you to fully customize
    your map tiles.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Tile Drawer服务器相当容易安装。只需设置几个设置即可使其运行。您稍后会发现，这些设置还允许您完全自定义您的地图瓦片。
- en: 'You can use the wizard on [http://tiledrawer.com/](http://tiledrawer.com/)
    to help you create the user data automatically. Or to continue following along
    with this example, paste the following data in the User Data box on the EC2 setup
    page (see [Figure 4-21](ch04s11.html#adding_user_data_to_the_ec2_instance "Figure 4-21. Adding
    user data to the EC2 instance")):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[http://tiledrawer.com/](http://tiledrawer.com/)上的向导来帮助您自动创建用户数据。或者，为了继续跟随这个示例，将以下数据粘贴到EC2设置页面上的用户数据框中（见图[图4-21](ch04s11.html#adding_user_data_to_the_ec2_instance
    "图4-21. 向EC2实例添加用户数据"))：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This data has four preferences. First, the style of the map, which uses a CSS-like
    style sheet. We'll stick with the basic look from Tile Drawer for this first example
    and make changes later. Next, we declare a `BoundingBox`, similar to those we've
    used with Mapstraction. The difference here is that longitudes are listed before
    latitudes. The two points we use are still southwest followed by northeast.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据有四个偏好设置。首先，地图的样式，它使用类似 CSS 的样式表。在这个第一个例子中，我们将坚持使用瓦片抽屉的基本外观，稍后再进行更改。接下来，我们声明一个`BoundingBox`，类似于我们与
    Mapstraction 一起使用的那些。这里的区别在于经度在纬度之前列出。我们使用的两个点仍然是西南，然后是东北。
- en: The last two items are URLs to files that Tile Drawer will download and use.
    The first is the data itself. We're using the data for Nevada, which is hosted
    by CloudMade. You can find the data you need at [http://downloads.cloudmade.com/](http://downloads.cloudmade.com/).
    Look for files of type *.osm.bz2*. The final URL is the coastline data, which
    is hosted separately.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两项是 Tile Drawer 将下载并使用的文件的 URL。第一个是数据本身。我们使用内华达州的数据，由 CloudMade 托管。您可以在 [http://downloads.cloudmade.com/](http://downloads.cloudmade.com/)
    找到您需要的数据。寻找类型为 *.osm.bz2* 的文件。最后一个 URL 是海岸线数据，它被单独托管。
- en: '![Adding user data to the EC2 instance](httpatomoreillycomsourcenostarchimages672027.png.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![向 EC2 实例添加用户数据](httpatomoreillycomsourcenostarchimages672027.png.jpg)'
- en: Figure 4-21. Adding user data to the EC2 instance
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-21. 向 EC2 实例添加用户数据
- en: With the user data set, click **Continue** again. The next screen will prompt
    you to create a key pair. The key pair enables you to connect to the server's
    backend. This advanced feature may be useful at some point in the future. For
    now, select **Proceed without a Key Pair**, and click **Continue**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了用户数据后，再次点击**继续**。下一屏幕将提示您创建密钥对。密钥对使您能够连接到服务器的后端。这个高级功能可能在未来的某个时刻有用。现在，选择**不使用密钥对继续**，然后点击**继续**。
- en: On the firewall screen, make sure you select the webserver security group. This
    group opens up the appropriate ports for running a web server, which is necessary
    for accessing your tiles from any computer, including your own. Click **Continue**
    and you'll be on the final screen. Take a deep breath and then click **Launch**.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在防火墙屏幕上，请确保您选择了 web 服务器安全组。此组打开运行 web 服务器所需的适当端口，这对于从任何计算机访问您的瓦片，包括您自己的计算机，是必要的。点击**继续**，您将进入最终屏幕。深吸一口气，然后点击**启动**。
- en: Tile Drawer Does Its Job
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓦片抽屉完成其工作
- en: Your EC2 instance will not instantly start up. Although it's a virtual computer,
    it still takes a few minutes to boot. Once it is available, creating all the tiles
    will take some additional time. This is a great time for a break!
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 EC2 实例不会立即启动。尽管它是一台虚拟计算机，但启动仍然需要几分钟。一旦可用，创建所有瓦片将需要额外的时间。这是一个休息的好时机！
- en: But you shouldn't need *too* long of a break. With only one state of data to
    download and a small area to prepare, Tile Drawer should be ready in less than
    15 minutes. From your EC2 dashboard, you should be able to click the **Running
    Instances** link under My Resources. From there, you can see the status of your
    new instance. When the server has booted up, it should switch from yellow and
    pending to green and running.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但您不应该需要**太长**的休息时间。由于只需下载一个状态的数据并准备一个小区域，瓦片抽屉应在 15 分钟内准备好。从您的 EC2 仪表板，您应该能够点击“我的资源”下的**运行实例**链接。从那里，您可以查看您的新实例的状态。当服务器启动后，它应该从黄色和挂起切换到绿色和运行。
- en: When the server is running, click your instance and a description will appear
    in the pane below. Scroll down and locate the Public DNS address, as shown in
    [Figure 4-22](ch04s11.html#instance_details_shows_your_public_dns_a "Figure 4-22. Instance
    details shows your Public DNS address."). This address is the equivalent of a
    domain name for your new virtual server. Enter that address in your web browser
    and you should see a page that says, "It works!"
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器运行时，点击您的实例，下面面板中会出现一个描述。向下滚动并找到公共 DNS 地址，如图 [图 4-22](ch04s11.html#instance_details_shows_your_public_dns_a
    "图 4-22. 实例详情显示您的公共 DNS 地址。") 所示。此地址是您新虚拟服务器的域名等效物。在您的网页浏览器中输入该地址，您应该会看到一个显示“它工作！”的页面。
- en: '![Instance details shows your Public DNS address.](httpatomoreillycomsourcenostarchimages672029.png.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![实例详情显示您的公共 DNS 地址。](httpatomoreillycomsourcenostarchimages672029.png.jpg)'
- en: Figure 4-22. Instance details shows your Public DNS address.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-22. 实例详情显示您的公共 DNS 地址。
- en: 'Next, add */status.php* to the end of your address to get Tile Drawer''s status.
    Tile Drawer goes through to create tiles: Getting Started, Downloading Source,
    Extracting Data, Creating Tables, Importing Coastline, Downloading Stylesheet,
    and Creating TileCache. As it completes each step, it will become grayed out,
    as shown in [Figure 4-23](ch04s11.html#tile_drawer_apostrophy_s_status_updates
    "Figure 4-23. Tile Drawer''s status updates as each section finishes."). When
    Tile Dawer is done, you can click the link or go to your address followed by */preview.php*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将*/status.php*添加到您的地址末尾以获取Tile Drawer的状态。Tile Drawer会创建瓦片：入门，下载源，提取数据，创建表格，导入海岸线，下载样式表，以及创建TileCache。随着每个步骤的完成，它将变为灰色，如图[图4-23](ch04s11.html#tile_drawer_apostrophy_s_status_updates
    "图4-23. Tile Drawer的每个部分完成时的状态更新")所示。当Tile Dawer完成时，您可以点击链接或转到您的地址后跟*/preview.php*。
- en: '![Tile Drawer''s status updates as each section finishes.](httpatomoreillycomsourcenostarchimages672031.png.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Tile Drawer的每个部分完成时的状态更新](httpatomoreillycomsourcenostarchimages672031.png.jpg)'
- en: Figure 4-23. Tile Drawer's status updates as each section finishes.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-23. Tile Drawer的每个部分完成时的状态更新。
- en: You'll see a quick preview of your new tiles on the Tile Drawer server. You
    can double-click to zoom in. If everything looks good, the time has come to put
    those tiles on a Mapstraction map.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在Tile Drawer服务器上看到您新瓦片的快速预览。您可以双击以放大。如果一切看起来都很好，那么是时候将这些瓦片放到Mapstraction地图上了。
- en: Add Tile Overlays to Your Map
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将瓦片叠加到您的地图上
- en: The process of including your tiles in Mapstraction is as easy as a single line
    of code. The hard work is behind you with setting up the tile server—and also
    ahead of you in creating the styles, which can be a tedious.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的瓦片包含到Mapstraction中的过程就像一行代码一样简单。设置瓦片服务器的工作已经完成——在创建样式方面，您的工作还在前方，这可能是一项繁琐的任务。
- en: 'Create a new basic map using the following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个新的基本地图：
- en: '[PRE25]*`yourserver`*[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]*`yourserver`*[PRE26]'
- en: Here we have created a map centered on the Las Vegas strip. Then, in the line
    in bold, we tell Mapstraction where to find our tiles. Our URL contains placeholders
    for zoom level ❶ and the tile grid coordinates. These values, `{Z}`, `{X}`, and
    `{Y}`, are filled in with actual numbers. You can see an example tile by going
    to *yourserver.amazonaws.com/tilecache/1.0.0/osm/13/1475/3213.png*. Be sure to
    replace *yourserver* with the Public DNS address of your EC2 instance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个以拉斯维加斯大道为中心的地图。然后，在加粗的行中，我们告诉Mapstraction在哪里找到我们的瓦片。我们的URL包含用于缩放级别❶和瓦片网格坐标的占位符。这些值，`{Z}`、`{X}`和`{Y}`，用实际数字填充。您可以通过访问*yourserver.amazonaws.com/tilecache/1.0.0/osm/13/1475/3213.png*来查看一个示例瓦片。请确保用您的EC2实例的公共DNS地址替换*yourserver*。
- en: 'The second argument that we pass to Mapstraction''s tile layer function is
    an opacity. Like in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map") in [#25: Overlay an Image on a Map](ch04s10.html "#25: Overlay
    an Image on a Map"), we can make our tiles semitransparent so we can still see
    some of the provider imagery underneath. Here I made our tiles completely opaque
    ❷ by choosing a value of one. A number between zero and one sets the percentage.
    For example, 0.6 would be 60 percent opaque.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '我们传递给Mapstraction的瓦片层函数的第二个参数是透明度。就像在[第25节：在地图上叠加图像](ch04s10.html "#25: Overlay
    an Image on a Map")中一样，我们可以使我们的瓦片半透明，这样我们仍然可以看到下面的提供者图像。在这里，我通过选择值为一来使我们的瓦片完全不透明❷。介于零和一之间的数字设置百分比。例如，0.6将是60%不透明。'
- en: Save your map and load it in a browser. You should now see your custom Las Vegas
    tiles instead of the Google imagery, like in [Figure 4-24](ch04s11.html#custom_tiles_using_tile_drawer_apostroph
    "Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet"). You may
    catch a glimpse of the default look before your tiles load. That's because the
    custom tiles are being placed on top of Google, so both sets still need to load.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您的地图并在浏览器中加载。现在您应该看到定制的拉斯维加斯瓦片而不是谷歌图像，如图[图4-24](ch04s11.html#custom_tiles_using_tile_drawer_apostroph
    "图4-24. 使用Tile Drawer的" scratch"样式表定制的瓦片")所示。在您的瓦片加载之前，您可能会看到默认的外观。这是因为定制的瓦片被放置在谷歌图像之上，所以这两组都需要加载。
- en: '![Custom tiles using Tile Drawer''s "scratch" style sheet](httpatomoreillycomsourcenostarchimages672033.png.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![使用Tile Drawer的" scratch"样式表定制的瓦片](httpatomoreillycomsourcenostarchimages672033.png.jpg)'
- en: Figure 4-24. Custom tiles using Tile Drawer's "scratch" style sheet
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-24. 使用Tile Drawer的" scratch"样式表定制的瓦片
- en: Create Your Own Tile Styles
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您自己的瓦片样式
- en: If you are familiar with CSS for styling web pages, you will likely feel comfortable
    with the way Tile Drawer applies colors and other styles to maps. It uses Cascadenik
    to convert into the file format necessary to work with the Mapnik tile generator.
    Earlier in this project, we used a basic example provided by Tile Drawer. Now
    we'll try changing a few of the colors and road widths.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉用于网页样式的CSS，您可能会对Tile Drawer应用颜色和其他样式到地图的方式感到舒适。它使用Cascadenik将其转换为与Mapnik瓦片生成器一起工作的文件格式。在本项目的早期，我们使用了Tile
    Drawer提供的基本示例。现在我们将尝试更改一些颜色和道路宽度。
- en: The first thing you'll need is to copy [http://tiledrawer.com/mapscratch.mml](http://tiledrawer.com/mapscratch.mml)
    to your own server. Or you can use the version I have edited for this section
    at [http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml](http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先需要做的是将[http://tiledrawer.com/mapscratch.mml](http://tiledrawer.com/mapscratch.mml)复制到您自己的服务器上。或者，您可以使用我为本节编辑的版本，在[http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml](http://mapscripting.com/examples/tiledrawer/mapscratch-edits.mml)。
- en: 'Because Vegas is famous for its neon lights, let''s aim to make the roads pop
    out from the map. To do this, we''ll use bright colors and a dark background.
    Find the line that begins with `#land` and change it, using this styling data:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于拉斯维加斯以其霓虹灯而闻名，让我们尝试使道路从地图中突出出来。为此，我们将使用鲜艳的颜色和深色背景。找到以`#land`开头的行，并使用以下样式数据进行更改：
- en: '[PRE27]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This data changes the land, which is essentially the background color, from
    a very light color to nearly black. Black is very Vegas, especially when we include
    the bright colors. For these next changes, you''ll need to use the styles that
    begin with the `#lines`. Be sure your code matches these settings:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这组数据将土地（基本上是背景颜色）从非常浅的颜色变为接近黑色。黑色非常符合拉斯维加斯的风格，尤其是当我们包括鲜艳的颜色时。对于接下来的更改，您需要使用以`#lines`开头的样式。确保您的代码与这些设置匹配：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cascadenik style sheets use OpenStreetMap tags inside the square brackets to
    determine which elements you want to style. In all these examples, we're styling
    highways, a generic term for any road. In the first set, we apply the styles only
    to motorways ❶ and motorway "links" (such as off-ramps). Since everything is bigger
    and brighter in Vegas, we make the motorways wider ❷ and then color them a bright
    red ❸.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Cascadenik样式表使用方括号内的OpenStreetMap标签来确定您想要样式的元素。在所有这些示例中，我们正在样式化高速公路，这是一个任何道路的通用术语。在第一组中，我们只将样式应用于高速公路❶和高速公路“链接”（例如出口）。由于拉斯维加斯的一切都更大更亮，所以我们使高速公路更宽❷，然后将其染成鲜艳的红色❸。
- en: In the next two sections, we set the larger streets to be yellow ❹. Residential
    and other small streets are set to blue ❺. As the streets get smaller, so do their
    widths on the map. Seeing as we're doing this Vegas-style, however, they're still
    larger than the styles we're editing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将较大街道设置为黄色❹。住宅和其他小街道设置为蓝色❺。随着街道变窄，地图上的街道宽度也相应变窄。然而，由于我们正在以拉斯维加斯风格进行，因此它们仍然比我们正在编辑的样式要宽。
- en: 'You can do some powerful things with these styles to make your maps look unlike
    any imagery available. As one example of how specific you can get with styles,
    try adding these lines to your style sheet:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些样式做一些强大的事情，使您的地图看起来与任何可用的图像都不同。作为样式如何具体的一个例子，尝试将以下行添加到您的样式表中：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At first glance, this code is similar to some we've already done. Pay attention
    to the bolded section; it tells the tile server to only apply this style when
    the zoom level is 13\. At all other zoom levels, our other styles will take precedence.
    But when our map is at level 13, the motorways will be orange instead of red.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，这段代码与我们之前做的一些代码类似。请注意加粗的部分；它告诉瓦片服务器仅在缩放级别为13时应用此样式。在所有其他缩放级别，我们的其他样式将优先。但是，当我们的地图处于13级时，高速公路将变为橙色而不是红色。
- en: I didn't reset the line width, as I did in other sections, which means the line
    width already set for motorways will remain the same for zoom level 13\. Only
    the color will change. In addition to `=`, you can use `>`, `>=`, `<`, and `<=`
    to style at certain zoom levels.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有重置线宽，就像在其他部分做的那样，这意味着为高速公路设置的线宽在13级缩放时将保持不变。只有颜色会改变。除了`=`之外，您还可以使用`>`, `>=`,
    `<`, 和 `<=`在特定缩放级别进行样式化。
- en: 'With a few styles changed, let''s see Tile Drawer in action. Create a new EC2
    instance (remember to terminate those not in use to avoid the hourly charges)
    with the following data:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改一些样式，让我们看看Tile Drawer的实际效果。创建一个新的EC2实例（记得终止未使用的实例以避免每小时收费）并使用以下数据：
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you've made changes that I didn't include here, good for you! In that case,
    replace the URL in bold with the address of the map style sheet on your own server.
    To get a feel for how these few changes alters the look of our tiles, see [Figure 4-25](ch04s11.html#big_roads_and_bright_colors_style_the_la
    "Figure 4-25. Big roads and bright colors style the Las Vegas map").
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您做了我没有在这里包括的更改，那真是太好了！在这种情况下，用您自己的服务器上地图样式表的地址替换粗体中的URL。为了了解这些少数更改如何改变我们瓦片的外观，请参阅[图4-25](ch04s11.html#big_roads_and_bright_colors_style_the_la
    "图4-25. 大路和鲜艳的色彩风格化的拉斯维加斯地图")。
- en: '![Big roads and bright colors style the Las Vegas map](httpatomoreillycomsourcenostarchimages672035.png.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![大路和鲜艳的色彩风格化的拉斯维加斯地图](httpatomoreillycomsourcenostarchimages672035.png.jpg)'
- en: Figure 4-25. Big roads and bright colors style the Las Vegas map
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-25. 大路和鲜艳的色彩风格化的拉斯维加斯地图
- en: After a short wait as your virtual server boots and Tile Drawer does its work,
    your newly styled Las Vegas tiles should be ready. Update the address of your
    server in the Mapstraction file you used to create a tile layer. Load it up and
    you should see the bright roads of Vegas popping out from your new map.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟服务器启动并Tile Drawer完成其工作后稍作等待，您新设计的拉斯维加斯瓷砖应该就绪了。更新您用于创建瓦片层的Mapstraction文件中服务器的地址。加载它，您应该会看到从您的新地图中跳出的明亮的拉斯维加斯道路。
