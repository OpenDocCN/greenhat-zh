- en: Chapter 10. Securing Your System
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章. 保护您的系统
- en: '*Hackers at the gates?*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hackers at the gates?*'
- en: '*Puffy the Barbarian*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*Puffy the Barbarian*'
- en: '*defends against fiends.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*defends against fiends.*'
- en: '![](httpatomoreillycomsourcenostarchimages1616079.png) Securing your system
    means ensuring that your computer’s resources are used only by authorized people
    and for authorized purposes. Even if a system has no important data, it still
    has valuable CPU time, memory, storage, and bandwidth. People who think that their
    systems are too unimportant for anyone to bother breaking into risk finding their
    equipment hosting pornography or relaying attacks against industrial or military
    sites. If you’re like me, you would rather not discover that your computers took
    down a government agency by having law enforcement agents kick in your door.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '![](httpatomoreillycomsourcenostarchimages1616079.png) 保护您的系统意味着确保您的计算机资源仅由授权人员用于授权目的。即使系统没有重要数据，它仍然有宝贵的CPU时间、内存、存储和带宽。认为他们的系统太不重要而不值得任何人闯入的人可能会发现他们的设备正在托管色情内容或中继针对工业或军事网站的攻击。如果您像我一样，您宁愿不发现您的计算机通过执法人员的敲门使政府机构瘫痪。'
- en: Taking over large numbers of remote computers gets easier all the time. Every
    year, more and more point-and-click toolkits for penetrating servers crop up.
    When one bright attacker posts an exploit, anyone can use it. Breaking into computers
    is big business, and if your computer is left unprotected, it *will* be penetrated.
    The only question is how.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 控制大量远程计算机变得越来越容易。每年，都会出现越来越多的用于渗透服务器的点击式工具包。当一位聪明的攻击者发布一个漏洞利用程序时，任何人都可以使用它。闯入计算机是一笔大生意，如果您的计算机没有受到保护，*将会*被渗透。唯一的问题是方式。
- en: Generally speaking, intruders don’t break into operating systems; they break
    into server programs running on the operating system. Even the most paranoiac,
    secure-by-default operating system cannot protect poorly written programs from
    themselves. OpenBSD features like W^X and address space layout randomization do
    a lot to protect the operating system from the side effects of buggy programs,
    but programs themselves still crash and burn. OpenBSD has undergone extensive
    auditing and testing to eliminate the most common security flaws, but there’s
    no guarantee that every security flaw has been eradicated. New features appear
    constantly, and can interact with older functions (and each other) in unexpected
    ways. For more details on the OpenBSD-specific features, check the papers and
    presentations collection at *[http://www.OpenBSD.org/papers/](http://www.OpenBSD.org/papers/)*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，入侵者不会闯入操作系统；他们侵入在操作系统上运行的服务器程序。即使是最偏执、默认安全性的操作系统也无法保护编写不良的程序免受自身的影响。OpenBSD的W^X和地址空间布局随机化等特性在很大程度上保护了操作系统免受有缺陷程序副作用的影响，但程序本身仍然会崩溃和燃烧。OpenBSD经过广泛的审计和测试，以消除最常见的安全漏洞，但无法保证每个安全漏洞都已根除。新特性不断出现，可能会以意想不到的方式与旧功能（以及彼此）交互。有关OpenBSD特定特性的更多详细信息，请查看*[http://www.OpenBSD.org/papers/](http://www.OpenBSD.org/papers/)*的论文和演示文稿集合。
- en: No single tool can protect your server against all threats, and no single tool
    is applicable to all environments. Learning about OpenBSD’s security features
    helps you to understand not only what the tools do, but when they should be used
    and when they won’t help your particular situation. The best place to start is
    by understanding the threat.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何单一的工具可以保护您的服务器免受所有威胁，也没有任何单一的工具适用于所有环境。了解OpenBSD的安全特性有助于您不仅理解工具的功能，而且了解何时应该使用它们以及何时它们对您的特定情况无济于事。最好的开始方式是理解威胁。
- en: Who Is the Enemy?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人是谁？
- en: 'Books dedicated to security break attackers down into smaller, more specific
    groups and include various edge cases, but that’s not what you’re here for. I
    lump potential attackers into four groups: script kiddies, botnets, disaffected
    users, and skilled attackers. These categories are easily understood and include
    99 percent of all the attackers you’re likely to encounter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 专门研究安全的书籍将攻击者划分为更小、更具体的群体，并包括各种边缘情况，但这不是您在这里的原因。我把潜在的攻击者分为四组：脚本小子、僵尸网络、不满的用户和熟练的攻击者。这些类别易于理解，包括您可能遇到的99%的攻击者。
- en: Script Kiddies
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本小子
- en: The most common type of attackers, script kiddies, are not sysadmins. They are
    amateurs who download attack scripts and go looking for poorly defended, vulnerable
    systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的攻击者类型，脚本小子，不是系统管理员。他们是业余爱好者，下载攻击脚本并寻找防御薄弱、易受攻击的系统。
- en: 'Script kiddies are easy to defend against: Keep your software up-to-date and
    follow good computing practices. Like locusts, script kiddies are easy to squash,
    but there are just so darned *many* of the little buggers!'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本小子很容易防御：保持你的软件更新，并遵循良好的计算实践。就像蝗虫一样，脚本小子很容易被压扁，但这个小东西实在是太多了！
- en: Botnets
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意软件网络
- en: Botnets are composed of machines compromised by worms or viruses and are controlled
    from a central point. The botnet’s controllers might use the victim machines to
    search for more vulnerable hosts, to send spam, or to break into secure sites.
    Most botnets are composed of Windows or Linux machines, but there’s no reason
    why such a worm couldn’t target OpenBSD. The virus author would need to work hard,
    but it’s conceivable—if he finds a suitable security flaw.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件网络由被蠕虫或病毒破坏的机器组成，并从中央点控制。恶意软件网络的控制者可能会使用受害机器来寻找更易受攻击的主机，发送垃圾邮件，或者入侵安全网站。大多数恶意软件网络由Windows或Linux机器组成，但没有任何理由说明这样的蠕虫不能针对OpenBSD。病毒作者需要付出很多努力，但如果他找到一个合适的安全漏洞，这是可以想象的。
- en: Fortunately, botnet defense is much like script kiddie defense. You shouldn’t
    have much to worry about if you keep your software patched, configure your server
    software securely, and follow good computing practices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，恶意软件防御与脚本小子防御类似。如果你保持软件更新，安全配置你的服务器软件，并遵循良好的计算实践，你不必担心太多。
- en: Disaffected Users
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 愤世嫉俗的用户
- en: Security pundits commonly claim that a system’s legitimate users cause the majority
    of security problems.^([[26](#ftn.id385498)]) Legitimate users are most likely
    to know where your security gaps are, to feel that the system rules don’t apply
    to them, and to have the necessary access and time to experiment with breaking
    your security. If you tell an employee that company policy forbids him access
    to a computer resource, and the employee feels that he *should* have access to
    it, he is likely to search for a way around the restriction. You can patch all
    of your servers and protect them with an outright hostile firewall, but if someone
    has physical access and knows the root password, your protections are useless.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安全专家通常声称，系统合法用户是大多数安全问题的原因。[^([26](#ftn.id385498))] 合法用户最有可能知道你的安全漏洞在哪里，觉得系统规则不适用于他们，并且有必要的访问权限和时间来尝试破解你的安全。如果你告诉一个员工公司政策禁止他访问计算机资源，而这个员工觉得他*应该*有权访问，他可能会寻找绕过限制的方法。你可以修补所有服务器并使用直接敌对的防火墙来保护它们，但如果有人有物理访问权限并且知道root密码，你的保护措施就毫无用处。
- en: 'Deal with this problem on two levels. The first is technical: Keep your servers
    patched and up-to-date. The second is human: Don’t leave projects half finished
    or half documented. That unsecured modem you installed for emergency incoming
    access until the VPN is solid? Get rid of it, or put a password on it. Ditto for
    that telnet server running on a nonstandard port.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从两个层面解决这个问题。第一个是技术层面：保持你的服务器修补和更新。第二个是人为层面：不要留下半完成或半文档化的项目。那个为了紧急接入而安装的未加密调制解调器？把它扔掉，或者给它设置一个密码。同样，对于运行在非标准端口上的telnet服务器也是如此。
- en: Security by obscurity is feeble at best. When a privileged user leaves the company,
    immediately disable his account, change all administrative passwords, inform employees
    of the person’s departure, and remind them not to share confidential information
    with that person. Implement a computer security policy with real penalties for
    violations. If you have a Human Resources department, get the staff members to
    agree to the policy and insist they enforce it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏式安全最差。当有特权的用户离开公司时，立即禁用他的账户，更改所有管理密码，通知员工该人员的离职情况，并提醒他们不要与该人员共享机密信息。实施具有实际违规处罚的计算机安全政策。如果你有人力资源部门，让员工同意该政策并坚持他们执行它。
- en: What’s the best way to protect yourself against the disaffected user? Don’t
    be lazy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 防止愤世嫉俗的用户最好的方法是什么？不要懒惰。
- en: Skilled Attackers
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技能攻击者
- en: As the most dangerous group, skilled attackers are competent system administrators,
    security researchers, penetration specialists, and criminals who want access to
    specific resources. Taking over computers is a lucrative business these days.
    Sending junk email or launching distributed denial-of-service attacks can bring
    in large sums of money. These intruders don’t care who they attack, as long as
    they secure the computing resources they need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最危险的一群人，熟练的攻击者包括合格的系统管理员、安全研究员、渗透专家以及想要访问特定资源的犯罪分子。如今控制计算机已经成为一项有利可图的生意。发送垃圾邮件或发起分布式拒绝服务攻击可以带来大量金钱。这些入侵者不在乎他们攻击谁，只要他们能确保获得所需的计算资源。
- en: 'If your company has valuable secrets, however, you might attract an entirely
    different type of intruder: someone who wants access to your network in particular.
    If your employer creates anything—from software to cast-iron tulips for front-wheel-drive
    vehicles—there’s likely a market for illicit copies of your product. Someone will
    find it worthwhile to probe every port on every IP address you expose to the Internet.
    It might take a long time, but that’s okay. Your data has a price tag, and the
    scan is cheap. This is often called the advanced persistent threat, or APT.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的公司有宝贵的机密信息，你可能会吸引到完全不同类型的入侵者：那些特别想要访问你网络的人。如果你的雇主从软件到前轮驱动车辆的铸铁郁金香都有所创造，那么你的产品很可能存在非法复制品的市场。有人会认为探测你暴露给互联网的每个IP地址上的每个端口是值得的。这可能需要很长时间，但没关系。你的数据有价格标签，而扫描是便宜的。这通常被称为高级持续性威胁，或APT。
- en: Security measures that stop the other types of intruders affect the techniques
    used by skilled attackers. If you’ve ditched that unsecured inbound access method,
    the intruder can’t find it. If your servers and programs are up to date and correctly
    configured, the intruder will need to find a previously unknown exploit to break
    into your network. If a skilled intruder really wants *your* company’s data, he
    will need to change tactics. Maybe he will try dumpster diving for old sticky
    notes, or even show up dressed as a telco repairman and try to install a packet
    sniffer. If an intruder knows everything about your network and his easiest way
    to break in is *still* something out of a caper film, your security is pretty
    good.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止其他类型入侵者的安全措施也会影响熟练攻击者所使用的技巧。如果你已经放弃了那个不安全的入站访问方法，入侵者就找不到它。如果你的服务器和程序都是最新版本并且配置正确，入侵者将需要找到之前未知的漏洞来入侵你的网络。如果一个熟练的入侵者真的想要获取*你的*公司的数据，他需要改变策略。他可能会尝试翻垃圾桶寻找旧粘性便签，或者甚至装扮成电信维修工试图安装数据嗅探器。如果一个入侵者对你的网络了如指掌，而他最容易的入侵方式*仍然*是来自冒险电影中的场景，那么你的安全状况相当不错。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The word hacker has different meanings depending on who is talking. In the technical
    world, a hacker is someone not only interested in the inner workings of technology
    but also capable of creating new technology. The media has transformed the word
    to mean “someone who breaks into computers.” I recommend completely avoiding the
    word “hacker,” and using terms like “intruder” or “gravy sucking pig-dog” instead.
    When to use each is up to you, of course.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “黑客”这个词的含义因人而异。在技术界，黑客不仅对技术的内部运作感兴趣，而且能够创造新技术。媒体已经将这个词的含义转变为“入侵计算机的人”。我建议完全避免使用“黑客”这个词，而使用“入侵者”或“贪婪的吸脂猪狗”等术语。当然，何时使用每个术语取决于你。
- en: OpenBSD Security Announcements
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenBSD 安全公告
- en: Your best line of defense against all types of intruders is keeping your computer
    software up to date. This means you need to know when to update your system and
    what to update. The OpenBSD Project maintains a low-traffic mailing list, *security-announce@OpenBSD.org*,
    specifically to broadcast new security alerts to users. Subscribe to this list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 防御所有类型入侵者的最佳防线是保持你的计算机软件更新。这意味着你需要知道何时更新你的系统以及更新什么。OpenBSD项目维护了一个低流量的邮件列表，*security-announce@OpenBSD.org*，专门用于向用户广播新的安全警报。请订阅此列表。
- en: If you don’t feel like subscribing to yet another mailing list, these security
    alerts are also posted on OpenBSD-specific sites such as *[http://www.undeadly.org](http://www.undeadly.org)*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想再订阅另一个邮件列表，这些安全警报也发布在OpenBSD特定的网站上，例如 *[http://www.undeadly.org](http://www.undeadly.org)*。
- en: Note that this won’t get you security alerts for third-party software running
    on OpenBSD. You must get updates for those programs separately. Check the software’s
    website for details on how to get their security announcements. All the time you’ve
    spent securing your operating system will be wasted if someone hijacks the insecure
    web application you neglected to update.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会为在OpenBSD上运行的第三方软件提供安全警报。你必须单独为这些程序获取更新。查看软件的网站以获取有关如何获取其安全公告的详细信息。如果你忽视更新而有人劫持了不安全的Web应用程序，那么你花费在保护操作系统上的所有时间都将浪费。
- en: OpenBSD Memory Protection
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenBSD内存保护
- en: One of the most common intrusion paths is to attack what’s in the computer’s
    memory. If intruders can access memory that they shouldn’t be able to access,
    or if they can make a program access memory it shouldn’t, they have any number
    of ways to get into the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的入侵途径之一是攻击计算机内存中的内容。如果入侵者能够访问他们不应能够访问的内存，或者他们能够使程序访问不应访问的内存，他们就有无数种方法进入系统。
- en: OpenBSD includes a whole bunch of security features for system memory that the
    sysadmin never actually sees. You don’t need to turn on the nonexecutable stack;
    it’s just there.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD包含了一系列系统内存的安全特性，系统管理员实际上从未真正看到过。你不需要开启不可执行的堆栈；它只是在那里。
- en: Some of these features appear only in OpenBSD. Some appeared first in OpenBSD,
    and then spread elsewhere. Some came from research papers. Others build on hardware
    features.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些特性仅在OpenBSD中出现。一些首先出现在OpenBSD中，然后传播到其他地方。一些来自研究论文。其他则是基于硬件特性。
- en: The OpenBSD team takes a more proactive attitude about security features than
    many other projects. As an example, consider the ProPolice deployment several
    years ago. ProPolice is a compiler feature that prevents certain classes of buffer
    overflows. When you enabled ProPolice in the early days, a lot of software could
    not be built. Even more software could be built, but it crashed when used. These
    failures were not ProPolice problems. ProPolice simply exposed programming errors
    in the software. But many users and developers said that “enabling ProPolice breaks
    all kinds of stuff, so don’t turn it on.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD团队在安全特性方面比许多其他项目更加积极主动。以几年前ProPolice的部署为例。ProPolice是一种编译器特性，可以防止某些类型的缓冲区溢出。在早期启用ProPolice时，许多软件无法构建。甚至更多软件可以构建，但在使用时崩溃。这些失败不是ProPolice的问题。ProPolice只是暴露了软件中的编程错误。但许多用户和开发者说，“启用ProPolice会破坏所有东西，所以不要启用它。”
- en: The OpenBSD team enabled ProPolice by default in a development snapshot. What
    happened? Stuff—a lot of stuff—broke. Many third-party applications needed by
    OpenBSD users either could not build or would not run. Third-party application
    vendors started receiving bug reports from OpenBSD users who were able to say
    exactly how the software was broken. Software vendors started fixing bugs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD团队在开发快照中默认启用了ProPolice。发生了什么？很多问题——很多问题——都出现了。许多OpenBSD用户需要的第三方应用程序要么无法构建，要么无法运行。第三方应用程序的供应商开始收到来自OpenBSD用户的错误报告，他们能够确切地说明软件是如何出错的。软件供应商开始修复错误。
- en: ProPolice didn’t cause these crashes; it merely exposed bugs. By enabling ProPolice
    by default, OpenBSD gave the free software world incentive to fix those bugs.
    Eventually, as the type of bugs revealed by ProPolice became less common, other
    operating systems also enabled ProPolice. OpenBSD’s willingness to take this step
    improved computer security as a whole.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ProPolice并没有导致这些崩溃；它只是暴露了错误。通过默认启用ProPolice，OpenBSD为免费软件世界提供了修复这些错误的动力。最终，随着ProPolice揭示的错误类型变得越来越不常见，其他操作系统也启用了ProPolice。OpenBSD愿意采取这一步骤，提高了整体计算机的安全性。
- en: If you closely follow OpenBSD development, expect to see more of this behavior.
    The OpenBSD team does what it considers most correct, not what is most convenient
    or easiest.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你密切关注OpenBSD的开发，预计会看到更多这样的行为。OpenBSD团队做他们认为最正确的事情，而不是最方便或最容易的事情。
- en: The common memory security features you should know about include W^X, .rodata
    segments, guard pages, randomized memory allocations, ProPolice, and protecting
    `atexit` and `stdio`. We’ll cover each in turn.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解的常见内存安全特性包括W^X、.rodata段、保护页、随机内存分配、ProPolice以及保护`atexit`和`stdio`。我们将逐一介绍。
- en: W^X
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: W^X
- en: W^X stands for Write Xor Execute. Once a program is loaded, that program’s pages
    in memory are either writable or executable, but not both.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: W^X代表写或执行。一旦程序被加载，该程序在内存中的页面要么是可写的，要么是可执行的，但不能同时两者都是。
- en: A common exploit technique is to trick a program into writing information to
    memory, and then executing that piece of memory. An attacker might convince a
    program to write to a chunk of memory, but the kernel will not allow that memory
    to be executed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的攻击技术是欺骗程序将信息写入内存，然后执行该内存片段。攻击者可能会说服程序将信息写入一块内存，但内核不会允许执行该内存。
- en: Some hardware platforms (such as amd64) have hardware support for W^X. If that
    support exists, OpenBSD uses it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些硬件平台（如amd64）具有W^X的硬件支持。如果存在这种支持，OpenBSD会使用它。
- en: .rodata Segments
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .rodata段
- en: 'A segment of memory containing program code traditionally had two parts: actual
    code and read-only data, or *.rodata segments*. In the past, some operating systems
    allowed programs to modify read-only memory. OpenBSD prevents this by leveraging
    hardware features when available.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，包含程序代码的内存段通常有两个部分：实际代码和只读数据，或*.rodata段*。在过去，一些操作系统允许程序修改只读内存。OpenBSD通过利用硬件功能（如果可用）来防止这一点。
- en: Guard Pages
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护页
- en: Many pieces of software used to access memory beyond what they allocated. If
    a program writes to memory that doesn’t belong to it, it’s writing to memory that
    belongs to a different program. Intruders use this to exploit programs. A *guard
    page* is a single page of memory next to the memory allocated by a program. The
    program cannot write to this memory. If the program tries to write to the guard
    page, it probably will crash. By enforcing this limit, OpenBSD protects other
    programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件在访问它们分配的内存之外时都会出现问题。如果一个程序写入不属于它的内存，它就是在写入属于另一个程序的内存。入侵者利用这一点来利用程序。*保护页*是紧挨着程序分配的内存的单页内存。程序不能写入此内存。如果程序尝试写入保护页，它很可能会崩溃。通过强制执行此限制，OpenBSD保护其他程序。
- en: Using guard pages everywhere would use a lot of memory, so OpenBSD enables guard
    pages only in carefully selected places.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有地方使用保护页会消耗大量内存，因此OpenBSD只在仔细选择的位置启用保护页。
- en: Address Space Layout Randomization
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地址空间布局随机化
- en: Traditionally, computers allocate memory consecutively. This can give intruders
    certain advantages. If they know that program A usually loads after program B,
    and they know they can make program B write to memory space outside its allocation,
    they can guess that they can write to program A’s memory space and make program
    A fail in a predictable manner. Doing so requires a certain degree of skill, but
    once one person figures out this exploit, innumerable people can use it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，计算机连续分配内存。这可能会给入侵者带来某些优势。如果他们知道程序A通常在程序B之后加载，并且他们知道他们可以让程序B写入其分配之外的内存空间，他们可以猜测他们可以写入程序A的内存空间并使程序A以可预测的方式失败。这样做需要一定的技能，但一旦有人发现这种利用方法，无数的人都可以使用它。
- en: OpenBSD randomizes where it allocates memory. Two programs started one after
    the other don’t get consecutive memory blocks. The randomization is done intelligently,
    to avoid wasting memory. Intruders cannot use one program against another in this
    manner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD随机化内存分配的位置。连续启动的两个程序不会获得连续的内存块。这种随机化是智能的，以避免浪费内存。入侵者不能以这种方式利用一个程序攻击另一个程序。
- en: ProPolice
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ProPolice
- en: ProPolice protects code against attacks that manipulate the memory stack. When
    code is compiled, ProPolice adds additional code to keep a program within its
    own area of memory. If ProPolice determines that specific areas of memory (called
    *canaries*) have been changed, it immediately aborts the program. Where other
    memory protection techniques prevent writing to executable memory, ProPolice terminates
    a process when writable memory that *can* be written to, but specifically *should
    not*, is changed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ProPolice保护代码免受操纵内存栈的攻击。当代码编译时，ProPolice会添加额外的代码以使程序保持在它自己的内存区域。如果ProPolice确定特定的内存区域（称为*金丝雀*）已被更改，它将立即终止程序。与其他内存保护技术防止写入可执行内存不同，当可写入的内存（*可以*写入，但具体*不应该*写入）被更改时，ProPolice会终止进程。
- en: And More!
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以及更多！
- en: 'OpenBSD includes a whole bunch of small memory guards scattered throughout.
    Here’s a small sampling:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD包含大量分散的小内存保护器。以下是一些小样本：
- en: The `malloc()` and `atexit()` system calls mark memory nonwritable after updating
    it.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc()`和`atexit()`系统调用在更新后标记内存为不可写。'
- en: File descriptor handling has been carefully audited throughout.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符处理已经经过仔细审计。
- en: '`snprintf` is async-signal-safe when no floats are involved.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不涉及浮点数时，`snprintf`是异步信号安全的。
- en: And the list continues.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。
- en: Could any of these be exploited in the real world? Some of them have, and some
    are just theoretical. But I would rather be protected against theoretical threats
    than assume no one can break something that has never been broken before.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在现实世界中是否可能被利用？其中一些已经被利用，而另一些只是理论上的。但我会更愿意保护自己免受理论威胁，而不是假设没有人能破坏从未被破坏过的事物。
- en: File Flags
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件标志
- en: All Unix-like operating systems share a common permissions scheme, but OpenBSD
    (and most BSD-based operating systems) extends the permissions scheme with *file
    flags*. File flags work with permissions to change file security. Flags can make
    a file unchangeable, make it so that existing data cannot be removed and users
    can only add to the file, and produce several other effects. Some flags have functions
    unrelated to security, but we’ll pay special attention to the security flags.
    File flags are listed and documented in `chflags(1)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类Unix操作系统都共享一个通用的权限方案，但OpenBSD（以及大多数基于BSD的操作系统）通过*文件标志*扩展了权限方案。文件标志与权限一起工作，以改变文件安全性。标志可以使文件不可更改，使得现有数据无法被删除，用户只能向文件中添加内容，并产生其他几种效果。一些标志的功能与安全性无关，但我们将特别关注安全标志。文件标志在`chflags(1)`中列出并文档化。
- en: File Flag Types
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件标志类型
- en: Many file flags have different effects depending on the system securelevel,
    which we’ll cover in the next section. Understanding how securelevels work requires
    an understanding of file flags, while file flags rely on securelevels. For the
    moment, just nod and smile when I mention securelevels while discussing file flags.
    All will become clear, trust me.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件标志的效果取决于系统安全级别，我们将在下一节中介绍。理解安全级别的工作原理需要理解文件标志，而文件标志依赖于安全级别。在此期间，当我提到安全级别时，只需点头微笑。一切都会变得清晰，请相信我。
- en: 'OpenBSD’s UFS and UFS2 filesystems support the following file flags:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD的UFS和UFS2文件系统支持以下文件标志：
- en: '**`sappnd`**'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`sappnd`**'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Files with the system-level append-only flag can be added to but cannot be removed
    or otherwise edited. The `sappnd` flag is particularly useful for log files. For
    example, a common intruder tactic is to remove *.history* or symlink it to */dev/null*
    so that the administrator cannot see what happened. Setting `sappnd` on a user’s
    *.history* file can be interesting if the account is compromised. Using the `sappnd`
    flag ensures that intruders cannot cover their tracks in this manner. Only root
    can set or remove the `sappnd` flag, and it cannot be removed when the system
    is running at securelevel 1 or higher.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带有系统级别只读标志的文件可以被添加，但不能被删除或以其他方式编辑。`sappnd`标志特别适用于日志文件。例如，常见的入侵者策略是删除*.history*或将它符号链接到*/dev/null*，这样管理员就无法看到发生了什么。如果账户被入侵，在用户的*.history*文件上设置`sappnd`标志可能很有趣。使用`sappnd`标志可以确保入侵者不能以这种方式掩盖他们的踪迹。只有root可以设置或删除`sappnd`标志，并且当系统在安全级别1或更高时，此标志不能被删除。
- en: '**`uappnd`**'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`uappnd`**'
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The user-level append-only flag can be set only by the file owner or root. As
    with `sappnd`, a file with the `uappnd` flag can be added to but not otherwise
    edited or removed. This is most useful for personal logs and files; it primarily
    adds an extra layer of protection against users accidentally deleting their own
    files. The owner or root can set or remove this flag.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户级别的只读标志只能由文件所有者或root设置。与`sappnd`类似，带有`uappnd`标志的文件可以被添加，但不能被其他方式编辑或删除。这对于个人日志和文件非常有用；它主要增加了一层额外的保护，以防止用户意外删除自己的文件。所有者或root可以设置或删除此标志。
- en: '**`schg`**'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`schg`**'
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Files with the system-level immutable flag cannot be changed in any way. They
    cannot be edited, moved, replaced, or overwritten. Basically, the filesystem itself
    prevents all attempts to alter this file. Only root can set or remove this flag,
    and it cannot be removed when the system is running at securelevel 1 or higher.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带有系统级别不可变标志的文件不能以任何方式更改。它们不能被编辑、移动、替换或覆盖。基本上，文件系统本身阻止了所有尝试更改此文件的行为。只有root可以设置或删除此标志，并且当系统在安全级别1或更高时，此标志不能被删除。
- en: '**`uchg`**'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`uchg`**'
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The user-level immutable flag prevents anyone from changing the file. It’s a
    user-level flag, so root can override it. This flag helps to prevent a file from
    being edited or removed by accident, but it’s not a way to secure the system.
    The owner or root can set or remove this flag at any securelevel.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户级别的不可变标志阻止任何人更改文件。这是一个用户级别的标志，因此root可以覆盖它。这个标志有助于防止文件被意外编辑或删除，但它不是确保系统安全的方法。所有者或root可以在任何安全级别设置或删除此标志。
- en: '**`nodump`**'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**`nodump`**'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The no dump flag tells `dump(8)` to not back up a file. Set this on files that
    don’t need to be backed up to tape. Check your backup program’s documentation
    to see if it honors this flag.
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无备份标志告诉 `dump(8)` 不要备份文件。在不需要备份到磁带的文件上设置此标志。查看您的备份程序文档，以了解它是否尊重此标志。
- en: Setting, Viewing, and Removing File Flags
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置、查看和移除文件标志
- en: Set file flags with `chflags(1)`. For example, if you are really worried about
    someone changing your kernel file, you could mark */bsd* with the system-level
    immutable flag.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `chflags(1)` 设置文件标志。例如，如果您非常担心有人更改您的内核文件，您可以使用系统级别的不可变标志标记 */bsd*。
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This would prevent anyone—including you—from changing the kernel, reconfiguring
    the kernel, or upgrading the system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将阻止任何人——包括您自己——更改内核、重新配置内核或升级系统。
- en: 'You can also recursively change the file flags on an entire directory tree
    with the `-R` flag. If you wanted to make the entirety of */bin* immutable, you
    would run this command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `-R` 标志递归地更改整个目录树上的文件标志。如果您想使 */bin* 下的所有内容都不可变，您将运行以下命令：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And poof, you can no longer upgrade your system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将无法再升级您的系统。
- en: To view the flags on a file, use `ls -lo`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文件上的标志，请使用 `ls -lo`。
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This file has no flags set on it. Let’s set the system-level append-only flag.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件上没有设置任何标志。让我们设置系统级别的只读标志。
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Oh, right—only root can set system-level flags. Let’s try again:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对了——只有 root 用户可以设置系统级别的标志。让我们再试一次：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This file now has the `sappnd` flag. The system can add to it, but cannot otherwise
    edit or remove it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件现在具有 `sappnd` 标志。系统可以添加到它，但不能对其进行其他编辑或删除。
- en: OpenBSD doesn’t flag any files out of the box, so you’ll need to add flags yourself
    if you want them. Before you go nuts, however, note that adding file flags increases
    the overhead for system maintenance. If upgrading a system is hard, the sysadmin
    won’t want to do it. Is it more secure to have all your programs in */bin* immutable,
    or is it more secure to simplify upgrades, updates, and application of security
    patches?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 默认不标记任何文件，因此如果您想设置标志，您需要自己添加。然而，在您疯狂地添加标志之前，请注意，添加文件标志会增加系统维护的开销。如果升级系统很困难，系统管理员可能不想这样做。在
    */bin* 中使所有程序不可变是否更安全，或者简化升级、更新和安全补丁的应用是否更安全？
- en: 'To remove a flag from a file, use `chflags` with a `no` before the flag name.
    For example, to unset the `sappnd` flag on the *vitallog* file, try this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中移除标志，请使用带有标志名称之前 `no` 的 `chflags`。例如，要取消 *vitallog* 文件上的 `sappnd` 标志，尝试以下操作：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Wait a minute! I’m running under `sudo(8)`, and I have root-level privileges.
    What’s going on?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我正在使用 `sudo(8)` 运行，并且我有 root 级别的权限。发生了什么事？
- en: By default, OpenBSD runs at securelevel 1\. When running at securelevel 1 or
    higher, you cannot unset system-level file flags, so an attempt to do so failed.
    You can remove these flags only at securelevel -1 or in single-user mode. Read
    on to learn about securelevels.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenBSD 运行在 securelevel 1。在 securelevel 1 或更高级别运行时，您不能取消系统级别的文件标志，因此尝试取消设置将失败。您只能在
    securelevel -1 或单用户模式下移除这些标志。继续阅读以了解 securelevel。
- en: Securelevels
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Securelevel
- en: '`securelevel(7)` is a kernel setting to restrict actions the system can perform.
    The kernel behaves slightly differently as you raise the securelevel. For example,
    at low securelevels, the file flags discussed in the previous section can be removed;
    a file might be marked immutable, but you can remove the marker, delete or edit
    the file, and restore the flag. When you increase the securelevel, however, you
    can no longer remove the flag. Similar changes take place in other parts of the
    system. Taken as a whole, these changes might frustrate or stop an intruder.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`securelevel(7)` 是一个内核设置，用于限制系统可以执行的操作。随着 securelevel 的提高，内核的行为会有所不同。例如，在低
    securelevel 下，上一节中讨论的文件标志可以被移除；文件可能被标记为不可变，但您可以移除标记、删除或编辑文件，并恢复标志。然而，当您提高 securelevel
    时，您将无法再移除标志。系统其他部分的类似更改也会发生。整体来看，这些更改可能会挫败或阻止入侵者。'
- en: Securelevel settings range from -1 to 2\. Though OpenBSD runs at securelevel
    1 by default, you can change this setting to fit your environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 设置范围从 -1 到 2。尽管 OpenBSD 默认运行在 securelevel 1，但您可以根据您的环境更改此设置。
- en: Higher securelevels make system maintenance difficult. Many actions taken during
    normal upgrades and administration are also things that intruders might do to
    cover their tracks. It might make sense for you to run a highly secure, stable
    server at securelevel 2, and run your experimental machine at -1\. On the other
    hand, the OpenBSD folks don’t encourage changing from the default securelevel.
    Running your system at -1 may leave you open to attacks, while running at 2 complicates
    management and maintenance. Which securelevel you choose depends on your environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 较高的 securelevel 会使得系统维护变得困难。在正常升级和管理过程中采取的许多操作也可能是入侵者用来掩盖行踪的行为。您可能需要在 securelevel
    2 上运行一个高度安全、稳定的服务器，并在 -1 上运行您的实验性机器。另一方面，OpenBSD 的人不鼓励更改默认的 securelevel。在 -1 上运行您的系统可能会使您容易受到攻击，而在
    2 上运行则会使得管理和维护变得复杂。您选择的 securelevel 取决于您的环境。
- en: Despite the name, a securelevel is not an all-purpose general security dial.
    Arbitrarily increasing the securelevel will do nothing but annoy you and your
    users. While you can increase the securelevel at any time, you cannot reduce the
    securelevel without rebooting the system, so don’t experiment blindly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字如此，securelevel 并不是一个万能的安全调节器。随意提高 securelevel 除了让您和您的用户感到烦恼外，不会产生任何作用。虽然您可以在任何时候提高
    securelevel，但您不能在不重启系统的情况下降低 securelevel，所以不要盲目实验。
- en: Setting the System Securelevel
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置系统 securelevel
- en: 'Set the boot-time securelevel in */etc/rc.securelevel*. In that file, you’ll
    find a line like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */etc/rc.securelevel* 中设置引导时的 securelevel。在该文件中，您会找到如下类似的行：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Change the `1` to your preferred securelevel. On your next reboot, the system
    will go to this securelevel when it enters multiuser mode. If you need to run
    a process before the boot process raises the securelevel, put the command to start
    the process in this file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `1` 改为您想要的 securelevel。在您下一次重启时，系统进入多用户模式时会进入此 securelevel。如果您需要在引导过程提升 securelevel
    之前运行一个进程，请将启动进程的命令放入此文件。
- en: If you want to raise the securelevel without rebooting, adjust the `kern.securelevel
    sysctl(3)` to the desired value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在不停机的情况下提升 securelevel，请调整 `kern.securelevel sysctl(3)` 到所需的值。
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remember that you cannot lower the securelevel of a running system. If a sysadmin
    could lower the securelevel, so could an intruder.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您不能降低正在运行系统的 securelevel。如果系统管理员可以降低 securelevel，那么入侵者也可以。
- en: Securelevel Definitions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Securelevel 定义
- en: 'OpenBSD has four securelevels: -1, 0, 1 and 2\. We’ll cover each in turn.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD 有四个 securelevel：-1、0、1 和 2。我们将逐一介绍。
- en: Securelevel -1
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Securelevel -1
- en: Securelevel -1 is also called permanently insecure mode. The system isn’t necessarily
    insecure—it’s just that none of the securelevel protections are in place. I use
    securelevel -1 only to remove file flags that I never should have used in the
    first place.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel -1 也被称为永久不安全模式。系统并不一定是不安全的——只是没有任何 securelevel 保护措施。我只使用 securelevel
    -1 来移除我一开始就不应该使用的文件标志。
- en: Securelevel 0
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Securelevel 0
- en: Securelevel 0 is used only when the system is first booting. It offers no special
    features. When the system reaches multiuser mode, however, the securelevel is
    automatically raised to 1\. Setting `securelevel=0` in */etc/rc.securelevel* is
    functionally equivalent to setting `securelevel=1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 0 仅在系统首次启动时使用。它不提供任何特殊功能。然而，当系统达到多用户模式时，securelevel 会自动提升到 1。在 */etc/rc.securelevel*
    中设置 `securelevel=0` 在功能上等同于设置 `securelevel=1`。
- en: Securelevel 1
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Securelevel 1
- en: At securelevel 1, OpenBSD’s default, things become interesting.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 的默认 securelevel 1 下，事情变得有趣。
- en: The securelevel affects certain kernel configuration settings, called sysctls
    (covered in [Chapter 18](ch18.html "Chapter 18. Kernel Configuration")). Early
    in the boot process, OpenBSD uses the settings in */etc/sysctl.conf* to set sysctls.
    When I say that a particular sysctl cannot be changed, read that as “without altering
    the configuration and rebooting.”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: securelevel 影响某些内核配置设置，称为 sysctl（在第 18 章中介绍）。在引导过程的早期，OpenBSD 使用 */etc/sysctl.conf*
    中的设置来设置 sysctl。当我说某个特定的 sysctl 不能更改时，请将其理解为“不改变配置和重新启动”。
- en: 'Securelevel 1 implements the following limitations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 1 实现以下限制：
- en: No one can write to the */dev/mem* and */dev/kmem* devices. Many security exploits
    work by writing to these devices.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有人可以写入 */dev/mem* 和 */dev/kmem* 设备。许多安全漏洞都是通过写入这些设备来实现的。
- en: The raw disk devices of all mounted file systems are read-only. (Writing to
    the raw devices of mounted filesystems would let you change files without regard
    to permissions.) Programs should access mounted filesystems only through the filesystem
    anyway, so this won’t change day-to-day operations.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有挂载的文件系统的原始磁盘设备都是只读的。（向挂载文件系统的原始设备写入会允许你更改文件而不考虑权限。）程序应该只通过文件系统访问挂载的文件系统，所以这不会改变日常操作。
- en: The system-level file flags `schg` and `sappnd` cannot be removed.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统级别的文件标志 `schg` 和 `sappnd` 不能被移除。
- en: Kernel modules cannot be loaded or unloaded. OpenBSD supports kernel modules,
    but the default kernel is monolithic. There’s no legitimate reason to load a kernel
    module on a running production system.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块不能加载或卸载。OpenBSD 支持内核模块，但默认内核是单片的。在运行的生产系统上加载内核模块没有合法的理由。
- en: The sysctl `fs.posix.setuid` cannot be changed. By default, `chown(1)` clears
    the `setuid` and `setgid` bits on files when changing file permissions, as per
    the POSIX standard. You can override this by setting `fs.posix.setuid` to 0.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sysctl `fs.posix.setuid` 不能更改。默认情况下，`chown(1)` 会根据 POSIX 标准清除文件上的 `setuid` 和
    `setgid` 位，当更改文件权限时。你可以通过将 `fs.posix.setuid` 设置为 0 来覆盖此设置。
- en: The sysctl `hw.allowpowerdown` cannot be changed. This controls the power button’s
    interaction with the system. When it’s set to 1, briefly pressing the power button
    shuts down the system cleanly. When it’s set to 0, the power button does not shut
    down the system. (You can still shut down the system by holding down the power
    button for several seconds, but that’s not a clean shutdown.) Not all platforms
    support this kind of shutdown or power management.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sysctl `hw.allowpowerdown` 不能更改。这控制着电源按钮与系统的交互。当设置为 1 时，短暂按下电源按钮会干净地关闭系统。当设置为
    0 时，电源按钮不会关闭系统。（你仍然可以通过按住电源按钮几秒钟来关闭系统，但这不是干净关闭。）并非所有平台都支持这种关闭或电源管理。
- en: The sysctl `net.inet.ip.sourceroute` cannot be changed. Source routing is a
    technique to permit the sender of a packet to control which route the packet takes
    across the network. It’s caused many security problems, and its use is generally
    discouraged. OpenBSD ignores source routing by default. Setting `net.inet.ip.sourceroute`
    to 1 forces OpenBSD to pay attention to source routing.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sysctl `net.inet.ip.sourceroute` 不能更改。源路由是一种允许数据包发送者控制数据包在网络中采取的路径的技术。它已经引起了许多安全问题，并且其使用通常是不被鼓励的。OpenBSD
    默认忽略源路由。将 `net.inet.ip.sourceroute` 设置为 1 会强制 OpenBSD 注意源路由。
- en: The sysctl `machdep.kbdreset` cannot be changed. When set to 1, `machdep.kbdreset`
    allows the system to be cleanly rebooted using CTRL-ALT-DELETE. When this sysctl
    is set to 0, the system ignores CTRL-ALT-DELETE.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sysctl `machdep.kbdreset` 不能更改。当设置为 1 时，`machdep.kbdreset` 允许系统通过 CTRL-ALT-DELETE
    清洁重启。当此 sysctl 设置为 0 时，系统会忽略 CTRL-ALT-DELETE。
- en: The `ddb.console` and `ddb.panic` sysctls may not be raised. Raising these sysctls
    enables certain kernel debugging options. Unauthorized users with physical access
    could gain unlimited system access through the debugger if they could raise these
    sysctls.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ddb.console` 和 `ddb.panic` sysctl 可能不能提高。提高这些 sysctl 启用某些内核调试选项。未经授权的用户如果能够提高这些
    sysctl，通过调试器可以获得无限系统访问。'
- en: The sysctl `machdep.allowaperture` cannot be raised. If you want to use the
    X Window System (discussed in [Chapter 17](ch17.html "Chapter 17. Desktop OpenBSD")),
    you must allow X access to specific parts of kernel memory by enabling this sysctl
    early during the boot process. If you’re not running X, no one legitimately needs
    this access.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sysctl `machdep.allowaperture` 不能提高。如果你想使用 X Window 系统（在第 17 章中讨论），你必须通过在引导过程中早期启用此
    sysctl 来允许 X 访问内核内存的特定部分。如果你没有运行 X，没有人有合法理由需要这种访问。
- en: General-purpose input/output (GPIO) controllers cannot be further configured.
    GPIO controllers support a wide variety of special-purpose hardware. See `gpio(4)`
    and `gpioctl(8)` for details on each.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用输入/输出（GPIO）控制器不能进一步配置。GPIO 控制器支持各种特殊用途的硬件。请参阅 `gpio(4)` 和 `gpioctl(8)` 以获取每个控制器的详细信息。
- en: These limitations have little effect on normal day-to-day operations, but they
    can interfere with debugging. If you’re trying to discover why your GPIO device
    isn’t working, you probably want to set your securelevel to -1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制对日常操作的影响很小，但可能会干扰调试。如果你正在尝试找出为什么你的 GPIO 设备不工作，你可能想将你的 securelevel 设置为 -1。
- en: Securelevel 2
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Securelevel 2
- en: Securelevel 2 is the highest securelevel in OpenBSD, and it disables a variety
    of features that you might need during normal maintenance. Use securelevel 2 only
    on a stable machine that you don’t expect to change much. If you need to change
    anything restricted by securelevel 2, you must reboot the machine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 2 是 OpenBSD 中的最高 securelevel，它禁用了在正常维护期间可能需要的各种功能。只有在稳定且不打算进行太多更改的机器上才应使用
    securelevel 2。如果你需要更改 securelevel 2 限制的内容，你必须重新启动机器。
- en: 'Securelevel 2 includes everything from securelevel 1, plus the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 2 包含了 securelevel 1 的所有内容，以及以下内容：
- en: Raw disk devices are always read-only. You cannot format, fdisk, or disklabel
    disks, even if they’re not in use.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始磁盘设备始终是只读的。即使它们未被使用，你也不能格式化、fdisk 或 disklabel 磁盘。
- en: The system clock cannot be moved backward, nor close to the overflow point.
    Make sure your system time is correct before entering multiuser mode!
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统时钟不能倒退，也不能接近溢出点。在进入多用户模式之前，请确保你的系统时间正确！
- en: You cannot alter packet-filtering rules (covered in [Chapter 21](ch21.html "Chapter 21. Packet
    Filtering") and [Chapter 22](ch22.html "Chapter 22. Advanced PF")). Packet filters,
    network address translation (NAT), traffic queues, and so on are immutable.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能更改数据包过滤规则（在[第 21 章](ch21.html "第 21 章。数据包过滤")和[第 22 章](ch22.html "第 22 章。高级
    PF")中介绍）。数据包过滤器、网络地址转换（NAT）、流量队列等都是不可变的。
- en: Kernel debugger sysctl values (those beginning with `ddb`) cannot be changed.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核调试器 sysctl 值（以 `ddb` 开头的）不能更改。
- en: So, for example, you don’t want your firewall at securelevel 2 unless you understand
    that packet filtering rules can change only with a reboot.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，除非你了解数据包过滤规则只能通过重启来更改，否则你不想让你的防火墙在 securelevel 2 上运行。
- en: What Securelevel Do You Need?
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你需要什么Securelevel？
- en: The securelevel appropriate for your environment depends entirely on your situation,
    but the overwhelming majority of the time, the default of securelevel 1 is most
    suitable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 适合你环境的 securelevel 完全取决于你的情况，但绝大多数情况下，默认的 securelevel 1 是最合适的。
- en: If you are debugging and testing features and tools, you might find that you
    need to use securelevel -1 on a development machine. Once you’ve worked out how
    to configure your GPIO device or the correct debugger settings for your system,
    however, use securelevel 1 so that you mirror a production environment.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在调试和测试功能和工具，你可能会发现需要在开发机器上使用 securelevel -1。然而，一旦你解决了如何配置你的 GPIO 设备或系统的正确调试器设置，就使用
    securelevel 1，以便在尽可能接近生产环境的情况下进行操作。
- en: If you have a very stable system, you could try securelevel 2\. In all my years
    of running OpenBSD, though, I’ve had only one system for which securelevel 2 was
    the right choice, and several cases where securelevel 2 created more trouble than
    it was worth.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个非常稳定的系统，你可以尝试使用 securelevel 2。然而，在我运行 OpenBSD 的这些年里，我只遇到过一次 securelevel
    2 是正确的选择，还有几次 securelevel 2 带来的麻烦比它值得的要多。
- en: Securelevel Weaknesses
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Securelevel 的弱点
- en: What can’t securelevels do? Consider a case where someone compromises a web
    application on your server, uses that to bootstrap himself into a shell, and then
    uses the shell to bootstrap himself into root access. Securelevels don’t do anything
    to prevent this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Securelevel 能做什么？考虑一个场景，有人入侵了你的服务器上的一个网络应用程序，利用这个漏洞将自己提升到 shell 权限，然后使用 shell
    提升到 root 权限。Securelevel 对此没有任何预防措施。
- en: Unless you’ve made copious use of the `schg` flag, the intruder can replace
    system binaries with ones that send your authentication credentials to a free
    email account registered in a bogus name. So you decide to run around applying
    the `schg` flag to the contents of critical directories like */bin* and */usr/lib*.
    That will stop the bugger! Well, that will work as long as you make every file
    immutable, including the system configuration files in */etc* —you know, the ones
    that you need to change in order to do your job. If you leave one file unprotected,
    the intruder could add a command like `chflags -R noschg /` to an early part of
    the system startup, and poof—the next time you reboot your system, you unlock
    all your files. How often do you exhaustively audit your */etc* files? And you’ll
    need to undo this tangled morass every time you patch or upgrade your system!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你大量使用了`schg`标志，入侵者可以用发送你的认证凭据到以虚假名字注册的免费电子邮件账户的系统二进制文件来替换。所以你决定四处奔波，将`schg`标志应用到像*/bin*和*/usr/lib*这样的关键目录的内容上。这样就能阻止那个家伙了！嗯，只要把每个文件都设置为不可变，包括*/etc*中的系统配置文件——你知道，你需要更改这些文件来完成你的工作——那么这就会有效。如果你留下一个文件没有保护，入侵者可以在系统启动的早期部分添加一个命令，比如`chflags
    -R noschg /`，那么下次你重启系统时，你所有的文件都会被解锁。你多久会彻底审计一次你的*/etc*文件？而且每次修补或升级系统时，你都需要撤销这个复杂的混乱！
- en: This is only one possible path. There are many ways for an intruder to lever
    himself into the system. Relying on securelevels to protect you is unwise. Use
    them and consider them a tool in your kit, but don’t think they are a panacea
    for every problem.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个可能的方法。入侵者进入系统的途径有很多。依赖securelevels来保护你是不明智的。使用它们，并将它们视为你的工具箱中的一个工具，但不要认为它们是每个问题的万能药。
- en: Keeping Secure
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持安全
- en: The tools discussed in this chapter are not OpenBSD’s only security features.
    The OpenBSD team has put a lot of work into securing every part of the system.
    But this chapter covers some things that make OpenBSD special and gives you an
    idea of how those features work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的工具并不是OpenBSD的唯一安全特性。OpenBSD团队已经投入了大量工作来确保系统的每个部分都安全。但本章涵盖了使OpenBSD特殊的一些内容，并给你一个了解这些功能如何工作的想法。
- en: What’s the best path to security? Keep your system updated and configure your
    server daemons securely. It’s boring, but it works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通往安全的最佳路径是什么？保持你的系统更新，并安全地配置你的服务器守护进程。这很无聊，但有效。
- en: '* * *'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^([[26](#id385498)]) I’ve seen too many botnet or script kiddie intrusions go
    undetected for months to be comfortable blaming legitimate users for the majority
    of security problems. I would agree that “insider intrusions” are the most commonly
    identified intrusions, but frequently, that’s because the guilty user can’t keep
    his mouth shut.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[26](#id385498)]) 我看到太多僵尸网络或脚本小子入侵几个月都没有被发现，因此我不太愿意将大多数安全问题归咎于合法用户。我同意“内部入侵”是最常见的入侵方式，但通常是因为有罪的用户无法闭嘴。
